{"sha": "b331bf303bdc1edead41e2b3d11d1a7804b433cf", "node_id": "C_kwDOANBUbNoAKGIzMzFiZjMwM2JkYzFlZGVhZDQxZTJiM2QxMWQxYTc4MDRiNDMzY2Y", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2022-11-11T15:22:02Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2022-11-11T17:16:42Z"}, "message": "libstdc++: Fix wstring conversions in filesystem::path [PR95048]\n\nIn commit r9-7381-g91756c4abc1757 I changed filesystem::path to use\nstd::codecvt<CharT, char, mbstate_t> for conversions from all wide\nstrings to UTF-8, instead of using std::codecvt_utf8<CharT>. This was\ndone because for 16-bit wchar_t, std::codecvt_utf8<wchar_t> only\nsupports UCS-2 and not UTF-16. The rationale for the change was sound,\nbut the actual fix was not. It's OK to use std::codecvt for char16_t or\nchar32_t, because the specializations for those types always use UTF-8 ,\nbut std::codecvt<wchar_t, char, mbstate_t> uses the current locale's\nencodings, and the narrow encoding is probably ASCII and can't support\nnon-ASCII characters.\n\nThe correct fix is to use std::codecvt only for char16_t and char32_t.\nFor 32-bit wchar_t we could have continued using std::codecvt_utf8\nbecause that uses UTF-32 which is fine, switching to std::codecvt broke\nnon-Windows targets with 32-bit wchar_t. For 16-bit wchar_t we did need\nto change, but should have changed to std::codecvt_utf8_utf16<wchar_t>\ninstead, as that always uses UTF-16 not UCS-2. I actually noted that in\nthe commit message for r9-7381-g91756c4abc1757 but didn't use that\noption. Oops.\n\nThis replaces the unconditional std::codecvt<CharT, char, mbstate_t>\nwith a type defined via template specialization, so it can vary\ndepending on the wide character type. The code is also simplified to\nremove some of the mess of #ifdef and if-constexpr conditions.\n\nlibstdc++-v3/ChangeLog:\n\n\tPR libstdc++/95048\n\t* include/bits/fs_path.h (path::_Codecvt): New class template\n\tthat selects the kind of code conversion done.\n\t(path::_Codecvt<wchar_t>): Select based on sizeof(wchar_t).\n\t(_GLIBCXX_CONV_FROM_UTF8): New macro to allow the same code to\n\tbe used for Windows and POSIX.\n\t(path::_S_convert(const EcharT*, const EcharT*)): Simplify by\n\tusing _Codecvt and _GLIBCXX_CONV_FROM_UTF8 abstractions.\n\t(path::_S_str_convert(basic_string_view<value_type>, const A&)):\n\tSimplify nested conditions.\n\t* include/experimental/bits/fs_path.h (path::_Cvt): Define\n\tnested typedef controlling type of code conversion done.\n\t(path::_Cvt::_S_wconvert): Use new typedef.\n\t(path::string(const A&)): Likewise.\n\t* testsuite/27_io/filesystem/path/construct/95048.cc: New test.\n\t* testsuite/experimental/filesystem/path/construct/95048.cc: New\n\ttest.", "tree": {"sha": "cc1835b8ef964957683d95879280460744d84020", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cc1835b8ef964957683d95879280460744d84020"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b331bf303bdc1edead41e2b3d11d1a7804b433cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b331bf303bdc1edead41e2b3d11d1a7804b433cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b331bf303bdc1edead41e2b3d11d1a7804b433cf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b331bf303bdc1edead41e2b3d11d1a7804b433cf/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dab5d73959cfc8f03cba548777adda9a798e1f0e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dab5d73959cfc8f03cba548777adda9a798e1f0e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dab5d73959cfc8f03cba548777adda9a798e1f0e"}], "stats": {"total": 269, "additions": 203, "deletions": 66}, "files": [{"sha": "b1835573c6a271bc34e9d53eb69b949d13720e54", "filename": "libstdc++-v3/include/bits/fs_path.h", "status": "modified", "additions": 71, "deletions": 55, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b331bf303bdc1edead41e2b3d11d1a7804b433cf/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffs_path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b331bf303bdc1edead41e2b3d11d1a7804b433cf/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffs_path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffs_path.h?ref=b331bf303bdc1edead41e2b3d11d1a7804b433cf", "patch": "@@ -727,6 +727,8 @@ namespace __detail\n     _List _M_cmpts;\n \n     struct _Parser;\n+\n+    template<typename _EcharT> struct _Codecvt;\n   };\n \n   /// @{\n@@ -855,55 +857,72 @@ namespace __detail\n     size_t _M_pos;\n   };\n \n+  // path::_Codecvt<C> Performs conversions between C and path::string_type.\n+  // The native encoding of char strings is the OS-dependent current\n+  // encoding for pathnames. FIXME: We assume this is UTF-8 everywhere,\n+  // but should use a Windows API to query it.\n+\n+  // Converts between native pathname encoding and char16_t or char32_t.\n+  template<typename _EcharT>\n+    struct path::_Codecvt\n+    // Need derived class here because std::codecvt has protected destructor.\n+    : std::codecvt<_EcharT, char, mbstate_t>\n+    { };\n+\n+  // Converts between native pathname encoding and native wide encoding.\n+  // The native encoding for wide strings is the execution wide-character\n+  // set encoding. FIXME: We assume that this is either UTF-32 or UTF-16\n+  // (depending on the width of wchar_t). That matches GCC's default,\n+  // but can be changed with -fwide-exec-charset.\n+  // We need a custom codecvt converting the native pathname encoding\n+  // to/from the native wide encoding.\n+  template<>\n+    struct path::_Codecvt<wchar_t>\n+    : __conditional_t<sizeof(wchar_t) == sizeof(char32_t),\n+\t\t      std::codecvt_utf8<wchar_t>,       // UTF-8 <-> UTF-32\n+\t\t      std::codecvt_utf8_utf16<wchar_t>> // UTF-8 <-> UTF-16\n+    { };\n+\n   template<typename _EcharT>\n     auto\n     path::_S_convert(const _EcharT* __f, const _EcharT* __l)\n     {\n       static_assert(__detail::__is_encoded_char<_EcharT>);\n \n+#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS\n+# define _GLIBCXX_CONV_FROM_UTF8(S) __detail::__wstr_from_utf8(S)\n+#else\n+# define _GLIBCXX_CONV_FROM_UTF8(S) S\n+#endif\n+\n       if constexpr (is_same_v<_EcharT, value_type>)\n \treturn basic_string_view<value_type>(__f, __l - __f);\n-#if !defined _GLIBCXX_FILESYSTEM_IS_WINDOWS && defined _GLIBCXX_USE_CHAR8_T\n+#ifdef _GLIBCXX_USE_CHAR8_T\n       else if constexpr (is_same_v<_EcharT, char8_t>)\n-\t// For POSIX converting from char8_t to char is also 'noconv'\n-\treturn string_view(reinterpret_cast<const char*>(__f), __l - __f);\n-#endif\n-      else\n \t{\n+\t  string_view __str(reinterpret_cast<const char*>(__f), __l - __f);\n+\t  return _GLIBCXX_CONV_FROM_UTF8(__str);\n+\t}\n+#endif\n #ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS\n+      else if constexpr (is_same_v<_EcharT, char>)\n+\t{\n \t  std::wstring __wstr;\n-\t  if constexpr (is_same_v<_EcharT, char>)\n-\t    {\n-\t      struct _UCvt : std::codecvt<wchar_t, char, std::mbstate_t>\n-\t      { } __cvt;\n-\t      if (__str_codecvt_in_all(__f, __l, __wstr, __cvt))\n-\t\treturn __wstr;\n-\t    }\n-#ifdef _GLIBCXX_USE_CHAR8_T\n-\t  else if constexpr (is_same_v<_EcharT, char8_t>)\n-\t    {\n-\t      const auto __f2 = reinterpret_cast<const char*>(__f);\n-\t      return __detail::__wstr_from_utf8(string_view(__f2, __l - __f));\n-\t    }\n+\t  path::_Codecvt<wchar_t> __cvt;\n+\t  if (__str_codecvt_in_all(__f, __l, __wstr, __cvt))\n+\t    return __wstr;\n+\t}\n #endif\n-\t  else // char16_t or char32_t\n-\t    {\n-\t      struct _UCvt : std::codecvt<_EcharT, char, std::mbstate_t>\n-\t      { } __cvt;\n-\t      std::string __str;\n-\t      if (__str_codecvt_out_all(__f, __l, __str, __cvt))\n-\t\treturn __detail::__wstr_from_utf8(__str);\n-\t    }\n-#else // ! windows\n-\t  struct _UCvt : std::codecvt<_EcharT, char, std::mbstate_t>\n-\t  { } __cvt;\n+      else\n+\t{\n+\t  path::_Codecvt<_EcharT> __cvt;\n \t  std::string __str;\n \t  if (__str_codecvt_out_all(__f, __l, __str, __cvt))\n-\t    return __str;\n-#endif\n-\t  __detail::__throw_conversion_error();\n+\t    return _GLIBCXX_CONV_FROM_UTF8(__str);\n \t}\n+      __detail::__throw_conversion_error();\n     }\n+#undef _GLIBCXX_CONV_FROM_UTF8\n \n   /// @endcond\n \n@@ -1085,7 +1104,9 @@ namespace __detail\n       if (__str.size() == 0)\n \treturn _WString(__a);\n \n-#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS\n+#ifndef _GLIBCXX_FILESYSTEM_IS_WINDOWS\n+      string_view __u8str = __str;\n+#else\n       // First convert native string from UTF-16 to to UTF-8.\n       // XXX This assumes that the execution wide-character set is UTF-16.\n       std::codecvt_utf8_utf16<value_type> __cvt;\n@@ -1095,35 +1116,30 @@ namespace __detail\n       _String __u8str{_CharAlloc{__a}};\n       const value_type* __wfirst = __str.data();\n       const value_type* __wlast = __wfirst + __str.size();\n-      if (__str_codecvt_out_all(__wfirst, __wlast, __u8str, __cvt)) {\n+      if (!__str_codecvt_out_all(__wfirst, __wlast, __u8str, __cvt))\n+\t__detail::__throw_conversion_error();\n       if constexpr (is_same_v<_CharT, char>)\n \treturn __u8str; // XXX assumes native ordinary encoding is UTF-8.\n-      else {\n-\n-      const char* __first = __u8str.data();\n-      const char* __last = __first + __u8str.size();\n-#else\n-      const value_type* __first = __str.data();\n-      const value_type* __last = __first + __str.size();\n-#endif\n-\n-      // Convert UTF-8 string to requested format.\n-#ifdef _GLIBCXX_USE_CHAR8_T\n-      if constexpr (is_same_v<_CharT, char8_t>)\n-\treturn _WString(__first, __last, __a);\n       else\n #endif\n \t{\n-\t  // Convert UTF-8 to wide string.\n-\t  _WString __wstr(__a);\n-\t  struct _UCvt : std::codecvt<_CharT, char, std::mbstate_t> { } __cvt;\n-\t  if (__str_codecvt_in_all(__first, __last, __wstr, __cvt))\n-\t    return __wstr;\n-\t}\n+\t  const char* __first = __u8str.data();\n+\t  const char* __last = __first + __u8str.size();\n \n-#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS\n-      } }\n+\t  // Convert UTF-8 string to requested format.\n+#ifdef _GLIBCXX_USE_CHAR8_T\n+\t  if constexpr (is_same_v<_CharT, char8_t>)\n+\t    return _WString(__first, __last, __a);\n+\t  else\n #endif\n+\t    {\n+\t      // Convert UTF-8 to wide string.\n+\t      _WString __wstr(__a);\n+\t      path::_Codecvt<_CharT> __cvt;\n+\t      if (__str_codecvt_in_all(__first, __last, __wstr, __cvt))\n+\t\treturn __wstr;\n+\t    }\n+\t}\n       __detail::__throw_conversion_error();\n     }\n   /// @endcond"}, {"sha": "6e2f47f5e63d4ad6ffe164c28b9d7bcdfa4d18a3", "filename": "libstdc++-v3/include/experimental/bits/fs_path.h", "status": "modified", "additions": 40, "deletions": 11, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b331bf303bdc1edead41e2b3d11d1a7804b433cf/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fbits%2Ffs_path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b331bf303bdc1edead41e2b3d11d1a7804b433cf/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fbits%2Ffs_path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fbits%2Ffs_path.h?ref=b331bf303bdc1edead41e2b3d11d1a7804b433cf", "patch": "@@ -734,15 +734,47 @@ namespace __detail\n   template<>\n     struct path::_Cvt<path::value_type>\n     {\n+      // We need this type to be defined because we don't have `if constexpr`\n+      // in C++11 and so path::string<C,T,A>(const A&) needs to be able to\n+      // declare a variable of this type and pass it to __str_codecvt_in_all.\n+      using __codecvt_utf8_to_wide = _Cvt;\n+      // Dummy overload used for unreachable calls in path::string<C,T,A>.\n+      template<typename _WStr>\n+\tfriend bool\n+\t__str_codecvt_in_all(const char*, const char*,\n+\t\t\t     _WStr&, __codecvt_utf8_to_wide&) noexcept\n+\t{ return true; }\n+\n       template<typename _Iter>\n \tstatic string_type\n \t_S_convert(_Iter __first, _Iter __last)\n \t{ return string_type{__first, __last}; }\n     };\n \n+  // Performs conversions from _CharT to path::string_type.\n   template<typename _CharT>\n     struct path::_Cvt\n     {\n+      // FIXME: We currently assume that the native wide encoding for wchar_t\n+      // is either UTF-32 or UTF-16 (depending on the width of wchar_t).\n+      // See comments in <bits/fs_path.h> for further details.\n+      using __codecvt_utf8_to_wchar\n+\t= __conditional_t<sizeof(wchar_t) == sizeof(char32_t),\n+\t\t\t  std::codecvt_utf8<wchar_t>,        // from UTF-32\n+\t\t\t  std::codecvt_utf8_utf16<wchar_t>>; // from UTF-16\n+\n+      // Converts from char16_t or char32_t using std::codecvt<charNN_t, char>.\n+      // Need derived class here because std::codecvt has protected destructor.\n+      struct __codecvt_utf8_to_utfNN : std::codecvt<_CharT, char, mbstate_t>\n+      { };\n+\n+      // Convert from native pathname format (assumed to be UTF-8 everywhere)\n+      // to the encoding implied by the wide character type _CharT.\n+      using __codecvt_utf8_to_wide\n+\t= __conditional_t<is_same<_CharT, wchar_t>::value,\n+\t\t\t  __codecvt_utf8_to_wchar,\n+\t\t\t  __codecvt_utf8_to_utfNN>;\n+\n #ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS\n #ifdef _GLIBCXX_USE_CHAR8_T\n       static string_type\n@@ -760,7 +792,7 @@ namespace __detail\n       static string_type\n       _S_wconvert(const char* __f, const char* __l, const char*)\n       {\n-\tusing _Cvt = std::codecvt<wchar_t, char, mbstate_t>;\n+\tusing _Cvt = std::codecvt_utf8_utf16<wchar_t>;\n \tconst auto& __cvt = std::use_facet<_Cvt>(std::locale{});\n \tstd::wstring __wstr;\n \tif (__str_codecvt_in_all(__f, __l, __wstr, __cvt))\n@@ -773,8 +805,7 @@ namespace __detail\n       static string_type\n       _S_wconvert(const _CharT* __f, const _CharT* __l, const void*)\n       {\n-\tstruct _UCvt : std::codecvt<_CharT, char, std::mbstate_t>\n-\t{ } __cvt;\n+\t__codecvt_utf8_to_wide __cvt;\n \tstd::string __str;\n \tif (__str_codecvt_out_all(__f, __l, __str, __cvt))\n \t  {\n@@ -805,8 +836,7 @@ namespace __detail\n \telse\n #endif\n \t  {\n-\t    struct _UCvt : std::codecvt<_CharT, char, std::mbstate_t>\n-\t    { } __cvt;\n+\t    __codecvt_utf8_to_wide __cvt;\n \t    std::string __str;\n \t    if (__str_codecvt_out_all(__f, __l, __str, __cvt))\n \t      return __str;\n@@ -1013,7 +1043,7 @@ namespace __detail\n     inline std::basic_string<_CharT, _Traits, _Allocator>\n     path::string(const _Allocator& __a) const\n     {\n-      if (is_same<_CharT, value_type>::value)\n+      if _GLIBCXX_CONSTEXPR (is_same<_CharT, value_type>::value)\n \treturn { _M_pathname.begin(), _M_pathname.end(), __a };\n \n       using _WString = basic_string<_CharT, _Traits, _Allocator>;\n@@ -1049,9 +1079,8 @@ namespace __detail\n \t      else\n #endif\n \t        {\n-\t          // Convert UTF-8 to wide string.\n-\t          struct _UCvt : std::codecvt<_CharT, char, std::mbstate_t>\n-\t\t  { } __cvt;\n+\t\t  // Convert UTF-8 to char16_t or char32_t string.\n+\t\t  typename path::_Cvt<_CharT>::__codecvt_utf8_to_wide __cvt;\n \t          const char* __f = __from.data();\n \t          const char* __l = __f + __from.size();\n \t          if (__str_codecvt_in_all(__f, __l, __to, __cvt))\n@@ -1064,14 +1093,14 @@ namespace __detail\n \t  if (auto* __p = __dispatch(__u8str, __wstr, is_same<_CharT, char>{}))\n \t    return *__p;\n \t}\n-#else\n+#else // ! Windows\n #ifdef _GLIBCXX_USE_CHAR8_T\n       if constexpr (is_same<_CharT, char8_t>::value)\n           return _WString(__first, __last, __a);\n       else\n #endif\n         {\n-          struct _UCvt : std::codecvt<_CharT, char, std::mbstate_t> { } __cvt;\n+\t  typename path::_Cvt<_CharT>::__codecvt_utf8_to_wide __cvt;\n           _WString __wstr(__a);\n           if (__str_codecvt_in_all(__first, __last, __wstr, __cvt))\n \t    return __wstr;"}, {"sha": "c1a382d14204d48e2d359e2a10725350e83af592", "filename": "libstdc++-v3/testsuite/27_io/filesystem/path/construct/95048.cc", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b331bf303bdc1edead41e2b3d11d1a7804b433cf/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fconstruct%2F95048.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b331bf303bdc1edead41e2b3d11d1a7804b433cf/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fconstruct%2F95048.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilesystem%2Fpath%2Fconstruct%2F95048.cc?ref=b331bf303bdc1edead41e2b3d11d1a7804b433cf", "patch": "@@ -0,0 +1,45 @@\n+// { dg-do run { target c++17 } }\n+\n+// C++17 30.10.8.4.1 path constructors [fs.path.construct]\n+\n+#include <filesystem>\n+#include <testsuite_hooks.h>\n+\n+using std::filesystem::path;\n+\n+#define CHECK(E, S) (path(E##S) == path(u8##S))\n+\n+void\n+test_wide()\n+{\n+  VERIFY( CHECK(L, \"\\u00E4\") ); // PR libstdc++/95048\n+  VERIFY( CHECK(L, \"\\U0001F4C1\") ); // folder\n+  VERIFY( CHECK(L, \"\\U0001F4C2\") ); // open folder\n+  VERIFY( CHECK(L, \"\\U0001F4C4\") ); // filing cabient\n+}\n+\n+void\n+test_u16()\n+{\n+  VERIFY( CHECK(u, \"\\u00E4\") ); // PR libstdc++/95048\n+  VERIFY( CHECK(u, \"\\U0001F4C1\") ); // folder\n+  VERIFY( CHECK(u, \"\\U0001F4C2\") ); // open folder\n+  VERIFY( CHECK(u, \"\\U0001F4C4\") ); // filing cabient\n+}\n+\n+void\n+test_u32()\n+{\n+  VERIFY( CHECK(U, \"\\u00E4\") ); // PR libstdc++/95048\n+  VERIFY( CHECK(U, \"\\U0001F4C1\") ); // folder\n+  VERIFY( CHECK(U, \"\\U0001F4C2\") ); // open folder\n+  VERIFY( CHECK(U, \"\\U0001F4C4\") ); // filing cabient\n+}\n+\n+int\n+main()\n+{\n+  test_wide();\n+  test_u16();\n+  test_u32();\n+}"}, {"sha": "b7a93f3c98568b92a111e6ac4ad08948807e5e69", "filename": "libstdc++-v3/testsuite/experimental/filesystem/path/construct/95048.cc", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b331bf303bdc1edead41e2b3d11d1a7804b433cf/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fconstruct%2F95048.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b331bf303bdc1edead41e2b3d11d1a7804b433cf/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fconstruct%2F95048.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Ffilesystem%2Fpath%2Fconstruct%2F95048.cc?ref=b331bf303bdc1edead41e2b3d11d1a7804b433cf", "patch": "@@ -0,0 +1,47 @@\n+// { dg-options \"-lstdc++fs\" }\n+// { dg-do run { target c++11 } }\n+// { dg-require-filesystem-ts \"\" }\n+\n+// 8.4.1 path constructors [path.construct]\n+\n+#include <experimental/filesystem>\n+#include <testsuite_hooks.h>\n+\n+using std::experimental::filesystem::path;\n+\n+#define CHECK(E, S) (path(E##S) == path(u8##S))\n+\n+void\n+test_wide()\n+{\n+  VERIFY( CHECK(L, \"\\u00E4\") ); // PR libstdc++/95048\n+  VERIFY( CHECK(L, \"\\U0001F4C1\") ); // folder\n+  VERIFY( CHECK(L, \"\\U0001F4C2\") ); // open folder\n+  VERIFY( CHECK(L, \"\\U0001F4C4\") ); // filing cabient\n+}\n+\n+void\n+test_u16()\n+{\n+  VERIFY( CHECK(u, \"\\u00E4\") ); // PR libstdc++/95048\n+  VERIFY( CHECK(u, \"\\U0001F4C1\") ); // folder\n+  VERIFY( CHECK(u, \"\\U0001F4C2\") ); // open folder\n+  VERIFY( CHECK(u, \"\\U0001F4C4\") ); // filing cabient\n+}\n+\n+void\n+test_u32()\n+{\n+  VERIFY( CHECK(U, \"\\u00E4\") ); // PR libstdc++/95048\n+  VERIFY( CHECK(U, \"\\U0001F4C1\") ); // folder\n+  VERIFY( CHECK(U, \"\\U0001F4C2\") ); // open folder\n+  VERIFY( CHECK(U, \"\\U0001F4C4\") ); // filing cabient\n+}\n+\n+int\n+main()\n+{\n+  test_wide();\n+  test_u16();\n+  test_u32();\n+}"}]}