{"sha": "400500c4a50104969a303ba3c41983b134523e15", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDAwNTAwYzRhNTAxMDQ5NjlhMzAzYmEzYzQxOTgzYjEzNDUyM2UxNQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2001-02-04T22:44:12Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2001-02-04T22:44:12Z"}, "message": "diagnostic.h (set_internal_error_function): Renamed.\n\n\t* diagnostic.h (set_internal_error_function): Renamed.\n\t* toplev.h (internal_error): Renamed from fatal.\n\t(pfatal_with_name): Deleted.\n\t(fatal_io_error): Now has printf-style arguments.\n\t* diagnostic.c (pfatal_with_name): Deleted.\n\t(fatal_io_error): Rework to have args in printf-style.\n\t(set_internal_error_function): Renamed from set_fatal_function.\n\t(internal_error): Renamed from fatal.\n\t(error_recursion, fancy_abort): Call internal_error instead of fatal.\n\t* dwarf2out.c (get_cfa_from_loc_descr): Likewise.\n\t* emit-rtl.c (gen_realpart, gen_imagpart): Likewise.\n\t* expr.c (check_max_integer_computation_mode, expand_expr): Likewise.\n\t* flow.c (verify_flow_info): Likewise.\n\t* config/arm/arm.c (thumb_unexpanded_epilogue): Likewise.\n\t* config/mips/mips.c (save_restore_insns): Likewise.\n\t* cp/init.c (build_java_class_ref): Likewise.\n\t(dsp16xx_reg_class_from_letter): Likewise.\n\t(limit_reload_class, double_reg_to_memory): Likewise.\n\t(print_operand_address, emit_1600_code_shift): Likewise.\n\t(gen_tst_reg, gen_compare_reg): Likewise.\n\t* config/m68hc11/m68hc11.c (m68hc11_emit_libcall): Likewise.\n\t* cp/decl.c (pushdecl): Likewise.\n\t* java/check-init.c (check_init): Likewise.\n\t* java/expr.c (java_lang_expand_expr): Likewise.\n\t* java/jcf-parse.c (get_constant): Likewise.\n\t* java/mangle.c (java_mangle_decl): Likewise.\n\t* java/parse.y (make_nested_class_name, java_complete_lhs): Likewise.\n\t(operator_string): Likewise.\n\n\t* except.c (duplicate_eh_handlers): Call abort instead of fatal.\n\t* flow.c (verify_flow_info): Likewise.\n\t* ch/convert.c (convert): Likewise.\n\t* ch/except.c (pop_handler, chill_check_no_handlers): Likewise.\n\t* ch/expr.c (chill_expand_expr): Likewise.\n\t* ch/parse.c (peek_token_, pushback_token, require): Likewise.\n\t* config/arm/arm.c (thumb_load_double_from_address): Likewise.\n\t* config/avr/avr.c (pttreg_to_str, unique_section): Likewise.\n\t(avr_normalize_condition): Likewise.\n\t* config/c4x/c4x.c (c4x_emit_libcall, c4x_valid_operands): Likewise.\n\t* config/dsp16xx/dsp16xx.c (dsp16xx_reg_class_from_letter): Likewise.\n\t(limit_reload_class, double_reg_to_memory): Likewise.\n\t(print_operand_address, emit_1600_code_shift): Likewise.\n\t(gen_tst_reg, gen_compare_reg): Likewise.\n\t* config/m68hc11/m68hc11.c (m68hc11_emit_libcall): Likewise.\n\t* cp/decl.c (pushdecl): Likewise.\n\t* java/check-init.c (check_init): Likewise.\n\t* java/class.c (build_class_ref): Likewise.\n\t* java/constants.c (write_constant_pool): Likewise.\n\t* java/decl.c (start_java_method): Likewise.\n\t* java/expr.c (push_type, java_stack_pop, java_stack_swap): Likewise.\n\t(java_stack_dup, encode_newarray_type): Likewise.\n\t(build_java_array_length_access): Likewise.\n\t(build_java_check_indexed_type, expand_java_pushc): Likewise.\n\t(build_java_soft_divmod, build_invokeinterface): Likewise.\n\t* java/java-tree.h (INNER_CLASS_P): Likewise.\n\t* java/jcf-parse.c (parse_signature, get_name_constant): Likewise.\n\t(give_name_to_class, get_class_constant): Likewise.\n\t* java/jcf-write.c (CHECK_PUT, CHECK_OP, get_access_flags): Likewise.\n\t(find_constant_index, generate_bytecode_conditional): Likewise.\n\t(generate_bytecode_insns, perform_relocations): Likewise.\n\t* java/lex.c (java_unget_unicode, java_lex): Likewise.\n\t* java/mangle.c (mangle_type, mangle_record_type): Likewise.\n\t(mangle_pointer_type, mangle_array_type, init_mangling): Likewise.\n\t(finish_mangling): Likewise.\n\t* java/parse.h (MARK_FINAL_PARMS): Likewise.\n\t* java/parse.y (pop_current_osb, unreachable_stmt_error): Likewise.\n\t(obtain_incomplete_type, java_complete_class): Likewise.\n\t(java_check_regular_methods, java_complete_expand_method): Likewise.\n\t(cut_identifier_in_qualified, check_deprecation): Likewise.\n\t(patch_invoke, find_applicable_accessible_methods_list): Likewise.\n\t(java_complete_lhs, lookup_name_in_blocks): Likewise.\n\t(check_final_variable_indirect_assignment, build_unaryop): Likewise.\n\t* java/typeck.c (set_local_type, parse_signature_type): Likewise.\n\t(parse_signature_string, build_java_signature): Likewise;\n\t(set_java_signature): Likewise.\n\t* java/verify.c (type_stack_dup, CHECK_PC_IN_RANGE): Likewise.\n\n\t* c-parse.in (methoddef): Call fatal_error instead of fatal.\n\t* objc/objc-act.c (build_ivar_chain): Likewise.\n\t* cp/except.c (decl_is_java_type): Likewise.\n\t* cp/init.c (build_java_class_ref): Likewise.\n\t* cp/init.c (build_new_1): Likewise.\n\t* f/com.c (ffecom_init_0): Likewise.\n\t* java/class.c (add_method, build_static_field_ref): Likewise.\n\t* java/expr.c (build_known_method_ref, expand_invoke): Likewise.\n\t* java/jcf-parse.c (get_constant, jcf_parse): Likewise.\n\t* java/lex.c (java_new_new_lexer): Likewise.\n\t* java/jv-scan.c (main): Likewise.\n\t(fatal_error): Renamed from fatal.\n\n\t* dwarfout.c (dwarfout_init): Call fatal_io_error instead of\n\tpfatal_with_name.\n\t* graph.c (clean_graph_dump_file): Likewise.\n\t* profile.c (init_branch_prob): Likewise.\n\t* ch/grant.c (write_grant_file): Likewise.\n\t* ch/lex.c (init_parse, same_file, yywrap): Likewise.\n\t* f/com.c (init_parse): Likewise.\n\t* java/jcf-parse.c (yyparse): Likewise.\n\t* objc/objc-act.c (objc_init): Likewise.\n\n\t* java/jcf-parse.c (jcf_parse_source): Call fatal_io_error, not fatal.\n\t(yyparse): Likewise.\n\t* java/jcf-write.c (make_class_file_name, write_classfile): Likewise.\n\t* java/lex.c (java_get_line_col): Likewise.\n\n\t* hash.c (hash_allocate): Don't check for failure returns from\n\tobstack functions that can't fail.\n\t(hash_table_init_n, hash_table_init): Likewise; also now return void.\n\t* hash.h (hash_table_init_n, hash_table_init): Now return void.\n\t* cp/decl.c (build_typename_type): hash_table_init now returns void.\n\n\t* ch/lang.c (GNU_xref_begin, GNU_xref_end): Deleted.\n\t* ch/lex.c (convert_bitstring): Delete check for alloca failure.\n\t* config/dsp16xx/dsp16xx.c (dsp16xx_invalid_register_for_compare):\n\tDeleted.\n\t* config/dsp16xx/dsp16xx.md (unnamed cmphi): Call abort instead of it.\n\n\t* f/com.c (ffecom_decode_include_option_): Make errors non-fatal.\n\t* f/lex.c (ffelex_cfelex_, ffelex_get_directive_line_): Likewise.\n\t(ffelex_hash_): Likewise.\n\t* config/arm/arm.c (arm_override_options): Likewise.\n\t* config/avr/avr.c (avr_override_options): Likewise.\n\t* config/c4x/c4x.c (c4x_expand_prologue): Likewise.\n\t* config/dsp16xx/dsp16xx.c (function_prologue): Likewise.\n\t* config/h8300/h8300.c (h8300_init_once): Likewise.\n\t* config/mips/mips.c (override_options): Likewise.\n\t* config/i386/i386.c (override_options): Likewise, rework.\n\t* config/m68k/m68k.c (override_options): Likewise.\n\t* cp/decl.c (init_decl_processing): Likewise.\n\t* java/jcf-parse.c (load_class): Likewise.\n\n\t* config/dsp16xx/dsp16xx.c (print_operand): Call output_operand_lossage\n\tinstead of fatal.\n\t* config/mips/mips.c (print_operand): Likewise.\n\n\t* java/lex.c (byteswap_init, need_byteswap): Only #ifdef HAVE_ICONV.\n\t* objc/objc_act.c (objc_check_decl): Remove unneeded fatal call.\n\t(get_object_reference): Likewise.\n\nFrom-SVN: r39443", "tree": {"sha": "8141b8180c25362fac62609d1e35c61c9cc898f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8141b8180c25362fac62609d1e35c61c9cc898f6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/400500c4a50104969a303ba3c41983b134523e15", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/400500c4a50104969a303ba3c41983b134523e15", "html_url": "https://github.com/Rust-GCC/gccrs/commit/400500c4a50104969a303ba3c41983b134523e15", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/400500c4a50104969a303ba3c41983b134523e15/comments", "author": null, "committer": null, "parents": [{"sha": "eab4abeb4d4463182fe24fe3ef8a7b40d1a1eec5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eab4abeb4d4463182fe24fe3ef8a7b40d1a1eec5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eab4abeb4d4463182fe24fe3ef8a7b40d1a1eec5"}], "stats": {"total": 1318, "additions": 754, "deletions": 564}, "files": [{"sha": "3a77f7c2f1e16af492af3b82a0315ccbcdc0aad3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/400500c4a50104969a303ba3c41983b134523e15/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/400500c4a50104969a303ba3c41983b134523e15/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=400500c4a50104969a303ba3c41983b134523e15", "patch": "@@ -1,3 +1,63 @@\n+Sun Feb  4 15:52:44 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* diagnostic.h (set_internal_error_function): Renamed.\n+\t* toplev.h (internal_error): Renamed from fatal.\n+\t(pfatal_with_name): Deleted.\n+\t(fatal_io_error): Now has printf-style arguments.\n+\t* diagnostic.c (pfatal_with_name): Deleted.\n+\t(fatal_io_error): Rework to have args in printf-style.\n+\t(set_internal_error_function): Renamed from set_fatal_function.\n+\t(internal_error): Renamed from fatal.\n+\t(error_recursion, fancy_abort): Call internal_error instead of fatal.\n+\t* dwarf2out.c (get_cfa_from_loc_descr): Likewise.\n+\t* emit-rtl.c (gen_realpart, gen_imagpart): Likewise.\n+\t* expr.c (check_max_integer_computation_mode, expand_expr): Likewise.\n+\t* flow.c (verify_flow_info): Likewise.\n+\t* config/arm/arm.c (thumb_unexpanded_epilogue): Likewise.\n+\t* config/mips/mips.c (save_restore_insns): Likewise.\n+\n+\t* except.c (duplicate_eh_handlers): Call abort instead of fatal.\n+\t* flow.c (verify_flow_info): Likewise.\t\n+\t* config/arm/arm.c (thumb_load_double_from_address): Likewise.\n+\t* config/avr/avr.c (pttreg_to_str, unique_section): Likewise.\n+\t(avr_normalize_condition): Likewise.\n+\t* config/c4x/c4x.c (c4x_emit_libcall, c4x_valid_operands): Likewise.\n+\t* config/dsp16xx/dsp16xx.c (dsp16xx_reg_class_from_letter): Likewise.\n+\t(limit_reload_class, double_reg_to_memory): Likewise.\n+\t(print_operand_address, emit_1600_code_shift): Likewise.\n+\t(gen_tst_reg, gen_compare_reg): Likewise.\n+\t* config/m68hc11/m68hc11.c (m68hc11_emit_libcall): Likewise.\n+\t* config/dsp16xx/dsp16xx.c (dsp16xx_invalid_register_for_compare):\n+\tDeleted.\n+\t* config/dsp16xx/dsp16xx.md (unnamed cmphi): Call abort instead of it.\n+\n+\t* c-parse.in (methoddef): Call fatal_error instead of fatal.\n+\t* objc/objc-act.c (build_ivar_chain): Likewise.\n+\t* dwarfout.c (dwarfout_init): Call fatal_io_error instead of\n+\tpfatal_with_name.\n+\t* graph.c (clean_graph_dump_file): Likewise.\n+\t* profile.c (init_branch_prob): Likewise.\n+\t* objc/objc-act.c (objc_init): Likewise.\n+\t\n+\t* config/arm/arm.c (arm_override_options): Make errors non-fatal.\n+\t* config/avr/avr.c (avr_override_options): Likewise.\t\n+\t* config/c4x/c4x.c (c4x_expand_prologue): Likewise.\n+\t* config/dsp16xx/dsp16xx.c (function_prologue): Likewise.\n+\t* config/h8300/h8300.c (h8300_init_once): Likewise.\n+\t* config/mips/mips.c (override_options): Likewise.\n+\t* config/i386/i386.c (override_options): Likewise, rework.\n+\t* config/m68k/m68k.c (override_options): Likewise.\n+\n+\t* config/dsp16xx/dsp16xx.c (print_operand): Call output_operand_lossage\n+\tinstead of fatal.\n+\t* config/mips/mips.c (print_operand): Likewise.\n+\t* hash.c (hash_allocate): Don't check for failure returns from\n+\tobstack functions that can't fail.\n+\t(hash_table_init_n, hash_table_init): Likewise; also now return void.\n+\t* hash.h (hash_table_init_n, hash_table_init): Now return void.\n+\t* objc/objc_act.c (objc_check_decl): Remove unneeded fatal call.\n+\t(get_object_reference): Likewise.\n+\n 2001-02-04  Nick Clifton  <nickc@redhat.com>\n \n \t* config/arm/arm.c (all_cores): Add 710T, 720T, 740T, 940T, 9e,"}, {"sha": "4f1de58772cfff3196acd3f5af1c0d15a1492091", "filename": "gcc/c-parse.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/400500c4a50104969a303ba3c41983b134523e15/gcc%2Fc-parse.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/400500c4a50104969a303ba3c41983b134523e15/gcc%2Fc-parse.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parse.in?ref=400500c4a50104969a303ba3c41983b134523e15", "patch": "@@ -2501,7 +2501,7 @@ methoddef:\n \t\t  if (objc_implementation_context)\n \t\t    objc_inherit_code = CLASS_METHOD_DECL;\n                   else\n-\t\t    fatal (\"method definition not in class context\");\n+\t\t    fatal_error (\"method definition not in class context\");\n \t\t}\n \t  methoddecl\n \t\t{\n@@ -2526,7 +2526,7 @@ methoddef:\n \t\t  if (objc_implementation_context)\n \t\t    objc_inherit_code = INSTANCE_METHOD_DECL;\n                   else\n-\t\t    fatal (\"method definition not in class context\");\n+\t\t    fatal_error (\"method definition not in class context\");\n \t\t}\n \t  methoddecl\n \t\t{"}, {"sha": "53dd0dd0f095cf1f76f054bd87a0d68074c92684", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/400500c4a50104969a303ba3c41983b134523e15/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/400500c4a50104969a303ba3c41983b134523e15/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=400500c4a50104969a303ba3c41983b134523e15", "patch": "@@ -573,7 +573,7 @@ arm_override_options ()\n     target_flags |= ARM_FLAG_APCS_FRAME;\n   \n   if (TARGET_APCS_REENT && flag_pic)\n-    fatal (\"-fpic and -mapcs-reent are incompatible\");\n+    error (\"-fpic and -mapcs-reent are incompatible\");\n   \n   if (TARGET_APCS_REENT)\n     warning (\"APCS reentrant code not supported.  Ignored\");\n@@ -621,7 +621,7 @@ arm_override_options ()\n       else if (streq (target_fp_name, \"3\"))\n \tarm_fpu_arch = FP_SOFT3;\n       else\n-\tfatal (\"Invalid floating point emulation option: -mfpe-%s\",\n+\terror (\"Invalid floating point emulation option: -mfpe-%s\",\n \t       target_fp_name);\n     }\n   else\n@@ -9425,6 +9425,7 @@ is_called_in_ARM_mode (func)\n }\n \n /* The bits which aren't usefully expanded as rtl. */\n+\n const char *\n thumb_unexpanded_epilogue ()\n {\n@@ -9489,7 +9490,8 @@ thumb_unexpanded_epilogue ()\n       if (mask == 0)\n \t/* Oh dear!  We have no low registers into which we can pop\n            high registers!  */\n-\tfatal (\"No low registers available for popping high registers\");\n+\tinternal_error\n+\t  (\"no low registers available for popping high registers\");\n       \n       for (next_hi_reg = 8; next_hi_reg < 13; next_hi_reg++)\n \tif (regs_ever_live[next_hi_reg] && !call_used_regs[next_hi_reg]\n@@ -10066,7 +10068,7 @@ output_thumb_prologue (f)\n \n const char *\n thumb_load_double_from_address (operands)\n-     rtx * operands;\n+     rtx *operands;\n {\n   rtx addr;\n   rtx base;\n@@ -10075,13 +10077,10 @@ thumb_load_double_from_address (operands)\n   rtx arg2;\n   \n   if (GET_CODE (operands[0]) != REG)\n-    fatal (\"thumb_load_double_from_address: destination is not a register\");\n+    abort ();\n   \n   if (GET_CODE (operands[1]) != MEM)\n-    {\n-      debug_rtx (operands[1]);\n-      fatal (\"thumb_load_double_from_address: source is not a computed memory address\");\n-    }\n+    abort ();\n \n   /* Get the memory address.  */\n   addr = XEXP (operands[1], 0);\n@@ -10124,7 +10123,7 @@ thumb_load_double_from_address (operands)\n \tbase = arg1, offset = arg2;\n   \n       if (GET_CODE (base) != REG)\n-\tfatal (\"thumb_load_double_from_address: base is not a register\");\n+\tabort ();\n \n       /* Catch the case of <address> = <reg> + <reg> */\n       if (GET_CODE (offset) == REG)\n@@ -10181,8 +10180,7 @@ thumb_load_double_from_address (operands)\n       break;\n       \n     default:\n-      debug_rtx (operands[1]);\n-      fatal (\"thumb_load_double_from_address: Unhandled address calculation\");\n+      abort ();\n       break;\n     }\n   "}, {"sha": "b01f9519859506a83f146abf6a5a71c6bd455ab6", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 11, "deletions": 19, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/400500c4a50104969a303ba3c41983b134523e15/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/400500c4a50104969a303ba3c41983b134523e15/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=400500c4a50104969a303ba3c41983b134523e15", "patch": "@@ -182,18 +182,18 @@ avr_override_options ()\n \t       avr_mcu_name);\n       for (t = avr_mcu_types; t->name; t++)\n \tfprintf (stderr,\"   %s\\n\", t->name);\n-      fatal (\"select right MCU name\");\n     }\n \n   switch (t->arch)\n     {\n-      case AVR1:\n-      default:\n-\tfatal (\"MCU `%s' not supported\", avr_mcu_name);\n-      case AVR2: avr_enhanced_p = 0; avr_mega_p = 0; break;\n-      case AVR3: avr_enhanced_p = 0; avr_mega_p = 1; break;\n-      case AVR4: avr_enhanced_p = 1; avr_mega_p = 0; break;\n-      case AVR5: avr_enhanced_p = 1; avr_mega_p = 1; break;\n+    case AVR1:\n+    default:\n+      error (\"MCU `%s' not supported\", avr_mcu_name);\n+      /* ... fall through ... */\n+    case AVR2: avr_enhanced_p = 0; avr_mega_p = 0; break;\n+    case AVR3: avr_enhanced_p = 0; avr_mega_p = 1; break;\n+    case AVR4: avr_enhanced_p = 1; avr_mega_p = 0; break;\n+    case AVR5: avr_enhanced_p = 1; avr_mega_p = 1; break;\n     }\n \n   if (optimize && !TARGET_NO_TABLEJUMP)\n@@ -910,7 +910,7 @@ ptrreg_to_str (regno)\n     case REG_Y: return \"Y\";\n     case REG_Z: return \"Z\";\n     default:\n-      fatal (\"register r%d isn't a pointer\\n\", regno);\n+      abort ();\n     }\n   return NULL;\n }\n@@ -933,21 +933,13 @@ cond_string (code)\n \treturn \"pl\";\n       else\n \treturn \"ge\";\n-    case GT:\n-      fatal (\"Internal compiler bug: command `bgt'\");\n-    case LE:\n-      fatal (\"Internal compiler bug: command `ble'\");\n     case LT:\n       if (cc_prev_status.flags & CC_OVERFLOW_UNUSABLE)\n \treturn \"mi\";\n       else\n \treturn \"lt\";\n     case GEU:\n       return \"sh\";\n-    case GTU:\n-      fatal (\"Internal compiler bug: command `bgtu'\");\n-    case LEU:\n-      fatal (\"Internal compiler bug: command `bleu'\");\n     case LTU:\n       return \"lo\";\n     default:\n@@ -4532,7 +4524,7 @@ unique_section (decl, reloc)\n \tprefix = \".text\";\n     }\n   else \n-    fatal (\"Strange situation: unique section is not a FUNCTION_DECL\");\n+    abort ();\n \n   if (flag_function_sections)\n     {\n@@ -5009,7 +5001,7 @@ avr_normalize_condition (condition)\n     case LEU:\n       return LTU;\n     default:\n-      fatal (\"Wrong condition: %s\", GET_RTX_NAME (condition));\n+      abort ();\n     }\n }\n "}, {"sha": "48f4451ad69059c328b01f0debabdd4ef9bad3fd", "filename": "gcc/config/c4x/c4x.c", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/400500c4a50104969a303ba3c41983b134523e15/gcc%2Fconfig%2Fc4x%2Fc4x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/400500c4a50104969a303ba3c41983b134523e15/gcc%2Fconfig%2Fc4x%2Fc4x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.c?ref=400500c4a50104969a303ba3c41983b134523e15", "patch": "@@ -1,26 +1,26 @@\n /* Subroutines for assembler code output on the TMS320C[34]x\n-   Copyright (C) 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000 Free Software Foundation, Inc.\n+   Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001\n+   Free Software Foundation, Inc.\n \n    Contributed by Michael Hayes (m.hayes@elec.canterbury.ac.nz)\n               and Herman Ten Brugge (Haj.Ten.Brugge@net.HCC.nl).\n \n-   This file is part of GNU CC.\n+This file is part of GNU CC.\n \n-   GNU CC is free software; you can redistribute it and/or modify\n-   it under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 2, or (at your option)\n-   any later version.\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n \n-   GNU CC is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-   GNU General Public License for more details.\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n \n-   You should have received a copy of the GNU General Public License\n-   along with GNU CC; see the file COPYING.  If not, write to\n-   the Free Software Foundation, 59 Temple Place - Suite 330,\n-   Boston, MA 02111-1307, USA.  */\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n \n /* Some output-actions in c4x.md need these.  */\n #include \"config.h\"\n@@ -858,8 +858,9 @@ c4x_expand_prologue ()\n \t     requires more than 32767 words of local temporary\n \t     storage!  */\n \t  if (size > 32767)\n-\t    fatal (\"ISR %s requires %d words of local vars, max is 32767.\",\n+\t    error (\"ISR %s requires %d words of local vars, max is 32767.\",\n \t\t   current_function_name, size);\n+\n \t  insn = emit_insn (gen_addqi3 (gen_rtx_REG (QImode, SP_REGNO),\n \t\t\t\t        gen_rtx_REG (QImode, SP_REGNO),\n \t\t\t\t\tGEN_INT (size)));\n@@ -1408,7 +1409,7 @@ c4x_emit_libcall (libcall, code, dmode, smode, noperands, operands)\n       break;\n \n     default:\n-      fatal (\"c4x_emit_libcall: Bad number of operands\");\n+      abort ();\n     }\n \n   insns = get_insns ();\n@@ -3970,7 +3971,7 @@ c4x_valid_operands (code, operands, mode, force)\n       break;\n       \n     default:\n-      fatal (\"c4x_valid_operands: Internal error\");\n+      abort ();\n       break;\n     }\n       "}, {"sha": "c74ac3884111186c896d0ea5c02df6dad7daef5a", "filename": "gcc/config/dsp16xx/dsp16xx.c", "status": "modified", "additions": 79, "deletions": 86, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/400500c4a50104969a303ba3c41983b134523e15/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/400500c4a50104969a303ba3c41983b134523e15/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.c?ref=400500c4a50104969a303ba3c41983b134523e15", "patch": "@@ -1,5 +1,5 @@\n /* Subroutines for assembler code output on the DSP1610.\n-   Copyright (C) 1994, 1995, 1997, 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1994, 1995, 1997, 1998, 2001 Free Software Foundation, Inc.\n    Contributed by Michael Collison (collison@world.std.com).\n \n This file is part of GNU CC.\n@@ -268,8 +268,7 @@ dsp16xx_reg_class_from_letter (c)\n       return SLOW_MEM_LOAD_REGS;\n \n     default:\n-      fatal (\"Invalid register class letter %c\", c);\n-      return NO_REGS;\n+      abort ();\n     }\n }\n /* Return the class number of the smallest class containing\n@@ -371,7 +370,7 @@ limit_reload_class (mode, class)\n       return class;\n \n     case ACCUM_HIGH_REGS:\n-      fatal (\"ACCUM_HIGH_REGS class in limit_reload_class\");\n+      abort ();\n \n     case A1L_REG:\n     case ACCUM_LOW_REGS:\n@@ -398,16 +397,15 @@ limit_reload_class (mode, class)\n       return class;\n \n     case YH_OR_ACCUM_HIGH_REGS:\n-      fatal (\"YH_OR_ACCUM_HIGH_REGS found in limit_reload_class\");\n+      abort ();\n \n     case X_OR_YH_REGS:\n       return class;\n \n     case YL_REG:\n       /* Register 'yl' is invalid for QImode, so we should never\n \t see it. */\n-\n-      fatal (\"YL found in limit_reload_class\");\n+      abort ();\n \n     case YL_OR_ACCUM_LOW_REGS:\n     case X_OR_YL_REGS:\n@@ -1220,51 +1218,48 @@ function_prologue (file, size)\n     {\n       if (current_frame_info.var_size == 1)\n \tfprintf (file, \"\\t*%s++\\n\", sp);\n+      else if (SMALL_INTVAL (current_frame_info.var_size)\n+\t       && ((current_frame_info.var_size & 0x8000) == 0))\n+\tfprintf (file, \"\\t%s=%ld\\n\\t*%s++%s\\n\", reg_names[REG_J],\n+\t\t current_frame_info.var_size, sp, reg_names[REG_J]);\n       else\n-        {\n-\t  if(SMALL_INTVAL(current_frame_info.var_size) && ((current_frame_info.var_size & 0x8000) == 0))\n-\t    fprintf (file, \"\\t%s=%ld\\n\\t*%s++%s\\n\", reg_names[REG_J], current_frame_info.var_size, sp, reg_names[REG_J]);\n-\t  else\n-\t    fatal (\"Stack size > 32k\");\n-\t}\n+\terror (\"Stack size > 32k\");\n     }\n   \n-  /* Save any registers this function uses, unless they are\n-   * used in a call, in which case we don't need to\n-   */\n+  /* Save any registers this function uses, unless they are used in a call,\n+     in which case we don't need to.  */\n   \n-  for( regno = 0; regno < FIRST_PSEUDO_REGISTER; ++ regno )\n+  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; ++ regno)\n     if (dsp16xx_call_saved_register (regno)) \n       {\n #if OLD_REGISTER_SAVE\n-\tfprintf( file, \"\\t*%s++=%s\\n\", sp, reg_names[regno] );\n+\tfprintf (file, \"\\t*%s++=%s\\n\", sp, reg_names[regno]);\n #else\n-\tfprintf( file, \"\\tpush(*%s)=%s\\n\", sp, reg_names[regno] );\n+\tfprintf (file, \"\\tpush(*%s)=%s\\n\", sp, reg_names[regno]);\n #endif\n       }\n   \n   if (current_frame_info.args_size)\n     {\n       if (current_frame_info.args_size == 1)\n \tfprintf (file, \"\\t*%s++\\n\", sp);\n+      else if (SMALL_INTVAL (current_frame_info.args_size)\n+\t       && (current_frame_info.args_size & 0x8000) == 0)\n+\tfprintf (file, \"\\t%s=%ld\\n\\t*%s++%s\\n\", reg_names[REG_J],\n+\t\t current_frame_info.args_size, sp, reg_names[REG_J]);\n       else\n-        {\n-\t  if(SMALL_INTVAL(current_frame_info.args_size) && ((current_frame_info.args_size & 0x8000) == 0))\n-\t    fprintf (file, \"\\t%s=%ld\\n\\t*%s++%s\\n\", reg_names[REG_J], current_frame_info.args_size, sp, reg_names[REG_J]);\n-\t  else\n-\t    fatal (\"Stack size > 32k\");\n-\t}\n+\terror (\"Stack size > 32k\");\n     }\n   \n   if (frame_pointer_needed)\n     {\n-      fprintf( file, \"\\t%s=%s\\n\", a1h, sp );\n-      fprintf( file, \"\\t%s=%s\\n\", fp, a1h );  /* Establish new base frame */\n-      fprintf( file, \"\\t%s=%ld\\n\", reg_names[REG_J], -total_size);\n-      fprintf( file, \"\\t*%s++%s\\n\", fp, reg_names[REG_J]);\n+      fprintf (file, \"\\t%s=%s\\n\", a1h, sp);\n+      fprintf (file, \"\\t%s=%s\\n\", fp, a1h);  /* Establish new base frame */\n+      fprintf (file, \"\\t%s=%ld\\n\", reg_names[REG_J], -total_size);\n+      fprintf (file, \"\\t*%s++%s\\n\", fp, reg_names[REG_J]);\n     }\n   \n-  fprintf( file, \"\\t/* END FUNCTION PROLOGUE: */\\n\\n\" );\n+  fprintf (file, \"\\t/* END FUNCTION PROLOGUE: */\\n\\n\");\n }\n \n void\n@@ -1482,9 +1477,10 @@ double_reg_to_memory (operands)\n       else if (GET_CODE (XEXP(addr,1)) == CONST_INT)\n \toffset = INTVAL(XEXP(addr,1)) + 1;\n       else\n-\tfatal (\"Invalid addressing mode\");\n+\tabort ();\n \n-      fprintf (asm_out_file, \"\\t*(%d)=%s\\n\", offset + 31, reg_names[REGNO(operands[1]) + 1]);\n+      fprintf (asm_out_file, \"\\t*(%d)=%s\\n\", offset + 31,\n+\t       reg_names[REGNO(operands[1]) + 1]);\n     }\n     else\n     {\n@@ -1660,40 +1656,43 @@ print_operand(file, op, letter)\n     {\n \t/* Print the low half of a 32-bit register pair */\n         if (letter == 'w')\n-           fprintf( file, \"%s\", reg_names[REGNO(op)+1] );\n+           fprintf (file, \"%s\", reg_names[REGNO (op) + 1]);\n         else if (letter == 'u' || !letter)\n-           fprintf( file, \"%s\", reg_names[REGNO(op)]);\n+           fprintf (file, \"%s\", reg_names[REGNO (op)]);\n \telse if (letter == 'b')\n-\t    fprintf ( file, \"%sh\", reg_names[REGNO(op)]);\n+\t    fprintf (file, \"%sh\", reg_names[REGNO (op)]);\n \telse if (letter == 'm')\n-\t  fprintf (file, \"%s\", himode_reg_name[REGNO(op)]);\n+\t  fprintf (file, \"%s\", himode_reg_name[REGNO (op)]);\n         else\n-           fatal(\"Bad register extension code\");\n+\t  output_operand_lossgae (\"Bad register extension code\");\n     }\n-    else if( code == MEM )\n-        output_address( XEXP(op,0) );\n-    else if( code == CONST_INT )\n-    { \n+    else if (code == MEM)\n+      output_address (XEXP(op,0));\n+    else if (code == CONST_INT)\n+      { \n \tHOST_WIDE_INT val = INTVAL (op);\n-        if( letter == 'H' )\n-            fprintf( file, HOST_WIDE_INT_PRINT_HEX, val & 0xffff);\n+\n+        if (letter == 'H')\n+\t  fprintf (file, HOST_WIDE_INT_PRINT_HEX, val & 0xffff);\n \telse if (letter == 'h')\n-            fprintf( file, HOST_WIDE_INT_PRINT_DEC, val);\n-        else if( letter == 'U' )\n-            fprintf( file, HOST_WIDE_INT_PRINT_HEX, (val >> 16) & 0xffff);\n+\t  fprintf (file, HOST_WIDE_INT_PRINT_DEC, val);\n+        else if (letter == 'U')\n+\t  fprint(f file, HOST_WIDE_INT_PRINT_HEX, (val >> 16) & 0xffff);\n         else\n-           output_addr_const( file, op );\n-    }\n-    else if( code == CONST_DOUBLE && GET_MODE(op) != DImode )\n-    {\n-\t  union { double d; int i[2]; } u;\n-\t  union { float f; int i; } u1;\n-\t  u.i[0] = CONST_DOUBLE_LOW (op);\n-\t  u.i[1] = CONST_DOUBLE_HIGH (op);\n-\t  u1.f = u.d;\n-          fprintf( file, \"0x%x\", u1.i );\n-    }\n-    else output_addr_const( file, op);\n+\t  output_addr_const (file, op);\n+      }\n+    else if (code == CONST_DOUBLE && GET_MODE (op) != DImode)\n+      {\n+\tunion {double d; int i[2]; } u;\n+\tunion {float f; int i; } u1;\n+\n+\tu.i[0] = CONST_DOUBLE_LOW (op);\n+\tu.i[1] = CONST_DOUBLE_HIGH (op);\n+\tu1.f = u.d;\n+\tfprintf (file, \"0x%x\", u1.i);\n+      }\n+    else\n+      output_addr_const (file, op);\n }\n \n \n@@ -1726,10 +1725,10 @@ print_operand_address(file, addr)\n \t  if (offset >= -31 && offset <= 0)\n \t    offset = 31 + offset;\n \t  else\n-\t    fatal (\"Invalid offset in ybase addressing\");\n+\t    abort ();\n \t}\n       else\n-\tfatal (\"Invalid register in ybase addressing\");\n+\tabort ();\n       \n       fprintf (file, \"*(%d)\", offset);\n       break;\n@@ -1743,7 +1742,7 @@ print_operand_address(file, addr)\n }\n \n void\n-output_dsp16xx_float_const(operands)\n+output_dsp16xx_float_const (operands)\n      rtx *operands;\n {\n   rtx src = operands[1];\n@@ -1758,7 +1757,7 @@ output_dsp16xx_float_const(operands)\n   operands[1] = GEN_INT (value);\n   output_asm_insn (\"%u0=%U1\\n\\t%w0=%H1\", operands);\n #else\n-  fatal (\"inline float constants not supported on this host\");\n+  fatal_error (\"inline float constants not supported on this host\");\n #endif\n }\n \n@@ -1902,7 +1901,7 @@ emit_1600_core_shift (shift_op, operands, shift_amount)\n       shift_asm_ptr_first = lshift_right_asm_first;\n     }\n   else\n-    fatal (\"Invalid shift operator in emit_1600_core_shift\");\n+    abort ();\n \n   while (shift_amount != 0)\n     {\n@@ -1984,19 +1983,21 @@ asm_output_float (file, fp_const)\n      double fp_const;\n {\n #if HOST_FLOAT_FORMAT == TARGET_FLOAT_FORMAT\n-      REAL_VALUE_TYPE d = fp_const;\n-      long value;\n+  REAL_VALUE_TYPE d = fp_const;\n+  long value;\n \n-      REAL_VALUE_TO_TARGET_SINGLE (d, value);\n-      fputs (\"\\tint \", file);\n+  REAL_VALUE_TO_TARGET_SINGLE (d, value);\n+  fputs (\"\\tint \", file);\n #ifdef WORDS_BIG_ENDIAN\n-      fprintf (file, \"0x%-4.4lx, 0x%-4.4lx\", (value >> 16) & 0xffff, (value & 0xffff));\n+  fprintf (file, \"0x%-4.4lx, 0x%-4.4lx\", (value >> 16) & 0xffff,\n+\t   value & 0xffff);\n #else\n-      fprintf (file, \"0x%-4.4lx, 0x%-4.4lx\", (value & 0xffff), (value >> 16) & 0xffff);\n+  fprintf (file, \"0x%-4.4lx, 0x%-4.4lx\", value & 0xffff,\n+\t   (value >> 16) & 0xffff);\n #endif\n-      fputs (\"\\n\", file);\n+  fputs (\"\\n\", file);\n #else\n-      fatal (\"inline float constants not supported on this host\");\n+  fatal_error (\"inline float constants not supported on this host\");\n #endif\n }\n \n@@ -2171,17 +2172,15 @@ gen_tst_reg (x)\n   mode = GET_MODE (x);\n \n   if (mode == QImode)\n-    {\n-\t  emit_insn (gen_rtx_PARALLEL\n-\t\t     (VOIDmode,\n-\t\t      gen_rtvec (2, gen_rtx_SET (VOIDmode, cc0_rtx, x),\n-\t\t\t\t gen_rtx_CLOBBER (VOIDmode,\n-\t\t\t\t\t\t  gen_rtx_SCRATCH (QImode)))));\n-\t}\n+    emit_insn (gen_rtx_PARALLEL\n+\t       (VOIDmode,\n+\t\tgen_rtvec (2, gen_rtx_SET (VOIDmode, cc0_rtx, x),\n+\t\t\t   gen_rtx_CLOBBER (VOIDmode,\n+\t\t\t\t\t    gen_rtx_SCRATCH (QImode)))));\n   else if (mode == HImode)\n     emit_insn (gen_rtx_SET (VOIDmode, cc0_rtx, x));\n   else\n-    fatal (\"Invalid mode for gen_tst_reg\");\n+    abort ();\n \n   return cc0_rtx;\n }\n@@ -2262,7 +2261,7 @@ gen_compare_reg (code, x, y)\n \t\t\t\t\t\t force_reg (HImode,y))));\n     }\n   else\n-    fatal (\"Invalid mode for integer comparison in gen_compare_reg\");\n+    abort ();\n \n   return cc0_rtx;\n }\n@@ -2286,9 +2285,3 @@ output_block_move (operands)\n   fprintf (asm_out_file, \"\\t}\\n\");\n   return \"\";\n }\n-\n-void\n-dsp16xx_invalid_register_for_compare ()\n-{\n-  fatal (\"Invalid register for compare\");\n-}"}, {"sha": "ce7fb96b8500eff04d10a4a55614627121f8a28a", "filename": "gcc/config/dsp16xx/dsp16xx.md", "status": "modified", "additions": 10, "deletions": 19, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/400500c4a50104969a303ba3c41983b134523e15/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/400500c4a50104969a303ba3c41983b134523e15/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.md?ref=400500c4a50104969a303ba3c41983b134523e15", "patch": "@@ -1,5 +1,5 @@\n ;;- Machine description for the AT&T DSP1600 for GNU C compiler\n-;;  Copyright (C) 1994, 1995, 1997, 1998 Free Software Foundation, Inc.\n+;;  Copyright (C) 1994, 1995, 1997, 1998, 2001 Free Software Foundation, Inc.\n ;;  Contributed by Michael Collison (collison@world.std.com).\n \n ;; This file is part of GNU CC.\n@@ -175,17 +175,13 @@\n \t{\n \t  output_asm_insn (\\\"a0=%0\\\", operands);\n \t}\n-      else if (IS_YBASE_REGISTER_WINDOW (REGNO(operands[0])))\n-\t{\n-\t  output_asm_insn (\\\"a0=%u0\\;a0l=%w0\\\", operands);\n-\t}\n+      else if (IS_YBASE_REGISTER_WINDOW (REGNO (operands[0])))\n+\toutput_asm_insn (\\\"a0=%u0\\;a0l=%w0\\\", operands);\n       else\n-\tdsp16xx_invalid_register_for_compare ();\n+\tabort ();\n     }\n   else if (GET_CODE(operands[0]) == CONST_INT)\n-    {\n-      output_asm_insn (\\\"a0=%U0\\;a0l=%H0\\\", operands);\n-    }\n+    output_asm_insn (\\\"a0=%U0\\;a0l=%H0\\\", operands);\n   else if (GET_CODE (operands[0]) == MEM)\n     {\n       rtx xoperands[2];\n@@ -197,17 +193,12 @@\n \n   if (GET_CODE(operands[1]) == REG)\n     {\n-      if (REGNO (operands[1]) == REG_Y\n-\t  || REGNO (operands[1]) == REG_PROD)\n-\t{\n-\t  output_asm_insn (\\\"a1=%1\\\", operands);\n-\t}\n-      else if (IS_YBASE_REGISTER_WINDOW (REGNO(operands[1])))\n-\t{\n-\t  output_asm_insn (\\\"a1=%u1\\;a1l=%w1\\\", operands);\n-\t}\n+      if (REGNO (operands[1]) == REG_Y || REGNO (operands[1]) == REG_PROD)\n+\toutput_asm_insn (\\\"a1=%1\\\", operands);\n+      else if (IS_YBASE_REGISTER_WINDOW (REGNO (operands[1])))\n+\toutput_asm_insn (\\\"a1=%u1\\;a1l=%w1\\\", operands);\n       else\n-\tdsp16xx_invalid_register_for_compare ();\n+\tabort ();\n     }\n   else if (GET_CODE (operands[1]) == MEM)\n     {"}, {"sha": "a52120c9dca7357d2378ef26d03186adee749e03", "filename": "gcc/config/h8300/h8300.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/400500c4a50104969a303ba3c41983b134523e15/gcc%2Fconfig%2Fh8300%2Fh8300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/400500c4a50104969a303ba3c41983b134523e15/gcc%2Fconfig%2Fh8300%2Fh8300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.c?ref=400500c4a50104969a303ba3c41983b134523e15", "patch": "@@ -1,5 +1,5 @@\n /* Subroutines for insn-output.c for Hitachi H8/300.\n-   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000\n+   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001\n    Free Software Foundation, Inc. \n    Contributed by Steve Chamberlain (sac@cygnus.com),\n    Jim Wilson (wilson@cygnus.com), and Doug Evans (dje@cygnus.com).\n@@ -113,7 +113,10 @@ h8300_init_once ()\n   h8_mov_op = h8_mov_ops[cpu_type];\n \n   if (!TARGET_H8300S && TARGET_MAC)\n-    fatal (\"-ms2600 is used without -ms.\");\n+    {\n+      error (\"-ms2600 is used without -ms.\");\n+      target_flags |= 1;\n+    }\n }\n \n const char *"}, {"sha": "708e8ee084974e8c62e1e8e29ef67d1f283dc665", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 43, "deletions": 31, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/400500c4a50104969a303ba3c41983b134523e15/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/400500c4a50104969a303ba3c41983b134523e15/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=400500c4a50104969a303ba3c41983b134523e15", "patch": "@@ -458,6 +458,7 @@ static int ix86_fp_comparison_cost PARAMS ((enum rtx_code code));\n void\n override_options ()\n {\n+  int i;\n   /* Comes from final.c -- no real reason to change it.  */\n #define MAX_CODE_ALIGN 16\n \n@@ -509,7 +510,6 @@ override_options ()\n \n   if (ix86_arch_string != 0)\n     {\n-      int i;\n       for (i = 0; i < pta_size; i++)\n \tif (! strcmp (ix86_arch_string, processor_alias_table[i].name))\n \t  {\n@@ -518,13 +518,13 @@ override_options ()\n \t    ix86_cpu = ix86_arch;\n \t    break;\n \t  }\n+\n       if (i == pta_size)\n \terror (\"bad value (%s) for -march= switch\", ix86_arch_string);\n     }\n \n   if (ix86_cpu_string != 0)\n     {\n-      int i;\n       for (i = 0; i < pta_size; i++)\n \tif (! strcmp (ix86_cpu_string, processor_alias_table[i].name))\n \t  {\n@@ -547,10 +547,11 @@ override_options ()\n   /* Validate registers in register allocation order.  */\n   if (ix86_reg_alloc_order)\n     {\n-      int i, ch;\n+      int  ch;\n+\n       for (i = 0; (ch = ix86_reg_alloc_order[i]) != '\\0'; i++)\n \t{\n-\t  int regno = 0;\n+\t  int regno = -1;\n \n \t  switch (ch)\n \t    {\n@@ -562,74 +563,85 @@ override_options ()\n \t    case 'D':\tregno = 5;\tbreak;\n \t    case 'B':\tregno = 6;\tbreak;\n \n-\t    default:\tfatal (\"Register '%c' is unknown\", ch);\n+\t    default:\terror (\"Register '%c' is unknown\", ch);\n \t    }\n \n-\t  if (regs_allocated[regno])\n-\t    fatal (\"Register '%c' already specified in allocation order\", ch);\n+\t  if (regno >= 0)\n+\t    {\n+\t      if (regs_allocated[regno])\n+\t\terror (\"Register '%c' already specified in allocation order\",\n+\t\t       ch);\n \n-\t  regs_allocated[regno] = 1;\n+\t      regs_allocated[regno] = 1;\n+\t    }\n \t}\n     }\n \n   /* Validate -mregparm= value.  */\n   if (ix86_regparm_string)\n     {\n-      ix86_regparm = atoi (ix86_regparm_string);\n-      if (ix86_regparm < 0 || ix86_regparm > REGPARM_MAX)\n-\tfatal (\"-mregparm=%d is not between 0 and %d\",\n-\t       ix86_regparm, REGPARM_MAX);\n+      i = atoi (ix86_regparm_string);\n+      if (i < 0 || i > REGPARM_MAX)\n+\terror (\"-mregparm=%d is not between 0 and %d\", i, REGPARM_MAX);\n+      else\n+\tix86_regparm = i;\n     }\n \n   /* Validate -malign-loops= value, or provide default.  */\n   ix86_align_loops = processor_target_table[ix86_cpu].align_loop;\n   if (ix86_align_loops_string)\n     {\n-      ix86_align_loops = atoi (ix86_align_loops_string);\n-      if (ix86_align_loops < 0 || ix86_align_loops > MAX_CODE_ALIGN)\n-\tfatal (\"-malign-loops=%d is not between 0 and %d\",\n-\t       ix86_align_loops, MAX_CODE_ALIGN);\n+      i = atoi (ix86_align_loops_string);\n+      if (i < 0 || i > MAX_CODE_ALIGN)\n+\terror (\"-malign-loops=%d is not between 0 and %d\", i, MAX_CODE_ALIGN);\n+      else\n+\tix86_align_loops = i;\n     }\n \n   /* Validate -malign-jumps= value, or provide default.  */\n   ix86_align_jumps = processor_target_table[ix86_cpu].align_jump;\n   if (ix86_align_jumps_string)\n     {\n-      ix86_align_jumps = atoi (ix86_align_jumps_string);\n-      if (ix86_align_jumps < 0 || ix86_align_jumps > MAX_CODE_ALIGN)\n-\tfatal (\"-malign-jumps=%d is not between 0 and %d\",\n-\t       ix86_align_jumps, MAX_CODE_ALIGN);\n+      i = atoi (ix86_align_jumps_string);\n+      if (i < 0 || i > MAX_CODE_ALIGN)\n+\terror (\"-malign-jumps=%d is not between 0 and %d\", i, MAX_CODE_ALIGN);\n+      else\n+\tix86_align_jumps = i;\n     }\n \n   /* Validate -malign-functions= value, or provide default.  */\n   ix86_align_funcs = processor_target_table[ix86_cpu].align_func;\n   if (ix86_align_funcs_string)\n     {\n-      ix86_align_funcs = atoi (ix86_align_funcs_string);\n-      if (ix86_align_funcs < 0 || ix86_align_funcs > MAX_CODE_ALIGN)\n-\tfatal (\"-malign-functions=%d is not between 0 and %d\",\n-\t       ix86_align_funcs, MAX_CODE_ALIGN);\n+      i = atoi (ix86_align_funcs_string);\n+      if (i < 0 || i > MAX_CODE_ALIGN)\n+\terror (\"-malign-functions=%d is not between 0 and %d\",\n+\t       i, MAX_CODE_ALIGN);\n+      else\n+\tix86_align_funcs = i;\n     }\n \n   /* Validate -mpreferred-stack-boundary= value, or provide default.\n      The default of 128 bits is for Pentium III's SSE __m128.  */\n   ix86_preferred_stack_boundary = 128;\n   if (ix86_preferred_stack_boundary_string)\n     {\n-      int i = atoi (ix86_preferred_stack_boundary_string);\n+      i = atoi (ix86_preferred_stack_boundary_string);\n       if (i < 2 || i > 31)\n-\tfatal (\"-mpreferred-stack-boundary=%d is not between 2 and 31\", i);\n-      ix86_preferred_stack_boundary = (1 << i) * BITS_PER_UNIT;\n+\terror (\"-mpreferred-stack-boundary=%d is not between 2 and 31\", i);\n+      else\n+\tix86_preferred_stack_boundary = (1 << i) * BITS_PER_UNIT;\n     }\n \n   /* Validate -mbranch-cost= value, or provide default.  */\n   ix86_branch_cost = processor_target_table[ix86_cpu].branch_cost;\n   if (ix86_branch_cost_string)\n     {\n-      ix86_branch_cost = atoi (ix86_branch_cost_string);\n-      if (ix86_branch_cost < 0 || ix86_branch_cost > 5)\n-\tfatal (\"-mbranch-cost=%d is not between 0 and 5\",\n-\t       ix86_branch_cost);\n+      i = atoi (ix86_branch_cost_string);\n+      if (i < 0 || i > 5)\n+\terror (\"-mbranch-cost=%d is not between 0 and 5\", i);\n+      else\n+\tix86_branch_cost = i;\n     }\n \n   /* Keep nonleaf frame pointers.  */"}, {"sha": "2fcf4ce6dabdd5e18f5587e702f30997fb8113d4", "filename": "gcc/config/m68hc11/m68hc11.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/400500c4a50104969a303ba3c41983b134523e15/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/400500c4a50104969a303ba3c41983b134523e15/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c?ref=400500c4a50104969a303ba3c41983b134523e15", "patch": "@@ -1,5 +1,5 @@\n /* Subroutines for code generation on Motorola 68HC11 and 68HC12.\n-   Copyright (C) 1999, 2000 Free Software Foundation, Inc.\n+   Copyright (C) 1999, 2000, 2001 Free Software Foundation, Inc.\n    Contributed by Stephane Carrez (stcarrez@worldnet.fr)\n \n This file is part of GNU CC.\n@@ -761,7 +761,7 @@ m68hc11_emit_libcall (name, code, dmode, smode, noperands, operands)\n       break;\n \n     default:\n-      fatal (\"m68hc11_emit_libcall: Bad number of operands\");\n+      abort ();\n     }\n \n   insns = get_insns ();"}, {"sha": "430e618e37ebdef36f6715df5b9f541765b54d05", "filename": "gcc/config/m68k/m68k.c", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/400500c4a50104969a303ba3c41983b134523e15/gcc%2Fconfig%2Fm68k%2Fm68k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/400500c4a50104969a303ba3c41983b134523e15/gcc%2Fconfig%2Fm68k%2Fm68k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.c?ref=400500c4a50104969a303ba3c41983b134523e15", "patch": "@@ -1,5 +1,5 @@\n /* Subroutines for insn-output.c for Motorola 68000 family.\n-   Copyright (C) 1987, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000\n+   Copyright (C) 1987, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001\n    Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n@@ -90,41 +90,43 @@ void\n override_options ()\n {\n   int def_align;\n+  int i;\n \n   def_align = 1;\n \n   /* Validate -malign-loops= value, or provide default */\n+  m68k_align_loops = def_align;\n   if (m68k_align_loops_string)\n     {\n-      m68k_align_loops = atoi (m68k_align_loops_string);\n-      if (m68k_align_loops < 1 || m68k_align_loops > MAX_CODE_ALIGN)\n-\tfatal (\"-malign-loops=%d is not between 1 and %d\",\n-\t       m68k_align_loops, MAX_CODE_ALIGN);\n+      i = atoi (m68k_align_loops_string);\n+      if (i < 1 || i > MAX_CODE_ALIGN)\n+\terror (\"-malign-loops=%d is not between 1 and %d\", i, MAX_CODE_ALIGN);\n+      else\n+\tm68k_align_loops = i;\n     }\n-  else\n-    m68k_align_loops = def_align;\n \n   /* Validate -malign-jumps= value, or provide default */\n+  m68k_align_jumps = def_align;\n   if (m68k_align_jumps_string)\n     {\n-      m68k_align_jumps = atoi (m68k_align_jumps_string);\n-      if (m68k_align_jumps < 1 || m68k_align_jumps > MAX_CODE_ALIGN)\n-\tfatal (\"-malign-jumps=%d is not between 1 and %d\",\n-\t       m68k_align_jumps, MAX_CODE_ALIGN);\n+      i = atoi (m68k_align_jumps_string);\n+      if (i < 1 || i > MAX_CODE_ALIGN)\n+\terror (\"-malign-jumps=%d is not between 1 and %d\", i, MAX_CODE_ALIGN);\n+      else\n+\tm68k_align_jumps = i;\n     }\n-  else\n-    m68k_align_jumps = def_align;\n \n   /* Validate -malign-functions= value, or provide default */\n+  m68k_align_funcs = def_align;\n   if (m68k_align_funcs_string)\n     {\n-      m68k_align_funcs = atoi (m68k_align_funcs_string);\n-      if (m68k_align_funcs < 1 || m68k_align_funcs > MAX_CODE_ALIGN)\n-\tfatal (\"-malign-functions=%d is not between 1 and %d\",\n-\t       m68k_align_funcs, MAX_CODE_ALIGN);\n+      i = atoi (m68k_align_funcs_string);\n+      if (i < 1 || i > MAX_CODE_ALIGN)\n+\terror (\"-malign-functions=%d is not between 1 and %d\",\n+\t       i, MAX_CODE_ALIGN);\n+      else\n+\tm68k_align_funcs = i;\n     }\n-  else\n-    m68k_align_funcs = def_align;\n }\n \f\n /* This function generates the assembly code for function entry."}, {"sha": "fbfa31fe53a96f7e25fe71d07b64796fdee4811b", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/400500c4a50104969a303ba3c41983b134523e15/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/400500c4a50104969a303ba3c41983b134523e15/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=400500c4a50104969a303ba3c41983b134523e15", "patch": "@@ -4953,10 +4953,16 @@ override_options ()\n   if (! ISA_HAS_64BIT_REGS)\n     {\n       if (TARGET_FLOAT64)\n-\tfatal (\"-mips%d does not support 64 bit fp registers\", mips_isa);\n+\t{\n+\t  error (\"-mips%d does not support 64 bit fp registers\", mips_isa);\n+\t  target_flags &= ~ MASK_FLAG64;\n+\t}\n \n       else if (TARGET_64BIT)\n-\tfatal (\"-mips%d does not support 64 bit gp registers\", mips_isa);\n+\t{\n+\t  error (\"-mips%d does not support 64 bit gp registers\", mips_isa);\n+\t  target_flags &= ~MASK_64BIT;\n+\t}\n     }\n \n   if (mips_abi != ABI_32 && mips_abi != ABI_O64)\n@@ -5572,8 +5578,7 @@ print_operand (file, op, letter)\n     fputs (reg_names[GP_REG_FIRST], file);\n \n   else if (letter == 'd' || letter == 'x' || letter == 'X')\n-    fatal (\"PRINT_OPERAND: letter %c was found & insn was not CONST_INT\",\n-\t   letter);\n+    output_operand_lossage (\"invalid use of %%d, %%x, or %%X\");\n \n   else if (letter == 'B')\n     fputs (code == EQ ? \"z\" : \"n\", file);\n@@ -6434,8 +6439,9 @@ save_restore_insns (store_p, large_reg, large_offset, file)\n \t\t       - GET_MODE_SIZE (gpr_mode));\n \n       if (gp_offset < 0 || end_offset < 0)\n-\tfatal (\"gp_offset (%ld) or end_offset (%ld) is less than zero.\",\n-\t       (long) gp_offset, (long) end_offset);\n+\tinternal_error\n+\t  (\"gp_offset (%ld) or end_offset (%ld) is less than zero.\",\n+\t   (long) gp_offset, (long) end_offset);\n \n       /* If we see a large frame in mips16 mode, we save the registers\n          before adjusting the stack pointer, and load them afterward.  */\n@@ -6651,8 +6657,9 @@ save_restore_insns (store_p, large_reg, large_offset, file)\n       end_offset = fp_offset - (current_frame_info.fp_reg_size - fp_size);\n \n       if (fp_offset < 0 || end_offset < 0)\n-\tfatal (\"fp_offset (%ld) or end_offset (%ld) is less than zero.\",\n-\t       (long) fp_offset, (long) end_offset);\n+\tinternal_error\n+\t  (\"fp_offset (%ld) or end_offset (%ld) is less than zero.\",\n+\t   (long) fp_offset, (long) end_offset);\n \n       else if (fp_offset < 32768)\n \tbase_reg_rtx = stack_pointer_rtx, base_offset  = 0;"}, {"sha": "b03d4812d889f741e57e8930a261846414ca8614", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/400500c4a50104969a303ba3c41983b134523e15/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/400500c4a50104969a303ba3c41983b134523e15/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=400500c4a50104969a303ba3c41983b134523e15", "patch": "@@ -1,3 +1,12 @@\n+Sun Feb  4 15:52:44 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* decl.c (pushdecl): Call abort instead of fatal.\n+\t* except.c (decl_is_java_type): Call fatal_error instead of fatal.\n+\t* init.c (build_new_1): Likewise.\n+\t(build_java_class_ref): Call internal_error and fatal_error, not fatal.\n+\t* decl.c (build_typename_type): hash_table_init now returns void.\n+\tdecl.c (init_decl_processing): Make an error non-fatal.\n+\n 2001-02-04  Mark Mitchell  <mark@codesourcery.com>\n \n \t* cp-tree.h (CLASSTYPE_INTERFACE_UNKNOWN): Fix formatting."}, {"sha": "13e3094e791db43b0636ec6a1b714e00f9e52ad6", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/400500c4a50104969a303ba3c41983b134523e15/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/400500c4a50104969a303ba3c41983b134523e15/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=400500c4a50104969a303ba3c41983b134523e15", "patch": "@@ -3867,7 +3867,9 @@ pushdecl (x)\n \t  else if (TREE_CODE (t) == PARM_DECL)\n \t    {\n \t      if (DECL_CONTEXT (t) == NULL_TREE)\n-\t\tfatal (\"parse errors have confused me too much\");\n+\t\t/* This is probaby caused by too many errors, but calling\n+\t\t   abort will say that if errors have occurred.  */\n+\t\tabort ();\n \n \t      /* Check for duplicate params.  */\n \t      if (duplicate_decls (x, t))\n@@ -5520,16 +5522,15 @@ build_typename_type (context, name, fullname, base_type)\n {\n   tree t;\n   tree d;\n-  struct hash_entry* e;\n+  struct hash_entry *e;\n \n   static struct hash_table ht;\n \n   if (!ht.table)\n     {\n       static struct hash_table *h = &ht;\n-      if (!hash_table_init (&ht, &hash_newfunc, &typename_hash,\n-\t\t\t    &typename_compare))\n-\tfatal (\"virtual memory exhausted\");\n+\n+      hash_table_init (&ht, &hash_newfunc, &typename_hash, &typename_compare);\n       ggc_add_tree_hash_table_root (&h, 1);\n     }\n \n@@ -6290,7 +6291,7 @@ init_decl_processing ()\n   /* Check to see that the user did not specify an invalid combination\n      of command-line options.  */\n   if (flag_new_abi && !flag_vtable_thunks)\n-    fatal (\"the new ABI requires vtable thunks\");\n+    error (\"the new ABI requires vtable thunks\");\n \n   /* Create all the identifiers we need.  */\n   initialize_predefined_identifiers ();\n@@ -7611,7 +7612,6 @@ check_initializer (decl, init)\n \n       DECL_INITIAL (decl) = init;\n \n-      /* This will keep us from needing to worry about our obstacks.  */\n       my_friendly_assert (init != NULL_TREE, 149);\n       init = NULL_TREE;\n     }"}, {"sha": "bcca6863bcbfe79447dceedeffca995c1cc0e012", "filename": "gcc/cp/except.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/400500c4a50104969a303ba3c41983b134523e15/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/400500c4a50104969a303ba3c41983b134523e15/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=400500c4a50104969a303ba3c41983b134523e15", "patch": "@@ -466,8 +466,11 @@ decl_is_java_type (decl, err)\n \t{\n \t  tree jthrow_node\n \t    = IDENTIFIER_GLOBAL_VALUE (get_identifier (\"jthrowable\"));\n+\n \t  if (jthrow_node == NULL_TREE)\n-\t    fatal (\"call to Java `catch' or `throw', while `jthrowable' undefined\");\n+\t    fatal_error\n+\t      (\"call to Java `catch' or `throw' with `jthrowable' undefined\");\n+\n \t  jthrow_node = TREE_TYPE (TREE_TYPE (jthrow_node));\n \n \t  if (! DERIVED_FROM_P (jthrow_node, TREE_TYPE (decl)))"}, {"sha": "7cd6c5739d61a62ffe59897fae1c66b6a891ce2f", "filename": "gcc/cp/init.c", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/400500c4a50104969a303ba3c41983b134523e15/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/400500c4a50104969a303ba3c41983b134523e15/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=400500c4a50104969a303ba3c41983b134523e15", "patch": "@@ -1,6 +1,6 @@\n /* Handle initialization things in C++.\n    Copyright (C) 1987, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000 Free Software Foundation, Inc.\n+   1999, 2000, 2001 Free Software Foundation, Inc.\n    Contributed by Michael Tiemann (tiemann@cygnus.com)\n \n This file is part of GNU CC.\n@@ -2205,9 +2205,10 @@ build_java_class_ref (type)\n     CL_suffix = get_identifier(\"class$\");\n   if (jclass_node == NULL_TREE)\n     {\n-      jclass_node = IDENTIFIER_GLOBAL_VALUE (get_identifier(\"jclass\"));\n+      jclass_node = IDENTIFIER_GLOBAL_VALUE (get_identifier (\"jclass\"));\n       if (jclass_node == NULL_TREE)\n-\tfatal(\"call to Java constructor, while `jclass' undefined\");\n+\tfatal_error (\"call to Java constructor, while `jclass' undefined\");\n+\n       jclass_node = TREE_TYPE (jclass_node);\n     }\n \n@@ -2222,7 +2223,7 @@ build_java_class_ref (type)\n \t    break;\n \t  }\n       if (!field)\n-\tfatal (\"Can't find class$\");\n+\tinternal_error (\"Can't find class$\");\n     }\n   else\n     name = build_static_name (type, CL_suffix);\n@@ -2398,7 +2399,9 @@ build_new_1 (exp)\n       use_java_new = 1;\n       alloc_decl = IDENTIFIER_GLOBAL_VALUE (get_identifier (alloc_name));\n       if (alloc_decl == NULL_TREE)\n-\tfatal(\"call to Java constructor, while `%s' undefined\", alloc_name);\n+\tfatal_error (\"call to Java constructor with `%s' undefined\",\n+\t\t     alloc_name);\n+\n       class_addr = build1 (ADDR_EXPR, jclass_node, class_decl);\n       alloc_call = (build_function_call\n \t\t    (alloc_decl,"}, {"sha": "2dccd4c8b0d9f140cb645b67fd09ad7eac21f886", "filename": "gcc/diagnostic.c", "status": "modified", "additions": 65, "deletions": 25, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/400500c4a50104969a303ba3c41983b134523e15/gcc%2Fdiagnostic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/400500c4a50104969a303ba3c41983b134523e15/gcc%2Fdiagnostic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.c?ref=400500c4a50104969a303ba3c41983b134523e15", "patch": "@@ -1,5 +1,5 @@\n /* Language-independent diagnostic subroutines for the GNU C compiler\n-   Copyright (C) 1999, 2000 Free Software Foundation, Inc.\n+   Copyright (C) 1999, 2000, 2001 Free Software Foundation, Inc.\n    Contributed by Gabriel Dos Reis <gdr@codesourcery.com>\n \n This file is part of GNU CC.\n@@ -1108,23 +1108,32 @@ fnotice VPARAMS ((FILE *file, const char *msgid, ...))\n }\n \n \n-/* Print a fatal error message.  NAME is the text.\n+/* Print a fatal I/O error message.  Argument are like printf.\n    Also include a system error message based on `errno'.  */\n \n void\n-pfatal_with_name (name)\n-  const char *name;\n+fatal_io_error VPARAMS ((const char *msgid, ...))\n {\n-  fprintf (stderr, \"%s: \", progname);\n-  perror (name);\n-  exit (FATAL_EXIT_CODE);\n-}\n+#ifndef ANSI_PROTOTYPES\n+  const char *msgid;\n+#endif\n+  va_list ap;\n+  output_state os;\n \n-void\n-fatal_io_error (name)\n-  const char *name;\n-{\n-  verbatim (\"%s: %s: I/O error\\n\", progname, name);\n+  os = output_buffer_state (diagnostic_buffer);\n+  VA_START (ap, msgid);\n+\n+#ifndef ANSI_PROTOTYPES\n+  msgid = va_arg (ap, const char *);\n+#endif\n+\n+  output_printf (diagnostic_buffer, \"%s: %s: \", progname, xstrerror (errno));\n+  output_buffer_ptr_to_format_args (diagnostic_buffer) = &ap;\n+  output_buffer_text_cursor (diagnostic_buffer) = msgid;\n+  output_format (diagnostic_buffer);\n+  finish_diagnostic ();\n+  output_buffer_state (diagnostic_buffer) = os;\n+  va_end (ap);\n   exit (FATAL_EXIT_CODE);\n }\n \n@@ -1368,6 +1377,8 @@ error_for_asm VPARAMS ((rtx insn, const char *msgid, ...))\n   va_end (ap);\n }\n \n+/* Report an error message.  The arguments are like that of printf.  */\n+\n void\n error VPARAMS ((const char *msgid, ...))\n {\n@@ -1389,22 +1400,49 @@ error VPARAMS ((const char *msgid, ...))\n   va_end (ap);\n }\n \n-/* Report a fatal error at the current line number.  Allow a front end to\n+/* Likewise, except that the compilation is terminated after printing the\n+   error message.  */\n+\n+void\n+fatal_error VPARAMS ((const char *msgid, ...))\n+{\n+#ifndef ANSI_PROTOTYPES\n+  const char *msgid;\n+#endif\n+  va_list ap;\n+  diagnostic_context dc;\n+\n+  VA_START (ap, msgid);\n+\n+#ifndef ANSI_PROTOTYPES\n+  msgid = va_arg (ap, const char *);\n+#endif\n+\n+  set_diagnostic_context\n+    (&dc, msgid, &ap, input_filename, lineno, /* warn = */ 0);\n+  report_diagnostic (&dc);\n+  va_end (ap);\n+\n+  fprintf (stderr, \"compilation terminated.\\n\");\n+  exit (FATAL_EXIT_CODE);\n+}\n+\n+/* Report a compiler error at the current line number.  Allow a front end to\n    intercept the message.  */\n \n-static void (*fatal_function) PARAMS((const char *, va_list *));\n+static void (*internal_error_function) PARAMS ((const char *, va_list *));\n \n-/* Set the function to call when a fatal error occurs.  */\n+/* Set the function to call when a compiler error occurs.  */\n \n void\n-set_fatal_function (f)\n+set_internal_error_function (f)\n      void (*f) PARAMS ((const char *, va_list *));\n {\n-  fatal_function = f;\n+  internal_error_function = f;\n }\n \n void\n-fatal VPARAMS ((const char *msgid, ...))\n+internal_error VPARAMS ((const char *msgid, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   const char *msgid;\n@@ -1424,15 +1462,16 @@ fatal VPARAMS ((const char *msgid, ...))\n       exit (FATAL_EXIT_CODE);\n     }\n \n-  if (fatal_function != 0)\n-    (*fatal_function) (_(msgid), &ap);\n+  if (internal_error_function != 0)\n+    (*internal_error_function) (_(msgid), &ap);\n   \n   set_diagnostic_context\n     (&dc, msgid, &ap, input_filename, lineno, /* warn = */0);\n   report_diagnostic (&dc);\n   va_end (ap);\n \n-  fprintf (stderr, \"Please submit a full bug report, with preprocessed source if appropriate.\\n\");\n+  fprintf (stderr, \"Please submit a full bug report, \");\n+  fprintf (stderr, \"with preprocessed source if appropriate.\\n\");\n   fprintf (stderr, \"See %s for instructions.\\n\", GCCBUGURL);\n   exit (FATAL_EXIT_CODE);\n }\n@@ -1661,7 +1700,8 @@ error_recursion ()\n   if (diagnostic_lock < 3)\n     finish_diagnostic ();\n \n-  fatal (\"Internal compiler error: Error reporting routines re-entered.\");\n+  internal_error\n+    (\"Internal compiler error: Error reporting routines re-entered.\");\n }\n \n /* Given a partial pathname as input, return another pathname that\n@@ -1718,8 +1758,8 @@ fancy_abort (file, line, function)\n      int line;\n      const char *function;\n {\n-  fatal (\"Internal compiler error in %s, at %s:%d\",\n-\t function, trim_filename (file), line);\n+  internal_error (\"Internal compiler error in %s, at %s:%d\",\n+\t\t  function, trim_filename (file), line);\n }\n \n /* Setup DC for reporting a diagnostic MESSAGE (an error or a WARNING),"}, {"sha": "5217e384b9d0f7ee5bd5e4bccde29d3f0ded27ac", "filename": "gcc/diagnostic.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/400500c4a50104969a303ba3c41983b134523e15/gcc%2Fdiagnostic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/400500c4a50104969a303ba3c41983b134523e15/gcc%2Fdiagnostic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.h?ref=400500c4a50104969a303ba3c41983b134523e15", "patch": "@@ -169,7 +169,7 @@ extern output_buffer *diagnostic_buffer;\n extern void set_diagnostic_context\tPARAMS ((diagnostic_context *,\n \t\t\t\t\t\t const char *, va_list *,\n \t\t\t\t\t\t const char *, int, int));\n-extern void set_fatal_function\t\tPARAMS ((void (*)\n+extern void set_internal_error_function\tPARAMS ((void (*)\n \t\t\t\t\t\t PARAMS ((const char *,\n \t\t\t\t\t\t\t  va_list *))));\n extern void report_diagnostic\t\tPARAMS ((diagnostic_context *));"}, {"sha": "e424086a0c56a389ad2b9015cc05ec5184684c8a", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/400500c4a50104969a303ba3c41983b134523e15/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/400500c4a50104969a303ba3c41983b134523e15/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=400500c4a50104969a303ba3c41983b134523e15", "patch": "@@ -3181,8 +3181,8 @@ get_cfa_from_loc_descr (cfa, loc)\n \t  cfa->offset = ptr->dw_loc_oprnd1.v.val_unsigned;\n \t  break;\n \tdefault:\n-\t  fatal (\"DW_LOC_OP %s not implememnted yet.\\n\",\n-\t\t dwarf_stack_op_name (ptr->dw_loc_opc));\n+\t  internal_error (\"DW_LOC_OP %s not implememnted\\n\",\n+\t\t\t  dwarf_stack_op_name (ptr->dw_loc_opc));\n \t}\n     }\n }"}, {"sha": "9c7cb47dbb49da98614f846fb541f6f524f25cd4", "filename": "gcc/dwarfout.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/400500c4a50104969a303ba3c41983b134523e15/gcc%2Fdwarfout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/400500c4a50104969a303ba3c41983b134523e15/gcc%2Fdwarfout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarfout.c?ref=400500c4a50104969a303ba3c41983b134523e15", "patch": "@@ -5711,7 +5711,8 @@ dwarfout_init (asm_out_file, main_input_filename)\n \t    register char *dirname;\n \n \t    if (!pwd)\n-\t      pfatal_with_name (\"getpwd\");\n+\t      fatal_io_error (\"can't get current directory\");\n+\n \t    dirname = concat (pwd, \"/\", NULL);\n \t    ASM_OUTPUT_DWARF_STRING_NEWLINE (asm_out_file, dirname);\n \t    free (dirname);"}, {"sha": "0b9e4aa9e51ccc75fa8dbd4644de173fe17c5452", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/400500c4a50104969a303ba3c41983b134523e15/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/400500c4a50104969a303ba3c41983b134523e15/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=400500c4a50104969a303ba3c41983b134523e15", "patch": "@@ -1001,7 +1001,8 @@ gen_realpart (mode, x)\n \t   && GET_MODE_BITSIZE (mode) < BITS_PER_WORD\n \t   && REG_P (x)\n \t   && REGNO (x) < FIRST_PSEUDO_REGISTER)\n-    fatal (\"Unable to access real part of complex value in a hard register on this target\");\n+    internal_error\n+      (\"Can't access real part of complex value in hard register\");\n   else if (WORDS_BIG_ENDIAN)\n     return gen_highpart (mode, x);\n   else\n@@ -1024,7 +1025,8 @@ gen_imagpart (mode, x)\n \t   && GET_MODE_BITSIZE (mode) < BITS_PER_WORD\n \t   && REG_P (x)\n \t   && REGNO (x) < FIRST_PSEUDO_REGISTER)\n-    fatal (\"Unable to access imaginary part of complex value in a hard register on this target\");\n+    internal_error\n+      (\"can't access imaginary part of complex value in hard register\");\n   else\n     return gen_highpart (mode, x);\n }"}, {"sha": "4770031220a3551863d9f28bfc51a95c855dd8ab", "filename": "gcc/except.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/400500c4a50104969a303ba3c41983b134523e15/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/400500c4a50104969a303ba3c41983b134523e15/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=400500c4a50104969a303ba3c41983b134523e15", "patch": "@@ -967,7 +967,8 @@ duplicate_eh_handlers (old_note_eh_region, new_note_eh_region, map)\n \n   region = find_func_region (old_note_eh_region);\n   if (region == -1)\n-    fatal (\"Cannot duplicate non-existant exception region.\");\n+    /* Cannot duplicate non-existant exception region.  */\n+    abort ();\n \n   /* duplicate_eh_handlers may have been called during a symbol remap. */\n   new_region = find_func_region (new_note_eh_region);"}, {"sha": "f4ff9b2d7439d8b811c2c75db4ce4ac56786632c", "filename": "gcc/expr.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/400500c4a50104969a303ba3c41983b134523e15/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/400500c4a50104969a303ba3c41983b134523e15/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=400500c4a50104969a303ba3c41983b134523e15", "patch": "@@ -5831,6 +5831,7 @@ var_rtx (exp)\n }\n \n #ifdef MAX_INTEGER_COMPUTATION_MODE\n+\n void\n check_max_integer_computation_mode (exp)\n      tree exp;\n@@ -5856,7 +5857,7 @@ check_max_integer_computation_mode (exp)\n       mode = TYPE_MODE (TREE_TYPE (exp));\n       if (GET_MODE_CLASS (mode) == MODE_INT\n \t  && mode > MAX_INTEGER_COMPUTATION_MODE)\n-\tfatal (\"unsupported wide integer operation\");\n+\tinternal_error (\"unsupported wide integer operation\");\n     }\n \n   /* Check operand of a unary op.  */\n@@ -5865,7 +5866,7 @@ check_max_integer_computation_mode (exp)\n       mode = TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0)));\n       if (GET_MODE_CLASS (mode) == MODE_INT\n \t  && mode > MAX_INTEGER_COMPUTATION_MODE)\n-\tfatal (\"unsupported wide integer operation\");\n+\tinternal_error (\"unsupported wide integer operation\");\n     }\n \n   /* Check operands of a binary/comparison op.  */\n@@ -5874,12 +5875,12 @@ check_max_integer_computation_mode (exp)\n       mode = TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0)));\n       if (GET_MODE_CLASS (mode) == MODE_INT\n \t  && mode > MAX_INTEGER_COMPUTATION_MODE)\n-\tfatal (\"unsupported wide integer operation\");\n+\tinternal_error (\"unsupported wide integer operation\");\n \n       mode = TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 1)));\n       if (GET_MODE_CLASS (mode) == MODE_INT\n \t  && mode > MAX_INTEGER_COMPUTATION_MODE)\n-\tfatal (\"unsupported wide integer operation\");\n+\tinternal_error (\"unsupported wide integer operation\");\n     }\n }\n #endif\n@@ -6037,7 +6038,7 @@ expand_expr (exp, target, tmode, modifier)\n \n       if (GET_MODE_CLASS (mode) == MODE_INT\n \t  && mode > MAX_INTEGER_COMPUTATION_MODE)\n-\tfatal (\"unsupported wide integer operation\");\n+\tinternal_error (\"unsupported wide integer operation\");\n     }\n \n   if (tmode != mode\n@@ -6052,7 +6053,7 @@ expand_expr (exp, target, tmode, modifier)\n       && TREE_CODE (exp) != RTL_EXPR\n       && GET_MODE_CLASS (tmode) == MODE_INT\n       && tmode > MAX_INTEGER_COMPUTATION_MODE)\n-    fatal (\"unsupported wide integer operation\");\n+    internal_error (\"unsupported wide integer operation\");\n \n   check_max_integer_computation_mode (exp);\n #endif"}, {"sha": "745890cfdf3b382f7654e5cfebd6183b2773cbef", "filename": "gcc/f/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/400500c4a50104969a303ba3c41983b134523e15/gcc%2Ff%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/400500c4a50104969a303ba3c41983b134523e15/gcc%2Ff%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2FChangeLog?ref=400500c4a50104969a303ba3c41983b134523e15", "patch": "@@ -1,3 +1,12 @@\n+Sun Feb  4 15:52:44 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* com.c (ffecom_init_0): Call fatal_error instead of fatal.\n+\t* com.c (init_parse): Call fatal_io_error instead of\n+\tpfatal_with_name.\n+\t(ffecom_decode_include_option_): Make errors non-fatal.\n+\t* lex.c (ffelex_cfelex_, ffelex_get_directive_line_): Likewise.\n+\t(ffelex_hash_): Likewise.\n+\t\n Sat Jan 27 20:52:18 2001  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* Make-lang.in: Remove all dependencies on defaults.h."}, {"sha": "198a1f719d23ae14403462f8589818a15cad30ce", "filename": "gcc/f/com.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/400500c4a50104969a303ba3c41983b134523e15/gcc%2Ff%2Fcom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/400500c4a50104969a303ba3c41983b134523e15/gcc%2Ff%2Fcom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fcom.c?ref=400500c4a50104969a303ba3c41983b134523e15", "patch": "@@ -11855,7 +11855,7 @@ ffecom_init_0 ()\n   /* Set up pointer types.  */\n \n   if (ffecom_pointer_kind_ == FFEINFO_basictypeNONE)\n-    fatal (\"no INTEGER type can hold a pointer on this configuration\");\n+    fatal_error (\"no INTEGER type can hold a pointer on this configuration\");\n   else if (0 && ffe_is_do_internal_checks ())\n     fprintf (stderr, \"Pointer type kt=%d\\n\", ffecom_pointer_kind_);\n   ffetype_set_kind (ffeinfo_type (FFEINFO_basictypeINTEGER,\n@@ -14608,7 +14608,7 @@ init_parse (filename)\n   else\n     finput = fopen (filename, \"r\");\n   if (finput == 0)\n-    pfatal_with_name (filename);\n+    fatal_io_error (\"can't open %s\", filename);\n \n #ifdef IO_BUFFER_SIZE\n   setvbuf (finput, (char *) xmalloc (IO_BUFFER_SIZE), _IOFBF, IO_BUFFER_SIZE);\n@@ -16078,12 +16078,12 @@ ffecom_decode_include_option_ (char *spec)\n       dirtmp = (struct file_name_list *)\n \txmalloc (sizeof (struct file_name_list));\n       dirtmp->next = 0;\t\t/* New one goes on the end */\n-      if (spec[0] != 0)\n-\tdirtmp->fname = spec;\n-      else\n-\tfatal (\"Directory name must immediately follow -I option with no intervening spaces, as in `-Idir', not `-I dir'\");\n+      dirtmp->fname = spec;\n       dirtmp->got_name_map = 0;\n-      append_include_chain (dirtmp, dirtmp);\n+      if (spec[0] == 0)\n+\terror (\"Directory name must immediately follow -I\");\n+      else\n+\tappend_include_chain (dirtmp, dirtmp);\n     }\n   return 1;\n }"}, {"sha": "ea0ef059b76197593fa6b8d6ff135dc4d5ee3991", "filename": "gcc/f/lex.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/400500c4a50104969a303ba3c41983b134523e15/gcc%2Ff%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/400500c4a50104969a303ba3c41983b134523e15/gcc%2Ff%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Flex.c?ref=400500c4a50104969a303ba3c41983b134523e15", "patch": "@@ -1,5 +1,5 @@\n /* Implementation of Fortran lexer\n-   Copyright (C) 1995, 1996, 1997, 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1995, 1996, 1997, 1998, 2001 Free Software Foundation, Inc.\n    Contributed by James Craig Burley.\n \n This file is part of GNU Fortran.\n@@ -803,7 +803,7 @@ ffelex_cfelex_ (ffelexToken *xtoken, FILE *finput, int c)\n \n \t    case EOF:\n \t    case '\\n':\n-\t      fatal (\"Badly formed directive -- no closing quote\");\n+\t      error (\"Badly formed directive -- no closing quote\");\n \t      done = TRUE;\n \t      break;\n \n@@ -1036,7 +1036,7 @@ ffelex_get_directive_line_ (char **text, FILE *finput)\n \t  || c == EOF)\n \t{\n \t  if (looking_for != 0)\n-\t    fatal (\"Bad directive -- missing close-quote\");\n+\t    error (\"Bad directive -- missing close-quote\");\n \n \t  *p++ = '\\0';\n \t  *text = directive_buffer;\n@@ -1366,7 +1366,7 @@ ffelex_hash_ (FILE *finput)\n \t    {\n \t      lineno = 1;\n \t      input_filename = old_input_filename;\n-\t      fatal (\"Use `#line ...' instead of `# ...' in first line\");\n+\t      error (\"Use `#line ...' instead of `# ...' in first line\");\n \t    }\n \n \t  if (num == 1)\n@@ -1410,7 +1410,7 @@ ffelex_hash_ (FILE *finput)\n \t{\n \t  lineno = 1;\n \t  input_filename = old_input_filename;\n-\t  fatal (\"Use `#line ...' instead of `# ...' in first line\");\n+\t  error (\"Use `#line ...' instead of `# ...' in first line\");\n \t}\n     }\n   else"}, {"sha": "aff84451e8d37b275e2b0f24983580b5791cd862", "filename": "gcc/flow.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/400500c4a50104969a303ba3c41983b134523e15/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/400500c4a50104969a303ba3c41983b134523e15/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=400500c4a50104969a303ba3c41983b134523e15", "patch": "@@ -6948,7 +6948,9 @@ verify_flow_info ()\n \t  basic_block bb = NOTE_BASIC_BLOCK (x);\n \t  num_bb_notes++;\n \t  if (bb->index != last_bb_num_seen + 1)\n-\t    fatal (\"Basic blocks not numbered consecutively\");\n+\t    /* Basic blocks not numbered consecutively.  */\n+\t    abort ();\n+\t       \n \t  last_bb_num_seen = bb->index;\n \t}\n \n@@ -6988,8 +6990,9 @@ verify_flow_info ()\n     }\n \n   if (num_bb_notes != n_basic_blocks)\n-    fatal (\"number of bb notes in insn chain (%d) != n_basic_blocks (%d)\",\n-\t   num_bb_notes, n_basic_blocks);\n+    internal_error\n+      (\"number of bb notes in insn chain (%d) != n_basic_blocks (%d)\",\n+       num_bb_notes, n_basic_blocks);\n \n   if (err)\n     abort ();"}, {"sha": "0f9e4ef22b9717b6a9a6f05476640e92f72ebf5b", "filename": "gcc/graph.c", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/400500c4a50104969a303ba3c41983b134523e15/gcc%2Fgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/400500c4a50104969a303ba3c41983b134523e15/gcc%2Fgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraph.c?ref=400500c4a50104969a303ba3c41983b134523e15", "patch": "@@ -1,23 +1,23 @@\n /* Output routines for graphical representation.\n-   Copyright (C) 1998, 1999, 2000 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1998.\n \n-   This file is part of GNU CC.\n+This file is part of GNU CC.\n \n-   GNU CC is free software; you can redistribute it and/or modify\n-   it under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 2, or (at your option)\n-   any later version.\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n \n-   GNU CC is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-   GNU General Public License for more details.\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n \n-   You should have received a copy of the GNU General Public License\n-   along with GNU CC; see the file COPYING.  If not, write to\n-   the Free Software Foundation, 59 Temple Place - Suite 330,\n-   Boston, MA 02111-1307, USA.  */\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n \n #include <config.h>\n #include \"system.h\"\n@@ -399,6 +399,7 @@ print_rtl_graph_with_bb (base, suffix, rtx_first)\n \n \n /* Similar as clean_dump_file, but this time for graph output files.  */\n+\n void\n clean_graph_dump_file (base, suffix)\n      const char *base;\n@@ -417,7 +418,7 @@ clean_graph_dump_file (base, suffix)\n   fp = fopen (buf, \"w\");\n \n   if (fp == NULL)\n-    pfatal_with_name (buf);\n+    fatal_io_error (\"can't open %s\", buf);\n \n   switch (graph_dump_format)\n     {"}, {"sha": "1f7e49e4085a57af5d1dd7308dd20f78a942faf8", "filename": "gcc/hash.c", "status": "modified", "additions": 24, "deletions": 51, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/400500c4a50104969a303ba3c41983b134523e15/gcc%2Fhash.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/400500c4a50104969a303ba3c41983b134523e15/gcc%2Fhash.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhash.c?ref=400500c4a50104969a303ba3c41983b134523e15", "patch": "@@ -1,5 +1,5 @@\n /* hash.c -- hash table routines\n-   Copyright (C) 1993, 1994, 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1993, 1994, 1998, 2001 Free Software Foundation, Inc.\n    Written by Steve Chamberlain <sac@cygnus.com>\n \n This file was lifted from BFD, the Binary File Descriptor library.\n@@ -30,11 +30,11 @@ Boston, MA 02111-1307, USA.  */\n #define obstack_chunk_free free\n \n /* The default number of entries to use when creating a hash table.  */\n-#define DEFAULT_SIZE (1009)\n+#define DEFAULT_SIZE 1009\n \n /* Create a new hash table, given a number of entries.  */\n \n-boolean\n+void\n hash_table_init_n (table, newfunc, hash, comp, size)\n      struct hash_table *table;\n      struct hash_entry *(*newfunc) PARAMS ((struct hash_entry *,\n@@ -47,29 +47,19 @@ hash_table_init_n (table, newfunc, hash, comp, size)\n   unsigned int alloc;\n \n   alloc = size * sizeof (struct hash_entry *);\n-  if (!obstack_begin (&table->memory, alloc))\n-    {\n-      error (\"no memory\");\n-      return false;\n-    }\n+  obstack_begin (&table->memory, alloc);\n   table->table = ((struct hash_entry **)\n \t\t  obstack_alloc (&table->memory, alloc));\n-  if (!table->table)\n-    {\n-      error (\"no memory\");\n-      return false;\n-    }\n   memset ((PTR) table->table, 0, alloc);\n   table->size = size;\n   table->newfunc = newfunc;\n   table->hash = hash;\n   table->comp = comp;\n-  return true;\n }\n \n /* Create a new hash table with the default number of entries.  */\n \n-boolean\n+void\n hash_table_init (table, newfunc, hash, comp)\n      struct hash_table *table;\n      struct hash_entry *(*newfunc) PARAMS ((struct hash_entry *,\n@@ -78,7 +68,7 @@ hash_table_init (table, newfunc, hash, comp)\n      unsigned long (*hash) PARAMS ((hash_table_key));\n      boolean (*comp) PARAMS ((hash_table_key, hash_table_key));\n {\n-  return hash_table_init_n (table, newfunc, hash, comp, DEFAULT_SIZE);\n+  hash_table_init_n (table, newfunc, hash, comp, DEFAULT_SIZE);\n }\n \n /* Free a hash table.  */\n@@ -108,23 +98,21 @@ hash_lookup (table, key, create, copy)\n   hash = (*table->hash)(key);\n \n   index = hash % table->size;\n-  for (hashp = table->table[index];\n-       hashp != (struct hash_entry *) NULL;\n-       hashp = hashp->next)\n-    {\n-      if (hashp->hash == hash\n-\t  && (*table->comp)(hashp->key, key))\n-\treturn hashp;\n-    }\n+  for (hashp = table->table[index]; hashp != 0; hashp = hashp->next)\n+    if (hashp->hash == hash\n+\t&& (*table->comp)(hashp->key, key))\n+      return hashp;\n \n   if (! create)\n-    return (struct hash_entry *) NULL;\n+    return 0;\n \n   hashp = (*table->newfunc) ((struct hash_entry *) NULL, table, key);\n-  if (hashp == (struct hash_entry *) NULL)\n-    return (struct hash_entry *) NULL;\n+  if (hashp == 0)\n+    return 0;\n+\n   if (copy)\n     key = (*copy) (&table->memory, key);\n+\n   hashp->key = key;\n   hashp->hash = hash;\n   hashp->next = table->table[index];\n@@ -135,14 +123,13 @@ hash_lookup (table, key, create, copy)\n \n /* Base method for creating a new hash table entry.  */\n \n-/*ARGSUSED*/\n struct hash_entry *\n hash_newfunc (entry, table, p)\n      struct hash_entry *entry;\n      struct hash_table *table;\n      hash_table_key p ATTRIBUTE_UNUSED;\n {\n-  if (entry == (struct hash_entry *) NULL)\n+  if (entry == 0)\n     entry = ((struct hash_entry *)\n \t     hash_allocate (table, sizeof (struct hash_entry)));\n   return entry;\n@@ -155,12 +142,7 @@ hash_allocate (table, size)\n      struct hash_table *table;\n      unsigned int size;\n {\n-  PTR ret;\n-\n-  ret = obstack_alloc (&table->memory, size);\n-  if (ret == NULL && size != 0)\n-    error (\"no memory\");\n-  return ret;\n+  return obstack_alloc (&table->memory, size);\n }\n \n /* Traverse a hash table.  */\n@@ -172,17 +154,12 @@ hash_traverse (table, func, info)\n      PTR info;\n {\n   unsigned int i;\n+  struct hash_entry *p;\n \n   for (i = 0; i < table->size; i++)\n-    {\n-      struct hash_entry *p;\n-\n-      for (p = table->table[i]; p != NULL; p = p->next)\n-\t{\n-\t  if (! (*func) (p, info))\n-\t    return;\n-\t}\n-    }\n+    for (p = table->table[i]; p != 0; p = p->next)\n+      if (! (*func) (p, info))\n+\treturn;\n }\n \n /* Hash a string.  Return a hash-code for the string.  */\n@@ -206,6 +183,7 @@ string_hash (k)\n       hash ^= hash >> 2;\n       ++len;\n     }\n+\n   hash += len + (len << 17);\n   hash ^= hash >> 2;\n \n@@ -227,18 +205,13 @@ string_compare (k1, k2)\n \n hash_table_key\n string_copy (memory, k)\n-     struct obstack* memory;\n+     struct obstack *memory;\n      hash_table_key k;\n {\n   char *new;\n-  char *string = (char*) k;\n+  char *string = (char *) k;\n \n   new = (char *) obstack_alloc (memory, strlen (string) + 1);\n-  if (!new)\n-    {\n-      error (\"no memory\");\n-      return NULL;\n-    }\n   strcpy (new, string);\n   \n   return new;"}, {"sha": "d79bc08dee142c827c248f99c8fa991b49ab0823", "filename": "gcc/hash.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/400500c4a50104969a303ba3c41983b134523e15/gcc%2Fhash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/400500c4a50104969a303ba3c41983b134523e15/gcc%2Fhash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhash.h?ref=400500c4a50104969a303ba3c41983b134523e15", "patch": "@@ -1,5 +1,5 @@\n /* Header file for generic hash table support.\n-   Copyright (C) 1993, 1994, 1997, 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1993, 1994, 1997, 1998, 2001 Free Software Foundation, Inc.\n    Written by Steve Chamberlain <sac@cygnus.com>\n \n This file was lifted from BFD, the Binary File Descriptor library.\n@@ -76,7 +76,7 @@ struct hash_table\n };\n \n /* Initialize a hash table.  */\n-extern boolean hash_table_init\n+extern void hash_table_init\n   PARAMS ((struct hash_table *,\n \t   struct hash_entry *(*) (struct hash_entry *,\n \t\t\t\t   struct hash_table *,\n@@ -85,7 +85,7 @@ extern boolean hash_table_init\n \t   boolean (*comp) (hash_table_key, hash_table_key)));\n \n /* Initialize a hash table specifying a size.  */\n-extern boolean hash_table_init_n\n+extern void hash_table_init_n\n   PARAMS ((struct hash_table *,\n \t   struct hash_entry *(*) (struct hash_entry *,\n \t\t\t\t   struct hash_table *,"}, {"sha": "ad17577c1132f4f3867cd163efad2c5d8ce4a6ad", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/400500c4a50104969a303ba3c41983b134523e15/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/400500c4a50104969a303ba3c41983b134523e15/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=400500c4a50104969a303ba3c41983b134523e15", "patch": "@@ -1,3 +1,58 @@\n+Sun Feb  4 15:52:44 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* check-init.c (check_init): Call internal_error instead of fatal.\n+\t* expr.c (java_lang_expand_expr): Likewise.\n+\t* jcf-parse.c (get_constant): Likewise.\n+\t* mangle.c (java_mangle_decl): Likewise.\n+\t* parse.y (make_nested_class_name, java_complete_lhs): Likewise.\n+\t(operator_string): Likewise.\n+\t* check-init.c (check_init): Call abort instead of fatal.\n+\t* class.c (build_class_ref): Likewise.\n+\t* constants.c (write_constant_pool): Likewise.\n+\t* decl.c (start_java_method): Likewise.\n+\t* expr.c (push_type, java_stack_pop, java_stack_swap): Likewise.\n+\t(java_stack_dup, encode_newarray_type): Likewise.\n+\t(build_java_array_length_access): Likewise.\n+\t(build_java_check_indexed_type, expand_java_pushc): Likewise.\n+\t(build_java_soft_divmod, build_invokeinterface): Likewise.\n+\t* java-tree.h (INNER_CLASS_P): Likewise.\n+\t* jcf-parse.c (parse_signature, get_name_constant): Likewise.\n+\t(give_name_to_class, get_class_constant): Likewise.\n+\t* jcf-write.c (CHECK_PUT, CHECK_OP, get_access_flags): Likewise.\n+\t(find_constant_index, generate_bytecode_conditional): Likewise.\n+\t(generate_bytecode_insns, perform_relocations): Likewise.\n+\t* lex.c (java_unget_unicode, java_lex): Likewise.\n+\t* mangle.c (mangle_type, mangle_record_type): Likewise.\n+\t(mangle_pointer_type, mangle_array_type, init_mangling): Likewise.\n+\t(finish_mangling): Likewise.\n+\t* parse.h (MARK_FINAL_PARMS): Likewise.\n+\t* parse.y (pop_current_osb, unreachable_stmt_error): Likewise.\n+\t(obtain_incomplete_type, java_complete_class): Likewise.\n+\t(java_check_regular_methods, java_complete_expand_method): Likewise.\n+\t(cut_identifier_in_qualified, check_deprecation): Likewise.\n+\t(patch_invoke, find_applicable_accessible_methods_list): Likewise.\n+\t(java_complete_lhs, lookup_name_in_blocks): Likewise.\n+\t(check_final_variable_indirect_assignment, build_unaryop): Likewise.\n+\t* typeck.c (set_local_type, parse_signature_type): Likewise.\n+\t(parse_signature_string, build_java_signature): Likewise;\n+\t(set_java_signature): Likewise.\n+\t* verify.c (type_stack_dup, CHECK_PC_IN_RANGE): Likewise.\n+\t* class.c (add_method): Call fatal_error instead of fatal.\n+\t(build_static_field_ref): Likewise.\n+\t* expr.c (build_known_method_ref, expand_invoke): Likewise.\n+\t* jcf-parse.c (get_constant, jcf_parse): Likewise.\n+\t* lex.c (java_new_new_lexer): Likewise.\n+\t* jv-scan.c (main): Likewise.\n+\t(fatal_error): Renamed from fatal.\n+\t* jcf-parse.c (yyparse): Call fatal_io_error instead of\n+\tpfatal_with_name.\n+\t* jcf-parse.c (jcf_parse_source): Call fatal_io_error, not fatal.\n+\t(yyparse): Likewise.\n+\t* jcf-write.c (make_class_file_name, write_classfile): Likewise.\n+\t* lex.c (java_get_line_col): Likewise.\n+\t* jcf-parse.c (load_class): Make errors non-fatal.\n+\t* lex.c (byteswap_init, need_byteswap): Only #ifdef HAVE_ICONV.\n+\t\n 2001-02-01  Bryce McKinlay  <bryce@albatross.co.nz>\n \n \t* jvgenmain.c (class_mangling_suffix): Remove unused string."}, {"sha": "9d891968d25990c72b02257e74018823fbd04db4", "filename": "gcc/java/check-init.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/400500c4a50104969a303ba3c41983b134523e15/gcc%2Fjava%2Fcheck-init.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/400500c4a50104969a303ba3c41983b134523e15/gcc%2Fjava%2Fcheck-init.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fcheck-init.c?ref=400500c4a50104969a303ba3c41983b134523e15", "patch": "@@ -1,6 +1,5 @@\n /* Code to test for \"definitive assignment\".\n-\n-   Copyright (C) 1999, 2000  Free Software Foundation, Inc.\n+   Copyright (C) 1999, 2000, 2001  Free Software Foundation, Inc.\n \n This program is free software; you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n@@ -464,7 +463,7 @@ check_init (exp, before)\n \twords when_false = tmp + num_current_words;\n #ifdef ENABLE_JC1_CHECKING\n \tif (TREE_CODE (alt->block) != LOOP_EXPR)\n-\t  fatal (\"internal error in check-init:  EXIT_EXPR not in LOOP_EXPR\");\n+\t  abort ();\n #endif\n \tcheck_bool_init (TREE_OPERAND (exp, 0), before, when_false, when_true);\n \tdone_alternative (when_true, alt);\n@@ -535,7 +534,7 @@ check_init (exp, before)\n \tstruct alternatives *alt = alternatives;\t\n #ifdef ENABLE_JC1_CHECKING\n \tif (TREE_CODE (alt->block) != CLEANUP_POINT_EXPR)\n-\t  fatal (\"internal error in check-init:  WITH_CLEANUP_EXPR not in CLEANUP_POINT_EXPR\");\n+\t  abort ();\n #endif\n \tcheck_init (TREE_OPERAND (exp, 0), before);\n \tUNION (alt->combined, alt->combined, before);\n@@ -728,8 +727,9 @@ check_init (exp, before)\n       break;\n       \n     default:\n-      fatal (\"internal error in check-init: tree code not implemented: %s\",\n-\t    tree_code_name [(int) TREE_CODE (exp)]);\n+      internal_error\n+\t(\"internal error in check-init: tree code not implemented: %s\",\n+\t tree_code_name [(int) TREE_CODE (exp)]);\n     }\n }\n "}, {"sha": "615c0754e6065cce6672e99b7327d9e19ff4cae0", "filename": "gcc/java/class.c", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/400500c4a50104969a303ba3c41983b134523e15/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/400500c4a50104969a303ba3c41983b134523e15/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=400500c4a50104969a303ba3c41983b134523e15", "patch": "@@ -1,5 +1,6 @@\n /* Functions related to building classes and their related objects.\n-   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n+   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001\n+   Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -692,9 +693,12 @@ add_method (this_class, access_flags, name, method_sig)\n {\n   tree handle_class = CLASS_TO_HANDLE_TYPE (this_class);\n   tree function_type, fndecl;\n-  const unsigned char *sig = (const unsigned char*)IDENTIFIER_POINTER (method_sig);\n+  const unsigned char *sig\n+    = (const unsigned char *) IDENTIFIER_POINTER (method_sig);\n+\n   if (sig[0] != '(')\n-    fatal (\"bad method signature\");\n+    fatal_error (\"bad method signature\");\n+\n   function_type = get_type_from_signature (method_sig);\n   fndecl = add_method_1 (handle_class, access_flags, name, function_type);\n   set_java_signature (TREE_TYPE (fndecl), method_sig);\n@@ -928,7 +932,8 @@ build_class_ref (type)\n \t      else if (type == void_type_node)\n                 prim_class_name = \"java.lang.Void\";\n \t      else\n-\t\tfatal (\"internal error - bad type to build_class_ref\");\n+\t\tabort ();\n+\n \t      prim_class = lookup_class (get_identifier (prim_class_name));\n \t      return build (COMPONENT_REF, NULL_TREE,\n \t\t\t    prim_class, TYPE_identifier_node);\n@@ -1000,8 +1005,8 @@ build_static_field_ref (fdecl)\n \t  if (fld == fdecl)\n \t    break;\n \t  if (fld == NULL_TREE)\n-\t    fatal (\"field '%s' not found in class\",\n-\t\t   IDENTIFIER_POINTER (DECL_NAME (fdecl)));\n+\t    fatal_error (\"field '%s' not found in class\",\n+\t\t\t IDENTIFIER_POINTER (DECL_NAME (fdecl)));\n \t  if (FIELD_STATIC (fld))\n \t    field_index++;\n \t}"}, {"sha": "0dcd715b2d9b0727a698f13c797af7b5b073500a", "filename": "gcc/java/constants.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/400500c4a50104969a303ba3c41983b134523e15/gcc%2Fjava%2Fconstants.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/400500c4a50104969a303ba3c41983b134523e15/gcc%2Fjava%2Fconstants.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fconstants.c?ref=400500c4a50104969a303ba3c41983b134523e15", "patch": "@@ -268,10 +268,10 @@ count_constant_pool_bytes (cpool)\n void\n write_constant_pool (cpool, buffer, length)\n      CPool *cpool;\n-     unsigned char* buffer;\n+     unsigned char *buffer;\n      int length;\n {\n-  unsigned char* ptr = buffer;\n+  unsigned char *ptr = buffer;\n   int i = 1;\n   jword *datap = &cpool->data[1];\n   PUT2 (cpool->count);\n@@ -311,8 +311,9 @@ write_constant_pool (cpool, buffer, length)\n \t  break;\n \t}\n     }\n+\n   if (ptr != buffer + length)\n-    fatal(\"internal error - incorrect constant pool\");\n+    abort ();\n }\n \n CPool *outgoing_cpool;"}, {"sha": "f59605906a37ccb6e24ed562fb2705d0946f15c2", "filename": "gcc/java/decl.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/400500c4a50104969a303ba3c41983b134523e15/gcc%2Fjava%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/400500c4a50104969a303ba3c41983b134523e15/gcc%2Fjava%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fdecl.c?ref=400500c4a50104969a303ba3c41983b134523e15", "patch": "@@ -1,6 +1,7 @@\n /* Process declarations and variables for the GNU compiler for the\n    Java(TM) language.\n-   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n+   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001\n+   Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -1817,8 +1818,8 @@ start_java_method (fndecl)\n     {\n       tree parm_name = NULL_TREE, parm_decl;\n       tree parm_type = TREE_VALUE (tem);\n-      if (i >= DECL_MAX_LOCALS(fndecl))\n-\tfatal (\"function has more parameters than local slots\");\n+      if (i >= DECL_MAX_LOCALS (fndecl))\n+\tabort ();\n \n       parm_decl = build_decl (PARM_DECL, parm_name, parm_type);\n       DECL_CONTEXT (parm_decl) = fndecl;"}, {"sha": "d74dfc035aa7802d0b352256499d9737c2ce9122", "filename": "gcc/java/expr.c", "status": "modified", "additions": 33, "deletions": 21, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/400500c4a50104969a303ba3c41983b134523e15/gcc%2Fjava%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/400500c4a50104969a303ba3c41983b134523e15/gcc%2Fjava%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexpr.c?ref=400500c4a50104969a303ba3c41983b134523e15", "patch": "@@ -1,5 +1,6 @@\n /* Process expressions for the GNU compiler for the Java(TM) language.\n-   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n+   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001\n+   Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -279,7 +280,7 @@ push_type (type)\n      tree type;\n {\n   if (! push_type_0 (type))\n-    fatal (\"stack overflow\");\n+    abort ();\n }\n \n static void\n@@ -497,14 +498,17 @@ java_stack_pop (count)\n   while (count > 0)\n     {\n       tree type, val;\n+\n       if (stack_pointer == 0)\n-\tfatal (\"stack underflow\");\n+\tabort ();\n+\n       type = stack_type_map[stack_pointer - 1];\n       if (type == TYPE_SECOND)\n \t{\n \t  count--;\n \t  if (stack_pointer == 1 || count <= 0)\n-\t    fatal (\"stack underflow\");\n+\t    abort ();\n+\n \t  type = stack_type_map[stack_pointer - 2];\n \t}\n       val = pop_value (type);\n@@ -526,7 +530,8 @@ java_stack_swap ()\n       || (type2 = stack_type_map[stack_pointer - 2]) == TYPE_UNKNOWN\n       || type1 == TYPE_SECOND || type2 == TYPE_SECOND\n       || TYPE_IS_WIDE (type1) || TYPE_IS_WIDE (type2))\n-    fatal (\"bad stack swap\");\n+    /* Bad stack swap.  */\n+    abort ();\n \n   flush_quick_stack ();\n   decl1 = find_stack_slot (stack_pointer - 1, type1);\n@@ -562,15 +567,18 @@ java_stack_dup (size, offset)\n       if (type == TYPE_SECOND)\n \t{\n \t  if (src_index <= low_index)\n-\t    fatal (\"dup operation splits 64-bit number\");\n+\t    /* Dup operation splits 64-bit number.  */\n+\t    abort ();\n+\n \t  stack_type_map[dst_index] = type;\n \t  src_index--;  dst_index--;\n \t  type = stack_type_map[src_index];\n \t  if (! TYPE_IS_WIDE (type))\n-            fatal (\"internal error - dup operation\");\n+\t    abort ();\n \t}\n       else if (TYPE_IS_WIDE (type))\n-\tfatal (\"internal error - dup operation\");\n+\tabort ();\n+\n       if (src_index != dst_index)\n \t{\n \t  tree src_decl = find_stack_slot (src_index, type);\n@@ -669,7 +677,7 @@ encode_newarray_type (type)\n   else if (type == long_type_node)\n     return 11;\n   else\n-    fatal (\"Can't compute type code - patch_newarray\");\n+    abort ();\n }\n \n /* Build a call to _Jv_ThrowBadArrayIndex(), the\n@@ -695,11 +703,14 @@ build_java_array_length_access (node)\n {\n   tree type = TREE_TYPE (node);\n   HOST_WIDE_INT length;\n+\n   if (!is_array_type_p (type))\n-    fatal (\"array length on a non-array reference\");\n+    abort ();\n+\n   length = java_array_type_length (type);\n   if (length >= 0)\n     return build_int_2 (length, 0);\n+\n   return fold (build1 (INDIRECT_REF,\n \t\t       int_type_node,\n \t\t       fold (build (PLUS_EXPR, ptr_type_node,\n@@ -807,7 +818,7 @@ build_java_check_indexed_type (array_node, indexed_type)\n   tree elt_type;\n \n   if (!is_array_type_p (TREE_TYPE (array_node)))\n-    fatal (\"array indexing on a non-array reference\");\n+    abort ();\n \n   elt_type = (TYPE_ARRAY_ELEMENT (TREE_TYPE (TREE_TYPE (array_node))));\n \n@@ -819,7 +830,7 @@ build_java_check_indexed_type (array_node, indexed_type)\n     return boolean_type_node;\n \n   if (indexed_type != elt_type )\n-    fatal (\"type array element mismatch\");\n+    abort ();\n   else\n     return indexed_type;\n }\n@@ -1041,7 +1052,8 @@ expand_java_pushc (ival, type)\n       value = build_real (type, x);\n     }\n   else\n-    fatal (\"internal error in expand_java_pushc\");\n+    abort ();\n+\n   push_value (value);\n }\n \n@@ -1257,7 +1269,7 @@ build_java_soft_divmod (op, type, op1, op2)\n     }\n \n   if (! call)\n-    fatal (\"Internal compiler error in build_java_soft_divmod\");\n+    abort ();\n \t\t  \n   call = build (CALL_EXPR, type,\n \t\tbuild_address_of (call),\n@@ -1733,8 +1745,8 @@ build_known_method_ref (method, method_type, self_type, method_signature, arg_li\n \t  if (method == meth)\n \t    break;\n \t  if (meth == NULL_TREE)\n-\t    fatal (\"method '%s' not found in class\",\n-\t\t   IDENTIFIER_POINTER (DECL_NAME (method)));\n+\t    fatal_error (\"method '%s' not found in class\",\n+\t\t\t IDENTIFIER_POINTER (DECL_NAME (method)));\n \t  method_index++;\n \t}\n       method_index *= int_size_in_bytes (method_type_node);\n@@ -1831,7 +1843,7 @@ build_invokeinterface (dtable, method)\n \t  break;\n \t}\n       if (meth == NULL_TREE)\n-        fatal (\"internal error in build_invokeinterface\");\n+\tabort ();\n     }\n \n   lookup_arg = tree_cons (NULL_TREE, dtable,\n@@ -1858,7 +1870,8 @@ expand_invoke (opcode, method_ref_index, nargs)\n   tree method_name = COMPONENT_REF_NAME (&current_jcf->cpool, method_ref_index);\n   tree self_type = get_class_constant\n     (current_jcf, COMPONENT_REF_CLASS_INDEX(&current_jcf->cpool, method_ref_index));\n-  const char *self_name = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (self_type)));\n+  const char *self_name\n+    = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (self_type)));\n   tree call, func, method, arg_list, method_type;\n   tree cond = NULL_TREE;\n \n@@ -1867,7 +1880,7 @@ expand_invoke (opcode, method_ref_index, nargs)\n       load_class (self_type, 1);\n       safe_layout_class (self_type);\n       if (TREE_CODE (TYPE_SIZE (self_type)) == ERROR_MARK)\n-\tfatal (\"failed to find class '%s'\", self_name);\n+\tfatal_error (\"failed to find class '%s'\", self_name);\n     }\n   layout_class_methods (self_type);\n \n@@ -2501,8 +2514,7 @@ java_lang_expand_expr (exp, target, tmode, modifier)\n       return const0_rtx;\n \n     default:\n-      fatal (\"Can't expand '%s' tree - java_lang_expand_expr\",\n-\t     tree_code_name [TREE_CODE (exp)]);\n+      internal_error (\"Can't expand %s\", tree_code_name [TREE_CODE (exp)]);\n     }\n }\n "}, {"sha": "7aeab9a8e35dee8eda90a0213c41652df8f92975", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/400500c4a50104969a303ba3c41983b134523e15/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/400500c4a50104969a303ba3c41983b134523e15/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=400500c4a50104969a303ba3c41983b134523e15", "patch": "@@ -1415,7 +1415,7 @@ extern tree *type_map;\n \t\t\t     INNER_CLASS_DECL_P (NODE) :\t\t      \\\n \t\t\t     (TREE_CODE (NODE) == RECORD_TYPE ? \t      \\\n \t\t\t      INNER_CLASS_TYPE_P (NODE) : \t\t      \\\n-\t\t\t      (fatal (\"INNER_CLASS_P: Wrong node type\"), 0)))\n+\t\t\t      (abort (), 0)))\n \n /* On a TYPE_DECL, hold the list of inner classes defined within the\n    scope of TYPE_DECL.  */"}, {"sha": "7cc1de62c11211c2223691dc08a78c402c44fd51", "filename": "gcc/java/jcf-parse.c", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/400500c4a50104969a303ba3c41983b134523e15/gcc%2Fjava%2Fjcf-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/400500c4a50104969a303ba3c41983b134523e15/gcc%2Fjava%2Fjcf-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-parse.c?ref=400500c4a50104969a303ba3c41983b134523e15", "patch": "@@ -240,14 +240,12 @@ parse_signature (jcf, sig_index)\n      JCF *jcf;\n      int sig_index;\n {\n-  if (sig_index <= 0 || sig_index >= JPOOL_SIZE(jcf)\n+  if (sig_index <= 0 || sig_index >= JPOOL_SIZE (jcf)\n       || JPOOL_TAG (jcf, sig_index) != CONSTANT_Utf8)\n-    fatal (\"invalid field/method signature\");\n+    abort ();\n   else\n-    {\n-      return parse_signature_string (JPOOL_UTF_DATA (jcf, sig_index),\n-\t\t\t\t     JPOOL_UTF_LENGTH (jcf, sig_index));\n-    }\n+    return parse_signature_string (JPOOL_UTF_DATA (jcf, sig_index),\n+\t\t\t\t   JPOOL_UTF_LENGTH (jcf, sig_index));\n }\n \n void\n@@ -364,7 +362,8 @@ get_constant (jcf, index)\n \t  {\n \t    int char_len = UT8_CHAR_LENGTH (*utf8);\n \t    if (char_len < 0 || char_len > 3 || char_len > i)\n- \t      fatal (\"bad string constant\");\n+ \t      fatal_error (\"bad string constant\");\n+\n \t    utf8 += char_len;\n \t    i -= char_len;\n \t    str_len++;\n@@ -415,12 +414,12 @@ get_constant (jcf, index)\n     default:\n       goto bad;\n     }\n-  JPOOL_TAG(jcf, index) = tag | CONSTANT_ResolvedFlag;\n+  JPOOL_TAG (jcf, index) = tag | CONSTANT_ResolvedFlag;\n   jcf->cpool.data [index] = (jword) value;\n   return value;\n  bad:\n-  fatal (\"bad value constant type %d, index %d\", \n-\t JPOOL_TAG( jcf, index ), index);\n+  internal_error (\"bad value constant type %d, index %d\", \n+\t\t  JPOOL_TAG (jcf, index), index);\n }\n \n tree\n@@ -429,8 +428,10 @@ get_name_constant (jcf, index)\n   int index;\n {\n   tree name = get_constant (jcf, index);\n+\n   if (TREE_CODE (name) != IDENTIFIER_NODE)\n-    fatal (\"bad nameandtype index %d\", index);\n+    abort ();\n+\n   return name;\n }\n \n@@ -479,9 +480,9 @@ give_name_to_class (jcf, i)\n      JCF *jcf;\n      int i;\n {\n-  if (i <= 0 || i >= JPOOL_SIZE(jcf)\n+  if (i <= 0 || i >= JPOOL_SIZE (jcf)\n       || JPOOL_TAG (jcf, i) != CONSTANT_Class)\n-    fatal (\"bad class index %d\", i);\n+    abort ();\n   else\n     {\n       tree this_class;\n@@ -507,16 +508,17 @@ tree\n get_class_constant (JCF *jcf , int i)\n {\n   tree type;\n-  if (i <= 0 || i >= JPOOL_SIZE(jcf)\n+  if (i <= 0 || i >= JPOOL_SIZE (jcf)\n       || (JPOOL_TAG (jcf, i) & ~CONSTANT_ResolvedFlag) != CONSTANT_Class)\n-    fatal (\"bad class index %d\", i);\n+    abort ();\n \n   if (JPOOL_TAG (jcf, i) != CONSTANT_ResolvedClass)\n     {\n       int name_index = JPOOL_USHORT1 (jcf, i);\n       /* verify_constant_pool confirmed that name_index is a CONSTANT_Utf8. */\n       const char *name = JPOOL_UTF_DATA (jcf, name_index);\n       int nlength = JPOOL_UTF_LENGTH (jcf, name_index);\n+\n       if (name[0] == '[')  /* Handle array \"classes\". */\n \t  type = TREE_TYPE (parse_signature_string (name, nlength));\n       else\n@@ -614,7 +616,7 @@ load_class (class_or_name, verbose)\n     name = DECL_NAME (TYPE_NAME (class_or_name));\n \n   if (read_class (name) == 0 && verbose)\n-    fatal (\"Cannot find file for class %s.\", IDENTIFIER_POINTER (name));\n+    error (\"Cannot find file for class %s.\", IDENTIFIER_POINTER (name));\n }\n \n /* Parse a source file when JCF refers to a source file.  */\n@@ -637,12 +639,10 @@ jcf_parse_source ()\n   if (!HAS_BEEN_ALREADY_PARSED_P (file))\n     {\n       if (!(finput = fopen (input_filename, \"r\")))\n-\tfatal (\"input file `%s' just disappeared - jcf_parse_source\",\n-\t       input_filename);\n+\tfatal_io_error (\"can't reopen %s\", input_filename);\n       parse_source_file (file, finput);\n       if (fclose (finput))\n-\tfatal (\"can't close input file `%s' stream - jcf_parse_source\",\n-\t       input_filename);\n+\tfatal_io_error (\"can't close %s\", input_filename);\n     }\n   java_pop_parser_context (IS_A_COMMAND_LINE_FILENAME_P (file));\n   java_parser_context_restore_global ();\n@@ -658,13 +658,13 @@ jcf_parse (jcf)\n   tree current;\n \n   if (jcf_parse_preamble (jcf) != 0)\n-    fatal (\"Not a valid Java .class file.\\n\");\n+    fatal_error (\"not a valid Java .class file\");\n   code = jcf_parse_constant_pool (jcf);\n   if (code != 0)\n-    fatal (\"error while parsing constant pool\");\n+    fatal_error (\"error while parsing constant pool\");\n   code = verify_constant_pool (jcf);\n   if (code > 0)\n-    fatal (\"error in constant pool entry #%d\\n\", code);\n+    fatal_error (\"error in constant pool entry #%d\\n\", code);\n \n   jcf_parse_class (jcf);\n   if (main_class == NULL_TREE)\n@@ -689,13 +689,13 @@ jcf_parse (jcf)\n   \n   code = jcf_parse_fields (jcf);\n   if (code != 0)\n-    fatal (\"error while parsing fields\");\n+    fatal_error (\"error while parsing fields\");\n   code = jcf_parse_methods (jcf);\n   if (code != 0)\n-    fatal (\"error while parsing methods\");\n+    fatal_error (\"error while parsing methods\");\n   code = jcf_parse_final_attributes (jcf);\n   if (code != 0)\n-    fatal (\"error while parsing final attributes\");\n+    fatal_error (\"error while parsing final attributes\");\n \n   /* The fields of class_type_node are already in correct order. */\n   if (current_class != class_type_node && current_class != object_type_node)\n@@ -954,14 +954,14 @@ yyparse ()\n       \n       /* Close previous descriptor, if any */\n       if (main_jcf->read_state && fclose (main_jcf->read_state))\n-\tfatal (\"failed to close input file `%s' - yyparse\",\n-\t       (main_jcf->filename ? main_jcf->filename : \"<unknown>\"));\n+\tfatal_io_error (\"can't close %s\",\n+\t\t\tmain_jcf->filename ? main_jcf->filename : \"<unknown>\");\n       \n       /* Set jcf up and open a new file */\n       JCF_ZERO (main_jcf);\n       main_jcf->read_state = fopen (IDENTIFIER_POINTER (name), \"rb\");\n       if (main_jcf->read_state == NULL)\n-\tpfatal_with_name (IDENTIFIER_POINTER (name));\n+\tfatal_io_error (\"can't open %s\", IDENTIFIER_POINTER (name));\n       \n       /* Set new input_filename and finput */\n       finput = main_jcf->read_state;"}, {"sha": "5cb4fb368a2b095b57c021af1efeecdaf2d21298", "filename": "gcc/java/jcf-write.c", "status": "modified", "additions": 33, "deletions": 36, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/400500c4a50104969a303ba3c41983b134523e15/gcc%2Fjava%2Fjcf-write.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/400500c4a50104969a303ba3c41983b134523e15/gcc%2Fjava%2Fjcf-write.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-write.c?ref=400500c4a50104969a303ba3c41983b134523e15", "patch": "@@ -1,5 +1,5 @@\n /* Write out a Java(TM) class file.\n-   Copyright (C) 1998, 1999, 2000 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -355,14 +355,15 @@ static void append_innerclasses_attribute_entry PARAMS ((struct jcf_partial *, t\n static int CHECK_PUT PARAMS ((void *, struct jcf_partial *, int));\n \n static int\n-CHECK_PUT(ptr, state, i)\n+CHECK_PUT (ptr, state, i)\n      void *ptr;\n      struct jcf_partial *state;\n      int i;\n {\n-  if ((unsigned char *)ptr < state->chunk->data\n-      || (unsigned char*)ptr + i > state->chunk->data + state->chunk->size)\n-    fatal (\"internal error - CHECK_PUT failed\");\n+  if ((unsigned char *) ptr < state->chunk->data\n+      || (unsigned char *) ptr + i > state->chunk->data + state->chunk->size)\n+    abort ();\n+\n   return 0;\n }\n #else\n@@ -411,16 +412,16 @@ alloc_chunk (last, data, size, work)\n static int CHECK_OP PARAMS ((struct jcf_partial *));\n \n static int\n-CHECK_OP(struct jcf_partial *state)\n+CHECK_OP (state)\n+     struct jcf_partial *state;\n {\n   if (state->bytecode.ptr > state->bytecode.limit)\n-    {\n-      fatal(\"internal error - CHECK_OP failed\");\n-    }\n+    abort ();\n+\n   return 0;\n }\n #else\n-#define CHECK_OP(STATE) ((void)0)\n+#define CHECK_OP(STATE) ((void) 0)\n #endif\n \n static unsigned char *\n@@ -687,7 +688,8 @@ get_access_flags (decl)\n \tflags |= ACC_PRIVATE;\n     }\n   else\n-    fatal (\"internal error - bad argument to get_access_flags\");\n+    abort ();\n+\n   if (TREE_CODE (decl) == FUNCTION_DECL)\n     {\n       if (METHOD_NATIVE (decl))\n@@ -833,11 +835,10 @@ find_constant_index (value, state)\n \t}\n     }\n   else if (TREE_CODE (value) == STRING_CST)\n-    {\n-      return find_string_constant (&state->cpool, value);\n-    }\n+    return find_string_constant (&state->cpool, value);\n+\n   else\n-    fatal (\"find_constant_index - bad type\");\n+    abort ();\n }\n \n /* Push 64-bit long constant on VM stack.\n@@ -1176,12 +1177,12 @@ generate_bytecode_conditional (exp, true_label, false_label,\n \t\t\t\t       true_label, false_label,\n \t\t\t\t       true_branch_first, state);\n \tif (state->code_SP != save_SP_after)\n-\t  fatal (\"internal error  non-matching SP\");\n+\t  abort ();\n       }\n       break;\n     case TRUTH_NOT_EXPR:\n-      generate_bytecode_conditional (TREE_OPERAND (exp, 0), false_label, true_label,\n-\t\t\t\t     ! true_branch_first, state);\n+      generate_bytecode_conditional (TREE_OPERAND (exp, 0), false_label,\n+\t\t\t\t     true_label, ! true_branch_first, state);\n       break;\n     case TRUTH_ANDIF_EXPR:\n       {\n@@ -1345,7 +1346,7 @@ generate_bytecode_conditional (exp, true_label, false_label,\n       break;\n     }\n   if (save_SP != state->code_SP)\n-    fatal (\"internal error - SP mismatch\");\n+    abort ();\n }\n \n /* Call pending cleanups i.e. those for surrounding CLEANUP_POINT_EXPRs\n@@ -2062,12 +2063,12 @@ generate_bytecode_insns (exp, target, state)\n       else if (TREE_CODE (exp) == ARRAY_REF)\n \t{\n \t  jopcode = OPCODE_iastore + adjust_typed_op (TREE_TYPE (exp), 7);\n-\t  RESERVE(1);\n+\t  RESERVE (1);\n \t  OP1 (jopcode);\n \t  NOTE_POP (TYPE_IS_WIDE (TREE_TYPE (exp)) ? 4 : 3);\n \t}\n       else\n-\tfatal (\"internal error (bad lhs to MODIFY_EXPR)\");\n+\tabort ();\n       break;\n     case PLUS_EXPR:\n       jopcode = OPCODE_iadd;\n@@ -2579,8 +2580,8 @@ generate_bytecode_insns (exp, target, state)\n \t      {\n \t\tDECL_CONTEXT (f) = saved_context;\n \t\tif (nargs <= 0)\n-\t\t  fatal (\"Illegal number of arguments to invokeinterface, nargs=%d\",\n-\t\t\t nargs);\n+\t\t  abort ();\n+\n \t\tOP1 (nargs);\n \t\tOP1 (0);\n \t      }\n@@ -2767,7 +2768,7 @@ perform_relocations (state)\n \t    }\n \t}\n       if (new_ptr != chunk->data)\n-\tfatal (\"internal error - perform_relocations\");\n+\tabort ();\n     }\n   state->code_length = pc;\n }\n@@ -3288,16 +3289,11 @@ make_class_file_name (clas)\n       if (s == NULL)\n \tbreak;\n       *s = '\\0';\n-      if (stat (r, &sb) == -1)\n-\t{\n+      if (stat (r, &sb) == -1\n \t  /* Try to make it.  */\n-\t  if (mkdir (r, 0755) == -1)\n-\t    {\n-\t      fatal (\"failed to create directory `%s'\", r);\n-\t      free (r);\n-\t      return NULL;\n-\t    }\n-\t}\n+\t  && mkdir (r, 0755) == -1)\n+\tfatal_io_error (\"can't create directory %s\", r);\n+\n       *s = DIR_SEPARATOR;\n       /* Skip consecutive separators.  */\n       for (dname = s + 1; *dname && *dname == DIR_SEPARATOR; ++dname)\n@@ -3321,15 +3317,16 @@ write_classfile (clas)\n \n   if (class_file_name != NULL)\n     {\n-      FILE* stream = fopen (class_file_name, \"wb\");\n+      FILE *stream = fopen (class_file_name, \"wb\");\n       if (stream == NULL)\n-\tfatal (\"failed to open `%s' for writing\", class_file_name);\n+\tfatal_io_error (\"can't to open %s\", class_file_name);\n+\n       jcf_dependency_add_target (class_file_name);\n       init_jcf_state (state, work);\n       chunks = generate_classfile (clas, state);\n       write_chunks (stream, chunks);\n       if (fclose (stream))\n-\tfatal (\"failed to close after writing `%s'\", class_file_name);\n+\tfatal_io_error (\"can't close %s\", class_file_name);\n       free (class_file_name);\n     }\n   release_jcf_state (state);"}, {"sha": "d5b0d0a678328a666e8b76fb5b62f53c08f9af1c", "filename": "gcc/java/jv-scan.c", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/400500c4a50104969a303ba3c41983b134523e15/gcc%2Fjava%2Fjv-scan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/400500c4a50104969a303ba3c41983b134523e15/gcc%2Fjava%2Fjv-scan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjv-scan.c?ref=400500c4a50104969a303ba3c41983b134523e15", "patch": "@@ -1,5 +1,5 @@\n /* Main for jv-scan\n-   Copyright (C) 1998, 1999, 2000 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n    Contributed by Alexandre Petit-Bianco (apbianco@cygnus.com)\n \n This file is part of GNU CC.\n@@ -36,7 +36,8 @@ Boston, MA 02111-1307, USA.  */\n \n #include <getopt.h>\n \n-void fatal PARAMS ((const char *s, ...)) ATTRIBUTE_PRINTF_1 ATTRIBUTE_NORETURN;\n+extern void fatal_error PARAMS ((const char *s, ...))\n+     ATTRIBUTE_PRINTF_1 ATTRIBUTE_NORETURN;\n void warning PARAMS ((const char *s, ...)) ATTRIBUTE_PRINTF_1;\n void gcc_obstack_init PARAMS ((struct obstack *obstack));\n void report PARAMS ((void));\n@@ -178,10 +179,11 @@ DEFUN (main, (argc, argv),\n \n   /* Check on bad usage */\n   if (flag_find_main + flag_dump_class + flag_complexity > 1)\n-    fatal (\"Only one of `--print-main', `--list-class', and `--complexity' allowed\");\n+    fatal_error\n+      (\"Only one of `--print-main', `--list-class', and `--complexity' allowed\");\n \n   if (output_file && !(out = fopen (output_file, \"w\")))\n-    fatal (\"Can't open output file `%s'\", output_file);\n+    fatal_error (\"Can't open output file `%s'\", output_file);\n \n   ft = ftell (out);\n \n@@ -217,7 +219,7 @@ DEFUN (main, (argc, argv),\n \t    reset_report ();\n \t  }\n \telse\n-\t  fatal (\"File not found `%s'\", argv [i]);\n+\t  fatal_error (\"File not found `%s'\", argv [i]);\n       }\n \n   /* Flush and close */\n@@ -235,7 +237,7 @@ DEFUN (main, (argc, argv),\n    functions */\n \n void\n-fatal VPARAMS ((const char *s, ...))\n+fatal_error VPARAMS ((const char *s, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   const char *s;"}, {"sha": "06eb35d7937723dc5e460e176e9600a3fcac8b4d", "filename": "gcc/java/lex.c", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/400500c4a50104969a303ba3c41983b134523e15/gcc%2Fjava%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/400500c4a50104969a303ba3c41983b134523e15/gcc%2Fjava%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flex.c?ref=400500c4a50104969a303ba3c41983b134523e15", "patch": "@@ -67,6 +67,7 @@ static int utf8_cmp PARAMS ((const unsigned char *, int, const char *));\n \n java_lexer *java_new_lexer PARAMS ((FILE *, const char *));\n \n+#ifdef HAVE_ICONV\n /* This is nonzero if we have initialized `need_byteswap'.  */\n static int byteswap_init = 0;\n \n@@ -75,6 +76,7 @@ static int byteswap_init = 0;\n    doing a conversion once at startup and seeing what happens.  This\n    flag holds the results of this determination.  */\n static int need_byteswap = 0;\n+#endif\n \n void\n java_init_lex (finput, encoding)\n@@ -161,7 +163,9 @@ static void\n java_unget_unicode ()\n {\n   if (!ctxp->c_line->current)\n-    fatal (\"can't unget unicode - java_unget_unicode\");\n+    /* Can't unget unicode.  */\n+    abort ();\n+\n   ctxp->c_line->current--;\n   ctxp->c_line->char_col -= JAVA_COLUMN_DELTA (0);\n }\n@@ -211,6 +215,7 @@ java_allocate_new_line ()\n }\n \n /* Create a new lexer object.  */\n+\n java_lexer *\n java_new_lexer (finput, encoding)\n      FILE *finput;\n@@ -277,8 +282,8 @@ java_new_lexer (finput, encoding)\n     {\n       /* If iconv failed, use the internal decoder if the default\n \t encoding was requested.  This code is used on platforms where\n-\t iconv() exists but is insufficient for our needs.  For\n-\t instance, on Solaris 2.5 iconv() cannot handle UTF-8 or UCS-2.  */\n+\t iconv exists but is insufficient for our needs.  For\n+\t instance, on Solaris 2.5 iconv cannot handle UTF-8 or UCS-2.  */\n       if (strcmp (encoding, DEFAULT_ENCODING))\n \tenc_error = 1;\n #ifdef HAVE_ICONV\n@@ -288,7 +293,7 @@ java_new_lexer (finput, encoding)\n     }\n \n   if (enc_error)\n-    fatal (\"unknown encoding: `%s'\", encoding);\n+    fatal_error (\"unknown encoding: `%s'\", encoding);\n \n   return lex;\n }\n@@ -956,7 +961,7 @@ java_lex (java_lval)\n   ctxp->elc.prev_col = ctxp->elc.col;\n   ctxp->elc.col = ctxp->c_line->char_col - JAVA_COLUMN_DELTA (-1);\n   if (ctxp->elc.col < 0)\n-    fatal (\"ctxp->elc.col < 0 - java_lex\");\n+    abort ();\n \n   /* Numeric literals */\n   if (JAVA_ASCII_DIGIT (c) || (c == '.'))\n@@ -1712,7 +1717,7 @@ java_get_line_col (filename, line, col)\n   char *base;\n \n   if (!(fp = fopen (filename, \"r\")))\n-    fatal (\"Can't open file - java_display_line_col\");\n+    fatal_io_error (\"can't open %s\", filename);\n \n   while (cline != line)\n     {"}, {"sha": "1c83ac2fc34478a077a8efba66175f4ee803a718", "filename": "gcc/java/mangle.c", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/400500c4a50104969a303ba3c41983b134523e15/gcc%2Fjava%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/400500c4a50104969a303ba3c41983b134523e15/gcc%2Fjava%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fmangle.c?ref=400500c4a50104969a303ba3c41983b134523e15", "patch": "@@ -85,8 +85,7 @@ java_mangle_decl (obstack, decl)\n       mangle_method_decl (decl);\n       break;\n     default:\n-      fatal (\"Can't mangle `%s\\' -- java_mangle_decl\", \n-\t     tree_code_name [TREE_CODE (decl)]);\n+      internal_error (\"Can't mangle %s\", tree_code_name [TREE_CODE (decl)]);\n     }\n   return finish_mangling ();\n }\n@@ -368,7 +367,7 @@ mangle_type (type)\n       break;\n     bad_type:\n     default:\n-      fatal (\"internal error - trying to mangle unknown type\");\n+      abort ();\n     }\n }\n \n@@ -481,7 +480,7 @@ mangle_record_type (type, from_pointer)\n   do { obstack_1grow (mangle_obstack, 'N'); nadded_p = 1; } while (0)\n \n   if (TREE_CODE (type) != RECORD_TYPE)\n-    fatal (\"Non RECORD_TYPE argument -- mangle_record_type\");\n+    abort ();\n \n   if (!TYPE_PACKAGE_LIST (type))\n     set_type_package_list (type);\n@@ -534,7 +533,7 @@ mangle_pointer_type (type)\n   pointer_type = type;\n   type = TREE_TYPE (type);\n   if (TREE_CODE (type) != RECORD_TYPE)\n-    fatal (\"Double indirection found -- mangle_pointer_type\");\n+    abort ();\n   \n   obstack_1grow (mangle_obstack, 'P');\n   if (mangle_record_type (type, /* for_pointer = */ 1))\n@@ -560,7 +559,8 @@ mangle_array_type (p_type)\n \n   type = TREE_TYPE (p_type);\n   if (!type)\n-    fatal (\"Non pointer array type -- mangle_array_type\");\n+    abort ();\n+\n   elt_type = TYPE_ARRAY_ELEMENT (type);\n \n   /* We cache a bit of the Jarray <> mangle. */\n@@ -736,7 +736,8 @@ init_mangling (obstack)\n   if (!compression_table)\n     compression_table = make_tree_vec (10);\n   else\n-    fatal (\"Mangling already in progress -- init_mangling\");\n+    /* Mangling already in progress.  */\n+    abort ();\n \n   /* Mangled name are to be suffixed */\n   obstack_grow (mangle_obstack, \"_Z\", 2);\n@@ -754,7 +755,8 @@ finish_mangling ()\n   tree result;\n \n   if (!compression_table)\n-    fatal (\"Mangling already finished -- finish_mangling\");\n+    /* Mangling already finished.  */\n+    abort ();\n \n   ggc_del_root (&compression_table);\n   compression_table = NULL_TREE;"}, {"sha": "dc2590708ce680d3d9dd6bb3d4bca277b34bc5ca", "filename": "gcc/java/parse.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/400500c4a50104969a303ba3c41983b134523e15/gcc%2Fjava%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/400500c4a50104969a303ba3c41983b134523e15/gcc%2Fjava%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.h?ref=400500c4a50104969a303ba3c41983b134523e15", "patch": "@@ -1,5 +1,5 @@\n /* Language parser definitions for the GNU compiler for the Java(TM) language.\n-   Copyright (C) 1997, 1998, 1999, 2000 Free Software Foundation, Inc.\n+   Copyright (C) 1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n    Contributed by Alexandre Petit-Bianco (apbianco@cygnus.com)\n \n This file is part of GNU CC.\n@@ -290,7 +290,7 @@ extern tree stabilize_reference PARAMS ((tree));\n \t current = TREE_CHAIN (current), list = TREE_CHAIN (list))\t\\\n       ARG_FINAL_P (current) = ARG_FINAL_P (list);\t\t\t\\\n     if (current != list)\t\t\t\t\t\t\\\n-      fatal (\"MARK_FINAL_PARMS\");\t\t\t\t\t\\\n+      abort ();\t\t\t\t\t\t\t\t\\\n   }\n \n /* Reset the ARG_FINAL_P that might have been set in method M args.  */"}, {"sha": "33c868c22264280b17e029f7efbacb08b74f36f8", "filename": "gcc/java/parse.y", "status": "modified", "additions": 20, "deletions": 22, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/400500c4a50104969a303ba3c41983b134523e15/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/400500c4a50104969a303ba3c41983b134523e15/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=400500c4a50104969a303ba3c41983b134523e15", "patch": "@@ -2596,7 +2596,7 @@ pop_current_osb (ctxp)\n   int to_return;\n \n   if (ctxp->osb_depth < 0)\n-    fatal (\"osb stack underflow\");\n+    abort ();\n   \n   to_return = CURRENT_OSB (ctxp);\n   ctxp->osb_depth--;\n@@ -3167,7 +3167,7 @@ unreachable_stmt_error (node)\n       parse_error_context (wfl_operator, \"Unreachable statement\");\n     }\n   else\n-    fatal (\"Can't get valid statement - unreachable_stmt_error\");\n+    abort ();\n }\n \n int\n@@ -3467,8 +3467,7 @@ make_nested_class_name (cpc_list)\n   /* Why is NO_DOLLAR_IN_LABEL defined? */\n #if 0\n #ifdef NO_DOLLAR_IN_LABEL\n-  fatal (\"make_nested_class_name: Can't use '$' as a separator \"\n-\t \"for inner classes\");\n+  internal_error (\"Can't use '$' as a separator for inner classes\");\n #endif\n #endif\n   obstack_1grow (&temporary_obstack, '$');\n@@ -4985,7 +4984,7 @@ obtain_incomplete_type (type_name)\n   else if (INCOMPLETE_TYPE_P (type_name))\n     name = TYPE_NAME (type_name);\n   else\n-    fatal (\"invalid type name - obtain_incomplete_type\");\n+    abort ();\n \n   for (ptr = ctxp->incomplete_class; ptr; ptr = TREE_CHAIN (ptr))\n     if (TYPE_NAME (ptr) == name)\n@@ -5422,8 +5421,7 @@ java_complete_class ()\n \t      break;\n \n \t    default:\n-\t      fatal (\"Can't handle patch code %d - java_complete_class\",\n-\t\t     JDEP_KIND (dep));\n+\t      abort ();\n \t    }\n \t}\n     }\n@@ -6180,7 +6178,7 @@ java_check_regular_methods (class_decl)\n   java_check_abstract_method_definitions (class_decl);\n \n   if (!saw_constructor)\n-    fatal (\"No constructor found\");\n+    abort ();\n }\n \n /* Return a non zero value if the `throws' clause of METHOD (if any)\n@@ -7723,7 +7721,7 @@ java_complete_expand_method (mdecl)\n       /* Pop the exceptions and sanity check */\n       POP_EXCEPTIONS();\n       if (currently_caught_type_list)\n-\tfatal (\"Exception list non empty - java_complete_expand_method\");\n+\tabort ();\n \n       if (flag_emit_xref)\n \tDECL_FUNCTION_THROWS (mdecl) = exception_copy;\n@@ -8736,7 +8734,9 @@ cut_identifier_in_qualified (wfl)\n     if (!TREE_CHAIN (q))\n       {\n \tif (!previous)\n-\t  fatal (\"Operating on a non qualified qualified WFL - cut_identifier_in_qualified\");\n+\t  /* Operating on a non qualified qualified WFL.  */\n+\t  abort ();\n+\n \tTREE_CHAIN (previous) = NULL_TREE;\n \treturn TREE_PURPOSE (q);\n       }\n@@ -9580,7 +9580,7 @@ check_deprecation (wfl, decl)\n \t  strcpy (the, \"class\");\n \t  break;\n \tdefault:\n-\t  fatal (\"unexpected DECL code - check_deprecation\");\n+\t  abort ();\n \t}\n       parse_warning_context \n \t(wfl, \"The %s `%s' in class `%s' has been deprecated\", \n@@ -10181,7 +10181,7 @@ patch_invoke (patch, method, args)\n \t  break;\n \n \tdefault:\n-\t  fatal (\"internal error - unknown invocation_mode result\");\n+\t  abort ();\n \t}\n \n       /* Ensure self_type is initialized, (invokestatic). FIXME */\n@@ -10426,7 +10426,7 @@ find_applicable_accessible_methods_list (lc, class, name, arglist)\n \t{\n \t  lc = 1;\n \t  if (!list)\n-\t    fatal (\"finit$ not found in class -- find_applicable_accessible_methods_list\");\n+\t    abort ();\n \t}\n \n       /* We must search all interfaces of this class */\n@@ -11644,7 +11644,7 @@ java_complete_lhs (node)\n \t  return field;\n \t}\n       else\n-\tfatal (\"unimplemented java_complete_tree for COMPONENT_REF\");\n+\tabort ();\n       break;\n \n     case THIS_EXPR:\n@@ -11691,8 +11691,7 @@ java_complete_lhs (node)\n       if ((nn = patch_string (node)))\n \tnode = nn;\n       else\n-\tfatal (\"No case for tree code `%s' - java_complete_tree\\n\",\n-\t       tree_code_name [TREE_CODE (node)]);\n+\tinternal_error (\"No case for %s\", tree_code_name [TREE_CODE (node)]);\n     }\n   return node;\n }\n@@ -11841,7 +11840,7 @@ lookup_name_in_blocks (name)\n \n       /* Paranoid sanity check. To be removed */\n       if (TREE_CODE (b) != BLOCK)\n-\tfatal (\"non block expr function body - lookup_name_in_blocks\");\n+\tabort ();\n \n       for (current = BLOCK_EXPR_DECLS (b); current; \n \t   current = TREE_CHAIN (current))\n@@ -12136,7 +12135,7 @@ check_final_variable_indirect_assignment (stmt)\n \tif (TREE_CODE (decl) != FUNCTION_DECL)\n \t  decl = TREE_OPERAND (TREE_OPERAND (decl, 0), 0);\n \tif (TREE_CODE (decl) != FUNCTION_DECL)\n-\t  fatal (\"Can't find FUNCTION_DECL in CALL_EXPR - check_final_variable_indirect_assignment\");\n+\t  abort ();\n \tif (DECL_FUNCTION_ALL_FINAL_INITIALIZED (decl))\n \t  return 1;\n \tif (DECL_FINIT_P (decl) || DECL_CONTEXT (decl) != current_class)\n@@ -12861,8 +12860,8 @@ operator_string (node)\n     case PREDECREMENT_EXPR:\t/* Fall through */\n     case POSTDECREMENT_EXPR: BUILD_OPERATOR_STRING (\"--\");\n     default:\n-      fatal (\"unregistered operator %s - operator_string\",\n-\t     tree_code_name [TREE_CODE (node)]);\n+      internal_error (\"unregistered operator %s\",\n+\t\t      tree_code_name [TREE_CODE (node)]);\n     }\n   return NULL;\n #undef BUILD_OPERATOR_STRING\n@@ -13561,8 +13560,7 @@ build_unaryop (op_token, op_location, op1)\n     case MINUS_TK: op = NEGATE_EXPR; break;\n     case NEG_TK: op = TRUTH_NOT_EXPR; break;\n     case NOT_TK: op = BIT_NOT_EXPR; break;\n-    default: fatal (\"Unknown token `%d' for unary operator - build_unaryop\",\n-\t\t    op_token);\n+    default: abort ();\n     }\n \n   unaryop = build1 (op, NULL_TREE, op1);"}, {"sha": "e20903da58e51ff3fb6293bc71abbe2f4279c37e", "filename": "gcc/java/typeck.c", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/400500c4a50104969a303ba3c41983b134523e15/gcc%2Fjava%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/400500c4a50104969a303ba3c41983b134523e15/gcc%2Fjava%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Ftypeck.c?ref=400500c4a50104969a303ba3c41983b134523e15", "patch": "@@ -1,5 +1,6 @@\n /* Handle types for the GNU compiler for the Java(TM) language.\n-   Copyright (C) 1996, 1997, 1998, 1999, 2000 Free Software Foundation, Inc.\n+   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001\n+   Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -52,8 +53,10 @@ set_local_type (slot, type)\n {\n   int max_locals = DECL_MAX_LOCALS(current_function_decl);\n   int nslots = TYPE_IS_WIDE (type) ? 2 : 1;\n+\n   if (slot < 0 || slot + nslots - 1 >= max_locals)\n-    fatal (\"invalid local variable index\");\n+    abort ();\n+\n   type_map[slot] = type;\n   while (--nslots > 0)\n     type_map[++slot] = void_type_node;\n@@ -498,9 +501,11 @@ parse_signature_type (ptr, limit)\n      const unsigned char **ptr, *limit;\n {\n   tree type;\n-  if ((*ptr) >= limit)\n-    fatal (\"bad signature string\");\n-  switch (*(*ptr))\n+\n+  if (*ptr >= limit)\n+    abort ();\n+\n+  switch (**ptr)\n     {\n     case 'B':  (*ptr)++;  return byte_type_node;\n     case 'C':  (*ptr)++;  return char_type_node;\n@@ -523,7 +528,7 @@ parse_signature_type (ptr, limit)\n \tfor ( ; ; str++)\n \t  {\n \t    if (str >= limit)\n-\t      fatal (\"bad signature string\");\n+\t      abort ();\n \t    if (*str == ';')\n \t      break;\n \t  }\n@@ -532,7 +537,7 @@ parse_signature_type (ptr, limit)\n \tbreak;\n       }\n     default:\n-      fatal (\"unrecognized signature string\");\n+      abort ();\n     }\n   return promote_type (type);\n }\n@@ -560,7 +565,7 @@ parse_signature_string (sig_string, sig_length)\n \t  argtype_list = tree_cons (NULL_TREE, argtype, argtype_list);\n \t}\n       if (str++, str >= limit)\n-\tfatal (\"bad signature string\");\n+\tabort ();\n       result_type = parse_signature_type (&str, limit);\n       argtype_list = chainon (nreverse (argtype_list), end_params_node);\n       result_type = build_function_type (result_type, argtype_list);\n@@ -696,7 +701,7 @@ build_java_signature (type)\n \t  break;\n \tbad_type:\n \tdefault:\n-\t  fatal (\"internal error - build_java_signature passed invalid type\");\n+\t  abort ();\n \t}\n       TYPE_SIGNATURE (type) = sig;\n     }\n@@ -716,7 +721,7 @@ set_java_signature (type, sig)\n   MAYBE_CREATE_TYPE_TYPE_LANG_SPECIFIC (type);\n   old_sig = TYPE_SIGNATURE (type);\n   if (old_sig != NULL_TREE && old_sig != sig)\n-    fatal (\"internal error - set_java_signature\");\n+    abort ();\n   TYPE_SIGNATURE (type) = sig;\n #if 0 /* careful about METHOD_TYPE */\n   if (IDENTIFIER_SIGNATURE_TYPE (sig) == NULL_TREE && TREE_PERMANENT (type))"}, {"sha": "5ac1d057e5c4281ffb05313805427bd25fbfd1eb", "filename": "gcc/java/verify.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/400500c4a50104969a303ba3c41983b134523e15/gcc%2Fjava%2Fverify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/400500c4a50104969a303ba3c41983b134523e15/gcc%2Fjava%2Fverify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fverify.c?ref=400500c4a50104969a303ba3c41983b134523e15", "patch": "@@ -1,6 +1,6 @@\n /* Handle verification of bytecoded methods for the GNU compiler for \n    the Java(TM) language.\n-   Copyright (C) 1997, 1998, 1999, 2000 Free Software Foundation, Inc.\n+   Copyright (C) 1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -304,9 +304,10 @@ type_stack_dup (size, offset)\n \t  index++;\n \t  type[index] = stack_type_map[stack_pointer - 2];\n \t  if (! TYPE_IS_WIDE (type[index]))\n-\t    fatal (\"internal error - dup operation\");\n+\t    abort ();\n \t  if (index == size || index == size + offset)\n-\t    fatal (\"dup operation splits 64-bit number\");\n+\t    /* Dup operation splits 64-bit number.  */\n+\t    abort ();\n \t}\n       pop_type (type[index]);\n     }\n@@ -393,8 +394,7 @@ pop_argument_types (arg_types)\n #ifdef __GNUC__\n #define CHECK_PC_IN_RANGE(PC) ({if (PC < 0 || PC > length) goto bad_pc; (void)1;})\n #else\n-#define CHECK_PC_IN_RANGE(PC) (PC < 0 || PC > length ? \\\n-  (fatal(\"Bad byte codes.\\n\"), 0) : 1)\n+#define CHECK_PC_IN_RANGE(PC) (PC < 0 || PC > length ? (abort (), 0) : 1)\n #endif\n \n #define BCODE byte_ops"}, {"sha": "9856f34e5ca84e438865548381e7d356acc66b50", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/400500c4a50104969a303ba3c41983b134523e15/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/400500c4a50104969a303ba3c41983b134523e15/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=400500c4a50104969a303ba3c41983b134523e15", "patch": "@@ -1,6 +1,6 @@\n /* Implement classes and message passing for Objective C.\n-   Copyright (C) 1992, 1993, 1994, 1995, 1997, 1998,\n-   1999, 2000, 2001 Free Software Foundation, Inc.\n+   Copyright (C) 1992, 1993, 1994, 1995, 1997, 1998, 1999, 2000, 2001\n+   Free Software Foundation, Inc.\n    Contributed by Steve Naroff.\n \n This file is part of GNU CC.\n@@ -730,7 +730,7 @@ objc_init ()\n       register char * const dumpname = concat (dumpname, \".decl\", NULL);\n       gen_declaration_file = fopen (dumpname, \"w\");\n       if (gen_declaration_file == 0)\n-\tpfatal_with_name (dumpname);\n+\tfatal_io_error (\"can't open %s\", dumpname);\n       free (dumpname);\n     }\n \n@@ -1088,10 +1088,7 @@ objc_check_decl (decl)\n   if (TREE_CODE (type) == RECORD_TYPE\n       && TREE_STATIC_TEMPLATE (type)\n       && type != constant_string_type)\n-    {\n-      error_with_decl (decl, \"`%s' cannot be statically allocated\");\n-      fatal (\"statically allocated objects not supported\");\n-    }\n+    error_with_decl (decl, \"`%s' cannot be statically allocated\");\n }\n \n void\n@@ -1151,7 +1148,10 @@ get_object_reference (protocols)\n \t\tgen_declaration (type, errbuf));\n     }\n   else\n-    fatal (\"Undefined type `id', please import <objc/objc.h>\");\n+    {\n+      error (\"Undefined type `id', please import <objc/objc.h>\");\n+      return error_mark_node;\n+    }\n \n   /* This clause creates a new pointer type that is qualified with\n      the protocol specification...this info is used later to do more\n@@ -2585,10 +2585,8 @@ build_ivar_chain (interface, copy)\n         }\n \n       if (super_interface == interface)\n-        {\n-          fatal (\"Circular inheritance in interface declaration for `%s'\",\n-                 IDENTIFIER_POINTER (super_name));\n-        }\n+\tfatal_error (\"Circular inheritance in interface declaration for `%s'\",\n+\t\t     IDENTIFIER_POINTER (super_name));\n \n       interface = super_interface;\n       my_name = CLASS_NAME (interface);"}, {"sha": "3cdd34b130aced72696bbba716768502fc9792c2", "filename": "gcc/profile.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/400500c4a50104969a303ba3c41983b134523e15/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/400500c4a50104969a303ba3c41983b134523e15/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=400500c4a50104969a303ba3c41983b134523e15", "patch": "@@ -904,15 +904,15 @@ init_branch_prob (filename)\n       strip_off_ending (data_file, len);\n       strcat (data_file, \".bb\");\n       if ((bb_file = fopen (data_file, \"wb\")) == 0)\n-\tpfatal_with_name (data_file);\n+\tfatal_io_error (\"can't open %s\", data_file);\n \n       /* Open an output file for the program flow graph.  */\n       bbg_file_name = (char *) alloca (len + 5);\n       strcpy (bbg_file_name, filename);\n       strip_off_ending (bbg_file_name, len);\n       strcat (bbg_file_name, \".bbg\");\n       if ((bbg_file = fopen (bbg_file_name, \"wb\")) == 0)\n-\tpfatal_with_name (bbg_file_name);\n+\tfatal_io_error (\"can't open %s\", bbg_file_name);\n \n       /* Initialize to zero, to ensure that the first file name will be\n \t written to the .bb file.  */"}, {"sha": "26cc52d53d1d99ab7b52b8dce3911f06a7a46877", "filename": "gcc/toplev.c", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/400500c4a50104969a303ba3c41983b134523e15/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/400500c4a50104969a303ba3c41983b134523e15/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=400500c4a50104969a303ba3c41983b134523e15", "patch": "@@ -1699,10 +1699,9 @@ pop_float_handler (handled, handler)\n \n static void\n crash_signal (signo)\n-     /* If this is missing, some compilers complain.  */\n      int signo;\n {\n-  fatal (\"Internal error: %s.\", strsignal (signo));\n+  internal_error (\"Internal error: %s\", strsignal (signo));\n }\n \n /* Strip off a legitimate source ending from the input string NAME of\n@@ -1851,7 +1850,7 @@ open_dump_file (index, decl)\n \n   rtl_dump_file = fopen (dump_name, open_arg);\n   if (rtl_dump_file == NULL)\n-    pfatal_with_name (dump_name);\n+    fatal_io_error (\"can't open %s\", dump_name);\n \n   free (dump_name);\n \n@@ -2209,7 +2208,7 @@ compile_file (name)\n     {\n       aux_info_file = fopen (aux_info_file_name, \"w\");\n       if (aux_info_file == 0)\n-\tpfatal_with_name (aux_info_file_name);\n+\tfatal_io_error (\"can't open %s\", aux_info_file_name);\n     }\n \n   /* Open assembler code output file.  Do this even if -fsyntax-only is on,\n@@ -2234,7 +2233,7 @@ compile_file (name)\n       else\n         asm_out_file = fopen (asm_file_name, \"w\");\n       if (asm_out_file == 0)\n-        pfatal_with_name (asm_file_name);\n+\tfatal_io_error (\"can't open %s for writing\", asm_file_name);\n     }\n \n #ifdef IO_BUFFER_SIZE\n@@ -2511,8 +2510,10 @@ compile_file (name)\n \n   finish_parse ();\n \n-  if (ferror (asm_out_file) != 0 || fclose (asm_out_file) != 0)\n-    fatal_io_error (asm_file_name);\n+  if (ferror (asm_out_file) != 0)\n+    fatal_io_error (\"error writing to %s\", asm_file_name);\n+  if (fclose (asm_out_file) != 0)\n+    fatal_io_error (\"error closing %s\", asm_file_name);\n \n   /* Do whatever is necessary to finish printing the graphs.  */\n   if (graph_dump_format != no_graph)"}, {"sha": "093c8f85366483e051d4a71acbdd820ba45fd95b", "filename": "gcc/toplev.h", "status": "modified", "additions": 29, "deletions": 26, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/400500c4a50104969a303ba3c41983b134523e15/gcc%2Ftoplev.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/400500c4a50104969a303ba3c41983b134523e15/gcc%2Ftoplev.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.h?ref=400500c4a50104969a303ba3c41983b134523e15", "patch": "@@ -1,5 +1,5 @@\n /* toplev.h - Various declarations for functions found in toplev.c\n-   Copyright (C) 1998, 1999, 2000 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -42,44 +42,46 @@ extern void debug_end_source_file\tPARAMS ((unsigned));\n extern void debug_define\t\tPARAMS ((unsigned, const char *));\n extern void debug_undef\t\t\tPARAMS ((unsigned, const char *));\n extern int debug_ignore_block\t\tPARAMS ((union tree_node *));\n-extern void fatal\t\t\tPARAMS ((const char *, ...))\n-  ATTRIBUTE_PRINTF_1 ATTRIBUTE_NORETURN;\n-extern void fatal_io_error\t\tPARAMS ((const char *))\n-  ATTRIBUTE_NORETURN;\n-extern void pfatal_with_name\t\tPARAMS ((const char *))\n-  ATTRIBUTE_NORETURN;\n+extern void internal_error\t\tPARAMS ((const char *, ...))\n+\t\t\t\t\t       ATTRIBUTE_PRINTF_1\n+\t\t\t\t\t       ATTRIBUTE_NORETURN;\n+extern void fatal_io_error\t\tPARAMS ((const char *, ...))\n+\t\t\t\t\t       ATTRIBUTE_PRINTF_1\n+\t\t\t\t\t       ATTRIBUTE_NORETURN;\n extern void _fatal_insn_not_found\tPARAMS ((struct rtx_def *,\n \t\t\t\t\t\tconst char *, int,\n \t\t\t\t\t\tconst char *))\n-  ATTRIBUTE_NORETURN;\n+\t\t\t\t\t       ATTRIBUTE_NORETURN;\n extern void _fatal_insn\t\t\tPARAMS ((const char *,\n \t\t\t\t\t\tstruct rtx_def *,\n \t\t\t\t\t\tconst char *, int,\n \t\t\t\t\t\tconst char *))\n-  ATTRIBUTE_NORETURN;\n+\t\t\t\t\t      ATTRIBUTE_NORETURN;\n \n #define fatal_insn(msgid, insn) \\\n \t_fatal_insn (msgid, insn, __FILE__, __LINE__, __FUNCTION__)\n #define fatal_insn_not_found(insn) \\\n \t_fatal_insn_not_found (insn, __FILE__, __LINE__, __FUNCTION__)\n \n extern void warning\t\t\tPARAMS ((const char *, ...))\n-\t\t\t\t\t\tATTRIBUTE_PRINTF_1;\n+\t\t\t\t\t       ATTRIBUTE_PRINTF_1;\n extern void error\t\t\tPARAMS ((const char *, ...))\n-\t\t\t\t\t\tATTRIBUTE_PRINTF_1;\n+\t\t\t\t\t       ATTRIBUTE_PRINTF_1;\n+extern void fatal_error\t\t\tPARAMS ((const char *, ...))\n+\t\t\t\t\t       ATTRIBUTE_PRINTF_1;\n extern void pedwarn\t\t\tPARAMS ((const char *, ...))\n-\t\t\t\t\t\tATTRIBUTE_PRINTF_1;\n+\t\t\t\t\t       ATTRIBUTE_PRINTF_1;\n extern void pedwarn_with_file_and_line\tPARAMS ((const char *, int,\n-\t\t\t\t\t\t  const char *, ...))\n-  ATTRIBUTE_PRINTF_3;\n+\t\t\t\t\t\t const char *, ...))\n+\t\t\t\t\t       ATTRIBUTE_PRINTF_3;\n extern void warning_with_file_and_line\tPARAMS ((const char *, int,\n-\t\t\t\t\t\t  const char *, ...))\n-  ATTRIBUTE_PRINTF_3;\n+\t\t\t\t\t\t const char *, ...))\n+\t\t\t\t\t       ATTRIBUTE_PRINTF_3;\n extern void error_with_file_and_line\tPARAMS ((const char *, int,\n-\t\t\t\t\t\t  const char *, ...))\n-  ATTRIBUTE_PRINTF_3;\n+\t\t\t\t\t\t const char *, ...))\n+\t\t\t\t\t       ATTRIBUTE_PRINTF_3;\n extern void sorry\t\t\tPARAMS ((const char *, ...))\n-  ATTRIBUTE_PRINTF_1;\n+\t\t\t\t\t       ATTRIBUTE_PRINTF_1;\n extern void default_print_error_function PARAMS ((const char *));\n extern void report_error_function\tPARAMS ((const char *));\n \n@@ -90,20 +92,20 @@ extern void rest_of_compilation\t\tPARAMS ((union tree_node *));\n \n /* The *_with_decl functions aren't suitable for ATTRIBUTE_PRINTF. */\n extern void pedwarn_with_decl\t\tPARAMS ((union tree_node *,\n-\t\t\t\t\t\t  const char *, ...));\n+\t\t\t\t\t\t const char *, ...));\n extern void warning_with_decl\t\tPARAMS ((union tree_node *,\n-\t\t\t\t\t\t  const char *, ...));\n+\t\t\t\t\t\t const char *, ...));\n extern void error_with_decl\t\tPARAMS ((union tree_node *,\n-\t\t\t\t\t\t  const char *, ...));\n+\t\t\t\t\t\t const char *, ...));\n \n extern void announce_function\t\tPARAMS ((union tree_node *));\n \n extern void error_for_asm\t\tPARAMS ((struct rtx_def *,\n \t\t\t\t\t\t const char *, ...))\n-  ATTRIBUTE_PRINTF_2;\n+\t\t\t\t\t       ATTRIBUTE_PRINTF_2;\n extern void warning_for_asm\t\tPARAMS ((struct rtx_def *,\n \t\t\t\t\t\t const char *, ...))\n-  ATTRIBUTE_PRINTF_2;\n+\t\t\t\t\t       ATTRIBUTE_PRINTF_2;\n #if defined (_JBLEN) || defined (setjmp)\n extern void set_float_handler PARAMS ((jmp_buf));\n extern int push_float_handler PARAMS ((jmp_buf, jmp_buf));\n@@ -121,12 +123,13 @@ extern void botch\t\t\tPARAMS ((const char *))\n \n #ifdef BUFSIZ\n extern void fnotice\t\t\tPARAMS ((FILE *, const char *, ...))\n-  ATTRIBUTE_PRINTF_2;\n+\t\t\t\t\t       ATTRIBUTE_PRINTF_2;\n #endif\n \n extern int wrapup_global_declarations   PARAMS ((union tree_node **, int));\n extern void check_global_declarations   PARAMS ((union tree_node **, int));\n-extern void note_deferral_of_defined_inline_function PARAMS ((union tree_node *));\n+extern void note_deferral_of_defined_inline_function\n+\t\t\t\t\tPARAMS ((union tree_node *));\n extern int errorcount;\n extern int warningcount;\n extern int sorrycount;"}]}