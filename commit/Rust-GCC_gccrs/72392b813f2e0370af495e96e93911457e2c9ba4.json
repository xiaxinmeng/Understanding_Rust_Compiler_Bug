{"sha": "72392b813f2e0370af495e96e93911457e2c9ba4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzIzOTJiODEzZjJlMDM3MGFmNDk1ZTk2ZTkzOTExNDU3ZTJjOWJhNA==", "commit": {"author": {"name": "Joern Rennecke", "email": "amylaar@spamcop.net", "date": "2010-01-18T02:47:16Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "2010-01-18T02:47:16Z"}, "message": "tm.texi (TARGET_ASM_FUNCTION_EPILOGUE): Update text on where to find number of popped argument bytes.\n\n\t* doc/tm.texi (TARGET_ASM_FUNCTION_EPILOGUE): Update text on where to\n\tfind number of popped argument bytes.\n\n\t(TARGET_INVALID_WITHIN_DOLOOP): Put return value in braces.\n\tFix the text that describes the return value for invalid insns.\n\n\t(TARGET_SCHED_NEEDS_BLOCK_P): Fix return type.  Fix argument list.\n\n\t(TARGET_SCHED_IS_COSTLY_DEPENDENCE): Fix argument types.\n\tClarify what 'cost of the -dependence' is.  Fix quoting.\n\nFrom-SVN: r155999", "tree": {"sha": "6d62d9629abf21289dda111f30d12111bbfe56c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6d62d9629abf21289dda111f30d12111bbfe56c1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/72392b813f2e0370af495e96e93911457e2c9ba4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72392b813f2e0370af495e96e93911457e2c9ba4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/72392b813f2e0370af495e96e93911457e2c9ba4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72392b813f2e0370af495e96e93911457e2c9ba4/comments", "author": null, "committer": null, "parents": [{"sha": "de65371499d71e60ddcfe4c5e202dcbec1a8976f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de65371499d71e60ddcfe4c5e202dcbec1a8976f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/de65371499d71e60ddcfe4c5e202dcbec1a8976f"}], "stats": {"total": 38, "additions": 25, "deletions": 13}, "files": [{"sha": "a518cfd88cff1ea2ebe2280f252d5f9cb6f86f87", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72392b813f2e0370af495e96e93911457e2c9ba4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72392b813f2e0370af495e96e93911457e2c9ba4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=72392b813f2e0370af495e96e93911457e2c9ba4", "patch": "@@ -1,3 +1,16 @@\n+2010-01-18  Joern Rennecke  <amylaar@spamcop.net>\n+\n+\t* doc/tm.texi (TARGET_ASM_FUNCTION_EPILOGUE): Update text on where to\n+\tfind number of popped argument bytes.\n+\n+\t(TARGET_INVALID_WITHIN_DOLOOP): Put return value in braces.\n+\tFix the text that describes the return value for invalid insns.\n+\n+\t(TARGET_SCHED_NEEDS_BLOCK_P): Fix return type.  Fix argument list.\n+\n+\t(TARGET_SCHED_IS_COSTLY_DEPENDENCE): Fix argument types.\n+\tClarify what 'cost of the -dependence' is.  Fix quoting.\n+\n 2010-01-17  Jakub Jelinek  <jakub@redhat.com>\n \n \t* dwarf2out.c (mem_loc_descriptor): Don't ICE on"}, {"sha": "f355e1cb2b5196c96e70eb3ae614f5bf937228d4", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72392b813f2e0370af495e96e93911457e2c9ba4/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72392b813f2e0370af495e96e93911457e2c9ba4/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=72392b813f2e0370af495e96e93911457e2c9ba4", "patch": "@@ -4698,11 +4698,9 @@ number of arguments.\n @findex current_function_pops_args\n Your definition of the macro @code{RETURN_POPS_ARGS} decides which\n functions pop their own arguments.  @code{TARGET_ASM_FUNCTION_EPILOGUE}\n-needs to know what was decided.  The variable that is called\n-@code{current_function_pops_args} is the number of bytes of its\n-arguments that a function should pop.  @xref{Scalar Return}.\n-@c what is the \"its arguments\" in the above sentence referring to, pray\n-@c tell?  --mew 5feb93\n+needs to know what was decided.  The number of bytes of the current\n+function's arguments that this function should pop is available in\n+@code{crtl->args.pops_args}.  @xref{Scalar Return}.\n @end deftypefn\n \n @itemize @bullet\n@@ -6567,13 +6565,13 @@ correspondingly processor cycle on which the previous insn has been\n issued and the current processor cycle.\n @end deftypefn\n \n-@deftypefn {Target Hook} bool TARGET_SCHED_IS_COSTLY_DEPENDENCE (struct dep_def *@var{_dep}, int @var{cost}, int @var{distance})\n+@deftypefn {Target Hook} bool TARGET_SCHED_IS_COSTLY_DEPENDENCE (struct _dep *@var{_dep}, int @var{cost}, int @var{distance})\n This hook is used to define which dependences are considered costly by\n the target, so costly that it is not advisable to schedule the insns that\n are involved in the dependence too close to one another.  The parameters\n to this hook are as follows:  The first parameter @var{_dep} is the dependence\n being evaluated.  The second parameter @var{cost} is the cost of the\n-dependence, and the third\n+dependence as estimated by the scheduler, and the third\n parameter @var{distance} is the distance in cycles between the two insns.\n The hook returns @code{true} if considering the distance between the two\n insns the dependence between them is considered costly by the target,\n@@ -6585,7 +6583,7 @@ delays, however: (b) there's a better chance to predict the actual grouping\n that will be formed, and (c) correctly emulating the grouping can be very\n important.  In such targets one may want to allow issuing dependent insns\n closer to one another---i.e., closer than the dependence distance;  however,\n-not in cases of \"costly dependences\", which this hooks allows to define.\n+not in cases of ``costly dependences'', which this hooks allows to define.\n @end deftypefn\n \n @deftypefn {Target Hook} void TARGET_SCHED_H_I_D_EXTENDED (void)\n@@ -6628,10 +6626,10 @@ speculation.  If the return value equals 1 then @var{new_pat} is assigned\n the generated speculative pattern.\n @end deftypefn\n \n-@deftypefn {Target Hook} int TARGET_SCHED_NEEDS_BLOCK_P (rtx @var{insn})\n+@deftypefn {Target Hook} bool TARGET_SCHED_NEEDS_BLOCK_P (int @var{dep_status})\n This hook is called by the insn scheduler during generation of recovery code\n-for @var{insn}.  It should return nonzero, if the corresponding check\n-instruction should branch to recovery code, or zero otherwise.\n+for @var{insn}.  It should return @code{true}, if the corresponding check\n+instruction should branch to recovery code, or @code{false} otherwise.\n @end deftypefn\n \n @deftypefn {Target Hook} rtx TARGET_SCHED_GEN_SPEC_CHECK (rtx @var{insn}, rtx @var{label}, int @var{mutate_p})\n@@ -10679,10 +10677,11 @@ simplified expression for the call's result.  If @var{ignore} is true\n the value will be ignored.\n @end deftypefn\n \n-@deftypefn {Target Hook} const char * TARGET_INVALID_WITHIN_DOLOOP (rtx @var{insn})\n+@deftypefn {Target Hook} {const char *} TARGET_INVALID_WITHIN_DOLOOP (const_rtx @var{insn})\n \n Take an instruction in @var{insn} and return NULL if it is valid within a\n-low-overhead loop, otherwise return a string why doloop could not be applied.\n+low-overhead loop, otherwise return a string explaining why doloop\n+could not be applied.\n \n Many targets use special registers for low-overhead looping. For any\n instruction that clobbers these this function should return a string indicating"}]}