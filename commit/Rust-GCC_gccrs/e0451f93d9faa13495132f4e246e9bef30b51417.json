{"sha": "e0451f93d9faa13495132f4e246e9bef30b51417", "node_id": "C_kwDOANBUbNoAKGUwNDUxZjkzZDlmYWExMzQ5NTEzMmY0ZTI0NmU5YmVmMzBiNTE0MTc", "commit": {"author": {"name": "Tom de Vries", "email": "tdevries@suse.de", "date": "2022-01-21T20:46:05Z"}, "committer": {"name": "Tom de Vries", "email": "tdevries@suse.de", "date": "2022-02-01T18:28:24Z"}, "message": "[nvptx] Add some support for .local atomics\n\nThe ptx insn atom doesn't support local memory.  In case of doing an atomic\noperation on local memory, we run into:\n...\noperation not supported on global/shared address space\n...\nThis is the cuGetErrorString message for CUDA_ERROR_INVALID_ADDRESS_SPACE.\n\nThe message is somewhat confusing given that actually the operation is not\nsupported on local address space.\n\nFix this by falling back on a non-atomic version when detecting\na frame-related memory operand.\n\nThis only solves some cases that are detected at compile-time.  It does\nhowever fix the openacc private-atomic-* test-cases.\n\nTested on x86_64 with nvptx accelerator.\n\ngcc/ChangeLog:\n\n2022-01-27  Tom de Vries  <tdevries@suse.de>\n\n\t* config/nvptx/nvptx.md (define_insn \"atomic_compare_and_swap<mode>_1\")\n\t(define_insn \"atomic_exchange<mode>\")\n\t(define_insn \"atomic_fetch_add<mode>\")\n\t(define_insn \"atomic_fetch_addsf\")\n\t(define_insn \"atomic_fetch_<logic><mode>\"): Output non-atomic version\n\tif memory operands is frame-relative.\n\ngcc/testsuite/ChangeLog:\n\n2022-01-31  Tom de Vries  <tdevries@suse.de>\n\n\t* gcc.target/nvptx/stack-atomics-run.c: New test.\n\nlibgomp/ChangeLog:\n\n2022-01-27  Tom de Vries  <tdevries@suse.de>\n\n\t* testsuite/libgomp.oacc-c-c++-common/private-atomic-1.c: Remove\n\tPR83812 workaround.\n\t* testsuite/libgomp.oacc-fortran/private-atomic-1-vector.f90: Same.\n\t* testsuite/libgomp.oacc-fortran/private-atomic-1-worker.f90: Same.", "tree": {"sha": "22d002b52a5921f93d4d4e48c82280c3094f1216", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/22d002b52a5921f93d4d4e48c82280c3094f1216"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e0451f93d9faa13495132f4e246e9bef30b51417", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0451f93d9faa13495132f4e246e9bef30b51417", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e0451f93d9faa13495132f4e246e9bef30b51417", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0451f93d9faa13495132f4e246e9bef30b51417/comments", "author": {"login": "vries", "id": 4057235, "node_id": "MDQ6VXNlcjQwNTcyMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4057235?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vries", "html_url": "https://github.com/vries", "followers_url": "https://api.github.com/users/vries/followers", "following_url": "https://api.github.com/users/vries/following{/other_user}", "gists_url": "https://api.github.com/users/vries/gists{/gist_id}", "starred_url": "https://api.github.com/users/vries/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vries/subscriptions", "organizations_url": "https://api.github.com/users/vries/orgs", "repos_url": "https://api.github.com/users/vries/repos", "events_url": "https://api.github.com/users/vries/events{/privacy}", "received_events_url": "https://api.github.com/users/vries/received_events", "type": "User", "site_admin": false}, "committer": {"login": "vries", "id": 4057235, "node_id": "MDQ6VXNlcjQwNTcyMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4057235?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vries", "html_url": "https://github.com/vries", "followers_url": "https://api.github.com/users/vries/followers", "following_url": "https://api.github.com/users/vries/following{/other_user}", "gists_url": "https://api.github.com/users/vries/gists{/gist_id}", "starred_url": "https://api.github.com/users/vries/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vries/subscriptions", "organizations_url": "https://api.github.com/users/vries/orgs", "repos_url": "https://api.github.com/users/vries/repos", "events_url": "https://api.github.com/users/vries/events{/privacy}", "received_events_url": "https://api.github.com/users/vries/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ca902055d056773bd0ca80f68bca4b20ad0e183f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca902055d056773bd0ca80f68bca4b20ad0e183f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca902055d056773bd0ca80f68bca4b20ad0e183f"}], "stats": {"total": 147, "additions": 124, "deletions": 23}, "files": [{"sha": "9cbbd956f9d5236796e25edf16b0f6ef0840eed3", "filename": "gcc/config/nvptx/nvptx.md", "status": "modified", "additions": 80, "deletions": 2, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0451f93d9faa13495132f4e246e9bef30b51417/gcc%2Fconfig%2Fnvptx%2Fnvptx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0451f93d9faa13495132f4e246e9bef30b51417/gcc%2Fconfig%2Fnvptx%2Fnvptx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnvptx%2Fnvptx.md?ref=e0451f93d9faa13495132f4e246e9bef30b51417", "patch": "@@ -1790,11 +1790,28 @@\n \t(unspec_volatile:SDIM [(const_int 0)] UNSPECV_CAS))]\n   \"\"\n   {\n+    struct address_info info;\n+    decompose_mem_address (&info, operands[1]);\n+    if (info.base != NULL && REG_P (*info.base)\n+\t&& REGNO_PTR_FRAME_P (REGNO (*info.base)))\n+      {\n+\toutput_asm_insn (\"{\", NULL);\n+\toutput_asm_insn (\"\\\\t\"\t      \".reg.pred\"  \"\\\\t\" \"%%eq_p;\", NULL);\n+\toutput_asm_insn (\"\\\\t\"\t      \".reg%t0\"\t   \"\\\\t\" \"%%val;\", operands);\n+\toutput_asm_insn (\"\\\\t\"\t      \"ld%A1%t0\"   \"\\\\t\" \"%%val,%1;\", operands);\n+\toutput_asm_insn (\"\\\\t\"\t      \"setp.eq%t0\" \"\\\\t\" \"%%eq_p, %%val, %2;\",\n+\t\t\t operands);\n+\toutput_asm_insn (\"@%%eq_p\\\\t\" \"st%A1%t0\"   \"\\\\t\" \"%1,%3;\", operands);\n+\toutput_asm_insn (\"\\\\t\"\t      \"mov%t0\"\t   \"\\\\t\" \"%0,%%val;\", operands);\n+\toutput_asm_insn (\"}\", NULL);\n+\treturn \"\";\n+      }\n     const char *t\n-      = \"%.\\\\tatom%A1.cas.b%T0\\\\t%0, %1, %2, %3;\";\n+      = \"\\\\tatom%A1.cas.b%T0\\\\t%0, %1, %2, %3;\";\n     return nvptx_output_atomic_insn (t, operands, 1, 4);\n   }\n-  [(set_attr \"atomic\" \"true\")])\n+  [(set_attr \"atomic\" \"true\")\n+   (set_attr \"predicable\" \"false\")])\n \n (define_insn \"atomic_exchange<mode>\"\n   [(set (match_operand:SDIM 0 \"nvptx_register_operand\" \"=R\")\t;; output\n@@ -1806,6 +1823,19 @@\n \t(match_operand:SDIM 2 \"nvptx_nonmemory_operand\" \"Ri\"))]\t;; input\n   \"\"\n   {\n+    struct address_info info;\n+    decompose_mem_address (&info, operands[1]);\n+    if (info.base != NULL && REG_P (*info.base)\n+\t&& REGNO_PTR_FRAME_P (REGNO (*info.base)))\n+      {\n+\toutput_asm_insn (\"{\", NULL);\n+\toutput_asm_insn (\"\\\\t\"\t \".reg%t0\"  \"\\\\t\" \"%%val;\", operands);\n+\toutput_asm_insn (\"%.\\\\t\" \"ld%A1%t0\" \"\\\\t\" \"%%val,%1;\", operands);\n+\toutput_asm_insn (\"%.\\\\t\" \"st%A1%t0\" \"\\\\t\" \"%1,%2;\", operands);\n+\toutput_asm_insn (\"%.\\\\t\" \"mov%t0\"   \"\\\\t\" \"%0,%%val;\", operands);\n+\toutput_asm_insn (\"}\", NULL);\n+\treturn \"\";\n+      }\n     const char *t\n       = \"%.\\tatom%A1.exch.b%T0\\t%0, %1, %2;\";\n     return nvptx_output_atomic_insn (t, operands, 1, 3);\n@@ -1823,6 +1853,22 @@\n \t(match_dup 1))]\n   \"\"\n   {\n+    struct address_info info;\n+    decompose_mem_address (&info, operands[1]);\n+    if (info.base != NULL && REG_P (*info.base)\n+\t&& REGNO_PTR_FRAME_P (REGNO (*info.base)))\n+      {\n+\toutput_asm_insn (\"{\", NULL);\n+\toutput_asm_insn (\"\\\\t\"\t \".reg%t0\"  \"\\\\t\" \"%%val;\", operands);\n+\toutput_asm_insn (\"\\\\t\"\t \".reg%t0\"  \"\\\\t\" \"%%update;\", operands);\n+\toutput_asm_insn (\"%.\\\\t\" \"ld%A1%t0\" \"\\\\t\" \"%%val,%1;\", operands);\n+\toutput_asm_insn (\"%.\\\\t\" \"add%t0\"   \"\\\\t\" \"%%update,%%val,%2;\",\n+\t\t\t operands);\n+\toutput_asm_insn (\"%.\\\\t\" \"st%A1%t0\" \"\\\\t\" \"%1,%%update;\", operands);\n+\toutput_asm_insn (\"%.\\\\t\" \"mov%t0\"   \"\\\\t\" \"%0,%%val;\", operands);\n+\toutput_asm_insn (\"}\", NULL);\n+\treturn \"\";\n+      }\n     const char *t\n       = \"%.\\\\tatom%A1.add%t0\\\\t%0, %1, %2;\";\n     return nvptx_output_atomic_insn (t, operands, 1, 3);\n@@ -1840,6 +1886,22 @@\n \t(match_dup 1))]\n   \"\"\n   {\n+    struct address_info info;\n+    decompose_mem_address (&info, operands[1]);\n+    if (info.base != NULL && REG_P (*info.base)\n+\t&& REGNO_PTR_FRAME_P (REGNO (*info.base)))\n+      {\n+\toutput_asm_insn (\"{\", NULL);\n+\toutput_asm_insn (\"\\\\t\"\t \".reg%t0\"  \"\\\\t\" \"%%val;\", operands);\n+\toutput_asm_insn (\"\\\\t\"\t \".reg%t0\"  \"\\\\t\" \"%%update;\", operands);\n+\toutput_asm_insn (\"%.\\\\t\" \"ld%A1%t0\" \"\\\\t\" \"%%val,%1;\", operands);\n+\toutput_asm_insn (\"%.\\\\t\" \"add%t0\"   \"\\\\t\" \"%%update,%%val,%2;\",\n+\t\t\t operands);\n+\toutput_asm_insn (\"%.\\\\t\" \"st%A1%t0\" \"\\\\t\" \"%1,%%update;\", operands);\n+\toutput_asm_insn (\"%.\\\\t\" \"mov%t0\"   \"\\\\t\" \"%0,%%val;\", operands);\n+\toutput_asm_insn (\"}\", NULL);\n+\treturn \"\";\n+      }\n     const char *t\n       = \"%.\\\\tatom%A1.add%t0\\\\t%0, %1, %2;\";\n     return nvptx_output_atomic_insn (t, operands, 1, 3);\n@@ -1860,6 +1922,22 @@\n \t(match_dup 1))]\n   \"<MODE>mode == SImode || TARGET_SM35\"\n   {\n+    struct address_info info;\n+    decompose_mem_address (&info, operands[1]);\n+    if (info.base != NULL && REG_P (*info.base)\n+\t&& REGNO_PTR_FRAME_P (REGNO (*info.base)))\n+      {\n+\toutput_asm_insn (\"{\", NULL);\n+\toutput_asm_insn (\"\\\\t\"\t \".reg.b%T0\"    \"\\\\t\" \"%%val;\", operands);\n+\toutput_asm_insn (\"\\\\t\"\t \".reg.b%T0\"    \"\\\\t\" \"%%update;\", operands);\n+\toutput_asm_insn (\"%.\\\\t\" \"ld%A1%t0\"     \"\\\\t\" \"%%val,%1;\", operands);\n+\toutput_asm_insn (\"%.\\\\t\" \"<logic>.b%T0\" \"\\\\t\" \"%%update,%%val,%2;\",\n+\t\t\t operands);\n+\toutput_asm_insn (\"%.\\\\t\" \"st%A1%t0\"     \"\\\\t\" \"%1,%%update;\", operands);\n+\toutput_asm_insn (\"%.\\\\t\" \"mov%t0\"       \"\\\\t\" \"%0,%%val;\", operands);\n+\toutput_asm_insn (\"}\", NULL);\n+\treturn \"\";\n+      }\n     const char *t\n       = \"%.\\\\tatom%A1.b%T0.<logic>\\\\t%0, %1, %2;\";\n     return nvptx_output_atomic_insn (t, operands, 1, 3);"}, {"sha": "ad8e2f842fb6533d0d51089d12d570c362ae0247", "filename": "gcc/testsuite/gcc.target/nvptx/stack-atomics-run.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0451f93d9faa13495132f4e246e9bef30b51417/gcc%2Ftestsuite%2Fgcc.target%2Fnvptx%2Fstack-atomics-run.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0451f93d9faa13495132f4e246e9bef30b51417/gcc%2Ftestsuite%2Fgcc.target%2Fnvptx%2Fstack-atomics-run.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fnvptx%2Fstack-atomics-run.c?ref=e0451f93d9faa13495132f4e246e9bef30b51417", "patch": "@@ -0,0 +1,44 @@\n+/* { dg-do run } */\n+\n+enum memmodel {\n+  MEMMODEL_RELAXED = 0\n+};\n+\n+int\n+main (void)\n+{\n+  int a, b;\n+\n+  a = 1;\n+  __atomic_fetch_add (&a, 1, MEMMODEL_RELAXED);\n+  if (a != 2)\n+    __builtin_abort ();\n+\n+  a = 0;\n+  __atomic_fetch_or (&a, 1, MEMMODEL_RELAXED);\n+  if (a != 1)\n+    __builtin_abort ();\n+  \n+  a = 1;\n+  b = -1;\n+  b = __atomic_exchange_n (&a, 0, MEMMODEL_RELAXED);\n+  if (a != 0)\n+    __builtin_abort ();\n+  if (b != 1)\n+    __builtin_abort ();\n+\n+  a = 1;\n+  b = -1;\n+  {\n+    int expected = a;\n+    b = __atomic_compare_exchange_n (&a, &expected, 0, 0, MEMMODEL_RELAXED,\n+\t\t\t\t     MEMMODEL_RELAXED);\n+  }\n+  if (a != 0)\n+    __builtin_abort ();\n+  if (b != 1)\n+    __builtin_abort ();\n+\n+  \n+  return 0;\n+}"}, {"sha": "2f9e6f2d8a5de7f8ffeef6b08ab58b55eea62ab1", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/private-atomic-1.c", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0451f93d9faa13495132f4e246e9bef30b51417/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fprivate-atomic-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0451f93d9faa13495132f4e246e9bef30b51417/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fprivate-atomic-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fprivate-atomic-1.c?ref=e0451f93d9faa13495132f4e246e9bef30b51417", "patch": "@@ -32,13 +32,6 @@ int main (void)\n \t{\n #pragma acc atomic update\n \t  ++v;\n-\t  /* nvptx offloading: PR83812 \"operation not supported on global/shared address space\".\n-\t     { dg-output \"(\\n|\\r\\n|\\r)libgomp: cuStreamSynchronize error: operation not supported on global/shared address space(\\n|\\r\\n|\\r)$\" { target openacc_nvidia_accel_selected } }\n-\t       Scan for what we expect in the \"XFAILed\" case (without actually XFAILing).\n-\t     { dg-shouldfail \"XFAILed\" { openacc_nvidia_accel_selected } }\n-\t       ... instead of 'dg-xfail-run-if' so that 'dg-output' is evaluated at all.\n-\t     { dg-final { if { [dg-process-target { xfail openacc_nvidia_accel_selected }] == \"F\" } { xfail \"[testname-for-summary] really is XFAILed\" } } }\n-\t       ... so that we still get an XFAIL visible in the log.  */\n \t}\n \n       res += (v == -222 + 121);"}, {"sha": "3f39d9e18e8f7f19d24bc746d4945a8dd438fe10", "filename": "libgomp/testsuite/libgomp.oacc-fortran/private-atomic-1-vector.f90", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0451f93d9faa13495132f4e246e9bef30b51417/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fprivate-atomic-1-vector.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0451f93d9faa13495132f4e246e9bef30b51417/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fprivate-atomic-1-vector.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fprivate-atomic-1-vector.f90?ref=e0451f93d9faa13495132f4e246e9bef30b51417", "patch": "@@ -25,13 +25,6 @@ program main\n       do i = 0, 31\n         !$acc atomic update\n         w = w + 1\n-        ! nvptx offloading: PR83812 \"operation not supported on global/shared address space\".\n-        ! { dg-output \"(\\n|\\r\\n|\\r)libgomp: cuStreamSynchronize error: operation not supported on global/shared address space(\\n|\\r\\n|\\r)$\" { target openacc_nvidia_accel_selected } }\n-        !   Scan for what we expect in the \"XFAILed\" case (without actually XFAILing).\n-        ! { dg-shouldfail \"XFAILed\" { openacc_nvidia_accel_selected } }\n-        !   ... instead of 'dg-xfail-run-if' so that 'dg-output' is evaluated at all.\n-        ! { dg-final { if { [dg-process-target { xfail openacc_nvidia_accel_selected }] == \"F\" } { xfail \"[testname-for-summary] really is XFAILed\" } } }\n-        !   ... so that we still get an XFAIL visible in the log.\n         !$acc end atomic\n       end do\n       arr(j) = w"}, {"sha": "a86b7a491bc7501e6eeac5aa16af2fdf66bd4de0", "filename": "libgomp/testsuite/libgomp.oacc-fortran/private-atomic-1-worker.f90", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0451f93d9faa13495132f4e246e9bef30b51417/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fprivate-atomic-1-worker.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0451f93d9faa13495132f4e246e9bef30b51417/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fprivate-atomic-1-worker.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fprivate-atomic-1-worker.f90?ref=e0451f93d9faa13495132f4e246e9bef30b51417", "patch": "@@ -25,13 +25,6 @@ program main\n       do i = 0, 31\n         !$acc atomic update\n         w = w + 1\n-        ! nvptx offloading: PR83812 \"operation not supported on global/shared address space\".\n-        ! { dg-output \"(\\n|\\r\\n|\\r)libgomp: cuStreamSynchronize error: operation not supported on global/shared address space(\\n|\\r\\n|\\r)$\" { target openacc_nvidia_accel_selected } }\n-        !   Scan for what we expect in the \"XFAILed\" case (without actually XFAILing).\n-        ! { dg-shouldfail \"XFAILed\" { openacc_nvidia_accel_selected } }\n-        !   ... instead of 'dg-xfail-run-if' so that 'dg-output' is evaluated at all.\n-        ! { dg-final { if { [dg-process-target { xfail openacc_nvidia_accel_selected }] == \"F\" } { xfail \"[testname-for-summary] really is XFAILed\" } } }\n-        !   ... so that we still get an XFAIL visible in the log.\n         !$acc end atomic\n       end do\n       arr(j) = w"}]}