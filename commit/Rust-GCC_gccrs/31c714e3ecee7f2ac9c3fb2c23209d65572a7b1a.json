{"sha": "31c714e3ecee7f2ac9c3fb2c23209d65572a7b1a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzFjNzE0ZTNlY2VlN2YyYWM5YzNmYjJjMjMyMDlkNjU1NzJhN2IxYQ==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1992-03-21T00:11:12Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1992-03-21T00:11:12Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r541", "tree": {"sha": "ebbc8b1746842eaba59be036a22030366916b7b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ebbc8b1746842eaba59be036a22030366916b7b3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/31c714e3ecee7f2ac9c3fb2c23209d65572a7b1a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31c714e3ecee7f2ac9c3fb2c23209d65572a7b1a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31c714e3ecee7f2ac9c3fb2c23209d65572a7b1a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31c714e3ecee7f2ac9c3fb2c23209d65572a7b1a/comments", "author": null, "committer": null, "parents": [{"sha": "b372168cef8e4b8707cc5b1ed6fecb2a36ccc264", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b372168cef8e4b8707cc5b1ed6fecb2a36ccc264", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b372168cef8e4b8707cc5b1ed6fecb2a36ccc264"}], "stats": {"total": 266, "additions": 103, "deletions": 163}, "files": [{"sha": "82f7ee6735ad870c5eed34165c37f6813591810f", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 103, "deletions": 163, "changes": 266, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31c714e3ecee7f2ac9c3fb2c23209d65572a7b1a/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31c714e3ecee7f2ac9c3fb2c23209d65572a7b1a/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=31c714e3ecee7f2ac9c3fb2c23209d65572a7b1a", "patch": "@@ -80,7 +80,6 @@ extern int set_noreorder;\t\t/* # of nested .set noreorder's  */\n extern int set_nomacro;\t\t\t/* # of nested .set nomacro's  */\n extern int set_noat;\t\t\t/* # of nested .set noat's  */\n extern int set_volatile;\t\t/* # of nested .set volatile's  */\n-extern int flag_half_pic;\t\t/* whether or not we use half-pic */\n extern int mips_branch_likely;\t\t/* emit 'l' after br (branch likely) */\n extern int mips_dbx_regno[];\t\t/* Map register # to debug register # */\n extern char mips_rtx_classify[];\t/* classify an RTX code */\n@@ -119,15 +118,14 @@ extern int\t\tfunction_arg_partial_nregs ();\n extern void\t\tfunction_epilogue ();\n extern void\t\tfunction_prologue ();\n extern void\t\tgen_conditional_branch ();\n-extern void\t\thalf_pic_encode_section_info ();\n extern void\t\tinit_cumulative_args ();\n extern int\t\tlarge_int ();\n extern int\t\tmd_register_operand ();\n extern int\t\tmips_address_cost ();\n extern void\t\tmips_asm_file_end ();\n extern void\t\tmips_asm_file_start ();\n+extern void\t\tmips_declare_object ();\n extern int\t\tmips_const_double_ok ();\n-extern int\t\tmips_constant_address_p ();\n extern void\t\tmips_count_memory_refs ();\n extern int\t\tmips_debugger_offset ();\n extern int\t\tmips_epilogue_delay_slots ();\n@@ -155,6 +153,15 @@ extern void\t\treadonly_data_section ();\n extern void\t\tsdata_section ();\n extern void\t\ttext_section ();\n \n+/* Stubs for half-pic support if not OSF/1 reference platform.  */\n+\n+#ifndef HALF_PIC_P\n+#define HALF_PIC_P() 0\n+#define HALF_PIC_ENCODE(DECL)\n+#define HALF_PIC_INIT()\terror (\"half-pic init called on systems that don't support it.\")\n+#define HALF_PIC_ADDRESS_P(X) 0\n+#endif\n+\n \f\n /* Switch  Recognition by gcc.c.  Add -G xx support */\n \n@@ -234,7 +241,6 @@ while (0)\n       flag_delayed_branch\t\t= TRUE;\t\t\t\t\\\n       flag_thread_jumps\t\t\t= TRUE;\t\t\t\t\\\n       flag_schedule_insns_after_reload\t= TRUE;\t\t\t\t\\\n-      flag_caller_saves\t\t\t= TRUE;\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n   if (LEVEL >= 2)\t\t\t\t\t\t\t\\\n@@ -244,7 +250,7 @@ while (0)\n       flag_expensive_optimizations\t= TRUE;\t\t\t\t\\\n       flag_rerun_cse_after_loop\t\t= TRUE;\t\t\t\t\\\n       flag_schedule_insns\t\t= TRUE;\t\t\t\t\\\n-   }\t\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n   if (LEVEL >= 3)\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n@@ -300,29 +306,31 @@ while (0)\n /* Extra switches sometimes passed to the assembler.  */\n \n #ifndef ASM_SPEC\n-#define ASM_SPEC\t\"%{!mgas:\t\t\t\t\t\\\n-\t\t\t\t%{!mrnames: -nocpp}\t\t\t\\\n-\t\t\t \t%{pipe: %e-pipe is not supported.}\t\\\n-\t\t\t\t%{EB} %{!EB:-EB}\t\t\t\\\n-\t\t\t\t%{EL: %e-EL not supported}\t\t\\\n-\t\t\t\t%{O:-O2} %{O1:-O2} %{O2:-O2} %{O3:-O3}\t\\\n-\t\t\t\t%{g} %{g0} %{g1} %{g2} %{g3} %{v} %{K}}\t\\\n-\t\t\t %{G*}\"\n+#define ASM_SPEC \"\\\n+%{!mgas: \\\n+\t%{!mrnames: -nocpp} \\\n+\t%{pipe: %e-pipe is not supported.} \\\n+\t%{EB} %{!EB:-EB} \\\n+\t%{EL: %e-EL not supported} \\\n+\t%{O:-O2} %{O1:-O2} %{O2:-O2} %{O3:-O3} \\\n+\t%{g} %{g0} %{g1} %{g2} %{g3} %{v} %{K}} \\\n+%{G*}\"\n \n #endif\t\t\t\t/* ASM_SPEC */\n \n /* Specify to run a post-processor, mips-tfile after the assembler\n    has run to stuff the mips debug information into the object file.\n    This is needed because the $#!%^ MIPS assembler provides no way\n-   of specifing such information in the assembly file.  */\n+   of specifying such information in the assembly file.  */\n \n #ifndef ASM_FINAL_SPEC\n-#define ASM_FINAL_SPEC \"%{!mgas: %{!mno-mips-tfile:\t\t\t\\\n-\t\t\t\t\\n mips-tfile %{v*: -v}\t\t\t\\\n-\t\t\t\t\t%{K: -I %b.o~} \t\t\t\\\n-\t\t\t\t\t%{!K: %{save-temps: -I %b.o~}}\t\\\n-\t\t\t\t\t%{c:%W{o*}%{!o*:-o %b.o}}%{!c:-o %b.o} \\\n-\t\t\t\t\t%{.s:%i} %{!.s:%g.s}}}\"\n+#define ASM_FINAL_SPEC \"\\\n+%{!mgas: %{!mno-mips-tfile: \\\n+\t\\n mips-tfile %{v*: -v} \\\n+\t\t%{K: -I %b.o~} \\\n+\t\t%{!K: %{save-temps: -I %b.o~}} \\\n+\t\t%{c:%W{o*}%{!o*:-o %b.o}}%{!c:-o %b.o} \\\n+\t\t%{.s:%i} %{!.s:%g.s}}}\"\n #endif\n \n /* Redefinition of libraries used.  Mips doesn't support normal\n@@ -333,77 +341,60 @@ while (0)\n #define LIB_SPEC \"%{pg:-lprof1} %{p:-lprof1} -lc\"\n #endif\n \n-/* Suppress libg.a from being linked in when debugging, since MIPS doesn't\n-   supply one.  */\n-\n-#ifndef LIBG_SPEC\n-#define LIBG_SPEC \"\"\n-#endif\n-\n-/* Extra switches sometimes passed to the loader.  */\n-\n+/* Extra switches sometimes passed to the linker.  */\n \n #ifndef LINK_SPEC\n-#define LINK_SPEC\t\"%{G*}\t\t\t\t\t\t\\\n-\t\t\t %{!mgas:\t\t\t\t\t\\\n-\t\t\t\t%{pipe: %e-pipe is not supported.}\t\\\n-\t\t\t\t%{EB} %{!EB:-EB}\t\t\t\\\n-\t\t\t\t%{EL: %e-EL not supported}\t\t\\\n-\t\t\t\t%{bestGnum}}\"\n+#define LINK_SPEC \"\\\n+%{G*} \\\n+%{!mgas: \\\n+\t%{pipe: %e-pipe is not supported.} \\\n+\t%{EB} %{!EB:-EB} \\\n+\t%{EL: %e-EL not supported} \\\n+\t%{bestGnum}}\"\n #endif\t\t\t\t/* LINK_SPEC defined */\n \n /* Specs for the compiler proper */\n \n #ifndef CC1_SPEC\n-#define CC1_SPEC   \"%{O*: %{!mno-gpOPT:%{!mno-gpopt: -mgpopt}}}\t\t\\\n-\t\t    %{gline:%{!g:%{!g0:%{!g1:%{!g2: -g1}}}}}\t\t\\\n-\t\t    %{G*}\t\t\t\t\t\t\\\n-\t\t    %{pic-none:   -mno-half-pic}\t\t\t\\\n-\t\t    %{pic-lib:    -mhalf-pic}\t\t\t\t\\\n-\t\t    %{pic-extern: -mhalf-pic}\t\t\t\t\\\n-\t\t    %{pic-calls:  -mhalf-pic}\t\t\t\t\\\n-\t\t    %{save-temps: }\"\n+#define CC1_SPEC \"\\\n+%{O*: %{!mno-gpOPT:%{!mno-gpopt: -mgpopt}}} \\\n+%{gline:%{!g:%{!g0:%{!g1:%{!g2: -g1}}}}} \\\n+%{G*} \\\n+%{pic-none:   -mno-half-pic} \\\n+%{pic-lib:    -mhalf-pic} \\\n+%{pic-extern: -mhalf-pic} \\\n+%{pic-calls:  -mhalf-pic} \\\n+%{save-temps: }\"\n #endif\n \n #ifndef CC1PLUS_SPEC\n-#define CC1PLUS_SPEC\t\"%{!fgnu-binutils: -fno-gnu-binutils}\"\n+#define CC1PLUS_SPEC \"%{!fgnu-binutils: -fno-gnu-binutils}\"\n #endif\n \n /* Preprocessor specs */\n \n #ifndef CPP_SPEC\n-#define CPP_SPEC\t\"%{!ansi:-DSYSTYPE_BSD} -D__SYSTYPE_BSD__\t\\\n-\t\t\t %{.S:\t-D__LANGUAGE_ASSEMBLY__\t\t\t\\\n-\t\t\t\t-D_LANGUAGE_ASSEMBLY\t\t\t\\\n-\t\t\t\t%{!ansi:-DLANGUAGE_ASSEMBLY}}\t\t\\\n-\t\t\t %{.cc:\t-D__LANGUAGE_C_PLUS_PLUS__\t\t\\\n-\t\t\t\t-D_LANGUAGE_C_PLUS_PLUS\t\t\t\\\n-\t\t\t\t%{!ansi:-DLANGUAGE_C_PLUS_PLUS}}\t\\\n-\t\t\t %{.cxx:-D__LANGUAGE_C_PLUS_PLUS__\t\t\\\n-\t\t\t\t-D_LANGUAGE_C_PLUS_PLUS\t\t\t\\\n-\t\t\t\t%{!ansi:-DLANGUAGE_C_PLUS_PLUS}}\t\\\n-\t\t\t %{.C:\t-D__LANGUAGE_C_PLUS_PLUS__\t\t\\\n-\t\t\t\t-D_LANGUAGE_C_PLUS_PLUS\t\t\t\\\n-\t\t\t\t%{!ansi:-DLANGUAGE_C_PLUS_PLUS}}\t\\\n-\t\t\t %{.m:\t-D__LANGUAGE_OBJECTIVE_C__\t\t\\\n-\t\t\t\t-D_LANGUAGE_OBJECTIVE_C\t\t\t\\\n-\t\t\t\t%{!ansi:-DLANGUAGE_OBJECTIVE_C}}\t\\\n-\t\t\t %{!.S: -D__LANGUAGE_C__\t\t\t\\\n-\t\t\t\t-D_LANGUAGE_C\t\t\t\t\\\n-\t\t\t\t%{!ansi:-DLANGUAGE_C}}\"\n+#define CPP_SPEC \"\\\n+%{!ansi:-DSYSTYPE_BSD} -D__SYSTYPE_BSD__ \\\n+%{.cc:\t-D__LANGUAGE_C_PLUS_PLUS -D_LANGUAGE_C_PLUS_PLUS} \\\n+%{.cxx:\t-D__LANGUAGE_C_PLUS_PLUS -D_LANGUAGE_C_PLUS_PLUS} \\\n+%{.C:\t-D__LANGUAGE_C_PLUS_PLUS -D_LANGUAGE_C_PLUS_PLUS} \\\n+%{.m:\t-D__LANGUAGE_OBJECTIVE_C -D_LANGUAGE_OBJECTIVE_C} \\\n+%{.S:\t-D__LANGUAGE_ASSEMBLY -D_LANGUAGE_ASSEMBLY %{!ansi:-DLANGUAGE_ASSEMBLY}} \\\n+%{!.S:\t-D__LANGUAGE_C -D_LANGUAGE_C %{!ansi:-DLANGUAGE_C}}\"\n #endif\n \n /* If defined, this macro is an additional prefix to try after\n    `STANDARD_EXEC_PREFIX'.  */\n \n #ifndef MD_EXEC_PREFIX\n-#define MD_EXEC_PREFIX \"/usr/lib/cmplrs/cc\"\n+#define MD_EXEC_PREFIX \"/usr/lib/cmplrs/cc/\"\n #endif\n \n \f\n /* Print subsidiary information on the compiler version in use.  */\n \n-#define MIPS_VERSION \"[AL 1.1, MM 11]\"\n+#define MIPS_VERSION \"[AL 1.1, MM 13]\"\n \n #ifndef MACHINE_TYPE\n #define MACHINE_TYPE \"BSD Mips\"\n@@ -584,6 +575,13 @@ do {\t\t\t\t\t\t\t\\\n #define DEBUGGER_AUTO_OFFSET(X)\t\tmips_debugger_offset (X, 0)\n #define DEBUGGER_ARG_OFFSET(OFFSET, X)\tmips_debugger_offset (X, OFFSET)\n \n+\n+/* Tell collect that the object format is ECOFF */\n+#ifndef OBJECT_FORMAT_ROSE\n+#define OBJECT_FORMAT_COFF\t/* Object file looks like COFF */\n+#define EXTENDED_COFF\t\t/* ECOFF, not normal coff */\n+#endif\n+\n \f\n /* Run-time compilation parameters selecting different hardware subsets.  */\n \n@@ -617,7 +615,7 @@ do {\t\t\t\t\t\t\t\\\n \t\t\t\t\t/* switches not used yet */\n #define MASK_WC8\t0x00000000\t/* wchar's are  8 bits, not 32 */\n #define MASK_WC16\t0x00000000\t/* wchar's are 16 bits, not 32 */\n-#define MASK_WC32\t0x00000000\t/* dummy for consistancy */\n+#define MASK_WC32\t0x00000000\t/* dummy for consistency */\n \n \t\t\t\t\t/* Debug switches, not documented */\n #define MASK_DEBUG\t0x40000000\t/* Eliminate version # in .s file */\n@@ -807,7 +805,7 @@ do {\t\t\t\t\t\t\t\\\n #define LEAST_SIGNIFICANT_WORD\t0\n #endif\n \n-/* Number of bits in an addressible storage unit */\n+/* Number of bits in an addressable storage unit */\n #define BITS_PER_UNIT 8\n \n /* Width in bits of a \"word\", which is the contents of a machine register.\n@@ -887,9 +885,9 @@ do {\t\t\t\t\t\t\t\\\n /* Biggest alignment any structure field can require in bits.  */\n #define BIGGEST_FIELD_ALIGNMENT 64\n \n-/* Define this if move instructions will actually fail to work\n+/* Set this nonzero if move instructions will actually fail to work\n    when given unaligned data.  */\n-#define STRICT_ALIGNMENT\n+#define STRICT_ALIGNMENT 1\n \n /* Define this if you wish to imitate the way many other C compilers\n    handle alignment of bitfields and the structures that contain\n@@ -1326,16 +1324,16 @@ extern enum reg_class mips_char_to_class[];\n    operand as its first argument and the constraint letter as its\n    second operand.\n \n-   `Q'\tis for memory refereces using take more than 1 instruction.\n-   `R'\tis for memory refereces which take 1 word for the instruction.\n+   `Q'\tis for memory references which take more than 1 instruction.\n+   `R'\tis for memory references which take 1 word for the instruction.\n    `S'\tis for references to extern items which are PIC for OSF/rose.  */\n \n #define EXTRA_CONSTRAINT(OP,CODE)\t\t\t\t\t\\\n   ((GET_CODE (OP) != MEM) ? FALSE\t\t\t\t\t\\\n    : ((CODE) == 'Q')\t  ? !simple_memory_operand (OP, GET_MODE (OP))\t\\\n    : ((CODE) == 'R')\t  ? simple_memory_operand (OP, GET_MODE (OP))\t\\\n-   : ((CODE) == 'S')\t  ? (flag_half_pic && CONSTANT_P (OP)\t\t\\\n-\t\t\t     && !mips_constant_address_p (OP))\t\t\\\n+   : ((CODE) == 'S')\t  ? (HALF_PIC_P () && CONSTANT_P (OP)\t\t\\\n+\t\t\t     && HALF_PIC_ADDRESS_P (OP))\t\t\\\n    : FALSE)\n \n /* Given an rtx X being reloaded into a reg required to be\n@@ -1419,9 +1417,7 @@ extern struct mips_frame_info current_frame_info;\n    of the fixed parts of the stack frame and on how registers are saved.  */\n \n #define INITIAL_FRAME_POINTER_OFFSET(VAR)\t\t\t\t\\\n- ((VAR) = (current_frame_info.initialized)\t\t\t\t\\\n-\t\t? current_frame_info.total_size\t\t\t\t\\\n-\t\t: compute_frame_size (get_frame_size ()))\n+ ((VAR) = compute_frame_size (get_frame_size ()))\n \n /* If we generate an insn to push BYTES bytes,\n    this says how many the stack pointer really advances by.\n@@ -1951,7 +1947,7 @@ __enable_execute_stack (addr)\t\t\t\t\t\t\\\n \t     machine doesn't support it.  This is because the\t\t\\\n \t     assembler can use $r1 to load just the high 16 bits, add\t\\\n \t     in the register, and fold the low 16 bits into the memory\t\\\n-\t     reference, wheras the compiler generates a 4 instruction\t\\\n+\t     reference, whereas the compiler generates a 4 instruction\t\\\n \t     sequence.  On the other hand, CSE is not as effective.\t\\\n \t     It would be a win to generate the lui directly, but the\t\\\n \t     MIPS assembler does not have syntax to generate the\t\\\n@@ -1979,7 +1975,8 @@ __enable_execute_stack (addr)\t\t\t\t\t\t\\\n    `high' expressions and `const' arithmetic expressions, in\n    addition to `const_int' and `const_double' expressions.  */\n \n-#define CONSTANT_ADDRESS_P(X) mips_constant_address_p (X)\n+#define CONSTANT_ADDRESS_P(X)\t\t\t\t\t\t\\\n+  (CONSTANT_P (X) && (!HALF_PIC_P () || HALF_PIC_ADDRESS_P (X)))\n \n \n /* Nonzero if the constant value X is a legitimate general operand.\n@@ -2071,8 +2068,8 @@ do\t\t\t\t\t\t\t\t\t\\\n \t  SYMBOL_REF_FLAG (XEXP (DECL_RTL (DECL), 0)) = 1;\t\t\\\n       }\t\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n-    else if (flag_half_pic)\t\t\t\t\t\t\\\n-      half_pic_encode_section_info (DECL);\t\t\t\t\\\n+    else if (HALF_PIC_P ())\t\t\t\t\t\t\\\n+      HALF_PIC_ENCODE (DECL);\t\t\t\t\t\t\\\n   }\t\t\t\t\t\t\t\t\t\\\n while (0)\n \n@@ -2176,7 +2173,7 @@ while (0)\n   case CONST:\t\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n       extern rtx eliminate_constant_term ();\t\t\t\t\\\n-      int offset = 0;\t\t\t\t\t\t\t\\\n+      rtx offset = const0_rtx;\t\t\t\t\t\t\\\n       rtx symref = eliminate_constant_term (X, &offset);\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n       if (GET_CODE (symref) == LABEL_REF)\t\t\t\t\\\n@@ -2186,7 +2183,7 @@ while (0)\n \treturn COSTS_N_INSNS (4);\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n       /* let's be paranoid.... */\t\t\t\t\t\\\n-      if (offset < -32768 || offset > 32767)\t\t\t\t\\\n+      if (INTVAL (offset) < -32768 || INTVAL (offset) > 32767)\t\t\\\n \treturn COSTS_N_INSNS (2);\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n       return COSTS_N_INSNS (SYMBOL_REF_FLAG (symref) ? 1 : 2);\t\t\\\n@@ -2400,7 +2397,7 @@ while (0)\n /* Optionally define this if you have added predicates to\n    `MACHINE.c'.  This macro is called within an initializer of an\n    array of structures.  The first field in the structure is the\n-   name of a predicate and the second field is an arrary of rtl\n+   name of a predicate and the second field is an array of rtl\n    codes.  For each predicate, list all rtl codes that can be in\n    expressions matched by the predicate.  The list should have a\n    trailing comma.  Here is an example of two entries in the list\n@@ -2869,75 +2866,47 @@ while (0)\n    since those bits seem to be unused, and we don't have any method\n    of getting the decl nodes from the name.  */\n \n-#ifndef COLLECT\n #define ASM_OUTPUT_LABEL(STREAM,NAME)\t\t\t\t\t\\\n do {\t\t\t\t\t\t\t\t\t\\\n   assemble_name (STREAM, NAME);\t\t\t\t\t\t\\\n   fputs (\":\\n\", STREAM);\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  if (TARGET_GP_OPT && mips_section_threshold != 0)\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      tree name_tree = get_identifier (NAME);\t\t\t\t\\\n-      TREE_ADDRESSABLE (name_tree) = 1;\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n } while (0)\n \n-#else\n-#define ASM_OUTPUT_LABEL(STREAM,NAME)\t\t\t\t\t\\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  fprintf (STREAM, \"%s:\\n\", NAME);\t\t\t\t\t\\\n-} while (0)\n-#endif\n+\n+/* A C statement (sans semicolon) to output to the stdio stream\n+   STREAM any text necessary for declaring the name NAME of an\n+   initialized variable which is being defined.  This macro must\n+   output the label definition (perhaps using `ASM_OUTPUT_LABEL'). \n+   The argument DECL is the `VAR_DECL' tree node representing the\n+   variable.\n+\n+   If this macro is not defined, then the variable name is defined\n+   in the usual manner as a label (by means of `ASM_OUTPUT_LABEL').  */\n+\n+#define ASM_DECLARE_OBJECT_NAME(STREAM, NAME, DECL)\t\t\t\\\n+  mips_declare_object (STREAM, NAME, \"\", \":\\n\", 0);\n+\n \n /* This is how to output a command to make the user-level label named NAME\n    defined for reference from other files.  */\n \n-#ifndef COLLECT\n #define ASM_GLOBALIZE_LABEL(STREAM,NAME)\t\t\t\t\\\n   do {\t\t\t\t\t\t\t\t\t\\\n     fputs (\"\\t.globl\\t\", STREAM);\t\t\t\t\t\\\n     assemble_name (STREAM, NAME);\t\t\t\t\t\\\n     fputs (\"\\n\", STREAM);\t\t\t\t\t\t\\\n   } while (0)\n \n-#else\n-#define ASM_GLOBALIZE_LABEL(STREAM,NAME)\t\t\t\t\\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  fprintf (STREAM, \"\\t.globl\\t%s\\n\", NAME);\t\t\t\t\\\n-} while (0)\n-#endif\n-\n-/* This says how to output an assembler line\n-   to define a global common symbol.  */\n+/* This says how to define a global common symbol.  */\n \n #define ASM_OUTPUT_COMMON(STREAM, NAME, SIZE, ROUNDED)\t\t\t\\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  fputs (\"\\n\\t.comm\\t\", (STREAM));\t\t\t\t\t\\\n-  assemble_name ((STREAM), (NAME));\t\t\t\t\t\\\n-  fprintf ((STREAM), \",%u\\n\", (ROUNDED));\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  if (TARGET_GP_OPT && mips_section_threshold != 0)\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      tree name_tree = get_identifier (NAME);\t\t\t\t\\\n-      TREE_ADDRESSABLE (name_tree) = 1;\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-} while (0)\n+  mips_declare_object (STREAM, NAME, \"\\n\\t.comm\\t\", \",%u\\n\", (ROUNDED))\n \n-/* This says how to output an assembler line\n-   to define a local common symbol.  */\n+/* This says how to define a local common symbol (ie, not visable to\n+   linker).  */\n \n #define ASM_OUTPUT_LOCAL(STREAM, NAME, SIZE, ROUNDED)\t\t\t\\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  fputs (\"\\n\\t.lcomm\\t\", (STREAM));\t\t\t\t\t\\\n-  assemble_name ((STREAM), (NAME));\t\t\t\t\t\\\n-  fprintf ((STREAM), \",%u\\n\", (ROUNDED));\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  if (TARGET_GP_OPT && mips_section_threshold != 0)\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      tree name_tree = get_identifier (NAME);\t\t\t\t\\\n-      TREE_ADDRESSABLE (name_tree) = 1;\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-} while (0)\n+  mips_declare_object (STREAM, NAME, \"\\n\\t.lcomm\\t\", \",%u\\n\", (ROUNDED))\n \n \n /* This says how to output an external.  It would be possible not to\n@@ -3008,19 +2977,13 @@ do {\t\t\t\t\t\t\t\t\t\\\n \n /* This is how to output an assembler line defining an `int' constant.  */\n \n-#ifndef COLLECT\n #define ASM_OUTPUT_INT(STREAM,VALUE)\t\t\t\t\t\\\n do {\t\t\t\t\t\t\t\t\t\\\n   fprintf (STREAM, \"\\t.word\\t\");\t\t\t\t\t\\\n   output_addr_const (STREAM, (VALUE));\t\t\t\t\t\\\n   fprintf (STREAM, \"\\n\");\t\t\t\t\t\t\\\n } while (0)\n \n-#else\n-#define ASM_OUTPUT_INT(STREAM,VALUE)\t\t\t\t\t\\\n-  fprintf (STREAM, \"\\t.word\\t%d\\n\", VALUE)\n-#endif\n-\n /* Likewise for `char' and `short' constants.  */\n \n #define ASM_OUTPUT_SHORT(STREAM,VALUE)\t\t\t\t\t\\\n@@ -3037,29 +3000,6 @@ do {\t\t\t\t\t\t\t\t\t\\\n   fprintf (STREAM, \"\\n\");\t\t\t\t\t\t\\\n }\n \n-/* This is how to output an assembler line defining an `int' constant,\n-   which is not in tree format (for collect.c).  */\n-\n-#define ASM_OUTPUT_INT_CONST(STREAM,VALUE) \t\t\t\t\\\n-  fprintf(STREAM, \"\\t.word\\t%d\\n\", VALUE)\n-\n-/* This is how to output an assembler line defining an external/static\n-   address which is not in tree format (for collect.c).  */\n-\n-#define ASM_OUTPUT_PTR_INT_SUM(STREAM, NAME, VALUE)\t\t\t\\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  fprintf (STREAM, \"\\t.word\\t\");\t\t\t\t\t\\\n-  ASM_OUTPUT_LABELREF (STREAM, NAME);\t\t\t\t\t\\\n-  fprintf (STREAM, \"+%d\\n\", VALUE);\t\t\t\t\t\\\n-} while (0)\n-\n-#define ASM_OUTPUT_LABELREF_AS_INT(STREAM, NAME)\t\t\t\\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  fprintf (STREAM, \"\\t.word\\t\");\t\t\t\t\t\\\n-  ASM_OUTPUT_LABELREF (STREAM, NAME);\t\t\t\t\t\\\n-  fprintf (STREAM, \"\\n\");\t\t\t\t\t\t\\\n-} while (0)\n-\n /* This is how to output an assembler line for a numeric constant byte.  */\n \n #define ASM_OUTPUT_BYTE(STREAM,VALUE)\t\t\t\t\t\\\n@@ -3192,19 +3132,19 @@ do {\t\t\t\t\t\t\t\t\t\\\n \n /* Output before read-only data.  */\n \n-#define TEXT_SECTION_ASM_OP \"\\t.text\"\n+#define TEXT_SECTION_ASM_OP \".text\"\n \n /* Output before writable data.  */\n \n-#define DATA_SECTION_ASM_OP \"\\t.data\"\n+#define DATA_SECTION_ASM_OP \".data\"\n \n /* Output before writable  short data.  */\n \n-#define SDATA_SECTION_ASM_OP \"\\t.sdata\"\n+#define SDATA_SECTION_ASM_OP \".sdata\"\n \n /* Output before read-only data.  */\n \n-#define RDATA_SECTION_ASM_OP \"\\t.rdata\"\n+#define RDATA_SECTION_ASM_OP \".rdata\"\n #define READONLY_DATA_SECTION rdata_section\n \n /* What other sections we support other than the normal .data/.text.  */"}]}