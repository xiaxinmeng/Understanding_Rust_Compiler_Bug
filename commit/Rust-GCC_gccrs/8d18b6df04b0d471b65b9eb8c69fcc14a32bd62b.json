{"sha": "8d18b6df04b0d471b65b9eb8c69fcc14a32bd62b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGQxOGI2ZGYwNGIwZDQ3MWI2NWI5ZWI4YzY5ZmNjMTRhMzJiZDYyYg==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2016-05-26T17:12:32Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2016-05-26T17:12:32Z"}, "message": "IVOPTS: make comp_cost in a more c++ fashion.\n\n\t* tree-ssa-loop-ivopts.c (comp_cost::infinite_cost_p): New\n\tfunction.\n\t(operator+): Likewise.\n\t(operator-): Likewise.\n\t(comp_cost::operator+=): Likewise.\n\t(comp_cost::operator-=): Likewise.\n\t(comp_cost::operator/=): Likewise.\n\t(comp_cost::operator*=): Likewise.\n\t(operator<): Likewise.\n\t(operator==): Likewise.\n\t(operator<=): Likewise.\n\t(new_cost): Remove.\n\t(infinite_cost_p): Likewise.\n\t(add_costs): Likewise.\n\t(sub_costs): Likewise.\n\t(compare_costs): Likewise.\n\t(set_group_iv_cost): Use the newly introduced functions.\n\t(get_address_cost): Likewise.\n\t(get_shiftadd_cost): Likewise.\n\t(force_expr_to_var_cost): Likewise.\n\t(split_address_cost): Likewise.\n\t(ptr_difference_cost): Likewise.\n\t(difference_cost): Likewise.\n\t(get_computation_cost_at): Likewise.\n\t(determine_group_iv_cost_generic): Likewise.\n\t(determine_group_iv_cost_address): Likewise.\n\t(determine_group_iv_cost_cond): Likewise.\n\t(autoinc_possible_for_pair): Likewise.\n\t(determine_group_iv_costs): Likewise.\n\t(cheaper_cost_pair): Likewise.\n\t(iv_ca_recount_cost): Likewise.\n\t(iv_ca_set_no_cp): Likewise.\n\t(iv_ca_set_cp): Likewise.\n\t(iv_ca_cost): Likewise.\n\t(iv_ca_new): Likewise.\n\t(iv_ca_dump): Likewise.\n\t(iv_ca_narrow): Likewise.\n\t(iv_ca_prune): Likewise.\n\t(iv_ca_replace): Likewise.\n\t(try_add_cand_for): Likewise.\n\t(try_improve_iv_set): Likewise.\n\t(find_optimal_iv_set): Likewise.\n\nFrom-SVN: r236785", "tree": {"sha": "0d7ea0e39a8f50aff01a046b3df42c967bb2c95a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0d7ea0e39a8f50aff01a046b3df42c967bb2c95a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8d18b6df04b0d471b65b9eb8c69fcc14a32bd62b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d18b6df04b0d471b65b9eb8c69fcc14a32bd62b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d18b6df04b0d471b65b9eb8c69fcc14a32bd62b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d18b6df04b0d471b65b9eb8c69fcc14a32bd62b/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b3d2acb6dce9a25f433c2d5d5bae48e9d2b4149a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3d2acb6dce9a25f433c2d5d5bae48e9d2b4149a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3d2acb6dce9a25f433c2d5d5bae48e9d2b4149a"}], "stats": {"total": 425, "additions": 280, "deletions": 145}, "files": [{"sha": "52335d18f217e89d4321d4571f4e9a119f2590d1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d18b6df04b0d471b65b9eb8c69fcc14a32bd62b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d18b6df04b0d471b65b9eb8c69fcc14a32bd62b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8d18b6df04b0d471b65b9eb8c69fcc14a32bd62b", "patch": "@@ -1,3 +1,48 @@\n+2016-05-26  Martin Liska  <mliska@suse.cz>\n+\n+\t* tree-ssa-loop-ivopts.c (comp_cost::infinite_cost_p): New\n+\tfunction.\n+\t(operator+): Likewise.\n+\t(operator-): Likewise.\n+\t(comp_cost::operator+=): Likewise.\n+\t(comp_cost::operator-=): Likewise.\n+\t(comp_cost::operator/=): Likewise.\n+\t(comp_cost::operator*=): Likewise.\n+\t(operator<): Likewise.\n+\t(operator==): Likewise.\n+\t(operator<=): Likewise.\n+\t(new_cost): Remove.\n+\t(infinite_cost_p): Likewise.\n+\t(add_costs): Likewise.\n+\t(sub_costs): Likewise.\n+\t(compare_costs): Likewise.\n+\t(set_group_iv_cost): Use the newly introduced functions.\n+\t(get_address_cost): Likewise.\n+\t(get_shiftadd_cost): Likewise.\n+\t(force_expr_to_var_cost): Likewise.\n+\t(split_address_cost): Likewise.\n+\t(ptr_difference_cost): Likewise.\n+\t(difference_cost): Likewise.\n+\t(get_computation_cost_at): Likewise.\n+\t(determine_group_iv_cost_generic): Likewise.\n+\t(determine_group_iv_cost_address): Likewise.\n+\t(determine_group_iv_cost_cond): Likewise.\n+\t(autoinc_possible_for_pair): Likewise.\n+\t(determine_group_iv_costs): Likewise.\n+\t(cheaper_cost_pair): Likewise.\n+\t(iv_ca_recount_cost): Likewise.\n+\t(iv_ca_set_no_cp): Likewise.\n+\t(iv_ca_set_cp): Likewise.\n+\t(iv_ca_cost): Likewise.\n+\t(iv_ca_new): Likewise.\n+\t(iv_ca_dump): Likewise.\n+\t(iv_ca_narrow): Likewise.\n+\t(iv_ca_prune): Likewise.\n+\t(iv_ca_replace): Likewise.\n+\t(try_add_cand_for): Likewise.\n+\t(try_improve_iv_set): Likewise.\n+\t(find_optimal_iv_set): Likewise.\n+\n 2016-05-26  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* tree-ssa-loop-ivopts.c (loop_body_includes_call): Don't assume"}, {"sha": "d770ec9e85af87608233eb6fa50c069cdc51e022", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 235, "deletions": 145, "changes": 380, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d18b6df04b0d471b65b9eb8c69fcc14a32bd62b/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d18b6df04b0d471b65b9eb8c69fcc14a32bd62b/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=8d18b6df04b0d471b65b9eb8c69fcc14a32bd62b", "patch": "@@ -173,16 +173,171 @@ enum use_type\n /* Cost of a computation.  */\n struct comp_cost\n {\n+  comp_cost (): cost (0), complexity (0), scratch (0)\n+  {}\n+\n+  comp_cost (int cost, unsigned complexity, int scratch = 0)\n+    : cost (cost), complexity (complexity), scratch (scratch)\n+  {}\n+\n+  /* Returns true if COST is infinite.  */\n+  bool infinite_cost_p ();\n+\n+  /* Adds costs COST1 and COST2.  */\n+  friend comp_cost operator+ (comp_cost cost1, comp_cost cost2);\n+\n+  /* Adds COST to the comp_cost.  */\n+  comp_cost operator+= (comp_cost cost);\n+\n+  /* Adds constant C to this comp_cost.  */\n+  comp_cost operator+= (HOST_WIDE_INT c);\n+\n+  /* Subtracts constant C to this comp_cost.  */\n+  comp_cost operator-= (HOST_WIDE_INT c);\n+\n+  /* Divide the comp_cost by constant C.  */\n+  comp_cost operator/= (HOST_WIDE_INT c);\n+\n+  /* Multiply the comp_cost by constant C.  */\n+  comp_cost operator*= (HOST_WIDE_INT c);\n+\n+  /* Subtracts costs COST1 and COST2.  */\n+  friend comp_cost operator- (comp_cost cost1, comp_cost cost2);\n+\n+  /* Subtracts COST from this comp_cost.  */\n+  comp_cost operator-= (comp_cost cost);\n+\n+  /* Returns true if COST1 is smaller than COST2.  */\n+  friend bool operator< (comp_cost cost1, comp_cost cost2);\n+\n+  /* Returns true if COST1 and COST2 are equal.  */\n+  friend bool operator== (comp_cost cost1, comp_cost cost2);\n+\n+  /* Returns true if COST1 is smaller or equal than COST2.  */\n+  friend bool operator<= (comp_cost cost1, comp_cost cost2);\n+\n   int cost;\t\t/* The runtime cost.  */\n-  unsigned complexity;\t/* The estimate of the complexity of the code for\n+  unsigned complexity;  /* The estimate of the complexity of the code for\n \t\t\t   the computation (in no concrete units --\n \t\t\t   complexity field should be larger for more\n \t\t\t   complex expressions and addressing modes).  */\n   int scratch;\t\t/* Scratch used during cost computation.  */\n };\n \n-static const comp_cost no_cost = {0, 0, 0};\n-static const comp_cost infinite_cost = {INFTY, INFTY, INFTY};\n+static const comp_cost no_cost;\n+static const comp_cost infinite_cost (INFTY, INFTY, INFTY);\n+\n+bool\n+comp_cost::infinite_cost_p ()\n+{\n+  return cost == INFTY;\n+}\n+\n+comp_cost\n+operator+ (comp_cost cost1, comp_cost cost2)\n+{\n+  if (cost1.infinite_cost_p () || cost2.infinite_cost_p ())\n+    return infinite_cost;\n+\n+  cost1.cost += cost2.cost;\n+  cost1.complexity += cost2.complexity;\n+\n+  return cost1;\n+}\n+\n+comp_cost\n+operator- (comp_cost cost1, comp_cost cost2)\n+{\n+  if (cost1.infinite_cost_p ())\n+    return infinite_cost;\n+\n+  gcc_assert (!cost2.infinite_cost_p ());\n+\n+  cost1.cost -= cost2.cost;\n+  cost1.complexity -= cost2.complexity;\n+\n+  return cost1;\n+}\n+\n+comp_cost\n+comp_cost::operator+= (comp_cost cost)\n+{\n+  *this = *this + cost;\n+  return *this;\n+}\n+\n+comp_cost\n+comp_cost::operator+= (HOST_WIDE_INT c)\n+{\n+  if (infinite_cost_p ())\n+    return *this;\n+\n+  this->cost += c;\n+\n+  return *this;\n+}\n+\n+comp_cost\n+comp_cost::operator-= (HOST_WIDE_INT c)\n+{\n+  if (infinite_cost_p ())\n+    return *this;\n+\n+  this->cost -= c;\n+\n+  return *this;\n+}\n+\n+comp_cost\n+comp_cost::operator/= (HOST_WIDE_INT c)\n+{\n+  if (infinite_cost_p ())\n+    return *this;\n+\n+  this->cost /= c;\n+\n+  return *this;\n+}\n+\n+comp_cost\n+comp_cost::operator*= (HOST_WIDE_INT c)\n+{\n+  if (infinite_cost_p ())\n+    return *this;\n+\n+  this->cost *= c;\n+\n+  return *this;\n+}\n+\n+comp_cost\n+comp_cost::operator-= (comp_cost cost)\n+{\n+  *this = *this - cost;\n+  return *this;\n+}\n+\n+bool\n+operator< (comp_cost cost1, comp_cost cost2)\n+{\n+  if (cost1.cost == cost2.cost)\n+    return cost1.complexity < cost2.complexity;\n+\n+  return cost1.cost < cost2.cost;\n+}\n+\n+bool\n+operator== (comp_cost cost1, comp_cost cost2)\n+{\n+  return cost1.cost == cost2.cost\n+    && cost1.complexity == cost2.complexity;\n+}\n+\n+bool\n+operator<= (comp_cost cost1, comp_cost cost2)\n+{\n+  return cost1 < cost2 || cost1 == cost2;\n+}\n \n struct iv_inv_expr_ent;\n \n@@ -3284,64 +3439,6 @@ alloc_use_cost_map (struct ivopts_data *data)\n     }\n }\n \n-/* Returns description of computation cost of expression whose runtime\n-   cost is RUNTIME and complexity corresponds to COMPLEXITY.  */\n-\n-static comp_cost\n-new_cost (unsigned runtime, unsigned complexity)\n-{\n-  comp_cost cost;\n-\n-  cost.cost = runtime;\n-  cost.complexity = complexity;\n-\n-  return cost;\n-}\n-\n-/* Returns true if COST is infinite.  */\n-\n-static bool\n-infinite_cost_p (comp_cost cost)\n-{\n-  return cost.cost == INFTY;\n-}\n-\n-/* Adds costs COST1 and COST2.  */\n-\n-static comp_cost\n-add_costs (comp_cost cost1, comp_cost cost2)\n-{\n-  if (infinite_cost_p (cost1) || infinite_cost_p (cost2))\n-    return infinite_cost;\n-\n-  cost1.cost += cost2.cost;\n-  cost1.complexity += cost2.complexity;\n-\n-  return cost1;\n-}\n-/* Subtracts costs COST1 and COST2.  */\n-\n-static comp_cost\n-sub_costs (comp_cost cost1, comp_cost cost2)\n-{\n-  cost1.cost -= cost2.cost;\n-  cost1.complexity -= cost2.complexity;\n-\n-  return cost1;\n-}\n-\n-/* Returns a negative number if COST1 < COST2, a positive number if\n-   COST1 > COST2, and 0 if COST1 = COST2.  */\n-\n-static int\n-compare_costs (comp_cost cost1, comp_cost cost2)\n-{\n-  if (cost1.cost == cost2.cost)\n-    return cost1.complexity - cost2.complexity;\n-\n-  return cost1.cost - cost2.cost;\n-}\n-\n /* Sets cost of (GROUP, CAND) pair to COST and record that it depends\n    on invariants DEPENDS_ON and that the value used in expressing it\n    is VALUE, and in case of iv elimination the comparison operator is COMP.  */\n@@ -3354,7 +3451,7 @@ set_group_iv_cost (struct ivopts_data *data,\n {\n   unsigned i, s;\n \n-  if (infinite_cost_p (cost))\n+  if (cost.infinite_cost_p ())\n     {\n       BITMAP_FREE (depends_on);\n       return;\n@@ -4170,7 +4267,7 @@ get_address_cost (bool symbol_present, bool var_present,\n   else\n     acost = data->costs[symbol_present][var_present][offset_p][ratio_p];\n   complexity = (symbol_present != 0) + (var_present != 0) + offset_p + ratio_p;\n-  return new_cost (cost + acost, complexity);\n+  return comp_cost (cost + acost, complexity);\n }\n \n  /* Calculate the SPEED or size cost of shiftadd EXPR in MODE.  MULT is the\n@@ -4207,12 +4304,12 @@ get_shiftadd_cost (tree expr, machine_mode mode, comp_cost cost0,\n \t\t? shiftsub1_cost (speed, mode, m)\n \t\t: shiftsub0_cost (speed, mode, m)));\n \n-  res = new_cost (MIN (as_cost, sa_cost), 0);\n-  res = add_costs (res, mult_in_op1 ? cost0 : cost1);\n+  res = comp_cost (MIN (as_cost, sa_cost), 0);\n+  res += (mult_in_op1 ? cost0 : cost1);\n \n   STRIP_NOPS (multop);\n   if (!is_gimple_val (multop))\n-    res = add_costs (res, force_expr_to_var_cost (multop, speed));\n+    res += force_expr_to_var_cost (multop, speed);\n \n   *cost = res;\n   return true;\n@@ -4277,7 +4374,7 @@ force_expr_to_var_cost (tree expr, bool speed)\n   if (is_gimple_min_invariant (expr))\n     {\n       if (TREE_CODE (expr) == INTEGER_CST)\n-\treturn new_cost (integer_cost [speed], 0);\n+\treturn comp_cost (integer_cost [speed], 0);\n \n       if (TREE_CODE (expr) == ADDR_EXPR)\n \t{\n@@ -4286,10 +4383,10 @@ force_expr_to_var_cost (tree expr, bool speed)\n \t  if (TREE_CODE (obj) == VAR_DECL\n \t      || TREE_CODE (obj) == PARM_DECL\n \t      || TREE_CODE (obj) == RESULT_DECL)\n-\t    return new_cost (symbol_cost [speed], 0);\n+\t    return comp_cost (symbol_cost [speed], 0);\n \t}\n \n-      return new_cost (address_cost [speed], 0);\n+      return comp_cost (address_cost [speed], 0);\n     }\n \n   switch (TREE_CODE (expr))\n@@ -4313,7 +4410,7 @@ force_expr_to_var_cost (tree expr, bool speed)\n \n     default:\n       /* Just an arbitrary value, FIXME.  */\n-      return new_cost (target_spill_cost[speed], 0);\n+      return comp_cost (target_spill_cost[speed], 0);\n     }\n \n   if (op0 == NULL_TREE\n@@ -4335,7 +4432,7 @@ force_expr_to_var_cost (tree expr, bool speed)\n     case PLUS_EXPR:\n     case MINUS_EXPR:\n     case NEGATE_EXPR:\n-      cost = new_cost (add_cost (speed, mode), 0);\n+      cost = comp_cost (add_cost (speed, mode), 0);\n       if (TREE_CODE (expr) != NEGATE_EXPR)\n \t{\n \t  tree mult = NULL_TREE;\n@@ -4358,28 +4455,28 @@ force_expr_to_var_cost (tree expr, bool speed)\n \ttree inner_mode, outer_mode;\n \touter_mode = TREE_TYPE (expr);\n \tinner_mode = TREE_TYPE (op0);\n-\tcost = new_cost (convert_cost (TYPE_MODE (outer_mode),\n+\tcost = comp_cost (convert_cost (TYPE_MODE (outer_mode),\n \t\t\t\t       TYPE_MODE (inner_mode), speed), 0);\n       }\n       break;\n \n     case MULT_EXPR:\n       if (cst_and_fits_in_hwi (op0))\n-\tcost = new_cost (mult_by_coeff_cost (int_cst_value (op0),\n+\tcost = comp_cost (mult_by_coeff_cost (int_cst_value (op0),\n \t\t\t\t\t     mode, speed), 0);\n       else if (cst_and_fits_in_hwi (op1))\n-\tcost = new_cost (mult_by_coeff_cost (int_cst_value (op1),\n+\tcost = comp_cost (mult_by_coeff_cost (int_cst_value (op1),\n \t\t\t\t\t     mode, speed), 0);\n       else\n-\treturn new_cost (target_spill_cost [speed], 0);\n+\treturn comp_cost (target_spill_cost [speed], 0);\n       break;\n \n     default:\n       gcc_unreachable ();\n     }\n \n-  cost = add_costs (cost, cost0);\n-  cost = add_costs (cost, cost1);\n+  cost += cost0;\n+  cost += cost1;\n \n   /* Bound the cost by target_spill_cost.  The parts of complicated\n      computations often are either loop invariant or at least can\n@@ -4438,7 +4535,7 @@ split_address_cost (struct ivopts_data *data,\n       if (depends_on)\n \twalk_tree (&addr, find_depends, depends_on, NULL);\n \n-      return new_cost (target_spill_cost[data->speed], 0);\n+      return comp_cost (target_spill_cost[data->speed], 0);\n     }\n \n   *offset += bitpos / BITS_PER_UNIT;\n@@ -4538,7 +4635,7 @@ difference_cost (struct ivopts_data *data,\n   if (integer_zerop (e1))\n     {\n       comp_cost cost = force_var_cost (data, e2, depends_on);\n-      cost.cost += mult_by_coeff_cost (-1, mode, data->speed);\n+      cost += mult_by_coeff_cost (-1, mode, data->speed);\n       return cost;\n     }\n \n@@ -4805,7 +4902,7 @@ get_computation_cost_at (struct ivopts_data *data,\n \t\t\t      ubase, build_int_cst (utype, 0),\n \t\t\t      &symbol_present, &var_present, &offset,\n \t\t\t      depends_on);\n-      cost.cost /= avg_loop_niter (data->current_loop);\n+      cost /= avg_loop_niter (data->current_loop);\n     }\n   else if (ratio == 1)\n     {\n@@ -4829,7 +4926,7 @@ get_computation_cost_at (struct ivopts_data *data,\n \t\t\t      ubase, real_cbase,\n \t\t\t      &symbol_present, &var_present, &offset,\n \t\t\t      depends_on);\n-      cost.cost /= avg_loop_niter (data->current_loop);\n+      cost /= avg_loop_niter (data->current_loop);\n     }\n   else if (address_p\n \t   && !POINTER_TYPE_P (ctype)\n@@ -4852,21 +4949,19 @@ get_computation_cost_at (struct ivopts_data *data,\n \t\t\t      ubase, real_cbase,\n \t\t\t      &symbol_present, &var_present, &offset,\n \t\t\t      depends_on);\n-      cost.cost /= avg_loop_niter (data->current_loop);\n+      cost /= avg_loop_niter (data->current_loop);\n     }\n   else\n     {\n       cost = force_var_cost (data, cbase, depends_on);\n-      cost = add_costs (cost,\n-\t\t\tdifference_cost (data,\n-\t\t\t\t\t ubase, build_int_cst (utype, 0),\n-\t\t\t\t\t &symbol_present, &var_present,\n-\t\t\t\t\t &offset, depends_on));\n-      cost.cost /= avg_loop_niter (data->current_loop);\n-      cost.cost += add_cost (data->speed, TYPE_MODE (ctype));\n+      cost += difference_cost (data, ubase, build_int_cst (utype, 0),\n+\t\t\t       &symbol_present, &var_present, &offset,\n+\t\t\t       depends_on);\n+      cost /= avg_loop_niter (data->current_loop);\n+      cost += add_cost (data->speed, TYPE_MODE (ctype));\n     }\n \n-  /* Record setup cost in scrach field.  */\n+  /* Record setup cost in scratch field.  */\n   cost.scratch = cost.cost;\n \n   if (inv_expr && depends_on && *depends_on)\n@@ -4887,38 +4982,36 @@ get_computation_cost_at (struct ivopts_data *data,\n      (symbol/var1/const parts may be omitted).  If we are looking for an\n      address, find the cost of addressing this.  */\n   if (address_p)\n-    return add_costs (cost,\n-\t\t      get_address_cost (symbol_present, var_present,\n-\t\t\t\t\toffset, ratio, cstepi,\n-\t\t\t\t\tmem_mode,\n-\t\t\t\t\tTYPE_ADDR_SPACE (TREE_TYPE (utype)),\n-\t\t\t\t\tspeed, stmt_is_after_inc,\n-\t\t\t\t\tcan_autoinc));\n+    return cost + get_address_cost (symbol_present, var_present,\n+\t\t\t\t    offset, ratio, cstepi,\n+\t\t\t\t    mem_mode,\n+\t\t\t\t    TYPE_ADDR_SPACE (TREE_TYPE (utype)),\n+\t\t\t\t    speed, stmt_is_after_inc, can_autoinc);\n \n   /* Otherwise estimate the costs for computing the expression.  */\n   if (!symbol_present && !var_present && !offset)\n     {\n       if (ratio != 1)\n-\tcost.cost += mult_by_coeff_cost (ratio, TYPE_MODE (ctype), speed);\n+\tcost += mult_by_coeff_cost (ratio, TYPE_MODE (ctype), speed);\n       return cost;\n     }\n \n   /* Symbol + offset should be compile-time computable so consider that they\n       are added once to the variable, if present.  */\n   if (var_present && (symbol_present || offset))\n-    cost.cost += adjust_setup_cost (data,\n+    cost += adjust_setup_cost (data,\n \t\t\t\t    add_cost (speed, TYPE_MODE (ctype)));\n \n   /* Having offset does not affect runtime cost in case it is added to\n      symbol, but it increases complexity.  */\n   if (offset)\n     cost.complexity++;\n \n-  cost.cost += add_cost (speed, TYPE_MODE (ctype));\n+  cost += add_cost (speed, TYPE_MODE (ctype));\n \n   aratio = ratio > 0 ? ratio : -ratio;\n   if (aratio != 1)\n-    cost.cost += mult_by_coeff_cost (aratio, TYPE_MODE (ctype), speed);\n+    cost += mult_by_coeff_cost (aratio, TYPE_MODE (ctype), speed);\n   return cost;\n \n fallback:\n@@ -4935,9 +5028,7 @@ get_computation_cost_at (struct ivopts_data *data,\n     if (address_p)\n       comp = build_simple_mem_ref (comp);\n \n-    cost = new_cost (computation_cost (comp, speed), 0);\n-    cost.scratch = 0;\n-    return cost;\n+    return comp_cost (computation_cost (comp, speed), 0);\n   }\n }\n \n@@ -4983,7 +5074,7 @@ determine_group_iv_cost_generic (struct ivopts_data *data,\n \n   set_group_iv_cost (data, group, cand, cost, depends_on,\n \t\t     NULL_TREE, ERROR_MARK, inv_expr);\n-  return !infinite_cost_p (cost);\n+  return !cost.infinite_cost_p ();\n }\n \n /* Determines cost of computing uses in GROUP with CAND in addresses.  */\n@@ -5003,10 +5094,10 @@ determine_group_iv_cost_address (struct ivopts_data *data,\n \t\t\t       &depends_on, &can_autoinc, &inv_expr);\n \n   sum_cost = cost;\n-  if (!infinite_cost_p (sum_cost) && cand->ainc_use == use)\n+  if (!sum_cost.infinite_cost_p () && cand->ainc_use == use)\n     {\n       if (can_autoinc)\n-\tsum_cost.cost -= cand->cost_step;\n+\tsum_cost -= cand->cost_step;\n       /* If we generated the candidate solely for exploiting autoincrement\n \t opportunities, and it turns out it can't be used, set the cost to\n \t infinity to make sure we ignore it.  */\n@@ -5015,9 +5106,9 @@ determine_group_iv_cost_address (struct ivopts_data *data,\n     }\n \n   /* Uses in a group can share setup code, so only add setup cost once.  */\n-  cost.cost -= cost.scratch;\n+  cost -= cost.scratch;\n   /* Compute and add costs for rest uses of this group.  */\n-  for (i = 1; i < group->vuses.length () && !infinite_cost_p (sum_cost); i++)\n+  for (i = 1; i < group->vuses.length () && !sum_cost.infinite_cost_p (); i++)\n     {\n       struct iv_use *next = group->vuses[i];\n \n@@ -5042,15 +5133,15 @@ determine_group_iv_cost_address (struct ivopts_data *data,\n \t  cost = get_computation_cost (data, next, cand, true,\n \t\t\t\t       NULL, &can_autoinc, NULL);\n \t  /* Remove setup cost.  */\n-\t  if (!infinite_cost_p (cost))\n-\t    cost.cost -= cost.scratch;\n+\t  if (!cost.infinite_cost_p ())\n+\t    cost -= cost.scratch;\n \t}\n-      sum_cost = add_costs (sum_cost, cost);\n+      sum_cost += cost;\n     }\n   set_group_iv_cost (data, group, cand, sum_cost, depends_on,\n \t\t     NULL_TREE, ERROR_MARK, inv_expr);\n \n-  return !infinite_cost_p (sum_cost);\n+  return !sum_cost.infinite_cost_p ();\n }\n \n /* Computes value of candidate CAND at position AT in iteration NITER, and\n@@ -5513,11 +5604,11 @@ determine_group_iv_cost_cond (struct ivopts_data *data,\n      TODO: The constant that we're subtracting from the cost should\n      be target-dependent.  This information should be added to the\n      target costs for each backend.  */\n-  if (!infinite_cost_p (elim_cost) /* Do not try to decrease infinite! */\n+  if (!elim_cost.infinite_cost_p () /* Do not try to decrease infinite! */\n       && integer_zerop (*bound_cst)\n       && (operand_equal_p (*control_var, cand->var_after, 0)\n \t  || operand_equal_p (*control_var, cand->var_before, 0)))\n-    elim_cost.cost -= 1;\n+    elim_cost -= 1;\n \n   express_cost = get_computation_cost (data, use, cand, false,\n \t\t\t\t       &depends_on_express, NULL,\n@@ -5531,10 +5622,10 @@ determine_group_iv_cost_cond (struct ivopts_data *data,\n     bound_cost.cost = parm_decl_cost (data, *bound_cst);\n   else if (TREE_CODE (*bound_cst) == INTEGER_CST)\n     bound_cost.cost = 0;\n-  express_cost.cost += bound_cost.cost;\n+  express_cost += bound_cost;\n \n   /* Choose the better approach, preferring the eliminated IV. */\n-  if (compare_costs (elim_cost, express_cost) <= 0)\n+  if (elim_cost <= express_cost)\n     {\n       cost = elim_cost;\n       depends_on = depends_on_elim;\n@@ -5559,7 +5650,7 @@ determine_group_iv_cost_cond (struct ivopts_data *data,\n   if (depends_on_express)\n     BITMAP_FREE (depends_on_express);\n \n-  return !infinite_cost_p (cost);\n+  return !cost.infinite_cost_p ();\n }\n \n /* Determines cost of computing uses in GROUP with CAND.  Returns false\n@@ -5604,7 +5695,7 @@ autoinc_possible_for_pair (struct ivopts_data *data, struct iv_use *use,\n \n   BITMAP_FREE (depends_on);\n \n-  return !infinite_cost_p (cost) && can_autoinc;\n+  return !cost.infinite_cost_p () && can_autoinc;\n }\n \n /* Examine IP_ORIGINAL candidates to see if they are incremented next to a\n@@ -5770,7 +5861,7 @@ determine_group_iv_costs (struct ivopts_data *data)\n \t  for (j = 0; j < group->n_map_members; j++)\n \t    {\n \t      if (!group->cost_map[j].cand\n-\t\t  || infinite_cost_p (group->cost_map[j].cost))\n+\t\t  || group->cost_map[j].cost.infinite_cost_p ())\n \t\tcontinue;\n \n \t      fprintf (dump_file, \"  %d\\t%d\\t%d\\t\",\n@@ -5944,19 +6035,16 @@ determine_set_costs (struct ivopts_data *data)\n static bool\n cheaper_cost_pair (struct cost_pair *a, struct cost_pair *b)\n {\n-  int cmp;\n-\n   if (!a)\n     return false;\n \n   if (!b)\n     return true;\n \n-  cmp = compare_costs (a->cost, b->cost);\n-  if (cmp < 0)\n+  if (a->cost < b->cost)\n     return true;\n \n-  if (cmp > 0)\n+  if (b->cost < a->cost)\n     return false;\n \n   /* In case the costs are the same, prefer the cheaper candidate.  */\n@@ -5982,11 +6070,11 @@ iv_ca_recount_cost (struct ivopts_data *data, struct iv_ca *ivs)\n {\n   comp_cost cost = ivs->cand_use_cost;\n \n-  cost.cost += ivs->cand_cost;\n+  cost += ivs->cand_cost;\n \n-  cost.cost += ivopts_global_cost_for_size (data,\n-\t\t\t\t\t    ivs->n_regs\n-\t\t\t\t\t    + ivs->used_inv_exprs->elements ());\n+  cost += ivopts_global_cost_for_size (data,\n+\t\t\t\t       ivs->n_regs\n+\t\t\t\t       + ivs->used_inv_exprs->elements ());\n \n   ivs->cost = cost;\n }\n@@ -6040,7 +6128,7 @@ iv_ca_set_no_cp (struct ivopts_data *data, struct iv_ca *ivs,\n       iv_ca_set_remove_invariants (ivs, cp->cand->depends_on);\n     }\n \n-  ivs->cand_use_cost = sub_costs (ivs->cand_use_cost, cp->cost);\n+  ivs->cand_use_cost -= cp->cost;\n \n   iv_ca_set_remove_invariants (ivs, cp->depends_on);\n \n@@ -6106,7 +6194,7 @@ iv_ca_set_cp (struct ivopts_data *data, struct iv_ca *ivs,\n \t  iv_ca_set_add_invariants (ivs, cp->cand->depends_on);\n \t}\n \n-      ivs->cand_use_cost = add_costs (ivs->cand_use_cost, cp->cost);\n+      ivs->cand_use_cost += cp->cost;\n       iv_ca_set_add_invariants (ivs, cp->depends_on);\n \n       if (cp->inv_expr != NULL)\n@@ -6350,7 +6438,8 @@ iv_ca_dump (struct ivopts_data *data, FILE *file, struct iv_ca *ivs)\n   unsigned i;\n   comp_cost cost = iv_ca_cost (ivs);\n \n-  fprintf (file, \"  cost: %d (complexity %d)\\n\", cost.cost, cost.complexity);\n+  fprintf (file, \"  cost: %d (complexity %d)\\n\", cost.cost,\n+\t   cost.complexity);\n   fprintf (file, \"  cand_cost: %d\\n  cand_group_cost: %d (complexity %d)\\n\",\n \t   ivs->cand_cost, ivs->cand_use_cost.cost,\n \t   ivs->cand_use_cost.complexity);\n@@ -6361,8 +6450,9 @@ iv_ca_dump (struct ivopts_data *data, FILE *file, struct iv_ca *ivs)\n       struct iv_group *group = data->vgroups[i];\n       struct cost_pair *cp = iv_ca_cand_for_group (ivs, group);\n       if (cp)\n-\tfprintf (file, \"   group:%d --> iv_cand:%d, cost=(%d,%d)\\n\",\n-\t\t group->id, cp->cand->id, cp->cost.cost, cp->cost.complexity);\n+        fprintf (file, \"   group:%d --> iv_cand:%d, cost=(%d,%d)\\n\",\n+\t\t group->id, cp->cand->id, cp->cost.cost,\n+\t\t cp->cost.complexity);\n       else\n \tfprintf (file, \"   group:%d --> ??\\n\", group->id);\n     }\n@@ -6480,7 +6570,7 @@ iv_ca_narrow (struct ivopts_data *data, struct iv_ca *ivs,\n \t      iv_ca_set_cp (data, ivs, group, cp);\n \t      acost = iv_ca_cost (ivs);\n \n-\t      if (compare_costs (acost, best_cost) < 0)\n+\t      if (acost < best_cost)\n \t\t{\n \t\t  best_cost = acost;\n \t\t  new_cp = cp;\n@@ -6503,7 +6593,7 @@ iv_ca_narrow (struct ivopts_data *data, struct iv_ca *ivs,\n \t      iv_ca_set_cp (data, ivs, group, cp);\n \t      acost = iv_ca_cost (ivs);\n \n-\t      if (compare_costs (acost, best_cost) < 0)\n+\t      if (acost < best_cost)\n \t\t{\n \t\t  best_cost = acost;\n \t\t  new_cp = cp;\n@@ -6555,7 +6645,7 @@ iv_ca_prune (struct ivopts_data *data, struct iv_ca *ivs,\n \n       acost = iv_ca_narrow (data, ivs, cand, except_cand, &act_delta);\n \n-      if (compare_costs (acost, best_cost) < 0)\n+      if (acost < best_cost)\n \t{\n \t  best_cost = acost;\n \t  iv_ca_delta_free (&best_delta);\n@@ -6668,7 +6758,7 @@ iv_ca_replace (struct ivopts_data *data, struct iv_ca *ivs,\n       iv_ca_delta_commit (data, ivs, act_delta, false);\n       act_delta = iv_ca_delta_join (act_delta, tmp_delta);\n \n-      if (compare_costs (acost, orig_cost) < 0)\n+      if (acost < orig_cost)\n \t{\n \t  *delta = act_delta;\n \t  return acost;\n@@ -6737,7 +6827,7 @@ try_add_cand_for (struct ivopts_data *data, struct iv_ca *ivs,\n       iv_ca_set_no_cp (data, ivs, group);\n       act_delta = iv_ca_delta_add (group, NULL, cp, act_delta);\n \n-      if (compare_costs (act_cost, best_cost) < 0)\n+      if (act_cost < best_cost)\n \t{\n \t  best_cost = act_cost;\n \n@@ -6748,7 +6838,7 @@ try_add_cand_for (struct ivopts_data *data, struct iv_ca *ivs,\n \tiv_ca_delta_free (&act_delta);\n     }\n \n-  if (infinite_cost_p (best_cost))\n+  if (best_cost.infinite_cost_p ())\n     {\n       for (i = 0; i < group->n_map_members; i++)\n \t{\n@@ -6777,7 +6867,7 @@ try_add_cand_for (struct ivopts_data *data, struct iv_ca *ivs,\n \t\t\t\t       iv_ca_cand_for_group (ivs, group),\n \t\t\t\t       cp, act_delta);\n \n-\t  if (compare_costs (act_cost, best_cost) < 0)\n+\t  if (act_cost < best_cost)\n \t    {\n \t      best_cost = act_cost;\n \n@@ -6793,7 +6883,7 @@ try_add_cand_for (struct ivopts_data *data, struct iv_ca *ivs,\n   iv_ca_delta_commit (data, ivs, best_delta, true);\n   iv_ca_delta_free (&best_delta);\n \n-  return !infinite_cost_p (best_cost);\n+  return !best_cost.infinite_cost_p ();\n }\n \n /* Finds an initial assignment of candidates to uses.  */\n@@ -6849,7 +6939,7 @@ try_improve_iv_set (struct ivopts_data *data,\n \t  act_delta = iv_ca_delta_join (act_delta, tmp_delta);\n \t}\n \n-      if (compare_costs (acost, best_cost) < 0)\n+      if (acost < best_cost)\n \t{\n \t  best_cost = acost;\n \t  iv_ca_delta_free (&best_delta);\n@@ -6883,7 +6973,7 @@ try_improve_iv_set (struct ivopts_data *data,\n     }\n \n   iv_ca_delta_commit (data, ivs, best_delta, true);\n-  gcc_assert (compare_costs (best_cost, iv_ca_cost (ivs)) == 0);\n+  gcc_assert (best_cost == iv_ca_cost (ivs));\n   iv_ca_delta_free (&best_delta);\n   return true;\n }\n@@ -6953,7 +7043,7 @@ find_optimal_iv_set (struct ivopts_data *data)\n     }\n \n   /* Choose the one with the best cost.  */\n-  if (compare_costs (origcost, cost) <= 0)\n+  if (origcost <= cost)\n     {\n       if (set)\n \tiv_ca_free (&set);"}]}