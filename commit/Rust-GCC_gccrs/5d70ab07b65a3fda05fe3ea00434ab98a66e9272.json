{"sha": "5d70ab07b65a3fda05fe3ea00434ab98a66e9272", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWQ3MGFiMDdiNjVhM2ZkYTA1ZmUzZWEwMDQzNGFiOThhNjZlOTI3Mg==", "commit": {"author": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2016-11-15T23:03:00Z"}, "committer": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2016-11-15T23:03:00Z"}, "message": "[multiple changes]\n\n2016-11-15  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n\t    Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR libgfortran/51119\n\t* Makefile.am: Add new optimization flags matmul.\n\t* Makefile.in: Regenerate.\n\t* m4/matmul.m4: For the case of all strides = 1, implement a\n\tfast blocked matrix multiply. Fix some whitespace.\n\t* generated/matmul_c10.c: Regenerate.\n\t* generated/matmul_c16.c: Regenerate.\n\t* generated/matmul_c4.c: Regenerate.\n\t* generated/matmul_c8.c: Regenerate.\n\t* generated/matmul_i1.c: Regenerate.\n\t* generated/matmul_i16.c: Regenerate.\n\t* generated/matmul_i2.c: Regenerate.\n\t* generated/matmul_i4.c: Regenerate.\n\t* generated/matmul_i8.c: Regenerate.\n\t* generated/matmul_r10.c: Regenerate.\n\t* generated/matmul_r16.c: Regenerate.\n\t* generated/matmul_r4.c: Regenerate.\n\t* generated/matmul_r8.c: Regenerate.\n\n2016-11-15  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR libgfortran/51119\n\t* gfortran.dg/matmul_12.f90: New test case.\n\nFrom-SVN: r242462", "tree": {"sha": "2043e90433038a86fd6bc5e64566a9569951e672", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2043e90433038a86fd6bc5e64566a9569951e672"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5d70ab07b65a3fda05fe3ea00434ab98a66e9272", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d70ab07b65a3fda05fe3ea00434ab98a66e9272", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d70ab07b65a3fda05fe3ea00434ab98a66e9272", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d70ab07b65a3fda05fe3ea00434ab98a66e9272/comments", "author": null, "committer": null, "parents": [{"sha": "fd0477ca84491b35875ab913f3b607fd33cb1258", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd0477ca84491b35875ab913f3b607fd33cb1258", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd0477ca84491b35875ab913f3b607fd33cb1258"}], "stats": {"total": 5601, "additions": 4463, "deletions": 1138}, "files": [{"sha": "65dac88b2bd8d216436505a12c9e7083e92f53c8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d70ab07b65a3fda05fe3ea00434ab98a66e9272/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d70ab07b65a3fda05fe3ea00434ab98a66e9272/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5d70ab07b65a3fda05fe3ea00434ab98a66e9272", "patch": "@@ -1,3 +1,8 @@\n+2016-11-15  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR libgfortran/51119\n+\t* gfortran.dg/matmul_12.f90: New test case.\n+\n 2016-11-15  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* gcc.target/i386/funcspec-56.inc: New file."}, {"sha": "5badd3f0b11f18a5c85b91b11de370b30910b843", "filename": "gcc/testsuite/gfortran.dg/matmul_12.f90", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d70ab07b65a3fda05fe3ea00434ab98a66e9272/gcc%2Ftestsuite%2Fgfortran.dg%2Fmatmul_12.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d70ab07b65a3fda05fe3ea00434ab98a66e9272/gcc%2Ftestsuite%2Fgfortran.dg%2Fmatmul_12.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fmatmul_12.f90?ref=5d70ab07b65a3fda05fe3ea00434ab98a66e9272", "patch": "@@ -0,0 +1,22 @@\n+! { dg-do run }\n+program main\n+  integer, parameter :: sz=5, su=3\n+  integer, parameter :: l=2\n+  integer, parameter :: u=l-1+su\n+  integer(kind=4), dimension(sz,sz) :: r,a,b\n+  integer :: i,j\n+  do i=1,4\n+     do j=1,4\n+        a(i,j) = i*10+j\n+        b(i,j) = 100+i*10+j\n+     end do\n+  end do\n+  r = -1\n+  b(l:u,l:u) = reshape([(i,i=1,su*su)],[su,su]);\n+  a(l:u,l:u) = reshape([(i,i=1,su*su)],[su,su]);\n+\n+  r(1:su,1:su) = matmul(a(l:u,l:u),b(l:u,l:u))\n+  if (any(reshape(r,[sz*sz]) /= [30, 36, 42, -1, -1, 66, 81, 96, -1, -1,&\n+       & 102, 126, 150, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1])) &\n+       call abort\n+end program main"}, {"sha": "50305af70a881d9667d74b0ed676c07206cfc5ef", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d70ab07b65a3fda05fe3ea00434ab98a66e9272/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d70ab07b65a3fda05fe3ea00434ab98a66e9272/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=5d70ab07b65a3fda05fe3ea00434ab98a66e9272", "patch": "@@ -1,3 +1,25 @@\n+2016-11-15  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n+\t    Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR libgfortran/51119\n+\t* Makefile.am: Add new optimization flags matmul.\n+\t* Makefile.in: Regenerate.\n+\t* m4/matmul.m4: For the case of all strides = 1, implement a\n+\tfast blocked matrix multiply. Fix some whitespace.\n+\t* generated/matmul_c10.c: Regenerate.\n+\t* generated/matmul_c16.c: Regenerate.\n+\t* generated/matmul_c4.c: Regenerate.\n+\t* generated/matmul_c8.c: Regenerate.\n+\t* generated/matmul_i1.c: Regenerate.\n+\t* generated/matmul_i16.c: Regenerate.\n+\t* generated/matmul_i2.c: Regenerate.\n+\t* generated/matmul_i4.c: Regenerate.\n+\t* generated/matmul_i8.c: Regenerate.\n+\t* generated/matmul_r10.c: Regenerate.\n+\t* generated/matmul_r16.c: Regenerate.\n+\t* generated/matmul_r4.c: Regenerate.\n+\t* generated/matmul_r8.c: Regenerate.\n+\n 2016-11-15  Matthias Klose  <doko@ubuntu.com>\n \n \t* configure: Regenerate."}, {"sha": "7f4002dcad48ba0d5a30a02725e38173d4840e62", "filename": "libgfortran/Makefile.am", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d70ab07b65a3fda05fe3ea00434ab98a66e9272/libgfortran%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d70ab07b65a3fda05fe3ea00434ab98a66e9272/libgfortran%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FMakefile.am?ref=5d70ab07b65a3fda05fe3ea00434ab98a66e9272", "patch": "@@ -850,7 +850,7 @@ intrinsics/dprod_r8.f90 \\\n intrinsics/f2c_specifics.F90\n \n # Turn on vectorization and loop unrolling for matmul.\n-$(patsubst %.c,%.lo,$(notdir $(i_matmul_c))): AM_CFLAGS += -ftree-vectorize -funroll-loops\n+$(patsubst %.c,%.lo,$(notdir $(i_matmul_c))): AM_CFLAGS += -ffast-math -fno-protect-parens -fstack-arrays -ftree-vectorize -funroll-loops --param max-unroll-times=4 \n # Logical matmul doesn't vectorize.\n $(patsubst %.c,%.lo,$(notdir $(i_matmull_c))): AM_CFLAGS += -funroll-loops\n "}, {"sha": "c1a37d78c40bb47abb8a45c459b20b82ac77d40f", "filename": "libgfortran/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d70ab07b65a3fda05fe3ea00434ab98a66e9272/libgfortran%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d70ab07b65a3fda05fe3ea00434ab98a66e9272/libgfortran%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FMakefile.in?ref=5d70ab07b65a3fda05fe3ea00434ab98a66e9272", "patch": "@@ -5956,7 +5956,7 @@ uninstall-am: uninstall-cafexeclibLTLIBRARIES \\\n @LIBGFOR_USE_SYMVER_SUN_TRUE@@LIBGFOR_USE_SYMVER_TRUE@\t > $@ || (rm -f $@ ; exit 1)\n \n # Turn on vectorization and loop unrolling for matmul.\n-$(patsubst %.c,%.lo,$(notdir $(i_matmul_c))): AM_CFLAGS += -ftree-vectorize -funroll-loops\n+$(patsubst %.c,%.lo,$(notdir $(i_matmul_c))): AM_CFLAGS += -ffast-math -fno-protect-parens -fstack-arrays -ftree-vectorize -funroll-loops --param max-unroll-times=4 \n # Logical matmul doesn't vectorize.\n $(patsubst %.c,%.lo,$(notdir $(i_matmull_c))): AM_CFLAGS += -funroll-loops\n "}, {"sha": "c784a2630cdfb49478fcf15e87ca012ec12ca328", "filename": "libgfortran/generated/matmul_c10.c", "status": "modified", "additions": 315, "deletions": 81, "changes": 396, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d70ab07b65a3fda05fe3ea00434ab98a66e9272/libgfortran%2Fgenerated%2Fmatmul_c10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d70ab07b65a3fda05fe3ea00434ab98a66e9272/libgfortran%2Fgenerated%2Fmatmul_c10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_c10.c?ref=5d70ab07b65a3fda05fe3ea00434ab98a66e9272", "patch": "@@ -32,7 +32,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #if defined (HAVE_GFC_COMPLEX_10)\n \n /* Prototype for the BLAS ?gemm subroutine, a pointer to which can be\n-   passed to us by the front-end, in which case we'll call it for large\n+   passed to us by the front-end, in which case we call it for large\n    matrices.  */\n \n typedef void (*blas_call)(const char *, const char *, const int *, const int *,\n@@ -99,7 +99,7 @@ matmul_c10 (gfc_array_c10 * const restrict retarray,\n \n    o One-dimensional argument B is implicitly treated as a column matrix\n      dimensioned [count, 1], so ycount=1.\n-  */\n+*/\n \n   if (retarray->base_addr == NULL)\n     {\n@@ -127,47 +127,47 @@ matmul_c10 (gfc_array_c10 * const restrict retarray,\n \t= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_COMPLEX_10));\n       retarray->offset = 0;\n     }\n-    else if (unlikely (compile_options.bounds_check))\n-      {\n-\tindex_type ret_extent, arg_extent;\n-\n-\tif (GFC_DESCRIPTOR_RANK (a) == 1)\n-\t  {\n-\t    arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n-\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t    if (arg_extent != ret_extent)\n-\t      runtime_error (\"Incorrect extent in return array in\"\n-\t\t\t     \" MATMUL intrinsic: is %ld, should be %ld\",\n-\t\t\t     (long int) ret_extent, (long int) arg_extent);\n-\t  }\n-\telse if (GFC_DESCRIPTOR_RANK (b) == 1)\n-\t  {\n-\t    arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n-\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t    if (arg_extent != ret_extent)\n-\t      runtime_error (\"Incorrect extent in return array in\"\n-\t\t\t     \" MATMUL intrinsic: is %ld, should be %ld\",\n-\t\t\t     (long int) ret_extent, (long int) arg_extent);\t    \n-\t  }\n-\telse\n-\t  {\n-\t    arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n-\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t    if (arg_extent != ret_extent)\n-\t      runtime_error (\"Incorrect extent in return array in\"\n-\t\t\t     \" MATMUL intrinsic for dimension 1:\"\n-\t\t\t     \" is %ld, should be %ld\",\n-\t\t\t     (long int) ret_extent, (long int) arg_extent);\n-\n-\t    arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n-\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n-\t    if (arg_extent != ret_extent)\n-\t      runtime_error (\"Incorrect extent in return array in\"\n-\t\t\t     \" MATMUL intrinsic for dimension 2:\"\n-\t\t\t     \" is %ld, should be %ld\",\n-\t\t\t     (long int) ret_extent, (long int) arg_extent);\n-\t  }\n-      }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+      index_type ret_extent, arg_extent;\n+\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 1:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 2:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+    }\n \n \n   if (GFC_DESCRIPTOR_RANK (retarray) == 1)\n@@ -230,61 +230,294 @@ matmul_c10 (gfc_array_c10 * const restrict retarray,\n   bbase = b->base_addr;\n   dest = retarray->base_addr;\n \n-\n-  /* Now that everything is set up, we're performing the multiplication\n+  /* Now that everything is set up, we perform the multiplication\n      itself.  */\n \n #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))\n+#define min(a,b) ((a) <= (b) ? (a) : (b))\n+#define max(a,b) ((a) >= (b) ? (a) : (b))\n \n   if (try_blas && rxstride == 1 && (axstride == 1 || aystride == 1)\n       && (bxstride == 1 || bystride == 1)\n       && (((float) xcount) * ((float) ycount) * ((float) count)\n           > POW3(blas_limit)))\n-  {\n-    const int m = xcount, n = ycount, k = count, ldc = rystride;\n-    const GFC_COMPLEX_10 one = 1, zero = 0;\n-    const int lda = (axstride == 1) ? aystride : axstride,\n-              ldb = (bxstride == 1) ? bystride : bxstride;\n-\n-    if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n-      {\n-        assert (gemm != NULL);\n-        gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m, &n, &k,\n-              &one, abase, &lda, bbase, &ldb, &zero, dest, &ldc, 1, 1);\n-        return;\n-      }\n-  }\n-\n-  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n     {\n-      const GFC_COMPLEX_10 * restrict bbase_y;\n-      GFC_COMPLEX_10 * restrict dest_y;\n-      const GFC_COMPLEX_10 * restrict abase_n;\n-      GFC_COMPLEX_10 bbase_yn;\n+      const int m = xcount, n = ycount, k = count, ldc = rystride;\n+      const GFC_COMPLEX_10 one = 1, zero = 0;\n+      const int lda = (axstride == 1) ? aystride : axstride,\n+\t\tldb = (bxstride == 1) ? bystride : bxstride;\n \n-      if (rystride == xcount)\n-\tmemset (dest, 0, (sizeof (GFC_COMPLEX_10) * xcount * ycount));\n-      else\n+      if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n \t{\n-\t  for (y = 0; y < ycount; y++)\n-\t    for (x = 0; x < xcount; x++)\n-\t      dest[x + y*rystride] = (GFC_COMPLEX_10)0;\n+\t  assert (gemm != NULL);\n+\t  gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m,\n+\t\t&n, &k,\t&one, abase, &lda, bbase, &ldb, &zero, dest,\n+\t\t&ldc, 1, 1);\n+\t  return;\n \t}\n+    }\n \n-      for (y = 0; y < ycount; y++)\n+  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n+    {\n+      /* This block of code implements a tuned matmul, derived from\n+         Superscalar GEMM-based level 3 BLAS,  Beta version 0.1\n+\n+               Bo Kagstrom and Per Ling\n+               Department of Computing Science\n+               Umea University\n+               S-901 87 Umea, Sweden\n+\n+\t from netlib.org, translated to C, and modified for matmul.m4.  */\n+\n+      const GFC_COMPLEX_10 *a, *b;\n+      GFC_COMPLEX_10 *c;\n+      const index_type m = xcount, n = ycount, k = count;\n+\n+      /* System generated locals */\n+      index_type a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset,\n+\t\t i1, i2, i3, i4, i5, i6;\n+\n+      /* Local variables */\n+      GFC_COMPLEX_10 t1[65536], /* was [256][256] */\n+\t\t f11, f12, f21, f22, f31, f32, f41, f42,\n+\t\t f13, f14, f23, f24, f33, f34, f43, f44;\n+      index_type i, j, l, ii, jj, ll;\n+      index_type isec, jsec, lsec, uisec, ujsec, ulsec;\n+\n+      a = abase;\n+      b = bbase;\n+      c = retarray->base_addr;\n+\n+      /* Parameter adjustments */\n+      c_dim1 = rystride;\n+      c_offset = 1 + c_dim1;\n+      c -= c_offset;\n+      a_dim1 = aystride;\n+      a_offset = 1 + a_dim1;\n+      a -= a_offset;\n+      b_dim1 = bystride;\n+      b_offset = 1 + b_dim1;\n+      b -= b_offset;\n+\n+      /* Early exit if possible */\n+      if (m == 0 || n == 0 || k == 0)\n+\treturn;\n+\n+      /* Empty c first.  */\n+      for (j=1; j<=n; j++)\n+\tfor (i=1; i<=m; i++)\n+\t  c[i + j * c_dim1] = (GFC_COMPLEX_10)0;\n+\n+      /* Start turning the crank. */\n+      i1 = n;\n+      for (jj = 1; jj <= i1; jj += 512)\n \t{\n-\t  bbase_y = bbase + y*bystride;\n-\t  dest_y = dest + y*rystride;\n-\t  for (n = 0; n < count; n++)\n+\t  /* Computing MIN */\n+\t  i2 = 512;\n+\t  i3 = n - jj + 1;\n+\t  jsec = min(i2,i3);\n+\t  ujsec = jsec - jsec % 4;\n+\t  i2 = k;\n+\t  for (ll = 1; ll <= i2; ll += 256)\n \t    {\n-\t      abase_n = abase + n*aystride;\n-\t      bbase_yn = bbase_y[n];\n-\t      for (x = 0; x < xcount; x++)\n+\t      /* Computing MIN */\n+\t      i3 = 256;\n+\t      i4 = k - ll + 1;\n+\t      lsec = min(i3,i4);\n+\t      ulsec = lsec - lsec % 2;\n+\n+\t      i3 = m;\n+\t      for (ii = 1; ii <= i3; ii += 256)\n \t\t{\n-\t\t  dest_y[x] += abase_n[x] * bbase_yn;\n+\t\t  /* Computing MIN */\n+\t\t  i4 = 256;\n+\t\t  i5 = m - ii + 1;\n+\t\t  isec = min(i4,i5);\n+\t\t  uisec = isec - isec % 2;\n+\t\t  i4 = ll + ulsec - 1;\n+\t\t  for (l = ll; l <= i4; l += 2)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 2)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + (l + 1) * a_dim1];\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ulsec < lsec)\n+\t\t    {\n+\t\t      i4 = ii + isec - 1;\n+\t\t      for (i = ii; i<= i4; ++i)\n+\t\t\t{\n+\t\t\t  t1[lsec + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t    a[i + (ll + lsec - 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\n+\t\t  uisec = isec - isec % 4;\n+\t\t  i4 = jj + ujsec - 1;\n+\t\t  for (j = jj; j <= i4; j += 4)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 4)\n+\t\t\t{\n+\t\t\t  f11 = c[i + j * c_dim1];\n+\t\t\t  f21 = c[i + 1 + j * c_dim1];\n+\t\t\t  f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t  f22 = c[i + 1 + (j + 1) * c_dim1];\n+\t\t\t  f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t  f23 = c[i + 1 + (j + 2) * c_dim1];\n+\t\t\t  f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t  f24 = c[i + 1 + (j + 3) * c_dim1];\n+\t\t\t  f31 = c[i + 2 + j * c_dim1];\n+\t\t\t  f41 = c[i + 3 + j * c_dim1];\n+\t\t\t  f32 = c[i + 2 + (j + 1) * c_dim1];\n+\t\t\t  f42 = c[i + 3 + (j + 1) * c_dim1];\n+\t\t\t  f33 = c[i + 2 + (j + 2) * c_dim1];\n+\t\t\t  f43 = c[i + 3 + (j + 2) * c_dim1];\n+\t\t\t  f34 = c[i + 2 + (j + 3) * c_dim1];\n+\t\t\t  f44 = c[i + 3 + (j + 3) * c_dim1];\n+\t\t\t  i6 = ll + lsec - 1;\n+\t\t\t  for (l = ll; l <= i6; ++l)\n+\t\t\t    {\n+\t\t\t      f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f22 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f23 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f24 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f32 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f42 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f33 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f43 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f34 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f44 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t    }\n+\t\t\t  c[i + j * c_dim1] = f11;\n+\t\t\t  c[i + 1 + j * c_dim1] = f21;\n+\t\t\t  c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t  c[i + 1 + (j + 1) * c_dim1] = f22;\n+\t\t\t  c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t  c[i + 1 + (j + 2) * c_dim1] = f23;\n+\t\t\t  c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t  c[i + 1 + (j + 3) * c_dim1] = f24;\n+\t\t\t  c[i + 2 + j * c_dim1] = f31;\n+\t\t\t  c[i + 3 + j * c_dim1] = f41;\n+\t\t\t  c[i + 2 + (j + 1) * c_dim1] = f32;\n+\t\t\t  c[i + 3 + (j + 1) * c_dim1] = f42;\n+\t\t\t  c[i + 2 + (j + 2) * c_dim1] = f33;\n+\t\t\t  c[i + 3 + (j + 2) * c_dim1] = f43;\n+\t\t\t  c[i + 2 + (j + 3) * c_dim1] = f34;\n+\t\t\t  c[i + 3 + (j + 3) * c_dim1] = f44;\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t      f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t      f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 1) * b_dim1];\n+\t\t\t\t  f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 2) * b_dim1];\n+\t\t\t\t  f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 3) * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t      c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t      c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ujsec < jsec)\n+\t\t    {\n+\t\t      i4 = jj + jsec - 1;\n+\t\t      for (j = jj + ujsec; j <= i4; ++j)\n+\t\t\t{\n+\t\t\t  i5 = ii + uisec - 1;\n+\t\t\t  for (i = ii; i <= i5; i += 4)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f21 = c[i + 1 + j * c_dim1];\n+\t\t\t      f31 = c[i + 2 + j * c_dim1];\n+\t\t\t      f41 = c[i + 3 + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + 1 + j * c_dim1] = f21;\n+\t\t\t      c[i + 2 + j * c_dim1] = f31;\n+\t\t\t      c[i + 3 + j * c_dim1] = f41;\n+\t\t\t    }\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n \t\t}\n \t    }\n \t}\n+      return;\n     }\n   else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n     {\n@@ -334,7 +567,9 @@ matmul_c10 (gfc_array_c10 * const restrict retarray,\n \tfor (n = 0; n < count; n++)\n \t  for (x = 0; x < xcount; x++)\n \t    /* dest[x,y] += a[x,n] * b[n,y] */\n-\t    dest[x*rxstride + y*rystride] += abase[x*axstride + n*aystride] * bbase[n*bxstride + y*bystride];\n+\t    dest[x*rxstride + y*rystride] +=\n+\t\t\t\t\tabase[x*axstride + n*aystride] *\n+\t\t\t\t\tbbase[n*bxstride + y*bystride];\n     }\n   else if (GFC_DESCRIPTOR_RANK (a) == 1)\n     {\n@@ -372,5 +607,4 @@ matmul_c10 (gfc_array_c10 * const restrict retarray,\n \t}\n     }\n }\n-\n #endif"}, {"sha": "47e1bea729b5353c5f06db0caa2727990f8b8a40", "filename": "libgfortran/generated/matmul_c16.c", "status": "modified", "additions": 315, "deletions": 81, "changes": 396, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d70ab07b65a3fda05fe3ea00434ab98a66e9272/libgfortran%2Fgenerated%2Fmatmul_c16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d70ab07b65a3fda05fe3ea00434ab98a66e9272/libgfortran%2Fgenerated%2Fmatmul_c16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_c16.c?ref=5d70ab07b65a3fda05fe3ea00434ab98a66e9272", "patch": "@@ -32,7 +32,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #if defined (HAVE_GFC_COMPLEX_16)\n \n /* Prototype for the BLAS ?gemm subroutine, a pointer to which can be\n-   passed to us by the front-end, in which case we'll call it for large\n+   passed to us by the front-end, in which case we call it for large\n    matrices.  */\n \n typedef void (*blas_call)(const char *, const char *, const int *, const int *,\n@@ -99,7 +99,7 @@ matmul_c16 (gfc_array_c16 * const restrict retarray,\n \n    o One-dimensional argument B is implicitly treated as a column matrix\n      dimensioned [count, 1], so ycount=1.\n-  */\n+*/\n \n   if (retarray->base_addr == NULL)\n     {\n@@ -127,47 +127,47 @@ matmul_c16 (gfc_array_c16 * const restrict retarray,\n \t= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_COMPLEX_16));\n       retarray->offset = 0;\n     }\n-    else if (unlikely (compile_options.bounds_check))\n-      {\n-\tindex_type ret_extent, arg_extent;\n-\n-\tif (GFC_DESCRIPTOR_RANK (a) == 1)\n-\t  {\n-\t    arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n-\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t    if (arg_extent != ret_extent)\n-\t      runtime_error (\"Incorrect extent in return array in\"\n-\t\t\t     \" MATMUL intrinsic: is %ld, should be %ld\",\n-\t\t\t     (long int) ret_extent, (long int) arg_extent);\n-\t  }\n-\telse if (GFC_DESCRIPTOR_RANK (b) == 1)\n-\t  {\n-\t    arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n-\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t    if (arg_extent != ret_extent)\n-\t      runtime_error (\"Incorrect extent in return array in\"\n-\t\t\t     \" MATMUL intrinsic: is %ld, should be %ld\",\n-\t\t\t     (long int) ret_extent, (long int) arg_extent);\t    \n-\t  }\n-\telse\n-\t  {\n-\t    arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n-\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t    if (arg_extent != ret_extent)\n-\t      runtime_error (\"Incorrect extent in return array in\"\n-\t\t\t     \" MATMUL intrinsic for dimension 1:\"\n-\t\t\t     \" is %ld, should be %ld\",\n-\t\t\t     (long int) ret_extent, (long int) arg_extent);\n-\n-\t    arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n-\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n-\t    if (arg_extent != ret_extent)\n-\t      runtime_error (\"Incorrect extent in return array in\"\n-\t\t\t     \" MATMUL intrinsic for dimension 2:\"\n-\t\t\t     \" is %ld, should be %ld\",\n-\t\t\t     (long int) ret_extent, (long int) arg_extent);\n-\t  }\n-      }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+      index_type ret_extent, arg_extent;\n+\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 1:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 2:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+    }\n \n \n   if (GFC_DESCRIPTOR_RANK (retarray) == 1)\n@@ -230,61 +230,294 @@ matmul_c16 (gfc_array_c16 * const restrict retarray,\n   bbase = b->base_addr;\n   dest = retarray->base_addr;\n \n-\n-  /* Now that everything is set up, we're performing the multiplication\n+  /* Now that everything is set up, we perform the multiplication\n      itself.  */\n \n #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))\n+#define min(a,b) ((a) <= (b) ? (a) : (b))\n+#define max(a,b) ((a) >= (b) ? (a) : (b))\n \n   if (try_blas && rxstride == 1 && (axstride == 1 || aystride == 1)\n       && (bxstride == 1 || bystride == 1)\n       && (((float) xcount) * ((float) ycount) * ((float) count)\n           > POW3(blas_limit)))\n-  {\n-    const int m = xcount, n = ycount, k = count, ldc = rystride;\n-    const GFC_COMPLEX_16 one = 1, zero = 0;\n-    const int lda = (axstride == 1) ? aystride : axstride,\n-              ldb = (bxstride == 1) ? bystride : bxstride;\n-\n-    if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n-      {\n-        assert (gemm != NULL);\n-        gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m, &n, &k,\n-              &one, abase, &lda, bbase, &ldb, &zero, dest, &ldc, 1, 1);\n-        return;\n-      }\n-  }\n-\n-  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n     {\n-      const GFC_COMPLEX_16 * restrict bbase_y;\n-      GFC_COMPLEX_16 * restrict dest_y;\n-      const GFC_COMPLEX_16 * restrict abase_n;\n-      GFC_COMPLEX_16 bbase_yn;\n+      const int m = xcount, n = ycount, k = count, ldc = rystride;\n+      const GFC_COMPLEX_16 one = 1, zero = 0;\n+      const int lda = (axstride == 1) ? aystride : axstride,\n+\t\tldb = (bxstride == 1) ? bystride : bxstride;\n \n-      if (rystride == xcount)\n-\tmemset (dest, 0, (sizeof (GFC_COMPLEX_16) * xcount * ycount));\n-      else\n+      if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n \t{\n-\t  for (y = 0; y < ycount; y++)\n-\t    for (x = 0; x < xcount; x++)\n-\t      dest[x + y*rystride] = (GFC_COMPLEX_16)0;\n+\t  assert (gemm != NULL);\n+\t  gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m,\n+\t\t&n, &k,\t&one, abase, &lda, bbase, &ldb, &zero, dest,\n+\t\t&ldc, 1, 1);\n+\t  return;\n \t}\n+    }\n \n-      for (y = 0; y < ycount; y++)\n+  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n+    {\n+      /* This block of code implements a tuned matmul, derived from\n+         Superscalar GEMM-based level 3 BLAS,  Beta version 0.1\n+\n+               Bo Kagstrom and Per Ling\n+               Department of Computing Science\n+               Umea University\n+               S-901 87 Umea, Sweden\n+\n+\t from netlib.org, translated to C, and modified for matmul.m4.  */\n+\n+      const GFC_COMPLEX_16 *a, *b;\n+      GFC_COMPLEX_16 *c;\n+      const index_type m = xcount, n = ycount, k = count;\n+\n+      /* System generated locals */\n+      index_type a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset,\n+\t\t i1, i2, i3, i4, i5, i6;\n+\n+      /* Local variables */\n+      GFC_COMPLEX_16 t1[65536], /* was [256][256] */\n+\t\t f11, f12, f21, f22, f31, f32, f41, f42,\n+\t\t f13, f14, f23, f24, f33, f34, f43, f44;\n+      index_type i, j, l, ii, jj, ll;\n+      index_type isec, jsec, lsec, uisec, ujsec, ulsec;\n+\n+      a = abase;\n+      b = bbase;\n+      c = retarray->base_addr;\n+\n+      /* Parameter adjustments */\n+      c_dim1 = rystride;\n+      c_offset = 1 + c_dim1;\n+      c -= c_offset;\n+      a_dim1 = aystride;\n+      a_offset = 1 + a_dim1;\n+      a -= a_offset;\n+      b_dim1 = bystride;\n+      b_offset = 1 + b_dim1;\n+      b -= b_offset;\n+\n+      /* Early exit if possible */\n+      if (m == 0 || n == 0 || k == 0)\n+\treturn;\n+\n+      /* Empty c first.  */\n+      for (j=1; j<=n; j++)\n+\tfor (i=1; i<=m; i++)\n+\t  c[i + j * c_dim1] = (GFC_COMPLEX_16)0;\n+\n+      /* Start turning the crank. */\n+      i1 = n;\n+      for (jj = 1; jj <= i1; jj += 512)\n \t{\n-\t  bbase_y = bbase + y*bystride;\n-\t  dest_y = dest + y*rystride;\n-\t  for (n = 0; n < count; n++)\n+\t  /* Computing MIN */\n+\t  i2 = 512;\n+\t  i3 = n - jj + 1;\n+\t  jsec = min(i2,i3);\n+\t  ujsec = jsec - jsec % 4;\n+\t  i2 = k;\n+\t  for (ll = 1; ll <= i2; ll += 256)\n \t    {\n-\t      abase_n = abase + n*aystride;\n-\t      bbase_yn = bbase_y[n];\n-\t      for (x = 0; x < xcount; x++)\n+\t      /* Computing MIN */\n+\t      i3 = 256;\n+\t      i4 = k - ll + 1;\n+\t      lsec = min(i3,i4);\n+\t      ulsec = lsec - lsec % 2;\n+\n+\t      i3 = m;\n+\t      for (ii = 1; ii <= i3; ii += 256)\n \t\t{\n-\t\t  dest_y[x] += abase_n[x] * bbase_yn;\n+\t\t  /* Computing MIN */\n+\t\t  i4 = 256;\n+\t\t  i5 = m - ii + 1;\n+\t\t  isec = min(i4,i5);\n+\t\t  uisec = isec - isec % 2;\n+\t\t  i4 = ll + ulsec - 1;\n+\t\t  for (l = ll; l <= i4; l += 2)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 2)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + (l + 1) * a_dim1];\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ulsec < lsec)\n+\t\t    {\n+\t\t      i4 = ii + isec - 1;\n+\t\t      for (i = ii; i<= i4; ++i)\n+\t\t\t{\n+\t\t\t  t1[lsec + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t    a[i + (ll + lsec - 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\n+\t\t  uisec = isec - isec % 4;\n+\t\t  i4 = jj + ujsec - 1;\n+\t\t  for (j = jj; j <= i4; j += 4)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 4)\n+\t\t\t{\n+\t\t\t  f11 = c[i + j * c_dim1];\n+\t\t\t  f21 = c[i + 1 + j * c_dim1];\n+\t\t\t  f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t  f22 = c[i + 1 + (j + 1) * c_dim1];\n+\t\t\t  f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t  f23 = c[i + 1 + (j + 2) * c_dim1];\n+\t\t\t  f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t  f24 = c[i + 1 + (j + 3) * c_dim1];\n+\t\t\t  f31 = c[i + 2 + j * c_dim1];\n+\t\t\t  f41 = c[i + 3 + j * c_dim1];\n+\t\t\t  f32 = c[i + 2 + (j + 1) * c_dim1];\n+\t\t\t  f42 = c[i + 3 + (j + 1) * c_dim1];\n+\t\t\t  f33 = c[i + 2 + (j + 2) * c_dim1];\n+\t\t\t  f43 = c[i + 3 + (j + 2) * c_dim1];\n+\t\t\t  f34 = c[i + 2 + (j + 3) * c_dim1];\n+\t\t\t  f44 = c[i + 3 + (j + 3) * c_dim1];\n+\t\t\t  i6 = ll + lsec - 1;\n+\t\t\t  for (l = ll; l <= i6; ++l)\n+\t\t\t    {\n+\t\t\t      f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f22 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f23 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f24 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f32 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f42 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f33 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f43 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f34 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f44 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t    }\n+\t\t\t  c[i + j * c_dim1] = f11;\n+\t\t\t  c[i + 1 + j * c_dim1] = f21;\n+\t\t\t  c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t  c[i + 1 + (j + 1) * c_dim1] = f22;\n+\t\t\t  c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t  c[i + 1 + (j + 2) * c_dim1] = f23;\n+\t\t\t  c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t  c[i + 1 + (j + 3) * c_dim1] = f24;\n+\t\t\t  c[i + 2 + j * c_dim1] = f31;\n+\t\t\t  c[i + 3 + j * c_dim1] = f41;\n+\t\t\t  c[i + 2 + (j + 1) * c_dim1] = f32;\n+\t\t\t  c[i + 3 + (j + 1) * c_dim1] = f42;\n+\t\t\t  c[i + 2 + (j + 2) * c_dim1] = f33;\n+\t\t\t  c[i + 3 + (j + 2) * c_dim1] = f43;\n+\t\t\t  c[i + 2 + (j + 3) * c_dim1] = f34;\n+\t\t\t  c[i + 3 + (j + 3) * c_dim1] = f44;\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t      f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t      f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 1) * b_dim1];\n+\t\t\t\t  f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 2) * b_dim1];\n+\t\t\t\t  f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 3) * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t      c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t      c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ujsec < jsec)\n+\t\t    {\n+\t\t      i4 = jj + jsec - 1;\n+\t\t      for (j = jj + ujsec; j <= i4; ++j)\n+\t\t\t{\n+\t\t\t  i5 = ii + uisec - 1;\n+\t\t\t  for (i = ii; i <= i5; i += 4)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f21 = c[i + 1 + j * c_dim1];\n+\t\t\t      f31 = c[i + 2 + j * c_dim1];\n+\t\t\t      f41 = c[i + 3 + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + 1 + j * c_dim1] = f21;\n+\t\t\t      c[i + 2 + j * c_dim1] = f31;\n+\t\t\t      c[i + 3 + j * c_dim1] = f41;\n+\t\t\t    }\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n \t\t}\n \t    }\n \t}\n+      return;\n     }\n   else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n     {\n@@ -334,7 +567,9 @@ matmul_c16 (gfc_array_c16 * const restrict retarray,\n \tfor (n = 0; n < count; n++)\n \t  for (x = 0; x < xcount; x++)\n \t    /* dest[x,y] += a[x,n] * b[n,y] */\n-\t    dest[x*rxstride + y*rystride] += abase[x*axstride + n*aystride] * bbase[n*bxstride + y*bystride];\n+\t    dest[x*rxstride + y*rystride] +=\n+\t\t\t\t\tabase[x*axstride + n*aystride] *\n+\t\t\t\t\tbbase[n*bxstride + y*bystride];\n     }\n   else if (GFC_DESCRIPTOR_RANK (a) == 1)\n     {\n@@ -372,5 +607,4 @@ matmul_c16 (gfc_array_c16 * const restrict retarray,\n \t}\n     }\n }\n-\n #endif"}, {"sha": "4eb18965d91ab4a523e944a0847a7b1e2c4862af", "filename": "libgfortran/generated/matmul_c4.c", "status": "modified", "additions": 315, "deletions": 81, "changes": 396, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d70ab07b65a3fda05fe3ea00434ab98a66e9272/libgfortran%2Fgenerated%2Fmatmul_c4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d70ab07b65a3fda05fe3ea00434ab98a66e9272/libgfortran%2Fgenerated%2Fmatmul_c4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_c4.c?ref=5d70ab07b65a3fda05fe3ea00434ab98a66e9272", "patch": "@@ -32,7 +32,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #if defined (HAVE_GFC_COMPLEX_4)\n \n /* Prototype for the BLAS ?gemm subroutine, a pointer to which can be\n-   passed to us by the front-end, in which case we'll call it for large\n+   passed to us by the front-end, in which case we call it for large\n    matrices.  */\n \n typedef void (*blas_call)(const char *, const char *, const int *, const int *,\n@@ -99,7 +99,7 @@ matmul_c4 (gfc_array_c4 * const restrict retarray,\n \n    o One-dimensional argument B is implicitly treated as a column matrix\n      dimensioned [count, 1], so ycount=1.\n-  */\n+*/\n \n   if (retarray->base_addr == NULL)\n     {\n@@ -127,47 +127,47 @@ matmul_c4 (gfc_array_c4 * const restrict retarray,\n \t= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_COMPLEX_4));\n       retarray->offset = 0;\n     }\n-    else if (unlikely (compile_options.bounds_check))\n-      {\n-\tindex_type ret_extent, arg_extent;\n-\n-\tif (GFC_DESCRIPTOR_RANK (a) == 1)\n-\t  {\n-\t    arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n-\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t    if (arg_extent != ret_extent)\n-\t      runtime_error (\"Incorrect extent in return array in\"\n-\t\t\t     \" MATMUL intrinsic: is %ld, should be %ld\",\n-\t\t\t     (long int) ret_extent, (long int) arg_extent);\n-\t  }\n-\telse if (GFC_DESCRIPTOR_RANK (b) == 1)\n-\t  {\n-\t    arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n-\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t    if (arg_extent != ret_extent)\n-\t      runtime_error (\"Incorrect extent in return array in\"\n-\t\t\t     \" MATMUL intrinsic: is %ld, should be %ld\",\n-\t\t\t     (long int) ret_extent, (long int) arg_extent);\t    \n-\t  }\n-\telse\n-\t  {\n-\t    arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n-\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t    if (arg_extent != ret_extent)\n-\t      runtime_error (\"Incorrect extent in return array in\"\n-\t\t\t     \" MATMUL intrinsic for dimension 1:\"\n-\t\t\t     \" is %ld, should be %ld\",\n-\t\t\t     (long int) ret_extent, (long int) arg_extent);\n-\n-\t    arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n-\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n-\t    if (arg_extent != ret_extent)\n-\t      runtime_error (\"Incorrect extent in return array in\"\n-\t\t\t     \" MATMUL intrinsic for dimension 2:\"\n-\t\t\t     \" is %ld, should be %ld\",\n-\t\t\t     (long int) ret_extent, (long int) arg_extent);\n-\t  }\n-      }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+      index_type ret_extent, arg_extent;\n+\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 1:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 2:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+    }\n \n \n   if (GFC_DESCRIPTOR_RANK (retarray) == 1)\n@@ -230,61 +230,294 @@ matmul_c4 (gfc_array_c4 * const restrict retarray,\n   bbase = b->base_addr;\n   dest = retarray->base_addr;\n \n-\n-  /* Now that everything is set up, we're performing the multiplication\n+  /* Now that everything is set up, we perform the multiplication\n      itself.  */\n \n #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))\n+#define min(a,b) ((a) <= (b) ? (a) : (b))\n+#define max(a,b) ((a) >= (b) ? (a) : (b))\n \n   if (try_blas && rxstride == 1 && (axstride == 1 || aystride == 1)\n       && (bxstride == 1 || bystride == 1)\n       && (((float) xcount) * ((float) ycount) * ((float) count)\n           > POW3(blas_limit)))\n-  {\n-    const int m = xcount, n = ycount, k = count, ldc = rystride;\n-    const GFC_COMPLEX_4 one = 1, zero = 0;\n-    const int lda = (axstride == 1) ? aystride : axstride,\n-              ldb = (bxstride == 1) ? bystride : bxstride;\n-\n-    if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n-      {\n-        assert (gemm != NULL);\n-        gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m, &n, &k,\n-              &one, abase, &lda, bbase, &ldb, &zero, dest, &ldc, 1, 1);\n-        return;\n-      }\n-  }\n-\n-  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n     {\n-      const GFC_COMPLEX_4 * restrict bbase_y;\n-      GFC_COMPLEX_4 * restrict dest_y;\n-      const GFC_COMPLEX_4 * restrict abase_n;\n-      GFC_COMPLEX_4 bbase_yn;\n+      const int m = xcount, n = ycount, k = count, ldc = rystride;\n+      const GFC_COMPLEX_4 one = 1, zero = 0;\n+      const int lda = (axstride == 1) ? aystride : axstride,\n+\t\tldb = (bxstride == 1) ? bystride : bxstride;\n \n-      if (rystride == xcount)\n-\tmemset (dest, 0, (sizeof (GFC_COMPLEX_4) * xcount * ycount));\n-      else\n+      if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n \t{\n-\t  for (y = 0; y < ycount; y++)\n-\t    for (x = 0; x < xcount; x++)\n-\t      dest[x + y*rystride] = (GFC_COMPLEX_4)0;\n+\t  assert (gemm != NULL);\n+\t  gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m,\n+\t\t&n, &k,\t&one, abase, &lda, bbase, &ldb, &zero, dest,\n+\t\t&ldc, 1, 1);\n+\t  return;\n \t}\n+    }\n \n-      for (y = 0; y < ycount; y++)\n+  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n+    {\n+      /* This block of code implements a tuned matmul, derived from\n+         Superscalar GEMM-based level 3 BLAS,  Beta version 0.1\n+\n+               Bo Kagstrom and Per Ling\n+               Department of Computing Science\n+               Umea University\n+               S-901 87 Umea, Sweden\n+\n+\t from netlib.org, translated to C, and modified for matmul.m4.  */\n+\n+      const GFC_COMPLEX_4 *a, *b;\n+      GFC_COMPLEX_4 *c;\n+      const index_type m = xcount, n = ycount, k = count;\n+\n+      /* System generated locals */\n+      index_type a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset,\n+\t\t i1, i2, i3, i4, i5, i6;\n+\n+      /* Local variables */\n+      GFC_COMPLEX_4 t1[65536], /* was [256][256] */\n+\t\t f11, f12, f21, f22, f31, f32, f41, f42,\n+\t\t f13, f14, f23, f24, f33, f34, f43, f44;\n+      index_type i, j, l, ii, jj, ll;\n+      index_type isec, jsec, lsec, uisec, ujsec, ulsec;\n+\n+      a = abase;\n+      b = bbase;\n+      c = retarray->base_addr;\n+\n+      /* Parameter adjustments */\n+      c_dim1 = rystride;\n+      c_offset = 1 + c_dim1;\n+      c -= c_offset;\n+      a_dim1 = aystride;\n+      a_offset = 1 + a_dim1;\n+      a -= a_offset;\n+      b_dim1 = bystride;\n+      b_offset = 1 + b_dim1;\n+      b -= b_offset;\n+\n+      /* Early exit if possible */\n+      if (m == 0 || n == 0 || k == 0)\n+\treturn;\n+\n+      /* Empty c first.  */\n+      for (j=1; j<=n; j++)\n+\tfor (i=1; i<=m; i++)\n+\t  c[i + j * c_dim1] = (GFC_COMPLEX_4)0;\n+\n+      /* Start turning the crank. */\n+      i1 = n;\n+      for (jj = 1; jj <= i1; jj += 512)\n \t{\n-\t  bbase_y = bbase + y*bystride;\n-\t  dest_y = dest + y*rystride;\n-\t  for (n = 0; n < count; n++)\n+\t  /* Computing MIN */\n+\t  i2 = 512;\n+\t  i3 = n - jj + 1;\n+\t  jsec = min(i2,i3);\n+\t  ujsec = jsec - jsec % 4;\n+\t  i2 = k;\n+\t  for (ll = 1; ll <= i2; ll += 256)\n \t    {\n-\t      abase_n = abase + n*aystride;\n-\t      bbase_yn = bbase_y[n];\n-\t      for (x = 0; x < xcount; x++)\n+\t      /* Computing MIN */\n+\t      i3 = 256;\n+\t      i4 = k - ll + 1;\n+\t      lsec = min(i3,i4);\n+\t      ulsec = lsec - lsec % 2;\n+\n+\t      i3 = m;\n+\t      for (ii = 1; ii <= i3; ii += 256)\n \t\t{\n-\t\t  dest_y[x] += abase_n[x] * bbase_yn;\n+\t\t  /* Computing MIN */\n+\t\t  i4 = 256;\n+\t\t  i5 = m - ii + 1;\n+\t\t  isec = min(i4,i5);\n+\t\t  uisec = isec - isec % 2;\n+\t\t  i4 = ll + ulsec - 1;\n+\t\t  for (l = ll; l <= i4; l += 2)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 2)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + (l + 1) * a_dim1];\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ulsec < lsec)\n+\t\t    {\n+\t\t      i4 = ii + isec - 1;\n+\t\t      for (i = ii; i<= i4; ++i)\n+\t\t\t{\n+\t\t\t  t1[lsec + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t    a[i + (ll + lsec - 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\n+\t\t  uisec = isec - isec % 4;\n+\t\t  i4 = jj + ujsec - 1;\n+\t\t  for (j = jj; j <= i4; j += 4)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 4)\n+\t\t\t{\n+\t\t\t  f11 = c[i + j * c_dim1];\n+\t\t\t  f21 = c[i + 1 + j * c_dim1];\n+\t\t\t  f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t  f22 = c[i + 1 + (j + 1) * c_dim1];\n+\t\t\t  f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t  f23 = c[i + 1 + (j + 2) * c_dim1];\n+\t\t\t  f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t  f24 = c[i + 1 + (j + 3) * c_dim1];\n+\t\t\t  f31 = c[i + 2 + j * c_dim1];\n+\t\t\t  f41 = c[i + 3 + j * c_dim1];\n+\t\t\t  f32 = c[i + 2 + (j + 1) * c_dim1];\n+\t\t\t  f42 = c[i + 3 + (j + 1) * c_dim1];\n+\t\t\t  f33 = c[i + 2 + (j + 2) * c_dim1];\n+\t\t\t  f43 = c[i + 3 + (j + 2) * c_dim1];\n+\t\t\t  f34 = c[i + 2 + (j + 3) * c_dim1];\n+\t\t\t  f44 = c[i + 3 + (j + 3) * c_dim1];\n+\t\t\t  i6 = ll + lsec - 1;\n+\t\t\t  for (l = ll; l <= i6; ++l)\n+\t\t\t    {\n+\t\t\t      f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f22 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f23 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f24 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f32 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f42 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f33 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f43 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f34 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f44 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t    }\n+\t\t\t  c[i + j * c_dim1] = f11;\n+\t\t\t  c[i + 1 + j * c_dim1] = f21;\n+\t\t\t  c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t  c[i + 1 + (j + 1) * c_dim1] = f22;\n+\t\t\t  c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t  c[i + 1 + (j + 2) * c_dim1] = f23;\n+\t\t\t  c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t  c[i + 1 + (j + 3) * c_dim1] = f24;\n+\t\t\t  c[i + 2 + j * c_dim1] = f31;\n+\t\t\t  c[i + 3 + j * c_dim1] = f41;\n+\t\t\t  c[i + 2 + (j + 1) * c_dim1] = f32;\n+\t\t\t  c[i + 3 + (j + 1) * c_dim1] = f42;\n+\t\t\t  c[i + 2 + (j + 2) * c_dim1] = f33;\n+\t\t\t  c[i + 3 + (j + 2) * c_dim1] = f43;\n+\t\t\t  c[i + 2 + (j + 3) * c_dim1] = f34;\n+\t\t\t  c[i + 3 + (j + 3) * c_dim1] = f44;\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t      f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t      f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 1) * b_dim1];\n+\t\t\t\t  f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 2) * b_dim1];\n+\t\t\t\t  f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 3) * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t      c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t      c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ujsec < jsec)\n+\t\t    {\n+\t\t      i4 = jj + jsec - 1;\n+\t\t      for (j = jj + ujsec; j <= i4; ++j)\n+\t\t\t{\n+\t\t\t  i5 = ii + uisec - 1;\n+\t\t\t  for (i = ii; i <= i5; i += 4)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f21 = c[i + 1 + j * c_dim1];\n+\t\t\t      f31 = c[i + 2 + j * c_dim1];\n+\t\t\t      f41 = c[i + 3 + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + 1 + j * c_dim1] = f21;\n+\t\t\t      c[i + 2 + j * c_dim1] = f31;\n+\t\t\t      c[i + 3 + j * c_dim1] = f41;\n+\t\t\t    }\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n \t\t}\n \t    }\n \t}\n+      return;\n     }\n   else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n     {\n@@ -334,7 +567,9 @@ matmul_c4 (gfc_array_c4 * const restrict retarray,\n \tfor (n = 0; n < count; n++)\n \t  for (x = 0; x < xcount; x++)\n \t    /* dest[x,y] += a[x,n] * b[n,y] */\n-\t    dest[x*rxstride + y*rystride] += abase[x*axstride + n*aystride] * bbase[n*bxstride + y*bystride];\n+\t    dest[x*rxstride + y*rystride] +=\n+\t\t\t\t\tabase[x*axstride + n*aystride] *\n+\t\t\t\t\tbbase[n*bxstride + y*bystride];\n     }\n   else if (GFC_DESCRIPTOR_RANK (a) == 1)\n     {\n@@ -372,5 +607,4 @@ matmul_c4 (gfc_array_c4 * const restrict retarray,\n \t}\n     }\n }\n-\n #endif"}, {"sha": "2321b9effbd69942cfa7b2fdf63254ef1f4ab54e", "filename": "libgfortran/generated/matmul_c8.c", "status": "modified", "additions": 315, "deletions": 81, "changes": 396, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d70ab07b65a3fda05fe3ea00434ab98a66e9272/libgfortran%2Fgenerated%2Fmatmul_c8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d70ab07b65a3fda05fe3ea00434ab98a66e9272/libgfortran%2Fgenerated%2Fmatmul_c8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_c8.c?ref=5d70ab07b65a3fda05fe3ea00434ab98a66e9272", "patch": "@@ -32,7 +32,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #if defined (HAVE_GFC_COMPLEX_8)\n \n /* Prototype for the BLAS ?gemm subroutine, a pointer to which can be\n-   passed to us by the front-end, in which case we'll call it for large\n+   passed to us by the front-end, in which case we call it for large\n    matrices.  */\n \n typedef void (*blas_call)(const char *, const char *, const int *, const int *,\n@@ -99,7 +99,7 @@ matmul_c8 (gfc_array_c8 * const restrict retarray,\n \n    o One-dimensional argument B is implicitly treated as a column matrix\n      dimensioned [count, 1], so ycount=1.\n-  */\n+*/\n \n   if (retarray->base_addr == NULL)\n     {\n@@ -127,47 +127,47 @@ matmul_c8 (gfc_array_c8 * const restrict retarray,\n \t= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_COMPLEX_8));\n       retarray->offset = 0;\n     }\n-    else if (unlikely (compile_options.bounds_check))\n-      {\n-\tindex_type ret_extent, arg_extent;\n-\n-\tif (GFC_DESCRIPTOR_RANK (a) == 1)\n-\t  {\n-\t    arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n-\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t    if (arg_extent != ret_extent)\n-\t      runtime_error (\"Incorrect extent in return array in\"\n-\t\t\t     \" MATMUL intrinsic: is %ld, should be %ld\",\n-\t\t\t     (long int) ret_extent, (long int) arg_extent);\n-\t  }\n-\telse if (GFC_DESCRIPTOR_RANK (b) == 1)\n-\t  {\n-\t    arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n-\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t    if (arg_extent != ret_extent)\n-\t      runtime_error (\"Incorrect extent in return array in\"\n-\t\t\t     \" MATMUL intrinsic: is %ld, should be %ld\",\n-\t\t\t     (long int) ret_extent, (long int) arg_extent);\t    \n-\t  }\n-\telse\n-\t  {\n-\t    arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n-\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t    if (arg_extent != ret_extent)\n-\t      runtime_error (\"Incorrect extent in return array in\"\n-\t\t\t     \" MATMUL intrinsic for dimension 1:\"\n-\t\t\t     \" is %ld, should be %ld\",\n-\t\t\t     (long int) ret_extent, (long int) arg_extent);\n-\n-\t    arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n-\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n-\t    if (arg_extent != ret_extent)\n-\t      runtime_error (\"Incorrect extent in return array in\"\n-\t\t\t     \" MATMUL intrinsic for dimension 2:\"\n-\t\t\t     \" is %ld, should be %ld\",\n-\t\t\t     (long int) ret_extent, (long int) arg_extent);\n-\t  }\n-      }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+      index_type ret_extent, arg_extent;\n+\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 1:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 2:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+    }\n \n \n   if (GFC_DESCRIPTOR_RANK (retarray) == 1)\n@@ -230,61 +230,294 @@ matmul_c8 (gfc_array_c8 * const restrict retarray,\n   bbase = b->base_addr;\n   dest = retarray->base_addr;\n \n-\n-  /* Now that everything is set up, we're performing the multiplication\n+  /* Now that everything is set up, we perform the multiplication\n      itself.  */\n \n #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))\n+#define min(a,b) ((a) <= (b) ? (a) : (b))\n+#define max(a,b) ((a) >= (b) ? (a) : (b))\n \n   if (try_blas && rxstride == 1 && (axstride == 1 || aystride == 1)\n       && (bxstride == 1 || bystride == 1)\n       && (((float) xcount) * ((float) ycount) * ((float) count)\n           > POW3(blas_limit)))\n-  {\n-    const int m = xcount, n = ycount, k = count, ldc = rystride;\n-    const GFC_COMPLEX_8 one = 1, zero = 0;\n-    const int lda = (axstride == 1) ? aystride : axstride,\n-              ldb = (bxstride == 1) ? bystride : bxstride;\n-\n-    if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n-      {\n-        assert (gemm != NULL);\n-        gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m, &n, &k,\n-              &one, abase, &lda, bbase, &ldb, &zero, dest, &ldc, 1, 1);\n-        return;\n-      }\n-  }\n-\n-  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n     {\n-      const GFC_COMPLEX_8 * restrict bbase_y;\n-      GFC_COMPLEX_8 * restrict dest_y;\n-      const GFC_COMPLEX_8 * restrict abase_n;\n-      GFC_COMPLEX_8 bbase_yn;\n+      const int m = xcount, n = ycount, k = count, ldc = rystride;\n+      const GFC_COMPLEX_8 one = 1, zero = 0;\n+      const int lda = (axstride == 1) ? aystride : axstride,\n+\t\tldb = (bxstride == 1) ? bystride : bxstride;\n \n-      if (rystride == xcount)\n-\tmemset (dest, 0, (sizeof (GFC_COMPLEX_8) * xcount * ycount));\n-      else\n+      if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n \t{\n-\t  for (y = 0; y < ycount; y++)\n-\t    for (x = 0; x < xcount; x++)\n-\t      dest[x + y*rystride] = (GFC_COMPLEX_8)0;\n+\t  assert (gemm != NULL);\n+\t  gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m,\n+\t\t&n, &k,\t&one, abase, &lda, bbase, &ldb, &zero, dest,\n+\t\t&ldc, 1, 1);\n+\t  return;\n \t}\n+    }\n \n-      for (y = 0; y < ycount; y++)\n+  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n+    {\n+      /* This block of code implements a tuned matmul, derived from\n+         Superscalar GEMM-based level 3 BLAS,  Beta version 0.1\n+\n+               Bo Kagstrom and Per Ling\n+               Department of Computing Science\n+               Umea University\n+               S-901 87 Umea, Sweden\n+\n+\t from netlib.org, translated to C, and modified for matmul.m4.  */\n+\n+      const GFC_COMPLEX_8 *a, *b;\n+      GFC_COMPLEX_8 *c;\n+      const index_type m = xcount, n = ycount, k = count;\n+\n+      /* System generated locals */\n+      index_type a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset,\n+\t\t i1, i2, i3, i4, i5, i6;\n+\n+      /* Local variables */\n+      GFC_COMPLEX_8 t1[65536], /* was [256][256] */\n+\t\t f11, f12, f21, f22, f31, f32, f41, f42,\n+\t\t f13, f14, f23, f24, f33, f34, f43, f44;\n+      index_type i, j, l, ii, jj, ll;\n+      index_type isec, jsec, lsec, uisec, ujsec, ulsec;\n+\n+      a = abase;\n+      b = bbase;\n+      c = retarray->base_addr;\n+\n+      /* Parameter adjustments */\n+      c_dim1 = rystride;\n+      c_offset = 1 + c_dim1;\n+      c -= c_offset;\n+      a_dim1 = aystride;\n+      a_offset = 1 + a_dim1;\n+      a -= a_offset;\n+      b_dim1 = bystride;\n+      b_offset = 1 + b_dim1;\n+      b -= b_offset;\n+\n+      /* Early exit if possible */\n+      if (m == 0 || n == 0 || k == 0)\n+\treturn;\n+\n+      /* Empty c first.  */\n+      for (j=1; j<=n; j++)\n+\tfor (i=1; i<=m; i++)\n+\t  c[i + j * c_dim1] = (GFC_COMPLEX_8)0;\n+\n+      /* Start turning the crank. */\n+      i1 = n;\n+      for (jj = 1; jj <= i1; jj += 512)\n \t{\n-\t  bbase_y = bbase + y*bystride;\n-\t  dest_y = dest + y*rystride;\n-\t  for (n = 0; n < count; n++)\n+\t  /* Computing MIN */\n+\t  i2 = 512;\n+\t  i3 = n - jj + 1;\n+\t  jsec = min(i2,i3);\n+\t  ujsec = jsec - jsec % 4;\n+\t  i2 = k;\n+\t  for (ll = 1; ll <= i2; ll += 256)\n \t    {\n-\t      abase_n = abase + n*aystride;\n-\t      bbase_yn = bbase_y[n];\n-\t      for (x = 0; x < xcount; x++)\n+\t      /* Computing MIN */\n+\t      i3 = 256;\n+\t      i4 = k - ll + 1;\n+\t      lsec = min(i3,i4);\n+\t      ulsec = lsec - lsec % 2;\n+\n+\t      i3 = m;\n+\t      for (ii = 1; ii <= i3; ii += 256)\n \t\t{\n-\t\t  dest_y[x] += abase_n[x] * bbase_yn;\n+\t\t  /* Computing MIN */\n+\t\t  i4 = 256;\n+\t\t  i5 = m - ii + 1;\n+\t\t  isec = min(i4,i5);\n+\t\t  uisec = isec - isec % 2;\n+\t\t  i4 = ll + ulsec - 1;\n+\t\t  for (l = ll; l <= i4; l += 2)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 2)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + (l + 1) * a_dim1];\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ulsec < lsec)\n+\t\t    {\n+\t\t      i4 = ii + isec - 1;\n+\t\t      for (i = ii; i<= i4; ++i)\n+\t\t\t{\n+\t\t\t  t1[lsec + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t    a[i + (ll + lsec - 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\n+\t\t  uisec = isec - isec % 4;\n+\t\t  i4 = jj + ujsec - 1;\n+\t\t  for (j = jj; j <= i4; j += 4)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 4)\n+\t\t\t{\n+\t\t\t  f11 = c[i + j * c_dim1];\n+\t\t\t  f21 = c[i + 1 + j * c_dim1];\n+\t\t\t  f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t  f22 = c[i + 1 + (j + 1) * c_dim1];\n+\t\t\t  f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t  f23 = c[i + 1 + (j + 2) * c_dim1];\n+\t\t\t  f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t  f24 = c[i + 1 + (j + 3) * c_dim1];\n+\t\t\t  f31 = c[i + 2 + j * c_dim1];\n+\t\t\t  f41 = c[i + 3 + j * c_dim1];\n+\t\t\t  f32 = c[i + 2 + (j + 1) * c_dim1];\n+\t\t\t  f42 = c[i + 3 + (j + 1) * c_dim1];\n+\t\t\t  f33 = c[i + 2 + (j + 2) * c_dim1];\n+\t\t\t  f43 = c[i + 3 + (j + 2) * c_dim1];\n+\t\t\t  f34 = c[i + 2 + (j + 3) * c_dim1];\n+\t\t\t  f44 = c[i + 3 + (j + 3) * c_dim1];\n+\t\t\t  i6 = ll + lsec - 1;\n+\t\t\t  for (l = ll; l <= i6; ++l)\n+\t\t\t    {\n+\t\t\t      f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f22 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f23 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f24 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f32 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f42 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f33 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f43 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f34 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f44 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t    }\n+\t\t\t  c[i + j * c_dim1] = f11;\n+\t\t\t  c[i + 1 + j * c_dim1] = f21;\n+\t\t\t  c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t  c[i + 1 + (j + 1) * c_dim1] = f22;\n+\t\t\t  c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t  c[i + 1 + (j + 2) * c_dim1] = f23;\n+\t\t\t  c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t  c[i + 1 + (j + 3) * c_dim1] = f24;\n+\t\t\t  c[i + 2 + j * c_dim1] = f31;\n+\t\t\t  c[i + 3 + j * c_dim1] = f41;\n+\t\t\t  c[i + 2 + (j + 1) * c_dim1] = f32;\n+\t\t\t  c[i + 3 + (j + 1) * c_dim1] = f42;\n+\t\t\t  c[i + 2 + (j + 2) * c_dim1] = f33;\n+\t\t\t  c[i + 3 + (j + 2) * c_dim1] = f43;\n+\t\t\t  c[i + 2 + (j + 3) * c_dim1] = f34;\n+\t\t\t  c[i + 3 + (j + 3) * c_dim1] = f44;\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t      f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t      f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 1) * b_dim1];\n+\t\t\t\t  f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 2) * b_dim1];\n+\t\t\t\t  f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 3) * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t      c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t      c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ujsec < jsec)\n+\t\t    {\n+\t\t      i4 = jj + jsec - 1;\n+\t\t      for (j = jj + ujsec; j <= i4; ++j)\n+\t\t\t{\n+\t\t\t  i5 = ii + uisec - 1;\n+\t\t\t  for (i = ii; i <= i5; i += 4)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f21 = c[i + 1 + j * c_dim1];\n+\t\t\t      f31 = c[i + 2 + j * c_dim1];\n+\t\t\t      f41 = c[i + 3 + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + 1 + j * c_dim1] = f21;\n+\t\t\t      c[i + 2 + j * c_dim1] = f31;\n+\t\t\t      c[i + 3 + j * c_dim1] = f41;\n+\t\t\t    }\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n \t\t}\n \t    }\n \t}\n+      return;\n     }\n   else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n     {\n@@ -334,7 +567,9 @@ matmul_c8 (gfc_array_c8 * const restrict retarray,\n \tfor (n = 0; n < count; n++)\n \t  for (x = 0; x < xcount; x++)\n \t    /* dest[x,y] += a[x,n] * b[n,y] */\n-\t    dest[x*rxstride + y*rystride] += abase[x*axstride + n*aystride] * bbase[n*bxstride + y*bystride];\n+\t    dest[x*rxstride + y*rystride] +=\n+\t\t\t\t\tabase[x*axstride + n*aystride] *\n+\t\t\t\t\tbbase[n*bxstride + y*bystride];\n     }\n   else if (GFC_DESCRIPTOR_RANK (a) == 1)\n     {\n@@ -372,5 +607,4 @@ matmul_c8 (gfc_array_c8 * const restrict retarray,\n \t}\n     }\n }\n-\n #endif"}, {"sha": "81c067b2ce1ef1524470ebefe96c3d40f5b899be", "filename": "libgfortran/generated/matmul_i1.c", "status": "modified", "additions": 315, "deletions": 81, "changes": 396, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d70ab07b65a3fda05fe3ea00434ab98a66e9272/libgfortran%2Fgenerated%2Fmatmul_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d70ab07b65a3fda05fe3ea00434ab98a66e9272/libgfortran%2Fgenerated%2Fmatmul_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_i1.c?ref=5d70ab07b65a3fda05fe3ea00434ab98a66e9272", "patch": "@@ -32,7 +32,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #if defined (HAVE_GFC_INTEGER_1)\n \n /* Prototype for the BLAS ?gemm subroutine, a pointer to which can be\n-   passed to us by the front-end, in which case we'll call it for large\n+   passed to us by the front-end, in which case we call it for large\n    matrices.  */\n \n typedef void (*blas_call)(const char *, const char *, const int *, const int *,\n@@ -99,7 +99,7 @@ matmul_i1 (gfc_array_i1 * const restrict retarray,\n \n    o One-dimensional argument B is implicitly treated as a column matrix\n      dimensioned [count, 1], so ycount=1.\n-  */\n+*/\n \n   if (retarray->base_addr == NULL)\n     {\n@@ -127,47 +127,47 @@ matmul_i1 (gfc_array_i1 * const restrict retarray,\n \t= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_INTEGER_1));\n       retarray->offset = 0;\n     }\n-    else if (unlikely (compile_options.bounds_check))\n-      {\n-\tindex_type ret_extent, arg_extent;\n-\n-\tif (GFC_DESCRIPTOR_RANK (a) == 1)\n-\t  {\n-\t    arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n-\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t    if (arg_extent != ret_extent)\n-\t      runtime_error (\"Incorrect extent in return array in\"\n-\t\t\t     \" MATMUL intrinsic: is %ld, should be %ld\",\n-\t\t\t     (long int) ret_extent, (long int) arg_extent);\n-\t  }\n-\telse if (GFC_DESCRIPTOR_RANK (b) == 1)\n-\t  {\n-\t    arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n-\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t    if (arg_extent != ret_extent)\n-\t      runtime_error (\"Incorrect extent in return array in\"\n-\t\t\t     \" MATMUL intrinsic: is %ld, should be %ld\",\n-\t\t\t     (long int) ret_extent, (long int) arg_extent);\t    \n-\t  }\n-\telse\n-\t  {\n-\t    arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n-\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t    if (arg_extent != ret_extent)\n-\t      runtime_error (\"Incorrect extent in return array in\"\n-\t\t\t     \" MATMUL intrinsic for dimension 1:\"\n-\t\t\t     \" is %ld, should be %ld\",\n-\t\t\t     (long int) ret_extent, (long int) arg_extent);\n-\n-\t    arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n-\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n-\t    if (arg_extent != ret_extent)\n-\t      runtime_error (\"Incorrect extent in return array in\"\n-\t\t\t     \" MATMUL intrinsic for dimension 2:\"\n-\t\t\t     \" is %ld, should be %ld\",\n-\t\t\t     (long int) ret_extent, (long int) arg_extent);\n-\t  }\n-      }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+      index_type ret_extent, arg_extent;\n+\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 1:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 2:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+    }\n \n \n   if (GFC_DESCRIPTOR_RANK (retarray) == 1)\n@@ -230,61 +230,294 @@ matmul_i1 (gfc_array_i1 * const restrict retarray,\n   bbase = b->base_addr;\n   dest = retarray->base_addr;\n \n-\n-  /* Now that everything is set up, we're performing the multiplication\n+  /* Now that everything is set up, we perform the multiplication\n      itself.  */\n \n #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))\n+#define min(a,b) ((a) <= (b) ? (a) : (b))\n+#define max(a,b) ((a) >= (b) ? (a) : (b))\n \n   if (try_blas && rxstride == 1 && (axstride == 1 || aystride == 1)\n       && (bxstride == 1 || bystride == 1)\n       && (((float) xcount) * ((float) ycount) * ((float) count)\n           > POW3(blas_limit)))\n-  {\n-    const int m = xcount, n = ycount, k = count, ldc = rystride;\n-    const GFC_INTEGER_1 one = 1, zero = 0;\n-    const int lda = (axstride == 1) ? aystride : axstride,\n-              ldb = (bxstride == 1) ? bystride : bxstride;\n-\n-    if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n-      {\n-        assert (gemm != NULL);\n-        gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m, &n, &k,\n-              &one, abase, &lda, bbase, &ldb, &zero, dest, &ldc, 1, 1);\n-        return;\n-      }\n-  }\n-\n-  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n     {\n-      const GFC_INTEGER_1 * restrict bbase_y;\n-      GFC_INTEGER_1 * restrict dest_y;\n-      const GFC_INTEGER_1 * restrict abase_n;\n-      GFC_INTEGER_1 bbase_yn;\n+      const int m = xcount, n = ycount, k = count, ldc = rystride;\n+      const GFC_INTEGER_1 one = 1, zero = 0;\n+      const int lda = (axstride == 1) ? aystride : axstride,\n+\t\tldb = (bxstride == 1) ? bystride : bxstride;\n \n-      if (rystride == xcount)\n-\tmemset (dest, 0, (sizeof (GFC_INTEGER_1) * xcount * ycount));\n-      else\n+      if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n \t{\n-\t  for (y = 0; y < ycount; y++)\n-\t    for (x = 0; x < xcount; x++)\n-\t      dest[x + y*rystride] = (GFC_INTEGER_1)0;\n+\t  assert (gemm != NULL);\n+\t  gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m,\n+\t\t&n, &k,\t&one, abase, &lda, bbase, &ldb, &zero, dest,\n+\t\t&ldc, 1, 1);\n+\t  return;\n \t}\n+    }\n \n-      for (y = 0; y < ycount; y++)\n+  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n+    {\n+      /* This block of code implements a tuned matmul, derived from\n+         Superscalar GEMM-based level 3 BLAS,  Beta version 0.1\n+\n+               Bo Kagstrom and Per Ling\n+               Department of Computing Science\n+               Umea University\n+               S-901 87 Umea, Sweden\n+\n+\t from netlib.org, translated to C, and modified for matmul.m4.  */\n+\n+      const GFC_INTEGER_1 *a, *b;\n+      GFC_INTEGER_1 *c;\n+      const index_type m = xcount, n = ycount, k = count;\n+\n+      /* System generated locals */\n+      index_type a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset,\n+\t\t i1, i2, i3, i4, i5, i6;\n+\n+      /* Local variables */\n+      GFC_INTEGER_1 t1[65536], /* was [256][256] */\n+\t\t f11, f12, f21, f22, f31, f32, f41, f42,\n+\t\t f13, f14, f23, f24, f33, f34, f43, f44;\n+      index_type i, j, l, ii, jj, ll;\n+      index_type isec, jsec, lsec, uisec, ujsec, ulsec;\n+\n+      a = abase;\n+      b = bbase;\n+      c = retarray->base_addr;\n+\n+      /* Parameter adjustments */\n+      c_dim1 = rystride;\n+      c_offset = 1 + c_dim1;\n+      c -= c_offset;\n+      a_dim1 = aystride;\n+      a_offset = 1 + a_dim1;\n+      a -= a_offset;\n+      b_dim1 = bystride;\n+      b_offset = 1 + b_dim1;\n+      b -= b_offset;\n+\n+      /* Early exit if possible */\n+      if (m == 0 || n == 0 || k == 0)\n+\treturn;\n+\n+      /* Empty c first.  */\n+      for (j=1; j<=n; j++)\n+\tfor (i=1; i<=m; i++)\n+\t  c[i + j * c_dim1] = (GFC_INTEGER_1)0;\n+\n+      /* Start turning the crank. */\n+      i1 = n;\n+      for (jj = 1; jj <= i1; jj += 512)\n \t{\n-\t  bbase_y = bbase + y*bystride;\n-\t  dest_y = dest + y*rystride;\n-\t  for (n = 0; n < count; n++)\n+\t  /* Computing MIN */\n+\t  i2 = 512;\n+\t  i3 = n - jj + 1;\n+\t  jsec = min(i2,i3);\n+\t  ujsec = jsec - jsec % 4;\n+\t  i2 = k;\n+\t  for (ll = 1; ll <= i2; ll += 256)\n \t    {\n-\t      abase_n = abase + n*aystride;\n-\t      bbase_yn = bbase_y[n];\n-\t      for (x = 0; x < xcount; x++)\n+\t      /* Computing MIN */\n+\t      i3 = 256;\n+\t      i4 = k - ll + 1;\n+\t      lsec = min(i3,i4);\n+\t      ulsec = lsec - lsec % 2;\n+\n+\t      i3 = m;\n+\t      for (ii = 1; ii <= i3; ii += 256)\n \t\t{\n-\t\t  dest_y[x] += abase_n[x] * bbase_yn;\n+\t\t  /* Computing MIN */\n+\t\t  i4 = 256;\n+\t\t  i5 = m - ii + 1;\n+\t\t  isec = min(i4,i5);\n+\t\t  uisec = isec - isec % 2;\n+\t\t  i4 = ll + ulsec - 1;\n+\t\t  for (l = ll; l <= i4; l += 2)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 2)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + (l + 1) * a_dim1];\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ulsec < lsec)\n+\t\t    {\n+\t\t      i4 = ii + isec - 1;\n+\t\t      for (i = ii; i<= i4; ++i)\n+\t\t\t{\n+\t\t\t  t1[lsec + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t    a[i + (ll + lsec - 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\n+\t\t  uisec = isec - isec % 4;\n+\t\t  i4 = jj + ujsec - 1;\n+\t\t  for (j = jj; j <= i4; j += 4)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 4)\n+\t\t\t{\n+\t\t\t  f11 = c[i + j * c_dim1];\n+\t\t\t  f21 = c[i + 1 + j * c_dim1];\n+\t\t\t  f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t  f22 = c[i + 1 + (j + 1) * c_dim1];\n+\t\t\t  f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t  f23 = c[i + 1 + (j + 2) * c_dim1];\n+\t\t\t  f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t  f24 = c[i + 1 + (j + 3) * c_dim1];\n+\t\t\t  f31 = c[i + 2 + j * c_dim1];\n+\t\t\t  f41 = c[i + 3 + j * c_dim1];\n+\t\t\t  f32 = c[i + 2 + (j + 1) * c_dim1];\n+\t\t\t  f42 = c[i + 3 + (j + 1) * c_dim1];\n+\t\t\t  f33 = c[i + 2 + (j + 2) * c_dim1];\n+\t\t\t  f43 = c[i + 3 + (j + 2) * c_dim1];\n+\t\t\t  f34 = c[i + 2 + (j + 3) * c_dim1];\n+\t\t\t  f44 = c[i + 3 + (j + 3) * c_dim1];\n+\t\t\t  i6 = ll + lsec - 1;\n+\t\t\t  for (l = ll; l <= i6; ++l)\n+\t\t\t    {\n+\t\t\t      f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f22 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f23 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f24 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f32 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f42 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f33 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f43 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f34 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f44 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t    }\n+\t\t\t  c[i + j * c_dim1] = f11;\n+\t\t\t  c[i + 1 + j * c_dim1] = f21;\n+\t\t\t  c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t  c[i + 1 + (j + 1) * c_dim1] = f22;\n+\t\t\t  c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t  c[i + 1 + (j + 2) * c_dim1] = f23;\n+\t\t\t  c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t  c[i + 1 + (j + 3) * c_dim1] = f24;\n+\t\t\t  c[i + 2 + j * c_dim1] = f31;\n+\t\t\t  c[i + 3 + j * c_dim1] = f41;\n+\t\t\t  c[i + 2 + (j + 1) * c_dim1] = f32;\n+\t\t\t  c[i + 3 + (j + 1) * c_dim1] = f42;\n+\t\t\t  c[i + 2 + (j + 2) * c_dim1] = f33;\n+\t\t\t  c[i + 3 + (j + 2) * c_dim1] = f43;\n+\t\t\t  c[i + 2 + (j + 3) * c_dim1] = f34;\n+\t\t\t  c[i + 3 + (j + 3) * c_dim1] = f44;\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t      f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t      f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 1) * b_dim1];\n+\t\t\t\t  f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 2) * b_dim1];\n+\t\t\t\t  f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 3) * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t      c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t      c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ujsec < jsec)\n+\t\t    {\n+\t\t      i4 = jj + jsec - 1;\n+\t\t      for (j = jj + ujsec; j <= i4; ++j)\n+\t\t\t{\n+\t\t\t  i5 = ii + uisec - 1;\n+\t\t\t  for (i = ii; i <= i5; i += 4)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f21 = c[i + 1 + j * c_dim1];\n+\t\t\t      f31 = c[i + 2 + j * c_dim1];\n+\t\t\t      f41 = c[i + 3 + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + 1 + j * c_dim1] = f21;\n+\t\t\t      c[i + 2 + j * c_dim1] = f31;\n+\t\t\t      c[i + 3 + j * c_dim1] = f41;\n+\t\t\t    }\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n \t\t}\n \t    }\n \t}\n+      return;\n     }\n   else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n     {\n@@ -334,7 +567,9 @@ matmul_i1 (gfc_array_i1 * const restrict retarray,\n \tfor (n = 0; n < count; n++)\n \t  for (x = 0; x < xcount; x++)\n \t    /* dest[x,y] += a[x,n] * b[n,y] */\n-\t    dest[x*rxstride + y*rystride] += abase[x*axstride + n*aystride] * bbase[n*bxstride + y*bystride];\n+\t    dest[x*rxstride + y*rystride] +=\n+\t\t\t\t\tabase[x*axstride + n*aystride] *\n+\t\t\t\t\tbbase[n*bxstride + y*bystride];\n     }\n   else if (GFC_DESCRIPTOR_RANK (a) == 1)\n     {\n@@ -372,5 +607,4 @@ matmul_i1 (gfc_array_i1 * const restrict retarray,\n \t}\n     }\n }\n-\n #endif"}, {"sha": "d1b1761014a263c8adea4a0bedebead061c3679f", "filename": "libgfortran/generated/matmul_i16.c", "status": "modified", "additions": 315, "deletions": 81, "changes": 396, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d70ab07b65a3fda05fe3ea00434ab98a66e9272/libgfortran%2Fgenerated%2Fmatmul_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d70ab07b65a3fda05fe3ea00434ab98a66e9272/libgfortran%2Fgenerated%2Fmatmul_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_i16.c?ref=5d70ab07b65a3fda05fe3ea00434ab98a66e9272", "patch": "@@ -32,7 +32,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #if defined (HAVE_GFC_INTEGER_16)\n \n /* Prototype for the BLAS ?gemm subroutine, a pointer to which can be\n-   passed to us by the front-end, in which case we'll call it for large\n+   passed to us by the front-end, in which case we call it for large\n    matrices.  */\n \n typedef void (*blas_call)(const char *, const char *, const int *, const int *,\n@@ -99,7 +99,7 @@ matmul_i16 (gfc_array_i16 * const restrict retarray,\n \n    o One-dimensional argument B is implicitly treated as a column matrix\n      dimensioned [count, 1], so ycount=1.\n-  */\n+*/\n \n   if (retarray->base_addr == NULL)\n     {\n@@ -127,47 +127,47 @@ matmul_i16 (gfc_array_i16 * const restrict retarray,\n \t= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_INTEGER_16));\n       retarray->offset = 0;\n     }\n-    else if (unlikely (compile_options.bounds_check))\n-      {\n-\tindex_type ret_extent, arg_extent;\n-\n-\tif (GFC_DESCRIPTOR_RANK (a) == 1)\n-\t  {\n-\t    arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n-\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t    if (arg_extent != ret_extent)\n-\t      runtime_error (\"Incorrect extent in return array in\"\n-\t\t\t     \" MATMUL intrinsic: is %ld, should be %ld\",\n-\t\t\t     (long int) ret_extent, (long int) arg_extent);\n-\t  }\n-\telse if (GFC_DESCRIPTOR_RANK (b) == 1)\n-\t  {\n-\t    arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n-\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t    if (arg_extent != ret_extent)\n-\t      runtime_error (\"Incorrect extent in return array in\"\n-\t\t\t     \" MATMUL intrinsic: is %ld, should be %ld\",\n-\t\t\t     (long int) ret_extent, (long int) arg_extent);\t    \n-\t  }\n-\telse\n-\t  {\n-\t    arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n-\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t    if (arg_extent != ret_extent)\n-\t      runtime_error (\"Incorrect extent in return array in\"\n-\t\t\t     \" MATMUL intrinsic for dimension 1:\"\n-\t\t\t     \" is %ld, should be %ld\",\n-\t\t\t     (long int) ret_extent, (long int) arg_extent);\n-\n-\t    arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n-\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n-\t    if (arg_extent != ret_extent)\n-\t      runtime_error (\"Incorrect extent in return array in\"\n-\t\t\t     \" MATMUL intrinsic for dimension 2:\"\n-\t\t\t     \" is %ld, should be %ld\",\n-\t\t\t     (long int) ret_extent, (long int) arg_extent);\n-\t  }\n-      }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+      index_type ret_extent, arg_extent;\n+\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 1:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 2:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+    }\n \n \n   if (GFC_DESCRIPTOR_RANK (retarray) == 1)\n@@ -230,61 +230,294 @@ matmul_i16 (gfc_array_i16 * const restrict retarray,\n   bbase = b->base_addr;\n   dest = retarray->base_addr;\n \n-\n-  /* Now that everything is set up, we're performing the multiplication\n+  /* Now that everything is set up, we perform the multiplication\n      itself.  */\n \n #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))\n+#define min(a,b) ((a) <= (b) ? (a) : (b))\n+#define max(a,b) ((a) >= (b) ? (a) : (b))\n \n   if (try_blas && rxstride == 1 && (axstride == 1 || aystride == 1)\n       && (bxstride == 1 || bystride == 1)\n       && (((float) xcount) * ((float) ycount) * ((float) count)\n           > POW3(blas_limit)))\n-  {\n-    const int m = xcount, n = ycount, k = count, ldc = rystride;\n-    const GFC_INTEGER_16 one = 1, zero = 0;\n-    const int lda = (axstride == 1) ? aystride : axstride,\n-              ldb = (bxstride == 1) ? bystride : bxstride;\n-\n-    if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n-      {\n-        assert (gemm != NULL);\n-        gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m, &n, &k,\n-              &one, abase, &lda, bbase, &ldb, &zero, dest, &ldc, 1, 1);\n-        return;\n-      }\n-  }\n-\n-  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n     {\n-      const GFC_INTEGER_16 * restrict bbase_y;\n-      GFC_INTEGER_16 * restrict dest_y;\n-      const GFC_INTEGER_16 * restrict abase_n;\n-      GFC_INTEGER_16 bbase_yn;\n+      const int m = xcount, n = ycount, k = count, ldc = rystride;\n+      const GFC_INTEGER_16 one = 1, zero = 0;\n+      const int lda = (axstride == 1) ? aystride : axstride,\n+\t\tldb = (bxstride == 1) ? bystride : bxstride;\n \n-      if (rystride == xcount)\n-\tmemset (dest, 0, (sizeof (GFC_INTEGER_16) * xcount * ycount));\n-      else\n+      if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n \t{\n-\t  for (y = 0; y < ycount; y++)\n-\t    for (x = 0; x < xcount; x++)\n-\t      dest[x + y*rystride] = (GFC_INTEGER_16)0;\n+\t  assert (gemm != NULL);\n+\t  gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m,\n+\t\t&n, &k,\t&one, abase, &lda, bbase, &ldb, &zero, dest,\n+\t\t&ldc, 1, 1);\n+\t  return;\n \t}\n+    }\n \n-      for (y = 0; y < ycount; y++)\n+  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n+    {\n+      /* This block of code implements a tuned matmul, derived from\n+         Superscalar GEMM-based level 3 BLAS,  Beta version 0.1\n+\n+               Bo Kagstrom and Per Ling\n+               Department of Computing Science\n+               Umea University\n+               S-901 87 Umea, Sweden\n+\n+\t from netlib.org, translated to C, and modified for matmul.m4.  */\n+\n+      const GFC_INTEGER_16 *a, *b;\n+      GFC_INTEGER_16 *c;\n+      const index_type m = xcount, n = ycount, k = count;\n+\n+      /* System generated locals */\n+      index_type a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset,\n+\t\t i1, i2, i3, i4, i5, i6;\n+\n+      /* Local variables */\n+      GFC_INTEGER_16 t1[65536], /* was [256][256] */\n+\t\t f11, f12, f21, f22, f31, f32, f41, f42,\n+\t\t f13, f14, f23, f24, f33, f34, f43, f44;\n+      index_type i, j, l, ii, jj, ll;\n+      index_type isec, jsec, lsec, uisec, ujsec, ulsec;\n+\n+      a = abase;\n+      b = bbase;\n+      c = retarray->base_addr;\n+\n+      /* Parameter adjustments */\n+      c_dim1 = rystride;\n+      c_offset = 1 + c_dim1;\n+      c -= c_offset;\n+      a_dim1 = aystride;\n+      a_offset = 1 + a_dim1;\n+      a -= a_offset;\n+      b_dim1 = bystride;\n+      b_offset = 1 + b_dim1;\n+      b -= b_offset;\n+\n+      /* Early exit if possible */\n+      if (m == 0 || n == 0 || k == 0)\n+\treturn;\n+\n+      /* Empty c first.  */\n+      for (j=1; j<=n; j++)\n+\tfor (i=1; i<=m; i++)\n+\t  c[i + j * c_dim1] = (GFC_INTEGER_16)0;\n+\n+      /* Start turning the crank. */\n+      i1 = n;\n+      for (jj = 1; jj <= i1; jj += 512)\n \t{\n-\t  bbase_y = bbase + y*bystride;\n-\t  dest_y = dest + y*rystride;\n-\t  for (n = 0; n < count; n++)\n+\t  /* Computing MIN */\n+\t  i2 = 512;\n+\t  i3 = n - jj + 1;\n+\t  jsec = min(i2,i3);\n+\t  ujsec = jsec - jsec % 4;\n+\t  i2 = k;\n+\t  for (ll = 1; ll <= i2; ll += 256)\n \t    {\n-\t      abase_n = abase + n*aystride;\n-\t      bbase_yn = bbase_y[n];\n-\t      for (x = 0; x < xcount; x++)\n+\t      /* Computing MIN */\n+\t      i3 = 256;\n+\t      i4 = k - ll + 1;\n+\t      lsec = min(i3,i4);\n+\t      ulsec = lsec - lsec % 2;\n+\n+\t      i3 = m;\n+\t      for (ii = 1; ii <= i3; ii += 256)\n \t\t{\n-\t\t  dest_y[x] += abase_n[x] * bbase_yn;\n+\t\t  /* Computing MIN */\n+\t\t  i4 = 256;\n+\t\t  i5 = m - ii + 1;\n+\t\t  isec = min(i4,i5);\n+\t\t  uisec = isec - isec % 2;\n+\t\t  i4 = ll + ulsec - 1;\n+\t\t  for (l = ll; l <= i4; l += 2)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 2)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + (l + 1) * a_dim1];\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ulsec < lsec)\n+\t\t    {\n+\t\t      i4 = ii + isec - 1;\n+\t\t      for (i = ii; i<= i4; ++i)\n+\t\t\t{\n+\t\t\t  t1[lsec + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t    a[i + (ll + lsec - 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\n+\t\t  uisec = isec - isec % 4;\n+\t\t  i4 = jj + ujsec - 1;\n+\t\t  for (j = jj; j <= i4; j += 4)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 4)\n+\t\t\t{\n+\t\t\t  f11 = c[i + j * c_dim1];\n+\t\t\t  f21 = c[i + 1 + j * c_dim1];\n+\t\t\t  f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t  f22 = c[i + 1 + (j + 1) * c_dim1];\n+\t\t\t  f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t  f23 = c[i + 1 + (j + 2) * c_dim1];\n+\t\t\t  f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t  f24 = c[i + 1 + (j + 3) * c_dim1];\n+\t\t\t  f31 = c[i + 2 + j * c_dim1];\n+\t\t\t  f41 = c[i + 3 + j * c_dim1];\n+\t\t\t  f32 = c[i + 2 + (j + 1) * c_dim1];\n+\t\t\t  f42 = c[i + 3 + (j + 1) * c_dim1];\n+\t\t\t  f33 = c[i + 2 + (j + 2) * c_dim1];\n+\t\t\t  f43 = c[i + 3 + (j + 2) * c_dim1];\n+\t\t\t  f34 = c[i + 2 + (j + 3) * c_dim1];\n+\t\t\t  f44 = c[i + 3 + (j + 3) * c_dim1];\n+\t\t\t  i6 = ll + lsec - 1;\n+\t\t\t  for (l = ll; l <= i6; ++l)\n+\t\t\t    {\n+\t\t\t      f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f22 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f23 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f24 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f32 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f42 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f33 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f43 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f34 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f44 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t    }\n+\t\t\t  c[i + j * c_dim1] = f11;\n+\t\t\t  c[i + 1 + j * c_dim1] = f21;\n+\t\t\t  c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t  c[i + 1 + (j + 1) * c_dim1] = f22;\n+\t\t\t  c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t  c[i + 1 + (j + 2) * c_dim1] = f23;\n+\t\t\t  c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t  c[i + 1 + (j + 3) * c_dim1] = f24;\n+\t\t\t  c[i + 2 + j * c_dim1] = f31;\n+\t\t\t  c[i + 3 + j * c_dim1] = f41;\n+\t\t\t  c[i + 2 + (j + 1) * c_dim1] = f32;\n+\t\t\t  c[i + 3 + (j + 1) * c_dim1] = f42;\n+\t\t\t  c[i + 2 + (j + 2) * c_dim1] = f33;\n+\t\t\t  c[i + 3 + (j + 2) * c_dim1] = f43;\n+\t\t\t  c[i + 2 + (j + 3) * c_dim1] = f34;\n+\t\t\t  c[i + 3 + (j + 3) * c_dim1] = f44;\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t      f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t      f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 1) * b_dim1];\n+\t\t\t\t  f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 2) * b_dim1];\n+\t\t\t\t  f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 3) * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t      c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t      c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ujsec < jsec)\n+\t\t    {\n+\t\t      i4 = jj + jsec - 1;\n+\t\t      for (j = jj + ujsec; j <= i4; ++j)\n+\t\t\t{\n+\t\t\t  i5 = ii + uisec - 1;\n+\t\t\t  for (i = ii; i <= i5; i += 4)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f21 = c[i + 1 + j * c_dim1];\n+\t\t\t      f31 = c[i + 2 + j * c_dim1];\n+\t\t\t      f41 = c[i + 3 + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + 1 + j * c_dim1] = f21;\n+\t\t\t      c[i + 2 + j * c_dim1] = f31;\n+\t\t\t      c[i + 3 + j * c_dim1] = f41;\n+\t\t\t    }\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n \t\t}\n \t    }\n \t}\n+      return;\n     }\n   else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n     {\n@@ -334,7 +567,9 @@ matmul_i16 (gfc_array_i16 * const restrict retarray,\n \tfor (n = 0; n < count; n++)\n \t  for (x = 0; x < xcount; x++)\n \t    /* dest[x,y] += a[x,n] * b[n,y] */\n-\t    dest[x*rxstride + y*rystride] += abase[x*axstride + n*aystride] * bbase[n*bxstride + y*bystride];\n+\t    dest[x*rxstride + y*rystride] +=\n+\t\t\t\t\tabase[x*axstride + n*aystride] *\n+\t\t\t\t\tbbase[n*bxstride + y*bystride];\n     }\n   else if (GFC_DESCRIPTOR_RANK (a) == 1)\n     {\n@@ -372,5 +607,4 @@ matmul_i16 (gfc_array_i16 * const restrict retarray,\n \t}\n     }\n }\n-\n #endif"}, {"sha": "5a06fcc6a2c0e0f2cc345537cda81d29a0a203f3", "filename": "libgfortran/generated/matmul_i2.c", "status": "modified", "additions": 315, "deletions": 81, "changes": 396, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d70ab07b65a3fda05fe3ea00434ab98a66e9272/libgfortran%2Fgenerated%2Fmatmul_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d70ab07b65a3fda05fe3ea00434ab98a66e9272/libgfortran%2Fgenerated%2Fmatmul_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_i2.c?ref=5d70ab07b65a3fda05fe3ea00434ab98a66e9272", "patch": "@@ -32,7 +32,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #if defined (HAVE_GFC_INTEGER_2)\n \n /* Prototype for the BLAS ?gemm subroutine, a pointer to which can be\n-   passed to us by the front-end, in which case we'll call it for large\n+   passed to us by the front-end, in which case we call it for large\n    matrices.  */\n \n typedef void (*blas_call)(const char *, const char *, const int *, const int *,\n@@ -99,7 +99,7 @@ matmul_i2 (gfc_array_i2 * const restrict retarray,\n \n    o One-dimensional argument B is implicitly treated as a column matrix\n      dimensioned [count, 1], so ycount=1.\n-  */\n+*/\n \n   if (retarray->base_addr == NULL)\n     {\n@@ -127,47 +127,47 @@ matmul_i2 (gfc_array_i2 * const restrict retarray,\n \t= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_INTEGER_2));\n       retarray->offset = 0;\n     }\n-    else if (unlikely (compile_options.bounds_check))\n-      {\n-\tindex_type ret_extent, arg_extent;\n-\n-\tif (GFC_DESCRIPTOR_RANK (a) == 1)\n-\t  {\n-\t    arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n-\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t    if (arg_extent != ret_extent)\n-\t      runtime_error (\"Incorrect extent in return array in\"\n-\t\t\t     \" MATMUL intrinsic: is %ld, should be %ld\",\n-\t\t\t     (long int) ret_extent, (long int) arg_extent);\n-\t  }\n-\telse if (GFC_DESCRIPTOR_RANK (b) == 1)\n-\t  {\n-\t    arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n-\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t    if (arg_extent != ret_extent)\n-\t      runtime_error (\"Incorrect extent in return array in\"\n-\t\t\t     \" MATMUL intrinsic: is %ld, should be %ld\",\n-\t\t\t     (long int) ret_extent, (long int) arg_extent);\t    \n-\t  }\n-\telse\n-\t  {\n-\t    arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n-\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t    if (arg_extent != ret_extent)\n-\t      runtime_error (\"Incorrect extent in return array in\"\n-\t\t\t     \" MATMUL intrinsic for dimension 1:\"\n-\t\t\t     \" is %ld, should be %ld\",\n-\t\t\t     (long int) ret_extent, (long int) arg_extent);\n-\n-\t    arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n-\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n-\t    if (arg_extent != ret_extent)\n-\t      runtime_error (\"Incorrect extent in return array in\"\n-\t\t\t     \" MATMUL intrinsic for dimension 2:\"\n-\t\t\t     \" is %ld, should be %ld\",\n-\t\t\t     (long int) ret_extent, (long int) arg_extent);\n-\t  }\n-      }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+      index_type ret_extent, arg_extent;\n+\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 1:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 2:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+    }\n \n \n   if (GFC_DESCRIPTOR_RANK (retarray) == 1)\n@@ -230,61 +230,294 @@ matmul_i2 (gfc_array_i2 * const restrict retarray,\n   bbase = b->base_addr;\n   dest = retarray->base_addr;\n \n-\n-  /* Now that everything is set up, we're performing the multiplication\n+  /* Now that everything is set up, we perform the multiplication\n      itself.  */\n \n #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))\n+#define min(a,b) ((a) <= (b) ? (a) : (b))\n+#define max(a,b) ((a) >= (b) ? (a) : (b))\n \n   if (try_blas && rxstride == 1 && (axstride == 1 || aystride == 1)\n       && (bxstride == 1 || bystride == 1)\n       && (((float) xcount) * ((float) ycount) * ((float) count)\n           > POW3(blas_limit)))\n-  {\n-    const int m = xcount, n = ycount, k = count, ldc = rystride;\n-    const GFC_INTEGER_2 one = 1, zero = 0;\n-    const int lda = (axstride == 1) ? aystride : axstride,\n-              ldb = (bxstride == 1) ? bystride : bxstride;\n-\n-    if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n-      {\n-        assert (gemm != NULL);\n-        gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m, &n, &k,\n-              &one, abase, &lda, bbase, &ldb, &zero, dest, &ldc, 1, 1);\n-        return;\n-      }\n-  }\n-\n-  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n     {\n-      const GFC_INTEGER_2 * restrict bbase_y;\n-      GFC_INTEGER_2 * restrict dest_y;\n-      const GFC_INTEGER_2 * restrict abase_n;\n-      GFC_INTEGER_2 bbase_yn;\n+      const int m = xcount, n = ycount, k = count, ldc = rystride;\n+      const GFC_INTEGER_2 one = 1, zero = 0;\n+      const int lda = (axstride == 1) ? aystride : axstride,\n+\t\tldb = (bxstride == 1) ? bystride : bxstride;\n \n-      if (rystride == xcount)\n-\tmemset (dest, 0, (sizeof (GFC_INTEGER_2) * xcount * ycount));\n-      else\n+      if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n \t{\n-\t  for (y = 0; y < ycount; y++)\n-\t    for (x = 0; x < xcount; x++)\n-\t      dest[x + y*rystride] = (GFC_INTEGER_2)0;\n+\t  assert (gemm != NULL);\n+\t  gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m,\n+\t\t&n, &k,\t&one, abase, &lda, bbase, &ldb, &zero, dest,\n+\t\t&ldc, 1, 1);\n+\t  return;\n \t}\n+    }\n \n-      for (y = 0; y < ycount; y++)\n+  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n+    {\n+      /* This block of code implements a tuned matmul, derived from\n+         Superscalar GEMM-based level 3 BLAS,  Beta version 0.1\n+\n+               Bo Kagstrom and Per Ling\n+               Department of Computing Science\n+               Umea University\n+               S-901 87 Umea, Sweden\n+\n+\t from netlib.org, translated to C, and modified for matmul.m4.  */\n+\n+      const GFC_INTEGER_2 *a, *b;\n+      GFC_INTEGER_2 *c;\n+      const index_type m = xcount, n = ycount, k = count;\n+\n+      /* System generated locals */\n+      index_type a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset,\n+\t\t i1, i2, i3, i4, i5, i6;\n+\n+      /* Local variables */\n+      GFC_INTEGER_2 t1[65536], /* was [256][256] */\n+\t\t f11, f12, f21, f22, f31, f32, f41, f42,\n+\t\t f13, f14, f23, f24, f33, f34, f43, f44;\n+      index_type i, j, l, ii, jj, ll;\n+      index_type isec, jsec, lsec, uisec, ujsec, ulsec;\n+\n+      a = abase;\n+      b = bbase;\n+      c = retarray->base_addr;\n+\n+      /* Parameter adjustments */\n+      c_dim1 = rystride;\n+      c_offset = 1 + c_dim1;\n+      c -= c_offset;\n+      a_dim1 = aystride;\n+      a_offset = 1 + a_dim1;\n+      a -= a_offset;\n+      b_dim1 = bystride;\n+      b_offset = 1 + b_dim1;\n+      b -= b_offset;\n+\n+      /* Early exit if possible */\n+      if (m == 0 || n == 0 || k == 0)\n+\treturn;\n+\n+      /* Empty c first.  */\n+      for (j=1; j<=n; j++)\n+\tfor (i=1; i<=m; i++)\n+\t  c[i + j * c_dim1] = (GFC_INTEGER_2)0;\n+\n+      /* Start turning the crank. */\n+      i1 = n;\n+      for (jj = 1; jj <= i1; jj += 512)\n \t{\n-\t  bbase_y = bbase + y*bystride;\n-\t  dest_y = dest + y*rystride;\n-\t  for (n = 0; n < count; n++)\n+\t  /* Computing MIN */\n+\t  i2 = 512;\n+\t  i3 = n - jj + 1;\n+\t  jsec = min(i2,i3);\n+\t  ujsec = jsec - jsec % 4;\n+\t  i2 = k;\n+\t  for (ll = 1; ll <= i2; ll += 256)\n \t    {\n-\t      abase_n = abase + n*aystride;\n-\t      bbase_yn = bbase_y[n];\n-\t      for (x = 0; x < xcount; x++)\n+\t      /* Computing MIN */\n+\t      i3 = 256;\n+\t      i4 = k - ll + 1;\n+\t      lsec = min(i3,i4);\n+\t      ulsec = lsec - lsec % 2;\n+\n+\t      i3 = m;\n+\t      for (ii = 1; ii <= i3; ii += 256)\n \t\t{\n-\t\t  dest_y[x] += abase_n[x] * bbase_yn;\n+\t\t  /* Computing MIN */\n+\t\t  i4 = 256;\n+\t\t  i5 = m - ii + 1;\n+\t\t  isec = min(i4,i5);\n+\t\t  uisec = isec - isec % 2;\n+\t\t  i4 = ll + ulsec - 1;\n+\t\t  for (l = ll; l <= i4; l += 2)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 2)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + (l + 1) * a_dim1];\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ulsec < lsec)\n+\t\t    {\n+\t\t      i4 = ii + isec - 1;\n+\t\t      for (i = ii; i<= i4; ++i)\n+\t\t\t{\n+\t\t\t  t1[lsec + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t    a[i + (ll + lsec - 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\n+\t\t  uisec = isec - isec % 4;\n+\t\t  i4 = jj + ujsec - 1;\n+\t\t  for (j = jj; j <= i4; j += 4)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 4)\n+\t\t\t{\n+\t\t\t  f11 = c[i + j * c_dim1];\n+\t\t\t  f21 = c[i + 1 + j * c_dim1];\n+\t\t\t  f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t  f22 = c[i + 1 + (j + 1) * c_dim1];\n+\t\t\t  f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t  f23 = c[i + 1 + (j + 2) * c_dim1];\n+\t\t\t  f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t  f24 = c[i + 1 + (j + 3) * c_dim1];\n+\t\t\t  f31 = c[i + 2 + j * c_dim1];\n+\t\t\t  f41 = c[i + 3 + j * c_dim1];\n+\t\t\t  f32 = c[i + 2 + (j + 1) * c_dim1];\n+\t\t\t  f42 = c[i + 3 + (j + 1) * c_dim1];\n+\t\t\t  f33 = c[i + 2 + (j + 2) * c_dim1];\n+\t\t\t  f43 = c[i + 3 + (j + 2) * c_dim1];\n+\t\t\t  f34 = c[i + 2 + (j + 3) * c_dim1];\n+\t\t\t  f44 = c[i + 3 + (j + 3) * c_dim1];\n+\t\t\t  i6 = ll + lsec - 1;\n+\t\t\t  for (l = ll; l <= i6; ++l)\n+\t\t\t    {\n+\t\t\t      f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f22 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f23 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f24 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f32 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f42 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f33 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f43 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f34 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f44 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t    }\n+\t\t\t  c[i + j * c_dim1] = f11;\n+\t\t\t  c[i + 1 + j * c_dim1] = f21;\n+\t\t\t  c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t  c[i + 1 + (j + 1) * c_dim1] = f22;\n+\t\t\t  c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t  c[i + 1 + (j + 2) * c_dim1] = f23;\n+\t\t\t  c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t  c[i + 1 + (j + 3) * c_dim1] = f24;\n+\t\t\t  c[i + 2 + j * c_dim1] = f31;\n+\t\t\t  c[i + 3 + j * c_dim1] = f41;\n+\t\t\t  c[i + 2 + (j + 1) * c_dim1] = f32;\n+\t\t\t  c[i + 3 + (j + 1) * c_dim1] = f42;\n+\t\t\t  c[i + 2 + (j + 2) * c_dim1] = f33;\n+\t\t\t  c[i + 3 + (j + 2) * c_dim1] = f43;\n+\t\t\t  c[i + 2 + (j + 3) * c_dim1] = f34;\n+\t\t\t  c[i + 3 + (j + 3) * c_dim1] = f44;\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t      f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t      f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 1) * b_dim1];\n+\t\t\t\t  f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 2) * b_dim1];\n+\t\t\t\t  f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 3) * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t      c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t      c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ujsec < jsec)\n+\t\t    {\n+\t\t      i4 = jj + jsec - 1;\n+\t\t      for (j = jj + ujsec; j <= i4; ++j)\n+\t\t\t{\n+\t\t\t  i5 = ii + uisec - 1;\n+\t\t\t  for (i = ii; i <= i5; i += 4)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f21 = c[i + 1 + j * c_dim1];\n+\t\t\t      f31 = c[i + 2 + j * c_dim1];\n+\t\t\t      f41 = c[i + 3 + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + 1 + j * c_dim1] = f21;\n+\t\t\t      c[i + 2 + j * c_dim1] = f31;\n+\t\t\t      c[i + 3 + j * c_dim1] = f41;\n+\t\t\t    }\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n \t\t}\n \t    }\n \t}\n+      return;\n     }\n   else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n     {\n@@ -334,7 +567,9 @@ matmul_i2 (gfc_array_i2 * const restrict retarray,\n \tfor (n = 0; n < count; n++)\n \t  for (x = 0; x < xcount; x++)\n \t    /* dest[x,y] += a[x,n] * b[n,y] */\n-\t    dest[x*rxstride + y*rystride] += abase[x*axstride + n*aystride] * bbase[n*bxstride + y*bystride];\n+\t    dest[x*rxstride + y*rystride] +=\n+\t\t\t\t\tabase[x*axstride + n*aystride] *\n+\t\t\t\t\tbbase[n*bxstride + y*bystride];\n     }\n   else if (GFC_DESCRIPTOR_RANK (a) == 1)\n     {\n@@ -372,5 +607,4 @@ matmul_i2 (gfc_array_i2 * const restrict retarray,\n \t}\n     }\n }\n-\n #endif"}, {"sha": "aee8e4d55d50bcb90c49819c8991b1f42eafad12", "filename": "libgfortran/generated/matmul_i4.c", "status": "modified", "additions": 315, "deletions": 81, "changes": 396, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d70ab07b65a3fda05fe3ea00434ab98a66e9272/libgfortran%2Fgenerated%2Fmatmul_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d70ab07b65a3fda05fe3ea00434ab98a66e9272/libgfortran%2Fgenerated%2Fmatmul_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_i4.c?ref=5d70ab07b65a3fda05fe3ea00434ab98a66e9272", "patch": "@@ -32,7 +32,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #if defined (HAVE_GFC_INTEGER_4)\n \n /* Prototype for the BLAS ?gemm subroutine, a pointer to which can be\n-   passed to us by the front-end, in which case we'll call it for large\n+   passed to us by the front-end, in which case we call it for large\n    matrices.  */\n \n typedef void (*blas_call)(const char *, const char *, const int *, const int *,\n@@ -99,7 +99,7 @@ matmul_i4 (gfc_array_i4 * const restrict retarray,\n \n    o One-dimensional argument B is implicitly treated as a column matrix\n      dimensioned [count, 1], so ycount=1.\n-  */\n+*/\n \n   if (retarray->base_addr == NULL)\n     {\n@@ -127,47 +127,47 @@ matmul_i4 (gfc_array_i4 * const restrict retarray,\n \t= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_INTEGER_4));\n       retarray->offset = 0;\n     }\n-    else if (unlikely (compile_options.bounds_check))\n-      {\n-\tindex_type ret_extent, arg_extent;\n-\n-\tif (GFC_DESCRIPTOR_RANK (a) == 1)\n-\t  {\n-\t    arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n-\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t    if (arg_extent != ret_extent)\n-\t      runtime_error (\"Incorrect extent in return array in\"\n-\t\t\t     \" MATMUL intrinsic: is %ld, should be %ld\",\n-\t\t\t     (long int) ret_extent, (long int) arg_extent);\n-\t  }\n-\telse if (GFC_DESCRIPTOR_RANK (b) == 1)\n-\t  {\n-\t    arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n-\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t    if (arg_extent != ret_extent)\n-\t      runtime_error (\"Incorrect extent in return array in\"\n-\t\t\t     \" MATMUL intrinsic: is %ld, should be %ld\",\n-\t\t\t     (long int) ret_extent, (long int) arg_extent);\t    \n-\t  }\n-\telse\n-\t  {\n-\t    arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n-\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t    if (arg_extent != ret_extent)\n-\t      runtime_error (\"Incorrect extent in return array in\"\n-\t\t\t     \" MATMUL intrinsic for dimension 1:\"\n-\t\t\t     \" is %ld, should be %ld\",\n-\t\t\t     (long int) ret_extent, (long int) arg_extent);\n-\n-\t    arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n-\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n-\t    if (arg_extent != ret_extent)\n-\t      runtime_error (\"Incorrect extent in return array in\"\n-\t\t\t     \" MATMUL intrinsic for dimension 2:\"\n-\t\t\t     \" is %ld, should be %ld\",\n-\t\t\t     (long int) ret_extent, (long int) arg_extent);\n-\t  }\n-      }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+      index_type ret_extent, arg_extent;\n+\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 1:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 2:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+    }\n \n \n   if (GFC_DESCRIPTOR_RANK (retarray) == 1)\n@@ -230,61 +230,294 @@ matmul_i4 (gfc_array_i4 * const restrict retarray,\n   bbase = b->base_addr;\n   dest = retarray->base_addr;\n \n-\n-  /* Now that everything is set up, we're performing the multiplication\n+  /* Now that everything is set up, we perform the multiplication\n      itself.  */\n \n #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))\n+#define min(a,b) ((a) <= (b) ? (a) : (b))\n+#define max(a,b) ((a) >= (b) ? (a) : (b))\n \n   if (try_blas && rxstride == 1 && (axstride == 1 || aystride == 1)\n       && (bxstride == 1 || bystride == 1)\n       && (((float) xcount) * ((float) ycount) * ((float) count)\n           > POW3(blas_limit)))\n-  {\n-    const int m = xcount, n = ycount, k = count, ldc = rystride;\n-    const GFC_INTEGER_4 one = 1, zero = 0;\n-    const int lda = (axstride == 1) ? aystride : axstride,\n-              ldb = (bxstride == 1) ? bystride : bxstride;\n-\n-    if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n-      {\n-        assert (gemm != NULL);\n-        gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m, &n, &k,\n-              &one, abase, &lda, bbase, &ldb, &zero, dest, &ldc, 1, 1);\n-        return;\n-      }\n-  }\n-\n-  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n     {\n-      const GFC_INTEGER_4 * restrict bbase_y;\n-      GFC_INTEGER_4 * restrict dest_y;\n-      const GFC_INTEGER_4 * restrict abase_n;\n-      GFC_INTEGER_4 bbase_yn;\n+      const int m = xcount, n = ycount, k = count, ldc = rystride;\n+      const GFC_INTEGER_4 one = 1, zero = 0;\n+      const int lda = (axstride == 1) ? aystride : axstride,\n+\t\tldb = (bxstride == 1) ? bystride : bxstride;\n \n-      if (rystride == xcount)\n-\tmemset (dest, 0, (sizeof (GFC_INTEGER_4) * xcount * ycount));\n-      else\n+      if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n \t{\n-\t  for (y = 0; y < ycount; y++)\n-\t    for (x = 0; x < xcount; x++)\n-\t      dest[x + y*rystride] = (GFC_INTEGER_4)0;\n+\t  assert (gemm != NULL);\n+\t  gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m,\n+\t\t&n, &k,\t&one, abase, &lda, bbase, &ldb, &zero, dest,\n+\t\t&ldc, 1, 1);\n+\t  return;\n \t}\n+    }\n \n-      for (y = 0; y < ycount; y++)\n+  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n+    {\n+      /* This block of code implements a tuned matmul, derived from\n+         Superscalar GEMM-based level 3 BLAS,  Beta version 0.1\n+\n+               Bo Kagstrom and Per Ling\n+               Department of Computing Science\n+               Umea University\n+               S-901 87 Umea, Sweden\n+\n+\t from netlib.org, translated to C, and modified for matmul.m4.  */\n+\n+      const GFC_INTEGER_4 *a, *b;\n+      GFC_INTEGER_4 *c;\n+      const index_type m = xcount, n = ycount, k = count;\n+\n+      /* System generated locals */\n+      index_type a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset,\n+\t\t i1, i2, i3, i4, i5, i6;\n+\n+      /* Local variables */\n+      GFC_INTEGER_4 t1[65536], /* was [256][256] */\n+\t\t f11, f12, f21, f22, f31, f32, f41, f42,\n+\t\t f13, f14, f23, f24, f33, f34, f43, f44;\n+      index_type i, j, l, ii, jj, ll;\n+      index_type isec, jsec, lsec, uisec, ujsec, ulsec;\n+\n+      a = abase;\n+      b = bbase;\n+      c = retarray->base_addr;\n+\n+      /* Parameter adjustments */\n+      c_dim1 = rystride;\n+      c_offset = 1 + c_dim1;\n+      c -= c_offset;\n+      a_dim1 = aystride;\n+      a_offset = 1 + a_dim1;\n+      a -= a_offset;\n+      b_dim1 = bystride;\n+      b_offset = 1 + b_dim1;\n+      b -= b_offset;\n+\n+      /* Early exit if possible */\n+      if (m == 0 || n == 0 || k == 0)\n+\treturn;\n+\n+      /* Empty c first.  */\n+      for (j=1; j<=n; j++)\n+\tfor (i=1; i<=m; i++)\n+\t  c[i + j * c_dim1] = (GFC_INTEGER_4)0;\n+\n+      /* Start turning the crank. */\n+      i1 = n;\n+      for (jj = 1; jj <= i1; jj += 512)\n \t{\n-\t  bbase_y = bbase + y*bystride;\n-\t  dest_y = dest + y*rystride;\n-\t  for (n = 0; n < count; n++)\n+\t  /* Computing MIN */\n+\t  i2 = 512;\n+\t  i3 = n - jj + 1;\n+\t  jsec = min(i2,i3);\n+\t  ujsec = jsec - jsec % 4;\n+\t  i2 = k;\n+\t  for (ll = 1; ll <= i2; ll += 256)\n \t    {\n-\t      abase_n = abase + n*aystride;\n-\t      bbase_yn = bbase_y[n];\n-\t      for (x = 0; x < xcount; x++)\n+\t      /* Computing MIN */\n+\t      i3 = 256;\n+\t      i4 = k - ll + 1;\n+\t      lsec = min(i3,i4);\n+\t      ulsec = lsec - lsec % 2;\n+\n+\t      i3 = m;\n+\t      for (ii = 1; ii <= i3; ii += 256)\n \t\t{\n-\t\t  dest_y[x] += abase_n[x] * bbase_yn;\n+\t\t  /* Computing MIN */\n+\t\t  i4 = 256;\n+\t\t  i5 = m - ii + 1;\n+\t\t  isec = min(i4,i5);\n+\t\t  uisec = isec - isec % 2;\n+\t\t  i4 = ll + ulsec - 1;\n+\t\t  for (l = ll; l <= i4; l += 2)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 2)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + (l + 1) * a_dim1];\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ulsec < lsec)\n+\t\t    {\n+\t\t      i4 = ii + isec - 1;\n+\t\t      for (i = ii; i<= i4; ++i)\n+\t\t\t{\n+\t\t\t  t1[lsec + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t    a[i + (ll + lsec - 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\n+\t\t  uisec = isec - isec % 4;\n+\t\t  i4 = jj + ujsec - 1;\n+\t\t  for (j = jj; j <= i4; j += 4)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 4)\n+\t\t\t{\n+\t\t\t  f11 = c[i + j * c_dim1];\n+\t\t\t  f21 = c[i + 1 + j * c_dim1];\n+\t\t\t  f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t  f22 = c[i + 1 + (j + 1) * c_dim1];\n+\t\t\t  f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t  f23 = c[i + 1 + (j + 2) * c_dim1];\n+\t\t\t  f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t  f24 = c[i + 1 + (j + 3) * c_dim1];\n+\t\t\t  f31 = c[i + 2 + j * c_dim1];\n+\t\t\t  f41 = c[i + 3 + j * c_dim1];\n+\t\t\t  f32 = c[i + 2 + (j + 1) * c_dim1];\n+\t\t\t  f42 = c[i + 3 + (j + 1) * c_dim1];\n+\t\t\t  f33 = c[i + 2 + (j + 2) * c_dim1];\n+\t\t\t  f43 = c[i + 3 + (j + 2) * c_dim1];\n+\t\t\t  f34 = c[i + 2 + (j + 3) * c_dim1];\n+\t\t\t  f44 = c[i + 3 + (j + 3) * c_dim1];\n+\t\t\t  i6 = ll + lsec - 1;\n+\t\t\t  for (l = ll; l <= i6; ++l)\n+\t\t\t    {\n+\t\t\t      f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f22 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f23 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f24 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f32 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f42 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f33 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f43 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f34 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f44 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t    }\n+\t\t\t  c[i + j * c_dim1] = f11;\n+\t\t\t  c[i + 1 + j * c_dim1] = f21;\n+\t\t\t  c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t  c[i + 1 + (j + 1) * c_dim1] = f22;\n+\t\t\t  c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t  c[i + 1 + (j + 2) * c_dim1] = f23;\n+\t\t\t  c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t  c[i + 1 + (j + 3) * c_dim1] = f24;\n+\t\t\t  c[i + 2 + j * c_dim1] = f31;\n+\t\t\t  c[i + 3 + j * c_dim1] = f41;\n+\t\t\t  c[i + 2 + (j + 1) * c_dim1] = f32;\n+\t\t\t  c[i + 3 + (j + 1) * c_dim1] = f42;\n+\t\t\t  c[i + 2 + (j + 2) * c_dim1] = f33;\n+\t\t\t  c[i + 3 + (j + 2) * c_dim1] = f43;\n+\t\t\t  c[i + 2 + (j + 3) * c_dim1] = f34;\n+\t\t\t  c[i + 3 + (j + 3) * c_dim1] = f44;\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t      f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t      f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 1) * b_dim1];\n+\t\t\t\t  f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 2) * b_dim1];\n+\t\t\t\t  f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 3) * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t      c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t      c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ujsec < jsec)\n+\t\t    {\n+\t\t      i4 = jj + jsec - 1;\n+\t\t      for (j = jj + ujsec; j <= i4; ++j)\n+\t\t\t{\n+\t\t\t  i5 = ii + uisec - 1;\n+\t\t\t  for (i = ii; i <= i5; i += 4)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f21 = c[i + 1 + j * c_dim1];\n+\t\t\t      f31 = c[i + 2 + j * c_dim1];\n+\t\t\t      f41 = c[i + 3 + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + 1 + j * c_dim1] = f21;\n+\t\t\t      c[i + 2 + j * c_dim1] = f31;\n+\t\t\t      c[i + 3 + j * c_dim1] = f41;\n+\t\t\t    }\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n \t\t}\n \t    }\n \t}\n+      return;\n     }\n   else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n     {\n@@ -334,7 +567,9 @@ matmul_i4 (gfc_array_i4 * const restrict retarray,\n \tfor (n = 0; n < count; n++)\n \t  for (x = 0; x < xcount; x++)\n \t    /* dest[x,y] += a[x,n] * b[n,y] */\n-\t    dest[x*rxstride + y*rystride] += abase[x*axstride + n*aystride] * bbase[n*bxstride + y*bystride];\n+\t    dest[x*rxstride + y*rystride] +=\n+\t\t\t\t\tabase[x*axstride + n*aystride] *\n+\t\t\t\t\tbbase[n*bxstride + y*bystride];\n     }\n   else if (GFC_DESCRIPTOR_RANK (a) == 1)\n     {\n@@ -372,5 +607,4 @@ matmul_i4 (gfc_array_i4 * const restrict retarray,\n \t}\n     }\n }\n-\n #endif"}, {"sha": "902b284075137c011cfa2ac5473b1c88c9096e0f", "filename": "libgfortran/generated/matmul_i8.c", "status": "modified", "additions": 315, "deletions": 81, "changes": 396, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d70ab07b65a3fda05fe3ea00434ab98a66e9272/libgfortran%2Fgenerated%2Fmatmul_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d70ab07b65a3fda05fe3ea00434ab98a66e9272/libgfortran%2Fgenerated%2Fmatmul_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_i8.c?ref=5d70ab07b65a3fda05fe3ea00434ab98a66e9272", "patch": "@@ -32,7 +32,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #if defined (HAVE_GFC_INTEGER_8)\n \n /* Prototype for the BLAS ?gemm subroutine, a pointer to which can be\n-   passed to us by the front-end, in which case we'll call it for large\n+   passed to us by the front-end, in which case we call it for large\n    matrices.  */\n \n typedef void (*blas_call)(const char *, const char *, const int *, const int *,\n@@ -99,7 +99,7 @@ matmul_i8 (gfc_array_i8 * const restrict retarray,\n \n    o One-dimensional argument B is implicitly treated as a column matrix\n      dimensioned [count, 1], so ycount=1.\n-  */\n+*/\n \n   if (retarray->base_addr == NULL)\n     {\n@@ -127,47 +127,47 @@ matmul_i8 (gfc_array_i8 * const restrict retarray,\n \t= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_INTEGER_8));\n       retarray->offset = 0;\n     }\n-    else if (unlikely (compile_options.bounds_check))\n-      {\n-\tindex_type ret_extent, arg_extent;\n-\n-\tif (GFC_DESCRIPTOR_RANK (a) == 1)\n-\t  {\n-\t    arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n-\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t    if (arg_extent != ret_extent)\n-\t      runtime_error (\"Incorrect extent in return array in\"\n-\t\t\t     \" MATMUL intrinsic: is %ld, should be %ld\",\n-\t\t\t     (long int) ret_extent, (long int) arg_extent);\n-\t  }\n-\telse if (GFC_DESCRIPTOR_RANK (b) == 1)\n-\t  {\n-\t    arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n-\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t    if (arg_extent != ret_extent)\n-\t      runtime_error (\"Incorrect extent in return array in\"\n-\t\t\t     \" MATMUL intrinsic: is %ld, should be %ld\",\n-\t\t\t     (long int) ret_extent, (long int) arg_extent);\t    \n-\t  }\n-\telse\n-\t  {\n-\t    arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n-\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t    if (arg_extent != ret_extent)\n-\t      runtime_error (\"Incorrect extent in return array in\"\n-\t\t\t     \" MATMUL intrinsic for dimension 1:\"\n-\t\t\t     \" is %ld, should be %ld\",\n-\t\t\t     (long int) ret_extent, (long int) arg_extent);\n-\n-\t    arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n-\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n-\t    if (arg_extent != ret_extent)\n-\t      runtime_error (\"Incorrect extent in return array in\"\n-\t\t\t     \" MATMUL intrinsic for dimension 2:\"\n-\t\t\t     \" is %ld, should be %ld\",\n-\t\t\t     (long int) ret_extent, (long int) arg_extent);\n-\t  }\n-      }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+      index_type ret_extent, arg_extent;\n+\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 1:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 2:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+    }\n \n \n   if (GFC_DESCRIPTOR_RANK (retarray) == 1)\n@@ -230,61 +230,294 @@ matmul_i8 (gfc_array_i8 * const restrict retarray,\n   bbase = b->base_addr;\n   dest = retarray->base_addr;\n \n-\n-  /* Now that everything is set up, we're performing the multiplication\n+  /* Now that everything is set up, we perform the multiplication\n      itself.  */\n \n #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))\n+#define min(a,b) ((a) <= (b) ? (a) : (b))\n+#define max(a,b) ((a) >= (b) ? (a) : (b))\n \n   if (try_blas && rxstride == 1 && (axstride == 1 || aystride == 1)\n       && (bxstride == 1 || bystride == 1)\n       && (((float) xcount) * ((float) ycount) * ((float) count)\n           > POW3(blas_limit)))\n-  {\n-    const int m = xcount, n = ycount, k = count, ldc = rystride;\n-    const GFC_INTEGER_8 one = 1, zero = 0;\n-    const int lda = (axstride == 1) ? aystride : axstride,\n-              ldb = (bxstride == 1) ? bystride : bxstride;\n-\n-    if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n-      {\n-        assert (gemm != NULL);\n-        gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m, &n, &k,\n-              &one, abase, &lda, bbase, &ldb, &zero, dest, &ldc, 1, 1);\n-        return;\n-      }\n-  }\n-\n-  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n     {\n-      const GFC_INTEGER_8 * restrict bbase_y;\n-      GFC_INTEGER_8 * restrict dest_y;\n-      const GFC_INTEGER_8 * restrict abase_n;\n-      GFC_INTEGER_8 bbase_yn;\n+      const int m = xcount, n = ycount, k = count, ldc = rystride;\n+      const GFC_INTEGER_8 one = 1, zero = 0;\n+      const int lda = (axstride == 1) ? aystride : axstride,\n+\t\tldb = (bxstride == 1) ? bystride : bxstride;\n \n-      if (rystride == xcount)\n-\tmemset (dest, 0, (sizeof (GFC_INTEGER_8) * xcount * ycount));\n-      else\n+      if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n \t{\n-\t  for (y = 0; y < ycount; y++)\n-\t    for (x = 0; x < xcount; x++)\n-\t      dest[x + y*rystride] = (GFC_INTEGER_8)0;\n+\t  assert (gemm != NULL);\n+\t  gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m,\n+\t\t&n, &k,\t&one, abase, &lda, bbase, &ldb, &zero, dest,\n+\t\t&ldc, 1, 1);\n+\t  return;\n \t}\n+    }\n \n-      for (y = 0; y < ycount; y++)\n+  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n+    {\n+      /* This block of code implements a tuned matmul, derived from\n+         Superscalar GEMM-based level 3 BLAS,  Beta version 0.1\n+\n+               Bo Kagstrom and Per Ling\n+               Department of Computing Science\n+               Umea University\n+               S-901 87 Umea, Sweden\n+\n+\t from netlib.org, translated to C, and modified for matmul.m4.  */\n+\n+      const GFC_INTEGER_8 *a, *b;\n+      GFC_INTEGER_8 *c;\n+      const index_type m = xcount, n = ycount, k = count;\n+\n+      /* System generated locals */\n+      index_type a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset,\n+\t\t i1, i2, i3, i4, i5, i6;\n+\n+      /* Local variables */\n+      GFC_INTEGER_8 t1[65536], /* was [256][256] */\n+\t\t f11, f12, f21, f22, f31, f32, f41, f42,\n+\t\t f13, f14, f23, f24, f33, f34, f43, f44;\n+      index_type i, j, l, ii, jj, ll;\n+      index_type isec, jsec, lsec, uisec, ujsec, ulsec;\n+\n+      a = abase;\n+      b = bbase;\n+      c = retarray->base_addr;\n+\n+      /* Parameter adjustments */\n+      c_dim1 = rystride;\n+      c_offset = 1 + c_dim1;\n+      c -= c_offset;\n+      a_dim1 = aystride;\n+      a_offset = 1 + a_dim1;\n+      a -= a_offset;\n+      b_dim1 = bystride;\n+      b_offset = 1 + b_dim1;\n+      b -= b_offset;\n+\n+      /* Early exit if possible */\n+      if (m == 0 || n == 0 || k == 0)\n+\treturn;\n+\n+      /* Empty c first.  */\n+      for (j=1; j<=n; j++)\n+\tfor (i=1; i<=m; i++)\n+\t  c[i + j * c_dim1] = (GFC_INTEGER_8)0;\n+\n+      /* Start turning the crank. */\n+      i1 = n;\n+      for (jj = 1; jj <= i1; jj += 512)\n \t{\n-\t  bbase_y = bbase + y*bystride;\n-\t  dest_y = dest + y*rystride;\n-\t  for (n = 0; n < count; n++)\n+\t  /* Computing MIN */\n+\t  i2 = 512;\n+\t  i3 = n - jj + 1;\n+\t  jsec = min(i2,i3);\n+\t  ujsec = jsec - jsec % 4;\n+\t  i2 = k;\n+\t  for (ll = 1; ll <= i2; ll += 256)\n \t    {\n-\t      abase_n = abase + n*aystride;\n-\t      bbase_yn = bbase_y[n];\n-\t      for (x = 0; x < xcount; x++)\n+\t      /* Computing MIN */\n+\t      i3 = 256;\n+\t      i4 = k - ll + 1;\n+\t      lsec = min(i3,i4);\n+\t      ulsec = lsec - lsec % 2;\n+\n+\t      i3 = m;\n+\t      for (ii = 1; ii <= i3; ii += 256)\n \t\t{\n-\t\t  dest_y[x] += abase_n[x] * bbase_yn;\n+\t\t  /* Computing MIN */\n+\t\t  i4 = 256;\n+\t\t  i5 = m - ii + 1;\n+\t\t  isec = min(i4,i5);\n+\t\t  uisec = isec - isec % 2;\n+\t\t  i4 = ll + ulsec - 1;\n+\t\t  for (l = ll; l <= i4; l += 2)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 2)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + (l + 1) * a_dim1];\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ulsec < lsec)\n+\t\t    {\n+\t\t      i4 = ii + isec - 1;\n+\t\t      for (i = ii; i<= i4; ++i)\n+\t\t\t{\n+\t\t\t  t1[lsec + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t    a[i + (ll + lsec - 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\n+\t\t  uisec = isec - isec % 4;\n+\t\t  i4 = jj + ujsec - 1;\n+\t\t  for (j = jj; j <= i4; j += 4)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 4)\n+\t\t\t{\n+\t\t\t  f11 = c[i + j * c_dim1];\n+\t\t\t  f21 = c[i + 1 + j * c_dim1];\n+\t\t\t  f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t  f22 = c[i + 1 + (j + 1) * c_dim1];\n+\t\t\t  f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t  f23 = c[i + 1 + (j + 2) * c_dim1];\n+\t\t\t  f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t  f24 = c[i + 1 + (j + 3) * c_dim1];\n+\t\t\t  f31 = c[i + 2 + j * c_dim1];\n+\t\t\t  f41 = c[i + 3 + j * c_dim1];\n+\t\t\t  f32 = c[i + 2 + (j + 1) * c_dim1];\n+\t\t\t  f42 = c[i + 3 + (j + 1) * c_dim1];\n+\t\t\t  f33 = c[i + 2 + (j + 2) * c_dim1];\n+\t\t\t  f43 = c[i + 3 + (j + 2) * c_dim1];\n+\t\t\t  f34 = c[i + 2 + (j + 3) * c_dim1];\n+\t\t\t  f44 = c[i + 3 + (j + 3) * c_dim1];\n+\t\t\t  i6 = ll + lsec - 1;\n+\t\t\t  for (l = ll; l <= i6; ++l)\n+\t\t\t    {\n+\t\t\t      f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f22 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f23 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f24 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f32 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f42 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f33 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f43 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f34 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f44 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t    }\n+\t\t\t  c[i + j * c_dim1] = f11;\n+\t\t\t  c[i + 1 + j * c_dim1] = f21;\n+\t\t\t  c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t  c[i + 1 + (j + 1) * c_dim1] = f22;\n+\t\t\t  c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t  c[i + 1 + (j + 2) * c_dim1] = f23;\n+\t\t\t  c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t  c[i + 1 + (j + 3) * c_dim1] = f24;\n+\t\t\t  c[i + 2 + j * c_dim1] = f31;\n+\t\t\t  c[i + 3 + j * c_dim1] = f41;\n+\t\t\t  c[i + 2 + (j + 1) * c_dim1] = f32;\n+\t\t\t  c[i + 3 + (j + 1) * c_dim1] = f42;\n+\t\t\t  c[i + 2 + (j + 2) * c_dim1] = f33;\n+\t\t\t  c[i + 3 + (j + 2) * c_dim1] = f43;\n+\t\t\t  c[i + 2 + (j + 3) * c_dim1] = f34;\n+\t\t\t  c[i + 3 + (j + 3) * c_dim1] = f44;\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t      f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t      f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 1) * b_dim1];\n+\t\t\t\t  f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 2) * b_dim1];\n+\t\t\t\t  f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 3) * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t      c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t      c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ujsec < jsec)\n+\t\t    {\n+\t\t      i4 = jj + jsec - 1;\n+\t\t      for (j = jj + ujsec; j <= i4; ++j)\n+\t\t\t{\n+\t\t\t  i5 = ii + uisec - 1;\n+\t\t\t  for (i = ii; i <= i5; i += 4)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f21 = c[i + 1 + j * c_dim1];\n+\t\t\t      f31 = c[i + 2 + j * c_dim1];\n+\t\t\t      f41 = c[i + 3 + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + 1 + j * c_dim1] = f21;\n+\t\t\t      c[i + 2 + j * c_dim1] = f31;\n+\t\t\t      c[i + 3 + j * c_dim1] = f41;\n+\t\t\t    }\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n \t\t}\n \t    }\n \t}\n+      return;\n     }\n   else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n     {\n@@ -334,7 +567,9 @@ matmul_i8 (gfc_array_i8 * const restrict retarray,\n \tfor (n = 0; n < count; n++)\n \t  for (x = 0; x < xcount; x++)\n \t    /* dest[x,y] += a[x,n] * b[n,y] */\n-\t    dest[x*rxstride + y*rystride] += abase[x*axstride + n*aystride] * bbase[n*bxstride + y*bystride];\n+\t    dest[x*rxstride + y*rystride] +=\n+\t\t\t\t\tabase[x*axstride + n*aystride] *\n+\t\t\t\t\tbbase[n*bxstride + y*bystride];\n     }\n   else if (GFC_DESCRIPTOR_RANK (a) == 1)\n     {\n@@ -372,5 +607,4 @@ matmul_i8 (gfc_array_i8 * const restrict retarray,\n \t}\n     }\n }\n-\n #endif"}, {"sha": "8bb1e6297bb35b871417b86da6a85aa743e01a5a", "filename": "libgfortran/generated/matmul_r10.c", "status": "modified", "additions": 315, "deletions": 81, "changes": 396, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d70ab07b65a3fda05fe3ea00434ab98a66e9272/libgfortran%2Fgenerated%2Fmatmul_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d70ab07b65a3fda05fe3ea00434ab98a66e9272/libgfortran%2Fgenerated%2Fmatmul_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_r10.c?ref=5d70ab07b65a3fda05fe3ea00434ab98a66e9272", "patch": "@@ -32,7 +32,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #if defined (HAVE_GFC_REAL_10)\n \n /* Prototype for the BLAS ?gemm subroutine, a pointer to which can be\n-   passed to us by the front-end, in which case we'll call it for large\n+   passed to us by the front-end, in which case we call it for large\n    matrices.  */\n \n typedef void (*blas_call)(const char *, const char *, const int *, const int *,\n@@ -99,7 +99,7 @@ matmul_r10 (gfc_array_r10 * const restrict retarray,\n \n    o One-dimensional argument B is implicitly treated as a column matrix\n      dimensioned [count, 1], so ycount=1.\n-  */\n+*/\n \n   if (retarray->base_addr == NULL)\n     {\n@@ -127,47 +127,47 @@ matmul_r10 (gfc_array_r10 * const restrict retarray,\n \t= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_REAL_10));\n       retarray->offset = 0;\n     }\n-    else if (unlikely (compile_options.bounds_check))\n-      {\n-\tindex_type ret_extent, arg_extent;\n-\n-\tif (GFC_DESCRIPTOR_RANK (a) == 1)\n-\t  {\n-\t    arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n-\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t    if (arg_extent != ret_extent)\n-\t      runtime_error (\"Incorrect extent in return array in\"\n-\t\t\t     \" MATMUL intrinsic: is %ld, should be %ld\",\n-\t\t\t     (long int) ret_extent, (long int) arg_extent);\n-\t  }\n-\telse if (GFC_DESCRIPTOR_RANK (b) == 1)\n-\t  {\n-\t    arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n-\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t    if (arg_extent != ret_extent)\n-\t      runtime_error (\"Incorrect extent in return array in\"\n-\t\t\t     \" MATMUL intrinsic: is %ld, should be %ld\",\n-\t\t\t     (long int) ret_extent, (long int) arg_extent);\t    \n-\t  }\n-\telse\n-\t  {\n-\t    arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n-\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t    if (arg_extent != ret_extent)\n-\t      runtime_error (\"Incorrect extent in return array in\"\n-\t\t\t     \" MATMUL intrinsic for dimension 1:\"\n-\t\t\t     \" is %ld, should be %ld\",\n-\t\t\t     (long int) ret_extent, (long int) arg_extent);\n-\n-\t    arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n-\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n-\t    if (arg_extent != ret_extent)\n-\t      runtime_error (\"Incorrect extent in return array in\"\n-\t\t\t     \" MATMUL intrinsic for dimension 2:\"\n-\t\t\t     \" is %ld, should be %ld\",\n-\t\t\t     (long int) ret_extent, (long int) arg_extent);\n-\t  }\n-      }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+      index_type ret_extent, arg_extent;\n+\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 1:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 2:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+    }\n \n \n   if (GFC_DESCRIPTOR_RANK (retarray) == 1)\n@@ -230,61 +230,294 @@ matmul_r10 (gfc_array_r10 * const restrict retarray,\n   bbase = b->base_addr;\n   dest = retarray->base_addr;\n \n-\n-  /* Now that everything is set up, we're performing the multiplication\n+  /* Now that everything is set up, we perform the multiplication\n      itself.  */\n \n #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))\n+#define min(a,b) ((a) <= (b) ? (a) : (b))\n+#define max(a,b) ((a) >= (b) ? (a) : (b))\n \n   if (try_blas && rxstride == 1 && (axstride == 1 || aystride == 1)\n       && (bxstride == 1 || bystride == 1)\n       && (((float) xcount) * ((float) ycount) * ((float) count)\n           > POW3(blas_limit)))\n-  {\n-    const int m = xcount, n = ycount, k = count, ldc = rystride;\n-    const GFC_REAL_10 one = 1, zero = 0;\n-    const int lda = (axstride == 1) ? aystride : axstride,\n-              ldb = (bxstride == 1) ? bystride : bxstride;\n-\n-    if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n-      {\n-        assert (gemm != NULL);\n-        gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m, &n, &k,\n-              &one, abase, &lda, bbase, &ldb, &zero, dest, &ldc, 1, 1);\n-        return;\n-      }\n-  }\n-\n-  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n     {\n-      const GFC_REAL_10 * restrict bbase_y;\n-      GFC_REAL_10 * restrict dest_y;\n-      const GFC_REAL_10 * restrict abase_n;\n-      GFC_REAL_10 bbase_yn;\n+      const int m = xcount, n = ycount, k = count, ldc = rystride;\n+      const GFC_REAL_10 one = 1, zero = 0;\n+      const int lda = (axstride == 1) ? aystride : axstride,\n+\t\tldb = (bxstride == 1) ? bystride : bxstride;\n \n-      if (rystride == xcount)\n-\tmemset (dest, 0, (sizeof (GFC_REAL_10) * xcount * ycount));\n-      else\n+      if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n \t{\n-\t  for (y = 0; y < ycount; y++)\n-\t    for (x = 0; x < xcount; x++)\n-\t      dest[x + y*rystride] = (GFC_REAL_10)0;\n+\t  assert (gemm != NULL);\n+\t  gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m,\n+\t\t&n, &k,\t&one, abase, &lda, bbase, &ldb, &zero, dest,\n+\t\t&ldc, 1, 1);\n+\t  return;\n \t}\n+    }\n \n-      for (y = 0; y < ycount; y++)\n+  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n+    {\n+      /* This block of code implements a tuned matmul, derived from\n+         Superscalar GEMM-based level 3 BLAS,  Beta version 0.1\n+\n+               Bo Kagstrom and Per Ling\n+               Department of Computing Science\n+               Umea University\n+               S-901 87 Umea, Sweden\n+\n+\t from netlib.org, translated to C, and modified for matmul.m4.  */\n+\n+      const GFC_REAL_10 *a, *b;\n+      GFC_REAL_10 *c;\n+      const index_type m = xcount, n = ycount, k = count;\n+\n+      /* System generated locals */\n+      index_type a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset,\n+\t\t i1, i2, i3, i4, i5, i6;\n+\n+      /* Local variables */\n+      GFC_REAL_10 t1[65536], /* was [256][256] */\n+\t\t f11, f12, f21, f22, f31, f32, f41, f42,\n+\t\t f13, f14, f23, f24, f33, f34, f43, f44;\n+      index_type i, j, l, ii, jj, ll;\n+      index_type isec, jsec, lsec, uisec, ujsec, ulsec;\n+\n+      a = abase;\n+      b = bbase;\n+      c = retarray->base_addr;\n+\n+      /* Parameter adjustments */\n+      c_dim1 = rystride;\n+      c_offset = 1 + c_dim1;\n+      c -= c_offset;\n+      a_dim1 = aystride;\n+      a_offset = 1 + a_dim1;\n+      a -= a_offset;\n+      b_dim1 = bystride;\n+      b_offset = 1 + b_dim1;\n+      b -= b_offset;\n+\n+      /* Early exit if possible */\n+      if (m == 0 || n == 0 || k == 0)\n+\treturn;\n+\n+      /* Empty c first.  */\n+      for (j=1; j<=n; j++)\n+\tfor (i=1; i<=m; i++)\n+\t  c[i + j * c_dim1] = (GFC_REAL_10)0;\n+\n+      /* Start turning the crank. */\n+      i1 = n;\n+      for (jj = 1; jj <= i1; jj += 512)\n \t{\n-\t  bbase_y = bbase + y*bystride;\n-\t  dest_y = dest + y*rystride;\n-\t  for (n = 0; n < count; n++)\n+\t  /* Computing MIN */\n+\t  i2 = 512;\n+\t  i3 = n - jj + 1;\n+\t  jsec = min(i2,i3);\n+\t  ujsec = jsec - jsec % 4;\n+\t  i2 = k;\n+\t  for (ll = 1; ll <= i2; ll += 256)\n \t    {\n-\t      abase_n = abase + n*aystride;\n-\t      bbase_yn = bbase_y[n];\n-\t      for (x = 0; x < xcount; x++)\n+\t      /* Computing MIN */\n+\t      i3 = 256;\n+\t      i4 = k - ll + 1;\n+\t      lsec = min(i3,i4);\n+\t      ulsec = lsec - lsec % 2;\n+\n+\t      i3 = m;\n+\t      for (ii = 1; ii <= i3; ii += 256)\n \t\t{\n-\t\t  dest_y[x] += abase_n[x] * bbase_yn;\n+\t\t  /* Computing MIN */\n+\t\t  i4 = 256;\n+\t\t  i5 = m - ii + 1;\n+\t\t  isec = min(i4,i5);\n+\t\t  uisec = isec - isec % 2;\n+\t\t  i4 = ll + ulsec - 1;\n+\t\t  for (l = ll; l <= i4; l += 2)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 2)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + (l + 1) * a_dim1];\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ulsec < lsec)\n+\t\t    {\n+\t\t      i4 = ii + isec - 1;\n+\t\t      for (i = ii; i<= i4; ++i)\n+\t\t\t{\n+\t\t\t  t1[lsec + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t    a[i + (ll + lsec - 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\n+\t\t  uisec = isec - isec % 4;\n+\t\t  i4 = jj + ujsec - 1;\n+\t\t  for (j = jj; j <= i4; j += 4)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 4)\n+\t\t\t{\n+\t\t\t  f11 = c[i + j * c_dim1];\n+\t\t\t  f21 = c[i + 1 + j * c_dim1];\n+\t\t\t  f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t  f22 = c[i + 1 + (j + 1) * c_dim1];\n+\t\t\t  f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t  f23 = c[i + 1 + (j + 2) * c_dim1];\n+\t\t\t  f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t  f24 = c[i + 1 + (j + 3) * c_dim1];\n+\t\t\t  f31 = c[i + 2 + j * c_dim1];\n+\t\t\t  f41 = c[i + 3 + j * c_dim1];\n+\t\t\t  f32 = c[i + 2 + (j + 1) * c_dim1];\n+\t\t\t  f42 = c[i + 3 + (j + 1) * c_dim1];\n+\t\t\t  f33 = c[i + 2 + (j + 2) * c_dim1];\n+\t\t\t  f43 = c[i + 3 + (j + 2) * c_dim1];\n+\t\t\t  f34 = c[i + 2 + (j + 3) * c_dim1];\n+\t\t\t  f44 = c[i + 3 + (j + 3) * c_dim1];\n+\t\t\t  i6 = ll + lsec - 1;\n+\t\t\t  for (l = ll; l <= i6; ++l)\n+\t\t\t    {\n+\t\t\t      f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f22 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f23 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f24 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f32 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f42 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f33 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f43 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f34 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f44 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t    }\n+\t\t\t  c[i + j * c_dim1] = f11;\n+\t\t\t  c[i + 1 + j * c_dim1] = f21;\n+\t\t\t  c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t  c[i + 1 + (j + 1) * c_dim1] = f22;\n+\t\t\t  c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t  c[i + 1 + (j + 2) * c_dim1] = f23;\n+\t\t\t  c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t  c[i + 1 + (j + 3) * c_dim1] = f24;\n+\t\t\t  c[i + 2 + j * c_dim1] = f31;\n+\t\t\t  c[i + 3 + j * c_dim1] = f41;\n+\t\t\t  c[i + 2 + (j + 1) * c_dim1] = f32;\n+\t\t\t  c[i + 3 + (j + 1) * c_dim1] = f42;\n+\t\t\t  c[i + 2 + (j + 2) * c_dim1] = f33;\n+\t\t\t  c[i + 3 + (j + 2) * c_dim1] = f43;\n+\t\t\t  c[i + 2 + (j + 3) * c_dim1] = f34;\n+\t\t\t  c[i + 3 + (j + 3) * c_dim1] = f44;\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t      f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t      f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 1) * b_dim1];\n+\t\t\t\t  f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 2) * b_dim1];\n+\t\t\t\t  f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 3) * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t      c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t      c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ujsec < jsec)\n+\t\t    {\n+\t\t      i4 = jj + jsec - 1;\n+\t\t      for (j = jj + ujsec; j <= i4; ++j)\n+\t\t\t{\n+\t\t\t  i5 = ii + uisec - 1;\n+\t\t\t  for (i = ii; i <= i5; i += 4)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f21 = c[i + 1 + j * c_dim1];\n+\t\t\t      f31 = c[i + 2 + j * c_dim1];\n+\t\t\t      f41 = c[i + 3 + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + 1 + j * c_dim1] = f21;\n+\t\t\t      c[i + 2 + j * c_dim1] = f31;\n+\t\t\t      c[i + 3 + j * c_dim1] = f41;\n+\t\t\t    }\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n \t\t}\n \t    }\n \t}\n+      return;\n     }\n   else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n     {\n@@ -334,7 +567,9 @@ matmul_r10 (gfc_array_r10 * const restrict retarray,\n \tfor (n = 0; n < count; n++)\n \t  for (x = 0; x < xcount; x++)\n \t    /* dest[x,y] += a[x,n] * b[n,y] */\n-\t    dest[x*rxstride + y*rystride] += abase[x*axstride + n*aystride] * bbase[n*bxstride + y*bystride];\n+\t    dest[x*rxstride + y*rystride] +=\n+\t\t\t\t\tabase[x*axstride + n*aystride] *\n+\t\t\t\t\tbbase[n*bxstride + y*bystride];\n     }\n   else if (GFC_DESCRIPTOR_RANK (a) == 1)\n     {\n@@ -372,5 +607,4 @@ matmul_r10 (gfc_array_r10 * const restrict retarray,\n \t}\n     }\n }\n-\n #endif"}, {"sha": "4ebd104594bf801817ab640c5d77adc66b95e833", "filename": "libgfortran/generated/matmul_r16.c", "status": "modified", "additions": 315, "deletions": 81, "changes": 396, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d70ab07b65a3fda05fe3ea00434ab98a66e9272/libgfortran%2Fgenerated%2Fmatmul_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d70ab07b65a3fda05fe3ea00434ab98a66e9272/libgfortran%2Fgenerated%2Fmatmul_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_r16.c?ref=5d70ab07b65a3fda05fe3ea00434ab98a66e9272", "patch": "@@ -32,7 +32,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #if defined (HAVE_GFC_REAL_16)\n \n /* Prototype for the BLAS ?gemm subroutine, a pointer to which can be\n-   passed to us by the front-end, in which case we'll call it for large\n+   passed to us by the front-end, in which case we call it for large\n    matrices.  */\n \n typedef void (*blas_call)(const char *, const char *, const int *, const int *,\n@@ -99,7 +99,7 @@ matmul_r16 (gfc_array_r16 * const restrict retarray,\n \n    o One-dimensional argument B is implicitly treated as a column matrix\n      dimensioned [count, 1], so ycount=1.\n-  */\n+*/\n \n   if (retarray->base_addr == NULL)\n     {\n@@ -127,47 +127,47 @@ matmul_r16 (gfc_array_r16 * const restrict retarray,\n \t= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_REAL_16));\n       retarray->offset = 0;\n     }\n-    else if (unlikely (compile_options.bounds_check))\n-      {\n-\tindex_type ret_extent, arg_extent;\n-\n-\tif (GFC_DESCRIPTOR_RANK (a) == 1)\n-\t  {\n-\t    arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n-\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t    if (arg_extent != ret_extent)\n-\t      runtime_error (\"Incorrect extent in return array in\"\n-\t\t\t     \" MATMUL intrinsic: is %ld, should be %ld\",\n-\t\t\t     (long int) ret_extent, (long int) arg_extent);\n-\t  }\n-\telse if (GFC_DESCRIPTOR_RANK (b) == 1)\n-\t  {\n-\t    arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n-\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t    if (arg_extent != ret_extent)\n-\t      runtime_error (\"Incorrect extent in return array in\"\n-\t\t\t     \" MATMUL intrinsic: is %ld, should be %ld\",\n-\t\t\t     (long int) ret_extent, (long int) arg_extent);\t    \n-\t  }\n-\telse\n-\t  {\n-\t    arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n-\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t    if (arg_extent != ret_extent)\n-\t      runtime_error (\"Incorrect extent in return array in\"\n-\t\t\t     \" MATMUL intrinsic for dimension 1:\"\n-\t\t\t     \" is %ld, should be %ld\",\n-\t\t\t     (long int) ret_extent, (long int) arg_extent);\n-\n-\t    arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n-\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n-\t    if (arg_extent != ret_extent)\n-\t      runtime_error (\"Incorrect extent in return array in\"\n-\t\t\t     \" MATMUL intrinsic for dimension 2:\"\n-\t\t\t     \" is %ld, should be %ld\",\n-\t\t\t     (long int) ret_extent, (long int) arg_extent);\n-\t  }\n-      }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+      index_type ret_extent, arg_extent;\n+\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 1:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 2:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+    }\n \n \n   if (GFC_DESCRIPTOR_RANK (retarray) == 1)\n@@ -230,61 +230,294 @@ matmul_r16 (gfc_array_r16 * const restrict retarray,\n   bbase = b->base_addr;\n   dest = retarray->base_addr;\n \n-\n-  /* Now that everything is set up, we're performing the multiplication\n+  /* Now that everything is set up, we perform the multiplication\n      itself.  */\n \n #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))\n+#define min(a,b) ((a) <= (b) ? (a) : (b))\n+#define max(a,b) ((a) >= (b) ? (a) : (b))\n \n   if (try_blas && rxstride == 1 && (axstride == 1 || aystride == 1)\n       && (bxstride == 1 || bystride == 1)\n       && (((float) xcount) * ((float) ycount) * ((float) count)\n           > POW3(blas_limit)))\n-  {\n-    const int m = xcount, n = ycount, k = count, ldc = rystride;\n-    const GFC_REAL_16 one = 1, zero = 0;\n-    const int lda = (axstride == 1) ? aystride : axstride,\n-              ldb = (bxstride == 1) ? bystride : bxstride;\n-\n-    if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n-      {\n-        assert (gemm != NULL);\n-        gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m, &n, &k,\n-              &one, abase, &lda, bbase, &ldb, &zero, dest, &ldc, 1, 1);\n-        return;\n-      }\n-  }\n-\n-  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n     {\n-      const GFC_REAL_16 * restrict bbase_y;\n-      GFC_REAL_16 * restrict dest_y;\n-      const GFC_REAL_16 * restrict abase_n;\n-      GFC_REAL_16 bbase_yn;\n+      const int m = xcount, n = ycount, k = count, ldc = rystride;\n+      const GFC_REAL_16 one = 1, zero = 0;\n+      const int lda = (axstride == 1) ? aystride : axstride,\n+\t\tldb = (bxstride == 1) ? bystride : bxstride;\n \n-      if (rystride == xcount)\n-\tmemset (dest, 0, (sizeof (GFC_REAL_16) * xcount * ycount));\n-      else\n+      if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n \t{\n-\t  for (y = 0; y < ycount; y++)\n-\t    for (x = 0; x < xcount; x++)\n-\t      dest[x + y*rystride] = (GFC_REAL_16)0;\n+\t  assert (gemm != NULL);\n+\t  gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m,\n+\t\t&n, &k,\t&one, abase, &lda, bbase, &ldb, &zero, dest,\n+\t\t&ldc, 1, 1);\n+\t  return;\n \t}\n+    }\n \n-      for (y = 0; y < ycount; y++)\n+  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n+    {\n+      /* This block of code implements a tuned matmul, derived from\n+         Superscalar GEMM-based level 3 BLAS,  Beta version 0.1\n+\n+               Bo Kagstrom and Per Ling\n+               Department of Computing Science\n+               Umea University\n+               S-901 87 Umea, Sweden\n+\n+\t from netlib.org, translated to C, and modified for matmul.m4.  */\n+\n+      const GFC_REAL_16 *a, *b;\n+      GFC_REAL_16 *c;\n+      const index_type m = xcount, n = ycount, k = count;\n+\n+      /* System generated locals */\n+      index_type a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset,\n+\t\t i1, i2, i3, i4, i5, i6;\n+\n+      /* Local variables */\n+      GFC_REAL_16 t1[65536], /* was [256][256] */\n+\t\t f11, f12, f21, f22, f31, f32, f41, f42,\n+\t\t f13, f14, f23, f24, f33, f34, f43, f44;\n+      index_type i, j, l, ii, jj, ll;\n+      index_type isec, jsec, lsec, uisec, ujsec, ulsec;\n+\n+      a = abase;\n+      b = bbase;\n+      c = retarray->base_addr;\n+\n+      /* Parameter adjustments */\n+      c_dim1 = rystride;\n+      c_offset = 1 + c_dim1;\n+      c -= c_offset;\n+      a_dim1 = aystride;\n+      a_offset = 1 + a_dim1;\n+      a -= a_offset;\n+      b_dim1 = bystride;\n+      b_offset = 1 + b_dim1;\n+      b -= b_offset;\n+\n+      /* Early exit if possible */\n+      if (m == 0 || n == 0 || k == 0)\n+\treturn;\n+\n+      /* Empty c first.  */\n+      for (j=1; j<=n; j++)\n+\tfor (i=1; i<=m; i++)\n+\t  c[i + j * c_dim1] = (GFC_REAL_16)0;\n+\n+      /* Start turning the crank. */\n+      i1 = n;\n+      for (jj = 1; jj <= i1; jj += 512)\n \t{\n-\t  bbase_y = bbase + y*bystride;\n-\t  dest_y = dest + y*rystride;\n-\t  for (n = 0; n < count; n++)\n+\t  /* Computing MIN */\n+\t  i2 = 512;\n+\t  i3 = n - jj + 1;\n+\t  jsec = min(i2,i3);\n+\t  ujsec = jsec - jsec % 4;\n+\t  i2 = k;\n+\t  for (ll = 1; ll <= i2; ll += 256)\n \t    {\n-\t      abase_n = abase + n*aystride;\n-\t      bbase_yn = bbase_y[n];\n-\t      for (x = 0; x < xcount; x++)\n+\t      /* Computing MIN */\n+\t      i3 = 256;\n+\t      i4 = k - ll + 1;\n+\t      lsec = min(i3,i4);\n+\t      ulsec = lsec - lsec % 2;\n+\n+\t      i3 = m;\n+\t      for (ii = 1; ii <= i3; ii += 256)\n \t\t{\n-\t\t  dest_y[x] += abase_n[x] * bbase_yn;\n+\t\t  /* Computing MIN */\n+\t\t  i4 = 256;\n+\t\t  i5 = m - ii + 1;\n+\t\t  isec = min(i4,i5);\n+\t\t  uisec = isec - isec % 2;\n+\t\t  i4 = ll + ulsec - 1;\n+\t\t  for (l = ll; l <= i4; l += 2)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 2)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + (l + 1) * a_dim1];\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ulsec < lsec)\n+\t\t    {\n+\t\t      i4 = ii + isec - 1;\n+\t\t      for (i = ii; i<= i4; ++i)\n+\t\t\t{\n+\t\t\t  t1[lsec + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t    a[i + (ll + lsec - 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\n+\t\t  uisec = isec - isec % 4;\n+\t\t  i4 = jj + ujsec - 1;\n+\t\t  for (j = jj; j <= i4; j += 4)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 4)\n+\t\t\t{\n+\t\t\t  f11 = c[i + j * c_dim1];\n+\t\t\t  f21 = c[i + 1 + j * c_dim1];\n+\t\t\t  f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t  f22 = c[i + 1 + (j + 1) * c_dim1];\n+\t\t\t  f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t  f23 = c[i + 1 + (j + 2) * c_dim1];\n+\t\t\t  f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t  f24 = c[i + 1 + (j + 3) * c_dim1];\n+\t\t\t  f31 = c[i + 2 + j * c_dim1];\n+\t\t\t  f41 = c[i + 3 + j * c_dim1];\n+\t\t\t  f32 = c[i + 2 + (j + 1) * c_dim1];\n+\t\t\t  f42 = c[i + 3 + (j + 1) * c_dim1];\n+\t\t\t  f33 = c[i + 2 + (j + 2) * c_dim1];\n+\t\t\t  f43 = c[i + 3 + (j + 2) * c_dim1];\n+\t\t\t  f34 = c[i + 2 + (j + 3) * c_dim1];\n+\t\t\t  f44 = c[i + 3 + (j + 3) * c_dim1];\n+\t\t\t  i6 = ll + lsec - 1;\n+\t\t\t  for (l = ll; l <= i6; ++l)\n+\t\t\t    {\n+\t\t\t      f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f22 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f23 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f24 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f32 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f42 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f33 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f43 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f34 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f44 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t    }\n+\t\t\t  c[i + j * c_dim1] = f11;\n+\t\t\t  c[i + 1 + j * c_dim1] = f21;\n+\t\t\t  c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t  c[i + 1 + (j + 1) * c_dim1] = f22;\n+\t\t\t  c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t  c[i + 1 + (j + 2) * c_dim1] = f23;\n+\t\t\t  c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t  c[i + 1 + (j + 3) * c_dim1] = f24;\n+\t\t\t  c[i + 2 + j * c_dim1] = f31;\n+\t\t\t  c[i + 3 + j * c_dim1] = f41;\n+\t\t\t  c[i + 2 + (j + 1) * c_dim1] = f32;\n+\t\t\t  c[i + 3 + (j + 1) * c_dim1] = f42;\n+\t\t\t  c[i + 2 + (j + 2) * c_dim1] = f33;\n+\t\t\t  c[i + 3 + (j + 2) * c_dim1] = f43;\n+\t\t\t  c[i + 2 + (j + 3) * c_dim1] = f34;\n+\t\t\t  c[i + 3 + (j + 3) * c_dim1] = f44;\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t      f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t      f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 1) * b_dim1];\n+\t\t\t\t  f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 2) * b_dim1];\n+\t\t\t\t  f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 3) * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t      c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t      c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ujsec < jsec)\n+\t\t    {\n+\t\t      i4 = jj + jsec - 1;\n+\t\t      for (j = jj + ujsec; j <= i4; ++j)\n+\t\t\t{\n+\t\t\t  i5 = ii + uisec - 1;\n+\t\t\t  for (i = ii; i <= i5; i += 4)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f21 = c[i + 1 + j * c_dim1];\n+\t\t\t      f31 = c[i + 2 + j * c_dim1];\n+\t\t\t      f41 = c[i + 3 + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + 1 + j * c_dim1] = f21;\n+\t\t\t      c[i + 2 + j * c_dim1] = f31;\n+\t\t\t      c[i + 3 + j * c_dim1] = f41;\n+\t\t\t    }\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n \t\t}\n \t    }\n \t}\n+      return;\n     }\n   else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n     {\n@@ -334,7 +567,9 @@ matmul_r16 (gfc_array_r16 * const restrict retarray,\n \tfor (n = 0; n < count; n++)\n \t  for (x = 0; x < xcount; x++)\n \t    /* dest[x,y] += a[x,n] * b[n,y] */\n-\t    dest[x*rxstride + y*rystride] += abase[x*axstride + n*aystride] * bbase[n*bxstride + y*bystride];\n+\t    dest[x*rxstride + y*rystride] +=\n+\t\t\t\t\tabase[x*axstride + n*aystride] *\n+\t\t\t\t\tbbase[n*bxstride + y*bystride];\n     }\n   else if (GFC_DESCRIPTOR_RANK (a) == 1)\n     {\n@@ -372,5 +607,4 @@ matmul_r16 (gfc_array_r16 * const restrict retarray,\n \t}\n     }\n }\n-\n #endif"}, {"sha": "cf3ffa352328f3246ffaf14e98d8a4b6f0fe354e", "filename": "libgfortran/generated/matmul_r4.c", "status": "modified", "additions": 315, "deletions": 81, "changes": 396, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d70ab07b65a3fda05fe3ea00434ab98a66e9272/libgfortran%2Fgenerated%2Fmatmul_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d70ab07b65a3fda05fe3ea00434ab98a66e9272/libgfortran%2Fgenerated%2Fmatmul_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_r4.c?ref=5d70ab07b65a3fda05fe3ea00434ab98a66e9272", "patch": "@@ -32,7 +32,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #if defined (HAVE_GFC_REAL_4)\n \n /* Prototype for the BLAS ?gemm subroutine, a pointer to which can be\n-   passed to us by the front-end, in which case we'll call it for large\n+   passed to us by the front-end, in which case we call it for large\n    matrices.  */\n \n typedef void (*blas_call)(const char *, const char *, const int *, const int *,\n@@ -99,7 +99,7 @@ matmul_r4 (gfc_array_r4 * const restrict retarray,\n \n    o One-dimensional argument B is implicitly treated as a column matrix\n      dimensioned [count, 1], so ycount=1.\n-  */\n+*/\n \n   if (retarray->base_addr == NULL)\n     {\n@@ -127,47 +127,47 @@ matmul_r4 (gfc_array_r4 * const restrict retarray,\n \t= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_REAL_4));\n       retarray->offset = 0;\n     }\n-    else if (unlikely (compile_options.bounds_check))\n-      {\n-\tindex_type ret_extent, arg_extent;\n-\n-\tif (GFC_DESCRIPTOR_RANK (a) == 1)\n-\t  {\n-\t    arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n-\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t    if (arg_extent != ret_extent)\n-\t      runtime_error (\"Incorrect extent in return array in\"\n-\t\t\t     \" MATMUL intrinsic: is %ld, should be %ld\",\n-\t\t\t     (long int) ret_extent, (long int) arg_extent);\n-\t  }\n-\telse if (GFC_DESCRIPTOR_RANK (b) == 1)\n-\t  {\n-\t    arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n-\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t    if (arg_extent != ret_extent)\n-\t      runtime_error (\"Incorrect extent in return array in\"\n-\t\t\t     \" MATMUL intrinsic: is %ld, should be %ld\",\n-\t\t\t     (long int) ret_extent, (long int) arg_extent);\t    \n-\t  }\n-\telse\n-\t  {\n-\t    arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n-\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t    if (arg_extent != ret_extent)\n-\t      runtime_error (\"Incorrect extent in return array in\"\n-\t\t\t     \" MATMUL intrinsic for dimension 1:\"\n-\t\t\t     \" is %ld, should be %ld\",\n-\t\t\t     (long int) ret_extent, (long int) arg_extent);\n-\n-\t    arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n-\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n-\t    if (arg_extent != ret_extent)\n-\t      runtime_error (\"Incorrect extent in return array in\"\n-\t\t\t     \" MATMUL intrinsic for dimension 2:\"\n-\t\t\t     \" is %ld, should be %ld\",\n-\t\t\t     (long int) ret_extent, (long int) arg_extent);\n-\t  }\n-      }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+      index_type ret_extent, arg_extent;\n+\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 1:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 2:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+    }\n \n \n   if (GFC_DESCRIPTOR_RANK (retarray) == 1)\n@@ -230,61 +230,294 @@ matmul_r4 (gfc_array_r4 * const restrict retarray,\n   bbase = b->base_addr;\n   dest = retarray->base_addr;\n \n-\n-  /* Now that everything is set up, we're performing the multiplication\n+  /* Now that everything is set up, we perform the multiplication\n      itself.  */\n \n #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))\n+#define min(a,b) ((a) <= (b) ? (a) : (b))\n+#define max(a,b) ((a) >= (b) ? (a) : (b))\n \n   if (try_blas && rxstride == 1 && (axstride == 1 || aystride == 1)\n       && (bxstride == 1 || bystride == 1)\n       && (((float) xcount) * ((float) ycount) * ((float) count)\n           > POW3(blas_limit)))\n-  {\n-    const int m = xcount, n = ycount, k = count, ldc = rystride;\n-    const GFC_REAL_4 one = 1, zero = 0;\n-    const int lda = (axstride == 1) ? aystride : axstride,\n-              ldb = (bxstride == 1) ? bystride : bxstride;\n-\n-    if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n-      {\n-        assert (gemm != NULL);\n-        gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m, &n, &k,\n-              &one, abase, &lda, bbase, &ldb, &zero, dest, &ldc, 1, 1);\n-        return;\n-      }\n-  }\n-\n-  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n     {\n-      const GFC_REAL_4 * restrict bbase_y;\n-      GFC_REAL_4 * restrict dest_y;\n-      const GFC_REAL_4 * restrict abase_n;\n-      GFC_REAL_4 bbase_yn;\n+      const int m = xcount, n = ycount, k = count, ldc = rystride;\n+      const GFC_REAL_4 one = 1, zero = 0;\n+      const int lda = (axstride == 1) ? aystride : axstride,\n+\t\tldb = (bxstride == 1) ? bystride : bxstride;\n \n-      if (rystride == xcount)\n-\tmemset (dest, 0, (sizeof (GFC_REAL_4) * xcount * ycount));\n-      else\n+      if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n \t{\n-\t  for (y = 0; y < ycount; y++)\n-\t    for (x = 0; x < xcount; x++)\n-\t      dest[x + y*rystride] = (GFC_REAL_4)0;\n+\t  assert (gemm != NULL);\n+\t  gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m,\n+\t\t&n, &k,\t&one, abase, &lda, bbase, &ldb, &zero, dest,\n+\t\t&ldc, 1, 1);\n+\t  return;\n \t}\n+    }\n \n-      for (y = 0; y < ycount; y++)\n+  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n+    {\n+      /* This block of code implements a tuned matmul, derived from\n+         Superscalar GEMM-based level 3 BLAS,  Beta version 0.1\n+\n+               Bo Kagstrom and Per Ling\n+               Department of Computing Science\n+               Umea University\n+               S-901 87 Umea, Sweden\n+\n+\t from netlib.org, translated to C, and modified for matmul.m4.  */\n+\n+      const GFC_REAL_4 *a, *b;\n+      GFC_REAL_4 *c;\n+      const index_type m = xcount, n = ycount, k = count;\n+\n+      /* System generated locals */\n+      index_type a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset,\n+\t\t i1, i2, i3, i4, i5, i6;\n+\n+      /* Local variables */\n+      GFC_REAL_4 t1[65536], /* was [256][256] */\n+\t\t f11, f12, f21, f22, f31, f32, f41, f42,\n+\t\t f13, f14, f23, f24, f33, f34, f43, f44;\n+      index_type i, j, l, ii, jj, ll;\n+      index_type isec, jsec, lsec, uisec, ujsec, ulsec;\n+\n+      a = abase;\n+      b = bbase;\n+      c = retarray->base_addr;\n+\n+      /* Parameter adjustments */\n+      c_dim1 = rystride;\n+      c_offset = 1 + c_dim1;\n+      c -= c_offset;\n+      a_dim1 = aystride;\n+      a_offset = 1 + a_dim1;\n+      a -= a_offset;\n+      b_dim1 = bystride;\n+      b_offset = 1 + b_dim1;\n+      b -= b_offset;\n+\n+      /* Early exit if possible */\n+      if (m == 0 || n == 0 || k == 0)\n+\treturn;\n+\n+      /* Empty c first.  */\n+      for (j=1; j<=n; j++)\n+\tfor (i=1; i<=m; i++)\n+\t  c[i + j * c_dim1] = (GFC_REAL_4)0;\n+\n+      /* Start turning the crank. */\n+      i1 = n;\n+      for (jj = 1; jj <= i1; jj += 512)\n \t{\n-\t  bbase_y = bbase + y*bystride;\n-\t  dest_y = dest + y*rystride;\n-\t  for (n = 0; n < count; n++)\n+\t  /* Computing MIN */\n+\t  i2 = 512;\n+\t  i3 = n - jj + 1;\n+\t  jsec = min(i2,i3);\n+\t  ujsec = jsec - jsec % 4;\n+\t  i2 = k;\n+\t  for (ll = 1; ll <= i2; ll += 256)\n \t    {\n-\t      abase_n = abase + n*aystride;\n-\t      bbase_yn = bbase_y[n];\n-\t      for (x = 0; x < xcount; x++)\n+\t      /* Computing MIN */\n+\t      i3 = 256;\n+\t      i4 = k - ll + 1;\n+\t      lsec = min(i3,i4);\n+\t      ulsec = lsec - lsec % 2;\n+\n+\t      i3 = m;\n+\t      for (ii = 1; ii <= i3; ii += 256)\n \t\t{\n-\t\t  dest_y[x] += abase_n[x] * bbase_yn;\n+\t\t  /* Computing MIN */\n+\t\t  i4 = 256;\n+\t\t  i5 = m - ii + 1;\n+\t\t  isec = min(i4,i5);\n+\t\t  uisec = isec - isec % 2;\n+\t\t  i4 = ll + ulsec - 1;\n+\t\t  for (l = ll; l <= i4; l += 2)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 2)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + (l + 1) * a_dim1];\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ulsec < lsec)\n+\t\t    {\n+\t\t      i4 = ii + isec - 1;\n+\t\t      for (i = ii; i<= i4; ++i)\n+\t\t\t{\n+\t\t\t  t1[lsec + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t    a[i + (ll + lsec - 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\n+\t\t  uisec = isec - isec % 4;\n+\t\t  i4 = jj + ujsec - 1;\n+\t\t  for (j = jj; j <= i4; j += 4)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 4)\n+\t\t\t{\n+\t\t\t  f11 = c[i + j * c_dim1];\n+\t\t\t  f21 = c[i + 1 + j * c_dim1];\n+\t\t\t  f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t  f22 = c[i + 1 + (j + 1) * c_dim1];\n+\t\t\t  f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t  f23 = c[i + 1 + (j + 2) * c_dim1];\n+\t\t\t  f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t  f24 = c[i + 1 + (j + 3) * c_dim1];\n+\t\t\t  f31 = c[i + 2 + j * c_dim1];\n+\t\t\t  f41 = c[i + 3 + j * c_dim1];\n+\t\t\t  f32 = c[i + 2 + (j + 1) * c_dim1];\n+\t\t\t  f42 = c[i + 3 + (j + 1) * c_dim1];\n+\t\t\t  f33 = c[i + 2 + (j + 2) * c_dim1];\n+\t\t\t  f43 = c[i + 3 + (j + 2) * c_dim1];\n+\t\t\t  f34 = c[i + 2 + (j + 3) * c_dim1];\n+\t\t\t  f44 = c[i + 3 + (j + 3) * c_dim1];\n+\t\t\t  i6 = ll + lsec - 1;\n+\t\t\t  for (l = ll; l <= i6; ++l)\n+\t\t\t    {\n+\t\t\t      f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f22 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f23 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f24 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f32 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f42 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f33 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f43 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f34 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f44 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t    }\n+\t\t\t  c[i + j * c_dim1] = f11;\n+\t\t\t  c[i + 1 + j * c_dim1] = f21;\n+\t\t\t  c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t  c[i + 1 + (j + 1) * c_dim1] = f22;\n+\t\t\t  c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t  c[i + 1 + (j + 2) * c_dim1] = f23;\n+\t\t\t  c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t  c[i + 1 + (j + 3) * c_dim1] = f24;\n+\t\t\t  c[i + 2 + j * c_dim1] = f31;\n+\t\t\t  c[i + 3 + j * c_dim1] = f41;\n+\t\t\t  c[i + 2 + (j + 1) * c_dim1] = f32;\n+\t\t\t  c[i + 3 + (j + 1) * c_dim1] = f42;\n+\t\t\t  c[i + 2 + (j + 2) * c_dim1] = f33;\n+\t\t\t  c[i + 3 + (j + 2) * c_dim1] = f43;\n+\t\t\t  c[i + 2 + (j + 3) * c_dim1] = f34;\n+\t\t\t  c[i + 3 + (j + 3) * c_dim1] = f44;\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t      f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t      f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 1) * b_dim1];\n+\t\t\t\t  f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 2) * b_dim1];\n+\t\t\t\t  f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 3) * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t      c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t      c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ujsec < jsec)\n+\t\t    {\n+\t\t      i4 = jj + jsec - 1;\n+\t\t      for (j = jj + ujsec; j <= i4; ++j)\n+\t\t\t{\n+\t\t\t  i5 = ii + uisec - 1;\n+\t\t\t  for (i = ii; i <= i5; i += 4)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f21 = c[i + 1 + j * c_dim1];\n+\t\t\t      f31 = c[i + 2 + j * c_dim1];\n+\t\t\t      f41 = c[i + 3 + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + 1 + j * c_dim1] = f21;\n+\t\t\t      c[i + 2 + j * c_dim1] = f31;\n+\t\t\t      c[i + 3 + j * c_dim1] = f41;\n+\t\t\t    }\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n \t\t}\n \t    }\n \t}\n+      return;\n     }\n   else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n     {\n@@ -334,7 +567,9 @@ matmul_r4 (gfc_array_r4 * const restrict retarray,\n \tfor (n = 0; n < count; n++)\n \t  for (x = 0; x < xcount; x++)\n \t    /* dest[x,y] += a[x,n] * b[n,y] */\n-\t    dest[x*rxstride + y*rystride] += abase[x*axstride + n*aystride] * bbase[n*bxstride + y*bystride];\n+\t    dest[x*rxstride + y*rystride] +=\n+\t\t\t\t\tabase[x*axstride + n*aystride] *\n+\t\t\t\t\tbbase[n*bxstride + y*bystride];\n     }\n   else if (GFC_DESCRIPTOR_RANK (a) == 1)\n     {\n@@ -372,5 +607,4 @@ matmul_r4 (gfc_array_r4 * const restrict retarray,\n \t}\n     }\n }\n-\n #endif"}, {"sha": "9a70a23df0bb1a2a6bbc02ef8ec428d312808e57", "filename": "libgfortran/generated/matmul_r8.c", "status": "modified", "additions": 315, "deletions": 81, "changes": 396, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d70ab07b65a3fda05fe3ea00434ab98a66e9272/libgfortran%2Fgenerated%2Fmatmul_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d70ab07b65a3fda05fe3ea00434ab98a66e9272/libgfortran%2Fgenerated%2Fmatmul_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmatmul_r8.c?ref=5d70ab07b65a3fda05fe3ea00434ab98a66e9272", "patch": "@@ -32,7 +32,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #if defined (HAVE_GFC_REAL_8)\n \n /* Prototype for the BLAS ?gemm subroutine, a pointer to which can be\n-   passed to us by the front-end, in which case we'll call it for large\n+   passed to us by the front-end, in which case we call it for large\n    matrices.  */\n \n typedef void (*blas_call)(const char *, const char *, const int *, const int *,\n@@ -99,7 +99,7 @@ matmul_r8 (gfc_array_r8 * const restrict retarray,\n \n    o One-dimensional argument B is implicitly treated as a column matrix\n      dimensioned [count, 1], so ycount=1.\n-  */\n+*/\n \n   if (retarray->base_addr == NULL)\n     {\n@@ -127,47 +127,47 @@ matmul_r8 (gfc_array_r8 * const restrict retarray,\n \t= xmallocarray (size0 ((array_t *) retarray), sizeof (GFC_REAL_8));\n       retarray->offset = 0;\n     }\n-    else if (unlikely (compile_options.bounds_check))\n-      {\n-\tindex_type ret_extent, arg_extent;\n-\n-\tif (GFC_DESCRIPTOR_RANK (a) == 1)\n-\t  {\n-\t    arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n-\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t    if (arg_extent != ret_extent)\n-\t      runtime_error (\"Incorrect extent in return array in\"\n-\t\t\t     \" MATMUL intrinsic: is %ld, should be %ld\",\n-\t\t\t     (long int) ret_extent, (long int) arg_extent);\n-\t  }\n-\telse if (GFC_DESCRIPTOR_RANK (b) == 1)\n-\t  {\n-\t    arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n-\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t    if (arg_extent != ret_extent)\n-\t      runtime_error (\"Incorrect extent in return array in\"\n-\t\t\t     \" MATMUL intrinsic: is %ld, should be %ld\",\n-\t\t\t     (long int) ret_extent, (long int) arg_extent);\t    \n-\t  }\n-\telse\n-\t  {\n-\t    arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n-\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t    if (arg_extent != ret_extent)\n-\t      runtime_error (\"Incorrect extent in return array in\"\n-\t\t\t     \" MATMUL intrinsic for dimension 1:\"\n-\t\t\t     \" is %ld, should be %ld\",\n-\t\t\t     (long int) ret_extent, (long int) arg_extent);\n-\n-\t    arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n-\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n-\t    if (arg_extent != ret_extent)\n-\t      runtime_error (\"Incorrect extent in return array in\"\n-\t\t\t     \" MATMUL intrinsic for dimension 2:\"\n-\t\t\t     \" is %ld, should be %ld\",\n-\t\t\t     (long int) ret_extent, (long int) arg_extent);\n-\t  }\n-      }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+      index_type ret_extent, arg_extent;\n+\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 1:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 2:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+    }\n \n \n   if (GFC_DESCRIPTOR_RANK (retarray) == 1)\n@@ -230,61 +230,294 @@ matmul_r8 (gfc_array_r8 * const restrict retarray,\n   bbase = b->base_addr;\n   dest = retarray->base_addr;\n \n-\n-  /* Now that everything is set up, we're performing the multiplication\n+  /* Now that everything is set up, we perform the multiplication\n      itself.  */\n \n #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))\n+#define min(a,b) ((a) <= (b) ? (a) : (b))\n+#define max(a,b) ((a) >= (b) ? (a) : (b))\n \n   if (try_blas && rxstride == 1 && (axstride == 1 || aystride == 1)\n       && (bxstride == 1 || bystride == 1)\n       && (((float) xcount) * ((float) ycount) * ((float) count)\n           > POW3(blas_limit)))\n-  {\n-    const int m = xcount, n = ycount, k = count, ldc = rystride;\n-    const GFC_REAL_8 one = 1, zero = 0;\n-    const int lda = (axstride == 1) ? aystride : axstride,\n-              ldb = (bxstride == 1) ? bystride : bxstride;\n-\n-    if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n-      {\n-        assert (gemm != NULL);\n-        gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m, &n, &k,\n-              &one, abase, &lda, bbase, &ldb, &zero, dest, &ldc, 1, 1);\n-        return;\n-      }\n-  }\n-\n-  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n     {\n-      const GFC_REAL_8 * restrict bbase_y;\n-      GFC_REAL_8 * restrict dest_y;\n-      const GFC_REAL_8 * restrict abase_n;\n-      GFC_REAL_8 bbase_yn;\n+      const int m = xcount, n = ycount, k = count, ldc = rystride;\n+      const GFC_REAL_8 one = 1, zero = 0;\n+      const int lda = (axstride == 1) ? aystride : axstride,\n+\t\tldb = (bxstride == 1) ? bystride : bxstride;\n \n-      if (rystride == xcount)\n-\tmemset (dest, 0, (sizeof (GFC_REAL_8) * xcount * ycount));\n-      else\n+      if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n \t{\n-\t  for (y = 0; y < ycount; y++)\n-\t    for (x = 0; x < xcount; x++)\n-\t      dest[x + y*rystride] = (GFC_REAL_8)0;\n+\t  assert (gemm != NULL);\n+\t  gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m,\n+\t\t&n, &k,\t&one, abase, &lda, bbase, &ldb, &zero, dest,\n+\t\t&ldc, 1, 1);\n+\t  return;\n \t}\n+    }\n \n-      for (y = 0; y < ycount; y++)\n+  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n+    {\n+      /* This block of code implements a tuned matmul, derived from\n+         Superscalar GEMM-based level 3 BLAS,  Beta version 0.1\n+\n+               Bo Kagstrom and Per Ling\n+               Department of Computing Science\n+               Umea University\n+               S-901 87 Umea, Sweden\n+\n+\t from netlib.org, translated to C, and modified for matmul.m4.  */\n+\n+      const GFC_REAL_8 *a, *b;\n+      GFC_REAL_8 *c;\n+      const index_type m = xcount, n = ycount, k = count;\n+\n+      /* System generated locals */\n+      index_type a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset,\n+\t\t i1, i2, i3, i4, i5, i6;\n+\n+      /* Local variables */\n+      GFC_REAL_8 t1[65536], /* was [256][256] */\n+\t\t f11, f12, f21, f22, f31, f32, f41, f42,\n+\t\t f13, f14, f23, f24, f33, f34, f43, f44;\n+      index_type i, j, l, ii, jj, ll;\n+      index_type isec, jsec, lsec, uisec, ujsec, ulsec;\n+\n+      a = abase;\n+      b = bbase;\n+      c = retarray->base_addr;\n+\n+      /* Parameter adjustments */\n+      c_dim1 = rystride;\n+      c_offset = 1 + c_dim1;\n+      c -= c_offset;\n+      a_dim1 = aystride;\n+      a_offset = 1 + a_dim1;\n+      a -= a_offset;\n+      b_dim1 = bystride;\n+      b_offset = 1 + b_dim1;\n+      b -= b_offset;\n+\n+      /* Early exit if possible */\n+      if (m == 0 || n == 0 || k == 0)\n+\treturn;\n+\n+      /* Empty c first.  */\n+      for (j=1; j<=n; j++)\n+\tfor (i=1; i<=m; i++)\n+\t  c[i + j * c_dim1] = (GFC_REAL_8)0;\n+\n+      /* Start turning the crank. */\n+      i1 = n;\n+      for (jj = 1; jj <= i1; jj += 512)\n \t{\n-\t  bbase_y = bbase + y*bystride;\n-\t  dest_y = dest + y*rystride;\n-\t  for (n = 0; n < count; n++)\n+\t  /* Computing MIN */\n+\t  i2 = 512;\n+\t  i3 = n - jj + 1;\n+\t  jsec = min(i2,i3);\n+\t  ujsec = jsec - jsec % 4;\n+\t  i2 = k;\n+\t  for (ll = 1; ll <= i2; ll += 256)\n \t    {\n-\t      abase_n = abase + n*aystride;\n-\t      bbase_yn = bbase_y[n];\n-\t      for (x = 0; x < xcount; x++)\n+\t      /* Computing MIN */\n+\t      i3 = 256;\n+\t      i4 = k - ll + 1;\n+\t      lsec = min(i3,i4);\n+\t      ulsec = lsec - lsec % 2;\n+\n+\t      i3 = m;\n+\t      for (ii = 1; ii <= i3; ii += 256)\n \t\t{\n-\t\t  dest_y[x] += abase_n[x] * bbase_yn;\n+\t\t  /* Computing MIN */\n+\t\t  i4 = 256;\n+\t\t  i5 = m - ii + 1;\n+\t\t  isec = min(i4,i5);\n+\t\t  uisec = isec - isec % 2;\n+\t\t  i4 = ll + ulsec - 1;\n+\t\t  for (l = ll; l <= i4; l += 2)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 2)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + (l + 1) * a_dim1];\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ulsec < lsec)\n+\t\t    {\n+\t\t      i4 = ii + isec - 1;\n+\t\t      for (i = ii; i<= i4; ++i)\n+\t\t\t{\n+\t\t\t  t1[lsec + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t    a[i + (ll + lsec - 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\n+\t\t  uisec = isec - isec % 4;\n+\t\t  i4 = jj + ujsec - 1;\n+\t\t  for (j = jj; j <= i4; j += 4)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 4)\n+\t\t\t{\n+\t\t\t  f11 = c[i + j * c_dim1];\n+\t\t\t  f21 = c[i + 1 + j * c_dim1];\n+\t\t\t  f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t  f22 = c[i + 1 + (j + 1) * c_dim1];\n+\t\t\t  f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t  f23 = c[i + 1 + (j + 2) * c_dim1];\n+\t\t\t  f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t  f24 = c[i + 1 + (j + 3) * c_dim1];\n+\t\t\t  f31 = c[i + 2 + j * c_dim1];\n+\t\t\t  f41 = c[i + 3 + j * c_dim1];\n+\t\t\t  f32 = c[i + 2 + (j + 1) * c_dim1];\n+\t\t\t  f42 = c[i + 3 + (j + 1) * c_dim1];\n+\t\t\t  f33 = c[i + 2 + (j + 2) * c_dim1];\n+\t\t\t  f43 = c[i + 3 + (j + 2) * c_dim1];\n+\t\t\t  f34 = c[i + 2 + (j + 3) * c_dim1];\n+\t\t\t  f44 = c[i + 3 + (j + 3) * c_dim1];\n+\t\t\t  i6 = ll + lsec - 1;\n+\t\t\t  for (l = ll; l <= i6; ++l)\n+\t\t\t    {\n+\t\t\t      f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f22 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f23 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f24 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f32 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f42 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f33 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f43 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f34 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f44 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t    }\n+\t\t\t  c[i + j * c_dim1] = f11;\n+\t\t\t  c[i + 1 + j * c_dim1] = f21;\n+\t\t\t  c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t  c[i + 1 + (j + 1) * c_dim1] = f22;\n+\t\t\t  c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t  c[i + 1 + (j + 2) * c_dim1] = f23;\n+\t\t\t  c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t  c[i + 1 + (j + 3) * c_dim1] = f24;\n+\t\t\t  c[i + 2 + j * c_dim1] = f31;\n+\t\t\t  c[i + 3 + j * c_dim1] = f41;\n+\t\t\t  c[i + 2 + (j + 1) * c_dim1] = f32;\n+\t\t\t  c[i + 3 + (j + 1) * c_dim1] = f42;\n+\t\t\t  c[i + 2 + (j + 2) * c_dim1] = f33;\n+\t\t\t  c[i + 3 + (j + 2) * c_dim1] = f43;\n+\t\t\t  c[i + 2 + (j + 3) * c_dim1] = f34;\n+\t\t\t  c[i + 3 + (j + 3) * c_dim1] = f44;\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t      f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t      f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 1) * b_dim1];\n+\t\t\t\t  f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 2) * b_dim1];\n+\t\t\t\t  f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 3) * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t      c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t      c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ujsec < jsec)\n+\t\t    {\n+\t\t      i4 = jj + jsec - 1;\n+\t\t      for (j = jj + ujsec; j <= i4; ++j)\n+\t\t\t{\n+\t\t\t  i5 = ii + uisec - 1;\n+\t\t\t  for (i = ii; i <= i5; i += 4)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f21 = c[i + 1 + j * c_dim1];\n+\t\t\t      f31 = c[i + 2 + j * c_dim1];\n+\t\t\t      f41 = c[i + 3 + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + 1 + j * c_dim1] = f21;\n+\t\t\t      c[i + 2 + j * c_dim1] = f31;\n+\t\t\t      c[i + 3 + j * c_dim1] = f41;\n+\t\t\t    }\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n \t\t}\n \t    }\n \t}\n+      return;\n     }\n   else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n     {\n@@ -334,7 +567,9 @@ matmul_r8 (gfc_array_r8 * const restrict retarray,\n \tfor (n = 0; n < count; n++)\n \t  for (x = 0; x < xcount; x++)\n \t    /* dest[x,y] += a[x,n] * b[n,y] */\n-\t    dest[x*rxstride + y*rystride] += abase[x*axstride + n*aystride] * bbase[n*bxstride + y*bystride];\n+\t    dest[x*rxstride + y*rystride] +=\n+\t\t\t\t\tabase[x*axstride + n*aystride] *\n+\t\t\t\t\tbbase[n*bxstride + y*bystride];\n     }\n   else if (GFC_DESCRIPTOR_RANK (a) == 1)\n     {\n@@ -372,5 +607,4 @@ matmul_r8 (gfc_array_r8 * const restrict retarray,\n \t}\n     }\n }\n-\n #endif"}, {"sha": "77ed4408425bb47e93a2f20e908cef2ba32317ec", "filename": "libgfortran/m4/matmul.m4", "status": "modified", "additions": 317, "deletions": 83, "changes": 400, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d70ab07b65a3fda05fe3ea00434ab98a66e9272/libgfortran%2Fm4%2Fmatmul.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d70ab07b65a3fda05fe3ea00434ab98a66e9272/libgfortran%2Fm4%2Fmatmul.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fmatmul.m4?ref=5d70ab07b65a3fda05fe3ea00434ab98a66e9272", "patch": "@@ -33,7 +33,7 @@ include(iparm.m4)dnl\n `#if defined (HAVE_'rtype_name`)\n \n /* Prototype for the BLAS ?gemm subroutine, a pointer to which can be\n-   passed to us by the front-end, in which case we''`ll call it for large\n+   passed to us by the front-end, in which case we call it for large\n    matrices.  */\n \n typedef void (*blas_call)(const char *, const char *, const int *, const int *,\n@@ -100,7 +100,7 @@ matmul_'rtype_code` ('rtype` * const restrict retarray,\n \n    o One-dimensional argument B is implicitly treated as a column matrix\n      dimensioned [count, 1], so ycount=1.\n-  */\n+*/\n \n   if (retarray->base_addr == NULL)\n     {\n@@ -128,47 +128,47 @@ matmul_'rtype_code` ('rtype` * const restrict retarray,\n \t= xmallocarray (size0 ((array_t *) retarray), sizeof ('rtype_name`));\n       retarray->offset = 0;\n     }\n-    else if (unlikely (compile_options.bounds_check))\n-      {\n-\tindex_type ret_extent, arg_extent;\n-\n-\tif (GFC_DESCRIPTOR_RANK (a) == 1)\n-\t  {\n-\t    arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n-\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t    if (arg_extent != ret_extent)\n-\t      runtime_error (\"Incorrect extent in return array in\"\n-\t\t\t     \" MATMUL intrinsic: is %ld, should be %ld\",\n-\t\t\t     (long int) ret_extent, (long int) arg_extent);\n-\t  }\n-\telse if (GFC_DESCRIPTOR_RANK (b) == 1)\n-\t  {\n-\t    arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n-\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t    if (arg_extent != ret_extent)\n-\t      runtime_error (\"Incorrect extent in return array in\"\n-\t\t\t     \" MATMUL intrinsic: is %ld, should be %ld\",\n-\t\t\t     (long int) ret_extent, (long int) arg_extent);\t    \n-\t  }\n-\telse\n-\t  {\n-\t    arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n-\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n-\t    if (arg_extent != ret_extent)\n-\t      runtime_error (\"Incorrect extent in return array in\"\n-\t\t\t     \" MATMUL intrinsic for dimension 1:\"\n-\t\t\t     \" is %ld, should be %ld\",\n-\t\t\t     (long int) ret_extent, (long int) arg_extent);\n-\n-\t    arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n-\t    ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n-\t    if (arg_extent != ret_extent)\n-\t      runtime_error (\"Incorrect extent in return array in\"\n-\t\t\t     \" MATMUL intrinsic for dimension 2:\"\n-\t\t\t     \" is %ld, should be %ld\",\n-\t\t\t     (long int) ret_extent, (long int) arg_extent);\n-\t  }\n-      }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+      index_type ret_extent, arg_extent;\n+\n+      if (GFC_DESCRIPTOR_RANK (a) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else if (GFC_DESCRIPTOR_RANK (b) == 1)\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic: is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+      else\n+\t{\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(a,0);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,0);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 1:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\n+\t  arg_extent = GFC_DESCRIPTOR_EXTENT(b,1);\n+\t  ret_extent = GFC_DESCRIPTOR_EXTENT(retarray,1);\n+\t  if (arg_extent != ret_extent)\n+\t    runtime_error (\"Incorrect extent in return array in\"\n+\t\t\t   \" MATMUL intrinsic for dimension 2:\"\n+\t\t\t   \" is %ld, should be %ld\",\n+\t\t\t   (long int) ret_extent, (long int) arg_extent);\n+\t}\n+    }\n '\n sinclude(`matmul_asm_'rtype_code`.m4')dnl\n `\n@@ -232,61 +232,294 @@ sinclude(`matmul_asm_'rtype_code`.m4')dnl\n   bbase = b->base_addr;\n   dest = retarray->base_addr;\n \n-\n-  /* Now that everything is set up, we''`re performing the multiplication\n+  /* Now that everything is set up, we perform the multiplication\n      itself.  */\n \n #define POW3(x) (((float) (x)) * ((float) (x)) * ((float) (x)))\n+#define min(a,b) ((a) <= (b) ? (a) : (b))\n+#define max(a,b) ((a) >= (b) ? (a) : (b))\n \n   if (try_blas && rxstride == 1 && (axstride == 1 || aystride == 1)\n       && (bxstride == 1 || bystride == 1)\n       && (((float) xcount) * ((float) ycount) * ((float) count)\n           > POW3(blas_limit)))\n-  {\n-    const int m = xcount, n = ycount, k = count, ldc = rystride;\n-    const 'rtype_name` one = 1, zero = 0;\n-    const int lda = (axstride == 1) ? aystride : axstride,\n-              ldb = (bxstride == 1) ? bystride : bxstride;\n-\n-    if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n-      {\n-        assert (gemm != NULL);\n-        gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m, &n, &k,\n-              &one, abase, &lda, bbase, &ldb, &zero, dest, &ldc, 1, 1);\n-        return;\n-      }\n-  }\n-\n-  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n     {\n-      const 'rtype_name` * restrict bbase_y;\n-      'rtype_name` * restrict dest_y;\n-      const 'rtype_name` * restrict abase_n;\n-      'rtype_name` bbase_yn;\n+      const int m = xcount, n = ycount, k = count, ldc = rystride;\n+      const 'rtype_name` one = 1, zero = 0;\n+      const int lda = (axstride == 1) ? aystride : axstride,\n+\t\tldb = (bxstride == 1) ? bystride : bxstride;\n \n-      if (rystride == xcount)\n-\tmemset (dest, 0, (sizeof ('rtype_name`) * xcount * ycount));\n-      else\n+      if (lda > 0 && ldb > 0 && ldc > 0 && m > 1 && n > 1 && k > 1)\n \t{\n-\t  for (y = 0; y < ycount; y++)\n-\t    for (x = 0; x < xcount; x++)\n-\t      dest[x + y*rystride] = ('rtype_name`)0;\n+\t  assert (gemm != NULL);\n+\t  gemm (axstride == 1 ? \"N\" : \"T\", bxstride == 1 ? \"N\" : \"T\", &m,\n+\t\t&n, &k,\t&one, abase, &lda, bbase, &ldb, &zero, dest,\n+\t\t&ldc, 1, 1);\n+\t  return;\n \t}\n+    }\n \n-      for (y = 0; y < ycount; y++)\n+  if (rxstride == 1 && axstride == 1 && bxstride == 1)\n+    {\n+      /* This block of code implements a tuned matmul, derived from\n+         Superscalar GEMM-based level 3 BLAS,  Beta version 0.1\n+\n+               Bo Kagstrom and Per Ling\n+               Department of Computing Science\n+               Umea University\n+               S-901 87 Umea, Sweden\n+\n+\t from netlib.org, translated to C, and modified for matmul.m4.  */\n+\n+      const 'rtype_name` *a, *b;\n+      'rtype_name` *c;\n+      const index_type m = xcount, n = ycount, k = count;\n+\n+      /* System generated locals */\n+      index_type a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset,\n+\t\t i1, i2, i3, i4, i5, i6;\n+\n+      /* Local variables */\n+      'rtype_name` t1[65536], /* was [256][256] */\n+\t\t f11, f12, f21, f22, f31, f32, f41, f42,\n+\t\t f13, f14, f23, f24, f33, f34, f43, f44;\n+      index_type i, j, l, ii, jj, ll;\n+      index_type isec, jsec, lsec, uisec, ujsec, ulsec;\n+\n+      a = abase;\n+      b = bbase;\n+      c = retarray->base_addr;\n+\n+      /* Parameter adjustments */\n+      c_dim1 = rystride;\n+      c_offset = 1 + c_dim1;\n+      c -= c_offset;\n+      a_dim1 = aystride;\n+      a_offset = 1 + a_dim1;\n+      a -= a_offset;\n+      b_dim1 = bystride;\n+      b_offset = 1 + b_dim1;\n+      b -= b_offset;\n+\n+      /* Early exit if possible */\n+      if (m == 0 || n == 0 || k == 0)\n+\treturn;\n+\n+      /* Empty c first.  */\n+      for (j=1; j<=n; j++)\n+\tfor (i=1; i<=m; i++)\n+\t  c[i + j * c_dim1] = ('rtype_name`)0;\n+\n+      /* Start turning the crank. */\n+      i1 = n;\n+      for (jj = 1; jj <= i1; jj += 512)\n \t{\n-\t  bbase_y = bbase + y*bystride;\n-\t  dest_y = dest + y*rystride;\n-\t  for (n = 0; n < count; n++)\n+\t  /* Computing MIN */\n+\t  i2 = 512;\n+\t  i3 = n - jj + 1;\n+\t  jsec = min(i2,i3);\n+\t  ujsec = jsec - jsec % 4;\n+\t  i2 = k;\n+\t  for (ll = 1; ll <= i2; ll += 256)\n \t    {\n-\t      abase_n = abase + n*aystride;\n-\t      bbase_yn = bbase_y[n];\n-\t      for (x = 0; x < xcount; x++)\n+\t      /* Computing MIN */\n+\t      i3 = 256;\n+\t      i4 = k - ll + 1;\n+\t      lsec = min(i3,i4);\n+\t      ulsec = lsec - lsec % 2;\n+\n+\t      i3 = m;\n+\t      for (ii = 1; ii <= i3; ii += 256)\n \t\t{\n-\t\t  dest_y[x] += abase_n[x] * bbase_yn;\n+\t\t  /* Computing MIN */\n+\t\t  i4 = 256;\n+\t\t  i5 = m - ii + 1;\n+\t\t  isec = min(i4,i5);\n+\t\t  uisec = isec - isec % 2;\n+\t\t  i4 = ll + ulsec - 1;\n+\t\t  for (l = ll; l <= i4; l += 2)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 2)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t\ta[i + (l + 1) * a_dim1];\n+\t\t\t  t1[l - ll + 1 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + ((i - ii + 2) << 8) - 257] =\n+\t\t\t\t\ta[i + 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  t1[l - ll + 1 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + l * a_dim1];\n+\t\t\t  t1[l - ll + 2 + (isec << 8) - 257] =\n+\t\t\t\t    a[ii + isec - 1 + (l + 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ulsec < lsec)\n+\t\t    {\n+\t\t      i4 = ii + isec - 1;\n+\t\t      for (i = ii; i<= i4; ++i)\n+\t\t\t{\n+\t\t\t  t1[lsec + ((i - ii + 1) << 8) - 257] =\n+\t\t\t\t    a[i + (ll + lsec - 1) * a_dim1];\n+\t\t\t}\n+\t\t    }\n+\n+\t\t  uisec = isec - isec % 4;\n+\t\t  i4 = jj + ujsec - 1;\n+\t\t  for (j = jj; j <= i4; j += 4)\n+\t\t    {\n+\t\t      i5 = ii + uisec - 1;\n+\t\t      for (i = ii; i <= i5; i += 4)\n+\t\t\t{\n+\t\t\t  f11 = c[i + j * c_dim1];\n+\t\t\t  f21 = c[i + 1 + j * c_dim1];\n+\t\t\t  f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t  f22 = c[i + 1 + (j + 1) * c_dim1];\n+\t\t\t  f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t  f23 = c[i + 1 + (j + 2) * c_dim1];\n+\t\t\t  f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t  f24 = c[i + 1 + (j + 3) * c_dim1];\n+\t\t\t  f31 = c[i + 2 + j * c_dim1];\n+\t\t\t  f41 = c[i + 3 + j * c_dim1];\n+\t\t\t  f32 = c[i + 2 + (j + 1) * c_dim1];\n+\t\t\t  f42 = c[i + 3 + (j + 1) * c_dim1];\n+\t\t\t  f33 = c[i + 2 + (j + 2) * c_dim1];\n+\t\t\t  f43 = c[i + 3 + (j + 2) * c_dim1];\n+\t\t\t  f34 = c[i + 2 + (j + 3) * c_dim1];\n+\t\t\t  f44 = c[i + 3 + (j + 3) * c_dim1];\n+\t\t\t  i6 = ll + lsec - 1;\n+\t\t\t  for (l = ll; l <= i6; ++l)\n+\t\t\t    {\n+\t\t\t      f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f22 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f23 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f24 += t1[l - ll + 1 + ((i - ii + 2) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + j * b_dim1];\n+\t\t\t      f32 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f42 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 1) * b_dim1];\n+\t\t\t      f33 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f43 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 2) * b_dim1];\n+\t\t\t      f34 += t1[l - ll + 1 + ((i - ii + 3) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t      f44 += t1[l - ll + 1 + ((i - ii + 4) << 8) - 257]\n+\t\t\t\t      * b[l + (j + 3) * b_dim1];\n+\t\t\t    }\n+\t\t\t  c[i + j * c_dim1] = f11;\n+\t\t\t  c[i + 1 + j * c_dim1] = f21;\n+\t\t\t  c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t  c[i + 1 + (j + 1) * c_dim1] = f22;\n+\t\t\t  c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t  c[i + 1 + (j + 2) * c_dim1] = f23;\n+\t\t\t  c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t  c[i + 1 + (j + 3) * c_dim1] = f24;\n+\t\t\t  c[i + 2 + j * c_dim1] = f31;\n+\t\t\t  c[i + 3 + j * c_dim1] = f41;\n+\t\t\t  c[i + 2 + (j + 1) * c_dim1] = f32;\n+\t\t\t  c[i + 3 + (j + 1) * c_dim1] = f42;\n+\t\t\t  c[i + 2 + (j + 2) * c_dim1] = f33;\n+\t\t\t  c[i + 3 + (j + 2) * c_dim1] = f43;\n+\t\t\t  c[i + 2 + (j + 3) * c_dim1] = f34;\n+\t\t\t  c[i + 3 + (j + 3) * c_dim1] = f44;\n+\t\t\t}\n+\t\t      if (uisec < isec)\n+\t\t\t{\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f12 = c[i + (j + 1) * c_dim1];\n+\t\t\t      f13 = c[i + (j + 2) * c_dim1];\n+\t\t\t      f14 = c[i + (j + 3) * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f12 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 1) * b_dim1];\n+\t\t\t\t  f13 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 2) * b_dim1];\n+\t\t\t\t  f14 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + (j + 3) * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + (j + 1) * c_dim1] = f12;\n+\t\t\t      c[i + (j + 2) * c_dim1] = f13;\n+\t\t\t      c[i + (j + 3) * c_dim1] = f14;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t  if (ujsec < jsec)\n+\t\t    {\n+\t\t      i4 = jj + jsec - 1;\n+\t\t      for (j = jj + ujsec; j <= i4; ++j)\n+\t\t\t{\n+\t\t\t  i5 = ii + uisec - 1;\n+\t\t\t  for (i = ii; i <= i5; i += 4)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      f21 = c[i + 1 + j * c_dim1];\n+\t\t\t      f31 = c[i + 2 + j * c_dim1];\n+\t\t\t      f41 = c[i + 3 + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f21 += t1[l - ll + 1 + ((i - ii + 2) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f31 += t1[l - ll + 1 + ((i - ii + 3) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t  f41 += t1[l - ll + 1 + ((i - ii + 4) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t      c[i + 1 + j * c_dim1] = f21;\n+\t\t\t      c[i + 2 + j * c_dim1] = f31;\n+\t\t\t      c[i + 3 + j * c_dim1] = f41;\n+\t\t\t    }\n+\t\t\t  i5 = ii + isec - 1;\n+\t\t\t  for (i = ii + uisec; i <= i5; ++i)\n+\t\t\t    {\n+\t\t\t      f11 = c[i + j * c_dim1];\n+\t\t\t      i6 = ll + lsec - 1;\n+\t\t\t      for (l = ll; l <= i6; ++l)\n+\t\t\t\t{\n+\t\t\t\t  f11 += t1[l - ll + 1 + ((i - ii + 1) << 8) -\n+\t\t\t\t\t  257] * b[l + j * b_dim1];\n+\t\t\t\t}\n+\t\t\t      c[i + j * c_dim1] = f11;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n \t\t}\n \t    }\n \t}\n+      return;\n     }\n   else if (rxstride == 1 && aystride == 1 && bxstride == 1)\n     {\n@@ -336,7 +569,9 @@ sinclude(`matmul_asm_'rtype_code`.m4')dnl\n \tfor (n = 0; n < count; n++)\n \t  for (x = 0; x < xcount; x++)\n \t    /* dest[x,y] += a[x,n] * b[n,y] */\n-\t    dest[x*rxstride + y*rystride] += abase[x*axstride + n*aystride] * bbase[n*bxstride + y*bystride];\n+\t    dest[x*rxstride + y*rystride] +=\n+\t\t\t\t\tabase[x*axstride + n*aystride] *\n+\t\t\t\t\tbbase[n*bxstride + y*bystride];\n     }\n   else if (GFC_DESCRIPTOR_RANK (a) == 1)\n     {\n@@ -373,6 +608,5 @@ sinclude(`matmul_asm_'rtype_code`.m4')dnl\n \t    }\n \t}\n     }\n-}\n-\n-#endif'\n+}'\n+#endif"}]}