{"sha": "9355fb29fc756807a775f9e8f71124071676c8e4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTM1NWZiMjlmYzc1NjgwN2E3NzVmOWU4ZjcxMTI0MDcxNjc2YzhlNA==", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-02-09T14:06:02Z"}, "committer": {"name": "Philip Herron", "email": "herron.philip@googlemail.com", "date": "2021-02-10T13:21:16Z"}, "message": "Enable -frust-dump-all option for debugging\n\nWe output each debug IR to file which makes it easier to debug larger\ntest cases. Beaware not all dumps are complete such as name resolution\nis not implemented yet, HIR is badly formatted and type resolution dump is\nnot finished.", "tree": {"sha": "b8110ae769dcd17a110520a3a48592218a2c283e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b8110ae769dcd17a110520a3a48592218a2c283e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9355fb29fc756807a775f9e8f71124071676c8e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9355fb29fc756807a775f9e8f71124071676c8e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9355fb29fc756807a775f9e8f71124071676c8e4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9355fb29fc756807a775f9e8f71124071676c8e4/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c8b9c41bf248b952b0260c7b2f1e4c24cdaffae1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c8b9c41bf248b952b0260c7b2f1e4c24cdaffae1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c8b9c41bf248b952b0260c7b2f1e4c24cdaffae1"}], "stats": {"total": 336, "additions": 230, "deletions": 106}, "files": [{"sha": "277cd8baec2b96d286848938e6791ea402974903", "filename": "gcc/rust/parse/rust-parse-impl.h", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9355fb29fc756807a775f9e8f71124071676c8e4/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9355fb29fc756807a775f9e8f71124071676c8e4/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse-impl.h?ref=9355fb29fc756807a775f9e8f71124071676c8e4", "patch": "@@ -14459,7 +14459,7 @@ Parser<ManagedTokenSource>::done_end ()\n // Dumps lexer output to stderr.\n template <typename ManagedTokenSource>\n void\n-Parser<ManagedTokenSource>::debug_dump_lex_output ()\n+Parser<ManagedTokenSource>::debug_dump_lex_output (std::ostream &out)\n {\n   /* TODO: a better implementation of \"lexer dump\" (as in dump what was actually\n    * tokenised) would actually be to \"write\" a token to a file every time\n@@ -14470,6 +14470,9 @@ Parser<ManagedTokenSource>::debug_dump_lex_output ()\n \n   while (true)\n     {\n+      if (tok->get_id () == Rust::END_OF_FILE)\n+\tbreak;\n+\n       bool has_text = tok->get_id () == Rust::IDENTIFIER\n \t\t      || tok->get_id () == Rust::INT_LITERAL\n \t\t      || tok->get_id () == Rust::FLOAT_LITERAL\n@@ -14480,16 +14483,13 @@ Parser<ManagedTokenSource>::debug_dump_lex_output ()\n \n       Location loc = tok->get_locus ();\n \n-      fprintf (stderr, \"<id=%s%s, %s\\n\", tok->token_id_to_str (),\n-\t       has_text ? (std::string (\", text=\") + tok->get_str ()\n-\t\t\t   + std::string (\", typehint=\")\n-\t\t\t   + std::string (tok->get_type_hint_str ()))\n-\t\t\t    .c_str ()\n-\t\t\t: \"\",\n-\t       lexer.get_line_map ()->to_string (loc).c_str ());\n-\n-      if (tok->get_id () == Rust::END_OF_FILE)\n-\tbreak;\n+      out << \"<id=\";\n+      out << tok->token_id_to_str ();\n+      out << has_text ? (std::string (\", text=\") + tok->get_str ()\n+\t\t\t + std::string (\", typehint=\")\n+\t\t\t + std::string (tok->get_type_hint_str ()))\n+\t\t      : \"\";\n+      out << lexer.get_line_map ()->to_string (loc);\n \n       lexer.skip_token ();\n       tok = lexer.peek_token ();\n@@ -14499,9 +14499,9 @@ Parser<ManagedTokenSource>::debug_dump_lex_output ()\n // Parses crate and dumps AST to stderr, recursively.\n template <typename ManagedTokenSource>\n void\n-Parser<ManagedTokenSource>::debug_dump_ast_output (AST::Crate &crate)\n+Parser<ManagedTokenSource>::debug_dump_ast_output (AST::Crate &crate,\n+\t\t\t\t\t\t   std::ostream &out)\n {\n-  // print crate \"as string\", which then calls each item as string, etc.\n-  fprintf (stderr, \"%s\", crate.as_string ().c_str ());\n+  out << crate.as_string ();\n }\n } // namespace Rust"}, {"sha": "b811c7763fb89d619b5cdaf3d47843b6328edec6", "filename": "gcc/rust/parse/rust-parse.h", "status": "modified", "additions": 37, "deletions": 21, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9355fb29fc756807a775f9e8f71124071676c8e4/gcc%2Frust%2Fparse%2Frust-parse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9355fb29fc756807a775f9e8f71124071676c8e4/gcc%2Frust%2Fparse%2Frust-parse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse.h?ref=9355fb29fc756807a775f9e8f71124071676c8e4", "patch": "@@ -166,22 +166,30 @@ template <typename ManagedTokenSource> class Parser\n   parse_generic_params_in_angles ();\n   std::vector<std::unique_ptr<AST::GenericParam> > parse_generic_params ();\n   template <typename EndTokenPred>\n-  std::vector<std::unique_ptr<AST::GenericParam> > parse_generic_params (EndTokenPred is_end_token);\n+  std::vector<std::unique_ptr<AST::GenericParam> >\n+  parse_generic_params (EndTokenPred is_end_token);\n   std::vector<std::unique_ptr<AST::LifetimeParam> > parse_lifetime_params ();\n   template <typename EndTokenPred>\n-  std::vector<std::unique_ptr<AST::LifetimeParam> > parse_lifetime_params (EndTokenPred is_end_token);\n+  std::vector<std::unique_ptr<AST::LifetimeParam> >\n+  parse_lifetime_params (EndTokenPred is_end_token);\n   std::vector<AST::LifetimeParam> parse_lifetime_params_objs ();\n   template <typename EndTokenPred>\n-  std::vector<AST::LifetimeParam> parse_lifetime_params_objs (EndTokenPred is_end_token);\n+  std::vector<AST::LifetimeParam>\n+  parse_lifetime_params_objs (EndTokenPred is_end_token);\n   template <typename ParseFunction, typename EndTokenPred>\n-  auto parse_non_ptr_sequence (ParseFunction parsing_function, EndTokenPred is_end_token, std::string error_msg = \"failed to parse generic param in generic params\") -> std::vector<decltype(parsing_function ())>;\n+  auto parse_non_ptr_sequence (\n+    ParseFunction parsing_function, EndTokenPred is_end_token,\n+    std::string error_msg = \"failed to parse generic param in generic params\")\n+    -> std::vector<decltype (parsing_function ())>;\n   AST::LifetimeParam parse_lifetime_param ();\n   std::vector<std::unique_ptr<AST::TypeParam> > parse_type_params ();\n   template <typename EndTokenPred>\n-  std::vector<std::unique_ptr<AST::TypeParam> > parse_type_params (EndTokenPred is_end_token);\n+  std::vector<std::unique_ptr<AST::TypeParam> >\n+  parse_type_params (EndTokenPred is_end_token);\n   std::unique_ptr<AST::TypeParam> parse_type_param ();\n   template <typename EndTokenPred>\n-  std::vector<AST::FunctionParam> parse_function_params (EndTokenPred is_end_token);\n+  std::vector<AST::FunctionParam>\n+  parse_function_params (EndTokenPred is_end_token);\n   AST::FunctionParam parse_function_param ();\n   std::unique_ptr<AST::Type> parse_function_return_type ();\n   AST::WhereClause parse_where_clause ();\n@@ -192,7 +200,8 @@ template <typename ManagedTokenSource> class Parser\n   parse_type_bound_where_clause_item ();\n   std::vector<AST::LifetimeParam> parse_for_lifetimes ();\n   template <typename EndTokenPred>\n-  std::vector<std::unique_ptr<AST::TypeParamBound> > parse_type_param_bounds (EndTokenPred is_end_token);\n+  std::vector<std::unique_ptr<AST::TypeParamBound> >\n+  parse_type_param_bounds (EndTokenPred is_end_token);\n   std::vector<std::unique_ptr<AST::TypeParamBound> > parse_type_param_bounds ();\n   std::unique_ptr<AST::TypeParamBound> parse_type_param_bound ();\n   std::unique_ptr<AST::TraitBound> parse_trait_bound ();\n@@ -215,7 +224,8 @@ template <typename ManagedTokenSource> class Parser\n   parse_enum (AST::Visibility vis, std::vector<AST::Attribute> outer_attrs);\n   std::vector<std::unique_ptr<AST::EnumItem> > parse_enum_items ();\n   template <typename EndTokenPred>\n-  std::vector<std::unique_ptr<AST::EnumItem> > parse_enum_items (EndTokenPred is_end_token);\n+  std::vector<std::unique_ptr<AST::EnumItem> >\n+  parse_enum_items (EndTokenPred is_end_token);\n   std::unique_ptr<AST::EnumItem> parse_enum_item ();\n   std::unique_ptr<AST::Union>\n   parse_union (AST::Visibility vis, std::vector<AST::Attribute> outer_attrs);\n@@ -247,8 +257,9 @@ template <typename ManagedTokenSource> class Parser\n   parse_extern_block (AST::Visibility vis,\n \t\t      std::vector<AST::Attribute> outer_attrs);\n   std::unique_ptr<AST::ExternalItem> parse_external_item ();\n-  AST::NamedFunctionParam parse_named_function_param (\n-    std::vector<AST::Attribute> outer_attrs = std::vector<AST::Attribute> ());\n+  AST::NamedFunctionParam\n+  parse_named_function_param (std::vector<AST::Attribute> outer_attrs\n+\t\t\t      = std::vector<AST::Attribute> ());\n   AST::Method parse_method ();\n \n   // Expression-related (Pratt parsed)\n@@ -272,9 +283,11 @@ template <typename ManagedTokenSource> class Parser\n \t\t   = std::vector<AST::Attribute> (),\n \t\t   ParseRestrictions restrictions = ParseRestrictions ());\n   std::unique_ptr<AST::ArithmeticOrLogicalExpr>\n-  parse_arithmetic_or_logical_expr (const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n-\t\t\t  std::vector<AST::Attribute> outer_attrs, AST::ArithmeticOrLogicalExpr::ExprType expr_type,\n-\t\t\t  ParseRestrictions restrictions = ParseRestrictions ());\n+  parse_arithmetic_or_logical_expr (\n+    const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n+    std::vector<AST::Attribute> outer_attrs,\n+    AST::ArithmeticOrLogicalExpr::ExprType expr_type,\n+    ParseRestrictions restrictions = ParseRestrictions ());\n   std::unique_ptr<AST::ArithmeticOrLogicalExpr>\n   parse_binary_plus_expr (const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n \t\t\t  std::vector<AST::Attribute> outer_attrs,\n@@ -368,10 +381,11 @@ template <typename ManagedTokenSource> class Parser\n   parse_assig_expr (const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n \t\t    std::vector<AST::Attribute> outer_attrs,\n \t\t    ParseRestrictions restrictions = ParseRestrictions ());\n-  std::unique_ptr<AST::CompoundAssignmentExpr>\n-  parse_compound_assignment_expr (const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n-\t\t\t std::vector<AST::Attribute> outer_attrs, AST::CompoundAssignmentExpr::ExprType expr_type,\n-\t\t\t ParseRestrictions restrictions = ParseRestrictions ());\n+  std::unique_ptr<AST::CompoundAssignmentExpr> parse_compound_assignment_expr (\n+    const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n+    std::vector<AST::Attribute> outer_attrs,\n+    AST::CompoundAssignmentExpr::ExprType expr_type,\n+    ParseRestrictions restrictions = ParseRestrictions ());\n   std::unique_ptr<AST::CompoundAssignmentExpr>\n   parse_plus_assig_expr (const_TokenPtr tok, std::unique_ptr<AST::Expr> left,\n \t\t\t std::vector<AST::Attribute> outer_attrs,\n@@ -563,7 +577,8 @@ template <typename ManagedTokenSource> class Parser\n   std::unique_ptr<AST::Type> parse_paren_prefixed_type ();\n   std::unique_ptr<AST::TypeNoBounds> parse_paren_prefixed_type_no_bounds ();\n   std::unique_ptr<AST::Type> parse_for_prefixed_type ();\n-  AST::MaybeNamedParam parse_maybe_named_param (std::vector<AST::Attribute> outer_attrs);\n+  AST::MaybeNamedParam\n+  parse_maybe_named_param (std::vector<AST::Attribute> outer_attrs);\n \n   // Statement-related\n   std::unique_ptr<AST::Stmt> parse_stmt ();\n@@ -593,7 +608,8 @@ template <typename ManagedTokenSource> class Parser\n   std::unique_ptr<AST::TupleStructItems> parse_tuple_struct_items ();\n   AST::StructPatternElements parse_struct_pattern_elems ();\n   std::unique_ptr<AST::StructPatternField> parse_struct_pattern_field ();\n-  std::unique_ptr<AST::StructPatternField> parse_struct_pattern_field_partial (std::vector<AST::Attribute> outer_attrs);\n+  std::unique_ptr<AST::StructPatternField>\n+  parse_struct_pattern_field_partial (std::vector<AST::Attribute> outer_attrs);\n \n   int left_binding_power (const_TokenPtr token);\n \n@@ -609,8 +625,8 @@ template <typename ManagedTokenSource> class Parser\n   AST::Crate parse_crate ();\n \n   // Dumps all lexer output.\n-  void debug_dump_lex_output ();\n-  void debug_dump_ast_output (AST::Crate &crate);\n+  void debug_dump_lex_output (std::ostream &out);\n+  void debug_dump_ast_output (AST::Crate &crate, std::ostream &out);\n \n private:\n   // The token source (usually lexer) associated with the parser."}, {"sha": "6960556eb5270ba92c153ecaa99ab98cb43231a6", "filename": "gcc/rust/rust-session-manager.cc", "status": "modified", "additions": 146, "deletions": 60, "changes": 206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9355fb29fc756807a775f9e8f71124071676c8e4/gcc%2Frust%2Frust-session-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9355fb29fc756807a775f9e8f71124071676c8e4/gcc%2Frust%2Frust-session-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-session-manager.cc?ref=9355fb29fc756807a775f9e8f71124071676c8e4", "patch": "@@ -21,6 +21,8 @@\n #include \"rust-diagnostics.h\"\n #include \"diagnostic.h\"\n #include \"input.h\"\n+#include <fstream>\n+#include <sstream>\n \n #include \"target.h\"\n #include \"tm.h\"\n@@ -46,6 +48,13 @@ rust_get_backend ();\n \n namespace Rust {\n \n+const char *kLexDumpFile = \"gccrs.lex.dump\";\n+const char *kASTDumpFile = \"gccrs.ast.dump\";\n+const char *kASTExpandedDumpFile = \"gccrs.ast-expanded.dump\";\n+const char *kHIRDumpFile = \"gccrs.hir.dump\";\n+const char *kHIRTypeResolutionDumpFile = \"gccrs.type-resolution.dump\";\n+const char *kTargetOptionsDumpFile = \"gccrs.target-options.dump\";\n+\n // Implicitly enable a target_feature (and recursively enable dependencies).\n void\n Session::implicitly_enable_feature (std::string feature_name)\n@@ -309,9 +318,7 @@ Session::init ()\n  * itself. */\n void\n Session::init_options ()\n-{\n-  options.dump_option = CompileOptions::NO_DUMP;\n-}\n+{}\n \n // Handle option selection.\n bool\n@@ -357,39 +364,40 @@ Session::handle_option (\n bool\n Session::enable_dump (std::string arg)\n {\n-  /* FIXME: change dumping algorithm when new non-inhibiting dump system is\n-   * created */\n-  if (arg == \"all\")\n+  if (arg.empty ())\n     {\n-      rust_error_at (\n-\tLocation (),\n-\t\"dumping all is not supported as of now. choose %<lex%>, %<parse%>, \"\n-\t\"or %<target_options%>\");\n+      rust_error_at (Location (), \"dump option was not given a name. choose \"\n+\t\t\t\t  \"%<lex%>, %<parse%>, or %<target_options%>\");\n       return false;\n     }\n+\n+  if (arg == \"all\")\n+    {\n+      options.enable_all_dump_options ();\n+    }\n   else if (arg == \"lex\")\n     {\n-      options.dump_option = CompileOptions::LEXER_DUMP;\n+      options.enable_dump_option (CompileOptions::LEXER_DUMP);\n     }\n   else if (arg == \"parse\")\n     {\n-      options.dump_option = CompileOptions::PARSER_AST_DUMP;\n+      options.enable_dump_option (CompileOptions::PARSER_AST_DUMP);\n     }\n   else if (arg == \"register_plugins\")\n     {\n-      options.dump_option = CompileOptions::REGISTER_PLUGINS_DUMP;\n+      options.enable_dump_option (CompileOptions::REGISTER_PLUGINS_DUMP);\n     }\n   else if (arg == \"injection\")\n     {\n-      options.dump_option = CompileOptions::INJECTION_DUMP;\n+      options.enable_dump_option (CompileOptions::INJECTION_DUMP);\n     }\n   else if (arg == \"expansion\")\n     {\n-      options.dump_option = CompileOptions::EXPANSION_DUMP;\n+      options.enable_dump_option (CompileOptions::EXPANSION_DUMP);\n     }\n   else if (arg == \"resolution\")\n     {\n-      options.dump_option = CompileOptions::RESOLUTION_DUMP;\n+      options.enable_dump_option (CompileOptions::RESOLUTION_DUMP);\n     }\n   else if (arg == \"target_options\")\n     {\n@@ -398,17 +406,11 @@ Session::enable_dump (std::string arg)\n       // actual compile option\n       // options.target_data.dump_target_options();\n       // return false;\n-      options.dump_option = CompileOptions::TARGET_OPTION_DUMP;\n+      options.enable_dump_option (CompileOptions::TARGET_OPTION_DUMP);\n     }\n   else if (arg == \"hir\")\n     {\n-      options.dump_option = CompileOptions::HIR_DUMP;\n-    }\n-  else if (arg == \"\")\n-    {\n-      rust_error_at (Location (), \"dump option was not given a name. choose \"\n-\t\t\t\t  \"%<lex%>, %<parse%>, or %<target_options%>\");\n-      return false;\n+      options.enable_dump_option (CompileOptions::HIR_DUMP);\n     }\n   else\n     {\n@@ -460,24 +462,22 @@ Session::parse_file (const char *filename)\n   auto mappings = Analysis::Mappings::get ();\n   mappings->insert_ast_crate (&parsed_crate);\n \n-  // give a chance to give some debug\n-  switch (options.dump_option)\n+  if (options.dump_option_enabled (CompileOptions::LEXER_DUMP))\n+    {\n+      dump_lex (parser);\n+    }\n+  if (options.dump_option_enabled (CompileOptions::PARSER_AST_DUMP))\n+    {\n+      dump_ast (parser, parsed_crate);\n+    }\n+  if (options.dump_option_enabled (CompileOptions::TARGET_OPTION_DUMP))\n     {\n-    case CompileOptions::LEXER_DUMP:\n-      parser.debug_dump_lex_output ();\n-      // TODO: rewrite lexer dump or something so that it allows for the crate\n-      // to already be parsed\n-      break;\n-    case CompileOptions::PARSER_AST_DUMP:\n-      parser.debug_dump_ast_output (parsed_crate);\n-      break;\n-    case CompileOptions::TARGET_OPTION_DUMP:\n       options.target_data.dump_target_options ();\n-      return;\n-    default:\n-      break;\n     }\n \n+  if (saw_errors ())\n+    return;\n+\n   /* basic pipeline:\n    *  - lex\n    *  - parse\n@@ -497,36 +497,33 @@ Session::parse_file (const char *filename)\n   // register plugins pipeline stage\n   register_plugins (parsed_crate);\n   fprintf (stderr, \"\\033[0;31mSUCCESSFULLY REGISTERED PLUGINS \\n\\033[0m\");\n-\n-  if (options.dump_option == CompileOptions::REGISTER_PLUGINS_DUMP)\n+  if (options.dump_option_enabled (CompileOptions::REGISTER_PLUGINS_DUMP))\n     {\n       // TODO: what do I dump here?\n     }\n \n   // injection pipeline stage\n   injection (parsed_crate);\n   fprintf (stderr, \"\\033[0;31mSUCCESSFULLY FINISHED INJECTION \\n\\033[0m\");\n-\n-  if (options.dump_option == CompileOptions::INJECTION_DUMP)\n+  if (options.dump_option_enabled (CompileOptions::INJECTION_DUMP))\n     {\n       // TODO: what do I dump here? injected crate names?\n     }\n \n   // expansion pipeline stage\n   expansion (parsed_crate);\n   fprintf (stderr, \"\\033[0;31mSUCCESSFULLY FINISHED EXPANSION \\n\\033[0m\");\n-\n-  if (options.dump_option == CompileOptions::EXPANSION_DUMP)\n+  if (options.dump_option_enabled (CompileOptions::EXPANSION_DUMP))\n     {\n       // dump AST with expanded stuff\n       fprintf (stderr, \"BEGIN POST-EXPANSION AST DUMP\\n\");\n-      parser.debug_dump_ast_output (parsed_crate);\n+      dump_ast_expanded (parser, parsed_crate);\n       fprintf (stderr, \"END POST-EXPANSION AST DUMP\\n\");\n     }\n \n   // resolution pipeline stage\n   Resolver::NameResolution::Resolve (parsed_crate);\n-  if (options.dump_option == CompileOptions::RESOLUTION_DUMP)\n+  if (options.dump_option_enabled (CompileOptions::RESOLUTION_DUMP))\n     {\n       // TODO: what do I dump here? resolved names? AST with resolved names?\n     }\n@@ -536,22 +533,19 @@ Session::parse_file (const char *filename)\n \n   // lower AST to HIR\n   HIR::Crate hir = HIR::ASTLowering::Resolve (parsed_crate);\n-  if (options.dump_option == CompileOptions::HIR_DUMP)\n+  if (options.dump_option_enabled (CompileOptions::HIR_DUMP))\n     {\n-      fprintf (stderr, \"%s\", hir.as_string ().c_str ());\n-      return;\n+      dump_hir (hir);\n     }\n \n   if (saw_errors ())\n     return;\n \n   // type resolve\n   Resolver::TypeResolution::Resolve (hir);\n-  if (options.dump_option == CompileOptions::TYPE_RESOLUTION_DUMP)\n+  if (options.dump_option_enabled (CompileOptions::TYPE_RESOLUTION_DUMP))\n     {\n-      auto buf = Resolver::TypeResolverDump::go (hir);\n-      fprintf (stderr, \"%s\\n\", buf.c_str ());\n-      return;\n+      dump_type_resolution (hir);\n     }\n \n   // scan unused has to be done after type resolution since methods are resolved\n@@ -793,23 +787,115 @@ Session::expansion (AST::Crate &crate)\n   fprintf (stderr, \"finished expansion\\n\");\n }\n \n+void\n+Session::dump_lex (Parser<Lexer> &parser) const\n+{\n+  std::ofstream out;\n+  out.open (kLexDumpFile);\n+  if (out.fail ())\n+    {\n+      rust_error_at (Linemap::unknown_location (), \"cannot open %s:%m; ignored\",\n+\t\t     kLexDumpFile);\n+      return;\n+    }\n+\n+  // TODO: rewrite lexer dump or something so that it allows for the crate\n+  // to already be parsed\n+  parser.debug_dump_lex_output (out);\n+  out.close ();\n+}\n+\n+void\n+Session::dump_ast (Parser<Lexer> &parser, AST::Crate &crate) const\n+{\n+  std::ofstream out;\n+  out.open (kASTDumpFile);\n+  if (out.fail ())\n+    {\n+      rust_error_at (Linemap::unknown_location (), \"cannot open %s:%m; ignored\",\n+\t\t     kASTDumpFile);\n+      return;\n+    }\n+\n+  parser.debug_dump_ast_output (crate, out);\n+  out.close ();\n+}\n+\n+void\n+Session::dump_ast_expanded (Parser<Lexer> &parser, AST::Crate &crate) const\n+{\n+  std::ofstream out;\n+  out.open (kASTExpandedDumpFile);\n+  if (out.fail ())\n+    {\n+      rust_error_at (Linemap::unknown_location (), \"cannot open %s:%m; ignored\",\n+\t\t     kASTExpandedDumpFile);\n+      return;\n+    }\n+\n+  parser.debug_dump_ast_output (crate, out);\n+  out.close ();\n+}\n+\n+void\n+Session::dump_hir (HIR::Crate &hir) const\n+{\n+  std::ofstream out;\n+  out.open (kHIRDumpFile);\n+  if (out.fail ())\n+    {\n+      rust_error_at (Linemap::unknown_location (), \"cannot open %s:%m; ignored\",\n+\t\t     kHIRDumpFile);\n+      return;\n+    }\n+\n+  out << hir.as_string ();\n+  out.close ();\n+}\n+\n+void\n+Session::dump_type_resolution (HIR::Crate &hir) const\n+{\n+  std::ofstream out;\n+  out.open (kHIRTypeResolutionDumpFile);\n+  if (out.fail ())\n+    {\n+      rust_error_at (Linemap::unknown_location (), \"cannot open %s:%m; ignored\",\n+\t\t     kHIRTypeResolutionDumpFile);\n+      return;\n+    }\n+\n+  Resolver::TypeResolverDump::go (hir, out);\n+  out.close ();\n+}\n+\n void\n TargetOptions::dump_target_options () const\n {\n-  fprintf (stderr,\n-\t   \"\\033[0;31m--PREPARING TO DUMP ALL TARGET OPTIONS--\\n\\033[0m\");\n+  std::ofstream out;\n+  out.open (kTargetOptionsDumpFile);\n+  if (out.fail ())\n+    {\n+      rust_error_at (Linemap::unknown_location (), \"cannot open %s:%m; ignored\",\n+\t\t     kTargetOptionsDumpFile);\n+      return;\n+    }\n+\n+  if (features.empty ())\n+    {\n+      out << \"No target options available!\\n\";\n+    }\n+\n   for (const auto &pairs : features)\n     {\n       for (const auto &value : pairs.second)\n-\tfprintf (stderr, \"%s: \\\"%s\\\"\\n\", pairs.first.c_str (), value.c_str ());\n+\tout << pairs.first + \": \\\"\" + value + \"\\\"\\n\";\n \n       if (pairs.second.empty ())\n-\tfprintf (stderr, \"%s\\n\", pairs.first.c_str ());\n+\tout << pairs.first + \"\\n\";\n     }\n-  if (features.empty ())\n-    fprintf (stderr, \"No target options available!\\n\");\n \n-  fprintf (stderr, \"\\033[0;31m--END OF TARGET OPTION DUMP--\\n\\033[0m\");\n+  out.close ();\n }\n \n void"}, {"sha": "b7e081bb8249e82f820e68ff0c8195b2bee45f0d", "filename": "gcc/rust/rust-session-manager.h", "status": "modified", "additions": 31, "deletions": 9, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9355fb29fc756807a775f9e8f71124071676c8e4/gcc%2Frust%2Frust-session-manager.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9355fb29fc756807a775f9e8f71124071676c8e4/gcc%2Frust%2Frust-session-manager.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-session-manager.h?ref=9355fb29fc756807a775f9e8f71124071676c8e4", "patch": "@@ -116,8 +116,8 @@ struct TargetOptions\n   // Dump all target options to stderr.\n   void dump_target_options () const;\n \n-  /* Creates derived values and implicit enables after all target info is added\n-   * (e.g. \"unix\"). */\n+  /* Creates derived values and implicit enables after all target info is\n+   * added (e.g. \"unix\"). */\n   void init_derived_values ();\n \n   /* Enables all requirements for the feature given, and will enable feature\n@@ -162,13 +162,8 @@ struct TargetOptions\n // Defines compiler options (e.g. dump, etc.).\n struct CompileOptions\n {\n-  // TODO: use bitfield for smaller memory requirements?\n-\n-  /* FIXME: this is set up for \"instead of\" dumping - in future, dumps should\n-   * not inhibit compilation */\n-  enum DumpOptions\n+  enum DumpOption\n   {\n-    NO_DUMP,\n     LEXER_DUMP,\n     PARSER_AST_DUMP,\n     REGISTER_PLUGINS_DUMP,\n@@ -178,8 +173,9 @@ struct CompileOptions\n     TARGET_OPTION_DUMP,\n     HIR_DUMP,\n     TYPE_RESOLUTION_DUMP,\n+  };\n \n-  } dump_option;\n+  std::set<DumpOption> dump_options;\n \n   /* configuration options - actually useful for conditional compilation and\n    * whatever data related to target arch, features, os, family, env, endian,\n@@ -188,6 +184,26 @@ struct CompileOptions\n   bool enable_test = false;\n   bool debug_assertions = false;\n   bool proc_macro = false;\n+\n+  bool dump_option_enabled (DumpOption option) const\n+  {\n+    return dump_options.find (option) != dump_options.end ();\n+  }\n+\n+  void enable_dump_option (DumpOption option) { dump_options.insert (option); }\n+\n+  void enable_all_dump_options ()\n+  {\n+    enable_dump_option (DumpOption::LEXER_DUMP);\n+    enable_dump_option (DumpOption::PARSER_AST_DUMP);\n+    enable_dump_option (DumpOption::REGISTER_PLUGINS_DUMP);\n+    enable_dump_option (DumpOption::INJECTION_DUMP);\n+    enable_dump_option (DumpOption::EXPANSION_DUMP);\n+    enable_dump_option (DumpOption::RESOLUTION_DUMP);\n+    enable_dump_option (DumpOption::TARGET_OPTION_DUMP);\n+    enable_dump_option (DumpOption::HIR_DUMP);\n+    enable_dump_option (DumpOption::TYPE_RESOLUTION_DUMP);\n+  }\n };\n \n /* Defines a compiler session. This is for a single compiler invocation, so\n@@ -219,6 +235,12 @@ struct Session\n   void parse_file (const char *filename);\n   bool enable_dump (std::string arg);\n \n+  void dump_lex (Parser<Lexer> &parser) const;\n+  void dump_ast (Parser<Lexer> &parser, AST::Crate &crate) const;\n+  void dump_ast_expanded (Parser<Lexer> &parser, AST::Crate &crate) const;\n+  void dump_hir (HIR::Crate &crate) const;\n+  void dump_type_resolution (HIR::Crate &crate) const;\n+\n   void debug_dump_load_crates (Parser<Lexer> &parser);\n \n   void implicitly_enable_feature (std::string feature_name);"}, {"sha": "17774a7fab5460c7fe51c396640d9a97b000d54f", "filename": "gcc/rust/typecheck/rust-tycheck-dump.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9355fb29fc756807a775f9e8f71124071676c8e4/gcc%2Frust%2Ftypecheck%2Frust-tycheck-dump.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9355fb29fc756807a775f9e8f71124071676c8e4/gcc%2Frust%2Ftypecheck%2Frust-tycheck-dump.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tycheck-dump.h?ref=9355fb29fc756807a775f9e8f71124071676c8e4", "patch": "@@ -28,13 +28,13 @@ namespace Resolver {\n class TypeResolverDump : public TypeCheckBase\n {\n public:\n-  static std::string go (HIR::Crate &crate)\n+  static void go (HIR::Crate &crate, std::ofstream &out)\n   {\n     TypeResolverDump dumper;\n     for (auto &item : crate.items)\n       item->accept_vis (dumper);\n \n-    return dumper.dump;\n+    out << dumper.dump;\n   }\n \n   void visit (HIR::InherentImpl &impl_block) override"}]}