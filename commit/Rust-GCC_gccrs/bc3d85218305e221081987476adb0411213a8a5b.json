{"sha": "bc3d85218305e221081987476adb0411213a8a5b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmMzZDg1MjE4MzA1ZTIyMTA4MTk4NzQ3NmFkYjA0MTEyMTNhOGE1Yg==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-09-28T20:02:35Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-09-28T20:02:35Z"}, "message": "Include gvarargs.h, not varargs.h.\n\nDon't include string.h.\n(seg_align): Use bzero, not memset.\n\nFrom-SVN: r5505", "tree": {"sha": "44594457f316ab5d1a409ea34f7ca4771f74a15b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/44594457f316ab5d1a409ea34f7ca4771f74a15b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bc3d85218305e221081987476adb0411213a8a5b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc3d85218305e221081987476adb0411213a8a5b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc3d85218305e221081987476adb0411213a8a5b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc3d85218305e221081987476adb0411213a8a5b/comments", "author": null, "committer": null, "parents": [{"sha": "7e4849dad43cbc7bc90094a39fd32a78b1e0e7ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e4849dad43cbc7bc90094a39fd32a78b1e0e7ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e4849dad43cbc7bc90094a39fd32a78b1e0e7ee"}], "stats": {"total": 55, "additions": 27, "deletions": 28}, "files": [{"sha": "06141c4ab4dea63774b9451b62795f646d37a6fd", "filename": "gcc/bc-emit.c", "status": "modified", "additions": 27, "deletions": 28, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc3d85218305e221081987476adb0411213a8a5b/gcc%2Fbc-emit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc3d85218305e221081987476adb0411213a8a5b/gcc%2Fbc-emit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbc-emit.c?ref=bc3d85218305e221081987476adb0411213a8a5b", "patch": "@@ -19,9 +19,8 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n \n \n #include <stdio.h>\n-#include <varargs.h>\n-#include <string.h>\n #include \"config.h\"\n+#include \"gvarargs.h\"\n #include \"machmode.h\"\n #include \"rtl.h\"\n #include \"real.h\"\n@@ -35,8 +34,8 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #include \"bc-typecd.h\"\n #include \"bi-run.h\"\n \n-extern char *xmalloc(), *xrealloc();\n-extern void free();\n+extern char *xmalloc (), *xrealloc ();\n+extern void free ();\n \n extern struct obstack *rtl_obstack;\n \n@@ -111,7 +110,7 @@ sym_lookup (name)\n   int i;\n   struct bc_sym *s;\n \n-  i = hash(name);\n+  i = hash (name);\n   for (s = hashtab[i]; s; s = s->next)\n     if (!strcmp (s->name, name))\n       return s;\n@@ -168,9 +167,9 @@ seg_create ()\n {\n   struct bc_seg *result;\n \n-  result = (struct bc_seg *) xmalloc(sizeof (struct bc_seg));\n+  result = (struct bc_seg *) xmalloc (sizeof (struct bc_seg));\n   result->alloc = 256;\n-  result->data = xmalloc(result->alloc);\n+  result->data = xmalloc (result->alloc);\n   result->size = 0;\n   result->syms = 0;\n   result->relocs = 0;\n@@ -191,9 +190,9 @@ seg_align (seg, log)\n     {\n       while (seg->size > seg->alloc)\n \tseg->alloc *= 2;\n-      seg->data = xrealloc(seg->data, seg->alloc);\n+      seg->data = xrealloc (seg->data, seg->alloc);\n     }\n-  memset(seg->data + oldsize, 0, seg->size - oldsize);\n+  bzero (seg->data + oldsize, seg->size - oldsize);\n }\n \n \n@@ -245,13 +244,13 @@ seg_defsym (seg, name)\n   struct bc_sym *sym;\n   struct bc_segsym *segsym;\n \n-  sym = sym_lookup(name);\n+  sym = sym_lookup (name);\n   if (sym->defined)\n     return 0;\n \n   sym->defined = 1;\n   sym->val = seg->size;\n-  segsym = (struct bc_segsym *) xmalloc(sizeof (struct bc_segsym));\n+  segsym = (struct bc_segsym *) xmalloc (sizeof (struct bc_segsym));\n   segsym->sym = sym;\n   segsym->next = seg->syms;\n   seg->syms = segsym;\n@@ -270,8 +269,8 @@ seg_refsym (seg, name, offset)\n   struct bc_sym *sym;\n   struct bc_segreloc *segreloc;\n \n-  sym = sym_lookup(name);\n-  segreloc = (struct bc_segreloc *) xmalloc(sizeof (struct bc_segreloc));\n+  sym = sym_lookup (name);\n+  segreloc = (struct bc_segreloc *) xmalloc (sizeof (struct bc_segreloc));\n   segreloc->offset = seg->size;\n   segreloc->sym = sym;\n   segreloc->next = seg->relocs;\n@@ -289,10 +288,10 @@ seg_concat (result, seg)\n   struct bc_segsym *segsym;\n   struct bc_segreloc *segreloc;\n \n-  seg_align(result, MACHINE_SEG_ALIGN);\n+  seg_align (result, MACHINE_SEG_ALIGN);\n   fix = result->size;\n-  seg_data(result, seg->data, seg->size);\n-  free(seg->data);\n+  seg_data (result, seg->data, seg->size);\n+  free (seg->data);\n \n   /* Go through the symbols and relocs of SEG, adjusting their offsets\n      for their new location in RESULT. */\n@@ -315,7 +314,7 @@ seg_concat (result, seg)\n       result->relocs = seg->relocs;\n     }\n \n-  free((char *) seg);\n+  free ((char *) seg);\n }\n \n /* Write a segment to a file.  */\n@@ -352,7 +351,7 @@ bc_seg_write (seg, file)\n       while (segsym && segsym->sym->val == i)\n \t{\n \t  if (i % 8 != 0)\n-\t    putc('\\n', file);\n+\t    putc ('\\n', file);\n \n \t  BC_WRITE_SEGSYM (segsym, file);\n \t  segsym = segsym->next;\n@@ -690,7 +689,7 @@ bc_align_data (align)\n \n /* Emit data. */\n void\n-bc_emit_data(data, size)\n+bc_emit_data (data, size)\n      char *data;\n      unsigned int size;\n {\n@@ -702,37 +701,37 @@ void\n bc_emit_data_skip (size)\n      unsigned int size;\n {\n-  seg_skip(bc_data_seg, size);\n+  seg_skip (bc_data_seg, size);\n }\n \n /* Emit label definition in data. */\n int\n-bc_emit_data_labeldef(name)\n+bc_emit_data_labeldef (name)\n      char *name;\n {\n-  return seg_defsym(bc_data_seg, name);\n+  return seg_defsym (bc_data_seg, name);\n }\n \n /* Emit label reference in data. */\n void\n-bc_emit_data_labelref(name, offset)\n+bc_emit_data_labelref (name, offset)\n      char *name;\n      int offset;\n {\n-  seg_refsym(bc_data_seg, name, offset);\n+  seg_refsym (bc_data_seg, name, offset);\n }\n \n /* Emit a common block of the given name and size.  Note that\n    when the .o file is actually written non-global \"common\"\n    blocks will have to be turned into space in the data section.  */\n int\n-bc_emit_common(name, size)\n+bc_emit_common (name, size)\n      char *name;\n      unsigned int size;\n {\n   struct bc_sym *sym;\n \n-  sym = sym_lookup(name);\n+  sym = sym_lookup (name);\n   if (sym->defined)\n     return 0;\n \n@@ -744,12 +743,12 @@ bc_emit_common(name, size)\n \n /* Globalize the given label. */\n void\n-bc_globalize_label(name)\n+bc_globalize_label (name)\n      char *name;\n {\n   struct bc_sym *sym;\n \n-  sym = sym_lookup(name);\n+  sym = sym_lookup (name);\n   sym->global = 1;\n }\n "}]}