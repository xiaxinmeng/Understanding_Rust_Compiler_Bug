{"sha": "57904e87b934e9dd8f94e9a0c4b3e10f3a4863ec", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTc5MDRlODdiOTM0ZTlkZDhmOTRlOWEwYzRiM2UxMGYzYTQ4NjNlYw==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2017-10-25T07:08:12Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2017-10-25T07:08:12Z"}, "message": "tree-ssa-pre.c (need_eh_cleanup, [...]): Move inside...\n\n2017-10-25  Richard Biener  <rguenther@suse.de>\n\n\t* tree-ssa-pre.c (need_eh_cleanup, need_ab_cleanup, el_to_remove,\n\tel_to_fixup, el_todo, el_avail, el_avail_stack, eliminate_avail,\n\teliminate_push_avail, eliminate_insert): Move inside...\n\t(class eliminate_dom_walker): ... this class in preparation\n\tof move.\n\t(fini_eliminate): Remove by merging with ...\n\t(eliminate): ... this function.  Adjust for class changes.\n\t(pass_pre::execute): Remove fini_eliminate call.\n\t(pass_fre::execute): Likewise.\n\nFrom-SVN: r254068", "tree": {"sha": "75021edfd0419e395f052dee1f961ad3af69e707", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/75021edfd0419e395f052dee1f961ad3af69e707"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/57904e87b934e9dd8f94e9a0c4b3e10f3a4863ec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57904e87b934e9dd8f94e9a0c4b3e10f3a4863ec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/57904e87b934e9dd8f94e9a0c4b3e10f3a4863ec", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57904e87b934e9dd8f94e9a0c4b3e10f3a4863ec/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e921c7e5a670ccc758bf58d82065d224a98671d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e921c7e5a670ccc758bf58d82065d224a98671d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e921c7e5a670ccc758bf58d82065d224a98671d9"}], "stats": {"total": 190, "additions": 95, "deletions": 95}, "files": [{"sha": "9b749af5e6629b76d07acaeb1dade886ae56adfb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57904e87b934e9dd8f94e9a0c4b3e10f3a4863ec/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57904e87b934e9dd8f94e9a0c4b3e10f3a4863ec/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=57904e87b934e9dd8f94e9a0c4b3e10f3a4863ec", "patch": "@@ -1,3 +1,15 @@\n+2017-10-25  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-ssa-pre.c (need_eh_cleanup, need_ab_cleanup, el_to_remove,\n+\tel_to_fixup, el_todo, el_avail, el_avail_stack, eliminate_avail,\n+\teliminate_push_avail, eliminate_insert): Move inside...\n+\t(class eliminate_dom_walker): ... this class in preparation\n+\tof move.\n+\t(fini_eliminate): Remove by merging with ...\n+\t(eliminate): ... this function.  Adjust for class changes.\n+\t(pass_pre::execute): Remove fini_eliminate call.\n+\t(pass_fre::execute): Likewise.\n+\n 2017-10-24  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR target/82460"}, {"sha": "ad7a0f10f448c13f851d4e246fd758a33577b83c", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 83, "deletions": 95, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57904e87b934e9dd8f94e9a0c4b3e10f3a4863ec/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57904e87b934e9dd8f94e9a0c4b3e10f3a4863ec/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=57904e87b934e9dd8f94e9a0c4b3e10f3a4863ec", "patch": "@@ -551,12 +551,6 @@ static unsigned int get_expr_value_id (pre_expr);\n static object_allocator<bitmap_set> bitmap_set_pool (\"Bitmap sets\");\n static bitmap_obstack grand_bitmap_obstack;\n \n-/* Set of blocks with statements that have had their EH properties changed.  */\n-static bitmap need_eh_cleanup;\n-\n-/* Set of blocks with statements that have had their AB properties changed.  */\n-static bitmap need_ab_cleanup;\n-\n /* A three tuple {e, pred, v} used to cache phi translations in the\n    phi_translate_table.  */\n \n@@ -4042,27 +4036,61 @@ compute_avail (void)\n   free (worklist);\n }\n \n+class eliminate_dom_walker : public dom_walker\n+{\n+public:\n+  eliminate_dom_walker (cdi_direction direction, bool do_pre_);\n+  ~eliminate_dom_walker ();\n+\n+  virtual edge before_dom_children (basic_block);\n+  virtual void after_dom_children (basic_block);\n+\n+  tree eliminate_avail (tree op);\n+  void eliminate_push_avail (tree op);\n+  tree eliminate_insert (gimple_stmt_iterator *gsi, tree val);\n+\n+  bool do_pre;\n+  unsigned int el_todo;\n+\n+  /* Blocks with statements that have had their EH properties changed.  */\n+  bitmap need_eh_cleanup;\n+\n+  /* Blocks with statements that have had their AB properties changed.  */\n+  bitmap need_ab_cleanup;\n \n-/* Local state for the eliminate domwalk.  */\n-static vec<gimple *> el_to_remove;\n-static vec<gimple *> el_to_fixup;\n-static unsigned int el_todo;\n-static vec<tree> el_avail;\n-static vec<tree> el_avail_stack;\n+  auto_vec<gimple *> to_remove;\n+  auto_vec<gimple *> to_fixup;\n+  auto_vec<tree> avail;\n+  auto_vec<tree> avail_stack;\n+};\n+\n+eliminate_dom_walker::eliminate_dom_walker (cdi_direction direction,\n+\t\t\t\t\t    bool do_pre_)\n+  : dom_walker (direction), do_pre (do_pre_), el_todo (0)\n+{\n+  need_eh_cleanup = BITMAP_ALLOC (NULL);\n+  need_ab_cleanup = BITMAP_ALLOC (NULL);\n+}\n+\n+eliminate_dom_walker::~eliminate_dom_walker ()\n+{\n+  BITMAP_FREE (need_eh_cleanup);\n+  BITMAP_FREE (need_ab_cleanup);\n+}\n \n /* Return a leader for OP that is available at the current point of the\n    eliminate domwalk.  */\n \n-static tree\n-eliminate_avail (tree op)\n+tree\n+eliminate_dom_walker::eliminate_avail (tree op)\n {\n   tree valnum = VN_INFO (op)->valnum;\n   if (TREE_CODE (valnum) == SSA_NAME)\n     {\n       if (SSA_NAME_IS_DEFAULT_DEF (valnum))\n \treturn valnum;\n-      if (el_avail.length () > SSA_NAME_VERSION (valnum))\n-\treturn el_avail[SSA_NAME_VERSION (valnum)];\n+      if (avail.length () > SSA_NAME_VERSION (valnum))\n+\treturn avail[SSA_NAME_VERSION (valnum)];\n     }\n   else if (is_gimple_min_invariant (valnum))\n     return valnum;\n@@ -4071,27 +4099,27 @@ eliminate_avail (tree op)\n \n /* At the current point of the eliminate domwalk make OP available.  */\n \n-static void\n-eliminate_push_avail (tree op)\n+void\n+eliminate_dom_walker::eliminate_push_avail (tree op)\n {\n   tree valnum = VN_INFO (op)->valnum;\n   if (TREE_CODE (valnum) == SSA_NAME)\n     {\n-      if (el_avail.length () <= SSA_NAME_VERSION (valnum))\n-\tel_avail.safe_grow_cleared (SSA_NAME_VERSION (valnum) + 1);\n+      if (avail.length () <= SSA_NAME_VERSION (valnum))\n+\tavail.safe_grow_cleared (SSA_NAME_VERSION (valnum) + 1);\n       tree pushop = op;\n-      if (el_avail[SSA_NAME_VERSION (valnum)])\n-\tpushop = el_avail[SSA_NAME_VERSION (valnum)];\n-      el_avail_stack.safe_push (pushop);\n-      el_avail[SSA_NAME_VERSION (valnum)] = op;\n+      if (avail[SSA_NAME_VERSION (valnum)])\n+\tpushop = avail[SSA_NAME_VERSION (valnum)];\n+      avail_stack.safe_push (pushop);\n+      avail[SSA_NAME_VERSION (valnum)] = op;\n     }\n }\n \n /* Insert the expression recorded by SCCVN for VAL at *GSI.  Returns\n    the leader for the expression if insertion was successful.  */\n \n-static tree\n-eliminate_insert (gimple_stmt_iterator *gsi, tree val)\n+tree\n+eliminate_dom_walker::eliminate_insert (gimple_stmt_iterator *gsi, tree val)\n {\n   /* We can insert a sequence with a single assignment only.  */\n   gimple_seq stmts = VN_INFO (val)->expr;\n@@ -4171,25 +4199,15 @@ eliminate_insert (gimple_stmt_iterator *gsi, tree val)\n   return res;\n }\n \n-class eliminate_dom_walker : public dom_walker\n-{\n-public:\n-  eliminate_dom_walker (cdi_direction direction, bool do_pre_)\n-      : dom_walker (direction), do_pre (do_pre_) {}\n \n-  virtual edge before_dom_children (basic_block);\n-  virtual void after_dom_children (basic_block);\n-\n-  bool do_pre;\n-};\n \n /* Perform elimination for the basic-block B during the domwalk.  */\n \n edge\n eliminate_dom_walker::before_dom_children (basic_block b)\n {\n   /* Mark new bb.  */\n-  el_avail_stack.safe_push (NULL_TREE);\n+  avail_stack.safe_push (NULL_TREE);\n \n   /* Skip unreachable blocks marked unreachable during the SCCVN domwalk.  */\n   edge_iterator ei;\n@@ -4236,7 +4254,7 @@ eliminate_dom_walker::before_dom_children (basic_block b)\n \t  if (may_propagate_copy (res, sprime))\n \t    {\n \t      /* Mark the PHI for removal.  */\n-\t      el_to_remove.safe_push (phi);\n+\t      to_remove.safe_push (phi);\n \t      gsi_next (&gsi);\n \t      continue;\n \t    }\n@@ -4378,7 +4396,7 @@ eliminate_dom_walker::before_dom_children (basic_block b)\n \t      if (may_propagate_copy (lhs, sprime))\n \t\t{\n \t\t  /* Mark it for removal.  */\n-\t\t  el_to_remove.safe_push (stmt);\n+\t\t  to_remove.safe_push (stmt);\n \n \t\t  /* ???  Don't count copy/constant propagations.  */\n \t\t  if (gimple_assign_single_p (stmt)\n@@ -4493,7 +4511,7 @@ eliminate_dom_walker::before_dom_children (basic_block b)\n \t\t    }\n \n \t\t  /* Queue stmt for removal.  */\n-\t\t  el_to_remove.safe_push (stmt);\n+\t\t  to_remove.safe_push (stmt);\n \t\t  continue;\n \t\t}\n \t    }\n@@ -4601,7 +4619,7 @@ eliminate_dom_walker::before_dom_children (basic_block b)\n \t  stmt = gsi_stmt (gsi);\n \t  /* In case we folded the stmt away schedule the NOP for removal.  */\n \t  if (gimple_nop_p (stmt))\n-\t    el_to_remove.safe_push (stmt);\n+\t    to_remove.safe_push (stmt);\n \t}\n \n       /* Visit indirect calls and turn them into direct calls if\n@@ -4668,7 +4686,7 @@ eliminate_dom_walker::before_dom_children (basic_block b)\n \t     is needed to fix up the noreturn call.  */\n \t  if (!was_noreturn\n \t      && is_gimple_call (stmt) && gimple_call_noreturn_p (stmt))\n-\t    el_to_fixup.safe_push  (stmt);\n+\t    to_fixup.safe_push  (stmt);\n \t  /* When changing a condition or switch into one we know what\n \t     edge will be executed, schedule a cfg cleanup.  */\n \t  if ((gimple_code (stmt) == GIMPLE_COND\n@@ -4734,14 +4752,14 @@ void\n eliminate_dom_walker::after_dom_children (basic_block)\n {\n   tree entry;\n-  while ((entry = el_avail_stack.pop ()) != NULL_TREE)\n+  while ((entry = avail_stack.pop ()) != NULL_TREE)\n     {\n       tree valnum = VN_INFO (entry)->valnum;\n-      tree old = el_avail[SSA_NAME_VERSION (valnum)];\n+      tree old = avail[SSA_NAME_VERSION (valnum)];\n       if (old == entry)\n-\tel_avail[SSA_NAME_VERSION (valnum)] = NULL_TREE;\n+\tavail[SSA_NAME_VERSION (valnum)] = NULL_TREE;\n       else\n-\tel_avail[SSA_NAME_VERSION (valnum)] = entry;\n+\tavail[SSA_NAME_VERSION (valnum)] = entry;\n     }\n }\n \n@@ -4750,73 +4768,50 @@ eliminate_dom_walker::after_dom_children (basic_block)\n static unsigned int\n eliminate (bool do_pre)\n {\n-  need_eh_cleanup = BITMAP_ALLOC (NULL);\n-  need_ab_cleanup = BITMAP_ALLOC (NULL);\n-\n-  el_to_remove.create (0);\n-  el_to_fixup.create (0);\n-  el_todo = 0;\n-  el_avail.create (num_ssa_names);\n-  el_avail_stack.create (0);\n+  eliminate_dom_walker el (CDI_DOMINATORS, do_pre);\n+  el.avail.reserve (num_ssa_names);\n \n-  eliminate_dom_walker (CDI_DOMINATORS,\n-\t\t\tdo_pre).walk (cfun->cfg->x_entry_block_ptr);\n-\n-  el_avail.release ();\n-  el_avail_stack.release ();\n-\n-  return el_todo;\n-}\n-\n-/* Perform CFG cleanups made necessary by elimination.  */\n-\n-static unsigned \n-fini_eliminate (void)\n-{\n-  gimple_stmt_iterator gsi;\n-  gimple *stmt;\n-  unsigned todo = 0;\n+  el.walk (cfun->cfg->x_entry_block_ptr);\n \n   /* We cannot remove stmts during BB walk, especially not release SSA\n      names there as this confuses the VN machinery.  The stmts ending\n-     up in el_to_remove are either stores or simple copies.\n+     up in to_remove are either stores or simple copies.\n      Remove stmts in reverse order to make debug stmt creation possible.  */\n-  while (!el_to_remove.is_empty ())\n+  while (!el.to_remove.is_empty ())\n     {\n-      stmt = el_to_remove.pop ();\n+      gimple *stmt = el.to_remove.pop ();\n \n       if (dump_file && (dump_flags & TDF_DETAILS))\n \t{\n \t  fprintf (dump_file, \"Removing dead stmt \");\n \t  print_gimple_stmt (dump_file, stmt, 0, 0);\n \t}\n \n-      gsi = gsi_for_stmt (stmt);\n+      gimple_stmt_iterator gsi = gsi_for_stmt (stmt);\n       if (gimple_code (stmt) == GIMPLE_PHI)\n \tremove_phi_node (&gsi, true);\n       else\n \t{\n \t  basic_block bb = gimple_bb (stmt);\n \t  unlink_stmt_vdef (stmt);\n \t  if (gsi_remove (&gsi, true))\n-\t    bitmap_set_bit (need_eh_cleanup, bb->index);\n+\t    bitmap_set_bit (el.need_eh_cleanup, bb->index);\n \t  if (is_gimple_call (stmt) && stmt_can_make_abnormal_goto (stmt))\n-\t    bitmap_set_bit (need_ab_cleanup, bb->index);\n+\t    bitmap_set_bit (el.need_ab_cleanup, bb->index);\n \t  release_defs (stmt);\n \t}\n \n       /* Removing a stmt may expose a forwarder block.  */\n-      todo |= TODO_cleanup_cfg;\n+      el.el_todo |= TODO_cleanup_cfg;\n     }\n-  el_to_remove.release ();\n \n   /* Fixup stmts that became noreturn calls.  This may require splitting\n      blocks and thus isn't possible during the dominator walk.  Do this\n      in reverse order so we don't inadvertedly remove a stmt we want to\n      fixup by visiting a dominating now noreturn call first.  */\n-  while (!el_to_fixup.is_empty ())\n+  while (!el.to_fixup.is_empty ())\n     {\n-      stmt = el_to_fixup.pop ();\n+      gimple *stmt = el.to_fixup.pop ();\n \n       if (dump_file && (dump_flags & TDF_DETAILS))\n \t{\n@@ -4825,25 +4820,21 @@ fini_eliminate (void)\n \t}\n \n       if (fixup_noreturn_call (stmt))\n-\ttodo |= TODO_cleanup_cfg;\n+\tel.el_todo |= TODO_cleanup_cfg;\n     }\n-  el_to_fixup.release ();\n \n-  bool do_eh_cleanup = !bitmap_empty_p (need_eh_cleanup);\n-  bool do_ab_cleanup = !bitmap_empty_p (need_ab_cleanup);\n+  bool do_eh_cleanup = !bitmap_empty_p (el.need_eh_cleanup);\n+  bool do_ab_cleanup = !bitmap_empty_p (el.need_ab_cleanup);\n \n   if (do_eh_cleanup)\n-    gimple_purge_all_dead_eh_edges (need_eh_cleanup);\n+    gimple_purge_all_dead_eh_edges (el.need_eh_cleanup);\n \n   if (do_ab_cleanup)\n-    gimple_purge_all_dead_abnormal_call_edges (need_ab_cleanup);\n-\n-  BITMAP_FREE (need_eh_cleanup);\n-  BITMAP_FREE (need_ab_cleanup);\n+    gimple_purge_all_dead_abnormal_call_edges (el.need_ab_cleanup);\n \n   if (do_eh_cleanup || do_ab_cleanup)\n-    todo |= TODO_cleanup_cfg;\n-  return todo;\n+    el.el_todo |= TODO_cleanup_cfg;\n+  return el.el_todo;\n }\n \n /* Cheap DCE of a known set of possibly dead stmts.\n@@ -5043,7 +5034,6 @@ pass_pre::execute (function *fun)\n   clear_expression_ids ();\n \n   scev_finalize ();\n-  todo |= fini_eliminate ();\n   remove_dead_inserted_code ();\n   fini_pre ();\n   loop_optimizer_finalize ();\n@@ -5121,8 +5111,6 @@ pass_fre::execute (function *fun)\n   /* Remove all the redundant expressions.  */\n   todo |= eliminate (false);\n \n-  todo |= fini_eliminate ();\n-\n   scc_vn_restore_ssa_info ();\n   free_scc_vn ();\n "}]}