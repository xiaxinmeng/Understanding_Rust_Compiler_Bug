{"sha": "5c6546ca7d8cab1f1c129f5b55f709e2ceee0f94", "node_id": "C_kwDOANBUbNoAKDVjNjU0NmNhN2Q4Y2FiMWYxYzEyOWY1YjU1ZjcwOWUyY2VlZTBmOTQ", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-11-10T18:23:56Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-11-10T18:23:56Z"}, "message": "analyzer: new warning: -Wanalyzer-deref-before-check [PR99671]\n\nThis patch implements a new -Wanalyzer-deref-before-check within\n-fanalyzer.  It complains about code paths in which a pointer is checked\nfor NULL after it has already been dereferenced.\n\nFor example, for the testcase in PR 77432 the diagnostic emits:\nderef-before-check-1.c: In function 'test_from_pr77432':\nderef-before-check-1.c:6:8: warning: check of 'a' for NULL after already dereferencing it [-Wanalyzer-deref-before-check]\n    6 |     if (a)\n      |        ^\n  'test_from_pr77432': events 1-2\n    |\n    |    5 |     int b = *a;\n    |      |         ^\n    |      |         |\n    |      |         (1) pointer 'a' is dereferenced here\n    |    6 |     if (a)\n    |      |        ~\n    |      |        |\n    |      |        (2) pointer 'a' is checked for NULL here but it was already dereferenced at (1)\n    |\n\nand in PR 77425 we had an instance of this hidden behind a\nmacro, which the diagnostic complains about as follows:\n\nderef-before-check-pr77425.c: In function 'get_odr_type':\nderef-before-check-pr77425.c:35:10: warning: check of 'odr_types_ptr' for NULL after already dereferencing it [-Wanalyzer-deref-before-check]\n   35 |       if (odr_types_ptr)\n      |          ^\n  'get_odr_type': events 1-3\n    |\n    |   27 |   if (cond)\n    |      |      ^\n    |      |      |\n    |      |      (1) following 'false' branch...\n    |......\n    |   31 |   else if (other_cond)\n    |      |           ~~~~~~~~~~~\n    |      |           ||\n    |      |           |(2) ...to here\n    |      |           (3) following 'true' branch...\n    |\n  'get_odr_type': event 4\n    |\n    |   11 | #define odr_types (*odr_types_ptr)\n    |      |                   ~^~~~~~~~~~~~~~~\n    |      |                    |\n    |      |                    (4) ...to here\nderef-before-check-pr77425.c:33:7: note: in expansion of macro 'odr_types'\n    |   33 |       odr_types[val->id] = 0;\n    |      |       ^~~~~~~~~\n    |\n  'get_odr_type': event 5\n    |\n    |   11 | #define odr_types (*odr_types_ptr)\n    |      |                   ~^~~~~~~~~~~~~~~\n    |      |                    |\n    |      |                    (5) pointer 'odr_types_ptr' is dereferenced here\nderef-before-check-pr77425.c:33:7: note: in expansion of macro 'odr_types'\n    |   33 |       odr_types[val->id] = 0;\n    |      |       ^~~~~~~~~\n    |\n  'get_odr_type': event 6\n    |\n    |   35 |       if (odr_types_ptr)\n    |      |          ^\n    |      |          |\n    |      |          (6) pointer 'odr_types_ptr' is checked for NULL here but it was already dereferenced at (5)\n    |\n\ngcc/analyzer/ChangeLog:\n\tPR analyzer/99671\n\t* analyzer.opt (Wanalyzer-deref-before-check): New warning.\n\t* diagnostic-manager.cc\n\t(null_assignment_sm_context::set_next_state): Only add state\n\tchange events for transition to \"null\" state.\n\t(null_assignment_sm_context::is_transition_to_null): New.\n\t* engine.cc (impl_region_model_context::on_pop_frame): New.\n\t* exploded-graph.h (impl_region_model_context::on_pop_frame): New\n\tdecl.\n\t* program-state.cc (sm_state_map::clear_any_state): New.\n\t(sm_state_map::can_merge_with_p): New.\n\t(program_state::can_merge_with_p): Replace requirement that\n\tsm-states be equal in favor of an attempt to merge them.\n\t* program-state.h (sm_state_map::clear_any_state): New decl.\n\t(sm_state_map::can_merge_with_p): New decl.\n\t* region-model.cc (region_model::eval_condition): Make const.\n\t(region_model::pop_frame): Call ctxt->on_pop_frame.\n\t* region-model.h (region_model::eval_condition): Make const.\n\t(region_model_context::on_pop_frame): New vfunc.\n\t(noop_region_model_context::on_pop_frame): New.\n\t(region_model_context_decorator::on_pop_frame): New.\n\t* sm-malloc.cc (enum resource_state): Add RS_ASSUMED_NON_NULL.\n\t(allocation_state::dump_to_pp): Drop \"final\".\n\t(struct assumed_non_null_state): New subclass.\n\t(malloc_state_machine::m_assumed_non_null): New.\n\t(assumed_non_null_p): New.\n\t(class deref_before_check): New.\n\t(assumed_non_null_state::dump_to_pp): New.\n\t(malloc_state_machine::get_or_create_assumed_non_null_state_for_frame):\n\tNew.\n\t(malloc_state_machine::maybe_assume_non_null): New.\n\t(malloc_state_machine::on_stmt): Transition from start state to\n\t\"assumed-non-null\" state for pointers passed to\n\t__attribute__((nonnull)) arguments, and for pointers explicitly\n\tdereferenced.  Call maybe_complain_about_deref_before_check for\n\tpointers explicitly compared against NULL.\n\t(malloc_state_machine::maybe_complain_about_deref_before_check):\n\tNew.\n\t(malloc_state_machine::on_deallocator_call): Also transition\n\t\"assumed-non-null\" states to \"freed\".\n\t(malloc_state_machine::on_pop_frame): New.\n\t(malloc_state_machine::maybe_get_merged_states_nonequal): New.\n\t* sm-malloc.dot: Update for changes to sm-malloc.cc.\n\t* sm.h (state_machine::on_pop_frame): New.\n\t(state_machine::maybe_get_merged_state): New.\n\t(state_machine::maybe_get_merged_states_nonequal): New.\n\ngcc/ChangeLog:\n\t* doc/gcc/gcc-command-options/options-that-control-static-analysis.rst:\n\tAdd -Wanalyzer-deref-before-check.\n\ngcc/testsuite/ChangeLog:\n\t* gcc.dg/analyzer/deref-before-check-1.c: New test.\n\t* gcc.dg/analyzer/deref-before-check-2.c: New test.\n\t* gcc.dg/analyzer/deref-before-check-pr77425.c: New test.\n\t* gcc.dg/analyzer/malloc-1.c (test_51): New test.\n\ngcc/ChangeLog:\n\tPR analyzer/99671\n\t* tristate.h (tristate::is_unknown): New.\n\nSigned-off-by: David Malcolm <dmalcolm@redhat.com>", "tree": {"sha": "4fac12e29958d8edf7753513459258980c8fe0b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4fac12e29958d8edf7753513459258980c8fe0b7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5c6546ca7d8cab1f1c129f5b55f709e2ceee0f94", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c6546ca7d8cab1f1c129f5b55f709e2ceee0f94", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5c6546ca7d8cab1f1c129f5b55f709e2ceee0f94", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c6546ca7d8cab1f1c129f5b55f709e2ceee0f94/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7e3ce73849fef8b50efb427ec96f317e88c0e6cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e3ce73849fef8b50efb427ec96f317e88c0e6cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e3ce73849fef8b50efb427ec96f317e88c0e6cf"}], "stats": {"total": 876, "additions": 860, "deletions": 16}, "files": [{"sha": "58ad3262ebfaa663efed34e6187931d20fb2b283", "filename": "gcc/analyzer/analyzer.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c6546ca7d8cab1f1c129f5b55f709e2ceee0f94/gcc%2Fanalyzer%2Fanalyzer.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c6546ca7d8cab1f1c129f5b55f709e2ceee0f94/gcc%2Fanalyzer%2Fanalyzer.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fanalyzer.opt?ref=5c6546ca7d8cab1f1c129f5b55f709e2ceee0f94", "patch": "@@ -58,6 +58,10 @@ Wanalyzer-allocation-size\n Common Var(warn_analyzer_allocation_size) Init(1) Warning\n Warn about code paths in which a pointer to a buffer is assigned to an incompatible type.\n \n+Wanalyzer-deref-before-check\n+Common Var(warn_analyzer_deref_before_check) Init(1) Warning\n+Warn about code paths in which a pointer is checked for NULL after it has already been dereferenced.\n+\n Wanalyzer-double-fclose\n Common Var(warn_analyzer_double_fclose) Init(1) Warning\n Warn about code paths in which a stdio FILE can be closed more than once."}, {"sha": "f82dd3a434aee71d0e6532c17597219eba207486", "filename": "gcc/analyzer/diagnostic-manager.cc", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c6546ca7d8cab1f1c129f5b55f709e2ceee0f94/gcc%2Fanalyzer%2Fdiagnostic-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c6546ca7d8cab1f1c129f5b55f709e2ceee0f94/gcc%2Fanalyzer%2Fdiagnostic-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fdiagnostic-manager.cc?ref=5c6546ca7d8cab1f1c129f5b55f709e2ceee0f94", "patch": "@@ -1739,9 +1739,12 @@ struct null_assignment_sm_context : public sm_context\n     state_machine::state_t from = get_state (stmt, var);\n     if (from != m_sm.get_start_state ())\n       return;\n+    if (!is_transition_to_null (to))\n+      return;\n \n     const svalue *var_new_sval\n       = m_new_state->m_region_model->get_rvalue (var, NULL);\n+\n     const supernode *supernode = m_point->get_supernode ();\n     int stack_depth = m_point->get_stack_depth ();\n \n@@ -1764,6 +1767,8 @@ struct null_assignment_sm_context : public sm_context\n     state_machine::state_t from = get_state (stmt, sval);\n     if (from != m_sm.get_start_state ())\n       return;\n+    if (!is_transition_to_null (to))\n+      return;\n \n     const supernode *supernode = m_point->get_supernode ();\n     int stack_depth = m_point->get_stack_depth ();\n@@ -1834,6 +1839,13 @@ struct null_assignment_sm_context : public sm_context\n     return m_new_state;\n   }\n \n+  /* We only care about transitions to the \"null\" state\n+     within sm-malloc.  Special-case this.  */\n+  static bool is_transition_to_null (state_machine::state_t s)\n+  {\n+    return !strcmp (s->get_name (), \"null\");\n+  }\n+\n   const program_state *m_old_state;\n   const program_state *m_new_state;\n   const gimple *m_stmt;"}, {"sha": "fc90b49d0413708e8425efd9a96507f825003365", "filename": "gcc/analyzer/engine.cc", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c6546ca7d8cab1f1c129f5b55f709e2ceee0f94/gcc%2Fanalyzer%2Fengine.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c6546ca7d8cab1f1c129f5b55f709e2ceee0f94/gcc%2Fanalyzer%2Fengine.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fengine.cc?ref=5c6546ca7d8cab1f1c129f5b55f709e2ceee0f94", "patch": "@@ -921,6 +921,22 @@ impl_region_model_context::on_bounded_ranges (const svalue &sval,\n     }\n }\n \n+/* Implementation of region_model_context::on_pop_frame vfunc.\n+   Notify all state machines about the frame being popped, which\n+   could lead to states being discarded.  */\n+\n+void\n+impl_region_model_context::on_pop_frame (const frame_region *frame_reg)\n+{\n+  int sm_idx;\n+  sm_state_map *smap;\n+  FOR_EACH_VEC_ELT (m_new_state->m_checker_states, sm_idx, smap)\n+    {\n+      const state_machine &sm = m_ext_state.get_sm (sm_idx);\n+      sm.on_pop_frame (smap, frame_reg);\n+    }\n+}\n+\n /* Implementation of region_model_context::on_phi vfunc.\n    Notify all state machines about the phi, which could lead to\n    state transitions.  */"}, {"sha": "de927e6c1b7613c0ac910cf3e309485f695a3a45", "filename": "gcc/analyzer/exploded-graph.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c6546ca7d8cab1f1c129f5b55f709e2ceee0f94/gcc%2Fanalyzer%2Fexploded-graph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c6546ca7d8cab1f1c129f5b55f709e2ceee0f94/gcc%2Fanalyzer%2Fexploded-graph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fexploded-graph.h?ref=5c6546ca7d8cab1f1c129f5b55f709e2ceee0f94", "patch": "@@ -77,6 +77,8 @@ class impl_region_model_context : public region_model_context\n   void on_bounded_ranges (const svalue &sval,\n \t\t\t  const bounded_ranges &ranges) final override;\n \n+  void on_pop_frame (const frame_region *frame_reg) final override;\n+\n   void on_unknown_change (const svalue *sval, bool is_mutable) final override;\n \n   void on_phi (const gphi *phi, tree rhs) final override;"}, {"sha": "a0585f5ceef6e9ebbdce23fb7ee9797cd0e2f295", "filename": "gcc/analyzer/program-state.cc", "status": "modified", "additions": 74, "deletions": 9, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c6546ca7d8cab1f1c129f5b55f709e2ceee0f94/gcc%2Fanalyzer%2Fprogram-state.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c6546ca7d8cab1f1c129f5b55f709e2ceee0f94/gcc%2Fanalyzer%2Fprogram-state.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fprogram-state.cc?ref=5c6546ca7d8cab1f1c129f5b55f709e2ceee0f94", "patch": "@@ -518,6 +518,14 @@ sm_state_map::impl_set_state (const svalue *sval,\n   return true;\n }\n \n+/* Clear any state for SVAL from this state map.  */\n+\n+void\n+sm_state_map::clear_any_state (const svalue *sval)\n+{\n+  m_map.remove (sval);\n+}\n+\n /* Set the \"global\" state within this state map to STATE.  */\n \n void\n@@ -719,6 +727,67 @@ sm_state_map::canonicalize_svalue (const svalue *sval,\n   return sval;\n }\n \n+/* Attempt to merge this state map with OTHER, writing the result\n+   into *OUT.\n+   Return true if the merger was possible, false otherwise.\n+\n+   Normally, only identical state maps can be merged, so that\n+   differences between state maps lead to different enodes\n+\n+   However some state machines may support merging states to\n+   allow for discarding of less important states, and thus avoid\n+   blow-up of the exploded graph.  */\n+\n+bool\n+sm_state_map::can_merge_with_p (const sm_state_map &other,\n+\t\t\t\tconst state_machine &sm,\n+\t\t\t\tconst extrinsic_state &ext_state,\n+\t\t\t\tsm_state_map **out) const\n+{\n+  /* If identical, then they merge trivially, with a copy.  */\n+  if (*this == other)\n+    {\n+      delete *out;\n+      *out = clone ();\n+      return true;\n+    }\n+\n+  delete *out;\n+  *out = new sm_state_map (sm);\n+\n+  /* Otherwise, attempt to merge element by element. */\n+\n+  /* Try to merge global state.  */\n+  if (state_machine::state_t merged_global_state\n+      = sm.maybe_get_merged_state (get_global_state (),\n+\t\t\t\t   other.get_global_state ()))\n+    (*out)->set_global_state (merged_global_state);\n+  else\n+    return false;\n+\n+  /* Try to merge state each svalue's state (for the union\n+     of svalues represented by each smap).\n+     Ignore the origin information.  */\n+  hash_set<const svalue *> svals;\n+  for (auto kv : *this)\n+    svals.add (kv.first);\n+  for (auto kv : other)\n+    svals.add (kv.first);\n+  for (auto sval : svals)\n+    {\n+      state_machine::state_t this_state = get_state (sval, ext_state);\n+      state_machine::state_t other_state = other.get_state (sval, ext_state);\n+      if (state_machine::state_t merged_state\n+\t    = sm.maybe_get_merged_state (this_state, other_state))\n+\t(*out)->impl_set_state (sval, merged_state, NULL, ext_state);\n+      else\n+\treturn false;\n+    }\n+\n+  /* Successfully merged all elements.  */\n+  return true;\n+}\n+\n /* class program_state.  */\n \n /* program_state's ctor.  */\n@@ -1283,11 +1352,14 @@ program_state::can_merge_with_p (const program_state &other,\n   gcc_assert (out);\n   gcc_assert (m_region_model);\n \n-  /* Early reject if there are sm-differences between the states.  */\n+  /* Attempt to merge the sm-states.  */\n   int i;\n   sm_state_map *smap;\n   FOR_EACH_VEC_ELT (out->m_checker_states, i, smap)\n-    if (*m_checker_states[i] != *other.m_checker_states[i])\n+    if (!m_checker_states[i]->can_merge_with_p (*other.m_checker_states[i],\n+\t\t\t\t\t\text_state.get_sm (i),\n+\t\t\t\t\t\text_state,\n+\t\t\t\t\t\t&out->m_checker_states[i]))\n       return false;\n \n   /* Attempt to merge the region_models.  */\n@@ -1298,13 +1370,6 @@ program_state::can_merge_with_p (const program_state &other,\n \t\t\t\t\t this, &other))\n     return false;\n \n-  /* Copy m_checker_states to OUT.  */\n-  FOR_EACH_VEC_ELT (out->m_checker_states, i, smap)\n-    {\n-      delete smap;\n-      out->m_checker_states[i] = m_checker_states[i]->clone ();\n-    }\n-\n   out->m_region_model->canonicalize ();\n \n   return true;"}, {"sha": "79643278ee82e8cdbcd3009457bc48f2a6d717d5", "filename": "gcc/analyzer/program-state.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c6546ca7d8cab1f1c129f5b55f709e2ceee0f94/gcc%2Fanalyzer%2Fprogram-state.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c6546ca7d8cab1f1c129f5b55f709e2ceee0f94/gcc%2Fanalyzer%2Fprogram-state.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fprogram-state.h?ref=5c6546ca7d8cab1f1c129f5b55f709e2ceee0f94", "patch": "@@ -145,6 +145,7 @@ class sm_state_map\n \t\t       state_machine::state_t state,\n \t\t       const svalue *origin,\n \t\t       const extrinsic_state &ext_state);\n+  void clear_any_state (const svalue *sval);\n \n   void set_global_state (state_machine::state_t state);\n   state_machine::state_t get_global_state () const;\n@@ -174,6 +175,11 @@ class sm_state_map\n   bool replay_call_summary (call_summary_replay &r,\n \t\t\t    const sm_state_map &summary);\n \n+  bool can_merge_with_p (const sm_state_map &other,\n+\t\t\t const state_machine &sm,\n+\t\t\t const extrinsic_state &ext_state,\n+\t\t\t sm_state_map **out) const;\n+\n private:\n   const state_machine &m_sm;\n   map_t m_map;"}, {"sha": "b91434d7db4d251f24ab98cd45a106a9c657cd24", "filename": "gcc/analyzer/region-model.cc", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c6546ca7d8cab1f1c129f5b55f709e2ceee0f94/gcc%2Fanalyzer%2Fregion-model.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c6546ca7d8cab1f1c129f5b55f709e2ceee0f94/gcc%2Fanalyzer%2Fregion-model.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.cc?ref=5c6546ca7d8cab1f1c129f5b55f709e2ceee0f94", "patch": "@@ -4690,7 +4690,7 @@ tristate\n region_model::eval_condition (tree lhs,\n \t\t\t      enum tree_code op,\n \t\t\t      tree rhs,\n-\t\t\t      region_model_context *ctxt)\n+\t\t\t      region_model_context *ctxt) const\n {\n   /* For now, make no attempt to model constraints on floating-point\n      values.  */\n@@ -5415,8 +5415,13 @@ region_model::pop_frame (tree result_lvalue,\n {\n   gcc_assert (m_current_frame);\n \n-  /* Evaluate the result, within the callee frame.  */\n   const frame_region *frame_reg = m_current_frame;\n+\n+  /* Notify state machines.  */\n+  if (ctxt)\n+    ctxt->on_pop_frame (frame_reg);\n+\n+  /* Evaluate the result, within the callee frame.  */\n   tree fndecl = m_current_frame->get_function ()->decl;\n   tree result = DECL_RESULT (fndecl);\n   const svalue *retval = NULL;"}, {"sha": "507905967262c0ace184c63573e044d9ac7b9c30", "filename": "gcc/analyzer/region-model.h", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c6546ca7d8cab1f1c129f5b55f709e2ceee0f94/gcc%2Fanalyzer%2Fregion-model.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c6546ca7d8cab1f1c129f5b55f709e2ceee0f94/gcc%2Fanalyzer%2Fregion-model.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.h?ref=5c6546ca7d8cab1f1c129f5b55f709e2ceee0f94", "patch": "@@ -458,7 +458,7 @@ class region_model\n   tristate eval_condition (tree lhs,\n \t\t\t   enum tree_code op,\n \t\t\t   tree rhs,\n-\t\t\t   region_model_context *ctxt);\n+\t\t\t   region_model_context *ctxt) const;\n   bool add_constraint (tree lhs, enum tree_code op, tree rhs,\n \t\t       region_model_context *ctxt);\n   bool add_constraint (tree lhs, enum tree_code op, tree rhs,\n@@ -708,6 +708,9 @@ class region_model_context\n   virtual void on_bounded_ranges (const svalue &sval,\n \t\t\t\t  const bounded_ranges &ranges) = 0;\n \n+  /* Hook for clients to be notified when a frame is popped from the stack.  */\n+  virtual void on_pop_frame (const frame_region *) = 0;\n+\n   /* Hooks for clients to be notified when an unknown change happens\n      to SVAL (in response to a call to an unknown function).  */\n   virtual void on_unknown_change (const svalue *sval, bool is_mutable) = 0;\n@@ -789,6 +792,7 @@ class noop_region_model_context : public region_model_context\n \t\t\t  const bounded_ranges &) override\n   {\n   }\n+  void on_pop_frame (const frame_region *) override {}\n   void on_unknown_change (const svalue *sval ATTRIBUTE_UNUSED,\n \t\t\t  bool is_mutable ATTRIBUTE_UNUSED) override\n   {\n@@ -886,6 +890,11 @@ class region_model_context_decorator : public region_model_context\n     m_inner->on_bounded_ranges (sval, ranges);\n   }\n \n+  void on_pop_frame (const frame_region *frame_reg) override\n+  {\n+    m_inner->on_pop_frame (frame_reg);\n+  }\n+\n   void on_unknown_change (const svalue *sval, bool is_mutable) override\n   {\n     m_inner->on_unknown_change (sval, is_mutable);"}, {"sha": "dd10356155cbc25fa15d1d7586d1338e175ef704", "filename": "gcc/analyzer/sm-malloc.cc", "status": "modified", "additions": 310, "deletions": 4, "changes": 314, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c6546ca7d8cab1f1c129f5b55f709e2ceee0f94/gcc%2Fanalyzer%2Fsm-malloc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c6546ca7d8cab1f1c129f5b55f709e2ceee0f94/gcc%2Fanalyzer%2Fsm-malloc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-malloc.cc?ref=5c6546ca7d8cab1f1c129f5b55f709e2ceee0f94", "patch": "@@ -87,6 +87,9 @@ enum resource_state\n   /* The start state.  */\n   RS_START,\n \n+  /* State for a pointer that's been unconditionally dereferenced.  */\n+  RS_ASSUMED_NON_NULL,\n+\n   /* State for a pointer that's known to be NULL.  */\n   RS_NULL,\n \n@@ -126,7 +129,7 @@ struct allocation_state : public state_machine::state\n     m_deallocator (deallocator)\n   {}\n \n-  void dump_to_pp (pretty_printer *pp) const final override;\n+  void dump_to_pp (pretty_printer *pp) const override;\n \n   const allocation_state *get_nonnull () const;\n \n@@ -135,6 +138,25 @@ struct allocation_state : public state_machine::state\n   const deallocator *m_deallocator;\n };\n \n+/* Custom state subclass, for the \"assumed-non-null\" state\n+   where the assumption happens in a particular frame.  */\n+\n+struct assumed_non_null_state : public allocation_state\n+{\n+  assumed_non_null_state (const char *name, unsigned id,\n+\t\t\t  const frame_region *frame)\n+  : allocation_state (name, id, RS_ASSUMED_NON_NULL,\n+\t\t      NULL, NULL),\n+    m_frame (frame)\n+  {\n+    gcc_assert (m_frame);\n+  }\n+\n+  void dump_to_pp (pretty_printer *pp) const final override;\n+\n+  const frame_region *m_frame;\n+};\n+\n /* An enum for choosing which wording to use in various diagnostics\n    when describing deallocations.  */\n \n@@ -384,14 +406,25 @@ class malloc_state_machine : public state_machine\n \t\t     enum tree_code op,\n \t\t     const svalue *rhs) const final override;\n \n+  void on_pop_frame (sm_state_map *smap,\n+\t\t     const frame_region *) const final override;\n+\n   bool can_purge_p (state_t s) const final override;\n   std::unique_ptr<pending_diagnostic> on_leak (tree var) const final override;\n \n   bool reset_when_passed_to_unknown_fn_p (state_t s,\n \t\t\t\t\t  bool is_mutable) const final override;\n \n+  state_t\n+  maybe_get_merged_states_nonequal (state_t state_a,\n+\t\t\t\t    state_t state_b) const final override;\n+\n   static bool unaffected_by_call_p (tree fndecl);\n \n+  void maybe_assume_non_null (sm_context *sm_ctxt,\n+\t\t\t      tree ptr,\n+\t\t\t      const gimple *stmt) const;\n+\n   void on_realloc_with_move (region_model *model,\n \t\t\t     sm_state_map *smap,\n \t\t\t     const svalue *old_ptr_sval,\n@@ -406,6 +439,10 @@ class malloc_state_machine : public state_machine\n \n   /* States that are independent of api.  */\n \n+  /* States for a pointer that's been unconditionally dereferenced\n+     in a particular stack frame.  */\n+  hash_map<const frame_region *, state_t> m_assumed_non_null;\n+\n   /* State for a pointer that's known to be NULL.  */\n   state_t m_null;\n \n@@ -425,6 +462,16 @@ class malloc_state_machine : public state_machine\n   const deallocator *\n   get_or_create_deallocator (tree deallocator_fndecl);\n \n+  state_t\n+  get_or_create_assumed_non_null_state_for_frame (const frame_region *frame);\n+\n+  void\n+  maybe_complain_about_deref_before_check (sm_context *sm_ctxt,\n+\t\t\t\t\t   const supernode *node,\n+\t\t\t\t\t   const gimple *stmt,\n+\t\t\t\t\t   const assumed_non_null_state *,\n+\t\t\t\t\t   tree ptr) const;\n+\n   void on_allocator_call (sm_context *sm_ctxt,\n \t\t\t  const gcall *call,\n \t\t\t  const deallocator_set *deallocators,\n@@ -678,6 +725,14 @@ freed_p (state_machine::state_t state)\n   return get_rs (state) == RS_FREED;\n }\n \n+/* Return true if STATE is a value that has been assumed to be non-NULL.  */\n+\n+static bool\n+assumed_non_null_p (state_machine::state_t state)\n+{\n+  return get_rs (state) == RS_ASSUMED_NON_NULL;\n+}\n+\n /* Class for diagnostics relating to malloc_state_machine.  */\n \n class malloc_diagnostic : public pending_diagnostic\n@@ -1428,6 +1483,80 @@ class free_of_non_heap : public malloc_diagnostic\n   const char *m_funcname;\n };\n \n+/* Concrete pending_diagnostic subclass for -Wanalyzer-deref-before-check.  */\n+\n+class deref_before_check : public malloc_diagnostic\n+{\n+public:\n+  deref_before_check (const malloc_state_machine &sm, tree arg)\n+  : malloc_diagnostic (sm, arg)\n+  {}\n+\n+  const char *get_kind () const final override { return \"deref_before_check\"; }\n+\n+  int get_controlling_option () const final override\n+  {\n+    return OPT_Wanalyzer_deref_before_check;\n+  }\n+\n+  bool emit (rich_location *rich_loc) final override\n+  {\n+    if (m_arg)\n+      return warning_at (rich_loc, get_controlling_option (),\n+\t\t\t \"check of %qE for NULL after already\"\n+\t\t\t \" dereferencing it\",\n+\t\t\t m_arg);\n+    else\n+      return warning_at (rich_loc, get_controlling_option (),\n+\t\t\t \"check of pointer for NULL after already\"\n+\t\t\t \" dereferencing it\");\n+  }\n+\n+  label_text describe_state_change (const evdesc::state_change &change)\n+    final override\n+  {\n+    if (change.m_old_state == m_sm.get_start_state ()\n+\t&& assumed_non_null_p (change.m_new_state))\n+      {\n+\tm_first_deref_event = change.m_event_id;\n+\tif (m_arg)\n+\t  return change.formatted_print (\"pointer %qE is dereferenced here\",\n+\t\t\t\t\t m_arg);\n+\telse\n+\t  return label_text::borrow (\"pointer is dereferenced here\");\n+      }\n+    return malloc_diagnostic::describe_state_change (change);\n+  }\n+\n+  label_text describe_final_event (const evdesc::final_event &ev) final override\n+  {\n+    if (m_first_deref_event.known_p ())\n+      {\n+\tif (m_arg)\n+\t  return ev.formatted_print (\"pointer %qE is checked for NULL here but\"\n+\t\t\t\t     \" it was already dereferenced at %@\",\n+\t\t\t\t     m_arg, &m_first_deref_event);\n+\telse\n+\t  return ev.formatted_print (\"pointer is checked for NULL here but\"\n+\t\t\t\t     \" it was already dereferenced at %@\",\n+\t\t\t\t     &m_first_deref_event);\n+      }\n+    else\n+      {\n+\tif (m_arg)\n+\t  return ev.formatted_print (\"pointer %qE is checked for NULL here but\"\n+\t\t\t\t     \" it was already dereferenced\",\n+\t\t\t\t     m_arg);\n+\telse\n+\t  return ev.formatted_print (\"pointer is checked for NULL here but\"\n+\t\t\t\t     \" it was already dereferenced\");\n+      }\n+  }\n+\n+private:\n+  diagnostic_event_id_t m_first_deref_event;\n+};\n+\n /* struct allocation_state : public state_machine::state.  */\n \n /* Implementation of state_machine::state::dump_to_pp vfunc\n@@ -1456,6 +1585,17 @@ allocation_state::get_nonnull () const\n   return as_a_allocation_state (m_deallocators->m_nonnull);\n }\n \n+/* struct assumed_non_null_state : public allocation_state.  */\n+\n+void\n+assumed_non_null_state::dump_to_pp (pretty_printer *pp) const\n+{\n+  allocation_state::dump_to_pp (pp);\n+  pp_string (pp, \" (in \");\n+  m_frame->dump_to_pp (pp, true);\n+  pp_character (pp, ')');\n+}\n+\n /* malloc_state_machine's ctor.  */\n \n malloc_state_machine::malloc_state_machine (logger *logger)\n@@ -1597,6 +1737,22 @@ malloc_state_machine::get_or_create_deallocator (tree deallocator_fndecl)\n   return d;\n }\n \n+/* Get the \"assumed-non-null\" state for assumptions made within FRAME,\n+   creating it if necessary.  */\n+\n+state_machine::state_t\n+malloc_state_machine::\n+get_or_create_assumed_non_null_state_for_frame (const frame_region *frame)\n+{\n+  if (state_t *slot = m_assumed_non_null.get (frame))\n+    return *slot;\n+  state_machine::state *new_state\n+    = new assumed_non_null_state (\"assumed-non-null\", alloc_state_id (), frame);\n+  add_custom_state (new_state);\n+  m_assumed_non_null.put (frame, new_state);\n+  return new_state;\n+}\n+\n /* Try to identify the function declaration either by name or as a known malloc\n    builtin.  */\n \n@@ -1629,6 +1785,33 @@ known_allocator_p (const_tree fndecl, const gcall *call)\n   return false;\n }\n \n+/* If PTR's nullness is not known, transition it to the \"assumed-non-null\"\n+   state for the current frame.  */\n+\n+void\n+malloc_state_machine::maybe_assume_non_null (sm_context *sm_ctxt,\n+\t\t\t\t\t     tree ptr,\n+\t\t\t\t\t     const gimple *stmt) const\n+{\n+  const region_model *old_model = sm_ctxt->get_old_region_model ();\n+  if (!old_model)\n+    return;\n+\n+  tree null_ptr_cst = build_int_cst (TREE_TYPE (ptr), 0);\n+  tristate known_non_null\n+    = old_model->eval_condition (ptr, NE_EXPR, null_ptr_cst, NULL);\n+  if (known_non_null.is_unknown ())\n+    {\n+      /* Cast away const-ness for cache-like operations.  */\n+      malloc_state_machine *mut_this\n+\t= const_cast <malloc_state_machine *> (this);\n+      state_t next_state\n+\t= mut_this->get_or_create_assumed_non_null_state_for_frame\n+\t(old_model->get_current_frame ());\n+      sm_ctxt->set_next_state (stmt, ptr, next_state);\n+    }\n+}\n+\n /* Implementation of state_machine::on_stmt vfunc for malloc_state_machine.  */\n \n bool\n@@ -1743,6 +1926,8 @@ malloc_state_machine::on_stmt (sm_context *sm_ctxt,\n \t\t\t\t\t   (*this, diag_arg, callee_fndecl, i));\n \t\t\t  sm_ctxt->set_next_state (stmt, arg, m_stop);\n \t\t\t}\n+\t\t      else if (state == m_start)\n+\t\t\tmaybe_assume_non_null (sm_ctxt, arg, stmt);\n \t\t    }\n \t\t}\n \t      BITMAP_FREE (nonnull_args);\n@@ -1760,6 +1945,36 @@ malloc_state_machine::on_stmt (sm_context *sm_ctxt,\n \t  }\n       }\n \n+  /* Look for pointers explicitly being compared against zero\n+     that are in state assumed_non_null i.e. we already defererenced\n+     them.\n+     We have to do this check here, rather than in on_condition\n+     because we add a constraint that the pointer is non-null when\n+     dereferencing it, and this makes the apply_constraints_for_gcond\n+     find known-true and known-false conditions; on_condition is only\n+     called when adding new constraints.  */\n+  if (const gcond *cond_stmt = dyn_cast <const gcond *> (stmt))\n+    {\n+      enum tree_code op = gimple_cond_code (cond_stmt);\n+      if (op == EQ_EXPR || op == NE_EXPR)\n+\t{\n+\t  tree lhs = gimple_cond_lhs (cond_stmt);\n+\t  tree rhs = gimple_cond_rhs (cond_stmt);\n+\t  if (any_pointer_p (lhs)\n+\t      && any_pointer_p (rhs)\n+\t      && zerop (rhs))\n+\t    {\n+\t      state_t state = sm_ctxt->get_state (stmt, lhs);\n+\t      if (assumed_non_null_p (state))\n+\t\tmaybe_complain_about_deref_before_check\n+\t\t  (sm_ctxt, node,\n+\t\t   stmt,\n+\t\t   (const assumed_non_null_state *)state,\n+\t\t   lhs);\n+\t    }\n+\t}\n+    }\n+\n   if (tree lhs = sm_ctxt->is_zero_assignment (stmt))\n     if (any_pointer_p (lhs))\n       on_zero_assignment (sm_ctxt, stmt,lhs);\n@@ -1778,7 +1993,9 @@ malloc_state_machine::on_stmt (sm_context *sm_ctxt,\n \t  tree arg = TREE_OPERAND (op, 0);\n \n \t  state_t state = sm_ctxt->get_state (stmt, arg);\n-\t  if (unchecked_p (state))\n+\t  if (state == m_start)\n+\t    maybe_assume_non_null (sm_ctxt, arg, stmt);\n+\t  else if (unchecked_p (state))\n \t    {\n \t      tree diag_arg = sm_ctxt->get_diagnostic_tree (arg);\n \t      sm_ctxt->warn (node, stmt, arg,\n@@ -1808,6 +2025,53 @@ malloc_state_machine::on_stmt (sm_context *sm_ctxt,\n   return false;\n }\n \n+/* Given a check against null of PTR in assumed-non-null state STATE,\n+   potentially add a deref_before_check warning to SM_CTXT.  */\n+\n+void\n+malloc_state_machine::\n+maybe_complain_about_deref_before_check (sm_context *sm_ctxt,\n+\t\t\t\t\t const supernode *node,\n+\t\t\t\t\t const gimple *stmt,\n+\t\t\t\t\t const assumed_non_null_state *state,\n+\t\t\t\t\t tree ptr) const\n+{\n+  const region_model *model = sm_ctxt->get_old_region_model ();\n+  if (!model)\n+    return;\n+\n+  /* Don't complain if the current frame (where the check is occurring) is\n+     deeper than the frame in which the \"not null\" assumption was made.\n+     This suppress false positives for cases like:\n+\n+\tvoid foo (struct s *p)\n+\t{\n+\t  int val = s->some_field; // deref here\n+\t  shared_helper (p);\n+\t}\n+\n+     where \"shared_helper\" has:\n+\n+\tvoid shared_helper (struct s *p)\n+\t{\n+\t  if (!p) // check here\n+\t    return;\n+\t  // etc\n+\t}\n+\n+     since the check in \"shared_helper\" is OK.  */\n+  const frame_region *checked_in_frame = model->get_current_frame ();\n+  const frame_region *assumed_nonnull_in_frame = state->m_frame;\n+  if (checked_in_frame->get_index () > assumed_nonnull_in_frame->get_index ())\n+    return;\n+\n+  tree diag_ptr = sm_ctxt->get_diagnostic_tree (ptr);\n+  sm_ctxt->warn\n+    (node, stmt, ptr,\n+     make_unique<deref_before_check> (*this, diag_ptr));\n+  sm_ctxt->set_next_state (stmt, ptr, m_stop);\n+}\n+\n /* Handle a call to an allocator.\n    RETURNS_NONNULL is true if CALL is to a fndecl known to have\n    __attribute__((returns_nonnull)).  */\n@@ -1870,8 +2134,8 @@ malloc_state_machine::on_deallocator_call (sm_context *sm_ctxt,\n \n   state_t state = sm_ctxt->get_state (call, arg);\n \n-  /* start/unchecked/nonnull -> freed.  */\n-  if (state == m_start)\n+  /* start/assumed_non_null/unchecked/nonnull -> freed.  */\n+  if (state == m_start || assumed_non_null_p (state))\n     sm_ctxt->set_next_state (call, arg, d->m_freed);\n   else if (unchecked_p (state) || nonnull_p (state))\n     {\n@@ -2016,6 +2280,31 @@ malloc_state_machine::on_condition (sm_context *sm_ctxt,\n     }\n }\n \n+/* Implementation of state_machine::on_pop_frame vfunc for malloc_state_machine.\n+   Clear any \"assumed-non-null\" state where the assumption happened in\n+   FRAME_REG.  */\n+\n+void\n+malloc_state_machine::on_pop_frame (sm_state_map *smap,\n+\t\t\t\t    const frame_region *frame_reg) const\n+{\n+  hash_set<const svalue *> svals_to_clear;\n+  for (auto kv : *smap)\n+    {\n+      const svalue *sval = kv.first;\n+      state_t state = kv.second.m_state;\n+      if (assumed_non_null_p (state))\n+\t{\n+\t  const assumed_non_null_state *assumed_state\n+\t    = (const assumed_non_null_state *)state;\n+\t  if (frame_reg == assumed_state->m_frame)\n+\t    svals_to_clear.add (sval);\n+\t}\n+    }\n+  for (auto sval : svals_to_clear)\n+    smap->clear_any_state (sval);\n+}\n+\n /* Implementation of state_machine::can_purge_p vfunc for malloc_state_machine.\n    Don't allow purging of pointers in state 'unchecked' or 'nonnull'\n    (to avoid false leak reports).  */\n@@ -2053,6 +2342,23 @@ malloc_state_machine::reset_when_passed_to_unknown_fn_p (state_t s,\n   return is_mutable;\n }\n \n+/* Implementation of state_machine::maybe_get_merged_states_nonequal vfunc\n+   for malloc_state_machine.\n+\n+   Support discarding \"assumed-non-null\" states when merging with\n+   start state.  */\n+\n+state_machine::state_t\n+malloc_state_machine::maybe_get_merged_states_nonequal (state_t state_a,\n+\t\t\t\t\t\t\tstate_t state_b) const\n+{\n+  if (assumed_non_null_p (state_a) && state_b == m_start)\n+    return m_start;\n+  if (state_a == m_start && assumed_non_null_p (state_b))\n+    return m_start;\n+  return NULL;\n+}\n+\n /* Return true if calls to FNDECL are known to not affect this sm-state.  */\n \n bool"}, {"sha": "cb1c54aa351c05e13f5eb4da8f83cc6812881c5b", "filename": "gcc/analyzer/sm-malloc.dot", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c6546ca7d8cab1f1c129f5b55f709e2ceee0f94/gcc%2Fanalyzer%2Fsm-malloc.dot", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c6546ca7d8cab1f1c129f5b55f709e2ceee0f94/gcc%2Fanalyzer%2Fsm-malloc.dot", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-malloc.dot?ref=5c6546ca7d8cab1f1c129f5b55f709e2ceee0f94", "patch": "@@ -32,6 +32,9 @@ digraph \"malloc\" {\n      It could be a pointer to heap-allocated memory, or could be NULL.  */\n   unchecked;\n \n+  /* State for a pointer that's been unconditionally dereferenced.  */\n+  assumed_non_null;\n+\n   /* State for a pointer that's known to be NULL.  */\n   null;\n \n@@ -58,6 +61,7 @@ digraph \"malloc\" {\n \n   /* On \"free\".  */\n   start -> freed [label=\"on 'free(X);'\"];\n+  assumed_non_null -> freed [label=\"on 'free(X);'\"];\n   unchecked -> freed [label=\"on 'free(X);'\"];\n   nonnull -> freed [label=\"on 'free(X);'\"];\n   freed -> stop [label=\"on 'free(X);':\\n Warn('double-free')\"];\n@@ -66,6 +70,7 @@ digraph \"malloc\" {\n   /* Handle \"__attribute__((nonnull))\".   */\n   unchecked -> nonnull [label=\"on 'FN(X)' with __attribute__((nonnull)):\\nWarn('possible NULL arg')\"];\n   null -> stop [label=\"on 'FN(X)' with __attribute__((nonnull)):\\nWarn('NULL arg')\"];\n+  start -> assumed_non_null [label=\"on 'FN(X)' with __attribute__((nonnull))\"];\n \n   /* is_zero_assignment.  */\n   start -> null [label=\"on 'X = 0;'\"];\n@@ -76,13 +81,15 @@ digraph \"malloc\" {\n   start -> non_heap [label=\"on 'X = &EXPR;'\"];\n \n   /* Handle dereferences.  */\n+  start -> assumed_non_null [label=\"on '*X'\"];\n   unchecked -> nonnull [label=\"on '*X':\\nWarn('possible NULL deref')\"];\n   null -> stop [label=\"on '*X':\\nWarn('NULL deref')\"];\n   freed -> stop [label=\"on '*X':\\nWarn('use after free')\"];\n \n   /* on_condition.  */\n   unchecked -> nonnull [label=\"on 'X != 0'\"];\n   unchecked -> null [label=\"on 'X == 0'\"];\n+  assumed_non_null -> stop [label=\"on 'if (X)':\\nWarn('deref-before-check')\"];\n \n   unchecked -> stop [label=\"on leak:\\nWarn('leak')\"];\n   nonnull -> stop [label=\"on leak:\\nWarn('leak')\"];"}, {"sha": "085a3a1514b447940d97f7366c9e3478be4c8db3", "filename": "gcc/analyzer/sm.h", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c6546ca7d8cab1f1c129f5b55f709e2ceee0f94/gcc%2Fanalyzer%2Fsm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c6546ca7d8cab1f1c129f5b55f709e2ceee0f94/gcc%2Fanalyzer%2Fsm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm.h?ref=5c6546ca7d8cab1f1c129f5b55f709e2ceee0f94", "patch": "@@ -117,6 +117,12 @@ class state_machine : public log_user\n   {\n   }\n \n+  virtual void\n+  on_pop_frame (sm_state_map *smap ATTRIBUTE_UNUSED,\n+\t\tconst frame_region *frame_reg ATTRIBUTE_UNUSED) const\n+  {\n+  }\n+\n   /* Return true if it safe to discard the given state (to help\n      when simplifying state objects).\n      States that need leak detection should return false.  */\n@@ -139,6 +145,31 @@ class state_machine : public log_user\n     return is_mutable;\n   }\n \n+  /* Attempt to get a state for the merger of STATE_A and STATE_B,\n+     or return NULL if merging shouldn't occur, so that differences\n+     between sm-state will lead to separate exploded nodes.\n+\n+     Most state machines will only merge equal states, but can\n+     override maybe_get_merged_states_nonequal to support mergers\n+     of certain non-equal states.  */\n+  state_t maybe_get_merged_state (state_t state_a,\n+\t\t\t\t  state_t state_b) const\n+  {\n+    if (state_a == state_b)\n+      return state_a;\n+    return maybe_get_merged_states_nonequal (state_a, state_b);\n+  }\n+\n+  /* Base implementation of hook for maybe_get_merged_state on non-equal\n+     states.  */\n+  virtual state_t\n+  maybe_get_merged_states_nonequal (state_t state_a ATTRIBUTE_UNUSED,\n+\t\t\t\t    state_t state_b ATTRIBUTE_UNUSED) const\n+  {\n+    /* By default, non-equal sm states should inhibit merger of enodes.  */\n+    return NULL;\n+  }\n+\n   void validate (state_t s) const;\n \n   void dump_to_pp (pretty_printer *pp) const;"}, {"sha": "09bf049036f1bad130dcd3932a6711737457caaf", "filename": "gcc/doc/gcc/gcc-command-options/options-that-control-static-analysis.rst", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c6546ca7d8cab1f1c129f5b55f709e2ceee0f94/gcc%2Fdoc%2Fgcc%2Fgcc-command-options%2Foptions-that-control-static-analysis.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c6546ca7d8cab1f1c129f5b55f709e2ceee0f94/gcc%2Fdoc%2Fgcc%2Fgcc-command-options%2Foptions-that-control-static-analysis.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgcc%2Fgcc-command-options%2Foptions-that-control-static-analysis.rst?ref=5c6546ca7d8cab1f1c129f5b55f709e2ceee0f94", "patch": "@@ -19,6 +19,7 @@ Options That Control Static Analysis\n   Enabling this option effectively enables the following warnings:\n \n   :option:`-Wanalyzer-allocation-size` |gol|\n+  :option:`-Wanalyzer-deref-before-check` |gol|\n   :option:`-Wanalyzer-double-fclose` |gol|\n   :option:`-Wanalyzer-double-free` |gol|\n   :option:`-Wanalyzer-exposure-through-output-file` |gol|\n@@ -88,6 +89,33 @@ Options That Control Static Analysis\n \n   Default setting; overrides :option:`-Wno-analyzer-allocation-size`.\n \n+.. option:: -Wno-analyzer-deref-before-check\n+\n+  This warning requires :option:`-fanalyzer`, which enables it; use\n+  :option:`-Wno-analyzer-deref-before-check`\n+  to disable it.\n+\n+  This diagnostic warns for paths through the code in which a pointer\n+  is checked for ``NULL`` *after* it has already been\n+  dereferenced, suggesting that the pointer could have been NULL.\n+  Such cases suggest that the check for NULL is either redundant,\n+  or that it needs to be moved to before the pointer is dereferenced.\n+\n+  This diagnostic also considers values passed to a function argument\n+  marked with ``__attribute__((nonnull))`` as requiring a non-NULL\n+  value, and thus will complain if such values are checked for ``NULL``\n+  after returning from such a function call.\n+\n+  This diagnostic is unlikely to be reported when any level of optimization\n+  is enabled, as GCC's optimization logic will typically consider such\n+  checks for NULL as being redundant, and optimize them away before the\n+  analyzer \"sees\" them.  Hence optimization should be disabled when\n+  attempting to trigger this diagnostic.\n+\n+.. option:: -Wanalyzer-deref-before-check\n+\n+  Default setting; overrides :option:`-Wno-analyzer-deref-before-check`.\n+\n .. option:: -Wno-analyzer-double-fclose\n \n   This warning requires :option:`-fanalyzer`, which enables it; use\n@@ -825,6 +853,7 @@ The following options control the analyzer.\n     Currently, :option:`-fanalyzer-checker=taint` disables the\n     following warnings from :option:`-fanalyzer` :\n \n+    :option:`-Wanalyzer-deref-before-check` |gol|\n     :option:`-Wanalyzer-double-fclose` |gol|\n     :option:`-Wanalyzer-double-free`  |gol|\n     :option:`-Wanalyzer-exposure-through-output-file`  |gol|"}, {"sha": "e1c7a00b97cca10bf3e3d36437c7d267b5d40dc3", "filename": "gcc/testsuite/gcc.dg/analyzer/deref-before-check-1.c", "status": "added", "additions": 169, "deletions": 0, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c6546ca7d8cab1f1c129f5b55f709e2ceee0f94/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fderef-before-check-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c6546ca7d8cab1f1c129f5b55f709e2ceee0f94/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fderef-before-check-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fderef-before-check-1.c?ref=5c6546ca7d8cab1f1c129f5b55f709e2ceee0f94", "patch": "@@ -0,0 +1,169 @@\n+#define NULL ((void *)0)\n+\n+int test_from_pr77432 (int *a)\n+{\n+    int b = *a; /* { dg-message \"pointer 'a' is dereferenced here\" } */\n+    if (a) /* { dg-warning \"check of 'a' for NULL after already dereferencing it \\\\\\[-Wanalyzer-deref-before-check\\\\\\]\" \"warning\" } */\n+         /* { dg-message \"pointer 'a' is checked for NULL here but it was already dereferenced at \\\\(1\\\\)\" \"final event\" { target *-*-* } .-1 } */\n+         return b;\n+    return 0;\n+}\n+\n+int test_1a (int *p, int x)\n+{\n+  *p = x; /* { dg-message \"pointer 'p' is dereferenced here\" } */\n+\n+  if (p) /* { dg-warning \"check of 'p' for NULL after already dereferencing it \\\\\\[-Wanalyzer-deref-before-check\\\\\\]\" \"warning\" } */\n+    /* { dg-message \"pointer 'p' is checked for NULL here but it was already dereferenced at \\\\(1\\\\)\" \"final event\" { target *-*-* } .-1 } */\n+    return 1;\n+  else\n+    return 0;\n+}\n+\n+int test_1b (int *p, int *q)\n+{\n+  *q = *p; /* { dg-message \"8: pointer 'p' is dereferenced here\" } */\n+\n+  if (p) /* { dg-warning \"check of 'p' for NULL after already dereferencing it \\\\\\[-Wanalyzer-deref-before-check\\\\\\]\" \"warning\" } */\n+    /* { dg-message \"pointer 'p' is checked for NULL here but it was already dereferenced at \\\\(1\\\\)\" \"final event\" { target *-*-* } .-1 } */\n+    return 1;\n+  else\n+    return 0;\n+}\n+\n+struct s2\n+{\n+  int x;\n+  int y;\n+};\n+\n+int test_2a (struct s2 *p)\n+{\n+  int sum = p->x + p->y; /* { dg-message \"pointer 'p' is dereferenced here\" } */\n+  if (!p) /* { dg-warning \"check of 'p' for NULL after already dereferencing it\" } */\n+    __builtin_abort ();\n+  return sum;\n+}\n+\n+int test_2b (struct s2 *p)\n+{\n+  if (!p)\n+    __builtin_abort ();\n+  int sum = p->x + p->y;\n+  return sum;\n+}\n+\n+struct s3\n+{\n+  int flag;\n+};\n+\n+extern void err (const char *);\n+\n+void test_3 (struct s3 *p)\n+{\n+  if (p->flag) /* { dg-message \"pointer 'p' is dereferenced here\" } */\n+    err (\"p->flag\");\n+  if (!p) /* { dg-warning \"check of 'p' for NULL after already dereferencing it\" } */\n+    err (\"p was NULL\");\n+}\n+\n+struct s4\n+{\n+  struct s4 *m_next;\n+  int m_val;\n+};\n+\n+int test_4 (struct s4 *p)\n+{\n+  if (p->m_next->m_val > 0) /* { dg-message \"pointer '\\\\*p.m_next' is dereferenced here\" } */\n+    return -1;\n+  if (!p->m_next) /* { dg-warning \"check of '\\\\*p.m_next' for NULL after already dereferencing it\" } */\n+    return -2;\n+  return p->m_next->m_val;\n+}\n+\n+struct s5\n+{\n+  const char *str;\n+  int val;\n+};\n+\n+int test_5 (struct s5 *p)\n+{\n+  __builtin_printf (\"%s: %i\\n\", p->str, p->val); /* { dg-message \"pointer 'p' is dereferenced here\" } */\n+  if (p != NULL) /* { dg-warning \"check of 'p' for NULL after already dereferencing it\" } */\n+    return p->val;\n+  return -1;\n+}\n+\n+static int  __attribute__((noinline))\n+__analyzer_check_ptr (int *p)\n+{\n+  if (p)\n+    return *p;\n+  else\n+    return 42;\n+}\n+\n+int test_calling_check_ptr_after_deref_1 (int *q)\n+{\n+  int v = *q; /* { dg-bogus \"dereferenced here\" } */\n+  v += __analyzer_check_ptr (q);\n+  return v;\n+}\n+\n+int test_calling_check_ptr_after_deref_2 (int *q)\n+{\n+  int v = *q; /* { dg-bogus \"dereferenced here\" } */\n+  v += __analyzer_check_ptr (q);\n+  *q = 17;\n+  return v;\n+}\n+\n+int test_calling_check_ptr_after_deref_3 (int *q)\n+{\n+  int v = *q; /* { dg-message \"pointer 'q' is dereferenced here\" } */\n+  v += __analyzer_check_ptr (q);\n+  if (q) /* { dg-warning \"check of 'q' for NULL after already dereferencing it\" } */\n+    *q = 17;\n+  return v;\n+}\n+\n+static int  __attribute__((noinline))\n+__analyzer_deref_ptr (int *p)\n+{\n+  return *p;\n+}\n+\n+int test_calling_check_ptr_after_calling_deref_1 (int *q)\n+{\n+  int v = __analyzer_deref_ptr (q);\n+  v += __analyzer_check_ptr (q);\n+  return v;\n+}\n+\n+int test_calling_check_ptr_after_calling_deref_2 (int *q)\n+{\n+  int v = __analyzer_deref_ptr (q);\n+  v += __analyzer_check_ptr (q);\n+  *q = 17;\n+  return v;\n+}\n+\n+int test_calling_check_ptr_after_calling_deref_3 (int *q)\n+{\n+  int v =  __analyzer_deref_ptr (q);\n+  v += __analyzer_check_ptr (q);\n+  if (q)\n+    *q = 17;\n+  return v;\n+}\n+\n+int test_checking_ptr_after_calling_deref (int *q)\n+{\n+  int v = __analyzer_deref_ptr (q);\n+  if (q)\n+    return 0;\n+  return v;\n+}"}, {"sha": "c0409c42d8982423744fe1cabb23e26c3fffa2bc", "filename": "gcc/testsuite/gcc.dg/analyzer/deref-before-check-2.c", "status": "added", "additions": 130, "deletions": 0, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c6546ca7d8cab1f1c129f5b55f709e2ceee0f94/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fderef-before-check-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c6546ca7d8cab1f1c129f5b55f709e2ceee0f94/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fderef-before-check-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fderef-before-check-2.c?ref=5c6546ca7d8cab1f1c129f5b55f709e2ceee0f94", "patch": "@@ -0,0 +1,130 @@\n+#include <stdio.h>\n+\n+struct st\n+{\n+  char *str;\n+  int i;\n+};\n+\n+int test_1 (struct st *p)\n+{\n+  fprintf (stderr, \"str: %s\\n\", p->str); /* { dg-message \"pointer 'p' is dereferenced here\" } */\n+  if (!p) /* { dg-warning \"check of 'p' for NULL after already dereferencing it\" } */\n+    return -1;\n+  return p->i;  \n+}\n+\n+int test_2 (int flag_a, int flag_b, struct st *p)\n+{\n+  if (flag_a)\n+    {\n+      int j = p->i; /* { dg-message \"pointer 'p' is dereferenced here\" } */\n+      if (flag_b && p) /* { dg-warning \"check of 'p' for NULL after already dereferencing it\" } */\n+\treturn 1;\n+      return j;\n+    }\n+  return 2;\n+}\n+\n+int test_3 (struct st *a, struct st *b)\n+{\n+  if (!a)\n+    return b->i;\n+  if (!b)\n+    return a->i;\n+  return 0;\n+}\n+\n+int test_4 (struct st *p)\n+{\n+  int *q = &p->i;\n+  if (!p)\n+    return -1;\n+  return *q;  \n+}\n+\n+void test_check_after_strlen (const char *str)\n+{\n+  size_t len_a = __builtin_strlen (str); /* { dg-message \"pointer 'str' is dereferenced here\" } */\n+  size_t len_b = str ? __builtin_strlen (str) : 0; /* { dg-warning \"check of 'str' for NULL after already dereferencing it\" } */\n+}\n+\n+void test_6 (struct st *a, struct st *b)\n+{\n+  int diff = a->i - b->i; /* { dg-message \"pointer 'b' is dereferenced here\" } */\n+\n+  /* ... */\n+\n+  if (b) /* { dg-warning \"check of 'b' for NULL after already dereferencing it\" } */\n+    fprintf (stderr, \"str: %s\\n\", b->str);\n+}\n+\n+void test_check_after_strcmp (const char *s1, const char *s2)\n+{\n+  if (!__builtin_strcmp (s1, s2)) /* { dg-message \"pointer 's1' is dereferenced here\" } */\n+    return;\n+\n+  /* ... */\n+\n+  if (s1) /* { dg-warning \"check of 's1' for NULL after already dereferencing it\" } */\n+    return;\n+}\n+\n+void test_more_than_one_deref (struct st *p)\n+{\n+  char *str = p->str; /* { dg-message \"pointer 'p' is dereferenced here\" } */\n+  int i = p->i;\n+  \n+  /* ... */\n+\n+  if (p) /* { dg-warning \"check of 'p' for NULL after already dereferencing it\" } */\n+    return;\n+\n+  /* ... */\n+}\n+\n+void test_deref_under_another_name (struct st *p)\n+{\n+  struct st *q = p;\n+  int i = q->i; /* { dg-message \"pointer 'p' is dereferenced here\" } */\n+\n+  /* ... */\n+\n+  if (p) /* { dg-warning \"check of 'p' for NULL after already dereferencing it\" } */\n+    return;\n+\n+  /* ... */\n+}\n+\n+void test_check_after_memcpy_src (struct st *dst, struct st *src)\n+{\n+  __builtin_memcpy (dst, src, sizeof (struct st)); /* { dg-message \"pointer 'src' is dereferenced here\" } */\n+\n+  /* ... */\n+\n+  if (!src) /* { dg-warning \"check of 'src' for NULL after already dereferencing it\" } */\n+    return;\n+\n+  /* ... */\n+}\n+\n+void test_check_after_memcpy_dst (struct st *dst, struct st *src)\n+{\n+  __builtin_memcpy (dst, src, sizeof (struct st)); /* { dg-message \"pointer 'dst' is dereferenced here\" } */\n+\n+  /* ... */\n+\n+  if (!dst) /* { dg-warning \"check of 'dst' for NULL after already dereferencing it\" } */\n+    return;\n+\n+  /* ... */\n+}\n+\n+void test_merger (int *p, int flag)\n+{\n+  int x = *p;\n+  if (flag)\n+    __builtin_free (p);\n+  if (!flag)\n+    __builtin_free (p); /* { dg-bogus \"double-'free'\" } */\n+}"}, {"sha": "1ceea97b422477e0fd2495884f462055a0c931bb", "filename": "gcc/testsuite/gcc.dg/analyzer/deref-before-check-pr77425.c", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c6546ca7d8cab1f1c129f5b55f709e2ceee0f94/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fderef-before-check-pr77425.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c6546ca7d8cab1f1c129f5b55f709e2ceee0f94/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fderef-before-check-pr77425.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fderef-before-check-pr77425.c?ref=5c6546ca7d8cab1f1c129f5b55f709e2ceee0f94", "patch": "@@ -0,0 +1,43 @@\n+/* Fixed in r7-2945-g61f46d0e6dd568.\n+   Simplified from gcc/ipa-devirt.c.  */\n+\n+#define NULL ((void *)0)\n+typedef struct odr_type_d {\n+  /* .... */\n+  int id;\n+  /* .... */\n+} *odr_type;\n+static odr_type **odr_types_ptr;\n+#define odr_types (*odr_types_ptr) /* { dg-message \"pointer 'odr_types_ptr' is dereferenced here\" } */\n+\n+int cond, other_cond;\n+\n+odr_type some_logic ();\n+\n+odr_type\n+get_odr_type (/* ... */)\n+{\n+  /* .... */\n+  odr_type val = NULL;\n+  /* .... */\n+\n+  val = some_logic ();\n+\n+  /* .... */\n+  if (cond)\n+    {\n+      /* .... */\n+    }\n+  else if (other_cond)\n+    {\n+      odr_types[val->id] = 0; /* { dg-message \"in expansion of macro 'odr_types'\" } */\n+      /* .... */\n+      if (odr_types_ptr) /* { dg-warning \"check of 'odr_types_ptr' for NULL after already dereferencing it\" } */\n+\t{\n+\t  /* .... */\n+\t  val->id = 42;\n+\t}\n+      /* .... */\n+    }\n+  return val;\n+}"}, {"sha": "6b5590a433a3a4fe051bc08e9b9a1a0d6b805c76", "filename": "gcc/testsuite/gcc.dg/analyzer/malloc-1.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c6546ca7d8cab1f1c129f5b55f709e2ceee0f94/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c6546ca7d8cab1f1c129f5b55f709e2ceee0f94/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-1.c?ref=5c6546ca7d8cab1f1c129f5b55f709e2ceee0f94", "patch": "@@ -625,5 +625,14 @@ void test_50c (void)\n   free (&&my_label); /* { dg-warning \"'free' of '&my_label' which points to memory not on the heap \\\\\\[CWE-590\\\\\\]\" } */\n }\n \n+/* Double free after unconditional dereference.  */\n+\n+int test_51 (int *p)\n+{\n+  int result = *p;\n+  free (p); /* { dg-message \"first 'free' here\" } */\n+  free (p); /* { dg-warning \"double-'free' of 'p'\" } */\n+  return result;\n+}\n \n /* { dg-prune-output \"\\\\\\[-Wfree-nonheap-object\" } */"}, {"sha": "bccfa8bf5235d911add4b9ea5cc62b2dc3deb095", "filename": "gcc/tristate.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c6546ca7d8cab1f1c129f5b55f709e2ceee0f94/gcc%2Ftristate.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c6546ca7d8cab1f1c129f5b55f709e2ceee0f94/gcc%2Ftristate.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftristate.h?ref=5c6546ca7d8cab1f1c129f5b55f709e2ceee0f94", "patch": "@@ -38,6 +38,7 @@ class tristate {\n   const char *as_string () const;\n \n   bool is_known () const { return m_value != TS_UNKNOWN; }\n+  bool is_unknown () const { return m_value == TS_UNKNOWN; }\n   bool is_true () const { return m_value == TS_TRUE; }\n   bool is_false () const { return m_value == TS_FALSE; }\n "}]}