{"sha": "a06ef755a376209a3c757786b3931671b72fc771", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTA2ZWY3NTVhMzc2MjA5YTNjNzU3Nzg2YjM5MzE2NzFiNzJmYzc3MQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2001-11-15T23:44:58Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2001-11-15T23:44:58Z"}, "message": "alias.c (nonoverlapping_memrefs): Use REGNO_PTR_FRAME_P.\n\n\t* alias.c (nonoverlapping_memrefs): Use REGNO_PTR_FRAME_P.\n\t* emit-rtl.c (change_address): Fix typo in default alignment.\n\t(adjust_address_1): Use mode of NEW, not MODE, when setting size.\n\t* expr.c (highest_pow2_factor, case WITH_RECORD_EXPR): New case.\n\t* rtl.h (REGNO_PTR_FRAME_P): New macro.\n\n\t* expr.c (store_field): Pass tree instead of max size; callers changed.\n\tChange handling of alignment.\n\tOnly copy to_rtx if is TARGET.\n\t(expand_expr_unaligned): Delete; callers now use expand_expr.\n\t(emit_cmp_insn): No longer take ALIGN parm; all callers changed.\n\t(expand_assignment): Change handling of alignment.\n\tOnly copy to_rtx if was original.\n\t(get_inner_reference): No longer return alginment; callers changed.\n\t(expand_expr, case COMPONENT_REF): Change handling of alignment.\n\t(expand_expr, case ADDR_EXPR): Make copy if not sufficiently aligned.\n\t(compare_from_rtx): Delete ALIGN parm; all callers changed.\n\t(do_compare_rtx_and_jump): Likewise.\n\t* expr.h: Reflect above changes.\n\t* tree.h: Likewise.\n\t* dwarf2out.c (loc_descriptor_from_tree): Remove ALIGN parameter\n\tto get_inner_reference.\n\t* except.c: Remove ALIGN parameter in call to emit_cmp_and_jump_insns.\n\t* explow.c: Likewise.\n\t* loop.c: Likewise.\n\t* optabs.c: Likewise.\n\t(prepare_cmp_insn): Now static; remove ALIGN parm.  Callers changed.\n\t(emit_cmp_and_jump_insns): Remove ALIGN parm; all callers changed.\n\t* fold-const.c: Remove PALIGN in calls to get_inner_reference.\n\t* function.c (assign_stack_temp_for_type): No longer static.\n\t* optabs.h (emit_cmp_insn): Remove ALIGN parm.\n\t(prepare_cmp_insn): Delete declaration.\n\t* rtl.h (assign_stack_temp_for_type): Add declaration.\n\t* config/d30v/d30v.c: Reflect above changes.\n\t* config/i860/i860.c, config/ia64/ia64.c: Likewise.\n\t* config/rs6000/rs6000.c, config/sh/sh.c: Likewise.\n\t* ada/trans.c, ada/utils2.c: Remove PALIGN parameter to\n\tget_inner_reference.\n\nFrom-SVN: r47075", "tree": {"sha": "105a983313e457a031de093d1916dbf3d53a97b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/105a983313e457a031de093d1916dbf3d53a97b4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a06ef755a376209a3c757786b3931671b72fc771", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a06ef755a376209a3c757786b3931671b72fc771", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a06ef755a376209a3c757786b3931671b72fc771", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a06ef755a376209a3c757786b3931671b72fc771/comments", "author": null, "committer": null, "parents": [{"sha": "d215024f7f4211af4ede74781e12c5b3578be15f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d215024f7f4211af4ede74781e12c5b3578be15f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d215024f7f4211af4ede74781e12c5b3578be15f"}], "stats": {"total": 791, "additions": 231, "deletions": 560}, "files": [{"sha": "dfe54f59fb9cbb4823620ff7d712dfc4d8585630", "filename": "gcc/ChangeLog", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a06ef755a376209a3c757786b3931671b72fc771/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a06ef755a376209a3c757786b3931671b72fc771/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a06ef755a376209a3c757786b3931671b72fc771", "patch": "@@ -1,3 +1,42 @@\n+Thu Nov 15 17:57:48 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* alias.c (nonoverlapping_memrefs): Use REGNO_PTR_FRAME_P.\n+\t* emit-rtl.c (change_address): Fix typo in default alignment.\n+\t(adjust_address_1): Use mode of NEW, not MODE, when setting size.\n+\t* expr.c (highest_pow2_factor, case WITH_RECORD_EXPR): New case.\n+\t* rtl.h (REGNO_PTR_FRAME_P): New macro.\n+\n+\t* expr.c (store_field): Pass tree instead of max size; callers changed.\n+\tChange handling of alignment.\n+\tOnly copy to_rtx if is TARGET.\n+\t(expand_expr_unaligned): Delete; callers now use expand_expr.\n+\t(emit_cmp_insn): No longer take ALIGN parm; all callers changed.\n+\t(expand_assignment): Change handling of alignment.\n+\tOnly copy to_rtx if was original.\n+\t(get_inner_reference): No longer return alginment; callers changed.\n+\t(expand_expr, case COMPONENT_REF): Change handling of alignment.\n+\t(expand_expr, case ADDR_EXPR): Make copy if not sufficiently aligned.\n+\t(compare_from_rtx): Delete ALIGN parm; all callers changed.\n+\t(do_compare_rtx_and_jump): Likewise.\n+\t* expr.h: Reflect above changes.\n+\t* tree.h: Likewise.\n+\t* dwarf2out.c (loc_descriptor_from_tree): Remove ALIGN parameter\n+\tto get_inner_reference.\n+\t* except.c: Remove ALIGN parameter in call to emit_cmp_and_jump_insns.\n+\t* explow.c: Likewise.\n+\t* loop.c: Likewise.\n+\t* optabs.c: Likewise.\n+\t(prepare_cmp_insn): Now static; remove ALIGN parm.  Callers changed.\n+\t(emit_cmp_and_jump_insns): Remove ALIGN parm; all callers changed.\n+\t* fold-const.c: Remove PALIGN in calls to get_inner_reference.\n+\t* function.c (assign_stack_temp_for_type): No longer static.\n+\t* optabs.h (emit_cmp_insn): Remove ALIGN parm.\n+\t(prepare_cmp_insn): Delete declaration.\n+\t* rtl.h (assign_stack_temp_for_type): Add declaration.\n+\t* config/d30v/d30v.c: Reflect above changes.\n+\t* config/i860/i860.c, config/ia64/ia64.c: Likewise.\n+\t* config/rs6000/rs6000.c, config/sh/sh.c: Likewise.\n+\n 2001-11-15  Stan Shebs  <shebs@apple.com>\n \n \t* config/rs6000/rs6000.h: Fix a comment typo."}, {"sha": "27e7e3903fd20a0b46cfddd0fd141ecb85fffebd", "filename": "gcc/alias.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a06ef755a376209a3c757786b3931671b72fc771/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a06ef755a376209a3c757786b3931671b72fc771/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=a06ef755a376209a3c757786b3931671b72fc771", "patch": "@@ -1806,9 +1806,9 @@ nonoverlapping_memrefs_p (x, y)\n   if (! rtx_equal_p (basex, basey))\n       return ((CONSTANT_P (basex) && CONSTANT_P (basey))\n \t      || (CONSTANT_P (basex) && REG_P (basey)\n-\t\t  && REGNO (basey) <= LAST_VIRTUAL_REGISTER)\n+\t\t  && REGNO_PTR_FRAME_P (REGNO (basey)))\n \t      || (CONSTANT_P (basey) && REG_P (basex)\n-\t\t  && REGNO (basex) <= LAST_VIRTUAL_REGISTER));\n+\t\t  && REGNO_PTR_FRAME_P (REGNO (basex))));\n \n   sizex = (GET_CODE (rtlx) != MEM ? GET_MODE_SIZE (GET_MODE (rtlx))\n \t   : MEM_SIZE (rtlx) ? INTVAL (MEM_SIZE (rtlx))"}, {"sha": "a4d14be8c0c48f35cb6d74324d451096909e7ced", "filename": "gcc/config/d30v/d30v.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a06ef755a376209a3c757786b3931671b72fc771/gcc%2Fconfig%2Fd30v%2Fd30v.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a06ef755a376209a3c757786b3931671b72fc771/gcc%2Fconfig%2Fd30v%2Fd30v.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fd30v%2Fd30v.c?ref=a06ef755a376209a3c757786b3931671b72fc771", "patch": "@@ -1,5 +1,5 @@\n /* Definitions of target machine for Mitsubishi D30V.\n-   Copyright (C) 1997, 1998, 1999, 2000 Free Software Foundation, Inc.\n+   Copyright (C) 1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n    Contributed by Cygnus Solutions.\n \n    This file is part of GNU CC.\n@@ -2290,7 +2290,7 @@ d30v_expand_builtin_va_arg(valist, type)\n \t\t build_int_2 (1, 0));\n \n       emit_cmp_and_jump_insns (expand_expr (t, NULL_RTX, QImode, EXPAND_NORMAL),\n-\t\t\t       GEN_INT (0), EQ, const1_rtx, QImode, 1, 1,\n+\t\t\t       GEN_INT (0), EQ, const1_rtx, QImode, 1,\n \t\t\t       lab_false);\n \n       t = build (POSTINCREMENT_EXPR, TREE_TYPE (arg_num), arg_num,"}, {"sha": "29ee2884fc5cd3a0a5463054f446d08137126d36", "filename": "gcc/config/i860/i860.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a06ef755a376209a3c757786b3931671b72fc771/gcc%2Fconfig%2Fi860%2Fi860.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a06ef755a376209a3c757786b3931671b72fc771/gcc%2Fconfig%2Fi860%2Fi860.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi860%2Fi860.c?ref=a06ef755a376209a3c757786b3931671b72fc771", "patch": "@@ -2312,7 +2312,7 @@ i860_va_arg (valist, type)\n       emit_cmp_and_jump_insns (expand_expr (field, NULL_RTX, 0, 0),\n \t\t\t       GEN_INT (nparm - incr), GT, const0_rtx,\n \t\t\t       TYPE_MODE (TREE_TYPE (field)),\n-\t\t\t       TREE_UNSIGNED (field), 0, lab_false);\n+\t\t\t       TREE_UNSIGNED (field), lab_false);\n \n       t = fold (build (POSTINCREMENT_EXPR, TREE_TYPE (field), field,\n \t\t       build_int_2 (incr, 0)));"}, {"sha": "11bac1385ca2b32a765cdd69755a88ef009cab05", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a06ef755a376209a3c757786b3931671b72fc771/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a06ef755a376209a3c757786b3931671b72fc771/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=a06ef755a376209a3c757786b3931671b72fc771", "patch": "@@ -7398,7 +7398,7 @@ ia64_expand_fetch_and_op (binoptab, mode, arglist, target)\n     insn = gen_cmpxchg_acq_di (tmp, mem, tmp, ccv);\n   emit_insn (insn);\n \n-  emit_cmp_and_jump_insns (tmp, ret, NE, 0, mode, 1, 0, label);\n+  emit_cmp_and_jump_insns (tmp, ret, NE, 0, mode, 1, label);\n \n   return ret;\n }\n@@ -7463,7 +7463,7 @@ ia64_expand_op_and_fetch (binoptab, mode, arglist, target)\n     insn = gen_cmpxchg_acq_di (tmp, mem, ret, ccv);\n   emit_insn (insn);\n \n-  emit_cmp_and_jump_insns (tmp, old, NE, 0, mode, 1, 0, label);\n+  emit_cmp_and_jump_insns (tmp, old, NE, 0, mode, 1, label);\n \n   return ret;\n }"}, {"sha": "c51ed4e5640f1806f53b5e0371ea5846b6767646", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a06ef755a376209a3c757786b3931671b72fc771/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a06ef755a376209a3c757786b3931671b72fc771/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=a06ef755a376209a3c757786b3931671b72fc771", "patch": "@@ -2866,8 +2866,8 @@ rs6000_va_arg (valist, type)\n   addr_rtx = gen_reg_rtx (Pmode);\n \n   emit_cmp_and_jump_insns (expand_expr (reg, NULL_RTX, QImode, EXPAND_NORMAL),\n-\t\t\t   GEN_INT (8 - n_reg + 1),\n-\t\t\t   GE, const1_rtx, QImode, 1, 1, lab_false);\n+\t\t\t   GEN_INT (8 - n_reg + 1), GE, const1_rtx, QImode, 1,\n+\t\t\t   lab_false);\n \n   /* Long long is aligned in the registers.  */\n   if (n_reg > 1)"}, {"sha": "169684529fe67612daea608c25db20fc53a21940", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a06ef755a376209a3c757786b3931671b72fc771/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a06ef755a376209a3c757786b3931671b72fc771/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=a06ef755a376209a3c757786b3931671b72fc771", "patch": "@@ -4507,7 +4507,7 @@ sh_va_arg (valist, type)\n \t\t\t\t\t\tEXPAND_NORMAL),\n \t\t\t\t   expand_expr (next_fp_limit, NULL_RTX,\n \t\t\t\t\t\tPmode, EXPAND_NORMAL),\n-\t\t\t\t   GE, const1_rtx, Pmode, 1, 1, lab_false);\n+\t\t\t\t   GE, const1_rtx, Pmode, 1, lab_false);\n \n \t  if (TYPE_ALIGN (type) > BITS_PER_WORD)\n \t    {\n@@ -4542,7 +4542,7 @@ sh_va_arg (valist, type)\n \t\t\t\t\t\tEXPAND_NORMAL),\n \t\t\t\t   expand_expr (next_o_limit, NULL_RTX,\n \t\t\t\t\t\tPmode, EXPAND_NORMAL),\n-\t\t\t\t   GT, const1_rtx, Pmode, 1, 1, lab_false);\n+\t\t\t\t   GT, const1_rtx, Pmode, 1, lab_false);\n \n \t  tmp = build1 (ADDR_EXPR, pptr_type_node, next_o);\n \t  r = expand_expr (tmp, addr_rtx, Pmode, EXPAND_NORMAL);"}, {"sha": "86a3a6a396131a423603638e388afe7cb928df42", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a06ef755a376209a3c757786b3931671b72fc771/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a06ef755a376209a3c757786b3931671b72fc771/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=a06ef755a376209a3c757786b3931671b72fc771", "patch": "@@ -7941,10 +7941,9 @@ loc_descriptor_from_tree (loc, addressp)\n \tHOST_WIDE_INT bitsize, bitpos, bytepos;\n \tenum machine_mode mode;\n \tint volatilep;\n-\tunsigned int alignment;\n \n \tobj = get_inner_reference (loc, &bitsize, &bitpos, &offset, &mode,\n-\t\t\t\t   &unsignedp, &volatilep, &alignment);\n+\t\t\t\t   &unsignedp, &volatilep);\n \n \tif (obj == loc)\n \t  return 0;"}, {"sha": "9ad98f02cb4aef714c7c7280dc2456ac313cc04d", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a06ef755a376209a3c757786b3931671b72fc771/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a06ef755a376209a3c757786b3931671b72fc771/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=a06ef755a376209a3c757786b3931671b72fc771", "patch": "@@ -1862,7 +1862,8 @@ change_address (memref, mode, addr)\n   MEM_ATTRS (new)\n     = get_mem_attrs (MEM_ALIAS_SET (memref), 0, 0,\n \t\t     mmode == BLKmode ? 0 : GEN_INT (GET_MODE_SIZE (mmode)),\n-\t\t     mmode == BLKmode ? 1 : GET_MODE_ALIGNMENT (mmode),\n+\t\t     (mmode == BLKmode ? BITS_PER_UNIT\n+\t\t      : GET_MODE_ALIGNMENT (mmode)),\n \t\t     mmode);\n \n   return new;\n@@ -1915,8 +1916,8 @@ adjust_address_1 (memref, mode, offset, validate, adjust)\n     memalign = MIN (memalign, (offset & -offset) * BITS_PER_UNIT);\n \n   /* We can compute the size in a number of ways.  */\n-  if (mode != BLKmode)\n-    size = GEN_INT (GET_MODE_SIZE (mode));\n+  if (GET_MODE (new) != BLKmode)\n+    size = GEN_INT (GET_MODE_SIZE (GET_MODE (new)));\n   else if (MEM_SIZE (memref))\n     size = plus_constant (MEM_SIZE (memref), -offset);\n "}, {"sha": "62f626b4ef65053cf167d04c982c1c1366a5cc98", "filename": "gcc/except.c", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a06ef755a376209a3c757786b3931671b72fc771/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a06ef755a376209a3c757786b3931671b72fc771/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=a06ef755a376209a3c757786b3931671b72fc771", "patch": "@@ -1752,8 +1752,8 @@ build_post_landing_pads ()\n \t\telse\n \t\t  emit_cmp_and_jump_insns (cfun->eh->filter,\n \t\t\t\t\t   GEN_INT (c->u.catch.filter),\n-\t\t\t\t\t   EQ, NULL_RTX, word_mode,\n-\t\t\t\t\t   0, 0, c->label);\n+\t\t\t\t\t   EQ, NULL_RTX, word_mode, 0,\n+\t\t\t\t\t   c->label);\n \t      }\n \t  }\n \n@@ -1779,8 +1779,7 @@ build_post_landing_pads ()\n \n \t  emit_cmp_and_jump_insns (cfun->eh->filter,\n \t\t\t\t   GEN_INT (region->u.allowed.filter),\n-\t\t\t\t   EQ, NULL_RTX, word_mode, 0, 0,\n-\t\t\t\t   region->label);\n+\t\t\t\t   EQ, NULL_RTX, word_mode, 0, region->label);\n \n \t  /* We delay the generation of the _Unwind_Resume until we generate\n \t     landing pads.  We emit a marker here so as to get good control\n@@ -2152,8 +2151,7 @@ sjlj_emit_function_enter (dispatch_label)\n     NOTE_EXPECTED_VALUE (note) = gen_rtx_EQ (VOIDmode, x, const0_rtx);\n \n     emit_cmp_and_jump_insns (x, const0_rtx, NE, 0,\n-\t\t\t     TYPE_MODE (integer_type_node), 0, 0,\n-\t\t\t     dispatch_label);\n+\t\t\t     TYPE_MODE (integer_type_node), 0, dispatch_label);\n   }\n #else\n   expand_builtin_setjmp_setup (plus_constant (XEXP (fc, 0), sjlj_fc_jbuf_ofs),\n@@ -2261,9 +2259,8 @@ sjlj_emit_dispatch_table (dispatch_label, lp_info)\n \t  continue;\n \t}\n \n-      emit_cmp_and_jump_insns (dispatch,\n-\t\t\t       GEN_INT (lp_info[i].dispatch_index), EQ,\n-\t\t\t       NULL_RTX, TYPE_MODE (integer_type_node), 0, 0,\n+      emit_cmp_and_jump_insns (dispatch, GEN_INT (lp_info[i].dispatch_index),\n+\t\t\t       EQ, NULL_RTX, TYPE_MODE (integer_type_node), 0,\n \t\t\t       cfun->eh->region_array[i]->post_landing_pad);\n     }\n "}, {"sha": "dce99a29c8197286fb8c3c50e36e73cee4cce9d4", "filename": "gcc/explow.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a06ef755a376209a3c757786b3931671b72fc771/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a06ef755a376209a3c757786b3931671b72fc771/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=a06ef755a376209a3c757786b3931671b72fc771", "patch": "@@ -1348,7 +1348,7 @@ allocate_dynamic_stack_space (size, target, known_align)\n \t\t\t\t    NULL_RTX, 1, OPTAB_WIDEN);\n #endif\n \t  emit_cmp_and_jump_insns (available, size, GEU, NULL_RTX, Pmode, 1,\n-\t\t\t\t   0, space_available);\n+\t\t\t\t   space_available);\n #ifdef HAVE_trap\n \t  if (HAVE_trap)\n \t    emit_insn (gen_trap ());\n@@ -1564,7 +1564,7 @@ probe_stack_range (first, size)\n \n       emit_label (test_lab);\n       emit_cmp_and_jump_insns (test_addr, last_addr, CMP_OPCODE,\n-\t\t\t       NULL_RTX, Pmode, 1, 0, loop_lab);\n+\t\t\t       NULL_RTX, Pmode, 1, loop_lab);\n       emit_jump (end_lab);\n       emit_note (NULL, NOTE_INSN_LOOP_END);\n       emit_label (end_lab);"}, {"sha": "a06011ba9ed8bd00a42836351cda8e77704c0992", "filename": "gcc/expr.c", "status": "modified", "additions": 123, "deletions": 487, "changes": 610, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a06ef755a376209a3c757786b3931671b72fc771/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a06ef755a376209a3c757786b3931671b72fc771/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=a06ef755a376209a3c757786b3931671b72fc771", "patch": "@@ -158,13 +158,12 @@ static void store_constructor_field PARAMS ((rtx, unsigned HOST_WIDE_INT,\n static void store_constructor\tPARAMS ((tree, rtx, int, HOST_WIDE_INT));\n static rtx store_field\t\tPARAMS ((rtx, HOST_WIDE_INT,\n \t\t\t\t\t HOST_WIDE_INT, enum machine_mode,\n-\t\t\t\t\t tree, enum machine_mode, int,\n-\t\t\t\t\t HOST_WIDE_INT, int));\n+\t\t\t\t\t tree, enum machine_mode, int, tree,\n+\t\t\t\t\t int));\n static enum memory_use_mode\n   get_memory_usage_from_modifier PARAMS ((enum expand_modifier));\n static rtx var_rtx\t\tPARAMS ((tree));\n static HOST_WIDE_INT highest_pow2_factor PARAMS ((tree));\n-static rtx expand_expr_unaligned PARAMS ((tree, unsigned int *));\n static rtx expand_increment\tPARAMS ((tree, int, int));\n static void do_jump_by_parts_greater PARAMS ((tree, int, rtx, rtx));\n static void do_jump_by_parts_equality PARAMS ((tree, rtx, rtx));\n@@ -877,7 +876,7 @@ convert_move (to, from, unsignedp)\n \t      && STORE_FLAG_VALUE == -1)\n \t    {\n \t      emit_cmp_insn (lowfrom, const0_rtx, NE, NULL_RTX,\n-\t\t\t     lowpart_mode, 0, 0);\n+\t\t\t     lowpart_mode, 0);\n \t      fill_value = gen_reg_rtx (word_mode);\n \t      emit_insn (gen_slt (fill_value));\n \t    }\n@@ -3716,23 +3715,24 @@ expand_assignment (to, from, want_value, suggest_reg)\n     {\n       enum machine_mode mode1;\n       HOST_WIDE_INT bitsize, bitpos;\n+      rtx orig_to_rtx;\n       tree offset;\n       int unsignedp;\n       int volatilep = 0;\n       tree tem;\n-      unsigned int alignment;\n \n       push_temp_slots ();\n       tem = get_inner_reference (to, &bitsize, &bitpos, &offset, &mode1,\n-\t\t\t\t &unsignedp, &volatilep, &alignment);\n+\t\t\t\t &unsignedp, &volatilep);\n \n       /* If we are going to use store_bit_field and extract_bit_field,\n \t make sure to_rtx will be safe for multiple use.  */\n \n       if (mode1 == VOIDmode && want_value)\n \ttem = stabilize_reference (tem);\n \n-      to_rtx = expand_expr (tem, NULL_RTX, VOIDmode, EXPAND_MEMORY_USE_DONT);\n+      orig_to_rtx = to_rtx\n+\t= expand_expr (tem, NULL_RTX, VOIDmode, EXPAND_MEMORY_USE_DONT);\n       if (offset != 0)\n \t{\n \t  rtx offset_rtx = expand_expr (offset, NULL_RTX, VOIDmode, 0);\n@@ -3753,10 +3753,10 @@ expand_assignment (to, from, want_value, suggest_reg)\n \t  if (GET_CODE (to_rtx) == MEM\n \t      && GET_MODE (to_rtx) == BLKmode\n \t      && GET_MODE (XEXP (to_rtx, 0)) != VOIDmode\n-\t      && bitsize\n+\t      && bitsize > 0\n \t      && (bitpos % bitsize) == 0\n \t      && (bitsize % GET_MODE_ALIGNMENT (mode1)) == 0\n-\t      && alignment == GET_MODE_ALIGNMENT (mode1))\n+\t      && MEM_ALIGN (to_rtx) == GET_MODE_ALIGNMENT (mode1))\n \t    {\n \t      rtx temp\n \t\t= adjust_address (to_rtx, mode1, bitpos / BITS_PER_UNIT);\n@@ -3774,35 +3774,31 @@ expand_assignment (to, from, want_value, suggest_reg)\n \t\t\t\t   highest_pow2_factor (offset));\n \t}\n \n-      if (volatilep)\n-\t{\n-\t  if (GET_CODE (to_rtx) == MEM)\n-\t    {\n-\t      /* When the offset is zero, to_rtx is the address of the\n-\t\t structure we are storing into, and hence may be shared.\n-\t\t We must make a new MEM before setting the volatile bit.  */\n-\t      if (offset == 0)\n-\t\tto_rtx = copy_rtx (to_rtx);\n \n-\t      MEM_VOLATILE_P (to_rtx) = 1;\n-\t    }\n-#if 0  /* This was turned off because, when a field is volatile\n-\t  in an object which is not volatile, the object may be in a register,\n-\t  and then we would abort over here.  */\n-\t  else\n-\t    abort ();\n-#endif\n+      /* Deal with volatile and readonly fields.  The former is only done\n+\t for MEM.  Also set MEM_KEEP_ALIAS_SET_P if needed.  */\n+      if (volatilep && GET_CODE (to_rtx) == MEM)\n+\t{\n+\t  if (to_rtx == orig_to_rtx)\n+\t    to_rtx = copy_rtx (to_rtx);\n+\t  MEM_VOLATILE_P (to_rtx) = 1;\n \t}\n \n       if (TREE_CODE (to) == COMPONENT_REF\n \t  && TREE_READONLY (TREE_OPERAND (to, 1)))\n \t{\n-\t  if (offset == 0)\n+\t  if (to_rtx == orig_to_rtx)\n \t    to_rtx = copy_rtx (to_rtx);\n-\n \t  RTX_UNCHANGING_P (to_rtx) = 1;\n \t}\n \n+      if (! can_address_p (to))\n+\t{\n+\t  if (to_rtx == orig_to_rtx)\n+\t    to_rtx = copy_rtx (to_rtx);\n+\t  MEM_KEEP_ALIAS_SET_P (to_rtx) = 1;\n+\t}\n+\n       /* Check the access.  */\n       if (current_function_check_memory_usage && GET_CODE (to_rtx) == MEM)\n \t{\n@@ -3818,7 +3814,7 @@ expand_assignment (to, from, want_value, suggest_reg)\n \t    best_mode = QImode;\n \n \t  best_mode_size = GET_MODE_BITSIZE (best_mode);\n-\t  to_addr = plus_constant (XEXP (to_rtx, 0), (bitpos / BITS_PER_UNIT));\n+\t  to_addr = plus_constant (XEXP (to_rtx, 0), bitpos / BITS_PER_UNIT);\n \t  size = CEIL ((bitpos % best_mode_size) + bitsize, best_mode_size);\n \t  size *= GET_MODE_SIZE (best_mode);\n \n@@ -3833,50 +3829,25 @@ expand_assignment (to, from, want_value, suggest_reg)\n \t  in_check_memory_usage = 0;\n \t}\n \n-      /* If this is a varying-length object, we must get the address of\n-\t the source and do an explicit block move.  */\n-      if (bitsize < 0)\n-\t{\n-\t  unsigned int from_align;\n-\t  rtx from_rtx = expand_expr_unaligned (from, &from_align);\n-\t  rtx inner_to_rtx\n-\t    = adjust_address (to_rtx, BLKmode, bitpos / BITS_PER_UNIT);\n-\n-\t  emit_block_move (inner_to_rtx, from_rtx, expr_size (from));\n-\n-\t  free_temp_slots ();\n-\t  pop_temp_slots ();\n-\t  return to_rtx;\n-\t}\n-      else\n-\t{\n-\t  if (! can_address_p (to))\n-\t    {\n-\t      to_rtx = copy_rtx (to_rtx);\n-\t      MEM_KEEP_ALIAS_SET_P (to_rtx) = 1;\n-\t    }\n-\n-\t  result = store_field (to_rtx, bitsize, bitpos, mode1, from,\n-\t\t\t\t(want_value\n-\t\t\t\t /* Spurious cast for HPUX compiler.  */\n-\t\t\t\t ? ((enum machine_mode)\n-\t\t\t\t    TYPE_MODE (TREE_TYPE (to)))\n-\t\t\t\t : VOIDmode),\n-\t\t\t\tunsignedp, int_size_in_bytes (TREE_TYPE (tem)),\n-\t\t\t\tget_alias_set (to));\n+      result = store_field (to_rtx, bitsize, bitpos, mode1, from,\n+\t\t\t    (want_value\n+\t\t\t     /* Spurious cast for HPUX compiler.  */\n+\t\t\t     ? ((enum machine_mode)\n+\t\t\t\tTYPE_MODE (TREE_TYPE (to)))\n+\t\t\t     : VOIDmode),\n+\t\t\t    unsignedp, TREE_TYPE (tem), get_alias_set (to));\n \n-\t  preserve_temp_slots (result);\n-\t  free_temp_slots ();\n-\t  pop_temp_slots ();\n+      preserve_temp_slots (result);\n+      free_temp_slots ();\n+      pop_temp_slots ();\n \n-\t  /* If the value is meaningful, convert RESULT to the proper mode.\n-\t     Otherwise, return nothing.  */\n-\t  return (want_value ? convert_modes (TYPE_MODE (TREE_TYPE (to)),\n-\t\t\t\t\t      TYPE_MODE (TREE_TYPE (from)),\n-\t\t\t\t\t      result,\n-\t\t\t\t\t      TREE_UNSIGNED (TREE_TYPE (to)))\n-\t\t  : NULL_RTX);\n-\t}\n+      /* If the value is meaningful, convert RESULT to the proper mode.\n+\t Otherwise, return nothing.  */\n+      return (want_value ? convert_modes (TYPE_MODE (TREE_TYPE (to)),\n+\t\t\t\t\t  TYPE_MODE (TREE_TYPE (from)),\n+\t\t\t\t\t  result,\n+\t\t\t\t\t  TREE_UNSIGNED (TREE_TYPE (to)))\n+\t      : NULL_RTX);\n     }\n \n   /* If the rhs is a function call and its value is not an aggregate,\n@@ -4319,7 +4290,7 @@ store_expr (exp, target, want_value)\n \n \t\t  label = gen_label_rtx ();\n \t\t  emit_cmp_and_jump_insns (size, const0_rtx, LT, NULL_RTX,\n-\t\t\t\t\t   GET_MODE (size), 0, 0, label);\n+\t\t\t\t\t   GET_MODE (size), 0, label);\n \t\t}\n \n \t      if (size != const0_rtx)\n@@ -4495,8 +4466,8 @@ store_constructor_field (target, bitsize, bitpos, mode, exp, type, cleared,\n       store_constructor (exp, target, cleared, bitsize / BITS_PER_UNIT);\n     }\n   else\n-    store_field (target, bitsize, bitpos, mode, exp, VOIDmode, 0,\n-\t\t int_size_in_bytes (type), alias_set);\n+    store_field (target, bitsize, bitpos, mode, exp, VOIDmode, 0, type,\n+\t\t alias_set);\n }\n \n /* Store the value of constructor EXP into the rtx TARGET.\n@@ -5126,23 +5097,23 @@ store_constructor (exp, target, cleared, size)\n    has mode VALUE_MODE if that is convenient to do.\n    In this case, UNSIGNEDP must be nonzero if the value is an unsigned type.\n \n-   TOTAL_SIZE is the size in bytes of the structure, or -1 if varying.\n+   TYPE is the type of the underlying object,\n \n    ALIAS_SET is the alias set for the destination.  This value will\n    (in general) be different from that for TARGET, since TARGET is a\n    reference to the containing structure.  */\n \n static rtx\n-store_field (target, bitsize, bitpos, mode, exp, value_mode, unsignedp,\n-\t     total_size, alias_set)\n+store_field (target, bitsize, bitpos, mode, exp, value_mode, unsignedp, type,\n+\t     alias_set)\n      rtx target;\n      HOST_WIDE_INT bitsize;\n      HOST_WIDE_INT bitpos;\n      enum machine_mode mode;\n      tree exp;\n      enum machine_mode value_mode;\n      int unsignedp;\n-     HOST_WIDE_INT total_size;\n+     tree type;\n      int alias_set;\n {\n   HOST_WIDE_INT width_mask = 0;\n@@ -5154,8 +5125,7 @@ store_field (target, bitsize, bitpos, mode, exp, value_mode, unsignedp,\n      side-effects.  */\n   if (bitsize == 0)\n     return expand_expr (exp, const0_rtx, VOIDmode, 0);\n-\n-  if (bitsize < HOST_BITS_PER_WIDE_INT)\n+  else if (bitsize >=0 && bitsize < HOST_BITS_PER_WIDE_INT)\n     width_mask = ((HOST_WIDE_INT) 1 << bitsize) - 1;\n \n   /* If we are storing into an unaligned field of an aligned union that is\n@@ -5174,24 +5144,22 @@ store_field (target, bitsize, bitpos, mode, exp, value_mode, unsignedp,\n     {\n       rtx object\n \t= assign_temp\n-\t  (build_qualified_type (type_for_mode (GET_MODE (target), 0),\n-\t\t\t\t TYPE_QUAL_CONST),\n+\t  (build_qualified_type (type, TYPE_QUALS (type) | TYPE_QUAL_CONST),\n \t   0, 1, 1);\n       rtx blk_object = copy_rtx (object);\n \n       PUT_MODE (blk_object, BLKmode);\n-      set_mem_alias_set (blk_object, 0);\n+      MEM_COPY_ATTRIBUTES (blk_object, object);\n \n       if (bitsize != (HOST_WIDE_INT) GET_MODE_BITSIZE (GET_MODE (target)))\n \temit_move_insn (object, target);\n \n-      store_field (blk_object, bitsize, bitpos, mode, exp, VOIDmode, 0,\n-\t\t   total_size, alias_set);\n+      store_field (blk_object, bitsize, bitpos, mode, exp, VOIDmode, 0, type,\n+\t\t   alias_set);\n \n-      /* Even though we aren't returning target, we need to\n-\t give it the updated value.  */\n       emit_move_insn (target, object);\n \n+      /* We want to return the BLKmode version of the data.  */\n       return blk_object;\n     }\n \n@@ -5219,9 +5187,6 @@ store_field (target, bitsize, bitpos, mode, exp, value_mode, unsignedp,\n       || (mode != BLKmode && SLOW_UNALIGNED_ACCESS (mode, MEM_ALIGN (target))\n \t  && (MEM_ALIGN (target) < GET_MODE_ALIGNMENT (mode)\n \t      || bitpos % GET_MODE_ALIGNMENT (mode)))\n-      || (mode == BLKmode && SLOW_UNALIGNED_ACCESS (mode, MEM_ALIGN (target))\n-\t  && (TYPE_ALIGN (TREE_TYPE (exp)) > MEM_ALIGN (target)\n-\t      || bitpos % TYPE_ALIGN (TREE_TYPE (exp)) != 0))\n       /* If the RHS and field are a constant size and the size of the\n \t RHS isn't the same size as the bitfield, we must use bitfield\n \t operations.  */\n@@ -5260,15 +5225,16 @@ store_field (target, bitsize, bitpos, mode, exp, value_mode, unsignedp,\n \n \t  target = adjust_address (target, VOIDmode, bitpos / BITS_PER_UNIT);\n \t  emit_block_move (target, temp,\n-\t\t\t   bitsize == -1 ? expr_size (exp)\n-\t\t\t   : GEN_INT ((bitsize + BITS_PER_UNIT - 1)\n-\t\t\t\t      / BITS_PER_UNIT));\n+\t\t\t   GEN_INT ((bitsize + BITS_PER_UNIT - 1)\n+\t\t\t\t    / BITS_PER_UNIT));\n \n \t  return value_mode == VOIDmode ? const0_rtx : target;\n \t}\n \n       /* Store the value in the bitfield.  */\n-      store_bit_field (target, bitsize, bitpos, mode, temp, total_size);\n+      store_bit_field (target, bitsize, bitpos, mode, temp,\n+\t\t       int_size_in_bytes (type));\n+\n       if (value_mode != VOIDmode)\n \t{\n \t  /* The caller wants an rtx for the value.\n@@ -5298,14 +5264,14 @@ store_field (target, bitsize, bitpos, mode, exp, value_mode, unsignedp,\n \n \t  return extract_bit_field (target, bitsize, bitpos, unsignedp,\n \t\t\t\t    NULL_RTX, value_mode, VOIDmode,\n-\t\t\t\t    total_size);\n+\t\t\t\t    int_size_in_bytes (type));\n \t}\n       return const0_rtx;\n     }\n   else\n     {\n       rtx addr = XEXP (target, 0);\n-      rtx to_rtx;\n+      rtx to_rtx = target;\n \n       /* If a value is wanted, it must be the lhs;\n \t so make the address stable for multiple use.  */\n@@ -5317,19 +5283,18 @@ store_field (target, bitsize, bitpos, mode, exp, value_mode, unsignedp,\n \t\t&& GET_CODE (XEXP (addr, 1)) == CONST_INT\n \t\t&& (XEXP (addr, 0) == virtual_incoming_args_rtx\n \t\t    || XEXP (addr, 0) == virtual_stack_vars_rtx)))\n-\ttarget = replace_equiv_address (target, copy_to_reg (addr));\n+\tto_rtx = replace_equiv_address (to_rtx, copy_to_reg (addr));\n \n       /* Now build a reference to just the desired component.  */\n \n-      to_rtx = copy_rtx (adjust_address (target, mode,\n-\t\t\t\t\t bitpos / BITS_PER_UNIT));\n+      to_rtx = adjust_address (target, mode, bitpos / BITS_PER_UNIT);\n+\n+      if (to_rtx == target)\n+\tto_rtx = copy_rtx (to_rtx);\n \n       MEM_SET_IN_STRUCT_P (to_rtx, 1);\n       if (!MEM_KEEP_ALIAS_SET_P (to_rtx) && MEM_ALIAS_SET (to_rtx) != 0)\n-\t{\n-\t  to_rtx = copy_rtx (to_rtx);\n-\t  set_mem_alias_set (to_rtx, alias_set);\n-\t}\n+\tset_mem_alias_set (to_rtx, alias_set);\n \n       return store_expr (exp, to_rtx, value_mode != VOIDmode);\n     }\n@@ -5345,9 +5310,6 @@ store_field (target, bitsize, bitpos, mode, exp, value_mode, unsignedp,\n    giving the variable offset (in units) in *POFFSET.\n    This offset is in addition to the bit position.\n    If the position is not variable, we store 0 in *POFFSET.\n-   We set *PALIGNMENT to the alignment of the address that will be\n-   computed.  This is the alignment of the thing we return if *POFFSET\n-   is zero, but can be more less strictly aligned if *POFFSET is nonzero.\n \n    If any of the extraction expressions is volatile,\n    we store 1 in *PVOLATILEP.  Otherwise we don't change that.\n@@ -5362,21 +5324,19 @@ store_field (target, bitsize, bitpos, mode, exp, value_mode, unsignedp,\n \n tree\n get_inner_reference (exp, pbitsize, pbitpos, poffset, pmode,\n-\t\t     punsignedp, pvolatilep, palignment)\n+\t\t     punsignedp, pvolatilep)\n      tree exp;\n      HOST_WIDE_INT *pbitsize;\n      HOST_WIDE_INT *pbitpos;\n      tree *poffset;\n      enum machine_mode *pmode;\n      int *punsignedp;\n      int *pvolatilep;\n-     unsigned int *palignment;\n {\n   tree size_tree = 0;\n   enum machine_mode mode = VOIDmode;\n   tree offset = size_zero_node;\n   tree bit_offset = bitsize_zero_node;\n-  unsigned int alignment = BIGGEST_ALIGNMENT;\n   tree placeholder_ptr = 0;\n   tree tem;\n \n@@ -5438,8 +5398,7 @@ get_inner_reference (exp, pbitsize, pbitpos, poffset, pmode,\n \t  bit_offset = size_binop (PLUS_EXPR, bit_offset,\n \t\t\t\t   DECL_FIELD_BIT_OFFSET (field));\n \n-\t  if (! host_integerp (offset, 0))\n-\t    alignment = MIN (alignment, DECL_OFFSET_ALIGN (field));\n+\t  /* ??? Right now we don't do anything with DECL_OFFSET_ALIGN.  */\n \t}\n \n       else if (TREE_CODE (exp) == ARRAY_REF\n@@ -5500,19 +5459,9 @@ get_inner_reference (exp, pbitsize, pbitpos, poffset, pmode,\n       if (TREE_THIS_VOLATILE (exp))\n \t*pvolatilep = 1;\n \n-      /* If the offset is non-constant already, then we can't assume any\n-\t alignment more than the alignment here.  */\n-      if (! TREE_CONSTANT (offset))\n-\talignment = MIN (alignment, TYPE_ALIGN (TREE_TYPE (exp)));\n-\n       exp = TREE_OPERAND (exp, 0);\n     }\n \n-  if (DECL_P (exp))\n-    alignment = MIN (alignment, DECL_ALIGN (exp));\n-  else if (TREE_TYPE (exp) != 0)\n-    alignment = MIN (alignment, TYPE_ALIGN (TREE_TYPE (exp)));\n-\n   /* If OFFSET is constant, see if we can return the whole thing as a\n      constant bit position.  Otherwise, split it up.  */\n   if (host_integerp (offset, 0)\n@@ -5525,7 +5474,6 @@ get_inner_reference (exp, pbitsize, pbitpos, poffset, pmode,\n     *pbitpos = tree_low_cst (bit_offset, 0), *poffset = offset;\n \n   *pmode = mode;\n-  *palignment = alignment;\n   return exp;\n }\n \n@@ -6022,7 +5970,7 @@ highest_pow2_factor (exp)\n       return MAX (1, c0 / c1);\n \n     case NON_LVALUE_EXPR:  case NOP_EXPR:  case CONVERT_EXPR:\n-    case COMPOUND_EXPR:  case SAVE_EXPR:\n+    case COMPOUND_EXPR:    case SAVE_EXPR: case WITH_RECORD_EXPR:\n       return highest_pow2_factor (TREE_OPERAND (exp, 0));\n \n     case COND_EXPR:\n@@ -7011,10 +6959,8 @@ expand_expr (exp, target, tmode, modifier)\n \tHOST_WIDE_INT bitsize, bitpos;\n \ttree offset;\n \tint volatilep = 0;\n-\tunsigned int alignment;\n \ttree tem = get_inner_reference (exp, &bitsize, &bitpos, &offset,\n-\t\t\t\t\t&mode1, &unsignedp, &volatilep,\n-\t\t\t\t\t&alignment);\n+\t\t\t\t\t&mode1, &unsignedp, &volatilep);\n \trtx orig_op0;\n \n \t/* If we got back the original object, something is wrong.  Perhaps\n@@ -7100,7 +7046,7 @@ expand_expr (exp, target, tmode, modifier)\n \t\t&& bitsize != 0\n \t\t&& (bitpos % bitsize) == 0\n \t\t&& (bitsize % GET_MODE_ALIGNMENT (mode1)) == 0\n-\t\t&& alignment == GET_MODE_ALIGNMENT (mode1))\n+\t\t&& MEM_ALIGN (op0) == GET_MODE_ALIGNMENT (mode1))\n \t      {\n \t\trtx temp = adjust_address (op0, mode1, bitpos / BITS_PER_UNIT);\n \n@@ -7171,7 +7117,7 @@ expand_expr (exp, target, tmode, modifier)\n \t    /* If the field isn't aligned enough to fetch as a memref,\n \t       fetch it as a bit field.  */\n \t    || (mode1 != BLKmode\n-\t\t&& SLOW_UNALIGNED_ACCESS (mode1, alignment)\n+\t\t&& SLOW_UNALIGNED_ACCESS (mode1, MEM_ALIGN (op))\n \t\t&& ((TYPE_ALIGN (TREE_TYPE (tem))\n \t\t     < GET_MODE_ALIGNMENT (mode))\n \t\t    || (bitpos % GET_MODE_ALIGNMENT (mode) != 0)))\n@@ -7182,11 +7128,7 @@ expand_expr (exp, target, tmode, modifier)\n \t\t&& (TREE_CODE (TYPE_SIZE (TREE_TYPE (exp)))\n \t\t    == INTEGER_CST)\n \t\t&& 0 != compare_tree_int (TYPE_SIZE (TREE_TYPE (exp)),\n-\t\t\t\t\t  bitsize))\n-\t    || (mode == BLKmode\n-\t\t&& SLOW_UNALIGNED_ACCESS (mode, alignment)\n-\t\t&& (TYPE_ALIGN (type) > alignment\n-\t\t    || bitpos % TYPE_ALIGN (type) != 0)))\n+\t\t\t\t\t  bitsize)))\n \t  {\n \t    enum machine_mode ext_mode = mode;\n \n@@ -7210,9 +7152,8 @@ expand_expr (exp, target, tmode, modifier)\n \t\t  target = assign_temp (type, 0, 1, 1);\n \n \t\temit_block_move (target, op0,\n-\t\t\t\t bitsize == -1 ? expr_size  (exp)\n-\t\t\t\t : GEN_INT ((bitsize + BITS_PER_UNIT - 1)\n-\t\t\t\t\t    / BITS_PER_UNIT));\n+\t\t\t\t GEN_INT ((bitsize + BITS_PER_UNIT - 1)\n+\t\t\t\t\t  / BITS_PER_UNIT));\n \n \t\treturn target;\n \t      }\n@@ -7268,7 +7209,7 @@ expand_expr (exp, target, tmode, modifier)\n \n \tset_mem_attributes (op0, exp, 0);\n \tif (GET_CODE (XEXP (op0, 0)) == REG)\n-\t  mark_reg_pointer (XEXP (op0, 0), alignment);\n+\t  mark_reg_pointer (XEXP (op0, 0), MEM_ALIGN (op0));\n \n \tMEM_VOLATILE_P (op0) |= volatilep;\n \tif (mode == mode1 || mode1 == BLKmode || mode1 == tmode\n@@ -7375,17 +7316,13 @@ expand_expr (exp, target, tmode, modifier)\n \n \tif (! (GET_CODE (index_val) == CONST_INT\n \t       && GET_CODE (lo_r) == CONST_INT))\n-\t  {\n-\t    emit_cmp_and_jump_insns (index_val, lo_r, LT, NULL_RTX,\n-\t\t\t\t     GET_MODE (index_val), iunsignedp, 0, op1);\n-\t  }\n+\t  emit_cmp_and_jump_insns (index_val, lo_r, LT, NULL_RTX,\n+\t\t\t\t   GET_MODE (index_val), iunsignedp, op1);\n \n \tif (! (GET_CODE (index_val) == CONST_INT\n \t       && GET_CODE (hi_r) == CONST_INT))\n-\t  {\n-\t    emit_cmp_and_jump_insns (index_val, hi_r, GT, NULL_RTX,\n-\t\t\t\t     GET_MODE (index_val), iunsignedp, 0, op1);\n-\t  }\n+\t  emit_cmp_and_jump_insns (index_val, hi_r, GT, NULL_RTX,\n+\t\t\t\t   GET_MODE (index_val), iunsignedp, op1);\n \n \t/* Calculate the element number of bit zero in the first word\n \t   of the set.  */\n@@ -7511,7 +7448,7 @@ expand_expr (exp, target, tmode, modifier)\n \t\t\t       * BITS_PER_UNIT),\n \t\t\t      (HOST_WIDE_INT) GET_MODE_BITSIZE (mode)),\n \t\t\t 0, TYPE_MODE (valtype), TREE_OPERAND (exp, 0),\n-\t\t\t VOIDmode, 0, int_size_in_bytes (type), 0);\n+\t\t\t VOIDmode, 0, type, 0);\n \t  else\n \t    abort ();\n \n@@ -8021,7 +7958,7 @@ expand_expr (exp, target, tmode, modifier)\n \t{\n \t  int unsignedp = TREE_UNSIGNED (TREE_TYPE (TREE_OPERAND (exp, 1)));\n \t  do_compare_rtx_and_jump (target, op1, code == MAX_EXPR ? GE : LE,\n-\t\t\t\t   unsignedp, mode, NULL_RTX, 0, NULL_RTX,\n+\t\t\t\t   unsignedp, mode, NULL_RTX, NULL_RTX,\n \t\t\t\t   op0);\n \t}\n       emit_move_insn (target, op1);\n@@ -8114,7 +8051,7 @@ expand_expr (exp, target, tmode, modifier)\n \n \t  op1 = gen_label_rtx ();\n \t  emit_cmp_and_jump_insns (temp, const0_rtx, EQ, NULL_RTX,\n-\t\t\t\t   GET_MODE (temp), unsignedp, 0, op1);\n+\t\t\t\t   GET_MODE (temp), unsignedp, op1);\n \t  emit_move_insn (temp, const1_rtx);\n \t  emit_label (op1);\n \t  return temp;\n@@ -8680,8 +8617,7 @@ expand_expr (exp, target, tmode, modifier)\n \t\t   || GET_CODE (op0) == CONCAT || GET_CODE (op0) == ADDRESSOF\n \t\t   || GET_CODE (op0) == PARALLEL)\n \t    {\n-\t      /* If this object is in a register, it must be not\n-\t\t be BLKmode.  */\n+\t      /* If this object is in a register, it must can't be BLKmode.  */\n \t      tree inner_type = TREE_TYPE (TREE_OPERAND (exp, 0));\n \t      tree nt = build_qualified_type (inner_type,\n \t\t\t\t\t      (TYPE_QUALS (inner_type)\n@@ -8713,6 +8649,25 @@ expand_expr (exp, target, tmode, modifier)\n \t      return op0;\n \t    }\n \n+\t  /* If OP0 is not aligned as least as much as the type requires,\n+\t     we need to make a temporary, copy OP0 to it, and take the\n+\t     address of the temporary.  */\n+\t  if (expr_align (TREE_OPERAND (exp, 0)) > MEM_ALIGN (op0))\n+\t    {\n+\t      tree inner_type = TREE_TYPE (TREE_OPERAND (exp, 0));\n+\t      rtx new\n+\t\t= assign_stack_temp_for_type\n+\t\t  (TYPE_MODE (inner_type),\n+\t\t   MEM_SIZE (op0) ? INTVAL (MEM_SIZE (op0))\n+\t\t   : int_size_in_bytes (TREE_TYPE (inner_type)),\n+\t\t   1, build_qualified_type (inner_type,\n+\t\t\t\t\t    (TYPE_QUALS (inner_type)\n+\t\t\t\t\t     | TYPE_QUAL_CONST)));\n+\n+\t      emit_block_move (new, op0, expr_size (TREE_OPERAND (exp, 0)));\n+\t      op0 = new;\n+\t    }\n+\n \t  op0 = force_operand (XEXP (op0, 0), target);\n \t}\n \n@@ -8902,313 +8857,6 @@ expand_expr (exp, target, tmode, modifier)\n   return temp;\n }\n \f\n-/* Similar to expand_expr, except that we don't specify a target, target\n-   mode, or modifier and we return the alignment of the inner type.  This is\n-   used in cases where it is not necessary to align the result to the\n-   alignment of its type as long as we know the alignment of the result, for\n-   example for comparisons of BLKmode values.  */\n-\n-static rtx\n-expand_expr_unaligned (exp, palign)\n-     tree exp;\n-     unsigned int *palign;\n-{\n-  rtx op0;\n-  tree type = TREE_TYPE (exp);\n-  enum machine_mode mode = TYPE_MODE (type);\n-\n-  /* Default the alignment we return to that of the type.  */\n-  *palign = TYPE_ALIGN (type);\n-\n-  /* The only cases in which we do anything special is if the resulting mode\n-     is BLKmode.  */\n-  if (mode != BLKmode)\n-    return expand_expr (exp, NULL_RTX, VOIDmode, EXPAND_NORMAL);\n-\n-  switch (TREE_CODE (exp))\n-    {\n-    case CONVERT_EXPR:\n-    case NOP_EXPR:\n-    case NON_LVALUE_EXPR:\n-      /* Conversions between BLKmode values don't change the underlying\n-         alignment or value.  */\n-      if (TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0))) == BLKmode)\n-\treturn expand_expr_unaligned (TREE_OPERAND (exp, 0), palign);\n-      break;\n-\n-    case ARRAY_REF:\n-      /* Much of the code for this case is copied directly from expand_expr.\n-\t We need to duplicate it here because we will do something different\n-\t in the fall-through case, so we need to handle the same exceptions\n-\t it does.  */\n-      {\n-\ttree array = TREE_OPERAND (exp, 0);\n-\ttree domain = TYPE_DOMAIN (TREE_TYPE (array));\n-\ttree low_bound = domain ? TYPE_MIN_VALUE (domain) : integer_zero_node;\n-\ttree index = convert (sizetype, TREE_OPERAND (exp, 1));\n-\tHOST_WIDE_INT i;\n-\n-\tif (TREE_CODE (TREE_TYPE (TREE_OPERAND (exp, 0))) != ARRAY_TYPE)\n-\t  abort ();\n-\n-\t/* Optimize the special-case of a zero lower bound.\n-\n-\t   We convert the low_bound to sizetype to avoid some problems\n-\t   with constant folding.  (E.g. suppose the lower bound is 1,\n-\t   and its mode is QI.  Without the conversion,  (ARRAY\n-\t   +(INDEX-(unsigned char)1)) becomes ((ARRAY+(-(unsigned char)1))\n-\t   +INDEX), which becomes (ARRAY+255+INDEX).  Oops!)  */\n-\n-\tif (! integer_zerop (low_bound))\n-\t  index = size_diffop (index, convert (sizetype, low_bound));\n-\n-\t/* If this is a constant index into a constant array,\n-\t   just get the value from the array.  Handle both the cases when\n-\t   we have an explicit constructor and when our operand is a variable\n-\t   that was declared const.  */\n-\n-\tif (TREE_CODE (array) == CONSTRUCTOR && ! TREE_SIDE_EFFECTS (array)\n-\t    && host_integerp (index, 0)\n-\t    && 0 > compare_tree_int (index,\n-\t\t\t\t     list_length (CONSTRUCTOR_ELTS\n-\t\t\t\t\t\t  (TREE_OPERAND (exp, 0)))))\n-\t  {\n-\t    tree elem;\n-\n-\t    for (elem = CONSTRUCTOR_ELTS (TREE_OPERAND (exp, 0)),\n-\t\t i = tree_low_cst (index, 0);\n-\t\t elem != 0 && i != 0; i--, elem = TREE_CHAIN (elem))\n-\t      ;\n-\n-\t    if (elem)\n-\t      return expand_expr_unaligned (fold (TREE_VALUE (elem)), palign);\n-\t  }\n-\n-\telse if (optimize >= 1\n-\t\t && TREE_READONLY (array) && ! TREE_SIDE_EFFECTS (array)\n-\t\t && TREE_CODE (array) == VAR_DECL && DECL_INITIAL (array)\n-\t\t && TREE_CODE (DECL_INITIAL (array)) != ERROR_MARK)\n-\t  {\n-\t    if (TREE_CODE (index) == INTEGER_CST)\n-\t      {\n-\t\ttree init = DECL_INITIAL (array);\n-\n-\t\tif (TREE_CODE (init) == CONSTRUCTOR)\n-\t\t  {\n-\t\t    tree elem;\n-\n-\t\t    for (elem = CONSTRUCTOR_ELTS (init);\n-\t\t\t ! tree_int_cst_equal (TREE_PURPOSE (elem), index);\n-\t\t\t elem = TREE_CHAIN (elem))\n-\t\t      ;\n-\n-\t\t    if (elem)\n-\t\t      return expand_expr_unaligned (fold (TREE_VALUE (elem)),\n-\t\t\t\t\t\t    palign);\n-\t\t  }\n-\t      }\n-\t  }\n-      }\n-      /* Fall through.  */\n-\n-    case COMPONENT_REF:\n-    case BIT_FIELD_REF:\n-    case ARRAY_RANGE_REF:\n-      /* If the operand is a CONSTRUCTOR, we can just extract the\n-\t appropriate field if it is present.  Don't do this if we have\n-\t already written the data since we want to refer to that copy\n-\t and varasm.c assumes that's what we'll do.  */\n-      if (TREE_CODE (exp) == COMPONENT_REF\n-\t  && TREE_CODE (TREE_OPERAND (exp, 0)) == CONSTRUCTOR\n-\t  && TREE_CST_RTL (TREE_OPERAND (exp, 0)) == 0)\n-\t{\n-\t  tree elt;\n-\n-\t  for (elt = CONSTRUCTOR_ELTS (TREE_OPERAND (exp, 0)); elt;\n-\t       elt = TREE_CHAIN (elt))\n-\t    if (TREE_PURPOSE (elt) == TREE_OPERAND (exp, 1))\n-\t      /* Note that unlike the case in expand_expr, we know this is\n-\t\t BLKmode and hence not an integer.  */\n-\t      return expand_expr_unaligned (TREE_VALUE (elt), palign);\n-\t}\n-\n-      {\n-\tenum machine_mode mode1;\n-\tHOST_WIDE_INT bitsize, bitpos;\n-\ttree offset;\n-\tint volatilep = 0;\n-\tunsigned int alignment;\n-\tint unsignedp;\n-\ttree tem = get_inner_reference (exp, &bitsize, &bitpos, &offset,\n-\t\t\t\t\t&mode1, &unsignedp, &volatilep,\n-\t\t\t\t\t&alignment);\n-\n-\t/* If we got back the original object, something is wrong.  Perhaps\n-\t   we are evaluating an expression too early.  In any event, don't\n-\t   infinitely recurse.  */\n-\tif (tem == exp)\n-\t  abort ();\n-\n-\top0 = expand_expr (tem, NULL_RTX, VOIDmode, EXPAND_NORMAL);\n-\n-\t/* If this is a constant, put it into a register if it is a\n-\t   legitimate constant and OFFSET is 0 and memory if it isn't.  */\n-\tif (CONSTANT_P (op0))\n-\t  {\n-\t    enum machine_mode inner_mode = TYPE_MODE (TREE_TYPE (tem));\n-\n-\t    if (inner_mode != BLKmode && LEGITIMATE_CONSTANT_P (op0)\n-\t\t&& offset == 0)\n-\t      op0 = force_reg (inner_mode, op0);\n-\t    else\n-\t      op0 = validize_mem (force_const_mem (inner_mode, op0));\n-\t  }\n-\n-\tif (offset != 0)\n-\t  {\n-\t    rtx offset_rtx = expand_expr (offset, NULL_RTX, VOIDmode, 0);\n-\n-\t    /* If this object is in a register, put it into memory.\n-\t       This case can't occur in C, but can in Ada if we have\n-\t       unchecked conversion of an expression from a scalar type to\n-\t       an array or record type.  */\n-\t    if (GET_CODE (op0) == REG || GET_CODE (op0) == SUBREG\n-\t\t|| GET_CODE (op0) == CONCAT || GET_CODE (op0) == ADDRESSOF)\n-\t      {\n-\t\ttree nt = build_qualified_type (TREE_TYPE (tem),\n-\t\t\t\t\t\t(TYPE_QUALS (TREE_TYPE (tem))\n-\t\t\t\t\t\t | TYPE_QUAL_CONST));\n-\t\trtx memloc = assign_temp (nt, 1, 1, 1);\n-\n-\t\temit_move_insn (memloc, op0);\n-\t\top0 = memloc;\n-\t      }\n-\n-\t    if (GET_CODE (op0) != MEM)\n-\t      abort ();\n-\n-\t    if (GET_MODE (offset_rtx) != ptr_mode)\n-\t      offset_rtx = convert_to_mode (ptr_mode, offset_rtx, 0);\n-\n-#ifdef POINTERS_EXTEND_UNSIGNED\n-\t    if (GET_MODE (offset_rtx) != Pmode)\n-\t      offset_rtx = convert_memory_address (Pmode, offset_rtx);\n-#endif\n-\n-\t    op0 = offset_address (op0, offset_rtx,\n-\t\t\t\t  highest_pow2_factor (offset));\n-\t  }\n-\n-\t/* Don't forget about volatility even if this is a bitfield.  */\n-\tif (GET_CODE (op0) == MEM && volatilep && ! MEM_VOLATILE_P (op0))\n-\t  {\n-\t    op0 = copy_rtx (op0);\n-\t    MEM_VOLATILE_P (op0) = 1;\n-\t  }\n-\n-\t/* Check the access.  */\n-\tif (current_function_check_memory_usage && GET_CODE (op0) == MEM)\n-\t  {\n-\t    rtx to;\n-\t    int size;\n-\n-\t    to = plus_constant (XEXP (op0, 0), (bitpos / BITS_PER_UNIT));\n-\t    size = (bitpos % BITS_PER_UNIT) + bitsize + BITS_PER_UNIT - 1;\n-\n-\t    /* Check the access right of the pointer.  */\n-\t    in_check_memory_usage = 1;\n-\t    if (size > BITS_PER_UNIT)\n-\t      emit_library_call (chkr_check_addr_libfunc,\n-\t\t\t\t LCT_CONST_MAKE_BLOCK, VOIDmode, 3,\n-\t\t\t\t to, ptr_mode, GEN_INT (size / BITS_PER_UNIT),\n-\t\t\t\t TYPE_MODE (sizetype),\n-\t\t\t\t GEN_INT (MEMORY_USE_RO),\n-\t\t\t\t TYPE_MODE (integer_type_node));\n-\t    in_check_memory_usage = 0;\n-\t  }\n-\n-\t/* In cases where an aligned union has an unaligned object\n-\t   as a field, we might be extracting a BLKmode value from\n-\t   an integer-mode (e.g., SImode) object.  Handle this case\n-\t   by doing the extract into an object as wide as the field\n-\t   (which we know to be the width of a basic mode), then\n-\t   storing into memory, and changing the mode to BLKmode.\n-\t   If we ultimately want the address (EXPAND_CONST_ADDRESS or\n-\t   EXPAND_INITIALIZER), then we must not copy to a temporary.  */\n-\tif (mode1 == VOIDmode\n-\t    || GET_CODE (op0) == REG || GET_CODE (op0) == SUBREG\n-\t    || (SLOW_UNALIGNED_ACCESS (mode1, alignment)\n-\t\t&& (TYPE_ALIGN (type) > alignment\n-\t\t    || bitpos % TYPE_ALIGN (type) != 0)))\n-\t  {\n-\t    enum machine_mode ext_mode = mode_for_size (bitsize, MODE_INT, 1);\n-\n-\t    if (ext_mode == BLKmode)\n-\t      {\n-\t\t/* In this case, BITPOS must start at a byte boundary.  */\n-\t\tif (GET_CODE (op0) != MEM\n-\t\t    || bitpos % BITS_PER_UNIT != 0)\n-\t\t  abort ();\n-\n-\t\top0 = adjust_address (op0, VOIDmode, bitpos / BITS_PER_UNIT);\n-\t      }\n-\t    else\n-\t      {\n-\t\ttree nt = build_qualified_type (type_for_mode (ext_mode, 0),\n-\t\t\t\t\t\tTYPE_QUAL_CONST);\n-\t\trtx new = assign_temp (nt, 0, 1, 1);\n-\n-\t\top0 = extract_bit_field (validize_mem (op0), bitsize, bitpos,\n-\t\t\t\t\t unsignedp, NULL_RTX, ext_mode,\n-\t\t\t\t\t ext_mode,\n-\t\t\t\t\t int_size_in_bytes (TREE_TYPE (tem)));\n-\n-\t\t/* If the result is a record type and BITSIZE is narrower than\n-\t\t   the mode of OP0, an integral mode, and this is a big endian\n-\t\t   machine, we must put the field into the high-order bits.  */\n-\t\tif (TREE_CODE (type) == RECORD_TYPE && BYTES_BIG_ENDIAN\n-\t\t    && GET_MODE_CLASS (GET_MODE (op0)) == MODE_INT\n-\t\t    && bitsize < GET_MODE_BITSIZE (GET_MODE (op0)))\n-\t\t  op0 = expand_shift (LSHIFT_EXPR, GET_MODE (op0), op0,\n-\t\t\t\t      size_int (GET_MODE_BITSIZE\n-\t\t\t\t\t\t(GET_MODE (op0))\n-\t\t\t\t\t\t- bitsize),\n-\t\t\t\t      op0, 1);\n-\n-\t\temit_move_insn (new, op0);\n-\t\top0 = copy_rtx (new);\n-\t\tPUT_MODE (op0, BLKmode);\n-\t      }\n-\t  }\n-\telse\n-\t  /* Get a reference to just this component.  */\n-\t  op0 = adjust_address (op0, mode1, bitpos / BITS_PER_UNIT);\n-\n-\tset_mem_attributes (op0, exp, 0);\n-\n-\t/* Adjust the alignment in case the bit position is not\n-\t   a multiple of the alignment of the inner object.  */\n-\twhile (bitpos % alignment != 0)\n-\t  alignment >>= 1;\n-\n-\tif (GET_CODE (XEXP (op0, 0)) == REG)\n-\t  mark_reg_pointer (XEXP (op0, 0), alignment);\n-\n-\tMEM_IN_STRUCT_P (op0) = 1;\n-\tMEM_VOLATILE_P (op0) |= volatilep;\n-\n-\t*palign = alignment;\n-\treturn op0;\n-      }\n-\n-    default:\n-      break;\n-\n-    }\n-\n-  return expand_expr (exp, NULL_RTX, VOIDmode, EXPAND_NORMAL);\n-}\n-\f\n /* Return the tree node if a ARG corresponds to a string constant or zero\n    if it doesn't.  If we return non-zero, set *PTR_OFFSET to the offset\n    in bytes within the string that ARG is accessing.  The type of the\n@@ -9697,12 +9345,11 @@ do_jump (exp, if_false_label, if_true_label)\n \ttree type;\n \ttree offset;\n \tint volatilep = 0;\n-\tunsigned int alignment;\n \n \t/* Get description of this reference.  We don't actually care\n \t   about the underlying object here.  */\n \tget_inner_reference (exp, &bitsize, &bitpos, &offset, &mode,\n-\t\t\t     &unsignedp, &volatilep, &alignment);\n+\t\t\t     &unsignedp, &volatilep);\n \n \ttype = type_for_size (bitsize, unsignedp);\n \tif (! SLOW_BYTE_ACCESS\n@@ -10004,7 +9651,7 @@ do_jump (exp, if_false_label, if_true_label)\n       else if (GET_MODE (temp) != VOIDmode)\n \tdo_compare_rtx_and_jump (temp, CONST0_RTX (GET_MODE (temp)),\n \t\t\t\t NE, TREE_UNSIGNED (TREE_TYPE (exp)),\n-\t\t\t\t GET_MODE (temp), NULL_RTX, 0,\n+\t\t\t\t GET_MODE (temp), NULL_RTX,\n \t\t\t\t if_false_label, if_true_label);\n       else\n \tabort ();\n@@ -10079,12 +9726,12 @@ do_jump_by_parts_greater_rtx (mode, unsignedp, op0, op1, if_false_label, if_true\n \n       /* All but high-order word must be compared as unsigned.  */\n       do_compare_rtx_and_jump (op0_word, op1_word, GT,\n-\t\t\t       (unsignedp || i > 0), word_mode, NULL_RTX, 0,\n+\t\t\t       (unsignedp || i > 0), word_mode, NULL_RTX,\n \t\t\t       NULL_RTX, if_true_label);\n \n       /* Consider lower words only if these are equal.  */\n       do_compare_rtx_and_jump (op0_word, op1_word, NE, unsignedp, word_mode,\n-\t\t\t       NULL_RTX, 0, NULL_RTX, if_false_label);\n+\t\t\t       NULL_RTX, NULL_RTX, if_false_label);\n     }\n \n   if (if_false_label)\n@@ -10115,8 +9762,7 @@ do_jump_by_parts_equality (exp, if_false_label, if_true_label)\n     do_compare_rtx_and_jump (operand_subword_force (op0, i, mode),\n \t\t\t     operand_subword_force (op1, i, mode),\n \t\t\t     EQ, TREE_UNSIGNED (TREE_TYPE (exp)),\n-\t\t\t     word_mode, NULL_RTX, 0, if_false_label,\n-\t\t\t     NULL_RTX);\n+\t\t\t     word_mode, NULL_RTX, if_false_label, NULL_RTX);\n \n   if (if_true_label)\n     emit_jump (if_true_label);\n@@ -10153,7 +9799,7 @@ do_jump_by_parts_equality_rtx (op0, if_false_label, if_true_label)\n   if (part != 0)\n     {\n       do_compare_rtx_and_jump (part, const0_rtx, EQ, 1, word_mode,\n-\t\t\t       NULL_RTX, 0, if_false_label, if_true_label);\n+\t\t\t       NULL_RTX, if_false_label, if_true_label);\n \n       return;\n     }\n@@ -10164,7 +9810,7 @@ do_jump_by_parts_equality_rtx (op0, if_false_label, if_true_label)\n \n   for (i = 0; i < nwords; i++)\n     do_compare_rtx_and_jump (operand_subword_force (op0, i, GET_MODE (op0)),\n-\t\t\t     const0_rtx, EQ, 1, word_mode, NULL_RTX, 0,\n+\t\t\t     const0_rtx, EQ, 1, word_mode, NULL_RTX,\n \t\t\t     if_false_label, NULL_RTX);\n \n   if (if_true_label)\n@@ -10183,19 +9829,15 @@ do_jump_by_parts_equality_rtx (op0, if_false_label, if_true_label)\n    things pushed on the stack that aren't yet used.\n \n    If MODE is BLKmode, SIZE is an RTX giving the size of the objects being\n-   compared.\n-\n-   If ALIGN is non-zero, it is the alignment of this type; if zero, the\n-   size of MODE should be used.  */\n+   compared.  */\n \n rtx\n-compare_from_rtx (op0, op1, code, unsignedp, mode, size, align)\n+compare_from_rtx (op0, op1, code, unsignedp, mode, size)\n      rtx op0, op1;\n      enum rtx_code code;\n      int unsignedp;\n      enum machine_mode mode;\n      rtx size;\n-     unsigned int align;\n {\n   rtx tem;\n \n@@ -10244,7 +9886,7 @@ compare_from_rtx (op0, op1, code, unsignedp, mode, size, align)\n     }\n #endif\n \n-  emit_cmp_insn (op0, op1, code, size, mode, unsignedp, align);\n+  emit_cmp_insn (op0, op1, code, size, mode, unsignedp);\n \n   return gen_rtx_fmt_ee (code, VOIDmode, cc0_rtx, const0_rtx);\n }\n@@ -10253,20 +9895,16 @@ compare_from_rtx (op0, op1, code, unsignedp, mode, size, align)\n    The decision as to signed or unsigned comparison must be made by the caller.\n \n    If MODE is BLKmode, SIZE is an RTX giving the size of the objects being\n-   compared.\n-\n-   If ALIGN is non-zero, it is the alignment of this type; if zero, the\n-   size of MODE should be used.  */\n+   compared.  */\n \n void\n-do_compare_rtx_and_jump (op0, op1, code, unsignedp, mode, size, align,\n+do_compare_rtx_and_jump (op0, op1, code, unsignedp, mode, size,\n \t\t\t if_false_label, if_true_label)\n      rtx op0, op1;\n      enum rtx_code code;\n      int unsignedp;\n      enum machine_mode mode;\n      rtx size;\n-     unsigned int align;\n      rtx if_false_label, if_true_label;\n {\n   rtx tem;\n@@ -10344,7 +9982,7 @@ do_compare_rtx_and_jump (op0, op1, code, unsignedp, mode, size, align,\n       if_true_label = gen_label_rtx ();\n     }\n \n-  emit_cmp_and_jump_insns (op0, op1, code, size, mode, unsignedp, align,\n+  emit_cmp_and_jump_insns (op0, op1, code, size, mode, unsignedp,\n \t\t\t   if_true_label);\n \n   if (if_false_label)\n@@ -10370,19 +10008,18 @@ do_compare_and_jump (exp, signed_code, unsigned_code, if_false_label,\n      enum rtx_code signed_code, unsigned_code;\n      rtx if_false_label, if_true_label;\n {\n-  unsigned int align0, align1;\n   rtx op0, op1;\n   tree type;\n   enum machine_mode mode;\n   int unsignedp;\n   enum rtx_code code;\n \n   /* Don't crash if the comparison was erroneous.  */\n-  op0 = expand_expr_unaligned (TREE_OPERAND (exp, 0), &align0);\n+  op0 = expand_expr (TREE_OPERAND (exp, 0), NULL_RTX, VOIDmode, 0);\n   if (TREE_CODE (TREE_OPERAND (exp, 0)) == ERROR_MARK)\n     return;\n \n-  op1 = expand_expr_unaligned (TREE_OPERAND (exp, 1), &align1);\n+  op1 = expand_expr (TREE_OPERAND (exp, 1), NULL_RTX, VOIDmode, 0);\n   if (TREE_CODE (TREE_OPERAND (exp, 1)) == ERROR_MARK)\n     return;\n \n@@ -10434,7 +10071,6 @@ do_compare_and_jump (exp, signed_code, unsigned_code, if_false_label,\n   do_compare_rtx_and_jump (op0, op1, code, unsignedp, mode,\n \t\t\t   ((mode == BLKmode)\n \t\t\t    ? expr_size (TREE_OPERAND (exp, 0)) : NULL_RTX),\n-\t\t\t   MIN (align0, align1),\n \t\t\t   if_false_label, if_true_label);\n }\n \f\n@@ -10713,7 +10349,7 @@ do_store_flag (exp, target, mode, only_cheap)\n \n   emit_move_insn (target, invert ? const0_rtx : const1_rtx);\n   result = compare_from_rtx (op0, op1, code, unsignedp,\n-\t\t\t     operand_mode, NULL_RTX, 0);\n+\t\t\t     operand_mode, NULL_RTX);\n   if (GET_CODE (result) == CONST_INT)\n     return (((result == const0_rtx && ! invert)\n \t     || (result != const0_rtx && invert))\n@@ -10780,7 +10416,7 @@ try_casesi (index_type, index_expr, minval, range,\n       minval = integer_zero_node;\n       index = expand_expr (index_expr, NULL_RTX, VOIDmode, 0);\n       emit_cmp_and_jump_insns (rangertx, index, LTU, NULL_RTX,\n-\t\t\t       omode, 1, 0, default_label);\n+\t\t\t       omode, 1, default_label);\n       /* Now we can safely truncate.  */\n       index = convert_to_mode (index_mode, index, 0);\n     }\n@@ -10860,7 +10496,7 @@ do_tablejump (index, mode, range, table_label, default_label)\n      the maximum value of the range.  */\n \n   emit_cmp_and_jump_insns (index, range, GTU, NULL_RTX, mode, 1,\n-\t\t\t   0, default_label);\n+\t\t\t   default_label);\n \n   /* If index is in range, it must fit in Pmode.\n      Convert to Pmode so we can index with it.  */"}, {"sha": "764e0818a8a101221992542d8e2a278e9679dd16", "filename": "gcc/expr.h", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a06ef755a376209a3c757786b3931671b72fc771/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a06ef755a376209a3c757786b3931671b72fc771/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=a06ef755a376209a3c757786b3931671b72fc771", "patch": "@@ -302,8 +302,7 @@ extern int have_sub2_insn PARAMS ((rtx, rtx));\n /* Emit a pair of rtl insns to compare two rtx's and to jump \n    to a label if the comparison is true.  */\n extern void emit_cmp_and_jump_insns PARAMS ((rtx, rtx, enum rtx_code, rtx,\n-\t\t\t\t\t     enum machine_mode, int,\n-\t\t\t\t\t     unsigned int, rtx));\n+\t\t\t\t\t     enum machine_mode, int, rtx));\n \n /* Generate code to indirectly jump to a location given in the rtx LOC.  */\n extern void emit_indirect_jump PARAMS ((rtx));\n@@ -542,10 +541,10 @@ extern void do_jump PARAMS ((tree, rtx, rtx));\n \n /* Generate rtl to compare two rtx's, will call emit_cmp_insn.  */\n extern rtx compare_from_rtx PARAMS ((rtx, rtx, enum rtx_code, int,\n-\t\t\t\t     enum machine_mode, rtx, unsigned int));\n+\t\t\t\t     enum machine_mode, rtx));\n extern void do_compare_rtx_and_jump PARAMS ((rtx, rtx, enum rtx_code, int,\n \t\t\t\t\t     enum machine_mode, rtx,\n-\t\t\t\t\t     unsigned int, rtx, rtx));\n+\t\t\t\t\t     rtx, rtx));\n \n /* Two different ways of generating switch statements.  */\n extern int try_casesi    PARAMS ((tree, tree, tree, tree, rtx, rtx));"}, {"sha": "f7cdc57d42133d8cafa7329bf1a35caea902f289", "filename": "gcc/fold-const.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a06ef755a376209a3c757786b3931671b72fc771/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a06ef755a376209a3c757786b3931671b72fc771/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=a06ef755a376209a3c757786b3931671b72fc771", "patch": "@@ -3025,7 +3025,6 @@ optimize_bit_field_compare (code, compare_type, lhs, rhs)\n   enum machine_mode lmode, rmode, nmode;\n   int lunsignedp, runsignedp;\n   int lvolatilep = 0, rvolatilep = 0;\n-  unsigned int alignment;\n   tree linner, rinner = NULL_TREE;\n   tree mask;\n   tree offset;\n@@ -3036,7 +3035,7 @@ optimize_bit_field_compare (code, compare_type, lhs, rhs)\n      do anything if the inner expression is a PLACEHOLDER_EXPR since we\n      then will no longer be able to replace it.  */\n   linner = get_inner_reference (lhs, &lbitsize, &lbitpos, &offset, &lmode,\n-\t\t\t\t&lunsignedp, &lvolatilep, &alignment);\n+\t\t\t\t&lunsignedp, &lvolatilep);\n   if (linner == lhs || lbitsize == GET_MODE_BITSIZE (lmode) || lbitsize < 0\n       || offset != 0 || TREE_CODE (linner) == PLACEHOLDER_EXPR)\n     return 0;\n@@ -3046,7 +3045,7 @@ optimize_bit_field_compare (code, compare_type, lhs, rhs)\n      /* If this is not a constant, we can only do something if bit positions,\n \tsizes, and signedness are the same.  */\n      rinner = get_inner_reference (rhs, &rbitsize, &rbitpos, &offset, &rmode,\n-\t\t\t\t   &runsignedp, &rvolatilep, &alignment);\n+\t\t\t\t   &runsignedp, &rvolatilep);\n \n      if (rinner == rhs || lbitpos != rbitpos || lbitsize != rbitsize\n \t || lunsignedp != runsignedp || offset != 0\n@@ -3204,7 +3203,6 @@ decode_field_reference (exp, pbitsize, pbitpos, pmode, punsignedp,\n   tree mask, inner, offset;\n   tree unsigned_type;\n   unsigned int precision;\n-  unsigned int alignment;\n \n   /* All the optimizations using this function assume integer fields.\n      There are problems with FP fields since the type_for_size call\n@@ -3224,7 +3222,7 @@ decode_field_reference (exp, pbitsize, pbitpos, pmode, punsignedp,\n     }\n \n   inner = get_inner_reference (exp, pbitsize, pbitpos, &offset, pmode,\n-\t\t\t       punsignedp, pvolatilep, &alignment);\n+\t\t\t       punsignedp, pvolatilep);\n   if ((inner == exp && and_mask == 0)\n       || *pbitsize < 0 || offset != 0\n       || TREE_CODE (inner) == PLACEHOLDER_EXPR)"}, {"sha": "4d382856138b4a5a1631b347189dc2e60b7c9ede", "filename": "gcc/function.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a06ef755a376209a3c757786b3931671b72fc771/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a06ef755a376209a3c757786b3931671b72fc771/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=a06ef755a376209a3c757786b3931671b72fc771", "patch": "@@ -231,8 +231,6 @@ struct insns_for_mem_entry\n \n static rtx assign_stack_local_1 PARAMS ((enum machine_mode, HOST_WIDE_INT,\n \t\t\t\t\t int, struct function *));\n-static rtx assign_stack_temp_for_type PARAMS ((enum machine_mode,\n-\t\t\t\t\t       HOST_WIDE_INT, int, tree));\n static struct temp_slot *find_temp_slot_from_address  PARAMS ((rtx));\n static void put_reg_into_stack\tPARAMS ((struct function *, rtx, tree,\n \t\t\t\t\t enum machine_mode, enum machine_mode,\n@@ -629,7 +627,7 @@ assign_stack_local (mode, size, align)\n \n    TYPE is the type that will be used for the stack slot.  */\n \n-static rtx\n+rtx\n assign_stack_temp_for_type (mode, size, keep, type)\n      enum machine_mode mode;\n      HOST_WIDE_INT size;"}, {"sha": "3c5a701a75f21cfec49219b40ac72abeb4ea9e0f", "filename": "gcc/loop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a06ef755a376209a3c757786b3931671b72fc771/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a06ef755a376209a3c757786b3931671b72fc771/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=a06ef755a376209a3c757786b3931671b72fc771", "patch": "@@ -7663,7 +7663,7 @@ check_dbra_loop (loop, insn_count)\n \t      /* Add new compare/branch insn at end of loop.  */\n \t      start_sequence ();\n \t      emit_cmp_and_jump_insns (reg, const0_rtx, cmp_code, NULL_RTX,\n-\t\t\t\t       GET_MODE (reg), 0, 0,\n+\t\t\t\t       GET_MODE (reg), 0,\n \t\t\t\t       XEXP (jump_label, 0));\n \t      tem = gen_sequence ();\n \t      end_sequence ();"}, {"sha": "e26a046dc71ac705fc5d6cd48de7e76c182af6a3", "filename": "gcc/optabs.c", "status": "modified", "additions": 24, "deletions": 27, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a06ef755a376209a3c757786b3931671b72fc771/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a06ef755a376209a3c757786b3931671b72fc771/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=a06ef755a376209a3c757786b3931671b72fc771", "patch": "@@ -96,10 +96,14 @@ static int expand_cmplxdiv_wide PARAMS ((rtx, rtx, rtx, rtx,\n \t\t\t\t       rtx, rtx, enum machine_mode,\n \t\t\t\t       int, enum optab_methods,\n \t\t\t\t       enum mode_class, optab));\n+static void prepare_cmp_insn PARAMS ((rtx *, rtx *, enum rtx_code *, rtx,\n+\t\t\t\t      enum machine_mode *, int *,\n+\t\t\t\t      enum can_compare_purpose));\n static enum insn_code can_fix_p\tPARAMS ((enum machine_mode, enum machine_mode,\n \t\t\t\t       int, int *));\n-static enum insn_code can_float_p PARAMS ((enum machine_mode, enum machine_mode,\n-\t\t\t\t\t int));\n+static enum insn_code can_float_p PARAMS ((enum machine_mode,\n+\t\t\t\t\t   enum machine_mode,\n+\t\t\t\t\t   int));\n static rtx ftruncify\tPARAMS ((rtx));\n static optab new_optab\tPARAMS ((void));\n static inline optab init_optab\tPARAMS ((enum rtx_code));\n@@ -352,7 +356,6 @@ expand_cmplxdiv_wide (real0, real1, imag0, imag1, realr, imagr, submode,\n   rtx real_t, imag_t;\n   rtx temp1, temp2, lab1, lab2;\n   enum machine_mode mode;\n-  int align;\n   rtx res;\n   optab this_add_optab = add_optab;\n   optab this_sub_optab = sub_optab;\n@@ -392,10 +395,9 @@ expand_cmplxdiv_wide (real0, real1, imag0, imag1, realr, imagr, submode,\n     return 0;\n \n   mode = GET_MODE (temp1);\n-  align = GET_MODE_ALIGNMENT (mode);\n   lab1 = gen_label_rtx ();\n   emit_cmp_and_jump_insns (temp1, temp2, LT, NULL_RTX,\n-\t\t\t   mode, unsignedp, align, lab1);\n+\t\t\t   mode, unsignedp, lab1);\n \n   /* |c| >= |d|; use ratio d/c to scale dividend and divisor.  */\n \n@@ -2419,7 +2421,7 @@ expand_abs (mode, op0, target, result_unsignedp, safe)\n \t\t\t\t  NULL_RTX, op1);\n   else\n     do_compare_rtx_and_jump (target, CONST0_RTX (mode), GE, 0, mode,\n-\t\t\t     NULL_RTX, 0, NULL_RTX, op1);\n+\t\t\t     NULL_RTX, NULL_RTX, op1);\n \n   op0 = expand_unop (mode, result_unsignedp ? neg_optab : negv_optab,\n                      target, target, 0);\n@@ -3035,8 +3037,7 @@ can_compare_p (code, mode, purpose)\n    *PUNSIGNEDP nonzero says that the operands are unsigned;\n    this matters if they need to be widened.\n \n-   If they have mode BLKmode, then SIZE specifies the size of both operands,\n-   and ALIGN specifies the known shared alignment of the operands.\n+   If they have mode BLKmode, then SIZE specifies the size of both operands.\n \n    This function performs all the setup necessary so that the caller only has\n    to emit a single comparison insn.  This setup can involve doing a BLKmode\n@@ -3045,22 +3046,19 @@ can_compare_p (code, mode, purpose)\n    The values which are passed in through pointers can be modified; the caller\n    should perform the comparison on the modified values.  */\n \n-void\n-prepare_cmp_insn (px, py, pcomparison, size, pmode, punsignedp, align,\n-\t\t  purpose)\n+static void\n+prepare_cmp_insn (px, py, pcomparison, size, pmode, punsignedp, purpose)\n      rtx *px, *py;\n      enum rtx_code *pcomparison;\n      rtx size;\n      enum machine_mode *pmode;\n      int *punsignedp;\n-     int align ATTRIBUTE_UNUSED;\n      enum can_compare_purpose purpose;\n {\n   enum machine_mode mode = *pmode;\n   rtx x = *px, y = *py;\n   int unsignedp = *punsignedp;\n   enum mode_class class;\n-  rtx opalign ATTRIBUTE_UNUSED = GEN_INT (align / BITS_PER_UNIT);;\n \n   class = GET_MODE_CLASS (mode);\n \n@@ -3103,6 +3101,8 @@ prepare_cmp_insn (px, py, pcomparison, size, pmode, punsignedp, align,\n     {\n       rtx result;\n       enum machine_mode result_mode;\n+      unsigned int opalign ATTRIBUTE_UNUSED\n+\t= (MIN (MEM_ALIGN (x), MEM_ALIGN (y)) / BITS_PER_UNIT);\n \n       emit_queue ();\n       x = protect_from_queue (x, 0);\n@@ -3193,8 +3193,7 @@ prepare_cmp_insn (px, py, pcomparison, size, pmode, punsignedp, align,\n       if (unsignedp && ucmp_optab->handlers[(int) mode].libfunc)\n \tlibfunc = ucmp_optab->handlers[(int) mode].libfunc;\n \n-      emit_library_call (libfunc, 1,\n-\t\t\t word_mode, 2, x, mode, y, mode);\n+      emit_library_call (libfunc, 1, word_mode, 2, x, mode, y, mode);\n \n       /* Immediately move the result of the libcall into a pseudo\n \t register so reload doesn't clobber the value if it needs\n@@ -3322,8 +3321,7 @@ emit_cmp_and_jump_insn_1 (x, y, mode, comparison, unsignedp, label)\n    need to be widened by emit_cmp_insn.  UNSIGNEDP is also used to select\n    the proper branch condition code.\n \n-   If X and Y have mode BLKmode, then SIZE specifies the size of both X and Y,\n-   and ALIGN specifies the known shared alignment of X and Y. \n+   If X and Y have mode BLKmode, then SIZE specifies the size of both X and Y.\n \n    MODE is the mode of the inputs (in case they are const_int).\n \n@@ -3332,13 +3330,12 @@ emit_cmp_and_jump_insn_1 (x, y, mode, comparison, unsignedp, label)\n    unsigned variant based on UNSIGNEDP to select a proper jump instruction.  */\n \n void\n-emit_cmp_and_jump_insns (x, y, comparison, size, mode, unsignedp, align, label)\n+emit_cmp_and_jump_insns (x, y, comparison, size, mode, unsignedp, label)\n      rtx x, y;\n      enum rtx_code comparison;\n      rtx size;\n      enum machine_mode mode;\n      int unsignedp;\n-     unsigned int align;\n      rtx label;\n {\n   rtx op0 = x, op1 = y;\n@@ -3366,23 +3363,23 @@ emit_cmp_and_jump_insns (x, y, comparison, size, mode, unsignedp, align, label)\n   emit_queue ();\n   if (unsignedp)\n     comparison = unsigned_condition (comparison);\n-  prepare_cmp_insn (&op0, &op1, &comparison, size, &mode, &unsignedp, align,\n+\n+  prepare_cmp_insn (&op0, &op1, &comparison, size, &mode, &unsignedp,\n \t\t    ccp_jump);\n   emit_cmp_and_jump_insn_1 (op0, op1, mode, comparison, unsignedp, label);\n }\n \n /* Like emit_cmp_and_jump_insns, but generate only the comparison.  */\n \n void\n-emit_cmp_insn (x, y, comparison, size, mode, unsignedp, align)\n+emit_cmp_insn (x, y, comparison, size, mode, unsignedp)\n      rtx x, y;\n      enum rtx_code comparison;\n      rtx size;\n      enum machine_mode mode;\n      int unsignedp;\n-     unsigned int align;\n {\n-  emit_cmp_and_jump_insns (x, y, comparison, size, mode, unsignedp, align, 0);\n+  emit_cmp_and_jump_insns (x, y, comparison, size, mode, unsignedp, 0);\n }\n \f\n /* Emit a library call comparison between floating point X and Y.\n@@ -3738,7 +3735,7 @@ emit_conditional_move (target, code, op0, op1, cmode, op2, op3, mode,\n      and then the conditional move.  */\n \n   comparison \n-    = compare_from_rtx (op0, op1, code, unsignedp, cmode, NULL_RTX, 0);\n+    = compare_from_rtx (op0, op1, code, unsignedp, cmode, NULL_RTX);\n \n   /* ??? Watch for const0_rtx (nop) and const_true_rtx (unconditional)?  */\n   /* We can get const0_rtx or const_true_rtx in some circumstances.  Just\n@@ -4169,7 +4166,7 @@ expand_float (to, from, unsignedp)\n \n \t      /* Test whether the sign bit is set.  */\n \t      emit_cmp_and_jump_insns (from, const0_rtx, LT, NULL_RTX, imode,\n-\t\t\t\t       0, 0, neglabel);\n+\t\t\t\t       0, neglabel);\n \n \t      /* The sign bit is not set.  Convert as signed.  */\n \t      expand_float (target, from, 0);\n@@ -4217,7 +4214,7 @@ expand_float (to, from, unsignedp)\n \n       do_pending_stack_adjust ();\n       emit_cmp_and_jump_insns (from, const0_rtx, GE, NULL_RTX, GET_MODE (from),\n-\t\t\t        0, 0, label);\n+\t\t\t       0, label);\n \n       /* On SCO 3.2.1, ldexp rejects values outside [0.5, 1).\n \t Rather than setting up a dconst_dot_5, let's hope SCO\n@@ -4425,7 +4422,7 @@ expand_fix (to, from, unsignedp)\n \t  /* See if we need to do the subtraction.  */\n \t  do_pending_stack_adjust ();\n \t  emit_cmp_and_jump_insns (from, limit, GE, NULL_RTX, GET_MODE (from),\n-\t\t\t\t   0, 0, lab1);\n+\t\t\t\t   0, lab1);\n \n \t  /* If not, do the signed \"fix\" and branch around fixup code.  */\n \t  expand_fix (to, from, 0);"}, {"sha": "0c488b8bc5a37c6fa91ef5b033aede69ed08d392", "filename": "gcc/optabs.h", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a06ef755a376209a3c757786b3931671b72fc771/gcc%2Foptabs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a06ef755a376209a3c757786b3931671b72fc771/gcc%2Foptabs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.h?ref=a06ef755a376209a3c757786b3931671b72fc771", "patch": "@@ -291,7 +291,7 @@ extern void emit_0_to_1_insn PARAMS ((rtx));\n \n /* Emit one rtl insn to compare two rtx's.  */\n extern void emit_cmp_insn PARAMS ((rtx, rtx, enum rtx_code, rtx,\n-\t\t\t\t   enum machine_mode, int, unsigned int));\n+\t\t\t\t   enum machine_mode, int));\n \n /* The various uses that a comparison can have; used by can_compare_p:\n    jumps, conditional moves, store flag operations.  */\n@@ -307,10 +307,6 @@ enum can_compare_purpose\n extern int can_compare_p PARAMS ((enum rtx_code, enum machine_mode,\n \t\t\t\t  enum can_compare_purpose));\n \n-extern void prepare_cmp_insn PARAMS ((rtx *, rtx *, enum rtx_code *, rtx,\n-\t\t\t\t      enum machine_mode *, int *, int,\n-\t\t\t\t      enum can_compare_purpose));\n-\n extern rtx prepare_operand PARAMS ((int, rtx, int, enum machine_mode,\n \t\t\t\t    enum machine_mode, int));\n "}, {"sha": "7cc1843ca9318addf051fe24cdf6d3e3e10efed7", "filename": "gcc/rtl.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a06ef755a376209a3c757786b3931671b72fc771/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a06ef755a376209a3c757786b3931671b72fc771/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=a06ef755a376209a3c757786b3931671b72fc771", "patch": "@@ -1289,6 +1289,8 @@ extern rtx assign_stack_local\t\tPARAMS ((enum machine_mode,\n \t\t\t\t\t       HOST_WIDE_INT, int));\n extern rtx assign_stack_temp\t\tPARAMS ((enum machine_mode,\n \t\t\t\t\t       HOST_WIDE_INT, int));\n+extern rtx assign_stack_temp_for_type\tPARAMS ((enum machine_mode,\n+\t\t\t\t\t\t HOST_WIDE_INT, int, tree));\n extern rtx assign_temp\t\t\tPARAMS ((tree, int, int, int));\n /* In emit-rtl.c */\n extern rtx emit_insn_before\t\tPARAMS ((rtx, rtx));\n@@ -1682,6 +1684,15 @@ extern rtx gen_lowpart_SUBREG PARAMS ((enum machine_mode, rtx));\n \n #define LAST_VIRTUAL_REGISTER\t\t((FIRST_VIRTUAL_REGISTER) + 4)\n \n+/* Nonzero if REGNUM is a pointer into the stack frame.  */\n+#define REGNO_PTR_FRAME_P(REGNUM) \t\t\\\n+  ((REGNUM) == STACK_POINTER_REGNUM\t\t\\\n+   || (REGNUM) == FRAME_POINTER_REGNUM\t\t\\\n+   || (REGNUM) == HARD_FRAME_POINTER_REGNUM\t\\\n+   || (REGNUM) == ARG_POINTER_REGNUM\t\t\\\n+   || ((REGNUM) >= FIRST_VIRTUAL_REGISTER\t\\\n+       && (REGNUM) <= LAST_VIRTUAL_REGISTER))\n+\n /* REGNUM never really appearing in the INSN stream.  */\n #define INVALID_REGNUM\t\t\t(~(unsigned int)0)\n "}, {"sha": "4fa60e7f5194a821baa0a36e52ec07b61e3b01e9", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a06ef755a376209a3c757786b3931671b72fc771/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a06ef755a376209a3c757786b3931671b72fc771/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=a06ef755a376209a3c757786b3931671b72fc771", "patch": "@@ -2577,7 +2577,7 @@ extern tree maybe_build_cleanup\t\tPARAMS ((tree));\n extern tree get_inner_reference\t\tPARAMS ((tree, HOST_WIDE_INT *,\n \t\t\t\t\t\t HOST_WIDE_INT *, tree *,\n \t\t\t\t\t\t enum machine_mode *, int *,\n-\t\t\t\t\t\t int *, unsigned int *));\n+\t\t\t\t\t\t int *));\n \n /* Given a DECL or TYPE, return the scope in which it was declared, or\n    NUL_TREE if there is no containing scope.  */"}]}