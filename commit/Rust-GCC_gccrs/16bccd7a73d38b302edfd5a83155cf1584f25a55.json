{"sha": "16bccd7a73d38b302edfd5a83155cf1584f25a55", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTZiY2NkN2E3M2QzOGIzMDJlZGZkNWE4MzE1NWNmMTU4NGYyNWE1NQ==", "commit": {"author": {"name": "Sebastian Pop", "email": "s.pop@samsung.com", "date": "2016-01-28T16:39:10Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2016-01-28T16:39:10Z"}, "message": "remove out of sync comments\n\n\t* graphite-isl-ast-to-gimple.c (class translate_isl_ast_to_gimple):\n\tRemove comments from class declarations: they are already in the code\n\tclose by the defs.\n\nFrom-SVN: r232934", "tree": {"sha": "029a36c0f78af4cbd9bba11a1f90326adf7a17e8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/029a36c0f78af4cbd9bba11a1f90326adf7a17e8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/16bccd7a73d38b302edfd5a83155cf1584f25a55", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16bccd7a73d38b302edfd5a83155cf1584f25a55", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16bccd7a73d38b302edfd5a83155cf1584f25a55", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16bccd7a73d38b302edfd5a83155cf1584f25a55/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0baa616ac8f979a59bf10ed9ae3650c7b96b885b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0baa616ac8f979a59bf10ed9ae3650c7b96b885b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0baa616ac8f979a59bf10ed9ae3650c7b96b885b"}], "stats": {"total": 443, "additions": 89, "deletions": 354}, "files": [{"sha": "9d5f81bde76ec6a45c6743f35efa368d87fbb49d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bccd7a73d38b302edfd5a83155cf1584f25a55/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bccd7a73d38b302edfd5a83155cf1584f25a55/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=16bccd7a73d38b302edfd5a83155cf1584f25a55", "patch": "@@ -1,3 +1,9 @@\n+2016-01-28  Sebastian Pop  <s.pop@samsung.com>\n+\n+\t* graphite-isl-ast-to-gimple.c (class translate_isl_ast_to_gimple):\n+\tRemove comments from class declarations: they are already in the code\n+\tclose by the defs.\n+\n 2016-01-28  Sebastian Pop  <s.pop@samsung.com>\n \n \t* graphite-isl-ast-to-gimple.c (binary_op_to_tree): Call codegen_error_p."}, {"sha": "161b43476995feff9b2243b06678999173794975", "filename": "gcc/graphite-isl-ast-to-gimple.c", "status": "modified", "additions": 83, "deletions": 354, "changes": 437, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16bccd7a73d38b302edfd5a83155cf1584f25a55/gcc%2Fgraphite-isl-ast-to-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16bccd7a73d38b302edfd5a83155cf1584f25a55/gcc%2Fgraphite-isl-ast-to-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-isl-ast-to-gimple.c?ref=16bccd7a73d38b302edfd5a83155cf1584f25a55", "patch": "@@ -171,342 +171,117 @@ class translate_isl_ast_to_gimple\n {\n  public:\n   translate_isl_ast_to_gimple (sese_info_p r)\n-    : region (r), codegen_error (false)\n-    { }\n-\n-  /* Translates an isl AST node NODE to GCC representation in the\n-     context of a SESE.  */\n+    : region (r), codegen_error (false) { }\n   edge translate_isl_ast (loop_p context_loop, __isl_keep isl_ast_node *node,\n \t\t\t  edge next_e, ivs_params &ip);\n-\n-  /* Translates an isl_ast_node_for to Gimple.  */\n   edge translate_isl_ast_node_for (loop_p context_loop,\n \t\t\t\t   __isl_keep isl_ast_node *node,\n \t\t\t\t   edge next_e, ivs_params &ip);\n-\n-  /* Create the loop for a isl_ast_node_for.\n-\n-     - NEXT_E is the edge where new generated code should be attached.  */\n   edge translate_isl_ast_for_loop (loop_p context_loop,\n \t\t\t\t   __isl_keep isl_ast_node *node_for,\n \t\t\t\t   edge next_e,\n \t\t\t\t   tree type, tree lb, tree ub,\n \t\t\t\t   ivs_params &ip);\n-\n-  /* Translates an isl_ast_node_if to Gimple.  */\n   edge translate_isl_ast_node_if (loop_p context_loop,\n \t\t\t\t  __isl_keep isl_ast_node *node,\n \t\t\t\t  edge next_e, ivs_params &ip);\n-\n-  /* Translates an isl_ast_node_user to Gimple.\n-\n-     FIXME: We should remove iv_map.create (loop->num + 1), if it is\n-     possible.  */\n   edge translate_isl_ast_node_user (__isl_keep isl_ast_node *node,\n \t\t\t\t    edge next_e, ivs_params &ip);\n-\n-  /* Translates an isl_ast_node_block to Gimple.  */\n   edge translate_isl_ast_node_block (loop_p context_loop,\n \t\t\t\t     __isl_keep isl_ast_node *node,\n \t\t\t\t     edge next_e, ivs_params &ip);\n-\n-  /* Converts a unary isl_ast_expr_op expression E to a GCC expression tree of\n-     type TYPE.  */\n   tree unary_op_to_tree (tree type, __isl_take isl_ast_expr *expr,\n \t\t\t ivs_params &ip);\n-\n-  /* Converts a binary isl_ast_expr_op expression E to a GCC expression tree of\n-     type TYPE.  */\n   tree binary_op_to_tree (tree type, __isl_take isl_ast_expr *expr,\n \t\t\t  ivs_params &ip);\n-\n-  /* Converts a ternary isl_ast_expr_op expression E to a GCC expression tree of\n-     type TYPE.  */\n   tree ternary_op_to_tree (tree type, __isl_take isl_ast_expr *expr,\n \t\t\t   ivs_params &ip);\n-\n-  /* Converts an isl_ast_expr_op expression E with unknown number of arguments\n-     to a GCC expression tree of type TYPE.  */\n   tree nary_op_to_tree (tree type, __isl_take isl_ast_expr *expr,\n \t\t\tivs_params &ip);\n-\n-  /* Converts an isl AST expression E back to a GCC expression tree of\n-     type TYPE.  */\n   tree gcc_expression_from_isl_expression (tree type,\n \t\t\t\t\t   __isl_take isl_ast_expr *,\n \t\t\t\t\t   ivs_params &ip);\n-\n-  /* Return the tree variable that corresponds to the given isl ast identifier\n-     expression (an isl_ast_expr of type isl_ast_expr_id).\n-\n-     FIXME: We should replace blind conversation of id's type with derivation\n-     of the optimal type when we get the corresponding isl support.  Blindly\n-     converting type sizes may be problematic when we switch to smaller\n-     types.  */\n   tree gcc_expression_from_isl_ast_expr_id (tree type,\n \t\t\t\t\t    __isl_keep isl_ast_expr *expr_id,\n \t\t\t\t\t    ivs_params &ip);\n-\n-  /* Converts an isl_ast_expr_int expression E to a GCC expression tree of\n-     type TYPE.  */\n   tree gcc_expression_from_isl_expr_int (tree type,\n \t\t\t\t\t __isl_take isl_ast_expr *expr);\n-\n-  /* Converts an isl_ast_expr_op expression E to a GCC expression tree of\n-     type TYPE.  */\n   tree gcc_expression_from_isl_expr_op (tree type,\n \t\t\t\t\t__isl_take isl_ast_expr *expr,\n \t\t\t\t\tivs_params &ip);\n-\n-  /* Creates a new LOOP corresponding to isl_ast_node_for.  Inserts an\n-     induction variable for the new LOOP.  New LOOP is attached to CFG\n-     starting at ENTRY_EDGE.  LOOP is inserted into the loop tree and\n-     becomes the child loop of the OUTER_LOOP.  NEWIVS_INDEX binds\n-     isl's scattering name to the induction variable created for the\n-     loop of STMT.  The new induction variable is inserted in the NEWIVS\n-     vector and is of type TYPE.  */\n   struct loop *graphite_create_new_loop (edge entry_edge,\n \t\t\t\t\t __isl_keep isl_ast_node *node_for,\n \t\t\t\t\t loop_p outer, tree type,\n \t\t\t\t\t tree lb, tree ub, ivs_params &ip);\n-\n-  /* All loops generated by create_empty_loop_on_edge have the form of\n-     a post-test loop:\n-\n-     do\n-\n-     {\n-     body of the loop;\n-     } while (lower bound < upper bound);\n-\n-     We create a new if region protecting the loop to be executed, if\n-     the execution count is zero (lower bound > upper bound).  */\n   edge graphite_create_new_loop_guard (edge entry_edge,\n \t\t\t\t       __isl_keep isl_ast_node *node_for,\n \t\t\t\t       tree *type,\n \t\t\t\t       tree *lb, tree *ub, ivs_params &ip);\n-\n-  /* Creates a new if region corresponding to isl's cond.  */\n   edge graphite_create_new_guard (edge entry_edge,\n \t\t\t\t  __isl_take isl_ast_expr *if_cond,\n \t\t\t\t  ivs_params &ip);\n-\n-  /* Inserts in iv_map a tuple (OLD_LOOP->num, NEW_NAME) for the induction\n-     variables of the loops around GBB in SESE.\n-\n-     FIXME: Instead of using a vec<tree> that maps each loop id to a possible\n-     chrec, we could consider using a map<int, tree> that maps loop ids to the\n-     corresponding tree expressions.  */\n   void build_iv_mapping (vec<tree> iv_map, gimple_poly_bb_p gbb,\n \t\t\t __isl_keep isl_ast_expr *user_expr, ivs_params &ip,\n \t\t\t sese_l &region);\n-\n-  /* Patch the missing arguments of the phi nodes.  */\n-\n   void translate_pending_phi_nodes (void);\n-\n-  /* Add isl's parameter identifiers and corresponding trees to ivs_params.  */\n-\n   void add_parameters_to_ivs_params (scop_p scop, ivs_params &ip);\n-\n-  /* Generates a build, which specifies the constraints on the parameters.  */\n-\n   __isl_give isl_ast_build *generate_isl_context (scop_p scop);\n \n #ifdef HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS\n-  /* Generate isl AST from schedule of SCOP.  */\n   __isl_give isl_ast_node * scop_to_isl_ast (scop_p scop);\n #else\n-  /* Get the maximal number of schedule dimensions in the scop SCOP.  */\n   int get_max_schedule_dimensions (scop_p scop);\n-\n-  /* Extend the schedule to NB_SCHEDULE_DIMS schedule dimensions.\n-\n-     For schedules with different dimensionality, the isl AST generator can not\n-     define an order and will just randomly choose an order.  The solution to\n-     this problem is to extend all schedules to the maximal number of schedule\n-     dimensions (using '0's for the remaining values).  */\n   __isl_give isl_map *extend_schedule (__isl_take isl_map *schedule,\n \t\t\t\t       int nb_schedule_dims);\n-\n-  /* Generates a schedule, which specifies an order used to\n-     visit elements in a domain.  */\n   __isl_give isl_union_map *generate_isl_schedule (scop_p scop);\n-\n-  /* Set the separate option for all dimensions.\n-     This helps to reduce control overhead.  */\n   __isl_give isl_ast_build *set_options (__isl_take isl_ast_build *control,\n \t\t\t\t\t __isl_keep isl_union_map *schedule);\n-\n-  /* Generate isl AST from schedule of SCOP.  Also, collects IVS_PARAMS in\n-     IP.  */\n   __isl_give isl_ast_node *scop_to_isl_ast (scop_p scop, ivs_params &ip);\n-\n-  /* Prints NODE to FILE.  */\n-  void print_isl_ast_node (FILE *file, __isl_keep isl_ast_node *node,\n-\t\t\t   __isl_keep isl_ctx *ctx) const\n-  {\n-    isl_printer *prn = isl_printer_to_file (ctx, file);\n-    prn = isl_printer_set_output_format (prn, ISL_FORMAT_C);\n-    prn = isl_printer_print_ast_node (prn, node);\n-    prn = isl_printer_print_str (prn, \"\\n\");\n-    isl_printer_free (prn);\n-  }\n #endif\n \n-  /* Return true if RENAME (defined in BB) is a valid use in NEW_BB.  The\n-     definition should flow into use, and the use should respect the loop-closed\n-     SSA form.  */\n-\n   bool is_valid_rename (tree rename, basic_block def_bb, basic_block use_bb,\n \t\t\tphi_node_kind, tree old_name, basic_block old_bb) const;\n-\n-  /* Returns the expression associated to OLD_NAME (which is used in OLD_BB), in\n-     NEW_BB from RENAME_MAP.  LOOP_PHI is true when we want to rename OLD_NAME\n-     within a loop PHI instruction.  */\n-\n   tree get_rename (basic_block new_bb, tree old_name,\n \t\t   basic_block old_bb, phi_node_kind) const;\n-\n-  /* For ops which are scev_analyzeable, we can regenerate a new name from\n-  its scalar evolution around LOOP.  */\n-\n   tree get_rename_from_scev (tree old_name, gimple_seq *stmts, loop_p loop,\n \t\t\t     basic_block new_bb, basic_block old_bb,\n \t\t\t     vec<tree> iv_map);\n-\n-  /* Returns a basic block that could correspond to where a constant was defined\n-     in the original code.  In the original code OLD_BB had the definition, we\n-     need to find which basic block out of the copies of old_bb, in the new\n-     region, should a definition correspond to if it has to reach BB.  */\n-\n   basic_block get_def_bb_for_const (basic_block bb, basic_block old_bb) const;\n-\n-  /* Get the new name of OP (from OLD_BB) to be used in NEW_BB.  LOOP_PHI is\n-     true when we want to rename an OP within a loop PHI instruction.  */\n-\n   tree get_new_name (basic_block new_bb, tree op,\n \t\t     basic_block old_bb, phi_node_kind) const;\n-\n-  /* Collect all the operands of NEW_EXPR by recursively visiting each\n-     operand.  */\n-\n   void collect_all_ssa_names (tree new_expr, vec<tree> *vec_ssa);\n-\n-  /* Copy the PHI arguments from OLD_PHI to the NEW_PHI.  The arguments to\n-     NEW_PHI must be found unless they can be POSTPONEd for later.  */\n-\n   bool copy_loop_phi_args (gphi *old_phi, init_back_edge_pair_t &ibp_old_bb,\n \t\t\t   gphi *new_phi, init_back_edge_pair_t &ibp_new_bb,\n \t\t\t   bool postpone);\n-\n-  /* Copy loop phi nodes from BB to NEW_BB.  */\n-\n   bool copy_loop_phi_nodes (basic_block bb, basic_block new_bb);\n-\n-  /* Add phi nodes to all merge points of all the diamonds enclosing the loop of\n-     the close phi node PHI.  */\n-\n   bool add_close_phis_to_merge_points (gphi *old_phi, gphi *new_phi,\n \t\t\t\t       tree default_value);\n-\n   tree add_close_phis_to_outer_loops (tree last_merge_name, edge merge_e,\n \t\t\t\t      gimple *old_close_phi);\n-\n-  /* Copy all the loop-close phi args from BB to NEW_BB.  */\n-\n   bool copy_loop_close_phi_args (basic_block old_bb, basic_block new_bb,\n \t\t\t\t bool postpone);\n-\n-  /* Copy loop close phi nodes from BB to NEW_BB.  */\n-\n   bool copy_loop_close_phi_nodes (basic_block old_bb, basic_block new_bb);\n-\n-  /* Copy the arguments of cond-phi node PHI, to NEW_PHI in the codegenerated\n-     region.  If postpone is true and it isn't possible to copy any arg of PHI,\n-     the PHI is added to the REGION->INCOMPLETE_PHIS to be codegenerated later.\n-     Returns false if the copying was unsuccessful.  */\n-\n   bool copy_cond_phi_args (gphi *phi, gphi *new_phi, vec<tree> iv_map,\n \t\t\t   bool postpone);\n-\n-  /* Copy cond phi nodes from BB to NEW_BB.  A cond-phi node is a basic block\n-  containing phi nodes coming from two predecessors, and none of them are back\n-  edges.  */\n-\n   bool copy_cond_phi_nodes (basic_block bb, basic_block new_bb,\n \t\t\t    vec<tree> iv_map);\n-\n-  /* Duplicates the statements of basic block BB into basic block NEW_BB\n-     and compute the new induction variables according to the IV_MAP.  */\n-\n   bool graphite_copy_stmts_from_block (basic_block bb, basic_block new_bb,\n \t\t\t\t       vec<tree> iv_map);\n-\n-  /* Copies BB and includes in the copied BB all the statements that can\n-     be reached following the use-def chains from the memory accesses,\n-     and returns the next edge following this new block.  */\n-\n   edge copy_bb_and_scalar_dependences (basic_block bb, edge next_e,\n \t\t\t\t       vec<tree> iv_map);\n-\n-  /* Given a basic block containing close-phi it returns the new basic block\n-     where to insert a copy of the close-phi nodes.  All the uses in close phis\n-     should come from a single loop otherwise it returns NULL.  */\n   edge edge_for_new_close_phis (basic_block bb);\n-\n-  /* Add NEW_NAME as the ARGNUM-th arg of NEW_PHI which is in NEW_BB.\n-     DOMINATING_PRED is the predecessor basic block of OLD_BB which dominates\n-     the other pred of OLD_BB as well.  If no such basic block exists then it is\n-     NULL.  NON_DOMINATING_PRED is a pred which does not dominate OLD_BB, it\n-     cannot be NULL.\n-\n-     Case1: OLD_BB->preds {BB1, BB2} and BB1 does not dominate BB2 and vice\n-     versa.  In this case DOMINATING_PRED = NULL.\n-\n-     Case2: OLD_BB->preds {BB1, BB2} and BB1 dominates BB2.\n-\n-     Returns true on successful copy of the args, false otherwise.  */\n-\n   bool add_phi_arg_for_new_expr (tree old_phi_args[2], tree new_phi_args[2],\n \t\t\t\t edge old_bb_dominating_edge,\n \t\t\t\t edge old_bb_non_dominating_edge,\n \t\t\t\t gphi *phi, gphi *new_phi,\n \t\t\t\t basic_block new_bb);\n-\n-  /* Renames the scalar uses of the statement COPY, using the substitution map\n-     RENAME_MAP, inserting the gimplification code at GSI_TGT, for the\n-     translation REGION, with the original copied statement in LOOP, and using\n-     the induction variable renaming map IV_MAP.  Returns true when something\n-     has been renamed.  */\n-\n   bool rename_uses (gimple *copy, gimple_stmt_iterator *gsi_tgt,\n \t\t    basic_block old_bb, loop_p loop, vec<tree> iv_map);\n-\n-  /* Register in RENAME_MAP the rename tuple (OLD_NAME, EXPR).\n-     When OLD_NAME and EXPR are the same we assert.  */\n-\n   void set_rename (tree old_name, tree expr);\n-\n-  /* Create new names for all the definitions created by COPY and add\n-     replacement mappings for each new name.  */\n-\n   void set_rename_for_each_def (gimple *stmt);\n-\n-  /* Insert each statement from SEQ at its earliest insertion p.  */\n-\n   void gsi_insert_earliest (gimple_seq seq);\n-\n-  /* Rename all the operands of NEW_EXPR by recursively visiting each\n-     operand.  */\n-\n   tree rename_all_uses (tree new_expr, basic_block new_bb, basic_block old_bb);\n-\n-  bool codegen_error_p () const\n-  { return codegen_error; }\n-\n-  /* Return true when OP is a constant tree.  */\n-\n+  bool codegen_error_p () const { return codegen_error; }\n   bool is_constant (tree op) const\n   {\n     return TREE_CODE (op) == INTEGER_CST\n@@ -535,8 +310,7 @@ class translate_isl_ast_to_gimple\n    converting type sizes may be problematic when we switch to smaller\n    types.  */\n \n-tree\n-translate_isl_ast_to_gimple::\n+tree translate_isl_ast_to_gimple::\n gcc_expression_from_isl_ast_expr_id (tree type,\n \t\t\t\t     __isl_take isl_ast_expr *expr_id,\n \t\t\t\t     ivs_params &ip)\n@@ -560,8 +334,7 @@ gcc_expression_from_isl_ast_expr_id (tree type,\n /* Converts an isl_ast_expr_int expression E to a GCC expression tree of\n    type TYPE.  */\n \n-tree\n-translate_isl_ast_to_gimple::\n+tree translate_isl_ast_to_gimple::\n gcc_expression_from_isl_expr_int (tree type, __isl_take isl_ast_expr *expr)\n {\n   gcc_assert (isl_ast_expr_get_type (expr) == isl_ast_expr_int);\n@@ -582,8 +355,7 @@ gcc_expression_from_isl_expr_int (tree type, __isl_take isl_ast_expr *expr)\n /* Converts a binary isl_ast_expr_op expression E to a GCC expression tree of\n    type TYPE.  */\n \n-tree\n-translate_isl_ast_to_gimple::\n+tree translate_isl_ast_to_gimple::\n binary_op_to_tree (tree type, __isl_take isl_ast_expr *expr, ivs_params &ip)\n {\n   isl_ast_expr *arg_expr = isl_ast_expr_get_op_arg (expr, 0);\n@@ -682,8 +454,7 @@ binary_op_to_tree (tree type, __isl_take isl_ast_expr *expr, ivs_params &ip)\n /* Converts a ternary isl_ast_expr_op expression E to a GCC expression tree of\n    type TYPE.  */\n \n-tree\n-translate_isl_ast_to_gimple::\n+tree translate_isl_ast_to_gimple::\n ternary_op_to_tree (tree type, __isl_take isl_ast_expr *expr, ivs_params &ip)\n {\n   enum isl_ast_op_type t = isl_ast_expr_get_op_type (expr);\n@@ -705,8 +476,7 @@ ternary_op_to_tree (tree type, __isl_take isl_ast_expr *expr, ivs_params &ip)\n /* Converts a unary isl_ast_expr_op expression E to a GCC expression tree of\n    type TYPE.  */\n \n-tree\n-translate_isl_ast_to_gimple::\n+tree translate_isl_ast_to_gimple::\n unary_op_to_tree (tree type, __isl_take isl_ast_expr *expr, ivs_params &ip)\n {\n   gcc_assert (isl_ast_expr_get_op_type (expr) == isl_ast_op_minus);\n@@ -720,8 +490,7 @@ unary_op_to_tree (tree type, __isl_take isl_ast_expr *expr, ivs_params &ip)\n /* Converts an isl_ast_expr_op expression E with unknown number of arguments\n    to a GCC expression tree of type TYPE.  */\n \n-tree\n-translate_isl_ast_to_gimple::\n+tree translate_isl_ast_to_gimple::\n nary_op_to_tree (tree type, __isl_take isl_ast_expr *expr, ivs_params &ip)\n {\n   enum tree_code op_code;\n@@ -768,8 +537,7 @@ nary_op_to_tree (tree type, __isl_take isl_ast_expr *expr, ivs_params &ip)\n /* Converts an isl_ast_expr_op expression E to a GCC expression tree of\n    type TYPE.  */\n \n-tree\n-translate_isl_ast_to_gimple::\n+tree translate_isl_ast_to_gimple::\n gcc_expression_from_isl_expr_op (tree type, __isl_take isl_ast_expr *expr,\n \t\t\t\t ivs_params &ip)\n {\n@@ -830,8 +598,7 @@ gcc_expression_from_isl_expr_op (tree type, __isl_take isl_ast_expr *expr,\n /* Converts an isl AST expression E back to a GCC expression tree of\n    type TYPE.  */\n \n-tree\n-translate_isl_ast_to_gimple::\n+tree translate_isl_ast_to_gimple::\n gcc_expression_from_isl_expression (tree type, __isl_take isl_ast_expr *expr,\n \t\t\t\t    ivs_params &ip)\n {\n@@ -867,8 +634,7 @@ gcc_expression_from_isl_expression (tree type, __isl_take isl_ast_expr *expr,\n    loop of STMT.  The new induction variable is inserted in the NEWIVS\n    vector and is of type TYPE.  */\n \n-struct loop *\n-translate_isl_ast_to_gimple::\n+struct loop *translate_isl_ast_to_gimple::\n graphite_create_new_loop (edge entry_edge, __isl_keep isl_ast_node *node_for,\n \t\t\t  loop_p outer, tree type, tree lb, tree ub,\n \t\t\t  ivs_params &ip)\n@@ -901,8 +667,7 @@ graphite_create_new_loop (edge entry_edge, __isl_keep isl_ast_node *node_for,\n \n    - NEXT_E is the edge where new generated code should be attached.  */\n \n-edge\n-translate_isl_ast_to_gimple::\n+edge translate_isl_ast_to_gimple::\n translate_isl_ast_for_loop (loop_p context_loop,\n \t\t\t    __isl_keep isl_ast_node *node_for, edge next_e,\n \t\t\t    tree type, tree lb, tree ub,\n@@ -1009,8 +774,7 @@ get_upper_bound (__isl_keep isl_ast_node *node_for)\n    We create a new if region protecting the loop to be executed, if\n    the execution count is zero (lower bound > upper bound).  */\n \n-edge\n-translate_isl_ast_to_gimple::\n+edge translate_isl_ast_to_gimple::\n graphite_create_new_loop_guard (edge entry_edge,\n \t\t\t\t__isl_keep isl_ast_node *node_for, tree *type,\n \t\t\t\ttree *lb, tree *ub, ivs_params &ip)\n@@ -1064,8 +828,7 @@ graphite_create_new_loop_guard (edge entry_edge,\n \n /* Translates an isl_ast_node_for to Gimple. */\n \n-edge\n-translate_isl_ast_to_gimple::\n+edge translate_isl_ast_to_gimple::\n translate_isl_ast_node_for (loop_p context_loop, __isl_keep isl_ast_node *node,\n \t\t\t    edge next_e, ivs_params &ip)\n {\n@@ -1100,8 +863,7 @@ translate_isl_ast_node_for (loop_p context_loop, __isl_keep isl_ast_node *node,\n    chrec, we could consider using a map<int, tree> that maps loop ids to the\n    corresponding tree expressions.  */\n \n-void\n-translate_isl_ast_to_gimple::\n+void translate_isl_ast_to_gimple::\n build_iv_mapping (vec<tree> iv_map, gimple_poly_bb_p gbb,\n \t\t  __isl_keep isl_ast_expr *user_expr, ivs_params &ip,\n \t\t  sese_l &region)\n@@ -1130,8 +892,7 @@ build_iv_mapping (vec<tree> iv_map, gimple_poly_bb_p gbb,\n \n    FIXME: We should remove iv_map.create (loop->num + 1), if it is possible.  */\n \n-edge\n-translate_isl_ast_to_gimple::\n+edge translate_isl_ast_to_gimple::\n translate_isl_ast_node_user (__isl_keep isl_ast_node *node,\n \t\t\t     edge next_e, ivs_params &ip)\n {\n@@ -1189,8 +950,7 @@ translate_isl_ast_node_user (__isl_keep isl_ast_node *node,\n \n /* Translates an isl_ast_node_block to Gimple. */\n \n-edge\n-translate_isl_ast_to_gimple::\n+edge translate_isl_ast_to_gimple::\n translate_isl_ast_node_block (loop_p context_loop,\n \t\t\t      __isl_keep isl_ast_node *node,\n \t\t\t      edge next_e, ivs_params &ip)\n@@ -1210,8 +970,7 @@ translate_isl_ast_node_block (loop_p context_loop,\n  \n /* Creates a new if region corresponding to isl's cond.  */\n \n-edge\n-translate_isl_ast_to_gimple::\n+edge translate_isl_ast_to_gimple::\n graphite_create_new_guard (edge entry_edge, __isl_take isl_ast_expr *if_cond,\n \t\t\t   ivs_params &ip)\n {\n@@ -1229,8 +988,7 @@ graphite_create_new_guard (edge entry_edge, __isl_take isl_ast_expr *if_cond,\n \n /* Translates an isl_ast_node_if to Gimple.  */\n \n-edge\n-translate_isl_ast_to_gimple::\n+edge translate_isl_ast_to_gimple::\n translate_isl_ast_node_if (loop_p context_loop,\n \t\t\t   __isl_keep isl_ast_node *node,\n \t\t\t   edge next_e, ivs_params &ip)\n@@ -1257,10 +1015,9 @@ translate_isl_ast_node_if (loop_p context_loop,\n /* Translates an isl AST node NODE to GCC representation in the\n    context of a SESE.  */\n \n-edge\n-translate_isl_ast_to_gimple::translate_isl_ast (loop_p context_loop,\n-\t\t\t\t\t\t__isl_keep isl_ast_node *node,\n-\t\t\t\t\t\tedge next_e, ivs_params &ip)\n+edge translate_isl_ast_to_gimple::\n+translate_isl_ast (loop_p context_loop, __isl_keep isl_ast_node *node,\n+\t\t   edge next_e, ivs_params &ip)\n {\n   if (codegen_error_p ())\n     return NULL;\n@@ -1397,8 +1154,7 @@ phi_uses_name (basic_block bb, tree name)\n    definition should flow into use, and the use should respect the loop-closed\n    SSA form.  */\n \n-bool\n-translate_isl_ast_to_gimple::\n+bool translate_isl_ast_to_gimple::\n is_valid_rename (tree rename, basic_block def_bb, basic_block use_bb,\n \t\t phi_node_kind phi_kind, tree old_name, basic_block old_bb) const\n {\n@@ -1439,11 +1195,9 @@ is_valid_rename (tree rename, basic_block def_bb, basic_block use_bb,\n /* Returns the expression associated to OLD_NAME (which is used in OLD_BB), in\n    NEW_BB from RENAME_MAP.  PHI_KIND determines the kind of phi node.  */\n \n-tree\n-translate_isl_ast_to_gimple::get_rename (basic_block new_bb,\n-\t\t\t\t\t tree old_name,\n-\t\t\t\t\t basic_block old_bb,\n-\t\t\t\t\t phi_node_kind phi_kind) const\n+tree translate_isl_ast_to_gimple::\n+get_rename (basic_block new_bb, tree old_name, basic_block old_bb,\n+\t    phi_node_kind phi_kind) const\n {\n   gcc_assert (TREE_CODE (old_name) == SSA_NAME);\n   vec <tree> *renames = region->rename_map->get (old_name);\n@@ -1504,8 +1258,8 @@ translate_isl_ast_to_gimple::get_rename (basic_block new_bb,\n /* Register in RENAME_MAP the rename tuple (OLD_NAME, EXPR).\n    When OLD_NAME and EXPR are the same we assert.  */\n \n-void\n-translate_isl_ast_to_gimple::set_rename (tree old_name, tree expr)\n+void translate_isl_ast_to_gimple::\n+set_rename (tree old_name, tree expr)\n {\n   if (dump_file)\n     {\n@@ -1575,8 +1329,8 @@ later_of_the_two (gimple_stmt_iterator gsi1, gimple_stmt_iterator gsi2)\n \n /* Insert each statement from SEQ at its earliest insertion p.  */\n \n-void\n-translate_isl_ast_to_gimple::gsi_insert_earliest (gimple_seq seq)\n+void translate_isl_ast_to_gimple::\n+gsi_insert_earliest (gimple_seq seq)\n {\n   update_modified_stmts (seq);\n   sese_l &codegen_region = region->if_region->true_region->region;\n@@ -1646,9 +1400,8 @@ translate_isl_ast_to_gimple::gsi_insert_earliest (gimple_seq seq)\n /* Collect all the operands of NEW_EXPR by recursively visiting each\n    operand.  */\n \n-void\n-translate_isl_ast_to_gimple::collect_all_ssa_names (tree new_expr,\n-\t\t\t\t\t\t    vec<tree> *vec_ssa)\n+void translate_isl_ast_to_gimple::\n+collect_all_ssa_names (tree new_expr, vec<tree> *vec_ssa)\n {\n \n   /* Rename all uses in new_expr.  */\n@@ -1809,9 +1562,8 @@ substitute_ssa_name (tree exp, tree f, tree r)\n \n /* Rename all the operands of NEW_EXPR by recursively visiting each operand.  */\n \n-tree\n-translate_isl_ast_to_gimple::rename_all_uses (tree new_expr, basic_block new_bb,\n-\t\t\t\t\t      basic_block old_bb)\n+tree translate_isl_ast_to_gimple::\n+rename_all_uses (tree new_expr, basic_block new_bb, basic_block old_bb)\n {\n   auto_vec<tree, 2> ssa_names;\n   collect_all_ssa_names (new_expr, &ssa_names);\n@@ -1827,8 +1579,7 @@ translate_isl_ast_to_gimple::rename_all_uses (tree new_expr, basic_block new_bb,\n /* For ops which are scev_analyzeable, we can regenerate a new name from its\n    scalar evolution around LOOP.  */\n \n-tree\n-translate_isl_ast_to_gimple::\n+tree translate_isl_ast_to_gimple::\n get_rename_from_scev (tree old_name, gimple_seq *stmts, loop_p loop,\n \t\t      basic_block new_bb, basic_block old_bb,\n \t\t      vec<tree> iv_map)\n@@ -1890,11 +1641,9 @@ get_rename_from_scev (tree old_name, gimple_seq *stmts, loop_p loop,\n    statement in LOOP, and using the induction variable renaming map\n    IV_MAP.  Returns true when something has been renamed.  */\n \n-bool\n-translate_isl_ast_to_gimple::rename_uses (gimple *copy,\n-\t\t\t\t\t  gimple_stmt_iterator *gsi_tgt,\n-\t\t\t\t\t  basic_block old_bb,\n-\t\t\t\t\t  loop_p loop, vec<tree> iv_map)\n+bool translate_isl_ast_to_gimple::\n+rename_uses (gimple *copy, gimple_stmt_iterator *gsi_tgt, basic_block old_bb,\n+\t     loop_p loop, vec<tree> iv_map)\n {\n   bool changed = false;\n \n@@ -2002,9 +1751,8 @@ translate_isl_ast_to_gimple::rename_uses (gimple *copy,\n    need to find which basic block out of the copies of old_bb, in the new\n    region, should a definition correspond to if it has to reach BB.  */\n \n-basic_block\n-translate_isl_ast_to_gimple::get_def_bb_for_const (basic_block bb,\n-\t\t\t\t\t\t   basic_block old_bb) const\n+basic_block translate_isl_ast_to_gimple::\n+get_def_bb_for_const (basic_block bb, basic_block old_bb) const\n {\n   vec <basic_block> *bbs = region->copied_bb_map->get (old_bb);\n \n@@ -2037,8 +1785,7 @@ translate_isl_ast_to_gimple::get_def_bb_for_const (basic_block bb,\n /* Get the new name of OP (from OLD_BB) to be used in NEW_BB.  PHI_KIND\n    determines the kind of phi node.  */\n \n-tree\n-translate_isl_ast_to_gimple::\n+tree translate_isl_ast_to_gimple::\n get_new_name (basic_block new_bb, tree op,\n \t      basic_block old_bb, phi_node_kind phi_kind) const\n {\n@@ -2082,8 +1829,7 @@ get_edges (basic_block bb)\n /* Copy the PHI arguments from OLD_PHI to the NEW_PHI.  The arguments to NEW_PHI\n    must be found unless they can be POSTPONEd for later.  */\n \n-bool\n-translate_isl_ast_to_gimple::\n+bool translate_isl_ast_to_gimple::\n copy_loop_phi_args (gphi *old_phi, init_back_edge_pair_t &ibp_old_bb,\n \t\t    gphi *new_phi, init_back_edge_pair_t &ibp_new_bb,\n \t\t    bool postpone)\n@@ -2130,9 +1876,8 @@ copy_loop_phi_args (gphi *old_phi, init_back_edge_pair_t &ibp_old_bb,\n \n /* Copy loop phi nodes from BB to NEW_BB.  */\n \n-bool\n-translate_isl_ast_to_gimple::copy_loop_phi_nodes (basic_block bb,\n-\t\t\t\t\t\t  basic_block new_bb)\n+bool translate_isl_ast_to_gimple::\n+copy_loop_phi_nodes (basic_block bb, basic_block new_bb)\n {\n   if (dump_file)\n     fprintf (dump_file, \"[codegen] copying loop phi nodes in bb_%d.\\n\",\n@@ -2340,10 +2085,8 @@ add_close_phis_to_merge_points (gphi *old_close_phi, gphi *new_close_phi,\n \n /* Copy all the loop-close phi args from BB to NEW_BB.  */\n \n-bool\n-translate_isl_ast_to_gimple::copy_loop_close_phi_args (basic_block old_bb,\n-\t\t\t\t\t\t       basic_block new_bb,\n-\t\t\t\t\t\t       bool postpone)\n+bool translate_isl_ast_to_gimple::\n+copy_loop_close_phi_args (basic_block old_bb, basic_block new_bb, bool postpone)\n {\n   for (gphi_iterator psi = gsi_start_phis (old_bb); !gsi_end_p (psi);\n        gsi_next (&psi))\n@@ -2415,9 +2158,8 @@ translate_isl_ast_to_gimple::copy_loop_close_phi_args (basic_block old_bb,\n \n /* Copy loop close phi nodes from BB to NEW_BB.  */\n \n-bool\n-translate_isl_ast_to_gimple::copy_loop_close_phi_nodes (basic_block old_bb,\n-\t\t\t\t\t\t\tbasic_block new_bb)\n+bool translate_isl_ast_to_gimple::\n+copy_loop_close_phi_nodes (basic_block old_bb, basic_block new_bb)\n {\n   if (dump_file)\n     fprintf (dump_file, \"[codegen] copying loop close phi nodes in bb_%d.\\n\",\n@@ -2442,8 +2184,7 @@ translate_isl_ast_to_gimple::copy_loop_close_phi_nodes (basic_block old_bb,\n \n    Returns true on successful copy of the args, false otherwise.  */\n \n-bool\n-translate_isl_ast_to_gimple::\n+bool translate_isl_ast_to_gimple::\n add_phi_arg_for_new_expr (tree old_phi_args[2], tree new_phi_args[2],\n \t\t\t  edge old_bb_dominating_edge,\n \t\t\t  edge old_bb_non_dominating_edge,\n@@ -2605,10 +2346,8 @@ add_phi_arg_for_new_expr (tree old_phi_args[2], tree new_phi_args[2],\n    the PHI is added to the REGION->INCOMPLETE_PHIS to be codegenerated later.\n    Returns false if the copying was unsuccessful.  */\n \n-bool\n-translate_isl_ast_to_gimple::copy_cond_phi_args (gphi *phi, gphi *new_phi,\n-\t\t\t\t\t\t vec<tree> iv_map,\n-\t\t\t\t\t\t bool postpone)\n+bool translate_isl_ast_to_gimple::\n+copy_cond_phi_args (gphi *phi, gphi *new_phi, vec<tree> iv_map, bool postpone)\n {\n   if (dump_file)\n     fprintf (dump_file, \"[codegen] copying cond phi args.\\n\");\n@@ -2722,10 +2461,8 @@ translate_isl_ast_to_gimple::copy_cond_phi_args (gphi *phi, gphi *new_phi,\n    containing phi nodes coming from two predecessors, and none of them are back\n    edges.  */\n \n-bool\n-translate_isl_ast_to_gimple::copy_cond_phi_nodes (basic_block bb,\n-\t\t\t\t\t\t  basic_block new_bb,\n-\t\t\t\t\t\t  vec<tree> iv_map)\n+bool translate_isl_ast_to_gimple::\n+copy_cond_phi_nodes (basic_block bb, basic_block new_bb, vec<tree> iv_map)\n {\n \n   gcc_assert (!bb_contains_loop_close_phi_nodes (bb));\n@@ -2797,8 +2534,8 @@ should_copy_to_new_region (gimple *stmt, sese_info_p region)\n /* Create new names for all the definitions created by COPY and add replacement\n    mappings for each new name.  */\n \n-void\n-translate_isl_ast_to_gimple::set_rename_for_each_def (gimple *stmt)\n+void translate_isl_ast_to_gimple::\n+set_rename_for_each_def (gimple *stmt)\n {\n   def_operand_p def_p;\n   ssa_op_iter op_iter;\n@@ -2813,10 +2550,9 @@ translate_isl_ast_to_gimple::set_rename_for_each_def (gimple *stmt)\n /* Duplicates the statements of basic block BB into basic block NEW_BB\n    and compute the new induction variables according to the IV_MAP.  */\n \n-bool\n-translate_isl_ast_to_gimple::graphite_copy_stmts_from_block (basic_block bb,\n-\t\t\t\t\t\t\t     basic_block new_bb,\n-\t\t\t\t\t\t\t     vec<tree> iv_map)\n+bool translate_isl_ast_to_gimple::\n+graphite_copy_stmts_from_block (basic_block bb, basic_block new_bb,\n+\t\t\t\tvec<tree> iv_map)\n {\n   /* Iterator poining to the place where new statement (s) will be inserted.  */\n   gimple_stmt_iterator gsi_tgt = gsi_last_bb (new_bb);\n@@ -2885,8 +2621,8 @@ translate_isl_ast_to_gimple::graphite_copy_stmts_from_block (basic_block bb,\n    to insert a copy of the close-phi nodes.  All the uses in close phis should\n    come from a single loop otherwise it returns NULL.  */\n \n-edge\n-translate_isl_ast_to_gimple::edge_for_new_close_phis (basic_block bb)\n+edge translate_isl_ast_to_gimple::\n+edge_for_new_close_phis (basic_block bb)\n {\n   /* Make sure that NEW_BB is the new_loop->exit->dest.  We find the definition\n      of close phi in the original code and then find the mapping of basic block\n@@ -2925,10 +2661,8 @@ translate_isl_ast_to_gimple::edge_for_new_close_phis (basic_block bb)\n    be reached following the use-def chains from the memory accesses,\n    and returns the next edge following this new block.  */\n \n-edge\n-translate_isl_ast_to_gimple::copy_bb_and_scalar_dependences (basic_block bb,\n-\t\t\t\t\t\t\t     edge next_e,\n-\t\t\t\t\t\t\t     vec<tree> iv_map)\n+edge translate_isl_ast_to_gimple::\n+copy_bb_and_scalar_dependences (basic_block bb, edge next_e, vec<tree> iv_map)\n {\n   int num_phis = number_of_phi_nodes (bb);\n \n@@ -3072,8 +2806,8 @@ translate_isl_ast_to_gimple::copy_bb_and_scalar_dependences (basic_block bb,\n \n /* Patch the missing arguments of the phi nodes.  */\n \n-void\n-translate_isl_ast_to_gimple::translate_pending_phi_nodes ()\n+void translate_isl_ast_to_gimple::\n+translate_pending_phi_nodes ()\n {\n   int i;\n   phi_rename *rename;\n@@ -3115,9 +2849,8 @@ translate_isl_ast_to_gimple::translate_pending_phi_nodes ()\n \n /* Add isl's parameter identifiers and corresponding trees to ivs_params.  */\n \n-void\n-translate_isl_ast_to_gimple::add_parameters_to_ivs_params (scop_p scop,\n-\t\t\t\t\t\t\t   ivs_params &ip)\n+void translate_isl_ast_to_gimple::\n+add_parameters_to_ivs_params (scop_p scop, ivs_params &ip)\n {\n   sese_info_p region = scop->scop_info;\n   unsigned nb_parameters = isl_set_dim (scop->param_context, isl_dim_param);\n@@ -3134,8 +2867,8 @@ translate_isl_ast_to_gimple::add_parameters_to_ivs_params (scop_p scop,\n \n /* Generates a build, which specifies the constraints on the parameters.  */\n \n-__isl_give isl_ast_build *\n-translate_isl_ast_to_gimple::generate_isl_context (scop_p scop)\n+__isl_give isl_ast_build *translate_isl_ast_to_gimple::\n+generate_isl_context (scop_p scop)\n {\n   isl_set *context_isl = isl_set_params (isl_set_copy (scop->param_context));\n   return isl_ast_build_from_context (context_isl);\n@@ -3162,8 +2895,8 @@ ast_build_before_for (__isl_keep isl_ast_build *build, void *user)\n \n /* Generate isl AST from schedule of SCOP.  */\n \n-__isl_give isl_ast_node *\n-translate_isl_ast_to_gimple::scop_to_isl_ast (scop_p scop)\n+__isl_give isl_ast_node *translate_isl_ast_to_gimple::\n+scop_to_isl_ast (scop_p scop)\n {\n   gcc_assert (scop->transformed_schedule);\n \n@@ -3189,8 +2922,8 @@ translate_isl_ast_to_gimple::scop_to_isl_ast (scop_p scop)\n #else\n /* Get the maximal number of schedule dimensions in the scop SCOP.  */\n \n-int\n-translate_isl_ast_to_gimple::get_max_schedule_dimensions (scop_p scop)\n+int translate_isl_ast_to_gimple::\n+get_max_schedule_dimensions (scop_p scop)\n {\n   int i;\n   poly_bb_p pbb;\n@@ -3213,9 +2946,8 @@ translate_isl_ast_to_gimple::get_max_schedule_dimensions (scop_p scop)\n    problem is to extend all schedules to the maximal number of schedule\n    dimensions (using '0's for the remaining values).  */\n \n-__isl_give isl_map *\n-translate_isl_ast_to_gimple::extend_schedule (__isl_take isl_map *schedule,\n-\t\t\t\t\t      int nb_schedule_dims)\n+__isl_give isl_map *translate_isl_ast_to_gimple::\n+extend_schedule (__isl_take isl_map *schedule, int nb_schedule_dims)\n {\n   int tmp_dims = isl_map_dim (schedule, isl_dim_out);\n   schedule =\n@@ -3235,8 +2967,8 @@ translate_isl_ast_to_gimple::extend_schedule (__isl_take isl_map *schedule,\n /* Generates a schedule, which specifies an order used to\n    visit elements in a domain.  */\n \n-__isl_give isl_union_map *\n-translate_isl_ast_to_gimple::generate_isl_schedule (scop_p scop)\n+__isl_give isl_union_map *translate_isl_ast_to_gimple::\n+generate_isl_schedule (scop_p scop)\n {\n   int nb_schedule_dims = get_max_schedule_dimensions (scop);\n   int i;\n@@ -3267,9 +2999,9 @@ translate_isl_ast_to_gimple::generate_isl_schedule (scop_p scop)\n /* Set the separate option for all dimensions.\n    This helps to reduce control overhead.  */\n \n-__isl_give isl_ast_build *\n-translate_isl_ast_to_gimple::set_options (__isl_take isl_ast_build *control,\n-\t\t\t\t\t  __isl_keep isl_union_map *schedule)\n+__isl_give isl_ast_build *translate_isl_ast_to_gimple::\n+set_options (__isl_take isl_ast_build *control,\n+\t     __isl_keep isl_union_map *schedule)\n {\n   isl_ctx *ctx = isl_union_map_get_ctx (schedule);\n   isl_space *range_space = isl_space_set_alloc (ctx, 0, 1);\n@@ -3285,8 +3017,8 @@ translate_isl_ast_to_gimple::set_options (__isl_take isl_ast_build *control,\n \n /* Generate isl AST from schedule of SCOP.  Also, collects IVS_PARAMS in IP.  */\n \n-__isl_give isl_ast_node *\n-translate_isl_ast_to_gimple::scop_to_isl_ast (scop_p scop, ivs_params &ip)\n+__isl_give isl_ast_node *translate_isl_ast_to_gimple::\n+scop_to_isl_ast (scop_p scop, ivs_params &ip)\n {\n   /* Generate loop upper bounds that consist of the current loop iterator, an\n      operator (< or <=) and an expression not involving the iterator.  If this\n@@ -3383,11 +3115,8 @@ copy_internal_parameters (sese_info_p region, sese_info_p to_region)\n     }\n }\n \n-/* GIMPLE Loop Generator: generates loops from STMT in GIMPLE form for\n-   the given SCOP.  Return true if code generation succeeded.\n-\n-   FIXME: This is not yet a full implementation of the code generator\n-   with isl ASTs.  Generation of GIMPLE code has to be completed.  */\n+/* GIMPLE Loop Generator: generates loops in GIMPLE form for the given SCOP.\n+   Return true if code generation succeeded.  */\n \n bool\n graphite_regenerate_ast_isl (scop_p scop)"}]}