{"sha": "b944d1875758f7cf655978b80ce9e2e45a9a0246", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjk0NGQxODc1NzU4ZjdjZjY1NTk3OGI4MGNlOWUyZTQ1YTlhMDI0Ng==", "commit": {"author": {"name": "Steven Bosscher", "email": "stevenb@suse.de", "date": "2003-12-13T01:06:11Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2003-12-13T01:06:11Z"}, "message": "ggc-zone.c (struct alloc_zone): Don't pre-declare, it already comes in with ggc.h.\n\n\t* ggc-zone.c (struct alloc_zone): Don't pre-declare, it already\n\tcomes in with ggc.h.  Add a new bool field `dead'.\n\t(destroy_ggc_zone): Don't destroy a zone at once.  Instead, only\n\tset the `dead' flag for the dead zone.  Wrap a sanity check in\n\tENABLE_CHECKING.\n\t(ggc_collect_1): Always mark and sweep if a zone has the `dead'\n\tflag set.\n\t(ggc_collect): Free dead zones after collecting.\n\nFrom-SVN: r74592", "tree": {"sha": "a2982fd809bd0bb84ba275ba4d287f0d614eb65b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a2982fd809bd0bb84ba275ba4d287f0d614eb65b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b944d1875758f7cf655978b80ce9e2e45a9a0246", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b944d1875758f7cf655978b80ce9e2e45a9a0246", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b944d1875758f7cf655978b80ce9e2e45a9a0246", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b944d1875758f7cf655978b80ce9e2e45a9a0246/comments", "author": null, "committer": null, "parents": [{"sha": "bbfff586bc9784558b71fd7d33dc1552a3118155", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bbfff586bc9784558b71fd7d33dc1552a3118155", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bbfff586bc9784558b71fd7d33dc1552a3118155"}], "stats": {"total": 77, "additions": 56, "deletions": 21}, "files": [{"sha": "34234a8dcce53f8eeea9dc90ab1b6771575fa6ab", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b944d1875758f7cf655978b80ce9e2e45a9a0246/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b944d1875758f7cf655978b80ce9e2e45a9a0246/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b944d1875758f7cf655978b80ce9e2e45a9a0246", "patch": "@@ -1,3 +1,14 @@\n+2003-12-13  Steven Bosscher  <stevenb@suse.de>\n+\n+\t* ggc-zone.c (struct alloc_zone): Don't pre-declare, it already\n+\tcomes in with ggc.h.  Add a new bool field `dead'.\n+\t(destroy_ggc_zone): Don't destroy a zone at once.  Instead, only\n+\tset the `dead' flag for the dead zone.  Wrap a sanity check in\n+\tENABLE_CHECKING.\n+\t(ggc_collect_1): Always mark and sweep if a zone has the `dead'\n+\tflag set.\n+\t(ggc_collect): Free dead zones after collecting.\n+ \n 2003-12-13  Jan Hubicka  <jh@suse.cz>\n \n \t* coverage.c (get_coverage_counts):  Use inform instead of warning"}, {"sha": "a45deae212cf5e09fa628ed6a256aa394753ba1e", "filename": "gcc/ggc-zone.c", "status": "modified", "additions": 45, "deletions": 21, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b944d1875758f7cf655978b80ce9e2e45a9a0246/gcc%2Fggc-zone.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b944d1875758f7cf655978b80ce9e2e45a9a0246/gcc%2Fggc-zone.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-zone.c?ref=b944d1875758f7cf655978b80ce9e2e45a9a0246", "patch": "@@ -244,7 +244,6 @@ struct max_alignment {\n #define LOOKUP_L2(p) \\\n   (((size_t) (p) >> G.lg_pagesize) & ((1 << PAGE_L2_BITS) - 1))\n \n-struct alloc_zone;\n /* A page_entry records the status of an allocation page.  */\n typedef struct page_entry\n {\n@@ -382,8 +381,11 @@ struct alloc_zone\n   /* Next zone in the linked list of zones.  */\n   struct alloc_zone *next_zone;\n \n-  /* Return true if this zone was collected during this collection.  */\n+  /* True if this zone was collected during this collection.  */\n   bool was_collected;\n+\n+  /* True if this zone should be destroyed after the next collection.  */\n+  bool dead;\n } main_zone;\n \n struct alloc_zone *rtl_zone;\n@@ -1215,17 +1217,14 @@ destroy_ggc_zone (struct alloc_zone * dead_zone)\n   for (z = G.zones; z && z->next_zone != dead_zone; z = z->next_zone)\n     /* Just find that zone.  */ ;\n \n-  /* We should have found the zone in the list.  Anything else is\n-     fatal.\n-     If we did find the zone, we expect this zone to be empty.\n-     A ggc_collect should have emptied it before we can destroy it.  */\n-  if (!z || dead_zone->allocated != 0)\n+#ifdef ENABLE_CHECKING\n+  /* We should have found the zone in the list.  Anything else is fatal.  */\n+  if (!z)\n     abort ();\n+#endif\n \n-  /* Unchain the dead zone, release all its pages and free it.  */\n-  z->next_zone = z->next_zone->next_zone;\n-  release_pages (dead_zone);\n-  free (dead_zone);\n+  /* z is dead, baby. z is dead.  */\n+  z->dead= true;\n }\n \n /* Increment the `GC context'.  Objects allocated in an outer context\n@@ -1408,19 +1407,24 @@ sweep_pages (struct alloc_zone *zone)\n static bool\n ggc_collect_1 (struct alloc_zone *zone, bool need_marking)\n {\n-  /* Avoid frequent unnecessary work by skipping collection if the\n-     total allocations haven't expanded much since the last\n-     collection.  */\n-  float allocated_last_gc =\n-    MAX (zone->allocated_last_gc, (size_t)PARAM_VALUE (GGC_MIN_HEAPSIZE) * 1024);\n+  if (!zone->dead)\n+    {\n+      /* Avoid frequent unnecessary work by skipping collection if the\n+\t total allocations haven't expanded much since the last\n+\t collection.  */\n+      float allocated_last_gc =\n+\tMAX (zone->allocated_last_gc,\n+\t     (size_t) PARAM_VALUE (GGC_MIN_HEAPSIZE) * 1024);\n \n-  float min_expand = allocated_last_gc * PARAM_VALUE (GGC_MIN_EXPAND) / 100;\n+      float min_expand = allocated_last_gc * PARAM_VALUE (GGC_MIN_EXPAND) / 100;\n \n-  if (zone->allocated < allocated_last_gc + min_expand)\n-    return false;\n+      if (zone->allocated < allocated_last_gc + min_expand)\n+\treturn false;\n+    }\n \n   if (!quiet_flag)\n-    fprintf (stderr, \" {%s GC %luk -> \", zone->name, (unsigned long) zone->allocated / 1024);\n+    fprintf (stderr, \" {%s GC %luk -> \",\n+\t     zone->name, (unsigned long) zone->allocated / 1024);\n \n   /* Zero the total allocated bytes.  This will be recalculated in the\n      sweep phase.  */\n@@ -1439,7 +1443,6 @@ ggc_collect_1 (struct alloc_zone *zone, bool need_marking)\n   zone->was_collected = true;\n   zone->allocated_last_gc = zone->allocated;\n \n-\n   if (!quiet_flag)\n     fprintf (stderr, \"%luk}\", (unsigned long) zone->allocated / 1024);\n   return true;\n@@ -1586,6 +1589,27 @@ ggc_collect (void)\n \t  }\n       }\n     }\n+\n+  /* Free dead zones.  */\n+  for (zone = G.zones; zone && zone->next_zone; zone = zone->next_zone)\n+    {\n+      if (zone->next_zone->dead)\n+\t{\n+\t  struct alloc_zone *dead_zone = zone->next_zone;\n+\n+\t  printf (\"Zone `%s' is dead and will be freed.\\n\", dead_zone->name);\n+\n+\t  /* The zone must be empty.  */\n+\t  if (dead_zone->allocated != 0)\n+\t    abort ();\n+\n+\t  /* Unchain the dead zone, release all its pages and free it.  */\n+\t  zone->next_zone = zone->next_zone->next_zone;\n+\t  release_pages (dead_zone);\n+\t  free (dead_zone);\n+\t}\n+    }\n+\n   timevar_pop (TV_GC);\n }\n "}]}