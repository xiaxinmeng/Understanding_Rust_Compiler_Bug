{"sha": "29dbb034cb3199167a9d0aaed040733c72326eed", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjlkYmIwMzRjYjMxOTkxNjdhOWQwYWFlZDA0MDczM2M3MjMyNmVlZA==", "commit": {"author": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2016-06-20T20:04:25Z"}, "committer": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2016-06-20T20:04:25Z"}, "message": "re PR libstdc++/71181 (Reserving in unordered_map doesn't reserve enough)\n\n2016-06-20  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n\n\tPR libstdc++/71181\n\t* include/tr1/hashtable_policy.h\n\t(_Prime_rehash_policy::_M_next_bkt): Make past-the-end iterator\n\tdereferenceable to avoid check on lower_bound result.\n\t(_Prime_rehash_policy::_M_bkt_for_elements): Call latter.\n\t(_Prime_rehash_policy::_M_need_rehash): Likewise.\n\t* src/c++11/hashtable_c++0x.cc (_Prime_rehash_policy::_M_next_bkt):\n\tAlways return a value greater than input value. Set _M_next_resize to\n\tmax value when reaching highest prime number.\n\t* src/shared/hashtable-aux.cc (__prime_list): Add comment about sentinel\n\tbeing now useless.\n\t* testsuite/23_containers/unordered_set/hash_policy/71181.cc: New.\n\t* testsuite/23_containers/unordered_set/hash_policy/power2_rehash.cc\n\t(test02): New.\n\t* testsuite/23_containers/unordered_set/hash_policy/prime_rehash.cc: New.\n\t* testsuite/23_containers/unordered_set/hash_policy/rehash.cc:\n\tFix indentation.\n\nFrom-SVN: r237617", "tree": {"sha": "c86343a665d22d10f0591ce6f4b23b371cb0f8fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c86343a665d22d10f0591ce6f4b23b371cb0f8fd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/29dbb034cb3199167a9d0aaed040733c72326eed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29dbb034cb3199167a9d0aaed040733c72326eed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/29dbb034cb3199167a9d0aaed040733c72326eed", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29dbb034cb3199167a9d0aaed040733c72326eed/comments", "author": null, "committer": null, "parents": [{"sha": "3947cf1919a959ad8e2a3f09b42c604c5553a6c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3947cf1919a959ad8e2a3f09b42c604c5553a6c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3947cf1919a959ad8e2a3f09b42c604c5553a6c4"}], "stats": {"total": 260, "additions": 216, "deletions": 44}, "files": [{"sha": "10ffc4169d1dec1a52ce61e5378c21e88d9706a5", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29dbb034cb3199167a9d0aaed040733c72326eed/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29dbb034cb3199167a9d0aaed040733c72326eed/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=29dbb034cb3199167a9d0aaed040733c72326eed", "patch": "@@ -1,3 +1,23 @@\n+2016-06-20  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n+\n+\tPR libstdc++/71181\n+\t* include/tr1/hashtable_policy.h\n+\t(_Prime_rehash_policy::_M_next_bkt): Make past-the-end iterator\n+\tdereferenceable to avoid check on lower_bound result.\n+\t(_Prime_rehash_policy::_M_bkt_for_elements): Call latter.\n+\t(_Prime_rehash_policy::_M_need_rehash): Likewise.\n+\t* src/c++11/hashtable_c++0x.cc (_Prime_rehash_policy::_M_next_bkt):\n+\tAlways return a value greater than input value. Set _M_next_resize to\n+\tmax value when reaching highest prime number.\n+\t* src/shared/hashtable-aux.cc (__prime_list): Add comment about sentinel\n+\tbeing now useless.\n+\t* testsuite/23_containers/unordered_set/hash_policy/71181.cc: New.\n+\t* testsuite/23_containers/unordered_set/hash_policy/power2_rehash.cc\n+\t(test02): New.\n+\t* testsuite/23_containers/unordered_set/hash_policy/prime_rehash.cc: New.\n+\t* testsuite/23_containers/unordered_set/hash_policy/rehash.cc:\n+\tFix indentation.\n+\n 2016-06-17  Jonathan Wakely  <jwakely@redhat.com>\n \n \tPR libstdc++/71545"}, {"sha": "c5cf866b1fefe3255d6817283e74af0fb12814c2", "filename": "libstdc++-v3/include/tr1/hashtable_policy.h", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29dbb034cb3199167a9d0aaed040733c72326eed/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fhashtable_policy.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29dbb034cb3199167a9d0aaed040733c72326eed/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fhashtable_policy.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fhashtable_policy.h?ref=29dbb034cb3199167a9d0aaed040733c72326eed", "patch": "@@ -420,8 +420,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   _Prime_rehash_policy::\n   _M_next_bkt(std::size_t __n) const\n   {\n-    const unsigned long* __p = std::lower_bound(__prime_list, __prime_list\n-\t\t\t\t\t\t+ _S_n_primes, __n);\n+    // Don't include the last prime in the search, so that anything\n+    // higher than the second-to-last prime returns a past-the-end\n+    // iterator that can be dereferenced to get the last prime.\n+    const unsigned long* __p\n+      = std::lower_bound(__prime_list, __prime_list + _S_n_primes - 1, __n);\n     _M_next_resize = \n       static_cast<std::size_t>(__builtin_ceil(*__p * _M_max_load_factor));\n     return *__p;\n@@ -434,11 +437,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   _M_bkt_for_elements(std::size_t __n) const\n   {\n     const float __min_bkts = __n / _M_max_load_factor;\n-    const unsigned long* __p = std::lower_bound(__prime_list, __prime_list\n-\t\t\t\t\t\t+ _S_n_primes, __min_bkts);\n-    _M_next_resize =\n-      static_cast<std::size_t>(__builtin_ceil(*__p * _M_max_load_factor));\n-    return *__p;\n+    return _M_next_bkt(__builtin_ceil(__min_bkts));\n   }\n \n   // Finds the smallest prime p such that alpha p > __n_elt + __n_ins.\n@@ -462,12 +461,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \tif (__min_bkts > __n_bkt)\n \t  {\n \t    __min_bkts = std::max(__min_bkts, _M_growth_factor * __n_bkt);\n-\t    const unsigned long* __p =\n-\t      std::lower_bound(__prime_list, __prime_list + _S_n_primes,\n-\t\t\t       __min_bkts);\n-\t    _M_next_resize = static_cast<std::size_t>\n-\t      (__builtin_ceil(*__p * _M_max_load_factor));\n-\t    return std::make_pair(true, *__p);\n+\t    return std::make_pair(true,\n+\t\t\t\t  _M_next_bkt(__builtin_ceil(__min_bkts)));\n \t  }\n \telse \n \t  {"}, {"sha": "ce4961fbd5ef43e8ecbcf818df653d792d8c7b65", "filename": "libstdc++-v3/src/c++11/hashtable_c++0x.cc", "status": "modified", "additions": 22, "deletions": 6, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29dbb034cb3199167a9d0aaed040733c72326eed/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Fhashtable_c%2B%2B0x.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29dbb034cb3199167a9d0aaed040733c72326eed/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Fhashtable_c%2B%2B0x.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Fhashtable_c%2B%2B0x.cc?ref=29dbb034cb3199167a9d0aaed040733c72326eed", "patch": "@@ -46,22 +46,38 @@ namespace __detail\n   {\n     // Optimize lookups involving the first elements of __prime_list.\n     // (useful to speed-up, eg, constructors)\n-    static const unsigned char __fast_bkt[12]\n-      = { 2, 2, 2, 3, 5, 5, 7, 7, 11, 11, 11, 11 };\n+    static const unsigned char __fast_bkt[13]\n+      = { 2, 2, 3, 5, 5, 7, 7, 11, 11, 11, 11, 13, 13 };\n \n-    if (__n <= 11)\n+    if (__n <= 12)\n       {\n \t_M_next_resize =\n \t  __builtin_ceil(__fast_bkt[__n] * (long double)_M_max_load_factor);\n \treturn __fast_bkt[__n];\n       }\n \n+    // Number of primes (without sentinel).\n     constexpr auto __n_primes\n       = sizeof(__prime_list) / sizeof(unsigned long) - 1;\n+\n+    // Don't include the last prime in the search, so that anything\n+    // higher than the second-to-last prime returns a past-the-end\n+    // iterator that can be dereferenced to get the last prime.\n+    constexpr auto __last_prime = __prime_list + __n_primes - 1;\n+\n+    // Look for 'n + 1' to make sure returned value will be greater than n.\n     const unsigned long* __next_bkt =\n-      std::lower_bound(__prime_list + 5, __prime_list + __n_primes, __n);\n-    _M_next_resize =\n-      __builtin_ceil(*__next_bkt * (long double)_M_max_load_factor);\n+      std::lower_bound(__prime_list + 6, __last_prime, __n + 1);\n+\n+    if (__next_bkt == __last_prime)\n+      // Set next resize to the max value so that we never try to rehash again\n+      // as we already reach the biggest possible bucket number.\n+      // Note that it might result in max_load_factor not being respected.\n+      _M_next_resize = std::size_t(-1);\n+    else\n+      _M_next_resize =\n+\t__builtin_ceil(*__next_bkt * (long double)_M_max_load_factor);\n+\n     return *__next_bkt;\n   }\n "}, {"sha": "ec9841e06a1797c233e74b2e9379a97be421ceab", "filename": "libstdc++-v3/src/shared/hashtable-aux.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29dbb034cb3199167a9d0aaed040733c72326eed/libstdc%2B%2B-v3%2Fsrc%2Fshared%2Fhashtable-aux.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29dbb034cb3199167a9d0aaed040733c72326eed/libstdc%2B%2B-v3%2Fsrc%2Fshared%2Fhashtable-aux.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fshared%2Fhashtable-aux.cc?ref=29dbb034cb3199167a9d0aaed040733c72326eed", "patch": "@@ -25,6 +25,7 @@\n namespace __detail\n {\n _GLIBCXX_BEGIN_NAMESPACE_VERSION\n+  // The sentinel value is kept only for abi backward compatibility.\n   extern const unsigned long __prime_list[] = // 256 + 1 or 256 + 48 + 1\n   {\n     2ul, 3ul, 5ul, 7ul, 11ul, 13ul, 17ul, 19ul, 23ul, 29ul, 31ul,"}, {"sha": "a8bbfc736d9eb90770fe573dfda981f3f89513f5", "filename": "libstdc++-v3/testsuite/23_containers/unordered_set/hash_policy/71181.cc", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29dbb034cb3199167a9d0aaed040733c72326eed/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fhash_policy%2F71181.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29dbb034cb3199167a9d0aaed040733c72326eed/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fhash_policy%2F71181.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fhash_policy%2F71181.cc?ref=29dbb034cb3199167a9d0aaed040733c72326eed", "patch": "@@ -0,0 +1,63 @@\n+// Copyright (C) 2016 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+//\n+// { dg-options \"-std=gnu++11\" }\n+\n+#include <unordered_set>\n+\n+#include <testsuite_hooks.h>\n+\n+template<typename _USet>\n+  void test(int threshold)\n+  {\n+    bool test __attribute__((unused)) = true;\n+    _USet us;\n+    auto nb_reserved = us.bucket_count();\n+    us.reserve(nb_reserved);\n+    auto bkts = us.bucket_count();\n+    for (int i = 0; i != threshold; ++i)\n+      {\n+\tif (i == nb_reserved)\n+\t  {\n+\t    nb_reserved = bkts;\n+\t    us.reserve(nb_reserved);\n+\t    bkts = us.bucket_count();\n+\t  }\n+\n+\tus.insert(i);\n+\n+\tVERIFY( us.bucket_count() == bkts );\n+      }\n+  }\n+\n+template<typename _Value>\n+  using unordered_set_power2_rehash =\n+  std::_Hashtable<_Value, _Value, std::allocator<_Value>,\n+\t\t  std::__detail::_Identity,\n+\t\t  std::equal_to<_Value>,\n+\t\t  std::hash<_Value>,\n+\t\t  std::__detail::_Mask_range_hashing,\n+\t\t  std::__detail::_Default_ranged_hash,\n+\t\t  std::__detail::_Power2_rehash_policy,\n+\t\t  std::__detail::_Hashtable_traits<false, true, true>>;\n+\n+int main()\n+{\n+  test<std::unordered_set<int>>(150);\n+  test<unordered_set_power2_rehash<int>>(150);\n+  return 0;\n+}"}, {"sha": "5805f7aafc62d1b3e81d03f37cb82d12e5b658eb", "filename": "libstdc++-v3/testsuite/23_containers/unordered_set/hash_policy/power2_rehash.cc", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29dbb034cb3199167a9d0aaed040733c72326eed/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fhash_policy%2Fpower2_rehash.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29dbb034cb3199167a9d0aaed040733c72326eed/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fhash_policy%2Fpower2_rehash.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fhash_policy%2Fpower2_rehash.cc?ref=29dbb034cb3199167a9d0aaed040733c72326eed", "patch": "@@ -17,6 +17,7 @@\n //\n // { dg-options \"-std=gnu++11\" }\n \n+#include <limits>\n #include <unordered_set>\n \n #include <testsuite_hooks.h>\n@@ -35,8 +36,32 @@ void test01()\n \t  == (std::size_t(1) << (sizeof(std::size_t) * 8 - 1)) );\n }\n \n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  std::__detail::_Power2_rehash_policy policy;\n+\n+  for (std::size_t i = 1;;)\n+    {\n+      auto nxt = policy._M_next_bkt(i);\n+\n+      if (nxt == i)\n+\t{\n+\t  // Equals only when reaching max.\n+\t  constexpr auto mx = std::numeric_limits<std::size_t>::max();\n+\t  VERIFY( nxt == policy._M_next_bkt(mx) );\n+\t  break;\n+\t}\n+\n+      VERIFY( nxt > i );\n+      i = nxt;\n+    }\n+}\n+\n int main()\n {\n   test01();\n+  test02();\n   return 0;\n }"}, {"sha": "403382349fad547e84dcec77e24afc3576d73b7b", "filename": "libstdc++-v3/testsuite/23_containers/unordered_set/hash_policy/prime_rehash.cc", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29dbb034cb3199167a9d0aaed040733c72326eed/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fhash_policy%2Fprime_rehash.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29dbb034cb3199167a9d0aaed040733c72326eed/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fhash_policy%2Fprime_rehash.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fhash_policy%2Fprime_rehash.cc?ref=29dbb034cb3199167a9d0aaed040733c72326eed", "patch": "@@ -0,0 +1,52 @@\n+// Copyright (C) 2016 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+//\n+// { dg-options \"-std=gnu++11\" }\n+\n+#include <limits>\n+#include <unordered_set>\n+\n+#include <testsuite_hooks.h>\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  std::__detail::_Prime_rehash_policy policy;\n+\n+  for (std::size_t i = 1;;)\n+    {\n+      auto nxt = policy._M_next_bkt(i);\n+\n+      if (nxt == i)\n+\t{\n+\t  // Equals only when reaching max.\n+\t  constexpr auto mx = std::numeric_limits<std::size_t>::max() - 1;\n+\t  VERIFY( nxt == policy._M_next_bkt(mx) );\n+\t  break;\n+\t}\n+\n+      VERIFY( nxt > i );\n+      i = nxt;\n+    }\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "96581317446e49de42a3c98808b5b143518657d6", "filename": "libstdc++-v3/testsuite/23_containers/unordered_set/hash_policy/rehash.cc", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29dbb034cb3199167a9d0aaed040733c72326eed/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fhash_policy%2Frehash.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29dbb034cb3199167a9d0aaed040733c72326eed/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fhash_policy%2Frehash.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fhash_policy%2Frehash.cc?ref=29dbb034cb3199167a9d0aaed040733c72326eed", "patch": "@@ -22,40 +22,40 @@\n #include <testsuite_hooks.h>\n \n template<typename _USet>\n-void test()\n-{\n-  bool test __attribute__((unused)) = true;\n-  _USet us;\n-  typedef typename _USet::size_type size_type;\n-  bool rehashed = false;\n-  for (int i = 0; i != 100000; ++i)\n+  void test()\n   {\n-    size_type bkt_count = us.bucket_count();\n-    us.insert(i);\n-    if (bkt_count != us.bucket_count())\n+    bool test __attribute__((unused)) = true;\n+    _USet us;\n+    typedef typename _USet::size_type size_type;\n+    bool rehashed = false;\n+    for (int i = 0; i != 100000; ++i)\n       {\n-\t// Container has been rehashed, lets check that it won't be rehash again\n-\t// if we remove and restore the last 2 inserted elements:\n-\trehashed = true;\n-\tbkt_count = us.bucket_count();\n-\tVERIFY( us.erase(i) == 1 );\n-\tVERIFY( bkt_count == us.bucket_count() );\n-\tif (i > 0)\n+\tsize_type bkt_count = us.bucket_count();\n+\tus.insert(i);\n+\tif (bkt_count != us.bucket_count())\n \t  {\n-\t    VERIFY( us.erase(i - 1) == 1 );\n+\t    // Container has been rehashed, lets check that it won't be rehash\n+\t    // again if we remove and restore the last 2 inserted elements:\n+\t    rehashed = true;\n+\t    bkt_count = us.bucket_count();\n+\t    VERIFY( us.erase(i) == 1 );\n \t    VERIFY( bkt_count == us.bucket_count() );\n+\t    if (i > 0)\n+\t      {\n+\t\tVERIFY( us.erase(i - 1) == 1 );\n+\t\tVERIFY( bkt_count == us.bucket_count() );\n \n-\t    VERIFY( us.insert(i - 1).second );\n+\t\tVERIFY( us.insert(i - 1).second );\n+\t\tVERIFY( bkt_count == us.bucket_count() );\n+\t      }\n+\t    VERIFY( us.insert(i).second );\n \t    VERIFY( bkt_count == us.bucket_count() );\n \t  }\n-\tVERIFY( us.insert(i).second );\n-\tVERIFY( bkt_count == us.bucket_count() );\n       }\n-  }\n \n-  // At lest we check a rehash once:\n-  VERIFY( rehashed );\n-}\n+    // At lest we check a rehash once:\n+    VERIFY( rehashed );\n+  }\n \n template<typename _Value>\n   using unordered_set_power2_rehash ="}]}