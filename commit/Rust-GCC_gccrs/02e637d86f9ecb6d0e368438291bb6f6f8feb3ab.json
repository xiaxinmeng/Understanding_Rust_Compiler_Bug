{"sha": "02e637d86f9ecb6d0e368438291bb6f6f8feb3ab", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDJlNjM3ZDg2ZjllY2I2ZDBlMzY4NDM4MjkxYmI2ZjZmOGZlYjNhYg==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2017-09-05T08:12:27Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2017-09-05T08:12:27Z"}, "message": "Learn CFG cleanup to transform single case switches to gcond.\n\n2017-09-05  Martin Liska  <mliska@suse.cz>\n\n\tPR tree-optimization/82032\n\t* tree-cfg.c (generate_range_test): New function.\n\t* tree-cfg.h (generate_range_test): Declared here.\n\t* tree-cfgcleanup.c (convert_single_case_switch): New function.\n\t(cleanup_control_expr_graph): Use it.\n\t* tree-switch-conversion.c (try_switch_expansion): Remove\n\tassert.\n\t(emit_case_nodes): Use generate_range_test.\n2017-09-05  Martin Liska  <mliska@suse.cz>\n\n\tPR tree-optimization/82032\n\t* g++.dg/other/pr82032.C: New test.\n\t* gcc.dg/tree-ssa/pr68198.c: Update scanned pattern.\n\t* gcc.dg/tree-ssa/vrp34.c: Likewise.\n\t* gcc.dg/switch-10.c: Likewise.\n\nFrom-SVN: r251690", "tree": {"sha": "93af2d7dae66c7bb229217f75ae4b0d99853f7c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/93af2d7dae66c7bb229217f75ae4b0d99853f7c7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/02e637d86f9ecb6d0e368438291bb6f6f8feb3ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02e637d86f9ecb6d0e368438291bb6f6f8feb3ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02e637d86f9ecb6d0e368438291bb6f6f8feb3ab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02e637d86f9ecb6d0e368438291bb6f6f8feb3ab/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b471c5c6cf2bfe51699b7fcbcffc34024ff7bfce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b471c5c6cf2bfe51699b7fcbcffc34024ff7bfce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b471c5c6cf2bfe51699b7fcbcffc34024ff7bfce"}], "stats": {"total": 173, "additions": 144, "deletions": 29}, "files": [{"sha": "7a824f82a2ecb6b9080e611c3b13e5a926b4fe2e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02e637d86f9ecb6d0e368438291bb6f6f8feb3ab/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02e637d86f9ecb6d0e368438291bb6f6f8feb3ab/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=02e637d86f9ecb6d0e368438291bb6f6f8feb3ab", "patch": "@@ -1,3 +1,14 @@\n+2017-09-05  Martin Liska  <mliska@suse.cz>\n+\n+\tPR tree-optimization/82032\n+\t* tree-cfg.c (generate_range_test): New function.\n+\t* tree-cfg.h (generate_range_test): Declared here.\n+\t* tree-cfgcleanup.c (convert_single_case_switch): New function.\n+\t(cleanup_control_expr_graph): Use it.\n+\t* tree-switch-conversion.c (try_switch_expansion): Remove\n+\tassert.\n+\t(emit_case_nodes): Use generate_range_test.\n+\n 2017-09-04  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR target/82098"}, {"sha": "74790654be854a22690a351d66098fc9ca2f4dff", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02e637d86f9ecb6d0e368438291bb6f6f8feb3ab/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02e637d86f9ecb6d0e368438291bb6f6f8feb3ab/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=02e637d86f9ecb6d0e368438291bb6f6f8feb3ab", "patch": "@@ -1,3 +1,11 @@\n+2017-09-05  Martin Liska  <mliska@suse.cz>\n+\n+\tPR tree-optimization/82032\n+\t* g++.dg/other/pr82032.C: New test.\n+\t* gcc.dg/tree-ssa/pr68198.c: Update scanned pattern.\n+\t* gcc.dg/tree-ssa/vrp34.c: Likewise.\n+\t* gcc.dg/switch-10.c: Likewise.\n+\n 2017-09-04  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* gcc.target/i386/mpx/mpx-os-support.h: New file."}, {"sha": "607bf85c8e10a44b3201a4ed6dcdb5be64e6cef8", "filename": "gcc/testsuite/g++.dg/other/pr82032.C", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02e637d86f9ecb6d0e368438291bb6f6f8feb3ab/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fpr82032.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02e637d86f9ecb6d0e368438291bb6f6f8feb3ab/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fpr82032.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fpr82032.C?ref=02e637d86f9ecb6d0e368438291bb6f6f8feb3ab", "patch": "@@ -0,0 +1,36 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -Wno-return-type\" } */\n+\n+template <typename a> class b\n+{\n+public:\n+  typename a::aa operator[] (typename a::c) { }\n+};\n+class d\n+{\n+public:\n+  typedef long c;\n+  typedef int aa;\n+};\n+struct e\n+{\n+  int af[4];\n+  int ag;\n+};\n+b<d> f;\n+bool\n+g (e &i)\n+{\n+  for (int h; h; ++h)\n+    switch (f[h])\n+      {\n+      case 'x':\n+      case 'a':\n+\ti.af[h] = 3;\n+\tbreak;\n+      default:\n+\treturn false;\n+      }\n+\n+  return true;\n+}"}, {"sha": "9e5926745b88c39a3a2309fe7b10949a3ed5da96", "filename": "gcc/testsuite/gcc.dg/switch-10.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02e637d86f9ecb6d0e368438291bb6f6f8feb3ab/gcc%2Ftestsuite%2Fgcc.dg%2Fswitch-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02e637d86f9ecb6d0e368438291bb6f6f8feb3ab/gcc%2Ftestsuite%2Fgcc.dg%2Fswitch-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fswitch-10.c?ref=02e637d86f9ecb6d0e368438291bb6f6f8feb3ab", "patch": "@@ -1,6 +1,4 @@\n /* { dg-options \"-O2 -fdump-tree-cfg\" }  */\n-/* { dg-final { scan-tree-dump \"case 0:\" \"cfg\" } }  */\n-/* { dg-final { scan-tree-dump-not \"case 1 ... 255:\" \"cfg\" } }  */\n #include <stdint.h>\n \n void foo (void);\n@@ -20,3 +18,6 @@ test (uint8_t ch)\n      break;\n    }\n }\n+\n+/* Switch statement is converted to GIMPLE condition.  */\n+/* { dg-final { scan-tree-dump-not \"switch\" \"cfg\" } }  */"}, {"sha": "59d562e156c2da3b70374d5eae347c7bd09db9a1", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr68198.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02e637d86f9ecb6d0e368438291bb6f6f8feb3ab/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr68198.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02e637d86f9ecb6d0e368438291bb6f6f8feb3ab/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr68198.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr68198.c?ref=02e637d86f9ecb6d0e368438291bb6f6f8feb3ab", "patch": "@@ -37,7 +37,5 @@ c_finish_omp_clauses (tree clauses)\n     }\n }\n \n-/* There are 3 FSM jump threading opportunities, two of which will\n-  get filtered out.  */\n-/* { dg-final { scan-tree-dump-times \"Registering FSM\" 1 \"thread1\"} } */\n-/* { dg-final { scan-tree-dump-times \"FSM Thread through multiway branch without threading a multiway branch\" 2 \"thread1\"} } */\n+/* There are 3 FSM jump threading opportunities.  */\n+/* { dg-final { scan-tree-dump-times \"Registering FSM\" 3 \"thread1\"} } */"}, {"sha": "d2a36a706f23c5bf344b6354a2b61f4320f42ff6", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp34.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02e637d86f9ecb6d0e368438291bb6f6f8feb3ab/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp34.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02e637d86f9ecb6d0e368438291bb6f6f8feb3ab/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp34.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp34.c?ref=02e637d86f9ecb6d0e368438291bb6f6f8feb3ab", "patch": "@@ -15,5 +15,6 @@ foo (int a)\n     }\n }\n \n-/* Both ifs should be optimized.  */\n-/* { dg-final { scan-tree-dump-times \"if \\\\\\(\" 0 \"vrp1\" } } */\n+/* Both ifs should be optimized (and switch statement will be the only if\n+   in the function).  */\n+/* { dg-final { scan-tree-dump-times \"if \\\\\\(\" 1 \"vrp1\" } } */"}, {"sha": "b601012cfeddb546ee7a3d1ac02e2eb19b755f56", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02e637d86f9ecb6d0e368438291bb6f6f8feb3ab/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02e637d86f9ecb6d0e368438291bb6f6f8feb3ab/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=02e637d86f9ecb6d0e368438291bb6f6f8feb3ab", "patch": "@@ -8927,7 +8927,31 @@ extract_true_false_controlled_edges (basic_block dom, basic_block phiblock,\n   return true;\n }\n \n+/* Generate a range test LHS CODE RHS that determines whether INDEX is in the\n+    range [low, high].  Place associated stmts before *GSI.  */\n \n+void\n+generate_range_test (basic_block bb, tree index, tree low, tree high,\n+\t\t     tree *lhs, tree *rhs)\n+{\n+  tree type = TREE_TYPE (index);\n+  tree utype = unsigned_type_for (type);\n+\n+  low = fold_convert (type, low);\n+  high = fold_convert (type, high);\n+\n+  tree tmp = make_ssa_name (type);\n+  gassign *sub1\n+    = gimple_build_assign (tmp, MINUS_EXPR, index, low);\n+\n+  *lhs = make_ssa_name (utype);\n+  gassign *a = gimple_build_assign (*lhs, NOP_EXPR, tmp);\n+\n+  *rhs = fold_build2 (MINUS_EXPR, utype, high, low);\n+  gimple_stmt_iterator gsi = gsi_last_bb (bb);\n+  gsi_insert_before (&gsi, sub1, GSI_SAME_STMT);\n+  gsi_insert_before (&gsi, a, GSI_SAME_STMT);\n+}\n \n /* Emit return warnings.  */\n "}, {"sha": "7a08cb074f733835d9def0c21a19a9d1945cbf5d", "filename": "gcc/tree-cfg.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02e637d86f9ecb6d0e368438291bb6f6f8feb3ab/gcc%2Ftree-cfg.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02e637d86f9ecb6d0e368438291bb6f6f8feb3ab/gcc%2Ftree-cfg.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.h?ref=02e637d86f9ecb6d0e368438291bb6f6f8feb3ab", "patch": "@@ -109,6 +109,8 @@ extern basic_block insert_cond_bb (basic_block, gimple *, gimple *,\n extern bool gimple_find_sub_bbs (gimple_seq, gimple_stmt_iterator *);\n extern bool extract_true_false_controlled_edges (basic_block, basic_block,\n \t\t\t\t\t\t edge *, edge *);\n+extern void generate_range_test (basic_block bb, tree index, tree low,\n+\t\t\t\t tree high, tree *lhs, tree *rhs);\n \n /* Return true if the LHS of a call should be removed.  */\n "}, {"sha": "a7053d748c66b22f905f29dac4b28adfd3cb7cfc", "filename": "gcc/tree-cfgcleanup.c", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02e637d86f9ecb6d0e368438291bb6f6f8feb3ab/gcc%2Ftree-cfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02e637d86f9ecb6d0e368438291bb6f6f8feb3ab/gcc%2Ftree-cfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfgcleanup.c?ref=02e637d86f9ecb6d0e368438291bb6f6f8feb3ab", "patch": "@@ -74,6 +74,49 @@ remove_fallthru_edge (vec<edge, va_gc> *ev)\n   return false;\n }\n \n+/* Convert a SWTCH with single non-default case to gcond and replace it\n+   at GSI.  */\n+\n+static bool\n+convert_single_case_switch (gswitch *swtch, gimple_stmt_iterator &gsi)\n+{\n+  if (gimple_switch_num_labels (swtch) != 2)\n+    return false;\n+\n+  tree index = gimple_switch_index (swtch);\n+  tree default_label = CASE_LABEL (gimple_switch_default_label (swtch));\n+  tree label = gimple_switch_label (swtch, 1);\n+  tree low = CASE_LOW (label);\n+  tree high = CASE_HIGH (label);\n+\n+  basic_block default_bb = label_to_block_fn (cfun, default_label);\n+  basic_block case_bb = label_to_block_fn (cfun, CASE_LABEL (label));\n+\n+  basic_block bb = gimple_bb (swtch);\n+  gcond *cond;\n+\n+  /* Replace switch statement with condition statement.  */\n+  if (high)\n+    {\n+      tree lhs, rhs;\n+      generate_range_test (bb, index, low, high, &lhs, &rhs);\n+      cond = gimple_build_cond (LE_EXPR, lhs, rhs, NULL_TREE, NULL_TREE);\n+    }\n+  else\n+    cond = gimple_build_cond (EQ_EXPR, index,\n+\t\t\t      fold_convert (TREE_TYPE (index), low),\n+\t\t\t      NULL_TREE, NULL_TREE);\n+\n+  gsi_replace (&gsi, cond, true);\n+\n+  /* Update edges.  */\n+  edge case_edge = find_edge (bb, case_bb);\n+  edge default_edge = find_edge (bb, default_bb);\n+\n+  case_edge->flags |= EDGE_TRUE_VALUE;\n+  default_edge->flags |= EDGE_FALSE_VALUE;\n+  return true;\n+}\n \n /* Disconnect an unreachable block in the control expression starting\n    at block BB.  */\n@@ -93,6 +136,12 @@ cleanup_control_expr_graph (basic_block bb, gimple_stmt_iterator gsi,\n       bool warned;\n       tree val = NULL_TREE;\n \n+      /* Try to convert a switch with just a single non-default case to\n+\t GIMPLE condition.  */\n+      if (gimple_code (stmt) == GIMPLE_SWITCH\n+\t  && convert_single_case_switch (as_a<gswitch *> (stmt), gsi))\n+\tstmt = gsi_stmt (gsi);\n+\n       fold_defer_overflow_warnings ();\n       switch (gimple_code (stmt))\n \t{"}, {"sha": "6d7c2c4902fa75c6fcdcf6765953373d747b9d1b", "filename": "gcc/tree-switch-conversion.c", "status": "modified", "additions": 6, "deletions": 21, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02e637d86f9ecb6d0e368438291bb6f6f8feb3ab/gcc%2Ftree-switch-conversion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02e637d86f9ecb6d0e368438291bb6f6f8feb3ab/gcc%2Ftree-switch-conversion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-switch-conversion.c?ref=02e637d86f9ecb6d0e368438291bb6f6f8feb3ab", "patch": "@@ -2057,9 +2057,8 @@ try_switch_expansion (gswitch *stmt)\n      expressions being INTEGER_CST.  */\n   gcc_assert (TREE_CODE (index_expr) != INTEGER_CST);\n \n-  /* Optimization of switch statements with only one label has already\n-     occurred, so we should never see them at this point.  */\n-  gcc_assert (ncases > 1);\n+  if (ncases == 1)\n+    return false;\n \n   /* Find the default case target label.  */\n   tree default_label = CASE_LABEL (gimple_switch_default_label (stmt));\n@@ -2701,27 +2700,13 @@ emit_case_nodes (basic_block bb, tree index, case_node_ptr node,\n \t    }\n \t  else if (!low_bound && !high_bound)\n \t    {\n-\t      tree type = TREE_TYPE (index);\n-\t      tree utype = unsigned_type_for (type);\n-\n-\t      tree lhs = make_ssa_name (type);\n-\t      gassign *sub1\n-\t\t= gimple_build_assign (lhs, MINUS_EXPR, index, node->low);\n-\n-\t      tree converted = make_ssa_name (utype);\n-\t      gassign *a = gimple_build_assign (converted, NOP_EXPR, lhs);\n-\n-\t      tree rhs = fold_build2 (MINUS_EXPR, utype,\n-\t\t\t\t      fold_convert (type, node->high),\n-\t\t\t\t      fold_convert (type, node->low));\n-\t      gimple_stmt_iterator gsi = gsi_last_bb (bb);\n-\t      gsi_insert_before (&gsi, sub1, GSI_SAME_STMT);\n-\t      gsi_insert_before (&gsi, a, GSI_SAME_STMT);\n-\n+\t      tree lhs, rhs;\n+\t      generate_range_test (bb, index, node->low, node->high,\n+\t\t\t\t   &lhs, &rhs);\n \t      probability\n \t\t= conditional_probability (default_prob,\n \t\t\t\t\t   subtree_prob + default_prob);\n-\t      bb = emit_cmp_and_jump_insns (bb, converted, rhs, GT_EXPR,\n+\t      bb = emit_cmp_and_jump_insns (bb, lhs, rhs, GT_EXPR,\n \t\t\t\t\t    default_bb, probability,\n \t\t\t\t\t    phi_mapping);\n \t    }"}]}