{"sha": "19c3fc24838bf562b9c833738a37905aee90c692", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTljM2ZjMjQ4MzhiZjU2MmI5YzgzMzczOGEzNzkwNWFlZTkwYzY5Mg==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-03-29T04:32:58Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-03-29T04:32:58Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r623", "tree": {"sha": "4b3453ca2f132898d0402544d4ca229870980523", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4b3453ca2f132898d0402544d4ca229870980523"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/19c3fc24838bf562b9c833738a37905aee90c692", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19c3fc24838bf562b9c833738a37905aee90c692", "html_url": "https://github.com/Rust-GCC/gccrs/commit/19c3fc24838bf562b9c833738a37905aee90c692", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19c3fc24838bf562b9c833738a37905aee90c692/comments", "author": null, "committer": null, "parents": [{"sha": "7ea6d623a8b05aa706f8175d9de5e892e0ca45fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ea6d623a8b05aa706f8175d9de5e892e0ca45fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ea6d623a8b05aa706f8175d9de5e892e0ca45fd"}], "stats": {"total": 243, "additions": 231, "deletions": 12}, "files": [{"sha": "14a9428f2001039d81d2056fec67857cb3fe1028", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19c3fc24838bf562b9c833738a37905aee90c692/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19c3fc24838bf562b9c833738a37905aee90c692/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=19c3fc24838bf562b9c833738a37905aee90c692", "patch": "@@ -3633,6 +3633,42 @@\n   \"TARGET_80387\"\n   \"* return (char *) output_387_binary_op (insn, operands);\")\n \f\n+(define_expand \"strlensi\"\n+  [(parallel [(set (match_dup 4)\n+\t\t   (unspec:SI [(mem:BLK (match_operand:BLK 1 \"general_operand\" \"\"))\n+\t\t\t       (match_operand:QI 2 \"register_operand\" \"\")\n+\t\t\t       (match_operand:SI 3 \"immediate_operand\" \"\")] 0))\n+\t      (clobber (match_dup 1))])\n+   (set (match_dup 5)\n+\t(not:SI (match_dup 4)))\n+   (set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(minus:SI (match_dup 5)\n+\t\t (const_int 1)))]\n+  \"\"\n+  \"\n+{\n+  operands[1] = copy_to_mode_reg (SImode, XEXP (operands[1], 0));\n+  operands[4] = gen_reg_rtx (SImode);\n+  operands[5] = gen_reg_rtx (SImode);\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=&c\")\n+\t(unspec:SI [(mem:BLK (match_operand:SI 1 \"register_operand\" \"D\"))\n+\t\t    (match_operand:QI 2 \"register_operand\" \"a\")\n+\t\t    (match_operand:SI 3 \"immediate_operand\" \"i\")] 0))\n+   (clobber (match_dup 1))]\n+  \"\"\n+  \"*\n+{\n+  rtx xops[2];\n+\n+  xops[0] = operands[0];\n+  xops[1] = constm1_rtx;\n+  output_asm_insn (AS2 (mov%L0,%1,%0), xops);\n+  return \\\"repnz\\;scas%B2\\\";\n+}\")\n+\f\n ;;- Local variables:\n ;;- mode:emacs-lisp\n ;;- comment-start: \";;- \""}, {"sha": "6dc009f9bd99504dc5777c009f6d2a61526fd6c8", "filename": "gcc/config/i386/x-ncr3000", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19c3fc24838bf562b9c833738a37905aee90c692/gcc%2Fconfig%2Fi386%2Fx-ncr3000", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19c3fc24838bf562b9c833738a37905aee90c692/gcc%2Fconfig%2Fi386%2Fx-ncr3000", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fx-ncr3000?ref=19c3fc24838bf562b9c833738a37905aee90c692", "patch": "@@ -1,3 +1,21 @@\n+# Makefile additions for the NCR3000 as host system.\n+\n+# Using -O with the AT&T compiler fails, with a message about a missing\n+# /usr/ccs/lib/optim pass.  So override the default in Makefile.in\n+\n+CCLIBFLAGS=\n+\n+# NCR3000 ships with a MetaWare compiler installed as CC, which chokes and\n+# dies all over the place on GCC source.  However, the AT&T compiler,\n+# crusty as it is, can be used to bootstrap GCC.  It can be found in\n+# /usr/ccs/ATT/cc.  It is also used to compile the things that should\n+# not be compiled with GCC.\n+\n+CC = /usr/ccs/ATT/cc\n+OLDCC = /usr/ccs/ATT/cc\n+\n+# The rest is just x-i386v4.\n+\n # The svr4 reference port for the i386 contains an alloca.o routine\n # in /usr/ucblib/libucb.a, but we can't just try to get that by\n # setting CLIB to /usr/ucblib/libucb.a because (unfortunately)"}, {"sha": "b7b7ffe3f24ac8f2899317d3c524f674b60da498", "filename": "gcc/config/sparc/sysv4.h", "status": "modified", "additions": 146, "deletions": 12, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19c3fc24838bf562b9c833738a37905aee90c692/gcc%2Fconfig%2Fsparc%2Fsysv4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19c3fc24838bf562b9c833738a37905aee90c692/gcc%2Fconfig%2Fsparc%2Fsysv4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsysv4.h?ref=19c3fc24838bf562b9c833738a37905aee90c692", "patch": "@@ -1,5 +1,5 @@\n /* Target definitions for GNU compiler for Sparc running System V.4\n-   Copyright (C) 1991 Free Software Foundation, Inc.\n+   Copyright (C) 1991, 1992 Free Software Foundation, Inc.\n \n    Written by Ron Guilmette (rfg@ncd.com).\n \n@@ -20,30 +20,164 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n \n #include \"sparc.h\"\n+\n+/* Undefine some symbols which are defined in \"sparc.h\" but which are\n+   appropriate only for SunOS 4.x, and not for svr4.  */\n+\n+#undef DBX_DEBUGGING_INFO\n+#undef WORD_SWITCH_TAKES_ARG\n+#undef SELECT_SECTION\n+#undef ASM_DECLARE_FUNCTION_NAME\n+#undef TEXT_SECTION_ASM_OP\n+#undef DATA_SECTION_ASM_OP\n+\n #include \"svr4.h\"\n \n+/* Undefined some symbols which are defined in \"svr4.h\" but which are\n+   appropriate only for typical svr4 systems, but not for the specific\n+   case of svr4 running on a Sparc.  */\n+\n+#undef CTORS_SECTION_ASM_OP\n+#undef DTORS_SECTION_ASM_OP\n+#undef INIT_SECTION_ASM_OP\n+#undef CONST_SECTION_ASM_OP\n+#undef TYPE_OPERAND_FMT\n+#undef PUSHSECTION_FORMAT\n+#undef STRING_ASM_OP\n+#undef COMMON_ASM_OP\n+#undef SKIP_ASM_OP\n+#undef DEF_ASM_OP\t/* Has no equivalent.  See ASM_OUTPUT_DEF below.  */\n+#undef ASM_GENERATE_INTERNAL_LABEL\n+#undef ASM_OUTPUT_INTERNAL_LABEL\n+\n /* Provide a set of pre-definitions and pre-assertions appropriate for\n-   the sparc running svr4.  __svr4__ is our extension.  */\n+   the Sparc running svr4.  __svr4__ is our extension.  */\n \n #define CPP_PREDEFINES \\\n   \"-Dsparc -Dunix -D__svr4__ -Asystem(unix) -Acpu(sparc) -Amachine(sparc)\"\n \n+/* This is the string used to begin an assembly language comment for the\n+   Sparc/svr4 assembler.  */\n+\n #define ASM_COMMENT_START \"!\"\n \n-#undef TYPE_OPERAND_FMT\n+/* Define the names of various pseudo-op used by the Sparc/svr4 assembler.\n+   Note that many of these are different from the typical pseudo-ops used\n+   by most svr4 assemblers.  That is probably due to a (misguided?) attempt\n+   to keep the Sparc/svr4 assembler somewhat compatible with the Sparc/SunOS\n+   assembler.  */\n+\n+#define STRING_ASM_OP\t\t\"\\t.asciz\"\n+#define COMMON_ASM_OP\t\t\"\\t.common\"\n+#define SKIP_ASM_OP\t\t\"\\t.skip\"\n+#define UNALIGNED_INT_ASM_OP\t\"\\t.uaword\"\n+#define UNALIGNED_SHORT_ASM_OP\t\"\\t.uahalf\"\n+#define PUSHSECTION_ASM_OP\t\"\\t.pushsection\"\n+#define POPSECTION_ASM_OP\t\"\\t.popsection\"\n+\n+/* This is the format used to print the second operand of a .type pseudo-op\n+   for the Sparc/svr4 assembler.  */\n+\n #define TYPE_OPERAND_FMT      \"#%s\"\n \n-/* Define how the sparc registers should be numbered for Dwarf output.\n+/* This is the format used to print a .pushsection pseudo-op (and its operand)\n+   for the Sparc/svr4 assembler.  */\n+\n+#define PUSHSECTION_FORMAT\t\"%s\\t\\\"%s\\\"\\n\"\n+\n+/* This is how to equate one symbol to another symbol.  The syntax used is\n+   `SYM1=SYM2'.  Note that this is different from the way equates are done\n+   with most svr4 assemblers, where the syntax is `.set SYM1,SYM2'.  */\n+\n+#define ASM_OUTPUT_DEF(FILE,LABEL1,LABEL2)\t\t\t\t\\\n+ do {\tfprintf ((FILE), \"\\t\");\t\t\t\t\t\t\\\n+\tassemble_name (FILE, LABEL1);\t\t\t\t\t\\\n+\tfprintf (FILE, \" = \");\t\t\t\t\t\t\\\n+\tassemble_name (FILE, LABEL2);\t\t\t\t\t\\\n+\tfprintf (FILE, \"\\n\");\t\t\t\t\t\t\\\n+  } while (0)\n+\n+/* Generate the special assembly code needed to align the start of a jump\n+   tables.  Under svr4, jump tables go into the .rodata section.  Other\n+   things (e.g. constants) may be put into the .rodata section too, and\n+   those other things may end on odd (i.e. unaligned) boundaries, so we\n+   need to get re-aligned just before we output each jump table.  */\n+\n+#define ASM_OUTPUT_ALIGN_JUMP_TABLE(FILE) ASM_OUTPUT_ALIGN ((FILE), 2)\n+\n+/* This is how to output an internal numbered label where\n+   PREFIX is the class of label and NUM is the number within the class.\n+\n+   If the NUM argument is negative, we don't use it when generating the\n+   label.\n+\n+   For most svr4 systems, the convention is that any symbol which begins\n+   with a period is not put into the linker symbol table by the assembler,\n+   however the current Sparc/svr4 assembler is brain-dammaged and it needs\n+   to see `.L' at the start of a symbol or else it will be put into the\n+   linker symbol table.\n+*/\n+\n+#define ASM_OUTPUT_INTERNAL_LABEL(FILE, PREFIX, NUM)\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  if ((int) (NUM) >= 0)\t\t\t\t\t\t\t\\\n+    fprintf (FILE, \".L%s%d:\\n\", PREFIX, NUM);\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    fprintf (FILE, \".L%s:\\n\", PREFIX);\t\t\t\t\t\\\n+} while (0)\n+\n+/* This is how to store into the string LABEL\n+   the symbol_ref name of an internal numbered label where\n+   PREFIX is the class of label and NUM is the number within the class.\n+   This is suitable for output with `assemble_name'.\n+\n+   If the NUM argument is negative, we don't use it when generating the\n+   label.\n+\n+   For most svr4 systems, the convention is that any symbol which begins\n+   with a period is not put into the linker symbol table by the assembler,\n+   however the current Sparc/svr4 assembler is brain-dammaged and it needs\n+   to see `.L' at the start of a symbol or else it will be put into the\n+   linker symbol table.\n+*/\n+\n+#define ASM_GENERATE_INTERNAL_LABEL(LABEL, PREFIX, NUM)\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  if ((int) (NUM) >= 0)\t\t\t\t\t\t\t\\\n+    sprintf (LABEL, \"*.L%s%d\", PREFIX, NUM);\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    sprintf (LABEL, \"*.L%s\", PREFIX);\t\t\t\t\t\\\n+} while (0)\n+\n+/* Define how the Sparc registers should be numbered for Dwarf output.\n    The numbering provided here should be compatible with the native\n-   svr4 SDB debugger in the sparc/svr4 reference port.  */\n+   svr4 SDB debugger in the Sparc/svr4 reference port.  The numbering\n+   is as follows:\n+\n+   Assembly name\tgcc internal regno\tDwarf regno\n+   ----------------------------------------------------------\n+   g0-g7\t\t0-7\t\t\t0-7\n+   o0-o7\t\t8-15\t\t\t8-15\n+   l0-l7\t\t16-23\t\t\t16-23\n+   i0-i7\t\t24-31\t\t\t24-31\n+   f0-f31\t\t32-63\t\t\t40-71\n+*/\n \n #define DBX_REGISTER_NUMBER(REGNO)\t\t\t\t\t\\\n-  ((REGNO) < 32) ? (REGNO) : ((REGNO) + 8))\n+  (((REGNO) < 32) ? (REGNO)\t\t\t\t\t\t\\\n+   : ((REGNO) < 63) ? ((REGNO) + 8)\t\t\t\t\t\\\n+   : (abort (), 0))\n \n-/* A pair of defines for the set of pseudo-ops used to switch to the\n-   .ctors and .dtors sections.  Note that on the sparc, all user-defined\n-   sections have the \"progbits\" attribute by default, so we don't even\n-   specify it here.  */\n+/* A set of symbol definitions for assembly pseudo-ops which will\n+   get us switched to various sections of interest.  These are used\n+   in all places where we simply want to switch to a section, and\n+   *not* to push the previous section name onto the assembler's\n+   section names stack (as we do often in dwarfout.c).  */\n \n-#define CTORS_SECTION_ASM_OP    \"\\t.section\\t.ctors,\\\"a\\\"\"\n-#define DTORS_SECTION_ASM_OP    \"\\t.section\\t.dtors,\\\"a\\\"\"\n+#define TEXT_SECTION_ASM_OP\t\"\\t.section\\t\\\".text\\\"\"\n+#define DATA_SECTION_ASM_OP\t\"\\t.section\\t\\\".data\\\"\"\n+#define BSS_SECTION_ASM_OP\t\"\\t.section\\t\\\".bss\\\"\"\n+#define CONST_SECTION_ASM_OP\t\"\\t.section\\t\\\".rodata\\\"\"\n+#define INIT_SECTION_ASM_OP\t\"\\t.section\\t\\\".init\\\",#alloc\"\n+#define CTORS_SECTION_ASM_OP    \"\\t.section\\t\\\".ctors\\\",#alloc\"\n+#define DTORS_SECTION_ASM_OP    \"\\t.section\\t\\\".dtors\\\",#alloc\""}, {"sha": "a78c262e47372ca449d4b54f8e5154a87c6151b7", "filename": "gcc/expr.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19c3fc24838bf562b9c833738a37905aee90c692/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19c3fc24838bf562b9c833738a37905aee90c692/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=19c3fc24838bf562b9c833738a37905aee90c692", "patch": "@@ -320,6 +320,7 @@ extern optab abs_optab;\t\t/* Abs value */\n extern optab one_cmpl_optab;\t/* Bitwise not */\n extern optab ffs_optab;\t\t/* Find first bit set */\n extern optab sqrt_optab;\t/* Square root */\n+extern optab strlen_optab;\t/* String length root */\n \n /* Passed to expand_binop and expand_unop to say which options to try to use\n    if the requested operation can't be open-coded on the requisite mode."}, {"sha": "b1578531a5043dfd0e36a1b59ca261b7052877da", "filename": "gcc/optabs.c", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19c3fc24838bf562b9c833738a37905aee90c692/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19c3fc24838bf562b9c833738a37905aee90c692/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=19c3fc24838bf562b9c833738a37905aee90c692", "patch": "@@ -77,6 +77,8 @@ optab cmp_optab;\n optab ucmp_optab;  /* Used only for libcalls for unsigned comparisons.  */\n optab tst_optab;\n \n+optab strlen_optab;\n+\n /* SYMBOL_REF rtx's for the library functions that are called\n    implicitly and not via optabs.  */\n \n@@ -2831,6 +2833,7 @@ init_optabs ()\n   one_cmpl_optab = init_optab (NOT);\n   ffs_optab = init_optab (FFS);\n   sqrt_optab = init_optab (SQRT);\n+  strlen_optab = init_optab (UNKNOWN);\n \n #ifdef HAVE_addqi3\n   if (HAVE_addqi3)\n@@ -3716,6 +3719,33 @@ init_optabs ()\n   /* No library calls here!  If there is no sqrt instruction expand_builtin\n      should force the library call.  */\n \n+#ifdef HAVE_strlenqi\n+  if (HAVE_strlenqi)\n+    strlen_optab->handlers[(int) QImode].insn_code = CODE_FOR_strlenqi;\n+#endif\n+#ifdef HAVE_strlenhi\n+  if (HAVE_strlenhi)\n+    strlen_optab->handlers[(int) HImode].insn_code = CODE_FOR_strlenhi;\n+#endif\n+#ifdef HAVE_strlenpsi\n+  if (HAVE_strlenpsi)\n+    strlen_optab->handlers[(int) PSImode].insn_code = CODE_FOR_strlenpsi;\n+#endif\n+#ifdef HAVE_strlensi\n+  if (HAVE_strlensi)\n+    strlen_optab->handlers[(int) SImode].insn_code = CODE_FOR_strlensi;\n+#endif\n+#ifdef HAVE_strlendi\n+  if (HAVE_strlendi)\n+    strlen_optab->handlers[(int) DImode].insn_code = CODE_FOR_strlendi;\n+#endif\n+#ifdef HAVE_strlenti\n+  if (HAVE_strlenti)\n+    strlen_optab->handlers[(int) TImode].insn_code = CODE_FOR_strlenti;\n+#endif\n+  /* No library calls here!  If there is no strlen instruction expand_builtin\n+     should force the library call.  */\n+\n #ifdef HAVE_one_cmplqi2\n   if (HAVE_one_cmplqi2)\n     one_cmpl_optab->handlers[(int) QImode].insn_code = CODE_FOR_one_cmplqi2;"}]}