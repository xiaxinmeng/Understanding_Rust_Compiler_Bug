{"sha": "2674fa47de9ecfee5b04f753582fb23041029f40", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjY3NGZhNDdkZTllY2ZlZTViMDRmNzUzNTgyZmIyMzA0MTAyOWY0MA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2018-11-16T21:49:42Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2018-11-16T21:49:42Z"}, "message": "Implement P0479R5, [[likely]] and [[unlikely]].\n\n[[likely]] and [[unlikely]] are equivalent to the GNU hot/cold attributes,\nexcept that they can be applied to arbitrary statements as well as labels;\nthis is most likely to be useful for marking if/else branches as likely or\nunlikely.  Conveniently, PREDICT_EXPR fits the bill nicely as a\nrepresentation.\n\nI also had to fix marking case labels as hot/cold, which didn't work before.\nWhich then required me to force __attribute ((fallthrough)) to apply to the\nstatement rather than the label.\n\ngcc/\n\t* gimplify.c (gimplify_case_label_expr): Handle hot/cold attributes.\ngcc/c-family/\n\t* c-lex.c (c_common_has_attribute): Handle likely/unlikely.\n\t* c-attribs.c (attr_cold_hot_exclusions): Make public.\ngcc/cp/\n\t* tree.c (handle_likeliness_attribute): New.\n\t(std_attribute_table): Add likely/unlikely.\n\t* cp-gimplify.c (lookup_hotness_attribute, remove_hotness_attribute)\n\t(process_stmt_hotness_attribute, first_stmt): New.\n\t(genericize_if_stmt): Check for duplicate predictions.\n\t* parser.c (cp_parser_statement): Call\n\tprocess_stmt_hotness_attribute.\n\t(cp_parser_label_for_labeled_statement): Apply attributes to case.\n\t* decl.c (finish_case_label): Give label in template type void.\n\t* pt.c (tsubst_expr) [CASE_LABEL_EXPR]: Copy attributes.\n\t[PREDICT_EXPR]: Handle.\n\nFrom-SVN: r266223", "tree": {"sha": "1c43236aab7e94c52420d2456ea29ce3079f0857", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1c43236aab7e94c52420d2456ea29ce3079f0857"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2674fa47de9ecfee5b04f753582fb23041029f40", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2674fa47de9ecfee5b04f753582fb23041029f40", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2674fa47de9ecfee5b04f753582fb23041029f40", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2674fa47de9ecfee5b04f753582fb23041029f40/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a0a57b074f79dbe5e01745da9cfbd08a52fa8cfd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0a57b074f79dbe5e01745da9cfbd08a52fa8cfd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a0a57b074f79dbe5e01745da9cfbd08a52fa8cfd"}], "stats": {"total": 310, "additions": 296, "deletions": 14}, "files": [{"sha": "4b87c43a2ea4a5873c0cac14336d5873be34dfa3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2674fa47de9ecfee5b04f753582fb23041029f40/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2674fa47de9ecfee5b04f753582fb23041029f40/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2674fa47de9ecfee5b04f753582fb23041029f40", "patch": "@@ -1,3 +1,7 @@\n+2018-11-12  Jason Merrill  <jason@redhat.com>\n+\n+\t* gimplify.c (gimplify_case_label_expr): Handle hot/cold attributes.\n+\n 2018-11-16  Michael Meissner  <meissner@linux.ibm.com>\n \n \t* config/rs6000/constraints.md (wF constraint): Remove power9"}, {"sha": "db46542105101b8203ecd7a8486ed11d65d967d5", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2674fa47de9ecfee5b04f753582fb23041029f40/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2674fa47de9ecfee5b04f753582fb23041029f40/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=2674fa47de9ecfee5b04f753582fb23041029f40", "patch": "@@ -1,3 +1,8 @@\n+2018-11-16  Jason Merrill  <jason@redhat.com>\n+\n+\t* c-lex.c (c_common_has_attribute): Handle likely/unlikely.\n+\t* c-attribs.c (attr_cold_hot_exclusions): Make public.\n+\n 2018-11-16  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR middle-end/87854"}, {"sha": "88b24cd6cd49f14bfe24dc1f45c92ad4b702d48e", "filename": "gcc/c-family/c-attribs.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2674fa47de9ecfee5b04f753582fb23041029f40/gcc%2Fc-family%2Fc-attribs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2674fa47de9ecfee5b04f753582fb23041029f40/gcc%2Fc-family%2Fc-attribs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-attribs.c?ref=2674fa47de9ecfee5b04f753582fb23041029f40", "patch": "@@ -163,7 +163,7 @@ static const struct attribute_spec::exclusions attr_aligned_exclusions[] =\n   ATTR_EXCL (NULL, false, false, false)\n };\n \n-static const struct attribute_spec::exclusions attr_cold_hot_exclusions[] =\n+extern const struct attribute_spec::exclusions attr_cold_hot_exclusions[] =\n {\n   ATTR_EXCL (\"cold\", true, true, true),\n   ATTR_EXCL (\"hot\", true, true, true),"}, {"sha": "4aa614261142e4a6716cc7182fa731bc4bf586d8", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2674fa47de9ecfee5b04f753582fb23041029f40/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2674fa47de9ecfee5b04f753582fb23041029f40/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=2674fa47de9ecfee5b04f753582fb23041029f40", "patch": "@@ -1330,6 +1330,7 @@ extern int parse_tm_stmt_attr (tree, int);\n extern int tm_attr_to_mask (tree);\n extern tree tm_mask_to_attr (int);\n extern tree find_tm_attribute (tree);\n+extern const struct attribute_spec::exclusions attr_cold_hot_exclusions[];\n \n /* A bitmap of flags to positional_argument.  */\n enum posargflags {"}, {"sha": "93a6f1660c4cbe3a77166c74c70a8c1360e32ba5", "filename": "gcc/c-family/c-lex.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2674fa47de9ecfee5b04f753582fb23041029f40/gcc%2Fc-family%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2674fa47de9ecfee5b04f753582fb23041029f40/gcc%2Fc-family%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-lex.c?ref=2674fa47de9ecfee5b04f753582fb23041029f40", "patch": "@@ -356,7 +356,9 @@ c_common_has_attribute (cpp_reader *pfile)\n \t\t       || is_attribute_p (\"nodiscard\", attr_name)\n \t\t       || is_attribute_p (\"fallthrough\", attr_name))\n \t\tresult = 201603;\n-\t      else if (is_attribute_p (\"no_unique_address\", attr_name))\n+\t      else if (is_attribute_p (\"no_unique_address\", attr_name)\n+\t\t       || is_attribute_p (\"likely\", attr_name)\n+\t\t       || is_attribute_p (\"unlikely\", attr_name))\n \t\tresult = 201803;\n \t      if (result)\n \t\tattr_name = NULL_TREE;"}, {"sha": "d0a344eadcaf1ad35fde8705b2445a48be598d96", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2674fa47de9ecfee5b04f753582fb23041029f40/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2674fa47de9ecfee5b04f753582fb23041029f40/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=2674fa47de9ecfee5b04f753582fb23041029f40", "patch": "@@ -1,3 +1,18 @@\n+2018-11-16  Jason Merrill  <jason@redhat.com>\n+\n+\tImplement P0479R5, [[likely]] and [[unlikely]].\n+\t* tree.c (handle_likeliness_attribute): New.\n+\t(std_attribute_table): Add likely/unlikely.\n+\t* cp-gimplify.c (lookup_hotness_attribute, remove_hotness_attribute)\n+\t(process_stmt_hotness_attribute, first_stmt): New.\n+\t(genericize_if_stmt): Check for duplicate predictions.\n+\t* parser.c (cp_parser_statement): Call\n+\tprocess_stmt_hotness_attribute.\n+\t(cp_parser_label_for_labeled_statement): Apply attributes to case.\n+\t* decl.c (finish_case_label): Give label in template type void.\n+\t* pt.c (tsubst_expr) [CASE_LABEL_EXPR]: Copy attributes.\n+\t[PREDICT_EXPR]: Handle.\n+\n 2018-11-16  Nathan Sidwell  <nathan@acm.org>\n \n \tRemove ovl_used, it is no longer needed"}, {"sha": "5cb54adf60f96f944575d1753ee733016d227b3e", "filename": "gcc/cp/cp-gimplify.c", "status": "modified", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2674fa47de9ecfee5b04f753582fb23041029f40/gcc%2Fcp%2Fcp-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2674fa47de9ecfee5b04f753582fb23041029f40/gcc%2Fcp%2Fcp-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.c?ref=2674fa47de9ecfee5b04f753582fb23041029f40", "patch": "@@ -34,6 +34,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"stringpool.h\"\n #include \"attribs.h\"\n #include \"asan.h\"\n+#include \"gcc-rich-location.h\"\n \n /* Forward declarations.  */\n \n@@ -158,6 +159,26 @@ genericize_eh_spec_block (tree *stmt_p)\n   TREE_NO_WARNING (TREE_OPERAND (*stmt_p, 1)) = true;\n }\n \n+/* Return the first non-compound statement in STMT.  */\n+\n+tree\n+first_stmt (tree stmt)\n+{\n+  switch (TREE_CODE (stmt))\n+    {\n+    case STATEMENT_LIST:\n+      if (tree_statement_list_node *p = STATEMENT_LIST_HEAD (stmt))\n+\treturn first_stmt (p->stmt);\n+      return void_node;\n+\n+    case BIND_EXPR:\n+      return first_stmt (BIND_EXPR_BODY (stmt));\n+\n+    default:\n+      return stmt;\n+    }\n+}\n+\n /* Genericize an IF_STMT by turning it into a COND_EXPR.  */\n \n static void\n@@ -171,6 +192,24 @@ genericize_if_stmt (tree *stmt_p)\n   then_ = THEN_CLAUSE (stmt);\n   else_ = ELSE_CLAUSE (stmt);\n \n+  if (then_ && else_)\n+    {\n+      tree ft = first_stmt (then_);\n+      tree fe = first_stmt (else_);\n+      br_predictor pr;\n+      if (TREE_CODE (ft) == PREDICT_EXPR\n+\t  && TREE_CODE (fe) == PREDICT_EXPR\n+\t  && (pr = PREDICT_EXPR_PREDICTOR (ft)) == PREDICT_EXPR_PREDICTOR (fe)\n+\t  && (pr == PRED_HOT_LABEL || pr == PRED_COLD_LABEL))\n+\t{\n+\t  gcc_rich_location richloc (EXPR_LOC_OR_LOC (ft, locus));\n+\t  richloc.add_range (EXPR_LOC_OR_LOC (fe, locus));\n+\t  warning_at (&richloc, OPT_Wattributes,\n+\t\t      \"both branches of %<if%> statement marked as %qs\",\n+\t\t      predictor_name (pr));\n+\t}\n+    }\n+\n   if (!then_)\n     then_ = build_empty_stmt (locus);\n   if (!else_)\n@@ -2674,4 +2713,58 @@ cp_fold (tree x)\n   return x;\n }\n \n+/* Look up either \"hot\" or \"cold\" in attribute list LIST.  */\n+\n+tree\n+lookup_hotness_attribute (tree list)\n+{\n+  for (; list; list = TREE_CHAIN (list))\n+    {\n+      tree name = get_attribute_name (list);\n+      if (is_attribute_p (\"hot\", name)\n+\t  || is_attribute_p (\"cold\", name)\n+\t  || is_attribute_p (\"likely\", name)\n+\t  || is_attribute_p (\"unlikely\", name))\n+\tbreak;\n+    }\n+  return list;\n+}\n+\n+/* Remove both \"hot\" and \"cold\" attributes from LIST.  */\n+\n+static tree\n+remove_hotness_attribute (tree list)\n+{\n+  list = remove_attribute (\"hot\", list);\n+  list = remove_attribute (\"cold\", list);\n+  list = remove_attribute (\"likely\", list);\n+  list = remove_attribute (\"unlikely\", list);\n+  return list;\n+}\n+\n+/* If [[likely]] or [[unlikely]] appear on this statement, turn it into a\n+   PREDICT_EXPR.  */\n+\n+tree\n+process_stmt_hotness_attribute (tree std_attrs)\n+{\n+  if (std_attrs == error_mark_node)\n+    return std_attrs;\n+  if (tree attr = lookup_hotness_attribute (std_attrs))\n+    {\n+      tree name = get_attribute_name (attr);\n+      bool hot = (is_attribute_p (\"hot\", name)\n+\t\t  || is_attribute_p (\"likely\", name));\n+      tree pred = build_predict_expr (hot ? PRED_HOT_LABEL : PRED_COLD_LABEL,\n+\t\t\t\t      hot ? TAKEN : NOT_TAKEN);\n+      SET_EXPR_LOCATION (pred, input_location);\n+      add_stmt (pred);\n+      if (tree other = lookup_hotness_attribute (TREE_CHAIN (attr)))\n+\twarning (OPT_Wattributes, \"ignoring attribute %qE after earlier %qE\",\n+\t\t get_attribute_name (other), name);\n+      std_attrs = remove_hotness_attribute (std_attrs);\n+    }\n+  return std_attrs;\n+}\n+\n #include \"gt-cp-cp-gimplify.h\""}, {"sha": "edb94940098474198267b4fedf1d6a6db7ef8654", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2674fa47de9ecfee5b04f753582fb23041029f40/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2674fa47de9ecfee5b04f753582fb23041029f40/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=2674fa47de9ecfee5b04f753582fb23041029f40", "patch": "@@ -7541,6 +7541,8 @@ extern bool cxx_omp_disregard_value_expr\t(tree, bool);\n extern void cp_fold_function\t\t\t(tree);\n extern tree cp_fully_fold\t\t\t(tree);\n extern void clear_fold_cache\t\t\t(void);\n+extern tree lookup_hotness_attribute\t\t(tree);\n+extern tree process_stmt_hotness_attribute\t(tree);\n \n /* in name-lookup.c */\n extern tree strip_using_decl                    (tree);"}, {"sha": "1eee29e0d59852872387c381154f10c67d5275e2", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2674fa47de9ecfee5b04f753582fb23041029f40/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2674fa47de9ecfee5b04f753582fb23041029f40/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=2674fa47de9ecfee5b04f753582fb23041029f40", "patch": "@@ -3624,7 +3624,7 @@ finish_case_label (location_t loc, tree low_value, tree high_value)\n \n       /* For templates, just add the case label; we'll do semantic\n \t analysis at instantiation-time.  */\n-      label = build_decl (loc, LABEL_DECL, NULL_TREE, NULL_TREE);\n+      label = build_decl (loc, LABEL_DECL, NULL_TREE, void_type_node);\n       return add_stmt (build_case_label (low_value, high_value, label));\n     }\n "}, {"sha": "215c5fb9983287ef2899eb78a9c9294b1c42c4e8", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 33, "deletions": 8, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2674fa47de9ecfee5b04f753582fb23041029f40/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2674fa47de9ecfee5b04f753582fb23041029f40/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=2674fa47de9ecfee5b04f753582fb23041029f40", "patch": "@@ -10880,6 +10880,7 @@ cp_parser_statement (cp_parser* parser, tree in_statement_expr,\n   /* Peek at the next token.  */\n   token = cp_lexer_peek_token (parser->lexer);\n   /* Remember the location of the first token in the statement.  */\n+  cp_token *statement_token = token;\n   statement_location = token->location;\n   add_debug_begin_stmt (statement_location);\n   /* If this is a keyword, then that will often determine what kind of\n@@ -10901,19 +10902,22 @@ cp_parser_statement (cp_parser* parser, tree in_statement_expr,\n \n \tcase RID_IF:\n \tcase RID_SWITCH:\n+\t  std_attrs = process_stmt_hotness_attribute (std_attrs);\n \t  statement = cp_parser_selection_statement (parser, if_p, chain);\n \t  break;\n \n \tcase RID_WHILE:\n \tcase RID_DO:\n \tcase RID_FOR:\n+\t  std_attrs = process_stmt_hotness_attribute (std_attrs);\n \t  statement = cp_parser_iteration_statement (parser, if_p, false, 0);\n \t  break;\n \n \tcase RID_BREAK:\n \tcase RID_CONTINUE:\n \tcase RID_RETURN:\n \tcase RID_GOTO:\n+\t  std_attrs = process_stmt_hotness_attribute (std_attrs);\n \t  statement = cp_parser_jump_statement (parser);\n \t  break;\n \n@@ -10923,15 +10927,24 @@ cp_parser_statement (cp_parser* parser, tree in_statement_expr,\n \tcase RID_AT_FINALLY:\n \tcase RID_AT_SYNCHRONIZED:\n \tcase RID_AT_THROW:\n+\t  std_attrs = process_stmt_hotness_attribute (std_attrs);\n \t  statement = cp_parser_objc_statement (parser);\n \t  break;\n \n \tcase RID_TRY:\n+\t  std_attrs = process_stmt_hotness_attribute (std_attrs);\n \t  statement = cp_parser_try_block (parser);\n \t  break;\n \n \tcase RID_NAMESPACE:\n \t  /* This must be a namespace alias definition.  */\n+\t  if (std_attrs != NULL_TREE)\n+\t    {\n+\t      /*  Attributes should be parsed as part of the the\n+\t\t  declaration, so let's un-parse them.  */\n+\t      saved_tokens.rollback();\n+\t      std_attrs = NULL_TREE;\n+\t    }\n \t  cp_parser_declaration_statement (parser);\n \t  return;\n \t  \n@@ -10940,9 +10953,11 @@ cp_parser_statement (cp_parser* parser, tree in_statement_expr,\n \tcase RID_SYNCHRONIZED:\n \tcase RID_ATOMIC_NOEXCEPT:\n \tcase RID_ATOMIC_CANCEL:\n+\t  std_attrs = process_stmt_hotness_attribute (std_attrs);\n \t  statement = cp_parser_transaction (parser, token);\n \t  break;\n \tcase RID_TRANSACTION_CANCEL:\n+\t  std_attrs = process_stmt_hotness_attribute (std_attrs);\n \t  statement = cp_parser_transaction_cancel (parser);\n \t  break;\n \n@@ -11001,24 +11016,26 @@ cp_parser_statement (cp_parser* parser, tree in_statement_expr,\n       if (cp_lexer_next_token_is_not (parser->lexer, CPP_SEMICOLON))\n \t{\n \t  if (std_attrs != NULL_TREE)\n-\t    {\n-\t      /*  Attributes should be parsed as part of the the\n-\t\t  declaration, so let's un-parse them.  */\n-\t      saved_tokens.rollback();\n-\t      std_attrs = NULL_TREE;\n-\t    }\n+\t    /* Attributes should be parsed as part of the declaration,\n+\t       so let's un-parse them.  */\n+\t    saved_tokens.rollback();\n \n \t  cp_parser_parse_tentatively (parser);\n \t  /* Try to parse the declaration-statement.  */\n \t  cp_parser_declaration_statement (parser);\n \t  /* If that worked, we're done.  */\n \t  if (cp_parser_parse_definitely (parser))\n \t    return;\n+\t  /* It didn't work, restore the post-attribute position.  */\n+\t  if (std_attrs)\n+\t    cp_lexer_set_token_position (parser->lexer, statement_token);\n \t}\n       /* All preceding labels have been parsed at this point.  */\n       if (loc_after_labels != NULL)\n \t*loc_after_labels = statement_location;\n \n+      std_attrs = process_stmt_hotness_attribute (std_attrs);\n+\n       /* Look for an expression-statement instead.  */\n       statement = cp_parser_expression_statement (parser, in_statement_expr);\n \n@@ -11131,7 +11148,10 @@ cp_parser_label_for_labeled_statement (cp_parser* parser, tree attributes)\n \t  {\n \t    tree l = finish_case_label (token->location, expr, expr_hi);\n \t    if (l && TREE_CODE (l) == CASE_LABEL_EXPR)\n-\t      FALLTHROUGH_LABEL_P (CASE_LABEL (l)) = fallthrough_p;\n+\t      {\n+\t\tlabel = CASE_LABEL (l);\n+\t\tFALLTHROUGH_LABEL_P (label) = fallthrough_p;\n+\t      }\n \t  }\n \telse\n \t  error_at (token->location,\n@@ -11148,7 +11168,10 @@ cp_parser_label_for_labeled_statement (cp_parser* parser, tree attributes)\n \t{\n \t  tree l = finish_case_label (token->location, NULL_TREE, NULL_TREE);\n \t  if (l && TREE_CODE (l) == CASE_LABEL_EXPR)\n-\t    FALLTHROUGH_LABEL_P (CASE_LABEL (l)) = fallthrough_p;\n+\t      {\n+\t\tlabel = CASE_LABEL (l);\n+\t\tFALLTHROUGH_LABEL_P (label) = fallthrough_p;\n+\t      }\n \t}\n       else\n \terror_at (token->location, \"case label not within a switch statement\");\n@@ -11178,6 +11201,8 @@ cp_parser_label_for_labeled_statement (cp_parser* parser, tree attributes)\n       cp_parser_parse_tentatively (parser);\n       attrs = cp_parser_gnu_attributes_opt (parser);\n       if (attrs == NULL_TREE\n+\t  /* And fallthrough always binds to the expression-statement.  */\n+\t  || attribute_fallthrough_p (attrs)\n \t  || cp_lexer_next_token_is_not (parser->lexer, CPP_SEMICOLON))\n \tcp_parser_abort_tentative_parse (parser);\n       else if (!cp_parser_parse_definitely (parser))"}, {"sha": "a0d899f594b6cffa6462979d0852af7d9d8484ab", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2674fa47de9ecfee5b04f753582fb23041029f40/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2674fa47de9ecfee5b04f753582fb23041029f40/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=2674fa47de9ecfee5b04f753582fb23041029f40", "patch": "@@ -17175,12 +17175,17 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n \n     case CASE_LABEL_EXPR:\n       {\n+\ttree decl = CASE_LABEL (t);\n \ttree low = RECUR (CASE_LOW (t));\n \ttree high = RECUR (CASE_HIGH (t));\n \ttree l = finish_case_label (EXPR_LOCATION (t), low, high);\n \tif (l && TREE_CODE (l) == CASE_LABEL_EXPR)\n-\t  FALLTHROUGH_LABEL_P (CASE_LABEL (l))\n-\t    = FALLTHROUGH_LABEL_P (CASE_LABEL (t));\n+\t  {\n+\t    tree label = CASE_LABEL (l);\n+\t    FALLTHROUGH_LABEL_P (label) = FALLTHROUGH_LABEL_P (decl);\n+\t    if (DECL_ATTRIBUTES (decl) != NULL_TREE)\n+\t      cplus_decl_attributes (&label, DECL_ATTRIBUTES (decl), 0);\n+\t  }\n       }\n       break;\n \n@@ -17731,6 +17736,9 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n \t\t\t  RECUR (TREE_OPERAND (t, 1)),\n \t\t\t  RECUR (TREE_OPERAND (t, 2))));\n \n+    case PREDICT_EXPR:\n+      RETURN (add_stmt (copy_node (t)));\n+\n     default:\n       gcc_assert (!STATEMENT_CODE_P (TREE_CODE (t)));\n "}, {"sha": "97074dfab563a53611bab7d248cdef580d120308", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2674fa47de9ecfee5b04f753582fb23041029f40/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2674fa47de9ecfee5b04f753582fb23041029f40/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=2674fa47de9ecfee5b04f753582fb23041029f40", "patch": "@@ -4403,6 +4403,32 @@ handle_no_unique_addr_attribute (tree* node,\n   return NULL_TREE;\n }\n \n+/* The C++20 [[likely]] and [[unlikely]] attributes on labels map to the GNU\n+   hot/cold attributes.  */\n+\n+static tree\n+handle_likeliness_attribute (tree *node, tree name, tree args,\n+\t\t\t     int flags, bool *no_add_attrs)\n+{\n+  *no_add_attrs = true;\n+  if (TREE_CODE (*node) == LABEL_DECL\n+      || TREE_CODE (*node) == FUNCTION_DECL)\n+    {\n+      if (args)\n+\twarning (OPT_Wattributes, \"%qE attribute takes no arguments\", name);\n+      tree bname = (is_attribute_p (\"likely\", name)\n+\t\t    ? get_identifier (\"hot\") : get_identifier (\"cold\"));\n+      if (TREE_CODE (*node) == FUNCTION_DECL)\n+\twarning (OPT_Wattributes, \"ISO C++ %qE attribute does not apply to \"\n+\t\t \"functions; treating as %<[[gnu::%E]]%>\", name, bname);\n+      tree battr = build_tree_list (bname, NULL_TREE);\n+      decl_attributes (node, battr, flags);\n+      return NULL_TREE;\n+    }\n+  else\n+    return error_mark_node;\n+}\n+\n /* Table of valid C++ attributes.  */\n const struct attribute_spec cxx_attribute_table[] =\n {\n@@ -4426,6 +4452,10 @@ const struct attribute_spec std_attribute_table[] =\n     handle_nodiscard_attribute, NULL },\n   { \"no_unique_address\", 0, 0, true, false, false, false,\n     handle_no_unique_addr_attribute, NULL },\n+  { \"likely\", 0, 0, false, false, false, false,\n+    handle_likeliness_attribute, attr_cold_hot_exclusions },\n+  { \"unlikely\", 0, 0, false, false, false, false,\n+    handle_likeliness_attribute, attr_cold_hot_exclusions },\n   { NULL, 0, 0, false, false, false, false, NULL, NULL }\n };\n "}, {"sha": "40fbaa2c523177031e50993b5575f821cf519227", "filename": "gcc/gimplify.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2674fa47de9ecfee5b04f753582fb23041029f40/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2674fa47de9ecfee5b04f753582fb23041029f40/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=2674fa47de9ecfee5b04f753582fb23041029f40", "patch": "@@ -2511,11 +2511,19 @@ gimplify_case_label_expr (tree *expr_p, gimple_seq *pre_p)\n     if (ctxp->case_labels.exists ())\n       break;\n \n-  label_stmt = gimple_build_label (CASE_LABEL (*expr_p));\n+  tree label = CASE_LABEL (*expr_p);\n+  label_stmt = gimple_build_label (label);\n   gimple_set_location (label_stmt, EXPR_LOCATION (*expr_p));\n   ctxp->case_labels.safe_push (*expr_p);\n   gimplify_seq_add_stmt (pre_p, label_stmt);\n \n+  if (lookup_attribute (\"cold\", DECL_ATTRIBUTES (label)))\n+    gimple_seq_add_stmt (pre_p, gimple_build_predict (PRED_COLD_LABEL,\n+\t\t\t\t\t\t      NOT_TAKEN));\n+  else if (lookup_attribute (\"hot\", DECL_ATTRIBUTES (label)))\n+    gimple_seq_add_stmt (pre_p, gimple_build_predict (PRED_HOT_LABEL,\n+\t\t\t\t\t\t      TAKEN));\n+\n   return GS_ALL_DONE;\n }\n "}, {"sha": "43de249bd5af88bf1e7f4270273d9f5afc18f56c", "filename": "gcc/testsuite/g++.dg/cpp2a/attr-likely1.C", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2674fa47de9ecfee5b04f753582fb23041029f40/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fattr-likely1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2674fa47de9ecfee5b04f753582fb23041029f40/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fattr-likely1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fattr-likely1.C?ref=2674fa47de9ecfee5b04f753582fb23041029f40", "patch": "@@ -0,0 +1,38 @@\n+// { dg-do compile { target c++2a } }\n+// { dg-additional-options -fdump-tree-gimple }\n+// { dg-final { scan-tree-dump-times \"hot label\" 5 \"gimple\" } }\n+// { dg-final { scan-tree-dump-times \"cold label\" 3 \"gimple\" } }\n+\n+bool b;\n+\n+template <class T> int f()\n+{\n+  if (b)\n+    [[likely]] return 0;\n+  else\n+    [[unlikely]] flabel: return 1;\n+  switch (b)\n+    {\n+      [[likely]] case true: break;\n+    };\n+  return 1;\n+}\n+\n+int main()\n+{\n+  if (b)\n+    [[likely]] return 0;\n+  else if (b)\n+    [[unlikely]] elabel:\n+      return 1;\n+  else\n+    [[likely]] b = false;\n+\n+  f<int>();\n+\n+  switch (b)\n+    {\n+      [[likely]] case true: break;\n+      [[unlikely]] case false: break;\n+    };\n+}"}, {"sha": "6c59610528ebaa2e08e7f049fef5ac82f78c953e", "filename": "gcc/testsuite/g++.dg/cpp2a/attr-likely2.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2674fa47de9ecfee5b04f753582fb23041029f40/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fattr-likely2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2674fa47de9ecfee5b04f753582fb23041029f40/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fattr-likely2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fattr-likely2.C?ref=2674fa47de9ecfee5b04f753582fb23041029f40", "patch": "@@ -0,0 +1,12 @@\n+// { dg-do compile { target c++2a } }\n+\n+bool b;\n+int main()\n+{\n+  if (b)\n+    [[likely, likely]] b;\t// { dg-warning \"ignoring\" }\n+  else\n+    [[unlikely]] [[likely]] b;\t// { dg-warning \"ignoring\" }\n+\n+  [[likely, unlikely]] lab:;\t// { dg-warning \"ignoring\" }\n+}"}, {"sha": "bb1265ddb6e4f689883ffc593f6b185837d889f6", "filename": "gcc/testsuite/g++.dg/cpp2a/attr-likely3.C", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2674fa47de9ecfee5b04f753582fb23041029f40/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fattr-likely3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2674fa47de9ecfee5b04f753582fb23041029f40/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fattr-likely3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fattr-likely3.C?ref=2674fa47de9ecfee5b04f753582fb23041029f40", "patch": "@@ -0,0 +1,8 @@\n+// { dg-do compile { target c++2a } }\n+\n+[[likely]] void f() { }\t\t// { dg-warning \"function\" }\n+\n+int main()\n+{\n+  f();\n+}"}, {"sha": "bf0dc4c5d4eea552d67511b8ecfe25a3cec08953", "filename": "gcc/testsuite/g++.dg/cpp2a/attr-likely4.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2674fa47de9ecfee5b04f753582fb23041029f40/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fattr-likely4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2674fa47de9ecfee5b04f753582fb23041029f40/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fattr-likely4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fattr-likely4.C?ref=2674fa47de9ecfee5b04f753582fb23041029f40", "patch": "@@ -0,0 +1,19 @@\n+// { dg-do compile { target c++2a } }\n+\n+int a, b, c;\n+\n+void\n+__attribute__((noinline))\n+bar()\n+{\n+  if (a == 123)\n+    [[likely]] c = 5;\t\t// { dg-warning \"both\" }\n+  else\n+    [[likely]] b = 77;\n+}\n+\n+int main()\n+{\n+  bar ();\n+  return 0;\n+}"}, {"sha": "b80cc34236468ca72fc50cbaf432f6d5cacbbe00", "filename": "gcc/testsuite/g++.dg/cpp2a/feat-cxx2a.C", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2674fa47de9ecfee5b04f753582fb23041029f40/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Ffeat-cxx2a.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2674fa47de9ecfee5b04f753582fb23041029f40/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Ffeat-cxx2a.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Ffeat-cxx2a.C?ref=2674fa47de9ecfee5b04f753582fb23041029f40", "patch": "@@ -456,6 +456,18 @@\n #    error \"__has_cpp_attribute(no_unique_address) != 201803\"\n #  endif\n \n+#  if ! __has_cpp_attribute(likely)\n+#    error \"__has_cpp_attribute(likely)\"\n+#  elif __has_cpp_attribute(likely) != 201803\n+#    error \"__has_cpp_attribute(likely) != 201803\"\n+#  endif\n+\n+#  if ! __has_cpp_attribute(unlikely)\n+#    error \"__has_cpp_attribute(unlikely)\"\n+#  elif __has_cpp_attribute(unlikely) != 201803\n+#    error \"__has_cpp_attribute(unlikely) != 201803\"\n+#  endif\n+\n #else\n #  error \"__has_cpp_attribute\"\n #endif"}]}