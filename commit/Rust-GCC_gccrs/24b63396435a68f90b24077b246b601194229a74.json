{"sha": "24b63396435a68f90b24077b246b601194229a74", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjRiNjMzOTY0MzVhNjhmOTBiMjQwNzdiMjQ2YjYwMTE5NDIyOWE3NA==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1994-08-02T18:41:16Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1994-08-02T18:41:16Z"}, "message": "(enum reg_class): New values EXTRA_FP_REGS,\n\nGENERAL_OR_EXTRA_FP_REGS for the v9 case.\n(REG_CLASS_NAMES): Likewise.\n(REG_CLASS_CONTENTS): Likewise.\n(REGNO_REG_CLASS): Handle EXTRA_FP_REGS.\n(REG_CLASS_FROM_LETTER): Likewise, as `e'.\nTreat `e' like `f' in v8 case.\n(FP_REG_CLASS_P): New macro.\n(PREFERRED_RELOAD_CLASS): Use it.\n(SECONDARY_INPUT_RELOAD_CLASS, SECONDARY_OUTPUT_RELOAD_CLASS,\nSECONDARY_MEMORY_NEEDED, CLASS_MAX_NREGS, REGISTER_MOVE_COST):\nLikewise.\n\nFrom-SVN: r7848", "tree": {"sha": "5a5558bf9603a8e114dd1ab9905d247abdc8bc36", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5a5558bf9603a8e114dd1ab9905d247abdc8bc36"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/24b63396435a68f90b24077b246b601194229a74", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24b63396435a68f90b24077b246b601194229a74", "html_url": "https://github.com/Rust-GCC/gccrs/commit/24b63396435a68f90b24077b246b601194229a74", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24b63396435a68f90b24077b246b601194229a74/comments", "author": null, "committer": null, "parents": [{"sha": "26fe82a7ce9185937b251792f3b21d3671aa3c09", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26fe82a7ce9185937b251792f3b21d3671aa3c09", "html_url": "https://github.com/Rust-GCC/gccrs/commit/26fe82a7ce9185937b251792f3b21d3671aa3c09"}], "stats": {"total": 89, "additions": 62, "deletions": 27}, "files": [{"sha": "5d1d4b9776643445e07ef224950a1a95f4bec188", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 62, "deletions": 27, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24b63396435a68f90b24077b246b601194229a74/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24b63396435a68f90b24077b246b601194229a74/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=24b63396435a68f90b24077b246b601194229a74", "patch": "@@ -823,15 +823,35 @@ extern int leaf_function;\n    class that represents their union.  */\n \n /* The SPARC has two kinds of registers, general and floating point.\n+\n+   For v9 we must distinguish between the upper and lower floating point\n+   registers because the upper ones can't hold SFmode values.\n+   HARD_REGNO_MODE_OK won't help here because reload assumes that register(s)\n+   satisfying a group need for a class will also satisfy a single need for\n+   that class.  EXTRA_FP_REGS is a bit of a misnomer as it covers all 64 fp\n+   regs.\n+\n+   It is important that one class contains all the general and all the standard\n+   fp regs.  Otherwise find_reg() won't properly allocate int regs for moves,\n+   because reg_class_record() will bias the selection in favor of fp regs,\n+   because reg_class_subunion[GENERAL_REGS][FP_REGS] will yield FP_REGS,\n+   because FP_REGS > GENERAL_REGS.\n+\n+   It is also important that one class contain all the general and all the\n+   fp regs.  Otherwise when spilling a DFmode reg, it may be from EXTRA_FP_REGS\n+   but find_reloads() may use class GENERAL_OR_FP_REGS. This will cause\n+   allocate_reload_reg() to bypass it causing an abort because the compiler\n+   thinks it doesn't have a spill reg when in fact it does.\n+\n    v9 also has 4 floating point condition code registers.  Since we don't\n    have a class that is the union of FPCC_REGS with either of the others,\n    it is important that it appear first.  Otherwise the compiler will die\n    trying to compile _fixunsdfsi because fix_truncdfsi2 won't match its\n    constraints.  */\n-   /* ??? As an experiment for v9, we treat all fp regs similarily here.  */\n \n #ifdef SPARCV9\n-enum reg_class { NO_REGS, FPCC_REGS, GENERAL_REGS, FP_REGS, GENERAL_OR_FP_REGS,\n+enum reg_class { NO_REGS, FPCC_REGS, GENERAL_REGS, FP_REGS, EXTRA_FP_REGS,\n+\t\t GENERAL_OR_FP_REGS, GENERAL_OR_EXTRA_FP_REGS,\n \t\t ALL_REGS, LIM_REG_CLASSES };\n #else\n enum reg_class { NO_REGS, GENERAL_REGS, FP_REGS, ALL_REGS, LIM_REG_CLASSES };\n@@ -843,11 +863,11 @@ enum reg_class { NO_REGS, GENERAL_REGS, FP_REGS, ALL_REGS, LIM_REG_CLASSES };\n \n #ifdef SPARCV9\n #define REG_CLASS_NAMES \\\n-  {\"NO_REGS\", \"FPCC_REGS\", \"GENERAL_REGS\", \"FP_REGS\", \"GENERAL_OR_FP_REGS\", \\\n-   \"ALL_REGS\" }\n+  { \"NO_REGS\", \"FPCC_REGS\", \"GENERAL_REGS\", \"FP_REGS\", \"EXTRA_FP_REGS\", \\\n+    \"GENERAL_OR_FP_REGS\", \"GENERAL_OR_EXTRA_FP_REGS\", \"ALL_REGS\" }\n #else\n #define REG_CLASS_NAMES \\\n-  {\"NO_REGS\", \"GENERAL_REGS\", \"FP_REGS\", \"ALL_REGS\" }\n+  { \"NO_REGS\", \"GENERAL_REGS\", \"FP_REGS\", \"ALL_REGS\" }\n #endif\n \n /* Define which registers fit in which classes.\n@@ -856,8 +876,9 @@ enum reg_class { NO_REGS, GENERAL_REGS, FP_REGS, ALL_REGS, LIM_REG_CLASSES };\n \n #ifdef SPARCV9\n #define REG_CLASS_CONTENTS \\\n-  {{0, 0, 0, 0}, {0, 0, 0, 0xf}, {-2, 0, 0, 0}, {0, -1, -1, 0}, \\\n-   {-2, -1, -1, 0}, {-2, -1, -1, 0xf}}\n+  {{0, 0, 0, 0}, {0, 0, 0, 0xf}, {-2, 0, 0, 0}, \\\n+   {0, -1, 0, 0}, {0, -1, -1, 0}, {-2, -1, 0, 0}, {-2, -1, -1, 0}, \\\n+   {-2, -1, -1, 0xf}}\n #else\n #if 0 && defined (__GNUC__)\n #define REG_CLASS_CONTENTS {0LL, 0xfffffffeLL, 0xffffffff00000000LL, 0xfffffffffffffffeLL}\n@@ -872,11 +893,12 @@ enum reg_class { NO_REGS, GENERAL_REGS, FP_REGS, ALL_REGS, LIM_REG_CLASSES };\n    or could index an array.  */\n \n #ifdef SPARCV9\n-#define REGNO_REG_CLASS(REGNO)\t\t\t\t\\\n-  ((REGNO) == 0 ? NO_REGS\t\t\t\t\\\n-   : ((REGNO) < 32 ? GENERAL_REGS\t\t\t\\\n-      : ((REGNO) < 96 ? FP_REGS\t\t\t\t\\\n-\t : FPCC_REGS)))\n+#define REGNO_REG_CLASS(REGNO) \\\n+  ((REGNO) == 0 ? NO_REGS\t\t\\\n+   : (REGNO) < 32 ? GENERAL_REGS\t\\\n+   : (REGNO) < 64 ? FP_REGS\t\t\\\n+   : (REGNO) < 96 ? EXTRA_FP_REGS\t\\\n+   : FPCC_REGS)\n #else\n #define REGNO_REG_CLASS(REGNO) \\\n   ((REGNO) >= 32 ? FP_REGS : (REGNO) == 0 ? NO_REGS : GENERAL_REGS)\n@@ -995,14 +1017,26 @@ extern char leaf_reg_remap[];\n #define INDEX_REG_CLASS GENERAL_REGS\n #define BASE_REG_CLASS GENERAL_REGS\n \n+/* Local macro to handle the two v9 classes of FP regs.  */\n+#ifdef SPARCV9\n+#define FP_REG_CLASS_P(CLASS) ((CLASS) == FP_REGS || (CLASS) == EXTRA_FP_REGS)\n+#else\n+#define FP_REG_CLASS_P(CLASS) ((CLASS) == FP_REGS)\n+#endif\n+\n /* Get reg_class from a letter such as appears in the machine description.  */\n \n #ifdef SPARCV9\n #define REG_CLASS_FROM_LETTER(C) \\\n-  ((C) == 'f' ? FP_REGS : (C) == 'c' ? FPCC_REGS : NO_REGS)\n+  ((C) == 'f' ? FP_REGS\t\t\\\n+   : (C) == 'e' ? EXTRA_FP_REGS\t\\\n+   : (C) == 'c' ? FPCC_REGS\t\\\n+   : NO_REGS)\n #else\n+/* Coerce v9's 'e' class to 'f', so we can use 'e' in the .md file for\n+   v8 and v9.  */\n #define REG_CLASS_FROM_LETTER(C) \\\n-  ((C) == 'f' ? FP_REGS : NO_REGS)\n+  ((C) == 'f' ? FP_REGS : (C) == 'e' ? FP_REGS : NO_REGS)\n #endif\n \n /* The letters I, J, K, L and M in a register constraint string\n@@ -1040,7 +1074,7 @@ extern char leaf_reg_remap[];\n    if an 'E' constraint fails to match it.  */\n #define PREFERRED_RELOAD_CLASS(X,CLASS)\t\t\t\\\n   (CONSTANT_P (X)\t\t\t\t\t\\\n-   && ((CLASS) == FP_REGS\t\t\t\t\\\n+   && (FP_REG_CLASS_P (CLASS)\t\t\t\t\\\n        || (GET_MODE_CLASS (GET_MODE (X)) == MODE_FLOAT\t\\\n \t   && (HOST_FLOAT_FORMAT != IEEE_FLOAT_FORMAT\t\\\n \t       || HOST_BITS_PER_INT != BITS_PER_WORD)))\t\\\n@@ -1057,20 +1091,21 @@ extern char leaf_reg_remap[];\n    a paradoxical subreg in a float/fix conversion insn.  */\n \n #define SECONDARY_INPUT_RELOAD_CLASS(CLASS, MODE, IN)\t\t\\\n-  (((CLASS) == FP_REGS && ((MODE) == HImode || (MODE) == QImode)\\\n-      && (GET_CODE (IN) == MEM\t\t\t\t\t\\\n-\t  || ((GET_CODE (IN) == REG || GET_CODE (IN) == SUBREG)\t\\\n-\t      && true_regnum (IN) == -1))) ? GENERAL_REGS : NO_REGS)\n+  ((FP_REG_CLASS_P (CLASS) && ((MODE) == HImode || (MODE) == QImode) \\\n+    && (GET_CODE (IN) == MEM\t\t\t\t\t\\\n+\t|| ((GET_CODE (IN) == REG || GET_CODE (IN) == SUBREG)\t\\\n+\t    && true_regnum (IN) == -1))) ? GENERAL_REGS : NO_REGS)\n \n #define SECONDARY_OUTPUT_RELOAD_CLASS(CLASS, MODE, IN)\t\t\\\n-  ((CLASS) == FP_REGS && ((MODE) == HImode || (MODE) == QImode)\t\\\n-   && (GET_CODE (IN) == MEM\t\t\t\t\t\\\n-       || ((GET_CODE (IN) == REG || GET_CODE (IN) == SUBREG)\t\\\n-\t   && true_regnum (IN) == -1)) ? GENERAL_REGS : NO_REGS)\n+  ((FP_REG_CLASS_P (CLASS) && ((MODE) == HImode || (MODE) == QImode) \\\n+    && (GET_CODE (IN) == MEM\t\t\t\t\t\\\n+\t|| ((GET_CODE (IN) == REG || GET_CODE (IN) == SUBREG)\t\\\n+\t    && true_regnum (IN) == -1))) ? GENERAL_REGS : NO_REGS)\n \n /* On SPARC it is not possible to directly move data between \n    GENERAL_REGS and FP_REGS.  */\n-#define SECONDARY_MEMORY_NEEDED(CLASS1, CLASS2, MODE) ((CLASS1) != (CLASS2))\n+#define SECONDARY_MEMORY_NEEDED(CLASS1, CLASS2, MODE) \\\n+  (FP_REG_CLASS_P (CLASS1) != FP_REG_CLASS_P (CLASS2))\n \n /* Return the stack location to use for secondary memory needed reloads.\n    We want to use the reserved location just below the frame pointer.\n@@ -1098,7 +1133,7 @@ extern char leaf_reg_remap[];\n    needed to represent mode MODE in a register of class CLASS.  */\n /* On SPARC, this is the size of MODE in words.  */\n #define CLASS_MAX_NREGS(CLASS, MODE)\t\\\n-  ((CLASS) == FP_REGS ? (GET_MODE_SIZE (MODE) + 3) / 4 \\\n+  (FP_REG_CLASS_P (CLASS) ? (GET_MODE_SIZE (MODE) + 3) / 4 \\\n    : (GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n \f\n /* Stack layout; function entry, exit and calling.  */\n@@ -2118,8 +2153,8 @@ extern struct rtx_def *legitimize_pic_address ();\n    and another.\n    ??? v9: We ignore FPCC_REGS on the assumption they'll never be seen.  */\n #define REGISTER_MOVE_COST(CLASS1, CLASS2) \\\n-  (((CLASS1 == FP_REGS && CLASS2 == GENERAL_REGS) \\\n-    || (CLASS1 == GENERAL_REGS && CLASS2 == FP_REGS)) ? 6 : 2)\n+  (((FP_REG_CLASS_P (CLASS1) && (CLASS2) == GENERAL_REGS) \\\n+    || ((CLASS1) == GENERAL_REGS && FP_REG_CLASS_P (CLASS2))) ? 6 : 2)\n \n /* Provide the costs of a rtl expression.  This is in the body of a\n    switch on CODE.  The purpose for the cost of MULT is to encourage"}]}