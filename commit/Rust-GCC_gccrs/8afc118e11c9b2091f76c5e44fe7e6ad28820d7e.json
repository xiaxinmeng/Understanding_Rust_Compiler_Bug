{"sha": "8afc118e11c9b2091f76c5e44fe7e6ad28820d7e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGFmYzExOGUxMWM5YjIwOTFmNzZjNWU0NGZlN2U2YWQyODgyMGQ3ZQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2005-02-10T13:53:21Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-02-10T13:53:21Z"}, "message": "Fix for c330001 - PR ada/19386\n\n2005-02-09  Eric Botcazou  <ebotcazou@adacore.com>\n\t    Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n\n\tFix for c330001 - PR ada/19386\n\n\t* decl.c:\n\t(gnat_to_gnu_field): Do not necessarily invoke make_packable_type\n\ton the field if Pragma Component_Alignment (Storage_Unit).\n\t(gnat_to_gnu_entity, case object): Do not treat a renaming that has\n\tside-effects as if it were a constant; also make SAVE_EXPR to protect\n\tside-effects.\n\t(gnat_to_gnu_entity, case E_Record_Subtype): If have _Parent, make a\n\tUNION_TYPE.\n\t(make_dummy_type): Set TYPE_UNCHECKED_UNION_P.\n\t(components_to_record): Test it.\n\tFix improper usage of REFERENCE_CLASS_P.\n\n\t* utils2.c (build_binary_op, case MODIFY_EXPRP): Treat UNION_TYPE as\n\tRECORD_TYPE.\n\n\t* utils2.c: Minor reformatting.\n\n\t* utils.c (convert, case UNION_TYPE): Check TYPE_UNCHECKED_UNION;\n\thandle other cases like RECORD_TYPE.\n\n\t* utils.c (gnat_pushdecl): Set TREE_NO_WARNING.\n\nFrom-SVN: r94812", "tree": {"sha": "684c32a8daeae86786653d8ce917537a2c90db20", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/684c32a8daeae86786653d8ce917537a2c90db20"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8afc118e11c9b2091f76c5e44fe7e6ad28820d7e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8afc118e11c9b2091f76c5e44fe7e6ad28820d7e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8afc118e11c9b2091f76c5e44fe7e6ad28820d7e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8afc118e11c9b2091f76c5e44fe7e6ad28820d7e/comments", "author": null, "committer": null, "parents": [{"sha": "cc892b2c9128f71cf72f4fbad94d272d02562435", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc892b2c9128f71cf72f4fbad94d272d02562435", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc892b2c9128f71cf72f4fbad94d272d02562435"}], "stats": {"total": 122, "additions": 83, "deletions": 39}, "files": [{"sha": "6edda454a0c81742732112081b5368f52de76c9f", "filename": "gcc/ada/decl.c", "status": "modified", "additions": 43, "deletions": 16, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8afc118e11c9b2091f76c5e44fe7e6ad28820d7e/gcc%2Fada%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8afc118e11c9b2091f76c5e44fe7e6ad28820d7e/gcc%2Fada%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdecl.c?ref=8afc118e11c9b2091f76c5e44fe7e6ad28820d7e", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                          C Implementation File                           *\n  *                                                                          *\n- *          Copyright (C) 1992-2004, Free Software Foundation, Inc.         *\n+ *          Copyright (C) 1992-2005, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -748,6 +748,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t      }\n \n \t    if (const_flag\n+\t\t&& !TREE_SIDE_EFFECTS (gnu_expr)\n \t\t&& TREE_CODE (gnu_type) != UNCONSTRAINED_ARRAY_TYPE\n \t\t&& TYPE_MODE (gnu_type) != BLKmode\n \t\t&& Ekind (Etype (gnat_entity)) != E_Class_Wide_Type\n@@ -757,8 +758,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    /* If this is a declaration or reference that we can stabilize,\n \t       just use that declaration or reference as this entity unless\n \t       the latter has to be materialized.  */\n-\t    else if ((DECL_P (gnu_expr)\n-\t\t      || (REFERENCE_CLASS_P (gnu_expr) == tcc_reference))\n+\t    else if ((DECL_P (gnu_expr) || REFERENCE_CLASS_P (gnu_expr))\n \t\t     && !Materialize_Entity (gnat_entity)\n \t\t     && (!global_bindings_p ()\n \t\t\t || (staticp (gnu_expr)\n@@ -793,7 +793,15 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n \t\tif (!global_bindings_p ())\n \t\t  {\n+\t\t    bool has_side_effects = TREE_SIDE_EFFECTS (gnu_expr);\n+\n \t\t    gnu_expr = gnat_stabilize_reference (gnu_expr, true);\n+\n+\t\t    /* If the original expression had side effects, put a\n+\t\t       SAVE_EXPR around this whole thing.  */\n+\t\t    if (has_side_effects)\n+\t\t      gnu_expr = save_expr (gnu_expr);\n+\n \t\t    add_stmt (gnu_expr);\n \t\t  }\n \n@@ -2582,6 +2590,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t      tree gnu_subst_list\n \t\t= substitution_list (gnat_entity, gnat_base_type, NULL_TREE,\n \t\t\t\t     definition);\n+\t      bool possibly_overlapping_fields = false;\n \t      tree gnu_temp;\n \n \t      /* If this is a derived type, we may be seeing fields from any\n@@ -2598,12 +2607,24 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t       BIGGEST_ALIGNMENT);\n \n \t\t  if (Present (Parent_Subtype (gnat_root_type)))\n-\t\t    gnu_subst_list\n-\t\t      = substitution_list (Parent_Subtype (gnat_root_type),\n-\t\t\t\t\t   Empty, gnu_subst_list, definition);\n+\t\t    {\n+\t\t      gnu_subst_list\n+\t\t\t= substitution_list (Parent_Subtype (gnat_root_type),\n+\t\t\t\t\t     Empty, gnu_subst_list,\n+\t\t\t\t\t     definition);\n+\n+\t\t      /* If there's a _Parent field, it may overlap the\n+\t\t\t fields we have that appear to be in this record but\n+\t\t\t actually are from the parent.  So make note of that\n+\t\t\t fact and later we'll make a UNION_TYPE instead of\n+\t\t\t a RECORD_TYPE, since the latter may not have\n+\t\t\t overlapping fields.  */\n+\t\t      possibly_overlapping_fields = true;\n+\t\t    }\n \t\t}\n \n-\t      gnu_type = make_node (RECORD_TYPE);\n+\t      gnu_type = make_node (possibly_overlapping_fields\n+\t\t\t\t    ? UNION_TYPE : RECORD_TYPE);\n \t      TYPE_NAME (gnu_type) = gnu_entity_id;\n \t      TYPE_STUB_DECL (gnu_type)\n \t\t= create_type_decl (NULL_TREE, gnu_type, NULL, false, false,\n@@ -3163,10 +3184,10 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t      p->next = defer_incomplete_list;\n \t      defer_incomplete_list = p;\n \t    }\n-          else if\n-            (IN (Ekind (Base_Type (Directly_Designated_Type (gnat_entity))),\n-              Incomplete_Or_Private_Kind))\n-            { ;}\n+          else if (IN (Ekind (Base_Type\n+\t\t\t      (Directly_Designated_Type (gnat_entity))),\n+\t\t       Incomplete_Or_Private_Kind))\n+\t    ;\n \t  else\n \t    gnat_to_gnu_entity (Directly_Designated_Type (gnat_entity),\n \t\t\t\tNULL_TREE, 0);\n@@ -4372,9 +4393,13 @@ make_dummy_type (Entity_Id gnat_type)\n \n   /* If this is a record, make this a RECORD_TYPE or UNION_TYPE; else make\n      it a VOID_TYPE.  */\n-  if (Is_Record_Type (gnat_underlying))\n-    gnu_type = make_node (Is_Unchecked_Union (gnat_underlying)\n-\t\t\t  ? UNION_TYPE : RECORD_TYPE);\n+  if (Is_Unchecked_Union (gnat_underlying))\n+    {\n+      gnu_type = make_node (UNION_TYPE);\n+      TYPE_UNCHECKED_UNION_P (gnu_type) = 1;\n+    }\n+  else if (Is_Record_Type (gnat_underlying))\n+    gnu_type = make_node (RECORD_TYPE);\n   else\n     gnu_type = make_node (ENUMERAL_TYPE);\n \n@@ -5098,7 +5123,7 @@ gnat_to_gnu_field (Entity_Id gnat_field, tree gnu_record_type, int packed,\n       && TYPE_MODE (gnu_field_type) == BLKmode\n       && host_integerp (TYPE_SIZE (gnu_field_type), 1)\n       && compare_tree_int (TYPE_SIZE (gnu_field_type), BIGGEST_ALIGNMENT) <= 0\n-      && (packed\n+      && (packed == 1\n \t  || (gnu_size && tree_int_cst_lt (gnu_size,\n \t\t\t\t\t   TYPE_SIZE (gnu_field_type)))\n \t  || Present (Component_Clause (gnat_field))))\n@@ -5375,7 +5400,9 @@ components_to_record (tree gnu_record_type, Node_Id component_list,\n \n   /* If this is an unchecked union, each variant must have exactly one\n      component, each of which becomes one component of this union.  */\n-  if (TREE_CODE (gnu_record_type) == UNION_TYPE && Present (variant_part))\n+  if (TREE_CODE (gnu_record_type) == UNION_TYPE\n+      && TYPE_UNCHECKED_UNION_P (gnu_record_type)\n+      && Present (variant_part))\n     for (variant = First_Non_Pragma (Variants (variant_part));\n \t Present (variant);\n \t variant = Next_Non_Pragma (variant))"}, {"sha": "549c0935e6f4a426d5c6312ad94806cd3c7109ad", "filename": "gcc/ada/utils.c", "status": "modified", "additions": 28, "deletions": 17, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8afc118e11c9b2091f76c5e44fe7e6ad28820d7e/gcc%2Fada%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8afc118e11c9b2091f76c5e44fe7e6ad28820d7e/gcc%2Fada%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils.c?ref=8afc118e11c9b2091f76c5e44fe7e6ad28820d7e", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                          C Implementation File                           *\n  *                                                                          *\n- *          Copyright (C) 1992-2004, Free Software Foundation, Inc.         *\n+ *          Copyright (C) 1992-2005, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -309,7 +309,7 @@ insert_block (tree block)\n }\n \f\n /* Records a ..._DECL node DECL as belonging to the current lexical scope\n-   and uses GNAT_NODE for location information.  */\n+   and uses GNAT_NODE for location information and propagating flags.  */\n \n void\n gnat_pushdecl (tree decl, Node_Id gnat_node)\n@@ -321,6 +321,8 @@ gnat_pushdecl (tree decl, Node_Id gnat_node)\n   else\n     DECL_CONTEXT (decl) = current_function_decl;\n \n+  TREE_NO_WARNING (decl) = (gnat_node == Empty || Warnings_Off (gnat_node));\n+\n   /* Set the location of DECL and emit a declaration for it.  */\n   if (Present (gnat_node))\n     Sloc_to_locus (Sloc (gnat_node), &DECL_SOURCE_LOCATION (decl));\n@@ -1182,8 +1184,8 @@ create_type_decl (tree type_name, tree type, struct attrib *attr_list,\n       || !debug_info_p)\n     DECL_IGNORED_P (type_decl) = 1;\n   else if (code != ENUMERAL_TYPE && code != RECORD_TYPE\n-      && !((code == POINTER_TYPE || code == REFERENCE_TYPE)\n-\t   && TYPE_IS_DUMMY_P (TREE_TYPE (type))))\n+\t   && !((code == POINTER_TYPE || code == REFERENCE_TYPE)\n+\t\t&& TYPE_IS_DUMMY_P (TREE_TYPE (type))))\n     rest_of_decl_compilation (type_decl, global_bindings_p (), 0);\n \n   if (!TYPE_IS_DUMMY_P (type))\n@@ -2905,21 +2907,29 @@ convert (tree type, tree expr)\n       return unchecked_convert (type, expr, false);\n \n     case UNION_TYPE:\n-      /* Just validate that the type is indeed that of a field\n-\t of the type.  Then make the simple conversion.  */\n-      for (tem = TYPE_FIELDS (type); tem; tem = TREE_CHAIN (tem))\n+      /* For unchecked unions, just validate that the type is indeed that of\n+\t a field of the type.  Then make the simple conversion.  */\n+      if (TYPE_UNCHECKED_UNION_P (type))\n \t{\n-\t  if (TREE_TYPE (tem) == etype)\n-\t    return build1 (CONVERT_EXPR, type, expr);\n-\t  else if (TREE_CODE (TREE_TYPE (tem)) == RECORD_TYPE\n-\t\t   && (TYPE_JUSTIFIED_MODULAR_P (TREE_TYPE (tem))\n-\t\t       || TYPE_IS_PADDING_P (TREE_TYPE (tem)))\n-\t\t   && TREE_TYPE (TYPE_FIELDS (TREE_TYPE (tem))) == etype)\n-\t    return build1 (CONVERT_EXPR, type,\n-\t\t\t   convert (TREE_TYPE (tem), expr));\n-\t}\n+\t  for (tem = TYPE_FIELDS (type); tem; tem = TREE_CHAIN (tem))\n+\t    {\n+\t      if (TREE_TYPE (tem) == etype)\n+\t\treturn build1 (CONVERT_EXPR, type, expr);\n+\t      else if (TREE_CODE (TREE_TYPE (tem)) == RECORD_TYPE\n+\t\t       && (TYPE_JUSTIFIED_MODULAR_P (TREE_TYPE (tem))\n+\t\t\t   || TYPE_IS_PADDING_P (TREE_TYPE (tem)))\n+\t\t       && TREE_TYPE (TYPE_FIELDS (TREE_TYPE (tem))) == etype)\n+\t\treturn build1 (CONVERT_EXPR, type,\n+\t\t\t       convert (TREE_TYPE (tem), expr));\n+\t    }\n \n-      gcc_unreachable ();\n+\t  gcc_unreachable ();\n+\t}\n+      else\n+\t/* Otherwise, this is a conversion between a tagged type and some\n+\t   subtype, which we have to mark as a UNION_TYPE because of\n+\t   overlapping fields.  */\n+\treturn unchecked_convert (type, expr, false);\n \n     case UNCONSTRAINED_ARRAY_TYPE:\n       /* If EXPR is a constrained array, take its address, convert it to a\n@@ -3214,6 +3224,7 @@ unchecked_convert (tree type, tree expr, bool notrunc_p)\n /* Search the chain of currently reachable declarations for a builtin\n    FUNCTION_DECL node corresponding to function NAME (an IDENTIFIER_NODE).\n    Return the first node found, if any, or NULL_TREE otherwise.  */\n+\n tree\n builtin_decl_for (tree name __attribute__ ((unused)))\n {"}, {"sha": "008ac6e3ab2e057f4212739b0855fa1aa614ede3", "filename": "gcc/ada/utils2.c", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8afc118e11c9b2091f76c5e44fe7e6ad28820d7e/gcc%2Fada%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8afc118e11c9b2091f76c5e44fe7e6ad28820d7e/gcc%2Fada%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils2.c?ref=8afc118e11c9b2091f76c5e44fe7e6ad28820d7e", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                          C Implementation File                           *\n  *                                                                          *\n- *          Copyright (C) 1992-2004, Free Software Foundation, Inc.         *\n+ *          Copyright (C) 1992-2005, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -660,13 +660,16 @@ build_binary_op (enum tree_code op_code, tree result_type,\n \t might indicate a conversion between a root type and a class-wide\n \t type, which we must not remove.  */\n       while (TREE_CODE (right_operand) == VIEW_CONVERT_EXPR\n-\t     && ((TREE_CODE (right_type) == RECORD_TYPE\n+\t     && (((TREE_CODE (right_type) == RECORD_TYPE\n+\t\t   || TREE_CODE (right_type) == UNION_TYPE)\n \t\t  && !TYPE_JUSTIFIED_MODULAR_P (right_type)\n \t\t  && !TYPE_ALIGN_OK (right_type)\n \t\t  && !TYPE_IS_FAT_POINTER_P (right_type))\n \t\t || TREE_CODE (right_type) == ARRAY_TYPE)\n-\t     && (((TREE_CODE (TREE_TYPE (TREE_OPERAND (right_operand, 0)))\n-\t\t   == RECORD_TYPE)\n+\t     && ((((TREE_CODE (TREE_TYPE (TREE_OPERAND (right_operand, 0)))\n+\t\t    == RECORD_TYPE)\n+\t\t   || (TREE_CODE (TREE_TYPE (TREE_OPERAND (right_operand, 0)))\n+\t\t       == UNION_TYPE))\n \t\t  && !(TYPE_JUSTIFIED_MODULAR_P\n \t\t       (TREE_TYPE (TREE_OPERAND (right_operand, 0))))\n \t\t  && !(TYPE_ALIGN_OK\n@@ -695,7 +698,9 @@ build_binary_op (enum tree_code op_code, tree result_type,\n \toperation_type = best_type;\n \n       /* If a class-wide type may be involved, force use of the RHS type.  */\n-      if (TREE_CODE (right_type) == RECORD_TYPE && TYPE_ALIGN_OK (right_type))\n+      if ((TREE_CODE (right_type) == RECORD_TYPE\n+\t   || TREE_CODE (right_type) == UNION_TYPE)\n+\t  && TYPE_ALIGN_OK (right_type))\n \toperation_type = right_type;\n \n       /* Ensure everything on the LHS is valid.  If we have a field reference,\n@@ -1087,7 +1092,8 @@ build_unary_op (enum tree_code op_code, tree result_type, tree operand)\n \t      int unsignedp, volatilep;\n \n \t      inner = get_inner_reference (operand, &bitsize, &bitpos, &offset,\n-\t\t\t\t\t   &mode, &unsignedp, &volatilep, false);\n+\t\t\t\t\t   &mode, &unsignedp, &volatilep,\n+\t\t\t\t\t   false);\n \n \t      /* If INNER is a padding type whose field has a self-referential\n \t\t size, convert to that inner type.  We know the offset is zero"}]}