{"sha": "926d64906af2efc8714d37e6db2171784cfa60cd", "node_id": "C_kwDOANBUbNoAKDkyNmQ2NDkwNmFmMmVmYzg3MTRkMzdlNmRiMjE3MTc4NGNmYTYwY2Q", "commit": {"author": {"name": "Bill Schmidt", "email": "wschmidt@linux.ibm.com", "date": "2021-12-14T19:34:11Z"}, "committer": {"name": "Bill Schmidt", "email": "wschmidt@linux.ibm.com", "date": "2021-12-14T21:42:00Z"}, "message": "rs6000: Rename arrays to remove temporary _x suffix\n\nWhile we had two sets of built-in infrastructure at once, I added _x as a\nsuffix to two arrays to disambiguate the old and new versions.  Time to fix\nthat also.\n\n2021-12-06  Bill Schmidt  <wschmidt@linux.ibm.com>\n\ngcc/\n\t* config/rs6000/rs6000-c.c (altivec_build_resolved_builtin): Rename\n\trs6000_builtin_decls_x to rs6000_builtin_decls.\n\t(altivec_resolve_overloaded_builtin): Likewise.  Also rename\n\trs6000_builtin_info_x to rs6000_builtin_info.\n\t* config/rs6000/rs6000-call.c (rs6000_invalid_builtin): Rename\n\trs6000_builtin_info_x to rs6000_builtin_info.\n\t(rs6000_builtin_is_supported): Likewise.\n\t(rs6000_gimple_fold_mma_builtin): Likewise.  Also rename\n\trs6000_builtin_decls_x to rs6000_builtin_decls.\n\t(rs6000_gimple_fold_builtin): Rename rs6000_builtin_info_x to\n\trs6000_builtin_info.\n\t(cpu_expand_builtin): Likewise.\n\t(rs6000_expand_builtin): Likewise.\n\t(rs6000_init_builtins): Likewise.  Also rename rs6000_builtin_decls_x\n\tto rs6000_builtin_decls.\n\t(rs6000_builtin_decl): Rename rs6000_builtin_decls_x to\n\trs6000_builtin_decls.\n\t* config/rs6000/rs6000-gen-builtins.c (write_decls): In generated code,\n\trename rs6000_builtin_decls_x to rs6000_builtin_decls, and rename\n\trs6000_builtin_info_x to rs6000_builtin_info.\n\t(write_bif_static_init): In generated code, rename\n\trs6000_builtin_info_x to rs6000_builtin_info.\n\t(write_init_bif_table): In generated code, rename\n\trs6000_builtin_decls_x to rs6000_builtin_decls, and rename\n\trs6000_builtin_info_x to rs6000_builtin_info.\n\t(write_init_ovld_table): In generated code, rename\n\trs6000_builtin_decls_x to rs6000_builtin_decls.\n\t(write_init_file): Likewise.\n\t* config/rs6000/rs6000.c (rs6000_builtin_vectorized_function):\n\tLikewise.\n\t(rs6000_builtin_md_vectorized_function): Likewise.\n\t(rs6000_builtin_reciprocal): Likewise.\n\t(add_condition_to_bb): Likewise.\n\t(rs6000_atomic_assign_expand_fenv): Likewise.", "tree": {"sha": "82e52e7c6f97d63583ea337a4dd8711de5c89c79", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/82e52e7c6f97d63583ea337a4dd8711de5c89c79"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/926d64906af2efc8714d37e6db2171784cfa60cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/926d64906af2efc8714d37e6db2171784cfa60cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/926d64906af2efc8714d37e6db2171784cfa60cd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/926d64906af2efc8714d37e6db2171784cfa60cd/comments", "author": null, "committer": null, "parents": [{"sha": "d9421a8dcac385b882e4551ab3e52da38058b230", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9421a8dcac385b882e4551ab3e52da38058b230", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d9421a8dcac385b882e4551ab3e52da38058b230"}], "stats": {"total": 195, "additions": 96, "deletions": 99}, "files": [{"sha": "e0ebdeed548c1e161c9605394e719e9983a9be11", "filename": "gcc/config/rs6000/rs6000-c.c", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/926d64906af2efc8714d37e6db2171784cfa60cd/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/926d64906af2efc8714d37e6db2171784cfa60cd/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-c.c?ref=926d64906af2efc8714d37e6db2171784cfa60cd", "patch": "@@ -867,7 +867,7 @@ altivec_build_resolved_builtin (tree *args, int n, tree fntype, tree ret_type,\n {\n   tree argtypes = TYPE_ARG_TYPES (fntype);\n   tree arg_type[MAX_OVLD_ARGS];\n-  tree fndecl = rs6000_builtin_decls_x[bif_id];\n+  tree fndecl = rs6000_builtin_decls[bif_id];\n \n   for (int i = 0; i < n; i++)\n     {\n@@ -1001,13 +1001,13 @@ altivec_resolve_overloaded_builtin (location_t loc, tree fndecl,\n \t  case E_SFmode:\n \t    {\n \t      /* For floats use the xvmulsp instruction directly.  */\n-\t      tree call = rs6000_builtin_decls_x[RS6000_BIF_XVMULSP];\n+\t      tree call = rs6000_builtin_decls[RS6000_BIF_XVMULSP];\n \t      return build_call_expr (call, 2, arg0, arg1);\n \t    }\n \t  case E_DFmode:\n \t    {\n \t      /* For doubles use the xvmuldp instruction directly.  */\n-\t      tree call = rs6000_builtin_decls_x[RS6000_BIF_XVMULDP];\n+\t      tree call = rs6000_builtin_decls[RS6000_BIF_XVMULDP];\n \t      return build_call_expr (call, 2, arg0, arg1);\n \t    }\n \t  /* Other types are errors.  */\n@@ -1066,7 +1066,7 @@ altivec_resolve_overloaded_builtin (location_t loc, tree fndecl,\n \t\tvec_safe_push (params, arg0);\n \t\tvec_safe_push (params, arg1);\n \t\ttree call = altivec_resolve_overloaded_builtin\n-\t\t  (loc, rs6000_builtin_decls_x[RS6000_OVLD_VEC_CMPEQ],\n+\t\t  (loc, rs6000_builtin_decls[RS6000_OVLD_VEC_CMPEQ],\n \t\t   params);\n \t\t/* Use save_expr to ensure that operands used more than once\n \t\t   that may have side effects (like calls) are only evaluated\n@@ -1076,7 +1076,7 @@ altivec_resolve_overloaded_builtin (location_t loc, tree fndecl,\n \t\tvec_safe_push (params, call);\n \t\tvec_safe_push (params, call);\n \t\treturn altivec_resolve_overloaded_builtin\n-\t\t  (loc, rs6000_builtin_decls_x[RS6000_OVLD_VEC_NOR], params);\n+\t\t  (loc, rs6000_builtin_decls[RS6000_OVLD_VEC_NOR], params);\n \t      }\n \t      /* Other types are errors.  */\n \t    default:\n@@ -1129,9 +1129,9 @@ altivec_resolve_overloaded_builtin (location_t loc, tree fndecl,\n \t      vec_safe_push (params, arg1);\n \n \t      if (fcode == RS6000_OVLD_VEC_ADDE)\n-\t\tadd_sub_builtin = rs6000_builtin_decls_x[RS6000_OVLD_VEC_ADD];\n+\t\tadd_sub_builtin = rs6000_builtin_decls[RS6000_OVLD_VEC_ADD];\n \t      else\n-\t\tadd_sub_builtin = rs6000_builtin_decls_x[RS6000_OVLD_VEC_SUB];\n+\t\tadd_sub_builtin = rs6000_builtin_decls[RS6000_OVLD_VEC_SUB];\n \n \t      tree call\n \t\t= altivec_resolve_overloaded_builtin (loc, add_sub_builtin,\n@@ -1207,9 +1207,9 @@ altivec_resolve_overloaded_builtin (location_t loc, tree fndecl,\n \t    vec_safe_push (params, arg1);\n \n \t    if (fcode == RS6000_OVLD_VEC_ADDEC)\n-\t      as_c_builtin = rs6000_builtin_decls_x[RS6000_OVLD_VEC_ADDC];\n+\t      as_c_builtin = rs6000_builtin_decls[RS6000_OVLD_VEC_ADDC];\n \t    else\n-\t      as_c_builtin = rs6000_builtin_decls_x[RS6000_OVLD_VEC_SUBC];\n+\t      as_c_builtin = rs6000_builtin_decls[RS6000_OVLD_VEC_SUBC];\n \n \t    tree call1 = altivec_resolve_overloaded_builtin (loc, as_c_builtin,\n \t\t\t\t\t\t\t     params);\n@@ -1218,9 +1218,9 @@ altivec_resolve_overloaded_builtin (location_t loc, tree fndecl,\n \t    vec_safe_push (params, arg1);\n \n \t    if (fcode == RS6000_OVLD_VEC_ADDEC)\n-\t      as_builtin = rs6000_builtin_decls_x[RS6000_OVLD_VEC_ADD];\n+\t      as_builtin = rs6000_builtin_decls[RS6000_OVLD_VEC_ADD];\n \t    else\n-\t      as_builtin = rs6000_builtin_decls_x[RS6000_OVLD_VEC_SUB];\n+\t      as_builtin = rs6000_builtin_decls[RS6000_OVLD_VEC_SUB];\n \n \t    tree call2 = altivec_resolve_overloaded_builtin (loc, as_builtin,\n \t\t\t\t\t\t\t     params);\n@@ -1236,7 +1236,7 @@ altivec_resolve_overloaded_builtin (location_t loc, tree fndecl,\n \t    params = make_tree_vector ();\n \t    vec_safe_push (params, call1);\n \t    vec_safe_push (params, call2);\n-\t    tree or_builtin = rs6000_builtin_decls_x[RS6000_OVLD_VEC_OR];\n+\t    tree or_builtin = rs6000_builtin_decls[RS6000_OVLD_VEC_OR];\n \t    return altivec_resolve_overloaded_builtin (loc, or_builtin,\n \t\t\t\t\t\t       params);\n \t    }\n@@ -1380,34 +1380,34 @@ altivec_resolve_overloaded_builtin (location_t loc, tree fndecl,\n \t\t  break;\n \n \t\tcase E_V1TImode:\n-\t\t  call = rs6000_builtin_decls_x[RS6000_BIF_VEC_EXT_V1TI];\n+\t\t  call = rs6000_builtin_decls[RS6000_BIF_VEC_EXT_V1TI];\n \t\t  break;\n \n \t\tcase E_V2DFmode:\n-\t\t  call = rs6000_builtin_decls_x[RS6000_BIF_VEC_EXT_V2DF];\n+\t\t  call = rs6000_builtin_decls[RS6000_BIF_VEC_EXT_V2DF];\n \t\t  break;\n \n \t\tcase E_V2DImode:\n-\t\t  call = rs6000_builtin_decls_x[RS6000_BIF_VEC_EXT_V2DI];\n+\t\t  call = rs6000_builtin_decls[RS6000_BIF_VEC_EXT_V2DI];\n \t\t  break;\n \n \t\tcase E_V4SFmode:\n-\t\t  call = rs6000_builtin_decls_x[RS6000_BIF_VEC_EXT_V4SF];\n+\t\t  call = rs6000_builtin_decls[RS6000_BIF_VEC_EXT_V4SF];\n \t\t  break;\n \n \t\tcase E_V4SImode:\n \t\t  if (TARGET_DIRECT_MOVE_64BIT)\n-\t\t    call = rs6000_builtin_decls_x[RS6000_BIF_VEC_EXT_V4SI];\n+\t\t    call = rs6000_builtin_decls[RS6000_BIF_VEC_EXT_V4SI];\n \t\t  break;\n \n \t\tcase E_V8HImode:\n \t\t  if (TARGET_DIRECT_MOVE_64BIT)\n-\t\t    call = rs6000_builtin_decls_x[RS6000_BIF_VEC_EXT_V8HI];\n+\t\t    call = rs6000_builtin_decls[RS6000_BIF_VEC_EXT_V8HI];\n \t\t  break;\n \n \t\tcase E_V16QImode:\n \t\t  if (TARGET_DIRECT_MOVE_64BIT)\n-\t\t    call = rs6000_builtin_decls_x[RS6000_BIF_VEC_EXT_V16QI];\n+\t\t    call = rs6000_builtin_decls[RS6000_BIF_VEC_EXT_V16QI];\n \t\t  break;\n \t\t}\n \t    }\n@@ -1422,27 +1422,27 @@ altivec_resolve_overloaded_builtin (location_t loc, tree fndecl,\n \t\t  break;\n \n \t\tcase E_V2DFmode:\n-\t\t  call = rs6000_builtin_decls_x[RS6000_BIF_VEC_EXT_V2DF];\n+\t\t  call = rs6000_builtin_decls[RS6000_BIF_VEC_EXT_V2DF];\n \t\t  break;\n \n \t\tcase E_V2DImode:\n-\t\t  call = rs6000_builtin_decls_x[RS6000_BIF_VEC_EXT_V2DI];\n+\t\t  call = rs6000_builtin_decls[RS6000_BIF_VEC_EXT_V2DI];\n \t\t  break;\n \n \t\tcase E_V4SFmode:\n-\t\t  call = rs6000_builtin_decls_x[RS6000_BIF_VEC_EXT_V4SF];\n+\t\t  call = rs6000_builtin_decls[RS6000_BIF_VEC_EXT_V4SF];\n \t\t  break;\n \n \t\tcase E_V4SImode:\n-\t\t  call = rs6000_builtin_decls_x[RS6000_BIF_VEC_EXT_V4SI];\n+\t\t  call = rs6000_builtin_decls[RS6000_BIF_VEC_EXT_V4SI];\n \t\t  break;\n \n \t\tcase E_V8HImode:\n-\t\t  call = rs6000_builtin_decls_x[RS6000_BIF_VEC_EXT_V8HI];\n+\t\t  call = rs6000_builtin_decls[RS6000_BIF_VEC_EXT_V8HI];\n \t\t  break;\n \n \t\tcase E_V16QImode:\n-\t\t  call = rs6000_builtin_decls_x[RS6000_BIF_VEC_EXT_V16QI];\n+\t\t  call = rs6000_builtin_decls[RS6000_BIF_VEC_EXT_V16QI];\n \t\t  break;\n \t\t}\n \t    }\n@@ -1542,9 +1542,9 @@ altivec_resolve_overloaded_builtin (location_t loc, tree fndecl,\n \n \t  arg2 = wide_int_to_tree (TREE_TYPE (arg2), selector);\n \t  if (mode == V2DFmode)\n-\t    call = rs6000_builtin_decls_x[RS6000_BIF_VEC_SET_V2DF];\n+\t    call = rs6000_builtin_decls[RS6000_BIF_VEC_SET_V2DF];\n \t  else if (mode == V2DImode)\n-\t    call = rs6000_builtin_decls_x[RS6000_BIF_VEC_SET_V2DI];\n+\t    call = rs6000_builtin_decls[RS6000_BIF_VEC_SET_V2DI];\n \n \t  /* Note, __builtin_vec_insert_<xxx> has vector and scalar types\n \t     reversed.  */\n@@ -1554,7 +1554,7 @@ altivec_resolve_overloaded_builtin (location_t loc, tree fndecl,\n       else if (mode == V1TImode && VECTOR_UNIT_VSX_P (mode)\n \t       && TREE_CODE (arg2) == INTEGER_CST)\n \t{\n-\t  tree call = rs6000_builtin_decls_x[RS6000_BIF_VEC_SET_V1TI];\n+\t  tree call = rs6000_builtin_decls[RS6000_BIF_VEC_SET_V1TI];\n \t  wide_int selector = wi::zero(32);\n \n \t  arg2 = wide_int_to_tree (TREE_TYPE (arg2), selector);\n@@ -1740,7 +1740,7 @@ altivec_resolve_overloaded_builtin (location_t loc, tree fndecl,\n \t  instance = instance->next;\n \n \tgcc_assert (instance != NULL);\n-\ttree fntype = rs6000_builtin_info_x[instance->bifid].fntype;\n+\ttree fntype = rs6000_builtin_info[instance->bifid].fntype;\n \ttree parmtype0 = TREE_VALUE (TYPE_ARG_TYPES (fntype));\n \ttree parmtype1 = TREE_VALUE (TREE_CHAIN (TYPE_ARG_TYPES (fntype)));\n \n@@ -1798,7 +1798,7 @@ altivec_resolve_overloaded_builtin (location_t loc, tree fndecl,\n \t  instance = instance->next;\n \n \tgcc_assert (instance != NULL);\n-\ttree fntype = rs6000_builtin_info_x[instance->bifid].fntype;\n+\ttree fntype = rs6000_builtin_info[instance->bifid].fntype;\n \ttree parmtype0 = TREE_VALUE (TYPE_ARG_TYPES (fntype));\n \ttree parmtype1 = TREE_VALUE (TREE_CHAIN (TYPE_ARG_TYPES (fntype)));\n \n@@ -1849,7 +1849,7 @@ altivec_resolve_overloaded_builtin (location_t loc, tree fndecl,\n \t    if (rs6000_builtin_decl (instance->bifid, false) != error_mark_node\n \t\t&& supported)\n \t      {\n-\t\ttree fntype = rs6000_builtin_info_x[instance->bifid].fntype;\n+\t\ttree fntype = rs6000_builtin_info[instance->bifid].fntype;\n \t\ttree ret_type = TREE_TYPE (instance->fntype);\n \t\treturn altivec_build_resolved_builtin (args, n, fntype,\n \t\t\t\t\t\t       ret_type,\n@@ -1876,7 +1876,7 @@ altivec_resolve_overloaded_builtin (location_t loc, tree fndecl,\n \t    /* Provide clarity of the relationship between the overload\n \t       and the instantiation.  */\n \t    const char *internal_name\n-\t      = rs6000_builtin_info_x[instance->bifid].bifname;\n+\t      = rs6000_builtin_info[instance->bifid].bifname;\n \t    rich_location richloc (line_table, input_location);\n \t    inform (&richloc,\n \t\t    \"overloaded builtin %qs is implemented by builtin %qs\","}, {"sha": "b98f4a4c97f7f17cc2f3a5b51dc204d4c3bf7e5d", "filename": "gcc/config/rs6000/rs6000-call.c", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/926d64906af2efc8714d37e6db2171784cfa60cd/gcc%2Fconfig%2Frs6000%2Frs6000-call.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/926d64906af2efc8714d37e6db2171784cfa60cd/gcc%2Fconfig%2Frs6000%2Frs6000-call.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-call.c?ref=926d64906af2efc8714d37e6db2171784cfa60cd", "patch": "@@ -3258,9 +3258,9 @@ void\n rs6000_invalid_builtin (enum rs6000_gen_builtins fncode)\n {\n   size_t j = (size_t) fncode;\n-  const char *name = rs6000_builtin_info_x[j].bifname;\n+  const char *name = rs6000_builtin_info[j].bifname;\n \n-  switch (rs6000_builtin_info_x[j].enable)\n+  switch (rs6000_builtin_info[j].enable)\n     {\n     case ENB_P5:\n       error (\"%qs requires the %qs option\", name, \"-mcpu=power5\");\n@@ -3510,7 +3510,7 @@ rs6000_builtin_valid_without_lhs (enum rs6000_gen_builtins fn_code,\n bool\n rs6000_builtin_is_supported (enum rs6000_gen_builtins fncode)\n {\n-  switch (rs6000_builtin_info_x[(size_t) fncode].enable)\n+  switch (rs6000_builtin_info[(size_t) fncode].enable)\n     {\n     case ENB_ALWAYS:\n       return true;\n@@ -3570,18 +3570,18 @@ rs6000_gimple_fold_mma_builtin (gimple_stmt_iterator *gsi,\n   gimple *stmt = gsi_stmt (*gsi);\n   size_t fncode = (size_t) fn_code;\n \n-  if (!bif_is_mma (rs6000_builtin_info_x[fncode]))\n+  if (!bif_is_mma (rs6000_builtin_info[fncode]))\n     return false;\n \n   /* Each call that can be gimple-expanded has an associated built-in\n      function that it will expand into.  If this one doesn't, we have\n      already expanded it!  Exceptions: lxvp and stxvp.  */\n-  if (rs6000_builtin_info_x[fncode].assoc_bif == RS6000_BIF_NONE\n+  if (rs6000_builtin_info[fncode].assoc_bif == RS6000_BIF_NONE\n       && fncode != RS6000_BIF_LXVP\n       && fncode != RS6000_BIF_STXVP)\n     return false;\n \n-  bifdata *bd = &rs6000_builtin_info_x[fncode];\n+  bifdata *bd = &rs6000_builtin_info[fncode];\n   unsigned nopnds = bd->nargs;\n   gimple_seq new_seq = NULL;\n   gimple *new_call;\n@@ -3626,7 +3626,7 @@ rs6000_gimple_fold_mma_builtin (gimple_stmt_iterator *gsi,\n \t to emit a xxmfacc instruction now, since we cannot do it later.  */\n       if (fncode == RS6000_BIF_DISASSEMBLE_ACC)\n \t{\n-\t  new_decl = rs6000_builtin_decls_x[RS6000_BIF_XXMFACC_INTERNAL];\n+\t  new_decl = rs6000_builtin_decls[RS6000_BIF_XXMFACC_INTERNAL];\n \t  new_call = gimple_build_call (new_decl, 1, src);\n \t  src = create_tmp_reg_or_ssa_name (vector_quad_type_node);\n \t  gimple_call_set_lhs (new_call, src);\n@@ -3635,7 +3635,7 @@ rs6000_gimple_fold_mma_builtin (gimple_stmt_iterator *gsi,\n \n       /* Copy the accumulator/pair vector by vector.  */\n       new_decl\n-\t= rs6000_builtin_decls_x[rs6000_builtin_info_x[fncode].assoc_bif];\n+\t= rs6000_builtin_decls[rs6000_builtin_info[fncode].assoc_bif];\n       tree dst_type = build_pointer_type_for_mode (unsigned_V16QI_type_node,\n \t\t\t\t\t\t   ptr_mode, true);\n       tree dst_base = build1 (VIEW_CONVERT_EXPR, dst_type, dst_ptr);\n@@ -3693,7 +3693,7 @@ rs6000_gimple_fold_mma_builtin (gimple_stmt_iterator *gsi,\n \n   /* Convert this built-in into an internal version that uses pass-by-value\n      arguments.  The internal built-in is found in the assoc_bif field.  */\n-  new_decl = rs6000_builtin_decls_x[rs6000_builtin_info_x[fncode].assoc_bif];\n+  new_decl = rs6000_builtin_decls[rs6000_builtin_info[fncode].assoc_bif];\n   tree lhs, op[MAX_MMA_OPERANDS];\n   tree acc = gimple_call_arg (stmt, 0);\n   push_gimplify_context (true);\n@@ -3777,8 +3777,8 @@ rs6000_gimple_fold_builtin (gimple_stmt_iterator *gsi)\n   gimple *g;\n \n   size_t uns_fncode = (size_t) fn_code;\n-  enum insn_code icode = rs6000_builtin_info_x[uns_fncode].icode;\n-  const char *fn_name1 = rs6000_builtin_info_x[uns_fncode].bifname;\n+  enum insn_code icode = rs6000_builtin_info[uns_fncode].icode;\n+  const char *fn_name1 = rs6000_builtin_info[uns_fncode].bifname;\n   const char *fn_name2 = (icode != CODE_FOR_nothing)\n \t\t\t  ? get_insn_name ((int) icode)\n \t\t\t  : \"nothing\";\n@@ -4801,7 +4801,7 @@ cpu_expand_builtin (enum rs6000_gen_builtins fcode,\n   if (TREE_CODE (arg) != STRING_CST)\n     {\n       error (\"builtin %qs only accepts a string argument\",\n-\t     rs6000_builtin_info_x[(size_t) fcode].bifname);\n+\t     rs6000_builtin_info[(size_t) fcode].bifname);\n       return const0_rtx;\n     }\n \n@@ -4820,7 +4820,7 @@ cpu_expand_builtin (enum rs6000_gen_builtins fcode,\n \t{\n \t  /* Invalid CPU argument.  */\n \t  error (\"cpu %qs is an invalid argument to builtin %qs\",\n-\t\t cpu, rs6000_builtin_info_x[(size_t) fcode].bifname);\n+\t\t cpu, rs6000_builtin_info[(size_t) fcode].bifname);\n \t  return const0_rtx;\n \t}\n \n@@ -4849,7 +4849,7 @@ cpu_expand_builtin (enum rs6000_gen_builtins fcode,\n \t  /* Invalid HWCAP argument.  */\n \t  error (\"%s %qs is an invalid argument to builtin %qs\",\n \t\t \"hwcap\", hwcap,\n-\t\t rs6000_builtin_info_x[(size_t) fcode].bifname);\n+\t\t rs6000_builtin_info[(size_t) fcode].bifname);\n \t  return const0_rtx;\n \t}\n \n@@ -4877,7 +4877,7 @@ cpu_expand_builtin (enum rs6000_gen_builtins fcode,\n \n #else\n   warning (0, \"builtin %qs needs GLIBC (2.23 and newer) that exports hardware \"\n-\t   \"capability bits\", rs6000_builtin_info_x[(size_t) fcode].bifname);\n+\t   \"capability bits\", rs6000_builtin_info[(size_t) fcode].bifname);\n \n   /* For old LIBCs, always return FALSE.  */\n   emit_move_insn (target, GEN_INT (0));\n@@ -5479,7 +5479,7 @@ rs6000_expand_builtin (tree exp, rtx target, rtx /* subtarget */,\n   enum rs6000_gen_builtins fcode\n     = (enum rs6000_gen_builtins) DECL_MD_FUNCTION_CODE (fndecl);\n   size_t uns_fcode = (size_t)fcode;\n-  enum insn_code icode = rs6000_builtin_info_x[uns_fcode].icode;\n+  enum insn_code icode = rs6000_builtin_info[uns_fcode].icode;\n \n   /* TODO: The following commentary and code is inherited from the original\n      builtin processing code.  The commentary is a bit confusing, with the\n@@ -5557,7 +5557,7 @@ rs6000_expand_builtin (tree exp, rtx target, rtx /* subtarget */,\n   /* In case of \"#pragma target\" changes, we initialize all builtins\n      but check for actual availability now, during expand time.  For\n      invalid builtins, generate a normal call.  */\n-  bifdata *bifaddr = &rs6000_builtin_info_x[uns_fcode];\n+  bifdata *bifaddr = &rs6000_builtin_info[uns_fcode];\n   bif_enable e = bifaddr->enable;\n \n   if (!(e == ENB_ALWAYS\n@@ -6267,7 +6267,7 @@ rs6000_init_builtins (void)\n       fprintf (stderr, \"\\nAutogenerated built-in functions:\\n\\n\");\n       for (int i = 1; i < (int) RS6000_BIF_MAX; i++)\n \t{\n-\t  bif_enable e = rs6000_builtin_info_x[i].enable;\n+\t  bif_enable e = rs6000_builtin_info[i].enable;\n \t  if (e == ENB_P5 && !TARGET_POPCNTB)\n \t    continue;\n \t  if (e == ENB_P6 && !TARGET_CMPB)\n@@ -6306,10 +6306,10 @@ rs6000_init_builtins (void)\n \t    continue;\n \t  if (e == ENB_MMA && !TARGET_MMA)\n \t    continue;\n-\t  tree fntype = rs6000_builtin_info_x[i].fntype;\n+\t  tree fntype = rs6000_builtin_info[i].fntype;\n \t  tree t = TREE_TYPE (fntype);\n \t  fprintf (stderr, \"%s %s (\", rs6000_type_string (t),\n-\t\t   rs6000_builtin_info_x[i].bifname);\n+\t\t   rs6000_builtin_info[i].bifname);\n \t  t = TYPE_ARG_TYPES (fntype);\n \t  while (t && TREE_VALUE (t) != void_type_node)\n \t    {\n@@ -6320,7 +6320,7 @@ rs6000_init_builtins (void)\n \t\tfprintf (stderr, \", \");\n \t    }\n \t  fprintf (stderr, \"); %s [%4d]\\n\",\n-\t\t   rs6000_builtin_info_x[i].attr_string, (int) i);\n+\t\t   rs6000_builtin_info[i].attr_string, (int) i);\n \t}\n       fprintf (stderr, \"\\nEnd autogenerated built-in functions.\\n\\n\\n\");\n      }\n@@ -6349,7 +6349,7 @@ rs6000_init_builtins (void)\n     }\n \n   altivec_builtin_mask_for_load\n-    = rs6000_builtin_decls_x[RS6000_BIF_MASK_FOR_LOAD];\n+    = rs6000_builtin_decls[RS6000_BIF_MASK_FOR_LOAD];\n \n #ifdef SUBTARGET_INIT_BUILTINS\n   SUBTARGET_INIT_BUILTINS;\n@@ -6366,7 +6366,7 @@ rs6000_builtin_decl (unsigned code, bool /* initialize_p */)\n   if (fcode >= RS6000_OVLD_MAX)\n     return error_mark_node;\n \n-  return rs6000_builtin_decls_x[code];\n+  return rs6000_builtin_decls[code];\n }\n \n /* Return the internal arg pointer used for function incoming"}, {"sha": "c6ddbc68398d2b5d8112fcde270271da01856755", "filename": "gcc/config/rs6000/rs6000-gen-builtins.c", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/926d64906af2efc8714d37e6db2171784cfa60cd/gcc%2Fconfig%2Frs6000%2Frs6000-gen-builtins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/926d64906af2efc8714d37e6db2171784cfa60cd/gcc%2Fconfig%2Frs6000%2Frs6000-gen-builtins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-gen-builtins.c?ref=926d64906af2efc8714d37e6db2171784cfa60cd", "patch": "@@ -2212,7 +2212,7 @@ write_decls (void)\n   fprintf (header_file, \"  RS6000_OVLD_MAX\\n};\\n\\n\");\n \n   fprintf (header_file,\n-\t   \"extern GTY(()) tree rs6000_builtin_decls_x[RS6000_OVLD_MAX];\\n\\n\");\n+\t   \"extern GTY(()) tree rs6000_builtin_decls[RS6000_OVLD_MAX];\\n\\n\");\n \n   fprintf (header_file,\n \t   \"enum rs6000_ovld_instances\\n{\\n  RS6000_INST_NONE,\\n\");\n@@ -2343,17 +2343,14 @@ write_decls (void)\n \t   \"#define bif_is_ibmld(x)\\t((x).bifattrs & bif_ibmld_bit)\\n\");\n   fprintf (header_file, \"\\n\");\n \n-  /* #### Note that the _x is added for now to avoid conflict with\n-     the existing rs6000_builtin_info[] file while testing.  It will\n-     be removed as we progress.  */\n   /* #### Cannot mark this as a GC root because only pointer types can\n      be marked as GTY((user)) and be GC roots.  All trees in here are\n      kept alive by other globals, so not a big deal.  Alternatively,\n      we could change the enum fields to ints and cast them in and out\n      to avoid requiring a GTY((user)) designation, but that seems\n      unnecessarily gross.  */\n   fprintf (header_file,\n-\t   \"extern bifdata rs6000_builtin_info_x[RS6000_BIF_MAX];\\n\\n\");\n+\t   \"extern bifdata rs6000_builtin_info[RS6000_BIF_MAX];\\n\\n\");\n \n   fprintf (header_file, \"struct GTY((user)) ovlddata\\n\");\n   fprintf (header_file, \"{\\n\");\n@@ -2502,12 +2499,12 @@ write_header_file (void)\n   return 1;\n }\n \n-/* Write the decl and initializer for rs6000_builtin_info_x[].  */\n+/* Write the decl and initializer for rs6000_builtin_info[].  */\n static void\n write_bif_static_init (void)\n {\n   const char *res[3];\n-  fprintf (init_file, \"bifdata rs6000_builtin_info_x[RS6000_BIF_MAX] =\\n\");\n+  fprintf (init_file, \"bifdata rs6000_builtin_info[RS6000_BIF_MAX] =\\n\");\n   fprintf (init_file, \"  {\\n\");\n   fprintf (init_file, \"    { /* RS6000_BIF_NONE: */\\n\");\n   fprintf (init_file, \"      \\\"\\\", ENB_ALWAYS, 0, CODE_FOR_nothing, 0,\\n\");\n@@ -2674,7 +2671,7 @@ write_init_bif_table (void)\n   for (int i = 0; i <= curr_bif; i++)\n     {\n       fprintf (init_file,\n-\t       \"  rs6000_builtin_info_x[RS6000_BIF_%s].fntype\"\n+\t       \"  rs6000_builtin_info[RS6000_BIF_%s].fntype\"\n \t       \"\\n    = %s;\\n\",\n \t       bifs[i].idname, bifs[i].fndecl);\n \n@@ -2701,7 +2698,7 @@ write_init_bif_table (void)\n \t}\n \n       fprintf (init_file,\n-\t       \"  rs6000_builtin_decls_x[(int)RS6000_BIF_%s] = t\\n\",\n+\t       \"  rs6000_builtin_decls[(int)RS6000_BIF_%s] = t\\n\",\n \t       bifs[i].idname);\n       fprintf (init_file,\n \t       \"    = add_builtin_function (\\\"%s\\\",\\n\",\n@@ -2742,7 +2739,7 @@ write_init_bif_table (void)\n \t  fprintf (init_file, \"    }\\n\");\n \t  fprintf (init_file, \"  else\\n\");\n \t  fprintf (init_file, \"    {\\n\");\n-\t  fprintf (init_file, \"      rs6000_builtin_decls_x\"\n+\t  fprintf (init_file, \"      rs6000_builtin_decls\"\n \t\t   \"[(int)RS6000_BIF_%s] = NULL_TREE;\\n\", bifs[i].idname);\n \t  fprintf (init_file, \"    }\\n\");\n \t}\n@@ -2795,7 +2792,7 @@ write_init_ovld_table (void)\n \t    }\n \n \t  fprintf (init_file,\n-\t\t   \"  rs6000_builtin_decls_x[(int)RS6000_OVLD_%s] = t\\n\",\n+\t\t   \"  rs6000_builtin_decls[(int)RS6000_OVLD_%s] = t\\n\",\n \t\t   stanza->stanza_id);\n \t  fprintf (init_file,\n \t\t   \"    = add_builtin_function (\\\"%s\\\",\\n\",\n@@ -2844,7 +2841,7 @@ write_init_file (void)\n   fprintf (init_file, \"#include \\\"rs6000-builtins.h\\\"\\n\");\n   fprintf (init_file, \"\\n\");\n \n-  fprintf (init_file, \"tree rs6000_builtin_decls_x[RS6000_OVLD_MAX];\\n\\n\");\n+  fprintf (init_file, \"tree rs6000_builtin_decls[RS6000_OVLD_MAX];\\n\\n\");\n \n   write_bif_static_init ();\n   write_ovld_static_init ();\n@@ -2860,11 +2857,11 @@ write_init_file (void)\n   fprintf (init_file, \"\\n\");\n \n   fprintf (init_file,\n-\t   \"  rs6000_builtin_decls_x[RS6000_BIF_NONE] = NULL_TREE;\\n\");\n+\t   \"  rs6000_builtin_decls[RS6000_BIF_NONE] = NULL_TREE;\\n\");\n   fprintf (init_file,\n-\t   \"  rs6000_builtin_decls_x[RS6000_BIF_MAX] = NULL_TREE;\\n\");\n+\t   \"  rs6000_builtin_decls[RS6000_BIF_MAX] = NULL_TREE;\\n\");\n   fprintf (init_file,\n-\t   \"  rs6000_builtin_decls_x[RS6000_OVLD_NONE] = NULL_TREE;\\n\\n\");\n+\t   \"  rs6000_builtin_decls[RS6000_OVLD_NONE] = NULL_TREE;\\n\\n\");\n \n   write_init_bif_table ();\n   write_init_ovld_table ();"}, {"sha": "4481ba57ed7df659db0f4f87a63e49318100d7fc", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/926d64906af2efc8714d37e6db2171784cfa60cd/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/926d64906af2efc8714d37e6db2171784cfa60cd/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=926d64906af2efc8714d37e6db2171784cfa60cd", "patch": "@@ -5596,95 +5596,95 @@ rs6000_builtin_vectorized_function (unsigned int fn, tree type_out,\n       if (VECTOR_UNIT_VSX_P (V2DFmode)\n \t  && out_mode == DFmode && out_n == 2\n \t  && in_mode == DFmode && in_n == 2)\n-\treturn rs6000_builtin_decls_x[RS6000_BIF_CPSGNDP];\n+\treturn rs6000_builtin_decls[RS6000_BIF_CPSGNDP];\n       if (VECTOR_UNIT_VSX_P (V4SFmode)\n \t  && out_mode == SFmode && out_n == 4\n \t  && in_mode == SFmode && in_n == 4)\n-\treturn rs6000_builtin_decls_x[RS6000_BIF_CPSGNSP];\n+\treturn rs6000_builtin_decls[RS6000_BIF_CPSGNSP];\n       if (VECTOR_UNIT_ALTIVEC_P (V4SFmode)\n \t  && out_mode == SFmode && out_n == 4\n \t  && in_mode == SFmode && in_n == 4)\n-\treturn rs6000_builtin_decls_x[RS6000_BIF_COPYSIGN_V4SF];\n+\treturn rs6000_builtin_decls[RS6000_BIF_COPYSIGN_V4SF];\n       break;\n     CASE_CFN_CEIL:\n       if (VECTOR_UNIT_VSX_P (V2DFmode)\n \t  && out_mode == DFmode && out_n == 2\n \t  && in_mode == DFmode && in_n == 2)\n-\treturn rs6000_builtin_decls_x[RS6000_BIF_XVRDPIP];\n+\treturn rs6000_builtin_decls[RS6000_BIF_XVRDPIP];\n       if (VECTOR_UNIT_VSX_P (V4SFmode)\n \t  && out_mode == SFmode && out_n == 4\n \t  && in_mode == SFmode && in_n == 4)\n-\treturn rs6000_builtin_decls_x[RS6000_BIF_XVRSPIP];\n+\treturn rs6000_builtin_decls[RS6000_BIF_XVRSPIP];\n       if (VECTOR_UNIT_ALTIVEC_P (V4SFmode)\n \t  && out_mode == SFmode && out_n == 4\n \t  && in_mode == SFmode && in_n == 4)\n-\treturn rs6000_builtin_decls_x[RS6000_BIF_VRFIP];\n+\treturn rs6000_builtin_decls[RS6000_BIF_VRFIP];\n       break;\n     CASE_CFN_FLOOR:\n       if (VECTOR_UNIT_VSX_P (V2DFmode)\n \t  && out_mode == DFmode && out_n == 2\n \t  && in_mode == DFmode && in_n == 2)\n-\treturn rs6000_builtin_decls_x[RS6000_BIF_XVRDPIM];\n+\treturn rs6000_builtin_decls[RS6000_BIF_XVRDPIM];\n       if (VECTOR_UNIT_VSX_P (V4SFmode)\n \t  && out_mode == SFmode && out_n == 4\n \t  && in_mode == SFmode && in_n == 4)\n-\treturn rs6000_builtin_decls_x[RS6000_BIF_XVRSPIM];\n+\treturn rs6000_builtin_decls[RS6000_BIF_XVRSPIM];\n       if (VECTOR_UNIT_ALTIVEC_P (V4SFmode)\n \t  && out_mode == SFmode && out_n == 4\n \t  && in_mode == SFmode && in_n == 4)\n-\treturn rs6000_builtin_decls_x[RS6000_BIF_VRFIM];\n+\treturn rs6000_builtin_decls[RS6000_BIF_VRFIM];\n       break;\n     CASE_CFN_FMA:\n       if (VECTOR_UNIT_VSX_P (V2DFmode)\n \t  && out_mode == DFmode && out_n == 2\n \t  && in_mode == DFmode && in_n == 2)\n-\treturn rs6000_builtin_decls_x[RS6000_BIF_XVMADDDP];\n+\treturn rs6000_builtin_decls[RS6000_BIF_XVMADDDP];\n       if (VECTOR_UNIT_VSX_P (V4SFmode)\n \t  && out_mode == SFmode && out_n == 4\n \t  && in_mode == SFmode && in_n == 4)\n-\treturn rs6000_builtin_decls_x[RS6000_BIF_XVMADDSP];\n+\treturn rs6000_builtin_decls[RS6000_BIF_XVMADDSP];\n       if (VECTOR_UNIT_ALTIVEC_P (V4SFmode)\n \t  && out_mode == SFmode && out_n == 4\n \t  && in_mode == SFmode && in_n == 4)\n-\treturn rs6000_builtin_decls_x[RS6000_BIF_VMADDFP];\n+\treturn rs6000_builtin_decls[RS6000_BIF_VMADDFP];\n       break;\n     CASE_CFN_TRUNC:\n       if (VECTOR_UNIT_VSX_P (V2DFmode)\n \t  && out_mode == DFmode && out_n == 2\n \t  && in_mode == DFmode && in_n == 2)\n-\treturn rs6000_builtin_decls_x[RS6000_BIF_XVRDPIZ];\n+\treturn rs6000_builtin_decls[RS6000_BIF_XVRDPIZ];\n       if (VECTOR_UNIT_VSX_P (V4SFmode)\n \t  && out_mode == SFmode && out_n == 4\n \t  && in_mode == SFmode && in_n == 4)\n-\treturn rs6000_builtin_decls_x[RS6000_BIF_XVRSPIZ];\n+\treturn rs6000_builtin_decls[RS6000_BIF_XVRSPIZ];\n       if (VECTOR_UNIT_ALTIVEC_P (V4SFmode)\n \t  && out_mode == SFmode && out_n == 4\n \t  && in_mode == SFmode && in_n == 4)\n-\treturn rs6000_builtin_decls_x[RS6000_BIF_VRFIZ];\n+\treturn rs6000_builtin_decls[RS6000_BIF_VRFIZ];\n       break;\n     CASE_CFN_NEARBYINT:\n       if (VECTOR_UNIT_VSX_P (V2DFmode)\n \t  && flag_unsafe_math_optimizations\n \t  && out_mode == DFmode && out_n == 2\n \t  && in_mode == DFmode && in_n == 2)\n-\treturn rs6000_builtin_decls_x[RS6000_BIF_XVRDPI];\n+\treturn rs6000_builtin_decls[RS6000_BIF_XVRDPI];\n       if (VECTOR_UNIT_VSX_P (V4SFmode)\n \t  && flag_unsafe_math_optimizations\n \t  && out_mode == SFmode && out_n == 4\n \t  && in_mode == SFmode && in_n == 4)\n-\treturn rs6000_builtin_decls_x[RS6000_BIF_XVRSPI];\n+\treturn rs6000_builtin_decls[RS6000_BIF_XVRSPI];\n       break;\n     CASE_CFN_RINT:\n       if (VECTOR_UNIT_VSX_P (V2DFmode)\n \t  && !flag_trapping_math\n \t  && out_mode == DFmode && out_n == 2\n \t  && in_mode == DFmode && in_n == 2)\n-\treturn rs6000_builtin_decls_x[RS6000_BIF_XVRDPIC];\n+\treturn rs6000_builtin_decls[RS6000_BIF_XVRDPIC];\n       if (VECTOR_UNIT_VSX_P (V4SFmode)\n \t  && !flag_trapping_math\n \t  && out_mode == SFmode && out_n == 4\n \t  && in_mode == SFmode && in_n == 4)\n-\treturn rs6000_builtin_decls_x[RS6000_BIF_XVRSPIC];\n+\treturn rs6000_builtin_decls[RS6000_BIF_XVRSPIC];\n       break;\n     default:\n       break;\n@@ -5731,25 +5731,25 @@ rs6000_builtin_md_vectorized_function (tree fndecl, tree type_out,\n       if (VECTOR_UNIT_ALTIVEC_OR_VSX_P (V4SFmode)\n \t  && out_mode == SFmode && out_n == 4\n \t  && in_mode == SFmode && in_n == 4)\n-\treturn rs6000_builtin_decls_x[RS6000_BIF_VRSQRTFP];\n+\treturn rs6000_builtin_decls[RS6000_BIF_VRSQRTFP];\n       break;\n     case RS6000_BIF_RSQRT:\n       if (VECTOR_UNIT_VSX_P (V2DFmode)\n \t  && out_mode == DFmode && out_n == 2\n \t  && in_mode == DFmode && in_n == 2)\n-\treturn rs6000_builtin_decls_x[RS6000_BIF_RSQRT_2DF];\n+\treturn rs6000_builtin_decls[RS6000_BIF_RSQRT_2DF];\n       break;\n     case RS6000_BIF_RECIPF:\n       if (VECTOR_UNIT_ALTIVEC_OR_VSX_P (V4SFmode)\n \t  && out_mode == SFmode && out_n == 4\n \t  && in_mode == SFmode && in_n == 4)\n-\treturn rs6000_builtin_decls_x[RS6000_BIF_VRECIPFP];\n+\treturn rs6000_builtin_decls[RS6000_BIF_VRECIPFP];\n       break;\n     case RS6000_BIF_RECIP:\n       if (VECTOR_UNIT_VSX_P (V2DFmode)\n \t  && out_mode == DFmode && out_n == 2\n \t  && in_mode == DFmode && in_n == 2)\n-\treturn rs6000_builtin_decls_x[RS6000_BIF_RECIP_V2DF];\n+\treturn rs6000_builtin_decls[RS6000_BIF_RECIP_V2DF];\n       break;\n     default:\n       break;\n@@ -5804,7 +5804,7 @@ rs6000_builtin_md_vectorized_function (tree fndecl, tree type_out,\n \t}\n \n       if (in_mode == exp_mode && in_vmode == exp_vmode)\n-\treturn rs6000_builtin_decls_x[bif];\n+\treturn rs6000_builtin_decls[bif];\n     }\n \n   return NULL_TREE;\n@@ -22496,13 +22496,13 @@ rs6000_builtin_reciprocal (tree fndecl)\n       if (!RS6000_RECIP_AUTO_RSQRTE_P (V2DFmode))\n \treturn NULL_TREE;\n \n-      return rs6000_builtin_decls_x[RS6000_BIF_RSQRT_2DF];\n+      return rs6000_builtin_decls[RS6000_BIF_RSQRT_2DF];\n \n     case RS6000_BIF_XVSQRTSP:\n       if (!RS6000_RECIP_AUTO_RSQRTE_P (V4SFmode))\n \treturn NULL_TREE;\n \n-      return rs6000_builtin_decls_x[RS6000_BIF_RSQRT_4SF];\n+      return rs6000_builtin_decls[RS6000_BIF_RSQRT_4SF];\n \n     default:\n       return NULL_TREE;\n@@ -25124,7 +25124,7 @@ add_condition_to_bb (tree function_decl, tree version_decl,\n \n   tree bool_zero = build_int_cst (bool_int_type_node, 0);\n   tree cond_var = create_tmp_var (bool_int_type_node);\n-  tree predicate_decl = rs6000_builtin_decls_x[(int) RS6000_BIF_CPU_SUPPORTS];\n+  tree predicate_decl = rs6000_builtin_decls[(int) RS6000_BIF_CPU_SUPPORTS];\n   const char *arg_str = rs6000_clone_map[clone_isa].name;\n   tree predicate_arg = build_string_literal (strlen (arg_str) + 1, arg_str);\n   gimple *call_cond_stmt = gimple_build_call (predicate_decl, 1, predicate_arg);\n@@ -27766,8 +27766,8 @@ rs6000_atomic_assign_expand_fenv (tree *hold, tree *clear, tree *update)\n       return;\n     }\n \n-  tree mffs = rs6000_builtin_decls_x[RS6000_BIF_MFFS];\n-  tree mtfsf = rs6000_builtin_decls_x[RS6000_BIF_MTFSF];\n+  tree mffs = rs6000_builtin_decls[RS6000_BIF_MFFS];\n+  tree mtfsf = rs6000_builtin_decls[RS6000_BIF_MTFSF];\n   tree call_mffs = build_call_expr (mffs, 0);\n \n   /* Generates the equivalent of feholdexcept (&fenv_var)"}]}