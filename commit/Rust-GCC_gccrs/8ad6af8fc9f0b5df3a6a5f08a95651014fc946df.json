{"sha": "8ad6af8fc9f0b5df3a6a5f08a95651014fc946df", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGFkNmFmOGZjOWYwYjVkZjNhNmE1ZjA4YTk1NjUxMDE0ZmM5NDZkZg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@adacore.com", "date": "2020-06-21T08:27:07Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-10-15T09:39:08Z"}, "message": "[Ada] Add support for compile time evaluation of Shift_Right_Arithmetic\n\ngcc/ada/\n\n\t* sem_eval.adb (Eval_Intrinsic_Call, Fold_Shift): Add support\n\tfor Shift_Right_Arithmetic and for signed integers.\n\t* exp_ch4.adb (Expand_N_Op_Rotate_Left,\n\tExpand_N_Op_Rotate_Right, Expand_N_Op_Shift_Left,\n\tExpand_N_Op_Shift_Right_Arithmetic): Minor reformatting and code\n\tcleanup to ensure a consistent handling. Update comments and add\n\tassertion.", "tree": {"sha": "1d7295a1ee16d22e25356bd364652daedb396e02", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1d7295a1ee16d22e25356bd364652daedb396e02"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8ad6af8fc9f0b5df3a6a5f08a95651014fc946df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ad6af8fc9f0b5df3a6a5f08a95651014fc946df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ad6af8fc9f0b5df3a6a5f08a95651014fc946df", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ad6af8fc9f0b5df3a6a5f08a95651014fc946df/comments", "author": {"login": "ArnaudCharlet", "id": 30291825, "node_id": "MDQ6VXNlcjMwMjkxODI1", "avatar_url": "https://avatars.githubusercontent.com/u/30291825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ArnaudCharlet", "html_url": "https://github.com/ArnaudCharlet", "followers_url": "https://api.github.com/users/ArnaudCharlet/followers", "following_url": "https://api.github.com/users/ArnaudCharlet/following{/other_user}", "gists_url": "https://api.github.com/users/ArnaudCharlet/gists{/gist_id}", "starred_url": "https://api.github.com/users/ArnaudCharlet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ArnaudCharlet/subscriptions", "organizations_url": "https://api.github.com/users/ArnaudCharlet/orgs", "repos_url": "https://api.github.com/users/ArnaudCharlet/repos", "events_url": "https://api.github.com/users/ArnaudCharlet/events{/privacy}", "received_events_url": "https://api.github.com/users/ArnaudCharlet/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "46a3809b1579cb86574c6ba8e2858a8f369f8786", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46a3809b1579cb86574c6ba8e2858a8f369f8786", "html_url": "https://github.com/Rust-GCC/gccrs/commit/46a3809b1579cb86574c6ba8e2858a8f369f8786"}], "stats": {"total": 177, "additions": 127, "deletions": 50}, "files": [{"sha": "b61c428182e2b59a8ba991c497183b26f305c5a6", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 53, "deletions": 40, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ad6af8fc9f0b5df3a6a5f08a95651014fc946df/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ad6af8fc9f0b5df3a6a5f08a95651014fc946df/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=8ad6af8fc9f0b5df3a6a5f08a95651014fc946df", "patch": "@@ -10265,15 +10265,17 @@ package body Exp_Ch4 is\n       --  where Bits is the shift count mod Esize (the mod operation here\n       --  deals with ludicrous large shift counts, which are apparently OK).\n \n-      --  What about nonbinary modulus ???\n+      if Modify_Tree_For_C then\n+         declare\n+            Loc : constant Source_Ptr := Sloc (N);\n+            Rtp : constant Entity_Id  := Etype (Right_Opnd (N));\n+            Typ : constant Entity_Id  := Etype (N);\n \n-      declare\n-         Loc : constant Source_Ptr := Sloc (N);\n-         Rtp : constant Entity_Id  := Etype (Right_Opnd (N));\n-         Typ : constant Entity_Id  := Etype (N);\n+         begin\n+            --  Sem_Intr should prevent getting there with a non binary modulus\n+\n+            pragma Assert (not Non_Binary_Modulus (Typ));\n \n-      begin\n-         if Modify_Tree_For_C then\n             Rewrite (Right_Opnd (N),\n               Make_Op_Rem (Loc,\n                 Left_Opnd  => Relocate_Node (Right_Opnd (N)),\n@@ -10298,8 +10300,8 @@ package body Exp_Ch4 is\n                           Duplicate_Subexpr_No_Checks (Right_Opnd (N))))));\n \n             Analyze_And_Resolve (N, Typ);\n-         end if;\n-      end;\n+         end;\n+      end if;\n    end Expand_N_Op_Rotate_Left;\n \n    ------------------------------\n@@ -10318,22 +10320,24 @@ package body Exp_Ch4 is\n       --  where Bits is the shift count mod Esize (the mod operation here\n       --  deals with ludicrous large shift counts, which are apparently OK).\n \n-      --  What about nonbinary modulus ???\n+      if Modify_Tree_For_C then\n+         declare\n+            Loc : constant Source_Ptr := Sloc (N);\n+            Rtp : constant Entity_Id  := Etype (Right_Opnd (N));\n+            Typ : constant Entity_Id  := Etype (N);\n \n-      declare\n-         Loc : constant Source_Ptr := Sloc (N);\n-         Rtp : constant Entity_Id  := Etype (Right_Opnd (N));\n-         Typ : constant Entity_Id  := Etype (N);\n+         begin\n+            --  Sem_Intr should prevent getting there with a non binary modulus\n \n-      begin\n-         Rewrite (Right_Opnd (N),\n-           Make_Op_Rem (Loc,\n-             Left_Opnd  => Relocate_Node (Right_Opnd (N)),\n-             Right_Opnd => Make_Integer_Literal (Loc, Esize (Typ))));\n+            pragma Assert (not Non_Binary_Modulus (Typ));\n+\n+            Rewrite (Right_Opnd (N),\n+              Make_Op_Rem (Loc,\n+                Left_Opnd  => Relocate_Node (Right_Opnd (N)),\n+                Right_Opnd => Make_Integer_Literal (Loc, Esize (Typ))));\n \n-         Analyze_And_Resolve (Right_Opnd (N), Rtp);\n+            Analyze_And_Resolve (Right_Opnd (N), Rtp);\n \n-         if Modify_Tree_For_C then\n             Rewrite (N,\n               Make_Op_Or (Loc,\n                 Left_Opnd =>\n@@ -10351,8 +10355,8 @@ package body Exp_Ch4 is\n                           Duplicate_Subexpr_No_Checks (Right_Opnd (N))))));\n \n             Analyze_And_Resolve (N, Typ);\n-         end if;\n-      end;\n+         end;\n+      end if;\n    end Expand_N_Op_Rotate_Right;\n \n    ----------------------------\n@@ -10382,6 +10386,10 @@ package body Exp_Ch4 is\n             Hi    : Uint;\n \n          begin\n+            --  Sem_Intr should prevent getting there with a non binary modulus\n+\n+            pragma Assert (not Non_Binary_Modulus (Typ));\n+\n             if Compile_Time_Known_Value (Right) then\n                if Expr_Value (Right) >= Siz then\n                   Rewrite (N, Make_Integer_Literal (Loc, 0));\n@@ -10439,7 +10447,14 @@ package body Exp_Ch4 is\n       Binary_Op_Validity_Checks (N);\n \n       --  If we are in Modify_Tree_For_C mode, there is no shift right\n-      --  arithmetic in C, so we rewrite in terms of logical shifts.\n+      --  arithmetic in C, so we rewrite in terms of logical shifts for\n+      --  modular integers, and keep the Shift_Right intrinsic for signed\n+      --  integers: even though doing a shift on a signed integer is not\n+      --  fully guaranteed by the C standard, this is what C compilers\n+      --  implement in practice.\n+      --  Consider also taking advantage of this for modular integers by first\n+      --  performing an unchecked conversion of the modular integer to a signed\n+      --  integer of the same sign, and then convert back.\n \n       --    Shift_Right (Num, Bits) or\n       --      (if Num >= Sign\n@@ -10448,26 +10463,24 @@ package body Exp_Ch4 is\n \n       --  Here Mask is all 1 bits (2**size - 1), and Sign is 2**(size - 1)\n \n-      --  Note: in almost all C compilers it would work to just shift a\n-      --  signed integer right, but it's undefined and we cannot rely on it.\n-\n       --  Note: the above works fine for shift counts greater than or equal\n       --  to the word size, since in this case (not (Shift_Right (Mask, bits)))\n       --  generates all 1'bits.\n \n-      --  What about nonbinary modulus ???\n+      if Modify_Tree_For_C and then Is_Modular_Integer_Type (Etype (N)) then\n+         declare\n+            Loc   : constant Source_Ptr := Sloc (N);\n+            Typ   : constant Entity_Id  := Etype (N);\n+            Sign  : constant Uint       := 2 ** (Esize (Typ) - 1);\n+            Mask  : constant Uint       := (2 ** Esize (Typ)) - 1;\n+            Left  : constant Node_Id    := Left_Opnd (N);\n+            Right : constant Node_Id    := Right_Opnd (N);\n+            Maskx : Node_Id;\n \n-      declare\n-         Loc   : constant Source_Ptr := Sloc (N);\n-         Typ   : constant Entity_Id  := Etype (N);\n-         Sign  : constant Uint       := 2 ** (Esize (Typ) - 1);\n-         Mask  : constant Uint       := (2 ** Esize (Typ)) - 1;\n-         Left  : constant Node_Id    := Left_Opnd (N);\n-         Right : constant Node_Id    := Right_Opnd (N);\n-         Maskx : Node_Id;\n+         begin\n+            --  Sem_Intr should prevent getting there with a non binary modulus\n \n-      begin\n-         if Modify_Tree_For_C then\n+            pragma Assert (not Non_Binary_Modulus (Typ));\n \n             --  Here if not (Shift_Right (Mask, bits)) can be computed at\n             --  compile time as a single constant.\n@@ -10513,8 +10526,8 @@ package body Exp_Ch4 is\n                       Maskx,\n                       Make_Integer_Literal (Loc, 0)))));\n             Analyze_And_Resolve (N, Typ);\n-         end if;\n-      end;\n+         end;\n+      end if;\n    end Expand_N_Op_Shift_Right_Arithmetic;\n \n    --------------------------"}, {"sha": "872112d03ebae615be3646bd8aa3e33e12d6eea0", "filename": "gcc/ada/sem_eval.adb", "status": "modified", "additions": 74, "deletions": 10, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ad6af8fc9f0b5df3a6a5f08a95651014fc946df/gcc%2Fada%2Fsem_eval.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ad6af8fc9f0b5df3a6a5f08a95651014fc946df/gcc%2Fada%2Fsem_eval.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.adb?ref=8ad6af8fc9f0b5df3a6a5f08a95651014fc946df", "patch": "@@ -2941,9 +2941,14 @@ package body Sem_Eval is\n       end if;\n \n       case Nam is\n-         when Name_Shift_Left  => Eval_Shift (N, E, N_Op_Shift_Left);\n-         when Name_Shift_Right => Eval_Shift (N, E, N_Op_Shift_Right);\n-         when others           => null;\n+         when Name_Shift_Left  =>\n+            Eval_Shift (N, E, N_Op_Shift_Left);\n+         when Name_Shift_Right =>\n+            Eval_Shift (N, E, N_Op_Shift_Right);\n+         when Name_Shift_Right_Arithmetic =>\n+            Eval_Shift (N, E, N_Op_Shift_Right_Arithmetic);\n+         when others           =>\n+            null;\n       end case;\n    end Eval_Intrinsic_Call;\n \n@@ -4800,13 +4805,11 @@ package body Sem_Eval is\n       end Check_Elab_Call;\n \n    begin\n-      --  Evaluate logical shift operators on binary modular types\n-\n-      if Is_Modular_Integer_Type (Typ)\n-        and then not Non_Binary_Modulus (Typ)\n-        and then Compile_Time_Known_Value (Left)\n+      if Compile_Time_Known_Value (Left)\n         and then Compile_Time_Known_Value (Right)\n       then\n+         pragma Assert (not Non_Binary_Modulus (Typ));\n+\n          if Op = N_Op_Shift_Left then\n             Check_Elab_Call;\n \n@@ -4821,12 +4824,73 @@ package body Sem_Eval is\n          elsif Op = N_Op_Shift_Right then\n             Check_Elab_Call;\n \n-            --  Fold Shift_Right (X, Y) by computing X / 2**Y\n+            --  Fold Shift_Right (X, Y) by computing abs X / 2**Y\n \n             Fold_Uint\n               (N,\n-               Expr_Value (Left) / (Uint_2 ** Expr_Value (Right)),\n+               abs Expr_Value (Left) / (Uint_2 ** Expr_Value (Right)),\n                Static => Static);\n+\n+         elsif Op = N_Op_Shift_Right_Arithmetic then\n+            Check_Elab_Call;\n+\n+            declare\n+               Two_Y   : constant Uint := Uint_2 ** Expr_Value (Right);\n+               Modulus : Uint;\n+            begin\n+               if Is_Modular_Integer_Type (Typ) then\n+                  Modulus := Einfo.Modulus (Typ);\n+               else\n+                  Modulus := Uint_2 ** RM_Size (Typ);\n+               end if;\n+\n+               --  X / 2**Y if X if positive or a small enough modular integer\n+\n+               if (Is_Modular_Integer_Type (Typ)\n+                    and then Expr_Value (Left) < Modulus / Uint_2)\n+                 or else\n+                   (not Is_Modular_Integer_Type (Typ)\n+                     and then Expr_Value (Left) >= 0)\n+               then\n+                  Fold_Uint (N, Expr_Value (Left) / Two_Y, Static => Static);\n+\n+               --  -1 (aka all 1's) if Y is larger than the number of bits\n+               --  available or if X = -1.\n+\n+               elsif Two_Y > Modulus\n+                 or else Expr_Value (Left) = Uint_Minus_1\n+               then\n+                  if Is_Modular_Integer_Type (Typ) then\n+                     Fold_Uint (N, Modulus - Uint_1, Static => Static);\n+                  else\n+                     Fold_Uint (N, Uint_Minus_1, Static => Static);\n+                  end if;\n+\n+               --  Large modular integer, compute via multiply/divide the\n+               --  following: X >> Y + (1 << Y - 1) << (RM_Size - Y)\n+\n+               elsif Is_Modular_Integer_Type (Typ) then\n+                  Fold_Uint\n+                    (N,\n+                     (Expr_Value (Left)) / Two_Y\n+                        + (Two_Y - Uint_1)\n+                          * Uint_2 ** (RM_Size (Typ) - Expr_Value (Right)),\n+                     Static => Static);\n+\n+               --  Negative signed integer, compute via multiple/divide the\n+               --  following:\n+               --  (Modulus + X) >> Y + (1 << Y - 1) << (RM_Size - Y) - Modulus\n+\n+               else\n+                  Fold_Uint\n+                    (N,\n+                     (Modulus + Expr_Value (Left)) / Two_Y\n+                        + (Two_Y - Uint_1)\n+                          * Uint_2 ** (RM_Size (Typ) - Expr_Value (Right))\n+                        - Modulus,\n+                     Static => Static);\n+               end if;\n+            end;\n          end if;\n       end if;\n    end Fold_Shift;"}]}