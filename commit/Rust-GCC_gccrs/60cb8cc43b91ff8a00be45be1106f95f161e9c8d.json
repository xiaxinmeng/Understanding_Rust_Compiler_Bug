{"sha": "60cb8cc43b91ff8a00be45be1106f95f161e9c8d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjBjYjhjYzQzYjkxZmY4YTAwYmU0NWJlMTEwNmY5NWYxNjFlOWM4ZA==", "commit": {"author": {"name": "Mark Wielaard", "email": "mark@klomp.org", "date": "2021-06-25T17:37:11Z"}, "committer": {"name": "Mark Wielaard", "email": "mark@klomp.org", "date": "2021-06-25T19:50:37Z"}, "message": "Reject non-pure decimal tuple indexes.\n\nTuple indexes should be pure decimal integer literals. But the parser just sees an\ninteger literal. Fix this by introducing a new type hint CORETYPE_PURE_DECIMAL. This\ndoesn't conflict with any existing type hints since a pure decimal doesn't have a\ntype suffix.\n\nIntroduce a new method is_pure_decimal that the parser can use in parse_tuple_index_expr.\nget_type_hint will return CORETYPE_UNKNOWN for pure decimals.\n\nparse_decimal_int_or_float will check whether there are no execissive leading zeros.\nparse_in_decimal checks the literal doesn't contain any underscores.\n\nAdd two testcases. bad_tuple_index.rs with all variants of integer literals which aren't\npure decimals. And tuple_index.rs with various correct tuple indexes.\n\nResolves: https://github.com/Rust-GCC/gccrs/issues/511", "tree": {"sha": "bd85ffbf6bf29ece4c4409e39d24fba3fb37748f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bd85ffbf6bf29ece4c4409e39d24fba3fb37748f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/60cb8cc43b91ff8a00be45be1106f95f161e9c8d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60cb8cc43b91ff8a00be45be1106f95f161e9c8d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/60cb8cc43b91ff8a00be45be1106f95f161e9c8d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60cb8cc43b91ff8a00be45be1106f95f161e9c8d/comments", "author": null, "committer": null, "parents": [{"sha": "99bc27d278359be9aec5597504807a6456a88a6c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99bc27d278359be9aec5597504807a6456a88a6c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/99bc27d278359be9aec5597504807a6456a88a6c"}], "stats": {"total": 152, "additions": 139, "deletions": 13}, "files": [{"sha": "d138416873191cfe6038c066fe5ff2279ba36dd9", "filename": "gcc/rust/lex/rust-lex.cc", "status": "modified", "additions": 22, "deletions": 11, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60cb8cc43b91ff8a00be45be1106f95f161e9c8d/gcc%2Frust%2Flex%2Frust-lex.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60cb8cc43b91ff8a00be45be1106f95f161e9c8d/gcc%2Frust%2Flex%2Frust-lex.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Flex%2Frust-lex.cc?ref=60cb8cc43b91ff8a00be45be1106f95f161e9c8d", "patch": "@@ -942,23 +942,26 @@ Lexer::parse_in_exponent_part ()\n \t}\n \n       // parse another decimal number for exponent\n-      auto str_length_pair = parse_in_decimal ();\n-      str += str_length_pair.first;\n-      additional_length_offset += str_length_pair.second;\n+      auto str_length = parse_in_decimal ();\n+      str += std::get<0> (str_length);\n+      additional_length_offset += std::get<1> (str_length);\n     }\n   return std::make_pair (str, additional_length_offset);\n }\n \n // Parses a decimal integer.\n-std::pair<std::string, int>\n+std::tuple<std::string, int, bool>\n Lexer::parse_in_decimal ()\n {\n+  /* A pure decimal contains only digits.  */\n+  bool pure_decimal = true;\n   int additional_length_offset = 0;\n   std::string str;\n   while (ISDIGIT (current_char) || current_char == '_')\n     {\n       if (current_char == '_')\n \t{\n+\t  pure_decimal = false;\n \t  // don't add _ to number\n \t  skip_input ();\n \t  current_char = peek_input ();\n@@ -974,7 +977,7 @@ Lexer::parse_in_decimal ()\n       skip_input ();\n       current_char = peek_input ();\n     }\n-  return std::make_pair (str, additional_length_offset);\n+  return std::make_tuple (str, additional_length_offset, pure_decimal);\n }\n \n /* Parses escapes (and string continues) in \"byte\" strings and characters. Does\n@@ -1842,13 +1845,14 @@ Lexer::parse_decimal_int_or_float (Location loc)\n   str += current_char;\n \n   int length = 1;\n+  bool first_zero = current_char == '0';\n \n   current_char = peek_input ();\n \n   // parse initial decimal integer (or first integer part of float) literal\n-  auto initial_decimal_pair = parse_in_decimal ();\n-  str += initial_decimal_pair.first;\n-  length += initial_decimal_pair.second;\n+  auto initial_decimal = parse_in_decimal ();\n+  str += std::get<0> (initial_decimal);\n+  length += std::get<1> (initial_decimal);\n \n   // detect float literal\n   if (current_char == '.' && is_float_digit (peek_input (1)))\n@@ -1862,9 +1866,9 @@ Lexer::parse_decimal_int_or_float (Location loc)\n       length++;\n \n       // parse another decimal number for float\n-      auto second_decimal_pair = parse_in_decimal ();\n-      str += second_decimal_pair.first;\n-      length += second_decimal_pair.second;\n+      auto second_decimal = parse_in_decimal ();\n+      str += std::get<0> (second_decimal);\n+      length += std::get<1> (second_decimal);\n \n       // parse in exponent part if it exists\n       auto exponent_pair = parse_in_exponent_part ();\n@@ -1947,6 +1951,13 @@ Lexer::parse_decimal_int_or_float (Location loc)\n       // parse in type suffix if it exists\n       auto type_suffix_pair = parse_in_type_suffix ();\n       PrimitiveCoreType type_hint = type_suffix_pair.first;\n+      /* A \"real\" pure decimal doesn't have a suffix and no zero prefix.  */\n+      if (type_hint == CORETYPE_UNKNOWN)\n+\t{\n+\t  bool pure_decimal = std::get<2> (initial_decimal);\n+\t  if (pure_decimal && (!first_zero || str.size () == 1))\n+\t    type_hint = CORETYPE_PURE_DECIMAL;\n+\t}\n       length += type_suffix_pair.second;\n \n       current_column += length;"}, {"sha": "902745fa1d5f0967b64e18c6a805c3719d27c7f3", "filename": "gcc/rust/lex/rust-lex.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60cb8cc43b91ff8a00be45be1106f95f161e9c8d/gcc%2Frust%2Flex%2Frust-lex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60cb8cc43b91ff8a00be45be1106f95f161e9c8d/gcc%2Frust%2Flex%2Frust-lex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Flex%2Frust-lex.h?ref=60cb8cc43b91ff8a00be45be1106f95f161e9c8d", "patch": "@@ -71,7 +71,7 @@ class Lexer\n   // Builds a token from the input queue.\n   TokenPtr build_token ();\n \n-  std::pair<std::string, int> parse_in_decimal ();\n+  std::tuple<std::string, int, bool> parse_in_decimal ();\n   std::pair<std::string, int> parse_in_exponent_part ();\n   std::pair<PrimitiveCoreType, int> parse_in_type_suffix ();\n   std::tuple<char, int, bool> parse_escape (char opening_char);"}, {"sha": "317416cb34967c435029021b9199e4e245dc55a0", "filename": "gcc/rust/lex/rust-token.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60cb8cc43b91ff8a00be45be1106f95f161e9c8d/gcc%2Frust%2Flex%2Frust-token.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60cb8cc43b91ff8a00be45be1106f95f161e9c8d/gcc%2Frust%2Flex%2Frust-token.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Flex%2Frust-token.cc?ref=60cb8cc43b91ff8a00be45be1106f95f161e9c8d", "patch": "@@ -99,6 +99,8 @@ get_type_hint_string (PrimitiveCoreType type)\n       return \"u64\";\n     case CORETYPE_U128:\n       return \"u128\";\n+    case CORETYPE_PURE_DECIMAL:\n+      return \"pure_decimal\";\n     case CORETYPE_UNKNOWN:\n     default:\n       return \"unknown\";"}, {"sha": "771910119b7d792df29c51ce8d4ae156ea4eadc4", "filename": "gcc/rust/lex/rust-token.h", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60cb8cc43b91ff8a00be45be1106f95f161e9c8d/gcc%2Frust%2Flex%2Frust-token.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60cb8cc43b91ff8a00be45be1106f95f161e9c8d/gcc%2Frust%2Flex%2Frust-token.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Flex%2Frust-token.h?ref=60cb8cc43b91ff8a00be45be1106f95f161e9c8d", "patch": "@@ -57,6 +57,9 @@ enum PrimitiveCoreType\n   CORETYPE_U32,\n   CORETYPE_U64,\n   CORETYPE_U128,\n+  // Pure decimals are used for tuple index.\n+  // Also means there is no type hint.\n+  CORETYPE_PURE_DECIMAL,\n   // arch-dependent pointer sizes\n   CORETYPE_ISIZE = CORETYPE_INT,\n   CORETYPE_USIZE = CORETYPE_UINT\n@@ -391,7 +394,10 @@ return *str;\n }*/\n \n   // Gets token's type hint info.\n-  PrimitiveCoreType get_type_hint () const { return type_hint; }\n+  PrimitiveCoreType get_type_hint () const\n+  {\n+    return type_hint == CORETYPE_PURE_DECIMAL ? CORETYPE_UNKNOWN : type_hint;\n+  }\n \n   // diagnostics (error reporting)\n   const char *get_token_description () const\n@@ -435,6 +441,9 @@ return *str;\n   {\n     return is_literal () || token_id == IDENTIFIER || token_id == LIFETIME;\n   }\n+\n+  // Returns whether the token is a pure decimal int literal\n+  bool is_pure_decimal () const { return type_hint == CORETYPE_PURE_DECIMAL; }\n };\n } // namespace Rust\n "}, {"sha": "014beaf9e9c4eb37d93f3526ad7be7de1a3c580e", "filename": "gcc/rust/parse/rust-parse-impl.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60cb8cc43b91ff8a00be45be1106f95f161e9c8d/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60cb8cc43b91ff8a00be45be1106f95f161e9c8d/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse-impl.h?ref=60cb8cc43b91ff8a00be45be1106f95f161e9c8d", "patch": "@@ -14083,6 +14083,12 @@ Parser<ManagedTokenSource>::parse_tuple_index_expr (\n   std::string index = index_tok->get_str ();\n \n   // convert to integer\n+  if (!index_tok->is_pure_decimal ())\n+    {\n+      Error error (index_tok->get_locus (),\n+\t\t   \"tuple index should be a pure decimal literal\");\n+      add_error (std::move (error));\n+    }\n   int index_int = atoi (index.c_str ());\n \n   Location locus = tuple_expr->get_locus_slow ();"}, {"sha": "c3bd1e91d108596339d0a80aeee71f62e8f6aca3", "filename": "gcc/testsuite/rust/compile/bad_tuple_index.rs", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60cb8cc43b91ff8a00be45be1106f95f161e9c8d/gcc%2Ftestsuite%2Frust%2Fcompile%2Fbad_tuple_index.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60cb8cc43b91ff8a00be45be1106f95f161e9c8d/gcc%2Ftestsuite%2Frust%2Fcompile%2Fbad_tuple_index.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fbad_tuple_index.rs?ref=60cb8cc43b91ff8a00be45be1106f95f161e9c8d", "patch": "@@ -0,0 +1,66 @@\n+fn main()\n+{\n+  // tuples\n+  let z = ();\n+\n+  let o = (0,);\n+  /* Binary, Octal and Hex literals are invalid.  */\n+  let _fb = o.0b0; // { dg-error \"tuple index should be a pure decimal literal\" }\n+  let _fo = o.0o0; // { dg-error \"tuple index should be a pure decimal literal\" }\n+  let _fh = o.0x0; // { dg-error \"tuple index should be a pure decimal literal\" }\n+\n+  /* No underscores.  */\n+  let _fua = o.0_; // { dg-error \"tuple index should be a pure decimal literal\" }\n+\n+  /* Suffix is not allowed.  */\n+  let _fu8 = o.0u8; // { dg-error \"tuple index should be a pure decimal literal\" }\n+  let _fi8 = o.0i8; // { dg-error \"tuple index should be a pure decimal literal\" }\n+  let _fu16 = o.0u16; // { dg-error \"tuple index should be a pure decimal literal\" }\n+  let _fi16 = o.0i16; // { dg-error \"tuple index should be a pure decimal literal\" }\n+  let _fu32 = o.0u32; // { dg-error \"tuple index should be a pure decimal literal\" }\n+  let _fi32 = o.0i32; // { dg-error \"tuple index should be a pure decimal literal\" }\n+  let _fu64 = o.0u64; // { dg-error \"tuple index should be a pure decimal literal\" }\n+  let _fi64 = o.0i64; // { dg-error \"tuple index should be a pure decimal literal\" }\n+  let _fu128 = o.0u128; // { dg-error \"tuple index should be a pure decimal literal\" }\n+  let _fi128 = o.0i128; // { dg-error \"tuple index should be a pure decimal literal\" }\n+  let _fusize = o.0usize; // { dg-error \"tuple index should be a pure decimal literal\" }\n+  let _fisize = o.0isize; // { dg-error \"tuple index should be a pure decimal literal\" }\n+\n+  let t = (0,1);\n+  /* No extra zero prefix.  */\n+  let _s = t.01; // { dg-error \"tuple index should be a pure decimal literal\" }\n+\n+  let m = (0,1,2,3,4,5,6,7,8,9,10);\n+  /* No extra zero prefix.  */\n+  let _l = m.010; // { dg-error \"tuple index should be a pure decimal literal\" }\n+\n+  /* No underscores.  */\n+  let _lu = m.1_0; // { dg-error \"tuple index should be a pure decimal literal\" }\n+\n+  // tuple structs\n+  struct E();\n+  let _e = E();\n+\n+  struct O(i32);\n+  let so = O(0);\n+  /* No leading zeros, no underscores.  */\n+  let _sf = so.0_0; // { dg-error \"tuple index should be a pure decimal literal\" }\n+  /* Binary, Octal and Hex literals are invalid.  */\n+  let _sb = so.0b0; // { dg-error \"tuple index should be a pure decimal literal\" }\n+  let _so = so.0o0; // { dg-error \"tuple index should be a pure decimal literal\" }\n+  let _sh = so.0x0; // { dg-error \"tuple index should be a pure decimal literal\" }\n+\n+  struct T(i32,i32);\n+  let st = T(0,1);\n+  /* Suffix is not allowed.  */\n+  let _stfu32 = st.1u32; // { dg-error \"tuple index should be a pure decimal literal\" }\n+  let _stfi32 = st.1i32; // { dg-error \"tuple index should be a pure decimal literal\" }\n+\n+  struct M(i32,i32,i32,i32,i32,i32,i32,i32,i32,i32,i32);\n+  let sm = M(0,1,2,3,4,5,6,7,8,9,10);\n+  /* No underscores. */\n+  let _sl2 = sm.1_0; // { dg-error \"tuple index should be a pure decimal literal\" }\n+  let _sl3 = sm.10_; // { dg-error \"tuple index should be a pure decimal literal\" }\n+\n+  z\n+}"}, {"sha": "f904fae9b5b793c733a95a5690795af559ac7d07", "filename": "gcc/testsuite/rust/compile/torture/tuple_index.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60cb8cc43b91ff8a00be45be1106f95f161e9c8d/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftuple_index.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60cb8cc43b91ff8a00be45be1106f95f161e9c8d/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftuple_index.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftuple_index.rs?ref=60cb8cc43b91ff8a00be45be1106f95f161e9c8d", "patch": "@@ -0,0 +1,32 @@\n+fn main()\n+{\n+  // tuples\n+  let z = ();\n+\n+  let o = (0,);\n+  let _f = o.0;\n+\n+  let t = (0,1);\n+  let _s = t.1;\n+\n+  let m = (0,1,2,3,4,5,6,7,8,9,10);\n+  let _l = m.10;\n+\n+  // tuple structs\n+  struct E();\n+  let _e = E();\n+\n+  struct O(i32);\n+  let so = O(0);\n+  let _sf = so.0;\n+\n+  struct T(i32,i32);\n+  let st = T(0,1);\n+  let _fs = st.1;\n+\n+  struct M(i32,i32,i32,i32,i32,i32,i32,i32,i32,i32,i32);\n+  let sm = M(0,1,2,3,4,5,6,7,8,9,10);\n+  let _sl = sm.10;\n+\n+  z\n+}"}]}