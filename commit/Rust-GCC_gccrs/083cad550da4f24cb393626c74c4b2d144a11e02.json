{"sha": "083cad550da4f24cb393626c74c4b2d144a11e02", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDgzY2FkNTUwZGE0ZjI0Y2IzOTM2MjZjNzRjNGIyZDE0NGExMWUwMg==", "commit": {"author": {"name": "Eric Christopher", "email": "echristo@apple.com", "date": "2006-01-06T23:16:23Z"}, "committer": {"name": "Eric Christopher", "email": "echristo@gcc.gnu.org", "date": "2006-01-06T23:16:23Z"}, "message": "tm.texi (TARGET_ASM_EMIT_EXCEPT_TABLE_LABEL): Document.\n\n2006-01-06  Eric Christopher  <echristo@apple.com>\n\n        * doc/tm.texi (TARGET_ASM_EMIT_EXCEPT_TABLE_LABEL): Document.\n        (TARGET_UNWIND_EMIT): Fix spelling.\n        * target.h (gcc_target): Add except_table_label.\n        * except.c (output_function_exception_table): Use.\n        * varasm.c (default_emit_except_table_label): New.\n        * target-def.h (TARGET_ASM_EMIT_EXCEPT_TABLE_LABEL): New default\n        define.\n        (asm_out): Add here.\n        * output.h (default_emit_except_table_label): Prototype.\n        * config/darwin-protos.h (darwin_emit_except_table_label): Ditto.\n        * config/darwin.c (darwin_emit_except_table_label): Define.\n        * config/darwin.h (TARGET_ASM_EMIT_EXCEPT_TABLE): Ditto.\n\nFrom-SVN: r109435", "tree": {"sha": "40c29d6ebecee3ad150d3ed86b8de4eacf4f5d3b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/40c29d6ebecee3ad150d3ed86b8de4eacf4f5d3b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/083cad550da4f24cb393626c74c4b2d144a11e02", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/083cad550da4f24cb393626c74c4b2d144a11e02", "html_url": "https://github.com/Rust-GCC/gccrs/commit/083cad550da4f24cb393626c74c4b2d144a11e02", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/083cad550da4f24cb393626c74c4b2d144a11e02/comments", "author": {"login": "echristo", "id": 327308, "node_id": "MDQ6VXNlcjMyNzMwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/327308?v=4", "gravatar_id": "", "url": "https://api.github.com/users/echristo", "html_url": "https://github.com/echristo", "followers_url": "https://api.github.com/users/echristo/followers", "following_url": "https://api.github.com/users/echristo/following{/other_user}", "gists_url": "https://api.github.com/users/echristo/gists{/gist_id}", "starred_url": "https://api.github.com/users/echristo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/echristo/subscriptions", "organizations_url": "https://api.github.com/users/echristo/orgs", "repos_url": "https://api.github.com/users/echristo/repos", "events_url": "https://api.github.com/users/echristo/events{/privacy}", "received_events_url": "https://api.github.com/users/echristo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "facb553fe47c58844418c15db413a09091895d70", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/facb553fe47c58844418c15db413a09091895d70", "html_url": "https://github.com/Rust-GCC/gccrs/commit/facb553fe47c58844418c15db413a09091895d70"}], "stats": {"total": 311, "additions": 184, "deletions": 127}, "files": [{"sha": "98373329a69f21dbc0a763ebc2542b5bf5b3b8f5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/083cad550da4f24cb393626c74c4b2d144a11e02/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/083cad550da4f24cb393626c74c4b2d144a11e02/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=083cad550da4f24cb393626c74c4b2d144a11e02", "patch": "@@ -1,3 +1,18 @@\n+2006-01-06  Eric Christopher  <echristo@apple.com>\n+\n+\t* doc/tm.texi (TARGET_ASM_EMIT_EXCEPT_TABLE_LABEL): Document.\n+\t(TARGET_UNWIND_EMIT): Fix spelling.\n+\t* target.h (gcc_target): Add except_table_label.\n+\t* except.c (output_function_exception_table): Use.\n+\t* varasm.c (default_emit_except_table_label): New.\n+\t* target-def.h (TARGET_ASM_EMIT_EXCEPT_TABLE_LABEL): New default\n+\tdefine.\n+\t(asm_out): Add here.\n+\t* output.h (default_emit_except_table_label): Prototype.\n+\t* config/darwin-protos.h (darwin_emit_except_table_label): Ditto.\n+\t* config/darwin.c (darwin_emit_except_table_label): Define.\n+\t* config/darwin.h (TARGET_ASM_EMIT_EXCEPT_TABLE): Ditto.\n+\n 2005-01-06  Zdenek Dvorak <dvorakz@suse.cz>\n \n \tPR tree-optimization/18527\n@@ -379,4 +394,3 @@\n \t* config/rs6000/sync.md (sync_compare_and_swap{hi,qi}): New.\n \t(sync_compare_and_swapqhi_internal): New.\n \t* config/rs6000/rs6000-protos.h: Declare.\n-"}, {"sha": "a22e76f8d79b6a9b8bcb7716b15d47dfebce2b0b", "filename": "gcc/config/darwin-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/083cad550da4f24cb393626c74c4b2d144a11e02/gcc%2Fconfig%2Fdarwin-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/083cad550da4f24cb393626c74c4b2d144a11e02/gcc%2Fconfig%2Fdarwin-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdarwin-protos.h?ref=083cad550da4f24cb393626c74c4b2d144a11e02", "patch": "@@ -60,6 +60,7 @@ extern void darwin_asm_named_section (const char *, unsigned int, tree);\n extern void darwin_non_lazy_pcrel (FILE *, rtx);\n \n extern void darwin_emit_unwind_label (FILE *, tree, int, int);\n+extern void darwin_emit_except_table_label (FILE *);\n \n extern void darwin_pragma_ignore (struct cpp_reader *);\n extern void darwin_pragma_options (struct cpp_reader *);"}, {"sha": "920c4784452c1293ba25ff89953562ef157be319", "filename": "gcc/config/darwin.c", "status": "modified", "additions": 49, "deletions": 38, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/083cad550da4f24cb393626c74c4b2d144a11e02/gcc%2Fconfig%2Fdarwin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/083cad550da4f24cb393626c74c4b2d144a11e02/gcc%2Fconfig%2Fdarwin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdarwin.c?ref=083cad550da4f24cb393626c74c4b2d144a11e02", "patch": "@@ -66,7 +66,7 @@ Boston, MA 02110-1301, USA.  */\n    allows all uses of the old name to forward to the replacement,\n    including existing function pointers and virtual methods.  See\n    rs6000_emit_prologue for the code that handles the nop insertions.\n- \n+\n    The added indirection allows gdb to redirect accesses to static\n    symbols from the newly loaded translation unit to the existing\n    symbol, if any.  @code{static} symbols are special and are handled by\n@@ -89,7 +89,7 @@ output_objc_section_asm_op (const void *directive)\n \n   if (! been_here)\n     {\n-      static const enum darwin_section_enum tomark[] = \n+      static const enum darwin_section_enum tomark[] =\n \t{\n \t  /* written, cold -> hot */\n \t  objc_cat_cls_meth_section,\n@@ -115,7 +115,7 @@ output_objc_section_asm_op (const void *directive)\n \t  objc_symbols_section\n \t};\n       size_t i;\n-      \n+\n       been_here = true;\n       for (i = 0; i < ARRAY_SIZE (tomark); i++)\n \tswitch_to_section (darwin_sections[tomark[i]]);\n@@ -190,10 +190,10 @@ machopic_classify_symbol (rtx sym_ref)\n   flags = SYMBOL_REF_FLAGS (sym_ref);\n   function_p = SYMBOL_REF_FUNCTION_P (sym_ref);\n   if (machopic_symbol_defined_p (sym_ref))\n-    return (function_p \n+    return (function_p\n \t    ? MACHOPIC_DEFINED_FUNCTION : MACHOPIC_DEFINED_DATA);\n   else\n-    return (function_p \n+    return (function_p\n \t    ? MACHOPIC_UNDEFINED_FUNCTION : MACHOPIC_UNDEFINED_DATA);\n }\n \n@@ -256,7 +256,7 @@ void\n machopic_define_symbol (rtx mem)\n {\n   rtx sym_ref;\n-  \n+\n   gcc_assert (GET_CODE (mem) == MEM);\n   sym_ref = XEXP (mem, 0);\n   SYMBOL_REF_FLAGS (sym_ref) |= MACHO_SYMBOL_FLAG_DEFINED;\n@@ -287,7 +287,7 @@ machopic_function_base_sym (void)\n   rtx sym_ref;\n \n   sym_ref = gen_rtx_SYMBOL_REF (Pmode, machopic_function_base_name ());\n-  SYMBOL_REF_FLAGS (sym_ref) \n+  SYMBOL_REF_FLAGS (sym_ref)\n     |= (MACHO_SYMBOL_FLAG_VARIABLE | MACHO_SYMBOL_FLAG_DEFINED);\n   return sym_ref;\n }\n@@ -344,7 +344,7 @@ typedef struct machopic_indirection GTY (())\n /* A table mapping stub names and non-lazy pointer names to\n    SYMBOL_REFs for the stubbed-to and pointed-to entities.  */\n \n-static GTY ((param_is (struct machopic_indirection))) htab_t \n+static GTY ((param_is (struct machopic_indirection))) htab_t\n   machopic_indirections;\n \n /* Return a hash value for a SLOT in the indirections hash table.  */\n@@ -396,7 +396,7 @@ machopic_indirection_name (rtx sym_ref, bool stub_p)\n \t  namelen = strlen (name);\n \t}\n     }\n-  \n+\n   if (name[0] == '*')\n     {\n       saw_star = true;\n@@ -427,11 +427,11 @@ machopic_indirection_name (rtx sym_ref, bool stub_p)\n   sprintf (buffer, \"&%sL%s%s%s%s\", quote, prefix, name, suffix, quote);\n \n   if (!machopic_indirections)\n-    machopic_indirections = htab_create_ggc (37, \n+    machopic_indirections = htab_create_ggc (37,\n \t\t\t\t\t     machopic_indirection_hash,\n \t\t\t\t\t     machopic_indirection_eq,\n \t\t\t\t\t     /*htab_del=*/NULL);\n-  \n+\n   slot = htab_find_slot_with_hash (machopic_indirections, buffer,\n \t\t\t\t   htab_hash_string (buffer), INSERT);\n   if (*slot)\n@@ -447,7 +447,7 @@ machopic_indirection_name (rtx sym_ref, bool stub_p)\n       p->used = false;\n       *slot = p;\n     }\n-  \n+\n   return p->ptr_name;\n }\n \n@@ -469,23 +469,23 @@ void\n machopic_validate_stub_or_non_lazy_ptr (const char *name)\n {\n   machopic_indirection *p;\n-  \n-  p = ((machopic_indirection *) \n+\n+  p = ((machopic_indirection *)\n        (htab_find_with_hash (machopic_indirections, name,\n \t\t\t     htab_hash_string (name))));\n   if (p && ! p->used)\n     {\n       const char *real_name;\n       tree id;\n-      \n+\n       p->used = true;\n \n       /* Do what output_addr_const will do when we actually call it.  */\n       if (SYMBOL_REF_DECL (p->symbol))\n \tmark_decl_referenced (SYMBOL_REF_DECL (p->symbol));\n \n       real_name = targetm.strip_name_encoding (XSTR (p->symbol, 0));\n-      \n+\n       id = maybe_get_identifier (real_name);\n       if (id)\n \tmark_referenced (id);\n@@ -556,7 +556,7 @@ machopic_indirect_data_reference (rtx orig, rtx reg)\n \t}\n \n       ptr_ref = (gen_rtx_SYMBOL_REF\n-\t\t (Pmode, \n+\t\t (Pmode,\n \t\t  machopic_indirection_name (orig, /*stub_p=*/false)));\n \n       SYMBOL_REF_DECL (ptr_ref) = SYMBOL_REF_DECL (orig);\n@@ -633,17 +633,17 @@ machopic_indirect_call_target (rtx target)\n   if (GET_CODE (target) != MEM)\n     return target;\n \n-  if (MACHOPIC_INDIRECT \n+  if (MACHOPIC_INDIRECT\n       && GET_CODE (XEXP (target, 0)) == SYMBOL_REF\n       && !(SYMBOL_REF_FLAGS (XEXP (target, 0))\n \t   & MACHO_SYMBOL_FLAG_DEFINED))\n     {\n       rtx sym_ref = XEXP (target, 0);\n-      const char *stub_name = machopic_indirection_name (sym_ref, \n+      const char *stub_name = machopic_indirection_name (sym_ref,\n \t\t\t\t\t\t\t /*stub_p=*/true);\n       enum machine_mode mode = GET_MODE (sym_ref);\n       tree decl = SYMBOL_REF_DECL (sym_ref);\n-      \n+\n       XEXP (target, 0) = gen_rtx_SYMBOL_REF (mode, stub_name);\n       SYMBOL_REF_DECL (XEXP (target, 0)) = decl;\n       MEM_READONLY_P (target) = 1;\n@@ -727,29 +727,29 @@ machopic_legitimize_pic_address (rtx orig, enum machine_mode mode, rtx reg)\n \t      rtx mem;\n \t      rtx insn;\n \t      rtx sum;\n-\t      \n+\n \t      sum = gen_rtx_HIGH (Pmode, offset);\n \t      if (! MACHO_DYNAMIC_NO_PIC_P)\n \t\tsum = gen_rtx_PLUS (Pmode, pic_offset_table_rtx, sum);\n \n \t      emit_insn (gen_rtx_SET (Pmode, hi_sum_reg, sum));\n \n \t      mem = gen_const_mem (GET_MODE (orig),\n-\t\t\t\t  gen_rtx_LO_SUM (Pmode, \n+\t\t\t\t  gen_rtx_LO_SUM (Pmode,\n \t\t\t\t\t\t  hi_sum_reg, offset));\n \t      insn = emit_insn (gen_rtx_SET (VOIDmode, reg, mem));\n-\t      REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_EQUAL, pic_ref, \n+\t      REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_EQUAL, pic_ref,\n \t\t\t\t\t\t    REG_NOTES (insn));\n \n \t      pic_ref = reg;\n #else\n \t      emit_insn (gen_rtx_USE (VOIDmode,\n-\t\t\t\t      gen_rtx_REG (Pmode, \n+\t\t\t\t      gen_rtx_REG (Pmode,\n \t\t\t\t\t\t   PIC_OFFSET_TABLE_REGNUM)));\n \n \t      emit_insn (gen_rtx_SET (VOIDmode, reg,\n \t\t\t\t      gen_rtx_HIGH (Pmode,\n-\t\t\t\t\t\t    gen_rtx_CONST (Pmode, \n+\t\t\t\t\t\t    gen_rtx_CONST (Pmode,\n \t\t\t\t\t\t\t\t   offset))));\n \t      emit_insn (gen_rtx_SET (VOIDmode, reg,\n \t\t\t\t  gen_rtx_LO_SUM (Pmode, reg,\n@@ -769,7 +769,7 @@ machopic_legitimize_pic_address (rtx orig, enum machine_mode mode, rtx reg)\n \t\t}\n #if 0\n \t      emit_insn (gen_rtx_USE (VOIDmode,\n-\t\t\t\t      gen_rtx_REG (Pmode, \n+\t\t\t\t      gen_rtx_REG (Pmode,\n \t\t\t\t\t\t   PIC_OFFSET_TABLE_REGNUM)));\n #endif\n \n@@ -807,7 +807,7 @@ machopic_legitimize_pic_address (rtx orig, enum machine_mode mode, rtx reg)\n \t\t\t\t      ? gen_rtx_HIGH (Pmode, offset)\n \t\t\t\t      : gen_rtx_PLUS (Pmode,\n \t\t\t\t\t\t      pic_offset_table_rtx,\n-\t\t\t\t\t\t      gen_rtx_HIGH (Pmode, \n+\t\t\t\t\t\t      gen_rtx_HIGH (Pmode,\n \t\t\t\t\t\t\t\t    offset))));\n \t      emit_insn (gen_rtx_SET (VOIDmode, reg,\n \t\t\t\t      gen_rtx_LO_SUM (Pmode,\n@@ -929,14 +929,14 @@ machopic_output_indirection (void **slot, void *data)\n   rtx symbol;\n   const char *sym_name;\n   const char *ptr_name;\n-  \n+\n   if (!p->used)\n     return 1;\n \n   symbol = p->symbol;\n   sym_name = XSTR (symbol, 0);\n   ptr_name = p->ptr_name;\n-  \n+\n   if (p->stub_p)\n     {\n       char *sym;\n@@ -988,11 +988,11 @@ machopic_output_indirection (void **slot, void *data)\n       switch_to_section (darwin_sections[machopic_nl_symbol_ptr_section]);\n       assemble_name (asm_out_file, ptr_name);\n       fprintf (asm_out_file, \":\\n\");\n-      \n+\n       fprintf (asm_out_file, \"\\t.indirect_symbol \");\n       assemble_name (asm_out_file, sym_name);\n       fprintf (asm_out_file, \"\\n\");\n-      \n+\n       /* Variables that are marked with MACHO_SYMBOL_STATIC need to\n \t have their symbol name instead of 0 in the second entry of\n \t the non-lazy symbol pointer data structure when they are\n@@ -1007,7 +1007,7 @@ machopic_output_indirection (void **slot, void *data)\n       assemble_integer (init, GET_MODE_SIZE (Pmode),\n \t\t\tGET_MODE_ALIGNMENT (Pmode), 1);\n     }\n-  \n+\n   return 1;\n }\n \n@@ -1273,14 +1273,14 @@ darwin_globalize_label (FILE *stream, const char *name)\n }\n \n void\n-darwin_asm_named_section (const char *name, \n+darwin_asm_named_section (const char *name,\n \t\t\t  unsigned int flags ATTRIBUTE_UNUSED,\n \t\t\t  tree decl ATTRIBUTE_UNUSED)\n {\n   fprintf (asm_out_file, \"\\t.section %s\\n\", name);\n }\n \n-void \n+void\n darwin_unique_section (tree decl ATTRIBUTE_UNUSED, int reloc ATTRIBUTE_UNUSED)\n {\n   /* Darwin does not use unique sections.  */\n@@ -1313,12 +1313,12 @@ no_dead_strip (FILE *file, const char *lab)\n   fprintf (file, \".no_dead_strip %s\\n\", lab);\n }\n \n-/* Emit a label for an FDE, making it global and/or weak if appropriate. \n+/* Emit a label for an FDE, making it global and/or weak if appropriate.\n    The third parameter is nonzero if this is for exception handling.\n    The fourth parameter is nonzero if this is just a placeholder for an\n    FDE that we are omitting. */\n \n-void \n+void\n darwin_emit_unwind_label (FILE *file, tree decl, int for_eh, int empty)\n {\n   tree id = DECL_ASSEMBLER_NAME (decl)\n@@ -1377,7 +1377,18 @@ darwin_emit_unwind_label (FILE *file, tree decl, int for_eh, int empty)\n   free (lab);\n }\n \n-/* Generate a PC-relative reference to a Mach-O non-lazy-symbol.  */ \n+static GTY(()) unsigned long except_table_label_num;\n+\n+void\n+darwin_emit_except_table_label (FILE *file)\n+{\n+  char section_start_label[30];\n+\n+  ASM_GENERATE_INTERNAL_LABEL (section_start_label, \"GCC_except_table\",\n+\t\t\t       except_table_label_num++);\n+  ASM_OUTPUT_LABEL (file, section_start_label);\n+}\n+/* Generate a PC-relative reference to a Mach-O non-lazy-symbol.  */\n \n void\n darwin_non_lazy_pcrel (FILE *file, rtx addr)\n@@ -1398,7 +1409,7 @@ darwin_non_lazy_pcrel (FILE *file, rtx addr)\n    extern\".  There is no MACH-O equivalent of ELF's\n    VISIBILITY_INTERNAL or VISIBILITY_PROTECTED. */\n \n-void \n+void\n darwin_assemble_visibility (tree decl, int vis)\n {\n   if (vis == VISIBILITY_DEFAULT)"}, {"sha": "70481bbea4c886c9abacdab0bb02cb440b9b9e50", "filename": "gcc/config/darwin.h", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/083cad550da4f24cb393626c74c4b2d144a11e02/gcc%2Fconfig%2Fdarwin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/083cad550da4f24cb393626c74c4b2d144a11e02/gcc%2Fconfig%2Fdarwin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdarwin.h?ref=083cad550da4f24cb393626c74c4b2d144a11e02", "patch": "@@ -303,8 +303,8 @@ Boston, MA 02110-1301, USA.  */\n    be in a new format, or the fallback routine might be changed; if\n    you want to explicitly link against the static version of those\n    routines, because you know you don't need to unwind through system\n-   libraries, you need to explicitly say -static-libgcc.  \n-   \n+   libraries, you need to explicitly say -static-libgcc.\n+\n    If it is linked against, it has to be before -lgcc, because it may\n    need symbols from -lgcc.  */\n #undef REAL_LIBGCC_SPEC\n@@ -317,7 +317,7 @@ Boston, MA 02110-1301, USA.  */\n       :%:version-compare(>< 10.3.9 10.5 mmacosx-version-min= -lgcc_s.10.4) \\\n        %:version-compare(>= 10.5 mmacosx-version-min= -lgcc_s.10.5)\t   \\\n        -lgcc}\"\n-\t\t\t \n+\n /* We specify crt0.o as -lcrt0.o so that ld will search the library path.  */\n \n #undef  STARTFILE_SPEC\n@@ -436,6 +436,9 @@ Boston, MA 02110-1301, USA.  */\n    emit a label for an empty FDE. */\n #define TARGET_ASM_EMIT_UNWIND_LABEL darwin_emit_unwind_label\n \n+/* Emit a label to separate the exception table.  */\n+#define TARGET_ASM_EMIT_EXCEPT_TABLE_LABEL darwin_emit_except_table_label\n+\n /* Our profiling scheme doesn't LP labels and counter words.  */\n \n #define NO_PROFILE_COUNTERS\t1"}, {"sha": "61b22e42ccf66b83f8d7165c7c67b453dca61de2", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 27, "deletions": 19, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/083cad550da4f24cb393626c74c4b2d144a11e02/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/083cad550da4f24cb393626c74c4b2d144a11e02/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=083cad550da4f24cb393626c74c4b2d144a11e02", "patch": "@@ -1530,7 +1530,7 @@ default is @code{LONG_DOUBLE_TYPE_SIZE}.\n @end defmac\n \n @defmac LIBGCC2_HAS_DF_MODE\n-Define this macro if neither @code{LIBGCC2_DOUBLE_TYPE_SIZE} nor \n+Define this macro if neither @code{LIBGCC2_DOUBLE_TYPE_SIZE} nor\n @code{LIBGCC2_LONG_DOUBLE_TYPE_SIZE} is\n @code{DFmode} but you want @code{DFmode} routines in @file{libgcc2.a}\n anyway.  If you don't define this and either @code{LIBGCC2_DOUBLE_TYPE_SIZE}\n@@ -1539,14 +1539,14 @@ otherwise it is 0.\n @end defmac\n \n @defmac LIBGCC2_HAS_XF_MODE\n-Define this macro if @code{LIBGCC2_LONG_DOUBLE_TYPE_SIZE} is not \n+Define this macro if @code{LIBGCC2_LONG_DOUBLE_TYPE_SIZE} is not\n @code{XFmode} but you want @code{XFmode} routines in @file{libgcc2.a}\n anyway.  If you don't define this and @code{LIBGCC2_LONG_DOUBLE_TYPE_SIZE}\n is 80 then the default is 1, otherwise it is 0.\n @end defmac\n \n @defmac LIBGCC2_HAS_TF_MODE\n-Define this macro if @code{LIBGCC2_LONG_DOUBLE_TYPE_SIZE} is not \n+Define this macro if @code{LIBGCC2_LONG_DOUBLE_TYPE_SIZE} is not\n @code{TFmode} but you want @code{TFmode} routines in @file{libgcc2.a}\n anyway.  If you don't define this and @code{LIBGCC2_LONG_DOUBLE_TYPE_SIZE}\n is 128 then the default is 1, otherwise it is 0.\n@@ -2504,7 +2504,7 @@ forwarding logic, you can set @code{sri->extra_cost} to a negative amount.\n @defmac SECONDARY_RELOAD_CLASS (@var{class}, @var{mode}, @var{x})\n @defmacx SECONDARY_INPUT_RELOAD_CLASS (@var{class}, @var{mode}, @var{x})\n @defmacx SECONDARY_OUTPUT_RELOAD_CLASS (@var{class}, @var{mode}, @var{x})\n-These macros are obsolete, new ports should use the target hook \n+These macros are obsolete, new ports should use the target hook\n @code{TARGET_SECONDARY_RELOAD} instead.\n \n These are obsolete macros, replaced by the @code{TARGET_SECONDARY_RELOAD}\n@@ -2901,10 +2901,10 @@ machines.  See @file{function.c} for details.\n \n @defmac INITIAL_FRAME_ADDRESS_RTX\n A C expression whose value is RTL representing the address of the initial\n-stack frame. This address is passed to @code{RETURN_ADDR_RTX} and \n+stack frame. This address is passed to @code{RETURN_ADDR_RTX} and\n @code{DYNAMIC_CHAIN_ADDRESS}.  If you don't define this macro, a reasonable\n default value will be used.  Define this macro in order to make frame pointer\n-elimination work in the presence of @code{__builtin_frame_address (count)} and \n+elimination work in the presence of @code{__builtin_frame_address (count)} and\n @code{__builtin_return_address (count)} for @code{count} not equal to zero.\n @end defmac\n \n@@ -3034,7 +3034,7 @@ The final value should conincide with that calculated by\n @code{INCOMING_FRAME_SP_OFFSET}.\n \n Normally the CFA is calculated as an offset from the argument pointer,\n-via @code{ARG_POINTER_CFA_OFFSET}, but if the argument pointer is \n+via @code{ARG_POINTER_CFA_OFFSET}, but if the argument pointer is\n variable due to the ABI, this may not be possible.  If this macro is\n defined, it implies that the virtual register instantiation should be\n based on the frame pointer instead of the argument pointer.  Only one\n@@ -4487,7 +4487,7 @@ may vary greatly between different architectures.\n \n @deftypefn {Target Hook} tree TARGET_STACK_PROTECT_GUARD (void)\n This hook returns a @code{DECL} node for the external variable to use\n-for the stack protection guard.  This variable is initialized by the \n+for the stack protection guard.  This variable is initialized by the\n runtime to some random value and is used to initialize the guard value\n that is placed at the top of the local stack frame.  The type of this\n variable must be @code{ptr_type_node}.\n@@ -4502,7 +4502,7 @@ stack protect guard variable has been modified.  This expression should\n involve a call to a @code{noreturn} function.\n \n The default version of this hook invokes a function called\n-@samp{__stack_chk_fail}, taking no arguments.  This function is \n+@samp{__stack_chk_fail}, taking no arguments.  This function is\n normally defined in @file{libgcc2.c}.\n @end deftypefn\n \n@@ -5201,7 +5201,7 @@ of TLS symbols for various targets.\n @deftypefn {Target Hook} tree TARGET_VECTORIZE_BUILTIN_MASK_FOR_LOAD (void)\n This hook should return the DECL of a function @var{f} that given an\n address @var{addr} as an argument returns a mask @var{m} that can be\n-used to extract from two vectors the relevant data that resides in \n+used to extract from two vectors the relevant data that resides in\n @var{addr} in case @var{addr} is not properly aligned.\n \n The autovectrizer, when vectorizing a load operation from an address\n@@ -5212,15 +5212,15 @@ two loaded vectors. The first two arguments to @code{REALIGN_LOAD},\n @var{v1} and @var{v2}, are the two vectors, each of size @var{VS}, and\n the third argument, @var{OFF}, defines how the data will be extracted\n from these two vectors: if @var{OFF} is 0, then the returned vector is\n-@var{v2}; otherwise, the returned vector is composed from the last \n-@var{VS}-@var{OFF} elements of @var{v1} concatenated to the first \n+@var{v2}; otherwise, the returned vector is composed from the last\n+@var{VS}-@var{OFF} elements of @var{v1} concatenated to the first\n @var{OFF} elements of @var{v2}.\n \n If this hook is defined, the autovectorizer will generate a call\n to @var{f} (using the DECL tree that this hook returns) and will\n use the return value of @var{f} as the argument @var{OFF} to\n @code{REALIGN_LOAD}. Therefore, the mask @var{m} returned by @var{f}\n-should comply with the semantics expected by @code{REALIGN_LOAD} \n+should comply with the semantics expected by @code{REALIGN_LOAD}\n described above.\n If this hook is not defined, then @var{addr} will be used as\n the argument @var{OFF} to @code{REALIGN_LOAD}, in which case the low\n@@ -6031,7 +6031,7 @@ part of the @code{.init_array} (or equivalent) section.  If not\n defined, GCC will assume such a section does not exist.  Do not define\n both this macro and @code{INIT_SECTION_ASM_OP}.\n @end defmac\n- \n+\n @defmac FINI_ARRAY_SECTION_ASM_OP\n If defined, a C expression whose value is a string, including spacing,\n containing the assembler operation to identify the following data as\n@@ -7687,7 +7687,15 @@ true if this is a placeholder label for an omitted FDE@.\n The default is that FDEs are not given nonlocal labels.\n @end deftypefn\n \n-@deftypefn {Taget Hook} void TARGET_UNWIND_EMIT (FILE * @var{stream}, rtx @var{insn})\n+@deftypefn {Target Hook} void TARGET_ASM_EMIT_EXCEPT_TABLE_LABEL (@var{stream})\n+This target hook emits a label at the beginning of the exception table.\n+It should be defined on targets where it is desirable for the table\n+to be broken up according to function.\n+\n+The default is that no label is emitted.\n+@end deftypefn\n+\n+@deftypefn {Target Hook} void TARGET_UNWIND_EMIT (FILE * @var{stream}, rtx @var{insn})\n This target hook emits and assembly directives required to unwind the\n given instruction.  This is only used when TARGET_UNWIND_INFO is set.\n @end deftypefn\n@@ -9480,9 +9488,9 @@ low-overhead loop, otherwise return a string why doloop could not be applied.\n \n Many targets use special registers for low-overhead looping. For any\n instruction that clobbers these this function should return a string indicating\n-the reason why the doloop could not be applied. \n+the reason why the doloop could not be applied.\n By default, the RTL loop optimizer does not use a present doloop pattern for\n-loops containing function calls or branch on table instructions.  \n+loops containing function calls or branch on table instructions.\n @end deftypefn\n \n @defmac MD_CAN_REDIRECT_BRANCH (@var{branch1}, @var{branch2})\n@@ -9661,8 +9669,8 @@ and ia64.  The default is @code{false}.\n @end deftypefn\n \n @deftypefn {Target Hook} const char *TARGET_INVALID_ARG_FOR_UNPROTOTYPED_FN (tree @var{typelist}, tree @var{funcdecl}, tree @var{val})\n-If defined, this macro returns the diagnostic message when it is \n-illegal to pass argument @var{val} to function @var{funcdecl} \n+If defined, this macro returns the diagnostic message when it is\n+illegal to pass argument @var{val} to function @var{funcdecl}\n with prototype @var{typelist}.\n @end deftypefn\n "}, {"sha": "19aeac8ee7fbc88226fc929e3b1301c5658178bc", "filename": "gcc/except.c", "status": "modified", "additions": 29, "deletions": 27, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/083cad550da4f24cb393626c74c4b2d144a11e02/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/083cad550da4f24cb393626c74c4b2d144a11e02/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=083cad550da4f24cb393626c74c4b2d144a11e02", "patch": "@@ -134,7 +134,7 @@ struct eh_region GTY(())\n \n   /* Each region does exactly one thing.  */\n   enum eh_region_type\n-  { \n+  {\n     ERT_UNKNOWN = 0,\n     ERT_CLEANUP,\n     ERT_TRY,\n@@ -251,7 +251,6 @@ struct eh_status GTY(())\n \n   htab_t GTY((param_is (struct throw_stmt_node))) throw_stmt_table;\n };\n-\n \f\n static int t2r_eq (const void *, const void *);\n static hashval_t t2r_hash (const void *);\n@@ -442,7 +441,7 @@ init_eh_for_function (void)\n   cfun->eh = ggc_alloc_cleared (sizeof (struct eh_status));\n }\n \f\n-/* Routines to generate the exception tree somewhat directly.  \n+/* Routines to generate the exception tree somewhat directly.\n    These are used from tree-eh.c when processing exception related\n    nodes during tree optimization.  */\n \n@@ -738,7 +737,7 @@ remove_unreachable_regions (rtx insns)\n \t    default:\n \t      break;\n \t    }\n-\t      \n+\n \t  if (kill_it)\n \t    remove_eh_handler (r);\n \t}\n@@ -864,11 +863,11 @@ duplicate_eh_region_1 (struct eh_region *o)\n   struct eh_region *n = ggc_alloc_cleared (sizeof (struct eh_region));\n \n   *n = *o;\n-  \n+\n   n->region_number = o->region_number + cfun->eh->last_region_number;\n   VEC_replace (eh_region, cfun->eh->region_array, n->region_number, n);\n   gcc_assert (!o->aka);\n-  \n+\n   return n;\n }\n \n@@ -877,7 +876,7 @@ duplicate_eh_region_2 (struct eh_region *o, struct eh_region **n_array,\n \t\t       struct eh_region *prev_try)\n {\n   struct eh_region *n = n_array[o->region_number];\n-  \n+\n   switch (n->type)\n     {\n     case ERT_TRY:\n@@ -886,7 +885,7 @@ duplicate_eh_region_2 (struct eh_region *o, struct eh_region **n_array,\n       if (o->u.try.last_catch)\n         n->u.try.last_catch = n_array[o->u.try.last_catch->region_number];\n       break;\n-      \n+\n     case ERT_CATCH:\n       if (o->u.catch.next_catch)\n \tn->u.catch.next_catch = n_array[o->u.catch.next_catch->region_number];\n@@ -900,11 +899,11 @@ duplicate_eh_region_2 (struct eh_region *o, struct eh_region **n_array,\n       else\n         n->u.cleanup.prev_try = prev_try;\n       break;\n-      \n+\n     default:\n       break;\n     }\n-  \n+\n   if (o->outer)\n     n->outer = n_array[o->outer->region_number];\n   if (o->inner)\n@@ -922,10 +921,10 @@ duplicate_eh_regions (struct function *ifun, duplicate_eh_regions_map map,\n   int ifun_last_region_number = ifun->eh->last_region_number;\n   struct eh_region **n_array, *root, *cur, *prev_try;\n   int i;\n-  \n+\n   if (ifun_last_region_number == 0 || !ifun->eh->region_tree)\n     return 0;\n-  \n+\n   n_array = xcalloc (ifun_last_region_number + 1, sizeof (*n_array));\n   VEC_safe_grow (eh_region, gc, cfun->eh->region_array,\n \t\t cfun->eh->last_region_number + 1 + ifun_last_region_number);\n@@ -936,7 +935,7 @@ duplicate_eh_regions (struct function *ifun, duplicate_eh_regions_map map,\n   for (i = cfun->eh->last_region_number + 1;\n        i < cfun->eh->last_region_number + 1 + ifun_last_region_number; i++)\n     VEC_replace (eh_region, cfun->eh->region_array, i, 0);\n-    \n+\n   /* Search for the containing ERT_TRY region to fix up\n      the prev_try short-cuts for ERT_CLEANUP regions.  */\n   prev_try = NULL;\n@@ -967,7 +966,7 @@ duplicate_eh_regions (struct function *ifun, duplicate_eh_regions_map map,\n \tcontinue;\n       duplicate_eh_region_2 (cur, n_array, prev_try);\n     }\n-  \n+\n   root = n_array[ifun->eh->region_tree->region_number];\n   gcc_assert (root->outer == NULL);\n   if (outer_region > 0)\n@@ -1000,12 +999,12 @@ duplicate_eh_regions (struct function *ifun, duplicate_eh_regions_map map,\n       else\n         cfun->eh->region_tree = root;\n     }\n-  \n+\n   free (n_array);\n-  \n+\n   i = cfun->eh->last_region_number;\n   cfun->eh->last_region_number = i + ifun_last_region_number;\n-  \n+\n   return i;\n }\n \f\n@@ -1268,7 +1267,7 @@ emit_to_new_bb_before (rtx seq, rtx insn)\n   edge_iterator ei;\n \n   /* If there happens to be a fallthru edge (possibly created by cleanup_cfg\n-     call), we don't want it to go into newly created landing pad or other EH \n+     call), we don't want it to go into newly created landing pad or other EH\n      construct.  */\n   for (ei = ei_start (BLOCK_FOR_INSN (insn)->preds); (e = ei_safe_edge (ei)); )\n     if (e->flags & EDGE_FALLTHRU)\n@@ -1339,7 +1338,7 @@ build_post_landing_pads (void)\n \t\t\temit_cmp_and_jump_insns\n \t\t\t  (cfun->eh->filter,\n \t\t\t   GEN_INT (tree_low_cst (TREE_VALUE (flt_node), 0)),\n-\t\t\t   EQ, NULL_RTX, \n+\t\t\t   EQ, NULL_RTX,\n \t\t\t   targetm.eh_return_filter_mode (), 0, c->label);\n \n \t\t\ttp_node = TREE_CHAIN (tp_node);\n@@ -1372,7 +1371,7 @@ build_post_landing_pads (void)\n \n \t  emit_cmp_and_jump_insns (cfun->eh->filter,\n \t\t\t\t   GEN_INT (region->u.allowed.filter),\n-\t\t\t\t   EQ, NULL_RTX, \n+\t\t\t\t   EQ, NULL_RTX,\n \t\t\t\t   targetm.eh_return_filter_mode (), 0, region->label);\n \n \t  /* We delay the generation of the _Unwind_Resume until we generate\n@@ -1552,7 +1551,7 @@ dw2_build_landing_pads (void)\n       emit_move_insn (cfun->eh->exc_ptr,\n \t\t      gen_rtx_REG (ptr_mode, EH_RETURN_DATA_REGNO (0)));\n       emit_move_insn (cfun->eh->filter,\n-\t\t      gen_rtx_REG (targetm.eh_return_filter_mode (), \n+\t\t      gen_rtx_REG (targetm.eh_return_filter_mode (),\n \t\t\t\t   EH_RETURN_DATA_REGNO (1)));\n \n       seq = get_insns ();\n@@ -2451,7 +2450,7 @@ reachable_next_level (struct eh_region *region, tree type_thrown,\n       /* Here we end our search, since no exceptions may propagate.\n \t If we've touched down at some landing pad previous, then the\n \t explicit function call we generated may be used.  Otherwise\n-\t the call is made by the runtime. \n+\t the call is made by the runtime.\n \n          Before inlining, do not perform this optimization.  We may\n \t inline a subroutine that contains handlers, and that will\n@@ -3095,7 +3094,7 @@ collect_one_action_chain (htab_t ar_hash, struct eh_region *region)\n \t Add a cleanup action to the chain to catch these.  */\n       else if (next <= 0)\n \tnext = add_action_record (ar_hash, 0, 0);\n-      \n+\n       return add_action_record (ar_hash, region->u.allowed.filter, next);\n \n     case ERT_MUST_NOT_THROW:\n@@ -3539,6 +3538,9 @@ output_function_exception_table (void)\n   switch_to_exception_section ();\n #endif\n \n+  /* If the target wants a label to begin the table, emit it here.  */\n+  targetm.asm_out.except_table_label (asm_out_file);\n+\n   have_tt_data = (VEC_length (tree, cfun->eh->ttype_data) > 0\n \t\t  || VARRAY_ACTIVE_SIZE (cfun->eh->ehspec_data) > 0);\n \n@@ -3706,7 +3708,7 @@ get_eh_throw_stmt_table (struct function *fun)\n }\n \n /* Dump EH information to OUT.  */\n-void \n+void\n dump_eh_tree (FILE *out, struct function *fun)\n {\n   struct eh_region *i;\n@@ -3752,7 +3754,7 @@ dump_eh_tree (FILE *out, struct function *fun)\n \n /* Verify some basic invariants on EH datastructures.  Could be extended to\n    catch more.  */\n-void \n+void\n verify_eh_tree (struct function *fun)\n {\n   struct eh_region *i, *outer = NULL;\n@@ -3868,8 +3870,8 @@ rest_of_handle_eh (void)\n struct tree_opt_pass pass_rtl_eh =\n {\n   \"eh\",                                 /* name */\n-  gate_handle_eh,                       /* gate */   \n-  rest_of_handle_eh,\t\t\t/* execute */       \n+  gate_handle_eh,                       /* gate */\n+  rest_of_handle_eh,\t\t\t/* execute */\n   NULL,                                 /* sub */\n   NULL,                                 /* next */\n   0,                                    /* static_pass_number */"}, {"sha": "d4fad194bb5bd68da91a6f8ed15c87f21851e712", "filename": "gcc/output.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/083cad550da4f24cb393626c74c4b2d144a11e02/gcc%2Foutput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/083cad550da4f24cb393626c74c4b2d144a11e02/gcc%2Foutput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foutput.h?ref=083cad550da4f24cb393626c74c4b2d144a11e02", "patch": "@@ -550,6 +550,7 @@ extern bool default_binds_local_p (tree);\n extern bool default_binds_local_p_1 (tree, int);\n extern void default_globalize_label (FILE *, const char *);\n extern void default_emit_unwind_label (FILE *, tree, int, int);\n+extern void default_emit_except_table_label (FILE *);\n extern void default_internal_label (FILE *, const char *, unsigned long);\n extern void default_file_start (void);\n extern void file_end_indicate_exec_stack (void);"}, {"sha": "204be4e6030af624bafe6e0d76057020f5fcebce", "filename": "gcc/target-def.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/083cad550da4f24cb393626c74c4b2d144a11e02/gcc%2Ftarget-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/083cad550da4f24cb393626c74c4b2d144a11e02/gcc%2Ftarget-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-def.h?ref=083cad550da4f24cb393626c74c4b2d144a11e02", "patch": "@@ -62,6 +62,10 @@ Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n #define TARGET_ASM_EMIT_UNWIND_LABEL default_emit_unwind_label\n #endif\n \n+#ifndef TARGET_ASM_EMIT_EXCEPT_TABLE_LABEL\n+#define TARGET_ASM_EMIT_EXCEPT_TABLE_LABEL default_emit_except_table_label\n+#endif\n+\n #ifndef TARGET_UNWIND_EMIT\n #define TARGET_UNWIND_EMIT default_unwind_emit\n #endif\n@@ -221,6 +225,7 @@ Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n \t\t\tTARGET_ASM_INTEGER,\t\t\t\\\n \t\t\tTARGET_ASM_GLOBALIZE_LABEL,\t\t\\\n                         TARGET_ASM_EMIT_UNWIND_LABEL,           \\\n+\t\t\tTARGET_ASM_EMIT_EXCEPT_TABLE_LABEL,\t\\\n \t\t\tTARGET_UNWIND_EMIT,\t\t\t\\\n \t\t\tTARGET_ASM_INTERNAL_LABEL,\t\t\\\n \t\t\tTARGET_ASM_TTYPE,\t\t\t\\"}, {"sha": "8c61bfe9692016e3068d8214bd2b7f3ff1f1f841", "filename": "gcc/target.h", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/083cad550da4f24cb393626c74c4b2d144a11e02/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/083cad550da4f24cb393626c74c4b2d144a11e02/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=083cad550da4f24cb393626c74c4b2d144a11e02", "patch": "@@ -102,6 +102,10 @@ struct gcc_target\n        this is only a placeholder for an omitted FDE.  */\n     void (* unwind_label) (FILE *, tree, int, int);\n \n+    /* Output code that will emit a label to divide up the exception\n+       table.  */\n+    void (* except_table_label) (FILE *);\n+\n     /* Emit any directives required to unwind this instruction.  */\n     void (* unwind_emit) (FILE *, rtx);\n \n@@ -373,7 +377,7 @@ struct gcc_target\n \n   /* Fold a target-specific builtin.  */\n   tree (* fold_builtin) (tree fndecl, tree arglist, bool ignore);\n-  \n+\n   /* For a vendor-specific fundamental TYPE, return a pointer to\n      a statically-allocated string containing the C++ mangling for\n      TYPE.  In all other cases, return NULL.  */\n@@ -569,7 +573,7 @@ struct gcc_target\n      specified.  Use this hook if the target needs to add extra validation\n      checks to  handle_dll_attribute ().  */\n   bool (* valid_dllimport_attribute_p) (tree decl);\n-    \n+\n   /* Functions relating to calls - argument passing, returns, etc.  */\n   struct calls {\n     bool (*promote_function_args) (tree fntype);\n@@ -620,7 +624,7 @@ struct gcc_target\n \n     /* Return the diagnostic message string if function without a prototype\n        is not allowed for this 'val' argument; NULL otherwise. */\n-    const char *(*invalid_arg_for_unprototyped_fn) (tree typelist, \n+    const char *(*invalid_arg_for_unprototyped_fn) (tree typelist,\n \t\t\t\t\t     \t    tree funcdecl, tree val);\n \n     /* Return an rtx for the return value location of the function\n@@ -677,7 +681,7 @@ struct gcc_target\n        visibility has been explicitly specified.  If the target needs\n        to specify a visibility other than that of the containing class,\n        use this hook to set DECL_VISIBILITY and\n-       DECL_VISIBILITY_SPECIFIED.  */ \n+       DECL_VISIBILITY_SPECIFIED.  */\n     void (*determine_class_data_visibility) (tree decl);\n     /* Returns true (the default) if virtual tables and other\n        similar implicit class data objects are always COMDAT if they\n@@ -691,7 +695,7 @@ struct gcc_target\n     /* TYPE is a C++ class (i.e., RECORD_TYPE or UNION_TYPE) that\n        has just been defined.  Use this hook to make adjustments to the\n        class  (eg, tweak visibility or perform any other required\n-       target modifications).  */  \n+       target modifications).  */\n     void (*adjust_class_at_definition) (tree type);\n   } cxx;\n "}, {"sha": "05bfabf288d87bbcff6c83343478549539ec8708", "filename": "gcc/varasm.c", "status": "modified", "additions": 42, "deletions": 34, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/083cad550da4f24cb393626c74c4b2d144a11e02/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/083cad550da4f24cb393626c74c4b2d144a11e02/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=083cad550da4f24cb393626c74c4b2d144a11e02", "patch": "@@ -435,10 +435,10 @@ section *\n function_section (tree decl)\n {\n   int reloc = 0;\n-    \n+\n   if (first_function_block_is_cold)\n     reloc = 1;\n-  \n+\n #ifdef USE_SELECT_SECTION_FOR_FUNCTIONS\n   return targetm.asm_out.select_section (decl, reloc, DECL_ALIGN (decl));\n #else\n@@ -473,7 +473,7 @@ default_function_rodata_section (tree decl)\n         {\n \t  size_t len = strlen (name) + 3;\n \t  char* rname = alloca (len);\n-         \n+\n \t  strcpy (rname, \".rodata\");\n \t  strcat (rname, name + 5);\n \t  return get_section (rname, SECTION_LINKONCE, decl);\n@@ -720,7 +720,7 @@ make_decl_rtl (tree decl)\n \t      || TREE_PUBLIC (decl)\n \t      || DECL_EXTERNAL (decl)\n \t      || DECL_REGISTER (decl));\n-  \n+\n   /* And that we were not given a type or a label.  */\n   gcc_assert (TREE_CODE (decl) != TYPE_DECL\n \t      && TREE_CODE (decl) != LABEL_DECL);\n@@ -755,11 +755,11 @@ make_decl_rtl (tree decl)\n     }\n \n   name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n-  \n+\n   if (name[0] != '*' && TREE_CODE (decl) != FUNCTION_DECL\n       && DECL_REGISTER (decl))\n     {\n-      error (\"register name not specified for %q+D\", decl);\t\n+      error (\"register name not specified for %q+D\", decl);\n     }\n   else if (TREE_CODE (decl) != FUNCTION_DECL && DECL_REGISTER (decl))\n     {\n@@ -1051,7 +1051,7 @@ assemble_start_function (tree decl, const char *fnname)\n   bool hot_label_written = false;\n \n   cfun->unlikely_text_section_name = NULL;\n- \n+\n   first_function_block_is_cold = false;\n   if (flag_reorder_blocks_and_partition)\n     {\n@@ -1115,7 +1115,7 @@ assemble_start_function (tree decl, const char *fnname)\n \n       initialize_cold_section_name ();\n \n-      if (cfun->unlikely_text_section_name \n+      if (cfun->unlikely_text_section_name\n \t  && strcmp (TREE_STRING_POINTER (DECL_SECTION_NAME (decl)),\n \t\t     cfun->unlikely_text_section_name) == 0)\n \tfirst_function_block_is_cold = true;\n@@ -1126,7 +1126,7 @@ assemble_start_function (tree decl, const char *fnname)\n   /* Switch to the correct text section for the start of the function.  */\n \n   switch_to_section (function_section (decl));\n-  if (flag_reorder_blocks_and_partition \n+  if (flag_reorder_blocks_and_partition\n       && !hot_label_written)\n     ASM_OUTPUT_LABEL (asm_out_file, cfun->hot_section_label);\n \n@@ -2087,7 +2087,7 @@ assemble_integer (rtx x, unsigned int size, unsigned int align, int force)\n     }\n \n   gcc_assert (!force);\n-  \n+\n   return false;\n }\n \f\n@@ -2266,13 +2266,13 @@ const_hash_1 (const tree exp)\n       {\n \tunsigned HOST_WIDE_INT idx;\n \ttree value;\n-\t\n+\n \thi = 5 + int_size_in_bytes (TREE_TYPE (exp));\n-\t\n+\n \tFOR_EACH_CONSTRUCTOR_VALUE (CONSTRUCTOR_ELTS (exp), idx, value)\n \t  if (value)\n \t    hi = hi * 603 + const_hash_1 (value);\n-\t\n+\n \treturn hi;\n       }\n \n@@ -2384,7 +2384,7 @@ compare_constant (const tree t1, const tree t2)\n       {\n \tVEC(constructor_elt, gc) *v1, *v2;\n \tunsigned HOST_WIDE_INT idx;\n-\t\n+\n \ttypecode = TREE_CODE (TREE_TYPE (t1));\n \tif (typecode != TREE_CODE (TREE_TYPE (t2)))\n \t  return 0;\n@@ -2432,7 +2432,7 @@ compare_constant (const tree t1, const tree t2)\n \t\t  return 0;\n \t      }\n \t  }\n-\t\n+\n \treturn 1;\n       }\n \n@@ -2520,7 +2520,7 @@ copy_constant (tree exp)\n \tVEC(constructor_elt, gc) *v;\n \tunsigned HOST_WIDE_INT idx;\n \ttree purpose, value;\n-\t\n+\n \tv = VEC_alloc(constructor_elt, gc, VEC_length(constructor_elt,\n \t\t\t\t\t\t      CONSTRUCTOR_ELTS (exp)));\n \tFOR_EACH_CONSTRUCTOR_ELT (CONSTRUCTOR_ELTS (exp), idx, purpose, value)\n@@ -2536,7 +2536,7 @@ copy_constant (tree exp)\n     default:\n       {\n \ttree t = lang_hooks.expand_constant (exp);\n-\t\n+\n \tgcc_assert (t == exp);\n \treturn copy_constant (t);\n       }\n@@ -2952,7 +2952,7 @@ force_const_mem (enum machine_mode mode, rtx x)\n   hash = const_rtx_hash (x);\n   slot = htab_find_slot_with_hash (pool->const_rtx_htab, &tmp, hash, INSERT);\n   desc = *slot;\n-  \n+\n   /* If the constant was already present, return its memory.  */\n   if (desc)\n     return copy_rtx (desc->mem);\n@@ -3087,13 +3087,13 @@ output_constant_pool_2 (enum machine_mode mode, rtx x, unsigned int align)\n     case MODE_DECIMAL_FLOAT:\n       {\n \tREAL_VALUE_TYPE r;\n-\t\n+\n \tgcc_assert (GET_CODE (x) == CONST_DOUBLE);\n \tREAL_VALUE_FROM_CONST_DOUBLE (r, x);\n \tassemble_real (r, mode, align);\n \tbreak;\n       }\n-      \n+\n     case MODE_INT:\n     case MODE_PARTIAL_INT:\n       assemble_integer (x, GET_MODE_SIZE (mode), align, 1);\n@@ -3226,7 +3226,7 @@ mark_constant (rtx *current_rtx, void *data)\n     }\n \n   return -1;\n-} \n+}\n \n /* Look through appropriate parts of INSN, marking all entries in the\n    constant pool which are actually being used.  Entries that are only\n@@ -3493,7 +3493,7 @@ initializer_constant_valid_p (tree value, tree endtype)\n \t    return null_pointer_node;\n \t  /* Taking the address of a nested function involves a trampoline.  */\n \t  if (TREE_CODE (value) == FUNCTION_DECL\n-\t      && ((decl_function_context (value) \n+\t      && ((decl_function_context (value)\n \t\t   && !DECL_NO_STATIC_CHAIN (value))\n \t\t  || DECL_DLLIMPORT_P (value)))\n \t    return NULL_TREE;\n@@ -3828,12 +3828,12 @@ output_constant (tree exp, unsigned HOST_WIDE_INT size, unsigned int align)\n \t    tree link;\n \t    unsigned int nalign;\n \t    enum machine_mode inner;\n-\t    \n+\n \t    inner = TYPE_MODE (TREE_TYPE (TREE_TYPE (exp)));\n \t    nalign = MIN (align, GET_MODE_ALIGNMENT (inner));\n-\t    \n+\n \t    elt_size = GET_MODE_SIZE (inner);\n-\t    \n+\n \t    link = TREE_VECTOR_CST_ELTS (exp);\n \t    output_constant (TREE_VALUE (link), elt_size, align);\n \t    while ((link = TREE_CHAIN (link)) != NULL)\n@@ -3961,8 +3961,8 @@ output_constructor (tree exp, unsigned HOST_WIDE_INT size,\n #ifdef ASM_COMMENT_START\n       if (field && flag_verbose_asm)\n \tfprintf (asm_out_file, \"%s %s:\\n\",\n-\t\t ASM_COMMENT_START, \n-\t\t DECL_NAME (field) \n+\t\t ASM_COMMENT_START,\n+\t\t DECL_NAME (field)\n \t\t ? IDENTIFIER_POINTER (DECL_NAME (field))\n \t\t : \"<anonymous>\");\n #endif\n@@ -4543,7 +4543,7 @@ find_decl_and_mark_needed (tree decl, tree target)\n       cgraph_varpool_mark_needed_node (vnode);\n       return vnode->decl;\n     }\n-  else \n+  else\n     return NULL_TREE;\n }\n \n@@ -4938,10 +4938,10 @@ default_section_type_flags_1 (tree decl, const char *name, int reloc,\n \t   && cfun->unlikely_text_section_name\n \t   && strcmp (name, cfun->unlikely_text_section_name) == 0)\n     flags = SECTION_CODE;\n-  else if (!decl \n+  else if (!decl\n \t   && (!current_function_decl || !cfun)\n \t   && strcmp (name, UNLIKELY_EXECUTED_TEXT_SECTION_NAME) == 0)\n-    flags = SECTION_CODE; \n+    flags = SECTION_CODE;\n   else\n     flags = SECTION_WRITE;\n \n@@ -5055,15 +5055,15 @@ default_elf_asm_named_section (const char *name, unsigned int flags,\n       if (flags & SECTION_ENTSIZE)\n \tfprintf (asm_out_file, \",%d\", flags & SECTION_ENTSIZE);\n       if (HAVE_COMDAT_GROUP && (flags & SECTION_LINKONCE))\n-\tfprintf (asm_out_file, \",%s,comdat\", \n+\tfprintf (asm_out_file, \",%s,comdat\",\n \t\t lang_hooks.decls.comdat_group (decl));\n     }\n \n   putc ('\\n', asm_out_file);\n }\n \n void\n-default_coff_asm_named_section (const char *name, unsigned int flags, \n+default_coff_asm_named_section (const char *name, unsigned int flags,\n \t\t\t\ttree decl ATTRIBUTE_UNUSED)\n {\n   char flagchars[8], *f = flagchars;\n@@ -5491,7 +5491,7 @@ default_binds_local_p_1 (tree exp, int shlib)\n     local_p = true;\n   /* A variable is local if the user has said explicitly that it will\n      be.  */\n-  else if (DECL_VISIBILITY_SPECIFIED (exp) \n+  else if (DECL_VISIBILITY_SPECIFIED (exp)\n \t   && DECL_VISIBILITY (exp) != VISIBILITY_DEFAULT)\n     local_p = true;\n   /* Variables defined outside this object might not be local.  */\n@@ -5552,7 +5552,15 @@ default_emit_unwind_label (FILE * stream ATTRIBUTE_UNUSED,\n \t\t\t   tree decl ATTRIBUTE_UNUSED,\n \t\t\t   int for_eh ATTRIBUTE_UNUSED,\n \t\t\t   int empty ATTRIBUTE_UNUSED)\n-{ \n+{\n+}\n+\n+/* Default function to output a label to divide up the exception table.\n+   The default is to do nothing.  A target that needs/wants to divide\n+   up the table must provide it's own function to do this.  */\n+void\n+default_emit_except_table_label (FILE * stream ATTRIBUTE_UNUSED)\n+{\n }\n \n /* This is how to output an internal numbered label where PREFIX is"}]}