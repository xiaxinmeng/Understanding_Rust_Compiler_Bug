{"sha": "b532e7f1dc84b4045b5f2d7cfe4a571bb575b22e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjUzMmU3ZjFkYzg0YjQwNDViNWYyZDdjZmU0YTU3MWJiNTc1YjIyZQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-06-23T02:42:04Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-06-23T02:42:04Z"}, "message": "(build_signature_table_constructor): Use DECL_CONTEXT instead of...\n\n(build_signature_table_constructor): Use DECL_CONTEXT instead of\nDECL_CLASS_CONTEXT for calculating the vfield offset so abstract\nvirtual functions are handled correctly.\n(build_signature_table_constructor): Store the correct delta in signature table\nentries.  It does not yet work for classes with virtual base classes as\nimplementations of signatures.\n(build_signature_method_call): Add the delta to the object_ptr before\ngenerating the function call.\n(build_signature_method_call): Dereference the optr for the direct and virtual\ncalls.\n(build_signature_table_constructor): Make the tag for default\nimplementations -1 instead of 2.\n(build_signature_method_call): Change the generated conditional expression\ncorrespondingly.\n(build_signature_pointer_constructor): Deleted the sorry message that said we\ncan't handle multiple inheritance for implementations of signatures\n(build_signature_method_call): Use the offset from the sigtable entry instead\nof the vptr field from the signature pointer for building a virtual function\ncall.\n(build_vptr_ref): Deleted.\n(build_signature_pointer_or_reference_type): Deleted construction of the vptr\nfield.\n(build_signature_pointer_constructor): Deleted initialization of/assignment to\nthe vptr field.\n(build_signature_table_constructor): Convert the signature table entry fields\nto their correct types.\n(build_signature_table_constructor): Don't call digest_init for the fields of\na sigtable entry, it's wasted time.\n(build_signature_table_constructor): Correctly set the offset and index fields\nof a sigtable entry.  Build the constructor the way digest_init does,\ndigest_init can't handle initializing an anonymous union inside a struct.\n(build_signature_method_call): Use the index field instead of the delta field\nto get the vtable index.\n(build_signature_table_constructor): Rename code and offset to tag and delta,\nrespectively.\n(build_signature_method_call): Ditto.  Use above variables.\n\nFrom-SVN: r10046", "tree": {"sha": "65a4c9d4828dffec9c1e4ace0d8b06f8f613b564", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/65a4c9d4828dffec9c1e4ace0d8b06f8f613b564"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b532e7f1dc84b4045b5f2d7cfe4a571bb575b22e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b532e7f1dc84b4045b5f2d7cfe4a571bb575b22e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b532e7f1dc84b4045b5f2d7cfe4a571bb575b22e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b532e7f1dc84b4045b5f2d7cfe4a571bb575b22e/comments", "author": null, "committer": null, "parents": [{"sha": "e1b7b0cb2e688fac7793af38a4d805a13e36056b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1b7b0cb2e688fac7793af38a4d805a13e36056b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e1b7b0cb2e688fac7793af38a4d805a13e36056b"}], "stats": {"total": 194, "additions": 102, "deletions": 92}, "files": [{"sha": "9f4802c22a5e3203c492f853c266558bb63b3735", "filename": "gcc/cp/sig.c", "status": "modified", "additions": 102, "deletions": 92, "changes": 194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b532e7f1dc84b4045b5f2d7cfe4a571bb575b22e/gcc%2Fcp%2Fsig.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b532e7f1dc84b4045b5f2d7cfe4a571bb575b22e/gcc%2Fcp%2Fsig.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsig.c?ref=b532e7f1dc84b4045b5f2d7cfe4a571bb575b22e", "patch": "@@ -1,5 +1,5 @@\n /* Functions dealing with signatures and signature pointers/references.\n-   Copyright (C) 1992, 1995 Free Software Foundation, Inc.\n+   Copyright (C) 1992, 1993, 1994, 1995 Free Software Foundation, Inc.\n    Contributed by Gerald Baumgartner (gb@cs.purdue.edu)\n \n This file is part of GNU CC.\n@@ -144,15 +144,13 @@ build_signature_pointer_or_reference_type (to_type, constp, volatilep, refp)\n        struct {\n          void * optr;\n \t const s * sptr;\n-\t vtbl_type_node * vptr;\n        };\n \n      A `const' signature pointer/reference is a\n \n        struct {\n          const void * optr;\n \t const s * sptr;\n-\t vtbl_type_node * vptr;\n        };\n \n      Similarly, for `volatile' and `const volatile'.\n@@ -162,7 +160,7 @@ build_signature_pointer_or_reference_type (to_type, constp, volatilep, refp)\n   {\n     tree obj_type = build_type_variant (void_type_node, constp, volatilep);\n     tree optr_type = build_pointer_type (obj_type);\n-    tree optr, sptr, vptr;\n+    tree optr, sptr;\n \n     optr = build_lang_field_decl (FIELD_DECL,\n \t\t\t\t  get_identifier (SIGNATURE_OPTR_NAME),\n@@ -171,37 +169,25 @@ build_signature_pointer_or_reference_type (to_type, constp, volatilep, refp)\n     DECL_CLASS_CONTEXT (optr) = t;\n \n     if (m)\n-      {\n-\t/* We can share `sptr' and `vptr' among type variants.  */\n-\tsptr = TREE_CHAIN (TYPE_FIELDS (m));\n-\tvptr = TREE_CHAIN (sptr);\n-      }\n+      /* We can share the `sptr' field among type variants.  */\n+      sptr = TREE_CHAIN (TYPE_FIELDS (m));\n     else\n       {\n \ttree sig_tbl_type = cp_build_type_variant (to_type, 1, 0);\n \t\n \tsptr = build_lang_field_decl (FIELD_DECL,\n \t\t\t\t      get_identifier (SIGNATURE_SPTR_NAME),\n \t\t\t\t      build_pointer_type (sig_tbl_type));\n-\tvptr = build_lang_field_decl (FIELD_DECL,\n-\t\t\t\t      get_identifier (SIGNATURE_VPTR_NAME),\n-\t\t\t\t      build_pointer_type (vtbl_type_node));\n \tDECL_FIELD_CONTEXT (sptr) = t;\n \tDECL_CLASS_CONTEXT (sptr) = t;\n-\tDECL_FIELD_CONTEXT (vptr) = t;\n-\tDECL_CLASS_CONTEXT (vptr) = t;\n-\tTREE_CHAIN (sptr) = vptr;\n-\tTREE_CHAIN (vptr) = NULL_TREE;\n+\tTREE_CHAIN (sptr) = NULL_TREE;\n       }\n \n     TREE_CHAIN (optr) = sptr;\n     TYPE_FIELDS (t) = optr;\n-    /* To make `build_vfn_ref' work when building a signature method call.  */\n-    CLASSTYPE_VFIELD (t) = vptr;\n-    DECL_FCONTEXT (CLASSTYPE_VFIELD (t)) = t;\n     TYPE_ALIGN (t) = TYPE_ALIGN (optr_type);\n \n-    /* A signature pointer/reference isn't a `real' class.  */\n+    /* A signature pointer/reference type isn't a `real' class type.  */\n     IS_AGGR_TYPE (t) = 0;\n   }\n \n@@ -573,36 +559,68 @@ build_signature_table_constructor (sig_ty, rhs)\n \t}\n       else\n \t{\n-\t  tree code, offset, pfn;\n+\t  tree tag, delta, pfn, offset, index;\n+\t  tree tag_decl, delta_decl, pfn_decl, offset_decl, index_decl;\n \n \t  if (rhs_method == sig_method)\n \t    {\n-\t      code = integer_two_node;\n-\t      offset = integer_zero_node;\n+\t      tag = build_unary_op (NEGATE_EXPR, integer_one_node, 0);\n+\t      delta = integer_zero_node;\n \t      pfn = build_unary_op (ADDR_EXPR, rhs_method, 0);\n \t      TREE_TYPE (pfn) = ptr_type_node;\n \t      offset_p = 0;\t/* we can't offset the rhs sig table */\n \t    }\n \t  else if (DECL_VINDEX (rhs_method))\n \t    {\n-\t      code = integer_one_node;\n-\t      offset = DECL_VINDEX (rhs_method);\n+\t      tag = integer_one_node;\n+\t      delta = BINFO_OFFSET (get_binfo (DECL_CLASS_CONTEXT (rhs_method),\n+\t\t\t\t\t       rhstype, 1));\n \t      pfn = null_pointer_node;\n+\t      offset = get_vfield_offset (get_binfo (DECL_CONTEXT (rhs_method),\n+\t\t\t\t\t\t     rhstype, 0));\n+\t      index = DECL_VINDEX (rhs_method);\n \t    }\n \t  else\n \t    {\n-\t      code = integer_zero_node;\n-\t      offset = integer_zero_node;\n+\t      tag = integer_zero_node;\n+\t      delta = BINFO_OFFSET (get_binfo (DECL_CLASS_CONTEXT (rhs_method),\n+\t\t\t\t\t       rhstype, 1));\n \t      pfn = build_unary_op (ADDR_EXPR, rhs_method, 0);\n \t      TREE_TYPE (pfn) = ptr_type_node;\n \t      TREE_ADDRESSABLE (rhs_method) = 1;\n \t    }\n \n-\t  tbl_entry = tree_cons (NULL_TREE, code,\n-\t\t\t\t tree_cons (NULL_TREE, offset,\n-\t\t\t\t\t    build_tree_list (NULL_TREE, pfn)));\n-\t  tbl_entry = build_nt (CONSTRUCTOR, NULL_TREE, tbl_entry);\n-\t  TREE_HAS_CONSTRUCTOR (tbl_entry) = 1;\n+\t  /* Since digest_init doesn't handle initializing selected fields\n+\t     of a struct (i.e., anonymous union), we build the constructor\n+\t     by hand, without calling digest_init.  */\n+\t  tag_decl = TYPE_FIELDS (sigtable_entry_type);\n+\t  delta_decl = TREE_CHAIN (tag_decl);\n+\t  pfn_decl = TREE_CHAIN (delta_decl);\n+\t  offset_decl = TREE_CHAIN (pfn_decl);\n+\t  index_decl = TREE_CHAIN (offset_decl);\n+\t  \n+\t  tag = convert (TREE_TYPE (tag_decl), tag);\n+\t  delta = convert (TREE_TYPE (delta_decl), delta);\n+\n+\t  if (DECL_VINDEX (rhs_method))\n+\t    {\n+\t      offset = convert (TREE_TYPE (offset_decl), offset);\n+\t      index = convert (TREE_TYPE (index_decl), index);\n+\n+\t      tbl_entry = tree_cons (offset_decl, offset,\n+\t\t\t\t     build_tree_list (index_decl, index));\n+\t    }\n+\t  else\n+\t    {\n+\t      pfn = convert (TREE_TYPE (pfn_decl), pfn);\n+\n+\t      tbl_entry = build_tree_list (pfn_decl, pfn);\n+\t    }\n+\t  tbl_entry = tree_cons (tag_decl, tag,\n+\t\t\t\t tree_cons (delta_decl, delta, tbl_entry));\n+\t  tbl_entry = build (CONSTRUCTOR, sigtable_entry_type,\n+\t\t\t     NULL_TREE, tbl_entry);\n+\n \t  TREE_CONSTANT (tbl_entry) = 1;\n \t}\n \n@@ -744,7 +762,7 @@ build_signature_pointer_constructor (lhs, rhs)\n   tree lhstype = initp ? lhs : TREE_TYPE (lhs);\n   tree rhstype = TREE_TYPE (rhs);\n   tree sig_ty  = SIGNATURE_TYPE (lhstype);\n-  tree sig_tbl, sptr_expr, optr_expr, vptr_expr;\n+  tree sig_tbl, sptr_expr, optr_expr;\n   tree result;\n \n   if (! ((TREE_CODE (rhstype) == POINTER_TYPE\n@@ -781,7 +799,6 @@ build_signature_pointer_constructor (lhs, rhs)\n \t  /* LHS and RHS are signature pointers/refs of the same signature.  */\n \t  optr_expr = build_optr_ref (rhs);\n \t  sptr_expr = build_sptr_ref (rhs);\n-\t  vptr_expr = build_vptr_ref (rhs);\n \t}\n       else\n \t{\n@@ -805,19 +822,10 @@ build_signature_pointer_constructor (lhs, rhs)\n \t  else\n \t    sptr_expr = build_unary_op (ADDR_EXPR, sig_tbl, 0);\n \t  TREE_TYPE (sptr_expr) = build_pointer_type (sig_ty);\n-\t  vptr_expr = build_vptr_ref (rhs);\n \t}\n     }\n   else\n     {\n-      tree rhs_vptr;\n-\n-      if (TYPE_USES_COMPLEX_INHERITANCE (TREE_TYPE (rhstype)))\n-\t{\n-\t  sorry (\"class with multiple inheritance as implementation of signature\");\n-\t  return error_mark_node;\n-\t}\n-\n       sig_tbl = build_sigtable (sig_ty, TREE_TYPE (rhstype), rhs);\n       if (sig_tbl == error_mark_node)\n \treturn error_mark_node;\n@@ -832,22 +840,12 @@ build_signature_pointer_constructor (lhs, rhs)\n \t}\n       else\n \tsptr_expr = build_unary_op (ADDR_EXPR, sig_tbl, 0);\n-      if (CLASSTYPE_VFIELD (TREE_TYPE (rhstype)))\n-\t{\n-\t  rhs_vptr = DECL_NAME (CLASSTYPE_VFIELD (TREE_TYPE (rhstype)));\n-\t  vptr_expr = build_component_ref (build_indirect_ref (rhs, 0),\n-\t\t\t\t\t   rhs_vptr, NULL_TREE, 0);\n-\t}\n-      else\n-\tvptr_expr = copy_node (null_pointer_node);\n-      TREE_TYPE (vptr_expr) = build_pointer_type (vtbl_type_node);\n     }\n \n   if (initp)\n     {\n       result = tree_cons (NULL_TREE, optr_expr,\n-\t\t\t  tree_cons (NULL_TREE, sptr_expr,\n-\t\t\t\t     build_tree_list (NULL_TREE, vptr_expr)));\n+\t\t\t  build_tree_list (NULL_TREE, sptr_expr));\n       result = build_nt (CONSTRUCTOR, NULL_TREE, result);\n       TREE_HAS_CONSTRUCTOR (result) = 1;\n       result = digest_init (lhstype, result, 0);\n@@ -861,14 +859,10 @@ build_signature_pointer_constructor (lhs, rhs)\n \t\t\t\t     optr_expr);\n       sptr_expr = build_modify_expr (build_sptr_ref (lhs), NOP_EXPR,\n \t\t\t\t     sptr_expr);\n-      vptr_expr = build_modify_expr (build_vptr_ref (lhs), NOP_EXPR,\n-\t\t\t\t     vptr_expr);\n \n       result = tree_cons (NULL_TREE, optr_expr,\n \t\t\t  tree_cons (NULL_TREE, sptr_expr,\n-\t\t\t\t     tree_cons (NULL_TREE, vptr_expr,\n-\t\t\t\t\t\tbuild_tree_list (NULL_TREE,\n-\t\t\t\t\t\t\t\t lhs))));\n+\t\t\t\t     build_tree_list (NULL_TREE, lhs)));\n       result = build_compound_expr (result);\n     }\n \n@@ -911,32 +905,40 @@ build_signature_method_call (basetype, instance, function, parms)\n      tree basetype, instance, function, parms;\n {\n   tree saved_instance = save_this (instance);\t/* Create temp for `this'.  */\n+  tree object_ptr = build_optr_ref (saved_instance);\n+  tree new_object_ptr, new_parms;\n   tree signature_tbl_ptr = build_sptr_ref (saved_instance);\n   tree sig_field_name = DECL_NAME (DECL_MEMFUNC_POINTER_TO (function));\n   tree basetype_path = TYPE_BINFO (basetype);\n   tree tbl_entry = build_component_ref (build1 (INDIRECT_REF, basetype,\n \t\t\t\t\t\tsignature_tbl_ptr),\n \t\t\t\t\tsig_field_name, basetype_path, 1);\n-  tree code, offset, pfn, vfn;\n+  tree tag, delta, pfn, offset, index, vfn;\n   tree deflt_call = NULL_TREE, direct_call, virtual_call, result;\n \n-  code = build_component_ref (tbl_entry, get_identifier (SIGTABLE_CODE_NAME),\n-\t\t\t     NULL_TREE, 1);\n-  offset = build_component_ref (tbl_entry,\n-\t\t\t\tget_identifier (SIGTABLE_OFFSET_NAME),\n-\t\t\t     NULL_TREE, 1);\n-  pfn = build_component_ref (tbl_entry, get_identifier (SIGTABLE_PFN_NAME),\n-\t\t\t     NULL_TREE, 1);\n+  tbl_entry = save_expr (tbl_entry);\n+  tag = build_component_ref (tbl_entry, tag_identifier, NULL_TREE, 1);\n+  delta = build_component_ref (tbl_entry, delta_identifier, NULL_TREE, 1);\n+  pfn = build_component_ref (tbl_entry, pfn_identifier, NULL_TREE, 1);\n+  offset = build_component_ref (tbl_entry, offset_identifier, NULL_TREE, 1);\n+  index = build_component_ref (tbl_entry, index_identifier, NULL_TREE, 1);\n   TREE_TYPE (pfn) = build_pointer_type (TREE_TYPE (function)); \n \n   if (IS_DEFAULT_IMPLEMENTATION (function))\n     {\n       pfn = save_expr (pfn);\n-      deflt_call = build_function_call (pfn,\n-\t\t\t\t\ttree_cons (NULL_TREE, saved_instance,\n-\t\t\t\t\t\t   TREE_CHAIN (parms)));\n+      deflt_call = build_function_call (pfn, parms);\n     }\n \n+  new_object_ptr = build (PLUS_EXPR, TYPE_POINTER_TO (basetype),\n+\t\t\t  convert (ptrdiff_type_node, object_ptr),\n+\t\t\t  convert (ptrdiff_type_node, delta));\n+\n+  parms = tree_cons (NULL_TREE,\n+\t\t     convert (TYPE_POINTER_TO (basetype), object_ptr),\n+\t\t     TREE_CHAIN (parms));\n+  new_parms = tree_cons (NULL_TREE, new_object_ptr, TREE_CHAIN (parms));\n+\n   {\n     /* Cast the signature method to have `this' of a normal pointer type.  */\n     tree old_this = TREE_VALUE (TYPE_ARG_TYPES (TREE_TYPE (TREE_TYPE (pfn))));\n@@ -946,11 +948,31 @@ build_signature_method_call (basetype, instance, function, parms)\n \t\t\t  TYPE_READONLY (old_this),\n \t\t\t  TYPE_VOLATILE (old_this));\n \n-    direct_call = build_function_call (pfn, parms);\n+    direct_call = build_function_call (pfn, new_parms);\n+\n+    {\n+      tree vfld, vtbl, aref;\n+\n+      vfld = build (PLUS_EXPR,\n+\t\t    build_pointer_type (build_pointer_type (vtbl_type_node)),\n+\t\t    convert (ptrdiff_type_node, object_ptr),\n+\t\t    convert (ptrdiff_type_node, offset));\n+      vtbl = build_indirect_ref (build_indirect_ref (vfld, NULL_PTR),\n+\t\t\t\t NULL_PTR);\n+      aref = build_array_ref (vtbl, index);\n+\n+      if (flag_vtable_thunks)\n+\tvfn = aref;\n+      else\n+\tvfn = build_component_ref (aref, pfn_identifier, 0, 0);\n+\n+      TREE_TYPE (vfn) = build_pointer_type (TREE_TYPE (function));\n \n-    vfn = build_vfn_ref (&TREE_VALUE (parms), saved_instance, offset);\n-    TREE_TYPE (vfn) = build_pointer_type (TREE_TYPE (function));\n-    virtual_call = build_function_call (vfn, parms);\n+      if (flag_vtable_thunks)\n+\tvirtual_call = build_function_call (vfn, parms);\n+      else\n+\tvirtual_call = build_function_call (vfn, new_parms);\n+    }\n \n     /* Undo the cast, make `this' a signature pointer again.  */\n     TREE_VALUE (TYPE_ARG_TYPES (TREE_TYPE (TREE_TYPE (pfn)))) = old_this;\n@@ -970,16 +992,16 @@ build_signature_method_call (basetype, instance, function, parms)\n \n   if (IS_DEFAULT_IMPLEMENTATION (function))\n     {\n-      tree test = build_binary_op_nodefault (EQ_EXPR, code, integer_one_node,\n-\t\t\t\t\t     EQ_EXPR);\n-      result = build_conditional_expr (code,\n+      tree test = build_binary_op_nodefault (LT_EXPR, tag, integer_zero_node,\n+\t\t\t\t\t     LT_EXPR);\n+      result = build_conditional_expr (tag,\n \t\t\t\t       build_conditional_expr (test,\n-\t\t\t\t\t\t\t       virtual_call,\n-\t\t\t\t\t\t\t       deflt_call),\n+\t\t\t\t\t\t\t       deflt_call,\n+\t\t\t\t\t\t\t       virtual_call),\n \t\t\t\t       direct_call);\n     }\n   else\n-    result = build_conditional_expr (code, virtual_call, direct_call);\n+    result = build_conditional_expr (tag, virtual_call, direct_call);\n \n   /* If we created a temporary variable for `this', initialize it first.  */\n   if (instance != saved_instance)\n@@ -1013,15 +1035,3 @@ build_sptr_ref (instance)\n \n   return build_component_ref (instance, field, NULL_TREE, 1);\n }\n-\n-/* Create a COMPONENT_REF expression for referencing the VPTR field\n-   of a signature pointer or reference.  */\n-\n-tree\n-build_vptr_ref (instance)\n-     tree instance;\n-{\n-  tree field = get_identifier (SIGNATURE_VPTR_NAME);\n-\n-  return build_component_ref (instance, field, NULL_TREE, 1);\n-}"}]}