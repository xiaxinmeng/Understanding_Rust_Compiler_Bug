{"sha": "4b674448203883c9b44091bf55479ee238d267fb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGI2NzQ0NDgyMDM4ODNjOWI0NDA5MWJmNTU0NzllZTIzOGQyNjdmYg==", "commit": {"author": {"name": "Jason Merrill", "email": "merrill@gnu.org", "date": "1996-10-04T17:51:20Z"}, "committer": {"name": "Jason Merrill", "email": "merrill@gnu.org", "date": "1996-10-04T17:51:20Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r12899", "tree": {"sha": "c4ebedaef22cfc1a03a538115ba24e96cd0700a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c4ebedaef22cfc1a03a538115ba24e96cd0700a4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4b674448203883c9b44091bf55479ee238d267fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b674448203883c9b44091bf55479ee238d267fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b674448203883c9b44091bf55479ee238d267fb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b674448203883c9b44091bf55479ee238d267fb/comments", "author": null, "committer": null, "parents": [{"sha": "acb94fa1e947d9c7791158f44631bde32492de64", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/acb94fa1e947d9c7791158f44631bde32492de64", "html_url": "https://github.com/Rust-GCC/gccrs/commit/acb94fa1e947d9c7791158f44631bde32492de64"}], "stats": {"total": 198, "additions": 92, "deletions": 106}, "files": [{"sha": "a76a0a89d292c2d79046c76965490d776dc12663", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 92, "deletions": 106, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b674448203883c9b44091bf55479ee238d267fb/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b674448203883c9b44091bf55479ee238d267fb/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=4b674448203883c9b44091bf55479ee238d267fb", "patch": "@@ -109,7 +109,6 @@ typedef struct dw_loc_descr_struct *dw_loc_descr_ref;\n typedef struct dw_cfi_struct *dw_cfi_ref;\n typedef struct dw_fde_struct *dw_fde_ref;\n typedef union  dw_cfi_oprnd_struct *dw_cfi_oprnd_ref;\n-typedef struct backchain *backchain_ref;\n \n /* Describe a double word constant value.  */\n typedef struct dw_double_const_struct\n@@ -197,7 +196,7 @@ typedef struct dw_cfi_struct\n dw_cfi_node;\n \n /* All call frame descriptions (FDE's) in the GCC generated DWARF\n-   refer to a signle Common Information Entry (CIE), defined at\n+   refer to a single Common Information Entry (CIE), defined at\n    the beginning of the .debug_frame section.  This used of a single\n    CIE obviates the need to keep track of multiple CIE's\n    in the DWARF generation routines below.  */\n@@ -227,17 +226,6 @@ typedef struct die_struct\n   }\n die_node;\n \n-/* The structure for backchaining support, when structure tags are declared\n-   before they are defined.  */\n-\n-typedef struct backchain\n-  {\n-    tree type;\n-    dw_die_ref placeholder;\n-    backchain_ref next;\n-  }\n-backchain_t;\n-\n /* How to start an assembler comment.  */\n #ifndef ASM_COMMENT_START\n #define ASM_COMMENT_START \";#\"\n@@ -567,10 +555,6 @@ static dw_die_ref int_base_type_die;\n    declaration are.  */\n static tree dwarf_last_decl;\n \n-/* A list of DIE reference attributes values that need backchaining\n-   support.  */\n-static backchain_ref backchain;\n-\n /* Forward declarations for functions defined in this file.  */\n static void gen_type_die ();\n static void add_type_attribute ();\n@@ -2088,23 +2072,6 @@ add_AT_section_offset (die, attr_kind, section)\n     }\n }\n \n-/* Save a DIE reference attribute value to a DIE for later backchaining.  */\n-inline void\n-backchain_AT_die_ref (type, placeholder)\n-     register tree type;\n-     register dw_die_ref placeholder;\n-{\n-  register backchain_ref back = (backchain_ref) xmalloc (sizeof (backchain_t));\n-  if (back != NULL)\n-    {\n-      back->type = type;\n-      back->placeholder = placeholder;\n-\n-      back->next = backchain;\n-      backchain = back;\n-    }\n-}\n-\n /* Test if die refers to an external subroutine.  */\n inline int\n is_extern_subr_die (die)\n@@ -2220,6 +2187,62 @@ get_AT_hi_pc (die)\n   return hi_pc;\n }\n \n+/* Remove the specified attribute if present.  */\n+inline void\n+remove_AT (die, attr_kind)\n+     register dw_die_ref die;\n+     register enum dwarf_attribute attr_kind;\n+{\n+  register dw_attr_ref a;\n+  register dw_attr_ref removed = NULL;;\n+  if (die != NULL)\n+    {\n+      if (die->die_attr->dw_attr == attr_kind)\n+\t{\n+\t  removed = die->die_attr;\n+\t  if (die->die_attr_last == die->die_attr)\n+\t    die->die_attr_last = NULL;\n+\t  die->die_attr = die->die_attr->dw_attr_next;\n+\t}\n+      else for (a = die->die_attr; a->dw_attr_next != NULL;\n+\t\ta = a->dw_attr_next)\n+\tif (a->dw_attr_next->dw_attr == attr_kind)\n+\t  {\n+\t    removed = a->dw_attr_next;\n+\t    if (die->die_attr_last == a->dw_attr_next)\n+\t      die->die_attr_last = a;\n+\t    a->dw_attr_next = a->dw_attr_next->dw_attr_next;\n+\t    return;\n+\t  }\n+      if (removed)\n+\tfree (removed);\n+    }\n+}\n+\n+/* Discard the children of this DIE.  */\n+inline void\n+remove_children (die)\n+     register dw_die_ref die;\n+{\n+  register dw_die_ref child_die = die->die_child;\n+  die->die_child = NULL;\n+  die->die_child_last = NULL;\n+  while (child_die != NULL)\n+    {\n+      register dw_die_ref tmp_die = child_die;\n+      register dw_attr_ref a;\n+      child_die = child_die->die_sib;\n+      \n+      for (a = tmp_die->die_attr; a != NULL; )\n+\t{\n+\t  register dw_attr_ref tmp_a = a;\n+\t  a = a->dw_attr_next;\n+\t  free (tmp_a);\n+\t}\n+      free (tmp_die);\n+    }\n+}\n+\n /* Add a child DIE below its parent.  */\n inline void\n add_child_die (die, child_die)\n@@ -4557,6 +4580,8 @@ modified_type_die (type, is_const_type, is_volatile_type, context_die)\n \t}\n       else\n \t{\n+\t  gen_type_die (type, context_die);\n+\n \t  /* We have to get the type_main_variant here (and pass that to the\n \t     `lookup_type_die' routine) because the ..._TYPE node we have\n \t     might simply be a *copy* of some original type node (where the\n@@ -4567,17 +4592,8 @@ modified_type_die (type, is_const_type, is_volatile_type, context_die)\n \t     handles DIEs representing *main variants*, and it never even\n \t     knows about non-main-variants.).  */\n \t  mod_type_die = lookup_type_die (type_main_variant (type));\n-\n-\t  /* Normally, we assume that all types are defined before they are\n-\t     referenced.  If this is not the case, then mod_type_die will\n-\t     be NULL here, and we must backchain.  This can happen as the\n-\t     result of a forward declaration of a structure tag.  */\n \t  if (mod_type_die == NULL)\n-\t    {\n-\t      dw_die_ref placeholder_die = new_die (DW_TAG_padding,\n-\t\t\t\t\t\t    context_die);\n-\t      backchain_AT_die_ref (type, placeholder_die);\n-\t    }\n+\t    abort ();\n \t}\n     }\n   if (sub_die != NULL)\n@@ -4588,32 +4604,6 @@ modified_type_die (type, is_const_type, is_volatile_type, context_die)\n   return mod_type_die;\n }\n \n-/* Fix all unresolved die references that resulted from forward\n-   declarations.  */\n-static void\n-resolve_backchains ()\n-{\n-  register backchain_ref back;\n-\n-  back = backchain;\n-  while (back)\n-    {\n-      register dw_die_ref type_die;\n-\n-      type_die = lookup_type_die (type_main_variant (back->type));\n-\n-      assert (type_die != NULL);\n-\t\t\t\t    \n-      /* ??? It would be cleaner to find the die attribute, and change\n-\t the val_dir_ref field to point to this new die.  Just overwriting\n-\t the temporary die with the correct one is easier though, and seems\n-\t to work just as well.  */\n-      memcpy (back->placeholder, type_die, sizeof (die_node));\n-\n-      back = back->next;\n-    }\n-}\n-\n /* Given a pointer to an arbitrary ..._TYPE tree node, return true if it is\n    an enumerated type.   */\n inline int\n@@ -6118,7 +6108,7 @@ gen_subprogram_die (decl, context_die)\n {\n   char label_id[MAX_ARTIFICIAL_LABEL_BYTES];\n   register tree origin = decl_ultimate_origin (decl);\n-  register dw_die_ref subr_die = new_die (DW_TAG_subprogram, context_die);\n+  register dw_die_ref subr_die;\n   register dw_loc_descr_ref fp_loc = NULL;\n   register unsigned fp_reg;\n   register tree type;\n@@ -6129,17 +6119,32 @@ gen_subprogram_die (decl, context_die)\n \n   if (origin != NULL)\n     {\n+      subr_die = new_die (DW_TAG_subprogram, context_die);\n       add_abstract_origin_attribute (subr_die, origin);\n     }\n   else if (old_die)\n     {\n+      register unsigned file_index\n+\t= lookup_filename (DECL_SOURCE_FILE (decl));\n       if (get_AT_flag (old_die, DW_AT_declaration) != 1)\n \tabort ();\n-      add_AT_die_ref (subr_die, DW_AT_specification, old_die);\n-      if (DECL_NAME (decl))\n+\n+      /* If the definition comes from the same place as the declaration,\n+\t use the old DIE.  */\n+      if (get_AT_unsigned (old_die, DW_AT_decl_file) == file_index\n+\t  && (get_AT_unsigned (old_die, DW_AT_decl_line)\n+\t      == DECL_SOURCE_LINE (decl)))\n \t{\n-\t  register unsigned file_index\n-\t    = lookup_filename (DECL_SOURCE_FILE (decl));\n+\t  subr_die = old_die;\n+\n+\t  /* Clear out the declaration attribute and the parm types.  */\n+\t  remove_AT (subr_die, DW_AT_declaration);\n+\t  remove_children (subr_die);\n+\t}\n+      else\n+\t{\n+\t  subr_die = new_die (DW_TAG_subprogram, context_die);\n+\t  add_AT_die_ref (subr_die, DW_AT_specification, old_die);\n \t  if (get_AT_unsigned (old_die, DW_AT_decl_file) != file_index)\n \t    add_AT_unsigned (subr_die, DW_AT_decl_file, file_index);\n \t  if (get_AT_unsigned (old_die, DW_AT_decl_line)\n@@ -6150,6 +6155,7 @@ gen_subprogram_die (decl, context_die)\n     }\n   else\n     {\n+      subr_die = new_die (DW_TAG_subprogram, context_die);\n       if (TREE_PUBLIC (decl) || DECL_EXTERNAL (decl))\n \t{\n \t  add_AT_flag (subr_die, DW_AT_external, 1);\n@@ -6657,6 +6663,10 @@ gen_struct_or_union_type_die (type, is_complete, context_die)\n       equate_type_number_to_die (type, type_die);\n       add_name_attribute (type_die, type_tag (type));\n     }\n+  else if (is_complete)\n+    remove_AT (type_die, DW_AT_declaration);\n+  else\n+    return;\n \n   /* If this type has been completed, then give it a byte_size attribute and\n      then give a list of members.  */\n@@ -6671,6 +6681,8 @@ gen_struct_or_union_type_die (type, is_complete, context_die)\n \t  gen_member_die (type, type_die);\n \t}\n     }\n+  else\n+    add_AT_flag (type_die, DW_AT_declaration, 1);\n }\n \n /* Generate a DIE for a subroutine _type_.  */\n@@ -6838,6 +6850,11 @@ gen_type_die (type, context_die)\n \t{\n \t  gen_struct_or_union_type_die (type, is_complete, context_die);\n \t}\n+\n+      /* Don't set TREE_ASM_WRITTEN on an incomplete struct; we want to fix\n+\t it up if it is ever completed.  */\n+      if (! is_complete)\n+\treturn;\n       break;\n \n     case VOID_TYPE:\n@@ -7076,18 +7093,6 @@ gen_decl_die (decl, context_die)\n \t{\n \t  break;\n \t}\n-      /* Before we describe the FUNCTION_DECL itself, make sure that we have\n-         described its context.  */\n-      origin = decl_class_context (decl);\n-      if (origin && ! decl_ultimate_origin (decl))\n-\t{\n-\t  dw_die_ref old_die;\n-\t  gen_type_die (origin, context_die);\n-\t  /* We may have just generated the DIE we need; let's check.  */\n-\t  old_die = lookup_decl_die (decl);\n-\t  if (old_die && get_AT_flag (old_die, DW_AT_declaration) != 1)\n-\t    break;\n-\t}\n \n       /* Before we describe the FUNCTION_DECL itself, make sure that we have\n          described its return type.  */\n@@ -7154,19 +7159,6 @@ gen_decl_die (decl, context_die)\n \t  break;\n \t}\n \n-      /* Before we describe the VAR_DECL itself, make sure that we have\n-         described its context.  */\n-      origin = decl_class_context (decl);\n-      if (origin && ! decl_ultimate_origin (decl))\n-\t{\n-\t  dw_die_ref old_die;\n-\t  gen_type_die (origin, context_die);\n-\t  /* We may have just generated the DIE we need; let's check.  */\n-\t  old_die = lookup_decl_die (decl);\n-\t  if (old_die && get_AT_flag (old_die, DW_AT_declaration) != 1)\n-\t    break;\n-\t}\n-\n       /* Output any DIEs that are needed to specify the type of this data\n          object.  */\n       gen_type_die (TREE_TYPE (decl), context_die);\n@@ -7748,19 +7740,13 @@ dwarfout_init (asm_out_file, main_input_filename)\n \n   /* clear the association between base types and their DIE's */\n   init_base_type_table ();\n-\n-  /* clear the backchain list.  */\n-  backchain = NULL;\n }\n \n /* Output stuff that dwarf requires at the end of every file,\n    and generate the DWARF-2 debugging info.  */\n void\n dwarfout_finish ()\n {\n-\n-  resolve_backchains ();\n-\n   /* Traverse the DIE tree and add sibling attributes to those DIE's\n      that have children.  */\n   add_sibling_attributes (comp_unit_die);"}]}