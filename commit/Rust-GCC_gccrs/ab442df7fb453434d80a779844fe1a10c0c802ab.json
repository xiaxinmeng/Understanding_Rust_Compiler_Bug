{"sha": "ab442df7fb453434d80a779844fe1a10c0c802ab", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWI0NDJkZjdmYjQ1MzQzNGQ4MGE3Nzk4NDRmZTFhMTBjMGM4MDJhYg==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2008-07-23T10:28:06Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2008-07-23T10:28:06Z"}, "message": "Add ability to set target options (ix86 only) and optimization options on a function specific basis\n\nFrom-SVN: r138075", "tree": {"sha": "efd8e61a3d2ff9dcff5eb5bf03e25922191f7df5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/efd8e61a3d2ff9dcff5eb5bf03e25922191f7df5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ab442df7fb453434d80a779844fe1a10c0c802ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab442df7fb453434d80a779844fe1a10c0c802ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab442df7fb453434d80a779844fe1a10c0c802ab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab442df7fb453434d80a779844fe1a10c0c802ab/comments", "author": null, "committer": null, "parents": [{"sha": "5295185c3150a8d31685dc44248aa058246bbe73", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5295185c3150a8d31685dc44248aa058246bbe73", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5295185c3150a8d31685dc44248aa058246bbe73"}], "stats": {"total": 5315, "additions": 4740, "deletions": 575}, "files": [{"sha": "28d4f5bdcfc041d8bfff1f76341e5556f13fa81f", "filename": "gcc/Makefile.in", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=ab442df7fb453434d80a779844fe1a10c0c802ab", "patch": "@@ -794,7 +794,7 @@ BUILTINS_DEF = builtins.def sync-builtins.def omp-builtins.def\n TREE_H = tree.h all-tree.def tree.def c-common.def $(lang_tree_files) \\\n           $(MACHMODE_H) tree-check.h $(BUILTINS_DEF) \\\n           $(INPUT_H) statistics.h vec.h treestruct.def $(HASHTAB_H) \\\n-          double-int.h alias.h $(SYMTAB_H)\n+          double-int.h alias.h $(SYMTAB_H) options.h\n BASIC_BLOCK_H = basic-block.h $(BITMAP_H) sbitmap.h varray.h $(PARTITION_H) \\\n           hard-reg-set.h $(PREDICT_H) vec.h $(FUNCTION_H) \\\n           cfghooks.h $(OBSTACK_H)\n@@ -1965,7 +1965,8 @@ s-options-h: optionlist $(srcdir)/opt-functions.awk $(srcdir)/opth-gen.awk\n \t$(SHELL) $(srcdir)/../move-if-change tmp-options.h options.h\n \t$(STAMP) $@\n \n-options.o: options.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) opts.h intl.h\n+options.o: options.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TARGET_H) $(FLAGS_H) \\\n+\t$(TM_H) opts.h intl.h\n \n gcc-options.o: options.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) opts.h intl.h\n \t$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(OUTPUT_OPTION) -DGCC_DRIVER options.c"}, {"sha": "ba6a9e294c84b42fbe11a902e116bda1d08319cc", "filename": "gcc/attribs.c", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Fattribs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Fattribs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fattribs.c?ref=ab442df7fb453434d80a779844fe1a10c0c802ab", "patch": "@@ -33,6 +33,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"target.h\"\n #include \"langhooks.h\"\n #include \"hashtab.h\"\n+#include \"c-common.h\"\n \n static void init_attributes (void);\n \n@@ -232,6 +233,41 @@ decl_attributes (tree *node, tree attributes, int flags)\n   if (!attributes_initialized)\n     init_attributes ();\n \n+  /* If this is a function and the user used #pragma GCC optimize, add the\n+     options to the attribute((optimize(...))) list.  */\n+  if (TREE_CODE (*node) == FUNCTION_DECL && current_optimize_pragma)\n+    {\n+      tree cur_attr = lookup_attribute (\"optimize\", attributes);\n+      tree opts = copy_list (current_optimize_pragma);\n+\n+      if (! cur_attr)\n+\tattributes\n+\t  = tree_cons (get_identifier (\"optimize\"), opts, attributes);\n+      else\n+\tTREE_VALUE (cur_attr) = chainon (opts, TREE_VALUE (cur_attr));\n+    }\n+\n+  if (TREE_CODE (*node) == FUNCTION_DECL\n+      && optimization_current_node != optimization_default_node\n+      && !DECL_FUNCTION_SPECIFIC_OPTIMIZATION (*node))\n+    DECL_FUNCTION_SPECIFIC_OPTIMIZATION (*node) = optimization_current_node;\n+\n+  /* If this is a function and the user used #pragma GCC option, add the\n+     options to the attribute((option(...))) list.  */\n+  if (TREE_CODE (*node) == FUNCTION_DECL\n+      && current_option_pragma\n+      && targetm.target_option.valid_attribute_p (*node, NULL_TREE,\n+\t\t\t\t\t\t  current_option_pragma, 0))\n+    {\n+      tree cur_attr = lookup_attribute (\"option\", attributes);\n+      tree opts = copy_list (current_option_pragma);\n+\n+      if (! cur_attr)\n+\tattributes = tree_cons (get_identifier (\"option\"), opts, attributes);\n+      else\n+\tTREE_VALUE (cur_attr) = chainon (opts, TREE_VALUE (cur_attr));\n+    }\n+\n   targetm.insert_attributes (*node, &attributes);\n \n   for (a = attributes; a; a = TREE_CHAIN (a))"}, {"sha": "afdcac65f95e56ee68d8a84478662b217ad2b63e", "filename": "gcc/c-common.c", "status": "modified", "additions": 240, "deletions": 5, "changes": 245, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=ab442df7fb453434d80a779844fe1a10c0c802ab", "patch": "@@ -574,6 +574,8 @@ static tree handle_warn_unused_result_attribute (tree *, tree, tree, int,\n static tree handle_sentinel_attribute (tree *, tree, tree, int, bool *);\n static tree handle_type_generic_attribute (tree *, tree, tree, int, bool *);\n static tree handle_alloc_size_attribute (tree *, tree, tree, int, bool *);\n+static tree handle_option_attribute (tree *, tree, tree, int, bool *);\n+static tree handle_optimize_attribute (tree *, tree, tree, int, bool *);\n \n static void check_function_nonnull (tree, int, tree *);\n static void check_nonnull_arg (void *, tree, unsigned HOST_WIDE_INT);\n@@ -857,6 +859,10 @@ const struct attribute_spec c_common_attribute_table[] =\n \t\t\t      handle_error_attribute },\n   { \"error\",\t\t      1, 1, true,  false, false,\n \t\t\t      handle_error_attribute },\n+  { \"option\",                 1, -1, true, false, false,\n+\t\t\t      handle_option_attribute },\n+  { \"optimize\",               1, -1, true, false, false,\n+\t\t\t      handle_optimize_attribute },\n   { NULL,                     0, 0, false, false, false, NULL }\n };\n \n@@ -5027,7 +5033,7 @@ handle_noreturn_attribute (tree *node, tree name, tree ARG_UNUSED (args),\n \n static tree\n handle_hot_attribute (tree *node, tree name, tree ARG_UNUSED (args),\n-\t\t\t  int ARG_UNUSED (flags), bool *no_add_attrs)\n+\t\t      int ARG_UNUSED (flags), bool *no_add_attrs)\n {\n   if (TREE_CODE (*node) == FUNCTION_DECL)\n     {\n@@ -5037,8 +5043,34 @@ handle_hot_attribute (tree *node, tree name, tree ARG_UNUSED (args),\n \t\t   name, \"cold\");\n \t  *no_add_attrs = true;\n \t}\n-      /* Do nothing else, just set the attribute.  We'll get at\n-\t it later with lookup_attribute.  */\n+\n+      else\n+\t{\n+\t  tree old_opts = DECL_FUNCTION_SPECIFIC_OPTIMIZATION (*node);\n+\n+\t  /* If we are not at -O3, but are optimizing, turn on -O3\n+\t     optimizations just for this one function.  */\n+\t  if (((optimize > 0 && optimize < 3) || optimize_size)\n+\t      && (!old_opts || old_opts == optimization_default_node))\n+\t    {\n+\t      /* Create the hot optimization node if needed.  */\n+\t      if (!optimization_hot_node)\n+\t\t{\n+\t\t  struct cl_optimization current_options;\n+\t\t  static const char *os_argv[] = { NULL, \"-O3\", NULL };\n+\n+\t\t  cl_optimization_save (&current_options);\n+\t\t  decode_options (2, os_argv);\n+\t\t  optimization_hot_node = build_optimization_node ();\n+\t\t  cl_optimization_restore (&current_options);\n+\t\t}\n+\n+\t      DECL_FUNCTION_SPECIFIC_OPTIMIZATION (*node)\n+\t\t= optimization_hot_node;\n+\t    }\n+\t}\n+      /* Most of the rest of the hot processing is done later with\n+\t lookup_attribute.  */\n     }\n   else\n     {\n@@ -5063,8 +5095,31 @@ handle_cold_attribute (tree *node, tree name, tree ARG_UNUSED (args),\n \t\t   name, \"hot\");\n \t  *no_add_attrs = true;\n \t}\n-      /* Do nothing else, just set the attribute.  We'll get at\n-\t it later with lookup_attribute.  */\n+      else\n+\t{\n+\t  tree old_opts = DECL_FUNCTION_SPECIFIC_OPTIMIZATION (*node);\n+\n+\t  /* If we are optimizing, but not optimizing for space, turn on -Os\n+\t     optimizations just for this one function.  */\n+\t  if (optimize && !optimize_size\n+\t      && (!old_opts || old_opts == optimization_default_node))\n+\t    {\n+\t      /* Create the cold optimization node if needed.  */\n+\t      if (!optimization_cold_node)\n+\t\t{\n+\t\t  struct cl_optimization current_options;\n+\t\t  static const char *os_argv[] = { NULL, \"-Os\", NULL };\n+\n+\t\t  cl_optimization_save (&current_options);\n+\t\t  decode_options (2, os_argv);\n+\t\t  optimization_cold_node = build_optimization_node ();\n+\t\t  cl_optimization_restore (&current_options);\n+\t\t}\n+\n+\t      DECL_FUNCTION_SPECIFIC_OPTIMIZATION (*node)\n+\t\t= optimization_cold_node;\n+\t    }\n+\t}\n     }\n   else\n     {\n@@ -6762,6 +6817,186 @@ handle_type_generic_attribute (tree *node, tree ARG_UNUSED (name),\n \n   return NULL_TREE;\n }\n+\n+/* For handling \"option\" attribute. arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+handle_option_attribute (tree *node, tree name, tree args, int flags,\n+\t\t\t bool *no_add_attrs)\n+{\n+  /* Ensure we have a function type.  */\n+  if (TREE_CODE (*node) != FUNCTION_DECL)\n+    {\n+      warning (OPT_Wattributes, \"%qE attribute ignored\", name);\n+      *no_add_attrs = true;\n+    }\n+  else if (targetm.target_option.valid_attribute_p\n+\t   == default_target_option_valid_attribute_p)\n+    {\n+      warning (OPT_Wattributes,\n+\t       \"%qE attribute is not supported on this machine\",\n+\t       name);\n+      *no_add_attrs = true;\n+    }\n+  else if (! targetm.target_option.valid_attribute_p (*node, name, args,\n+\t\t\t\t\t\t      flags))\n+    *no_add_attrs = true;\n+\n+  return NULL_TREE;\n+}\n+\n+/* Arguments being collected for optimization.  */\n+typedef const char *const_char_p;\t\t/* For DEF_VEC_P.  */\n+DEF_VEC_P(const_char_p);\n+DEF_VEC_ALLOC_P(const_char_p, gc);\n+static GTY(()) VEC(const_char_p, gc) *optimize_args;\n+\n+\n+/* Inner function to convert a TREE_LIST to argv string to parse the optimize\n+   options in ARGS.  ATTR_P is true if this is for attribute(optimize), and\n+   false for #pragma GCC optimize.  */\n+\n+bool\n+parse_optimize_options (tree args, bool attr_p)\n+{\n+  bool ret = true;\n+  unsigned opt_argc;\n+  unsigned i;\n+  const char **opt_argv;\n+  tree ap;\n+\n+  /* Build up argv vector.  Just in case the string is stored away, use garbage\n+     collected strings.  */\n+  VEC_truncate (const_char_p, optimize_args, 0);\n+  VEC_safe_push (const_char_p, gc, optimize_args, NULL);\n+\n+  for (ap = args; ap != NULL_TREE; ap = TREE_CHAIN (ap))\n+    {\n+      tree value = TREE_VALUE (ap);\n+\n+      if (TREE_CODE (value) == INTEGER_CST)\n+\t{\n+\t  char buffer[20];\n+\t  sprintf (buffer, \"-O%ld\", (long) TREE_INT_CST_LOW (value));\n+\t  VEC_safe_push (const_char_p, gc, optimize_args, ggc_strdup (buffer));\n+\t}\n+\n+      else if (TREE_CODE (value) == STRING_CST)\n+\t{\n+\t  /* Split string into multiple substrings.  */\n+\t  size_t len = TREE_STRING_LENGTH (value);\n+\t  char *p = ASTRDUP (TREE_STRING_POINTER (value));\n+\t  char *end = p + len;\n+\t  char *comma;\n+\t  char *next_p = p;\n+\n+\t  while (next_p != NULL)\n+\t    {\n+\t      size_t len2;\n+\t      char *q, *r;\n+\n+\t      p = next_p;\n+\t      comma = strchr (p, ',');\n+\t      if (comma)\n+\t\t{\n+\t\t  len2 = comma - p;\n+\t\t  *comma = '\\0';\n+\t\t  next_p = comma+1;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  len2 = end - p;\n+\t\t  next_p = NULL;\n+\t\t}\n+\n+\t      r = q = (char *) ggc_alloc (len2 + 3);\n+\n+\t      /* If the user supplied -Oxxx or -fxxx, only allow -Oxxx or -fxxx\n+\t\t options.  */\n+\t      if (*p == '-' && p[1] != 'O' && p[1] != 'f')\n+\t\t{\n+\t\t  ret = false;\n+\t\t  if (attr_p)\n+\t\t    warning (OPT_Wattributes,\n+\t\t\t     \"Bad option %s to optimize attribute.\", p);\n+\t\t  else\n+\t\t    warning (OPT_Wpragmas,\n+\t\t\t     \"Bad option %s to pragma attribute\", p);\n+\t\t  continue;\n+\t\t}\n+\n+\t      if (*p != '-')\n+\t\t{\n+\t\t  *r++ = '-';\n+\n+\t\t  /* Assume that Ox is -Ox, a numeric value is -Ox, a s by\n+\t\t     itself is -Os, and any other switch begins with a -f.  */\n+\t\t  if ((*p >= '0' && *p <= '9')\n+\t\t      || (p[0] == 's' && p[1] == '\\0'))\n+\t\t    *r++ = 'O';\n+\t\t  else if (*p != 'O')\n+\t\t    *r++ = 'f';\n+\t\t}\n+\n+\t      memcpy (r, p, len2);\n+\t      r[len2] = '\\0';\n+\t      VEC_safe_push (const_char_p, gc, optimize_args, q);\n+\t    }\n+\n+\t}\n+    }\n+\n+  opt_argc = VEC_length (const_char_p, optimize_args);\n+  opt_argv = (const char **) alloca (sizeof (char *) * (opt_argc + 1));\n+\n+  for (i = 1; i < opt_argc; i++)\n+    opt_argv[i] = VEC_index (const_char_p, optimize_args, i);\n+\n+  /* Now parse the options.  */\n+  decode_options (opt_argc, opt_argv);\n+\n+  VEC_truncate (const_char_p, optimize_args, 0);\n+  return ret;\n+}\n+\n+/* For handling \"optimize\" attribute. arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+handle_optimize_attribute (tree *node, tree name, tree args,\n+\t\t\t   int ARG_UNUSED (flags), bool *no_add_attrs)\n+{\n+  /* Ensure we have a function type.  */\n+  if (TREE_CODE (*node) != FUNCTION_DECL)\n+    {\n+      warning (OPT_Wattributes, \"%qE attribute ignored\", name);\n+      *no_add_attrs = true;\n+    }\n+  else\n+    {\n+      struct cl_optimization cur_opts;\n+      tree old_opts = DECL_FUNCTION_SPECIFIC_OPTIMIZATION (*node);\n+\n+      /* Save current options.  */\n+      cl_optimization_save (&cur_opts);\n+\n+      /* If we previously had some optimization options, use them as the\n+\t default.  */\n+      if (old_opts)\n+\tcl_optimization_restore (TREE_OPTIMIZATION (old_opts));\n+\n+      /* Parse options, and update the vector.  */\n+      parse_optimize_options (args, true);\n+      DECL_FUNCTION_SPECIFIC_OPTIMIZATION (*node)\n+\t= build_optimization_node ();\n+\n+      /* Restore current options.  */\n+      cl_optimization_restore (&cur_opts);\n+    }\n+\n+  return NULL_TREE;\n+}\n \f\n /* Check for valid arguments being passed to a function.\n    ATTRS is a list of attributes.  There are NARGS arguments in the array"}, {"sha": "9850dfa94d09bc0efc5af30cf4a2a2c31004859b", "filename": "gcc/c-common.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=ab442df7fb453434d80a779844fe1a10c0c802ab", "patch": "@@ -870,6 +870,7 @@ extern tree c_staticp (tree);\n extern void init_c_lex (void);\n \n extern void c_cpp_builtins (cpp_reader *);\n+extern void c_cpp_builtins_optimize_pragma (cpp_reader *, tree, tree);\n \n /* Positive if an implicit `extern \"C\"' scope has just been entered;\n    negative if such a scope has just been exited.  */\n@@ -925,7 +926,6 @@ extern void warn_about_parentheses (enum tree_code, enum tree_code,\n extern void warn_for_unused_label (tree label);\n extern void warn_for_div_by_zero (tree divisor);\n \n-\n /* In c-gimplify.c  */\n extern void c_genericize (tree);\n extern int c_gimplify_expr (tree *, tree *, tree *);\n@@ -944,6 +944,8 @@ extern void c_common_print_pch_checksum (FILE *f);\n /* In *-checksum.c */\n extern const unsigned char executable_checksum[16];\n \n+/* In c-cppbuiltin.c  */\n+extern void builtin_define_std (const char *macro);\n extern void builtin_define_with_value (const char *, const char *, int);\n extern void c_stddef_cpp_builtins (void);\n extern void fe_file_change (const struct line_map *);"}, {"sha": "57d00580d24384315c0a161db7a2152c5597d6be", "filename": "gcc/c-cppbuiltin.c", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Fc-cppbuiltin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Fc-cppbuiltin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-cppbuiltin.c?ref=ab442df7fb453434d80a779844fe1a10c0c802ab", "patch": "@@ -405,6 +405,58 @@ builtin_define_stdint_macros (void)\n   builtin_define_type_max (\"__INTMAX_MAX__\", intmax_type_node, intmax_long);\n }\n \n+/* Adjust the optimization macros when a #pragma GCC optimization is done to\n+   reflect the current level.  */\n+void\n+c_cpp_builtins_optimize_pragma (cpp_reader *pfile, tree prev_tree,\n+\t\t\t\ttree cur_tree)\n+{\n+  struct cl_optimization *prev = TREE_OPTIMIZATION (prev_tree);\n+  struct cl_optimization *cur  = TREE_OPTIMIZATION (cur_tree);\n+  bool prev_fast_math;\n+  bool cur_fast_math;\n+\n+  /* -undef turns off target-specific built-ins.  */\n+  if (flag_undef)\n+    return;\n+\n+  /* Other target-independent built-ins determined by command-line\n+     options.  */\n+  if (!prev->optimize_size && cur->optimize_size)\n+    cpp_define (pfile, \"__OPTIMIZE_SIZE__\");\n+  else if (prev->optimize_size && !cur->optimize_size)\n+    cpp_undef (pfile, \"__OPTIMIZE_SIZE__\");\n+\n+  if (!prev->optimize && cur->optimize)\n+    cpp_define (pfile, \"__OPTIMIZE__\");\n+  else if (prev->optimize && !cur->optimize)\n+    cpp_undef (pfile, \"__OPTIMIZE__\");\n+\n+  prev_fast_math = fast_math_flags_struct_set_p (prev);\n+  cur_fast_math  = fast_math_flags_struct_set_p (cur);\n+  if (!prev_fast_math && cur_fast_math)\n+    cpp_define (pfile, \"__FAST_MATH__\");\n+  else if (prev_fast_math && !cur_fast_math)\n+    cpp_undef (pfile, \"__FAST_MATH__\");\n+\n+  if (!prev->flag_signaling_nans && cur->flag_signaling_nans)\n+    cpp_define (pfile, \"__SUPPORT_SNAN__\");\n+  else if (prev->flag_signaling_nans && !cur->flag_signaling_nans)\n+    cpp_undef (pfile, \"__SUPPORT_SNAN__\");\n+\n+  if (!prev->flag_finite_math_only && cur->flag_finite_math_only)\n+    {\n+      cpp_undef (pfile, \"__FINITE_MATH_ONLY__\");\n+      cpp_define (pfile, \"__FINITE_MATH_ONLY__=1\");\n+    }\n+  else if (!prev->flag_finite_math_only && cur->flag_finite_math_only)\n+    {\n+      cpp_undef (pfile, \"__FINITE_MATH_ONLY__\");\n+      cpp_define (pfile, \"__FINITE_MATH_ONLY__=0\");\n+    }\n+}\n+\n+\n /* Hook that registers front end and target-specific built-ins.  */\n void\n c_cpp_builtins (cpp_reader *pfile)"}, {"sha": "80ec48f61af6ca5232143c975a1d12df533c5363", "filename": "gcc/c-decl.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=ab442df7fb453434d80a779844fe1a10c0c802ab", "patch": "@@ -1842,6 +1842,17 @@ merge_decls (tree newdecl, tree olddecl, tree newtype, tree oldtype)\n \t      = C_DECL_BUILTIN_PROTOTYPE (olddecl);\n \t}\n \n+      /* Preserve function specific target and optimization options */\n+      if (DECL_FUNCTION_SPECIFIC_TARGET (olddecl)\n+\t  && !DECL_FUNCTION_SPECIFIC_TARGET (newdecl))\n+\tDECL_FUNCTION_SPECIFIC_TARGET (newdecl)\n+\t  = DECL_FUNCTION_SPECIFIC_TARGET (olddecl);\n+\n+      if (DECL_FUNCTION_SPECIFIC_OPTIMIZATION (olddecl)\n+\t  && !DECL_FUNCTION_SPECIFIC_OPTIMIZATION (newdecl))\n+\tDECL_FUNCTION_SPECIFIC_OPTIMIZATION (newdecl)\n+\t  = DECL_FUNCTION_SPECIFIC_OPTIMIZATION (olddecl);\n+\n       /* Also preserve various other info from the definition.  */\n       if (!new_is_definition)\n \t{"}, {"sha": "6e4043ae672285b25952aea8c8bfce971313099c", "filename": "gcc/c-pragma.c", "status": "modified", "additions": 309, "deletions": 0, "changes": 309, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Fc-pragma.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Fc-pragma.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pragma.c?ref=ab442df7fb453434d80a779844fe1a10c0c802ab", "patch": "@@ -866,6 +866,313 @@ handle_pragma_diagnostic(cpp_reader *ARG_UNUSED(dummy))\n   GCC_BAD (\"unknown option after %<#pragma GCC diagnostic%> kind\");\n }\n \n+/* Stack of the #pragma GCC options created with #pragma GCC option push.  */\n+static GTY(()) VEC(tree,gc) *option_stack;\n+\n+/*  Parse #pragma GCC option (xxx) to set target specific options.  */\n+static void\n+handle_pragma_option(cpp_reader *ARG_UNUSED(dummy))\n+{\n+  enum cpp_ttype token;\n+  const char *name;\n+  tree x;\n+  bool close_paren_needed_p = false;\n+\n+  if (cfun)\n+    {\n+      error (\"#pragma GCC option is not allowed inside functions\");\n+      return;\n+    }\n+\n+  if (!targetm.target_option.pragma_parse)\n+    {\n+      error (\"#pragma GCC option is not supported for this system\");\n+      return;\n+    }\n+\n+  token = pragma_lex (&x);\n+  if (token == CPP_OPEN_PAREN)\n+    {\n+      close_paren_needed_p = true;\n+      token = pragma_lex (&x);\n+    }\n+\n+  if (token == CPP_NAME)\n+    {\n+      bool call_pragma_parse_p = false;\n+      bool ok_p;\n+\n+      name = IDENTIFIER_POINTER (x);\n+      if (strcmp (name, \"reset\") == 0)\n+\t{\n+\t  current_option_pragma = NULL_TREE;\n+\t  call_pragma_parse_p = true;\n+\t}\n+\n+      else if (strcmp (name, \"push\") == 0)\n+\tVEC_safe_push (tree, gc, option_stack,\n+\t\t       copy_list (current_option_pragma));\n+\n+      else if (strcmp (name, \"pop\") == 0)\n+\t{\n+\t  int len = VEC_length (tree, option_stack);\n+\t  if (len == 0)\n+\t    {\n+\t      GCC_BAD (\"%<#pragma GCC option pop%> without a %<#pragma GCC \"\n+\t\t       \"option push%>\");\n+\t      return;\n+\t    }\n+\t  else\n+\t    {\n+\t      VEC_truncate (tree, option_stack, len-1);\n+\t      current_option_pragma = ((len > 1)\n+\t\t\t\t       ? VEC_last (tree, option_stack)\n+\t\t\t\t       : NULL_TREE);\n+\n+\t      call_pragma_parse_p = true;\n+\t    }\n+\t}\n+\n+      else\n+\t{\n+\t  GCC_BAD (\"%<#pragma GCC option%> is not a string or \"\n+\t\t   \"push/pop/reset\");\n+\t  return;\n+\t}\n+\n+      token = pragma_lex (&x);\n+      if (close_paren_needed_p)\n+\t{\n+\t  if (token == CPP_CLOSE_PAREN)\n+\t    token = pragma_lex (&x);\n+\t  else\n+\t    GCC_BAD (\"%<#pragma GCC option ([push|pop|reset])%> does not \"\n+\t\t     \"have a final %<)%>.\");\n+\t}\n+\n+      if (token != CPP_EOF)\n+\t{\n+\t  GCC_BAD (\"%<#pragma GCC option [push|pop|reset]%> is badly \"\n+\t\t   \"formed\");\n+\t  return;\n+\t}\n+\n+      /* See if we need to call the pragma_parse hook.  This must occur at the\n+\t end after processing all of the tokens, or we may get spurious errors\n+\t when we define or undef macros.  */\n+      ok_p = targetm.target_option.pragma_parse (current_option_pragma);\n+      gcc_assert (ok_p);\n+    }\n+\n+  else if (token != CPP_STRING)\n+    {\n+      GCC_BAD (\"%<#pragma GCC option%> is not a string or push/pop/reset\");\n+      return;\n+    }\n+\n+  /* Strings are user options.  */\n+  else\n+    {\n+      tree args = NULL_TREE;\n+\n+      do\n+\t{\n+\t  /* Build up the strings now as a tree linked list.  Skip empty\n+\t     strings.  */\n+\t  if (TREE_STRING_LENGTH (x) > 0)\n+\t    args = tree_cons (NULL_TREE, x, args);\n+\n+\t  token = pragma_lex (&x);\n+\t  while (token == CPP_COMMA)\n+\t    token = pragma_lex (&x);\n+\t}\n+      while (token == CPP_STRING);\n+\n+      if (close_paren_needed_p)\n+\t{\n+\t  if (token == CPP_CLOSE_PAREN)\n+\t    token = pragma_lex (&x);\n+\t  else\n+\t    GCC_BAD (\"%<#pragma GCC option (string [,string]...)%> does \"\n+\t\t     \"not have a final %<)%>.\");\n+\t}\n+\n+      if (token != CPP_EOF)\n+\t{\n+\t  error (\"#pragma GCC option string... is badly formed\");\n+\t  return;\n+\t}\n+\n+      /* put arguments in the order the user typed them.  */\n+      args = nreverse (args);\n+\n+      if (targetm.target_option.pragma_parse (args))\n+\tcurrent_option_pragma = args;\n+    }\n+}\n+\n+/* Stack of the #pragma GCC optimize options created with #pragma GCC optimize\n+   push.  */\n+static GTY(()) VEC(tree,gc) *optimize_stack;\n+\n+/* Handle #pragma GCC optimize to set optimization options.  */\n+static void\n+handle_pragma_optimize(cpp_reader *ARG_UNUSED(dummy))\n+{\n+  enum cpp_ttype token;\n+  const char *name;\n+  tree x;\n+  bool close_paren_needed_p = false;\n+  tree optimization_previous_node = optimization_current_node;\n+\n+  if (cfun)\n+    {\n+      error (\"#pragma GCC optimize is not allowed inside functions\");\n+      return;\n+    }\n+\n+  token = pragma_lex (&x);\n+  if (token == CPP_OPEN_PAREN)\n+    {\n+      close_paren_needed_p = true;\n+      token = pragma_lex (&x);\n+    }\n+\n+  if (token == CPP_NAME)\n+    {\n+      bool call_opt_p = false;\n+\n+      name = IDENTIFIER_POINTER (x);\n+      if (strcmp (name, \"reset\") == 0)\n+\t{\n+\t  struct cl_optimization *def\n+\t    = TREE_OPTIMIZATION (optimization_default_node);\n+\t  current_optimize_pragma = NULL_TREE;\n+\t  optimization_current_node = optimization_default_node;\n+\t  cl_optimization_restore (def);\n+\t  call_opt_p = true;\n+\t}\n+\n+      else if (strcmp (name, \"push\") == 0)\n+\tVEC_safe_push (tree, gc, optimize_stack, current_optimize_pragma);\n+\n+      else if (strcmp (name, \"pop\") == 0)\n+\t{\n+\t  int len = VEC_length (tree, optimize_stack);\n+\t  if (len == 0)\n+\t    {\n+\t      GCC_BAD (\"%<#pragma GCC optimize pop%> without a %<#pragma \"\n+\t\t       \"GCC optimize push%>\");\n+\t      return;\n+\t    }\n+\t  else\n+\t    {\n+\t      VEC_truncate (tree, optimize_stack, len-1);\n+\t      current_optimize_pragma\n+\t\t= ((len > 1)\n+\t\t   ? VEC_last (tree, optimize_stack)\n+\t\t   : NULL_TREE);\n+\n+\t      call_opt_p = true;\n+\t      if (current_optimize_pragma)\n+\t\t{\n+\t\t  bool ok_p\n+\t\t    = parse_optimize_options (current_optimize_pragma, false);\n+\t\t  gcc_assert (ok_p);\t/* should be parsed previously.  */\n+\t\t  optimization_current_node = build_optimization_node ();\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  struct cl_optimization *opt\n+\t\t    = TREE_OPTIMIZATION (optimization_default_node);\n+\t\t  optimization_current_node = optimization_default_node;\n+\t\t  cl_optimization_restore (opt);\n+\t\t}\n+\t    }\n+\t}\n+\n+      else\n+\t{\n+\t  GCC_BAD (\"%<#pragma GCC optimize%> is not a string or \"\n+\t\t   \"push/pop/reset\");\n+\t  return;\n+\t}\n+\n+      token = pragma_lex (&x);\n+      if (close_paren_needed_p)\n+\t{\n+\t  if (token == CPP_CLOSE_PAREN)\n+\t    token = pragma_lex (&x);\n+\t  else\n+\t    GCC_BAD (\"%<#pragma GCC optimize ([push|pop|reset])%> does not \"\n+\t\t     \"have a final %<)%>.\");\n+\t}\n+\n+      if (token != CPP_EOF)\n+\t{\n+\t  GCC_BAD (\"%<#pragma GCC optimize [push|pop|reset]%> is badly \"\n+\t\t   \"formed\");\n+\t  return;\n+\t}\n+\n+      if (call_opt_p &&\n+\t  (optimization_previous_node != optimization_current_node))\n+\tc_cpp_builtins_optimize_pragma (parse_in,\n+\t\t\t\t\toptimization_previous_node,\n+\t\t\t\t\toptimization_current_node);\n+\n+    }\n+\n+  else if (token != CPP_STRING && token != CPP_NUMBER)\n+    {\n+      GCC_BAD (\"%<#pragma GCC optimize%> is not a string, number, or \"\n+\t       \"push/pop/reset\");\n+      return;\n+    }\n+\n+  /* Strings/numbers are user options.  */\n+  else\n+    {\n+      tree args = NULL_TREE;\n+\n+      do\n+\t{\n+\t  /* Build up the numbers/strings now as a list.  */\n+\t  if (token != CPP_STRING || TREE_STRING_LENGTH (x) > 0)\n+\t    args = tree_cons (NULL_TREE, x, args);\n+\n+\t  token = pragma_lex (&x);\n+\t  while (token == CPP_COMMA)\n+\t    token = pragma_lex (&x);\n+\t}\n+      while (token == CPP_STRING || token == CPP_NUMBER);\n+\n+      if (close_paren_needed_p)\n+\t{\n+\t  if (token == CPP_CLOSE_PAREN)\n+\t    token = pragma_lex (&x);\n+\t  else\n+\t    GCC_BAD (\"%<#pragma GCC optimize (string [,string]...)%> does \"\n+\t\t     \"not have a final %<)%>.\");\n+\t}\n+\n+      if (token != CPP_EOF)\n+\t{\n+\t  error (\"#pragma GCC optimize string... is badly formed\");\n+\t  return;\n+\t}\n+\n+      /* put arguments in the order the user typed them.  */\n+      args = nreverse (args);\n+\n+      parse_optimize_options (args, false);\n+      optimization_current_node = build_optimization_node ();\n+      c_cpp_builtins_optimize_pragma (parse_in,\n+\t\t\t\t      optimization_previous_node,\n+\t\t\t\t      optimization_current_node);\n+    }\n+}\n+\n /* A vector of registered pragma callbacks.  */\n \n DEF_VEC_O (pragma_handler);\n@@ -1028,6 +1335,8 @@ init_pragma (void)\n #endif\n \n   c_register_pragma (\"GCC\", \"diagnostic\", handle_pragma_diagnostic);\n+  c_register_pragma (\"GCC\", \"option\", handle_pragma_option);\n+  c_register_pragma (\"GCC\", \"optimize\", handle_pragma_optimize);\n \n   c_register_pragma_with_expansion (0, \"redefine_extname\", handle_pragma_redefine_extname);\n   c_register_pragma (0, \"extern_prefix\", handle_pragma_extern_prefix);"}, {"sha": "2196f749b357fa79ef2da0143553dbdb4d60c507", "filename": "gcc/common.opt", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=ab442df7fb453434d80a779844fe1a10c0c802ab", "patch": "@@ -59,11 +59,11 @@ Common Joined Separate UInteger\n -G<number>\tPut global and static data smaller than <number> bytes into a special section (on some targets)\n \n O\n-Common JoinedOrMissing\n+Common JoinedOrMissing Optimization\n -O<number>\tSet optimization level to <number>\n \n Os\n-Common\n+Common Optimization\n Optimize for space rather than speed\n \n W\n@@ -275,28 +275,28 @@ fabi-version=\n Common Joined UInteger Var(flag_abi_version) Init(2)\n \n falign-functions\n-Common Report Var(align_functions,0)\n+Common Report Var(align_functions,0) Optimization UInteger\n Align the start of functions\n \n falign-functions=\n Common RejectNegative Joined UInteger\n \n falign-jumps\n-Common Report Var(align_jumps,0) Optimization\n+Common Report Var(align_jumps,0) Optimization UInteger\n Align labels which are only reached by jumping\n \n falign-jumps=\n Common RejectNegative Joined UInteger\n \n falign-labels\n-Common Report Var(align_labels,0) Optimization\n+Common Report Var(align_labels,0) Optimization UInteger\n Align all labels\n \n falign-labels=\n Common RejectNegative Joined UInteger\n \n falign-loops\n-Common Report Var(align_loops) Optimization\n+Common Report Var(align_loops) Optimization UInteger\n Align the start of loops\n \n falign-loops=\n@@ -666,7 +666,7 @@ Common\n Does nothing.  Preserved for backward compatibility.\n \n fmath-errno\n-Common Report Var(flag_errno_math) Init(1)\n+Common Report Var(flag_errno_math) Init(1) Optimization\n Set errno after built-in math functions\n \n fmem-report\n@@ -925,7 +925,7 @@ Reschedule instructions after register allocation\n ; sched_stalled_insns means that insns can be moved prematurely from the queue\n ; of stalled insns into the ready list.\n fsched-stalled-insns\n-Common Report Var(flag_sched_stalled_insns) Optimization\n+Common Report Var(flag_sched_stalled_insns) Optimization UInteger\n Allow premature scheduling of queued insns\n \n fsched-stalled-insns=\n@@ -937,7 +937,7 @@ Common RejectNegative Joined UInteger\n ; premature removal from the queue of stalled insns into the ready list (has\n ; an effect only if the flag 'sched_stalled_insns' is set).\n fsched-stalled-insns-dep\n-Common Report Var(flag_sched_stalled_insns_dep,1) Init(1) Optimization\n+Common Report Var(flag_sched_stalled_insns_dep,1) Init(1) Optimization UInteger\n Set dependence distance checking in premature scheduling of queued insns\n \n fsched-stalled-insns-dep="}, {"sha": "bc818e6f585f6b4cda7ad5a455d24b57246658c8", "filename": "gcc/config.gcc", "status": "modified", "additions": 28, "deletions": 24, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=ab442df7fb453434d80a779844fe1a10c0c802ab", "patch": "@@ -294,13 +294,17 @@ fido-*-*)\n         ;;\n i[34567]86-*-*)\n \tcpu_type=i386\n+\tc_target_objs=\"i386-c.o\"\n+\tcxx_target_objs=\"i386-c.o\"\n \textra_headers=\"cpuid.h mmintrin.h mm3dnow.h xmmintrin.h emmintrin.h\n \t\t       pmmintrin.h tmmintrin.h ammintrin.h smmintrin.h\n \t\t       nmmintrin.h bmmintrin.h mmintrin-common.h\n \t\t       wmmintrin.h cross-stdarg.h\"\n \t;;\n x86_64-*-*)\n \tcpu_type=i386\n+\tc_target_objs=\"i386-c.o\"\n+\tcxx_target_objs=\"i386-c.o\"\n \textra_headers=\"cpuid.h mmintrin.h mm3dnow.h xmmintrin.h emmintrin.h\n \t\t       pmmintrin.h tmmintrin.h ammintrin.h smmintrin.h\n \t\t       nmmintrin.h bmmintrin.h mmintrin-common.h\n@@ -410,8 +414,8 @@ case ${target} in\n   tmake_file=\"t-darwin ${cpu_type}/t-darwin t-slibgcc-darwin\"\n   target_gtfiles=\"\\$(srcdir)/config/darwin.c\"\n   extra_options=\"${extra_options} darwin.opt\"\n-  c_target_objs=\"darwin-c.o\"\n-  cxx_target_objs=\"darwin-c.o\"\n+  c_target_objs=\"${c_target_objs} darwin-c.o\"\n+  cxx_target_objs=\"${cxx_target_objs} darwin-c.o\"\n   fortran_target_objs=\"darwin-f.o\"\n   extra_objs=\"darwin.o\"\n   extra_gcc_objs=\"darwin-driver.o\"\n@@ -1028,16 +1032,16 @@ i[34567]86-*-darwin*)\n \t;;\n x86_64-*-darwin*)\n \twith_cpu=${with_cpu:-generic}\n-\ttmake_file=\"t-darwin ${cpu_type}/t-darwin64 t-slibgcc-darwin i386/t-crtpc i386/t-crtfm\"\n+\ttmake_file=\"${tmake_file} t-darwin ${cpu_type}/t-darwin64 t-slibgcc-darwin i386/t-crtpc i386/t-crtfm\"\n \ttm_file=\"${tm_file} ${cpu_type}/darwin64.h\"\n \t;;\n i[34567]86-*-elf*)\n \ttm_file=\"${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h i386/i386elf.h\"\n-\ttmake_file=\"i386/t-i386elf t-svr4\"\n+\ttmake_file=\"${tmake_file} i386/t-i386elf t-svr4\"\n \t;;\n x86_64-*-elf*)\n \ttm_file=\"${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h i386/i386elf.h i386/x86-64.h\"\n-\ttmake_file=\"i386/t-i386elf t-svr4\"\n+\ttmake_file=\"${tmake_file} i386/t-i386elf t-svr4\"\n \t;;\n i[34567]86-*-aout*)\n \ttm_file=\"${tm_file} i386/unix.h i386/bsd.h i386/gas.h i386/gstabs.h i386/i386-aout.h\"\n@@ -1054,7 +1058,7 @@ i[34567]86-*-netbsdelf*)\n \t;;\n i[34567]86-*-netbsd*)\n \ttm_file=\"${tm_file} i386/unix.h i386/bsd.h i386/gas.h i386/gstabs.h netbsd.h netbsd-aout.h i386/netbsd.h\"\n-\ttmake_file=t-netbsd\n+\ttmake_file=\"${tmake_file} t-netbsd\"\n \textra_parts=\"\"\n \tuse_collect2=yes\n \t;;\n@@ -1065,7 +1069,7 @@ x86_64-*-netbsd*)\n i[34567]86-*-openbsd2.*|i[34567]86-*openbsd3.[0123])\n \ttm_file=\"i386/i386.h i386/unix.h i386/bsd.h i386/gas.h i386/gstabs.h openbsd-oldgas.h openbsd.h i386/openbsd.h\"\n \t# needed to unconfuse gdb\n-\ttmake_file=\"t-libc-ok t-openbsd i386/t-openbsd\"\n+\ttmake_file=\"${tmake_file} t-libc-ok t-openbsd i386/t-openbsd\"\n \t# we need collect2 until our bug is fixed...\n \tuse_collect2=yes\n \t;;\n@@ -1126,15 +1130,15 @@ i[34567]86-*-gnu*)\n i[34567]86-pc-msdosdjgpp*)\n \txm_file=i386/xm-djgpp.h\n \ttm_file=\"dbxcoff.h ${tm_file} i386/unix.h i386/bsd.h i386/gas.h i386/djgpp.h\"\n-\ttmake_file=i386/t-djgpp\n+\ttmake_file=\"${tmake_file} i386/t-djgpp\"\n \textra_options=\"${extra_options} i386/djgpp.opt\"\n \tgnu_ld=yes\n \tgas=yes\n \t;;\n i[34567]86-*-lynxos*)\n \txm_defines=POSIX\n \ttm_file=\"${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h i386/lynx.h lynx.h\"\n-\ttmake_file=\"i386/t-crtstuff t-lynx\"\n+\ttmake_file=\"${tmake_file} i386/t-crtstuff t-lynx\"\n \textra_parts=\"crtbegin.o crtbeginS.o crtend.o crtendS.o\"\n \textra_options=\"${extra_options} lynx.opt\"\n \tthread_file=lynx\n@@ -1143,7 +1147,7 @@ i[34567]86-*-lynxos*)\n \t;;\n i[3456x]86-*-netware*)\n \ttm_file=\"${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h svr4.h tm-dwarf2.h i386/netware.h\"\n- \ttmake_file=i386/t-netware\n+ \ttmake_file=\"${tmake_file} i386/t-netware\"\n \textra_objs=netware.o\n \tcase /${with_ld} in\n \t*/nwld)\n@@ -1162,14 +1166,14 @@ i[3456x]86-*-netware*)\n \t;;\n i[34567]86-*-nto-qnx*)\n \ttm_file=\"${tm_file} i386/att.h dbxelf.h tm-dwarf2.h elfos.h svr4.h i386/unix.h i386/nto.h\"\n-\ttmake_file=i386/t-nto\n+\ttmake_file=\"${tmake_file} i386/t-nto\"\n \tgnu_ld=yes\n \tgas=yes\n \t;;\n i[34567]86-*-rtems*)\n \ttm_file=\"${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h i386/i386elf.h i386/rtemself.h rtems.h\"\n \textra_parts=\"crtbegin.o crtend.o crti.o crtn.o\"\n-\ttmake_file=\"i386/t-rtems-i386 i386/t-crtstuff t-rtems\"\n+\ttmake_file=\"${tmake_file} i386/t-rtems-i386 i386/t-crtstuff t-rtems\"\n \t;;\n i[34567]86-*-solaris2*)\n \ttm_file=\"${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h svr4.h i386/sysv4.h sol2.h\"\n@@ -1179,9 +1183,9 @@ i[34567]86-*-solaris2*)\n \t\t;;\n \tesac\n \ttm_file=\"${tm_file} i386/sol2.h\"\n-\ttmake_file=\"t-sol2 i386/t-sol2 t-svr4\"\n-\tc_target_objs=\"sol2-c.o\"\n-\tcxx_target_objs=\"sol2-c.o\"\n+\ttmake_file=\"${tmake_file} t-sol2 i386/t-sol2 t-svr4\"\n+\tc_target_objs=\"${c_target_objs} sol2-c.o\"\n+\tcxx_target_objs=\"${cxx_target_objs} sol2-c.o\"\n \textra_objs=\"sol2.o\"\n \ttm_p_file=\"${tm_p_file} sol2-protos.h\"\n \tif test x$gnu_ld = xyes; then\n@@ -1247,12 +1251,12 @@ i[4567]86-wrs-vxworks|i[4567]86-wrs-vxworksae)\n i[34567]86-*-pe | i[34567]86-*-cygwin*)\n \ttm_file=\"${tm_file} i386/unix.h i386/bsd.h i386/gas.h dbxcoff.h i386/cygming.h i386/cygwin.h\"\n \txm_file=i386/xm-cygwin.h\n-\ttmake_file=\"i386/t-cygwin i386/t-cygming\"\n+\ttmake_file=\"${tmake_file} i386/t-cygwin i386/t-cygming\"\n \ttarget_gtfiles=\"\\$(srcdir)/config/i386/winnt.c\"\n \textra_options=\"${extra_options} i386/cygming.opt\"\n \textra_objs=\"winnt.o winnt-stubs.o\"\n-\tc_target_objs=\"cygwin2.o msformat-c.o\"\n-\tcxx_target_objs=\"cygwin2.o winnt-cxx.o msformat-c.o\"\n+\tc_target_objs=\"${c_target_objs} cygwin2.o msformat-c.o\"\n+\tcxx_target_objs=\"${cxx_target_objs} cygwin2.o winnt-cxx.o msformat-c.o\"\n \textra_gcc_objs=cygwin1.o\n \tif test x$enable_threads = xyes; then\n \t\tthread_file='posix'\n@@ -1261,12 +1265,12 @@ i[34567]86-*-pe | i[34567]86-*-cygwin*)\n i[34567]86-*-mingw* | x86_64-*-mingw*)\n \ttm_file=\"${tm_file} i386/unix.h i386/bsd.h i386/gas.h dbxcoff.h i386/cygming.h i386/mingw32.h\"\n \txm_file=i386/xm-mingw32.h\n-\ttmake_file=\"i386/t-cygming i386/t-mingw32\"\n+\ttmake_file=\"${tmake_file} i386/t-cygming i386/t-mingw32\"\n \ttarget_gtfiles=\"\\$(srcdir)/config/i386/winnt.c\"\n \textra_options=\"${extra_options} i386/cygming.opt\"\n \textra_objs=\"winnt.o winnt-stubs.o\"\n-\tc_target_objs=\"msformat-c.o\"\n-\tcxx_target_objs=\"winnt-cxx.o msformat-c.o\"\n+\tc_target_objs=\"${c_target_objs} msformat-c.o\"\n+\tcxx_target_objs=\"${cxx_target_objs} winnt-cxx.o msformat-c.o\"\n \tdefault_use_cxa_atexit=yes\n \tcase ${enable_threads} in\n \t  \"\" | yes | win32)\n@@ -1291,7 +1295,7 @@ i[34567]86-*-mingw* | x86_64-*-mingw*)\n \t;;\n i[34567]86-*-interix3*)\n \ttm_file=\"${tm_file} i386/unix.h i386/bsd.h i386/gas.h i386/i386-interix.h i386/i386-interix3.h interix.h interix3.h\"\n-\ttmake_file=\"i386/t-interix\"\n+\ttmake_file=\"${tmake_file} i386/t-interix\"\n \textra_objs=winnt.o\n \ttarget_gtfiles=\"\\$(srcdir)/config/i386/winnt.c\"\n \tif test x$enable_threads = xyes ; then\n@@ -2369,10 +2373,10 @@ esac\n \n case ${target} in\n i[34567]86-*-linux* | x86_64-*-linux*)\n-\ttmake_file=\"${tmake_file} i386/t-pmm_malloc\"\n+\ttmake_file=\"${tmake_file} i386/t-pmm_malloc i386/t-i386\"\n \t;;\n i[34567]86-*-* | x86_64-*-*)\n-\ttmake_file=\"${tmake_file} i386/t-gmm_malloc\"\n+\ttmake_file=\"${tmake_file} i386/t-gmm_malloc i386/t-i386\"\n \t;;\n esac\n "}, {"sha": "c6ed10d8a729173a5a2e88909dfd9726acf42389", "filename": "gcc/config/i386/darwin.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Fconfig%2Fi386%2Fdarwin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Fconfig%2Fi386%2Fdarwin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fdarwin.h?ref=ab442df7fb453434d80a779844fe1a10c0c802ab", "patch": "@@ -263,8 +263,8 @@ extern void darwin_x86_file_end (void);\n    : (n) >= 11 && (n) <= 18 ? (n) + 1\t\t\t\t\t\\\n    : (n))\n \n-#undef REGISTER_TARGET_PRAGMAS\n-#define REGISTER_TARGET_PRAGMAS() DARWIN_REGISTER_TARGET_PRAGMAS()\n+#undef REGISTER_SUBTARGET_PRAGMAS\n+#define REGISTER_SUBTARGET_PRAGMAS() DARWIN_REGISTER_TARGET_PRAGMAS()\n \n #undef TARGET_SET_DEFAULT_TYPE_ATTRIBUTES\n #define TARGET_SET_DEFAULT_TYPE_ATTRIBUTES darwin_set_default_type_attributes"}, {"sha": "f0a3a17f9f65afdd1badd04f36a73e512d3c0eab", "filename": "gcc/config/i386/i386-c.c", "status": "added", "additions": 344, "deletions": 0, "changes": 344, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Fconfig%2Fi386%2Fi386-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Fconfig%2Fi386%2Fi386-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-c.c?ref=ab442df7fb453434d80a779844fe1a10c0c802ab", "patch": "@@ -0,0 +1,344 @@\n+/* Subroutines used for macro/preprocessor support on the ia-32.\n+   Copyright (C) 2008\n+   Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"rtl.h\"\n+#include \"tree.h\"\n+#include \"tm_p.h\"\n+#include \"flags.h\"\n+#include \"c-common.h\"\n+#include \"ggc.h\"\n+#include \"target.h\"\n+#include \"target-def.h\"\n+#include \"cpplib.h\"\n+#include \"c-pragma.h\"\n+\n+static bool ix86_pragma_option_parse (tree);\n+static void ix86_target_macros_internal\n+  (int, enum processor_type, enum processor_type, enum fpmath_unit,\n+   void (*def_or_undef) (cpp_reader *, const char *));\n+\n+\f\n+/* Internal function to either define or undef the appropriate system\n+   macros.  */\n+static void\n+ix86_target_macros_internal (int isa_flag,\n+\t\t\t     enum processor_type arch,\n+\t\t\t     enum processor_type tune,\n+\t\t\t     enum fpmath_unit fpmath,\n+\t\t\t     void (*def_or_undef) (cpp_reader *,\n+\t\t\t\t\t\t   const char *))\n+{\n+  /* For some of the k6/pentium varients there weren't seperate ISA bits to\n+     identify which tune/arch flag was passed, so figure it out here.  */\n+  size_t arch_len = strlen (ix86_arch_string);\n+  size_t tune_len = strlen (ix86_tune_string);\n+  int last_arch_char = ix86_arch_string[arch_len - 1];\n+  int last_tune_char = ix86_tune_string[tune_len - 1];\n+\n+  /* Built-ins based on -march=.  */\n+  switch (arch)\n+    {\n+    case PROCESSOR_I386:\n+      break;\n+    case PROCESSOR_I486:\n+      def_or_undef (parse_in, \"__i486\");\n+      def_or_undef (parse_in, \"__i486__\");\n+      break;\n+    case PROCESSOR_PENTIUM:\n+      def_or_undef (parse_in, \"__i586\");\n+      def_or_undef (parse_in, \"__i586__\");\n+      def_or_undef (parse_in, \"__pentium\");\n+      def_or_undef (parse_in, \"__pentium__\");\n+      if (isa_flag & OPTION_MASK_ISA_MMX)\n+\tdef_or_undef (parse_in, \"__pentium_mmx__\");\n+      break;\n+    case PROCESSOR_PENTIUMPRO:\n+      def_or_undef (parse_in, \"__i686\");\n+      def_or_undef (parse_in, \"__i686__\");\n+      def_or_undef (parse_in, \"__pentiumpro\");\n+      def_or_undef (parse_in, \"__pentiumpro__\");\n+      break;\n+    case PROCESSOR_GEODE:\n+      def_or_undef (parse_in, \"__geode\");\n+      def_or_undef (parse_in, \"__geode__\");\n+      break;\n+    case PROCESSOR_K6:\n+      def_or_undef (parse_in, \"__k6\");\n+      def_or_undef (parse_in, \"__k6__\");\n+      if (last_arch_char == '2')\n+\tdef_or_undef (parse_in, \"__k6_2__\");\n+      else if (last_arch_char == '3')\n+\tdef_or_undef (parse_in, \"__k6_3__\");\n+      else if (isa_flag & OPTION_MASK_ISA_3DNOW)\n+\tdef_or_undef (parse_in, \"__k6_3__\");\n+      break;\n+    case PROCESSOR_ATHLON:\n+      def_or_undef (parse_in, \"__athlon\");\n+      def_or_undef (parse_in, \"__athlon__\");\n+      if (isa_flag & OPTION_MASK_ISA_SSE)\n+\tdef_or_undef (parse_in, \"__athlon_sse__\");\n+      break;\n+    case PROCESSOR_K8:\n+      def_or_undef (parse_in, \"__k8\");\n+      def_or_undef (parse_in, \"__k8__\");\n+      break;\n+    case PROCESSOR_AMDFAM10:\n+      def_or_undef (parse_in, \"__amdfam10\");\n+      def_or_undef (parse_in, \"__amdfam10__\");\n+      break;\n+    case PROCESSOR_PENTIUM4:\n+      def_or_undef (parse_in, \"__pentium4\");\n+      def_or_undef (parse_in, \"__pentium4__\");\n+      break;\n+    case PROCESSOR_NOCONA:\n+      def_or_undef (parse_in, \"__nocona\");\n+      def_or_undef (parse_in, \"__nocona__\");\n+      break;\n+    case PROCESSOR_CORE2:\n+      def_or_undef (parse_in, \"__core2\");\n+      def_or_undef (parse_in, \"__core2__\");\n+      break;\n+    /* use PROCESSOR_max to not set/unset the arch macro.  */\n+    case PROCESSOR_max:\n+      break;\n+    case PROCESSOR_GENERIC32:\n+    case PROCESSOR_GENERIC64:\n+      gcc_unreachable ();\n+    }\n+\n+  /* Built-ins based on -mtune=.  */\n+  switch (tune)\n+    {\n+    case PROCESSOR_I386:\n+      def_or_undef (parse_in, \"__tune_i386__\");\n+      break;\n+    case PROCESSOR_I486:\n+      def_or_undef (parse_in, \"__tune_i486__\");\n+      break;\n+    case PROCESSOR_PENTIUM:\n+      def_or_undef (parse_in, \"__tune_i586__\");\n+      def_or_undef (parse_in, \"__tune_pentium__\");\n+      if (last_tune_char == 'x')\n+\tdef_or_undef (parse_in, \"__tune_pentium_mmx__\");\n+      break;\n+    case PROCESSOR_PENTIUMPRO:\n+      def_or_undef (parse_in, \"__tune_i686__\");\n+      def_or_undef (parse_in, \"__tune_pentiumpro__\");\n+      switch (last_tune_char)\n+\t{\n+\tcase '3':\n+\t  def_or_undef (parse_in, \"__tune_pentium3__\");\n+\t  /* FALLTHRU */\n+\tcase '2':\n+\t  def_or_undef (parse_in, \"__tune_pentium2__\");\n+\t  break;\n+\t}\n+      break;\n+    case PROCESSOR_GEODE:\n+      def_or_undef (parse_in, \"__tune_geode__\");\n+      break;\n+    case PROCESSOR_K6:\n+      def_or_undef (parse_in, \"__tune_k6__\");\n+      if (last_tune_char == '2')\n+\tdef_or_undef (parse_in, \"__tune_k6_2__\");\n+      else if (last_tune_char == '3')\n+\tdef_or_undef (parse_in, \"__tune_k6_3__\");\n+      else if (isa_flag & OPTION_MASK_ISA_3DNOW)\n+\tdef_or_undef (parse_in, \"__tune_k6_3__\");\n+      break;\n+    case PROCESSOR_ATHLON:\n+      def_or_undef (parse_in, \"__tune_athlon__\");\n+      if (isa_flag & OPTION_MASK_ISA_SSE)\n+\tdef_or_undef (parse_in, \"__tune_athlon_sse__\");\n+      break;\n+    case PROCESSOR_K8:\n+      def_or_undef (parse_in, \"__tune_k8__\");\n+      break;\n+    case PROCESSOR_AMDFAM10:\n+      def_or_undef (parse_in, \"__tune_amdfam10__\");\n+      break;\n+    case PROCESSOR_PENTIUM4:\n+      def_or_undef (parse_in, \"__tune_pentium4__\");\n+      break;\n+    case PROCESSOR_NOCONA:\n+      def_or_undef (parse_in, \"__tune_nocona__\");\n+      break;\n+    case PROCESSOR_CORE2:\n+      def_or_undef (parse_in, \"__tune_core2__\");\n+      break;\n+    case PROCESSOR_GENERIC32:\n+    case PROCESSOR_GENERIC64:\n+      break;\n+    /* use PROCESSOR_max to not set/unset the tune macro.  */\n+    case PROCESSOR_max:\n+      break;\n+    }\n+\n+  if (isa_flag & OPTION_MASK_ISA_MMX)\n+    def_or_undef (parse_in, \"__MMX__\");\n+  if (isa_flag & OPTION_MASK_ISA_3DNOW)\n+    def_or_undef (parse_in, \"__3dNOW__\");\n+  if (isa_flag & OPTION_MASK_ISA_3DNOW_A)\n+    def_or_undef (parse_in, \"__3dNOW_A__\");\n+  if (isa_flag & OPTION_MASK_ISA_SSE)\n+    def_or_undef (parse_in, \"__SSE__\");\n+  if (isa_flag & OPTION_MASK_ISA_SSE2)\n+    def_or_undef (parse_in, \"__SSE2__\");\n+  if (isa_flag & OPTION_MASK_ISA_SSE3)\n+    def_or_undef (parse_in, \"__SSE3__\");\n+  if (isa_flag & OPTION_MASK_ISA_SSSE3)\n+    def_or_undef (parse_in, \"__SSSE3__\");\n+  if (isa_flag & OPTION_MASK_ISA_SSE4_1)\n+    def_or_undef (parse_in, \"__SSE4_1__\");\n+  if (isa_flag & OPTION_MASK_ISA_SSE4_2)\n+    def_or_undef (parse_in, \"__SSE4_2__\");\n+  if (isa_flag & OPTION_MASK_ISA_AES)\n+    def_or_undef (parse_in, \"__AES__\");\n+  if (isa_flag & OPTION_MASK_ISA_PCLMUL)\n+    def_or_undef (parse_in, \"__PCLMUL__\");\n+  if (isa_flag & OPTION_MASK_ISA_SSE4A)\n+    def_or_undef (parse_in, \"__SSE4A__\");\n+  if (isa_flag & OPTION_MASK_ISA_SSE5)\n+    def_or_undef (parse_in, \"__SSE5__\");\n+  if ((fpmath & FPMATH_SSE) && (isa_flag & OPTION_MASK_ISA_SSE))\n+    def_or_undef (parse_in, \"__SSE_MATH__\");\n+  if ((fpmath & FPMATH_SSE) && (isa_flag & OPTION_MASK_ISA_SSE2))\n+    def_or_undef (parse_in, \"__SSE2_MATH__\");\n+}\n+\n+\f\n+/* Hook to validate the current #pragma option and set the state, and update\n+   the macros based on what was changed.  */\n+\n+static bool\n+ix86_pragma_option_parse (tree args)\n+{\n+  tree prev_tree = build_target_option_node ();\n+  tree cur_tree;\n+  struct cl_target_option *prev_opt;\n+  struct cl_target_option *cur_opt;\n+  int prev_isa;\n+  int cur_isa;\n+  int diff_isa;\n+  enum processor_type prev_arch;\n+  enum processor_type prev_tune;\n+  enum processor_type cur_arch;\n+  enum processor_type cur_tune;\n+\n+  if (! args)\n+    {\n+      cur_tree = target_option_default_node;\n+      cl_target_option_restore (TREE_TARGET_OPTION (cur_tree));\n+    }\n+  else\n+    {\n+      cur_tree = ix86_valid_option_attribute_tree (args);\n+      if (!cur_tree)\n+\treturn false;\n+    }\n+\n+  target_option_current_node = cur_tree;\n+\n+  /* Figure out the previous/current isa, arch, tune and the differences.  */\n+  prev_opt  = TREE_TARGET_OPTION (prev_tree);\n+  cur_opt   = TREE_TARGET_OPTION (cur_tree);\n+  prev_isa  = prev_opt->ix86_isa_flags;\n+  cur_isa   = cur_opt->ix86_isa_flags;\n+  diff_isa  = (prev_isa ^ cur_isa);\n+  prev_arch = prev_opt->arch;\n+  prev_tune = prev_opt->tune;\n+  cur_arch  = cur_opt->arch;\n+  cur_tune  = cur_opt->tune;\n+\n+  /* If the same processor is used for both previous and current options, don't\n+     change the macros.  */\n+  if (cur_arch == prev_arch)\n+    cur_arch = prev_arch = PROCESSOR_max;\n+\n+  if (cur_tune == prev_tune)\n+    cur_tune = prev_tune = PROCESSOR_max;\n+\n+  /* Undef all of the macros for that are no longer current.  */\n+  ix86_target_macros_internal (prev_isa & diff_isa,\n+\t\t\t       prev_arch,\n+\t\t\t       prev_tune,\n+\t\t\t       prev_opt->fpmath,\n+\t\t\t       cpp_undef);\n+\n+  /* Define all of the macros for new options that were just turned on.  */\n+  ix86_target_macros_internal (cur_isa & diff_isa,\n+\t\t\t       cur_arch,\n+\t\t\t       cur_tune,\n+\t\t\t       cur_opt->fpmath,\n+\t\t\t       cpp_define);\n+\n+  return true;\n+}\n+\f\n+/* Function to tell the preprocessor about the defines for the current target.  */\n+\n+void\n+ix86_target_macros (void)\n+{\n+  /* 32/64-bit won't change with target specific options, so do the assert and\n+     builtin_define_std calls here.  */\n+  if (TARGET_64BIT)\n+    {\n+      cpp_assert (parse_in, \"cpu=x86_64\");\n+      cpp_assert (parse_in, \"machine=x86_64\");\n+      cpp_define (parse_in, \"__amd64\");\n+      cpp_define (parse_in, \"__amd64__\");\n+      cpp_define (parse_in, \"__x86_64\");\n+      cpp_define (parse_in, \"__x86_64__\");\n+    }\n+  else\n+    {\n+      cpp_assert (parse_in, \"cpu=i386\");\n+      cpp_assert (parse_in, \"machine=i386\");\n+      builtin_define_std (\"i386\");\n+    }\n+\n+  ix86_target_macros_internal (ix86_isa_flags,\n+\t\t\t       ix86_arch,\n+\t\t\t       ix86_tune,\n+\t\t\t       ix86_fpmath,\n+\t\t\t       cpp_define);\n+}\n+\n+\f\n+/* Register target pragmas.  We need to add the hook for parsing #pragma GCC\n+   option here rather than in i386.c since it will pull in various preprocessor\n+   functions, and those are not present in languages like fortran without a\n+   preprocessor.  */\n+\n+void\n+ix86_register_pragmas (void)\n+{\n+  /* Update pragma hook to allow parsing #pragma GCC option.  */\n+  targetm.target_option.pragma_parse = ix86_pragma_option_parse;\n+\n+#ifdef REGISTER_SUBTARGET_PRAGMAS\n+  REGISTER_SUBTARGET_PRAGMAS ();\n+#endif\n+}"}, {"sha": "3ebfd3cd9a9e8b3a7f8ef3e80cef07eacd80551a", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=ab442df7fb453434d80a779844fe1a10c0c802ab", "patch": "@@ -20,7 +20,7 @@ along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n /* Functions in i386.c */\n-extern void override_options (void);\n+extern void override_options (bool);\n extern void optimization_options (int, int);\n \n extern int ix86_can_use_return_insn_p (void);\n@@ -202,6 +202,7 @@ extern int ix86_constant_alignment (tree, int);\n extern tree ix86_handle_shared_attribute (tree *, tree, tree, int, bool *);\n extern tree ix86_handle_selectany_attribute (tree *, tree, tree, int, bool *);\n extern int x86_field_alignment (tree, int);\n+extern tree ix86_valid_option_attribute_tree (tree);\n #endif\n \n extern rtx ix86_tls_get_addr (void);\n@@ -215,6 +216,10 @@ extern void ix86_expand_reduc_v4sf (rtx (*)(rtx, rtx, rtx), rtx, rtx);\n extern bool ix86_sse5_valid_op_p (rtx [], rtx, int, bool, int, bool);\n extern void ix86_expand_sse5_multiple_memory (rtx [], int, enum machine_mode);\n \n+/* In i386-c.c  */\n+extern void ix86_target_macros (void);\n+extern void ix86_register_pragmas (void);\n+\n /* In winnt.c  */\n extern void i386_pe_unique_section (tree, int);\n extern void i386_pe_declare_function_type (FILE *, const char *, int);"}, {"sha": "fbe4bb6b227f4b83db861ccfde5a98d43814204c", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 1048, "deletions": 140, "changes": 1188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=ab442df7fb453434d80a779844fe1a10c0c802ab", "patch": "@@ -1210,7 +1210,11 @@ const struct processor_costs *ix86_cost = &pentium_cost;\n #define m_GENERIC (m_GENERIC32 | m_GENERIC64)\n \n /* Feature tests against the various tunings.  */\n-unsigned int ix86_tune_features[X86_TUNE_LAST] = {\n+unsigned char ix86_tune_features[X86_TUNE_LAST];\n+\n+/* Feature tests against the various tunings used to create ix86_tune_features\n+   based on the processor mask.  */\n+static unsigned int initial_ix86_tune_features[X86_TUNE_LAST] = {\n   /* X86_TUNE_USE_LEAVE: Leave does not affect Nocona SPEC2000 results\n      negatively, so enabling for Generic64 seems like good code size\n      tradeoff.  We can't enable it for 32bit generic because it does not\n@@ -1443,7 +1447,11 @@ unsigned int ix86_tune_features[X86_TUNE_LAST] = {\n };\n \n /* Feature tests against the various architecture variations.  */\n-unsigned int ix86_arch_features[X86_ARCH_LAST] = {\n+unsigned char ix86_arch_features[X86_ARCH_LAST];\n+\n+/* Feature tests against the various architecture variations, used to create\n+   ix86_arch_features based on the processor mask.  */\n+static unsigned int initial_ix86_arch_features[X86_ARCH_LAST] = {\n   /* X86_ARCH_CMOVE: Conditional move was added for pentiumpro.  */\n   ~(m_386 | m_486 | m_PENT | m_K6),\n \n@@ -1773,13 +1781,37 @@ static void ix86_compute_frame_layout (struct ix86_frame *);\n static bool ix86_expand_vector_init_one_nonzero (bool, enum machine_mode,\n \t\t\t\t\t\t rtx, rtx, int);\n \n+enum ix86_function_specific_strings\n+{\n+  IX86_FUNCTION_SPECIFIC_ARCH,\n+  IX86_FUNCTION_SPECIFIC_TUNE,\n+  IX86_FUNCTION_SPECIFIC_FPMATH,\n+  IX86_FUNCTION_SPECIFIC_MAX\n+};\n+\n+static char *ix86_target_string (int, int, const char *, const char *,\n+\t\t\t\t const char *, bool);\n+static void ix86_debug_options (void) ATTRIBUTE_UNUSED;\n+static void ix86_function_specific_save (struct cl_target_option *);\n+static void ix86_function_specific_restore (struct cl_target_option *);\n+static void ix86_function_specific_print (FILE *, int,\n+\t\t\t\t\t  struct cl_target_option *);\n+static bool ix86_valid_option_attribute_p (tree, tree, tree, int);\n+static bool ix86_valid_option_attribute_inner_p (tree, char *[]);\n+static bool ix86_can_inline_p (tree, tree);\n+static void ix86_set_current_function (tree);\n+\n \f\n /* The svr4 ABI for the i386 says that records and unions are returned\n    in memory.  */\n #ifndef DEFAULT_PCC_STRUCT_RETURN\n #define DEFAULT_PCC_STRUCT_RETURN 1\n #endif\n \n+/* Whether -mtune= or -march= were specified */\n+static int ix86_tune_defaulted;\n+static int ix86_arch_specified;\n+\n /* Bit flags that specify the ISA we are compiling for.  */\n int ix86_isa_flags = TARGET_64BIT_DEFAULT | TARGET_SUBTARGET_ISA_DEFAULT;\n \n@@ -1815,6 +1847,18 @@ static int ix86_isa_flags_explicit;\n #define OPTION_MASK_ISA_SSE5_SET \\\n   (OPTION_MASK_ISA_SSE5 | OPTION_MASK_ISA_SSE4A_SET)\n \n+/* AES and PCLMUL need SSE2 because they use xmm registers */\n+#define OPTION_MASK_ISA_AES_SET \\\n+  (OPTION_MASK_ISA_AES | OPTION_MASK_ISA_SSE2_SET)\n+#define OPTION_MASK_ISA_PCLMUL_SET \\\n+  (OPTION_MASK_ISA_PCLMUL | OPTION_MASK_ISA_SSE2_SET)\n+\n+#define OPTION_MASK_ISA_ABM_SET \\\n+  (OPTION_MASK_ISA_ABM | OPTION_MASK_ISA_POPCNT)\n+#define OPTION_MASK_ISA_POPCNT_SET OPTION_MASK_ISA_POPCNT\n+#define OPTION_MASK_ISA_CX16_SET OPTION_MASK_ISA_CX16\n+#define OPTION_MASK_ISA_SAHF_SET OPTION_MASK_ISA_SAHF\n+\n /* Define a set of ISAs which aren't available when a given ISA is\n    disabled.  MMX and SSE ISAs are handled separately.  */\n \n@@ -1844,14 +1888,73 @@ static int ix86_isa_flags_explicit;\n \n #define OPTION_MASK_ISA_SSE4A_UNSET \\\n   (OPTION_MASK_ISA_SSE4A | OPTION_MASK_ISA_SSE5_UNSET)\n-\n #define OPTION_MASK_ISA_SSE5_UNSET OPTION_MASK_ISA_SSE5\n+#define OPTION_MASK_ISA_AES_UNSET OPTION_MASK_ISA_AES\n+#define OPTION_MASK_ISA_PCLMUL_UNSET OPTION_MASK_ISA_PCLMUL\n+#define OPTION_MASK_ISA_ABM_UNSET OPTION_MASK_ISA_ABM\n+#define OPTION_MASK_ISA_POPCNT_UNSET OPTION_MASK_ISA_POPCNT\n+#define OPTION_MASK_ISA_CX16_UNSET OPTION_MASK_ISA_CX16\n+#define OPTION_MASK_ISA_SAHF_UNSET OPTION_MASK_ISA_SAHF\n \n /* Vectorization library interface and handlers.  */\n tree (*ix86_veclib_handler)(enum built_in_function, tree, tree) = NULL;\n static tree ix86_veclibabi_svml (enum built_in_function, tree, tree);\n static tree ix86_veclibabi_acml (enum built_in_function, tree, tree);\n \n+/* Processor target table, indexed by processor number */\n+struct ptt\n+{\n+  const struct processor_costs *cost;\t\t/* Processor costs */\n+  const int align_loop;\t\t\t\t/* Default alignments.  */\n+  const int align_loop_max_skip;\n+  const int align_jump;\n+  const int align_jump_max_skip;\n+  const int align_func;\n+};\n+\n+static const struct ptt processor_target_table[PROCESSOR_max] =\n+{\n+  {&i386_cost, 4, 3, 4, 3, 4},\n+  {&i486_cost, 16, 15, 16, 15, 16},\n+  {&pentium_cost, 16, 7, 16, 7, 16},\n+  {&pentiumpro_cost, 16, 15, 16, 10, 16},\n+  {&geode_cost, 0, 0, 0, 0, 0},\n+  {&k6_cost, 32, 7, 32, 7, 32},\n+  {&athlon_cost, 16, 7, 16, 7, 16},\n+  {&pentium4_cost, 0, 0, 0, 0, 0},\n+  {&k8_cost, 16, 7, 16, 7, 16},\n+  {&nocona_cost, 0, 0, 0, 0, 0},\n+  {&core2_cost, 16, 10, 16, 10, 16},\n+  {&generic32_cost, 16, 7, 16, 7, 16},\n+  {&generic64_cost, 16, 10, 16, 10, 16},\n+  {&amdfam10_cost, 32, 24, 32, 7, 32}\n+};\n+\n+static const char *const cpu_names[TARGET_CPU_DEFAULT_max] =\n+{\n+  \"generic\",\n+  \"i386\",\n+  \"i486\",\n+  \"pentium\",\n+  \"pentium-mmx\",\n+  \"pentiumpro\",\n+  \"pentium2\",\n+  \"pentium3\",\n+  \"pentium4\",\n+  \"pentium-m\",\n+  \"prescott\",\n+  \"nocona\",\n+  \"core2\",\n+  \"geode\",\n+  \"k6\",\n+  \"k6-2\",\n+  \"k6-3\",\n+  \"athlon\",\n+  \"athlon-4\",\n+  \"k8\",\n+  \"amdfam10\"\n+};\n+\f\n /* Implement TARGET_HANDLE_OPTION.  */\n \n static bool\n@@ -2002,11 +2105,294 @@ ix86_handle_option (size_t code, const char *arg ATTRIBUTE_UNUSED, int value)\n \t}\n       return true;\n \n+    case OPT_mabm:\n+      if (value)\n+\t{\n+\t  ix86_isa_flags |= OPTION_MASK_ISA_ABM_SET;\n+\t  ix86_isa_flags_explicit |= OPTION_MASK_ISA_ABM_SET;\n+\t}\n+      else\n+\t{\n+\t  ix86_isa_flags &= ~OPTION_MASK_ISA_ABM_UNSET;\n+\t  ix86_isa_flags_explicit |= OPTION_MASK_ISA_ABM_UNSET;\n+\t}\n+      return true;\n+\n+    case OPT_mpopcnt:\n+      if (value)\n+\t{\n+\t  ix86_isa_flags |= OPTION_MASK_ISA_POPCNT_SET;\n+\t  ix86_isa_flags_explicit |= OPTION_MASK_ISA_POPCNT_SET;\n+\t}\n+      else\n+\t{\n+\t  ix86_isa_flags &= ~OPTION_MASK_ISA_POPCNT_UNSET;\n+\t  ix86_isa_flags_explicit |= OPTION_MASK_ISA_POPCNT_UNSET;\n+\t}\n+      return true;\n+\n+    case OPT_msahf:\n+      if (value)\n+\t{\n+\t  ix86_isa_flags |= OPTION_MASK_ISA_SAHF_SET;\n+\t  ix86_isa_flags_explicit |= OPTION_MASK_ISA_SAHF_SET;\n+\t}\n+      else\n+\t{\n+\t  ix86_isa_flags &= ~OPTION_MASK_ISA_SAHF_UNSET;\n+\t  ix86_isa_flags_explicit |= OPTION_MASK_ISA_SAHF_UNSET;\n+\t}\n+      return true;\n+\n+    case OPT_mcx16:\n+      if (value)\n+\t{\n+\t  ix86_isa_flags |= OPTION_MASK_ISA_CX16_SET;\n+\t  ix86_isa_flags_explicit |= OPTION_MASK_ISA_CX16_SET;\n+\t}\n+      else\n+\t{\n+\t  ix86_isa_flags &= ~OPTION_MASK_ISA_CX16_UNSET;\n+\t  ix86_isa_flags_explicit |= OPTION_MASK_ISA_CX16_UNSET;\n+\t}\n+      return true;\n+\n+    case OPT_maes:\n+      if (value)\n+\t{\n+\t  ix86_isa_flags |= OPTION_MASK_ISA_AES_SET;\n+\t  ix86_isa_flags_explicit |= OPTION_MASK_ISA_AES_SET;\n+\t}\n+      else\n+\t{\n+\t  ix86_isa_flags &= ~OPTION_MASK_ISA_AES_UNSET;\n+\t  ix86_isa_flags_explicit |= OPTION_MASK_ISA_AES_UNSET;\n+\t}\n+      return true;\n+\n+    case OPT_mpclmul:\n+      if (value)\n+\t{\n+\t  ix86_isa_flags |= OPTION_MASK_ISA_PCLMUL_SET;\n+\t  ix86_isa_flags_explicit |= OPTION_MASK_ISA_PCLMUL_SET;\n+\t}\n+      else\n+\t{\n+\t  ix86_isa_flags &= ~OPTION_MASK_ISA_PCLMUL_UNSET;\n+\t  ix86_isa_flags_explicit |= OPTION_MASK_ISA_PCLMUL_UNSET;\n+\t}\n+      return true;\n+\n     default:\n       return true;\n     }\n }\n+\f\n+/* Return a string the documents the current -m options.  The caller is\n+   responsible for freeing the string.  */\n+\n+static char *\n+ix86_target_string (int isa, int flags, const char *arch, const char *tune,\n+\t\t    const char *fpmath, bool add_nl_p)\n+{\n+  struct ix86_target_opts\n+  {\n+    const char *option;\t\t/* option string */\n+    int mask;\t\t\t/* isa mask options */\n+  };\n+\n+  /* This table is ordered so that options like -msse5 or -msse4.2 that imply\n+     preceding options while match those first.  */\n+  static struct ix86_target_opts isa_opts[] =\n+  {\n+    { \"-m64\",\t\tOPTION_MASK_ISA_64BIT },\n+    { \"-msse5\",\t\tOPTION_MASK_ISA_SSE5 },\n+    { \"-msse4a\",\tOPTION_MASK_ISA_SSE4A },\n+    { \"-msse4.2\",\tOPTION_MASK_ISA_SSE4_2 },\n+    { \"-msse4.1\",\tOPTION_MASK_ISA_SSE4_1 },\n+    { \"-mssse3\",\tOPTION_MASK_ISA_SSSE3 },\n+    { \"-msse3\",\t\tOPTION_MASK_ISA_SSE3 },\n+    { \"-msse2\",\t\tOPTION_MASK_ISA_SSE2 },\n+    { \"-msse\",\t\tOPTION_MASK_ISA_SSE },\n+    { \"-m3dnow\",\tOPTION_MASK_ISA_3DNOW },\n+    { \"-mmmx\",\t\tOPTION_MASK_ISA_MMX },\n+    { \"-mabm\",\t\tOPTION_MASK_ISA_ABM },\n+    { \"-mpopcnt\",\tOPTION_MASK_ISA_POPCNT },\n+    { \"-maes\",\t\tOPTION_MASK_ISA_AES },\n+    { \"-mpclmul\",\tOPTION_MASK_ISA_PCLMUL },\n+  };\n+\n+  /* Flag options.  */\n+  static struct ix86_target_opts flag_opts[] =\n+  {\n+    { \"-m128bit-long-double\",\t\tMASK_128BIT_LONG_DOUBLE },\n+    { \"-m80387\",\t\t\tMASK_80387 },\n+    { \"-maccumulate-outgoing-args\",\tMASK_ACCUMULATE_OUTGOING_ARGS },\n+    { \"-malign-double\",\t\t\tMASK_ALIGN_DOUBLE },\n+    { \"-mcld\",\t\t\t\tMASK_CLD },\n+    { \"-mfp-ret-in-387\",\t\tMASK_FLOAT_RETURNS },\n+    { \"-mieee-fp\",\t\t\tMASK_IEEE_FP },\n+    { \"-minline-all-stringops\",\t\tMASK_INLINE_ALL_STRINGOPS },\n+    { \"-minline-stringops-dynamically\",\tMASK_INLINE_STRINGOPS_DYNAMICALLY },\n+    { \"-mms-bitfields\",\t\t\tMASK_MS_BITFIELD_LAYOUT },\n+    { \"-mno-align-stringops\",\t\tMASK_NO_ALIGN_STRINGOPS },\n+    { \"-mno-fancy-math-387\",\t\tMASK_NO_FANCY_MATH_387 },\n+    { \"-mno-fused-madd\",\t\tMASK_NO_FUSED_MADD },\n+    { \"-mno-push-args\",\t\t\tMASK_NO_PUSH_ARGS },\n+    { \"-mno-red-zone\",\t\t\tMASK_NO_RED_ZONE },\n+    { \"-momit-leaf-frame-pointer\",\tMASK_OMIT_LEAF_FRAME_POINTER },\n+    { \"-mrecip\",\t\t\tMASK_RECIP },\n+    { \"-mrtd\",\t\t\t\tMASK_RTD },\n+    { \"-msseregparm\",\t\t\tMASK_SSEREGPARM },\n+    { \"-mstack-arg-probe\",\t\tMASK_STACK_PROBE },\n+    { \"-mtls-direct-seg-refs\",\t\tMASK_TLS_DIRECT_SEG_REFS },\n+  };\n+\n+  const char *opts[ (sizeof (isa_opts) / sizeof (isa_opts[0])\n+\t\t     + sizeof (flag_opts) / sizeof (flag_opts[0])\n+\t\t     + 6)][2];\n+\n+  char isa_other[40];\n+  char target_other[40];\n+  unsigned num = 0;\n+  unsigned i, j;\n+  char *ret;\n+  char *ptr;\n+  size_t len;\n+  size_t line_len;\n+  size_t sep_len;\n+\n+  memset (opts, '\\0', sizeof (opts));\n+\n+  /* Add -march= option.  */\n+  if (arch)\n+    {\n+      opts[num][0] = \"-march=\";\n+      opts[num++][1] = arch;\n+    }\n+\n+  /* Add -mtune= option.  */\n+  if (tune)\n+    {\n+      opts[num][0] = \"-mtune=\";\n+      opts[num++][1] = tune;\n+    }\n+\n+  /* Pick out the options in isa options.  */\n+  for (i = 0; i < sizeof (isa_opts) / sizeof (isa_opts[0]); i++)\n+    {\n+      if ((isa & isa_opts[i].mask) != 0)\n+\t{\n+\t  opts[num++][0] = isa_opts[i].option;\n+\t  isa &= ~ isa_opts[i].mask;\n+\t}\n+    }\n+\n+  if (isa && add_nl_p)\n+    {\n+      opts[num++][0] = isa_other;\n+      sprintf (isa_other, \"(other isa: 0x%x)\", isa);\n+    }\n+\n+  /* Add flag options.  */\n+  for (i = 0; i < sizeof (flag_opts) / sizeof (flag_opts[0]); i++)\n+    {\n+      if ((flags & flag_opts[i].mask) != 0)\n+\t{\n+\t  opts[num++][0] = flag_opts[i].option;\n+\t  flags &= ~ flag_opts[i].mask;\n+\t}\n+    }\n+\n+  if (flags && add_nl_p)\n+    {\n+      opts[num++][0] = target_other;\n+      sprintf (target_other, \"(other flags: 0x%x)\", isa);\n+    }\n+\n+  /* Add -fpmath= option.  */\n+  if (fpmath)\n+    {\n+      opts[num][0] = \"-mfpmath=\";\n+      opts[num++][1] = fpmath;\n+    }\n+\n+  /* Any options?  */\n+  if (num == 0)\n+    return NULL;\n+\n+  gcc_assert (num < sizeof (opts) / sizeof (opts[0]));\n+\n+  /* Size the string.  */\n+  len = 0;\n+  sep_len = (add_nl_p) ? 3 : 1;\n+  for (i = 0; i < num; i++)\n+    {\n+      len += sep_len;\n+      for (j = 0; j < 2; j++)\n+\tif (opts[i][j])\n+\t  len += strlen (opts[i][j]);\n+    }\n+\n+  /* Build the string.  */\n+  ret = ptr = (char *) xmalloc (len);\n+  line_len = 0;\n+\n+  for (i = 0; i < num; i++)\n+    {\n+      size_t len2[2];\n+\n+      for (j = 0; j < 2; j++)\n+\tlen2[j] = (opts[i][j]) ? strlen (opts[i][j]) : 0;\n+\n+      if (i != 0)\n+\t{\n+\t  *ptr++ = ' ';\n+\t  line_len++;\n+\n+\t  if (add_nl_p && line_len + len2[0] + len2[1] > 70)\n+\t    {\n+\t      *ptr++ = '\\\\';\n+\t      *ptr++ = '\\n';\n+\t      line_len = 0;\n+\t    }\n+\t}\n+\n+      for (j = 0; j < 2; j++)\n+\tif (opts[i][j])\n+\t  {\n+\t    memcpy (ptr, opts[i][j], len2[j]);\n+\t    ptr += len2[j];\n+\t    line_len += len2[j];\n+\t  }\n+    }\n+\n+  *ptr = '\\0';\n+  gcc_assert (ret + len >= ptr);\n+\n+  return ret;\n+}\n+\n+/* Function that is callable from the debugger to print the current\n+   options.  */\n+void\n+ix86_debug_options (void)\n+{\n+  char *opts = ix86_target_string (ix86_isa_flags, target_flags,\n+\t\t\t\t   ix86_arch_string, ix86_tune_string,\n+\t\t\t\t   ix86_fpmath_string, true);\n \n+  if (opts)\n+    {\n+      fprintf (stderr, \"%s\\n\\n\", opts);\n+      free (opts);\n+    }\n+  else\n+    fprintf (stderr, \"<no options>\\n\\n\");\n+\n+  return;\n+}\n+\f\n /* Sometimes certain combinations of command options do not make\n    sense on a particular target machine.  You can define a macro\n    `OVERRIDE_OPTIONS' to take account of this.  This macro, if\n@@ -2017,68 +2403,17 @@ ix86_handle_option (size_t code, const char *arg ATTRIBUTE_UNUSED, int value)\n    `-O'.  That is what `OPTIMIZATION_OPTIONS' is for.  */\n \n void\n-override_options (void)\n+override_options (bool main_args_p)\n {\n   int i;\n-  int ix86_tune_defaulted = 0;\n-  int ix86_arch_specified = 0;\n   unsigned int ix86_arch_mask, ix86_tune_mask;\n+  const char *prefix;\n+  const char *suffix;\n+  const char *sw;\n \n   /* Comes from final.c -- no real reason to change it.  */\n #define MAX_CODE_ALIGN 16\n \n-  static struct ptt\n-    {\n-      const struct processor_costs *cost;\t/* Processor costs */\n-      const int align_loop;\t\t\t/* Default alignments.  */\n-      const int align_loop_max_skip;\n-      const int align_jump;\n-      const int align_jump_max_skip;\n-      const int align_func;\n-    }\n-  const processor_target_table[PROCESSOR_max] =\n-    {\n-      {&i386_cost, 4, 3, 4, 3, 4},\n-      {&i486_cost, 16, 15, 16, 15, 16},\n-      {&pentium_cost, 16, 7, 16, 7, 16},\n-      {&pentiumpro_cost, 16, 15, 16, 10, 16},\n-      {&geode_cost, 0, 0, 0, 0, 0},\n-      {&k6_cost, 32, 7, 32, 7, 32},\n-      {&athlon_cost, 16, 7, 16, 7, 16},\n-      {&pentium4_cost, 0, 0, 0, 0, 0},\n-      {&k8_cost, 16, 7, 16, 7, 16},\n-      {&nocona_cost, 0, 0, 0, 0, 0},\n-      {&core2_cost, 16, 10, 16, 10, 16},\n-      {&generic32_cost, 16, 7, 16, 7, 16},\n-      {&generic64_cost, 16, 10, 16, 10, 16},\n-      {&amdfam10_cost, 32, 24, 32, 7, 32}\n-    };\n-\n-  static const char *const cpu_names[TARGET_CPU_DEFAULT_max] =\n-    {\n-      \"generic\",\n-      \"i386\",\n-      \"i486\",\n-      \"pentium\",\n-      \"pentium-mmx\",\n-      \"pentiumpro\",\n-      \"pentium2\",\n-      \"pentium3\",\n-      \"pentium4\",\n-      \"pentium-m\",\n-      \"prescott\",\n-      \"nocona\",\n-      \"core2\",\n-      \"geode\",\n-      \"k6\",\n-      \"k6-2\",\n-      \"k6-3\",\n-      \"athlon\",\n-      \"athlon-4\",\n-      \"k8\",\n-      \"amdfam10\"\n-    };\n-\n   enum pta_flags\n     {\n       PTA_SSE = 1 << 0,\n@@ -2197,6 +2532,21 @@ override_options (void)\n \n   int const pta_size = ARRAY_SIZE (processor_alias_table);\n \n+  /* Set up prefix/suffix so the error messages refer to either the command\n+     line argument, or the attribute(option).  */\n+  if (main_args_p)\n+    {\n+      prefix = \"-m\";\n+      suffix = \"\";\n+      sw = \"switch\";\n+    }\n+  else\n+    {\n+      prefix = \"option(\\\"\";\n+      suffix = \"\\\")\";\n+      sw = \"attribute\";\n+    }\n+\n #ifdef SUBTARGET_OVERRIDE_OPTIONS\n   SUBTARGET_OVERRIDE_OPTIONS;\n #endif\n@@ -2246,8 +2596,15 @@ override_options (void)\n \t  else\n \t    ix86_tune_string = \"generic32\";\n \t}\n+      /* If this call is for setting the option attribute, allow the\n+\t generic32/generic64 that was previously set.  */\n+      else if (!main_args_p\n+\t       && (!strcmp (ix86_tune_string, \"generic32\")\n+\t\t   || !strcmp (ix86_tune_string, \"generic64\")))\n+\t;\n       else if (!strncmp (ix86_tune_string, \"generic\", 7))\n-\terror (\"bad value (%s) for -mtune= switch\", ix86_tune_string);\n+\terror (\"bad value (%s) for %stune=%s %s\",\n+\t       ix86_tune_string, prefix, suffix, sw);\n     }\n   else\n     {\n@@ -2288,21 +2645,25 @@ override_options (void)\n       else if (!strcmp (ix86_stringop_string, \"unrolled_loop\"))\n \tstringop_alg = unrolled_loop;\n       else\n-\terror (\"bad value (%s) for -mstringop-strategy= switch\", ix86_stringop_string);\n+\terror (\"bad value (%s) for %sstringop-strategy=%s %s\",\n+\t       ix86_stringop_string, prefix, suffix, sw);\n     }\n   if (!strcmp (ix86_tune_string, \"x86-64\"))\n-    warning (OPT_Wdeprecated, \"-mtune=x86-64 is deprecated.  Use -mtune=k8 or \"\n-\t     \"-mtune=generic instead as appropriate.\");\n+    warning (OPT_Wdeprecated, \"%stune=x86-64%s is deprecated.  Use \"\n+\t     \"%stune=k8%s or %stune=generic%s instead as appropriate.\",\n+\t     prefix, suffix, prefix, suffix, prefix, suffix);\n \n   if (!ix86_arch_string)\n     ix86_arch_string = TARGET_64BIT ? \"x86-64\" : \"i386\";\n   else\n     ix86_arch_specified = 1;\n \n   if (!strcmp (ix86_arch_string, \"generic\"))\n-    error (\"generic CPU can be used only for -mtune= switch\");\n+    error (\"generic CPU can be used only for %stune=%s %s\",\n+\t   prefix, suffix, sw);\n   if (!strncmp (ix86_arch_string, \"generic\", 7))\n-    error (\"bad value (%s) for -march= switch\", ix86_arch_string);\n+    error (\"bad value (%s) for %sarch=%s %s\",\n+\t   ix86_arch_string, prefix, suffix, sw);\n \n   if (ix86_cmodel_string != 0)\n     {\n@@ -2319,7 +2680,8 @@ override_options (void)\n       else if (!strcmp (ix86_cmodel_string, \"kernel\") && !flag_pic)\n \tix86_cmodel = CM_KERNEL;\n       else\n-\terror (\"bad value (%s) for -mcmodel= switch\", ix86_cmodel_string);\n+\terror (\"bad value (%s) for %scmodel=%s %s\",\n+\t       ix86_cmodel_string, prefix, suffix, sw);\n     }\n   else\n     {\n@@ -2342,7 +2704,8 @@ override_options (void)\n       else if (!strcmp (ix86_asm_string, \"att\"))\n \tix86_asm_dialect = ASM_ATT;\n       else\n-\terror (\"bad value (%s) for -masm= switch\", ix86_asm_string);\n+\terror (\"bad value (%s) for %sasm=%s %s\",\n+\t       ix86_asm_string, prefix, suffix, sw);\n     }\n   if ((TARGET_64BIT == 0) != (ix86_cmodel == CM_32))\n     error (\"code model %qs not supported in the %s bit mode\",\n@@ -2395,31 +2758,37 @@ override_options (void)\n \tif (processor_alias_table[i].flags & PTA_SSE5\n \t    && !(ix86_isa_flags_explicit & OPTION_MASK_ISA_SSE5))\n \t  ix86_isa_flags |= OPTION_MASK_ISA_SSE5;\n-\n-\tif (processor_alias_table[i].flags & PTA_ABM)\n-\t  x86_abm = true;\n-\tif (processor_alias_table[i].flags & PTA_CX16)\n-\t  x86_cmpxchg16b = true;\n-\tif (processor_alias_table[i].flags & (PTA_POPCNT | PTA_ABM))\n-\t  x86_popcnt = true;\n+\tif (processor_alias_table[i].flags & PTA_ABM\n+\t    && !(ix86_isa_flags_explicit & OPTION_MASK_ISA_ABM))\n+\t  ix86_isa_flags |= OPTION_MASK_ISA_ABM;\n+\tif (processor_alias_table[i].flags & PTA_CX16\n+\t    && !(ix86_isa_flags_explicit & OPTION_MASK_ISA_CX16))\n+\t  ix86_isa_flags |= OPTION_MASK_ISA_CX16;\n+\tif (processor_alias_table[i].flags & (PTA_POPCNT | PTA_ABM)\n+\t    && !(ix86_isa_flags_explicit & OPTION_MASK_ISA_POPCNT))\n+\t  ix86_isa_flags |= OPTION_MASK_ISA_POPCNT;\n+\tif (!(TARGET_64BIT && (processor_alias_table[i].flags & PTA_NO_SAHF))\n+\t    && !(ix86_isa_flags_explicit & OPTION_MASK_ISA_SAHF))\n+\t  ix86_isa_flags |= OPTION_MASK_ISA_SAHF;\n+\tif (processor_alias_table[i].flags & PTA_AES\n+\t    && !(ix86_isa_flags_explicit & OPTION_MASK_ISA_AES))\n+\t  ix86_isa_flags |= OPTION_MASK_ISA_AES;\n+\tif (processor_alias_table[i].flags & PTA_PCLMUL\n+\t    && !(ix86_isa_flags_explicit & OPTION_MASK_ISA_PCLMUL))\n+\t  ix86_isa_flags |= OPTION_MASK_ISA_PCLMUL;\n \tif (processor_alias_table[i].flags & (PTA_PREFETCH_SSE | PTA_SSE))\n \t  x86_prefetch_sse = true;\n-\tif (!(TARGET_64BIT && (processor_alias_table[i].flags & PTA_NO_SAHF)))\n-\t  x86_sahf = true;\n-\tif (processor_alias_table[i].flags & PTA_AES)\n-\t  x86_aes = true;\n-\tif (processor_alias_table[i].flags & PTA_PCLMUL)\n-\t  x86_pclmul = true;\n \n \tbreak;\n       }\n \n   if (i == pta_size)\n-    error (\"bad value (%s) for -march= switch\", ix86_arch_string);\n+    error (\"bad value (%s) for %sarch=%s %s\",\n+\t   ix86_arch_string, prefix, suffix, sw);\n \n   ix86_arch_mask = 1u << ix86_arch;\n   for (i = 0; i < X86_ARCH_LAST; ++i)\n-    ix86_arch_features[i] &= ix86_arch_mask;\n+    ix86_arch_features[i] = !!(initial_ix86_arch_features[i] & ix86_arch_mask);\n \n   for (i = 0; i < pta_size; i++)\n     if (! strcmp (ix86_tune_string, processor_alias_table[i].name))\n@@ -2451,19 +2820,12 @@ override_options (void)\n \tbreak;\n       }\n   if (i == pta_size)\n-    error (\"bad value (%s) for -mtune= switch\", ix86_tune_string);\n-\n-  /* Enable SSE2 if AES or PCLMUL is enabled.  */\n-  if ((x86_aes || x86_pclmul)\n-      && !(ix86_isa_flags_explicit & OPTION_MASK_ISA_SSE2))\n-    {\n-      ix86_isa_flags |= OPTION_MASK_ISA_SSE2_SET;\n-      ix86_isa_flags_explicit |= OPTION_MASK_ISA_SSE2_SET;\n-    }\n+    error (\"bad value (%s) for %stune=%s %s\",\n+\t   ix86_tune_string, prefix, suffix, sw);\n \n   ix86_tune_mask = 1u << ix86_tune;\n   for (i = 0; i < X86_TUNE_LAST; ++i)\n-    ix86_tune_features[i] &= ix86_tune_mask;\n+    ix86_tune_features[i] = !!(initial_ix86_tune_features[i] & ix86_tune_mask);\n \n   if (optimize_size)\n     ix86_cost = &size_cost;\n@@ -2477,10 +2839,11 @@ override_options (void)\n   if (ix86_regparm_string)\n     {\n       if (TARGET_64BIT)\n-\twarning (0, \"-mregparm is ignored in 64-bit mode\");\n+\twarning (0, \"%sregparm%s is ignored in 64-bit mode\", prefix, suffix);\n       i = atoi (ix86_regparm_string);\n       if (i < 0 || i > REGPARM_MAX)\n-\terror (\"-mregparm=%d is not between 0 and %d\", i, REGPARM_MAX);\n+\terror (\"%sregparm=%d%s is not between 0 and %d\",\n+\t       prefix, i, suffix, REGPARM_MAX);\n       else\n \tix86_regparm = i;\n     }\n@@ -2492,38 +2855,44 @@ override_options (void)\n      Remove this code in GCC 3.2 or later.  */\n   if (ix86_align_loops_string)\n     {\n-      warning (0, \"-malign-loops is obsolete, use -falign-loops\");\n+      warning (0, \"%salign-loops%s is obsolete, use %salign-loops%s\",\n+\t       prefix, suffix, prefix, suffix);\n       if (align_loops == 0)\n \t{\n \t  i = atoi (ix86_align_loops_string);\n \t  if (i < 0 || i > MAX_CODE_ALIGN)\n-\t    error (\"-malign-loops=%d is not between 0 and %d\", i, MAX_CODE_ALIGN);\n+\t    error (\"%salign-loops=%d%s is not between 0 and %d\",\n+\t\t   prefix, i, suffix, MAX_CODE_ALIGN);\n \t  else\n \t    align_loops = 1 << i;\n \t}\n     }\n \n   if (ix86_align_jumps_string)\n     {\n-      warning (0, \"-malign-jumps is obsolete, use -falign-jumps\");\n+      warning (0, \"%salign-jumps%s is obsolete, use %salign-jumps%s\",\n+\t       prefix, suffix, prefix, suffix);\n       if (align_jumps == 0)\n \t{\n \t  i = atoi (ix86_align_jumps_string);\n \t  if (i < 0 || i > MAX_CODE_ALIGN)\n-\t    error (\"-malign-loops=%d is not between 0 and %d\", i, MAX_CODE_ALIGN);\n+\t    error (\"%salign-loops=%d%s is not between 0 and %d\",\n+\t\t   prefix, i, suffix, MAX_CODE_ALIGN);\n \t  else\n \t    align_jumps = 1 << i;\n \t}\n     }\n \n   if (ix86_align_funcs_string)\n     {\n-      warning (0, \"-malign-functions is obsolete, use -falign-functions\");\n+      warning (0, \"%salign-functions%s is obsolete, use %salign-functions%s\",\n+\t       prefix, suffix, prefix, suffix);\n       if (align_functions == 0)\n \t{\n \t  i = atoi (ix86_align_funcs_string);\n \t  if (i < 0 || i > MAX_CODE_ALIGN)\n-\t    error (\"-malign-loops=%d is not between 0 and %d\", i, MAX_CODE_ALIGN);\n+\t    error (\"%salign-loops=%d%s is not between 0 and %d\",\n+\t\t   prefix, i, suffix, MAX_CODE_ALIGN);\n \t  else\n \t    align_functions = 1 << i;\n \t}\n@@ -2551,15 +2920,15 @@ override_options (void)\n     {\n       i = atoi (ix86_branch_cost_string);\n       if (i < 0 || i > 5)\n-\terror (\"-mbranch-cost=%d is not between 0 and 5\", i);\n+\terror (\"%sbranch-cost=%d%s is not between 0 and 5\", prefix, i, suffix);\n       else\n \tix86_branch_cost = i;\n     }\n   if (ix86_section_threshold_string)\n     {\n       i = atoi (ix86_section_threshold_string);\n       if (i < 0)\n-\terror (\"-mlarge-data-threshold=%d is negative\", i);\n+\terror (\"%slarge-data-threshold=%d%s is negative\", prefix, i, suffix);\n       else\n \tix86_section_threshold = i;\n     }\n@@ -2573,8 +2942,8 @@ override_options (void)\n       else if (strcmp (ix86_tls_dialect_string, \"sun\") == 0)\n \tix86_tls_dialect = TLS_DIALECT_SUN;\n       else\n-\terror (\"bad value (%s) for -mtls-dialect= switch\",\n-\t       ix86_tls_dialect_string);\n+\terror (\"bad value (%s) for %stls-dialect=%s %s\",\n+\t       ix86_tls_dialect_string, prefix, suffix, sw);\n     }\n \n   if (ix87_precision_string)\n@@ -2597,7 +2966,7 @@ override_options (void)\n \t     | TARGET_SUBTARGET64_ISA_DEFAULT) & ~ix86_isa_flags_explicit);\n \n       if (TARGET_RTD)\n-\twarning (0, \"-mrtd is ignored in 64bit mode\");\n+\twarning (0, \"%srtd%s is ignored in 64bit mode\", prefix, suffix);\n     }\n   else\n     {\n@@ -2643,7 +3012,7 @@ override_options (void)\n \n   /* Turn on popcnt instruction for -msse4.2 or -mabm.  */\n   if (TARGET_SSE4_2 || TARGET_ABM)\n-    x86_popcnt = true;\n+    ix86_isa_flags |= OPTION_MASK_ISA_POPCNT & ~ix86_isa_flags_explicit;\n \n   /* Validate -mpreferred-stack-boundary= value, or provide default.\n      The default of 128 bits is for Pentium III's SSE __m128.  We can't\n@@ -2654,16 +3023,16 @@ override_options (void)\n     {\n       i = atoi (ix86_preferred_stack_boundary_string);\n       if (i < (TARGET_64BIT ? 4 : 2) || i > 12)\n-\terror (\"-mpreferred-stack-boundary=%d is not between %d and 12\", i,\n-\t       TARGET_64BIT ? 4 : 2);\n+\terror (\"%spreferred-stack-boundary=%d%s is not between %d and 12\",\n+\t       prefix, i, suffix, TARGET_64BIT ? 4 : 2);\n       else\n \tix86_preferred_stack_boundary = (1 << i) * BITS_PER_UNIT;\n     }\n \n   /* Accept -msseregparm only if at least SSE support is enabled.  */\n   if (TARGET_SSEREGPARM\n       && ! TARGET_SSE)\n-    error (\"-msseregparm used without SSE enabled\");\n+    error (\"%ssseregparm%s used without SSE enabled\", prefix, suffix);\n \n   ix86_fpmath = TARGET_FPMATH_DEFAULT;\n   if (ix86_fpmath_string != 0)\n@@ -2681,7 +3050,10 @@ override_options (void)\n \t    ix86_fpmath = FPMATH_SSE;\n \t}\n       else if (! strcmp (ix86_fpmath_string, \"387,sse\")\n-\t       || ! strcmp (ix86_fpmath_string, \"sse,387\"))\n+\t       || ! strcmp (ix86_fpmath_string, \"387+sse\")\n+\t       || ! strcmp (ix86_fpmath_string, \"sse,387\")\n+\t       || ! strcmp (ix86_fpmath_string, \"sse+387\")\n+\t       || ! strcmp (ix86_fpmath_string, \"both\"))\n \t{\n \t  if (!TARGET_SSE)\n \t    {\n@@ -2697,7 +3069,8 @@ override_options (void)\n \t    ix86_fpmath = (enum fpmath_unit) (FPMATH_SSE | FPMATH_387);\n \t}\n       else\n-\terror (\"bad value (%s) for -mfpmath= switch\", ix86_fpmath_string);\n+\terror (\"bad value (%s) for %sfpmath=%s %s\",\n+\t       ix86_fpmath_string, prefix, suffix, sw);\n     }\n \n   /* If the i387 is disabled, then do not return values in it. */\n@@ -2713,7 +3086,8 @@ override_options (void)\n \tix86_veclib_handler = ix86_veclibabi_acml;\n       else\n \terror (\"unknown vectorization library ABI type (%s) for \"\n-\t       \"-mveclibabi= switch\", ix86_veclibabi_string);\n+\t       \"%sveclibabi=%s %s\", ix86_veclibabi_string,\n+\t       prefix, suffix, sw);\n     }\n \n   if ((x86_accumulate_outgoing_args & ix86_tune_mask)\n@@ -2732,7 +3106,8 @@ override_options (void)\n     {\n       if (target_flags_explicit & MASK_ACCUMULATE_OUTGOING_ARGS)\n \twarning (0, \"unwind tables currently require either a frame pointer \"\n-\t\t \"or -maccumulate-outgoing-args for correctness\");\n+\t\t \"or %saccumulate-outgoing-args%s for correctness\",\n+\t\t prefix, suffix);\n       target_flags |= MASK_ACCUMULATE_OUTGOING_ARGS;\n     }\n \n@@ -2743,11 +3118,13 @@ override_options (void)\n       && !(target_flags & MASK_ACCUMULATE_OUTGOING_ARGS))\n     {\n       if (target_flags_explicit & MASK_ACCUMULATE_OUTGOING_ARGS)\n-\twarning (0, \"stack probing requires -maccumulate-outgoing-args \"\n-\t\t \"for correctness\");\n+\twarning (0, \"stack probing requires %saccumulate-outgoing-args%s \"\n+\t\t \"for correctness\", prefix, suffix);\n       target_flags |= MASK_ACCUMULATE_OUTGOING_ARGS;\n     }\n \n+  TARGET_CMOVE = 0;\n+\n   /* For sane SSE instruction set generation we need fcomi instruction.\n      It is safe to enable all CMOVE instructions.  */\n   if (TARGET_SSE)\n@@ -2808,7 +3185,499 @@ override_options (void)\n   if (!TARGET_64BIT)\n     target_flags |= MASK_CLD & ~target_flags_explicit;\n #endif\n+\n+  /* Save the initial options in case the user does function specific options */\n+  if (main_args_p)\n+    target_option_default_node = target_option_current_node\n+      = build_target_option_node ();\n }\n+\f\n+/* Save the current options */\n+\n+static void\n+ix86_function_specific_save (struct cl_target_option *ptr)\n+{\n+  gcc_assert (IN_RANGE (ix86_arch, 0, 255));\n+  gcc_assert (IN_RANGE (ix86_tune, 0, 255));\n+  gcc_assert (IN_RANGE (ix86_fpmath, 0, 255));\n+  gcc_assert (IN_RANGE (ix86_branch_cost, 0, 255));\n+\n+  ptr->arch = ix86_arch;\n+  ptr->tune = ix86_tune;\n+  ptr->fpmath = ix86_fpmath;\n+  ptr->branch_cost = ix86_branch_cost;\n+  ptr->tune_defaulted = ix86_tune_defaulted;\n+  ptr->arch_specified = ix86_arch_specified;\n+  ptr->ix86_isa_flags_explicit = ix86_isa_flags_explicit;\n+  ptr->target_flags_explicit = target_flags_explicit;\n+}\n+\n+/* Restore the current options */\n+\n+static void\n+ix86_function_specific_restore (struct cl_target_option *ptr)\n+{\n+  enum processor_type old_tune = ix86_tune;\n+  enum processor_type old_arch = ix86_arch;\n+  unsigned int ix86_arch_mask, ix86_tune_mask;\n+  int i;\n+\n+  ix86_arch = ptr->arch;\n+  ix86_tune = ptr->tune;\n+  ix86_fpmath = ptr->fpmath;\n+  ix86_branch_cost = ptr->branch_cost;\n+  ix86_tune_defaulted = ptr->tune_defaulted;\n+  ix86_arch_specified = ptr->arch_specified;\n+  ix86_isa_flags_explicit = ptr->ix86_isa_flags_explicit;\n+  target_flags_explicit = ptr->target_flags_explicit;\n+\n+  /* Recreate the arch feature tests if the arch changed */\n+  if (old_arch != ix86_arch)\n+    {\n+      ix86_arch_mask = 1u << ix86_arch;\n+      for (i = 0; i < X86_ARCH_LAST; ++i)\n+\tix86_arch_features[i]\n+\t  = !!(initial_ix86_arch_features[i] & ix86_arch_mask);\n+    }\n+\n+  /* Recreate the tune optimization tests */\n+  if (old_tune != ix86_tune)\n+    {\n+      ix86_tune_mask = 1u << ix86_tune;\n+      for (i = 0; i < X86_TUNE_LAST; ++i)\n+\tix86_tune_features[i]\n+\t  = !!(initial_ix86_tune_features[i] & ix86_tune_mask);\n+    }\n+}\n+\n+/* Print the current options */\n+\n+static void\n+ix86_function_specific_print (FILE *file, int indent,\n+\t\t\t      struct cl_target_option *ptr)\n+{\n+  char *target_string\n+    = ix86_target_string (ptr->ix86_isa_flags, ptr->target_flags,\n+\t\t\t  NULL, NULL, NULL, false);\n+\n+  fprintf (file, \"%*sarch = %d (%s)\\n\",\n+\t   indent, \"\",\n+\t   ptr->arch,\n+\t   ((ptr->arch < TARGET_CPU_DEFAULT_max)\n+\t    ? cpu_names[ptr->arch]\n+\t    : \"<unknown>\"));\n+\n+  fprintf (file, \"%*stune = %d (%s)\\n\",\n+\t   indent, \"\",\n+\t   ptr->tune,\n+\t   ((ptr->tune < TARGET_CPU_DEFAULT_max)\n+\t    ? cpu_names[ptr->tune]\n+\t    : \"<unknown>\"));\n+\n+  fprintf (file, \"%*sfpmath = %d%s%s\\n\", indent, \"\", ptr->fpmath,\n+\t   (ptr->fpmath & FPMATH_387) ? \", 387\" : \"\",\n+\t   (ptr->fpmath & FPMATH_SSE) ? \", sse\" : \"\");\n+  fprintf (file, \"%*sbranch_cost = %d\\n\", indent, \"\", ptr->branch_cost);\n+\n+  if (target_string)\n+    {\n+      fprintf (file, \"%*s%s\\n\", indent, \"\", target_string);\n+      free (target_string);\n+    }\n+}\n+\n+\f\n+/* Inner function to process the attribute((option(...))), take an argument and\n+   set the current options from the argument. If we have a list, recursively go\n+   over the list.  */\n+\n+static bool\n+ix86_valid_option_attribute_inner_p (tree args, char *p_strings[])\n+{\n+  char *next_optstr;\n+  bool ret = true;\n+\n+#define IX86_ATTR_ISA(S,O)   { S, sizeof (S)-1, ix86_opt_isa, O, 0 }\n+#define IX86_ATTR_STR(S,O)   { S, sizeof (S)-1, ix86_opt_str, O, 0 }\n+#define IX86_ATTR_YES(S,O,M) { S, sizeof (S)-1, ix86_opt_yes, O, M }\n+#define IX86_ATTR_NO(S,O,M)  { S, sizeof (S)-1, ix86_opt_no,  O, M }\n+\n+  enum ix86_opt_type\n+  {\n+    ix86_opt_unknown,\n+    ix86_opt_yes,\n+    ix86_opt_no,\n+    ix86_opt_str,\n+    ix86_opt_isa\n+  };\n+\n+  static const struct\n+  {\n+    const char *string;\n+    size_t len;\n+    enum ix86_opt_type type;\n+    int opt;\n+    int mask;\n+  } attrs[] = {\n+    /* isa options */\n+    IX86_ATTR_ISA (\"3dnow\",\tOPT_m3dnow),\n+    IX86_ATTR_ISA (\"abm\",\tOPT_mabm),\n+    IX86_ATTR_ISA (\"aes\",\tOPT_maes),\n+    IX86_ATTR_ISA (\"mmx\",\tOPT_mmmx),\n+    IX86_ATTR_ISA (\"pclmul\",\tOPT_mpclmul),\n+    IX86_ATTR_ISA (\"popcnt\",\tOPT_mpopcnt),\n+    IX86_ATTR_ISA (\"sse\",\tOPT_msse),\n+    IX86_ATTR_ISA (\"sse2\",\tOPT_msse2),\n+    IX86_ATTR_ISA (\"sse3\",\tOPT_msse3),\n+    IX86_ATTR_ISA (\"sse4\",\tOPT_msse4),\n+    IX86_ATTR_ISA (\"sse4.1\",\tOPT_msse4_1),\n+    IX86_ATTR_ISA (\"sse4.2\",\tOPT_msse4_2),\n+    IX86_ATTR_ISA (\"sse4a\",\tOPT_msse4a),\n+    IX86_ATTR_ISA (\"sse5\",\tOPT_msse5),\n+    IX86_ATTR_ISA (\"ssse3\",\tOPT_mssse3),\n+\n+    /* string options */\n+    IX86_ATTR_STR (\"arch=\",\tIX86_FUNCTION_SPECIFIC_ARCH),\n+    IX86_ATTR_STR (\"fpmath=\",\tIX86_FUNCTION_SPECIFIC_FPMATH),\n+    IX86_ATTR_STR (\"tune=\",\tIX86_FUNCTION_SPECIFIC_TUNE),\n+\n+    /* flag options */\n+    IX86_ATTR_YES (\"cld\",\n+\t\t   OPT_mcld,\n+\t\t   MASK_CLD),\n+\n+    IX86_ATTR_NO (\"fancy-math-387\",\n+\t\t  OPT_mfancy_math_387,\n+\t\t  MASK_NO_FANCY_MATH_387),\n+\n+    IX86_ATTR_NO (\"fused-madd\",\n+\t\t  OPT_mfused_madd,\n+\t\t  MASK_NO_FUSED_MADD),\n+\n+    IX86_ATTR_YES (\"ieee-fp\",\n+\t\t   OPT_mieee_fp,\n+\t\t   MASK_IEEE_FP),\n+\n+    IX86_ATTR_YES (\"inline-all-stringops\",\n+\t\t   OPT_minline_all_stringops,\n+\t\t   MASK_INLINE_ALL_STRINGOPS),\n+\n+    IX86_ATTR_YES (\"inline-stringops-dynamically\",\n+\t\t   OPT_minline_stringops_dynamically,\n+\t\t   MASK_INLINE_STRINGOPS_DYNAMICALLY),\n+\n+    IX86_ATTR_NO (\"align-stringops\",\n+\t\t  OPT_mno_align_stringops,\n+\t\t  MASK_NO_ALIGN_STRINGOPS),\n+\n+    IX86_ATTR_YES (\"recip\",\n+\t\t   OPT_mrecip,\n+\t\t   MASK_RECIP),\n+\n+  };\n+\n+  /* If this is a list, recurse to get the options.  */\n+  if (TREE_CODE (args) == TREE_LIST)\n+    {\n+      bool ret = true;\n+\n+      for (; args; args = TREE_CHAIN (args))\n+\tif (TREE_VALUE (args)\n+\t    && !ix86_valid_option_attribute_inner_p (TREE_VALUE (args), p_strings))\n+\t  ret = false;\n+\n+      return ret;\n+    }\n+\n+  else if (TREE_CODE (args) != STRING_CST)\n+    gcc_unreachable ();\n+\n+  /* Handle multiple arguments separated by commas.  */\n+  next_optstr = ASTRDUP (TREE_STRING_POINTER (args));\n+\n+  while (next_optstr && *next_optstr != '\\0')\n+    {\n+      char *p = next_optstr;\n+      char *orig_p = p;\n+      char *comma = strchr (next_optstr, ',');\n+      const char *opt_string;\n+      size_t len, opt_len;\n+      int opt;\n+      bool opt_set_p;\n+      char ch;\n+      unsigned i;\n+      enum ix86_opt_type type = ix86_opt_unknown;\n+      int mask = 0;\n+\n+      if (comma)\n+\t{\n+\t  *comma = '\\0';\n+\t  len = comma - next_optstr;\n+\t  next_optstr = comma + 1;\n+\t}\n+      else\n+\t{\n+\t  len = strlen (p);\n+\t  next_optstr = NULL;\n+\t}\n+\n+      /* Recognize no-xxx.  */\n+      if (len > 3 && p[0] == 'n' && p[1] == 'o' && p[2] == '-')\n+\t{\n+\t  opt_set_p = false;\n+\t  p += 3;\n+\t  len -= 3;\n+\t}\n+      else\n+\topt_set_p = true;\n+\n+      /* Find the option.  */\n+      ch = *p;\n+      opt = N_OPTS;\n+      for (i = 0; i < sizeof (attrs) / sizeof (attrs[0]); i++)\n+\t{\n+\t  type = attrs[i].type;\n+\t  opt_len = attrs[i].len;\n+\t  if (ch == attrs[i].string[0]\n+\t      && ((type != ix86_opt_str) ? len == opt_len : len > opt_len)\n+\t      && memcmp (p, attrs[i].string, opt_len) == 0)\n+\t    {\n+\t      opt = attrs[i].opt;\n+\t      mask = attrs[i].mask;\n+\t      opt_string = attrs[i].string;\n+\t      break;\n+\t    }\n+\t}\n+\n+      /* Process the option.  */\n+      if (opt == N_OPTS)\n+\t{\n+\t  error (\"attribute(option(\\\"%s\\\")) is unknown\", orig_p);\n+\t  ret = false;\n+\t}\n+\n+      else if (type == ix86_opt_isa)\n+\tix86_handle_option (opt, p, opt_set_p);\n+\n+      else if (type == ix86_opt_yes || type == ix86_opt_no)\n+\t{\n+\t  if (type == ix86_opt_no)\n+\t    opt_set_p = !opt_set_p;\n+\n+\t  if (opt_set_p)\n+\t    target_flags |= mask;\n+\t  else\n+\t    target_flags &= ~mask;\n+\t}\n+\n+      else if (type == ix86_opt_str)\n+\t{\n+\t  if (p_strings[opt])\n+\t    {\n+\t      error (\"option(\\\"%s\\\") was already specified\", opt_string);\n+\t      ret = false;\n+\t    }\n+\t  else\n+\t    p_strings[opt] = xstrdup (p + opt_len);\n+\t}\n+\n+      else\n+\tgcc_unreachable ();\n+    }\n+\n+  return ret;\n+}\n+\n+/* Return a TARGET_OPTION_NODE tree of the target options listed or NULL.  */\n+\n+tree\n+ix86_valid_option_attribute_tree (tree args)\n+{\n+  const char *orig_arch_string = ix86_arch_string;\n+  const char *orig_tune_string = ix86_tune_string;\n+  const char *orig_fpmath_string = ix86_fpmath_string;\n+  int orig_tune_defaulted = ix86_tune_defaulted;\n+  int orig_arch_specified = ix86_arch_specified;\n+  char *option_strings[IX86_FUNCTION_SPECIFIC_MAX] = { NULL, NULL, NULL };\n+  tree t = NULL_TREE;\n+  int i;\n+  struct cl_target_option *def\n+    = TREE_TARGET_OPTION (target_option_default_node);\n+\n+  /* Process each of the options on the chain.  */\n+  if (! ix86_valid_option_attribute_inner_p (args, option_strings))\n+    return NULL_TREE;\n+\n+  /* If the changed options are different from the default, rerun override_options,\n+     and then save the options away.  The string options are are attribute options,\n+     and will be undone when we copy the save structure.  */\n+  if (ix86_isa_flags != def->ix86_isa_flags\n+      || target_flags != def->target_flags\n+      || option_strings[IX86_FUNCTION_SPECIFIC_ARCH]\n+      || option_strings[IX86_FUNCTION_SPECIFIC_TUNE]\n+      || option_strings[IX86_FUNCTION_SPECIFIC_FPMATH])\n+    {\n+      /* If we are using the default tune= or arch=, undo the string assigned,\n+\t and use the default.  */\n+      if (option_strings[IX86_FUNCTION_SPECIFIC_ARCH])\n+\tix86_arch_string = option_strings[IX86_FUNCTION_SPECIFIC_ARCH];\n+      else if (!orig_arch_specified)\n+\tix86_arch_string = NULL;\n+\n+      if (option_strings[IX86_FUNCTION_SPECIFIC_TUNE])\n+\tix86_tune_string = option_strings[IX86_FUNCTION_SPECIFIC_TUNE];\n+      else if (orig_tune_defaulted)\n+\tix86_tune_string = NULL;\n+\n+      /* If fpmath= is not set, and we now have sse2 on 32-bit, use it.  */\n+      if (option_strings[IX86_FUNCTION_SPECIFIC_FPMATH])\n+\tix86_fpmath_string = option_strings[IX86_FUNCTION_SPECIFIC_FPMATH];\n+      else if (!TARGET_64BIT && TARGET_SSE)\n+\tix86_fpmath_string = \"sse,387\";\n+\n+      /* Do any overrides, such as arch=xxx, or tune=xxx support.  */\n+      override_options (false);\n+\n+      /* Save the current options unless we are validating options for\n+\t #pragma.  */\n+      t = build_target_option_node ();\n+\n+      ix86_arch_string = orig_arch_string;\n+      ix86_tune_string = orig_tune_string;\n+      ix86_fpmath_string = orig_fpmath_string;\n+\n+      /* Free up memory allocated to hold the strings */\n+      for (i = 0; i < IX86_FUNCTION_SPECIFIC_MAX; i++)\n+\tif (option_strings[i])\n+\t  free (option_strings[i]);\n+    }\n+\n+  return t;\n+}\n+\n+/* Hook to validate attribute((option(\"string\"))).  */\n+\n+static bool\n+ix86_valid_option_attribute_p (tree fndecl,\n+\t\t\t       tree ARG_UNUSED (name),\n+\t\t\t       tree args,\n+\t\t\t       int ARG_UNUSED (flags))\n+{\n+  struct cl_target_option cur_opts;\n+  bool ret = true;\n+  tree new_opts;\n+\n+  cl_target_option_save (&cur_opts);\n+  new_opts = ix86_valid_option_attribute_tree (args);\n+  if (!new_opts)\n+    ret = false;\n+\n+  else if (fndecl)\n+    DECL_FUNCTION_SPECIFIC_TARGET (fndecl) = new_opts;\n+\n+  cl_target_option_restore (&cur_opts);\n+  return ret;\n+}\n+\n+\f\n+/* Hook to determine if one function can safely inline another.  */\n+\n+static bool\n+ix86_can_inline_p (tree caller, tree callee)\n+{\n+  bool ret = false;\n+  tree caller_tree = DECL_FUNCTION_SPECIFIC_TARGET (caller);\n+  tree callee_tree = DECL_FUNCTION_SPECIFIC_TARGET (callee);\n+\n+  /* If callee has no option attributes, then it is ok to inline.  */\n+  if (!callee_tree)\n+    ret = true;\n+\n+  /* If caller has no option attributes, but callee does then it is not ok to\n+     inline.  */\n+  else if (!caller_tree)\n+    ret = false;\n+\n+  else\n+    {\n+      struct cl_target_option *caller_opts = TREE_TARGET_OPTION (caller_tree);\n+      struct cl_target_option *callee_opts = TREE_TARGET_OPTION (callee_tree);\n+\n+      /* Callee's isa options should a subset of the caller's, i.e. a SSE5 function\n+\t can inline a SSE2 function but a SSE2 function can't inline a SSE5\n+\t function.  */\n+      if ((caller_opts->ix86_isa_flags & callee_opts->ix86_isa_flags)\n+\t  != callee_opts->ix86_isa_flags)\n+\tret = false;\n+\n+      /* See if we have the same non-isa options.  */\n+      else if (caller_opts->target_flags != callee_opts->target_flags)\n+\tret = false;\n+\n+      /* See if arch, tune, etc. are the same.  */\n+      else if (caller_opts->arch != callee_opts->arch)\n+\tret = false;\n+\n+      else if (caller_opts->tune != callee_opts->tune)\n+\tret = false;\n+\n+      else if (caller_opts->fpmath != callee_opts->fpmath)\n+\tret = false;\n+\n+      else if (caller_opts->branch_cost != callee_opts->branch_cost)\n+\tret = false;\n+\n+      else\n+\tret = true;\n+    }\n+\n+  return ret;\n+}\n+\n+\f\n+/* Remember the last target of ix86_set_current_function.  */\n+static GTY(()) tree ix86_previous_fndecl;\n+\n+/* Establish appropriate back-end context for processing the function\n+   FNDECL.  The argument might be NULL to indicate processing at top\n+   level, outside of any function scope.  */\n+static void\n+ix86_set_current_function (tree fndecl)\n+{\n+  /* Only change the context if the function changes.  This hook is called\n+     several times in the course of compiling a function, and we don't want to\n+     slow things down too much or call target_reinit when it isn't safe.  */\n+  if (fndecl && fndecl != ix86_previous_fndecl)\n+    {\n+      tree old_tree = (ix86_previous_fndecl\n+\t\t       ? DECL_FUNCTION_SPECIFIC_TARGET (ix86_previous_fndecl)\n+\t\t       : NULL_TREE);\n+\n+      tree new_tree = (fndecl\n+\t\t       ? DECL_FUNCTION_SPECIFIC_TARGET (fndecl)\n+\t\t       : NULL_TREE);\n+\n+      ix86_previous_fndecl = fndecl;\n+      if (old_tree == new_tree)\n+\t;\n+\n+      else if (new_tree)\n+\t{\n+\t  cl_target_option_restore (TREE_TARGET_OPTION (new_tree));\n+\t  target_reinit ();\n+\t}\n+\n+      else if (old_tree)\n+\t{\n+\t  struct cl_target_option *def\n+\t    = TREE_TARGET_OPTION (target_option_current_node);\n+\n+\t  cl_target_option_restore (def);\n+\t  target_reinit ();\n+\t}\n+    }\n+}\n+\n \f\n /* Return true if this goes in large data/bss.  */\n \n@@ -18129,22 +18998,29 @@ enum ix86_builtins\n /* Table for the ix86 builtin decls.  */\n static GTY(()) tree ix86_builtins[(int) IX86_BUILTIN_MAX];\n \n-/* Add an ix86 target builtin function with CODE, NAME and TYPE.  Do so,\n- * if the target_flags include one of MASK.  Stores the function decl\n- * in the ix86_builtins array.\n- * Returns the function decl or NULL_TREE, if the builtin was not added.  */\n+/* Table to record which ISA options the builtin needs.  */\n+static int ix86_builtins_isa[(int) IX86_BUILTIN_MAX];\n+\n+/* Add an ix86 target builtin function with CODE, NAME and TYPE.  Save the MASK\n+ * of which isa_flags to use in the ix86_builtins_isa array.  Stores the\n+ * function decl in the ix86_builtins array.  Returns the function decl or\n+ * NULL_TREE, if the builtin was not added.\n+ *\n+ * Record all builtins, even if it isn't an instruction set in the current ISA\n+ * in case the user uses function specific options for a different ISA.  When\n+ * the builtin is expanded, check at that time whether it is valid.  */\n \n static inline tree\n def_builtin (int mask, const char *name, tree type, enum ix86_builtins code)\n {\n   tree decl = NULL_TREE;\n \n-  if (mask & ix86_isa_flags\n-      && (!(mask & OPTION_MASK_ISA_64BIT) || TARGET_64BIT))\n+  if (!(mask & OPTION_MASK_ISA_64BIT) || TARGET_64BIT)\n     {\n       decl = add_builtin_function (name, type, code, BUILT_IN_MD,\n \t\t\t\t   NULL, NULL_TREE);\n       ix86_builtins[(int) code] = decl;\n+      ix86_builtins_isa[(int) code] = mask;\n     }\n \n   return decl;\n@@ -19187,9 +20063,10 @@ static const struct builtin_description bdesc_multi_arg[] =\n   { OPTION_MASK_ISA_SSE5, CODE_FOR_sse5_pcom_tfv2di3,      \"__builtin_ia32_pcomtrueuq\", IX86_BUILTIN_PCOMTRUEUQ, PCOM_TRUE,    (int)MULTI_ARG_2_DI_TF },\n };\n \n-/* Set up all the MMX/SSE builtins.  This is not called if TARGET_MMX\n-   is zero.  Otherwise, if TARGET_SSE is not set, only expand the MMX\n-   builtins.  */\n+/* Set up all the MMX/SSE builtins, even builtins for instructions that are not\n+   in the current target ISA to allow the user to compile particular modules\n+   with different target specific options that differ from the command line\n+   options.  */\n static void\n ix86_init_mmx_sse_builtins (void)\n {\n@@ -20128,23 +21005,15 @@ ix86_init_mmx_sse_builtins (void)\n   def_builtin (OPTION_MASK_ISA_SSE3, \"__builtin_ia32_mwait\", void_ftype_unsigned_unsigned, IX86_BUILTIN_MWAIT);\n \n   /* AES */\n-  if (TARGET_AES)\n-    {\n-      /* Define AES built-in functions only if AES is enabled.  */\n-      def_builtin_const (OPTION_MASK_ISA_SSE2, \"__builtin_ia32_aesenc128\", v2di_ftype_v2di_v2di, IX86_BUILTIN_AESENC128);\n-      def_builtin_const (OPTION_MASK_ISA_SSE2, \"__builtin_ia32_aesenclast128\", v2di_ftype_v2di_v2di, IX86_BUILTIN_AESENCLAST128);\n-      def_builtin_const (OPTION_MASK_ISA_SSE2, \"__builtin_ia32_aesdec128\", v2di_ftype_v2di_v2di, IX86_BUILTIN_AESDEC128);\n-      def_builtin_const (OPTION_MASK_ISA_SSE2, \"__builtin_ia32_aesdeclast128\", v2di_ftype_v2di_v2di, IX86_BUILTIN_AESDECLAST128);\n-      def_builtin_const (OPTION_MASK_ISA_SSE2, \"__builtin_ia32_aesimc128\", v2di_ftype_v2di, IX86_BUILTIN_AESIMC128);\n-      def_builtin_const (OPTION_MASK_ISA_SSE2, \"__builtin_ia32_aeskeygenassist128\", v2di_ftype_v2di_int, IX86_BUILTIN_AESKEYGENASSIST128);\n-    }\n+  def_builtin_const (OPTION_MASK_ISA_AES, \"__builtin_ia32_aesenc128\", v2di_ftype_v2di_v2di, IX86_BUILTIN_AESENC128);\n+  def_builtin_const (OPTION_MASK_ISA_AES, \"__builtin_ia32_aesenclast128\", v2di_ftype_v2di_v2di, IX86_BUILTIN_AESENCLAST128);\n+  def_builtin_const (OPTION_MASK_ISA_AES, \"__builtin_ia32_aesdec128\", v2di_ftype_v2di_v2di, IX86_BUILTIN_AESDEC128);\n+  def_builtin_const (OPTION_MASK_ISA_AES, \"__builtin_ia32_aesdeclast128\", v2di_ftype_v2di_v2di, IX86_BUILTIN_AESDECLAST128);\n+  def_builtin_const (OPTION_MASK_ISA_AES, \"__builtin_ia32_aesimc128\", v2di_ftype_v2di, IX86_BUILTIN_AESIMC128);\n+  def_builtin_const (OPTION_MASK_ISA_AES, \"__builtin_ia32_aeskeygenassist128\", v2di_ftype_v2di_int, IX86_BUILTIN_AESKEYGENASSIST128);\n \n   /* PCLMUL */\n-  if (TARGET_PCLMUL)\n-    {\n-      /* Define PCLMUL built-in function only if PCLMUL is enabled.  */\n-      def_builtin_const (OPTION_MASK_ISA_SSE2, \"__builtin_ia32_pclmulqdq128\", v2di_ftype_v2di_v2di_int, IX86_BUILTIN_PCLMULQDQ128);\n-    }\n+  def_builtin_const (OPTION_MASK_ISA_PCLMUL, \"__builtin_ia32_pclmulqdq128\", v2di_ftype_v2di_v2di_int, IX86_BUILTIN_PCLMULQDQ128);\n \n   /* Access to the vec_init patterns.  */\n   ftype = build_function_type_list (V2SI_type_node, integer_type_node,\n@@ -20399,8 +21268,7 @@ ix86_init_builtins (void)\n   ix86_builtins[(int) IX86_BUILTIN_COPYSIGNQ] = decl;\n   TREE_READONLY (decl) = 1;\n \n-  if (TARGET_MMX)\n-    ix86_init_mmx_sse_builtins ();\n+  ix86_init_mmx_sse_builtins ();\n   if (TARGET_64BIT)\n     ix86_init_builtins_va_builtins_abi ();\n }\n@@ -21616,6 +22484,28 @@ ix86_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n   enum machine_mode mode0, mode1, mode2;\n   unsigned int fcode = DECL_FUNCTION_CODE (fndecl);\n \n+  /* Determine whether the builtin function is available under the current ISA.\n+     Originally the builtin was not created if it wasn't applicable to the\n+     current ISA based on the command line switches.  With function specific\n+     options, we need to check in the context of the function making the call\n+     whether it is supported.  */\n+  if (ix86_builtins_isa[fcode]\n+      && !(ix86_builtins_isa[fcode] & ix86_isa_flags))\n+    {\n+      char *opts = ix86_target_string (ix86_builtins_isa[fcode], 0, NULL,\n+\t\t\t\t       NULL, NULL, false);\n+\n+      if (!opts)\n+\terror (\"%qE needs unknown isa option\", fndecl);\n+      else\n+\t{\n+\t  gcc_assert (opts != NULL);\n+\t  error (\"%qE needs isa option %s\", fndecl, opts);\n+\t  free (opts);\n+\t}\n+      return const0_rtx;\n+    }\n+\n   switch (fcode)\n     {\n     case IX86_BUILTIN_MASKMOVQ:\n@@ -26436,6 +27326,24 @@ ix86_enum_va_list (int idx, const char **pname, tree *ptree)\n #undef TARGET_VECTORIZE_BUILTIN_VECTORIZATION_COST\n #define TARGET_VECTORIZE_BUILTIN_VECTORIZATION_COST x86_builtin_vectorization_cost\n \n+#undef TARGET_SET_CURRENT_FUNCTION\n+#define TARGET_SET_CURRENT_FUNCTION ix86_set_current_function\n+\n+#undef TARGET_OPTION_VALID_ATTRIBUTE_P\n+#define TARGET_OPTION_VALID_ATTRIBUTE_P ix86_valid_option_attribute_p\n+\n+#undef TARGET_OPTION_SAVE\n+#define TARGET_OPTION_SAVE ix86_function_specific_save\n+\n+#undef TARGET_OPTION_RESTORE\n+#define TARGET_OPTION_RESTORE ix86_function_specific_restore\n+\n+#undef TARGET_OPTION_PRINT\n+#define TARGET_OPTION_PRINT ix86_function_specific_print\n+\n+#undef TARGET_OPTION_CAN_INLINE_P\n+#define TARGET_OPTION_CAN_INLINE_P ix86_can_inline_p\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n #include \"gt-i386.h\""}, {"sha": "c7d33c7eb050b942fdf83ef7f80bcd92e47a859f", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 14, "deletions": 201, "changes": 215, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=ab442df7fb453434d80a779844fe1a10c0c802ab", "patch": "@@ -49,6 +49,13 @@ along with GCC; see the file COPYING3.  If not see\n #define TARGET_SSE4A\tOPTION_ISA_SSE4A\n #define TARGET_SSE5\tOPTION_ISA_SSE5\n #define TARGET_ROUND\tOPTION_ISA_ROUND\n+#define TARGET_ABM\tOPTION_ISA_ABM\n+#define TARGET_POPCNT\tOPTION_ISA_POPCNT\n+#define TARGET_SAHF\tOPTION_ISA_SAHF\n+#define TARGET_AES\tOPTION_ISA_AES\n+#define TARGET_PCLMUL\tOPTION_ISA_PCLMUL\n+#define TARGET_CMPXCHG16B OPTION_ISA_CX16\n+\n \n /* SSE5 and SSE4.1 define the same round instructions */\n #define\tOPTION_MASK_ISA_ROUND\t(OPTION_MASK_ISA_SSE4_1 | OPTION_MASK_ISA_SSE5)\n@@ -286,7 +293,7 @@ enum ix86_tune_indices {\n   X86_TUNE_LAST\n };\n \n-extern unsigned int ix86_tune_features[X86_TUNE_LAST];\n+extern unsigned char ix86_tune_features[X86_TUNE_LAST];\n \n #define TARGET_USE_LEAVE\tix86_tune_features[X86_TUNE_USE_LEAVE]\n #define TARGET_PUSH_MEMORY\tix86_tune_features[X86_TUNE_PUSH_MEMORY]\n@@ -380,7 +387,7 @@ enum ix86_arch_indices {\n   X86_ARCH_LAST\n };\n \n-extern unsigned int ix86_arch_features[X86_ARCH_LAST];\n+extern unsigned char ix86_arch_features[X86_ARCH_LAST];\n \n #define TARGET_CMOVE\t\tix86_arch_features[X86_ARCH_CMOVE]\n #define TARGET_CMPXCHG\t\tix86_arch_features[X86_ARCH_CMPXCHG]\n@@ -392,15 +399,7 @@ extern unsigned int ix86_arch_features[X86_ARCH_LAST];\n \n extern int x86_prefetch_sse;\n \n-#define TARGET_ABM\t\tx86_abm\n-#define TARGET_CMPXCHG16B\tx86_cmpxchg16b\n-#define TARGET_POPCNT\t\tx86_popcnt\n #define TARGET_PREFETCH_SSE\tx86_prefetch_sse\n-#define TARGET_SAHF\t\tx86_sahf\n-#define TARGET_RECIP\t\tx86_recip\n-#define TARGET_FUSED_MADD\tx86_fused_muladd\n-#define TARGET_AES\t\t(TARGET_SSE2 && x86_aes)\n-#define TARGET_PCLMUL\t\t(TARGET_SSE2 && x86_pclmul)\n \n #define ASSEMBLER_DIALECT\t(ix86_asm_dialect)\n \n@@ -475,7 +474,7 @@ enum calling_abi\n    Don't use this macro to turn on various extra optimizations for\n    `-O'.  That is what `OPTIMIZATION_OPTIONS' is for.  */\n \n-#define OVERRIDE_OPTIONS override_options ()\n+#define OVERRIDE_OPTIONS override_options (true)\n \n /* Define this to change the optimizations performed by default.  */\n #define OPTIMIZATION_OPTIONS(LEVEL, SIZE) \\\n@@ -537,196 +536,10 @@ extern const char *host_detect_local_cpu (int argc, const char **argv);\n #endif\n \f\n /* Target CPU builtins.  */\n-#define TARGET_CPU_CPP_BUILTINS()\t\t\t\t\\\n-  do\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      size_t arch_len = strlen (ix86_arch_string);\t\t\\\n-      size_t tune_len = strlen (ix86_tune_string);\t\t\\\n-      int last_arch_char = ix86_arch_string[arch_len - 1];\t\\\n-      int last_tune_char = ix86_tune_string[tune_len - 1];\t\\\n-\t\t\t\t\t\t\t\t\\\n-      if (TARGET_64BIT)\t\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\\\n-\t  builtin_assert (\"cpu=x86_64\");\t\t\t\\\n-\t  builtin_assert (\"machine=x86_64\");\t\t\t\\\n-\t  builtin_define (\"__amd64\");\t\t\t\t\\\n-\t  builtin_define (\"__amd64__\");\t\t\t\t\\\n-\t  builtin_define (\"__x86_64\");\t\t\t\t\\\n-\t  builtin_define (\"__x86_64__\");\t\t\t\\\n-\t}\t\t\t\t\t\t\t\\\n-      else\t\t\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\\\n-\t  builtin_assert (\"cpu=i386\");\t\t\t\t\\\n-\t  builtin_assert (\"machine=i386\");\t\t\t\\\n-\t  builtin_define_std (\"i386\");\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\\\n-      /* Built-ins based on -march=.  */\t\t\t\\\n-      switch (ix86_arch)\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\\\n-\tcase PROCESSOR_I386:\t\t\t\t\t\\\n-\t  break;\t\t\t\t\t\t\\\n-\tcase PROCESSOR_I486:\t\t\t\t\t\\\n-\t  builtin_define (\"__i486\");\t\t\t\t\\\n-\t  builtin_define (\"__i486__\");\t\t\t\t\\\n-\t  break;\t\t\t\t\t\t\\\n-\tcase PROCESSOR_PENTIUM:\t\t\t\t\t\\\n-\t  builtin_define (\"__i586\");\t\t\t\t\\\n-\t  builtin_define (\"__i586__\");\t\t\t\t\\\n-\t  builtin_define (\"__pentium\");\t\t\t\t\\\n-\t  builtin_define (\"__pentium__\");\t\t\t\\\n-\t  if (last_arch_char == 'x')\t\t\t\t\\\n-\t    builtin_define (\"__pentium_mmx__\");\t\t\t\\\n-\t  break;\t\t\t\t\t\t\\\n-\tcase PROCESSOR_PENTIUMPRO:\t\t\t\t\\\n-\t  builtin_define (\"__i686\");\t\t\t\t\\\n-\t  builtin_define (\"__i686__\");\t\t\t\t\\\n-\t  builtin_define (\"__pentiumpro\");\t\t\t\\\n-\t  builtin_define (\"__pentiumpro__\");\t\t\t\\\n-\t  break;\t\t\t\t\t\t\\\n-\tcase PROCESSOR_GEODE:\t\t\t\t\t\\\n-\t  builtin_define (\"__geode\");\t\t\t\t\\\n-\t  builtin_define (\"__geode__\");\t\t\t\t\\\n-\t  break;\t\t\t\t\t\t\\\n-\tcase PROCESSOR_K6:\t\t\t\t\t\\\n-\t  builtin_define (\"__k6\");\t\t\t\t\\\n-\t  builtin_define (\"__k6__\");\t\t\t\t\\\n-\t  if (last_arch_char == '2')\t\t\t\t\\\n-\t    builtin_define (\"__k6_2__\");\t\t\t\\\n-\t  else if (last_arch_char == '3')\t\t\t\\\n-\t    builtin_define (\"__k6_3__\");\t\t\t\\\n-\t  break;\t\t\t\t\t\t\\\n-\tcase PROCESSOR_ATHLON:\t\t\t\t\t\\\n-\t  builtin_define (\"__athlon\");\t\t\t\t\\\n-\t  builtin_define (\"__athlon__\");\t\t\t\\\n-\t  /* Only plain \"athlon\" lacks SSE.  */\t\t\t\\\n-\t  if (last_arch_char != 'n')\t\t\t\t\\\n-\t    builtin_define (\"__athlon_sse__\");\t\t\t\\\n-\t  break;\t\t\t\t\t\t\\\n-\tcase PROCESSOR_K8:\t\t\t\t\t\\\n-\t  builtin_define (\"__k8\");\t\t\t\t\\\n-\t  builtin_define (\"__k8__\");\t\t\t\t\\\n-\t  break;\t\t\t\t\t\t\\\n-\tcase PROCESSOR_AMDFAM10:\t\t\t\t\\\n-\t  builtin_define (\"__amdfam10\");\t\t\t\\\n-\t  builtin_define (\"__amdfam10__\");\t\t\t\\\n-\t  break;\t\t\t\t\t\t\\\n-\tcase PROCESSOR_PENTIUM4:\t\t\t\t\\\n-\t  builtin_define (\"__pentium4\");\t\t\t\\\n-\t  builtin_define (\"__pentium4__\");\t\t\t\\\n-\t  break;\t\t\t\t\t\t\\\n-\tcase PROCESSOR_NOCONA:\t\t\t\t\t\\\n-\t  builtin_define (\"__nocona\");\t\t\t\t\\\n-\t  builtin_define (\"__nocona__\");\t\t\t\\\n-\t  break;\t\t\t\t\t\t\\\n-\tcase PROCESSOR_CORE2:\t\t\t\t\t\\\n-\t  builtin_define (\"__core2\");\t\t\t\t\\\n-\t  builtin_define (\"__core2__\");\t\t\t\t\\\n-\t  break;\t\t\t\t\t\t\\\n-\tcase PROCESSOR_GENERIC32:\t\t\t\t\\\n-\tcase PROCESSOR_GENERIC64:\t\t\t\t\\\n-\tcase PROCESSOR_max:\t\t\t\t\t\\\n-\t  gcc_unreachable ();\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\\\n-      /* Built-ins based on -mtune=.  */\t\t\t\\\n-      switch (ix86_tune)\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\\\n-\tcase PROCESSOR_I386:\t\t\t\t\t\\\n-\t  builtin_define (\"__tune_i386__\");\t\t\t\\\n-\t  break;\t\t\t\t\t\t\\\n-\tcase PROCESSOR_I486:\t\t\t\t\t\\\n-\t  builtin_define (\"__tune_i486__\");\t\t\t\\\n-\t  break;\t\t\t\t\t\t\\\n-\tcase PROCESSOR_PENTIUM:\t\t\t\t\t\\\n-\t  builtin_define (\"__tune_i586__\");\t\t\t\\\n-\t  builtin_define (\"__tune_pentium__\");\t\t\t\\\n-\t  if (last_tune_char == 'x')\t\t\t\t\\\n-\t    builtin_define (\"__tune_pentium_mmx__\");\t\t\\\n-\t  break;\t\t\t\t\t\t\\\n-\tcase PROCESSOR_PENTIUMPRO:\t\t\t\t\\\n-\t  builtin_define (\"__tune_i686__\");\t\t\t\\\n-\t  builtin_define (\"__tune_pentiumpro__\");\t\t\\\n-\t  switch (last_tune_char)\t\t\t\t\\\n-\t    {\t\t\t\t\t\t\t\\\n-\t    case '3':\t\t\t\t\t\t\\\n-\t      builtin_define (\"__tune_pentium3__\");\t\t\\\n-\t      /* FALLTHRU */\t\t\t\t\t\\\n-\t    case '2':\t\t\t\t\t\t\\\n-\t      builtin_define (\"__tune_pentium2__\");\t\t\\\n-\t      break;\t\t\t\t\t\t\\\n-\t    }\t\t\t\t\t\t\t\\\n-\t  break;\t\t\t\t\t\t\\\n-\tcase PROCESSOR_GEODE:\t\t\t\t\t\\\n-\t  builtin_define (\"__tune_geode__\");\t\t\t\\\n-\t  break;\t\t\t\t\t\t\\\n-\tcase PROCESSOR_K6:\t\t\t\t\t\\\n-\t  builtin_define (\"__tune_k6__\");\t\t\t\\\n-\t  if (last_tune_char == '2')\t\t\t\t\\\n-\t    builtin_define (\"__tune_k6_2__\");\t\t\t\\\n-\t  else if (last_tune_char == '3')\t\t\t\\\n-\t    builtin_define (\"__tune_k6_3__\");\t\t\t\\\n-\t  break;\t\t\t\t\t\t\\\n-\tcase PROCESSOR_ATHLON:\t\t\t\t\t\\\n-\t  builtin_define (\"__tune_athlon__\");\t\t\t\\\n-\t  /* Only plain \"athlon\" lacks SSE.  */\t\t\t\\\n-\t  if (last_tune_char != 'n')\t\t\t\t\\\n-\t    builtin_define (\"__tune_athlon_sse__\");\t\t\\\n-\t  break;\t\t\t\t\t\t\\\n-\tcase PROCESSOR_K8:\t\t\t\t\t\\\n-\t  builtin_define (\"__tune_k8__\");\t\t\t\\\n-\t  break;\t\t\t\t\t\t\\\n-\tcase PROCESSOR_AMDFAM10:\t\t\t\t\\\n-\t  builtin_define (\"__tune_amdfam10__\");\t\t\t\\\n-\t  break;\t\t\t\t\t\t\\\n-\tcase PROCESSOR_PENTIUM4:\t\t\t\t\\\n-\t  builtin_define (\"__tune_pentium4__\");\t\t\t\\\n-\t  break;\t\t\t\t\t\t\\\n-        case PROCESSOR_NOCONA:\t\t\t\t\t\\\n-\t  builtin_define (\"__tune_nocona__\");\t\t\t\\\n-\t  break;\t\t\t\t\t\t\\\n-\tcase PROCESSOR_CORE2:\t\t\t\t\t\\\n-\t  builtin_define (\"__tune_core2__\");\t\t\t\\\n-\t  break;\t\t\t\t\t\t\\\n-\tcase PROCESSOR_GENERIC32:\t\t\t\t\\\n-\tcase PROCESSOR_GENERIC64:\t\t\t\t\\\n-\t  break;\t\t\t\t\t\t\\\n-\tcase PROCESSOR_max:\t\t\t\t\t\\\n-\t  gcc_unreachable ();\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\\\n-      if (TARGET_MMX)\t\t\t\t\t\t\\\n-\tbuiltin_define (\"__MMX__\");\t\t\t\t\\\n-      if (TARGET_3DNOW)\t\t\t\t\t\t\\\n-\tbuiltin_define (\"__3dNOW__\");\t\t\t\t\\\n-      if (TARGET_3DNOW_A)\t\t\t\t\t\\\n-\tbuiltin_define (\"__3dNOW_A__\");\t\t\t\t\\\n-      if (TARGET_SSE)\t\t\t\t\t\t\\\n-\tbuiltin_define (\"__SSE__\");\t\t\t\t\\\n-      if (TARGET_SSE2)\t\t\t\t\t\t\\\n-\tbuiltin_define (\"__SSE2__\");\t\t\t\t\\\n-      if (TARGET_SSE3)\t\t\t\t\t\t\\\n-\tbuiltin_define (\"__SSE3__\");\t\t\t\t\\\n-      if (TARGET_SSSE3)\t\t\t\t\t\t\\\n-\tbuiltin_define (\"__SSSE3__\");\t\t\t\t\\\n-      if (TARGET_SSE4_1)\t\t\t\t\t\\\n-\tbuiltin_define (\"__SSE4_1__\");\t\t\t\t\\\n-      if (TARGET_SSE4_2)\t\t\t\t\t\\\n-\tbuiltin_define (\"__SSE4_2__\");\t\t\t\t\\\n-      if (TARGET_AES)\t\t\t\t\t\t\\\n-\tbuiltin_define (\"__AES__\");\t\t\t\t\\\n-      if (TARGET_PCLMUL)\t\t\t\t\t\\\n-\tbuiltin_define (\"__PCLMUL__\");\t\t\t\t\\\n-      if (TARGET_SSE4A)\t\t\t\t\t\t\\\n- \tbuiltin_define (\"__SSE4A__\");\t\t                \\\n-      if (TARGET_SSE5)\t\t\t\t\t\t\\\n-\tbuiltin_define (\"__SSE5__\");\t\t\t\t\\\n-      if (TARGET_SSE_MATH && TARGET_SSE)\t\t\t\\\n-\tbuiltin_define (\"__SSE_MATH__\");\t\t\t\\\n-      if (TARGET_SSE_MATH && TARGET_SSE2)\t\t\t\\\n-\tbuiltin_define (\"__SSE2_MATH__\");\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  while (0)\n+#define TARGET_CPU_CPP_BUILTINS() ix86_target_macros ()\n+\n+/* Target Pragmas.  */\n+#define REGISTER_TARGET_PRAGMAS() ix86_register_pragmas ()\n \n enum target_cpu_default\n {"}, {"sha": "d5c0978dde580ae52813ab6f51f86621460407d8", "filename": "gcc/config/i386/i386.opt", "status": "modified", "additions": 99, "deletions": 64, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Fconfig%2Fi386%2Fi386.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Fconfig%2Fi386%2Fi386.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.opt?ref=ab442df7fb453434d80a779844fe1a10c0c802ab", "patch": "@@ -18,24 +18,58 @@\n ; along with GCC; see the file COPYING3.  If not see\n ; <http://www.gnu.org/licenses/>.\n \n+;; Definitions to add to the cl_target_option structure\n+;; -march= processor\n+TargetSave\n+unsigned char arch\n+\n+;; -mtune= processor\n+TargetSave\n+unsigned char tune\n+\n+;; -mfpath=\n+TargetSave\n+unsigned char fpmath\n+\n+;; branch cost\n+TargetSave\n+unsigned char branch_cost\n+\n+;; which flags were passed by the user\n+TargetSave\n+int ix86_isa_flags_explicit\n+\n+;; which flags were passed by the user\n+TargetSave\n+int target_flags_explicit\n+\n+;; whether -mtune was not specified\n+TargetSave\n+unsigned char tune_defaulted\n+\n+;; whether -march was specified\n+TargetSave\n+unsigned char arch_specified\n+\n+;; x86 options\n m128bit-long-double\n-Target RejectNegative Report Mask(128BIT_LONG_DOUBLE)\n+Target RejectNegative Report Mask(128BIT_LONG_DOUBLE) Save\n sizeof(long double) is 16\n \n m80387\n-Target Report Mask(80387)\n+Target Report Mask(80387) Save\n Use hardware fp\n \n m96bit-long-double\n-Target RejectNegative Report InverseMask(128BIT_LONG_DOUBLE)\n+Target RejectNegative Report InverseMask(128BIT_LONG_DOUBLE) Save\n sizeof(long double) is 12\n \n maccumulate-outgoing-args\n-Target Report Mask(ACCUMULATE_OUTGOING_ARGS)\n+Target Report Mask(ACCUMULATE_OUTGOING_ARGS) Save\n Reserve space for outgoing arguments in the function prologue\n \n malign-double\n-Target Report Mask(ALIGN_DOUBLE)\n+Target Report Mask(ALIGN_DOUBLE) Save\n Align some doubles on dword boundary\n \n malign-functions=\n@@ -51,7 +85,7 @@ Target RejectNegative Joined Var(ix86_align_loops_string)\n Loop code aligned to this power of 2\n \n malign-stringops\n-Target RejectNegative Report InverseMask(NO_ALIGN_STRINGOPS, ALIGN_STRINGOPS)\n+Target RejectNegative Report InverseMask(NO_ALIGN_STRINGOPS, ALIGN_STRINGOPS) Save\n Align destination of the string operations\n \n march=\n@@ -75,55 +109,55 @@ Target RejectNegative Joined Var(ix86_cmodel_string)\n Use given x86-64 code model\n \n mfancy-math-387\n-Target RejectNegative Report InverseMask(NO_FANCY_MATH_387, USE_FANCY_MATH_387)\n+Target RejectNegative Report InverseMask(NO_FANCY_MATH_387, USE_FANCY_MATH_387) Save\n Generate sin, cos, sqrt for FPU\n \n mfp-ret-in-387\n-Target Report Mask(FLOAT_RETURNS)\n+Target Report Mask(FLOAT_RETURNS) Save\n Return values of functions in FPU registers\n \n mfpmath=\n Target RejectNegative Joined Var(ix86_fpmath_string)\n Generate floating point mathematics using given instruction set\n \n mhard-float\n-Target RejectNegative Mask(80387) MaskExists\n+Target RejectNegative Mask(80387) MaskExists Save\n Use hardware fp\n \n mieee-fp\n-Target Report Mask(IEEE_FP)\n+Target Report Mask(IEEE_FP) Save\n Use IEEE math for fp comparisons\n \n minline-all-stringops\n-Target Report Mask(INLINE_ALL_STRINGOPS)\n+Target Report Mask(INLINE_ALL_STRINGOPS) Save\n Inline all known string operations\n \n minline-stringops-dynamically\n-Target Report Mask(INLINE_STRINGOPS_DYNAMICALLY)\n+Target Report Mask(INLINE_STRINGOPS_DYNAMICALLY) Save\n Inline memset/memcpy string operations, but perform inline version only for small blocks\n \n mintel-syntax\n Target Undocumented\n ;; Deprecated\n \n mms-bitfields\n-Target Report Mask(MS_BITFIELD_LAYOUT)\n+Target Report Mask(MS_BITFIELD_LAYOUT) Save\n Use native (MS) bitfield layout\n \n mno-align-stringops\n-Target RejectNegative Report Mask(NO_ALIGN_STRINGOPS) Undocumented\n+Target RejectNegative Report Mask(NO_ALIGN_STRINGOPS) Undocumented Save\n \n mno-fancy-math-387\n-Target RejectNegative Report Mask(NO_FANCY_MATH_387) Undocumented\n+Target RejectNegative Report Mask(NO_FANCY_MATH_387) Undocumented Save\n \n mno-push-args\n-Target RejectNegative Report Mask(NO_PUSH_ARGS) Undocumented\n+Target RejectNegative Report Mask(NO_PUSH_ARGS) Undocumented Save\n \n mno-red-zone\n-Target RejectNegative Report Mask(NO_RED_ZONE) Undocumented\n+Target RejectNegative Report Mask(NO_RED_ZONE) Undocumented Save\n \n momit-leaf-frame-pointer\n-Target Report Mask(OMIT_LEAF_FRAME_POINTER)\n+Target Report Mask(OMIT_LEAF_FRAME_POINTER) Save\n Omit the frame pointer in leaf functions\n \n mpc\n@@ -135,35 +169,35 @@ Target RejectNegative Joined Var(ix86_preferred_stack_boundary_string)\n Attempt to keep stack aligned to this power of 2\n \n mpush-args\n-Target Report InverseMask(NO_PUSH_ARGS, PUSH_ARGS)\n+Target Report InverseMask(NO_PUSH_ARGS, PUSH_ARGS) Save\n Use push instructions to save outgoing arguments\n \n mred-zone\n-Target RejectNegative Report InverseMask(NO_RED_ZONE, RED_ZONE)\n+Target RejectNegative Report InverseMask(NO_RED_ZONE, RED_ZONE) Save\n Use red-zone in the x86-64 code\n \n mregparm=\n Target RejectNegative Joined Var(ix86_regparm_string)\n Number of registers used to pass integer arguments\n \n mrtd\n-Target Report Mask(RTD)\n+Target Report Mask(RTD) Save\n Alternate calling convention\n \n msoft-float\n-Target InverseMask(80387)\n+Target InverseMask(80387) Save\n Do not use hardware fp\n \n msseregparm\n-Target RejectNegative Mask(SSEREGPARM)\n+Target RejectNegative Mask(SSEREGPARM) Save\n Use SSE register passing conventions for SF and DF mode\n \n mstackrealign\n Target Report Var(ix86_force_align_arg_pointer)\n Realign stack in prologue\n \n mstack-arg-probe\n-Target Report Mask(STACK_PROBE)\n+Target Report Mask(STACK_PROBE) Save\n Enable stack probing\n \n mstringop-strategy=\n@@ -186,104 +220,105 @@ mveclibabi=\n Target RejectNegative Joined Var(ix86_veclibabi_string)\n Vector library ABI to use\n \n+mrecip\n+Target Report Mask(RECIP) Save\n+Generate reciprocals instead of divss and sqrtss.\n+\n+mcld\n+Target Report Mask(CLD) Save\n+Generate cld instruction in the function prologue.\n+\n+mno-fused-madd\n+Target RejectNegative Report Mask(NO_FUSED_MADD) Undocumented Save\n+\n+mfused-madd\n+Target Report InverseMask(NO_FUSED_MADD, FUSED_MADD) Save\n+Enable automatic generation of fused floating point multiply-add instructions\n+if the ISA supports such instructions.  The -mfused-madd option is on by\n+default.\n+\n ;; ISA support\n \n m32\n-Target RejectNegative Negative(m64) Report InverseMask(ISA_64BIT) Var(ix86_isa_flags) VarExists\n+Target RejectNegative Negative(m64) Report InverseMask(ISA_64BIT) Var(ix86_isa_flags) VarExists Save\n Generate 32bit i386 code\n \n m64\n-Target RejectNegative Negative(m32) Report Mask(ISA_64BIT) Var(ix86_isa_flags) VarExists\n+Target RejectNegative Negative(m32) Report Mask(ISA_64BIT) Var(ix86_isa_flags) VarExists Save\n Generate 64bit x86-64 code\n \n mmmx\n-Target Report Mask(ISA_MMX) Var(ix86_isa_flags) VarExists\n+Target Report Mask(ISA_MMX) Var(ix86_isa_flags) VarExists Save\n Support MMX built-in functions\n \n m3dnow\n-Target Report Mask(ISA_3DNOW) Var(ix86_isa_flags) VarExists\n+Target Report Mask(ISA_3DNOW) Var(ix86_isa_flags) VarExists Save\n Support 3DNow! built-in functions\n \n m3dnowa\n-Target Undocumented Mask(ISA_3DNOW_A) Var(ix86_isa_flags) VarExists\n+Target Undocumented Mask(ISA_3DNOW_A) Var(ix86_isa_flags) VarExists Save\n Support Athlon 3Dnow! built-in functions\n \n msse\n-Target Report Mask(ISA_SSE) Var(ix86_isa_flags) VarExists\n+Target Report Mask(ISA_SSE) Var(ix86_isa_flags) VarExists Save\n Support MMX and SSE built-in functions and code generation\n \n msse2\n-Target Report Mask(ISA_SSE2) Var(ix86_isa_flags) VarExists\n+Target Report Mask(ISA_SSE2) Var(ix86_isa_flags) VarExists Save\n Support MMX, SSE and SSE2 built-in functions and code generation\n \n msse3\n-Target Report Mask(ISA_SSE3) Var(ix86_isa_flags) VarExists\n+Target Report Mask(ISA_SSE3) Var(ix86_isa_flags) VarExists Save\n Support MMX, SSE, SSE2 and SSE3 built-in functions and code generation\n \n mssse3\n-Target Report Mask(ISA_SSSE3) Var(ix86_isa_flags) VarExists\n+Target Report Mask(ISA_SSSE3) Var(ix86_isa_flags) VarExists Save\n Support MMX, SSE, SSE2, SSE3 and SSSE3 built-in functions and code generation\n \n msse4.1\n-Target Report Mask(ISA_SSE4_1) Var(ix86_isa_flags) VarExists\n+Target Report Mask(ISA_SSE4_1) Var(ix86_isa_flags) VarExists Save\n Support MMX, SSE, SSE2, SSE3, SSSE3 and SSE4.1 built-in functions and code generation\n \n msse4.2\n-Target Report Mask(ISA_SSE4_2) Var(ix86_isa_flags) VarExists\n+Target Report Mask(ISA_SSE4_2) Var(ix86_isa_flags) VarExists Save\n Support MMX, SSE, SSE2, SSE3, SSSE3, SSE4.1 and SSE4.2 built-in functions and code generation\n \n msse4\n-Target RejectNegative Report Mask(ISA_SSE4_2) MaskExists Var(ix86_isa_flags) VarExists\n+Target RejectNegative Report Mask(ISA_SSE4_2) MaskExists Var(ix86_isa_flags) VarExists Save\n Support MMX, SSE, SSE2, SSE3, SSSE3, SSE4.1 and SSE4.2 built-in functions and code generation\n \n mno-sse4\n-Target RejectNegative Report InverseMask(ISA_SSE4_1) MaskExists Var(ix86_isa_flags) VarExists\n+Target RejectNegative Report InverseMask(ISA_SSE4_1) MaskExists Var(ix86_isa_flags) VarExists Save\n Do not support SSE4.1 and SSE4.2 built-in functions and code generation\n \n msse4a\n-Target Report Mask(ISA_SSE4A) Var(ix86_isa_flags) VarExists\n+Target Report Mask(ISA_SSE4A) Var(ix86_isa_flags) VarExists Save\n Support MMX, SSE, SSE2, SSE3 and SSE4A built-in functions and code generation\n \n msse5\n-Target Report Mask(ISA_SSE5) Var(ix86_isa_flags) VarExists\n+Target Report Mask(ISA_SSE5) Var(ix86_isa_flags) VarExists Save\n Support SSE5 built-in functions and code generation\n \n-;; Instruction support\n-\n-mcld\n-Target Report Mask(CLD)\n-Generate cld instruction in the function prologue.\n-\n mabm\n-Target Report RejectNegative Var(x86_abm)\n+Target Report Mask(ISA_ABM) Var(ix86_isa_flags) VarExists Save\n Support code generation of Advanced Bit Manipulation (ABM) instructions.\n \n-mcx16\n-Target Report RejectNegative Var(x86_cmpxchg16b)\n-Support code generation of cmpxchg16b instruction.\n-\n mpopcnt\n-Target Report RejectNegative Var(x86_popcnt)\n+Target Report Mask(ISA_POPCNT) Var(ix86_isa_flags) VarExists Save\n Support code generation of popcnt instruction.\n \n+mcx16\n+Target Report Mask(ISA_CX16) Var(ix86_isa_flags) VarExists Save\n+Support code generation of cmpxchg16b instruction.\n+\n msahf\n-Target Report RejectNegative Var(x86_sahf)\n+Target Report Mask(ISA_SAHF) Var(ix86_isa_flags) VarExists Save\n Support code generation of sahf instruction in 64bit x86-64 code.\n \n-mrecip\n-Target Report RejectNegative Var(x86_recip)\n-Generate reciprocals instead of divss and sqrtss.\n-\n-mfused-madd\n-Target Report Var(x86_fused_muladd) Init(1)\n-Enable automatic generation of fused floating point multiply-add instructions\n-if the ISA supports such instructions.  The -mfused-madd option is on by\n-default.\n-\n maes\n-Target Report RejectNegative Var(x86_aes)\n+Target Report Mask(ISA_AES) Var(ix86_isa_flags) VarExists Save\n Support AES built-in functions and code generation\n \n mpclmul\n-Target Report RejectNegative Var(x86_pclmul)\n+Target Report Mask(ISA_PCLMUL) Var(ix86_isa_flags) VarExists Save\n Support PCLMUL built-in functions and code generation"}, {"sha": "4c0c046dae6107a2c580621af7de0be043d13f7f", "filename": "gcc/config/i386/t-i386", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Fconfig%2Fi386%2Ft-i386", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Fconfig%2Fi386%2Ft-i386", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Ft-i386?ref=ab442df7fb453434d80a779844fe1a10c0c802ab", "patch": "@@ -0,0 +1,13 @@\n+i386.o: $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n+  $(RTL_H) $(TREE_H) $(TM_P_H) $(REGS_H) hard-reg-set.h \\\n+  $(REAL_H) insn-config.h conditions.h output.h insn-codes.h \\\n+  $(INSN_ATTR_H) $(FLAGS_H) $(C_COMMON_H) except.h $(FUNCTION_H) \\\n+  $(RECOG_H) $(EXPR_H) $(OPTABS_H) toplev.h $(BASIC_BLOCK_H) \\\n+  $(GGC_H) $(TARGET_H) $(TARGET_DEF_H) langhooks.h $(CGRAPH_H) \\\n+  $(TREE_GIMPLE_H) dwarf2.h $(DF_H) tm-constrs.h $(PARAMS_H)\n+\n+i386-c.o: $(srcdir)/config/i386/i386-c.c \\\n+  $(srcdir)/config/i386/i386-protos.h $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n+  $(TM_H) $(RTL_H) $(TREE_H) $(TM_P_H) $(FLAGS_H) $(C_COMMON_H) $(GGC_H) \\\n+  $(TARGET_H) $(TARGET_DEF_H) $(CPPLIB_H) $(C_PRAGMA_H)\n+\t$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $(srcdir)/config/i386/i386-c.c"}, {"sha": "f5d62cab785a4134ea6e6c7f66d0ac9f9d6686b1", "filename": "gcc/coretypes.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Fcoretypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Fcoretypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoretypes.h?ref=ab442df7fb453434d80a779844fe1a10c0c802ab", "patch": "@@ -50,6 +50,8 @@ typedef union tree_node *tree;\n typedef const union tree_node *const_tree;\n union section;\n typedef union section section;\n+struct cl_target_option;\n+struct cl_optimization;\n \n /* The major intermediate representations of GCC.  */\n enum ir_type {"}, {"sha": "6eef7d12ef35e8faba0fa0908ef03f4733fedea5", "filename": "gcc/doc/c-tree.texi", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Fdoc%2Fc-tree.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Fdoc%2Fc-tree.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fc-tree.texi?ref=ab442df7fb453434d80a779844fe1a10c0c802ab", "patch": "@@ -1330,6 +1330,8 @@ a containing function, and the back end must take appropriate action.\n @findex DECL_GLOBAL_CTOR_P\n @findex DECL_GLOBAL_DTOR_P\n @findex GLOBAL_INIT_PRIORITY\n+@findex DECL_FUNCTION_SPECIFIC_TARGET\n+@findex DECL_FUNCTION_SPECIFIC_OPTIMIZATION\n \n The following macros and functions can be used on a @code{FUNCTION_DECL}:\n @ftable @code\n@@ -1514,6 +1516,17 @@ is of the form `@code{()}'.\n This predicate holds if the function an overloaded\n @code{operator delete[]}.\n \n+@item DECL_FUNCTION_SPECIFIC_TARGET\n+This macro returns a tree node that holds the target options that are\n+to be used to compile this particular function or @code{NULL_TREE} if\n+the function is to be compiled with the target options specified on\n+the command line.\n+\n+@item DECL_FUNCTION_SPECIFIC_OPTIMIZATION\n+This macro returns a tree node that holds the optimization options\n+that are to be used to compile this particular function or\n+@code{NULL_TREE} if the function is to be compiled with the\n+optimization options specified on the command line.\n @end ftable\n \n @c ---------------------------------------------------------------------"}, {"sha": "a8040920d65dcc269553462836c3686355d0fb17", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 287, "deletions": 2, "changes": 289, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=ab442df7fb453434d80a779844fe1a10c0c802ab", "patch": "@@ -1792,6 +1792,8 @@ the enclosing block.\n @cindex functions that are passed arguments in registers on the 386\n @cindex functions that pop the argument stack on the 386\n @cindex functions that do not pop the argument stack on the 386\n+@cindex functions that have different compilation options on the 386\n+@cindex functions that have different optimization options\n \n In GNU C, you declare certain things about functions called in your program\n which help the compiler optimize function calls and check your code more\n@@ -2662,6 +2664,207 @@ with the notable exceptions of @code{qsort} and @code{bsearch} that\n take function pointer arguments.  The @code{nothrow} attribute is not\n implemented in GCC versions earlier than 3.3.\n \n+@item option\n+@cindex @code{option} function attribute\n+The @code{option} attribute is used to specify that a function is to\n+be compiled with different target options than specified on the\n+command line.  This can be used for instance to have functions\n+compiled with a different ISA (instruction set architecture) than the\n+default.  You can also use the @samp{#pragma GCC option} pragma to set\n+more than one function to be compiled with specific target options.\n+@xref{Function Specific Option Pragmas}, for details about the\n+@samp{#pragma GCC option} pragma.\n+\n+For instance on a 386, you could compile one function with\n+@code{option(\"sse4.1,arch=core2\")} and another with\n+@code{option(\"sse4a,arch=amdfam10\")} that would be equivalent to\n+compiling the first function with @option{-msse4.1} and\n+@option{-march=core2} options, and the second function with\n+@option{-msse4a} and @option{-march=amdfam10} options.  It is up to the\n+user to make sure that a function is only invoked on a machine that\n+supports the particular ISA it was compiled for (for example by using\n+@code{cpuid} on 386 to determine what feature bits and architecture\n+family are used).\n+\n+@smallexample\n+int core2_func (void) __attribute__ ((__option__ (\"arch=core2\")));\n+int sse3_func (void) __attribute__ ((__option__ (\"sse3\")));\n+@end smallexample\n+\n+On the 386, the following options are allowed:\n+\n+@table @samp\n+@item abm\n+@itemx no-abm\n+@cindex option(\"abm\")\n+Enable/disable the generation of the advanced bit instructions.\n+\n+@item aes\n+@itemx no-aes\n+@cindex @code{option(\"aes\")} attribute\n+Enable/disable the generation of the AES instructions.\n+\n+@item mmx\n+@itemx no-mmx\n+@cindex @code{option(\"mmx\")} attribute\n+Enable/disable the generation of the MMX instructions.\n+\n+@item pclmul\n+@itemx no-pclmul\n+@cindex @code{option(\"pclmul\")} attribute\n+Enable/disable the generation of the PCLMUL instructions.\n+\n+@item popcnt\n+@itemx no-popcnt\n+@cindex @code{option(\"popcnt\")} attribute\n+Enable/disable the generation of the POPCNT instruction.\n+\n+@item sse\n+@itemx no-sse\n+@cindex @code{option(\"sse\")} attribute\n+Enable/disable the generation of the SSE instructions.\n+\n+@item sse2\n+@itemx no-sse2\n+@cindex @code{option(\"sse2\")} attribute\n+Enable/disable the generation of the SSE2 instructions.\n+\n+@item sse3\n+@itemx no-sse3\n+@cindex @code{option(\"sse3\")} attribute\n+Enable/disable the generation of the SSE3 instructions.\n+\n+@item sse4\n+@itemx no-sse4\n+@cindex @code{option(\"sse4\")} attribute\n+Enable/disable the generation of the SSE4 instructions (both SSE4.1\n+and SSE4.2).\n+\n+@item sse4.1\n+@itemx no-sse4.1\n+@cindex @code{option(\"sse4.1\")} attribute\n+Enable/disable the generation of the sse4.1 instructions.\n+\n+@item sse4.2\n+@itemx no-sse4.2\n+@cindex @code{option(\"sse4.2\")} attribute\n+Enable/disable the generation of the sse4.2 instructions.\n+\n+@item sse4a\n+@itemx no-sse4a\n+@cindex @code{option(\"sse4a\")} attribute\n+Enable/disable the generation of the SSE4A instructions.\n+\n+@item sse5\n+@itemx no-sse5\n+@cindex @code{option(\"sse5\")} attribute\n+Enable/disable the generation of the SSE5 instructions.\n+\n+@item ssse3\n+@itemx no-ssse3\n+@cindex @code{option(\"ssse3\")} attribute\n+Enable/disable the generation of the SSSE3 instructions.\n+\n+@item cld\n+@itemx no-cld\n+@cindex @code{option(\"cld\")} attribute\n+Enable/disable the generation of the CLD before string moves.\n+\n+@item fancy-math-387\n+@itemx no-fancy-math-387\n+@cindex @code{option(\"fancy-math-387\")} attribute\n+Enable/disable the generation of the @code{sin}, @code{cos}, and\n+@code{sqrt} instructions on the 387 floating point unit.\n+\n+@item fused-madd\n+@itemx no-fused-madd\n+@cindex @code{option(\"fused-madd\")} attribute\n+Enable/disable the generation of the fused multiply/add instructions.\n+\n+@item ieee-fp\n+@itemx no-ieee-fp\n+@cindex @code{option(\"ieee-fp\")} attribute\n+Enable/disable the generation of floating point that depends on IEEE arithmetic.\n+\n+@item inline-all-stringops\n+@itemx no-inline-all-stringops\n+@cindex @code{option(\"inline-all-stringops\")} attribute\n+Enable/disable inlining of string operations.\n+\n+@item inline-stringops-dynamically\n+@itemx no-inline-stringops-dynamically\n+@cindex @code{option(\"inline-stringops-dynamically\")} attribute\n+Enable/disable the generation of the inline code to do small string\n+operations and calling the library routines for large operations.\n+\n+@item align-stringops\n+@itemx no-align-stringops\n+@cindex @code{option(\"align-stringops\")} attribute\n+Do/do not align destination of inlined string operations.\n+\n+@item recip\n+@itemx no-recip\n+@cindex @code{option(\"recip\")} attribute\n+Enable/disable the generation of RCPSS, RCPPS, RSQRTSS and RSQRTPS\n+instructions followed an additional Newton-Rhapson step instead of\n+doing a floating point division.\n+\n+@item arch=@var{ARCH}\n+@cindex @code{option(\"arch=@var{ARCH}\")} attribute\n+Specify the architecture to generate code for in compiling the function.\n+\n+@item tune=@var{TUNE}\n+@cindex @code{option(\"tune=@var{TUNE}\")} attribute\n+Specify the architecture to tune for in compiling the function.\n+\n+@item fpmath=@var{FPMATH}\n+@cindex @code{option(\"fpmath=@var{FPMATH}\")} attribute\n+Specify which floating point unit to use.  The\n+@code{option(\"fpmath=sse,387\")} option must be specified as\n+@code{option(\"fpmath=sse+387\")} because the comma would separate\n+different options.\n+@end table\n+\n+On the 386, you can use either multiple strings to specify multiple\n+options, or you can separate the option with a comma (@code{,}).\n+\n+On the 386, the inliner will not inline a function that has different\n+target options than the caller, unless the callee has a subset of the\n+target options of the caller.  For example a function declared with\n+@code{option(\"sse5\")} can inline a function with\n+@code{option(\"sse2\")}, since @code{-msse5} implies @code{-msse2}.\n+\n+The @code{option} attribute is not implemented in GCC versions earlier\n+than 4.4, and at present only the 386 uses it.\n+\n+@item optimize\n+@cindex @code{optimize} function attribute\n+The @code{optimize} attribute is used to specify that a function is to\n+be compiled with different optimization options than specified on the\n+command line.  Arguments can either be numbers or strings.  Numbers\n+are assumed to be an optimization level.  Strings that begin with\n+@code{O} are assumed to be an optimization option, while other options\n+are assumed to be used with a @code{-f} prefix.  You can also use the\n+@samp{#pragma GCC optimize} pragma to set the optimization options\n+that affect more than one function.\n+@xref{Function Specific Option Pragmas}, for details about the\n+@samp{#pragma GCC option} pragma.\n+\n+This can be used for instance to have frequently executed functions\n+compiled with more aggressive optimization options that produce faster\n+and larger code, while other functions can be called with less\n+aggressive options.  The @code{hot} attribute implies\n+@code{optimize(\"O3\")}, and @code{cold} attribute implies\n+@code{optimize(\"Os\")}.\n+\n+@smallexample\n+int fast_func (void) __attribute__ ((__optimize__ (\"O3,unroll-loops\")));\n+int slow_func (void) __attribute__ ((__optimize__ (\"Os\")));\n+@end smallexample\n+\n+The inliner will not inline functions with a higher optimization level\n+than the caller or different space/time trade offs.\n+\n @item pure\n @cindex @code{pure} function attribute\n Many functions have no effects except the return value and their\n@@ -2697,7 +2900,11 @@ all hot functions appears close together improving locality.\n When profile feedback is available, via @option{-fprofile-use}, hot functions\n are automatically detected and this attribute is ignored.\n \n-The @code{hot} attribute is not implemented in GCC versions earlier than 4.3.\n+The @code{hot} attribute is not implemented in GCC versions earlier\n+than 4.3.\n+\n+Starting with GCC 4.4, the @code{hot} attribute sets\n+@code{optimize(\"O3\")} to turn on more aggressive optimization.\n \n @item cold\n @cindex @code{cold} function attribute\n@@ -2714,7 +2921,10 @@ occasions.\n When profile feedback is available, via @option{-fprofile-use}, hot functions\n are automatically detected and this attribute is ignored.\n \n-The @code{hot} attribute is not implemented in GCC versions earlier than 4.3.\n+The @code{cold} attribute is not implemented in GCC versions earlier than 4.3.\n+\n+Starting with GCC 4.4, the @code{cold} attribute sets\n+@code{optimize(\"Os\")} to save space.\n \n @item regparm (@var{number})\n @cindex @code{regparm} attribute\n@@ -11108,6 +11318,7 @@ for further explanation.\n * Diagnostic Pragmas::\n * Visibility Pragmas::\n * Push/Pop Macro Pragmas::\n+* Function Specific Option Pragmas::\n @end menu\n \n @node ARM Pragmas\n@@ -11458,6 +11669,80 @@ int x [X];\n In this example, the definition of X as 1 is saved by @code{#pragma\n push_macro} and restored by @code{#pragma pop_macro}.\n \n+@node Function Specific Option Pragmas\n+@subsection Function Specific Option Pragmas\n+\n+@table @code\n+@item #pragma GCC option (@var{\"string\"}...)\n+@cindex pragma GCC option\n+\n+This pragma allows you to set target specific options for functions\n+defined later in the source file.  One or more strings can be\n+specified.  Each function that is defined after this point will be as\n+if @code{attribute((option(\"STRING\")))} was specified for that\n+function.  The parenthesis around the options is optional.\n+@xref{Function Attributes}, for more information about the\n+@code{option} attribute and the attribute syntax.\n+\n+The @samp{#pragma GCC option} pragma is not implemented in GCC\n+versions earlier than 4.4, and is currently only implemented for the\n+386 and x86_64 backend.\n+@end table\n+\n+@table @code\n+@item #pragma GCC option (push)\n+@itemx #pragma GCC option (pop)\n+@cindex pragma GCC option\n+\n+These pragmas maintain a stack of the current options.  It is\n+intended for include files where you temporarily want to switch to\n+using a different @samp{#pragma GCC option} and then to pop back to\n+the previous options.\n+@end table\n+\n+@table @code\n+@item #pragma GCC option (reset)\n+@cindex pragma, target option\n+@cindex pragma GCC option\n+\n+This pragma clears the current @code{#pragma GCC options} to use the\n+default switches as specified on the command line.\n+@end table\n+@table @code\n+@item #pragma GCC optimize (@var{\"string\"}...)\n+@cindex pragma GCC optimize\n+\n+This pragma allows you to set global optimization options for functions\n+defined later in the source file.  One or more strings can be\n+specified.  Each function that is defined after this point will be as\n+if @code{attribute((optimize(\"STRING\")))} was specified for that\n+function.  The parenthesis around the options is optional.\n+@xref{Function Attributes}, for more information about the\n+@code{optimize} attribute and the attribute syntax.\n+\n+The @samp{#pragma GCC optimize} pragma is not implemented in GCC\n+versions earlier than 4.4.\n+@end table\n+\n+@table @code\n+@item #pragma GCC optimize (push)\n+@itemx #pragma GCC optimize (pop)\n+@cindex pragma GCC optimize\n+\n+These pragmas maintain a stack of the current optimization options.\n+It is intended for include files where you temporarily want to switch\n+to using a different @code{#pragma GCC optimize} and then to pop back\n+to the previous optimizations.\n+@end table\n+\n+@table @code\n+@item #pragma GCC optimize reset\n+@cindex pragma GCC optimize\n+\n+This pragma clears the current @code{#pragma GCC optimize} to use the\n+default switches as specified on the command line.\n+@end table\n+\n @node Unnamed Fields\n @section Unnamed struct/union fields within structs/unions\n @cindex struct"}, {"sha": "f493bf710a954b31372615e1d0cf7f111558cf32", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=ab442df7fb453434d80a779844fe1a10c0c802ab", "patch": "@@ -10543,6 +10543,8 @@ code that expects temporaries to be 80bit.\n This is the default choice for the x86-64 compiler.\n \n @item sse,387\n+@itemx sse+387\n+@itemx both\n Attempt to utilize both instruction sets at once.  This effectively double the\n amount of available registers and on chips with separate execution units for\n 387 and SSE the execution resources too.  Use this option with care, as it is"}, {"sha": "4581ead6da6efb5c4066aa2dcb253562112b0ee9", "filename": "gcc/doc/options.texi", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Fdoc%2Foptions.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Fdoc%2Foptions.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Foptions.texi?ref=ab442df7fb453434d80a779844fe1a10c0c802ab", "patch": "@@ -35,8 +35,11 @@ has been declared in this way, it can be used as an option property.\n @xref{Option properties}.\n \n @item\n-An option definition record.  These records have the following fields:\n+A target specific save record to save additional information. These\n+records have two fields: the string @samp{TargetSave}, and a\n+declaration type to go in the @code{cl_target_option} structure.\n \n+@item\n @enumerate\n @item\n the name of the option, with the leading ``-'' removed\n@@ -124,7 +127,10 @@ This property cannot be used alongside @code{Joined} or @code{Separate}.\n @item UInteger\n The option's argument is a non-negative integer.  The option parser\n will check and convert the argument before passing it to the relevant\n-option handler.\n+option handler.  @code{UInteger} should also be used on options like\n+@code{-falign-loops} where both @code{-falign-loops} and\n+@code{-falign-loops}=@var{n} are supported to make sure the saved\n+options are given a full integer.\n \n @item Var(@var{var})\n The state of this option should be stored in variable @var{var}.\n@@ -221,4 +227,9 @@ The option should only be accepted if preprocessor condition\n option will be present even if @var{cond} is false; @var{cond} simply\n controls whether the option is accepted and whether it is printed in\n the @option{--help} output.\n+\n+@item Save\n+Build the @code{cl_target_option} structure to hold a copy of the\n+option, add the functions @code{cl_target_option_save} and\n+@code{cl_target_option_restore} to save and restore the options.\n @end table"}, {"sha": "274e69b9802a69d5f97ccdd9dde0dd5db0759533", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=ab442df7fb453434d80a779844fe1a10c0c802ab", "patch": "@@ -9271,6 +9271,51 @@ attributes, @code{false} otherwise.  By default, if a function has a\n target specific attribute attached to it, it will not be inlined.\n @end deftypefn\n \n+@deftypefn {Target Hook} bool TARGET_VALID_OPTION_ATTRIBUTE_P (tree @var{fndecl}, tree @var{name}, tree @var{args}, int @var{flags})\n+This hook is called to parse the @code{attribute(option(\"...\"))}, and\n+it allows the function to set different target machine compile time\n+options for the current function that might be different than the\n+options specified on the command line.  The hook should return\n+@code{true} if the options are valid.\n+\n+The hook should set the @var{DECL_FUNCTION_SPECIFIC_TARGET} field in\n+the function declaration to hold a pointer to a target specific\n+@var{struct cl_target_option} structure.\n+@end deftypefn\n+\n+@deftypefn {Target Hook} void TARGET_OPTION_SAVE (struct cl_target_option *@var{ptr})\n+This hook is called to save any additional target specific information\n+in the @var{struct cl_target_option} structure for function specific\n+options.\n+@xref{Option file format}.\n+@end deftypefn\n+\n+@deftypefn {Target Hook} void TARGET_OPTION_RESTORE (struct cl_target_option *@var{ptr})\n+This hook is called to restore any additional target specific\n+information in the @var{struct cl_target_option} structure for\n+function specific options.\n+@end deftypefn\n+\n+@deftypefn {Target Hook} void TARGET_OPTION_PRINT (struct cl_target_option *@var{ptr})\n+This hook is called to print any additional target specific\n+information in the @var{struct cl_target_option} structure for\n+function specific options.\n+@end deftypefn\n+\n+@deftypefn {Target Hook} bool TARGET_OPTION_PRAGMA_PARSE (target @var{args})\n+This target hook parses the options for @code{#pragma GCC option} to\n+set the machine specific options for functions that occur later in the\n+input stream.  The options should be the same as handled by the\n+@code{TARGET_VALID_OPTION_ATTRIBUTE_P} hook.\n+@end deftypefn\n+\n+@deftypefn {Target Hook} bool TARGET_CAN_INLINE_P (tree @var{caller}, tree @var{callee})\n+This target hook returns @code{false} if the @var{caller} function\n+cannot inline @var{callee}, based on target specific information.  By\n+default, inlining is not allowed if the callee function has function\n+specific target options and the caller does not use the same options.\n+@end deftypefn\n+\n @node Emulated TLS\n @section Emulating TLS\n @cindex Emulated TLS"}, {"sha": "fa2a84d804f8f726f4474588eca7fc03c4bc1a46", "filename": "gcc/function.c", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=ab442df7fb453434d80a779844fe1a10c0c802ab", "patch": "@@ -3731,13 +3731,30 @@ debug_find_var_in_block_tree (tree var, tree block)\n \n static bool in_dummy_function;\n \n-/* Invoke the target hook when setting cfun.  */\n+/* Invoke the target hook when setting cfun.  Update the optimization options\n+   if the function uses different options than the default.  */\n \n static void\n invoke_set_current_function_hook (tree fndecl)\n {\n   if (!in_dummy_function)\n-    targetm.set_current_function (fndecl);\n+    {\n+      tree opts = ((fndecl)\n+\t\t   ? DECL_FUNCTION_SPECIFIC_OPTIMIZATION (fndecl)\n+\t\t   : optimization_default_node);\n+\n+      if (!opts)\n+\topts = optimization_default_node;\n+\n+      /* Change optimization options if needed.  */\n+      if (optimization_current_node != opts)\n+\t{\n+\t  optimization_current_node = opts;\n+\t  cl_optimization_restore (TREE_OPTIMIZATION (opts));\n+\t}\n+\n+      targetm.set_current_function (fndecl);\n+    }\n }\n \n /* cfun should never be set directly; use this function.  */"}, {"sha": "b7f1597691a50193c1de0b6ccff7559972390e07", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=ab442df7fb453434d80a779844fe1a10c0c802ab", "patch": "@@ -954,6 +954,14 @@ cgraph_decide_inlining_of_small_functions (void)\n \t    }\n \t  continue;\n \t}\n+      if (!tree_can_inline_p (edge->caller->decl, edge->callee->decl))\n+\t{\n+\t  CALL_STMT_CANNOT_INLINE_P (edge->call_stmt) = true;\n+\t  edge->inline_failed = N_(\"target specific option mismatch\");\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \" inline_failed:%s.\\n\", edge->inline_failed);\n+\t  continue;\n+\t}\n       if (cgraph_recursive_inlining_p (edge->caller, edge->callee,\n \t\t\t\t       &edge->inline_failed))\n \t{\n@@ -1098,6 +1106,11 @@ cgraph_decide_inlining (void)\n \t  if (cgraph_recursive_inlining_p (e->caller, e->callee,\n \t\t\t\t  \t   &e->inline_failed))\n \t    continue;\n+\t  if (!tree_can_inline_p (e->caller->decl, e->callee->decl))\n+\t    {\n+\t      CALL_STMT_CANNOT_INLINE_P (e->call_stmt) = true;\n+\t      continue;\n+\t    }\n \t  cgraph_mark_inline_edge (e, true);\n \t  if (dump_file)\n \t    fprintf (dump_file, \n@@ -1322,6 +1335,17 @@ cgraph_decide_inlining_incrementally (struct cgraph_node *node,\n \t    }\n \t  continue;\n \t}\n+      if (!tree_can_inline_p (node->decl, e->callee->decl))\n+\t{\n+\t  CALL_STMT_CANNOT_INLINE_P (e->call_stmt) = true;\n+\t  if (dump_file)\n+\t    {\n+\t      indent_to (dump_file, depth);\n+\t      fprintf (dump_file,\n+\t\t       \"Not inlining: Target specific option mismatch.\\n\");\n+\t    }\n+\t  continue;\n+\t}\n       if (gimple_in_ssa_p (DECL_STRUCT_FUNCTION (node->decl))\n \t  != gimple_in_ssa_p (DECL_STRUCT_FUNCTION (e->callee->decl)))\n \t{\n@@ -1418,6 +1442,17 @@ cgraph_decide_inlining_incrementally (struct cgraph_node *node,\n \t      }\n \t    continue;\n \t  }\n+\tif (!tree_can_inline_p (node->decl, e->callee->decl))\n+\t  {\n+\t    CALL_STMT_CANNOT_INLINE_P (e->call_stmt) = true;\n+\t    if (dump_file)\n+\t      {\n+\t\tindent_to (dump_file, depth);\n+\t\tfprintf (dump_file,\n+\t\t\t \"Not inlining: Target specific option mismatch.\\n\");\n+\t      }\n+\t    continue;\n+\t  }\n \tif (cgraph_default_inline_p (e->callee, &failed_reason))\n \t  inlined |= try_inline (e, mode, depth);\n \telse if (!flag_unit_at_a_time)"}, {"sha": "a14b8c203d547517bcdc475d747c4d7095915ede", "filename": "gcc/opt-functions.awk", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Fopt-functions.awk", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Fopt-functions.awk", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopt-functions.awk?ref=ab442df7fb453434d80a779844fe1a10c0c802ab", "patch": "@@ -128,6 +128,23 @@ function var_type(flags)\n \t\treturn \"const char *\"\n }\n \n+# Return the type of variable that should be associated with the given flags\n+# for use within a structure.  Simple variables are changed to unsigned char\n+# type instead of int to save space.\n+function var_type_struct(flags)\n+{\n+\tif (flag_set_p(\"UInteger\", flags))\n+\t\treturn \"int \"\n+\telse if (!flag_set_p(\"Joined.*\", flags)) {\n+\t\tif (flag_set_p(\".*Mask.*\", flags))\n+\t\t\treturn \"int \"\n+\t\telse\n+\t\t\treturn \"unsigned char \"\n+\t}\n+\telse\n+\t\treturn \"const char *\"\n+}\n+\n # Given that an option has flags FLAGS, return an initializer for the\n # \"var_cond\" and \"var_value\" fields of its cl_options[] entry.\n function var_set(flags)"}, {"sha": "845efb4a5157d99fb5c7e066513acd700738269f", "filename": "gcc/optc-gen.awk", "status": "modified", "additions": 319, "deletions": 0, "changes": 319, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Foptc-gen.awk", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Foptc-gen.awk", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptc-gen.awk?ref=ab442df7fb453434d80a779844fe1a10c0c802ab", "patch": "@@ -28,6 +28,7 @@\n BEGIN {\n \tn_opts = 0\n \tn_langs = 0\n+\tn_target_save = 0\n         quote = \"\\042\"\n \tcomma = \",\"\n \tFS=SUBSEP\n@@ -41,6 +42,11 @@ BEGIN {\n \t\t\tlangs[n_langs] = $2\n \t\t\tn_langs++;\n \t\t}\n+\t\telse if ($1 == \"TargetSave\") {\n+\t\t\t# Make sure the declarations are put in source order\n+\t\t\ttarget_save_decl[n_target_save] = $2\n+\t\t\tn_target_save++\n+\t\t}\n \t\telse {\n \t\t\tname = opt_args(\"Mask\", $1)\n \t\t\tif (name == \"\") {\n@@ -64,10 +70,17 @@ print \"#include \" quote \"intl.h\" quote\n print \"\"\n print \"#ifdef GCC_DRIVER\"\n print \"int target_flags;\"\n+print \"#else\"\n+print \"#include \" quote \"flags.h\" quote\n+print \"#include \" quote \"target.h\" quote\n print \"#endif /* GCC_DRIVER */\"\n print \"\"\n \n+have_save = 0;\n for (i = 0; i < n_opts; i++) {\n+\tif (flag_set_p(\"Save\", flags[i]))\n+\t\thave_save = 1;\n+\n \tname = var_name(flags[i]);\n \tif (name == \"\")\n \t\tcontinue;\n@@ -210,4 +223,310 @@ for (i = 0; i < n_opts; i++) {\n }\n \n print \"};\"\n+\n+print \"\";\n+print \"#if !defined(GCC_DRIVER) && !defined(IN_LIBGCC2)\"\n+print \"\";\n+print \"/* Save optimization variables into a structure.  */\"\n+print \"void\";\n+print \"cl_optimization_save (struct cl_optimization *ptr)\";\n+print \"{\";\n+\n+n_opt_char = 2;\n+n_opt_short = 0;\n+n_opt_int = 0;\n+n_opt_other = 0;\n+var_opt_char[0] = \"optimize\";\n+var_opt_char[1] = \"optimize_size\";\n+var_opt_range[\"optimize\"] = \"0, 255\";\n+var_opt_range[\"optimize_size\"] = \"0, 255\";\n+\n+# Sort by size to mimic how the structure is laid out to be friendlier to the\n+# cache.\n+\n+for (i = 0; i < n_opts; i++) {\n+\tif (flag_set_p(\"Optimization\", flags[i])) {\n+\t\tname = var_name(flags[i])\n+\t\tif(name == \"\")\n+\t\t\tcontinue;\n+\n+\t\tif(name in var_opt_seen)\n+\t\t\tcontinue;\n+\n+\t\tvar_opt_seen[name]++;\n+\t\totype = var_type_struct(flags[i]);\n+\t\tif (otype ~ \"^((un)?signed +)?int *$\")\n+\t\t\tvar_opt_int[n_opt_int++] = name;\n+\n+\t\telse if (otype ~ \"^((un)?signed +)?short *$\")\n+\t\t\tvar_opt_short[n_opt_short++] = name;\n+\n+\t\telse if (otype ~ \"^((un)?signed +)?char *$\") {\n+\t\t\tvar_opt_char[n_opt_char++] = name;\n+\t\t\tif (otype ~ \"^unsigned +char *$\")\n+\t\t\t\tvar_opt_range[name] = \"0, 255\"\n+\t\t\telse if (otype ~ \"^signed +char *$\")\n+\t\t\t\tvar_opt_range[name] = \"-128, 127\"\n+\t\t}\n+\t\telse\n+\t\t\tvar_opt_other[n_opt_other++] = name;\n+\t}\n+}\n+\n+for (i = 0; i < n_opt_char; i++) {\n+\tname = var_opt_char[i];\n+\tif (var_opt_range[name] != \"\")\n+\t\tprint \"  gcc_assert (IN_RANGE (\" name \", \" var_opt_range[name] \"));\";\n+}\n+\n+print \"\";\n+for (i = 0; i < n_opt_other; i++) {\n+\tprint \"  ptr->\" var_opt_other[i] \" = \" var_opt_other[i] \";\";\n+}\n+\n+for (i = 0; i < n_opt_int; i++) {\n+\tprint \"  ptr->\" var_opt_int[i] \" = \" var_opt_int[i] \";\";\n+}\n+\n+for (i = 0; i < n_opt_short; i++) {\n+\tprint \"  ptr->\" var_opt_short[i] \" = \" var_opt_short[i] \";\";\n+}\n+\n+for (i = 0; i < n_opt_char; i++) {\n+\tprint \"  ptr->\" var_opt_char[i] \" = \" var_opt_char[i] \";\";\n+}\n+\n+print \"}\";\n+\n+print \"\";\n+print \"/* Restore optimization options from a structure.  */\";\n+print \"void\";\n+print \"cl_optimization_restore (struct cl_optimization *ptr)\";\n+print \"{\";\n+\n+for (i = 0; i < n_opt_other; i++) {\n+\tprint \"  \" var_opt_other[i] \" = ptr->\" var_opt_other[i] \";\";\n+}\n+\n+for (i = 0; i < n_opt_int; i++) {\n+\tprint \"  \" var_opt_int[i] \" = ptr->\" var_opt_int[i] \";\";\n+}\n+\n+for (i = 0; i < n_opt_short; i++) {\n+\tprint \"  \" var_opt_short[i] \" = ptr->\" var_opt_short[i] \";\";\n+}\n+\n+for (i = 0; i < n_opt_char; i++) {\n+\tprint \"  \" var_opt_char[i] \" = ptr->\" var_opt_char[i] \";\";\n+}\n+\n+print \"}\";\n+\n+print \"\";\n+print \"/* Print optimization options from a structure.  */\";\n+print \"void\";\n+print \"cl_optimization_print (FILE *file,\";\n+print \"                       int indent_to,\";\n+print \"                       struct cl_optimization *ptr)\";\n+print \"{\";\n+\n+print \"  fputs (\\\"\\\\n\\\", file);\";\n+for (i = 0; i < n_opt_other; i++) {\n+\tprint \"  if (ptr->\" var_opt_other[i] \")\";\n+\tprint \"    fprintf (file, \\\"%*s%s (0x%lx)\\\\n\\\",\";\n+\tprint \"             indent_to, \\\"\\\",\";\n+\tprint \"             \\\"\" var_opt_other[i] \"\\\",\";\n+\tprint \"             (unsigned long)ptr->\" var_opt_other[i] \");\";\n+\tprint \"\";\n+}\n+\n+for (i = 0; i < n_opt_int; i++) {\n+\tprint \"  if (ptr->\" var_opt_int[i] \")\";\n+\tprint \"    fprintf (file, \\\"%*s%s (0x%x)\\\\n\\\",\";\n+\tprint \"             indent_to, \\\"\\\",\";\n+\tprint \"             \\\"\" var_opt_int[i] \"\\\",\";\n+\tprint \"             ptr->\" var_opt_int[i] \");\";\n+\tprint \"\";\n+}\n+\n+for (i = 0; i < n_opt_short; i++) {\n+\tprint \"  if (ptr->\" var_opt_short[i] \")\";\n+\tprint \"    fprintf (file, \\\"%*s%s (0x%x)\\\\n\\\",\";\n+\tprint \"             indent_to, \\\"\\\",\";\n+\tprint \"             \\\"\" var_opt_short[i] \"\\\",\";\n+\tprint \"             ptr->\" var_opt_short[i] \");\";\n+\tprint \"\";\n+}\n+\n+for (i = 0; i < n_opt_char; i++) {\n+\tprint \"  if (ptr->\" var_opt_char[i] \")\";\n+\tprint \"    fprintf (file, \\\"%*s%s (0x%x)\\\\n\\\",\";\n+\tprint \"             indent_to, \\\"\\\",\";\n+\tprint \"             \\\"\" var_opt_char[i] \"\\\",\";\n+\tprint \"             ptr->\" var_opt_char[i] \");\";\n+\tprint \"\";\n+}\n+\n+print \"}\";\n+\n+print \"\";\n+print \"/* Save selected option variables into a structure.  */\"\n+print \"void\";\n+print \"cl_target_option_save (struct cl_target_option *ptr)\";\n+print \"{\";\n+\n+n_target_char = 0;\n+n_target_short = 0;\n+n_target_int = 0;\n+n_target_other = 0;\n+\n+if (have_save) {\n+\tfor (i = 0; i < n_opts; i++) {\n+\t\tif (flag_set_p(\"Save\", flags[i])) {\n+\t\t\tname = var_name(flags[i])\n+\t\t\tif(name == \"\")\n+\t\t\t\tname = \"target_flags\";\n+\n+\t\t\tif(name in var_save_seen)\n+\t\t\t\tcontinue;\n+\n+\t\t\tvar_save_seen[name]++;\n+\t\t\totype = var_type_struct(flags[i])\n+\t\t\tif (otype ~ \"^((un)?signed +)?int *$\")\n+\t\t\t\tvar_target_int[n_target_int++] = name;\n+\n+\t\t\telse if (otype ~ \"^((un)?signed +)?short *$\")\n+\t\t\t\tvar_target_short[n_target_short++] = name;\n+\n+\t\t\telse if (otype ~ \"^((un)?signed +)?char *$\") {\n+\t\t\t\tvar_target_char[n_target_char++] = name;\n+\t\t\t\tif (otype ~ \"^unsigned +char *$\")\n+\t\t\t\t\tvar_target_range[name] = \"0, 255\"\n+\t\t\t\telse if (otype ~ \"^signed +char *$\")\n+\t\t\t\t\tvar_target_range[name] = \"-128, 127\"\n+\t\t\t}\n+\t\t\telse\n+\t\t\t\tvar_target_other[n_target_other++] = name;\n+\t\t}\n+\t}\n+} else {\n+\tvar_target_int[n_target_int++] = \"target_flags\";\n+}\n+\n+have_assert = 0;\n+for (i = 0; i < n_target_char; i++) {\n+\tname = var_target_char[i];\n+\tif (var_target_range[name] != \"\") {\n+\t\thave_assert = 1;\n+\t\tprint \"  gcc_assert (IN_RANGE (\" name \", \" var_target_range[name] \"));\";\n+\t}\n+}\n+\n+if (have_assert)\n+\tprint \"\";\n+\n+print \"  if (targetm.target_option.save)\";\n+print \"    targetm.target_option.save (ptr);\";\n+print \"\";\n+\n+for (i = 0; i < n_target_other; i++) {\n+\tprint \"  ptr->\" var_target_other[i] \" = \" var_target_other[i] \";\";\n+}\n+\n+for (i = 0; i < n_target_int; i++) {\n+\tprint \"  ptr->\" var_target_int[i] \" = \" var_target_int[i] \";\";\n+}\n+\n+for (i = 0; i < n_target_short; i++) {\n+\tprint \"  ptr->\" var_target_short[i] \" = \" var_target_short[i] \";\";\n+}\n+\n+for (i = 0; i < n_target_char; i++) {\n+\tprint \"  ptr->\" var_target_char[i] \" = \" var_target_char[i] \";\";\n+}\n+\n+print \"}\";\n+\n+print \"\";\n+print \"/* Restore selected current options from a structure.  */\";\n+print \"void\";\n+print \"cl_target_option_restore (struct cl_target_option *ptr)\";\n+print \"{\";\n+\n+for (i = 0; i < n_target_other; i++) {\n+\tprint \"  \" var_target_other[i] \" = ptr->\" var_target_other[i] \";\";\n+}\n+\n+for (i = 0; i < n_target_int; i++) {\n+\tprint \"  \" var_target_int[i] \" = ptr->\" var_target_int[i] \";\";\n+}\n+\n+for (i = 0; i < n_target_short; i++) {\n+\tprint \"  \" var_target_short[i] \" = ptr->\" var_target_short[i] \";\";\n+}\n+\n+for (i = 0; i < n_target_char; i++) {\n+\tprint \"  \" var_target_char[i] \" = ptr->\" var_target_char[i] \";\";\n+}\n+\n+# This must occur after the normal variables in case the code depends on those\n+# variables.\n+print \"\";\n+print \"  if (targetm.target_option.restore)\";\n+print \"    targetm.target_option.restore (ptr);\";\n+\n+print \"}\";\n+\n+print \"\";\n+print \"/* Print optimization options from a structure.  */\";\n+print \"void\";\n+print \"cl_target_option_print (FILE *file,\";\n+print \"                        int indent,\";\n+print \"                        struct cl_target_option *ptr)\";\n+print \"{\";\n+\n+print \"  fputs (\\\"\\\\n\\\", file);\";\n+for (i = 0; i < n_target_other; i++) {\n+\tprint \"  if (ptr->\" var_target_other[i] \")\";\n+\tprint \"    fprintf (file, \\\"%*s%s (0x%lx)\\\\n\\\",\";\n+\tprint \"             indent, \\\"\\\",\";\n+\tprint \"             \\\"\" var_target_other[i] \"\\\",\";\n+\tprint \"             (unsigned long)ptr->\" var_target_other[i] \");\";\n+\tprint \"\";\n+}\n+\n+for (i = 0; i < n_target_int; i++) {\n+\tprint \"  if (ptr->\" var_target_int[i] \")\";\n+\tprint \"    fprintf (file, \\\"%*s%s (0x%x)\\\\n\\\",\";\n+\tprint \"             indent, \\\"\\\",\";\n+\tprint \"             \\\"\" var_target_int[i] \"\\\",\";\n+\tprint \"             ptr->\" var_target_int[i] \");\";\n+\tprint \"\";\n+}\n+\n+for (i = 0; i < n_target_short; i++) {\n+\tprint \"  if (ptr->\" var_target_short[i] \")\";\n+\tprint \"    fprintf (file, \\\"%*s%s (0x%x)\\\\n\\\",\";\n+\tprint \"             indent, \\\"\\\",\";\n+\tprint \"             \\\"\" var_target_short[i] \"\\\",\";\n+\tprint \"             ptr->\" var_target_short[i] \");\";\n+\tprint \"\";\n+}\n+\n+for (i = 0; i < n_target_char; i++) {\n+\tprint \"  if (ptr->\" var_target_char[i] \")\";\n+\tprint \"    fprintf (file, \\\"%*s%s (0x%x)\\\\n\\\",\";\n+\tprint \"             indent, \\\"\\\",\";\n+\tprint \"             \\\"\" var_target_char[i] \"\\\",\";\n+\tprint \"             ptr->\" var_target_char[i] \");\";\n+\tprint \"\";\n+}\n+\n+print \"\";\n+print \"  if (targetm.target_option.print)\";\n+print \"    targetm.target_option.print (file, indent, ptr);\";\n+\n+print \"}\";\n+print \"#endif\";\n+\n }"}, {"sha": "7c1d92ac4fa94542741c8e0196d63847a77bff71", "filename": "gcc/opth-gen.awk", "status": "modified", "additions": 171, "deletions": 0, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Fopth-gen.awk", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Fopth-gen.awk", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopth-gen.awk?ref=ab442df7fb453434d80a779844fe1a10c0c802ab", "patch": "@@ -26,6 +26,7 @@\n BEGIN {\n \tn_opts = 0\n \tn_langs = 0\n+\tn_target_save = 0\n \tn_extra_masks = 0\n \tquote = \"\\042\"\n \tcomma = \",\"\n@@ -38,6 +39,11 @@ BEGIN {\n \t\t\tlangs[n_langs] = $2\n \t\t\tn_langs++;\n \t\t}\n+\t\telse if ($1 == \"TargetSave\") {\n+\t\t\t# Make sure the declarations are put in source order\n+\t\t\ttarget_save_decl[n_target_save] = $2\n+\t\t\tn_target_save++\n+\t\t}\n \t\telse {\n \t\t\tname = opt_args(\"Mask\", $1)\n \t\t\tif (name == \"\") {\n@@ -64,15 +70,180 @@ print \"extern int target_flags;\"\n print \"extern int target_flags_explicit;\"\n print \"\"\n \n+have_save = 0;\n+\n for (i = 0; i < n_opts; i++) {\n+\tif (flag_set_p(\"Save\", flags[i]))\n+\t\thave_save = 1;\n+\n \tname = var_name(flags[i]);\n \tif (name == \"\")\n \t\tcontinue;\n \n+\tif (name in var_seen)\n+\t\tcontinue;\n+\n+\tvar_seen[name] = 1;\n \tprint \"extern \" var_type(flags[i]) name \";\"\n }\n print \"\"\n \n+# All of the optimization switches gathered together so they can be saved and restored.\n+# This will allow attribute((cold)) to turn on space optimization.\n+\n+# Change the type of normal switches from int to unsigned char to save space.\n+# Also, order the structure so that pointer fields occur first, then int\n+# fields, and then char fields to provide the best packing.\n+\n+print \"#if !defined(GCC_DRIVER) && !defined(IN_LIBGCC2)\"\n+print \"\"\n+print \"/* Structure to save/restore optimization and target specific options.  */\";\n+print \"struct cl_optimization GTY(())\";\n+print \"{\";\n+\n+n_opt_char = 2;\n+n_opt_short = 0;\n+n_opt_int = 0;\n+n_opt_other = 0;\n+var_opt_char[0] = \"unsigned char optimize\";\n+var_opt_char[1] = \"unsigned char optimize_size\";\n+\n+for (i = 0; i < n_opts; i++) {\n+\tif (flag_set_p(\"Optimization\", flags[i])) {\n+\t\tname = var_name(flags[i])\n+\t\tif(name == \"\")\n+\t\t\tcontinue;\n+\n+\t\tif(name in var_opt_seen)\n+\t\t\tcontinue;\n+\n+\t\tvar_opt_seen[name]++;\n+\t\totype = var_type_struct(flags[i]);\n+\t\tif (otype ~ \"^((un)?signed +)?int *$\")\n+\t\t\tvar_opt_int[n_opt_int++] = otype name;\n+\n+\t\telse if (otype ~ \"^((un)?signed +)?short *$\")\n+\t\t\tvar_opt_short[n_opt_short++] = otype name;\n+\n+\t\telse if (otype ~ \"^((un)?signed +)?char *$\")\n+\t\t\tvar_opt_char[n_opt_char++] = otype name;\n+\n+\t\telse\n+\t\t\tvar_opt_other[n_opt_other++] = otype name;\n+\t}\n+}\n+\n+for (i = 0; i < n_opt_other; i++) {\n+\tprint \"  \" var_opt_other[i] \";\";\n+}\n+\n+for (i = 0; i < n_opt_int; i++) {\n+\tprint \"  \" var_opt_int[i] \";\";\n+}\n+\n+for (i = 0; i < n_opt_short; i++) {\n+\tprint \"  \" var_opt_short[i] \";\";\n+}\n+\n+for (i = 0; i < n_opt_char; i++) {\n+\tprint \"  \" var_opt_char[i] \";\";\n+}\n+\n+print \"};\";\n+print \"\";\n+\n+# Target and optimization save/restore/print functions.\n+print \"/* Structure to save/restore selected target specific options.  */\";\n+print \"struct cl_target_option GTY(())\";\n+print \"{\";\n+\n+n_target_char = 0;\n+n_target_short = 0;\n+n_target_int = 0;\n+n_target_other = 0;\n+\n+for (i = 0; i < n_target_save; i++) {\n+\tif (target_save_decl[i] ~ \"^((un)?signed +)?int +[_a-zA-Z0-9]+$\")\n+\t\tvar_target_int[n_target_int++] = target_save_decl[i];\n+\n+\telse if (target_save_decl[i] ~ \"^((un)?signed +)?short +[_a-zA-Z0-9]+$\")\n+\t\tvar_target_short[n_target_short++] = target_save_decl[i];\n+\n+\telse if (target_save_decl[i] ~ \"^((un)?signed +)?char +[_a-zA-Z0-9]+$\")\n+\t\tvar_target_char[n_target_char++] = target_save_decl[i];\n+\n+\telse\n+\t\tvar_target_other[n_target_other++] = target_save_decl[i];\n+}\n+\n+if (have_save) {\n+\tfor (i = 0; i < n_opts; i++) {\n+\t\tif (flag_set_p(\"Save\", flags[i])) {\n+\t\t\tname = var_name(flags[i])\n+\t\t\tif(name == \"\")\n+\t\t\t\tname = \"target_flags\";\n+\n+\t\t\tif(name in var_save_seen)\n+\t\t\t\tcontinue;\n+\n+\t\t\tvar_save_seen[name]++;\n+\t\t\totype = var_type_struct(flags[i])\n+\t\t\tif (otype ~ \"^((un)?signed +)?int *$\")\n+\t\t\t\tvar_target_int[n_target_int++] = otype name;\n+\n+\t\t\telse if (otype ~ \"^((un)?signed +)?short *$\")\n+\t\t\t\tvar_target_short[n_target_short++] = otype name;\n+\n+\t\t\telse if (otype ~ \"^((un)?signed +)?char *$\")\n+\t\t\t\tvar_target_char[n_target_char++] = otype name;\n+\n+\t\t\telse\n+\t\t\t\tvar_target_other[n_target_other++] = otype name;\n+\t\t}\n+\t}\n+} else {\n+\tvar_target_int[n_target_int++] = \"int target_flags\";\n+}\n+\n+for (i = 0; i < n_target_other; i++) {\n+\tprint \"  \" var_target_other[i] \";\";\n+}\n+\n+for (i = 0; i < n_target_int; i++) {\n+\tprint \"  \" var_target_int[i] \";\";\n+}\n+\n+for (i = 0; i < n_target_short; i++) {\n+\tprint \"  \" var_target_short[i] \";\";\n+}\n+\n+for (i = 0; i < n_target_char; i++) {\n+\tprint \"  \" var_target_char[i] \";\";\n+}\n+\n+print \"};\";\n+print \"\";\n+print \"\";\n+print \"/* Save optimization variables into a structure.  */\"\n+print \"extern void cl_optimization_save (struct cl_optimization *);\";\n+print \"\";\n+print \"/* Restore optimization variables from a structure.  */\";\n+print \"extern void cl_optimization_restore (struct cl_optimization *);\";\n+print \"\";\n+print \"/* Print optimization variables from a structure.  */\";\n+print \"extern void cl_optimization_print (FILE *, int, struct cl_optimization *);\";\n+print \"\";\n+print \"/* Save selected option variables into a structure.  */\"\n+print \"extern void cl_target_option_save (struct cl_target_option *);\";\n+print \"\";\n+print \"/* Restore selected option variables from a structure.  */\"\n+print \"extern void cl_target_option_restore (struct cl_target_option *);\";\n+print \"\";\n+print \"/* Print target option variables from a structure.  */\";\n+print \"extern void cl_target_option_print (FILE *, int, struct cl_target_option *);\";\n+print \"#endif\";\n+print \"\";\n+\n for (i = 0; i < n_opts; i++) {\n \tname = opt_args(\"Mask\", flags[i])\n \tvname = var_name(flags[i])"}, {"sha": "a45722703861a6dfa713e7a173c46f3020a9cd09", "filename": "gcc/opts.c", "status": "modified", "additions": 200, "deletions": 119, "changes": 319, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=ab442df7fb453434d80a779844fe1a10c0c802ab", "patch": "@@ -809,12 +809,36 @@ handle_options (unsigned int argc, const char **argv, unsigned int lang_mask)\n void\n decode_options (unsigned int argc, const char **argv)\n {\n-  unsigned int i, lang_mask;\n+  static bool first_time_p = true;\n+  static int initial_max_aliased_vops;\n+  static int initial_avg_aliased_vops;\n+  static int initial_min_crossjump_insns;\n+  static int initial_max_fields_for_field_sensitive;\n+  static unsigned int initial_lang_mask;\n \n-  /* Perform language-specific options initialization.  */\n-  lang_mask = lang_hooks.init_options (argc, argv);\n+  unsigned int i, lang_mask;\n+  int opt1;\n+  int opt2;\n+  int opt3;\n+  int opt1_max;\n \n-  lang_hooks.initialize_diagnostics (global_dc);\n+  if (first_time_p)\n+    {\n+      /* Perform language-specific options initialization.  */\n+      initial_lang_mask = lang_mask = lang_hooks.init_options (argc, argv);\n+\n+      lang_hooks.initialize_diagnostics (global_dc);\n+\n+      /* Save initial values of parameters we reset.  */\n+      initial_max_aliased_vops = MAX_ALIASED_VOPS;\n+      initial_avg_aliased_vops = AVG_ALIASED_VOPS;\n+      initial_min_crossjump_insns\n+\t= compiler_params[PARAM_MIN_CROSSJUMP_INSNS].value;\n+      initial_max_fields_for_field_sensitive\n+\t= compiler_params[PARAM_MAX_FIELDS_FOR_FIELD_SENSITIVE].value;\n+    }\n+  else\n+    lang_mask = initial_lang_mask;\n \n   /* Scan to see what optimization level has been specified.  That will\n      determine the default value of many flags.  */\n@@ -863,6 +887,9 @@ decode_options (unsigned int argc, const char **argv)\n       flag_section_anchors = 0;\n     }\n \n+  /* Originally we just set the variables if a particular optimization level,\n+     but with the advent of being able to change the optimization level for a\n+     function, we need to reset optimizations.  */\n   if (!optimize)\n     {\n       flag_merge_constants = 0;\n@@ -873,139 +900,170 @@ decode_options (unsigned int argc, const char **argv)\n       if (flag_toplevel_reorder == 2)\n         flag_toplevel_reorder = 0;\n     }\n+  else\n+    flag_merge_constants = 1;\n \n-  if (optimize >= 1)\n-    {\n-      flag_defer_pop = 1;\n+  /* -O1 optimizations.  */\n+  opt1 = (optimize >= 1);\n+  flag_defer_pop = opt1;\n #ifdef DELAY_SLOTS\n-      flag_delayed_branch = 1;\n+  flag_delayed_branch = opt1;\n #endif\n #ifdef CAN_DEBUG_WITHOUT_FP\n-      flag_omit_frame_pointer = 1;\n+  flag_omit_frame_pointer = opt1;\n #endif\n-      flag_guess_branch_prob = 1;\n-      flag_cprop_registers = 1;\n-      flag_if_conversion = 1;\n-      flag_if_conversion2 = 1;\n-      flag_ipa_pure_const = 1;\n-      flag_ipa_reference = 1;\n-      flag_split_wide_types = 1;\n-      flag_tree_ccp = 1;\n-      flag_tree_dce = 1;\n-      flag_tree_dom = 1;\n-      flag_tree_dse = 1;\n-      flag_tree_ter = 1;\n-      flag_tree_sra = 1;\n-      flag_tree_copyrename = 1;\n-      flag_tree_fre = 1;\n-      flag_tree_copy_prop = 1;\n-      flag_tree_sink = 1;\n-\n-      if (!optimize_size)\n-\t{\n-\t  /* Loop header copying usually increases size of the code.  This used\n-\t     not to be true, since quite often it is possible to verify that\n-\t     the condition is satisfied in the first iteration and therefore\n-\t     to eliminate it.  Jump threading handles these cases now.  */\n-\t  flag_tree_ch = 1;\n-\t}\n-    }\n-\n-  if (optimize >= 2)\n-    {\n-      flag_inline_small_functions = 1;\n-      flag_thread_jumps = 1;\n-      flag_crossjumping = 1;\n-      flag_optimize_sibling_calls = 1;\n-      flag_forward_propagate = 1;\n-      flag_cse_follow_jumps = 1;\n-      flag_gcse = 1;\n-      flag_expensive_optimizations = 1;\n-      flag_rerun_cse_after_loop = 1;\n-      flag_caller_saves = 1;\n-      flag_peephole2 = 1;\n+  flag_guess_branch_prob = opt1;\n+  flag_cprop_registers = opt1;\n+  flag_if_conversion = opt1;\n+  flag_if_conversion2 = opt1;\n+  flag_ipa_pure_const = opt1;\n+  flag_ipa_reference = opt1;\n+  flag_split_wide_types = opt1;\n+  flag_tree_ccp = opt1;\n+  flag_tree_dce = opt1;\n+  flag_tree_dom = opt1;\n+  flag_tree_dse = opt1;\n+  flag_tree_ter = opt1;\n+  flag_tree_sra = opt1;\n+  flag_tree_copyrename = opt1;\n+  flag_tree_fre = opt1;\n+  flag_tree_copy_prop = opt1;\n+  flag_tree_sink = opt1;\n+  flag_tree_ch = opt1;\n+\n+  /* -O2 optimizations.  */\n+  opt2 = (optimize >= 2);\n+  flag_inline_small_functions = opt2;\n+  flag_thread_jumps = opt2;\n+  flag_crossjumping = opt2;\n+  flag_optimize_sibling_calls = opt2;\n+  flag_forward_propagate = opt2;\n+  flag_cse_follow_jumps = opt2;\n+  flag_gcse = opt2;\n+  flag_expensive_optimizations = opt2;\n+  flag_rerun_cse_after_loop = opt2;\n+  flag_caller_saves = opt2;\n+  flag_peephole2 = opt2;\n #ifdef INSN_SCHEDULING\n-      flag_schedule_insns = 1;\n-      flag_schedule_insns_after_reload = 1;\n+  flag_schedule_insns = opt2;\n+  flag_schedule_insns_after_reload = opt2;\n #endif\n-      flag_regmove = 1;\n-      flag_strict_aliasing = 1;\n-      flag_strict_overflow = 1;\n-      flag_delete_null_pointer_checks = 1;\n-      flag_reorder_blocks = 1;\n-      flag_reorder_functions = 1;\n-      flag_tree_store_ccp = 1;\n-      flag_tree_vrp = 1;\n+  flag_regmove = opt2;\n+  flag_strict_aliasing = opt2;\n+  flag_strict_overflow = opt2;\n+  flag_delete_null_pointer_checks = opt2;\n+  flag_reorder_blocks = opt2;\n+  flag_reorder_functions = opt2;\n+  flag_tree_store_ccp = opt2;\n+  flag_tree_vrp = opt2;\n+  flag_tree_builtin_call_dce = opt2;\n+  flag_tree_pre = opt2;\n       flag_tree_switch_conversion = 1;\n \n-      if (!optimize_size)\n-\t{\n-          /* Conditional DCE generates bigger code.  */\n-          flag_tree_builtin_call_dce = 1;\n-          /* PRE tends to generate bigger code.  */\n-          flag_tree_pre = 1;\n-\t}\n-\n       /* Allow more virtual operators to increase alias precision.  */\n-      set_param_value (\"max-aliased-vops\", 500);\n \n-      /* Track fields in field-sensitive alias analysis.  */\n-      set_param_value (\"max-fields-for-field-sensitive\", 100);\n-    }\n+  set_param_value (\"max-aliased-vops\",\n+\t\t   (opt2) ? 500 : initial_max_aliased_vops);\n \n-  if (optimize >= 3)\n-    {\n-      flag_predictive_commoning = 1;\n-      flag_inline_functions = 1;\n-      flag_unswitch_loops = 1;\n-      flag_gcse_after_reload = 1;\n-      flag_tree_vectorize = 1;\n+  /* Track fields in field-sensitive alias analysis.  */\n+  set_param_value (\"max-fields-for-field-sensitive\",\n+\t\t   (opt2) ? 100 : initial_max_fields_for_field_sensitive);\n \n-      /* Allow even more virtual operators.  */\n-      set_param_value (\"max-aliased-vops\", 1000);\n-      set_param_value (\"avg-aliased-vops\", 3);\n-    }\n+  /* -O3 optimizations.  */\n+  opt3 = (optimize >= 3);\n+  flag_predictive_commoning = opt3;\n+  flag_inline_functions = opt3;\n+  flag_unswitch_loops = opt3;\n+  flag_gcse_after_reload = opt3;\n+  flag_tree_vectorize = opt3;\n+\n+  /* Allow even more virtual operators.  Max-aliased-vops was set above for\n+     -O2, so don't reset it unless we are at -O3.  */\n+  if (opt3)\n+    set_param_value (\"max-aliased-vops\", 1000);\n \n-  if (optimize < 2 || optimize_size)\n+  set_param_value (\"avg-aliased-vops\", (opt3) ? 3 : initial_avg_aliased_vops);\n+\n+  /* Just -O1/-O0 optimizations.  */\n+  opt1_max = (optimize <= 1);\n+  align_loops = opt1_max;\n+  align_jumps = opt1_max;\n+  align_labels = opt1_max;\n+  align_functions = opt1_max;\n+\n+  if (optimize_size)\n     {\n+      /* Loop header copying usually increases size of the code.  This used not to\n+\t be true, since quite often it is possible to verify that the condition is\n+\t satisfied in the first iteration and therefore to eliminate it.  Jump\n+\t threading handles these cases now.  */\n+      flag_tree_ch = 0;\n+\n+      /* Conditional DCE generates bigger code.  */\n+      flag_tree_builtin_call_dce = 0;\n+\n+      /* PRE tends to generate bigger code.  */\n+      flag_tree_pre = 0;\n+\n+      /* These options are set with -O3, so reset for -Os */\n+      flag_predictive_commoning = 0;\n+      flag_inline_functions = 0;\n+      flag_unswitch_loops = 0;\n+      flag_gcse_after_reload = 0;\n+      flag_tree_vectorize = 0;\n+\n+      /* Don't reorder blocks when optimizing for size because extra jump insns may\n+\t be created; also barrier may create extra padding.\n+\n+\t More correctly we should have a block reordering mode that tried to\n+\t minimize the combined size of all the jumps.  This would more or less\n+\t automatically remove extra jumps, but would also try to use more short\n+\t jumps instead of long jumps.  */\n+      flag_reorder_blocks = 0;\n+      flag_reorder_blocks_and_partition = 0;\n+\n+      /* Inlining of functions reducing size is a good idea regardless of them\n+\t being declared inline.  */\n+      flag_inline_functions = 1;\n+\n+      /* Don't align code.  */\n       align_loops = 1;\n       align_jumps = 1;\n       align_labels = 1;\n       align_functions = 1;\n \n-      /* Don't reorder blocks when optimizing for size because extra\n-\t jump insns may be created; also barrier may create extra padding.\n+      /* Unroll/prefetch switches that may be set on the command line, and tend to\n+\t generate bigger code.  */\n+      flag_unroll_loops = 0;\n+      flag_unroll_all_loops = 0;\n+      flag_prefetch_loop_arrays = 0;\n \n-\t More correctly we should have a block reordering mode that tried\n-\t to minimize the combined size of all the jumps.  This would more\n-\t or less automatically remove extra jumps, but would also try to\n-\t use more short jumps instead of long jumps.  */\n-      flag_reorder_blocks = 0;\n-      flag_reorder_blocks_and_partition = 0;\n-    }\n-\n-  if (optimize_size)\n-    {\n-      /* Inlining of functions reducing size is a good idea regardless\n-\t of them being declared inline.  */\n-      flag_inline_functions = 1;\n+      /* Basic optimization options.  */\n+      optimize_size = 1;\n+      if (optimize > 2)\n+\toptimize = 2;\n \n       /* We want to crossjump as much as possible.  */\n       set_param_value (\"min-crossjump-insns\", 1);\n     }\n+  else\n+    set_param_value (\"min-crossjump-insns\", initial_min_crossjump_insns);\n \n-  /* Initialize whether `char' is signed.  */\n-  flag_signed_char = DEFAULT_SIGNED_CHAR;\n-  /* Set this to a special \"uninitialized\" value.  The actual default is set\n-     after target options have been processed.  */\n-  flag_short_enums = 2;\n-\n-  /* Initialize target_flags before OPTIMIZATION_OPTIONS so the latter can\n-     modify it.  */\n-  target_flags = targetm.default_target_flags;\n-\n-  /* Some targets have ABI-specified unwind tables.  */\n-  flag_unwind_tables = targetm.unwind_tables_default;\n+  if (first_time_p)\n+    {\n+      /* Initialize whether `char' is signed.  */\n+      flag_signed_char = DEFAULT_SIGNED_CHAR;\n+      /* Set this to a special \"uninitialized\" value.  The actual default is\n+\t set after target options have been processed.  */\n+      flag_short_enums = 2;\n+\n+      /* Initialize target_flags before OPTIMIZATION_OPTIONS so the latter can\n+\t modify it.  */\n+      target_flags = targetm.default_target_flags;\n+\n+      /* Some targets have ABI-specified unwind tables.  */\n+      flag_unwind_tables = targetm.unwind_tables_default;\n+    }\n \n #ifdef OPTIMIZATION_OPTIONS\n   /* Allow default optimizations to be specified on a per-machine basis.  */\n@@ -1014,15 +1072,18 @@ decode_options (unsigned int argc, const char **argv)\n \n   handle_options (argc, argv, lang_mask);\n \n-  if (flag_pie)\n-    flag_pic = flag_pie;\n-  if (flag_pic && !flag_pie)\n-    flag_shlib = 1;\n+  if (first_time_p)\n+    {\n+      if (flag_pie)\n+\tflag_pic = flag_pie;\n+      if (flag_pic && !flag_pie)\n+\tflag_shlib = 1;\n \n-  if (flag_no_inline == 2)\n-    flag_no_inline = 0;\n-  else\n-    flag_really_no_inline = flag_no_inline;\n+      if (flag_no_inline == 2)\n+\tflag_no_inline = 0;\n+      else\n+\tflag_really_no_inline = flag_no_inline;\n+    }\n \n   /* Set flag_no_inline before the post_options () hook.  The C front\n      ends use it to determine tree inlining defaults.  FIXME: such\n@@ -1095,6 +1156,14 @@ decode_options (unsigned int argc, const char **argv)\n       flag_reorder_blocks_and_partition = 0;\n       flag_reorder_blocks = 1;\n     }\n+\n+  /* Save the current optimization options if this is the first call.  */\n+  if (first_time_p)\n+    {\n+      optimization_default_node = build_optimization_node ();\n+      optimization_current_node = optimization_default_node;\n+      first_time_p = false;\n+    }\n }\n \n #define LEFT_COLUMN\t27\n@@ -2087,6 +2156,18 @@ fast_math_flags_set_p (void)\n \t  && !flag_errno_math);\n }\n \n+/* Return true iff flags are set as if -ffast-math but using the flags stored\n+   in the struct cl_optimization structure.  */\n+bool\n+fast_math_flags_struct_set_p (struct cl_optimization *opt)\n+{\n+  return (!opt->flag_trapping_math\n+\t  && opt->flag_unsafe_math_optimizations\n+\t  && opt->flag_finite_math_only\n+\t  && !opt->flag_signed_zeros\n+\t  && !opt->flag_errno_math);\n+}\n+\n /* Handle a debug output -g switch.  EXTENDED is true or false to support\n    extended output (2 is special and means \"-ggdb\" was given).  */\n static void"}, {"sha": "09ca2849a7ee19142311f577c12e05c600ab93f2", "filename": "gcc/print-tree.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Fprint-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Fprint-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-tree.c?ref=ab442df7fb453434d80a779844fe1a10c0c802ab", "patch": "@@ -369,6 +369,12 @@ print_node (FILE *file, const char *prefix, tree node, int indent)\n       if (TREE_CODE (node) == TYPE_DECL && TYPE_DECL_SUPPRESS_DEBUG (node))\n \tfputs (\" suppress-debug\", file);\n \n+      if (TREE_CODE (node) == FUNCTION_DECL\n+\t  && DECL_FUNCTION_SPECIFIC_TARGET (node))\n+\tfputs (\" function-specific-target\", file);\n+      if (TREE_CODE (node) == FUNCTION_DECL\n+\t  && DECL_FUNCTION_SPECIFIC_OPTIMIZATION (node))\n+\tfputs (\" function-specific-opt\", file);\n       if (TREE_CODE (node) == FUNCTION_DECL && DECL_INLINE (node))\n \tfputs (DECL_DECLARED_INLINE_P (node) ? \" inline\" : \" autoinline\", file);\n       if (TREE_CODE (node) == FUNCTION_DECL && DECL_BUILT_IN (node))\n@@ -931,6 +937,14 @@ print_node (FILE *file, const char *prefix, tree node, int indent)\n \t    }\n \t  break;\n \n+\tcase OPTIMIZATION_NODE:\n+\t  cl_optimization_print (file, indent + 4, TREE_OPTIMIZATION (node));\n+\t  break;\n+\n+\tcase TARGET_OPTION_NODE:\n+\t  cl_target_option_print (file, indent + 4, TREE_TARGET_OPTION (node));\n+\t  break;\n+\n \tdefault:\n \t  if (EXCEPTIONAL_CLASS_P (node))\n \t    lang_hooks.print_xnode (file, node, indent);"}, {"sha": "1d138e5fb68647c59203f7060fb333a33c6f67c4", "filename": "gcc/target-def.h", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Ftarget-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Ftarget-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-def.h?ref=ab442df7fb453434d80a779844fe1a10c0c802ab", "patch": "@@ -758,6 +758,41 @@\n     TARGET_EMUTLS_DEBUG_FORM_TLS_ADDRESS\t\\\n   }\n \n+/* Function specific option attribute support.  */\n+#ifndef TARGET_OPTION_VALID_ATTRIBUTE_P\n+#define TARGET_OPTION_VALID_ATTRIBUTE_P NULL\n+#endif\n+\n+#ifndef TARGET_OPTION_SAVE\n+#define TARGET_OPTION_SAVE NULL\n+#endif\n+\n+#ifndef TARGET_OPTION_RESTORE\n+#define TARGET_OPTION_RESTORE NULL\n+#endif\n+\n+#ifndef TARGET_OPTION_PRINT\n+#define TARGET_OPTION_PRINT NULL\n+#endif\n+\n+#ifndef TARGET_OPTION_PRAGMA_PARSE\n+#define TARGET_OPTION_PRAGMA_PARSE NULL\n+#endif\n+\n+#ifndef TARGET_OPTION_CAN_INLINE_P\n+#define TARGET_OPTION_CAN_INLINE_P default_target_option_can_inline_p\n+#endif\n+\n+#define TARGET_OPTION_HOOKS\t\t\t\\\n+  {\t\t\t\t\t\t\\\n+    TARGET_OPTION_VALID_ATTRIBUTE_P,\t\t\\\n+    TARGET_OPTION_SAVE,\t\t\t\t\\\n+    TARGET_OPTION_RESTORE,\t\t\t\\\n+    TARGET_OPTION_PRINT,\t\t\t\\\n+    TARGET_OPTION_PRAGMA_PARSE,\t\t\t\\\n+    TARGET_OPTION_CAN_INLINE_P,\t\t\t\\\n+  }\n+\n /* The whole shebang.  */\n #define TARGET_INITIALIZER\t\t\t\\\n {\t\t\t\t\t\t\\\n@@ -854,6 +889,7 @@\n   TARGET_C,\t\t\t\t\t\\\n   TARGET_CXX,\t\t\t\t\t\\\n   TARGET_EMUTLS,\t\t\t\t\\\n+  TARGET_OPTION_HOOKS,\t\t\t\t\\\n   TARGET_EXTRA_LIVE_ON_ENTRY,\t\t\t\\\n   TARGET_UNWIND_TABLES_DEFAULT,\t\t\t\\\n   TARGET_HAVE_NAMED_SECTIONS,\t\t\t\\"}, {"sha": "468e5d7f0833c2b1bb1f9254e8763341c32c5fb1", "filename": "gcc/target.h", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=ab442df7fb453434d80a779844fe1a10c0c802ab", "patch": "@@ -963,6 +963,34 @@ struct gcc_target\n     bool debug_form_tls_address;\n   } emutls;  \n \n+  struct target_option_hooks {\n+    /* Function to validate the attribute((option(...))) strings or NULL.  If\n+       the option is validated, it is assumed that DECL_FUNCTION_SPECIFIC will\n+       be filled in in the function decl node.  */\n+    bool (*valid_attribute_p) (tree, tree, tree, int);\n+\n+    /* Function to save any extra target state in the target options\n+       structure.  */\n+    void (*save) (struct cl_target_option *);\n+\n+    /* Function to restore any extra target state from the target options\n+       structure.  */\n+    void (*restore) (struct cl_target_option *);\n+\n+    /* Function to print any extra target state from the target options\n+       structure.  */\n+    void (*print) (FILE *, int, struct cl_target_option *);\n+\n+    /* Function to parse arguments to be validated for #pragma option, and to\n+       change the state if the options are valid.  If the arguments are NULL,\n+       use the default target options.  Return true if the options are valid,\n+       and set the current state.  */\n+    bool (*pragma_parse) (tree);\n+\n+    /* Function to determine if one function can inline another function.  */\n+    bool (*can_inline_p) (tree, tree);\n+  } target_option;\n+\n   /* For targets that need to mark extra registers as live on entry to\n      the function, they should define this target hook and set their\n      bits in the bitmap passed in. */  "}, {"sha": "4e9b9ad06750fdb34c6a677e522f3d42c146801a", "filename": "gcc/targhooks.c", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=ab442df7fb453434d80a779844fe1a10c0c802ab", "patch": "@@ -709,4 +709,38 @@ default_hard_regno_scratch_ok (unsigned int regno ATTRIBUTE_UNUSED)\n   return true;\n }\n \n+bool\n+default_target_option_valid_attribute_p (tree ARG_UNUSED (fndecl),\n+\t\t\t\t\t tree ARG_UNUSED (name),\n+\t\t\t\t\t tree ARG_UNUSED (args),\n+\t\t\t\t\t int ARG_UNUSED (flags))\n+{\n+  return false;\n+}\n+\n+bool\n+default_target_option_can_inline_p (tree caller, tree callee)\n+{\n+  bool ret = false;\n+  tree callee_opts = DECL_FUNCTION_SPECIFIC_TARGET (callee);\n+  tree caller_opts = DECL_FUNCTION_SPECIFIC_TARGET (caller);\n+\n+  /* If callee has no option attributes, then it is ok to inline */\n+  if (!callee_opts)\n+    ret = true;\n+\n+  /* If caller has no option attributes, but callee does then it is not ok to\n+     inline */\n+  else if (!caller_opts)\n+    ret = false;\n+\n+  /* If both caller and callee have attributes, assume that if the pointer is\n+     different, the the two functions have different target options since\n+     build_target_option_node uses a hash table for the options.  */\n+  else\n+    ret = (callee_opts == caller_opts);\n+\n+  return ret;\n+}\n+\n #include \"gt-targhooks.h\""}, {"sha": "efb487c0d8b2e09fd668296d863f97c4ab12d7e7", "filename": "gcc/targhooks.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=ab442df7fb453434d80a779844fe1a10c0c802ab", "patch": "@@ -97,5 +97,6 @@ extern int default_reloc_rw_mask (void);\n extern tree default_mangle_decl_assembler_name (tree, tree);\n extern tree default_emutls_var_fields (tree, tree *);\n extern tree default_emutls_var_init (tree, tree, tree);\n-\n extern bool default_hard_regno_scratch_ok (unsigned int);\n+extern bool default_target_option_valid_attribute_p (tree, tree, tree, int);\n+extern bool default_target_option_can_inline_p (tree, tree);"}, {"sha": "bcdc471eb589a437fdafdbe516d9bfba4ead5001", "filename": "gcc/testsuite/gcc.target/i386/cold-1.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fcold-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fcold-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fcold-1.c?ref=ab442df7fb453434d80a779844fe1a10c0c802ab", "patch": "@@ -0,0 +1,13 @@\n+/* Test whether using attribute((cold)) really turns on -Os.  Do this test\n+   by checking whether strcpy calls the library function rather than doing\n+   the move inline.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -march=k8\" } */\n+/* { dg-final { scan-assembler \"(jmp|call)\\t(.*)strcpy\" } } */\n+\n+void cold (char *) __attribute__((__cold__));\n+\n+void cold (char *a)\n+{\n+  __builtin_strcpy (a, \"testing 1.2.3 testing 1.2.3\");\n+}"}, {"sha": "1ee43a0bbb8ee70a98322c631003200a049543f0", "filename": "gcc/testsuite/gcc.target/i386/funcspec-1.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffuncspec-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffuncspec-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffuncspec-1.c?ref=ab442df7fb453434d80a779844fe1a10c0c802ab", "patch": "@@ -0,0 +1,34 @@\n+/* Test whether using target specific options, we can generate SSE2 code on\n+   32-bit, which does not generate SSE2 by default, but still generate 387 code\n+   for a function that doesn't use attribute((option)).  */\n+/* { dg-do compile } */\n+/* { dg-require-effective-target ilp32 } */\n+/* { dg-options \"-O3 -ftree-vectorize -march=i386\" } */\n+/* { dg-final { scan-assembler \"addps\\[ \\t\\]\" } } */\n+/* { dg-final { scan-assembler \"fsubs\\[ \\t\\]\" } } */\n+\n+#ifndef SIZE\n+#define SIZE 1024\n+#endif\n+\n+static float a[SIZE] __attribute__((__aligned__(16)));\n+static float b[SIZE] __attribute__((__aligned__(16)));\n+static float c[SIZE] __attribute__((__aligned__(16)));\n+\n+void sse_addnums (void) __attribute__ ((__option__ (\"sse2\")));\n+\n+void\n+sse_addnums (void)\n+{\n+  int i = 0;\n+  for (; i < SIZE; ++i)\n+    a[i] = b[i] + c[i];\n+}\n+\n+void\n+i387_subnums (void)\n+{\n+  int i = 0;\n+  for (; i < SIZE; ++i)\n+    a[i] = b[i] - c[i];\n+}"}, {"sha": "eb6f48bae1f93df212f68f264b0ee110133b2631", "filename": "gcc/testsuite/gcc.target/i386/funcspec-2.c", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffuncspec-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffuncspec-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffuncspec-2.c?ref=ab442df7fb453434d80a779844fe1a10c0c802ab", "patch": "@@ -0,0 +1,99 @@\n+/* Test whether using target specific options, we can generate SSE5 code.  */\n+/* { dg-do compile } */\n+/* { dg-require-effective-target lp64 } */\n+/* { dg-options \"-O2 -march=k8\" } */\n+\n+extern void exit (int);\n+\n+#define SSE5_ATTR __attribute__((__option__(\"sse5,fused-madd\")))\n+extern float  flt_mul_add     (float a, float b, float c) SSE5_ATTR;\n+extern float  flt_mul_sub     (float a, float b, float c) SSE5_ATTR;\n+extern float  flt_neg_mul_add (float a, float b, float c) SSE5_ATTR;\n+extern float  flt_neg_mul_sub (float a, float b, float c) SSE5_ATTR;\n+\n+extern double dbl_mul_add     (double a, double b, double c) SSE5_ATTR;\n+extern double dbl_mul_sub     (double a, double b, double c) SSE5_ATTR;\n+extern double dbl_neg_mul_add (double a, double b, double c) SSE5_ATTR;\n+extern double dbl_neg_mul_sub (double a, double b, double c) SSE5_ATTR;\n+\n+float\n+flt_mul_add (float a, float b, float c)\n+{\n+  return (a * b) + c;\n+}\n+\n+double\n+dbl_mul_add (double a, double b, double c)\n+{\n+  return (a * b) + c;\n+}\n+\n+float\n+flt_mul_sub (float a, float b, float c)\n+{\n+  return (a * b) - c;\n+}\n+\n+double\n+dbl_mul_sub (double a, double b, double c)\n+{\n+  return (a * b) - c;\n+}\n+\n+float\n+flt_neg_mul_add (float a, float b, float c)\n+{\n+  return (-(a * b)) + c;\n+}\n+\n+double\n+dbl_neg_mul_add (double a, double b, double c)\n+{\n+  return (-(a * b)) + c;\n+}\n+\n+float\n+flt_neg_mul_sub (float a, float b, float c)\n+{\n+  return (-(a * b)) - c;\n+}\n+\n+double\n+dbl_neg_mul_sub (double a, double b, double c)\n+{\n+  return (-(a * b)) - c;\n+}\n+\n+float  f[10] = { 2, 3, 4 };\n+double d[10] = { 2, 3, 4 };\n+\n+int main ()\n+{\n+  f[3] = flt_mul_add (f[0], f[1], f[2]);\n+  f[4] = flt_mul_sub (f[0], f[1], f[2]);\n+  f[5] = flt_neg_mul_add (f[0], f[1], f[2]);\n+  f[6] = flt_neg_mul_sub (f[0], f[1], f[2]);\n+\n+  d[3] = dbl_mul_add (d[0], d[1], d[2]);\n+  d[4] = dbl_mul_sub (d[0], d[1], d[2]);\n+  d[5] = dbl_neg_mul_add (d[0], d[1], d[2]);\n+  d[6] = dbl_neg_mul_sub (d[0], d[1], d[2]);\n+  exit (0);\n+}\n+\n+/* { dg-final { scan-assembler \"fmaddss\" } } */\n+/* { dg-final { scan-assembler \"fmaddsd\" } } */\n+/* { dg-final { scan-assembler \"fmsubss\" } } */\n+/* { dg-final { scan-assembler \"fmsubsd\" } } */\n+/* { dg-final { scan-assembler \"fnmaddss\" } } */\n+/* { dg-final { scan-assembler \"fnmaddsd\" } } */\n+/* { dg-final { scan-assembler \"fnmsubss\" } } */\n+/* { dg-final { scan-assembler \"fnmsubsd\" } } */\n+/* { dg-final { scan-assembler \"call\\t(.*)flt_mul_add\" } } */\n+/* { dg-final { scan-assembler \"call\\t(.*)flt_mul_sub\" } } */\n+/* { dg-final { scan-assembler \"call\\t(.*)flt_neg_mul_add\" } } */\n+/* { dg-final { scan-assembler \"call\\t(.*)flt_neg_mul_sub\" } } */\n+/* { dg-final { scan-assembler \"call\\t(.*)dbl_mul_add\" } } */\n+/* { dg-final { scan-assembler \"call\\t(.*)dbl_mul_sub\" } } */\n+/* { dg-final { scan-assembler \"call\\t(.*)dbl_neg_mul_add\" } } */\n+/* { dg-final { scan-assembler \"call\\t(.*)dbl_neg_mul_sub\" } } */"}, {"sha": "80ec23da09f0a9993b9abf8093c1c89678d19a85", "filename": "gcc/testsuite/gcc.target/i386/funcspec-3.c", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffuncspec-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffuncspec-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffuncspec-3.c?ref=ab442df7fb453434d80a779844fe1a10c0c802ab", "patch": "@@ -0,0 +1,66 @@\n+/* Test whether using target specific options, we can generate popcnt by\n+   setting the architecture.  */\n+/* { dg-do compile } */\n+/* { dg-require-effective-target lp64 } */\n+/* { dg-options \"-O2 -march=k8\" } */\n+\n+extern void exit (int);\n+extern void abort (void);\n+\n+#define SSE4A_ATTR __attribute__((__option__(\"arch=amdfam10\")))\n+#define SSE42_ATTR __attribute__((__option__(\"sse4.2\")))\n+\n+static int sse4a_pop_i (int a) SSE4A_ATTR;\n+static long sse42_pop_l (long a) SSE42_ATTR;\n+static int generic_pop_i (int a);\n+static long generic_pop_l (long a);\n+\n+static\n+int sse4a_pop_i (int a)\n+{\n+  return __builtin_popcount (a);\n+}\n+\n+static\n+long sse42_pop_l (long a)\n+{\n+  return __builtin_popcountl (a);\n+}\n+\n+static\n+int generic_pop_i (int a)\n+{\n+  return __builtin_popcount (a);\n+}\n+\n+static\n+long generic_pop_l (long a)\n+{\n+  return __builtin_popcountl (a);\n+}\n+\n+int five = 5;\n+long seven = 7;\n+\n+int main ()\n+{\n+  if (sse4a_pop_i (five) != 2)\n+    abort ();\n+\n+  if (sse42_pop_l (seven) != 3L)\n+    abort ();\n+\n+  if (generic_pop_i (five) != 2)\n+    abort ();\n+\n+  if (generic_pop_l (seven) != 3L)\n+    abort ();\n+\n+  exit (0);\n+}\n+\n+/* { dg-final { scan-assembler \"popcntl\" } } */\n+/* { dg-final { scan-assembler \"popcntq\" } } */\n+/* { dg-final { scan-assembler \"call\\t(.*)sse4a_pop_i\" } } */\n+/* { dg-final { scan-assembler \"call\\t(.*)sse42_pop_l\" } } */\n+/* { dg-final { scan-assembler \"call\\t(.*)popcountdi2\" } } */"}, {"sha": "71251c314bb62614d28ceb861513ba3eecb2d813", "filename": "gcc/testsuite/gcc.target/i386/funcspec-4.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffuncspec-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffuncspec-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffuncspec-4.c?ref=ab442df7fb453434d80a779844fe1a10c0c802ab", "patch": "@@ -0,0 +1,14 @@\n+/* Test some error conditions with function specific options.  */\n+/* { dg-do compile } */\n+\n+/* no sse500 switch */\n+extern void error1 (void) __attribute__((__option__(\"sse500\"))); /* { dg-error \"unknown\" } */\n+\n+/* Multiple arch switches */\n+extern void error2 (void) __attribute__((__option__(\"arch=core2,arch=k8\"))); /* { dg-error \"already specified\" } */\n+\n+/* Unknown tune target */\n+extern void error3 (void) __attribute__((__option__(\"tune=foobar\"))); /* { dg-error \"bad value\" } */\n+\n+/* option on a variable */\n+extern int error4 __attribute__((__option__(\"sse2\"))); /* { dg-warning \"ignored\" } */"}, {"sha": "d4204bb141184e73f32d7f476cd8d41d34c920a3", "filename": "gcc/testsuite/gcc.target/i386/funcspec-5.c", "status": "added", "additions": 125, "deletions": 0, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffuncspec-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffuncspec-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffuncspec-5.c?ref=ab442df7fb453434d80a779844fe1a10c0c802ab", "patch": "@@ -0,0 +1,125 @@\n+/* Test whether all of the 32-bit function specific options are accepted\n+   without error.  */\n+/* { dg-do compile } */\n+/* { dg-require-effective-target ilp32 } */\n+\n+extern void test_abm (void)\t\t\t__attribute__((__option__(\"abm\")));\n+extern void test_aes (void)\t\t\t__attribute__((__option__(\"aes\")));\n+extern void test_fused_madd (void)\t\t__attribute__((__option__(\"fused-madd\")));\n+extern void test_mmx (void)\t\t\t__attribute__((__option__(\"mmx\")));\n+extern void test_pclmul (void)\t\t\t__attribute__((__option__(\"pclmul\")));\n+extern void test_popcnt (void)\t\t\t__attribute__((__option__(\"popcnt\")));\n+extern void test_recip (void)\t\t\t__attribute__((__option__(\"recip\")));\n+extern void test_sse (void)\t\t\t__attribute__((__option__(\"sse\")));\n+extern void test_sse2 (void)\t\t\t__attribute__((__option__(\"sse2\")));\n+extern void test_sse3 (void)\t\t\t__attribute__((__option__(\"sse3\")));\n+extern void test_sse4 (void)\t\t\t__attribute__((__option__(\"sse4\")));\n+extern void test_sse4_1 (void)\t\t\t__attribute__((__option__(\"sse4.1\")));\n+extern void test_sse4_2 (void)\t\t\t__attribute__((__option__(\"sse4.2\")));\n+extern void test_sse4a (void)\t\t\t__attribute__((__option__(\"sse4a\")));\n+extern void test_sse5 (void)\t\t\t__attribute__((__option__(\"sse5\")));\n+extern void test_ssse3 (void)\t\t\t__attribute__((__option__(\"ssse3\")));\n+\n+extern void test_no_abm (void)\t\t\t__attribute__((__option__(\"no-abm\")));\n+extern void test_no_aes (void)\t\t\t__attribute__((__option__(\"no-aes\")));\n+extern void test_no_fused_madd (void)\t\t__attribute__((__option__(\"no-fused-madd\")));\n+extern void test_no_mmx (void)\t\t\t__attribute__((__option__(\"no-mmx\")));\n+extern void test_no_pclmul (void)\t\t__attribute__((__option__(\"no-pclmul\")));\n+extern void test_no_popcnt (void)\t\t__attribute__((__option__(\"no-popcnt\")));\n+extern void test_no_recip (void)\t\t__attribute__((__option__(\"no-recip\")));\n+extern void test_no_sse (void)\t\t\t__attribute__((__option__(\"no-sse\")));\n+extern void test_no_sse2 (void)\t\t\t__attribute__((__option__(\"no-sse2\")));\n+extern void test_no_sse3 (void)\t\t\t__attribute__((__option__(\"no-sse3\")));\n+extern void test_no_sse4 (void)\t\t\t__attribute__((__option__(\"no-sse4\")));\n+extern void test_no_sse4_1 (void)\t\t__attribute__((__option__(\"no-sse4.1\")));\n+extern void test_no_sse4_2 (void)\t\t__attribute__((__option__(\"no-sse4.2\")));\n+extern void test_no_sse4a (void)\t\t__attribute__((__option__(\"no-sse4a\")));\n+extern void test_no_sse5 (void)\t\t\t__attribute__((__option__(\"no-sse5\")));\n+extern void test_no_ssse3 (void)\t\t__attribute__((__option__(\"no-ssse3\")));\n+\n+extern void test_arch_i386 (void)\t\t__attribute__((__option__(\"arch=i386\")));\n+extern void test_arch_i486 (void)\t\t__attribute__((__option__(\"arch=i486\")));\n+extern void test_arch_i586 (void)\t\t__attribute__((__option__(\"arch=i586\")));\n+extern void test_arch_pentium (void)\t\t__attribute__((__option__(\"arch=pentium\")));\n+extern void test_arch_pentium_mmx (void)\t__attribute__((__option__(\"arch=pentium-mmx\")));\n+extern void test_arch_winchip_c6 (void)\t\t__attribute__((__option__(\"arch=winchip-c6\")));\n+extern void test_arch_winchip2 (void)\t\t__attribute__((__option__(\"arch=winchip2\")));\n+extern void test_arch_c3 (void)\t\t\t__attribute__((__option__(\"arch=c3\")));\n+extern void test_arch_c3_2 (void)\t\t__attribute__((__option__(\"arch=c3-2\")));\n+extern void test_arch_i686 (void)\t\t__attribute__((__option__(\"arch=i686\")));\n+extern void test_arch_pentiumpro (void)\t\t__attribute__((__option__(\"arch=pentiumpro\")));\n+extern void test_arch_pentium2 (void)\t\t__attribute__((__option__(\"arch=pentium2\")));\n+extern void test_arch_pentium3 (void)\t\t__attribute__((__option__(\"arch=pentium3\")));\n+extern void test_arch_pentium3m (void)\t\t__attribute__((__option__(\"arch=pentium3m\")));\n+extern void test_arch_pentium_m (void)\t\t__attribute__((__option__(\"arch=pentium-m\")));\n+extern void test_arch_pentium4 (void)\t\t__attribute__((__option__(\"arch=pentium4\")));\n+extern void test_arch_pentium4m (void)\t\t__attribute__((__option__(\"arch=pentium4m\")));\n+extern void test_arch_prescott (void)\t\t__attribute__((__option__(\"arch=prescott\")));\n+extern void test_arch_nocona (void)\t\t__attribute__((__option__(\"arch=nocona\")));\n+extern void test_arch_core2 (void)\t\t__attribute__((__option__(\"arch=core2\")));\n+extern void test_arch_geode (void)\t\t__attribute__((__option__(\"arch=geode\")));\n+extern void test_arch_k6 (void)\t\t\t__attribute__((__option__(\"arch=k6\")));\n+extern void test_arch_k6_2 (void)\t\t__attribute__((__option__(\"arch=k6-2\")));\n+extern void test_arch_k6_3 (void)\t\t__attribute__((__option__(\"arch=k6-3\")));\n+extern void test_arch_athlon (void)\t\t__attribute__((__option__(\"arch=athlon\")));\n+extern void test_arch_athlon_tbird (void)\t__attribute__((__option__(\"arch=athlon-tbird\")));\n+extern void test_arch_athlon_4 (void)\t\t__attribute__((__option__(\"arch=athlon-4\")));\n+extern void test_arch_athlon_xp (void)\t\t__attribute__((__option__(\"arch=athlon-xp\")));\n+extern void test_arch_athlon_mp (void)\t\t__attribute__((__option__(\"arch=athlon-mp\")));\n+extern void test_arch_k8 (void)\t\t\t__attribute__((__option__(\"arch=k8\")));\n+extern void test_arch_k8_sse3 (void)\t\t__attribute__((__option__(\"arch=k8-sse3\")));\n+extern void test_arch_opteron (void)\t\t__attribute__((__option__(\"arch=opteron\")));\n+extern void test_arch_opteron_sse3 (void)\t__attribute__((__option__(\"arch=opteron-sse3\")));\n+extern void test_arch_athlon64 (void)\t\t__attribute__((__option__(\"arch=athlon64\")));\n+extern void test_arch_athlon64_sse3 (void)\t__attribute__((__option__(\"arch=athlon64-sse3\")));\n+extern void test_arch_athlon_fx (void)\t\t__attribute__((__option__(\"arch=athlon-fx\")));\n+extern void test_arch_amdfam10 (void)\t\t__attribute__((__option__(\"arch=amdfam10\")));\n+extern void test_arch_barcelona (void)\t\t__attribute__((__option__(\"arch=barcelona\")));\n+extern void test_arch_foo (void)\t\t__attribute__((__option__(\"arch=foo\"))); /* { dg-error \"bad value\" } */\n+\n+extern void test_tune_i386 (void)\t\t__attribute__((__option__(\"tune=i386\")));\n+extern void test_tune_i486 (void)\t\t__attribute__((__option__(\"tune=i486\")));\n+extern void test_tune_i586 (void)\t\t__attribute__((__option__(\"tune=i586\")));\n+extern void test_tune_pentium (void)\t\t__attribute__((__option__(\"tune=pentium\")));\n+extern void test_tune_pentium_mmx (void)\t__attribute__((__option__(\"tune=pentium-mmx\")));\n+extern void test_tune_winchip_c6 (void)\t\t__attribute__((__option__(\"tune=winchip-c6\")));\n+extern void test_tune_winchip2 (void)\t\t__attribute__((__option__(\"tune=winchip2\")));\n+extern void test_tune_c3 (void)\t\t\t__attribute__((__option__(\"tune=c3\")));\n+extern void test_tune_c3_2 (void)\t\t__attribute__((__option__(\"tune=c3-2\")));\n+extern void test_tune_i686 (void)\t\t__attribute__((__option__(\"tune=i686\")));\n+extern void test_tune_pentiumpro (void)\t\t__attribute__((__option__(\"tune=pentiumpro\")));\n+extern void test_tune_pentium2 (void)\t\t__attribute__((__option__(\"tune=pentium2\")));\n+extern void test_tune_pentium3 (void)\t\t__attribute__((__option__(\"tune=pentium3\")));\n+extern void test_tune_pentium3m (void)\t\t__attribute__((__option__(\"tune=pentium3m\")));\n+extern void test_tune_pentium_m (void)\t\t__attribute__((__option__(\"tune=pentium-m\")));\n+extern void test_tune_pentium4 (void)\t\t__attribute__((__option__(\"tune=pentium4\")));\n+extern void test_tune_pentium4m (void)\t\t__attribute__((__option__(\"tune=pentium4m\")));\n+extern void test_tune_prescott (void)\t\t__attribute__((__option__(\"tune=prescott\")));\n+extern void test_tune_nocona (void)\t\t__attribute__((__option__(\"tune=nocona\")));\n+extern void test_tune_core2 (void)\t\t__attribute__((__option__(\"tune=core2\")));\n+extern void test_tune_geode (void)\t\t__attribute__((__option__(\"tune=geode\")));\n+extern void test_tune_k6 (void)\t\t\t__attribute__((__option__(\"tune=k6\")));\n+extern void test_tune_k6_2 (void)\t\t__attribute__((__option__(\"tune=k6-2\")));\n+extern void test_tune_k6_3 (void)\t\t__attribute__((__option__(\"tune=k6-3\")));\n+extern void test_tune_athlon (void)\t\t__attribute__((__option__(\"tune=athlon\")));\n+extern void test_tune_athlon_tbird (void)\t__attribute__((__option__(\"tune=athlon-tbird\")));\n+extern void test_tune_athlon_4 (void)\t\t__attribute__((__option__(\"tune=athlon-4\")));\n+extern void test_tune_athlon_xp (void)\t\t__attribute__((__option__(\"tune=athlon-xp\")));\n+extern void test_tune_athlon_mp (void)\t\t__attribute__((__option__(\"tune=athlon-mp\")));\n+extern void test_tune_k8 (void)\t\t\t__attribute__((__option__(\"tune=k8\")));\n+extern void test_tune_k8_sse3 (void)\t\t__attribute__((__option__(\"tune=k8-sse3\")));\n+extern void test_tune_opteron (void)\t\t__attribute__((__option__(\"tune=opteron\")));\n+extern void test_tune_opteron_sse3 (void)\t__attribute__((__option__(\"tune=opteron-sse3\")));\n+extern void test_tune_athlon64 (void)\t\t__attribute__((__option__(\"tune=athlon64\")));\n+extern void test_tune_athlon64_sse3 (void)\t__attribute__((__option__(\"tune=athlon64-sse3\")));\n+extern void test_tune_athlon_fx (void)\t\t__attribute__((__option__(\"tune=athlon-fx\")));\n+extern void test_tune_amdfam10 (void)\t\t__attribute__((__option__(\"tune=amdfam10\")));\n+extern void test_tune_barcelona (void)\t\t__attribute__((__option__(\"tune=barcelona\")));\n+extern void test_tune_generic (void)\t\t__attribute__((__option__(\"tune=generic\")));\n+extern void test_tune_foo (void)\t\t__attribute__((__option__(\"tune=foo\"))); /* { dg-error \"bad value\" } */\n+\n+extern void test_fpmath_sse (void)\t\t__attribute__((__option__(\"sse2,fpmath=sse\")));\n+extern void test_fpmath_387 (void)\t\t__attribute__((__option__(\"sse2,fpmath=387\")));\n+extern void test_fpmath_sse_387 (void)\t\t__attribute__((__option__(\"sse2,fpmath=sse+387\")));\n+extern void test_fpmath_387_sse (void)\t\t__attribute__((__option__(\"sse2,fpmath=387+sse\")));\n+extern void test_fpmath_both (void)\t\t__attribute__((__option__(\"sse2,fpmath=both\")));"}, {"sha": "0c915975894c46a4c2ab3bccdb4a26f9fe723e42", "filename": "gcc/testsuite/gcc.target/i386/funcspec-6.c", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffuncspec-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffuncspec-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffuncspec-6.c?ref=ab442df7fb453434d80a779844fe1a10c0c802ab", "patch": "@@ -0,0 +1,71 @@\n+/* Test whether all of the 64-bit function specific options are accepted\n+   without error.  */\n+/* { dg-do compile } */\n+/* { dg-require-effective-target lp64 } */\n+\n+extern void test_abm (void)\t\t\t__attribute__((__option__(\"abm\")));\n+extern void test_aes (void)\t\t\t__attribute__((__option__(\"aes\")));\n+extern void test_fused_madd (void)\t\t__attribute__((__option__(\"fused-madd\")));\n+extern void test_mmx (void)\t\t\t__attribute__((__option__(\"mmx\")));\n+extern void test_pclmul (void)\t\t\t__attribute__((__option__(\"pclmul\")));\n+extern void test_popcnt (void)\t\t\t__attribute__((__option__(\"popcnt\")));\n+extern void test_recip (void)\t\t\t__attribute__((__option__(\"recip\")));\n+extern void test_sse (void)\t\t\t__attribute__((__option__(\"sse\")));\n+extern void test_sse2 (void)\t\t\t__attribute__((__option__(\"sse2\")));\n+extern void test_sse3 (void)\t\t\t__attribute__((__option__(\"sse3\")));\n+extern void test_sse4 (void)\t\t\t__attribute__((__option__(\"sse4\")));\n+extern void test_sse4_1 (void)\t\t\t__attribute__((__option__(\"sse4.1\")));\n+extern void test_sse4_2 (void)\t\t\t__attribute__((__option__(\"sse4.2\")));\n+extern void test_sse4a (void)\t\t\t__attribute__((__option__(\"sse4a\")));\n+extern void test_sse5 (void)\t\t\t__attribute__((__option__(\"sse5\")));\n+extern void test_ssse3 (void)\t\t\t__attribute__((__option__(\"ssse3\")));\n+\n+extern void test_no_abm (void)\t\t\t__attribute__((__option__(\"no-abm\")));\n+extern void test_no_aes (void)\t\t\t__attribute__((__option__(\"no-aes\")));\n+extern void test_no_fused_madd (void)\t\t__attribute__((__option__(\"no-fused-madd\")));\n+extern void test_no_mmx (void)\t\t\t__attribute__((__option__(\"no-mmx\")));\n+extern void test_no_pclmul (void)\t\t__attribute__((__option__(\"no-pclmul\")));\n+extern void test_no_popcnt (void)\t\t__attribute__((__option__(\"no-popcnt\")));\n+extern void test_no_recip (void)\t\t__attribute__((__option__(\"no-recip\")));\n+extern void test_no_sse (void)\t\t\t__attribute__((__option__(\"no-sse\")));\n+extern void test_no_sse2 (void)\t\t\t__attribute__((__option__(\"no-sse2\")));\n+extern void test_no_sse3 (void)\t\t\t__attribute__((__option__(\"no-sse3\")));\n+extern void test_no_sse4 (void)\t\t\t__attribute__((__option__(\"no-sse4\")));\n+extern void test_no_sse4_1 (void)\t\t__attribute__((__option__(\"no-sse4.1\")));\n+extern void test_no_sse4_2 (void)\t\t__attribute__((__option__(\"no-sse4.2\")));\n+extern void test_no_sse4a (void)\t\t__attribute__((__option__(\"no-sse4a\")));\n+extern void test_no_sse5 (void)\t\t\t__attribute__((__option__(\"no-sse5\")));\n+extern void test_no_ssse3 (void)\t\t__attribute__((__option__(\"no-ssse3\")));\n+\n+extern void test_arch_nocona (void)\t\t__attribute__((__option__(\"arch=nocona\")));\n+extern void test_arch_core2 (void)\t\t__attribute__((__option__(\"arch=core2\")));\n+extern void test_arch_k8 (void)\t\t\t__attribute__((__option__(\"arch=k8\")));\n+extern void test_arch_k8_sse3 (void)\t\t__attribute__((__option__(\"arch=k8-sse3\")));\n+extern void test_arch_opteron (void)\t\t__attribute__((__option__(\"arch=opteron\")));\n+extern void test_arch_opteron_sse3 (void)\t__attribute__((__option__(\"arch=opteron-sse3\")));\n+extern void test_arch_athlon64 (void)\t\t__attribute__((__option__(\"arch=athlon64\")));\n+extern void test_arch_athlon64_sse3 (void)\t__attribute__((__option__(\"arch=athlon64-sse3\")));\n+extern void test_arch_athlon_fx (void)\t\t__attribute__((__option__(\"arch=athlon-fx\")));\n+extern void test_arch_amdfam10 (void)\t\t__attribute__((__option__(\"arch=amdfam10\")));\n+extern void test_arch_barcelona (void)\t\t__attribute__((__option__(\"arch=barcelona\")));\n+extern void test_arch_foo (void)\t\t__attribute__((__option__(\"arch=foo\"))); /* { dg-error \"bad value\" } */\n+\n+extern void test_tune_nocona (void)\t\t__attribute__((__option__(\"tune=nocona\")));\n+extern void test_tune_core2 (void)\t\t__attribute__((__option__(\"tune=core2\")));\n+extern void test_tune_k8 (void)\t\t\t__attribute__((__option__(\"tune=k8\")));\n+extern void test_tune_k8_sse3 (void)\t\t__attribute__((__option__(\"tune=k8-sse3\")));\n+extern void test_tune_opteron (void)\t\t__attribute__((__option__(\"tune=opteron\")));\n+extern void test_tune_opteron_sse3 (void)\t__attribute__((__option__(\"tune=opteron-sse3\")));\n+extern void test_tune_athlon64 (void)\t\t__attribute__((__option__(\"tune=athlon64\")));\n+extern void test_tune_athlon64_sse3 (void)\t__attribute__((__option__(\"tune=athlon64-sse3\")));\n+extern void test_tune_athlon_fx (void)\t\t__attribute__((__option__(\"tune=athlon-fx\")));\n+extern void test_tune_amdfam10 (void)\t\t__attribute__((__option__(\"tune=amdfam10\")));\n+extern void test_tune_barcelona (void)\t\t__attribute__((__option__(\"tune=barcelona\")));\n+extern void test_tune_generic (void)\t\t__attribute__((__option__(\"tune=generic\")));\n+extern void test_tune_foo (void)\t\t__attribute__((__option__(\"tune=foo\"))); /* { dg-error \"bad value\" } */\n+\n+extern void test_fpmath_sse (void)\t\t__attribute__((__option__(\"sse2,fpmath=sse\")));\n+extern void test_fpmath_387 (void)\t\t__attribute__((__option__(\"sse2,fpmath=387\")));\n+extern void test_fpmath_sse_387 (void)\t\t__attribute__((__option__(\"sse2,fpmath=sse+387\")));\n+extern void test_fpmath_387_sse (void)\t\t__attribute__((__option__(\"sse2,fpmath=387+sse\")));\n+extern void test_fpmath_both (void)\t\t__attribute__((__option__(\"sse2,fpmath=both\")));"}, {"sha": "a65ae2519786b0b3c3cce088198c50b31e1725f5", "filename": "gcc/testsuite/gcc.target/i386/funcspec-7.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffuncspec-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffuncspec-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffuncspec-7.c?ref=ab442df7fb453434d80a779844fe1a10c0c802ab", "patch": "@@ -0,0 +1,13 @@\n+/* Test whether using target specific options, we can generate the reciprocal\n+   square root instruction.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -march=k8 -mno-recip -mfpmath=sse -ffast-math\" } */\n+\n+float do_recip  (float a) __attribute__((__option__(\"recip\")));\n+float do_normal (float a);\n+\n+float do_recip  (float a) { return 1.0f / __builtin_sqrtf (a); }\n+float do_normal (float a) { return 1.0f / __builtin_sqrtf (a); }\n+\n+/* { dg-final { scan-assembler \"sqrtss\" } } */\n+/* { dg-final { scan-assembler \"rsqrtss\" } } */"}, {"sha": "115f60866a2dddb02a7cd29d706b2a5f902ca0a3", "filename": "gcc/testsuite/gcc.target/i386/funcspec-8.c", "status": "added", "additions": 161, "deletions": 0, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffuncspec-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffuncspec-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffuncspec-8.c?ref=ab442df7fb453434d80a779844fe1a10c0c802ab", "patch": "@@ -0,0 +1,161 @@\n+/* Test whether using target specific options, we can use the x86 builtin\n+   functions in functions with the appropriate function specific options.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -march=k8 -mfpmath=sse\" } */\n+\n+typedef float     __m128  __attribute__ ((__vector_size__ (16), __may_alias__));\n+typedef double    __m128d __attribute__ ((__vector_size__ (16), __may_alias__));\n+typedef int\t  __m128w __attribute__ ((__vector_size__ (16), __may_alias__));\n+typedef long long __m128i __attribute__ ((__vector_size__ (16), __may_alias__));\n+\n+#ifdef __SSE3__\n+#error \"-msse3 should not be set for this test\"\n+#endif\n+\n+__m128d sse3_hsubpd (__m128d a, __m128d b) __attribute__((__option__(\"sse3\")));\n+__m128d generic_hsubpd (__m128d a, __m128d b);\n+\n+__m128d\n+sse3_hsubpd (__m128d a, __m128d b)\n+{\n+  return __builtin_ia32_hsubpd (a, b);\n+}\n+\n+__m128d\n+generic_hsubpd (__m128d a, __m128d b)\n+{\n+  return __builtin_ia32_hsubpd (a, b);\t\t\t/* { dg-error \"needs isa option\" } */\n+}\n+\n+#ifdef __SSSE3__\n+#error \"-mssse3 should not be set for this test\"\n+#endif\n+\n+__m128w ssse3_psignd128 (__m128w a, __m128w b) __attribute__((__option__(\"ssse3\")));\n+__m128w generic_psignd (__m128w ab, __m128w b);\n+\n+__m128w\n+ssse3_psignd128 (__m128w a, __m128w b)\n+{\n+  return __builtin_ia32_psignd128 (a, b);\n+}\n+\n+__m128w\n+generic_psignd128 (__m128w a, __m128w b)\n+{\n+  return __builtin_ia32_psignd128 (a, b);\t\t/* { dg-error \"needs isa option\" } */\n+}\n+\n+#ifdef __SSE4_1__\n+#error \"-msse4.1 should not be set for this test\"\n+#endif\n+\n+__m128d sse4_1_blendvpd (__m128d a, __m128d b, __m128d c) __attribute__((__option__(\"sse4.1\")));\n+__m128d generic_blendvpd (__m128d a, __m128d b, __m128d c);\n+\n+__m128d\n+sse4_1_blendvpd  (__m128d a, __m128d b, __m128d c)\n+{\n+  return __builtin_ia32_blendvpd (a, b, c);\n+}\n+\n+__m128d\n+generic_blendvpd  (__m128d a, __m128d b, __m128d c)\n+{\n+  return __builtin_ia32_blendvpd (a, b, c);\t\t/* { dg-error \"needs isa option\" } */\n+}\n+\n+#ifdef __SSE4_2__\n+#error \"-msse4.2 should not be set for this test\"\n+#endif\n+\n+__m128i sse4_2_pcmpgtq (__m128i a, __m128i b) __attribute__((__option__(\"sse4.2\")));\n+__m128i generic_pcmpgtq (__m128i ab, __m128i b);\n+\n+__m128i\n+sse4_2_pcmpgtq (__m128i a, __m128i b)\n+{\n+  return __builtin_ia32_pcmpgtq (a, b);\n+}\n+\n+__m128i\n+generic_pcmpgtq (__m128i a, __m128i b)\n+{\n+  return __builtin_ia32_pcmpgtq (a, b);\t\t\t/* { dg-error \"needs isa option\" } */\n+}\n+\n+#ifdef __SSE4A__\n+#error \"-msse4a should not be set for this test\"\n+#endif\n+\n+__m128i sse4_2_insertq (__m128i a, __m128i b) __attribute__((__option__(\"sse4a\")));\n+__m128i generic_insertq (__m128i ab, __m128i b);\n+\n+__m128i\n+sse4_2_insertq (__m128i a, __m128i b)\n+{\n+  return __builtin_ia32_insertq (a, b);\n+}\n+\n+__m128i\n+generic_insertq (__m128i a, __m128i b)\n+{\n+  return __builtin_ia32_insertq (a, b);\t\t\t/* { dg-error \"needs isa option\" } */\n+}\n+\n+#ifdef __SSE5__\n+#error \"-msse5 should not be set for this test\"\n+#endif\n+\n+__m128d sse5_fmaddpd (__m128d a, __m128d b, __m128d c) __attribute__((__option__(\"sse5\")));\n+__m128d generic_fmaddpd (__m128d a, __m128d b, __m128d c);\n+\n+__m128d\n+sse5_fmaddpd  (__m128d a, __m128d b, __m128d c)\n+{\n+  return __builtin_ia32_fmaddpd (a, b, c);\n+}\n+\n+__m128d\n+generic_fmaddpd  (__m128d a, __m128d b, __m128d c)\n+{\n+  return __builtin_ia32_fmaddpd (a, b, c);\t\t/* { dg-error \"needs isa option\" } */\n+}\n+\n+#ifdef __AES__\n+#error \"-maes should not be set for this test\"\n+#endif\n+\n+__m128i aes_aesimc128 (__m128i a) __attribute__((__option__(\"aes\")));\n+__m128i generic_aesimc128 (__m128i a);\n+\n+__m128i\n+aes_aesimc128 (__m128i a)\n+{\n+  return __builtin_ia32_aesimc128 (a);\n+}\n+\n+__m128i\n+generic_aesimc128 (__m128i a)\n+{\n+  return __builtin_ia32_aesimc128 (a);\t\t\t/* { dg-error \"needs isa option\" } */\n+}\n+\n+#ifdef __PCLMUL__\n+#error \"-mpclmul should not be set for this test\"\n+#endif\n+\n+__m128i pclmul_pclmulqdq128 (__m128i a, __m128i b) __attribute__((__option__(\"pclmul\")));\n+__m128i generic_pclmulqdq128 (__m128i a, __m128i b);\n+\n+__m128i\n+pclmul_pclmulqdq128 (__m128i a, __m128i b)\n+{\n+  return __builtin_ia32_pclmulqdq128 (a, b, 5);\n+}\n+\n+__m128i\n+generic_pclmulqdq128 (__m128i a, __m128i b)\n+{\n+  return __builtin_ia32_pclmulqdq128 (a, b, 5);\t\t/* { dg-error \"needs isa option\" } */\n+}"}, {"sha": "e6d190131015b6136ee954cc56ba4e3c8c254e29", "filename": "gcc/testsuite/gcc.target/i386/funcspec-9.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffuncspec-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffuncspec-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffuncspec-9.c?ref=ab442df7fb453434d80a779844fe1a10c0c802ab", "patch": "@@ -0,0 +1,36 @@\n+/* Test whether using target specific options, we can generate SSE5 code.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -march=k8 -mfpmath=sse -msse2\" } */\n+\n+extern void exit (int);\n+\n+#ifdef __SSE5__\n+#warning \"__SSE5__ should not be defined before #pragma GCC option.\"\n+#endif\n+\n+#pragma GCC option (push)\n+#pragma GCC option (\"sse5,fused-madd\")\n+\n+#ifndef __SSE5__\n+#warning \"__SSE5__ should have be defined after #pragma GCC option.\"\n+#endif\n+\n+float\n+flt_mul_add (float a, float b, float c)\n+{\n+  return (a * b) + c;\n+}\n+\n+#pragma GCC option (pop)\n+#ifdef __SSE5__\n+#warning \"__SSE5__ should not be defined after #pragma GCC pop option.\"\n+#endif\n+\n+double\n+dbl_mul_add (double a, double b, double c)\n+{\n+  return (a * b) + c;\n+}\n+\n+/* { dg-final { scan-assembler \"fmaddss\" } } */\n+/* { dg-final { scan-assembler \"addsd\" } } */"}, {"sha": "608f52fd6eb9c8cd6e19b5d1edc58186b34f0c5b", "filename": "gcc/testsuite/gcc.target/i386/hot-1.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fhot-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fhot-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fhot-1.c?ref=ab442df7fb453434d80a779844fe1a10c0c802ab", "patch": "@@ -0,0 +1,33 @@\n+/* Test whether using attribute((hot)) really turns on -O3.  Do this test\n+   by checking whether we vectorize a simple loop.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O1 -msse2 -mfpmath=sse -march=k8\" } */\n+/* { dg-final { scan-assembler \"addps\" } } */\n+/* { dg-final { scan-assembler \"subss\" } } */\n+\n+#define SIZE 1024\n+float a[SIZE] __attribute__((__aligned__(32)));\n+float b[SIZE] __attribute__((__aligned__(32)));\n+float c[SIZE] __attribute__((__aligned__(32)));\n+\n+/* This should vectorize.  */\n+void hot (void) __attribute__((__hot__));\n+\n+void\n+hot (void)\n+{\n+  int i;\n+\n+  for (i = 0; i < SIZE; i++)\n+    a[i] = b[i] + c[i];\n+}\n+\n+/* This should not vectorize.  */\n+void\n+not_hot (void)\n+{\n+  int i;\n+\n+  for (i = 0; i < SIZE; i++)\n+    a[i] = b[i] - c[i];\n+}"}, {"sha": "28e2ef38c348e42bb7fe665843bc47aba68885f5", "filename": "gcc/testsuite/gcc.target/i386/opt-1.c", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fopt-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fopt-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fopt-1.c?ref=ab442df7fb453434d80a779844fe1a10c0c802ab", "patch": "@@ -0,0 +1,35 @@\n+/* Test the attribute((optimize)) really works.  Do this test by checking\n+   whether we vectorize a simple loop.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O1 -msse2 -mfpmath=sse -march=k8\" } */\n+/* { dg-final { scan-assembler \"prefetcht0\" } } */\n+/* { dg-final { scan-assembler \"addps\" } } */\n+/* { dg-final { scan-assembler \"subss\" } } */\n+\n+#define SIZE 10240\n+float a[SIZE] __attribute__((__aligned__(32)));\n+float b[SIZE] __attribute__((__aligned__(32)));\n+float c[SIZE] __attribute__((__aligned__(32)));\n+\n+/* This should vectorize.  */\n+void opt3 (void) __attribute__((__optimize__(3,\"unroll-all-loops,-fprefetch-loop-arrays\")));\n+\n+void\n+opt3 (void)\n+{\n+  int i;\n+\n+  for (i = 0; i < SIZE; i++)\n+    a[i] = b[i] + c[i];\n+}\n+\n+/* This should not vectorize.  */\n+void\n+not_opt3 (void)\n+{\n+  int i;\n+\n+  for (i = 0; i < SIZE; i++)\n+    a[i] = b[i] - c[i];\n+}\n+"}, {"sha": "8d6ba6fe925dea06bc98434a5d28856dfc9c18af", "filename": "gcc/testsuite/gcc.target/i386/opt-2.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fopt-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fopt-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fopt-2.c?ref=ab442df7fb453434d80a779844fe1a10c0c802ab", "patch": "@@ -0,0 +1,38 @@\n+/* Test the attribute((optimize)) really works.  Do this test by checking\n+   whether we vectorize a simple loop.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O1 -msse2 -mfpmath=sse -march=k8\" } */\n+/* { dg-final { scan-assembler \"prefetcht0\" } } */\n+/* { dg-final { scan-assembler \"addps\" } } */\n+/* { dg-final { scan-assembler \"subss\" } } */\n+\n+#define SIZE 10240\n+float a[SIZE] __attribute__((__aligned__(32)));\n+float b[SIZE] __attribute__((__aligned__(32)));\n+float c[SIZE] __attribute__((__aligned__(32)));\n+\n+/* This should vectorize.  */\n+#pragma GCC optimize push\n+#pragma GCC optimize (3, \"unroll-all-loops\", \"-fprefetch-loop-arrays\")\n+\n+void\n+opt3 (void)\n+{\n+  int i;\n+\n+  for (i = 0; i < SIZE; i++)\n+    a[i] = b[i] + c[i];\n+}\n+\n+#pragma GCC optimize pop\n+\n+/* This should not vectorize.  */\n+void\n+not_opt3 (void)\n+{\n+  int i;\n+\n+  for (i = 0; i < SIZE; i++)\n+    a[i] = b[i] - c[i];\n+}\n+"}, {"sha": "a9b10333157db5fb700180c12d575305b304b7c6", "filename": "gcc/testsuite/gcc.target/i386/sse-22.c", "status": "added", "additions": 171, "deletions": 0, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse-22.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse-22.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse-22.c?ref=ab442df7fb453434d80a779844fe1a10c0c802ab", "patch": "@@ -0,0 +1,171 @@\n+/* Same as sse-14, except converted to use #pragma GCC option.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O0 -Werror-implicit-function-declaration\" } */\n+\n+#include <mm_malloc.h>\n+\n+/* Test that the intrinsics compile without optimization.  All of them are\n+   defined as inline functions in {,x,e,p,t,s,w,a,b}mmintrin.h  and mm3dnow.h\n+   that reference the proper builtin functions.  Defining away \"extern\" and\n+   \"__inline\" results in all of them being compiled as proper functions.  */\n+\n+#define extern\n+#define __inline\n+\n+#define _CONCAT(x,y) x ## y\n+\n+#define test_1(func, type, op1_type, imm)\t\t\t\t\\\n+  type _CONCAT(_,func) (op1_type A, int const I)\t\t\t\\\n+  { return func (A, imm); }\n+\n+#define test_1x(func, type, op1_type, imm1, imm2)\t\t\t\\\n+  type _CONCAT(_,func) (op1_type A, int const I, int const L)\t\t\\\n+  { return func (A, imm1, imm2); }\n+\n+#define test_2(func, type, op1_type, op2_type, imm)\t\t\t\\\n+  type _CONCAT(_,func) (op1_type A, op2_type B, int const I)\t\t\\\n+  { return func (A, B, imm); }\n+\n+#define test_2x(func, type, op1_type, op2_type, imm1, imm2)\t\t\\\n+  type _CONCAT(_,func) (op1_type A, op2_type B, int const I, int const L) \\\n+  { return func (A, B, imm1, imm2); }\n+\n+#define test_4(func, type, op1_type, op2_type, op3_type, op4_type, imm)\t\\\n+  type _CONCAT(_,func) (op1_type A, op2_type B,\t\t\t\t\\\n+\t\t\top3_type C, op4_type D, int const I)\t\t\\\n+  { return func (A, B, C, D, imm); }\n+\n+\n+#ifndef DIFFERENT_PRAGMAS\n+#pragma GCC option (\"mmx,3dnow,sse,sse2,sse3,ssse3,sse4.1,sse4.2,sse5,aes,pclmul\")\n+#endif\n+\n+/* Following intrinsics require immediate arguments.  They\n+   are defined as macros for non-optimized compilations. */\n+\n+/* mmintrin.h (MMX).  */\n+#ifdef DIFFERENT_PRAGMAS\n+#pragma GCC option (\"mmx\")\n+#endif\n+#include <mmintrin.h>\n+\n+/* mm3dnow.h (3DNOW).  */\n+#ifdef DIFFERENT_PRAGMAS\n+#pragma GCC option (\"3dnow\")\n+#endif\n+#include <mm3dnow.h>\n+\n+/* xmmintrin.h (SSE).  */\n+#ifdef DIFFERENT_PRAGMAS\n+#pragma GCC option (\"sse\")\n+#endif\n+#include <xmmintrin.h>\n+test_2 (_mm_shuffle_ps, __m128, __m128, __m128, 1)\n+test_1 (_mm_extract_pi16, int, __m64, 1)\n+test_1 (_m_pextrw, int, __m64, 1)\n+test_2 (_mm_insert_pi16, __m64, __m64, int, 1)\n+test_2 (_m_pinsrw, __m64, __m64, int, 1)\n+test_1 (_mm_shuffle_pi16, __m64, __m64, 1)\n+test_1 (_m_pshufw, __m64, __m64, 1)\n+test_1 (_mm_prefetch, void, void *, _MM_HINT_NTA)\n+\n+/* emmintrin.h (SSE2).  */\n+#ifdef DIFFERENT_PRAGMAS\n+#pragma GCC option (\"sse2\")\n+#endif\n+#include <emmintrin.h>\n+test_2 (_mm_shuffle_pd, __m128d, __m128d, __m128d, 1)\n+test_1 (_mm_srli_si128, __m128i, __m128i, 1)\n+test_1 (_mm_slli_si128, __m128i, __m128i, 1)\n+test_1 (_mm_extract_epi16, int, __m128i, 1)\n+test_2 (_mm_insert_epi16, __m128i, __m128i, int, 1)\n+test_1 (_mm_shufflehi_epi16, __m128i, __m128i, 1)\n+test_1 (_mm_shufflelo_epi16, __m128i, __m128i, 1)\n+test_1 (_mm_shuffle_epi32, __m128i, __m128i, 1)\n+\n+/* pmmintrin.h (SSE3).  */\n+#ifdef DIFFERENT_PRAGMAS\n+#pragma GCC option (\"sse3\")\n+#endif\n+#include <pmmintrin.h>\n+\n+/* tmmintrin.h (SSSE3).  */\n+#ifdef DIFFERENT_PRAGMAS\n+#pragma GCC option (\"ssse3\")\n+#endif\n+#include <tmmintrin.h>\n+test_2 (_mm_alignr_epi8, __m128i, __m128i, __m128i, 1)\n+test_2 (_mm_alignr_pi8, __m64, __m64, __m64, 1)\n+\n+/* ammintrin.h (SSE4A).  */\n+#ifdef DIFFERENT_PRAGMAS\n+#pragma GCC option (\"sse4a\")\n+#endif\n+#include <ammintrin.h>\n+test_1x (_mm_extracti_si64, __m128i, __m128i, 1, 1)\n+test_2x (_mm_inserti_si64, __m128i, __m128i, __m128i, 1, 1)\n+\n+/* smmintrin.h (SSE4.1).  */\n+/* nmmintrin.h (SSE4.2).  */\n+/* Note, nmmintrin.h includes smmintrin.h, and smmintrin.h checks for the\n+   #ifdef.  So just set the option to SSE4.2.  */\n+#ifdef DIFFERENT_PRAGMAS\n+#pragma GCC option (\"sse4.2\")\n+#endif\n+#include <nmmintrin.h>\n+test_2 (_mm_blend_epi16, __m128i, __m128i, __m128i, 1)\n+test_2 (_mm_blend_ps, __m128, __m128, __m128, 1)\n+test_2 (_mm_blend_pd, __m128d, __m128d, __m128d, 1)\n+test_2 (_mm_dp_ps, __m128, __m128, __m128, 1)\n+test_2 (_mm_dp_pd, __m128d, __m128d, __m128d, 1)\n+test_2 (_mm_insert_ps, __m128, __m128, __m128, 1)\n+test_1 (_mm_extract_ps, int, __m128, 1)\n+test_2 (_mm_insert_epi8, __m128i, __m128i, int, 1)\n+test_2 (_mm_insert_epi32, __m128i, __m128i, int, 1)\n+#ifdef __x86_64__\n+test_2 (_mm_insert_epi64, __m128i, __m128i, long long, 1)\n+#endif\n+test_1 (_mm_extract_epi8, int, __m128i, 1)\n+test_1 (_mm_extract_epi32, int, __m128i, 1)\n+#ifdef __x86_64__\n+test_1 (_mm_extract_epi64, long long, __m128i, 1)\n+#endif\n+test_2 (_mm_mpsadbw_epu8, __m128i, __m128i, __m128i, 1)\n+test_2 (_mm_cmpistrm, __m128i, __m128i, __m128i, 1)\n+test_2 (_mm_cmpistri, int, __m128i, __m128i, 1)\n+test_4 (_mm_cmpestrm, __m128i, __m128i, int, __m128i, int, 1)\n+test_4 (_mm_cmpestri, int, __m128i, int, __m128i, int, 1)\n+test_2 (_mm_cmpistra, int, __m128i, __m128i, 1)\n+test_2 (_mm_cmpistrc, int, __m128i, __m128i, 1)\n+test_2 (_mm_cmpistro, int, __m128i, __m128i, 1)\n+test_2 (_mm_cmpistrs, int, __m128i, __m128i, 1)\n+test_2 (_mm_cmpistrz, int, __m128i, __m128i, 1)\n+test_4 (_mm_cmpestra, int, __m128i, int, __m128i, int, 1)\n+test_4 (_mm_cmpestrc, int, __m128i, int, __m128i, int, 1)\n+test_4 (_mm_cmpestro, int, __m128i, int, __m128i, int, 1)\n+test_4 (_mm_cmpestrs, int, __m128i, int, __m128i, int, 1)\n+test_4 (_mm_cmpestrz, int, __m128i, int, __m128i, int, 1)\n+\n+/* bmmintrin.h (SSE5).  */\n+#ifdef DIFFERENT_PRAGMAS\n+#pragma GCC option (\"sse5\")\n+#endif\n+#include <bmmintrin.h>\n+test_1 (_mm_roti_epi8, __m128i, __m128i, 1)\n+test_1 (_mm_roti_epi16, __m128i, __m128i, 1)\n+test_1 (_mm_roti_epi32, __m128i, __m128i, 1)\n+test_1 (_mm_roti_epi64, __m128i, __m128i, 1)\n+\n+/* wmmintrin.h (AES/PCLMUL).  */\n+#ifdef DIFFERENT_PRAGMAS\n+#pragma GCC option (\"aes,pclmul\")\n+#endif\n+#include <wmmintrin.h>\n+test_1 (_mm_aeskeygenassist_si128, __m128i, __m128i, 1)\n+test_2 (_mm_clmulepi64_si128, __m128i, __m128i, __m128i, 1)\n+\n+/* mmintrin-common.h */\n+test_1 (_mm_round_pd, __m128d, __m128d, 1)\n+test_1 (_mm_round_ps, __m128, __m128, 1)\n+test_2 (_mm_round_sd, __m128d, __m128d, __m128d, 1)\n+test_2 (_mm_round_ss, __m128, __m128, __m128, 1)"}, {"sha": "27b601452a5a5f6e2eadc0cee8a4a5d9c24e4359", "filename": "gcc/testsuite/gcc.target/i386/sse-23.c", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse-23.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse-23.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse-23.c?ref=ab442df7fb453434d80a779844fe1a10c0c802ab", "patch": "@@ -0,0 +1,108 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -Werror-implicit-function-declaration -march=k8\" } */\n+\n+#include <mm_malloc.h>\n+\n+/* Test that the intrinsics compile with optimization.  All of them are\n+   defined as inline functions in {,x,e,p,t,s,w,a,b}mmintrin.h and mm3dnow.h\n+   that reference the proper builtin functions.  Defining away \"extern\" and\n+   \"__inline\" results in all of them being compiled as proper functions.  */\n+\n+#define extern\n+#define __inline\n+\n+/* Following intrinsics require immediate arguments. */\n+\n+/* ammintrin.h */\n+#define __builtin_ia32_extrqi(X, I, L)  __builtin_ia32_extrqi(X, 1, 1)\n+#define __builtin_ia32_insertqi(X, Y, I, L) __builtin_ia32_insertqi(X, Y, 1, 1)\n+\n+/* wmmintrin.h */\n+#define __builtin_ia32_aeskeygenassist128(X, C) __builtin_ia32_aeskeygenassist128(X, 1)\n+#define __builtin_ia32_pclmulqdq128(X, Y, I) __builtin_ia32_pclmulqdq128(X, Y, 1)\n+\n+/* mmintrin-common.h */\n+#define __builtin_ia32_roundpd(V, M) __builtin_ia32_roundpd(V, 1)\n+#define __builtin_ia32_roundsd(D, V, M) __builtin_ia32_roundsd(D, V, 1)\n+#define __builtin_ia32_roundps(V, M) __builtin_ia32_roundps(V, 1)\n+#define __builtin_ia32_roundss(D, V, M) __builtin_ia32_roundss(D, V, 1)\n+\n+/* smmintrin.h */\n+#define __builtin_ia32_pblendw128(X, Y, M) __builtin_ia32_pblendw128 (X, Y, 1)\n+#define __builtin_ia32_blendps(X, Y, M) __builtin_ia32_blendps(X, Y, 1)\n+#define __builtin_ia32_blendpd(X, Y, M) __builtin_ia32_blendpd(X, Y, 1)\n+#define __builtin_ia32_dpps(X, Y, M) __builtin_ia32_dpps(X, Y, 1)\n+#define __builtin_ia32_dppd(X, Y, M) __builtin_ia32_dppd(X, Y, 1)\n+#define __builtin_ia32_insertps128(D, S, N) __builtin_ia32_insertps128(D, S, 1)\n+#define __builtin_ia32_vec_ext_v4sf(X, N) __builtin_ia32_vec_ext_v4sf(X, 1)\n+#define __builtin_ia32_vec_set_v16qi(D, S, N) __builtin_ia32_vec_set_v16qi(D, S, 1)\n+#define __builtin_ia32_vec_set_v4si(D, S, N) __builtin_ia32_vec_set_v4si(D, S, 1)\n+#define __builtin_ia32_vec_set_v2di(D, S, N) __builtin_ia32_vec_set_v2di(D, S, 1)\n+#define __builtin_ia32_vec_ext_v16qi(X, N) __builtin_ia32_vec_ext_v16qi(X, 1)\n+#define __builtin_ia32_vec_ext_v4si(X, N) __builtin_ia32_vec_ext_v4si(X, 1)\n+#define __builtin_ia32_vec_ext_v2di(X, N) __builtin_ia32_vec_ext_v2di(X, 1)\n+#define __builtin_ia32_mpsadbw128(X, Y, M) __builtin_ia32_mpsadbw128(X, Y, 1)\n+#define __builtin_ia32_pcmpistrm128(X, Y, M) \\\n+  __builtin_ia32_pcmpistrm128(X, Y, 1)\n+#define __builtin_ia32_pcmpistri128(X, Y, M) \\\n+  __builtin_ia32_pcmpistri128(X, Y, 1)\n+#define __builtin_ia32_pcmpestrm128(X, LX, Y, LY, M) \\\n+  __builtin_ia32_pcmpestrm128(X, LX, Y, LY, 1)\n+#define __builtin_ia32_pcmpestri128(X, LX, Y, LY, M) \\\n+  __builtin_ia32_pcmpestri128(X, LX, Y, LY, 1)\n+#define __builtin_ia32_pcmpistria128(X, Y, M) \\\n+  __builtin_ia32_pcmpistria128(X, Y, 1)\n+#define __builtin_ia32_pcmpistric128(X, Y, M) \\\n+  __builtin_ia32_pcmpistric128(X, Y, 1)\n+#define __builtin_ia32_pcmpistrio128(X, Y, M) \\\n+  __builtin_ia32_pcmpistrio128(X, Y, 1)\n+#define __builtin_ia32_pcmpistris128(X, Y, M) \\\n+  __builtin_ia32_pcmpistris128(X, Y, 1)\n+#define __builtin_ia32_pcmpistriz128(X, Y, M) \\\n+  __builtin_ia32_pcmpistriz128(X, Y, 1)\n+#define __builtin_ia32_pcmpestria128(X, LX, Y, LY, M) \\\n+  __builtin_ia32_pcmpestria128(X, LX, Y, LY, 1)\n+#define __builtin_ia32_pcmpestric128(X, LX, Y, LY, M) \\\n+  __builtin_ia32_pcmpestric128(X, LX, Y, LY, 1)\n+#define __builtin_ia32_pcmpestrio128(X, LX, Y, LY, M) \\\n+  __builtin_ia32_pcmpestrio128(X, LX, Y, LY, 1)\n+#define __builtin_ia32_pcmpestris128(X, LX, Y, LY, M) \\\n+  __builtin_ia32_pcmpestris128(X, LX, Y, LY, 1)\n+#define __builtin_ia32_pcmpestriz128(X, LX, Y, LY, M) \\\n+  __builtin_ia32_pcmpestriz128(X, LX, Y, LY, 1)\n+\n+/* tmmintrin.h */\n+#define __builtin_ia32_palignr128(X, Y, N) __builtin_ia32_palignr128(X, Y, 8)\n+#define __builtin_ia32_palignr(X, Y, N) __builtin_ia32_palignr(X, Y, 8)\n+\n+/* emmintrin.h */\n+#define __builtin_ia32_psrldqi128(A, B) __builtin_ia32_psrldqi128(A, 8)\n+#define __builtin_ia32_pslldqi128(A, B) __builtin_ia32_pslldqi128(A, 8)\n+#define __builtin_ia32_pshufhw(A, N) __builtin_ia32_pshufhw(A, 0)\n+#define __builtin_ia32_pshuflw(A, N) __builtin_ia32_pshuflw(A, 0)\n+#define __builtin_ia32_pshufd(A, N) __builtin_ia32_pshufd(A, 0)\n+#define __builtin_ia32_vec_set_v8hi(A, D, N) \\\n+  __builtin_ia32_vec_set_v8hi(A, D, 0)\n+#define __builtin_ia32_vec_ext_v8hi(A, N) __builtin_ia32_vec_ext_v8hi(A, 0)\n+#define __builtin_ia32_shufpd(A, B, N) __builtin_ia32_shufpd(A, B, 0)\n+\n+/* xmmintrin.h */\n+#define __builtin_prefetch(P, A, I) __builtin_prefetch(P, A, _MM_HINT_NTA)\n+#define __builtin_ia32_pshufw(A, N) __builtin_ia32_pshufw(A, 0)\n+#define __builtin_ia32_vec_set_v4hi(A, D, N) \\\n+  __builtin_ia32_vec_set_v4hi(A, D, 0)\n+#define __builtin_ia32_vec_ext_v4hi(A, N) __builtin_ia32_vec_ext_v4hi(A, 0)\n+#define __builtin_ia32_shufps(A, B, N) __builtin_ia32_shufps(A, B, 0)\n+\n+/* bmmintrin.h */\n+#define __builtin_ia32_protbi(A, B) __builtin_ia32_protbi(A,1)\n+#define __builtin_ia32_protwi(A, B) __builtin_ia32_protwi(A,1)\n+#define __builtin_ia32_protdi(A, B) __builtin_ia32_protdi(A,1)\n+#define __builtin_ia32_protqi(A, B) __builtin_ia32_protqi(A,1)\n+\n+\n+#pragma GCC option (\"3dnow,sse4,sse5,aes,pclmul\")\n+#include <wmmintrin.h>\n+#include <bmmintrin.h>\n+#include <smmintrin.h>\n+#include <mm3dnow.h>"}, {"sha": "a2d64cd9d69d6b65f4a32fe97e71a0493c827f4b", "filename": "gcc/toplev.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Ftoplev.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Ftoplev.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.h?ref=ab442df7fb453434d80a779844fe1a10c0c802ab", "patch": "@@ -82,6 +82,7 @@ extern void announce_function (tree);\n extern void error_for_asm (const_rtx, const char *, ...) ATTRIBUTE_GCC_DIAG(2,3);\n extern void warning_for_asm (const_rtx, const char *, ...) ATTRIBUTE_GCC_DIAG(2,3);\n extern void warn_deprecated_use (tree);\n+extern bool parse_optimize_options (tree, bool);\n \n #ifdef BUFSIZ\n extern void output_quoted_string\t(FILE *, const char *);\n@@ -158,6 +159,7 @@ extern void decode_d_option\t\t(const char *);\n \n /* Return true iff flags are set as if -ffast-math.  */\n extern bool fast_math_flags_set_p\t(void);\n+extern bool fast_math_flags_struct_set_p (struct cl_optimization *);\n \n /* Return log2, or -1 if not exact.  */\n extern int exact_log2                  (unsigned HOST_WIDE_INT);"}, {"sha": "9d827ff92615f2bbbd28196a4cad2de3a5bf0e26", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=ab442df7fb453434d80a779844fe1a10c0c802ab", "patch": "@@ -3683,3 +3683,34 @@ build_duplicate_type (tree type)\n \n   return type;\n }\n+\n+/* Return whether it is safe to inline a function because it used different\n+   target specific options or different optimization options.  */\n+bool\n+tree_can_inline_p (tree caller, tree callee)\n+{\n+  /* Don't inline a function with a higher optimization level than the\n+     caller, or with different space constraints (hot/cold functions).  */\n+  tree caller_tree = DECL_FUNCTION_SPECIFIC_OPTIMIZATION (caller);\n+  tree callee_tree = DECL_FUNCTION_SPECIFIC_OPTIMIZATION (callee);\n+\n+  if (caller_tree != callee_tree)\n+    {\n+      struct cl_optimization *caller_opt\n+\t= TREE_OPTIMIZATION ((caller_tree)\n+\t\t\t     ? caller_tree\n+\t\t\t     : optimization_default_node);\n+\n+      struct cl_optimization *callee_opt\n+\t= TREE_OPTIMIZATION ((callee_tree)\n+\t\t\t     ? callee_tree\n+\t\t\t     : optimization_default_node);\n+\n+      if ((caller_opt->optimize > callee_opt->optimize)\n+\t  || (caller_opt->optimize_size != callee_opt->optimize_size))\n+\treturn false;\n+    }\n+\n+  /* Allow the backend to decide if inlining is ok.  */\n+  return targetm.target_option.can_inline_p (caller, callee);\n+}"}, {"sha": "d858b91290f69885ae248a180014cb3a303481cd", "filename": "gcc/tree-inline.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Ftree-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Ftree-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.h?ref=ab442df7fb453434d80a779844fe1a10c0c802ab", "patch": "@@ -150,6 +150,7 @@ int estimate_move_cost (tree type);\n int estimate_num_insns (tree expr, eni_weights *);\n bool tree_versionable_function_p (tree);\n void tree_function_versioning (tree, tree, varray_type, bool);\n+bool tree_can_inline_p (tree, tree);\n \n extern tree remap_decl (tree decl, copy_body_data *id);\n extern tree remap_type (tree type, copy_body_data *id);"}, {"sha": "0af1189388392dadacce4c4e58f2b6bb8d0ed0fd", "filename": "gcc/tree.c", "status": "modified", "additions": 150, "deletions": 0, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=ab442df7fb453434d80a779844fe1a10c0c802ab", "patch": "@@ -175,6 +175,16 @@ static GTY (()) tree int_cst_node;\n static GTY ((if_marked (\"ggc_marked_p\"), param_is (union tree_node)))\n      htab_t int_cst_hash_table;\n \n+/* Hash table for optimization flags and target option flags.  Use the same\n+   hash table for both sets of options.  Nodes for building the current\n+   optimization and target option nodes.  The assumption is most of the time\n+   the options created will already be in the hash table, so we avoid\n+   allocating and freeing up a node repeatably.  */\n+static GTY (()) tree cl_optimization_node;\n+static GTY (()) tree cl_target_option_node;\n+static GTY ((if_marked (\"ggc_marked_p\"), param_is (union tree_node)))\n+     htab_t cl_option_hash_table;\n+\n /* General tree->tree mapping  structure for use in hash tables.  */\n \n \n@@ -196,6 +206,8 @@ static int type_hash_eq (const void *, const void *);\n static hashval_t type_hash_hash (const void *);\n static hashval_t int_cst_hash_hash (const void *);\n static int int_cst_hash_eq (const void *, const void *);\n+static hashval_t cl_option_hash_hash (const void *);\n+static int cl_option_hash_eq (const void *, const void *);\n static void print_type_hash_statistics (void);\n static void print_debug_expr_statistics (void);\n static void print_value_expr_statistics (void);\n@@ -273,6 +285,12 @@ init_ttree (void)\n   \n   int_cst_node = make_node (INTEGER_CST);\n \n+  cl_option_hash_table = htab_create_ggc (64, cl_option_hash_hash,\n+\t\t\t\t\t  cl_option_hash_eq, NULL);\n+\n+  cl_optimization_node = make_node (OPTIMIZATION_NODE);\n+  cl_target_option_node = make_node (TARGET_OPTION_NODE);\n+\n   tree_contains_struct[FUNCTION_DECL][TS_DECL_NON_COMMON] = 1;\n   tree_contains_struct[TRANSLATION_UNIT_DECL][TS_DECL_NON_COMMON] = 1;\n   tree_contains_struct[TYPE_DECL][TS_DECL_NON_COMMON] = 1;\n@@ -505,6 +523,8 @@ tree_code_size (enum tree_code code)\n \tcase STATEMENT_LIST:\treturn sizeof (struct tree_statement_list);\n \tcase BLOCK:\t\treturn sizeof (struct tree_block);\n \tcase CONSTRUCTOR:\treturn sizeof (struct tree_constructor);\n+\tcase OPTIMIZATION_NODE: return sizeof (struct tree_optimization_option);\n+\tcase TARGET_OPTION_NODE: return sizeof (struct tree_target_option);\n \n \tdefault:\n \t  return lang_hooks.tree_size (code);\n@@ -2427,6 +2447,8 @@ tree_node_structure (const_tree t)\n     case CONSTRUCTOR:\t\treturn TS_CONSTRUCTOR;\n     case TREE_BINFO:\t\treturn TS_BINFO;\n     case OMP_CLAUSE:\t\treturn TS_OMP_CLAUSE;\n+    case OPTIMIZATION_NODE:\treturn TS_OPTIMIZATION;\n+    case TARGET_OPTION_NODE:\treturn TS_TARGET_OPTION;\n \n     default:\n       gcc_unreachable ();\n@@ -8942,4 +8964,132 @@ block_nonartificial_location (tree block)\n   return ret;\n }\n \n+/* These are the hash table functions for the hash table of OPTIMIZATION_NODEq\n+   nodes.  */\n+\n+/* Return the hash code code X, an OPTIMIZATION_NODE or TARGET_OPTION code.  */\n+\n+static hashval_t\n+cl_option_hash_hash (const void *x)\n+{\n+  const_tree const t = (const_tree) x;\n+  const char *p;\n+  size_t i;\n+  size_t len = 0;\n+  hashval_t hash = 0;\n+\n+  if (TREE_CODE (t) == OPTIMIZATION_NODE)\n+    {\n+      p = (const char *)TREE_OPTIMIZATION (t);\n+      len = sizeof (struct cl_optimization);\n+    }\n+\n+  else if (TREE_CODE (t) == TARGET_OPTION_NODE)\n+    {\n+      p = (const char *)TREE_TARGET_OPTION (t);\n+      len = sizeof (struct cl_target_option);\n+    }\n+\n+  else\n+    gcc_unreachable ();\n+\n+  /* assume most opt flags are just 0/1, some are 2-3, and a few might be\n+     something else.  */\n+  for (i = 0; i < len; i++)\n+    if (p[i])\n+      hash = (hash << 4) ^ ((i << 2) | p[i]);\n+\n+  return hash;\n+}\n+\n+/* Return nonzero if the value represented by *X (an OPTIMIZATION or\n+   TARGET_OPTION tree node) is the same as that given by *Y, which is the\n+   same.  */\n+\n+static int\n+cl_option_hash_eq (const void *x, const void *y)\n+{\n+  const_tree const xt = (const_tree) x;\n+  const_tree const yt = (const_tree) y;\n+  const char *xp;\n+  const char *yp;\n+  size_t len;\n+\n+  if (TREE_CODE (xt) != TREE_CODE (yt))\n+    return 0;\n+\n+  if (TREE_CODE (xt) == OPTIMIZATION_NODE)\n+    {\n+      xp = (const char *)TREE_OPTIMIZATION (xt);\n+      yp = (const char *)TREE_OPTIMIZATION (yt);\n+      len = sizeof (struct cl_optimization);\n+    }\n+\n+  else if (TREE_CODE (xt) == TARGET_OPTION_NODE)\n+    {\n+      xp = (const char *)TREE_TARGET_OPTION (xt);\n+      yp = (const char *)TREE_TARGET_OPTION (yt);\n+      len = sizeof (struct cl_target_option);\n+    }\n+\n+  else\n+    gcc_unreachable ();\n+\n+  return (memcmp (xp, yp, len) == 0);\n+}\n+\n+/* Build an OPTIMIZATION_NODE based on the current options.  */\n+\n+tree\n+build_optimization_node (void)\n+{\n+  tree t;\n+  void **slot;\n+\n+  /* Use the cache of optimization nodes.  */\n+\n+  cl_optimization_save (TREE_OPTIMIZATION (cl_optimization_node));\n+\n+  slot = htab_find_slot (cl_option_hash_table, cl_optimization_node, INSERT);\n+  t = (tree) *slot;\n+  if (!t)\n+    {\n+      /* Insert this one into the hash table.  */\n+      t = cl_optimization_node;\n+      *slot = t;\n+\n+      /* Make a new node for next time round.  */\n+      cl_optimization_node = make_node (OPTIMIZATION_NODE);\n+    }\n+\n+  return t;\n+}\n+\n+/* Build a TARGET_OPTION_NODE based on the current options.  */\n+\n+tree\n+build_target_option_node (void)\n+{\n+  tree t;\n+  void **slot;\n+\n+  /* Use the cache of optimization nodes.  */\n+\n+  cl_target_option_save (TREE_TARGET_OPTION (cl_target_option_node));\n+\n+  slot = htab_find_slot (cl_option_hash_table, cl_target_option_node, INSERT);\n+  t = (tree) *slot;\n+  if (!t)\n+    {\n+      /* Insert this one into the hash table.  */\n+      t = cl_target_option_node;\n+      *slot = t;\n+\n+      /* Make a new node for next time round.  */\n+      cl_target_option_node = make_node (TARGET_OPTION_NODE);\n+    }\n+\n+  return t;\n+}\n+\n #include \"gt-tree.h\""}, {"sha": "26e72c44bd326dd9010b025c37bb475b575e3069", "filename": "gcc/tree.def", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=ab442df7fb453434d80a779844fe1a10c0c802ab", "patch": "@@ -1194,6 +1194,13 @@ DEFTREECODE (VEC_INTERLEAVE_LOW_EXPR, \"vec_interleavelow_expr\", tcc_binary, 2)\n    all conditional branches leading to execution paths executing the\n    PREDICT_EXPR will get predicted by the specified predictor.  */\n DEFTREECODE (PREDICT_EXPR, \"predict_expr\", tcc_unary, 1)\n+\n+/* OPTIMIZATION_NODE.  Node to store the optimization options.  */\n+DEFTREECODE (OPTIMIZATION_NODE, \"optimization_node\", tcc_exceptional, 0)\n+\n+/* TARGET_OPTION_NODE.  Node to store the target specific options.  */\n+DEFTREECODE (TARGET_OPTION_NODE, \"target_option_node\", tcc_exceptional, 0)\n+\n /*\n Local variables:\n mode:c"}, {"sha": "0ffd91bc40b34584e712b0493713d7e18fe991ea", "filename": "gcc/tree.h", "status": "modified", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=ab442df7fb453434d80a779844fe1a10c0c802ab", "patch": "@@ -29,6 +29,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"vec.h\"\n #include \"double-int.h\"\n #include \"alias.h\"\n+#include \"options.h\"\n \n /* Codes of tree nodes */\n \n@@ -3408,6 +3409,16 @@ struct tree_decl_non_common GTY(())\n #define DECL_ARGUMENTS(NODE) (FUNCTION_DECL_CHECK (NODE)->decl_non_common.arguments)\n #define DECL_ARGUMENT_FLD(NODE) (DECL_NON_COMMON_CHECK (NODE)->decl_non_common.arguments)\n \n+/* In FUNCTION_DECL, the function specific target options to use when compiling\n+   this function.  */\n+#define DECL_FUNCTION_SPECIFIC_TARGET(NODE) \\\n+   (FUNCTION_DECL_CHECK (NODE)->function_decl.function_specific_target)\n+\n+/* In FUNCTION_DECL, the function specific optimization options to use when\n+   compiling this function.  */\n+#define DECL_FUNCTION_SPECIFIC_OPTIMIZATION(NODE) \\\n+   (FUNCTION_DECL_CHECK (NODE)->function_decl.function_specific_optimization)\n+\n /* FUNCTION_DECL inherits from DECL_NON_COMMON because of the use of the\n    arguments/result/saved_tree fields by front ends.   It was either inherit\n    FUNCTION_DECL from non_common, or inherit non_common from FUNCTION_DECL,\n@@ -3419,6 +3430,10 @@ struct tree_function_decl GTY(())\n \n   struct function *f;\n \n+  /* Function specific options that are used by this function.  */\n+  tree function_specific_target;\t/* target options */\n+  tree function_specific_optimization;\t/* optimization options */\n+\n   /* In a FUNCTION_DECL for which DECL_BUILT_IN holds, this is\n      DECL_FUNCTION_CODE.  Otherwise unused.\n      ???  The bitfield needs to be able to hold all target function\n@@ -3491,6 +3506,39 @@ struct tree_statement_list\n   struct tree_statement_list_node *tail;\n };\n \n+\n+/* Optimization options used by a function.  */\n+\n+struct tree_optimization_option GTY(())\n+{\n+  struct tree_common common;\n+\n+  /* The optimization options used by the user.  */\n+  struct cl_optimization opts;\n+};\n+\n+#define TREE_OPTIMIZATION(NODE) \\\n+  (&OPTIMIZATION_NODE_CHECK (NODE)->optimization.opts)\n+\n+/* Return a tree node that encapsulates the current optimization options.  */\n+extern tree build_optimization_node (void);\n+\n+/* Target options used by a function.  */\n+\n+struct tree_target_option GTY(())\n+{\n+  struct tree_common common;\n+\n+  /* The optimization options used by the user.  */\n+  struct cl_target_option opts;\n+};\n+\n+#define TREE_TARGET_OPTION(NODE) \\\n+  (&TARGET_OPTION_NODE_CHECK (NODE)->target_option.opts)\n+\n+/* Return a tree node that encapsulates the current target options.  */\n+extern tree build_target_option_node (void);\n+\n \f\n /* Define the overall contents of a tree node.\n    It may be any of the structures declared above\n@@ -3535,6 +3583,8 @@ union tree_node GTY ((ptr_alias (union lang_tree_node),\n   struct tree_memory_tag GTY ((tag (\"TS_MEMORY_TAG\"))) mtag;\n   struct tree_omp_clause GTY ((tag (\"TS_OMP_CLAUSE\"))) omp_clause;\n   struct tree_memory_partition_tag GTY ((tag (\"TS_MEMORY_PARTITION_TAG\"))) mpt;\n+  struct tree_optimization_option GTY ((tag (\"TS_OPTIMIZATION\"))) optimization;\n+  struct tree_target_option GTY ((tag (\"TS_TARGET_OPTION\"))) target_option;\n };\n \f\n /* Standard named or nameless data types of the C compiler.  */\n@@ -3682,6 +3732,15 @@ enum tree_index\n   TI_SAT_UDA_TYPE,\n   TI_SAT_UTA_TYPE,\n \n+  TI_OPTIMIZATION_DEFAULT,\n+  TI_OPTIMIZATION_CURRENT,\n+  TI_OPTIMIZATION_COLD,\n+  TI_OPTIMIZATION_HOT,\n+  TI_TARGET_OPTION_DEFAULT,\n+  TI_TARGET_OPTION_CURRENT,\n+  TI_CURRENT_OPTION_PRAGMA,\n+  TI_CURRENT_OPTIMIZE_PRAGMA,\n+\n   TI_MAX\n };\n \n@@ -3849,6 +3908,22 @@ extern GTY(()) tree global_trees[TI_MAX];\n #define main_identifier_node\t\tglobal_trees[TI_MAIN_IDENTIFIER]\n #define MAIN_NAME_P(NODE) (IDENTIFIER_NODE_CHECK (NODE) == main_identifier_node)\n \n+/* Optimization options (OPTIMIZATION_NODE) to use for default, current, cold,\n+   and hot functions.  */\n+#define optimization_default_node\tglobal_trees[TI_OPTIMIZATION_DEFAULT]\n+#define optimization_current_node\tglobal_trees[TI_OPTIMIZATION_CURRENT]\n+#define optimization_cold_node\t\tglobal_trees[TI_OPTIMIZATION_COLD]\n+#define optimization_hot_node\t\tglobal_trees[TI_OPTIMIZATION_HOT]\n+\n+/* Default/current target options (TARGET_OPTION_NODE).  */\n+#define target_option_default_node\tglobal_trees[TI_TARGET_OPTION_DEFAULT]\n+#define target_option_current_node\tglobal_trees[TI_TARGET_OPTION_CURRENT]\n+\n+/* Default tree list option(), optimize() pragmas to be linked into the\n+   attribute list.  */\n+#define current_option_pragma\t\tglobal_trees[TI_CURRENT_OPTION_PRAGMA]\n+#define current_optimize_pragma\t\tglobal_trees[TI_CURRENT_OPTIMIZE_PRAGMA]\n+\n /* An enumeration of the standard C integer types.  These must be\n    ordered so that shorter types appear before longer ones, and so\n    that signed types appear before unsigned ones, for the correct"}, {"sha": "0f3dbbdfb2a34ebd8f55f72bc8e73fa1f76de0c9", "filename": "gcc/treestruct.def", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Ftreestruct.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab442df7fb453434d80a779844fe1a10c0c802ab/gcc%2Ftreestruct.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftreestruct.def?ref=ab442df7fb453434d80a779844fe1a10c0c802ab", "patch": "@@ -63,3 +63,6 @@ DEFTREESTRUCT(TS_CONSTRUCTOR, \"constructor\")\n DEFTREESTRUCT(TS_MEMORY_TAG, \"memory tag\")\n DEFTREESTRUCT(TS_OMP_CLAUSE, \"omp clause\")\n DEFTREESTRUCT(TS_MEMORY_PARTITION_TAG, \"memory partition tag\")\n+DEFTREESTRUCT(TS_OPTIMIZATION, \"optimization options\")\n+DEFTREESTRUCT(TS_TARGET_OPTION, \"target options\")\n+"}]}