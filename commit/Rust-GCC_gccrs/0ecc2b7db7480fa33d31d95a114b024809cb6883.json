{"sha": "0ecc2b7db7480fa33d31d95a114b024809cb6883", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGVjYzJiN2RiNzQ4MGZhMzNkMzFkOTVhMTE0YjAyNDgwOWNiNjg4Mw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-01-03T09:01:52Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-01-03T09:01:52Z"}, "message": "poly_int: vector_builder element count\n\nThis patch changes the number of elements in a vector being built\nby a vector_builder from unsigned int to poly_uint64.  The case\nin which it isn't a constant is the one that motivated adding\nthe vector encoding in the first place.\n\n2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n\ngcc/\n\t* vector-builder.h (vector_builder::m_full_nelts): Change from\n\tunsigned int to poly_uint64.\n\t(vector_builder::full_nelts): Update prototype accordingly.\n\t(vector_builder::new_vector): Likewise.\n\t(vector_builder::encoded_full_vector_p): Handle polynomial full_nelts.\n\t(vector_builder::operator ==): Likewise.\n\t(vector_builder::finalize): Likewise.\n\t* int-vector-builder.h (int_vector_builder::int_vector_builder):\n\tTake the number of elements as a poly_uint64 rather than an\n\tunsigned int.\n\t* vec-perm-indices.h (vec_perm_indices::m_nelts_per_input): Change\n\tfrom unsigned int to poly_uint64.\n\t(vec_perm_indices::vec_perm_indices): Update prototype accordingly.\n\t(vec_perm_indices::new_vector): Likewise.\n\t(vec_perm_indices::length): Likewise.\n\t(vec_perm_indices::nelts_per_input): Likewise.\n\t(vec_perm_indices::input_nelts): Likewise.\n\t* vec-perm-indices.c (vec_perm_indices::new_vector): Take the\n\tnumber of elements per input as a poly_uint64 rather than an\n\tunsigned int.  Use the original encoding for variable-length\n\tvectors, rather than clamping each individual element.\n\tFor the second and subsequent elements in each pattern,\n\tclamp the step and base before clamping their sum.\n\t(vec_perm_indices::series_p): Handle polynomial element counts.\n\t(vec_perm_indices::all_in_range_p): Likewise.\n\t(vec_perm_indices_to_tree): Likewise.\n\t(vec_perm_indices_to_rtx): Likewise.\n\t* tree-vect-stmts.c (vect_gen_perm_mask_any): Likewise.\n\t* tree-vector-builder.c (tree_vector_builder::new_unary_operation)\n\t(tree_vector_builder::new_binary_operation): Handle polynomial\n\telement counts.  Return false if we need to know the number\n\tof elements at compile time.\n\t* fold-const.c (fold_vec_perm): Punt if the number of elements\n\tisn't known at compile time.\n\nFrom-SVN: r256165", "tree": {"sha": "9003f8b5836a2167c157e9007befcc84ae24a173", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9003f8b5836a2167c157e9007befcc84ae24a173"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0ecc2b7db7480fa33d31d95a114b024809cb6883", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ecc2b7db7480fa33d31d95a114b024809cb6883", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ecc2b7db7480fa33d31d95a114b024809cb6883", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ecc2b7db7480fa33d31d95a114b024809cb6883/comments", "author": null, "committer": null, "parents": [{"sha": "6b0630fbe8c34255f2739f63a8d3e5b636020bf4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b0630fbe8c34255f2739f63a8d3e5b636020bf4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b0630fbe8c34255f2739f63a8d3e5b636020bf4"}], "stats": {"total": 155, "additions": 114, "deletions": 41}, "files": [{"sha": "ed19e28d63e9e668f99750e53a70cc8e18779758", "filename": "gcc/ChangeLog", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ecc2b7db7480fa33d31d95a114b024809cb6883/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ecc2b7db7480fa33d31d95a114b024809cb6883/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0ecc2b7db7480fa33d31d95a114b024809cb6883", "patch": "@@ -1,3 +1,40 @@\n+2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* vector-builder.h (vector_builder::m_full_nelts): Change from\n+\tunsigned int to poly_uint64.\n+\t(vector_builder::full_nelts): Update prototype accordingly.\n+\t(vector_builder::new_vector): Likewise.\n+\t(vector_builder::encoded_full_vector_p): Handle polynomial full_nelts.\n+\t(vector_builder::operator ==): Likewise.\n+\t(vector_builder::finalize): Likewise.\n+\t* int-vector-builder.h (int_vector_builder::int_vector_builder):\n+\tTake the number of elements as a poly_uint64 rather than an\n+\tunsigned int.\n+\t* vec-perm-indices.h (vec_perm_indices::m_nelts_per_input): Change\n+\tfrom unsigned int to poly_uint64.\n+\t(vec_perm_indices::vec_perm_indices): Update prototype accordingly.\n+\t(vec_perm_indices::new_vector): Likewise.\n+\t(vec_perm_indices::length): Likewise.\n+\t(vec_perm_indices::nelts_per_input): Likewise.\n+\t(vec_perm_indices::input_nelts): Likewise.\n+\t* vec-perm-indices.c (vec_perm_indices::new_vector): Take the\n+\tnumber of elements per input as a poly_uint64 rather than an\n+\tunsigned int.  Use the original encoding for variable-length\n+\tvectors, rather than clamping each individual element.\n+\tFor the second and subsequent elements in each pattern,\n+\tclamp the step and base before clamping their sum.\n+\t(vec_perm_indices::series_p): Handle polynomial element counts.\n+\t(vec_perm_indices::all_in_range_p): Likewise.\n+\t(vec_perm_indices_to_tree): Likewise.\n+\t(vec_perm_indices_to_rtx): Likewise.\n+\t* tree-vect-stmts.c (vect_gen_perm_mask_any): Likewise.\n+\t* tree-vector-builder.c (tree_vector_builder::new_unary_operation)\n+\t(tree_vector_builder::new_binary_operation): Handle polynomial\n+\telement counts.  Return false if we need to know the number\n+\tof elements at compile time.\n+\t* fold-const.c (fold_vec_perm): Punt if the number of elements\n+\tisn't known at compile time.\n+\n 2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \t* vec-perm-indices.h (vec_perm_builder): Change element type"}, {"sha": "98eb55ef9ddbcba51007ed2552224b230c95d549", "filename": "gcc/fold-const.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ecc2b7db7480fa33d31d95a114b024809cb6883/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ecc2b7db7480fa33d31d95a114b024809cb6883/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=0ecc2b7db7480fa33d31d95a114b024809cb6883", "patch": "@@ -8927,9 +8927,11 @@ static tree\n fold_vec_perm (tree type, tree arg0, tree arg1, const vec_perm_indices &sel)\n {\n   unsigned int i;\n+  unsigned HOST_WIDE_INT nelts;\n   bool need_ctor = false;\n \n-  unsigned int nelts = sel.length ();\n+  if (!sel.length ().is_constant (&nelts))\n+    return NULL_TREE;\n   gcc_assert (TYPE_VECTOR_SUBPARTS (type) == nelts\n \t      && TYPE_VECTOR_SUBPARTS (TREE_TYPE (arg0)) == nelts\n \t      && TYPE_VECTOR_SUBPARTS (TREE_TYPE (arg1)) == nelts);"}, {"sha": "2500e866438b1d1a797a6509a70ae68f5ee1456f", "filename": "gcc/int-vector-builder.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ecc2b7db7480fa33d31d95a114b024809cb6883/gcc%2Fint-vector-builder.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ecc2b7db7480fa33d31d95a114b024809cb6883/gcc%2Fint-vector-builder.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fint-vector-builder.h?ref=0ecc2b7db7480fa33d31d95a114b024809cb6883", "patch": "@@ -33,7 +33,7 @@ class int_vector_builder : public vector_builder<T, int_vector_builder<T> >\n \n public:\n   int_vector_builder () {}\n-  int_vector_builder (unsigned int, unsigned int, unsigned int);\n+  int_vector_builder (poly_uint64, unsigned int, unsigned int);\n \n   using parent::new_vector;\n \n@@ -53,7 +53,7 @@ class int_vector_builder : public vector_builder<T, int_vector_builder<T> >\n \n template<typename T>\n inline\n-int_vector_builder<T>::int_vector_builder (unsigned int full_nelts,\n+int_vector_builder<T>::int_vector_builder (poly_uint64 full_nelts,\n \t\t\t\t\t   unsigned int npatterns,\n \t\t\t\t\t   unsigned int nelts_per_pattern)\n {"}, {"sha": "c4e78b7ec447f8a26677fbf0ff41fd1845cc1a5f", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ecc2b7db7480fa33d31d95a114b024809cb6883/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ecc2b7db7480fa33d31d95a114b024809cb6883/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=0ecc2b7db7480fa33d31d95a114b024809cb6883", "patch": "@@ -6588,8 +6588,8 @@ vect_gen_perm_mask_any (tree vectype, const vec_perm_indices &sel)\n {\n   tree mask_type;\n \n-  unsigned int nunits = sel.length ();\n-  gcc_assert (nunits == TYPE_VECTOR_SUBPARTS (vectype));\n+  poly_uint64 nunits = sel.length ();\n+  gcc_assert (known_eq (nunits, TYPE_VECTOR_SUBPARTS (vectype)));\n \n   mask_type = build_vector_type (ssizetype, nunits);\n   return vec_perm_indices_to_tree (mask_type, sel);"}, {"sha": "be257074475484270dd8b7680e1593612f039773", "filename": "gcc/tree-vector-builder.c", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ecc2b7db7480fa33d31d95a114b024809cb6883/gcc%2Ftree-vector-builder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ecc2b7db7480fa33d31d95a114b024809cb6883/gcc%2Ftree-vector-builder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vector-builder.c?ref=0ecc2b7db7480fa33d31d95a114b024809cb6883", "patch": "@@ -36,13 +36,15 @@ bool\n tree_vector_builder::new_unary_operation (tree type, tree t,\n \t\t\t\t\t  bool allow_stepped_p)\n {\n-  unsigned int full_nelts = TYPE_VECTOR_SUBPARTS (type);\n-  gcc_assert (full_nelts == TYPE_VECTOR_SUBPARTS (TREE_TYPE (t)));\n+  poly_uint64 full_nelts = TYPE_VECTOR_SUBPARTS (type);\n+  gcc_assert (known_eq (full_nelts, TYPE_VECTOR_SUBPARTS (TREE_TYPE (t))));\n   unsigned int npatterns = VECTOR_CST_NPATTERNS (t);\n   unsigned int nelts_per_pattern = VECTOR_CST_NELTS_PER_PATTERN (t);\n   if (!allow_stepped_p && nelts_per_pattern > 2)\n     {\n-      npatterns = full_nelts;\n+      if (!full_nelts.is_constant ())\n+\treturn false;\n+      npatterns = full_nelts.to_constant ();\n       nelts_per_pattern = 1;\n     }\n   new_vector (type, npatterns, nelts_per_pattern);\n@@ -61,9 +63,9 @@ bool\n tree_vector_builder::new_binary_operation (tree type, tree t1, tree t2,\n \t\t\t\t\t   bool allow_stepped_p)\n {\n-  unsigned int full_nelts = TYPE_VECTOR_SUBPARTS (type);\n-  gcc_assert (full_nelts == TYPE_VECTOR_SUBPARTS (TREE_TYPE (t1))\n-\t      && full_nelts == TYPE_VECTOR_SUBPARTS (TREE_TYPE (t2)));\n+  poly_uint64 full_nelts = TYPE_VECTOR_SUBPARTS (type);\n+  gcc_assert (known_eq (full_nelts, TYPE_VECTOR_SUBPARTS (TREE_TYPE (t1)))\n+\t      && known_eq (full_nelts, TYPE_VECTOR_SUBPARTS (TREE_TYPE (t2))));\n   /* Conceptually we split the patterns in T1 and T2 until we have\n      an equal number for both.  Each split pattern requires the same\n      number of elements per pattern as the original.  E.g. splitting:\n@@ -89,7 +91,9 @@ tree_vector_builder::new_binary_operation (tree type, tree t1, tree t2,\n \t\t\t\t\tVECTOR_CST_NELTS_PER_PATTERN (t2));\n   if (!allow_stepped_p && nelts_per_pattern > 2)\n     {\n-      npatterns = full_nelts;\n+      if (!full_nelts.is_constant ())\n+\treturn false;\n+      npatterns = full_nelts.to_constant ();\n       nelts_per_pattern = 1;\n     }\n   new_vector (type, npatterns, nelts_per_pattern);"}, {"sha": "89764b7258369b8846b46acead86da7eb4907676", "filename": "gcc/vec-perm-indices.c", "status": "modified", "additions": 38, "deletions": 11, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ecc2b7db7480fa33d31d95a114b024809cb6883/gcc%2Fvec-perm-indices.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ecc2b7db7480fa33d31d95a114b024809cb6883/gcc%2Fvec-perm-indices.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvec-perm-indices.c?ref=0ecc2b7db7480fa33d31d95a114b024809cb6883", "patch": "@@ -38,16 +38,42 @@ along with GCC; see the file COPYING3.  If not see\n void\n vec_perm_indices::new_vector (const vec_perm_builder &elements,\n \t\t\t      unsigned int ninputs,\n-\t\t\t      unsigned int nelts_per_input)\n+\t\t\t      poly_uint64 nelts_per_input)\n {\n   m_ninputs = ninputs;\n   m_nelts_per_input = nelts_per_input;\n-  /* Expand the encoding and clamp each element.  E.g. { 0, 2, 4, ... }\n-     might wrap halfway if there is only one vector input.  */\n-  unsigned int full_nelts = elements.full_nelts ();\n-  m_encoding.new_vector (full_nelts, full_nelts, 1);\n-  for (unsigned int i = 0; i < full_nelts; ++i)\n+  /* If the vector has a constant number of elements, expand the\n+     encoding and clamp each element.  E.g. { 0, 2, 4, ... } might\n+     wrap halfway if there is only one vector input, and we want\n+     the wrapped form to be the canonical one.\n+\n+     If the vector has a variable number of elements, just copy\n+     the encoding.  In that case the unwrapped form is canonical\n+     and there is no way of representing the wrapped form.  */\n+  poly_uint64 full_nelts = elements.full_nelts ();\n+  unsigned HOST_WIDE_INT copy_nelts;\n+  if (full_nelts.is_constant (&copy_nelts))\n+    m_encoding.new_vector (full_nelts, copy_nelts, 1);\n+  else\n+    {\n+      copy_nelts = elements.encoded_nelts ();\n+      m_encoding.new_vector (full_nelts, elements.npatterns (),\n+\t\t\t     elements.nelts_per_pattern ());\n+    }\n+  unsigned int npatterns = m_encoding.npatterns ();\n+  for (unsigned int i = 0; i < npatterns; ++i)\n     m_encoding.quick_push (clamp (elements.elt (i)));\n+  /* Use the fact that:\n+\n+\t(a + b) % c == ((a % c) + (b % c)) % c\n+\n+     to simplify the clamping of variable-length vectors.  */\n+  for (unsigned int i = npatterns; i < copy_nelts; ++i)\n+    {\n+      element_type step = clamp (elements.elt (i)\n+\t\t\t\t - elements.elt (i - npatterns));\n+      m_encoding.quick_push (clamp (m_encoding[i - npatterns] + step));\n+    }\n   m_encoding.finalize ();\n }\n \n@@ -98,7 +124,7 @@ vec_perm_indices::series_p (unsigned int out_base, unsigned int out_step,\n   if (maybe_ne (clamp (m_encoding.elt (out_base)), clamp (in_base)))\n     return false;\n \n-  unsigned int full_nelts = m_encoding.full_nelts ();\n+  element_type full_nelts = m_encoding.full_nelts ();\n   unsigned int npatterns = m_encoding.npatterns ();\n \n   /* Calculate which multiple of OUT_STEP elements we need to get\n@@ -112,7 +138,7 @@ vec_perm_indices::series_p (unsigned int out_base, unsigned int out_step,\n   for (;;)\n     {\n       /* Succeed if we've checked all the elements in the vector.  */\n-      if (out_base >= full_nelts)\n+      if (known_ge (out_base, full_nelts))\n \treturn true;\n \n       if (out_base >= npatterns)\n@@ -156,7 +182,8 @@ vec_perm_indices::all_in_range_p (element_type start, element_type size) const\n \n       /* The number of elements in each pattern beyond the first two\n \t that we checked above.  */\n-      unsigned int step_nelts = (m_encoding.full_nelts () / npatterns) - 2;\n+      poly_int64 step_nelts = exact_div (m_encoding.full_nelts (),\n+\t\t\t\t\t npatterns) - 2;\n       for (unsigned int i = 0; i < npatterns; ++i)\n \t{\n \t  /* BASE1 has been checked but BASE2 hasn't.   */\n@@ -210,7 +237,7 @@ tree_to_vec_perm_builder (vec_perm_builder *builder, tree cst)\n tree\n vec_perm_indices_to_tree (tree type, const vec_perm_indices &indices)\n {\n-  gcc_assert (TYPE_VECTOR_SUBPARTS (type) == indices.length ());\n+  gcc_assert (known_eq (TYPE_VECTOR_SUBPARTS (type), indices.length ()));\n   tree_vector_builder sel (type, indices.encoding ().npatterns (),\n \t\t\t   indices.encoding ().nelts_per_pattern ());\n   unsigned int encoded_nelts = sel.encoded_nelts ();\n@@ -226,7 +253,7 @@ rtx\n vec_perm_indices_to_rtx (machine_mode mode, const vec_perm_indices &indices)\n {\n   gcc_assert (GET_MODE_CLASS (mode) == MODE_VECTOR_INT\n-\t      && GET_MODE_NUNITS (mode) == indices.length ());\n+\t      && known_eq (GET_MODE_NUNITS (mode), indices.length ()));\n   rtx_vector_builder sel (mode, indices.encoding ().npatterns (),\n \t\t\t  indices.encoding ().nelts_per_pattern ());\n   unsigned int encoded_nelts = sel.encoded_nelts ();"}, {"sha": "b5396546c684a71a981d800f0f3ad5a5ee5b34f0", "filename": "gcc/vec-perm-indices.h", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ecc2b7db7480fa33d31d95a114b024809cb6883/gcc%2Fvec-perm-indices.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ecc2b7db7480fa33d31d95a114b024809cb6883/gcc%2Fvec-perm-indices.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvec-perm-indices.h?ref=0ecc2b7db7480fa33d31d95a114b024809cb6883", "patch": "@@ -53,9 +53,9 @@ class vec_perm_indices\n \n public:\n   vec_perm_indices ();\n-  vec_perm_indices (const vec_perm_builder &, unsigned int, unsigned int);\n+  vec_perm_indices (const vec_perm_builder &, unsigned int, poly_uint64);\n \n-  void new_vector (const vec_perm_builder &, unsigned int, unsigned int);\n+  void new_vector (const vec_perm_builder &, unsigned int, poly_uint64);\n   void new_expanded_vector (const vec_perm_indices &, unsigned int);\n   void rotate_inputs (int delta);\n \n@@ -64,16 +64,16 @@ class vec_perm_indices\n \n   /* Return the number of output elements.  This is called length ()\n      so that we present a more vec-like interface.  */\n-  unsigned int length () const { return m_encoding.full_nelts (); }\n+  poly_uint64 length () const { return m_encoding.full_nelts (); }\n \n   /* Return the number of input vectors being permuted.  */\n   unsigned int ninputs () const { return m_ninputs; }\n \n   /* Return the number of elements in each input vector.  */\n-  unsigned int nelts_per_input () const { return m_nelts_per_input; }\n+  poly_uint64 nelts_per_input () const { return m_nelts_per_input; }\n \n   /* Return the total number of input elements.  */\n-  unsigned int input_nelts () const { return m_ninputs * m_nelts_per_input; }\n+  poly_uint64 input_nelts () const { return m_ninputs * m_nelts_per_input; }\n \n   element_type clamp (element_type) const;\n   element_type operator[] (unsigned int i) const;\n@@ -86,7 +86,7 @@ class vec_perm_indices\n \n   vec_perm_builder m_encoding;\n   unsigned int m_ninputs;\n-  unsigned int m_nelts_per_input;\n+  poly_uint64 m_nelts_per_input;\n };\n \n bool tree_to_vec_perm_builder (vec_perm_builder *, tree);\n@@ -107,7 +107,7 @@ vec_perm_indices::vec_perm_indices ()\n inline\n vec_perm_indices::vec_perm_indices (const vec_perm_builder &elements,\n \t\t\t\t    unsigned int ninputs,\n-\t\t\t\t    unsigned int nelts_per_input)\n+\t\t\t\t    poly_uint64 nelts_per_input)\n {\n   new_vector (elements, ninputs, nelts_per_input);\n }"}, {"sha": "f8b61467d9a14ba45c1557ce2a9fc4a722f6e788", "filename": "gcc/vector-builder.h", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ecc2b7db7480fa33d31d95a114b024809cb6883/gcc%2Fvector-builder.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ecc2b7db7480fa33d31d95a114b024809cb6883/gcc%2Fvector-builder.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvector-builder.h?ref=0ecc2b7db7480fa33d31d95a114b024809cb6883", "patch": "@@ -90,7 +90,7 @@ class vector_builder : public auto_vec<T, 32>\n public:\n   vector_builder ();\n \n-  unsigned int full_nelts () const { return m_full_nelts; }\n+  poly_uint64 full_nelts () const { return m_full_nelts; }\n   unsigned int npatterns () const { return m_npatterns; }\n   unsigned int nelts_per_pattern () const { return m_nelts_per_pattern; }\n   unsigned int encoded_nelts () const;\n@@ -103,7 +103,7 @@ class vector_builder : public auto_vec<T, 32>\n   void finalize ();\n \n protected:\n-  void new_vector (unsigned int, unsigned int, unsigned int);\n+  void new_vector (poly_uint64, unsigned int, unsigned int);\n   void reshape (unsigned int, unsigned int);\n   bool repeating_sequence_p (unsigned int, unsigned int, unsigned int);\n   bool stepped_sequence_p (unsigned int, unsigned int, unsigned int);\n@@ -115,7 +115,7 @@ class vector_builder : public auto_vec<T, 32>\n   Derived *derived () { return static_cast<Derived *> (this); }\n   const Derived *derived () const;\n \n-  unsigned int m_full_nelts;\n+  poly_uint64 m_full_nelts;\n   unsigned int m_npatterns;\n   unsigned int m_nelts_per_pattern;\n };\n@@ -152,15 +152,15 @@ template<typename T, typename Derived>\n inline bool\n vector_builder<T, Derived>::encoded_full_vector_p () const\n {\n-  return m_npatterns * m_nelts_per_pattern == m_full_nelts;\n+  return known_eq (m_npatterns * m_nelts_per_pattern, m_full_nelts);\n }\n \n /* Start building a vector that has FULL_NELTS elements.  Initially\n    encode it using NPATTERNS patterns with NELTS_PER_PATTERN each.  */\n \n template<typename T, typename Derived>\n void\n-vector_builder<T, Derived>::new_vector (unsigned int full_nelts,\n+vector_builder<T, Derived>::new_vector (poly_uint64 full_nelts,\n \t\t\t\t\tunsigned int npatterns,\n \t\t\t\t\tunsigned int nelts_per_pattern)\n {\n@@ -178,7 +178,7 @@ template<typename T, typename Derived>\n bool\n vector_builder<T, Derived>::operator == (const Derived &other) const\n {\n-  if (m_full_nelts != other.m_full_nelts\n+  if (maybe_ne (m_full_nelts, other.m_full_nelts)\n       || m_npatterns != other.m_npatterns\n       || m_nelts_per_pattern != other.m_nelts_per_pattern)\n     return false;\n@@ -356,14 +356,16 @@ vector_builder<T, Derived>::finalize ()\n {\n   /* The encoding requires the same number of elements to come from each\n      pattern.  */\n-  gcc_assert (m_full_nelts % m_npatterns == 0);\n+  gcc_assert (multiple_p (m_full_nelts, m_npatterns));\n \n   /* Allow the caller to build more elements than necessary.  For example,\n      it's often convenient to build a stepped vector from the natural\n      encoding of three elements even if the vector itself only has two.  */\n-  if (m_full_nelts <= encoded_nelts ())\n+  unsigned HOST_WIDE_INT const_full_nelts;\n+  if (m_full_nelts.is_constant (&const_full_nelts)\n+      && const_full_nelts <= encoded_nelts ())\n     {\n-      m_npatterns = m_full_nelts;\n+      m_npatterns = const_full_nelts;\n       m_nelts_per_pattern = 1;\n     }\n \n@@ -435,9 +437,10 @@ vector_builder<T, Derived>::finalize ()\n \t would be for 2-bit elements.  We'll have treated them as\n \t duplicates in the loop above.  */\n       if (m_nelts_per_pattern == 1\n-\t  && this->length () >= m_full_nelts\n+\t  && m_full_nelts.is_constant (&const_full_nelts)\n+\t  && this->length () >= const_full_nelts\n \t  && (m_npatterns & 3) == 0\n-\t  && stepped_sequence_p (m_npatterns / 4, m_full_nelts,\n+\t  && stepped_sequence_p (m_npatterns / 4, const_full_nelts,\n \t\t\t\t m_npatterns / 4))\n \t{\n \t  reshape (m_npatterns / 4, 3);"}]}