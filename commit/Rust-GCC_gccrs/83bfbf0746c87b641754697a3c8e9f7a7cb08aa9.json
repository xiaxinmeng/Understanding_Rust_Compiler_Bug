{"sha": "83bfbf0746c87b641754697a3c8e9f7a7cb08aa9", "node_id": "C_kwDOANBUbNoAKDgzYmZiZjA3NDZjODdiNjQxNzU0Njk3YTNjOGU5ZjdhN2NiMDhhYTk", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-02-04T09:38:43Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-02-04T09:38:43Z"}, "message": "Merge #907\n\n907: Support cfg expansions predicates r=philberty a=philberty\n\nConfig expansion can be not, any, or all predicate to enforce the config\r\nexpansion logic.\r\n\r\nThis patch refactors the MacroParser to be named AttributeParser as it is\r\nonly used to parse attributes into MetaItems that we can work with and\r\ndo expansion logic upon. This handles the case of parsing the\r\ninner-meta-item of not(A) to parse it into MetaListNameValueStr and tidies\r\nup some of the code in the area.\r\n\r\nFixes #901\r\n\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>", "tree": {"sha": "7e33205e75ef19e8e3eefef0a1eacd678a7ce35f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7e33205e75ef19e8e3eefef0a1eacd678a7ce35f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/83bfbf0746c87b641754697a3c8e9f7a7cb08aa9", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJh/PQjCRBK7hj4Ov3rIwAAr/wIAHnwl/FTRQAXvayMSKcQk1xC\nhPUMgcbNyl5zfH3HFkmZZ6rKNuTN67wbf+3Jd2jWjFmadwhuy7nR+XBnMCqK77Vx\nlaro+NyXCSaBxNe4v2Up93qNpO6V1kAcXFfutlEQP0klbD978lkL/uBfBOoi4b6d\nndubeAXmf3XtHWX8Ksv7V+/05uy8cGBlMbp7FRsiJ+KME1Rg6GNA16WAUivjqT6Z\nXLOO5/XaG8XF7DrXsjFBSqcqwo5V/XnGW4C7mSwOB1kXZnwkNumIX8Gdtvi32Tf9\nY0DQ3zEztaA1ifaz3v5oR1vseIj44np+G1gnex+f0U22TaQnf5ZgdvbUDxQdXm0=\n=awjI\n-----END PGP SIGNATURE-----\n", "payload": "tree 7e33205e75ef19e8e3eefef0a1eacd678a7ce35f\nparent 7eef766dc5a8abda2ca2cf8d535cdf160f40b50c\nparent 9f36d99b4067df98608dc3535e6c786d1897837e\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1643967523 +0000\ncommitter GitHub <noreply@github.com> 1643967523 +0000\n\nMerge #907\n\n907: Support cfg expansions predicates r=philberty a=philberty\n\nConfig expansion can be not, any, or all predicate to enforce the config\r\nexpansion logic.\r\n\r\nThis patch refactors the MacroParser to be named AttributeParser as it is\r\nonly used to parse attributes into MetaItems that we can work with and\r\ndo expansion logic upon. This handles the case of parsing the\r\ninner-meta-item of not(A) to parse it into MetaListNameValueStr and tidies\r\nup some of the code in the area.\r\n\r\nFixes #901\r\n\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83bfbf0746c87b641754697a3c8e9f7a7cb08aa9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/83bfbf0746c87b641754697a3c8e9f7a7cb08aa9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83bfbf0746c87b641754697a3c8e9f7a7cb08aa9/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7eef766dc5a8abda2ca2cf8d535cdf160f40b50c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7eef766dc5a8abda2ca2cf8d535cdf160f40b50c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7eef766dc5a8abda2ca2cf8d535cdf160f40b50c"}, {"sha": "9f36d99b4067df98608dc3535e6c786d1897837e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f36d99b4067df98608dc3535e6c786d1897837e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9f36d99b4067df98608dc3535e6c786d1897837e"}], "stats": {"total": 185, "additions": 124, "deletions": 61}, "files": [{"sha": "68f6f8c1ab7780dc41912abcb9fa3b93c03e9c55", "filename": "gcc/rust/ast/rust-ast-full-test.cc", "status": "modified", "additions": 44, "deletions": 56, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83bfbf0746c87b641754697a3c8e9f7a7cb08aa9/gcc%2Frust%2Fast%2Frust-ast-full-test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83bfbf0746c87b641754697a3c8e9f7a7cb08aa9/gcc%2Frust%2Fast%2Frust-ast-full-test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast-full-test.cc?ref=83bfbf0746c87b641754697a3c8e9f7a7cb08aa9", "patch": "@@ -3886,6 +3886,7 @@ MetaItemInner::~MetaItemInner () = default;\n std::unique_ptr<MetaNameValueStr>\n MetaItemInner::to_meta_name_value_str () const\n {\n+  // TODO parse foo = bar\n   return nullptr;\n }\n \n@@ -4103,8 +4104,8 @@ Attribute::parse_attr_to_meta_item ()\n   if (!has_attr_input () || is_parsed_to_meta_item ())\n     return;\n \n-  std::unique_ptr<AttrInput> converted_input (\n-    attr_input->parse_to_meta_item ());\n+  auto res = attr_input->parse_to_meta_item ();\n+  std::unique_ptr<AttrInput> converted_input (res);\n \n   if (converted_input != nullptr)\n     attr_input = std::move (converted_input);\n@@ -4121,15 +4122,15 @@ DelimTokenTree::parse_to_meta_item () const\n    * to token stream */\n   std::vector<std::unique_ptr<Token> > token_stream = to_token_stream ();\n \n-  MacroParser parser (std::move (token_stream));\n+  AttributeParser parser (std::move (token_stream));\n   std::vector<std::unique_ptr<MetaItemInner> > meta_items (\n     parser.parse_meta_item_seq ());\n \n   return new AttrInputMetaItemContainer (std::move (meta_items));\n }\n \n std::unique_ptr<MetaItemInner>\n-MacroParser::parse_meta_item_inner ()\n+AttributeParser::parse_meta_item_inner ()\n {\n   // if first tok not identifier, not a \"special\" case one\n   if (peek_token ()->get_id () != IDENTIFIER)\n@@ -4144,15 +4145,15 @@ MacroParser::parse_meta_item_inner ()\n \tcase FLOAT_LITERAL:\n \tcase TRUE_LITERAL:\n \tcase FALSE_LITERAL:\n-\t  // stream_pos++;\n \t  return parse_meta_item_lit ();\n+\n \tcase SUPER:\n \tcase SELF:\n \tcase CRATE:\n \tcase DOLLAR_SIGN:\n-\t  case SCOPE_RESOLUTION: {\n-\t    return parse_path_meta_item ();\n-\t  }\n+\tcase SCOPE_RESOLUTION:\n+\t  return parse_path_meta_item ();\n+\n \tdefault:\n \t  rust_error_at (peek_token ()->get_locus (),\n \t\t\t \"unrecognised token '%s' in meta item\",\n@@ -4208,10 +4209,13 @@ MacroParser::parse_meta_item_inner ()\n       return nullptr;\n     }\n \n-  /* HACK: parse parenthesised sequence, and then try conversions to other\n-   * stuff */\n-  std::vector<std::unique_ptr<MetaItemInner> > meta_items\n-    = parse_meta_item_seq ();\n+  // is it one of those special cases like not?\n+  if (peek_token ()->get_id () == IDENTIFIER)\n+    {\n+      return parse_path_meta_item ();\n+    }\n+\n+  auto meta_items = parse_meta_item_seq ();\n \n   // pass for meta name value str\n   std::vector<MetaNameValueStr> meta_name_value_str_items;\n@@ -4234,23 +4238,25 @@ MacroParser::parse_meta_item_inner ()\n \t\t\t\t  std::move (meta_name_value_str_items)));\n     }\n \n-  // pass for meta list idents\n-  /*std::vector<Identifier> ident_items;\n-  for (const auto& item : meta_items) {\n-      std::unique_ptr<Identifier> converted_ident(item->to_ident_item());\n-      if (converted_ident == nullptr) {\n-\t  ident_items.clear();\n-\t  break;\n-      }\n-      ident_items.push_back(std::move(*converted_ident));\n-  }\n-  // if valid return this\n-  if (!ident_items.empty()) {\n-      return std::unique_ptr<MetaListIdents>(new\n-  MetaListIdents(std::move(ident),\n-  std::move(ident_items)));\n-  }*/\n-  // as currently no meta list ident, currently no path. may change in future\n+  // // pass for meta list idents\n+  // std::vector<Identifier> ident_items;\n+  // for (const auto &item : meta_items)\n+  //   {\n+  //     std::unique_ptr<Identifier> converted_ident (item->to_ident_item ());\n+  //     if (converted_ident == nullptr)\n+  //       {\n+  //         ident_items.clear ();\n+  //         break;\n+  //       }\n+  //     ident_items.push_back (std::move (*converted_ident));\n+  //   }\n+  // // if valid return this\n+  // if (!ident_items.empty ())\n+  //   {\n+  //     return std::unique_ptr<MetaListIdents> (\n+  //       new MetaListIdents (std::move (ident), std::move (ident_items)));\n+  //   }\n+  // // as currently no meta list ident, currently no path. may change in future\n \n   // pass for meta list paths\n   std::vector<SimplePath> path_items;\n@@ -4276,13 +4282,13 @@ MacroParser::parse_meta_item_inner ()\n }\n \n bool\n-MacroParser::is_end_meta_item_tok (TokenId id) const\n+AttributeParser::is_end_meta_item_tok (TokenId id) const\n {\n   return id == COMMA || id == RIGHT_PAREN;\n }\n \n std::unique_ptr<MetaItem>\n-MacroParser::parse_path_meta_item ()\n+AttributeParser::parse_path_meta_item ()\n {\n   SimplePath path = parse_simple_path ();\n   if (path.is_empty ())\n@@ -4334,15 +4340,8 @@ MacroParser::parse_path_meta_item ()\n /* Parses a parenthesised sequence of meta item inners. Parentheses are\n  * required here. */\n std::vector<std::unique_ptr<MetaItemInner> >\n-MacroParser::parse_meta_item_seq ()\n+AttributeParser::parse_meta_item_seq ()\n {\n-  if (stream_pos != 0)\n-    {\n-      // warning?\n-      rust_debug (\"WARNING: stream pos for parse_meta_item_seq is not 0!\");\n-    }\n-\n-  // int i = 0;\n   int vec_length = token_stream.size ();\n   std::vector<std::unique_ptr<MetaItemInner> > meta_items;\n \n@@ -4414,7 +4413,7 @@ DelimTokenTree::to_token_stream () const\n }\n \n Literal\n-MacroParser::parse_literal ()\n+AttributeParser::parse_literal ()\n {\n   const std::unique_ptr<Token> &tok = peek_token ();\n   switch (tok->get_id ())\n@@ -4453,7 +4452,7 @@ MacroParser::parse_literal ()\n }\n \n SimplePath\n-MacroParser::parse_simple_path ()\n+AttributeParser::parse_simple_path ()\n {\n   bool has_opening_scope_res = false;\n   if (peek_token ()->get_id () == SCOPE_RESOLUTION)\n@@ -4494,7 +4493,7 @@ MacroParser::parse_simple_path ()\n }\n \n SimplePathSegment\n-MacroParser::parse_simple_path_segment ()\n+AttributeParser::parse_simple_path_segment ()\n {\n   const std::unique_ptr<Token> &tok = peek_token ();\n   switch (tok->get_id ())\n@@ -4527,7 +4526,7 @@ MacroParser::parse_simple_path_segment ()\n }\n \n std::unique_ptr<MetaItemLitExpr>\n-MacroParser::parse_meta_item_lit ()\n+AttributeParser::parse_meta_item_lit ()\n {\n   Location locus = peek_token ()->get_locus ();\n   LiteralExpr lit_expr (parse_literal (), {}, locus);\n@@ -4538,27 +4537,16 @@ MacroParser::parse_meta_item_lit ()\n bool\n AttrInputMetaItemContainer::check_cfg_predicate (const Session &session) const\n {\n-  /* NOTE: assuming that only first item must be true - cfg should only have one\n-   * item, and cfg_attr only has first item as predicate. TODO ensure that this\n-   * is correct. */\n   if (items.empty ())\n     return false;\n \n-  // DEBUG\n-  rust_debug (\n-    \"asked to check cfg of attrinputmetaitemcontainer - delegating to \"\n-    \"first item. container: '%s'\",\n-    as_string ().c_str ());\n-\n-  return items[0]->check_cfg_predicate (session);\n-\n-  /*for (const auto &inner_item : items)\n+  for (const auto &inner_item : items)\n     {\n       if (!inner_item->check_cfg_predicate (session))\n \treturn false;\n     }\n \n-  return true;*/\n+  return true;\n }\n \n bool"}, {"sha": "0c22c37903f81b77e845a53241bccf83436ef014", "filename": "gcc/rust/ast/rust-ast.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83bfbf0746c87b641754697a3c8e9f7a7cb08aa9/gcc%2Frust%2Fast%2Frust-ast.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83bfbf0746c87b641754697a3c8e9f7a7cb08aa9/gcc%2Frust%2Fast%2Frust-ast.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast.h?ref=83bfbf0746c87b641754697a3c8e9f7a7cb08aa9", "patch": "@@ -816,7 +816,7 @@ class MetaWord;\n class MetaListPaths;\n \n // Forward decl - defined in rust-macro.h\n-struct MetaListNameValueStr;\n+class MetaListNameValueStr;\n \n /* Base statement abstract class. Note that most \"statements\" are not allowed in\n  * top-level module scope - only a subclass of statements called \"items\" are. */"}, {"sha": "6ea7de821ade5346174e2738b9c617301a19f366", "filename": "gcc/rust/ast/rust-macro.h", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83bfbf0746c87b641754697a3c8e9f7a7cb08aa9/gcc%2Frust%2Fast%2Frust-macro.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83bfbf0746c87b641754697a3c8e9f7a7cb08aa9/gcc%2Frust%2Fast%2Frust-macro.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-macro.h?ref=83bfbf0746c87b641754697a3c8e9f7a7cb08aa9", "patch": "@@ -610,6 +610,8 @@ class MetaListNameValueStr : public MetaItem\n   Identifier ident;\n   std::vector<MetaNameValueStr> strs;\n \n+  // FIXME add location info\n+\n public:\n   MetaListNameValueStr (Identifier ident, std::vector<MetaNameValueStr> strs)\n     : ident (std::move (ident)), strs (std::move (strs))\n@@ -690,20 +692,20 @@ struct ASTFragment\n // Object that parses macros from a token stream.\n /* TODO: would \"AttributeParser\" be a better name? MetaItems are only for\n  * attributes, I believe */\n-struct MacroParser\n+struct AttributeParser\n {\n private:\n   // TODO: might as well rewrite to use lexer tokens\n   std::vector<std::unique_ptr<Token> > token_stream;\n   int stream_pos;\n \n public:\n-  MacroParser (std::vector<std::unique_ptr<Token> > token_stream,\n-\t       int stream_start_pos = 0)\n+  AttributeParser (std::vector<std::unique_ptr<Token> > token_stream,\n+\t\t   int stream_start_pos = 0)\n     : token_stream (std::move (token_stream)), stream_pos (stream_start_pos)\n   {}\n \n-  ~MacroParser () = default;\n+  ~AttributeParser () = default;\n \n   std::vector<std::unique_ptr<MetaItemInner> > parse_meta_item_seq ();\n "}, {"sha": "939384c5b7dab383d0da44d4e824d8571dc76d7d", "filename": "gcc/testsuite/rust/compile/cfg2.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83bfbf0746c87b641754697a3c8e9f7a7cb08aa9/gcc%2Ftestsuite%2Frust%2Fcompile%2Fcfg2.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83bfbf0746c87b641754697a3c8e9f7a7cb08aa9/gcc%2Ftestsuite%2Frust%2Fcompile%2Fcfg2.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fcfg2.rs?ref=83bfbf0746c87b641754697a3c8e9f7a7cb08aa9", "patch": "@@ -0,0 +1,13 @@\n+// { dg-additional-options \"-w -frust-cfg=A\" }\n+struct Foo;\n+impl Foo {\n+    #[cfg(not(A))]\n+    fn test(&self) {}\n+}\n+\n+fn main() {\n+    let a = Foo;\n+    a.test();\n+    // { dg-error \"failed to resolve method for .test.\" \"\" { target *-*-* } .-1 }\n+    // { dg-error \"failed to type resolve expression\" \"\" { target *-*-* } .-2 }\n+}"}, {"sha": "d6ffab6bfc6c23e18e4b1f1ce6d02fa0d264f20b", "filename": "gcc/testsuite/rust/compile/cfg3.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83bfbf0746c87b641754697a3c8e9f7a7cb08aa9/gcc%2Ftestsuite%2Frust%2Fcompile%2Fcfg3.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83bfbf0746c87b641754697a3c8e9f7a7cb08aa9/gcc%2Ftestsuite%2Frust%2Fcompile%2Fcfg3.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fcfg3.rs?ref=83bfbf0746c87b641754697a3c8e9f7a7cb08aa9", "patch": "@@ -0,0 +1,11 @@\n+// { dg-additional-options \"-w -frust-cfg=A -frust-cfg=B\" }\n+struct Foo;\n+impl Foo {\n+    #[cfg(all(A, B))]\n+    fn test(&self) {}\n+}\n+\n+fn main() {\n+    let a = Foo;\n+    a.test();\n+}"}, {"sha": "2834c277ddfc6e2eb0943ceedeb403816b515c3e", "filename": "gcc/testsuite/rust/compile/cfg4.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83bfbf0746c87b641754697a3c8e9f7a7cb08aa9/gcc%2Ftestsuite%2Frust%2Fcompile%2Fcfg4.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83bfbf0746c87b641754697a3c8e9f7a7cb08aa9/gcc%2Ftestsuite%2Frust%2Fcompile%2Fcfg4.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fcfg4.rs?ref=83bfbf0746c87b641754697a3c8e9f7a7cb08aa9", "patch": "@@ -0,0 +1,11 @@\n+// { dg-additional-options \"-w -frust-cfg=A\" }\n+struct Foo;\n+impl Foo {\n+    #[cfg(any(A, B))]\n+    fn test(&self) {}\n+}\n+\n+fn main() {\n+    let a = Foo;\n+    a.test();\n+}"}, {"sha": "d1c2a22a0ffc0c58e4e8cdcb60e1cf6e1982057b", "filename": "gcc/testsuite/rust/execute/torture/cfg4.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83bfbf0746c87b641754697a3c8e9f7a7cb08aa9/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fcfg4.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83bfbf0746c87b641754697a3c8e9f7a7cb08aa9/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fcfg4.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fcfg4.rs?ref=83bfbf0746c87b641754697a3c8e9f7a7cb08aa9", "patch": "@@ -0,0 +1,38 @@\n+// { dg-additional-options \"-w -frust-cfg=A\" }\n+// { dg-output \"test1\\ntest2\\n\" }\n+extern \"C\" {\n+    fn printf(s: *const i8, ...);\n+}\n+\n+struct Foo(i32);\n+impl Foo {\n+    #[cfg(A)]\n+    fn test(&self) {\n+        unsafe {\n+            let a = \"test1\\n\\0\";\n+            let b = a as *const str;\n+            let c = b as *const i8;\n+\n+            printf(c);\n+        }\n+    }\n+\n+    #[cfg(not(B))]\n+    fn test2(&self) {\n+        unsafe {\n+            let a = \"test2\\n\\0\";\n+            let b = a as *const str;\n+            let c = b as *const i8;\n+\n+            printf(c);\n+        }\n+    }\n+}\n+\n+fn main() -> i32 {\n+    let a = Foo(123);\n+    a.test();\n+    a.test2();\n+\n+    0\n+}"}]}