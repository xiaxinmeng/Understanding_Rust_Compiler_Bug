{"sha": "2e362c747413dc3767d020f522df127964b275ac", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmUzNjJjNzQ3NDEzZGMzNzY3ZDAyMGY1MjJkZjEyNzk2NGIyNzVhYw==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@redhat.com", "date": "2006-09-14T09:48:15Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2006-09-14T09:48:15Z"}, "message": "atomicity.h: Move to...\n\n2006-09-13  Benjamin Kosnik  <bkoz@redhat.com>\n\n\t* include/bits/atomicity.h: Move to...\n\t* include/ext/atomicity.h: ...here.\t\n\t* include/bits/concurrence.h: Move to...\n\t* include/ext/concurrence.h: ...here.\n\t* include/Makefile.am (ext_headers): Additions.\n\t(bits_headers): Subtractions.\n\t* include/Makefile.in: Regenerate.\n\n\t* include/ext/bitmap_allocator.h (_Mutex), __threads_enabled,\n\t_Lock, _Auto_Lock): Subsume into...\n\t* include/bits/concurrence.h (__mutex): ..this. Error check\n\tlocking and unlocking.\t\n\t(lock): Uglify to...\n\t(__scoped_lock): Use __mutex. \n\t(__glibcxx_mutex_define_initialized): Remove.\n\t(__glibcxx_mutex_type): Remove.\n\n\t* include/tr1/boost_shared_ptr.h: Formating tweaks, adjustments.\n\t(_Lock_policy): Move from here...\n\t* include/ext/concurrence.h: ... to here.\n\t(__shared_ptr_default_lock_mode): To __default_lock_policy.\n\t(_S_lockfree): To _S_atomic.\n\tDocument.\n\n\t* libsupc++/guard.cc (static_mutex): Subsume into and fixup for...\n\t* include/ext/concurrence.h (__recursive_mutex): ...this. Error\n\tcheck locking and unlocking.\n\t* libsupc++/eh_alloc.cc: Use __scoped_lock.\n\n\t* config/os/aix/atomicity.h: Fixups for include paths, mutex to\n\t__scoped_mutex change, removal of locking defines.\n\t* config/os/irix/atomicity.h: Same.\n\t* config/cpu/cris/atomicity.h: Same.\n\t* config/cpu/m68k/atomicity.h: Same.\n\t* config/cpu/hppa/atomicity.h: Same.\n\t* config/cpu/mips/atomicity.h: Same.\n\t* config/cpu/sparc/atomicity.h: Same.\n\t* config/cpu/i386/atomicity.h: Same.\n\t* config/cpu/i486/atomicity.h: Same.\n\t* config/cpu/sh/atomicity.h: Same.\n\t* config/cpu/generic/atomicity_mutex/atomicity.h: Same.\n\t* include/ext/pool_allocator.h: Same.\n\t* include/ext/bitmap_allocator.h: Same.\n\t* include/ext/rc_string_base.h: Same.\n\t* include/ext/mt_allocator.h: Same.\n\t* include/bits/locale_classes.h: Same.\n\t* include/bits/basic_string.h: Same.\n\t* include/bits/ios_base.h: Same.\n\t* include/tr1/memory: Same.\n\t* src/pool_allocator.cc: Same.\n\t* src/mt_allocator.cc: Same.\n\t* src/locale_init.cc: Same.\n\t* src/ios.cc: Same.\n\t* src/locale.cc: Same.\n\t* src/bitmap_allocator.cc: Same.\n\t* src/ios_init.cc: Same.\n\t* src/debug.cc: Same.\n\nFrom-SVN: r116942", "tree": {"sha": "eef2837703208f056261f360e2ea7f39d3036693", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eef2837703208f056261f360e2ea7f39d3036693"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2e362c747413dc3767d020f522df127964b275ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e362c747413dc3767d020f522df127964b275ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e362c747413dc3767d020f522df127964b275ac", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e362c747413dc3767d020f522df127964b275ac/comments", "author": null, "committer": null, "parents": [{"sha": "06fcf75439fbafae348fa33a0630f7bd83a835aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06fcf75439fbafae348fa33a0630f7bd83a835aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/06fcf75439fbafae348fa33a0630f7bd83a835aa"}], "stats": {"total": 1405, "additions": 602, "deletions": 803}, "files": [{"sha": "3d5f8798bd5e1ee2c610cfcf837105001a6d2633", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e362c747413dc3767d020f522df127964b275ac/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e362c747413dc3767d020f522df127964b275ac/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=2e362c747413dc3767d020f522df127964b275ac", "patch": "@@ -1,3 +1,63 @@\n+2006-09-13  Benjamin Kosnik  <bkoz@redhat.com>\n+\n+\t* include/bits/atomicity.h: Move to...\n+\t* include/ext/atomicity.h: ...here.\t\n+\t* include/bits/concurrence.h: Move to...\n+\t* include/ext/concurrence.h: ...here.\n+\t* include/Makefile.am (ext_headers): Additions.\n+\t(bits_headers): Subtractions.\n+\t* include/Makefile.in: Regenerate.\n+\n+\t* include/ext/bitmap_allocator.h (_Mutex), __threads_enabled,\n+\t_Lock, _Auto_Lock): Subsume into...\n+\t* include/bits/concurrence.h (__mutex): ..this. Error check\n+\tlocking and unlocking.\t\n+\t(lock): Uglify to...\n+\t(__scoped_lock): Use __mutex. \n+\t(__glibcxx_mutex_define_initialized): Remove.\n+\t(__glibcxx_mutex_type): Remove.\n+\n+\t* include/tr1/boost_shared_ptr.h: Formating tweaks, adjustments.\n+\t(_Lock_policy): Move from here...\n+\t* include/ext/concurrence.h: ... to here.\n+\t(__shared_ptr_default_lock_mode): To __default_lock_policy.\n+\t(_S_lockfree): To _S_atomic.\n+\tDocument.\n+\n+\t* libsupc++/guard.cc (static_mutex): Subsume into and fixup for...\n+\t* include/ext/concurrence.h (__recursive_mutex): ...this. Error\n+\tcheck locking and unlocking.\n+\t* libsupc++/eh_alloc.cc: Use __scoped_lock.\n+\n+\t* config/os/aix/atomicity.h: Fixups for include paths, mutex to\n+\t__scoped_mutex change, removal of locking defines.\n+\t* config/os/irix/atomicity.h: Same.\n+\t* config/cpu/cris/atomicity.h: Same.\n+\t* config/cpu/m68k/atomicity.h: Same.\n+\t* config/cpu/hppa/atomicity.h: Same.\n+\t* config/cpu/mips/atomicity.h: Same.\n+\t* config/cpu/sparc/atomicity.h: Same.\n+\t* config/cpu/i386/atomicity.h: Same.\n+\t* config/cpu/i486/atomicity.h: Same.\n+\t* config/cpu/sh/atomicity.h: Same.\n+\t* config/cpu/generic/atomicity_mutex/atomicity.h: Same.\n+\t* include/ext/pool_allocator.h: Same.\n+\t* include/ext/bitmap_allocator.h: Same.\n+\t* include/ext/rc_string_base.h: Same.\n+\t* include/ext/mt_allocator.h: Same.\n+\t* include/bits/locale_classes.h: Same.\n+\t* include/bits/basic_string.h: Same.\n+\t* include/bits/ios_base.h: Same.\n+\t* include/tr1/memory: Same.\n+\t* src/pool_allocator.cc: Same.\n+\t* src/mt_allocator.cc: Same.\n+\t* src/locale_init.cc: Same.\n+\t* src/ios.cc: Same.\n+\t* src/locale.cc: Same.\n+\t* src/bitmap_allocator.cc: Same.\n+\t* src/ios_init.cc: Same.\n+\t* src/debug.cc: Same.\n+\t\n 2006-09-12  Benjamin Kosnik  <bkoz@redhat.com>\n \n \t* libsupc++/eh_globals.cc: Remove __gnu_internal."}, {"sha": "da16a1aacee7ba79f0b3cf3c948f1bfc867dd4d4", "filename": "libstdc++-v3/config/cpu/cris/atomicity.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e362c747413dc3767d020f522df127964b275ac/libstdc%2B%2B-v3%2Fconfig%2Fcpu%2Fcris%2Fatomicity.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e362c747413dc3767d020f522df127964b275ac/libstdc%2B%2B-v3%2Fconfig%2Fcpu%2Fcris%2Fatomicity.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fcpu%2Fcris%2Fatomicity.h?ref=2e362c747413dc3767d020f522df127964b275ac", "patch": "@@ -27,7 +27,7 @@\n // invalidate any other reasons why the executable file might be covered by\n // the GNU General Public License.\n \n-#include <bits/atomicity.h>\n+#include <ext/atomicity.h>\n \n _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n "}, {"sha": "b54309ea2bbd2a62b15a5ba9de522a9c9b7be5b7", "filename": "libstdc++-v3/config/cpu/generic/atomicity_mutex/atomicity.h", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e362c747413dc3767d020f522df127964b275ac/libstdc%2B%2B-v3%2Fconfig%2Fcpu%2Fgeneric%2Fatomicity_mutex%2Fatomicity.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e362c747413dc3767d020f522df127964b275ac/libstdc%2B%2B-v3%2Fconfig%2Fcpu%2Fgeneric%2Fatomicity_mutex%2Fatomicity.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fcpu%2Fgeneric%2Fatomicity_mutex%2Fatomicity.h?ref=2e362c747413dc3767d020f522df127964b275ac", "patch": "@@ -28,12 +28,12 @@\n // invalidate any other reasons why the executable file might be covered by\n // the GNU General Public License.\n \n-#include <bits/atomicity.h>\n-#include <bits/concurrence.h>\n+#include <ext/atomicity.h>\n+#include <ext/concurrence.h>\n \n namespace \n {\n-  __glibcxx_mutex_define_initialized(atomic_mutex);\n+  __gnu_cxx::__mutex atomic_mutex;\n } // anonymous namespace\n \n _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n@@ -42,11 +42,10 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n   __attribute__ ((__unused__))\n   __exchange_and_add(volatile _Atomic_word* __mem, int __val)\n   {\n-    __glibcxx_mutex_lock(atomic_mutex);\n+    __gnu_cxx::__scoped_lock sentry(atomic_mutex);\n     _Atomic_word __result;\n     __result = *__mem;\n     *__mem += __val;\n-    __glibcxx_mutex_unlock(atomic_mutex);\n     return __result;\n   }\n "}, {"sha": "76c09e046fb5921cb12ca1b3e61287e9b8f6c1a4", "filename": "libstdc++-v3/config/cpu/hppa/atomicity.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e362c747413dc3767d020f522df127964b275ac/libstdc%2B%2B-v3%2Fconfig%2Fcpu%2Fhppa%2Fatomicity.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e362c747413dc3767d020f522df127964b275ac/libstdc%2B%2B-v3%2Fconfig%2Fcpu%2Fhppa%2Fatomicity.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fcpu%2Fhppa%2Fatomicity.h?ref=2e362c747413dc3767d020f522df127964b275ac", "patch": "@@ -28,7 +28,7 @@\n // the GNU General Public License.\n \n #include <bits/c++config.h>\n-#include <bits/atomicity.h>\n+#include <ext/atomicity.h>\n \n _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n "}, {"sha": "7232b5b26e46a6edb64e430447c4a3fea9a75db2", "filename": "libstdc++-v3/config/cpu/i386/atomicity.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e362c747413dc3767d020f522df127964b275ac/libstdc%2B%2B-v3%2Fconfig%2Fcpu%2Fi386%2Fatomicity.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e362c747413dc3767d020f522df127964b275ac/libstdc%2B%2B-v3%2Fconfig%2Fcpu%2Fi386%2Fatomicity.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fcpu%2Fi386%2Fatomicity.h?ref=2e362c747413dc3767d020f522df127964b275ac", "patch": "@@ -27,7 +27,7 @@\n // invalidate any other reasons why the executable file might be covered by\n // the GNU General Public License.\n \n-#include <bits/atomicity.h>\n+#include <ext/atomicity.h>\n \n _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n "}, {"sha": "4d8f652935813a79b4bf27f7ac36533cb5983c7e", "filename": "libstdc++-v3/config/cpu/i486/atomicity.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e362c747413dc3767d020f522df127964b275ac/libstdc%2B%2B-v3%2Fconfig%2Fcpu%2Fi486%2Fatomicity.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e362c747413dc3767d020f522df127964b275ac/libstdc%2B%2B-v3%2Fconfig%2Fcpu%2Fi486%2Fatomicity.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fcpu%2Fi486%2Fatomicity.h?ref=2e362c747413dc3767d020f522df127964b275ac", "patch": "@@ -27,7 +27,7 @@\n // invalidate any other reasons why the executable file might be covered by\n // the GNU General Public License.\n \n-#include <bits/atomicity.h>\n+#include <ext/atomicity.h>\n \n _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n "}, {"sha": "f63b582a9768ba114bde447b24fe22811bde5ace", "filename": "libstdc++-v3/config/cpu/m68k/atomicity.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e362c747413dc3767d020f522df127964b275ac/libstdc%2B%2B-v3%2Fconfig%2Fcpu%2Fm68k%2Fatomicity.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e362c747413dc3767d020f522df127964b275ac/libstdc%2B%2B-v3%2Fconfig%2Fcpu%2Fm68k%2Fatomicity.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fcpu%2Fm68k%2Fatomicity.h?ref=2e362c747413dc3767d020f522df127964b275ac", "patch": "@@ -27,7 +27,7 @@\n // invalidate any other reasons why the executable file might be covered by\n // the GNU General Public License.\n \n-#include <bits/atomicity.h>\n+#include <ext/atomicity.h>\n \n _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n "}, {"sha": "2989fa442785ac5847d87d0ef7a45c070183b83a", "filename": "libstdc++-v3/config/cpu/mips/atomicity.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e362c747413dc3767d020f522df127964b275ac/libstdc%2B%2B-v3%2Fconfig%2Fcpu%2Fmips%2Fatomicity.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e362c747413dc3767d020f522df127964b275ac/libstdc%2B%2B-v3%2Fconfig%2Fcpu%2Fmips%2Fatomicity.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fcpu%2Fmips%2Fatomicity.h?ref=2e362c747413dc3767d020f522df127964b275ac", "patch": "@@ -28,7 +28,7 @@\n // invalidate any other reasons why the executable file might be covered by\n // the GNU General Public License.\n \n-#include <bits/atomicity.h>\n+#include <ext/atomicity.h>\n \n _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n "}, {"sha": "d200818f66d3732e82faaced922a97748e92b933", "filename": "libstdc++-v3/config/cpu/sh/atomicity.h", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e362c747413dc3767d020f522df127964b275ac/libstdc%2B%2B-v3%2Fconfig%2Fcpu%2Fsh%2Fatomicity.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e362c747413dc3767d020f522df127964b275ac/libstdc%2B%2B-v3%2Fconfig%2Fcpu%2Fsh%2Fatomicity.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fcpu%2Fsh%2Fatomicity.h?ref=2e362c747413dc3767d020f522df127964b275ac", "patch": "@@ -74,12 +74,12 @@ __atomic_add (volatile _Atomic_word* __mem, int __val)\n \n /* This is generic/atomicity.h */\n \n-#include <bits/atomicity.h>\n-#include <bits/concurrence.h>\n+#include <ext/atomicity.h>\n+#include <ext/concurrence.h>\n \n namespace \n {\n-  __glibcxx_mutex_define_initialized(atomic_mutex);\n+  __gnu_cxx::__mutex atomic_mutex;\n } // anonymous namespace\n \n _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n@@ -88,11 +88,10 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n   __attribute__ ((__unused__))\n   __exchange_and_add(volatile _Atomic_word* __mem, int __val)\n   {\n-    __glibcxx_mutex_lock(atomic_mutex);\n+    __gnu_cxx::__scoped_lock sentry(atomic_mutex);\n     _Atomic_word __result;\n     __result = *__mem;\n     *__mem += __val;\n-    __glibcxx_mutex_unlock(atomic_mutex);\n     return __result;\n   }\n "}, {"sha": "5fec033e6a7a9365609b2f3809e1c8438684e86c", "filename": "libstdc++-v3/config/cpu/sparc/atomicity.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e362c747413dc3767d020f522df127964b275ac/libstdc%2B%2B-v3%2Fconfig%2Fcpu%2Fsparc%2Fatomicity.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e362c747413dc3767d020f522df127964b275ac/libstdc%2B%2B-v3%2Fconfig%2Fcpu%2Fsparc%2Fatomicity.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fcpu%2Fsparc%2Fatomicity.h?ref=2e362c747413dc3767d020f522df127964b275ac", "patch": "@@ -28,7 +28,7 @@\n // invalidate any other reasons why the executable file might be covered by\n // the GNU General Public License.\n \n-#include <bits/atomicity.h>\n+#include <ext/atomicity.h>\n \n _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n "}, {"sha": "38c1ee368a9229097bacf316bf0aeafd199846af", "filename": "libstdc++-v3/config/os/aix/atomicity.h", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e362c747413dc3767d020f522df127964b275ac/libstdc%2B%2B-v3%2Fconfig%2Fos%2Faix%2Fatomicity.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e362c747413dc3767d020f522df127964b275ac/libstdc%2B%2B-v3%2Fconfig%2Fos%2Faix%2Fatomicity.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fos%2Faix%2Fatomicity.h?ref=2e362c747413dc3767d020f522df127964b275ac", "patch": "@@ -27,7 +27,7 @@\n // invalidate any other reasons why the executable file might be covered by\n // the GNU General Public License.\n \n-#include <bits/atomicity.h>\n+#include <ext/atomicity.h>\n \n /* We cannot use the cpu/powerpc/bits/atomicity.h inline assembly\n    definitions for these operations since they depend on operations\n@@ -48,15 +48,11 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n   _Atomic_word\n   __attribute__ ((__unused__))\n   __exchange_and_add (volatile _Atomic_word* __mem, int __val)\n-  {\n-    return ::fetch_and_add (const_cast<atomic_p>(__mem), __val);\n-  }\n+  { return ::fetch_and_add(const_cast<atomic_p>(__mem), __val); }\n \n   void\n   __attribute__ ((__unused__))\n   __atomic_add (volatile _Atomic_word* __mem, int __val)\n-  {\n-    (void) ::fetch_and_add (const_cast<atomic_p>(__mem), __val);\n-  }\n+  { (void) ::fetch_and_add(const_cast<atomic_p>(__mem), __val); }\n \n _GLIBCXX_END_NAMESPACE"}, {"sha": "ebb3dfb5e8a675fba3c2c6e33fdef0ac8f10059c", "filename": "libstdc++-v3/config/os/irix/atomicity.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e362c747413dc3767d020f522df127964b275ac/libstdc%2B%2B-v3%2Fconfig%2Fos%2Firix%2Fatomicity.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e362c747413dc3767d020f522df127964b275ac/libstdc%2B%2B-v3%2Fconfig%2Fos%2Firix%2Fatomicity.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fos%2Firix%2Fatomicity.h?ref=2e362c747413dc3767d020f522df127964b275ac", "patch": "@@ -28,7 +28,7 @@\n // the GNU General Public License.\n \n #include <mutex.h>\n-#include <bits/atomicity.h>\n+#include <ext/atomicity.h>\n \n _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n "}, {"sha": "0940be8f7f829aafb91b7eb8b048968ed97999dc", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e362c747413dc3767d020f522df127964b275ac/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e362c747413dc3767d020f522df127964b275ac/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=2e362c747413dc3767d020f522df127964b275ac", "patch": "@@ -93,7 +93,6 @@ bits_srcdir = ${glibcxx_srcdir}/include/bits\n bits_builddir = ./bits\n bits_headers = \\\n \t${bits_srcdir}/allocator.h \\\n-\t${bits_srcdir}/atomicity.h \\\n \t${bits_srcdir}/basic_ios.h \\\n \t${bits_srcdir}/basic_ios.tcc \\\n \t${bits_srcdir}/basic_string.h \\\n@@ -102,7 +101,6 @@ bits_headers = \\\n \t${bits_srcdir}/char_traits.h \\\n \t${bits_srcdir}/codecvt.h \\\n \t${bits_srcdir}/concept_check.h \\\n-\t${bits_srcdir}/concurrence.h \\\n \t${bits_srcdir}/cpp_type_traits.h \\\n \t${bits_srcdir}/deque.tcc \\\n \t${bits_srcdir}/fstream.tcc \\\n@@ -529,9 +527,11 @@ ext_srcdir = ${glibcxx_srcdir}/include/ext\n ext_builddir = ./ext \n ext_headers = \\\n \t${ext_srcdir}/algorithm \\\n+\t${ext_srcdir}/atomicity.h \\\n \t${ext_srcdir}/array_allocator.h \\\n \t${ext_srcdir}/bitmap_allocator.h \\\n \t${ext_srcdir}/codecvt_specializations.h \\\n+\t${ext_srcdir}/concurrence.h \\\n \t${ext_srcdir}/debug_allocator.h \\\n \t${ext_srcdir}/stdio_filebuf.h \\\n \t${ext_srcdir}/stdio_sync_filebuf.h \\"}, {"sha": "51ad224e45bfda0bc855bd9287bf783a5a7654b6", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e362c747413dc3767d020f522df127964b275ac/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e362c747413dc3767d020f522df127964b275ac/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=2e362c747413dc3767d020f522df127964b275ac", "patch": "@@ -318,7 +318,6 @@ bits_srcdir = ${glibcxx_srcdir}/include/bits\n bits_builddir = ./bits\n bits_headers = \\\n \t${bits_srcdir}/allocator.h \\\n-\t${bits_srcdir}/atomicity.h \\\n \t${bits_srcdir}/basic_ios.h \\\n \t${bits_srcdir}/basic_ios.tcc \\\n \t${bits_srcdir}/basic_string.h \\\n@@ -327,7 +326,6 @@ bits_headers = \\\n \t${bits_srcdir}/char_traits.h \\\n \t${bits_srcdir}/codecvt.h \\\n \t${bits_srcdir}/concept_check.h \\\n-\t${bits_srcdir}/concurrence.h \\\n \t${bits_srcdir}/cpp_type_traits.h \\\n \t${bits_srcdir}/deque.tcc \\\n \t${bits_srcdir}/fstream.tcc \\\n@@ -750,9 +748,11 @@ ext_srcdir = ${glibcxx_srcdir}/include/ext\n ext_builddir = ./ext \n ext_headers = \\\n \t${ext_srcdir}/algorithm \\\n+\t${ext_srcdir}/atomicity.h \\\n \t${ext_srcdir}/array_allocator.h \\\n \t${ext_srcdir}/bitmap_allocator.h \\\n \t${ext_srcdir}/codecvt_specializations.h \\\n+\t${ext_srcdir}/concurrence.h \\\n \t${ext_srcdir}/debug_allocator.h \\\n \t${ext_srcdir}/stdio_filebuf.h \\\n \t${ext_srcdir}/stdio_sync_filebuf.h \\"}, {"sha": "3e4f19d727518bfdef469e78dfbb2998aa5ea1e4", "filename": "libstdc++-v3/include/bits/basic_string.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e362c747413dc3767d020f522df127964b275ac/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_string.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e362c747413dc3767d020f522df127964b275ac/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_string.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_string.h?ref=2e362c747413dc3767d020f522df127964b275ac", "patch": "@@ -42,7 +42,7 @@\n \n #pragma GCC system_header\n \n-#include <bits/atomicity.h>\n+#include <ext/atomicity.h>\n #include <debug/debug.h>\n \n _GLIBCXX_BEGIN_NAMESPACE(std)"}, {"sha": "81bf2a6215a64d169e6602ea417d686d151d7898", "filename": "libstdc++-v3/include/bits/concurrence.h", "status": "removed", "additions": 0, "deletions": 101, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06fcf75439fbafae348fa33a0630f7bd83a835aa/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fconcurrence.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06fcf75439fbafae348fa33a0630f7bd83a835aa/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fconcurrence.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fconcurrence.h?ref=06fcf75439fbafae348fa33a0630f7bd83a835aa", "patch": "@@ -1,101 +0,0 @@\n-// Support for concurrent programing -*- C++ -*-\n-\n-// Copyright (C) 2003, 2004, 2005\n-// Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING.  If not, write to the Free\n-// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n-// USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-/** @file concurrence.h\n- *  This is an internal header file, included by other library headers.\n- *  You should not attempt to use it directly.\n- */\n-\n-#ifndef _CONCURRENCE_H\n-#define _CONCURRENCE_H 1\n-\n-// GCC's thread abstraction layer\n-#include \"bits/gthr.h\"\n-\n-#if __GTHREADS\n-\n-# ifdef __GTHREAD_MUTEX_INIT\n-#  define __glibcxx_mutex_type __gthread_mutex_t\n-#  define __glibcxx_mutex_define_initialized(NAME) \\\n-__gthread_mutex_t NAME = __GTHREAD_MUTEX_INIT\n-#  define __glibcxx_mutex_lock(NAME) \\\n-__gthread_mutex_lock(&NAME)\n-# else\n-// Implies __GTHREAD_MUTEX_INIT_FUNCTION\n-struct __glibcxx_mutex : public __gthread_mutex_t\n-{\n-   __glibcxx_mutex() { __GTHREAD_MUTEX_INIT_FUNCTION(this); }\n-};\n-\n-#  define __glibcxx_mutex_type __glibcxx_mutex\n-#  define __glibcxx_mutex_define_initialized(NAME) \\\n-__glibcxx_mutex NAME\n-# define __glibcxx_mutex_lock(NAME) \\\n-__gthread_mutex_lock(&NAME)\n-# endif\n-\n-# define __glibcxx_mutex_unlock(NAME) __gthread_mutex_unlock(&NAME)\n-\n-#else\n-\n-# define __glibcxx_mutex_type __gthread_mutex_t\n-# define __glibcxx_mutex_define_initialized(NAME) __gthread_mutex_t NAME\n-# define __glibcxx_mutex_lock(NAME)\n-# define __glibcxx_mutex_unlock(NAME)\n-\n-#endif\n-\n-_GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n-\n-  typedef __glibcxx_mutex_type mutex_type;\n-  \n-  /// @brief  Scoped lock idiom.\n-  // Acquire the mutex here with a constructor call, then release with\n-  // the destructor call in accordance with RAII style.\n-  class lock\n-  {\n-    // Externally defined and initialized.\n-    mutex_type& device;\n-\n-  public:\n-    explicit lock(mutex_type& name) : device(name)\n-    { __glibcxx_mutex_lock(device); }\n-\n-    ~lock() throw()\n-    { __glibcxx_mutex_unlock(device); }\n-\n-  private:\n-    lock(const lock&);\n-    lock& operator=(const lock&);\n-  };\n-\n-_GLIBCXX_END_NAMESPACE\n-\n-#endif"}, {"sha": "5cbdfab4e7799e9dd9a95e43ad53d80372dea15b", "filename": "libstdc++-v3/include/bits/ios_base.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e362c747413dc3767d020f522df127964b275ac/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fios_base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e362c747413dc3767d020f522df127964b275ac/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fios_base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fios_base.h?ref=2e362c747413dc3767d020f522df127964b275ac", "patch": "@@ -42,7 +42,7 @@\n \n #pragma GCC system_header\n \n-#include <bits/atomicity.h>\n+#include <ext/atomicity.h>\n #include <bits/localefwd.h>\n #include <bits/locale_classes.h>\n "}, {"sha": "9fbac9e2ac7ec05c601e75e8e52ce6a4e8ca11e8", "filename": "libstdc++-v3/include/bits/locale_classes.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e362c747413dc3767d020f522df127964b275ac/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_classes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e362c747413dc3767d020f522df127964b275ac/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_classes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_classes.h?ref=2e362c747413dc3767d020f522df127964b275ac", "patch": "@@ -45,8 +45,7 @@\n #include <bits/localefwd.h>\n #include <cstring>\t\t// For strcmp.\n #include <string>\n-#include <bits/atomicity.h>\n-#include <bits/gthr.h>\n+#include <ext/atomicity.h>\n \n _GLIBCXX_BEGIN_NAMESPACE(std)\n "}, {"sha": "975121e876b38ee249922b501c547e30f500c2e6", "filename": "libstdc++-v3/include/ext/atomicity.h", "status": "renamed", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e362c747413dc3767d020f522df127964b275ac/libstdc%2B%2B-v3%2Finclude%2Fext%2Fatomicity.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e362c747413dc3767d020f522df127964b275ac/libstdc%2B%2B-v3%2Finclude%2Fext%2Fatomicity.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fatomicity.h?ref=2e362c747413dc3767d020f522df127964b275ac", "patch": "@@ -1,4 +1,4 @@\n-// Low-level functions for atomic operations -*- C++ -*-\n+// Support for atomic operations -*- C++ -*-\n \n // Copyright (C) 2004, 2005, 2006 Free Software Foundation, Inc.\n //\n@@ -41,6 +41,10 @@\n \n _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n \n+  // Functions for portable atomic access.\n+  // To abstract locking primatives across all thread policies, use:\n+  // __exchange_and_add_dispatch\n+  // __atomic_add_dispatch\n #ifdef _GLIBCXX_ATOMIC_BUILTINS\n   static inline _Atomic_word \n   __exchange_and_add(volatile _Atomic_word* __mem, int __val)\n@@ -52,11 +56,11 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n #else\n   _Atomic_word\n   __attribute__ ((__unused__))\n-  __exchange_and_add(volatile _Atomic_word* __mem, int __val);\n+  __exchange_and_add(volatile _Atomic_word*, int);\n \n   void\n   __attribute__ ((__unused__))\n-  __atomic_add(volatile _Atomic_word* __mem, int __val);\n+  __atomic_add(volatile _Atomic_word*, int);\n #endif\n \n   static inline _Atomic_word", "previous_filename": "libstdc++-v3/include/bits/atomicity.h"}, {"sha": "5dbe28600ebd89164ebcdf497a4d25c926e5ac26", "filename": "libstdc++-v3/include/ext/bitmap_allocator.h", "status": "modified", "additions": 29, "deletions": 179, "changes": 208, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e362c747413dc3767d020f522df127964b275ac/libstdc%2B%2B-v3%2Finclude%2Fext%2Fbitmap_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e362c747413dc3767d020f522df127964b275ac/libstdc%2B%2B-v3%2Finclude%2Fext%2Fbitmap_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fbitmap_allocator.h?ref=2e362c747413dc3767d020f522df127964b275ac", "patch": "@@ -34,25 +34,13 @@\n #ifndef _BITMAP_ALLOCATOR_H\n #define _BITMAP_ALLOCATOR_H 1\n \n-// For std::size_t, and ptrdiff_t.\n-#include <cstddef>\n-\n-// For __throw_bad_alloc().\n-#include <bits/functexcept.h>\n-\n-// For std::pair.\n-#include <utility>\n-\n-// For greater_equal, and less_equal.\n-#include <functional>\n-\n-// For operator new.\n-#include <new>\n-\n-// For __gthread_mutex_t, __gthread_mutex_lock and __gthread_mutex_unlock.\n-#include <bits/gthr.h>\n-\n+#include <cstddef> // For std::size_t, and ptrdiff_t.\n+#include <bits/functexcept.h> // For __throw_bad_alloc().\n+#include <utility> // For std::pair.\n+#include <functional> // For greater_equal, and less_equal.\n+#include <new> // For operator new.\n #include <debug/debug.h> // _GLIBCXX_DEBUG_ASSERT\n+#include <ext/concurrence.h>\n \n \n /** @brief The constant in the expression below is the alignment\n@@ -65,144 +53,6 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n   using std::size_t;\n   using std::ptrdiff_t;\n \n-#if defined __GTHREADS\n-  namespace\n-  {\n-    /** @brief  If true, then the application being compiled will be\n-     *  using threads, so use mutexes as a synchronization primitive,\n-     *  else do no use any synchronization primitives.\n-     */\n-    bool const __threads_enabled = __gthread_active_p();\n-  } // anonymous namespace\n-#endif\n-\n-#if defined __GTHREADS\n-  /** @class  _Mutex bitmap_allocator.h bitmap_allocator.h\n-   *\n-   *  @brief  _Mutex is an OO-Wrapper for __gthread_mutex_t. \n-   *\n-   *  It does not allow you to copy or assign an already initialized\n-   *  mutex. This is used merely as a convenience for the locking\n-   *  classes.\n-   */\n-  class _Mutex \n-  {\n-    __gthread_mutex_t _M_mut;\n-\n-    // Prevent Copying and assignment.\n-    _Mutex(_Mutex const&);\n-    _Mutex& operator=(_Mutex const&);\n-\n-  public:\n-    _Mutex()\n-    {\n-      if (__threads_enabled)\n-\t{\n-#if !defined __GTHREAD_MUTEX_INIT\n-\t  __GTHREAD_MUTEX_INIT_FUNCTION(&_M_mut);\n-#else\n-\t  __gthread_mutex_t __mtemp = __GTHREAD_MUTEX_INIT;\n-\t  _M_mut = __mtemp;\n-#endif\n-\t}\n-    }\n-\n-    ~_Mutex()\n-    {\n-      // Gthreads does not define a Mutex Destruction Function.\n-    }\n-\n-    __gthread_mutex_t*\n-    _M_get() { return &_M_mut; }\n-  };\n-\n-  /** @class  _Lock bitmap_allocator.h bitmap_allocator.h\n-   *\n-   *  @brief  _Lock is a simple manual locking class which allows you to\n-   *  manually lock and unlock a mutex associated with the lock. \n-   *\n-   *  There is no automatic locking or unlocking happening without the\n-   *  programmer's explicit instructions. This class unlocks the mutex\n-   *  ONLY if it has not been locked. However, this check does not\n-   *  apply for locking, and wayward use may cause dead-locks.\n-   */\n-  class _Lock \n-  {\n-    _Mutex* _M_pmt;\n-    bool _M_locked;\n-\n-    // Prevent Copying and assignment.\n-    _Lock(_Lock const&);\n-    _Lock& operator=(_Lock const&);\n-\n-  public:\n-    _Lock(_Mutex* __mptr)\n-    : _M_pmt(__mptr), _M_locked(false)\n-    { }\n-\n-    void\n-    _M_lock()\n-    {\n-      if (__threads_enabled)\n-\t{\n-\t  _M_locked = true;\n-\t  __gthread_mutex_lock(_M_pmt->_M_get());\n-\t}\n-    }\n-\n-    void\n-    _M_unlock()\n-    {\n-      if (__threads_enabled)\n-\t{\n-\t  if (__builtin_expect(_M_locked, true))\n-\t    {\n-\t      __gthread_mutex_unlock(_M_pmt->_M_get());\n-\t      _M_locked = false;\n-\t    }\n-\t}\n-    }\n-    \n-    ~_Lock() { }\n-  };\n-\n-  /** @class  _Auto_Lock bitmap_allocator.h bitmap_allocator.h\n-   *\n-   *  @brief  _Auto_Lock locks the associated mutex on construction, and\n-   *  unlocks on destruction.\n-   *\n-   *  There are no checks performed, and this class follows the RAII\n-   *  principle.\n-   */\n-  class _Auto_Lock \n-  {\n-    _Mutex* _M_pmt;\n-    // Prevent Copying and assignment.\n-    _Auto_Lock(_Auto_Lock const&);\n-    _Auto_Lock& operator=(_Auto_Lock const&);\n-\n-    void\n-    _M_lock()\n-    {\n-      if (__threads_enabled)\n-\t__gthread_mutex_lock(_M_pmt->_M_get());\n-    }\n-\n-    void\n-    _M_unlock()\n-    {\n-      if (__threads_enabled)\n-\t__gthread_mutex_unlock(_M_pmt->_M_get());\n-    }\n-\n-  public:\n-    _Auto_Lock(_Mutex* __mptr) : _M_pmt(__mptr)\n-    { this->_M_lock(); }\n-\n-    ~_Auto_Lock() { this->_M_unlock(); }\n-  };\n-#endif \n-\n   namespace balloc\n   {\n     /** @class  __mini_vector bitmap_allocator.h bitmap_allocator.h\n@@ -699,9 +549,10 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n    */\n   class free_list\n   {\n-    typedef size_t* value_type;\n-    typedef balloc::__mini_vector<value_type> vector_type;\n-    typedef vector_type::iterator iterator;\n+    typedef size_t* \t\t\t\tvalue_type;\n+    typedef balloc::__mini_vector<value_type> \tvector_type;\n+    typedef vector_type::iterator \t\titerator;\n+    typedef __mutex\t\t\t\tmutex_type;\n \n     struct _LT_pointer_compare\n     {\n@@ -712,11 +563,11 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n     };\n \n #if defined __GTHREADS\n-    _Mutex*\n+    mutex_type&\n     _M_get_mutex()\n     {\n-      static _Mutex _S_mutex;\n-      return &_S_mutex;\n+      static mutex_type _S_mutex;\n+      return _S_mutex;\n     }\n #endif\n \n@@ -807,7 +658,7 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n     _M_insert(size_t* __addr) throw()\n     {\n #if defined __GTHREADS\n-      _Auto_Lock __bfl_lock(_M_get_mutex());\n+      __gnu_cxx::__scoped_lock __bfl_lock(_M_get_mutex());\n #endif\n       // Call _M_validate to decide what should be done with\n       // this particular free list.\n@@ -859,13 +710,15 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n     class bitmap_allocator : private free_list\n     {\n     public:\n-      typedef size_t    size_type;\n-      typedef ptrdiff_t difference_type;\n-      typedef _Tp*        pointer;\n-      typedef const _Tp*  const_pointer;\n-      typedef _Tp&        reference;\n-      typedef const _Tp&  const_reference;\n-      typedef _Tp         value_type;\n+      typedef size_t    \t\tsize_type;\n+      typedef ptrdiff_t \t\tdifference_type;\n+      typedef _Tp*        \t\tpointer;\n+      typedef const _Tp*  \t\tconst_pointer;\n+      typedef _Tp&        \t\treference;\n+      typedef const _Tp&  \t\tconst_reference;\n+      typedef _Tp         \t\tvalue_type;\n+      typedef free_list::mutex_type \tmutex_type;\n+\n       template<typename _Tp1>\n         struct rebind\n \t{\n@@ -971,7 +824,7 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n       _Bitmap_counter<_Alloc_block*> _S_last_request;\n       static typename _BPVector::size_type _S_last_dealloc_index;\n #if defined __GTHREADS\n-      static _Mutex _S_mut;\n+      static mutex_type _S_mut;\n #endif\n \n     public:\n@@ -993,7 +846,7 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n       _M_allocate_single_object() throw(std::bad_alloc)\n       {\n #if defined __GTHREADS\n-\t_Auto_Lock __bit_lock(&_S_mut);\n+\t__gnu_cxx::__scoped_lock __bit_lock(_S_mut);\n #endif\n \n \t// The algorithm is something like this: The last_request\n@@ -1091,7 +944,7 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n       _M_deallocate_single_object(pointer __p) throw()\n       {\n #if defined __GTHREADS\n-\t_Auto_Lock __bit_lock(&_S_mut);\n+\t__gnu_cxx::__scoped_lock __bit_lock(_S_mut);\n #endif\n \t_Alloc_block* __real_p = reinterpret_cast<_Alloc_block*>(__p);\n \n@@ -1105,8 +958,7 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n \n \t\n \tif (__gnu_cxx::balloc::_Inclusive_between<_Alloc_block*>\n-\t    (__real_p)\n-\t    (_S_mem_blocks[_S_last_dealloc_index]))\n+\t    (__real_p) (_S_mem_blocks[_S_last_dealloc_index]))\n \t  {\n \t    _GLIBCXX_DEBUG_ASSERT(_S_last_dealloc_index <= _S_mem_blocks.size() - 1);\n \n@@ -1116,8 +968,7 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n \t  }\n \telse\n \t  {\n-\t    _Iterator _iter = \n-\t      __gnu_cxx::balloc::\n+\t    _Iterator _iter = __gnu_cxx::balloc::\n \t      __find_if(_S_mem_blocks.begin(), \n \t\t\t_S_mem_blocks.end(), \n \t\t\t__gnu_cxx::balloc::\n@@ -1276,12 +1127,11 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n \n #if defined __GTHREADS\n   template<typename _Tp>\n-    __gnu_cxx::_Mutex\n+    typename bitmap_allocator<_Tp>::mutex_type\n     bitmap_allocator<_Tp>::_S_mut;\n #endif\n \n _GLIBCXX_END_NAMESPACE\n \n #endif \n \n-//  LocalWords:  namespace GTHREADS bool const gthread endif Mutex mutex"}, {"sha": "54d21e595ae3855bd154788dc03cb96c2121f192", "filename": "libstdc++-v3/include/ext/concurrence.h", "status": "added", "additions": 184, "deletions": 0, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e362c747413dc3767d020f522df127964b275ac/libstdc%2B%2B-v3%2Finclude%2Fext%2Fconcurrence.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e362c747413dc3767d020f522df127964b275ac/libstdc%2B%2B-v3%2Finclude%2Fext%2Fconcurrence.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fconcurrence.h?ref=2e362c747413dc3767d020f522df127964b275ac", "patch": "@@ -0,0 +1,184 @@\n+// Support for concurrent programing -*- C++ -*-\n+\n+// Copyright (C) 2003, 2004, 2005, 2006\n+// Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+/** @file concurrence.h\n+ *  This is an internal header file, included by other library headers.\n+ *  You should not attempt to use it directly.\n+ */\n+\n+#ifndef _CONCURRENCE_H\n+#define _CONCURRENCE_H 1\n+\n+#include <bits/gthr.h> \n+#include <bits/functexcept.h>\n+\n+_GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n+\n+  // Available locking policies:\n+  // _S_single    single-threaded code that doesn't need to be locked.\n+  // _S_mutex     multi-threaded code that requires additional support\n+  //              from gthr.h or abstraction layers in concurrance.h.\n+  // _S_atomic    multi-threaded code using atomic operations.\n+  enum _Lock_policy { _S_single, _S_mutex, _S_atomic }; \n+\n+  // Compile time constant that indicates prefered locking policy in\n+  // the current configuration.\n+  static const _Lock_policy __default_lock_policy = \n+#ifdef __GTHREADS\n+  // NB: This macro doesn't actually exist yet in the compiler, but is\n+  // set somewhat haphazardly at configure time.\n+#ifdef _GLIBCXX_ATOMIC_BUILTINS\n+  _S_atomic;\n+#else\n+  _S_mutex;\n+#endif\n+#else\n+  _S_single;\n+#endif\n+\n+  class __mutex \n+  {\n+  private:\n+    __gthread_mutex_t _M_mutex;\n+\n+    __mutex(const __mutex&);\n+    __mutex& operator=(const __mutex&);\n+\n+  public:\n+    __mutex() \n+    { \n+#if __GTHREADS\n+      if (__gthread_active_p())\n+\t{\n+#if defined __GTHREAD_MUTEX_INIT\n+\t  __gthread_mutex_t __tmp = __GTHREAD_MUTEX_INIT;\n+\t  _M_mutex = __tmp;\n+#else\n+\t  __GTHREAD_MUTEX_INIT_FUNCTION(_M_mutex); \n+#endif\n+\t}\n+#endif \n+    }\n+\n+    void lock()\n+    { \n+#if __GTHREADS\n+      if (__gthread_active_p())\n+\t{\n+\t  if (__gthread_mutex_lock(&_M_mutex) != 0)\n+\t    std::__throw_runtime_error(\"__mutex::lock\");\n+\t}\n+#endif\n+    }\n+    \n+    void unlock()\n+    { \n+#if __GTHREADS\n+      if (__gthread_active_p())\n+\t{\n+\t  if (__gthread_mutex_unlock(&_M_mutex) != 0)\n+\t    std::__throw_runtime_error(\"__mutex::unlock\");\n+\t}\n+#endif\n+    }\n+  };\n+\n+  class __recursive_mutex \n+  {\n+  private:\n+    __gthread_recursive_mutex_t _M_mutex;\n+\n+    __recursive_mutex(const __recursive_mutex&);\n+    __recursive_mutex& operator=(const __recursive_mutex&);\n+\n+  public:\n+    __recursive_mutex() \n+    { \n+#if __GTHREADS\n+      if (__gthread_active_p())\n+\t{\n+#if defined __GTHREAD_RECURSIVE_MUTEX_INIT\n+\t  __gthread_recursive_mutex_t __tmp = __GTHREAD_RECURSIVE_MUTEX_INIT;\n+\t  _M_mutex = __tmp;\n+#else\n+\t  __GTHREAD_RECURSIVE_MUTEX_INIT_FUNCTION(_M_mutex); \n+#endif\n+\t}\n+#endif \n+    }\n+\n+    void lock()\n+    { \n+#if __GTHREADS\n+      if (__gthread_active_p())\n+\t{\n+\t  if (__gthread_recursive_mutex_lock(&_M_mutex) != 0)\n+\t    std::__throw_runtime_error(\"__recursive_mutex::lock\");\n+\t}\n+#endif\n+    }\n+    \n+    void unlock()\n+    { \n+#if __GTHREADS\n+      if (__gthread_active_p())\n+\t{\n+\t  if (__gthread_recursive_mutex_unlock(&_M_mutex) != 0)\n+\t    std::__throw_runtime_error(\"__recursive_mutex::unlock\");\n+\t}\n+#endif\n+    }\n+  };\n+\n+  /// @brief  Scoped lock idiom.\n+  // Acquire the mutex here with a constructor call, then release with\n+  // the destructor call in accordance with RAII style.\n+  class __scoped_lock\n+  {\n+  public:\n+    typedef __mutex mutex_type;\n+\n+  private:\n+    mutex_type& _M_device;\n+\n+    __scoped_lock(const __scoped_lock&);\n+    __scoped_lock& operator=(const __scoped_lock&);\n+\n+  public:\n+    explicit __scoped_lock(mutex_type& __name) : _M_device(__name)\n+    { _M_device.lock(); }\n+\n+    ~__scoped_lock() throw()\n+    { _M_device.unlock(); }\n+  };\n+\n+_GLIBCXX_END_NAMESPACE\n+\n+#endif"}, {"sha": "4dcd4373e4e608bbfa20de00c7dd33752563c63a", "filename": "libstdc++-v3/include/ext/mt_allocator.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e362c747413dc3767d020f522df127964b275ac/libstdc%2B%2B-v3%2Finclude%2Fext%2Fmt_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e362c747413dc3767d020f522df127964b275ac/libstdc%2B%2B-v3%2Finclude%2Fext%2Fmt_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fmt_allocator.h?ref=2e362c747413dc3767d020f522df127964b275ac", "patch": "@@ -37,8 +37,7 @@\n #include <new>\n #include <cstdlib>\n #include <bits/functexcept.h>\n-#include <bits/gthr.h>\n-#include <bits/atomicity.h>\n+#include <ext/atomicity.h>\n \n _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n "}, {"sha": "e78bf21778c251db5ef7c16c7ab457c19c4a1ad5", "filename": "libstdc++-v3/include/ext/pool_allocator.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e362c747413dc3767d020f522df127964b275ac/libstdc%2B%2B-v3%2Finclude%2Fext%2Fpool_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e362c747413dc3767d020f522df127964b275ac/libstdc%2B%2B-v3%2Finclude%2Fext%2Fpool_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fpool_allocator.h?ref=2e362c747413dc3767d020f522df127964b275ac", "patch": "@@ -52,8 +52,8 @@\n #include <cstdlib>\n #include <new>\n #include <bits/functexcept.h>\n-#include <bits/atomicity.h>\n-#include <bits/concurrence.h>\n+#include <ext/atomicity.h>\n+#include <ext/concurrence.h>\n \n _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n \n@@ -106,7 +106,7 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n       _Obj* volatile*\n       _M_get_free_list(size_t __bytes);\n     \n-      mutex_type&\n+      __mutex&\n       _M_get_mutex();\n \n       // Returns an object of size __n, and optionally adds to size __n\n@@ -218,7 +218,7 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n \t    {\n \t      _Obj* volatile* __free_list = _M_get_free_list(__bytes);\n \t      \n-\t      lock sentry(_M_get_mutex());\n+\t      __scoped_lock sentry(_M_get_mutex());\n \t      _Obj* __restrict__ __result = *__free_list;\n \t      if (__builtin_expect(__result == 0, 0))\n \t\t__ret = static_cast<_Tp*>(_M_refill(_M_round_up(__bytes)));\n@@ -248,7 +248,7 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n \t      _Obj* volatile* __free_list = _M_get_free_list(__bytes);\n \t      _Obj* __q = reinterpret_cast<_Obj*>(__p);\n \n-\t      lock sentry(_M_get_mutex());\n+\t      __scoped_lock sentry(_M_get_mutex());\n \t      __q ->_M_free_list_link = *__free_list;\n \t      *__free_list = __q;\n \t    }"}, {"sha": "3d41fe5dde19e2b6f7c89d9d8cb9c8ceec8b047a", "filename": "libstdc++-v3/include/ext/rc_string_base.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e362c747413dc3767d020f522df127964b275ac/libstdc%2B%2B-v3%2Finclude%2Fext%2Frc_string_base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e362c747413dc3767d020f522df127964b275ac/libstdc%2B%2B-v3%2Finclude%2Fext%2Frc_string_base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Frc_string_base.h?ref=2e362c747413dc3767d020f522df127964b275ac", "patch": "@@ -36,7 +36,7 @@\n #ifndef _RC_STRING_BASE_H\n #define _RC_STRING_BASE_H 1\n \n-#include <bits/atomicity.h>\n+#include <ext/atomicity.h>\n \n _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n "}, {"sha": "dfe5f171b6d003db8494b9ba092b7975f31219f3", "filename": "libstdc++-v3/include/tr1/boost_shared_ptr.h", "status": "modified", "additions": 223, "deletions": 330, "changes": 553, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e362c747413dc3767d020f522df127964b275ac/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fboost_shared_ptr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e362c747413dc3767d020f522df127964b275ac/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fboost_shared_ptr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fboost_shared_ptr.h?ref=2e362c747413dc3767d020f522df127964b275ac", "patch": "@@ -1,6 +1,6 @@\n // <tr1/boost_shared_ptr.h> -*- C++ -*-\n \n-// Copyright (C) 2005 Free Software Foundation, Inc.\n+// Copyright (C) 2005, 2006 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -54,40 +54,18 @@\n #ifndef _BOOST_SHARED_PTR_H\n #define _BOOST_SHARED_PTR_H 1\n \n-// namespace std::tr1\n namespace std\n {\n-\n _GLIBCXX_BEGIN_NAMESPACE(tr1)\n-// TODO This should go into a separate header really.\n-enum _Lock_policy { _S_lockfree, _S_mutex, _S_single }; \n-\n-static const _Lock_policy __shared_ptr_default_lock_mode = \n-#ifdef __GTHREADS\n-// NOTE: This doesn't actually exist yet in the compiler.\n-#ifdef _GLIBCXX_ATOMIC_BUILTINS\n-  _S_lockfree;\n-#else\n-  _S_mutex;\n-#endif\n-#else\n-  _S_single;\n-#endif\n-\n-// END TODO\n-\n \n class bad_weak_ptr : public std::exception\n {\n public:\n-\n   virtual char const*\n-  what() const throw()\n-  { return \"tr1::bad_weak_ptr\"; }\n+  what() const throw() { return \"tr1::bad_weak_ptr\"; }\n };\n \n-// Helper for exception objects in <tr1/memory>\n-// TODO this should be defined in a different file.\n+  // Substitute for bad_weak_ptr object in the case of -fno-exceptions.\n inline void\n __throw_bad_weak_ptr()\n {\n@@ -98,6 +76,11 @@ __throw_bad_weak_ptr()\n #endif\n }\n \n+using __gnu_cxx::_Lock_policy;\n+using __gnu_cxx::__default_lock_policy;\n+using __gnu_cxx::_S_single;\n+using __gnu_cxx::_S_mutex;\n+using __gnu_cxx::_S_atomic;\n \n template<typename _Tp>\n   struct _Sp_deleter\n@@ -111,64 +94,41 @@ template<typename _Tp>\n   };\n \n // Empty helper class except when the template argument is _S_mutex.\n-template <_Lock_policy __l>\n+template<_Lock_policy _Lp>\n   class _Mutex_base\n-  {\n-  };\n+  { };\n \n-template <>\n-  class _Mutex_base<_S_mutex>\n-  {\n-  public:\n-    __gnu_cxx::mutex_type _M_mutex;\n-    \n-    _Mutex_base()\n-    {\n-      // For the case of __GTHREAD_MUTEX_INIT we haven't initialised\n-      // the mutex yet, so do it now.\n-#if defined(__GTHREADS) && defined(__GTHREAD_MUTEX_INIT)\n-      __gthread_mutex_t __tmp = __GTHREAD_MUTEX_INIT;\n-      _M_mutex = __tmp;\n-#endif\n-    }\n-  };\n+template<>\n+  class _Mutex_base<_S_mutex> : public __gnu_cxx::__mutex\n+  { };\n \n \n-template <_Lock_policy __l = __shared_ptr_default_lock_mode>\n-  class _Sp_counted_base\n-  : public _Mutex_base<__l>\n+template<_Lock_policy _Lp = __default_lock_policy>\n+  class _Sp_counted_base : public _Mutex_base<_Lp>\n   {\n-  public:\n-  \n-    _Sp_counted_base()\n-    : _M_use_count(1), _M_weak_count(1)\n-    {\n-    }\n+  public:  \n+    _Sp_counted_base() : _M_use_count(1), _M_weak_count(1) { }\n   \n     virtual\n-    ~_Sp_counted_base() // nothrow\n+    ~_Sp_counted_base() // nothrow \n     { }\n   \n-    // dispose() is called when _M_use_count drops to zero, to release\n-    // the resources managed by *this.\n+    // Called when _M_use_count drops to zero, to release the resources\n+    // managed by *this.\n     virtual void\n     dispose() = 0; // nothrow\n   \n-    // destroy() is called when _M_weak_count drops to zero.\n+    // Called when _M_weak_count drops to zero.\n     virtual void\n     destroy() // nothrow\n-    {\n-      delete this;\n-    }\n+    { delete this; }\n   \n     virtual void*\n     get_deleter(const std::type_info&) = 0;\n   \n     void\n     add_ref_copy()\n-    {\n-      __gnu_cxx::__atomic_add(&_M_use_count, 1);\n-    }\n+    { __gnu_cxx::__atomic_add(&_M_use_count, 1); }\n   \n     void\n     add_ref_lock();\n@@ -190,9 +150,7 @@ template <_Lock_policy __l = __shared_ptr_default_lock_mode>\n   \n     void\n     weak_add_ref() // nothrow\n-    {\n-      __gnu_cxx::__atomic_add(&_M_weak_count, 1);\n-    }\n+    { __gnu_cxx::__atomic_add(&_M_weak_count, 1); }\n   \n     void\n     weak_release() // nothrow\n@@ -209,12 +167,9 @@ template <_Lock_policy __l = __shared_ptr_default_lock_mode>\n   \n     long\n     use_count() const // nothrow\n-    {\n-      return _M_use_count;  // XXX is this MT safe?\n-    }\n-  \n-  private:\n+    { return _M_use_count; }  // XXX is this MT safe? \n   \n+  private:  \n     _Sp_counted_base(_Sp_counted_base const&);\n     _Sp_counted_base& operator=(_Sp_counted_base const&);\n   \n@@ -223,8 +178,7 @@ template <_Lock_policy __l = __shared_ptr_default_lock_mode>\n   };\n \n template<>\n-  inline\n-  void\n+  inline void\n   _Sp_counted_base<_S_single>::add_ref_lock()\n   {\n     if (__gnu_cxx::__exchange_and_add(&_M_use_count, 1) == 0)\n@@ -236,11 +190,10 @@ template<>\n   \n #ifdef __GTHREADS\n template<>\n-  inline\n-  void\n+  inline void\n   _Sp_counted_base<_S_mutex>::add_ref_lock()\n   {\n-    __gnu_cxx::lock lock(_M_mutex);\n+    __gnu_cxx::__scoped_lock sentry(*this);\n     if (__gnu_cxx::__exchange_and_add(&_M_use_count, 1) == 0)\n       {\n         _M_use_count = 0;\n@@ -250,50 +203,41 @@ template<>\n #endif\n \n template<> \n-  inline\n-  void\n-  _Sp_counted_base<_S_lockfree>::add_ref_lock()\n+  inline void\n+  _Sp_counted_base<_S_atomic>::add_ref_lock()\n   {\n     // Perform lock-free add-if-not-zero operation.\n     _Atomic_word __count;\n     do\n     {\n       __count = _M_use_count;\n       if (__count == 0)\n-        {\n-          __throw_bad_weak_ptr();\n-        }\n-      /* Replace the current counter value with the old value + 1, as long\n-       * as it's not changed meanwhile. */\n+\t__throw_bad_weak_ptr();\n+\n+      // Replace the current counter value with the old value + 1, as\n+      // long as it's not changed meanwhile. \n     }\n     while (!__sync_bool_compare_and_swap(&_M_use_count, __count, __count + 1));\n   }\n \n-template<typename _Ptr, typename _Deleter, _Lock_policy __l>\n-  class _Sp_counted_base_impl\n-  : public _Sp_counted_base<__l>\n+template<typename _Ptr, typename _Deleter, _Lock_policy _Lp>\n+  class _Sp_counted_base_impl : public _Sp_counted_base<_Lp>\n   {\n   public:\n-\n     /**\n      *  @brief   \n      *  @pre     d(p) must not throw.\n      */\n     _Sp_counted_base_impl(_Ptr __p, _Deleter __d)\n-    : _M_ptr(__p), _M_del(__d)\n-    { }\n+    : _M_ptr(__p), _M_del(__d) { }\n     \n     virtual void\n     dispose() // nothrow\n-    {\n-      _M_del(_M_ptr);\n-    }\n+    { _M_del(_M_ptr); }\n     \n     virtual void*\n     get_deleter(const std::type_info& __ti)\n-    {\n-      return __ti == typeid(_Deleter) ? &_M_del : 0;\n-    }\n+    { return __ti == typeid(_Deleter) ? &_M_del : 0; }\n     \n   private:\n     _Sp_counted_base_impl(const _Sp_counted_base_impl&);\n@@ -303,49 +247,44 @@ template<typename _Ptr, typename _Deleter, _Lock_policy __l>\n     _Deleter _M_del; // copy constructor must not throw\n   };\n \n-template<_Lock_policy __l = __shared_ptr_default_lock_mode>\n+template<_Lock_policy _Lp = __default_lock_policy>\n   class weak_count;\n \n-template<_Lock_policy __l = __shared_ptr_default_lock_mode>\n+template<_Lock_policy _Lp = __default_lock_policy>\n   class shared_count\n   {\n-  private:\n+  private:  \n+    _Sp_counted_base<_Lp>* _M_pi;\n   \n-    _Sp_counted_base<__l>* _M_pi;\n+    friend class weak_count<_Lp>;\n   \n-    friend class weak_count<__l>;\n-  \n-  public:\n-  \n-    shared_count()\n-    : _M_pi(0) // nothrow\n+  public:  \n+    shared_count() : _M_pi(0) // nothrow\n     { }\n   \n     template<typename _Ptr, typename _Deleter>\n-      shared_count(_Ptr __p, _Deleter __d)\n-      : _M_pi(0)\n+      shared_count(_Ptr __p, _Deleter __d) : _M_pi(0)\n       {\n         try\n           {\n-            _M_pi = new _Sp_counted_base_impl<_Ptr, _Deleter, __l>(__p, __d);\n+            _M_pi = new _Sp_counted_base_impl<_Ptr, _Deleter, _Lp>(__p, __d);\n           }\n         catch(...)\n           {\n-            __d(__p); // delete __p\n+            __d(__p); // Call _Deleter on __p.\n             __throw_exception_again;\n           }\n       }\n   \n-    // auto_ptr<_Tp> is special cased to provide the strong guarantee\n-  \n+    // Special case for auto_ptr<_Tp> to provide the strong guarantee.\n     template<typename _Tp>\n       explicit shared_count(std::auto_ptr<_Tp>& __r)\n       : _M_pi(new _Sp_counted_base_impl<_Tp*,\n-              _Sp_deleter<_Tp>, __l >(__r.get(), _Sp_deleter<_Tp>()))\n+\t      _Sp_deleter<_Tp>, _Lp >(__r.get(), _Sp_deleter<_Tp>()))\n       { __r.release(); }\n   \n-    // throws bad_weak_ptr when __r.use_count() == 0\n-    explicit shared_count(const weak_count<__l>& __r);\n+    // Throw bad_weak_ptr when __r.use_count() == 0.\n+    explicit shared_count(const weak_count<_Lp>& __r);\n   \n     ~shared_count() // nothrow\n     {\n@@ -363,13 +302,12 @@ template<_Lock_policy __l = __shared_ptr_default_lock_mode>\n     shared_count&\n     operator=(const shared_count& __r) // nothrow\n     {\n-      _Sp_counted_base<__l>* __tmp = __r._M_pi;\n-  \n-      if(__tmp != _M_pi)\n+      _Sp_counted_base<_Lp>* __tmp = __r._M_pi;\n+      if (__tmp != _M_pi)\n         {\n-          if(__tmp != 0)\n+          if (__tmp != 0)\n             __tmp->add_ref_copy();\n-          if(_M_pi != 0)\n+          if (_M_pi != 0)\n             _M_pi->release();\n           _M_pi = __tmp;\n         }\n@@ -378,7 +316,7 @@ template<_Lock_policy __l = __shared_ptr_default_lock_mode>\n   \n     void swap(shared_count& __r) // nothrow\n     {\n-      _Sp_counted_base<__l>* __tmp = __r._M_pi;\n+      _Sp_counted_base<_Lp>* __tmp = __r._M_pi;\n       __r._M_pi = _M_pi;\n       _M_pi = __tmp;\n     }\n@@ -397,36 +335,34 @@ template<_Lock_policy __l = __shared_ptr_default_lock_mode>\n   \n     friend inline bool\n     operator<(const shared_count& __a, const shared_count& __b)\n-    { return std::less<_Sp_counted_base<__l>*>()(__a._M_pi, __b._M_pi); }\n+    { return std::less<_Sp_counted_base<_Lp>*>()(__a._M_pi, __b._M_pi); }\n   \n     void*\n     get_deleter(const std::type_info& __ti) const\n     { return _M_pi ? _M_pi->get_deleter(__ti) : 0; }\n   };\n \n-template<_Lock_policy __l>\n+template<_Lock_policy _Lp>\n   class weak_count\n   {\n-  private:\n-  \n-    _Sp_counted_base<__l>* _M_pi;\n-  \n-    friend class shared_count<__l>;\n+  private:  \n+    _Sp_counted_base<_Lp>* _M_pi;\n   \n-  public:\n+    friend class shared_count<_Lp>;\n   \n+  public:  \n     weak_count()\n     : _M_pi(0) // nothrow\n     { }\n   \n-    weak_count(const shared_count<__l>& __r)\n+    weak_count(const shared_count<_Lp>& __r)\n     : _M_pi(__r._M_pi) // nothrow\n     {\n       if (_M_pi != 0)\n         _M_pi->weak_add_ref();\n     }\n   \n-    weak_count(const weak_count<__l>& __r)\n+    weak_count(const weak_count<_Lp>& __r)\n     : _M_pi(__r._M_pi) // nothrow\n     {\n       if (_M_pi != 0)\n@@ -439,36 +375,34 @@ template<_Lock_policy __l>\n         _M_pi->weak_release();\n     }\n   \n-    weak_count<__l>&\n-    operator=(const shared_count<__l>& __r) // nothrow\n+    weak_count<_Lp>&\n+    operator=(const shared_count<_Lp>& __r) // nothrow\n     {\n-      _Sp_counted_base<__l>* __tmp = __r._M_pi;\n+      _Sp_counted_base<_Lp>* __tmp = __r._M_pi;\n       if (__tmp != 0)\n         __tmp->weak_add_ref();\n       if (_M_pi != 0)\n         _M_pi->weak_release();\n-      _M_pi = __tmp;\n-  \n+      _M_pi = __tmp;  \n       return *this;\n     }\n   \n-    weak_count<__l>&\n-    operator=(const weak_count<__l>& __r) // nothrow\n+    weak_count<_Lp>&\n+    operator=(const weak_count<_Lp>& __r) // nothrow\n     {\n-      _Sp_counted_base<__l> * __tmp = __r._M_pi;\n+      _Sp_counted_base<_Lp> * __tmp = __r._M_pi;\n       if (__tmp != 0)\n         __tmp->weak_add_ref();\n       if (_M_pi != 0)\n         _M_pi->weak_release();\n       _M_pi = __tmp;\n-  \n       return *this;\n     }\n   \n     void\n-    swap(weak_count<__l>& __r) // nothrow\n+    swap(weak_count<_Lp>& __r) // nothrow\n     {\n-      _Sp_counted_base<__l> * __tmp = __r._M_pi;\n+      _Sp_counted_base<_Lp> * __tmp = __r._M_pi;\n       __r._M_pi = _M_pi;\n       _M_pi = __tmp;\n     }\n@@ -478,17 +412,17 @@ template<_Lock_policy __l>\n     { return _M_pi != 0 ? _M_pi->use_count() : 0; }\n   \n     friend inline bool\n-    operator==(const weak_count<__l>& __a, const weak_count<__l>& __b)\n+    operator==(const weak_count<_Lp>& __a, const weak_count<_Lp>& __b)\n     { return __a._M_pi == __b._M_pi; }\n   \n     friend inline bool\n-    operator<(const weak_count<__l>& __a, const weak_count<__l>& __b)\n-    { return std::less<_Sp_counted_base<__l>*>()(__a._M_pi, __b._M_pi); }\n+    operator<(const weak_count<_Lp>& __a, const weak_count<_Lp>& __b)\n+    { return std::less<_Sp_counted_base<_Lp>*>()(__a._M_pi, __b._M_pi); }\n   };\n \n-template<_Lock_policy __l>\n+template<_Lock_policy _Lp>\n   inline\n-  shared_count<__l>::shared_count(const weak_count<__l>& __r)\n+  shared_count<_Lp>::shared_count(const weak_count<_Lp>& __r)\n   : _M_pi(__r._M_pi)\n   {\n     if (_M_pi != 0)\n@@ -498,20 +432,20 @@ template<_Lock_policy __l>\n   }\n \n \n-// fwd decls\n-template<typename _Tp, _Lock_policy __l = __shared_ptr_default_lock_mode>\n+// Forward decls.\n+template<typename _Tp, _Lock_policy _Lp = __default_lock_policy>\n   class __shared_ptr;\n \n-template<typename _Tp, _Lock_policy __l = __shared_ptr_default_lock_mode>\n+template<typename _Tp, _Lock_policy _Lp = __default_lock_policy>\n   class __weak_ptr;\n \n-template<typename _Tp, _Lock_policy __l>\n+template<typename _Tp, _Lock_policy _Lp>\n   class __enable_shared_from_this;\n \n-struct __static_cast_tag {};\n-struct __const_cast_tag {};\n-struct __dynamic_cast_tag {};\n-struct __polymorphic_cast_tag {};\n+struct __static_cast_tag { };\n+struct __const_cast_tag { };\n+struct __dynamic_cast_tag { };\n+struct __polymorphic_cast_tag { };\n \n template<class _Tp>\n   struct shared_ptr_traits\n@@ -534,24 +468,25 @@ template<>\n   { typedef void reference; };\n \n \n-// enable_shared_from_this support\n+// Support for enable_shared_from_this.\n \n-// friend of __enable_shared_from_this\n-template<_Lock_policy __l, typename _Tp1, typename _Tp2>\n+// Friend of __enable_shared_from_this.\n+template<_Lock_policy _Lp, typename _Tp1, typename _Tp2>\n   void\n-  __enable_shared_from_this_helper(const shared_count<__l>& __pn,\n-                            const __enable_shared_from_this<_Tp1, __l>* __pe,\n-                            const _Tp2* __px );\n+  __enable_shared_from_this_helper(const shared_count<_Lp>&,\n+                            const __enable_shared_from_this<_Tp1, _Lp>*,\n+                            const _Tp2*);\n \n-template<_Lock_policy __l>\n+template<_Lock_policy _Lp>\n   inline void\n-  __enable_shared_from_this_helper(const shared_count<__l>&, ...)\n+  __enable_shared_from_this_helper(const shared_count<_Lp>&, ...)\n   { }\n \n \n-// get_deleter must be declared before friend declaration by shared_ptr.\n-template<typename _Del, typename _Tp, _Lock_policy __l>\n-  _Del* get_deleter(const __shared_ptr<_Tp, __l>&);\n+// Function get_deleter must be declared before friend declaration by\n+// shared_ptr.\n+template<typename _Del, typename _Tp, _Lock_policy _Lp>\n+  _Del* get_deleter(const __shared_ptr<_Tp, _Lp>&);\n \n /**\n  *  @class shared_ptr <tr1/memory>\n@@ -560,13 +495,12 @@ template<typename _Del, typename _Tp, _Lock_policy __l>\n  *  The object pointed to is deleted when the last shared_ptr pointing to it\n  *  is destroyed or reset.\n  */\n-template<typename _Tp, _Lock_policy __l>\n+template<typename _Tp, _Lock_policy _Lp>\n   class __shared_ptr\n   {\n     typedef typename shared_ptr_traits<_Tp>::reference _Reference;\n \n   public:\n-\n     typedef _Tp   element_type;\n \n     /** @brief  Construct an empty %__shared_ptr.\n@@ -587,7 +521,6 @@ template<typename _Tp, _Lock_policy __l>\n       {\n         __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>)\n         // __glibcxx_function_requires(_CompleteConcept<_Tp1*>)\n-\n         __enable_shared_from_this_helper( _M_refcount, __p, __p );\n       }\n \n@@ -609,7 +542,6 @@ template<typename _Tp, _Lock_policy __l>\n       {\n         __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>)\n         // TODO requires D is CopyConstructible and d(p) well-formed\n-\n         __enable_shared_from_this_helper( _M_refcount, __p, __p );\n       }\n \n@@ -622,11 +554,9 @@ template<typename _Tp, _Lock_policy __l>\n      *  @throw  std::bad_alloc, in which case \n      */\n     template<typename _Tp1>\n-      __shared_ptr(const __shared_ptr<_Tp1, __l>& __r)\n+      __shared_ptr(const __shared_ptr<_Tp1, _Lp>& __r)\n       : _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount) // never throws\n-      {\n-        __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>)\n-      }\n+      { __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>) }\n \n     /** @brief  Constructs a %__shared_ptr that shares ownership with @a r\n      *          and stores a copy of the pointer stored in @a r.\n@@ -636,12 +566,12 @@ template<typename _Tp, _Lock_policy __l>\n      *          in which case the constructor has no effect.\n      */\n     template<typename _Tp1>\n-      explicit __shared_ptr(const __weak_ptr<_Tp1, __l>& __r)\n+      explicit __shared_ptr(const __weak_ptr<_Tp1, _Lp>& __r)\n       : _M_refcount(__r._M_refcount) // may throw\n       {\n         __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>)\n-        // it is now safe to copy r__._M_ptr, as _M_refcount(__r._M_refcount)\n-        // did not throw\n+        // It is now safe to copy r__._M_ptr, as _M_refcount(__r._M_refcount)\n+        // did not throw.\n         _M_ptr = __r._M_ptr;\n       }\n \n@@ -655,35 +585,34 @@ template<typename _Tp, _Lock_policy __l>\n         // TODO requires r.release() convertible to _Tp*, Tp1 is complete,\n         // delete r.release() well-formed\n         _Tp1 * __tmp = __r.get();\n-        _M_refcount = shared_count<__l>(__r);\n-\n+        _M_refcount = shared_count<_Lp>(__r);\n         __enable_shared_from_this_helper( _M_refcount, __tmp, __tmp );\n       }\n \n     template<typename _Tp1>\n-      __shared_ptr(const __shared_ptr<_Tp1, __l>& __r, __static_cast_tag)\n+      __shared_ptr(const __shared_ptr<_Tp1, _Lp>& __r, __static_cast_tag)\n       : _M_ptr(static_cast<element_type*>(__r._M_ptr)),\n \t_M_refcount(__r._M_refcount)\n       { }\n \n     template<typename _Tp1>\n-      __shared_ptr(const __shared_ptr<_Tp1, __l>& __r, __const_cast_tag)\n+      __shared_ptr(const __shared_ptr<_Tp1, _Lp>& __r, __const_cast_tag)\n       : _M_ptr(const_cast<element_type*>(__r._M_ptr)),\n \t_M_refcount(__r._M_refcount)\n       { }\n \n     template<typename _Tp1>\n-      __shared_ptr(const __shared_ptr<_Tp1, __l>& __r, __dynamic_cast_tag)\n+      __shared_ptr(const __shared_ptr<_Tp1, _Lp>& __r, __dynamic_cast_tag)\n       : _M_ptr(dynamic_cast<element_type*>(__r._M_ptr)),\n \t_M_refcount(__r._M_refcount)\n       {\n         if (_M_ptr == 0) // need to allocate new counter -- the cast failed\n-          _M_refcount = shared_count<__l>();\n+          _M_refcount = shared_count<_Lp>();\n       }\n \n     template<typename _Tp1>\n       __shared_ptr&\n-      operator=(const __shared_ptr<_Tp1, __l>& __r) // never throws\n+      operator=(const __shared_ptr<_Tp1, _Lp>& __r) // never throws\n       {\n         _M_ptr = __r._M_ptr;\n         _M_refcount = __r._M_refcount; // shared_count::op= doesn't throw\n@@ -704,10 +633,10 @@ template<typename _Tp, _Lock_policy __l>\n \n     template<typename _Tp1>\n       void\n-      reset(_Tp1* __p) // _Tp1 must be complete\n+      reset(_Tp1* __p) // _Tp1 must be complete.\n       {\n-        _GLIBCXX_DEBUG_ASSERT(__p == 0 || __p != _M_ptr); // catch self-reset\n-\t                                                  // errors\n+\t// Catch self-reset errors.\n+        _GLIBCXX_DEBUG_ASSERT(__p == 0 || __p != _M_ptr); \n         __shared_ptr(__p).swap(*this);\n       }\n \n@@ -716,7 +645,7 @@ template<typename _Tp, _Lock_policy __l>\n       reset(_Tp1 * __p, _Deleter __d)\n       { __shared_ptr(__p, __d).swap(*this); }\n \n-    // error to instantiate if _Tp is [cv-qual] void\n+    // Error to instantiate if _Tp is [cv-qual] void.\n     _Reference\n     operator*() const // never throws\n     {\n@@ -735,7 +664,7 @@ template<typename _Tp, _Lock_policy __l>\n     get() const // never throws\n     { return _M_ptr; }\n \n-    // implicit conversion to \"bool\"\n+    // Implicit conversion to \"bool\"\n   private:\n     typedef _Tp* __shared_ptr::*__unspecified_bool_type;\n \n@@ -752,7 +681,7 @@ template<typename _Tp, _Lock_policy __l>\n     { return _M_refcount.use_count(); }\n \n     void\n-    swap(__shared_ptr<_Tp, __l>& __other) // never throws\n+    swap(__shared_ptr<_Tp, _Lp>& __other) // never throws\n     {\n       std::swap(_M_ptr, __other._M_ptr);\n       _M_refcount.swap(__other._M_refcount);\n@@ -763,41 +692,41 @@ template<typename _Tp, _Lock_policy __l>\n     _M_get_deleter(const std::type_info& __ti) const\n     { return _M_refcount.get_deleter(__ti); }\n \n-    template<typename _Tp1, _Lock_policy __l1>\n+    template<typename _Tp1, _Lock_policy _Lp1>\n       bool\n-      _M_less(const __shared_ptr<_Tp1, __l1>& __rhs) const\n+      _M_less(const __shared_ptr<_Tp1, _Lp1>& __rhs) const\n       { return _M_refcount < __rhs._M_refcount; }\n \n-    template<typename _Tp1, _Lock_policy __l1> friend class __shared_ptr;\n-    template<typename _Tp1, _Lock_policy __l1> friend class __weak_ptr;\n+    template<typename _Tp1, _Lock_policy _Lp1> friend class __shared_ptr;\n+    template<typename _Tp1, _Lock_policy _Lp1> friend class __weak_ptr;\n \n-    template<typename _Del, typename _Tp1, _Lock_policy __l1>\n-      friend _Del* get_deleter(const __shared_ptr<_Tp1, __l1>&);\n+    template<typename _Del, typename _Tp1, _Lock_policy _Lp1>\n+      friend _Del* get_deleter(const __shared_ptr<_Tp1, _Lp1>&);\n \n-    // friends injected into enclosing namespace and found by ADL:\n+    // Friends injected into enclosing namespace and found by ADL:\n     template<typename _Tp1>\n       friend inline bool\n-      operator==(const __shared_ptr& __a, const __shared_ptr<_Tp1, __l>& __b)\n+      operator==(const __shared_ptr& __a, const __shared_ptr<_Tp1, _Lp>& __b)\n       { return __a.get() == __b.get(); }\n \n     template<typename _Tp1>\n       friend inline bool\n-      operator!=(const __shared_ptr& __a, const __shared_ptr<_Tp1, __l>& __b)\n+      operator!=(const __shared_ptr& __a, const __shared_ptr<_Tp1, _Lp>& __b)\n       { return __a.get() != __b.get(); }\n \n     template<typename _Tp1>\n       friend inline bool\n-      operator<(const __shared_ptr& __a, const __shared_ptr<_Tp1, __l>& __b)\n+      operator<(const __shared_ptr& __a, const __shared_ptr<_Tp1, _Lp>& __b)\n       { return __a._M_less(__b); }\n \n-    _Tp*         _M_ptr;         // contained pointer\n-    shared_count<__l> _M_refcount;    // reference counter\n-  };  // __shared_ptr\n+    _Tp*         \t_M_ptr;         // Contained pointer.\n+    shared_count<_Lp> \t_M_refcount;    // Reference counter.\n+  }; \n \n // 2.2.3.8 shared_ptr specialized algorithms.\n-template<typename _Tp, _Lock_policy __l>\n+template<typename _Tp, _Lock_policy _Lp>\n   inline void\n-  swap(__shared_ptr<_Tp, __l>& __a, __shared_ptr<_Tp, __l>& __b)\n+  swap(__shared_ptr<_Tp, _Lp>& __a, __shared_ptr<_Tp, _Lp>& __b)\n   { __a.swap(__b); }\n \n // 2.2.3.9 shared_ptr casts\n@@ -806,101 +735,89 @@ template<typename _Tp, _Lock_policy __l>\n  *           will eventually result in undefined behaviour,\n  *           attempting to delete the same object twice.\n  */\n-template<typename _Tp, typename _Tp1, _Lock_policy __l>\n-  __shared_ptr<_Tp, __l>\n-  static_pointer_cast(const __shared_ptr<_Tp1, __l>& __r)\n-  {\n-    return __shared_ptr<_Tp, __l>(__r, __static_cast_tag());\n-  }\n+template<typename _Tp, typename _Tp1, _Lock_policy _Lp>\n+  __shared_ptr<_Tp, _Lp>\n+  static_pointer_cast(const __shared_ptr<_Tp1, _Lp>& __r)\n+  { return __shared_ptr<_Tp, _Lp>(__r, __static_cast_tag()); }\n \n /** @warning The seemingly equivalent\n  *           <code>shared_ptr<T>(const_cast<T*>(r.get()))</code>\n  *           will eventually result in undefined behaviour,\n  *           attempting to delete the same object twice.\n  */\n-template<typename _Tp, typename _Tp1, _Lock_policy __l>\n-  __shared_ptr<_Tp, __l>\n-  const_pointer_cast(const __shared_ptr<_Tp1, __l>& __r)\n-  {\n-    return __shared_ptr<_Tp, __l>(__r, __const_cast_tag());\n-  }\n+template<typename _Tp, typename _Tp1, _Lock_policy _Lp>\n+  __shared_ptr<_Tp, _Lp>\n+  const_pointer_cast(const __shared_ptr<_Tp1, _Lp>& __r)\n+  { return __shared_ptr<_Tp, _Lp>(__r, __const_cast_tag()); }\n \n /** @warning The seemingly equivalent\n  *           <code>shared_ptr<T>(dynamic_cast<T*>(r.get()))</code>\n  *           will eventually result in undefined behaviour,\n  *           attempting to delete the same object twice.\n  */\n-template<typename _Tp, typename _Tp1, _Lock_policy __l>\n-  __shared_ptr<_Tp, __l>\n-  dynamic_pointer_cast(const __shared_ptr<_Tp1, __l>& __r)\n-  {\n-    return __shared_ptr<_Tp, __l>(__r, __dynamic_cast_tag());\n-  }\n+template<typename _Tp, typename _Tp1, _Lock_policy _Lp>\n+  __shared_ptr<_Tp, _Lp>\n+  dynamic_pointer_cast(const __shared_ptr<_Tp1, _Lp>& __r)\n+  { return __shared_ptr<_Tp, _Lp>(__r, __dynamic_cast_tag()); }\n \n // 2.2.3.7 shared_ptr I/O\n-template<typename _Ch, typename _Tr, typename _Tp, _Lock_policy __l>\n+template<typename _Ch, typename _Tr, typename _Tp, _Lock_policy _Lp>\n   std::basic_ostream<_Ch, _Tr>&\n-  operator<<(std::basic_ostream<_Ch, _Tr>& __os, const __shared_ptr<_Tp, __l>& __p)\n+  operator<<(std::basic_ostream<_Ch, _Tr>& __os, \n+\t     const __shared_ptr<_Tp, _Lp>& __p)\n   {\n     __os << __p.get();\n     return __os;\n   }\n \n // 2.2.3.10 shared_ptr get_deleter (experimental)\n-template<typename _Del, typename _Tp, _Lock_policy __l>\n+template<typename _Del, typename _Tp, _Lock_policy _Lp>\n   inline _Del*\n-  get_deleter(const __shared_ptr<_Tp, __l>& __p)\n+  get_deleter(const __shared_ptr<_Tp, _Lp>& __p)\n   { return static_cast<_Del*>(__p._M_get_deleter(typeid(_Del))); }\n \n \n-template<typename _Tp, _Lock_policy __l>\n+template<typename _Tp, _Lock_policy _Lp>\n   class __weak_ptr\n   {\n   public:\n-\n     typedef _Tp element_type;\n \n-    __weak_ptr()\n-    : _M_ptr(0), _M_refcount() // never throws\n+    __weak_ptr() : _M_ptr(0), _M_refcount() // never throws\n     { }\n \n-    //  generated copy constructor, assignment, destructor are fine\n+    // Generated copy constructor, assignment, destructor are fine.\n \n-    //\n-    //  The \"obvious\" converting constructor implementation:\n+    // The \"obvious\" converting constructor implementation:\n     //\n     //  template<class Y>\n     //    __weak_ptr(__weak_ptr<Y> const & r)\n     //    : _M_ptr(r._M_ptr), _M_refcount(r._M_refcount) // never throws\n     //    { }\n     //\n-    //  has a serious problem.\n+    // has a serious problem.\n     //\n     //  r._M_ptr may already have been invalidated. The _M_ptr(r._M_ptr)\n     //  conversion may require access to *r._M_ptr (virtual inheritance).\n     //\n-    //  It is not possible to avoid spurious access violations since\n-    //  in multithreaded programs r._M_ptr may be invalidated at any point.\n-    //\n-\n+    // It is not possible to avoid spurious access violations since\n+    // in multithreaded programs r._M_ptr may be invalidated at any point.\n     template<typename _Tp1>\n-      __weak_ptr(const __weak_ptr<_Tp1, __l>& r)\n+      __weak_ptr(const __weak_ptr<_Tp1, _Lp>& r)\n       : _M_refcount(r._M_refcount) // never throws\n       {\n         __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>)\n         _M_ptr = r.lock().get();\n       }\n \n     template<typename _Tp1>\n-      __weak_ptr(const __shared_ptr<_Tp1, __l>& r)\n+      __weak_ptr(const __shared_ptr<_Tp1, _Lp>& r)\n       : _M_ptr(r._M_ptr), _M_refcount(r._M_refcount) // never throws\n-      {\n-        __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>)\n-      }\n+      { __glibcxx_function_requires(_ConvertibleConcept<_Tp1*, _Tp*>) }\n \n     template<typename _Tp1>\n       __weak_ptr&\n-      operator=(const __weak_ptr<_Tp1, __l>& r) // never throws\n+      operator=(const __weak_ptr<_Tp1, _Lp>& r) // never throws\n       {\n         _M_ptr = r.lock().get();\n         _M_refcount = r._M_refcount;\n@@ -909,39 +826,37 @@ template<typename _Tp, _Lock_policy __l>\n \n     template<typename _Tp1>\n       __weak_ptr&\n-      operator=(const __shared_ptr<_Tp1, __l>& r) // never throws\n+      operator=(const __shared_ptr<_Tp1, _Lp>& r) // never throws\n       {\n         _M_ptr = r._M_ptr;\n         _M_refcount = r._M_refcount;\n         return *this;\n       }\n \n-    __shared_ptr<_Tp, __l>\n+    __shared_ptr<_Tp, _Lp>\n     lock() const // never throws\n     {\n #ifdef __GTHREADS\n-\n-      // optimization: avoid throw overhead\n+      // Optimization: avoid throw overhead.\n       if (expired())\n-\treturn __shared_ptr<element_type, __l>();\n+\treturn __shared_ptr<element_type, _Lp>();\n       \n       try\n \t{\n-\t  return __shared_ptr<element_type, __l>(*this);\n+\t  return __shared_ptr<element_type, _Lp>(*this);\n \t}\n       catch (const bad_weak_ptr&)\n \t{\n-\t  // Q: how can we get here?\n-\t  // A: another thread may have invalidated r after the\n+\t  // Q: How can we get here?\n+\t  // A: Another thread may have invalidated r after the\n \t  //    use_count test above.\n \t  return __shared_ptr<element_type>();\n \t}\n \n #else\n-\n-      // optimization: avoid try/catch overhead when single threaded\n-      return expired() ? __shared_ptr<element_type, __l>()\n-\t               : __shared_ptr<element_type, __l>(*this);\n+      // Optimization: avoid try/catch overhead when single threaded.\n+      return expired() ? __shared_ptr<element_type, _Lp>()\n+\t               : __shared_ptr<element_type, _Lp>(*this);\n \n #endif\n     } // XXX MT\n@@ -966,118 +881,105 @@ template<typename _Tp, _Lock_policy __l>\n     }\n \n   private:\n-\n     template<typename _Tp1>\n       bool\n-      _M_less(const __weak_ptr<_Tp1, __l>& __rhs) const\n+      _M_less(const __weak_ptr<_Tp1, _Lp>& __rhs) const\n       { return _M_refcount < __rhs._M_refcount; }\n \n-    // used by __enable_shared_from_this\n+    // Used by __enable_shared_from_this.\n     void\n-    _M_assign(_Tp* __ptr, const shared_count<__l>& __refcount)\n+    _M_assign(_Tp* __ptr, const shared_count<_Lp>& __refcount)\n     {\n       _M_ptr = __ptr;\n       _M_refcount = __refcount;\n     }\n \n-    // friend injected into namespace and found by ADL\n-\n+    // Friend injected into namespace and found by ADL.\n     template<typename _Tp1>\n       friend inline bool\n-      operator<(const __weak_ptr& __lhs, const __weak_ptr<_Tp1, __l>& __rhs)\n+      operator<(const __weak_ptr& __lhs, const __weak_ptr<_Tp1, _Lp>& __rhs)\n       { return __lhs._M_less(__rhs); }\n \n-    template<typename _Tp1, _Lock_policy __l1> friend class __weak_ptr;\n-    template<typename _Tp1, _Lock_policy __l1> friend class __shared_ptr;\n-    friend class __enable_shared_from_this<_Tp, __l>;\n+    template<typename _Tp1, _Lock_policy _Lp1> friend class __weak_ptr;\n+    template<typename _Tp1, _Lock_policy _Lp1> friend class __shared_ptr;\n+    friend class __enable_shared_from_this<_Tp, _Lp>;\n \n-    _Tp*       _M_ptr;           // contained pointer\n-    weak_count<__l> _M_refcount;      // reference counter\n-\n-  };  // __weak_ptr\n+    _Tp*       \t\t_M_ptr;           // Contained pointer.\n+    weak_count<_Lp> \t_M_refcount;      // Reference counter.\n+  };  \n \n // 2.2.4.7 weak_ptr specialized algorithms.\n-template<typename _Tp, _Lock_policy __l>\n+template<typename _Tp, _Lock_policy _Lp>\n   void\n-  swap(__weak_ptr<_Tp, __l>& __a, __weak_ptr<_Tp, __l>& __b)\n+  swap(__weak_ptr<_Tp, _Lp>& __a, __weak_ptr<_Tp, _Lp>& __b)\n   { __a.swap(__b); }\n \n \n-template<typename _Tp, _Lock_policy __l = __shared_ptr_default_lock_mode>\n+template<typename _Tp, _Lock_policy _Lp = __default_lock_policy>\n   class __enable_shared_from_this\n   {\n   protected:\n+    __enable_shared_from_this() { }\n \n-    __enable_shared_from_this()\n-    { }\n-\n-    __enable_shared_from_this(const __enable_shared_from_this&)\n-    { }\n+    __enable_shared_from_this(const __enable_shared_from_this&) { }\n \n     __enable_shared_from_this&\n     operator=(const __enable_shared_from_this&)\n     { return *this; }\n \n-    ~__enable_shared_from_this()\n-    { }\n+    ~__enable_shared_from_this() { }\n \n   public:\n-\n-    __shared_ptr<_Tp, __l>\n+    __shared_ptr<_Tp, _Lp>\n     shared_from_this()\n     {\n-      __shared_ptr<_Tp, __l> __p(this->_M_weak_this);\n+      __shared_ptr<_Tp, _Lp> __p(this->_M_weak_this);\n       return __p;\n     }\n \n-    __shared_ptr<const _Tp, __l>\n+    __shared_ptr<const _Tp, _Lp>\n     shared_from_this() const\n     {\n-      __shared_ptr<const _Tp, __l> __p(this->_M_weak_this);\n+      __shared_ptr<const _Tp, _Lp> __p(this->_M_weak_this);\n       return __p;\n     }\n \n   private:\n     template<typename _Tp1>\n       void\n-      _M_weak_assign(_Tp1* __p, const shared_count<__l>& __n) const\n+      _M_weak_assign(_Tp1* __p, const shared_count<_Lp>& __n) const\n       { _M_weak_this._M_assign(__p, __n); }\n \n     template<typename _Tp1>\n       friend void\n-      __enable_shared_from_this_helper(const shared_count<__l>& __pn,\n+      __enable_shared_from_this_helper(const shared_count<_Lp>& __pn,\n \t\t\t\t       const __enable_shared_from_this* __pe,\n \t\t\t\t       const _Tp1* __px)\n       {\n-        if(__pe != 0)\n+        if (__pe != 0)\n           __pe->_M_weak_assign(const_cast<_Tp1*>(__px), __pn);\n       }\n \n-    mutable __weak_ptr<_Tp, __l> _M_weak_this;\n+    mutable __weak_ptr<_Tp, _Lp> _M_weak_this;\n   };\n \n template<typename _Tp>\n   class shared_ptr;\n \n-// The actual TR1 weak_ptr, with forwarding constructors and assignment operators.\n+// The actual TR1 weak_ptr, with forwarding constructors and\n+// assignment operators.\n template<typename _Tp>\n-  class weak_ptr\n-  : public __weak_ptr<_Tp>\n+  class weak_ptr : public __weak_ptr<_Tp>\n   {\n   public:\n-    weak_ptr()\n-    : __weak_ptr<_Tp>()\n-    { }\n+    weak_ptr() : __weak_ptr<_Tp>() { }\n   \n     template<typename _Tp1>\n-      weak_ptr(const __weak_ptr<_Tp1>& r)\n-      : __weak_ptr<_Tp>(r)\n-      { }\n+      weak_ptr(const __weak_ptr<_Tp1>& r) : __weak_ptr<_Tp>(r) { }\n     \n     template<typename _Tp1>\n-      weak_ptr(const __shared_ptr<_Tp1>& r)\n-      : __weak_ptr<_Tp>(r)\n-      { }\n+      weak_ptr(const __shared_ptr<_Tp1>& r) : __weak_ptr<_Tp>(r) { }\n+\n     template<typename _Tp1>\n       weak_ptr&\n       operator=(const weak_ptr<_Tp1>& r) // never throws\n@@ -1095,53 +997,46 @@ template<typename _Tp>\n       }\n   };\n \n-// The actual TR1 shared_ptr, with forwarding constructors and assignment operators.\n+// The actual TR1 shared_ptr, with forwarding constructors and\n+// assignment operators.\n template<typename _Tp>\n-  class shared_ptr\n-  : public __shared_ptr<_Tp>\n+  class shared_ptr : public __shared_ptr<_Tp>\n   {\n   public:\n-    shared_ptr()\n-    : __shared_ptr<_Tp>()\n-    { }\n+    shared_ptr() : __shared_ptr<_Tp>() { }\n     \n     template<typename _Tp1>\n       explicit shared_ptr(_Tp1* __p)\n-      : __shared_ptr<_Tp>(__p)\n-      { }\n+      : __shared_ptr<_Tp>(__p) { }\n     \n     template<typename _Tp1, typename _Deleter>\n       shared_ptr(_Tp1* __p, _Deleter __d)\n-      : __shared_ptr<_Tp>(__p, __d)\n-      { }\n+      : __shared_ptr<_Tp>(__p, __d) { }\n     \n     template<typename _Tp1>\n       shared_ptr(const __shared_ptr<_Tp1>& __r)\n-      : __shared_ptr<_Tp>(__r)\n-      { }\n+      : __shared_ptr<_Tp>(__r) { }\n     \n     template<typename _Tp1>\n       explicit shared_ptr(const __weak_ptr<_Tp1>& __r)\n-      : __shared_ptr<_Tp>(__r)\n-      { }\n+      : __shared_ptr<_Tp>(__r) { }\n     \n     template<typename _Tp1>\n       explicit shared_ptr(std::auto_ptr<_Tp1>& __r)\n-      : __shared_ptr<_Tp>(__r)\n-      { }\n+      : __shared_ptr<_Tp>(__r) { }\n+\n     template<typename _Tp1>\n       shared_ptr(const __shared_ptr<_Tp1>& __r, __static_cast_tag)\n-      : __shared_ptr<_Tp>(__r, __static_cast_tag())\n-      { }\n+      : __shared_ptr<_Tp>(__r, __static_cast_tag()) { }\n+\n     template<typename _Tp1>\n       shared_ptr(const __shared_ptr<_Tp1>& __r, __const_cast_tag)\n-      : __shared_ptr<_Tp>(__r, __const_cast_tag())\n-      { }\n+      : __shared_ptr<_Tp>(__r, __const_cast_tag()) { }\n     \n     template<typename _Tp1>\n       shared_ptr(const __shared_ptr<_Tp1>& __r, __dynamic_cast_tag)\n-      : __shared_ptr<_Tp>(__r, __dynamic_cast_tag())\n-      { }\n+      : __shared_ptr<_Tp>(__r, __dynamic_cast_tag()) { }\n+\n     // Additional non-base assignment operators to avoid excessive errors.\n     template<typename _Tp1>\n       shared_ptr&\n@@ -1150,6 +1045,7 @@ template<typename _Tp>\n         this->__shared_ptr<_Tp>::operator=(__r);\n         return *this;\n       }\n+\n     template<typename _Tp1>\n       shared_ptr&\n       operator=(const shared_ptr<_Tp1>& __r) // never throws\n@@ -1160,17 +1056,14 @@ template<typename _Tp>\n   };\n \n template<typename _Tp>\n-  class enable_shared_from_this\n-  : public __enable_shared_from_this<_Tp>\n+  class enable_shared_from_this : public __enable_shared_from_this<_Tp>\n   {\n   protected:\n     enable_shared_from_this()\n-    : __enable_shared_from_this<_Tp>()\n-    { }\n+    : __enable_shared_from_this<_Tp>() { }\n     \n     enable_shared_from_this(const enable_shared_from_this&)\n-    : __enable_shared_from_this<_Tp>(enable_shared_from_this<_Tp>())\n-    { }\n+    : __enable_shared_from_this<_Tp>(enable_shared_from_this<_Tp>()) { }\n   };\n \n _GLIBCXX_END_NAMESPACE"}, {"sha": "6befb91c6fad7477901a6767dc7671a363a8e071", "filename": "libstdc++-v3/include/tr1/memory", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e362c747413dc3767d020f522df127964b275ac/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fmemory", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e362c747413dc3767d020f522df127964b275ac/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fmemory", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fmemory?ref=2e362c747413dc3767d020f522df127964b275ac", "patch": "@@ -1,6 +1,6 @@\n // <tr1/memory> -*- C++ -*-\n \n-// Copyright (C) 2005 Free Software Foundation, Inc.\n+// Copyright (C) 2005, 2006 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -40,10 +40,9 @@\n #include <iosfwd>           // std::basic_ostream\n #include <cstdlib>          // std::abort\n \n-#include <bits/gthr.h>\n-#include <bits/atomicity.h>\n+#include <ext/atomicity.h>\n+#include <ext/concurrence.h>\n #include <bits/functexcept.h>\n-#include <bits/concurrence.h>\n #include <debug/debug.h>\n \n #include <tr1/boost_shared_ptr.h>"}, {"sha": "217a8cd804381e8f6e64a2f44d7458153407de9e", "filename": "libstdc++-v3/libsupc++/eh_alloc.cc", "status": "modified", "additions": 8, "deletions": 33, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e362c747413dc3767d020f522df127964b275ac/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_alloc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e362c747413dc3767d020f522df127964b275ac/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_alloc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_alloc.cc?ref=2e362c747413dc3767d020f522df127964b275ac", "patch": "@@ -39,7 +39,7 @@\n #include <climits>\n #include <exception>\n #include \"unwind-cxx.h\"\n-#include \"bits/gthr.h\"\n+#include <ext/concurrence.h>\n \n #if _GLIBCXX_HOSTED\n using std::free;\n@@ -89,23 +89,11 @@ typedef char one_buffer[EMERGENCY_OBJ_SIZE] __attribute__((aligned));\n static one_buffer emergency_buffer[EMERGENCY_OBJ_COUNT];\n static bitmask_type emergency_used;\n \n-\n-#ifdef __GTHREADS\n-#ifdef __GTHREAD_MUTEX_INIT\n-static __gthread_mutex_t emergency_mutex =__GTHREAD_MUTEX_INIT;\n-#else \n-static __gthread_mutex_t emergency_mutex;\n-#endif\n-\n-#ifdef __GTHREAD_MUTEX_INIT_FUNCTION\n-static void\n-emergency_mutex_init ()\n+namespace\n {\n-  __GTHREAD_MUTEX_INIT_FUNCTION (&emergency_mutex);\n+  // A single mutex controlling emergency allocations.\n+  __gnu_cxx::__mutex emergency_mutex;\n }\n-#endif\n-#endif\n-\n \n extern \"C\" void *\n __cxxabiv1::__cxa_allocate_exception(std::size_t thrown_size) throw()\n@@ -117,13 +105,7 @@ __cxxabiv1::__cxa_allocate_exception(std::size_t thrown_size) throw()\n \n   if (! ret)\n     {\n-#ifdef __GTHREADS\n-#ifdef __GTHREAD_MUTEX_INIT_FUNCTION\n-      static __gthread_once_t once = __GTHREAD_ONCE_INIT;\n-      __gthread_once (&once, emergency_mutex_init);\n-#endif\n-      __gthread_mutex_lock (&emergency_mutex);\n-#endif\n+      __gnu_cxx::__scoped_lock sentry(emergency_mutex);\n \n       bitmask_type used = emergency_used;\n       unsigned int which = 0;\n@@ -141,9 +123,7 @@ __cxxabiv1::__cxa_allocate_exception(std::size_t thrown_size) throw()\n       ret = &emergency_buffer[which][0];\n \n     failed:;\n-#ifdef __GTHREADS\n-      __gthread_mutex_unlock (&emergency_mutex);\n-#endif\n+\n       if (!ret)\n \tstd::terminate ();\n     }\n@@ -167,16 +147,11 @@ __cxxabiv1::__cxa_free_exception(void *vptr) throw()\n   if (ptr >= &emergency_buffer[0][0]\n       && ptr < &emergency_buffer[0][0] + sizeof (emergency_buffer))\n     {\n-      unsigned int which\n+      const unsigned int which\n \t= (unsigned)(ptr - &emergency_buffer[0][0]) / EMERGENCY_OBJ_SIZE;\n \n-#ifdef __GTHREADS\n-      __gthread_mutex_lock (&emergency_mutex);\n+      __gnu_cxx::__scoped_lock sentry(emergency_mutex);\n       emergency_used &= ~((bitmask_type)1 << which);\n-      __gthread_mutex_unlock (&emergency_mutex);\n-#else\n-      emergency_used &= ~((bitmask_type)1 << which);\n-#endif\n     }\n   else\n     free (ptr - sizeof (__cxa_exception));"}, {"sha": "a56fe15e7eea3fa408ef739e608bace6d36d2688", "filename": "libstdc++-v3/libsupc++/guard.cc", "status": "modified", "additions": 14, "deletions": 55, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e362c747413dc3767d020f522df127964b275ac/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fguard.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e362c747413dc3767d020f522df127964b275ac/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fguard.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fguard.cc?ref=2e362c747413dc3767d020f522df127964b275ac", "patch": "@@ -1,4 +1,4 @@\n-// Copyright (C) 2002 Free Software Foundation, Inc.\n+// Copyright (C) 2002, 2004, 2006 Free Software Foundation, Inc.\n //  \n // This file is part of GCC.\n //\n@@ -32,8 +32,8 @@\n #include <bits/c++config.h>\n #include <cxxabi.h>\n #include <exception>\n-#include <bits/gthr.h>\n-#include <bits/atomicity.h>\n+#include <ext/atomicity.h>\n+#include <ext/concurrence.h>\n \n // The IA64/generic ABI uses the first byte of the guard variable.\n // The ARM EABI uses the least significant bit.\n@@ -42,49 +42,8 @@\n #ifdef __GTHREADS\n namespace\n {\n-  // static_mutex is a single mutex controlling all static initializations.\n-  // This is a static class--the need for a static initialization function\n-  // to pass to __gthread_once precludes creating multiple instances, though\n-  // I suppose you could achieve the same effect with a template.\n-  class static_mutex\n-  {\n-    static __gthread_recursive_mutex_t mutex;\n-\n-#ifdef __GTHREAD_RECURSIVE_MUTEX_INIT_FUNCTION\n-    static void init();\n-#endif\n-\n-  public:\n-    static void lock();\n-    static void unlock();\n-  };\n-\n-  __gthread_recursive_mutex_t static_mutex::mutex\n-#ifdef __GTHREAD_RECURSIVE_MUTEX_INIT\n-  = __GTHREAD_RECURSIVE_MUTEX_INIT\n-#endif\n-  ;\n-\n-#ifdef __GTHREAD_RECURSIVE_MUTEX_INIT_FUNCTION\n-  void static_mutex::init()\n-  {\n-    __GTHREAD_RECURSIVE_MUTEX_INIT_FUNCTION (&mutex);\n-  }\n-#endif\n-\n-  void static_mutex::lock()\n-  {\n-#ifdef __GTHREAD_RECURSIVE_MUTEX_INIT_FUNCTION\n-    static __gthread_once_t once = __GTHREAD_ONCE_INIT;\n-    __gthread_once (&once, init);\n-#endif\n-    __gthread_recursive_mutex_lock (&mutex);\n-  }\n-\n-  void static_mutex::unlock ()\n-  {\n-    __gthread_recursive_mutex_unlock (&mutex);\n-  }\n+  // A single mutex controlling all static initializations.\n+  __gnu_cxx::__recursive_mutex static_mutex;\n }\n \n #ifndef _GLIBCXX_GUARD_TEST_AND_ACQUIRE\n@@ -125,14 +84,14 @@ namespace __gnu_cxx\n   // as well check for this situation and throw an exception.\n   // We use the second byte of the guard variable to remember that we're\n   // in the middle of an initialization.\n-  class recursive_init: public std::exception\n+  class recursive_init_error: public std::exception\n   {\n   public:\n-    recursive_init() throw() { }\n-    virtual ~recursive_init() throw ();\n+    recursive_init_error() throw() { }\n+    virtual ~recursive_init_error() throw ();\n   };\n \n-  recursive_init::~recursive_init() throw() { }\n+  recursive_init_error::~recursive_init_error() throw() { }\n }\n \n namespace __cxxabiv1 \n@@ -158,7 +117,7 @@ namespace __cxxabiv1\n     if (recursion_push (g))\n       {\n #ifdef __EXCEPTIONS\n-\tthrow __gnu_cxx::recursive_init();\n+\tthrow __gnu_cxx::recursive_init_error();\n #else\n \t// Use __builtin_trap so we don't require abort().\n \t__builtin_trap ();\n@@ -185,12 +144,12 @@ namespace __cxxabiv1\n \t  bool unlock;\n \t  mutex_wrapper (): unlock(true)\n \t  {\n-\t    static_mutex::lock ();\n+\t    static_mutex.lock();\n \t  }\n \t  ~mutex_wrapper ()\n \t  {\n \t    if (unlock)\n-\t      static_mutex::unlock ();\n+\t      static_mutex.unlock();\n \t  }\n \t} mw;\n \n@@ -213,7 +172,7 @@ namespace __cxxabiv1\n     recursion_pop (g);\n #ifdef __GTHREADS\n     if (__gthread_active_p ())\n-      static_mutex::unlock ();\n+      static_mutex.unlock();\n #endif\n   }\n \n@@ -224,7 +183,7 @@ namespace __cxxabiv1\n     _GLIBCXX_GUARD_SET_AND_RELEASE (g);\n #ifdef __GTHREADS\n     if (__gthread_active_p ())\n-      static_mutex::unlock ();\n+      static_mutex.unlock();\n #endif\n   }\n }"}, {"sha": "63208df60f97b2cb3744b0ae2974e35369b038d7", "filename": "libstdc++-v3/src/bitmap_allocator.cc", "status": "modified", "additions": 18, "deletions": 27, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e362c747413dc3767d020f522df127964b275ac/libstdc%2B%2B-v3%2Fsrc%2Fbitmap_allocator.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e362c747413dc3767d020f522df127964b275ac/libstdc%2B%2B-v3%2Fsrc%2Fbitmap_allocator.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fbitmap_allocator.cc?ref=2e362c747413dc3767d020f522df127964b275ac", "patch": "@@ -33,54 +33,45 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n \n   namespace balloc\n   {\n-    template class __mini_vector<std::pair\n-    <bitmap_allocator<char>::_Alloc_block*, \n-     bitmap_allocator<char>::_Alloc_block*> >;\n-\n-    template class __mini_vector<std::pair\n-    <bitmap_allocator<wchar_t>::_Alloc_block*, \n-     bitmap_allocator<wchar_t>::_Alloc_block*> >;\n-\n+    template class __mini_vector<std::pair<bitmap_allocator<char>::_Alloc_block*, bitmap_allocator<char>::_Alloc_block*> >;\n+    template class __mini_vector<std::pair<bitmap_allocator<wchar_t>::_Alloc_block*, bitmap_allocator<wchar_t>::_Alloc_block*> >;\n     template class __mini_vector<size_t*>;\n \n-    template size_t** __lower_bound\n-    (size_t**, size_t**, \n-     size_t const&, free_list::_LT_pointer_compare);\n+    template size_t** __lower_bound(size_t**, size_t**, size_t const&, \n+\t\t\t\t    free_list::_LT_pointer_compare);\n   }\n \n   size_t*\n   free_list::\n   _M_get(size_t __sz) throw(std::bad_alloc)\n   {\n #if defined __GTHREADS\n-    _Lock __bfl_lock(_M_get_mutex());\n-    __bfl_lock._M_lock();\n+    mutex_type& __bfl_mutex = _M_get_mutex();\n #endif\n-    iterator __temp = \n-      __gnu_cxx::balloc::__lower_bound\n-      (_M_get_free_list().begin(), _M_get_free_list().end(), \n-       __sz, _LT_pointer_compare());\n+    const vector_type& __free_list = _M_get_free_list();\n+    using __gnu_cxx::balloc::__lower_bound;\n+    iterator __tmp = __lower_bound(__free_list.begin(), __free_list.end(), \n+\t\t\t\t   __sz, _LT_pointer_compare());\n \n-    if (__temp == _M_get_free_list().end() || !_M_should_i_give(**__temp, __sz))\n+    if (__tmp == __free_list.end() || !_M_should_i_give(**__tmp, __sz))\n       {\n \t// We release the lock here, because operator new is\n \t// guaranteed to be thread-safe by the underlying\n \t// implementation.\n #if defined __GTHREADS\n-\t__bfl_lock._M_unlock();\n+\t__bfl_mutex.unlock();\n #endif\n \t// Try twice to get the memory: once directly, and the 2nd\n-\t// time after clearing the free list. If both fail, then\n-\t// throw std::bad_alloc().\n+\t// time after clearing the free list. If both fail, then throw\n+\t// std::bad_alloc().\n \tint __ctr = 2;\n \twhile (__ctr)\n \t  {\n \t    size_t* __ret = 0;\n \t    --__ctr;\n \t    try\n \t      {\n-\t\t__ret = reinterpret_cast<size_t*>\n-\t\t  (::operator new(__sz + sizeof(size_t)));\n+\t\t__ret = reinterpret_cast<size_t*>(::operator new(__sz + sizeof(size_t)));\n \t      }\n \t    catch(...)\n \t      {\n@@ -95,10 +86,10 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n       }\n     else\n       {\n-\tsize_t* __ret = *__temp;\n-\t_M_get_free_list().erase(__temp);\n+\tsize_t* __ret = *__tmp;\n+\t_M_get_free_list().erase(__tmp);\n #if defined __GTHREADS\n-\t__bfl_lock._M_unlock();\n+\t__bfl_mutex.unlock();\n #endif\n \treturn __ret + 1;\n       }\n@@ -109,7 +100,7 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n   _M_clear()\n   {\n #if defined __GTHREADS\n-    _Auto_Lock __bfl_lock(_M_get_mutex());\n+    __gnu_cxx::__scoped_lock __bfl_lock(_M_get_mutex());\n #endif\n     vector_type& __free_list = _M_get_free_list();\n     iterator __iter = __free_list.begin();"}, {"sha": "c43acd6e727528099d76e3e4d01df5ab68d3afbb", "filename": "libstdc++-v3/src/debug.cc", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e362c747413dc3767d020f522df127964b275ac/libstdc%2B%2B-v3%2Fsrc%2Fdebug.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e362c747413dc3767d020f522df127964b275ac/libstdc%2B%2B-v3%2Fsrc%2Fdebug.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fdebug.cc?ref=2e362c747413dc3767d020f522df127964b275ac", "patch": "@@ -35,14 +35,14 @@\n #include <cassert>\n #include <cstring>\n #include <cctype>\n-#include <bits/concurrence.h>\n+#include <ext/concurrence.h>\n \n using namespace std;\n \n namespace\n {\n-  static __glibcxx_mutex_define_initialized(iterator_base_mutex);\n-} \n+  __gnu_cxx::__mutex iterator_base_mutex;\n+} // anonymous namespace\n \n namespace __gnu_debug\n {\n@@ -192,7 +192,7 @@ namespace __gnu_debug\n     // Attach to the new sequence (if there is one)\n     if (__seq)\n       {\n-\t__gnu_cxx::lock sentry(iterator_base_mutex);\n+\t__gnu_cxx::__scoped_lock sentry(iterator_base_mutex);\n \t_M_sequence = __seq;\n \t_M_version = _M_sequence->_M_version;\n \t_M_prior = 0;\n@@ -217,7 +217,7 @@ namespace __gnu_debug\n   _Safe_iterator_base::\n   _M_detach()\n   {\n-    __gnu_cxx::lock sentry(iterator_base_mutex);\n+    __gnu_cxx::__scoped_lock sentry(iterator_base_mutex);\n     if (_M_sequence)\n       {\n \t// Remove us from this sequence's list"}, {"sha": "3fbee2cad4e9ae23256049de7cb248c16a4a54c2", "filename": "libstdc++-v3/src/ios.cc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e362c747413dc3767d020f522df127964b275ac/libstdc%2B%2B-v3%2Fsrc%2Fios.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e362c747413dc3767d020f522df127964b275ac/libstdc%2B%2B-v3%2Fsrc%2Fios.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fios.cc?ref=2e362c747413dc3767d020f522df127964b275ac", "patch": "@@ -34,7 +34,6 @@\n \n #include <ios>\n #include <limits>\n-#include <bits/atomicity.h>\n \n _GLIBCXX_BEGIN_NAMESPACE(std)\n "}, {"sha": "5c7ab2e8322b993c5c6adf6506132c15154582ab", "filename": "libstdc++-v3/src/ios_init.cc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e362c747413dc3767d020f522df127964b275ac/libstdc%2B%2B-v3%2Fsrc%2Fios_init.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e362c747413dc3767d020f522df127964b275ac/libstdc%2B%2B-v3%2Fsrc%2Fios_init.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fios_init.cc?ref=2e362c747413dc3767d020f522df127964b275ac", "patch": "@@ -36,7 +36,6 @@\n #include <ostream>\n #include <istream>\n #include <fstream>\n-#include <bits/atomicity.h>\n #include <ext/stdio_filebuf.h>\n #include <ext/stdio_sync_filebuf.h>\n "}, {"sha": "12070eb2eb22c3a9b91c92edb09c2f337086945d", "filename": "libstdc++-v3/src/locale.cc", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e362c747413dc3767d020f522df127964b275ac/libstdc%2B%2B-v3%2Fsrc%2Flocale.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e362c747413dc3767d020f522df127964b275ac/libstdc%2B%2B-v3%2Fsrc%2Flocale.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Flocale.cc?ref=2e362c747413dc3767d020f522df127964b275ac", "patch": "@@ -32,14 +32,12 @@\n #include <cctype>\n #include <cwctype>     // For towupper, etc.\n #include <locale>\n-#include <bits/atomicity.h>\n-#include <bits/concurrence.h>\n+#include <ext/concurrence.h>\n \n namespace\n {\n-  // Mutex object for cache access.\n-  static __glibcxx_mutex_define_initialized(locale_cache_mutex);\n-}\n+  __gnu_cxx::__mutex locale_cache_mutex;\n+} // anonymous namespace\n \n // XXX GLIBCXX_ABI Deprecated\n #ifdef _GLIBCXX_LONG_DOUBLE_COMPAT\n@@ -391,7 +389,7 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n   locale::_Impl::\n   _M_install_cache(const facet* __cache, size_t __index)\n   {\n-    __gnu_cxx::lock sentry(locale_cache_mutex);\n+    __gnu_cxx::__scoped_lock sentry(locale_cache_mutex);\n     if (_M_caches[__index] != 0)\n       {\n \t// Some other thread got in first."}, {"sha": "2b6b4af269406f1e281459ed1ca3b509488ba2d1", "filename": "libstdc++-v3/src/locale_init.cc", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e362c747413dc3767d020f522df127964b275ac/libstdc%2B%2B-v3%2Fsrc%2Flocale_init.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e362c747413dc3767d020f522df127964b275ac/libstdc%2B%2B-v3%2Fsrc%2Flocale_init.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Flocale_init.cc?ref=2e362c747413dc3767d020f522df127964b275ac", "patch": "@@ -32,8 +32,7 @@\n #include <cctype>\n #include <cwctype>     // For towupper, etc.\n #include <locale>\n-#include <bits/atomicity.h>\n-#include <bits/concurrence.h>\n+#include <ext/concurrence.h>\n \n namespace \n {\n@@ -200,16 +199,15 @@ namespace\n   fake_time_cache_w timepunct_cache_w;\n #endif\n \n-  // Mutex object for locale initialization.\n-  static __glibcxx_mutex_define_initialized(locale_mutex);\n+  __gnu_cxx::__mutex locale_mutex;\n } // anonymous namespace\n \n _GLIBCXX_BEGIN_NAMESPACE(std)\n \n   locale::locale() throw() : _M_impl(0)\n   { \n     _S_initialize();\n-    __gnu_cxx::lock sentry(locale_mutex);\n+    __gnu_cxx::__scoped_lock sentry(locale_mutex);\n     _S_global->_M_add_reference();\n     _M_impl = _S_global;\n   }\n@@ -220,7 +218,7 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n     _S_initialize();\n     _Impl* __old;\n     {\n-      __gnu_cxx::lock sentry(locale_mutex);\n+      __gnu_cxx::__scoped_lock sentry(locale_mutex);\n       __old = _S_global;\n       __other._M_impl->_M_add_reference();\n       _S_global = __other._M_impl;"}, {"sha": "4385fbc84bf65c01c1f9667af5c465858b6ddebb", "filename": "libstdc++-v3/src/mt_allocator.cc", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e362c747413dc3767d020f522df127964b275ac/libstdc%2B%2B-v3%2Fsrc%2Fmt_allocator.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e362c747413dc3767d020f522df127964b275ac/libstdc%2B%2B-v3%2Fsrc%2Fmt_allocator.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fmt_allocator.cc?ref=2e362c747413dc3767d020f522df127964b275ac", "patch": "@@ -32,7 +32,7 @@\n //\n \n #include <bits/c++config.h>\n-#include <bits/concurrence.h>\n+#include <ext/concurrence.h>\n #include <ext/mt_allocator.h>\n #include <cstring>\n \n@@ -59,13 +59,13 @@ namespace\n \n   // Ensure freelist is constructed first.\n   static __freelist freelist;\n-  static __glibcxx_mutex_define_initialized(freelist_mutex);\n+  __gnu_cxx::__mutex freelist_mutex;\n \n   static void \n   _M_destroy_thread_key(void* __id)\n   {\n     // Return this thread id record to the front of thread_freelist.\n-    __gnu_cxx::lock sentry(freelist_mutex);\n+    __gnu_cxx::__scoped_lock sentry(freelist_mutex);\n     size_t _M_id = reinterpret_cast<size_t>(__id);\n \n     typedef __gnu_cxx::__pool<true>::_Thread_record _Thread_record;\n@@ -497,11 +497,10 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n     if (__gthread_active_p())\n       {\n \t{\n-\t  __gnu_cxx::lock sentry(freelist_mutex);\n+\t  __gnu_cxx::__scoped_lock sentry(freelist_mutex);\n \n \t  if (!freelist._M_thread_freelist_array\n-\t      || freelist._M_max_threads\n-\t\t < _M_options._M_max_threads)\n+\t      || freelist._M_max_threads < _M_options._M_max_threads)\n \t    {\n \t      const size_t __k = sizeof(_Thread_record)\n \t\t\t\t * _M_options._M_max_threads;\n@@ -622,7 +621,7 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n \tif (_M_id == 0)\n \t  {\n \t    {\n-\t      __gnu_cxx::lock sentry(freelist_mutex);\n+\t      __gnu_cxx::__scoped_lock sentry(freelist_mutex);\n \t      if (freelist._M_thread_freelist)\n \t\t{\n \t\t  _M_id = freelist._M_thread_freelist->_M_id;\n@@ -695,7 +694,7 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n     if (__gthread_active_p())\n       {\n \t{\n-\t  __gnu_cxx::lock sentry(freelist_mutex);\n+\t  __gnu_cxx::__scoped_lock sentry(freelist_mutex);\n \n \t  if (!freelist._M_thread_freelist_array\n \t      || freelist._M_max_threads"}, {"sha": "c7593271b1dc5fb15678e02210df71c751a4843c", "filename": "libstdc++-v3/src/pool_allocator.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e362c747413dc3767d020f522df127964b275ac/libstdc%2B%2B-v3%2Fsrc%2Fpool_allocator.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e362c747413dc3767d020f522df127964b275ac/libstdc%2B%2B-v3%2Fsrc%2Fpool_allocator.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fpool_allocator.cc?ref=2e362c747413dc3767d020f522df127964b275ac", "patch": "@@ -37,8 +37,8 @@\n \n namespace\n {\n-  static __glibcxx_mutex_define_initialized(palloc_init_mutex);\n-}\n+  __gnu_cxx::__mutex palloc_init_mutex;\n+} // anonymous namespace\n \n _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n \n@@ -50,7 +50,7 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n     return _S_free_list + __i;\n   }\n \n-  mutex_type&\n+  __mutex&\n   __pool_alloc_base::_M_get_mutex()\n   { return palloc_init_mutex; }\n "}]}