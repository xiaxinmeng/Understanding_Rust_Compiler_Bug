{"sha": "606d9a09761f99e1810e938b548f4675403221bd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjA2ZDlhMDk3NjFmOTllMTgxMGU5MzhiNTQ4ZjQ2NzU0MDMyMjFiZA==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2011-09-03T19:48:39Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2011-09-03T19:48:39Z"}, "message": "ipa-prop.h (ipa_jump_func_t): New typedef.\n\n2011-09-03  Martin Jambor  <mjambor@suse.cz>\n\n\t* ipa-prop.h (ipa_jump_func_t): New typedef.\n\t(struct ipa_edge_args): Removed field argument_count, field\n\tjump_functions turned into a vector.\n\t(ipa_set_cs_argument_count): Removed.\n\t(ipa_get_cs_argument_count): Updated to work on vectors.\n\t(ipa_get_ith_jump_func): Likewise.\n\t* ipa-prop.c (ipa_count_arguments): Removed.\n\t(compute_scalar_jump_functions): Use ipa_get_ith_jump_func to access\n\tjump functions.  Update caller.\n\t(compute_pass_through_member_ptrs): Likewise.\n\t(compute_cst_member_ptr_arguments): Likewise.\n\t(ipa_compute_jump_functions_for_edge): Get number of arguments from\n\tthe statement, allocate vector.\n\t(ipa_compute_jump_functions): Do not call ipa_count_arguments.\n\t(duplicate_ipa_jump_func_array): Removed.\n\t(ipa_edge_duplication_hook): Use VEC_copy, do not copy argument count.\n\t(ipa_read_node_info): Allocate vector.\n\nFrom-SVN: r178502", "tree": {"sha": "f58a3c72614d08e1db1d533101a557475b159314", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f58a3c72614d08e1db1d533101a557475b159314"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/606d9a09761f99e1810e938b548f4675403221bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/606d9a09761f99e1810e938b548f4675403221bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/606d9a09761f99e1810e938b548f4675403221bd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/606d9a09761f99e1810e938b548f4675403221bd/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8f15b6055ff17fcf51bd7521c7472272af298417", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f15b6055ff17fcf51bd7521c7472272af298417", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f15b6055ff17fcf51bd7521c7472272af298417"}], "stats": {"total": 166, "additions": 66, "deletions": 100}, "files": [{"sha": "ec3f8aab3a901f24d3c74da53778ffe4c9c3e216", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/606d9a09761f99e1810e938b548f4675403221bd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/606d9a09761f99e1810e938b548f4675403221bd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=606d9a09761f99e1810e938b548f4675403221bd", "patch": "@@ -1,3 +1,23 @@\n+2011-09-03  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* ipa-prop.h (ipa_jump_func_t): New typedef.\n+\t(struct ipa_edge_args): Removed field argument_count, field\n+\tjump_functions turned into a vector.\n+\t(ipa_set_cs_argument_count): Removed.\n+\t(ipa_get_cs_argument_count): Updated to work on vectors.\n+\t(ipa_get_ith_jump_func): Likewise.\n+\t* ipa-prop.c (ipa_count_arguments): Removed.\n+\t(compute_scalar_jump_functions): Use ipa_get_ith_jump_func to access\n+\tjump functions.  Update caller.\n+\t(compute_pass_through_member_ptrs): Likewise.\n+\t(compute_cst_member_ptr_arguments): Likewise.\n+\t(ipa_compute_jump_functions_for_edge): Get number of arguments from\n+\tthe statement, allocate vector.\n+\t(ipa_compute_jump_functions): Do not call ipa_count_arguments.\n+\t(duplicate_ipa_jump_func_array): Removed.\n+\t(ipa_edge_duplication_hook): Use VEC_copy, do not copy argument count.\n+\t(ipa_read_node_info): Allocate vector.\n+\n 2011-09-03  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n \n \tPR middle-end/50232"}, {"sha": "066bbdbf03e35325f70fcb9ab93491320dcd23c8", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 37, "deletions": 81, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/606d9a09761f99e1810e938b548f4675403221bd/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/606d9a09761f99e1810e938b548f4675403221bd/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=606d9a09761f99e1810e938b548f4675403221bd", "patch": "@@ -143,25 +143,6 @@ ipa_initialize_node_params (struct cgraph_node *node)\n     }\n }\n \n-/* Count number of arguments callsite CS has and store it in\n-   ipa_edge_args structure corresponding to this callsite.  */\n-\n-static void\n-ipa_count_arguments (struct cgraph_edge *cs)\n-{\n-  gimple stmt;\n-  int arg_num;\n-\n-  stmt = cs->call_stmt;\n-  gcc_assert (is_gimple_call (stmt));\n-  arg_num = gimple_call_num_args (stmt);\n-  if (VEC_length (ipa_edge_args_t, ipa_edge_args_vector)\n-      <= (unsigned) cgraph_edge_max_uid)\n-    VEC_safe_grow_cleared (ipa_edge_args_t, gc,\n-\t\t\t   ipa_edge_args_vector, cgraph_edge_max_uid + 1);\n-  ipa_set_cs_argument_count (IPA_EDGE_REF (cs), arg_num);\n-}\n-\n /* Print the jump functions associated with call graph edge CS to file F.  */\n \n static void\n@@ -696,20 +677,21 @@ compute_known_type_jump_func (tree op, struct ipa_jump_func *jfunc,\n \n static void\n compute_scalar_jump_functions (struct ipa_node_params *info,\n-\t\t\t       struct ipa_jump_func *functions,\n+\t\t\t       struct ipa_edge_args *args,\n \t\t\t       gimple call)\n {\n   tree arg;\n   unsigned num = 0;\n \n   for (num = 0; num < gimple_call_num_args (call); num++)\n     {\n+      struct ipa_jump_func *jfunc = ipa_get_ith_jump_func (args, num);\n       arg = gimple_call_arg (call, num);\n \n       if (is_gimple_ip_invariant (arg))\n \t{\n-\t  functions[num].type = IPA_JF_CONST;\n-\t  functions[num].value.constant = arg;\n+\t  jfunc->type = IPA_JF_CONST;\n+\t  jfunc->value.constant = arg;\n \t}\n       else if (TREE_CODE (arg) == SSA_NAME)\n \t{\n@@ -718,26 +700,24 @@ compute_scalar_jump_functions (struct ipa_node_params *info,\n \t      int index = ipa_get_param_decl_index (info, SSA_NAME_VAR (arg));\n \n \t      if (index >= 0\n-\t\t  && !detect_type_change_ssa (arg, call, &functions[num]))\n+\t\t  && !detect_type_change_ssa (arg, call, jfunc))\n \t\t{\n-\t\t  functions[num].type = IPA_JF_PASS_THROUGH;\n-\t\t  functions[num].value.pass_through.formal_id = index;\n-\t\t  functions[num].value.pass_through.operation = NOP_EXPR;\n+\t\t  jfunc->type = IPA_JF_PASS_THROUGH;\n+\t\t  jfunc->value.pass_through.formal_id = index;\n+\t\t  jfunc->value.pass_through.operation = NOP_EXPR;\n \t\t}\n \t    }\n \t  else\n \t    {\n \t      gimple stmt = SSA_NAME_DEF_STMT (arg);\n \t      if (is_gimple_assign (stmt))\n-\t\tcompute_complex_assign_jump_func (info, &functions[num],\n-\t\t\t\t\t\t  call, stmt, arg);\n+\t\tcompute_complex_assign_jump_func (info, jfunc, call, stmt, arg);\n \t      else if (gimple_code (stmt) == GIMPLE_PHI)\n-\t\tcompute_complex_ancestor_jump_func (info, &functions[num],\n-\t\t\t\t\t\t    call, stmt);\n+\t\tcompute_complex_ancestor_jump_func (info, jfunc, call, stmt);\n \t    }\n \t}\n       else\n-\tcompute_known_type_jump_func (arg, &functions[num], call);\n+\tcompute_known_type_jump_func (arg, jfunc, call);\n     }\n }\n \n@@ -821,7 +801,7 @@ is_parm_modified_before_call (struct param_analysis_info *parm_info,\n static bool\n compute_pass_through_member_ptrs (struct ipa_node_params *info,\n \t\t\t\t  struct param_analysis_info *parms_info,\n-\t\t\t\t  struct ipa_jump_func *functions,\n+\t\t\t\t  struct ipa_edge_args *args,\n \t\t\t\t  gimple call)\n {\n   bool undecided_members = false;\n@@ -841,9 +821,11 @@ compute_pass_through_member_ptrs (struct ipa_node_params *info,\n \t      gcc_assert (index >=0);\n \t      if (!is_parm_modified_before_call (&parms_info[index], call, arg))\n \t\t{\n-\t\t  functions[num].type = IPA_JF_PASS_THROUGH;\n-\t\t  functions[num].value.pass_through.formal_id = index;\n-\t\t  functions[num].value.pass_through.operation = NOP_EXPR;\n+\t\t  struct ipa_jump_func *jfunc = ipa_get_ith_jump_func (args,\n+\t\t\t\t\t\t\t\t       num);\n+\t\t  jfunc->type = IPA_JF_PASS_THROUGH;\n+\t\t  jfunc->value.pass_through.formal_id = index;\n+\t\t  jfunc->value.pass_through.operation = NOP_EXPR;\n \t\t}\n \t      else\n \t\tundecided_members = true;\n@@ -969,21 +951,21 @@ determine_cst_member_ptr (gimple call, tree arg, tree method_field,\n    associated with the call.  */\n \n static void\n-compute_cst_member_ptr_arguments (struct ipa_jump_func *functions,\n+compute_cst_member_ptr_arguments (struct ipa_edge_args *args,\n \t\t\t\t  gimple call)\n {\n   unsigned num;\n   tree arg, method_field, delta_field;\n \n   for (num = 0; num < gimple_call_num_args (call); num++)\n     {\n+      struct ipa_jump_func *jfunc = ipa_get_ith_jump_func (args, num);\n       arg = gimple_call_arg (call, num);\n \n-      if (functions[num].type == IPA_JF_UNKNOWN\n+      if (jfunc->type == IPA_JF_UNKNOWN\n \t  && type_like_member_ptr_p (TREE_TYPE (arg), &method_field,\n \t\t\t\t     &delta_field))\n-\tdetermine_cst_member_ptr (call, arg, method_field, delta_field,\n-\t\t\t\t  &functions[num]);\n+\tdetermine_cst_member_ptr (call, arg, method_field, delta_field, jfunc);\n     }\n }\n \n@@ -996,29 +978,25 @@ ipa_compute_jump_functions_for_edge (struct param_analysis_info *parms_info,\n \t\t\t\t     struct cgraph_edge *cs)\n {\n   struct ipa_node_params *info = IPA_NODE_REF (cs->caller);\n-  struct ipa_edge_args *arguments = IPA_EDGE_REF (cs);\n-  gimple call;\n+  struct ipa_edge_args *args = IPA_EDGE_REF (cs);\n+  gimple call = cs->call_stmt;\n+  int arg_num = gimple_call_num_args (call);\n \n-  if (ipa_get_cs_argument_count (arguments) == 0 || arguments->jump_functions)\n+  if (arg_num == 0 || args->jump_functions)\n     return;\n-  arguments->jump_functions = ggc_alloc_cleared_vec_ipa_jump_func\n-    (ipa_get_cs_argument_count (arguments));\n-\n-  call = cs->call_stmt;\n-  gcc_assert (is_gimple_call (call));\n+  VEC_safe_grow_cleared (ipa_jump_func_t, gc, args->jump_functions, arg_num);\n \n   /* We will deal with constants and SSA scalars first:  */\n-  compute_scalar_jump_functions (info, arguments->jump_functions, call);\n+  compute_scalar_jump_functions (info, args, call);\n \n   /* Let's check whether there are any potential member pointers and if so,\n      whether we can determine their functions as pass_through.  */\n-  if (!compute_pass_through_member_ptrs (info, parms_info,\n-\t\t\t\t\t arguments->jump_functions, call))\n+  if (!compute_pass_through_member_ptrs (info, parms_info, args, call))\n     return;\n \n   /* Finally, let's check whether we actually pass a new constant member\n      pointer here...  */\n-  compute_cst_member_ptr_arguments (arguments->jump_functions, call);\n+  compute_cst_member_ptr_arguments (args, call);\n }\n \n /* Compute jump functions for all edges - both direct and indirect - outgoing\n@@ -1038,15 +1016,11 @@ ipa_compute_jump_functions (struct cgraph_node *node,\n \t functions unless they may become known during lto/whopr.  */\n       if (!callee->analyzed && !flag_lto)\n \tcontinue;\n-      ipa_count_arguments (cs);\n       ipa_compute_jump_functions_for_edge (parms_info, cs);\n     }\n \n   for (cs = node->indirect_calls; cs; cs = cs->next_callee)\n-    {\n-      ipa_count_arguments (cs);\n-      ipa_compute_jump_functions_for_edge (parms_info, cs);\n-    }\n+    ipa_compute_jump_functions_for_edge (parms_info, cs);\n }\n \n /* If RHS looks like a rhs of a statement loading pfn from a member\n@@ -1900,37 +1874,21 @@ ipa_node_removal_hook (struct cgraph_node *node, void *data ATTRIBUTE_UNUSED)\n   ipa_free_node_params_substructures (IPA_NODE_REF (node));\n }\n \n-static struct ipa_jump_func *\n-duplicate_ipa_jump_func_array (const struct ipa_jump_func * src, size_t n)\n-{\n-  struct ipa_jump_func *p;\n-\n-  if (!src)\n-    return NULL;\n-\n-  p = ggc_alloc_vec_ipa_jump_func (n);\n-  memcpy (p, src, n * sizeof (struct ipa_jump_func));\n-  return p;\n-}\n-\n /* Hook that is called by cgraph.c when a node is duplicated.  */\n \n static void\n ipa_edge_duplication_hook (struct cgraph_edge *src, struct cgraph_edge *dst,\n \t\t\t   __attribute__((unused)) void *data)\n {\n   struct ipa_edge_args *old_args, *new_args;\n-  int arg_count;\n \n   ipa_check_create_edge_args ();\n \n   old_args = IPA_EDGE_REF (src);\n   new_args = IPA_EDGE_REF (dst);\n \n-  arg_count = ipa_get_cs_argument_count (old_args);\n-  ipa_set_cs_argument_count (new_args, arg_count);\n-  new_args->jump_functions =\n-    duplicate_ipa_jump_func_array (old_args->jump_functions, arg_count);\n+  new_args->jump_functions = VEC_copy (ipa_jump_func_t, gc,\n+\t\t\t\t       old_args->jump_functions);\n \n   if (iinlining_processed_edges\n       && bitmap_bit_p (iinlining_processed_edges, src->uid))\n@@ -2802,12 +2760,10 @@ ipa_read_node_info (struct lto_input_block *ib, struct cgraph_node *node,\n       struct ipa_edge_args *args = IPA_EDGE_REF (e);\n       int count = streamer_read_uhwi (ib);\n \n-      ipa_set_cs_argument_count (args, count);\n       if (!count)\n \tcontinue;\n+      VEC_safe_grow_cleared (ipa_jump_func_t, gc, args->jump_functions, count);\n \n-      args->jump_functions = ggc_alloc_cleared_vec_ipa_jump_func\n-\t(ipa_get_cs_argument_count (args));\n       for (k = 0; k < ipa_get_cs_argument_count (args); k++)\n \tipa_read_jump_function (ib, ipa_get_ith_jump_func (args, k), data_in);\n     }\n@@ -2816,13 +2772,13 @@ ipa_read_node_info (struct lto_input_block *ib, struct cgraph_node *node,\n       struct ipa_edge_args *args = IPA_EDGE_REF (e);\n       int count = streamer_read_uhwi (ib);\n \n-      ipa_set_cs_argument_count (args, count);\n       if (count)\n \t{\n-          args->jump_functions = ggc_alloc_cleared_vec_ipa_jump_func\n-\t    (ipa_get_cs_argument_count (args));\n+\t  VEC_safe_grow_cleared (ipa_jump_func_t, gc, args->jump_functions,\n+\t\t\t\t count);\n           for (k = 0; k < ipa_get_cs_argument_count (args); k++)\n-\t    ipa_read_jump_function (ib, ipa_get_ith_jump_func (args, k), data_in);\n+\t    ipa_read_jump_function (ib, ipa_get_ith_jump_func (args, k),\n+\t\t\t\t    data_in);\n \t}\n       ipa_read_indirect_edge_info (ib, data_in, e);\n     }"}, {"sha": "fafd17d2fce8330fdfc94fed73d4ab40d153f1aa", "filename": "gcc/ipa-prop.h", "status": "modified", "additions": 9, "deletions": 19, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/606d9a09761f99e1810e938b548f4675403221bd/gcc%2Fipa-prop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/606d9a09761f99e1810e938b548f4675403221bd/gcc%2Fipa-prop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.h?ref=606d9a09761f99e1810e938b548f4675403221bd", "patch": "@@ -119,7 +119,7 @@ struct GTY(()) ipa_member_ptr_cst\n /* A jump function for a callsite represents the values passed as actual\n    arguments of the callsite. See enum jump_func_type for the various\n    types of jump functions supported.  */\n-struct GTY (()) ipa_jump_func\n+typedef struct GTY (()) ipa_jump_func\n {\n   enum jump_func_type type;\n   /* Represents a value of a jump function.  pass_through is used only in jump\n@@ -133,7 +133,10 @@ struct GTY (()) ipa_jump_func\n     struct ipa_pass_through_data GTY ((tag (\"IPA_JF_PASS_THROUGH\"))) pass_through;\n     struct ipa_ancestor_jf_data GTY ((tag (\"IPA_JF_ANCESTOR\"))) ancestor;\n   } GTY ((desc (\"%1.type\"))) value;\n-};\n+} ipa_jump_func_t;\n+\n+DEF_VEC_O (ipa_jump_func_t);\n+DEF_VEC_ALLOC_O (ipa_jump_func_t, gc);\n \n /* Summary describing a single formal parameter.  */\n \n@@ -223,31 +226,19 @@ ipa_is_param_used (struct ipa_node_params *info, int i)\n    arguments.  It can be accessed by the IPA_EDGE_REF macro.  */\n typedef struct GTY(()) ipa_edge_args\n {\n-  /* Number of actual arguments in this callsite.  When set to 0,\n-     this callsite's parameters would not be analyzed by the different\n-     stages of IPA CP.  */\n-  int argument_count;\n-  /* Array of the callsite's jump function of each parameter.  */\n-  struct ipa_jump_func GTY ((length (\"%h.argument_count\"))) *jump_functions;\n+  /* Vector of the callsite's jump function of each parameter.  */\n+  VEC (ipa_jump_func_t, gc) *jump_functions;\n } ipa_edge_args_t;\n \n /* ipa_edge_args access functions.  Please use these to access fields that\n    are or will be shared among various passes.  */\n \n-/* Set the number of actual arguments. */\n-\n-static inline void\n-ipa_set_cs_argument_count (struct ipa_edge_args *args, int count)\n-{\n-  args->argument_count = count;\n-}\n-\n /* Return the number of actual arguments. */\n \n static inline int\n ipa_get_cs_argument_count (struct ipa_edge_args *args)\n {\n-  return args->argument_count;\n+  return VEC_length (ipa_jump_func_t, args->jump_functions);\n }\n \n /* Returns a pointer to the jump function for the ith argument.  Please note\n@@ -257,8 +248,7 @@ ipa_get_cs_argument_count (struct ipa_edge_args *args)\n static inline struct ipa_jump_func *\n ipa_get_ith_jump_func (struct ipa_edge_args *args, int i)\n {\n-  gcc_assert (i >= 0 && i <= args->argument_count);\n-  return &args->jump_functions[i];\n+  return VEC_index (ipa_jump_func_t, args->jump_functions, i);\n }\n \n /* Vectors need to have typedefs of structures.  */"}]}