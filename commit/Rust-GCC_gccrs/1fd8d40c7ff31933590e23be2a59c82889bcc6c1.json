{"sha": "1fd8d40c7ff31933590e23be2a59c82889bcc6c1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWZkOGQ0MGM3ZmYzMTkzMzU5MGUyM2JlMmE1OWM4Mjg4OWJjYzZjMQ==", "commit": {"author": {"name": "Kyrylo Tkachov", "email": "kyrylo.tkachov@arm.com", "date": "2015-08-04T10:17:13Z"}, "committer": {"name": "Kyrylo Tkachov", "email": "ktkachov@gcc.gnu.org", "date": "2015-08-04T10:17:13Z"}, "message": "[AArch64][9/14] Implement TARGET_CAN_INLINE_P\n\n\t* config/aarch64/aarch64.c (aarch64_tribools_ok_for_inlining_p):\n\tNew function.\n\t(aarch64_can_inline_p): Likewise.\n\t(TARGET_CAN_INLINE_P): Define.\n\nFrom-SVN: r226561", "tree": {"sha": "4295b4a44f7bfe4d4ba64773dfc09cd2770fd901", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4295b4a44f7bfe4d4ba64773dfc09cd2770fd901"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1fd8d40c7ff31933590e23be2a59c82889bcc6c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1fd8d40c7ff31933590e23be2a59c82889bcc6c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1fd8d40c7ff31933590e23be2a59c82889bcc6c1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1fd8d40c7ff31933590e23be2a59c82889bcc6c1/comments", "author": {"login": "ktkachov-arm", "id": 74917949, "node_id": "MDQ6VXNlcjc0OTE3OTQ5", "avatar_url": "https://avatars.githubusercontent.com/u/74917949?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ktkachov-arm", "html_url": "https://github.com/ktkachov-arm", "followers_url": "https://api.github.com/users/ktkachov-arm/followers", "following_url": "https://api.github.com/users/ktkachov-arm/following{/other_user}", "gists_url": "https://api.github.com/users/ktkachov-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/ktkachov-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ktkachov-arm/subscriptions", "organizations_url": "https://api.github.com/users/ktkachov-arm/orgs", "repos_url": "https://api.github.com/users/ktkachov-arm/repos", "events_url": "https://api.github.com/users/ktkachov-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/ktkachov-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5a2c833115cc88f420f577e36ba46be6295cc23a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a2c833115cc88f420f577e36ba46be6295cc23a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a2c833115cc88f420f577e36ba46be6295cc23a"}], "stats": {"total": 117, "additions": 117, "deletions": 0}, "files": [{"sha": "28a55d5529eb5d650cfa755112362dc61c4a973b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fd8d40c7ff31933590e23be2a59c82889bcc6c1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fd8d40c7ff31933590e23be2a59c82889bcc6c1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1fd8d40c7ff31933590e23be2a59c82889bcc6c1", "patch": "@@ -1,3 +1,10 @@\n+2015-08-04  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n+\n+\t* config/aarch64/aarch64.c (aarch64_tribools_ok_for_inlining_p):\n+\tNew function.\n+\t(aarch64_can_inline_p): Likewise.\n+\t(TARGET_CAN_INLINE_P): Define.\n+\n 2015-08-04  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \t* common/config/aarch64/aarch64-common.c (aarch64_handle_option):"}, {"sha": "6b418a7a12993e7b375e19a520dd5420c7dc57ca", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fd8d40c7ff31933590e23be2a59c82889bcc6c1/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fd8d40c7ff31933590e23be2a59c82889bcc6c1/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=1fd8d40c7ff31933590e23be2a59c82889bcc6c1", "patch": "@@ -8459,6 +8459,113 @@ aarch64_option_valid_attribute_p (tree fndecl, tree, tree args, int)\n   return ret;\n }\n \n+/* Helper for aarch64_can_inline_p.  In the case where CALLER and CALLEE are\n+   tri-bool options (yes, no, don't care) and the default value is\n+   DEF, determine whether to reject inlining.  */\n+\n+static bool\n+aarch64_tribools_ok_for_inlining_p (int caller, int callee,\n+\t\t\t\t     int dont_care, int def)\n+{\n+  /* If the callee doesn't care, always allow inlining.  */\n+  if (callee == dont_care)\n+    return true;\n+\n+  /* If the caller doesn't care, always allow inlining.  */\n+  if (caller == dont_care)\n+    return true;\n+\n+  /* Otherwise, allow inlining if either the callee and caller values\n+     agree, or if the callee is using the default value.  */\n+  return (callee == caller || callee == def);\n+}\n+\n+/* Implement TARGET_CAN_INLINE_P.  Decide whether it is valid\n+   to inline CALLEE into CALLER based on target-specific info.\n+   Make sure that the caller and callee have compatible architectural\n+   features.  Then go through the other possible target attributes\n+   and see if they can block inlining.  Try not to reject always_inline\n+   callees unless they are incompatible architecturally.  */\n+\n+static bool\n+aarch64_can_inline_p (tree caller, tree callee)\n+{\n+  tree caller_tree = DECL_FUNCTION_SPECIFIC_TARGET (caller);\n+  tree callee_tree = DECL_FUNCTION_SPECIFIC_TARGET (callee);\n+\n+  /* If callee has no option attributes, then it is ok to inline.  */\n+  if (!callee_tree)\n+    return true;\n+\n+  struct cl_target_option *caller_opts\n+\t= TREE_TARGET_OPTION (caller_tree ? caller_tree\n+\t\t\t\t\t   : target_option_default_node);\n+\n+  struct cl_target_option *callee_opts = TREE_TARGET_OPTION (callee_tree);\n+\n+\n+  /* Callee's ISA flags should be a subset of the caller's.  */\n+  if ((caller_opts->x_aarch64_isa_flags & callee_opts->x_aarch64_isa_flags)\n+       != callee_opts->x_aarch64_isa_flags)\n+    return false;\n+\n+  /* Allow non-strict aligned functions inlining into strict\n+     aligned ones.  */\n+  if ((TARGET_STRICT_ALIGN_P (caller_opts->x_target_flags)\n+       != TARGET_STRICT_ALIGN_P (callee_opts->x_target_flags))\n+      && !(!TARGET_STRICT_ALIGN_P (callee_opts->x_target_flags)\n+\t   && TARGET_STRICT_ALIGN_P (caller_opts->x_target_flags)))\n+    return false;\n+\n+  bool always_inline = lookup_attribute (\"always_inline\",\n+\t\t\t\t\t  DECL_ATTRIBUTES (callee));\n+\n+  /* If the architectural features match up and the callee is always_inline\n+     then the other attributes don't matter.  */\n+  if (always_inline)\n+    return true;\n+\n+  if (caller_opts->x_aarch64_cmodel_var\n+      != callee_opts->x_aarch64_cmodel_var)\n+    return false;\n+\n+  if (caller_opts->x_aarch64_tls_dialect\n+      != callee_opts->x_aarch64_tls_dialect)\n+    return false;\n+\n+  /* Honour explicit requests to workaround errata.  */\n+  if (!aarch64_tribools_ok_for_inlining_p (\n+\t  caller_opts->x_aarch64_fix_a53_err835769,\n+\t  callee_opts->x_aarch64_fix_a53_err835769,\n+\t  2, TARGET_FIX_ERR_A53_835769_DEFAULT))\n+    return false;\n+\n+  /* If the user explicitly specified -momit-leaf-frame-pointer for the\n+     caller and calle and they don't match up, reject inlining.  */\n+  if (!aarch64_tribools_ok_for_inlining_p (\n+\t  caller_opts->x_flag_omit_leaf_frame_pointer,\n+\t  callee_opts->x_flag_omit_leaf_frame_pointer,\n+\t  2, 1))\n+    return false;\n+\n+  /* If the callee has specific tuning overrides, respect them.  */\n+  if (callee_opts->x_aarch64_override_tune_string != NULL\n+      && caller_opts->x_aarch64_override_tune_string == NULL)\n+    return false;\n+\n+  /* If the user specified tuning override strings for the\n+     caller and callee and they don't match up, reject inlining.\n+     We just do a string compare here, we don't analyze the meaning\n+     of the string, as it would be too costly for little gain.  */\n+  if (callee_opts->x_aarch64_override_tune_string\n+      && caller_opts->x_aarch64_override_tune_string\n+      && (strcmp (callee_opts->x_aarch64_override_tune_string,\n+\t\t  caller_opts->x_aarch64_override_tune_string) != 0))\n+    return false;\n+\n+  return true;\n+}\n+\n /* Return true if SYMBOL_REF X binds locally.  */\n \n static bool\n@@ -12863,6 +12970,9 @@ aarch64_promoted_type (const_tree t)\n #undef TARGET_CAN_ELIMINATE\n #define TARGET_CAN_ELIMINATE aarch64_can_eliminate\n \n+#undef TARGET_CAN_INLINE_P\n+#define TARGET_CAN_INLINE_P aarch64_can_inline_p\n+\n #undef TARGET_CANNOT_FORCE_CONST_MEM\n #define TARGET_CANNOT_FORCE_CONST_MEM aarch64_cannot_force_const_mem\n "}]}