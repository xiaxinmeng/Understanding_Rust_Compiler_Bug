{"sha": "b6dc500c521ecf59d64f9132d71bb11367997ab2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjZkYzUwMGM1MjFlY2Y1OWQ2NGY5MTMyZDcxYmIxMTM2Nzk5N2FiMg==", "commit": {"author": {"name": "Janis Johnson", "email": "janis187@us.ibm.com", "date": "2004-11-12T01:11:01Z"}, "committer": {"name": "Janis Johnson", "email": "janis@gcc.gnu.org", "date": "2004-11-12T01:11:01Z"}, "message": "target-supports.exp (get-compiler_messages): New.\n\n\t* lib/target-supports.exp (get-compiler_messages): New.\n\t(check_named_sections_available): Use it.\n\t(check_effective_target_ilp32): New.\n\t(check_effective_target_lp64): New.\n\t(is-effective-target): New.\n\t* lib/gcc-dg.exp (dg-require-effective-target): New.\n\nCo-Authored-By: Richard Sandiford <rsandifo@redhat.com>\n\nFrom-SVN: r90515", "tree": {"sha": "5d6493f798e0075fdcf59230ca2d281bf8ffb18d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5d6493f798e0075fdcf59230ca2d281bf8ffb18d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b6dc500c521ecf59d64f9132d71bb11367997ab2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6dc500c521ecf59d64f9132d71bb11367997ab2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6dc500c521ecf59d64f9132d71bb11367997ab2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6dc500c521ecf59d64f9132d71bb11367997ab2/comments", "author": null, "committer": null, "parents": [{"sha": "49a94e56d8f93392027e57c86e31882c6fa21887", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49a94e56d8f93392027e57c86e31882c6fa21887", "html_url": "https://github.com/Rust-GCC/gccrs/commit/49a94e56d8f93392027e57c86e31882c6fa21887"}], "stats": {"total": 107, "additions": 91, "deletions": 16}, "files": [{"sha": "501175878c217d0a429cf18322cc24af96d0ed4e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6dc500c521ecf59d64f9132d71bb11367997ab2/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6dc500c521ecf59d64f9132d71bb11367997ab2/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b6dc500c521ecf59d64f9132d71bb11367997ab2", "patch": "@@ -1,3 +1,13 @@\n+2004-11-11  Janis Johnson  <janis187@us.ibm.com>\n+\t    Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t* lib/target-supports.exp (get-compiler_messages): New.\n+\t(check_named_sections_available): Use it.\n+\t(check_effective_target_ilp32): New.\n+\t(check_effective_target_lp64): New.\n+\t(is-effective-target): New.\n+\t* lib/gcc-dg.exp (dg-require-effective-target): New.\n+\n 2004-11-11  Joseph S. Myers  <joseph@codesourcery.com>\n \n \t* gcc.dg/precedence-1.c: New test."}, {"sha": "2c2ee009fd637745f94b147b44605ba10fe5ddaf", "filename": "gcc/testsuite/lib/gcc-dg.exp", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6dc500c521ecf59d64f9132d71bb11367997ab2/gcc%2Ftestsuite%2Flib%2Fgcc-dg.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6dc500c521ecf59d64f9132d71bb11367997ab2/gcc%2Ftestsuite%2Flib%2Fgcc-dg.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Fgcc-dg.exp?ref=b6dc500c521ecf59d64f9132d71bb11367997ab2", "patch": "@@ -432,6 +432,16 @@ proc dg-require-named-sections { args } {\n     }\n }\n \n+# If the target does not match the required effective target, skip this test.\n+\n+proc dg-require-effective-target { args } {\n+    set args [lreplace $args 0 0]\n+    if { ![is-effective-target [lindex $args 0]] } {\n+\tupvar dg-do-what dg-do-what\n+\tskip_test_and_clear_xfail\n+    }\n+}\n+\n # Prune any messages matching ARGS[1] (a regexp) from test output.\n proc dg-prune-output { args } {\n     global additional_prunes"}, {"sha": "df1b4416cfc1d35625675774e0791472f144fff5", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 71, "deletions": 16, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6dc500c521ecf59d64f9132d71bb11367997ab2/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6dc500c521ecf59d64f9132d71bb11367997ab2/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=b6dc500c521ecf59d64f9132d71bb11367997ab2", "patch": "@@ -19,6 +19,29 @@\n \n # This file defines procs for determining features supported by the target.\n \n+# Try to compile some code and return the messages printed by the compiler.\n+#\n+# BASENAME is a basename to use for temporary files.\n+# TYPE is the type of compilation to perform (see target_compile).\n+# CONTENTS gives the contents of the input file.\n+proc get_compiler_messages {basename type contents} {\n+    global tool\n+\n+    set src ${basename}[pid].c\n+    switch $type {\n+\tassembly { set output ${basename}[pid].s }\n+\tobject { set output ${basename}[pid].o }\n+    }\n+    set f [open $src \"w\"]\n+    puts $f $contents\n+    close $f\n+    set lines [${tool}_target_compile $src $output $type \"\"]\n+    file delete $src\n+    remote_file build delete $output\n+\n+    return $lines\n+}\n+\n ###############################\n # proc check_weak_available { }\n ###############################\n@@ -280,22 +303,11 @@ proc check_iconv_available { test_what } {\n # when cycling over subtarget options (e.g. irix o32/n32/n64) in\n # the same test run.\n proc check_named_sections_available { } {\n-    global tool\n-\n-    set src named[pid].c\n-    set obj named[pid].o\n-    verbose \"check_named_sections_available compiling testfile $src\" 2\n-    set f [open $src \"w\"]\n-    # Compile a small test program.\n-    puts $f \"int __attribute__ ((section(\\\"whatever\\\"))) foo;\"\n-    close $f\n-    set lines [${tool}_target_compile $src $obj object \"\"]\n-    file delete $src\n-    remote_file build delete $obj\n-\n-    # If we got no error messages, everything is OK.\n-    set answer [string match \"\" $lines]\n-    verbose \"check_named_sections_available  returning $answer\" 2\n+    verbose \"check_named_sections_available: compiling source\" 2\n+    set answer [string match \"\" [get_compiler_messages named object {\n+\tint __attribute__ ((section(\"whatever\"))) foo;\n+    }]]\n+    verbose \"check_named_sections_available: returning $answer\" 2\n     return $answer\n }\n \n@@ -355,3 +367,46 @@ proc check_vmx_hw_available { } {\n \n     return $vmx_hw_available_saved\n }\n+\n+# Return 1 if we're generating 32-bit code using default options, 0\n+# otherwise.\n+\n+proc check_effective_target_ilp32 { } {\n+    verbose \"check_effective_target_ilp32: compiling source\" 2\n+    set answer [string match \"\" [get_compiler_messages ilp32 object {\n+\tint dummy[(sizeof (int) == 4 && sizeof (void *) == 4 && sizeof (long) == 4 ) ? 1 : -1];\n+    }]]\n+    verbose \"check_effective_target_ilp32: returning $answer\" 2\n+    return $answer\n+}\n+\n+# Return 1 if we're generating 64-bit code using default options, 0\n+# otherwise.\n+\n+proc check_effective_target_lp64 { } {\n+    verbose \"check_effective_target_lp64: compiling source\" 2\n+    set answer [string match \"\" [get_compiler_messages lp64 object {\n+\tint dummy[(sizeof (int) == 4 && sizeof (void *) == 8 && sizeof (long) == 8 ) ? 1 : -1];\n+    }]]\n+    verbose \"check_effective_target_lp64: returning $answer\" 2\n+    return $answer\n+}\n+\n+# Return 1 if the target matches the effective target 'arg', 0 otherwise.\n+# This can be used with any check_* proc that takes no argument and\n+# returns only 1 or 0.  It could be used with check_* procs that take\n+# arguments with keywords that pass particular arguments.\n+\n+proc is-effective-target { arg } {\n+    set selected 0\n+    switch $arg {\n+\t\"ilp32\"  { set selected [check_effective_target_ilp32] }\n+\t\"lp64\"   { set selected [check_effective_target_lp64] }\n+\t\"vmx_hw\" { set selected [check_vmx_hw_available] }\n+\t\"named_sections\" { set selected [check_named_sections_available] }\n+\t\"gc_sections\" { set selected [check_gc_sections_available] }\n+\tdefault  { error \"unknown effective target selector `$arg'\" }\n+    }\n+    verbose \"is-effective-target: $arg $selected\" 2\n+    return $selected\n+}"}]}