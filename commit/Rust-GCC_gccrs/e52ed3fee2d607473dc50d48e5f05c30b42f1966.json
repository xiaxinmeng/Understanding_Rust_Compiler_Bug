{"sha": "e52ed3fee2d607473dc50d48e5f05c30b42f1966", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTUyZWQzZmVlMmQ2MDc0NzNkYzUwZDQ4ZTVmMDVjMzBiNDJmMTk2Ng==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2016-08-08T20:10:19Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2016-08-08T20:10:19Z"}, "message": "Use class substring_loc in c-format.c (PR c/52952)\n\ngcc/c-family/ChangeLog:\n\tPR c/52952\n\t* c-format.c: Include \"diagnostic.h\".\n\t(location_column_from_byte_offset): Delete.\n\t(location_from_offset): Delete.\n\t(format_warning_va): New function.\n\t(format_warning_at_substring): New function.\n\t(format_warning_at_char): New function.\n\t(check_format_arg): Capture location of format_tree and pass to\n\tcheck_format_info_main.\n\t(argument_parser): Add fields \"start_of_this_format\" and\n\t\"format_string_cst\".\n\t(flag_chars_t::validate): Add param \"format_string_cst\".  Convert\n\twarning_at call using location_from_offset to call to\n\tformat_warning_at_char.\n\t(argument_parser::argument_parser): Add param \"format_string_cst_\"\n\tand use use it to initialize field \"format_string_cst\".\n\tInitialize new field \"start_of_this_format\".\n\t(argument_parser::read_format_flags): Convert warning_at call\n\tusing location_from_offset to a call to format_warning_at_char.\n\t(argument_parser::read_any_format_left_precision): Likewise.\n\t(argument_parser::read_any_format_precision): Likewise.\n\t(argument_parser::read_any_other_modifier): Likewise.\n\t(argument_parser::find_format_char_info): Likewise, in three places.\n\t(argument_parser::parse_any_scan_set): Likewise, in one place.\n\t(argument_parser::handle_conversions): Likewise, in two places.\n\t(argument_parser::check_argument_type): Add param \"fmt_param_loc\"\n\tand use it to make a substring_loc.  Pass the latter to\n\tcheck_format_types.\n\t(check_format_info_main): Add params \"fmt_param_loc\" and\n\t\"format_string_cst\".  Convert warning_at calls using\n\tlocation_from_offset to calls to format_warning_at_char.  Pass the\n\tnew params to the arg_parser ctor.  Pass \"format_string_cst\" to\n\tflag_chars.validate.  Pass \"fmt_param_loc\" to\n\targ_parser.check_argument_type.\n\t(check_format_types): Convert first param from a location_t\n\tto a const substring_loc & and rename to \"fmt_loc\".  Attempt\n\tto extract the range of the relevant parameter and pass it\n\tto format_type_warning.\n\t(format_type_warning): Convert first param from a location_t\n\tto a const substring_loc & and rename to \"fmt_loc\".  Add\n\tparams \"param_range\" and \"type\".  Replace calls to warning_at\n\twith calls to format_warning_at_substring.\n\ngcc/testsuite/ChangeLog:\n\tPR c/52952\n\t* gcc.dg/cpp/pr66415-1.c: Likewise.\n\t* gcc.dg/format/asm_fprintf-1.c: Update column numbers.\n\t* gcc.dg/format/c90-printf-1.c: Likewise.\n\t* gcc.dg/format/diagnostic-ranges.c: New test case.\n\nFrom-SVN: r239253", "tree": {"sha": "1b7fed1d67ce31784e5db3e8d574083aca1d6576", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1b7fed1d67ce31784e5db3e8d574083aca1d6576"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e52ed3fee2d607473dc50d48e5f05c30b42f1966", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e52ed3fee2d607473dc50d48e5f05c30b42f1966", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e52ed3fee2d607473dc50d48e5f05c30b42f1966", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e52ed3fee2d607473dc50d48e5f05c30b42f1966/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f432d1282d585bbedaa4293ec4bac0b7c8c2024a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f432d1282d585bbedaa4293ec4bac0b7c8c2024a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f432d1282d585bbedaa4293ec4bac0b7c8c2024a"}], "stats": {"total": 790, "additions": 605, "deletions": 185}, "files": [{"sha": "f03a078b43861f60a3cfb476c1f5b2f240e467ad", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e52ed3fee2d607473dc50d48e5f05c30b42f1966/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e52ed3fee2d607473dc50d48e5f05c30b42f1966/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=e52ed3fee2d607473dc50d48e5f05c30b42f1966", "patch": "@@ -1,3 +1,48 @@\n+2016-08-08  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR c/52952\n+\t* c-format.c: Include \"diagnostic.h\".\n+\t(location_column_from_byte_offset): Delete.\n+\t(location_from_offset): Delete.\n+\t(format_warning_va): New function.\n+\t(format_warning_at_substring): New function.\n+\t(format_warning_at_char): New function.\n+\t(check_format_arg): Capture location of format_tree and pass to\n+\tcheck_format_info_main.\n+\t(argument_parser): Add fields \"start_of_this_format\" and\n+\t\"format_string_cst\".\n+\t(flag_chars_t::validate): Add param \"format_string_cst\".  Convert\n+\twarning_at call using location_from_offset to call to\n+\tformat_warning_at_char.\n+\t(argument_parser::argument_parser): Add param \"format_string_cst_\"\n+\tand use use it to initialize field \"format_string_cst\".\n+\tInitialize new field \"start_of_this_format\".\n+\t(argument_parser::read_format_flags): Convert warning_at call\n+\tusing location_from_offset to a call to format_warning_at_char.\n+\t(argument_parser::read_any_format_left_precision): Likewise.\n+\t(argument_parser::read_any_format_precision): Likewise.\n+\t(argument_parser::read_any_other_modifier): Likewise.\n+\t(argument_parser::find_format_char_info): Likewise, in three places.\n+\t(argument_parser::parse_any_scan_set): Likewise, in one place.\n+\t(argument_parser::handle_conversions): Likewise, in two places.\n+\t(argument_parser::check_argument_type): Add param \"fmt_param_loc\"\n+\tand use it to make a substring_loc.  Pass the latter to\n+\tcheck_format_types.\n+\t(check_format_info_main): Add params \"fmt_param_loc\" and\n+\t\"format_string_cst\".  Convert warning_at calls using\n+\tlocation_from_offset to calls to format_warning_at_char.  Pass the\n+\tnew params to the arg_parser ctor.  Pass \"format_string_cst\" to\n+\tflag_chars.validate.  Pass \"fmt_param_loc\" to\n+\targ_parser.check_argument_type.\n+\t(check_format_types): Convert first param from a location_t\n+\tto a const substring_loc & and rename to \"fmt_loc\".  Attempt\n+\tto extract the range of the relevant parameter and pass it\n+\tto format_type_warning.\n+\t(format_type_warning): Convert first param from a location_t\n+\tto a const substring_loc & and rename to \"fmt_loc\".  Add\n+\tparams \"param_range\" and \"type\".  Replace calls to warning_at\n+\twith calls to format_warning_at_substring.\n+\n 2016-08-08  David Malcolm  <dmalcolm@redhat.com>\n \n \t* c-format.c (class flag_chars_t): New class."}, {"sha": "eff2ab4321c689c07f4d3a30d5837031a3ad7d7a", "filename": "gcc/c-family/c-format.c", "status": "modified", "additions": 313, "deletions": 174, "changes": 487, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e52ed3fee2d607473dc50d48e5f05c30b42f1966/gcc%2Fc-family%2Fc-format.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e52ed3fee2d607473dc50d48e5f05c30b42f1966/gcc%2Fc-family%2Fc-format.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-format.c?ref=e52ed3fee2d607473dc50d48e5f05c30b42f1966", "patch": "@@ -29,6 +29,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"intl.h\"\n #include \"langhooks.h\"\n #include \"c-format.h\"\n+#include \"diagnostic.h\"\n \n /* Handle attributes associated with format checking.  */\n \n@@ -65,78 +66,169 @@ static int first_target_format_type;\n static const char *format_name (int format_num);\n static int format_flags (int format_num);\n \n-/* Given a string S of length LINE_WIDTH, find the visual column\n-   corresponding to OFFSET bytes.   */\n+/* Emit a warning governed by option OPT, using GMSGID as the format\n+   string and AP as its arguments.\n \n-static unsigned int\n-location_column_from_byte_offset (const char *s, int line_width,\n-\t\t\t\t  unsigned int offset)\n-{\n-  const char * c = s;\n-  if (*c != '\"')\n-    return 0;\n+   Attempt to obtain precise location information within a string\n+   literal from FMT_LOC.\n+\n+   Case 1: if substring location is available, and is within the range of\n+   the format string itself, the primary location of the\n+   diagnostic is the substring range obtained from FMT_LOC, with the\n+   caret at the *end* of the substring range.\n+\n+   For example:\n+\n+     test.c:90:10: warning: problem with '%i' here [-Wformat=]\n+     printf (\"hello %i\", msg);\n+                    ~^\n+\n+   Case 2: if the substring location is available, but is not within\n+   the range of the format string, the primary location is that of the\n+   format string, and an note is emitted showing the substring location.\n+\n+   For example:\n+     test.c:90:10: warning: problem with '%i' here [-Wformat=]\n+     printf(\"hello \" INT_FMT \" world\", msg);\n+            ^~~~~~~~~~~~~~~~~~~~~~~~~\n+     test.c:19: note: format string is defined here\n+     #define INT_FMT \"%i\"\n+                      ~^\n+\n+   Case 3: if precise substring information is unavailable, the primary\n+   location is that of the whole string passed to FMT_LOC's constructor.\n+   For example:\n+\n+     test.c:90:10: warning: problem with '%i' here [-Wformat=]\n+     printf(fmt, msg);\n+            ^~~\n+\n+   For each of cases 1-3, if param_range is non-NULL, then it is used\n+   as a secondary range within the warning.  For example, here it\n+   is used with case 1:\n+\n+     test.c:90:16: warning: '%s' here but arg 2 has 'long' type [-Wformat=]\n+     printf (\"foo %s bar\", long_i + long_j);\n+                  ~^       ~~~~~~~~~~~~~~~\n \n-  c++, offset--;\n-  while (offset > 0)\n+   and here with case 2:\n+\n+     test.c:90:16: warning: '%s' here but arg 2 has 'long' type [-Wformat=]\n+     printf (\"foo \" STR_FMT \" bar\", long_i + long_j);\n+             ^~~~~~~~~~~~~~~~~~~~~  ~~~~~~~~~~~~~~~\n+     test.c:89:16: note: format string is defined here\n+     #define STR_FMT \"%s\"\n+                      ~^\n+\n+   and with case 3:\n+\n+     test.c:90:10: warning: '%i' here, but arg 2 is \"const char *' [-Wformat=]\n+     printf(fmt, msg);\n+            ^~~  ~~~\n+\n+   Return true if a warning was emitted, false otherwise.  */\n+\n+ATTRIBUTE_GCC_DIAG (4,0)\n+static bool\n+format_warning_va (const substring_loc &fmt_loc, source_range *param_range,\n+\t\t   int opt, const char *gmsgid, va_list *ap)\n+{\n+  bool substring_within_range = false;\n+  location_t primary_loc;\n+  location_t substring_loc = UNKNOWN_LOCATION;\n+  source_range fmt_loc_range\n+    = get_range_from_loc (line_table, fmt_loc.get_fmt_string_loc ());\n+  source_range fmt_substring_range;\n+  const char *err = fmt_loc.get_range (&fmt_substring_range);\n+  if (err)\n+    /* Case 3: unable to get substring location.  */\n+    primary_loc = fmt_loc.get_fmt_string_loc ();\n+  else\n     {\n-      if (c - s >= line_width)\n-\treturn 0;\n+      substring_loc = make_location (fmt_substring_range.m_finish,\n+\t\t\t\t     fmt_substring_range.m_start,\n+\t\t\t\t     fmt_substring_range.m_finish);\n \n-      switch (*c)\n+      if (fmt_substring_range.m_start >= fmt_loc_range.m_start\n+\t  && fmt_substring_range.m_finish <= fmt_loc_range.m_finish)\n+\t/* Case 1.  */\n \t{\n-\tcase '\\\\':\n-\t  c++;\n-\t  if (c - s >= line_width)\n-\t    return 0;\n-\t  switch (*c)\n-\t    {\n-\t    case '\\\\': case '\\'': case '\"': case '?':\n-\t    case '(': case '{': case '[': case '%':\n-\t    case 'a': case 'b': case 'f': case 'n':\n-\t    case 'r': case 't': case 'v': \n-\t    case 'e': case 'E':\n-\t      c++, offset--;\n-\t      break;\n+\t  substring_within_range = true;\n+\t  primary_loc = substring_loc;\n+\t}\n+      else\n+\t/* Case 2.  */\n+\t{\n+\t  substring_within_range = false;\n+\t  primary_loc = fmt_loc.get_fmt_string_loc ();\n+\t}\n+    }\n \n-\t    default:\n-\t      return 0;\n-\t    }\n-\t  break;\n+  rich_location richloc (line_table, primary_loc);\n \n-\tcase '\"':\n-\t  /* We found the end of the string too early.  */\n-\t  return 0;\n-\t  \n-\tdefault:\n-\t  c++, offset--;\n-\t  break;\n-\t}\n+  if (param_range)\n+    {\n+      location_t param_loc = make_location (param_range->m_start,\n+\t\t\t\t\t    param_range->m_start,\n+\t\t\t\t\t    param_range->m_finish);\n+      richloc.add_range (param_loc, false);\n     }\n-  return c - s;\n+\n+  diagnostic_info diagnostic;\n+  diagnostic_set_info (&diagnostic, gmsgid, ap, &richloc, DK_WARNING);\n+  diagnostic.option_index = opt;\n+  bool warned = report_diagnostic (&diagnostic);\n+\n+  if (!err && substring_loc && !substring_within_range)\n+    /* Case 2.  */\n+    if (warned)\n+      inform (substring_loc, \"format string is defined here\");\n+\n+  return warned;\n }\n \n-/* Return a location that encodes the same location as LOC but shifted\n-   by OFFSET bytes.  */\n+/* Variadic call to format_warning_va.  */\n \n-static location_t\n-location_from_offset (location_t loc, int offset)\n+ATTRIBUTE_GCC_DIAG (4,0)\n+static bool\n+format_warning_at_substring (const substring_loc &fmt_loc,\n+\t\t\t     source_range *param_range,\n+\t\t\t     int opt, const char *gmsgid, ...)\n {\n-  gcc_checking_assert (offset >= 0);\n-  if (linemap_location_from_macro_expansion_p (line_table, loc)\n-      || offset < 0)\n-    return loc;\n+  va_list ap;\n+  va_start (ap, gmsgid);\n+  bool warned = format_warning_va (fmt_loc, param_range, opt, gmsgid, &ap);\n+  va_end (ap);\n \n-  expanded_location s = expand_location_to_spelling_point (loc);\n-  int line_width;\n-  const char *line = location_get_source_line (s.file, s.line, &line_width);\n-  if (line == NULL)\n-    return loc;\n-  line += s.column - 1 ;\n-  line_width -= s.column - 1;\n-  unsigned int column =\n-    location_column_from_byte_offset (line, line_width, (unsigned) offset);\n+  return warned;\n+}\n+\n+/* Emit a warning as per format_warning_va, but construct the substring_loc\n+   for the character at offset (CHAR_IDX - 1) within a string constant\n+   FORMAT_STRING_CST at FMT_STRING_LOC.  */\n \n-  return linemap_position_for_loc_and_offset (line_table, loc, column);\n+ATTRIBUTE_GCC_DIAG (5,6)\n+static bool\n+format_warning_at_char (location_t fmt_string_loc, tree format_string_cst,\n+\t\t\tint char_idx, int opt, const char *gmsgid, ...)\n+{\n+  va_list ap;\n+  va_start (ap, gmsgid);\n+  tree string_type = TREE_TYPE (format_string_cst);\n+\n+  /* The callers are of the form:\n+       format_warning (format_string_loc, format_string_cst,\n+\t\t       format_chars - orig_format_chars,\n+      where format_chars has already been incremented, so that\n+      CHAR_IDX is one character beyond where the warning should\n+      be emitted.  Fix it.  */\n+  char_idx -= 1;\n+\n+  substring_loc fmt_loc (fmt_string_loc, string_type, char_idx, char_idx);\n+  bool warned = format_warning_va (fmt_loc, NULL, opt, gmsgid, &ap);\n+  va_end (ap);\n+\n+  return warned;\n }\n \n /* Check that we have a pointer to a string suitable for use as a format.\n@@ -1018,8 +1110,9 @@ format_flags (int format_num)\n static void check_format_info (function_format_info *, tree);\n static void check_format_arg (void *, tree, unsigned HOST_WIDE_INT);\n static void check_format_info_main (format_check_results *,\n-\t\t\t\t    function_format_info *,\n-\t\t\t\t    const char *, int, tree,\n+\t\t\t\t    function_format_info *, const char *,\n+\t\t\t\t    location_t, tree,\n+\t\t\t\t    int, tree,\n \t\t\t\t    unsigned HOST_WIDE_INT,\n \t\t\t\t    object_allocator<format_wanted_type> &);\n \n@@ -1032,8 +1125,12 @@ static void finish_dollar_format_checking (format_check_results *, int);\n static const format_flag_spec *get_flag_spec (const format_flag_spec *,\n \t\t\t\t\t      int, const char *);\n \n-static void check_format_types (location_t, format_wanted_type *);\n-static void format_type_warning (location_t, format_wanted_type *, tree, tree);\n+static void check_format_types (const substring_loc &fmt_loc,\n+\t\t\t\tformat_wanted_type *);\n+static void format_type_warning (const substring_loc &fmt_loc,\n+\t\t\t\t source_range *param_range,\n+\t\t\t\t format_wanted_type *, tree,\n+\t\t\t\t tree);\n \n /* Decode a format type from a string, returning the type, or\n    format_type_error if not valid, in which case the caller should print an\n@@ -1509,6 +1606,8 @@ check_format_arg (void *ctx, tree format_tree,\n   tree array_size = 0;\n   tree array_init;\n \n+  location_t fmt_param_loc = EXPR_LOC_OR_LOC (format_tree, input_location);\n+\n   if (VAR_P (format_tree))\n     {\n       /* Pull out a constant value if the front end didn't.  */\n@@ -1684,8 +1783,8 @@ check_format_arg (void *ctx, tree format_tree,\n      need not adjust it for every return.  */\n   res->number_other++;\n   object_allocator <format_wanted_type> fwt_pool (\"format_wanted_type pool\");\n-  check_format_info_main (res, info, format_chars, format_length,\n-\t\t\t  params, arg_num, fwt_pool);\n+  check_format_info_main (res, info, format_chars, fmt_param_loc, format_tree,\n+\t\t\t  format_length, params, arg_num, fwt_pool);\n }\n \n /* Support class for argument_parser and check_format_info_main.\n@@ -1702,6 +1801,7 @@ class flag_chars_t\n \t\t const format_char_info *fci,\n \t\t const format_flag_spec *flag_specs,\n \t\t const char * const format_chars,\n+\t\t tree format_string_cst,\n \t\t location_t format_string_loc,\n \t\t const char * const orig_format_chars,\n \t\t char format_char);\n@@ -1744,6 +1844,7 @@ class argument_parser\n {\n  public:\n   argument_parser (function_format_info *info, const char *&format_chars,\n+\t\t   tree format_string_cst,\n \t\t   const char * const orig_format_chars,\n \t\t   location_t format_string_loc, flag_chars_t &flag_chars,\n \t\t   int &has_operand_number, tree first_fillin_param,\n@@ -1799,13 +1900,16 @@ class argument_parser\n \t\t       unsigned HOST_WIDE_INT &arg_num,\n \t\t       tree &params,\n \t\t       const int alloc_flag,\n-\t\t       const char * const format_start);\n+\t\t       const char * const format_start,\n+\t\t       location_t fmt_param_loc);\n \n  private:\n   const function_format_info *const info;\n   const format_kind_info * const fki;\n   const format_flag_spec * const flag_specs;\n+  const char *start_of_this_format;\n   const char *&format_chars;\n+  const tree format_string_cst;\n   const char * const orig_format_chars;\n   const location_t format_string_loc;\n   object_allocator <format_wanted_type> &fwt_pool;\n@@ -1855,6 +1959,7 @@ flag_chars_t::validate (const format_kind_info *fki,\n \t\t\tconst format_char_info *fci,\n \t\t\tconst format_flag_spec *flag_specs,\n \t\t\tconst char * const format_chars,\n+\t\t\ttree format_string_cst,\n \t\t\tlocation_t format_string_loc,\n \t\t\tconst char * const orig_format_chars,\n \t\t\tchar format_char)\n@@ -1870,11 +1975,11 @@ flag_chars_t::validate (const format_kind_info *fki,\n \tcontinue;\n       if (strchr (fci->flag_chars, m_flag_chars[i]) == 0)\n \t{\n-\t  warning_at (location_from_offset (format_string_loc,\n-\t\t\t\t\t    format_chars\n-\t\t\t\t\t    - orig_format_chars),\n-\t\t      OPT_Wformat_, \"%s used with %<%%%c%> %s format\",\n-\t\t      _(s->name), format_char, fki->name);\n+\t  format_warning_at_char (format_string_loc, format_string_cst,\n+\t\t\t\t  format_chars - orig_format_chars,\n+\t\t\t\t  OPT_Wformat_,\n+\t\t\t\t  \"%s used with %<%%%c%> %s format\",\n+\t\t\t\t  _(s->name), format_char, fki->name);\n \t  d++;\n \t  continue;\n \t}\n@@ -1935,6 +2040,7 @@ flag_chars_t::assignment_suppression_p (const format_kind_info *fki)\n \n argument_parser::\n argument_parser (function_format_info *info_, const char *&format_chars_,\n+\t\t tree format_string_cst_,\n \t\t const char * const orig_format_chars_,\n \t\t location_t format_string_loc_,\n \t\t flag_chars_t &flag_chars_,\n@@ -1944,7 +2050,9 @@ argument_parser (function_format_info *info_, const char *&format_chars_,\n : info (info_),\n   fki (&format_types[info->format_type]),\n   flag_specs (fki->flag_specs),\n+  start_of_this_format (format_chars_),\n   format_chars (format_chars_),\n+  format_string_cst (format_string_cst_),\n   orig_format_chars (orig_format_chars_),\n   format_string_loc (format_string_loc_),\n   fwt_pool (fwt_pool_),\n@@ -2008,11 +2116,10 @@ argument_parser::read_format_flags ()\n \t\t\t\t\t\t *format_chars, NULL);\n       if (flag_chars.has_char_p (*format_chars))\n \t{\n-\t  warning_at (location_from_offset (format_string_loc,\n-\t\t\t\t\t    format_chars + 1\n-\t\t\t\t\t    - orig_format_chars),\n-\t\t      OPT_Wformat_,\n-\t\t      \"repeated %s in format\", _(s->name));\n+\t  format_warning_at_char (format_string_loc, format_string_cst,\n+\t\t\t\t  format_chars + 1 - orig_format_chars,\n+\t\t\t\t  OPT_Wformat_,\n+\t\t\t\t  \"repeated %s in format\", _(s->name));\n \t}\n       else\n \tflag_chars.add_char (*format_chars);\n@@ -2145,10 +2252,10 @@ argument_parser::read_any_format_left_precision ()\n   ++format_chars;\n   flag_chars.add_char (fki->left_precision_char);\n   if (!ISDIGIT (*format_chars))\n-    warning_at (location_from_offset (format_string_loc,\n-\t\t\t\t      format_chars - orig_format_chars),\n-\t\tOPT_Wformat_,\n-\t\t\"empty left precision in %s format\", fki->name);\n+    format_warning_at_char (format_string_loc, format_string_cst,\n+\t\t\t    format_chars - orig_format_chars,\n+\t\t\t    OPT_Wformat_,\n+\t\t\t    \"empty left precision in %s format\", fki->name);\n   while (ISDIGIT (*format_chars))\n     ++format_chars;\n }\n@@ -2236,10 +2343,10 @@ read_any_format_precision (tree &params,\n     {\n       if (!(fki->flags & (int) FMT_FLAG_EMPTY_PREC_OK)\n \t  && !ISDIGIT (*format_chars))\n-\twarning_at (location_from_offset (format_string_loc,\n-\t\t\t\t\t  format_chars - orig_format_chars),\n-\t\t    OPT_Wformat_,\n-\t\t    \"empty precision in %s format\", fki->name);\n+\tformat_warning_at_char (format_string_loc, format_string_cst,\n+\t\t\t\tformat_chars - orig_format_chars,\n+\t\t\t\tOPT_Wformat_,\n+\t\t\t\t\"empty precision in %s format\", fki->name);\n       while (ISDIGIT (*format_chars))\n \t++format_chars;\n     }\n@@ -2340,11 +2447,10 @@ argument_parser::read_any_other_modifier ()\n \t{\n \t  const format_flag_spec *s = get_flag_spec (flag_specs,\n \t\t\t\t\t\t     *format_chars, NULL);\n-\t  warning_at (location_from_offset (format_string_loc,\n-\t\t\t\t\t    format_chars\n-\t\t\t\t\t    - orig_format_chars),\n-\t\t      OPT_Wformat_,\n-\t\t      \"repeated %s in format\", _(s->name));\n+\t  format_warning_at_char (format_string_loc, format_string_cst,\n+\t\t\t\t  format_chars - orig_format_chars,\n+\t\t\t\t  OPT_Wformat_,\n+\t\t\t\t  \"repeated %s in format\", _(s->name));\n \t}\n       else\n \tflag_chars.add_char (*format_chars);\n@@ -2372,28 +2478,30 @@ argument_parser::find_format_char_info (char format_char)\n   if (fci->format_chars == 0)\n     {\n       if (ISGRAPH (format_char))\n-\twarning_at (location_from_offset (format_string_loc,\n-\t\t\t\t\t  format_chars - orig_format_chars),\n-\t\t    OPT_Wformat_,\n-\t\t    \"unknown conversion type character %qc in format\",\n-\t\t    format_char);\n+\tformat_warning_at_char (format_string_loc, format_string_cst,\n+\t\t\t\tformat_chars - orig_format_chars,\n+\t\t\t\tOPT_Wformat_,\n+\t\t\t\t\"unknown conversion type character\"\n+\t\t\t\t\" %qc in format\",\n+\t\t\t\tformat_char);\n       else\n-\twarning_at (location_from_offset (format_string_loc,\n-\t\t\t\t\t  format_chars - orig_format_chars),\n-\t\t    OPT_Wformat_,\n-\t\t    \"unknown conversion type character 0x%x in format\",\n-\t\t    format_char);\n+\tformat_warning_at_char (format_string_loc, format_string_cst,\n+\t\t\t\tformat_chars - orig_format_chars,\n+\t\t\t\tOPT_Wformat_,\n+\t\t\t\t\"unknown conversion type character\"\n+\t\t\t\t\" 0x%x in format\",\n+\t\t\t\tformat_char);\n       return NULL;\n     }\n \n   if (pedantic)\n     {\n       if (ADJ_STD (fci->std) > C_STD_VER)\n-\twarning_at (location_from_offset (format_string_loc,\n-\t\t\t\t\t  format_chars - orig_format_chars),\n-\t\t    OPT_Wformat_,\n-\t\t    \"%s does not support the %<%%%c%> %s format\",\n-\t\t    C_STD_NAME (fci->std), format_char, fki->name);\n+\tformat_warning_at_char (format_string_loc, format_string_cst,\n+\t\t\t\tformat_chars - orig_format_chars,\n+\t\t\t\tOPT_Wformat_,\n+\t\t\t\t\"%s does not support the %<%%%c%> %s format\",\n+\t\t\t\tC_STD_NAME (fci->std), format_char, fki->name);\n     }\n \n   return fci;\n@@ -2496,10 +2604,10 @@ argument_parser::parse_any_scan_set (const format_char_info *fci)\n     ++format_chars;\n   if (*format_chars != ']')\n     /* The end of the format string was reached.  */\n-    warning_at (location_from_offset (format_string_loc,\n-\t\t\t\t      format_chars - orig_format_chars),\n-\t\tOPT_Wformat_,\n-\t\t\"no closing %<]%> for %<%%[%> format\");\n+    format_warning_at_char (format_string_loc, format_string_cst,\n+\t\t\t    format_chars - orig_format_chars,\n+\t\t\t    OPT_Wformat_,\n+\t\t\t    \"no closing %<]%> for %<%%[%> format\");\n }\n \n /* Return true if this argument is to be continued to be parsed,\n@@ -2525,12 +2633,13 @@ argument_parser::handle_conversions (const format_char_info *fci,\n   wanted_type_std = fci->types[len_modifier.val].std;\n   if (wanted_type == 0)\n     {\n-      warning_at (location_from_offset (format_string_loc,\n-\t\t\t\t\tformat_chars - orig_format_chars),\n-\t\t  OPT_Wformat_,\n-\t\t  \"use of %qs length modifier with %qc type character\"\n-\t\t  \" has either no effect or undefined behavior\",\n-\t\t  len_modifier.chars, format_char);\n+      format_warning_at_char (format_string_loc, format_string_cst,\n+\t\t\t      format_chars - orig_format_chars,\n+\t\t\t      OPT_Wformat_,\n+\t\t\t      \"use of %qs length modifier with %qc type\"\n+\t\t\t      \" character has either no effect\"\n+\t\t\t      \" or undefined behavior\",\n+\t\t\t      len_modifier.chars, format_char);\n       /* Heuristic: skip one argument when an invalid length/type\n \t combination is encountered.  */\n       arg_num++;\n@@ -2546,12 +2655,13 @@ argument_parser::handle_conversions (const format_char_info *fci,\n \t   && ADJ_STD (wanted_type_std) > ADJ_STD (fci->std))\n     {\n       if (ADJ_STD (wanted_type_std) > C_STD_VER)\n-\twarning_at (location_from_offset (format_string_loc,\n-\t\t\t\t\t  format_chars - orig_format_chars),\n-\t\t    OPT_Wformat_,\n-\t\t    \"%s does not support the %<%%%s%c%> %s format\",\n-\t\t    C_STD_NAME (wanted_type_std), len_modifier.chars,\n-\t\t    format_char, fki->name);\n+\tformat_warning_at_char (format_string_loc, format_string_cst,\n+\t\t\t\tformat_chars - orig_format_chars,\n+\t\t\t\tOPT_Wformat_,\n+\t\t\t\t\"%s does not support the %<%%%s%c%> %s format\",\n+\t\t\t\tC_STD_NAME (wanted_type_std),\n+\t\t\t\tlen_modifier.chars,\n+\t\t\t\tformat_char, fki->name);\n     }\n \n   return true;\n@@ -2571,7 +2681,8 @@ check_argument_type (const format_char_info *fci,\n \t\t     unsigned HOST_WIDE_INT &arg_num,\n \t\t     tree &params,\n \t\t     const int alloc_flag,\n-\t\t     const char * const format_start)\n+\t\t     const char * const format_start,\n+\t\t     location_t fmt_param_loc)\n {\n   if (info->first_arg_num == 0)\n     return true;\n@@ -2670,7 +2781,13 @@ check_argument_type (const format_char_info *fci,\n     }\n \n   if (first_wanted_type != 0)\n-    check_format_types (format_string_loc, first_wanted_type);\n+    {\n+      ptrdiff_t offset_to_format_start = (start_of_this_format - 1) - orig_format_chars;\n+      ptrdiff_t offset_to_format_end = (format_chars - 1) - orig_format_chars;\n+      substring_loc fmt_loc (fmt_param_loc, TREE_TYPE (format_string_cst),\n+\t\t\t     offset_to_format_start, offset_to_format_end);\n+      check_format_types (fmt_loc, first_wanted_type);\n+    }\n \n   return true;\n }\n@@ -2685,6 +2802,7 @@ check_argument_type (const format_char_info *fci,\n static void\n check_format_info_main (format_check_results *res,\n \t\t\tfunction_format_info *info, const char *format_chars,\n+\t\t\tlocation_t fmt_param_loc, tree format_string_cst,\n \t\t\tint format_length, tree params,\n \t\t\tunsigned HOST_WIDE_INT arg_num,\n \t\t\tobject_allocator <format_wanted_type> &fwt_pool)\n@@ -2708,10 +2826,10 @@ check_format_info_main (format_check_results *res,\n \tcontinue;\n       if (*format_chars == 0)\n \t{\n-          warning_at (location_from_offset (format_string_loc,\n-\t\t\t\t\t    format_chars - orig_format_chars),\n-\t\t      OPT_Wformat_,\n-\t\t      \"spurious trailing %<%%%> in format\");\n+\t  format_warning_at_char (format_string_loc, format_string_cst,\n+\t\t\t\t  format_chars - orig_format_chars,\n+\t\t\t\t  OPT_Wformat_,\n+\t\t\t\t  \"spurious trailing %<%%%> in format\");\n \t  continue;\n \t}\n       if (*format_chars == '%')\n@@ -2721,8 +2839,8 @@ check_format_info_main (format_check_results *res,\n \t}\n \n       flag_chars_t flag_chars;\n-      argument_parser arg_parser (info, format_chars, orig_format_chars,\n-\t\t\t\t  format_string_loc,\n+      argument_parser arg_parser (info, format_chars, format_string_cst,\n+\t\t\t\t  orig_format_chars, format_string_loc,\n \t\t\t\t  flag_chars, has_operand_number,\n \t\t\t\t  first_fillin_param, fwt_pool);\n \n@@ -2759,10 +2877,10 @@ check_format_info_main (format_check_results *res,\n \t  || (!(fki->flags & (int) FMT_FLAG_FANCY_PERCENT_OK)\n \t      && format_char == '%'))\n \t{\n-\t  warning_at (location_from_offset (format_string_loc,\n-\t\t\t\t\t    format_chars - orig_format_chars),\n-\t\t      OPT_Wformat_,\n-\t\t      \"conversion lacks type at end of format\");\n+\t  format_warning_at_char (format_string_loc, format_string_cst,\n+\t\t\t     format_chars - orig_format_chars,\n+\t\t\t     OPT_Wformat_,\n+\t\t\t     \"conversion lacks type at end of format\");\n \t  continue;\n \t}\n       format_chars++;\n@@ -2773,6 +2891,7 @@ check_format_info_main (format_check_results *res,\n \tcontinue;\n \n       flag_chars.validate (fki, fci, flag_specs, format_chars,\n+\t\t\t   format_string_cst,\n \t\t\t   format_string_loc, orig_format_chars, format_char);\n \n       const int alloc_flag = flag_chars.get_alloc_flag (fki);\n@@ -2803,15 +2922,15 @@ check_format_info_main (format_check_results *res,\n \t\t\t\t\t   suppressed,\n \t\t\t\t\t   arg_num, params,\n \t\t\t\t\t   alloc_flag,\n-\t\t\t\t\t   format_start))\n+\t\t\t\t\t   format_start, fmt_param_loc))\n \treturn;\n     }\n \n   if (format_chars - orig_format_chars != format_length)\n-    warning_at (location_from_offset (format_string_loc,\n-\t\t\t\t      format_chars + 1 - orig_format_chars),\n-\t\tOPT_Wformat_contains_nul,\n-\t\t\"embedded %<\\\\0%> in format\");\n+    format_warning_at_char (format_string_loc, format_string_cst,\n+\t\t\t    format_chars + 1 - orig_format_chars,\n+\t\t\t    OPT_Wformat_contains_nul,\n+\t\t\t    \"embedded %<\\\\0%> in format\");\n   if (info->first_arg_num != 0 && params != 0\n       && has_operand_number <= 0)\n     {\n@@ -2822,12 +2941,12 @@ check_format_info_main (format_check_results *res,\n     finish_dollar_format_checking (res, fki->flags & (int) FMT_FLAG_DOLLAR_GAP_POINTER_OK);\n }\n \n-\n /* Check the argument types from a single format conversion (possibly\n-   including width and precision arguments).  LOC is the location of\n-   the format string.  */\n+   including width and precision arguments).  FMT_LOC is the\n+   location of the format conversion.  */\n static void\n-check_format_types (location_t loc, format_wanted_type *types)\n+check_format_types (const substring_loc &fmt_loc,\n+\t\t    format_wanted_type *types)\n {\n   for (; types != 0; types = types->next)\n     {\n@@ -2854,7 +2973,7 @@ check_format_types (location_t loc, format_wanted_type *types)\n       cur_param = types->param;\n       if (!cur_param)\n         {\n-          format_type_warning (loc, types, wanted_type, NULL);\n+          format_type_warning (fmt_loc, NULL, types, wanted_type, NULL);\n           continue;\n         }\n \n@@ -2864,6 +2983,16 @@ check_format_types (location_t loc, format_wanted_type *types)\n       orig_cur_type = cur_type;\n       char_type_flag = 0;\n \n+      source_range param_range;\n+      source_range *param_range_ptr;\n+      if (CAN_HAVE_LOCATION_P (cur_param))\n+\t{\n+\t  param_range = EXPR_LOCATION_RANGE (cur_param);\n+\t  param_range_ptr = &param_range;\n+\t}\n+      else\n+\tparam_range_ptr = NULL;\n+\n       STRIP_NOPS (cur_param);\n \n       /* Check the types of any additional pointer arguments\n@@ -2928,7 +3057,8 @@ check_format_types (location_t loc, format_wanted_type *types)\n \t    }\n \t  else\n \t    {\n-              format_type_warning (loc, types, wanted_type, orig_cur_type);\n+\t      format_type_warning (fmt_loc, param_range_ptr,\n+\t\t\t\t   types, wanted_type, orig_cur_type);\n \t      break;\n \t    }\n \t}\n@@ -2996,20 +3126,24 @@ check_format_types (location_t loc, format_wanted_type *types)\n \t  && TYPE_PRECISION (cur_type) == TYPE_PRECISION (wanted_type))\n \tcontinue;\n       /* Now we have a type mismatch.  */\n-      format_type_warning (loc, types, wanted_type, orig_cur_type);\n+      format_type_warning (fmt_loc, param_range_ptr, types,\n+\t\t\t   wanted_type, orig_cur_type);\n     }\n }\n \n \n-/* Give a warning at LOC about a format argument of different type from that\n-   expected.  WANTED_TYPE is the type the argument should have, possibly\n-   stripped of pointer dereferences.  The description (such as \"field\n+/* Give a warning at FMT_LOC about a format argument of different type\n+   from that expected.  If non-NULL, PARAM_RANGE is the source range of the\n+   relevant argument.  WANTED_TYPE is the type the argument should have,\n+   possibly stripped of pointer dereferences.  The description (such as \"field\n    precision\"), the placement in the format string, a possibly more\n    friendly name of WANTED_TYPE, and the number of pointer dereferences\n    are taken from TYPE.  ARG_TYPE is the type of the actual argument,\n    or NULL if it is missing.  */\n static void\n-format_type_warning (location_t loc, format_wanted_type *type,\n+format_type_warning (const substring_loc &fmt_loc,\n+\t\t     source_range *param_range,\n+\t\t     format_wanted_type *type,\n \t\t     tree wanted_type, tree arg_type)\n {\n   int kind = type->kind;\n@@ -3018,7 +3152,6 @@ format_type_warning (location_t loc, format_wanted_type *type,\n   int format_length = type->format_length;\n   int pointer_count = type->pointer_count;\n   int arg_num = type->arg_num;\n-  unsigned int offset_loc = type->offset_loc;\n \n   char *p;\n   /* If ARG_TYPE is a typedef with a misleading name (for example,\n@@ -3052,41 +3185,47 @@ format_type_warning (location_t loc, format_wanted_type *type,\n       p[pointer_count + 1] = 0;\n     }\n \n-  loc = location_from_offset (loc, offset_loc);\n-\t\t      \n   if (wanted_type_name)\n     {\n       if (arg_type)\n-        warning_at (loc, OPT_Wformat_,\n-\t\t    \"%s %<%s%.*s%> expects argument of type %<%s%s%>, \"\n-\t\t    \"but argument %d has type %qT\",\n-\t\t    gettext (kind_descriptions[kind]),\n-\t\t    (kind == CF_KIND_FORMAT ? \"%\" : \"\"),\n-\t\t    format_length, format_start, \n-\t\t    wanted_type_name, p, arg_num, arg_type);\n+\tformat_warning_at_substring\n+\t  (fmt_loc, param_range,\n+\t   OPT_Wformat_,\n+\t   \"%s %<%s%.*s%> expects argument of type %<%s%s%>, \"\n+\t   \"but argument %d has type %qT\",\n+\t   gettext (kind_descriptions[kind]),\n+\t   (kind == CF_KIND_FORMAT ? \"%\" : \"\"),\n+\t   format_length, format_start,\n+\t   wanted_type_name, p, arg_num, arg_type);\n       else\n-        warning_at (loc, OPT_Wformat_,\n-\t\t    \"%s %<%s%.*s%> expects a matching %<%s%s%> argument\",\n-\t\t    gettext (kind_descriptions[kind]),\n-\t\t    (kind == CF_KIND_FORMAT ? \"%\" : \"\"),\n-\t\t    format_length, format_start, wanted_type_name, p);\n+\tformat_warning_at_substring\n+\t  (fmt_loc, param_range,\n+\t   OPT_Wformat_,\n+\t   \"%s %<%s%.*s%> expects a matching %<%s%s%> argument\",\n+\t   gettext (kind_descriptions[kind]),\n+\t   (kind == CF_KIND_FORMAT ? \"%\" : \"\"),\n+\t   format_length, format_start, wanted_type_name, p);\n     }\n   else\n     {\n       if (arg_type)\n-        warning_at (loc, OPT_Wformat_,\n-\t\t    \"%s %<%s%.*s%> expects argument of type %<%T%s%>, \"\n-\t\t    \"but argument %d has type %qT\",\n-\t\t    gettext (kind_descriptions[kind]),\n-\t\t    (kind == CF_KIND_FORMAT ? \"%\" : \"\"),\n-\t\t    format_length, format_start, \n-\t\t    wanted_type, p, arg_num, arg_type);\n+\tformat_warning_at_substring\n+\t  (fmt_loc, param_range,\n+\t   OPT_Wformat_,\n+\t   \"%s %<%s%.*s%> expects argument of type %<%T%s%>, \"\n+\t   \"but argument %d has type %qT\",\n+\t   gettext (kind_descriptions[kind]),\n+\t   (kind == CF_KIND_FORMAT ? \"%\" : \"\"),\n+\t   format_length, format_start,\n+\t   wanted_type, p, arg_num, arg_type);\n       else\n-        warning_at (loc, OPT_Wformat_,\n-\t\t    \"%s %<%s%.*s%> expects a matching %<%T%s%> argument\",\n-\t\t    gettext (kind_descriptions[kind]),\n-\t\t    (kind == CF_KIND_FORMAT ? \"%\" : \"\"),\n-\t\t    format_length, format_start, wanted_type, p);\n+\tformat_warning_at_substring\n+\t  (fmt_loc, param_range,\n+\t   OPT_Wformat_,\n+\t   \"%s %<%s%.*s%> expects a matching %<%T%s%> argument\",\n+\t   gettext (kind_descriptions[kind]),\n+\t   (kind == CF_KIND_FORMAT ? \"%\" : \"\"),\n+\t   format_length, format_start, wanted_type, p);\n     }\n }\n "}, {"sha": "6e406f6de8cd89572f4732c344f06d867688619f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e52ed3fee2d607473dc50d48e5f05c30b42f1966/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e52ed3fee2d607473dc50d48e5f05c30b42f1966/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e52ed3fee2d607473dc50d48e5f05c30b42f1966", "patch": "@@ -1,3 +1,11 @@\n+2016-08-08  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tPR c/52952\n+\t* gcc.dg/cpp/pr66415-1.c: Likewise.\n+\t* gcc.dg/format/asm_fprintf-1.c: Update column numbers.\n+\t* gcc.dg/format/c90-printf-1.c: Likewise.\n+\t* gcc.dg/format/diagnostic-ranges.c: New test case.\n+\n 2016-08-08  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR fortran/72716"}, {"sha": "1f67cb4f84ccfc8c29bd124aea3ae10893d66316", "filename": "gcc/testsuite/gcc.dg/cpp/pr66415-1.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e52ed3fee2d607473dc50d48e5f05c30b42f1966/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fpr66415-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e52ed3fee2d607473dc50d48e5f05c30b42f1966/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fpr66415-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fpr66415-1.c?ref=e52ed3fee2d607473dc50d48e5f05c30b42f1966", "patch": "@@ -1,9 +1,15 @@\n /* PR c/66415 */\n /* { dg-do compile } */\n-/* { dg-options \"-Wformat\" } */\n+/* { dg-options \"-Wformat -fdiagnostics-show-caret\" } */\n \n void\n fn1 (void)\n {\n   __builtin_printf                                (\"xxxxxxxxxxxxxxxxx%dxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\"); /* { dg-warning \"71:format\" } */\n+\n+/* { dg-begin-multiline-output \"\" }\n+   __builtin_printf                                (\"xxxxxxxxxxxxxxxxx%dxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\");\n+                                                                      ~^\n+   { dg-end-multiline-output \"\" } */\n+\n }"}, {"sha": "50ca57206b1c24d7f58852effbb057d32bf2df62", "filename": "gcc/testsuite/gcc.dg/format/asm_fprintf-1.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e52ed3fee2d607473dc50d48e5f05c30b42f1966/gcc%2Ftestsuite%2Fgcc.dg%2Fformat%2Fasm_fprintf-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e52ed3fee2d607473dc50d48e5f05c30b42f1966/gcc%2Ftestsuite%2Fgcc.dg%2Fformat%2Fasm_fprintf-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fformat%2Fasm_fprintf-1.c?ref=e52ed3fee2d607473dc50d48e5f05c30b42f1966", "patch": "@@ -66,9 +66,9 @@ foo (int i, int i1, int i2, unsigned int u, double d, char *s, void *p,\n   asm_fprintf (\"%d\", i, i); /* { dg-warning \"16:arguments\" \"wrong number of args\" } */\n   /* Miscellaneous bogus constructions.  */\n   asm_fprintf (\"\"); /* { dg-warning \"16:zero-length\" \"warning for empty format\" } */\n-  asm_fprintf (\"\\0\"); /* { dg-warning \"17:embedded\" \"warning for embedded NUL\" } */\n-  asm_fprintf (\"%d\\0\", i); /* { dg-warning \"19:embedded\" \"warning for embedded NUL\" } */\n-  asm_fprintf (\"%d\\0%d\", i, i); /* { dg-warning \"19:embedded|too many\" \"warning for embedded NUL\" } */\n+  asm_fprintf (\"\\0\"); /* { dg-warning \"18:embedded\" \"warning for embedded NUL\" } */\n+  asm_fprintf (\"%d\\0\", i); /* { dg-warning \"20:embedded\" \"warning for embedded NUL\" } */\n+  asm_fprintf (\"%d\\0%d\", i, i); /* { dg-warning \"20:embedded|too many\" \"warning for embedded NUL\" } */\n   asm_fprintf (NULL); /* { dg-warning \"null\" \"null format string warning\" } */\n   asm_fprintf (\"%\"); /* { dg-warning \"17:trailing\" \"trailing % warning\" } */\n   asm_fprintf (\"%++d\", i); /* { dg-warning \"19:repeated\" \"repeated flag warning\" } */"}, {"sha": "338b971da0967a2c93ffc8f4ded78f89857f7b95", "filename": "gcc/testsuite/gcc.dg/format/c90-printf-1.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e52ed3fee2d607473dc50d48e5f05c30b42f1966/gcc%2Ftestsuite%2Fgcc.dg%2Fformat%2Fc90-printf-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e52ed3fee2d607473dc50d48e5f05c30b42f1966/gcc%2Ftestsuite%2Fgcc.dg%2Fformat%2Fc90-printf-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fformat%2Fc90-printf-1.c?ref=e52ed3fee2d607473dc50d48e5f05c30b42f1966", "patch": "@@ -58,11 +58,11 @@ foo (int i, int i1, int i2, unsigned int u, double d, char *s, void *p,\n   printf (\"%-%\"); /* { dg-warning \"13:type\" \"missing type\" } */\n   /* { dg-warning \"14:trailing\" \"bogus %%\" { target *-*-* } 58 } */\n   printf (\"%-%\\n\"); /* { dg-warning \"13:format\" \"bogus %%\" } */\n-  /* { dg-warning \"15:format\" \"bogus %%\" { target *-*-* } 60 } */\n+  /* { dg-warning \"16:format\" \"bogus %%\" { target *-*-* } 60 } */\n   printf (\"%5%\\n\"); /* { dg-warning \"13:format\" \"bogus %%\" } */\n-  /* { dg-warning \"15:format\" \"bogus %%\" { target *-*-* } 62 } */\n+  /* { dg-warning \"16:format\" \"bogus %%\" { target *-*-* } 62 } */\n   printf (\"%h%\\n\"); /* { dg-warning \"13:format\" \"bogus %%\" } */\n-  /* { dg-warning \"15:format\" \"bogus %%\" { target *-*-* } 64 } */\n+  /* { dg-warning \"16:format\" \"bogus %%\" { target *-*-* } 64 } */\n   /* Valid and invalid %h, %l, %L constructions.  */\n   printf (\"%hd\", i);\n   printf (\"%hi\", i);\n@@ -184,8 +184,8 @@ foo (int i, int i1, int i2, unsigned int u, double d, char *s, void *p,\n   printf (\"%-08G\", d); /* { dg-warning \"11:flags|ignored\" \"0 flag ignored with - flag\" } */\n   /* Various tests of bad argument types.  */\n   printf (\"%d\", l); /* { dg-warning \"13:format\" \"bad argument types\" } */\n-  printf (\"%*.*d\", l, i2, i); /* { dg-warning \"13:field\" \"bad * argument types\" } */\n-  printf (\"%*.*d\", i1, l, i); /* { dg-warning \"15:field\" \"bad * argument types\" } */\n+  printf (\"%*.*d\", l, i2, i); /* { dg-warning \"16:field\" \"bad * argument types\" } */\n+  printf (\"%*.*d\", i1, l, i); /* { dg-warning \"16:field\" \"bad * argument types\" } */\n   printf (\"%ld\", i); /* { dg-warning \"14:format\" \"bad argument types\" } */\n   printf (\"%s\", n); /* { dg-warning \"13:format\" \"bad argument types\" } */\n   printf (\"%p\", i); /* { dg-warning \"13:format\" \"bad argument types\" } */\n@@ -231,8 +231,8 @@ foo (int i, int i1, int i2, unsigned int u, double d, char *s, void *p,\n   printf (\"%d\", i, i); /* { dg-warning \"11:arguments\" \"wrong number of args\" } */\n   /* Miscellaneous bogus constructions.  */\n   printf (\"\"); /* { dg-warning \"11:zero-length\" \"warning for empty format\" } */\n-  printf (\"\\0\"); /* { dg-warning \"12:embedded\" \"warning for embedded NUL\" } */\n-  printf (\"%d\\0\", i); /* { dg-warning \"14:embedded\" \"warning for embedded NUL\" } */\n+  printf (\"\\0\"); /* { dg-warning \"13:embedded\" \"warning for embedded NUL\" } */\n+  printf (\"%d\\0\", i); /* { dg-warning \"15:embedded\" \"warning for embedded NUL\" } */\n   printf (\"%d\\0%d\", i, i); /* { dg-warning \"embedded|too many\" \"warning for embedded NUL\" } */\n   printf (NULL); /* { dg-warning \"3:null\" \"null format string warning\" } */\n   printf (\"%\"); /* { dg-warning \"12:trailing\" \"trailing % warning\" } */"}, {"sha": "9e86b5210f1a040a45a7aa2217ad6528e1d556ec", "filename": "gcc/testsuite/gcc.dg/format/diagnostic-ranges.c", "status": "added", "additions": 222, "deletions": 0, "changes": 222, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e52ed3fee2d607473dc50d48e5f05c30b42f1966/gcc%2Ftestsuite%2Fgcc.dg%2Fformat%2Fdiagnostic-ranges.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e52ed3fee2d607473dc50d48e5f05c30b42f1966/gcc%2Ftestsuite%2Fgcc.dg%2Fformat%2Fdiagnostic-ranges.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fformat%2Fdiagnostic-ranges.c?ref=e52ed3fee2d607473dc50d48e5f05c30b42f1966", "patch": "@@ -0,0 +1,222 @@\n+/* { dg-options \"-Wformat -fdiagnostics-show-caret\" } */\n+\n+/* See PR 52952. */\n+\n+#include \"format.h\"\n+\n+void test_mismatching_types (const char *msg)\n+{\n+  printf(\"hello %i\", msg);  /* { dg-warning \"format '%i' expects argument of type 'int', but argument 2 has type 'const char \\\\*' \" } */\n+\n+/* TODO: ideally would also underline \"msg\".  */\n+/* { dg-begin-multiline-output \"\" }\n+   printf(\"hello %i\", msg);\n+                 ~^\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+void test_multiple_arguments (void)\n+{\n+  printf (\"arg0: %i  arg1: %s arg 2: %i\", /* { dg-warning \"29: format '%s'\" } */\n+          100, 101, 102);\n+/* TODO: ideally would also underline \"101\".  */\n+/* { dg-begin-multiline-output \"\" }\n+   printf (\"arg0: %i  arg1: %s arg 2: %i\",\n+                            ~^\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+void test_multiple_arguments_2 (int i, int j)\n+{\n+  printf (\"arg0: %i  arg1: %s arg 2: %i\", /* { dg-warning \"29: format '%s'\" } */\n+          100, i + j, 102);\n+/* { dg-begin-multiline-output \"\" }\n+   printf (\"arg0: %i  arg1: %s arg 2: %i\",\n+                            ~^\n+           100, i + j, 102);\n+                ~~~~~         \n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+void multiline_format_string (void) {\n+  printf (\"before the fmt specifier\" /* { dg-warning \"11: format '%d' expects a matching 'int' argument\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   printf (\"before the fmt specifier\"\n+           ^~~~~~~~~~~~~~~~~~~~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+          \"%\"\n+          \"d\" /* { dg-message \"12: format string is defined here\" } */\n+          \"after the fmt specifier\");\n+\n+/* { dg-begin-multiline-output \"\" }\n+           \"%\"\n+            ~~\n+           \"d\"\n+           ~^\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+void test_hex (const char *msg)\n+{\n+  /* \"%\" is \\x25\n+     \"i\" is \\x69 */\n+  printf(\"hello \\x25\\x69\", msg);  /* { dg-warning \"format '%i' expects argument of type 'int', but argument 2 has type 'const char \\\\*' \" } */\n+\n+/* TODO: ideally would also underline \"msg\".  */\n+/* { dg-begin-multiline-output \"\" }\n+   printf(\"hello \\x25\\x69\", msg);\n+                 ~~~~~~~^\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+void test_oct (const char *msg)\n+{\n+  /* \"%\" is octal 045\n+     \"i\" is octal 151.  */\n+  printf(\"hello \\045\\151\", msg);  /* { dg-warning \"format '%i' expects argument of type 'int', but argument 2 has type 'const char \\\\*' \" } */\n+\n+/* TODO: ideally would also underline \"msg\".  */\n+/* { dg-begin-multiline-output \"\" }\n+   printf(\"hello \\045\\151\", msg);\n+                 ~~~~~~~^\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+void test_multiple (const char *msg)\n+{\n+  /* \"%\" is \\x25 in hex\n+     \"i\" is \\151 in octal.  */\n+  printf(\"prefix\"  \"\\x25\"  \"\\151\"  \"suffix\",  /* { dg-warning \"format '%i'\" } */\n+         msg);\n+/* { dg-begin-multiline-output \"\" }\n+   printf(\"prefix\"  \"\\x25\"  \"\\151\"  \"suffix\",\n+          ^~~~~~~~\n+  { dg-end-multiline-output \"\" } */\n+\n+/* TODO: ideally would also underline \"msg\".  */\n+/* { dg-begin-multiline-output \"\" }\n+   printf(\"prefix\"  \"\\x25\"  \"\\151\"  \"suffix\",\n+                     ~~~~~~~~~~~^\n+  { dg-end-multiline-output \"\" } */\n+}\n+\n+void test_u8 (const char *msg)\n+{\n+  printf(u8\"hello %i\", msg);/* { dg-warning \"format '%i' expects argument of type 'int', but argument 2 has type 'const char \\\\*' \" } */\n+/* TODO: ideally would also underline \"msg\".  */\n+/* { dg-begin-multiline-output \"\" }\n+   printf(u8\"hello %i\", msg);\n+                   ~^\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+void test_param (long long_i, long long_j)\n+{\n+  printf (\"foo %s bar\", long_i + long_j); /* { dg-warning \"17: format '%s' expects argument of type 'char \\\\*', but argument 2 has type 'long int'\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   printf (\"foo %s bar\", long_i + long_j);\n+                ~^       ~~~~~~~~~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+void test_field_width_specifier (long l, int i1, int i2)\n+{\n+  printf (\" %*.*d \", l, i1, i2); /* { dg-warning \"17: field width specifier '\\\\*' expects argument of type 'int', but argument 2 has type 'long int'\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   printf (\" %*.*d \", l, i1, i2);\n+             ~~~~^\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+void test_spurious_percent (void)\n+{\n+  printf(\"hello world %\"); /* { dg-warning \"23: spurious trailing\" } */\n+\n+/* { dg-begin-multiline-output \"\" }\n+   printf(\"hello world %\");\n+                       ^\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+void test_empty_precision (char *s, size_t m, double d)\n+{\n+  strfmon (s, m, \"%#.5n\", d); /* { dg-warning \"20: empty left precision in gnu_strfmon format\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   strfmon (s, m, \"%#.5n\", d);\n+                    ^\n+   { dg-end-multiline-output \"\" } */\n+\n+  strfmon (s, m, \"%#5.n\", d); /* { dg-warning \"22: empty precision in gnu_strfmon format\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   strfmon (s, m, \"%#5.n\", d);\n+                      ^\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+void test_repeated (int i)\n+{\n+  printf (\"%++d\", i); /* { dg-warning \"14: repeated '\\\\+' flag in format\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   printf (\"%++d\", i);\n+              ^\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+void test_conversion_lacks_type (void)\n+{\n+  printf (\" %h\"); /* { dg-warning \"14:conversion lacks type at end of format\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   printf (\" %h\");\n+              ^\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+void test_embedded_nul (void)\n+{\n+  printf (\" \\0 \"); /* { dg-warning \"14:embedded\" \"warning for embedded NUL\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   printf (\" \\0 \");\n+             ~^\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+void test_macro (const char *msg)\n+{\n+#define INT_FMT \"%i\" /* { dg-message \"19: format string is defined here\" } */\n+  printf(\"hello \" INT_FMT \" world\", msg);  /* { dg-warning \"10: format '%i' expects argument of type 'int', but argument 2 has type 'const char \\\\*' \" } */\n+/* { dg-begin-multiline-output \"\" }\n+   printf(\"hello \" INT_FMT \" world\", msg);\n+          ^~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+/* { dg-begin-multiline-output \"\" }\n+ #define INT_FMT \"%i\"\n+                  ~^\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+void test_non_contiguous_strings (void)\n+{\n+  __builtin_printf(\" %\" \"d \", 0.5); /* { dg-warning \"20: format .%d. expects argument of type .int., but argument 2 has type .double.\" } */\n+                                    /* { dg-message \"26: format string is defined here\" \"\" { target *-*-* } 200 } */\n+  /* { dg-begin-multiline-output \"\" }\n+   __builtin_printf(\" %\" \"d \", 0.5);\n+                    ^~~~\n+   { dg-end-multiline-output \"\" } */\n+  /* { dg-begin-multiline-output \"\" }\n+   __builtin_printf(\" %\" \"d \", 0.5);\n+                      ~~~~^\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+void test_const_arrays (void)\n+{\n+  /* TODO: ideally we'd highlight both the format string *and* the use of\n+     it here.  For now, just verify that we gracefully handle this case.  */\n+  const char a[] = \" %d \";\n+  __builtin_printf(a, 0.5); /* { dg-warning \"20: format .%d. expects argument of type .int., but argument 2 has type .double.\" } */\n+  /* { dg-begin-multiline-output \"\" }\n+   __builtin_printf(a, 0.5);\n+                    ^\n+   { dg-end-multiline-output \"\" } */\n+}"}]}