{"sha": "442fcea74d0c7797fc083fa7e5543268c0ff54a6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDQyZmNlYTc0ZDBjNzc5N2ZjMDgzZmE3ZTU1NDMyNjhjMGZmNTRhNg==", "commit": {"author": {"name": "Paul Koning", "email": "ni1d@arrl.net", "date": "2018-11-08T18:56:58Z"}, "committer": {"name": "Paul Koning", "email": "pkoning@gcc.gnu.org", "date": "2018-11-08T18:56:58Z"}, "message": "re PR c/87795 (Excessive alignment permitted for functions and labels)\n\n\t* config/pdp11/constraints.md: Add \"Z\" series constraints for use\n\twith pre-dec and post-inc addressing.\n\t* config/pdp11/pdp11-protos.m (expand_block_move): Delete.\n\t(pdp11_expand_operands): Add int argument (word count).\n\t(pdp11_sp_frame_offset): Delete.\n\t(pdp11_cmp_length): New function.\n\t(pushpop_regeq): New function.\n\t* config/pdp11/pdp11.c (TARGET_STACK_PROTECT_RUNTIME_ENABLED_P):\n\tAdd hook.\n\t(pdp11_expand_prologue, pdp11_expand_epilogue): Rewrite for new\n\tframe layout.\n\t(pdp11_initial_elimination_offset): Ditto.\n\t(pdp11_expand_operands): Add word count argument.  Bugfixes.\n\t(output_move_multiple): Change how pointer adjustment is done.\n\t(pdp11_gen_int_label): Correct format.\n\t(output_ascii): Ditto.\n\t(pdp11_asm_output_var): Add code for DEC assembler case.\n\t(pdp11_asm_print_operand): Bugfix for CONST_DOUBLE holding integer\n\tvalue.\n\t(legitimate_const_double_p): Ditto.\n\t(pdp11_register_move_cost): Adjust for new register classes.\n\t(pdp11_regno_reg_class): Ditto.\n\t(expand_block_move): Delete.\n\t(pushpop_regeq): New function.\n\t(pdp11_legitimate_address_p): Bugfix in check for constant\n\toffset.\n\t(pdp11_sp_frame_offset): Delete.\n\t(pdp11_reg_save_size): New helper function for new frame layout.\n\t(output_addr_const_pdp11): Remove CONST_DOUBLE case.\n\t(pdp11_expand_shift): Bugfix in check for constant shift count.\n\t(pdp11_shift_length): Ditto.\n\t(pdp11_assemble_shift): Copy input to pdp11_expand_operands.\n\t(pdp11_cmp_length): New function.\n\t* config/pdp11/pdp11.h (TARGET_CPU_CPP_BUILTINS): Add macros for\n\tsome compile options.\n\t(FIXED_REGISTERS): Remove HARD_FRAME_POINTER_REGNUM.\n\t(CALL_USED_REGISTERS): Ditto.\n\t(ELIMINABLE_REGS): Ditto.\n\t(REGISTER_NAMES): Ditto.\n\t(reg_class): Add classes NOTR0_REG through NOTSP_REG for use by Z\n\tconstraints.\n\t(REG_CLASS_NAMES): Ditto.\n\t(REG_CLASS_CONTENTS): Ditto.  Also remove\n\tHARD_FRAME_POINTER_REGNUM.\n\t(CPU_REG_CLASS): New macro.\n\t(CLASS_MAX_NREGS): Adjust for new register classes.\n\t(FUNCTION_PROFILER): Make no-op.\n\t(may_call_alloca): Remove unused declaration.\n\t(ASM_OUTPUT_ALIGN): Add workaround for PR87795.\n\t(ASM_OUTPUT_SKIP): Fix format.\n\t* config/pdp11/pdp11.md (unspecv): Add UNSPECV_MOVMEM.\n\t(HARD_FRAME_POINTER_REGNUM): Remove.\n\t(return): Delete.\n\t(*rts): Rename.  Remove epilogue related checks.\n\t(cmpsi, cmpdi): New insn.\n\t(cbranch<mode>4): Change to apply to SI and DI modes as well.\n\t(mov<mode>): Change constraints to enforce that push/pop\n\tdestination cannot use the same register as source.\n\t(*mov<mode><cc_cc>): Ditto.\n\t(movmemhi, movmemhi1, movmemhi_nocc): Change to expand block move\n\tat assembly output rather than as RTL expander.\n\t(zero_extendqihi2): Bugfix in check for same registers.\n\t(adddi3_nocc): Bugfix in check for constant operand.\n\t(addsi3_nocc): Ditto.\n\t(subdi3_nocc): Ditto.\n\t(subsi3_nocc): Ditto.\n\t(negdi2_nocc): Copy input to pdp11_expand_operands.\n\t(negsi2_nocc): Ditto.\n\t(bswap2_nocc): Ditto.\n\t* config/pdp11/pdp11.opt (mlra): Fix documentation.\n\t* config/pdp11/t-pdp11: Use -Os.\n\nFrom-SVN: r265932", "tree": {"sha": "8d6dabf3fc85a028b233437a17c5fb3e6c20e9a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8d6dabf3fc85a028b233437a17c5fb3e6c20e9a3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/442fcea74d0c7797fc083fa7e5543268c0ff54a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/442fcea74d0c7797fc083fa7e5543268c0ff54a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/442fcea74d0c7797fc083fa7e5543268c0ff54a6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/442fcea74d0c7797fc083fa7e5543268c0ff54a6/comments", "author": null, "committer": null, "parents": [{"sha": "d4f680c672261642b47ecd72b6201825703bfa40", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4f680c672261642b47ecd72b6201825703bfa40", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d4f680c672261642b47ecd72b6201825703bfa40"}], "stats": {"total": 973, "additions": 605, "deletions": 368}, "files": [{"sha": "e131f6243d859aa8d3647e845434d116eab523bd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/442fcea74d0c7797fc083fa7e5543268c0ff54a6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/442fcea74d0c7797fc083fa7e5543268c0ff54a6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=442fcea74d0c7797fc083fa7e5543268c0ff54a6", "patch": "@@ -1,3 +1,77 @@\n+2018-11-08  Paul Koning  <ni1d@arrl.net>\n+\n+\t* config/pdp11/constraints.md: Add \"Z\" series constraints for use\n+\twith pre-dec and post-inc addressing.\n+\t* config/pdp11/pdp11-protos.m (expand_block_move): Delete.\n+\t(pdp11_expand_operands): Add int argument (word count).\n+\t(pdp11_sp_frame_offset): Delete.\n+\t(pdp11_cmp_length): New function.\n+\t(pushpop_regeq): New function.\n+\t* config/pdp11/pdp11.c (TARGET_STACK_PROTECT_RUNTIME_ENABLED_P):\n+\tAdd hook.\n+\t(pdp11_expand_prologue, pdp11_expand_epilogue): Rewrite for new\n+\tframe layout.\n+\t(pdp11_initial_elimination_offset): Ditto.\n+\t(pdp11_expand_operands): Add word count argument.  Bugfixes.\n+\t(output_move_multiple): Change how pointer adjustment is done.\n+\t(pdp11_gen_int_label): Correct format.\n+\t(output_ascii): Ditto.\n+\t(pdp11_asm_output_var): Add code for DEC assembler case.\n+\t(pdp11_asm_print_operand): Bugfix for CONST_DOUBLE holding integer\n+\tvalue.\n+\t(legitimate_const_double_p): Ditto.\n+\t(pdp11_register_move_cost): Adjust for new register classes.\n+\t(pdp11_regno_reg_class): Ditto.\n+\t(expand_block_move): Delete.\n+\t(pushpop_regeq): New function.\n+\t(pdp11_legitimate_address_p): Bugfix in check for constant\n+\toffset.\n+\t(pdp11_sp_frame_offset): Delete.\n+\t(pdp11_reg_save_size): New helper function for new frame layout.\n+\t(output_addr_const_pdp11): Remove CONST_DOUBLE case.\n+\t(pdp11_expand_shift): Bugfix in check for constant shift count.\n+\t(pdp11_shift_length): Ditto.\n+\t(pdp11_assemble_shift): Copy input to pdp11_expand_operands.\n+\t(pdp11_cmp_length): New function.\n+\t* config/pdp11/pdp11.h (TARGET_CPU_CPP_BUILTINS): Add macros for\n+\tsome compile options.\n+\t(FIXED_REGISTERS): Remove HARD_FRAME_POINTER_REGNUM.\n+\t(CALL_USED_REGISTERS): Ditto.\n+\t(ELIMINABLE_REGS): Ditto.\n+\t(REGISTER_NAMES): Ditto.\n+\t(reg_class): Add classes NOTR0_REG through NOTSP_REG for use by Z\n+\tconstraints.\n+\t(REG_CLASS_NAMES): Ditto.\n+\t(REG_CLASS_CONTENTS): Ditto.  Also remove\n+\tHARD_FRAME_POINTER_REGNUM.\n+\t(CPU_REG_CLASS): New macro.\n+\t(CLASS_MAX_NREGS): Adjust for new register classes.\n+\t(FUNCTION_PROFILER): Make no-op.\n+\t(may_call_alloca): Remove unused declaration.\n+\t(ASM_OUTPUT_ALIGN): Add workaround for PR87795.\n+\t(ASM_OUTPUT_SKIP): Fix format.\n+\t* config/pdp11/pdp11.md (unspecv): Add UNSPECV_MOVMEM.\n+\t(HARD_FRAME_POINTER_REGNUM): Remove.\n+\t(return): Delete.\n+\t(*rts): Rename.  Remove epilogue related checks.\n+\t(cmpsi, cmpdi): New insn.\n+\t(cbranch<mode>4): Change to apply to SI and DI modes as well.\n+\t(mov<mode>): Change constraints to enforce that push/pop\n+\tdestination cannot use the same register as source.\n+\t(*mov<mode><cc_cc>): Ditto.\n+\t(movmemhi, movmemhi1, movmemhi_nocc): Change to expand block move\n+\tat assembly output rather than as RTL expander.\n+\t(zero_extendqihi2): Bugfix in check for same registers.\n+\t(adddi3_nocc): Bugfix in check for constant operand.\n+\t(addsi3_nocc): Ditto.\n+\t(subdi3_nocc): Ditto.\n+\t(subsi3_nocc): Ditto.\n+\t(negdi2_nocc): Copy input to pdp11_expand_operands.\n+\t(negsi2_nocc): Ditto.\n+\t(bswap2_nocc): Ditto.\n+\t* config/pdp11/pdp11.opt (mlra): Fix documentation.\n+\t* config/pdp11/t-pdp11: Use -Os.\n+\n 2018-11-08  Richard Earnshaw  <rearnsha@arm.com>\n \n \t* config/arm/parsecpu.awk (/alias/): New parsing rule."}, {"sha": "d821af3d7fed2d8f1fff16ed8bb699a797af3bc4", "filename": "gcc/config/pdp11/constraints.md", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/442fcea74d0c7797fc083fa7e5543268c0ff54a6/gcc%2Fconfig%2Fpdp11%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/442fcea74d0c7797fc083fa7e5543268c0ff54a6/gcc%2Fconfig%2Fpdp11%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fconstraints.md?ref=442fcea74d0c7797fc083fa7e5543268c0ff54a6", "patch": "@@ -88,3 +88,32 @@\n        (match_test \"memory_address_p (GET_MODE (op), XEXP (op, 0))\n                     && no_side_effect_operand (op, GET_MODE (op))\")))\n \n+;; What follows is a set of constraints used to prevent the generation\n+;; of insns that have a register as source, and an auto-increment or\n+;; auto-decrement memory reference as the destination where the register\n+;; is the same as the source.  On the PDP11, such instructions are not\n+;; implemented consistently across the models and often do something\n+;; different from what the RTL intends.\n+(define_register_constraint \"Z0\" \"NOTR0_REG\" \"Register other than 0\")\n+(define_register_constraint \"Z1\" \"NOTR1_REG\" \"Register other than 1\")\n+(define_register_constraint \"Z2\" \"NOTR2_REG\" \"Register other than 2\")\n+(define_register_constraint \"Z3\" \"NOTR3_REG\" \"Register other than 3\")\n+(define_register_constraint \"Z4\" \"NOTR4_REG\" \"Register other than 4\")\n+(define_register_constraint \"Z5\" \"NOTR5_REG\" \"Register other than 5\")\n+(define_register_constraint \"Z6\" \"NOTSP_REG\"\n+  \"Register other than stack pointer (register 6)\")\n+(define_memory_constraint \"Za\" \"R0 push/pop\"\n+  (match_test \"pushpop_regeq (op, 0)\"))\n+(define_memory_constraint \"Zb\" \"R1 push/pop\"\n+  (match_test \"pushpop_regeq (op, 1)\"))\n+(define_memory_constraint \"Zc\" \"R2 push/pop\"\n+  (match_test \"pushpop_regeq (op, 2)\"))\n+(define_memory_constraint \"Zd\" \"R3 push/pop\"\n+  (match_test \"pushpop_regeq (op, 3)\"))\n+(define_memory_constraint \"Ze\" \"R4 push/pop\"\n+  (match_test \"pushpop_regeq (op, 4)\"))\n+(define_memory_constraint \"Zf\" \"R5 push/pop\"\n+  (match_test \"pushpop_regeq (op, 5)\"))\n+(define_memory_constraint \"Zg\" \"SP push/pop\"\n+  (match_test \"pushpop_regeq (op, 6)\"))\n+  "}, {"sha": "135d437a2eee43304995fb101747eb2d8ee7340c", "filename": "gcc/config/pdp11/pdp11-protos.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/442fcea74d0c7797fc083fa7e5543268c0ff54a6/gcc%2Fconfig%2Fpdp11%2Fpdp11-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/442fcea74d0c7797fc083fa7e5543268c0ff54a6/gcc%2Fconfig%2Fpdp11%2Fpdp11-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11-protos.h?ref=442fcea74d0c7797fc083fa7e5543268c0ff54a6", "patch": "@@ -26,14 +26,12 @@ extern int legitimate_const_double_p (rtx);\n extern void notice_update_cc_on_set (rtx, rtx);\n extern void output_addr_const_pdp11 (FILE *, rtx);\n extern const char *output_move_multiple (rtx *);\n-extern void expand_block_move (rtx *);\n extern const char *output_jump (rtx *, int, int);\n extern void print_operand_address (FILE *, rtx);\n typedef enum { no_action, dec_before, inc_after } pdp11_action;\n typedef enum { little, either, big } pdp11_partorder;\n-extern bool pdp11_expand_operands (rtx *, rtx [][2], int,\n+extern bool pdp11_expand_operands (rtx *, rtx [][2], int, int,\n \t\t\t\t   pdp11_action *, pdp11_partorder);\n-extern int pdp11_sp_frame_offset (void);\n extern int pdp11_initial_elimination_offset (int, int);\n extern enum reg_class pdp11_regno_reg_class (int);\n extern bool pdp11_fixed_cc_regs (unsigned int *, unsigned int *);\n@@ -42,6 +40,8 @@ extern bool pdp11_expand_shift (rtx *, rtx (*) (rtx, rtx, rtx),\n \t\t\t\trtx (*) (rtx, rtx, rtx));\n extern const char * pdp11_assemble_shift (rtx *, machine_mode, int);\n extern int pdp11_shift_length (rtx *, machine_mode, int, bool);\n+extern int pdp11_cmp_length (rtx *, int);\n+extern bool pushpop_regeq (rtx, int);\n extern bool pdp11_small_shift (int);\n \n #endif /* RTX_CODE */"}, {"sha": "0019efe39f1a67608c20f88757f68d1a73ce56ee", "filename": "gcc/config/pdp11/pdp11.c", "status": "modified", "additions": 213, "deletions": 271, "changes": 484, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/442fcea74d0c7797fc083fa7e5543268c0ff54a6/gcc%2Fconfig%2Fpdp11%2Fpdp11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/442fcea74d0c7797fc083fa7e5543268c0ff54a6/gcc%2Fconfig%2Fpdp11%2Fpdp11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11.c?ref=442fcea74d0c7797fc083fa7e5543268c0ff54a6", "patch": "@@ -304,6 +304,9 @@ static bool pdp11_scalar_mode_supported_p (scalar_mode);\n \n #undef TARGET_HAVE_SPECULATION_SAFE_VALUE\n #define TARGET_HAVE_SPECULATION_SAFE_VALUE speculation_safe_value_not_needed\n+\n+#undef  TARGET_STACK_PROTECT_RUNTIME_ENABLED_P\n+#define TARGET_STACK_PROTECT_RUNTIME_ENABLED_P hook_bool_void_false\n \f\n /* A helper function to determine if REGNO should be saved in the\n    current function's stack frame.  */\n@@ -316,6 +319,13 @@ pdp11_saved_regno (unsigned regno)\n \n /* Expand the function prologue.  */\n \n+/* Frame layout, from high to low memory (stack push order):\n+   return address (from jsr instruction)\n+   saved CPU registers, lowest number first\n+   saved FPU registers, lowest number first, always 64 bit mode\n+   *** frame pointer points here ***\n+   local variables\n+   alloca storage if any.  */\n void\n pdp11_expand_prologue (void)\n {\t\t\t\t\t\t\t       \n@@ -331,31 +341,9 @@ pdp11_expand_prologue (void)\n       emit_insn (gen_seti ());\n     }\n     \n-  if (frame_pointer_needed) \t\t\t\t\t\n-    {\t\t\t\t\t\t\t\t\n-      x = gen_rtx_PRE_DEC (Pmode, stack_pointer_rtx);\n-      x = gen_frame_mem (Pmode, x);\n-      emit_move_insn (x, hard_frame_pointer_rtx);\n-\n-      emit_move_insn (hard_frame_pointer_rtx, stack_pointer_rtx);\n-    }\t\t\t\t\t\t\t\t\n-\n-  /* Make frame.  */\n-  if (fsize)\n-    {\n-      emit_insn (gen_addhi3 (stack_pointer_rtx, stack_pointer_rtx,\n-\t\t\t     GEN_INT (-fsize)));\n-\n-      /* Prevent frame references via the frame pointer from being\n-\t scheduled before the frame is allocated.  */\n-      if (frame_pointer_needed)\n-\temit_insn (gen_blockage ());\n-    }\n-\n   /* Save CPU registers.  */\n   for (regno = R0_REGNUM; regno <= PC_REGNUM; regno++)\n-    if (pdp11_saved_regno (regno)\n-\t&& (regno != HARD_FRAME_POINTER_REGNUM || !frame_pointer_needed))\n+    if (pdp11_saved_regno (regno))\n       {\n \tx = gen_rtx_PRE_DEC (Pmode, stack_pointer_rtx);\n \tx = gen_frame_mem (Pmode, x);\n@@ -383,25 +371,21 @@ pdp11_expand_prologue (void)\n \tx = gen_frame_mem (DFmode, x);\n \temit_move_insn (x, via_ac);\n       }\n-}\n-\n-/* The function epilogue should not depend on the current stack pointer!\n-   It should use the frame pointer only.  This is mandatory because\n-   of alloca; we also take advantage of it to omit stack adjustments\n-   before returning.  */\n-\n-/* Maybe we can make leaf functions faster by switching to the\n-   second register file - this way we don't have to save regs!\n-   leaf functions are ~ 50% of all functions (dynamically!) \n \n-   set/clear bit 11 (dec. 2048) of status word for switching register files - \n-   but how can we do this? the pdp11/45 manual says bit may only \n-   be set (p.24), but not cleared!\n+  if (frame_pointer_needed)\n+    emit_move_insn (frame_pointer_rtx, stack_pointer_rtx);\n \n-   switching to kernel is probably more expensive, so we'll leave it \n-   like this and not use the second set of registers... \n+  /* Make local variable space.  */\n+  if (fsize)\n+    emit_insn (gen_addhi3 (stack_pointer_rtx, stack_pointer_rtx,\n+\t\t\t   GEN_INT (-fsize)));\n+}\n \n-   maybe as option if you want to generate code for kernel mode? */\n+/* Generate epilogue.  This uses the frame pointer to pop the local\n+   variables and any alloca data off the stack.  If there is no alloca\n+   and frame pointer elimination hasn't been disabled, there is no\n+   frame pointer and the local variables are popped by adjusting the\n+   stack pointer instead.  */\n \n void\n pdp11_expand_epilogue (void)\n@@ -410,6 +394,20 @@ pdp11_expand_epilogue (void)\n   unsigned regno;\n   rtx x, reg, via_ac = NULL;\n \n+  /* Deallocate the local variables.  */\n+  if (fsize)\n+    {\n+      if (frame_pointer_needed)\n+\t{\n+\t  /* We can deallocate the frame with a single move.  */\n+\t  emit_move_insn (stack_pointer_rtx, frame_pointer_rtx);\n+\t}\n+      else\n+\temit_insn (gen_addhi3 (stack_pointer_rtx, stack_pointer_rtx,\n+\t\t\t       GEN_INT (fsize)));\n+    }\n+\n+  /* Restore the FPU registers.  */\n   if (pdp11_saved_regno (AC4_REGNUM) || pdp11_saved_regno (AC5_REGNUM))\n     {\n       /* Find a temporary with which to restore AC4/5.  */\n@@ -421,109 +419,33 @@ pdp11_expand_epilogue (void)\n \t  }\n     }\n \n-  /* If possible, restore registers via pops.  */\n-  if (!frame_pointer_needed || crtl->sp_is_unchanging)\n-    {\n-      /* Restore registers via pops.  */\n-\n-      for (regno = AC5_REGNUM; regno >= AC0_REGNUM; regno--)\n-\tif (pdp11_saved_regno (regno))\n-\t  {\n-\t    x = gen_rtx_POST_INC (Pmode, stack_pointer_rtx);\n-\t    x = gen_frame_mem (DFmode, x);\n-\t    reg = gen_rtx_REG (DFmode, regno);\n-\n-\t    if (LOAD_FPU_REG_P (regno))\n-\t      emit_move_insn (reg, x);\n-\t    else\n-\t      {\n-\t\temit_move_insn (via_ac, x);\n-\t\temit_move_insn (reg, via_ac);\n-\t      }\n-\t  }\n+  /* Restore registers via pops.  */\n \n-      for (regno = PC_REGNUM; regno >= R0_REGNUM + 2; regno--)\n-\tif (pdp11_saved_regno (regno)\n-\t    && (regno != HARD_FRAME_POINTER_REGNUM || !frame_pointer_needed))\n-\t  {\n-\t    x = gen_rtx_POST_INC (Pmode, stack_pointer_rtx);\n-\t    x = gen_frame_mem (Pmode, x);\n-\t    emit_move_insn (gen_rtx_REG (Pmode, regno), x);\n-\t  }\n-    }\n-  else\n-    {\n-      /* Restore registers via moves.  */\n-      /* ??? If more than a few registers need to be restored, it's smaller\n-\t to generate a pointer through which we can emit pops.  Consider\n-\t that moves cost 2*NREG words and pops cost NREG+3 words.  This\n-\t means that the crossover is NREG=3.\n-\n-\t Possible registers to use are:\n-\t  (1) The first call-saved general register.  This register will\n-\t\tbe restored with the last pop.\n-\t  (2) R1, if it's not used as a return register.\n-\t  (3) FP itself.  This option may result in +4 words, since we\n-\t\tmay need two add imm,rn instructions instead of just one.\n-\t\tThis also has the downside that we're not representing\n-\t\tthe unwind info in any way, so during the epilogue the\n-\t\tdebugger may get lost.  */\n-\n-      HOST_WIDE_INT ofs = -pdp11_sp_frame_offset ();\n-\n-      for (regno = AC5_REGNUM; regno >= AC0_REGNUM; regno--)\n-\tif (pdp11_saved_regno (regno))\n-\t  {\n-\t    x = plus_constant (Pmode, hard_frame_pointer_rtx, ofs);\n-\t    x = gen_frame_mem (DFmode, x);\n-\t    reg = gen_rtx_REG (DFmode, regno);\n-\n-\t    if (LOAD_FPU_REG_P (regno))\n-\t      emit_move_insn (reg, x);\n-\t    else\n-\t      {\n-\t        emit_move_insn (via_ac, x);\n-\t\temit_move_insn (reg, via_ac);\n-\t      }\n-\t    ofs += 8;\n-\t  }\n+  for (regno = AC5_REGNUM; regno >= AC0_REGNUM; regno--)\n+    if (pdp11_saved_regno (regno))\n+      {\n+\tx = gen_rtx_POST_INC (Pmode, stack_pointer_rtx);\n+\tx = gen_frame_mem (DFmode, x);\n+\treg = gen_rtx_REG (DFmode, regno);\n \n-      for (regno = PC_REGNUM; regno >= R0_REGNUM + 2; regno--)\n-\tif (pdp11_saved_regno (regno)\n-\t    && (regno != HARD_FRAME_POINTER_REGNUM || !frame_pointer_needed))\n+\tif (LOAD_FPU_REG_P (regno))\n+\t  emit_move_insn (reg, x);\n+\telse\n \t  {\n-\t    x = plus_constant (Pmode, hard_frame_pointer_rtx, ofs);\n-\t    x = gen_frame_mem (Pmode, x);\n-\t    emit_move_insn (gen_rtx_REG (Pmode, regno), x);\n-\t    ofs += 2;\n+\t    emit_move_insn (via_ac, x);\n+\t    emit_move_insn (reg, via_ac);\n \t  }\n-    }\n-\n-  /* Deallocate the stack frame.  */\n-  if (fsize)\n-    {\n-      /* Prevent frame references via any pointer from being\n-\t scheduled after the frame is deallocated.  */\n-      emit_insn (gen_blockage ());\n-\n-      if (frame_pointer_needed)\n-\t{\n-\t  /* We can deallocate the frame with a single move.  */\n-\t  emit_move_insn (stack_pointer_rtx, hard_frame_pointer_rtx);\n-\t}\n-      else\n-\temit_insn (gen_addhi3 (stack_pointer_rtx, stack_pointer_rtx,\n-\t\t\t       GEN_INT (fsize)));\n-    }\n+      }\n \n-  if (frame_pointer_needed)\n-    {\n-      x = gen_rtx_POST_INC (Pmode, stack_pointer_rtx);\n-      x = gen_frame_mem (Pmode, x);\n-      emit_move_insn (hard_frame_pointer_rtx, x);\n-    }\n+  for (regno = PC_REGNUM; regno >= R0_REGNUM + 2; regno--)\n+    if (pdp11_saved_regno (regno))\n+      {\n+\tx = gen_rtx_POST_INC (Pmode, stack_pointer_rtx);\n+\tx = gen_frame_mem (Pmode, x);\n+\temit_move_insn (gen_rtx_REG (Pmode, regno), x);\n+      }\n \n-  emit_jump_insn (gen_return ());\n+  emit_jump_insn (gen_rtspc ());\n }\n \n /* Return the best assembler insn template\n@@ -539,21 +461,23 @@ singlemove_string (rtx *operands)\n \n \f\n /* Expand multi-word operands (SImode or DImode) into the 2 or 4\n-   corresponding HImode operands.  The number of operands is given\n-   as the third argument, and the required order of the parts as\n-   the fourth argument.  */\n+   corresponding HImode operands.  The number of operands is given as\n+   the third argument, the word count for the mode as the fourth\n+   argument, and the required order of parts as the sixth argument.\n+   The word count is explicit because sometimes we're asked to compare\n+   two constants, both of which have mode VOIDmode, so we can't always\n+   rely on the input operand mode to imply the operand size.  */\n bool\n-pdp11_expand_operands (rtx *operands, rtx exops[][2], int opcount, \n+pdp11_expand_operands (rtx *operands, rtx exops[][2],\n+\t\t       int opcount, int words,\n \t\t       pdp11_action *action, pdp11_partorder order)\n {\n-  int words, op, w, i, sh;\n+  int op, w, i, sh;\n   pdp11_partorder useorder;\n   bool sameoff = false;\n   enum { REGOP, OFFSOP, MEMOP, PUSHOP, POPOP, CNSTOP, RNDOP } optype;\n   long sval[2];\n   \n-  words = GET_MODE_BITSIZE (GET_MODE (operands[0])) / 16;\n-  \n   /* If either piece order is accepted and one is pre-decrement\n      while the other is post-increment, set order to be high order\n      word first.  That will force the pre-decrement to be turned\n@@ -566,19 +490,16 @@ pdp11_expand_operands (rtx *operands, rtx exops[][2], int opcount,\n   useorder = either;\n   if (opcount == 2)\n     {\n-      if (!REG_P (operands[0]) && !REG_P (operands[1]) &&\n-\t  !(CONSTANT_P (operands[1]) || \n-\t    GET_CODE (operands[1]) == CONST_DOUBLE) &&\n+      if (GET_CODE (operands[0]) == MEM &&\n+\t  GET_CODE (operands[1]) == MEM &&\n \t  ((GET_CODE (XEXP (operands[0], 0)) == POST_INC &&\n \t    GET_CODE (XEXP (operands[1], 0)) == PRE_DEC) ||\n \t   (GET_CODE (XEXP (operands[0], 0)) == PRE_DEC &&\n \t    GET_CODE (XEXP (operands[1], 0)) == POST_INC)))\n \t    useorder = big;\n-      else if ((!REG_P (operands[0]) &&\n+      else if ((GET_CODE (operands[0]) == MEM &&\n \t\tGET_CODE (XEXP (operands[0], 0)) == PRE_DEC) ||\n-\t       (!REG_P (operands[1]) &&\n-\t\t!(CONSTANT_P (operands[1]) || \n-\t\t  GET_CODE (operands[1]) == CONST_DOUBLE) &&\n+\t       (GET_CODE (operands[1]) == MEM &&\n \t\tGET_CODE (XEXP (operands[1], 0)) == PRE_DEC))\n \tuseorder = little;\n       else if (REG_P (operands[0]) && REG_P (operands[1]) &&\n@@ -615,7 +536,7 @@ pdp11_expand_operands (rtx *operands, rtx exops[][2], int opcount,\n       /* First classify the operand.  */\n       if (REG_P (operands[op]))\n \toptype = REGOP;\n-      else if (CONSTANT_P (operands[op])\n+      else if (CONST_INT_P (operands[op])\n \t       || GET_CODE (operands[op]) == CONST_DOUBLE)\n \toptype = CNSTOP;\n       else if (GET_CODE (XEXP (operands[op], 0)) == POST_INC)\n@@ -663,8 +584,11 @@ pdp11_expand_operands (rtx *operands, rtx exops[][2], int opcount,\n \t}\n \n       if (GET_CODE (operands[op]) == CONST_DOUBLE)\n-\tREAL_VALUE_TO_TARGET_DOUBLE\n-\t  (*CONST_DOUBLE_REAL_VALUE (operands[op]), sval);\n+\t{\n+\t  gcc_assert (GET_MODE (operands[op]) != VOIDmode);\n+\t  REAL_VALUE_TO_TARGET_DOUBLE\n+\t    (*CONST_DOUBLE_REAL_VALUE (operands[op]), sval);\n+\t}\n       \n       for (i = 0; i < words; i++)\n \t{\n@@ -707,24 +631,31 @@ pdp11_expand_operands (rtx *operands, rtx exops[][2], int opcount,\n const char *\n output_move_multiple (rtx *operands)\n {\n+  rtx inops[2];\n   rtx exops[4][2];\n+  rtx adjops[2];\n+  \n   pdp11_action action[2];\n   int i, words;\n   \n   words = GET_MODE_BITSIZE (GET_MODE (operands[0])) / 16;\n+  adjops[1] = gen_rtx_CONST_INT (HImode, words * 2);\n \n-  pdp11_expand_operands (operands, exops, 2, action, either);\n+  inops[0] = operands[0];\n+  inops[1] = operands[1];\n+  \n+  pdp11_expand_operands (inops, exops, 2, words, action, either);\n   \n   /* Check for explicit decrement before.  */\n   if (action[0] == dec_before)\n     {\n-      operands[0] = XEXP (operands[0], 0);\n-      output_asm_insn (\"sub\\t%#4,%0\", operands);\n+      adjops[0] = XEXP (XEXP (operands[0], 0), 0);\n+      output_asm_insn (\"sub\\t%1,%0\", adjops);\n     }\n   if (action[1] == dec_before)\n     {\n-      operands[1] = XEXP (operands[1], 0);\n-      output_asm_insn (\"sub\\t%#4,%1\", operands);\n+      adjops[0] = XEXP (XEXP (operands[1], 0), 0);\n+      output_asm_insn (\"sub\\t%1,%0\", adjops);\n     }\n \n   /* Do the words.  */\n@@ -734,13 +665,13 @@ output_move_multiple (rtx *operands)\n   /* Check for increment after.  */\n   if (action[0] == inc_after)\n     {\n-      operands[0] = XEXP (operands[0], 0);\n-      output_asm_insn (\"add\\t%#4,%0\", operands);\n+      adjops[0] = XEXP (XEXP (operands[0], 0), 0);\n+      output_asm_insn (\"add\\t%1,%0\", adjops);\n     }\n   if (action[1] == inc_after)\n     {\n-      operands[1] = XEXP (operands[1], 0);\n-      output_asm_insn (\"add\\t%#4,%1\", operands);\n+      adjops[0] = XEXP (XEXP (operands[1], 0), 0);\n+      output_asm_insn (\"add\\t%1,%0\", adjops);\n     }\n \n   return \"\";\n@@ -752,9 +683,9 @@ pdp11_gen_int_label (char *label, const char *prefix, int num)\n {\n   if (TARGET_DEC_ASM)\n     /* +1 because GCC numbers labels starting at zero.  */\n-    sprintf (label, \"*%lu$\", num + 1);\n+    sprintf (label, \"*%u$\", num + 1);\n   else\n-    sprintf (label, \"*%s_%lu\", prefix, num);\n+    sprintf (label, \"*%s_%u\", prefix, num);\n }\n   \n /* Output an ascii string.  */\n@@ -780,7 +711,7 @@ output_ascii (FILE *file, const char *p, int size)\n \t    {\n \t      if (delim)\n \t\tputc ('\"', file);\n-\t      fprintf (file, \"<%o%>\", c);\n+\t      fprintf (file, \"<%o>\", c);\n \t      delim = false;\n \t    }\n \t  else\n@@ -815,15 +746,30 @@ pdp11_asm_output_var (FILE *file, const char *name, int size,\n {\n   if (align > 8)\n     fprintf (file, \"\\t.even\\n\");\n-  if (global)\n+  if (TARGET_DEC_ASM)\n     {\n-      fprintf (file, \".globl \");\n       assemble_name (file, name);\n+      if (global)\n+\tfputs (\"::\", file);\n+      else\n+\tfputs (\":\", file);\n+      if (align > 8)\n+\tfprintf (file, \"\\t.blkw\\t%o\\n\", (size & 0xffff) / 2);\n+      else\n+\tfprintf (file, \"\\t.blkb\\t%o\\n\", size & 0xffff);\n     }\n-  fprintf (file, \"\\n\");\n-  assemble_name (file, name);\n-  fputs (\":\", file);\n-  ASM_OUTPUT_SKIP (file, size);\n+  else\n+    {\n+      if (global)\n+\t{\n+\t  fprintf (file, \".globl \");\n+\t  assemble_name (file, name);\n+\t}\n+      fprintf (file, \"\\n\");\n+      assemble_name (file, name);\n+      fputs (\":\", file);\n+      ASM_OUTPUT_SKIP (file, size);\n+    }  \n }\n \n /* Special format operators handled here:\n@@ -855,7 +801,7 @@ pdp11_asm_print_operand (FILE *file, rtx x, int code)\n     fprintf (file, \"%s\", reg_names[REGNO (x)]);\n   else if (GET_CODE (x) == MEM)\n     output_address (GET_MODE (x), XEXP (x, 0));\n-  else if (GET_CODE (x) == CONST_DOUBLE && GET_MODE (x) != SImode)\n+  else if (GET_CODE (x) == CONST_DOUBLE && FLOAT_MODE_P (GET_MODE (x)))\n     {\n       REAL_VALUE_TO_TARGET_DOUBLE (*CONST_DOUBLE_REAL_VALUE (x), sval);\n       if (TARGET_DEC_ASM)\n@@ -1013,8 +959,7 @@ static int\n pdp11_register_move_cost (machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\t  reg_class_t c1, reg_class_t c2)\n {\n-  if (((c1 == MUL_REGS || c1 == GENERAL_REGS) &&\n-       (c2 == MUL_REGS || c2 == GENERAL_REGS)))\n+  if (CPU_REG_CLASS (c1) && CPU_REG_CLASS (c2))\n     return 2;\n   else if ((c1 >= LOAD_FPU_REGS && c1 <= FPU_REGS && c2 == LOAD_FPU_REGS) ||\n \t   (c2 >= LOAD_FPU_REGS && c2 <= FPU_REGS && c1 == LOAD_FPU_REGS))\n@@ -1512,50 +1457,32 @@ no_side_effect_operand(rtx op, machine_mode mode ATTRIBUTE_UNUSED)\n   return FALSE;\n }\n \n-\n-/*\n- * expand a block move:\n- *\n- * operands[0]\t... to\n- * operands[1]  ... from\n- * operands[2]  ... length\n- * operands[3]  ... alignment\n- */\n-\n-void\n-expand_block_move(rtx *operands)\n+/* Return TRUE if op is a push or pop using the register \"regno\".  */\n+bool\n+pushpop_regeq (rtx op, int regno)\n {\n-    rtx lb, test;\n-    rtx fromop, toop, counter;\n-    int count;\n-\n-    /* Transform BLKmode MEM reference into a (reg)+ operand.  */\n-    toop = copy_to_mode_reg (Pmode, XEXP (operands[0], 0));\n-    toop = gen_rtx_POST_INC (Pmode, toop);\n-    fromop = copy_to_mode_reg (Pmode, XEXP (operands[1], 0));\n-    fromop = gen_rtx_POST_INC (Pmode, fromop);\n-\n-    count = INTVAL (operands[2]);\n-    if (INTVAL (operands [3]) >= 2 && (count & 1) == 0)\n-      {\n-\tcount >>= 1;\n-\ttoop = gen_rtx_MEM (HImode, toop);\n-\tfromop = gen_rtx_MEM (HImode, fromop);\n-      }\n-    else\n-      {\n-\ttoop = gen_rtx_MEM (QImode, toop);\n-\tfromop = gen_rtx_MEM (QImode, fromop);\n-      }\n-    counter = copy_to_mode_reg (HImode, gen_rtx_CONST_INT (HImode, count));\n+  rtx addr;\n+  \n+  /* False if not memory reference.  */\n+  if (GET_CODE (op) != MEM)\n+    return FALSE;\n+  \n+  /* Get the address of the memory reference.  */\n+  addr = XEXP (op, 0);\n \n-    /* Label at top of loop */\n-    lb = gen_label_rtx ();\n-    emit_label (lb);\n-    emit_move_insn (toop, fromop);\n-    emit_insn (gen_subhi3 (counter, counter, const1_rtx));\n-    test = gen_rtx_NE (HImode, counter, const0_rtx);\n-    emit_jump_insn (gen_cbranchhi4 (test, counter, const0_rtx, lb));\n+  if (GET_CODE (addr) == MEM)\n+    addr = XEXP (addr, 0);\n+    \n+  switch (GET_CODE (addr))\n+    {\n+    case PRE_DEC:\n+    case POST_INC:\n+    case PRE_MODIFY:\n+    case POST_MODIFY:\n+      return REGNO (XEXP (addr, 0)) == regno;\n+    default:\n+      return FALSE;\n+    }\n }\n \n /* This function checks whether a real value can be encoded as\n@@ -1565,7 +1492,12 @@ int\n legitimate_const_double_p (rtx address)\n {\n   long sval[2];\n+\n+  /* If it's too big for HOST_WIDE_INT, it's definitely to big here.  */\n+  if (GET_MODE (address) == VOIDmode)\n+    return 0;\n   REAL_VALUE_TO_TARGET_DOUBLE (*CONST_DOUBLE_REAL_VALUE (address), sval);\n+\n   if ((sval[0] & 0xffff) == 0 && sval[1] == 0)\n     return 1;\n   return 0;\n@@ -1723,7 +1655,7 @@ pdp11_legitimate_address_p (machine_mode mode,\n \t  && GET_CODE ((xfoob = XEXP (operand, 1))) == PLUS\n \t  && GET_CODE (XEXP (xfoob, 0)) == REG\n \t  && REGNO (XEXP (xfoob, 0)) == STACK_POINTER_REGNUM\n-\t  && CONSTANT_P (XEXP (xfoob, 1))\n+\t  && CONST_INT_P (XEXP (xfoob, 1))\n \t  && INTVAL (XEXP (xfoob,1)) == -2;\n \n       case POST_MODIFY:\n@@ -1733,7 +1665,7 @@ pdp11_legitimate_address_p (machine_mode mode,\n \t  && GET_CODE ((xfoob = XEXP (operand, 1))) == PLUS\n \t  && GET_CODE (XEXP (xfoob, 0)) == REG\n \t  && REGNO (XEXP (xfoob, 0)) == STACK_POINTER_REGNUM\n-\t  && CONSTANT_P (XEXP (xfoob, 1))\n+\t  && CONST_INT_P (XEXP (xfoob, 1))\n \t  && INTVAL (XEXP (xfoob,1)) == 2;\n \n       case MEM:\n@@ -1792,16 +1724,18 @@ pdp11_legitimate_address_p (machine_mode mode,\n enum reg_class\n pdp11_regno_reg_class (int regno)\n { \n-  if (regno == FRAME_POINTER_REGNUM || regno == ARG_POINTER_REGNUM)\n-    return GENERAL_REGS;\n+  if (regno == ARG_POINTER_REGNUM)\n+    return NOTSP_REG;\n   else if (regno == CC_REGNUM || regno == FCC_REGNUM)\n     return CC_REGS;\n   else if (regno > AC3_REGNUM)\n     return NO_LOAD_FPU_REGS;\n   else if (regno >= AC0_REGNUM)\n     return LOAD_FPU_REGS;\n-  else if (regno & 1)\n-    return MUL_REGS;\n+  else if (regno == 6)\n+    return NOTR0_REG;\n+  else if (regno < 6)\n+    return NOTSP_REG;\n   else\n     return GENERAL_REGS;\n }\n@@ -1815,11 +1749,11 @@ pdp11_fixed_cc_regs (unsigned int *p1, unsigned int *p2)\n   return true;\n }\n \n-int\n-pdp11_sp_frame_offset (void)\n+static int\n+pdp11_reg_save_size (void)\n {\n   int offset = 0, regno;\n-  offset = get_frame_size();\n+\n   for (regno = 0; regno <= PC_REGNUM; regno++)\n     if (pdp11_saved_regno (regno))\n       offset += 2;\n@@ -1836,32 +1770,18 @@ pdp11_sp_frame_offset (void)\n int\n pdp11_initial_elimination_offset (int from, int to)\n {\n+  /* Get the size of the register save area.  */\n   int spoff;\n   \n-  if (from == ARG_POINTER_REGNUM && to == HARD_FRAME_POINTER_REGNUM)\n-    return 4;\n-  else if (from == FRAME_POINTER_REGNUM\n-\t   && to == HARD_FRAME_POINTER_REGNUM)\n-    return 0;\n+  if (from == FRAME_POINTER_REGNUM && to == STACK_POINTER_REGNUM)\n+    return get_frame_size ();\n+  else if (from == ARG_POINTER_REGNUM && to == FRAME_POINTER_REGNUM)\n+    return pdp11_reg_save_size () + 2;\n+  else if (from == ARG_POINTER_REGNUM && to == STACK_POINTER_REGNUM)\n+    return pdp11_reg_save_size () + 2 + get_frame_size ();\n   else\n-    {\n-      gcc_assert (to == STACK_POINTER_REGNUM);\n-\n-      /* Get the size of the register save area.  */\n-      spoff = pdp11_sp_frame_offset ();\n-      if (from == FRAME_POINTER_REGNUM)\n-\treturn spoff;\n-\n-      gcc_assert (from == ARG_POINTER_REGNUM);\n-\n-      /* If there is a frame pointer, that is saved too.  */\n-      if (frame_pointer_needed)\n-\tspoff += 2;\n-      \n-      /* Account for the saved PC in the function call.  */\n-      return spoff + 2;\n-    }\n-}    \n+    gcc_assert (0);\n+}\n \n /* A copy of output_addr_const modified for pdp11 expression syntax.\n    output_addr_const also gets called for %cDIGIT and %nDIGIT, which we don't\n@@ -1913,21 +1833,6 @@ output_addr_const_pdp11 (FILE *file, rtx x)\n       output_addr_const_pdp11 (file, XEXP (x, 0));\n       break;\n \n-    case CONST_DOUBLE:\n-      if (GET_MODE (x) == VOIDmode)\n-\t{\n-\t  /* We can use %o if the number is one word and positive.  */\n-\t  if (TARGET_DEC_ASM)\n-\t    fprintf (file, \"%o\", (int) CONST_DOUBLE_LOW (x) & 0xffff);\n-\t  else\n-\t    fprintf (file, \"%#o\", (int) CONST_DOUBLE_LOW (x) & 0xffff);\n-\t}\n-      else\n-\t/* We can't handle floating point constants;\n-\t   PRINT_OPERAND must handle them.  */\n-\toutput_operand_lossage (\"floating constant misused\");\n-      break;\n-\n     case PLUS:\n       /* Some assemblers need integer constants to appear last (e.g. masm).  */\n       if (GET_CODE (XEXP (x, 0)) == CONST_INT)\n@@ -2033,7 +1938,7 @@ pdp11_expand_shift (rtx *operands, rtx (*shift_sc) (rtx, rtx, rtx),\n   rtx r, test;\n   rtx_code_label *lb;\n   \n-  if (CONSTANT_P (operands[2]) && pdp11_small_shift (INTVAL (operands[2])))\n+  if (CONST_INT_P (operands[2]) && pdp11_small_shift (INTVAL (operands[2])))\n     emit_insn ((*shift_sc) (operands[0], operands[1], operands[2]));\n   else if (TARGET_40_PLUS)\n     return false;\n@@ -2043,7 +1948,7 @@ pdp11_expand_shift (rtx *operands, rtx (*shift_sc) (rtx, rtx, rtx),\n       r = gen_reg_rtx (HImode);\n       emit_move_insn (operands[0], operands[1]);\n       emit_move_insn (r, operands[2]);\n-      if (!CONSTANT_P (operands[2]))\n+      if (!CONST_INT_P (operands[2]))\n \t{\n \t  test = gen_rtx_LE (HImode, r, const0_rtx);\n \t  emit_jump_insn (gen_cbranchhi4 (test, r, const0_rtx, lb));\n@@ -2053,7 +1958,7 @@ pdp11_expand_shift (rtx *operands, rtx (*shift_sc) (rtx, rtx, rtx),\n \t optimizer and it doesn't appreciate flow changes happening\n \t while it's doing things.  */\n       emit_insn ((*shift_base) (operands[0], operands[1], r));\n-      if (!CONSTANT_P (operands[2]))\n+      if (!CONST_INT_P (operands[2]))\n \t{\n \t  emit_label (lb);\n \n@@ -2072,16 +1977,20 @@ const char *\n pdp11_assemble_shift (rtx *operands, machine_mode m, int code)\n {\n   int i, n;\n-  rtx exops[4][2];\n+  rtx inops[2];\n+  rtx exops[2][2];\n   rtx lb[1];\n   pdp11_action action[2];\n-  const bool small = CONSTANT_P (operands[2]) && pdp11_small_shift (INTVAL (operands[2]));\n+  const bool small = CONST_INT_P (operands[2]) && pdp11_small_shift (INTVAL (operands[2]));\n \n   gcc_assert (small || !TARGET_40_PLUS);\n \n   if (m == E_SImode)\n-      pdp11_expand_operands (operands, exops, 1, action, either);\n-\n+    {\n+      inops[0] = operands[0];\n+      pdp11_expand_operands (inops, exops, 1, 2, action, either);\n+    }\n+  \n   if (!small)\n     {\n       /* Loop case, generate the top of loop label.  */\n@@ -2179,7 +2088,7 @@ pdp11_shift_length (rtx *operands, machine_mode m, int code, bool simple_operand\n   /* If shifting by a small constant, the loop is unrolled by the\n      shift count.  Otherwise, account for the size of the decrement\n      and branch.  */\n-  if (CONSTANT_P (operands[2]) && pdp11_small_shift (INTVAL (operands[2])))\n+  if (CONST_INT_P (operands[2]) && pdp11_small_shift (INTVAL (operands[2])))\n     shift_size *= INTVAL (operands[2]);\n   else\n     shift_size += 4;\n@@ -2191,6 +2100,39 @@ pdp11_shift_length (rtx *operands, machine_mode m, int code, bool simple_operand\n   return shift_size;\n }\n \n+/* Return the length of 2 or 4 word integer compares.  */\n+int\n+pdp11_cmp_length (rtx *operands, int words)\n+{\n+  rtx inops[2];\n+  rtx exops[4][2];\n+  rtx lb[1];\n+  int i, len = 0;\n+\n+  if (!reload_completed)\n+    return 2;\n+  \n+  inops[0] = operands[0];\n+  inops[1] = operands[1];\n+  \n+  pdp11_expand_operands (inops, exops, 2, words, NULL, big);\n+\n+  for (i = 0; i < words; i++)\n+    {\n+      len += 4;    /* cmp instruction word and branch that follows.  */\n+      if (!REG_P (exops[i][0]) &&\n+\t  !simple_memory_operand (exops[i][0], HImode))\n+\tlen += 2;  /* first operand extra word.  */\n+      if (!REG_P (exops[i][1]) &&\n+\t  !simple_memory_operand (exops[i][1], HImode) &&\n+\t  !(CONST_INT_P (exops[i][1]) && INTVAL (exops[i][1]) == 0))\n+\tlen += 2;  /* second operand extra word.  */\n+    }\n+\n+  /* Deduct one word because there is no branch at the end.  */\n+  return len - 2;\n+}\n+\n /* Prepend to CLOBBERS hard registers that are automatically clobbered\n    for an asm We do this for CC_REGNUM and FCC_REGNUM (on FPU target)\n    to maintain source compatibility with the original cc0-based"}, {"sha": "92c237b3b7e65799710cc516e0b42c2adc0ef8e4", "filename": "gcc/config/pdp11/pdp11.h", "status": "modified", "additions": 66, "deletions": 40, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/442fcea74d0c7797fc083fa7e5543268c0ff54a6/gcc%2Fconfig%2Fpdp11%2Fpdp11.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/442fcea74d0c7797fc083fa7e5543268c0ff54a6/gcc%2Fconfig%2Fpdp11%2Fpdp11.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11.h?ref=442fcea74d0c7797fc083fa7e5543268c0ff54a6", "patch": "@@ -32,6 +32,20 @@ along with GCC; see the file COPYING3.  If not see\n   do\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\\\n       builtin_define_std (\"pdp11\");\t\t\\\n+      if (TARGET_INT16) \t\t\t\t\t\\\n+\tbuiltin_define_with_int_value (\"__pdp11_int\", 16);\t\\\n+      else\t\t\t\t\t\t\t\\\n+\tbuiltin_define_with_int_value (\"__pdp11_int\", 32);\t\\\n+      if (TARGET_40)\t\t\t\t\t\t\\\n+\tbuiltin_define_with_int_value (\"__pdp11_model\", 40);\t\\\n+      else if (TARGET_45)\t\t\t\t\t\\\n+\tbuiltin_define_with_int_value (\"__pdp11_model\", 45);\t\\\n+      else\t\t\t\t\t\t\t\\\n+\tbuiltin_define_with_int_value (\"__pdp11_model\", 10);\t\\\n+      if (TARGET_FPU)\t\t\t\t\t\t\\\n+\tbuiltin_define (\"__pdp11_fpu\");\t\t\t\t\\\n+      if (TARGET_AC0)\t\t\t\t\t\t\\\n+\tbuiltin_define (\"__pdp11_ac0\");\t\t\t\t\\\n     }\t\t\t\t\t\t\\\n   while (0)\n \n@@ -153,7 +167,7 @@ extern const struct real_format pdp11_d_format;\n #define FIXED_REGISTERS  \\\n {0, 0, 0, 0, 0, 0, 1, 1, \\\n  0, 0, 0, 0, 0, 0, 1, 1, \\\n- 1, 1 }\n+ 1 }\n \n \n \n@@ -168,7 +182,7 @@ extern const struct real_format pdp11_d_format;\n #define CALL_USED_REGISTERS  \\\n {1, 1, 0, 0, 0, 0, 1, 1, \\\n  0, 0, 0, 0, 0, 0, 1, 1, \\\n- 1, 1 }\n+ 1 }\n \n \n /* Specify the registers used for certain standard purposes.\n@@ -211,6 +225,13 @@ CC_REGS is the condition codes (CPU and FPU)\n \n enum reg_class\n   { NO_REGS,\n+    NOTR0_REG,\n+    NOTR1_REG,\n+    NOTR2_REG,\n+    NOTR3_REG,\n+    NOTR4_REG,\n+    NOTR5_REG,\n+    NOTSP_REG,\n     MUL_REGS,\n     GENERAL_REGS,\n     LOAD_FPU_REGS,\n@@ -229,6 +250,13 @@ enum reg_class\n \n #define REG_CLASS_NAMES  \\\n   { \"NO_REGS\",\t\t \\\n+    \"NOTR0_REG\",\t \\\n+    \"NOTR1_REG\",\t \\\n+    \"NOTR2_REG\",\t \\\n+    \"NOTR3_REG\",\t \\\n+    \"NOTR4_REG\",\t \\\n+    \"NOTR5_REG\",\t \\\n+    \"SP_REG\",\t\t \\\n     \"MUL_REGS\", \t \\\n     \"GENERAL_REGS\",\t \\\n     \"LOAD_FPU_REGS\",\t \\\n@@ -243,13 +271,20 @@ enum reg_class\n \n #define REG_CLASS_CONTENTS \\\n   { {0x00000},\t/* NO_REGS */\t\t\\\n-    {0x000aa},\t/* MUL_REGS */\t\t\\\n-    {0x0c0ff},\t/* GENERAL_REGS */\t\\\n+    {0x000fe},\t/* NOTR0_REG */\t\t\\\n+    {0x000fd},\t/* NOTR1_REG */\t\t\\\n+    {0x000fb},\t/* NOTR2_REG */\t\t\\\n+    {0x000f7},\t/* NOTR3_REG */\t\t\\\n+    {0x000ef},\t/* NOTR4_REG */\t\t\\\n+    {0x000df},\t/* NOTR5_REG */\t\t\\\n+    {0x000bf},\t/* NOTSP_REG */\t\t\\\n+    {0x0002a},\t/* MUL_REGS */\t\t\\\n+    {0x040ff},\t/* GENERAL_REGS */\t\\\n     {0x00f00},\t/* LOAD_FPU_REGS */\t\\\n     {0x03000},\t/* NO_LOAD_FPU_REGS */ \t\\\n     {0x03f00},\t/* FPU_REGS */\t\t\\\n-    {0x30000},\t/* CC_REGS */\t\t\\\n-    {0x3ffff}}\t/* ALL_REGS */\n+    {0x18000},\t/* CC_REGS */\t\t\\\n+    {0x1ffff}}\t/* ALL_REGS */\n \n /* The same information, inverted:\n    Return the class number of the smallest class containing\n@@ -262,13 +297,17 @@ enum reg_class\n #define INDEX_REG_CLASS GENERAL_REGS\n #define BASE_REG_CLASS GENERAL_REGS\n \n+/* Return TRUE if the class is a CPU register.  */\n+#define CPU_REG_CLASS(CLASS) \\\n+  (CLASS >= NOTR0_REG && CLASS <= GENERAL_REGS)\n+  \n /* Return the maximum number of consecutive registers\n    needed to represent mode MODE in a register of class CLASS.  */\n #define CLASS_MAX_NREGS(CLASS, MODE)\t\\\n-((CLASS == GENERAL_REGS || CLASS == MUL_REGS)?\t\t\t\t\\\n-  ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD):\t\\\n-  1\t\t\t\t\t\t\t\t\t\\\n-)\n+  (CPU_REG_CLASS (CLASS) ?\t\\\n+   ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD):\t\\\n+   1\t\t\t\t\t\t\t\t\t\\\n+  )\n \f\n /* Stack layout; function entry, exit and calling.  */\n \n@@ -328,16 +367,13 @@ extern int current_first_parm_offset;\n /* Output assembler code to FILE to increment profiler label # LABELNO\n    for profiling a function entry.  */\n \n-#define FUNCTION_PROFILER(FILE, LABELNO)  \\\n-   gcc_unreachable ();\n+#define FUNCTION_PROFILER(FILE, LABELNO)\n \n /* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,\n    the stack pointer does not matter.  The value is tested only in\n    functions that have frame pointers.\n    No definition is equivalent to always zero.  */\n \n-extern int may_call_alloca;\n-\n #define EXIT_IGNORE_STACK\t1\n \n /* Definitions for register eliminations.\n@@ -347,17 +383,14 @@ extern int may_call_alloca;\n    followed by \"to\".  Eliminations of the same \"from\" register are listed\n    in order of preference.\n \n-   There are two registers that can always be eliminated on the pdp11.\n-   The frame pointer and the arg pointer can be replaced by either the\n-   hard frame pointer or to the stack pointer, depending upon the\n-   circumstances.  The hard frame pointer is not used before reload and\n-   so it is not eligible for elimination.  */\n+   There are two registers that can be eliminated on the pdp11.  The\n+   arg pointer can be replaced by the frame pointer; the frame pointer\n+   can often be replaced by the stack pointer.  */\n \n #define ELIMINABLE_REGS\t\t\t\t\t\\\n {{ ARG_POINTER_REGNUM, STACK_POINTER_REGNUM},\t\t\\\n- { ARG_POINTER_REGNUM, HARD_FRAME_POINTER_REGNUM},\t\\\n- { FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM},\t\t\\\n- { FRAME_POINTER_REGNUM, HARD_FRAME_POINTER_REGNUM}}\n+ { ARG_POINTER_REGNUM, FRAME_POINTER_REGNUM},\t\t\\\n+ { FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM}}\n \n #define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET) \\\n   ((OFFSET) = pdp11_initial_elimination_offset ((FROM), (TO)))\n@@ -514,8 +547,8 @@ extern int may_call_alloca;\n \n #define REGISTER_NAMES \\\n {\"r0\", \"r1\", \"r2\", \"r3\", \"r4\", \"r5\", \"sp\", \"pc\",     \\\n- \"ac0\", \"ac1\", \"ac2\", \"ac3\", \"ac4\", \"ac5\", \"fp\", \"ap\", \\\n- \"cc\", \"fcc\" }\n+ \"ac0\", \"ac1\", \"ac2\", \"ac3\", \"ac4\", \"ac5\", \"ap\", \"cc\", \\\n+ \"fcc\" }\n \n /* Globalizing directive for a label.  */\n #define GLOBAL_ASM_OP \"\\t.globl\\t\"\n@@ -568,36 +601,29 @@ extern int may_call_alloca;\n #define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  \\\n   pdp11_output_addr_vec_elt (FILE, VALUE)\n \n-/* This is how to output an assembler line\n-   that says to advance the location counter\n-   to a multiple of 2**LOG bytes. \n+/* This is how to output an assembler line that says to advance the\n+   location counter to a multiple of 2**LOG bytes.  Only values 0 and\n+   1 should appear, but due to PR87795 larger values (which are not\n+   supported) can also appear.  So we treat all alignment of LOG >= 1\n+   as word (2 byte) alignment.\n */\n \n #define ASM_OUTPUT_ALIGN(FILE,LOG)\t\\\n-  switch (LOG)\t\t\t\t\\\n-    {\t\t\t\t\t\\\n-      case 0:\t\t\t\t\\\n-\tbreak;\t\t\t\t\\\n-      case 1:\t\t\t\t\\\n-\tfprintf (FILE, \"\\t.even\\n\");\t\\\n-\tbreak;\t\t\t\t\\\n-      default:\t\t\t\t\\\n-\tgcc_unreachable ();\t\t\\\n-    }\n+  if (LOG != 0)\t\t\t\t\\\n+    fprintf (FILE, \"\\t.even\\n\")\n \n #define ASM_OUTPUT_SKIP(FILE,SIZE)  \\\n   if (TARGET_DEC_ASM) \\\n-    fprintf (FILE, \"\\t.blkb\\t%ho\\n\", (SIZE) & 0xffff);\t\\\n+    fprintf (FILE, \"\\t.blkb\\t%o\\n\", (SIZE) & 0xffff);\t\\\n   else\t\t\t\t\t\t\t\\\n-    fprintf (FILE, \"\\t.=.+ %#ho\\n\", (SIZE) & 0xffff);\n+    fprintf (FILE, \"\\t.=.+ %#o\\n\", (SIZE) & 0xffff);\n \n /* This says how to output an assembler line\n    to define a global common symbol.  */\n \n #define ASM_OUTPUT_ALIGNED_COMMON(FILE, NAME, SIZE, ALIGN)  \\\n   pdp11_asm_output_var (FILE, NAME, SIZE, ALIGN, true)\n \n-\n /* This says how to output an assembler line\n    to define a local common symbol.  */\n "}, {"sha": "fc5efc7939013d3be9982f827aee653b31678ab7", "filename": "gcc/config/pdp11/pdp11.md", "status": "modified", "additions": 215, "deletions": 53, "changes": 268, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/442fcea74d0c7797fc083fa7e5543268c0ff54a6/gcc%2Fconfig%2Fpdp11%2Fpdp11.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/442fcea74d0c7797fc083fa7e5543268c0ff54a6/gcc%2Fconfig%2Fpdp11%2Fpdp11.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11.md?ref=442fcea74d0c7797fc083fa7e5543268c0ff54a6", "patch": "@@ -26,29 +26,29 @@\n     UNSPECV_BLOCKAGE\n     UNSPECV_SETD\n     UNSPECV_SETI\n+    UNSPECV_MOVMEM\n   ])\n \n (define_constants\n   [\n    ;; Register numbers\n    (R0_REGNUM     \t  0)\n    (RETVAL_REGNUM     \t  0)\n-   (HARD_FRAME_POINTER_REGNUM  5)\n+   (FRAME_POINTER_REGNUM  5)\n    (STACK_POINTER_REGNUM  6)\n    (PC_REGNUM             7)\n    (AC0_REGNUM            8)\n    (AC3_REGNUM            11)\n    (AC4_REGNUM            12)\n    (AC5_REGNUM            13)\n-   ;; The next two are not physical registers but are used for addressing\n-   ;; arguments.\n-   (FRAME_POINTER_REGNUM  14)\n-   (ARG_POINTER_REGNUM    15)\n+   ;; The next one is not a physical register but is used for\n+   ;; addressing arguments.\n+   (ARG_POINTER_REGNUM    14)\n    ;; Condition code registers\n-   (CC_REGNUM             16)\n-   (FCC_REGNUM            17)\n+   (CC_REGNUM             15)\n+   (FCC_REGNUM            16)\n    ;; End of hard registers\n-   (FIRST_PSEUDO_REGISTER 18)\n+   (FIRST_PSEUDO_REGISTER 17)\n    \n    ;; Branch offset limits, as byte offsets from (pc).  That is NOT\n    ;; the same thing as \"instruction address\" -- it is for backward\n@@ -178,12 +178,7 @@\n   DONE;\n })\n \n-(define_expand \"return\"\n-  [(return)]\n-  \"reload_completed && !frame_pointer_needed && pdp11_sp_frame_offset () == 0\"\n-  \"\")\n-\n-(define_insn \"*rts\"\n+(define_insn \"rtspc\"\n   [(return)]\n   \"\"\n   \"rts\\tpc\")\n@@ -249,6 +244,78 @@\n    cmp<PDPint:isfx>\\t%0,%1\"\n   [(set_attr \"length\" \"2,2,4,4,4,6\")])\n \n+;; Two word compare\n+(define_insn \"cmpsi\"\n+  [(set (reg:CC CC_REGNUM)\n+\t(compare:CC (match_operand:SI 0 \"general_operand\" \"rDQi\")\n+\t\t    (match_operand:SI 1 \"general_operand\" \"rDQi\")))]\n+  \"\"\n+{\n+  rtx inops[2];\n+  rtx exops[2][2];\n+  rtx lb[1];\n+  \n+  inops[0] = operands[0];\n+  inops[1] = operands[1];\n+  pdp11_expand_operands (inops, exops, 2, 2, NULL, big);\n+  lb[0] = gen_label_rtx ();\n+  \n+  if (CONST_INT_P (exops[0][1]) && INTVAL (exops[0][1]) == 0)\n+   output_asm_insn (\"tst\\t%0\", exops[0]);\n+  else\n+   output_asm_insn (\"cmp\\t%0,%1\", exops[0]);\n+  output_asm_insn (\"bne\\t%l0\", lb);\n+  if (CONST_INT_P (exops[1][1]) && INTVAL (exops[1][1]) == 0)\n+   output_asm_insn (\"tst\\t%0\", exops[1]);\n+  else\n+   output_asm_insn (\"cmp\\t%0,%1\", exops[1]);\n+  output_asm_label (lb[0]);\n+  fputs (\":\\n\", asm_out_file);\n+\n+  return \"\";\n+}\n+  [(set (attr \"length\")\n+\t(symbol_ref \"pdp11_cmp_length (operands, 2)\"))\n+   (set_attr \"base_cost\" \"0\")])\n+\n+;; Four word compare\n+(define_insn \"cmpdi\"\n+  [(set (reg:CC CC_REGNUM)\n+\t(compare:CC (match_operand:DI 0 \"general_operand\" \"rDQi\")\n+\t\t    (match_operand:DI 1 \"general_operand\" \"rDQi\")))]\n+  \"\"\n+{\n+  rtx inops[4];\n+  rtx exops[4][2];\n+  rtx lb[1];\n+  int i;\n+  \n+  inops[0] = operands[0];\n+  inops[1] = operands[1];\n+  pdp11_expand_operands (inops, exops, 2, 4, NULL, big);\n+  lb[0] = gen_label_rtx ();\n+\n+  for (i = 0; i < 3; i++)\n+    {\n+      if (CONST_INT_P (exops[i][1]) && INTVAL (exops[i][1]) == 0)\n+        output_asm_insn (\"tst\\t%0\", exops[i]);\n+      else\n+        output_asm_insn (\"cmp\\t%0,%1\", exops[i]);\n+       output_asm_insn (\"bne\\t%l0\", lb);\n+     }\n+  if (CONST_INT_P (exops[3][1]) && INTVAL (exops[3][1]) == 0)\n+   output_asm_insn (\"tst\\t%0\", exops[3]);\n+  else\n+   output_asm_insn (\"cmp\\t%0,%1\", exops[3]);\n+  output_asm_label (lb[0]);\n+   fputs (\":\\n\", asm_out_file);\n+\n+  return \"\";\n+}\n+  [(set (attr \"length\")\n+\t(symbol_ref \"pdp11_cmp_length (operands, 2)\"))\n+   (set_attr \"base_cost\" \"0\")])\n+\n ;; sob instruction\n ;;\n ;; This expander has to check for mode match because the doloop pass\n@@ -368,8 +435,8 @@\n (define_insn_and_split \"cbranch<mode>4\"\n   [(set (pc)\n \t(if_then_else (match_operator 0 \"ordered_comparison_operator\"\n-\t\t       [(match_operand:PDPint 1 \"general_operand\" \"g\")\n-\t\t\t(match_operand:PDPint 2 \"general_operand\" \"g\")])\n+\t\t       [(match_operand:QHSDint 1 \"general_operand\" \"g\")\n+\t\t\t(match_operand:QHSDint 2 \"general_operand\" \"g\")])\n \t\t      (label_ref (match_operand 3 \"\" \"\"))\n \t\t      (pc)))]\n   \"\"\n@@ -473,12 +540,19 @@\n   \"* return output_move_multiple (operands);\"\n   [(set_attr \"length\" \"4,6,8,16\")])\n \n+;; That long string of \"Z\" constraints enforces the restriction that\n+;; a register source and auto increment or decrement destination must\n+;; not use the same register, because that case is not consistently\n+;; implemented across the PDP11 models.\n+;; TODO: the same should be applied to insn like add, but this is not\n+;; necessary yet because the incdec optimization pass does not apply\n+;; that optimization to 3-operand insns at the moment.\n (define_insn \"mov<mode>\"\n-  [(set (match_operand:PDPint 0 \"nonimmediate_operand\" \"=rR,rR,Q,Q\")\n-\t(match_operand:PDPint 1 \"general_operand\" \"rRN,Qi,rRN,Qi\"))]\n+  [(set (match_operand:PDPint 0 \"nonimmediate_operand\" \"=rR,Za,Zb,Zc,Zd,Ze,Zf,Zg,rD,rR,Q,Q\")\n+\t(match_operand:PDPint 1 \"general_operand\" \"RN,Z0,Z1,Z2,Z3,Z4,Z5,Z6,r,Qi,rRN,Qi\"))]\n   \"\"\n   \"\"\n-  [(set_attr \"length\" \"2,4,4,6\")])\n+  [(set_attr \"length\" \"2,2,2,2,2,2,2,2,2,4,4,6\")])\n \n ;; This splits all the integer moves: DI and SI modes as well as\n ;; the simple machine operations.\n@@ -493,8 +567,8 @@\n   \n ;; MOV clears V\n (define_insn \"*mov<mode>_<cc_cc>\"\n-  [(set (match_operand:PDPint 0 \"nonimmediate_operand\" \"=rR,rR,Q,Q\")\n-\t(match_operand:PDPint 1 \"general_operand\" \"rRN,Qi,rRN,Qi\"))\n+  [(set (match_operand:PDPint 0 \"nonimmediate_operand\" \"=rR,Za,Zb,Zc,Zd,Ze,Zf,Zg,rD,rR,Q,Q\")\n+\t(match_operand:PDPint 1 \"general_operand\" \"RN,Z0,Z1,Z2,Z3,Z4,Z5,Z6,r,Qi,rRN,Qi\"))\n    (clobber (reg:CC CC_REGNUM))]\n   \"reload_completed\"\n   \"*\n@@ -504,7 +578,7 @@\n \n   return \\\"mov<PDPint:isfx>\\t%1,%0\\\";\n }\"\n-  [(set_attr \"length\" \"2,4,4,6\")])\n+  [(set_attr \"length\" \"2,2,2,2,2,2,2,2,2,4,4,6\")])\n \n ;; movdf has unusually complicated condition code handling, because\n ;; load (into float register) updates the FCC, while store (from\n@@ -591,18 +665,98 @@\n \n ;; Expand a block move.  We turn this into a move loop.\n (define_expand \"movmemhi\"\n-  [(match_operand:BLK 0 \"general_operand\" \"=g\")\n-   (match_operand:BLK 1 \"general_operand\" \"g\")\n-   (match_operand:HI 2 \"immediate_operand\" \"i\")\n-   (match_operand:HI 3 \"immediate_operand\" \"i\")]\n+  [(parallel [(unspec_volatile [(const_int 0)] UNSPECV_MOVMEM)\n+\t      (match_operand:BLK 0 \"general_operand\" \"=g\")\n+\t      (match_operand:BLK 1 \"general_operand\" \"g\")\n+\t      (match_operand:HI 2 \"immediate_operand\" \"i\")\n+\t      (match_operand:HI 3 \"immediate_operand\" \"i\")\n+\t      (clobber (mem:BLK (scratch)))\n+\t      (clobber (match_dup 0))\n+\t      (clobber (match_dup 1))\n+\t      (clobber (match_dup 2))])]\n   \"\"\n   \"\n {\n-  if (INTVAL (operands[2]) != 0)\n-    expand_block_move (operands);\n-  DONE;\n+  int count;\n+  count = INTVAL (operands[2]);\n+  if (count == 0)\n+    DONE;\n+  if (INTVAL (operands [3]) >= 2 && (count & 1) == 0)\n+    count >>= 1;\n+  else\n+    operands[3] = const1_rtx;\n+  operands[2] = copy_to_mode_reg (HImode,\n+                                  gen_rtx_CONST_INT (HImode, count));\n+\n+  /* Load BLKmode MEM addresses into scratch registers.  */\n+  operands[0] = copy_to_mode_reg (Pmode, XEXP (operands[0], 0));\n+  operands[1] = copy_to_mode_reg (Pmode, XEXP (operands[1], 0));\n }\")\n \n+;; Expand a block move.  We turn this into a move loop.\n+(define_insn_and_split \"movmemhi1\"\n+  [(unspec_volatile [(const_int 0)] UNSPECV_MOVMEM)\n+   (match_operand:HI 0 \"register_operand\" \"+r\")\n+   (match_operand:HI 1 \"register_operand\" \"+r\")\n+   (match_operand:HI 2 \"register_operand\" \"+r\")\n+   (match_operand:HI 3 \"immediate_operand\" \"i\")\n+   (clobber (mem:BLK (scratch)))\n+   (clobber (match_dup 0))\n+   (clobber (match_dup 1))\n+   (clobber (match_dup 2))]\n+  \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel [(unspec_volatile [(const_int 0)] UNSPECV_MOVMEM)\n+\t      (match_dup 0)\n+\t      (match_dup 1)\n+\t      (match_dup 2)\n+\t      (match_dup 3)\n+\t      (clobber (mem:BLK (scratch)))\n+\t      (clobber (match_dup 0))\n+\t      (clobber (match_dup 1))\n+\t      (clobber (match_dup 2))\n+\t      (clobber (reg:CC CC_REGNUM))])]\n+  \"\")\n+\n+(define_insn \"movmemhi_nocc\"\n+  [(unspec_volatile [(const_int 0)] UNSPECV_MOVMEM)\n+   (match_operand:HI 0 \"register_operand\" \"+r\")\n+   (match_operand:HI 1 \"register_operand\" \"+r\")\n+   (match_operand:HI 2 \"register_operand\" \"+r\")\n+   (match_operand:HI 3 \"immediate_operand\" \"i\")\n+   (clobber (mem:BLK (scratch)))\n+   (clobber (match_dup 0))\n+   (clobber (match_dup 1))\n+   (clobber (match_dup 2))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"reload_completed\"\n+  \"*\n+{\n+  rtx lb[2];\n+  \n+  lb[0] = operands[2];\n+  lb[1] = gen_label_rtx ();\n+  \n+  output_asm_label (lb[1]);\n+  fputs (\\\":\\n\\\", asm_out_file);\n+  if (INTVAL (operands[3]) > 1)\n+    output_asm_insn (\\\"mov\\t(%1)+,(%0)+\\\", operands);\n+  else\n+    output_asm_insn (\\\"movb\\t(%1)+,(%0)+\\\", operands);\n+  if (TARGET_40_PLUS)\n+    output_asm_insn (\\\"sob\\t%0,%l1\\\", lb);\n+  else\n+    {\n+      output_asm_insn (\\\"dec\\t%0\\\", lb);\n+      output_asm_insn (\\\"bne\\t%l1\\\", lb);\n+    }\n+  return \\\"\\\";\n+}\"\n+  [(set (attr \"length\")\n+\t(if_then_else (match_test \"TARGET_40_PLUS\")\n+\t\t      (const_int 4)\n+\t\t      (const_int 6)))])\n \f\n ;;- truncation instructions\n \n@@ -659,7 +813,8 @@\n         emit_move_insn (r, const0_rtx);\n         DONE;\n       }\n-    else if (!rtx_equal_p (operands[0], operands[1]))\n+    else if (!REG_P (operands[1]) ||\n+             REGNO (operands[0]) != REGNO (operands[1]))\n       {\n         /* Alternatives 2 and 3 */\n         emit_move_insn (operands[0], const0_rtx);\n@@ -975,22 +1130,22 @@\n   \n   inops[0] = operands[0];\n   inops[1] = operands[2];\n-  pdp11_expand_operands (inops, exops, 2, NULL, either);\n+  pdp11_expand_operands (inops, exops, 2, 4, NULL, big);\n   \n-  if (!CONSTANT_P (exops[0][1]) || INTVAL (exops[0][1]) != 0)\n+  if (!CONST_INT_P (exops[0][1]) || INTVAL (exops[0][1]) != 0)\n     output_asm_insn (\\\"add\\t%1,%0\\\", exops[0]);\n-  if (!CONSTANT_P (exops[1][1]) || INTVAL (exops[1][1]) != 0)\n+  if (!CONST_INT_P (exops[1][1]) || INTVAL (exops[1][1]) != 0)\n   {\n     output_asm_insn (\\\"add\\t%1,%0\\\", exops[1]);\n     output_asm_insn (\\\"adc\\t%0\\\", exops[0]);\n   }\n-  if (!CONSTANT_P (exops[2][1]) || INTVAL (exops[2][1]) != 0)\n+  if (!CONST_INT_P (exops[2][1]) || INTVAL (exops[2][1]) != 0)\n   {\n     output_asm_insn (\\\"add\\t%1,%0\\\", exops[2]);\n     output_asm_insn (\\\"adc\\t%0\\\", exops[1]);\n     output_asm_insn (\\\"adc\\t%0\\\", exops[0]);\n   }\n-  if (!CONSTANT_P (exops[3][1]) || INTVAL (exops[3][1]) != 0)\n+  if (!CONST_INT_P (exops[3][1]) || INTVAL (exops[3][1]) != 0)\n   {\n     output_asm_insn (\\\"add\\t%1,%0\\\", exops[3]);\n     output_asm_insn (\\\"adc\\t%0\\\", exops[2]);\n@@ -1037,11 +1192,11 @@\n   \n   inops[0] = operands[0];\n   inops[1] = operands[2];\n-  pdp11_expand_operands (inops, exops, 2, NULL, either);\n+  pdp11_expand_operands (inops, exops, 2, 2, NULL, big);\n   \n-  if (!CONSTANT_P (exops[0][1]) || INTVAL (exops[0][1]) != 0)\n+  if (!CONST_INT_P (exops[0][1]) || INTVAL (exops[0][1]) != 0)\n     output_asm_insn (\\\"add\\t%1,%0\\\", exops[0]);\n-  if (!CONSTANT_P (exops[1][1]) || INTVAL (exops[1][1]) != 0)\n+  if (!CONST_INT_P (exops[1][1]) || INTVAL (exops[1][1]) != 0)\n   {\n     output_asm_insn (\\\"add\\t%1,%0\\\", exops[1]);\n     output_asm_insn (\\\"adc\\t%0\\\", exops[0]);\n@@ -1169,22 +1324,22 @@\n   \n   inops[0] = operands[0];\n   inops[1] = operands[2];\n-  pdp11_expand_operands (inops, exops, 2, NULL, either);\n+  pdp11_expand_operands (inops, exops, 2, 4, NULL, big);\n   \n-  if (!CONSTANT_P (exops[0][1]) || INTVAL (exops[0][1]) != 0)\n+  if (!CONST_INT_P (exops[0][1]) || INTVAL (exops[0][1]) != 0)\n     output_asm_insn (\\\"sub\\t%1,%0\\\", exops[0]);\n-  if (!CONSTANT_P (exops[1][1]) || INTVAL (exops[1][1]) != 0)\n+  if (!CONST_INT_P (exops[1][1]) || INTVAL (exops[1][1]) != 0)\n   {\n     output_asm_insn (\\\"sub\\t%1,%0\\\", exops[1]);\n     output_asm_insn (\\\"sbc\\t%0\\\", exops[0]);\n   }\n-  if (!CONSTANT_P (exops[2][1]) || INTVAL (exops[2][1]) != 0)\n+  if (!CONST_INT_P (exops[2][1]) || INTVAL (exops[2][1]) != 0)\n   {\n     output_asm_insn (\\\"sub\\t%1,%0\\\", exops[2]);\n     output_asm_insn (\\\"sbc\\t%0\\\", exops[1]);\n     output_asm_insn (\\\"sbc\\t%0\\\", exops[0]);\n   }\n-  if (!CONSTANT_P (exops[3][1]) || INTVAL (exops[3][1]) != 0)\n+  if (!CONST_INT_P (exops[3][1]) || INTVAL (exops[3][1]) != 0)\n   {\n     output_asm_insn (\\\"sub\\t%1,%0\\\", exops[3]);\n     output_asm_insn (\\\"sbc\\t%0\\\", exops[2]);\n@@ -1222,11 +1377,11 @@\n   \n   inops[0] = operands[0];\n   inops[1] = operands[2];\n-  pdp11_expand_operands (inops, exops, 2, NULL, either);\n+  pdp11_expand_operands (inops, exops, 2, 2, NULL, big);\n   \n-  if (!CONSTANT_P (exops[0][1]) || INTVAL (exops[0][1]) != 0)\n+  if (!CONST_INT_P (exops[0][1]) || INTVAL (exops[0][1]) != 0)\n     output_asm_insn (\\\"sub\\t%1,%0\\\", exops[0]);\n-  if (!CONSTANT_P (exops[1][1]) || INTVAL (exops[1][1]) != 0)\n+  if (!CONST_INT_P (exops[1][1]) || INTVAL (exops[1][1]) != 0)\n   {\n     output_asm_insn (\\\"sub\\t%1,%0\\\", exops[1]);\n     output_asm_insn (\\\"sbc\\t%0\\\", exops[0]);\n@@ -1702,9 +1857,11 @@\n    (clobber (reg:CC CC_REGNUM))]\n   \"reload_completed\"\n   {\n+    rtx inops[2];\n     rtx exops[4][2];\n-    \n-    pdp11_expand_operands (operands, exops, 1, NULL, either);\n+\n+    inops[0] = operands[0];\n+    pdp11_expand_operands (inops, exops, 1, 4, NULL, big);\n   \n     output_asm_insn (\\\"com\\t%0\\\", exops[3]);\n     output_asm_insn (\\\"com\\t%0\\\", exops[2]);\n@@ -1738,9 +1895,11 @@\n    (clobber (reg:CC CC_REGNUM))]\n   \"reload_completed\"\n   {\n-    rtx exops[2][2];\n-    \n-    pdp11_expand_operands (operands, exops, 1, NULL, either);\n+    rtx inops[2];\n+    rtx exops[4][2];\n+\n+    inops[0] = operands[0];\n+    pdp11_expand_operands (inops, exops, 1, 2, NULL, big);\n   \n     output_asm_insn (\\\"com\\t%0\\\", exops[1]);\n     output_asm_insn (\\\"com\\t%0\\\", exops[0]);\n@@ -2046,10 +2205,13 @@\n    (clobber (reg:CC CC_REGNUM))]\n   \"\"\n   {\n+    rtx inops[2];\n     rtx exops[2][2];\n     rtx t;\n-  \n-    pdp11_expand_operands (operands, exops, 2, NULL, either);\n+\n+    inops[0] = operands[0];\n+    inops[1] = operands[1];\n+    pdp11_expand_operands (inops, exops, 2, 2, NULL, either);\n \n     t = exops[0][0];\n     exops[0][0] = exops[1][0];"}, {"sha": "79fca28b665cd015d0b766e0e71d830e87edf95c", "filename": "gcc/config/pdp11/pdp11.opt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/442fcea74d0c7797fc083fa7e5543268c0ff54a6/gcc%2Fconfig%2Fpdp11%2Fpdp11.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/442fcea74d0c7797fc083fa7e5543268c0ff54a6/gcc%2Fconfig%2Fpdp11%2Fpdp11.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11.opt?ref=442fcea74d0c7797fc083fa7e5543268c0ff54a6", "patch": "@@ -68,4 +68,4 @@ Use UNIX assembler syntax.\n \n mlra\n Target Report Mask(LRA)\n-Use LRA register allocator\n+Use LRA register allocator."}, {"sha": "467d2284b202cf208c3407df6644dfce4ae15e8b", "filename": "gcc/config/pdp11/t-pdp11", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/442fcea74d0c7797fc083fa7e5543268c0ff54a6/gcc%2Fconfig%2Fpdp11%2Ft-pdp11", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/442fcea74d0c7797fc083fa7e5543268c0ff54a6/gcc%2Fconfig%2Fpdp11%2Ft-pdp11", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Ft-pdp11?ref=442fcea74d0c7797fc083fa7e5543268c0ff54a6", "patch": "@@ -18,6 +18,10 @@\n \n MULTILIB_OPTIONS = msoft-float\n \n+# Optimize for space\n+LIBGCC2_CFLAGS = -Os\n+CRTSTUFF_T_CFLAGS = -Os\n+\n # Because the pdp11 POINTER_SIZE is only 16, in dwarf2out.c,\n # DWARF_ARANGES_PAD_SIZE is 0, thus a loop in output_aranges that checks\n # (i < (unsigned) DWARF_ARANGES_PAD_SIZE) elicits a warning that the"}]}