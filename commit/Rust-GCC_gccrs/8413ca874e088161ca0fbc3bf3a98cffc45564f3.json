{"sha": "8413ca874e088161ca0fbc3bf3a98cffc45564f3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODQxM2NhODc0ZTA4ODE2MWNhMGZiYzNiZjNhOThjZmZjNDU1NjRmMw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2014-11-14T17:46:50Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2014-11-14T17:46:50Z"}, "message": "ipa-pure-const.c (struct funct_state_d): Add can_free field.\n\n\t* ipa-pure-const.c (struct funct_state_d): Add can_free field.\n\t(varying_state): Add true for can_free.\n\t(check_call): For builtin or internal !nonfreeing_call_p set\n\tlocal->can_free.\n\t(check_stmt): For asm volatile and asm with \"memory\" set\n\tlocal->can_free.\n\t(analyze_function): Clear local->can_free initially, continue\n\tcalling check_stmt until all flags are computed, dump can_free\n\tflag.\n\t(pure_const_write_summary): Write can_free flag.\n\t(pure_const_read_summary): Read it back.\n\t(propagate_pure_const): Propagate also can_free flag, set\n\tw->nonfreeing_fn if it is false after propagation.\n\t* cgraph.h (cgraph_node): Add nonfreeing_fn member.\n\t* gimple.c: Include ipa-ref.h, lto-streamer.h and cgraph.h.\n\t(nonfreeing_call_p): Return cgraph nonfreeing_fn flag if set.\n\tAlso return true for IFN_ABNORMAL_DISPATCHER.\n\t* cgraph.c (cgraph_node::dump): Dump nonfreeing_fn flag.\n\t* lto-cgraph.c (lto_output_node): Write nonfreeing_fn flag.\n\t(input_overwrite_node): Read it back.\n\nFrom-SVN: r217582", "tree": {"sha": "a5f3f2ac60cf67edecc73331df1bbb55654423a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a5f3f2ac60cf67edecc73331df1bbb55654423a3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8413ca874e088161ca0fbc3bf3a98cffc45564f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8413ca874e088161ca0fbc3bf3a98cffc45564f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8413ca874e088161ca0fbc3bf3a98cffc45564f3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8413ca874e088161ca0fbc3bf3a98cffc45564f3/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ab9a4330370dccbb9559c4edf032f49e925e951c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab9a4330370dccbb9559c4edf032f49e925e951c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab9a4330370dccbb9559c4edf032f49e925e951c"}], "stats": {"total": 120, "additions": 113, "deletions": 7}, "files": [{"sha": "c5ea481145833550affbc4814600803d9c95518d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8413ca874e088161ca0fbc3bf3a98cffc45564f3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8413ca874e088161ca0fbc3bf3a98cffc45564f3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8413ca874e088161ca0fbc3bf3a98cffc45564f3", "patch": "@@ -1,3 +1,26 @@\n+2014-11-14  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* ipa-pure-const.c (struct funct_state_d): Add can_free field.\n+\t(varying_state): Add true for can_free.\n+\t(check_call): For builtin or internal !nonfreeing_call_p set\n+\tlocal->can_free.\n+\t(check_stmt): For asm volatile and asm with \"memory\" set\n+\tlocal->can_free.\n+\t(analyze_function): Clear local->can_free initially, continue\n+\tcalling check_stmt until all flags are computed, dump can_free\n+\tflag.\n+\t(pure_const_write_summary): Write can_free flag.\n+\t(pure_const_read_summary): Read it back.\n+\t(propagate_pure_const): Propagate also can_free flag, set\n+\tw->nonfreeing_fn if it is false after propagation.\n+\t* cgraph.h (cgraph_node): Add nonfreeing_fn member.\n+\t* gimple.c: Include ipa-ref.h, lto-streamer.h and cgraph.h.\n+\t(nonfreeing_call_p): Return cgraph nonfreeing_fn flag if set.\n+\tAlso return true for IFN_ABNORMAL_DISPATCHER.\n+\t* cgraph.c (cgraph_node::dump): Dump nonfreeing_fn flag.\n+\t* lto-cgraph.c (lto_output_node): Write nonfreeing_fn flag.\n+\t(input_overwrite_node): Read it back.\n+\n 2014-11-14  Jakub Jelinek  <jakub@redhat.com>\n \t    Marek Polacek  <polacek@redhat.com>\n "}, {"sha": "a66c9c0ea75dcb4eac0d792bb12a82e29431f084", "filename": "gcc/cgraph.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8413ca874e088161ca0fbc3bf3a98cffc45564f3/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8413ca874e088161ca0fbc3bf3a98cffc45564f3/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=8413ca874e088161ca0fbc3bf3a98cffc45564f3", "patch": "@@ -1995,6 +1995,8 @@ cgraph_node::dump (FILE *f)\n     fprintf (f, \" tm_clone\");\n   if (icf_merged)\n     fprintf (f, \" icf_merged\");\n+  if (nonfreeing_fn)\n+    fprintf (f, \" nonfreeing_fn\");\n   if (DECL_STATIC_CONSTRUCTOR (decl))\n     fprintf (f,\" static_constructor (priority:%i)\", get_init_priority ());\n   if (DECL_STATIC_DESTRUCTOR (decl))"}, {"sha": "e9a14c4d49270c7c811ee57204396f41d37894a0", "filename": "gcc/cgraph.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8413ca874e088161ca0fbc3bf3a98cffc45564f3/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8413ca874e088161ca0fbc3bf3a98cffc45564f3/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=8413ca874e088161ca0fbc3bf3a98cffc45564f3", "patch": "@@ -1267,6 +1267,10 @@ struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node {\n   /* True when function is clone created for Pointer Bounds Checker\n      instrumentation.  */\n   unsigned instrumentation_clone : 1;\n+  /* True if call to node can't result in a call to free, munmap or\n+     other operation that could make previously non-trapping memory\n+     accesses trapping.  */\n+  unsigned nonfreeing_fn : 1;\n };\n \n /* A cgraph node set is a collection of cgraph nodes.  A cgraph node"}, {"sha": "f8459a448cb989b8ba7b541b9888e50f6c426bd5", "filename": "gcc/gimple.c", "status": "modified", "additions": 24, "deletions": 4, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8413ca874e088161ca0fbc3bf3a98cffc45564f3/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8413ca874e088161ca0fbc3bf3a98cffc45564f3/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=8413ca874e088161ca0fbc3bf3a98cffc45564f3", "patch": "@@ -58,6 +58,9 @@ along with GCC; see the file COPYING3.  If not see\n #include \"bitmap.h\"\n #include \"stringpool.h\"\n #include \"tree-ssanames.h\"\n+#include \"ipa-ref.h\"\n+#include \"lto-streamer.h\"\n+#include \"cgraph.h\"\n \n \n /* All the tuples have their operand vector (if present) at the very bottom\n@@ -2538,11 +2541,28 @@ nonfreeing_call_p (gimple call)\n \tdefault:\n \t  return true;\n       }\n-  else if (gimple_call_internal_p (call)\n-\t   && gimple_call_flags (call) & ECF_LEAF)\n-    return true;\n+  else if (gimple_call_internal_p (call))\n+    switch (gimple_call_internal_fn (call))\n+      {\n+      case IFN_ABNORMAL_DISPATCHER:\n+        return true;\n+      default:\n+\tif (gimple_call_flags (call) & ECF_LEAF)\n+\t  return true;\n+\treturn false;\n+      }\n \n-  return false;\n+  tree fndecl = gimple_call_fndecl (call);\n+  if (!fndecl)\n+    return false;\n+  struct cgraph_node *n = cgraph_node::get (fndecl);\n+  if (!n)\n+    return false;\n+  enum availability availability;\n+  n = n->function_symbol (&availability);\n+  if (!n || availability <= AVAIL_INTERPOSABLE)\n+    return false;\n+  return n->nonfreeing_fn;\n }\n \n /* Callback for walk_stmt_load_store_ops."}, {"sha": "a55288d7ba4301f0525f4509a7d715f45c000778", "filename": "gcc/ipa-pure-const.c", "status": "modified", "additions": 58, "deletions": 3, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8413ca874e088161ca0fbc3bf3a98cffc45564f3/gcc%2Fipa-pure-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8413ca874e088161ca0fbc3bf3a98cffc45564f3/gcc%2Fipa-pure-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-pure-const.c?ref=8413ca874e088161ca0fbc3bf3a98cffc45564f3", "patch": "@@ -112,11 +112,15 @@ struct funct_state_d\n   bool looping;\n \n   bool can_throw;\n+\n+  /* If function can call free, munmap or otherwise make previously\n+     non-trapping memory accesses trapping.  */\n+  bool can_free;\n };\n \n /* State used when we know nothing about function.  */\n static struct funct_state_d varying_state\n-   = { IPA_NEITHER, IPA_NEITHER, true, true, true };\n+   = { IPA_NEITHER, IPA_NEITHER, true, true, true, true };\n \n \n typedef struct funct_state_d * funct_state;\n@@ -559,6 +563,10 @@ check_call (funct_state local, gimple call, bool ipa)\n       enum pure_const_state_e call_state;\n       bool call_looping;\n \n+      if (gimple_call_builtin_p (call, BUILT_IN_NORMAL)\n+\t  && !nonfreeing_call_p (call))\n+\tlocal->can_free = true;\n+\n       if (special_builtin_state (&call_state, &call_looping, callee_t))\n \t{\n \t  worse_state (&local->pure_const_state, &local->looping,\n@@ -589,6 +597,8 @@ check_call (funct_state local, gimple call, bool ipa)\n \t    break;\n \t  }\n     }\n+  else if (gimple_call_internal_p (call) && !nonfreeing_call_p (call))\n+    local->can_free = true;\n \n   /* When not in IPA mode, we can still handle self recursion.  */\n   if (!ipa && callee_t\n@@ -753,14 +763,16 @@ check_stmt (gimple_stmt_iterator *gsip, funct_state local, bool ipa)\n \t    fprintf (dump_file, \"    memory asm clobber is not const/pure\\n\");\n \t  /* Abandon all hope, ye who enter here. */\n \t  local->pure_const_state = IPA_NEITHER;\n+\t  local->can_free = true;\n \t}\n       if (gimple_asm_volatile_p (stmt))\n \t{\n \t  if (dump_file)\n \t    fprintf (dump_file, \"    volatile is not const/pure\\n\");\n \t  /* Abandon all hope, ye who enter here. */\n \t  local->pure_const_state = IPA_NEITHER;\n-          local->looping = true;\n+\t  local->looping = true;\n+\t  local->can_free = true;\n \t}\n       return;\n     default:\n@@ -785,6 +797,7 @@ analyze_function (struct cgraph_node *fn, bool ipa)\n   l->looping_previously_known = true;\n   l->looping = false;\n   l->can_throw = false;\n+  l->can_free = false;\n   state_from_flags (&l->state_previously_known, &l->looping_previously_known,\n \t\t    flags_from_decl_or_type (fn->decl),\n \t\t    fn->cannot_return_p ());\n@@ -815,7 +828,10 @@ analyze_function (struct cgraph_node *fn, bool ipa)\n \t   gsi_next (&gsi))\n \t{\n \t  check_stmt (&gsi, l, ipa);\n-\t  if (l->pure_const_state == IPA_NEITHER && l->looping && l->can_throw)\n+\t  if (l->pure_const_state == IPA_NEITHER\n+\t      && l->looping\n+\t      && l->can_throw\n+\t      && l->can_free)\n \t    goto end;\n \t}\n     }\n@@ -882,6 +898,8 @@ analyze_function (struct cgraph_node *fn, bool ipa)\n         fprintf (dump_file, \"Function is locally const.\\n\");\n       if (l->pure_const_state == IPA_PURE)\n         fprintf (dump_file, \"Function is locally pure.\\n\");\n+      if (l->can_free)\n+\tfprintf (dump_file, \"Function can locally free.\\n\");\n     }\n   return l;\n }\n@@ -1021,6 +1039,7 @@ pure_const_write_summary (void)\n \t  bp_pack_value (&bp, fs->looping_previously_known, 1);\n \t  bp_pack_value (&bp, fs->looping, 1);\n \t  bp_pack_value (&bp, fs->can_throw, 1);\n+\t  bp_pack_value (&bp, fs->can_free, 1);\n \t  streamer_write_bitpack (&bp);\n \t}\n     }\n@@ -1080,6 +1099,7 @@ pure_const_read_summary (void)\n \t      fs->looping_previously_known = bp_unpack_value (&bp, 1);\n \t      fs->looping = bp_unpack_value (&bp, 1);\n \t      fs->can_throw = bp_unpack_value (&bp, 1);\n+\t      fs->can_free = bp_unpack_value (&bp, 1);\n \t      if (dump_file)\n \t\t{\n \t\t  int flags = flags_from_decl_or_type (node->decl);\n@@ -1102,6 +1122,8 @@ pure_const_read_summary (void)\n \t\t    fprintf (dump_file,\"  function is previously known looping\\n\");\n \t\t  if (fs->can_throw)\n \t\t    fprintf (dump_file,\"  function is locally throwing\\n\");\n+\t\t  if (fs->can_free)\n+\t\t    fprintf (dump_file,\"  function can locally free\\n\");\n \t\t}\n \t    }\n \n@@ -1347,6 +1369,33 @@ propagate_pure_const (void)\n \t\t pure_const_names [pure_const_state],\n \t\t looping);\n \n+      /* Find the worst state of can_free for any node in the cycle.  */\n+      bool can_free = false;\n+      w = node;\n+      while (w && !can_free)\n+\t{\n+\t  struct cgraph_edge *e;\n+\t  funct_state w_l = get_function_state (w);\n+\n+\t  if (w_l->can_free\n+\t      || w->get_availability () == AVAIL_INTERPOSABLE\n+\t      || w->indirect_calls)\n+\t    can_free = true;\n+\n+\t  for (e = w->callees; e && !can_free; e = e->next_callee)\n+\t    {\n+\t      enum availability avail;\n+\t      struct cgraph_node *y = e->callee->function_symbol (&avail);\n+\n+\t      if (avail > AVAIL_INTERPOSABLE)\n+\t\tcan_free = get_function_state (y)->can_free;\n+\t      else\n+\t\tcan_free = true;\n+\t    }\n+\t  w_info = (struct ipa_dfs_info *) w->aux;\n+\t  w = w_info->next_cycle;\n+\t}\n+\n       /* Copy back the region's pure_const_state which is shared by\n \t all nodes in the region.  */\n       w = node;\n@@ -1356,6 +1405,12 @@ propagate_pure_const (void)\n \t  enum pure_const_state_e this_state = pure_const_state;\n \t  bool this_looping = looping;\n \n+\t  w_l->can_free = can_free;\n+\t  w->nonfreeing_fn = !can_free;\n+\t  if (!can_free && dump_file)\n+\t    fprintf (dump_file, \"Function found not to call free: %s\\n\",\n+\t\t     w->name ());\n+\n \t  if (w_l->state_previously_known != IPA_NEITHER\n \t      && this_state > w_l->state_previously_known)\n \t    {"}, {"sha": "3ce2367a3bfe8bf88d1f4ca5e684ec31e699f23d", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8413ca874e088161ca0fbc3bf3a98cffc45564f3/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8413ca874e088161ca0fbc3bf3a98cffc45564f3/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=8413ca874e088161ca0fbc3bf3a98cffc45564f3", "patch": "@@ -562,6 +562,7 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n   bp_pack_value (&bp, node->tm_clone, 1);\n   bp_pack_value (&bp, node->calls_comdat_local, 1);\n   bp_pack_value (&bp, node->icf_merged, 1);\n+  bp_pack_value (&bp, node->nonfreeing_fn, 1);\n   bp_pack_value (&bp, node->thunk.thunk_p && !boundary_p, 1);\n   bp_pack_enum (&bp, ld_plugin_symbol_resolution,\n \t        LDPR_NUM_KNOWN, node->resolution);\n@@ -1168,6 +1169,7 @@ input_overwrite_node (struct lto_file_decl_data *file_data,\n   node->tm_clone = bp_unpack_value (bp, 1);\n   node->calls_comdat_local = bp_unpack_value (bp, 1);\n   node->icf_merged = bp_unpack_value (bp, 1);\n+  node->nonfreeing_fn = bp_unpack_value (bp, 1);\n   node->thunk.thunk_p = bp_unpack_value (bp, 1);\n   node->resolution = bp_unpack_enum (bp, ld_plugin_symbol_resolution,\n \t\t\t\t     LDPR_NUM_KNOWN);"}]}