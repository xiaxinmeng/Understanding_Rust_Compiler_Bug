{"sha": "0b4b14ac40a7efec44d96074ec0dd0c0e6bd5fc2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGI0YjE0YWM0MGE3ZWZlYzQ0ZDk2MDc0ZWMwZGQwYzBlNmJkNWZjMg==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2010-08-06T11:47:31Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2010-08-06T11:47:31Z"}, "message": "tree-ssa-ccp.c (struct prop_value_d): Add mask member.\n\n2010-08-06  Richard Guenther  <rguenther@suse.de>\n\n\t* tree-ssa-ccp.c (struct prop_value_d): Add mask member.\n\t(dump_lattice_value): Dump it.\n\t(get_default_value): Adjust.\n\t(get_constant_value): Likewise.\n\t(set_value_varying): Likewise.\n\t(set_lattice_value): Make sure to not go up the lattice\n\twith bitwise constant values.\n\t(get_value_for_expr): Handle ADDR_EXPRs.\n\t(value_to_double_int): New function.\n\t(get_value_from_alignment): Likewise.\n\t(do_dbg_cnt): Adjust.\n\t(ccp_lattice_meet): Handle partially constant values.\n\t(bit_value_unop_1): New function.\n\t(bit_value_binop_1): Likewise.\n\t(bit_value_unop): Likewise.\n\t(bit_value_binop): Likewise.\n\t(evaluate_stmt): Track partially constant values if\n\tflag_tree_bit_ccp is set.\n\t(ccp_fold_stmt): Dump if we folded a predicate.\n\t(ccp_visit_stmt): Adjust.\n\t* common.opt (ftree-bit-ccp): New flag.\n\t* doc/invoke.texi (ftree-bit-ccp): Document.\n\t* opts.c (decode_options): Enable bit-CCP at -O1.\n\n\t* gcc.dg/tree-ssa/ssa-dce-3.c: XFAIL.\n\t* gcc.dg/tree-ssa/pr23744.c: Disable CCP.\n\t* gcc.dg/tree-ssa/pr25382.c: Likewise.\n\t* gcc.dg/tree-ssa/ssa-ccp-30.c: New testcase.\n\t* gcc.dg/tree-ssa/ssa-ccp-31.c: Likewise.\n\t* gcc.dg/tree-ssa/ssa-ccp-32.c: Likewise.\n\t* gcc.dg/tree-ssa/ssa-ccp-33.c: Likewise.\n\t* gcc.c-torture/execute/20100805-1.c: Likewise.\n\nFrom-SVN: r162943", "tree": {"sha": "261ce4e80b1aef1ffd602e6ca4a99546e9283728", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/261ce4e80b1aef1ffd602e6ca4a99546e9283728"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0b4b14ac40a7efec44d96074ec0dd0c0e6bd5fc2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b4b14ac40a7efec44d96074ec0dd0c0e6bd5fc2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b4b14ac40a7efec44d96074ec0dd0c0e6bd5fc2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b4b14ac40a7efec44d96074ec0dd0c0e6bd5fc2/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c2653d8fc2c0c59cbb0fa7c9fbcfc5642e0ae4f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2653d8fc2c0c59cbb0fa7c9fbcfc5642e0ae4f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c2653d8fc2c0c59cbb0fa7c9fbcfc5642e0ae4f8"}], "stats": {"total": 942, "additions": 882, "deletions": 60}, "files": [{"sha": "0ed05bd5ad110bac45b2c07acdb07b7c35563bd0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b4b14ac40a7efec44d96074ec0dd0c0e6bd5fc2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b4b14ac40a7efec44d96074ec0dd0c0e6bd5fc2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0b4b14ac40a7efec44d96074ec0dd0c0e6bd5fc2", "patch": "@@ -1,3 +1,29 @@\n+2010-08-06  Richard Guenther  <rguenther@suse.de>\n+\n+\t* tree-ssa-ccp.c (struct prop_value_d): Add mask member.\n+\t(dump_lattice_value): Dump it.\n+\t(get_default_value): Adjust.\n+\t(get_constant_value): Likewise.\n+\t(set_value_varying): Likewise.\n+\t(set_lattice_value): Make sure to not go up the lattice\n+\twith bitwise constant values.\n+\t(get_value_for_expr): Handle ADDR_EXPRs.\n+\t(value_to_double_int): New function.\n+\t(get_value_from_alignment): Likewise.\n+\t(do_dbg_cnt): Adjust.\n+\t(ccp_lattice_meet): Handle partially constant values.\n+\t(bit_value_unop_1): New function.\n+\t(bit_value_binop_1): Likewise.\n+\t(bit_value_unop): Likewise.\n+\t(bit_value_binop): Likewise.\n+\t(evaluate_stmt): Track partially constant values if\n+\tflag_tree_bit_ccp is set.\n+\t(ccp_fold_stmt): Dump if we folded a predicate.\n+\t(ccp_visit_stmt): Adjust.\n+\t* common.opt (ftree-bit-ccp): New flag.\n+\t* doc/invoke.texi (ftree-bit-ccp): Document.\n+\t* opts.c (decode_options): Enable bit-CCP at -O1.\n+\n 2010-08-06  Alan Modra  <amodra@gmail.com>\n \n \t* doc/invoke.texi (RS/6000 and PowerPC Options): Rewrite -mrelocatable"}, {"sha": "1285ff037fb128d82729fc2e8eb488862bdddf08", "filename": "gcc/common.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b4b14ac40a7efec44d96074ec0dd0c0e6bd5fc2/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b4b14ac40a7efec44d96074ec0dd0c0e6bd5fc2/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=0b4b14ac40a7efec44d96074ec0dd0c0e6bd5fc2", "patch": "@@ -1281,6 +1281,10 @@ ftree-ccp\n Common Report Var(flag_tree_ccp) Optimization\n Enable SSA-CCP optimization on trees\n \n+ftree-bit-ccp\n+Common Report Var(flag_tree_bit_ccp) Optimization\n+Enable SSA-BIT-CCP optimization on trees\n+\n ftree-store-ccp\n Common\n Does nothing.  Preserved for backward compatibility."}, {"sha": "edce70381063127c80810ea3c0910eece77faa14", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b4b14ac40a7efec44d96074ec0dd0c0e6bd5fc2/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b4b14ac40a7efec44d96074ec0dd0c0e6bd5fc2/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=0b4b14ac40a7efec44d96074ec0dd0c0e6bd5fc2", "patch": "@@ -380,7 +380,7 @@ Objective-C and Objective-C++ Dialects}.\n -fsel-sched-pipelining -fsel-sched-pipelining-outer-loops @gol\n -fsignaling-nans -fsingle-precision-constant -fsplit-ivs-in-unroller @gol\n -fsplit-wide-types -fstack-protector -fstack-protector-all @gol\n--fstrict-aliasing -fstrict-overflow -fthread-jumps -ftracer @gol\n+-fstrict-aliasing -fstrict-overflow -fthread-jumps -ftracer -ftree-bit-ccp @gol\n -ftree-builtin-call-dce -ftree-ccp -ftree-ch -ftree-copy-prop @gol\n -ftree-copyrename -ftree-dce -ftree-dominator-opts -ftree-dse @gol\n -ftree-forwprop -ftree-fre -ftree-loop-if-convert -ftree-loop-im @gol\n@@ -5848,6 +5848,7 @@ compilation time.\n -fipa-reference @gol\n -fmerge-constants\n -fsplit-wide-types @gol\n+-ftree-bit-ccp @gol\n -ftree-builtin-call-dce @gol\n -ftree-ccp @gol\n -ftree-ch @gol\n@@ -6737,6 +6738,13 @@ Transposing is enabled only if profiling information is available.\n Perform forward store motion  on trees.  This flag is\n enabled by default at @option{-O} and higher.\n \n+@item -ftree-bit-ccp\n+@opindex ftree-bit-ccp\n+Perform sparse conditional bit constant propagation on trees and propagate\n+pointer alignment information.\n+This pass only operates on local scalar variables and is enabled by default\n+at @option{-O} and higher.  It requires that @option{-ftree-ccp} is enabled.\n+\n @item -ftree-ccp\n @opindex ftree-ccp\n Perform sparse conditional constant propagation (CCP) on trees.  This"}, {"sha": "967ad4002787cb4ac64aa70fc59a989091861ab1", "filename": "gcc/opts.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b4b14ac40a7efec44d96074ec0dd0c0e6bd5fc2/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b4b14ac40a7efec44d96074ec0dd0c0e6bd5fc2/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=0b4b14ac40a7efec44d96074ec0dd0c0e6bd5fc2", "patch": "@@ -767,6 +767,7 @@ decode_options (unsigned int argc, const char **argv,\n   flag_merge_constants = opt1;\n   flag_split_wide_types = opt1;\n   flag_tree_ccp = opt1;\n+  flag_tree_bit_ccp = opt1;\n   flag_tree_dce = opt1;\n   flag_tree_dom = opt1;\n   flag_tree_dse = opt1;"}, {"sha": "d2ba094a8f0463a3dd4ae1c2b790efe9400ae153", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b4b14ac40a7efec44d96074ec0dd0c0e6bd5fc2/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b4b14ac40a7efec44d96074ec0dd0c0e6bd5fc2/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0b4b14ac40a7efec44d96074ec0dd0c0e6bd5fc2", "patch": "@@ -1,3 +1,14 @@\n+2010-08-06  Richard Guenther  <rguenther@suse.de>\n+\n+\t* gcc.dg/tree-ssa/ssa-dce-3.c: XFAIL.\n+\t* gcc.dg/tree-ssa/pr23744.c: Disable CCP.\n+\t* gcc.dg/tree-ssa/pr25382.c: Likewise.\n+\t* gcc.dg/tree-ssa/ssa-ccp-30.c: New testcase.\n+\t* gcc.dg/tree-ssa/ssa-ccp-31.c: Likewise.\n+\t* gcc.dg/tree-ssa/ssa-ccp-32.c: Likewise.\n+\t* gcc.dg/tree-ssa/ssa-ccp-33.c: Likewise.\n+\t* gcc.c-torture/execute/20100805-1.c: Likewise.\n+\n 2010-08-05  Martin Jambor  <mjambor@suse.cz>\n \n \tPR testsuite/42855"}, {"sha": "5b476960ed7beef2644a33d5d35bd7479e035395", "filename": "gcc/testsuite/gcc.c-torture/execute/20100805-1.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b4b14ac40a7efec44d96074ec0dd0c0e6bd5fc2/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20100805-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b4b14ac40a7efec44d96074ec0dd0c0e6bd5fc2/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20100805-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20100805-1.c?ref=0b4b14ac40a7efec44d96074ec0dd0c0e6bd5fc2", "patch": "@@ -0,0 +1,15 @@\n+unsigned int foo (unsigned int a, unsigned int b)\n+{\n+  unsigned i;\n+  a = a & 1;\n+  for (i = 0; i < b; ++i)\n+    a = a << 1 | a >> (sizeof (unsigned int) * 8 - 1);\n+  return a;\n+}\n+extern void abort (void);\n+int main()\n+{\n+  if (foo (1, sizeof (unsigned int) * 8 + 1) != 2)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "5381396766391b6d124b1a5d28c36f49f4bfed93", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr23744.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b4b14ac40a7efec44d96074ec0dd0c0e6bd5fc2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr23744.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b4b14ac40a7efec44d96074ec0dd0c0e6bd5fc2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr23744.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr23744.c?ref=0b4b14ac40a7efec44d96074ec0dd0c0e6bd5fc2", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-tree-vrp1\" } */\n+/* { dg-options \"-O2 -fno-tree-ccp -fdump-tree-vrp1\" } */\n \n int g (int i, int j)\n {"}, {"sha": "daff68ee92bd0617672975a77f267d603cc5138e", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr25382.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b4b14ac40a7efec44d96074ec0dd0c0e6bd5fc2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr25382.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b4b14ac40a7efec44d96074ec0dd0c0e6bd5fc2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr25382.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr25382.c?ref=0b4b14ac40a7efec44d96074ec0dd0c0e6bd5fc2", "patch": "@@ -3,7 +3,7 @@\n    Check that VRP now gets ranges from BIT_AND_EXPRs.  */\n \n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-tree-vrp1\" } */\n+/* { dg-options \"-O2 -fno-tree-ccp -fdump-tree-vrp1\" } */\n \n int\n foo (int a)"}, {"sha": "47675ed5d3177eae7b0b715217b6c48c5d707aba", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-ccp-30.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b4b14ac40a7efec44d96074ec0dd0c0e6bd5fc2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ccp-30.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b4b14ac40a7efec44d96074ec0dd0c0e6bd5fc2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ccp-30.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ccp-30.c?ref=0b4b14ac40a7efec44d96074ec0dd0c0e6bd5fc2", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fdump-tree-ccp1\" } */\n+\n+int\n+foo (int a)\n+{\n+  int b = a & 0xff;\n+  if (b > 300)\n+    return 2;\n+  else\n+    return 1;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Folding predicate b_.* > 300 to 0\" 1 \"ccp1\" } } */\n+/* { dg-final { cleanup-tree-dump \"ccp1\" } } */"}, {"sha": "c155e921c78c573a74217a64f29a138da3bdb607", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-ccp-31.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b4b14ac40a7efec44d96074ec0dd0c0e6bd5fc2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ccp-31.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b4b14ac40a7efec44d96074ec0dd0c0e6bd5fc2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ccp-31.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ccp-31.c?ref=0b4b14ac40a7efec44d96074ec0dd0c0e6bd5fc2", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fdump-tree-ccp1\" } */\n+\n+int g (int i, int j)\n+{\n+  int t = 0;\n+  int i1;\n+\n+  if (i == j)\n+    t = 3;\n+  for (i1 = 0; i1 < 10000; i1++) h();\n+  if (t != 5)\n+    return 0;\n+  else\n+    return 1;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Folding predicate.*to 1\" 1 \"ccp1\" } } */\n+/* { dg-final { cleanup-tree-dump \"ccp1\" } } */"}, {"sha": "24a60062c17463793f74e93687743d2aa66ed7ef", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-ccp-32.c", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b4b14ac40a7efec44d96074ec0dd0c0e6bd5fc2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ccp-32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b4b14ac40a7efec44d96074ec0dd0c0e6bd5fc2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ccp-32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ccp-32.c?ref=0b4b14ac40a7efec44d96074ec0dd0c0e6bd5fc2", "patch": "@@ -0,0 +1,58 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O\" } */\n+\n+extern void link_error (void);\n+unsigned int __attribute__((noinline,noclone))\n+test0 (unsigned int a)\n+{\n+  a = a & 1;\n+  a = a << 1 | a >> (sizeof (unsigned int) * 8 - 1);\n+  if (a & 1)\n+    {\n+      a = a | 4;\n+      link_error ();\n+    }\n+  if (a & 4)\n+    link_error ();\n+  return a;\n+}\n+int __attribute__((noinline,noclone))\n+test1 (int a)\n+{\n+  a |= 1;\n+  a = a << (sizeof (int) * 8 - 1);\n+  if (a >= 0)\n+    link_error ();\n+  a = a * 4;\n+  if (a & ~3)\n+    link_error ();\n+  if (a == -1)\n+    link_error ();\n+  return a;\n+}\n+int __attribute__((noinline,noclone))\n+test2 (int a)\n+{\n+  a = a | 0xff;\n+  a = a + 1;\n+  if (a & 0xff)\n+    link_error ();\n+  a = -a;\n+  if (a & 0xff)\n+    link_error ();\n+  a = a - 1;\n+  if (a & 0xff != 0xff)\n+    link_error ();\n+  return a;\n+}\n+extern void abort (void);\n+int main()\n+{\n+  if (test0 (1) != 2)\n+    abort ();\n+  if (test1 (0) != 0)\n+    abort ();\n+  if (test2 (-1) != -1)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "5a890cae69f0be58258598350715660274760cdf", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-ccp-33.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b4b14ac40a7efec44d96074ec0dd0c0e6bd5fc2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ccp-33.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b4b14ac40a7efec44d96074ec0dd0c0e6bd5fc2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ccp-33.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ccp-33.c?ref=0b4b14ac40a7efec44d96074ec0dd0c0e6bd5fc2", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do link } */\n+/* { dg-options \"-O\" } */\n+\n+extern void link_error ();\n+int a[256];\n+void foo(int n)\n+{\n+  int *p;\n+  for (p = a; n != 0; --n, ++p)\n+    ;\n+  if ((__SIZE_TYPE__)p & (sizeof (int) - 1))\n+    link_error ();\n+}\n+int main()\n+{\n+  return 0;\n+}"}, {"sha": "72020aac7f3e91fe4f82da1a5f2e95695a42815c", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-dce-3.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b4b14ac40a7efec44d96074ec0dd0c0e6bd5fc2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dce-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b4b14ac40a7efec44d96074ec0dd0c0e6bd5fc2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dce-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dce-3.c?ref=0b4b14ac40a7efec44d96074ec0dd0c0e6bd5fc2", "patch": "@@ -21,11 +21,15 @@ int main(void)\n   return 0;\n }\n \n+/* We now can prove the infiniteness of the loop during CCP and fail\n+   to eliminate the code inside the infinite loop because we start\n+   by marking the j % 7 condition as useful.  See PR45178.  */\n+\n /* We should eliminate the inner condition, but the loop must be preserved\n    as it is infinite.  Therefore there should be just one phi node (for i):  */\n-/* { dg-final { scan-tree-dump-times \"PHI \" 1 \"cddce1\"} } */\n+/* { dg-final { scan-tree-dump-times \"PHI \" 1 \"cddce1\" { xfail *-*-* } } } */\n \n /* And one if (for the exit condition of the loop):  */\n-/* { dg-final { scan-tree-dump-times \"if \" 1 \"cddce1\"} } */\n+/* { dg-final { scan-tree-dump-times \"if \" 1 \"cddce1\" } } */\n \n /* { dg-final { cleanup-tree-dump \"cddce1\" } } */"}, {"sha": "a01658438213c817953b5b9601c71fe1b34cd70d", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 699, "deletions": 55, "changes": 754, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b4b14ac40a7efec44d96074ec0dd0c0e6bd5fc2/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b4b14ac40a7efec44d96074ec0dd0c0e6bd5fc2/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=0b4b14ac40a7efec44d96074ec0dd0c0e6bd5fc2", "patch": "@@ -150,6 +150,10 @@ struct prop_value_d {\n \n     /* Propagated value.  */\n     tree value;\n+\n+    /* Mask that applies to the propagated value during CCP.  For\n+       X with a CONSTANT lattice value X & ~mask == value & ~mask.  */\n+    double_int mask;\n };\n \n typedef struct prop_value_d prop_value_t;\n@@ -183,7 +187,18 @@ dump_lattice_value (FILE *outf, const char *prefix, prop_value_t val)\n       break;\n     case CONSTANT:\n       fprintf (outf, \"%sCONSTANT \", prefix);\n-      print_generic_expr (outf, val.value, dump_flags);\n+      if (TREE_CODE (val.value) != INTEGER_CST\n+\t  || double_int_zero_p (val.mask))\n+\tprint_generic_expr (outf, val.value, dump_flags);\n+      else\n+\t{\n+\t  double_int cval = double_int_and_not (tree_to_double_int (val.value),\n+\t\t\t\t\t\tval.mask);\n+\t  fprintf (outf, \"%sCONSTANT \" HOST_WIDE_INT_PRINT_DOUBLE_HEX,\n+\t\t   prefix, cval.high, cval.low);\n+\t  fprintf (outf, \" (\" HOST_WIDE_INT_PRINT_DOUBLE_HEX \")\",\n+\t\t   val.mask.high, val.mask.low);\n+\t}\n       break;\n     default:\n       gcc_unreachable ();\n@@ -225,7 +240,7 @@ static prop_value_t\n get_default_value (tree var)\n {\n   tree sym = SSA_NAME_VAR (var);\n-  prop_value_t val = { UNINITIALIZED, NULL_TREE };\n+  prop_value_t val = { UNINITIALIZED, NULL_TREE, { 0, 0 } };\n   gimple stmt;\n \n   stmt = SSA_NAME_DEF_STMT (var);\n@@ -240,7 +255,10 @@ get_default_value (tree var)\n \t  && TREE_CODE (sym) == VAR_DECL)\n \tval.lattice_val = UNDEFINED;\n       else\n-\tval.lattice_val = VARYING;\n+\t{\n+\t  val.lattice_val = VARYING;\n+\t  val.mask = double_int_minus_one;\n+\t}\n     }\n   else if (is_gimple_assign (stmt)\n \t   /* Value-returning GIMPLE_CALL statements assign to\n@@ -266,6 +284,7 @@ get_default_value (tree var)\n     {\n       /* Otherwise, VAR will never take on a constant value.  */\n       val.lattice_val = VARYING;\n+      val.mask = double_int_minus_one;\n     }\n \n   return val;\n@@ -297,7 +316,10 @@ static inline tree\n get_constant_value (tree var)\n {\n   prop_value_t *val = get_value (var);\n-  if (val && val->lattice_val == CONSTANT)\n+  if (val\n+      && val->lattice_val == CONSTANT\n+      && (TREE_CODE (val->value) != INTEGER_CST\n+\t  || double_int_zero_p (val->mask)))\n     return val->value;\n   return NULL_TREE;\n }\n@@ -311,6 +333,7 @@ set_value_varying (tree var)\n \n   val->lattice_val = VARYING;\n   val->value = NULL_TREE;\n+  val->mask = double_int_minus_one;\n }\n \n /* For float types, modify the value of VAL to make ccp work correctly\n@@ -360,6 +383,42 @@ canonicalize_float_value (prop_value_t *val)\n     }\n }\n \n+/* Return whether the lattice transition is valid.  */\n+\n+static bool\n+valid_lattice_transition (prop_value_t old_val, prop_value_t new_val)\n+{\n+  /* Lattice transitions must always be monotonically increasing in\n+     value.  */\n+  if (old_val.lattice_val < new_val.lattice_val)\n+    return true;\n+\n+  if (old_val.lattice_val != new_val.lattice_val)\n+    return false;\n+\n+  if (!old_val.value && !new_val.value)\n+    return true;\n+\n+  /* Now both lattice values are CONSTANT.  */\n+\n+  /* Allow transitioning from &x to &x & ~3.  */\n+  if (TREE_CODE (old_val.value) != INTEGER_CST\n+      && TREE_CODE (new_val.value) == INTEGER_CST)\n+    return true;\n+\n+  /* Bit-lattices have to agree in the still valid bits.  */\n+  if (TREE_CODE (old_val.value) == INTEGER_CST\n+      && TREE_CODE (new_val.value) == INTEGER_CST)\n+    return double_int_equal_p\n+\t\t(double_int_and_not (tree_to_double_int (old_val.value),\n+\t\t\t\t     new_val.mask),\n+\t\t double_int_and_not (tree_to_double_int (new_val.value),\n+\t\t\t\t     new_val.mask));\n+\n+  /* Otherwise constant values have to agree.  */\n+  return operand_equal_p (old_val.value, new_val.value, 0);\n+}\n+\n /* Set the value for variable VAR to NEW_VAL.  Return true if the new\n    value is different from VAR's previous value.  */\n \n@@ -371,17 +430,34 @@ set_lattice_value (tree var, prop_value_t new_val)\n \n   canonicalize_float_value (&new_val);\n \n-  /* Lattice transitions must always be monotonically increasing in\n-     value.  If *OLD_VAL and NEW_VAL are the same, return false to\n-     inform the caller that this was a non-transition.  */\n+  /* We have to be careful to not go up the bitwise lattice\n+     represented by the mask.\n+     ???  This doesn't seem to be the best place to enforce this.  */\n+  if (new_val.lattice_val == CONSTANT\n+      && old_val->lattice_val == CONSTANT\n+      && TREE_CODE (new_val.value) == INTEGER_CST\n+      && TREE_CODE (old_val->value) == INTEGER_CST)\n+    {\n+      double_int diff;\n+      diff = double_int_xor (tree_to_double_int (new_val.value),\n+\t\t\t     tree_to_double_int (old_val->value));\n+      new_val.mask = double_int_ior (new_val.mask,\n+\t\t\t\t     double_int_ior (old_val->mask, diff));\n+    }\n \n-  gcc_assert (old_val->lattice_val < new_val.lattice_val\n-              || (old_val->lattice_val == new_val.lattice_val\n-\t\t  && ((!old_val->value && !new_val.value)\n-\t\t      || operand_equal_p (old_val->value, new_val.value, 0))));\n+  gcc_assert (valid_lattice_transition (*old_val, new_val));\n \n-  if (old_val->lattice_val != new_val.lattice_val)\n+  /* If *OLD_VAL and NEW_VAL are the same, return false to inform the\n+     caller that this was a non-transition.  */\n+  if (old_val->lattice_val != new_val.lattice_val\n+      || (new_val.lattice_val == CONSTANT\n+\t  && TREE_CODE (new_val.value) == INTEGER_CST\n+\t  && (TREE_CODE (old_val->value) != INTEGER_CST\n+\t      || !double_int_equal_p (new_val.mask, old_val->mask))))\n     {\n+      /* ???  We would like to delay creation of INTEGER_CSTs from\n+\t partially constants here.  */\n+\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \t{\n \t  dump_lattice_value (dump_file, \"Lattice value changed to \", new_val);\n@@ -397,31 +473,142 @@ set_lattice_value (tree var, prop_value_t new_val)\n   return false;\n }\n \n-/* Return the value for the tree operand EXPR.  */\n+static prop_value_t get_value_for_expr (tree, bool);\n+static prop_value_t bit_value_binop (enum tree_code, tree, tree, tree);\n+static void bit_value_binop_1 (enum tree_code, tree, double_int *, double_int *,\n+\t\t\t       tree, double_int, double_int,\n+\t\t\t       tree, double_int, double_int);\n+\n+/* Return a double_int that can be used for bitwise simplifications\n+   from VAL.  */\n+\n+static double_int\n+value_to_double_int (prop_value_t val)\n+{\n+  if (val.value\n+      && TREE_CODE (val.value) == INTEGER_CST)\n+    return tree_to_double_int (val.value);\n+  else\n+    return double_int_zero;\n+}\n+\n+/* Return the value for the address expression EXPR based on alignment\n+   information.  */\n \n static prop_value_t\n-get_value_for_expr (tree expr)\n+get_value_from_alignment (tree expr)\n+{\n+  prop_value_t val;\n+  HOST_WIDE_INT bitsize, bitpos;\n+  tree base, offset;\n+  enum machine_mode mode;\n+  int align;\n+\n+  gcc_assert (TREE_CODE (expr) == ADDR_EXPR);\n+\n+  base = get_inner_reference (TREE_OPERAND (expr, 0),\n+\t\t\t      &bitsize, &bitpos, &offset,\n+\t\t\t      &mode, &align, &align, false);\n+  if (TREE_CODE (base) == MISALIGNED_INDIRECT_REF)\n+    val = get_value_for_expr (TREE_OPERAND (base, 0), true);\n+  else if (TREE_CODE (base) == MEM_REF)\n+    val = bit_value_binop (PLUS_EXPR, TREE_TYPE (expr),\n+\t\t\t   TREE_OPERAND (base, 0), TREE_OPERAND (base, 1));\n+  else if (base\n+\t   && ((align = get_object_alignment (base, BITS_PER_UNIT,\n+\t\t\t\t\t      BIGGEST_ALIGNMENT))\n+\t\t> BITS_PER_UNIT))\n+    {\n+      val.lattice_val = CONSTANT;\n+      /* We assume pointers are zero-extended.  */\n+      val.mask = double_int_and_not\n+\t           (double_int_mask (TYPE_PRECISION (TREE_TYPE (expr))),\n+\t\t    uhwi_to_double_int (align / BITS_PER_UNIT - 1));\n+      val.value = build_int_cst (TREE_TYPE (expr), 0);\n+    }\n+  else\n+    {\n+      val.lattice_val = VARYING;\n+      val.mask = double_int_minus_one;\n+      val.value = NULL_TREE;\n+    }\n+  if (bitpos != 0)\n+    {\n+      double_int value, mask;\n+      bit_value_binop_1 (PLUS_EXPR, TREE_TYPE (expr), &value, &mask,\n+\t\t\t TREE_TYPE (expr), value_to_double_int (val), val.mask,\n+\t\t\t TREE_TYPE (expr),\n+\t\t\t shwi_to_double_int (bitpos / BITS_PER_UNIT),\n+\t\t\t double_int_zero);\n+      val.lattice_val = double_int_minus_one_p (mask) ? VARYING : CONSTANT;\n+      val.mask = mask;\n+      if (val.lattice_val == CONSTANT)\n+\tval.value = double_int_to_tree (TREE_TYPE (expr), value);\n+      else\n+\tval.value = NULL_TREE;\n+    }\n+  /* ???  We should handle i * 4 and more complex expressions from\n+     the offset, possibly by just expanding get_value_for_expr.  */\n+  if (offset != NULL_TREE)\n+    {\n+      double_int value, mask;\n+      prop_value_t oval = get_value_for_expr (offset, true);\n+      bit_value_binop_1 (PLUS_EXPR, TREE_TYPE (expr), &value, &mask,\n+\t\t\t TREE_TYPE (expr), value_to_double_int (val), val.mask,\n+\t\t\t TREE_TYPE (expr), value_to_double_int (oval),\n+\t\t\t oval.mask);\n+      val.mask = mask;\n+      if (double_int_minus_one_p (mask))\n+\t{\n+\t  val.lattice_val = VARYING;\n+\t  val.value = NULL_TREE;\n+\t}\n+      else\n+\t{\n+\t  val.lattice_val = CONSTANT;\n+\t  val.value = double_int_to_tree (TREE_TYPE (expr), value);\n+\t}\n+    }\n+\n+  return val;\n+}\n+\n+/* Return the value for the tree operand EXPR.  If FOR_BITS_P is true\n+   return constant bits extracted from alignment information for\n+   invariant addresses.  */\n+\n+static prop_value_t\n+get_value_for_expr (tree expr, bool for_bits_p)\n {\n   prop_value_t val;\n \n   if (TREE_CODE (expr) == SSA_NAME)\n-    val = *(get_value (expr));\n-  else if (is_gimple_min_invariant (expr))\n+    {\n+      val = *get_value (expr);\n+      if (for_bits_p\n+\t  && val.lattice_val == CONSTANT\n+\t  && TREE_CODE (val.value) == ADDR_EXPR)\n+\tval = get_value_from_alignment (val.value);\n+    }\n+  else if (is_gimple_min_invariant (expr)\n+\t   && (!for_bits_p || TREE_CODE (expr) != ADDR_EXPR))\n     {\n       val.lattice_val = CONSTANT;\n       val.value = expr;\n+      val.mask = double_int_zero;\n       canonicalize_float_value (&val);\n     }\n+  else if (TREE_CODE (expr) == ADDR_EXPR)\n+    val = get_value_from_alignment (expr);\n   else\n     {\n       val.lattice_val = VARYING;\n+      val.mask = double_int_minus_one;\n       val.value = NULL_TREE;\n     }\n-\n   return val;\n }\n \n-\n /* Return the likely CCP lattice value for STMT.\n \n    If STMT has no operands, then return CONSTANT.\n@@ -637,6 +824,7 @@ do_dbg_cnt (void)\n       if (!dbg_cnt (ccp))\n         {\n           const_val[i].lattice_val = VARYING;\n+\t  const_val[i].mask = double_int_minus_one;\n           const_val[i].value = NULL_TREE;\n         }\n     }\n@@ -692,23 +880,58 @@ ccp_lattice_meet (prop_value_t *val1, prop_value_t *val2)\n     {\n       /* any M VARYING = VARYING.  */\n       val1->lattice_val = VARYING;\n+      val1->mask = double_int_minus_one;\n       val1->value = NULL_TREE;\n     }\n+  else if (val1->lattice_val == CONSTANT\n+\t   && val2->lattice_val == CONSTANT\n+\t   && TREE_CODE (val1->value) == INTEGER_CST\n+\t   && TREE_CODE (val2->value) == INTEGER_CST)\n+    {\n+      /* Ci M Cj = Ci\t\tif (i == j)\n+\t Ci M Cj = VARYING\tif (i != j)\n+\n+         For INTEGER_CSTs mask unequal bits.  If no equal bits remain,\n+\t drop to varying.  */\n+      val1->mask\n+\t  = double_int_ior (double_int_ior (val1->mask,\n+\t\t\t\t\t    val2->mask),\n+\t\t\t    double_int_xor (tree_to_double_int (val1->value),\n+\t\t\t\t\t    tree_to_double_int (val2->value)));\n+      if (double_int_minus_one_p (val1->mask))\n+\t{\n+\t  val1->lattice_val = VARYING;\n+\t  val1->value = NULL_TREE;\n+\t}\n+    }\n   else if (val1->lattice_val == CONSTANT\n \t   && val2->lattice_val == CONSTANT\n \t   && simple_cst_equal (val1->value, val2->value) == 1)\n     {\n       /* Ci M Cj = Ci\t\tif (i == j)\n \t Ci M Cj = VARYING\tif (i != j)\n \n-         If these two values come from memory stores, make sure that\n-\t they come from the same memory reference.\n-         Nothing to do.  VAL1 already contains the value we want.  */\n+         VAL1 already contains the value we want for equivalent values.  */\n+    }\n+  else if (val1->lattice_val == CONSTANT\n+\t   && val2->lattice_val == CONSTANT\n+\t   && (TREE_CODE (val1->value) == ADDR_EXPR\n+\t       || TREE_CODE (val2->value) == ADDR_EXPR))\n+    {\n+      /* When not equal addresses are involved try meeting for\n+\t alignment.  */\n+      prop_value_t tem = *val2;\n+      if (TREE_CODE (val1->value) == ADDR_EXPR)\n+\t*val1 = get_value_for_expr (val1->value, true);\n+      if (TREE_CODE (val2->value) == ADDR_EXPR)\n+\ttem = get_value_for_expr (val2->value, true);\n+      ccp_lattice_meet (val1, &tem);\n     }\n   else\n     {\n       /* Any other combination is VARYING.  */\n       val1->lattice_val = VARYING;\n+      val1->mask = double_int_minus_one;\n       val1->value = NULL_TREE;\n     }\n }\n@@ -769,7 +992,7 @@ ccp_visit_phi_node (gimple phi)\n       if (e->flags & EDGE_EXECUTABLE)\n \t{\n \t  tree arg = gimple_phi_arg (phi, i)->def;\n-\t  prop_value_t arg_val = get_value_for_expr (arg);\n+\t  prop_value_t arg_val = get_value_for_expr (arg, false);\n \n \t  ccp_lattice_meet (&new_val, &arg_val);\n \n@@ -1334,6 +1557,347 @@ fold_const_aggregate_ref (tree t)\n   return NULL_TREE;\n }\n \n+/* Apply the operation CODE in type TYPE to the value, mask pair\n+   RVAL and RMASK representing a value of type RTYPE and set\n+   the value, mask pair *VAL and *MASK to the result.  */\n+\n+static void\n+bit_value_unop_1 (enum tree_code code, tree type,\n+\t\t  double_int *val, double_int *mask,\n+\t\t  tree rtype, double_int rval, double_int rmask)\n+{\n+  switch (code)\n+    {\n+    case BIT_NOT_EXPR:\n+      *mask = rmask;\n+      *val = double_int_not (rval);\n+      break;\n+\n+    case NEGATE_EXPR:\n+      {\n+\tdouble_int temv, temm;\n+\t/* Return ~rval + 1.  */\n+\tbit_value_unop_1 (BIT_NOT_EXPR, type, &temv, &temm, type, rval, rmask);\n+\tbit_value_binop_1 (PLUS_EXPR, type, val, mask,\n+\t\t\t type, temv, temm,\n+\t\t\t type, double_int_one, double_int_zero);\n+\tbreak;\n+      }\n+\n+    CASE_CONVERT:\n+      {\n+\tbool uns;\n+\n+\t/* First extend mask and value according to the original type.  */\n+\tuns = (TREE_CODE (rtype) == INTEGER_TYPE && TYPE_IS_SIZETYPE (rtype)\n+\t       ? 0 : TYPE_UNSIGNED (rtype));\n+\t*mask = double_int_ext (rmask, TYPE_PRECISION (rtype), uns);\n+\t*val = double_int_ext (rval, TYPE_PRECISION (rtype), uns);\n+\n+\t/* Then extend mask and value according to the target type.  */\n+\tuns = (TREE_CODE (type) == INTEGER_TYPE && TYPE_IS_SIZETYPE (type)\n+\t       ? 0 : TYPE_UNSIGNED (type));\n+\t*mask = double_int_ext (*mask, TYPE_PRECISION (type), uns);\n+\t*val = double_int_ext (*val, TYPE_PRECISION (type), uns);\n+\tbreak;\n+      }\n+\n+    default:\n+      *mask = double_int_minus_one;\n+      break;\n+    }\n+}\n+\n+/* Apply the operation CODE in type TYPE to the value, mask pairs\n+   R1VAL, R1MASK and R2VAL, R2MASK representing a values of type R1TYPE\n+   and R2TYPE and set the value, mask pair *VAL and *MASK to the result.  */\n+\n+static void\n+bit_value_binop_1 (enum tree_code code, tree type,\n+\t\t   double_int *val, double_int *mask,\n+\t\t   tree r1type, double_int r1val, double_int r1mask,\n+\t\t   tree r2type, double_int r2val, double_int r2mask)\n+{\n+  bool uns = (TREE_CODE (type) == INTEGER_TYPE\n+\t      && TYPE_IS_SIZETYPE (type) ? 0 : TYPE_UNSIGNED (type));\n+  /* Assume we'll get a constant result.  Use an initial varying value,\n+     we fall back to varying in the end if necessary.  */\n+  *mask = double_int_minus_one;\n+  switch (code)\n+    {\n+    case BIT_AND_EXPR:\n+      /* The mask is constant where there is a known not\n+\t set bit, (m1 | m2) & ((v1 | m1) & (v2 | m2)) */\n+      *mask = double_int_and (double_int_ior (r1mask, r2mask),\n+\t\t\t      double_int_and (double_int_ior (r1val, r1mask),\n+\t\t\t\t\t      double_int_ior (r2val, r2mask)));\n+      *val = double_int_and (r1val, r2val);\n+      break;\n+\n+    case BIT_IOR_EXPR:\n+      /* The mask is constant where there is a known\n+\t set bit, (m1 | m2) & ~((v1 & ~m1) | (v2 & ~m2)).  */\n+      *mask = double_int_and_not\n+\t  \t(double_int_ior (r1mask, r2mask),\n+\t\t double_int_ior (double_int_and_not (r1val, r1mask),\n+\t\t\t\t double_int_and_not (r2val, r2mask)));\n+      *val = double_int_ior (r1val, r2val);\n+      break;\n+\n+    case BIT_XOR_EXPR:\n+      /* m1 | m2  */\n+      *mask = double_int_ior (r1mask, r2mask);\n+      *val = double_int_xor (r1val, r2val);\n+      break;\n+\n+    case LROTATE_EXPR:\n+    case RROTATE_EXPR:\n+      if (double_int_zero_p (r2mask))\n+\t{\n+\t  HOST_WIDE_INT shift = r2val.low;\n+\t  if (code == RROTATE_EXPR)\n+\t    shift = -shift;\n+\t  *mask = double_int_lrotate (r1mask, shift, TYPE_PRECISION (type));\n+\t  *val = double_int_lrotate (r1val, shift, TYPE_PRECISION (type));\n+\t}\n+      break;\n+\n+    case LSHIFT_EXPR:\n+    case RSHIFT_EXPR:\n+      /* ???  We can handle partially known shift counts if we know\n+\t its sign.  That way we can tell that (x << (y | 8)) & 255\n+\t is zero.  */\n+      if (double_int_zero_p (r2mask))\n+\t{\n+\t  HOST_WIDE_INT shift = r2val.low;\n+\t  if (code == RSHIFT_EXPR)\n+\t    shift = -shift;\n+\t  /* We need to know if we are doing a left or a right shift\n+\t     to properly shift in zeros for left shift and unsigned\n+\t     right shifts and the sign bit for signed right shifts.\n+\t     For signed right shifts we shift in varying in case\n+\t     the sign bit was varying.  */\n+\t  if (shift > 0)\n+\t    {\n+\t      *mask = double_int_lshift (r1mask, shift,\n+\t\t\t\t\t TYPE_PRECISION (type), false);\n+\t      *val = double_int_lshift (r1val, shift,\n+\t\t\t\t\tTYPE_PRECISION (type), false);\n+\t    }\n+\t  else if (shift < 0)\n+\t    {\n+\t      shift = -shift;\n+\t      *mask = double_int_rshift (r1mask, shift,\n+\t\t\t\t\t TYPE_PRECISION (type), !uns);\n+\t      *val = double_int_rshift (r1val, shift,\n+\t\t\t\t\tTYPE_PRECISION (type), !uns);\n+\t    }\n+\t  else\n+\t    {\n+\t      *mask = r1mask;\n+\t      *val = r1val;\n+\t    }\n+\t}\n+      break;\n+\n+    case PLUS_EXPR:\n+    case POINTER_PLUS_EXPR:\n+      {\n+\tdouble_int lo, hi;\n+\t/* Do the addition with unknown bits set to zero, to give carry-ins of\n+\t   zero wherever possible.  */\n+\tlo = double_int_add (double_int_and_not (r1val, r1mask),\n+\t\t\t     double_int_and_not (r2val, r2mask));\n+\tlo = double_int_ext (lo, TYPE_PRECISION (type), uns);\n+\t/* Do the addition with unknown bits set to one, to give carry-ins of\n+\t   one wherever possible.  */\n+\thi = double_int_add (double_int_ior (r1val, r1mask),\n+\t\t\t     double_int_ior (r2val, r2mask));\n+\thi = double_int_ext (hi, TYPE_PRECISION (type), uns);\n+\t/* Each bit in the result is known if (a) the corresponding bits in\n+\t   both inputs are known, and (b) the carry-in to that bit position\n+\t   is known.  We can check condition (b) by seeing if we got the same\n+\t   result with minimised carries as with maximised carries.  */\n+\t*mask = double_int_ior (double_int_ior (r1mask, r2mask),\n+\t\t\t\tdouble_int_xor (lo, hi));\n+\t*mask = double_int_ext (*mask, TYPE_PRECISION (type), uns);\n+\t/* It shouldn't matter whether we choose lo or hi here.  */\n+\t*val = lo;\n+\tbreak;\n+      }\n+\n+    case MINUS_EXPR:\n+      {\n+\tdouble_int temv, temm;\n+\tbit_value_unop_1 (NEGATE_EXPR, r2type, &temv, &temm,\n+\t\t\t  r2type, r2val, r2mask);\n+\tbit_value_binop_1 (PLUS_EXPR, type, val, mask,\n+\t\t\t   r1type, r1val, r1mask,\n+\t\t\t   r2type, temv, temm);\n+\tbreak;\n+      }\n+\n+    case MULT_EXPR:\n+      {\n+\t/* Just track trailing zeros in both operands and transfer\n+\t   them to the other.  */\n+\tint r1tz = double_int_ctz (double_int_ior (r1val, r1mask));\n+\tint r2tz = double_int_ctz (double_int_ior (r2val, r2mask));\n+\tif (r1tz + r2tz >= HOST_BITS_PER_DOUBLE_INT)\n+\t  {\n+\t    *mask = double_int_zero;\n+\t    *val = double_int_zero;\n+\t  }\n+\telse if (r1tz + r2tz > 0)\n+\t  {\n+\t    *mask = double_int_not (double_int_mask (r1tz + r2tz));\n+\t    *mask = double_int_ext (*mask, TYPE_PRECISION (type), uns);\n+\t    *val = double_int_zero;\n+\t  }\n+\tbreak;\n+      }\n+\n+    case EQ_EXPR:\n+    case NE_EXPR:\n+      {\n+\tdouble_int m = double_int_ior (r1mask, r2mask);\n+\tif (!double_int_equal_p (double_int_and_not (r1val, m),\n+\t\t\t\t double_int_and_not (r2val, m)))\n+\t  {\n+\t    *mask = double_int_zero;\n+\t    *val = ((code == EQ_EXPR) ? double_int_zero : double_int_one);\n+\t  }\n+\telse\n+\t  {\n+\t    /* We know the result of a comparison is always one or zero.  */\n+\t    *mask = double_int_one;\n+\t    *val = double_int_zero;\n+\t  }\n+\tbreak;\n+      }\n+\n+    case GE_EXPR:\n+    case GT_EXPR:\n+      {\n+\tdouble_int tem = r1val;\n+\tr1val = r2val;\n+\tr2val = tem;\n+\ttem = r1mask;\n+\tr1mask = r2mask;\n+\tr2mask = tem;\n+\tcode = swap_tree_comparison (code);\n+      }\n+      /* Fallthru.  */\n+    case LT_EXPR:\n+    case LE_EXPR:\n+      {\n+\tint minmax, maxmin;\n+\t/* If the most significant bits are not known we know nothing.  */\n+\tif (double_int_negative_p (r1mask) || double_int_negative_p (r2mask))\n+\t  break;\n+\n+\t/* If we know the most significant bits we know the values\n+\t   value ranges by means of treating varying bits as zero\n+\t   or one.  Do a cross comparison of the max/min pairs.  */\n+\tmaxmin = double_int_cmp (double_int_ior (r1val, r1mask),\n+\t\t\t\t double_int_and_not (r2val, r2mask), uns);\n+\tminmax = double_int_cmp (double_int_and_not (r1val, r1mask),\n+\t\t\t\t double_int_ior (r2val, r2mask), uns);\n+\tif (maxmin < 0)  /* r1 is less than r2.  */\n+\t  {\n+\t    *mask = double_int_zero;\n+\t    *val = double_int_one;\n+\t  }\n+\telse if (minmax > 0)  /* r1 is not less or equal to r2.  */\n+\t  {\n+\t    *mask = double_int_zero;\n+\t    *val = double_int_zero;\n+\t  }\n+\telse if (maxmin == minmax)  /* r1 and r2 are equal.  */\n+\t  {\n+\t    /* This probably should never happen as we'd have\n+\t       folded the thing during fully constant value folding.  */\n+\t    *mask = double_int_zero;\n+\t    *val = (code == LE_EXPR ? double_int_one :  double_int_zero);\n+\t  }\n+\telse\n+\t  {\n+\t    /* We know the result of a comparison is always one or zero.  */\n+\t    *mask = double_int_one;\n+\t    *val = double_int_zero;\n+\t  }\n+\tbreak;\n+      }\n+\n+    default:;\n+    }\n+}\n+\n+/* Return the propagation value when applying the operation CODE to\n+   the value RHS yielding type TYPE.  */\n+\n+static prop_value_t\n+bit_value_unop (enum tree_code code, tree type, tree rhs)\n+{\n+  prop_value_t rval = get_value_for_expr (rhs, true);\n+  double_int value, mask;\n+  prop_value_t val;\n+  gcc_assert ((rval.lattice_val == CONSTANT\n+\t       && TREE_CODE (rval.value) == INTEGER_CST)\n+\t      || double_int_minus_one_p (rval.mask));\n+  bit_value_unop_1 (code, type, &value, &mask,\n+\t\t    TREE_TYPE (rhs), value_to_double_int (rval), rval.mask);\n+  if (!double_int_minus_one_p (mask))\n+    {\n+      val.lattice_val = CONSTANT;\n+      val.mask = mask;\n+      /* ???  Delay building trees here.  */\n+      val.value = double_int_to_tree (type, value);\n+    }\n+  else\n+    {\n+      val.lattice_val = VARYING;\n+      val.value = NULL_TREE;\n+      val.mask = double_int_minus_one;\n+    }\n+  return val;\n+}\n+\n+/* Return the propagation value when applying the operation CODE to\n+   the values RHS1 and RHS2 yielding type TYPE.  */\n+\n+static prop_value_t\n+bit_value_binop (enum tree_code code, tree type, tree rhs1, tree rhs2)\n+{\n+  prop_value_t r1val = get_value_for_expr (rhs1, true);\n+  prop_value_t r2val = get_value_for_expr (rhs2, true);\n+  double_int value, mask;\n+  prop_value_t val;\n+  gcc_assert ((r1val.lattice_val == CONSTANT\n+\t       && TREE_CODE (r1val.value) == INTEGER_CST)\n+\t      || double_int_minus_one_p (r1val.mask));\n+  gcc_assert ((r2val.lattice_val == CONSTANT\n+\t       && TREE_CODE (r2val.value) == INTEGER_CST)\n+\t      || double_int_minus_one_p (r2val.mask));\n+  bit_value_binop_1 (code, type, &value, &mask,\n+\t\t     TREE_TYPE (rhs1), value_to_double_int (r1val), r1val.mask,\n+\t\t     TREE_TYPE (rhs2), value_to_double_int (r2val), r2val.mask);\n+  if (!double_int_minus_one_p (mask))\n+    {\n+      val.lattice_val = CONSTANT;\n+      val.mask = mask;\n+      /* ???  Delay building trees here.  */\n+      val.value = double_int_to_tree (type, value);\n+    }\n+  else\n+    {\n+      val.lattice_val = VARYING;\n+      val.value = NULL_TREE;\n+      val.mask = double_int_minus_one;\n+    }\n+  return val;\n+}\n+\n /* Evaluate statement STMT.\n    Valid only for assignments, calls, conditionals, and switches. */\n \n@@ -1343,17 +1907,46 @@ evaluate_stmt (gimple stmt)\n   prop_value_t val;\n   tree simplified = NULL_TREE;\n   ccp_lattice_t likelyvalue = likely_value (stmt);\n-  bool is_constant;\n+  bool is_constant = false;\n \n-  fold_defer_overflow_warnings ();\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"which is likely \");\n+      switch (likelyvalue)\n+\t{\n+\tcase CONSTANT:\n+\t  fprintf (dump_file, \"CONSTANT\");\n+\t  break;\n+\tcase UNDEFINED:\n+\t  fprintf (dump_file, \"UNDEFINED\");\n+\t  break;\n+\tcase VARYING:\n+\t  fprintf (dump_file, \"VARYING\");\n+\t  break;\n+\tdefault:;\n+\t}\n+      fprintf (dump_file, \"\\n\");\n+    }\n \n   /* If the statement is likely to have a CONSTANT result, then try\n      to fold the statement to determine the constant value.  */\n   /* FIXME.  This is the only place that we call ccp_fold.\n      Since likely_value never returns CONSTANT for calls, we will\n      not attempt to fold them, including builtins that may profit.  */\n   if (likelyvalue == CONSTANT)\n-    simplified = ccp_fold (stmt);\n+    {\n+      fold_defer_overflow_warnings ();\n+      simplified = ccp_fold (stmt);\n+      is_constant = simplified && is_gimple_min_invariant (simplified);\n+      fold_undefer_overflow_warnings (is_constant, stmt, 0);\n+      if (is_constant)\n+\t{\n+\t  /* The statement produced a constant value.  */\n+\t  val.lattice_val = CONSTANT;\n+\t  val.value = simplified;\n+\t  val.mask = double_int_zero;\n+\t}\n+    }\n   /* If the statement is likely to have a VARYING result, then do not\n      bother folding the statement.  */\n   else if (likelyvalue == VARYING)\n@@ -1373,46 +1966,85 @@ evaluate_stmt (gimple stmt)\n       else\n \t/* These cannot satisfy is_gimple_min_invariant without folding.  */\n \tgcc_assert (code == GIMPLE_CALL || code == GIMPLE_COND);\n+      is_constant = simplified && is_gimple_min_invariant (simplified);\n+      if (is_constant)\n+\t{\n+\t  /* The statement produced a constant value.  */\n+\t  val.lattice_val = CONSTANT;\n+\t  val.value = simplified;\n+\t  val.mask = double_int_zero;\n+\t}\n     }\n \n-  is_constant = simplified && is_gimple_min_invariant (simplified);\n-\n-  fold_undefer_overflow_warnings (is_constant, stmt, 0);\n-\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n+  /* Resort to simplification for bitwise tracking.  */\n+  if (flag_tree_bit_ccp\n+      && likelyvalue == CONSTANT\n+      && !is_constant)\n     {\n-      fprintf (dump_file, \"which is likely \");\n-      switch (likelyvalue)\n+      enum gimple_code code = gimple_code (stmt);\n+      val.lattice_val = VARYING;\n+      val.value = NULL_TREE;\n+      val.mask = double_int_minus_one;\n+      if (code == GIMPLE_ASSIGN)\n \t{\n-\tcase CONSTANT:\n-\t  fprintf (dump_file, \"CONSTANT\");\n-\t  break;\n-\tcase UNDEFINED:\n-\t  fprintf (dump_file, \"UNDEFINED\");\n-\t  break;\n-\tcase VARYING:\n-\t  fprintf (dump_file, \"VARYING\");\n-\t  break;\n-\tdefault:;\n+\t  enum tree_code subcode = gimple_assign_rhs_code (stmt);\n+\t  tree rhs1 = gimple_assign_rhs1 (stmt);\n+\t  switch (get_gimple_rhs_class (subcode))\n+\t    {\n+\t    case GIMPLE_SINGLE_RHS:\n+\t      if (INTEGRAL_TYPE_P (TREE_TYPE (rhs1))\n+\t\t  || POINTER_TYPE_P (TREE_TYPE (rhs1)))\n+\t\tval = get_value_for_expr (rhs1, true);\n+\t      break;\n+\n+\t    case GIMPLE_UNARY_RHS:\n+\t      if ((INTEGRAL_TYPE_P (TREE_TYPE (rhs1))\n+\t\t   || POINTER_TYPE_P (TREE_TYPE (rhs1)))\n+\t\t  && (INTEGRAL_TYPE_P (gimple_expr_type (stmt))\n+\t\t      || POINTER_TYPE_P (gimple_expr_type (stmt))))\n+\t\tval = bit_value_unop (subcode, gimple_expr_type (stmt), rhs1);\n+\t      break;\n+\n+\t    case GIMPLE_BINARY_RHS:\n+\t      if (INTEGRAL_TYPE_P (TREE_TYPE (rhs1))\n+\t\t  || POINTER_TYPE_P (TREE_TYPE (rhs1)))\n+\t\t{\n+\t\t  tree rhs2 = gimple_assign_rhs2 (stmt);\n+\t\t  val = bit_value_binop (subcode,\n+\t\t\t\t\t TREE_TYPE (rhs1), rhs1, rhs2);\n+\t\t}\n+\t      break;\n+\n+\t    default:;\n+\t    }\n \t}\n-      fprintf (dump_file, \"\\n\");\n+      else if (code == GIMPLE_COND)\n+\t{\n+\t  enum tree_code code = gimple_cond_code (stmt);\n+\t  tree rhs1 = gimple_cond_lhs (stmt);\n+\t  tree rhs2 = gimple_cond_rhs (stmt);\n+\t  if (INTEGRAL_TYPE_P (TREE_TYPE (rhs1))\n+\t      || POINTER_TYPE_P (TREE_TYPE (rhs1)))\n+\t    val = bit_value_binop (code, TREE_TYPE (rhs1), rhs1, rhs2);\n+\t}\n+      is_constant = (val.lattice_val == CONSTANT);\n     }\n \n-  if (is_constant)\n-    {\n-      /* The statement produced a constant value.  */\n-      val.lattice_val = CONSTANT;\n-      val.value = simplified;\n-    }\n-  else\n+  if (!is_constant)\n     {\n       /* The statement produced a nonconstant value.  If the statement\n \t had UNDEFINED operands, then the result of the statement\n \t should be UNDEFINED.  Otherwise, the statement is VARYING.  */\n       if (likelyvalue == UNDEFINED)\n-\tval.lattice_val = likelyvalue;\n+\t{\n+\t  val.lattice_val = likelyvalue;\n+\t  val.mask = double_int_zero;\n+\t}\n       else\n-\tval.lattice_val = VARYING;\n+\t{\n+\t  val.lattice_val = VARYING;\n+\t  val.mask = double_int_minus_one;\n+\t}\n \n       val.value = NULL_TREE;\n     }\n@@ -1438,9 +2070,18 @@ ccp_fold_stmt (gimple_stmt_iterator *gsi)\n \t   fold more conditionals here.  */\n \tval = evaluate_stmt (stmt);\n \tif (val.lattice_val != CONSTANT\n-\t    || TREE_CODE (val.value) != INTEGER_CST)\n+\t    || !double_int_zero_p (val.mask))\n \t  return false;\n \n+\tif (dump_file)\n+\t  {\n+\t    fprintf (dump_file, \"Folding predicate \");\n+\t    print_gimple_expr (dump_file, stmt, 0, 0);\n+\t    fprintf (dump_file, \" to \");\n+\t    print_generic_expr (dump_file, val.value, 0);\n+\t    fprintf (dump_file, \"\\n\");\n+\t  }\n+\n \tif (integer_zerop (val.value))\n \t  gimple_cond_make_false (stmt);\n \telse\n@@ -1583,12 +2224,15 @@ visit_cond_stmt (gimple stmt, edge *taken_edge_p)\n \n   block = gimple_bb (stmt);\n   val = evaluate_stmt (stmt);\n+  if (val.lattice_val != CONSTANT\n+      || !double_int_zero_p (val.mask))\n+    return SSA_PROP_VARYING;\n \n   /* Find which edge out of the conditional block will be taken and add it\n      to the worklist.  If no single edge can be determined statically,\n      return SSA_PROP_VARYING to feed all the outgoing edges to the\n      propagation engine.  */\n-  *taken_edge_p = val.value ? find_taken_edge (block, val.value) : 0;\n+  *taken_edge_p = find_taken_edge (block, val.value);\n   if (*taken_edge_p)\n     return SSA_PROP_INTERESTING;\n   else\n@@ -1653,7 +2297,7 @@ ccp_visit_stmt (gimple stmt, edge *taken_edge_p, tree *output_p)\n      Mark them VARYING.  */\n   FOR_EACH_SSA_TREE_OPERAND (def, stmt, iter, SSA_OP_ALL_DEFS)\n     {\n-      prop_value_t v = { VARYING, NULL_TREE };\n+      prop_value_t v = { VARYING, NULL_TREE, { -1, (HOST_WIDE_INT) -1 } };\n       set_lattice_value (def, v);\n     }\n "}]}