{"sha": "41081235df0e32d9bfc3fe4169af4f1af4b823af", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDEwODEyMzVkZjBlMzJkOWJmYzNmZTQxNjlhZjRmMWFmNGI4MjNhZg==", "commit": {"author": {"name": "Giuliano Belinassi", "email": "giuliano.belinassi@usp.br", "date": "2020-05-07T17:43:48Z"}, "committer": {"name": "Jeff Law", "email": "law@torsion.usersys.redhat.com", "date": "2020-05-07T17:45:34Z"}, "message": "Wrap global variables in tree-ssa-operands.c into a class.\n\n\t* tree-ssa-operands.c (operands_scanner): New class.\n\t(operands_bitmap_obstack): Remove.\n\t(n_initialized): Remove.\n\t(build_uses): Move to operands_scanner class.\n\t(build_vuse): Same as above.\n\t(build_vdef): Same as above.\n\t(verify_ssa_operands): Same as above.\n\t(finalize_ssa_uses): Same as above.\n\t(cleanup_build_arrays): Same as above.\n\t(finalize_ssa_stmt_operands): Same as above.\n\t(start_ssa_stmt_operands): Same as above.\n\t(append_use): Same as above.\n\t(append_vdef): Same as above.\n\t(add_virtual_operand): Same as above.\n\t(add_stmt_operand): Same as above.\n\t(get_mem_ref_operands): Same as above.\n\t(get_tmr_operands): Same as above.\n\t(maybe_add_call_vops): Same as above.\n\t(get_asm_stmt_operands): Same as above.\n\t(get_expr_operands): Same as above.\n\t(parse_ssa_operands): Same as above.\n\t(finalize_ssa_defs): Same as above.\n\t(build_ssa_operands): Same as above, plus create a C-like wrapper.\n\t(update_stmt_operands): Create an instance of operands_scanner.", "tree": {"sha": "50f3b8bae1f769aba5ddcbe690491cf267b0c069", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/50f3b8bae1f769aba5ddcbe690491cf267b0c069"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/41081235df0e32d9bfc3fe4169af4f1af4b823af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41081235df0e32d9bfc3fe4169af4f1af4b823af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/41081235df0e32d9bfc3fe4169af4f1af4b823af", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41081235df0e32d9bfc3fe4169af4f1af4b823af/comments", "author": null, "committer": null, "parents": [{"sha": "0ca22d027eccb55215bb553b66fb10637344e2e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ca22d027eccb55215bb553b66fb10637344e2e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ca22d027eccb55215bb553b66fb10637344e2e6"}], "stats": {"total": 333, "additions": 216, "deletions": 117}, "files": [{"sha": "176b0de434a5fb287d3d6963d9c5ae4eded48536", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41081235df0e32d9bfc3fe4169af4f1af4b823af/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41081235df0e32d9bfc3fe4169af4f1af4b823af/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=41081235df0e32d9bfc3fe4169af4f1af4b823af", "patch": "@@ -1,3 +1,30 @@\n+2020-05-07  Giuliano Belinassi  <giuliano.belinassi@usp.br>\n+\n+\t* tree-ssa-operands.c (operands_scanner): New class.\n+\t(operands_bitmap_obstack): Remove.\n+\t(n_initialized): Remove.\n+\t(build_uses): Move to operands_scanner class.\n+\t(build_vuse): Same as above.\n+\t(build_vdef): Same as above.\n+\t(verify_ssa_operands): Same as above.\n+\t(finalize_ssa_uses): Same as above.\n+\t(cleanup_build_arrays): Same as above.\n+\t(finalize_ssa_stmt_operands): Same as above.\n+\t(start_ssa_stmt_operands): Same as above.\n+\t(append_use): Same as above.\n+\t(append_vdef): Same as above.\n+\t(add_virtual_operand): Same as above.\n+\t(add_stmt_operand): Same as above.\n+\t(get_mem_ref_operands): Same as above.\n+\t(get_tmr_operands): Same as above.\n+\t(maybe_add_call_vops): Same as above.\n+\t(get_asm_stmt_operands): Same as above.\n+\t(get_expr_operands): Same as above.\n+\t(parse_ssa_operands): Same as above.\n+\t(finalize_ssa_defs): Same as above.\n+\t(build_ssa_operands): Same as above, plus create a C-like wrapper.\n+\t(update_stmt_operands): Create an instance of operands_scanner.\n+\n 2020-05-07  Richard Biener  <rguenther@suse.de>\n \n \tPR ipa/94947"}, {"sha": "f4716d0e36fae857b8a46076814f8d965abd52de", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 189, "deletions": 117, "changes": 306, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41081235df0e32d9bfc3fe4169af4f1af4b823af/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41081235df0e32d9bfc3fe4169af4f1af4b823af/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=41081235df0e32d9bfc3fe4169af4f1af4b823af", "patch": "@@ -99,23 +99,111 @@ along with GCC; see the file COPYING3.  If not see\n /* Operand is having its address taken.  */\n #define opf_address_taken (1 << 5)\n \n-/* Array for building all the use operands.  */\n-static vec<tree *> build_uses;\n+/* Class containing temporary per-stmt state.  */\n \n-/* The built VDEF operand.  */\n-static tree build_vdef;\n+class operands_scanner\n+{\n+  public:\n+    operands_scanner (struct function *fun, gimple *statement)\n+      {\n+\tbuild_vuse = NULL_TREE;\n+\tbuild_vdef = NULL_TREE;\n+\tfn = fun;\n+\tstmt = statement;\n+      }\n+\n+    /* Create an operands cache for STMT.  */\n+    void build_ssa_operands ();\n+\n+    /* Verifies SSA statement operands.  */\n+    DEBUG_FUNCTION bool verify_ssa_operands ();\n+\n+  private:\n+    /* Disable copy and assign of this class, as it may have problems with\n+       build_uses vec.  */\n+    DISABLE_COPY_AND_ASSIGN (operands_scanner);\n+\n+    /* Array for building all the use operands.  */\n+    auto_vec<tree *, 16> build_uses;\n+\n+    /* The built VDEF operand.  */\n+    tree build_vdef;\n+\n+    /* The built VUSE operand.  */\n+    tree build_vuse;\n+\n+    /* Function which STMT belongs to.  */\n+    struct function *fn;\n+\n+    /* Statement to work on.  */\n+    gimple *stmt;\n+\n+    /* Takes elements from build_uses and turns them into use operands of STMT.  */\n+    void finalize_ssa_uses ();\n+\n+    /* Clear the in_list bits and empty the build array for VDEFs and\n+       VUSEs.  */\n+    void cleanup_build_arrays ();\n+\n+    /* Finalize all the build vectors, fill the new ones into INFO.  */\n+    void finalize_ssa_stmt_operands ();\n+\n+    /* Start the process of building up operands vectors in INFO.  */\n+    void start_ssa_stmt_operands ();\n+\n+    /* Add USE_P to the list of pointers to operands.  */\n+    void append_use (tree *use_p);\n \n-/* The built VUSE operand.  */\n-static tree build_vuse;\n+    /* Add VAR to the set of variables that require a VDEF operator.  */\n+    void append_vdef (tree var);\n \n-/* Bitmap obstack for our datastructures that needs to survive across\n-   compilations of multiple functions.  */\n-static bitmap_obstack operands_bitmap_obstack;\n+    /* Add VAR to the set of variables that require a VUSE operator.  */\n+    void append_vuse (tree var);\n \n-static void get_expr_operands (struct function *, gimple *, tree *, int);\n+    /* Add virtual operands for STMT.  FLAGS is as in get_expr_operands.  */\n+    void add_virtual_operand (int flags);\n \n-/* Number of functions with initialized ssa_operands.  */\n-static int n_initialized = 0;\n+\n+    /* Add *VAR_P to the appropriate operand array for statement STMT.\n+       FLAGS is as in get_expr_operands.  If *VAR_P is a GIMPLE register,\n+       it will be added to the statement's real operands, otherwise it is\n+       added to virtual operands.  */\n+    void add_stmt_operand (tree *var_p, int flags);\n+\n+    /* A subroutine of get_expr_operands to handle MEM_REF.\n+\n+       STMT is the statement being processed, EXPR is the MEM_REF\n+\t  that got us here.\n+\n+       FLAGS is as in get_expr_operands.  */\n+    void get_mem_ref_operands (tree expr, int flags);\n+\n+    /* A subroutine of get_expr_operands to handle TARGET_MEM_REF.  */\n+    void get_tmr_operands (tree expr, int flags);\n+\n+\n+    /* If STMT is a call that may clobber globals and other symbols that\n+       escape, add them to the VDEF/VUSE lists for it.  */\n+    void maybe_add_call_vops (gcall *stmt);\n+\n+    /* Scan operands in the ASM_EXPR stmt referred to in INFO.  */\n+    void get_asm_stmt_operands (gasm *stmt);\n+\n+\n+    /* Recursively scan the expression pointed to by EXPR_P in statement\n+       STMT.  FLAGS is one of the OPF_* constants modifying how to\n+       interpret the operands found.  */\n+    void get_expr_operands (tree *expr_p, int flags);\n+\n+    /* Parse STMT looking for operands.  When finished, the various\n+       build_* operand vectors will have potential operands in them.  */\n+    void parse_ssa_operands ();\n+\n+\n+    /* Takes elements from build_defs and turns them into def operands of STMT.\n+       TODO -- Make build_defs vec of tree *.  */\n+    void finalize_ssa_defs ();\n+};\n \n /* Accessor to tree-ssa-operands.c caches.  */\n static inline struct ssa_operands *\n@@ -181,14 +269,6 @@ create_vop_var (struct function *fn)\n void\n init_ssa_operands (struct function *fn)\n {\n-  if (!n_initialized++)\n-    {\n-      build_uses.create (10);\n-      build_vuse = NULL_TREE;\n-      build_vdef = NULL_TREE;\n-      bitmap_obstack_initialize (&operands_bitmap_obstack);\n-    }\n-\n   gcc_assert (gimple_ssa_operands (fn)->operand_memory == NULL);\n   gimple_ssa_operands (fn)->operand_memory_index\n      = gimple_ssa_operands (fn)->ssa_operand_mem_size;\n@@ -205,13 +285,6 @@ fini_ssa_operands (struct function *fn)\n {\n   struct ssa_operand_memory_d *ptr;\n \n-  if (!--n_initialized)\n-    {\n-      build_uses.release ();\n-      build_vdef = NULL_TREE;\n-      build_vuse = NULL_TREE;\n-    }\n-\n   gimple_ssa_operands (fn)->free_uses = NULL;\n \n   while ((ptr = gimple_ssa_operands (fn)->operand_memory) != NULL)\n@@ -223,9 +296,6 @@ fini_ssa_operands (struct function *fn)\n \n   gimple_ssa_operands (fn)->ops_active = false;\n \n-  if (!n_initialized)\n-    bitmap_obstack_release (&operands_bitmap_obstack);\n-\n   fn->gimple_df->vop = NULL_TREE;\n }\n \n@@ -315,8 +385,8 @@ add_use_op (struct function *fn, gimple *stmt, tree *op, use_optype_p last)\n /* Takes elements from build_defs and turns them into def operands of STMT.\n    TODO -- Make build_defs vec of tree *.  */\n \n-static inline void\n-finalize_ssa_defs (struct function *fn, gimple *stmt)\n+inline void\n+operands_scanner::finalize_ssa_defs ()\n {\n   /* Pre-pend the vdef we may have built.  */\n   if (build_vdef != NULL_TREE)\n@@ -353,8 +423,8 @@ finalize_ssa_defs (struct function *fn, gimple *stmt)\n \n /* Takes elements from build_uses and turns them into use operands of STMT.  */\n \n-static inline void\n-finalize_ssa_uses (struct function *fn, gimple *stmt)\n+inline void\n+operands_scanner::finalize_ssa_uses ()\n {\n   unsigned new_i;\n   struct use_optype_d new_list;\n@@ -418,8 +488,8 @@ finalize_ssa_uses (struct function *fn, gimple *stmt)\n /* Clear the in_list bits and empty the build array for VDEFs and\n    VUSEs.  */\n \n-static inline void\n-cleanup_build_arrays (void)\n+inline void\n+operands_scanner::cleanup_build_arrays ()\n {\n   build_vdef = NULL_TREE;\n   build_vuse = NULL_TREE;\n@@ -429,19 +499,19 @@ cleanup_build_arrays (void)\n \n /* Finalize all the build vectors, fill the new ones into INFO.  */\n \n-static inline void\n-finalize_ssa_stmt_operands (struct function *fn, gimple *stmt)\n+inline void\n+operands_scanner::finalize_ssa_stmt_operands ()\n {\n-  finalize_ssa_defs (fn, stmt);\n-  finalize_ssa_uses (fn, stmt);\n+  finalize_ssa_defs ();\n+  finalize_ssa_uses ();\n   cleanup_build_arrays ();\n }\n \n \n /* Start the process of building up operands vectors in INFO.  */\n \n-static inline void\n-start_ssa_stmt_operands (void)\n+inline void\n+operands_scanner::start_ssa_stmt_operands ()\n {\n   gcc_assert (build_uses.length () == 0);\n   gcc_assert (build_vuse == NULL_TREE);\n@@ -451,17 +521,17 @@ start_ssa_stmt_operands (void)\n \n /* Add USE_P to the list of pointers to operands.  */\n \n-static inline void\n-append_use (tree *use_p)\n+inline void\n+operands_scanner::append_use (tree *use_p)\n {\n   build_uses.safe_push (use_p);\n }\n \n \n /* Add VAR to the set of variables that require a VDEF operator.  */\n \n-static inline void\n-append_vdef (tree var)\n+inline void\n+operands_scanner::append_vdef (tree var)\n {\n   gcc_assert ((build_vdef == NULL_TREE\n \t       || build_vdef == var)\n@@ -475,8 +545,8 @@ append_vdef (tree var)\n \n /* Add VAR to the set of variables that require a VUSE operator.  */\n \n-static inline void\n-append_vuse (tree var)\n+inline void\n+operands_scanner::append_vuse (tree var)\n {\n   gcc_assert (build_vuse == NULL_TREE\n \t      || build_vuse == var);\n@@ -486,9 +556,8 @@ append_vuse (tree var)\n \n /* Add virtual operands for STMT.  FLAGS is as in get_expr_operands.  */\n \n-static void\n-add_virtual_operand (struct function *fn,\n-\t\t     gimple *stmt ATTRIBUTE_UNUSED, int flags)\n+void\n+operands_scanner::add_virtual_operand (int flags)\n {\n   /* Add virtual operands to the stmt, unless the caller has specifically\n      requested not to do that (used when adding operands inside an\n@@ -510,8 +579,8 @@ add_virtual_operand (struct function *fn,\n    it will be added to the statement's real operands, otherwise it is\n    added to virtual operands.  */\n \n-static void\n-add_stmt_operand (struct function *fn, tree *var_p, gimple *stmt, int flags)\n+void\n+operands_scanner::add_stmt_operand (tree *var_p, int flags)\n {\n   tree var = *var_p;\n \n@@ -537,7 +606,7 @@ add_stmt_operand (struct function *fn, tree *var_p, gimple *stmt, int flags)\n \tgimple_set_has_volatile_ops (stmt, true);\n \n       /* The variable is a memory access.  Add virtual operands.  */\n-      add_virtual_operand (fn, stmt, flags);\n+      add_virtual_operand (flags);\n     }\n }\n \n@@ -576,9 +645,8 @@ mark_address_taken (tree ref)\n \n    FLAGS is as in get_expr_operands.  */\n \n-static void\n-get_mem_ref_operands (struct function *fn,\n-\t\t      gimple *stmt, tree expr, int flags)\n+void\n+operands_scanner::get_mem_ref_operands (tree expr, int flags)\n {\n   tree *pptr = &TREE_OPERAND (expr, 0);\n \n@@ -587,41 +655,38 @@ get_mem_ref_operands (struct function *fn,\n     gimple_set_has_volatile_ops (stmt, true);\n \n   /* Add the VOP.  */\n-  add_virtual_operand (fn, stmt, flags);\n+  add_virtual_operand (flags);\n \n   /* If requested, add a USE operand for the base pointer.  */\n-  get_expr_operands (fn, stmt, pptr,\n+  get_expr_operands (pptr,\n \t\t     opf_non_addressable | opf_use\n \t\t     | (flags & (opf_no_vops|opf_not_non_addressable)));\n }\n \n \n /* A subroutine of get_expr_operands to handle TARGET_MEM_REF.  */\n \n-static void\n-get_tmr_operands (struct function *fn, gimple *stmt, tree expr, int flags)\n+void\n+operands_scanner::get_tmr_operands(tree expr, int flags)\n {\n   if (!(flags & opf_no_vops)\n       && TREE_THIS_VOLATILE (expr))\n     gimple_set_has_volatile_ops (stmt, true);\n \n   /* First record the real operands.  */\n-  get_expr_operands (fn, stmt,\n-\t\t     &TMR_BASE (expr), opf_use | (flags & opf_no_vops));\n-  get_expr_operands (fn, stmt,\n-\t\t     &TMR_INDEX (expr), opf_use | (flags & opf_no_vops));\n-  get_expr_operands (fn, stmt,\n-\t\t     &TMR_INDEX2 (expr), opf_use | (flags & opf_no_vops));\n-\n-  add_virtual_operand (fn, stmt, flags);\n+  get_expr_operands (&TMR_BASE (expr), opf_use | (flags & opf_no_vops));\n+  get_expr_operands (&TMR_INDEX (expr), opf_use | (flags & opf_no_vops));\n+  get_expr_operands (&TMR_INDEX2 (expr), opf_use | (flags & opf_no_vops));\n+\n+  add_virtual_operand (flags);\n }\n \n \n /* If STMT is a call that may clobber globals and other symbols that\n    escape, add them to the VDEF/VUSE lists for it.  */\n \n-static void\n-maybe_add_call_vops (struct function *fn, gcall *stmt)\n+void\n+operands_scanner::maybe_add_call_vops (gcall *stmt)\n {\n   int call_flags = gimple_call_flags (stmt);\n \n@@ -632,17 +697,17 @@ maybe_add_call_vops (struct function *fn, gcall *stmt)\n     {\n       /* A 'pure' or a 'const' function never call-clobbers anything.  */\n       if (!(call_flags & (ECF_PURE | ECF_CONST)))\n-\tadd_virtual_operand (fn, stmt, opf_def);\n+\tadd_virtual_operand (opf_def);\n       else if (!(call_flags & ECF_CONST))\n-\tadd_virtual_operand (fn, stmt, opf_use);\n+\tadd_virtual_operand (opf_use);\n     }\n }\n \n \n /* Scan operands in the ASM_EXPR stmt referred to in INFO.  */\n \n-static void\n-get_asm_stmt_operands (struct function *fn, gasm *stmt)\n+void\n+operands_scanner::get_asm_stmt_operands (gasm *stmt)\n {\n   size_t i, noutputs;\n   const char **oconstraints;\n@@ -669,8 +734,7 @@ get_asm_stmt_operands (struct function *fn, gasm *stmt)\n       if (!allows_reg && allows_mem)\n \tmark_address_taken (TREE_VALUE (link));\n \n-      get_expr_operands (fn, stmt,\n-\t\t\t &TREE_VALUE (link), opf_def | opf_not_non_addressable);\n+      get_expr_operands (&TREE_VALUE (link), opf_def | opf_not_non_addressable);\n     }\n \n   /* Gather all input operands.  */\n@@ -686,21 +750,21 @@ get_asm_stmt_operands (struct function *fn, gasm *stmt)\n       if (!allows_reg && allows_mem)\n \tmark_address_taken (TREE_VALUE (link));\n \n-      get_expr_operands (fn, stmt, &TREE_VALUE (link), opf_not_non_addressable);\n+      get_expr_operands (&TREE_VALUE (link), opf_not_non_addressable);\n     }\n \n   /* Clobber all memory and addressable symbols for asm (\"\" : : : \"memory\");  */\n   if (gimple_asm_clobbers_memory_p (stmt))\n-    add_virtual_operand (fn, stmt, opf_def);\n+    add_virtual_operand (opf_def);\n }\n \n \n /* Recursively scan the expression pointed to by EXPR_P in statement\n    STMT.  FLAGS is one of the OPF_* constants modifying how to\n    interpret the operands found.  */\n \n-static void\n-get_expr_operands (struct function *fn, gimple *stmt, tree *expr_p, int flags)\n+void\n+operands_scanner::get_expr_operands (tree *expr_p, int flags)\n {\n   enum tree_code code;\n   enum tree_code_class codeclass;\n@@ -734,7 +798,7 @@ get_expr_operands (struct function *fn, gimple *stmt, tree *expr_p, int flags)\n \t here are ARRAY_REF indices which will always be real operands\n \t (GIMPLE does not allow non-registers as array indices).  */\n       flags |= opf_no_vops;\n-      get_expr_operands (fn, stmt, &TREE_OPERAND (expr, 0),\n+      get_expr_operands (&TREE_OPERAND (expr, 0),\n \t\t\t flags | opf_not_non_addressable | opf_address_taken);\n       return;\n \n@@ -745,19 +809,19 @@ get_expr_operands (struct function *fn, gimple *stmt, tree *expr_p, int flags)\n     case STRING_CST:\n     case CONST_DECL:\n       if (!(flags & opf_address_taken))\n-\tadd_stmt_operand (fn, expr_p, stmt, flags);\n+\tadd_stmt_operand (expr_p, flags);\n       return;\n \n     case DEBUG_EXPR_DECL:\n       gcc_assert (gimple_debug_bind_p (stmt));\n       return;\n \n     case MEM_REF:\n-      get_mem_ref_operands (fn, stmt, expr, flags);\n+      get_mem_ref_operands (expr, flags);\n       return;\n \n     case TARGET_MEM_REF:\n-      get_tmr_operands (fn, stmt, expr, flags);\n+      get_tmr_operands (expr, flags);\n       return;\n \n     case ARRAY_REF:\n@@ -770,20 +834,20 @@ get_expr_operands (struct function *fn, gimple *stmt, tree *expr_p, int flags)\n \t    && TREE_THIS_VOLATILE (expr))\n \t  gimple_set_has_volatile_ops (stmt, true);\n \n-\tget_expr_operands (fn, stmt, &TREE_OPERAND (expr, 0), flags);\n+\tget_expr_operands (&TREE_OPERAND (expr, 0), flags);\n \n \tif (code == COMPONENT_REF)\n \t  {\n \t    if (!(flags & opf_no_vops)\n \t\t&& TREE_THIS_VOLATILE (TREE_OPERAND (expr, 1)))\n \t      gimple_set_has_volatile_ops (stmt, true);\n-\t    get_expr_operands (fn, stmt, &TREE_OPERAND (expr, 2), uflags);\n+\t    get_expr_operands (&TREE_OPERAND (expr, 2), uflags);\n \t  }\n \telse if (code == ARRAY_REF || code == ARRAY_RANGE_REF)\n \t  {\n-            get_expr_operands (fn, stmt, &TREE_OPERAND (expr, 1), uflags);\n-            get_expr_operands (fn, stmt, &TREE_OPERAND (expr, 2), uflags);\n-            get_expr_operands (fn, stmt, &TREE_OPERAND (expr, 3), uflags);\n+\t    get_expr_operands (&TREE_OPERAND (expr, 1), uflags);\n+\t    get_expr_operands (&TREE_OPERAND (expr, 2), uflags);\n+\t    get_expr_operands (&TREE_OPERAND (expr, 3), uflags);\n \t  }\n \n \treturn;\n@@ -792,16 +856,16 @@ get_expr_operands (struct function *fn, gimple *stmt, tree *expr_p, int flags)\n     case WITH_SIZE_EXPR:\n       /* WITH_SIZE_EXPR is a pass-through reference to its first argument,\n \t and an rvalue reference to its second argument.  */\n-      get_expr_operands (fn, stmt, &TREE_OPERAND (expr, 1), uflags);\n-      get_expr_operands (fn, stmt, &TREE_OPERAND (expr, 0), flags);\n+      get_expr_operands (&TREE_OPERAND (expr, 1), uflags);\n+      get_expr_operands (&TREE_OPERAND (expr, 0), flags);\n       return;\n \n     case COND_EXPR:\n     case VEC_COND_EXPR:\n     case VEC_PERM_EXPR:\n-      get_expr_operands (fn, stmt, &TREE_OPERAND (expr, 0), uflags);\n-      get_expr_operands (fn, stmt, &TREE_OPERAND (expr, 1), uflags);\n-      get_expr_operands (fn, stmt, &TREE_OPERAND (expr, 2), uflags);\n+      get_expr_operands (&TREE_OPERAND (expr, 0), uflags);\n+      get_expr_operands (&TREE_OPERAND (expr, 1), uflags);\n+      get_expr_operands (&TREE_OPERAND (expr, 2), uflags);\n       return;\n \n     case CONSTRUCTOR:\n@@ -821,7 +885,7 @@ get_expr_operands (struct function *fn, gimple *stmt, tree *expr_p, int flags)\n \tfor (idx = 0;\n \t     vec_safe_iterate (CONSTRUCTOR_ELTS (expr), idx, &ce);\n \t     idx++)\n-\t  get_expr_operands (fn, stmt, &ce->value, uflags);\n+\t  get_expr_operands (&ce->value, uflags);\n \n \treturn;\n       }\n@@ -834,7 +898,7 @@ get_expr_operands (struct function *fn, gimple *stmt, tree *expr_p, int flags)\n \n     case VIEW_CONVERT_EXPR:\n     do_unary:\n-      get_expr_operands (fn, stmt, &TREE_OPERAND (expr, 0), flags);\n+      get_expr_operands (&TREE_OPERAND (expr, 0), flags);\n       return;\n \n     case BIT_INSERT_EXPR:\n@@ -843,8 +907,8 @@ get_expr_operands (struct function *fn, gimple *stmt, tree *expr_p, int flags)\n     case ASSERT_EXPR:\n     do_binary:\n       {\n-\tget_expr_operands (fn, stmt, &TREE_OPERAND (expr, 0), flags);\n-\tget_expr_operands (fn, stmt, &TREE_OPERAND (expr, 1), flags);\n+\tget_expr_operands (&TREE_OPERAND (expr, 0), flags);\n+\tget_expr_operands (&TREE_OPERAND (expr, 1), flags);\n \treturn;\n       }\n \n@@ -854,9 +918,9 @@ get_expr_operands (struct function *fn, gimple *stmt, tree *expr_p, int flags)\n     case WIDEN_MULT_PLUS_EXPR:\n     case WIDEN_MULT_MINUS_EXPR:\n       {\n-\tget_expr_operands (fn, stmt, &TREE_OPERAND (expr, 0), flags);\n-\tget_expr_operands (fn, stmt, &TREE_OPERAND (expr, 1), flags);\n-\tget_expr_operands (fn, stmt, &TREE_OPERAND (expr, 2), flags);\n+\tget_expr_operands (&TREE_OPERAND (expr, 0), flags);\n+\tget_expr_operands (&TREE_OPERAND (expr, 1), flags);\n+\tget_expr_operands (&TREE_OPERAND (expr, 2), flags);\n \treturn;\n       }\n \n@@ -889,27 +953,27 @@ get_expr_operands (struct function *fn, gimple *stmt, tree *expr_p, int flags)\n /* Parse STMT looking for operands.  When finished, the various\n    build_* operand vectors will have potential operands in them.  */\n \n-static void\n-parse_ssa_operands (struct function *fn, gimple *stmt)\n+void\n+operands_scanner::parse_ssa_operands ()\n {\n   enum gimple_code code = gimple_code (stmt);\n   size_t i, n, start = 0;\n \n   switch (code)\n     {\n     case GIMPLE_ASM:\n-      get_asm_stmt_operands (fn, as_a <gasm *> (stmt));\n+      get_asm_stmt_operands (as_a <gasm *> (stmt));\n       break;\n \n     case GIMPLE_TRANSACTION:\n       /* The start of a transaction is a memory barrier.  */\n-      add_virtual_operand (fn, stmt, opf_def | opf_use);\n+      add_virtual_operand (opf_def | opf_use);\n       break;\n \n     case GIMPLE_DEBUG:\n       if (gimple_debug_bind_p (stmt)\n \t  && gimple_debug_bind_has_value_p (stmt))\n-\tget_expr_operands (fn, stmt, gimple_debug_bind_get_value_ptr (stmt),\n+\tget_expr_operands (gimple_debug_bind_get_value_ptr (stmt),\n \t\t\t   opf_use | opf_no_vops);\n       break;\n \n@@ -919,41 +983,41 @@ parse_ssa_operands (struct function *fn, gimple *stmt)\n \n     case GIMPLE_CALL:\n       /* Add call-clobbered operands, if needed.  */\n-      maybe_add_call_vops (fn, as_a <gcall *> (stmt));\n+      maybe_add_call_vops (as_a <gcall *> (stmt));\n       /* FALLTHRU */\n \n     case GIMPLE_ASSIGN:\n-      get_expr_operands (fn, stmt, gimple_op_ptr (stmt, 0), opf_def);\n+      get_expr_operands (gimple_op_ptr (stmt, 0), opf_def);\n       start = 1;\n       /* FALLTHRU */\n \n     default:\n     do_default:\n       n = gimple_num_ops (stmt);\n       for (i = start; i < n; i++)\n-\tget_expr_operands (fn, stmt, gimple_op_ptr (stmt, i), opf_use);\n+\tget_expr_operands (gimple_op_ptr (stmt, i), opf_use);\n       break;\n     }\n }\n \n \n /* Create an operands cache for STMT.  */\n \n-static void\n-build_ssa_operands (struct function *fn, gimple *stmt)\n+void\n+operands_scanner::build_ssa_operands ()\n {\n   /* Initially assume that the statement has no volatile operands.  */\n   gimple_set_has_volatile_ops (stmt, false);\n \n   start_ssa_stmt_operands ();\n-  parse_ssa_operands (fn, stmt);\n-  finalize_ssa_stmt_operands (fn, stmt);\n+  parse_ssa_operands ();\n+  finalize_ssa_stmt_operands ();\n }\n \n /* Verifies SSA statement operands.  */\n \n DEBUG_FUNCTION bool\n-verify_ssa_operands (struct function *fn, gimple *stmt)\n+operands_scanner::verify_ssa_operands ()\n {\n   use_operand_p use_p;\n   def_operand_p def_p;\n@@ -965,7 +1029,7 @@ verify_ssa_operands (struct function *fn, gimple *stmt)\n   /* build_ssa_operands w/o finalizing them.  */\n   gimple_set_has_volatile_ops (stmt, false);\n   start_ssa_stmt_operands ();\n-  parse_ssa_operands (fn, stmt);\n+  parse_ssa_operands ();\n \n   /* Now verify the built operands are the same as present in STMT.  */\n   def = gimple_vdef (stmt);\n@@ -1040,6 +1104,14 @@ verify_ssa_operands (struct function *fn, gimple *stmt)\n   return false;\n }\n \n+/* Interface for external use.  */\n+\n+DEBUG_FUNCTION bool\n+verify_ssa_operands (struct function *fn, gimple *stmt)\n+{\n+  return operands_scanner (fn, stmt).verify_ssa_operands ();\n+}\n+\n \n /* Releases the operands of STMT back to their freelists, and clears\n    the stmt operand lists.  */\n@@ -1080,7 +1152,7 @@ update_stmt_operands (struct function *fn, gimple *stmt)\n   timevar_push (TV_TREE_OPS);\n \n   gcc_assert (gimple_modified_p (stmt));\n-  build_ssa_operands (fn, stmt);\n+  operands_scanner (fn, stmt).build_ssa_operands ();\n   gimple_set_modified (stmt, false);\n \n   timevar_pop (TV_TREE_OPS);"}]}