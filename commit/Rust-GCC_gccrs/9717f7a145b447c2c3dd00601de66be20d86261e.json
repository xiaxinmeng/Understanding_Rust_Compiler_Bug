{"sha": "9717f7a145b447c2c3dd00601de66be20d86261e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTcxN2Y3YTE0NWI0NDdjMmMzZGQwMDYwMWRlNjZiZTIwZDg2MjYxZQ==", "commit": {"author": {"name": "Janus Weil", "email": "janus@gcc.gnu.org", "date": "2012-07-17T21:51:20Z"}, "committer": {"name": "Janus Weil", "email": "janus@gcc.gnu.org", "date": "2012-07-17T21:51:20Z"}, "message": "re PR fortran/51081 ([F03] Proc-pointer assignment: Rejects valid internal proc)\n\n2012-07-17  Janus Weil  <janus@gcc.gnu.org>\n\n\tPR fortran/51081\n\t* error.c (gfc_notify_std): Automatically print the relevant Fortran\n\tstandard version.\n\t* arith.c (arith_power): Remove explicit standard reference string.\n\t* array.c (gfc_match_array_spec, gfc_match_array_constructor): Ditto.\n\t* check.c (gfc_check_a_p, gfc_check_besn, gfc_check_count,\n\tgfc_check_float, gfc_check_fn_rc2008, gfc_check_iand,\n\tgfc_check_ichar_iachar, gfc_check_ieor, gfc_check_index, gfc_check_ior,\n\tgfc_check_lbound, gfc_check_len_lentrim, check_rest, gfc_check_min_max,\n\tgfc_check_null, gfc_check_scan, gfc_check_selected_real_kind,\n\tgfc_check_shape, gfc_check_size, gfc_check_sngl, gfc_check_ubound,\n\tgfc_check_verify): Ditto.\n\t* data.c (gfc_assign_data_value): Ditto.\n\t* decl.c (var_element, char_len_param_value, match_char_length,\n\tgfc_verify_c_interop_param, match_pointer_init, variable_decl,\n\tgfc_match_decl_type_spec, gfc_match_import, match_attr_spec, \n\tgfc_match_prefix, gfc_match_suffix, match_ppc_decl,\n\tmatch_procedure_in_interface, gfc_match_procedure,gfc_match_entry,\n\tgfc_match_subroutine, gfc_match_end, gfc_match_codimension,\n\tgfc_match_protected, gfc_match_value, gfc_match_volatile,\n\tgfc_match_asynchronous, gfc_match_modproc, gfc_get_type_attr_spec,\n\tgfc_match_enum, match_procedure_in_type): Ditto.\n\t* expr.c (check_elemental, gfc_check_assign, gfc_check_pointer_assign):\n\tDitto.\n\t* interface.c (gfc_match_abstract_interface, check_interface0): Ditto.\n\t* intrinsic.c (gfc_intrinsic_func_interface): Ditto.\n\t* io.c (format_lex, resolve_tag_format, resolve_tag,\n\tcompare_to_allowed_values, gfc_match_open, gfc_match_rewind,\n\tgfc_resolve_dt, gfc_match_wait): Ditto.\n\t* match.c (match_arithmetic_if, gfc_match_if, gfc_match_critical,\n\tgfc_match_do, match_exit_cycle, gfc_match_pause, gfc_match_stop,\n\tgfc_match_lock, sync_statement, gfc_match_assign, gfc_match_goto,\n\tgfc_match_allocate, gfc_match_return, gfc_match_st_function): Ditto.\n\t* module.c (gfc_match_use, gfc_use_module): Ditto.\n\t* parse.c (parse_derived_contains, parse_block_construct,\n\tparse_associate, parse_contained): Ditto.\n\t* primary.c (match_hollerith_constant, match_boz_constant,\n\tmatch_real_constant, match_sym_complex_part, match_arg_list_function,\n\tbuild_actual_constructor, gfc_convert_to_structure_constructor): Ditto.\n\t* resolve.c (resolve_formal_arglist, resolve_entries,\n\tresolve_common_blocks, resolve_actual_arglist, gfc_resolve_index_1,\n\tgfc_resolve_iterator_expr, resolve_ordinary_assign,\n\tresolve_fl_var_and_proc, resolve_fl_variable_derived,\n\tresolve_fl_procedure, resolve_fl_derived0, resolve_fl_derived,\n\tresolve_fl_namelist, resolve_symbol, resolve_fntype): Ditto.\n\t* symbol.c (check_conflict, conflict, gfc_add_is_bind_c,\n\tgfc_add_extension, gfc_check_symbol_typed): Ditto.\n\nFrom-SVN: r189589", "tree": {"sha": "febd4dbe9cfa04d1ec5bd70ba1e7499e1bead258", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/febd4dbe9cfa04d1ec5bd70ba1e7499e1bead258"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9717f7a145b447c2c3dd00601de66be20d86261e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9717f7a145b447c2c3dd00601de66be20d86261e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9717f7a145b447c2c3dd00601de66be20d86261e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9717f7a145b447c2c3dd00601de66be20d86261e/comments", "author": {"login": "janusw", "id": 484108, "node_id": "MDQ6VXNlcjQ4NDEwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/484108?v=4", "gravatar_id": "", "url": "https://api.github.com/users/janusw", "html_url": "https://github.com/janusw", "followers_url": "https://api.github.com/users/janusw/followers", "following_url": "https://api.github.com/users/janusw/following{/other_user}", "gists_url": "https://api.github.com/users/janusw/gists{/gist_id}", "starred_url": "https://api.github.com/users/janusw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/janusw/subscriptions", "organizations_url": "https://api.github.com/users/janusw/orgs", "repos_url": "https://api.github.com/users/janusw/repos", "events_url": "https://api.github.com/users/janusw/events{/privacy}", "received_events_url": "https://api.github.com/users/janusw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "janusw", "id": 484108, "node_id": "MDQ6VXNlcjQ4NDEwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/484108?v=4", "gravatar_id": "", "url": "https://api.github.com/users/janusw", "html_url": "https://github.com/janusw", "followers_url": "https://api.github.com/users/janusw/followers", "following_url": "https://api.github.com/users/janusw/following{/other_user}", "gists_url": "https://api.github.com/users/janusw/gists{/gist_id}", "starred_url": "https://api.github.com/users/janusw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/janusw/subscriptions", "organizations_url": "https://api.github.com/users/janusw/orgs", "repos_url": "https://api.github.com/users/janusw/repos", "events_url": "https://api.github.com/users/janusw/events{/privacy}", "received_events_url": "https://api.github.com/users/janusw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "697c474c8fadce131f79b662a79a454959d02c39", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/697c474c8fadce131f79b662a79a454959d02c39", "html_url": "https://github.com/Rust-GCC/gccrs/commit/697c474c8fadce131f79b662a79a454959d02c39"}], "stats": {"total": 476, "additions": 283, "deletions": 193}, "files": [{"sha": "0f5e403ceaaf60aefc5006ab037c781e85253e65", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9717f7a145b447c2c3dd00601de66be20d86261e/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9717f7a145b447c2c3dd00601de66be20d86261e/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=9717f7a145b447c2c3dd00601de66be20d86261e", "patch": "@@ -1,3 +1,53 @@\n+2012-07-17  Janus Weil  <janus@gcc.gnu.org>\n+\n+\tPR fortran/51081\n+\t* error.c (gfc_notify_std): Automatically print the relevant Fortran\n+\tstandard version.\n+\t* arith.c (arith_power): Remove explicit standard reference string.\n+\t* array.c (gfc_match_array_spec, gfc_match_array_constructor): Ditto.\n+\t* check.c (gfc_check_a_p, gfc_check_besn, gfc_check_count,\n+\tgfc_check_float, gfc_check_fn_rc2008, gfc_check_iand,\n+\tgfc_check_ichar_iachar, gfc_check_ieor, gfc_check_index, gfc_check_ior,\n+\tgfc_check_lbound, gfc_check_len_lentrim, check_rest, gfc_check_min_max,\n+\tgfc_check_null, gfc_check_scan, gfc_check_selected_real_kind,\n+\tgfc_check_shape, gfc_check_size, gfc_check_sngl, gfc_check_ubound,\n+\tgfc_check_verify): Ditto.\n+\t* data.c (gfc_assign_data_value): Ditto.\n+\t* decl.c (var_element, char_len_param_value, match_char_length,\n+\tgfc_verify_c_interop_param, match_pointer_init, variable_decl,\n+\tgfc_match_decl_type_spec, gfc_match_import, match_attr_spec, \n+\tgfc_match_prefix, gfc_match_suffix, match_ppc_decl,\n+\tmatch_procedure_in_interface, gfc_match_procedure,gfc_match_entry,\n+\tgfc_match_subroutine, gfc_match_end, gfc_match_codimension,\n+\tgfc_match_protected, gfc_match_value, gfc_match_volatile,\n+\tgfc_match_asynchronous, gfc_match_modproc, gfc_get_type_attr_spec,\n+\tgfc_match_enum, match_procedure_in_type): Ditto.\n+\t* expr.c (check_elemental, gfc_check_assign, gfc_check_pointer_assign):\n+\tDitto.\n+\t* interface.c (gfc_match_abstract_interface, check_interface0): Ditto.\n+\t* intrinsic.c (gfc_intrinsic_func_interface): Ditto.\n+\t* io.c (format_lex, resolve_tag_format, resolve_tag,\n+\tcompare_to_allowed_values, gfc_match_open, gfc_match_rewind,\n+\tgfc_resolve_dt, gfc_match_wait): Ditto.\n+\t* match.c (match_arithmetic_if, gfc_match_if, gfc_match_critical,\n+\tgfc_match_do, match_exit_cycle, gfc_match_pause, gfc_match_stop,\n+\tgfc_match_lock, sync_statement, gfc_match_assign, gfc_match_goto,\n+\tgfc_match_allocate, gfc_match_return, gfc_match_st_function): Ditto.\n+\t* module.c (gfc_match_use, gfc_use_module): Ditto.\n+\t* parse.c (parse_derived_contains, parse_block_construct,\n+\tparse_associate, parse_contained): Ditto.\n+\t* primary.c (match_hollerith_constant, match_boz_constant,\n+\tmatch_real_constant, match_sym_complex_part, match_arg_list_function,\n+\tbuild_actual_constructor, gfc_convert_to_structure_constructor): Ditto.\n+\t* resolve.c (resolve_formal_arglist, resolve_entries,\n+\tresolve_common_blocks, resolve_actual_arglist, gfc_resolve_index_1,\n+\tgfc_resolve_iterator_expr, resolve_ordinary_assign,\n+\tresolve_fl_var_and_proc, resolve_fl_variable_derived,\n+\tresolve_fl_procedure, resolve_fl_derived0, resolve_fl_derived,\n+\tresolve_fl_namelist, resolve_symbol, resolve_fntype): Ditto.\n+\t* symbol.c (check_conflict, conflict, gfc_add_is_bind_c,\n+\tgfc_add_extension, gfc_check_symbol_typed): Ditto.\n+\n 2012-07-17  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/53985"}, {"sha": "6fa7c70fe9cec0bdb8098848da2c6431a2435663", "filename": "gcc/fortran/arith.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9717f7a145b447c2c3dd00601de66be20d86261e/gcc%2Ffortran%2Farith.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9717f7a145b447c2c3dd00601de66be20d86261e/gcc%2Ffortran%2Farith.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Farith.c?ref=9717f7a145b447c2c3dd00601de66be20d86261e", "patch": "@@ -903,7 +903,7 @@ arith_power (gfc_expr *op1, gfc_expr *op2, gfc_expr **resultp)\n \n       if (gfc_init_expr_flag)\n \t{\n-\t  if (gfc_notify_std (GFC_STD_F2003,\"Fortran 2003: Noninteger \"\n+\t  if (gfc_notify_std (GFC_STD_F2003, \"Noninteger \"\n \t\t\t      \"exponent in an initialization \"\n \t\t\t      \"expression at %L\", &op2->where) == FAILURE)\n \t    return ARITH_PROHIBIT;\n@@ -925,7 +925,7 @@ arith_power (gfc_expr *op1, gfc_expr *op2, gfc_expr **resultp)\n       {\n \tif (gfc_init_expr_flag)\n \t  {\n-\t    if (gfc_notify_std (GFC_STD_F2003,\"Fortran 2003: Noninteger \"\n+\t    if (gfc_notify_std (GFC_STD_F2003, \"Noninteger \"\n \t\t\t\t\"exponent in an initialization \"\n \t\t\t\t\"expression at %L\", &op2->where) == FAILURE)\n \t      return ARITH_PROHIBIT;"}, {"sha": "b8523624fafc4ba40b33465e9331b6f5cb68f8a9", "filename": "gcc/fortran/array.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9717f7a145b447c2c3dd00601de66be20d86261e/gcc%2Ffortran%2Farray.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9717f7a145b447c2c3dd00601de66be20d86261e/gcc%2Ffortran%2Farray.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Farray.c?ref=9717f7a145b447c2c3dd00601de66be20d86261e", "patch": "@@ -555,7 +555,7 @@ gfc_match_array_spec (gfc_array_spec **asp, bool match_dim, bool match_codim)\n \t}\n \n       if (as->corank + as->rank >= 7\n-\t  && gfc_notify_std (GFC_STD_F2008, \"Fortran 2008: Array \"\n+\t  && gfc_notify_std (GFC_STD_F2008, \"Array \"\n \t\t\t     \"specification at %C with more than 7 dimensions\")\n \t     == FAILURE)\n \tgoto cleanup;\n@@ -568,7 +568,7 @@ gfc_match_array_spec (gfc_array_spec **asp, bool match_dim, bool match_codim)\n   if (gfc_match_char ('[')  != MATCH_YES)\n     goto done;\n \n-  if (gfc_notify_std (GFC_STD_F2008, \"Fortran 2008: Coarray declaration at %C\")\n+  if (gfc_notify_std (GFC_STD_F2008, \"Coarray declaration at %C\")\n       == FAILURE)\n     goto cleanup;\n \n@@ -1027,7 +1027,7 @@ gfc_match_array_constructor (gfc_expr **result)\n \treturn MATCH_NO;\n       else\n \t{\n-\t  if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: [...] \"\n+\t  if (gfc_notify_std (GFC_STD_F2003, \"[...] \"\n \t\t\t      \"style array constructors at %C\") == FAILURE)\n \t    return MATCH_ERROR;\n \t  end_delim = \" ]\";\n@@ -1047,7 +1047,7 @@ gfc_match_array_constructor (gfc_expr **result)\n \n       if (seen_ts)\n \t{\n-\t  if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: Array constructor \"\n+\t  if (gfc_notify_std (GFC_STD_F2003, \"Array constructor \"\n \t\t\t      \"including type specification at %C\") == FAILURE)\n \t    goto cleanup;\n "}, {"sha": "bfd12057632eaec1b5a225b08bac3fd325d7c948", "filename": "gcc/fortran/check.c", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9717f7a145b447c2c3dd00601de66be20d86261e/gcc%2Ffortran%2Fcheck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9717f7a145b447c2c3dd00601de66be20d86261e/gcc%2Ffortran%2Fcheck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fcheck.c?ref=9717f7a145b447c2c3dd00601de66be20d86261e", "patch": "@@ -862,7 +862,7 @@ gfc_check_a_p (gfc_expr *a, gfc_expr *p)\n \n   if (a->ts.kind != p->ts.kind)\n     {\n-      if (gfc_notify_std (GFC_STD_GNU, \"Extension: Different type kinds at %L\",\n+      if (gfc_notify_std (GFC_STD_GNU, \"Different type kinds at %L\",\n \t\t\t  &p->where) == FAILURE)\n        return FAILURE;\n     }\n@@ -1081,7 +1081,7 @@ gfc_check_besn (gfc_expr *n, gfc_expr *x)\n     {\n       int i;\n       gfc_extract_int (n, &i);\n-      if (i < 0 && gfc_notify_std (GFC_STD_GNU, \"Extension: Negative argument \"\n+      if (i < 0 && gfc_notify_std (GFC_STD_GNU, \"Negative argument \"\n \t\t\t\t   \"N at %L\", &n->where) == FAILURE)\n \treturn FAILURE;\n     }\n@@ -1306,7 +1306,7 @@ gfc_check_count (gfc_expr *mask, gfc_expr *dim, gfc_expr *kind)\n     return FAILURE;\n   if (kind_check (kind, 2, BT_INTEGER) == FAILURE)\n     return FAILURE;\n-  if (kind && gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: '%s' intrinsic \"\n+  if (kind && gfc_notify_std (GFC_STD_F2003, \"'%s' intrinsic \"\n \t\t\t      \"with KIND argument at %L\",\n \t\t\t      gfc_current_intrinsic, &kind->where) == FAILURE)\n     return FAILURE;\n@@ -1664,7 +1664,7 @@ gfc_check_float (gfc_expr *a)\n     return FAILURE;\n \n   if ((a->ts.kind != gfc_default_integer_kind)\n-      && gfc_notify_std (GFC_STD_GNU, \"GNU extension: non-default INTEGER \"\n+      && gfc_notify_std (GFC_STD_GNU, \"non-default INTEGER \"\n \t\t\t \"kind argument to %s intrinsic at %L\",\n \t\t\t gfc_current_intrinsic, &a->where) == FAILURE\t)\n     return FAILURE;\n@@ -1724,7 +1724,7 @@ gfc_check_fn_rc2008 (gfc_expr *a)\n     return FAILURE;\n \n   if (a->ts.type == BT_COMPLEX\n-      && gfc_notify_std (GFC_STD_F2008, \"Fortran 2008: COMPLEX argument '%s' \"\n+      && gfc_notify_std (GFC_STD_F2008, \"COMPLEX argument '%s' \"\n \t\t\t \"argument of '%s' intrinsic at %L\",\n \t\t\t gfc_current_intrinsic_arg[0]->name,\n \t\t\t gfc_current_intrinsic, &a->where) == FAILURE)\n@@ -1792,7 +1792,7 @@ gfc_check_iand (gfc_expr *i, gfc_expr *j)\n \n   if (i->ts.kind != j->ts.kind)\n     {\n-      if (gfc_notify_std (GFC_STD_GNU, \"Extension: Different type kinds at %L\",\n+      if (gfc_notify_std (GFC_STD_GNU, \"Different type kinds at %L\",\n \t\t\t  &i->where) == FAILURE)\n \treturn FAILURE;\n     }\n@@ -1837,7 +1837,7 @@ gfc_check_ichar_iachar (gfc_expr *c, gfc_expr *kind)\n   if (kind_check (kind, 1, BT_INTEGER) == FAILURE)\n     return FAILURE;\n \n-  if (kind && gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: '%s' intrinsic \"\n+  if (kind && gfc_notify_std (GFC_STD_F2003, \"'%s' intrinsic \"\n \t\t\t      \"with KIND argument at %L\",\n \t\t\t      gfc_current_intrinsic, &kind->where) == FAILURE)\n     return FAILURE;\n@@ -1918,7 +1918,7 @@ gfc_check_ieor (gfc_expr *i, gfc_expr *j)\n \n   if (i->ts.kind != j->ts.kind)\n     {\n-      if (gfc_notify_std (GFC_STD_GNU, \"Extension: Different type kinds at %L\",\n+      if (gfc_notify_std (GFC_STD_GNU, \"Different type kinds at %L\",\n \t\t\t  &i->where) == FAILURE)\n \treturn FAILURE;\n     }\n@@ -1940,7 +1940,7 @@ gfc_check_index (gfc_expr *string, gfc_expr *substring, gfc_expr *back,\n \n   if (kind_check (kind, 3, BT_INTEGER) == FAILURE)\n     return FAILURE;\n-  if (kind && gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: '%s' intrinsic \"\n+  if (kind && gfc_notify_std (GFC_STD_F2003, \"'%s' intrinsic \"\n \t\t\t      \"with KIND argument at %L\",\n \t\t\t      gfc_current_intrinsic, &kind->where) == FAILURE)\n     return FAILURE;\n@@ -1992,7 +1992,7 @@ gfc_check_ior (gfc_expr *i, gfc_expr *j)\n \n   if (i->ts.kind != j->ts.kind)\n     {\n-      if (gfc_notify_std (GFC_STD_GNU, \"Extension: Different type kinds at %L\",\n+      if (gfc_notify_std (GFC_STD_GNU, \"Different type kinds at %L\",\n \t\t\t  &i->where) == FAILURE)\n \treturn FAILURE;\n     }\n@@ -2134,7 +2134,7 @@ gfc_check_lbound (gfc_expr *array, gfc_expr *dim, gfc_expr *kind)\n \n   if (kind_check (kind, 2, BT_INTEGER) == FAILURE)\n     return FAILURE;\n-  if (kind && gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: '%s' intrinsic \"\n+  if (kind && gfc_notify_std (GFC_STD_F2003, \"'%s' intrinsic \"\n \t\t\t      \"with KIND argument at %L\",\n \t\t\t      gfc_current_intrinsic, &kind->where) == FAILURE)\n     return FAILURE;\n@@ -2179,7 +2179,7 @@ gfc_check_len_lentrim (gfc_expr *s, gfc_expr *kind)\n \n   if (kind_check (kind, 1, BT_INTEGER) == FAILURE)\n     return FAILURE;\n-  if (kind && gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: '%s' intrinsic \"\n+  if (kind && gfc_notify_std (GFC_STD_F2003, \"'%s' intrinsic \"\n \t\t\t      \"with KIND argument at %L\",\n \t\t\t      gfc_current_intrinsic, &kind->where) == FAILURE)\n     return FAILURE;\n@@ -2344,7 +2344,7 @@ check_rest (bt type, int kind, gfc_actual_arglist *arglist)\n \t{\n \t  if (x->ts.type == type)\n \t    {\n-\t      if (gfc_notify_std (GFC_STD_GNU, \"Extension: Different type \"\n+\t      if (gfc_notify_std (GFC_STD_GNU, \"Different type \"\n \t\t\t\t  \"kinds at %L\", &x->where) == FAILURE)\n \t\treturn FAILURE;\n \t    }\n@@ -2381,7 +2381,7 @@ gfc_check_min_max (gfc_actual_arglist *arg)\n \n   if (x->ts.type == BT_CHARACTER)\n     {\n-      if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: '%s' intrinsic \"\n+      if (gfc_notify_std (GFC_STD_F2003, \"'%s' intrinsic \"\n \t\t\t  \"with CHARACTER argument at %L\",\n \t\t\t  gfc_current_intrinsic, &x->where) == FAILURE)\n \treturn FAILURE;\n@@ -2863,7 +2863,7 @@ gfc_check_null (gfc_expr *mold)\n     }\n \n   if (attr.allocatable\n-      && gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: NULL intrinsic with \"\n+      && gfc_notify_std (GFC_STD_F2003, \"NULL intrinsic with \"\n \t\t\t \"allocatable MOLD at %L\", &mold->where) == FAILURE)\n     return FAILURE;\n \n@@ -3399,7 +3399,7 @@ gfc_check_scan (gfc_expr *x, gfc_expr *y, gfc_expr *z, gfc_expr *kind)\n \n   if (kind_check (kind, 3, BT_INTEGER) == FAILURE)\n     return FAILURE;\n-  if (kind && gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: '%s' intrinsic \"\n+  if (kind && gfc_notify_std (GFC_STD_F2003, \"'%s' intrinsic \"\n \t\t\t      \"with KIND argument at %L\",\n \t\t\t      gfc_current_intrinsic, &kind->where) == FAILURE)\n     return FAILURE;\n@@ -3460,7 +3460,7 @@ gfc_try\n gfc_check_selected_real_kind (gfc_expr *p, gfc_expr *r, gfc_expr *radix)\n {\n   if (p == NULL && r == NULL\n-      && gfc_notify_std (GFC_STD_F2008, \"Fortran 2008: SELECTED_REAL_KIND with\"\n+      && gfc_notify_std (GFC_STD_F2008, \"SELECTED_REAL_KIND with\"\n \t\t\t \" neither 'P' nor 'R' argument at %L\",\n \t\t\t gfc_current_intrinsic_where) == FAILURE)\n     return FAILURE;\n@@ -3491,7 +3491,7 @@ gfc_check_selected_real_kind (gfc_expr *p, gfc_expr *r, gfc_expr *radix)\n       if (scalar_check (radix, 1) == FAILURE)\n \treturn FAILURE;\n \n-      if (gfc_notify_std (GFC_STD_F2008, \"Fortran 2008: '%s' intrinsic with \"\n+      if (gfc_notify_std (GFC_STD_F2008, \"'%s' intrinsic with \"\n \t\t\t  \"RADIX argument at %L\", gfc_current_intrinsic,\n \t\t\t  &radix->where) == FAILURE)\n \treturn FAILURE;\n@@ -3533,7 +3533,7 @@ gfc_check_shape (gfc_expr *source, gfc_expr *kind)\n \n   if (kind_check (kind, 1, BT_INTEGER) == FAILURE)\n     return FAILURE;\n-  if (kind && gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: '%s' intrinsic \"\n+  if (kind && gfc_notify_std (GFC_STD_F2003, \"'%s' intrinsic \"\n \t\t\t      \"with KIND argument at %L\",\n \t\t\t      gfc_current_intrinsic, &kind->where) == FAILURE)\n     return FAILURE;\n@@ -3588,7 +3588,7 @@ gfc_check_size (gfc_expr *array, gfc_expr *dim, gfc_expr *kind)\n \n   if (kind_check (kind, 2, BT_INTEGER) == FAILURE)\n     return FAILURE;\n-  if (kind && gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: '%s' intrinsic \"\n+  if (kind && gfc_notify_std (GFC_STD_F2003, \"'%s' intrinsic \"\n \t\t\t      \"with KIND argument at %L\",\n \t\t\t      gfc_current_intrinsic, &kind->where) == FAILURE)\n     return FAILURE;\n@@ -3646,7 +3646,7 @@ gfc_check_sngl (gfc_expr *a)\n     return FAILURE;\n \n   if ((a->ts.kind != gfc_default_double_kind)\n-      && gfc_notify_std (GFC_STD_GNU, \"GNU extension: non double precision \"\n+      && gfc_notify_std (GFC_STD_GNU, \"non double precision \"\n \t\t\t \"REAL argument to %s intrinsic at %L\",\n \t\t\t gfc_current_intrinsic, &a->where) == FAILURE)\n     return FAILURE;\n@@ -4127,7 +4127,7 @@ gfc_check_ubound (gfc_expr *array, gfc_expr *dim, gfc_expr *kind)\n \n   if (kind_check (kind, 2, BT_INTEGER) == FAILURE)\n     return FAILURE;\n-  if (kind && gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: '%s' intrinsic \"\n+  if (kind && gfc_notify_std (GFC_STD_F2003, \"'%s' intrinsic \"\n \t\t\t      \"with KIND argument at %L\",\n \t\t\t      gfc_current_intrinsic, &kind->where) == FAILURE)\n     return FAILURE;\n@@ -4256,7 +4256,7 @@ gfc_check_verify (gfc_expr *x, gfc_expr *y, gfc_expr *z, gfc_expr *kind)\n \n   if (kind_check (kind, 3, BT_INTEGER) == FAILURE)\n     return FAILURE;\n-  if (kind && gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: '%s' intrinsic \"\n+  if (kind && gfc_notify_std (GFC_STD_F2003, \"'%s' intrinsic \"\n \t\t\t      \"with KIND argument at %L\",\n \t\t\t      gfc_current_intrinsic, &kind->where) == FAILURE)\n     return FAILURE;"}, {"sha": "385ca898dcd44cb78a9f21ff52f4b2307d8fcc13", "filename": "gcc/fortran/data.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9717f7a145b447c2c3dd00601de66be20d86261e/gcc%2Ffortran%2Fdata.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9717f7a145b447c2c3dd00601de66be20d86261e/gcc%2Ffortran%2Fdata.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdata.c?ref=9717f7a145b447c2c3dd00601de66be20d86261e", "patch": "@@ -315,7 +315,7 @@ gfc_assign_data_value (gfc_expr *lvalue, gfc_expr *rvalue, mpz_t index,\n \t\t  exprd = (LOCATION_LINE (con->expr->where.lb->location)\n \t\t\t   > LOCATION_LINE (rvalue->where.lb->location))\n \t\t\t  ? con->expr : rvalue;\n-\t\t  if (gfc_notify_std (GFC_STD_GNU,\"Extension: \"\n+\t\t  if (gfc_notify_std (GFC_STD_GNU,\n \t\t\t\t      \"re-initialization of '%s' at %L\",\n \t\t\t\t      symbol->name, &exprd->where) == FAILURE)\n \t\t    return FAILURE;\n@@ -481,7 +481,7 @@ gfc_assign_data_value (gfc_expr *lvalue, gfc_expr *rvalue, mpz_t index,\n \t  expr = (LOCATION_LINE (init->where.lb->location)\n \t\t  > LOCATION_LINE (rvalue->where.lb->location))\n \t       ? init : rvalue;\n-\t  if (gfc_notify_std (GFC_STD_GNU,\"Extension: \"\n+\t  if (gfc_notify_std (GFC_STD_GNU,\n \t\t\t      \"re-initialization of '%s' at %L\",\n \t\t\t      symbol->name, &expr->where) == FAILURE)\n \t    return FAILURE;"}, {"sha": "01693ad4cb0f744e074b957196484120e7daef47", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9717f7a145b447c2c3dd00601de66be20d86261e/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9717f7a145b447c2c3dd00601de66be20d86261e/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=9717f7a145b447c2c3dd00601de66be20d86261e", "patch": "@@ -269,7 +269,7 @@ var_element (gfc_data_variable *new_var)\n \n   if (gfc_current_state () != COMP_BLOCK_DATA\n       && sym->attr.in_common\n-      && gfc_notify_std (GFC_STD_GNU, \"Extension: initialization of \"\n+      && gfc_notify_std (GFC_STD_GNU, \"initialization of \"\n \t\t\t \"common block variable '%s' in DATA statement at %C\",\n \t\t\t sym->name) == FAILURE)\n     return MATCH_ERROR;\n@@ -677,7 +677,7 @@ char_len_param_value (gfc_expr **expr, bool *deferred)\n \n   if (gfc_match_char (':') == MATCH_YES)\n     {\n-      if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: deferred type \"\n+      if (gfc_notify_std (GFC_STD_F2003, \"deferred type \"\n \t\t\t  \"parameter at %C\") == FAILURE)\n \treturn MATCH_ERROR;\n \n@@ -740,7 +740,7 @@ match_char_length (gfc_expr **expr, bool *deferred, bool obsolenscent_check)\n   if (m == MATCH_YES)\n     {\n       if (obsolenscent_check\n-\t  && gfc_notify_std (GFC_STD_F95_OBS, \"Obsolescent feature: \"\n+\t  && gfc_notify_std (GFC_STD_F95_OBS,\n \t\t\t     \"Old-style character length at %C\") == FAILURE)\n \treturn MATCH_ERROR;\n       *expr = gfc_get_int_expr (gfc_default_integer_kind, NULL, length);\n@@ -1083,7 +1083,7 @@ gfc_verify_c_interop_param (gfc_symbol *sym)\n \t      retval = FAILURE;\n \t    }\n \t  else if (sym->attr.optional == 1\n-\t\t   && gfc_notify_std (GFC_STD_F2008_TS, \"TS29113: Variable '%s' \"\n+\t\t   && gfc_notify_std (GFC_STD_F2008_TS, \"Variable '%s' \"\n \t\t\t\t      \"at %L with OPTIONAL attribute in \"\n \t\t\t\t      \"procedure '%s' which is BIND(C)\",\n \t\t\t\t      sym->name, &(sym->declared_at),\n@@ -1739,7 +1739,7 @@ match_pointer_init (gfc_expr **init, int procptr)\n   if (!procptr)\n     gfc_resolve_expr (*init);\n   \n-  if (gfc_notify_std (GFC_STD_F2008, \"Fortran 2008: non-NULL pointer \"\n+  if (gfc_notify_std (GFC_STD_F2008, \"non-NULL pointer \"\n \t\t      \"initialization at %C\") == FAILURE)\n     return MATCH_ERROR;\n \n@@ -1836,7 +1836,7 @@ variable_decl (int elem)\n \n       if (as->type == AS_IMPLIED_SHAPE\n \t  && gfc_notify_std (GFC_STD_F2008,\n-\t\t\t     \"Fortran 2008: Implied-shape array at %L\",\n+\t\t\t     \"Implied-shape array at %L\",\n \t\t\t     &var_locus) == FAILURE)\n \t{\n \t  m = MATCH_ERROR;\n@@ -1995,7 +1995,7 @@ variable_decl (int elem)\n \n   if (!colon_seen && gfc_match (\" /\") == MATCH_YES)\n     {\n-      if (gfc_notify_std (GFC_STD_GNU, \"Extension: Old-style \"\n+      if (gfc_notify_std (GFC_STD_GNU, \"Old-style \"\n \t\t\t  \"initialization at %C\") == FAILURE)\n \treturn MATCH_ERROR;\n  \n@@ -2588,7 +2588,7 @@ gfc_match_decl_type_spec (gfc_typespec *ts, int implicit_flag)\n \n   if (gfc_match (\" byte\") == MATCH_YES)\n     {\n-      if (gfc_notify_std (GFC_STD_GNU, \"Extension: BYTE type at %C\")\n+      if (gfc_notify_std (GFC_STD_GNU, \"BYTE type at %C\")\n \t  == FAILURE)\n \treturn MATCH_ERROR;\n \n@@ -2619,7 +2619,7 @@ gfc_match_decl_type_spec (gfc_typespec *ts, int implicit_flag)\n \t      gfc_error (\"Assumed type at %C is not allowed for components\");\n \t      return MATCH_ERROR;\n \t    }\n-\t  if (gfc_notify_std (GFC_STD_F2008_TS, \"TS 29113: Assumed type \"\n+\t  if (gfc_notify_std (GFC_STD_F2008_TS, \"Assumed type \"\n \t\t\t  \"at %C\") == FAILURE)\n \t    return MATCH_ERROR;\n \t  ts->type = BT_ASSUMED;\n@@ -2642,7 +2642,7 @@ gfc_match_decl_type_spec (gfc_typespec *ts, int implicit_flag)\n       || (!matched_type && gfc_match (\" character\") == MATCH_YES))\n     {\n       if (matched_type\n-\t  && gfc_notify_std (GFC_STD_F2008, \"Fortran 2008: TYPE with \"\n+\t  && gfc_notify_std (GFC_STD_F2008, \"TYPE with \"\n \t\t\t  \"intrinsic-type-spec at %C\") == FAILURE)\n \treturn MATCH_ERROR;\n \n@@ -2673,7 +2673,7 @@ gfc_match_decl_type_spec (gfc_typespec *ts, int implicit_flag)\n       || (!matched_type && gfc_match (\" double precision\") == MATCH_YES))\n     {\n       if (matched_type\n-\t  && gfc_notify_std (GFC_STD_F2008, \"Fortran 2008: TYPE with \"\n+\t  && gfc_notify_std (GFC_STD_F2008, \"TYPE with \"\n \t\t\t  \"intrinsic-type-spec at %C\") == FAILURE)\n \treturn MATCH_ERROR;\n       if (matched_type && gfc_match_char (')') != MATCH_YES)\n@@ -2698,12 +2698,12 @@ gfc_match_decl_type_spec (gfc_typespec *ts, int implicit_flag)\n \t       && gfc_match (\" complex\") == MATCH_YES)))\n       || (!matched_type && gfc_match (\" double complex\") == MATCH_YES))\n     {\n-      if (gfc_notify_std (GFC_STD_GNU, \"Extension: DOUBLE COMPLEX at %C\")\n+      if (gfc_notify_std (GFC_STD_GNU, \"DOUBLE COMPLEX at %C\")\n \t  == FAILURE)\n \treturn MATCH_ERROR;\n \n       if (matched_type\n-\t  && gfc_notify_std (GFC_STD_F2008, \"Fortran 2008: TYPE with \"\n+\t  && gfc_notify_std (GFC_STD_F2008, \"TYPE with \"\n \t\t\t  \"intrinsic-type-spec at %C\") == FAILURE)\n \treturn MATCH_ERROR;\n \n@@ -2745,7 +2745,7 @@ gfc_match_decl_type_spec (gfc_typespec *ts, int implicit_flag)\n \treturn m;\n       ts->type = BT_CLASS;\n \n-      if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: CLASS statement at %C\")\n+      if (gfc_notify_std (GFC_STD_F2003, \"CLASS statement at %C\")\n \t\t\t  == FAILURE)\n \treturn MATCH_ERROR;\n     }\n@@ -2853,7 +2853,7 @@ gfc_match_decl_type_spec (gfc_typespec *ts, int implicit_flag)\n \n get_kind:\n   if (matched_type\n-      && gfc_notify_std (GFC_STD_F2008, \"Fortran 2008: TYPE with \"\n+      && gfc_notify_std (GFC_STD_F2008, \"TYPE with \"\n \t\t\t \"intrinsic-type-spec at %C\") == FAILURE)\n     return MATCH_ERROR;\n \n@@ -3138,7 +3138,7 @@ gfc_match_import (void)\n       return MATCH_ERROR;\n     }\n \n-  if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: IMPORT statement at %C\")\n+  if (gfc_notify_std (GFC_STD_F2003, \"IMPORT statement at %C\")\n       == FAILURE)\n     return MATCH_ERROR;\n \n@@ -3634,7 +3634,7 @@ match_attr_spec (void)\n \t{\n \t  if (d == DECL_ALLOCATABLE)\n \t    {\n-\t      if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: ALLOCATABLE \"\n+\t      if (gfc_notify_std (GFC_STD_F2003, \"ALLOCATABLE \"\n \t\t\t\t  \"attribute at %C in a TYPE definition\")\n \t\t  == FAILURE)\n \t\t{\n@@ -3662,7 +3662,7 @@ match_attr_spec (void)\n \t      && gfc_state_stack->previous\n \t      && gfc_state_stack->previous->state == COMP_MODULE)\n \t    {\n-\t      if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: Attribute %s \"\n+\t      if (gfc_notify_std (GFC_STD_F2003, \"Attribute %s \"\n \t\t\t\t  \"at %L in a TYPE definition\", attr,\n \t\t\t\t  &seen_at[d])\n \t\t  == FAILURE)\n@@ -3688,7 +3688,7 @@ match_attr_spec (void)\n \n \tcase DECL_ASYNCHRONOUS:\n \t  if (gfc_notify_std (GFC_STD_F2003,\n-\t\t\t      \"Fortran 2003: ASYNCHRONOUS attribute at %C\")\n+\t\t\t      \"ASYNCHRONOUS attribute at %C\")\n \t      == FAILURE)\n \t    t = FAILURE;\n \t  else\n@@ -3701,7 +3701,7 @@ match_attr_spec (void)\n \n \tcase DECL_CONTIGUOUS:\n \t  if (gfc_notify_std (GFC_STD_F2008,\n-\t\t\t      \"Fortran 2008: CONTIGUOUS attribute at %C\")\n+\t\t\t      \"CONTIGUOUS attribute at %C\")\n \t      == FAILURE)\n \t    t = FAILURE;\n \t  else\n@@ -3753,7 +3753,7 @@ match_attr_spec (void)\n \t       break;\n \t    }\n \n-\t  if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: PROTECTED \"\n+\t  if (gfc_notify_std (GFC_STD_F2003, \"PROTECTED \"\n \t\t\t      \"attribute at %C\")\n \t      == FAILURE)\n \t    t = FAILURE;\n@@ -3784,7 +3784,7 @@ match_attr_spec (void)\n            break;\n            \n \tcase DECL_VALUE:\n-\t  if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: VALUE attribute \"\n+\t  if (gfc_notify_std (GFC_STD_F2003, \"VALUE attribute \"\n \t\t\t      \"at %C\")\n \t      == FAILURE)\n \t    t = FAILURE;\n@@ -3794,7 +3794,7 @@ match_attr_spec (void)\n \n \tcase DECL_VOLATILE:\n \t  if (gfc_notify_std (GFC_STD_F2003,\n-\t\t\t      \"Fortran 2003: VOLATILE attribute at %C\")\n+\t\t\t      \"VOLATILE attribute at %C\")\n \t      == FAILURE)\n \t    t = FAILURE;\n \t  else\n@@ -4374,7 +4374,7 @@ gfc_match_prefix (gfc_typespec *ts)\n       if (gfc_match (\"impure% \") == MATCH_YES)\n \t{\n \t  if (gfc_notify_std (GFC_STD_F2008,\n-\t\t\t      \"Fortran 2008: IMPURE procedure at %C\")\n+\t\t\t      \"IMPURE procedure at %C\")\n \t\t== FAILURE)\n \t    goto error;\n \n@@ -4660,7 +4660,7 @@ gfc_match_suffix (gfc_symbol *sym, gfc_symbol **result)\n       /* Fortran 2008 draft allows BIND(C) for internal procedures.  */\n       if (gfc_current_state () == COMP_CONTAINS\n \t  && sym->ns->proc_name->attr.flavor != FL_MODULE\n-\t  && gfc_notify_std (GFC_STD_F2008, \"Fortran 2008: BIND(C) attribute \"\n+\t  && gfc_notify_std (GFC_STD_F2008, \"BIND(C) attribute \"\n \t\t\t     \"at %L may not be specified for an internal \"\n \t\t\t     \"procedure\", &gfc_current_locus)\n \t     == FAILURE)\n@@ -5031,7 +5031,7 @@ match_ppc_decl (void)\n       return MATCH_ERROR;\n     }\n \n-  if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: Procedure pointer \"\n+  if (gfc_notify_std (GFC_STD_F2003, \"Procedure pointer \"\n                      \"component at %C\") == FAILURE)\n     return MATCH_ERROR;\n \n@@ -5123,7 +5123,7 @@ match_procedure_in_interface (void)\n   old_locus = gfc_current_locus;\n   if (gfc_match (\"::\") == MATCH_YES)\n     {\n-      if (gfc_notify_std (GFC_STD_F2008, \"Fortran 2008: double colon in \"\n+      if (gfc_notify_std (GFC_STD_F2008, \"double colon in \"\n \t\t\t \"MODULE PROCEDURE statement at %L\", &old_locus)\n \t  == FAILURE)\n \treturn MATCH_ERROR;\n@@ -5193,7 +5193,7 @@ gfc_match_procedure (void)\n   if (m != MATCH_YES)\n     return m;\n \n-  if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: PROCEDURE statement at %C\")\n+  if (gfc_notify_std (GFC_STD_F2003, \"PROCEDURE statement at %C\")\n       == FAILURE)\n     return MATCH_ERROR;\n \n@@ -5404,7 +5404,7 @@ gfc_match_entry (void)\n   if (m != MATCH_YES)\n     return m;\n \n-  if (gfc_notify_std (GFC_STD_F2008_OBS, \"Fortran 2008 obsolescent feature: \"\n+  if (gfc_notify_std (GFC_STD_F2008_OBS,\n \t\t      \"ENTRY statement at %C\") == FAILURE)\n     return MATCH_ERROR;\n \n@@ -5715,7 +5715,7 @@ gfc_match_subroutine (void)\n       /* The following is allowed in the Fortran 2008 draft.  */\n       if (gfc_current_state () == COMP_CONTAINS\n \t  && sym->ns->proc_name->attr.flavor != FL_MODULE\n-\t  && gfc_notify_std (GFC_STD_F2008, \"Fortran 2008: BIND(C) attribute \"\n+\t  && gfc_notify_std (GFC_STD_F2008, \"BIND(C) attribute \"\n \t\t\t     \"at %L may not be specified for an internal \"\n \t\t\t     \"procedure\", &gfc_current_locus)\n \t     == FAILURE)\n@@ -6085,7 +6085,7 @@ gfc_match_end (gfc_statement *st)\n     {\n       if (!eos_ok && (*st == ST_END_SUBROUTINE || *st == ST_END_FUNCTION))\n \t{\n-\t  if (gfc_notify_std (GFC_STD_F2008, \"Fortran 2008: END statement \"\n+\t  if (gfc_notify_std (GFC_STD_F2008, \"END statement \"\n \t\t\t      \"instead of %s statement at %L\",\n \t\t\t      gfc_ascii_statement (*st), &old_loc) == FAILURE)\n \t    goto cleanup;\n@@ -6611,7 +6611,7 @@ gfc_match_codimension (void)\n match\n gfc_match_contiguous (void)\n {\n-  if (gfc_notify_std (GFC_STD_F2008, \"Fortran 2008: CONTIGUOUS statement at %C\")\n+  if (gfc_notify_std (GFC_STD_F2008, \"CONTIGUOUS statement at %C\")\n       == FAILURE)\n     return MATCH_ERROR;\n \n@@ -6764,7 +6764,7 @@ gfc_match_protected (void)\n \n     }\n \n-  if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: PROTECTED statement at %C\")\n+  if (gfc_notify_std (GFC_STD_F2003, \"PROTECTED statement at %C\")\n       == FAILURE)\n     return MATCH_ERROR;\n \n@@ -7062,7 +7062,7 @@ gfc_match_value (void)\n       return MATCH_ERROR;\n     }\n \n-  if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: VALUE statement at %C\")\n+  if (gfc_notify_std (GFC_STD_F2003, \"VALUE statement at %C\")\n       == FAILURE)\n     return MATCH_ERROR;\n \n@@ -7113,7 +7113,7 @@ gfc_match_volatile (void)\n   gfc_symbol *sym;\n   match m;\n \n-  if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: VOLATILE statement at %C\")\n+  if (gfc_notify_std (GFC_STD_F2003, \"VOLATILE statement at %C\")\n       == FAILURE)\n     return MATCH_ERROR;\n \n@@ -7174,7 +7174,7 @@ gfc_match_asynchronous (void)\n   gfc_symbol *sym;\n   match m;\n \n-  if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: ASYNCHRONOUS statement at %C\")\n+  if (gfc_notify_std (GFC_STD_F2003, \"ASYNCHRONOUS statement at %C\")\n       == FAILURE)\n     return MATCH_ERROR;\n \n@@ -7265,7 +7265,7 @@ gfc_match_modproc (void)\n   old_locus = gfc_current_locus;\n   if (gfc_match (\"::\") == MATCH_YES)\n     {\n-      if (gfc_notify_std (GFC_STD_F2008, \"Fortran 2008: double colon in \"\n+      if (gfc_notify_std (GFC_STD_F2008, \"double colon in \"\n \t\t\t \"MODULE PROCEDURE statement at %L\", &old_locus)\n \t  == FAILURE)\n \treturn MATCH_ERROR;\n@@ -7432,7 +7432,7 @@ gfc_get_type_attr_spec (symbol_attribute *attr, char *name)\n     }\n   else if (gfc_match (\" , abstract\") == MATCH_YES)\n     {\n-      if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: ABSTRACT type at %C\")\n+      if (gfc_notify_std (GFC_STD_F2003, \"ABSTRACT type at %C\")\n \t    == FAILURE)\n \treturn MATCH_ERROR;\n \n@@ -7663,7 +7663,7 @@ gfc_match_enum (void)\n   if (m != MATCH_YES)\n     return m;\n \n-  if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: ENUM and ENUMERATOR at %C\")\n+  if (gfc_notify_std (GFC_STD_F2003, \"ENUM and ENUMERATOR at %C\")\n       == FAILURE)\n     return MATCH_ERROR;\n \n@@ -8157,7 +8157,7 @@ match_procedure_in_type (void)\n \t  return MATCH_ERROR;\n \t}\n \n-      if (num>1 && gfc_notify_std (GFC_STD_F2008, \"Fortran 2008: PROCEDURE list\"\n+      if (num>1 && gfc_notify_std (GFC_STD_F2008, \"PROCEDURE list\"\n \t\t\t\t   \" at %C\") == FAILURE)\n \treturn MATCH_ERROR;\n "}, {"sha": "7e968dbb9963e82415e1cb074f2cb3b7fe589143", "filename": "gcc/fortran/error.c", "status": "modified", "additions": 42, "deletions": 3, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9717f7a145b447c2c3dd00601de66be20d86261e/gcc%2Ffortran%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9717f7a145b447c2c3dd00601de66be20d86261e/gcc%2Ffortran%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ferror.c?ref=9717f7a145b447c2c3dd00601de66be20d86261e", "patch": "@@ -809,6 +809,8 @@ gfc_notify_std (int std, const char *gmsgid, ...)\n {\n   va_list argp;\n   bool warning;\n+  const char *msg1, *msg2;\n+  char *buffer;\n \n   warning = ((gfc_option.warn_std & std) != 0) && !inhibit_warnings;\n   if ((gfc_option.allow_std & std) != 0 && !warning)\n@@ -821,11 +823,48 @@ gfc_notify_std (int std, const char *gmsgid, ...)\n   cur_error_buffer->flag = 1;\n   cur_error_buffer->index = 0;\n \n-  va_start (argp, gmsgid);\n   if (warning)\n-    error_print (_(\"Warning:\"), _(gmsgid), argp);\n+    msg1 = _(\"Warning:\");\n   else\n-    error_print (_(\"Error:\"), _(gmsgid), argp);\n+    msg1 = _(\"Error:\");\n+  \n+  switch (std)\n+  {\n+    case GFC_STD_F2008_TS:\n+      msg2 = \"TS 29113:\";\n+      break;\n+    case GFC_STD_F2008_OBS:\n+      msg2 = _(\"Fortran 2008 obsolescent feature:\");\n+      break;\n+    case GFC_STD_F2008:\n+      msg2 = \"Fortran 2008:\";\n+      break;\n+    case GFC_STD_F2003:\n+      msg2 = \"Fortran 2003:\";\n+      break;\n+    case GFC_STD_GNU:\n+      msg2 = _(\"GNU Extension:\");\n+      break;\n+    case GFC_STD_LEGACY:\n+      msg2 = _(\"Legacy Extension:\");\n+      break;\n+    case GFC_STD_F95_OBS:\n+      msg2 = _(\"Obsolescent feature:\");\n+      break;\n+    case GFC_STD_F95_DEL:\n+      msg2 = _(\"Deleted feature:\");\n+      break;\n+    default:\n+      gcc_unreachable ();\n+  }\n+\n+  buffer = (char *) alloca (strlen (msg1) + strlen (msg2) + 2);\n+  strcpy (buffer, msg1);\n+  strcat (buffer, \" \");\n+  strcat (buffer, msg2);\n+\n+  va_start (argp, gmsgid);\n+  error_print (buffer, _(gmsgid), argp);\n   va_end (argp);\n \n   error_char ('\\0');"}, {"sha": "88a59bc89db72707409649c72e64dbc7a86c91ac", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9717f7a145b447c2c3dd00601de66be20d86261e/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9717f7a145b447c2c3dd00601de66be20d86261e/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=9717f7a145b447c2c3dd00601de66be20d86261e", "patch": "@@ -2405,7 +2405,7 @@ check_elemental (gfc_expr *e)\n \n   if (e->ts.type != BT_INTEGER\n       && e->ts.type != BT_CHARACTER\n-      && gfc_notify_std (GFC_STD_F2003, \"Extension: Evaluation of \"\n+      && gfc_notify_std (GFC_STD_F2003, \"Evaluation of \"\n \t\t\t\"nonstandard initialization expression at %L\",\n \t\t\t&e->where) == FAILURE)\n     return MATCH_ERROR;\n@@ -3164,13 +3164,13 @@ gfc_check_assign (gfc_expr *lvalue, gfc_expr *rvalue, int conform)\n \n   if (rvalue->is_boz && lvalue->ts.type != BT_INTEGER\n       && lvalue->symtree->n.sym->attr.data\n-      && gfc_notify_std (GFC_STD_GNU, \"Extension: BOZ literal at %L used to \"\n+      && gfc_notify_std (GFC_STD_GNU, \"BOZ literal at %L used to \"\n                          \"initialize non-integer variable '%s'\",\n \t\t\t &rvalue->where, lvalue->symtree->n.sym->name)\n \t == FAILURE)\n     return FAILURE;\n   else if (rvalue->is_boz && !lvalue->symtree->n.sym->attr.data\n-      && gfc_notify_std (GFC_STD_GNU, \"Extension: BOZ literal at %L outside \"\n+      && gfc_notify_std (GFC_STD_GNU, \"BOZ literal at %L outside \"\n \t\t\t \"a DATA statement and outside INT/REAL/DBLE/CMPLX\",\n \t\t\t &rvalue->where) == FAILURE)\n     return FAILURE;\n@@ -3338,7 +3338,7 @@ gfc_check_pointer_assign (gfc_expr *lvalue, gfc_expr *rvalue)\n \t      return FAILURE;\n \t    }\n \n-\t  if (gfc_notify_std (GFC_STD_F2003,\"Fortran 2003: Bounds \"\n+\t  if (gfc_notify_std (GFC_STD_F2003,\"Bounds \"\n \t\t\t      \"specification for '%s' in pointer assignment \"\n \t\t\t      \"at %L\", lvalue->symtree->n.sym->name,\n \t\t\t      &lvalue->where) == FAILURE)\n@@ -3439,9 +3439,10 @@ gfc_check_pointer_assign (gfc_expr *lvalue, gfc_expr *rvalue)\n \t      return FAILURE;\n \t    }\n \t  if (attr.proc == PROC_INTERNAL &&\n-\t      gfc_notify_std (GFC_STD_F2008, \"Internal procedure '%s' is \"\n-\t\t\t      \"invalid in procedure pointer assignment at %L\",\n-\t\t\t      rvalue->symtree->name, &rvalue->where) == FAILURE)\n+\t      gfc_notify_std (GFC_STD_F2008, \"Internal procedure \"\n+\t\t\t      \"'%s' is invalid in procedure pointer assignment \"\n+\t\t\t      \"at %L\", rvalue->symtree->name, &rvalue->where)\n+\t\t\t      == FAILURE)\n \t    return FAILURE;\n \t}\n       /* Check for F08:C730.  */\n@@ -3562,7 +3563,7 @@ gfc_check_pointer_assign (gfc_expr *lvalue, gfc_expr *rvalue)\n \t\t\t \" simply contiguous at %L\", &rvalue->where);\n \t      return FAILURE;\n \t    }\n-\t  if (gfc_notify_std (GFC_STD_F2008, \"Fortran 2008: Rank remapping\"\n+\t  if (gfc_notify_std (GFC_STD_F2008, \"Rank remapping\"\n \t\t\t      \" target is not rank 1 at %L\", &rvalue->where)\n \t\t== FAILURE)\n \t    return FAILURE;"}, {"sha": "922de039c2d771bf8943c913861a114e5b9d3445", "filename": "gcc/fortran/interface.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9717f7a145b447c2c3dd00601de66be20d86261e/gcc%2Ffortran%2Finterface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9717f7a145b447c2c3dd00601de66be20d86261e/gcc%2Ffortran%2Finterface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finterface.c?ref=9717f7a145b447c2c3dd00601de66be20d86261e", "patch": "@@ -253,7 +253,7 @@ gfc_match_abstract_interface (void)\n {\n   match m;\n \n-  if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: ABSTRACT INTERFACE at %C\")\n+  if (gfc_notify_std (GFC_STD_F2003, \"ABSTRACT INTERFACE at %C\")\n \t\t      == FAILURE)\n     return MATCH_ERROR;\n \n@@ -1313,7 +1313,7 @@ check_interface0 (gfc_interface *p, const char *interface_name)\n \n       /* F2003, C1207. F2008, C1207.  */\n       if (p->sym->attr.proc == PROC_INTERNAL\n-\t  && gfc_notify_std (GFC_STD_F2008, \"Fortran 2008: Internal procedure \"\n+\t  && gfc_notify_std (GFC_STD_F2008, \"Internal procedure \"\n \t\t\t     \"'%s' in %s at %L\", p->sym->name, interface_name,\n \t\t\t     &p->sym->declared_at) == FAILURE)\n \treturn 1;"}, {"sha": "dbfadb42b118cde0695c3056380f93dfb8f3890e", "filename": "gcc/fortran/intrinsic.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9717f7a145b447c2c3dd00601de66be20d86261e/gcc%2Ffortran%2Fintrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9717f7a145b447c2c3dd00601de66be20d86261e/gcc%2Ffortran%2Fintrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.c?ref=9717f7a145b447c2c3dd00601de66be20d86261e", "patch": "@@ -4083,7 +4083,7 @@ gfc_intrinsic_func_interface (gfc_expr *expr, int error_flag)\n   if ((isym->id == GFC_ISYM_REAL || isym->id == GFC_ISYM_DBLE\n        || isym->id == GFC_ISYM_CMPLX)\n       && gfc_init_expr_flag\n-      && gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: Function '%s' \"\n+      && gfc_notify_std (GFC_STD_F2003, \"Function '%s' \"\n \t\t\t \"as initialization expression at %L\", name,\n \t\t\t &expr->where) == FAILURE)\n     {\n@@ -4159,7 +4159,7 @@ gfc_intrinsic_func_interface (gfc_expr *expr, int error_flag)\n            where each argument is an initialization expression  */\n \n   if (gfc_init_expr_flag && isym->elemental && flag\n-      && gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: Elemental function \"\n+      && gfc_notify_std (GFC_STD_F2003, \"Elemental function \"\n \t\t\t\"as initialization expression with non-integer/non-\"\n \t\t        \"character arguments at %L\", &expr->where) == FAILURE)\n     return MATCH_ERROR;"}, {"sha": "428799c1262ff15f4bfabdc84277bb5ceb8e9f89", "filename": "gcc/fortran/io.c", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9717f7a145b447c2c3dd00601de66be20d86261e/gcc%2Ffortran%2Fio.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9717f7a145b447c2c3dd00601de66be20d86261e/gcc%2Ffortran%2Fio.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fio.c?ref=9717f7a145b447c2c3dd00601de66be20d86261e", "patch": "@@ -451,14 +451,14 @@ format_lex (void)\n       c = next_char_not_space (&error);\n       if (c == 'P')\n \t{\n-\t  if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: DP format \"\n+\t  if (gfc_notify_std (GFC_STD_F2003, \"DP format \"\n \t      \"specifier not allowed at %C\") == FAILURE)\n \t    return FMT_ERROR;\n \t  token = FMT_DP;\n \t}\n       else if (c == 'C')\n \t{\n-\t  if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: DC format \"\n+\t  if (gfc_notify_std (GFC_STD_F2003, \"DC format \"\n \t      \"specifier not allowed at %C\") == FAILURE)\n \t    return FMT_ERROR;\n \t  token = FMT_DC;\n@@ -647,7 +647,7 @@ check_format (bool is_input)\n       /* X requires a prior number if we're being pedantic.  */\n       if (mode != MODE_FORMAT)\n \tformat_locus.nextc += format_string_pos;\n-      if (gfc_notify_std (GFC_STD_GNU, \"Extension: X descriptor \"\n+      if (gfc_notify_std (GFC_STD_GNU, \"X descriptor \"\n \t\t\t  \"requires leading space count at %L\", &format_locus)\n \t  == FAILURE)\n \treturn FAILURE;\n@@ -677,7 +677,7 @@ check_format (bool is_input)\n       if (t == FMT_ERROR)\n \tgoto fail;\n \n-      if (gfc_notify_std (GFC_STD_GNU, \"Extension: $ descriptor at %L\",\n+      if (gfc_notify_std (GFC_STD_GNU, \"$ descriptor at %L\",\n \t  &format_locus) == FAILURE)\n \treturn FAILURE;\n       if (t != FMT_RPAREN || level > 0)\n@@ -824,7 +824,7 @@ check_format (bool is_input)\n \t      error = zero_width;\n \t      goto syntax;\n \t    }\n-\t  if (gfc_notify_std (GFC_STD_F2008, \"Fortran 2008: 'G0' in \"\n+\t  if (gfc_notify_std (GFC_STD_F2008, \"'G0' in \"\n \t\t\t      \"format at %L\", &format_locus) == FAILURE)\n \t    return FAILURE;\n \t  u = format_lex ();\n@@ -1057,7 +1057,7 @@ check_format (bool is_input)\n     default:\n       if (mode != MODE_FORMAT)\n \tformat_locus.nextc += format_string_pos - 1;\n-      if (gfc_notify_std (GFC_STD_GNU, \"Extension: Missing comma at %L\",\n+      if (gfc_notify_std (GFC_STD_GNU, \"Missing comma at %L\",\n \t  &format_locus) == FAILURE)\n \treturn FAILURE;\n       /* If we do not actually return a failure, we need to unwind this\n@@ -1120,7 +1120,7 @@ check_format (bool is_input)\n     default:\n       if (mode != MODE_FORMAT)\n \tformat_locus.nextc += format_string_pos;\n-      if (gfc_notify_std (GFC_STD_GNU, \"Extension: Missing comma at %L\",\n+      if (gfc_notify_std (GFC_STD_GNU, \"Missing comma at %L\",\n \t  &format_locus) == FAILURE)\n \treturn FAILURE;\n       /* If we do not actually return a failure, we need to unwind this\n@@ -1405,7 +1405,7 @@ resolve_tag_format (const gfc_expr *e)\n \t}\n       else if (e->ts.type == BT_INTEGER && e->expr_type == EXPR_VARIABLE)\n \t{\n-\t  if (gfc_notify_std (GFC_STD_F95_DEL, \"Deleted feature: ASSIGNED \"\n+\t  if (gfc_notify_std (GFC_STD_F95_DEL, \"ASSIGNED \"\n \t\t\t      \"variable in FORMAT tag at %L\", &e->where)\n \t      == FAILURE)\n \t    return FAILURE;\n@@ -1430,7 +1430,7 @@ resolve_tag_format (const gfc_expr *e)\n      It may be assigned an Hollerith constant.  */\n   if (e->ts.type != BT_CHARACTER)\n     {\n-      if (gfc_notify_std (GFC_STD_LEGACY, \"Extension: Non-character \"\n+      if (gfc_notify_std (GFC_STD_LEGACY, \"Non-character \"\n \t\t\t  \"in FORMAT tag at %L\", &e->where) == FAILURE)\n \treturn FAILURE;\n \n@@ -1496,7 +1496,7 @@ resolve_tag (const io_tag *tag, gfc_expr *e)\n \n   if (tag == &tag_iomsg)\n     {\n-      if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: IOMSG tag at %L\",\n+      if (gfc_notify_std (GFC_STD_F2003, \"IOMSG tag at %L\",\n \t\t\t  &e->where) == FAILURE)\n \treturn FAILURE;\n     }\n@@ -1512,15 +1512,15 @@ resolve_tag (const io_tag *tag, gfc_expr *e)\n \n   if (tag == &tag_exist && e->ts.kind != gfc_default_logical_kind)\n     {\n-      if (gfc_notify_std (GFC_STD_F2008, \"Fortran 2008: Nondefault LOGICAL \"\n+      if (gfc_notify_std (GFC_STD_F2008, \"Nondefault LOGICAL \"\n \t\t\t  \"in %s tag at %L\", tag->name, &e->where)\n \t  == FAILURE)\n \treturn FAILURE;\n     }\n \n   if (tag == &tag_newunit)\n     {\n-      if (gfc_notify_std (GFC_STD_F2008, \"Fortran 2008: NEWUNIT specifier\"\n+      if (gfc_notify_std (GFC_STD_F2008, \"NEWUNIT specifier\"\n \t\t\t  \" at %L\", &e->where) == FAILURE)\n \treturn FAILURE;\n     }\n@@ -1538,7 +1538,7 @@ resolve_tag (const io_tag *tag, gfc_expr *e)\n   \n   if (tag == &tag_convert)\n     {\n-      if (gfc_notify_std (GFC_STD_GNU, \"Extension: CONVERT tag at %L\",\n+      if (gfc_notify_std (GFC_STD_GNU, \"CONVERT tag at %L\",\n \t\t\t  &e->where) == FAILURE)\n \treturn FAILURE;\n     }\n@@ -1732,7 +1732,7 @@ compare_to_allowed_values (const char *specifier, const char *allowed[],\n \telse\n \t  if (n == ERROR)\n \t    {\n-\t      gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: %s specifier in \"\n+\t      gfc_notify_std (GFC_STD_F2003, \"%s specifier in \"\n \t\t\t      \"%s statement at %C has value '%s'\", specifier,\n \t\t\t      statement, allowed_f2003[i]);\n \t      return 0;\n@@ -1759,7 +1759,7 @@ compare_to_allowed_values (const char *specifier, const char *allowed[],\n \telse\n \t  if (n == ERROR)\n \t    {\n-\t      gfc_notify_std (GFC_STD_GNU, \"Extension: %s specifier in \"\n+\t      gfc_notify_std (GFC_STD_GNU, \"%s specifier in \"\n \t\t\t      \"%s statement at %C has value '%s'\", specifier,\n \t\t\t      statement, allowed_gnu[i]);\n \t      return 0;\n@@ -1894,7 +1894,7 @@ gfc_match_open (void)\n   /* Checks on the ASYNCHRONOUS specifier.  */\n   if (open->asynchronous)\n     {\n-      if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: ASYNCHRONOUS= at %C \"\n+      if (gfc_notify_std (GFC_STD_F2003, \"ASYNCHRONOUS= at %C \"\n \t  \"not allowed in Fortran 95\") == FAILURE)\n \tgoto cleanup;\n \n@@ -1912,7 +1912,7 @@ gfc_match_open (void)\n   /* Checks on the BLANK specifier.  */\n   if (open->blank)\n     {\n-      if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: BLANK= at %C \"\n+      if (gfc_notify_std (GFC_STD_F2003, \"BLANK= at %C \"\n \t  \"not allowed in Fortran 95\") == FAILURE)\n \tgoto cleanup;\n \n@@ -1930,7 +1930,7 @@ gfc_match_open (void)\n   /* Checks on the DECIMAL specifier.  */\n   if (open->decimal)\n     {\n-      if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: DECIMAL= at %C \"\n+      if (gfc_notify_std (GFC_STD_F2003, \"DECIMAL= at %C \"\n \t  \"not allowed in Fortran 95\") == FAILURE)\n \tgoto cleanup;\n \n@@ -1962,7 +1962,7 @@ gfc_match_open (void)\n   /* Checks on the ENCODING specifier.  */\n   if (open->encoding)\n     {\n-      if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: ENCODING= at %C \"\n+      if (gfc_notify_std (GFC_STD_F2003, \"ENCODING= at %C \"\n \t  \"not allowed in Fortran 95\") == FAILURE)\n \tgoto cleanup;\n     \n@@ -2013,7 +2013,7 @@ gfc_match_open (void)\n   /* Checks on the ROUND specifier.  */\n   if (open->round)\n     {\n-      if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: ROUND= at %C \"\n+      if (gfc_notify_std (GFC_STD_F2003, \"ROUND= at %C \"\n \t  \"not allowed in Fortran 95\") == FAILURE)\n       goto cleanup;\n \n@@ -2033,7 +2033,7 @@ gfc_match_open (void)\n   /* Checks on the SIGN specifier.  */\n   if (open->sign) \n     {\n-      if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: SIGN= at %C \"\n+      if (gfc_notify_std (GFC_STD_F2003, \"SIGN= at %C \"\n \t  \"not allowed in Fortran 95\") == FAILURE)\n \tgoto cleanup;\n \n@@ -2479,7 +2479,7 @@ gfc_match_rewind (void)\n match\n gfc_match_flush (void)\n {\n-  if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: FLUSH statement at %C\")\n+  if (gfc_notify_std (GFC_STD_F2003, \"FLUSH statement at %C\")\n       == FAILURE)\n     return MATCH_ERROR;\n \n@@ -2910,7 +2910,7 @@ gfc_resolve_dt (gfc_dt *dt, locus *loc)\n     }\n \n   if (dt->extra_comma\n-      && gfc_notify_std (GFC_STD_GNU, \"Extension: Comma before i/o \"\n+      && gfc_notify_std (GFC_STD_GNU, \"Comma before i/o \"\n \t\t\t \"item list at %L\", &dt->extra_comma->where) == FAILURE)\n     return FAILURE;\n \n@@ -3256,7 +3256,7 @@ if (condition) \\\n \n       if (dt->namelist != NULL)\n \t{\n-\t  if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: Internal file \"\n+\t  if (gfc_notify_std (GFC_STD_F2003, \"Internal file \"\n \t\t\t      \"at %L with namelist\", &expr->where)\n \t      == FAILURE)\n \t    m = MATCH_ERROR;\n@@ -3340,7 +3340,7 @@ if (condition) \\\n \n   if (dt->decimal)\n     {\n-      if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: DECIMAL= at %C \"\n+      if (gfc_notify_std (GFC_STD_F2003, \"DECIMAL= at %C \"\n \t  \"not allowed in Fortran 95\") == FAILURE)\n \treturn MATCH_ERROR;\n \n@@ -3361,7 +3361,7 @@ if (condition) \\\n   \n   if (dt->blank)\n     {\n-      if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: BLANK= at %C \"\n+      if (gfc_notify_std (GFC_STD_F2003, \"BLANK= at %C \"\n \t  \"not allowed in Fortran 95\") == FAILURE)\n \treturn MATCH_ERROR;\n \n@@ -3382,7 +3382,7 @@ if (condition) \\\n \n   if (dt->pad)\n     {\n-      if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: PAD= at %C \"\n+      if (gfc_notify_std (GFC_STD_F2003, \"PAD= at %C \"\n \t  \"not allowed in Fortran 95\") == FAILURE)\n \treturn MATCH_ERROR;\n \n@@ -3403,7 +3403,7 @@ if (condition) \\\n \n   if (dt->round)\n     {\n-      if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: ROUND= at %C \"\n+      if (gfc_notify_std (GFC_STD_F2003, \"ROUND= at %C \"\n \t  \"not allowed in Fortran 95\") == FAILURE)\n \treturn MATCH_ERROR;\n \n@@ -3423,7 +3423,7 @@ if (condition) \\\n   if (dt->sign)\n     {\n       /* When implemented, change the following to use gfc_notify_std F2003.\n-      if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: SIGN= at %C \"\n+      if (gfc_notify_std (GFC_STD_F2003, \"SIGN= at %C \"\n \t  \"not allowed in Fortran 95\") == FAILURE)\n \treturn MATCH_ERROR;  */\n       if (dt->sign->expr_type == EXPR_CONSTANT)\n@@ -3448,7 +3448,7 @@ if (condition) \\\n \n   if (dt->delim)\n     {\n-      if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: DELIM= at %C \"\n+      if (gfc_notify_std (GFC_STD_F2003, \"DELIM= at %C \"\n \t  \"not allowed in Fortran 95\") == FAILURE)\n \treturn MATCH_ERROR;\n \n@@ -4197,7 +4197,7 @@ gfc_match_wait (void)\n \tgoto syntax;\n     }\n \n-  if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: WAIT at %C \"\n+  if (gfc_notify_std (GFC_STD_F2003, \"WAIT at %C \"\n \t  \"not allowed in Fortran 95\") == FAILURE)\n     goto cleanup;\n "}, {"sha": "737d6a31676c026e10a3d2b93c096a2648a9f902", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9717f7a145b447c2c3dd00601de66be20d86261e/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9717f7a145b447c2c3dd00601de66be20d86261e/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=9717f7a145b447c2c3dd00601de66be20d86261e", "patch": "@@ -1393,7 +1393,7 @@ match_arithmetic_if (void)\n       return MATCH_ERROR;\n     }\n \n-  if (gfc_notify_std (GFC_STD_F95_OBS, \"Obsolescent feature: Arithmetic IF \"\n+  if (gfc_notify_std (GFC_STD_F95_OBS, \"Arithmetic IF \"\n \t\t      \"statement at %C\") == FAILURE)\n     return MATCH_ERROR;\n \n@@ -1474,7 +1474,7 @@ gfc_match_if (gfc_statement *if_type)\n \t  return MATCH_ERROR;\n \t}\n       \n-      if (gfc_notify_std (GFC_STD_F95_OBS, \"Obsolescent feature: Arithmetic IF \"\n+      if (gfc_notify_std (GFC_STD_F95_OBS, \"Arithmetic IF \"\n \t\t\t  \"statement at %C\") == FAILURE)\n \treturn MATCH_ERROR;\n \n@@ -1758,7 +1758,7 @@ gfc_match_critical (void)\n   if (gfc_implicit_pure (NULL))\n     gfc_current_ns->proc_name->attr.implicit_pure = 0;\n \n-  if (gfc_notify_std (GFC_STD_F2008, \"Fortran 2008: CRITICAL statement at %C\")\n+  if (gfc_notify_std (GFC_STD_F2008, \"CRITICAL statement at %C\")\n       == FAILURE)\n     return MATCH_ERROR;\n \n@@ -2382,7 +2382,7 @@ gfc_match_do (void)\n       gfc_forall_iterator *head;\n       gfc_expr *mask;\n \n-      if (gfc_notify_std (GFC_STD_F2008, \"Fortran 2008: DO CONCURRENT \"\n+      if (gfc_notify_std (GFC_STD_F2008, \"DO CONCURRENT \"\n \t\t\t   \"construct at %C\") == FAILURE)\n \treturn MATCH_ERROR;\n \n@@ -2581,7 +2581,7 @@ match_exit_cycle (gfc_statement st, gfc_exec_op op)\n \t  return MATCH_ERROR;\n \t}\n       gcc_assert (op == EXEC_EXIT);\n-      if (gfc_notify_std (GFC_STD_F2008, \"Fortran 2008: EXIT statement with no\"\n+      if (gfc_notify_std (GFC_STD_F2008, \"EXIT statement with no\"\n \t\t\t  \" do-construct-name at %C\") == FAILURE)\n \treturn MATCH_ERROR;\n       break;\n@@ -2772,7 +2772,7 @@ gfc_match_pause (void)\n   m = gfc_match_stopcode (ST_PAUSE);\n   if (m == MATCH_YES)\n     {\n-      if (gfc_notify_std (GFC_STD_F95_DEL, \"Deleted feature: PAUSE statement\"\n+      if (gfc_notify_std (GFC_STD_F95_DEL, \"PAUSE statement\"\n \t  \" at %C\")\n \t  == FAILURE)\n \tm = MATCH_ERROR;\n@@ -2795,7 +2795,7 @@ gfc_match_stop (void)\n match\n gfc_match_error_stop (void)\n {\n-  if (gfc_notify_std (GFC_STD_F2008, \"Fortran 2008: ERROR STOP statement at %C\")\n+  if (gfc_notify_std (GFC_STD_F2008, \"ERROR STOP statement at %C\")\n       == FAILURE)\n     return MATCH_ERROR;\n \n@@ -2977,7 +2977,7 @@ lock_unlock_statement (gfc_statement st)\n match\n gfc_match_lock (void)\n {\n-  if (gfc_notify_std (GFC_STD_F2008, \"Fortran 2008: LOCK statement at %C\")\n+  if (gfc_notify_std (GFC_STD_F2008, \"LOCK statement at %C\")\n       == FAILURE)\n     return MATCH_ERROR;\n \n@@ -2988,7 +2988,7 @@ gfc_match_lock (void)\n match\n gfc_match_unlock (void)\n {\n-  if (gfc_notify_std (GFC_STD_F2008, \"Fortran 2008: UNLOCK statement at %C\")\n+  if (gfc_notify_std (GFC_STD_F2008, \"UNLOCK statement at %C\")\n       == FAILURE)\n     return MATCH_ERROR;\n \n@@ -3021,7 +3021,7 @@ sync_statement (gfc_statement st)\n   if (gfc_implicit_pure (NULL))\n     gfc_current_ns->proc_name->attr.implicit_pure = 0;\n \n-  if (gfc_notify_std (GFC_STD_F2008, \"Fortran 2008: SYNC statement at %C\")\n+  if (gfc_notify_std (GFC_STD_F2008, \"SYNC statement at %C\")\n       == FAILURE)\n     return MATCH_ERROR;\n \n@@ -3219,7 +3219,7 @@ gfc_match_assign (void)\n \treturn MATCH_ERROR;\n       if (gfc_match (\" to %v%t\", &expr) == MATCH_YES)\n \t{\n-\t  if (gfc_notify_std (GFC_STD_F95_DEL, \"Deleted feature: ASSIGN \"\n+\t  if (gfc_notify_std (GFC_STD_F95_DEL, \"ASSIGN \"\n \t\t\t      \"statement at %C\")\n \t      == FAILURE)\n \t    return MATCH_ERROR;\n@@ -3265,7 +3265,7 @@ gfc_match_goto (void)\n \n   if (gfc_match_variable (&expr, 0) == MATCH_YES)\n     {\n-      if (gfc_notify_std (GFC_STD_F95_DEL, \"Deleted feature: Assigned GOTO \"\n+      if (gfc_notify_std (GFC_STD_F95_DEL, \"Assigned GOTO \"\n \t\t\t  \"statement at %C\")\n \t  == FAILURE)\n \treturn MATCH_ERROR;\n@@ -3375,7 +3375,7 @@ gfc_match_goto (void)\n   if (gfc_match (\" %e%t\", &expr) != MATCH_YES)\n     goto syntax;\n \n-  if (gfc_notify_std (GFC_STD_F95_OBS, \"Obsolescent feature: Computed GOTO \"\n+  if (gfc_notify_std (GFC_STD_F95_OBS, \"Computed GOTO \"\n \t\t      \"at %C\") == FAILURE)\n     return MATCH_ERROR;\n \n@@ -3457,7 +3457,7 @@ gfc_match_allocate (void)\n     {\n       if (gfc_match (\" :: \") == MATCH_YES)\n \t{\n-\t  if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: typespec in \"\n+\t  if (gfc_notify_std (GFC_STD_F2003, \"typespec in \"\n \t\t\t      \"ALLOCATE at %L\", &old_locus) == FAILURE)\n \t    goto cleanup;\n \n@@ -3620,7 +3620,7 @@ gfc_match_allocate (void)\n \tgoto cleanup;\n       if (m == MATCH_YES)\n \t{\n-\t  if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: ERRMSG tag at %L\",\n+\t  if (gfc_notify_std (GFC_STD_F2003, \"ERRMSG tag at %L\",\n \t\t\t      &tmp->where) == FAILURE)\n \t    goto cleanup;\n \n@@ -3644,7 +3644,7 @@ gfc_match_allocate (void)\n \tgoto cleanup;\n       if (m == MATCH_YES)\n \t{\n-\t  if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: SOURCE tag at %L\",\n+\t  if (gfc_notify_std (GFC_STD_F2003, \"SOURCE tag at %L\",\n \t\t\t      &tmp->where) == FAILURE)\n \t    goto cleanup;\n \n@@ -3664,7 +3664,7 @@ gfc_match_allocate (void)\n \t    }\n \n \t  if (head->next\n-\t      && gfc_notify_std (GFC_STD_F2008, \"Fortran 2008: SOURCE tag at %L\"\n+\t      && gfc_notify_std (GFC_STD_F2008, \"SOURCE tag at %L\"\n \t\t\t\t \" with more than a single allocate object\",\n \t\t\t\t &tmp->where) == FAILURE)\n \t    goto cleanup;\n@@ -3682,7 +3682,7 @@ gfc_match_allocate (void)\n \tgoto cleanup;\n       if (m == MATCH_YES)\n \t{\n-\t  if (gfc_notify_std (GFC_STD_F2008, \"Fortran 2008: MOLD tag at %L\",\n+\t  if (gfc_notify_std (GFC_STD_F2008, \"MOLD tag at %L\",\n \t\t\t      &tmp->where) == FAILURE)\n \t    goto cleanup;\n \n@@ -3944,7 +3944,7 @@ gfc_match_deallocate (void)\n \tgoto cleanup;\n       if (m == MATCH_YES)\n \t{\n-\t  if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: ERRMSG at %L\",\n+\t  if (gfc_notify_std (GFC_STD_F2003, \"ERRMSG at %L\",\n \t\t\t      &tmp->where) == FAILURE)\n \t    goto cleanup;\n \n@@ -4022,7 +4022,7 @@ gfc_match_return (void)\n       goto cleanup;\n     }\n \n-  if (gfc_notify_std (GFC_STD_F95_OBS, \"Obsolescent feature: Alternate RETURN \"\n+  if (gfc_notify_std (GFC_STD_F95_OBS, \"Alternate RETURN \"\n \t\t      \"at %C\") == FAILURE)\n     return MATCH_ERROR;\n \n@@ -4052,7 +4052,7 @@ gfc_match_return (void)\n done:\n   gfc_enclosing_unit (&s);\n   if (s == COMP_PROGRAM\n-      && gfc_notify_std (GFC_STD_GNU, \"Extension: RETURN statement in \"\n+      && gfc_notify_std (GFC_STD_GNU, \"RETURN statement in \"\n \t\t\t\"main program at %C\") == FAILURE)\n       return MATCH_ERROR;\n \n@@ -4966,7 +4966,7 @@ gfc_match_st_function (void)\n \n   sym->value = expr;\n \n-  if (gfc_notify_std (GFC_STD_F95_OBS, \"Obsolescent feature: \"\n+  if (gfc_notify_std (GFC_STD_F95_OBS,\n \t\t      \"Statement function at %C\") == FAILURE)\n     return MATCH_ERROR;\n "}, {"sha": "88519b71de915ff3159a42520748d17bea4a451b", "filename": "gcc/fortran/module.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9717f7a145b447c2c3dd00601de66be20d86261e/gcc%2Ffortran%2Fmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9717f7a145b447c2c3dd00601de66be20d86261e/gcc%2Ffortran%2Fmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmodule.c?ref=9717f7a145b447c2c3dd00601de66be20d86261e", "patch": "@@ -553,7 +553,7 @@ gfc_match_use (void)\n     {\n       if ((m = gfc_match (\" %n ::\", module_nature)) == MATCH_YES)\n \t{\n-\t  if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: module \"\n+\t  if (gfc_notify_std (GFC_STD_F2003, \"module \"\n \t\t\t      \"nature in USE statement at %C\") == FAILURE)\n \t    goto cleanup;\n \n@@ -588,7 +588,7 @@ gfc_match_use (void)\n     {\n       m = gfc_match (\" ::\");\n       if (m == MATCH_YES &&\n-\t  gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: \"\n+\t  gfc_notify_std (GFC_STD_F2003,\n \t\t\t  \"\\\"USE :: module\\\" at %C\") == FAILURE)\n \tgoto cleanup;\n \n@@ -656,7 +656,7 @@ gfc_match_use (void)\n \t  m = gfc_match (\" =>\");\n \n \t  if (type == INTERFACE_USER_OP && m == MATCH_YES\n-\t      && (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: Renaming \"\n+\t      && (gfc_notify_std (GFC_STD_F2003, \"Renaming \"\n \t\t\t\t  \"operators in USE statements at %C\")\n \t\t == FAILURE))\n \t    goto cleanup;\n@@ -6051,7 +6051,7 @@ gfc_use_module (gfc_use_list *module)\n   if (module_fp == NULL && !module->non_intrinsic)\n     {\n       if (strcmp (module_name, \"iso_fortran_env\") == 0\n-\t  && gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: ISO_FORTRAN_ENV \"\n+\t  && gfc_notify_std (GFC_STD_F2003, \"ISO_FORTRAN_ENV \"\n \t\t\t     \"intrinsic module at %C\") != FAILURE)\n        {\n \t use_iso_fortran_env_module ();\n@@ -6061,7 +6061,7 @@ gfc_use_module (gfc_use_list *module)\n        }\n \n       if (strcmp (module_name, \"iso_c_binding\") == 0\n-\t  && gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: \"\n+\t  && gfc_notify_std (GFC_STD_F2003,\n \t\t\t     \"ISO_C_BINDING module at %C\") != FAILURE)\n \t{\n \t  import_iso_c_binding_module();"}, {"sha": "a5d0f85963bee0a5186cecb55a8799cde103648a", "filename": "gcc/fortran/parse.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9717f7a145b447c2c3dd00601de66be20d86261e/gcc%2Ffortran%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9717f7a145b447c2c3dd00601de66be20d86261e/gcc%2Ffortran%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.c?ref=9717f7a145b447c2c3dd00601de66be20d86261e", "patch": "@@ -1976,7 +1976,7 @@ parse_derived_contains (void)\n \t  goto error;\n \n \tcase ST_PROCEDURE:\n-\t  if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003:  Type-bound\"\n+\t  if (gfc_notify_std (GFC_STD_F2003, \"Type-bound\"\n \t\t\t\t\t     \" procedure at %C\") == FAILURE)\n \t    goto error;\n \n@@ -1985,7 +1985,7 @@ parse_derived_contains (void)\n \t  break;\n \n \tcase ST_GENERIC:\n-\t  if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003:  GENERIC binding\"\n+\t  if (gfc_notify_std (GFC_STD_F2003, \"GENERIC binding\"\n \t\t\t\t\t     \" at %C\") == FAILURE)\n \t    goto error;\n \n@@ -1995,7 +1995,7 @@ parse_derived_contains (void)\n \n \tcase ST_FINAL:\n \t  if (gfc_notify_std (GFC_STD_F2003,\n-\t\t\t      \"Fortran 2003:  FINAL procedure declaration\"\n+\t\t\t      \"FINAL procedure declaration\"\n \t\t\t      \" at %C\") == FAILURE)\n \t    goto error;\n \n@@ -2007,7 +2007,7 @@ parse_derived_contains (void)\n \t  to_finish = true;\n \n \t  if (!seen_comps\n-\t      && (gfc_notify_std (GFC_STD_F2008, \"Fortran 2008: Derived type \"\n+\t      && (gfc_notify_std (GFC_STD_F2008, \"Derived type \"\n \t\t\t\t  \"definition at %C with empty CONTAINS \"\n \t\t\t\t  \"section\") == FAILURE))\n \t    goto error;\n@@ -2112,7 +2112,7 @@ parse_derived (void)\n \t  compiling_type = 0;\n \n \t  if (!seen_component)\n-\t    gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: Derived type \"\n+\t    gfc_notify_std (GFC_STD_F2003, \"Derived type \"\n \t\t\t    \"definition at %C without components\");\n \n \t  accept_statement (ST_END_TYPE);\n@@ -2166,7 +2166,7 @@ parse_derived (void)\n \n \tcase ST_CONTAINS:\n \t  gfc_notify_std (GFC_STD_F2003,\n-\t\t\t  \"Fortran 2003:  CONTAINS block in derived type\"\n+\t\t\t  \"CONTAINS block in derived type\"\n \t\t\t  \" definition at %C\");\n \n \t  accept_statement (ST_CONTAINS);\n@@ -3335,7 +3335,7 @@ parse_block_construct (void)\n   gfc_namespace* my_ns;\n   gfc_state_data s;\n \n-  gfc_notify_std (GFC_STD_F2008, \"Fortran 2008: BLOCK construct at %C\");\n+  gfc_notify_std (GFC_STD_F2008, \"BLOCK construct at %C\");\n \n   my_ns = gfc_build_block_ns (gfc_current_ns);\n \n@@ -3365,7 +3365,7 @@ parse_associate (void)\n   gfc_statement st;\n   gfc_association_list* a;\n \n-  gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: ASSOCIATE construct at %C\");\n+  gfc_notify_std (GFC_STD_F2003, \"ASSOCIATE construct at %C\");\n \n   my_ns = gfc_build_block_ns (gfc_current_ns);\n \n@@ -4095,7 +4095,7 @@ parse_contained (int module)\n \n   pop_state ();\n   if (!contains_statements)\n-    gfc_notify_std (GFC_STD_F2008, \"Fortran 2008: CONTAINS statement without \"\n+    gfc_notify_std (GFC_STD_F2008, \"CONTAINS statement without \"\n \t\t    \"FUNCTION or SUBROUTINE statement at %C\");\n }\n "}, {"sha": "e2c3f9917c33652490aca9c2890a983c2d512157", "filename": "gcc/fortran/primary.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9717f7a145b447c2c3dd00601de66be20d86261e/gcc%2Ffortran%2Fprimary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9717f7a145b447c2c3dd00601de66be20d86261e/gcc%2Ffortran%2Fprimary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fprimary.c?ref=9717f7a145b447c2c3dd00601de66be20d86261e", "patch": "@@ -269,7 +269,7 @@ match_hollerith_constant (gfc_expr **result)\n   if (match_integer_constant (&e, 0) == MATCH_YES\n       && gfc_match_char ('h') == MATCH_YES)\n     {\n-      if (gfc_notify_std (GFC_STD_LEGACY, \"Extension: Hollerith constant \"\n+      if (gfc_notify_std (GFC_STD_LEGACY, \"Hollerith constant \"\n \t\t\t  \"at %C\") == FAILURE)\n \tgoto cleanup;\n \n@@ -393,7 +393,7 @@ match_boz_constant (gfc_expr **result)\n     goto backup;\n \n   if (x_hex\n-      && (gfc_notify_std (GFC_STD_GNU, \"Extension: Hexadecimal \"\n+      && (gfc_notify_std (GFC_STD_GNU, \"Hexadecimal \"\n \t\t\t  \"constant at %C uses non-standard syntax\")\n \t  == FAILURE))\n       return MATCH_ERROR;\n@@ -432,7 +432,7 @@ match_boz_constant (gfc_expr **result)\n \t  goto backup;\n \t}\n \n-      if (gfc_notify_std (GFC_STD_GNU, \"Extension: BOZ constant \"\n+      if (gfc_notify_std (GFC_STD_GNU, \"BOZ constant \"\n \t\t\t  \"at %C uses non-standard postfix syntax\")\n \t  == FAILURE)\n \treturn MATCH_ERROR;\n@@ -469,7 +469,7 @@ match_boz_constant (gfc_expr **result)\n     }\n \n   if (!gfc_in_match_data ()\n-      && (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: BOZ used outside a DATA \"\n+      && (gfc_notify_std (GFC_STD_F2003, \"BOZ used outside a DATA \"\n \t\t\t  \"statement at %C\")\n \t  == FAILURE))\n       return MATCH_ERROR;\n@@ -560,7 +560,7 @@ match_real_constant (gfc_expr **result, int signflag)\n \n   if (c == 'q')\n     {\n-      if (gfc_notify_std (GFC_STD_GNU, \"Extension: exponent-letter 'q' in \"\n+      if (gfc_notify_std (GFC_STD_GNU, \"exponent-letter 'q' in \"\n \t\t\t \"real-literal-constant at %C\") == FAILURE)\n \treturn MATCH_ERROR;\n       else if (gfc_option.warn_real_q_constant)\n@@ -1218,7 +1218,7 @@ match_sym_complex_part (gfc_expr **result)\n       return MATCH_ERROR;\n     }\n \n-  if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: PARAMETER symbol in \"\n+  if (gfc_notify_std (GFC_STD_F2003, \"PARAMETER symbol in \"\n \t\t      \"complex constant at %C\") == FAILURE)\n     return MATCH_ERROR;\n \n@@ -1646,7 +1646,7 @@ match_arg_list_function (gfc_actual_arglist *result)\n \t}\n     }\n \n-  if (gfc_notify_std (GFC_STD_GNU, \"Extension: argument list \"\n+  if (gfc_notify_std (GFC_STD_GNU, \"argument list \"\n \t\t      \"function at %C\") == FAILURE)\n     {\n       m = MATCH_ERROR;\n@@ -2353,7 +2353,7 @@ build_actual_constructor (gfc_structure_ctor_component **comp_head,\n \t{\n \t  if (comp->initializer)\n \t    {\n-\t      if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: Structure\"\n+\t      if (gfc_notify_std (GFC_STD_F2003, \"Structure\"\n \t\t\t\t  \" constructor with missing optional arguments\"\n \t\t\t\t  \" at %C\") == FAILURE)\n \t\treturn FAILURE;\n@@ -2429,7 +2429,7 @@ gfc_convert_to_structure_constructor (gfc_expr *e, gfc_symbol *sym, gfc_expr **c\n        \t}\n       if (actual->name)\n \t{\n-\t  if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: Structure\"\n+\t  if (gfc_notify_std (GFC_STD_F2003, \"Structure\"\n \t\t\t      \" constructor with named arguments at %C\")\n \t      == FAILURE)\n \t    goto cleanup;"}, {"sha": "73a9731c0cfbbdc31f9a092e4d2580465d4666df", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9717f7a145b447c2c3dd00601de66be20d86261e/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9717f7a145b447c2c3dd00601de66be20d86261e/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=9717f7a145b447c2c3dd00601de66be20d86261e", "patch": "@@ -331,7 +331,7 @@ resolve_formal_arglist (gfc_symbol *proc)\n \t      if (proc->attr.function && sym->attr.intent != INTENT_IN)\n \t\t{\n \t\t  if (sym->attr.value)\n-\t\t    gfc_notify_std (GFC_STD_F2008, \"Fortran 2008: Argument '%s'\"\n+\t\t    gfc_notify_std (GFC_STD_F2008, \"Argument '%s'\"\n \t\t\t\t    \" of pure function '%s' at %L with VALUE \"\n \t\t\t\t    \"attribute but without INTENT(IN)\",\n \t\t\t\t    sym->name, proc->name, &sym->declared_at);\n@@ -344,7 +344,7 @@ resolve_formal_arglist (gfc_symbol *proc)\n \t      if (proc->attr.subroutine && sym->attr.intent == INTENT_UNKNOWN)\n \t\t{\n \t\t  if (sym->attr.value)\n-\t\t    gfc_notify_std (GFC_STD_F2008, \"Fortran 2008: Argument '%s'\"\n+\t\t    gfc_notify_std (GFC_STD_F2008, \"Argument '%s'\"\n \t\t\t\t    \" of pure subroutine '%s' at %L with VALUE \"\n \t\t\t\t    \"attribute but without INTENT\", sym->name,\n \t\t\t\t    proc->name, &sym->declared_at);\n@@ -723,7 +723,7 @@ resolve_entries (gfc_namespace *ns)\n \t\t\t   && ts->u.cl->length->expr_type == EXPR_CONSTANT\n \t\t           && mpz_cmp (ts->u.cl->length->value.integer,\n \t\t\t\t       fts->u.cl->length->value.integer) != 0)))\n-\t    gfc_notify_std (GFC_STD_GNU, \"Extension: Function %s at %L with \"\n+\t    gfc_notify_std (GFC_STD_GNU, \"Function %s at %L with \"\n \t\t\t    \"entries returning variables of different \"\n \t\t\t    \"string lengths\", ns->entries->sym->name,\n \t\t\t    &ns->entries->sym->declared_at);\n@@ -916,12 +916,12 @@ resolve_common_blocks (gfc_symtree *common_root)\n \t       sym->name, &common_root->n.common->where);\n   else if (sym->attr.result\n \t   || gfc_is_function_return_value (sym, gfc_current_ns))\n-    gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: COMMON block '%s' at %L \"\n+    gfc_notify_std (GFC_STD_F2003, \"COMMON block '%s' at %L \"\n \t\t    \"that is also a function result\", sym->name,\n \t\t    &common_root->n.common->where);\n   else if (sym->attr.flavor == FL_PROCEDURE && sym->attr.proc != PROC_INTERNAL\n \t   && sym->attr.proc != PROC_ST_FUNCTION)\n-    gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: COMMON block '%s' at %L \"\n+    gfc_notify_std (GFC_STD_F2003, \"COMMON block '%s' at %L \"\n \t\t    \"that is also a global procedure\", sym->name,\n \t\t    &common_root->n.common->where);\n }\n@@ -1673,7 +1673,7 @@ resolve_actual_arglist (gfc_actual_arglist *arg, procedure_type ptype,\n \t      && sym->ns->proc_name->attr.flavor != FL_MODULE)\n \t    {\n \t      if (gfc_notify_std (GFC_STD_F2008,\n-\t\t\t\t  \"Fortran 2008: Internal procedure '%s' is\"\n+\t\t\t\t  \"Internal procedure '%s' is\"\n \t\t\t\t  \" used as actual argument at %L\",\n \t\t\t\t  sym->name, &e->where) == FAILURE)\n \t\treturn FAILURE;\n@@ -4450,7 +4450,7 @@ gfc_resolve_index_1 (gfc_expr *index, int check_scalar,\n     }\n \n   if (index->ts.type == BT_REAL)\n-    if (gfc_notify_std (GFC_STD_LEGACY, \"Extension: REAL array index at %L\",\n+    if (gfc_notify_std (GFC_STD_LEGACY, \"REAL array index at %L\",\n \t\t\t&index->where) == FAILURE)\n       return FAILURE;\n \n@@ -6420,7 +6420,7 @@ gfc_resolve_iterator_expr (gfc_expr *expr, bool real_ok,\n \t{\n \t  if (real_ok)\n \t    return gfc_notify_std (GFC_STD_F95_DEL,\n-\t\t\t\t   \"Deleted feature: %s at %L must be integer\",\n+\t\t\t\t   \"%s at %L must be integer\",\n \t\t\t\t   _(name_msgid), &expr->where);\n \t  else\n \t    {\n@@ -9158,7 +9158,7 @@ resolve_ordinary_assign (gfc_code *code, gfc_namespace *ns)\n   rhs = code->expr2;\n \n   if (rhs->is_boz\n-      && gfc_notify_std (GFC_STD_GNU, \"Extension: BOZ literal at %L outside \"\n+      && gfc_notify_std (GFC_STD_GNU, \"BOZ literal at %L outside \"\n \t\t\t \"a DATA statement and outside INT/REAL/DBLE/CMPLX\",\n \t\t\t &code->loc) == FAILURE)\n     return false;\n@@ -10327,9 +10327,9 @@ resolve_fl_var_and_proc (gfc_symbol *sym, int mp_flag)\n \t\t\t \"a deferred shape\", sym->name, &sym->declared_at);\n \t      return FAILURE;\n \t    }\n-\t  else if (gfc_notify_std (GFC_STD_F2003, \"Scalar object '%s' at %L \"\n-\t\t\t\t   \"may not be ALLOCATABLE\", sym->name,\n-\t\t\t\t   &sym->declared_at) == FAILURE)\n+\t  else if (gfc_notify_std (GFC_STD_F2003, \"Scalar object \"\n+\t\t\t\t   \"'%s' at %L may not be ALLOCATABLE\",\n+\t\t\t\t   sym->name, &sym->declared_at) == FAILURE)\n \t    return FAILURE;\n \t}\n \n@@ -10423,7 +10423,7 @@ resolve_fl_variable_derived (gfc_symbol *sym, int no_init_flag)\n       && !sym->ns->save_all && !sym->attr.save\n       && !sym->attr.pointer && !sym->attr.allocatable\n       && gfc_has_default_initializer (sym->ts.u.derived)\n-      && gfc_notify_std (GFC_STD_F2008, \"Fortran 2008: Implied SAVE for \"\n+      && gfc_notify_std (GFC_STD_F2008, \"Implied SAVE for \"\n \t\t\t \"module variable '%s' at %L, needed due to \"\n \t\t\t \"the default initialization\", sym->name,\n \t\t\t &sym->declared_at) == FAILURE)\n@@ -10638,7 +10638,7 @@ resolve_fl_procedure (gfc_symbol *sym, int mp_flag)\n \t      && arg->sym->ts.type == BT_DERIVED\n \t      && !arg->sym->ts.u.derived->attr.use_assoc\n \t      && !gfc_check_symbol_access (arg->sym->ts.u.derived)\n-\t      && gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: '%s' is of a \"\n+\t      && gfc_notify_std (GFC_STD_F2003, \"'%s' is of a \"\n \t\t\t\t \"PRIVATE type and cannot be a dummy argument\"\n \t\t\t\t \" of '%s', which is PUBLIC at %L\",\n \t\t\t\t arg->sym->name, sym->name, &sym->declared_at)\n@@ -10660,7 +10660,7 @@ resolve_fl_procedure (gfc_symbol *sym, int mp_flag)\n \t\t  && arg->sym->ts.type == BT_DERIVED\n \t\t  && !arg->sym->ts.u.derived->attr.use_assoc\n \t\t  && !gfc_check_symbol_access (arg->sym->ts.u.derived)\n-\t\t  && gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: Procedure \"\n+\t\t  && gfc_notify_std (GFC_STD_F2003, \"Procedure \"\n \t\t\t\t     \"'%s' in PUBLIC interface '%s' at %L \"\n \t\t\t\t     \"takes dummy arguments of '%s' which is \"\n \t\t\t\t     \"PRIVATE\", iface->sym->name, sym->name,\n@@ -10684,7 +10684,7 @@ resolve_fl_procedure (gfc_symbol *sym, int mp_flag)\n \t\t  && arg->sym->ts.type == BT_DERIVED\n \t\t  && !arg->sym->ts.u.derived->attr.use_assoc\n \t\t  && !gfc_check_symbol_access (arg->sym->ts.u.derived)\n-\t\t  && gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: Procedure \"\n+\t\t  && gfc_notify_std (GFC_STD_F2003, \"Procedure \"\n \t\t\t\t     \"'%s' in PUBLIC interface '%s' at %L \"\n \t\t\t\t     \"takes dummy arguments of '%s' which is \"\n \t\t\t\t     \"PRIVATE\", iface->sym->name, sym->name,\n@@ -10772,7 +10772,7 @@ resolve_fl_procedure (gfc_symbol *sym, int mp_flag)\n       if (!sym->attr.contained\n \t    && gfc_current_form != FORM_FIXED\n \t    && !sym->ts.deferred)\n-\tgfc_notify_std (GFC_STD_F95_OBS, \"Obsolescent feature: \"\n+\tgfc_notify_std (GFC_STD_F95_OBS,\n \t\t\t\"CHARACTER(*) function '%s' at %L\",\n \t\t\tsym->name, &sym->declared_at);\n     }\n@@ -11992,7 +11992,7 @@ resolve_fl_derived0 (gfc_symbol *sym)\n \t  && !is_sym_host_assoc (c->ts.u.derived, sym->ns)\n \t  && !c->ts.u.derived->attr.use_assoc\n \t  && !gfc_check_symbol_access (c->ts.u.derived)\n-\t  && gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: the component '%s' \"\n+\t  && gfc_notify_std (GFC_STD_F2003, \"the component '%s' \"\n \t\t\t     \"is a PRIVATE type and cannot be a component of \"\n \t\t\t     \"'%s', which is PUBLIC at %L\", c->name,\n \t\t\t     sym->name, &sym->declared_at) == FAILURE)\n@@ -12100,7 +12100,7 @@ resolve_fl_derived (gfc_symbol *sym)\n   if (gen_dt && gen_dt->generic && gen_dt->generic->next\n       && (!gen_dt->generic->sym->attr.use_assoc\n \t  || gen_dt->generic->sym->module != gen_dt->generic->next->sym->module)\n-      && gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: Generic name '%s' of \"\n+      && gfc_notify_std (GFC_STD_F2003, \"Generic name '%s' of \"\n \t\t\t \"function '%s' at %L being the same name as derived \"\n \t\t\t \"type at %L\", sym->name,\n \t\t\t gen_dt->generic->sym == sym\n@@ -12158,14 +12158,14 @@ resolve_fl_namelist (gfc_symbol *sym)\n \t}\n \n       if (nl->sym->as && nl->sym->as->type == AS_ASSUMED_SHAPE\n-\t  && gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: NAMELIST array \"\n+\t  && gfc_notify_std (GFC_STD_F2003, \"NAMELIST array \"\n \t\t\t     \"object '%s' with assumed shape in namelist \"\n \t\t\t     \"'%s' at %L\", nl->sym->name, sym->name,\n \t\t\t     &sym->declared_at) == FAILURE)\n \treturn FAILURE;\n \n       if (is_non_constant_shape_array (nl->sym)\n-\t  && gfc_notify_std (GFC_STD_F2003,  \"Fortran 2003: NAMELIST array \"\n+\t  && gfc_notify_std (GFC_STD_F2003, \"NAMELIST array \"\n \t\t\t     \"object '%s' with nonconstant shape in namelist \"\n \t\t\t     \"'%s' at %L\", nl->sym->name, sym->name,\n \t\t\t     &sym->declared_at) == FAILURE)\n@@ -12174,7 +12174,7 @@ resolve_fl_namelist (gfc_symbol *sym)\n       if (nl->sym->ts.type == BT_CHARACTER\n \t  && (nl->sym->ts.u.cl->length == NULL\n \t      || !gfc_is_constant_expr (nl->sym->ts.u.cl->length))\n-\t  && gfc_notify_std (GFC_STD_F2003,  \"Fortran 2003: NAMELIST object \"\n+\t  && gfc_notify_std (GFC_STD_F2003, \"NAMELIST object \"\n \t\t\t     \"'%s' with nonconstant character length in \"\n \t\t\t     \"namelist '%s' at %L\", nl->sym->name, sym->name,\n \t\t\t     &sym->declared_at) == FAILURE)\n@@ -12194,7 +12194,7 @@ resolve_fl_namelist (gfc_symbol *sym)\n \t  && (nl->sym->ts.u.derived->attr.alloc_comp\n \t      || nl->sym->ts.u.derived->attr.pointer_comp))\n \t{\n-\t  if (gfc_notify_std (GFC_STD_F2003,  \"Fortran 2003: NAMELIST object \"\n+\t  if (gfc_notify_std (GFC_STD_F2003, \"NAMELIST object \"\n \t\t\t      \"'%s' in namelist '%s' at %L with ALLOCATABLE \"\n \t\t\t      \"or POINTER components\", nl->sym->name,\n \t\t\t      sym->name, &sym->declared_at) == FAILURE)\n@@ -12672,7 +12672,7 @@ resolve_symbol (gfc_symbol *sym)\n       && !sym->ts.u.derived->attr.use_assoc\n       && gfc_check_symbol_access (sym)\n       && !gfc_check_symbol_access (sym->ts.u.derived)\n-      && gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: PUBLIC %s '%s' at %L \"\n+      && gfc_notify_std (GFC_STD_F2003, \"PUBLIC %s '%s' at %L \"\n \t\t         \"of PRIVATE derived type '%s'\",\n \t\t\t (sym->attr.flavor == FL_PARAMETER) ? \"parameter\"\n \t\t\t : \"variable\", sym->name, &sym->declared_at,\n@@ -13838,7 +13838,7 @@ resolve_fntype (gfc_namespace *ns)\n       && !gfc_check_symbol_access (sym->ts.u.derived)\n       && gfc_check_symbol_access (sym))\n     {\n-      gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: PUBLIC function '%s' at \"\n+      gfc_notify_std (GFC_STD_F2003, \"PUBLIC function '%s' at \"\n \t\t      \"%L of PRIVATE type '%s'\", sym->name,\n \t\t      &sym->declared_at, sym->ts.u.derived->name);\n     }"}, {"sha": "455e6c98951164b938f592cbb649b8968fbffec8", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9717f7a145b447c2c3dd00601de66be20d86261e/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9717f7a145b447c2c3dd00601de66be20d86261e/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=9717f7a145b447c2c3dd00601de66be20d86261e", "patch": "@@ -481,7 +481,7 @@ check_conflict (symbol_attribute *attr, const char *name, locus *where)\n     conf (external, subroutine);\n \n   if (attr->proc_pointer && gfc_notify_std (GFC_STD_F2003,\n-\t\t\t    \"Fortran 2003: Procedure pointer at %C\") == FAILURE)\n+\t\t\t    \"Procedure pointer at %C\") == FAILURE)\n     return FAILURE;\n \n   conf (allocatable, pointer);\n@@ -772,13 +772,13 @@ check_conflict (symbol_attribute *attr, const char *name, locus *where)\n conflict_std:\n   if (name == NULL)\n     {\n-      return gfc_notify_std (standard, \"Fortran 2003: %s attribute \"\n+      return gfc_notify_std (standard, \"%s attribute \"\n                              \"with %s attribute at %L\", a1, a2,\n                              where);\n     }\n   else\n     {\n-      return gfc_notify_std (standard, \"Fortran 2003: %s attribute \"\n+      return gfc_notify_std (standard, \"%s attribute \"\n \t\t\t     \"with %s attribute in '%s' at %L\",\n                              a1, a2, name, where);\n     }\n@@ -1597,7 +1597,7 @@ gfc_add_is_bind_c (symbol_attribute *attr, const char *name, locus *where,\n   if (where == NULL)\n     where = &gfc_current_locus;\n    \n-  if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: BIND(C) at %L\", where)\n+  if (gfc_notify_std (GFC_STD_F2003, \"BIND(C) at %L\", where)\n       == FAILURE)\n     return FAILURE;\n \n@@ -1618,7 +1618,7 @@ gfc_add_extension (symbol_attribute *attr, locus *where)\n   else\n     attr->extension = 1;\n \n-  if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: EXTENDS at %L\", where)\n+  if (gfc_notify_std (GFC_STD_F2003, \"EXTENDS at %L\", where)\n \t== FAILURE)\n     return FAILURE;\n \n@@ -4746,7 +4746,7 @@ gfc_check_symbol_typed (gfc_symbol* sym, gfc_namespace* ns,\n \t}\n \n       if (gfc_notify_std (GFC_STD_GNU,\n-\t\t\t  \"Extension: Symbol '%s' is used before\"\n+\t\t\t  \"Symbol '%s' is used before\"\n \t\t\t  \" it is typed at %L\", sym->name, &where) == FAILURE)\n \treturn FAILURE;\n     }"}]}