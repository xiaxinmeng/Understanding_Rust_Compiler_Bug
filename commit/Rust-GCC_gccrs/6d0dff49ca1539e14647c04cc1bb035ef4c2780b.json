{"sha": "6d0dff49ca1539e14647c04cc1bb035ef4c2780b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmQwZGZmNDljYTE1MzllMTQ2NDdjMDRjYzFiYjAzNWVmNGMyNzgwYg==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2019-10-29T17:44:18Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2019-10-29T17:44:18Z"}, "message": "Add iterator concepts and range access customization points for C++20\n\nThis adds most of the new C++20 features to <iterator>, as well as a few\ninitial pieces of <ranges> (but no actual <ranges> header just yet).\n\n\t* include/Makefile.am: Add new header.\n\t* include/Makefile.in: Regenerate.\n\t* include/bits/iterator_concepts.h: New header.\n\t(contiguous_iterator_tag, iter_reference_t, ranges::iter_move)\n\t(iter_rvalue_reference_t, incrementable_traits, iter_difference_t)\n\t(readable_traits, iter_value_t, readable, iter_common_reference_t)\n\t(writable, waekly_incrementable, incrementable)\n\t(input_or_output_iterator, sentinel_for, disable_sized_sentinel)\n\t(sized_sentinel_for, input_iterator, output_iterator)\n\t(forward_iterator, bidirectional_iterator, random_access_iterator)\n\t(contiguous_iterator, indirectly_unary_invocable)\n\t(indirectly_regular_unary_invocable, indirect_unary_predicate)\n\t(indirect_relation, indirect_strict_weak_order, indirect_result_t)\n\t(projected, indirectly_movable, indirectly_movable_storable)\n\t(indirectly_copyable, indirectly_copyable_storable, ranges::iter_swap)\n\t(indirectly_swappable, indirectly_comparable, permutable, mergeable)\n\t(sortable, unreachable_sentinel_t, unreachable_sentinel)\n\t(default_sentinel_t, default_sentinel): Define.\n\t(__detail::__cpp17_iterator, __detail::__cpp17_input_iterator)\n\t(__detail::__cpp17_fwd_iterator, __detail::__cpp17_bidi_iterator)\n\t(__detail::__cpp17_randacc_iterator): Define.\n\t(__iterator_traits): Define constrained specializations.\n\t* include/bits/move.h (move): Only use old concept check for C++98.\n\t* include/bits/range_access.h (ranges::disable_sized_range)\n\t(ranges::begin, ranges::end, ranges::cbegin, ranges::cend)\n\t(ranges::rbegin, ranges::rend, ranges::crbegin, ranges::crend)\n\t(ranges::size, ranges::empty, ranges::data, ranges::cdata): Define\n\tnew customization points for C++20.\n\t(ranges::range, ranges::sized_range): Define new concepts for C++20.\n\t(ranges::advance, ranges::distance, ranges::next, ranges::prev):\n\tDefine new functions for C++20.\n\t(__adl_end, __adl_cdata, __adl_cbegin, __adl_cend, __adl_rbegin)\n\t(__adl_rend, __adl_crbegin, __adl_crend, __adl_cdata, __adl_size)\n\t(__adl_empty): Remove.\n\t* include/bits/stl_iterator.h (disable_sized_sentinel): Specialize\n\tfor reverse_iterator.\n\t* include/bits/stl_iterator_base_types.h (contiguous_iterator_tag):\n\tDefine new struct for C++20.\n\t(iterator_traits<_Tp*>): Constrain partial specialization in C++20.\n\t* include/std/concepts (__is_class_or_enum): Move to __detail\n\tnamespace.\n\t* testsuite/20_util/forward/c_neg.cc: Adjust dg-error line number.\n\t* testsuite/20_util/forward/f_neg.cc: Likewise.\n\t* testsuite/24_iterators/associated_types/incrementable.traits.cc: New\n\ttest.\n\t* testsuite/24_iterators/associated_types/readable.traits.cc: New test.\n\t* testsuite/24_iterators/contiguous/concept.cc: New test.\n\t* testsuite/24_iterators/contiguous/tag.cc: New test.\n\t* testsuite/24_iterators/customization_points/iter_move.cc: New test.\n\t* testsuite/24_iterators/customization_points/iter_swap.cc: New test.\n\t* testsuite/24_iterators/headers/iterator/synopsis_c++20.cc: New test.\n\t* testsuite/24_iterators/range_operations/advance.cc: New test.\n\t* testsuite/24_iterators/range_operations/distance.cc: New test.\n\t* testsuite/24_iterators/range_operations/next.cc: New test.\n\t* testsuite/24_iterators/range_operations/prev.cc: New test.\n\t* testsuite/26_numerics/adjacent_difference/requirements/\n\texplicit_instantiation/2.cc: Rename types that conflict with C++20\n\tconcepts.\n\t* testsuite/26_numerics/adjacent_difference/requirements/\n\texplicit_instantiation/pod.cc: Likewise.\n\t* testsuite/26_numerics/partial_sum/requirements/\n\texplicit_instantiation/2.cc: Likewise.\n\t* testsuite/26_numerics/partial_sum/requirements/\n\texplicit_instantiation/pod.cc: Likewise.\n\t* testsuite/experimental/iterator/requirements.cc: Likewise.\n\t* testsuite/std/ranges/access/begin.cc: New test.\n\t* testsuite/std/ranges/access/cbegin.cc: New test.\n\t* testsuite/std/ranges/access/cdata.cc: New test.\n\t* testsuite/std/ranges/access/cend.cc: New test.\n\t* testsuite/std/ranges/access/crbegin.cc: New test.\n\t* testsuite/std/ranges/access/crend.cc: New test.\n\t* testsuite/std/ranges/access/data.cc: New test.\n\t* testsuite/std/ranges/access/empty.cc: New test.\n\t* testsuite/std/ranges/access/end.cc: New test.\n\t* testsuite/std/ranges/access/rbegin.cc: New test.\n\t* testsuite/std/ranges/access/rend.cc: New test.\n\t* testsuite/std/ranges/access/size.cc: New test.\n\t* testsuite/util/testsuite_iterators.h (contiguous_iterator_wrapper)\n\t(test_range, test_sized_range): New test utilities.\n\nFrom-SVN: r277579", "tree": {"sha": "e438e2b4a9d49f1cc15e751a889a0ed890cfd287", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e438e2b4a9d49f1cc15e751a889a0ed890cfd287"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6d0dff49ca1539e14647c04cc1bb035ef4c2780b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d0dff49ca1539e14647c04cc1bb035ef4c2780b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d0dff49ca1539e14647c04cc1bb035ef4c2780b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d0dff49ca1539e14647c04cc1bb035ef4c2780b/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9921ac3db381106b66b70d8bf99136b265ec07c3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9921ac3db381106b66b70d8bf99136b265ec07c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9921ac3db381106b66b70d8bf99136b265ec07c3"}], "stats": {"total": 4339, "additions": 4262, "deletions": 77}, "files": [{"sha": "ad595aa7a6573361ffcb331a809615d85cb2edc5", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d0dff49ca1539e14647c04cc1bb035ef4c2780b/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d0dff49ca1539e14647c04cc1bb035ef4c2780b/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=6d0dff49ca1539e14647c04cc1bb035ef4c2780b", "patch": "@@ -1,5 +1,85 @@\n 2019-10-29  Jonathan Wakely  <jwakely@redhat.com>\n \n+\t* include/Makefile.am: Add new header.\n+\t* include/Makefile.in: Regenerate.\n+\t* include/bits/iterator_concepts.h: New header.\n+\t(contiguous_iterator_tag, iter_reference_t, ranges::iter_move)\n+\t(iter_rvalue_reference_t, incrementable_traits, iter_difference_t)\n+\t(readable_traits, iter_value_t, readable, iter_common_reference_t)\n+\t(writable, waekly_incrementable, incrementable)\n+\t(input_or_output_iterator, sentinel_for, disable_sized_sentinel)\n+\t(sized_sentinel_for, input_iterator, output_iterator)\n+\t(forward_iterator, bidirectional_iterator, random_access_iterator)\n+\t(contiguous_iterator, indirectly_unary_invocable)\n+\t(indirectly_regular_unary_invocable, indirect_unary_predicate)\n+\t(indirect_relation, indirect_strict_weak_order, indirect_result_t)\n+\t(projected, indirectly_movable, indirectly_movable_storable)\n+\t(indirectly_copyable, indirectly_copyable_storable, ranges::iter_swap)\n+\t(indirectly_swappable, indirectly_comparable, permutable, mergeable)\n+\t(sortable, unreachable_sentinel_t, unreachable_sentinel)\n+\t(default_sentinel_t, default_sentinel): Define.\n+\t(__detail::__cpp17_iterator, __detail::__cpp17_input_iterator)\n+\t(__detail::__cpp17_fwd_iterator, __detail::__cpp17_bidi_iterator)\n+\t(__detail::__cpp17_randacc_iterator): Define.\n+\t(__iterator_traits): Define constrained specializations.\n+\t* include/bits/move.h (move): Only use old concept check for C++98.\n+\t* include/bits/range_access.h (ranges::disable_sized_range)\n+\t(ranges::begin, ranges::end, ranges::cbegin, ranges::cend)\n+\t(ranges::rbegin, ranges::rend, ranges::crbegin, ranges::crend)\n+\t(ranges::size, ranges::empty, ranges::data, ranges::cdata): Define\n+\tnew customization points for C++20.\n+\t(ranges::range, ranges::sized_range): Define new concepts for C++20.\n+\t(ranges::advance, ranges::distance, ranges::next, ranges::prev):\n+\tDefine new functions for C++20.\n+\t(__adl_end, __adl_cdata, __adl_cbegin, __adl_cend, __adl_rbegin)\n+\t(__adl_rend, __adl_crbegin, __adl_crend, __adl_cdata, __adl_size)\n+\t(__adl_empty): Remove.\n+\t* include/bits/stl_iterator.h (disable_sized_sentinel): Specialize\n+\tfor reverse_iterator.\n+\t* include/bits/stl_iterator_base_types.h (contiguous_iterator_tag):\n+\tDefine new struct for C++20.\n+\t(iterator_traits<_Tp*>): Constrain partial specialization in C++20.\n+\t* include/std/concepts (__is_class_or_enum): Move to __detail\n+\tnamespace.\n+\t* testsuite/20_util/forward/c_neg.cc: Adjust dg-error line number.\n+\t* testsuite/20_util/forward/f_neg.cc: Likewise.\n+\t* testsuite/24_iterators/associated_types/incrementable.traits.cc: New\n+\ttest.\n+\t* testsuite/24_iterators/associated_types/readable.traits.cc: New test.\n+\t* testsuite/24_iterators/contiguous/concept.cc: New test.\n+\t* testsuite/24_iterators/contiguous/tag.cc: New test.\n+\t* testsuite/24_iterators/customization_points/iter_move.cc: New test.\n+\t* testsuite/24_iterators/customization_points/iter_swap.cc: New test.\n+\t* testsuite/24_iterators/headers/iterator/synopsis_c++20.cc: New test.\n+\t* testsuite/24_iterators/range_operations/advance.cc: New test.\n+\t* testsuite/24_iterators/range_operations/distance.cc: New test.\n+\t* testsuite/24_iterators/range_operations/next.cc: New test.\n+\t* testsuite/24_iterators/range_operations/prev.cc: New test.\n+\t* testsuite/26_numerics/adjacent_difference/requirements/\n+\texplicit_instantiation/2.cc: Rename types that conflict with C++20\n+\tconcepts.\n+\t* testsuite/26_numerics/adjacent_difference/requirements/\n+\texplicit_instantiation/pod.cc: Likewise.\n+\t* testsuite/26_numerics/partial_sum/requirements/\n+\texplicit_instantiation/2.cc: Likewise.\n+\t* testsuite/26_numerics/partial_sum/requirements/\n+\texplicit_instantiation/pod.cc: Likewise.\n+\t* testsuite/experimental/iterator/requirements.cc: Likewise.\n+\t* testsuite/std/ranges/access/begin.cc: New test.\n+\t* testsuite/std/ranges/access/cbegin.cc: New test.\n+\t* testsuite/std/ranges/access/cdata.cc: New test.\n+\t* testsuite/std/ranges/access/cend.cc: New test.\n+\t* testsuite/std/ranges/access/crbegin.cc: New test.\n+\t* testsuite/std/ranges/access/crend.cc: New test.\n+\t* testsuite/std/ranges/access/data.cc: New test.\n+\t* testsuite/std/ranges/access/empty.cc: New test.\n+\t* testsuite/std/ranges/access/end.cc: New test.\n+\t* testsuite/std/ranges/access/rbegin.cc: New test.\n+\t* testsuite/std/ranges/access/rend.cc: New test.\n+\t* testsuite/std/ranges/access/size.cc: New test.\n+\t* testsuite/util/testsuite_iterators.h (contiguous_iterator_wrapper)\n+\t(test_range, test_sized_range): New test utilities.\n+\n \t* testsuite/util/testsuite_iterators.h (BoundsContainer::size()): Add\n \tnew member function.\n \t(WritableObject::operator=): Constrain with enable_if when available."}, {"sha": "401c87ad103ca0b8bfedb3726ef90bebc71cd1b4", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d0dff49ca1539e14647c04cc1bb035ef4c2780b/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d0dff49ca1539e14647c04cc1bb035ef4c2780b/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=6d0dff49ca1539e14647c04cc1bb035ef4c2780b", "patch": "@@ -129,6 +129,7 @@ bits_headers = \\\n \t${bits_srcdir}/invoke.h \\\n \t${bits_srcdir}/ios_base.h \\\n \t${bits_srcdir}/istream.tcc \\\n+\t${bits_srcdir}/iterator_concepts.h \\\n \t${bits_srcdir}/list.tcc \\\n \t${bits_srcdir}/locale_classes.h \\\n \t${bits_srcdir}/locale_classes.tcc \\"}, {"sha": "e0a749635471c68e5dd1d1225428de6b46902d5a", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d0dff49ca1539e14647c04cc1bb035ef4c2780b/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d0dff49ca1539e14647c04cc1bb035ef4c2780b/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=6d0dff49ca1539e14647c04cc1bb035ef4c2780b", "patch": "@@ -473,6 +473,7 @@ bits_headers = \\\n \t${bits_srcdir}/invoke.h \\\n \t${bits_srcdir}/ios_base.h \\\n \t${bits_srcdir}/istream.tcc \\\n+\t${bits_srcdir}/iterator_concepts.h \\\n \t${bits_srcdir}/list.tcc \\\n \t${bits_srcdir}/locale_classes.h \\\n \t${bits_srcdir}/locale_classes.tcc \\"}, {"sha": "323689e63ea399d09e34ee5c8c2d35bacaa2fa81", "filename": "libstdc++-v3/include/bits/iterator_concepts.h", "status": "added", "additions": 828, "deletions": 0, "changes": 828, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d0dff49ca1539e14647c04cc1bb035ef4c2780b/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fiterator_concepts.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d0dff49ca1539e14647c04cc1bb035ef4c2780b/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fiterator_concepts.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fiterator_concepts.h?ref=6d0dff49ca1539e14647c04cc1bb035ef4c2780b", "patch": "@@ -0,0 +1,828 @@\n+// Concepts and traits for use with iterators -*- C++ -*-\n+\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/** @file bits/iterator_concepts.h\n+ *  This is an internal header file, included by other library headers.\n+ *  Do not attempt to use it directly. @headername{iterator}\n+ */\n+\n+#ifndef _ITERATOR_CONCEPTS_H\n+#define _ITERATOR_CONCEPTS_H 1\n+\n+#pragma GCC system_header\n+\n+#include <concepts>\n+#include <bits/ptr_traits.h>\t// to_address\n+#include <bits/range_cmp.h>\t// identity, ranges::less\n+\n+#if __cpp_lib_concepts\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+  struct input_iterator_tag;\n+  struct output_iterator_tag;\n+  struct forward_iterator_tag;\n+  struct bidirectional_iterator_tag;\n+  struct random_access_iterator_tag;\n+  struct contiguous_iterator_tag;\n+\n+  template<typename _Iterator>\n+    struct iterator_traits;\n+\n+  template<typename _Tp> requires is_object_v<_Tp>\n+    struct iterator_traits<_Tp*>;\n+\n+  template<typename _Iterator, typename>\n+    struct __iterator_traits;\n+\n+  namespace __detail\n+  {\n+    template<typename _Tp>\n+      using __with_ref = _Tp&;\n+\n+    template<typename _Tp>\n+      concept __can_reference = requires { typename __with_ref<_Tp>; };\n+\n+    template<typename _Tp>\n+      concept __dereferenceable = requires(_Tp& __t)\n+\t{\n+\t  { *__t } -> __can_reference;\n+\t};\n+\n+    // FIXME: needed due to PR c++/67704\n+    template<__detail::__dereferenceable _Tp>\n+      struct __iter_ref\n+      {\n+\tusing type = decltype(*std::declval<_Tp&>());\n+      };\n+  } // namespace __detail\n+\n+  template<typename _Tp>\n+    using iter_reference_t = typename __detail::__iter_ref<_Tp>::type;\n+\n+  namespace ranges\n+  {\n+    namespace __cust_imove\n+    {\n+      template<typename _Tp>\n+\tconcept __adl_imove\n+\t  = (std::__detail::__class_or_enum<remove_reference_t<_Tp>>)\n+\t  && requires(_Tp&& __t) { iter_move(static_cast<_Tp&&>(__t)); };\n+\n+      struct _IMove\n+      {\n+      private:\n+\ttemplate<typename _Tp>\n+\t  static constexpr bool\n+\t  _S_noexcept()\n+\t  {\n+\t    if constexpr (__adl_imove<_Tp>)\n+\t      return noexcept(iter_move(std::declval<_Tp>()));\n+\t    else\n+\t      return noexcept(*std::declval<_Tp>());\n+\t  }\n+\n+      public:\n+\ttemplate<typename _Tp>\n+\t  requires __adl_imove<_Tp> || requires(_Tp& __e) { *__e; }\n+\t  constexpr decltype(auto)\n+\t  operator()(_Tp&& __e) const\n+\t  noexcept(_S_noexcept<_Tp>())\n+\t  {\n+\t    if constexpr (__adl_imove<_Tp>)\n+\t      return iter_move(static_cast<_Tp&&>(__e));\n+\t    else if constexpr (is_reference_v<iter_reference_t<_Tp>>)\n+\t      return std::move(*__e);\n+\t    else\n+\t      return *__e;\n+\t  }\n+      };\n+    } // namespace __cust_imove\n+\n+    inline namespace __cust\n+    {\n+      inline constexpr __cust_imove::_IMove iter_move{};\n+    } // inline namespace __cust\n+  } // namespace ranges\n+\n+  namespace __detail\n+  {\n+    // FIXME: needed due to PR c++/67704\n+    template<__detail::__dereferenceable _Tp>\n+      struct __iter_rvalue_ref\n+      { };\n+\n+    template<__detail::__dereferenceable _Tp>\n+      requires requires(_Tp& __t)\n+      {\n+\t{ ranges::iter_move(__t) } -> __detail::__can_reference;\n+      }\n+      struct __iter_rvalue_ref<_Tp>\n+      { using type = decltype(ranges::iter_move(std::declval<_Tp&>())); };\n+\n+  } // namespace __detail\n+\n+  template<typename _Tp>\n+    using iter_rvalue_reference_t\n+      = typename __detail::__iter_rvalue_ref<_Tp>::type;\n+\n+  template<typename> struct incrementable_traits { };\n+\n+  template<typename _Tp> requires is_object_v<_Tp>\n+    struct incrementable_traits<_Tp*>\n+    { using difference_type = ptrdiff_t; };\n+\n+  template<typename _Iter>\n+    struct incrementable_traits<const _Iter>\n+    : incrementable_traits<_Iter> { };\n+\n+  template<typename _Tp> requires requires { typename _Tp::difference_type; }\n+    struct incrementable_traits<_Tp>\n+    { using difference_type = typename _Tp::difference_type; };\n+\n+  template<typename _Tp>\n+    requires (!requires { typename _Tp::difference_type; }\n+\t      && requires(const _Tp& __a, const _Tp& __b)\n+\t      {\n+\t\trequires (!is_void_v<remove_pointer_t<_Tp>>); // PR c++/78173\n+\t\t{ __a - __b } -> integral;\n+\t      })\n+    struct incrementable_traits<_Tp>\n+    {\n+      using difference_type\n+\t= make_signed_t<decltype(std::declval<_Tp>() - std::declval<_Tp>())>;\n+    };\n+\n+  namespace __detail\n+  {\n+    // An iterator such that iterator_traits<_Iter> names a specialization\n+    // generated from the primary template.\n+    template<typename _Iter>\n+      concept __primary_traits_iter\n+\t= __is_base_of(__iterator_traits<_Iter, void>, iterator_traits<_Iter>);\n+\n+    template<typename _Iter, typename _Tp>\n+      struct __iter_traits_impl\n+      { using type = iterator_traits<_Iter>; };\n+\n+    template<typename _Iter, typename _Tp>\n+      requires __primary_traits_iter<_Iter>\n+      struct __iter_traits_impl<_Iter, _Tp>\n+      { using type = _Tp; };\n+\n+    // ITER_TRAITS\n+    template<typename _Iter, typename _Tp = _Iter>\n+      using __iter_traits = typename __iter_traits_impl<_Iter, _Tp>::type;\n+  } // namespace __detail\n+\n+  template<typename _Tp>\n+    using iter_difference_t = typename\n+      __detail::__iter_traits<_Tp, incrementable_traits<_Tp>>::difference_type;\n+\n+  namespace __detail\n+  {\n+    template<typename> struct __cond_value_type { };\n+\n+    template<typename _Tp> requires is_object_v<_Tp>\n+      struct __cond_value_type<_Tp>\n+      { using value_type = remove_cv_t<_Tp>; };\n+  } // namespace __detail\n+\n+  template<typename> struct readable_traits { };\n+\n+  template<typename _Tp>\n+    struct readable_traits<_Tp*>\n+    : __detail::__cond_value_type<_Tp>\n+    { };\n+\n+  template<typename _Iter> requires is_array_v<_Iter>\n+    struct readable_traits<_Iter>\n+    { using value_type = remove_cv_t<remove_extent_t<_Iter>>; };\n+\n+  template<typename _Iter>\n+    struct readable_traits<const _Iter>\n+    : readable_traits<_Iter>\n+    { };\n+\n+  template<typename _Tp> requires requires { typename _Tp::value_type; }\n+    struct readable_traits<_Tp>\n+    : __detail::__cond_value_type<typename _Tp::value_type>\n+    { };\n+\n+  template<typename _Tp> requires requires { typename _Tp::element_type; }\n+    struct readable_traits<_Tp>\n+    : __detail::__cond_value_type<typename _Tp::element_type>\n+    { };\n+\n+  template<typename _Tp>\n+    using iter_value_t = typename\n+      __detail::__iter_traits<_Tp, readable_traits<_Tp>>::value_type;\n+\n+  namespace __detail\n+  {\n+    template<typename _Iter>\n+      concept __cpp17_iterator = copyable<_Iter>\n+\t&& requires(_Iter __it)\n+\t{\n+\t  { *__it } -> __can_reference;\n+\t  { ++__it } -> same_as<_Iter&>;\n+\t  { *__it++ } -> __can_reference;\n+\t};\n+\n+    template<typename _Iter>\n+      concept __cpp17_input_iterator = __cpp17_iterator<_Iter>\n+\t&& equality_comparable<_Iter>\n+\t&& requires(_Iter __it)\n+\t{\n+\t  typename incrementable_traits<_Iter>::difference_type;\n+\t  typename readable_traits<_Iter>::value_type;\n+\t  typename common_reference_t<iter_reference_t<_Iter>&&,\n+\t\t   typename readable_traits<_Iter>::value_type&>;\n+\t  typename common_reference_t<decltype(*__it++)&&,\n+\t\t   typename readable_traits<_Iter>::value_type&>;\n+\t  requires signed_integral<typename incrementable_traits<_Iter>::difference_type>;\n+\t};\n+\n+    template<typename _Iter>\n+      concept __cpp17_fwd_iterator = __cpp17_input_iterator<_Iter>\n+\t&& constructible_from<_Iter>\n+\t&& is_lvalue_reference_v<iter_reference_t<_Iter>>\n+\t&& same_as<remove_cvref_t<iter_reference_t<_Iter>>,\n+\t\t   typename readable_traits<_Iter>::value_type>\n+\t&& requires(_Iter __it)\n+\t{\n+\t  {  __it++ } -> convertible_to<const _Iter&>;\n+\t  { *__it++ } -> same_as<iter_reference_t<_Iter>>;\n+\t};\n+\n+    template<typename _Iter>\n+      concept __cpp17_bidi_iterator = __cpp17_fwd_iterator<_Iter>\n+\t&& requires(_Iter __it)\n+\t{\n+\t  {  --__it } -> same_as<_Iter&>;\n+\t  {  __it-- } -> convertible_to<const _Iter&>;\n+\t  { *__it-- } -> same_as<iter_reference_t<_Iter>>;\n+\t};\n+\n+    template<typename _Iter>\n+      concept __cpp17_randacc_iterator = __cpp17_bidi_iterator<_Iter>\n+\t&& totally_ordered<_Iter>\n+\t&& requires(_Iter __it,\n+\t\t    typename incrementable_traits<_Iter>::difference_type __n)\n+\t{\n+\t  { __it += __n } -> same_as<_Iter&>;\n+\t  { __it -= __n } -> same_as<_Iter&>;\n+\t  { __it +  __n } -> same_as<_Iter>;\n+\t  { __n +  __it } -> same_as<_Iter>;\n+\t  { __it -  __n } -> same_as<_Iter>;\n+\t  { __it -  __it } -> same_as<decltype(__n)>;\n+\t  {  __it[__n]  } -> convertible_to<iter_reference_t<_Iter>>;\n+\t};\n+\n+    template<typename _Iter>\n+      concept __iter_with_nested_types = requires {\n+\ttypename _Iter::iterator_category;\n+\ttypename _Iter::value_type;\n+\ttypename _Iter::difference_type;\n+\ttypename _Iter::reference;\n+      };\n+\n+    // FIXME: needed due to PR c++/92102\n+    template<typename _Iter>\n+      concept __iter_without_nested_types = !__iter_with_nested_types<_Iter>;\n+\n+    template<typename _Iter, bool __use_arrow = false>\n+      struct __ptr\n+      { using type = void; };\n+\n+    template<typename _Iter> requires requires { typename _Iter::pointer; }\n+      struct __ptr<_Iter, true>\n+      { using type = typename _Iter::pointer; };\n+\n+    template<typename _Iter> requires requires { typename _Iter::pointer; }\n+      struct __ptr<_Iter, false>\n+      { using type = typename _Iter::pointer; };\n+\n+    template<typename _Iter>\n+      requires (!requires { typename _Iter::pointer; }\n+\t  && requires(_Iter& __it) { __it.operator->(); })\n+      struct __ptr<_Iter, true>\n+      { using type = decltype(std::declval<_Iter&>().operator->()); };\n+\n+    template<typename _Iter>\n+      struct __ref\n+      { using type = iter_reference_t<_Iter>; };\n+\n+    template<typename _Iter> requires requires { typename _Iter::reference; }\n+      struct __ref<_Iter>\n+      { using type = typename _Iter::reference; };\n+\n+    template<typename _Iter>\n+      struct __cat\n+      { using type = input_iterator_tag; };\n+\n+    template<typename _Iter>\n+      requires requires { typename _Iter::iterator_category; }\n+      struct __cat<_Iter>\n+      { using type = typename _Iter::iterator_category; };\n+\n+    template<typename _Iter>\n+      requires (!requires { typename _Iter::iterator_category; }\n+\t\t&& __detail::__cpp17_randacc_iterator<_Iter>)\n+      struct __cat<_Iter>\n+      { using type = random_access_iterator_tag; };\n+\n+    template<typename _Iter>\n+      requires (!requires { typename _Iter::iterator_category; }\n+\t\t&& __detail::__cpp17_bidi_iterator<_Iter>)\n+      struct __cat<_Iter>\n+      { using type = bidirectional_iterator_tag; };\n+\n+    template<typename _Iter>\n+      requires (!requires { typename _Iter::iterator_category; }\n+\t\t&& __detail::__cpp17_fwd_iterator<_Iter>)\n+      struct __cat<_Iter>\n+      { using type = forward_iterator_tag; };\n+\n+    template<typename _Iter>\n+      struct __diff\n+      { using type = void; };\n+\n+    template<typename _Iter>\n+      requires requires {\n+\ttypename incrementable_traits<_Iter>::difference_type;\n+      }\n+      struct __diff<_Iter>\n+      {\n+\tusing type = typename incrementable_traits<_Iter>::difference_type;\n+      };\n+\n+  } // namespace __detail\n+\n+  template<typename _Iterator>\n+    requires __detail::__iter_with_nested_types<_Iterator>\n+    struct __iterator_traits<_Iterator, void>\n+    {\n+      using iterator_category = typename _Iterator::iterator_category;\n+      using value_type\t      = typename _Iterator::value_type;\n+      using difference_type   = typename _Iterator::difference_type;\n+      using pointer\t      = typename __detail::__ptr<_Iterator>::type;\n+      using reference\t      = typename _Iterator::reference;\n+    };\n+\n+  template<typename _Iterator>\n+    requires __detail::__iter_without_nested_types<_Iterator>\n+\t      && __detail::__cpp17_input_iterator<_Iterator>\n+    struct __iterator_traits<_Iterator, void>\n+    {\n+      using iterator_category = typename __detail::__cat<_Iterator>::type;\n+      using value_type\n+\t= typename readable_traits<_Iterator>::value_type;\n+      using difference_type\n+\t= typename incrementable_traits<_Iterator>::difference_type;\n+      using pointer\t      = typename __detail::__ptr<_Iterator, true>::type;\n+      using reference\t      = typename __detail::__ref<_Iterator>::type;\n+    };\n+\n+  template<typename _Iterator>\n+    requires __detail::__iter_without_nested_types<_Iterator>\n+\t      && __detail::__cpp17_iterator<_Iterator>\n+    struct __iterator_traits<_Iterator, void>\n+    {\n+      using iterator_category = output_iterator_tag;\n+      using value_type\t      = void;\n+      using difference_type   = typename __detail::__diff<_Iterator>::type;\n+      using pointer\t      = void;\n+      using reference\t      = void;\n+    };\n+\n+  namespace __detail\n+  {\n+    template<typename _Iter>\n+      struct __iter_concept_impl\n+      { };\n+\n+    template<typename _Iter>\n+      requires requires { typename __iter_traits<_Iter>::iterator_concept; }\n+      struct __iter_concept_impl<_Iter>\n+      { using type = typename __iter_traits<_Iter>::iterator_concept; };\n+\n+    template<typename _Iter>\n+      requires (!requires { typename __iter_traits<_Iter>::iterator_concept; }\n+\t  && requires { typename __iter_traits<_Iter>::iterator_category; })\n+      struct __iter_concept_impl<_Iter>\n+      { using type = typename __iter_traits<_Iter>::iterator_category; };\n+\n+    template<typename _Iter>\n+      requires (!requires { typename __iter_traits<_Iter>::iterator_concept; }\n+\t  && !requires { typename __iter_traits<_Iter>::iterator_category; }\n+\t  && __primary_traits_iter<_Iter>)\n+      struct __iter_concept_impl<_Iter>\n+      { using type = random_access_iterator_tag; };\n+\n+    // ITER_TRAITS\n+    template<typename _Iter>\n+      using __iter_concept = typename __iter_concept_impl<_Iter>::type;\n+  } // namespace __detail\n+\n+  /// Requirements for types that are readable by applying operator*.\n+  template<typename _In>\n+    concept readable = requires\n+      {\n+\ttypename iter_value_t<_In>;\n+\ttypename iter_reference_t<_In>;\n+\ttypename iter_rvalue_reference_t<_In>;\n+      }\n+      && common_reference_with<iter_reference_t<_In>&&, iter_value_t<_In>&>\n+      && common_reference_with<iter_reference_t<_In>&&,\n+\t\t\t      iter_rvalue_reference_t<_In>&&>\n+      && common_reference_with<iter_rvalue_reference_t<_In>&&,\n+\t\t\t       const iter_value_t<_In>&>;\n+\n+  namespace __detail\n+  {\n+    // FIXME: needed due to PR c++/67704\n+    template<readable _Tp>\n+      struct __iter_common_ref\n+      : common_reference<iter_reference_t<_Tp>, iter_value_t<_Tp>&>\n+      { };\n+\n+    // FIXME: needed due to PR c++/67704\n+    template<typename _Fn, typename... _Is>\n+      struct __indirect_result\n+      { };\n+\n+    template<typename _Fn, typename... _Is>\n+      requires (readable<_Is> && ...)\n+\t&& invocable<_Fn, iter_reference_t<_Is>...>\n+      struct __indirect_result<_Fn, _Is...>\n+      : invoke_result<_Fn, iter_reference_t<_Is>...>\n+      { };\n+  } // namespace __detail\n+\n+  template<typename _Tp>\n+    using iter_common_reference_t\n+      = typename __detail::__iter_common_ref<_Tp>::type;\n+\n+  /// Requirements for writing a value into an iterator's referenced object.\n+  template<typename _Out, typename _Tp>\n+    concept writable = requires(_Out&& __o, _Tp&& __t)\n+      {\n+\t*__o = std::forward<_Tp>(__t);\n+\t*std::forward<_Out>(__o) = std::forward<_Tp>(__t);\n+\tconst_cast<const iter_reference_t<_Out>&&>(*__o)\n+\t  = std::forward<_Tp>(__t);\n+\tconst_cast<const iter_reference_t<_Out>&&>(*std::forward<_Out>(__o))\n+\t  = std::forward<_Tp>(__t);\n+      };\n+\n+  /// Requirements on types that can be incremented with ++.\n+  template<typename _Iter>\n+    concept weakly_incrementable = default_constructible<_Iter>\n+      && movable<_Iter>\n+      && requires(_Iter __i)\n+      {\n+\ttypename iter_difference_t<_Iter>;\n+\trequires signed_integral<iter_difference_t<_Iter>>;\n+\t{ ++__i } -> same_as<_Iter&>;\n+\t__i++;\n+      };\n+\n+  template<typename _Iter>\n+    concept incrementable = regular<_Iter> && weakly_incrementable<_Iter>\n+      && requires(_Iter __i) { { __i++ } -> same_as<_Iter>; };\n+\n+  template<typename _Iter>\n+    concept input_or_output_iterator\n+      = requires(_Iter __i) { { *__i } -> __detail::__can_reference; }\n+\t&& weakly_incrementable<_Iter>;\n+\n+  template<typename _Sent, typename _Iter>\n+    concept sentinel_for = semiregular<_Sent>\n+      && input_or_output_iterator<_Iter>\n+      && __detail::__weakly_eq_cmp_with<_Sent, _Iter>;\n+\n+  template<typename _Sent, typename _Iter>\n+    inline constexpr bool disable_sized_sentinel = false;\n+\n+  template<typename _Sent, typename _Iter>\n+    concept sized_sentinel_for = sentinel_for<_Sent, _Iter>\n+    && !disable_sized_sentinel<remove_cv_t<_Sent>, remove_cv_t<_Iter>>\n+    && requires(const _Iter& __i, const _Sent& __s)\n+    {\n+      { __s - __i } -> same_as<iter_difference_t<_Iter>>;\n+      { __i - __s } -> same_as<iter_difference_t<_Iter>>;\n+    };\n+\n+  template<typename _Iter>\n+    concept input_iterator = input_or_output_iterator<_Iter>\n+      && readable<_Iter>\n+      && requires { typename __detail::__iter_concept<_Iter>; }\n+      && derived_from<__detail::__iter_concept<_Iter>, input_iterator_tag>;\n+\n+  template<typename _Iter, typename _Tp>\n+    concept output_iterator = input_or_output_iterator<_Iter>\n+      && writable<_Iter, _Tp>\n+      && requires(_Iter __i, _Tp&& __t) { *__i++ = std::forward<_Tp>(__t); };\n+\n+  template<typename _Iter>\n+    concept forward_iterator = input_iterator<_Iter>\n+      && derived_from<__detail::__iter_concept<_Iter>, forward_iterator_tag>\n+      && incrementable<_Iter> && sentinel_for<_Iter, _Iter>;\n+\n+  template<typename _Iter>\n+    concept bidirectional_iterator = forward_iterator<_Iter>\n+      && derived_from<__detail::__iter_concept<_Iter>,\n+\t\t      bidirectional_iterator_tag>\n+      && requires(_Iter __i)\n+      {\n+\t{ --__i } -> same_as<_Iter&>;\n+\t{ __i-- } -> same_as<_Iter>;\n+      };\n+\n+  template<typename _Iter>\n+    concept random_access_iterator = bidirectional_iterator<_Iter>\n+      && derived_from<__detail::__iter_concept<_Iter>,\n+\t\t      random_access_iterator_tag>\n+      && totally_ordered<_Iter> && sized_sentinel_for<_Iter, _Iter>\n+      && requires(_Iter __i, const _Iter __j,\n+\t\t  const iter_difference_t<_Iter> __n)\n+      {\n+\t{ __i += __n } -> same_as<_Iter&>;\n+\t{ __j +  __n } -> same_as<_Iter>;\n+\t{ __n +  __j } -> same_as<_Iter>;\n+\t{ __i -= __n } -> same_as<_Iter&>;\n+\t{ __j -  __n } -> same_as<_Iter>;\n+\t{  __j[__n]  } -> same_as<iter_reference_t<_Iter>>;\n+      };\n+\n+  template<typename _Iter>\n+    concept contiguous_iterator = random_access_iterator<_Iter>\n+      && derived_from<__detail::__iter_concept<_Iter>, contiguous_iterator_tag>\n+      && is_lvalue_reference_v<iter_reference_t<_Iter>>\n+      && same_as<iter_value_t<_Iter>, remove_cvref_t<iter_reference_t<_Iter>>>\n+      && requires(const _Iter& __i)\n+      {\n+\t{ std::to_address(__i) }\n+\t  -> same_as<add_pointer_t<iter_reference_t<_Iter>>>;\n+      };\n+\n+  // [indirectcallable], indirect callable requirements\n+\n+  // [indirectcallable.indirectinvocable], indirect callables\n+\n+  template<typename _Fn, typename _Iter>\n+    concept indirectly_unary_invocable = readable<_Iter>\n+      && copy_constructible<_Fn> && invocable<_Fn&, iter_value_t<_Iter>&>\n+      && invocable<_Fn&, iter_reference_t<_Iter>>\n+      && invocable<_Fn&, iter_common_reference_t<_Iter>>\n+      && common_reference_with<invoke_result_t<_Fn&, iter_value_t<_Iter>&>,\n+\t\t\t       invoke_result_t<_Fn&, iter_reference_t<_Iter>>>;\n+\n+  template<typename _Fn, typename _Iter>\n+    concept indirectly_regular_unary_invocable = readable<_Iter>\n+      && copy_constructible<_Fn>\n+      && regular_invocable<_Fn&, iter_value_t<_Iter>&>\n+      && regular_invocable<_Fn&, iter_reference_t<_Iter>>\n+      && regular_invocable<_Fn&, iter_common_reference_t<_Iter>>\n+      && common_reference_with<invoke_result_t<_Fn&, iter_value_t<_Iter>&>,\n+\t\t\t       invoke_result_t<_Fn&, iter_reference_t<_Iter>>>;\n+\n+  template<typename _Fn, typename _Iter>\n+    concept indirect_unary_predicate = readable<_Iter>\n+      && copy_constructible<_Fn> && predicate<_Fn&, iter_value_t<_Iter>&>\n+      && predicate<_Fn&, iter_reference_t<_Iter>>\n+      && predicate<_Fn&, iter_common_reference_t<_Iter>>;\n+\n+  template<typename _Fn, typename _I1, typename _I2 = _I1>\n+    concept indirect_relation = readable<_I1> && readable<_I2>\n+      && copy_constructible<_Fn>\n+      && relation<_Fn&, iter_value_t<_I1>&, iter_value_t<_I2>&>\n+      && relation<_Fn&, iter_value_t<_I1>&, iter_reference_t<_I2>>\n+      && relation<_Fn&, iter_reference_t<_I1>, iter_value_t<_I2>&>\n+      && relation<_Fn&, iter_reference_t<_I1>, iter_reference_t<_I2>>\n+      && relation<_Fn&, iter_common_reference_t<_I1>,\n+\t\t  iter_common_reference_t<_I2>>;\n+\n+  template<typename _Fn, typename _I1, typename _I2 = _I1>\n+    concept indirect_strict_weak_order = readable<_I1> && readable<_I2>\n+      && copy_constructible<_Fn>\n+      && strict_weak_order<_Fn&, iter_value_t<_I1>&, iter_value_t<_I2>&>\n+      && strict_weak_order<_Fn&, iter_value_t<_I1>&, iter_reference_t<_I2>>\n+      && strict_weak_order<_Fn&, iter_reference_t<_I1>, iter_value_t<_I2>&>\n+      && strict_weak_order<_Fn&, iter_reference_t<_I1>, iter_reference_t<_I2>>\n+      && strict_weak_order<_Fn&, iter_common_reference_t<_I1>,\n+\t\t\t   iter_common_reference_t<_I2>>;\n+\n+  template<typename _Fn, typename... _Is>\n+    using indirect_result_t = typename\n+      __detail::__indirect_result<_Fn, iter_reference_t<_Is>...>::type;\n+\n+  /// [projected], projected\n+  template<readable _Iter, indirectly_regular_unary_invocable<_Iter> _Proj>\n+    struct projected\n+    {\n+      using value_type = remove_cvref_t<indirect_result_t<_Proj&, _Iter>>;\n+      indirect_result_t<_Proj&, _Iter> operator*() const; // not defined\n+    };\n+\n+  template<weakly_incrementable _Iter, typename _Proj>\n+    struct incrementable_traits<projected<_Iter, _Proj>>\n+    { using difference_type = iter_difference_t<_Iter>; };\n+\n+  // [alg.req], common algorithm requirements\n+\n+  /// [alg.req.ind.move], concept `indirectly_movable`\n+\n+  template<typename _In, typename _Out>\n+    concept indirectly_movable = readable<_In>\n+      && writable<_Out, iter_rvalue_reference_t<_In>>;\n+\n+  template<typename _In, typename _Out>\n+    concept indirectly_movable_storable = indirectly_movable<_In, _Out>\n+      && writable<_Out, iter_value_t<_In>> && movable<iter_value_t<_In>>\n+      && constructible_from<iter_value_t<_In>, iter_rvalue_reference_t<_In>>\n+      && assignable_from<iter_value_t<_In>&, iter_rvalue_reference_t<_In>>;\n+\n+  /// [alg.req.ind.copy], concept `indirectly_copyable`\n+  template<typename _In, typename _Out>\n+    concept indirectly_copyable = readable<_In>\n+      && writable<_Out, iter_reference_t<_In>>;\n+\n+  template<typename _In, typename _Out>\n+    concept indirectly_copyable_storable = indirectly_copyable<_In, _Out>\n+      && writable<_Out, const iter_value_t<_In>&>\n+      && copyable<iter_value_t<_In>>\n+      && constructible_from<iter_value_t<_In>, iter_reference_t<_In>>\n+      && assignable_from<iter_value_t<_In>&, iter_reference_t<_In>>;\n+\n+namespace ranges\n+{\n+  namespace __cust_iswap\n+  {\n+    template<typename _It1, typename _It2>\n+      void iter_swap(_It1&, _It2&) = delete;\n+\n+    template<typename _Tp, typename _Up>\n+      concept __adl_iswap\n+\t= (std::__detail::__class_or_enum<remove_reference_t<_Tp>>\n+\t  || std::__detail::__class_or_enum<remove_reference_t<_Up>>)\n+\t&& requires(_Tp&& __t, _Up&& __u) {\n+\t  iter_swap(static_cast<_Tp&&>(__t), static_cast<_Up&&>(__u));\n+\t};\n+\n+    template<typename _Xp, typename _Yp>\n+      constexpr iter_value_t<remove_reference_t<_Xp>>\n+      __iter_exchange_move(_Xp&& __x, _Yp&& __y)\n+      noexcept(noexcept(iter_value_t<remove_reference_t<_Xp>>(iter_move(__x)))\n+\t       && noexcept(*__x = iter_move(__y)))\n+      {\n+\titer_value_t<remove_reference_t<_Xp>> __old_value(iter_move(__x));\n+\t*__x = iter_move(__y);\n+\treturn __old_value;\n+      }\n+\n+    struct _IterSwap\n+    {\n+    private:\n+      template<typename _Tp, typename _Up>\n+\tstatic constexpr bool\n+\t_S_noexcept()\n+\t{\n+\t  if constexpr (__adl_iswap<_Tp, _Up>)\n+\t    return noexcept(iter_swap(std::declval<_Tp>(),\n+\t\t\t\t      std::declval<_Up>()));\n+\t  else if constexpr (readable<_Tp> && readable<_Up>\n+\t    && swappable_with<iter_reference_t<_Tp>, iter_reference_t<_Up>>)\n+\t    return noexcept(ranges::swap(*std::declval<_Tp>(),\n+\t\t\t\t\t *std::declval<_Up>()));\n+\t  else\n+\t    return noexcept(*std::declval<_Tp>()\n+\t\t= __iter_exchange_move(std::declval<_Up>(),\n+\t\t\t\t       std::declval<_Tp>()));\n+\t}\n+\n+    public:\n+      template<typename _Tp, typename _Up>\n+\trequires __adl_iswap<_Tp, _Up>\n+\t|| (readable<_Tp> && readable<_Up>\n+\t    && swappable_with<iter_reference_t<_Tp>, iter_reference_t<_Up>>)\n+\t|| (indirectly_movable_storable<_Tp, _Up>\n+\t    && indirectly_movable_storable<_Up, _Tp>)\n+\tconstexpr void\n+\toperator()(_Tp&& __e1, _Up&& __e2) const\n+\tnoexcept(_S_noexcept<_Tp, _Up>())\n+\t{\n+\t  if constexpr (__adl_iswap<_Tp, _Up>)\n+\t    iter_swap(static_cast<_Tp&&>(__e1), static_cast<_Up&&>(__e2));\n+\t  else if constexpr (readable<_Tp> && readable<_Up>\n+\t    && swappable_with<iter_reference_t<_Tp>, iter_reference_t<_Up>>)\n+\t    ranges::swap(*__e1, *__e2);\n+\t  else\n+\t    *__e1 = __iter_exchange_move(__e2, __e1);\n+\t}\n+    };\n+  } // namespace __cust_iswap\n+\n+  inline namespace __cust\n+  {\n+    inline constexpr __cust_iswap::_IterSwap iter_swap{};\n+  } // inline namespace __cust\n+\n+} // namespace ranges\n+\n+  /// [alg.req.ind.swap], concept `indirectly_swappable`\n+  template<typename _I1, typename _I2 = _I1>\n+    concept indirectly_swappable = readable<_I1> && readable<_I2>\n+      && requires(_I1& __i1, _I2& __i2)\n+      {\n+\tranges::iter_swap(__i1, __i1);\n+\tranges::iter_swap(__i2, __i2);\n+\tranges::iter_swap(__i1, __i2);\n+\tranges::iter_swap(__i2, __i1);\n+      };\n+\n+  /// [alg.req.ind.cmp], concept `indirectly_comparable`\n+  template<typename _I1, typename _I2, typename _Rel, typename _P1 = identity,\n+\t   typename _P2 = identity>\n+    concept indirectly_comparable\n+      = indirect_relation<_Rel, projected<_I1, _P1>, projected<_I2, _P2>>;\n+\n+  /// [alg.req.permutable], concept `permutable`\n+  template<typename _Iter>\n+    concept permutable = forward_iterator<_Iter>\n+      && indirectly_movable_storable<_Iter, _Iter>\n+      && indirectly_swappable<_Iter, _Iter>;\n+\n+  /// [alg.req.mergeable], concept `mergeable`\n+  template<typename _I1, typename _I2, typename _Out,\n+\t   typename _Rel = ranges::less, typename _P1 = identity,\n+\t   typename _P2 = identity>\n+    concept mergeable = input_iterator<_I1> && input_iterator<_I2>\n+      && weakly_incrementable<_Out> && indirectly_copyable<_I1, _Out>\n+      && indirectly_copyable<_I2, _Out>\n+      && indirect_strict_weak_order<_Rel, projected<_I1, _P1>,\n+\t\t\t\t    projected<_I2, _P2>>;\n+\n+  /// [alg.req.sortable], concept `sortable`\n+  template<typename _Iter, typename _Rel = ranges::less,\n+\t   typename _Proj = identity>\n+    concept sortable = permutable<_Iter>\n+      && indirect_strict_weak_order<_Rel, projected<_Iter, _Proj>>;\n+\n+  struct unreachable_sentinel_t\n+  {\n+    template<weakly_incrementable _It>\n+      friend constexpr bool\n+      operator==(unreachable_sentinel_t, const _It&) noexcept\n+      { return false; }\n+\n+#ifndef __cpp_lib_three_way_comparison\n+    template<weakly_incrementable _It>\n+      friend constexpr bool\n+      operator!=(unreachable_sentinel_t, const _It&) noexcept\n+      { return true; }\n+\n+    template<weakly_incrementable _It>\n+      friend constexpr bool\n+      operator==(const _It&, unreachable_sentinel_t) noexcept\n+      { return false; }\n+\n+    template<weakly_incrementable _It>\n+      friend constexpr bool\n+      operator!=(const _It&, unreachable_sentinel_t) noexcept\n+      { return true; }\n+#endif\n+  };\n+\n+  inline constexpr unreachable_sentinel_t unreachable_sentinel{};\n+\n+  struct default_sentinel_t { };\n+  inline constexpr default_sentinel_t default_sentinel{};\n+\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace std\n+#endif // C++20 library concepts\n+#endif // _ITERATOR_CONCEPTS_H"}, {"sha": "5d6541d193f7dad6689bf86e07b6a6f3e1727583", "filename": "libstdc++-v3/include/bits/move.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d0dff49ca1539e14647c04cc1bb035ef4c2780b/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fmove.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d0dff49ca1539e14647c04cc1bb035ef4c2780b/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fmove.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fmove.h?ref=6d0dff49ca1539e14647c04cc1bb035ef4c2780b", "patch": "@@ -31,7 +31,9 @@\n #define _MOVE_H 1\n \n #include <bits/c++config.h>\n-#include <bits/concept_check.h>\n+#if __cplusplus < 201103L\n+# include <bits/concept_check.h>\n+#endif\n \n namespace std _GLIBCXX_VISIBILITY(default)\n {\n@@ -188,9 +190,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     _GLIBCXX_NOEXCEPT_IF(__and_<is_nothrow_move_constructible<_Tp>,\n \t\t\t\tis_nothrow_move_assignable<_Tp>>::value)\n     {\n+#if __cplusplus < 201103L\n       // concept requirements\n       __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)\n-\n+#endif\n       _Tp __tmp = _GLIBCXX_MOVE(__a);\n       __a = _GLIBCXX_MOVE(__b);\n       __b = _GLIBCXX_MOVE(__tmp);"}, {"sha": "3b6ed9aa66a32eef7562a0146209228e8d6adb5b", "filename": "libstdc++-v3/include/bits/range_access.h", "status": "modified", "additions": 707, "deletions": 43, "changes": 750, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d0dff49ca1539e14647c04cc1bb035ef4c2780b/libstdc%2B%2B-v3%2Finclude%2Fbits%2Frange_access.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d0dff49ca1539e14647c04cc1bb035ef4c2780b/libstdc%2B%2B-v3%2Finclude%2Fbits%2Frange_access.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Frange_access.h?ref=6d0dff49ca1539e14647c04cc1bb035ef4c2780b", "patch": "@@ -34,6 +34,8 @@\n \n #if __cplusplus >= 201103L\n #include <initializer_list>\n+#include <bits/iterator_concepts.h>\n+\n namespace std _GLIBCXX_VISIBILITY(default)\n {\n _GLIBCXX_BEGIN_NAMESPACE_VERSION\n@@ -344,60 +346,722 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   template <typename _Container>\n     constexpr auto\n-    __adl_end(_Container& __cont) noexcept(noexcept(end(__cont)))\n-    { return end(__cont); }\n+    __adl_data(_Container& __cont) noexcept(noexcept(data(__cont)))\n+    { return data(__cont); }\n \n-  template <typename _Container>\n-    constexpr auto\n-    __adl_cbegin(_Container& __cont) noexcept(noexcept(cbegin(__cont)))\n-    { return cbegin(__cont); }\n+namespace ranges\n+{\n+  template<typename>\n+    inline constexpr bool disable_sized_range = false;\n \n-  template <typename _Container>\n-    constexpr auto\n-    __adl_cend(_Container& __cont) noexcept(noexcept(cend(__cont)))\n-    { return cend(__cont); }\n+  namespace __detail\n+  {\n+    using __max_diff_type = long long;\n+    using __max_size_type = unsigned long long;\n \n-  template <typename _Container>\n-    constexpr auto\n-    __adl_rbegin(_Container& __cont) noexcept(noexcept(rbegin(__cont)))\n-    { return rbegin(__cont); }\n+    template<typename _Tp>\n+      concept __is_integer_like = integral<_Tp>\n+\t|| same_as<_Tp, __max_diff_type> || same_as<_Tp, __max_size_type>;\n \n-  template <typename _Container>\n-    constexpr auto\n-    __adl_rend(_Container& __cont) noexcept(noexcept(rend(__cont)))\n-    { return rend(__cont); }\n+    template<typename _Tp>\n+      concept __is_signed_integer_like = signed_integral<_Tp>\n+\t|| same_as<_Tp, __max_diff_type>;\n \n-  template <typename _Container>\n-    constexpr auto\n-    __adl_crbegin(_Container& __cont) noexcept(noexcept(crbegin(__cont)))\n-    { return crbegin(__cont); }\n+    template<integral _Tp>\n+      constexpr make_unsigned_t<_Tp>\n+      __to_unsigned_like(_Tp __t) noexcept\n+      { return __t; }\n+  } // namespace __detail\n \n-  template <typename _Container>\n-    constexpr auto\n-    __adl_crend(_Container& __cont) noexcept(noexcept(crend(__cont)))\n-    { return crend(__cont); }\n+  namespace __cust_access\n+  {\n+    template<typename _Tp>\n+      constexpr decay_t<_Tp>\n+      __decay_copy(_Tp&& __t)\n+      noexcept(is_nothrow_convertible_v<_Tp, decay_t<_Tp>>)\n+      { return std::forward<_Tp>(__t); }\n \n-  template <typename _Container>\n-    constexpr auto\n-    __adl_data(_Container& __cont) noexcept(noexcept(data(__cont)))\n-    { return data(__cont); }\n+    template<typename _Tp>\n+      concept __member_begin = is_lvalue_reference_v<_Tp>\n+\t&& requires(_Tp __t)\n+\t{ { __decay_copy(__t.begin()) } -> input_or_output_iterator; };\n \n-  template <typename _Container>\n-    constexpr auto\n-    __adl_cdata(_Container& __cont) noexcept(noexcept(cdata(__cont)))\n-    { return cdata(__cont); }\n+    template<typename _Tp> void begin(_Tp&&) = delete;\n+    template<typename _Tp> void begin(initializer_list<_Tp>&&) = delete;\n \n-  template <typename _Container>\n-    constexpr auto\n-    __adl_size(_Container& __cont) noexcept(noexcept(size(__cont)))\n-    { return size(__cont); }\n+    template<typename _Tp>\n+      concept __adl_begin = requires(_Tp&& __t)\n+\t{\n+\t  { __decay_copy(begin(std::forward<_Tp>(__t))) }\n+\t    -> input_or_output_iterator;\n+\t};\n \n-  template <typename _Container>\n-    constexpr auto\n-    __adl_empty(_Container& __cont) noexcept(noexcept(empty(__cont)))\n-    { return empty(__cont); }\n-#endif // C++20\n+    template<typename _Tp>\n+      concept __complete_type = requires(_Tp* __p) { __p + 1; };\n+\n+    struct _Begin\n+    {\n+    private:\n+      template<typename _Tp>\n+\tstatic constexpr bool\n+\t_S_noexcept()\n+\t{\n+\t  if constexpr (__member_begin<_Tp>)\n+\t    return noexcept(__decay_copy(std::declval<_Tp>().begin()));\n+\t  else\n+\t    return noexcept(__decay_copy(begin(std::declval<_Tp>())));\n+\t}\n+\n+    public:\n+      template<__complete_type _Tp, size_t _Nm>\n+\tconstexpr _Tp*\n+\toperator()(_Tp (&__e)[_Nm]) const noexcept\n+\t{ return __e; }\n+\n+      template<typename _Tp> requires __member_begin<_Tp> || __adl_begin<_Tp>\n+\tconstexpr auto\n+\toperator()(_Tp&& __e) const noexcept(_S_noexcept<_Tp>())\n+\t{\n+\t  if constexpr (__member_begin<_Tp>)\n+\t    return __e.begin();\n+\t  else\n+\t    return begin(std::forward<_Tp>(__e));\n+\t}\n+    };\n+\n+    template<typename _Tp>\n+      concept __member_end = is_lvalue_reference_v<_Tp>\n+\t&& requires(_Tp __t)\n+\t{\n+\t  { __decay_copy(__t.end()) }\n+\t    -> sentinel_for<decltype(_Begin{}(__t))>;\n+\t};\n+\n+    template<typename _Tp> void end(_Tp&&) = delete;\n+    template<typename _Tp> void end(initializer_list<_Tp>&&) = delete;\n \n+    template<typename _Tp>\n+      concept __adl_end = requires(_Tp&& __t)\n+\t{\n+\t  { __decay_copy(end(std::forward<_Tp>(__t))) }\n+\t    -> sentinel_for<decltype(_Begin{}(std::forward<_Tp>(__t)))>;\n+\t};\n+\n+    struct _End\n+    {\n+    private:\n+      template<typename _Tp>\n+\tstatic constexpr bool\n+\t_S_noexcept()\n+\t{\n+\t  if constexpr (__member_end<_Tp>)\n+\t    return noexcept(__decay_copy(std::declval<_Tp>().end()));\n+\t  else\n+\t    return noexcept(__decay_copy(end(std::declval<_Tp>())));\n+\t}\n+\n+    public:\n+      template<__complete_type _Tp, size_t _Nm>\n+\tconstexpr _Tp*\n+\toperator()(_Tp (&__e)[_Nm]) const noexcept\n+\t{ return __e + _Nm; }\n+\n+      template<typename _Tp> requires __member_end<_Tp> || __adl_end<_Tp>\n+\tconstexpr auto\n+\toperator()(_Tp&& __e) const noexcept(_S_noexcept<_Tp>())\n+\t{\n+\t  if constexpr (__member_end<_Tp>)\n+\t    return __e.end();\n+\t  else\n+\t    return end(std::forward<_Tp>(__e));\n+\t}\n+    };\n+\n+    template<typename _Tp>\n+      constexpr decltype(auto)\n+      __as_const(_Tp&& __t) noexcept\n+      {\n+\tif constexpr (is_lvalue_reference_v<_Tp>)\n+\t  return static_cast<const remove_reference_t<_Tp>&>(__t);\n+\telse\n+\t  return static_cast<const _Tp&&>(__t);\n+      }\n+\n+    struct _CBegin\n+    {\n+      template<typename _Tp>\n+\tconstexpr auto\n+\toperator()(_Tp&& __e) const\n+\tnoexcept(noexcept(_Begin{}(__cust_access::__as_const((_Tp&&)__e))))\n+\trequires requires { _Begin{}(__cust_access::__as_const((_Tp&&)__e)); }\n+\t{\n+\t  return _Begin{}(__cust_access::__as_const(std::forward<_Tp>(__e)));\n+\t}\n+    };\n+\n+    struct _CEnd\n+    {\n+      template<typename _Tp>\n+\tconstexpr auto\n+\toperator()(_Tp&& __e) const\n+\tnoexcept(noexcept(_End{}(__cust_access::__as_const((_Tp&&)__e))))\n+\trequires requires { _End{}(__cust_access::__as_const((_Tp&&)__e)); }\n+\t{\n+\t  return _End{}(__cust_access::__as_const(std::forward<_Tp>(__e)));\n+\t}\n+    };\n+\n+    template<typename _Tp>\n+      concept __member_rbegin = is_lvalue_reference_v<_Tp>\n+\t&& requires(_Tp __t)\n+\t{ { __decay_copy(__t.rbegin()) } -> input_or_output_iterator; };\n+\n+    template<typename _Tp> void rbegin(_Tp&&) = delete;\n+\n+    template<typename _Tp>\n+      concept __adl_rbegin = requires(_Tp&& __t)\n+\t{\n+\t  { __decay_copy(rbegin(std::forward<_Tp>(__t))) }\n+\t    -> input_or_output_iterator;\n+\t};\n+\n+    template<typename _Tp>\n+      concept __reversable = requires(_Tp&& __t)\n+\t{\n+\t  { _Begin{}(std::forward<_Tp>(__t)) } -> bidirectional_iterator;\n+\t  { _End{}(std::forward<_Tp>(__t)) }\n+\t    -> same_as<decltype(_Begin{}(std::forward<_Tp>(__t)))>;\n+\t};\n+\n+    struct _RBegin\n+    {\n+    private:\n+      template<typename _Tp>\n+\tstatic constexpr bool\n+\t_S_noexcept()\n+\t{\n+\t  if constexpr (__member_rbegin<_Tp>)\n+\t    return noexcept(__decay_copy(std::declval<_Tp>().rbegin()));\n+\t  else if constexpr (__adl_rbegin<_Tp>)\n+\t    return noexcept(__decay_copy(rbegin(std::declval<_Tp>())));\n+\t  else if constexpr (noexcept(_End{}(std::declval<_Tp>())))\n+\t    {\n+\t      using _It = decltype(_End{}(std::declval<_Tp>()));\n+\t      // std::reverse_iterator copy-initializes its member.\n+\t      return is_nothrow_copy_constructible_v<_It>;\n+\t    }\n+\t  else\n+\t    return false;\n+\t}\n+\n+    public:\n+      template<typename _Tp>\n+\trequires __member_rbegin<_Tp> || __adl_rbegin<_Tp> || __reversable<_Tp>\n+\tconstexpr auto\n+\toperator()(_Tp&& __e) const\n+\tnoexcept(_S_noexcept<_Tp>())\n+\t{\n+\t  if constexpr (__member_rbegin<_Tp>)\n+\t    return __e.rbegin();\n+\t  else if constexpr (__adl_rbegin<_Tp>)\n+\t    return rbegin(std::forward<_Tp>(__e));\n+\t  else\n+\t    return std::make_reverse_iterator(_End{}(std::forward<_Tp>(__e)));\n+\t}\n+    };\n+\n+    template<typename _Tp>\n+      concept __member_rend = is_lvalue_reference_v<_Tp>\n+\t&& requires(_Tp __t)\n+\t{\n+\t  { __decay_copy(__t.rend()) }\n+\t    -> sentinel_for<decltype(_RBegin{}(__t))>;\n+\t};\n+\n+    template<typename _Tp> void rend(_Tp&&) = delete;\n+\n+    template<typename _Tp>\n+      concept __adl_rend = requires(_Tp&& __t)\n+\t{\n+\t  { __decay_copy(rend(std::forward<_Tp>(__t))) }\n+\t    -> sentinel_for<decltype(_RBegin{}(std::forward<_Tp>(__t)))>;\n+\t};\n+\n+    struct _REnd\n+    {\n+    private:\n+      template<typename _Tp>\n+\tstatic constexpr bool\n+\t_S_noexcept()\n+\t{\n+\t  if constexpr (__member_rend<_Tp>)\n+\t    return noexcept(__decay_copy(std::declval<_Tp>().rend()));\n+\t  else if constexpr (__adl_rend<_Tp>)\n+\t    return noexcept(__decay_copy(rend(std::declval<_Tp>())));\n+\t  else if constexpr (noexcept(_Begin{}(std::declval<_Tp>())))\n+\t    {\n+\t      using _It = decltype(_Begin{}(std::declval<_Tp>()));\n+\t      // std::reverse_iterator copy-initializes its member.\n+\t      return is_nothrow_copy_constructible_v<_It>;\n+\t    }\n+\t  else\n+\t    return false;\n+\t}\n+\n+    public:\n+      template<typename _Tp>\n+\trequires __member_rend<_Tp> || __adl_rend<_Tp> || __reversable<_Tp>\n+\tconstexpr auto\n+\toperator()(_Tp&& __e) const\n+\tnoexcept(_S_noexcept<_Tp>())\n+\t{\n+\t  if constexpr (__member_rend<_Tp>)\n+\t    return __e.rend();\n+\t  else if constexpr (__adl_rend<_Tp>)\n+\t    return rend(std::forward<_Tp>(__e));\n+\t  else\n+\t    return std::make_reverse_iterator(_Begin{}(std::forward<_Tp>(__e)));\n+\t}\n+    };\n+\n+    struct _CRBegin\n+    {\n+      template<typename _Tp>\n+\tconstexpr auto\n+\toperator()(_Tp&& __e) const\n+\tnoexcept(noexcept(_RBegin{}(__cust_access::__as_const((_Tp&&)__e))))\n+\trequires requires { _RBegin{}(__cust_access::__as_const((_Tp&&)__e)); }\n+\t{\n+\t  return _RBegin{}(__cust_access::__as_const(std::forward<_Tp>(__e)));\n+\t}\n+    };\n+\n+    struct _CREnd\n+    {\n+      template<typename _Tp>\n+\tconstexpr auto\n+\toperator()(_Tp&& __e) const\n+\tnoexcept(noexcept(_REnd{}(__cust_access::__as_const((_Tp&&)__e))))\n+\trequires requires { _REnd{}(__cust_access::__as_const((_Tp&&)__e)); }\n+\t{\n+\t  return _REnd{}(__cust_access::__as_const(std::forward<_Tp>(__e)));\n+\t}\n+    };\n+\n+    template<typename _Tp>\n+      concept __member_size = !disable_sized_range<remove_cvref_t<_Tp>>\n+\t&& requires(_Tp&& __t)\n+\t{\n+\t  { __decay_copy(std::forward<_Tp>(__t).size()) }\n+\t    -> __detail::__is_integer_like;\n+\t};\n+\n+    template<typename _Tp> void size(_Tp&&) = delete;\n+\n+    template<typename _Tp>\n+      concept __adl_size = !disable_sized_range<remove_cvref_t<_Tp>>\n+\t&& requires(_Tp&& __t)\n+\t{\n+\t  { __decay_copy(size(std::forward<_Tp>(__t))) }\n+\t    -> __detail::__is_integer_like;\n+\t};\n+\n+    // FIXME: needed due to PR c++/92268\n+    template<forward_iterator _It, sized_sentinel_for<_It> _End>\n+      requires requires (_It __it, _End __end)\n+      { { __end - __it } -> __detail::__is_integer_like; }\n+      void\n+      __subtractable_fwd_iter(_It, _End)\n+      { }\n+\n+    template<typename _Tp>\n+      concept __sizable = requires(_Tp&& __t)\n+\t{\n+\t  __subtractable_fwd_iter(_Begin{}(std::forward<_Tp>(__t)),\n+\t\t\t\t  _End{}(std::forward<_Tp>(__t)));\n+\t};\n+\n+    struct _Size\n+    {\n+    private:\n+      template<typename _Tp>\n+\tstatic constexpr bool\n+\t_S_noexcept()\n+\t{\n+\t  if constexpr (__member_size<_Tp>)\n+\t    return noexcept(__decay_copy(std::declval<_Tp>().size()));\n+\t  else if constexpr (__adl_size<_Tp>)\n+\t    return noexcept(__decay_copy(size(std::declval<_Tp>())));\n+\t  else if constexpr (__sizable<_Tp>)\n+\t    return noexcept(_End{}(std::declval<_Tp>())\n+\t\t\t    - _Begin{}(std::declval<_Tp>()));\n+\t}\n+\n+    public:\n+      template<__complete_type _Tp, size_t _Nm>\n+\tconstexpr size_t\n+\toperator()(_Tp (&__e)[_Nm]) const noexcept\n+\t{ return _Nm; }\n+\n+      template<typename _Tp>\n+\trequires __member_size<_Tp> || __adl_size<_Tp> || __sizable<_Tp>\n+\tconstexpr auto\n+\toperator()(_Tp&& __e) const noexcept(_S_noexcept<_Tp>())\n+\t{\n+\t  if constexpr (__member_size<_Tp>)\n+\t    return std::forward<_Tp>(__e).size();\n+\t  else if constexpr (__adl_size<_Tp>)\n+\t    return size(std::forward<_Tp>(__e));\n+\t  else if constexpr (__sizable<_Tp>)\n+\t    return __detail::__to_unsigned_like(\n+\t\t_End{}(std::forward<_Tp>(__e))\n+\t\t- _Begin{}(std::forward<_Tp>(__e)));\n+\t}\n+    };\n+\n+    template<typename _Tp>\n+      concept __member_empty = requires(_Tp&& __t)\n+\t{ bool(std::forward<_Tp>(__t).empty()); };\n+\n+    template<typename _Tp>\n+      concept __size0_empty = requires(_Tp&& __t)\n+\t{ _Size{}(std::forward<_Tp>(__t)) == 0; };\n+\n+    template<typename _Tp>\n+      concept __eq_iter_empty = requires(_Tp&& __t)\n+\t{\n+\t  { _Begin{}(std::forward<_Tp>(__t)) } -> forward_iterator;\n+\t  bool(_Begin{}(std::forward<_Tp>(__t))\n+\t      == _End{}(std::forward<_Tp>(__t)));\n+\t};\n+\n+    struct _Empty\n+    {\n+    private:\n+      template<typename _Tp>\n+\tstatic constexpr bool\n+\t_S_noexcept()\n+\t{\n+\t  if constexpr (__member_empty<_Tp>)\n+\t    return noexcept(std::declval<_Tp>().empty());\n+\t  else if constexpr (__size0_empty<_Tp>)\n+\t    return noexcept(_Size{}(std::declval<_Tp>()) == 0);\n+\t  else\n+\t    return noexcept(bool(_Begin{}(std::declval<_Tp>())\n+\t\t== _End{}(std::declval<_Tp>())));\n+\t}\n+\n+    public:\n+      template<typename _Tp>\n+\trequires __member_empty<_Tp> || __size0_empty<_Tp>\n+\t|| __eq_iter_empty<_Tp>\n+\tconstexpr auto\n+\toperator()(_Tp&& __e) const noexcept(_S_noexcept<_Tp>())\n+\t{\n+\t  if constexpr (__member_empty<_Tp>)\n+\t    return bool(std::forward<_Tp>(__e).empty());\n+\t  else if constexpr (__size0_empty<_Tp>)\n+\t    return _Size{}(std::forward<_Tp>(__e)) == 0;\n+\t  else\n+\t    return bool(_Begin{}(std::forward<_Tp>(__e))\n+\t\t== _End{}(std::forward<_Tp>(__e)));\n+\t}\n+    };\n+\n+    template<typename _Tp>\n+      concept __pointer_to_object = is_pointer_v<_Tp>\n+\t\t\t\t    && is_object_v<remove_pointer_t<_Tp>>;\n+\n+    template<typename _Tp>\n+      concept __member_data = is_lvalue_reference_v<_Tp>\n+\t&& requires(_Tp __t) { { __t.data() } -> __pointer_to_object; };\n+\n+    template<typename _Tp>\n+      concept __begin_data = requires(_Tp&& __t)\n+\t{ { _Begin{}(std::forward<_Tp>(__t)) } -> contiguous_iterator; };\n+\n+    struct _Data\n+    {\n+    private:\n+      template<typename _Tp>\n+\tstatic constexpr bool\n+\t_S_noexcept()\n+\t{\n+\t  if constexpr (__member_data<_Tp>)\n+\t    return noexcept(__decay_copy(std::declval<_Tp>().data()));\n+\t  else\n+\t    return noexcept(_Begin{}(std::declval<_Tp>()));\n+\t}\n+\n+    public:\n+      template<typename _Tp> requires __member_data<_Tp> || __begin_data<_Tp>\n+\tconstexpr auto\n+\toperator()(_Tp&& __e) const noexcept(_S_noexcept<_Tp>())\n+\t{\n+\t  if constexpr (__member_data<_Tp>)\n+\t    return __e.data();\n+\t  else\n+\t    return std::to_address(_Begin{}(std::forward<_Tp>(__e)));\n+\t}\n+    };\n+\n+    struct _CData\n+    {\n+      template<typename _Tp>\n+\tconstexpr auto\n+\toperator()(_Tp&& __e) const\n+\tnoexcept(noexcept(_Data{}(__cust_access::__as_const((_Tp&&)__e))))\n+\trequires requires { _Data{}(__cust_access::__as_const((_Tp&&)__e)); }\n+\t{\n+\t  return _Data{}(__cust_access::__as_const(std::forward<_Tp>(__e)));\n+\t}\n+    };\n+\n+  } // namespace __cust_access\n+\n+  inline namespace __cust\n+  {\n+    inline constexpr __cust_access::_Begin begin{};\n+    inline constexpr __cust_access::_End end{};\n+    inline constexpr __cust_access::_CBegin cbegin{};\n+    inline constexpr __cust_access::_CEnd cend{};\n+    inline constexpr __cust_access::_RBegin rbegin{};\n+    inline constexpr __cust_access::_REnd rend{};\n+    inline constexpr __cust_access::_CRBegin crbegin{};\n+    inline constexpr __cust_access::_CREnd crend{};\n+    inline constexpr __cust_access::_Size size{};\n+    inline constexpr __cust_access::_Empty empty{};\n+    inline constexpr __cust_access::_Data data{};\n+    inline constexpr __cust_access::_CData cdata{};\n+  }\n+\n+  namespace __detail\n+  {\n+    template<typename _Tp>\n+      concept __range_impl = requires(_Tp&& __t) {\n+\tranges::begin(std::forward<_Tp>(__t));\n+\tranges::end(std::forward<_Tp>(__t));\n+      };\n+\n+  } // namespace __detail\n+\n+  /// [range.range] The range concept.\n+  template<typename _Tp>\n+    concept range = __detail::__range_impl<_Tp&>;\n+\n+  /// [range.sized] The sized_range concept.\n+  template<typename _Tp>\n+    concept sized_range = range<_Tp>\n+      && requires(_Tp& __t) { ranges::size(__t); };\n+\n+    // [range.iter.ops] range iterator operations\n+\n+  template<input_or_output_iterator _It>\n+    constexpr void\n+    advance(_It& __it, iter_difference_t<_It> __n)\n+    {\n+      if constexpr (random_access_iterator<_It>)\n+\t__it += __n;\n+      else if constexpr (bidirectional_iterator<_It>)\n+\t{\n+\t  if (__n > 0)\n+\t    {\n+\t      do\n+\t\t{\n+\t\t  ++__it;\n+\t\t}\n+\t      while (--__n);\n+\t    }\n+\t  else if (__n < 0)\n+\t    {\n+\t      do\n+\t\t{\n+\t\t  --__it;\n+\t\t}\n+\t      while (++__n);\n+\t    }\n+\t}\n+      else\n+\t{\n+#ifdef __cpp_lib_is_constant_evaluated\n+\t  if (std::is_constant_evaluated() && __n < 0)\n+\t    throw \"attempt to decrement a non-bidirectional iterator\";\n+#endif\n+\t  __glibcxx_assert(__n >= 0);\n+\t  while (__n-- > 0)\n+\t    ++__it;\n+\t}\n+    }\n+\n+  template<input_or_output_iterator _It, sentinel_for<_It> _Sent>\n+    constexpr void\n+    advance(_It& __it, _Sent __bound)\n+    {\n+      if constexpr (assignable_from<_It&, _Sent>)\n+\t__it = std::move(__bound);\n+      else if constexpr (sized_sentinel_for<_Sent, _It>)\n+\tranges::advance(__it, __bound - __it);\n+      else\n+\t{\n+\t  while (__it != __bound)\n+\t    ++__it;\n+\t}\n+    }\n+\n+  template<input_or_output_iterator _It, sentinel_for<_It> _Sent>\n+    constexpr iter_difference_t<_It>\n+    advance(_It& __it, iter_difference_t<_It> __n, _Sent __bound)\n+    {\n+      if constexpr (sized_sentinel_for<_Sent, _It>)\n+\t{\n+\t  const auto __diff = __bound - __it;\n+#ifdef __cpp_lib_is_constant_evaluated\n+\t  if (std::is_constant_evaluated()\n+\t      && !(__n == 0 || __diff == 0 || (__n < 0 == __diff < 0)))\n+\t    throw \"inconsistent directions for distance and bound\";\n+#endif\n+\t  // n and bound must not lead in opposite directions:\n+\t  __glibcxx_assert(__n == 0 || __diff == 0 || (__n < 0 == __diff < 0));\n+\t  const auto __absdiff = __diff < 0 ? -__diff : __diff;\n+\t  const auto __absn = __n < 0 ? -__n : __n;;\n+\t  if (__absn >= __absdiff)\n+\t    {\n+\t      ranges::advance(__it, __bound);\n+\t      return __n - __diff;\n+\t    }\n+\t  else\n+\t    {\n+\t      ranges::advance(__it, __n);\n+\t      return 0;\n+\t    }\n+\t}\n+      else if (__it == __bound || __n == 0)\n+\treturn iter_difference_t<_It>(0);\n+      else if (__n > 0)\n+\t{\n+\t  iter_difference_t<_It> __m = 0;\n+\t  do\n+\t    {\n+\t      ++__it;\n+\t      ++__m;\n+\t    }\n+\t  while (__m != __n && __it != __bound);\n+\t  return __n - __m;\n+\t}\n+      else if constexpr (bidirectional_iterator<_It> && same_as<_It, _Sent>)\n+\t{\n+\t  iter_difference_t<_It> __m = 0;\n+\t  do\n+\t    {\n+\t      --__it;\n+\t      --__m;\n+\t    }\n+\t  while (__m != __n && __it != __bound);\n+\t  return __n - __m;\n+\t}\n+      else\n+\t{\n+#ifdef __cpp_lib_is_constant_evaluated\n+\t  if (std::is_constant_evaluated() && __n < 0)\n+\t    throw \"attempt to decrement a non-bidirectional iterator\";\n+#endif\n+\t  __glibcxx_assert(__n >= 0);\n+\t  return __n;\n+\t}\n+    }\n+\n+  template<input_or_output_iterator _It, sentinel_for<_It> _Sent>\n+    constexpr iter_difference_t<_It>\n+    distance(_It __first, _Sent __last)\n+    {\n+      if constexpr (sized_sentinel_for<_Sent, _It>)\n+\treturn __last - __first;\n+      else\n+\t{\n+\t  iter_difference_t<_It> __n = 0;\n+\t  while (__first != __last)\n+\t    {\n+\t      ++__first;\n+\t      ++__n;\n+\t    }\n+\t  return __n;\n+\t}\n+    }\n+\n+  template<range _Range>\n+    using iterator_t = decltype(ranges::begin(std::declval<_Range&>()));\n+\n+  template<range _Range>\n+    using range_difference_t = iter_difference_t<iterator_t<_Range>>;\n+\n+  template<range _Range>\n+    constexpr range_difference_t<_Range>\n+    distance(_Range&& __r)\n+    {\n+      if constexpr (sized_range<_Range>)\n+\treturn static_cast<range_difference_t<_Range>>(ranges::size(__r));\n+      else\n+\treturn ranges::distance(ranges::begin(__r), ranges::end(__r));\n+    }\n+\n+  template<input_or_output_iterator _It>\n+    constexpr _It\n+    next(_It __x)\n+    {\n+      ++__x;\n+      return __x;\n+    }\n+\n+  template<input_or_output_iterator _It>\n+    constexpr _It\n+    next(_It __x, iter_difference_t<_It> __n)\n+    {\n+      ranges::advance(__x, __n);\n+      return __x;\n+    }\n+\n+  template<input_or_output_iterator _It, sentinel_for<_It> _Sent>\n+    constexpr _It\n+    next(_It __x, _Sent __bound)\n+    {\n+      ranges::advance(__x, __bound);\n+      return __x;\n+    }\n+\n+  template<input_or_output_iterator _It, sentinel_for<_It> _Sent>\n+    constexpr _It\n+    next(_It __x, iter_difference_t<_It> __n, _Sent __bound)\n+    {\n+      ranges::advance(__x, __n, __bound);\n+      return __x;\n+    }\n+\n+  template<bidirectional_iterator _It>\n+    constexpr _It\n+    prev(_It __x)\n+    {\n+      --__x;\n+      return __x;\n+    }\n+\n+  template<bidirectional_iterator _It>\n+    constexpr _It\n+    prev(_It __x, iter_difference_t<_It> __n)\n+    {\n+      ranges::advance(__x, -__n);\n+      return __x;\n+    }\n+\n+  template<bidirectional_iterator _It>\n+    constexpr _It\n+    prev(_It __x, iter_difference_t<_It> __n, _It __bound)\n+    {\n+      ranges::advance(__x, -__n, __bound);\n+      return __x;\n+    }\n+\n+} // namespace ranges\n+#endif // C++20\n _GLIBCXX_END_NAMESPACE_VERSION\n } // namespace\n "}, {"sha": "966087598f4a5c72763ce2d5712932737e8f8925", "filename": "libstdc++-v3/include/bits/stl_iterator.h", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d0dff49ca1539e14647c04cc1bb035ef4c2780b/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_iterator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d0dff49ca1539e14647c04cc1bb035ef4c2780b/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_iterator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_iterator.h?ref=6d0dff49ca1539e14647c04cc1bb035ef4c2780b", "patch": "@@ -431,7 +431,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     __make_reverse_iterator(_Iterator __i)\n     { return reverse_iterator<_Iterator>(__i); }\n \n-# if __cplusplus > 201103L\n+# if __cplusplus >= 201402L\n #  define __cpp_lib_make_reverse_iterator 201402\n \n   // _GLIBCXX_RESOLVE_LIB_DEFECTS\n@@ -441,10 +441,16 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     inline _GLIBCXX17_CONSTEXPR reverse_iterator<_Iterator>\n     make_reverse_iterator(_Iterator __i)\n     { return reverse_iterator<_Iterator>(__i); }\n-# endif\n-#endif\n \n-#if __cplusplus >= 201103L\n+#  if __cplusplus > 201703L\n+  template<typename _Iterator1, typename _Iterator2>\n+    requires (!sized_sentinel_for<_Iterator1, _Iterator2>)\n+    inline constexpr bool disable_sized_sentinel<reverse_iterator<_Iterator1>,\n+\t\t\t\t\t\t reverse_iterator<_Iterator2>>\n+\t\t\t\t\t\t   = true;\n+#  endif // C++20\n+# endif // C++14\n+\n   template<typename _Iterator>\n     _GLIBCXX20_CONSTEXPR\n     auto\n@@ -463,7 +469,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     __miter_base(reverse_iterator<_Iterator> __it)\n     -> decltype(__make_reverse_iterator(__miter_base(__it.base())))\n     { return __make_reverse_iterator(__miter_base(__it.base())); }\n-#endif\n+#endif // C++11\n \n   // 24.4.2.2.1 back_insert_iterator\n   /**"}, {"sha": "3fad5869b40de2e1fdb0e5f280111eb68e9269b2", "filename": "libstdc++-v3/include/bits/stl_iterator_base_types.h", "status": "modified", "additions": 35, "deletions": 2, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d0dff49ca1539e14647c04cc1bb035ef4c2780b/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_iterator_base_types.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d0dff49ca1539e14647c04cc1bb035ef4c2780b/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_iterator_base_types.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_iterator_base_types.h?ref=6d0dff49ca1539e14647c04cc1bb035ef4c2780b", "patch": "@@ -67,6 +67,10 @@\n # include <type_traits>  // For __void_t, is_convertible\n #endif\n \n+#if __cplusplus > 201703L && __cpp_concepts\n+# include <bits/iterator_concepts.h>\n+#endif\n+\n namespace std _GLIBCXX_VISIBILITY(default)\n {\n _GLIBCXX_BEGIN_NAMESPACE_VERSION\n@@ -101,6 +105,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   /// Random-access iterators support a superset of bidirectional\n   /// iterator operations.\n   struct random_access_iterator_tag : public bidirectional_iterator_tag { };\n+\n+#if __cplusplus > 201703L\n+  /// Contiguous iterators point to objects stored contiguously in memory.\n+  struct contiguous_iterator_tag : public random_access_iterator_tag { };\n+#endif\n   //@}\n \n   /**\n@@ -137,12 +146,17 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n    *  argument.  Specialized versions for pointers and pointers-to-const\n    *  provide tighter, more correct semantics.\n   */\n+  template<typename _Iterator>\n+    struct iterator_traits;\n+\n #if __cplusplus >= 201103L\n   // _GLIBCXX_RESOLVE_LIB_DEFECTS\n   // 2408. SFINAE-friendly common_type/iterator_traits is missing in C++14\n   template<typename _Iterator, typename = __void_t<>>\n     struct __iterator_traits { };\n \n+#if ! __cpp_lib_concepts\n+\n   template<typename _Iterator>\n     struct __iterator_traits<_Iterator,\n \t\t\t     __void_t<typename _Iterator::iterator_category,\n@@ -157,11 +171,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       typedef typename _Iterator::pointer           pointer;\n       typedef typename _Iterator::reference         reference;\n     };\n+#endif // ! concepts\n \n   template<typename _Iterator>\n     struct iterator_traits\n     : public __iterator_traits<_Iterator> { };\n-#else\n+\n+#else // ! C++11\n   template<typename _Iterator>\n     struct iterator_traits\n     {\n@@ -171,8 +187,24 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       typedef typename _Iterator::pointer           pointer;\n       typedef typename _Iterator::reference         reference;\n     };\n-#endif\n+#endif // C++11\n \n+#if __cplusplus > 201703L\n+  /// Partial specialization for object pointer types.\n+  template<typename _Tp>\n+#if __cpp_concepts\n+    requires is_object_v<_Tp>\n+#endif\n+    struct iterator_traits<_Tp*>\n+    {\n+      using iterator_concept  = contiguous_iterator_tag;\n+      using iterator_category = random_access_iterator_tag;\n+      using value_type\t      = remove_cv_t<_Tp>;\n+      using difference_type   = ptrdiff_t;\n+      using pointer\t      = _Tp*;\n+      using reference\t      = _Tp&;\n+    };\n+#else\n   /// Partial specialization for pointer types.\n   template<typename _Tp>\n     struct iterator_traits<_Tp*>\n@@ -194,6 +226,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       typedef const _Tp*                  pointer;\n       typedef const _Tp&                  reference;\n     };\n+#endif\n \n   /**\n    *  This function is not a part of the C++ standard but is syntactic"}, {"sha": "68cbba9b8a7b6bfcdc4c65681c5e38efbb0a1965", "filename": "libstdc++-v3/include/std/concepts", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d0dff49ca1539e14647c04cc1bb035ef4c2780b/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fconcepts", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d0dff49ca1539e14647c04cc1bb035ef4c2780b/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fconcepts", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fconcepts?ref=6d0dff49ca1539e14647c04cc1bb035ef4c2780b", "patch": "@@ -114,6 +114,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   {\n     template<typename _Tp>\n       using __cref = const remove_reference_t<_Tp>&;\n+\n+      template<typename _Tp>\n+\tconcept __class_or_enum\n+\t  = is_class_v<_Tp> || is_union_v<_Tp> || is_enum_v<_Tp>;\n   } // namespace __detail\n \n   /// [concept.assignable], concept assignable_from\n@@ -159,14 +163,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     {\n       template<typename _Tp> void swap(_Tp&, _Tp&) = delete;\n \n-      template<typename _Tp>\n-\tconcept __class_or_enum\n-\t  = is_class_v<_Tp> || is_union_v<_Tp> || is_enum_v<_Tp>;\n-\n       template<typename _Tp, typename _Up>\n \tconcept __adl_swap\n-\t  = (__class_or_enum<remove_cvref_t<_Tp>>\n-\t    || __class_or_enum<remove_cvref_t<_Up>>)\n+\t  = (__detail::__class_or_enum<remove_reference_t<_Tp>>\n+\t    || __detail::__class_or_enum<remove_reference_t<_Up>>)\n \t  && requires(_Tp&& __t, _Up&& __u) {\n \t    swap(static_cast<_Tp&&>(__t), static_cast<_Up&&>(__u));\n \t  };\n@@ -175,7 +175,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       {\n \ttemplate<typename _Tp, typename _Up>\n \t  requires __adl_swap<_Tp, _Up>\n-\t  constexpr void operator()(_Tp&& __t, _Up&& __u) const\n+\t  constexpr void\n+\t  operator()(_Tp&& __t, _Up&& __u) const\n \t  noexcept(noexcept(swap(std::declval<_Tp>(), std::declval<_Up>())))\n \t  { swap(static_cast<_Tp&&>(__t), static_cast<_Up&&>(__u)); }\n "}, {"sha": "6b719eb988fbf3ae8c0f72a8a6b1e546b4b5ba23", "filename": "libstdc++-v3/testsuite/20_util/forward/c_neg.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d0dff49ca1539e14647c04cc1bb035ef4c2780b/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fforward%2Fc_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d0dff49ca1539e14647c04cc1bb035ef4c2780b/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fforward%2Fc_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fforward%2Fc_neg.cc?ref=6d0dff49ca1539e14647c04cc1bb035ef4c2780b", "patch": "@@ -17,7 +17,7 @@\n // with this library; see the file COPYING3.  If not see\n // <http://www.gnu.org/licenses/>.\n \n-// { dg-error \"static assertion failed\" \"\" { target *-*-* } 87 }\n+// { dg-error \"static assertion failed\" \"\" { target *-*-* } 89 }\n \n #include <list>\n "}, {"sha": "7161f47760ce73db705dc3be44405645e0be09f8", "filename": "libstdc++-v3/testsuite/20_util/forward/f_neg.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d0dff49ca1539e14647c04cc1bb035ef4c2780b/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fforward%2Ff_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d0dff49ca1539e14647c04cc1bb035ef4c2780b/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fforward%2Ff_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fforward%2Ff_neg.cc?ref=6d0dff49ca1539e14647c04cc1bb035ef4c2780b", "patch": "@@ -17,7 +17,7 @@\n // with this library; see the file COPYING3.  If not see\n // <http://www.gnu.org/licenses/>.\n \n-// { dg-error \"static assertion failed\" \"\" { target *-*-* } 87 }\n+// { dg-error \"static assertion failed\" \"\" { target *-*-* } 89 }\n \n #include <utility>\n "}, {"sha": "929f0e4121f6f4533434e0d19684e2e9df9e350d", "filename": "libstdc++-v3/testsuite/24_iterators/associated_types/incrementable.traits.cc", "status": "added", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d0dff49ca1539e14647c04cc1bb035ef4c2780b/libstdc%2B%2B-v3%2Ftestsuite%2F24_iterators%2Fassociated_types%2Fincrementable.traits.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d0dff49ca1539e14647c04cc1bb035ef4c2780b/libstdc%2B%2B-v3%2Ftestsuite%2F24_iterators%2Fassociated_types%2Fincrementable.traits.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F24_iterators%2Fassociated_types%2Fincrementable.traits.cc?ref=6d0dff49ca1539e14647c04cc1bb035ef4c2780b", "patch": "@@ -0,0 +1,142 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+#include <iterator>\n+\n+struct none;\n+\n+template<typename T>\n+  concept has_inc_traits_type\n+    = requires { typename std::incrementable_traits<T>::difference_type; };\n+\n+// Check std::incrementable_traits<T>::difference_type is U (or doesn't exist).\n+template<typename T, typename U>\n+  concept check_inc_traits = (has_inc_traits_type<T> != std::same_as<U, none>);\n+\n+static_assert( check_inc_traits<void, none> );\n+static_assert( check_inc_traits<const void, none> );\n+static_assert( check_inc_traits<void*, none> );\n+static_assert( check_inc_traits<const void*, none> );\n+\n+static_assert( check_inc_traits<int, int> );\n+static_assert( check_inc_traits<const int, int> );\n+\n+static_assert( check_inc_traits<int*, std::ptrdiff_t> );\n+static_assert( check_inc_traits<const int*, std::ptrdiff_t> );\n+static_assert( check_inc_traits<int[2], std::ptrdiff_t> );\n+static_assert( check_inc_traits<const int[2], std::ptrdiff_t> );\n+\n+struct A { using difference_type = int; };\n+static_assert( check_inc_traits<A, int> );\n+static_assert( check_inc_traits<const A, int> );\n+struct B : private A { };\n+static_assert( check_inc_traits<B, none> );\n+\n+struct C { };\n+short operator-(C, C) { return 0; }\n+static_assert( check_inc_traits<C, short> );\n+static_assert( check_inc_traits<const C, short> );\n+\n+struct D { };\n+unsigned short operator-(D, D) { return 0; }\n+static_assert( check_inc_traits<D, short> );\n+static_assert( check_inc_traits<const D, short> );\n+\n+struct E { };\n+template<>\n+  struct std::incrementable_traits<E> { using difference_type = long; };\n+static_assert( check_inc_traits<E, long> );\n+static_assert( check_inc_traits<const E, long> );\n+\n+template<typename T>\n+  concept has_alias = requires { typename std::iter_difference_t<T>; };\n+\n+// Check std::iter_difference_t<T> is U (or doesn't exist).\n+template<typename T, typename U>\n+  concept check_alias = (has_alias<T> != std::same_as<U, none>);\n+\n+static_assert( check_alias<void, none> );\n+static_assert( check_alias<const void, none> );\n+static_assert( check_alias<void*, none> );\n+static_assert( check_alias<const void*, none> );\n+\n+static_assert( check_alias<int, int> );\n+static_assert( check_alias<const int, int> );\n+static_assert( check_alias<int*, std::ptrdiff_t> );\n+static_assert( check_alias<const int*, std::ptrdiff_t> );\n+static_assert( check_alias<int[2], std::ptrdiff_t> );\n+static_assert( check_alias<const int[2], std::ptrdiff_t> );\n+\n+static_assert( check_alias<A, int> );\n+static_assert( check_alias<const A, int> );\n+static_assert( check_alias<B, none> );\n+static_assert( check_alias<C, short> );\n+static_assert( check_alias<const C, short> );\n+static_assert( check_alias<D, short> );\n+static_assert( check_alias<const D, short> );\n+static_assert( check_alias<E, long> );\n+static_assert( check_alias<const E, long> );\n+\n+struct F { };\n+template<>\n+  struct std::iterator_traits<F> { using difference_type = F; };\n+// iterator_traits<F> is specialized, so use its difference_type.\n+static_assert( check_alias<F, std::iterator_traits<F>::difference_type> );\n+\n+struct G { };\n+template<>\n+  struct std::incrementable_traits<G> { using difference_type = G; };\n+template<>\n+  struct std::iterator_traits<G> { using difference_type = int; };\n+// iterator_traits<G> is specialized, so use its difference_type.\n+static_assert( check_alias<G, std::iterator_traits<G>::difference_type> );\n+\n+struct H { };\n+template<>\n+  struct std::incrementable_traits<H> { using difference_type = H; };\n+template<>\n+  struct std::iterator_traits<H>\n+  {\n+    using iterator_category = input_iterator_tag;\n+    using difference_type = int;\n+    using value_type = char;\n+    using reference = value_type&;\n+  };\n+// iterator_traits<H> is specialized, so use its difference_type.\n+static_assert( check_alias<H, std::iterator_traits<H>::difference_type> );\n+\n+struct I\n+{\n+  using difference_type = I;\n+};\n+// iterator_traits<I> is not specialized, and no standard specialization\n+// matches, so use incrementable_traits.\n+static_assert( check_alias<I, std::incrementable_traits<I>::difference_type> );\n+\n+struct J\n+{\n+  using iterator_category = std::input_iterator_tag;\n+  using difference_type = int;\n+  using value_type = char;\n+  using reference = value_type&;\n+};\n+// iterator_traits<J> matches constrained specialization in the library,\n+// so use its difference_type.\n+static_assert( check_alias<J, int> );"}, {"sha": "b4678abc1bca62c46d8222e3a93643c708cbc2ba", "filename": "libstdc++-v3/testsuite/24_iterators/associated_types/readable.traits.cc", "status": "added", "additions": 143, "deletions": 0, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d0dff49ca1539e14647c04cc1bb035ef4c2780b/libstdc%2B%2B-v3%2Ftestsuite%2F24_iterators%2Fassociated_types%2Freadable.traits.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d0dff49ca1539e14647c04cc1bb035ef4c2780b/libstdc%2B%2B-v3%2Ftestsuite%2F24_iterators%2Fassociated_types%2Freadable.traits.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F24_iterators%2Fassociated_types%2Freadable.traits.cc?ref=6d0dff49ca1539e14647c04cc1bb035ef4c2780b", "patch": "@@ -0,0 +1,143 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+#include <iterator>\n+\n+struct none;\n+\n+template<typename T>\n+  concept has_readable_traits_type\n+    = requires { typename std::readable_traits<T>::value_type; };\n+\n+// Check std::readable_traits<T>::value_type is U (or doesn't exist).\n+template<typename T, typename U>\n+  concept check_readable_traits\n+    = (has_readable_traits_type<T> != std::same_as<U, none>);\n+\n+static_assert( check_readable_traits<void, none> );\n+static_assert( check_readable_traits<const void, none> );\n+static_assert( check_readable_traits<void*, none> );\n+static_assert( check_readable_traits<const void*, none> );\n+\n+static_assert( check_readable_traits<int, none> );\n+static_assert( check_readable_traits<const int, none> );\n+\n+static_assert( check_readable_traits<int*, int> );\n+static_assert( check_readable_traits<const int*, int> );\n+static_assert( check_readable_traits<int[2], int> );\n+static_assert( check_readable_traits<const int[2], int> );\n+\n+struct A { using value_type = int; };\n+static_assert( check_readable_traits<A, int> );\n+static_assert( check_readable_traits<const A, int> );\n+struct B : private A { };\n+static_assert( check_readable_traits<B, none> );\n+\n+struct C { };\n+short operator-(C, C) { return 0; }\n+static_assert( check_readable_traits<C, none> );\n+static_assert( check_readable_traits<const C, none> );\n+\n+struct D { long operator*() const { return 1L; } };\n+unsigned short operator-(D, D) { return 0; }\n+static_assert( check_readable_traits<D, none> );\n+static_assert( check_readable_traits<const D, none> );\n+\n+struct E { };\n+template<>\n+  struct std::readable_traits<E> { using value_type = long; };\n+static_assert( check_readable_traits<E, long> );\n+static_assert( check_readable_traits<const E, long> );\n+\n+template<typename T>\n+  concept has_alias = requires { typename std::iter_value_t<T>; };\n+\n+// Check std::iter_value_t<T> is U (or doesn't exist).\n+template<typename T, typename U>\n+  concept check_alias = (has_alias<T> != std::same_as<U, none>);\n+\n+static_assert( check_alias<void, none> );\n+static_assert( check_alias<const void, none> );\n+static_assert( check_alias<void*, none> );\n+static_assert( check_alias<const void*, none> );\n+\n+static_assert( check_alias<int, none> );\n+static_assert( check_alias<const int, none> );\n+static_assert( check_alias<int*, std::ptrdiff_t> );\n+static_assert( check_alias<const int*, std::ptrdiff_t> );\n+static_assert( check_alias<int[2], std::ptrdiff_t> );\n+static_assert( check_alias<const int[2], std::ptrdiff_t> );\n+\n+static_assert( check_alias<A, int> );\n+static_assert( check_alias<const A, int> );\n+static_assert( check_alias<B, none> );\n+static_assert( check_alias<C, none> );\n+static_assert( check_alias<const C, none> );\n+static_assert( check_alias<D, none> );\n+static_assert( check_alias<const D, none> );\n+static_assert( check_alias<E, long> );\n+static_assert( check_alias<const E, long> );\n+\n+struct F { };\n+template<>\n+  struct std::iterator_traits<F> { using value_type = F; };\n+// iterator_traits<F> is specialized, so use its value_type.\n+static_assert( check_alias<F, std::iterator_traits<F>::value_type> );\n+\n+struct G { };\n+template<>\n+  struct std::readable_traits<G> { using value_type = G; };\n+template<>\n+  struct std::iterator_traits<G> { using value_type = int; };\n+// iterator_traits<G> is specialized, so use its value_type.\n+static_assert( check_alias<G, std::iterator_traits<G>::value_type> );\n+\n+struct H { };\n+template<>\n+  struct std::readable_traits<H> { using value_type = H; };\n+template<>\n+  struct std::iterator_traits<H>\n+  {\n+    using iterator_category = input_iterator_tag;\n+    using difference_type = int;\n+    using value_type = char;\n+    using reference = value_type&;\n+  };\n+// iterator_traits<H> is specialized, so use its value_type.\n+static_assert( check_alias<H, std::iterator_traits<H>::value_type> );\n+\n+struct I\n+{\n+  using value_type = I;\n+};\n+// iterator_traits<I> is not specialized, and no standard specialization\n+// matches, so use readable_traits.\n+static_assert( check_alias<I, std::readable_traits<I>::value_type> );\n+\n+struct J\n+{\n+  using iterator_category = std::input_iterator_tag;\n+  using difference_type = int;\n+  using value_type = char;\n+  using reference = value_type&;\n+};\n+// iterator_traits<J> matches constrained specialization in the library,\n+// so use its value_type.\n+static_assert( check_alias<J, int> );"}, {"sha": "a9bb42e023f4c02cebefe64f09df39892f43ab00", "filename": "libstdc++-v3/testsuite/24_iterators/contiguous/concept.cc", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d0dff49ca1539e14647c04cc1bb035ef4c2780b/libstdc%2B%2B-v3%2Ftestsuite%2F24_iterators%2Fcontiguous%2Fconcept.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d0dff49ca1539e14647c04cc1bb035ef4c2780b/libstdc%2B%2B-v3%2Ftestsuite%2F24_iterators%2Fcontiguous%2Fconcept.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F24_iterators%2Fcontiguous%2Fconcept.cc?ref=6d0dff49ca1539e14647c04cc1bb035ef4c2780b", "patch": "@@ -0,0 +1,36 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+#include <iterator>\n+\n+static_assert( std::contiguous_iterator<int*> );\n+static_assert( std::contiguous_iterator<const int*> );\n+static_assert( std::contiguous_iterator<void**> );\n+\n+static_assert( ! std::contiguous_iterator<void*> );\n+static_assert( ! std::contiguous_iterator<const void*> );\n+static_assert( ! std::contiguous_iterator<volatile void*> );\n+\n+static_assert( ! std::contiguous_iterator<void(*)()> );\n+static_assert( ! std::contiguous_iterator<void(*)()> );\n+\n+struct A;\n+static_assert( ! std::contiguous_iterator<void(A::*)()> );\n+static_assert( ! std::contiguous_iterator<int A::*> );"}, {"sha": "7673131f215f777816b1e59b247cb14747c8120d", "filename": "libstdc++-v3/testsuite/24_iterators/contiguous/tag.cc", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d0dff49ca1539e14647c04cc1bb035ef4c2780b/libstdc%2B%2B-v3%2Ftestsuite%2F24_iterators%2Fcontiguous%2Ftag.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d0dff49ca1539e14647c04cc1bb035ef4c2780b/libstdc%2B%2B-v3%2Ftestsuite%2F24_iterators%2Fcontiguous%2Ftag.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F24_iterators%2Fcontiguous%2Ftag.cc?ref=6d0dff49ca1539e14647c04cc1bb035ef4c2780b", "patch": "@@ -0,0 +1,34 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+#include <iterator>\n+\n+static_assert( std::is_empty_v<std::contiguous_iterator_tag> );\n+static_assert( std::is_trivially_copy_constructible_v<std::contiguous_iterator_tag> );\n+\n+static_assert( std::is_base_of_v<std::random_access_iterator_tag,\n+\t\t\t\t std::contiguous_iterator_tag> );\n+static_assert( std::is_convertible_v<std::contiguous_iterator_tag*,\n+\t\t\t\t     std::random_access_iterator_tag*> );\n+\n+static_assert( ! std::is_same_v<std::iterator_traits<int*>::iterator_category,\n+\t\t\t\tstd::contiguous_iterator_tag> );\n+static_assert( std::is_same_v<std::iterator_traits<int*>::iterator_concept,\n+\t\t\t      std::contiguous_iterator_tag> );"}, {"sha": "d32dee39f3ac5b0b0d7c156db1f890171d3b1913", "filename": "libstdc++-v3/testsuite/24_iterators/customization_points/iter_move.cc", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d0dff49ca1539e14647c04cc1bb035ef4c2780b/libstdc%2B%2B-v3%2Ftestsuite%2F24_iterators%2Fcustomization_points%2Fiter_move.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d0dff49ca1539e14647c04cc1bb035ef4c2780b/libstdc%2B%2B-v3%2Ftestsuite%2F24_iterators%2Fcustomization_points%2Fiter_move.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F24_iterators%2Fcustomization_points%2Fiter_move.cc?ref=6d0dff49ca1539e14647c04cc1bb035ef4c2780b", "patch": "@@ -0,0 +1,68 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <iterator>\n+#include <testsuite_hooks.h>\n+\n+struct X\n+{\n+  int value;\n+\n+  constexpr X(int i) : value(i) { }\n+\n+  X(const X&) = default;\n+  X& operator=(const X&) = default;\n+\n+  constexpr X(X&& x)\n+  : value(x.value)\n+  {\n+    x.value = -2;\n+  }\n+\n+  constexpr X& operator=(X&& x)\n+  {\n+    value = x.value;\n+    x.value = -1;\n+    return *this;\n+  }\n+};\n+\n+constexpr bool\n+test_X(int i, int j)\n+{\n+  X x1{i}, x2{j};\n+  std::ranges::iter_move(&x1); // no-op\n+  x1 = std::ranges::iter_move(&x2);\n+  return x1.value == j &&  x2.value == -1;\n+}\n+\n+static_assert( test_X(1, 2) );\n+\n+void\n+test01()\n+{\n+  VERIFY( test_X(3, 4) );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}, {"sha": "4243a162fc6f8a7455a2053a8ca11d3cd7426b64", "filename": "libstdc++-v3/testsuite/24_iterators/customization_points/iter_swap.cc", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d0dff49ca1539e14647c04cc1bb035ef4c2780b/libstdc%2B%2B-v3%2Ftestsuite%2F24_iterators%2Fcustomization_points%2Fiter_swap.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d0dff49ca1539e14647c04cc1bb035ef4c2780b/libstdc%2B%2B-v3%2Ftestsuite%2F24_iterators%2Fcustomization_points%2Fiter_swap.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F24_iterators%2Fcustomization_points%2Fiter_swap.cc?ref=6d0dff49ca1539e14647c04cc1bb035ef4c2780b", "patch": "@@ -0,0 +1,61 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <iterator>\n+#include <testsuite_hooks.h>\n+\n+struct X\n+{\n+  int value;\n+\n+  constexpr X(int i) : value(i) { }\n+\n+  X(const X&) = default;\n+  X& operator=(const X&) = default;\n+\n+  constexpr X& operator=(X&& x)\n+  {\n+    value = x.value;\n+    x.value = -1;\n+    return *this;\n+  }\n+};\n+\n+constexpr bool\n+test_X(int i, int j)\n+{\n+  X x1{i}, x2{j};\n+  std::ranges::iter_swap(&x1, &x2);\n+  return x1.value == j &&  x2.value == i;\n+}\n+\n+static_assert( test_X(1, 2) );\n+\n+void\n+test01()\n+{\n+  VERIFY( test_X(3, 4) );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}, {"sha": "2dbfb767fdb4dd54bfc40bf48717099a721c95a1", "filename": "libstdc++-v3/testsuite/24_iterators/headers/iterator/synopsis_c++20.cc", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d0dff49ca1539e14647c04cc1bb035ef4c2780b/libstdc%2B%2B-v3%2Ftestsuite%2F24_iterators%2Fheaders%2Fiterator%2Fsynopsis_c%2B%2B20.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d0dff49ca1539e14647c04cc1bb035ef4c2780b/libstdc%2B%2B-v3%2Ftestsuite%2F24_iterators%2Fheaders%2Fiterator%2Fsynopsis_c%2B%2B20.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F24_iterators%2Fheaders%2Fiterator%2Fsynopsis_c%2B%2B20.cc?ref=6d0dff49ca1539e14647c04cc1bb035ef4c2780b", "patch": "@@ -0,0 +1,95 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+// { dg-require-normal-namespace \"\" }\n+\n+#include <iterator>\n+#include \"./synopsis_c++17.cc\"\n+\n+namespace std\n+{\n+  template<class> struct incrementable_traits;\n+  template<class> struct readable_traits;\n+\n+  struct contiguous_iterator_tag;\n+\n+  namespace ranges\n+  {\n+    template<input_or_output_iterator I, sentinel_for<I> S>\n+      constexpr iter_difference_t<I> distance(I first, S last);\n+    template<range R>\n+      constexpr range_difference_t<R> distance(R&& r);\n+\n+    template<input_or_output_iterator I>\n+      constexpr I next(I x);\n+    template<input_or_output_iterator I>\n+      constexpr I next(I x, iter_difference_t<I> n);\n+    template<input_or_output_iterator I, sentinel_for<I> S>\n+      constexpr I next(I x, S bound);\n+    template<input_or_output_iterator I, sentinel_for<I> S>\n+      constexpr I next(I x, iter_difference_t<I> n, S bound);\n+\n+    template<bidirectional_iterator I>\n+      constexpr I prev(I x);\n+    template<bidirectional_iterator I>\n+      constexpr I prev(I x, iter_difference_t<I> n);\n+    template<bidirectional_iterator I>\n+      constexpr I prev(I x, iter_difference_t<I> n, I bound);\n+  }\n+\n+  template<semiregular S> class move_sentinel;\n+\n+  template<input_or_output_iterator I, sentinel_for<I> S>\n+    requires (!same_as<I, S>)\n+    class common_iterator;\n+\n+  template<class I, class S>\n+    struct incrementable_traits<common_iterator<I, S>>;\n+\n+  template<input_iterator I, class S>\n+    struct iterator_traits<common_iterator<I, S>>;\n+\n+  struct default_sentinel_t;\n+\n+  template<input_or_output_iterator I> class counted_iterator;\n+\n+  template<class I>\n+    struct incrementable_traits<counted_iterator<I>>;\n+\n+  template<input_iterator I>\n+    struct iterator_traits<counted_iterator<I>>;\n+\n+  struct unreachable_sentinel_t;\n+}\n+\n+namespace __gnu_test\n+{\n+  // customization points\n+  constexpr auto* iter_move = &std::ranges::iter_move;\n+  constexpr auto* iter_swap = &std::ranges::iter_swap;\n+  // sized sentinels\n+  constexpr bool const* disable_sized_sentinel\n+    = &std::disable_sized_sentinel<void, void>;\n+  // default sentinels\n+  constexpr std::default_sentinel_t const* default_sentinel\n+    = &std::default_sentinel;\n+  // unreachable sentinels\n+  constexpr std::unreachable_sentinel_t const* unreachable_sentinel\n+    = &std::unreachable_sentinel;\n+}"}, {"sha": "7f77eca1c4bbb15bf29e6b9f0b2bddfbf0a4983f", "filename": "libstdc++-v3/testsuite/24_iterators/range_operations/advance.cc", "status": "added", "additions": 204, "deletions": 0, "changes": 204, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d0dff49ca1539e14647c04cc1bb035ef4c2780b/libstdc%2B%2B-v3%2Ftestsuite%2F24_iterators%2Frange_operations%2Fadvance.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d0dff49ca1539e14647c04cc1bb035ef4c2780b/libstdc%2B%2B-v3%2Ftestsuite%2F24_iterators%2Frange_operations%2Fadvance.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F24_iterators%2Frange_operations%2Fadvance.cc?ref=6d0dff49ca1539e14647c04cc1bb035ef4c2780b", "patch": "@@ -0,0 +1,204 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <iterator>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_range;\n+using __gnu_test::random_access_iterator_wrapper;\n+using __gnu_test::bidirectional_iterator_wrapper;\n+using __gnu_test::forward_iterator_wrapper;\n+using __gnu_test::input_iterator_wrapper;\n+using __gnu_test::output_iterator_wrapper;\n+\n+void\n+test01()\n+{\n+  int a[2] = { };\n+  test_range<int, random_access_iterator_wrapper> r(a);\n+  auto iter = r.begin();\n+  std::ranges::advance(iter, 1);\n+  VERIFY( iter != r.begin() );\n+  VERIFY( iter != r.end() );\n+  std::ranges::advance(iter, 1);\n+  VERIFY( iter == r.end() );\n+  std::ranges::advance(iter, -2);\n+  VERIFY( iter == r.begin() );\n+\n+  std::ranges::advance(iter, r.begin() + 1);\n+  VERIFY( iter != r.begin() );\n+  VERIFY( iter != r.end() );\n+  std::ranges::advance(iter, r.begin());\n+  VERIFY( iter == r.begin() );\n+\n+  std::ranges::advance(iter, 99, r.end());\n+  VERIFY( iter == r.end() );\n+  std::ranges::advance(iter, -222, r.begin());\n+  VERIFY( iter == r.begin() );\n+}\n+\n+void\n+test02()\n+{\n+  int a[2] = { };\n+  test_range<int, bidirectional_iterator_wrapper> r(a);\n+  auto iter = r.begin();\n+  std::ranges::advance(iter, 1);\n+  VERIFY( iter != r.begin() );\n+  VERIFY( iter != r.end() );\n+  std::ranges::advance(iter, 1);\n+  VERIFY( iter == r.end() );\n+  std::ranges::advance(iter, -2);\n+  VERIFY( iter == r.begin() );\n+\n+  auto iter1 = r.begin();\n+  ++iter1;\n+  std::ranges::advance(iter, iter1);\n+  VERIFY( iter != r.begin() );\n+  VERIFY( iter != r.end() );\n+  std::ranges::advance(iter, r.begin());\n+  VERIFY( iter == r.begin() );\n+\n+  std::ranges::advance(iter, 99, r.end());\n+  VERIFY( iter == r.end() );\n+  std::ranges::advance(iter, -222, r.begin());\n+  VERIFY( iter == r.begin() );\n+}\n+\n+void\n+test03()\n+{\n+  int a[2] = { };\n+  test_range<int, forward_iterator_wrapper> r(a);\n+  auto iter = r.begin();\n+  std::ranges::advance(iter, 1);\n+  VERIFY( iter != r.begin() );\n+  VERIFY( iter != r.end() );\n+  std::ranges::advance(iter, 1);\n+  std::ranges::advance(iter, 0);\n+  VERIFY( iter == r.end() );\n+  std::ranges::advance(iter, 0);\n+  VERIFY( iter == r.end() );\n+\n+  auto iter1 = r.begin();\n+  ++iter1;\n+  std::ranges::advance(iter, iter1);\n+  VERIFY( iter != r.begin() );\n+  VERIFY( iter != r.end() );\n+  std::ranges::advance(iter, r.end());\n+  VERIFY( iter == r.end() );\n+  std::ranges::advance(iter, r.end());\n+  VERIFY( iter == r.end() );\n+\n+  std::ranges::advance(iter, 99, r.end());\n+  VERIFY( iter == r.end() );\n+  std::ranges::advance(iter, 99, r.end());\n+  VERIFY( iter == r.end() );\n+  iter = r.begin();\n+  std::ranges::advance(iter, 99, r.end());\n+  VERIFY( iter == r.end() );\n+  std::ranges::advance(iter, 99, r.end());\n+  VERIFY( iter == r.end() );\n+}\n+\n+void\n+test04()\n+{\n+  int a[2] = { };\n+  test_range<int, input_iterator_wrapper> r(a);\n+  auto iter = r.begin();\n+  std::ranges::advance(iter, 1);\n+  VERIFY( iter != r.end() );\n+  std::ranges::advance(iter, 1);\n+  std::ranges::advance(iter, 0);\n+  VERIFY( iter == r.end() );\n+  std::ranges::advance(iter, 0);\n+  VERIFY( iter == r.end() );\n+\n+  test_range<int, input_iterator_wrapper> r2(a);\n+  iter = r2.begin();\n+  ++iter;\n+  const auto iter1 = iter;\n+  std::ranges::advance(iter, iter1);\n+  VERIFY( iter == iter1 );\n+  VERIFY( iter != r2.end() );\n+  std::ranges::advance(iter, r2.end());\n+  VERIFY( iter == r2.end() );\n+  std::ranges::advance(iter, r2.end());\n+  VERIFY( iter == r2.end() );\n+\n+  std::ranges::advance(iter, 99, r2.end());\n+  VERIFY( iter == r2.end() );\n+  std::ranges::advance(iter, 99, r2.end());\n+  VERIFY( iter == r2.end() );\n+\n+  test_range<int, input_iterator_wrapper> r3(a);\n+  iter = r3.begin();\n+  std::ranges::advance(iter, 99, r3.end());\n+  VERIFY( iter == r3.end() );\n+  std::ranges::advance(iter, 99, r3.end());\n+  VERIFY( iter == r3.end() );\n+}\n+\n+void\n+test05()\n+{\n+  int a[2] = { };\n+  test_range<int, output_iterator_wrapper> r(a);\n+  auto iter = r.begin();\n+  std::ranges::advance(iter, 1);\n+  VERIFY( iter != r.end() );\n+  std::ranges::advance(iter, 1);\n+  std::ranges::advance(iter, 0);\n+  VERIFY( iter == r.end() );\n+  std::ranges::advance(iter, 0);\n+  VERIFY( iter == r.end() );\n+\n+  test_range<int, output_iterator_wrapper> r2(a);\n+  iter = r2.begin();\n+  ++iter;\n+  std::ranges::advance(iter, r2.end());\n+  VERIFY( iter == r2.end() );\n+  std::ranges::advance(iter, r2.end());\n+  VERIFY( iter == r2.end() );\n+\n+  std::ranges::advance(iter, 99, r2.end());\n+  VERIFY( iter == r2.end() );\n+  std::ranges::advance(iter, 99, r2.end());\n+  VERIFY( iter == r2.end() );\n+\n+  test_range<int, output_iterator_wrapper> r3(a);\n+  iter = r3.begin();\n+  std::ranges::advance(iter, 99, r3.end());\n+  VERIFY( iter == r3.end() );\n+  std::ranges::advance(iter, 99, r3.end());\n+  VERIFY( iter == r3.end() );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  test04();\n+  test05();\n+}"}, {"sha": "4aa095ff3d7180dcb573fbfc94a1fccabb127d62", "filename": "libstdc++-v3/testsuite/24_iterators/range_operations/distance.cc", "status": "added", "additions": 146, "deletions": 0, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d0dff49ca1539e14647c04cc1bb035ef4c2780b/libstdc%2B%2B-v3%2Ftestsuite%2F24_iterators%2Frange_operations%2Fdistance.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d0dff49ca1539e14647c04cc1bb035ef4c2780b/libstdc%2B%2B-v3%2Ftestsuite%2F24_iterators%2Frange_operations%2Fdistance.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F24_iterators%2Frange_operations%2Fdistance.cc?ref=6d0dff49ca1539e14647c04cc1bb035ef4c2780b", "patch": "@@ -0,0 +1,146 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <iterator>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_range;\n+using __gnu_test::test_sized_range;\n+using __gnu_test::random_access_iterator_wrapper;\n+using __gnu_test::bidirectional_iterator_wrapper;\n+using __gnu_test::forward_iterator_wrapper;\n+using __gnu_test::input_iterator_wrapper;\n+using __gnu_test::output_iterator_wrapper;\n+\n+void\n+test01()\n+{\n+  int a[10] = { };\n+  VERIFY( std::ranges::distance(a) == 10 );\n+\n+  test_range<int, random_access_iterator_wrapper> c(a);\n+  VERIFY( std::ranges::distance(c) == 10 );\n+\n+  auto b = c.begin(), e = c.end();\n+  VERIFY( std::ranges::distance(b, e) == 10 );\n+  VERIFY( std::ranges::distance(e, b) == -10 );\n+\n+  const auto cb = b, ce = e;\n+  VERIFY( std::ranges::distance(cb, ce) == 10 );\n+  VERIFY( std::ranges::distance(ce, cb) == -10 );\n+\n+  test_sized_range<int, random_access_iterator_wrapper> c2(a);\n+  VERIFY( std::ranges::distance(c2) == 10 );\n+}\n+\n+void\n+test02()\n+{\n+  int a[2] = { };\n+  VERIFY( std::ranges::distance(a) == 2 );\n+\n+  test_range<int, bidirectional_iterator_wrapper> c(a);\n+  VERIFY( std::ranges::distance(c) == 2 );\n+\n+  auto b = c.begin(), e = c.end();\n+  VERIFY( std::ranges::distance(b, e) == 2 );\n+\n+  const auto cb = b, ce = e;\n+  VERIFY( std::ranges::distance(cb, ce) == 2 );\n+\n+  test_sized_range<int, bidirectional_iterator_wrapper> c2(a);\n+  VERIFY( std::ranges::distance(c2) == 2 );\n+}\n+\n+void\n+test03()\n+{\n+  int a[3] = { };\n+  test_range<int, forward_iterator_wrapper> c(a);\n+  VERIFY( std::ranges::distance(c) == 3 );\n+\n+  auto b = c.begin(), e = c.end();\n+  VERIFY( std::ranges::distance(b, e) == 3 );\n+\n+  const auto cb = b, ce = e;\n+  VERIFY( std::ranges::distance(cb, ce) == 3 );\n+\n+  test_sized_range<int, forward_iterator_wrapper> c2(a);\n+  VERIFY( std::ranges::distance(c2) == 3 );\n+}\n+\n+void\n+test04()\n+{\n+  int a[4] = { };\n+  test_range<int, input_iterator_wrapper> c(a);\n+  static_assert( std::ranges::range<decltype(c)> );\n+\n+  VERIFY( std::ranges::distance(c) == 4 );\n+  // first call to distance has traversed the range:\n+  VERIFY( std::ranges::distance(c) == 0 );\n+\n+  c = test_range<int, input_iterator_wrapper>(a);\n+  auto b = c.begin(), e = c.end();\n+  VERIFY( std::ranges::distance(b, e) == 4 );\n+\n+  test_range<int, input_iterator_wrapper> c2(a);\n+  const auto cb = c2.begin(), ce = c2.end();\n+  VERIFY( std::ranges::distance(cb, ce) == 4 );\n+\n+  test_sized_range<int, input_iterator_wrapper> c3(a);\n+  VERIFY( std::ranges::distance(c3) == 4 );\n+  // first call to distance just called size() without affecting the range:\n+  VERIFY( std::ranges::distance(c3) == 4 );\n+}\n+\n+void\n+test05()\n+{\n+  int a[5] = { };\n+  test_range<int, output_iterator_wrapper> c(a);\n+  VERIFY( std::ranges::distance(c) == 5 );\n+\n+  test_range<int, output_iterator_wrapper> c2(a);\n+  auto b = c2.begin();\n+  auto e = c2.end();\n+  VERIFY( std::ranges::distance(b, e) == 5 );\n+\n+  test_range<int, output_iterator_wrapper> c3(a);\n+  const auto cb = c3.begin();\n+  const auto ce = c3.end();\n+  VERIFY( std::ranges::distance(cb, ce) == 5 );\n+\n+  test_sized_range<int, output_iterator_wrapper> c4(a);\n+  VERIFY( std::ranges::distance(c4) == 5 );\n+  // first call to distance just called size() without affecting the range:\n+  VERIFY( std::ranges::distance(c4) == 5 );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  test04();\n+  test05();\n+}"}, {"sha": "7f04cb23b3cc157ef2b348bd53f980ad244519d5", "filename": "libstdc++-v3/testsuite/24_iterators/range_operations/next.cc", "status": "added", "additions": 211, "deletions": 0, "changes": 211, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d0dff49ca1539e14647c04cc1bb035ef4c2780b/libstdc%2B%2B-v3%2Ftestsuite%2F24_iterators%2Frange_operations%2Fnext.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d0dff49ca1539e14647c04cc1bb035ef4c2780b/libstdc%2B%2B-v3%2Ftestsuite%2F24_iterators%2Frange_operations%2Fnext.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F24_iterators%2Frange_operations%2Fnext.cc?ref=6d0dff49ca1539e14647c04cc1bb035ef4c2780b", "patch": "@@ -0,0 +1,211 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <iterator>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_range;\n+using __gnu_test::random_access_iterator_wrapper;\n+using __gnu_test::bidirectional_iterator_wrapper;\n+using __gnu_test::forward_iterator_wrapper;\n+using __gnu_test::input_iterator_wrapper;\n+using __gnu_test::output_iterator_wrapper;\n+\n+void\n+test01()\n+{\n+  int a[10] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };\n+  test_range<int, random_access_iterator_wrapper> r(a);\n+  auto begin = r.begin();\n+  auto end = r.end();\n+  VERIFY( *std::ranges::next(begin) == 1 );\n+  VERIFY(  std::ranges::next(begin, 0) == begin );\n+  VERIFY( *std::ranges::next(begin, 1) == 1 );\n+  VERIFY( *std::ranges::next(begin, 3) == 3 );\n+  VERIFY( *std::ranges::next(end, -4) == 6 );\n+  VERIFY(  std::ranges::next(begin, begin) == begin );\n+  VERIFY(  std::ranges::next(begin, end) == end );\n+  VERIFY(  std::ranges::next(end, end) == end );\n+  VERIFY(  std::ranges::next(end, begin) == begin );\n+  VERIFY(  std::ranges::next(begin, 0, begin) == begin );\n+  VERIFY(  std::ranges::next(begin, 5, begin) == begin );\n+  VERIFY(  std::ranges::next(begin, -5, begin) == begin );\n+  VERIFY(  std::ranges::next(begin, 0, end) == begin );\n+  VERIFY( *std::ranges::next(begin, 5, end) == 5 );\n+  VERIFY(  std::ranges::next(begin, 55, end) == end );\n+  VERIFY(  std::ranges::next(end, 0, end) == end );\n+  VERIFY(  std::ranges::next(end, -5, end) == end );\n+  VERIFY(  std::ranges::next(end, -55, end) == end );\n+  VERIFY(  std::ranges::next(end, 0, begin) == end );\n+  VERIFY( *std::ranges::next(end, -5, begin) == 5 );\n+  VERIFY(  std::ranges::next(end, -55, begin) == begin );\n+}\n+\n+void\n+test02()\n+{\n+  int a[10] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };\n+  test_range<int, bidirectional_iterator_wrapper> r(a);\n+  auto begin = r.begin();\n+  auto end = r.end();\n+  VERIFY( *std::ranges::next(begin) == 1 );\n+  VERIFY(  std::ranges::next(begin, 0) == begin );\n+  VERIFY( *std::ranges::next(begin, 1) == 1 );\n+  VERIFY( *std::ranges::next(begin, 3) == 3 );\n+  VERIFY( *std::ranges::next(end, -4) == 6 );\n+  VERIFY(  std::ranges::next(begin, begin) == begin );\n+  VERIFY(  std::ranges::next(begin, end) == end );\n+  VERIFY(  std::ranges::next(end, end) == end );\n+  VERIFY(  std::ranges::next(end, begin) == begin );\n+  VERIFY(  std::ranges::next(begin, 0, begin) == begin );\n+  VERIFY(  std::ranges::next(begin, 5, begin) == begin );\n+  VERIFY(  std::ranges::next(begin, -5, begin) == begin );\n+  VERIFY(  std::ranges::next(begin, 0, end) == begin );\n+  VERIFY( *std::ranges::next(begin, 5, end) == 5 );\n+  VERIFY(  std::ranges::next(begin, 55, end) == end );\n+  VERIFY(  std::ranges::next(end, 0, end) == end );\n+  VERIFY(  std::ranges::next(end, -5, end) == end );\n+  VERIFY(  std::ranges::next(end, -55, end) == end );\n+  VERIFY(  std::ranges::next(end, 0, begin) == end );\n+  VERIFY( *std::ranges::next(end, -5, begin) == 5 );\n+  VERIFY(  std::ranges::next(end, -55, begin) == begin );\n+}\n+\n+void\n+test03()\n+{\n+  int a[10] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };\n+  test_range<int, forward_iterator_wrapper> r(a);\n+  auto begin = r.begin();\n+  auto end = r.end();\n+  VERIFY( *std::ranges::next(begin) == 1 );\n+  VERIFY(  std::ranges::next(begin, 0) == begin );\n+  VERIFY( *std::ranges::next(begin, 1) == 1 );\n+  VERIFY( *std::ranges::next(begin, 3) == 3 );\n+  VERIFY(  std::ranges::next(begin, begin) == begin );\n+  VERIFY(  std::ranges::next(begin, end) == end );\n+  VERIFY(  std::ranges::next(end, end) == end );\n+  VERIFY(  std::ranges::next(begin, 0, begin) == begin );\n+  VERIFY(  std::ranges::next(begin, 5, begin) == begin );\n+  VERIFY(  std::ranges::next(begin, -5, begin) == begin );\n+  VERIFY(  std::ranges::next(begin, 0, end) == begin );\n+  VERIFY( *std::ranges::next(begin, 5, end) == 5 );\n+  VERIFY(  std::ranges::next(begin, 55, end) == end );\n+  VERIFY(  std::ranges::next(end, 0, end) == end );\n+  VERIFY(  std::ranges::next(end, 5, end) == end );\n+  VERIFY(  std::ranges::next(end, 55, end) == end );\n+  VERIFY(  std::ranges::next(end, 0, begin) == end );\n+}\n+\n+void\n+test04()\n+{\n+  int a[10] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };\n+  test_range<int, input_iterator_wrapper> r(a);\n+  auto begin = r.begin();\n+  auto end = r.end();\n+  auto iter = std::ranges::next(begin);\n+  VERIFY( *iter == 1 );\n+  iter = std::ranges::next(iter, 0);\n+  VERIFY( *iter == 1 );\n+  iter = std::ranges::next(iter, 1);\n+  VERIFY( *iter == 2 );\n+  iter = std::ranges::next(iter, 4);\n+  VERIFY( *iter == 6 );\n+\n+  iter = std::ranges::next(iter, iter);\n+  VERIFY( *iter == 6 );\n+  iter = std::ranges::next(iter, end);\n+  VERIFY( iter == end );\n+  iter = std::ranges::next(iter, end);\n+  VERIFY( iter == end );\n+\n+  test_range<int, input_iterator_wrapper> r2(a);\n+  begin = r2.begin();\n+  end = r2.end();\n+  iter = std::ranges::next(begin, 0, begin);\n+  VERIFY( *iter == 0 );\n+  iter = std::ranges::next(begin, 5, begin);\n+  VERIFY( *iter == 0 );\n+  iter = std::ranges::next(begin, -5, begin);\n+  VERIFY( *iter == 0 );\n+  iter = std::ranges::next(begin, 0, end);\n+  VERIFY( *iter == 0 );\n+  iter = std::ranges::next(end, 0, begin);\n+  VERIFY( iter == end );\n+  iter = std::ranges::next(begin, 5, end); // invalidates begin\n+  VERIFY( *iter == 5 );\n+  iter = std::ranges::next(iter, 55, end);\n+  VERIFY( iter == end );\n+  iter = std::ranges::next(end, 0, end);\n+  VERIFY( iter == end );\n+  iter = std::ranges::next(end, 5, end);\n+  VERIFY( iter == end );\n+}\n+\n+void\n+test05()\n+{\n+  int a[10] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };\n+  test_range<int, output_iterator_wrapper> r(a);\n+  auto iter = r.begin();\n+  auto end = r.end(); // sentinel, !same_as<decltype(iter), decltype(end)>\n+\n+  iter = std::ranges::next(iter);\n+  *iter = 10;\n+  VERIFY( a[1] == 10 );\n+  iter = std::ranges::next(iter, 0);\n+  iter = std::ranges::next(iter, 1);\n+  *iter = 20;\n+  VERIFY( a[2] == 20 );\n+  iter = std::ranges::next(iter, 4);\n+  iter = std::ranges::next(iter, 0);\n+  *iter = 60;\n+  VERIFY( a[6] == 60 );\n+\n+  iter = std::ranges::next(iter, end);\n+  VERIFY( iter == end );\n+  iter = std::ranges::next(iter, end);\n+  VERIFY( iter == end );\n+\n+  test_range<int, output_iterator_wrapper> r2(a);\n+  iter = std::ranges::next(r2.begin(), 5);\n+  end = r2.end();\n+\n+  iter = std::ranges::next(iter, 0, end);\n+  *iter = 50;\n+  VERIFY( a[5] == 50 );\n+  iter = std::ranges::next(iter, 2, end);\n+  *iter = 70;\n+  VERIFY( a[7] == 70 );\n+  iter = std::ranges::next(iter, 5, end);\n+  VERIFY( iter == end );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  test04();\n+  test05();\n+}"}, {"sha": "944c02a6052e55eded18303f5d5d8e459f7f914c", "filename": "libstdc++-v3/testsuite/24_iterators/range_operations/prev.cc", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d0dff49ca1539e14647c04cc1bb035ef4c2780b/libstdc%2B%2B-v3%2Ftestsuite%2F24_iterators%2Frange_operations%2Fprev.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d0dff49ca1539e14647c04cc1bb035ef4c2780b/libstdc%2B%2B-v3%2Ftestsuite%2F24_iterators%2Frange_operations%2Fprev.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F24_iterators%2Frange_operations%2Fprev.cc?ref=6d0dff49ca1539e14647c04cc1bb035ef4c2780b", "patch": "@@ -0,0 +1,98 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <iterator>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_range;\n+using __gnu_test::random_access_iterator_wrapper;\n+using __gnu_test::bidirectional_iterator_wrapper;\n+using __gnu_test::forward_iterator_wrapper;\n+using __gnu_test::input_iterator_wrapper;\n+using __gnu_test::output_iterator_wrapper;\n+\n+void\n+test01()\n+{\n+  int a[10] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };\n+  test_range<int, random_access_iterator_wrapper> r(a);\n+  auto begin = r.begin();\n+  auto end = r.end();\n+  VERIFY( *std::ranges::prev(end) == 9 );\n+  VERIFY(  std::ranges::prev(begin, 0) == begin );\n+  VERIFY( *std::ranges::prev(end, 1) == 9 );\n+  VERIFY( *std::ranges::prev(end, 3) == 7 );\n+  VERIFY( *std::ranges::prev(begin, -4) == 4 );\n+  VERIFY(  std::ranges::prev(begin, 0, begin) == begin );\n+  VERIFY(  std::ranges::prev(begin, 5, begin) == begin );\n+  VERIFY(  std::ranges::prev(begin, -5, begin) == begin );\n+  VERIFY(  std::ranges::prev(begin, 0, end) == begin );\n+  VERIFY( *std::ranges::prev(end, 5, begin) == 5 );\n+  VERIFY(  std::ranges::prev(end, 55, begin) == begin );\n+  VERIFY(  std::ranges::prev(end, 0, end) == end );\n+  VERIFY(  std::ranges::prev(end, -5, end) == end );\n+  VERIFY(  std::ranges::prev(end, -55, end) == end );\n+  VERIFY(  std::ranges::prev(end, 0, begin) == end );\n+  VERIFY( *std::ranges::prev(begin, -5, end) == 5 );\n+  VERIFY(  std::ranges::prev(begin, -55, end) == end );\n+}\n+\n+void\n+test02()\n+{\n+  int a[10] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };\n+  test_range<int, bidirectional_iterator_wrapper> r(a);\n+  auto begin = r.begin();\n+  auto end = r.end();\n+  VERIFY( *std::ranges::prev(end) == 9 );\n+  VERIFY(  std::ranges::prev(begin, 0) == begin );\n+  VERIFY( *std::ranges::prev(end, 1) == 9 );\n+  VERIFY( *std::ranges::prev(end, 3) == 7 );\n+  VERIFY( *std::ranges::prev(begin, -4) == 4 );\n+  VERIFY(  std::ranges::prev(begin, 0, begin) == begin );\n+  VERIFY(  std::ranges::prev(begin, 5, begin) == begin );\n+  VERIFY(  std::ranges::prev(begin, -5, begin) == begin );\n+  VERIFY(  std::ranges::prev(begin, 0, end) == begin );\n+  VERIFY( *std::ranges::prev(end, 5, begin) == 5 );\n+  VERIFY(  std::ranges::prev(end, 55, begin) == begin );\n+  VERIFY(  std::ranges::prev(end, 0, end) == end );\n+  VERIFY(  std::ranges::prev(end, -5, end) == end );\n+  VERIFY(  std::ranges::prev(end, -55, end) == end );\n+  VERIFY(  std::ranges::prev(end, 0, begin) == end );\n+  VERIFY( *std::ranges::prev(begin, -5, end) == 5 );\n+  VERIFY(  std::ranges::prev(begin, -55, end) == end );\n+}\n+\n+template<typename T>\n+  concept can_prev = requires(T& t) { std::ranges::prev(t); }\n+    || requires(T& t) { std::ranges::prev(t, 1); }\n+    || requires(T& t) { std::ranges::prev(t, 1, t); };\n+\n+static_assert( !can_prev<forward_iterator_wrapper<int>> );\n+static_assert( !can_prev<input_iterator_wrapper<int>> );\n+static_assert( !can_prev<output_iterator_wrapper<int>> );\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "1d44c316086e09aa6a1b9822bea3f9b35e314ac2", "filename": "libstdc++-v3/testsuite/26_numerics/adjacent_difference/requirements/explicit_instantiation/2.cc", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d0dff49ca1539e14647c04cc1bb035ef4c2780b/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fadjacent_difference%2Frequirements%2Fexplicit_instantiation%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d0dff49ca1539e14647c04cc1bb035ef4c2780b/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fadjacent_difference%2Frequirements%2Fexplicit_instantiation%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fadjacent_difference%2Frequirements%2Fexplicit_instantiation%2F2.cc?ref=6d0dff49ca1539e14647c04cc1bb035ef4c2780b", "patch": "@@ -28,9 +28,10 @@ namespace std\n   using __gnu_test::NonDefaultConstructible;\n \n   typedef NonDefaultConstructible \t\tvalue_type;\n-  typedef value_type* \t\tinput_iterator;\n-  typedef value_type* \t\toutput_iterator;\n+  typedef value_type* \t\tinput_iterator_type;\n+  typedef value_type* \t\toutput_iterator_type;\n \n-  template \n-  output_iterator adjacent_difference(input_iterator, input_iterator, output_iterator);\n+  template output_iterator_type\n+  adjacent_difference(input_iterator_type, input_iterator_type,\n+\t\t      output_iterator_type);\n } "}, {"sha": "f7c82ece9083b85ba68eccb270d85d161c6be8a3", "filename": "libstdc++-v3/testsuite/26_numerics/adjacent_difference/requirements/explicit_instantiation/pod.cc", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d0dff49ca1539e14647c04cc1bb035ef4c2780b/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fadjacent_difference%2Frequirements%2Fexplicit_instantiation%2Fpod.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d0dff49ca1539e14647c04cc1bb035ef4c2780b/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fadjacent_difference%2Frequirements%2Fexplicit_instantiation%2Fpod.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fadjacent_difference%2Frequirements%2Fexplicit_instantiation%2Fpod.cc?ref=6d0dff49ca1539e14647c04cc1bb035ef4c2780b", "patch": "@@ -28,9 +28,10 @@ namespace std\n   using __gnu_test::pod_int;\n \n   typedef pod_int \t\tvalue_type;\n-  typedef value_type* \t\tinput_iterator;\n-  typedef value_type* \t\toutput_iterator;\n+  typedef value_type* \t\tinput_iterator_type;\n+  typedef value_type* \t\toutput_iterator_type;\n \n-  template \n-  output_iterator adjacent_difference(input_iterator, input_iterator, output_iterator);\n+  template output_iterator_type\n+  adjacent_difference(input_iterator_type, input_iterator_type,\n+\t\t      output_iterator_type);\n } "}, {"sha": "763d2d1ebe5e2e09875d9782e03490197695f7dd", "filename": "libstdc++-v3/testsuite/26_numerics/partial_sum/requirements/explicit_instantiation/2.cc", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d0dff49ca1539e14647c04cc1bb035ef4c2780b/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fpartial_sum%2Frequirements%2Fexplicit_instantiation%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d0dff49ca1539e14647c04cc1bb035ef4c2780b/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fpartial_sum%2Frequirements%2Fexplicit_instantiation%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fpartial_sum%2Frequirements%2Fexplicit_instantiation%2F2.cc?ref=6d0dff49ca1539e14647c04cc1bb035ef4c2780b", "patch": "@@ -28,8 +28,9 @@ namespace std\n   using __gnu_test::NonDefaultConstructible;\n \n   typedef NonDefaultConstructible \t\tvalue_type;\n-  typedef value_type* \t\tinput_iterator;\n-  typedef value_type* \t\toutput_iterator;\n+  typedef value_type* \t\tinput_iterator_type;\n+  typedef value_type* \t\toutput_iterator_type;\n \n-  template output_iterator partial_sum(input_iterator, input_iterator, output_iterator);\n+  template output_iterator_type\n+  partial_sum(input_iterator_type, input_iterator_type, output_iterator_type);\n } "}, {"sha": "a5b7a688ccbcfd51d3577bbbfbc575c6e7ed1b39", "filename": "libstdc++-v3/testsuite/26_numerics/partial_sum/requirements/explicit_instantiation/pod.cc", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d0dff49ca1539e14647c04cc1bb035ef4c2780b/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fpartial_sum%2Frequirements%2Fexplicit_instantiation%2Fpod.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d0dff49ca1539e14647c04cc1bb035ef4c2780b/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fpartial_sum%2Frequirements%2Fexplicit_instantiation%2Fpod.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fpartial_sum%2Frequirements%2Fexplicit_instantiation%2Fpod.cc?ref=6d0dff49ca1539e14647c04cc1bb035ef4c2780b", "patch": "@@ -28,8 +28,9 @@ namespace std\n   using __gnu_test::pod_int;\n \n   typedef pod_int \t\tvalue_type;\n-  typedef value_type* \t\tinput_iterator;\n-  typedef value_type* \t\toutput_iterator;\n+  typedef value_type* \t\tinput_iterator_type;\n+  typedef value_type* \t\toutput_iterator_type;\n \n-  template output_iterator partial_sum(input_iterator, input_iterator, output_iterator);\n+  template output_iterator_type\n+  partial_sum(input_iterator_type, input_iterator_type, output_iterator_type);\n } "}, {"sha": "734cc170e9ebebd4007b74209ea772b18f7a7bce", "filename": "libstdc++-v3/testsuite/experimental/iterator/requirements.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d0dff49ca1539e14647c04cc1bb035ef4c2780b/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fiterator%2Frequirements.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d0dff49ca1539e14647c04cc1bb035ef4c2780b/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fiterator%2Frequirements.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fiterator%2Frequirements.cc?ref=6d0dff49ca1539e14647c04cc1bb035ef4c2780b", "patch": "@@ -64,4 +64,6 @@ std::move_iterator<int*> mi;\n std::istream_iterator<int> isi;\n std::ostream_iterator<int> osi(os());\n std::istreambuf_iterator<char> isbi;\n+\n+#include <ostream>\n std::ostreambuf_iterator<char> osbi(os());"}, {"sha": "1d7db46b68a285d3bf82192d5083131cd0b21229", "filename": "libstdc++-v3/testsuite/std/ranges/access/begin.cc", "status": "added", "additions": 140, "deletions": 0, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d0dff49ca1539e14647c04cc1bb035ef4c2780b/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Faccess%2Fbegin.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d0dff49ca1539e14647c04cc1bb035ef4c2780b/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Faccess%2Fbegin.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Faccess%2Fbegin.cc?ref=6d0dff49ca1539e14647c04cc1bb035ef4c2780b", "patch": "@@ -0,0 +1,140 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <iterator> // N.B. should be <ranges>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using std::same_as;\n+\n+void\n+test01()\n+{\n+  int a[2] = {};\n+\n+  static_assert(same_as<decltype(std::ranges::begin(a)), decltype(a + 0)>);\n+  static_assert(noexcept(std::ranges::begin(a)));\n+  VERIFY( std::ranges::begin(a) == (a + 0) );\n+\n+  constexpr long b[2] = { };\n+  static_assert( std::ranges::begin(b) == (b + 0) );\n+}\n+\n+void\n+test02()\n+{\n+  using __gnu_test::test_range;\n+  using __gnu_test::random_access_iterator_wrapper;\n+  using __gnu_test::input_iterator_wrapper;\n+  using __gnu_test::output_iterator_wrapper;\n+\n+  int a[] = { 0, 1 };\n+\n+  test_range<int, random_access_iterator_wrapper> r(a);\n+  static_assert(same_as<decltype(std::ranges::begin(r)), decltype(r.begin())>);\n+  VERIFY( std::ranges::begin(r) == r.begin() );\n+\n+  test_range<int, input_iterator_wrapper> i(a);\n+  static_assert(same_as<decltype(std::ranges::begin(i)), decltype(i.begin())>);\n+  VERIFY( std::ranges::begin(i) == i.begin() );\n+\n+  test_range<int, output_iterator_wrapper> o(a);\n+  static_assert(same_as<decltype(std::ranges::begin(o)), decltype(o.begin())>);\n+  *std::ranges::begin(o) = 99;\n+  VERIFY( a[0] == 99 );\n+}\n+\n+struct R\n+{\n+  int a[4] = { 0, 1, 2, 3 };\n+\n+  friend int* begin(R& r) { return r.a + 0; }\n+  friend int* begin(R&& r) { return r.a + 1; }\n+  friend const int* begin(const R& r) noexcept { return r.a + 2; }\n+  friend const int* begin(const R&& r) noexcept { return r.a + 3; }\n+};\n+\n+void\n+test03()\n+{\n+  R r;\n+  const R& c = r;\n+\n+  static_assert(same_as<decltype(std::ranges::begin(r)), decltype(begin(r))>);\n+  static_assert(!noexcept(std::ranges::begin(r)));\n+  VERIFY( std::ranges::begin(r) == begin(r) );\n+\n+  static_assert(same_as<decltype(std::ranges::begin(std::move(r))),\n+\t\tdecltype(begin(std::move(r)))>);\n+  static_assert(!noexcept(std::ranges::begin(std::move(r))));\n+  VERIFY( std::ranges::begin(std::move(r)) == begin(std::move(r)) );\n+\n+\n+  static_assert(same_as<decltype(std::ranges::begin(c)), decltype(begin(c))>);\n+  static_assert(noexcept(std::ranges::begin(c)));\n+  VERIFY( std::ranges::begin(c) == begin(c) );\n+\n+  static_assert(same_as<decltype(std::ranges::begin(std::move(c))),\n+\t\tdecltype(begin(std::move(c)))>);\n+  static_assert(noexcept(std::ranges::begin(std::move(c))));\n+  VERIFY( std::ranges::begin(std::move(c)) == begin(std::move(c)) );\n+}\n+\n+struct RR\n+{\n+  short s = 0;\n+  long l = 0;\n+  int a[4] = { 0, 1, 2, 3 };\n+\n+  short* begin() noexcept { return &s; }\n+  const long* begin() const { return &l; }\n+\n+  friend int* begin(RR& r) { return r.a + 0; }\n+  friend int* begin(RR&& r) { return r.a + 1; }\n+  friend const int* begin(const RR& r) { return r.a + 2; }\n+  friend const int* begin(const RR&& r) noexcept { return r.a + 3; }\n+};\n+\n+void\n+test04()\n+{\n+  RR r;\n+  const RR& c = r;\n+  VERIFY( std::ranges::begin(r) == &r.s );\n+  static_assert(noexcept(std::ranges::begin(r)));\n+\n+  VERIFY( std::ranges::begin(std::move(r)) == r.a + 1 );\n+  static_assert(!noexcept(std::ranges::begin(std::move(r))));\n+\n+  VERIFY( std::ranges::begin(c) == &r.l );\n+  static_assert(!noexcept(std::ranges::begin(c)));\n+\n+  VERIFY( std::ranges::begin(std::move(c)) == r.a + 3 );\n+  static_assert(noexcept(std::ranges::begin(std::move(c))));\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  test04();\n+}"}, {"sha": "34dd7fec3c658b93ca586d48c20c90191761dc21", "filename": "libstdc++-v3/testsuite/std/ranges/access/cbegin.cc", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d0dff49ca1539e14647c04cc1bb035ef4c2780b/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Faccess%2Fcbegin.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d0dff49ca1539e14647c04cc1bb035ef4c2780b/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Faccess%2Fcbegin.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Faccess%2Fcbegin.cc?ref=6d0dff49ca1539e14647c04cc1bb035ef4c2780b", "patch": "@@ -0,0 +1,91 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <iterator> // N.B. should be <ranges>\n+#include <testsuite_hooks.h>\n+using std::same_as;\n+\n+void\n+test01()\n+{\n+  int a[2] = {};\n+\n+  static_assert(same_as<decltype(std::ranges::cbegin(a)), const int*>);\n+  static_assert(noexcept(std::ranges::cbegin(a)));\n+  VERIFY( std::ranges::cbegin(a) == (a + 0) );\n+\n+  constexpr long b[2] = {};\n+  static_assert( std::ranges::cbegin(b) == (b + 0) );\n+}\n+\n+struct R\n+{\n+  int a[4] = { 0, 1, 2, 3 };\n+\n+  friend int* begin(R& r) { return r.a + 0; }\n+  friend int* begin(R&& r) { return r.a + 1; }\n+  friend const int* begin(const R& r) noexcept { return r.a + 2; }\n+  friend const int* begin(const R&& r) noexcept { return r.a + 3; }\n+};\n+\n+void\n+test03()\n+{\n+  R r;\n+  const R& c = r;\n+  VERIFY(std::ranges::cbegin(r) == std::ranges::begin(c));\n+  VERIFY(std::ranges::cbegin(std::move(r)) == std::ranges::begin(std::move(c)));\n+  VERIFY(std::ranges::cbegin(c) == std::ranges::begin(c));\n+  VERIFY(std::ranges::cbegin(std::move(c)) == std::ranges::begin(std::move(c)));\n+}\n+\n+struct RR\n+{\n+  short s = 0;\n+  long l = 0;\n+  int a[4] = { 0, 1, 2, 3 };\n+\n+  short* begin() noexcept { return &s; }\n+  const long* begin() const { return &l; }\n+\n+  friend int* begin(RR& r) { return r.a + 0; }\n+  friend int* begin(RR&& r) { return r.a + 1; }\n+  friend const int* begin(const RR& r) { return r.a + 2; }\n+  friend const int* begin(const RR&& r) noexcept { return r.a + 3; }\n+};\n+\n+void\n+test04()\n+{\n+  RR r;\n+  const RR& c = r;\n+  VERIFY(std::ranges::cbegin(r) == std::ranges::begin(c));\n+  VERIFY(std::ranges::cbegin(std::move(r)) == std::ranges::begin(std::move(c)));\n+  VERIFY(std::ranges::cbegin(c) == std::ranges::begin(c));\n+  VERIFY(std::ranges::cbegin(std::move(c)) == std::ranges::begin(std::move(c)));\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test03();\n+  test04();\n+}"}, {"sha": "9a1ab5b96079cfeea4dcd20a1c5573dda62b56ae", "filename": "libstdc++-v3/testsuite/std/ranges/access/cdata.cc", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d0dff49ca1539e14647c04cc1bb035ef4c2780b/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Faccess%2Fcdata.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d0dff49ca1539e14647c04cc1bb035ef4c2780b/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Faccess%2Fcdata.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Faccess%2Fcdata.cc?ref=6d0dff49ca1539e14647c04cc1bb035ef4c2780b", "patch": "@@ -0,0 +1,73 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <iterator>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  struct R\n+  {\n+    int i = 0;\n+    int j = 0;\n+    int* data() { return &j; }\n+    const R* data() const noexcept { return nullptr; }\n+  };\n+  R r;\n+  const R& c = r;\n+  VERIFY( std::ranges::cdata(r) == (R*)nullptr );\n+  static_assert( noexcept(std::ranges::cdata(r)) );\n+  VERIFY( std::ranges::cdata(c) == (R*)nullptr );\n+  static_assert( noexcept(std::ranges::cdata(c)) );\n+}\n+\n+void\n+test02()\n+{\n+  int a[] = { 0, 1 };\n+  VERIFY( std::ranges::cdata(a) == a + 0 );\n+}\n+\n+struct R\n+{\n+  long l = 0;\n+\n+  int* data() const { return nullptr; }\n+  friend long* begin(R&& r) { return &r.l; }\n+  friend const long* begin(const R&& r) { return &r.l + 1; }\n+};\n+\n+void\n+test03()\n+{\n+  R r;\n+  const R& c = r;\n+  VERIFY( std::ranges::cdata(std::move(r)) == std::ranges::data(std::move(c)) );\n+  VERIFY( std::ranges::cdata(std::move(c)) == std::ranges::data(std::move(c)) );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+}"}, {"sha": "789c6ca383785410e64608513709b2b921cd1d42", "filename": "libstdc++-v3/testsuite/std/ranges/access/cend.cc", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d0dff49ca1539e14647c04cc1bb035ef4c2780b/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Faccess%2Fcend.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d0dff49ca1539e14647c04cc1bb035ef4c2780b/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Faccess%2Fcend.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Faccess%2Fcend.cc?ref=6d0dff49ca1539e14647c04cc1bb035ef4c2780b", "patch": "@@ -0,0 +1,98 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <iterator> // N.B. should be <ranges>\n+#include <testsuite_hooks.h>\n+\n+using std::same_as;\n+\n+void\n+test01()\n+{\n+  int a[2] = {};\n+\n+  static_assert(same_as<decltype(std::ranges::cend(a)), const int*>);\n+  static_assert(noexcept(std::ranges::cend(a)));\n+  VERIFY( std::ranges::cend(a) == (a + 2) );\n+}\n+\n+struct R\n+{\n+  int a[4] = { 0, 1, 2, 3 };\n+\n+  const int* begin() const { return nullptr; }\n+  friend const int* begin(const R&& r) noexcept { return nullptr; }\n+\n+  // Should be ignored because it doesn't return a sentinel for int*\n+  const long* end() const { return nullptr; }\n+\n+  friend int* end(R& r) { return r.a + 0; }\n+  friend int* end(R&& r) { return r.a + 1; }\n+  friend const int* end(const R& r) noexcept { return r.a + 2; }\n+  friend const int* end(const R&& r) noexcept { return r.a + 3; }\n+};\n+\n+void\n+test03()\n+{\n+  R r;\n+  const R& c = r;\n+  VERIFY( std::ranges::cend(r) == std::ranges::end(c) );\n+  VERIFY( std::ranges::cend(std::move(r)) == std::ranges::end(std::move(c)) );\n+  VERIFY( std::ranges::cend(c) == std::ranges::end(c) );\n+  VERIFY( std::ranges::cend(std::move(c)) == std::ranges::end(std::move(c)) );\n+}\n+\n+struct RR\n+{\n+  short s = 0;\n+  long l = 0;\n+  int a[4] = { 0, 1, 2, 3 };\n+\n+  const void* begin() const { return nullptr; }\n+  friend const void* begin(const RR&&) noexcept { return nullptr; }\n+\n+  short* end() noexcept { return &s; }\n+  const long* end() const { return &l; }\n+\n+  friend int* end(RR&) { throw 1; }\n+  friend int* end(RR&& r) { return r.a + 1; }\n+  friend const int* end(const RR&) { throw 1; }\n+  friend const int* end(const RR&& r) noexcept { return r.a + 3; }\n+};\n+\n+void\n+test04()\n+{\n+  RR r;\n+  const RR& c = r;\n+  VERIFY( std::ranges::cend(r) == std::ranges::end(c) );\n+  VERIFY( std::ranges::cend(std::move(r)) == std::ranges::end(std::move(c)) );\n+  VERIFY( std::ranges::cend(c) == std::ranges::end(c) );\n+  VERIFY( std::ranges::cend(std::move(c)) == std::ranges::end(std::move(c)) );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test03();\n+  test04();\n+}"}, {"sha": "24939ac658e5451181a3728a99a77efed5dbbb47", "filename": "libstdc++-v3/testsuite/std/ranges/access/crbegin.cc", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d0dff49ca1539e14647c04cc1bb035ef4c2780b/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Faccess%2Fcrbegin.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d0dff49ca1539e14647c04cc1bb035ef4c2780b/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Faccess%2Fcrbegin.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Faccess%2Fcrbegin.cc?ref=6d0dff49ca1539e14647c04cc1bb035ef4c2780b", "patch": "@@ -0,0 +1,73 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <iterator>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+struct R1\n+{\n+  int i = 0;\n+  int j = 0;\n+\n+  const int* rbegin() const { return &i; }\n+  friend const int* rbegin(const R1&& r) { return &r.j; }\n+};\n+\n+void\n+test01()\n+{\n+  R1 r;\n+  const R1& c = r;\n+  VERIFY( std::ranges::crbegin(r) == std::ranges::rbegin(c) );\n+  VERIFY( std::ranges::crbegin(std::move(r)) == std::ranges::rbegin(std::move(c)) );\n+  VERIFY( std::ranges::crbegin(c) == std::ranges::rbegin(c) );\n+  VERIFY( std::ranges::crbegin(std::move(c)) == std::ranges::rbegin(std::move(c)) );\n+}\n+\n+struct R2\n+{\n+  int a[2] = { };\n+  long l[2] = { };\n+\n+  const int* begin() const { return a; }\n+  const int* end() const { return a + 2; }\n+\n+  friend const long* begin(const R2&& r) { return r.l; }\n+  friend const long* end(const R2&& r) { return r.l + 2; }\n+};\n+\n+void\n+test02()\n+{\n+  R2 r;\n+  const R2& c = r;\n+  VERIFY( std::ranges::crbegin(r) == std::ranges::rbegin(c) );\n+  VERIFY( std::ranges::crbegin(std::move(r)) == std::ranges::rbegin(std::move(c)) );\n+  VERIFY( std::ranges::crbegin(c) == std::ranges::rbegin(c) );\n+  VERIFY( std::ranges::crbegin(std::move(c)) == std::ranges::rbegin(std::move(c)) );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "ef0fb0e6b09e803dde8b823cc06757388d4325f1", "filename": "libstdc++-v3/testsuite/std/ranges/access/crend.cc", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d0dff49ca1539e14647c04cc1bb035ef4c2780b/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Faccess%2Fcrend.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d0dff49ca1539e14647c04cc1bb035ef4c2780b/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Faccess%2Fcrend.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Faccess%2Fcrend.cc?ref=6d0dff49ca1539e14647c04cc1bb035ef4c2780b", "patch": "@@ -0,0 +1,108 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <iterator>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+struct R1\n+{\n+  int i = 0;\n+  int j = 0;\n+\n+  constexpr const int* rbegin() const { return &i; }\n+  constexpr const int* rend() const { return &i + 1; }\n+  friend constexpr const int* rbegin(const R1&& r) { return &r.j; }\n+  friend constexpr const int* rend(const R1&& r) { return &r.j + 1; }\n+};\n+\n+void\n+test01()\n+{\n+  R1 r;\n+  const R1& c = r;\n+  VERIFY( std::ranges::crend(r) == std::ranges::rend(c) );\n+  VERIFY( std::ranges::crend(std::move(r)) == std::ranges::rend(std::move(c)) );\n+  VERIFY( std::ranges::crend(c) == std::ranges::rend(c) );\n+  VERIFY( std::ranges::crend(std::move(c)) == std::ranges::rend(std::move(c)) );\n+}\n+\n+struct R2\n+{\n+  int a[2] = { };\n+  long l[2] = { };\n+\n+  const int* begin() const { return a; }\n+  const int* end() const { return a + 2; }\n+\n+  friend const long* begin(const R2&& r) { return r.l; }\n+  friend const long* end(const R2&& r) { return r.l + 2; }\n+};\n+\n+void\n+test02()\n+{\n+  R2 r;\n+  const R2& c = r;\n+  VERIFY( std::ranges::crend(r) == std::ranges::rend(c) );\n+  VERIFY( std::ranges::crend(std::move(r)) == std::ranges::rend(std::move(c)) );\n+  VERIFY( std::ranges::crend(c) == std::ranges::rend(c) );\n+  VERIFY( std::ranges::crend(std::move(c)) == std::ranges::rend(std::move(c)) );\n+}\n+\n+struct R3\n+{\n+  int i = 0;\n+\n+  const int* rbegin() const noexcept { return &i + 1; }\n+  const long* rend() const noexcept { return nullptr; } // not a sentinel for rbegin()\n+\n+  friend const long* rbegin(const R3&) noexcept { return nullptr; }\n+  friend const int* rend(const R3& r) { return &r.i; }\n+};\n+\n+void\n+test03()\n+{\n+  R3 r;\n+  const R3& c = r;\n+  VERIFY( std::ranges::crend(r) == std::ranges::rend(c) );\n+  static_assert( !noexcept(std::ranges::crend(r)) );\n+  VERIFY( std::ranges::crend(c) == std::ranges::rend(c) );\n+  static_assert( !noexcept(std::ranges::crend(c)) );\n+}\n+\n+void\n+test04()\n+{\n+  int a[2] = { };\n+  const auto& c = a;\n+  VERIFY( std::ranges::crend(a) == std::ranges::rend(c) );\n+  VERIFY( std::ranges::crend(c) == std::ranges::rend(c) );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  test04();\n+}"}, {"sha": "d9129d055fcc5540c6537febdcf7ea1d21ffeb8c", "filename": "libstdc++-v3/testsuite/std/ranges/access/data.cc", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d0dff49ca1539e14647c04cc1bb035ef4c2780b/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Faccess%2Fdata.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d0dff49ca1539e14647c04cc1bb035ef4c2780b/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Faccess%2Fdata.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Faccess%2Fdata.cc?ref=6d0dff49ca1539e14647c04cc1bb035ef4c2780b", "patch": "@@ -0,0 +1,78 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <iterator>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+void\n+test01()\n+{\n+  struct R\n+  {\n+    int i = 0;\n+    int j = 0;\n+    int* data() { return &j; }\n+    const R* data() const noexcept { return nullptr; }\n+  };\n+  R r;\n+  const R& c = r;\n+  VERIFY( std::ranges::data(r) == &r.j );\n+  static_assert( !noexcept(std::ranges::data(r)) );\n+  VERIFY( std::ranges::data(c) == (R*)nullptr );\n+  static_assert( noexcept(std::ranges::data(c)) );\n+}\n+\n+\n+void\n+test02()\n+{\n+  int a[] = { 0, 1 };\n+  VERIFY( std::ranges::data(a) == a + 0 );\n+\n+  __gnu_test::test_range<int, __gnu_test::contiguous_iterator_wrapper> r(a);\n+  VERIFY( std::ranges::data(r) == std::to_address(std::ranges::begin(r)) );\n+}\n+\n+struct R3\n+{\n+  long l = 0;\n+\n+  int* data() const { return nullptr; }\n+  friend long* begin(R3&& r) { return &r.l; }\n+  friend const long* begin(const R3&& r) { return &r.l + 1; }\n+};\n+\n+void\n+test03()\n+{\n+  R3 r;\n+  const R3& c = r;\n+  VERIFY( std::ranges::data(std::move(r)) == std::to_address(std::ranges::begin(std::move(r))) );\n+  VERIFY( std::ranges::data(std::move(c)) == std::to_address(std::ranges::begin(std::move(c))) );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+}"}, {"sha": "64b1e1b5e1b705ab7e800898dbe1fcb414d11234", "filename": "libstdc++-v3/testsuite/std/ranges/access/empty.cc", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d0dff49ca1539e14647c04cc1bb035ef4c2780b/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Faccess%2Fempty.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d0dff49ca1539e14647c04cc1bb035ef4c2780b/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Faccess%2Fempty.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Faccess%2Fempty.cc?ref=6d0dff49ca1539e14647c04cc1bb035ef4c2780b", "patch": "@@ -0,0 +1,76 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <iterator> // N.B. should be <ranges>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using std::same_as;\n+\n+void\n+test01()\n+{\n+  struct R\n+  {\n+    constexpr int empty() const & { return 0; }\n+    constexpr const void* empty() const && { return this; }\n+  };\n+  constexpr R r;\n+  static_assert( !std::ranges::empty(r) );\n+  static_assert( same_as<decltype(std::ranges::empty(r)), bool> );\n+  static_assert( std::ranges::empty(std::move(r)) );\n+  static_assert( same_as<decltype(std::ranges::empty(std::move(r))), bool> );\n+}\n+\n+void\n+test02()\n+{\n+  using __gnu_test::test_range;\n+  using __gnu_test::test_sized_range;\n+  using __gnu_test::random_access_iterator_wrapper;\n+  using __gnu_test::forward_iterator_wrapper;\n+  using __gnu_test::input_iterator_wrapper;\n+  using __gnu_test::output_iterator_wrapper;\n+\n+  int a[] = { 0, 1 };\n+  VERIFY( !std::ranges::empty(a) );\n+\n+  test_range<int, random_access_iterator_wrapper> r(a);\n+  VERIFY( !std::ranges::empty(r) );\n+\n+  test_range<int, forward_iterator_wrapper> i(a);\n+  VERIFY( !std::ranges::empty(i) );\n+\n+  test_sized_range<int, random_access_iterator_wrapper> sr(a);\n+  VERIFY( !std::ranges::empty(sr) );\n+\n+  test_sized_range<int, input_iterator_wrapper> si(a);\n+  VERIFY( !std::ranges::empty(si) );\n+\n+  test_sized_range<int, output_iterator_wrapper> so(a);\n+  VERIFY( !std::ranges::empty(so) );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "7f09cc2a4aba5633515abae812f15c17d6fd8fd6", "filename": "libstdc++-v3/testsuite/std/ranges/access/end.cc", "status": "added", "additions": 145, "deletions": 0, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d0dff49ca1539e14647c04cc1bb035ef4c2780b/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Faccess%2Fend.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d0dff49ca1539e14647c04cc1bb035ef4c2780b/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Faccess%2Fend.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Faccess%2Fend.cc?ref=6d0dff49ca1539e14647c04cc1bb035ef4c2780b", "patch": "@@ -0,0 +1,145 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <iterator> // N.B. should be <ranges>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using std::same_as;\n+\n+void\n+test01()\n+{\n+  int a[2] = {};\n+\n+  static_assert(same_as<decltype(std::ranges::end(a)), decltype(a + 2)>);\n+  static_assert(noexcept(std::ranges::end(a)));\n+  VERIFY( std::ranges::end(a) == (a + 2) );\n+}\n+\n+void\n+test02()\n+{\n+  using __gnu_test::test_range;\n+  using __gnu_test::random_access_iterator_wrapper;\n+  using __gnu_test::input_iterator_wrapper;\n+  using __gnu_test::output_iterator_wrapper;\n+\n+  int a[] = { 0, 1 };\n+\n+  test_range<int, random_access_iterator_wrapper> r(a);\n+  static_assert(same_as<decltype(std::ranges::end(r)), decltype(r.end())>);\n+  VERIFY( std::ranges::end(r) == r.end() );\n+\n+  test_range<int, input_iterator_wrapper> i(a);\n+  static_assert(same_as<decltype(std::ranges::end(i)), decltype(i.end())>);\n+  VERIFY( std::ranges::end(i) == i.end() );\n+\n+  test_range<int, output_iterator_wrapper> o(a);\n+  static_assert(same_as<decltype(std::ranges::end(o)), decltype(o.end())>);\n+  VERIFY( std::ranges::end(o) == std::ranges::next(o.begin(), 2) );\n+}\n+\n+struct R\n+{\n+  int a[4] = { 0, 1, 2, 3 };\n+\n+  const int* begin() const { return nullptr; }\n+  friend const int* begin(const R&& r) noexcept { return nullptr; }\n+\n+  // Should be ignored because it doesn't return a sentinel for int*\n+  const long* end() const { return nullptr; }\n+\n+  friend int* end(R& r) { return r.a + 0; }\n+  friend int* end(R&& r) { return r.a + 1; }\n+  friend const int* end(const R& r) noexcept { return r.a + 2; }\n+  friend const int* end(const R&& r) noexcept { return r.a + 3; }\n+};\n+\n+void\n+test03()\n+{\n+  R r;\n+  const R& c = r;\n+\n+  static_assert(same_as<decltype(std::ranges::end(r)), decltype(end(r))>);\n+  static_assert(!noexcept(std::ranges::end(r)));\n+  VERIFY( std::ranges::end(r) == end(r) );\n+\n+  static_assert(same_as<decltype(std::ranges::end(std::move(r))),\n+\t\tdecltype(end(std::move(r)))>);\n+  static_assert(!noexcept(std::ranges::end(std::move(r))));\n+  VERIFY( std::ranges::end(std::move(r)) == end(std::move(r)) );\n+\n+\n+  static_assert(same_as<decltype(std::ranges::end(c)), decltype(end(c))>);\n+  static_assert(noexcept(std::ranges::end(c)));\n+  VERIFY( std::ranges::end(c) == end(c) );\n+\n+  static_assert(same_as<decltype(std::ranges::end(std::move(c))),\n+\t\tdecltype(end(std::move(c)))>);\n+  static_assert(noexcept(std::ranges::end(std::move(c))));\n+  VERIFY( std::ranges::end(std::move(c)) == end(std::move(c)) );\n+}\n+\n+struct RR\n+{\n+  short s = 0;\n+  long l = 0;\n+  int a[4] = { 0, 1, 2, 3 };\n+\n+  const void* begin() const { return nullptr; }\n+  friend const void* begin(const RR&&) noexcept { return nullptr; }\n+\n+  short* end() noexcept { return &s; }\n+  const long* end() const { return &l; }\n+\n+  friend int* end(RR&) { throw 1; }\n+  friend int* end(RR&& r) { return r.a + 1; }\n+  friend const int* end(const RR&) { throw 1; }\n+  friend const int* end(const RR&& r) noexcept { return r.a + 3; }\n+};\n+\n+void\n+test04()\n+{\n+  RR r;\n+  const RR& c = r;\n+  VERIFY( std::ranges::end(r) == &r.s );\n+  static_assert(noexcept(std::ranges::end(r)));\n+\n+  VERIFY( std::ranges::end(std::move(r)) == r.a + 1 );\n+  static_assert(!noexcept(std::ranges::end(std::move(r))));\n+\n+  VERIFY( std::ranges::end(c) == &r.l );\n+  static_assert(!noexcept(std::ranges::end(c)));\n+\n+  VERIFY( std::ranges::end(std::move(c)) == r.a + 3 );\n+  static_assert(noexcept(std::ranges::end(std::move(c))));\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  test04();\n+}"}, {"sha": "6cfc1a38122e5351ff7222b839ef8058d2fec435", "filename": "libstdc++-v3/testsuite/std/ranges/access/rbegin.cc", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d0dff49ca1539e14647c04cc1bb035ef4c2780b/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Faccess%2Frbegin.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d0dff49ca1539e14647c04cc1bb035ef4c2780b/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Faccess%2Frbegin.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Faccess%2Frbegin.cc?ref=6d0dff49ca1539e14647c04cc1bb035ef4c2780b", "patch": "@@ -0,0 +1,81 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <iterator>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+struct R1\n+{\n+  int i = 0;\n+  int j = 0;\n+\n+  constexpr const int* rbegin() const { return &i; }\n+  friend constexpr const int* rbegin(const R1&& r) { return &r.j; }\n+};\n+\n+void\n+test01()\n+{\n+  constexpr R1 r;\n+  static_assert( std::ranges::rbegin(r) == &r.i );\n+  static_assert( std::ranges::rbegin(std::move(r)) == &r.j );\n+}\n+\n+struct R2\n+{\n+  int a[2] = { };\n+  long l[2] = { };\n+\n+  constexpr const int* begin() const { return a; }\n+  constexpr const int* end() const { return a + 2; }\n+\n+  friend constexpr const long* begin(const R2&& r) { return r.l; }\n+  friend constexpr const long* end(const R2&& r) { return r.l + 2; }\n+};\n+\n+void\n+test02()\n+{\n+  constexpr R2 r;\n+  static_assert( std::ranges::rbegin(r)\n+      == std::make_reverse_iterator(std::ranges::end(r)) );\n+  static_assert( std::ranges::rbegin(std::move(r))\n+      == std::make_reverse_iterator(std::ranges::end(std::move(r))) );\n+}\n+\n+void\n+test03()\n+{\n+  using __gnu_test::test_range;\n+  using __gnu_test::bidirectional_iterator_wrapper;\n+\n+  int a[2] = { };\n+  test_range<int, bidirectional_iterator_wrapper> r(a);\n+  VERIFY( std::ranges::rbegin(r) == std::make_reverse_iterator(std::ranges::end(r)) );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+}"}, {"sha": "2192825708a332c6e776574847d917d5c189f9fd", "filename": "libstdc++-v3/testsuite/std/ranges/access/rend.cc", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d0dff49ca1539e14647c04cc1bb035ef4c2780b/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Faccess%2Frend.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d0dff49ca1539e14647c04cc1bb035ef4c2780b/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Faccess%2Frend.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Faccess%2Frend.cc?ref=6d0dff49ca1539e14647c04cc1bb035ef4c2780b", "patch": "@@ -0,0 +1,105 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <iterator>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+struct R1\n+{\n+  int i = 0;\n+  int j = 0;\n+\n+  constexpr const int* rbegin() const { return &i; }\n+  constexpr const int* rend() const { return &i + 1; }\n+  friend constexpr const int* rbegin(const R1&& r) { return &r.j; }\n+  friend constexpr const int* rend(const R1&& r) { return &r.j + 1; }\n+};\n+\n+void\n+test01()\n+{\n+  constexpr R1 r;\n+  static_assert( std::ranges::rend(r) == &r.i + 1 );\n+  static_assert( std::ranges::rend(std::move(r)) == &r.j + 1 );\n+}\n+\n+struct R2\n+{\n+  int a[2] = { };\n+  long l[2] = { };\n+\n+  constexpr const int* begin() const { return a; }\n+  constexpr const int* end() const { return a + 2; }\n+\n+  friend constexpr const long* begin(const R2&& r) { return r.l; }\n+  friend constexpr const long* end(const R2&& r) { return r.l + 2; }\n+};\n+\n+void\n+test02()\n+{\n+  constexpr R2 r;\n+  static_assert( std::ranges::rend(r)\n+      == std::make_reverse_iterator(std::ranges::begin(r)) );\n+  static_assert( std::ranges::rend(std::move(r))\n+      == std::make_reverse_iterator(std::ranges::begin(std::move(r))) );\n+}\n+\n+struct R3\n+{\n+  int i = 0;\n+\n+  int* rbegin() noexcept { return &i + 1; }\n+  long* rend() noexcept { return nullptr; } // not a sentinel for rbegin()\n+\n+  friend long* rbegin(R3&) noexcept { return nullptr; }\n+  friend int* rend(R3& r) { return &r.i; }\n+};\n+\n+void\n+test03()\n+{\n+  R3 r;\n+  auto i1 = std::ranges::rbegin(r);\n+  auto i2 = rend(r);\n+  static_assert( std::sentinel_for<decltype(i2), decltype(i1)> );\n+  // VERIFY( std::ranges::rend(r) == r.i );\n+  // static_assert( !noexcept(std::ranges::rend(r)) );\n+}\n+\n+void\n+test04()\n+{\n+  using __gnu_test::test_range;\n+  using __gnu_test::bidirectional_iterator_wrapper;\n+\n+  int a[2] = { };\n+  test_range<int, bidirectional_iterator_wrapper> r(a);\n+  VERIFY( std::ranges::rend(r) == std::make_reverse_iterator(std::ranges::begin(r)) );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+}"}, {"sha": "b92e5d504497816470e7849df64f39955b2c728b", "filename": "libstdc++-v3/testsuite/std/ranges/access/size.cc", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d0dff49ca1539e14647c04cc1bb035ef4c2780b/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Faccess%2Fsize.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d0dff49ca1539e14647c04cc1bb035ef4c2780b/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Faccess%2Fsize.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Faccess%2Fsize.cc?ref=6d0dff49ca1539e14647c04cc1bb035ef4c2780b", "patch": "@@ -0,0 +1,116 @@\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <iterator>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+void\n+test01()\n+{\n+  constexpr int a[10] = { };\n+  static_assert( std::ranges::size(a) == 10 );\n+  static_assert( noexcept(std::ranges::size(a)) );\n+\n+  int a2[2];\n+  VERIFY( std::ranges::size(a2) == 2);\n+  static_assert( noexcept(std::ranges::size(a2)) );\n+}\n+\n+void\n+test02()\n+{\n+  struct R\n+  {\n+    int size() { return 1; }\n+    long size() const noexcept { return 2; }\n+  };\n+  R r;\n+  const R& c = r;\n+  VERIFY( std::ranges::size(r) == 1 );\n+  static_assert( !noexcept(std::ranges::size(r)) );\n+  VERIFY( std::ranges::size(c) == 2L );\n+  static_assert( noexcept(std::ranges::size(c)) );\n+\n+  int a[3] = { };\n+  __gnu_test::test_sized_range<int, __gnu_test::input_iterator_wrapper> ri(a);\n+  VERIFY( std::ranges::size(ri) == 3 );\n+  static_assert( noexcept(std::ranges::size(ri)) );\n+}\n+\n+struct R3\n+{\n+  int* size() { return nullptr; }\n+  friend int size(R3&) noexcept { return 1; }\n+  friend long size(const R3&) { return 2L; }\n+  friend unsigned int size(R3&&) { return 3U; }\n+  friend unsigned long size(const R3&&) noexcept { return 4UL; }\n+};\n+\n+void\n+test03()\n+{\n+  R3 r;\n+  const R3& c = r;\n+  VERIFY( std::ranges::size(r) == 1 );\n+  static_assert( noexcept(std::ranges::size(r)) );\n+  VERIFY( std::ranges::size(std::move(r)) == 3U );\n+  static_assert( !noexcept(std::ranges::size(std::move(r))) );\n+  VERIFY( std::ranges::size(c) == 2L );\n+  static_assert( !noexcept(std::ranges::size(c)) );\n+  VERIFY( std::ranges::size(std::move(c)) == 4UL );\n+  static_assert( noexcept(std::ranges::size(std::move(c))) );\n+}\n+\n+void\n+test04()\n+{\n+  int a[] = { 0, 1 };\n+  __gnu_test::test_range<int, __gnu_test::random_access_iterator_wrapper> r(a);\n+  auto& rr = r;\n+  VERIFY( std::ranges::size(r) == (std::ranges::end(r) - std::ranges::begin(r)) );\n+}\n+\n+struct R5\n+{\n+  int size() const noexcept { return 0; }\n+  R5* begin() { return this; }\n+  R5* end() { return this + 1; }\n+};\n+\n+template<>\n+constexpr bool std::ranges::disable_sized_range<R5> = true;\n+\n+void\n+test05()\n+{\n+  R5 r;\n+  VERIFY( std::ranges::size(r) == 1 );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  test04();\n+  test05();\n+}"}, {"sha": "70c1f9b66894e9c58043ecb7c1d52ac2918fe124", "filename": "libstdc++-v3/testsuite/util/testsuite_iterators.h", "status": "modified", "additions": 142, "deletions": 2, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d0dff49ca1539e14647c04cc1bb035ef4c2780b/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_iterators.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d0dff49ca1539e14647c04cc1bb035ef4c2780b/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_iterators.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_iterators.h?ref=6d0dff49ca1539e14647c04cc1bb035ef4c2780b", "patch": "@@ -590,5 +590,145 @@ namespace __gnu_test\n     size() const\n     { return bounds.size(); }\n   };\n-}\n-#endif\n+\n+#if __cplusplus > 201703L\n+  template<typename T>\n+    struct contiguous_iterator_wrapper\n+    : random_access_iterator_wrapper<T>\n+    {\n+      using random_access_iterator_wrapper<T>::random_access_iterator_wrapper;\n+\n+      using iterator_concept = std::contiguous_iterator_tag;\n+\n+      contiguous_iterator_wrapper&\n+      operator++()\n+      {\n+\trandom_access_iterator_wrapper<T>::operator++();\n+\treturn *this;\n+      }\n+\n+      contiguous_iterator_wrapper&\n+      operator--()\n+      {\n+\trandom_access_iterator_wrapper<T>::operator--();\n+\treturn *this;\n+      }\n+\n+      contiguous_iterator_wrapper\n+      operator++(int)\n+      {\n+\tauto tmp = *this;\n+\t++*this;\n+\treturn tmp;\n+      }\n+\n+      contiguous_iterator_wrapper\n+      operator--(int)\n+      {\n+\tauto tmp = *this;\n+\t--*this;\n+\treturn tmp;\n+      }\n+\n+      contiguous_iterator_wrapper&\n+      operator+=(std::ptrdiff_t n)\n+      {\n+\trandom_access_iterator_wrapper<T>::operator+=(n);\n+\treturn *this;\n+      }\n+\n+      friend contiguous_iterator_wrapper\n+      operator+(contiguous_iterator_wrapper iter, std::ptrdiff_t n)\n+      { return iter += n; }\n+\n+      friend contiguous_iterator_wrapper\n+      operator+(std::ptrdiff_t n, contiguous_iterator_wrapper iter)\n+      { return iter += n; }\n+\n+      contiguous_iterator_wrapper&\n+      operator-=(std::ptrdiff_t n)\n+      { return *this += -n; }\n+\n+      friend contiguous_iterator_wrapper\n+      operator-(contiguous_iterator_wrapper iter, std::ptrdiff_t n)\n+      { return iter -= n; }\n+    };\n+\n+  // A type meeting the minimum std::range requirements\n+  template<typename T, template<typename> class Iter>\n+    class test_range\n+    {\n+      // Adds default constructor to Iter<T> if needed\n+      struct iterator : Iter<T>\n+      {\n+\tusing Iter<T>::Iter;\n+\n+\titerator() : Iter<T>(nullptr, nullptr) { }\n+\n+\tusing Iter<T>::operator++;\n+\n+\titerator& operator++() { Iter<T>::operator++(); return *this; }\n+      };\n+\n+      template<typename I>\n+\tstruct sentinel\n+\t{\n+\t  T* end;\n+\n+\t  friend bool operator==(const sentinel& s, const I& i)\n+\t  { return s.end == i.ptr; }\n+\n+\t  friend bool operator!=(const sentinel& s, const I& i)\n+\t  { return !(s == i); }\n+\n+\t  friend bool operator==(const I& i, const sentinel& s)\n+\t  { return s == i; }\n+\n+\t  friend bool operator!=(const I& i, const sentinel& s)\n+\t  { return !(s == i); }\n+\t};\n+\n+      auto\n+      get_iterator(T* p)\n+      {\n+\tif constexpr (std::default_constructible<Iter<T>>)\n+\t  return Iter<T>(p, &bounds);\n+\telse\n+\t  return iterator(p, &bounds);\n+      }\n+\n+    public:\n+      test_range(T* first, T* last) : bounds(first, last)\n+      { }\n+\n+      template<std::size_t N>\n+\texplicit\n+\ttest_range(T (&arr)[N]) : test_range(arr, arr+N)\n+\t{ }\n+\n+      auto begin() & { return get_iterator(bounds.first); }\n+\n+      auto end() &\n+      {\n+\tusing I = decltype(get_iterator(bounds.last));\n+\tif constexpr (std::sentinel_for<I, I>)\n+\t  return get_iterator(bounds.last);\n+\telse\n+\t  return sentinel<I>{bounds.last};\n+      }\n+\n+      typename Iter<T>::ContainerType bounds;\n+    };\n+\n+  // A type meeting the minimum std::sized_range requirements\n+  template<typename T, template<typename> class Iter>\n+    struct test_sized_range : test_range<T, Iter>\n+    {\n+      using test_range<T, Iter>::test_range;\n+\n+      std::size_t size() const noexcept\n+      { return this->bounds.size(); }\n+    };\n+#endif // C++20\n+} // namespace __gnu_test\n+#endif // _TESTSUITE_ITERATORS"}]}