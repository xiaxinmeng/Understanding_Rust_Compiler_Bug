{"sha": "86066f9bd4c6ea678e843eea7bad9a260d25e22a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODYwNjZmOWJkNGM2ZWE2NzhlODQzZWVhN2JhZDlhMjYwZDI1ZTIyYQ==", "commit": {"author": {"name": "James E Wilson", "email": "wilson@specifixinc.com", "date": "2006-04-12T22:10:49Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "2006-04-12T22:10:49Z"}, "message": "Fix IA-64 problems with denorms getting clobbered by type conversions.\n\nPR libgcj/26483\n* src/ia64/ffi.c (stf_spill, ldf_fill): Rewrite as macros.\n(hfa_type_load): Call stf_spill.\n(hfa_type_store): Call ldf_fill.\n(ffi_call): Adjust calls to above routines.  Add local temps for\nmacro result.\n\nFrom-SVN: r112900", "tree": {"sha": "058fd994fe32fbfca9c9895944282d6ec1b80c24", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/058fd994fe32fbfca9c9895944282d6ec1b80c24"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/86066f9bd4c6ea678e843eea7bad9a260d25e22a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86066f9bd4c6ea678e843eea7bad9a260d25e22a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86066f9bd4c6ea678e843eea7bad9a260d25e22a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86066f9bd4c6ea678e843eea7bad9a260d25e22a/comments", "author": null, "committer": null, "parents": [{"sha": "3f1d352611a48f7104634a420106f8fc74fb3547", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f1d352611a48f7104634a420106f8fc74fb3547", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f1d352611a48f7104634a420106f8fc74fb3547"}], "stats": {"total": 95, "additions": 60, "deletions": 35}, "files": [{"sha": "baa57145be7442692f848e27dc350ad66351412b", "filename": "libffi/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86066f9bd4c6ea678e843eea7bad9a260d25e22a/libffi%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86066f9bd4c6ea678e843eea7bad9a260d25e22a/libffi%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FChangeLog?ref=86066f9bd4c6ea678e843eea7bad9a260d25e22a", "patch": "@@ -1,3 +1,12 @@\n+2006-04-12  James E Wilson  <wilson@specifix.com>\n+\n+\tPR libgcj/26483\n+\t* src/ia64/ffi.c (stf_spill, ldf_fill): Rewrite as macros.\n+\t(hfa_type_load): Call stf_spill.\n+\t(hfa_type_store): Call ldf_fill.\n+\t(ffi_call): Adjust calls to above routines.  Add local temps for\n+\tmacro result.\n+\t\n 2006-04-10  Matthias Klose  <doko@debian.org>\n \n \t* testsuite/lib/libffi-dg.exp (libffi-init): Recognize multilib"}, {"sha": "77dec567284a01f2c049abed468d60426c019d3d", "filename": "libffi/src/ia64/ffi.c", "status": "modified", "additions": 51, "deletions": 35, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86066f9bd4c6ea678e843eea7bad9a260d25e22a/libffi%2Fsrc%2Fia64%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86066f9bd4c6ea678e843eea7bad9a260d25e22a/libffi%2Fsrc%2Fia64%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fia64%2Fffi.c?ref=86066f9bd4c6ea678e843eea7bad9a260d25e22a", "patch": "@@ -69,24 +69,19 @@ endian_adjust (void *addr, size_t len)\n #endif\n }\n \n-/* Store VALUE to ADDR in the current cpu implementation's fp spill format.  */\n+/* Store VALUE to ADDR in the current cpu implementation's fp spill format.\n+   This is a macro instead of a function, so that it works for all 3 floating\n+   point types without type conversions.  Type conversion to long double breaks\n+   the denorm support.  */\n \n-static inline void\n-stf_spill(fpreg *addr, __float80 value)\n-{\n+#define stf_spill(addr, value)\t\\\n   asm (\"stf.spill %0 = %1%P0\" : \"=m\" (*addr) : \"f\"(value));\n-}\n \n /* Load a value from ADDR, which is in the current cpu implementation's\n-   fp spill format.  */\n+   fp spill format.  As above, this must also be a macro.  */\n \n-static inline __float80\n-ldf_fill(fpreg *addr)\n-{\n-  __float80 ret;\n-  asm (\"ldf.fill %0 = %1%P1\" : \"=f\"(ret) : \"m\"(*addr));\n-  return ret;\n-}\n+#define ldf_fill(result, addr)\t\\\n+  asm (\"ldf.fill %0 = %1%P1\" : \"=f\"(result) : \"m\"(*addr));\n \n /* Return the size of the C type associated with with TYPE.  Which will\n    be one of the FFI_IA64_TYPE_HFA_* values.  */\n@@ -110,17 +105,20 @@ hfa_type_size (int type)\n /* Load from ADDR a value indicated by TYPE.  Which will be one of\n    the FFI_IA64_TYPE_HFA_* values.  */\n \n-static __float80\n-hfa_type_load (int type, void *addr)\n+static void\n+hfa_type_load (fpreg *fpaddr, int type, void *addr)\n {\n   switch (type)\n     {\n     case FFI_IA64_TYPE_HFA_FLOAT:\n-      return *(float *) addr;\n+      stf_spill (fpaddr, *(float *) addr);\n+      return;\n     case FFI_IA64_TYPE_HFA_DOUBLE:\n-      return *(double *) addr;\n+      stf_spill (fpaddr, *(double *) addr);\n+      return;\n     case FFI_IA64_TYPE_HFA_LDOUBLE:\n-      return *(__float80 *) addr;\n+      stf_spill (fpaddr, *(__float80 *) addr);\n+      return;\n     default:\n       abort ();\n     }\n@@ -130,19 +128,31 @@ hfa_type_load (int type, void *addr)\n    the FFI_IA64_TYPE_HFA_* values.  */\n \n static void\n-hfa_type_store (int type, void *addr, __float80 value)\n+hfa_type_store (int type, void *addr, fpreg *fpaddr)\n {\n   switch (type)\n     {\n     case FFI_IA64_TYPE_HFA_FLOAT:\n-      *(float *) addr = value;\n-      break;\n+      {\n+\tfloat result;\n+\tldf_fill (result, fpaddr);\n+\t*(float *) addr = result;\n+\tbreak;\n+      }\n     case FFI_IA64_TYPE_HFA_DOUBLE:\n-      *(double *) addr = value;\n-      break;\n+      {\n+\tdouble result;\n+\tldf_fill (result, fpaddr);\n+\t*(double *) addr = result;\n+\tbreak;\n+      }\n     case FFI_IA64_TYPE_HFA_LDOUBLE:\n-      *(__float80 *) addr = value;\n-      break;\n+      {\n+\t__float80 result;\n+\tldf_fill (result, fpaddr);\n+\t*(__float80 *) addr = result;\n+\tbreak;\n+      }\n     default:\n       abort ();\n     }\n@@ -351,8 +361,8 @@ ffi_call(ffi_cif *cif, void (*fn)(), void *rvalue, void **avalue)\n \t\t       && offset < size\n \t\t       && gp_offset < 8 * 8)\n \t\t  {\n-\t\t    stf_spill (&stack->fp_regs[fpcount],\n-\t\t\t       hfa_type_load (hfa_type, avalue[i] + offset));\n+\t\t    hfa_type_load (&stack->fp_regs[fpcount], hfa_type,\n+\t\t\t\t   avalue[i] + offset);\n \t\t    offset += hfa_size;\n \t\t    gp_offset += hfa_size;\n \t\t    fpcount += 1;\n@@ -475,9 +485,11 @@ ffi_closure_unix_inner (ffi_closure *closure, struct ia64_args *stack,\n \tcase FFI_TYPE_FLOAT:\n \t  if (gpcount < 8 && fpcount < 8)\n \t    {\n-\t      void *addr = &stack->fp_regs[fpcount++];\n+\t      fpreg *addr = &stack->fp_regs[fpcount++];\n+\t      float result;\n \t      avalue[i] = addr;\n-\t      *(float *)addr = ldf_fill (addr);\n+\t      ldf_fill (result, addr);\n+\t      *(float *)addr = result;\n \t    }\n \t  else\n \t    avalue[i] = endian_adjust(&stack->gp_regs[gpcount], 4);\n@@ -487,9 +499,11 @@ ffi_closure_unix_inner (ffi_closure *closure, struct ia64_args *stack,\n \tcase FFI_TYPE_DOUBLE:\n \t  if (gpcount < 8 && fpcount < 8)\n \t    {\n-\t      void *addr = &stack->fp_regs[fpcount++];\n+\t      fpreg *addr = &stack->fp_regs[fpcount++];\n+\t      double result;\n \t      avalue[i] = addr;\n-\t      *(double *)addr = ldf_fill (addr);\n+\t      ldf_fill (result, addr);\n+\t      *(double *)addr = result;\n \t    }\n \t  else\n \t    avalue[i] = &stack->gp_regs[gpcount];\n@@ -501,9 +515,11 @@ ffi_closure_unix_inner (ffi_closure *closure, struct ia64_args *stack,\n \t    gpcount++;\n \t  if (LDBL_MANT_DIG == 64 && gpcount < 8 && fpcount < 8)\n \t    {\n-\t      void *addr = &stack->fp_regs[fpcount++];\n+\t      fpreg *addr = &stack->fp_regs[fpcount++];\n+\t      __float80 result;\n \t      avalue[i] = addr;\n-\t      *(__float80 *)addr = ldf_fill (addr);\n+\t      ldf_fill (result, addr);\n+\t      *(__float80 *)addr = result;\n \t    }\n \t  else\n \t    avalue[i] = &stack->gp_regs[gpcount];\n@@ -533,8 +549,8 @@ ffi_closure_unix_inner (ffi_closure *closure, struct ia64_args *stack,\n \t\t       && offset < size\n \t\t       && gp_offset < 8 * 8)\n \t\t  {\n-\t\t    hfa_type_store (hfa_type, addr + offset, \n-\t\t\t\t    ldf_fill (&stack->fp_regs[fpcount]));\n+\t\t    hfa_type_store (hfa_type, addr + offset,\n+\t\t\t\t    &stack->fp_regs[fpcount]);\n \t\t    offset += hfa_size;\n \t\t    gp_offset += hfa_size;\n \t\t    fpcount += 1;"}]}