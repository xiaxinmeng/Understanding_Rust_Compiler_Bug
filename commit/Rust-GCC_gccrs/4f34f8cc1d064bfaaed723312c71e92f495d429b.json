{"sha": "4f34f8cc1d064bfaaed723312c71e92f495d429b", "node_id": "C_kwDOANBUbNoAKDRmMzRmOGNjMWQwNjRiZmFhZWQ3MjMzMTJjNzFlOTJmNDk1ZDQyOWI", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-01-07T22:44:23Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-01-11T14:16:08Z"}, "message": "analyzer: fix false +ve on bitwise binops (PR analyzer/102692)\n\nPR analyzer/102692 reports a false positive at -O2 from\n-Wanalyzer-null-dereference on:\n  if (!p || q || !p->next)\n\nAt the gimple level, -O2 has converted the first || into bitwise or\ncontrolling a jump:\n  _4 = _2 | _3;\n  if (_4 != 0)\nand a recursive call has been converted to iteration.  The analyzer hits\nthe symbolic value complexity limit whilst analyzing the iteration and\nhits a case where _2 is (_Bool)1 (i.e. true) and _3 (i.e. q) is\nUNKNOWN(_Bool).\n\nThere are two issues leading to the false positive; fixing either issue\nfixes the false positive; this patch fixes both for good measure:\n\n(a) The analyzer erronously treats bitwise ops on UNKNOWN(_Bool) as UNKNOWN,\neven for case like (1 | UNKNOWN) where we know the result, leading to\nbogus edges in the exploded graph.  The patch fixes these cases.\n\n(b) The state-handling code creates \"UNKNOWN\" symbolic values, as a way\nto give up when symbolic expressions get too complicated, and in various\nother cases.  This makes sense when building the exploded graph, since\nwe want the analysis to terminate, but doesn't make sense when checking\nthe feasibility along a specific path, where we want precision.  The patch\nprevents all use of \"unknown\" symbolic values when performing feasibility\nchecking of a path (before it merely stopped doing complexity-checking),\nby creating a unique placeholder_svalue instead.\n\nThis fixes the -Wanalyzer-null-dereference false positive.\n\nUnfortunately, with GCC 12 there's also a false positive from\n-Wanalyzer-use-of-uninitialized-value on this code, which is a separate\nissue that the patch does not fix.\n\ngcc/analyzer/ChangeLog:\n\tPR analyzer/102692\n\t* diagnostic-manager.cc\n\t(class auto_disable_complexity_checks): Rename to...\n\t(class auto_checking_feasibility): ...this, updating\n\tthe calls accordingly.\n\t(epath_finder::explore_feasible_paths): Update for renaming.\n\t* region-model-manager.cc\n\t(region_model_manager::region_model_manager): Update for change from\n\tm_check_complexity to m_checking_feasibility.\n\t(region_model_manager::reject_if_too_complex): Likewise.\n\t(region_model_manager::get_or_create_unknown_svalue): Handle\n\tm_checking_feasibility.\n\t(region_model_manager::create_unique_svalue): New.\n\t(region_model_manager::maybe_fold_binop): Handle BIT_AND_EXPR and\n\tBIT_IOR_EXPRs on booleans where we know the result.\n\t* region-model.cc (test_binop_svalue_folding): Add test coverage\n\tfor the above.\n\t* region-model.h (region_model_manager::create_unique_svalue): New\n\tdecl.\n\t(region_model_manager::enable_complexity_check): Replace with...\n\t(region_model_manager::begin_checking_feasibility): ...this.\n\t(region_model_manager::disable_complexity_check): Replace with...\n\t(region_model_manager::end_checking_feasibility): ...this.\n\t(region_model_manager::m_check_complexity): Replace with...\n\t(region_model_manager::m_checking_feasibility): ...this.\n\t(region_model_manager::m_managed_dynamic_svalues): New field.\n\ngcc/testsuite/ChangeLog:\n\tPR analyzer/102692\n\t* gcc.dg/analyzer/pr102692.c: New test.\n\nSigned-off-by: David Malcolm <dmalcolm@redhat.com>", "tree": {"sha": "d831cf25f32f088e4b260961aed644d0619333db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d831cf25f32f088e4b260961aed644d0619333db"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4f34f8cc1d064bfaaed723312c71e92f495d429b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f34f8cc1d064bfaaed723312c71e92f495d429b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f34f8cc1d064bfaaed723312c71e92f495d429b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f34f8cc1d064bfaaed723312c71e92f495d429b/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "438f2a24a4f02a3128847f7186bfcb56e7a60d83", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/438f2a24a4f02a3128847f7186bfcb56e7a60d83", "html_url": "https://github.com/Rust-GCC/gccrs/commit/438f2a24a4f02a3128847f7186bfcb56e7a60d83"}], "stats": {"total": 231, "additions": 219, "deletions": 12}, "files": [{"sha": "73c133dd66d67593475343c36fdfadc37e6a523c", "filename": "gcc/analyzer/diagnostic-manager.cc", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f34f8cc1d064bfaaed723312c71e92f495d429b/gcc%2Fanalyzer%2Fdiagnostic-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f34f8cc1d064bfaaed723312c71e92f495d429b/gcc%2Fanalyzer%2Fdiagnostic-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fdiagnostic-manager.cc?ref=4f34f8cc1d064bfaaed723312c71e92f495d429b", "patch": "@@ -303,18 +303,21 @@ class feasible_worklist\n \n    Hence this is an RAII class for temporarily disabling complexity-checking\n    in the region_model_manager, for use within\n-   epath_finder::explore_feasible_paths.  */\n+   epath_finder::explore_feasible_paths.\n \n-class auto_disable_complexity_checks\n+   We also disable the creation of unknown_svalue instances during feasibility\n+   checking, instead creating unique svalues, to avoid paradoxes in paths.  */\n+\n+class auto_checking_feasibility\n {\n public:\n-  auto_disable_complexity_checks (region_model_manager *mgr) : m_mgr (mgr)\n+  auto_checking_feasibility (region_model_manager *mgr) : m_mgr (mgr)\n   {\n-    m_mgr->disable_complexity_check ();\n+    m_mgr->begin_checking_feasibility ();\n   }\n-  ~auto_disable_complexity_checks ()\n+  ~auto_checking_feasibility ()\n   {\n-    m_mgr->enable_complexity_check ();\n+    m_mgr->end_checking_feasibility ();\n   }\n private:\n   region_model_manager *m_mgr;\n@@ -406,7 +409,7 @@ epath_finder::explore_feasible_paths (const exploded_node *target_enode,\n   exploded_path *best_path = NULL;\n \n   {\n-    auto_disable_complexity_checks sentinel (mgr);\n+    auto_checking_feasibility sentinel (mgr);\n \n     while (process_worklist_item (&worklist, tg, &fg, target_enode, diag_idx,\n \t\t\t\t  &best_path))"}, {"sha": "903cdfde91d6a22d232c3ac9d4a036a37bd53009", "filename": "gcc/analyzer/region-model-manager.cc", "status": "modified", "additions": 53, "deletions": 2, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f34f8cc1d064bfaaed723312c71e92f495d429b/gcc%2Fanalyzer%2Fregion-model-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f34f8cc1d064bfaaed723312c71e92f495d429b/gcc%2Fanalyzer%2Fregion-model-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model-manager.cc?ref=4f34f8cc1d064bfaaed723312c71e92f495d429b", "patch": "@@ -73,7 +73,7 @@ region_model_manager::region_model_manager (logger *logger)\n   m_stack_region (alloc_region_id (), &m_root_region),\n   m_heap_region (alloc_region_id (), &m_root_region),\n   m_unknown_NULL (NULL),\n-  m_check_complexity (true),\n+  m_checking_feasibility (false),\n   m_max_complexity (0, 0),\n   m_code_region (alloc_region_id (), &m_root_region),\n   m_fndecls_map (), m_labels_map (),\n@@ -166,7 +166,7 @@ region_model_manager::too_complex_p (const complexity &c) const\n bool\n region_model_manager::reject_if_too_complex (svalue *sval)\n {\n-  if (!m_check_complexity)\n+  if (m_checking_feasibility)\n     return false;\n \n   const complexity &c = sval->get_complexity ();\n@@ -238,6 +238,11 @@ region_model_manager::get_or_create_int_cst (tree type, poly_int64 val)\n const svalue *\n region_model_manager::get_or_create_unknown_svalue (tree type)\n {\n+  /* Don't create unknown values when doing feasibility testing;\n+     instead, create a unique svalue.  */\n+  if (m_checking_feasibility)\n+    return create_unique_svalue (type);\n+\n   /* Special-case NULL, so that the hash_map can use NULL as the\n      \"empty\" value.  */\n   if (type == NULL_TREE)\n@@ -255,6 +260,16 @@ region_model_manager::get_or_create_unknown_svalue (tree type)\n   return sval;\n }\n \n+/* Return a freshly-allocated svalue of TYPE, owned by this manager.  */\n+\n+const svalue *\n+region_model_manager::create_unique_svalue (tree type)\n+{\n+  svalue *sval = new placeholder_svalue (type, \"unique\");\n+  m_managed_dynamic_svalues.safe_push (sval);\n+  return sval;\n+}\n+\n /* Return the svalue * for the initial value of REG, creating it if\n    necessary.  */\n \n@@ -584,6 +599,42 @@ region_model_manager::maybe_fold_binop (tree type, enum tree_code op,\n \t\t\t\t\t\t\t cst1, arg1))\n \t      return sval;\n \t}\n+      if (arg0->get_type () == boolean_type_node\n+\t  && arg1->get_type () == boolean_type_node)\n+\t{\n+\t  /* If the LHS are both _Bool, then... */\n+\t  /* ...\"(1 & x) -> x\".  */\n+\t  if (cst0 && !zerop (cst0))\n+\t    return get_or_create_cast (type, arg1);\n+\t  /* ...\"(x & 1) -> x\".  */\n+\t  if (cst1 && !zerop (cst1))\n+\t    return get_or_create_cast (type, arg0);\n+\t  /* ...\"(0 & x) -> 0\".  */\n+\t  if (cst0 && zerop (cst0))\n+\t    return get_or_create_int_cst (type, 0);\n+\t  /* ...\"(x & 0) -> 0\".  */\n+\t  if (cst1 && zerop (cst1))\n+\t    return get_or_create_int_cst (type, 0);\n+\t}\n+      break;\n+    case BIT_IOR_EXPR:\n+      if (arg0->get_type () == boolean_type_node\n+\t  && arg1->get_type () == boolean_type_node)\n+\t{\n+\t  /* If the LHS are both _Bool, then... */\n+\t  /* ...\"(1 | x) -> 1\".  */\n+\t  if (cst0 && !zerop (cst0))\n+\t    return get_or_create_int_cst (type, 1);\n+\t  /* ...\"(x | 1) -> 1\".  */\n+\t  if (cst1 && !zerop (cst1))\n+\t    return get_or_create_int_cst (type, 1);\n+\t  /* ...\"(0 | x) -> x\".  */\n+\t  if (cst0 && zerop (cst0))\n+\t    return get_or_create_cast (type, arg1);\n+\t  /* ...\"(x | 0) -> x\".  */\n+\t  if (cst1 && zerop (cst1))\n+\t    return get_or_create_cast (type, arg0);\n+\t}\n       break;\n     case TRUTH_ANDIF_EXPR:\n     case TRUTH_AND_EXPR:"}, {"sha": "b58d0894d4aa4b26e559899477ae739f9508aadd", "filename": "gcc/analyzer/region-model.cc", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f34f8cc1d064bfaaed723312c71e92f495d429b/gcc%2Fanalyzer%2Fregion-model.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f34f8cc1d064bfaaed723312c71e92f495d429b/gcc%2Fanalyzer%2Fregion-model.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.cc?ref=4f34f8cc1d064bfaaed723312c71e92f495d429b", "patch": "@@ -4555,6 +4555,39 @@ test_binop_svalue_folding ()\n     = mgr.get_or_create_binop (integer_type_node, PLUS_EXPR,\n \t\t\t       x_init_plus_one, cst_sval[1]);\n   ASSERT_EQ (x_init_plus_one_plus_one, x_init_plus_two);\n+\n+  /* Verify various binops on booleans.  */\n+  {\n+    const svalue *sval_true = mgr.get_or_create_int_cst (boolean_type_node, 1);\n+    const svalue *sval_false = mgr.get_or_create_int_cst (boolean_type_node, 0);\n+    const svalue *sval_unknown\n+      = mgr.get_or_create_unknown_svalue (boolean_type_node);\n+    const placeholder_svalue sval_placeholder (boolean_type_node, \"v\");\n+    for (auto op : {BIT_IOR_EXPR, TRUTH_OR_EXPR})\n+      {\n+\tASSERT_EQ (mgr.get_or_create_binop (boolean_type_node, op,\n+\t\t\t\t\t    sval_true, sval_unknown),\n+\t\t   sval_true);\n+\tASSERT_EQ (mgr.get_or_create_binop (boolean_type_node, op,\n+\t\t\t\t\t    sval_false, sval_unknown),\n+\t\t   sval_unknown);\n+\tASSERT_EQ (mgr.get_or_create_binop (boolean_type_node, op,\n+\t\t\t\t\t    sval_false, &sval_placeholder),\n+\t\t   &sval_placeholder);\n+      }\n+    for (auto op : {BIT_AND_EXPR, TRUTH_AND_EXPR})\n+      {\n+\tASSERT_EQ (mgr.get_or_create_binop (boolean_type_node, op,\n+\t\t\t\t\t    sval_false, sval_unknown),\n+\t\t   sval_false);\n+\tASSERT_EQ (mgr.get_or_create_binop (boolean_type_node, op,\n+\t\t\t\t\t    sval_true, sval_unknown),\n+\t\t   sval_unknown);\n+\tASSERT_EQ (mgr.get_or_create_binop (boolean_type_node, op,\n+\t\t\t\t\t    sval_true, &sval_placeholder),\n+\t\t   &sval_placeholder);\n+      }\n+  }\n }\n \n /* Verify that sub_svalues are folded as expected.  */"}, {"sha": "c78efe8f21511f693886e02c3ab026dbbf62eb11", "filename": "gcc/analyzer/region-model.h", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f34f8cc1d064bfaaed723312c71e92f495d429b/gcc%2Fanalyzer%2Fregion-model.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f34f8cc1d064bfaaed723312c71e92f495d429b/gcc%2Fanalyzer%2Fregion-model.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.h?ref=4f34f8cc1d064bfaaed723312c71e92f495d429b", "patch": "@@ -286,6 +286,11 @@ class region_model_manager\n   const svalue *maybe_get_char_from_string_cst (tree string_cst,\n \t\t\t\t\t\ttree byte_offset_cst);\n \n+  /* Dynamically-allocated svalue instances.\n+     The number of these within the analysis can grow arbitrarily.\n+     They are still owned by the manager.  */\n+  const svalue *create_unique_svalue (tree type);\n+\n   /* region consolidation.  */\n   const stack_region * get_stack_region () const { return &m_stack_region; }\n   const heap_region *get_heap_region () const { return &m_heap_region; }\n@@ -332,8 +337,8 @@ class region_model_manager\n \n   void log_stats (logger *logger, bool show_objs) const;\n \n-  void enable_complexity_check (void) { m_check_complexity = true; }\n-  void disable_complexity_check (void) { m_check_complexity = false; }\n+  void begin_checking_feasibility (void) { m_checking_feasibility = true; }\n+  void end_checking_feasibility (void) { m_checking_feasibility = false; }\n \n   logger *get_logger () const { return m_logger; }\n \n@@ -429,7 +434,12 @@ class region_model_manager\n \t\t   asm_output_svalue *> asm_output_values_map_t;\n   asm_output_values_map_t m_asm_output_values_map;\n \n-  bool m_check_complexity;\n+  bool m_checking_feasibility;\n+\n+  /* \"Dynamically-allocated\" svalue instances.\n+     The number of these within the analysis can grow arbitrarily.\n+     They are still owned by the manager.  */\n+  auto_delete_vec<svalue> m_managed_dynamic_svalues;\n \n   /* Maximum complexity of svalues that weren't rejected.  */\n   complexity m_max_complexity;"}, {"sha": "c8993c829803a904bad57b8c36336eb6e83cc62b", "filename": "gcc/testsuite/gcc.dg/analyzer/pr102692.c", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f34f8cc1d064bfaaed723312c71e92f495d429b/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr102692.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f34f8cc1d064bfaaed723312c71e92f495d429b/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr102692.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr102692.c?ref=4f34f8cc1d064bfaaed723312c71e92f495d429b", "patch": "@@ -0,0 +1,110 @@\n+/* { dg-additional-options \"-O2 -Wno-analyzer-too-complex\" } */\n+/* TODO: remove the need for -Wno-analyzer-too-complex.  */\n+\n+struct lisp;\n+union vectorlike_header { long size; };\n+\n+static struct lisp *\n+make_lisp_ptr (void *ptr, int type)\n+{\n+  char *p = ptr;\n+  void *q = p + type;\n+  return q;\n+}\n+\n+static _Bool\n+TAGGEDP (struct lisp *a, unsigned tag)\n+{\n+  return ! (((unsigned) (long) a - tag) & 7);\n+}\n+\n+static _Bool\n+VECTORLIKEP (struct lisp *x)\n+{\n+  return TAGGEDP (x, 5);\n+}\n+\n+extern _Bool\n+PSEUDOVECTOR_TYPEP (union vectorlike_header const *a, int code);\n+\n+static _Bool\n+PSEUDOVECTORP (struct lisp *a, int code)\n+{\n+  if (! VECTORLIKEP (a))\n+    return 0;\n+  else\n+    return PSEUDOVECTOR_TYPEP ((union vectorlike_header *) ((char *) a - 5),\n+\t\t\t       code);\n+}\n+\n+struct Lisp_Overlay\n+{\n+  union vectorlike_header header;\n+  struct lisp *end;\n+  struct Lisp_Overlay *next;\n+};\n+\n+static _Bool\n+OVERLAYP (struct lisp *x)\n+{\n+  return PSEUDOVECTORP (x, 4);\n+}\n+\n+static struct Lisp_Overlay *\n+XOVERLAY (struct lisp *a)\n+{\n+  void *r = (char *) a - 5;\n+  return r;\n+}\n+struct buffer { struct Lisp_Overlay *overlays_before; };\n+\n+long marker_position (struct lisp *);\n+\n+void\n+fix_overlays_before (struct buffer *bp, long prev, long pos)\n+{\n+  struct Lisp_Overlay *tail = bp->overlays_before, *parent = 0, *right_pair;\n+  struct lisp *tem;\n+  long end;\n+  while (tail\n+\t && (tem = make_lisp_ptr (tail, 5),\n+\t     (end = marker_position (XOVERLAY (tem)->end)) >= pos))\n+    {\n+      parent = tail;\n+      tail = tail->next;\n+    }\n+  if (!tail || end < prev || !tail->next) /* { dg-bogus \"use of uninitialized value 'end'\" \"uninit\" { xfail *-*-* } } */\n+    /* { dg-bogus \"dereference of NULL 'tail'\" \"null deref\" { target *-*-* } .-1 } */\n+    return;\n+  right_pair = parent;\n+  parent = tail;\n+  tail = tail->next;\n+  while (tail)\n+    {\n+      tem = make_lisp_ptr (tail, 5);\n+      end = marker_position (XOVERLAY (tem)->end);\n+      if (end == pos)\n+\t{\n+\t  struct Lisp_Overlay *found = tail;\n+\t  tail = found->next;\n+\t  parent->next = tail;\n+\t  if (!right_pair)\n+\t    {\n+\t      found->next = bp->overlays_before;\n+\t      bp->overlays_before = found;\n+\t    }\n+\t  else\n+\t    {\n+\t      found->next = right_pair->next;\n+\t      right_pair->next = found;\n+\t    }\n+\t}\n+      else if (end == prev)\n+\t{\n+\t  parent = tail;\n+\t  tail = tail->next;\n+\t}\n+      else\n+\tbreak;\n+    }\n+}"}]}