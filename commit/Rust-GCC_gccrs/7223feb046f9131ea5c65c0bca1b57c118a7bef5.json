{"sha": "7223feb046f9131ea5c65c0bca1b57c118a7bef5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzIyM2ZlYjA0NmY5MTMxZWE1YzY1YzBiY2ExYjU3YzExOGE3YmVmNQ==", "commit": {"author": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1993-09-05T22:20:29Z"}, "committer": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1993-09-05T22:20:29Z"}, "message": "collect2.c (our_file_name, [...]): deleted.\n\n        * collect2.c (our_file_name, last_file_name): deleted.\n        (our_file_names): New variable.\n        (is_in_prefix_list): New function.\n        (find_a_file): Call is_in_prefix_list.\n        (main): Make COLLECT_NAMES a list of our invocations.\n        If we've invoked ourselves, try again with ld_file_name.\n\nFrom-SVN: r5262", "tree": {"sha": "a90ce86b78c24a69f8877a9fcb4bff36d69b1f15", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a90ce86b78c24a69f8877a9fcb4bff36d69b1f15"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7223feb046f9131ea5c65c0bca1b57c118a7bef5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7223feb046f9131ea5c65c0bca1b57c118a7bef5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7223feb046f9131ea5c65c0bca1b57c118a7bef5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7223feb046f9131ea5c65c0bca1b57c118a7bef5/comments", "author": null, "committer": null, "parents": [{"sha": "cb61f66f5bc01f6728773ac38dbb36f5110a53d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb61f66f5bc01f6728773ac38dbb36f5110a53d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb61f66f5bc01f6728773ac38dbb36f5110a53d4"}], "stats": {"total": 86, "additions": 73, "deletions": 13}, "files": [{"sha": "c576a5d9ea55ae48a02dce372ea32d4ea0df98f2", "filename": "gcc/collect2.c", "status": "modified", "additions": 73, "deletions": 13, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7223feb046f9131ea5c65c0bca1b57c118a7bef5/gcc%2Fcollect2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7223feb046f9131ea5c65c0bca1b57c118a7bef5/gcc%2Fcollect2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcollect2.c?ref=7223feb046f9131ea5c65c0bca1b57c118a7bef5", "patch": "@@ -551,8 +551,45 @@ static char *target_machine = TARGET_MACHINE;\n /* Names under which we were executed.  Never return one of those files in our\n    searches.  */\n \n-static char *our_file_name, *last_file_name;\n+static struct path_prefix our_file_names;\n \f\n+/* Determine if STRING is in PPREFIX.\n+\n+   This utility is currently only used to look up file names.  Prefix lists\n+   record directory names.  This matters to us because the latter has a \n+   trailing slash, so I've added a flag to handle both.  */\n+\n+static int\n+is_in_prefix_list (pprefix, string, filep)\n+     struct path_prefix *pprefix;\n+     char *string;\n+     int filep;\n+{\n+  struct prefix_list *pl;\n+\n+  if (filep)\n+    {\n+      int len = strlen (string);\n+\n+      for (pl = pprefix->plist; pl; pl = pl->next)\n+\t{\n+\t  if (strncmp (pl->prefix, string, len) == 0\n+\t      && strcmp (pl->prefix + len, \"/\") == 0)\n+\t    return 1;\n+\t}\n+    }\n+  else\n+    {\n+      for (pl = pprefix->plist; pl; pl = pl->next)\n+\t{\n+\t  if (strcmp (pl->prefix, string) == 0)\n+\t    return 1;\n+\t}\n+    }\n+\n+  return 0;\n+}\n+\n /* Search for NAME using prefix list PPREFIX.  We only look for executable\n    files. \n \n@@ -588,8 +625,7 @@ find_a_file (pprefix, name)\n       {\n \tstrcpy (temp, pl->prefix);\n \tstrcat (temp, name);\n-\tif (strcmp (temp, our_file_name) != 0\n-\t    && ! (last_file_name != 0 && strcmp (temp, last_file_name) == 0)\n+\tif (! is_in_prefix_list (&our_file_names, temp, 1)\n \t    /* This is a kludge, but there seems no way around it.  */\n \t    && strcmp (temp, \"./ld\") != 0\n \t    && access (temp, X_OK) == 0)\n@@ -599,8 +635,7 @@ find_a_file (pprefix, name)\n \t/* Some systems have a suffix for executable files.\n \t   So try appending that.  */\n \tstrcat (temp, EXECUTABLE_SUFFIX);\n-\tif (strcmp (temp, our_file_name) != 0\n-\t    && ! (last_file_name != 0 && strcmp (temp, last_file_name) == 0)\n+\tif (! is_in_prefix_list (&our_file_names, temp, 1)\n \t    && access (temp, X_OK) == 0)\n \t  return temp;\n #endif\n@@ -716,6 +751,7 @@ main (argc, argv)\n   FILE *outf;\n   char *ld_file_name;\n   char *c_file_name;\n+  char *collect_names;\n   char *p;\n   char **c_argv;\n   char **c_ptr;\n@@ -733,23 +769,31 @@ main (argc, argv)\n   vflag = 1;\n #endif\n \n-  our_file_name = argv[0];\n-\n   output_file = \"a.out\";\n \n   /* We must check that we do not call ourselves in an infinite\n-     recursion loop. We save the name used for us in the COLLECT_NAME\n+     recursion loop. We save the name used for us in the COLLECT_NAMES\n      environment variable, first getting the previous value.\n \n-     To be fully safe, we need to maintain a list of names that name\n-     been used, but, in practice, two names are enough.  */\n+     In practice, collect will rarely invoke itself.  This can happen now\n+     that we are no longer called gld.  A perfect example is when running\n+     gcc in a build directory that has been installed.  When looking for \n+     ld's, we'll find our installed version and believe that's the real ld.  */\n \n-  last_file_name = getenv (\"COLLECT_NAME\");\n+  collect_names = (char *) getenv (\"COLLECT_NAMES\");\n \n-  p = (char *) xmalloc (strlen (our_file_name) + strlen (\"COLLECT_NAME=\") + 1);\n-  sprintf (p, \"COLLECT_NAME=%s\", our_file_name);\n+  p = (char *) xmalloc (strlen (\"COLLECT_NAMES=\")\n+\t\t\t+ (collect_names ? strlen (collect_names) + 1 : 0)\n+\t\t\t+ strlen (argv[0]) + 1);\n+  if (collect_names != 0)\n+    sprintf (p, \"COLLECT_NAMES=%s%c%s\",\n+\t     collect_names, PATH_SEPARATOR, argv[0]);\n+  else\n+    sprintf (p, \"COLLECT_NAMES=%s\", argv[0]);\n   putenv (p);\n \n+  prefix_from_env (\"COLLECT_NAMES\", &our_file_names);\n+\n   p = (char *) getenv (\"COLLECT_GCC_OPTIONS\");\n   if (p)\n     while (*p)\n@@ -873,6 +917,18 @@ main (argc, argv)\n   if (ld_file_name == 0)\n     ld_file_name = find_a_file (&path, full_ld_suffix);\n \n+  /* If we've invoked ourselves, try again with LD_FILE_NAME.  */\n+\n+  if (collect_names != 0)\n+    {\n+      if (ld_file_name != 0)\n+\t{\n+\t  argv[0] = ld_file_name;\n+\t  execvp (argv[0], argv);\n+\t}\n+      fatal (\"cannot find `ld'\");\n+    }\n+\n   nm_file_name = find_a_file (&cpath, gnm_suffix);\n   if (nm_file_name == 0)\n     nm_file_name = find_a_file (&path, full_gnm_suffix);\n@@ -1038,6 +1094,10 @@ main (argc, argv)\n       fprintf (stderr, \"o_file              = %s\\n\",\n \t       (o_file ? o_file : \"not found\"));\n \n+      ptr = getenv (\"COLLECT_NAMES\");\n+      if (ptr)\n+\tfprintf (stderr, \"COLLECT_NAMES       = %s\\n\", ptr);\n+\n       ptr = getenv (\"COLLECT_GCC_OPTIONS\");\n       if (ptr)\n \tfprintf (stderr, \"COLLECT_GCC_OPTIONS = %s\\n\", ptr);"}]}