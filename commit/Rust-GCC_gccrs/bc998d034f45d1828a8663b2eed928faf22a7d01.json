{"sha": "bc998d034f45d1828a8663b2eed928faf22a7d01", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmM5OThkMDM0ZjQ1ZDE4MjhhODY2M2IyZWVkOTI4ZmFmMjJhN2QwMQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2017-09-14T17:11:35Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2017-09-14T17:11:35Z"}, "message": "libgo: update to go1.9\n    \n    Reviewed-on: https://go-review.googlesource.com/63753\n\nFrom-SVN: r252767", "tree": {"sha": "8d262a22ca7318f4bcd64269fe8fe9e45bcf8d0f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8d262a22ca7318f4bcd64269fe8fe9e45bcf8d0f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bc998d034f45d1828a8663b2eed928faf22a7d01", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc998d034f45d1828a8663b2eed928faf22a7d01", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc998d034f45d1828a8663b2eed928faf22a7d01", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc998d034f45d1828a8663b2eed928faf22a7d01/comments", "author": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a41a6142df74219f596e612d3a7775f68ca6e96f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a41a6142df74219f596e612d3a7775f68ca6e96f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a41a6142df74219f596e612d3a7775f68ca6e96f"}], "stats": {"total": 77237, "additions": 56840, "deletions": 20397}, "files": [{"sha": "a1ccb2bc75ec9fb0dafcbdb93c1facdeef46b031", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -1,4 +1,4 @@\n-199f175f4239d1ca6d7e80d08639955d41c3b09f\n+4e063a8eee636cce17aea48c7183e78431174de3\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "c04f2116c5fecb418f6cec87308090c448e5f28f", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug273.go", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug273.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug273.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug273.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -1,10 +1,10 @@\n // run\n \n-// Copyright 2010 The Go Authors.  All rights reserved.\n+// Copyright 2010 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// http://code.google.com/p/go/issues/detail?id=589\n+// https://golang.org/issue/589\n \n package main\n \n@@ -48,15 +48,6 @@ func bigcap() {\n \tg1 = make([]block, 10, big)\n }\n \n-var g3 map[block]block\n-func badmapcap() {\n-\tg3 = make(map[block]block, minus1)\n-}\n-\n-func bigmapcap() {\n-\tg3 = make(map[block]block, big)\n-}\n-\n type cblock [1<<16-1]byte\n \n var g4 chan cblock\n@@ -78,8 +69,6 @@ func main() {\n \tshouldfail(badcap, \"badcap\")\n \tshouldfail(badcap1, \"badcap1\")\n \tshouldfail(bigcap, \"bigcap\")\n-\tshouldfail(badmapcap, \"badmapcap\")\n-\tshouldfail(bigmapcap, \"bigmapcap\")\n \tshouldfail(badchancap, \"badchancap\")\n \tshouldfail(bigchancap, \"bigchancap\")\n \tshouldfail(overflowchan, \"overflowchan\")"}, {"sha": "8fac16e37124493b2bdc37e3eb8c119e343437da", "filename": "gotools/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/gotools%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/gotools%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gotools%2FChangeLog?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -1,3 +1,15 @@\n+2017-09-14  Ian Lance Taylor  <iant@golang.org>\n+\n+\t* Makefile.am (LIBGOTOOL): Define.\n+\t(go_cmd_go_files): Update for Go 1.9 release.\n+\t(go$(EXEEXT)): Depend on and link against $(LIBGOTOOL).\n+\t(CHECK_ENV): Add definition of shell variable fl.\n+\t(check-go-tool): Update for rearrangement of cmd/go sources in Go\n+\t1.9 release.  Echo failure message if test fails.\n+\t(check-runtime): Echo failure message if test fails.\n+\t(check-cgo-test, check-carchive-test): Likewise.\n+\t* Makefile.in: Rebuild.\n+\n 2017-08-30  Ian Lance Taylor  <iant@golang.org>\n \n \t* configure.ac: Substitute GOC_FOR_TARGET and GCC_FOR_TARGET."}, {"sha": "4f13ffe31c3a3ec9faf623e6243b57eb52ee90b5", "filename": "gotools/Makefile.am", "status": "modified", "additions": 17, "deletions": 36, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/gotools%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/gotools%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gotools%2FMakefile.am?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -28,6 +28,8 @@ STAMP = echo timestamp >\n libgodir = ../$(target_noncanonical)/libgo\n LIBGODEP = $(libgodir)/libgo.la\n \n+LIBGOTOOL = $(libgodir)/libgotool.a\n+\n if NATIVE\n # Use the compiler we just built.\n GOCOMPILER = $(GOC_FOR_TARGET) $(XGCC_FLAGS_FOR_TARGET)\n@@ -48,34 +50,8 @@ libgomiscdir = $(srcdir)/../libgo/misc\n \n go_cmd_go_files = \\\n \t$(cmdsrcdir)/go/alldocs.go \\\n-\t$(cmdsrcdir)/go/bug.go \\\n-\t$(cmdsrcdir)/go/build.go \\\n-\t$(cmdsrcdir)/go/clean.go \\\n-\t$(cmdsrcdir)/go/context.go \\\n-\t$(cmdsrcdir)/go/discovery.go \\\n-\t$(cmdsrcdir)/go/doc.go \\\n-\t$(cmdsrcdir)/go/env.go \\\n-\t$(cmdsrcdir)/go/fix.go \\\n-\t$(cmdsrcdir)/go/fmt.go \\\n-\t$(cmdsrcdir)/go/generate.go \\\n-\t$(cmdsrcdir)/go/get.go \\\n \t$(cmdsrcdir)/go/go11.go \\\n-\t$(cmdsrcdir)/go/help.go \\\n-\t$(cmdsrcdir)/go/http.go \\\n-\t$(cmdsrcdir)/go/list.go \\\n-\t$(cmdsrcdir)/go/main.go \\\n-\t$(cmdsrcdir)/go/note.go \\\n-\t$(cmdsrcdir)/go/pkg.go \\\n-\t$(cmdsrcdir)/go/run.go \\\n-\t$(cmdsrcdir)/go/signal.go \\\n-\t$(cmdsrcdir)/go/signal_unix.go \\\n-\t$(cmdsrcdir)/go/test.go \\\n-\t$(cmdsrcdir)/go/testflag.go \\\n-\t$(cmdsrcdir)/go/tool.go \\\n-\t$(cmdsrcdir)/go/vcs.go \\\n-\t$(cmdsrcdir)/go/version.go \\\n-\t$(cmdsrcdir)/go/vet.go \\\n-\t$(libgodir)/zstdpkglist.go\n+\t$(cmdsrcdir)/go/main.go\n \n go_cmd_gofmt_files = \\\n \t$(cmdsrcdir)/gofmt/doc.go \\\n@@ -124,8 +100,8 @@ bin_PROGRAMS = go$(EXEEXT) gofmt$(EXEEXT)\n noinst_PROGRAMS = cgo$(EXEEXT)\n man_MANS = go.1 gofmt.1\n \n-go$(EXEEXT): $(go_cmd_go_files) zdefaultcc.go $(LIBGODEP)\n-\t$(GOLINK) $(go_cmd_go_files) zdefaultcc.go $(LIBS) $(NET_LIBS)\n+go$(EXEEXT): $(go_cmd_go_files) $(LIBGOTOOL) $(LIBGODEP)\n+\t$(GOLINK) $(go_cmd_go_files) $(LIBGOTOOL) $(LIBS) $(NET_LIBS)\n gofmt$(EXEEXT): $(go_cmd_gofmt_files) $(LIBGODEP)\n \t$(GOLINK) $(go_cmd_gofmt_files) $(LIBS) $(NET_LIBS)\n cgo$(EXEEXT): $(go_cmd_cgo_files) zdefaultcc.go $(LIBGODEP)\n@@ -175,6 +151,8 @@ check-gcc: Makefile\n \n # CHECK_ENV sets up the environment to run the newly built go tool.\n # If you change this, change ECHO_ENV, below.\n+# The fl shell variable is used to avoid having FAIL appear\n+# in the log unnecessarily.\n CHECK_ENV = \\\n \tPATH=`echo $(abs_builddir):$${PATH} | sed 's,::*,:,g;s,^:*,,;s,:*$$,,'`; \\\n \texport PATH; \\\n@@ -190,7 +168,8 @@ CHECK_ENV = \\\n \tLD_LIBRARY_PATH=`echo $${abs_libgodir}/.libs:$${LD_LIBRARY_PATH} | sed 's,::*,:,g;s,^:*,,;s,:*$$,,'`; \\\n \texport LD_LIBRARY_PATH; \\\n \tGOROOT=$${abs_libgodir}; \\\n-\texport GOROOT;\n+\texport GOROOT; \\\n+\tfl1=\"FA\"; fl2=\"IL\"; fl=\"$${fl1}$${fl2}\";\n \n # ECHO_ENV is a variant of CHECK_ENV to put into a testlog file.\n # It assumes that abs_libgodir is set.\n@@ -201,16 +180,18 @@ check-go-tool: go$(EXEEXT) cgo$(EXEEXT) check-head check-gccgo check-gcc\n \trm -rf check-go-dir cmd_go-testlog\n \t$(MKDIR_P) check-go-dir/src/cmd/go\n \tcp $(cmdsrcdir)/go/*.go check-go-dir/src/cmd/go/\n-\tcp $(libgodir)/zstdpkglist.go check-go-dir/src/cmd/go/\n-\tcp zdefaultcc.go check-go-dir/src/cmd/go/\n+\tcp -r $(cmdsrcdir)/go/internal check-go-dir/src/cmd/go/\n+\tcp $(libgodir)/zstdpkglist.go check-go-dir/src/cmd/go/internal/load/\n+\tcp $(libgodir)/zdefaultcc.go check-go-dir/src/cmd/go/internal/cfg/\n \tcp -r $(cmdsrcdir)/go/testdata check-go-dir/src/cmd/go/\n+\tcp -r $(cmdsrcdir)/internal check-go-dir/src/cmd/\n \t@abs_libgodir=`cd $(libgodir) && $(PWD_COMMAND)`; \\\n \tabs_checkdir=`cd check-go-dir && $(PWD_COMMAND)`; \\\n \techo \"cd check-go-dir/src/cmd/go && $(ECHO_ENV) GOPATH=$${abs_checkdir} $(abs_builddir)/go$(EXEEXT) test -test.short -test.v\" > cmd_go-testlog\n \t$(CHECK_ENV) \\\n \tGOPATH=`cd check-go-dir && $(PWD_COMMAND)`; \\\n \texport GOPATH; \\\n-\t(cd check-go-dir/src/cmd/go && $(abs_builddir)/go$(EXEEXT) test -test.short -test.v) > cmd_go-testlog 2>&1 || true\n+\t(cd check-go-dir/src/cmd/go && $(abs_builddir)/go$(EXEEXT) test -test.short -test.v) >> cmd_go-testlog 2>&1 || echo \"--- $${fl} go test cmd/go (0.00s)\" >> cmd_go-testlog\n \tgrep '^--- ' cmd_go-testlog | sed -e 's/^--- \\(.*\\) ([^)]*)$$/\\1/'\n \n # check-runtime runs `go test runtime` in our environment.\n@@ -232,7 +213,7 @@ check-runtime: go$(EXEEXT) cgo$(EXEEXT) check-head check-gccgo check-gcc\n \tGOARCH=`$(abs_builddir)/go$(EXEEXT) env GOARCH`; \\\n \tGOOS=`$(abs_builddir)/go$(EXEEXT) env GOOS`; \\\n \tfiles=`$(SHELL) $(libgosrcdir)/../match.sh --goarch=$${GOARCH} --goos=$${GOOS} --srcdir=$(libgosrcdir)/runtime --extrafiles=\"$(libgodir)/runtime_sysinfo.go $(libgodir)/sigtab.go\" --tag=libffi`; \\\n-\t$(SHELL) $(libgosrcdir)/../testsuite/gotest --goarch=$${GOARCH} --goos=$${GOOS} --basedir=$(libgosrcdir)/.. --srcdir=$(libgosrcdir)/runtime --pkgpath=runtime --pkgfiles=\"$${files}\" -test.v >> runtime-testlog 2>&1 || true\n+\t$(SHELL) $(libgosrcdir)/../testsuite/gotest --goarch=$${GOARCH} --goos=$${GOOS} --basedir=$(libgosrcdir)/.. --srcdir=$(libgosrcdir)/runtime --pkgpath=runtime --pkgfiles=\"$${files}\" -test.v >> runtime-testlog 2>&1 || echo \"--- $${fl} go test runtime (0.00s)\" >> runtime-testlog\n \tgrep '^--- ' runtime-testlog | sed -e 's/^--- \\(.*\\) ([^)]*)$$/\\1/'\n \n # check-cgo-test runs `go test misc/cgo/test` in our environment.\n@@ -245,7 +226,7 @@ check-cgo-test: go$(EXEEXT) cgo$(EXEEXT) check-head check-gccgo check-gcc\n \t$(CHECK_ENV) \\\n \tGOTRACEBACK=2; \\\n \texport GOTRACEBACK; \\\n-\t(cd cgo-test-dir/misc/cgo/test && $(abs_builddir)/go$(EXEEXT) test -test.short -test.v) >> cgo-testlog 2>&1 || true\n+\t(cd cgo-test-dir/misc/cgo/test && $(abs_builddir)/go$(EXEEXT) test -test.short -test.v) >> cgo-testlog 2>&1 || echo \"--- $${fl} go test misc/cgo/test (0.00s)\" >> cgo-testlog\n \tgrep '^--- ' cgo-testlog | sed -e 's/^--- \\(.*\\) ([^)]*)$$/\\1/'\n \n # check-carchive-test runs `go test misc/cgo/testcarchive/carchive_test.go`\n@@ -259,7 +240,7 @@ check-carchive-test: go$(EXEEXT) cgo$(EXEEXT) check-head check-gccgo check-gcc\n \t$(CHECK_ENV) \\\n \tLIBRARY_PATH=`echo $${abs_libgodir}/.libs:$${LIBRARY_PATH} | sed 's,::*,:,g;s,^:*,,;s,:*$$,,'`; \\\n \texport LIBRARY_PATH; \\\n-\t(cd carchive-test-dir/misc/cgo/testcarchive && $(abs_builddir)/go$(EXEEXT) test -test.v carchive_test.go) >> carchive-testlog 2>&1 || true\n+\t(cd carchive-test-dir/misc/cgo/testcarchive && $(abs_builddir)/go$(EXEEXT) test -test.v carchive_test.go) >> carchive-testlog 2>&1 || echo \"--- $${fl} go test misc/cgo/testcarchive (0.00s)\" >> carchive-testlog\n \tgrep '^--- ' carchive-testlog | sed -e 's/^--- \\(.*\\) ([^)]*)$$/\\1/'\n \n # The check targets runs the tests and assembles the output files."}, {"sha": "b9734f151cced287c4106fcb05b1c4cc6301657d", "filename": "gotools/Makefile.in", "status": "modified", "additions": 17, "deletions": 37, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/gotools%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/gotools%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gotools%2FMakefile.in?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -255,6 +255,7 @@ PWD_COMMAND = $${PWDCMD-pwd}\n STAMP = echo timestamp >\n libgodir = ../$(target_noncanonical)/libgo\n LIBGODEP = $(libgodir)/libgo.la\n+LIBGOTOOL = $(libgodir)/libgotool.a\n @NATIVE_FALSE@GOCOMPILER = $(GOC)\n \n # Use the compiler we just built.\n@@ -268,34 +269,8 @@ cmdsrcdir = $(libgosrcdir)/cmd\n libgomiscdir = $(srcdir)/../libgo/misc\n go_cmd_go_files = \\\n \t$(cmdsrcdir)/go/alldocs.go \\\n-\t$(cmdsrcdir)/go/bug.go \\\n-\t$(cmdsrcdir)/go/build.go \\\n-\t$(cmdsrcdir)/go/clean.go \\\n-\t$(cmdsrcdir)/go/context.go \\\n-\t$(cmdsrcdir)/go/discovery.go \\\n-\t$(cmdsrcdir)/go/doc.go \\\n-\t$(cmdsrcdir)/go/env.go \\\n-\t$(cmdsrcdir)/go/fix.go \\\n-\t$(cmdsrcdir)/go/fmt.go \\\n-\t$(cmdsrcdir)/go/generate.go \\\n-\t$(cmdsrcdir)/go/get.go \\\n \t$(cmdsrcdir)/go/go11.go \\\n-\t$(cmdsrcdir)/go/help.go \\\n-\t$(cmdsrcdir)/go/http.go \\\n-\t$(cmdsrcdir)/go/list.go \\\n-\t$(cmdsrcdir)/go/main.go \\\n-\t$(cmdsrcdir)/go/note.go \\\n-\t$(cmdsrcdir)/go/pkg.go \\\n-\t$(cmdsrcdir)/go/run.go \\\n-\t$(cmdsrcdir)/go/signal.go \\\n-\t$(cmdsrcdir)/go/signal_unix.go \\\n-\t$(cmdsrcdir)/go/test.go \\\n-\t$(cmdsrcdir)/go/testflag.go \\\n-\t$(cmdsrcdir)/go/tool.go \\\n-\t$(cmdsrcdir)/go/vcs.go \\\n-\t$(cmdsrcdir)/go/version.go \\\n-\t$(cmdsrcdir)/go/vet.go \\\n-\t$(libgodir)/zstdpkglist.go\n+\t$(cmdsrcdir)/go/main.go\n \n go_cmd_gofmt_files = \\\n \t$(cmdsrcdir)/gofmt/doc.go \\\n@@ -330,6 +305,8 @@ MOSTLYCLEANFILES = \\\n \n # CHECK_ENV sets up the environment to run the newly built go tool.\n # If you change this, change ECHO_ENV, below.\n+# The fl shell variable is used to avoid having FAIL appear\n+# in the log unnecessarily.\n @NATIVE_TRUE@CHECK_ENV = \\\n @NATIVE_TRUE@\tPATH=`echo $(abs_builddir):$${PATH} | sed 's,::*,:,g;s,^:*,,;s,:*$$,,'`; \\\n @NATIVE_TRUE@\texport PATH; \\\n@@ -345,7 +322,8 @@ MOSTLYCLEANFILES = \\\n @NATIVE_TRUE@\tLD_LIBRARY_PATH=`echo $${abs_libgodir}/.libs:$${LD_LIBRARY_PATH} | sed 's,::*,:,g;s,^:*,,;s,:*$$,,'`; \\\n @NATIVE_TRUE@\texport LD_LIBRARY_PATH; \\\n @NATIVE_TRUE@\tGOROOT=$${abs_libgodir}; \\\n-@NATIVE_TRUE@\texport GOROOT;\n+@NATIVE_TRUE@\texport GOROOT; \\\n+@NATIVE_TRUE@\tfl1=\"FA\"; fl2=\"IL\"; fl=\"$${fl1}$${fl2}\";\n \n \n # ECHO_ENV is a variant of CHECK_ENV to put into a testlog file.\n@@ -598,8 +576,8 @@ distclean-generic:\n maintainer-clean-generic:\n \t@echo \"This command is intended for maintainers to use\"\n \t@echo \"it deletes files that may require special tools to rebuild.\"\n-@NATIVE_FALSE@uninstall-local:\n @NATIVE_FALSE@install-exec-local:\n+@NATIVE_FALSE@uninstall-local:\n clean: clean-am\n \n clean-am: clean-binPROGRAMS clean-generic clean-noinstPROGRAMS \\\n@@ -707,8 +685,8 @@ s-zdefaultcc: Makefile\n mostlyclean-local:\n \trm -rf check-go-dir check-runtime-dir cgo-test-dir carchive-test-dir\n \n-@NATIVE_TRUE@go$(EXEEXT): $(go_cmd_go_files) zdefaultcc.go $(LIBGODEP)\n-@NATIVE_TRUE@\t$(GOLINK) $(go_cmd_go_files) zdefaultcc.go $(LIBS) $(NET_LIBS)\n+@NATIVE_TRUE@go$(EXEEXT): $(go_cmd_go_files) $(LIBGOTOOL) $(LIBGODEP)\n+@NATIVE_TRUE@\t$(GOLINK) $(go_cmd_go_files) $(LIBGOTOOL) $(LIBS) $(NET_LIBS)\n @NATIVE_TRUE@gofmt$(EXEEXT): $(go_cmd_gofmt_files) $(LIBGODEP)\n @NATIVE_TRUE@\t$(GOLINK) $(go_cmd_gofmt_files) $(LIBS) $(NET_LIBS)\n @NATIVE_TRUE@cgo$(EXEEXT): $(go_cmd_cgo_files) zdefaultcc.go $(LIBGODEP)\n@@ -761,16 +739,18 @@ mostlyclean-local:\n @NATIVE_TRUE@\trm -rf check-go-dir cmd_go-testlog\n @NATIVE_TRUE@\t$(MKDIR_P) check-go-dir/src/cmd/go\n @NATIVE_TRUE@\tcp $(cmdsrcdir)/go/*.go check-go-dir/src/cmd/go/\n-@NATIVE_TRUE@\tcp $(libgodir)/zstdpkglist.go check-go-dir/src/cmd/go/\n-@NATIVE_TRUE@\tcp zdefaultcc.go check-go-dir/src/cmd/go/\n+@NATIVE_TRUE@\tcp -r $(cmdsrcdir)/go/internal check-go-dir/src/cmd/go/\n+@NATIVE_TRUE@\tcp $(libgodir)/zstdpkglist.go check-go-dir/src/cmd/go/internal/load/\n+@NATIVE_TRUE@\tcp $(libgodir)/zdefaultcc.go check-go-dir/src/cmd/go/internal/cfg/\n @NATIVE_TRUE@\tcp -r $(cmdsrcdir)/go/testdata check-go-dir/src/cmd/go/\n+@NATIVE_TRUE@\tcp -r $(cmdsrcdir)/internal check-go-dir/src/cmd/\n @NATIVE_TRUE@\t@abs_libgodir=`cd $(libgodir) && $(PWD_COMMAND)`; \\\n @NATIVE_TRUE@\tabs_checkdir=`cd check-go-dir && $(PWD_COMMAND)`; \\\n @NATIVE_TRUE@\techo \"cd check-go-dir/src/cmd/go && $(ECHO_ENV) GOPATH=$${abs_checkdir} $(abs_builddir)/go$(EXEEXT) test -test.short -test.v\" > cmd_go-testlog\n @NATIVE_TRUE@\t$(CHECK_ENV) \\\n @NATIVE_TRUE@\tGOPATH=`cd check-go-dir && $(PWD_COMMAND)`; \\\n @NATIVE_TRUE@\texport GOPATH; \\\n-@NATIVE_TRUE@\t(cd check-go-dir/src/cmd/go && $(abs_builddir)/go$(EXEEXT) test -test.short -test.v) > cmd_go-testlog 2>&1 || true\n+@NATIVE_TRUE@\t(cd check-go-dir/src/cmd/go && $(abs_builddir)/go$(EXEEXT) test -test.short -test.v) >> cmd_go-testlog 2>&1 || echo \"--- $${fl} go test cmd/go (0.00s)\" >> cmd_go-testlog\n @NATIVE_TRUE@\tgrep '^--- ' cmd_go-testlog | sed -e 's/^--- \\(.*\\) ([^)]*)$$/\\1/'\n \n # check-runtime runs `go test runtime` in our environment.\n@@ -792,7 +772,7 @@ mostlyclean-local:\n @NATIVE_TRUE@\tGOARCH=`$(abs_builddir)/go$(EXEEXT) env GOARCH`; \\\n @NATIVE_TRUE@\tGOOS=`$(abs_builddir)/go$(EXEEXT) env GOOS`; \\\n @NATIVE_TRUE@\tfiles=`$(SHELL) $(libgosrcdir)/../match.sh --goarch=$${GOARCH} --goos=$${GOOS} --srcdir=$(libgosrcdir)/runtime --extrafiles=\"$(libgodir)/runtime_sysinfo.go $(libgodir)/sigtab.go\" --tag=libffi`; \\\n-@NATIVE_TRUE@\t$(SHELL) $(libgosrcdir)/../testsuite/gotest --goarch=$${GOARCH} --goos=$${GOOS} --basedir=$(libgosrcdir)/.. --srcdir=$(libgosrcdir)/runtime --pkgpath=runtime --pkgfiles=\"$${files}\" -test.v >> runtime-testlog 2>&1 || true\n+@NATIVE_TRUE@\t$(SHELL) $(libgosrcdir)/../testsuite/gotest --goarch=$${GOARCH} --goos=$${GOOS} --basedir=$(libgosrcdir)/.. --srcdir=$(libgosrcdir)/runtime --pkgpath=runtime --pkgfiles=\"$${files}\" -test.v >> runtime-testlog 2>&1 || echo \"--- $${fl} go test runtime (0.00s)\" >> runtime-testlog\n @NATIVE_TRUE@\tgrep '^--- ' runtime-testlog | sed -e 's/^--- \\(.*\\) ([^)]*)$$/\\1/'\n \n # check-cgo-test runs `go test misc/cgo/test` in our environment.\n@@ -805,7 +785,7 @@ mostlyclean-local:\n @NATIVE_TRUE@\t$(CHECK_ENV) \\\n @NATIVE_TRUE@\tGOTRACEBACK=2; \\\n @NATIVE_TRUE@\texport GOTRACEBACK; \\\n-@NATIVE_TRUE@\t(cd cgo-test-dir/misc/cgo/test && $(abs_builddir)/go$(EXEEXT) test -test.short -test.v) >> cgo-testlog 2>&1 || true\n+@NATIVE_TRUE@\t(cd cgo-test-dir/misc/cgo/test && $(abs_builddir)/go$(EXEEXT) test -test.short -test.v) >> cgo-testlog 2>&1 || echo \"--- $${fl} go test misc/cgo/test (0.00s)\" >> cgo-testlog\n @NATIVE_TRUE@\tgrep '^--- ' cgo-testlog | sed -e 's/^--- \\(.*\\) ([^)]*)$$/\\1/'\n \n # check-carchive-test runs `go test misc/cgo/testcarchive/carchive_test.go`\n@@ -819,7 +799,7 @@ mostlyclean-local:\n @NATIVE_TRUE@\t$(CHECK_ENV) \\\n @NATIVE_TRUE@\tLIBRARY_PATH=`echo $${abs_libgodir}/.libs:$${LIBRARY_PATH} | sed 's,::*,:,g;s,^:*,,;s,:*$$,,'`; \\\n @NATIVE_TRUE@\texport LIBRARY_PATH; \\\n-@NATIVE_TRUE@\t(cd carchive-test-dir/misc/cgo/testcarchive && $(abs_builddir)/go$(EXEEXT) test -test.v carchive_test.go) >> carchive-testlog 2>&1 || true\n+@NATIVE_TRUE@\t(cd carchive-test-dir/misc/cgo/testcarchive && $(abs_builddir)/go$(EXEEXT) test -test.v carchive_test.go) >> carchive-testlog 2>&1 || echo \"--- $${fl} go test misc/cgo/testcarchive (0.00s)\" >> carchive-testlog\n @NATIVE_TRUE@\tgrep '^--- ' carchive-testlog | sed -e 's/^--- \\(.*\\) ([^)]*)$$/\\1/'\n \n # The check targets runs the tests and assembles the output files."}, {"sha": "85703d6ec4fd482f7e2e52059b0eff0961ebe777", "filename": "libgo/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMERGE?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -1,4 +1,4 @@\n-352996a381701cfa0c16e8de29cbde8f3922182f\n+c8aec4095e089ff6ac50d18e97c3f46561f14f48\n \n The first line of this file holds the git revision number of the\n last merge done from the master library sources."}, {"sha": "23761302f47ee0c4bdea69b85fda6afe91b9a16b", "filename": "libgo/Makefile.am", "status": "modified", "additions": 84, "deletions": 10, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.am?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -117,6 +117,8 @@ toolexeclib_LTLIBRARIES = libgo.la\n toolexeclib_LIBRARIES = libgobegin.a libgolibbegin.a\n endif\n \n+noinst_LIBRARIES = libgotool.a\n+\n toolexeclibgo_DATA = \\\n \tbufio.gox \\\n \tbytes.gox \\\n@@ -299,6 +301,7 @@ toolexeclibgomathdir = $(toolexeclibgodir)/math\n \n toolexeclibgomath_DATA = \\\n \tmath/big.gox \\\n+\tmath/bits.gox \\\n \tmath/cmplx.gox \\\n \tmath/rand.gox\n \n@@ -534,6 +537,21 @@ s-sigtab: $(srcdir)/mksigtab.sh gen-sysinfo.go\n \t$(SHELL) $(srcdir)/mvifdiff.sh tmp-sigtab.go sigtab.go\n \t$(STAMP) $@\n \n+GCCGO_INSTALL_NAME := $(shell echo gccgo|sed '$(program_transform_name)')\n+GCC_INSTALL_NAME := $(shell echo gcc|sed '$(program_transform_name)')\n+GXX_INSTALL_NAME := $(shell echo g++|sed '$(program_transform_name)')\n+\n+zdefaultcc.go: s-zdefaultcc; @true\n+s-zdefaultcc: Makefile\n+\techo 'package cfg' > zdefaultcc.go.tmp\n+\techo >> zdefaultcc.go.tmp\n+\techo 'const DefaultGCCGO = \"$(bindir)/$(GCCGO_INSTALL_NAME)\"' >> zdefaultcc.go.tmp\n+\techo 'const DefaultCC = \"$(GCC_INSTALL_NAME)\"' >> zdefaultcc.go.tmp\n+\techo 'const DefaultCXX = \"$(GXX_INSTALL_NAME)\"' >> zdefaultcc.go.tmp\n+\techo 'const DefaultPkgConfig = \"pkg-config\"' >> zdefaultcc.go.tmp\n+\t$(SHELL) $(srcdir)/../move-if-change zdefaultcc.go.tmp zdefaultcc.go\n+\t$(STAMP) $@ \n+\n # _Complex_lock and _Reader_lock are Go translations of some AIX system\n # types and should not be exported back to C\n # semt is a Go translation of the C type sem_t; it fails to convert on\n@@ -555,13 +573,13 @@ s-runtime-inc: runtime.lo Makefile\n \trm -f runtime.inc.tmp2 runtime.inc.tmp3\n \t$(STAMP) $@\n \n-noinst_DATA = zstdpkglist.go\n+noinst_DATA = zstdpkglist.go zdefaultcc.go\n \n # Generate the list of go std packages that were included in libgo\n zstdpkglist.go: s-zstdpkglist; @true\n s-zstdpkglist: Makefile\n \trm -f zstdpkglist.go.tmp\n-\techo 'package main' > zstdpkglist.go.tmp\n+\techo 'package load' > zstdpkglist.go.tmp\n \techo \"\" >> zstdpkglist.go.tmp\n \techo 'var stdpkg = map[string]bool{' >> zstdpkglist.go.tmp\n \techo $(libgo_go_objs) 'unsafe.lo' 'runtime/cgo.lo' | sed 's|[a-z0-9_/]*_c\\.lo||g' | sed 's|\\([a-z0-9_/]*\\)\\.lo|\"\\1\": true,|g' >> zstdpkglist.go.tmp\n@@ -660,7 +678,6 @@ PACKAGES = \\\n \tarchive/zip \\\n \tbufio \\\n \tbytes \\\n-\tcmd/internal/browser \\\n \tcompress/bzip2 \\\n \tcompress/flate \\\n \tcompress/gzip \\\n@@ -724,6 +741,7 @@ PACKAGES = \\\n \tgo/importer \\\n \tgo/internal/gccgoimporter \\\n \tgo/internal/gcimporter \\\n+\tgo/internal/srcimporter \\\n \tgo/parser \\\n \tgo/printer \\\n \tgo/scanner \\\n@@ -736,7 +754,10 @@ PACKAGES = \\\n \tgolang_org/x/net/http2/hpack \\\n \tgolang_org/x/net/idna \\\n \tgolang_org/x/net/lex/httplex \\\n+\tgolang_org/x/net/proxy \\\n+\tgolang_org/x/text/secure/bidirule \\\n \tgolang_org/x/text/transform \\\n+\tgolang_org/x/text/unicode/bidi \\\n \tgolang_org/x/text/unicode/norm \\\n \tgolang_org/x/text/width \\\n \thash \\\n@@ -756,7 +777,7 @@ PACKAGES = \\\n \timage/png \\\n \tindex/suffixarray \\\n \tinternal/nettrace \\\n-\tinternal/pprof/profile \\\n+\tinternal/poll \\\n \tinternal/race \\\n \tinternal/singleflight \\\n \tinternal/syscall/unix \\\n@@ -768,6 +789,7 @@ PACKAGES = \\\n \tlog/syslog \\\n \tmath \\\n \tmath/big \\\n+\tmath/bits \\\n \tmath/cmplx \\\n \tmath/rand \\\n \tmime \\\n@@ -804,7 +826,7 @@ PACKAGES = \\\n \truntime/internal/atomic \\\n \truntime/internal/sys \\\n \truntime/pprof \\\n-\truntime/pprof/internal/protopprof \\\n+\truntime/pprof/internal/profile \\\n \truntime/trace \\\n \tsort \\\n \tstrconv \\\n@@ -871,6 +893,37 @@ libgolibbegin_a_SOURCES = \\\n \n libgolibbegin_a_CFLAGS = $(AM_CFLAGS) -fPIC\n \n+GOTOOL_PACKAGES = \\\n+\tcmd/go/internal/base \\\n+\tcmd/go/internal/bug \\\n+\tcmd/go/internal/buildid \\\n+\tcmd/go/internal/cfg \\\n+\tcmd/go/internal/clean \\\n+\tcmd/go/internal/cmdflag \\\n+\tcmd/go/internal/doc \\\n+\tcmd/go/internal/envcmd \\\n+\tcmd/go/internal/fix \\\n+\tcmd/go/internal/fmtcmd \\\n+\tcmd/go/internal/generate \\\n+\tcmd/go/internal/get \\\n+\tcmd/go/internal/help \\\n+\tcmd/go/internal/list \\\n+\tcmd/go/internal/load \\\n+\tcmd/go/internal/run \\\n+\tcmd/go/internal/str \\\n+\tcmd/go/internal/test \\\n+\tcmd/go/internal/tool \\\n+\tcmd/go/internal/version \\\n+\tcmd/go/internal/vet \\\n+\tcmd/go/internal/web \\\n+\tcmd/go/internal/work \\\n+\tcmd/internal/browser \\\n+\tcmd/internal/objabi\n+\n+libgotool_a_SOURCES =\n+libgotool_a_DEPENDENCIES = $(addsuffix .lo,$(GOTOOL_PACKAGES))\n+libgotool_a_LIBADD = $(addsuffix .o,$(GOTOOL_PACKAGES))\n+\n # Make sure runtime.inc is built before compiling any .c file.\n $(libgo_la_OBJECTS): runtime.inc\n $(libgo_llgo_la_OBJECTS): runtime.inc\n@@ -925,7 +978,7 @@ GOBENCH =\n CHECK = \\\n \tGC=\"$(GOC) $(GOCFLAGS) $($(subst /,_,$@)_GOCFLAGS) -L `${PWD_COMMAND}` -L `${PWD_COMMAND}`/.libs\"; \\\n \texport GC; \\\n-\tGOLIBS=\"$(MATH_LIBS) $(NET_LIBS) $(LIBS)\"; \\\n+\tGOLIBS=\"$(extra_check_libs_$(subst /,_,$(@D))) $(MATH_LIBS) $(NET_LIBS) $(LIBS)\"; \\\n \texport GOLIBS; \\\n \tRUNTESTFLAGS=\"$(RUNTESTFLAGS)\"; \\\n \texport RUNTESTFLAGS; \\\n@@ -985,7 +1038,8 @@ CHECK_DEPS = \\\n \t$(toolexeclibgotesting_DATA) \\\n \t$(toolexeclibgotext_DATA) \\\n \t$(toolexeclibgotexttemplate_DATA) \\\n-\t$(toolexeclibgounicode_DATA)\n+\t$(toolexeclibgounicode_DATA) \\\n+\t$(noinst_LIBRARIES)\n \n if GOC_IS_LLGO\n CHECK_DEPS += libgo-llgo.la libgobegin-llgo.a\n@@ -1025,6 +1079,7 @@ endef\n # This line expands PACKAGE_template once for each package name listed\n # in $(PACKAGES).\n $(foreach package,$(PACKAGES),$(eval $(call PACKAGE_template,$(package))))\n+$(foreach package,$(GOTOOL_PACKAGES),$(eval $(call PACKAGE_template,$(package))))\n \n # Pass -ffp-contract=off, or 386-specific options, when building the\n # math package.  MATH_FLAG is defined in configure.ac.\n@@ -1066,6 +1121,17 @@ runtime_pprof_check_GOCFLAGS = -static-libgo -fno-inline\n extra_go_files_runtime_internal_sys = version.go\n runtime/internal/sys.lo.dep: $(extra_go_files_runtime_internal_sys)\n \n+extra_go_files_cmd_go_internal_cfg = zdefaultcc.go\n+cmd/go/internal/cfg.lo.dep: $(extra_go_files_cmd_go_internal_cfg)\n+\n+extra_go_files_cmd_go_internal_load = zstdpkglist.go\n+cmd/go/internal/load.lo.dep: $(extra_go_files_cmd_go_internal_load)\n+\n+extra_check_libs_cmd_go_internal_generate = $(abs_builddir)/libgotool.a\n+extra_check_libs_cmd_go_internal_get = $(abs_builddir)/libgotool.a\n+extra_check_libs_cmd_go_internal_load = $(abs_builddir)/libgotool.a\n+extra_check_libs_cmd_go_internal_work = $(abs_builddir)/libgotool.a\n+\n # FIXME: The following C files may as well move to the runtime\n # directory and be treated like other C files.\n \n@@ -1177,6 +1243,11 @@ TEST_PACKAGES = \\\n \tunicode/check \\\n \tarchive/tar/check \\\n \tarchive/zip/check \\\n+\tcmd/go/internal/generate/check \\\n+\tcmd/go/internal/get/check \\\n+\tcmd/go/internal/load/check \\\n+\tcmd/go/internal/work/check \\\n+\tcmd/internal/objabi/check \\\n \tcompress/bzip2/check \\\n \tcompress/flate/check \\\n \tcompress/gzip/check \\\n@@ -1230,6 +1301,7 @@ TEST_PACKAGES = \\\n \tgo/format/check \\\n \tgo/internal/gcimporter/check \\\n \tgo/internal/gccgoimporter/check \\\n+\tgo/internal/srcimporter/check \\\n \tgo/parser/check \\\n \tgo/printer/check \\\n \tgo/scanner/check \\\n@@ -1243,6 +1315,7 @@ TEST_PACKAGES = \\\n \tgolang_org/x/net/idna/check \\\n \tgolang_org/x/net/lex/httplex/check \\\n \t$(golang_org_x_net_lif_check) \\\n+\tgolang_org/x/net/proxy/check \\\n \t$(golang_org_x_net_route_check) \\\n \thash/adler32/check \\\n \thash/crc32/check \\\n@@ -1253,12 +1326,13 @@ TEST_PACKAGES = \\\n \timage/jpeg/check \\\n \timage/png/check \\\n \tindex/suffixarray/check \\\n-\tinternal/pprof/profile/check \\\n+\tinternal/poll/check \\\n \tinternal/singleflight/check \\\n \tinternal/trace/check \\\n \tio/ioutil/check \\\n \tlog/syslog/check \\\n \tmath/big/check \\\n+\tmath/bits/check \\\n \tmath/cmplx/check \\\n \tmath/rand/check \\\n \tmime/multipart/check \\\n@@ -1287,7 +1361,7 @@ TEST_PACKAGES = \\\n \truntime/internal/atomic/check \\\n \truntime/internal/sys/check \\\n \truntime/pprof/check \\\n-\truntime/pprof/internal/protopprof/check \\\n+\truntime/pprof/internal/profile/check \\\n \truntime/trace/check \\\n \tsync/atomic/check \\\n \ttext/scanner/check \\\n@@ -1413,7 +1487,7 @@ mostlyclean-local:\n \tfind . -name '*-testsum' -print | xargs rm -f\n \tfind . -name '*-testlog' -print | xargs rm -f\n \n-CLEANFILES = *.go *.c s-version libgo.sum libgo.log runtime.inc\n+CLEANFILES = *.go *.c s-* libgo.sum libgo.log runtime.inc\n \n clean-local:\n \tfind . -name '*.la' -print | xargs $(LIBTOOL) --mode=clean rm -f"}, {"sha": "5f7adb21dd293f171c7848e27ae648c915423795", "filename": "libgo/Makefile.in", "status": "modified", "additions": 105, "deletions": 26, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.in?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -155,7 +155,7 @@ am__installdirs = \"$(DESTDIR)$(toolexeclibdir)\" \\\n \t\"$(DESTDIR)$(toolexeclibgotextdir)\" \\\n \t\"$(DESTDIR)$(toolexeclibgotexttemplatedir)\" \\\n \t\"$(DESTDIR)$(toolexeclibgounicodedir)\"\n-LIBRARIES = $(toolexeclib_LIBRARIES)\n+LIBRARIES = $(noinst_LIBRARIES) $(toolexeclib_LIBRARIES)\n ARFLAGS = cru\n libgobegin_llgo_a_AR = $(AR) $(ARFLAGS)\n libgobegin_llgo_a_LIBADD =\n@@ -169,6 +169,9 @@ libgolibbegin_a_AR = $(AR) $(ARFLAGS)\n libgolibbegin_a_LIBADD =\n am_libgolibbegin_a_OBJECTS = libgolibbegin_a-go-libmain.$(OBJEXT)\n libgolibbegin_a_OBJECTS = $(am_libgolibbegin_a_OBJECTS)\n+libgotool_a_AR = $(AR) $(ARFLAGS)\n+am_libgotool_a_OBJECTS =\n+libgotool_a_OBJECTS = $(am_libgotool_a_OBJECTS)\n LTLIBRARIES = $(toolexeclib_LTLIBRARIES)\n @LIBGO_IS_LINUX_TRUE@am__DEPENDENCIES_1 = syscall/clone_linux.lo\n am__DEPENDENCIES_2 = $(addsuffix .lo,$(PACKAGES)) bytes/index.lo \\\n@@ -229,8 +232,8 @@ LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n \t--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \\\n \t$(LDFLAGS) -o $@\n SOURCES = $(libgobegin_llgo_a_SOURCES) $(libgobegin_a_SOURCES) \\\n-\t$(libgolibbegin_a_SOURCES) $(libgo_llgo_la_SOURCES) \\\n-\t$(libgo_la_SOURCES)\n+\t$(libgolibbegin_a_SOURCES) $(libgotool_a_SOURCES) \\\n+\t$(libgo_llgo_la_SOURCES) $(libgo_la_SOURCES)\n MULTISRCTOP = \n MULTIBUILDTOP = \n MULTIDIRS = \n@@ -518,6 +521,7 @@ FLAGS_TO_PASS = $(AM_MAKEFLAGS)\n @GOC_IS_LLGO_TRUE@toolexeclib_LTLIBRARIES = libgo-llgo.la\n @GOC_IS_LLGO_FALSE@toolexeclib_LIBRARIES = libgobegin.a libgolibbegin.a\n @GOC_IS_LLGO_TRUE@toolexeclib_LIBRARIES = libgobegin-llgo.a\n+noinst_LIBRARIES = libgotool.a\n toolexeclibgo_DATA = \\\n \tbufio.gox \\\n \tbytes.gox \\\n@@ -681,6 +685,7 @@ toolexeclibgolog_DATA = \\\n toolexeclibgomathdir = $(toolexeclibgodir)/math\n toolexeclibgomath_DATA = \\\n \tmath/big.gox \\\n+\tmath/bits.gox \\\n \tmath/cmplx.gox \\\n \tmath/rand.gox\n \n@@ -809,7 +814,10 @@ runtime_files = \\\n \t$(rtems_task_variable_add_file) \\\n \t$(runtime_getncpu_file)\n \n-noinst_DATA = zstdpkglist.go\n+GCCGO_INSTALL_NAME := $(shell echo gccgo|sed '$(program_transform_name)')\n+GCC_INSTALL_NAME := $(shell echo gcc|sed '$(program_transform_name)')\n+GXX_INSTALL_NAME := $(shell echo g++|sed '$(program_transform_name)')\n+noinst_DATA = zstdpkglist.go zdefaultcc.go\n @LIBGO_IS_LINUX_FALSE@syscall_epoll_file = \n @LIBGO_IS_LINUX_TRUE@syscall_epoll_file = epoll.go\n SYSINFO_FLAGS = \\\n@@ -823,7 +831,6 @@ PACKAGES = \\\n \tarchive/zip \\\n \tbufio \\\n \tbytes \\\n-\tcmd/internal/browser \\\n \tcompress/bzip2 \\\n \tcompress/flate \\\n \tcompress/gzip \\\n@@ -887,6 +894,7 @@ PACKAGES = \\\n \tgo/importer \\\n \tgo/internal/gccgoimporter \\\n \tgo/internal/gcimporter \\\n+\tgo/internal/srcimporter \\\n \tgo/parser \\\n \tgo/printer \\\n \tgo/scanner \\\n@@ -899,7 +907,10 @@ PACKAGES = \\\n \tgolang_org/x/net/http2/hpack \\\n \tgolang_org/x/net/idna \\\n \tgolang_org/x/net/lex/httplex \\\n+\tgolang_org/x/net/proxy \\\n+\tgolang_org/x/text/secure/bidirule \\\n \tgolang_org/x/text/transform \\\n+\tgolang_org/x/text/unicode/bidi \\\n \tgolang_org/x/text/unicode/norm \\\n \tgolang_org/x/text/width \\\n \thash \\\n@@ -919,7 +930,7 @@ PACKAGES = \\\n \timage/png \\\n \tindex/suffixarray \\\n \tinternal/nettrace \\\n-\tinternal/pprof/profile \\\n+\tinternal/poll \\\n \tinternal/race \\\n \tinternal/singleflight \\\n \tinternal/syscall/unix \\\n@@ -931,6 +942,7 @@ PACKAGES = \\\n \tlog/syslog \\\n \tmath \\\n \tmath/big \\\n+\tmath/bits \\\n \tmath/cmplx \\\n \tmath/rand \\\n \tmime \\\n@@ -967,7 +979,7 @@ PACKAGES = \\\n \truntime/internal/atomic \\\n \truntime/internal/sys \\\n \truntime/pprof \\\n-\truntime/pprof/internal/protopprof \\\n+\truntime/pprof/internal/profile \\\n \truntime/trace \\\n \tsort \\\n \tstrconv \\\n@@ -1031,6 +1043,36 @@ libgolibbegin_a_SOURCES = \\\n \truntime/go-libmain.c\n \n libgolibbegin_a_CFLAGS = $(AM_CFLAGS) -fPIC\n+GOTOOL_PACKAGES = \\\n+\tcmd/go/internal/base \\\n+\tcmd/go/internal/bug \\\n+\tcmd/go/internal/buildid \\\n+\tcmd/go/internal/cfg \\\n+\tcmd/go/internal/clean \\\n+\tcmd/go/internal/cmdflag \\\n+\tcmd/go/internal/doc \\\n+\tcmd/go/internal/envcmd \\\n+\tcmd/go/internal/fix \\\n+\tcmd/go/internal/fmtcmd \\\n+\tcmd/go/internal/generate \\\n+\tcmd/go/internal/get \\\n+\tcmd/go/internal/help \\\n+\tcmd/go/internal/list \\\n+\tcmd/go/internal/load \\\n+\tcmd/go/internal/run \\\n+\tcmd/go/internal/str \\\n+\tcmd/go/internal/test \\\n+\tcmd/go/internal/tool \\\n+\tcmd/go/internal/version \\\n+\tcmd/go/internal/vet \\\n+\tcmd/go/internal/web \\\n+\tcmd/go/internal/work \\\n+\tcmd/internal/browser \\\n+\tcmd/internal/objabi\n+\n+libgotool_a_SOURCES = \n+libgotool_a_DEPENDENCIES = $(addsuffix .lo,$(GOTOOL_PACKAGES))\n+libgotool_a_LIBADD = $(addsuffix .o,$(GOTOOL_PACKAGES))\n LTLDFLAGS = $(shell $(SHELL) $(top_srcdir)/../libtool-ldflags $(LDFLAGS))\n AM_GOCFLAGS = $(STRINGOPS_FLAG) $(GO_SPLIT_STACK)\n GOCOMPILE = $(GOC) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_GOCFLAGS) $(GOCFLAGS)\n@@ -1078,7 +1120,7 @@ GOBENCH =\n CHECK = \\\n \tGC=\"$(GOC) $(GOCFLAGS) $($(subst /,_,$@)_GOCFLAGS) -L `${PWD_COMMAND}` -L `${PWD_COMMAND}`/.libs\"; \\\n \texport GC; \\\n-\tGOLIBS=\"$(MATH_LIBS) $(NET_LIBS) $(LIBS)\"; \\\n+\tGOLIBS=\"$(extra_check_libs_$(subst /,_,$(@D))) $(MATH_LIBS) $(NET_LIBS) $(LIBS)\"; \\\n \texport GOLIBS; \\\n \tRUNTESTFLAGS=\"$(RUNTESTFLAGS)\"; \\\n \texport RUNTESTFLAGS; \\\n@@ -1125,7 +1167,8 @@ CHECK_DEPS = $(toolexeclibgo_DATA) $(toolexeclibgoarchive_DATA) \\\n \t$(toolexeclibgorpc_DATA) $(toolexeclibgoruntime_DATA) \\\n \t$(toolexeclibgosync_DATA) $(toolexeclibgotesting_DATA) \\\n \t$(toolexeclibgotext_DATA) $(toolexeclibgotexttemplate_DATA) \\\n-\t$(toolexeclibgounicode_DATA) $(am__append_3) $(am__append_4)\n+\t$(toolexeclibgounicode_DATA) $(noinst_LIBRARIES) \\\n+\t$(am__append_3) $(am__append_4)\n \n # Pass -ffp-contract=off, or 386-specific options, when building the\n # math package.  MATH_FLAG is defined in configure.ac.\n@@ -1160,6 +1203,12 @@ runtime_internal_sys_lo_check_GOCFLAGS = -fgo-compiling-runtime\n # Also use -fno-inline to get better results from the memory profiler.\n runtime_pprof_check_GOCFLAGS = -static-libgo -fno-inline\n extra_go_files_runtime_internal_sys = version.go\n+extra_go_files_cmd_go_internal_cfg = zdefaultcc.go\n+extra_go_files_cmd_go_internal_load = zstdpkglist.go\n+extra_check_libs_cmd_go_internal_generate = $(abs_builddir)/libgotool.a\n+extra_check_libs_cmd_go_internal_get = $(abs_builddir)/libgotool.a\n+extra_check_libs_cmd_go_internal_load = $(abs_builddir)/libgotool.a\n+extra_check_libs_cmd_go_internal_work = $(abs_builddir)/libgotool.a\n @HAVE_STAT_TIMESPEC_FALSE@@LIBGO_IS_SOLARIS_TRUE@matchargs_os = \n \n # Solaris 12 changed the type of fields in struct stat.\n@@ -1207,6 +1256,11 @@ TEST_PACKAGES = \\\n \tunicode/check \\\n \tarchive/tar/check \\\n \tarchive/zip/check \\\n+\tcmd/go/internal/generate/check \\\n+\tcmd/go/internal/get/check \\\n+\tcmd/go/internal/load/check \\\n+\tcmd/go/internal/work/check \\\n+\tcmd/internal/objabi/check \\\n \tcompress/bzip2/check \\\n \tcompress/flate/check \\\n \tcompress/gzip/check \\\n@@ -1260,6 +1314,7 @@ TEST_PACKAGES = \\\n \tgo/format/check \\\n \tgo/internal/gcimporter/check \\\n \tgo/internal/gccgoimporter/check \\\n+\tgo/internal/srcimporter/check \\\n \tgo/parser/check \\\n \tgo/printer/check \\\n \tgo/scanner/check \\\n@@ -1273,6 +1328,7 @@ TEST_PACKAGES = \\\n \tgolang_org/x/net/idna/check \\\n \tgolang_org/x/net/lex/httplex/check \\\n \t$(golang_org_x_net_lif_check) \\\n+\tgolang_org/x/net/proxy/check \\\n \t$(golang_org_x_net_route_check) \\\n \thash/adler32/check \\\n \thash/crc32/check \\\n@@ -1283,12 +1339,13 @@ TEST_PACKAGES = \\\n \timage/jpeg/check \\\n \timage/png/check \\\n \tindex/suffixarray/check \\\n-\tinternal/pprof/profile/check \\\n+\tinternal/poll/check \\\n \tinternal/singleflight/check \\\n \tinternal/trace/check \\\n \tio/ioutil/check \\\n \tlog/syslog/check \\\n \tmath/big/check \\\n+\tmath/bits/check \\\n \tmath/cmplx/check \\\n \tmath/rand/check \\\n \tmime/multipart/check \\\n@@ -1317,7 +1374,7 @@ TEST_PACKAGES = \\\n \truntime/internal/atomic/check \\\n \truntime/internal/sys/check \\\n \truntime/pprof/check \\\n-\truntime/pprof/internal/protopprof/check \\\n+\truntime/pprof/internal/profile/check \\\n \truntime/trace/check \\\n \tsync/atomic/check \\\n \ttext/scanner/check \\\n@@ -1335,7 +1392,7 @@ MOSTLYCLEANFILES = \\\n \tlibgo.head libgo.sum.sep libgo.log.sep libgo.var \\\n \tlibcalls-list runtime.inc runtime.inc.tmp2 runtime.inc.tmp3\n \n-CLEANFILES = *.go *.c s-version libgo.sum libgo.log runtime.inc\n+CLEANFILES = *.go *.c s-* libgo.sum libgo.log runtime.inc\n all: config.h\n \t$(MAKE) $(AM_MAKEFLAGS) all-recursive\n \n@@ -1390,6 +1447,9 @@ $(srcdir)/config.h.in: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)\n \n distclean-hdr:\n \t-rm -f config.h stamp-h1\n+\n+clean-noinstLIBRARIES:\n+\t-test -z \"$(noinst_LIBRARIES)\" || rm -f $(noinst_LIBRARIES)\n install-toolexeclibLIBRARIES: $(toolexeclib_LIBRARIES)\n \t@$(NORMAL_INSTALL)\n \t@list='$(toolexeclib_LIBRARIES)'; test -n \"$(toolexeclibdir)\" || list=; \\\n@@ -1433,6 +1493,10 @@ libgolibbegin.a: $(libgolibbegin_a_OBJECTS) $(libgolibbegin_a_DEPENDENCIES) $(EX\n \t-rm -f libgolibbegin.a\n \t$(libgolibbegin_a_AR) libgolibbegin.a $(libgolibbegin_a_OBJECTS) $(libgolibbegin_a_LIBADD)\n \t$(RANLIB) libgolibbegin.a\n+libgotool.a: $(libgotool_a_OBJECTS) $(libgotool_a_DEPENDENCIES) $(EXTRA_libgotool_a_DEPENDENCIES) \n+\t-rm -f libgotool.a\n+\t$(libgotool_a_AR) libgotool.a $(libgotool_a_OBJECTS) $(libgotool_a_LIBADD)\n+\t$(RANLIB) libgotool.a\n install-toolexeclibLTLIBRARIES: $(toolexeclib_LTLIBRARIES)\n \t@$(NORMAL_INSTALL)\n \t@list='$(toolexeclib_LTLIBRARIES)'; test -n \"$(toolexeclibdir)\" || list=; \\\n@@ -2797,8 +2861,8 @@ maintainer-clean-generic:\n clean: clean-multi clean-recursive\n \n clean-am: clean-generic clean-libtool clean-local \\\n-\tclean-toolexeclibLIBRARIES clean-toolexeclibLTLIBRARIES \\\n-\tmostlyclean-am\n+\tclean-noinstLIBRARIES clean-toolexeclibLIBRARIES \\\n+\tclean-toolexeclibLTLIBRARIES mostlyclean-am\n \n distclean: distclean-multi distclean-recursive\n \t-rm -f $(am__CONFIG_DISTCLEAN_FILES)\n@@ -2931,17 +2995,18 @@ uninstall-am: uninstall-toolexeclibLIBRARIES \\\n .PHONY: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) CTAGS GTAGS \\\n \tall all-am all-multi am--refresh check check-am clean \\\n \tclean-generic clean-libtool clean-local clean-multi \\\n-\tclean-toolexeclibLIBRARIES clean-toolexeclibLTLIBRARIES ctags \\\n-\tctags-recursive distclean distclean-compile distclean-generic \\\n-\tdistclean-hdr distclean-libtool distclean-local \\\n-\tdistclean-multi distclean-tags dvi dvi-am html html-am info \\\n-\tinfo-am install install-am install-data install-data-am \\\n-\tinstall-dvi install-dvi-am install-exec install-exec-am \\\n-\tinstall-html install-html-am install-info install-info-am \\\n-\tinstall-man install-multi install-pdf install-pdf-am \\\n-\tinstall-ps install-ps-am install-strip \\\n-\tinstall-toolexeclibLIBRARIES install-toolexeclibLTLIBRARIES \\\n-\tinstall-toolexeclibgoDATA install-toolexeclibgoarchiveDATA \\\n+\tclean-noinstLIBRARIES clean-toolexeclibLIBRARIES \\\n+\tclean-toolexeclibLTLIBRARIES ctags ctags-recursive distclean \\\n+\tdistclean-compile distclean-generic distclean-hdr \\\n+\tdistclean-libtool distclean-local distclean-multi \\\n+\tdistclean-tags dvi dvi-am html html-am info info-am install \\\n+\tinstall-am install-data install-data-am install-dvi \\\n+\tinstall-dvi-am install-exec install-exec-am install-html \\\n+\tinstall-html-am install-info install-info-am install-man \\\n+\tinstall-multi install-pdf install-pdf-am install-ps \\\n+\tinstall-ps-am install-strip install-toolexeclibLIBRARIES \\\n+\tinstall-toolexeclibLTLIBRARIES install-toolexeclibgoDATA \\\n+\tinstall-toolexeclibgoarchiveDATA \\\n \tinstall-toolexeclibgocompressDATA \\\n \tinstall-toolexeclibgocontainerDATA \\\n \tinstall-toolexeclibgocryptoDATA \\\n@@ -3069,6 +3134,17 @@ s-sigtab: $(srcdir)/mksigtab.sh gen-sysinfo.go\n \t$(SHELL) $(srcdir)/mvifdiff.sh tmp-sigtab.go sigtab.go\n \t$(STAMP) $@\n \n+zdefaultcc.go: s-zdefaultcc; @true\n+s-zdefaultcc: Makefile\n+\techo 'package cfg' > zdefaultcc.go.tmp\n+\techo >> zdefaultcc.go.tmp\n+\techo 'const DefaultGCCGO = \"$(bindir)/$(GCCGO_INSTALL_NAME)\"' >> zdefaultcc.go.tmp\n+\techo 'const DefaultCC = \"$(GCC_INSTALL_NAME)\"' >> zdefaultcc.go.tmp\n+\techo 'const DefaultCXX = \"$(GXX_INSTALL_NAME)\"' >> zdefaultcc.go.tmp\n+\techo 'const DefaultPkgConfig = \"pkg-config\"' >> zdefaultcc.go.tmp\n+\t$(SHELL) $(srcdir)/../move-if-change zdefaultcc.go.tmp zdefaultcc.go\n+\t$(STAMP) $@ \n+\n # _Complex_lock and _Reader_lock are Go translations of some AIX system\n # types and should not be exported back to C\n # semt is a Go translation of the C type sem_t; it fails to convert on\n@@ -3094,7 +3170,7 @@ s-runtime-inc: runtime.lo Makefile\n zstdpkglist.go: s-zstdpkglist; @true\n s-zstdpkglist: Makefile\n \trm -f zstdpkglist.go.tmp\n-\techo 'package main' > zstdpkglist.go.tmp\n+\techo 'package load' > zstdpkglist.go.tmp\n \techo \"\" >> zstdpkglist.go.tmp\n \techo 'var stdpkg = map[string]bool{' >> zstdpkglist.go.tmp\n \techo $(libgo_go_objs) 'unsafe.lo' 'runtime/cgo.lo' | sed 's|[a-z0-9_/]*_c\\.lo||g' | sed 's|\\([a-z0-9_/]*\\)\\.lo|\"\\1\": true,|g' >> zstdpkglist.go.tmp\n@@ -3211,9 +3287,12 @@ endef\n # This line expands PACKAGE_template once for each package name listed\n # in $(PACKAGES).\n $(foreach package,$(PACKAGES),$(eval $(call PACKAGE_template,$(package))))\n+$(foreach package,$(GOTOOL_PACKAGES),$(eval $(call PACKAGE_template,$(package))))\n runtime.lo.dep: $(extra_go_files_runtime)\n syscall.lo.dep: $(extra_go_files_syscall)\n runtime/internal/sys.lo.dep: $(extra_go_files_runtime_internal_sys)\n+cmd/go/internal/cfg.lo.dep: $(extra_go_files_cmd_go_internal_cfg)\n+cmd/go/internal/load.lo.dep: $(extra_go_files_cmd_go_internal_load)\n \n # FIXME: The following C files may as well move to the runtime\n # directory and be treated like other C files."}, {"sha": "6d1d72fa43188a0cfdf764ea66285a0b7b560c0c", "filename": "libgo/VERSION", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2FVERSION", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2FVERSION", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FVERSION?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -1 +1 @@\n-go1.8.3\n+go1.9"}, {"sha": "1e5e41bed213495596b24230651e1bc97ded9884", "filename": "libgo/configure", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fconfigure?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -2494,7 +2494,7 @@ ac_compiler_gnu=$ac_cv_c_compiler_gnu\n ac_config_headers=\"$ac_config_headers config.h\"\n \n \n-libtool_VERSION=11:0:0\n+libtool_VERSION=12:0:0\n \n \n # Default to --enable-multilib"}, {"sha": "4bfe1698d329e2efede240cd3e33e24a79875c83", "filename": "libgo/configure.ac", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fconfigure.ac?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -11,7 +11,7 @@ AC_INIT(package-unused, version-unused,, libgo)\n AC_CONFIG_SRCDIR(Makefile.am)\n AC_CONFIG_HEADER(config.h)\n \n-libtool_VERSION=11:0:0\n+libtool_VERSION=12:0:0\n AC_SUBST(libtool_VERSION)\n \n AM_ENABLE_MULTILIB(, ..)"}, {"sha": "d49c5c3fd9ee3dc3e6b8580032bdebca6038cc9a", "filename": "libgo/go/archive/tar/common.go", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Farchive%2Ftar%2Fcommon.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Farchive%2Ftar%2Fcommon.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Fcommon.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -158,11 +158,15 @@ func (fi headerFileInfo) Mode() (mode os.FileMode) {\n // sysStat, if non-nil, populates h from system-dependent fields of fi.\n var sysStat func(fi os.FileInfo, h *Header) error\n \n-// Mode constants from the tar spec.\n const (\n-\tc_ISUID  = 04000   // Set uid\n-\tc_ISGID  = 02000   // Set gid\n-\tc_ISVTX  = 01000   // Save text (sticky bit)\n+\t// Mode constants from the USTAR spec:\n+\t// See http://pubs.opengroup.org/onlinepubs/9699919799/utilities/pax.html#tag_20_92_13_06\n+\tc_ISUID = 04000 // Set uid\n+\tc_ISGID = 02000 // Set gid\n+\tc_ISVTX = 01000 // Save text (sticky bit)\n+\n+\t// Common Unix mode constants; these are not defined in any common tar standard.\n+\t// Header.FileInfo understands these, but FileInfoHeader will never produce these.\n \tc_ISDIR  = 040000  // Directory\n \tc_ISFIFO = 010000  // FIFO\n \tc_ISREG  = 0100000 // Regular file\n@@ -208,30 +212,24 @@ func FileInfoHeader(fi os.FileInfo, link string) (*Header, error) {\n \t}\n \tswitch {\n \tcase fm.IsRegular():\n-\t\th.Mode |= c_ISREG\n \t\th.Typeflag = TypeReg\n \t\th.Size = fi.Size()\n \tcase fi.IsDir():\n \t\th.Typeflag = TypeDir\n-\t\th.Mode |= c_ISDIR\n \t\th.Name += \"/\"\n \tcase fm&os.ModeSymlink != 0:\n \t\th.Typeflag = TypeSymlink\n-\t\th.Mode |= c_ISLNK\n \t\th.Linkname = link\n \tcase fm&os.ModeDevice != 0:\n \t\tif fm&os.ModeCharDevice != 0 {\n-\t\t\th.Mode |= c_ISCHR\n \t\t\th.Typeflag = TypeChar\n \t\t} else {\n-\t\t\th.Mode |= c_ISBLK\n \t\t\th.Typeflag = TypeBlock\n \t\t}\n \tcase fm&os.ModeNamedPipe != 0:\n \t\th.Typeflag = TypeFifo\n-\t\th.Mode |= c_ISFIFO\n \tcase fm&os.ModeSocket != 0:\n-\t\th.Mode |= c_ISSOCK\n+\t\treturn nil, fmt.Errorf(\"archive/tar: sockets not supported\")\n \tdefault:\n \t\treturn nil, fmt.Errorf(\"archive/tar: unknown file mode %v\", fm)\n \t}"}, {"sha": "fb7a9dcfc47451f43b26c964741993fc8775df73", "filename": "libgo/go/archive/tar/tar_test.go", "status": "modified", "additions": 49, "deletions": 31, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Farchive%2Ftar%2Ftar_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Farchive%2Ftar%2Ftar_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Ftar_test.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -6,9 +6,11 @@ package tar\n \n import (\n \t\"bytes\"\n+\t\"internal/testenv\"\n \t\"io/ioutil\"\n \t\"os\"\n \t\"path\"\n+\t\"path/filepath\"\n \t\"reflect\"\n \t\"strings\"\n \t\"testing\"\n@@ -27,7 +29,7 @@ func TestFileInfoHeader(t *testing.T) {\n \tif g, e := h.Name, \"small.txt\"; g != e {\n \t\tt.Errorf(\"Name = %q; want %q\", g, e)\n \t}\n-\tif g, e := h.Mode, int64(fi.Mode().Perm())|c_ISREG; g != e {\n+\tif g, e := h.Mode, int64(fi.Mode().Perm()); g != e {\n \t\tt.Errorf(\"Mode = %#o; want %#o\", g, e)\n \t}\n \tif g, e := h.Size, int64(5); g != e {\n@@ -55,7 +57,7 @@ func TestFileInfoHeaderDir(t *testing.T) {\n \t\tt.Errorf(\"Name = %q; want %q\", g, e)\n \t}\n \t// Ignoring c_ISGID for golang.org/issue/4867\n-\tif g, e := h.Mode&^c_ISGID, int64(fi.Mode().Perm())|c_ISDIR; g != e {\n+\tif g, e := h.Mode&^c_ISGID, int64(fi.Mode().Perm()); g != e {\n \t\tt.Errorf(\"Mode = %#o; want %#o\", g, e)\n \t}\n \tif g, e := h.Size, int64(0); g != e {\n@@ -67,40 +69,56 @@ func TestFileInfoHeaderDir(t *testing.T) {\n }\n \n func TestFileInfoHeaderSymlink(t *testing.T) {\n-\th, err := FileInfoHeader(symlink{}, \"some-target\")\n+\ttestenv.MustHaveSymlink(t)\n+\n+\ttmpdir, err := ioutil.TempDir(\"\", \"TestFileInfoHeaderSymlink\")\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tdefer os.RemoveAll(tmpdir)\n+\n+\tlink := filepath.Join(tmpdir, \"link\")\n+\ttarget := tmpdir\n+\terr = os.Symlink(target, link)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tfi, err := os.Lstat(link)\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n-\tif g, e := h.Name, \"some-symlink\"; g != e {\n+\n+\th, err := FileInfoHeader(fi, target)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tif g, e := h.Name, fi.Name(); g != e {\n \t\tt.Errorf(\"Name = %q; want %q\", g, e)\n \t}\n-\tif g, e := h.Linkname, \"some-target\"; g != e {\n+\tif g, e := h.Linkname, target; g != e {\n \t\tt.Errorf(\"Linkname = %q; want %q\", g, e)\n \t}\n+\tif g, e := h.Typeflag, byte(TypeSymlink); g != e {\n+\t\tt.Errorf(\"Typeflag = %v; want %v\", g, e)\n+\t}\n }\n \n-type symlink struct{}\n-\n-func (symlink) Name() string       { return \"some-symlink\" }\n-func (symlink) Size() int64        { return 0 }\n-func (symlink) Mode() os.FileMode  { return os.ModeSymlink }\n-func (symlink) ModTime() time.Time { return time.Time{} }\n-func (symlink) IsDir() bool        { return false }\n-func (symlink) Sys() interface{}   { return nil }\n-\n func TestRoundTrip(t *testing.T) {\n \tdata := []byte(\"some file contents\")\n \n \tvar b bytes.Buffer\n \ttw := NewWriter(&b)\n \thdr := &Header{\n-\t\tName:    \"file.txt\",\n-\t\tUid:     1 << 21, // too big for 8 octal digits\n-\t\tSize:    int64(len(data)),\n-\t\tModTime: time.Now(),\n+\t\tName: \"file.txt\",\n+\t\tUid:  1 << 21, // too big for 8 octal digits\n+\t\tSize: int64(len(data)),\n+\t\t// AddDate to strip monotonic clock reading,\n+\t\t// and Round to discard sub-second precision,\n+\t\t// both of which are not included in the tar header\n+\t\t// and would otherwise break the round-trip check\n+\t\t// below.\n+\t\tModTime: time.Now().AddDate(0, 0, 0).Round(1 * time.Second),\n \t}\n-\t// tar only supports second precision.\n-\thdr.ModTime = hdr.ModTime.Add(-time.Duration(hdr.ModTime.Nanosecond()) * time.Nanosecond)\n \tif err := tw.WriteHeader(hdr); err != nil {\n \t\tt.Fatalf(\"tw.WriteHeader: %v\", err)\n \t}\n@@ -139,7 +157,7 @@ func TestHeaderRoundTrip(t *testing.T) {\n \t\t// regular file.\n \t\th: &Header{\n \t\t\tName:     \"test.txt\",\n-\t\t\tMode:     0644 | c_ISREG,\n+\t\t\tMode:     0644,\n \t\t\tSize:     12,\n \t\t\tModTime:  time.Unix(1360600916, 0),\n \t\t\tTypeflag: TypeReg,\n@@ -149,7 +167,7 @@ func TestHeaderRoundTrip(t *testing.T) {\n \t\t// symbolic link.\n \t\th: &Header{\n \t\t\tName:     \"link.txt\",\n-\t\t\tMode:     0777 | c_ISLNK,\n+\t\t\tMode:     0777,\n \t\t\tSize:     0,\n \t\t\tModTime:  time.Unix(1360600852, 0),\n \t\t\tTypeflag: TypeSymlink,\n@@ -159,7 +177,7 @@ func TestHeaderRoundTrip(t *testing.T) {\n \t\t// character device node.\n \t\th: &Header{\n \t\t\tName:     \"dev/null\",\n-\t\t\tMode:     0666 | c_ISCHR,\n+\t\t\tMode:     0666,\n \t\t\tSize:     0,\n \t\t\tModTime:  time.Unix(1360578951, 0),\n \t\t\tTypeflag: TypeChar,\n@@ -169,7 +187,7 @@ func TestHeaderRoundTrip(t *testing.T) {\n \t\t// block device node.\n \t\th: &Header{\n \t\t\tName:     \"dev/sda\",\n-\t\t\tMode:     0660 | c_ISBLK,\n+\t\t\tMode:     0660,\n \t\t\tSize:     0,\n \t\t\tModTime:  time.Unix(1360578954, 0),\n \t\t\tTypeflag: TypeBlock,\n@@ -179,7 +197,7 @@ func TestHeaderRoundTrip(t *testing.T) {\n \t\t// directory.\n \t\th: &Header{\n \t\t\tName:     \"dir/\",\n-\t\t\tMode:     0755 | c_ISDIR,\n+\t\t\tMode:     0755,\n \t\t\tSize:     0,\n \t\t\tModTime:  time.Unix(1360601116, 0),\n \t\t\tTypeflag: TypeDir,\n@@ -189,7 +207,7 @@ func TestHeaderRoundTrip(t *testing.T) {\n \t\t// fifo node.\n \t\th: &Header{\n \t\t\tName:     \"dev/initctl\",\n-\t\t\tMode:     0600 | c_ISFIFO,\n+\t\t\tMode:     0600,\n \t\t\tSize:     0,\n \t\t\tModTime:  time.Unix(1360578949, 0),\n \t\t\tTypeflag: TypeFifo,\n@@ -199,7 +217,7 @@ func TestHeaderRoundTrip(t *testing.T) {\n \t\t// setuid.\n \t\th: &Header{\n \t\t\tName:     \"bin/su\",\n-\t\t\tMode:     0755 | c_ISREG | c_ISUID,\n+\t\t\tMode:     0755 | c_ISUID,\n \t\t\tSize:     23232,\n \t\t\tModTime:  time.Unix(1355405093, 0),\n \t\t\tTypeflag: TypeReg,\n@@ -209,7 +227,7 @@ func TestHeaderRoundTrip(t *testing.T) {\n \t\t// setguid.\n \t\th: &Header{\n \t\t\tName:     \"group.txt\",\n-\t\t\tMode:     0750 | c_ISREG | c_ISGID,\n+\t\t\tMode:     0750 | c_ISGID,\n \t\t\tSize:     0,\n \t\t\tModTime:  time.Unix(1360602346, 0),\n \t\t\tTypeflag: TypeReg,\n@@ -219,7 +237,7 @@ func TestHeaderRoundTrip(t *testing.T) {\n \t\t// sticky.\n \t\th: &Header{\n \t\t\tName:     \"sticky.txt\",\n-\t\t\tMode:     0600 | c_ISREG | c_ISVTX,\n+\t\t\tMode:     0600 | c_ISVTX,\n \t\t\tSize:     7,\n \t\t\tModTime:  time.Unix(1360602540, 0),\n \t\t\tTypeflag: TypeReg,\n@@ -229,7 +247,7 @@ func TestHeaderRoundTrip(t *testing.T) {\n \t\t// hard link.\n \t\th: &Header{\n \t\t\tName:     \"hard.txt\",\n-\t\t\tMode:     0644 | c_ISREG,\n+\t\t\tMode:     0644,\n \t\t\tSize:     0,\n \t\t\tLinkname: \"file.txt\",\n \t\t\tModTime:  time.Unix(1360600916, 0),\n@@ -240,7 +258,7 @@ func TestHeaderRoundTrip(t *testing.T) {\n \t\t// More information.\n \t\th: &Header{\n \t\t\tName:     \"info.txt\",\n-\t\t\tMode:     0600 | c_ISREG,\n+\t\t\tMode:     0600,\n \t\t\tSize:     0,\n \t\t\tUid:      1000,\n \t\t\tGid:      1000,"}, {"sha": "c51c243a8b8efe091d5318483467aaf6e6446566", "filename": "libgo/go/archive/tar/writer.go", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Farchive%2Ftar%2Fwriter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Farchive%2Ftar%2Fwriter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Fwriter.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -121,9 +121,15 @@ func (tw *Writer) writeHeader(hdr *Header, allowPax bool) error {\n \t\tneedsPaxHeader := paxKeyword != paxNone && len(s) > len(b) || !isASCII(s)\n \t\tif needsPaxHeader {\n \t\t\tpaxHeaders[paxKeyword] = s\n-\t\t\treturn\n \t\t}\n-\t\tf.formatString(b, s)\n+\n+\t\t// Write string in a best-effort manner to satisfy readers that expect\n+\t\t// the field to be non-empty.\n+\t\ts = toASCII(s)\n+\t\tif len(s) > len(b) {\n+\t\t\ts = s[:len(b)]\n+\t\t}\n+\t\tf.formatString(b, s) // Should never error\n \t}\n \tvar formatNumeric = func(b []byte, x int64, paxKeyword string) {\n \t\t// Try octal first."}, {"sha": "51e9c3e4d4b7103e878f06894b2b10d013797965", "filename": "libgo/go/archive/zip/register.go", "status": "modified", "additions": 21, "deletions": 26, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Farchive%2Fzip%2Fregister.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Farchive%2Fzip%2Fregister.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Fregister.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -103,51 +103,46 @@ func (r *pooledFlateReader) Close() error {\n }\n \n var (\n-\tmu sync.RWMutex // guards compressor and decompressor maps\n+\tcompressors   sync.Map // map[uint16]Compressor\n+\tdecompressors sync.Map // map[uint16]Decompressor\n+)\n \n-\tcompressors = map[uint16]Compressor{\n-\t\tStore:   func(w io.Writer) (io.WriteCloser, error) { return &nopCloser{w}, nil },\n-\t\tDeflate: func(w io.Writer) (io.WriteCloser, error) { return newFlateWriter(w), nil },\n-\t}\n+func init() {\n+\tcompressors.Store(Store, Compressor(func(w io.Writer) (io.WriteCloser, error) { return &nopCloser{w}, nil }))\n+\tcompressors.Store(Deflate, Compressor(func(w io.Writer) (io.WriteCloser, error) { return newFlateWriter(w), nil }))\n \n-\tdecompressors = map[uint16]Decompressor{\n-\t\tStore:   ioutil.NopCloser,\n-\t\tDeflate: newFlateReader,\n-\t}\n-)\n+\tdecompressors.Store(Store, Decompressor(ioutil.NopCloser))\n+\tdecompressors.Store(Deflate, Decompressor(newFlateReader))\n+}\n \n // RegisterDecompressor allows custom decompressors for a specified method ID.\n // The common methods Store and Deflate are built in.\n func RegisterDecompressor(method uint16, dcomp Decompressor) {\n-\tmu.Lock()\n-\tdefer mu.Unlock()\n-\n-\tif _, ok := decompressors[method]; ok {\n+\tif _, dup := decompressors.LoadOrStore(method, dcomp); dup {\n \t\tpanic(\"decompressor already registered\")\n \t}\n-\tdecompressors[method] = dcomp\n }\n \n // RegisterCompressor registers custom compressors for a specified method ID.\n // The common methods Store and Deflate are built in.\n func RegisterCompressor(method uint16, comp Compressor) {\n-\tmu.Lock()\n-\tdefer mu.Unlock()\n-\n-\tif _, ok := compressors[method]; ok {\n+\tif _, dup := compressors.LoadOrStore(method, comp); dup {\n \t\tpanic(\"compressor already registered\")\n \t}\n-\tcompressors[method] = comp\n }\n \n func compressor(method uint16) Compressor {\n-\tmu.RLock()\n-\tdefer mu.RUnlock()\n-\treturn compressors[method]\n+\tci, ok := compressors.Load(method)\n+\tif !ok {\n+\t\treturn nil\n+\t}\n+\treturn ci.(Compressor)\n }\n \n func decompressor(method uint16) Decompressor {\n-\tmu.RLock()\n-\tdefer mu.RUnlock()\n-\treturn decompressors[method]\n+\tdi, ok := decompressors.Load(method)\n+\tif !ok {\n+\t\treturn nil\n+\t}\n+\treturn di.(Decompressor)\n }"}, {"sha": "0be210e8e73953451e33c24fb7abc46f2e8e2499", "filename": "libgo/go/archive/zip/struct.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Farchive%2Fzip%2Fstruct.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Farchive%2Fzip%2Fstruct.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Fstruct.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -5,7 +5,7 @@\n /*\n Package zip provides support for reading and writing ZIP archives.\n \n-See: https://www.pkware.com/documents/casestudies/APPNOTE.TXT\n+See: https://www.pkware.com/appnote\n \n This package does not support disk spanning.\n "}, {"sha": "9f4fceee844b0d1d329456ccfd969b4c7805f368", "filename": "libgo/go/archive/zip/writer.go", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Farchive%2Fzip%2Fwriter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Farchive%2Fzip%2Fwriter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Fwriter.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -11,10 +11,9 @@ import (\n \t\"hash\"\n \t\"hash/crc32\"\n \t\"io\"\n+\t\"unicode/utf8\"\n )\n \n-// TODO(adg): support zip file comments\n-\n // Writer implements a zip file writer.\n type Writer struct {\n \tcw          *countWriter\n@@ -201,6 +200,20 @@ func (w *Writer) Create(name string) (io.Writer, error) {\n \treturn w.CreateHeader(header)\n }\n \n+func hasValidUTF8(s string) bool {\n+\tn := 0\n+\tfor _, r := range s {\n+\t\t// By default, ZIP uses CP437, which is only identical to ASCII for the printable characters.\n+\t\tif r < 0x20 || r >= 0x7f {\n+\t\t\tif !utf8.ValidRune(r) {\n+\t\t\t\treturn false\n+\t\t\t}\n+\t\t\tn++\n+\t\t}\n+\t}\n+\treturn n > 0\n+}\n+\n // CreateHeader adds a file to the zip file using the provided FileHeader\n // for the file metadata.\n // It returns a Writer to which the file contents should be written.\n@@ -221,6 +234,10 @@ func (w *Writer) CreateHeader(fh *FileHeader) (io.Writer, error) {\n \n \tfh.Flags |= 0x8 // we will write a data descriptor\n \n+\tif hasValidUTF8(fh.Name) || hasValidUTF8(fh.Comment) {\n+\t\tfh.Flags |= 0x800 // filename or comment have valid utf-8 string\n+\t}\n+\n \tfh.CreatorVersion = fh.CreatorVersion&0xff00 | zipVersion20 // preserve compatibility byte\n \tfh.ReaderVersion = zipVersion20\n "}, {"sha": "92fb6ecf0ed11e7decce45b72b77058994259e73", "filename": "libgo/go/archive/zip/writer_test.go", "status": "modified", "additions": 80, "deletions": 10, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Farchive%2Fzip%2Fwriter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Farchive%2Fzip%2Fwriter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Fwriter_test.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -87,6 +87,69 @@ func TestWriter(t *testing.T) {\n \t}\n }\n \n+func TestWriterUTF8(t *testing.T) {\n+\tvar utf8Tests = []struct {\n+\t\tname    string\n+\t\tcomment string\n+\t\texpect  uint16\n+\t}{\n+\t\t{\n+\t\t\tname:    \"hi, hello\",\n+\t\t\tcomment: \"in the world\",\n+\t\t\texpect:  0x8,\n+\t\t},\n+\t\t{\n+\t\t\tname:    \"hi, \u3053\u3093\u306b\u3061\u308f\",\n+\t\t\tcomment: \"in the world\",\n+\t\t\texpect:  0x808,\n+\t\t},\n+\t\t{\n+\t\t\tname:    \"hi, hello\",\n+\t\t\tcomment: \"in the \u4e16\u754c\",\n+\t\t\texpect:  0x808,\n+\t\t},\n+\t\t{\n+\t\t\tname:    \"hi, \u3053\u3093\u306b\u3061\u308f\",\n+\t\t\tcomment: \"in the \u4e16\u754c\",\n+\t\t\texpect:  0x808,\n+\t\t},\n+\t}\n+\n+\t// write a zip file\n+\tbuf := new(bytes.Buffer)\n+\tw := NewWriter(buf)\n+\n+\tfor _, test := range utf8Tests {\n+\t\th := &FileHeader{\n+\t\t\tName:    test.name,\n+\t\t\tComment: test.comment,\n+\t\t\tMethod:  Deflate,\n+\t\t}\n+\t\tw, err := w.CreateHeader(h)\n+\t\tif err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\t\tw.Write([]byte{})\n+\t}\n+\n+\tif err := w.Close(); err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\n+\t// read it back\n+\tr, err := NewReader(bytes.NewReader(buf.Bytes()), int64(buf.Len()))\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tfor i, test := range utf8Tests {\n+\t\tgot := r.File[i].Flags\n+\t\tt.Logf(\"name %v, comment %v\", test.name, test.comment)\n+\t\tif got != test.expect {\n+\t\t\tt.Fatalf(\"Flags: got %v, want %v\", got, test.expect)\n+\t\t}\n+\t}\n+}\n+\n func TestWriterOffset(t *testing.T) {\n \tlargeData := make([]byte, 1<<17)\n \tfor i := range largeData {\n@@ -181,12 +244,11 @@ func testReadFile(t *testing.T, f *File, wt *WriteTest) {\n }\n \n func BenchmarkCompressedZipGarbage(b *testing.B) {\n-\tb.ReportAllocs()\n-\tvar buf bytes.Buffer\n \tbigBuf := bytes.Repeat([]byte(\"a\"), 1<<20)\n-\tfor i := 0; i <= b.N; i++ {\n+\n+\trunOnce := func(buf *bytes.Buffer) {\n \t\tbuf.Reset()\n-\t\tzw := NewWriter(&buf)\n+\t\tzw := NewWriter(buf)\n \t\tfor j := 0; j < 3; j++ {\n \t\t\tw, _ := zw.CreateHeader(&FileHeader{\n \t\t\t\tName:   \"foo\",\n@@ -195,11 +257,19 @@ func BenchmarkCompressedZipGarbage(b *testing.B) {\n \t\t\tw.Write(bigBuf)\n \t\t}\n \t\tzw.Close()\n-\t\tif i == 0 {\n-\t\t\t// Reset the timer after the first time through.\n-\t\t\t// This effectively discards the very large initial flate setup cost,\n-\t\t\t// as well as the initialization of bigBuf.\n-\t\t\tb.ResetTimer()\n-\t\t}\n \t}\n+\n+\tb.ReportAllocs()\n+\t// Run once and then reset the timer.\n+\t// This effectively discards the very large initial flate setup cost,\n+\t// as well as the initialization of bigBuf.\n+\trunOnce(&bytes.Buffer{})\n+\tb.ResetTimer()\n+\n+\tb.RunParallel(func(pb *testing.PB) {\n+\t\tvar buf bytes.Buffer\n+\t\tfor pb.Next() {\n+\t\t\trunOnce(&buf)\n+\t\t}\n+\t})\n }"}, {"sha": "18c2171ba6c15ba13937336c286e6857aaace10c", "filename": "libgo/go/archive/zip/zip_test.go", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Farchive%2Fzip%2Fzip_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Farchive%2Fzip%2Fzip_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Fzip_test.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -255,7 +255,7 @@ func TestZip64EdgeCase(t *testing.T) {\n \ttestZip64DirectoryRecordLength(buf, t)\n }\n \n-// Tests that we generate a zip64 file if the the directory at offset\n+// Tests that we generate a zip64 file if the directory at offset\n // 0xFFFFFFFF, but not before.\n func TestZip64DirectoryOffset(t *testing.T) {\n \tif testing.Short() && race.Enabled {\n@@ -681,6 +681,18 @@ func BenchmarkZip64Test(b *testing.B) {\n \t}\n }\n \n+func BenchmarkZip64TestSizes(b *testing.B) {\n+\tfor _, size := range []int64{1 << 12, 1 << 20, 1 << 26} {\n+\t\tb.Run(fmt.Sprint(size), func(b *testing.B) {\n+\t\t\tb.RunParallel(func(pb *testing.PB) {\n+\t\t\t\tfor pb.Next() {\n+\t\t\t\t\ttestZip64(b, size)\n+\t\t\t\t}\n+\t\t\t})\n+\t\t})\n+\t}\n+}\n+\n func TestSuffixSaver(t *testing.T) {\n \tconst keep = 10\n \tss := &suffixSaver{keep: keep}"}, {"sha": "da94a2503f0a8fdb4caf7ba446511589881a41b0", "filename": "libgo/go/bufio/bufio.go", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fbufio%2Fbufio.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fbufio%2Fbufio.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbufio%2Fbufio.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// Package bufio implements buffered I/O.  It wraps an io.Reader or io.Writer\n+// Package bufio implements buffered I/O. It wraps an io.Reader or io.Writer\n // object, creating another object (Reader or Writer) that also implements\n // the interface but provides buffering and some help for textual I/O.\n package bufio\n@@ -458,6 +458,7 @@ func (b *Reader) ReadString(delim byte) (string, error) {\n }\n \n // WriteTo implements io.WriterTo.\n+// This may make multiple calls to the Read method of the underlying Reader.\n func (b *Reader) WriteTo(w io.Writer) (n int64, err error) {\n \tn, err = b.writeBuf(w)\n \tif err != nil {\n@@ -513,7 +514,7 @@ func (b *Reader) writeBuf(w io.Writer) (int64, error) {\n \n // Writer implements buffering for an io.Writer object.\n // If an error occurs writing to a Writer, no more data will be\n-// accepted and all subsequent writes will return the error.\n+// accepted and all subsequent writes, and Flush, will return the error.\n // After all data has been written, the client should call the\n // Flush method to guarantee all data has been forwarded to\n // the underlying io.Writer."}, {"sha": "25682256887daaa0b973e5660ef453ef80713488", "filename": "libgo/go/bufio/scan_test.go", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fbufio%2Fscan_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fbufio%2Fscan_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbufio%2Fscan_test.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -169,7 +169,6 @@ func genLine(buf *bytes.Buffer, lineNum, n int, addNewline bool) {\n \t\t}\n \t\tbuf.WriteByte('\\n')\n \t}\n-\treturn\n }\n \n // Test the line splitter, including some carriage returns but no long lines."}, {"sha": "1c7c041d680fdddbafeeb14345a29a589dfb5c63", "filename": "libgo/go/builtin/builtin.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fbuiltin%2Fbuiltin.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fbuiltin%2Fbuiltin.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbuiltin%2Fbuiltin.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -85,11 +85,11 @@ type uintptr uintptr\n // byte is an alias for uint8 and is equivalent to uint8 in all ways. It is\n // used, by convention, to distinguish byte values from 8-bit unsigned\n // integer values.\n-type byte byte\n+type byte = uint8\n \n // rune is an alias for int32 and is equivalent to int32 in all ways. It is\n // used, by convention, to distinguish character values from integer values.\n-type rune rune\n+type rune = int32\n \n // iota is a predeclared identifier representing the untyped integer ordinal\n // number of the current const specification in a (usually parenthesized)\n@@ -179,7 +179,7 @@ func cap(v Type) int\n //\tChannel: The channel's buffer is initialized with the specified\n //\tbuffer capacity. If zero, or the size is omitted, the channel is\n //\tunbuffered.\n-func make(Type, size IntegerType) Type\n+func make(t Type, size ...IntegerType) Type\n \n // The new built-in function allocates memory. The first argument is a type,\n // not a value, and the value returned is a pointer to a newly"}, {"sha": "20e42bbbbcaa9736cc3afa3bbd12d5972d2ce96b", "filename": "libgo/go/bytes/buffer.go", "status": "modified", "additions": 88, "deletions": 49, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fbytes%2Fbuffer.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fbytes%2Fbuffer.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbuffer.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -15,10 +15,15 @@ import (\n // A Buffer is a variable-sized buffer of bytes with Read and Write methods.\n // The zero value for Buffer is an empty buffer ready to use.\n type Buffer struct {\n-\tbuf       []byte   // contents are the bytes buf[off : len(buf)]\n-\toff       int      // read at &buf[off], write at &buf[len(buf)]\n-\tbootstrap [64]byte // memory to hold first slice; helps small buffers avoid allocation.\n-\tlastRead  readOp   // last read operation, so that Unread* can work correctly.\n+\tbuf      []byte // contents are the bytes buf[off : len(buf)]\n+\toff      int    // read at &buf[off], write at &buf[len(buf)]\n+\tlastRead readOp // last read operation, so that Unread* can work correctly.\n+\t// FIXME: lastRead can fit in a single byte\n+\n+\t// memory to hold first slice; helps small buffers avoid allocation.\n+\t// FIXME: it would be advisable to align Buffer to cachelines to avoid false\n+\t// sharing.\n+\tbootstrap [64]byte\n }\n \n // The readOp constants describe the last action performed on\n@@ -68,21 +73,36 @@ func (b *Buffer) Cap() int { return cap(b.buf) }\n // but continues to use the same allocated storage.\n // It panics if n is negative or greater than the length of the buffer.\n func (b *Buffer) Truncate(n int) {\n+\tif n == 0 {\n+\t\tb.Reset()\n+\t\treturn\n+\t}\n \tb.lastRead = opInvalid\n-\tswitch {\n-\tcase n < 0 || n > b.Len():\n+\tif n < 0 || n > b.Len() {\n \t\tpanic(\"bytes.Buffer: truncation out of range\")\n-\tcase n == 0:\n-\t\t// Reuse buffer space.\n-\t\tb.off = 0\n \t}\n \tb.buf = b.buf[0 : b.off+n]\n }\n \n // Reset resets the buffer to be empty,\n // but it retains the underlying storage for use by future writes.\n // Reset is the same as Truncate(0).\n-func (b *Buffer) Reset() { b.Truncate(0) }\n+func (b *Buffer) Reset() {\n+\tb.buf = b.buf[:0]\n+\tb.off = 0\n+\tb.lastRead = opInvalid\n+}\n+\n+// tryGrowByReslice is a inlineable version of grow for the fast-case where the\n+// internal buffer only needs to be resliced.\n+// It returns the index where bytes should be written and whether it succeeded.\n+func (b *Buffer) tryGrowByReslice(n int) (int, bool) {\n+\tif l := len(b.buf); l+n <= cap(b.buf) {\n+\t\tb.buf = b.buf[:l+n]\n+\t\treturn l, true\n+\t}\n+\treturn 0, false\n+}\n \n // grow grows the buffer to guarantee space for n more bytes.\n // It returns the index where bytes should be written.\n@@ -91,29 +111,33 @@ func (b *Buffer) grow(n int) int {\n \tm := b.Len()\n \t// If buffer is empty, reset to recover space.\n \tif m == 0 && b.off != 0 {\n-\t\tb.Truncate(0)\n+\t\tb.Reset()\n \t}\n-\tif len(b.buf)+n > cap(b.buf) {\n-\t\tvar buf []byte\n-\t\tif b.buf == nil && n <= len(b.bootstrap) {\n-\t\t\tbuf = b.bootstrap[0:]\n-\t\t} else if m+n <= cap(b.buf)/2 {\n-\t\t\t// We can slide things down instead of allocating a new\n-\t\t\t// slice. We only need m+n <= cap(b.buf) to slide, but\n-\t\t\t// we instead let capacity get twice as large so we\n-\t\t\t// don't spend all our time copying.\n-\t\t\tcopy(b.buf[:], b.buf[b.off:])\n-\t\t\tbuf = b.buf[:m]\n-\t\t} else {\n-\t\t\t// not enough space anywhere\n-\t\t\tbuf = makeSlice(2*cap(b.buf) + n)\n-\t\t\tcopy(buf, b.buf[b.off:])\n-\t\t}\n+\t// Try to grow by means of a reslice.\n+\tif i, ok := b.tryGrowByReslice(n); ok {\n+\t\treturn i\n+\t}\n+\t// Check if we can make use of bootstrap array.\n+\tif b.buf == nil && n <= len(b.bootstrap) {\n+\t\tb.buf = b.bootstrap[:n]\n+\t\treturn 0\n+\t}\n+\tif m+n <= cap(b.buf)/2 {\n+\t\t// We can slide things down instead of allocating a new\n+\t\t// slice. We only need m+n <= cap(b.buf) to slide, but\n+\t\t// we instead let capacity get twice as large so we\n+\t\t// don't spend all our time copying.\n+\t\tcopy(b.buf[:], b.buf[b.off:])\n+\t} else {\n+\t\t// Not enough space anywhere, we need to allocate.\n+\t\tbuf := makeSlice(2*cap(b.buf) + n)\n+\t\tcopy(buf, b.buf[b.off:])\n \t\tb.buf = buf\n-\t\tb.off = 0\n \t}\n-\tb.buf = b.buf[0 : b.off+m+n]\n-\treturn b.off + m\n+\t// Restore b.off and len(b.buf).\n+\tb.off = 0\n+\tb.buf = b.buf[:m+n]\n+\treturn m\n }\n \n // Grow grows the buffer's capacity, if necessary, to guarantee space for\n@@ -134,7 +158,10 @@ func (b *Buffer) Grow(n int) {\n // buffer becomes too large, Write will panic with ErrTooLarge.\n func (b *Buffer) Write(p []byte) (n int, err error) {\n \tb.lastRead = opInvalid\n-\tm := b.grow(len(p))\n+\tm, ok := b.tryGrowByReslice(len(p))\n+\tif !ok {\n+\t\tm = b.grow(len(p))\n+\t}\n \treturn copy(b.buf[m:], p), nil\n }\n \n@@ -143,7 +170,10 @@ func (b *Buffer) Write(p []byte) (n int, err error) {\n // buffer becomes too large, WriteString will panic with ErrTooLarge.\n func (b *Buffer) WriteString(s string) (n int, err error) {\n \tb.lastRead = opInvalid\n-\tm := b.grow(len(s))\n+\tm, ok := b.tryGrowByReslice(len(s))\n+\tif !ok {\n+\t\tm = b.grow(len(s))\n+\t}\n \treturn copy(b.buf[m:], s), nil\n }\n \n@@ -161,7 +191,7 @@ func (b *Buffer) ReadFrom(r io.Reader) (n int64, err error) {\n \tb.lastRead = opInvalid\n \t// If buffer is empty, reset to recover space.\n \tif b.off >= len(b.buf) {\n-\t\tb.Truncate(0)\n+\t\tb.Reset()\n \t}\n \tfor {\n \t\tif free := cap(b.buf) - len(b.buf); free < MinRead {\n@@ -225,7 +255,7 @@ func (b *Buffer) WriteTo(w io.Writer) (n int64, err error) {\n \t\t}\n \t}\n \t// Buffer is now empty; reset.\n-\tb.Truncate(0)\n+\tb.Reset()\n \treturn\n }\n \n@@ -235,7 +265,10 @@ func (b *Buffer) WriteTo(w io.Writer) (n int64, err error) {\n // ErrTooLarge.\n func (b *Buffer) WriteByte(c byte) error {\n \tb.lastRead = opInvalid\n-\tm := b.grow(1)\n+\tm, ok := b.tryGrowByReslice(1)\n+\tif !ok {\n+\t\tm = b.grow(1)\n+\t}\n \tb.buf[m] = c\n \treturn nil\n }\n@@ -250,7 +283,10 @@ func (b *Buffer) WriteRune(r rune) (n int, err error) {\n \t\treturn 1, nil\n \t}\n \tb.lastRead = opInvalid\n-\tm := b.grow(utf8.UTFMax)\n+\tm, ok := b.tryGrowByReslice(utf8.UTFMax)\n+\tif !ok {\n+\t\tm = b.grow(utf8.UTFMax)\n+\t}\n \tn = utf8.EncodeRune(b.buf[m:m+utf8.UTFMax], r)\n \tb.buf = b.buf[:m+n]\n \treturn n, nil\n@@ -264,7 +300,7 @@ func (b *Buffer) Read(p []byte) (n int, err error) {\n \tb.lastRead = opInvalid\n \tif b.off >= len(b.buf) {\n \t\t// Buffer is empty, reset to recover space.\n-\t\tb.Truncate(0)\n+\t\tb.Reset()\n \t\tif len(p) == 0 {\n \t\t\treturn\n \t\t}\n@@ -302,7 +338,7 @@ func (b *Buffer) ReadByte() (byte, error) {\n \tb.lastRead = opInvalid\n \tif b.off >= len(b.buf) {\n \t\t// Buffer is empty, reset to recover space.\n-\t\tb.Truncate(0)\n+\t\tb.Reset()\n \t\treturn 0, io.EOF\n \t}\n \tc := b.buf[b.off]\n@@ -320,7 +356,7 @@ func (b *Buffer) ReadRune() (r rune, size int, err error) {\n \tb.lastRead = opInvalid\n \tif b.off >= len(b.buf) {\n \t\t// Buffer is empty, reset to recover space.\n-\t\tb.Truncate(0)\n+\t\tb.Reset()\n \t\treturn 0, 0, io.EOF\n \t}\n \tc := b.buf[b.off]\n@@ -337,12 +373,12 @@ func (b *Buffer) ReadRune() (r rune, size int, err error) {\n \n // UnreadRune unreads the last rune returned by ReadRune.\n // If the most recent read or write operation on the buffer was\n-// not a ReadRune, UnreadRune returns an error.  (In this regard\n+// not a successful ReadRune, UnreadRune returns an error.  (In this regard\n // it is stricter than UnreadByte, which will unread the last byte\n // from any read operation.)\n func (b *Buffer) UnreadRune() error {\n \tif b.lastRead <= opInvalid {\n-\t\treturn errors.New(\"bytes.Buffer: UnreadRune: previous operation was not ReadRune\")\n+\t\treturn errors.New(\"bytes.Buffer: UnreadRune: previous operation was not a successful ReadRune\")\n \t}\n \tif b.off >= int(b.lastRead) {\n \t\tb.off -= int(b.lastRead)\n@@ -351,12 +387,13 @@ func (b *Buffer) UnreadRune() error {\n \treturn nil\n }\n \n-// UnreadByte unreads the last byte returned by the most recent\n-// read operation. If write has happened since the last read, UnreadByte\n-// returns an error.\n+// UnreadByte unreads the last byte returned by the most recent successful\n+// read operation that read at least one byte. If a write has happened since\n+// the last read, if the last read returned an error, or if the read read zero\n+// bytes, UnreadByte returns an error.\n func (b *Buffer) UnreadByte() error {\n \tif b.lastRead == opInvalid {\n-\t\treturn errors.New(\"bytes.Buffer: UnreadByte: previous operation was not a read\")\n+\t\treturn errors.New(\"bytes.Buffer: UnreadByte: previous operation was not a successful read\")\n \t}\n \tb.lastRead = opInvalid\n \tif b.off > 0 {\n@@ -404,10 +441,12 @@ func (b *Buffer) ReadString(delim byte) (line string, err error) {\n \treturn string(slice), err\n }\n \n-// NewBuffer creates and initializes a new Buffer using buf as its initial\n-// contents. It is intended to prepare a Buffer to read existing data. It\n-// can also be used to size the internal buffer for writing. To do that,\n-// buf should have the desired capacity but a length of zero.\n+// NewBuffer creates and initializes a new Buffer using buf as its\n+// initial contents. The new Buffer takes ownership of buf, and the\n+// caller should not use buf after this call. NewBuffer is intended to\n+// prepare a Buffer to read existing data. It can also be used to size\n+// the internal buffer for writing. To do that, buf should have the\n+// desired capacity but a length of zero.\n //\n // In most cases, new(Buffer) (or just declaring a Buffer variable) is\n // sufficient to initialize a Buffer."}, {"sha": "ce2f01a0ad3f9142b33d43b684f4b0b0c6b6e821", "filename": "libgo/go/bytes/buffer_test.go", "status": "modified", "additions": 71, "deletions": 5, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fbytes%2Fbuffer_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fbytes%2Fbuffer_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbuffer_test.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -6,8 +6,10 @@ package bytes_test\n \n import (\n \t. \"bytes\"\n+\t\"internal/testenv\"\n \t\"io\"\n \t\"math/rand\"\n+\t\"os/exec\"\n \t\"runtime\"\n \t\"testing\"\n \t\"unicode/utf8\"\n@@ -311,6 +313,19 @@ func TestRuneIO(t *testing.T) {\n \n \t// Check that UnreadRune works\n \tbuf.Reset()\n+\n+\t// check at EOF\n+\tif err := buf.UnreadRune(); err == nil {\n+\t\tt.Fatal(\"UnreadRune at EOF: got no error\")\n+\t}\n+\tif _, _, err := buf.ReadRune(); err == nil {\n+\t\tt.Fatal(\"ReadRune at EOF: got no error\")\n+\t}\n+\tif err := buf.UnreadRune(); err == nil {\n+\t\tt.Fatal(\"UnreadRune after ReadRune at EOF: got no error\")\n+\t}\n+\n+\t// check not at EOF\n \tbuf.Write(b)\n \tfor r := rune(0); r < NRune; r++ {\n \t\tr1, size, _ := buf.ReadRune()\n@@ -473,15 +488,34 @@ func TestReadEmptyAtEOF(t *testing.T) {\n \n func TestUnreadByte(t *testing.T) {\n \tb := new(Buffer)\n+\n+\t// check at EOF\n+\tif err := b.UnreadByte(); err == nil {\n+\t\tt.Fatal(\"UnreadByte at EOF: got no error\")\n+\t}\n+\tif _, err := b.ReadByte(); err == nil {\n+\t\tt.Fatal(\"ReadByte at EOF: got no error\")\n+\t}\n+\tif err := b.UnreadByte(); err == nil {\n+\t\tt.Fatal(\"UnreadByte after ReadByte at EOF: got no error\")\n+\t}\n+\n+\t// check not at EOF\n \tb.WriteString(\"abcdefghijklmnopqrstuvwxyz\")\n \n-\t_, err := b.ReadBytes('m')\n-\tif err != nil {\n-\t\tt.Fatalf(\"ReadBytes: %v\", err)\n+\t// after unsuccessful read\n+\tif n, err := b.Read(nil); n != 0 || err != nil {\n+\t\tt.Fatalf(\"Read(nil) = %d,%v; want 0,nil\", n, err)\n+\t}\n+\tif err := b.UnreadByte(); err == nil {\n+\t\tt.Fatal(\"UnreadByte after Read(nil): got no error\")\n \t}\n \n-\terr = b.UnreadByte()\n-\tif err != nil {\n+\t// after successful read\n+\tif _, err := b.ReadBytes('m'); err != nil {\n+\t\tt.Fatalf(\"ReadBytes: %v\", err)\n+\t}\n+\tif err := b.UnreadByte(); err != nil {\n \t\tt.Fatalf(\"UnreadByte: %v\", err)\n \t}\n \tc, err := b.ReadByte()\n@@ -514,6 +548,38 @@ func TestBufferGrowth(t *testing.T) {\n \t}\n }\n \n+// Test that tryGrowByReslice is inlined.\n+// Only execute on \"linux-amd64\" builder in order to avoid breakage.\n+func TestTryGrowByResliceInlined(t *testing.T) {\n+\ttargetBuilder := \"linux-amd64\"\n+\tif testenv.Builder() != targetBuilder {\n+\t\tt.Skipf(\"%q gets executed on %q builder only\", t.Name(), targetBuilder)\n+\t}\n+\tt.Parallel()\n+\tgoBin := testenv.GoToolPath(t)\n+\tout, err := exec.Command(goBin, \"tool\", \"nm\", goBin).CombinedOutput()\n+\tif err != nil {\n+\t\tt.Fatalf(\"go tool nm: %v: %s\", err, out)\n+\t}\n+\t// Verify this doesn't exist:\n+\tsym := \"bytes.(*Buffer).tryGrowByReslice\"\n+\tif Contains(out, []byte(sym)) {\n+\t\tt.Errorf(\"found symbol %q in cmd/go, but should be inlined\", sym)\n+\t}\n+}\n+\n+func BenchmarkWriteByte(b *testing.B) {\n+\tconst n = 4 << 10\n+\tb.SetBytes(n)\n+\tbuf := NewBuffer(make([]byte, n))\n+\tfor i := 0; i < b.N; i++ {\n+\t\tbuf.Reset()\n+\t\tfor i := 0; i < n; i++ {\n+\t\t\tbuf.WriteByte('x')\n+\t\t}\n+\t}\n+}\n+\n func BenchmarkWriteRune(b *testing.B) {\n \tconst n = 4 << 10\n \tconst r = '\u263a'"}, {"sha": "7c878af688cc71462ab4e8bcbfa7cdaf6256f7b2", "filename": "libgo/go/bytes/bytes.go", "status": "modified", "additions": 23, "deletions": 37, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fbytes%2Fbytes.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fbytes%2Fbytes.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbytes.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -46,36 +46,21 @@ func explode(s []byte, n int) [][]byte {\n \treturn a[0:na]\n }\n \n-// Count counts the number of non-overlapping instances of sep in s.\n-// If sep is an empty slice, Count returns 1 + the number of Unicode code points in s.\n-func Count(s, sep []byte) int {\n-\tn := len(sep)\n-\tif n == 0 {\n+// countGeneric actually implements Count\n+func countGeneric(s, sep []byte) int {\n+\t// special case\n+\tif len(sep) == 0 {\n \t\treturn utf8.RuneCount(s) + 1\n \t}\n-\tif n > len(s) {\n-\t\treturn 0\n-\t}\n-\tcount := 0\n-\tc := sep[0]\n-\ti := 0\n-\tt := s[:len(s)-n+1]\n-\tfor i < len(t) {\n-\t\tif t[i] != c {\n-\t\t\to := IndexByte(t[i:], c)\n-\t\t\tif o < 0 {\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t\ti += o\n-\t\t}\n-\t\tif n == 1 || Equal(s[i:i+n], sep) {\n-\t\t\tcount++\n-\t\t\ti += n\n-\t\t\tcontinue\n+\tn := 0\n+\tfor {\n+\t\ti := Index(s, sep)\n+\t\tif i == -1 {\n+\t\t\treturn n\n \t\t}\n-\t\ti++\n+\t\tn++\n+\t\ts = s[i+len(sep):]\n \t}\n-\treturn count\n }\n \n // Contains reports whether subslice is within b.\n@@ -229,20 +214,21 @@ func genSplit(s, sep []byte, sepSave, n int) [][]byte {\n \tif n < 0 {\n \t\tn = Count(s, sep) + 1\n \t}\n-\tc := sep[0]\n-\tstart := 0\n+\n \ta := make([][]byte, n)\n-\tna := 0\n-\tfor i := 0; i+len(sep) <= len(s) && na+1 < n; i++ {\n-\t\tif s[i] == c && (len(sep) == 1 || Equal(s[i:i+len(sep)], sep)) {\n-\t\t\ta[na] = s[start : i+sepSave]\n-\t\t\tna++\n-\t\t\tstart = i + len(sep)\n-\t\t\ti += len(sep) - 1\n+\tn--\n+\ti := 0\n+\tfor i < n {\n+\t\tm := Index(s, sep)\n+\t\tif m < 0 {\n+\t\t\tbreak\n \t\t}\n+\t\ta[i] = s[:m+sepSave]\n+\t\ts = s[m+len(sep):]\n+\t\ti++\n \t}\n-\ta[na] = s[start:]\n-\treturn a[0 : na+1]\n+\ta[i] = s\n+\treturn a[:i+1]\n }\n \n // SplitN slices s into subslices separated by sep and returns a slice of"}, {"sha": "d40c7441e9415d86c8557625b2d456bcaeba85b6", "filename": "libgo/go/bytes/bytes_amd64.go", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fbytes%2Fbytes_amd64.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fbytes%2Fbytes_amd64.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbytes_amd64.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -6,17 +6,19 @@\n \n package bytes\n \n+import \"internal/cpu\"\n+\n //go:noescape\n \n // indexShortStr returns the index of the first instance of c in s, or -1 if c is not present in s.\n // indexShortStr requires 2 <= len(c) <= shortStringLen\n-func indexShortStr(s, c []byte) int // ../runtime/asm_$GOARCH.s\n-func supportAVX2() bool             // ../runtime/asm_$GOARCH.s\n+func indexShortStr(s, c []byte) int  // ../runtime/asm_amd64.s\n+func countByte(s []byte, c byte) int // ../runtime/asm_amd64.s\n \n var shortStringLen int\n \n func init() {\n-\tif supportAVX2() {\n+\tif cpu.X86.HasAVX2 {\n \t\tshortStringLen = 63\n \t} else {\n \t\tshortStringLen = 31\n@@ -96,6 +98,15 @@ func Index(s, sep []byte) int {\n \treturn -1\n }\n \n+// Count counts the number of non-overlapping instances of sep in s.\n+// If sep is an empty slice, Count returns 1 + the number of Unicode code points in s.\n+func Count(s, sep []byte) int {\n+\tif len(sep) == 1 && cpu.X86.HasPOPCNT {\n+\t\treturn countByte(s, sep[0])\n+\t}\n+\treturn countGeneric(s, sep)\n+}\n+\n // primeRK is the prime base used in Rabin-Karp algorithm.\n const primeRK = 16777619\n "}, {"sha": "75a9c36dc42d85408cd346246951a75d21b51475", "filename": "libgo/go/bytes/bytes_generic.go", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fbytes%2Fbytes_generic.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fbytes%2Fbytes_generic.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbytes_generic.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -39,3 +39,9 @@ func Index(s, sep []byte) int {\n \t}\n \treturn -1\n }\n+\n+// Count counts the number of non-overlapping instances of sep in s.\n+// If sep is an empty slice, Count returns 1 + the number of Unicode code points in s.\n+func Count(s, sep []byte) int {\n+\treturn countGeneric(s, sep)\n+}"}, {"sha": "54e013e9ada82011584f15722349d423133bde7d", "filename": "libgo/go/bytes/bytes_s390x.go", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fbytes%2Fbytes_s390x.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fbytes%2Fbytes_s390x.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbytes_s390x.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -99,6 +99,12 @@ func Index(s, sep []byte) int {\n \treturn -1\n }\n \n+// Count counts the number of non-overlapping instances of sep in s.\n+// If sep is an empty slice, Count returns 1 + the number of Unicode code points in s.\n+func Count(s, sep []byte) int {\n+\treturn countGeneric(s, sep)\n+}\n+\n // primeRK is the prime base used in Rabin-Karp algorithm.\n const primeRK = 16777619\n "}, {"sha": "d571eb3ab4924d5793382278b703a339e0544baf", "filename": "libgo/go/bytes/bytes_test.go", "status": "modified", "additions": 146, "deletions": 0, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fbytes%2Fbytes_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fbytes%2Fbytes_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbytes_test.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -401,6 +401,79 @@ func TestIndexRune(t *testing.T) {\n \t}\n }\n \n+// test count of a single byte across page offsets\n+func TestCountByte(t *testing.T) {\n+\tb := make([]byte, 5015) // bigger than a page\n+\twindows := []int{1, 2, 3, 4, 15, 16, 17, 31, 32, 33, 63, 64, 65, 128}\n+\ttestCountWindow := func(i, window int) {\n+\t\tfor j := 0; j < window; j++ {\n+\t\t\tb[i+j] = byte(100)\n+\t\t\tp := Count(b[i:i+window], []byte{100})\n+\t\t\tif p != j+1 {\n+\t\t\t\tt.Errorf(\"TestCountByte.Count(%q, 100) = %d\", b[i:i+window], p)\n+\t\t\t}\n+\t\t\tpGeneric := CountGeneric(b[i:i+window], []byte{100})\n+\t\t\tif pGeneric != j+1 {\n+\t\t\t\tt.Errorf(\"TestCountByte.CountGeneric(%q, 100) = %d\", b[i:i+window], p)\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tmaxWnd := windows[len(windows)-1]\n+\n+\tfor i := 0; i <= 2*maxWnd; i++ {\n+\t\tfor _, window := range windows {\n+\t\t\tif window > len(b[i:]) {\n+\t\t\t\twindow = len(b[i:])\n+\t\t\t}\n+\t\t\ttestCountWindow(i, window)\n+\t\t\tfor j := 0; j < window; j++ {\n+\t\t\t\tb[i+j] = byte(0)\n+\t\t\t}\n+\t\t}\n+\t}\n+\tfor i := 4096 - (maxWnd + 1); i < len(b); i++ {\n+\t\tfor _, window := range windows {\n+\t\t\tif window > len(b[i:]) {\n+\t\t\t\twindow = len(b[i:])\n+\t\t\t}\n+\t\t\ttestCountWindow(i, window)\n+\t\t\tfor j := 0; j < window; j++ {\n+\t\t\t\tb[i+j] = byte(0)\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+// Make sure we don't count bytes outside our window\n+func TestCountByteNoMatch(t *testing.T) {\n+\tb := make([]byte, 5015)\n+\twindows := []int{1, 2, 3, 4, 15, 16, 17, 31, 32, 33, 63, 64, 65, 128}\n+\tfor i := 0; i <= len(b); i++ {\n+\t\tfor _, window := range windows {\n+\t\t\tif window > len(b[i:]) {\n+\t\t\t\twindow = len(b[i:])\n+\t\t\t}\n+\t\t\t// Fill the window with non-match\n+\t\t\tfor j := 0; j < window; j++ {\n+\t\t\t\tb[i+j] = byte(100)\n+\t\t\t}\n+\t\t\t// Try to find something that doesn't exist\n+\t\t\tp := Count(b[i:i+window], []byte{0})\n+\t\t\tif p != 0 {\n+\t\t\t\tt.Errorf(\"TestCountByteNoMatch(%q, 0) = %d\", b[i:i+window], p)\n+\t\t\t}\n+\t\t\tpGeneric := CountGeneric(b[i:i+window], []byte{0})\n+\t\t\tif pGeneric != 0 {\n+\t\t\t\tt.Errorf(\"TestCountByteNoMatch.CountGeneric(%q, 100) = %d\", b[i:i+window], p)\n+\t\t\t}\n+\t\t\tfor j := 0; j < window; j++ {\n+\t\t\t\tb[i+j] = byte(0)\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n var bmbuf []byte\n \n func valName(x int) string {\n@@ -594,6 +667,26 @@ func BenchmarkCountEasy(b *testing.B) {\n \t})\n }\n \n+func BenchmarkCountSingle(b *testing.B) {\n+\tbenchBytes(b, indexSizes, func(b *testing.B, n int) {\n+\t\tbuf := bmbuf[0:n]\n+\t\tstep := 8\n+\t\tfor i := 0; i < len(buf); i += step {\n+\t\t\tbuf[i] = 1\n+\t\t}\n+\t\texpect := (len(buf) + (step - 1)) / step\n+\t\tfor i := 0; i < b.N; i++ {\n+\t\t\tj := Count(buf, []byte{1})\n+\t\t\tif j != expect {\n+\t\t\t\tb.Fatal(\"bad count\", j, expect)\n+\t\t\t}\n+\t\t}\n+\t\tfor i := 0; i < len(buf); i++ {\n+\t\t\tbuf[i] = 0\n+\t\t}\n+\t})\n+}\n+\n type ExplodeTest struct {\n \ts string\n \tn int\n@@ -1437,6 +1530,59 @@ func BenchmarkTrimSpace(b *testing.B) {\n \t}\n }\n \n+func makeBenchInputHard() []byte {\n+\ttokens := [...]string{\n+\t\t\"<a>\", \"<p>\", \"<b>\", \"<strong>\",\n+\t\t\"</a>\", \"</p>\", \"</b>\", \"</strong>\",\n+\t\t\"hello\", \"world\",\n+\t}\n+\tx := make([]byte, 0, 1<<20)\n+\tfor {\n+\t\ti := rand.Intn(len(tokens))\n+\t\tif len(x)+len(tokens[i]) >= 1<<20 {\n+\t\t\tbreak\n+\t\t}\n+\t\tx = append(x, tokens[i]...)\n+\t}\n+\treturn x\n+}\n+\n+var benchInputHard = makeBenchInputHard()\n+\n+func BenchmarkSplitEmptySeparator(b *testing.B) {\n+\tfor i := 0; i < b.N; i++ {\n+\t\tSplit(benchInputHard, nil)\n+\t}\n+}\n+\n+func BenchmarkSplitSingleByteSeparator(b *testing.B) {\n+\tsep := []byte(\"/\")\n+\tfor i := 0; i < b.N; i++ {\n+\t\tSplit(benchInputHard, sep)\n+\t}\n+}\n+\n+func BenchmarkSplitMultiByteSeparator(b *testing.B) {\n+\tsep := []byte(\"hello\")\n+\tfor i := 0; i < b.N; i++ {\n+\t\tSplit(benchInputHard, sep)\n+\t}\n+}\n+\n+func BenchmarkSplitNSingleByteSeparator(b *testing.B) {\n+\tsep := []byte(\"/\")\n+\tfor i := 0; i < b.N; i++ {\n+\t\tSplitN(benchInputHard, sep, 10)\n+\t}\n+}\n+\n+func BenchmarkSplitNMultiByteSeparator(b *testing.B) {\n+\tsep := []byte(\"hello\")\n+\tfor i := 0; i < b.N; i++ {\n+\t\tSplitN(benchInputHard, sep, 10)\n+\t}\n+}\n+\n func BenchmarkRepeat(b *testing.B) {\n \tfor i := 0; i < b.N; i++ {\n \t\tRepeat([]byte(\"-\"), 80)"}, {"sha": "93972770ab2449a19e7eeb452999507603c4c397", "filename": "libgo/go/bytes/example_test.go", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fbytes%2Fexample_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fbytes%2Fexample_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fexample_test.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -30,6 +30,15 @@ func ExampleBuffer_reader() {\n \t// Output: Gophers rule!\n }\n \n+func ExampleBuffer_Grow() {\n+\tvar b bytes.Buffer\n+\tb.Grow(64)\n+\tbb := b.Bytes()\n+\tb.Write([]byte(\"64 bytes or fewer\"))\n+\tfmt.Printf(\"%q\", bb[:b.Len()])\n+\t// Output: \"64 bytes or fewer\"\n+}\n+\n func ExampleCompare() {\n \t// Interpret Compare's result by comparing it to zero.\n \tvar a, b []byte"}, {"sha": "823c8b09eef8fc048a7b93bccbbdcfbc501883e2", "filename": "libgo/go/bytes/export_test.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fbytes%2Fexport_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fbytes%2Fexport_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fexport_test.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -7,3 +7,4 @@ package bytes\n // Export func for testing\n var IndexBytePortable = indexBytePortable\n var EqualPortable = equalPortable\n+var CountGeneric = countGeneric"}, {"sha": "7122a9dbbebae6f841b84248b9dc30cba8cfb00a", "filename": "libgo/go/cmd/cgo/ast.go", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fcgo%2Fast.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fcgo%2Fast.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fast.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -17,8 +17,8 @@ import (\n \t\"strings\"\n )\n \n-func parse(name string, flags parser.Mode) *ast.File {\n-\tast1, err := parser.ParseFile(fset, name, nil, flags)\n+func parse(name string, src []byte, flags parser.Mode) *ast.File {\n+\tast1, err := parser.ParseFile(fset, name, src, flags)\n \tif err != nil {\n \t\tif list, ok := err.(scanner.ErrorList); ok {\n \t\t\t// If err is a scanner.ErrorList, its String will print just\n@@ -39,12 +39,12 @@ func sourceLine(n ast.Node) int {\n \treturn fset.Position(n.Pos()).Line\n }\n \n-// ReadGo populates f with information learned from reading the\n-// Go source file with the given file name. It gathers the C preamble\n+// ParseGo populates f with information learned from the Go source code\n+// which was read from the named file. It gathers the C preamble\n // attached to the import \"C\" comment, a list of references to C.xxx,\n // a list of exported functions, and the actual AST, to be rewritten and\n // printed.\n-func (f *File) ReadGo(name string) {\n+func (f *File) ParseGo(name string, src []byte) {\n \t// Create absolute path for file, so that it will be used in error\n \t// messages and recorded in debug line number information.\n \t// This matches the rest of the toolchain. See golang.org/issue/5122.\n@@ -58,8 +58,8 @@ func (f *File) ReadGo(name string) {\n \t// so we use ast1 to look for the doc comments on import \"C\"\n \t// and on exported functions, and we use ast2 for translating\n \t// and reprinting.\n-\tast1 := parse(name, parser.ParseComments)\n-\tast2 := parse(name, 0)\n+\tast1 := parse(name, src, parser.ParseComments)\n+\tast2 := parse(name, src, 0)\n \n \tf.Package = ast1.Name.Name\n \tf.Name = make(map[string]*Name)"}, {"sha": "b2388829a8796aca2a9fa97ac105fef7fe48d446", "filename": "libgo/go/cmd/cgo/doc.go", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fcgo%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fcgo%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fdoc.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -14,27 +14,27 @@ as C.stdout, or functions such as C.putchar.\n \n If the import of \"C\" is immediately preceded by a comment, that\n comment, called the preamble, is used as a header when compiling\n-the C parts of the package.  For example:\n+the C parts of the package. For example:\n \n \t// #include <stdio.h>\n \t// #include <errno.h>\n \timport \"C\"\n \n The preamble may contain any C code, including function and variable\n-declarations and definitions.  These may then be referred to from Go\n-code as though they were defined in the package \"C\".  All names\n+declarations and definitions. These may then be referred to from Go\n+code as though they were defined in the package \"C\". All names\n declared in the preamble may be used, even if they start with a\n-lower-case letter.  Exception: static variables in the preamble may\n+lower-case letter. Exception: static variables in the preamble may\n not be referenced from Go code; static functions are permitted.\n \n-See $GOROOT/misc/cgo/stdio and $GOROOT/misc/cgo/gmp for examples.  See\n+See $GOROOT/misc/cgo/stdio and $GOROOT/misc/cgo/gmp for examples. See\n \"C? Go? Cgo!\" for an introduction to using cgo:\n https://golang.org/doc/articles/c_go_cgo.html.\n \n CFLAGS, CPPFLAGS, CXXFLAGS, FFLAGS and LDFLAGS may be defined with pseudo\n #cgo directives within these comments to tweak the behavior of the C, C++\n-or Fortran compiler.  Values defined in multiple directives are concatenated\n-together.  The directive can include a list of build constraints limiting its\n+or Fortran compiler. Values defined in multiple directives are concatenated\n+together. The directive can include a list of build constraints limiting its\n effect to systems satisfying one of the constraints\n (see https://golang.org/pkg/go/build/#hdr-Build_Constraints for details about the constraint syntax).\n For example:\n@@ -57,16 +57,16 @@ The default pkg-config tool may be changed by setting the PKG_CONFIG environment\n \n When building, the CGO_CFLAGS, CGO_CPPFLAGS, CGO_CXXFLAGS, CGO_FFLAGS and\n CGO_LDFLAGS environment variables are added to the flags derived from\n-these directives.  Package-specific flags should be set using the\n+these directives. Package-specific flags should be set using the\n directives, not the environment variables, so that builds work in\n unmodified environments.\n \n All the cgo CPPFLAGS and CFLAGS directives in a package are concatenated and\n-used to compile C files in that package.  All the CPPFLAGS and CXXFLAGS\n+used to compile C files in that package. All the CPPFLAGS and CXXFLAGS\n directives in a package are concatenated and used to compile C++ files in that\n-package.  All the CPPFLAGS and FFLAGS directives in a package are concatenated\n-and used to compile Fortran files in that package.  All the LDFLAGS directives\n-in any package in the program are concatenated and used at link time.  All the\n+package. All the CPPFLAGS and FFLAGS directives in a package are concatenated\n+and used to compile Fortran files in that package. All the LDFLAGS directives\n+in any package in the program are concatenated and used at link time. All the\n pkg-config directives are concatenated and sent to pkg-config simultaneously\n to add to each appropriate set of command-line flags.\n \n@@ -84,27 +84,27 @@ Will be expanded to:\n \n When the Go tool sees that one or more Go files use the special import\n \"C\", it will look for other non-Go files in the directory and compile\n-them as part of the Go package.  Any .c, .s, or .S files will be\n-compiled with the C compiler.  Any .cc, .cpp, or .cxx files will be\n-compiled with the C++ compiler.  Any .f, .F, .for or .f90 files will be\n+them as part of the Go package. Any .c, .s, or .S files will be\n+compiled with the C compiler. Any .cc, .cpp, or .cxx files will be\n+compiled with the C++ compiler. Any .f, .F, .for or .f90 files will be\n compiled with the fortran compiler. Any .h, .hh, .hpp, or .hxx files will\n not be compiled separately, but, if these header files are changed,\n-the C and C++ files will be recompiled.  The default C and C++\n+the C and C++ files will be recompiled. The default C and C++\n compilers may be changed by the CC and CXX environment variables,\n respectively; those environment variables may include command line\n options.\n \n The cgo tool is enabled by default for native builds on systems where\n-it is expected to work.  It is disabled by default when\n-cross-compiling.  You can control this by setting the CGO_ENABLED\n+it is expected to work. It is disabled by default when\n+cross-compiling. You can control this by setting the CGO_ENABLED\n environment variable when running the go tool: set it to 1 to enable\n-the use of cgo, and to 0 to disable it.  The go tool will set the\n+the use of cgo, and to 0 to disable it. The go tool will set the\n build constraint \"cgo\" if cgo is enabled.\n \n When cross-compiling, you must specify a C cross-compiler for cgo to\n-use.  You can do this by setting the CC_FOR_TARGET environment\n+use. You can do this by setting the CC_FOR_TARGET environment\n variable when building the toolchain using make.bash, or by setting\n-the CC environment variable any time you run the go tool.  The\n+the CC environment variable any time you run the go tool. The\n CXX_FOR_TARGET and CXX environment variables work in a similar way for\n C++ code.\n \n@@ -138,7 +138,7 @@ C's union types are represented as a Go byte array with the same length.\n Go structs cannot embed fields with C types.\n \n Go code cannot refer to zero-sized fields that occur at the end of\n-non-empty C structs.  To get the address of such a field (which is the\n+non-empty C structs. To get the address of such a field (which is the\n only operation you can do with a zero-sized field) you must take the\n address of the struct and add the size of the struct.\n \n@@ -150,7 +150,7 @@ is different from the same C type used in another.\n Any C function (even void functions) may be called in a multiple\n assignment context to retrieve both the return value (if any) and the\n C errno variable as an error (use _ to skip the result value if the\n-function returns void).  For example:\n+function returns void). For example:\n \n \tn, err = C.sqrt(-1)\n \t_, err := C.voidFunc()\n@@ -187,11 +187,11 @@ received from Go. For example:\n In C, a function argument written as a fixed size array\n actually requires a pointer to the first element of the array.\n C compilers are aware of this calling convention and adjust\n-the call accordingly, but Go cannot.  In Go, you must pass\n+the call accordingly, but Go cannot. In Go, you must pass\n the pointer to the first element explicitly: C.f(&C.x[0]).\n \n A few special functions convert between Go and C types\n-by making copies of the data.  In pseudo-Go definitions:\n+by making copies of the data. In pseudo-Go definitions:\n \n \t// Go string to C string\n \t// The C string is allocated in the C heap using malloc.\n@@ -253,50 +253,50 @@ must be placed in preambles in other files, or in C source files.\n Passing pointers\n \n Go is a garbage collected language, and the garbage collector needs to\n-know the location of every pointer to Go memory.  Because of this,\n+know the location of every pointer to Go memory. Because of this,\n there are restrictions on passing pointers between Go and C.\n \n In this section the term Go pointer means a pointer to memory\n allocated by Go (such as by using the & operator or calling the\n predefined new function) and the term C pointer means a pointer to\n-memory allocated by C (such as by a call to C.malloc).  Whether a\n+memory allocated by C (such as by a call to C.malloc). Whether a\n pointer is a Go pointer or a C pointer is a dynamic property\n determined by how the memory was allocated; it has nothing to do with\n the type of the pointer.\n \n Go code may pass a Go pointer to C provided the Go memory to which it\n-points does not contain any Go pointers.  The C code must preserve\n+points does not contain any Go pointers. The C code must preserve\n this property: it must not store any Go pointers in Go memory, even\n-temporarily.  When passing a pointer to a field in a struct, the Go\n+temporarily. When passing a pointer to a field in a struct, the Go\n memory in question is the memory occupied by the field, not the entire\n-struct.  When passing a pointer to an element in an array or slice,\n+struct. When passing a pointer to an element in an array or slice,\n the Go memory in question is the entire array or the entire backing\n array of the slice.\n \n C code may not keep a copy of a Go pointer after the call returns.\n \n-A Go function called by C code may not return a Go pointer.  A Go\n+A Go function called by C code may not return a Go pointer. A Go\n function called by C code may take C pointers as arguments, and it may\n store non-pointer or C pointer data through those pointers, but it may\n-not store a Go pointer in memory pointed to by a C pointer.  A Go\n+not store a Go pointer in memory pointed to by a C pointer. A Go\n function called by C code may take a Go pointer as an argument, but it\n must preserve the property that the Go memory to which it points does\n not contain any Go pointers.\n \n-Go code may not store a Go pointer in C memory.  C code may store Go\n+Go code may not store a Go pointer in C memory. C code may store Go\n pointers in C memory, subject to the rule above: it must stop storing\n the Go pointer when the C function returns.\n \n-These rules are checked dynamically at runtime.  The checking is\n+These rules are checked dynamically at runtime. The checking is\n controlled by the cgocheck setting of the GODEBUG environment\n-variable.  The default setting is GODEBUG=cgocheck=1, which implements\n-reasonably cheap dynamic checks.  These checks may be disabled\n-entirely using GODEBUG=cgocheck=0.  Complete checking of pointer\n+variable. The default setting is GODEBUG=cgocheck=1, which implements\n+reasonably cheap dynamic checks. These checks may be disabled\n+entirely using GODEBUG=cgocheck=0. Complete checking of pointer\n handling, at some cost in run time, is available via GODEBUG=cgocheck=2.\n \n It is possible to defeat this enforcement by using the unsafe package,\n and of course there is nothing stopping the C code from doing anything\n-it likes.  However, programs that break these rules are likely to fail\n+it likes. However, programs that break these rules are likely to fail\n in unexpected and unpredictable ways.\n \n Using cgo directly\n@@ -499,7 +499,7 @@ Here is a _cgo_gotypes.go containing definitions for needed C types:\n \ttype _Ctype_void [0]byte\n \n The _cgo_gotypes.go file also contains the definitions of the\n-functions.  They all have similar bodies that invoke runtime\u00b7cgocall\n+functions. They all have similar bodies that invoke runtime\u00b7cgocall\n to make a switch from the Go runtime world to the system C (GCC-based)\n world.\n \n@@ -835,7 +835,7 @@ to avoid conflicts), write the go.o file to that directory, and invoke\n the host linker. The default value for the host linker is $CC, split\n into fields, or else \"gcc\". The specific host linker command line can\n be overridden using command line flags: cmd/link -extld=clang\n--extldflags='-ggdb -O3'.  If any package in a build includes a .cc or\n+-extldflags='-ggdb -O3'. If any package in a build includes a .cc or\n other file compiled by the C++ compiler, the go tool will use the\n -extld option to set the host linker to the C++ compiler.\n "}, {"sha": "03239a0fc0d05cface605d552ea704cf7b8bc396", "filename": "libgo/go/cmd/cgo/gcc.go", "status": "modified", "additions": 360, "deletions": 104, "changes": 464, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fcgo%2Fgcc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fcgo%2Fgcc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fgcc.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -20,6 +20,7 @@ import (\n \t\"go/ast\"\n \t\"go/parser\"\n \t\"go/token\"\n+\t\"math\"\n \t\"os\"\n \t\"strconv\"\n \t\"strings\"\n@@ -259,26 +260,26 @@ func (p *Package) guessKinds(f *File) []*Name {\n \t\t// If we've already found this name as a #define\n \t\t// and we can translate it as a constant value, do so.\n \t\tif n.Define != \"\" {\n-\t\t\tisConst := false\n-\t\t\tif _, err := strconv.Atoi(n.Define); err == nil {\n-\t\t\t\tisConst = true\n-\t\t\t} else if n.Define[0] == '\"' || n.Define[0] == '\\'' {\n-\t\t\t\tif _, err := parser.ParseExpr(n.Define); err == nil {\n-\t\t\t\t\tisConst = true\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tif isConst {\n-\t\t\t\tn.Kind = \"const\"\n+\t\t\tif i, err := strconv.ParseInt(n.Define, 0, 64); err == nil {\n+\t\t\t\tn.Kind = \"iconst\"\n \t\t\t\t// Turn decimal into hex, just for consistency\n \t\t\t\t// with enum-derived constants. Otherwise\n \t\t\t\t// in the cgo -godefs output half the constants\n \t\t\t\t// are in hex and half are in whatever the #define used.\n-\t\t\t\ti, err := strconv.ParseInt(n.Define, 0, 64)\n-\t\t\t\tif err == nil {\n-\t\t\t\t\tn.Const = fmt.Sprintf(\"%#x\", i)\n-\t\t\t\t} else {\n+\t\t\t\tn.Const = fmt.Sprintf(\"%#x\", i)\n+\t\t\t} else if n.Define[0] == '\\'' {\n+\t\t\t\tif _, err := parser.ParseExpr(n.Define); err == nil {\n+\t\t\t\t\tn.Kind = \"iconst\"\n \t\t\t\t\tn.Const = n.Define\n \t\t\t\t}\n+\t\t\t} else if n.Define[0] == '\"' {\n+\t\t\t\tif _, err := parser.ParseExpr(n.Define); err == nil {\n+\t\t\t\t\tn.Kind = \"sconst\"\n+\t\t\t\t\tn.Const = n.Define\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tif n.IsConst() {\n \t\t\t\tcontinue\n \t\t\t}\n \n@@ -287,11 +288,10 @@ func (p *Package) guessKinds(f *File) []*Name {\n \t\t\t}\n \t\t}\n \n-\t\tneedType = append(needType, n)\n-\n \t\t// If this is a struct, union, or enum type name, no need to guess the kind.\n \t\tif strings.HasPrefix(n.C, \"struct \") || strings.HasPrefix(n.C, \"union \") || strings.HasPrefix(n.C, \"enum \") {\n \t\t\tn.Kind = \"type\"\n+\t\t\tneedType = append(needType, n)\n \t\t\tcontinue\n \t\t}\n \n@@ -317,14 +317,24 @@ func (p *Package) guessKinds(f *File) []*Name {\n \t//\tvoid __cgo_f_xxx_1(void) { __typeof__(name) *__cgo_undefined__; }\n \t//\t#line xxx \"not-type\"\n \t//\tvoid __cgo_f_xxx_2(void) { name *__cgo_undefined__; }\n-\t//\t#line xxx \"not-const\"\n+\t//\t#line xxx \"not-int-const\"\n \t//\tvoid __cgo_f_xxx_3(void) { enum { __cgo_undefined__ = (name)*1 }; }\n+\t//\t#line xxx \"not-num-const\"\n+\t//\tvoid __cgo_f_xxx_4(void) { static const double x = (name); }\n+\t//\t#line xxx \"not-str-lit\"\n+\t//\tvoid __cgo_f_xxx_5(void) { static const char x[] = (name); }\n+\t//\t#line xxx \"not-signed-int-const\"\n+\t//\t#if 0 < -(name)\n+\t//\t#line xxx \"not-signed-int-const\"\n+\t//\t#error found unsigned int\n+\t//\t#endif\n \t//\n \t// If we see an error at not-declared:xxx, the corresponding name is not declared.\n \t// If we see an error at not-type:xxx, the corresponding name is a type.\n-\t// If we see an error at not-const:xxx, the corresponding name is not an integer constant.\n-\t// If we see no errors, we assume the name is an expression but not a constant\n-\t// (so a variable or a function).\n+\t// If we see an error at not-int-const:xxx, the corresponding name is not an integer constant.\n+\t// If we see an error at not-num-const:xxx, the corresponding name is not a number constant.\n+\t// If we see an error at not-str-lit:xxx, the corresponding name is not a string literal.\n+\t// If we see an error at not-signed-int-const:xxx, the corresponding name is not a signed integer literal.\n \t//\n \t// The specific input forms are chosen so that they are valid C syntax regardless of\n \t// whether name denotes a type or an expression.\n@@ -338,11 +348,24 @@ func (p *Package) guessKinds(f *File) []*Name {\n \t\t\t\"void __cgo_f_%d_1(void) { __typeof__(%s) *__cgo_undefined__; }\\n\"+\n \t\t\t\"#line %d \\\"not-type\\\"\\n\"+\n \t\t\t\"void __cgo_f_%d_2(void) { %s *__cgo_undefined__; }\\n\"+\n-\t\t\t\"#line %d \\\"not-const\\\"\\n\"+\n-\t\t\t\"void __cgo_f_%d_3(void) { enum { __cgo__undefined__ = (%s)*1 }; }\\n\",\n+\t\t\t\"#line %d \\\"not-int-const\\\"\\n\"+\n+\t\t\t\"void __cgo_f_%d_3(void) { enum { __cgo_undefined__ = (%s)*1 }; }\\n\"+\n+\t\t\t\"#line %d \\\"not-num-const\\\"\\n\"+\n+\t\t\t\"void __cgo_f_%d_4(void) { static const double x = (%s); }\\n\"+\n+\t\t\t\"#line %d \\\"not-str-lit\\\"\\n\"+\n+\t\t\t\"void __cgo_f_%d_5(void) { static const char s[] = (%s); }\\n\"+\n+\t\t\t\"#line %d \\\"not-signed-int-const\\\"\\n\"+\n+\t\t\t\"#if 0 < (%s)\\n\"+\n+\t\t\t\"#line %d \\\"not-signed-int-const\\\"\\n\"+\n+\t\t\t\"#error found unsigned int\\n\"+\n+\t\t\t\"#endif\\n\",\n+\t\t\ti+1, i+1, n.C,\n+\t\t\ti+1, i+1, n.C,\n \t\t\ti+1, i+1, n.C,\n \t\t\ti+1, i+1, n.C,\n-\t\t\ti+1, i+1, n.C)\n+\t\t\ti+1, i+1, n.C,\n+\t\t\ti+1, n.C, i+1,\n+\t\t)\n \t}\n \tfmt.Fprintf(&b, \"#line 1 \\\"completed\\\"\\n\"+\n \t\t\"int __cgo__1 = __cgo__2;\\n\")\n@@ -356,13 +379,23 @@ func (p *Package) guessKinds(f *File) []*Name {\n \tsniff := make([]int, len(names))\n \tconst (\n \t\tnotType = 1 << iota\n-\t\tnotConst\n+\t\tnotIntConst\n+\t\tnotNumConst\n+\t\tnotStrLiteral\n \t\tnotDeclared\n+\t\tnotSignedIntConst\n \t)\n+\tsawUnmatchedErrors := false\n \tfor _, line := range strings.Split(stderr, \"\\n\") {\n-\t\tif !strings.Contains(line, \": error:\") {\n-\t\t\t// we only care about errors.\n-\t\t\t// we tried to turn off warnings on the command line, but one never knows.\n+\t\t// Ignore warnings and random comments, with one\n+\t\t// exception: newer GCC versions will sometimes emit\n+\t\t// an error on a macro #define with a note referring\n+\t\t// to where the expansion occurs. We care about where\n+\t\t// the expansion occurs, so in that case treat the note\n+\t\t// as an error.\n+\t\tisError := strings.Contains(line, \": error:\")\n+\t\tisErrorNote := strings.Contains(line, \": note:\") && sawUnmatchedErrors\n+\t\tif !isError && !isErrorNote {\n \t\t\tcontinue\n \t\t}\n \n@@ -380,6 +413,9 @@ func (p *Package) guessKinds(f *File) []*Name {\n \t\ti, _ := strconv.Atoi(line[c1+1 : c2])\n \t\ti--\n \t\tif i < 0 || i >= len(names) {\n+\t\t\tif isError {\n+\t\t\t\tsawUnmatchedErrors = true\n+\t\t\t}\n \t\t\tcontinue\n \t\t}\n \n@@ -395,24 +431,52 @@ func (p *Package) guessKinds(f *File) []*Name {\n \t\t\tsniff[i] |= notDeclared\n \t\tcase \"not-type\":\n \t\t\tsniff[i] |= notType\n-\t\tcase \"not-const\":\n-\t\t\tsniff[i] |= notConst\n+\t\tcase \"not-int-const\":\n+\t\t\tsniff[i] |= notIntConst\n+\t\tcase \"not-num-const\":\n+\t\t\tsniff[i] |= notNumConst\n+\t\tcase \"not-str-lit\":\n+\t\t\tsniff[i] |= notStrLiteral\n+\t\tcase \"not-signed-int-const\":\n+\t\t\tsniff[i] |= notSignedIntConst\n+\t\tdefault:\n+\t\t\tif isError {\n+\t\t\t\tsawUnmatchedErrors = true\n+\t\t\t}\n+\t\t\tcontinue\n \t\t}\n+\n+\t\tsawUnmatchedErrors = false\n \t}\n \n \tif !completed {\n \t\tfatalf(\"%s did not produce error at completed:1\\non input:\\n%s\\nfull error output:\\n%s\", p.gccBaseCmd()[0], b.Bytes(), stderr)\n \t}\n \n \tfor i, n := range names {\n-\t\tswitch sniff[i] {\n+\t\tswitch sniff[i] &^ notSignedIntConst {\n \t\tdefault:\n-\t\t\terror_(token.NoPos, \"could not determine kind of name for C.%s\", fixGo(n.Go))\n-\t\tcase notType:\n-\t\t\tn.Kind = \"const\"\n-\t\tcase notConst:\n+\t\t\tvar tpos token.Pos\n+\t\t\tfor _, ref := range f.Ref {\n+\t\t\t\tif ref.Name == n {\n+\t\t\t\t\ttpos = ref.Pos()\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\terror_(tpos, \"could not determine kind of name for C.%s\", fixGo(n.Go))\n+\t\tcase notStrLiteral | notType:\n+\t\t\tif sniff[i]&notSignedIntConst != 0 {\n+\t\t\t\tn.Kind = \"uconst\"\n+\t\t\t} else {\n+\t\t\t\tn.Kind = \"iconst\"\n+\t\t\t}\n+\t\tcase notIntConst | notStrLiteral | notType:\n+\t\t\tn.Kind = \"fconst\"\n+\t\tcase notIntConst | notNumConst | notType:\n+\t\t\tn.Kind = \"sconst\"\n+\t\tcase notIntConst | notNumConst | notStrLiteral:\n \t\t\tn.Kind = \"type\"\n-\t\tcase notConst | notType:\n+\t\tcase notIntConst | notNumConst | notStrLiteral | notType:\n \t\t\tn.Kind = \"not-type\"\n \t\t}\n \t}\n@@ -450,18 +514,16 @@ func (p *Package) loadDWARF(f *File, names []*Name) {\n \tb.WriteString(\"#line 1 \\\"cgo-dwarf-inference\\\"\\n\")\n \tfor i, n := range names {\n \t\tfmt.Fprintf(&b, \"__typeof__(%s) *__cgo__%d;\\n\", n.C, i)\n-\t\tif n.Kind == \"const\" {\n+\t\tif n.Kind == \"iconst\" || n.Kind == \"uconst\" {\n \t\t\tfmt.Fprintf(&b, \"enum { __cgo_enum__%d = %s };\\n\", i, n.C)\n \t\t}\n \t}\n \n-\t// Apple's LLVM-based gcc does not include the enumeration\n-\t// names and values in its DWARF debug output. In case we're\n-\t// using such a gcc, create a data block initialized with the values.\n-\t// We can read them out of the object file.\n-\tfmt.Fprintf(&b, \"long long __cgodebug_data[] = {\\n\")\n+\t// We create a data block initialized with the values,\n+\t// so we can read them out of the object file.\n+\tfmt.Fprintf(&b, \"long long __cgodebug_ints[] = {\\n\")\n \tfor _, n := range names {\n-\t\tif n.Kind == \"const\" {\n+\t\tif n.Kind == \"iconst\" || n.Kind == \"uconst\" {\n \t\t\tfmt.Fprintf(&b, \"\\t%s,\\n\", n.C)\n \t\t} else {\n \t\t\tfmt.Fprintf(&b, \"\\t0,\\n\")\n@@ -475,15 +537,30 @@ func (p *Package) loadDWARF(f *File, names []*Name) {\n \tfmt.Fprintf(&b, \"\\t1\\n\")\n \tfmt.Fprintf(&b, \"};\\n\")\n \n-\td, bo, debugData := p.gccDebug(b.Bytes())\n-\tenumVal := make([]int64, len(debugData)/8)\n-\tfor i := range enumVal {\n-\t\tenumVal[i] = int64(bo.Uint64(debugData[i*8:]))\n+\t// do the same work for floats.\n+\tfmt.Fprintf(&b, \"double __cgodebug_floats[] = {\\n\")\n+\tfor _, n := range names {\n+\t\tif n.Kind == \"fconst\" {\n+\t\t\tfmt.Fprintf(&b, \"\\t%s,\\n\", n.C)\n+\t\t} else {\n+\t\t\tfmt.Fprintf(&b, \"\\t0,\\n\")\n+\t\t}\n+\t}\n+\tfmt.Fprintf(&b, \"\\t1\\n\")\n+\tfmt.Fprintf(&b, \"};\\n\")\n+\n+\t// do the same work for strings.\n+\tfor i, n := range names {\n+\t\tif n.Kind == \"sconst\" {\n+\t\t\tfmt.Fprintf(&b, \"const char __cgodebug_str__%d[] = %s;\\n\", i, n.C)\n+\t\t\tfmt.Fprintf(&b, \"const unsigned long long __cgodebug_strlen__%d = sizeof(%s)-1;\\n\", i, n.C)\n+\t\t}\n \t}\n \n+\td, ints, floats, strs := p.gccDebug(b.Bytes(), len(names))\n+\n \t// Scan DWARF info for top-level TagVariable entries with AttrName __cgo__i.\n \ttypes := make([]dwarf.Type, len(names))\n-\tenums := make([]dwarf.Offset, len(names))\n \tnameToIndex := make(map[*Name]int)\n \tfor i, n := range names {\n \t\tnameToIndex[n] = i\n@@ -502,26 +579,6 @@ func (p *Package) loadDWARF(f *File, names []*Name) {\n \t\t\tbreak\n \t\t}\n \t\tswitch e.Tag {\n-\t\tcase dwarf.TagEnumerationType:\n-\t\t\toffset := e.Offset\n-\t\t\tfor {\n-\t\t\t\te, err := r.Next()\n-\t\t\t\tif err != nil {\n-\t\t\t\t\tfatalf(\"reading DWARF entry: %s\", err)\n-\t\t\t\t}\n-\t\t\t\tif e.Tag == 0 {\n-\t\t\t\t\tbreak\n-\t\t\t\t}\n-\t\t\t\tif e.Tag == dwarf.TagEnumerator {\n-\t\t\t\t\tentryName := e.Val(dwarf.AttrName).(string)\n-\t\t\t\t\tif strings.HasPrefix(entryName, \"__cgo_enum__\") {\n-\t\t\t\t\t\tn, _ := strconv.Atoi(entryName[len(\"__cgo_enum__\"):])\n-\t\t\t\t\t\tif 0 <= n && n < len(names) {\n-\t\t\t\t\t\t\tenums[n] = offset\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n \t\tcase dwarf.TagVariable:\n \t\t\tname, _ := e.Val(dwarf.AttrName).(string)\n \t\t\ttypOff, _ := e.Val(dwarf.AttrType).(dwarf.Offset)\n@@ -548,15 +605,7 @@ func (p *Package) loadDWARF(f *File, names []*Name) {\n \t\t\tif err != nil {\n \t\t\t\tfatalf(\"malformed __cgo__ name: %s\", name)\n \t\t\t}\n-\t\t\tif enums[i] != 0 {\n-\t\t\t\tt, err := d.Type(enums[i])\n-\t\t\t\tif err != nil {\n-\t\t\t\t\tfatalf(\"loading DWARF type: %s\", err)\n-\t\t\t\t}\n-\t\t\t\ttypes[i] = t\n-\t\t\t} else {\n-\t\t\t\ttypes[i] = t.Type\n-\t\t\t}\n+\t\t\ttypes[i] = t.Type\n \t\t}\n \t\tif e.Tag != dwarf.TagCompileUnit {\n \t\t\tr.SkipChildren()\n@@ -580,17 +629,23 @@ func (p *Package) loadDWARF(f *File, names []*Name) {\n \t\t\tn.FuncType = conv.FuncType(f, pos)\n \t\t} else {\n \t\t\tn.Type = conv.Type(types[i], pos)\n-\t\t\tif enums[i] != 0 && n.Type.EnumValues != nil {\n-\t\t\t\tk := fmt.Sprintf(\"__cgo_enum__%d\", i)\n-\t\t\t\tn.Kind = \"const\"\n-\t\t\t\tn.Const = fmt.Sprintf(\"%#x\", n.Type.EnumValues[k])\n-\t\t\t\t// Remove injected enum to ensure the value will deep-compare\n-\t\t\t\t// equally in future loads of the same constant.\n-\t\t\t\tdelete(n.Type.EnumValues, k)\n-\t\t\t}\n-\t\t\t// Prefer debug data over DWARF debug output, if we have it.\n-\t\t\tif n.Kind == \"const\" && i < len(enumVal) {\n-\t\t\t\tn.Const = fmt.Sprintf(\"%#x\", enumVal[i])\n+\t\t\tswitch n.Kind {\n+\t\t\tcase \"iconst\":\n+\t\t\t\tif i < len(ints) {\n+\t\t\t\t\tn.Const = fmt.Sprintf(\"%#x\", ints[i])\n+\t\t\t\t}\n+\t\t\tcase \"uconst\":\n+\t\t\t\tif i < len(ints) {\n+\t\t\t\t\tn.Const = fmt.Sprintf(\"%#x\", uint64(ints[i]))\n+\t\t\t\t}\n+\t\t\tcase \"fconst\":\n+\t\t\t\tif i < len(floats) {\n+\t\t\t\t\tn.Const = fmt.Sprintf(\"%f\", floats[i])\n+\t\t\t\t}\n+\t\t\tcase \"sconst\":\n+\t\t\t\tif i < len(strs) {\n+\t\t\t\t\tn.Const = fmt.Sprintf(\"%q\", strs[i])\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tconv.FinishType(pos)\n@@ -1069,7 +1124,7 @@ func (p *Package) rewriteRef(f *File) {\n \t// are trying to do a ,err call. Also check that\n \t// functions are only used in calls.\n \tfor _, r := range f.Ref {\n-\t\tif r.Name.Kind == \"const\" && r.Name.Const == \"\" {\n+\t\tif r.Name.IsConst() && r.Name.Const == \"\" {\n \t\t\terror_(r.Pos(), \"unable to find value of constant C.%s\", fixGo(r.Name.Go))\n \t\t}\n \t\tvar expr ast.Expr = ast.NewIdent(r.Name.Mangle) // default\n@@ -1109,6 +1164,10 @@ func (p *Package) rewriteRef(f *File) {\n \t\t\t}\n \t\tcase \"expr\":\n \t\t\tif r.Name.Kind == \"func\" {\n+\t\t\t\tif builtinDefs[r.Name.C] != \"\" {\n+\t\t\t\t\terror_(r.Pos(), \"use of builtin '%s' not in function call\", fixGo(r.Name.C))\n+\t\t\t\t}\n+\n \t\t\t\t// Function is being used in an expression, to e.g. pass around a C function pointer.\n \t\t\t\t// Create a new Name for this Ref which causes the variable to be declared in Go land.\n \t\t\t\tfpName := \"fp_\" + r.Name.Go\n@@ -1277,12 +1336,55 @@ func (p *Package) gccCmd() []string {\n \n // gccDebug runs gcc -gdwarf-2 over the C program stdin and\n // returns the corresponding DWARF data and, if present, debug data block.\n-func (p *Package) gccDebug(stdin []byte) (*dwarf.Data, binary.ByteOrder, []byte) {\n+func (p *Package) gccDebug(stdin []byte, nnames int) (d *dwarf.Data, ints []int64, floats []float64, strs []string) {\n \trunGcc(stdin, p.gccCmd())\n \n-\tisDebugData := func(s string) bool {\n+\tisDebugInts := func(s string) bool {\n+\t\t// Some systems use leading _ to denote non-assembly symbols.\n+\t\treturn s == \"__cgodebug_ints\" || s == \"___cgodebug_ints\"\n+\t}\n+\tisDebugFloats := func(s string) bool {\n+\t\t// Some systems use leading _ to denote non-assembly symbols.\n+\t\treturn s == \"__cgodebug_floats\" || s == \"___cgodebug_floats\"\n+\t}\n+\tindexOfDebugStr := func(s string) int {\n+\t\t// Some systems use leading _ to denote non-assembly symbols.\n+\t\tif strings.HasPrefix(s, \"___\") {\n+\t\t\ts = s[1:]\n+\t\t}\n+\t\tif strings.HasPrefix(s, \"__cgodebug_str__\") {\n+\t\t\tif n, err := strconv.Atoi(s[len(\"__cgodebug_str__\"):]); err == nil {\n+\t\t\t\treturn n\n+\t\t\t}\n+\t\t}\n+\t\treturn -1\n+\t}\n+\tindexOfDebugStrlen := func(s string) int {\n \t\t// Some systems use leading _ to denote non-assembly symbols.\n-\t\treturn s == \"__cgodebug_data\" || s == \"___cgodebug_data\"\n+\t\tif strings.HasPrefix(s, \"___\") {\n+\t\t\ts = s[1:]\n+\t\t}\n+\t\tif strings.HasPrefix(s, \"__cgodebug_strlen__\") {\n+\t\t\tif n, err := strconv.Atoi(s[len(\"__cgodebug_strlen__\"):]); err == nil {\n+\t\t\t\treturn n\n+\t\t\t}\n+\t\t}\n+\t\treturn -1\n+\t}\n+\n+\tstrs = make([]string, nnames)\n+\n+\tstrdata := make(map[int]string, nnames)\n+\tstrlens := make(map[int]int, nnames)\n+\n+\tbuildStrings := func() {\n+\t\tfor n, strlen := range strlens {\n+\t\t\tdata := strdata[n]\n+\t\t\tif len(data) <= strlen {\n+\t\t\t\tfatalf(\"invalid string literal\")\n+\t\t\t}\n+\t\t\tstrs[n] = string(data[:strlen])\n+\t\t}\n \t}\n \n \tif f, err := macho.Open(gccTmp()); err == nil {\n@@ -1291,24 +1393,76 @@ func (p *Package) gccDebug(stdin []byte) (*dwarf.Data, binary.ByteOrder, []byte)\n \t\tif err != nil {\n \t\t\tfatalf(\"cannot load DWARF output from %s: %v\", gccTmp(), err)\n \t\t}\n-\t\tvar data []byte\n+\t\tbo := f.ByteOrder\n \t\tif f.Symtab != nil {\n \t\t\tfor i := range f.Symtab.Syms {\n \t\t\t\ts := &f.Symtab.Syms[i]\n-\t\t\t\tif isDebugData(s.Name) {\n+\t\t\t\tswitch {\n+\t\t\t\tcase isDebugInts(s.Name):\n \t\t\t\t\t// Found it. Now find data section.\n \t\t\t\t\tif i := int(s.Sect) - 1; 0 <= i && i < len(f.Sections) {\n \t\t\t\t\t\tsect := f.Sections[i]\n \t\t\t\t\t\tif sect.Addr <= s.Value && s.Value < sect.Addr+sect.Size {\n \t\t\t\t\t\t\tif sdat, err := sect.Data(); err == nil {\n-\t\t\t\t\t\t\t\tdata = sdat[s.Value-sect.Addr:]\n+\t\t\t\t\t\t\t\tdata := sdat[s.Value-sect.Addr:]\n+\t\t\t\t\t\t\t\tints = make([]int64, len(data)/8)\n+\t\t\t\t\t\t\t\tfor i := range ints {\n+\t\t\t\t\t\t\t\t\tints[i] = int64(bo.Uint64(data[i*8:]))\n+\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n+\t\t\t\tcase isDebugFloats(s.Name):\n+\t\t\t\t\t// Found it. Now find data section.\n+\t\t\t\t\tif i := int(s.Sect) - 1; 0 <= i && i < len(f.Sections) {\n+\t\t\t\t\t\tsect := f.Sections[i]\n+\t\t\t\t\t\tif sect.Addr <= s.Value && s.Value < sect.Addr+sect.Size {\n+\t\t\t\t\t\t\tif sdat, err := sect.Data(); err == nil {\n+\t\t\t\t\t\t\t\tdata := sdat[s.Value-sect.Addr:]\n+\t\t\t\t\t\t\t\tfloats = make([]float64, len(data)/8)\n+\t\t\t\t\t\t\t\tfor i := range floats {\n+\t\t\t\t\t\t\t\t\tfloats[i] = math.Float64frombits(bo.Uint64(data[i*8:]))\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\tdefault:\n+\t\t\t\t\tif n := indexOfDebugStr(s.Name); n != -1 {\n+\t\t\t\t\t\t// Found it. Now find data section.\n+\t\t\t\t\t\tif i := int(s.Sect) - 1; 0 <= i && i < len(f.Sections) {\n+\t\t\t\t\t\t\tsect := f.Sections[i]\n+\t\t\t\t\t\t\tif sect.Addr <= s.Value && s.Value < sect.Addr+sect.Size {\n+\t\t\t\t\t\t\t\tif sdat, err := sect.Data(); err == nil {\n+\t\t\t\t\t\t\t\t\tdata := sdat[s.Value-sect.Addr:]\n+\t\t\t\t\t\t\t\t\tstrdata[n] = string(data)\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tbreak\n+\t\t\t\t\t}\n+\t\t\t\t\tif n := indexOfDebugStrlen(s.Name); n != -1 {\n+\t\t\t\t\t\t// Found it. Now find data section.\n+\t\t\t\t\t\tif i := int(s.Sect) - 1; 0 <= i && i < len(f.Sections) {\n+\t\t\t\t\t\t\tsect := f.Sections[i]\n+\t\t\t\t\t\t\tif sect.Addr <= s.Value && s.Value < sect.Addr+sect.Size {\n+\t\t\t\t\t\t\t\tif sdat, err := sect.Data(); err == nil {\n+\t\t\t\t\t\t\t\t\tdata := sdat[s.Value-sect.Addr:]\n+\t\t\t\t\t\t\t\t\tstrlen := bo.Uint64(data[:8])\n+\t\t\t\t\t\t\t\t\tif strlen > (1<<(uint(p.IntSize*8)-1) - 1) { // greater than MaxInt?\n+\t\t\t\t\t\t\t\t\t\tfatalf(\"string literal too big\")\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\tstrlens[n] = int(strlen)\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tbreak\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n+\n+\t\t\tbuildStrings()\n \t\t}\n-\t\treturn d, f.ByteOrder, data\n+\t\treturn d, ints, floats, strs\n \t}\n \n \tif f, err := elf.Open(gccTmp()); err == nil {\n@@ -1317,25 +1471,77 @@ func (p *Package) gccDebug(stdin []byte) (*dwarf.Data, binary.ByteOrder, []byte)\n \t\tif err != nil {\n \t\t\tfatalf(\"cannot load DWARF output from %s: %v\", gccTmp(), err)\n \t\t}\n-\t\tvar data []byte\n+\t\tbo := f.ByteOrder\n \t\tsymtab, err := f.Symbols()\n \t\tif err == nil {\n \t\t\tfor i := range symtab {\n \t\t\t\ts := &symtab[i]\n-\t\t\t\tif isDebugData(s.Name) {\n+\t\t\t\tswitch {\n+\t\t\t\tcase isDebugInts(s.Name):\n+\t\t\t\t\t// Found it. Now find data section.\n+\t\t\t\t\tif i := int(s.Section); 0 <= i && i < len(f.Sections) {\n+\t\t\t\t\t\tsect := f.Sections[i]\n+\t\t\t\t\t\tif sect.Addr <= s.Value && s.Value < sect.Addr+sect.Size {\n+\t\t\t\t\t\t\tif sdat, err := sect.Data(); err == nil {\n+\t\t\t\t\t\t\t\tdata := sdat[s.Value-sect.Addr:]\n+\t\t\t\t\t\t\t\tints = make([]int64, len(data)/8)\n+\t\t\t\t\t\t\t\tfor i := range ints {\n+\t\t\t\t\t\t\t\t\tints[i] = int64(bo.Uint64(data[i*8:]))\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\tcase isDebugFloats(s.Name):\n \t\t\t\t\t// Found it. Now find data section.\n \t\t\t\t\tif i := int(s.Section); 0 <= i && i < len(f.Sections) {\n \t\t\t\t\t\tsect := f.Sections[i]\n \t\t\t\t\t\tif sect.Addr <= s.Value && s.Value < sect.Addr+sect.Size {\n \t\t\t\t\t\t\tif sdat, err := sect.Data(); err == nil {\n-\t\t\t\t\t\t\t\tdata = sdat[s.Value-sect.Addr:]\n+\t\t\t\t\t\t\t\tdata := sdat[s.Value-sect.Addr:]\n+\t\t\t\t\t\t\t\tfloats = make([]float64, len(data)/8)\n+\t\t\t\t\t\t\t\tfor i := range floats {\n+\t\t\t\t\t\t\t\t\tfloats[i] = math.Float64frombits(bo.Uint64(data[i*8:]))\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\tdefault:\n+\t\t\t\t\tif n := indexOfDebugStr(s.Name); n != -1 {\n+\t\t\t\t\t\t// Found it. Now find data section.\n+\t\t\t\t\t\tif i := int(s.Section); 0 <= i && i < len(f.Sections) {\n+\t\t\t\t\t\t\tsect := f.Sections[i]\n+\t\t\t\t\t\t\tif sect.Addr <= s.Value && s.Value < sect.Addr+sect.Size {\n+\t\t\t\t\t\t\t\tif sdat, err := sect.Data(); err == nil {\n+\t\t\t\t\t\t\t\t\tdata := sdat[s.Value-sect.Addr:]\n+\t\t\t\t\t\t\t\t\tstrdata[n] = string(data)\n+\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n+\t\t\t\t\t\tbreak\n+\t\t\t\t\t}\n+\t\t\t\t\tif n := indexOfDebugStrlen(s.Name); n != -1 {\n+\t\t\t\t\t\t// Found it. Now find data section.\n+\t\t\t\t\t\tif i := int(s.Section); 0 <= i && i < len(f.Sections) {\n+\t\t\t\t\t\t\tsect := f.Sections[i]\n+\t\t\t\t\t\t\tif sect.Addr <= s.Value && s.Value < sect.Addr+sect.Size {\n+\t\t\t\t\t\t\t\tif sdat, err := sect.Data(); err == nil {\n+\t\t\t\t\t\t\t\t\tdata := sdat[s.Value-sect.Addr:]\n+\t\t\t\t\t\t\t\t\tstrlen := bo.Uint64(data[:8])\n+\t\t\t\t\t\t\t\t\tif strlen > (1<<(uint(p.IntSize*8)-1) - 1) { // greater than MaxInt?\n+\t\t\t\t\t\t\t\t\t\tfatalf(\"string literal too big\")\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\tstrlens[n] = int(strlen)\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tbreak\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n+\n+\t\t\tbuildStrings()\n \t\t}\n-\t\treturn d, f.ByteOrder, data\n+\t\treturn d, ints, floats, strs\n \t}\n \n \tif f, err := pe.Open(gccTmp()); err == nil {\n@@ -1344,20 +1550,70 @@ func (p *Package) gccDebug(stdin []byte) (*dwarf.Data, binary.ByteOrder, []byte)\n \t\tif err != nil {\n \t\t\tfatalf(\"cannot load DWARF output from %s: %v\", gccTmp(), err)\n \t\t}\n-\t\tvar data []byte\n+\t\tbo := binary.LittleEndian\n \t\tfor _, s := range f.Symbols {\n-\t\t\tif isDebugData(s.Name) {\n+\t\t\tswitch {\n+\t\t\tcase isDebugInts(s.Name):\n \t\t\t\tif i := int(s.SectionNumber) - 1; 0 <= i && i < len(f.Sections) {\n \t\t\t\t\tsect := f.Sections[i]\n \t\t\t\t\tif s.Value < sect.Size {\n \t\t\t\t\t\tif sdat, err := sect.Data(); err == nil {\n-\t\t\t\t\t\t\tdata = sdat[s.Value:]\n+\t\t\t\t\t\t\tdata := sdat[s.Value:]\n+\t\t\t\t\t\t\tints = make([]int64, len(data)/8)\n+\t\t\t\t\t\t\tfor i := range ints {\n+\t\t\t\t\t\t\t\tints[i] = int64(bo.Uint64(data[i*8:]))\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\tcase isDebugFloats(s.Name):\n+\t\t\t\tif i := int(s.SectionNumber) - 1; 0 <= i && i < len(f.Sections) {\n+\t\t\t\t\tsect := f.Sections[i]\n+\t\t\t\t\tif s.Value < sect.Size {\n+\t\t\t\t\t\tif sdat, err := sect.Data(); err == nil {\n+\t\t\t\t\t\t\tdata := sdat[s.Value:]\n+\t\t\t\t\t\t\tfloats = make([]float64, len(data)/8)\n+\t\t\t\t\t\t\tfor i := range floats {\n+\t\t\t\t\t\t\t\tfloats[i] = math.Float64frombits(bo.Uint64(data[i*8:]))\n+\t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n+\t\t\tdefault:\n+\t\t\t\tif n := indexOfDebugStr(s.Name); n != -1 {\n+\t\t\t\t\tif i := int(s.SectionNumber) - 1; 0 <= i && i < len(f.Sections) {\n+\t\t\t\t\t\tsect := f.Sections[i]\n+\t\t\t\t\t\tif s.Value < sect.Size {\n+\t\t\t\t\t\t\tif sdat, err := sect.Data(); err == nil {\n+\t\t\t\t\t\t\t\tdata := sdat[s.Value:]\n+\t\t\t\t\t\t\t\tstrdata[n] = string(data)\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t\tif n := indexOfDebugStrlen(s.Name); n != -1 {\n+\t\t\t\t\tif i := int(s.SectionNumber) - 1; 0 <= i && i < len(f.Sections) {\n+\t\t\t\t\t\tsect := f.Sections[i]\n+\t\t\t\t\t\tif s.Value < sect.Size {\n+\t\t\t\t\t\t\tif sdat, err := sect.Data(); err == nil {\n+\t\t\t\t\t\t\t\tdata := sdat[s.Value:]\n+\t\t\t\t\t\t\t\tstrlen := bo.Uint64(data[:8])\n+\t\t\t\t\t\t\t\tif strlen > (1<<(uint(p.IntSize*8)-1) - 1) { // greater than MaxInt?\n+\t\t\t\t\t\t\t\t\tfatalf(\"string literal too big\")\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tstrlens[n] = int(strlen)\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n-\t\treturn d, binary.LittleEndian, data\n+\n+\t\tbuildStrings()\n+\n+\t\treturn d, ints, floats, strs\n \t}\n \n \tfatalf(\"cannot parse gcc output %s as ELF, Mach-O, PE object\", gccTmp())\n@@ -2048,7 +2304,7 @@ func (c *typeConv) FuncType(dtype *dwarf.FuncType, pos token.Pos) *FuncType {\n \t}\n \tvar r *Type\n \tvar gr []*ast.Field\n-\tif _, ok := dtype.ReturnType.(*dwarf.VoidType); ok {\n+\tif _, ok := base(dtype.ReturnType).(*dwarf.VoidType); ok {\n \t\tgr = []*ast.Field{{Type: c.goVoid}}\n \t} else if dtype.ReturnType != nil {\n \t\tr = c.Type(unqual(dtype.ReturnType), pos)"}, {"sha": "c9a44fdd1666373b59e4511b777550d5d58e257f", "filename": "libgo/go/cmd/cgo/main.go", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fcgo%2Fmain.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fcgo%2Fmain.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fmain.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -17,7 +17,7 @@ import (\n \t\"go/ast\"\n \t\"go/printer\"\n \t\"go/token\"\n-\t\"io\"\n+\t\"io/ioutil\"\n \t\"os\"\n \t\"path/filepath\"\n \t\"reflect\"\n@@ -88,7 +88,7 @@ type Name struct {\n \tMangle   string // name used in generated Go\n \tC        string // name used in C\n \tDefine   string // #define expansion\n-\tKind     string // \"const\", \"type\", \"var\", \"fpvar\", \"func\", \"not-type\"\n+\tKind     string // \"iconst\", \"uconst\", \"fconst\", \"sconst\", \"type\", \"var\", \"fpvar\", \"func\", \"not-type\"\n \tType     *Type  // the type of xxx\n \tFuncType *FuncType\n \tAddError bool\n@@ -100,6 +100,11 @@ func (n *Name) IsVar() bool {\n \treturn n.Kind == \"var\" || n.Kind == \"fpvar\"\n }\n \n+// IsConst reports whether Kind is either \"iconst\", \"uconst\", \"fconst\" or \"sconst\"\n+func (n *Name) IsConst() bool {\n+\treturn strings.HasSuffix(n.Kind, \"const\")\n+}\n+\n // A ExpFunc is an exported function, callable from C.\n // Such functions are identified in the Go input file\n // by doc comments containing the line //export ExpName\n@@ -274,30 +279,28 @@ func main() {\n \t// concern is other cgo wrappers for the same functions.\n \t// Use the beginning of the md5 of the input to disambiguate.\n \th := md5.New()\n-\tfor _, input := range goFiles {\n+\tfs := make([]*File, len(goFiles))\n+\tfor i, input := range goFiles {\n \t\tif *srcDir != \"\" {\n \t\t\tinput = filepath.Join(*srcDir, input)\n \t\t}\n-\t\tf, err := os.Open(input)\n+\n+\t\tb, err := ioutil.ReadFile(input)\n \t\tif err != nil {\n \t\t\tfatalf(\"%s\", err)\n \t\t}\n-\t\tio.Copy(h, f)\n-\t\tf.Close()\n-\t}\n-\tcPrefix = fmt.Sprintf(\"_%x\", h.Sum(nil)[0:6])\n-\n-\tfs := make([]*File, len(goFiles))\n-\tfor i, input := range goFiles {\n-\t\tif *srcDir != \"\" {\n-\t\t\tinput = filepath.Join(*srcDir, input)\n+\t\tif _, err = h.Write(b); err != nil {\n+\t\t\tfatalf(\"%s\", err)\n \t\t}\n+\n \t\tf := new(File)\n-\t\tf.ReadGo(input)\n+\t\tf.ParseGo(input, b)\n \t\tf.DiscardCgoDirectives()\n \t\tfs[i] = f\n \t}\n \n+\tcPrefix = fmt.Sprintf(\"_%x\", h.Sum(nil)[0:6])\n+\n \tif *objDir == \"\" {\n \t\t// make sure that _obj directory exists, so that we can write\n \t\t// all the output files there."}, {"sha": "c4ff07d2668d8f7cae99239e53ce4f2cb1001a60", "filename": "libgo/go/cmd/cgo/out.go", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fcgo%2Fout.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fcgo%2Fout.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fout.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -190,7 +190,7 @@ func (p *Package) writeDefs() {\n \tfor _, key := range nameKeys(p.Name) {\n \t\tn := p.Name[key]\n \t\tif n.Const != \"\" {\n-\t\t\tfmt.Fprintf(fgo2, \"const _Cconst_%s = %s\\n\", n.Go, n.Const)\n+\t\t\tfmt.Fprintf(fgo2, \"const %s = %s\\n\", n.Mangle, n.Const)\n \t\t}\n \t}\n \tfmt.Fprintf(fgo2, \"\\n\")\n@@ -1303,7 +1303,7 @@ const gccProlog = `\n */\n #define __cgo_compile_assert_eq(x, y, name) typedef char name[(x-y)*(x-y)*-2+1];\n \n-// Check at compile time that the sizes we use match our expectations.\n+/* Check at compile time that the sizes we use match our expectations. */\n #define __cgo_size_assert(t, n) __cgo_compile_assert_eq(sizeof(t), n, _cgo_sizeof_##t##_is_not_##n)\n \n __cgo_size_assert(char, 1)\n@@ -1328,6 +1328,27 @@ const noTsanProlog = `\n `\n \n // This must match the TSAN code in runtime/cgo/libcgo.h.\n+// This is used when the code is built with the C/C++ Thread SANitizer,\n+// which is not the same as the Go race detector.\n+// __tsan_acquire tells TSAN that we are acquiring a lock on a variable,\n+// in this case _cgo_sync. __tsan_release releases the lock.\n+// (There is no actual lock, we are just telling TSAN that there is.)\n+//\n+// When we call from Go to C we call _cgo_tsan_acquire.\n+// When the C function returns we call _cgo_tsan_release.\n+// Similarly, when C calls back into Go we call _cgo_tsan_release\n+// and then call _cgo_tsan_acquire when we return to C.\n+// These calls tell TSAN that there is a serialization point at the C call.\n+//\n+// This is necessary because TSAN, which is a C/C++ tool, can not see\n+// the synchronization in the Go code. Without these calls, when\n+// multiple goroutines call into C code, TSAN does not understand\n+// that the calls are properly synchronized on the Go side.\n+//\n+// To be clear, if the calls are not properly synchronized on the Go side,\n+// we will be hiding races. But when using TSAN on mixed Go C/C++ code\n+// it is more important to avoid false positives, which reduce confidence\n+// in the tool, than to avoid false negatives.\n const yesTsanProlog = `\n #line 1 \"cgo-tsan-prolog\"\n #define CGO_NO_SANITIZE_THREAD __attribute__ ((no_sanitize_thread))"}, {"sha": "6f9dc326dc51d367ce2199500124417a5ead3f74", "filename": "libgo/go/cmd/go/alldocs.go", "status": "modified", "additions": 105, "deletions": 73, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Falldocs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Falldocs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Falldocs.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -118,8 +118,8 @@\n // \t\ta suffix to use in the name of the package installation directory,\n // \t\tin order to keep output separate from default builds.\n // \t\tIf using the -race flag, the install suffix is automatically set to race\n-// \t\tor, if set explicitly, has _race appended to it.  Likewise for the -msan\n-// \t\tflag.  Using a -buildmode option that requires non-default compile flags\n+// \t\tor, if set explicitly, has _race appended to it. Likewise for the -msan\n+// \t\tflag. Using a -buildmode option that requires non-default compile flags\n // \t\thas a similar effect.\n // \t-ldflags 'flag list'\n // \t\targuments to pass on each go tool link invocation.\n@@ -131,16 +131,17 @@\n // \t\tFor example, when building with a non-standard configuration,\n // \t\tuse -pkgdir to keep generated packages in a separate location.\n // \t-tags 'tag list'\n-// \t\ta list of build tags to consider satisfied during the build.\n-// \t\tFor more information about build tags, see the description of\n+// \t\ta space-separated list of build tags to consider satisfied during the\n+// \t\tbuild. For more information about build tags, see the description of\n // \t\tbuild constraints in the documentation for the go/build package.\n // \t-toolexec 'cmd args'\n // \t\ta program to use to invoke toolchain programs like vet and asm.\n // \t\tFor example, instead of running asm, the go command will run\n // \t\t'cmd args /path/to/asm <arguments for asm>'.\n //\n-// The list flags accept a space-separated list of strings. To embed spaces\n-// in an element in the list, surround it with either single or double quotes.\n+// All the flags that take a list of arguments accept a space-separated\n+// list of strings. To embed spaces in an element in the list, surround\n+// it with either single or double quotes.\n //\n // For more about specifying packages, see 'go help packages'.\n // For more about where packages and binaries are installed,\n@@ -208,12 +209,13 @@\n //\n // Usage:\n //\n-// \tgo doc [-u] [-c] [package|[package.]symbol[.method]]\n+// \tgo doc [-u] [-c] [package|[package.]symbol[.methodOrField]]\n //\n // Doc prints the documentation comments associated with the item identified by its\n-// arguments (a package, const, func, type, var, or method) followed by a one-line\n-// summary of each of the first-level items \"under\" that item (package-level\n-// declarations for a package, methods for a type, etc.).\n+// arguments (a package, const, func, type, var, method, or struct field)\n+// followed by a one-line summary of each of the first-level items \"under\"\n+// that item (package-level declarations for a package, methods for a type,\n+// etc.).\n //\n // Doc accepts zero, one, or two arguments.\n //\n@@ -231,17 +233,17 @@\n // which is schematically one of these:\n //\n // \tgo doc <pkg>\n-// \tgo doc <sym>[.<method>]\n-// \tgo doc [<pkg>.]<sym>[.<method>]\n-// \tgo doc [<pkg>.][<sym>.]<method>\n+// \tgo doc <sym>[.<methodOrField>]\n+// \tgo doc [<pkg>.]<sym>[.<methodOrField>]\n+// \tgo doc [<pkg>.][<sym>.]<methodOrField>\n //\n // The first item in this list matched by the argument is the one whose documentation\n // is printed. (See the examples below.) However, if the argument starts with a capital\n // letter it is assumed to identify a symbol or method in the current directory.\n //\n // For packages, the order of scanning is determined lexically in breadth-first order.\n // That is, the package presented is the one that matches the search and is nearest\n-// the root and lexically first at its level of the hierarchy.  The GOROOT tree is\n+// the root and lexically first at its level of the hierarchy. The GOROOT tree is\n // always scanned in its entirety before GOPATH.\n //\n // If there is no package specified or matched, the package in the current\n@@ -253,10 +255,10 @@\n // elements like . and ... are not implemented by go doc.\n //\n // When run with two arguments, the first must be a full package path (not just a\n-// suffix), and the second is a symbol or symbol and method; this is similar to the\n-// syntax accepted by godoc:\n+// suffix), and the second is a symbol, or symbol with method or struct field.\n+// This is similar to the syntax accepted by godoc:\n //\n-// \tgo doc <pkg> <sym>[.<method>]\n+// \tgo doc <pkg> <sym>[.<methodOrField>]\n //\n // In all forms, when matching symbols, lower-case letters in the argument match\n // either case but upper-case letters match exactly. This means that there may be\n@@ -307,22 +309,25 @@\n // \t\twhen showing the package's top-level documentation.\n // \t-u\n // \t\tShow documentation for unexported as well as exported\n-// \t\tsymbols and methods.\n+// \t\tsymbols, methods, and fields.\n //\n //\n // Print Go environment information\n //\n // Usage:\n //\n-// \tgo env [var ...]\n+// \tgo env [-json] [var ...]\n //\n // Env prints Go environment information.\n //\n // By default env prints information as a shell script\n-// (on Windows, a batch file).  If one or more variable\n-// names is given as arguments,  env prints the value of\n+// (on Windows, a batch file). If one or more variable\n+// names is given as arguments, env prints the value of\n // each named variable on its own line.\n //\n+// The -json flag prints the environment in JSON format\n+// instead of as a shell script.\n+//\n //\n // Start a bug report\n //\n@@ -357,7 +362,7 @@\n // \tgo fmt [-n] [-x] [packages]\n //\n // Fmt runs the command 'gofmt -l -w' on the packages named\n-// by the import paths.  It prints the names of the files that are modified.\n+// by the import paths. It prints the names of the files that are modified.\n //\n // For more about gofmt, see 'go doc cmd/gofmt'.\n // For more about specifying packages, see 'go help packages'.\n@@ -427,7 +432,7 @@\n // As a last step before running the command, any invocations of any\n // environment variables with alphanumeric names, such as $GOFILE or\n // $HOME, are expanded throughout the command line. The syntax for\n-// variable expansion is $NAME on all operating systems.  Due to the\n+// variable expansion is $NAME on all operating systems. Due to the\n // order of evaluation, variables are expanded even inside quoted\n // strings. If the variable NAME is not set, $NAME expands to the\n // empty string.\n@@ -504,7 +509,7 @@\n // the tests for the specified packages.\n //\n // The -u flag instructs get to use the network to update the named packages\n-// and their dependencies.  By default, get uses the network to check out\n+// and their dependencies. By default, get uses the network to check out\n // missing packages but does not use it to look for updates to existing packages.\n //\n // The -v flag enables verbose progress and debug output.\n@@ -518,8 +523,8 @@\n // When checking out or updating a package, get looks for a branch or tag\n // that matches the locally installed version of Go. The most important\n // rule is that if the local installation is running version \"go1\", get\n-// searches for a branch or tag named \"go1\". If no such version exists it\n-// retrieves the most recent version of the package.\n+// searches for a branch or tag named \"go1\". If no such version exists\n+// it retrieves the default branch of the package.\n //\n // When go get checks out or updates a Git repository,\n // it also updates any git submodules referenced by the repository.\n@@ -565,7 +570,7 @@\n //     golang.org/x/net/html\n //\n // The -f flag specifies an alternate format for the list, using the\n-// syntax of package template.  The default output is equivalent to -f\n+// syntax of package template. The default output is equivalent to -f\n // '{{.ImportPath}}'. The struct being passed to the template is:\n //\n //     type Package struct {\n@@ -658,12 +663,12 @@\n // instead of using the template format.\n //\n // The -e flag changes the handling of erroneous packages, those that\n-// cannot be found or are malformed.  By default, the list command\n+// cannot be found or are malformed. By default, the list command\n // prints an error to standard error for each erroneous package and\n // omits the packages from consideration during the usual printing.\n // With the -e flag, the list command never prints errors to standard\n // error and instead processes the erroneous packages with the usual\n-// printing.  Erroneous packages will have a non-empty ImportPath and\n+// printing. Erroneous packages will have a non-empty ImportPath and\n // a non-nil Error field; other information may or may not be missing\n // (zeroed).\n //\n@@ -716,7 +721,7 @@\n // the file pattern \"*_test.go\".\n // Files whose names begin with \"_\" (including \"_test.go\") or \".\" are ignored.\n // These additional files can contain test functions, benchmark functions, and\n-// example functions.  See 'go help testfunc' for more.\n+// example functions. See 'go help testfunc' for more.\n // Each listed package causes the execution of a separate test binary.\n //\n // Test files that declare a package with the suffix \"_test\" will be compiled as a\n@@ -725,7 +730,7 @@\n // The go tool will ignore a directory named \"testdata\", making it available\n // to hold ancillary data needed by the tests.\n //\n-// By default, go test needs no arguments.  It compiles and tests the package\n+// By default, go test needs no arguments. It compiles and tests the package\n // with source in the current directory, including tests, and runs the tests.\n //\n // The package is built in a temporary directory so it does not interfere with the\n@@ -793,15 +798,13 @@\n //\n // Usage:\n //\n-// \tgo vet [-n] [-x] [build flags] [packages]\n+// \tgo vet [-n] [-x] [build flags] [vet flags] [packages]\n //\n // Vet runs the Go vet command on the packages named by the import paths.\n //\n-// For more about vet, see 'go doc cmd/vet'.\n+// For more about vet and its flags, see 'go doc cmd/vet'.\n // For more about specifying packages, see 'go help packages'.\n //\n-// To run the vet tool with specific options, run 'go tool vet'.\n-//\n // The -n flag prints commands that would be executed.\n // The -x flag prints commands as they are executed.\n //\n@@ -814,18 +817,18 @@\n //\n // There are two different ways to call between Go and C/C++ code.\n //\n-// The first is the cgo tool, which is part of the Go distribution.  For\n+// The first is the cgo tool, which is part of the Go distribution. For\n // information on how to use it see the cgo documentation (go doc cmd/cgo).\n //\n // The second is the SWIG program, which is a general tool for\n-// interfacing between languages.  For information on SWIG see\n-// http://swig.org/.  When running go build, any file with a .swig\n-// extension will be passed to SWIG.  Any file with a .swigcxx extension\n+// interfacing between languages. For information on SWIG see\n+// http://swig.org/. When running go build, any file with a .swig\n+// extension will be passed to SWIG. Any file with a .swigcxx extension\n // will be passed to SWIG with the -c++ option.\n //\n // When either cgo or SWIG is used, go build will pass any .c, .m, .s,\n // or .S files to the C compiler, and any .cc, .cpp, .cxx files to the C++\n-// compiler.  The CC or CXX environment variables may be set to determine\n+// compiler. The CC or CXX environment variables may be set to determine\n // the C or C++ compiler, respectively, to use.\n //\n //\n@@ -846,10 +849,10 @@\n // \t\texactly one main package to be listed.\n //\n // \t-buildmode=c-shared\n-// \t\tBuild the listed main packages, plus all packages that they\n-// \t\timport, into C shared libraries. The only callable symbols will\n+// \t\tBuild the listed main package, plus all packages it imports,\n+// \t\tinto a C shared library. The only callable symbols will\n // \t\tbe those functions exported using a cgo //export comment.\n-// \t\tNon-main packages are ignored.\n+// \t\tRequires exactly one main package to be listed.\n //\n // \t-buildmode=default\n // \t\tListed main packages are built into executables and listed\n@@ -938,7 +941,7 @@\n //\n // Each directory listed in GOPATH must have a prescribed structure:\n //\n-// The src directory holds source code.  The path below src\n+// The src directory holds source code. The path below src\n // determines the import path or executable name.\n //\n // The pkg directory holds installed package objects.\n@@ -952,11 +955,11 @@\n //\n // The bin directory holds compiled commands.\n // Each command is named for its source directory, but only\n-// the final element, not the entire path.  That is, the\n+// the final element, not the entire path. That is, the\n // command with source in DIR/src/foo/quux is installed into\n-// DIR/bin/quux, not DIR/bin/foo/quux.  The \"foo/\" prefix is stripped\n+// DIR/bin/quux, not DIR/bin/foo/quux. The \"foo/\" prefix is stripped\n // so that you can add DIR/bin to your PATH to get at the\n-// installed commands.  If the GOBIN environment variable is\n+// installed commands. If the GOBIN environment variable is\n // set, commands are installed to the directory it names instead\n // of DIR/bin. GOBIN must be an absolute path.\n //\n@@ -1099,7 +1102,7 @@\n // \tCC\n // \t\tThe command to use to compile C code.\n // \tCGO_ENABLED\n-// \t\tWhether the cgo command is supported.  Either 0 or 1.\n+// \t\tWhether the cgo command is supported. Either 0 or 1.\n // \tCGO_CFLAGS\n // \t\tFlags that cgo will pass to the compiler when compiling\n // \t\tC code.\n@@ -1151,7 +1154,7 @@\n // Import path syntax\n //\n // An import path (see 'go help packages') denotes a package stored in the local\n-// file system.  In general, an import path denotes either a standard package (such\n+// file system. In general, an import path denotes either a standard package (such\n // as \"unicode/utf8\") or a package found in one of the work spaces (For more\n // details see: 'go help gopath').\n //\n@@ -1222,7 +1225,7 @@\n //\n // specifies the given repository, with or without the .vcs suffix,\n // using the named version control system, and then the path inside\n-// that repository.  The supported version control systems are:\n+// that repository. The supported version control systems are:\n //\n // \tBazaar      .bzr\n // \tGit         .git\n@@ -1242,7 +1245,7 @@\n // example.org/repo or repo.git.\n //\n // When a version control system supports multiple protocols,\n-// each is tried in turn when downloading.  For example, a Git\n+// each is tried in turn when downloading. For example, a Git\n // download tries https://, then git+ssh://.\n //\n // By default, downloads are restricted to known secure protocols\n@@ -1360,17 +1363,28 @@\n //\n // An import path is a pattern if it includes one or more \"...\" wildcards,\n // each of which can match any string, including the empty string and\n-// strings containing slashes.  Such a pattern expands to all package\n+// strings containing slashes. Such a pattern expands to all package\n // directories found in the GOPATH trees with names matching the\n-// patterns.  As a special case, x/... matches x as well as x's subdirectories.\n-// For example, net/... expands to net and packages in its subdirectories.\n+// patterns.\n+//\n+// To make common patterns more convenient, there are two special cases.\n+// First, /... at the end of the pattern can match an empty string,\n+// so that net/... matches both net and packages in its subdirectories, like net/http.\n+// Second, any slash-separated pattern element containing a wildcard never\n+// participates in a match of the \"vendor\" element in the path of a vendored\n+// package, so that ./... does not match packages in subdirectories of\n+// ./vendor or ./mycode/vendor, but ./vendor/... and ./mycode/vendor/... do.\n+// Note, however, that a directory named vendor that itself contains code\n+// is not a vendored package: cmd/vendor would be a command named vendor,\n+// and the pattern cmd/... matches it.\n+// See golang.org/s/go15vendor for more about vendoring.\n //\n // An import path can also name a package to be downloaded from\n-// a remote repository.  Run 'go help importpath' for details.\n+// a remote repository. Run 'go help importpath' for details.\n //\n // Every package in a program must have a unique import path.\n // By convention, this is arranged by starting each path with a\n-// unique prefix that belongs to you.  For example, paths used\n+// unique prefix that belongs to you. For example, paths used\n // internally at Google all begin with 'google', and paths\n // denoting remote repositories begin with the path to the code,\n // such as 'github.com/user/repo'.\n@@ -1399,19 +1413,24 @@\n //\n // Several of the flags control profiling and write an execution profile\n // suitable for \"go tool pprof\"; run \"go tool pprof -h\" for more\n-// information.  The --alloc_space, --alloc_objects, and --show_bytes\n+// information. The --alloc_space, --alloc_objects, and --show_bytes\n // options of pprof control how the information is presented.\n //\n // The following flags are recognized by the 'go test' command and\n // control the execution of any test:\n //\n // \t-bench regexp\n-// \t    Run (sub)benchmarks matching a regular expression.\n-// \t    The given regular expression is split into smaller ones by\n-// \t    top-level '/', where each must match the corresponding part of a\n-// \t    benchmark's identifier.\n-// \t    By default, no benchmarks run. To run all benchmarks,\n-// \t    use '-bench .' or '-bench=.'.\n+// \t    Run only those benchmarks matching a regular expression.\n+// \t    By default, no benchmarks are run.\n+// \t    To run all benchmarks, use '-bench .' or '-bench=.'.\n+// \t    The regular expression is split by unbracketed slash (/)\n+// \t    characters into a sequence of regular expressions, and each\n+// \t    part of a benchmark's identifier must match the corresponding\n+// \t    element in the sequence, if any. Possible parents of matches\n+// \t    are run with b.N=1 to identify sub-benchmarks. For example,\n+// \t    given -bench=X/Y, top-level benchmarks matching X are run\n+// \t    with b.N=1 to find any sub-benchmarks matching Y, which are\n+// \t    then run in full.\n //\n // \t-benchtime t\n // \t    Run enough iterations of each benchmark to take t, specified\n@@ -1425,6 +1444,10 @@\n //\n // \t-cover\n // \t    Enable coverage analysis.\n+// \t    Note that because coverage works by annotating the source\n+// \t    code before compilation, compilation and test failures with\n+// \t    coverage enabled may report line numbers that don't correspond\n+// \t    to the original sources.\n //\n // \t-covermode set,count,atomic\n // \t    Set the mode for coverage analysis for the package[s]\n@@ -1445,9 +1468,14 @@\n //\n // \t-cpu 1,2,4\n // \t    Specify a list of GOMAXPROCS values for which the tests or\n-// \t    benchmarks should be executed.  The default is the current value\n+// \t    benchmarks should be executed. The default is the current value\n // \t    of GOMAXPROCS.\n //\n+// \t-list regexp\n+// \t    List tests, benchmarks, or examples matching the regular expression.\n+// \t    No tests, benchmarks or examples will be run. This will only\n+// \t    list top-level tests. No subtest or subbenchmarks will be shown.\n+//\n // \t-parallel n\n // \t    Allow parallel execution of test functions that call t.Parallel.\n // \t    The value of this flag is the maximum number of tests to run\n@@ -1459,18 +1487,22 @@\n //\n // \t-run regexp\n // \t    Run only those tests and examples matching the regular expression.\n-// \t    For tests the regular expression is split into smaller ones by\n-// \t    top-level '/', where each must match the corresponding part of a\n-// \t    test's identifier.\n+// \t    For tests, the regular expression is split by unbracketed slash (/)\n+// \t    characters into a sequence of regular expressions, and each part\n+// \t    of a test's identifier must match the corresponding element in\n+// \t    the sequence, if any. Note that possible parents of matches are\n+// \t    run too, so that -run=X/Y matches and runs and reports the result\n+// \t    of all tests matching X, even those without sub-tests matching Y,\n+// \t    because it must run them to look for those sub-tests.\n //\n // \t-short\n // \t    Tell long-running tests to shorten their run time.\n // \t    It is off by default but set during all.bash so that installing\n // \t    the Go tree can run a sanity check but not spend time running\n // \t    exhaustive tests.\n //\n-// \t-timeout t\n-// \t    If a test runs longer than t, panic.\n+// \t-timeout d\n+// \t    If a test binary runs longer than duration d, panic.\n // \t    The default is 10 minutes (10m).\n //\n // \t-v\n@@ -1493,7 +1525,7 @@\n // \t    calling runtime.SetBlockProfileRate with n.\n // \t    See 'go doc runtime.SetBlockProfileRate'.\n // \t    The profiler aims to sample, on average, one blocking event every\n-// \t    n nanoseconds the program spends blocked.  By default,\n+// \t    n nanoseconds the program spends blocked. By default,\n // \t    if -test.blockprofile is set without this flag, all blocking events\n // \t    are recorded, equivalent to -test.blockprofilerate=1.\n //\n@@ -1511,7 +1543,7 @@\n //\n // \t-memprofilerate n\n // \t    Enable more precise (and expensive) memory profiles by setting\n-// \t    runtime.MemProfileRate.  See 'go doc runtime.MemProfileRate'.\n+// \t    runtime.MemProfileRate. See 'go doc runtime.MemProfileRate'.\n // \t    To profile all memory allocations, use -test.memprofilerate=1\n // \t    and pass --alloc_space flag to the pprof tool.\n //\n@@ -1614,8 +1646,8 @@\n // \"Output:\" is compiled, executed, and expected to produce no output.\n //\n // Godoc displays the body of ExampleXXX to demonstrate the use\n-// of the function, constant, or variable XXX.  An example of a method M with\n-// receiver type T or *T is named ExampleT_M.  There may be multiple examples\n+// of the function, constant, or variable XXX. An example of a method M with\n+// receiver type T or *T is named ExampleT_M. There may be multiple examples\n // for a given function, constant, or variable, distinguished by a trailing _xxx,\n // where xxx is a suffix not beginning with an upper case letter.\n //"}, {"sha": "79bbd545915badb95a7b60a876946451873b802b", "filename": "libgo/go/cmd/go/build_test.go", "status": "removed", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a41a6142df74219f596e612d3a7775f68ca6e96f/libgo%2Fgo%2Fcmd%2Fgo%2Fbuild_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a41a6142df74219f596e612d3a7775f68ca6e96f/libgo%2Fgo%2Fcmd%2Fgo%2Fbuild_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fbuild_test.go?ref=a41a6142df74219f596e612d3a7775f68ca6e96f", "patch": "@@ -1,44 +0,0 @@\n-// Copyright 2016 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package main\n-\n-import (\n-\t\"os\"\n-\t\"reflect\"\n-\t\"testing\"\n-)\n-\n-func TestRemoveDevNull(t *testing.T) {\n-\tfi, err := os.Lstat(os.DevNull)\n-\tif err != nil {\n-\t\tt.Skip(err)\n-\t}\n-\tif fi.Mode().IsRegular() {\n-\t\tt.Errorf(\"Lstat(%s).Mode().IsRegular() = true; expected false\", os.DevNull)\n-\t}\n-\tmayberemovefile(os.DevNull)\n-\t_, err = os.Lstat(os.DevNull)\n-\tif err != nil {\n-\t\tt.Errorf(\"mayberemovefile(%s) did remove it; oops\", os.DevNull)\n-\t}\n-}\n-\n-func TestSplitPkgConfigOutput(t *testing.T) {\n-\tfor _, test := range []struct {\n-\t\tin   []byte\n-\t\twant []string\n-\t}{\n-\t\t{[]byte(`-r:foo -L/usr/white\\ space/lib -lfoo\\ bar -lbar\\ baz`), []string{\"-r:foo\", \"-L/usr/white space/lib\", \"-lfoo bar\", \"-lbar baz\"}},\n-\t\t{[]byte(`-lextra\\ fun\\ arg\\\\`), []string{`-lextra fun arg\\`}},\n-\t\t{[]byte(`broken flag\\`), []string{\"broken\", \"flag\"}},\n-\t\t{[]byte(\"\\textra     whitespace\\r\\n\"), []string{\"extra\", \"whitespace\"}},\n-\t\t{[]byte(\"     \\r\\n      \"), nil},\n-\t} {\n-\t\tgot := splitPkgConfigOutput(test.in)\n-\t\tif !reflect.DeepEqual(got, test.want) {\n-\t\t\tt.Errorf(\"splitPkgConfigOutput(%v) = %v; want %v\", test.in, got, test.want)\n-\t\t}\n-\t}\n-}"}, {"sha": "31710b7e6d62fbf36da4931daec635e6fef434ca", "filename": "libgo/go/cmd/go/env.go", "status": "removed", "additions": 0, "deletions": 138, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a41a6142df74219f596e612d3a7775f68ca6e96f/libgo%2Fgo%2Fcmd%2Fgo%2Fenv.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a41a6142df74219f596e612d3a7775f68ca6e96f/libgo%2Fgo%2Fcmd%2Fgo%2Fenv.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fenv.go?ref=a41a6142df74219f596e612d3a7775f68ca6e96f", "patch": "@@ -1,138 +0,0 @@\n-// Copyright 2012 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package main\n-\n-import (\n-\t\"fmt\"\n-\t\"os\"\n-\t\"runtime\"\n-\t\"strings\"\n-)\n-\n-var cmdEnv = &Command{\n-\tRun:       runEnv,\n-\tUsageLine: \"env [var ...]\",\n-\tShort:     \"print Go environment information\",\n-\tLong: `\n-Env prints Go environment information.\n-\n-By default env prints information as a shell script\n-(on Windows, a batch file).  If one or more variable\n-names is given as arguments,  env prints the value of\n-each named variable on its own line.\n-\t`,\n-}\n-\n-type envVar struct {\n-\tname, value string\n-}\n-\n-func mkEnv() []envVar {\n-\tvar b builder\n-\tb.init()\n-\n-\tenv := []envVar{\n-\t\t{\"GOARCH\", goarch},\n-\t\t{\"GOBIN\", gobin},\n-\t\t{\"GOEXE\", exeSuffix},\n-\t\t{\"GOHOSTARCH\", runtime.GOARCH},\n-\t\t{\"GOHOSTOS\", runtime.GOOS},\n-\t\t{\"GOOS\", goos},\n-\t\t{\"GOPATH\", buildContext.GOPATH},\n-\t\t{\"GORACE\", os.Getenv(\"GORACE\")},\n-\t\t{\"GOROOT\", goroot},\n-\t\t{\"GOTOOLDIR\", toolDir},\n-\n-\t\t// disable escape codes in clang errors\n-\t\t{\"TERM\", \"dumb\"},\n-\t}\n-\n-\tif gccgoBin != \"\" {\n-\t\tenv = append(env, envVar{\"GCCGO\", gccgoBin})\n-\t} else {\n-\t\tenv = append(env, envVar{\"GCCGO\", gccgoName})\n-\t}\n-\n-\tswitch goarch {\n-\tcase \"arm\":\n-\t\tenv = append(env, envVar{\"GOARM\", os.Getenv(\"GOARM\")})\n-\tcase \"386\":\n-\t\tenv = append(env, envVar{\"GO386\", os.Getenv(\"GO386\")})\n-\t}\n-\n-\tcmd := b.gccCmd(\".\")\n-\tenv = append(env, envVar{\"CC\", cmd[0]})\n-\tenv = append(env, envVar{\"GOGCCFLAGS\", strings.Join(cmd[3:], \" \")})\n-\tcmd = b.gxxCmd(\".\")\n-\tenv = append(env, envVar{\"CXX\", cmd[0]})\n-\n-\tif buildContext.CgoEnabled {\n-\t\tenv = append(env, envVar{\"CGO_ENABLED\", \"1\"})\n-\t} else {\n-\t\tenv = append(env, envVar{\"CGO_ENABLED\", \"0\"})\n-\t}\n-\n-\treturn env\n-}\n-\n-func findEnv(env []envVar, name string) string {\n-\tfor _, e := range env {\n-\t\tif e.name == name {\n-\t\t\treturn e.value\n-\t\t}\n-\t}\n-\treturn \"\"\n-}\n-\n-// extraEnvVars returns environment variables that should not leak into child processes.\n-func extraEnvVars() []envVar {\n-\tvar b builder\n-\tb.init()\n-\tcppflags, cflags, cxxflags, fflags, ldflags := b.cflags(&Package{})\n-\treturn []envVar{\n-\t\t{\"PKG_CONFIG\", b.pkgconfigCmd()},\n-\t\t{\"CGO_CFLAGS\", strings.Join(cflags, \" \")},\n-\t\t{\"CGO_CPPFLAGS\", strings.Join(cppflags, \" \")},\n-\t\t{\"CGO_CXXFLAGS\", strings.Join(cxxflags, \" \")},\n-\t\t{\"CGO_FFLAGS\", strings.Join(fflags, \" \")},\n-\t\t{\"CGO_LDFLAGS\", strings.Join(ldflags, \" \")},\n-\t}\n-}\n-\n-func runEnv(cmd *Command, args []string) {\n-\tenv := newEnv\n-\tenv = append(env, extraEnvVars()...)\n-\tif len(args) > 0 {\n-\t\tfor _, name := range args {\n-\t\t\tfmt.Printf(\"%s\\n\", findEnv(env, name))\n-\t\t}\n-\t\treturn\n-\t}\n-\n-\tfor _, e := range env {\n-\t\tif e.name != \"TERM\" {\n-\t\t\tswitch runtime.GOOS {\n-\t\t\tdefault:\n-\t\t\t\tfmt.Printf(\"%s=\\\"%s\\\"\\n\", e.name, e.value)\n-\t\t\tcase \"plan9\":\n-\t\t\t\tif strings.IndexByte(e.value, '\\x00') < 0 {\n-\t\t\t\t\tfmt.Printf(\"%s='%s'\\n\", e.name, strings.Replace(e.value, \"'\", \"''\", -1))\n-\t\t\t\t} else {\n-\t\t\t\t\tv := strings.Split(e.value, \"\\x00\")\n-\t\t\t\t\tfmt.Printf(\"%s=(\", e.name)\n-\t\t\t\t\tfor x, s := range v {\n-\t\t\t\t\t\tif x > 0 {\n-\t\t\t\t\t\t\tfmt.Printf(\" \")\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tfmt.Printf(\"%s\", s)\n-\t\t\t\t\t}\n-\t\t\t\t\tfmt.Printf(\")\\n\")\n-\t\t\t\t}\n-\t\t\tcase \"windows\":\n-\t\t\t\tfmt.Printf(\"set %s=%s\\n\", e.name, e.value)\n-\t\t\t}\n-\t\t}\n-\t}\n-}"}, {"sha": "28fb5efe328ea04e0752373ca6135b411fe82eec", "filename": "libgo/go/cmd/go/go_test.go", "status": "modified", "additions": 650, "deletions": 81, "changes": 731, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_test.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -7,7 +7,6 @@ package main_test\n import (\n \t\"bytes\"\n \t\"fmt\"\n-\t\"go/build\"\n \t\"go/format\"\n \t\"internal/race\"\n \t\"internal/testenv\"\n@@ -74,6 +73,13 @@ func init() {\n \t}\n }\n \n+// testGOROOT is the GOROOT to use when running testgo, a cmd/go binary\n+// build from this process's current GOROOT, but run from a different\n+// (temp) directory.\n+var testGOROOT string\n+\n+var testCC string\n+\n // The TestMain function creates a go command for testing purposes and\n // deletes it after the tests have been run.\n func TestMain(m *testing.M) {\n@@ -88,6 +94,20 @@ func TestMain(m *testing.M) {\n \t\t\tos.Exit(2)\n \t\t}\n \n+\t\tout, err = exec.Command(\"go\", \"env\", \"GOROOT\").CombinedOutput()\n+\t\tif err != nil {\n+\t\t\tfmt.Fprintf(os.Stderr, \"could not find testing GOROOT: %v\\n%s\", err, out)\n+\t\t\tos.Exit(2)\n+\t\t}\n+\t\ttestGOROOT = strings.TrimSpace(string(out))\n+\n+\t\tout, err = exec.Command(\"go\", \"env\", \"CC\").CombinedOutput()\n+\t\tif err != nil {\n+\t\t\tfmt.Fprintf(os.Stderr, \"could not find testing CC: %v\\n%s\", err, out)\n+\t\t\tos.Exit(2)\n+\t\t}\n+\t\ttestCC = strings.TrimSpace(string(out))\n+\n \t\tif out, err := exec.Command(\"./testgo\"+exeSuffix, \"env\", \"CGO_ENABLED\").Output(); err != nil {\n \t\t\tfmt.Fprintf(os.Stderr, \"running testgo failed: %v\\n\", err)\n \t\t\tcanRun = false\n@@ -100,7 +120,9 @@ func TestMain(m *testing.M) {\n \n \t\tswitch runtime.GOOS {\n \t\tcase \"linux\", \"darwin\", \"freebsd\", \"windows\":\n-\t\t\tcanRace = canCgo && runtime.GOARCH == \"amd64\" && runtime.Compiler != \"gccgo\"\n+\t\t\t// The race detector doesn't work on Alpine Linux:\n+\t\t\t// golang.org/issue/14481\n+\t\t\tcanRace = canCgo && runtime.GOARCH == \"amd64\" && !isAlpineLinux() && runtime.Compiler != \"gccgo\"\n \t\t}\n \t}\n \n@@ -111,7 +133,7 @@ func TestMain(m *testing.M) {\n \tif home, ccacheDir := os.Getenv(\"HOME\"), os.Getenv(\"CCACHE_DIR\"); home != \"\" && ccacheDir == \"\" {\n \t\t// On some systems the default C compiler is ccache.\n \t\t// Setting HOME to a non-existent directory will break\n-\t\t// those systems.  Set CCACHE_DIR to cope.  Issue 17668.\n+\t\t// those systems. Set CCACHE_DIR to cope. Issue 17668.\n \t\tos.Setenv(\"CCACHE_DIR\", filepath.Join(home, \".ccache\"))\n \t}\n \tos.Setenv(\"HOME\", \"/test-go-home-does-not-exist\")\n@@ -125,6 +147,14 @@ func TestMain(m *testing.M) {\n \tos.Exit(r)\n }\n \n+func isAlpineLinux() bool {\n+\tif runtime.GOOS != \"linux\" {\n+\t\treturn false\n+\t}\n+\tfi, err := os.Lstat(\"/etc/alpine-release\")\n+\treturn err == nil && fi.Mode().IsRegular()\n+}\n+\n // The length of an mtime tick on this system. This is an estimate of\n // how long we need to sleep to ensure that the mtime of two files is\n // different.\n@@ -251,6 +281,13 @@ func (tg *testgoData) unsetenv(name string) {\n \t}\n }\n \n+func (tg *testgoData) goTool() string {\n+\tif tg.wd == \"\" {\n+\t\treturn \"./testgo\" + exeSuffix\n+\t}\n+\treturn filepath.Join(tg.wd, \"testgo\"+exeSuffix)\n+}\n+\n // doRun runs the test go command, recording stdout and stderr and\n // returning exit status.\n func (tg *testgoData) doRun(args []string) error {\n@@ -264,13 +301,20 @@ func (tg *testgoData) doRun(args []string) error {\n \t\t\t}\n \t\t}\n \t}\n-\ttg.t.Logf(\"running testgo %v\", args)\n-\tvar prog string\n-\tif tg.wd == \"\" {\n-\t\tprog = \"./testgo\" + exeSuffix\n-\t} else {\n-\t\tprog = filepath.Join(tg.wd, \"testgo\"+exeSuffix)\n+\n+\thasGoroot := false\n+\tfor _, v := range tg.env {\n+\t\tif strings.HasPrefix(v, \"GOROOT=\") {\n+\t\t\thasGoroot = true\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\tprog := tg.goTool()\n+\tif !hasGoroot {\n+\t\ttg.setenv(\"GOROOT\", testGOROOT)\n \t}\n+\n+\ttg.t.Logf(\"running testgo %v\", args)\n \tcmd := exec.Command(prog, args...)\n \ttg.stdout.Reset()\n \ttg.stderr.Reset()\n@@ -365,7 +409,7 @@ func (tg *testgoData) doGrepMatch(match string, b *bytes.Buffer) bool {\n \n // doGrep looks for a regular expression in a buffer and fails if it\n // is not found. The name argument is the name of the output we are\n-// searching, \"output\" or \"error\".  The msg argument is logged on\n+// searching, \"output\" or \"error\". The msg argument is logged on\n // failure.\n func (tg *testgoData) doGrep(match string, b *bytes.Buffer, name, msg string) {\n \tif !tg.doGrepMatch(match, b) {\n@@ -1354,7 +1398,7 @@ func TestInstallFailsWithNoBuildableFiles(t *testing.T) {\n \ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n \ttg.setenv(\"CGO_ENABLED\", \"0\")\n \ttg.runFail(\"install\", \"cgotest\")\n-\ttg.grepStderr(\"no buildable Go source files\", \"go install cgotest did not report 'no buildable Go Source files'\")\n+\ttg.grepStderr(\"build constraints exclude all Go files\", \"go install cgotest did not report 'build constraints exclude all Go files'\")\n }\n \n func TestRelativeGOBINFail(t *testing.T) {\n@@ -1483,11 +1527,11 @@ func TestGoGetNonPkg(t *testing.T) {\n \ttg.setenv(\"GOPATH\", tg.path(\".\"))\n \ttg.setenv(\"GOBIN\", tg.path(\"gobin\"))\n \ttg.runFail(\"get\", \"-d\", \"golang.org/x/tools\")\n-\ttg.grepStderr(\"golang.org/x/tools: no buildable Go source files\", \"missing error\")\n+\ttg.grepStderr(\"golang.org/x/tools: no Go files\", \"missing error\")\n \ttg.runFail(\"get\", \"-d\", \"-u\", \"golang.org/x/tools\")\n-\ttg.grepStderr(\"golang.org/x/tools: no buildable Go source files\", \"missing error\")\n+\ttg.grepStderr(\"golang.org/x/tools: no Go files\", \"missing error\")\n \ttg.runFail(\"get\", \"-d\", \"golang.org/x/tools\")\n-\ttg.grepStderr(\"golang.org/x/tools: no buildable Go source files\", \"missing error\")\n+\ttg.grepStderr(\"golang.org/x/tools: no Go files\", \"missing error\")\n }\n \n func TestGoGetTestOnlyPkg(t *testing.T) {\n@@ -1753,7 +1797,7 @@ func TestDefaultGOPATHPrintedSearchList(t *testing.T) {\n \ttg.grepStderr(regexp.QuoteMeta(tg.path(\"home/go/src/github.com/golang/example/hello\"))+`.*from \\$GOPATH`, \"expected default GOPATH\")\n }\n \n-// Issue 4186.  go get cannot be used to download packages to $GOROOT.\n+// Issue 4186. go get cannot be used to download packages to $GOROOT.\n // Test that without GOPATH set, go get should fail.\n func TestGoGetIntoGOROOT(t *testing.T) {\n \ttestenv.MustHaveExternalNetwork(t)\n@@ -1895,10 +1939,7 @@ func TestGoTestDashIDashOWritesBinary(t *testing.T) {\n \n // Issue 4568.\n func TestSymlinksList(t *testing.T) {\n-\tswitch runtime.GOOS {\n-\tcase \"plan9\", \"windows\":\n-\t\tt.Skipf(\"skipping symlink test on %s\", runtime.GOOS)\n-\t}\n+\ttestenv.MustHaveSymlink(t)\n \n \ttg := testgo(t)\n \tdefer tg.cleanup()\n@@ -1916,10 +1957,7 @@ func TestSymlinksList(t *testing.T) {\n \n // Issue 14054.\n func TestSymlinksVendor(t *testing.T) {\n-\tswitch runtime.GOOS {\n-\tcase \"plan9\", \"windows\":\n-\t\tt.Skipf(\"skipping symlink test on %s\", runtime.GOOS)\n-\t}\n+\ttestenv.MustHaveSymlink(t)\n \n \ttg := testgo(t)\n \tdefer tg.cleanup()\n@@ -1943,10 +1981,7 @@ func TestSymlinksVendor(t *testing.T) {\n \n // Issue 15201.\n func TestSymlinksVendor15201(t *testing.T) {\n-\tswitch runtime.GOOS {\n-\tcase \"plan9\", \"windows\":\n-\t\tt.Skipf(\"skipping symlink test on %s\", runtime.GOOS)\n-\t}\n+\ttestenv.MustHaveSymlink(t)\n \n \ttg := testgo(t)\n \tdefer tg.cleanup()\n@@ -1963,10 +1998,7 @@ func TestSymlinksVendor15201(t *testing.T) {\n }\n \n func TestSymlinksInternal(t *testing.T) {\n-\tswitch runtime.GOOS {\n-\tcase \"plan9\", \"windows\":\n-\t\tt.Skipf(\"skipping symlink test on %s\", runtime.GOOS)\n-\t}\n+\ttestenv.MustHaveSymlink(t)\n \n \ttg := testgo(t)\n \tdefer tg.cleanup()\n@@ -2030,8 +2062,10 @@ func TestCaseCollisions(t *testing.T) {\n \t\t)`)\n \ttg.tempFile(\"src/example/a/pkg/pkg.go\", `package pkg`)\n \ttg.tempFile(\"src/example/a/Pkg/pkg.go\", `package pkg`)\n-\ttg.runFail(\"list\", \"example/a\")\n-\ttg.grepStderr(\"case-insensitive import collision\", \"go list example/a did not report import collision\")\n+\ttg.run(\"list\", \"-json\", \"example/a\")\n+\ttg.grepStdout(\"case-insensitive import collision\", \"go list -json example/a did not report import collision\")\n+\ttg.runFail(\"build\", \"example/a\")\n+\ttg.grepStderr(\"case-insensitive import collision\", \"go build example/a did not report import collision\")\n \ttg.tempFile(\"src/example/b/file.go\", `package b`)\n \ttg.tempFile(\"src/example/b/FILE.go\", `package b`)\n \tf, err := os.Open(tg.path(\"src/example/b\"))\n@@ -2049,6 +2083,38 @@ func TestCaseCollisions(t *testing.T) {\n \t}\n \ttg.runFail(args...)\n \ttg.grepStderr(\"case-insensitive file name collision\", \"go list example/b did not report file name collision\")\n+\n+\ttg.runFail(\"list\", \"example/a/pkg\", \"example/a/Pkg\")\n+\ttg.grepStderr(\"case-insensitive import collision\", \"go list example/a/pkg example/a/Pkg did not report import collision\")\n+\ttg.run(\"list\", \"-json\", \"-e\", \"example/a/pkg\", \"example/a/Pkg\")\n+\ttg.grepStdout(\"case-insensitive import collision\", \"go list -json -e example/a/pkg example/a/Pkg did not report import collision\")\n+\ttg.runFail(\"build\", \"example/a/pkg\", \"example/a/Pkg\")\n+\ttg.grepStderr(\"case-insensitive import collision\", \"go build example/a/pkg example/a/Pkg did not report import collision\")\n+}\n+\n+// Issue 17451, 17662.\n+func TestSymlinkWarning(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.parallel()\n+\ttg.makeTempdir()\n+\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n+\n+\ttg.tempDir(\"src/example/xx\")\n+\ttg.tempDir(\"yy/zz\")\n+\ttg.tempFile(\"yy/zz/zz.go\", \"package zz\\n\")\n+\tif err := os.Symlink(tg.path(\"yy\"), tg.path(\"src/example/xx/yy\")); err != nil {\n+\t\tt.Skip(\"symlink failed: %v\", err)\n+\t}\n+\ttg.run(\"list\", \"example/xx/z...\")\n+\ttg.grepStdoutNot(\".\", \"list should not have matched anything\")\n+\ttg.grepStderr(\"matched no packages\", \"list should have reported that pattern matched no packages\")\n+\ttg.grepStderrNot(\"symlink\", \"list should not have reported symlink\")\n+\n+\ttg.run(\"list\", \"example/xx/...\")\n+\ttg.grepStdoutNot(\".\", \"list should not have matched anything\")\n+\ttg.grepStderr(\"matched no packages\", \"list should have reported that pattern matched no packages\")\n+\ttg.grepStderr(\"ignoring symlink\", \"list should have reported symlink\")\n }\n \n // Issue 8181.\n@@ -2195,29 +2261,6 @@ func TestCoverageUsesAtomicModeForRace(t *testing.T) {\n \tcheckCoverage(tg, data)\n }\n \n-func TestCoverageUsesActualSettingToOverrideEvenForRace(t *testing.T) {\n-\tif testing.Short() {\n-\t\tt.Skip(\"don't build libraries for coverage in short mode\")\n-\t}\n-\tif !canRace {\n-\t\tt.Skip(\"skipping because race detector not supported\")\n-\t}\n-\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\ttg.creatingTemp(\"testdata/cover.out\")\n-\ttg.run(\"test\", \"-short\", \"-race\", \"-cover\", \"encoding/binary\", \"-covermode=count\", \"-coverprofile=testdata/cover.out\")\n-\tdata := tg.getStdout() + tg.getStderr()\n-\tif out, err := ioutil.ReadFile(\"testdata/cover.out\"); err != nil {\n-\t\tt.Error(err)\n-\t} else {\n-\t\tif !bytes.Contains(out, []byte(\"mode: count\")) {\n-\t\t\tt.Error(\"missing mode: count\")\n-\t\t}\n-\t}\n-\tcheckCoverage(tg, data)\n-}\n-\n func TestCoverageImportMainLoop(t *testing.T) {\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n@@ -2228,14 +2271,27 @@ func TestCoverageImportMainLoop(t *testing.T) {\n \ttg.grepStderr(\"not an importable package\", \"did not detect import main\")\n }\n \n+func TestPluginNonMain(t *testing.T) {\n+\twd, err := os.Getwd()\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\n+\tpkg := filepath.Join(wd, \"testdata\", \"testdep\", \"p2\")\n+\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\n+\ttg.runFail(\"build\", \"-buildmode=plugin\", pkg)\n+}\n+\n func TestTestEmpty(t *testing.T) {\n \tif !canRace {\n \t\tt.Skip(\"no race detector\")\n \t}\n \n \twd, _ := os.Getwd()\n \ttestdata := filepath.Join(wd, \"testdata\")\n-\n \tfor _, dir := range []string{\"pkg\", \"test\", \"xtest\", \"pkgtest\", \"pkgxtest\", \"pkgtestxtest\", \"testxtest\"} {\n \t\tt.Run(dir, func(t *testing.T) {\n \t\t\ttg := testgo(t)\n@@ -2250,10 +2306,36 @@ func TestTestEmpty(t *testing.T) {\n \t}\n }\n \n+func TestNoGoError(t *testing.T) {\n+\twd, _ := os.Getwd()\n+\ttestdata := filepath.Join(wd, \"testdata\")\n+\tfor _, dir := range []string{\"empty/test\", \"empty/xtest\", \"empty/testxtest\", \"exclude\", \"exclude/ignore\", \"exclude/empty\"} {\n+\t\tt.Run(dir, func(t *testing.T) {\n+\t\t\ttg := testgo(t)\n+\t\t\tdefer tg.cleanup()\n+\t\t\ttg.setenv(\"GOPATH\", testdata)\n+\t\t\ttg.cd(filepath.Join(testdata, \"src\"))\n+\t\t\ttg.runFail(\"build\", \"./\"+dir)\n+\t\t\tvar want string\n+\t\t\tif strings.Contains(dir, \"test\") {\n+\t\t\t\twant = \"no non-test Go files in \"\n+\t\t\t} else if dir == \"exclude\" {\n+\t\t\t\twant = \"build constraints exclude all Go files in \"\n+\t\t\t} else {\n+\t\t\t\twant = \"no Go files in \"\n+\t\t\t}\n+\t\t\ttg.grepStderr(want, \"wrong reason for failure\")\n+\t\t})\n+\t}\n+}\n+\n func TestTestRaceInstall(t *testing.T) {\n \tif !canRace {\n \t\tt.Skip(\"no race detector\")\n \t}\n+\tif testing.Short() && testenv.Builder() == \"\" {\n+\t\tt.Skip(\"don't rebuild the standard library in short mode\")\n+\t}\n \n \ttg := testgo(t)\n \tdefer tg.cleanup()\n@@ -2308,6 +2390,19 @@ func TestCoverageWithCgo(t *testing.T) {\n \t}\n }\n \n+func TestCgoAsmError(t *testing.T) {\n+\tif !canCgo {\n+\t\tt.Skip(\"skipping because cgo not enabled\")\n+\t}\n+\n+\ttg := testgo(t)\n+\ttg.parallel()\n+\tdefer tg.cleanup()\n+\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n+\ttg.runFail(\"build\", \"cgoasm\")\n+\ttg.grepBoth(\"package using cgo has Go assembly file\", \"did not detect Go assembly file\")\n+}\n+\n func TestCgoDependsOnSyscall(t *testing.T) {\n \tif testing.Short() {\n \t\tt.Skip(\"skipping test that removes $GOROOT/pkg/*_race in short mode\")\n@@ -2445,7 +2540,7 @@ import \"C\"\n func main() { C.f() }`)\n \ttg.setenv(\"GOPATH\", tg.path(\".\"))\n \ttg.run(\"build\", \"-n\", \"-compiler\", \"gccgo\", \"cgoref\")\n-\ttg.grepStderr(`gccgo.*\\-L alibpath \\-lalib`, `no Go-inline \"#cgo LDFLAGS:\" (\"-L alibpath -lalib\") passed to gccgo linking stage`)\n+\ttg.grepStderr(`gccgo.*\\-L [^ ]*alibpath \\-lalib`, `no Go-inline \"#cgo LDFLAGS:\" (\"-L alibpath -lalib\") passed to gccgo linking stage`)\n }\n \n func TestListTemplateContextFunction(t *testing.T) {\n@@ -2535,7 +2630,7 @@ func TestGoBuildInTestOnlyDirectoryFailsWithAGoodError(t *testing.T) {\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n \ttg.runFail(\"build\", \"./testdata/testonly\")\n-\ttg.grepStderr(\"no buildable Go\", \"go build ./testdata/testonly produced unexpected error\")\n+\ttg.grepStderr(\"no non-test Go files in\", \"go build ./testdata/testonly produced unexpected error\")\n }\n \n func TestGoTestDetectsTestOnlyImportCycles(t *testing.T) {\n@@ -2674,8 +2769,7 @@ func TestGoGetInternalWildcard(t *testing.T) {\n }\n \n func TestGoVetWithExternalTests(t *testing.T) {\n-\ttestenv.MustHaveExternalNetwork(t)\n-\n+\tskipIfGccgo(t, \"gccgo does not have vet\")\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n \ttg.makeTempdir()\n@@ -2686,27 +2780,47 @@ func TestGoVetWithExternalTests(t *testing.T) {\n }\n \n func TestGoVetWithTags(t *testing.T) {\n-\ttestenv.MustHaveExternalNetwork(t)\n-\n+\tskipIfGccgo(t, \"gccgo does not have vet\")\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n \ttg.makeTempdir()\n \ttg.run(\"install\", \"cmd/vet\")\n \ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n \ttg.runFail(\"vet\", \"-tags\", \"tagtest\", \"vetpkg\")\n-\ttg.grepBoth(`c\\.go.*wrong number of args for format`, \"go get vetpkg did not run scan tagged file\")\n+\ttg.grepBoth(`c\\.go.*wrong number of args for format`, \"go vet vetpkg did not run scan tagged file\")\n+}\n+\n+func TestGoVetWithFlagsOn(t *testing.T) {\n+\tskipIfGccgo(t, \"gccgo does not have vet\")\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.makeTempdir()\n+\ttg.run(\"install\", \"cmd/vet\")\n+\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n+\ttg.runFail(\"vet\", \"-printf\", \"vetpkg\")\n+\ttg.grepBoth(\"missing argument for Printf\", \"go vet -printf vetpkg did not find missing argument for Printf\")\n+}\n+\n+func TestGoVetWithFlagsOff(t *testing.T) {\n+\tskipIfGccgo(t, \"gccgo does not have vet\")\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.makeTempdir()\n+\ttg.run(\"install\", \"cmd/vet\")\n+\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n+\ttg.run(\"vet\", \"-printf=false\", \"vetpkg\")\n }\n \n-// Issue 9767.\n-func TestGoGetRscIoToolstash(t *testing.T) {\n+// Issue 9767, 19769.\n+func TestGoGetDotSlashDownload(t *testing.T) {\n \ttestenv.MustHaveExternalNetwork(t)\n \n \ttg := testgo(t)\n \tdefer tg.cleanup()\n \ttg.tempDir(\"src/rsc.io\")\n \ttg.setenv(\"GOPATH\", tg.path(\".\"))\n \ttg.cd(tg.path(\"src/rsc.io\"))\n-\ttg.run(\"get\", \"./toolstash\")\n+\ttg.run(\"get\", \"./pprof_mac_fix\")\n }\n \n // Issue 13037: Was not parsing <meta> tags in 404 served over HTTPS\n@@ -3047,17 +3161,8 @@ func TestGoInstallPkgdir(t *testing.T) {\n }\n \n func TestGoTestRaceInstallCgo(t *testing.T) {\n-\tskipIfGccgo(t, \"gccgo has no race detector\")\n-\n-\tswitch sys := runtime.GOOS + \"/\" + runtime.GOARCH; sys {\n-\tcase \"darwin/amd64\", \"freebsd/amd64\", \"linux/amd64\", \"windows/amd64\":\n-\t\t// ok\n-\tdefault:\n-\t\tt.Skip(\"no race detector on %s\", sys)\n-\t}\n-\n-\tif !build.Default.CgoEnabled {\n-\t\tt.Skip(\"no race detector without cgo\")\n+\tif !canRace {\n+\t\tt.Skip(\"skipping because race detector not supported\")\n \t}\n \n \t// golang.org/issue/10500.\n@@ -3071,7 +3176,7 @@ func TestGoTestRaceInstallCgo(t *testing.T) {\n \ttg.run(\"test\", \"-race\", \"-i\", \"runtime/race\")\n \tnew, err := os.Stat(cgo)\n \ttg.must(err)\n-\tif new.ModTime() != old.ModTime() {\n+\tif !new.ModTime().Equal(old.ModTime()) {\n \t\tt.Fatalf(\"go test -i runtime/race reinstalled cmd/cgo\")\n \t}\n }\n@@ -3100,7 +3205,7 @@ func TestGoTestRaceFailures(t *testing.T) {\n func TestGoTestImportErrorStack(t *testing.T) {\n \tconst out = `package testdep/p1 (test)\n \timports testdep/p2\n-\timports testdep/p3: no buildable Go source files`\n+\timports testdep/p3: build constraints exclude all Go files `\n \n \ttg := testgo(t)\n \tdefer tg.cleanup()\n@@ -3141,6 +3246,20 @@ func TestGoGetUpdate(t *testing.T) {\n \ttg.run(\"get\", \"-d\", \"-u\", \"github.com/rsc/go-get-issue-9224-cmd\")\n }\n \n+// Issue #20512.\n+func TestGoGetRace(t *testing.T) {\n+\ttestenv.MustHaveExternalNetwork(t)\n+\tif !canRace {\n+\t\tt.Skip(\"skipping because race detector not supported\")\n+\t}\n+\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.makeTempdir()\n+\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n+\ttg.run(\"get\", \"-race\", \"github.com/rsc/go-get-issue-9224-cmd\")\n+}\n+\n func TestGoGetDomainRoot(t *testing.T) {\n \t// golang.org/issue/9357.\n \t// go get foo.io (not foo.io/subdir) was not working consistently.\n@@ -3477,7 +3596,7 @@ func TestBinaryOnlyPackages(t *testing.T) {\n \t\tfunc F() { p1.F(true) }\n \t`)\n \ttg.runFail(\"install\", \"p2\")\n-\ttg.grepStderr(\"no buildable Go source files\", \"did not complain about missing sources\")\n+\ttg.grepStderr(\"no Go files\", \"did not complain about missing sources\")\n \n \ttg.tempFile(\"src/p1/missing.go\", `//go:binary-only-package\n \n@@ -3675,6 +3794,28 @@ func TestMatchesOnlyBenchmarkIsOK(t *testing.T) {\n \ttg.grepBoth(okPattern, \"go test did not say ok\")\n }\n \n+func TestBenchmarkLabels(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\t// TODO: tg.parallel()\n+\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n+\ttg.run(\"test\", \"-run\", \"^$\", \"-bench\", \".\", \"bench\")\n+\ttg.grepStdout(`(?m)^goos: `+runtime.GOOS, \"go test did not print goos\")\n+\ttg.grepStdout(`(?m)^goarch: `+runtime.GOARCH, \"go test did not print goarch\")\n+\ttg.grepStdout(`(?m)^pkg: bench`, \"go test did not say pkg: bench\")\n+\ttg.grepBothNot(`(?s)pkg:.*pkg:`, \"go test said pkg multiple times\")\n+}\n+\n+func TestBenchmarkLabelsOutsideGOPATH(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\t// TODO: tg.parallel()\n+\ttg.run(\"test\", \"-run\", \"^$\", \"-bench\", \".\", \"testdata/standalone_benchmark_test.go\")\n+\ttg.grepStdout(`(?m)^goos: `+runtime.GOOS, \"go test did not print goos\")\n+\ttg.grepStdout(`(?m)^goarch: `+runtime.GOARCH, \"go test did not print goarch\")\n+\ttg.grepBothNot(`(?m)^pkg:`, \"go test did say pkg:\")\n+}\n+\n func TestMatchesOnlyTestIsOK(t *testing.T) {\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n@@ -3804,3 +3945,431 @@ func TestA(t *testing.T) {}`)\n \ttg.grepStdout(\"pkgs$\", \"expected package not listed\")\n \ttg.grepStdout(\"pkgs/a\", \"expected package not listed\")\n }\n+\n+// Issue 18975.\n+func TestFFLAGS(t *testing.T) {\n+\tif !canCgo {\n+\t\tt.Skip(\"skipping because cgo not enabled\")\n+\t}\n+\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.parallel()\n+\n+\ttg.tempFile(\"p/src/p/main.go\", `package main\n+\t\t// #cgo FFLAGS: -no-such-fortran-flag\n+\t\timport \"C\"\n+\t\tfunc main() {}\n+\t`)\n+\ttg.tempFile(\"p/src/p/a.f\", `! comment`)\n+\ttg.setenv(\"GOPATH\", tg.path(\"p\"))\n+\n+\t// This should normally fail because we are passing an unknown flag,\n+\t// but issue #19080 points to Fortran compilers that succeed anyhow.\n+\t// To work either way we call doRun directly rather than run or runFail.\n+\ttg.doRun([]string{\"build\", \"-x\", \"p\"})\n+\n+\ttg.grepStderr(\"no-such-fortran-flag\", `missing expected \"-no-such-fortran-flag\"`)\n+}\n+\n+// Issue 19198.\n+// This is really a cmd/link issue but this is a convenient place to test it.\n+func TestDuplicateGlobalAsmSymbols(t *testing.T) {\n+\tskipIfGccgo(t, \"gccgo does not use cmd/asm\")\n+\tif runtime.GOARCH != \"386\" && runtime.GOARCH != \"amd64\" {\n+\t\tt.Skipf(\"skipping test on %s\", runtime.GOARCH)\n+\t}\n+\tif !canCgo {\n+\t\tt.Skip(\"skipping because cgo not enabled\")\n+\t}\n+\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.parallel()\n+\n+\tasm := `\n+#include \"textflag.h\"\n+\n+DATA sym<>+0x0(SB)/8,$0\n+GLOBL sym<>(SB),(NOPTR+RODATA),$8\n+\n+TEXT \u00b7Data(SB),NOSPLIT,$0\n+\tMOVB sym<>(SB), AX\n+\tMOVB AX, ret+0(FP)\n+\tRET\n+`\n+\ttg.tempFile(\"go/src/a/a.s\", asm)\n+\ttg.tempFile(\"go/src/a/a.go\", `package a; func Data() uint8`)\n+\ttg.tempFile(\"go/src/b/b.s\", asm)\n+\ttg.tempFile(\"go/src/b/b.go\", `package b; func Data() uint8`)\n+\ttg.tempFile(\"go/src/p/p.go\", `\n+package main\n+import \"a\"\n+import \"b\"\n+import \"C\"\n+func main() {\n+\t_ = a.Data() + b.Data()\n+}\n+`)\n+\ttg.setenv(\"GOPATH\", tg.path(\"go\"))\n+\texe := filepath.Join(tg.tempdir, \"p.exe\")\n+\ttg.creatingTemp(exe)\n+\ttg.run(\"build\", \"-o\", exe, \"p\")\n+}\n+\n+func TestBuildTagsNoComma(t *testing.T) {\n+\tskipIfGccgo(t, \"gccgo has no standard packages\")\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.makeTempdir()\n+\ttg.setenv(\"GOPATH\", tg.path(\"go\"))\n+\ttg.run(\"install\", \"-tags\", \"tag1 tag2\", \"math\")\n+\ttg.runFail(\"install\", \"-tags\", \"tag1,tag2\", \"math\")\n+\ttg.grepBoth(\"space-separated list contains comma\", \"-tags with a comma-separated list didn't error\")\n+\ttg.runFail(\"build\", \"-tags\", \"tag1,tag2\", \"math\")\n+\ttg.grepBoth(\"space-separated list contains comma\", \"-tags with a comma-separated list didn't error\")\n+}\n+\n+func copyFile(src, dst string, perm os.FileMode) error {\n+\tsf, err := os.Open(src)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tdefer sf.Close()\n+\n+\tdf, err := os.OpenFile(dst, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, perm)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\t_, err = io.Copy(df, sf)\n+\terr2 := df.Close()\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\treturn err2\n+}\n+\n+func TestExecutableGOROOT(t *testing.T) {\n+\tskipIfGccgo(t, \"gccgo has no GOROOT\")\n+\tif runtime.GOOS == \"openbsd\" {\n+\t\tt.Skipf(\"test case does not work on %s, missing os.Executable\", runtime.GOOS)\n+\t}\n+\n+\t// Env with no GOROOT.\n+\tvar env []string\n+\tfor _, e := range os.Environ() {\n+\t\tif !strings.HasPrefix(e, \"GOROOT=\") {\n+\t\t\tenv = append(env, e)\n+\t\t}\n+\t}\n+\n+\tcheck := func(t *testing.T, exe, want string) {\n+\t\tcmd := exec.Command(exe, \"env\", \"GOROOT\")\n+\t\tcmd.Env = env\n+\t\tout, err := cmd.CombinedOutput()\n+\t\tif err != nil {\n+\t\t\tt.Fatalf(\"%s env GOROOT: %v, %s\", exe, err, out)\n+\t\t}\n+\t\tgoroot, err := filepath.EvalSymlinks(strings.TrimSpace(string(out)))\n+\t\tif err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\t\twant, err = filepath.EvalSymlinks(want)\n+\t\tif err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\t\tif !strings.EqualFold(goroot, want) {\n+\t\t\tt.Errorf(\"go env GOROOT:\\nhave %s\\nwant %s\", goroot, want)\n+\t\t} else {\n+\t\t\tt.Logf(\"go env GOROOT: %s\", goroot)\n+\t\t}\n+\t}\n+\n+\t// Note: Must not call tg methods inside subtests: tg is attached to outer t.\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\n+\ttg.makeTempdir()\n+\ttg.tempDir(\"new/bin\")\n+\tnewGoTool := tg.path(\"new/bin/go\" + exeSuffix)\n+\ttg.must(copyFile(tg.goTool(), newGoTool, 0775))\n+\tnewRoot := tg.path(\"new\")\n+\n+\tt.Run(\"RelocatedExe\", func(t *testing.T) {\n+\t\tt.Skip(\"TODO: skipping known broken test; see golang.org/issue/20284\")\n+\n+\t\t// Should fall back to default location in binary.\n+\t\t// No way to dig out other than look at source code.\n+\t\tdata, err := ioutil.ReadFile(\"../../runtime/internal/sys/zversion.go\")\n+\t\tif err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\t\tm := regexp.MustCompile(\"const DefaultGoroot = `([^`]+)`\").FindStringSubmatch(string(data))\n+\t\tif m == nil {\n+\t\t\tt.Fatal(\"cannot find DefaultGoroot in ../../runtime/internal/sys/zversion.go\")\n+\t\t}\n+\t\tcheck(t, newGoTool, m[1])\n+\t})\n+\n+\t// If the binary is sitting in a bin dir next to ../pkg/tool, that counts as a GOROOT,\n+\t// so it should find the new tree.\n+\ttg.tempDir(\"new/pkg/tool\")\n+\tt.Run(\"RelocatedTree\", func(t *testing.T) {\n+\t\tcheck(t, newGoTool, newRoot)\n+\t})\n+\n+\ttg.tempDir(\"other/bin\")\n+\tsymGoTool := tg.path(\"other/bin/go\" + exeSuffix)\n+\n+\t// Symlink into go tree should still find go tree.\n+\tt.Run(\"SymlinkedExe\", func(t *testing.T) {\n+\t\ttestenv.MustHaveSymlink(t)\n+\t\tif err := os.Symlink(newGoTool, symGoTool); err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\t\tcheck(t, symGoTool, newRoot)\n+\t})\n+}\n+\n+func TestNeedVersion(t *testing.T) {\n+\tskipIfGccgo(t, \"gccgo does not use cmd/compile\")\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.parallel()\n+\ttg.tempFile(\"goversion.go\", `package main; func main() {}`)\n+\tpath := tg.path(\"goversion.go\")\n+\ttg.setenv(\"TESTGO_VERSION\", \"go1.testgo\")\n+\ttg.runFail(\"run\", path)\n+\ttg.grepStderr(\"compile\", \"does not match go tool version\")\n+}\n+\n+// Test that user can override default code generation flags.\n+func TestUserOverrideFlags(t *testing.T) {\n+\tskipIfGccgo(t, \"gccgo does not use -gcflags\")\n+\tif !canCgo {\n+\t\tt.Skip(\"skipping because cgo not enabled\")\n+\t}\n+\tif runtime.GOOS != \"linux\" {\n+\t\t// We are testing platform-independent code, so it's\n+\t\t// OK to skip cases that work differently.\n+\t\tt.Skipf(\"skipping on %s because test only works if c-archive implies -shared\", runtime.GOOS)\n+\t}\n+\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.parallel()\n+\ttg.tempFile(\"override.go\", `package main\n+\n+import \"C\"\n+\n+//export GoFunc\n+func GoFunc() {}\n+\n+func main() {}`)\n+\ttg.creatingTemp(\"override.a\")\n+\ttg.creatingTemp(\"override.h\")\n+\ttg.run(\"build\", \"-x\", \"-buildmode=c-archive\", \"-gcflags=-shared=false\", tg.path(\"override.go\"))\n+\ttg.grepStderr(\"compile .*-shared .*-shared=false\", \"user can not override code generation flag\")\n+}\n+\n+func TestCgoFlagContainsSpace(t *testing.T) {\n+\tif !canCgo {\n+\t\tt.Skip(\"skipping because cgo not enabled\")\n+\t}\n+\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\n+\tccName := filepath.Base(testCC)\n+\n+\ttg.tempFile(fmt.Sprintf(\"src/%s/main.go\", ccName), fmt.Sprintf(`package main\n+\t\timport (\n+\t\t\t\"os\"\n+\t\t\t\"os/exec\"\n+\t\t\t\"path/filepath\"\n+\t\t\t\"strings\"\n+\t\t)\n+\n+\t\tfunc main() {\n+\t\t\tcmd := exec.Command(%q, os.Args[1:]...)\n+\t\t\tcmd.Stdin = os.Stdin\n+\t\t\tcmd.Stdout = os.Stdout\n+\t\t\tcmd.Stderr = os.Stderr\n+\t\t\terr := cmd.Run()\n+\t\t\tif err != nil {\n+\t\t\t\tpanic(err)\n+\t\t\t}\n+\n+\t\t\tif os.Args[len(os.Args)-1] == \"trivial.c\" {\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tif filepath.Base(os.Args[len(os.Args)-1]) == \"_cgo_defun.c\" {\n+\t\t\t\treturn\n+\t\t\t}\n+\n+\t\t\tvar success bool\n+\t\t\tfor _, arg := range os.Args {\n+\t\t\t\tswitch {\n+\t\t\t\tcase strings.Contains(arg, \"c flags\"):\n+\t\t\t\t\tif success {\n+\t\t\t\t\t\tpanic(\"duplicate CFLAGS\")\n+\t\t\t\t\t}\n+\t\t\t\t\tsuccess = true\n+\t\t\t\tcase strings.Contains(arg, \"ld flags\"):\n+\t\t\t\t\tif success {\n+\t\t\t\t\t\tpanic(\"duplicate LDFLAGS\")\n+\t\t\t\t\t}\n+\t\t\t\t\tsuccess = true\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif !success {\n+\t\t\t\tpanic(\"args should contains '-Ic flags' or '-Lld flags'\")\n+\t\t\t}\n+\t\t}\n+\t`, testCC))\n+\ttg.cd(tg.path(fmt.Sprintf(\"src/%s\", ccName)))\n+\ttg.run(\"build\")\n+\ttg.setenv(\"CC\", tg.path(fmt.Sprintf(\"src/%s/%s\", ccName, ccName)))\n+\n+\ttg.tempFile(\"src/cgo/main.go\", `package main\n+\t\t// #cgo CFLAGS: -I\"c flags\"\n+\t\t// #cgo LDFLAGS: -L\"ld flags\"\n+\t\timport \"C\"\n+\t\tfunc main() {}\n+\t`)\n+\ttg.cd(tg.path(\"src/cgo\"))\n+\ttg.run(\"run\", \"main.go\")\n+}\n+\n+// Issue #20435.\n+func TestGoTestRaceCoverModeFailures(t *testing.T) {\n+\tif !canRace {\n+\t\tt.Skip(\"skipping because race detector not supported\")\n+\t}\n+\n+\ttg := testgo(t)\n+\ttg.parallel()\n+\tdefer tg.cleanup()\n+\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n+\n+\ttg.run(\"test\", \"testrace\")\n+\n+\ttg.runFail(\"test\", \"-race\", \"-covermode=set\", \"testrace\")\n+\ttg.grepStderr(`-covermode must be \"atomic\", not \"set\", when -race is enabled`, \"-race -covermode=set was allowed\")\n+\ttg.grepBothNot(\"PASS\", \"something passed\")\n+}\n+\n+// Issue 9737: verify that GOARM and GO386 affect the computed build ID.\n+func TestBuildIDContainsArchModeEnv(t *testing.T) {\n+\tif testing.Short() {\n+\t\tt.Skip(\"skipping in short mode\")\n+\t}\n+\n+\tvar tg *testgoData\n+\ttestWith := func(before, after func()) func(*testing.T) {\n+\t\treturn func(t *testing.T) {\n+\t\t\ttg = testgo(t)\n+\t\t\tdefer tg.cleanup()\n+\t\t\ttg.tempFile(\"src/mycmd/x.go\", `package main\n+func main() {}`)\n+\t\t\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n+\n+\t\t\ttg.cd(tg.path(\"src/mycmd\"))\n+\t\t\ttg.setenv(\"GOOS\", \"linux\")\n+\t\t\tbefore()\n+\t\t\ttg.run(\"install\", \"mycmd\")\n+\t\t\tafter()\n+\t\t\ttg.wantStale(\"mycmd\", \"build ID mismatch\", \"should be stale after environment variable change\")\n+\t\t}\n+\t}\n+\n+\tt.Run(\"386\", testWith(func() {\n+\t\ttg.setenv(\"GOARCH\", \"386\")\n+\t\ttg.setenv(\"GO386\", \"387\")\n+\t}, func() {\n+\t\ttg.setenv(\"GO386\", \"sse2\")\n+\t}))\n+\n+\tt.Run(\"arm\", testWith(func() {\n+\t\ttg.setenv(\"GOARCH\", \"arm\")\n+\t\ttg.setenv(\"GOARM\", \"5\")\n+\t}, func() {\n+\t\ttg.setenv(\"GOARM\", \"7\")\n+\t}))\n+}\n+\n+func TestTestRegexps(t *testing.T) {\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n+\ttg.run(\"test\", \"-cpu=1\", \"-run=X/Y\", \"-bench=X/Y\", \"-count=2\", \"-v\", \"testregexp\")\n+\tvar lines []string\n+\tfor _, line := range strings.SplitAfter(tg.getStdout(), \"\\n\") {\n+\t\tif strings.Contains(line, \"=== RUN\") || strings.Contains(line, \"--- BENCH\") || strings.Contains(line, \"LOG\") {\n+\t\t\tlines = append(lines, line)\n+\t\t}\n+\t}\n+\n+\t// Important parts:\n+\t//\tTestX is run, twice\n+\t//\tTestX/Y is run, twice\n+\t//\tTestXX is run, twice\n+\t//\tTestZ is not run\n+\t//\tBenchmarkX is run but only with N=1, once\n+\t//\tBenchmarkXX is run but only with N=1, once\n+\t//\tBenchmarkX/Y is run in full, twice\n+\twant := `=== RUN   TestX\n+=== RUN   TestX/Y\n+\tx_test.go:6: LOG: X running\n+    \tx_test.go:8: LOG: Y running\n+=== RUN   TestXX\n+\tz_test.go:10: LOG: XX running\n+=== RUN   TestX\n+=== RUN   TestX/Y\n+\tx_test.go:6: LOG: X running\n+    \tx_test.go:8: LOG: Y running\n+=== RUN   TestXX\n+\tz_test.go:10: LOG: XX running\n+--- BENCH: BenchmarkX/Y\n+\tx_test.go:15: LOG: Y running N=1\n+\tx_test.go:15: LOG: Y running N=100\n+\tx_test.go:15: LOG: Y running N=10000\n+\tx_test.go:15: LOG: Y running N=1000000\n+\tx_test.go:15: LOG: Y running N=100000000\n+\tx_test.go:15: LOG: Y running N=2000000000\n+--- BENCH: BenchmarkX/Y\n+\tx_test.go:15: LOG: Y running N=1\n+\tx_test.go:15: LOG: Y running N=100\n+\tx_test.go:15: LOG: Y running N=10000\n+\tx_test.go:15: LOG: Y running N=1000000\n+\tx_test.go:15: LOG: Y running N=100000000\n+\tx_test.go:15: LOG: Y running N=2000000000\n+--- BENCH: BenchmarkX\n+\tx_test.go:13: LOG: X running N=1\n+--- BENCH: BenchmarkXX\n+\tz_test.go:18: LOG: XX running N=1\n+`\n+\n+\thave := strings.Join(lines, \"\")\n+\tif have != want {\n+\t\tt.Errorf(\"reduced output:<<<\\n%s>>> want:<<<\\n%s>>>\", have, want)\n+\t}\n+}\n+\n+func TestListTests(t *testing.T) {\n+\tvar tg *testgoData\n+\ttestWith := func(listName, expected string) func(*testing.T) {\n+\t\treturn func(t *testing.T) {\n+\t\t\ttg = testgo(t)\n+\t\t\tdefer tg.cleanup()\n+\t\t\ttg.run(\"test\", \"./testdata/src/testlist/...\", fmt.Sprintf(\"-list=%s\", listName))\n+\t\t\ttg.grepStdout(expected, fmt.Sprintf(\"-test.list=%s returned %q, expected %s\", listName, tg.getStdout(), expected))\n+\t\t}\n+\t}\n+\n+\tt.Run(\"Test\", testWith(\"Test\", \"TestSimple\"))\n+\tt.Run(\"Bench\", testWith(\"Benchmark\", \"BenchmarkSimple\"))\n+\tt.Run(\"Example1\", testWith(\"Example\", \"ExampleSimple\"))\n+\tt.Run(\"Example2\", testWith(\"Example\", \"ExampleWithEmptyOutput\"))\n+}"}, {"sha": "f6e10ca59c743f8a2f26bcdbea731196c0259d86", "filename": "libgo/go/cmd/go/go_unix_test.go", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_unix_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_unix_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_unix_test.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -19,9 +19,13 @@ func TestGoBuildUmask(t *testing.T) {\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n \ttg.tempFile(\"x.go\", `package main; func main() {}`)\n-\ttg.creatingTemp(\"x\")\n-\ttg.run(\"build\", tg.path(\"x.go\"))\n-\tfi, err := os.Stat(\"x\")\n+\t// Make sure artifact will be output to /tmp/... in case the user\n+\t// has POSIX acl's on their go source tree.\n+\t// See issue 17909.\n+\texe := tg.path(\"x\")\n+\ttg.creatingTemp(exe)\n+\ttg.run(\"build\", \"-o\", exe, tg.path(\"x.go\"))\n+\tfi, err := os.Stat(exe)\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}"}, {"sha": "aff33f70d8deb3394e708bf2c20e0edeb840087e", "filename": "libgo/go/cmd/go/internal/base/base.go", "status": "added", "additions": 173, "deletions": 0, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fbase.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fbase.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fbase.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -0,0 +1,173 @@\n+// Copyright 2017 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Package base defines shared basic pieces of the go command,\n+// in particular logging and the Command structure.\n+package base\n+\n+import (\n+\t\"bytes\"\n+\t\"errors\"\n+\t\"flag\"\n+\t\"fmt\"\n+\t\"go/scanner\"\n+\t\"log\"\n+\t\"os\"\n+\t\"os/exec\"\n+\t\"strings\"\n+\t\"sync\"\n+\n+\t\"cmd/go/internal/cfg\"\n+\t\"cmd/go/internal/str\"\n+)\n+\n+// A Command is an implementation of a go command\n+// like go build or go fix.\n+type Command struct {\n+\t// Run runs the command.\n+\t// The args are the arguments after the command name.\n+\tRun func(cmd *Command, args []string)\n+\n+\t// UsageLine is the one-line usage message.\n+\t// The first word in the line is taken to be the command name.\n+\tUsageLine string\n+\n+\t// Short is the short description shown in the 'go help' output.\n+\tShort string\n+\n+\t// Long is the long message shown in the 'go help <this-command>' output.\n+\tLong string\n+\n+\t// Flag is a set of flags specific to this command.\n+\tFlag flag.FlagSet\n+\n+\t// CustomFlags indicates that the command will do its own\n+\t// flag parsing.\n+\tCustomFlags bool\n+}\n+\n+// Commands lists the available commands and help topics.\n+// The order here is the order in which they are printed by 'go help'.\n+var Commands []*Command\n+\n+// Name returns the command's name: the first word in the usage line.\n+func (c *Command) Name() string {\n+\tname := c.UsageLine\n+\ti := strings.Index(name, \" \")\n+\tif i >= 0 {\n+\t\tname = name[:i]\n+\t}\n+\treturn name\n+}\n+\n+func (c *Command) Usage() {\n+\tfmt.Fprintf(os.Stderr, \"usage: %s\\n\\n\", c.UsageLine)\n+\tfmt.Fprintf(os.Stderr, \"%s\\n\", strings.TrimSpace(c.Long))\n+\tos.Exit(2)\n+}\n+\n+// Runnable reports whether the command can be run; otherwise\n+// it is a documentation pseudo-command such as importpath.\n+func (c *Command) Runnable() bool {\n+\treturn c.Run != nil\n+}\n+\n+var atExitFuncs []func()\n+\n+func AtExit(f func()) {\n+\tatExitFuncs = append(atExitFuncs, f)\n+}\n+\n+func Exit() {\n+\tfor _, f := range atExitFuncs {\n+\t\tf()\n+\t}\n+\tos.Exit(exitStatus)\n+}\n+\n+func Fatalf(format string, args ...interface{}) {\n+\tErrorf(format, args...)\n+\tExit()\n+}\n+\n+func Errorf(format string, args ...interface{}) {\n+\tlog.Printf(format, args...)\n+\tSetExitStatus(1)\n+}\n+\n+func ExitIfErrors() {\n+\tif exitStatus != 0 {\n+\t\tExit()\n+\t}\n+}\n+\n+var exitStatus = 0\n+var exitMu sync.Mutex\n+\n+func SetExitStatus(n int) {\n+\texitMu.Lock()\n+\tif exitStatus < n {\n+\t\texitStatus = n\n+\t}\n+\texitMu.Unlock()\n+}\n+\n+// Run runs the command, with stdout and stderr\n+// connected to the go command's own stdout and stderr.\n+// If the command fails, Run reports the error using Errorf.\n+func Run(cmdargs ...interface{}) {\n+\tcmdline := str.StringList(cmdargs...)\n+\tif cfg.BuildN || cfg.BuildX {\n+\t\tfmt.Printf(\"%s\\n\", strings.Join(cmdline, \" \"))\n+\t\tif cfg.BuildN {\n+\t\t\treturn\n+\t\t}\n+\t}\n+\n+\tcmd := exec.Command(cmdline[0], cmdline[1:]...)\n+\tcmd.Stdout = os.Stdout\n+\tcmd.Stderr = os.Stderr\n+\tif err := cmd.Run(); err != nil {\n+\t\tErrorf(\"%v\", err)\n+\t}\n+}\n+\n+// RunStdin is like run but connects Stdin.\n+func RunStdin(cmdline []string) {\n+\tcmd := exec.Command(cmdline[0], cmdline[1:]...)\n+\tcmd.Stdin = os.Stdin\n+\tcmd.Stdout = os.Stdout\n+\tcmd.Stderr = os.Stderr\n+\tcmd.Env = cfg.OrigEnv\n+\tStartSigHandlers()\n+\tif err := cmd.Run(); err != nil {\n+\t\tErrorf(\"%v\", err)\n+\t}\n+}\n+\n+// Usage is the usage-reporting function, filled in by package main\n+// but here for reference by other packages.\n+var Usage func()\n+\n+// ExpandScanner expands a scanner.List error into all the errors in the list.\n+// The default Error method only shows the first error\n+// and does not shorten paths.\n+func ExpandScanner(err error) error {\n+\t// Look for parser errors.\n+\tif err, ok := err.(scanner.ErrorList); ok {\n+\t\t// Prepare error with \\n before each message.\n+\t\t// When printed in something like context: %v\n+\t\t// this will put the leading file positions each on\n+\t\t// its own line. It will also show all the errors\n+\t\t// instead of just the first, as err.Error does.\n+\t\tvar buf bytes.Buffer\n+\t\tfor _, e := range err {\n+\t\t\te.Pos.Filename = ShortPath(e.Pos.Filename)\n+\t\t\tbuf.WriteString(\"\\n\")\n+\t\t\tbuf.WriteString(e.Error())\n+\t\t}\n+\t\treturn errors.New(buf.String())\n+\t}\n+\treturn err\n+}"}, {"sha": "fcade9d84e228400547fe3d9532b42ad8b655d32", "filename": "libgo/go/cmd/go/internal/base/env.go", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fenv.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fenv.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fenv.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2017 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package base\n+\n+import \"strings\"\n+\n+// EnvForDir returns a copy of the environment\n+// suitable for running in the given directory.\n+// The environment is the current process's environment\n+// but with an updated $PWD, so that an os.Getwd in the\n+// child will be faster.\n+func EnvForDir(dir string, base []string) []string {\n+\t// Internally we only use rooted paths, so dir is rooted.\n+\t// Even if dir is not rooted, no harm done.\n+\treturn MergeEnvLists([]string{\"PWD=\" + dir}, base)\n+}\n+\n+// MergeEnvLists merges the two environment lists such that\n+// variables with the same name in \"in\" replace those in \"out\".\n+// This always returns a newly allocated slice.\n+func MergeEnvLists(in, out []string) []string {\n+\tout = append([]string(nil), out...)\n+NextVar:\n+\tfor _, inkv := range in {\n+\t\tk := strings.SplitAfterN(inkv, \"=\", 2)[0]\n+\t\tfor i, outkv := range out {\n+\t\t\tif strings.HasPrefix(outkv, k) {\n+\t\t\t\tout[i] = inkv\n+\t\t\t\tcontinue NextVar\n+\t\t\t}\n+\t\t}\n+\t\tout = append(out, inkv)\n+\t}\n+\treturn out\n+}"}, {"sha": "5e03e6405884d27eb5fce6b2623da9187b1760c6", "filename": "libgo/go/cmd/go/internal/base/flag.go", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fflag.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fflag.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fflag.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2017 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package base\n+\n+import (\n+\t\"flag\"\n+\n+\t\"cmd/go/internal/cfg\"\n+\t\"cmd/go/internal/str\"\n+)\n+\n+// A StringsFlag is a command-line flag that interprets its argument\n+// as a space-separated list of possibly-quoted strings.\n+type StringsFlag []string\n+\n+func (v *StringsFlag) Set(s string) error {\n+\tvar err error\n+\t*v, err = str.SplitQuotedFields(s)\n+\tif *v == nil {\n+\t\t*v = []string{}\n+\t}\n+\treturn err\n+}\n+\n+func (v *StringsFlag) String() string {\n+\treturn \"<StringsFlag>\"\n+}\n+\n+// AddBuildFlagsNX adds the -n and -x build flags to the flag set.\n+func AddBuildFlagsNX(flags *flag.FlagSet) {\n+\tflags.BoolVar(&cfg.BuildN, \"n\", false, \"\")\n+\tflags.BoolVar(&cfg.BuildX, \"x\", false, \"\")\n+}"}, {"sha": "4f12fa8c28c316f24a558c9abfb01eb50948961f", "filename": "libgo/go/cmd/go/internal/base/path.go", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fpath.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fpath.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fpath.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -0,0 +1,74 @@\n+// Copyright 2017 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package base\n+\n+import (\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"strings\"\n+)\n+\n+func getwd() string {\n+\twd, err := os.Getwd()\n+\tif err != nil {\n+\t\tFatalf(\"cannot determine current directory: %v\", err)\n+\t}\n+\treturn wd\n+}\n+\n+var Cwd = getwd()\n+\n+// ShortPath returns an absolute or relative name for path, whatever is shorter.\n+func ShortPath(path string) string {\n+\tif rel, err := filepath.Rel(Cwd, path); err == nil && len(rel) < len(path) {\n+\t\treturn rel\n+\t}\n+\treturn path\n+}\n+\n+// RelPaths returns a copy of paths with absolute paths\n+// made relative to the current directory if they would be shorter.\n+func RelPaths(paths []string) []string {\n+\tvar out []string\n+\t// TODO(rsc): Can this use Cwd from above?\n+\tpwd, _ := os.Getwd()\n+\tfor _, p := range paths {\n+\t\trel, err := filepath.Rel(pwd, p)\n+\t\tif err == nil && len(rel) < len(p) {\n+\t\t\tp = rel\n+\t\t}\n+\t\tout = append(out, p)\n+\t}\n+\treturn out\n+}\n+\n+// FilterDotUnderscoreFiles returns a slice containing all elements\n+// of path whose base name doesn't begin with \".\" or \"_\".\n+func FilterDotUnderscoreFiles(path []string) []string {\n+\tvar out []string // lazily initialized\n+\tfor i, p := range path {\n+\t\tbase := filepath.Base(p)\n+\t\tif strings.HasPrefix(base, \".\") || strings.HasPrefix(base, \"_\") {\n+\t\t\tif out == nil {\n+\t\t\t\tout = append(make([]string, 0, len(path)), path[:i]...)\n+\t\t\t}\n+\t\t\tcontinue\n+\t\t}\n+\t\tif out != nil {\n+\t\t\tout = append(out, p)\n+\t\t}\n+\t}\n+\tif out == nil {\n+\t\treturn path\n+\t}\n+\treturn out\n+}\n+\n+// IsTestFile reports whether the source file is a set of tests and should therefore\n+// be excluded from coverage analysis.\n+func IsTestFile(file string) bool {\n+\t// We don't cover tests, only the code they test.\n+\treturn strings.HasSuffix(file, \"_test.go\")\n+}"}, {"sha": "54d11876d07aeeeba70bc2cac70d5f96b14ca8ed", "filename": "libgo/go/cmd/go/internal/base/signal.go", "status": "renamed", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fsignal.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fsignal.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fsignal.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -2,30 +2,30 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-package main\n+package base\n \n import (\n \t\"os\"\n \t\"os/signal\"\n \t\"sync\"\n )\n \n-// interrupted is closed, if go process is interrupted.\n-var interrupted = make(chan struct{})\n+// Interrupted is closed when the go command receives an interrupt signal.\n+var Interrupted = make(chan struct{})\n \n // processSignals setups signal handler.\n func processSignals() {\n \tsig := make(chan os.Signal)\n \tsignal.Notify(sig, signalsToIgnore...)\n \tgo func() {\n \t\t<-sig\n-\t\tclose(interrupted)\n+\t\tclose(Interrupted)\n \t}()\n }\n \n var onceProcessSignals sync.Once\n \n-// startSigHandlers start signal handlers.\n-func startSigHandlers() {\n+// StartSigHandlers starts the signal handlers.\n+func StartSigHandlers() {\n \tonceProcessSignals.Do(processSignals)\n }", "previous_filename": "libgo/go/cmd/go/signal.go"}, {"sha": "9e869b03ea8aafa10c288abfc2771b7c9616d2cd", "filename": "libgo/go/cmd/go/internal/base/signal_notunix.go", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fsignal_notunix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fsignal_notunix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fsignal_notunix.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -4,14 +4,14 @@\n \n // +build plan9 windows\n \n-package main\n+package base\n \n import (\n \t\"os\"\n )\n \n var signalsToIgnore = []os.Signal{os.Interrupt}\n \n-// signalTrace is the signal to send to make a Go program\n-// crash with a stack trace.\n-var signalTrace os.Signal = nil\n+// SignalTrace is the signal to send to make a Go program\n+// crash with a stack trace (no such signal in this case).\n+var SignalTrace os.Signal = nil", "previous_filename": "libgo/go/cmd/go/signal_notunix.go"}, {"sha": "4ca3da99226f8e141fd3b20af3282233a4d1c81c", "filename": "libgo/go/cmd/go/internal/base/signal_unix.go", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fsignal_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fsignal_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fsignal_unix.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -4,7 +4,7 @@\n \n // +build darwin dragonfly freebsd linux nacl netbsd openbsd solaris\n \n-package main\n+package base\n \n import (\n \t\"os\"\n@@ -13,6 +13,6 @@ import (\n \n var signalsToIgnore = []os.Signal{os.Interrupt, syscall.SIGQUIT}\n \n-// signalTrace is the signal to send to make a Go program\n+// SignalTrace is the signal to send to make a Go program\n // crash with a stack trace.\n-var signalTrace os.Signal = syscall.SIGQUIT\n+var SignalTrace os.Signal = syscall.SIGQUIT", "previous_filename": "libgo/go/cmd/go/signal_unix.go"}, {"sha": "c907772c00a51bc8404213ef7d127db86641d3b8", "filename": "libgo/go/cmd/go/internal/base/tool.go", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Ftool.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Ftool.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Ftool.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -0,0 +1,53 @@\n+// Copyright 2017 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package base\n+\n+import (\n+\t\"fmt\"\n+\t\"go/build\"\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"runtime\"\n+\n+\t\"cmd/go/internal/cfg\"\n+)\n+\n+// Configuration for finding tool binaries.\n+var (\n+\tToolGOOS      = runtime.GOOS\n+\tToolGOARCH    = runtime.GOARCH\n+\tToolIsWindows = ToolGOOS == \"windows\"\n+\tToolDir       = build.ToolDir\n+)\n+\n+const ToolWindowsExtension = \".exe\"\n+\n+// Tool returns the path to the named tool (for example, \"vet\").\n+// If the tool cannot be found, Tool exits the process.\n+func Tool(toolName string) string {\n+\ttoolPath := filepath.Join(ToolDir, toolName)\n+\tif ToolIsWindows {\n+\t\ttoolPath += ToolWindowsExtension\n+\t}\n+\tif len(cfg.BuildToolexec) > 0 {\n+\t\treturn toolPath\n+\t}\n+\t// Give a nice message if there is no tool with that name.\n+\tif _, err := os.Stat(toolPath); err != nil {\n+\t\tif isInGoToolsRepo(toolName) {\n+\t\t\tfmt.Fprintf(os.Stderr, \"go tool: no such tool %q; to install:\\n\\tgo get golang.org/x/tools/cmd/%s\\n\", toolName, toolName)\n+\t\t} else {\n+\t\t\tfmt.Fprintf(os.Stderr, \"go tool: no such tool %q\\n\", toolName)\n+\t\t}\n+\t\tSetExitStatus(2)\n+\t\tExit()\n+\t}\n+\treturn toolPath\n+}\n+\n+// TODO: Delete.\n+func isInGoToolsRepo(toolName string) bool {\n+\treturn false\n+}"}, {"sha": "963da94c493c10cb4b47015dbc4a536424e8097c", "filename": "libgo/go/cmd/go/internal/bug/bug.go", "status": "renamed", "additions": 21, "deletions": 15, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbug%2Fbug.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbug%2Fbug.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbug%2Fbug.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -2,7 +2,8 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-package main\n+// Package bug implements the ``go bug'' command.\n+package bug\n \n import (\n \t\"bytes\"\n@@ -15,9 +16,14 @@ import (\n \t\"regexp\"\n \t\"runtime\"\n \t\"strings\"\n+\n+\t\"cmd/go/internal/base\"\n+\t\"cmd/go/internal/cfg\"\n+\t\"cmd/go/internal/envcmd\"\n+\t\"cmd/go/internal/web\"\n )\n \n-var cmdBug = &Command{\n+var CmdBug = &base.Command{\n \tRun:       runBug,\n \tUsageLine: \"bug\",\n \tShort:     \"start a bug report\",\n@@ -28,23 +34,23 @@ The report includes useful system information.\n }\n \n func init() {\n-\tcmdBug.Flag.BoolVar(&buildV, \"v\", false, \"\")\n+\tCmdBug.Flag.BoolVar(&cfg.BuildV, \"v\", false, \"\")\n }\n \n-func runBug(cmd *Command, args []string) {\n+func runBug(cmd *base.Command, args []string) {\n \tvar buf bytes.Buffer\n \tbuf.WriteString(bugHeader)\n \tinspectGoVersion(&buf)\n \tfmt.Fprint(&buf, \"#### System details\\n\\n\")\n \tfmt.Fprintln(&buf, \"```\")\n \tfmt.Fprintf(&buf, \"go version %s %s/%s\\n\", runtime.Version(), runtime.GOOS, runtime.GOARCH)\n-\tenv := newEnv\n-\tenv = append(env, extraEnvVars()...)\n+\tenv := cfg.CmdEnv\n+\tenv = append(env, envcmd.ExtraEnvVars()...)\n \tfor _, e := range env {\n \t\t// Hide the TERM environment variable from \"go bug\".\n \t\t// See issue #18128\n-\t\tif e.name != \"TERM\" {\n-\t\t\tfmt.Fprintf(&buf, \"%s=\\\"%s\\\"\\n\", e.name, e.value)\n+\t\tif e.Name != \"TERM\" {\n+\t\t\tfmt.Fprintf(&buf, \"%s=\\\"%s\\\"\\n\", e.Name, e.Value)\n \t\t}\n \t}\n \tprintGoDetails(&buf)\n@@ -53,8 +59,8 @@ func runBug(cmd *Command, args []string) {\n \tfmt.Fprintln(&buf, \"```\")\n \n \tbody := buf.String()\n-\turl := \"https://github.com/golang/go/issues/new?body=\" + queryEscape(body)\n-\tif !openBrowser(url) {\n+\turl := \"https://github.com/golang/go/issues/new?body=\" + web.QueryEscape(body)\n+\tif !web.OpenBrowser(url) {\n \t\tfmt.Print(\"Please file a new issue at golang.org/issue/new using this template:\\n\\n\")\n \t\tfmt.Print(body)\n \t}\n@@ -97,7 +103,7 @@ func printOSDetails(w io.Writer) {\n \t\tif err == nil {\n \t\t\tfmt.Fprintf(w, \"/etc/release: %s\\n\", out)\n \t\t} else {\n-\t\t\tif buildV {\n+\t\t\tif cfg.BuildV {\n \t\t\t\tfmt.Printf(\"failed to read /etc/release: %v\\n\", err)\n \t\t\t}\n \t\t}\n@@ -114,16 +120,16 @@ func printCDetails(w io.Writer) {\n \t\t// Print up to the first newline.\n \t\tfmt.Fprintf(w, \"gdb --version: %s\\n\", firstLine(out))\n \t} else {\n-\t\tif buildV {\n+\t\tif cfg.BuildV {\n \t\t\tfmt.Printf(\"failed to run gdb --version: %v\\n\", err)\n \t\t}\n \t}\n }\n \n func inspectGoVersion(w io.Writer) {\n-\tdata, err := httpGET(\"https://golang.org/VERSION?m=text\")\n+\tdata, err := web.Get(\"https://golang.org/VERSION?m=text\")\n \tif err != nil {\n-\t\tif buildV {\n+\t\tif cfg.BuildV {\n \t\t\tfmt.Printf(\"failed to read from golang.org/VERSION: %v\\n\", err)\n \t\t}\n \t\treturn\n@@ -150,7 +156,7 @@ func printCmdOut(w io.Writer, prefix, path string, args ...string) {\n \tcmd := exec.Command(path, args...)\n \tout, err := cmd.Output()\n \tif err != nil {\n-\t\tif buildV {\n+\t\tif cfg.BuildV {\n \t\t\tfmt.Printf(\"%s %s: %v\\n\", path, strings.Join(args, \" \"), err)\n \t\t}\n \t\treturn", "previous_filename": "libgo/go/cmd/go/bug.go"}, {"sha": "091c9090c86bb0caa81ab8111de99a6538ee14e3", "filename": "libgo/go/cmd/go/internal/buildid/buildid.go", "status": "added", "additions": 201, "deletions": 0, "changes": 201, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbuildid%2Fbuildid.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbuildid%2Fbuildid.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbuildid%2Fbuildid.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -0,0 +1,201 @@\n+// Copyright 2017 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package buildid\n+\n+import (\n+\t\"bytes\"\n+\t\"cmd/go/internal/cfg\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"os\"\n+\t\"strconv\"\n+\t\"strings\"\n+)\n+\n+var (\n+\terrBuildIDToolchain = fmt.Errorf(\"build ID only supported in gc toolchain\")\n+\terrBuildIDMalformed = fmt.Errorf(\"malformed object file\")\n+\terrBuildIDUnknown   = fmt.Errorf(\"lost build ID\")\n+)\n+\n+var (\n+\tbangArch = []byte(\"!<arch>\")\n+\tpkgdef   = []byte(\"__.PKGDEF\")\n+\tgoobject = []byte(\"go object \")\n+\tbuildid  = []byte(\"build id \")\n+)\n+\n+// ReadBuildID reads the build ID from an archive or binary.\n+// It only supports the gc toolchain.\n+// Other toolchain maintainers should adjust this function.\n+func ReadBuildID(name, target string) (id string, err error) {\n+\tif cfg.BuildToolchainName != \"gc\" {\n+\t\treturn \"\", errBuildIDToolchain\n+\t}\n+\n+\t// For commands, read build ID directly from binary.\n+\tif name == \"main\" {\n+\t\treturn ReadBuildIDFromBinary(target)\n+\t}\n+\n+\t// Otherwise, we expect to have an archive (.a) file,\n+\t// and we can read the build ID from the Go export data.\n+\tif !strings.HasSuffix(target, \".a\") {\n+\t\treturn \"\", &os.PathError{Op: \"parse\", Path: target, Err: errBuildIDUnknown}\n+\t}\n+\n+\t// Read just enough of the target to fetch the build ID.\n+\t// The archive is expected to look like:\n+\t//\n+\t//\t!<arch>\n+\t//\t__.PKGDEF       0           0     0     644     7955      `\n+\t//\tgo object darwin amd64 devel X:none\n+\t//\tbuild id \"b41e5c45250e25c9fd5e9f9a1de7857ea0d41224\"\n+\t//\n+\t// The variable-sized strings are GOOS, GOARCH, and the experiment list (X:none).\n+\t// Reading the first 1024 bytes should be plenty.\n+\tf, err := os.Open(target)\n+\tif err != nil {\n+\t\treturn \"\", err\n+\t}\n+\tdata := make([]byte, 1024)\n+\tn, err := io.ReadFull(f, data)\n+\tf.Close()\n+\n+\tif err != nil && n == 0 {\n+\t\treturn \"\", err\n+\t}\n+\n+\tbad := func() (string, error) {\n+\t\treturn \"\", &os.PathError{Op: \"parse\", Path: target, Err: errBuildIDMalformed}\n+\t}\n+\n+\t// Archive header.\n+\tfor i := 0; ; i++ { // returns during i==3\n+\t\tj := bytes.IndexByte(data, '\\n')\n+\t\tif j < 0 {\n+\t\t\treturn bad()\n+\t\t}\n+\t\tline := data[:j]\n+\t\tdata = data[j+1:]\n+\t\tswitch i {\n+\t\tcase 0:\n+\t\t\tif !bytes.Equal(line, bangArch) {\n+\t\t\t\treturn bad()\n+\t\t\t}\n+\t\tcase 1:\n+\t\t\tif !bytes.HasPrefix(line, pkgdef) {\n+\t\t\t\treturn bad()\n+\t\t\t}\n+\t\tcase 2:\n+\t\t\tif !bytes.HasPrefix(line, goobject) {\n+\t\t\t\treturn bad()\n+\t\t\t}\n+\t\tcase 3:\n+\t\t\tif !bytes.HasPrefix(line, buildid) {\n+\t\t\t\t// Found the object header, just doesn't have a build id line.\n+\t\t\t\t// Treat as successful, with empty build id.\n+\t\t\t\treturn \"\", nil\n+\t\t\t}\n+\t\t\tid, err := strconv.Unquote(string(line[len(buildid):]))\n+\t\t\tif err != nil {\n+\t\t\t\treturn bad()\n+\t\t\t}\n+\t\t\treturn id, nil\n+\t\t}\n+\t}\n+}\n+\n+var (\n+\tgoBuildPrefix = []byte(\"\\xff Go build ID: \\\"\")\n+\tgoBuildEnd    = []byte(\"\\\"\\n \\xff\")\n+\n+\telfPrefix = []byte(\"\\x7fELF\")\n+\n+\tmachoPrefixes = [][]byte{\n+\t\t{0xfe, 0xed, 0xfa, 0xce},\n+\t\t{0xfe, 0xed, 0xfa, 0xcf},\n+\t\t{0xce, 0xfa, 0xed, 0xfe},\n+\t\t{0xcf, 0xfa, 0xed, 0xfe},\n+\t}\n+)\n+\n+var BuildIDReadSize = 32 * 1024 // changed for testing\n+\n+// ReadBuildIDFromBinary reads the build ID from a binary.\n+//\n+// ELF binaries store the build ID in a proper PT_NOTE section.\n+//\n+// Other binary formats are not so flexible. For those, the linker\n+// stores the build ID as non-instruction bytes at the very beginning\n+// of the text segment, which should appear near the beginning\n+// of the file. This is clumsy but fairly portable. Custom locations\n+// can be added for other binary types as needed, like we did for ELF.\n+func ReadBuildIDFromBinary(filename string) (id string, err error) {\n+\tif filename == \"\" {\n+\t\treturn \"\", &os.PathError{Op: \"parse\", Path: filename, Err: errBuildIDUnknown}\n+\t}\n+\n+\t// Read the first 32 kB of the binary file.\n+\t// That should be enough to find the build ID.\n+\t// In ELF files, the build ID is in the leading headers,\n+\t// which are typically less than 4 kB, not to mention 32 kB.\n+\t// In Mach-O files, there's no limit, so we have to parse the file.\n+\t// On other systems, we're trying to read enough that\n+\t// we get the beginning of the text segment in the read.\n+\t// The offset where the text segment begins in a hello\n+\t// world compiled for each different object format today:\n+\t//\n+\t//\tPlan 9: 0x20\n+\t//\tWindows: 0x600\n+\t//\n+\tf, err := os.Open(filename)\n+\tif err != nil {\n+\t\treturn \"\", err\n+\t}\n+\tdefer f.Close()\n+\n+\tdata := make([]byte, BuildIDReadSize)\n+\t_, err = io.ReadFull(f, data)\n+\tif err == io.ErrUnexpectedEOF {\n+\t\terr = nil\n+\t}\n+\tif err != nil {\n+\t\treturn \"\", err\n+\t}\n+\n+\tif bytes.HasPrefix(data, elfPrefix) {\n+\t\treturn readELFGoBuildID(filename, f, data)\n+\t}\n+\tfor _, m := range machoPrefixes {\n+\t\tif bytes.HasPrefix(data, m) {\n+\t\t\treturn readMachoGoBuildID(filename, f, data)\n+\t\t}\n+\t}\n+\n+\treturn readRawGoBuildID(filename, data)\n+}\n+\n+// readRawGoBuildID finds the raw build ID stored in text segment data.\n+func readRawGoBuildID(filename string, data []byte) (id string, err error) {\n+\ti := bytes.Index(data, goBuildPrefix)\n+\tif i < 0 {\n+\t\t// Missing. Treat as successful but build ID empty.\n+\t\treturn \"\", nil\n+\t}\n+\n+\tj := bytes.Index(data[i+len(goBuildPrefix):], goBuildEnd)\n+\tif j < 0 {\n+\t\treturn \"\", &os.PathError{Op: \"parse\", Path: filename, Err: errBuildIDMalformed}\n+\t}\n+\n+\tquoted := data[i+len(goBuildPrefix)-1 : i+len(goBuildPrefix)+j+1]\n+\tid, err = strconv.Unquote(string(quoted))\n+\tif err != nil {\n+\t\treturn \"\", &os.PathError{Op: \"parse\", Path: filename, Err: errBuildIDMalformed}\n+\t}\n+\n+\treturn id, nil\n+}"}, {"sha": "68c91e27047507c546331e151675d0935001cb0c", "filename": "libgo/go/cmd/go/internal/buildid/note.go", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbuildid%2Fnote.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbuildid%2Fnote.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbuildid%2Fnote.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-package main\n+package buildid\n \n import (\n \t\"bytes\"\n@@ -25,7 +25,7 @@ func readAligned4(r io.Reader, sz int32) ([]byte, error) {\n \treturn data, nil\n }\n \n-func readELFNote(filename, name string, typ int32) ([]byte, error) {\n+func ReadELFNote(filename, name string, typ int32) ([]byte, error) {\n \tf, err := elf.Open(filename)\n \tif err != nil {\n \t\treturn nil, err", "previous_filename": "libgo/go/cmd/go/note.go"}, {"sha": "8257a0e511685d7e67355c66965f66e2815bbaa6", "filename": "libgo/go/cmd/go/internal/cfg/cfg.go", "status": "added", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcfg%2Fcfg.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcfg%2Fcfg.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcfg%2Fcfg.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -0,0 +1,134 @@\n+// Copyright 2017 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Package cfg holds configuration shared by multiple parts\n+// of the go command.\n+package cfg\n+\n+import (\n+\t\"fmt\"\n+\t\"go/build\"\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"runtime\"\n+\n+\t\"cmd/internal/objabi\"\n+)\n+\n+// These are general \"build flags\" used by build and other commands.\n+var (\n+\tBuildA                 bool   // -a flag\n+\tBuildBuildmode         string // -buildmode flag\n+\tBuildContext           = build.Default\n+\tBuildI                 bool               // -i flag\n+\tBuildLdflags           []string           // -ldflags flag\n+\tBuildLinkshared        bool               // -linkshared flag\n+\tBuildMSan              bool               // -msan flag\n+\tBuildN                 bool               // -n flag\n+\tBuildO                 string             // -o flag\n+\tBuildP                 = runtime.NumCPU() // -p flag\n+\tBuildPkgdir            string             // -pkgdir flag\n+\tBuildRace              bool               // -race flag\n+\tBuildToolexec          []string           // -toolexec flag\n+\tBuildToolchainName     string\n+\tBuildToolchainCompiler func() string\n+\tBuildToolchainLinker   func() string\n+\tBuildV                 bool // -v flag\n+\tBuildWork              bool // -work flag\n+\tBuildX                 bool // -x flag\n+)\n+\n+func init() {\n+\tBuildToolchainCompiler = func() string { return \"missing-compiler\" }\n+\tBuildToolchainLinker = func() string { return \"missing-linker\" }\n+}\n+\n+// An EnvVar is an environment variable Name=Value.\n+type EnvVar struct {\n+\tName  string\n+\tValue string\n+}\n+\n+// OrigEnv is the original environment of the program at startup.\n+var OrigEnv []string\n+\n+// CmdEnv is the new environment for running go tool commands.\n+// User binaries (during go test or go run) are run with OrigEnv,\n+// not CmdEnv.\n+var CmdEnv []EnvVar\n+\n+// Global build parameters (used during package load)\n+var (\n+\tGoarch    = BuildContext.GOARCH\n+\tGoos      = BuildContext.GOOS\n+\tExeSuffix string\n+\tGopath    = filepath.SplitList(BuildContext.GOPATH)\n+)\n+\n+func init() {\n+\tif Goos == \"windows\" {\n+\t\tExeSuffix = \".exe\"\n+\t}\n+}\n+\n+var (\n+\tGOROOT    = findGOROOT()\n+\tGOBIN     = os.Getenv(\"GOBIN\")\n+\tGOROOTbin = filepath.Join(GOROOT, \"bin\")\n+\tGOROOTpkg = filepath.Join(GOROOT, \"pkg\")\n+\tGOROOTsrc = filepath.Join(GOROOT, \"src\")\n+\n+\t// Used in envcmd.MkEnv and build ID computations.\n+\tGOARM = fmt.Sprint(objabi.GOARM)\n+\tGO386 = objabi.GO386\n+)\n+\n+// Update build context to use our computed GOROOT.\n+func init() {\n+\tBuildContext.GOROOT = GOROOT\n+\t// Note that we must use runtime.GOOS and runtime.GOARCH here,\n+\t// as the tool directory does not move based on environment variables.\n+\t// This matches the initialization of ToolDir in go/build,\n+\t// except for using GOROOT rather than runtime.GOROOT().\n+\tif runtime.Compiler != \"gccgo\" {\n+\t\tbuild.ToolDir = filepath.Join(GOROOT, \"pkg/tool/\"+runtime.GOOS+\"_\"+runtime.GOARCH)\n+\t}\n+}\n+\n+func findGOROOT() string {\n+\tif env := os.Getenv(\"GOROOT\"); env != \"\" {\n+\t\treturn filepath.Clean(env)\n+\t}\n+\tif runtime.Compiler != \"gccgo\" {\n+\t\texe, err := os.Executable()\n+\t\tif err == nil {\n+\t\t\texe, err = filepath.Abs(exe)\n+\t\t\tif err == nil {\n+\t\t\t\tif dir := filepath.Join(exe, \"../..\"); isGOROOT(dir) {\n+\t\t\t\t\treturn dir\n+\t\t\t\t}\n+\t\t\t\texe, err = filepath.EvalSymlinks(exe)\n+\t\t\t\tif err == nil {\n+\t\t\t\t\tif dir := filepath.Join(exe, \"../..\"); isGOROOT(dir) {\n+\t\t\t\t\t\treturn dir\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\treturn filepath.Clean(runtime.GOROOT())\n+}\n+\n+// isGOROOT reports whether path looks like a GOROOT.\n+//\n+// It does this by looking for the path/pkg/tool directory,\n+// which is necessary for useful operation of the cmd/go tool,\n+// and is not typically present in a GOPATH.\n+func isGOROOT(path string) bool {\n+\tstat, err := os.Stat(filepath.Join(path, \"pkg\", \"tool\"))\n+\tif err != nil {\n+\t\treturn false\n+\t}\n+\treturn stat.IsDir()\n+}"}, {"sha": "454cac1f47b4c592f1049c4fb3f6414de4eed0fd", "filename": "libgo/go/cmd/go/internal/clean/clean.go", "status": "renamed", "additions": 35, "deletions": 29, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fclean%2Fclean.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fclean%2Fclean.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fclean%2Fclean.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -2,17 +2,23 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-package main\n+// Package clean implements the ``go clean'' command.\n+package clean\n \n import (\n \t\"fmt\"\n \t\"io/ioutil\"\n \t\"os\"\n \t\"path/filepath\"\n \t\"strings\"\n+\n+\t\"cmd/go/internal/base\"\n+\t\"cmd/go/internal/cfg\"\n+\t\"cmd/go/internal/load\"\n+\t\"cmd/go/internal/work\"\n )\n \n-var cmdClean = &Command{\n+var CmdClean = &base.Command{\n \tUsageLine: \"clean [-i] [-r] [-n] [-x] [build flags] [packages]\",\n \tShort:     \"remove object files\",\n \tLong: `\n@@ -63,24 +69,24 @@ var cleanR bool // clean -r flag\n \n func init() {\n \t// break init cycle\n-\tcmdClean.Run = runClean\n+\tCmdClean.Run = runClean\n \n-\tcmdClean.Flag.BoolVar(&cleanI, \"i\", false, \"\")\n-\tcmdClean.Flag.BoolVar(&cleanR, \"r\", false, \"\")\n+\tCmdClean.Flag.BoolVar(&cleanI, \"i\", false, \"\")\n+\tCmdClean.Flag.BoolVar(&cleanR, \"r\", false, \"\")\n \t// -n and -x are important enough to be\n \t// mentioned explicitly in the docs but they\n \t// are part of the build flags.\n \n-\taddBuildFlags(cmdClean)\n+\twork.AddBuildFlags(CmdClean)\n }\n \n-func runClean(cmd *Command, args []string) {\n-\tfor _, pkg := range packagesAndErrors(args) {\n+func runClean(cmd *base.Command, args []string) {\n+\tfor _, pkg := range load.PackagesAndErrors(args) {\n \t\tclean(pkg)\n \t}\n }\n \n-var cleaned = map[*Package]bool{}\n+var cleaned = map[*load.Package]bool{}\n \n // TODO: These are dregs left by Makefile-based builds.\n // Eventually, can stop deleting these.\n@@ -105,24 +111,24 @@ var cleanExt = map[string]bool{\n \t\".so\": true,\n }\n \n-func clean(p *Package) {\n+func clean(p *load.Package) {\n \tif cleaned[p] {\n \t\treturn\n \t}\n \tcleaned[p] = true\n \n \tif p.Dir == \"\" {\n-\t\terrorf(\"can't load package: %v\", p.Error)\n+\t\tbase.Errorf(\"can't load package: %v\", p.Error)\n \t\treturn\n \t}\n \tdirs, err := ioutil.ReadDir(p.Dir)\n \tif err != nil {\n-\t\terrorf(\"go clean %s: %v\", p.Dir, err)\n+\t\tbase.Errorf(\"go clean %s: %v\", p.Dir, err)\n \t\treturn\n \t}\n \n-\tvar b builder\n-\tb.print = fmt.Print\n+\tvar b work.Builder\n+\tb.Print = fmt.Print\n \n \tpackageFile := map[string]bool{}\n \tif p.Name != \"main\" {\n@@ -172,8 +178,8 @@ func clean(p *Package) {\n \t\t}\n \t}\n \n-\tif buildN || buildX {\n-\t\tb.showcmd(p.Dir, \"rm -f %s\", strings.Join(allRemove, \" \"))\n+\tif cfg.BuildN || cfg.BuildX {\n+\t\tb.Showcmd(p.Dir, \"rm -f %s\", strings.Join(allRemove, \" \"))\n \t}\n \n \ttoRemove := map[string]bool{}\n@@ -185,20 +191,20 @@ func clean(p *Package) {\n \t\tif dir.IsDir() {\n \t\t\t// TODO: Remove once Makefiles are forgotten.\n \t\t\tif cleanDir[name] {\n-\t\t\t\tif buildN || buildX {\n-\t\t\t\t\tb.showcmd(p.Dir, \"rm -r %s\", name)\n-\t\t\t\t\tif buildN {\n+\t\t\t\tif cfg.BuildN || cfg.BuildX {\n+\t\t\t\t\tb.Showcmd(p.Dir, \"rm -r %s\", name)\n+\t\t\t\t\tif cfg.BuildN {\n \t\t\t\t\t\tcontinue\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tif err := os.RemoveAll(filepath.Join(p.Dir, name)); err != nil {\n-\t\t\t\t\terrorf(\"go clean: %v\", err)\n+\t\t\t\t\tbase.Errorf(\"go clean: %v\", err)\n \t\t\t\t}\n \t\t\t}\n \t\t\tcontinue\n \t\t}\n \n-\t\tif buildN {\n+\t\tif cfg.BuildN {\n \t\t\tcontinue\n \t\t}\n \n@@ -207,17 +213,17 @@ func clean(p *Package) {\n \t\t}\n \t}\n \n-\tif cleanI && p.target != \"\" {\n-\t\tif buildN || buildX {\n-\t\t\tb.showcmd(\"\", \"rm -f %s\", p.target)\n+\tif cleanI && p.Internal.Target != \"\" {\n+\t\tif cfg.BuildN || cfg.BuildX {\n+\t\t\tb.Showcmd(\"\", \"rm -f %s\", p.Internal.Target)\n \t\t}\n-\t\tif !buildN {\n-\t\t\tremoveFile(p.target)\n+\t\tif !cfg.BuildN {\n+\t\t\tremoveFile(p.Internal.Target)\n \t\t}\n \t}\n \n \tif cleanR {\n-\t\tfor _, p1 := range p.imports {\n+\t\tfor _, p1 := range p.Internal.Imports {\n \t\t\tclean(p1)\n \t\t}\n \t}\n@@ -231,7 +237,7 @@ func removeFile(f string) {\n \t\treturn\n \t}\n \t// Windows does not allow deletion of a binary file while it is executing.\n-\tif toolIsWindows {\n+\tif base.ToolIsWindows {\n \t\t// Remove lingering ~ file from last attempt.\n \t\tif _, err2 := os.Stat(f + \"~\"); err2 == nil {\n \t\t\tos.Remove(f + \"~\")\n@@ -244,5 +250,5 @@ func removeFile(f string) {\n \t\t\treturn\n \t\t}\n \t}\n-\terrorf(\"go clean: %v\", err)\n+\tbase.Errorf(\"go clean: %v\", err)\n }", "previous_filename": "libgo/go/cmd/go/clean.go"}, {"sha": "7ab30221279f2a44474c5884d12ec1b1acb20f2e", "filename": "libgo/go/cmd/go/internal/cmdflag/flag.go", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcmdflag%2Fflag.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcmdflag%2Fflag.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcmdflag%2Fflag.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -0,0 +1,123 @@\n+// Copyright 2017 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Package cmdflag handles flag processing common to several go tools.\n+package cmdflag\n+\n+import (\n+\t\"flag\"\n+\t\"fmt\"\n+\t\"os\"\n+\t\"strconv\"\n+\t\"strings\"\n+\n+\t\"cmd/go/internal/base\"\n+)\n+\n+// The flag handling part of go commands such as test is large and distracting.\n+// We can't use the standard flag package because some of the flags from\n+// our command line are for us, and some are for the binary we're running,\n+// and some are for both.\n+\n+// Defn defines a flag we know about.\n+type Defn struct {\n+\tName       string     // Name on command line.\n+\tBoolVar    *bool      // If it's a boolean flag, this points to it.\n+\tValue      flag.Value // The flag.Value represented.\n+\tPassToTest bool       // Pass to the test binary? Used only by go test.\n+\tPresent    bool       // Flag has been seen.\n+}\n+\n+// IsBool reports whether v is a bool flag.\n+func IsBool(v flag.Value) bool {\n+\tvv, ok := v.(interface {\n+\t\tIsBoolFlag() bool\n+\t})\n+\tif ok {\n+\t\treturn vv.IsBoolFlag()\n+\t}\n+\treturn false\n+}\n+\n+// SetBool sets the addressed boolean to the value.\n+func SetBool(cmd string, flag *bool, value string) {\n+\tx, err := strconv.ParseBool(value)\n+\tif err != nil {\n+\t\tSyntaxError(cmd, \"illegal bool flag value \"+value)\n+\t}\n+\t*flag = x\n+}\n+\n+// SetInt sets the addressed integer to the value.\n+func SetInt(cmd string, flag *int, value string) {\n+\tx, err := strconv.Atoi(value)\n+\tif err != nil {\n+\t\tSyntaxError(cmd, \"illegal int flag value \"+value)\n+\t}\n+\t*flag = x\n+}\n+\n+// SyntaxError reports an argument syntax error and exits the program.\n+func SyntaxError(cmd, msg string) {\n+\tfmt.Fprintf(os.Stderr, \"go %s: %s\\n\", cmd, msg)\n+\tif cmd == \"test\" {\n+\t\tfmt.Fprintf(os.Stderr, `run \"go help %s\" or \"go help testflag\" for more information`+\"\\n\", cmd)\n+\t} else {\n+\t\tfmt.Fprintf(os.Stderr, `run \"go help %s\" for more information`+\"\\n\", cmd)\n+\t}\n+\tos.Exit(2)\n+}\n+\n+// Parse sees if argument i is present in the definitions and if so,\n+// returns its definition, value, and whether it consumed an extra word.\n+// If the flag begins (cmd+\".\") it is ignored for the purpose of this function.\n+func Parse(cmd string, defns []*Defn, args []string, i int) (f *Defn, value string, extra bool) {\n+\targ := args[i]\n+\tif strings.HasPrefix(arg, \"--\") { // reduce two minuses to one\n+\t\targ = arg[1:]\n+\t}\n+\tswitch arg {\n+\tcase \"-?\", \"-h\", \"-help\":\n+\t\tbase.Usage()\n+\t}\n+\tif arg == \"\" || arg[0] != '-' {\n+\t\treturn\n+\t}\n+\tname := arg[1:]\n+\t// If there's already a prefix such as \"test.\", drop it for now.\n+\tname = strings.TrimPrefix(name, cmd+\".\")\n+\tequals := strings.Index(name, \"=\")\n+\tif equals >= 0 {\n+\t\tvalue = name[equals+1:]\n+\t\tname = name[:equals]\n+\t}\n+\tfor _, f = range defns {\n+\t\tif name == f.Name {\n+\t\t\t// Booleans are special because they have modes -x, -x=true, -x=false.\n+\t\t\tif f.BoolVar != nil || IsBool(f.Value) {\n+\t\t\t\tif equals < 0 { // Otherwise, it's been set and will be verified in SetBool.\n+\t\t\t\t\tvalue = \"true\"\n+\t\t\t\t} else {\n+\t\t\t\t\t// verify it parses\n+\t\t\t\t\tSetBool(cmd, new(bool), value)\n+\t\t\t\t}\n+\t\t\t} else { // Non-booleans must have a value.\n+\t\t\t\textra = equals < 0\n+\t\t\t\tif extra {\n+\t\t\t\t\tif i+1 >= len(args) {\n+\t\t\t\t\t\tSyntaxError(cmd, \"missing argument for flag \"+f.Name)\n+\t\t\t\t\t}\n+\t\t\t\t\tvalue = args[i+1]\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif f.Present {\n+\t\t\t\tSyntaxError(cmd, f.Name+\" flag may be set only once\")\n+\t\t\t}\n+\t\t\tf.Present = true\n+\t\t\treturn\n+\t\t}\n+\t}\n+\tf = nil\n+\treturn\n+}"}, {"sha": "d73dd9ad914d37bd2a83e8bc40d5efeb4d7f6201", "filename": "libgo/go/cmd/go/internal/doc/doc.go", "status": "renamed", "additions": 22, "deletions": 17, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fdoc%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fdoc%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fdoc%2Fdoc.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -2,20 +2,25 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-//go:generate ./mkalldocs.sh\n+// Package doc implements the ``go doc'' command.\n+package doc\n \n-package main\n+import (\n+\t\"cmd/go/internal/base\"\n+\t\"cmd/go/internal/cfg\"\n+)\n \n-var cmdDoc = &Command{\n+var CmdDoc = &base.Command{\n \tRun:         runDoc,\n-\tUsageLine:   \"doc [-u] [-c] [package|[package.]symbol[.method]]\",\n+\tUsageLine:   \"doc [-u] [-c] [package|[package.]symbol[.methodOrField]]\",\n \tCustomFlags: true,\n \tShort:       \"show documentation for package or symbol\",\n \tLong: `\n Doc prints the documentation comments associated with the item identified by its\n-arguments (a package, const, func, type, var, or method) followed by a one-line\n-summary of each of the first-level items \"under\" that item (package-level\n-declarations for a package, methods for a type, etc.).\n+arguments (a package, const, func, type, var, method, or struct field)\n+followed by a one-line summary of each of the first-level items \"under\"\n+that item (package-level declarations for a package, methods for a type,\n+etc.).\n \n Doc accepts zero, one, or two arguments.\n \n@@ -33,17 +38,17 @@ on what is installed in GOROOT and GOPATH, as well as the form of the argument,\n which is schematically one of these:\n \n \tgo doc <pkg>\n-\tgo doc <sym>[.<method>]\n-\tgo doc [<pkg>.]<sym>[.<method>]\n-\tgo doc [<pkg>.][<sym>.]<method>\n+\tgo doc <sym>[.<methodOrField>]\n+\tgo doc [<pkg>.]<sym>[.<methodOrField>]\n+\tgo doc [<pkg>.][<sym>.]<methodOrField>\n \n The first item in this list matched by the argument is the one whose documentation\n is printed. (See the examples below.) However, if the argument starts with a capital\n letter it is assumed to identify a symbol or method in the current directory.\n \n For packages, the order of scanning is determined lexically in breadth-first order.\n That is, the package presented is the one that matches the search and is nearest\n-the root and lexically first at its level of the hierarchy.  The GOROOT tree is\n+the root and lexically first at its level of the hierarchy. The GOROOT tree is\n always scanned in its entirety before GOPATH.\n \n If there is no package specified or matched, the package in the current\n@@ -55,10 +60,10 @@ path. The go tool's usual package mechanism does not apply: package path\n elements like . and ... are not implemented by go doc.\n \n When run with two arguments, the first must be a full package path (not just a\n-suffix), and the second is a symbol or symbol and method; this is similar to the\n-syntax accepted by godoc:\n+suffix), and the second is a symbol, or symbol with method or struct field.\n+This is similar to the syntax accepted by godoc:\n \n-\tgo doc <pkg> <sym>[.<method>]\n+\tgo doc <pkg> <sym>[.<methodOrField>]\n \n In all forms, when matching symbols, lower-case letters in the argument match\n either case but upper-case letters match exactly. This means that there may be\n@@ -109,10 +114,10 @@ Flags:\n \t\twhen showing the package's top-level documentation.\n \t-u\n \t\tShow documentation for unexported as well as exported\n-\t\tsymbols and methods.\n+\t\tsymbols, methods, and fields.\n `,\n }\n \n-func runDoc(cmd *Command, args []string) {\n-\trun(buildToolExec, tool(\"doc\"), args)\n+func runDoc(cmd *base.Command, args []string) {\n+\tbase.Run(cfg.BuildToolexec, base.Tool(\"doc\"), args)\n }", "previous_filename": "libgo/go/cmd/go/doc.go"}, {"sha": "43d4334f0603d640cfcdf319b6052891740f804a", "filename": "libgo/go/cmd/go/internal/envcmd/env.go", "status": "added", "additions": 178, "deletions": 0, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fenvcmd%2Fenv.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fenvcmd%2Fenv.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fenvcmd%2Fenv.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -0,0 +1,178 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Package envcmd implements the ``go env'' command.\n+package envcmd\n+\n+import (\n+\t\"encoding/json\"\n+\t\"fmt\"\n+\t\"os\"\n+\t\"runtime\"\n+\t\"strings\"\n+\n+\t\"cmd/go/internal/base\"\n+\t\"cmd/go/internal/cfg\"\n+\t\"cmd/go/internal/load\"\n+\t\"cmd/go/internal/work\"\n+)\n+\n+var CmdEnv = &base.Command{\n+\tUsageLine: \"env [-json] [var ...]\",\n+\tShort:     \"print Go environment information\",\n+\tLong: `\n+Env prints Go environment information.\n+\n+By default env prints information as a shell script\n+(on Windows, a batch file). If one or more variable\n+names is given as arguments, env prints the value of\n+each named variable on its own line.\n+\n+The -json flag prints the environment in JSON format\n+instead of as a shell script.\n+\t`,\n+}\n+\n+func init() {\n+\tCmdEnv.Run = runEnv // break init cycle\n+}\n+\n+var envJson = CmdEnv.Flag.Bool(\"json\", false, \"\")\n+\n+func MkEnv() []cfg.EnvVar {\n+\tvar b work.Builder\n+\tb.Init()\n+\n+\tenv := []cfg.EnvVar{\n+\t\t{Name: \"GOARCH\", Value: cfg.Goarch},\n+\t\t{Name: \"GOBIN\", Value: cfg.GOBIN},\n+\t\t{Name: \"GOEXE\", Value: cfg.ExeSuffix},\n+\t\t{Name: \"GOHOSTARCH\", Value: runtime.GOARCH},\n+\t\t{Name: \"GOHOSTOS\", Value: runtime.GOOS},\n+\t\t{Name: \"GOOS\", Value: cfg.Goos},\n+\t\t{Name: \"GOPATH\", Value: cfg.BuildContext.GOPATH},\n+\t\t{Name: \"GORACE\", Value: os.Getenv(\"GORACE\")},\n+\t\t{Name: \"GOROOT\", Value: cfg.GOROOT},\n+\t\t{Name: \"GOTOOLDIR\", Value: base.ToolDir},\n+\n+\t\t// disable escape codes in clang errors\n+\t\t{Name: \"TERM\", Value: \"dumb\"},\n+\t}\n+\n+\tif work.GccgoBin != \"\" {\n+\t\tenv = append(env, cfg.EnvVar{Name: \"GCCGO\", Value: work.GccgoBin})\n+\t} else {\n+\t\tenv = append(env, cfg.EnvVar{Name: \"GCCGO\", Value: work.GccgoName})\n+\t}\n+\n+\tswitch cfg.Goarch {\n+\tcase \"arm\":\n+\t\tenv = append(env, cfg.EnvVar{Name: \"GOARM\", Value: cfg.GOARM})\n+\tcase \"386\":\n+\t\tenv = append(env, cfg.EnvVar{Name: \"GO386\", Value: cfg.GO386})\n+\t}\n+\n+\tcmd := b.GccCmd(\".\")\n+\tenv = append(env, cfg.EnvVar{Name: \"CC\", Value: cmd[0]})\n+\tenv = append(env, cfg.EnvVar{Name: \"GOGCCFLAGS\", Value: strings.Join(cmd[3:], \" \")})\n+\tcmd = b.GxxCmd(\".\")\n+\tenv = append(env, cfg.EnvVar{Name: \"CXX\", Value: cmd[0]})\n+\n+\tif cfg.BuildContext.CgoEnabled {\n+\t\tenv = append(env, cfg.EnvVar{Name: \"CGO_ENABLED\", Value: \"1\"})\n+\t} else {\n+\t\tenv = append(env, cfg.EnvVar{Name: \"CGO_ENABLED\", Value: \"0\"})\n+\t}\n+\n+\treturn env\n+}\n+\n+func findEnv(env []cfg.EnvVar, name string) string {\n+\tfor _, e := range env {\n+\t\tif e.Name == name {\n+\t\t\treturn e.Value\n+\t\t}\n+\t}\n+\treturn \"\"\n+}\n+\n+// ExtraEnvVars returns environment variables that should not leak into child processes.\n+func ExtraEnvVars() []cfg.EnvVar {\n+\tvar b work.Builder\n+\tb.Init()\n+\tcppflags, cflags, cxxflags, fflags, ldflags := b.CFlags(&load.Package{})\n+\treturn []cfg.EnvVar{\n+\t\t{Name: \"CGO_CFLAGS\", Value: strings.Join(cflags, \" \")},\n+\t\t{Name: \"CGO_CPPFLAGS\", Value: strings.Join(cppflags, \" \")},\n+\t\t{Name: \"CGO_CXXFLAGS\", Value: strings.Join(cxxflags, \" \")},\n+\t\t{Name: \"CGO_FFLAGS\", Value: strings.Join(fflags, \" \")},\n+\t\t{Name: \"CGO_LDFLAGS\", Value: strings.Join(ldflags, \" \")},\n+\t\t{Name: \"PKG_CONFIG\", Value: b.PkgconfigCmd()},\n+\t}\n+}\n+\n+func runEnv(cmd *base.Command, args []string) {\n+\tenv := cfg.CmdEnv\n+\tenv = append(env, ExtraEnvVars()...)\n+\tif len(args) > 0 {\n+\t\tif *envJson {\n+\t\t\tvar es []cfg.EnvVar\n+\t\t\tfor _, name := range args {\n+\t\t\t\te := cfg.EnvVar{Name: name, Value: findEnv(env, name)}\n+\t\t\t\tes = append(es, e)\n+\t\t\t}\n+\t\t\tprintEnvAsJSON(es)\n+\t\t} else {\n+\t\t\tfor _, name := range args {\n+\t\t\t\tfmt.Printf(\"%s\\n\", findEnv(env, name))\n+\t\t\t}\n+\t\t}\n+\t\treturn\n+\t}\n+\n+\tif *envJson {\n+\t\tprintEnvAsJSON(env)\n+\t\treturn\n+\t}\n+\n+\tfor _, e := range env {\n+\t\tif e.Name != \"TERM\" {\n+\t\t\tswitch runtime.GOOS {\n+\t\t\tdefault:\n+\t\t\t\tfmt.Printf(\"%s=\\\"%s\\\"\\n\", e.Name, e.Value)\n+\t\t\tcase \"plan9\":\n+\t\t\t\tif strings.IndexByte(e.Value, '\\x00') < 0 {\n+\t\t\t\t\tfmt.Printf(\"%s='%s'\\n\", e.Name, strings.Replace(e.Value, \"'\", \"''\", -1))\n+\t\t\t\t} else {\n+\t\t\t\t\tv := strings.Split(e.Value, \"\\x00\")\n+\t\t\t\t\tfmt.Printf(\"%s=(\", e.Name)\n+\t\t\t\t\tfor x, s := range v {\n+\t\t\t\t\t\tif x > 0 {\n+\t\t\t\t\t\t\tfmt.Printf(\" \")\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tfmt.Printf(\"%s\", s)\n+\t\t\t\t\t}\n+\t\t\t\t\tfmt.Printf(\")\\n\")\n+\t\t\t\t}\n+\t\t\tcase \"windows\":\n+\t\t\t\tfmt.Printf(\"set %s=%s\\n\", e.Name, e.Value)\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+func printEnvAsJSON(env []cfg.EnvVar) {\n+\tm := make(map[string]string)\n+\tfor _, e := range env {\n+\t\tif e.Name == \"TERM\" {\n+\t\t\tcontinue\n+\t\t}\n+\t\tm[e.Name] = e.Value\n+\t}\n+\tenc := json.NewEncoder(os.Stdout)\n+\tenc.SetIndent(\"\", \"\\t\")\n+\tif err := enc.Encode(m); err != nil {\n+\t\tbase.Fatalf(\"%s\", err)\n+\t}\n+}"}, {"sha": "788d49bcb6070c09a398458af35b1acfd078a704", "filename": "libgo/go/cmd/go/internal/fix/fix.go", "status": "renamed", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ffix%2Ffix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ffix%2Ffix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ffix%2Ffix.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -2,9 +2,17 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-package main\n+// Package fix implements the ``go fix'' command.\n+package fix\n \n-var cmdFix = &Command{\n+import (\n+\t\"cmd/go/internal/base\"\n+\t\"cmd/go/internal/cfg\"\n+\t\"cmd/go/internal/load\"\n+\t\"cmd/go/internal/str\"\n+)\n+\n+var CmdFix = &base.Command{\n \tRun:       runFix,\n \tUsageLine: \"fix [packages]\",\n \tShort:     \"run go tool fix on packages\",\n@@ -20,11 +28,12 @@ See also: go fmt, go vet.\n \t`,\n }\n \n-func runFix(cmd *Command, args []string) {\n-\tfor _, pkg := range packages(args) {\n+func runFix(cmd *base.Command, args []string) {\n+\tfor _, pkg := range load.Packages(args) {\n \t\t// Use pkg.gofiles instead of pkg.Dir so that\n \t\t// the command only applies to this package,\n \t\t// not to packages in subdirectories.\n-\t\trun(stringList(buildToolExec, tool(\"fix\"), relPaths(pkg.allgofiles)))\n+\t\tfiles := base.FilterDotUnderscoreFiles(base.RelPaths(pkg.Internal.AllGoFiles))\n+\t\tbase.Run(str.StringList(cfg.BuildToolexec, base.Tool(\"fix\"), files))\n \t}\n }", "previous_filename": "libgo/go/cmd/go/fix.go"}, {"sha": "0563a0410b377faeade56963b1afa3a8bd88ae2b", "filename": "libgo/go/cmd/go/internal/fmtcmd/fmt.go", "status": "renamed", "additions": 18, "deletions": 11, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ffmtcmd%2Ffmt.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ffmtcmd%2Ffmt.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ffmtcmd%2Ffmt.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -2,24 +2,30 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-package main\n+// Package fmtcmd implements the ``go fmt'' command.\n+package fmtcmd\n \n import (\n \t\"os\"\n \t\"path/filepath\"\n+\n+\t\"cmd/go/internal/base\"\n+\t\"cmd/go/internal/cfg\"\n+\t\"cmd/go/internal/load\"\n+\t\"cmd/go/internal/str\"\n )\n \n func init() {\n-\taddBuildFlagsNX(cmdFmt)\n+\tbase.AddBuildFlagsNX(&CmdFmt.Flag)\n }\n \n-var cmdFmt = &Command{\n+var CmdFmt = &base.Command{\n \tRun:       runFmt,\n \tUsageLine: \"fmt [-n] [-x] [packages]\",\n \tShort:     \"run gofmt on package sources\",\n \tLong: `\n Fmt runs the command 'gofmt -l -w' on the packages named\n-by the import paths.  It prints the names of the files that are modified.\n+by the import paths. It prints the names of the files that are modified.\n \n For more about gofmt, see 'go doc cmd/gofmt'.\n For more about specifying packages, see 'go help packages'.\n@@ -33,28 +39,29 @@ See also: go fix, go vet.\n \t`,\n }\n \n-func runFmt(cmd *Command, args []string) {\n+func runFmt(cmd *base.Command, args []string) {\n \tgofmt := gofmtPath()\n-\tfor _, pkg := range packages(args) {\n+\tfor _, pkg := range load.Packages(args) {\n \t\t// Use pkg.gofiles instead of pkg.Dir so that\n \t\t// the command only applies to this package,\n \t\t// not to packages in subdirectories.\n-\t\trun(stringList(gofmt, \"-l\", \"-w\", relPaths(pkg.allgofiles)))\n+\t\tfiles := base.FilterDotUnderscoreFiles(base.RelPaths(pkg.Internal.AllGoFiles))\n+\t\tbase.Run(str.StringList(gofmt, \"-l\", \"-w\", files))\n \t}\n }\n \n func gofmtPath() string {\n \tgofmt := \"gofmt\"\n-\tif toolIsWindows {\n-\t\tgofmt += toolWindowsExtension\n+\tif base.ToolIsWindows {\n+\t\tgofmt += base.ToolWindowsExtension\n \t}\n \n-\tgofmtPath := filepath.Join(gobin, gofmt)\n+\tgofmtPath := filepath.Join(cfg.GOBIN, gofmt)\n \tif _, err := os.Stat(gofmtPath); err == nil {\n \t\treturn gofmtPath\n \t}\n \n-\tgofmtPath = filepath.Join(goroot, \"bin\", gofmt)\n+\tgofmtPath = filepath.Join(cfg.GOROOT, \"bin\", gofmt)\n \tif _, err := os.Stat(gofmtPath); err == nil {\n \t\treturn gofmtPath\n \t}", "previous_filename": "libgo/go/cmd/go/fmt.go"}, {"sha": "d47c9b73236b85ac93732ae2408b76e987751912", "filename": "libgo/go/cmd/go/internal/generate/generate.go", "status": "renamed", "additions": 25, "deletions": 19, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fgenerate%2Fgenerate.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fgenerate%2Fgenerate.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fgenerate%2Fgenerate.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -2,7 +2,8 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-package main\n+// Package generate implements the ``go generate'' command.\n+package generate\n \n import (\n \t\"bufio\"\n@@ -16,9 +17,14 @@ import (\n \t\"regexp\"\n \t\"strconv\"\n \t\"strings\"\n+\n+\t\"cmd/go/internal/base\"\n+\t\"cmd/go/internal/cfg\"\n+\t\"cmd/go/internal/load\"\n+\t\"cmd/go/internal/work\"\n )\n \n-var cmdGenerate = &Command{\n+var CmdGenerate = &base.Command{\n \tRun:       runGenerate,\n \tUsageLine: \"generate [-run regexp] [-n] [-v] [-x] [build flags] [file.go... | packages]\",\n \tShort:     \"generate Go files by processing source\",\n@@ -74,7 +80,7 @@ line.\n As a last step before running the command, any invocations of any\n environment variables with alphanumeric names, such as $GOFILE or\n $HOME, are expanded throughout the command line. The syntax for\n-variable expansion is $NAME on all operating systems.  Due to the\n+variable expansion is $NAME on all operating systems. Due to the\n order of evaluation, variables are expanded even inside quoted\n strings. If the variable NAME is not set, $NAME expands to the\n empty string.\n@@ -131,12 +137,12 @@ var (\n )\n \n func init() {\n-\taddBuildFlags(cmdGenerate)\n-\tcmdGenerate.Flag.StringVar(&generateRunFlag, \"run\", \"\", \"\")\n+\twork.AddBuildFlags(CmdGenerate)\n+\tCmdGenerate.Flag.StringVar(&generateRunFlag, \"run\", \"\", \"\")\n }\n \n-func runGenerate(cmd *Command, args []string) {\n-\tignoreImports = true\n+func runGenerate(cmd *base.Command, args []string) {\n+\tload.IgnoreImports = true\n \n \tif generateRunFlag != \"\" {\n \t\tvar err error\n@@ -146,8 +152,8 @@ func runGenerate(cmd *Command, args []string) {\n \t\t}\n \t}\n \t// Even if the arguments are .go files, this loop suffices.\n-\tfor _, pkg := range packages(args) {\n-\t\tfor _, file := range pkg.gofiles {\n+\tfor _, pkg := range load.Packages(args) {\n+\t\tfor _, file := range pkg.Internal.GoFiles {\n \t\t\tif !generate(pkg.Name, file) {\n \t\t\t\tbreak\n \t\t\t}\n@@ -195,13 +201,13 @@ func (g *Generator) run() (ok bool) {\n \t\t\tif e != stop {\n \t\t\t\tpanic(e)\n \t\t\t}\n-\t\t\tsetExitStatus(1)\n+\t\t\tbase.SetExitStatus(1)\n \t\t}\n \t}()\n \tg.dir, g.file = filepath.Split(g.path)\n \tg.dir = filepath.Clean(g.dir) // No final separator please.\n-\tif buildV {\n-\t\tfmt.Fprintf(os.Stderr, \"%s\\n\", shortPath(g.path))\n+\tif cfg.BuildV {\n+\t\tfmt.Fprintf(os.Stderr, \"%s\\n\", base.ShortPath(g.path))\n \t}\n \n \t// Scan for lines that start \"//go:generate\".\n@@ -255,16 +261,16 @@ func (g *Generator) run() (ok bool) {\n \t\t\tcontinue\n \t\t}\n \t\t// Run the command line.\n-\t\tif buildN || buildX {\n+\t\tif cfg.BuildN || cfg.BuildX {\n \t\t\tfmt.Fprintf(os.Stderr, \"%s\\n\", strings.Join(words, \" \"))\n \t\t}\n-\t\tif buildN {\n+\t\tif cfg.BuildN {\n \t\t\tcontinue\n \t\t}\n \t\tg.exec(words)\n \t}\n \tif err != nil && err != io.EOF {\n-\t\tg.errorf(\"error reading %s: %s\", shortPath(g.path), err)\n+\t\tg.errorf(\"error reading %s: %s\", base.ShortPath(g.path), err)\n \t}\n \treturn true\n }\n@@ -277,8 +283,8 @@ func isGoGenerate(buf []byte) bool {\n // single go:generate command.\n func (g *Generator) setEnv() {\n \tg.env = []string{\n-\t\t\"GOARCH=\" + buildContext.GOARCH,\n-\t\t\"GOOS=\" + buildContext.GOOS,\n+\t\t\"GOARCH=\" + cfg.BuildContext.GOARCH,\n+\t\t\"GOOS=\" + cfg.BuildContext.GOOS,\n \t\t\"GOFILE=\" + g.file,\n \t\t\"GOLINE=\" + strconv.Itoa(g.lineNum),\n \t\t\"GOPACKAGE=\" + g.pkg,\n@@ -354,7 +360,7 @@ var stop = fmt.Errorf(\"error in generation\")\n // It then exits the program (with exit status 1) because generation stops\n // at the first error.\n func (g *Generator) errorf(format string, args ...interface{}) {\n-\tfmt.Fprintf(os.Stderr, \"%s:%d: %s\\n\", shortPath(g.path), g.lineNum,\n+\tfmt.Fprintf(os.Stderr, \"%s:%d: %s\\n\", base.ShortPath(g.path), g.lineNum,\n \t\tfmt.Sprintf(format, args...))\n \tpanic(stop)\n }\n@@ -393,7 +399,7 @@ func (g *Generator) exec(words []string) {\n \tcmd.Stderr = os.Stderr\n \t// Run the command in the package directory.\n \tcmd.Dir = g.dir\n-\tcmd.Env = mergeEnvLists(g.env, origEnv)\n+\tcmd.Env = base.MergeEnvLists(g.env, cfg.OrigEnv)\n \terr := cmd.Run()\n \tif err != nil {\n \t\tg.errorf(\"running %q: %s\", words[0], err)", "previous_filename": "libgo/go/cmd/go/generate.go"}, {"sha": "defc15387f39a30b6111e4482cb8ab1f746883bb", "filename": "libgo/go/cmd/go/internal/generate/generate_test.go", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fgenerate%2Fgenerate_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fgenerate%2Fgenerate_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fgenerate%2Fgenerate_test.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-package main\n+package generate\n \n import (\n \t\"reflect\"", "previous_filename": "libgo/go/cmd/go/generate_test.go"}, {"sha": "b2918dbb4f31aaa4488856e68113fee8efecdf2c", "filename": "libgo/go/cmd/go/internal/get/discovery.go", "status": "renamed", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fdiscovery.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fdiscovery.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fdiscovery.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -2,14 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build !cmd_go_bootstrap\n-\n-// This code is compiled into the real 'go' binary, but it is not\n-// compiled into the binary that is built during all.bash, so as\n-// to avoid needing to build net (and thus use cgo) during the\n-// bootstrap process.\n-\n-package main\n+package get\n \n import (\n \t\"encoding/xml\"", "previous_filename": "libgo/go/cmd/go/discovery.go"}, {"sha": "550321198d122a7e8c09c5e9cbe7732b5452c7eb", "filename": "libgo/go/cmd/go/internal/get/get.go", "status": "renamed", "additions": 95, "deletions": 155, "changes": 250, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fget.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fget.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fget.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -2,20 +2,26 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-package main\n+// Package get implements the ``go get'' command.\n+package get\n \n import (\n \t\"fmt\"\n \t\"go/build\"\n \t\"os\"\n \t\"path/filepath\"\n-\t\"regexp\"\n \t\"runtime\"\n-\t\"strconv\"\n \t\"strings\"\n+\n+\t\"cmd/go/internal/base\"\n+\t\"cmd/go/internal/cfg\"\n+\t\"cmd/go/internal/load\"\n+\t\"cmd/go/internal/str\"\n+\t\"cmd/go/internal/web\"\n+\t\"cmd/go/internal/work\"\n )\n \n-var cmdGet = &Command{\n+var CmdGet = &base.Command{\n \tUsageLine: \"get [-d] [-f] [-fix] [-insecure] [-t] [-u] [build flags] [packages]\",\n \tShort:     \"download and install packages and dependencies\",\n \tLong: `\n@@ -40,7 +46,7 @@ The -t flag instructs get to also download the packages required to build\n the tests for the specified packages.\n \n The -u flag instructs get to use the network to update the named packages\n-and their dependencies.  By default, get uses the network to check out\n+and their dependencies. By default, get uses the network to check out\n missing packages but does not use it to look for updates to existing packages.\n \n The -v flag enables verbose progress and debug output.\n@@ -54,8 +60,8 @@ get uses the first one. For more details see: 'go help gopath'.\n When checking out or updating a package, get looks for a branch or tag\n that matches the locally installed version of Go. The most important\n rule is that if the local installation is running version \"go1\", get\n-searches for a branch or tag named \"go1\". If no such version exists it\n-retrieves the most recent version of the package.\n+searches for a branch or tag named \"go1\". If no such version exists\n+it retrieves the default branch of the package.\n \n When go get checks out or updates a Git repository,\n it also updates any git submodules referenced by the repository.\n@@ -71,21 +77,24 @@ See also: go build, go install, go clean.\n \t`,\n }\n \n-var getD = cmdGet.Flag.Bool(\"d\", false, \"\")\n-var getF = cmdGet.Flag.Bool(\"f\", false, \"\")\n-var getT = cmdGet.Flag.Bool(\"t\", false, \"\")\n-var getU = cmdGet.Flag.Bool(\"u\", false, \"\")\n-var getFix = cmdGet.Flag.Bool(\"fix\", false, \"\")\n-var getInsecure = cmdGet.Flag.Bool(\"insecure\", false, \"\")\n+var getD = CmdGet.Flag.Bool(\"d\", false, \"\")\n+var getF = CmdGet.Flag.Bool(\"f\", false, \"\")\n+var getT = CmdGet.Flag.Bool(\"t\", false, \"\")\n+var getU = CmdGet.Flag.Bool(\"u\", false, \"\")\n+var getFix = CmdGet.Flag.Bool(\"fix\", false, \"\")\n+var getInsecure = CmdGet.Flag.Bool(\"insecure\", false, \"\")\n \n func init() {\n-\taddBuildFlags(cmdGet)\n-\tcmdGet.Run = runGet // break init loop\n+\twork.AddBuildFlags(CmdGet)\n+\tCmdGet.Run = runGet // break init loop\n }\n \n-func runGet(cmd *Command, args []string) {\n+func runGet(cmd *base.Command, args []string) {\n+\twork.InstrumentInit()\n+\twork.BuildModeInit()\n+\n \tif *getF && !*getU {\n-\t\tfatalf(\"go get: cannot use -f flag without -u\")\n+\t\tbase.Fatalf(\"go get: cannot use -f flag without -u\")\n \t}\n \n \t// Disable any prompting for passwords by Git.\n@@ -115,17 +124,17 @@ func runGet(cmd *Command, args []string) {\n \t\tos.Setenv(\"GIT_SSH_COMMAND\", \"ssh -o ControlMaster=no\")\n \t}\n \n-\t// Phase 1.  Download/update.\n-\tvar stk importStack\n+\t// Phase 1. Download/update.\n+\tvar stk load.ImportStack\n \tmode := 0\n \tif *getT {\n-\t\tmode |= getTestDeps\n+\t\tmode |= load.GetTestDeps\n \t}\n \targs = downloadPaths(args)\n \tfor _, arg := range args {\n \t\tdownload(arg, nil, &stk, mode)\n \t}\n-\texitIfErrors()\n+\tbase.ExitIfErrors()\n \n \t// Phase 2. Rescan packages and re-evaluate args list.\n \n@@ -134,30 +143,26 @@ func runGet(cmd *Command, args []string) {\n \t// the information will be recomputed. Instead of keeping\n \t// track of the reverse dependency information, evict\n \t// everything.\n-\tfor name := range packageCache {\n-\t\tdelete(packageCache, name)\n-\t}\n+\tload.ClearPackageCache()\n \n \t// In order to rebuild packages information completely,\n \t// we need to clear commands cache. Command packages are\n \t// referring to evicted packages from the package cache.\n \t// This leads to duplicated loads of the standard packages.\n-\tfor name := range cmdCache {\n-\t\tdelete(cmdCache, name)\n-\t}\n+\tload.ClearCmdCache()\n \n-\targs = importPaths(args)\n-\tpackagesForBuild(args)\n+\targs = load.ImportPaths(args)\n+\tload.PackagesForBuild(args)\n \n-\t// Phase 3.  Install.\n+\t// Phase 3. Install.\n \tif *getD {\n \t\t// Download only.\n \t\t// Check delayed until now so that importPaths\n \t\t// and packagesForBuild have a chance to print errors.\n \t\treturn\n \t}\n \n-\tinstallPackages(args, true)\n+\twork.InstallPackages(args, true)\n }\n \n // downloadPaths prepares the list of paths to pass to download.\n@@ -166,7 +171,7 @@ func runGet(cmd *Command, args []string) {\n // in the hope that we can figure out the repository from the\n // initial ...-free prefix.\n func downloadPaths(args []string) []string {\n-\targs = importPathsNoDotExpansion(args)\n+\targs = load.ImportPathsNoDotExpansion(args)\n \tvar out []string\n \tfor _, a := range args {\n \t\tif strings.Contains(a, \"...\") {\n@@ -175,9 +180,9 @@ func downloadPaths(args []string) []string {\n \t\t\t// warnings. They will be printed by the\n \t\t\t// eventual call to importPaths instead.\n \t\t\tif build.IsLocalImport(a) {\n-\t\t\t\texpand = matchPackagesInFS(a)\n+\t\t\t\texpand = load.MatchPackagesInFS(a)\n \t\t\t} else {\n-\t\t\t\texpand = matchPackages(a)\n+\t\t\t\texpand = load.MatchPackages(a)\n \t\t\t}\n \t\t\tif len(expand) > 0 {\n \t\t\t\tout = append(out, expand...)\n@@ -204,21 +209,21 @@ var downloadRootCache = map[string]bool{}\n \n // download runs the download half of the get command\n // for the package named by the argument.\n-func download(arg string, parent *Package, stk *importStack, mode int) {\n-\tif mode&useVendor != 0 {\n+func download(arg string, parent *load.Package, stk *load.ImportStack, mode int) {\n+\tif mode&load.UseVendor != 0 {\n \t\t// Caller is responsible for expanding vendor paths.\n \t\tpanic(\"internal error: download mode has useVendor set\")\n \t}\n-\tload := func(path string, mode int) *Package {\n+\tload1 := func(path string, mode int) *load.Package {\n \t\tif parent == nil {\n-\t\t\treturn loadPackage(path, stk)\n+\t\t\treturn load.LoadPackage(path, stk)\n \t\t}\n-\t\treturn loadImport(path, parent.Dir, parent, stk, nil, mode)\n+\t\treturn load.LoadImport(path, parent.Dir, parent, stk, nil, mode)\n \t}\n \n-\tp := load(arg, mode)\n-\tif p.Error != nil && p.Error.hard {\n-\t\terrorf(\"%s\", p.Error)\n+\tp := load1(arg, mode)\n+\tif p.Error != nil && p.Error.Hard {\n+\t\tbase.Errorf(\"%s\", p.Error)\n \t\treturn\n \t}\n \n@@ -240,58 +245,52 @@ func download(arg string, parent *Package, stk *importStack, mode int) {\n \t// Only process each package once.\n \t// (Unless we're fetching test dependencies for this package,\n \t// in which case we want to process it again.)\n-\tif downloadCache[arg] && mode&getTestDeps == 0 {\n+\tif downloadCache[arg] && mode&load.GetTestDeps == 0 {\n \t\treturn\n \t}\n \tdownloadCache[arg] = true\n \n-\tpkgs := []*Package{p}\n+\tpkgs := []*load.Package{p}\n \twildcardOkay := len(*stk) == 0\n \tisWildcard := false\n \n \t// Download if the package is missing, or update if we're using -u.\n \tif p.Dir == \"\" || *getU {\n \t\t// The actual download.\n-\t\tstk.push(arg)\n+\t\tstk.Push(arg)\n \t\terr := downloadPackage(p)\n \t\tif err != nil {\n-\t\t\terrorf(\"%s\", &PackageError{ImportStack: stk.copy(), Err: err.Error()})\n-\t\t\tstk.pop()\n+\t\t\tbase.Errorf(\"%s\", &load.PackageError{ImportStack: stk.Copy(), Err: err.Error()})\n+\t\t\tstk.Pop()\n \t\t\treturn\n \t\t}\n-\t\tstk.pop()\n+\t\tstk.Pop()\n \n \t\targs := []string{arg}\n \t\t// If the argument has a wildcard in it, re-evaluate the wildcard.\n \t\t// We delay this until after reloadPackage so that the old entry\n \t\t// for p has been replaced in the package cache.\n \t\tif wildcardOkay && strings.Contains(arg, \"...\") {\n \t\t\tif build.IsLocalImport(arg) {\n-\t\t\t\targs = matchPackagesInFS(arg)\n+\t\t\t\targs = load.MatchPackagesInFS(arg)\n \t\t\t} else {\n-\t\t\t\targs = matchPackages(arg)\n+\t\t\t\targs = load.MatchPackages(arg)\n \t\t\t}\n \t\t\tisWildcard = true\n \t\t}\n \n \t\t// Clear all relevant package cache entries before\n \t\t// doing any new loads.\n-\t\tfor _, arg := range args {\n-\t\t\tp := packageCache[arg]\n-\t\t\tif p != nil {\n-\t\t\t\tdelete(packageCache, p.Dir)\n-\t\t\t\tdelete(packageCache, p.ImportPath)\n-\t\t\t}\n-\t\t}\n+\t\tload.ClearPackageCachePartial(args)\n \n \t\tpkgs = pkgs[:0]\n \t\tfor _, arg := range args {\n \t\t\t// Note: load calls loadPackage or loadImport,\n \t\t\t// which push arg onto stk already.\n \t\t\t// Do not push here too, or else stk will say arg imports arg.\n-\t\t\tp := load(arg, mode)\n+\t\t\tp := load1(arg, mode)\n \t\t\tif p.Error != nil {\n-\t\t\t\terrorf(\"%s\", p.Error)\n+\t\t\t\tbase.Errorf(\"%s\", p.Error)\n \t\t\t\tcontinue\n \t\t\t}\n \t\t\tpkgs = append(pkgs, p)\n@@ -302,92 +301,93 @@ func download(arg string, parent *Package, stk *importStack, mode int) {\n \t// due to wildcard expansion.\n \tfor _, p := range pkgs {\n \t\tif *getFix {\n-\t\t\trun(buildToolExec, stringList(tool(\"fix\"), relPaths(p.allgofiles)))\n+\t\t\tfiles := base.FilterDotUnderscoreFiles(base.RelPaths(p.Internal.AllGoFiles))\n+\t\t\tbase.Run(cfg.BuildToolexec, str.StringList(base.Tool(\"fix\"), files))\n \n \t\t\t// The imports might have changed, so reload again.\n-\t\t\tp = reloadPackage(arg, stk)\n+\t\t\tp = load.ReloadPackage(arg, stk)\n \t\t\tif p.Error != nil {\n-\t\t\t\terrorf(\"%s\", p.Error)\n+\t\t\t\tbase.Errorf(\"%s\", p.Error)\n \t\t\t\treturn\n \t\t\t}\n \t\t}\n \n \t\tif isWildcard {\n \t\t\t// Report both the real package and the\n \t\t\t// wildcard in any error message.\n-\t\t\tstk.push(p.ImportPath)\n+\t\t\tstk.Push(p.ImportPath)\n \t\t}\n \n \t\t// Process dependencies, now that we know what they are.\n \t\timports := p.Imports\n-\t\tif mode&getTestDeps != 0 {\n+\t\tif mode&load.GetTestDeps != 0 {\n \t\t\t// Process test dependencies when -t is specified.\n \t\t\t// (But don't get test dependencies for test dependencies:\n \t\t\t// we always pass mode 0 to the recursive calls below.)\n-\t\t\timports = stringList(imports, p.TestImports, p.XTestImports)\n+\t\t\timports = str.StringList(imports, p.TestImports, p.XTestImports)\n \t\t}\n \t\tfor i, path := range imports {\n \t\t\tif path == \"C\" {\n \t\t\t\tcontinue\n \t\t\t}\n \t\t\t// Fail fast on import naming full vendor path.\n \t\t\t// Otherwise expand path as needed for test imports.\n-\t\t\t// Note that p.Imports can have additional entries beyond p.build.Imports.\n+\t\t\t// Note that p.Imports can have additional entries beyond p.Internal.Build.Imports.\n \t\t\torig := path\n-\t\t\tif i < len(p.build.Imports) {\n-\t\t\t\torig = p.build.Imports[i]\n+\t\t\tif i < len(p.Internal.Build.Imports) {\n+\t\t\t\torig = p.Internal.Build.Imports[i]\n \t\t\t}\n-\t\t\tif j, ok := findVendor(orig); ok {\n-\t\t\t\tstk.push(path)\n-\t\t\t\terr := &PackageError{\n-\t\t\t\t\tImportStack: stk.copy(),\n+\t\t\tif j, ok := load.FindVendor(orig); ok {\n+\t\t\t\tstk.Push(path)\n+\t\t\t\terr := &load.PackageError{\n+\t\t\t\t\tImportStack: stk.Copy(),\n \t\t\t\t\tErr:         \"must be imported as \" + path[j+len(\"vendor/\"):],\n \t\t\t\t}\n-\t\t\t\tstk.pop()\n-\t\t\t\terrorf(\"%s\", err)\n+\t\t\t\tstk.Pop()\n+\t\t\t\tbase.Errorf(\"%s\", err)\n \t\t\t\tcontinue\n \t\t\t}\n \t\t\t// If this is a test import, apply vendor lookup now.\n \t\t\t// We cannot pass useVendor to download, because\n \t\t\t// download does caching based on the value of path,\n \t\t\t// so it must be the fully qualified path already.\n \t\t\tif i >= len(p.Imports) {\n-\t\t\t\tpath = vendoredImportPath(p, path)\n+\t\t\t\tpath = load.VendoredImportPath(p, path)\n \t\t\t}\n \t\t\tdownload(path, p, stk, 0)\n \t\t}\n \n \t\tif isWildcard {\n-\t\t\tstk.pop()\n+\t\t\tstk.Pop()\n \t\t}\n \t}\n }\n \n // downloadPackage runs the create or download command\n // to make the first copy of or update a copy of the given package.\n-func downloadPackage(p *Package) error {\n+func downloadPackage(p *load.Package) error {\n \tvar (\n \t\tvcs            *vcsCmd\n \t\trepo, rootPath string\n \t\terr            error\n \t)\n \n-\tsecurity := secure\n+\tsecurity := web.Secure\n \tif *getInsecure {\n-\t\tsecurity = insecure\n+\t\tsecurity = web.Insecure\n \t}\n \n-\tif p.build.SrcRoot != \"\" {\n+\tif p.Internal.Build.SrcRoot != \"\" {\n \t\t// Directory exists. Look for checkout along path to src.\n-\t\tvcs, rootPath, err = vcsFromDir(p.Dir, p.build.SrcRoot)\n+\t\tvcs, rootPath, err = vcsFromDir(p.Dir, p.Internal.Build.SrcRoot)\n \t\tif err != nil {\n \t\t\treturn err\n \t\t}\n \t\trepo = \"<local>\" // should be unused; make distinctive\n \n \t\t// Double-check where it came from.\n \t\tif *getU && vcs.remoteRepo != nil {\n-\t\t\tdir := filepath.Join(p.build.SrcRoot, filepath.FromSlash(rootPath))\n+\t\t\tdir := filepath.Join(p.Internal.Build.SrcRoot, filepath.FromSlash(rootPath))\n \t\t\tremote, err := vcs.remoteRepo(vcs, dir)\n \t\t\tif err != nil {\n \t\t\t\treturn err\n@@ -421,31 +421,31 @@ func downloadPackage(p *Package) error {\n \t\treturn fmt.Errorf(\"cannot download, %v uses insecure protocol\", repo)\n \t}\n \n-\tif p.build.SrcRoot == \"\" {\n+\tif p.Internal.Build.SrcRoot == \"\" {\n \t\t// Package not found. Put in first directory of $GOPATH.\n-\t\tlist := filepath.SplitList(buildContext.GOPATH)\n+\t\tlist := filepath.SplitList(cfg.BuildContext.GOPATH)\n \t\tif len(list) == 0 {\n \t\t\treturn fmt.Errorf(\"cannot download, $GOPATH not set. For more details see: 'go help gopath'\")\n \t\t}\n \t\t// Guard against people setting GOPATH=$GOROOT.\n-\t\tif filepath.Clean(list[0]) == filepath.Clean(goroot) {\n+\t\tif filepath.Clean(list[0]) == filepath.Clean(cfg.GOROOT) {\n \t\t\treturn fmt.Errorf(\"cannot download, $GOPATH must not be set to $GOROOT. For more details see: 'go help gopath'\")\n \t\t}\n \t\tif _, err := os.Stat(filepath.Join(list[0], \"src/cmd/go/alldocs.go\")); err == nil {\n \t\t\treturn fmt.Errorf(\"cannot download, %s is a GOROOT, not a GOPATH. For more details see: 'go help gopath'\", list[0])\n \t\t}\n-\t\tp.build.Root = list[0]\n-\t\tp.build.SrcRoot = filepath.Join(list[0], \"src\")\n-\t\tp.build.PkgRoot = filepath.Join(list[0], \"pkg\")\n+\t\tp.Internal.Build.Root = list[0]\n+\t\tp.Internal.Build.SrcRoot = filepath.Join(list[0], \"src\")\n+\t\tp.Internal.Build.PkgRoot = filepath.Join(list[0], \"pkg\")\n \t}\n-\troot := filepath.Join(p.build.SrcRoot, filepath.FromSlash(rootPath))\n+\troot := filepath.Join(p.Internal.Build.SrcRoot, filepath.FromSlash(rootPath))\n \t// If we've considered this repository already, don't do it again.\n \tif downloadRootCache[root] {\n \t\treturn nil\n \t}\n \tdownloadRootCache[root] = true\n \n-\tif buildV {\n+\tif cfg.BuildV {\n \t\tfmt.Fprintf(os.Stderr, \"%s (download)\\n\", rootPath)\n \t}\n \n@@ -464,16 +464,16 @@ func downloadPackage(p *Package) error {\n \t\t\treturn fmt.Errorf(\"%s exists but %s does not - stale checkout?\", root, meta)\n \t\t}\n \n-\t\t_, err := os.Stat(p.build.Root)\n+\t\t_, err := os.Stat(p.Internal.Build.Root)\n \t\tgopathExisted := err == nil\n \n \t\t// Some version control tools require the parent of the target to exist.\n \t\tparent, _ := filepath.Split(root)\n \t\tif err = os.MkdirAll(parent, 0777); err != nil {\n \t\t\treturn err\n \t\t}\n-\t\tif buildV && !gopathExisted && p.build.Root == buildContext.GOPATH {\n-\t\t\tfmt.Fprintf(os.Stderr, \"created GOPATH=%s; see 'go help gopath'\\n\", p.build.Root)\n+\t\tif cfg.BuildV && !gopathExisted && p.Internal.Build.Root == cfg.BuildContext.GOPATH {\n+\t\t\tfmt.Fprintf(os.Stderr, \"created GOPATH=%s; see 'go help gopath'\\n\", p.Internal.Build.Root)\n \t\t}\n \n \t\tif err = vcs.create(root, repo); err != nil {\n@@ -486,7 +486,7 @@ func downloadPackage(p *Package) error {\n \t\t}\n \t}\n \n-\tif buildN {\n+\tif cfg.BuildN {\n \t\t// Do not show tag sync in -n; it's noise more than anything,\n \t\t// and since we're not running commands, no tag will be found.\n \t\t// But avoid printing nothing.\n@@ -510,79 +510,19 @@ func downloadPackage(p *Package) error {\n \treturn nil\n }\n \n-// goTag matches go release tags such as go1 and go1.2.3.\n-// The numbers involved must be small (at most 4 digits),\n-// have no unnecessary leading zeros, and the version cannot\n-// end in .0 - it is go1, not go1.0 or go1.0.0.\n-var goTag = regexp.MustCompile(\n-\t`^go((0|[1-9][0-9]{0,3})\\.)*([1-9][0-9]{0,3})$`,\n-)\n-\n // selectTag returns the closest matching tag for a given version.\n // Closest means the latest one that is not after the current release.\n // Version \"goX\" (or \"goX.Y\" or \"goX.Y.Z\") matches tags of the same form.\n // Version \"release.rN\" matches tags of the form \"go.rN\" (N being a floating-point number).\n // Version \"weekly.YYYY-MM-DD\" matches tags like \"go.weekly.YYYY-MM-DD\".\n //\n // NOTE(rsc): Eventually we will need to decide on some logic here.\n-// For now, there is only \"go1\".  This matches the docs in go help get.\n+// For now, there is only \"go1\". This matches the docs in go help get.\n func selectTag(goVersion string, tags []string) (match string) {\n \tfor _, t := range tags {\n \t\tif t == \"go1\" {\n \t\t\treturn \"go1\"\n \t\t}\n \t}\n \treturn \"\"\n-\n-\t/*\n-\t\tif goTag.MatchString(goVersion) {\n-\t\t\tv := goVersion\n-\t\t\tfor _, t := range tags {\n-\t\t\t\tif !goTag.MatchString(t) {\n-\t\t\t\t\tcontinue\n-\t\t\t\t}\n-\t\t\t\tif cmpGoVersion(match, t) < 0 && cmpGoVersion(t, v) <= 0 {\n-\t\t\t\t\tmatch = t\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn match\n-\t*/\n-}\n-\n-// cmpGoVersion returns -1, 0, +1 reporting whether\n-// x < y, x == y, or x > y.\n-func cmpGoVersion(x, y string) int {\n-\t// Malformed strings compare less than well-formed strings.\n-\tif !goTag.MatchString(x) {\n-\t\treturn -1\n-\t}\n-\tif !goTag.MatchString(y) {\n-\t\treturn +1\n-\t}\n-\n-\t// Compare numbers in sequence.\n-\txx := strings.Split(x[len(\"go\"):], \".\")\n-\tyy := strings.Split(y[len(\"go\"):], \".\")\n-\n-\tfor i := 0; i < len(xx) && i < len(yy); i++ {\n-\t\t// The Atoi are guaranteed to succeed\n-\t\t// because the versions match goTag.\n-\t\txi, _ := strconv.Atoi(xx[i])\n-\t\tyi, _ := strconv.Atoi(yy[i])\n-\t\tif xi < yi {\n-\t\t\treturn -1\n-\t\t} else if xi > yi {\n-\t\t\treturn +1\n-\t\t}\n-\t}\n-\n-\tif len(xx) < len(yy) {\n-\t\treturn -1\n-\t}\n-\tif len(xx) > len(yy) {\n-\t\treturn +1\n-\t}\n-\treturn 0\n }", "previous_filename": "libgo/go/cmd/go/get.go"}, {"sha": "b8937a57ec9122d036edfe559c297c9ca4e9c8dc", "filename": "libgo/go/cmd/go/internal/get/pkg_test.go", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fpkg_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fpkg_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fpkg_test.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -0,0 +1,83 @@\n+// Copyright 2014 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package get\n+\n+import (\n+\t\"cmd/go/internal/str\"\n+\t\"reflect\"\n+\t\"strings\"\n+\t\"testing\"\n+)\n+\n+var foldDupTests = []struct {\n+\tlist   []string\n+\tf1, f2 string\n+}{\n+\t{str.StringList(\"math/rand\", \"math/big\"), \"\", \"\"},\n+\t{str.StringList(\"math\", \"strings\"), \"\", \"\"},\n+\t{str.StringList(\"strings\"), \"\", \"\"},\n+\t{str.StringList(\"strings\", \"strings\"), \"strings\", \"strings\"},\n+\t{str.StringList(\"Rand\", \"rand\", \"math\", \"math/rand\", \"math/Rand\"), \"Rand\", \"rand\"},\n+}\n+\n+func TestFoldDup(t *testing.T) {\n+\tfor _, tt := range foldDupTests {\n+\t\tf1, f2 := str.FoldDup(tt.list)\n+\t\tif f1 != tt.f1 || f2 != tt.f2 {\n+\t\t\tt.Errorf(\"foldDup(%q) = %q, %q, want %q, %q\", tt.list, f1, f2, tt.f1, tt.f2)\n+\t\t}\n+\t}\n+}\n+\n+var parseMetaGoImportsTests = []struct {\n+\tin  string\n+\tout []metaImport\n+}{\n+\t{\n+\t\t`<meta name=\"go-import\" content=\"foo/bar git https://github.com/rsc/foo/bar\">`,\n+\t\t[]metaImport{{\"foo/bar\", \"git\", \"https://github.com/rsc/foo/bar\"}},\n+\t},\n+\t{\n+\t\t`<meta name=\"go-import\" content=\"foo/bar git https://github.com/rsc/foo/bar\">\n+\t\t<meta name=\"go-import\" content=\"baz/quux git http://github.com/rsc/baz/quux\">`,\n+\t\t[]metaImport{\n+\t\t\t{\"foo/bar\", \"git\", \"https://github.com/rsc/foo/bar\"},\n+\t\t\t{\"baz/quux\", \"git\", \"http://github.com/rsc/baz/quux\"},\n+\t\t},\n+\t},\n+\t{\n+\t\t`<head>\n+\t\t<meta name=\"go-import\" content=\"foo/bar git https://github.com/rsc/foo/bar\">\n+\t\t</head>`,\n+\t\t[]metaImport{{\"foo/bar\", \"git\", \"https://github.com/rsc/foo/bar\"}},\n+\t},\n+\t{\n+\t\t`<meta name=\"go-import\" content=\"foo/bar git https://github.com/rsc/foo/bar\">\n+\t\t<body>`,\n+\t\t[]metaImport{{\"foo/bar\", \"git\", \"https://github.com/rsc/foo/bar\"}},\n+\t},\n+\t{\n+\t\t`<!doctype html><meta name=\"go-import\" content=\"foo/bar git https://github.com/rsc/foo/bar\">`,\n+\t\t[]metaImport{{\"foo/bar\", \"git\", \"https://github.com/rsc/foo/bar\"}},\n+\t},\n+\t{\n+\t\t// XML doesn't like <div style=position:relative>.\n+\t\t`<!doctype html><title>Page Not Found</title><meta name=go-import content=\"chitin.io/chitin git https://github.com/chitin-io/chitin\"><div style=position:relative>DRAFT</div>`,\n+\t\t[]metaImport{{\"chitin.io/chitin\", \"git\", \"https://github.com/chitin-io/chitin\"}},\n+\t},\n+}\n+\n+func TestParseMetaGoImports(t *testing.T) {\n+\tfor i, tt := range parseMetaGoImportsTests {\n+\t\tout, err := parseMetaGoImports(strings.NewReader(tt.in))\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"test#%d: %v\", i, err)\n+\t\t\tcontinue\n+\t\t}\n+\t\tif !reflect.DeepEqual(out, tt.out) {\n+\t\t\tt.Errorf(\"test#%d:\\n\\thave %q\\n\\twant %q\", i, out, tt.out)\n+\t\t}\n+\t}\n+}"}, {"sha": "9a25dfafbc3559b5440c31f69a9ab9648c18516d", "filename": "libgo/go/cmd/go/internal/get/tag_test.go", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Ftag_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Ftag_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Ftag_test.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-package main\n+package get\n \n import \"testing\"\n ", "previous_filename": "libgo/go/cmd/go/tag_test.go"}, {"sha": "71d0b51344a979c0ffc2921585b3c232d087a9db", "filename": "libgo/go/cmd/go/internal/get/vcs.go", "status": "renamed", "additions": 36, "deletions": 37, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fvcs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fvcs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fvcs.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-package main\n+package get\n \n import (\n \t\"bytes\"\n@@ -18,6 +18,10 @@ import (\n \t\"regexp\"\n \t\"strings\"\n \t\"sync\"\n+\n+\t\"cmd/go/internal/base\"\n+\t\"cmd/go/internal/cfg\"\n+\t\"cmd/go/internal/web\"\n )\n \n // A vcsCmd describes how to use a version control system\n@@ -298,15 +302,20 @@ func svnRemoteRepo(vcsSvn *vcsCmd, rootDir string) (remoteRepo string, err error\n \tout := string(outb)\n \n \t// Expect:\n-\t// ...\n-\t// Repository Root: <URL>\n-\t// ...\n-\n-\ti := strings.Index(out, \"\\nRepository Root: \")\n+\t//\n+\t//\t ...\n+\t// \tURL: <URL>\n+\t// \t...\n+\t//\n+\t// Note that we're not using the Repository Root line,\n+\t// because svn allows checking out subtrees.\n+\t// The URL will be the URL of the subtree (what we used with 'svn co')\n+\t// while the Repository Root may be a much higher parent.\n+\ti := strings.Index(out, \"\\nURL: \")\n \tif i < 0 {\n \t\treturn \"\", fmt.Errorf(\"unable to parse output of svn info\")\n \t}\n-\tout = out[i+len(\"\\nRepository Root: \"):]\n+\tout = out[i+len(\"\\nURL: \"):]\n \ti = strings.Index(out, \"\\n\")\n \tif i < 0 {\n \t\treturn \"\", fmt.Errorf(\"unable to parse output of svn info\")\n@@ -320,7 +329,7 @@ func (v *vcsCmd) String() string {\n }\n \n // run runs the command line cmd in the given directory.\n-// keyval is a list of key, value pairs.  run expands\n+// keyval is a list of key, value pairs. run expands\n // instances of {key} in cmd into value, but only after\n // splitting cmd into individual arguments.\n // If an error occurs, run prints the command line and the\n@@ -372,8 +381,8 @@ func (v *vcsCmd) run1(dir string, cmdline string, keyval []string, verbose bool)\n \n \tcmd := exec.Command(v.cmd, args...)\n \tcmd.Dir = dir\n-\tcmd.Env = envForDir(cmd.Dir, os.Environ())\n-\tif buildX {\n+\tcmd.Env = base.EnvForDir(cmd.Dir, os.Environ())\n+\tif cfg.BuildX {\n \t\tfmt.Printf(\"cd %s\\n\", dir)\n \t\tfmt.Printf(\"%s %s\\n\", v.cmd, strings.Join(args, \" \"))\n \t}\n@@ -383,7 +392,7 @@ func (v *vcsCmd) run1(dir string, cmdline string, keyval []string, verbose bool)\n \terr = cmd.Run()\n \tout := buf.Bytes()\n \tif err != nil {\n-\t\tif verbose || buildV {\n+\t\tif verbose || cfg.BuildV {\n \t\t\tfmt.Fprintf(os.Stderr, \"# cd %s; %s %s\\n\", dir, v.cmd, strings.Join(args, \" \"))\n \t\t\tos.Stderr.Write(out)\n \t\t}\n@@ -535,19 +544,9 @@ type repoRoot struct {\n \n var httpPrefixRE = regexp.MustCompile(`^https?:`)\n \n-// securityMode specifies whether a function should make network\n-// calls using insecure transports (eg, plain text HTTP).\n-// The zero value is \"secure\".\n-type securityMode int\n-\n-const (\n-\tsecure securityMode = iota\n-\tinsecure\n-)\n-\n // repoRootForImportPath analyzes importPath to determine the\n // version control system, and code repository to use.\n-func repoRootForImportPath(importPath string, security securityMode) (*repoRoot, error) {\n+func repoRootForImportPath(importPath string, security web.SecurityMode) (*repoRoot, error) {\n \trr, err := repoRootFromVCSPaths(importPath, \"\", security, vcsPaths)\n \tif err == errUnknownSite {\n \t\t// If there are wildcards, look up the thing before the wildcard,\n@@ -583,7 +582,7 @@ var errUnknownSite = errors.New(\"dynamic lookup required to find mapping\")\n // repoRootFromVCSPaths attempts to map importPath to a repoRoot\n // using the mappings defined in vcsPaths.\n // If scheme is non-empty, that scheme is forced.\n-func repoRootFromVCSPaths(importPath, scheme string, security securityMode, vcsPaths []*vcsPath) (*repoRoot, error) {\n+func repoRootFromVCSPaths(importPath, scheme string, security web.SecurityMode, vcsPaths []*vcsPath) (*repoRoot, error) {\n \t// A common error is to use https://packagepath because that's what\n \t// hg and git require. Diagnose this helpfully.\n \tif loc := httpPrefixRE.FindStringIndex(importPath); loc != nil {\n@@ -633,7 +632,7 @@ func repoRootFromVCSPaths(importPath, scheme string, security securityMode, vcsP\n \t\t\t\tmatch[\"repo\"] = scheme + \"://\" + match[\"repo\"]\n \t\t\t} else {\n \t\t\t\tfor _, scheme := range vcs.scheme {\n-\t\t\t\t\tif security == secure && !vcs.isSecureScheme(scheme) {\n+\t\t\t\t\tif security == web.Secure && !vcs.isSecureScheme(scheme) {\n \t\t\t\t\t\tcontinue\n \t\t\t\t\t}\n \t\t\t\t\tif vcs.ping(scheme, match[\"repo\"]) == nil {\n@@ -657,7 +656,7 @@ func repoRootFromVCSPaths(importPath, scheme string, security securityMode, vcsP\n // statically known by repoRootForImportPathStatic.\n //\n // This handles custom import paths like \"name.tld/pkg/foo\" or just \"name.tld\".\n-func repoRootForImportDynamic(importPath string, security securityMode) (*repoRoot, error) {\n+func repoRootForImportDynamic(importPath string, security web.SecurityMode) (*repoRoot, error) {\n \tslash := strings.Index(importPath, \"/\")\n \tif slash < 0 {\n \t\tslash = len(importPath)\n@@ -666,10 +665,10 @@ func repoRootForImportDynamic(importPath string, security securityMode) (*repoRo\n \tif !strings.Contains(host, \".\") {\n \t\treturn nil, errors.New(\"import path does not begin with hostname\")\n \t}\n-\turlStr, body, err := httpsOrHTTP(importPath, security)\n+\turlStr, body, err := web.GetMaybeInsecure(importPath, security)\n \tif err != nil {\n \t\tmsg := \"https fetch: %v\"\n-\t\tif security == insecure {\n+\t\tif security == web.Insecure {\n \t\t\tmsg = \"http/\" + msg\n \t\t}\n \t\treturn nil, fmt.Errorf(msg, err)\n@@ -687,17 +686,17 @@ func repoRootForImportDynamic(importPath string, security securityMode) (*repoRo\n \t\t}\n \t\treturn nil, fmt.Errorf(\"parse %s: no go-import meta tags (%s)\", urlStr, err)\n \t}\n-\tif buildV {\n+\tif cfg.BuildV {\n \t\tlog.Printf(\"get %q: found meta tag %#v at %s\", importPath, mmi, urlStr)\n \t}\n \t// If the import was \"uni.edu/bob/project\", which said the\n \t// prefix was \"uni.edu\" and the RepoRoot was \"evilroot.com\",\n \t// make sure we don't trust Bob and check out evilroot.com to\n \t// \"uni.edu\" yet (possibly overwriting/preempting another\n-\t// non-evil student).  Instead, first verify the root and see\n+\t// non-evil student). Instead, first verify the root and see\n \t// if it matches Bob's claim.\n \tif mmi.Prefix != importPath {\n-\t\tif buildV {\n+\t\tif cfg.BuildV {\n \t\t\tlog.Printf(\"get %q: verifying non-authoritative meta tag\", importPath)\n \t\t}\n \t\turlStr0 := urlStr\n@@ -741,7 +740,7 @@ var (\n // It is an error if no imports are found.\n // urlStr will still be valid if err != nil.\n // The returned urlStr will be of the form \"https://golang.org/x/tools?go-get=1\"\n-func metaImportsForPrefix(importPrefix string, security securityMode) (urlStr string, imports []metaImport, err error) {\n+func metaImportsForPrefix(importPrefix string, security web.SecurityMode) (urlStr string, imports []metaImport, err error) {\n \tsetCache := func(res fetchResult) (fetchResult, error) {\n \t\tfetchCacheMu.Lock()\n \t\tdefer fetchCacheMu.Unlock()\n@@ -757,7 +756,7 @@ func metaImportsForPrefix(importPrefix string, security securityMode) (urlStr st\n \t\t}\n \t\tfetchCacheMu.Unlock()\n \n-\t\turlStr, body, err := httpsOrHTTP(importPrefix, security)\n+\t\turlStr, body, err := web.GetMaybeInsecure(importPrefix, security)\n \t\tif err != nil {\n \t\t\treturn setCache(fetchResult{urlStr: urlStr, err: fmt.Errorf(\"fetch %s: %v\", urlStr, err)})\n \t\t}\n@@ -857,7 +856,7 @@ var vcsPaths = []*vcsPath{\n \t// Github\n \t{\n \t\tprefix: \"github.com/\",\n-\t\tre:     `^(?P<root>github\\.com/[A-Za-z0-9_.\\-]+/[A-Za-z0-9_.\\-]+)(/[A-Za-z0-9_.\\-]+)*$`,\n+\t\tre:     `^(?P<root>github\\.com/[A-Za-z0-9_.\\-]+/[A-Za-z0-9_.\\-]+)(/[\\p{L}0-9_.\\-]+)*$`,\n \t\tvcs:    \"git\",\n \t\trepo:   \"https://{root}\",\n \t\tcheck:  noVCSSuffix,\n@@ -954,10 +953,10 @@ func bitbucketVCS(match map[string]string) error {\n \tvar resp struct {\n \t\tSCM string `json:\"scm\"`\n \t}\n-\turl := expand(match, \"https://api.bitbucket.org/1.0/repositories/{bitname}\")\n-\tdata, err := httpGET(url)\n+\turl := expand(match, \"https://api.bitbucket.org/2.0/repositories/{bitname}?fields=scm\")\n+\tdata, err := web.Get(url)\n \tif err != nil {\n-\t\tif httpErr, ok := err.(*httpError); ok && httpErr.statusCode == 403 {\n+\t\tif httpErr, ok := err.(*web.HTTPError); ok && httpErr.StatusCode == 403 {\n \t\t\t// this may be a private repository. If so, attempt to determine which\n \t\t\t// VCS it uses. See issue 5375.\n \t\t\troot := match[\"root\"]\n@@ -997,7 +996,7 @@ func launchpadVCS(match map[string]string) error {\n \tif match[\"project\"] == \"\" || match[\"series\"] == \"\" {\n \t\treturn nil\n \t}\n-\t_, err := httpGET(expand(match, \"https://code.launchpad.net/{project}{series}/.bzr/branch-format\"))\n+\t_, err := web.Get(expand(match, \"https://code.launchpad.net/{project}{series}/.bzr/branch-format\"))\n \tif err != nil {\n \t\tmatch[\"root\"] = expand(match, \"launchpad.net/{project}\")\n \t\tmatch[\"repo\"] = expand(match, \"https://{root}\")", "previous_filename": "libgo/go/cmd/go/vcs.go"}, {"sha": "62d352ae575eef8bb01f12d5184e8a2377694205", "filename": "libgo/go/cmd/go/internal/get/vcs_test.go", "status": "renamed", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fvcs_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fvcs_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fvcs_test.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-package main\n+package get\n \n import (\n \t\"errors\"\n@@ -12,6 +12,8 @@ import (\n \t\"path\"\n \t\"path/filepath\"\n \t\"testing\"\n+\n+\t\"cmd/go/internal/web\"\n )\n \n // Test that RepoRootForImportPath creates the correct RepoRoot for a given importPath.\n@@ -30,6 +32,14 @@ func TestRepoRootForImportPath(t *testing.T) {\n \t\t\t\trepo: \"https://github.com/golang/groupcache\",\n \t\t\t},\n \t\t},\n+\t\t// Unicode letters in directories (issue 18660).\n+\t\t{\n+\t\t\t\"github.com/user/unicode/\u0438\u0441\u043f\u044b\u0442\u0430\u043d\u0438\u0435\",\n+\t\t\t&repoRoot{\n+\t\t\t\tvcs:  vcsGit,\n+\t\t\t\trepo: \"https://github.com/user/unicode\",\n+\t\t\t},\n+\t\t},\n \t\t// IBM DevOps Services tests\n \t\t{\n \t\t\t\"hub.jazz.net/git/user1/pkgname\",\n@@ -147,21 +157,21 @@ func TestRepoRootForImportPath(t *testing.T) {\n \t}\n \n \tfor _, test := range tests {\n-\t\tgot, err := repoRootForImportPath(test.path, secure)\n+\t\tgot, err := repoRootForImportPath(test.path, web.Secure)\n \t\twant := test.want\n \n \t\tif want == nil {\n \t\t\tif err == nil {\n-\t\t\t\tt.Errorf(\"RepoRootForImport(%q): Error expected but not received\", test.path)\n+\t\t\t\tt.Errorf(\"repoRootForImportPath(%q): Error expected but not received\", test.path)\n \t\t\t}\n \t\t\tcontinue\n \t\t}\n \t\tif err != nil {\n-\t\t\tt.Errorf(\"RepoRootForImport(%q): %v\", test.path, err)\n+\t\t\tt.Errorf(\"repoRootForImportPath(%q): %v\", test.path, err)\n \t\t\tcontinue\n \t\t}\n \t\tif got.vcs.name != want.vcs.name || got.repo != want.repo {\n-\t\t\tt.Errorf(\"RepoRootForImport(%q) = VCS(%s) Repo(%s), want VCS(%s) Repo(%s)\", test.path, got.vcs, got.repo, want.vcs, want.repo)\n+\t\t\tt.Errorf(\"repoRootForImportPath(%q) = VCS(%s) Repo(%s), want VCS(%s) Repo(%s)\", test.path, got.vcs, got.repo, want.vcs, want.repo)\n \t\t}\n \t}\n }", "previous_filename": "libgo/go/cmd/go/vcs_test.go"}, {"sha": "b4c5217f83688db6cb62d4f5c9b8f69cded50cb6", "filename": "libgo/go/cmd/go/internal/help/help.go", "status": "added", "additions": 178, "deletions": 0, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fhelp%2Fhelp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fhelp%2Fhelp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fhelp%2Fhelp.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -0,0 +1,178 @@\n+// Copyright 2017 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Package help implements the ``go help'' command.\n+package help\n+\n+import (\n+\t\"bufio\"\n+\t\"bytes\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"os\"\n+\t\"strings\"\n+\t\"text/template\"\n+\t\"unicode\"\n+\t\"unicode/utf8\"\n+\n+\t\"cmd/go/internal/base\"\n+)\n+\n+// Help implements the 'help' command.\n+func Help(args []string) {\n+\tif len(args) == 0 {\n+\t\tPrintUsage(os.Stdout)\n+\t\t// not exit 2: succeeded at 'go help'.\n+\t\treturn\n+\t}\n+\tif len(args) != 1 {\n+\t\tfmt.Fprintf(os.Stderr, \"usage: go help command\\n\\nToo many arguments given.\\n\")\n+\t\tos.Exit(2) // failed at 'go help'\n+\t}\n+\n+\targ := args[0]\n+\n+\t// 'go help documentation' generates doc.go.\n+\tif arg == \"documentation\" {\n+\t\tfmt.Println(\"// Copyright 2011 The Go Authors. All rights reserved.\")\n+\t\tfmt.Println(\"// Use of this source code is governed by a BSD-style\")\n+\t\tfmt.Println(\"// license that can be found in the LICENSE file.\")\n+\t\tfmt.Println()\n+\t\tfmt.Println(\"// DO NOT EDIT THIS FILE. GENERATED BY mkalldocs.sh.\")\n+\t\tfmt.Println(\"// Edit the documentation in other files and rerun mkalldocs.sh to generate this one.\")\n+\t\tfmt.Println()\n+\t\tbuf := new(bytes.Buffer)\n+\t\tPrintUsage(buf)\n+\t\tusage := &base.Command{Long: buf.String()}\n+\t\ttmpl(&commentWriter{W: os.Stdout}, documentationTemplate, append([]*base.Command{usage}, base.Commands...))\n+\t\tfmt.Println(\"package main\")\n+\t\treturn\n+\t}\n+\n+\tfor _, cmd := range base.Commands {\n+\t\tif cmd.Name() == arg {\n+\t\t\ttmpl(os.Stdout, helpTemplate, cmd)\n+\t\t\t// not exit 2: succeeded at 'go help cmd'.\n+\t\t\treturn\n+\t\t}\n+\t}\n+\n+\tfmt.Fprintf(os.Stderr, \"Unknown help topic %#q. Run 'go help'.\\n\", arg)\n+\tos.Exit(2) // failed at 'go help cmd'\n+}\n+\n+var usageTemplate = `Go is a tool for managing Go source code.\n+\n+Usage:\n+\n+\tgo command [arguments]\n+\n+The commands are:\n+{{range .}}{{if .Runnable}}\n+\t{{.Name | printf \"%-11s\"}} {{.Short}}{{end}}{{end}}\n+\n+Use \"go help [command]\" for more information about a command.\n+\n+Additional help topics:\n+{{range .}}{{if not .Runnable}}\n+\t{{.Name | printf \"%-11s\"}} {{.Short}}{{end}}{{end}}\n+\n+Use \"go help [topic]\" for more information about that topic.\n+\n+`\n+\n+var helpTemplate = `{{if .Runnable}}usage: go {{.UsageLine}}\n+\n+{{end}}{{.Long | trim}}\n+`\n+\n+var documentationTemplate = `{{range .}}{{if .Short}}{{.Short | capitalize}}\n+\n+{{end}}{{if .Runnable}}Usage:\n+\n+\tgo {{.UsageLine}}\n+\n+{{end}}{{.Long | trim}}\n+\n+\n+{{end}}`\n+\n+// commentWriter writes a Go comment to the underlying io.Writer,\n+// using line comment form (//).\n+type commentWriter struct {\n+\tW            io.Writer\n+\twroteSlashes bool // Wrote \"//\" at the beginning of the current line.\n+}\n+\n+func (c *commentWriter) Write(p []byte) (int, error) {\n+\tvar n int\n+\tfor i, b := range p {\n+\t\tif !c.wroteSlashes {\n+\t\t\ts := \"//\"\n+\t\t\tif b != '\\n' {\n+\t\t\t\ts = \"// \"\n+\t\t\t}\n+\t\t\tif _, err := io.WriteString(c.W, s); err != nil {\n+\t\t\t\treturn n, err\n+\t\t\t}\n+\t\t\tc.wroteSlashes = true\n+\t\t}\n+\t\tn0, err := c.W.Write(p[i : i+1])\n+\t\tn += n0\n+\t\tif err != nil {\n+\t\t\treturn n, err\n+\t\t}\n+\t\tif b == '\\n' {\n+\t\t\tc.wroteSlashes = false\n+\t\t}\n+\t}\n+\treturn len(p), nil\n+}\n+\n+// An errWriter wraps a writer, recording whether a write error occurred.\n+type errWriter struct {\n+\tw   io.Writer\n+\terr error\n+}\n+\n+func (w *errWriter) Write(b []byte) (int, error) {\n+\tn, err := w.w.Write(b)\n+\tif err != nil {\n+\t\tw.err = err\n+\t}\n+\treturn n, err\n+}\n+\n+// tmpl executes the given template text on data, writing the result to w.\n+func tmpl(w io.Writer, text string, data interface{}) {\n+\tt := template.New(\"top\")\n+\tt.Funcs(template.FuncMap{\"trim\": strings.TrimSpace, \"capitalize\": capitalize})\n+\ttemplate.Must(t.Parse(text))\n+\tew := &errWriter{w: w}\n+\terr := t.Execute(ew, data)\n+\tif ew.err != nil {\n+\t\t// I/O error writing. Ignore write on closed pipe.\n+\t\tif strings.Contains(ew.err.Error(), \"pipe\") {\n+\t\t\tos.Exit(1)\n+\t\t}\n+\t\tbase.Fatalf(\"writing output: %v\", ew.err)\n+\t}\n+\tif err != nil {\n+\t\tpanic(err)\n+\t}\n+}\n+\n+func capitalize(s string) string {\n+\tif s == \"\" {\n+\t\treturn s\n+\t}\n+\tr, n := utf8.DecodeRuneInString(s)\n+\treturn string(unicode.ToTitle(r)) + s[n:]\n+}\n+\n+func PrintUsage(w io.Writer) {\n+\tbw := bufio.NewWriter(w)\n+\ttmpl(bw, usageTemplate, base.Commands)\n+\tbw.Flush()\n+}"}, {"sha": "516fff3528e3987d42f1e381845b77ed034a5cbd", "filename": "libgo/go/cmd/go/internal/help/helpdoc.go", "status": "renamed", "additions": 42, "deletions": 29, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fhelp%2Fhelpdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fhelp%2Fhelpdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fhelp%2Fhelpdoc.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -2,31 +2,33 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-package main\n+package help\n \n-var helpC = &Command{\n+import \"cmd/go/internal/base\"\n+\n+var HelpC = &base.Command{\n \tUsageLine: \"c\",\n \tShort:     \"calling between Go and C\",\n \tLong: `\n There are two different ways to call between Go and C/C++ code.\n \n-The first is the cgo tool, which is part of the Go distribution.  For\n+The first is the cgo tool, which is part of the Go distribution. For\n information on how to use it see the cgo documentation (go doc cmd/cgo).\n \n The second is the SWIG program, which is a general tool for\n-interfacing between languages.  For information on SWIG see\n-http://swig.org/.  When running go build, any file with a .swig\n-extension will be passed to SWIG.  Any file with a .swigcxx extension\n+interfacing between languages. For information on SWIG see\n+http://swig.org/. When running go build, any file with a .swig\n+extension will be passed to SWIG. Any file with a .swigcxx extension\n will be passed to SWIG with the -c++ option.\n \n When either cgo or SWIG is used, go build will pass any .c, .m, .s,\n or .S files to the C compiler, and any .cc, .cpp, .cxx files to the C++\n-compiler.  The CC or CXX environment variables may be set to determine\n+compiler. The CC or CXX environment variables may be set to determine\n the C or C++ compiler, respectively, to use.\n \t`,\n }\n \n-var helpPackages = &Command{\n+var HelpPackages = &base.Command{\n \tUsageLine: \"packages\",\n \tShort:     \"description of package lists\",\n \tLong: `\n@@ -67,17 +69,28 @@ the Go repository.\n \n An import path is a pattern if it includes one or more \"...\" wildcards,\n each of which can match any string, including the empty string and\n-strings containing slashes.  Such a pattern expands to all package\n+strings containing slashes. Such a pattern expands to all package\n directories found in the GOPATH trees with names matching the\n-patterns.  As a special case, x/... matches x as well as x's subdirectories.\n-For example, net/... expands to net and packages in its subdirectories.\n+patterns.\n+\n+To make common patterns more convenient, there are two special cases.\n+First, /... at the end of the pattern can match an empty string,\n+so that net/... matches both net and packages in its subdirectories, like net/http.\n+Second, any slash-separated pattern element containing a wildcard never\n+participates in a match of the \"vendor\" element in the path of a vendored\n+package, so that ./... does not match packages in subdirectories of\n+./vendor or ./mycode/vendor, but ./vendor/... and ./mycode/vendor/... do.\n+Note, however, that a directory named vendor that itself contains code\n+is not a vendored package: cmd/vendor would be a command named vendor,\n+and the pattern cmd/... matches it.\n+See golang.org/s/go15vendor for more about vendoring.\n \n An import path can also name a package to be downloaded from\n-a remote repository.  Run 'go help importpath' for details.\n+a remote repository. Run 'go help importpath' for details.\n \n Every package in a program must have a unique import path.\n By convention, this is arranged by starting each path with a\n-unique prefix that belongs to you.  For example, paths used\n+unique prefix that belongs to you. For example, paths used\n internally at Google all begin with 'google', and paths\n denoting remote repositories begin with the path to the code,\n such as 'github.com/user/repo'.\n@@ -100,13 +113,13 @@ by the go tool, as are directories named \"testdata\".\n \t`,\n }\n \n-var helpImportPath = &Command{\n+var HelpImportPath = &base.Command{\n \tUsageLine: \"importpath\",\n \tShort:     \"import path syntax\",\n \tLong: `\n \n An import path (see 'go help packages') denotes a package stored in the local\n-file system.  In general, an import path denotes either a standard package (such\n+file system. In general, an import path denotes either a standard package (such\n as \"unicode/utf8\") or a package found in one of the work spaces (For more\n details see: 'go help gopath').\n \n@@ -177,7 +190,7 @@ To declare the code location, an import path of the form\n \n specifies the given repository, with or without the .vcs suffix,\n using the named version control system, and then the path inside\n-that repository.  The supported version control systems are:\n+that repository. The supported version control systems are:\n \n \tBazaar      .bzr\n \tGit         .git\n@@ -197,7 +210,7 @@ denotes the foo/bar directory of the Git repository at\n example.org/repo or repo.git.\n \n When a version control system supports multiple protocols,\n-each is tried in turn when downloading.  For example, a Git\n+each is tried in turn when downloading. For example, a Git\n download tries https://, then git+ssh://.\n \n By default, downloads are restricted to known secure protocols\n@@ -277,7 +290,7 @@ See https://golang.org/s/go14customimport for details.\n \t`,\n }\n \n-var helpGopath = &Command{\n+var HelpGopath = &base.Command{\n \tUsageLine: \"gopath\",\n \tShort:     \"GOPATH environment variable\",\n \tLong: `\n@@ -299,7 +312,7 @@ See https://golang.org/wiki/SettingGOPATH to set a custom GOPATH.\n \n Each directory listed in GOPATH must have a prescribed structure:\n \n-The src directory holds source code.  The path below src\n+The src directory holds source code. The path below src\n determines the import path or executable name.\n \n The pkg directory holds installed package objects.\n@@ -313,11 +326,11 @@ has its compiled form installed to \"DIR/pkg/GOOS_GOARCH/foo/bar.a\".\n \n The bin directory holds compiled commands.\n Each command is named for its source directory, but only\n-the final element, not the entire path.  That is, the\n+the final element, not the entire path. That is, the\n command with source in DIR/src/foo/quux is installed into\n-DIR/bin/quux, not DIR/bin/foo/quux.  The \"foo/\" prefix is stripped\n+DIR/bin/quux, not DIR/bin/foo/quux. The \"foo/\" prefix is stripped\n so that you can add DIR/bin to your PATH to get at the\n-installed commands.  If the GOBIN environment variable is\n+installed commands. If the GOBIN environment variable is\n set, commands are installed to the directory it names instead\n of DIR/bin. GOBIN must be an absolute path.\n \n@@ -429,7 +442,7 @@ See https://golang.org/s/go15vendor for details.\n \t`,\n }\n \n-var helpEnvironment = &Command{\n+var HelpEnvironment = &base.Command{\n \tUsageLine: \"environment\",\n \tShort:     \"environment variables\",\n \tLong: `\n@@ -464,7 +477,7 @@ Environment variables for use with cgo:\n \tCC\n \t\tThe command to use to compile C code.\n \tCGO_ENABLED\n-\t\tWhether the cgo command is supported.  Either 0 or 1.\n+\t\tWhether the cgo command is supported. Either 0 or 1.\n \tCGO_CFLAGS\n \t\tFlags that cgo will pass to the compiler when compiling\n \t\tC code.\n@@ -514,7 +527,7 @@ Special-purpose environment variables:\n \t`,\n }\n \n-var helpFileType = &Command{\n+var HelpFileType = &base.Command{\n \tUsageLine: \"filetype\",\n \tShort:     \"file types\",\n \tLong: `\n@@ -560,7 +573,7 @@ for more details.\n \t`,\n }\n \n-var helpBuildmode = &Command{\n+var HelpBuildmode = &base.Command{\n \tUsageLine: \"buildmode\",\n \tShort:     \"description of build modes\",\n \tLong: `\n@@ -579,10 +592,10 @@ are:\n \t\texactly one main package to be listed.\n \n \t-buildmode=c-shared\n-\t\tBuild the listed main packages, plus all packages that they\n-\t\timport, into C shared libraries. The only callable symbols will\n+\t\tBuild the listed main package, plus all packages it imports,\n+\t\tinto a C shared library. The only callable symbols will\n \t\tbe those functions exported using a cgo //export comment.\n-\t\tNon-main packages are ignored.\n+\t\tRequires exactly one main package to be listed.\n \n \t-buildmode=default\n \t\tListed main packages are built into executables and listed", "previous_filename": "libgo/go/cmd/go/help.go"}, {"sha": "68d691ebe2eeccd0e7f16ca8528204d0296854e9", "filename": "libgo/go/cmd/go/internal/list/context.go", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flist%2Fcontext.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flist%2Fcontext.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flist%2Fcontext.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-package main\n+package list\n \n import (\n \t\"go/build\"", "previous_filename": "libgo/go/cmd/go/context.go"}, {"sha": "241d0894c01431eb2169924f4087b6d9dc2a53fd", "filename": "libgo/go/cmd/go/internal/list/list.go", "status": "renamed", "additions": 31, "deletions": 25, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flist%2Flist.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flist%2Flist.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flist%2Flist.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -2,7 +2,8 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-package main\n+// Package list implements the ``go list'' command.\n+package list\n \n import (\n \t\"bufio\"\n@@ -11,9 +12,14 @@ import (\n \t\"os\"\n \t\"strings\"\n \t\"text/template\"\n+\n+\t\"cmd/go/internal/base\"\n+\t\"cmd/go/internal/cfg\"\n+\t\"cmd/go/internal/load\"\n+\t\"cmd/go/internal/work\"\n )\n \n-var cmdList = &Command{\n+var CmdList = &base.Command{\n \tUsageLine: \"list [-e] [-f format] [-json] [build flags] [packages]\",\n \tShort:     \"list packages\",\n \tLong: `\n@@ -27,7 +33,7 @@ The default output shows the package import path:\n     golang.org/x/net/html\n \n The -f flag specifies an alternate format for the list, using the\n-syntax of package template.  The default output is equivalent to -f\n+syntax of package template. The default output is equivalent to -f\n '{{.ImportPath}}'. The struct being passed to the template is:\n \n     type Package struct {\n@@ -120,12 +126,12 @@ The -json flag causes the package data to be printed in JSON format\n instead of using the template format.\n \n The -e flag changes the handling of erroneous packages, those that\n-cannot be found or are malformed.  By default, the list command\n+cannot be found or are malformed. By default, the list command\n prints an error to standard error for each erroneous package and\n omits the packages from consideration during the usual printing.\n With the -e flag, the list command never prints errors to standard\n error and instead processes the erroneous packages with the usual\n-printing.  Erroneous packages will have a non-empty ImportPath and\n+printing. Erroneous packages will have a non-empty ImportPath and\n a non-nil Error field; other information may or may not be missing\n (zeroed).\n \n@@ -136,27 +142,27 @@ For more about specifying packages, see 'go help packages'.\n }\n \n func init() {\n-\tcmdList.Run = runList // break init cycle\n-\taddBuildFlags(cmdList)\n+\tCmdList.Run = runList // break init cycle\n+\twork.AddBuildFlags(CmdList)\n }\n \n-var listE = cmdList.Flag.Bool(\"e\", false, \"\")\n-var listFmt = cmdList.Flag.String(\"f\", \"{{.ImportPath}}\", \"\")\n-var listJson = cmdList.Flag.Bool(\"json\", false, \"\")\n+var listE = CmdList.Flag.Bool(\"e\", false, \"\")\n+var listFmt = CmdList.Flag.String(\"f\", \"{{.ImportPath}}\", \"\")\n+var listJson = CmdList.Flag.Bool(\"json\", false, \"\")\n var nl = []byte{'\\n'}\n \n-func runList(cmd *Command, args []string) {\n-\tbuildModeInit()\n+func runList(cmd *base.Command, args []string) {\n+\twork.BuildModeInit()\n \tout := newTrackingWriter(os.Stdout)\n \tdefer out.w.Flush()\n \n-\tvar do func(*Package)\n+\tvar do func(*load.PackagePublic)\n \tif *listJson {\n-\t\tdo = func(p *Package) {\n+\t\tdo = func(p *load.PackagePublic) {\n \t\t\tb, err := json.MarshalIndent(p, \"\", \"\\t\")\n \t\t\tif err != nil {\n \t\t\t\tout.Flush()\n-\t\t\t\tfatalf(\"%s\", err)\n+\t\t\t\tbase.Fatalf(\"%s\", err)\n \t\t\t}\n \t\t\tout.Write(b)\n \t\t\tout.Write(nl)\n@@ -165,7 +171,7 @@ func runList(cmd *Command, args []string) {\n \t\tvar cachedCtxt *Context\n \t\tcontext := func() *Context {\n \t\t\tif cachedCtxt == nil {\n-\t\t\t\tcachedCtxt = newContext(&buildContext)\n+\t\t\t\tcachedCtxt = newContext(&cfg.BuildContext)\n \t\t\t}\n \t\t\treturn cachedCtxt\n \t\t}\n@@ -175,30 +181,30 @@ func runList(cmd *Command, args []string) {\n \t\t}\n \t\ttmpl, err := template.New(\"main\").Funcs(fm).Parse(*listFmt)\n \t\tif err != nil {\n-\t\t\tfatalf(\"%s\", err)\n+\t\t\tbase.Fatalf(\"%s\", err)\n \t\t}\n-\t\tdo = func(p *Package) {\n+\t\tdo = func(p *load.PackagePublic) {\n \t\t\tif err := tmpl.Execute(out, p); err != nil {\n \t\t\t\tout.Flush()\n-\t\t\t\tfatalf(\"%s\", err)\n+\t\t\t\tbase.Fatalf(\"%s\", err)\n \t\t\t}\n \t\t\tif out.NeedNL() {\n \t\t\t\tout.Write(nl)\n \t\t\t}\n \t\t}\n \t}\n \n-\tload := packages\n+\tloadpkgs := load.Packages\n \tif *listE {\n-\t\tload = packagesAndErrors\n+\t\tloadpkgs = load.PackagesAndErrors\n \t}\n \n-\tfor _, pkg := range load(args) {\n+\tfor _, pkg := range loadpkgs(args) {\n \t\t// Show vendor-expanded paths in listing\n-\t\tpkg.TestImports = pkg.vendored(pkg.TestImports)\n-\t\tpkg.XTestImports = pkg.vendored(pkg.XTestImports)\n+\t\tpkg.TestImports = pkg.Vendored(pkg.TestImports)\n+\t\tpkg.XTestImports = pkg.Vendored(pkg.XTestImports)\n \n-\t\tdo(pkg)\n+\t\tdo(&pkg.PackagePublic)\n \t}\n }\n ", "previous_filename": "libgo/go/cmd/go/list.go"}, {"sha": "b8d67dac742e5a53a3db1eebaab0ef532a527d06", "filename": "libgo/go/cmd/go/internal/load/match_test.go", "status": "added", "additions": 165, "deletions": 0, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fmatch_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fmatch_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fmatch_test.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -0,0 +1,165 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package load\n+\n+import (\n+\t\"strings\"\n+\t\"testing\"\n+)\n+\n+var matchPatternTests = `\n+\tpattern ...\n+\tmatch foo\n+\t\n+\tpattern net\n+\tmatch net\n+\tnot net/http\n+\t\n+\tpattern net/http\n+\tmatch net/http\n+\tnot net\n+\t\n+\tpattern net...\n+\tmatch net net/http netchan\n+\tnot not/http not/net/http\n+\t\n+\t# Special cases. Quoting docs:\n+\n+\t# First, /... at the end of the pattern can match an empty string,\n+\t# so that net/... matches both net and packages in its subdirectories, like net/http.\n+\tpattern net/...\n+\tmatch net net/http\n+\tnot not/http not/net/http netchan\n+\n+\t# Second, any slash-separted pattern element containing a wildcard never\n+\t# participates in a match of the \"vendor\" element in the path of a vendored\n+\t# package, so that ./... does not match packages in subdirectories of\n+\t# ./vendor or ./mycode/vendor, but ./vendor/... and ./mycode/vendor/... do.\n+\t# Note, however, that a directory named vendor that itself contains code\n+\t# is not a vendored package: cmd/vendor would be a command named vendor,\n+\t# and the pattern cmd/... matches it.\n+\tpattern ./...\n+\tmatch ./vendor ./mycode/vendor\n+\tnot ./vendor/foo ./mycode/vendor/foo\n+\t\n+\tpattern ./vendor/...\n+\tmatch ./vendor/foo ./vendor/foo/vendor\n+\tnot ./vendor/foo/vendor/bar\n+\t\n+\tpattern mycode/vendor/...\n+\tmatch mycode/vendor mycode/vendor/foo mycode/vendor/foo/vendor\n+\tnot mycode/vendor/foo/vendor/bar\n+\t\n+\tpattern x/vendor/y\n+\tmatch x/vendor/y\n+\tnot x/vendor\n+\t\n+\tpattern x/vendor/y/...\n+\tmatch x/vendor/y x/vendor/y/z x/vendor/y/vendor x/vendor/y/z/vendor\n+\tnot x/vendor/y/vendor/z\n+\t\n+\tpattern .../vendor/...\n+\tmatch x/vendor/y x/vendor/y/z x/vendor/y/vendor x/vendor/y/z/vendor\n+`\n+\n+func TestMatchPattern(t *testing.T) {\n+\ttestPatterns(t, \"matchPattern\", matchPatternTests, func(pattern, name string) bool {\n+\t\treturn matchPattern(pattern)(name)\n+\t})\n+}\n+\n+var treeCanMatchPatternTests = `\n+\tpattern ...\n+\tmatch foo\n+\t\n+\tpattern net\n+\tmatch net\n+\tnot net/http\n+\t\n+\tpattern net/http\n+\tmatch net net/http\n+\t\n+\tpattern net...\n+\tmatch net netchan net/http\n+\tnot not/http not/net/http\n+\n+\tpattern net/...\n+\tmatch net net/http\n+\tnot not/http netchan\n+\t\n+\tpattern abc.../def\n+\tmatch abcxyz\n+\tnot xyzabc\n+\t\n+\tpattern x/y/z/...\n+\tmatch x x/y x/y/z x/y/z/w\n+\t\n+\tpattern x/y/z\n+\tmatch x x/y x/y/z\n+\tnot x/y/z/w\n+\t\n+\tpattern x/.../y/z\n+\tmatch x/a/b/c\n+\tnot y/x/a/b/c\n+`\n+\n+func TestTreeCanMatchPattern(t *testing.T) {\n+\ttestPatterns(t, \"treeCanMatchPattern\", treeCanMatchPatternTests, func(pattern, name string) bool {\n+\t\treturn treeCanMatchPattern(pattern)(name)\n+\t})\n+}\n+\n+var hasPathPrefixTests = []stringPairTest{\n+\t{\"abc\", \"a\", false},\n+\t{\"a/bc\", \"a\", true},\n+\t{\"a\", \"a\", true},\n+\t{\"a/bc\", \"a/\", true},\n+}\n+\n+func TestHasPathPrefix(t *testing.T) {\n+\ttestStringPairs(t, \"hasPathPrefix\", hasPathPrefixTests, hasPathPrefix)\n+}\n+\n+type stringPairTest struct {\n+\tin1 string\n+\tin2 string\n+\tout bool\n+}\n+\n+func testStringPairs(t *testing.T, name string, tests []stringPairTest, f func(string, string) bool) {\n+\tfor _, tt := range tests {\n+\t\tif out := f(tt.in1, tt.in2); out != tt.out {\n+\t\t\tt.Errorf(\"%s(%q, %q) = %v, want %v\", name, tt.in1, tt.in2, out, tt.out)\n+\t\t}\n+\t}\n+}\n+\n+func testPatterns(t *testing.T, name, tests string, fn func(string, string) bool) {\n+\tvar patterns []string\n+\tfor _, line := range strings.Split(tests, \"\\n\") {\n+\t\tif i := strings.Index(line, \"#\"); i >= 0 {\n+\t\t\tline = line[:i]\n+\t\t}\n+\t\tf := strings.Fields(line)\n+\t\tif len(f) == 0 {\n+\t\t\tcontinue\n+\t\t}\n+\t\tswitch f[0] {\n+\t\tdefault:\n+\t\t\tt.Fatalf(\"unknown directive %q\", f[0])\n+\t\tcase \"pattern\":\n+\t\t\tpatterns = f[1:]\n+\t\tcase \"match\", \"not\":\n+\t\t\twant := f[0] == \"match\"\n+\t\t\tfor _, pattern := range patterns {\n+\t\t\t\tfor _, in := range f[1:] {\n+\t\t\t\t\tif fn(pattern, in) != want {\n+\t\t\t\t\t\tt.Errorf(\"%s(%q, %q) = %v, want %v\", name, pattern, in, !want, want)\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+}"}, {"sha": "9cc85dd757b62c83978cac5d3b33d04dfbeb2c43", "filename": "libgo/go/cmd/go/internal/load/path.go", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fpath.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fpath.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fpath.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -0,0 +1,80 @@\n+// Copyright 2017 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package load\n+\n+import (\n+\t\"path/filepath\"\n+\t\"strings\"\n+)\n+\n+// hasSubdir reports whether dir is a subdirectory of\n+// (possibly multiple levels below) root.\n+// If so, it sets rel to the path fragment that must be\n+// appended to root to reach dir.\n+func hasSubdir(root, dir string) (rel string, ok bool) {\n+\tif p, err := filepath.EvalSymlinks(root); err == nil {\n+\t\troot = p\n+\t}\n+\tif p, err := filepath.EvalSymlinks(dir); err == nil {\n+\t\tdir = p\n+\t}\n+\tconst sep = string(filepath.Separator)\n+\troot = filepath.Clean(root)\n+\tif !strings.HasSuffix(root, sep) {\n+\t\troot += sep\n+\t}\n+\tdir = filepath.Clean(dir)\n+\tif !strings.HasPrefix(dir, root) {\n+\t\treturn \"\", false\n+\t}\n+\treturn filepath.ToSlash(dir[len(root):]), true\n+}\n+\n+// hasPathPrefix reports whether the path s begins with the\n+// elements in prefix.\n+func hasPathPrefix(s, prefix string) bool {\n+\tswitch {\n+\tdefault:\n+\t\treturn false\n+\tcase len(s) == len(prefix):\n+\t\treturn s == prefix\n+\tcase len(s) > len(prefix):\n+\t\tif prefix != \"\" && prefix[len(prefix)-1] == '/' {\n+\t\t\treturn strings.HasPrefix(s, prefix)\n+\t\t}\n+\t\treturn s[len(prefix)] == '/' && s[:len(prefix)] == prefix\n+\t}\n+}\n+\n+// expandPath returns the symlink-expanded form of path.\n+func expandPath(p string) string {\n+\tx, err := filepath.EvalSymlinks(p)\n+\tif err == nil {\n+\t\treturn x\n+\t}\n+\treturn p\n+}\n+\n+// hasFilePathPrefix reports whether the filesystem path s begins with the\n+// elements in prefix.\n+func hasFilePathPrefix(s, prefix string) bool {\n+\tsv := strings.ToUpper(filepath.VolumeName(s))\n+\tpv := strings.ToUpper(filepath.VolumeName(prefix))\n+\ts = s[len(sv):]\n+\tprefix = prefix[len(pv):]\n+\tswitch {\n+\tdefault:\n+\t\treturn false\n+\tcase sv != pv:\n+\t\treturn false\n+\tcase len(s) == len(prefix):\n+\t\treturn s == prefix\n+\tcase len(s) > len(prefix):\n+\t\tif prefix != \"\" && prefix[len(prefix)-1] == filepath.Separator {\n+\t\t\treturn strings.HasPrefix(s, prefix)\n+\t\t}\n+\t\treturn s[len(prefix)] == filepath.Separator && s[:len(prefix)] == prefix\n+\t}\n+}"}, {"sha": "acb20fe03e4336b58596476ece9cadec171f2e8a", "filename": "libgo/go/cmd/go/internal/load/pkg.go", "status": "renamed", "additions": 403, "deletions": 482, "changes": 885, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fpkg.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fpkg.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fpkg.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -2,32 +2,38 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-package main\n+// Package load loads packages.\n+package load\n \n import (\n-\t\"bytes\"\n \t\"crypto/sha1\"\n-\t\"errors\"\n \t\"fmt\"\n \t\"go/build\"\n-\t\"go/scanner\"\n \t\"go/token\"\n-\t\"io\"\n \t\"io/ioutil\"\n \t\"os\"\n \tpathpkg \"path\"\n \t\"path/filepath\"\n \t\"runtime\"\n \t\"sort\"\n-\t\"strconv\"\n \t\"strings\"\n \t\"unicode\"\n+\n+\t\"cmd/go/internal/base\"\n+\t\"cmd/go/internal/buildid\"\n+\t\"cmd/go/internal/cfg\"\n+\t\"cmd/go/internal/str\"\n )\n \n-var ignoreImports bool // control whether we ignore imports in packages\n+var IgnoreImports bool // control whether we ignore imports in packages\n \n // A Package describes a single package found in a directory.\n type Package struct {\n+\tPackagePublic                 // visible in 'go list'\n+\tInternal      PackageInternal // for use inside go command only\n+}\n+\n+type PackagePublic struct {\n \t// Note: These fields are part of the go command's public API.\n \t// See list.go. It is okay to add fields, but not to change or\n \t// remove existing ones. Keep in sync with list.go\n@@ -82,31 +88,59 @@ type Package struct {\n \tTestImports  []string `json:\",omitempty\"` // imports from TestGoFiles\n \tXTestGoFiles []string `json:\",omitempty\"` // _test.go files outside package\n \tXTestImports []string `json:\",omitempty\"` // imports from XTestGoFiles\n+}\n \n+type PackageInternal struct {\n \t// Unexported fields are not part of the public API.\n-\tbuild        *build.Package\n-\tpkgdir       string // overrides build.PkgDir\n-\timports      []*Package\n-\tdeps         []*Package\n-\tgofiles      []string // GoFiles+CgoFiles+TestGoFiles+XTestGoFiles files, absolute paths\n-\tsfiles       []string\n-\tallgofiles   []string             // gofiles + IgnoredGoFiles, absolute paths\n-\ttarget       string               // installed file for this package (may be executable)\n-\tfake         bool                 // synthesized package\n-\texternal     bool                 // synthesized external test package\n-\tforceLibrary bool                 // this package is a library (even if named \"main\")\n-\tcmdline      bool                 // defined by files listed on command line\n-\tlocal        bool                 // imported via local path (./ or ../)\n-\tlocalPrefix  string               // interpret ./ and ../ imports relative to this prefix\n-\texeName      string               // desired name for temporary executable\n-\tcoverMode    string               // preprocess Go source files with the coverage tool in this mode\n-\tcoverVars    map[string]*CoverVar // variables created by coverage analysis\n-\tomitDWARF    bool                 // tell linker not to write DWARF information\n-\tbuildID      string               // expected build ID for generated package\n-\tgobinSubdir  bool                 // install target would be subdir of GOBIN\n+\tBuild        *build.Package\n+\tPkgdir       string // overrides build.PkgDir\n+\tImports      []*Package\n+\tDeps         []*Package\n+\tGoFiles      []string // GoFiles+CgoFiles+TestGoFiles+XTestGoFiles files, absolute paths\n+\tSFiles       []string\n+\tAllGoFiles   []string             // gofiles + IgnoredGoFiles, absolute paths\n+\tTarget       string               // installed file for this package (may be executable)\n+\tFake         bool                 // synthesized package\n+\tExternal     bool                 // synthesized external test package\n+\tForceLibrary bool                 // this package is a library (even if named \"main\")\n+\tCmdline      bool                 // defined by files listed on command line\n+\tLocal        bool                 // imported via local path (./ or ../)\n+\tLocalPrefix  string               // interpret ./ and ../ imports relative to this prefix\n+\tExeName      string               // desired name for temporary executable\n+\tCoverMode    string               // preprocess Go source files with the coverage tool in this mode\n+\tCoverVars    map[string]*CoverVar // variables created by coverage analysis\n+\tOmitDebug    bool                 // tell linker not to write debug information\n+\tBuildID      string               // expected build ID for generated package\n+\tGobinSubdir  bool                 // install target would be subdir of GOBIN\n+}\n+\n+type NoGoError struct {\n+\tPackage *Package\n+}\n+\n+func (e *NoGoError) Error() string {\n+\t// Count files beginning with _ and ., which we will pretend don't exist at all.\n+\tdummy := 0\n+\tfor _, name := range e.Package.IgnoredGoFiles {\n+\t\tif strings.HasPrefix(name, \"_\") || strings.HasPrefix(name, \".\") {\n+\t\t\tdummy++\n+\t\t}\n+\t}\n+\n+\tif len(e.Package.IgnoredGoFiles) > dummy {\n+\t\t// Go files exist, but they were ignored due to build constraints.\n+\t\treturn \"build constraints exclude all Go files in \" + e.Package.Dir\n+\t}\n+\tif len(e.Package.TestGoFiles)+len(e.Package.XTestGoFiles) > 0 {\n+\t\t// Test Go files exist, but we're not interested in them.\n+\t\t// The double-negative is unfortunate but we want e.Package.Dir\n+\t\t// to appear at the end of error message.\n+\t\treturn \"no non-test Go files in \" + e.Package.Dir\n+\t}\n+\treturn \"no Go files in \" + e.Package.Dir\n }\n \n-// vendored returns the vendor-resolved version of imports,\n+// Vendored returns the vendor-resolved version of imports,\n // which should be p.TestImports or p.XTestImports, NOT p.Imports.\n // The imports in p.TestImports and p.XTestImports are not recursively\n // loaded during the initial load of p, so they list the imports found in\n@@ -116,14 +150,14 @@ type Package struct {\n // can produce better error messages if it starts with the original paths.\n // The initial load of p loads all the non-test imports and rewrites\n // the vendored paths, so nothing should ever call p.vendored(p.Imports).\n-func (p *Package) vendored(imports []string) []string {\n+func (p *Package) Vendored(imports []string) []string {\n \tif len(imports) > 0 && len(p.Imports) > 0 && &imports[0] == &p.Imports[0] {\n \t\tpanic(\"internal error: p.vendored(p.Imports) called\")\n \t}\n \tseen := make(map[string]bool)\n \tvar all []string\n \tfor _, path := range imports {\n-\t\tpath = vendoredImportPath(p, path)\n+\t\tpath = VendoredImportPath(p, path)\n \t\tif !seen[path] {\n \t\t\tseen[path] = true\n \t\t\tall = append(all, path)\n@@ -140,13 +174,13 @@ type CoverVar struct {\n }\n \n func (p *Package) copyBuild(pp *build.Package) {\n-\tp.build = pp\n+\tp.Internal.Build = pp\n \n-\tif pp.PkgTargetRoot != \"\" && buildPkgdir != \"\" {\n+\tif pp.PkgTargetRoot != \"\" && cfg.BuildPkgdir != \"\" {\n \t\told := pp.PkgTargetRoot\n-\t\tpp.PkgRoot = buildPkgdir\n-\t\tpp.PkgTargetRoot = buildPkgdir\n-\t\tpp.PkgObj = filepath.Join(buildPkgdir, strings.TrimPrefix(pp.PkgObj, old))\n+\t\tpp.PkgRoot = cfg.BuildPkgdir\n+\t\tpp.PkgTargetRoot = cfg.BuildPkgdir\n+\t\tpp.PkgObj = filepath.Join(cfg.BuildPkgdir, strings.TrimPrefix(pp.PkgObj, old))\n \t}\n \n \tp.Dir = pp.Dir\n@@ -160,10 +194,9 @@ func (p *Package) copyBuild(pp *build.Package) {\n \n \t// TODO? Target\n \tp.Goroot = pp.Goroot\n-\tif buildContext.Compiler == \"gccgo\" {\n+\tp.Standard = p.Goroot && p.ImportPath != \"\" && isStandardImportPath(p.ImportPath)\n+\tif cfg.BuildToolchainName == \"gccgo\" {\n \t\tp.Standard = stdpkg[p.ImportPath]\n-\t} else {\n-\t\tp.Standard = p.Goroot && p.ImportPath != \"\" && isStandardImportPath(p.ImportPath)\n \t}\n \tp.GoFiles = pp.GoFiles\n \tp.CgoFiles = pp.CgoFiles\n@@ -180,6 +213,7 @@ func (p *Package) copyBuild(pp *build.Package) {\n \tp.CgoCFLAGS = pp.CgoCFLAGS\n \tp.CgoCPPFLAGS = pp.CgoCPPFLAGS\n \tp.CgoCXXFLAGS = pp.CgoCXXFLAGS\n+\tp.CgoFFLAGS = pp.CgoFFLAGS\n \tp.CgoLDFLAGS = pp.CgoLDFLAGS\n \tp.CgoPkgConfig = pp.CgoPkgConfig\n \t// We modify p.Imports in place, so make copy now.\n@@ -189,7 +223,7 @@ func (p *Package) copyBuild(pp *build.Package) {\n \tp.TestImports = pp.TestImports\n \tp.XTestGoFiles = pp.XTestGoFiles\n \tp.XTestImports = pp.XTestImports\n-\tif ignoreImports {\n+\tif IgnoreImports {\n \t\tp.Imports = nil\n \t\tp.TestImports = nil\n \t\tp.XTestImports = nil\n@@ -214,13 +248,13 @@ type PackageError struct {\n \tImportStack   []string // shortest path from package named on command line to this one\n \tPos           string   // position of error\n \tErr           string   // the error itself\n-\tisImportCycle bool     // the error is an import cycle\n-\thard          bool     // whether the error is soft or hard; soft errors are ignored in some places\n+\tIsImportCycle bool     `json:\"-\"` // the error is an import cycle\n+\tHard          bool     `json:\"-\"` // whether the error is soft or hard; soft errors are ignored in some places\n }\n \n func (p *PackageError) Error() string {\n \t// Import cycles deserve special treatment.\n-\tif p.isImportCycle {\n+\tif p.IsImportCycle {\n \t\treturn fmt.Sprintf(\"%s\\npackage %s\\n\", p.Err, strings.Join(p.ImportStack, \"\\n\\timports \"))\n \t}\n \tif p.Pos != \"\" {\n@@ -234,25 +268,25 @@ func (p *PackageError) Error() string {\n \treturn \"package \" + strings.Join(p.ImportStack, \"\\n\\timports \") + \": \" + p.Err\n }\n \n-// An importStack is a stack of import paths.\n-type importStack []string\n+// An ImportStack is a stack of import paths.\n+type ImportStack []string\n \n-func (s *importStack) push(p string) {\n+func (s *ImportStack) Push(p string) {\n \t*s = append(*s, p)\n }\n \n-func (s *importStack) pop() {\n+func (s *ImportStack) Pop() {\n \t*s = (*s)[0 : len(*s)-1]\n }\n \n-func (s *importStack) copy() []string {\n+func (s *ImportStack) Copy() []string {\n \treturn append([]string{}, *s...)\n }\n \n // shorterThan reports whether sp is shorter than t.\n // We use this to record the shortest import sequence\n // that leads to a particular package.\n-func (sp *importStack) shorterThan(t []string) bool {\n+func (sp *ImportStack) shorterThan(t []string) bool {\n \ts := *sp\n \tif len(s) != len(t) {\n \t\treturn len(s) < len(t)\n@@ -271,15 +305,31 @@ func (sp *importStack) shorterThan(t []string) bool {\n // we return the same pointer each time.\n var packageCache = map[string]*Package{}\n \n+func ClearPackageCache() {\n+\tfor name := range packageCache {\n+\t\tdelete(packageCache, name)\n+\t}\n+}\n+\n+func ClearPackageCachePartial(args []string) {\n+\tfor _, arg := range args {\n+\t\tp := packageCache[arg]\n+\t\tif p != nil {\n+\t\t\tdelete(packageCache, p.Dir)\n+\t\t\tdelete(packageCache, p.ImportPath)\n+\t\t}\n+\t}\n+}\n+\n // reloadPackage is like loadPackage but makes sure\n // not to use the package cache.\n-func reloadPackage(arg string, stk *importStack) *Package {\n+func ReloadPackage(arg string, stk *ImportStack) *Package {\n \tp := packageCache[arg]\n \tif p != nil {\n \t\tdelete(packageCache, p.Dir)\n \t\tdelete(packageCache, p.ImportPath)\n \t}\n-\treturn loadPackage(arg, stk)\n+\treturn LoadPackage(arg, stk)\n }\n \n // dirToImportPath returns the pseudo-import path we use for a package\n@@ -313,20 +363,20 @@ const (\n \t// recorded as the canonical import path. At that point, future loads\n \t// of that package must not pass useVendor, because\n \t// disallowVendor will reject direct use of paths containing /vendor/.\n-\tuseVendor = 1 << iota\n+\tUseVendor = 1 << iota\n \n \t// getTestDeps is for download (part of \"go get\") and indicates\n \t// that test dependencies should be fetched too.\n-\tgetTestDeps\n+\tGetTestDeps\n )\n \n // loadImport scans the directory named by path, which must be an import path,\n // but possibly a local import path (an absolute file system path or one beginning\n-// with ./ or ../).  A local relative path is interpreted relative to srcDir.\n+// with ./ or ../). A local relative path is interpreted relative to srcDir.\n // It returns a *Package describing the package found in that directory.\n-func loadImport(path, srcDir string, parent *Package, stk *importStack, importPos []token.Position, mode int) *Package {\n-\tstk.push(path)\n-\tdefer stk.pop()\n+func LoadImport(path, srcDir string, parent *Package, stk *ImportStack, importPos []token.Position, mode int) *Package {\n+\tstk.Push(path)\n+\tdefer stk.Pop()\n \n \t// Determine canonical identifier for this package.\n \t// For a local import the identifier is the pseudo-import path\n@@ -338,12 +388,12 @@ func loadImport(path, srcDir string, parent *Package, stk *importStack, importPo\n \tisLocal := build.IsLocalImport(path)\n \tif isLocal {\n \t\timportPath = dirToImportPath(filepath.Join(srcDir, path))\n-\t} else if mode&useVendor != 0 {\n+\t} else if mode&UseVendor != 0 {\n \t\t// We do our own vendor resolution, because we want to\n \t\t// find out the key to use in packageCache without the\n \t\t// overhead of repeated calls to buildContext.Import.\n \t\t// The code is also needed in a few other places anyway.\n-\t\tpath = vendoredImportPath(parent, path)\n+\t\tpath = VendoredImportPath(parent, path)\n \t\timportPath = path\n \t}\n \n@@ -352,7 +402,7 @@ func loadImport(path, srcDir string, parent *Package, stk *importStack, importPo\n \t\tp = reusePackage(p, stk)\n \t} else {\n \t\tp = new(Package)\n-\t\tp.local = isLocal\n+\t\tp.Internal.Local = isLocal\n \t\tp.ImportPath = importPath\n \t\tpackageCache[importPath] = p\n \n@@ -363,14 +413,14 @@ func loadImport(path, srcDir string, parent *Package, stk *importStack, importPo\n \t\t// TODO: After Go 1, decide when to pass build.AllowBinary here.\n \t\t// See issue 3268 for mistakes to avoid.\n \t\tbuildMode := build.ImportComment\n-\t\tif mode&useVendor == 0 || path != origPath {\n+\t\tif mode&UseVendor == 0 || path != origPath {\n \t\t\t// Not vendoring, or we already found the vendored path.\n \t\t\tbuildMode |= build.IgnoreVendor\n \t\t}\n-\t\tbp, err := buildContext.Import(path, srcDir, buildMode)\n+\t\tbp, err := cfg.BuildContext.Import(path, srcDir, buildMode)\n \t\tbp.ImportPath = importPath\n-\t\tif gobin != \"\" {\n-\t\t\tbp.BinDir = gobin\n+\t\tif cfg.GOBIN != \"\" {\n+\t\t\tbp.BinDir = cfg.GOBIN\n \t\t}\n \t\tif err == nil && !isLocal && bp.ImportComment != \"\" && bp.ImportComment != path &&\n \t\t\t!strings.Contains(path, \"/vendor/\") && !strings.HasPrefix(path, \"vendor/\") {\n@@ -383,7 +433,7 @@ func loadImport(path, srcDir string, parent *Package, stk *importStack, importPo\n \n \t\tif origPath != cleanImport(origPath) {\n \t\t\tp.Error = &PackageError{\n-\t\t\t\tImportStack: stk.copy(),\n+\t\t\t\tImportStack: stk.Copy(),\n \t\t\t\tErr:         fmt.Sprintf(\"non-canonical import path: %q should be %q\", origPath, pathpkg.Clean(origPath)),\n \t\t\t}\n \t\t\tp.Incomplete = true\n@@ -394,7 +444,7 @@ func loadImport(path, srcDir string, parent *Package, stk *importStack, importPo\n \tif perr := disallowInternal(srcDir, p, stk); perr != p {\n \t\treturn setErrorPos(perr, importPos)\n \t}\n-\tif mode&useVendor != 0 {\n+\tif mode&UseVendor != 0 {\n \t\tif perr := disallowVendor(srcDir, origPath, p, stk); perr != p {\n \t\t\treturn setErrorPos(perr, importPos)\n \t\t}\n@@ -403,16 +453,16 @@ func loadImport(path, srcDir string, parent *Package, stk *importStack, importPo\n \tif p.Name == \"main\" && parent != nil && parent.Dir != p.Dir {\n \t\tperr := *p\n \t\tperr.Error = &PackageError{\n-\t\t\tImportStack: stk.copy(),\n+\t\t\tImportStack: stk.Copy(),\n \t\t\tErr:         fmt.Sprintf(\"import %q is a program, not an importable package\", path),\n \t\t}\n \t\treturn setErrorPos(&perr, importPos)\n \t}\n \n-\tif p.local && parent != nil && !parent.local {\n+\tif p.Internal.Local && parent != nil && !parent.Internal.Local {\n \t\tperr := *p\n \t\tperr.Error = &PackageError{\n-\t\t\tImportStack: stk.copy(),\n+\t\t\tImportStack: stk.Copy(),\n \t\t\tErr:         fmt.Sprintf(\"local import %q in non-local package\", path),\n \t\t}\n \t\treturn setErrorPos(&perr, importPos)\n@@ -424,7 +474,7 @@ func loadImport(path, srcDir string, parent *Package, stk *importStack, importPo\n func setErrorPos(p *Package, importPos []token.Position) *Package {\n \tif len(importPos) > 0 {\n \t\tpos := importPos[0]\n-\t\tpos.Filename = shortPath(pos.Filename)\n+\t\tpos.Filename = base.ShortPath(pos.Filename)\n \t\tp.Error.Pos = pos.String()\n \t}\n \treturn p\n@@ -453,11 +503,11 @@ func isDir(path string) bool {\n \treturn result\n }\n \n-// vendoredImportPath returns the expansion of path when it appears in parent.\n+// VendoredImportPath returns the expansion of path when it appears in parent.\n // If parent is x/y/z, then path might expand to x/y/z/vendor/path, x/y/vendor/path,\n // x/vendor/path, vendor/path, or else stay path if none of those exist.\n-// vendoredImportPath returns the expanded path or, if no expansion is found, the original.\n-func vendoredImportPath(parent *Package, path string) (found string) {\n+// VendoredImportPath returns the expanded path or, if no expansion is found, the original.\n+func VendoredImportPath(parent *Package, path string) (found string) {\n \tif parent == nil || parent.Root == \"\" {\n \t\treturn path\n \t}\n@@ -470,8 +520,8 @@ func vendoredImportPath(parent *Package, path string) (found string) {\n \t\troot = expandPath(root)\n \t}\n \n-\tif !hasFilePathPrefix(dir, root) || len(dir) <= len(root) || dir[len(root)] != filepath.Separator || parent.ImportPath != \"command-line-arguments\" && !parent.local && filepath.Join(root, parent.ImportPath) != dir {\n-\t\tfatalf(\"unexpected directory layout:\\n\"+\n+\tif !hasFilePathPrefix(dir, root) || len(dir) <= len(root) || dir[len(root)] != filepath.Separator || parent.ImportPath != \"command-line-arguments\" && !parent.Internal.Local && filepath.Join(root, parent.ImportPath) != dir {\n+\t\tbase.Fatalf(\"unexpected directory layout:\\n\"+\n \t\t\t\"\timport path: %s\\n\"+\n \t\t\t\"\troot: %s\\n\"+\n \t\t\t\"\tdir: %s\\n\"+\n@@ -545,32 +595,32 @@ func hasGoFiles(dir string) bool {\n // reusePackage reuses package p to satisfy the import at the top\n // of the import stack stk. If this use causes an import loop,\n // reusePackage updates p's error information to record the loop.\n-func reusePackage(p *Package, stk *importStack) *Package {\n-\t// We use p.imports==nil to detect a package that\n+func reusePackage(p *Package, stk *ImportStack) *Package {\n+\t// We use p.Internal.Imports==nil to detect a package that\n \t// is in the midst of its own loadPackage call\n-\t// (all the recursion below happens before p.imports gets set).\n-\tif p.imports == nil {\n+\t// (all the recursion below happens before p.Internal.Imports gets set).\n+\tif p.Internal.Imports == nil {\n \t\tif p.Error == nil {\n \t\t\tp.Error = &PackageError{\n-\t\t\t\tImportStack:   stk.copy(),\n+\t\t\t\tImportStack:   stk.Copy(),\n \t\t\t\tErr:           \"import cycle not allowed\",\n-\t\t\t\tisImportCycle: true,\n+\t\t\t\tIsImportCycle: true,\n \t\t\t}\n \t\t}\n \t\tp.Incomplete = true\n \t}\n \t// Don't rewrite the import stack in the error if we have an import cycle.\n \t// If we do, we'll lose the path that describes the cycle.\n-\tif p.Error != nil && !p.Error.isImportCycle && stk.shorterThan(p.Error.ImportStack) {\n-\t\tp.Error.ImportStack = stk.copy()\n+\tif p.Error != nil && !p.Error.IsImportCycle && stk.shorterThan(p.Error.ImportStack) {\n+\t\tp.Error.ImportStack = stk.Copy()\n \t}\n \treturn p\n }\n \n // disallowInternal checks that srcDir is allowed to import p.\n // If the import is allowed, disallowInternal returns the original package p.\n // If not, it returns a new package containing just an appropriate error.\n-func disallowInternal(srcDir string, p *Package, stk *importStack) *Package {\n+func disallowInternal(srcDir string, p *Package, stk *ImportStack) *Package {\n \t// golang.org/s/go14internal:\n \t// An import of a path containing the element \u201cinternal\u201d\n \t// is disallowed if the importing code is outside the tree\n@@ -590,7 +640,7 @@ func disallowInternal(srcDir string, p *Package, stk *importStack) *Package {\n \t}\n \n \t// We can't check standard packages with gccgo.\n-\tif buildContext.Compiler == \"gccgo\" && p.Standard {\n+\tif cfg.BuildContext.Compiler == \"gccgo\" && p.Standard {\n \t\treturn p\n \t}\n \n@@ -628,7 +678,7 @@ func disallowInternal(srcDir string, p *Package, stk *importStack) *Package {\n \t// Internal is present, and srcDir is outside parent's tree. Not allowed.\n \tperr := *p\n \tperr.Error = &PackageError{\n-\t\tImportStack: stk.copy(),\n+\t\tImportStack: stk.Copy(),\n \t\tErr:         \"use of internal package not allowed\",\n \t}\n \tperr.Incomplete = true\n@@ -657,7 +707,7 @@ func findInternal(path string) (index int, ok bool) {\n // disallowVendor checks that srcDir is allowed to import p as path.\n // If the import is allowed, disallowVendor returns the original package p.\n // If not, it returns a new package containing just an appropriate error.\n-func disallowVendor(srcDir, path string, p *Package, stk *importStack) *Package {\n+func disallowVendor(srcDir, path string, p *Package, stk *ImportStack) *Package {\n \t// The stack includes p.ImportPath.\n \t// If that's the only thing on the stack, we started\n \t// with a name given on the command line, not an\n@@ -671,10 +721,10 @@ func disallowVendor(srcDir, path string, p *Package, stk *importStack) *Package\n \t}\n \n \t// Paths like x/vendor/y must be imported as y, never as x/vendor/y.\n-\tif i, ok := findVendor(path); ok {\n+\tif i, ok := FindVendor(path); ok {\n \t\tperr := *p\n \t\tperr.Error = &PackageError{\n-\t\t\tImportStack: stk.copy(),\n+\t\t\tImportStack: stk.Copy(),\n \t\t\tErr:         \"must be imported as \" + path[i+len(\"vendor/\"):],\n \t\t}\n \t\tperr.Incomplete = true\n@@ -689,7 +739,7 @@ func disallowVendor(srcDir, path string, p *Package, stk *importStack) *Package\n // is not subject to the rules, only subdirectories of vendor.\n // This allows people to have packages and commands named vendor,\n // for maximal compatibility with existing source trees.\n-func disallowVendorVisibility(srcDir string, p *Package, stk *importStack) *Package {\n+func disallowVendorVisibility(srcDir string, p *Package, stk *ImportStack) *Package {\n \t// The stack includes p.ImportPath.\n \t// If that's the only thing on the stack, we started\n \t// with a name given on the command line, not an\n@@ -699,7 +749,7 @@ func disallowVendorVisibility(srcDir string, p *Package, stk *importStack) *Pack\n \t}\n \n \t// Check for \"vendor\" element.\n-\ti, ok := findVendor(p.ImportPath)\n+\ti, ok := FindVendor(p.ImportPath)\n \tif !ok {\n \t\treturn p\n \t}\n@@ -728,22 +778,22 @@ func disallowVendorVisibility(srcDir string, p *Package, stk *importStack) *Pack\n \t// Vendor is present, and srcDir is outside parent's tree. Not allowed.\n \tperr := *p\n \tperr.Error = &PackageError{\n-\t\tImportStack: stk.copy(),\n+\t\tImportStack: stk.Copy(),\n \t\tErr:         \"use of vendored package not allowed\",\n \t}\n \tperr.Incomplete = true\n \treturn &perr\n }\n \n-// findVendor looks for the last non-terminating \"vendor\" path element in the given import path.\n-// If there isn't one, findVendor returns ok=false.\n-// Otherwise, findVendor returns ok=true and the index of the \"vendor\".\n+// FindVendor looks for the last non-terminating \"vendor\" path element in the given import path.\n+// If there isn't one, FindVendor returns ok=false.\n+// Otherwise, FindVendor returns ok=true and the index of the \"vendor\".\n //\n // Note that terminating \"vendor\" elements don't count: \"x/vendor\" is its own package,\n // not the vendored copy of an import \"\" (the empty import path).\n // This will allow people to have packages or commands named vendor.\n // This may help reduce breakage, or it may just be confusing. We'll see.\n-func findVendor(path string) (index int, ok bool) {\n+func FindVendor(path string) (index int, ok bool) {\n \t// Two cases, depending on internal at start of string or not.\n \t// The order matters: we must return the index of the final element,\n \t// because the final one is where the effective import path starts.\n@@ -759,54 +809,33 @@ func findVendor(path string) (index int, ok bool) {\n type targetDir int\n \n const (\n-\ttoRoot    targetDir = iota // to bin dir inside package root (default)\n-\ttoTool                     // GOROOT/pkg/tool\n-\tstalePath                  // the old import path; fail to build\n+\tToRoot    targetDir = iota // to bin dir inside package root (default)\n+\tToTool                     // GOROOT/pkg/tool\n+\tStalePath                  // the old import path; fail to build\n )\n \n // goTools is a map of Go program import path to install target directory.\n-var goTools = map[string]targetDir{\n-\t\"cmd/addr2line\": toTool,\n-\t\"cmd/api\":       toTool,\n-\t\"cmd/asm\":       toTool,\n-\t\"cmd/compile\":   toTool,\n-\t\"cmd/cgo\":       toTool,\n-\t\"cmd/cover\":     toTool,\n-\t\"cmd/dist\":      toTool,\n-\t\"cmd/doc\":       toTool,\n-\t\"cmd/fix\":       toTool,\n-\t\"cmd/link\":      toTool,\n-\t\"cmd/newlink\":   toTool,\n-\t\"cmd/nm\":        toTool,\n-\t\"cmd/objdump\":   toTool,\n-\t\"cmd/pack\":      toTool,\n-\t\"cmd/pprof\":     toTool,\n-\t\"cmd/trace\":     toTool,\n-\t\"cmd/vet\":       toTool,\n-\t\"code.google.com/p/go.tools/cmd/cover\": stalePath,\n-\t\"code.google.com/p/go.tools/cmd/godoc\": stalePath,\n-\t\"code.google.com/p/go.tools/cmd/vet\":   stalePath,\n-}\n-\n-// expandScanner expands a scanner.List error into all the errors in the list.\n-// The default Error method only shows the first error.\n-func expandScanner(err error) error {\n-\t// Look for parser errors.\n-\tif err, ok := err.(scanner.ErrorList); ok {\n-\t\t// Prepare error with \\n before each message.\n-\t\t// When printed in something like context: %v\n-\t\t// this will put the leading file positions each on\n-\t\t// its own line. It will also show all the errors\n-\t\t// instead of just the first, as err.Error does.\n-\t\tvar buf bytes.Buffer\n-\t\tfor _, e := range err {\n-\t\t\te.Pos.Filename = shortPath(e.Pos.Filename)\n-\t\t\tbuf.WriteString(\"\\n\")\n-\t\t\tbuf.WriteString(e.Error())\n-\t\t}\n-\t\treturn errors.New(buf.String())\n-\t}\n-\treturn err\n+var GoTools = map[string]targetDir{\n+\t\"cmd/addr2line\": ToTool,\n+\t\"cmd/api\":       ToTool,\n+\t\"cmd/asm\":       ToTool,\n+\t\"cmd/compile\":   ToTool,\n+\t\"cmd/cgo\":       ToTool,\n+\t\"cmd/cover\":     ToTool,\n+\t\"cmd/dist\":      ToTool,\n+\t\"cmd/doc\":       ToTool,\n+\t\"cmd/fix\":       ToTool,\n+\t\"cmd/link\":      ToTool,\n+\t\"cmd/newlink\":   ToTool,\n+\t\"cmd/nm\":        ToTool,\n+\t\"cmd/objdump\":   ToTool,\n+\t\"cmd/pack\":      ToTool,\n+\t\"cmd/pprof\":     ToTool,\n+\t\"cmd/trace\":     ToTool,\n+\t\"cmd/vet\":       ToTool,\n+\t\"code.google.com/p/go.tools/cmd/cover\": StalePath,\n+\t\"code.google.com/p/go.tools/cmd/godoc\": StalePath,\n+\t\"code.google.com/p/go.tools/cmd/vet\":   StalePath,\n }\n \n var raceExclude = map[string]bool{\n@@ -828,147 +857,152 @@ var cgoSyscallExclude = map[string]bool{\n \t\"runtime/msan\": true,\n }\n \n+var foldPath = make(map[string]string)\n+\n // load populates p using information from bp, err, which should\n // be the result of calling build.Context.Import.\n-func (p *Package) load(stk *importStack, bp *build.Package, err error) *Package {\n+func (p *Package) load(stk *ImportStack, bp *build.Package, err error) *Package {\n \tp.copyBuild(bp)\n \n \t// When using gccgo the go/build package will not be able to\n-\t// find a standard package.  It would be nicer to not get that\n+\t// find a standard package. It would be nicer to not get that\n \t// error, but go/build doesn't know stdpkg.\n-\tif runtime.Compiler == \"gccgo\" && err != nil && p.Standard {\n+\tif cfg.BuildToolchainName == \"gccgo\" && err != nil && p.Standard {\n \t\terr = nil\n \t}\n \n \t// The localPrefix is the path we interpret ./ imports relative to.\n \t// Synthesized main packages sometimes override this.\n-\tp.localPrefix = dirToImportPath(p.Dir)\n+\tp.Internal.LocalPrefix = dirToImportPath(p.Dir)\n \n \tif err != nil {\n+\t\tif _, ok := err.(*build.NoGoError); ok {\n+\t\t\terr = &NoGoError{Package: p}\n+\t\t}\n \t\tp.Incomplete = true\n-\t\terr = expandScanner(err)\n+\t\terr = base.ExpandScanner(err)\n \t\tp.Error = &PackageError{\n-\t\t\tImportStack: stk.copy(),\n+\t\t\tImportStack: stk.Copy(),\n \t\t\tErr:         err.Error(),\n \t\t}\n \t\treturn p\n \t}\n \n \tuseBindir := p.Name == \"main\"\n \tif !p.Standard {\n-\t\tswitch buildBuildmode {\n+\t\tswitch cfg.BuildBuildmode {\n \t\tcase \"c-archive\", \"c-shared\", \"plugin\":\n \t\t\tuseBindir = false\n \t\t}\n \t}\n \n \tif useBindir {\n \t\t// Report an error when the old code.google.com/p/go.tools paths are used.\n-\t\tif goTools[p.ImportPath] == stalePath {\n+\t\tif GoTools[p.ImportPath] == StalePath {\n \t\t\tnewPath := strings.Replace(p.ImportPath, \"code.google.com/p/go.\", \"golang.org/x/\", 1)\n \t\t\te := fmt.Sprintf(\"the %v command has moved; use %v instead.\", p.ImportPath, newPath)\n \t\t\tp.Error = &PackageError{Err: e}\n \t\t\treturn p\n \t\t}\n \t\t_, elem := filepath.Split(p.Dir)\n-\t\tfull := buildContext.GOOS + \"_\" + buildContext.GOARCH + \"/\" + elem\n-\t\tif buildContext.GOOS != toolGOOS || buildContext.GOARCH != toolGOARCH {\n+\t\tfull := cfg.BuildContext.GOOS + \"_\" + cfg.BuildContext.GOARCH + \"/\" + elem\n+\t\tif cfg.BuildContext.GOOS != base.ToolGOOS || cfg.BuildContext.GOARCH != base.ToolGOARCH {\n \t\t\t// Install cross-compiled binaries to subdirectories of bin.\n \t\t\telem = full\n \t\t}\n-\t\tif p.build.BinDir != \"\" {\n+\t\tif p.Internal.Build.BinDir != \"\" {\n \t\t\t// Install to GOBIN or bin of GOPATH entry.\n-\t\t\tp.target = filepath.Join(p.build.BinDir, elem)\n-\t\t\tif !p.Goroot && strings.Contains(elem, \"/\") && gobin != \"\" {\n+\t\t\tp.Internal.Target = filepath.Join(p.Internal.Build.BinDir, elem)\n+\t\t\tif !p.Goroot && strings.Contains(elem, \"/\") && cfg.GOBIN != \"\" {\n \t\t\t\t// Do not create $GOBIN/goos_goarch/elem.\n-\t\t\t\tp.target = \"\"\n-\t\t\t\tp.gobinSubdir = true\n+\t\t\t\tp.Internal.Target = \"\"\n+\t\t\t\tp.Internal.GobinSubdir = true\n \t\t\t}\n \t\t}\n-\t\tif goTools[p.ImportPath] == toTool {\n+\t\tif GoTools[p.ImportPath] == ToTool {\n \t\t\t// This is for 'go tool'.\n \t\t\t// Override all the usual logic and force it into the tool directory.\n-\t\t\tif buildContext.Compiler == \"gccgo\" {\n-\t\t\t\tp.target = filepath.Join(runtime.GCCGOTOOLDIR, elem)\n+\t\t\tif cfg.BuildToolchainName == \"gccgo\" {\n+\t\t\t\tp.Internal.Target = filepath.Join(runtime.GCCGOTOOLDIR, elem)\n \t\t\t} else {\n-\t\t\t\tp.target = filepath.Join(gorootPkg, \"tool\", full)\n+\t\t\t\tp.Internal.Target = filepath.Join(cfg.GOROOTpkg, \"tool\", full)\n \t\t\t}\n \t\t}\n-\t\tif p.target != \"\" && buildContext.GOOS == \"windows\" {\n-\t\t\tp.target += \".exe\"\n+\t\tif p.Internal.Target != \"\" && cfg.BuildContext.GOOS == \"windows\" {\n+\t\t\tp.Internal.Target += \".exe\"\n \t\t}\n-\t} else if p.local {\n+\t} else if p.Internal.Local {\n \t\t// Local import turned into absolute path.\n \t\t// No permanent install target.\n-\t\tp.target = \"\"\n+\t\tp.Internal.Target = \"\"\n \t} else {\n-\t\tp.target = p.build.PkgObj\n-\t\tif buildLinkshared {\n-\t\t\tshlibnamefile := p.target[:len(p.target)-2] + \".shlibname\"\n+\t\tp.Internal.Target = p.Internal.Build.PkgObj\n+\t\tif cfg.BuildLinkshared {\n+\t\t\tshlibnamefile := p.Internal.Target[:len(p.Internal.Target)-2] + \".shlibname\"\n \t\t\tshlib, err := ioutil.ReadFile(shlibnamefile)\n \t\t\tif err == nil {\n \t\t\t\tlibname := strings.TrimSpace(string(shlib))\n-\t\t\t\tif buildContext.Compiler == \"gccgo\" {\n-\t\t\t\t\tp.Shlib = filepath.Join(p.build.PkgTargetRoot, \"shlibs\", libname)\n+\t\t\t\tif cfg.BuildContext.Compiler == \"gccgo\" {\n+\t\t\t\t\tp.Shlib = filepath.Join(p.Internal.Build.PkgTargetRoot, \"shlibs\", libname)\n \t\t\t\t} else {\n-\t\t\t\t\tp.Shlib = filepath.Join(p.build.PkgTargetRoot, libname)\n+\t\t\t\t\tp.Shlib = filepath.Join(p.Internal.Build.PkgTargetRoot, libname)\n \n \t\t\t\t}\n \t\t\t} else if !os.IsNotExist(err) {\n-\t\t\t\tfatalf(\"unexpected error reading %s: %v\", shlibnamefile, err)\n+\t\t\t\tbase.Fatalf(\"unexpected error reading %s: %v\", shlibnamefile, err)\n \t\t\t}\n \t\t}\n \t}\n \n-\timportPaths := p.Imports\n+\tImportPaths := p.Imports\n \t// Packages that use cgo import runtime/cgo implicitly.\n \t// Packages that use cgo also import syscall implicitly,\n \t// to wrap errno.\n \t// Exclude certain packages to avoid circular dependencies.\n \tif len(p.CgoFiles) > 0 && (!p.Standard || !cgoExclude[p.ImportPath]) {\n-\t\timportPaths = append(importPaths, \"runtime/cgo\")\n+\t\tImportPaths = append(ImportPaths, \"runtime/cgo\")\n \t}\n \tif len(p.CgoFiles) > 0 && (!p.Standard || !cgoSyscallExclude[p.ImportPath]) {\n-\t\timportPaths = append(importPaths, \"syscall\")\n+\t\tImportPaths = append(ImportPaths, \"syscall\")\n \t}\n \n-\tif buildContext.CgoEnabled && p.Name == \"main\" && !p.Goroot {\n+\tif cfg.BuildContext.CgoEnabled && p.Name == \"main\" && !p.Goroot {\n \t\t// Currently build modes c-shared, pie (on systems that do not\n \t\t// support PIE with internal linking mode), plugin, and\n \t\t// -linkshared force external linking mode, as of course does\n \t\t// -ldflags=-linkmode=external. External linking mode forces\n \t\t// an import of runtime/cgo.\n-\t\tpieCgo := buildBuildmode == \"pie\" && (buildContext.GOOS != \"linux\" || buildContext.GOARCH != \"amd64\")\n+\t\tpieCgo := cfg.BuildBuildmode == \"pie\" && (cfg.BuildContext.GOOS != \"linux\" || cfg.BuildContext.GOARCH != \"amd64\")\n \t\tlinkmodeExternal := false\n-\t\tfor i, a := range buildLdflags {\n+\t\tfor i, a := range cfg.BuildLdflags {\n \t\t\tif a == \"-linkmode=external\" {\n \t\t\t\tlinkmodeExternal = true\n \t\t\t}\n-\t\t\tif a == \"-linkmode\" && i+1 < len(buildLdflags) && buildLdflags[i+1] == \"external\" {\n+\t\t\tif a == \"-linkmode\" && i+1 < len(cfg.BuildLdflags) && cfg.BuildLdflags[i+1] == \"external\" {\n \t\t\t\tlinkmodeExternal = true\n \t\t\t}\n \t\t}\n-\t\tif buildBuildmode == \"c-shared\" || buildBuildmode == \"plugin\" || pieCgo || buildLinkshared || linkmodeExternal {\n-\t\t\timportPaths = append(importPaths, \"runtime/cgo\")\n+\t\tif cfg.BuildBuildmode == \"c-shared\" || cfg.BuildBuildmode == \"plugin\" || pieCgo || cfg.BuildLinkshared || linkmodeExternal {\n+\t\t\tImportPaths = append(ImportPaths, \"runtime/cgo\")\n \t\t}\n \t}\n \n \t// Everything depends on runtime, except runtime, its internal\n \t// subpackages, and unsafe.\n \tif !p.Standard || (p.ImportPath != \"runtime\" && !strings.HasPrefix(p.ImportPath, \"runtime/internal/\") && p.ImportPath != \"unsafe\") {\n-\t\timportPaths = append(importPaths, \"runtime\")\n+\t\tImportPaths = append(ImportPaths, \"runtime\")\n \t\t// When race detection enabled everything depends on runtime/race.\n \t\t// Exclude certain packages to avoid circular dependencies.\n-\t\tif buildRace && (!p.Standard || !raceExclude[p.ImportPath]) {\n-\t\t\timportPaths = append(importPaths, \"runtime/race\")\n+\t\tif cfg.BuildRace && (!p.Standard || !raceExclude[p.ImportPath]) {\n+\t\t\tImportPaths = append(ImportPaths, \"runtime/race\")\n \t\t}\n \t\t// MSan uses runtime/msan.\n-\t\tif buildMSan && (!p.Standard || !raceExclude[p.ImportPath]) {\n-\t\t\timportPaths = append(importPaths, \"runtime/msan\")\n+\t\tif cfg.BuildMSan && (!p.Standard || !raceExclude[p.ImportPath]) {\n+\t\t\tImportPaths = append(ImportPaths, \"runtime/msan\")\n \t\t}\n \t\t// On ARM with GOARM=5, everything depends on math for the link.\n-\t\tif p.Name == \"main\" && goarch == \"arm\" {\n-\t\t\timportPaths = append(importPaths, \"math\")\n+\t\tif p.Name == \"main\" && cfg.Goarch == \"arm\" {\n+\t\t\tImportPaths = append(ImportPaths, \"math\")\n \t\t}\n \t}\n \n@@ -977,35 +1011,35 @@ func (p *Package) load(stk *importStack, bp *build.Package, err error) *Package\n \t// This can be an issue particularly for runtime/internal/atomic;\n \t// see issue 13655.\n \tif p.Standard && (p.ImportPath == \"runtime\" || strings.HasPrefix(p.ImportPath, \"runtime/internal/\")) && p.ImportPath != \"runtime/internal/sys\" {\n-\t\timportPaths = append(importPaths, \"runtime/internal/sys\")\n+\t\tImportPaths = append(ImportPaths, \"runtime/internal/sys\")\n \t}\n \n \t// Build list of full paths to all Go files in the package,\n \t// for use by commands like go fmt.\n-\tp.gofiles = stringList(p.GoFiles, p.CgoFiles, p.TestGoFiles, p.XTestGoFiles)\n-\tfor i := range p.gofiles {\n-\t\tp.gofiles[i] = filepath.Join(p.Dir, p.gofiles[i])\n+\tp.Internal.GoFiles = str.StringList(p.GoFiles, p.CgoFiles, p.TestGoFiles, p.XTestGoFiles)\n+\tfor i := range p.Internal.GoFiles {\n+\t\tp.Internal.GoFiles[i] = filepath.Join(p.Dir, p.Internal.GoFiles[i])\n \t}\n-\tsort.Strings(p.gofiles)\n+\tsort.Strings(p.Internal.GoFiles)\n \n-\tp.sfiles = stringList(p.SFiles)\n-\tfor i := range p.sfiles {\n-\t\tp.sfiles[i] = filepath.Join(p.Dir, p.sfiles[i])\n+\tp.Internal.SFiles = str.StringList(p.SFiles)\n+\tfor i := range p.Internal.SFiles {\n+\t\tp.Internal.SFiles[i] = filepath.Join(p.Dir, p.Internal.SFiles[i])\n \t}\n-\tsort.Strings(p.sfiles)\n+\tsort.Strings(p.Internal.SFiles)\n \n-\tp.allgofiles = stringList(p.IgnoredGoFiles)\n-\tfor i := range p.allgofiles {\n-\t\tp.allgofiles[i] = filepath.Join(p.Dir, p.allgofiles[i])\n+\tp.Internal.AllGoFiles = str.StringList(p.IgnoredGoFiles)\n+\tfor i := range p.Internal.AllGoFiles {\n+\t\tp.Internal.AllGoFiles[i] = filepath.Join(p.Dir, p.Internal.AllGoFiles[i])\n \t}\n-\tp.allgofiles = append(p.allgofiles, p.gofiles...)\n-\tsort.Strings(p.allgofiles)\n+\tp.Internal.AllGoFiles = append(p.Internal.AllGoFiles, p.Internal.GoFiles...)\n+\tsort.Strings(p.Internal.AllGoFiles)\n \n \t// Check for case-insensitive collision of input files.\n \t// To avoid problems on case-insensitive files, we reject any package\n \t// where two different input files have equal names under a case-insensitive\n \t// comparison.\n-\tf1, f2 := foldDup(stringList(\n+\tf1, f2 := str.FoldDup(str.StringList(\n \t\tp.GoFiles,\n \t\tp.CgoFiles,\n \t\tp.IgnoredGoFiles,\n@@ -1023,7 +1057,7 @@ func (p *Package) load(stk *importStack, bp *build.Package, err error) *Package\n \t))\n \tif f1 != \"\" {\n \t\tp.Error = &PackageError{\n-\t\t\tImportStack: stk.copy(),\n+\t\t\tImportStack: stk.Copy(),\n \t\t\tErr:         fmt.Sprintf(\"case-insensitive file name collision: %q and %q\", f1, f2),\n \t\t}\n \t\treturn p\n@@ -1042,41 +1076,41 @@ func (p *Package) load(stk *importStack, bp *build.Package, err error) *Package\n \t\t}\n \t}\n \n-\tfor i, path := range importPaths {\n+\tfor i, path := range ImportPaths {\n \t\tif path == \"C\" {\n \t\t\tcontinue\n \t\t}\n-\t\tp1 := loadImport(path, p.Dir, p, stk, p.build.ImportPos[path], useVendor)\n-\t\tif !reqStdPkgSrc && p1.Standard {\n+\t\tp1 := LoadImport(path, p.Dir, p, stk, p.Internal.Build.ImportPos[path], UseVendor)\n+\t\tif cfg.BuildToolchainName == \"gccgo\" && p1.Standard {\n \t\t\tcontinue\n \t\t}\n \t\tif p.Standard && p.Error == nil && !p1.Standard && p1.Error == nil {\n \t\t\tp.Error = &PackageError{\n-\t\t\t\tImportStack: stk.copy(),\n+\t\t\t\tImportStack: stk.Copy(),\n \t\t\t\tErr:         fmt.Sprintf(\"non-standard import %q in standard package %q\", path, p.ImportPath),\n \t\t\t}\n-\t\t\tpos := p.build.ImportPos[path]\n+\t\t\tpos := p.Internal.Build.ImportPos[path]\n \t\t\tif len(pos) > 0 {\n \t\t\t\tp.Error.Pos = pos[0].String()\n \t\t\t}\n \t\t}\n \n \t\tpath = p1.ImportPath\n-\t\timportPaths[i] = path\n+\t\tImportPaths[i] = path\n \t\tif i < len(p.Imports) {\n \t\t\tp.Imports[i] = path\n \t\t}\n \n \t\tsave(path, p1)\n \t\timports = append(imports, p1)\n-\t\tfor _, dep := range p1.deps {\n+\t\tfor _, dep := range p1.Internal.Deps {\n \t\t\tsave(dep.ImportPath, dep)\n \t\t}\n \t\tif p1.Incomplete {\n \t\t\tp.Incomplete = true\n \t\t}\n \t}\n-\tp.imports = imports\n+\tp.Internal.Imports = imports\n \n \tp.Deps = make([]string, 0, len(deps))\n \tfor dep := range deps {\n@@ -1088,21 +1122,21 @@ func (p *Package) load(stk *importStack, bp *build.Package, err error) *Package\n \t\tif p1 == nil {\n \t\t\tpanic(\"impossible: missing entry in package cache for \" + dep + \" imported by \" + p.ImportPath)\n \t\t}\n-\t\tp.deps = append(p.deps, p1)\n+\t\tp.Internal.Deps = append(p.Internal.Deps, p1)\n \t\tif p1.Error != nil {\n \t\t\tp.DepsErrors = append(p.DepsErrors, p1.Error)\n \t\t}\n \t}\n \n \t// unsafe is a fake package.\n-\tif p.Standard && (p.ImportPath == \"unsafe\" || buildContext.Compiler == \"gccgo\") {\n-\t\tp.target = \"\"\n+\tif p.Standard && (p.ImportPath == \"unsafe\" || cfg.BuildContext.Compiler == \"gccgo\") {\n+\t\tp.Internal.Target = \"\"\n \t}\n-\tp.Target = p.target\n+\tp.Target = p.Internal.Target\n \n \t// If cgo is not enabled, ignore cgo supporting sources\n \t// just as we ignore go files containing import \"C\".\n-\tif !buildContext.CgoEnabled {\n+\tif !cfg.BuildContext.CgoEnabled {\n \t\tp.CFiles = nil\n \t\tp.CXXFiles = nil\n \t\tp.MFiles = nil\n@@ -1115,32 +1149,31 @@ func (p *Package) load(stk *importStack, bp *build.Package, err error) *Package\n \t}\n \n \t// The gc toolchain only permits C source files with cgo.\n-\tif len(p.CFiles) > 0 && !p.usesCgo() && !p.usesSwig() && buildContext.Compiler == \"gc\" {\n+\tif len(p.CFiles) > 0 && !p.UsesCgo() && !p.UsesSwig() && cfg.BuildContext.Compiler == \"gc\" {\n \t\tp.Error = &PackageError{\n-\t\t\tImportStack: stk.copy(),\n+\t\t\tImportStack: stk.Copy(),\n \t\t\tErr:         fmt.Sprintf(\"C source files not allowed when not using cgo or SWIG: %s\", strings.Join(p.CFiles, \" \")),\n \t\t}\n \t\treturn p\n \t}\n \n-\t// In the absence of errors lower in the dependency tree,\n-\t// check for case-insensitive collisions of import paths.\n-\tif len(p.DepsErrors) == 0 {\n-\t\tdep1, dep2 := foldDup(p.Deps)\n-\t\tif dep1 != \"\" {\n-\t\t\tp.Error = &PackageError{\n-\t\t\t\tImportStack: stk.copy(),\n-\t\t\t\tErr:         fmt.Sprintf(\"case-insensitive import collision: %q and %q\", dep1, dep2),\n-\t\t\t}\n-\t\t\treturn p\n+\t// Check for case-insensitive collisions of import paths.\n+\tfold := str.ToFold(p.ImportPath)\n+\tif other := foldPath[fold]; other == \"\" {\n+\t\tfoldPath[fold] = p.ImportPath\n+\t} else if other != p.ImportPath {\n+\t\tp.Error = &PackageError{\n+\t\t\tImportStack: stk.Copy(),\n+\t\t\tErr:         fmt.Sprintf(\"case-insensitive import collision: %q and %q\", p.ImportPath, other),\n \t\t}\n+\t\treturn p\n \t}\n \n \tif p.BinaryOnly {\n \t\t// For binary-only package, use build ID from supplied package binary.\n-\t\tbuildID, err := readBuildID(p)\n+\t\tbuildID, err := buildid.ReadBuildID(p.Name, p.Target)\n \t\tif err == nil {\n-\t\t\tp.buildID = buildID\n+\t\t\tp.Internal.BuildID = buildID\n \t\t}\n \t} else {\n \t\tcomputeBuildID(p)\n@@ -1149,18 +1182,18 @@ func (p *Package) load(stk *importStack, bp *build.Package, err error) *Package\n }\n \n // usesSwig reports whether the package needs to run SWIG.\n-func (p *Package) usesSwig() bool {\n+func (p *Package) UsesSwig() bool {\n \treturn len(p.SwigFiles) > 0 || len(p.SwigCXXFiles) > 0\n }\n \n // usesCgo reports whether the package needs to run cgo\n-func (p *Package) usesCgo() bool {\n+func (p *Package) UsesCgo() bool {\n \treturn len(p.CgoFiles) > 0\n }\n \n // packageList returns the list of packages in the dag rooted at roots\n // as visited in a depth-first post-order traversal.\n-func packageList(roots []*Package) []*Package {\n+func PackageList(roots []*Package) []*Package {\n \tseen := map[*Package]bool{}\n \tall := []*Package{}\n \tvar walk func(*Package)\n@@ -1169,7 +1202,7 @@ func packageList(roots []*Package) []*Package {\n \t\t\treturn\n \t\t}\n \t\tseen[p] = true\n-\t\tfor _, p1 := range p.imports {\n+\t\tfor _, p1 := range p.Internal.Imports {\n \t\t\twalk(p1)\n \t\t}\n \t\tall = append(all, p)\n@@ -1182,8 +1215,8 @@ func packageList(roots []*Package) []*Package {\n \n // computeStale computes the Stale flag in the package dag that starts\n // at the named pkgs (command-line arguments).\n-func computeStale(pkgs ...*Package) {\n-\tfor _, p := range packageList(pkgs) {\n+func ComputeStale(pkgs ...*Package) {\n+\tfor _, p := range PackageList(pkgs) {\n \t\tp.Stale, p.StaleReason = isStale(p)\n \t}\n }\n@@ -1458,7 +1491,7 @@ var isGoRelease = strings.HasPrefix(runtime.Version(), \"go1\")\n // isStale reports whether package p needs to be rebuilt,\n // along with the reason why.\n func isStale(p *Package) (bool, string) {\n-\tif p.Standard && (p.ImportPath == \"unsafe\" || buildContext.Compiler == \"gccgo\") {\n+\tif p.Standard && (p.ImportPath == \"unsafe\" || cfg.BuildContext.Compiler == \"gccgo\") {\n \t\t// fake, builtin package\n \t\treturn false, \"builtin package\"\n \t}\n@@ -1474,29 +1507,29 @@ func isStale(p *Package) (bool, string) {\n \t// if a rebuild is needed, that rebuild attempt will produce a useful error.\n \t// (Some commands, such as 'go list', do not attempt to rebuild.)\n \tif p.BinaryOnly {\n-\t\tif p.target == \"\" {\n+\t\tif p.Internal.Target == \"\" {\n \t\t\t// Fail if a build is attempted.\n \t\t\treturn true, \"no source code for package, but no install target\"\n \t\t}\n-\t\tif _, err := os.Stat(p.target); err != nil {\n+\t\tif _, err := os.Stat(p.Internal.Target); err != nil {\n \t\t\t// Fail if a build is attempted.\n \t\t\treturn true, \"no source code for package, but cannot access install target: \" + err.Error()\n \t\t}\n \t\treturn false, \"no source code for package\"\n \t}\n \n \t// If the -a flag is given, rebuild everything.\n-\tif buildA {\n+\tif cfg.BuildA {\n \t\treturn true, \"build -a flag in use\"\n \t}\n \n \t// If there's no install target, we have to rebuild.\n-\tif p.target == \"\" {\n+\tif p.Internal.Target == \"\" {\n \t\treturn true, \"no install target\"\n \t}\n \n \t// Package is stale if completely unbuilt.\n-\tfi, err := os.Stat(p.target)\n+\tfi, err := os.Stat(p.Internal.Target)\n \tif err != nil {\n \t\treturn true, \"cannot stat install target\"\n \t}\n@@ -1509,13 +1542,13 @@ func isStale(p *Package) (bool, string) {\n \t// It also catches changes in toolchain, like when flipping between\n \t// two versions of Go compiling a single GOPATH.\n \t// See issue 8290 and issue 10702.\n-\ttargetBuildID, err := readBuildID(p)\n-\tif err == nil && targetBuildID != p.buildID {\n+\ttargetBuildID, err := buildid.ReadBuildID(p.Name, p.Target)\n+\tif err == nil && targetBuildID != p.Internal.BuildID {\n \t\treturn true, \"build ID mismatch\"\n \t}\n \n \t// Package is stale if a dependency is.\n-\tfor _, p1 := range p.deps {\n+\tfor _, p1 := range p.Internal.Deps {\n \t\tif p1.Stale {\n \t\t\treturn true, \"stale dependency\"\n \t\t}\n@@ -1553,8 +1586,8 @@ func isStale(p *Package) (bool, string) {\n \t}\n \n \t// Package is stale if a dependency is, or if a dependency is newer.\n-\tfor _, p1 := range p.deps {\n-\t\tif p1.target != \"\" && olderThan(p1.target) {\n+\tfor _, p1 := range p.Internal.Deps {\n+\t\tif p1.Internal.Target != \"\" && olderThan(p1.Internal.Target) {\n \t\t\treturn true, \"newer dependency\"\n \t\t}\n \t}\n@@ -1572,11 +1605,11 @@ func isStale(p *Package) (bool, string) {\n \t// and get a full rebuild anyway.\n \t// Excluding $GOROOT used to also fix issue 4106, but that's now\n \t// taken care of above (at least when the installed Go is a released version).\n-\tif p.Root != goroot {\n-\t\tif olderThan(buildToolchain.compiler()) {\n+\tif p.Root != cfg.GOROOT {\n+\t\tif olderThan(cfg.BuildToolchainCompiler()) {\n \t\t\treturn true, \"newer compiler\"\n \t\t}\n-\t\tif p.build.IsCommand() && olderThan(buildToolchain.linker()) {\n+\t\tif p.Internal.Build.IsCommand() && olderThan(cfg.BuildToolchainLinker()) {\n \t\t\treturn true, \"newer linker\"\n \t\t}\n \t}\n@@ -1619,7 +1652,7 @@ func isStale(p *Package) (bool, string) {\n \t// to test for write access, and then skip GOPATH roots we don't have write\n \t// access to. But hopefully we can just use the mtimes always.\n \n-\tsrcs := stringList(p.GoFiles, p.CFiles, p.CXXFiles, p.MFiles, p.HFiles, p.FFiles, p.SFiles, p.CgoFiles, p.SysoFiles, p.SwigFiles, p.SwigCXXFiles)\n+\tsrcs := str.StringList(p.GoFiles, p.CFiles, p.CXXFiles, p.MFiles, p.HFiles, p.FFiles, p.SFiles, p.CgoFiles, p.SysoFiles, p.SwigFiles, p.SwigCXXFiles)\n \tfor _, src := range srcs {\n \t\tif olderThan(filepath.Join(p.Dir, src)) {\n \t\t\treturn true, \"newer source file\"\n@@ -1629,19 +1662,20 @@ func isStale(p *Package) (bool, string) {\n \treturn false, \"\"\n }\n \n-// computeBuildID computes the build ID for p, leaving it in p.buildID.\n+// computeBuildID computes the build ID for p, leaving it in p.Internal.BuildID.\n // Build ID is a hash of the information we want to detect changes in.\n // See the long comment in isStale for details.\n func computeBuildID(p *Package) {\n \th := sha1.New()\n \n \t// Include the list of files compiled as part of the package.\n \t// This lets us detect removed files. See issue 3895.\n-\tinputFiles := stringList(\n+\tinputFiles := str.StringList(\n \t\tp.GoFiles,\n \t\tp.CgoFiles,\n \t\tp.CFiles,\n \t\tp.CXXFiles,\n+\t\tp.FFiles,\n \t\tp.MFiles,\n \t\tp.HFiles,\n \t\tp.SFiles,\n@@ -1656,12 +1690,23 @@ func computeBuildID(p *Package) {\n \t// Include the content of runtime/internal/sys/zversion.go in the hash\n \t// for package runtime. This will give package runtime a\n \t// different build ID in each Go release.\n-\tif p.Standard && p.ImportPath == \"runtime/internal/sys\" && buildContext.Compiler != \"gccgo\" {\n+\tif p.Standard && p.ImportPath == \"runtime/internal/sys\" && cfg.BuildContext.Compiler != \"gccgo\" {\n \t\tdata, err := ioutil.ReadFile(filepath.Join(p.Dir, \"zversion.go\"))\n-\t\tif err != nil {\n-\t\t\tfatalf(\"go: %s\", err)\n+\t\tif os.IsNotExist(err) {\n+\t\t\tp.Stale = true\n+\t\t\tp.StaleReason = fmt.Sprintf(\"missing zversion.go\")\n+\t\t} else if err != nil {\n+\t\t\tbase.Fatalf(\"go: %s\", err)\n \t\t}\n \t\tfmt.Fprintf(h, \"zversion %q\\n\", string(data))\n+\n+\t\t// Add environment variables that affect code generation.\n+\t\tswitch cfg.BuildContext.GOARCH {\n+\t\tcase \"arm\":\n+\t\t\tfmt.Fprintf(h, \"GOARM=%s\\n\", cfg.GOARM)\n+\t\tcase \"386\":\n+\t\t\tfmt.Fprintf(h, \"GO386=%s\\n\", cfg.GO386)\n+\t\t}\n \t}\n \n \t// Include the build IDs of any dependencies in the hash.\n@@ -1672,22 +1717,26 @@ func computeBuildID(p *Package) {\n \t// people use the same GOPATH but switch between\n \t// different Go releases. See issue 10702.\n \t// This is also a better fix for issue 8290.\n-\tfor _, p1 := range p.deps {\n-\t\tfmt.Fprintf(h, \"dep %s %s\\n\", p1.ImportPath, p1.buildID)\n+\tfor _, p1 := range p.Internal.Deps {\n+\t\tfmt.Fprintf(h, \"dep %s %s\\n\", p1.ImportPath, p1.Internal.BuildID)\n \t}\n \n-\tp.buildID = fmt.Sprintf(\"%x\", h.Sum(nil))\n+\tp.Internal.BuildID = fmt.Sprintf(\"%x\", h.Sum(nil))\n }\n \n-var cwd, _ = os.Getwd()\n-\n var cmdCache = map[string]*Package{}\n \n+func ClearCmdCache() {\n+\tfor name := range cmdCache {\n+\t\tdelete(cmdCache, name)\n+\t}\n+}\n+\n // loadPackage is like loadImport but is used for command-line arguments,\n // not for paths found in import statements. In addition to ordinary import paths,\n // loadPackage accepts pseudo-paths beginning with cmd/ to denote commands\n // in the Go command directory, as well as paths to those directories.\n-func loadPackage(arg string, stk *importStack) *Package {\n+func LoadPackage(arg string, stk *ImportStack) *Package {\n \tif build.IsLocalImport(arg) {\n \t\tdir := arg\n \t\tif !filepath.IsAbs(dir) {\n@@ -1696,32 +1745,32 @@ func loadPackage(arg string, stk *importStack) *Package {\n \t\t\t\tdir = abs\n \t\t\t}\n \t\t}\n-\t\tif sub, ok := hasSubdir(gorootSrc, dir); ok && strings.HasPrefix(sub, \"cmd/\") && !strings.Contains(sub[4:], \"/\") {\n+\t\tif sub, ok := hasSubdir(cfg.GOROOTsrc, dir); ok && strings.HasPrefix(sub, \"cmd/\") && !strings.Contains(sub[4:], \"/\") {\n \t\t\targ = sub\n \t\t}\n \t}\n \tif strings.HasPrefix(arg, \"cmd/\") && !strings.Contains(arg[4:], \"/\") {\n \t\tif p := cmdCache[arg]; p != nil {\n \t\t\treturn p\n \t\t}\n-\t\tstk.push(arg)\n-\t\tdefer stk.pop()\n+\t\tstk.Push(arg)\n+\t\tdefer stk.Pop()\n \n-\t\tbp, err := buildContext.ImportDir(filepath.Join(gorootSrc, arg), 0)\n+\t\tbp, err := cfg.BuildContext.ImportDir(filepath.Join(cfg.GOROOTsrc, arg), 0)\n \t\tbp.ImportPath = arg\n \t\tbp.Goroot = true\n-\t\tbp.BinDir = gorootBin\n-\t\tif gobin != \"\" {\n-\t\t\tbp.BinDir = gobin\n+\t\tbp.BinDir = cfg.GOROOTbin\n+\t\tif cfg.GOROOTbin != \"\" {\n+\t\t\tbp.BinDir = cfg.GOROOTbin\n \t\t}\n-\t\tbp.Root = goroot\n-\t\tbp.SrcRoot = gorootSrc\n+\t\tbp.Root = cfg.GOROOT\n+\t\tbp.SrcRoot = cfg.GOROOTsrc\n \t\tp := new(Package)\n \t\tcmdCache[arg] = p\n \t\tp.load(stk, bp, err)\n \t\tif p.Error == nil && p.Name != \"main\" {\n \t\t\tp.Error = &PackageError{\n-\t\t\t\tImportStack: stk.copy(),\n+\t\t\t\tImportStack: stk.Copy(),\n \t\t\t\tErr:         fmt.Sprintf(\"expected package main but found package %s in %s\", p.Name, p.Dir),\n \t\t\t}\n \t\t}\n@@ -1735,28 +1784,28 @@ func loadPackage(arg string, stk *importStack) *Package {\n \t// referring to io/ioutil rather than a hypothetical import of\n \t// \"./ioutil\".\n \tif build.IsLocalImport(arg) {\n-\t\tbp, _ := buildContext.ImportDir(filepath.Join(cwd, arg), build.FindOnly)\n+\t\tbp, _ := cfg.BuildContext.ImportDir(filepath.Join(base.Cwd, arg), build.FindOnly)\n \t\tif bp.ImportPath != \"\" && bp.ImportPath != \".\" {\n \t\t\targ = bp.ImportPath\n \t\t}\n \t}\n \n-\treturn loadImport(arg, cwd, nil, stk, nil, 0)\n+\treturn LoadImport(arg, base.Cwd, nil, stk, nil, 0)\n }\n \n // packages returns the packages named by the\n-// command line arguments 'args'.  If a named package\n+// command line arguments 'args'. If a named package\n // cannot be loaded at all (for example, if the directory does not exist),\n // then packages prints an error and does not include that\n // package in the results. However, if errors occur trying\n // to load dependencies of a named package, the named\n // package is still returned, with p.Incomplete = true\n // and details in p.DepsErrors.\n-func packages(args []string) []*Package {\n+func Packages(args []string) []*Package {\n \tvar pkgs []*Package\n-\tfor _, pkg := range packagesAndErrors(args) {\n+\tfor _, pkg := range PackagesAndErrors(args) {\n \t\tif pkg.Error != nil {\n-\t\t\terrorf(\"can't load package: %s\", pkg.Error)\n+\t\t\tbase.Errorf(\"can't load package: %s\", pkg.Error)\n \t\t\tcontinue\n \t\t}\n \t\tpkgs = append(pkgs, pkg)\n@@ -1768,15 +1817,15 @@ func packages(args []string) []*Package {\n // *Package for every argument, even the ones that\n // cannot be loaded at all.\n // The packages that fail to load will have p.Error != nil.\n-func packagesAndErrors(args []string) []*Package {\n+func PackagesAndErrors(args []string) []*Package {\n \tif len(args) > 0 && strings.HasSuffix(args[0], \".go\") {\n-\t\treturn []*Package{goFilesPackage(args)}\n+\t\treturn []*Package{GoFilesPackage(args)}\n \t}\n \n-\targs = importPaths(args)\n+\targs = ImportPaths(args)\n \tvar (\n \t\tpkgs    []*Package\n-\t\tstk     importStack\n+\t\tstk     ImportStack\n \t\tseenArg = make(map[string]bool)\n \t\tseenPkg = make(map[*Package]bool)\n \t)\n@@ -1786,27 +1835,27 @@ func packagesAndErrors(args []string) []*Package {\n \t\t\tcontinue\n \t\t}\n \t\tseenArg[arg] = true\n-\t\tpkg := loadPackage(arg, &stk)\n+\t\tpkg := LoadPackage(arg, &stk)\n \t\tif seenPkg[pkg] {\n \t\t\tcontinue\n \t\t}\n \t\tseenPkg[pkg] = true\n \t\tpkgs = append(pkgs, pkg)\n \t}\n-\tcomputeStale(pkgs...)\n+\tComputeStale(pkgs...)\n \n \treturn pkgs\n }\n \n // packagesForBuild is like 'packages' but fails if any of\n // the packages or their dependencies have errors\n // (cannot be built).\n-func packagesForBuild(args []string) []*Package {\n-\tpkgs := packagesAndErrors(args)\n+func PackagesForBuild(args []string) []*Package {\n+\tpkgs := PackagesAndErrors(args)\n \tprinted := map[*PackageError]bool{}\n \tfor _, pkg := range pkgs {\n \t\tif pkg.Error != nil {\n-\t\t\terrorf(\"can't load package: %s\", pkg.Error)\n+\t\t\tbase.Errorf(\"can't load package: %s\", pkg.Error)\n \t\t}\n \t\tfor _, err := range pkg.DepsErrors {\n \t\t\t// Since these are errors in dependencies,\n@@ -1815,11 +1864,11 @@ func packagesForBuild(args []string) []*Package {\n \t\t\t// Only print each once.\n \t\t\tif !printed[err] {\n \t\t\t\tprinted[err] = true\n-\t\t\t\terrorf(\"%s\", err)\n+\t\t\t\tbase.Errorf(\"%s\", err)\n \t\t\t}\n \t\t}\n \t}\n-\texitIfErrors()\n+\tbase.ExitIfErrors()\n \n \t// Check for duplicate loads of the same package.\n \t// That should be impossible, but if it does happen then\n@@ -1828,223 +1877,95 @@ func packagesForBuild(args []string) []*Package {\n \t// which doesn't work very well.\n \tseen := map[string]bool{}\n \treported := map[string]bool{}\n-\tfor _, pkg := range packageList(pkgs) {\n+\tfor _, pkg := range PackageList(pkgs) {\n \t\tif seen[pkg.ImportPath] && !reported[pkg.ImportPath] {\n \t\t\treported[pkg.ImportPath] = true\n-\t\t\terrorf(\"internal error: duplicate loads of %s\", pkg.ImportPath)\n+\t\t\tbase.Errorf(\"internal error: duplicate loads of %s\", pkg.ImportPath)\n \t\t}\n \t\tseen[pkg.ImportPath] = true\n \t}\n-\texitIfErrors()\n+\tbase.ExitIfErrors()\n \n \treturn pkgs\n }\n \n-// hasSubdir reports whether dir is a subdirectory of\n-// (possibly multiple levels below) root.\n-// If so, it sets rel to the path fragment that must be\n-// appended to root to reach dir.\n-func hasSubdir(root, dir string) (rel string, ok bool) {\n-\tif p, err := filepath.EvalSymlinks(root); err == nil {\n-\t\troot = p\n-\t}\n-\tif p, err := filepath.EvalSymlinks(dir); err == nil {\n-\t\tdir = p\n-\t}\n-\tconst sep = string(filepath.Separator)\n-\troot = filepath.Clean(root)\n-\tif !strings.HasSuffix(root, sep) {\n-\t\troot += sep\n-\t}\n-\tdir = filepath.Clean(dir)\n-\tif !strings.HasPrefix(dir, root) {\n-\t\treturn \"\", false\n-\t}\n-\treturn filepath.ToSlash(dir[len(root):]), true\n-}\n-\n-var (\n-\terrBuildIDToolchain = fmt.Errorf(\"build ID only supported in gc toolchain\")\n-\terrBuildIDMalformed = fmt.Errorf(\"malformed object file\")\n-\terrBuildIDUnknown   = fmt.Errorf(\"lost build ID\")\n-)\n-\n-var (\n-\tbangArch = []byte(\"!<arch>\")\n-\tpkgdef   = []byte(\"__.PKGDEF\")\n-\tgoobject = []byte(\"go object \")\n-\tbuildid  = []byte(\"build id \")\n-)\n-\n-// readBuildID reads the build ID from an archive or binary.\n-// It only supports the gc toolchain.\n-// Other toolchain maintainers should adjust this function.\n-func readBuildID(p *Package) (id string, err error) {\n-\tif buildToolchain != (gcToolchain{}) {\n-\t\treturn \"\", errBuildIDToolchain\n-\t}\n-\n-\t// For commands, read build ID directly from binary.\n-\tif p.Name == \"main\" {\n-\t\treturn ReadBuildIDFromBinary(p.Target)\n-\t}\n-\n-\t// Otherwise, we expect to have an archive (.a) file,\n-\t// and we can read the build ID from the Go export data.\n-\tif !strings.HasSuffix(p.Target, \".a\") {\n-\t\treturn \"\", &os.PathError{Op: \"parse\", Path: p.Target, Err: errBuildIDUnknown}\n-\t}\n-\n-\t// Read just enough of the target to fetch the build ID.\n-\t// The archive is expected to look like:\n-\t//\n-\t//\t!<arch>\n-\t//\t__.PKGDEF       0           0     0     644     7955      `\n-\t//\tgo object darwin amd64 devel X:none\n-\t//\tbuild id \"b41e5c45250e25c9fd5e9f9a1de7857ea0d41224\"\n-\t//\n-\t// The variable-sized strings are GOOS, GOARCH, and the experiment list (X:none).\n-\t// Reading the first 1024 bytes should be plenty.\n-\tf, err := os.Open(p.Target)\n-\tif err != nil {\n-\t\treturn \"\", err\n-\t}\n-\tdata := make([]byte, 1024)\n-\tn, err := io.ReadFull(f, data)\n-\tf.Close()\n-\n-\tif err != nil && n == 0 {\n-\t\treturn \"\", err\n+// GoFilesPackage creates a package for building a collection of Go files\n+// (typically named on the command line). The target is named p.a for\n+// package p or named after the first Go file for package main.\n+func GoFilesPackage(gofiles []string) *Package {\n+\t// TODO: Remove this restriction.\n+\tfor _, f := range gofiles {\n+\t\tif !strings.HasSuffix(f, \".go\") {\n+\t\t\tbase.Fatalf(\"named files must be .go files\")\n+\t\t}\n \t}\n \n-\tbad := func() (string, error) {\n-\t\treturn \"\", &os.PathError{Op: \"parse\", Path: p.Target, Err: errBuildIDMalformed}\n-\t}\n+\tvar stk ImportStack\n+\tctxt := cfg.BuildContext\n+\tctxt.UseAllFiles = true\n \n-\t// Archive header.\n-\tfor i := 0; ; i++ { // returns during i==3\n-\t\tj := bytes.IndexByte(data, '\\n')\n-\t\tif j < 0 {\n-\t\t\treturn bad()\n+\t// Synthesize fake \"directory\" that only shows the named files,\n+\t// to make it look like this is a standard package or\n+\t// command directory. So that local imports resolve\n+\t// consistently, the files must all be in the same directory.\n+\tvar dirent []os.FileInfo\n+\tvar dir string\n+\tfor _, file := range gofiles {\n+\t\tfi, err := os.Stat(file)\n+\t\tif err != nil {\n+\t\t\tbase.Fatalf(\"%s\", err)\n \t\t}\n-\t\tline := data[:j]\n-\t\tdata = data[j+1:]\n-\t\tswitch i {\n-\t\tcase 0:\n-\t\t\tif !bytes.Equal(line, bangArch) {\n-\t\t\t\treturn bad()\n-\t\t\t}\n-\t\tcase 1:\n-\t\t\tif !bytes.HasPrefix(line, pkgdef) {\n-\t\t\t\treturn bad()\n-\t\t\t}\n-\t\tcase 2:\n-\t\t\tif !bytes.HasPrefix(line, goobject) {\n-\t\t\t\treturn bad()\n-\t\t\t}\n-\t\tcase 3:\n-\t\t\tif !bytes.HasPrefix(line, buildid) {\n-\t\t\t\t// Found the object header, just doesn't have a build id line.\n-\t\t\t\t// Treat as successful, with empty build id.\n-\t\t\t\treturn \"\", nil\n-\t\t\t}\n-\t\t\tid, err := strconv.Unquote(string(line[len(buildid):]))\n-\t\t\tif err != nil {\n-\t\t\t\treturn bad()\n-\t\t\t}\n-\t\t\treturn id, nil\n+\t\tif fi.IsDir() {\n+\t\t\tbase.Fatalf(\"%s is a directory, should be a Go file\", file)\n \t\t}\n+\t\tdir1, _ := filepath.Split(file)\n+\t\tif dir1 == \"\" {\n+\t\t\tdir1 = \"./\"\n+\t\t}\n+\t\tif dir == \"\" {\n+\t\t\tdir = dir1\n+\t\t} else if dir != dir1 {\n+\t\t\tbase.Fatalf(\"named files must all be in one directory; have %s and %s\", dir, dir1)\n+\t\t}\n+\t\tdirent = append(dirent, fi)\n \t}\n-}\n+\tctxt.ReadDir = func(string) ([]os.FileInfo, error) { return dirent, nil }\n \n-var (\n-\tgoBuildPrefix = []byte(\"\\xff Go build ID: \\\"\")\n-\tgoBuildEnd    = []byte(\"\\\"\\n \\xff\")\n-\n-\telfPrefix = []byte(\"\\x7fELF\")\n-\n-\tmachoPrefixes = [][]byte{\n-\t\t{0xfe, 0xed, 0xfa, 0xce},\n-\t\t{0xfe, 0xed, 0xfa, 0xcf},\n-\t\t{0xce, 0xfa, 0xed, 0xfe},\n-\t\t{0xcf, 0xfa, 0xed, 0xfe},\n+\tvar err error\n+\tif dir == \"\" {\n+\t\tdir = base.Cwd\n \t}\n-)\n-\n-var BuildIDReadSize = 32 * 1024 // changed for testing\n-\n-// ReadBuildIDFromBinary reads the build ID from a binary.\n-//\n-// ELF binaries store the build ID in a proper PT_NOTE section.\n-//\n-// Other binary formats are not so flexible. For those, the linker\n-// stores the build ID as non-instruction bytes at the very beginning\n-// of the text segment, which should appear near the beginning\n-// of the file. This is clumsy but fairly portable. Custom locations\n-// can be added for other binary types as needed, like we did for ELF.\n-func ReadBuildIDFromBinary(filename string) (id string, err error) {\n-\tif filename == \"\" {\n-\t\treturn \"\", &os.PathError{Op: \"parse\", Path: filename, Err: errBuildIDUnknown}\n-\t}\n-\n-\t// Read the first 32 kB of the binary file.\n-\t// That should be enough to find the build ID.\n-\t// In ELF files, the build ID is in the leading headers,\n-\t// which are typically less than 4 kB, not to mention 32 kB.\n-\t// In Mach-O files, there's no limit, so we have to parse the file.\n-\t// On other systems, we're trying to read enough that\n-\t// we get the beginning of the text segment in the read.\n-\t// The offset where the text segment begins in a hello\n-\t// world compiled for each different object format today:\n-\t//\n-\t//\tPlan 9: 0x20\n-\t//\tWindows: 0x600\n-\t//\n-\tf, err := os.Open(filename)\n+\tdir, err = filepath.Abs(dir)\n \tif err != nil {\n-\t\treturn \"\", err\n+\t\tbase.Fatalf(\"%s\", err)\n \t}\n-\tdefer f.Close()\n \n-\tdata := make([]byte, BuildIDReadSize)\n-\t_, err = io.ReadFull(f, data)\n-\tif err == io.ErrUnexpectedEOF {\n-\t\terr = nil\n-\t}\n-\tif err != nil {\n-\t\treturn \"\", err\n-\t}\n+\tbp, err := ctxt.ImportDir(dir, 0)\n+\tpkg := new(Package)\n+\tpkg.Internal.Local = true\n+\tpkg.Internal.Cmdline = true\n+\tstk.Push(\"main\")\n+\tpkg.load(&stk, bp, err)\n+\tstk.Pop()\n+\tpkg.Internal.LocalPrefix = dirToImportPath(dir)\n+\tpkg.ImportPath = \"command-line-arguments\"\n+\tpkg.Internal.Target = \"\"\n \n-\tif bytes.HasPrefix(data, elfPrefix) {\n-\t\treturn readELFGoBuildID(filename, f, data)\n-\t}\n-\tfor _, m := range machoPrefixes {\n-\t\tif bytes.HasPrefix(data, m) {\n-\t\t\treturn readMachoGoBuildID(filename, f, data)\n+\tif pkg.Name == \"main\" {\n+\t\t_, elem := filepath.Split(gofiles[0])\n+\t\texe := elem[:len(elem)-len(\".go\")] + cfg.ExeSuffix\n+\t\tif cfg.BuildO == \"\" {\n+\t\t\tcfg.BuildO = exe\n+\t\t}\n+\t\tif cfg.GOBIN != \"\" {\n+\t\t\tpkg.Internal.Target = filepath.Join(cfg.GOBIN, exe)\n \t\t}\n \t}\n \n-\treturn readRawGoBuildID(filename, data)\n-}\n-\n-// readRawGoBuildID finds the raw build ID stored in text segment data.\n-func readRawGoBuildID(filename string, data []byte) (id string, err error) {\n-\ti := bytes.Index(data, goBuildPrefix)\n-\tif i < 0 {\n-\t\t// Missing. Treat as successful but build ID empty.\n-\t\treturn \"\", nil\n-\t}\n-\n-\tj := bytes.Index(data[i+len(goBuildPrefix):], goBuildEnd)\n-\tif j < 0 {\n-\t\treturn \"\", &os.PathError{Op: \"parse\", Path: filename, Err: errBuildIDMalformed}\n-\t}\n-\n-\tquoted := data[i+len(goBuildPrefix)-1 : i+len(goBuildPrefix)+j+1]\n-\tid, err = strconv.Unquote(string(quoted))\n-\tif err != nil {\n-\t\treturn \"\", &os.PathError{Op: \"parse\", Path: filename, Err: errBuildIDMalformed}\n-\t}\n+\tpkg.Target = pkg.Internal.Target\n+\tpkg.Stale = true\n+\tpkg.StaleReason = \"files named on command line\"\n \n-\treturn id, nil\n+\tComputeStale(pkg)\n+\treturn pkg\n }", "previous_filename": "libgo/go/cmd/go/pkg.go"}, {"sha": "0c7d9ce0e6c310554796ab1d118d7cc9597e4690", "filename": "libgo/go/cmd/go/internal/load/search.go", "status": "added", "additions": 338, "deletions": 0, "changes": 338, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fsearch.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fsearch.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fsearch.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -0,0 +1,338 @@\n+// Copyright 2017 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package load\n+\n+import (\n+\t\"cmd/go/internal/cfg\"\n+\t\"fmt\"\n+\t\"go/build\"\n+\t\"log\"\n+\t\"os\"\n+\t\"path\"\n+\t\"path/filepath\"\n+\t\"regexp\"\n+\t\"strings\"\n+)\n+\n+// allPackages returns all the packages that can be found\n+// under the $GOPATH directories and $GOROOT matching pattern.\n+// The pattern is either \"all\" (all packages), \"std\" (standard packages),\n+// \"cmd\" (standard commands), or a path including \"...\".\n+func allPackages(pattern string) []string {\n+\tpkgs := MatchPackages(pattern)\n+\tif len(pkgs) == 0 {\n+\t\tfmt.Fprintf(os.Stderr, \"warning: %q matched no packages\\n\", pattern)\n+\t}\n+\treturn pkgs\n+}\n+\n+// allPackagesInFS is like allPackages but is passed a pattern\n+// beginning ./ or ../, meaning it should scan the tree rooted\n+// at the given directory. There are ... in the pattern too.\n+func allPackagesInFS(pattern string) []string {\n+\tpkgs := MatchPackagesInFS(pattern)\n+\tif len(pkgs) == 0 {\n+\t\tfmt.Fprintf(os.Stderr, \"warning: %q matched no packages\\n\", pattern)\n+\t}\n+\treturn pkgs\n+}\n+\n+// MatchPackages returns a list of package paths matching pattern\n+// (see go help packages for pattern syntax).\n+func MatchPackages(pattern string) []string {\n+\tmatch := func(string) bool { return true }\n+\ttreeCanMatch := func(string) bool { return true }\n+\tif !IsMetaPackage(pattern) {\n+\t\tmatch = matchPattern(pattern)\n+\t\ttreeCanMatch = treeCanMatchPattern(pattern)\n+\t}\n+\n+\thave := map[string]bool{\n+\t\t\"builtin\": true, // ignore pseudo-package that exists only for documentation\n+\t}\n+\tif !cfg.BuildContext.CgoEnabled {\n+\t\thave[\"runtime/cgo\"] = true // ignore during walk\n+\t}\n+\tvar pkgs []string\n+\n+\tfor _, src := range cfg.BuildContext.SrcDirs() {\n+\t\tif (pattern == \"std\" || pattern == \"cmd\") && src != cfg.GOROOTsrc {\n+\t\t\tcontinue\n+\t\t}\n+\t\tsrc = filepath.Clean(src) + string(filepath.Separator)\n+\t\troot := src\n+\t\tif pattern == \"cmd\" {\n+\t\t\troot += \"cmd\" + string(filepath.Separator)\n+\t\t}\n+\t\tfilepath.Walk(root, func(path string, fi os.FileInfo, err error) error {\n+\t\t\tif err != nil || path == src {\n+\t\t\t\treturn nil\n+\t\t\t}\n+\n+\t\t\twant := true\n+\t\t\t// Avoid .foo, _foo, and testdata directory trees.\n+\t\t\t_, elem := filepath.Split(path)\n+\t\t\tif strings.HasPrefix(elem, \".\") || strings.HasPrefix(elem, \"_\") || elem == \"testdata\" {\n+\t\t\t\twant = false\n+\t\t\t}\n+\n+\t\t\tname := filepath.ToSlash(path[len(src):])\n+\t\t\tif pattern == \"std\" && (!isStandardImportPath(name) || name == \"cmd\") {\n+\t\t\t\t// The name \"std\" is only the standard library.\n+\t\t\t\t// If the name is cmd, it's the root of the command tree.\n+\t\t\t\twant = false\n+\t\t\t}\n+\t\t\tif !treeCanMatch(name) {\n+\t\t\t\twant = false\n+\t\t\t}\n+\n+\t\t\tif !fi.IsDir() {\n+\t\t\t\tif fi.Mode()&os.ModeSymlink != 0 && want {\n+\t\t\t\t\tif target, err := os.Stat(path); err == nil && target.IsDir() {\n+\t\t\t\t\t\tfmt.Fprintf(os.Stderr, \"warning: ignoring symlink %s\\n\", path)\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\treturn nil\n+\t\t\t}\n+\t\t\tif !want {\n+\t\t\t\treturn filepath.SkipDir\n+\t\t\t}\n+\n+\t\t\tif have[name] {\n+\t\t\t\treturn nil\n+\t\t\t}\n+\t\t\thave[name] = true\n+\t\t\tif !match(name) {\n+\t\t\t\treturn nil\n+\t\t\t}\n+\t\t\tpkg, err := cfg.BuildContext.ImportDir(path, 0)\n+\t\t\tif err != nil {\n+\t\t\t\tif _, noGo := err.(*build.NoGoError); noGo {\n+\t\t\t\t\treturn nil\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\t// If we are expanding \"cmd\", skip main\n+\t\t\t// packages under cmd/vendor. At least as of\n+\t\t\t// March, 2017, there is one there for the\n+\t\t\t// vendored pprof tool.\n+\t\t\tif pattern == \"cmd\" && strings.HasPrefix(pkg.ImportPath, \"cmd/vendor\") && pkg.Name == \"main\" {\n+\t\t\t\treturn nil\n+\t\t\t}\n+\n+\t\t\tpkgs = append(pkgs, name)\n+\t\t\treturn nil\n+\t\t})\n+\t}\n+\treturn pkgs\n+}\n+\n+// MatchPackagesInFS returns a list of package paths matching pattern,\n+// which must begin with ./ or ../\n+// (see go help packages for pattern syntax).\n+func MatchPackagesInFS(pattern string) []string {\n+\t// Find directory to begin the scan.\n+\t// Could be smarter but this one optimization\n+\t// is enough for now, since ... is usually at the\n+\t// end of a path.\n+\ti := strings.Index(pattern, \"...\")\n+\tdir, _ := path.Split(pattern[:i])\n+\n+\t// pattern begins with ./ or ../.\n+\t// path.Clean will discard the ./ but not the ../.\n+\t// We need to preserve the ./ for pattern matching\n+\t// and in the returned import paths.\n+\tprefix := \"\"\n+\tif strings.HasPrefix(pattern, \"./\") {\n+\t\tprefix = \"./\"\n+\t}\n+\tmatch := matchPattern(pattern)\n+\n+\tvar pkgs []string\n+\tfilepath.Walk(dir, func(path string, fi os.FileInfo, err error) error {\n+\t\tif err != nil || !fi.IsDir() {\n+\t\t\treturn nil\n+\t\t}\n+\t\tif path == dir {\n+\t\t\t// filepath.Walk starts at dir and recurses. For the recursive case,\n+\t\t\t// the path is the result of filepath.Join, which calls filepath.Clean.\n+\t\t\t// The initial case is not Cleaned, though, so we do this explicitly.\n+\t\t\t//\n+\t\t\t// This converts a path like \"./io/\" to \"io\". Without this step, running\n+\t\t\t// \"cd $GOROOT/src; go list ./io/...\" would incorrectly skip the io\n+\t\t\t// package, because prepending the prefix \"./\" to the unclean path would\n+\t\t\t// result in \"././io\", and match(\"././io\") returns false.\n+\t\t\tpath = filepath.Clean(path)\n+\t\t}\n+\n+\t\t// Avoid .foo, _foo, and testdata directory trees, but do not avoid \".\" or \"..\".\n+\t\t_, elem := filepath.Split(path)\n+\t\tdot := strings.HasPrefix(elem, \".\") && elem != \".\" && elem != \"..\"\n+\t\tif dot || strings.HasPrefix(elem, \"_\") || elem == \"testdata\" {\n+\t\t\treturn filepath.SkipDir\n+\t\t}\n+\n+\t\tname := prefix + filepath.ToSlash(path)\n+\t\tif !match(name) {\n+\t\t\treturn nil\n+\t\t}\n+\n+\t\t// We keep the directory if we can import it, or if we can't import it\n+\t\t// due to invalid Go source files. This means that directories containing\n+\t\t// parse errors will be built (and fail) instead of being silently skipped\n+\t\t// as not matching the pattern. Go 1.5 and earlier skipped, but that\n+\t\t// behavior means people miss serious mistakes.\n+\t\t// See golang.org/issue/11407.\n+\t\tif p, err := cfg.BuildContext.ImportDir(path, 0); err != nil && (p == nil || len(p.InvalidGoFiles) == 0) {\n+\t\t\tif _, noGo := err.(*build.NoGoError); !noGo {\n+\t\t\t\tlog.Print(err)\n+\t\t\t}\n+\t\t\treturn nil\n+\t\t}\n+\t\tpkgs = append(pkgs, name)\n+\t\treturn nil\n+\t})\n+\treturn pkgs\n+}\n+\n+// treeCanMatchPattern(pattern)(name) reports whether\n+// name or children of name can possibly match pattern.\n+// Pattern is the same limited glob accepted by matchPattern.\n+func treeCanMatchPattern(pattern string) func(name string) bool {\n+\twildCard := false\n+\tif i := strings.Index(pattern, \"...\"); i >= 0 {\n+\t\twildCard = true\n+\t\tpattern = pattern[:i]\n+\t}\n+\treturn func(name string) bool {\n+\t\treturn len(name) <= len(pattern) && hasPathPrefix(pattern, name) ||\n+\t\t\twildCard && strings.HasPrefix(name, pattern)\n+\t}\n+}\n+\n+// matchPattern(pattern)(name) reports whether\n+// name matches pattern. Pattern is a limited glob\n+// pattern in which '...' means 'any string' and there\n+// is no other special syntax.\n+// Unfortunately, there are two special cases. Quoting \"go help packages\":\n+//\n+// First, /... at the end of the pattern can match an empty string,\n+// so that net/... matches both net and packages in its subdirectories, like net/http.\n+// Second, any slash-separted pattern element containing a wildcard never\n+// participates in a match of the \"vendor\" element in the path of a vendored\n+// package, so that ./... does not match packages in subdirectories of\n+// ./vendor or ./mycode/vendor, but ./vendor/... and ./mycode/vendor/... do.\n+// Note, however, that a directory named vendor that itself contains code\n+// is not a vendored package: cmd/vendor would be a command named vendor,\n+// and the pattern cmd/... matches it.\n+func matchPattern(pattern string) func(name string) bool {\n+\t// Convert pattern to regular expression.\n+\t// The strategy for the trailing /... is to nest it in an explicit ? expression.\n+\t// The strategy for the vendor exclusion is to change the unmatchable\n+\t// vendor strings to a disallowed code point (vendorChar) and to use\n+\t// \"(anything but that codepoint)*\" as the implementation of the ... wildcard.\n+\t// This is a bit complicated but the obvious alternative,\n+\t// namely a hand-written search like in most shell glob matchers,\n+\t// is too easy to make accidentally exponential.\n+\t// Using package regexp guarantees linear-time matching.\n+\n+\tconst vendorChar = \"\\x00\"\n+\n+\tif strings.Contains(pattern, vendorChar) {\n+\t\treturn func(name string) bool { return false }\n+\t}\n+\n+\tre := regexp.QuoteMeta(pattern)\n+\tre = replaceVendor(re, vendorChar)\n+\tswitch {\n+\tcase strings.HasSuffix(re, `/`+vendorChar+`/\\.\\.\\.`):\n+\t\tre = strings.TrimSuffix(re, `/`+vendorChar+`/\\.\\.\\.`) + `(/vendor|/` + vendorChar + `/\\.\\.\\.)`\n+\tcase re == vendorChar+`/\\.\\.\\.`:\n+\t\tre = `(/vendor|/` + vendorChar + `/\\.\\.\\.)`\n+\tcase strings.HasSuffix(re, `/\\.\\.\\.`):\n+\t\tre = strings.TrimSuffix(re, `/\\.\\.\\.`) + `(/\\.\\.\\.)?`\n+\t}\n+\tre = strings.Replace(re, `\\.\\.\\.`, `[^`+vendorChar+`]*`, -1)\n+\n+\treg := regexp.MustCompile(`^` + re + `$`)\n+\n+\treturn func(name string) bool {\n+\t\tif strings.Contains(name, vendorChar) {\n+\t\t\treturn false\n+\t\t}\n+\t\treturn reg.MatchString(replaceVendor(name, vendorChar))\n+\t}\n+}\n+\n+// replaceVendor returns the result of replacing\n+// non-trailing vendor path elements in x with repl.\n+func replaceVendor(x, repl string) string {\n+\tif !strings.Contains(x, \"vendor\") {\n+\t\treturn x\n+\t}\n+\telem := strings.Split(x, \"/\")\n+\tfor i := 0; i < len(elem)-1; i++ {\n+\t\tif elem[i] == \"vendor\" {\n+\t\t\telem[i] = repl\n+\t\t}\n+\t}\n+\treturn strings.Join(elem, \"/\")\n+}\n+\n+// ImportPaths returns the import paths to use for the given command line.\n+func ImportPaths(args []string) []string {\n+\targs = ImportPathsNoDotExpansion(args)\n+\tvar out []string\n+\tfor _, a := range args {\n+\t\tif strings.Contains(a, \"...\") {\n+\t\t\tif build.IsLocalImport(a) {\n+\t\t\t\tout = append(out, allPackagesInFS(a)...)\n+\t\t\t} else {\n+\t\t\t\tout = append(out, allPackages(a)...)\n+\t\t\t}\n+\t\t\tcontinue\n+\t\t}\n+\t\tout = append(out, a)\n+\t}\n+\treturn out\n+}\n+\n+// ImportPathsNoDotExpansion returns the import paths to use for the given\n+// command line, but it does no ... expansion.\n+func ImportPathsNoDotExpansion(args []string) []string {\n+\tif len(args) == 0 {\n+\t\treturn []string{\".\"}\n+\t}\n+\tvar out []string\n+\tfor _, a := range args {\n+\t\t// Arguments are supposed to be import paths, but\n+\t\t// as a courtesy to Windows developers, rewrite \\ to /\n+\t\t// in command-line arguments. Handles .\\... and so on.\n+\t\tif filepath.Separator == '\\\\' {\n+\t\t\ta = strings.Replace(a, `\\`, `/`, -1)\n+\t\t}\n+\n+\t\t// Put argument in canonical form, but preserve leading ./.\n+\t\tif strings.HasPrefix(a, \"./\") {\n+\t\t\ta = \"./\" + path.Clean(a)\n+\t\t\tif a == \"./.\" {\n+\t\t\t\ta = \".\"\n+\t\t\t}\n+\t\t} else {\n+\t\t\ta = path.Clean(a)\n+\t\t}\n+\t\tif IsMetaPackage(a) {\n+\t\t\tout = append(out, allPackages(a)...)\n+\t\t\tcontinue\n+\t\t}\n+\t\tout = append(out, a)\n+\t}\n+\treturn out\n+}\n+\n+// isMetaPackage checks if name is a reserved package name that expands to multiple packages.\n+func IsMetaPackage(name string) bool {\n+\treturn name == \"std\" || name == \"cmd\" || name == \"all\"\n+}"}, {"sha": "7734048f5c98d99a246ea21fa3779edef936944e", "filename": "libgo/go/cmd/go/internal/load/testgo.go", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Ftestgo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Ftestgo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Ftestgo.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -10,7 +10,7 @@\n \n // +build testgo\n \n-package main\n+package load\n \n import \"os\"\n ", "previous_filename": "libgo/go/cmd/go/testgo.go"}, {"sha": "6e276c28ec19f96f59caed7531c4c2dc3e281348", "filename": "libgo/go/cmd/go/internal/run/run.go", "status": "renamed", "additions": 42, "deletions": 67, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frun%2Frun.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frun%2Frun.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frun%2Frun.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -2,34 +2,22 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-package main\n+// Package run implements the ``go run'' command.\n+package run\n \n import (\n \t\"fmt\"\n \t\"os\"\n-\t\"os/exec\"\n-\t\"runtime\"\n \t\"strings\"\n-)\n-\n-var execCmd []string // -exec flag, for run and test\n \n-func findExecCmd() []string {\n-\tif execCmd != nil {\n-\t\treturn execCmd\n-\t}\n-\texecCmd = []string{} // avoid work the second time\n-\tif goos == runtime.GOOS && goarch == runtime.GOARCH {\n-\t\treturn execCmd\n-\t}\n-\tpath, err := exec.LookPath(fmt.Sprintf(\"go_%s_%s_exec\", goos, goarch))\n-\tif err == nil {\n-\t\texecCmd = []string{path}\n-\t}\n-\treturn execCmd\n-}\n+\t\"cmd/go/internal/base\"\n+\t\"cmd/go/internal/cfg\"\n+\t\"cmd/go/internal/load\"\n+\t\"cmd/go/internal/str\"\n+\t\"cmd/go/internal/work\"\n+)\n \n-var cmdRun = &Command{\n+var CmdRun = &base.Command{\n \tUsageLine: \"run [build flags] [-exec xprog] gofiles... [arguments...]\",\n \tShort:     \"compile and run Go program\",\n \tLong: `\n@@ -53,60 +41,60 @@ See also: go build.\n }\n \n func init() {\n-\tcmdRun.Run = runRun // break init loop\n+\tCmdRun.Run = runRun // break init loop\n \n-\taddBuildFlags(cmdRun)\n-\tcmdRun.Flag.Var((*stringsFlag)(&execCmd), \"exec\", \"\")\n+\twork.AddBuildFlags(CmdRun)\n+\tCmdRun.Flag.Var((*base.StringsFlag)(&work.ExecCmd), \"exec\", \"\")\n }\n \n func printStderr(args ...interface{}) (int, error) {\n \treturn fmt.Fprint(os.Stderr, args...)\n }\n \n-func runRun(cmd *Command, args []string) {\n-\tinstrumentInit()\n-\tbuildModeInit()\n-\tvar b builder\n-\tb.init()\n-\tb.print = printStderr\n+func runRun(cmd *base.Command, args []string) {\n+\twork.InstrumentInit()\n+\twork.BuildModeInit()\n+\tvar b work.Builder\n+\tb.Init()\n+\tb.Print = printStderr\n \ti := 0\n \tfor i < len(args) && strings.HasSuffix(args[i], \".go\") {\n \t\ti++\n \t}\n \tfiles, cmdArgs := args[:i], args[i:]\n \tif len(files) == 0 {\n-\t\tfatalf(\"go run: no go files listed\")\n+\t\tbase.Fatalf(\"go run: no go files listed\")\n \t}\n \tfor _, file := range files {\n \t\tif strings.HasSuffix(file, \"_test.go\") {\n-\t\t\t// goFilesPackage is going to assign this to TestGoFiles.\n+\t\t\t// GoFilesPackage is going to assign this to TestGoFiles.\n \t\t\t// Reject since it won't be part of the build.\n-\t\t\tfatalf(\"go run: cannot run *_test.go files (%s)\", file)\n+\t\t\tbase.Fatalf(\"go run: cannot run *_test.go files (%s)\", file)\n \t\t}\n \t}\n-\tp := goFilesPackage(files)\n+\tp := load.GoFilesPackage(files)\n \tif p.Error != nil {\n-\t\tfatalf(\"%s\", p.Error)\n+\t\tbase.Fatalf(\"%s\", p.Error)\n \t}\n-\tp.omitDWARF = true\n+\tp.Internal.OmitDebug = true\n \tif len(p.DepsErrors) > 0 {\n \t\t// Since these are errors in dependencies,\n \t\t// the same error might show up multiple times,\n \t\t// once in each package that depends on it.\n \t\t// Only print each once.\n-\t\tprinted := map[*PackageError]bool{}\n+\t\tprinted := map[*load.PackageError]bool{}\n \t\tfor _, err := range p.DepsErrors {\n \t\t\tif !printed[err] {\n \t\t\t\tprinted[err] = true\n-\t\t\t\terrorf(\"%s\", err)\n+\t\t\t\tbase.Errorf(\"%s\", err)\n \t\t\t}\n \t\t}\n \t}\n-\texitIfErrors()\n+\tbase.ExitIfErrors()\n \tif p.Name != \"main\" {\n-\t\tfatalf(\"go run: cannot run non-main package\")\n+\t\tbase.Fatalf(\"go run: cannot run non-main package\")\n \t}\n-\tp.target = \"\" // must build - not up to date\n+\tp.Internal.Target = \"\" // must build - not up to date\n \tvar src string\n \tif len(p.GoFiles) > 0 {\n \t\tsrc = p.GoFiles[0]\n@@ -116,41 +104,28 @@ func runRun(cmd *Command, args []string) {\n \t\t// this case could only happen if the provided source uses cgo\n \t\t// while cgo is disabled.\n \t\thint := \"\"\n-\t\tif !buildContext.CgoEnabled {\n+\t\tif !cfg.BuildContext.CgoEnabled {\n \t\t\thint = \" (cgo is disabled)\"\n \t\t}\n-\t\tfatalf(\"go run: no suitable source files%s\", hint)\n+\t\tbase.Fatalf(\"go run: no suitable source files%s\", hint)\n \t}\n-\tp.exeName = src[:len(src)-len(\".go\")] // name temporary executable for first go file\n-\ta1 := b.action(modeBuild, modeBuild, p)\n-\ta := &action{f: (*builder).runProgram, args: cmdArgs, deps: []*action{a1}}\n-\tb.do(a)\n+\tp.Internal.ExeName = src[:len(src)-len(\".go\")] // name temporary executable for first go file\n+\ta1 := b.Action(work.ModeBuild, work.ModeBuild, p)\n+\ta := &work.Action{Func: buildRunProgram, Args: cmdArgs, Deps: []*work.Action{a1}}\n+\tb.Do(a)\n }\n \n-// runProgram is the action for running a binary that has already\n+// buildRunProgram is the action for running a binary that has already\n // been compiled. We ignore exit status.\n-func (b *builder) runProgram(a *action) error {\n-\tcmdline := stringList(findExecCmd(), a.deps[0].target, a.args)\n-\tif buildN || buildX {\n-\t\tb.showcmd(\"\", \"%s\", strings.Join(cmdline, \" \"))\n-\t\tif buildN {\n+func buildRunProgram(b *work.Builder, a *work.Action) error {\n+\tcmdline := str.StringList(work.FindExecCmd(), a.Deps[0].Target, a.Args)\n+\tif cfg.BuildN || cfg.BuildX {\n+\t\tb.Showcmd(\"\", \"%s\", strings.Join(cmdline, \" \"))\n+\t\tif cfg.BuildN {\n \t\t\treturn nil\n \t\t}\n \t}\n \n-\trunStdin(cmdline)\n+\tbase.RunStdin(cmdline)\n \treturn nil\n }\n-\n-// runStdin is like run, but connects Stdin.\n-func runStdin(cmdline []string) {\n-\tcmd := exec.Command(cmdline[0], cmdline[1:]...)\n-\tcmd.Stdin = os.Stdin\n-\tcmd.Stdout = os.Stdout\n-\tcmd.Stderr = os.Stderr\n-\tcmd.Env = origEnv\n-\tstartSigHandlers()\n-\tif err := cmd.Run(); err != nil {\n-\t\terrorf(\"%v\", err)\n-\t}\n-}", "previous_filename": "libgo/go/cmd/go/run.go"}, {"sha": "0413ed8e69e19992effa8e68a7ff57e2222cc2fd", "filename": "libgo/go/cmd/go/internal/str/str.go", "status": "added", "additions": 141, "deletions": 0, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fstr%2Fstr.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fstr%2Fstr.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fstr%2Fstr.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -0,0 +1,141 @@\n+// Copyright 2017 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Package str provides string manipulation utilities.\n+package str\n+\n+import (\n+\t\"bytes\"\n+\t\"fmt\"\n+\t\"unicode\"\n+\t\"unicode/utf8\"\n+)\n+\n+// StringList flattens its arguments into a single []string.\n+// Each argument in args must have type string or []string.\n+func StringList(args ...interface{}) []string {\n+\tvar x []string\n+\tfor _, arg := range args {\n+\t\tswitch arg := arg.(type) {\n+\t\tcase []string:\n+\t\t\tx = append(x, arg...)\n+\t\tcase string:\n+\t\t\tx = append(x, arg)\n+\t\tdefault:\n+\t\t\tpanic(\"stringList: invalid argument of type \" + fmt.Sprintf(\"%T\", arg))\n+\t\t}\n+\t}\n+\treturn x\n+}\n+\n+// ToFold returns a string with the property that\n+//\tstrings.EqualFold(s, t) iff ToFold(s) == ToFold(t)\n+// This lets us test a large set of strings for fold-equivalent\n+// duplicates without making a quadratic number of calls\n+// to EqualFold. Note that strings.ToUpper and strings.ToLower\n+// do not have the desired property in some corner cases.\n+func ToFold(s string) string {\n+\t// Fast path: all ASCII, no upper case.\n+\t// Most paths look like this already.\n+\tfor i := 0; i < len(s); i++ {\n+\t\tc := s[i]\n+\t\tif c >= utf8.RuneSelf || 'A' <= c && c <= 'Z' {\n+\t\t\tgoto Slow\n+\t\t}\n+\t}\n+\treturn s\n+\n+Slow:\n+\tvar buf bytes.Buffer\n+\tfor _, r := range s {\n+\t\t// SimpleFold(x) cycles to the next equivalent rune > x\n+\t\t// or wraps around to smaller values. Iterate until it wraps,\n+\t\t// and we've found the minimum value.\n+\t\tfor {\n+\t\t\tr0 := r\n+\t\t\tr = unicode.SimpleFold(r0)\n+\t\t\tif r <= r0 {\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t}\n+\t\t// Exception to allow fast path above: A-Z => a-z\n+\t\tif 'A' <= r && r <= 'Z' {\n+\t\t\tr += 'a' - 'A'\n+\t\t}\n+\t\tbuf.WriteRune(r)\n+\t}\n+\treturn buf.String()\n+}\n+\n+// FoldDup reports a pair of strings from the list that are\n+// equal according to strings.EqualFold.\n+// It returns \"\", \"\" if there are no such strings.\n+func FoldDup(list []string) (string, string) {\n+\tclash := map[string]string{}\n+\tfor _, s := range list {\n+\t\tfold := ToFold(s)\n+\t\tif t := clash[fold]; t != \"\" {\n+\t\t\tif s > t {\n+\t\t\t\ts, t = t, s\n+\t\t\t}\n+\t\t\treturn s, t\n+\t\t}\n+\t\tclash[fold] = s\n+\t}\n+\treturn \"\", \"\"\n+}\n+\n+// Contains reports whether x contains s.\n+func Contains(x []string, s string) bool {\n+\tfor _, t := range x {\n+\t\tif t == s {\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\treturn false\n+}\n+\n+func isSpaceByte(c byte) bool {\n+\treturn c == ' ' || c == '\\t' || c == '\\n' || c == '\\r'\n+}\n+\n+// SplitQuotedFields splits s into a list of fields,\n+// allowing single or double quotes around elements.\n+// There is no unescaping or other processing within\n+// quoted fields.\n+func SplitQuotedFields(s string) ([]string, error) {\n+\t// Split fields allowing '' or \"\" around elements.\n+\t// Quotes further inside the string do not count.\n+\tvar f []string\n+\tfor len(s) > 0 {\n+\t\tfor len(s) > 0 && isSpaceByte(s[0]) {\n+\t\t\ts = s[1:]\n+\t\t}\n+\t\tif len(s) == 0 {\n+\t\t\tbreak\n+\t\t}\n+\t\t// Accepted quoted string. No unescaping inside.\n+\t\tif s[0] == '\"' || s[0] == '\\'' {\n+\t\t\tquote := s[0]\n+\t\t\ts = s[1:]\n+\t\t\ti := 0\n+\t\t\tfor i < len(s) && s[i] != quote {\n+\t\t\t\ti++\n+\t\t\t}\n+\t\t\tif i >= len(s) {\n+\t\t\t\treturn nil, fmt.Errorf(\"unterminated %c string\", quote)\n+\t\t\t}\n+\t\t\tf = append(f, s[:i])\n+\t\t\ts = s[i+1:]\n+\t\t\tcontinue\n+\t\t}\n+\t\ti := 0\n+\t\tfor i < len(s) && !isSpaceByte(s[i]) {\n+\t\t\ti++\n+\t\t}\n+\t\tf = append(f, s[:i])\n+\t\ts = s[i:]\n+\t}\n+\treturn f, nil\n+}"}, {"sha": "c1e66f9e88963bfb6901f1cbecf1a44fc3d2f530", "filename": "libgo/go/cmd/go/internal/test/test.go", "status": "renamed", "additions": 333, "deletions": 316, "changes": 649, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Ftest.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Ftest.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Ftest.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-package main\n+package test\n \n import (\n \t\"bytes\"\n@@ -25,16 +25,22 @@ import (\n \t\"time\"\n \t\"unicode\"\n \t\"unicode/utf8\"\n+\n+\t\"cmd/go/internal/base\"\n+\t\"cmd/go/internal/cfg\"\n+\t\"cmd/go/internal/load\"\n+\t\"cmd/go/internal/str\"\n+\t\"cmd/go/internal/work\"\n )\n \n // Break init loop.\n func init() {\n-\tcmdTest.Run = runTest\n+\tCmdTest.Run = runTest\n }\n \n const testUsage = \"test [build/test flags] [packages] [build/test flags & test binary flags]\"\n \n-var cmdTest = &Command{\n+var CmdTest = &base.Command{\n \tCustomFlags: true,\n \tUsageLine:   testUsage,\n \tShort:       \"test packages\",\n@@ -53,7 +59,7 @@ followed by detailed output for each failed package.\n the file pattern \"*_test.go\".\n Files whose names begin with \"_\" (including \"_test.go\") or \".\" are ignored.\n These additional files can contain test functions, benchmark functions, and\n-example functions.  See 'go help testfunc' for more.\n+example functions. See 'go help testfunc' for more.\n Each listed package causes the execution of a separate test binary.\n \n Test files that declare a package with the suffix \"_test\" will be compiled as a\n@@ -62,7 +68,7 @@ separate package, and then linked and run with the main test binary.\n The go tool will ignore a directory named \"testdata\", making it available\n to hold ancillary data needed by the tests.\n \n-By default, go test needs no arguments.  It compiles and tests the package\n+By default, go test needs no arguments. It compiles and tests the package\n with source in the current directory, including tests, and runs the tests.\n \n The package is built in a temporary directory so it does not interfere with the\n@@ -107,7 +113,15 @@ The test binary also accepts flags that control execution of the test; these\n flags are also accessible by 'go test'.\n `\n \n-var helpTestflag = &Command{\n+// Usage prints the usage message for 'go test -h' and exits.\n+func Usage() {\n+\tos.Stderr.WriteString(testUsage + \"\\n\\n\" +\n+\t\tstrings.TrimSpace(testFlag1) + \"\\n\\n\\t\" +\n+\t\tstrings.TrimSpace(testFlag2) + \"\\n\")\n+\tos.Exit(2)\n+}\n+\n+var HelpTestflag = &base.Command{\n \tUsageLine: \"testflag\",\n \tShort:     \"description of testing flags\",\n \tLong: `\n@@ -116,7 +130,7 @@ and flags that apply to the resulting test binary.\n \n Several of the flags control profiling and write an execution profile\n suitable for \"go tool pprof\"; run \"go tool pprof -h\" for more\n-information.  The --alloc_space, --alloc_objects, and --show_bytes\n+information. The --alloc_space, --alloc_objects, and --show_bytes\n options of pprof control how the information is presented.\n \n The following flags are recognized by the 'go test' command and\n@@ -128,12 +142,17 @@ control the execution of any test:\n \n const testFlag2 = `\n \t-bench regexp\n-\t    Run (sub)benchmarks matching a regular expression.\n-\t    The given regular expression is split into smaller ones by\n-\t    top-level '/', where each must match the corresponding part of a\n-\t    benchmark's identifier.\n-\t    By default, no benchmarks run. To run all benchmarks,\n-\t    use '-bench .' or '-bench=.'.\n+\t    Run only those benchmarks matching a regular expression.\n+\t    By default, no benchmarks are run. \n+\t    To run all benchmarks, use '-bench .' or '-bench=.'.\n+\t    The regular expression is split by unbracketed slash (/)\n+\t    characters into a sequence of regular expressions, and each\n+\t    part of a benchmark's identifier must match the corresponding\n+\t    element in the sequence, if any. Possible parents of matches\n+\t    are run with b.N=1 to identify sub-benchmarks. For example,\n+\t    given -bench=X/Y, top-level benchmarks matching X are run\n+\t    with b.N=1 to find any sub-benchmarks matching Y, which are\n+\t    then run in full.\n \n \t-benchtime t\n \t    Run enough iterations of each benchmark to take t, specified\n@@ -147,6 +166,10 @@ const testFlag2 = `\n \n \t-cover\n \t    Enable coverage analysis.\n+\t    Note that because coverage works by annotating the source\n+\t    code before compilation, compilation and test failures with\n+\t    coverage enabled may report line numbers that don't correspond\n+\t    to the original sources.\n \n \t-covermode set,count,atomic\n \t    Set the mode for coverage analysis for the package[s]\n@@ -167,9 +190,14 @@ const testFlag2 = `\n \n \t-cpu 1,2,4\n \t    Specify a list of GOMAXPROCS values for which the tests or\n-\t    benchmarks should be executed.  The default is the current value\n+\t    benchmarks should be executed. The default is the current value\n \t    of GOMAXPROCS.\n \n+\t-list regexp\n+\t    List tests, benchmarks, or examples matching the regular expression.\n+\t    No tests, benchmarks or examples will be run. This will only\n+\t    list top-level tests. No subtest or subbenchmarks will be shown.\n+\n \t-parallel n\n \t    Allow parallel execution of test functions that call t.Parallel.\n \t    The value of this flag is the maximum number of tests to run\n@@ -181,18 +209,22 @@ const testFlag2 = `\n \n \t-run regexp\n \t    Run only those tests and examples matching the regular expression.\n-\t    For tests the regular expression is split into smaller ones by\n-\t    top-level '/', where each must match the corresponding part of a\n-\t    test's identifier.\n+\t    For tests, the regular expression is split by unbracketed slash (/)\n+\t    characters into a sequence of regular expressions, and each part\n+\t    of a test's identifier must match the corresponding element in\n+\t    the sequence, if any. Note that possible parents of matches are\n+\t    run too, so that -run=X/Y matches and runs and reports the result\n+\t    of all tests matching X, even those without sub-tests matching Y,\n+\t    because it must run them to look for those sub-tests.\n \n \t-short\n \t    Tell long-running tests to shorten their run time.\n \t    It is off by default but set during all.bash so that installing\n \t    the Go tree can run a sanity check but not spend time running\n \t    exhaustive tests.\n \n-\t-timeout t\n-\t    If a test runs longer than t, panic.\n+\t-timeout d\n+\t    If a test binary runs longer than duration d, panic.\n \t    The default is 10 minutes (10m).\n \n \t-v\n@@ -215,7 +247,7 @@ profile the tests during execution:\n \t    calling runtime.SetBlockProfileRate with n.\n \t    See 'go doc runtime.SetBlockProfileRate'.\n \t    The profiler aims to sample, on average, one blocking event every\n-\t    n nanoseconds the program spends blocked.  By default,\n+\t    n nanoseconds the program spends blocked. By default,\n \t    if -test.blockprofile is set without this flag, all blocking events\n \t    are recorded, equivalent to -test.blockprofilerate=1.\n \n@@ -233,7 +265,7 @@ profile the tests during execution:\n \n \t-memprofilerate n\n \t    Enable more precise (and expensive) memory profiles by setting\n-\t    runtime.MemProfileRate.  See 'go doc runtime.MemProfileRate'.\n+\t    runtime.MemProfileRate. See 'go doc runtime.MemProfileRate'.\n \t    To profile all memory allocations, use -test.memprofilerate=1\n \t    and pass --alloc_space flag to the pprof tool.\n \n@@ -312,7 +344,7 @@ In the second example, the argument math is passed through to the test\n binary, instead of being interpreted as the package list.\n `\n \n-var helpTestfunc = &Command{\n+var HelpTestfunc = &base.Command{\n \tUsageLine: \"testfunc\",\n \tShort:     \"description of testing functions\",\n \tLong: `\n@@ -338,8 +370,8 @@ comment is compiled but not executed. An example with no text after\n \"Output:\" is compiled, executed, and expected to produce no output.\n \n Godoc displays the body of ExampleXXX to demonstrate the use\n-of the function, constant, or variable XXX.  An example of a method M with\n-receiver type T or *T is named ExampleT_M.  There may be multiple examples\n+of the function, constant, or variable XXX. An example of a method M with\n+receiver type T or *T is named ExampleT_M. There may be multiple examples\n for a given function, constant, or variable, distinguished by a trailing _xxx,\n where xxx is a suffix not beginning with an upper case letter.\n \n@@ -374,18 +406,19 @@ See the documentation of the testing package for more information.\n }\n \n var (\n-\ttestC            bool       // -c flag\n-\ttestCover        bool       // -cover flag\n-\ttestCoverMode    string     // -covermode flag\n-\ttestCoverPaths   []string   // -coverpkg flag\n-\ttestCoverPkgs    []*Package // -coverpkg flag\n-\ttestO            string     // -o flag\n-\ttestProfile      bool       // some profiling flag\n-\ttestNeedBinary   bool       // profile needs to keep binary around\n-\ttestV            bool       // -v flag\n-\ttestTimeout      string     // -timeout flag\n+\ttestC            bool            // -c flag\n+\ttestCover        bool            // -cover flag\n+\ttestCoverMode    string          // -covermode flag\n+\ttestCoverPaths   []string        // -coverpkg flag\n+\ttestCoverPkgs    []*load.Package // -coverpkg flag\n+\ttestO            string          // -o flag\n+\ttestProfile      bool            // some profiling flag\n+\ttestNeedBinary   bool            // profile needs to keep binary around\n+\ttestV            bool            // -v flag\n+\ttestTimeout      string          // -timeout flag\n \ttestArgs         []string\n \ttestBench        bool\n+\ttestList         bool\n \ttestStreamOutput bool // show output as it is generated\n \ttestShowPass     bool // show passing output\n \n@@ -399,27 +432,27 @@ var testMainDeps = map[string]bool{\n \t\"os\": true,\n }\n \n-func runTest(cmd *Command, args []string) {\n+func runTest(cmd *base.Command, args []string) {\n \tvar pkgArgs []string\n \tpkgArgs, testArgs = testFlags(args)\n \n-\tfindExecCmd() // initialize cached result\n+\twork.FindExecCmd() // initialize cached result\n \n-\tinstrumentInit()\n-\tbuildModeInit()\n-\tpkgs := packagesForBuild(pkgArgs)\n+\twork.InstrumentInit()\n+\twork.BuildModeInit()\n+\tpkgs := load.PackagesForBuild(pkgArgs)\n \tif len(pkgs) == 0 {\n-\t\tfatalf(\"no packages to test\")\n+\t\tbase.Fatalf(\"no packages to test\")\n \t}\n \n \tif testC && len(pkgs) != 1 {\n-\t\tfatalf(\"cannot use -c flag with multiple packages\")\n+\t\tbase.Fatalf(\"cannot use -c flag with multiple packages\")\n \t}\n \tif testO != \"\" && len(pkgs) != 1 {\n-\t\tfatalf(\"cannot use -o flag with multiple packages\")\n+\t\tbase.Fatalf(\"cannot use -o flag with multiple packages\")\n \t}\n \tif testProfile && len(pkgs) != 1 {\n-\t\tfatalf(\"cannot use test profile flag with multiple packages\")\n+\t\tbase.Fatalf(\"cannot use test profile flag with multiple packages\")\n \t}\n \n \t// If a test timeout was given and is parseable, set our kill timeout\n@@ -433,7 +466,7 @@ func runTest(cmd *Command, args []string) {\n \t// show passing test output (after buffering) with -v flag.\n \t// must buffer because tests are running in parallel, and\n \t// otherwise the output will get mixed.\n-\ttestShowPass = testV\n+\ttestShowPass = testV || testList\n \n \t// stream test output (no buffering) when no package has\n \t// been given on the command line (implicit current directory)\n@@ -443,18 +476,18 @@ func runTest(cmd *Command, args []string) {\n \t// In these cases, streaming the output produces the same result\n \t// as not streaming, just more immediately.\n \ttestStreamOutput = len(pkgArgs) == 0 || testBench ||\n-\t\t(testShowPass && (len(pkgs) == 1 || buildP == 1))\n+\t\t(testShowPass && (len(pkgs) == 1 || cfg.BuildP == 1))\n \n \t// For 'go test -i -o x.test', we want to build x.test. Imply -c to make the logic easier.\n-\tif buildI && testO != \"\" {\n+\tif cfg.BuildI && testO != \"\" {\n \t\ttestC = true\n \t}\n \n-\tvar b builder\n-\tb.init()\n+\tvar b work.Builder\n+\tb.Init()\n \n-\tif buildI {\n-\t\tbuildV = testV\n+\tif cfg.BuildI {\n+\t\tcfg.BuildV = testV\n \n \t\tdeps := make(map[string]bool)\n \t\tfor dep := range testMainDeps {\n@@ -466,10 +499,10 @@ func runTest(cmd *Command, args []string) {\n \t\t\tfor _, path := range p.Imports {\n \t\t\t\tdeps[path] = true\n \t\t\t}\n-\t\t\tfor _, path := range p.vendored(p.TestImports) {\n+\t\t\tfor _, path := range p.Vendored(p.TestImports) {\n \t\t\t\tdeps[path] = true\n \t\t\t}\n-\t\t\tfor _, path := range p.vendored(p.XTestImports) {\n+\t\t\tfor _, path := range p.Vendored(p.XTestImports) {\n \t\t\t\tdeps[path] = true\n \t\t\t}\n \t\t}\n@@ -478,7 +511,7 @@ func runTest(cmd *Command, args []string) {\n \t\tif deps[\"C\"] {\n \t\t\tdelete(deps, \"C\")\n \t\t\tdeps[\"runtime/cgo\"] = true\n-\t\t\tif goos == runtime.GOOS && goarch == runtime.GOARCH && !buildRace && !buildMSan {\n+\t\t\tif cfg.Goos == runtime.GOOS && cfg.Goarch == runtime.GOARCH && !cfg.BuildRace && !cfg.BuildMSan {\n \t\t\t\tdeps[\"cmd/cgo\"] = true\n \t\t\t}\n \t\t}\n@@ -493,26 +526,26 @@ func runTest(cmd *Command, args []string) {\n \t\t}\n \t\tsort.Strings(all)\n \n-\t\ta := &action{}\n-\t\tfor _, p := range packagesForBuild(all) {\n-\t\t\tif !reqStdPkgSrc && p.Standard {\n+\t\ta := &work.Action{}\n+\t\tfor _, p := range load.PackagesForBuild(all) {\n+\t\t\tif cfg.BuildToolchainName == \"gccgo\" && p.Standard {\n \t\t\t\tcontinue\n \t\t\t}\n-\t\t\ta.deps = append(a.deps, b.action(modeInstall, modeInstall, p))\n+\t\t\ta.Deps = append(a.Deps, b.Action(work.ModeInstall, work.ModeInstall, p))\n \t\t}\n-\t\tb.do(a)\n-\t\tif !testC || a.failed {\n+\t\tb.Do(a)\n+\t\tif !testC || a.Failed {\n \t\t\treturn\n \t\t}\n-\t\tb.init()\n+\t\tb.Init()\n \t}\n \n-\tvar builds, runs, prints []*action\n+\tvar builds, runs, prints []*work.Action\n \n \tif testCoverPaths != nil {\n \t\t// Load packages that were asked about for coverage.\n \t\t// packagesForBuild exits if the packages cannot be loaded.\n-\t\ttestCoverPkgs = packagesForBuild(testCoverPaths)\n+\t\ttestCoverPkgs = load.PackagesForBuild(testCoverPaths)\n \n \t\t// Warn about -coverpkg arguments that are not actually used.\n \t\tused := make(map[string]bool)\n@@ -536,13 +569,13 @@ func runTest(cmd *Command, args []string) {\n \t\t\t}\n \t\t\tp.Stale = true // rebuild\n \t\t\tp.StaleReason = \"rebuild for coverage\"\n-\t\t\tp.fake = true // do not warn about rebuild\n-\t\t\tp.coverMode = testCoverMode\n+\t\t\tp.Internal.Fake = true // do not warn about rebuild\n+\t\t\tp.Internal.CoverMode = testCoverMode\n \t\t\tvar coverFiles []string\n \t\t\tcoverFiles = append(coverFiles, p.GoFiles...)\n \t\t\tcoverFiles = append(coverFiles, p.CgoFiles...)\n \t\t\tcoverFiles = append(coverFiles, p.TestGoFiles...)\n-\t\t\tp.coverVars = declareCoverVars(p.ImportPath, coverFiles...)\n+\t\t\tp.Internal.CoverVars = declareCoverVars(p.ImportPath, coverFiles...)\n \t\t}\n \t}\n \n@@ -552,7 +585,8 @@ func runTest(cmd *Command, args []string) {\n \t\tif testCover && testCoverMode == \"atomic\" {\n \t\t\tensureImport(p, \"sync/atomic\")\n \t\t}\n-\t\tbuildTest, runTest, printTest, err := b.test(p)\n+\n+\t\tbuildTest, runTest, printTest, err := builderTest(&b, p)\n \t\tif err != nil {\n \t\t\tstr := err.Error()\n \t\t\tif strings.HasPrefix(str, \"\\n\") {\n@@ -561,9 +595,9 @@ func runTest(cmd *Command, args []string) {\n \t\t\tfailed := fmt.Sprintf(\"FAIL\\t%s [setup failed]\\n\", p.ImportPath)\n \n \t\t\tif p.ImportPath != \"\" {\n-\t\t\t\terrorf(\"# %s\\n%s\\n%s\", p.ImportPath, str, failed)\n+\t\t\t\tbase.Errorf(\"# %s\\n%s\\n%s\", p.ImportPath, str, failed)\n \t\t\t} else {\n-\t\t\t\terrorf(\"%s\\n%s\", str, failed)\n+\t\t\t\tbase.Errorf(\"%s\\n%s\", str, failed)\n \t\t\t}\n \t\t\tcontinue\n \t\t}\n@@ -573,13 +607,13 @@ func runTest(cmd *Command, args []string) {\n \t}\n \n \t// Ultimately the goal is to print the output.\n-\troot := &action{deps: prints}\n+\troot := &work.Action{Deps: prints}\n \n \t// Force the printing of results to happen in order,\n \t// one at a time.\n \tfor i, a := range prints {\n \t\tif i > 0 {\n-\t\t\ta.deps = append(a.deps, prints[i-1])\n+\t\t\ta.Deps = append(a.Deps, prints[i-1])\n \t\t}\n \t}\n \n@@ -589,40 +623,40 @@ func runTest(cmd *Command, args []string) {\n \t\t// Later runs must wait for the previous run's print.\n \t\tfor i, run := range runs {\n \t\t\tif i == 0 {\n-\t\t\t\trun.deps = append(run.deps, builds...)\n+\t\t\t\trun.Deps = append(run.Deps, builds...)\n \t\t\t} else {\n-\t\t\t\trun.deps = append(run.deps, prints[i-1])\n+\t\t\t\trun.Deps = append(run.Deps, prints[i-1])\n \t\t\t}\n \t\t}\n \t}\n \n \t// If we are building any out-of-date packages other\n \t// than those under test, warn.\n-\tokBuild := map[*Package]bool{}\n+\tokBuild := map[*load.Package]bool{}\n \tfor _, p := range pkgs {\n \t\tokBuild[p] = true\n \t}\n \twarned := false\n-\tfor _, a := range actionList(root) {\n-\t\tif a.p == nil || okBuild[a.p] {\n+\tfor _, a := range work.ActionList(root) {\n+\t\tif a.Package == nil || okBuild[a.Package] {\n \t\t\tcontinue\n \t\t}\n-\t\tokBuild[a.p] = true // warn at most once\n+\t\tokBuild[a.Package] = true // warn at most once\n \n \t\t// Don't warn about packages being rebuilt because of\n \t\t// things like coverage analysis.\n-\t\tfor _, p1 := range a.p.imports {\n-\t\t\tif p1.fake {\n-\t\t\t\ta.p.fake = true\n+\t\tfor _, p1 := range a.Package.Internal.Imports {\n+\t\t\tif p1.Internal.Fake {\n+\t\t\t\ta.Package.Internal.Fake = true\n \t\t\t}\n \t\t}\n \n-\t\tif a.f != nil && !okBuild[a.p] && !a.p.fake && !a.p.local {\n+\t\tif a.Func != nil && !okBuild[a.Package] && !a.Package.Internal.Fake && !a.Package.Internal.Local {\n \t\t\tif !warned {\n \t\t\t\tfmt.Fprintf(os.Stderr, \"warning: building out-of-date packages:\\n\")\n \t\t\t\twarned = true\n \t\t\t}\n-\t\t\tfmt.Fprintf(os.Stderr, \"\\t%s\\n\", a.p.ImportPath)\n+\t\t\tfmt.Fprintf(os.Stderr, \"\\t%s\\n\", a.Package.ImportPath)\n \t\t}\n \t}\n \tif warned {\n@@ -631,42 +665,33 @@ func runTest(cmd *Command, args []string) {\n \t\t\targs = \" \" + args\n \t\t}\n \t\textraOpts := \"\"\n-\t\tif buildRace {\n+\t\tif cfg.BuildRace {\n \t\t\textraOpts = \"-race \"\n \t\t}\n-\t\tif buildMSan {\n+\t\tif cfg.BuildMSan {\n \t\t\textraOpts = \"-msan \"\n \t\t}\n \t\tfmt.Fprintf(os.Stderr, \"installing these packages with 'go test %s-i%s' will speed future tests.\\n\\n\", extraOpts, args)\n \t}\n \n-\tb.do(root)\n+\tb.Do(root)\n }\n \n-// ensures that package p imports the named package.\n-func ensureImport(p *Package, pkg string) {\n-\tfor _, d := range p.deps {\n+// ensures that package p imports the named package\n+func ensureImport(p *load.Package, pkg string) {\n+\tfor _, d := range p.Internal.Deps {\n \t\tif d.Name == pkg {\n \t\t\treturn\n \t\t}\n \t}\n \n-\ta := loadPackage(pkg, &importStack{})\n+\ta := load.LoadPackage(pkg, &load.ImportStack{})\n \tif a.Error != nil {\n-\t\tfatalf(\"load %s: %v\", pkg, a.Error)\n+\t\tbase.Fatalf(\"load %s: %v\", pkg, a.Error)\n \t}\n-\tcomputeStale(a)\n-\n-\tp.imports = append(p.imports, a)\n-}\n+\tload.ComputeStale(a)\n \n-func contains(x []string, s string) bool {\n-\tfor _, t := range x {\n-\t\tif t == s {\n-\t\t\treturn true\n-\t\t}\n-\t}\n-\treturn false\n+\tp.Internal.Imports = append(p.Internal.Imports, a)\n }\n \n var windowsBadWords = []string{\n@@ -676,26 +701,26 @@ var windowsBadWords = []string{\n \t\"update\",\n }\n \n-func (b *builder) test(p *Package) (buildAction, runAction, printAction *action, err error) {\n+func builderTest(b *work.Builder, p *load.Package) (buildAction, runAction, printAction *work.Action, err error) {\n \tif len(p.TestGoFiles)+len(p.XTestGoFiles) == 0 {\n-\t\tbuild := b.action(modeBuild, modeBuild, p)\n-\t\trun := &action{p: p, deps: []*action{build}}\n-\t\tprint := &action{f: (*builder).notest, p: p, deps: []*action{run}}\n+\t\tbuild := b.Action(work.ModeBuild, work.ModeBuild, p)\n+\t\trun := &work.Action{Package: p, Deps: []*work.Action{build}}\n+\t\tprint := &work.Action{Func: builderNoTest, Package: p, Deps: []*work.Action{run}}\n \t\treturn build, run, print, nil\n \t}\n \n \t// Build Package structs describing:\n \t//\tptest - package + test files\n \t//\tpxtest - package of external test files\n \t//\tpmain - pkg.test binary\n-\tvar ptest, pxtest, pmain *Package\n+\tvar ptest, pxtest, pmain *load.Package\n \n-\tvar imports, ximports []*Package\n-\tvar stk importStack\n-\tstk.push(p.ImportPath + \" (test)\")\n+\tvar imports, ximports []*load.Package\n+\tvar stk load.ImportStack\n+\tstk.Push(p.ImportPath + \" (test)\")\n \tfor i, path := range p.TestImports {\n-\t\tp1 := loadImport(path, p.Dir, p, &stk, p.build.TestImportPos[path], useVendor)\n-\t\tif !reqStdPkgSrc && p1.Standard {\n+\t\tp1 := load.LoadImport(path, p.Dir, p, &stk, p.Internal.Build.TestImportPos[path], load.UseVendor)\n+\t\tif cfg.BuildToolchainName == \"gccgo\" && p1.Standard {\n \t\t\tcontinue\n \t\t}\n \t\tif p1.Error != nil {\n@@ -706,26 +731,26 @@ func (b *builder) test(p *Package) (buildAction, runAction, printAction *action,\n \t\t\terr.Pos = \"\" // show full import stack\n \t\t\treturn nil, nil, nil, err\n \t\t}\n-\t\tif contains(p1.Deps, p.ImportPath) || p1.ImportPath == p.ImportPath {\n+\t\tif str.Contains(p1.Deps, p.ImportPath) || p1.ImportPath == p.ImportPath {\n \t\t\t// Same error that loadPackage returns (via reusePackage) in pkg.go.\n \t\t\t// Can't change that code, because that code is only for loading the\n \t\t\t// non-test copy of a package.\n-\t\t\terr := &PackageError{\n+\t\t\terr := &load.PackageError{\n \t\t\t\tImportStack:   testImportStack(stk[0], p1, p.ImportPath),\n \t\t\t\tErr:           \"import cycle not allowed in test\",\n-\t\t\t\tisImportCycle: true,\n+\t\t\t\tIsImportCycle: true,\n \t\t\t}\n \t\t\treturn nil, nil, nil, err\n \t\t}\n \t\tp.TestImports[i] = p1.ImportPath\n \t\timports = append(imports, p1)\n \t}\n-\tstk.pop()\n-\tstk.push(p.ImportPath + \"_test\")\n+\tstk.Pop()\n+\tstk.Push(p.ImportPath + \"_test\")\n \tpxtestNeedsPtest := false\n \tfor i, path := range p.XTestImports {\n-\t\tp1 := loadImport(path, p.Dir, p, &stk, p.build.XTestImportPos[path], useVendor)\n-\t\tif !reqStdPkgSrc && p1.Standard {\n+\t\tp1 := load.LoadImport(path, p.Dir, p, &stk, p.Internal.Build.XTestImportPos[path], load.UseVendor)\n+\t\tif cfg.BuildToolchainName == \"gccgo\" && p1.Standard {\n \t\t\tcontinue\n \t\t}\n \t\tif p1.Error != nil {\n@@ -743,7 +768,7 @@ func (b *builder) test(p *Package) (buildAction, runAction, printAction *action,\n \t\t}\n \t\tp.XTestImports[i] = p1.ImportPath\n \t}\n-\tstk.pop()\n+\tstk.Pop()\n \n \t// Use last element of import path, not package name.\n \t// They differ when package name is \"main\".\n@@ -771,12 +796,12 @@ func (b *builder) test(p *Package) (buildAction, runAction, printAction *action,\n \t// $WORK/unicode/utf8/_test/unicode/utf8.a.\n \t// We write the external test package archive to\n \t// $WORK/unicode/utf8/_test/unicode/utf8_test.a.\n-\ttestDir := filepath.Join(b.work, filepath.FromSlash(p.ImportPath+\"/_test\"))\n-\tptestObj := buildToolchain.pkgpath(testDir, p)\n+\ttestDir := filepath.Join(b.WorkDir, filepath.FromSlash(p.ImportPath+\"/_test\"))\n+\tptestObj := work.BuildToolchain.Pkgpath(testDir, p)\n \n \t// Create the directory for the .a files.\n \tptestDir, _ := filepath.Split(ptestObj)\n-\tif err := b.mkdir(ptestDir); err != nil {\n+\tif err := b.Mkdir(ptestDir); err != nil {\n \t\treturn nil, nil, nil, err\n \t}\n \n@@ -788,106 +813,114 @@ func (b *builder) test(p *Package) (buildAction, runAction, printAction *action,\n \n \t// Test package.\n \tif len(p.TestGoFiles) > 0 || localCover || p.Name == \"main\" {\n-\t\tptest = new(Package)\n+\t\tptest = new(load.Package)\n \t\t*ptest = *p\n \t\tptest.GoFiles = nil\n \t\tptest.GoFiles = append(ptest.GoFiles, p.GoFiles...)\n \t\tptest.GoFiles = append(ptest.GoFiles, p.TestGoFiles...)\n-\t\tptest.target = \"\"\n-\t\tptest.Imports = stringList(p.Imports, p.TestImports)\n-\t\tptest.imports = append(append([]*Package{}, p.imports...), imports...)\n-\t\tptest.pkgdir = testDir\n-\t\tptest.fake = true\n-\t\tptest.forceLibrary = true\n+\t\tptest.Internal.Target = \"\"\n+\t\tptest.Imports = str.StringList(p.Imports, p.TestImports)\n+\t\tptest.Internal.Imports = append(append([]*load.Package{}, p.Internal.Imports...), imports...)\n+\t\tptest.Internal.Pkgdir = testDir\n+\t\tptest.Internal.Fake = true\n+\t\tptest.Internal.ForceLibrary = true\n \t\tptest.Stale = true\n \t\tptest.StaleReason = \"rebuild for test\"\n-\t\tptest.build = new(build.Package)\n-\t\t*ptest.build = *p.build\n+\t\tptest.Internal.Build = new(build.Package)\n+\t\t*ptest.Internal.Build = *p.Internal.Build\n \t\tm := map[string][]token.Position{}\n-\t\tfor k, v := range p.build.ImportPos {\n+\t\tfor k, v := range p.Internal.Build.ImportPos {\n \t\t\tm[k] = append(m[k], v...)\n \t\t}\n-\t\tfor k, v := range p.build.TestImportPos {\n+\t\tfor k, v := range p.Internal.Build.TestImportPos {\n \t\t\tm[k] = append(m[k], v...)\n \t\t}\n-\t\tptest.build.ImportPos = m\n+\t\tptest.Internal.Build.ImportPos = m\n \n \t\tif localCover {\n-\t\t\tptest.coverMode = testCoverMode\n+\t\t\tptest.Internal.CoverMode = testCoverMode\n \t\t\tvar coverFiles []string\n \t\t\tcoverFiles = append(coverFiles, ptest.GoFiles...)\n \t\t\tcoverFiles = append(coverFiles, ptest.CgoFiles...)\n-\t\t\tptest.coverVars = declareCoverVars(ptest.ImportPath, coverFiles...)\n+\t\t\tptest.Internal.CoverVars = declareCoverVars(ptest.ImportPath, coverFiles...)\n \t\t}\n \t} else {\n \t\tptest = p\n \t}\n \n \t// External test package.\n \tif len(p.XTestGoFiles) > 0 {\n-\t\tpxtest = &Package{\n-\t\t\tName:        p.Name + \"_test\",\n-\t\t\tImportPath:  p.ImportPath + \"_test\",\n-\t\t\tlocalPrefix: p.localPrefix,\n-\t\t\tRoot:        p.Root,\n-\t\t\tDir:         p.Dir,\n-\t\t\tGoFiles:     p.XTestGoFiles,\n-\t\t\tImports:     p.XTestImports,\n-\t\t\tbuild: &build.Package{\n-\t\t\t\tImportPos: p.build.XTestImportPos,\n+\t\tpxtest = &load.Package{\n+\t\t\tPackagePublic: load.PackagePublic{\n+\t\t\t\tName:       p.Name + \"_test\",\n+\t\t\t\tImportPath: p.ImportPath + \"_test\",\n+\t\t\t\tRoot:       p.Root,\n+\t\t\t\tDir:        p.Dir,\n+\t\t\t\tGoFiles:    p.XTestGoFiles,\n+\t\t\t\tImports:    p.XTestImports,\n+\t\t\t\tStale:      true,\n+\t\t\t},\n+\t\t\tInternal: load.PackageInternal{\n+\t\t\t\tLocalPrefix: p.Internal.LocalPrefix,\n+\t\t\t\tBuild: &build.Package{\n+\t\t\t\t\tImportPos: p.Internal.Build.XTestImportPos,\n+\t\t\t\t},\n+\t\t\t\tImports:  ximports,\n+\t\t\t\tPkgdir:   testDir,\n+\t\t\t\tFake:     true,\n+\t\t\t\tExternal: true,\n \t\t\t},\n-\t\t\timports:  ximports,\n-\t\t\tpkgdir:   testDir,\n-\t\t\tfake:     true,\n-\t\t\texternal: true,\n-\t\t\tStale:    true,\n \t\t}\n \t\tif pxtestNeedsPtest {\n-\t\t\tpxtest.imports = append(pxtest.imports, ptest)\n+\t\t\tpxtest.Internal.Imports = append(pxtest.Internal.Imports, ptest)\n \t\t}\n \t}\n \n \t// Action for building pkg.test.\n-\tpmain = &Package{\n-\t\tName:       \"main\",\n-\t\tDir:        testDir,\n-\t\tGoFiles:    []string{\"_testmain.go\"},\n-\t\tImportPath: \"testmain\",\n-\t\tRoot:       p.Root,\n-\t\tbuild:      &build.Package{Name: \"main\"},\n-\t\tpkgdir:     testDir,\n-\t\tfake:       true,\n-\t\tStale:      true,\n-\t\tomitDWARF:  !testC && !testNeedBinary,\n+\tpmain = &load.Package{\n+\t\tPackagePublic: load.PackagePublic{\n+\t\t\tName:       \"main\",\n+\t\t\tDir:        testDir,\n+\t\t\tGoFiles:    []string{\"_testmain.go\"},\n+\t\t\tImportPath: \"testmain\",\n+\t\t\tRoot:       p.Root,\n+\t\t\tStale:      true,\n+\t\t},\n+\t\tInternal: load.PackageInternal{\n+\t\t\tBuild:     &build.Package{Name: \"main\"},\n+\t\t\tPkgdir:    testDir,\n+\t\t\tFake:      true,\n+\t\t\tOmitDebug: !testC && !testNeedBinary,\n+\t\t},\n \t}\n \n \t// The generated main also imports testing, regexp, and os.\n-\tstk.push(\"testmain\")\n+\tstk.Push(\"testmain\")\n \tfor dep := range testMainDeps {\n \t\tif dep == ptest.ImportPath {\n-\t\t\tpmain.imports = append(pmain.imports, ptest)\n+\t\t\tpmain.Internal.Imports = append(pmain.Internal.Imports, ptest)\n \t\t} else {\n-\t\t\tp1 := loadImport(dep, \"\", nil, &stk, nil, 0)\n-\t\t\tif !reqStdPkgSrc && p1.Standard {\n+\t\t\tp1 := load.LoadImport(dep, \"\", nil, &stk, nil, 0)\n+\t\t\tif cfg.BuildToolchainName == \"gccgo\" && p1.Standard {\n \t\t\t\tcontinue\n \t\t\t}\n \t\t\tif p1.Error != nil {\n \t\t\t\treturn nil, nil, nil, p1.Error\n \t\t\t}\n-\t\t\tpmain.imports = append(pmain.imports, p1)\n+\t\t\tpmain.Internal.Imports = append(pmain.Internal.Imports, p1)\n \t\t}\n \t}\n \n \tif testCoverPkgs != nil {\n \t\t// Add imports, but avoid duplicates.\n-\t\tseen := map[*Package]bool{p: true, ptest: true}\n-\t\tfor _, p1 := range pmain.imports {\n+\t\tseen := map[*load.Package]bool{p: true, ptest: true}\n+\t\tfor _, p1 := range pmain.Internal.Imports {\n \t\t\tseen[p1] = true\n \t\t}\n \t\tfor _, p1 := range testCoverPkgs {\n \t\t\tif !seen[p1] {\n \t\t\t\tseen[p1] = true\n-\t\t\t\tpmain.imports = append(pmain.imports, p1)\n+\t\t\t\tpmain.Internal.Imports = append(pmain.Internal.Imports, p1)\n \t\t\t}\n \t\t}\n \t}\n@@ -901,11 +934,11 @@ func (b *builder) test(p *Package) (buildAction, runAction, printAction *action,\n \t\treturn nil, nil, nil, err\n \t}\n \tif len(ptest.GoFiles)+len(ptest.CgoFiles) > 0 {\n-\t\tpmain.imports = append(pmain.imports, ptest)\n+\t\tpmain.Internal.Imports = append(pmain.Internal.Imports, ptest)\n \t\tt.ImportTest = true\n \t}\n \tif pxtest != nil {\n-\t\tpmain.imports = append(pmain.imports, pxtest)\n+\t\tpmain.Internal.Imports = append(pmain.Internal.Imports, pxtest)\n \t\tt.ImportXtest = true\n \t}\n \n@@ -925,52 +958,48 @@ func (b *builder) test(p *Package) (buildAction, runAction, printAction *action,\n \t\trecompileForTest(pmain, p, ptest, testDir)\n \t}\n \n-\tif buildContext.GOOS == \"darwin\" {\n-\t\tif buildContext.GOARCH == \"arm\" || buildContext.GOARCH == \"arm64\" {\n-\t\t\tt.IsIOS = true\n-\t\t\tt.NeedOS = true\n+\tif cfg.BuildContext.GOOS == \"darwin\" {\n+\t\tif cfg.BuildContext.GOARCH == \"arm\" || cfg.BuildContext.GOARCH == \"arm64\" {\n+\t\t\tt.NeedCgo = true\n \t\t}\n \t}\n-\tif t.TestMain == nil {\n-\t\tt.NeedOS = true\n-\t}\n \n-\tfor _, cp := range pmain.imports {\n-\t\tif len(cp.coverVars) > 0 {\n-\t\t\tt.Cover = append(t.Cover, coverInfo{cp, cp.coverVars})\n+\tfor _, cp := range pmain.Internal.Imports {\n+\t\tif len(cp.Internal.CoverVars) > 0 {\n+\t\t\tt.Cover = append(t.Cover, coverInfo{cp, cp.Internal.CoverVars})\n \t\t}\n \t}\n \n-\tif !buildN {\n+\tif !cfg.BuildN {\n \t\t// writeTestmain writes _testmain.go. This must happen after recompileForTest,\n \t\t// because recompileForTest modifies XXX.\n \t\tif err := writeTestmain(filepath.Join(testDir, \"_testmain.go\"), t); err != nil {\n \t\t\treturn nil, nil, nil, err\n \t\t}\n \t}\n \n-\tcomputeStale(pmain)\n+\tload.ComputeStale(pmain)\n \n \tif ptest != p {\n-\t\ta := b.action(modeBuild, modeBuild, ptest)\n-\t\ta.objdir = testDir + string(filepath.Separator) + \"_obj_test\" + string(filepath.Separator)\n-\t\ta.objpkg = ptestObj\n-\t\ta.target = ptestObj\n-\t\ta.link = false\n+\t\ta := b.Action(work.ModeBuild, work.ModeBuild, ptest)\n+\t\ta.Objdir = testDir + string(filepath.Separator) + \"_obj_test\" + string(filepath.Separator)\n+\t\ta.Objpkg = ptestObj\n+\t\ta.Target = ptestObj\n+\t\ta.Link = false\n \t}\n \n \tif pxtest != nil {\n-\t\ta := b.action(modeBuild, modeBuild, pxtest)\n-\t\ta.objdir = testDir + string(filepath.Separator) + \"_obj_xtest\" + string(filepath.Separator)\n-\t\ta.objpkg = buildToolchain.pkgpath(testDir, pxtest)\n-\t\ta.target = a.objpkg\n+\t\ta := b.Action(work.ModeBuild, work.ModeBuild, pxtest)\n+\t\ta.Objdir = testDir + string(filepath.Separator) + \"_obj_xtest\" + string(filepath.Separator)\n+\t\ta.Objpkg = work.BuildToolchain.Pkgpath(testDir, pxtest)\n+\t\ta.Target = a.Objpkg\n \t}\n \n-\ta := b.action(modeBuild, modeBuild, pmain)\n-\ta.objdir = testDir + string(filepath.Separator)\n-\ta.objpkg = filepath.Join(testDir, \"main.a\")\n-\ta.target = filepath.Join(testDir, testBinary) + exeSuffix\n-\tif goos == \"windows\" {\n+\ta := b.Action(work.ModeBuild, work.ModeBuild, pmain)\n+\ta.Objdir = testDir + string(filepath.Separator)\n+\ta.Objpkg = filepath.Join(testDir, \"main.a\")\n+\ta.Target = filepath.Join(testDir, testBinary) + cfg.ExeSuffix\n+\tif cfg.Goos == \"windows\" {\n \t\t// There are many reserved words on Windows that,\n \t\t// if used in the name of an executable, cause Windows\n \t\t// to try to ask for extra permissions.\n@@ -995,7 +1024,7 @@ func (b *builder) test(p *Package) (buildAction, runAction, printAction *action,\n \t\t// we could just do this always on Windows.\n \t\tfor _, bad := range windowsBadWords {\n \t\t\tif strings.Contains(testBinary, bad) {\n-\t\t\t\ta.target = filepath.Join(testDir, \"test.test\") + exeSuffix\n+\t\t\t\ta.Target = filepath.Join(testDir, \"test.test\") + cfg.ExeSuffix\n \t\t\t\tbreak\n \t\t\t}\n \t\t}\n@@ -1004,52 +1033,52 @@ func (b *builder) test(p *Package) (buildAction, runAction, printAction *action,\n \n \tif testC || testNeedBinary {\n \t\t// -c or profiling flag: create action to copy binary to ./test.out.\n-\t\ttarget := filepath.Join(cwd, testBinary+exeSuffix)\n+\t\ttarget := filepath.Join(base.Cwd, testBinary+cfg.ExeSuffix)\n \t\tif testO != \"\" {\n \t\t\ttarget = testO\n \t\t\tif !filepath.IsAbs(target) {\n-\t\t\t\ttarget = filepath.Join(cwd, target)\n+\t\t\t\ttarget = filepath.Join(base.Cwd, target)\n \t\t\t}\n \t\t}\n-\t\tbuildAction = &action{\n-\t\t\tf:      (*builder).install,\n-\t\t\tdeps:   []*action{buildAction},\n-\t\t\tp:      pmain,\n-\t\t\ttarget: target,\n+\t\tbuildAction = &work.Action{\n+\t\t\tFunc:    work.BuildInstallFunc,\n+\t\t\tDeps:    []*work.Action{buildAction},\n+\t\t\tPackage: pmain,\n+\t\t\tTarget:  target,\n \t\t}\n \t\trunAction = buildAction // make sure runAction != nil even if not running test\n \t}\n \tif testC {\n-\t\tprintAction = &action{p: p, deps: []*action{runAction}} // nop\n+\t\tprintAction = &work.Action{Package: p, Deps: []*work.Action{runAction}} // nop\n \t} else {\n \t\t// run test\n-\t\trunAction = &action{\n-\t\t\tf:          (*builder).runTest,\n-\t\t\tdeps:       []*action{buildAction},\n-\t\t\tp:          p,\n-\t\t\tignoreFail: true,\n+\t\trunAction = &work.Action{\n+\t\t\tFunc:       builderRunTest,\n+\t\t\tDeps:       []*work.Action{buildAction},\n+\t\t\tPackage:    p,\n+\t\t\tIgnoreFail: true,\n \t\t}\n-\t\tcleanAction := &action{\n-\t\t\tf:    (*builder).cleanTest,\n-\t\t\tdeps: []*action{runAction},\n-\t\t\tp:    p,\n+\t\tcleanAction := &work.Action{\n+\t\t\tFunc:    builderCleanTest,\n+\t\t\tDeps:    []*work.Action{runAction},\n+\t\t\tPackage: p,\n \t\t}\n-\t\tprintAction = &action{\n-\t\t\tf:    (*builder).printTest,\n-\t\t\tdeps: []*action{cleanAction},\n-\t\t\tp:    p,\n+\t\tprintAction = &work.Action{\n+\t\t\tFunc:    builderPrintTest,\n+\t\t\tDeps:    []*work.Action{cleanAction},\n+\t\t\tPackage: p,\n \t\t}\n \t}\n \n \treturn buildAction, runAction, printAction, nil\n }\n \n-func testImportStack(top string, p *Package, target string) []string {\n+func testImportStack(top string, p *load.Package, target string) []string {\n \tstk := []string{top, p.ImportPath}\n Search:\n \tfor p.ImportPath != target {\n-\t\tfor _, p1 := range p.imports {\n-\t\t\tif p1.ImportPath == target || contains(p1.Deps, target) {\n+\t\tfor _, p1 := range p.Internal.Imports {\n+\t\t\tif p1.ImportPath == target || str.Contains(p1.Deps, target) {\n \t\t\t\tstk = append(stk, p1.ImportPath)\n \t\t\t\tp = p1\n \t\t\t\tcontinue Search\n@@ -1062,45 +1091,45 @@ Search:\n \treturn stk\n }\n \n-func recompileForTest(pmain, preal, ptest *Package, testDir string) {\n+func recompileForTest(pmain, preal, ptest *load.Package, testDir string) {\n \t// The \"test copy\" of preal is ptest.\n \t// For each package that depends on preal, make a \"test copy\"\n \t// that depends on ptest. And so on, up the dependency tree.\n-\ttestCopy := map[*Package]*Package{preal: ptest}\n-\tfor _, p := range packageList([]*Package{pmain}) {\n+\ttestCopy := map[*load.Package]*load.Package{preal: ptest}\n+\tfor _, p := range load.PackageList([]*load.Package{pmain}) {\n \t\t// Copy on write.\n \t\tdidSplit := false\n \t\tsplit := func() {\n \t\t\tif didSplit {\n \t\t\t\treturn\n \t\t\t}\n \t\t\tdidSplit = true\n-\t\t\tif p.pkgdir != testDir {\n-\t\t\t\tp1 := new(Package)\n+\t\t\tif p.Internal.Pkgdir != testDir {\n+\t\t\t\tp1 := new(load.Package)\n \t\t\t\ttestCopy[p] = p1\n \t\t\t\t*p1 = *p\n-\t\t\t\tp1.imports = make([]*Package, len(p.imports))\n-\t\t\t\tcopy(p1.imports, p.imports)\n+\t\t\t\tp1.Internal.Imports = make([]*load.Package, len(p.Internal.Imports))\n+\t\t\t\tcopy(p1.Internal.Imports, p.Internal.Imports)\n \t\t\t\tp = p1\n-\t\t\t\tp.pkgdir = testDir\n-\t\t\t\tp.target = \"\"\n-\t\t\t\tp.fake = true\n+\t\t\t\tp.Internal.Pkgdir = testDir\n+\t\t\t\tp.Internal.Target = \"\"\n+\t\t\t\tp.Internal.Fake = true\n \t\t\t\tp.Stale = true\n \t\t\t\tp.StaleReason = \"depends on package being tested\"\n \t\t\t}\n \t\t}\n \n-\t\t// Update p.deps and p.imports to use at test copies.\n-\t\tfor i, dep := range p.deps {\n+\t\t// Update p.Deps and p.Internal.Imports to use at test copies.\n+\t\tfor i, dep := range p.Internal.Deps {\n \t\t\tif p1 := testCopy[dep]; p1 != nil && p1 != dep {\n \t\t\t\tsplit()\n-\t\t\t\tp.deps[i] = p1\n+\t\t\t\tp.Internal.Deps[i] = p1\n \t\t\t}\n \t\t}\n-\t\tfor i, imp := range p.imports {\n+\t\tfor i, imp := range p.Internal.Imports {\n \t\t\tif p1 := testCopy[imp]; p1 != nil && p1 != imp {\n \t\t\t\tsplit()\n-\t\t\t\tp.imports[i] = p1\n+\t\t\t\tp.Internal.Imports[i] = p1\n \t\t\t}\n \t\t}\n \t}\n@@ -1117,13 +1146,13 @@ func isTestFile(file string) bool {\n \n // declareCoverVars attaches the required cover variables names\n // to the files, to be used when annotating the files.\n-func declareCoverVars(importPath string, files ...string) map[string]*CoverVar {\n-\tcoverVars := make(map[string]*CoverVar)\n+func declareCoverVars(importPath string, files ...string) map[string]*load.CoverVar {\n+\tcoverVars := make(map[string]*load.CoverVar)\n \tfor _, file := range files {\n \t\tif isTestFile(file) {\n \t\t\tcontinue\n \t\t}\n-\t\tcoverVars[file] = &CoverVar{\n+\t\tcoverVars[file] = &load.CoverVar{\n \t\t\tFile: filepath.Join(importPath, file),\n \t\t\tVar:  fmt.Sprintf(\"GoCover_%d\", coverIndex),\n \t\t}\n@@ -1134,29 +1163,29 @@ func declareCoverVars(importPath string, files ...string) map[string]*CoverVar {\n \n var noTestsToRun = []byte(\"\\ntesting: warning: no tests to run\\n\")\n \n-// runTest is the action for running a test binary.\n-func (b *builder) runTest(a *action) error {\n-\targs := stringList(findExecCmd(), a.deps[0].target, testArgs)\n-\ta.testOutput = new(bytes.Buffer)\n+// builderRunTest is the action for running a test binary.\n+func builderRunTest(b *work.Builder, a *work.Action) error {\n+\targs := str.StringList(work.FindExecCmd(), a.Deps[0].Target, testArgs)\n+\ta.TestOutput = new(bytes.Buffer)\n \n-\tif buildN || buildX {\n-\t\tb.showcmd(\"\", \"%s\", strings.Join(args, \" \"))\n-\t\tif buildN {\n+\tif cfg.BuildN || cfg.BuildX {\n+\t\tb.Showcmd(\"\", \"%s\", strings.Join(args, \" \"))\n+\t\tif cfg.BuildN {\n \t\t\treturn nil\n \t\t}\n \t}\n \n-\tif a.failed {\n+\tif a.Failed {\n \t\t// We were unable to build the binary.\n-\t\ta.failed = false\n-\t\tfmt.Fprintf(a.testOutput, \"FAIL\\t%s [build failed]\\n\", a.p.ImportPath)\n-\t\tsetExitStatus(1)\n+\t\ta.Failed = false\n+\t\tfmt.Fprintf(a.TestOutput, \"FAIL\\t%s [build failed]\\n\", a.Package.ImportPath)\n+\t\tbase.SetExitStatus(1)\n \t\treturn nil\n \t}\n \n \tcmd := exec.Command(args[0], args[1:]...)\n-\tcmd.Dir = a.p.Dir\n-\tcmd.Env = envForDir(cmd.Dir, origEnv)\n+\tcmd.Dir = a.Package.Dir\n+\tcmd.Env = base.EnvForDir(cmd.Dir, cfg.OrigEnv)\n \tvar buf bytes.Buffer\n \tif testStreamOutput {\n \t\tcmd.Stdout = os.Stdout\n@@ -1168,7 +1197,7 @@ func (b *builder) runTest(a *action) error {\n \n \t// If there are any local SWIG dependencies, we want to load\n \t// the shared library from the build directory.\n-\tif a.p.usesSwig() {\n+\tif a.Package.UsesSwig() {\n \t\tenv := cmd.Env\n \t\tfound := false\n \t\tprefix := \"LD_LIBRARY_PATH=\"\n@@ -1193,7 +1222,7 @@ func (b *builder) runTest(a *action) error {\n \t// running.\n \tif err == nil {\n \t\ttick := time.NewTimer(testKillTimeout)\n-\t\tstartSigHandlers()\n+\t\tbase.StartSigHandlers()\n \t\tdone := make(chan error)\n \t\tgo func() {\n \t\t\tdone <- cmd.Wait()\n@@ -1203,14 +1232,14 @@ func (b *builder) runTest(a *action) error {\n \t\tcase err = <-done:\n \t\t\t// ok\n \t\tcase <-tick.C:\n-\t\t\tif signalTrace != nil {\n+\t\t\tif base.SignalTrace != nil {\n \t\t\t\t// Send a quit signal in the hope that the program will print\n \t\t\t\t// a stack trace and exit. Give it five seconds before resorting\n \t\t\t\t// to Kill.\n-\t\t\t\tcmd.Process.Signal(signalTrace)\n+\t\t\t\tcmd.Process.Signal(base.SignalTrace)\n \t\t\t\tselect {\n \t\t\t\tcase err = <-done:\n-\t\t\t\t\tfmt.Fprintf(&buf, \"*** Test killed with %v: ran too long (%v).\\n\", signalTrace, testKillTimeout)\n+\t\t\t\t\tfmt.Fprintf(&buf, \"*** Test killed with %v: ran too long (%v).\\n\", base.SignalTrace, testKillTimeout)\n \t\t\t\t\tbreak Outer\n \t\t\t\tcase <-time.After(5 * time.Second):\n \t\t\t\t}\n@@ -1226,23 +1255,23 @@ func (b *builder) runTest(a *action) error {\n \tif err == nil {\n \t\tnorun := \"\"\n \t\tif testShowPass {\n-\t\t\ta.testOutput.Write(out)\n+\t\t\ta.TestOutput.Write(out)\n \t\t}\n \t\tif bytes.HasPrefix(out, noTestsToRun[1:]) || bytes.Contains(out, noTestsToRun) {\n \t\t\tnorun = \" [no tests to run]\"\n \t\t}\n-\t\tfmt.Fprintf(a.testOutput, \"ok  \\t%s\\t%s%s%s\\n\", a.p.ImportPath, t, coveragePercentage(out), norun)\n+\t\tfmt.Fprintf(a.TestOutput, \"ok  \\t%s\\t%s%s%s\\n\", a.Package.ImportPath, t, coveragePercentage(out), norun)\n \t\treturn nil\n \t}\n \n-\tsetExitStatus(1)\n+\tbase.SetExitStatus(1)\n \tif len(out) > 0 {\n-\t\ta.testOutput.Write(out)\n+\t\ta.TestOutput.Write(out)\n \t\t// assume printing the test binary's exit status is superfluous\n \t} else {\n-\t\tfmt.Fprintf(a.testOutput, \"%s\\n\", err)\n+\t\tfmt.Fprintf(a.TestOutput, \"%s\\n\", err)\n \t}\n-\tfmt.Fprintf(a.testOutput, \"FAIL\\t%s\\t%s\\n\", a.p.ImportPath, t)\n+\tfmt.Fprintf(a.TestOutput, \"FAIL\\t%s\\t%s\\n\", a.Package.ImportPath, t)\n \n \treturn nil\n }\n@@ -1266,29 +1295,29 @@ func coveragePercentage(out []byte) string {\n \treturn fmt.Sprintf(\"\\tcoverage: %s\", matches[1])\n }\n \n-// cleanTest is the action for cleaning up after a test.\n-func (b *builder) cleanTest(a *action) error {\n-\tif buildWork {\n+// builderCleanTest is the action for cleaning up after a test.\n+func builderCleanTest(b *work.Builder, a *work.Action) error {\n+\tif cfg.BuildWork {\n \t\treturn nil\n \t}\n-\trun := a.deps[0]\n-\ttestDir := filepath.Join(b.work, filepath.FromSlash(run.p.ImportPath+\"/_test\"))\n+\trun := a.Deps[0]\n+\ttestDir := filepath.Join(b.WorkDir, filepath.FromSlash(run.Package.ImportPath+\"/_test\"))\n \tos.RemoveAll(testDir)\n \treturn nil\n }\n \n-// printTest is the action for printing a test result.\n-func (b *builder) printTest(a *action) error {\n-\tclean := a.deps[0]\n-\trun := clean.deps[0]\n-\tos.Stdout.Write(run.testOutput.Bytes())\n-\trun.testOutput = nil\n+// builderPrintTest is the action for printing a test result.\n+func builderPrintTest(b *work.Builder, a *work.Action) error {\n+\tclean := a.Deps[0]\n+\trun := clean.Deps[0]\n+\tos.Stdout.Write(run.TestOutput.Bytes())\n+\trun.TestOutput = nil\n \treturn nil\n }\n \n-// notest is the action for testing a package with no test files.\n-func (b *builder) notest(a *action) error {\n-\tfmt.Printf(\"?   \\t%s\\t[no test files]\\n\", a.p.ImportPath)\n+// builderNoTest is the action for testing a package with no test files.\n+func builderNoTest(b *work.Builder, a *work.Action) error {\n+\tfmt.Printf(\"?   \\t%s\\t[no test files]\\n\", a.Package.ImportPath)\n \treturn nil\n }\n \n@@ -1333,12 +1362,12 @@ func isTest(name, prefix string) bool {\n }\n \n type coverInfo struct {\n-\tPackage *Package\n-\tVars    map[string]*CoverVar\n+\tPackage *load.Package\n+\tVars    map[string]*load.CoverVar\n }\n \n // loadTestFuncs returns the testFuncs describing the tests that will be run.\n-func loadTestFuncs(ptest *Package) (*testFuncs, error) {\n+func loadTestFuncs(ptest *load.Package) (*testFuncs, error) {\n \tt := &testFuncs{\n \t\tPackage: ptest,\n \t}\n@@ -1375,13 +1404,12 @@ type testFuncs struct {\n \tBenchmarks  []testFunc\n \tExamples    []testFunc\n \tTestMain    *testFunc\n-\tPackage     *Package\n+\tPackage     *load.Package\n \tImportTest  bool\n \tNeedTest    bool\n \tImportXtest bool\n \tNeedXtest   bool\n-\tNeedOS      bool\n-\tIsIOS       bool\n+\tNeedCgo     bool\n \tCover       []coverInfo\n }\n \n@@ -1393,6 +1421,19 @@ func (t *testFuncs) CoverEnabled() bool {\n \treturn testCover\n }\n \n+// ImportPath returns the import path of the package being tested, if it is within GOPATH.\n+// This is printed by the testing package when running benchmarks.\n+func (t *testFuncs) ImportPath() string {\n+\tpkg := t.Package.ImportPath\n+\tif strings.HasPrefix(pkg, \"_/\") {\n+\t\treturn \"\"\n+\t}\n+\tif pkg == \"command-line-arguments\" {\n+\t\treturn \"\"\n+\t}\n+\treturn pkg\n+}\n+\n // Covered returns a string describing which packages are being tested for coverage.\n // If the covered package is the same as the tested package, it returns the empty string.\n // Otherwise it is a comma-separated human-readable list of packages beginning with\n@@ -1421,7 +1462,7 @@ var testFileSet = token.NewFileSet()\n func (t *testFuncs) load(filename, pkg string, doImport, seen *bool) error {\n \tf, err := parser.ParseFile(testFileSet, filename, nil, parser.ParseComments)\n \tif err != nil {\n-\t\treturn expandScanner(err)\n+\t\treturn base.ExpandScanner(err)\n \t}\n \tfor _, d := range f.Decls {\n \t\tn, ok := d.(*ast.FuncDecl)\n@@ -1482,7 +1523,7 @@ var testmainTmpl = template.Must(template.New(\"main\").Parse(`\n package main\n \n import (\n-{{if .NeedOS}}\n+{{if not .TestMain}}\n \t\"os\"\n {{end}}\n \t\"testing\"\n@@ -1498,10 +1539,8 @@ import (\n \t_cover{{$i}} {{$p.Package.ImportPath | printf \"%q\"}}\n {{end}}\n \n-{{if .IsIOS}}\n-\t\"os/signal\"\n+{{if .NeedCgo}}\n \t_ \"runtime/cgo\"\n-\t\"syscall\"\n {{end}}\n )\n \n@@ -1523,6 +1562,10 @@ var examples = []testing.InternalExample{\n {{end}}\n }\n \n+func init() {\n+\ttestdeps.ImportPath = {{.ImportPath | printf \"%q\"}}\n+}\n+\n {{if .CoverEnabled}}\n \n // Only updated by init functions, so no need for atomicity.\n@@ -1563,32 +1606,6 @@ func coverRegisterFile(fileName string, counter []uint32, pos []uint32, numStmts\n {{end}}\n \n func main() {\n-{{if .IsIOS}}\n-\t// Send a SIGUSR2, which will be intercepted by LLDB to\n-\t// tell the test harness that installation was successful.\n-\t// See misc/ios/go_darwin_arm_exec.go.\n-\tsignal.Notify(make(chan os.Signal), syscall.SIGUSR2)\n-\tsyscall.Kill(0, syscall.SIGUSR2)\n-\tsignal.Reset(syscall.SIGUSR2)\n-\n-\t// The first argument supplied to an iOS test is an offset\n-\t// suffix for the current working directory.\n-\t// Process it here, and remove it from os.Args.\n-\tconst hdr = \"cwdSuffix=\"\n-\tif len(os.Args) < 2 || len(os.Args[1]) <= len(hdr) || os.Args[1][:len(hdr)] != hdr {\n-\t\tpanic(\"iOS test not passed a working directory suffix\")\n-\t}\n-\tsuffix := os.Args[1][len(hdr):]\n-\tdir, err := os.Getwd()\n-\tif err != nil {\n-\t\tpanic(err)\n-\t}\n-\tif err := os.Chdir(dir + \"/\" + suffix); err != nil {\n-\t\tpanic(err)\n-\t}\n-\tos.Args = append([]string{os.Args[0]}, os.Args[2:]...)\n-{{end}}\n-\n {{if .CoverEnabled}}\n \ttesting.RegisterCover(testing.Cover{\n \t\tMode: {{printf \"%q\" .CoverMode}},", "previous_filename": "libgo/go/cmd/go/test.go"}, {"sha": "bff8656a4c1d2ab9066d66494df8e63e46da2df7", "filename": "libgo/go/cmd/go/internal/test/testflag.go", "status": "added", "additions": 211, "deletions": 0, "changes": 211, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Ftestflag.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Ftestflag.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Ftestflag.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -0,0 +1,211 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package test\n+\n+import (\n+\t\"flag\"\n+\t\"os\"\n+\t\"strings\"\n+\n+\t\"cmd/go/internal/base\"\n+\t\"cmd/go/internal/cfg\"\n+\t\"cmd/go/internal/cmdflag\"\n+\t\"cmd/go/internal/str\"\n+\t\"cmd/go/internal/work\"\n+)\n+\n+const cmd = \"test\"\n+\n+// The flag handling part of go test is large and distracting.\n+// We can't use the flag package because some of the flags from\n+// our command line are for us, and some are for 6.out, and\n+// some are for both.\n+\n+// testFlagDefn is the set of flags we process.\n+var testFlagDefn = []*cmdflag.Defn{\n+\t// local.\n+\t{Name: \"c\", BoolVar: &testC},\n+\t{Name: \"i\", BoolVar: &cfg.BuildI},\n+\t{Name: \"o\"},\n+\t{Name: \"cover\", BoolVar: &testCover},\n+\t{Name: \"covermode\"},\n+\t{Name: \"coverpkg\"},\n+\t{Name: \"exec\"},\n+\n+\t// Passed to 6.out, adding a \"test.\" prefix to the name if necessary: -v becomes -test.v.\n+\t{Name: \"bench\", PassToTest: true},\n+\t{Name: \"benchmem\", BoolVar: new(bool), PassToTest: true},\n+\t{Name: \"benchtime\", PassToTest: true},\n+\t{Name: \"count\", PassToTest: true},\n+\t{Name: \"coverprofile\", PassToTest: true},\n+\t{Name: \"cpu\", PassToTest: true},\n+\t{Name: \"cpuprofile\", PassToTest: true},\n+\t{Name: \"list\", PassToTest: true},\n+\t{Name: \"memprofile\", PassToTest: true},\n+\t{Name: \"memprofilerate\", PassToTest: true},\n+\t{Name: \"blockprofile\", PassToTest: true},\n+\t{Name: \"blockprofilerate\", PassToTest: true},\n+\t{Name: \"mutexprofile\", PassToTest: true},\n+\t{Name: \"mutexprofilefraction\", PassToTest: true},\n+\t{Name: \"outputdir\", PassToTest: true},\n+\t{Name: \"parallel\", PassToTest: true},\n+\t{Name: \"run\", PassToTest: true},\n+\t{Name: \"short\", BoolVar: new(bool), PassToTest: true},\n+\t{Name: \"timeout\", PassToTest: true},\n+\t{Name: \"trace\", PassToTest: true},\n+\t{Name: \"v\", BoolVar: &testV, PassToTest: true},\n+}\n+\n+// add build flags to testFlagDefn\n+func init() {\n+\tvar cmd base.Command\n+\twork.AddBuildFlags(&cmd)\n+\tcmd.Flag.VisitAll(func(f *flag.Flag) {\n+\t\tif f.Name == \"v\" {\n+\t\t\t// test overrides the build -v flag\n+\t\t\treturn\n+\t\t}\n+\t\ttestFlagDefn = append(testFlagDefn, &cmdflag.Defn{\n+\t\t\tName:  f.Name,\n+\t\t\tValue: f.Value,\n+\t\t})\n+\t})\n+}\n+\n+// testFlags processes the command line, grabbing -x and -c, rewriting known flags\n+// to have \"test\" before them, and reading the command line for the 6.out.\n+// Unfortunately for us, we need to do our own flag processing because go test\n+// grabs some flags but otherwise its command line is just a holding place for\n+// pkg.test's arguments.\n+// We allow known flags both before and after the package name list,\n+// to allow both\n+//\tgo test fmt -custom-flag-for-fmt-test\n+//\tgo test -x math\n+func testFlags(args []string) (packageNames, passToTest []string) {\n+\tinPkg := false\n+\toutputDir := \"\"\n+\tvar explicitArgs []string\n+\tfor i := 0; i < len(args); i++ {\n+\t\tif !strings.HasPrefix(args[i], \"-\") {\n+\t\t\tif !inPkg && packageNames == nil {\n+\t\t\t\t// First package name we've seen.\n+\t\t\t\tinPkg = true\n+\t\t\t}\n+\t\t\tif inPkg {\n+\t\t\t\tpackageNames = append(packageNames, args[i])\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t}\n+\n+\t\tif inPkg {\n+\t\t\t// Found an argument beginning with \"-\"; end of package list.\n+\t\t\tinPkg = false\n+\t\t}\n+\n+\t\tf, value, extraWord := cmdflag.Parse(cmd, testFlagDefn, args, i)\n+\t\tif f == nil {\n+\t\t\t// This is a flag we do not know; we must assume\n+\t\t\t// that any args we see after this might be flag\n+\t\t\t// arguments, not package names.\n+\t\t\tinPkg = false\n+\t\t\tif packageNames == nil {\n+\t\t\t\t// make non-nil: we have seen the empty package list\n+\t\t\t\tpackageNames = []string{}\n+\t\t\t}\n+\t\t\tif args[i] == \"-args\" || args[i] == \"--args\" {\n+\t\t\t\t// -args or --args signals that everything that follows\n+\t\t\t\t// should be passed to the test.\n+\t\t\t\texplicitArgs = args[i+1:]\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t\tpassToTest = append(passToTest, args[i])\n+\t\t\tcontinue\n+\t\t}\n+\t\tif f.Value != nil {\n+\t\t\tif err := f.Value.Set(value); err != nil {\n+\t\t\t\tbase.Fatalf(\"invalid flag argument for -%s: %v\", f.Name, err)\n+\t\t\t}\n+\t\t} else {\n+\t\t\t// Test-only flags.\n+\t\t\t// Arguably should be handled by f.Value, but aren't.\n+\t\t\tswitch f.Name {\n+\t\t\t// bool flags.\n+\t\t\tcase \"c\", \"i\", \"v\", \"cover\":\n+\t\t\t\tcmdflag.SetBool(cmd, f.BoolVar, value)\n+\t\t\tcase \"o\":\n+\t\t\t\ttestO = value\n+\t\t\t\ttestNeedBinary = true\n+\t\t\tcase \"exec\":\n+\t\t\t\txcmd, err := str.SplitQuotedFields(value)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tbase.Fatalf(\"invalid flag argument for -%s: %v\", f.Name, err)\n+\t\t\t\t}\n+\t\t\t\twork.ExecCmd = xcmd\n+\t\t\tcase \"bench\":\n+\t\t\t\t// record that we saw the flag; don't care about the value\n+\t\t\t\ttestBench = true\n+\t\t\tcase \"list\":\n+\t\t\t\ttestList = true\n+\t\t\tcase \"timeout\":\n+\t\t\t\ttestTimeout = value\n+\t\t\tcase \"blockprofile\", \"cpuprofile\", \"memprofile\", \"mutexprofile\":\n+\t\t\t\ttestProfile = true\n+\t\t\t\ttestNeedBinary = true\n+\t\t\tcase \"trace\":\n+\t\t\t\ttestProfile = true\n+\t\t\tcase \"coverpkg\":\n+\t\t\t\ttestCover = true\n+\t\t\t\tif value == \"\" {\n+\t\t\t\t\ttestCoverPaths = nil\n+\t\t\t\t} else {\n+\t\t\t\t\ttestCoverPaths = strings.Split(value, \",\")\n+\t\t\t\t}\n+\t\t\tcase \"coverprofile\":\n+\t\t\t\ttestCover = true\n+\t\t\t\ttestProfile = true\n+\t\t\tcase \"covermode\":\n+\t\t\t\tswitch value {\n+\t\t\t\tcase \"set\", \"count\", \"atomic\":\n+\t\t\t\t\ttestCoverMode = value\n+\t\t\t\tdefault:\n+\t\t\t\t\tbase.Fatalf(\"invalid flag argument for -covermode: %q\", value)\n+\t\t\t\t}\n+\t\t\t\ttestCover = true\n+\t\t\tcase \"outputdir\":\n+\t\t\t\toutputDir = value\n+\t\t\t}\n+\t\t}\n+\t\tif extraWord {\n+\t\t\ti++\n+\t\t}\n+\t\tif f.PassToTest {\n+\t\t\tpassToTest = append(passToTest, \"-test.\"+f.Name+\"=\"+value)\n+\t\t}\n+\t}\n+\n+\tif testCoverMode == \"\" {\n+\t\ttestCoverMode = \"set\"\n+\t\tif cfg.BuildRace {\n+\t\t\t// Default coverage mode is atomic when -race is set.\n+\t\t\ttestCoverMode = \"atomic\"\n+\t\t}\n+\t}\n+\n+\tif cfg.BuildRace && testCoverMode != \"atomic\" {\n+\t\tbase.Fatalf(`-covermode must be \"atomic\", not %q, when -race is enabled`, testCoverMode)\n+\t}\n+\n+\t// Tell the test what directory we're running in, so it can write the profiles there.\n+\tif testProfile && outputDir == \"\" {\n+\t\tdir, err := os.Getwd()\n+\t\tif err != nil {\n+\t\t\tbase.Fatalf(\"error from os.Getwd: %s\", err)\n+\t\t}\n+\t\tpassToTest = append(passToTest, \"-test.outputdir\", dir)\n+\t}\n+\n+\tpassToTest = append(passToTest, explicitArgs...)\n+\treturn\n+}"}, {"sha": "7dd5510328c924d0c59157dfceef15faf9e721c6", "filename": "libgo/go/cmd/go/internal/tool/tool.go", "status": "renamed", "additions": 30, "deletions": 68, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftool%2Ftool.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftool%2Ftool.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftool%2Ftool.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -2,20 +2,21 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-package main\n+// Package tool implements the ``go tool'' command.\n+package tool\n \n import (\n \t\"fmt\"\n-\t\"go/build\"\n \t\"os\"\n \t\"os/exec\"\n-\t\"path/filepath\"\n-\t\"runtime\"\n \t\"sort\"\n \t\"strings\"\n+\n+\t\"cmd/go/internal/base\"\n+\t\"cmd/go/internal/cfg\"\n )\n \n-var cmdTool = &Command{\n+var CmdTool = &base.Command{\n \tRun:       runTool,\n \tUsageLine: \"tool [-n] command [args...]\",\n \tShort:     \"run specified go tool\",\n@@ -30,53 +31,24 @@ For more about each tool command, see 'go tool command -h'.\n `,\n }\n \n-var (\n-\ttoolGOOS      = runtime.GOOS\n-\ttoolGOARCH    = runtime.GOARCH\n-\ttoolIsWindows = toolGOOS == \"windows\"\n-\ttoolDir       = build.ToolDir\n-\n-\ttoolN bool\n-)\n+var toolN bool\n \n-// List of go tools found in the gccgo tool directory.\n+// Return whether tool can be expected in the gccgo tool directory.\n // Other binaries could be in the same directory so don't\n // show those with the 'go tool' command.\n-\n-var gccgoTools = []string{\"cgo\", \"fix\", \"cover\", \"godoc\", \"vet\"}\n-\n-func init() {\n-\tcmdTool.Flag.BoolVar(&toolN, \"n\", false, \"\")\n-}\n-\n-const toolWindowsExtension = \".exe\"\n-\n-func tool(toolName string) string {\n-\ttoolPath := filepath.Join(toolDir, toolName)\n-\tif toolIsWindows {\n-\t\ttoolPath += toolWindowsExtension\n-\t}\n-\tif len(buildToolExec) > 0 {\n-\t\treturn toolPath\n+func isGccgoTool(tool string) bool {\n+\tswitch tool {\n+\tcase \"cgo\", \"fix\", \"cover\", \"godoc\", \"vet\":\n+\t\treturn true\n \t}\n-\t// Give a nice message if there is no tool with that name.\n-\tif _, err := os.Stat(toolPath); err != nil {\n-\t\tif isInGoToolsRepo(toolName) {\n-\t\t\tfmt.Fprintf(os.Stderr, \"go tool: no such tool %q; to install:\\n\\tgo get golang.org/x/tools/cmd/%s\\n\", toolName, toolName)\n-\t\t} else {\n-\t\t\tfmt.Fprintf(os.Stderr, \"go tool: no such tool %q\\n\", toolName)\n-\t\t}\n-\t\tsetExitStatus(2)\n-\t\texit()\n-\t}\n-\treturn toolPath\n+\treturn false\n }\n \n-func isInGoToolsRepo(toolName string) bool {\n-\treturn false\n+func init() {\n+\tCmdTool.Flag.BoolVar(&toolN, \"n\", false, \"\")\n }\n \n-func runTool(cmd *Command, args []string) {\n+func runTool(cmd *base.Command, args []string) {\n \tif len(args) == 0 {\n \t\tlistTools()\n \t\treturn\n@@ -88,11 +60,11 @@ func runTool(cmd *Command, args []string) {\n \t\tcase 'a' <= c && c <= 'z', '0' <= c && c <= '9', c == '_':\n \t\tdefault:\n \t\t\tfmt.Fprintf(os.Stderr, \"go tool: bad tool name %q\\n\", toolName)\n-\t\t\tsetExitStatus(2)\n+\t\t\tbase.SetExitStatus(2)\n \t\t\treturn\n \t\t}\n \t}\n-\ttoolPath := tool(toolName)\n+\ttoolPath := base.Tool(toolName)\n \tif toolPath == \"\" {\n \t\treturn\n \t}\n@@ -112,7 +84,7 @@ func runTool(cmd *Command, args []string) {\n \t\tStdout: os.Stdout,\n \t\tStderr: os.Stderr,\n \t\t// Set $GOROOT, mainly for go tool dist.\n-\t\tEnv: mergeEnvLists([]string{\"GOROOT=\" + goroot}, os.Environ()),\n+\t\tEnv: base.MergeEnvLists([]string{\"GOROOT=\" + cfg.GOROOT}, os.Environ()),\n \t}\n \terr := toolCmd.Run()\n \tif err != nil {\n@@ -121,27 +93,27 @@ func runTool(cmd *Command, args []string) {\n \t\t// or we're printing command lines too (-x mode).\n \t\t// Assume if command exited cleanly (even with non-zero status)\n \t\t// it printed any messages it wanted to print.\n-\t\tif e, ok := err.(*exec.ExitError); !ok || !e.Exited() || buildX {\n+\t\tif e, ok := err.(*exec.ExitError); !ok || !e.Exited() || cfg.BuildX {\n \t\t\tfmt.Fprintf(os.Stderr, \"go tool %s: %s\\n\", toolName, err)\n \t\t}\n-\t\tsetExitStatus(1)\n+\t\tbase.SetExitStatus(1)\n \t\treturn\n \t}\n }\n \n // listTools prints a list of the available tools in the tools directory.\n func listTools() {\n-\tf, err := os.Open(toolDir)\n+\tf, err := os.Open(base.ToolDir)\n \tif err != nil {\n \t\tfmt.Fprintf(os.Stderr, \"go tool: no tool directory: %s\\n\", err)\n-\t\tsetExitStatus(2)\n+\t\tbase.SetExitStatus(2)\n \t\treturn\n \t}\n \tdefer f.Close()\n \tnames, err := f.Readdirnames(-1)\n \tif err != nil {\n \t\tfmt.Fprintf(os.Stderr, \"go tool: can't read directory: %s\\n\", err)\n-\t\tsetExitStatus(2)\n+\t\tbase.SetExitStatus(2)\n \t\treturn\n \t}\n \n@@ -150,24 +122,14 @@ func listTools() {\n \t\t// Unify presentation by going to lower case.\n \t\tname = strings.ToLower(name)\n \t\t// If it's windows, don't show the .exe suffix.\n-\t\tif toolIsWindows && strings.HasSuffix(name, toolWindowsExtension) {\n-\t\t\tname = name[:len(name)-len(toolWindowsExtension)]\n+\t\tif base.ToolIsWindows && strings.HasSuffix(name, base.ToolWindowsExtension) {\n+\t\t\tname = name[:len(name)-len(base.ToolWindowsExtension)]\n \t\t}\n-\n \t\t// The tool directory used by gccgo will have other binaries\n-\t\t// in additions to go tools.  Only display go tools for this list.\n-\n-\t\tif buildContext.Compiler == \"gccgo\" {\n-\t\t\tfor _, tool := range gccgoTools {\n-\t\t\t\tif tool == name {\n-\t\t\t\t\tfmt.Println(name)\n-\t\t\t\t}\n-\t\t\t}\n-\t\t} else {\n-\n-\t\t\t// Not gccgo, list all the tools found in this dir\n-\n-\t\t\tfmt.Println(name)\n+\t\t// in addition to go tools. Only display go tools here.\n+\t\tif cfg.BuildToolchainName == \"gccgo\" && !isGccgoTool(name) {\n+\t\t\tcontinue\n \t\t}\n+\t\tfmt.Println(name)\n \t}\n }", "previous_filename": "libgo/go/cmd/go/tool.go"}, {"sha": "c3f7d73ff1d95fd47a31d8b1cafc593a8b3f9eec", "filename": "libgo/go/cmd/go/internal/version/version.go", "status": "renamed", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fversion%2Fversion.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fversion%2Fversion.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fversion%2Fversion.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -2,21 +2,24 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-package main\n+// Package version implements the ``go version'' command.\n+package version\n \n import (\n \t\"fmt\"\n \t\"runtime\"\n+\n+\t\"cmd/go/internal/base\"\n )\n \n-var cmdVersion = &Command{\n+var CmdVersion = &base.Command{\n \tRun:       runVersion,\n \tUsageLine: \"version\",\n \tShort:     \"print Go version\",\n \tLong:      `Version prints the Go version, as reported by runtime.Version.`,\n }\n \n-func runVersion(cmd *Command, args []string) {\n+func runVersion(cmd *base.Command, args []string) {\n \tif len(args) != 0 {\n \t\tcmd.Usage()\n \t}", "previous_filename": "libgo/go/cmd/go/version.go"}, {"sha": "ddacd085b0661c438b7022242a45e4d732b7c67f", "filename": "libgo/go/cmd/go/internal/vet/vet.go", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvet%2Fvet.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvet%2Fvet.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvet%2Fvet.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -0,0 +1,56 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Package vet implements the ``go vet'' command.\n+package vet\n+\n+import (\n+\t\"path/filepath\"\n+\n+\t\"cmd/go/internal/base\"\n+\t\"cmd/go/internal/cfg\"\n+\t\"cmd/go/internal/load\"\n+\t\"cmd/go/internal/str\"\n+)\n+\n+var CmdVet = &base.Command{\n+\tRun:         runVet,\n+\tCustomFlags: true,\n+\tUsageLine:   \"vet [-n] [-x] [build flags] [vet flags] [packages]\",\n+\tShort:       \"run go tool vet on packages\",\n+\tLong: `\n+Vet runs the Go vet command on the packages named by the import paths.\n+\n+For more about vet and its flags, see 'go doc cmd/vet'.\n+For more about specifying packages, see 'go help packages'.\n+\n+The -n flag prints commands that would be executed.\n+The -x flag prints commands as they are executed.\n+\n+For more about build flags, see 'go help build'.\n+\n+See also: go fmt, go fix.\n+\t`,\n+}\n+\n+func runVet(cmd *base.Command, args []string) {\n+\tvetFlags, packages := vetFlags(args)\n+\tfor _, p := range load.Packages(packages) {\n+\t\t// Vet expects to be given a set of files all from the same package.\n+\t\t// Run once for package p and once for package p_test.\n+\t\tif len(p.GoFiles)+len(p.CgoFiles)+len(p.TestGoFiles) > 0 {\n+\t\t\trunVetFiles(p, vetFlags, str.StringList(p.GoFiles, p.CgoFiles, p.TestGoFiles, p.SFiles))\n+\t\t}\n+\t\tif len(p.XTestGoFiles) > 0 {\n+\t\t\trunVetFiles(p, vetFlags, str.StringList(p.XTestGoFiles))\n+\t\t}\n+\t}\n+}\n+\n+func runVetFiles(p *load.Package, flags, files []string) {\n+\tfor i := range files {\n+\t\tfiles[i] = filepath.Join(p.Dir, files[i])\n+\t}\n+\tbase.Run(cfg.BuildToolexec, base.Tool(\"vet\"), flags, base.RelPaths(files))\n+}"}, {"sha": "8cd21bb72b75fcde0924f482e3439d437cb23dc1", "filename": "libgo/go/cmd/go/internal/vet/vetflag.go", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvet%2Fvetflag.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvet%2Fvetflag.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvet%2Fvetflag.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -0,0 +1,99 @@\n+// Copyright 2017 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package vet\n+\n+import (\n+\t\"flag\"\n+\t\"fmt\"\n+\t\"os\"\n+\t\"strings\"\n+\n+\t\"cmd/go/internal/base\"\n+\t\"cmd/go/internal/cmdflag\"\n+\t\"cmd/go/internal/work\"\n+)\n+\n+const cmd = \"vet\"\n+\n+// vetFlagDefn is the set of flags we process.\n+var vetFlagDefn = []*cmdflag.Defn{\n+\t// Note: Some flags, in particular -tags and -v, are known to\n+\t// vet but also defined as build flags. This works fine, so we\n+\t// don't define them here but use AddBuildFlags to init them.\n+\t// However some, like -x, are known to the build but not\n+\t// to vet. We handle them in vetFlags.\n+\n+\t// local.\n+\t{Name: \"all\", BoolVar: new(bool)},\n+\t{Name: \"asmdecl\", BoolVar: new(bool)},\n+\t{Name: \"assign\", BoolVar: new(bool)},\n+\t{Name: \"atomic\", BoolVar: new(bool)},\n+\t{Name: \"bool\", BoolVar: new(bool)},\n+\t{Name: \"buildtags\", BoolVar: new(bool)},\n+\t{Name: \"cgocall\", BoolVar: new(bool)},\n+\t{Name: \"composites\", BoolVar: new(bool)},\n+\t{Name: \"copylocks\", BoolVar: new(bool)},\n+\t{Name: \"httpresponse\", BoolVar: new(bool)},\n+\t{Name: \"lostcancel\", BoolVar: new(bool)},\n+\t{Name: \"methods\", BoolVar: new(bool)},\n+\t{Name: \"nilfunc\", BoolVar: new(bool)},\n+\t{Name: \"printf\", BoolVar: new(bool)},\n+\t{Name: \"printfuncs\"},\n+\t{Name: \"rangeloops\", BoolVar: new(bool)},\n+\t{Name: \"shadow\", BoolVar: new(bool)},\n+\t{Name: \"shadowstrict\", BoolVar: new(bool)},\n+\t{Name: \"source\", BoolVar: new(bool)},\n+\t{Name: \"structtags\", BoolVar: new(bool)},\n+\t{Name: \"tests\", BoolVar: new(bool)},\n+\t{Name: \"unreachable\", BoolVar: new(bool)},\n+\t{Name: \"unsafeptr\", BoolVar: new(bool)},\n+\t{Name: \"unusedfuncs\"},\n+\t{Name: \"unusedresult\", BoolVar: new(bool)},\n+\t{Name: \"unusedstringmethods\"},\n+}\n+\n+// add build flags to vetFlagDefn.\n+func init() {\n+\tvar cmd base.Command\n+\twork.AddBuildFlags(&cmd)\n+\tcmd.Flag.VisitAll(func(f *flag.Flag) {\n+\t\tvetFlagDefn = append(vetFlagDefn, &cmdflag.Defn{\n+\t\t\tName:  f.Name,\n+\t\t\tValue: f.Value,\n+\t\t})\n+\t})\n+}\n+\n+// vetFlags processes the command line, splitting it at the first non-flag\n+// into the list of flags and list of packages.\n+func vetFlags(args []string) (passToVet, packageNames []string) {\n+\tfor i := 0; i < len(args); i++ {\n+\t\tif !strings.HasPrefix(args[i], \"-\") {\n+\t\t\treturn args[:i], args[i:]\n+\t\t}\n+\n+\t\tf, value, extraWord := cmdflag.Parse(cmd, vetFlagDefn, args, i)\n+\t\tif f == nil {\n+\t\t\tfmt.Fprintf(os.Stderr, \"vet: flag %q not defined\\n\", args[i])\n+\t\t\tfmt.Fprintf(os.Stderr, \"Run \\\"go help vet\\\" for more information\\n\")\n+\t\t\tos.Exit(2)\n+\t\t}\n+\t\tif f.Value != nil {\n+\t\t\tif err := f.Value.Set(value); err != nil {\n+\t\t\t\tbase.Fatalf(\"invalid flag argument for -%s: %v\", f.Name, err)\n+\t\t\t}\n+\t\t\tswitch f.Name {\n+\t\t\t// Flags known to the build but not to vet, so must be dropped.\n+\t\t\tcase \"x\", \"n\":\n+\t\t\t\targs = append(args[:i], args[i+1:]...)\n+\t\t\t\ti--\n+\t\t\t}\n+\t\t}\n+\t\tif extraWord {\n+\t\t\ti++\n+\t\t}\n+\t}\n+\treturn args, nil\n+}"}, {"sha": "d1d4621a44b6884e5d1f862524c6528a6f0fb087", "filename": "libgo/go/cmd/go/internal/web/bootstrap.go", "status": "renamed", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb%2Fbootstrap.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb%2Fbootstrap.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb%2Fbootstrap.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -8,7 +8,7 @@\n // These stubs avoid importing packages with large dependency\n // trees, like the use of \"net/http\" in vcs.go.\n \n-package main\n+package web\n \n import (\n \t\"errors\"\n@@ -17,25 +17,21 @@ import (\n \n var errHTTP = errors.New(\"no http in bootstrap go command\")\n \n-type httpError struct {\n-\tstatusCode int\n+type HTTPError struct {\n+\tStatusCode int\n }\n \n-func (e *httpError) Error() string {\n+func (e *HTTPError) Error() string {\n \tpanic(\"unreachable\")\n }\n \n-func httpGET(url string) ([]byte, error) {\n+func Get(url string) ([]byte, error) {\n \treturn nil, errHTTP\n }\n \n-func httpsOrHTTP(importPath string, security securityMode) (string, io.ReadCloser, error) {\n+func GetMaybeInsecure(importPath string, security SecurityMode) (string, io.ReadCloser, error) {\n \treturn \"\", nil, errHTTP\n }\n \n-func parseMetaGoImports(r io.Reader) ([]metaImport, error) {\n-\tpanic(\"unreachable\")\n-}\n-\n-func queryEscape(s string) string { panic(\"unreachable\") }\n-func openBrowser(url string) bool { panic(\"unreachable\") }\n+func QueryEscape(s string) string { panic(\"unreachable\") }\n+func OpenBrowser(url string) bool { panic(\"unreachable\") }", "previous_filename": "libgo/go/cmd/go/bootstrap.go"}, {"sha": "6e347fbf86029ae0a5977062886c824b52984f21", "filename": "libgo/go/cmd/go/internal/web/http.go", "status": "renamed", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb%2Fhttp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb%2Fhttp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb%2Fhttp.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -9,10 +9,9 @@\n // to avoid needing to build net (and thus use cgo) during the\n // bootstrap process.\n \n-package main\n+package web\n \n import (\n-\t\"cmd/internal/browser\"\n \t\"crypto/tls\"\n \t\"fmt\"\n \t\"io\"\n@@ -21,6 +20,9 @@ import (\n \t\"net/http\"\n \t\"net/url\"\n \t\"time\"\n+\n+\t\"cmd/go/internal/cfg\"\n+\t\"cmd/internal/browser\"\n )\n \n // httpClient is the default HTTP client, but a variable so it can be\n@@ -40,25 +42,25 @@ var impatientInsecureHTTPClient = &http.Client{\n \t},\n }\n \n-type httpError struct {\n+type HTTPError struct {\n \tstatus     string\n-\tstatusCode int\n+\tStatusCode int\n \turl        string\n }\n \n-func (e *httpError) Error() string {\n+func (e *HTTPError) Error() string {\n \treturn fmt.Sprintf(\"%s: %s\", e.url, e.status)\n }\n \n-// httpGET returns the data from an HTTP GET request for the given URL.\n-func httpGET(url string) ([]byte, error) {\n+// Get returns the data from an HTTP GET request for the given URL.\n+func Get(url string) ([]byte, error) {\n \tresp, err := httpClient.Get(url)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n \tdefer resp.Body.Close()\n \tif resp.StatusCode != 200 {\n-\t\terr := &httpError{status: resp.Status, statusCode: resp.StatusCode, url: url}\n+\t\terr := &HTTPError{status: resp.Status, StatusCode: resp.StatusCode, url: url}\n \n \t\treturn nil, err\n \t}\n@@ -69,20 +71,20 @@ func httpGET(url string) ([]byte, error) {\n \treturn b, nil\n }\n \n-// httpsOrHTTP returns the body of either the importPath's\n-// https resource or, if unavailable, the http resource.\n-func httpsOrHTTP(importPath string, security securityMode) (urlStr string, body io.ReadCloser, err error) {\n+// GetMaybeInsecure returns the body of either the importPath's\n+// https resource or, if unavailable and permitted by the security mode, the http resource.\n+func GetMaybeInsecure(importPath string, security SecurityMode) (urlStr string, body io.ReadCloser, err error) {\n \tfetch := func(scheme string) (urlStr string, res *http.Response, err error) {\n \t\tu, err := url.Parse(scheme + \"://\" + importPath)\n \t\tif err != nil {\n \t\t\treturn \"\", nil, err\n \t\t}\n \t\tu.RawQuery = \"go-get=1\"\n \t\turlStr = u.String()\n-\t\tif buildV {\n+\t\tif cfg.BuildV {\n \t\t\tlog.Printf(\"Fetching %s\", urlStr)\n \t\t}\n-\t\tif security == insecure && scheme == \"https\" { // fail earlier\n+\t\tif security == Insecure && scheme == \"https\" { // fail earlier\n \t\t\tres, err = impatientInsecureHTTPClient.Get(urlStr)\n \t\t} else {\n \t\t\tres, err = httpClient.Get(urlStr)\n@@ -96,10 +98,10 @@ func httpsOrHTTP(importPath string, security securityMode) (urlStr string, body\n \t}\n \turlStr, res, err := fetch(\"https\")\n \tif err != nil {\n-\t\tif buildV {\n+\t\tif cfg.BuildV {\n \t\t\tlog.Printf(\"https fetch failed: %v\", err)\n \t\t}\n-\t\tif security == insecure {\n+\t\tif security == Insecure {\n \t\t\tcloseBody(res)\n \t\t\turlStr, res, err = fetch(\"http\")\n \t\t}\n@@ -110,11 +112,11 @@ func httpsOrHTTP(importPath string, security securityMode) (urlStr string, body\n \t}\n \t// Note: accepting a non-200 OK here, so people can serve a\n \t// meta import in their http 404 page.\n-\tif buildV {\n+\tif cfg.BuildV {\n \t\tlog.Printf(\"Parsing meta tags from %s (status code %d)\", urlStr, res.StatusCode)\n \t}\n \treturn urlStr, res.Body, nil\n }\n \n-func queryEscape(s string) string { return url.QueryEscape(s) }\n-func openBrowser(url string) bool { return browser.Open(url) }\n+func QueryEscape(s string) string { return url.QueryEscape(s) }\n+func OpenBrowser(url string) bool { return browser.Open(url) }", "previous_filename": "libgo/go/cmd/go/http.go"}, {"sha": "1dc6f1b076fb46be26b3b3d2c6dea5915f1cebe2", "filename": "libgo/go/cmd/go/internal/web/security.go", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb%2Fsecurity.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb%2Fsecurity.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb%2Fsecurity.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2017 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Package web defines helper routines for accessing HTTP/HTTPS resources.\n+package web\n+\n+// SecurityMode specifies whether a function should make network\n+// calls using insecure transports (eg, plain text HTTP).\n+// The zero value is \"secure\".\n+type SecurityMode int\n+\n+const (\n+\tSecure SecurityMode = iota\n+\tInsecure\n+)"}, {"sha": "de8c4937a1333b24b93d618f60644d4f58e76946", "filename": "libgo/go/cmd/go/internal/work/build.go", "status": "renamed", "additions": 953, "deletions": 949, "changes": 1902, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuild.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuild.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuild.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "previous_filename": "libgo/go/cmd/go/build.go"}, {"sha": "294b83c6b2ae6272ccf3c31a16243fa4ea3b6235", "filename": "libgo/go/cmd/go/internal/work/build_test.go", "status": "added", "additions": 227, "deletions": 0, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuild_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuild_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuild_test.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -0,0 +1,227 @@\n+// Copyright 2016 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package work\n+\n+import (\n+\t\"bytes\"\n+\t\"fmt\"\n+\t\"io/ioutil\"\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"reflect\"\n+\t\"runtime\"\n+\t\"strings\"\n+\t\"testing\"\n+\n+\t\"cmd/go/internal/base\"\n+\t\"cmd/go/internal/cfg\"\n+\t\"cmd/go/internal/load\"\n+)\n+\n+func TestRemoveDevNull(t *testing.T) {\n+\tfi, err := os.Lstat(os.DevNull)\n+\tif err != nil {\n+\t\tt.Skip(err)\n+\t}\n+\tif fi.Mode().IsRegular() {\n+\t\tt.Errorf(\"Lstat(%s).Mode().IsRegular() = true; expected false\", os.DevNull)\n+\t}\n+\tmayberemovefile(os.DevNull)\n+\t_, err = os.Lstat(os.DevNull)\n+\tif err != nil {\n+\t\tt.Errorf(\"mayberemovefile(%s) did remove it; oops\", os.DevNull)\n+\t}\n+}\n+\n+func TestSplitPkgConfigOutput(t *testing.T) {\n+\tfor _, test := range []struct {\n+\t\tin   []byte\n+\t\twant []string\n+\t}{\n+\t\t{[]byte(`-r:foo -L/usr/white\\ space/lib -lfoo\\ bar -lbar\\ baz`), []string{\"-r:foo\", \"-L/usr/white space/lib\", \"-lfoo bar\", \"-lbar baz\"}},\n+\t\t{[]byte(`-lextra\\ fun\\ arg\\\\`), []string{`-lextra fun arg\\`}},\n+\t\t{[]byte(`broken flag\\`), []string{\"broken\", \"flag\"}},\n+\t\t{[]byte(\"\\textra     whitespace\\r\\n\"), []string{\"extra\", \"whitespace\"}},\n+\t\t{[]byte(\"     \\r\\n      \"), nil},\n+\t} {\n+\t\tgot := splitPkgConfigOutput(test.in)\n+\t\tif !reflect.DeepEqual(got, test.want) {\n+\t\t\tt.Errorf(\"splitPkgConfigOutput(%v) = %v; want %v\", test.in, got, test.want)\n+\t\t}\n+\t}\n+}\n+\n+func TestSharedLibName(t *testing.T) {\n+\t// TODO(avdva) - make these values platform-specific\n+\tprefix := \"lib\"\n+\tsuffix := \".so\"\n+\ttestData := []struct {\n+\t\targs      []string\n+\t\tpkgs      []*load.Package\n+\t\texpected  string\n+\t\texpectErr bool\n+\t\trootedAt  string\n+\t}{\n+\t\t{\n+\t\t\targs:     []string{\"std\"},\n+\t\t\tpkgs:     []*load.Package{},\n+\t\t\texpected: \"std\",\n+\t\t},\n+\t\t{\n+\t\t\targs:     []string{\"std\", \"cmd\"},\n+\t\t\tpkgs:     []*load.Package{},\n+\t\t\texpected: \"std,cmd\",\n+\t\t},\n+\t\t{\n+\t\t\targs:     []string{},\n+\t\t\tpkgs:     []*load.Package{pkgImportPath(\"gopkg.in/somelib\")},\n+\t\t\texpected: \"gopkg.in-somelib\",\n+\t\t},\n+\t\t{\n+\t\t\targs:     []string{\"./...\"},\n+\t\t\tpkgs:     []*load.Package{pkgImportPath(\"somelib\")},\n+\t\t\texpected: \"somelib\",\n+\t\t\trootedAt: \"somelib\",\n+\t\t},\n+\t\t{\n+\t\t\targs:     []string{\"../somelib\", \"../somelib\"},\n+\t\t\tpkgs:     []*load.Package{pkgImportPath(\"somelib\")},\n+\t\t\texpected: \"somelib\",\n+\t\t},\n+\t\t{\n+\t\t\targs:     []string{\"../lib1\", \"../lib2\"},\n+\t\t\tpkgs:     []*load.Package{pkgImportPath(\"gopkg.in/lib1\"), pkgImportPath(\"gopkg.in/lib2\")},\n+\t\t\texpected: \"gopkg.in-lib1,gopkg.in-lib2\",\n+\t\t},\n+\t\t{\n+\t\t\targs: []string{\"./...\"},\n+\t\t\tpkgs: []*load.Package{\n+\t\t\t\tpkgImportPath(\"gopkg.in/dir/lib1\"),\n+\t\t\t\tpkgImportPath(\"gopkg.in/lib2\"),\n+\t\t\t\tpkgImportPath(\"gopkg.in/lib3\"),\n+\t\t\t},\n+\t\t\texpected: \"gopkg.in\",\n+\t\t\trootedAt: \"gopkg.in\",\n+\t\t},\n+\t\t{\n+\t\t\targs:      []string{\"std\", \"../lib2\"},\n+\t\t\tpkgs:      []*load.Package{},\n+\t\t\texpectErr: true,\n+\t\t},\n+\t\t{\n+\t\t\targs:      []string{\"all\", \"./\"},\n+\t\t\tpkgs:      []*load.Package{},\n+\t\t\texpectErr: true,\n+\t\t},\n+\t\t{\n+\t\t\targs:      []string{\"cmd\", \"fmt\"},\n+\t\t\tpkgs:      []*load.Package{},\n+\t\t\texpectErr: true,\n+\t\t},\n+\t}\n+\tfor _, data := range testData {\n+\t\tfunc() {\n+\t\t\tif data.rootedAt != \"\" {\n+\t\t\t\ttmpGopath, err := ioutil.TempDir(\"\", \"gopath\")\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tt.Fatal(err)\n+\t\t\t\t}\n+\t\t\t\toldGopath := cfg.BuildContext.GOPATH\n+\t\t\t\tdefer func() {\n+\t\t\t\t\tcfg.BuildContext.GOPATH = oldGopath\n+\t\t\t\t\tos.Chdir(base.Cwd)\n+\t\t\t\t\terr := os.RemoveAll(tmpGopath)\n+\t\t\t\t\tif err != nil {\n+\t\t\t\t\t\tt.Error(err)\n+\t\t\t\t\t}\n+\t\t\t\t}()\n+\t\t\t\troot := filepath.Join(tmpGopath, \"src\", data.rootedAt)\n+\t\t\t\terr = os.MkdirAll(root, 0755)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tt.Fatal(err)\n+\t\t\t\t}\n+\t\t\t\tcfg.BuildContext.GOPATH = tmpGopath\n+\t\t\t\tos.Chdir(root)\n+\t\t\t}\n+\t\t\tcomputed, err := libname(data.args, data.pkgs)\n+\t\t\tif err != nil {\n+\t\t\t\tif !data.expectErr {\n+\t\t\t\t\tt.Errorf(\"libname returned an error %q, expected a name\", err.Error())\n+\t\t\t\t}\n+\t\t\t} else if data.expectErr {\n+\t\t\t\tt.Errorf(\"libname returned %q, expected an error\", computed)\n+\t\t\t} else {\n+\t\t\t\texpected := prefix + data.expected + suffix\n+\t\t\t\tif expected != computed {\n+\t\t\t\t\tt.Errorf(\"libname returned %q, expected %q\", computed, expected)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}()\n+\t}\n+}\n+\n+func pkgImportPath(pkgpath string) *load.Package {\n+\treturn &load.Package{\n+\t\tPackagePublic: load.PackagePublic{\n+\t\t\tImportPath: pkgpath,\n+\t\t},\n+\t}\n+}\n+\n+// When installing packages, the installed package directory should\n+// respect the SetGID bit and group name of the destination\n+// directory.\n+// See https://golang.org/issue/18878.\n+func TestRespectSetgidDir(t *testing.T) {\n+\tif runtime.GOOS == \"nacl\" {\n+\t\tt.Skip(\"can't set SetGID bit with chmod on nacl\")\n+\t}\n+\n+\tvar b Builder\n+\n+\t// Check that `cp` is called instead of `mv` by looking at the output\n+\t// of `(*Builder).ShowCmd` afterwards as a sanity check.\n+\tcfg.BuildX = true\n+\tvar cmdBuf bytes.Buffer\n+\tb.Print = func(a ...interface{}) (int, error) {\n+\t\treturn cmdBuf.WriteString(fmt.Sprint(a...))\n+\t}\n+\n+\tsetgiddir, err := ioutil.TempDir(\"\", \"SetGroupID\")\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tdefer os.RemoveAll(setgiddir)\n+\n+\tif runtime.GOOS == \"freebsd\" {\n+\t\terr = os.Chown(setgiddir, os.Getuid(), os.Getgid())\n+\t\tif err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\t}\n+\n+\t// Change setgiddir's permissions to include the SetGID bit.\n+\tif err := os.Chmod(setgiddir, 0755|os.ModeSetgid); err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\n+\tpkgfile, err := ioutil.TempFile(\"\", \"pkgfile\")\n+\tif err != nil {\n+\t\tt.Fatalf(\"ioutil.TempFile(\\\"\\\", \\\"pkgfile\\\"): %v\", err)\n+\t}\n+\tdefer os.Remove(pkgfile.Name())\n+\tdefer pkgfile.Close()\n+\n+\tdirGIDFile := filepath.Join(setgiddir, \"setgid\")\n+\tif err := b.moveOrCopyFile(nil, dirGIDFile, pkgfile.Name(), 0666, true); err != nil {\n+\t\tt.Fatalf(\"moveOrCopyFile: %v\", err)\n+\t}\n+\n+\tgot := strings.TrimSpace(cmdBuf.String())\n+\twant := b.fmtcmd(\"\", \"cp %s %s\", pkgfile.Name(), dirGIDFile)\n+\tif got != want {\n+\t\tt.Fatalf(\"moveOrCopyFile(%q, %q): want %q, got %q\", dirGIDFile, pkgfile.Name(), want, got)\n+\t}\n+}"}, {"sha": "3e623c662100dc6101ceb51ebdcda5473f9daa19", "filename": "libgo/go/cmd/go/internal/work/testgo.go", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Ftestgo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Ftestgo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Ftestgo.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2017 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// This file contains extra hooks for testing the go command.\n+\n+// +build testgo\n+\n+package work\n+\n+import \"os\"\n+\n+func init() {\n+\tif v := os.Getenv(\"TESTGO_VERSION\"); v != \"\" {\n+\t\truntimeVersion = v\n+\t}\n+}"}, {"sha": "794ce08b769405e25e66d8bcd5c9cbb24bc180af", "filename": "libgo/go/cmd/go/main.go", "status": "modified", "additions": 73, "deletions": 716, "changes": 789, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Fmain.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Fmain.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fmain.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -2,141 +2,90 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+//go:generate ./mkalldocs.sh\n+\n package main\n \n import (\n-\t\"bufio\"\n-\t\"bytes\"\n \t\"flag\"\n \t\"fmt\"\n-\t\"go/build\"\n-\t\"io\"\n \t\"log\"\n \t\"os\"\n-\t\"os/exec\"\n-\t\"path\"\n \t\"path/filepath\"\n-\t\"regexp\"\n \t\"runtime\"\n \t\"strings\"\n-\t\"sync\"\n-\t\"text/template\"\n-\t\"unicode\"\n-\t\"unicode/utf8\"\n-)\n-\n-// A Command is an implementation of a go command\n-// like go build or go fix.\n-type Command struct {\n-\t// Run runs the command.\n-\t// The args are the arguments after the command name.\n-\tRun func(cmd *Command, args []string)\n-\n-\t// UsageLine is the one-line usage message.\n-\t// The first word in the line is taken to be the command name.\n-\tUsageLine string\n-\n-\t// Short is the short description shown in the 'go help' output.\n-\tShort string\n-\n-\t// Long is the long message shown in the 'go help <this-command>' output.\n-\tLong string\n-\n-\t// Flag is a set of flags specific to this command.\n-\tFlag flag.FlagSet\n \n-\t// CustomFlags indicates that the command will do its own\n-\t// flag parsing.\n-\tCustomFlags bool\n-}\n-\n-// Name returns the command's name: the first word in the usage line.\n-func (c *Command) Name() string {\n-\tname := c.UsageLine\n-\ti := strings.Index(name, \" \")\n-\tif i >= 0 {\n-\t\tname = name[:i]\n-\t}\n-\treturn name\n-}\n-\n-func (c *Command) Usage() {\n-\tfmt.Fprintf(os.Stderr, \"usage: %s\\n\\n\", c.UsageLine)\n-\tfmt.Fprintf(os.Stderr, \"%s\\n\", strings.TrimSpace(c.Long))\n-\tos.Exit(2)\n-}\n-\n-// Runnable reports whether the command can be run; otherwise\n-// it is a documentation pseudo-command such as importpath.\n-func (c *Command) Runnable() bool {\n-\treturn c.Run != nil\n-}\n-\n-// Commands lists the available commands and help topics.\n-// The order here is the order in which they are printed by 'go help'.\n-var commands = []*Command{\n-\tcmdBuild,\n-\tcmdClean,\n-\tcmdDoc,\n-\tcmdEnv,\n-\tcmdBug,\n-\tcmdFix,\n-\tcmdFmt,\n-\tcmdGenerate,\n-\tcmdGet,\n-\tcmdInstall,\n-\tcmdList,\n-\tcmdRun,\n-\tcmdTest,\n-\tcmdTool,\n-\tcmdVersion,\n-\tcmdVet,\n-\n-\thelpC,\n-\thelpBuildmode,\n-\thelpFileType,\n-\thelpGopath,\n-\thelpEnvironment,\n-\thelpImportPath,\n-\thelpPackages,\n-\thelpTestflag,\n-\thelpTestfunc,\n-}\n-\n-var exitStatus = 0\n-var exitMu sync.Mutex\n+\t\"cmd/go/internal/base\"\n+\t\"cmd/go/internal/bug\"\n+\t\"cmd/go/internal/cfg\"\n+\t\"cmd/go/internal/clean\"\n+\t\"cmd/go/internal/doc\"\n+\t\"cmd/go/internal/envcmd\"\n+\t\"cmd/go/internal/fix\"\n+\t\"cmd/go/internal/fmtcmd\"\n+\t\"cmd/go/internal/generate\"\n+\t\"cmd/go/internal/get\"\n+\t\"cmd/go/internal/help\"\n+\t\"cmd/go/internal/list\"\n+\t\"cmd/go/internal/run\"\n+\t\"cmd/go/internal/test\"\n+\t\"cmd/go/internal/tool\"\n+\t\"cmd/go/internal/version\"\n+\t\"cmd/go/internal/vet\"\n+\t\"cmd/go/internal/work\"\n+)\n \n-func setExitStatus(n int) {\n-\texitMu.Lock()\n-\tif exitStatus < n {\n-\t\texitStatus = n\n+func init() {\n+\tbase.Commands = []*base.Command{\n+\t\twork.CmdBuild,\n+\t\tclean.CmdClean,\n+\t\tdoc.CmdDoc,\n+\t\tenvcmd.CmdEnv,\n+\t\tbug.CmdBug,\n+\t\tfix.CmdFix,\n+\t\tfmtcmd.CmdFmt,\n+\t\tgenerate.CmdGenerate,\n+\t\tget.CmdGet,\n+\t\twork.CmdInstall,\n+\t\tlist.CmdList,\n+\t\trun.CmdRun,\n+\t\ttest.CmdTest,\n+\t\ttool.CmdTool,\n+\t\tversion.CmdVersion,\n+\t\tvet.CmdVet,\n+\n+\t\thelp.HelpC,\n+\t\thelp.HelpBuildmode,\n+\t\thelp.HelpFileType,\n+\t\thelp.HelpGopath,\n+\t\thelp.HelpEnvironment,\n+\t\thelp.HelpImportPath,\n+\t\thelp.HelpPackages,\n+\t\ttest.HelpTestflag,\n+\t\ttest.HelpTestfunc,\n \t}\n-\texitMu.Unlock()\n }\n \n-var origEnv []string\n-var newEnv []envVar\n-\n func main() {\n \t_ = go11tag\n-\tflag.Usage = usage\n+\tflag.Usage = base.Usage\n \tflag.Parse()\n \tlog.SetFlags(0)\n \n \targs := flag.Args()\n \tif len(args) < 1 {\n-\t\tusage()\n+\t\tbase.Usage()\n \t}\n \n \tif args[0] == \"help\" {\n-\t\thelp(args[1:])\n+\t\thelp.Help(args[1:])\n \t\treturn\n \t}\n \n \t// Diagnose common mistake: GOPATH==GOROOT.\n \t// This setting is equivalent to not setting GOPATH at all,\n \t// which is not what most people want when they do it.\n-\tif gopath := buildContext.GOPATH; filepath.Clean(gopath) == filepath.Clean(runtime.GOROOT()) {\n+\tif gopath := cfg.BuildContext.GOPATH; filepath.Clean(gopath) == filepath.Clean(runtime.GOROOT()) {\n \t\tfmt.Fprintf(os.Stderr, \"warning: GOPATH set to GOROOT (%s) has no effect\\n\", gopath)\n \t} else {\n \t\tfor _, p := range filepath.SplitList(gopath) {\n@@ -154,30 +103,28 @@ func main() {\n \t\t}\n \t}\n \n-\tif fi, err := os.Stat(goroot); err != nil || !fi.IsDir() {\n-\t\t// For gccgo this is fine, carry on.\n-\t\t// Note that this check is imperfect as we have not yet\n-\t\t// parsed the -compiler flag.\n-\t\tif runtime.Compiler != \"gccgo\" {\n-\t\t\tfmt.Fprintf(os.Stderr, \"go: cannot find GOROOT directory: %v\\n\", goroot)\n-\t\t\tos.Exit(2)\n-\t\t}\n+\t// For gccgo this is fine, carry on.\n+\t// Note that this check is imperfect as we have not yet parsed\n+\t// the -compiler flag.\n+\tif fi, err := os.Stat(cfg.GOROOT); err != nil || !fi.IsDir() && runtime.Compiler != \"gccgo\" {\n+\t\tfmt.Fprintf(os.Stderr, \"go: cannot find GOROOT directory: %v\\n\", cfg.GOROOT)\n+\t\tos.Exit(2)\n \t}\n \n \t// Set environment (GOOS, GOARCH, etc) explicitly.\n \t// In theory all the commands we invoke should have\n \t// the same default computation of these as we do,\n \t// but in practice there might be skew\n \t// This makes sure we all agree.\n-\torigEnv = os.Environ()\n-\tnewEnv = mkEnv()\n-\tfor _, env := range newEnv {\n-\t\tif os.Getenv(env.name) != env.value {\n-\t\t\tos.Setenv(env.name, env.value)\n+\tcfg.OrigEnv = os.Environ()\n+\tcfg.CmdEnv = envcmd.MkEnv()\n+\tfor _, env := range cfg.CmdEnv {\n+\t\tif os.Getenv(env.Name) != env.Value {\n+\t\t\tos.Setenv(env.Name, env.Value)\n \t\t}\n \t}\n \n-\tfor _, cmd := range commands {\n+\tfor _, cmd := range base.Commands {\n \t\tif cmd.Name() == args[0] && cmd.Runnable() {\n \t\t\tcmd.Flag.Usage = func() { cmd.Usage() }\n \t\t\tif cmd.CustomFlags {\n@@ -187,615 +134,25 @@ func main() {\n \t\t\t\targs = cmd.Flag.Args()\n \t\t\t}\n \t\t\tcmd.Run(cmd, args)\n-\t\t\texit()\n+\t\t\tbase.Exit()\n \t\t\treturn\n \t\t}\n \t}\n \n \tfmt.Fprintf(os.Stderr, \"go: unknown subcommand %q\\nRun 'go help' for usage.\\n\", args[0])\n-\tsetExitStatus(2)\n-\texit()\n-}\n-\n-var usageTemplate = `Go is a tool for managing Go source code.\n-\n-Usage:\n-\n-\tgo command [arguments]\n-\n-The commands are:\n-{{range .}}{{if .Runnable}}\n-\t{{.Name | printf \"%-11s\"}} {{.Short}}{{end}}{{end}}\n-\n-Use \"go help [command]\" for more information about a command.\n-\n-Additional help topics:\n-{{range .}}{{if not .Runnable}}\n-\t{{.Name | printf \"%-11s\"}} {{.Short}}{{end}}{{end}}\n-\n-Use \"go help [topic]\" for more information about that topic.\n-\n-`\n-\n-var helpTemplate = `{{if .Runnable}}usage: go {{.UsageLine}}\n-\n-{{end}}{{.Long | trim}}\n-`\n-\n-var documentationTemplate = `{{range .}}{{if .Short}}{{.Short | capitalize}}\n-\n-{{end}}{{if .Runnable}}Usage:\n-\n-\tgo {{.UsageLine}}\n-\n-{{end}}{{.Long | trim}}\n-\n-\n-{{end}}`\n-\n-// commentWriter writes a Go comment to the underlying io.Writer,\n-// using line comment form (//).\n-type commentWriter struct {\n-\tW            io.Writer\n-\twroteSlashes bool // Wrote \"//\" at the beginning of the current line.\n-}\n-\n-func (c *commentWriter) Write(p []byte) (int, error) {\n-\tvar n int\n-\tfor i, b := range p {\n-\t\tif !c.wroteSlashes {\n-\t\t\ts := \"//\"\n-\t\t\tif b != '\\n' {\n-\t\t\t\ts = \"// \"\n-\t\t\t}\n-\t\t\tif _, err := io.WriteString(c.W, s); err != nil {\n-\t\t\t\treturn n, err\n-\t\t\t}\n-\t\t\tc.wroteSlashes = true\n-\t\t}\n-\t\tn0, err := c.W.Write(p[i : i+1])\n-\t\tn += n0\n-\t\tif err != nil {\n-\t\t\treturn n, err\n-\t\t}\n-\t\tif b == '\\n' {\n-\t\t\tc.wroteSlashes = false\n-\t\t}\n-\t}\n-\treturn len(p), nil\n-}\n-\n-// An errWriter wraps a writer, recording whether a write error occurred.\n-type errWriter struct {\n-\tw   io.Writer\n-\terr error\n+\tbase.SetExitStatus(2)\n+\tbase.Exit()\n }\n \n-func (w *errWriter) Write(b []byte) (int, error) {\n-\tn, err := w.w.Write(b)\n-\tif err != nil {\n-\t\tw.err = err\n-\t}\n-\treturn n, err\n+func init() {\n+\tbase.Usage = mainUsage\n }\n \n-// tmpl executes the given template text on data, writing the result to w.\n-func tmpl(w io.Writer, text string, data interface{}) {\n-\tt := template.New(\"top\")\n-\tt.Funcs(template.FuncMap{\"trim\": strings.TrimSpace, \"capitalize\": capitalize})\n-\ttemplate.Must(t.Parse(text))\n-\tew := &errWriter{w: w}\n-\terr := t.Execute(ew, data)\n-\tif ew.err != nil {\n-\t\t// I/O error writing. Ignore write on closed pipe.\n-\t\tif strings.Contains(ew.err.Error(), \"pipe\") {\n-\t\t\tos.Exit(1)\n-\t\t}\n-\t\tfatalf(\"writing output: %v\", ew.err)\n-\t}\n-\tif err != nil {\n-\t\tpanic(err)\n-\t}\n-}\n-\n-func capitalize(s string) string {\n-\tif s == \"\" {\n-\t\treturn s\n-\t}\n-\tr, n := utf8.DecodeRuneInString(s)\n-\treturn string(unicode.ToTitle(r)) + s[n:]\n-}\n-\n-func printUsage(w io.Writer) {\n-\tbw := bufio.NewWriter(w)\n-\ttmpl(bw, usageTemplate, commands)\n-\tbw.Flush()\n-}\n-\n-func usage() {\n+func mainUsage() {\n \t// special case \"go test -h\"\n \tif len(os.Args) > 1 && os.Args[1] == \"test\" {\n-\t\tos.Stderr.WriteString(testUsage + \"\\n\\n\" +\n-\t\t\tstrings.TrimSpace(testFlag1) + \"\\n\\n\\t\" +\n-\t\t\tstrings.TrimSpace(testFlag2) + \"\\n\")\n-\t\tos.Exit(2)\n+\t\ttest.Usage()\n \t}\n-\tprintUsage(os.Stderr)\n+\thelp.PrintUsage(os.Stderr)\n \tos.Exit(2)\n }\n-\n-// help implements the 'help' command.\n-func help(args []string) {\n-\tif len(args) == 0 {\n-\t\tprintUsage(os.Stdout)\n-\t\t// not exit 2: succeeded at 'go help'.\n-\t\treturn\n-\t}\n-\tif len(args) != 1 {\n-\t\tfmt.Fprintf(os.Stderr, \"usage: go help command\\n\\nToo many arguments given.\\n\")\n-\t\tos.Exit(2) // failed at 'go help'\n-\t}\n-\n-\targ := args[0]\n-\n-\t// 'go help documentation' generates doc.go.\n-\tif arg == \"documentation\" {\n-\t\tfmt.Println(\"// Copyright 2011 The Go Authors. All rights reserved.\")\n-\t\tfmt.Println(\"// Use of this source code is governed by a BSD-style\")\n-\t\tfmt.Println(\"// license that can be found in the LICENSE file.\")\n-\t\tfmt.Println()\n-\t\tfmt.Println(\"// DO NOT EDIT THIS FILE. GENERATED BY mkalldocs.sh.\")\n-\t\tfmt.Println(\"// Edit the documentation in other files and rerun mkalldocs.sh to generate this one.\")\n-\t\tfmt.Println()\n-\t\tbuf := new(bytes.Buffer)\n-\t\tprintUsage(buf)\n-\t\tusage := &Command{Long: buf.String()}\n-\t\ttmpl(&commentWriter{W: os.Stdout}, documentationTemplate, append([]*Command{usage}, commands...))\n-\t\tfmt.Println(\"package main\")\n-\t\treturn\n-\t}\n-\n-\tfor _, cmd := range commands {\n-\t\tif cmd.Name() == arg {\n-\t\t\ttmpl(os.Stdout, helpTemplate, cmd)\n-\t\t\t// not exit 2: succeeded at 'go help cmd'.\n-\t\t\treturn\n-\t\t}\n-\t}\n-\n-\tfmt.Fprintf(os.Stderr, \"Unknown help topic %#q.  Run 'go help'.\\n\", arg)\n-\tos.Exit(2) // failed at 'go help cmd'\n-}\n-\n-// importPathsNoDotExpansion returns the import paths to use for the given\n-// command line, but it does no ... expansion.\n-func importPathsNoDotExpansion(args []string) []string {\n-\tif len(args) == 0 {\n-\t\treturn []string{\".\"}\n-\t}\n-\tvar out []string\n-\tfor _, a := range args {\n-\t\t// Arguments are supposed to be import paths, but\n-\t\t// as a courtesy to Windows developers, rewrite \\ to /\n-\t\t// in command-line arguments. Handles .\\... and so on.\n-\t\tif filepath.Separator == '\\\\' {\n-\t\t\ta = strings.Replace(a, `\\`, `/`, -1)\n-\t\t}\n-\n-\t\t// Put argument in canonical form, but preserve leading ./.\n-\t\tif strings.HasPrefix(a, \"./\") {\n-\t\t\ta = \"./\" + path.Clean(a)\n-\t\t\tif a == \"./.\" {\n-\t\t\t\ta = \".\"\n-\t\t\t}\n-\t\t} else {\n-\t\t\ta = path.Clean(a)\n-\t\t}\n-\t\tif isMetaPackage(a) {\n-\t\t\tout = append(out, allPackages(a)...)\n-\t\t\tcontinue\n-\t\t}\n-\t\tout = append(out, a)\n-\t}\n-\treturn out\n-}\n-\n-// importPaths returns the import paths to use for the given command line.\n-func importPaths(args []string) []string {\n-\targs = importPathsNoDotExpansion(args)\n-\tvar out []string\n-\tfor _, a := range args {\n-\t\tif strings.Contains(a, \"...\") {\n-\t\t\tif build.IsLocalImport(a) {\n-\t\t\t\tout = append(out, allPackagesInFS(a)...)\n-\t\t\t} else {\n-\t\t\t\tout = append(out, allPackages(a)...)\n-\t\t\t}\n-\t\t\tcontinue\n-\t\t}\n-\t\tout = append(out, a)\n-\t}\n-\treturn out\n-}\n-\n-var atexitFuncs []func()\n-\n-func atexit(f func()) {\n-\tatexitFuncs = append(atexitFuncs, f)\n-}\n-\n-func exit() {\n-\tfor _, f := range atexitFuncs {\n-\t\tf()\n-\t}\n-\tos.Exit(exitStatus)\n-}\n-\n-func fatalf(format string, args ...interface{}) {\n-\terrorf(format, args...)\n-\texit()\n-}\n-\n-func errorf(format string, args ...interface{}) {\n-\tlog.Printf(format, args...)\n-\tsetExitStatus(1)\n-}\n-\n-func exitIfErrors() {\n-\tif exitStatus != 0 {\n-\t\texit()\n-\t}\n-}\n-\n-func run(cmdargs ...interface{}) {\n-\tcmdline := stringList(cmdargs...)\n-\tif buildN || buildX {\n-\t\tfmt.Printf(\"%s\\n\", strings.Join(cmdline, \" \"))\n-\t\tif buildN {\n-\t\t\treturn\n-\t\t}\n-\t}\n-\n-\tcmd := exec.Command(cmdline[0], cmdline[1:]...)\n-\tcmd.Stdout = os.Stdout\n-\tcmd.Stderr = os.Stderr\n-\tif err := cmd.Run(); err != nil {\n-\t\terrorf(\"%v\", err)\n-\t}\n-}\n-\n-// envForDir returns a copy of the environment\n-// suitable for running in the given directory.\n-// The environment is the current process's environment\n-// but with an updated $PWD, so that an os.Getwd in the\n-// child will be faster.\n-func envForDir(dir string, base []string) []string {\n-\t// Internally we only use rooted paths, so dir is rooted.\n-\t// Even if dir is not rooted, no harm done.\n-\treturn mergeEnvLists([]string{\"PWD=\" + dir}, base)\n-}\n-\n-// mergeEnvLists merges the two environment lists such that\n-// variables with the same name in \"in\" replace those in \"out\".\n-// This always returns a newly allocated slice.\n-func mergeEnvLists(in, out []string) []string {\n-\tout = append([]string(nil), out...)\n-NextVar:\n-\tfor _, inkv := range in {\n-\t\tk := strings.SplitAfterN(inkv, \"=\", 2)[0]\n-\t\tfor i, outkv := range out {\n-\t\t\tif strings.HasPrefix(outkv, k) {\n-\t\t\t\tout[i] = inkv\n-\t\t\t\tcontinue NextVar\n-\t\t\t}\n-\t\t}\n-\t\tout = append(out, inkv)\n-\t}\n-\treturn out\n-}\n-\n-// matchPattern(pattern)(name) reports whether\n-// name matches pattern. Pattern is a limited glob\n-// pattern in which '...' means 'any string' and there\n-// is no other special syntax.\n-func matchPattern(pattern string) func(name string) bool {\n-\tre := regexp.QuoteMeta(pattern)\n-\tre = strings.Replace(re, `\\.\\.\\.`, `.*`, -1)\n-\t// Special case: foo/... matches foo too.\n-\tif strings.HasSuffix(re, `/.*`) {\n-\t\tre = re[:len(re)-len(`/.*`)] + `(/.*)?`\n-\t}\n-\treg := regexp.MustCompile(`^` + re + `$`)\n-\treturn func(name string) bool {\n-\t\treturn reg.MatchString(name)\n-\t}\n-}\n-\n-// hasPathPrefix reports whether the path s begins with the\n-// elements in prefix.\n-func hasPathPrefix(s, prefix string) bool {\n-\tswitch {\n-\tdefault:\n-\t\treturn false\n-\tcase len(s) == len(prefix):\n-\t\treturn s == prefix\n-\tcase len(s) > len(prefix):\n-\t\tif prefix != \"\" && prefix[len(prefix)-1] == '/' {\n-\t\t\treturn strings.HasPrefix(s, prefix)\n-\t\t}\n-\t\treturn s[len(prefix)] == '/' && s[:len(prefix)] == prefix\n-\t}\n-}\n-\n-// hasFilePathPrefix reports whether the filesystem path s begins with the\n-// elements in prefix.\n-func hasFilePathPrefix(s, prefix string) bool {\n-\tsv := strings.ToUpper(filepath.VolumeName(s))\n-\tpv := strings.ToUpper(filepath.VolumeName(prefix))\n-\ts = s[len(sv):]\n-\tprefix = prefix[len(pv):]\n-\tswitch {\n-\tdefault:\n-\t\treturn false\n-\tcase sv != pv:\n-\t\treturn false\n-\tcase len(s) == len(prefix):\n-\t\treturn s == prefix\n-\tcase len(s) > len(prefix):\n-\t\tif prefix != \"\" && prefix[len(prefix)-1] == filepath.Separator {\n-\t\t\treturn strings.HasPrefix(s, prefix)\n-\t\t}\n-\t\treturn s[len(prefix)] == filepath.Separator && s[:len(prefix)] == prefix\n-\t}\n-}\n-\n-// expandPath returns the symlink-expanded form of path.\n-func expandPath(p string) string {\n-\tx, err := filepath.EvalSymlinks(p)\n-\tif err == nil {\n-\t\treturn x\n-\t}\n-\treturn p\n-}\n-\n-// treeCanMatchPattern(pattern)(name) reports whether\n-// name or children of name can possibly match pattern.\n-// Pattern is the same limited glob accepted by matchPattern.\n-func treeCanMatchPattern(pattern string) func(name string) bool {\n-\twildCard := false\n-\tif i := strings.Index(pattern, \"...\"); i >= 0 {\n-\t\twildCard = true\n-\t\tpattern = pattern[:i]\n-\t}\n-\treturn func(name string) bool {\n-\t\treturn len(name) <= len(pattern) && hasPathPrefix(pattern, name) ||\n-\t\t\twildCard && strings.HasPrefix(name, pattern)\n-\t}\n-}\n-\n-// allPackages returns all the packages that can be found\n-// under the $GOPATH directories and $GOROOT matching pattern.\n-// The pattern is either \"all\" (all packages), \"std\" (standard packages),\n-// \"cmd\" (standard commands), or a path including \"...\".\n-func allPackages(pattern string) []string {\n-\tpkgs := matchPackages(pattern)\n-\tif len(pkgs) == 0 {\n-\t\tfmt.Fprintf(os.Stderr, \"warning: %q matched no packages\\n\", pattern)\n-\t}\n-\treturn pkgs\n-}\n-\n-func matchPackages(pattern string) []string {\n-\tmatch := func(string) bool { return true }\n-\ttreeCanMatch := func(string) bool { return true }\n-\tif !isMetaPackage(pattern) {\n-\t\tmatch = matchPattern(pattern)\n-\t\ttreeCanMatch = treeCanMatchPattern(pattern)\n-\t}\n-\n-\thave := map[string]bool{\n-\t\t\"builtin\": true, // ignore pseudo-package that exists only for documentation\n-\t}\n-\tif !buildContext.CgoEnabled {\n-\t\thave[\"runtime/cgo\"] = true // ignore during walk\n-\t}\n-\tvar pkgs []string\n-\n-\tfor _, src := range buildContext.SrcDirs() {\n-\t\tif (pattern == \"std\" || pattern == \"cmd\") && src != gorootSrc {\n-\t\t\tcontinue\n-\t\t}\n-\t\tsrc = filepath.Clean(src) + string(filepath.Separator)\n-\t\troot := src\n-\t\tif pattern == \"cmd\" {\n-\t\t\troot += \"cmd\" + string(filepath.Separator)\n-\t\t}\n-\t\tfilepath.Walk(root, func(path string, fi os.FileInfo, err error) error {\n-\t\t\tif err != nil || !fi.IsDir() || path == src {\n-\t\t\t\treturn nil\n-\t\t\t}\n-\n-\t\t\t// Avoid .foo, _foo, and testdata directory trees.\n-\t\t\t_, elem := filepath.Split(path)\n-\t\t\tif strings.HasPrefix(elem, \".\") || strings.HasPrefix(elem, \"_\") || elem == \"testdata\" {\n-\t\t\t\treturn filepath.SkipDir\n-\t\t\t}\n-\n-\t\t\tname := filepath.ToSlash(path[len(src):])\n-\t\t\tif pattern == \"std\" && (!isStandardImportPath(name) || name == \"cmd\") {\n-\t\t\t\t// The name \"std\" is only the standard library.\n-\t\t\t\t// If the name is cmd, it's the root of the command tree.\n-\t\t\t\treturn filepath.SkipDir\n-\t\t\t}\n-\t\t\tif !treeCanMatch(name) {\n-\t\t\t\treturn filepath.SkipDir\n-\t\t\t}\n-\t\t\tif have[name] {\n-\t\t\t\treturn nil\n-\t\t\t}\n-\t\t\thave[name] = true\n-\t\t\tif !match(name) {\n-\t\t\t\treturn nil\n-\t\t\t}\n-\t\t\t_, err = buildContext.ImportDir(path, 0)\n-\t\t\tif err != nil {\n-\t\t\t\tif _, noGo := err.(*build.NoGoError); noGo {\n-\t\t\t\t\treturn nil\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tpkgs = append(pkgs, name)\n-\t\t\treturn nil\n-\t\t})\n-\t}\n-\treturn pkgs\n-}\n-\n-// allPackagesInFS is like allPackages but is passed a pattern\n-// beginning ./ or ../, meaning it should scan the tree rooted\n-// at the given directory. There are ... in the pattern too.\n-func allPackagesInFS(pattern string) []string {\n-\tpkgs := matchPackagesInFS(pattern)\n-\tif len(pkgs) == 0 {\n-\t\tfmt.Fprintf(os.Stderr, \"warning: %q matched no packages\\n\", pattern)\n-\t}\n-\treturn pkgs\n-}\n-\n-func matchPackagesInFS(pattern string) []string {\n-\t// Find directory to begin the scan.\n-\t// Could be smarter but this one optimization\n-\t// is enough for now, since ... is usually at the\n-\t// end of a path.\n-\ti := strings.Index(pattern, \"...\")\n-\tdir, _ := path.Split(pattern[:i])\n-\n-\t// pattern begins with ./ or ../.\n-\t// path.Clean will discard the ./ but not the ../.\n-\t// We need to preserve the ./ for pattern matching\n-\t// and in the returned import paths.\n-\tprefix := \"\"\n-\tif strings.HasPrefix(pattern, \"./\") {\n-\t\tprefix = \"./\"\n-\t}\n-\tmatch := matchPattern(pattern)\n-\n-\tvar pkgs []string\n-\tfilepath.Walk(dir, func(path string, fi os.FileInfo, err error) error {\n-\t\tif err != nil || !fi.IsDir() {\n-\t\t\treturn nil\n-\t\t}\n-\t\tif path == dir {\n-\t\t\t// filepath.Walk starts at dir and recurses. For the recursive case,\n-\t\t\t// the path is the result of filepath.Join, which calls filepath.Clean.\n-\t\t\t// The initial case is not Cleaned, though, so we do this explicitly.\n-\t\t\t//\n-\t\t\t// This converts a path like \"./io/\" to \"io\". Without this step, running\n-\t\t\t// \"cd $GOROOT/src; go list ./io/...\" would incorrectly skip the io\n-\t\t\t// package, because prepending the prefix \"./\" to the unclean path would\n-\t\t\t// result in \"././io\", and match(\"././io\") returns false.\n-\t\t\tpath = filepath.Clean(path)\n-\t\t}\n-\n-\t\t// Avoid .foo, _foo, and testdata directory trees, but do not avoid \".\" or \"..\".\n-\t\t_, elem := filepath.Split(path)\n-\t\tdot := strings.HasPrefix(elem, \".\") && elem != \".\" && elem != \"..\"\n-\t\tif dot || strings.HasPrefix(elem, \"_\") || elem == \"testdata\" {\n-\t\t\treturn filepath.SkipDir\n-\t\t}\n-\n-\t\tname := prefix + filepath.ToSlash(path)\n-\t\tif !match(name) {\n-\t\t\treturn nil\n-\t\t}\n-\n-\t\t// We keep the directory if we can import it, or if we can't import it\n-\t\t// due to invalid Go source files. This means that directories containing\n-\t\t// parse errors will be built (and fail) instead of being silently skipped\n-\t\t// as not matching the pattern. Go 1.5 and earlier skipped, but that\n-\t\t// behavior means people miss serious mistakes.\n-\t\t// See golang.org/issue/11407.\n-\t\tif p, err := buildContext.ImportDir(path, 0); err != nil && (p == nil || len(p.InvalidGoFiles) == 0) {\n-\t\t\tif _, noGo := err.(*build.NoGoError); !noGo {\n-\t\t\t\tlog.Print(err)\n-\t\t\t}\n-\t\t\treturn nil\n-\t\t}\n-\t\tpkgs = append(pkgs, name)\n-\t\treturn nil\n-\t})\n-\treturn pkgs\n-}\n-\n-// stringList's arguments should be a sequence of string or []string values.\n-// stringList flattens them into a single []string.\n-func stringList(args ...interface{}) []string {\n-\tvar x []string\n-\tfor _, arg := range args {\n-\t\tswitch arg := arg.(type) {\n-\t\tcase []string:\n-\t\t\tx = append(x, arg...)\n-\t\tcase string:\n-\t\t\tx = append(x, arg)\n-\t\tdefault:\n-\t\t\tpanic(\"stringList: invalid argument of type \" + fmt.Sprintf(\"%T\", arg))\n-\t\t}\n-\t}\n-\treturn x\n-}\n-\n-// toFold returns a string with the property that\n-//\tstrings.EqualFold(s, t) iff toFold(s) == toFold(t)\n-// This lets us test a large set of strings for fold-equivalent\n-// duplicates without making a quadratic number of calls\n-// to EqualFold. Note that strings.ToUpper and strings.ToLower\n-// have the desired property in some corner cases.\n-func toFold(s string) string {\n-\t// Fast path: all ASCII, no upper case.\n-\t// Most paths look like this already.\n-\tfor i := 0; i < len(s); i++ {\n-\t\tc := s[i]\n-\t\tif c >= utf8.RuneSelf || 'A' <= c && c <= 'Z' {\n-\t\t\tgoto Slow\n-\t\t}\n-\t}\n-\treturn s\n-\n-Slow:\n-\tvar buf bytes.Buffer\n-\tfor _, r := range s {\n-\t\t// SimpleFold(x) cycles to the next equivalent rune > x\n-\t\t// or wraps around to smaller values. Iterate until it wraps,\n-\t\t// and we've found the minimum value.\n-\t\tfor {\n-\t\t\tr0 := r\n-\t\t\tr = unicode.SimpleFold(r0)\n-\t\t\tif r <= r0 {\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t}\n-\t\t// Exception to allow fast path above: A-Z => a-z\n-\t\tif 'A' <= r && r <= 'Z' {\n-\t\t\tr += 'a' - 'A'\n-\t\t}\n-\t\tbuf.WriteRune(r)\n-\t}\n-\treturn buf.String()\n-}\n-\n-// foldDup reports a pair of strings from the list that are\n-// equal according to strings.EqualFold.\n-// It returns \"\", \"\" if there are no such strings.\n-func foldDup(list []string) (string, string) {\n-\tclash := map[string]string{}\n-\tfor _, s := range list {\n-\t\tfold := toFold(s)\n-\t\tif t := clash[fold]; t != \"\" {\n-\t\t\tif s > t {\n-\t\t\t\ts, t = t, s\n-\t\t\t}\n-\t\t\treturn s, t\n-\t\t}\n-\t\tclash[fold] = s\n-\t}\n-\treturn \"\", \"\"\n-}"}, {"sha": "e0ad562384db15e5a74b18bfecf1854349f66363", "filename": "libgo/go/cmd/go/match_test.go", "status": "removed", "additions": 0, "deletions": 88, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a41a6142df74219f596e612d3a7775f68ca6e96f/libgo%2Fgo%2Fcmd%2Fgo%2Fmatch_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a41a6142df74219f596e612d3a7775f68ca6e96f/libgo%2Fgo%2Fcmd%2Fgo%2Fmatch_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fmatch_test.go?ref=a41a6142df74219f596e612d3a7775f68ca6e96f", "patch": "@@ -1,88 +0,0 @@\n-// Copyright 2012 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package main\n-\n-import \"testing\"\n-\n-var matchPatternTests = []stringPairTest{\n-\t{\"...\", \"foo\", true},\n-\t{\"net\", \"net\", true},\n-\t{\"net\", \"net/http\", false},\n-\t{\"net/http\", \"net\", false},\n-\t{\"net/http\", \"net/http\", true},\n-\t{\"net...\", \"netchan\", true},\n-\t{\"net...\", \"net\", true},\n-\t{\"net...\", \"net/http\", true},\n-\t{\"net...\", \"not/http\", false},\n-\t{\"net/...\", \"netchan\", false},\n-\t{\"net/...\", \"net\", true},\n-\t{\"net/...\", \"net/http\", true},\n-\t{\"net/...\", \"not/http\", false},\n-}\n-\n-func TestMatchPattern(t *testing.T) {\n-\ttestStringPairs(t, \"matchPattern\", matchPatternTests, func(pattern, name string) bool {\n-\t\treturn matchPattern(pattern)(name)\n-\t})\n-}\n-\n-var treeCanMatchPatternTests = []stringPairTest{\n-\t{\"...\", \"foo\", true},\n-\t{\"net\", \"net\", true},\n-\t{\"net\", \"net/http\", false},\n-\t{\"net/http\", \"net\", true},\n-\t{\"net/http\", \"net/http\", true},\n-\t{\"net...\", \"netchan\", true},\n-\t{\"net...\", \"net\", true},\n-\t{\"net...\", \"net/http\", true},\n-\t{\"net...\", \"not/http\", false},\n-\t{\"net/...\", \"netchan\", false},\n-\t{\"net/...\", \"net\", true},\n-\t{\"net/...\", \"net/http\", true},\n-\t{\"net/...\", \"not/http\", false},\n-\t{\"abc.../def\", \"abcxyz\", true},\n-\t{\"abc.../def\", \"xyxabc\", false},\n-\t{\"x/y/z/...\", \"x\", true},\n-\t{\"x/y/z/...\", \"x/y\", true},\n-\t{\"x/y/z/...\", \"x/y/z\", true},\n-\t{\"x/y/z/...\", \"x/y/z/w\", true},\n-\t{\"x/y/z\", \"x\", true},\n-\t{\"x/y/z\", \"x/y\", true},\n-\t{\"x/y/z\", \"x/y/z\", true},\n-\t{\"x/y/z\", \"x/y/z/w\", false},\n-\t{\"x/.../y/z\", \"x/a/b/c\", true},\n-\t{\"x/.../y/z\", \"y/x/a/b/c\", false},\n-}\n-\n-func TestChildrenCanMatchPattern(t *testing.T) {\n-\ttestStringPairs(t, \"treeCanMatchPattern\", treeCanMatchPatternTests, func(pattern, name string) bool {\n-\t\treturn treeCanMatchPattern(pattern)(name)\n-\t})\n-}\n-\n-var hasPathPrefixTests = []stringPairTest{\n-\t{\"abc\", \"a\", false},\n-\t{\"a/bc\", \"a\", true},\n-\t{\"a\", \"a\", true},\n-\t{\"a/bc\", \"a/\", true},\n-}\n-\n-func TestHasPathPrefix(t *testing.T) {\n-\ttestStringPairs(t, \"hasPathPrefix\", hasPathPrefixTests, hasPathPrefix)\n-}\n-\n-type stringPairTest struct {\n-\tin1 string\n-\tin2 string\n-\tout bool\n-}\n-\n-func testStringPairs(t *testing.T, name string, tests []stringPairTest, f func(string, string) bool) {\n-\tfor _, tt := range tests {\n-\t\tif out := f(tt.in1, tt.in2); out != tt.out {\n-\t\t\tt.Errorf(\"%s(%q, %q) = %v, want %v\", name, tt.in1, tt.in2, out, tt.out)\n-\t\t}\n-\t}\n-}"}, {"sha": "f33efdce226f3dcfd4576a7a892c11b2a688cbcd", "filename": "libgo/go/cmd/go/note_test.go", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Fnote_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Fnote_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fnote_test.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -7,10 +7,11 @@\n package main_test\n \n import (\n-\tmain \"cmd/go\"\n \t\"go/build\"\n \t\"runtime\"\n \t\"testing\"\n+\n+\t\"cmd/go/internal/buildid\"\n )\n \n func TestNoteReading(t *testing.T) {\n@@ -23,9 +24,9 @@ func TestNoteReading2K(t *testing.T) {\n \t}\n \t// Set BuildIDReadSize to 2kB to exercise Mach-O parsing more strictly.\n \tdefer func(old int) {\n-\t\tmain.BuildIDReadSize = old\n-\t}(main.BuildIDReadSize)\n-\tmain.BuildIDReadSize = 2 * 1024\n+\t\tbuildid.BuildIDReadSize = old\n+\t}(buildid.BuildIDReadSize)\n+\tbuildid.BuildIDReadSize = 2 * 1024\n \n \ttestNoteReading(t)\n }\n@@ -36,7 +37,7 @@ func testNoteReading(t *testing.T) {\n \ttg.tempFile(\"hello.go\", `package main; func main() { print(\"hello, world\\n\") }`)\n \tconst buildID = \"TestNoteReading-Build-ID\"\n \ttg.run(\"build\", \"-ldflags\", \"-buildid=\"+buildID, \"-o\", tg.path(\"hello.exe\"), tg.path(\"hello.go\"))\n-\tid, err := main.ReadBuildIDFromBinary(tg.path(\"hello.exe\"))\n+\tid, err := buildid.ReadBuildIDFromBinary(tg.path(\"hello.exe\"))\n \tif err != nil {\n \t\tt.Fatalf(\"reading build ID from hello binary: %v\", err)\n \t}\n@@ -56,7 +57,7 @@ func testNoteReading(t *testing.T) {\n \t}\n \n \ttg.run(\"build\", \"-ldflags\", \"-buildid=\"+buildID+\" -linkmode=external\", \"-o\", tg.path(\"hello.exe\"), tg.path(\"hello.go\"))\n-\tid, err = main.ReadBuildIDFromBinary(tg.path(\"hello.exe\"))\n+\tid, err = buildid.ReadBuildIDFromBinary(tg.path(\"hello.exe\"))\n \tif err != nil {\n \t\tt.Fatalf(\"reading build ID from hello binary (linkmode=external): %v\", err)\n \t}"}, {"sha": "fba13636cdd195bfd63a10840592d37c5287a638", "filename": "libgo/go/cmd/go/pkg_test.go", "status": "removed", "additions": 0, "deletions": 194, "changes": 194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a41a6142df74219f596e612d3a7775f68ca6e96f/libgo%2Fgo%2Fcmd%2Fgo%2Fpkg_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a41a6142df74219f596e612d3a7775f68ca6e96f/libgo%2Fgo%2Fcmd%2Fgo%2Fpkg_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fpkg_test.go?ref=a41a6142df74219f596e612d3a7775f68ca6e96f", "patch": "@@ -1,194 +0,0 @@\n-// Copyright 2014 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package main\n-\n-import (\n-\t\"io/ioutil\"\n-\t\"os\"\n-\t\"path/filepath\"\n-\t\"reflect\"\n-\t\"strings\"\n-\t\"testing\"\n-)\n-\n-var foldDupTests = []struct {\n-\tlist   []string\n-\tf1, f2 string\n-}{\n-\t{stringList(\"math/rand\", \"math/big\"), \"\", \"\"},\n-\t{stringList(\"math\", \"strings\"), \"\", \"\"},\n-\t{stringList(\"strings\"), \"\", \"\"},\n-\t{stringList(\"strings\", \"strings\"), \"strings\", \"strings\"},\n-\t{stringList(\"Rand\", \"rand\", \"math\", \"math/rand\", \"math/Rand\"), \"Rand\", \"rand\"},\n-}\n-\n-func TestFoldDup(t *testing.T) {\n-\tfor _, tt := range foldDupTests {\n-\t\tf1, f2 := foldDup(tt.list)\n-\t\tif f1 != tt.f1 || f2 != tt.f2 {\n-\t\t\tt.Errorf(\"foldDup(%q) = %q, %q, want %q, %q\", tt.list, f1, f2, tt.f1, tt.f2)\n-\t\t}\n-\t}\n-}\n-\n-var parseMetaGoImportsTests = []struct {\n-\tin  string\n-\tout []metaImport\n-}{\n-\t{\n-\t\t`<meta name=\"go-import\" content=\"foo/bar git https://github.com/rsc/foo/bar\">`,\n-\t\t[]metaImport{{\"foo/bar\", \"git\", \"https://github.com/rsc/foo/bar\"}},\n-\t},\n-\t{\n-\t\t`<meta name=\"go-import\" content=\"foo/bar git https://github.com/rsc/foo/bar\">\n-\t\t<meta name=\"go-import\" content=\"baz/quux git http://github.com/rsc/baz/quux\">`,\n-\t\t[]metaImport{\n-\t\t\t{\"foo/bar\", \"git\", \"https://github.com/rsc/foo/bar\"},\n-\t\t\t{\"baz/quux\", \"git\", \"http://github.com/rsc/baz/quux\"},\n-\t\t},\n-\t},\n-\t{\n-\t\t`<head>\n-\t\t<meta name=\"go-import\" content=\"foo/bar git https://github.com/rsc/foo/bar\">\n-\t\t</head>`,\n-\t\t[]metaImport{{\"foo/bar\", \"git\", \"https://github.com/rsc/foo/bar\"}},\n-\t},\n-\t{\n-\t\t`<meta name=\"go-import\" content=\"foo/bar git https://github.com/rsc/foo/bar\">\n-\t\t<body>`,\n-\t\t[]metaImport{{\"foo/bar\", \"git\", \"https://github.com/rsc/foo/bar\"}},\n-\t},\n-\t{\n-\t\t`<!doctype html><meta name=\"go-import\" content=\"foo/bar git https://github.com/rsc/foo/bar\">`,\n-\t\t[]metaImport{{\"foo/bar\", \"git\", \"https://github.com/rsc/foo/bar\"}},\n-\t},\n-\t{\n-\t\t// XML doesn't like <div style=position:relative>.\n-\t\t`<!doctype html><title>Page Not Found</title><meta name=go-import content=\"chitin.io/chitin git https://github.com/chitin-io/chitin\"><div style=position:relative>DRAFT</div>`,\n-\t\t[]metaImport{{\"chitin.io/chitin\", \"git\", \"https://github.com/chitin-io/chitin\"}},\n-\t},\n-}\n-\n-func TestParseMetaGoImports(t *testing.T) {\n-\tfor i, tt := range parseMetaGoImportsTests {\n-\t\tout, err := parseMetaGoImports(strings.NewReader(tt.in))\n-\t\tif err != nil {\n-\t\t\tt.Errorf(\"test#%d: %v\", i, err)\n-\t\t\tcontinue\n-\t\t}\n-\t\tif !reflect.DeepEqual(out, tt.out) {\n-\t\t\tt.Errorf(\"test#%d:\\n\\thave %q\\n\\twant %q\", i, out, tt.out)\n-\t\t}\n-\t}\n-}\n-\n-func TestSharedLibName(t *testing.T) {\n-\t// TODO(avdva) - make these values platform-specific\n-\tprefix := \"lib\"\n-\tsuffix := \".so\"\n-\ttestData := []struct {\n-\t\targs      []string\n-\t\tpkgs      []*Package\n-\t\texpected  string\n-\t\texpectErr bool\n-\t\trootedAt  string\n-\t}{\n-\t\t{\n-\t\t\targs:     []string{\"std\"},\n-\t\t\tpkgs:     []*Package{},\n-\t\t\texpected: \"std\",\n-\t\t},\n-\t\t{\n-\t\t\targs:     []string{\"std\", \"cmd\"},\n-\t\t\tpkgs:     []*Package{},\n-\t\t\texpected: \"std,cmd\",\n-\t\t},\n-\t\t{\n-\t\t\targs:     []string{},\n-\t\t\tpkgs:     []*Package{&Package{ImportPath: \"gopkg.in/somelib\"}},\n-\t\t\texpected: \"gopkg.in-somelib\",\n-\t\t},\n-\t\t{\n-\t\t\targs:     []string{\"./...\"},\n-\t\t\tpkgs:     []*Package{&Package{ImportPath: \"somelib\"}},\n-\t\t\texpected: \"somelib\",\n-\t\t\trootedAt: \"somelib\",\n-\t\t},\n-\t\t{\n-\t\t\targs:     []string{\"../somelib\", \"../somelib\"},\n-\t\t\tpkgs:     []*Package{&Package{ImportPath: \"somelib\"}},\n-\t\t\texpected: \"somelib\",\n-\t\t},\n-\t\t{\n-\t\t\targs:     []string{\"../lib1\", \"../lib2\"},\n-\t\t\tpkgs:     []*Package{&Package{ImportPath: \"gopkg.in/lib1\"}, &Package{ImportPath: \"gopkg.in/lib2\"}},\n-\t\t\texpected: \"gopkg.in-lib1,gopkg.in-lib2\",\n-\t\t},\n-\t\t{\n-\t\t\targs: []string{\"./...\"},\n-\t\t\tpkgs: []*Package{\n-\t\t\t\t&Package{ImportPath: \"gopkg.in/dir/lib1\"},\n-\t\t\t\t&Package{ImportPath: \"gopkg.in/lib2\"},\n-\t\t\t\t&Package{ImportPath: \"gopkg.in/lib3\"},\n-\t\t\t},\n-\t\t\texpected: \"gopkg.in\",\n-\t\t\trootedAt: \"gopkg.in\",\n-\t\t},\n-\t\t{\n-\t\t\targs:      []string{\"std\", \"../lib2\"},\n-\t\t\tpkgs:      []*Package{},\n-\t\t\texpectErr: true,\n-\t\t},\n-\t\t{\n-\t\t\targs:      []string{\"all\", \"./\"},\n-\t\t\tpkgs:      []*Package{},\n-\t\t\texpectErr: true,\n-\t\t},\n-\t\t{\n-\t\t\targs:      []string{\"cmd\", \"fmt\"},\n-\t\t\tpkgs:      []*Package{},\n-\t\t\texpectErr: true,\n-\t\t},\n-\t}\n-\tfor _, data := range testData {\n-\t\tfunc() {\n-\t\t\tif data.rootedAt != \"\" {\n-\t\t\t\ttmpGopath, err := ioutil.TempDir(\"\", \"gopath\")\n-\t\t\t\tif err != nil {\n-\t\t\t\t\tt.Fatal(err)\n-\t\t\t\t}\n-\t\t\t\toldGopath := buildContext.GOPATH\n-\t\t\t\tdefer func() {\n-\t\t\t\t\tbuildContext.GOPATH = oldGopath\n-\t\t\t\t\tos.Chdir(cwd)\n-\t\t\t\t\terr := os.RemoveAll(tmpGopath)\n-\t\t\t\t\tif err != nil {\n-\t\t\t\t\t\tt.Error(err)\n-\t\t\t\t\t}\n-\t\t\t\t}()\n-\t\t\t\troot := filepath.Join(tmpGopath, \"src\", data.rootedAt)\n-\t\t\t\terr = os.MkdirAll(root, 0755)\n-\t\t\t\tif err != nil {\n-\t\t\t\t\tt.Fatal(err)\n-\t\t\t\t}\n-\t\t\t\tbuildContext.GOPATH = tmpGopath\n-\t\t\t\tos.Chdir(root)\n-\t\t\t}\n-\t\t\tcomputed, err := libname(data.args, data.pkgs)\n-\t\t\tif err != nil {\n-\t\t\t\tif !data.expectErr {\n-\t\t\t\t\tt.Errorf(\"libname returned an error %q, expected a name\", err.Error())\n-\t\t\t\t}\n-\t\t\t} else if data.expectErr {\n-\t\t\t\tt.Errorf(\"libname returned %q, expected an error\", computed)\n-\t\t\t} else {\n-\t\t\t\texpected := prefix + data.expected + suffix\n-\t\t\t\tif expected != computed {\n-\t\t\t\t\tt.Errorf(\"libname returned %q, expected %q\", computed, expected)\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}()\n-\t}\n-}"}, {"sha": "340a7e824cafd64b280d8e50454d752f2f0d0640", "filename": "libgo/go/cmd/go/script", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a41a6142df74219f596e612d3a7775f68ca6e96f/libgo%2Fgo%2Fcmd%2Fgo%2Fscript", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a41a6142df74219f596e612d3a7775f68ca6e96f/libgo%2Fgo%2Fcmd%2Fgo%2Fscript", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fscript?ref=a41a6142df74219f596e612d3a7775f68ca6e96f", "patch": "@@ -1,23 +0,0 @@\n-#!/bin/sh\n-\n-x() {\n-\techo '--- ' \"$@\"\n-\t\"$@\"\n-\techo '---'\n-\techo\n-}\n-\n-x go help\n-x go help build\n-x go help clean\n-x go help install\n-x go help fix\n-x go help fmt\n-x go help get\n-x go help list\n-x go help test\n-x go help version\n-x go help vet\n-x go help gopath\n-x go help importpath\n-x go help remote"}, {"sha": "a672146584e6cae5c5606e25d9effd8a94a2093a", "filename": "libgo/go/cmd/go/script.txt", "status": "removed", "additions": 0, "deletions": 352, "changes": 352, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a41a6142df74219f596e612d3a7775f68ca6e96f/libgo%2Fgo%2Fcmd%2Fgo%2Fscript.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a41a6142df74219f596e612d3a7775f68ca6e96f/libgo%2Fgo%2Fcmd%2Fgo%2Fscript.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fscript.txt?ref=a41a6142df74219f596e612d3a7775f68ca6e96f", "patch": "@@ -1,352 +0,0 @@\n----  go help\n-usage: go command [arguments]\n-\n-go manages Go source code.\n-\n-The commands are:\n-\n-    build       compile and install packages and dependencies\n-    clean       remove intermediate objects\n-    fix         run gofix on packages\n-    fmt         run gofmt -w on packages\n-    get         download and install packages and dependencies\n-    install     install packages and dependencies\n-    list        list packages\n-    test        test packages\n-    version     print Go version\n-    vet         run govet on packages\n-\n-Use \"go help [command]\" for more information about a command.\n-\n-Additional help topics:\n-\n-    gopath      GOPATH environment variable\n-    importpath  description of import paths\n-    remote      remote import path syntax\n-\n-Use \"go help [topic]\" for more information about that topic.\n-\n----\n-\n----  go help build\n-usage: go build [-n] [-v] [importpath...]\n-\n-Build compiles the packages named by the import paths,\n-along with their dependencies, but it does not install the results.\n-\n-The -n flag prints the commands but does not run them.\n-The -v flag prints the commands.\n-\n-For more about import paths, see 'go help importpath'.\n-\n-See also: go install, go get, go clean.\n----\n-\n----  go help clean\n-usage: go clean [-nuke] [importpath...]\n-\n-Clean removes intermediate object files generated during\n-the compilation of the packages named by the import paths,\n-but by default it does not remove the installed package binaries.\n-\n-The -nuke flag causes clean to remove the installed package binaries too.\n-\n-TODO: Clean does not clean dependencies of the packages.\n-\n-For more about import paths, see 'go help importpath'.\n----\n-\n----  go help install\n-usage: go install [-n] [-v] [importpath...]\n-\n-Install compiles and installs the packages named by the import paths,\n-along with their dependencies.\n-\n-The -n flag prints the commands but does not run them.\n-The -v flag prints the commands.\n-\n-For more about import paths, see 'go help importpath'.\n-\n-See also: go build, go get, go clean.\n----\n-\n----  go help fix\n-usage: go fix [importpath...]\n-\n-Fix runs the gofix command on the packages named by the import paths.\n-\n-For more about gofix, see 'godoc gofix'.\n-For more about import paths, see 'go help importpath'.\n-\n-To run gofix with specific options, run gofix itself.\n-\n-See also: go fmt, go vet.\n----\n-\n----  go help fmt\n-usage: go fmt [importpath...]\n-\n-Fmt runs the command 'gofmt -w' on the packages named by the import paths.\n-\n-For more about gofmt, see 'godoc gofmt'.\n-For more about import paths, see 'go help importpath'.\n-\n-To run gofmt with specific options, run gofmt itself.\n-\n-See also: go fix, go vet.\n----\n-\n----  go help get\n-usage: go get [importpath...]\n-\n-Get downloads and installs the packages named by the import paths,\n-along with their dependencies.\n-\n-After downloading the code, 'go get' looks for a tag beginning\n-with \"go.\" that corresponds to the local Go version.\n-For Go \"release.r58\" it looks for a tag named \"go.r58\".\n-For \"weekly.2011-06-03\" it looks for \"go.weekly.2011-06-03\".\n-If the specific \"go.X\" tag is not found, it uses the latest earlier\n-version it can find.  Otherwise, it uses the default version for\n-the version control system: HEAD for git, tip for Mercurial,\n-and so on.\n-\n-TODO: Explain versions better.\n-\n-For more about import paths, see 'go help importpath'.\n-\n-For more about how 'go get' finds source code to\n-download, see 'go help remote'.\n-\n-See also: go build, go install, go clean.\n----\n-\n----  go help list\n-usage: go list [-f format] [-json] [importpath...]\n-\n-List lists the packages named by the import paths.\n-\n-The default output shows the package name and file system location:\n-\n-    books /home/you/src/google-api-go-client.googlecode.com/hg/books/v1\n-    oauth /home/you/src/goauth2.googlecode.com/hg/oauth\n-    sqlite /home/you/src/gosqlite.googlecode.com/hg/sqlite\n-\n-The -f flag specifies an alternate format for the list,\n-using the syntax of package template.  The default output\n-is equivalent to -f '{{.Name}} {{.Dir}}'  The struct\n-being passed to the template is:\n-\n-    type Package struct {\n-        Name string         // package name\n-        Doc string          // package documentation string\n-        GoFiles []string    // names of Go source files in package\n-        ImportPath string   // import path denoting package\n-        Imports []string    // import paths used by this package\n-        Deps []string       // all (recursively) imported dependencies\n-        Dir string          // directory containing package sources\n-        Version string      // version of installed package\n-    }\n-\n-The -json flag causes the package data to be printed in JSON format.\n-\n-For more about import paths, see 'go help importpath'.\n----\n-\n----  go help test\n-usage: go test [importpath...]\n-\n-Test runs gotest to test the packages named by the import paths.\n-It prints a summary of the test results in the format:\n-\n-\ttest archive/tar\n-\tFAIL archive/zip\n-\ttest compress/gzip\n-\t...\n-\n-followed by gotest output for each failed package.\n-\n-For more about import paths, see 'go help importpath'.\n-\n-See also: go build, go compile, go vet.\n----\n-\n----  go help version\n-usage: go version\n-\n-Version prints the Go version, as reported by runtime.Version.\n----\n-\n----  go help vet\n-usage: go vet [importpath...]\n-\n-Vet runs the govet command on the packages named by the import paths.\n-\n-For more about govet, see 'godoc govet'.\n-For more about import paths, see 'go help importpath'.\n-\n-To run govet with specific options, run govet itself.\n-\n-See also: go fmt, go fix.\n----\n-\n----  go help gopath\n-The GOPATH environment variable lists places to look for Go code.\n-On Unix, the value is a colon-separated string.\n-On Windows, the value is a semicolon-separated string.\n-On Plan 9, the value is a list.\n-\n-GOPATH must be set to build and install packages outside the\n-standard Go tree.\n-\n-Each directory listed in GOPATH must have a prescribed structure:\n-\n-The src/ directory holds source code.  The path below 'src'\n-determines the import path or executable name.\n-\n-The pkg/ directory holds installed package objects.\n-As in the Go tree, each target operating system and\n-architecture pair has its own subdirectory of pkg\n-(pkg/GOOS_GOARCH).\n-\n-If DIR is a directory listed in the GOPATH, a package with\n-source in DIR/src/foo/bar can be imported as \"foo/bar\" and\n-has its compiled form installed to \"DIR/pkg/GOOS_GOARCH/foo/bar.a\".\n-\n-The bin/ directory holds compiled commands.\n-Each command is named for its source directory, but only\n-the final element, not the entire path.  That is, the\n-command with source in DIR/src/foo/quux is installed into\n-DIR/bin/quux, not DIR/bin/foo/quux.  The foo/ is stripped\n-so that you can add DIR/bin to your PATH to get at the\n-installed commands.\n-\n-Here's an example directory layout:\n-\n-    GOPATH=/home/user/gocode\n-\n-    /home/user/gocode/\n-        src/\n-            foo/\n-                bar/               (go code in package bar)\n-                    x.go\n-                quux/              (go code in package main)\n-                    y.go\n-        bin/\n-            quux                   (installed command)\n-\t\tpkg/\n-\t\t    linux_amd64/\n-\t\t        foo/\n-\t\t            bar.a          (installed package object)\n-\n-Go searches each directory listed in GOPATH to find source code,\n-but new packages are always downloaded into the first directory \n-in the list.\n----\n-\n----  go help importpath\n-Many commands apply to a set of packages named by import paths:\n-\n-\tgo action [importpath...]\n-\n-An import path that is a rooted path or that begins with\n-a . or .. element is interpreted as a file system path and\n-denotes the package in that directory.\n-\n-Otherwise, the import path P denotes the package found in\n-the directory DIR/src/P for some DIR listed in the GOPATH\n-environment variable (see 'go help gopath'). \n-\n-If no import paths are given, the action applies to the\n-package in the current directory.\n-\n-The special import path \"all\" expands to all package directories\n-found in all the GOPATH trees.  For example, 'go list all' \n-lists all the packages on the local system.\n-\n-An import path can also name a package to be downloaded from\n-a remote repository.  Run 'go help remote' for details.\n-\n-Every package in a program must have a unique import path.\n-By convention, this is arranged by starting each path with a\n-unique prefix that belongs to you.  For example, paths used\n-internally at Google all begin with 'google', and paths\n-denoting remote repositories begin with the path to the code,\n-such as 'project.googlecode.com/'.\n----\n-\n----  go help remote\n-An import path (see 'go help importpath') denotes a package\n-stored in the local file system.  Certain import paths also\n-describe how to obtain the source code for the package using\n-a revision control system.\n-\n-A few common code hosting sites have special syntax:\n-\n-\tBitBucket (Mercurial)\n-\n-\t\timport \"bitbucket.org/user/project\"\n-\t\timport \"bitbucket.org/user/project/sub/directory\"\n-\n-\tGitHub (Git)\n-\n-\t\timport \"github.com/user/project\"\n-\t\timport \"github.com/user/project/sub/directory\"\n-\n-\tGoogle Code Project Hosting (Git, Mercurial, Subversion)\n-\n-\t\timport \"project.googlecode.com/git\"\n-\t\timport \"project.googlecode.com/git/sub/directory\"\n-\n-\t\timport \"project.googlecode.com/hg\"\n-\t\timport \"project.googlecode.com/hg/sub/directory\"\n-\n-\t\timport \"project.googlecode.com/svn/trunk\"\n-\t\timport \"project.googlecode.com/svn/trunk/sub/directory\"\n-\n-\tLaunchpad (Bazaar)\n-\n-\t\timport \"launchpad.net/project\"\n-\t\timport \"launchpad.net/project/series\"\n-\t\timport \"launchpad.net/project/series/sub/directory\"\n-\n-\t\timport \"launchpad.net/~user/project/branch\"\n-\t\timport \"launchpad.net/~user/project/branch/sub/directory\"\n-\n-For code hosted on other servers, an import path of the form\n-\n-\trepository.vcs/path\n-\n-specifies the given repository, with or without the .vcs suffix,\n-using the named version control system, and then the path inside\n-that repository.  The supported version control systems are:\n-\n-\tBazaar      .bzr\n-\tGit         .git\n-\tMercurial   .hg\n-\tSubversion  .svn\n-\n-For example,\n-\n-\timport \"example.org/user/foo.hg\"\n-\n-denotes the root directory of the Mercurial repository at\n-example.org/user/foo or foo.hg, and\n-\n-\timport \"example.org/repo.git/foo/bar\"\n-\n-denotes the foo/bar directory of the Git repository at\n-example.com/repo or repo.git.\n-\n-When a version control system supports multiple protocols,\n-each is tried in turn when downloading.  For example, a Git\n-download tries git://, then https://, then http://.\n-\n-New downloaded packages are written to the first directory\n-listed in the GOPATH environment variable (see 'go help gopath').\n-\n-The go command attempts to download the version of the\n-package appropriate for the Go release being used.\n-Run 'go help install' for more.\n----\n-"}, {"sha": "0060ce2185f3f8e2f3d3545344db5b2814ee9306", "filename": "libgo/go/cmd/go/test.bash", "status": "removed", "additions": 0, "deletions": 820, "changes": 820, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a41a6142df74219f596e612d3a7775f68ca6e96f/libgo%2Fgo%2Fcmd%2Fgo%2Ftest.bash", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a41a6142df74219f596e612d3a7775f68ca6e96f/libgo%2Fgo%2Fcmd%2Fgo%2Ftest.bash", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftest.bash?ref=a41a6142df74219f596e612d3a7775f68ca6e96f", "patch": "@@ -1,820 +0,0 @@\n-#!/bin/bash\n-# Copyright 2012 The Go Authors.  All rights reserved.\n-# Use of this source code is governed by a BSD-style\n-# license that can be found in the LICENSE file.\n-\n-set -e\n-go build -o testgo\n-go() {\n-\techo TEST ERROR: ran go, not testgo: go \"$@\" >&2\n-\texit 2\n-}\n-\n-started=false\n-TEST() {\n-\tif $started; then\n-\t\tstop\n-\tfi\n-\techo TEST: \"$@\"\n-\tstarted=true\n-\tok=true\n-}\n-stop() {\n-\tif ! $started; then\n-\t\techo TEST ERROR: stop missing start >&2\n-\t\texit 2\n-\tfi\n-\tstarted=false\n-\tif $ok; then\n-\t\techo PASS\n-\telse\n-\t\techo FAIL\n-\t\tallok=false\n-\tfi\n-}\n-\n-ok=true\n-allok=true\n-\n-unset GOBIN\n-unset GOPATH\n-unset GOROOT\n-\n-TEST 'file:line in error messages'\n-# Test that error messages have file:line information at beginning of\n-# the line. Also test issue 4917: that the error is on stderr.\n-d=$(TMPDIR=/var/tmp mktemp -d -t testgoXXX)\n-fn=$d/err.go\n-echo \"package main\" > $fn\n-echo 'import \"bar\"' >> $fn\n-./testgo run $fn 2>$d/err.out || true\n-if ! grep -q \"^$fn:\" $d/err.out; then\n-\techo \"missing file:line in error message\"\n-\tcat $d/err.out\n-\tok=false\n-fi\n-rm -r $d\n-\n-# Test local (./) imports.\n-testlocal() {\n-\tlocal=\"$1\"\n-\tTEST local imports $2 '(easy)'\n-\t./testgo build -o hello \"testdata/$local/easy.go\"\n-\t./hello >hello.out\n-\tif ! grep -q '^easysub\\.Hello' hello.out; then\n-\t\techo \"testdata/$local/easy.go did not generate expected output\"\n-\t\tcat hello.out\n-\t\tok=false\n-\tfi\n-\t\n-\tTEST local imports $2 '(easysub)'\n-\t./testgo build -o hello \"testdata/$local/easysub/main.go\"\n-\t./hello >hello.out\n-\tif ! grep -q '^easysub\\.Hello' hello.out; then\n-\t\techo \"testdata/$local/easysub/main.go did not generate expected output\"\n-\t\tcat hello.out\n-\t\tok=false\n-\tfi\n-\t\n-\tTEST local imports $2 '(hard)'\n-\t./testgo build -o hello \"testdata/$local/hard.go\"\n-\t./hello >hello.out\n-\tif ! grep -q '^sub\\.Hello' hello.out || ! grep -q '^subsub\\.Hello' hello.out ; then\n-\t\techo \"testdata/$local/hard.go did not generate expected output\"\n-\t\tcat hello.out\n-\t\tok=false\n-\tfi\n-\t\n-\trm -f hello.out hello\n-\t\n-\t# Test that go install x.go fails.\n-\tTEST local imports $2 '(go install should fail)'\n-\tif ./testgo install \"testdata/$local/easy.go\" >/dev/null 2>&1; then\n-\t\techo \"go install testdata/$local/easy.go succeeded\"\n-\t\tok=false\n-\tfi\n-}\n-\n-# Test local imports\n-testlocal local ''\n-\n-# Test local imports again, with bad characters in the directory name.\n-bad='#$%:, &()*;<=>?\\^{}'\n-rm -rf \"testdata/$bad\"\n-cp -R testdata/local \"testdata/$bad\"\n-testlocal \"$bad\" 'with bad characters in path'\n-rm -rf \"testdata/$bad\"\n-\n-TEST error message for syntax error in test go file says FAIL\n-export GOPATH=$(pwd)/testdata\n-if ./testgo test syntaxerror 2>testdata/err; then\n-\techo 'go test syntaxerror succeeded'\n-\tok=false\n-elif ! grep FAIL testdata/err >/dev/null; then\n-\techo 'go test did not say FAIL:'\n-\tcat testdata/err\n-\tok=false\n-fi\n-rm -f ./testdata/err\n-unset GOPATH\n-\n-TEST wildcards do not look in useless directories\n-export GOPATH=$(pwd)/testdata\n-if ./testgo list ... >testdata/err 2>&1; then\n-\techo \"go list ... succeeded\"\n-\tok=false\n-elif ! grep badpkg testdata/err >/dev/null; then\n-\techo \"go list ... failure does not mention badpkg\"\n-\tcat testdata/err\n-\tok=false\n-elif ! ./testgo list m... >testdata/err 2>&1; then\n-\techo \"go list m... failed\"\n-\tok=false\n-fi\n-rm -rf ./testdata/err\n-unset GOPATH\n-\n-# Test tests with relative imports.\n-TEST relative imports '(go test)'\n-if ! ./testgo test ./testdata/testimport; then\n-\techo \"go test ./testdata/testimport failed\"\n-\tok=false\n-fi\n-\n-# Test installation with relative imports.\n-TEST relative imports '(go test -i)'\n-if ! ./testgo test -i ./testdata/testimport; then\n-    echo \"go test -i ./testdata/testimport failed\"\n-    ok=false\n-fi\n-\n-# Test tests with relative imports in packages synthesized\n-# from Go files named on the command line.\n-TEST relative imports in command-line package\n-if ! ./testgo test ./testdata/testimport/*.go; then\n-\techo \"go test ./testdata/testimport/*.go failed\"\n-\tok=false\n-fi\n-\n-TEST version control error message includes correct directory\n-export GOPATH=$(pwd)/testdata/shadow/root1\n-if ./testgo get -u foo 2>testdata/err; then\n-\techo \"go get -u foo succeeded unexpectedly\"\n-\tok=false\n-elif ! grep testdata/shadow/root1/src/foo testdata/err >/dev/null; then\n-\techo \"go get -u error does not mention shadow/root1/src/foo:\"\n-\tcat testdata/err\n-\tok=false\n-fi\n-unset GOPATH\n-\n-TEST go install fails with no buildable files\n-export GOPATH=$(pwd)/testdata\n-export CGO_ENABLED=0\n-if ./testgo install cgotest 2>testdata/err; then\n-\techo \"go install cgotest succeeded unexpectedly\"\n-elif ! grep 'no buildable Go source files' testdata/err >/dev/null; then\n-\techo \"go install cgotest did not report 'no buildable Go source files'\"\n-\tcat testdata/err\n-\tok=false\n-fi\n-unset CGO_ENABLED\n-unset GOPATH\n-\n-# Test that without $GOBIN set, binaries get installed\n-# into the GOPATH bin directory.\n-TEST install into GOPATH\n-rm -rf testdata/bin\n-if ! GOPATH=$(pwd)/testdata ./testgo install go-cmd-test; then\n-\techo \"go install go-cmd-test failed\"\n-\tok=false\n-elif ! test -x testdata/bin/go-cmd-test; then\n-\techo \"go install go-cmd-test did not write to testdata/bin/go-cmd-test\"\n-\tok=false\n-fi\n-\n-TEST package main_test imports archive not binary\n-export GOBIN=$(pwd)/testdata/bin\n-mkdir -p $GOBIN\n-export GOPATH=$(pwd)/testdata\n-touch ./testdata/src/main_test/m.go\n-if ! ./testgo test main_test; then\n-\techo \"go test main_test failed without install\"\n-\tok=false\n-elif ! ./testgo install main_test; then\n-\techo \"go test main_test failed\"\n-\tok=false\n-elif [ \"$(./testgo list -f '{{.Stale}}' main_test)\" != false ]; then\n-\techo \"after go install, main listed as stale\"\n-\tok=false\n-elif ! ./testgo test main_test; then\n-\techo \"go test main_test failed after install\"\n-\tok=false\n-fi\n-rm -rf $GOBIN\n-unset GOBIN\n-\n-# And with $GOBIN set, binaries get installed to $GOBIN.\n-TEST install into GOBIN\n-if ! GOBIN=$(pwd)/testdata/bin1 GOPATH=$(pwd)/testdata ./testgo install go-cmd-test; then\n-\techo \"go install go-cmd-test failed\"\n-\tok=false\n-elif ! test -x testdata/bin1/go-cmd-test; then\n-\techo \"go install go-cmd-test did not write to testdata/bin1/go-cmd-test\"\n-\tok=false\n-fi\n-\n-# Without $GOBIN set, installing a program outside $GOPATH should fail\n-# (there is nowhere to install it).\n-TEST install without destination fails\n-if ./testgo install testdata/src/go-cmd-test/helloworld.go 2>testdata/err; then\n-\techo \"go install testdata/src/go-cmd-test/helloworld.go should have failed, did not\"\n-\tok=false\n-elif ! grep 'no install location for .go files listed on command line' testdata/err; then\n-\techo \"wrong error:\"\n-\tcat testdata/err\n-\tok=false\n-fi\n-rm -f testdata/err\n-\n-# With $GOBIN set, should install there.\n-TEST install to GOBIN '(command-line package)'\n-if ! GOBIN=$(pwd)/testdata/bin1 ./testgo install testdata/src/go-cmd-test/helloworld.go; then\n-\techo \"go install testdata/src/go-cmd-test/helloworld.go failed\"\n-\tok=false\n-elif ! test -x testdata/bin1/helloworld; then\n-\techo \"go install testdata/src/go-cmd-test/helloworld.go did not write testdata/bin1/helloworld\"\n-\tok=false\n-fi\n-\n-TEST godoc installs into GOBIN\n-d=$(mktemp -d -t testgoXXX)\n-export GOPATH=$d\n-mkdir $d/gobin\n-GOBIN=$d/gobin ./testgo get code.google.com/p/go.tools/cmd/godoc\n-if [ ! -x $d/gobin/godoc ]; then\n-\techo did not install godoc to '$GOBIN'\n-\tGOBIN=$d/gobin ./testgo list -f 'Target: {{.Target}}' code.google.com/p/go.tools/cmd/godoc\n-\tok=false\n-fi\n-\n-TEST godoc installs into GOROOT\n-GOROOT=$(./testgo env GOROOT)\n-rm -f $GOROOT/bin/godoc\n-./testgo install code.google.com/p/go.tools/cmd/godoc\n-if [ ! -x $GOROOT/bin/godoc ]; then\n-\techo did not install godoc to '$GOROOT/bin'\n-\t./testgo list -f 'Target: {{.Target}}' code.google.com/p/go.tools/cmd/godoc\n-\tok=false\n-fi\n-\n-TEST cmd/fix installs into tool\n-GOOS=$(./testgo env GOOS)\n-GOARCH=$(./testgo env GOARCH)\n-rm -f $GOROOT/pkg/tool/${GOOS}_${GOARCH}/fix\n-./testgo install cmd/fix\n-if [ ! -x $GOROOT/pkg/tool/${GOOS}_${GOARCH}/fix ]; then\n-\techo 'did not install cmd/fix to $GOROOT/pkg/tool'\n-\tGOBIN=$d/gobin ./testgo list -f 'Target: {{.Target}}' cmd/fix\n-\tok=false\n-fi\n-rm -f $GOROOT/pkg/tool/${GOOS}_${GOARCH}/fix\n-GOBIN=$d/gobin ./testgo install cmd/fix\n-if [ ! -x $GOROOT/pkg/tool/${GOOS}_${GOARCH}/fix ]; then\n-\techo 'did not install cmd/fix to $GOROOT/pkg/tool with $GOBIN set'\n-\tGOBIN=$d/gobin ./testgo list -f 'Target: {{.Target}}' cmd/fix\n-\tok=false\n-fi\n-\n-TEST gopath program installs into GOBIN\n-mkdir $d/src/progname\n-echo 'package main; func main() {}' >$d/src/progname/p.go\n-GOBIN=$d/gobin ./testgo install progname\n-if [ ! -x $d/gobin/progname ]; then\n-\techo 'did not install progname to $GOBIN/progname'\n-\t./testgo list -f 'Target: {{.Target}}' cmd/api\n-\tok=false\n-fi\n-rm -f $d/gobin/progname $d/bin/progname\n-\n-TEST gopath program installs into GOPATH/bin\n-./testgo install progname\n-if [ ! -x $d/bin/progname ]; then\n-\techo 'did not install progname to $GOPATH/bin/progname'\n-\t./testgo list -f 'Target: {{.Target}}' progname\n-\tok=false\n-fi\n-\n-unset GOPATH\n-rm -rf $d\n-\n-# Reject relative paths in GOPATH.\n-TEST reject relative paths in GOPATH '(command-line package)'\n-if GOPATH=. ./testgo build testdata/src/go-cmd-test/helloworld.go; then\n-    echo 'GOPATH=\".\" go build should have failed, did not'\n-    ok=false\n-fi\n-\n-TEST reject relative paths in GOPATH \n-if GOPATH=:$(pwd)/testdata:. ./testgo build go-cmd-test; then\n-    echo 'GOPATH=\":$(pwd)/testdata:.\" go build should have failed, did not'\n-    ok=false\n-fi\n-\n-# issue 4104\n-TEST go test with package listed multiple times\n-if [ $(./testgo test fmt fmt fmt fmt fmt | wc -l) -ne 1 ] ; then\n-    echo 'go test fmt fmt fmt fmt fmt tested the same package multiple times'\n-    ok=false\n-fi\n-\n-# ensure that output of 'go list' is consistent between runs\n-TEST go list is consistent\n-./testgo list std > test_std.list\n-if ! ./testgo list std | cmp -s test_std.list - ; then\n-\techo \"go list std ordering is inconsistent\"\n-\tok=false\n-fi\n-rm -f test_std.list\n-\n-# issue 4096. Validate the output of unsuccessful go install foo/quxx \n-TEST unsuccessful go install should mention missing package\n-if [ $(./testgo install 'foo/quxx' 2>&1 | grep -c 'cannot find package \"foo/quxx\" in any of') -ne 1 ] ; then\n-\techo 'go install foo/quxx expected error: .*cannot find package \"foo/quxx\" in any of'\n-\tok=false\n-fi \n-# test GOROOT search failure is reported\n-TEST GOROOT search failure reporting\n-if [ $(./testgo install 'foo/quxx' 2>&1 | egrep -c 'foo/quxx \\(from \\$GOROOT\\)$') -ne 1 ] ; then\n-        echo 'go install foo/quxx expected error: .*foo/quxx (from $GOROOT)'\n-        ok=false\n-fi\n-# test multiple GOPATH entries are reported separately\n-TEST multiple GOPATH entries reported separately\n-if [ $(GOPATH=$(pwd)/testdata/a:$(pwd)/testdata/b ./testgo install 'foo/quxx' 2>&1 | egrep -c 'testdata/./src/foo/quxx') -ne 2 ] ; then\n-        echo 'go install foo/quxx expected error: .*testdata/a/src/foo/quxx (from $GOPATH)\\n.*testdata/b/src/foo/quxx'\n-        ok=false\n-fi\n-# test (from $GOPATH) annotation is reported for the first GOPATH entry\n-TEST mention GOPATH in first GOPATH entry\n-if [ $(GOPATH=$(pwd)/testdata/a:$(pwd)/testdata/b ./testgo install 'foo/quxx' 2>&1 | egrep -c 'testdata/a/src/foo/quxx \\(from \\$GOPATH\\)$') -ne 1 ] ; then\n-        echo 'go install foo/quxx expected error: .*testdata/a/src/foo/quxx (from $GOPATH)'\n-        ok=false\n-fi\n-# but not on the second\n-TEST but not the second entry\n-if [ $(GOPATH=$(pwd)/testdata/a:$(pwd)/testdata/b ./testgo install 'foo/quxx' 2>&1 | egrep -c 'testdata/b/src/foo/quxx$') -ne 1 ] ; then\n-        echo 'go install foo/quxx expected error: .*testdata/b/src/foo/quxx'\n-        ok=false\n-fi\n-# test missing GOPATH is reported\n-TEST missing GOPATH is reported\n-if [ $(GOPATH= ./testgo install 'foo/quxx' 2>&1 | egrep -c '\\(\\$GOPATH not set\\)$') -ne 1 ] ; then\n-        echo 'go install foo/quxx expected error: ($GOPATH not set)'\n-        ok=false\n-fi\n-\n-# issue 4186. go get cannot be used to download packages to $GOROOT\n-# Test that without GOPATH set, go get should fail\n-TEST without GOPATH, go get fails\n-d=$(mktemp -d -t testgoXXX)\n-mkdir -p $d/src/pkg\n-if GOPATH= GOROOT=$d ./testgo get -d code.google.com/p/go.codereview/cmd/hgpatch ; then \n-\techo 'go get code.google.com/p/go.codereview/cmd/hgpatch should not succeed with $GOPATH unset'\n-\tok=false\n-fi\t\n-rm -rf $d\n-\n-# Test that with GOPATH=$GOROOT, go get should fail\n-TEST with GOPATH=GOROOT, go get fails\n-d=$(mktemp -d -t testgoXXX)\n-mkdir -p $d/src/pkg\n-if GOPATH=$d GOROOT=$d ./testgo get -d code.google.com/p/go.codereview/cmd/hgpatch ; then\n-        echo 'go get code.google.com/p/go.codereview/cmd/hgpatch should not succeed with GOPATH=$GOROOT'\n-        ok=false\n-fi\n-rm -rf $d\n-\n-TEST ldflags arguments with spaces '(issue 3941)'\n-d=$(mktemp -d -t testgoXXX)\n-cat >$d/main.go<<EOF\n-package main\n-var extern string\n-func main() {\n-\tprintln(extern)\n-}\n-EOF\n-./testgo run -ldflags '-X main.extern \"hello world\"' $d/main.go 2>hello.out\n-if ! grep -q '^hello world' hello.out; then\n-\techo \"ldflags -X main.extern 'hello world' failed. Output:\"\n-\tcat hello.out\n-\tok=false\n-fi\n-rm -rf $d hello.out\n-\n-TEST go test -cpuprofile leaves binary behind\n-./testgo test -cpuprofile strings.prof strings || ok=false\n-if [ ! -x strings.test ]; then\n-\techo \"go test -cpuprofile did not create strings.test\"\n-\tok=false\n-fi\n-rm -f strings.prof strings.test\n-\n-TEST symlinks do not confuse go list '(issue 4568)'\n-old=$(pwd)\n-tmp=$(cd /tmp && pwd -P)\n-d=$(TMPDIR=$tmp mktemp -d -t testgoXXX)\n-mkdir -p $d/src\n-(\n-\tln -s $d $d/src/dir1\n-\tcd $d/src\n-\techo package p >dir1/p.go\n-\texport GOPATH=$d\n-\tif [ \"$($old/testgo list -f '{{.Root}}' dir1)\" != \"$d\" ]; then\n-\t\techo Confused by symlinks.\n-\t\techo \"Package in current directory $(pwd) should have Root $d\"\n-\t\tenv|grep WD\n-\t\t$old/testgo list -json . dir1\n-\t\ttouch $d/failed\n-\tfi\t\t\n-)\n-if [ -f $d/failed ]; then\n-\tok=false\n-fi\n-rm -rf $d\n-\n-TEST 'install with tags (issue 4515)'\n-d=$(TMPDIR=/var/tmp mktemp -d -t testgoXXX)\n-mkdir -p $d/src/example/a $d/src/example/b $d/bin\n-cat >$d/src/example/a/main.go <<EOF\n-package main\n-func main() {}\n-EOF\n-cat >$d/src/example/b/main.go <<EOF\n-// +build mytag\n-\n-package main\n-func main() {}\n-EOF\n-GOPATH=$d ./testgo install -tags mytag example/a example/b || ok=false\n-if [ ! -x $d/bin/a -o ! -x $d/bin/b ]; then\n-\techo go install example/a example/b did not install binaries\n-\tok=false\n-fi\n-rm -f $d/bin/*\n-GOPATH=$d ./testgo install -tags mytag example/... || ok=false\n-if [ ! -x $d/bin/a -o ! -x $d/bin/b ]; then\n-\techo go install example/... did not install binaries\n-\tok=false\n-fi\n-rm -f $d/bin/*go\n-export GOPATH=$d\n-if [ \"$(./testgo list -tags mytag example/b...)\" != \"example/b\" ]; then\n-\techo go list example/b did not find example/b\n-\tok=false\n-fi\n-unset GOPATH\n-rm -rf $d\n-\n-TEST case collisions '(issue 4773)'\n-d=$(TMPDIR=/var/tmp mktemp -d -t testgoXXX)\n-export GOPATH=$d\n-mkdir -p $d/src/example/{a/pkg,a/Pkg,b}\n-cat >$d/src/example/a/a.go <<EOF\n-package p\n-import (\n-\t_ \"example/a/pkg\"\n-\t_ \"example/a/Pkg\"\n-)\n-EOF\n-cat >$d/src/example/a/pkg/pkg.go <<EOF\n-package pkg\n-EOF\n-cat >$d/src/example/a/Pkg/pkg.go <<EOF\n-package pkg\n-EOF\n-if ./testgo list example/a 2>$d/out; then\n-\techo go list example/a should have failed, did not.\n-\tok=false\n-elif ! grep \"case-insensitive import collision\" $d/out >/dev/null; then\n-\techo go list example/a did not report import collision.\n-\tok=false\n-fi\n-cat >$d/src/example/b/file.go <<EOF\n-package b\n-EOF\n-cat >$d/src/example/b/FILE.go <<EOF\n-package b\n-EOF\n-if [ $(ls $d/src/example/b | wc -l) = 2 ]; then\n-\t# case-sensitive file system, let directory read find both files\n-\targs=\"example/b\"\n-else\n-\t# case-insensitive file system, list files explicitly on command line.\n-\targs=\"$d/src/example/b/file.go $d/src/example/b/FILE.go\"\n-fi\n-if ./testgo list $args 2>$d/out; then\n-\techo go list example/b should have failed, did not.\n-\tok=false\n-elif ! grep \"case-insensitive file name collision\" $d/out >/dev/null; then\n-\techo go list example/b did not report file name collision.\n-\tok=false\n-fi\n-\n-TEST go get cover\n-./testgo get code.google.com/p/go.tools/cmd/cover || ok=false\n-\n-unset GOPATH\n-rm -rf $d\n-\n-TEST shadowing logic\n-export GOPATH=$(pwd)/testdata/shadow/root1:$(pwd)/testdata/shadow/root2\n-\n-# The math in root1 is not \"math\" because the standard math is.\n-cdir=$(./testgo list -f '({{.ImportPath}}) ({{.ConflictDir}})' ./testdata/shadow/root1/src/math)\n-if [ \"$cdir\" != \"(_$(pwd)/testdata/shadow/root1/src/math) ($GOROOT/src/pkg/math)\" ]; then\n-\techo shadowed math is not shadowed: \"$cdir\"\n-\tok=false\n-fi\n-\n-# The foo in root1 is \"foo\".\n-cdir=$(./testgo list -f '({{.ImportPath}}) ({{.ConflictDir}})' ./testdata/shadow/root1/src/foo)\n-if [ \"$cdir\" != \"(foo) ()\" ]; then\n-\techo unshadowed foo is shadowed: \"$cdir\"\n-\tok=false\n-fi\n-\n-# The foo in root2 is not \"foo\" because the foo in root1 got there first.\n-cdir=$(./testgo list -f '({{.ImportPath}}) ({{.ConflictDir}})' ./testdata/shadow/root2/src/foo)\n-if [ \"$cdir\" != \"(_$(pwd)/testdata/shadow/root2/src/foo) ($(pwd)/testdata/shadow/root1/src/foo)\" ]; then\n-\techo shadowed foo is not shadowed: \"$cdir\"\n-\tok=false\n-fi\n-\n-# The error for go install should mention the conflicting directory.\n-err=$(! ./testgo install ./testdata/shadow/root2/src/foo 2>&1)\n-if [ \"$err\" != \"go install: no install location for $(pwd)/testdata/shadow/root2/src/foo: hidden by $(pwd)/testdata/shadow/root1/src/foo\" ]; then\n-\techo wrong shadowed install error: \"$err\"\n-\tok=false\n-fi\n-\n-# Only succeeds if source order is preserved.\n-TEST source file name order preserved\n-./testgo test testdata/example[12]_test.go || ok=false\n-\n-# Check that coverage analysis works at all.\n-# Don't worry about the exact numbers but require not 0.0%.\n-checkcoverage() {\n-\tif grep '[^0-9]0\\.0%' testdata/cover.txt >/dev/null; then\n-\t\techo 'some coverage results are 0.0%'\n-\t\tok=false\n-\tfi\n-\tcat testdata/cover.txt\n-\trm -f testdata/cover.txt\n-}\n-\t\n-TEST coverage runs\n-./testgo test -short -coverpkg=strings strings regexp >testdata/cover.txt 2>&1 || ok=false\n-./testgo test -short -cover strings math regexp >>testdata/cover.txt 2>&1 || ok=false\n-checkcoverage\n-\n-# Check that coverage analysis uses set mode.\n-TEST coverage uses set mode\n-if ./testgo test -short -cover encoding/binary -coverprofile=testdata/cover.out >testdata/cover.txt 2>&1; then\n-\tif ! grep -q 'mode: set' testdata/cover.out; then\n-\t\tok=false\n-\tfi\n-\tcheckcoverage\n-else\n-\tok=false\n-fi\n-rm -f testdata/cover.out testdata/cover.txt\n-\n-TEST coverage uses atomic mode for -race.\n-if ./testgo test -short -race -cover encoding/binary -coverprofile=testdata/cover.out >testdata/cover.txt 2>&1; then\n-\tif ! grep -q 'mode: atomic' testdata/cover.out; then\n-\t\tok=false\n-\tfi\n-\tcheckcoverage\n-else\n-\tok=false\n-fi\n-rm -f testdata/cover.out\n-\n-TEST coverage uses actual setting to override even for -race.\n-if ./testgo test -short -race -cover encoding/binary -covermode=count -coverprofile=testdata/cover.out >testdata/cover.txt 2>&1; then\n-\tif ! grep -q 'mode: count' testdata/cover.out; then\n-\t\tok=false\n-\tfi\n-\tcheckcoverage\n-else\n-\tok=false\n-fi\n-rm -f testdata/cover.out\n-\n-TEST coverage with cgo\n-d=$(TMPDIR=/var/tmp mktemp -d -t testgoXXX)\n-./testgo test -short -cover ./testdata/cgocover >testdata/cover.txt 2>&1 || ok=false\n-checkcoverage\n-\n-TEST cgo depends on syscall\n-rm -rf $GOROOT/pkg/*_race\n-d=$(TMPDIR=/var/tmp mktemp -d -t testgoXXX)\n-export GOPATH=$d\n-mkdir -p $d/src/foo\n-echo '\n-package foo\n-//#include <stdio.h>\n-import \"C\"\n-' >$d/src/foo/foo.go\n-./testgo build -race foo || ok=false\n-rm -rf $d\n-unset GOPATH\n-\n-TEST cgo shows full path names\n-d=$(TMPDIR=/var/tmp mktemp -d -t testgoXXX)\n-export GOPATH=$d\n-mkdir -p $d/src/x/y/dirname\n-echo '\n-package foo\n-import \"C\"\n-func f() {\n-' >$d/src/x/y/dirname/foo.go\n-if ./testgo build x/y/dirname >$d/err 2>&1; then\n-\techo build succeeded unexpectedly.\n-\tok=false\n-elif ! grep x/y/dirname $d/err >/dev/null; then\n-\techo error did not use full path.\n-\tcat $d/err\n-\tok=false\n-fi\n-rm -rf $d\n-unset GOPATH\n-\n-TEST 'cgo handles -Wl,$ORIGIN'\n-d=$(TMPDIR=/var/tmp mktemp -d -t testgoXXX)\n-export GOPATH=$d\n-mkdir -p $d/src/origin\n-echo '\n-package origin\n-// #cgo !darwin LDFLAGS: -Wl,-rpath -Wl,$ORIGIN\n-// void f(void) {}\n-import \"C\"\n-\n-func f() { C.f() }\n-' >$d/src/origin/origin.go\n-if ! ./testgo build origin; then\n-\techo build failed\n-\tok=false\n-fi\n-rm -rf $d\n-unset GOPATH\n-\n-TEST 'Issue 6480: \"go test -c -test.bench=XXX fmt\" should not hang'\n-if ! ./testgo test -c -test.bench=XXX fmt; then\n-\techo build test failed\n-\tok=false\n-fi\n-rm -f fmt.test\n-\n-TEST 'Issue 7573: cmd/cgo: undefined reference when linking a C-library using gccgo'\n-d=$(mktemp -d -t testgoXXX)\n-export GOPATH=$d\n-mkdir -p $d/src/cgoref\n-ldflags=\"-L alibpath -lalib\"\n-echo \"\n-package main\n-// #cgo LDFLAGS: $ldflags\n-// void f(void) {}\n-import \\\"C\\\"\n-\n-func main() { C.f() }\n-\" >$d/src/cgoref/cgoref.go\n-go_cmds=\"$(./testgo build -n -compiler gccgo cgoref 2>&1 1>/dev/null)\"\n-ldflags_count=\"$(echo \"$go_cmds\" | egrep -c \"^gccgo.*$(echo $ldflags | sed -e 's/-/\\\\-/g')\" || true)\"\n-if [ \"$ldflags_count\" -lt 1 ]; then\n-\techo \"No Go-inline \"#cgo LDFLAGS:\" (\\\"$ldflags\\\") passed to gccgo linking stage.\"\n-\tok=false\n-fi\n-rm -rf $d\n-unset ldflags_count\n-unset go_cmds\n-unset ldflags\n-unset GOPATH\n-\n-TEST list template can use context function\n-if ! ./testgo list -f \"GOARCH: {{context.GOARCH}}\"; then \n-\techo unable to use context in list template\n-\tok=false\n-fi\n-\n-TEST 'Issue 7108: cmd/go: \"go test\" should fail if package does not build'\n-export GOPATH=$(pwd)/testdata\n-if ./testgo test notest >/dev/null 2>&1; then\n-\techo 'go test notest succeeded, but should fail'\n-\tok=false\n-fi\n-unset GOPATH\n-\n-TEST 'Issue 6844: cmd/go: go test -a foo does not rebuild regexp'\n-if ! ./testgo test -x -a -c testdata/dep_test.go 2>deplist; then\n-\techo \"go test -x -a -c testdata/dep_test.go failed\"\n-\tok=false\n-elif ! grep -q regexp deplist; then\n-\techo \"go test -x -a -c testdata/dep_test.go did not rebuild regexp\"\n-\tok=false\n-fi\n-rm -f deplist\n-rm -f deps.test\n-\n-TEST list template can use context function\n-if ! ./testgo list -f \"GOARCH: {{context.GOARCH}}\"; then \n-\techo unable to use context in list template\n-\tok=false\n-fi\n-\n-TEST build -i installs dependencies\n-d=$(TMPDIR=/var/tmp mktemp -d -t testgoXXX)\n-export GOPATH=$d\n-mkdir -p $d/src/x/y/foo $d/src/x/y/bar\n-echo '\n-package foo\n-func F() {}\n-' >$d/src/x/y/foo/foo.go\n-echo '\n-package bar\n-import \"x/y/foo\"\n-func F() { foo.F() }\n-' >$d/src/x/y/bar/bar.go\n-if ! ./testgo build -v -i x/y/bar &> $d/err; then\n-\techo build -i failed\n-\tcat $d/err\n-\tok=false\n-elif ! grep x/y/foo $d/err >/dev/null; then\n-\techo first build -i did not build x/y/foo\n-\tcat $d/err\n-\tok=false\n-fi\n-if ! ./testgo build -v -i x/y/bar &> $d/err; then\n-\techo second build -i failed\n-\tcat $d/err\n-\tok=false\n-elif grep x/y/foo $d/err >/dev/null; then\n-\techo second build -i built x/y/foo\n-\tcat $d/err\n-\tok=false\n-fi\n-rm -rf $d\n-unset GOPATH\n-\n-TEST 'go build in test-only directory fails with a good error'\n-if ./testgo build ./testdata/testonly 2>testdata/err.out; then\n-\techo \"go build ./testdata/testonly succeeded, should have failed\"\n-\tok=false\n-elif ! grep 'no buildable Go' testdata/err.out >/dev/null; then\n-\techo \"go build ./testdata/testonly produced unexpected error:\"\n-\tcat testdata/err.out\n-\tok=false\n-fi\n-rm -f testdata/err.out\n-\n-TEST 'go test detects test-only import cycles'\n-export GOPATH=$(pwd)/testdata\n-if ./testgo test -c testcycle/p3 2>testdata/err.out; then\n-\techo \"go test testcycle/p3 succeeded, should have failed\"\n-\tok=false\n-elif ! grep 'import cycle not allowed in test' testdata/err.out >/dev/null; then\n-\techo \"go test testcycle/p3 produced unexpected error:\"\n-\tcat testdata/err.out\n-\tok=false\n-fi\n-rm -f testdata/err.out\n-unset GOPATH\n-\n-TEST 'go test foo_test.go works'\n-if ! ./testgo test testdata/standalone_test.go; then\n-\techo \"go test testdata/standalone_test.go failed\"\n-\tok=false\n-fi\n-\n-TEST 'go test xtestonly works'\n-export GOPATH=$(pwd)/testdata\n-./testgo clean -i xtestonly\n-if ! ./testgo test xtestonly >/dev/null; then\n-\techo \"go test xtestonly failed\"\n-\tok=false\n-fi\n-unset GOPATH\n-\n-\n-# clean up\n-if $started; then stop; fi\n-rm -rf testdata/bin testdata/bin1\n-rm -f testgo\n-\n-if $allok; then\n-\techo PASS\n-else\n-\techo FAIL\n-\texit 1\n-fi"}, {"sha": "32cabf8a7be1a78659bb5bc8a03381ea9582de63", "filename": "libgo/go/cmd/go/testdata/src/bench/x_test.go", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fbench%2Fx_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fbench%2Fx_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fbench%2Fx_test.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -0,0 +1,6 @@\n+package bench\n+\n+import \"testing\"\n+\n+func Benchmark(b *testing.B) {\n+}"}, {"sha": "148b47f6a5b6bb1320c5efed8c92eb0350f87af6", "filename": "libgo/go/cmd/go/testdata/src/cgoasm/p.go", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcgoasm%2Fp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcgoasm%2Fp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcgoasm%2Fp.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -0,0 +1,8 @@\n+package p\n+\n+/*\n+// hi\n+*/\n+import \"C\"\n+\n+func F() {}"}, {"sha": "aaade03a437067ae22796ced4624ad468737936c", "filename": "libgo/go/cmd/go/testdata/src/cgoasm/p.s", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcgoasm%2Fp.s", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcgoasm%2Fp.s", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcgoasm%2Fp.s?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -0,0 +1,2 @@\n+TEXT asm(SB),$0\n+\tRET"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "libgo/go/cmd/go/testdata/src/exclude/empty/x.txt", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fexclude%2Fempty%2Fx.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fexclude%2Fempty%2Fx.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fexclude%2Fempty%2Fx.txt?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "823aafd0712b6c533df84b17d9b7ac6ae43e66fa", "filename": "libgo/go/cmd/go/testdata/src/exclude/ignore/_x.go", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fexclude%2Fignore%2F_x.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fexclude%2Fignore%2F_x.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fexclude%2Fignore%2F_x.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -0,0 +1 @@\n+package x"}, {"sha": "9affd21e8c1d4fcf1028ec1e7d9d2d7250a8dc66", "filename": "libgo/go/cmd/go/testdata/src/exclude/x.go", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fexclude%2Fx.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fexclude%2Fx.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fexclude%2Fx.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -0,0 +1,3 @@\n+// +build linux,!linux\n+\n+package x"}, {"sha": "41ef6e5d7b18ee2c588759d52dedb1fc518db12a", "filename": "libgo/go/cmd/go/testdata/src/exclude/x_linux.go", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fexclude%2Fx_linux.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fexclude%2Fx_linux.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fexclude%2Fx_linux.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -0,0 +1,3 @@\n+// +build windows\n+\n+package x"}, {"sha": "22f147b63390de175d1b98af310b08b6f0bb7307", "filename": "libgo/go/cmd/go/testdata/src/testlist/bench_test.go", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestlist%2Fbench_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestlist%2Fbench_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestlist%2Fbench_test.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -0,0 +1,14 @@\n+package testlist\n+\n+import (\n+\t\"fmt\"\n+\t\"testing\"\n+)\n+\n+func BenchmarkSimplefunc(b *testing.B) {\n+\tb.StopTimer()\n+\tb.StartTimer()\n+\tfor i := 0; i < b.N; i++ {\n+\t\t_ = fmt.Sprint(\"Test for bench\")\n+\t}\n+}"}, {"sha": "0298dfde81e2a3926cb644187c39a2dcd72147fd", "filename": "libgo/go/cmd/go/testdata/src/testlist/example_test.go", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestlist%2Fexample_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestlist%2Fexample_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestlist%2Fexample_test.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -0,0 +1,21 @@\n+package testlist\n+\n+import (\n+\t\"fmt\"\n+)\n+\n+func ExampleSimple() {\n+\tfmt.Println(\"Test with Output.\")\n+\n+\t// Output: Test with Output.\n+}\n+\n+func ExampleWithEmptyOutput() {\n+\tfmt.Println(\"\")\n+\n+\t// Output:\n+}\n+\n+func ExampleNoOutput() {\n+\t_ = fmt.Sprint(\"Test with no output\")\n+}"}, {"sha": "bdc09f27c5b10338d3da75a25dfb16bd03cf918f", "filename": "libgo/go/cmd/go/testdata/src/testlist/test_test.go", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestlist%2Ftest_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestlist%2Ftest_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestlist%2Ftest_test.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -0,0 +1,10 @@\n+package testlist\n+\n+import (\n+\t\"fmt\"\n+\t\"testing\"\n+)\n+\n+func TestSimple(t *testing.T) {\n+\t_ = fmt.Sprint(\"Test simple\")\n+}"}, {"sha": "7573e79e167d992a188e862138fdb2777c43aca7", "filename": "libgo/go/cmd/go/testdata/src/testregexp/x_test.go", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestregexp%2Fx_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestregexp%2Fx_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestregexp%2Fx_test.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -0,0 +1,17 @@\n+package x\n+\n+import \"testing\"\n+\n+func TestX(t *testing.T) {\n+\tt.Logf(\"LOG: X running\")\n+\tt.Run(\"Y\", func(t *testing.T) {\n+\t\tt.Logf(\"LOG: Y running\")\n+\t})\n+}\n+\n+func BenchmarkX(b *testing.B) {\n+\tb.Logf(\"LOG: X running N=%d\", b.N)\n+\tb.Run(\"Y\", func(b *testing.B) {\n+\t\tb.Logf(\"LOG: Y running N=%d\", b.N)\n+\t})\n+}"}, {"sha": "4fd1979154403d6ef446a1fb648ece78aea580e5", "filename": "libgo/go/cmd/go/testdata/src/testregexp/z_test.go", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestregexp%2Fz_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestregexp%2Fz_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestregexp%2Fz_test.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -0,0 +1,19 @@\n+package x\n+\n+import \"testing\"\n+\n+func TestZ(t *testing.T) {\n+\tt.Logf(\"LOG: Z running\")\n+}\n+\n+func TestXX(t *testing.T) {\n+\tt.Logf(\"LOG: XX running\")\n+}\n+\n+func BenchmarkZ(b *testing.B) {\n+\tb.Logf(\"LOG: Z running N=%d\", b.N)\n+}\n+\n+func BenchmarkXX(b *testing.B) {\n+\tb.Logf(\"LOG: XX running N=%d\", b.N)\n+}"}, {"sha": "fa53bfcdf095b3ddfa2000016eb440478da79807", "filename": "libgo/go/cmd/go/testflag.go", "status": "removed", "additions": 0, "deletions": 294, "changes": 294, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a41a6142df74219f596e612d3a7775f68ca6e96f/libgo%2Fgo%2Fcmd%2Fgo%2Ftestflag.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a41a6142df74219f596e612d3a7775f68ca6e96f/libgo%2Fgo%2Fcmd%2Fgo%2Ftestflag.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestflag.go?ref=a41a6142df74219f596e612d3a7775f68ca6e96f", "patch": "@@ -1,294 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package main\n-\n-import (\n-\t\"flag\"\n-\t\"fmt\"\n-\t\"os\"\n-\t\"strconv\"\n-\t\"strings\"\n-)\n-\n-// The flag handling part of go test is large and distracting.\n-// We can't use the flag package because some of the flags from\n-// our command line are for us, and some are for 6.out, and\n-// some are for both.\n-\n-// testFlagSpec defines a flag we know about.\n-type testFlagSpec struct {\n-\tname       string\n-\tboolVar    *bool\n-\tflagValue  flag.Value\n-\tpassToTest bool // pass to Test\n-\tmultiOK    bool // OK to have multiple instances\n-\tpresent    bool // flag has been seen\n-}\n-\n-// testFlagDefn is the set of flags we process.\n-var testFlagDefn = []*testFlagSpec{\n-\t// local.\n-\t{name: \"c\", boolVar: &testC},\n-\t{name: \"i\", boolVar: &buildI},\n-\t{name: \"o\"},\n-\t{name: \"cover\", boolVar: &testCover},\n-\t{name: \"covermode\"},\n-\t{name: \"coverpkg\"},\n-\t{name: \"exec\"},\n-\n-\t// passed to 6.out, adding a \"test.\" prefix to the name if necessary: -v becomes -test.v.\n-\t{name: \"bench\", passToTest: true},\n-\t{name: \"benchmem\", boolVar: new(bool), passToTest: true},\n-\t{name: \"benchtime\", passToTest: true},\n-\t{name: \"count\", passToTest: true},\n-\t{name: \"coverprofile\", passToTest: true},\n-\t{name: \"cpu\", passToTest: true},\n-\t{name: \"cpuprofile\", passToTest: true},\n-\t{name: \"memprofile\", passToTest: true},\n-\t{name: \"memprofilerate\", passToTest: true},\n-\t{name: \"blockprofile\", passToTest: true},\n-\t{name: \"blockprofilerate\", passToTest: true},\n-\t{name: \"mutexprofile\", passToTest: true},\n-\t{name: \"mutexprofilefraction\", passToTest: true},\n-\t{name: \"outputdir\", passToTest: true},\n-\t{name: \"parallel\", passToTest: true},\n-\t{name: \"run\", passToTest: true},\n-\t{name: \"short\", boolVar: new(bool), passToTest: true},\n-\t{name: \"timeout\", passToTest: true},\n-\t{name: \"trace\", passToTest: true},\n-\t{name: \"v\", boolVar: &testV, passToTest: true},\n-}\n-\n-// add build flags to testFlagDefn\n-func init() {\n-\tvar cmd Command\n-\taddBuildFlags(&cmd)\n-\tcmd.Flag.VisitAll(func(f *flag.Flag) {\n-\t\tif f.Name == \"v\" {\n-\t\t\t// test overrides the build -v flag\n-\t\t\treturn\n-\t\t}\n-\t\ttestFlagDefn = append(testFlagDefn, &testFlagSpec{\n-\t\t\tname:      f.Name,\n-\t\t\tflagValue: f.Value,\n-\t\t})\n-\t})\n-}\n-\n-// testFlags processes the command line, grabbing -x and -c, rewriting known flags\n-// to have \"test\" before them, and reading the command line for the 6.out.\n-// Unfortunately for us, we need to do our own flag processing because go test\n-// grabs some flags but otherwise its command line is just a holding place for\n-// pkg.test's arguments.\n-// We allow known flags both before and after the package name list,\n-// to allow both\n-//\tgo test fmt -custom-flag-for-fmt-test\n-//\tgo test -x math\n-func testFlags(args []string) (packageNames, passToTest []string) {\n-\tinPkg := false\n-\toutputDir := \"\"\n-\tvar explicitArgs []string\n-\tfor i := 0; i < len(args); i++ {\n-\t\tif !strings.HasPrefix(args[i], \"-\") {\n-\t\t\tif !inPkg && packageNames == nil {\n-\t\t\t\t// First package name we've seen.\n-\t\t\t\tinPkg = true\n-\t\t\t}\n-\t\t\tif inPkg {\n-\t\t\t\tpackageNames = append(packageNames, args[i])\n-\t\t\t\tcontinue\n-\t\t\t}\n-\t\t}\n-\n-\t\tif inPkg {\n-\t\t\t// Found an argument beginning with \"-\"; end of package list.\n-\t\t\tinPkg = false\n-\t\t}\n-\n-\t\tf, value, extraWord := testFlag(args, i)\n-\t\tif f == nil {\n-\t\t\t// This is a flag we do not know; we must assume\n-\t\t\t// that any args we see after this might be flag\n-\t\t\t// arguments, not package names.\n-\t\t\tinPkg = false\n-\t\t\tif packageNames == nil {\n-\t\t\t\t// make non-nil: we have seen the empty package list\n-\t\t\t\tpackageNames = []string{}\n-\t\t\t}\n-\t\t\tif args[i] == \"-args\" || args[i] == \"--args\" {\n-\t\t\t\t// -args or --args signals that everything that follows\n-\t\t\t\t// should be passed to the test.\n-\t\t\t\texplicitArgs = args[i+1:]\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t\tpassToTest = append(passToTest, args[i])\n-\t\t\tcontinue\n-\t\t}\n-\t\tif f.flagValue != nil {\n-\t\t\tif err := f.flagValue.Set(value); err != nil {\n-\t\t\t\tfatalf(\"invalid flag argument for -%s: %v\", f.name, err)\n-\t\t\t}\n-\t\t} else {\n-\t\t\t// Test-only flags.\n-\t\t\t// Arguably should be handled by f.flagValue, but aren't.\n-\t\t\tvar err error\n-\t\t\tswitch f.name {\n-\t\t\t// bool flags.\n-\t\t\tcase \"c\", \"i\", \"v\", \"cover\":\n-\t\t\t\tsetBoolFlag(f.boolVar, value)\n-\t\t\tcase \"o\":\n-\t\t\t\ttestO = value\n-\t\t\t\ttestNeedBinary = true\n-\t\t\tcase \"exec\":\n-\t\t\t\texecCmd, err = splitQuotedFields(value)\n-\t\t\t\tif err != nil {\n-\t\t\t\t\tfatalf(\"invalid flag argument for -%s: %v\", f.name, err)\n-\t\t\t\t}\n-\t\t\tcase \"bench\":\n-\t\t\t\t// record that we saw the flag; don't care about the value\n-\t\t\t\ttestBench = true\n-\t\t\tcase \"timeout\":\n-\t\t\t\ttestTimeout = value\n-\t\t\tcase \"blockprofile\", \"cpuprofile\", \"memprofile\", \"mutexprofile\":\n-\t\t\t\ttestProfile = true\n-\t\t\t\ttestNeedBinary = true\n-\t\t\tcase \"trace\":\n-\t\t\t\ttestProfile = true\n-\t\t\tcase \"coverpkg\":\n-\t\t\t\ttestCover = true\n-\t\t\t\tif value == \"\" {\n-\t\t\t\t\ttestCoverPaths = nil\n-\t\t\t\t} else {\n-\t\t\t\t\ttestCoverPaths = strings.Split(value, \",\")\n-\t\t\t\t}\n-\t\t\tcase \"coverprofile\":\n-\t\t\t\ttestCover = true\n-\t\t\t\ttestProfile = true\n-\t\t\tcase \"covermode\":\n-\t\t\t\tswitch value {\n-\t\t\t\tcase \"set\", \"count\", \"atomic\":\n-\t\t\t\t\ttestCoverMode = value\n-\t\t\t\tdefault:\n-\t\t\t\t\tfatalf(\"invalid flag argument for -covermode: %q\", value)\n-\t\t\t\t}\n-\t\t\t\ttestCover = true\n-\t\t\tcase \"outputdir\":\n-\t\t\t\toutputDir = value\n-\t\t\t}\n-\t\t}\n-\t\tif extraWord {\n-\t\t\ti++\n-\t\t}\n-\t\tif f.passToTest {\n-\t\t\tpassToTest = append(passToTest, \"-test.\"+f.name+\"=\"+value)\n-\t\t}\n-\t}\n-\n-\tif testCoverMode == \"\" {\n-\t\ttestCoverMode = \"set\"\n-\t\tif buildRace {\n-\t\t\t// Default coverage mode is atomic when -race is set.\n-\t\t\ttestCoverMode = \"atomic\"\n-\t\t}\n-\t}\n-\n-\t// Tell the test what directory we're running in, so it can write the profiles there.\n-\tif testProfile && outputDir == \"\" {\n-\t\tdir, err := os.Getwd()\n-\t\tif err != nil {\n-\t\t\tfatalf(\"error from os.Getwd: %s\", err)\n-\t\t}\n-\t\tpassToTest = append(passToTest, \"-test.outputdir\", dir)\n-\t}\n-\n-\tpassToTest = append(passToTest, explicitArgs...)\n-\treturn\n-}\n-\n-// testFlag sees if argument i is a known flag and returns its definition, value, and whether it consumed an extra word.\n-func testFlag(args []string, i int) (f *testFlagSpec, value string, extra bool) {\n-\targ := args[i]\n-\tif strings.HasPrefix(arg, \"--\") { // reduce two minuses to one\n-\t\targ = arg[1:]\n-\t}\n-\tswitch arg {\n-\tcase \"-?\", \"-h\", \"-help\":\n-\t\tusage()\n-\t}\n-\tif arg == \"\" || arg[0] != '-' {\n-\t\treturn\n-\t}\n-\tname := arg[1:]\n-\t// If there's already \"test.\", drop it for now.\n-\tname = strings.TrimPrefix(name, \"test.\")\n-\tequals := strings.Index(name, \"=\")\n-\tif equals >= 0 {\n-\t\tvalue = name[equals+1:]\n-\t\tname = name[:equals]\n-\t}\n-\tfor _, f = range testFlagDefn {\n-\t\tif name == f.name {\n-\t\t\t// Booleans are special because they have modes -x, -x=true, -x=false.\n-\t\t\tif f.boolVar != nil || isBoolFlag(f.flagValue) {\n-\t\t\t\tif equals < 0 { // otherwise, it's been set and will be verified in setBoolFlag\n-\t\t\t\t\tvalue = \"true\"\n-\t\t\t\t} else {\n-\t\t\t\t\t// verify it parses\n-\t\t\t\t\tsetBoolFlag(new(bool), value)\n-\t\t\t\t}\n-\t\t\t} else { // Non-booleans must have a value.\n-\t\t\t\textra = equals < 0\n-\t\t\t\tif extra {\n-\t\t\t\t\tif i+1 >= len(args) {\n-\t\t\t\t\t\ttestSyntaxError(\"missing argument for flag \" + f.name)\n-\t\t\t\t\t}\n-\t\t\t\t\tvalue = args[i+1]\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tif f.present && !f.multiOK {\n-\t\t\t\ttestSyntaxError(f.name + \" flag may be set only once\")\n-\t\t\t}\n-\t\t\tf.present = true\n-\t\t\treturn\n-\t\t}\n-\t}\n-\tf = nil\n-\treturn\n-}\n-\n-// isBoolFlag reports whether v is a bool flag.\n-func isBoolFlag(v flag.Value) bool {\n-\tvv, ok := v.(interface {\n-\t\tIsBoolFlag() bool\n-\t})\n-\tif ok {\n-\t\treturn vv.IsBoolFlag()\n-\t}\n-\treturn false\n-}\n-\n-// setBoolFlag sets the addressed boolean to the value.\n-func setBoolFlag(flag *bool, value string) {\n-\tx, err := strconv.ParseBool(value)\n-\tif err != nil {\n-\t\ttestSyntaxError(\"illegal bool flag value \" + value)\n-\t}\n-\t*flag = x\n-}\n-\n-// setIntFlag sets the addressed integer to the value.\n-func setIntFlag(flag *int, value string) {\n-\tx, err := strconv.Atoi(value)\n-\tif err != nil {\n-\t\ttestSyntaxError(\"illegal int flag value \" + value)\n-\t}\n-\t*flag = x\n-}\n-\n-func testSyntaxError(msg string) {\n-\tfmt.Fprintf(os.Stderr, \"go test: %s\\n\", msg)\n-\tfmt.Fprintf(os.Stderr, `run \"go help test\" or \"go help testflag\" for more information`+\"\\n\")\n-\tos.Exit(2)\n-}"}, {"sha": "739ce5a5a45db5ccb13b8e429c4811438d81665f", "filename": "libgo/go/cmd/go/vendor_test.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Fvendor_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgo%2Fvendor_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fvendor_test.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -20,18 +20,18 @@ func TestVendorImports(t *testing.T) {\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n \ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n-\ttg.run(\"list\", \"-f\", \"{{.ImportPath}} {{.Imports}}\", \"vend/...\")\n+\ttg.run(\"list\", \"-f\", \"{{.ImportPath}} {{.Imports}}\", \"vend/...\", \"vend/vendor/...\", \"vend/x/vendor/...\")\n \twant := `\n \t\tvend [vend/vendor/p r]\n \t\tvend/dir1 []\n \t\tvend/hello [fmt vend/vendor/strings]\n \t\tvend/subdir [vend/vendor/p r]\n+\t\tvend/x [vend/x/vendor/p vend/vendor/q vend/x/vendor/r vend/dir1 vend/vendor/vend/dir1/dir2]\n+\t\tvend/x/invalid [vend/x/invalid/vendor/foo]\n \t\tvend/vendor/p []\n \t\tvend/vendor/q []\n \t\tvend/vendor/strings []\n \t\tvend/vendor/vend/dir1/dir2 []\n-\t\tvend/x [vend/x/vendor/p vend/vendor/q vend/x/vendor/r vend/dir1 vend/vendor/vend/dir1/dir2]\n-\t\tvend/x/invalid [vend/x/invalid/vendor/foo]\n \t\tvend/x/vendor/p []\n \t\tvend/x/vendor/p/p [notfound]\n \t\tvend/x/vendor/r []"}, {"sha": "8e296c8572e3bee248fa6a4a1138a0eec4ac569a", "filename": "libgo/go/cmd/go/vet.go", "status": "removed", "additions": 0, "deletions": 52, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a41a6142df74219f596e612d3a7775f68ca6e96f/libgo%2Fgo%2Fcmd%2Fgo%2Fvet.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a41a6142df74219f596e612d3a7775f68ca6e96f/libgo%2Fgo%2Fcmd%2Fgo%2Fvet.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fvet.go?ref=a41a6142df74219f596e612d3a7775f68ca6e96f", "patch": "@@ -1,52 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package main\n-\n-import \"path/filepath\"\n-\n-func init() {\n-\taddBuildFlags(cmdVet)\n-}\n-\n-var cmdVet = &Command{\n-\tRun:       runVet,\n-\tUsageLine: \"vet [-n] [-x] [build flags] [packages]\",\n-\tShort:     \"run go tool vet on packages\",\n-\tLong: `\n-Vet runs the Go vet command on the packages named by the import paths.\n-\n-For more about vet, see 'go doc cmd/vet'.\n-For more about specifying packages, see 'go help packages'.\n-\n-To run the vet tool with specific options, run 'go tool vet'.\n-\n-The -n flag prints commands that would be executed.\n-The -x flag prints commands as they are executed.\n-\n-For more about build flags, see 'go help build'.\n-\n-See also: go fmt, go fix.\n-\t`,\n-}\n-\n-func runVet(cmd *Command, args []string) {\n-\tfor _, p := range packages(args) {\n-\t\t// Vet expects to be given a set of files all from the same package.\n-\t\t// Run once for package p and once for package p_test.\n-\t\tif len(p.GoFiles)+len(p.CgoFiles)+len(p.TestGoFiles) > 0 {\n-\t\t\trunVetFiles(p, stringList(p.GoFiles, p.CgoFiles, p.TestGoFiles, p.SFiles))\n-\t\t}\n-\t\tif len(p.XTestGoFiles) > 0 {\n-\t\t\trunVetFiles(p, stringList(p.XTestGoFiles))\n-\t\t}\n-\t}\n-}\n-\n-func runVetFiles(p *Package, files []string) {\n-\tfor i := range files {\n-\t\tfiles[i] = filepath.Join(p.Dir, files[i])\n-\t}\n-\trun(buildToolExec, tool(\"vet\"), relPaths(files))\n-}"}, {"sha": "e34066559415e76e6cbea9664d1a19939ca176fe", "filename": "libgo/go/cmd/gofmt/doc.go", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgofmt%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgofmt%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Fdoc.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -4,7 +4,8 @@\n \n /*\n Gofmt formats Go programs.\n-It uses tabs (width = 8) for indentation and blanks for alignment.\n+It uses tabs for indentation and blanks for alignment.\n+Alignment assumes that an editor is using a fixed-width font.\n \n Without an explicit path, it processes the standard input.  Given a file,\n it operates on that file; given a directory, it operates on all .go files in\n@@ -100,4 +101,4 @@ package main\n \n // BUG(rsc): The implementation of -r is a bit slow.\n // BUG(gri): If -w fails, the restored original file may not have some of the\n-//           original file attributes.\n+// original file attributes."}, {"sha": "d5b7be327a50216ad6589197952b7d300fcf3c30", "filename": "libgo/go/cmd/gofmt/gofmt.go", "status": "modified", "additions": 57, "deletions": 13, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgofmt%2Fgofmt.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgofmt%2Fgofmt.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Fgofmt.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -139,11 +139,11 @@ func processFile(filename string, in io.Reader, out io.Writer, stdin bool) error\n \t\t\t}\n \t\t}\n \t\tif *doDiff {\n-\t\t\tdata, err := diff(src, res)\n+\t\t\tdata, err := diff(src, res, filename)\n \t\t\tif err != nil {\n \t\t\t\treturn fmt.Errorf(\"computing diff: %s\", err)\n \t\t\t}\n-\t\t\tfmt.Printf(\"diff %s gofmt/%s\\n\", filename, filename)\n+\t\t\tfmt.Printf(\"diff -u %s %s\\n\", filepath.ToSlash(filename+\".orig\"), filepath.ToSlash(filename))\n \t\t\tout.Write(data)\n \t\t}\n \t}\n@@ -225,32 +225,76 @@ func gofmtMain() {\n \t}\n }\n \n-func diff(b1, b2 []byte) (data []byte, err error) {\n-\tf1, err := ioutil.TempFile(\"\", \"gofmt\")\n+func writeTempFile(dir, prefix string, data []byte) (string, error) {\n+\tfile, err := ioutil.TempFile(dir, prefix)\n+\tif err != nil {\n+\t\treturn \"\", err\n+\t}\n+\t_, err = file.Write(data)\n+\tif err1 := file.Close(); err == nil {\n+\t\terr = err1\n+\t}\n+\tif err != nil {\n+\t\tos.Remove(file.Name())\n+\t\treturn \"\", err\n+\t}\n+\treturn file.Name(), nil\n+}\n+\n+func diff(b1, b2 []byte, filename string) (data []byte, err error) {\n+\tf1, err := writeTempFile(\"\", \"gofmt\", b1)\n \tif err != nil {\n \t\treturn\n \t}\n-\tdefer os.Remove(f1.Name())\n-\tdefer f1.Close()\n+\tdefer os.Remove(f1)\n \n-\tf2, err := ioutil.TempFile(\"\", \"gofmt\")\n+\tf2, err := writeTempFile(\"\", \"gofmt\", b2)\n \tif err != nil {\n \t\treturn\n \t}\n-\tdefer os.Remove(f2.Name())\n-\tdefer f2.Close()\n+\tdefer os.Remove(f2)\n \n-\tf1.Write(b1)\n-\tf2.Write(b2)\n+\tcmd := \"diff\"\n+\tif runtime.GOOS == \"plan9\" {\n+\t\tcmd = \"/bin/ape/diff\"\n+\t}\n \n-\tdata, err = exec.Command(\"diff\", \"-u\", f1.Name(), f2.Name()).CombinedOutput()\n+\tdata, err = exec.Command(cmd, \"-u\", f1, f2).CombinedOutput()\n \tif len(data) > 0 {\n \t\t// diff exits with a non-zero status when the files don't match.\n \t\t// Ignore that failure as long as we get output.\n-\t\terr = nil\n+\t\treturn replaceTempFilename(data, filename)\n \t}\n \treturn\n+}\n \n+// replaceTempFilename replaces temporary filenames in diff with actual one.\n+//\n+// --- /tmp/gofmt316145376\t2017-02-03 19:13:00.280468375 -0500\n+// +++ /tmp/gofmt617882815\t2017-02-03 19:13:00.280468375 -0500\n+// ...\n+// ->\n+// --- path/to/file.go.orig\t2017-02-03 19:13:00.280468375 -0500\n+// +++ path/to/file.go\t2017-02-03 19:13:00.280468375 -0500\n+// ...\n+func replaceTempFilename(diff []byte, filename string) ([]byte, error) {\n+\tbs := bytes.SplitN(diff, []byte{'\\n'}, 3)\n+\tif len(bs) < 3 {\n+\t\treturn nil, fmt.Errorf(\"got unexpected diff for %s\", filename)\n+\t}\n+\t// Preserve timestamps.\n+\tvar t0, t1 []byte\n+\tif i := bytes.LastIndexByte(bs[0], '\\t'); i != -1 {\n+\t\tt0 = bs[0][i:]\n+\t}\n+\tif i := bytes.LastIndexByte(bs[1], '\\t'); i != -1 {\n+\t\tt1 = bs[1][i:]\n+\t}\n+\t// Always print filepath with slash separator.\n+\tf := filepath.ToSlash(filename)\n+\tbs[0] = []byte(fmt.Sprintf(\"--- %s%s\", f+\".orig\", t0))\n+\tbs[1] = []byte(fmt.Sprintf(\"+++ %s%s\", f, t1))\n+\treturn bytes.Join(bs, []byte{'\\n'}), nil\n }\n \n const chmodSupported = runtime.GOOS != \"windows\""}, {"sha": "16b653b6460d7892126307eef1943282d8fbf51e", "filename": "libgo/go/cmd/gofmt/gofmt_test.go", "status": "modified", "additions": 69, "deletions": 1, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgofmt%2Fgofmt_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgofmt%2Fgofmt_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Fgofmt_test.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -9,7 +9,9 @@ import (\n \t\"flag\"\n \t\"io/ioutil\"\n \t\"os\"\n+\t\"os/exec\"\n \t\"path/filepath\"\n+\t\"runtime\"\n \t\"strings\"\n \t\"testing\"\n \t\"text/scanner\"\n@@ -110,7 +112,7 @@ func runTest(t *testing.T, in, out string) {\n \t\t}\n \n \t\tt.Errorf(\"(gofmt %s) != %s (see %s.gofmt)\", in, out, in)\n-\t\td, err := diff(expected, got)\n+\t\td, err := diff(expected, got, in)\n \t\tif err == nil {\n \t\t\tt.Errorf(\"%s\", d)\n \t\t}\n@@ -184,3 +186,69 @@ func TestBackupFile(t *testing.T) {\n \t}\n \tt.Logf(\"Created: %s\", name)\n }\n+\n+func TestDiff(t *testing.T) {\n+\tif _, err := exec.LookPath(\"diff\"); err != nil {\n+\t\tt.Skipf(\"skip test on %s: diff command is required\", runtime.GOOS)\n+\t}\n+\tin := []byte(\"first\\nsecond\\n\")\n+\tout := []byte(\"first\\nthird\\n\")\n+\tfilename := \"difftest.txt\"\n+\tb, err := diff(in, out, filename)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\n+\tif runtime.GOOS == \"windows\" {\n+\t\tb = bytes.Replace(b, []byte{'\\r', '\\n'}, []byte{'\\n'}, -1)\n+\t}\n+\n+\tbs := bytes.SplitN(b, []byte{'\\n'}, 3)\n+\tline0, line1 := bs[0], bs[1]\n+\n+\tif prefix := \"--- difftest.txt.orig\"; !bytes.HasPrefix(line0, []byte(prefix)) {\n+\t\tt.Errorf(\"diff: first line should start with `%s`\\ngot: %s\", prefix, line0)\n+\t}\n+\n+\tif prefix := \"+++ difftest.txt\"; !bytes.HasPrefix(line1, []byte(prefix)) {\n+\t\tt.Errorf(\"diff: second line should start with `%s`\\ngot: %s\", prefix, line1)\n+\t}\n+\n+\twant := `@@ -1,2 +1,2 @@\n+ first\n+-second\n++third\n+`\n+\n+\tif got := string(bs[2]); got != want {\n+\t\tt.Errorf(\"diff: got:\\n%s\\nwant:\\n%s\", got, want)\n+\t}\n+}\n+\n+func TestReplaceTempFilename(t *testing.T) {\n+\tdiff := []byte(`--- /tmp/tmpfile1\t2017-02-08 00:53:26.175105619 +0900\n++++ /tmp/tmpfile2\t2017-02-08 00:53:38.415151275 +0900\n+@@ -1,2 +1,2 @@\n+ first\n+-second\n++third\n+`)\n+\twant := []byte(`--- path/to/file.go.orig\t2017-02-08 00:53:26.175105619 +0900\n++++ path/to/file.go\t2017-02-08 00:53:38.415151275 +0900\n+@@ -1,2 +1,2 @@\n+ first\n+-second\n++third\n+`)\n+\t// Check path in diff output is always slash regardless of the\n+\t// os.PathSeparator (`/` or `\\`).\n+\tsep := string(os.PathSeparator)\n+\tfilename := strings.Join([]string{\"path\", \"to\", \"file.go\"}, sep)\n+\tgot, err := replaceTempFilename(diff, filename)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tif !bytes.Equal(got, want) {\n+\t\tt.Errorf(\"os.PathSeparator='%s': replacedDiff:\\ngot:\\n%s\\nwant:\\n%s\", sep, got, want)\n+\t}\n+}"}, {"sha": "79b7858a5afd06be14152efdc3cf9d12a4fa1887", "filename": "libgo/go/cmd/gofmt/rewrite.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgofmt%2Frewrite.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Fgofmt%2Frewrite.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Frewrite.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -66,10 +66,10 @@ func rewriteFile(pattern, replace ast.Expr, p *ast.File) *ast.File {\n \t\tif !val.IsValid() {\n \t\t\treturn reflect.Value{}\n \t\t}\n+\t\tval = apply(rewriteVal, val)\n \t\tfor k := range m {\n \t\t\tdelete(m, k)\n \t\t}\n-\t\tval = apply(rewriteVal, val)\n \t\tif match(m, pat, val) {\n \t\t\tval = subst(m, repl, reflect.ValueOf(val.Interface().(ast.Node).Pos()))\n \t\t}"}, {"sha": "6867c85d2320406bb4c80b8960f5b958c6a2f196", "filename": "libgo/go/cmd/internal/browser/browser.go", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Finternal%2Fbrowser%2Fbrowser.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Finternal%2Fbrowser%2Fbrowser.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Finternal%2Fbrowser%2Fbrowser.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -9,6 +9,7 @@ import (\n \t\"os\"\n \t\"os/exec\"\n \t\"runtime\"\n+\t\"time\"\n )\n \n // Commands returns a list of possible commands to use to open a url.\n@@ -23,7 +24,10 @@ func Commands() [][]string {\n \tcase \"windows\":\n \t\tcmds = append(cmds, []string{\"cmd\", \"/c\", \"start\"})\n \tdefault:\n-\t\tcmds = append(cmds, []string{\"xdg-open\"})\n+\t\tif os.Getenv(\"DISPLAY\") != \"\" {\n+\t\t\t// xdg-open is only for use in a desktop environment.\n+\t\t\tcmds = append(cmds, []string{\"xdg-open\"})\n+\t\t}\n \t}\n \tcmds = append(cmds,\n \t\t[]string{\"chrome\"},\n@@ -38,9 +42,26 @@ func Commands() [][]string {\n func Open(url string) bool {\n \tfor _, args := range Commands() {\n \t\tcmd := exec.Command(args[0], append(args[1:], url)...)\n-\t\tif cmd.Start() == nil {\n+\t\tif cmd.Start() == nil && appearsSuccessful(cmd, 3*time.Second) {\n \t\t\treturn true\n \t\t}\n \t}\n \treturn false\n }\n+\n+// appearsSuccessful reports whether the command appears to have run successfully.\n+// If the command runs longer than the timeout, it's deemed successful.\n+// If the command runs within the timeout, it's deemed successful if it exited cleanly.\n+func appearsSuccessful(cmd *exec.Cmd, timeout time.Duration) bool {\n+\terrc := make(chan error, 1)\n+\tgo func() {\n+\t\terrc <- cmd.Wait()\n+\t}()\n+\n+\tselect {\n+\tcase <-time.After(timeout):\n+\t\treturn true\n+\tcase err := <-errc:\n+\t\treturn err == nil\n+\t}\n+}"}, {"sha": "17c42931310ffb442d7b5ab3520122de6e7cb499", "filename": "libgo/go/cmd/internal/objabi/autotype.go", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fautotype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fautotype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fautotype.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -0,0 +1,37 @@\n+// Derived from Inferno utils/6l/l.h and related files.\n+// https://bitbucket.org/inferno-os/inferno-os/src/default/utils/6l/l.h\n+//\n+//\tCopyright \u00a9 1994-1999 Lucent Technologies Inc.  All rights reserved.\n+//\tPortions Copyright \u00a9 1995-1997 C H Forsyth (forsyth@terzarima.net)\n+//\tPortions Copyright \u00a9 1997-1999 Vita Nuova Limited\n+//\tPortions Copyright \u00a9 2000-2007 Vita Nuova Holdings Limited (www.vitanuova.com)\n+//\tPortions Copyright \u00a9 2004,2006 Bruce Ellis\n+//\tPortions Copyright \u00a9 2005-2007 C H Forsyth (forsyth@terzarima.net)\n+//\tRevisions Copyright \u00a9 2000-2007 Lucent Technologies Inc. and others\n+//\tPortions Copyright \u00a9 2009 The Go Authors. All rights reserved.\n+//\n+// Permission is hereby granted, free of charge, to any person obtaining a copy\n+// of this software and associated documentation files (the \"Software\"), to deal\n+// in the Software without restriction, including without limitation the rights\n+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+// copies of the Software, and to permit persons to whom the Software is\n+// furnished to do so, subject to the following conditions:\n+//\n+// The above copyright notice and this permission notice shall be included in\n+// all copies or substantial portions of the Software.\n+//\n+// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\n+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+// THE SOFTWARE.\n+\n+package objabi\n+\n+// Auto.name\n+const (\n+\tA_AUTO = 1 + iota\n+\tA_PARAM\n+)"}, {"sha": "7bd5ff63e562c7a47ab73e18f3ab7c8bde2db242", "filename": "libgo/go/cmd/internal/objabi/doc.go", "status": "added", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fdoc.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -0,0 +1,120 @@\n+// Copyright 2013 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// NOTE: There are *three* independent implementations of this object\n+// file format in the Go source tree:\n+//\n+//\t- cmd/internal/goobj/read.go (used by cmd/addr2line, cmd/nm, cmd/objdump, cmd/pprof)\n+//\t- cmd/internal/obj/objfile.go (used by cmd/asm and cmd/compile)\n+//\t- cmd/link/internal/objfile.go (used by cmd/link)\n+//\n+// When changing the object file format, remember to change all three.\n+\n+// Originally, Go object files were Plan 9 object files, but no longer.\n+// Now they are more like standard object files, in that each symbol is defined\n+// by an associated memory image (bytes) and a list of relocations to apply\n+// during linking. We do not (yet?) use a standard file format, however.\n+// For now, the format is chosen to be as simple as possible to read and write.\n+// It may change for reasons of efficiency, or we may even switch to a\n+// standard file format if there are compelling benefits to doing so.\n+// See golang.org/s/go13linker for more background.\n+//\n+// The file format is:\n+//\n+//\t- magic header: \"\\x00\\x00go19ld\"\n+//\t- byte 1 - version number\n+//\t- sequence of strings giving dependencies (imported packages)\n+//\t- empty string (marks end of sequence)\n+//\t- sequence of symbol references used by the defined symbols\n+//\t- byte 0xff (marks end of sequence)\n+//\t- sequence of integer lengths:\n+//\t\t- total data length\n+//\t\t- total number of relocations\n+//\t\t- total number of pcdata\n+//\t\t- total number of automatics\n+//\t\t- total number of funcdata\n+//\t\t- total number of files\n+//\t- data, the content of the defined symbols\n+//\t- sequence of defined symbols\n+//\t- byte 0xff (marks end of sequence)\n+//\t- magic footer: \"\\xff\\xffgo19ld\"\n+//\n+// All integers are stored in a zigzag varint format.\n+// See golang.org/s/go12symtab for a definition.\n+//\n+// Data blocks and strings are both stored as an integer\n+// followed by that many bytes.\n+//\n+// A symbol reference is a string name followed by a version.\n+//\n+// A symbol points to other symbols using an index into the symbol\n+// reference sequence. Index 0 corresponds to a nil symbol pointer.\n+// In the symbol layout described below \"symref index\" stands for this\n+// index.\n+//\n+// Each symbol is laid out as the following fields:\n+//\n+//\t- byte 0xfe (sanity check for synchronization)\n+//\t- type [byte]\n+//\t- name & version [symref index]\n+//\t- flags [int]\n+//\t\t1<<0 dupok\n+//\t\t1<<1 local\n+//\t\t1<<2 add to typelink table\n+//\t- size [int]\n+//\t- gotype [symref index]\n+//\t- p [data block]\n+//\t- nr [int]\n+//\t- r [nr relocations, sorted by off]\n+//\n+// If type == STEXT, there are a few more fields:\n+//\n+//\t- args [int]\n+//\t- locals [int]\n+//\t- nosplit [int]\n+//\t- flags [int]\n+//\t\t1<<0 leaf\n+//\t\t1<<1 C function\n+//\t\t1<<2 function may call reflect.Type.Method\n+//\t\t1<<3 function compiled with -shared\n+//\t- nlocal [int]\n+//\t- local [nlocal automatics]\n+//\t- pcln [pcln table]\n+//\n+// Each relocation has the encoding:\n+//\n+//\t- off [int]\n+//\t- siz [int]\n+//\t- type [int]\n+//\t- add [int]\n+//\t- sym [symref index]\n+//\n+// Each local has the encoding:\n+//\n+//\t- asym [symref index]\n+//\t- offset [int]\n+//\t- type [int]\n+//\t- gotype [symref index]\n+//\n+// The pcln table has the encoding:\n+//\n+//\t- pcsp [data block]\n+//\t- pcfile [data block]\n+//\t- pcline [data block]\n+//\t- pcinline [data block]\n+//\t- npcdata [int]\n+//\t- pcdata [npcdata data blocks]\n+//\t- nfuncdata [int]\n+//\t- funcdata [nfuncdata symref index]\n+//\t- funcdatasym [nfuncdata ints]\n+//\t- nfile [int]\n+//\t- file [nfile symref index]\n+//\t- ninlinedcall [int]\n+//\t- inlinedcall [ninlinedcall int symref int symref]\n+//\n+// The file layout and meaning of type integers are architecture-independent.\n+//\n+// TODO(rsc): The file format is good for a first pass but needs work.\n+//\t- There are SymID in the object file that should really just be strings.\n+package objabi"}, {"sha": "e349b413249ec17523c1326cdcfb57d48a5d1581", "filename": "libgo/go/cmd/internal/objabi/flag.go", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fflag.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fflag.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fflag.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -0,0 +1,115 @@\n+// Copyright 2015 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package objabi\n+\n+import (\n+\t\"flag\"\n+\t\"fmt\"\n+\t\"os\"\n+\t\"strconv\"\n+)\n+\n+func Flagfn2(string, string, func(string, string)) { panic(\"flag\") }\n+\n+func Flagcount(name, usage string, val *int) {\n+\tflag.Var((*count)(val), name, usage)\n+}\n+\n+func Flagint32(name, usage string, val *int32) {\n+\tflag.Var((*int32Value)(val), name, usage)\n+}\n+\n+func Flagint64(name, usage string, val *int64) {\n+\tflag.Int64Var(val, name, *val, usage)\n+}\n+\n+func Flagstr(name, usage string, val *string) {\n+\tflag.StringVar(val, name, *val, usage)\n+}\n+\n+func Flagfn0(name, usage string, f func()) {\n+\tflag.Var(fn0(f), name, usage)\n+}\n+\n+func Flagfn1(name, usage string, f func(string)) {\n+\tflag.Var(fn1(f), name, usage)\n+}\n+\n+func Flagprint(fd int) {\n+\tif fd == 1 {\n+\t\tflag.CommandLine.SetOutput(os.Stdout)\n+\t}\n+\tflag.PrintDefaults()\n+}\n+\n+func Flagparse(usage func()) {\n+\tflag.Usage = usage\n+\tflag.Parse()\n+}\n+\n+// count is a flag.Value that is like a flag.Bool and a flag.Int.\n+// If used as -name, it increments the count, but -name=x sets the count.\n+// Used for verbose flag -v.\n+type count int\n+\n+func (c *count) String() string {\n+\treturn fmt.Sprint(int(*c))\n+}\n+\n+func (c *count) Set(s string) error {\n+\tswitch s {\n+\tcase \"true\":\n+\t\t*c++\n+\tcase \"false\":\n+\t\t*c = 0\n+\tdefault:\n+\t\tn, err := strconv.Atoi(s)\n+\t\tif err != nil {\n+\t\t\treturn fmt.Errorf(\"invalid count %q\", s)\n+\t\t}\n+\t\t*c = count(n)\n+\t}\n+\treturn nil\n+}\n+\n+func (c *count) IsBoolFlag() bool {\n+\treturn true\n+}\n+\n+type int32Value int32\n+\n+func (i *int32Value) Set(s string) error {\n+\tv, err := strconv.ParseInt(s, 0, 64)\n+\t*i = int32Value(v)\n+\treturn err\n+}\n+\n+func (i *int32Value) Get() interface{} { return int32(*i) }\n+\n+func (i *int32Value) String() string { return fmt.Sprint(*i) }\n+\n+type fn0 func()\n+\n+func (f fn0) Set(s string) error {\n+\tf()\n+\treturn nil\n+}\n+\n+func (f fn0) Get() interface{} { return nil }\n+\n+func (f fn0) String() string { return \"\" }\n+\n+func (f fn0) IsBoolFlag() bool {\n+\treturn true\n+}\n+\n+type fn1 func(string)\n+\n+func (f fn1) Set(s string) error {\n+\tf(s)\n+\treturn nil\n+}\n+\n+func (f fn1) String() string { return \"\" }"}, {"sha": "80874edeb0f50dcd200f8bdf5187f0a728d4c67c", "filename": "libgo/go/cmd/internal/objabi/funcdata.go", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Ffuncdata.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Ffuncdata.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Ffuncdata.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2013 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package objabi\n+\n+// This file defines the IDs for PCDATA and FUNCDATA instructions\n+// in Go binaries.\n+//\n+// These must agree with ../../../runtime/funcdata.h and\n+// ../../../runtime/symtab.go.\n+\n+const (\n+\tPCDATA_StackMapIndex       = 0\n+\tPCDATA_InlTreeIndex        = 1\n+\tFUNCDATA_ArgsPointerMaps   = 0\n+\tFUNCDATA_LocalsPointerMaps = 1\n+\tFUNCDATA_InlTree           = 2\n+\n+\t// ArgsSizeUnknown is set in Func.argsize to mark all functions\n+\t// whose argument size is unknown (C vararg functions, and\n+\t// assembly code without an explicit specification).\n+\t// This value is generated by the compiler, assembler, or linker.\n+\tArgsSizeUnknown = -0x80000000\n+)"}, {"sha": "ff19606cd2be6f6f00392dffeb7e713e67d5b363", "filename": "libgo/go/cmd/internal/objabi/head.go", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fhead.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fhead.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fhead.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -0,0 +1,104 @@\n+// Derived from Inferno utils/6l/l.h and related files.\n+// https://bitbucket.org/inferno-os/inferno-os/src/default/utils/6l/l.h\n+//\n+//\tCopyright \u00a9 1994-1999 Lucent Technologies Inc.  All rights reserved.\n+//\tPortions Copyright \u00a9 1995-1997 C H Forsyth (forsyth@terzarima.net)\n+//\tPortions Copyright \u00a9 1997-1999 Vita Nuova Limited\n+//\tPortions Copyright \u00a9 2000-2007 Vita Nuova Holdings Limited (www.vitanuova.com)\n+//\tPortions Copyright \u00a9 2004,2006 Bruce Ellis\n+//\tPortions Copyright \u00a9 2005-2007 C H Forsyth (forsyth@terzarima.net)\n+//\tRevisions Copyright \u00a9 2000-2007 Lucent Technologies Inc. and others\n+//\tPortions Copyright \u00a9 2009 The Go Authors. All rights reserved.\n+//\n+// Permission is hereby granted, free of charge, to any person obtaining a copy\n+// of this software and associated documentation files (the \"Software\"), to deal\n+// in the Software without restriction, including without limitation the rights\n+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+// copies of the Software, and to permit persons to whom the Software is\n+// furnished to do so, subject to the following conditions:\n+//\n+// The above copyright notice and this permission notice shall be included in\n+// all copies or substantial portions of the Software.\n+//\n+// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\n+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+// THE SOFTWARE.\n+\n+package objabi\n+\n+import \"fmt\"\n+\n+// HeadType is the executable header type.\n+type HeadType uint8\n+\n+const (\n+\tHunknown HeadType = iota\n+\tHdarwin\n+\tHdragonfly\n+\tHfreebsd\n+\tHlinux\n+\tHnacl\n+\tHnetbsd\n+\tHopenbsd\n+\tHplan9\n+\tHsolaris\n+\tHwindows\n+)\n+\n+func (h *HeadType) Set(s string) error {\n+\tswitch s {\n+\tcase \"darwin\":\n+\t\t*h = Hdarwin\n+\tcase \"dragonfly\":\n+\t\t*h = Hdragonfly\n+\tcase \"freebsd\":\n+\t\t*h = Hfreebsd\n+\tcase \"linux\", \"android\":\n+\t\t*h = Hlinux\n+\tcase \"nacl\":\n+\t\t*h = Hnacl\n+\tcase \"netbsd\":\n+\t\t*h = Hnetbsd\n+\tcase \"openbsd\":\n+\t\t*h = Hopenbsd\n+\tcase \"plan9\":\n+\t\t*h = Hplan9\n+\tcase \"solaris\":\n+\t\t*h = Hsolaris\n+\tcase \"windows\":\n+\t\t*h = Hwindows\n+\tdefault:\n+\t\treturn fmt.Errorf(\"invalid headtype: %q\", s)\n+\t}\n+\treturn nil\n+}\n+\n+func (h *HeadType) String() string {\n+\tswitch *h {\n+\tcase Hdarwin:\n+\t\treturn \"darwin\"\n+\tcase Hdragonfly:\n+\t\treturn \"dragonfly\"\n+\tcase Hfreebsd:\n+\t\treturn \"freebsd\"\n+\tcase Hlinux:\n+\t\treturn \"linux\"\n+\tcase Hnacl:\n+\t\treturn \"nacl\"\n+\tcase Hnetbsd:\n+\t\treturn \"netbsd\"\n+\tcase Hopenbsd:\n+\t\treturn \"openbsd\"\n+\tcase Hplan9:\n+\t\treturn \"plan9\"\n+\tcase Hsolaris:\n+\t\treturn \"solaris\"\n+\tcase Hwindows:\n+\t\treturn \"windows\"\n+\t}\n+\treturn fmt.Sprintf(\"HeadType(%d)\", *h)\n+}"}, {"sha": "ed509b700179f739f16dfdf6c7c8eec1afc553a3", "filename": "libgo/go/cmd/internal/objabi/line.go", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fline.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fline.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fline.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -0,0 +1,82 @@\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package objabi\n+\n+import (\n+\t\"os\"\n+\t\"path/filepath\"\n+)\n+\n+// WorkingDir returns the current working directory\n+// (or \"/???\" if the directory cannot be identified),\n+// with \"/\" as separator.\n+func WorkingDir() string {\n+\tvar path string\n+\tpath, _ = os.Getwd()\n+\tif path == \"\" {\n+\t\tpath = \"/???\"\n+\t}\n+\treturn filepath.ToSlash(path)\n+}\n+\n+// AbsFile returns the absolute filename for file in the given directory.\n+// It also removes a leading pathPrefix, or else rewrites a leading $GOROOT\n+// prefix to the literal \"$GOROOT\".\n+// If the resulting path is the empty string, the result is \"??\".\n+func AbsFile(dir, file, pathPrefix string) string {\n+\tabs := file\n+\tif dir != \"\" && !filepath.IsAbs(file) {\n+\t\tabs = filepath.Join(dir, file)\n+\t}\n+\n+\tif pathPrefix != \"\" && hasPathPrefix(abs, pathPrefix) {\n+\t\tif abs == pathPrefix {\n+\t\t\tabs = \"\"\n+\t\t} else {\n+\t\t\tabs = abs[len(pathPrefix)+1:]\n+\t\t}\n+\t} else if hasPathPrefix(abs, GOROOT) {\n+\t\tabs = \"$GOROOT\" + abs[len(GOROOT):]\n+\t}\n+\tif abs == \"\" {\n+\t\tabs = \"??\"\n+\t}\n+\n+\treturn filepath.Clean(abs)\n+}\n+\n+// Does s have t as a path prefix?\n+// That is, does s == t or does s begin with t followed by a slash?\n+// For portability, we allow ASCII case folding, so that hasPathPrefix(\"a/b/c\", \"A/B\") is true.\n+// Similarly, we allow slash folding, so that hasPathPrefix(\"a/b/c\", \"a\\\\b\") is true.\n+// We do not allow full Unicode case folding, for fear of causing more confusion\n+// or harm than good. (For an example of the kinds of things that can go wrong,\n+// see http://article.gmane.org/gmane.linux.kernel/1853266.)\n+func hasPathPrefix(s string, t string) bool {\n+\tif len(t) > len(s) {\n+\t\treturn false\n+\t}\n+\tvar i int\n+\tfor i = 0; i < len(t); i++ {\n+\t\tcs := int(s[i])\n+\t\tct := int(t[i])\n+\t\tif 'A' <= cs && cs <= 'Z' {\n+\t\t\tcs += 'a' - 'A'\n+\t\t}\n+\t\tif 'A' <= ct && ct <= 'Z' {\n+\t\t\tct += 'a' - 'A'\n+\t\t}\n+\t\tif cs == '\\\\' {\n+\t\t\tcs = '/'\n+\t\t}\n+\t\tif ct == '\\\\' {\n+\t\t\tct = '/'\n+\t\t}\n+\t\tif cs != ct {\n+\t\t\treturn false\n+\t\t}\n+\t}\n+\treturn i >= len(s) || s[i] == '/' || s[i] == '\\\\'\n+}"}, {"sha": "2a42179a3686b20e0b757d6cd52e02967d9dff69", "filename": "libgo/go/cmd/internal/objabi/path.go", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fpath.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fpath.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fpath.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -0,0 +1,41 @@\n+// Copyright 2017 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package objabi\n+\n+import \"strings\"\n+\n+// PathToPrefix converts raw string to the prefix that will be used in the\n+// symbol table. All control characters, space, '%' and '\"', as well as\n+// non-7-bit clean bytes turn into %xx. The period needs escaping only in the\n+// last segment of the path, and it makes for happier users if we escape that as\n+// little as possible.\n+func PathToPrefix(s string) string {\n+\tslash := strings.LastIndex(s, \"/\")\n+\t// check for chars that need escaping\n+\tn := 0\n+\tfor r := 0; r < len(s); r++ {\n+\t\tif c := s[r]; c <= ' ' || (c == '.' && r > slash) || c == '%' || c == '\"' || c >= 0x7F {\n+\t\t\tn++\n+\t\t}\n+\t}\n+\n+\t// quick exit\n+\tif n == 0 {\n+\t\treturn s\n+\t}\n+\n+\t// escape\n+\tconst hex = \"0123456789abcdef\"\n+\tp := make([]byte, 0, len(s)+2*n)\n+\tfor r := 0; r < len(s); r++ {\n+\t\tif c := s[r]; c <= ' ' || (c == '.' && r > slash) || c == '%' || c == '\"' || c >= 0x7F {\n+\t\t\tp = append(p, '%', hex[c>>4], hex[c&0xF])\n+\t\t} else {\n+\t\t\tp = append(p, c)\n+\t\t}\n+\t}\n+\n+\treturn string(p)\n+}"}, {"sha": "05d7fb436e33e22f5fbcb4c2a33f5639955da7d9", "filename": "libgo/go/cmd/internal/objabi/path_test.go", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fpath_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fpath_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fpath_test.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2017 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package objabi\n+\n+import \"testing\"\n+\n+func TestPathToPrefix(t *testing.T) {\n+\ttests := []struct {\n+\t\tPath     string\n+\t\tExpected string\n+\t}{{\"foo/bar/v1\", \"foo/bar/v1\"},\n+\t\t{\"foo/bar/v.1\", \"foo/bar/v%2e1\"},\n+\t\t{\"f.o.o/b.a.r/v1\", \"f.o.o/b.a.r/v1\"},\n+\t\t{\"f.o.o/b.a.r/v.1\", \"f.o.o/b.a.r/v%2e1\"},\n+\t\t{\"f.o.o/b.a.r/v..1\", \"f.o.o/b.a.r/v%2e%2e1\"},\n+\t\t{\"f.o.o/b.a.r/v..1.\", \"f.o.o/b.a.r/v%2e%2e1%2e\"},\n+\t\t{\"f.o.o/b.a.r/v%1\", \"f.o.o/b.a.r/v%251\"},\n+\t\t{\"runtime\", \"runtime\"},\n+\t\t{\"sync/atomic\", \"sync/atomic\"},\n+\t\t{\"golang.org/x/tools/godoc\", \"golang.org/x/tools/godoc\"},\n+\t\t{\"foo.bar/baz.quux\", \"foo.bar/baz%2equux\"},\n+\t\t{\"\", \"\"},\n+\t\t{\"%foo%bar\", \"%25foo%25bar\"},\n+\t\t{\"\\x01\\x00\\x7F\u263a\", \"%01%00%7f%e2%98%ba\"},\n+\t}\n+\tfor _, tc := range tests {\n+\t\tif got := PathToPrefix(tc.Path); got != tc.Expected {\n+\t\t\tt.Errorf(\"expected PathToPrefix(%s) = %s, got %s\", tc.Path, tc.Expected, got)\n+\t\t}\n+\t}\n+}"}, {"sha": "179f049de7d6ffa0c25432d2e4cadc059091e400", "filename": "libgo/go/cmd/internal/objabi/reloctype.go", "status": "added", "additions": 200, "deletions": 0, "changes": 200, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Freloctype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Freloctype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Freloctype.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -0,0 +1,200 @@\n+// Derived from Inferno utils/6l/l.h and related files.\n+// https://bitbucket.org/inferno-os/inferno-os/src/default/utils/6l/l.h\n+//\n+//\tCopyright \u00a9 1994-1999 Lucent Technologies Inc.  All rights reserved.\n+//\tPortions Copyright \u00a9 1995-1997 C H Forsyth (forsyth@terzarima.net)\n+//\tPortions Copyright \u00a9 1997-1999 Vita Nuova Limited\n+//\tPortions Copyright \u00a9 2000-2007 Vita Nuova Holdings Limited (www.vitanuova.com)\n+//\tPortions Copyright \u00a9 2004,2006 Bruce Ellis\n+//\tPortions Copyright \u00a9 2005-2007 C H Forsyth (forsyth@terzarima.net)\n+//\tRevisions Copyright \u00a9 2000-2007 Lucent Technologies Inc. and others\n+//\tPortions Copyright \u00a9 2009 The Go Authors. All rights reserved.\n+//\n+// Permission is hereby granted, free of charge, to any person obtaining a copy\n+// of this software and associated documentation files (the \"Software\"), to deal\n+// in the Software without restriction, including without limitation the rights\n+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+// copies of the Software, and to permit persons to whom the Software is\n+// furnished to do so, subject to the following conditions:\n+//\n+// The above copyright notice and this permission notice shall be included in\n+// all copies or substantial portions of the Software.\n+//\n+// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\n+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+// THE SOFTWARE.\n+\n+package objabi\n+\n+type RelocType int32\n+\n+//go:generate stringer -type=RelocType\n+const (\n+\tR_ADDR RelocType = 1 + iota\n+\t// R_ADDRPOWER relocates a pair of \"D-form\" instructions (instructions with 16-bit\n+\t// immediates in the low half of the instruction word), usually addis followed by\n+\t// another add or a load, inserting the \"high adjusted\" 16 bits of the address of\n+\t// the referenced symbol into the immediate field of the first instruction and the\n+\t// low 16 bits into that of the second instruction.\n+\tR_ADDRPOWER\n+\t// R_ADDRARM64 relocates an adrp, add pair to compute the address of the\n+\t// referenced symbol.\n+\tR_ADDRARM64\n+\t// R_ADDRMIPS (only used on mips/mips64) resolves to the low 16 bits of an external\n+\t// address, by encoding it into the instruction.\n+\tR_ADDRMIPS\n+\t// R_ADDROFF resolves to a 32-bit offset from the beginning of the section\n+\t// holding the data being relocated to the referenced symbol.\n+\tR_ADDROFF\n+\t// R_WEAKADDROFF resolves just like R_ADDROFF but is a weak relocation.\n+\t// A weak relocation does not make the symbol it refers to reachable,\n+\t// and is only honored by the linker if the symbol is in some other way\n+\t// reachable.\n+\tR_WEAKADDROFF\n+\tR_SIZE\n+\tR_CALL\n+\tR_CALLARM\n+\tR_CALLARM64\n+\tR_CALLIND\n+\tR_CALLPOWER\n+\t// R_CALLMIPS (only used on mips64) resolves to non-PC-relative target address\n+\t// of a CALL (JAL) instruction, by encoding the address into the instruction.\n+\tR_CALLMIPS\n+\tR_CONST\n+\tR_PCREL\n+\t// R_TLS_LE, used on 386, amd64, and ARM, resolves to the offset of the\n+\t// thread-local symbol from the thread local base and is used to implement the\n+\t// \"local exec\" model for tls access (r.Sym is not set on intel platforms but is\n+\t// set to a TLS symbol -- runtime.tlsg -- in the linker when externally linking).\n+\tR_TLS_LE\n+\t// R_TLS_IE, used 386, amd64, and ARM resolves to the PC-relative offset to a GOT\n+\t// slot containing the offset from the thread-local symbol from the thread local\n+\t// base and is used to implemented the \"initial exec\" model for tls access (r.Sym\n+\t// is not set on intel platforms but is set to a TLS symbol -- runtime.tlsg -- in\n+\t// the linker when externally linking).\n+\tR_TLS_IE\n+\tR_GOTOFF\n+\tR_PLT0\n+\tR_PLT1\n+\tR_PLT2\n+\tR_USEFIELD\n+\t// R_USETYPE resolves to an *rtype, but no relocation is created. The\n+\t// linker uses this as a signal that the pointed-to type information\n+\t// should be linked into the final binary, even if there are no other\n+\t// direct references. (This is used for types reachable by reflection.)\n+\tR_USETYPE\n+\t// R_METHODOFF resolves to a 32-bit offset from the beginning of the section\n+\t// holding the data being relocated to the referenced symbol.\n+\t// It is a variant of R_ADDROFF used when linking from the uncommonType of a\n+\t// *rtype, and may be set to zero by the linker if it determines the method\n+\t// text is unreachable by the linked program.\n+\tR_METHODOFF\n+\tR_POWER_TOC\n+\tR_GOTPCREL\n+\t// R_JMPMIPS (only used on mips64) resolves to non-PC-relative target address\n+\t// of a JMP instruction, by encoding the address into the instruction.\n+\t// The stack nosplit check ignores this since it is not a function call.\n+\tR_JMPMIPS\n+\t// R_DWARFREF resolves to the offset of the symbol from its section.\n+\tR_DWARFREF\n+\n+\t// Platform dependent relocations. Architectures with fixed width instructions\n+\t// have the inherent issue that a 32-bit (or 64-bit!) displacement cannot be\n+\t// stuffed into a 32-bit instruction, so an address needs to be spread across\n+\t// several instructions, and in turn this requires a sequence of relocations, each\n+\t// updating a part of an instruction. This leads to relocation codes that are\n+\t// inherently processor specific.\n+\n+\t// Arm64.\n+\n+\t// Set a MOV[NZ] immediate field to bits [15:0] of the offset from the thread\n+\t// local base to the thread local variable defined by the referenced (thread\n+\t// local) symbol. Error if the offset does not fit into 16 bits.\n+\tR_ARM64_TLS_LE\n+\n+\t// Relocates an ADRP; LD64 instruction sequence to load the offset between\n+\t// the thread local base and the thread local variable defined by the\n+\t// referenced (thread local) symbol from the GOT.\n+\tR_ARM64_TLS_IE\n+\n+\t// R_ARM64_GOTPCREL relocates an adrp, ld64 pair to compute the address of the GOT\n+\t// slot of the referenced symbol.\n+\tR_ARM64_GOTPCREL\n+\n+\t// PPC64.\n+\n+\t// R_POWER_TLS_LE is used to implement the \"local exec\" model for tls\n+\t// access. It resolves to the offset of the thread-local symbol from the\n+\t// thread pointer (R13) and inserts this value into the low 16 bits of an\n+\t// instruction word.\n+\tR_POWER_TLS_LE\n+\n+\t// R_POWER_TLS_IE is used to implement the \"initial exec\" model for tls access. It\n+\t// relocates a D-form, DS-form instruction sequence like R_ADDRPOWER_DS. It\n+\t// inserts to the offset of GOT slot for the thread-local symbol from the TOC (the\n+\t// GOT slot is filled by the dynamic linker with the offset of the thread-local\n+\t// symbol from the thread pointer (R13)).\n+\tR_POWER_TLS_IE\n+\n+\t// R_POWER_TLS marks an X-form instruction such as \"MOVD 0(R13)(R31*1), g\" as\n+\t// accessing a particular thread-local symbol. It does not affect code generation\n+\t// but is used by the system linker when relaxing \"initial exec\" model code to\n+\t// \"local exec\" model code.\n+\tR_POWER_TLS\n+\n+\t// R_ADDRPOWER_DS is similar to R_ADDRPOWER above, but assumes the second\n+\t// instruction is a \"DS-form\" instruction, which has an immediate field occupying\n+\t// bits [15:2] of the instruction word. Bits [15:2] of the address of the\n+\t// relocated symbol are inserted into this field; it is an error if the last two\n+\t// bits of the address are not 0.\n+\tR_ADDRPOWER_DS\n+\n+\t// R_ADDRPOWER_PCREL relocates a D-form, DS-form instruction sequence like\n+\t// R_ADDRPOWER_DS but inserts the offset of the GOT slot for the referenced symbol\n+\t// from the TOC rather than the symbol's address.\n+\tR_ADDRPOWER_GOT\n+\n+\t// R_ADDRPOWER_PCREL relocates two D-form instructions like R_ADDRPOWER, but\n+\t// inserts the displacement from the place being relocated to the address of the\n+\t// the relocated symbol instead of just its address.\n+\tR_ADDRPOWER_PCREL\n+\n+\t// R_ADDRPOWER_TOCREL relocates two D-form instructions like R_ADDRPOWER, but\n+\t// inserts the offset from the TOC to the address of the relocated symbol\n+\t// rather than the symbol's address.\n+\tR_ADDRPOWER_TOCREL\n+\n+\t// R_ADDRPOWER_TOCREL relocates a D-form, DS-form instruction sequence like\n+\t// R_ADDRPOWER_DS but inserts the offset from the TOC to the address of the the\n+\t// relocated symbol rather than the symbol's address.\n+\tR_ADDRPOWER_TOCREL_DS\n+\n+\t// R_PCRELDBL relocates s390x 2-byte aligned PC-relative addresses.\n+\t// TODO(mundaym): remove once variants can be serialized - see issue 14218.\n+\tR_PCRELDBL\n+\n+\t// R_ADDRMIPSU (only used on mips/mips64) resolves to the sign-adjusted \"upper\" 16\n+\t// bits (bit 16-31) of an external address, by encoding it into the instruction.\n+\tR_ADDRMIPSU\n+\t// R_ADDRMIPSTLS (only used on mips64) resolves to the low 16 bits of a TLS\n+\t// address (offset from thread pointer), by encoding it into the instruction.\n+\tR_ADDRMIPSTLS\n+)\n+\n+// IsDirectJump returns whether r is a relocation for a direct jump.\n+// A direct jump is a CALL or JMP instruction that takes the target address\n+// as immediate. The address is embedded into the instruction, possibly\n+// with limited width.\n+// An indirect jump is a CALL or JMP instruction that takes the target address\n+// in register or memory.\n+func (r RelocType) IsDirectJump() bool {\n+\tswitch r {\n+\tcase R_CALL, R_CALLARM, R_CALLARM64, R_CALLPOWER, R_CALLMIPS, R_JMPMIPS:\n+\t\treturn true\n+\t}\n+\treturn false\n+}"}, {"sha": "182d03f78c1260233e8f660feb25535709f169c7", "filename": "libgo/go/cmd/internal/objabi/reloctype_string.go", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Freloctype_string.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Freloctype_string.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Freloctype_string.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -0,0 +1,17 @@\n+// Code generated by \"stringer -type=RelocType\"; DO NOT EDIT.\n+\n+package objabi\n+\n+import \"fmt\"\n+\n+const _RelocType_name = \"R_ADDRR_ADDRPOWERR_ADDRARM64R_ADDRMIPSR_ADDROFFR_WEAKADDROFFR_SIZER_CALLR_CALLARMR_CALLARM64R_CALLINDR_CALLPOWERR_CALLMIPSR_CONSTR_PCRELR_TLS_LER_TLS_IER_GOTOFFR_PLT0R_PLT1R_PLT2R_USEFIELDR_USETYPER_METHODOFFR_POWER_TOCR_GOTPCRELR_JMPMIPSR_DWARFREFR_ARM64_TLS_LER_ARM64_TLS_IER_ARM64_GOTPCRELR_POWER_TLS_LER_POWER_TLS_IER_POWER_TLSR_ADDRPOWER_DSR_ADDRPOWER_GOTR_ADDRPOWER_PCRELR_ADDRPOWER_TOCRELR_ADDRPOWER_TOCREL_DSR_PCRELDBLR_ADDRMIPSUR_ADDRMIPSTLS\"\n+\n+var _RelocType_index = [...]uint16{0, 6, 17, 28, 38, 47, 60, 66, 72, 81, 92, 101, 112, 122, 129, 136, 144, 152, 160, 166, 172, 178, 188, 197, 208, 219, 229, 238, 248, 262, 276, 292, 306, 320, 331, 345, 360, 377, 395, 416, 426, 437, 450}\n+\n+func (i RelocType) String() string {\n+\ti -= 1\n+\tif i < 0 || i >= RelocType(len(_RelocType_index)-1) {\n+\t\treturn fmt.Sprintf(\"RelocType(%d)\", i+1)\n+\t}\n+\treturn _RelocType_name[_RelocType_index[i]:_RelocType_index[i+1]]\n+}"}, {"sha": "11433932e2dcfbdc8eeb4b26cc85bddaf7e237d2", "filename": "libgo/go/cmd/internal/objabi/stack.go", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fstack.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fstack.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fstack.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package objabi\n+\n+// For the linkers. Must match Go definitions.\n+\n+const (\n+\tSTACKSYSTEM = 0\n+\tStackSystem = STACKSYSTEM\n+\tStackBig    = 4096\n+\tStackGuard  = 880*stackGuardMultiplier + StackSystem\n+\tStackSmall  = 128\n+\tStackLimit  = StackGuard - StackSystem - StackSmall\n+)\n+\n+const (\n+\tStackPreempt = -1314 // 0xfff...fade\n+)"}, {"sha": "b037e9e4ed17c6ecfef1d136d3b226f484ff2618", "filename": "libgo/go/cmd/internal/objabi/symkind.go", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fsymkind.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fsymkind.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fsymkind.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -0,0 +1,60 @@\n+// Derived from Inferno utils/6l/l.h and related files.\n+// https://bitbucket.org/inferno-os/inferno-os/src/default/utils/6l/l.h\n+//\n+//\tCopyright \u00a9 1994-1999 Lucent Technologies Inc.  All rights reserved.\n+//\tPortions Copyright \u00a9 1995-1997 C H Forsyth (forsyth@terzarima.net)\n+//\tPortions Copyright \u00a9 1997-1999 Vita Nuova Limited\n+//\tPortions Copyright \u00a9 2000-2007 Vita Nuova Holdings Limited (www.vitanuova.com)\n+//\tPortions Copyright \u00a9 2004,2006 Bruce Ellis\n+//\tPortions Copyright \u00a9 2005-2007 C H Forsyth (forsyth@terzarima.net)\n+//\tRevisions Copyright \u00a9 2000-2007 Lucent Technologies Inc. and others\n+//\tPortions Copyright \u00a9 2009 The Go Authors. All rights reserved.\n+//\n+// Permission is hereby granted, free of charge, to any person obtaining a copy\n+// of this software and associated documentation files (the \"Software\"), to deal\n+// in the Software without restriction, including without limitation the rights\n+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+// copies of the Software, and to permit persons to whom the Software is\n+// furnished to do so, subject to the following conditions:\n+//\n+// The above copyright notice and this permission notice shall be included in\n+// all copies or substantial portions of the Software.\n+//\n+// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\n+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+// THE SOFTWARE.\n+\n+package objabi\n+\n+// A SymKind describes the kind of memory represented by a symbol.\n+type SymKind uint8\n+\n+// Defined SymKind values.\n+//\n+// TODO(rsc): Give idiomatic Go names.\n+//go:generate stringer -type=SymKind\n+const (\n+\t// An otherwise invalid zero value for the type\n+\tSxxx SymKind = iota\n+\t// Executable instructions\n+\tSTEXT\n+\t// Read only static data\n+\tSRODATA\n+\t// Static data that does not contain any pointers\n+\tSNOPTRDATA\n+\t// Static data\n+\tSDATA\n+\t// Statically data that is initially all 0s\n+\tSBSS\n+\t// Statically data that is initially all 0s and does not contain pointers\n+\tSNOPTRBSS\n+\t// Thread-local data that is initally all 0s\n+\tSTLSBSS\n+\t// Debugging data\n+\tSDWARFINFO\n+\tSDWARFRANGE\n+)"}, {"sha": "5123dc7097f49ad8aa917425af8f8d7f0d207ae0", "filename": "libgo/go/cmd/internal/objabi/symkind_string.go", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fsymkind_string.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fsymkind_string.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fsymkind_string.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -0,0 +1,16 @@\n+// Code generated by \"stringer -type=SymKind\"; DO NOT EDIT.\n+\n+package objabi\n+\n+import \"fmt\"\n+\n+const _SymKind_name = \"SxxxSTEXTSRODATASNOPTRDATASDATASBSSSNOPTRBSSSTLSBSSSDWARFINFOSDWARFRANGE\"\n+\n+var _SymKind_index = [...]uint8{0, 4, 9, 16, 26, 31, 35, 44, 51, 61, 72}\n+\n+func (i SymKind) String() string {\n+\tif i >= SymKind(len(_SymKind_index)-1) {\n+\t\treturn fmt.Sprintf(\"SymKind(%d)\", i)\n+\t}\n+\treturn _SymKind_name[_SymKind_index[i]:_SymKind_index[i+1]]\n+}"}, {"sha": "f0e6f472e5bf5c26aaad36b6f85b53798403d913", "filename": "libgo/go/cmd/internal/objabi/typekind.go", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Ftypekind.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Ftypekind.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Ftypekind.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -0,0 +1,41 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package objabi\n+\n+// Must match runtime and reflect.\n+// Included by cmd/gc.\n+\n+const (\n+\tKindBool = 1 + iota\n+\tKindInt\n+\tKindInt8\n+\tKindInt16\n+\tKindInt32\n+\tKindInt64\n+\tKindUint\n+\tKindUint8\n+\tKindUint16\n+\tKindUint32\n+\tKindUint64\n+\tKindUintptr\n+\tKindFloat32\n+\tKindFloat64\n+\tKindComplex64\n+\tKindComplex128\n+\tKindArray\n+\tKindChan\n+\tKindFunc\n+\tKindInterface\n+\tKindMap\n+\tKindPtr\n+\tKindSlice\n+\tKindString\n+\tKindStruct\n+\tKindUnsafePointer\n+\tKindDirectIface = 1 << 5\n+\tKindGCProg      = 1 << 6\n+\tKindNoPointers  = 1 << 7\n+\tKindMask        = (1 << 5) - 1\n+)"}, {"sha": "1da05021f50855feb95b63424edfb4d915198942", "filename": "libgo/go/cmd/internal/objabi/util.go", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Futil.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Futil.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Futil.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -0,0 +1,119 @@\n+// Copyright 2015 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package objabi\n+\n+import (\n+\t\"fmt\"\n+\t\"log\"\n+\t\"os\"\n+\t\"strings\"\n+)\n+\n+func envOr(key, value string) string {\n+\tif x := os.Getenv(key); x != \"\" {\n+\t\treturn x\n+\t}\n+\treturn value\n+}\n+\n+var (\n+\tGOROOT  = envOr(\"GOROOT\", defaultGOROOT)\n+\tGOARCH  = envOr(\"GOARCH\", defaultGOARCH)\n+\tGOOS    = envOr(\"GOOS\", defaultGOOS)\n+\tGO386   = envOr(\"GO386\", defaultGO386)\n+\tGOARM   = goarm()\n+\tVersion = version\n+)\n+\n+func goarm() int {\n+\tswitch v := envOr(\"GOARM\", defaultGOARM); v {\n+\tcase \"5\":\n+\t\treturn 5\n+\tcase \"6\":\n+\t\treturn 6\n+\tcase \"7\":\n+\t\treturn 7\n+\t}\n+\t// Fail here, rather than validate at multiple call sites.\n+\tlog.Fatalf(\"Invalid GOARM value. Must be 5, 6, or 7.\")\n+\tpanic(\"unreachable\")\n+}\n+\n+func Getgoextlinkenabled() string {\n+\treturn envOr(\"GO_EXTLINK_ENABLED\", defaultGO_EXTLINK_ENABLED)\n+}\n+\n+func init() {\n+\tfor _, f := range strings.Split(goexperiment, \",\") {\n+\t\tif f != \"\" {\n+\t\t\taddexp(f)\n+\t\t}\n+\t}\n+}\n+\n+func Framepointer_enabled(goos, goarch string) bool {\n+\treturn framepointer_enabled != 0 && goarch == \"amd64\" && goos != \"nacl\"\n+}\n+\n+func addexp(s string) {\n+\t// Could do general integer parsing here, but the runtime copy doesn't yet.\n+\tv := 1\n+\tname := s\n+\tif len(name) > 2 && name[:2] == \"no\" {\n+\t\tv = 0\n+\t\tname = name[2:]\n+\t}\n+\tfor i := 0; i < len(exper); i++ {\n+\t\tif exper[i].name == name {\n+\t\t\tif exper[i].val != nil {\n+\t\t\t\t*exper[i].val = v\n+\t\t\t}\n+\t\t\treturn\n+\t\t}\n+\t}\n+\n+\tfmt.Printf(\"unknown experiment %s\\n\", s)\n+\tos.Exit(2)\n+}\n+\n+var (\n+\tframepointer_enabled     int = 1\n+\tFieldtrack_enabled       int\n+\tPreemptibleloops_enabled int\n+\tClobberdead_enabled      int\n+)\n+\n+// Toolchain experiments.\n+// These are controlled by the GOEXPERIMENT environment\n+// variable recorded when the toolchain is built.\n+// This list is also known to cmd/gc.\n+var exper = []struct {\n+\tname string\n+\tval  *int\n+}{\n+\t{\"fieldtrack\", &Fieldtrack_enabled},\n+\t{\"framepointer\", &framepointer_enabled},\n+\t{\"preemptibleloops\", &Preemptibleloops_enabled},\n+\t{\"clobberdead\", &Clobberdead_enabled},\n+}\n+\n+var defaultExpstring = Expstring()\n+\n+func DefaultExpstring() string {\n+\treturn defaultExpstring\n+}\n+\n+func Expstring() string {\n+\tbuf := \"X\"\n+\tfor i := range exper {\n+\t\tif *exper[i].val != 0 {\n+\t\t\tbuf += \",\" + exper[i].name\n+\t\t}\n+\t}\n+\tif buf == \"X\" {\n+\t\tbuf += \",none\"\n+\t}\n+\treturn \"X:\" + buf[2:]\n+}"}, {"sha": "56450fac61850a4ceec897628557def8290db60a", "filename": "libgo/go/cmd/internal/objabi/zbootstrap.go", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fzbootstrap.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fzbootstrap.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Finternal%2Fobjabi%2Fzbootstrap.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -0,0 +1,15 @@\n+// auto generated by go tool dist\n+\n+package objabi\n+\n+import \"runtime\"\n+\n+const defaultGOROOT = `/home/iant/go1.9`\n+const defaultGO386 = `sse2`\n+const defaultGOARM = `5`\n+const defaultGOOS = runtime.GOOS\n+const defaultGOARCH = runtime.GOARCH\n+const defaultGO_EXTLINK_ENABLED = ``\n+const version = `go1.9rc2`\n+const stackGuardMultiplier = 1\n+const goexperiment = ``"}, {"sha": "a6c3080db3efe5f49467b28e703aed888e560b02", "filename": "libgo/go/compress/bzip2/bzip2_test.go", "status": "modified", "additions": 9, "deletions": 15, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcompress%2Fbzip2%2Fbzip2_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcompress%2Fbzip2%2Fbzip2_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fbzip2%2Fbzip2_test.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -204,6 +204,12 @@ func TestMTF(t *testing.T) {\n \t}\n }\n \n+var (\n+\tdigits = mustLoadFile(\"testdata/e.txt.bz2\")\n+\ttwain  = mustLoadFile(\"testdata/Mark.Twain-Tom.Sawyer.txt.bz2\")\n+\trandom = mustLoadFile(\"testdata/random.data.bz2\")\n+)\n+\n func benchmarkDecode(b *testing.B, compressed []byte) {\n \t// Determine the uncompressed size of testfile.\n \tuncompressedSize, err := io.Copy(ioutil.Discard, NewReader(bytes.NewReader(compressed)))\n@@ -221,18 +227,6 @@ func benchmarkDecode(b *testing.B, compressed []byte) {\n \t}\n }\n \n-func BenchmarkDecodeDigits(b *testing.B) {\n-\tdigits := mustLoadFile(\"testdata/e.txt.bz2\")\n-\tb.ResetTimer()\n-\tbenchmarkDecode(b, digits)\n-}\n-func BenchmarkDecodeTwain(b *testing.B) {\n-\ttwain := mustLoadFile(\"testdata/Mark.Twain-Tom.Sawyer.txt.bz2\")\n-\tb.ResetTimer()\n-\tbenchmarkDecode(b, twain)\n-}\n-func BenchmarkDecodeRand(b *testing.B) {\n-\trandom := mustLoadFile(\"testdata/random.data.bz2\")\n-\tb.ResetTimer()\n-\tbenchmarkDecode(b, random)\n-}\n+func BenchmarkDecodeDigits(b *testing.B) { benchmarkDecode(b, digits) }\n+func BenchmarkDecodeTwain(b *testing.B)  { benchmarkDecode(b, twain) }\n+func BenchmarkDecodeRand(b *testing.B)   { benchmarkDecode(b, random) }"}, {"sha": "dbba9a58b5ae19f9f230f4b4d9a25d776968bc99", "filename": "libgo/go/compress/bzip2/huffman.go", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcompress%2Fbzip2%2Fhuffman.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcompress%2Fbzip2%2Fhuffman.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fbzip2%2Fhuffman.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -108,10 +108,6 @@ func newHuffmanTree(lengths []uint8) (huffmanTree, error) {\n \tcodes := huffmanCodes(make([]huffmanCode, len(lengths)))\n \tfor i := len(pairs) - 1; i >= 0; i-- {\n \t\tif length > pairs[i].length {\n-\t\t\t// If the code length decreases we shift in order to\n-\t\t\t// zero any bits beyond the end of the code.\n-\t\t\tlength >>= 32 - pairs[i].length\n-\t\t\tlength <<= 32 - pairs[i].length\n \t\t\tlength = pairs[i].length\n \t\t}\n \t\tcodes[i].code = code"}, {"sha": "891537ed5e6343eb0c6e67078e5ac9cff1b25bc2", "filename": "libgo/go/compress/flate/huffman_code.go", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcompress%2Fflate%2Fhuffman_code.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcompress%2Fflate%2Fhuffman_code.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Fhuffman_code.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -6,6 +6,7 @@ package flate\n \n import (\n \t\"math\"\n+\t\"math/bits\"\n \t\"sort\"\n )\n \n@@ -342,3 +343,7 @@ func (s byFreq) Less(i, j int) bool {\n }\n \n func (s byFreq) Swap(i, j int) { s[i], s[j] = s[j], s[i] }\n+\n+func reverseBits(number uint16, bitLength byte) uint16 {\n+\treturn bits.Reverse16(number << (16 - bitLength))\n+}"}, {"sha": "faa33cc6e9b6b0eb299c417c4696bc5652f3e901", "filename": "libgo/go/compress/flate/inflate.go", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcompress%2Fflate%2Finflate.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcompress%2Fflate%2Finflate.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Finflate.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -10,6 +10,7 @@ package flate\n import (\n \t\"bufio\"\n \t\"io\"\n+\tmathbits \"math/bits\"\n \t\"strconv\"\n \t\"sync\"\n )\n@@ -176,7 +177,7 @@ func (h *huffmanDecoder) init(bits []int) bool {\n \t\tlink := nextcode[huffmanChunkBits+1] >> 1\n \t\th.links = make([][]uint32, huffmanNumChunks-link)\n \t\tfor j := uint(link); j < huffmanNumChunks; j++ {\n-\t\t\treverse := int(reverseByte[j>>8]) | int(reverseByte[j&0xff])<<8\n+\t\t\treverse := int(mathbits.Reverse16(uint16(j)))\n \t\t\treverse >>= uint(16 - huffmanChunkBits)\n \t\t\toff := j - uint(link)\n \t\t\tif sanity && h.chunks[reverse] != 0 {\n@@ -194,7 +195,7 @@ func (h *huffmanDecoder) init(bits []int) bool {\n \t\tcode := nextcode[n]\n \t\tnextcode[n]++\n \t\tchunk := uint32(i<<huffmanValueShift | n)\n-\t\treverse := int(reverseByte[code>>8]) | int(reverseByte[code&0xff])<<8\n+\t\treverse := int(mathbits.Reverse16(uint16(code)))\n \t\treverse >>= uint(16 - n)\n \t\tif n <= huffmanChunkBits {\n \t\t\tfor off := reverse; off < len(h.chunks); off += 1 << uint(n) {\n@@ -556,7 +557,7 @@ readLiteral:\n \t\t\t\t\treturn\n \t\t\t\t}\n \t\t\t}\n-\t\t\tdist = int(reverseByte[(f.b&0x1F)<<3])\n+\t\t\tdist = int(mathbits.Reverse8(uint8(f.b & 0x1F << 3)))\n \t\t\tf.b >>= 5\n \t\t\tf.nb -= 5\n \t\t} else {"}, {"sha": "6b222900c1ec9deab163ca98e0bdcafd7c869fbb", "filename": "libgo/go/compress/flate/reverse_bits.go", "status": "removed", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a41a6142df74219f596e612d3a7775f68ca6e96f/libgo%2Fgo%2Fcompress%2Fflate%2Freverse_bits.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a41a6142df74219f596e612d3a7775f68ca6e96f/libgo%2Fgo%2Fcompress%2Fflate%2Freverse_bits.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Freverse_bits.go?ref=a41a6142df74219f596e612d3a7775f68ca6e96f", "patch": "@@ -1,48 +0,0 @@\n-// Copyright 2009 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package flate\n-\n-var reverseByte = [256]byte{\n-\t0x00, 0x80, 0x40, 0xc0, 0x20, 0xa0, 0x60, 0xe0,\n-\t0x10, 0x90, 0x50, 0xd0, 0x30, 0xb0, 0x70, 0xf0,\n-\t0x08, 0x88, 0x48, 0xc8, 0x28, 0xa8, 0x68, 0xe8,\n-\t0x18, 0x98, 0x58, 0xd8, 0x38, 0xb8, 0x78, 0xf8,\n-\t0x04, 0x84, 0x44, 0xc4, 0x24, 0xa4, 0x64, 0xe4,\n-\t0x14, 0x94, 0x54, 0xd4, 0x34, 0xb4, 0x74, 0xf4,\n-\t0x0c, 0x8c, 0x4c, 0xcc, 0x2c, 0xac, 0x6c, 0xec,\n-\t0x1c, 0x9c, 0x5c, 0xdc, 0x3c, 0xbc, 0x7c, 0xfc,\n-\t0x02, 0x82, 0x42, 0xc2, 0x22, 0xa2, 0x62, 0xe2,\n-\t0x12, 0x92, 0x52, 0xd2, 0x32, 0xb2, 0x72, 0xf2,\n-\t0x0a, 0x8a, 0x4a, 0xca, 0x2a, 0xaa, 0x6a, 0xea,\n-\t0x1a, 0x9a, 0x5a, 0xda, 0x3a, 0xba, 0x7a, 0xfa,\n-\t0x06, 0x86, 0x46, 0xc6, 0x26, 0xa6, 0x66, 0xe6,\n-\t0x16, 0x96, 0x56, 0xd6, 0x36, 0xb6, 0x76, 0xf6,\n-\t0x0e, 0x8e, 0x4e, 0xce, 0x2e, 0xae, 0x6e, 0xee,\n-\t0x1e, 0x9e, 0x5e, 0xde, 0x3e, 0xbe, 0x7e, 0xfe,\n-\t0x01, 0x81, 0x41, 0xc1, 0x21, 0xa1, 0x61, 0xe1,\n-\t0x11, 0x91, 0x51, 0xd1, 0x31, 0xb1, 0x71, 0xf1,\n-\t0x09, 0x89, 0x49, 0xc9, 0x29, 0xa9, 0x69, 0xe9,\n-\t0x19, 0x99, 0x59, 0xd9, 0x39, 0xb9, 0x79, 0xf9,\n-\t0x05, 0x85, 0x45, 0xc5, 0x25, 0xa5, 0x65, 0xe5,\n-\t0x15, 0x95, 0x55, 0xd5, 0x35, 0xb5, 0x75, 0xf5,\n-\t0x0d, 0x8d, 0x4d, 0xcd, 0x2d, 0xad, 0x6d, 0xed,\n-\t0x1d, 0x9d, 0x5d, 0xdd, 0x3d, 0xbd, 0x7d, 0xfd,\n-\t0x03, 0x83, 0x43, 0xc3, 0x23, 0xa3, 0x63, 0xe3,\n-\t0x13, 0x93, 0x53, 0xd3, 0x33, 0xb3, 0x73, 0xf3,\n-\t0x0b, 0x8b, 0x4b, 0xcb, 0x2b, 0xab, 0x6b, 0xeb,\n-\t0x1b, 0x9b, 0x5b, 0xdb, 0x3b, 0xbb, 0x7b, 0xfb,\n-\t0x07, 0x87, 0x47, 0xc7, 0x27, 0xa7, 0x67, 0xe7,\n-\t0x17, 0x97, 0x57, 0xd7, 0x37, 0xb7, 0x77, 0xf7,\n-\t0x0f, 0x8f, 0x4f, 0xcf, 0x2f, 0xaf, 0x6f, 0xef,\n-\t0x1f, 0x9f, 0x5f, 0xdf, 0x3f, 0xbf, 0x7f, 0xff,\n-}\n-\n-func reverseUint16(v uint16) uint16 {\n-\treturn uint16(reverseByte[v>>8]) | uint16(reverseByte[v&0xFF])<<8\n-}\n-\n-func reverseBits(number uint16, bitLength byte) uint16 {\n-\treturn reverseUint16(number << (16 - bitLength))\n-}"}, {"sha": "0cc44c59e0f5504303a15e5478491d6a917987ab", "filename": "libgo/go/compress/gzip/gzip.go", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcompress%2Fgzip%2Fgzip.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcompress%2Fgzip%2Fgzip.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fgzip%2Fgzip.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -222,8 +222,9 @@ func (z *Writer) Flush() error {\n \treturn z.err\n }\n \n-// Close closes the Writer, flushing any unwritten data to the underlying\n-// io.Writer, but does not close the underlying io.Writer.\n+// Close closes the Writer by flushing any unwritten data to the underlying\n+// io.Writer and writing the GZIP footer.\n+// It does not close the underlying io.Writer.\n func (z *Writer) Close() error {\n \tif z.err != nil {\n \t\treturn z.err"}, {"sha": "1be52d55e4fc41a9e31585480162dd5cfdd26d4a", "filename": "libgo/go/compress/lzw/reader.go", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcompress%2Flzw%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcompress%2Flzw%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Flzw%2Freader.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -57,8 +57,14 @@ type decoder struct {\n \t// The next two codes mean clear and EOF.\n \t// Other valid codes are in the range [lo, hi] where lo := clear + 2,\n \t// with the upper bound incrementing on each code seen.\n-\t// overflow is the code at which hi overflows the code width.\n+\t//\n+\t// overflow is the code at which hi overflows the code width. It always\n+\t// equals 1 << width.\n+\t//\n \t// last is the most recently seen code, or decoderInvalidCode.\n+\t//\n+\t// An invariant is that\n+\t// (hi < overflow) || (hi == overflow && last == decoderInvalidCode)\n \tclear, eof, hi, overflow, last uint16\n \n \t// Each code c in [lo, hi] expands to two or more bytes. For c != hi:\n@@ -163,7 +169,7 @@ loop:\n \t\t\tbreak loop\n \t\tcase code <= d.hi:\n \t\t\tc, i := code, len(d.output)-1\n-\t\t\tif code == d.hi {\n+\t\t\tif code == d.hi && d.last != decoderInvalidCode {\n \t\t\t\t// code == hi is a special case which expands to the last expansion\n \t\t\t\t// followed by the head of the last expansion. To find the head, we walk\n \t\t\t\t// the prefix chain until we find a literal code.\n@@ -196,6 +202,10 @@ loop:\n \t\tif d.hi >= d.overflow {\n \t\t\tif d.width == maxWidth {\n \t\t\t\td.last = decoderInvalidCode\n+\t\t\t\t// Undo the d.hi++ a few lines above, so that (1) we maintain\n+\t\t\t\t// the invariant that d.hi <= d.overflow, and (2) d.hi does not\n+\t\t\t\t// eventually overflow a uint16.\n+\t\t\t\td.hi--\n \t\t\t} else {\n \t\t\t\td.width++\n \t\t\t\td.overflow <<= 1"}, {"sha": "f8974de28fc955a6237fb51ac5b689356ed3b33b", "filename": "libgo/go/compress/lzw/reader_test.go", "status": "modified", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcompress%2Flzw%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcompress%2Flzw%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Flzw%2Freader_test.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -120,6 +120,103 @@ func TestReader(t *testing.T) {\n \t}\n }\n \n+type devZero struct{}\n+\n+func (devZero) Read(p []byte) (int, error) {\n+\tfor i := range p {\n+\t\tp[i] = 0\n+\t}\n+\treturn len(p), nil\n+}\n+\n+func TestHiCodeDoesNotOverflow(t *testing.T) {\n+\tr := NewReader(devZero{}, LSB, 8)\n+\td := r.(*decoder)\n+\tbuf := make([]byte, 1024)\n+\toldHi := uint16(0)\n+\tfor i := 0; i < 100; i++ {\n+\t\tif _, err := io.ReadFull(r, buf); err != nil {\n+\t\t\tt.Fatalf(\"i=%d: %v\", i, err)\n+\t\t}\n+\t\t// The hi code should never decrease.\n+\t\tif d.hi < oldHi {\n+\t\t\tt.Fatalf(\"i=%d: hi=%d decreased from previous value %d\", i, d.hi, oldHi)\n+\t\t}\n+\t\toldHi = d.hi\n+\t}\n+}\n+\n+// TestNoLongerSavingPriorExpansions tests the decoder state when codes other\n+// than clear codes continue to be seen after decoder.hi and decoder.width\n+// reach their maximum values (4095 and 12), i.e. after we no longer save prior\n+// expansions. In particular, it tests seeing the highest possible code, 4095.\n+func TestNoLongerSavingPriorExpansions(t *testing.T) {\n+\t// Iterations is used to calculate how many input bits are needed to get\n+\t// the decoder.hi and decoder.width values up to their maximum.\n+\titerations := []struct {\n+\t\twidth, n int\n+\t}{\n+\t\t// The final term is 257, not 256, as NewReader initializes d.hi to\n+\t\t// d.clear+1 and the clear code is 256.\n+\t\t{9, 512 - 257},\n+\t\t{10, 1024 - 512},\n+\t\t{11, 2048 - 1024},\n+\t\t{12, 4096 - 2048},\n+\t}\n+\tnCodes, nBits := 0, 0\n+\tfor _, e := range iterations {\n+\t\tnCodes += e.n\n+\t\tnBits += e.n * e.width\n+\t}\n+\tif nCodes != 3839 {\n+\t\tt.Fatalf(\"nCodes: got %v, want %v\", nCodes, 3839)\n+\t}\n+\tif nBits != 43255 {\n+\t\tt.Fatalf(\"nBits: got %v, want %v\", nBits, 43255)\n+\t}\n+\n+\t// Construct our input of 43255 zero bits (which gets d.hi and d.width up\n+\t// to 4095 and 12), followed by 0xfff (4095) as 12 bits, followed by 0x101\n+\t// (EOF) as 12 bits.\n+\t//\n+\t// 43255 = 5406*8 + 7, and codes are read in LSB order. The final bytes are\n+\t// therefore:\n+\t//\n+\t// xwwwwwww xxxxxxxx yyyyyxxx zyyyyyyy\n+\t// 10000000 11111111 00001111 00001000\n+\t//\n+\t// or split out:\n+\t//\n+\t// .0000000 ........ ........ ........   w = 0x000\n+\t// 1....... 11111111 .....111 ........   x = 0xfff\n+\t// ........ ........ 00001... .0001000   y = 0x101\n+\t//\n+\t// The 12 'w' bits (not all are shown) form the 3839'th code, with value\n+\t// 0x000. Just after decoder.read returns that code, d.hi == 4095 and\n+\t// d.last == 0.\n+\t//\n+\t// The 12 'x' bits form the 3840'th code, with value 0xfff or 4095. Just\n+\t// after decoder.read returns that code, d.hi == 4095 and d.last ==\n+\t// decoderInvalidCode.\n+\t//\n+\t// The 12 'y' bits form the 3841'st code, with value 0x101, the EOF code.\n+\t//\n+\t// The 'z' bit is unused.\n+\tin := make([]byte, 5406)\n+\tin = append(in, 0x80, 0xff, 0x0f, 0x08)\n+\n+\tr := NewReader(bytes.NewReader(in), LSB, 8)\n+\tnDecoded, err := io.Copy(ioutil.Discard, r)\n+\tif err != nil {\n+\t\tt.Fatalf(\"Copy: %v\", err)\n+\t}\n+\t// nDecoded should be 3841: 3839 literal codes and then 2 decoded bytes\n+\t// from 1 non-literal code. The EOF code contributes 0 decoded bytes.\n+\tif nDecoded != int64(nCodes+2) {\n+\t\tt.Fatalf(\"nDecoded: got %v, want %v\", nDecoded, nCodes+2)\n+\t}\n+}\n+\n func BenchmarkDecoder(b *testing.B) {\n \tbuf, err := ioutil.ReadFile(\"../testdata/e.txt\")\n \tif err != nil {"}, {"sha": "b2c64276c82db5eac755b9af8a0cf0f19472e762", "filename": "libgo/go/container/heap/heap.go", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcontainer%2Fheap%2Fheap.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcontainer%2Fheap%2Fheap.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcontainer%2Fheap%2Fheap.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -72,8 +72,9 @@ func Remove(h Interface, i int) interface{} {\n \tn := h.Len() - 1\n \tif n != i {\n \t\th.Swap(i, n)\n-\t\tdown(h, i, n)\n-\t\tup(h, i)\n+\t\tif !down(h, i, n) {\n+\t\t\tup(h, i)\n+\t\t}\n \t}\n \treturn h.Pop()\n }\n@@ -107,7 +108,7 @@ func down(h Interface, i0, n int) bool {\n \t\t\tbreak\n \t\t}\n \t\tj := j1 // left child\n-\t\tif j2 := j1 + 1; j2 < n && !h.Less(j1, j2) {\n+\t\tif j2 := j1 + 1; j2 < n && h.Less(j2, j1) {\n \t\t\tj = j2 // = 2*i + 2  // right child\n \t\t}\n \t\tif !h.Less(j, i) {"}, {"sha": "892ff27c6539783da3c407e1e8daab75331192a9", "filename": "libgo/go/context/context.go", "status": "modified", "additions": 27, "deletions": 13, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcontext%2Fcontext.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcontext%2Fcontext.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcontext%2Fcontext.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -96,10 +96,11 @@ type Context interface {\n \t// a Done channel for cancelation.\n \tDone() <-chan struct{}\n \n-\t// Err returns a non-nil error value after Done is closed. Err returns\n-\t// Canceled if the context was canceled or DeadlineExceeded if the\n-\t// context's deadline passed. No other values for Err are defined.\n-\t// After Done is closed, successive calls to Err return the same value.\n+\t// If Done is not yet closed, Err returns nil.\n+\t// If Done is closed, Err returns a non-nil error explaining why:\n+\t// Canceled if the context was canceled\n+\t// or DeadlineExceeded if the context's deadline passed.\n+\t// After Err returns a non-nil error, successive calls to Err return the same error.\n \tErr() error\n \n \t// Value returns the value associated with this context for key, or nil\n@@ -234,10 +235,7 @@ func WithCancel(parent Context) (ctx Context, cancel CancelFunc) {\n \n // newCancelCtx returns an initialized cancelCtx.\n func newCancelCtx(parent Context) cancelCtx {\n-\treturn cancelCtx{\n-\t\tContext: parent,\n-\t\tdone:    make(chan struct{}),\n-\t}\n+\treturn cancelCtx{Context: parent}\n }\n \n // propagateCancel arranges for child to be canceled when parent is.\n@@ -306,20 +304,32 @@ type canceler interface {\n \tDone() <-chan struct{}\n }\n \n+// closedchan is a reusable closed channel.\n+var closedchan = make(chan struct{})\n+\n+func init() {\n+\tclose(closedchan)\n+}\n+\n // A cancelCtx can be canceled. When canceled, it also cancels any children\n // that implement canceler.\n type cancelCtx struct {\n \tContext\n \n-\tdone chan struct{} // closed by the first cancel call.\n-\n-\tmu       sync.Mutex\n+\tmu       sync.Mutex            // protects following fields\n+\tdone     chan struct{}         // created lazily, closed by first cancel call\n \tchildren map[canceler]struct{} // set to nil by the first cancel call\n \terr      error                 // set to non-nil by the first cancel call\n }\n \n func (c *cancelCtx) Done() <-chan struct{} {\n-\treturn c.done\n+\tc.mu.Lock()\n+\tif c.done == nil {\n+\t\tc.done = make(chan struct{})\n+\t}\n+\td := c.done\n+\tc.mu.Unlock()\n+\treturn d\n }\n \n func (c *cancelCtx) Err() error {\n@@ -344,7 +354,11 @@ func (c *cancelCtx) cancel(removeFromParent bool, err error) {\n \t\treturn // already canceled\n \t}\n \tc.err = err\n-\tclose(c.done)\n+\tif c.done == nil {\n+\t\tc.done = closedchan\n+\t} else {\n+\t\tclose(c.done)\n+\t}\n \tfor child := range c.children {\n \t\t// NOTE: acquiring the child's lock while holding parent's lock.\n \t\tchild.cancel(false, err)"}, {"sha": "548476f290d4976a5ac373034774db831b175e0d", "filename": "libgo/go/context/context_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcontext%2Fcontext_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcontext%2Fcontext_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcontext%2Fcontext_test.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -428,7 +428,7 @@ func XTestAllocs(t testingT, testingShort func() bool, testingAllocsPerRun func(\n \t\tlimit := test.limit\n \t\tif runtime.Compiler == \"gccgo\" {\n \t\t\t// gccgo does not yet do escape analysis.\n-\t\t\t// TOOD(iant): Remove this when gccgo does do escape analysis.\n+\t\t\t// TODO(iant): Remove this when gccgo does do escape analysis.\n \t\t\tlimit = test.gccgoLimit\n \t\t}\n \t\tnumRuns := 100"}, {"sha": "98169bf5fd757a723f4d6a2bd0f7f4bd4c511f6f", "filename": "libgo/go/crypto/aes/cipher_generic.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcrypto%2Faes%2Fcipher_generic.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcrypto%2Faes%2Fcipher_generic.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Faes%2Fcipher_generic.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// -build !amd64,!s390x\n+// -build !amd64,!s390x,!ppc64le\n \n package aes\n "}, {"sha": "1d16fe03f0409edb0f555ebfae5559d8f1b0d48c", "filename": "libgo/go/crypto/aes/cipher_ppc64le.go", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcrypto%2Faes%2Fcipher_ppc64le.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcrypto%2Faes%2Fcipher_ppc64le.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Faes%2Fcipher_ppc64le.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -0,0 +1,82 @@\n+// Copyright 2016 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build ignore\n+\n+package aes\n+\n+import (\n+\t\"crypto/cipher\"\n+)\n+\n+// defined in asm_ppc64le.s\n+\n+//go:noescape\n+\n+func setEncryptKeyAsm(key *byte, keylen int, enc *uint32) int\n+\n+//go:noescape\n+\n+func setDecryptKeyAsm(key *byte, keylen int, dec *uint32) int\n+\n+//go:noescape\n+\n+func doEncryptKeyAsm(key *byte, keylen int, dec *uint32) int\n+\n+//go:noescape\n+\n+func encryptBlockAsm(dst, src *byte, enc *uint32)\n+\n+//go:noescape\n+\n+func decryptBlockAsm(dst, src *byte, dec *uint32)\n+\n+type aesCipherAsm struct {\n+\taesCipher\n+}\n+\n+func newCipher(key []byte) (cipher.Block, error) {\n+\tn := 64 // size is fixed for all and round value is stored inside it too\n+\tc := aesCipherAsm{aesCipher{make([]uint32, n), make([]uint32, n)}}\n+\tk := len(key)\n+\n+\tret := 0\n+\tret += setEncryptKeyAsm(&key[0], k*8, &c.enc[0])\n+\tret += setDecryptKeyAsm(&key[0], k*8, &c.dec[0])\n+\n+\tif ret > 0 {\n+\t\treturn nil, KeySizeError(k)\n+\t}\n+\n+\treturn &c, nil\n+}\n+\n+func (c *aesCipherAsm) BlockSize() int { return BlockSize }\n+\n+func (c *aesCipherAsm) Encrypt(dst, src []byte) {\n+\tif len(src) < BlockSize {\n+\t\tpanic(\"crypto/aes: input not full block\")\n+\t}\n+\tif len(dst) < BlockSize {\n+\t\tpanic(\"crypto/aes: output not full block\")\n+\t}\n+\tencryptBlockAsm(&dst[0], &src[0], &c.enc[0])\n+}\n+\n+func (c *aesCipherAsm) Decrypt(dst, src []byte) {\n+\tif len(src) < BlockSize {\n+\t\tpanic(\"crypto/aes: input not full block\")\n+\t}\n+\tif len(dst) < BlockSize {\n+\t\tpanic(\"crypto/aes: output not full block\")\n+\t}\n+\tdecryptBlockAsm(&dst[0], &src[0], &c.dec[0])\n+}\n+\n+// expandKey is used by BenchmarkExpand to ensure that the asm implementation\n+// of key expansion is used for the benchmark when it is available.\n+func expandKey(key []byte, enc, dec []uint32) {\n+\tsetEncryptKeyAsm(&key[0], len(key)*8, &enc[0])\n+\tsetDecryptKeyAsm(&key[0], len(key)*8, &dec[0])\n+}"}, {"sha": "b4d6cdcab4e9b29144a06864172dc8ebc0f7242b", "filename": "libgo/go/crypto/crypto.go", "status": "modified", "additions": 38, "deletions": 30, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcrypto%2Fcrypto.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcrypto%2Fcrypto.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fcrypto.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -21,40 +21,48 @@ func (h Hash) HashFunc() Hash {\n }\n \n const (\n-\tMD4        Hash = 1 + iota // import golang.org/x/crypto/md4\n-\tMD5                        // import crypto/md5\n-\tSHA1                       // import crypto/sha1\n-\tSHA224                     // import crypto/sha256\n-\tSHA256                     // import crypto/sha256\n-\tSHA384                     // import crypto/sha512\n-\tSHA512                     // import crypto/sha512\n-\tMD5SHA1                    // no implementation; MD5+SHA1 used for TLS RSA\n-\tRIPEMD160                  // import golang.org/x/crypto/ripemd160\n-\tSHA3_224                   // import golang.org/x/crypto/sha3\n-\tSHA3_256                   // import golang.org/x/crypto/sha3\n-\tSHA3_384                   // import golang.org/x/crypto/sha3\n-\tSHA3_512                   // import golang.org/x/crypto/sha3\n-\tSHA512_224                 // import crypto/sha512\n-\tSHA512_256                 // import crypto/sha512\n+\tMD4         Hash = 1 + iota // import golang.org/x/crypto/md4\n+\tMD5                         // import crypto/md5\n+\tSHA1                        // import crypto/sha1\n+\tSHA224                      // import crypto/sha256\n+\tSHA256                      // import crypto/sha256\n+\tSHA384                      // import crypto/sha512\n+\tSHA512                      // import crypto/sha512\n+\tMD5SHA1                     // no implementation; MD5+SHA1 used for TLS RSA\n+\tRIPEMD160                   // import golang.org/x/crypto/ripemd160\n+\tSHA3_224                    // import golang.org/x/crypto/sha3\n+\tSHA3_256                    // import golang.org/x/crypto/sha3\n+\tSHA3_384                    // import golang.org/x/crypto/sha3\n+\tSHA3_512                    // import golang.org/x/crypto/sha3\n+\tSHA512_224                  // import crypto/sha512\n+\tSHA512_256                  // import crypto/sha512\n+\tBLAKE2s_256                 // import golang.org/x/crypto/blake2s\n+\tBLAKE2b_256                 // import golang.org/x/crypto/blake2b\n+\tBLAKE2b_384                 // import golang.org/x/crypto/blake2b\n+\tBLAKE2b_512                 // import golang.org/x/crypto/blake2b\n \tmaxHash\n )\n \n var digestSizes = []uint8{\n-\tMD4:        16,\n-\tMD5:        16,\n-\tSHA1:       20,\n-\tSHA224:     28,\n-\tSHA256:     32,\n-\tSHA384:     48,\n-\tSHA512:     64,\n-\tSHA512_224: 28,\n-\tSHA512_256: 32,\n-\tSHA3_224:   28,\n-\tSHA3_256:   32,\n-\tSHA3_384:   48,\n-\tSHA3_512:   64,\n-\tMD5SHA1:    36,\n-\tRIPEMD160:  20,\n+\tMD4:         16,\n+\tMD5:         16,\n+\tSHA1:        20,\n+\tSHA224:      28,\n+\tSHA256:      32,\n+\tSHA384:      48,\n+\tSHA512:      64,\n+\tSHA512_224:  28,\n+\tSHA512_256:  32,\n+\tSHA3_224:    28,\n+\tSHA3_256:    32,\n+\tSHA3_384:    48,\n+\tSHA3_512:    64,\n+\tMD5SHA1:     36,\n+\tRIPEMD160:   20,\n+\tBLAKE2s_256: 32,\n+\tBLAKE2b_256: 32,\n+\tBLAKE2b_384: 48,\n+\tBLAKE2b_512: 64,\n }\n \n // Size returns the length, in bytes, of a digest resulting from the given hash"}, {"sha": "21e6d4e82f6b2cc8cea0b0e8da2ea4d2679ecb19", "filename": "libgo/go/crypto/des/block.go", "status": "modified", "additions": 73, "deletions": 41, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcrypto%2Fdes%2Fblock.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcrypto%2Fdes%2Fblock.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fdes%2Fblock.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -4,25 +4,29 @@\n \n package des\n \n-import (\n-\t\"encoding/binary\"\n-)\n+import \"encoding/binary\"\n \n func cryptBlock(subkeys []uint64, dst, src []byte, decrypt bool) {\n \tb := binary.BigEndian.Uint64(src)\n \tb = permuteInitialBlock(b)\n \tleft, right := uint32(b>>32), uint32(b)\n \n-\tvar subkey uint64\n-\tfor i := 0; i < 16; i++ {\n-\t\tif decrypt {\n-\t\t\tsubkey = subkeys[15-i]\n-\t\t} else {\n-\t\t\tsubkey = subkeys[i]\n-\t\t}\n+\tleft = (left << 1) | (left >> 31)\n+\tright = (right << 1) | (right >> 31)\n \n-\t\tleft, right = right, left^feistel(right, subkey)\n+\tif decrypt {\n+\t\tfor i := 0; i < 8; i++ {\n+\t\t\tleft, right = feistel(left, right, subkeys[15-2*i], subkeys[15-(2*i+1)])\n+\t\t}\n+\t} else {\n+\t\tfor i := 0; i < 8; i++ {\n+\t\t\tleft, right = feistel(left, right, subkeys[2*i], subkeys[2*i+1])\n+\t\t}\n \t}\n+\n+\tleft = (left << 31) | (left >> 1)\n+\tright = (right << 31) | (right >> 1)\n+\n \t// switch left & right and perform final permutation\n \tpreOutput := (uint64(right) << 32) | uint64(left)\n \tbinary.BigEndian.PutUint64(dst, permuteFinalBlock(preOutput))\n@@ -39,19 +43,34 @@ func decryptBlock(subkeys []uint64, dst, src []byte) {\n }\n \n // DES Feistel function\n-func feistel(right uint32, key uint64) (result uint32) {\n-\tsBoxLocations := key ^ expandBlock(right)\n-\tvar sBoxResult uint32\n-\tfor i := uint8(0); i < 8; i++ {\n-\t\tsBoxLocation := uint8(sBoxLocations>>42) & 0x3f\n-\t\tsBoxLocations <<= 6\n-\t\t// row determined by 1st and 6th bit\n-\t\t// column is middle four bits\n-\t\trow := (sBoxLocation & 0x1) | ((sBoxLocation & 0x20) >> 4)\n-\t\tcolumn := (sBoxLocation >> 1) & 0xf\n-\t\tsBoxResult ^= feistelBox[i][16*row+column]\n-\t}\n-\treturn sBoxResult\n+func feistel(l, r uint32, k0, k1 uint64) (lout, rout uint32) {\n+\tvar t uint32\n+\n+\tt = r ^ uint32(k0>>32)\n+\tl ^= feistelBox[7][t&0x3f] ^\n+\t\tfeistelBox[5][(t>>8)&0x3f] ^\n+\t\tfeistelBox[3][(t>>16)&0x3f] ^\n+\t\tfeistelBox[1][(t>>24)&0x3f]\n+\n+\tt = ((r << 28) | (r >> 4)) ^ uint32(k0)\n+\tl ^= feistelBox[6][(t)&0x3f] ^\n+\t\tfeistelBox[4][(t>>8)&0x3f] ^\n+\t\tfeistelBox[2][(t>>16)&0x3f] ^\n+\t\tfeistelBox[0][(t>>24)&0x3f]\n+\n+\tt = l ^ uint32(k1>>32)\n+\tr ^= feistelBox[7][t&0x3f] ^\n+\t\tfeistelBox[5][(t>>8)&0x3f] ^\n+\t\tfeistelBox[3][(t>>16)&0x3f] ^\n+\t\tfeistelBox[1][(t>>24)&0x3f]\n+\n+\tt = ((l << 28) | (l >> 4)) ^ uint32(k1)\n+\tr ^= feistelBox[6][(t)&0x3f] ^\n+\t\tfeistelBox[4][(t>>8)&0x3f] ^\n+\t\tfeistelBox[2][(t>>16)&0x3f] ^\n+\t\tfeistelBox[0][(t>>24)&0x3f]\n+\n+\treturn l, r\n }\n \n // feistelBox[s][16*i+j] contains the output of permutationFunction\n@@ -73,27 +92,22 @@ func init() {\n \t\t\tfor j := 0; j < 16; j++ {\n \t\t\t\tf := uint64(sBoxes[s][i][j]) << (4 * (7 - uint(s)))\n \t\t\t\tf = permuteBlock(f, permutationFunction[:])\n-\t\t\t\tfeistelBox[s][16*i+j] = uint32(f)\n+\n+\t\t\t\t// Row is determined by the 1st and 6th bit.\n+\t\t\t\t// Column is the middle four bits.\n+\t\t\t\trow := uint8(((i & 2) << 4) | i&1)\n+\t\t\t\tcol := uint8(j << 1)\n+\t\t\t\tt := row | col\n+\n+\t\t\t\t// The rotation was performed in the feistel rounds, being factored out and now mixed into the feistelBox.\n+\t\t\t\tf = (f << 1) | (f >> 31)\n+\n+\t\t\t\tfeistelBox[s][t] = uint32(f)\n \t\t\t}\n \t\t}\n \t}\n }\n \n-// expandBlock expands an input block of 32 bits,\n-// producing an output block of 48 bits.\n-func expandBlock(src uint32) (block uint64) {\n-\t// rotate the 5 highest bits to the right.\n-\tsrc = (src << 5) | (src >> 27)\n-\tfor i := 0; i < 8; i++ {\n-\t\tblock <<= 6\n-\t\t// take the 6 bits on the right\n-\t\tblock |= uint64(src) & (1<<6 - 1)\n-\t\t// advance by 4 bits.\n-\t\tsrc = (src << 4) | (src >> 28)\n-\t}\n-\treturn\n-}\n-\n // permuteInitialBlock is equivalent to the permutation defined\n // by initialPermutation.\n func permuteInitialBlock(block uint64) uint64 {\n@@ -218,6 +232,24 @@ func (c *desCipher) generateSubkeys(keyBytes []byte) {\n \t\t// combine halves to form 56-bit input to PC2\n \t\tpc2Input := uint64(leftRotations[i])<<28 | uint64(rightRotations[i])\n \t\t// apply PC2 permutation to 7 byte input\n-\t\tc.subkeys[i] = permuteBlock(pc2Input, permutedChoice2[:])\n+\t\tc.subkeys[i] = unpack(permuteBlock(pc2Input, permutedChoice2[:]))\n \t}\n }\n+\n+// Expand 48-bit input to 64-bit, with each 6-bit block padded by extra two bits at the top.\n+// By doing so, we can have the input blocks (four bits each), and the key blocks (six bits each) well-aligned without\n+// extra shifts/rotations for alignments.\n+func unpack(x uint64) uint64 {\n+\tvar result uint64\n+\n+\tresult = ((x>>(6*1))&0xff)<<(8*0) |\n+\t\t((x>>(6*3))&0xff)<<(8*1) |\n+\t\t((x>>(6*5))&0xff)<<(8*2) |\n+\t\t((x>>(6*7))&0xff)<<(8*3) |\n+\t\t((x>>(6*0))&0xff)<<(8*4) |\n+\t\t((x>>(6*2))&0xff)<<(8*5) |\n+\t\t((x>>(6*4))&0xff)<<(8*6) |\n+\t\t((x>>(6*6))&0xff)<<(8*7)\n+\n+\treturn result\n+}"}, {"sha": "46af5b0f022c8816781d4ab9c582f28f4cc36667", "filename": "libgo/go/crypto/des/cipher.go", "status": "modified", "additions": 45, "deletions": 6, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcrypto%2Fdes%2Fcipher.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcrypto%2Fdes%2Fcipher.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fdes%2Fcipher.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -6,6 +6,7 @@ package des\n \n import (\n \t\"crypto/cipher\"\n+\t\"encoding/binary\"\n \t\"strconv\"\n )\n \n@@ -61,13 +62,51 @@ func NewTripleDESCipher(key []byte) (cipher.Block, error) {\n func (c *tripleDESCipher) BlockSize() int { return BlockSize }\n \n func (c *tripleDESCipher) Encrypt(dst, src []byte) {\n-\tc.cipher1.Encrypt(dst, src)\n-\tc.cipher2.Decrypt(dst, dst)\n-\tc.cipher3.Encrypt(dst, dst)\n+\tb := binary.BigEndian.Uint64(src)\n+\tb = permuteInitialBlock(b)\n+\tleft, right := uint32(b>>32), uint32(b)\n+\n+\tleft = (left << 1) | (left >> 31)\n+\tright = (right << 1) | (right >> 31)\n+\n+\tfor i := 0; i < 8; i++ {\n+\t\tleft, right = feistel(left, right, c.cipher1.subkeys[2*i], c.cipher1.subkeys[2*i+1])\n+\t}\n+\tfor i := 0; i < 8; i++ {\n+\t\tright, left = feistel(right, left, c.cipher2.subkeys[15-2*i], c.cipher2.subkeys[15-(2*i+1)])\n+\t}\n+\tfor i := 0; i < 8; i++ {\n+\t\tleft, right = feistel(left, right, c.cipher3.subkeys[2*i], c.cipher3.subkeys[2*i+1])\n+\t}\n+\n+\tleft = (left << 31) | (left >> 1)\n+\tright = (right << 31) | (right >> 1)\n+\n+\tpreOutput := (uint64(right) << 32) | uint64(left)\n+\tbinary.BigEndian.PutUint64(dst, permuteFinalBlock(preOutput))\n }\n \n func (c *tripleDESCipher) Decrypt(dst, src []byte) {\n-\tc.cipher3.Decrypt(dst, src)\n-\tc.cipher2.Encrypt(dst, dst)\n-\tc.cipher1.Decrypt(dst, dst)\n+\tb := binary.BigEndian.Uint64(src)\n+\tb = permuteInitialBlock(b)\n+\tleft, right := uint32(b>>32), uint32(b)\n+\n+\tleft = (left << 1) | (left >> 31)\n+\tright = (right << 1) | (right >> 31)\n+\n+\tfor i := 0; i < 8; i++ {\n+\t\tleft, right = feistel(left, right, c.cipher3.subkeys[15-2*i], c.cipher3.subkeys[15-(2*i+1)])\n+\t}\n+\tfor i := 0; i < 8; i++ {\n+\t\tright, left = feistel(right, left, c.cipher2.subkeys[2*i], c.cipher2.subkeys[2*i+1])\n+\t}\n+\tfor i := 0; i < 8; i++ {\n+\t\tleft, right = feistel(left, right, c.cipher1.subkeys[15-2*i], c.cipher1.subkeys[15-(2*i+1)])\n+\t}\n+\n+\tleft = (left << 31) | (left >> 1)\n+\tright = (right << 31) | (right >> 1)\n+\n+\tpreOutput := (uint64(right) << 32) | uint64(left)\n+\tbinary.BigEndian.PutUint64(dst, permuteFinalBlock(preOutput))\n }"}, {"sha": "a20879d57412da256a0bc737a484ba7488ee498a", "filename": "libgo/go/crypto/des/const.go", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcrypto%2Fdes%2Fconst.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcrypto%2Fdes%2Fconst.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fdes%2Fconst.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -5,6 +5,9 @@\n // Package des implements the Data Encryption Standard (DES) and the\n // Triple Data Encryption Algorithm (TDEA) as defined\n // in U.S. Federal Information Processing Standards Publication 46-3.\n+//\n+// DES is cryptographically broken and should not be used for secure\n+// applications.\n package des\n \n // Used to perform an initial permutation of a 64-bit input block."}, {"sha": "690a49f5efb05a6e8aa065369e8958b2bf0d92a0", "filename": "libgo/go/crypto/des/des_test.go", "status": "modified", "additions": 28, "deletions": 11, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcrypto%2Fdes%2Fdes_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcrypto%2Fdes%2Fdes_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fdes%2Fdes_test.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -1526,17 +1526,6 @@ func TestFinalPermute(t *testing.T) {\n \t}\n }\n \n-func TestExpandBlock(t *testing.T) {\n-\tfor i := uint(0); i < 32; i++ {\n-\t\tbit := uint32(1) << i\n-\t\tgot := expandBlock(bit)\n-\t\twant := permuteBlock(uint64(bit), expansionFunction[:])\n-\t\tif got != want {\n-\t\t\tt.Errorf(\"expand(%x) = %x, want %x\", bit, got, want)\n-\t\t}\n-\t}\n-}\n-\n func BenchmarkEncrypt(b *testing.B) {\n \ttt := encryptDESTests[0]\n \tc, err := NewCipher(tt.key)\n@@ -1564,3 +1553,31 @@ func BenchmarkDecrypt(b *testing.B) {\n \t\tc.Decrypt(out, tt.out)\n \t}\n }\n+\n+func BenchmarkTDESEncrypt(b *testing.B) {\n+\ttt := encryptTripleDESTests[0]\n+\tc, err := NewTripleDESCipher(tt.key)\n+\tif err != nil {\n+\t\tb.Fatal(\"NewCipher:\", err)\n+\t}\n+\tout := make([]byte, len(tt.in))\n+\tb.SetBytes(int64(len(out)))\n+\tb.ResetTimer()\n+\tfor i := 0; i < b.N; i++ {\n+\t\tc.Encrypt(out, tt.in)\n+\t}\n+}\n+\n+func BenchmarkTDESDecrypt(b *testing.B) {\n+\ttt := encryptTripleDESTests[0]\n+\tc, err := NewTripleDESCipher(tt.key)\n+\tif err != nil {\n+\t\tb.Fatal(\"NewCipher:\", err)\n+\t}\n+\tout := make([]byte, len(tt.out))\n+\tb.SetBytes(int64(len(out)))\n+\tb.ResetTimer()\n+\tfor i := 0; i < b.N; i++ {\n+\t\tc.Decrypt(out, tt.out)\n+\t}\n+}"}, {"sha": "7fc246bc2bdf84306743fb8bab85e942b9c08893", "filename": "libgo/go/crypto/dsa/dsa_test.go", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcrypto%2Fdsa%2Fdsa_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcrypto%2Fdsa%2Fdsa_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fdsa%2Fdsa_test.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -82,12 +82,17 @@ func fromHex(s string) *big.Int {\n }\n \n func TestSignAndVerify(t *testing.T) {\n-\tvar priv PrivateKey\n-\tpriv.P, _ = new(big.Int).SetString(\"A9B5B793FB4785793D246BAE77E8FF63CA52F442DA763C440259919FE1BC1D6065A9350637A04F75A2F039401D49F08E066C4D275A5A65DA5684BC563C14289D7AB8A67163BFBF79D85972619AD2CFF55AB0EE77A9002B0EF96293BDD0F42685EBB2C66C327079F6C98000FBCB79AACDE1BC6F9D5C7B1A97E3D9D54ED7951FEF\", 16)\n-\tpriv.Q, _ = new(big.Int).SetString(\"E1D3391245933D68A0714ED34BBCB7A1F422B9C1\", 16)\n-\tpriv.G, _ = new(big.Int).SetString(\"634364FC25248933D01D1993ECABD0657CC0CB2CEED7ED2E3E8AECDFCDC4A25C3B15E9E3B163ACA2984B5539181F3EFF1A5E8903D71D5B95DA4F27202B77D2C44B430BB53741A8D59A8F86887525C9F2A6A5980A195EAA7F2FF910064301DEF89D3AA213E1FAC7768D89365318E370AF54A112EFBA9246D9158386BA1B4EEFDA\", 16)\n-\tpriv.Y, _ = new(big.Int).SetString(\"32969E5780CFE1C849A1C276D7AEB4F38A23B591739AA2FE197349AEEBD31366AEE5EB7E6C6DDB7C57D02432B30DB5AA66D9884299FAA72568944E4EEDC92EA3FBC6F39F53412FBCC563208F7C15B737AC8910DBC2D9C9B8C001E72FDC40EB694AB1F06A5A2DBD18D9E36C66F31F566742F11EC0A52E9F7B89355C02FB5D32D2\", 16)\n-\tpriv.X, _ = new(big.Int).SetString(\"5078D4D29795CBE76D3AACFE48C9AF0BCDBEE91A\", 16)\n+\tpriv := PrivateKey{\n+\t\tPublicKey: PublicKey{\n+\t\t\tParameters: Parameters{\n+\t\t\t\tP: fromHex(\"A9B5B793FB4785793D246BAE77E8FF63CA52F442DA763C440259919FE1BC1D6065A9350637A04F75A2F039401D49F08E066C4D275A5A65DA5684BC563C14289D7AB8A67163BFBF79D85972619AD2CFF55AB0EE77A9002B0EF96293BDD0F42685EBB2C66C327079F6C98000FBCB79AACDE1BC6F9D5C7B1A97E3D9D54ED7951FEF\"),\n+\t\t\t\tQ: fromHex(\"E1D3391245933D68A0714ED34BBCB7A1F422B9C1\"),\n+\t\t\t\tG: fromHex(\"634364FC25248933D01D1993ECABD0657CC0CB2CEED7ED2E3E8AECDFCDC4A25C3B15E9E3B163ACA2984B5539181F3EFF1A5E8903D71D5B95DA4F27202B77D2C44B430BB53741A8D59A8F86887525C9F2A6A5980A195EAA7F2FF910064301DEF89D3AA213E1FAC7768D89365318E370AF54A112EFBA9246D9158386BA1B4EEFDA\"),\n+\t\t\t},\n+\t\t\tY: fromHex(\"32969E5780CFE1C849A1C276D7AEB4F38A23B591739AA2FE197349AEEBD31366AEE5EB7E6C6DDB7C57D02432B30DB5AA66D9884299FAA72568944E4EEDC92EA3FBC6F39F53412FBCC563208F7C15B737AC8910DBC2D9C9B8C001E72FDC40EB694AB1F06A5A2DBD18D9E36C66F31F566742F11EC0A52E9F7B89355C02FB5D32D2\"),\n+\t\t},\n+\t\tX: fromHex(\"5078D4D29795CBE76D3AACFE48C9AF0BCDBEE91A\"),\n+\t}\n \n \ttestSignAndVerify(t, 0, &priv)\n }"}, {"sha": "b682f008942fbadac7acaf06a31530fd0b6542f9", "filename": "libgo/go/crypto/md5/md5.go", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcrypto%2Fmd5%2Fmd5.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcrypto%2Fmd5%2Fmd5.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fmd5%2Fmd5.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -5,6 +5,9 @@\n //go:generate go run gen.go -full -output md5block.go\n \n // Package md5 implements the MD5 hash algorithm as defined in RFC 1321.\n+//\n+// MD5 is cryptographically broken and should not be used for secure\n+// applications.\n package md5\n \n import ("}, {"sha": "8a4c757236387934ad520a12a3bbce366734faee", "filename": "libgo/go/crypto/rand/rand_linux.go", "status": "modified", "additions": 7, "deletions": 21, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcrypto%2Frand%2Frand_linux.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcrypto%2Frand%2Frand_linux.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frand%2Frand_linux.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -6,34 +6,20 @@ package rand\n \n import (\n \t\"internal/syscall/unix\"\n-\t\"sync\"\n )\n \n func init() {\n \taltGetRandom = getRandomLinux\n }\n \n-var (\n-\tonce       sync.Once\n-\tuseSyscall bool\n-)\n-\n-func pickStrategy() {\n-\t// Test whether we should use the system call or /dev/urandom.\n-\t// We'll fall back to urandom if:\n-\t// - the kernel is too old (before 3.17)\n-\t// - the machine has no entropy available (early boot + no hardware\n-\t//   entropy source?) and we want to avoid blocking later.\n-\tvar buf [1]byte\n-\tn, err := unix.GetRandom(buf[:], unix.GRND_NONBLOCK)\n-\tuseSyscall = n == 1 && err == nil\n-}\n-\n+// If the kernel is too old (before 3.17) to support the getrandom syscall(),\n+// unix.GetRandom will immediately return ENOSYS and we will then fall back to\n+// reading from /dev/urandom in rand_unix.go. unix.GetRandom caches the ENOSYS\n+// result so we only suffer the syscall overhead once in this case.\n+// If the kernel supports the getrandom() syscall, unix.GetRandom will block\n+// until the kernel has sufficient randomness (as we don't use GRND_NONBLOCK).\n+// In this case, unix.GetRandom will not return an error.\n func getRandomLinux(p []byte) (ok bool) {\n-\tonce.Do(pickStrategy)\n-\tif !useSyscall {\n-\t\treturn false\n-\t}\n \tn, err := unix.GetRandom(p, 0)\n \treturn n == len(p) && err == nil\n }"}, {"sha": "4dd171120341f13b5aa7517a04de453011441104", "filename": "libgo/go/crypto/rand/util.go", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcrypto%2Frand%2Futil.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcrypto%2Frand%2Futil.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frand%2Futil.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -107,16 +107,23 @@ func Int(rand io.Reader, max *big.Int) (n *big.Int, err error) {\n \tif max.Sign() <= 0 {\n \t\tpanic(\"crypto/rand: argument to Int is <= 0\")\n \t}\n-\tk := (max.BitLen() + 7) / 8\n-\n-\t// b is the number of bits in the most significant byte of max.\n-\tb := uint(max.BitLen() % 8)\n+\tn = new(big.Int)\n+\tn.Sub(max, n.SetUint64(1))\n+\t// bitLen is the maximum bit length needed to encode a value < max.\n+\tbitLen := n.BitLen()\n+\tif bitLen == 0 {\n+\t\t// the only valid result is 0\n+\t\treturn\n+\t}\n+\t// k is the maximum byte length needed to encode a value < max.\n+\tk := (bitLen + 7) / 8\n+\t// b is the number of bits in the most significant byte of max-1.\n+\tb := uint(bitLen % 8)\n \tif b == 0 {\n \t\tb = 8\n \t}\n \n \tbytes := make([]byte, k)\n-\tn = new(big.Int)\n \n \tfor {\n \t\t_, err = io.ReadFull(rand, bytes)"}, {"sha": "685624e1b3dfbea04abfe46291dd8f294a63b6ba", "filename": "libgo/go/crypto/rand/util_test.go", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcrypto%2Frand%2Futil_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcrypto%2Frand%2Futil_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frand%2Futil_test.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -5,7 +5,10 @@\n package rand_test\n \n import (\n+\t\"bytes\"\n \t\"crypto/rand\"\n+\t\"fmt\"\n+\t\"io\"\n \t\"math/big\"\n \tmathrand \"math/rand\"\n \t\"testing\"\n@@ -45,6 +48,56 @@ func TestInt(t *testing.T) {\n \t}\n }\n \n+type countingReader struct {\n+\tr io.Reader\n+\tn int\n+}\n+\n+func (r *countingReader) Read(p []byte) (n int, err error) {\n+\tn, err = r.r.Read(p)\n+\tr.n += n\n+\treturn n, err\n+}\n+\n+// Test that Int reads only the necessary number of bytes from the reader for\n+// max at each bit length\n+func TestIntReads(t *testing.T) {\n+\tfor i := 0; i < 32; i++ {\n+\t\tmax := int64(1 << uint64(i))\n+\t\tt.Run(fmt.Sprintf(\"max=%d\", max), func(t *testing.T) {\n+\t\t\treader := &countingReader{r: rand.Reader}\n+\n+\t\t\t_, err := rand.Int(reader, big.NewInt(max))\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatalf(\"Can't generate random value: %d, %v\", max, err)\n+\t\t\t}\n+\t\t\texpected := (i + 7) / 8\n+\t\t\tif reader.n != expected {\n+\t\t\t\tt.Errorf(\"Int(reader, %d) should read %d bytes, but it read: %d\", max, expected, reader.n)\n+\t\t\t}\n+\t\t})\n+\t}\n+}\n+\n+// Test that Int does not mask out valid return values\n+func TestIntMask(t *testing.T) {\n+\tfor max := 1; max <= 256; max++ {\n+\t\tt.Run(fmt.Sprintf(\"max=%d\", max), func(t *testing.T) {\n+\t\t\tfor i := 0; i < max; i++ {\n+\t\t\t\tvar b bytes.Buffer\n+\t\t\t\tb.WriteByte(byte(i))\n+\t\t\t\tn, err := rand.Int(&b, big.NewInt(int64(max)))\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tt.Fatalf(\"Can't generate random value: %d, %v\", max, err)\n+\t\t\t\t}\n+\t\t\t\tif n.Int64() != int64(i) {\n+\t\t\t\t\tt.Errorf(\"Int(reader, %d) should have returned value of %d, but it returned: %v\", max, i, n)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t})\n+\t}\n+}\n+\n func testIntPanics(t *testing.T, b *big.Int) {\n \tdefer func() {\n \t\tif err := recover(); err == nil {"}, {"sha": "772af0e7e0d4fdc5b9d38e18f04687dc38d3dcef", "filename": "libgo/go/crypto/rc4/rc4.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcrypto%2Frc4%2Frc4.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcrypto%2Frc4%2Frc4.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frc4%2Frc4.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -4,11 +4,11 @@\n \n // Package rc4 implements RC4 encryption, as defined in Bruce Schneier's\n // Applied Cryptography.\n+//\n+// RC4 is cryptographically broken and should not be used for secure\n+// applications.\n package rc4\n \n-// BUG(agl): RC4 is in common use but has design weaknesses that make\n-// it a poor choice for new protocols.\n-\n import \"strconv\"\n \n // A Cipher is an instance of RC4 using a particular key."}, {"sha": "6b1721470b20268431b3f3bd45a282aa5a195a5f", "filename": "libgo/go/crypto/sha1/sha1.go", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -2,7 +2,10 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// Package sha1 implements the SHA1 hash algorithm as defined in RFC 3174.\n+// Package sha1 implements the SHA-1 hash algorithm as defined in RFC 3174.\n+//\n+// SHA-1 is cryptographically broken and should not be used for secure\n+// applications.\n package sha1\n \n import (\n@@ -14,10 +17,10 @@ func init() {\n \tcrypto.RegisterHash(crypto.SHA1, New)\n }\n \n-// The size of a SHA1 checksum in bytes.\n+// The size of a SHA-1 checksum in bytes.\n const Size = 20\n \n-// The blocksize of SHA1 in bytes.\n+// The blocksize of SHA-1 in bytes.\n const BlockSize = 64\n \n const (\n@@ -189,7 +192,7 @@ func (d *digest) constSum() [Size]byte {\n \treturn digest\n }\n \n-// Sum returns the SHA1 checksum of the data.\n+// Sum returns the SHA-1 checksum of the data.\n func Sum(data []byte) [Size]byte {\n \tvar d digest\n \td.Reset()"}, {"sha": "faa9916bc06e9df9f9dcbe71e2bee1c38a13d15a", "filename": "libgo/go/crypto/sha1/sha1_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1_test.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// SHA1 hash algorithm. See RFC 3174.\n+// SHA-1 hash algorithm. See RFC 3174.\n \n package sha1\n "}, {"sha": "1d37544940f120485a636ce72204e0c1d3ae1261", "filename": "libgo/go/crypto/sha1/sha1block.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1block.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1block.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1block.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -11,7 +11,7 @@ const (\n \t_K3 = 0xCA62C1D6\n )\n \n-// blockGeneric is a portable, pure Go version of the SHA1 block step.\n+// blockGeneric is a portable, pure Go version of the SHA-1 block step.\n // It's used by sha1block_generic.go and tests.\n func blockGeneric(dig *digest, p []byte) {\n \tvar w [16]uint32"}, {"sha": "2d7a314d51da3f570535acdcfe35862f0b57c66a", "filename": "libgo/go/crypto/sha1/sha1block_amd64.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1block_amd64.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1block_amd64.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1block_amd64.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -6,18 +6,18 @@\n \n package sha1\n \n-//go:noescape\n+import \"internal/cpu\"\n \n+//go:noescape\n func blockAVX2(dig *digest, p []byte)\n \n //go:noescape\n func blockAMD64(dig *digest, p []byte)\n-func checkAVX2() bool\n \n-var hasAVX2 = checkAVX2()\n+var useAVX2 = cpu.X86.HasAVX2 && cpu.X86.HasBMI1 && cpu.X86.HasBMI2\n \n func block(dig *digest, p []byte) {\n-\tif hasAVX2 && len(p) >= 256 {\n+\tif useAVX2 && len(p) >= 256 {\n \t\t// blockAVX2 calculates sha1 for 2 block per iteration\n \t\t// it also interleaves precalculation for next block.\n \t\t// So it may read up-to 192 bytes past end of p"}, {"sha": "55a23599a97a9008d0641cde1ca5632496bca12d", "filename": "libgo/go/crypto/sha1/sha1block_s390x.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1block_s390x.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1block_s390x.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha1%2Fsha1block_s390x.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -7,7 +7,7 @@\n package sha1\n \n // featureCheck reports whether the CPU supports the\n-// SHA1 compute intermediate message digest (KIMD)\n+// SHA-1 compute intermediate message digest (KIMD)\n // function code.\n func featureCheck() bool\n "}, {"sha": "b311a125c982c7a4cef08b7ec510dcce069ef32a", "filename": "libgo/go/crypto/sha256/sha256block_amd64.go", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcrypto%2Fsha256%2Fsha256block_amd64.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcrypto%2Fsha256%2Fsha256block_amd64.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha256%2Fsha256block_amd64.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2017 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build ignore\n+\n+package sha256\n+\n+import \"internal/cpu\"\n+\n+var useAVX2 = cpu.X86.HasAVX2 && cpu.X86.HasBMI2"}, {"sha": "0ce599b8ebcb4f43fce9a5ed8144c926896c7e51", "filename": "libgo/go/crypto/sha512/sha512block_amd64.go", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcrypto%2Fsha512%2Fsha512block_amd64.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcrypto%2Fsha512%2Fsha512block_amd64.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha512%2Fsha512block_amd64.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2013 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build ignore\n+// +build amd64\n+\n+package sha512\n+\n+import \"internal/cpu\"\n+\n+//go:noescape\n+func blockAVX2(dig *digest, p []byte)\n+\n+//go:noescape\n+func blockAMD64(dig *digest, p []byte)\n+\n+var useAVX2 = cpu.X86.HasAVX2 && cpu.X86.HasBMI1 && cpu.X86.HasBMI2\n+\n+func block(dig *digest, p []byte) {\n+\tif useAVX2 {\n+\t\tblockAVX2(dig, p)\n+\t} else {\n+\t\tblockAMD64(dig, p)\n+\t}\n+}"}, {"sha": "3d098c5b17eaac01dd93c9b5309c4012904e42cd", "filename": "libgo/go/crypto/sha512/sha512block_decl.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcrypto%2Fsha512%2Fsha512block_decl.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcrypto%2Fsha512%2Fsha512block_decl.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fsha512%2Fsha512block_decl.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -3,7 +3,7 @@\n // license that can be found in the LICENSE file.\n \n // +build ignore\n-// +build amd64 s390x ppc64le\n+// +build s390x ppc64le\n \n package sha512\n "}, {"sha": "5860838dd25457945e0819ae70e8f1b09a6cd716", "filename": "libgo/go/crypto/tls/common.go", "status": "modified", "additions": 14, "deletions": 22, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcrypto%2Ftls%2Fcommon.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcrypto%2Ftls%2Fcommon.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fcommon.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -163,8 +163,8 @@ type ConnectionState struct {\n \tHandshakeComplete           bool                  // TLS handshake is complete\n \tDidResume                   bool                  // connection resumes a previous TLS connection\n \tCipherSuite                 uint16                // cipher suite in use (TLS_RSA_WITH_RC4_128_SHA, ...)\n-\tNegotiatedProtocol          string                // negotiated next protocol (from Config.NextProtos)\n-\tNegotiatedProtocolIsMutual  bool                  // negotiated protocol was advertised by server\n+\tNegotiatedProtocol          string                // negotiated next protocol (not guaranteed to be from Config.NextProtos)\n+\tNegotiatedProtocolIsMutual  bool                  // negotiated protocol was advertised by server (client side only)\n \tServerName                  string                // server name requested by client, if any (server side only)\n \tPeerCertificates            []*x509.Certificate   // certificate chain presented by remote peer\n \tVerifiedChains              [][]*x509.Certificate // verified chains built from PeerCertificates\n@@ -174,9 +174,9 @@ type ConnectionState struct {\n \t// TLSUnique contains the \"tls-unique\" channel binding value (see RFC\n \t// 5929, section 3). For resumed sessions this value will be nil\n \t// because resumption does not include enough context (see\n-\t// https://secure-resumption.com/#channelbindings). This will change in\n-\t// future versions of Go once the TLS master-secret fix has been\n-\t// standardized and implemented.\n+\t// https://mitls.org/pages/attacks/3SHAKE#channelbindings). This will\n+\t// change in future versions of Go once the TLS master-secret fix has\n+\t// been standardized and implemented.\n \tTLSUnique []byte\n }\n \n@@ -206,7 +206,8 @@ type ClientSessionState struct {\n // ClientSessionCache is a cache of ClientSessionState objects that can be used\n // by a client to resume a TLS session with a given server. ClientSessionCache\n // implementations should expect to be called concurrently from different\n-// goroutines.\n+// goroutines. Only ticket-based resumption is supported, not SessionID-based\n+// resumption.\n type ClientSessionCache interface {\n \t// Get searches for a ClientSessionState associated with the given key.\n \t// On return, ok is true if one was found.\n@@ -508,17 +509,13 @@ type Config struct {\n \n \tserverInitOnce sync.Once // guards calling (*Config).serverInit\n \n-\t// mutex protects sessionTicketKeys and originalConfig.\n+\t// mutex protects sessionTicketKeys.\n \tmutex sync.RWMutex\n \t// sessionTicketKeys contains zero or more ticket keys. If the length\n \t// is zero, SessionTicketsDisabled must be true. The first key is used\n \t// for new tickets and any subsequent keys can be used to decrypt old\n \t// tickets.\n \tsessionTicketKeys []ticketKey\n-\t// originalConfig is set to the Config that was passed to Server if\n-\t// this Config is returned by a GetConfigForClient callback. It's used\n-\t// by serverInit in order to copy session ticket keys if needed.\n-\toriginalConfig *Config\n }\n \n // ticketKeyNameLen is the number of bytes of identifier that is prepended to\n@@ -550,7 +547,7 @@ func ticketKeyFromBytes(b [32]byte) (key ticketKey) {\n func (c *Config) Clone() *Config {\n \t// Running serverInit ensures that it's safe to read\n \t// SessionTicketsDisabled.\n-\tc.serverInitOnce.Do(c.serverInit)\n+\tc.serverInitOnce.Do(func() { c.serverInit(nil) })\n \n \tvar sessionTicketKeys []ticketKey\n \tc.mutex.RLock()\n@@ -584,20 +581,17 @@ func (c *Config) Clone() *Config {\n \t\tRenegotiation:               c.Renegotiation,\n \t\tKeyLogWriter:                c.KeyLogWriter,\n \t\tsessionTicketKeys:           sessionTicketKeys,\n-\t\t// originalConfig is deliberately not duplicated.\n \t}\n }\n \n-func (c *Config) serverInit() {\n+// serverInit is run under c.serverInitOnce to do initialization of c. If c was\n+// returned by a GetConfigForClient callback then the argument should be the\n+// Config that was passed to Server, otherwise it should be nil.\n+func (c *Config) serverInit(originalConfig *Config) {\n \tif c.SessionTicketsDisabled || len(c.ticketKeys()) != 0 {\n \t\treturn\n \t}\n \n-\tvar originalConfig *Config\n-\tc.mutex.Lock()\n-\toriginalConfig, c.originalConfig = c.originalConfig, nil\n-\tc.mutex.Unlock()\n-\n \talreadySet := false\n \tfor _, b := range c.SessionTicketKey {\n \t\tif b != 0 {\n@@ -947,9 +941,7 @@ func initDefaultCipherSuites() {\n \t}\n \n \tvarDefaultCipherSuites = make([]uint16, 0, len(cipherSuites))\n-\tfor _, topCipher := range topCipherSuites {\n-\t\tvarDefaultCipherSuites = append(varDefaultCipherSuites, topCipher)\n-\t}\n+\tvarDefaultCipherSuites = append(varDefaultCipherSuites, topCipherSuites...)\n \n NextCipherSuite:\n \tfor _, suite := range cipherSuites {"}, {"sha": "e6d85aa26391fa0aada9c676cbabc642f6a93a95", "filename": "libgo/go/crypto/tls/conn.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcrypto%2Ftls%2Fconn.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcrypto%2Ftls%2Fconn.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fconn.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -1206,10 +1206,10 @@ func (c *Conn) Close() error {\n \tvar alertErr error\n \n \tc.handshakeMutex.Lock()\n-\tdefer c.handshakeMutex.Unlock()\n \tif c.handshakeComplete {\n \t\talertErr = c.closeNotify()\n \t}\n+\tc.handshakeMutex.Unlock()\n \n \tif err := c.conn.Close(); err != nil {\n \t\treturn err"}, {"sha": "e27c5414b22bdf7e65cb8571fef3b24367870915", "filename": "libgo/go/crypto/tls/conn_test.go", "status": "modified", "additions": 36, "deletions": 5, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcrypto%2Ftls%2Fconn_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcrypto%2Ftls%2Fconn_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fconn_test.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -138,7 +138,7 @@ func runDynamicRecordSizingTest(t *testing.T, config *Config) {\n \n \t\ttlsConn := Client(clientConn, config)\n \t\tif err := tlsConn.Handshake(); err != nil {\n-\t\t\tt.Errorf(\"Error from client handshake: %s\", err)\n+\t\t\tt.Errorf(\"Error from client handshake: %v\", err)\n \t\t\treturn\n \t\t}\n \n@@ -147,12 +147,12 @@ func runDynamicRecordSizingTest(t *testing.T, config *Config) {\n \t\tvar recordSizes []int\n \n \t\tfor {\n-\t\t\tn, err := clientConn.Read(recordHeader[:])\n+\t\t\tn, err := io.ReadFull(clientConn, recordHeader[:])\n \t\t\tif err == io.EOF {\n \t\t\t\tbreak\n \t\t\t}\n \t\t\tif err != nil || n != len(recordHeader) {\n-\t\t\t\tt.Errorf(\"Error from client read: %s\", err)\n+\t\t\t\tt.Errorf(\"io.ReadFull = %d, %v\", n, err)\n \t\t\t\treturn\n \t\t\t}\n \n@@ -161,9 +161,9 @@ func runDynamicRecordSizingTest(t *testing.T, config *Config) {\n \t\t\t\trecord = make([]byte, length)\n \t\t\t}\n \n-\t\t\tn, err = clientConn.Read(record[:length])\n+\t\t\tn, err = io.ReadFull(clientConn, record[:length])\n \t\t\tif err != nil || n != length {\n-\t\t\t\tt.Errorf(\"Error from client read: %s\", err)\n+\t\t\t\tt.Errorf(\"io.ReadFull = %d, %v\", n, err)\n \t\t\t\treturn\n \t\t\t}\n \n@@ -241,3 +241,34 @@ func TestDynamicRecordSizingWithAEAD(t *testing.T) {\n \tconfig.CipherSuites = []uint16{TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256}\n \trunDynamicRecordSizingTest(t, config)\n }\n+\n+// hairpinConn is a net.Conn that makes a \u201chairpin\u201d call when closed, back into\n+// the tls.Conn which is calling it.\n+type hairpinConn struct {\n+\tnet.Conn\n+\ttlsConn *Conn\n+}\n+\n+func (conn *hairpinConn) Close() error {\n+\tconn.tlsConn.ConnectionState()\n+\treturn nil\n+}\n+\n+func TestHairpinInClose(t *testing.T) {\n+\t// This tests that the underlying net.Conn can call back into the\n+\t// tls.Conn when being closed without deadlocking.\n+\tclient, server := net.Pipe()\n+\tdefer server.Close()\n+\tdefer client.Close()\n+\n+\tconn := &hairpinConn{client, nil}\n+\ttlsConn := Server(conn, &Config{\n+\t\tGetCertificate: func(*ClientHelloInfo) (*Certificate, error) {\n+\t\t\tpanic(\"unreachable\")\n+\t\t},\n+\t})\n+\tconn.tlsConn = tlsConn\n+\n+\t// This call should not deadlock.\n+\ttlsConn.Close()\n+}"}, {"sha": "8ee2b5922b3778296d7f2868d48fc6047981b7e5", "filename": "libgo/go/crypto/tls/generate_cert.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcrypto%2Ftls%2Fgenerate_cert.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcrypto%2Ftls%2Fgenerate_cert.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fgenerate_cert.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -33,7 +33,7 @@ var (\n \tvalidFor   = flag.Duration(\"duration\", 365*24*time.Hour, \"Duration that certificate is valid for\")\n \tisCA       = flag.Bool(\"ca\", false, \"whether this cert should be its own Certificate Authority\")\n \trsaBits    = flag.Int(\"rsa-bits\", 2048, \"Size of RSA key to generate. Ignored if --ecdsa-curve is set\")\n-\tecdsaCurve = flag.String(\"ecdsa-curve\", \"\", \"ECDSA curve to use to generate a key. Valid values are P224, P256, P384, P521\")\n+\tecdsaCurve = flag.String(\"ecdsa-curve\", \"\", \"ECDSA curve to use to generate a key. Valid values are P224, P256 (recommended), P384, P521\")\n )\n \n func publicKey(priv interface{}) interface{} {"}, {"sha": "a4ca5d34fb878cb03ee612e61ee936375ba2fa11", "filename": "libgo/go/crypto/tls/handshake_client.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -815,7 +815,7 @@ func hostnameInSNI(name string) string {\n \tif net.ParseIP(host) != nil {\n \t\treturn \"\"\n \t}\n-\tif len(name) > 0 && name[len(name)-1] == '.' {\n+\tfor len(name) > 0 && name[len(name)-1] == '.' {\n \t\tname = name[:len(name)-1]\n \t}\n \treturn name"}, {"sha": "0c7581f3e36768688c082f752b920de41ff9c772", "filename": "libgo/go/crypto/tls/handshake_messages.go", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_messages.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_messages.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_messages.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -4,7 +4,10 @@\n \n package tls\n \n-import \"bytes\"\n+import (\n+\t\"bytes\"\n+\t\"strings\"\n+)\n \n type clientHelloMsg struct {\n \traw                          []byte\n@@ -393,6 +396,12 @@ func (m *clientHelloMsg) unmarshal(data []byte) bool {\n \t\t\t\t}\n \t\t\t\tif nameType == 0 {\n \t\t\t\t\tm.serverName = string(d[:nameLen])\n+\t\t\t\t\t// An SNI value may not include a\n+\t\t\t\t\t// trailing dot. See\n+\t\t\t\t\t// https://tools.ietf.org/html/rfc6066#section-3.\n+\t\t\t\t\tif strings.HasSuffix(m.serverName, \".\") {\n+\t\t\t\t\t\treturn false\n+\t\t\t\t\t}\n \t\t\t\t\tbreak\n \t\t\t\t}\n \t\t\t\td = d[nameLen:]"}, {"sha": "7add97c32c1071041e426b3b9a2a11283b0d1641", "filename": "libgo/go/crypto/tls/handshake_messages_test.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_messages_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_messages_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_messages_test.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -8,6 +8,7 @@ import (\n \t\"bytes\"\n \t\"math/rand\"\n \t\"reflect\"\n+\t\"strings\"\n \t\"testing\"\n \t\"testing/quick\"\n )\n@@ -123,6 +124,9 @@ func (*clientHelloMsg) Generate(rand *rand.Rand, size int) reflect.Value {\n \t}\n \tif rand.Intn(10) > 5 {\n \t\tm.serverName = randomString(rand.Intn(255), rand)\n+\t\tfor strings.HasSuffix(m.serverName, \".\") {\n+\t\t\tm.serverName = m.serverName[:len(m.serverName)-1]\n+\t\t}\n \t}\n \tm.ocspStapling = rand.Intn(10) > 5\n \tm.supportedPoints = randomBytes(rand.Intn(5)+1, rand)"}, {"sha": "ae32848708845aa92151503d196da9670bf0d95e", "filename": "libgo/go/crypto/tls/handshake_server.go", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -40,7 +40,7 @@ type serverHandshakeState struct {\n func (c *Conn) serverHandshake() error {\n \t// If this is the first server handshake, we generate a random key to\n \t// encrypt the tickets with.\n-\tc.config.serverInitOnce.Do(c.config.serverInit)\n+\tc.config.serverInitOnce.Do(func() { c.config.serverInit(nil) })\n \n \ths := serverHandshakeState{\n \t\tc: c,\n@@ -129,11 +129,7 @@ func (hs *serverHandshakeState) readClientHello() (isResume bool, err error) {\n \t\t\tc.sendAlert(alertInternalError)\n \t\t\treturn false, err\n \t\t} else if newConfig != nil {\n-\t\t\tnewConfig.mutex.Lock()\n-\t\t\tnewConfig.originalConfig = c.config\n-\t\t\tnewConfig.mutex.Unlock()\n-\n-\t\t\tnewConfig.serverInitOnce.Do(newConfig.serverInit)\n+\t\t\tnewConfig.serverInitOnce.Do(func() { newConfig.serverInit(c.config) })\n \t\t\tc.config = newConfig\n \t\t}\n \t}"}, {"sha": "63845c170d7804afc786bed99e01430b948708b5", "filename": "libgo/go/crypto/tls/handshake_server_test.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server_test.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -137,6 +137,10 @@ func TestNoRC4ByDefault(t *testing.T) {\n \ttestClientHelloFailure(t, serverConfig, clientHello, \"no cipher suite supported by both client and server\")\n }\n \n+func TestRejectSNIWithTrailingDot(t *testing.T) {\n+\ttestClientHelloFailure(t, testConfig, &clientHelloMsg{vers: VersionTLS12, serverName: \"foo.com.\"}, \"unexpected message\")\n+}\n+\n func TestDontSelectECDSAWithRSAKey(t *testing.T) {\n \t// Test that, even when both sides support an ECDSA cipher suite, it\n \t// won't be selected if the server's private key doesn't support it."}, {"sha": "73bc7623a5aaffa46703e203334747b34ca44f76", "filename": "libgo/go/crypto/x509/pkcs1.go", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcrypto%2Fx509%2Fpkcs1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcrypto%2Fx509%2Fpkcs1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fpkcs1.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -35,6 +35,12 @@ type pkcs1AdditionalRSAPrime struct {\n \tCoeff *big.Int\n }\n \n+// pkcs1PublicKey reflects the ASN.1 structure of a PKCS#1 public key.\n+type pkcs1PublicKey struct {\n+\tN *big.Int\n+\tE int\n+}\n+\n // ParsePKCS1PrivateKey returns an RSA private key from its ASN.1 PKCS#1 DER encoded form.\n func ParsePKCS1PrivateKey(der []byte) (*rsa.PrivateKey, error) {\n \tvar priv pkcs1PrivateKey\n@@ -113,9 +119,3 @@ func MarshalPKCS1PrivateKey(key *rsa.PrivateKey) []byte {\n \tb, _ := asn1.Marshal(priv)\n \treturn b\n }\n-\n-// rsaPublicKey reflects the ASN.1 structure of a PKCS#1 public key.\n-type rsaPublicKey struct {\n-\tN *big.Int\n-\tE int\n-}"}, {"sha": "1371933891030e81682eb083f0aed89f9c464b67", "filename": "libgo/go/crypto/x509/root_bsd.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_bsd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_bsd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_bsd.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -8,7 +8,8 @@ package x509\n \n // Possible certificate files; stop after finding one.\n var certFiles = []string{\n-\t\"/usr/local/share/certs/ca-root-nss.crt\", // FreeBSD/DragonFly\n+\t\"/usr/local/etc/ssl/cert.pem\",            // FreeBSD\n \t\"/etc/ssl/cert.pem\",                      // OpenBSD\n+\t\"/usr/local/share/certs/ca-root-nss.crt\", // DragonFly\n \t\"/etc/openssl/certs/ca-certificates.crt\", // NetBSD\n }"}, {"sha": "bc35a1cf212e5e0faa9e7754f48c4bd8d8c8ec88", "filename": "libgo/go/crypto/x509/root_darwin.go", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_darwin.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_darwin.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_darwin.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -16,6 +16,7 @@ import (\n \t\"io/ioutil\"\n \t\"os\"\n \t\"os/exec\"\n+\t\"os/user\"\n \t\"path/filepath\"\n \t\"strings\"\n \t\"sync\"\n@@ -61,7 +62,26 @@ func execSecurityRoots() (*CertPool, error) {\n \t\tprintln(fmt.Sprintf(\"crypto/x509: %d certs have a trust policy\", len(hasPolicy)))\n \t}\n \n-\tcmd := exec.Command(\"/usr/bin/security\", \"find-certificate\", \"-a\", \"-p\", \"/System/Library/Keychains/SystemRootCertificates.keychain\")\n+\targs := []string{\"find-certificate\", \"-a\", \"-p\",\n+\t\t\"/System/Library/Keychains/SystemRootCertificates.keychain\",\n+\t\t\"/Library/Keychains/System.keychain\",\n+\t}\n+\n+\tu, err := user.Current()\n+\tif err != nil {\n+\t\tif debugExecDarwinRoots {\n+\t\t\tprintln(fmt.Sprintf(\"crypto/x509: get current user: %v\", err))\n+\t\t}\n+\t} else {\n+\t\targs = append(args,\n+\t\t\tfilepath.Join(u.HomeDir, \"/Library/Keychains/login.keychain\"),\n+\n+\t\t\t// Fresh installs of Sierra use a slightly different path for the login keychain\n+\t\t\tfilepath.Join(u.HomeDir, \"/Library/Keychains/login.keychain-db\"),\n+\t\t)\n+\t}\n+\n+\tcmd := exec.Command(\"/usr/bin/security\", args...)\n \tdata, err := cmd.Output()\n \tif err != nil {\n \t\treturn nil, err"}, {"sha": "0547460437b92a2a0418c287915ad0af23d89249", "filename": "libgo/go/crypto/x509/root_unix.go", "status": "modified", "additions": 31, "deletions": 3, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_unix.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -16,28 +16,52 @@ import (\n var certDirectories = []string{\n \t\"/etc/ssl/certs\",               // SLES10/SLES11, https://golang.org/issue/12139\n \t\"/system/etc/security/cacerts\", // Android\n+\t\"/usr/local/share/certs\",       // FreeBSD\n+\t\"/etc/pki/tls/certs\",           // Fedora/RHEL\n+\t\"/etc/openssl/certs\",           // NetBSD\n \t\"/var/ssl/certs\",               // AIX\n }\n \n+const (\n+\t// certFileEnv is the environment variable which identifies where to locate\n+\t// the SSL certificate file. If set this overrides the system default.\n+\tcertFileEnv = \"SSL_CERT_FILE\"\n+\n+\t// certDirEnv is the environment variable which identifies which directory\n+\t// to check for SSL certificate files. If set this overrides the system default.\n+\tcertDirEnv = \"SSL_CERT_DIR\"\n+)\n+\n func (c *Certificate) systemVerify(opts *VerifyOptions) (chains [][]*Certificate, err error) {\n \treturn nil, nil\n }\n \n func loadSystemRoots() (*CertPool, error) {\n \troots := NewCertPool()\n+\n+\tfiles := certFiles\n+\tif f := os.Getenv(certFileEnv); f != \"\" {\n+\t\tfiles = []string{f}\n+\t}\n+\n \tvar firstErr error\n-\tfor _, file := range certFiles {\n+\tfor _, file := range files {\n \t\tdata, err := ioutil.ReadFile(file)\n \t\tif err == nil {\n \t\t\troots.AppendCertsFromPEM(data)\n-\t\t\treturn roots, nil\n+\t\t\tbreak\n \t\t}\n \t\tif firstErr == nil && !os.IsNotExist(err) {\n \t\t\tfirstErr = err\n \t\t}\n \t}\n \n-\tfor _, directory := range certDirectories {\n+\tdirs := certDirectories\n+\tif d := os.Getenv(certDirEnv); d != \"\" {\n+\t\tdirs = []string{d}\n+\t}\n+\n+\tfor _, directory := range dirs {\n \t\tfis, err := ioutil.ReadDir(directory)\n \t\tif err != nil {\n \t\t\tif firstErr == nil && !os.IsNotExist(err) {\n@@ -57,5 +81,9 @@ func loadSystemRoots() (*CertPool, error) {\n \t\t}\n \t}\n \n+\tif len(roots.certs) > 0 {\n+\t\treturn roots, nil\n+\t}\n+\n \treturn nil, firstErr\n }"}, {"sha": "03f935d4e82fda63351cf43bfa3dd1378f13d14d", "filename": "libgo/go/crypto/x509/root_unix_test.go", "status": "added", "additions": 127, "deletions": 0, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_unix_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_unix_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_unix_test.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -0,0 +1,127 @@\n+// Copyright 2017 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build dragonfly freebsd linux netbsd openbsd solaris\n+\n+package x509\n+\n+import (\n+\t\"fmt\"\n+\t\"os\"\n+\t\"testing\"\n+)\n+\n+const (\n+\ttestDir     = \"testdata\"\n+\ttestDirCN   = \"test-dir\"\n+\ttestFile    = \"test-file.crt\"\n+\ttestFileCN  = \"test-file\"\n+\ttestMissing = \"missing\"\n+)\n+\n+func TestEnvVars(t *testing.T) {\n+\ttestCases := []struct {\n+\t\tname    string\n+\t\tfileEnv string\n+\t\tdirEnv  string\n+\t\tfiles   []string\n+\t\tdirs    []string\n+\t\tcns     []string\n+\t}{\n+\t\t{\n+\t\t\t// Environment variables override the default locations preventing fall through.\n+\t\t\tname:    \"override-defaults\",\n+\t\t\tfileEnv: testMissing,\n+\t\t\tdirEnv:  testMissing,\n+\t\t\tfiles:   []string{testFile},\n+\t\t\tdirs:    []string{testDir},\n+\t\t\tcns:     nil,\n+\t\t},\n+\t\t{\n+\t\t\t// File environment overrides default file locations.\n+\t\t\tname:    \"file\",\n+\t\t\tfileEnv: testFile,\n+\t\t\tdirEnv:  \"\",\n+\t\t\tfiles:   nil,\n+\t\t\tdirs:    nil,\n+\t\t\tcns:     []string{testFileCN},\n+\t\t},\n+\t\t{\n+\t\t\t// Directory environment overrides default directory locations.\n+\t\t\tname:    \"dir\",\n+\t\t\tfileEnv: \"\",\n+\t\t\tdirEnv:  testDir,\n+\t\t\tfiles:   nil,\n+\t\t\tdirs:    nil,\n+\t\t\tcns:     []string{testDirCN},\n+\t\t},\n+\t\t{\n+\t\t\t// File & directory environment overrides both default locations.\n+\t\t\tname:    \"file+dir\",\n+\t\t\tfileEnv: testFile,\n+\t\t\tdirEnv:  testDir,\n+\t\t\tfiles:   nil,\n+\t\t\tdirs:    nil,\n+\t\t\tcns:     []string{testFileCN, testDirCN},\n+\t\t},\n+\t\t{\n+\t\t\t// Environment variable empty / unset uses default locations.\n+\t\t\tname:    \"empty-fall-through\",\n+\t\t\tfileEnv: \"\",\n+\t\t\tdirEnv:  \"\",\n+\t\t\tfiles:   []string{testFile},\n+\t\t\tdirs:    []string{testDir},\n+\t\t\tcns:     []string{testFileCN, testDirCN},\n+\t\t},\n+\t}\n+\n+\t// Save old settings so we can restore before the test ends.\n+\torigCertFiles, origCertDirectories := certFiles, certDirectories\n+\torigFile, origDir := os.Getenv(certFileEnv), os.Getenv(certDirEnv)\n+\tdefer func() {\n+\t\tcertFiles = origCertFiles\n+\t\tcertDirectories = origCertDirectories\n+\t\tos.Setenv(certFileEnv, origFile)\n+\t\tos.Setenv(certDirEnv, origDir)\n+\t}()\n+\n+\tfor _, tc := range testCases {\n+\t\tt.Run(tc.name, func(t *testing.T) {\n+\t\t\tif err := os.Setenv(certFileEnv, tc.fileEnv); err != nil {\n+\t\t\t\tt.Fatalf(\"setenv %q failed: %v\", certFileEnv, err)\n+\t\t\t}\n+\t\t\tif err := os.Setenv(certDirEnv, tc.dirEnv); err != nil {\n+\t\t\t\tt.Fatalf(\"setenv %q failed: %v\", certDirEnv, err)\n+\t\t\t}\n+\n+\t\t\tcertFiles, certDirectories = tc.files, tc.dirs\n+\n+\t\t\tr, err := loadSystemRoots()\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatal(\"unexpected failure:\", err)\n+\t\t\t}\n+\n+\t\t\tif r == nil {\n+\t\t\t\tif tc.cns == nil {\n+\t\t\t\t\t// Expected nil\n+\t\t\t\t\treturn\n+\t\t\t\t}\n+\t\t\t\tt.Fatal(\"nil roots\")\n+\t\t\t}\n+\n+\t\t\t// Verify that the returned certs match, otherwise report where the mismatch is.\n+\t\t\tfor i, cn := range tc.cns {\n+\t\t\t\tif i >= len(r.certs) {\n+\t\t\t\t\tt.Errorf(\"missing cert %v @ %v\", cn, i)\n+\t\t\t\t} else if r.certs[i].Subject.CommonName != cn {\n+\t\t\t\t\tfmt.Printf(\"%#v\\n\", r.certs[0].Subject)\n+\t\t\t\t\tt.Errorf(\"unexpected cert common name %q, want %q\", r.certs[i].Subject.CommonName, cn)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif len(r.certs) > len(tc.cns) {\n+\t\t\t\tt.Errorf(\"got %v certs, which is more than %v wanted\", len(r.certs), len(tc.cns))\n+\t\t\t}\n+\t\t})\n+\t}\n+}"}, {"sha": "caa83b9f824c104c8f4aa03b13f770ad91b794e1", "filename": "libgo/go/crypto/x509/test-file.crt", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcrypto%2Fx509%2Ftest-file.crt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcrypto%2Fx509%2Ftest-file.crt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Ftest-file.crt?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -0,0 +1,32 @@\n+-----BEGIN CERTIFICATE-----\n+MIIFbTCCA1WgAwIBAgIJAN338vEmMtLsMA0GCSqGSIb3DQEBCwUAME0xCzAJBgNV\n+BAYTAlVLMRMwEQYDVQQIDApUZXN0LVN0YXRlMRUwEwYDVQQKDAxHb2xhbmcgVGVz\n+dHMxEjAQBgNVBAMMCXRlc3QtZmlsZTAeFw0xNzAyMDEyMzUyMDhaFw0yNzAxMzAy\n+MzUyMDhaME0xCzAJBgNVBAYTAlVLMRMwEQYDVQQIDApUZXN0LVN0YXRlMRUwEwYD\n+VQQKDAxHb2xhbmcgVGVzdHMxEjAQBgNVBAMMCXRlc3QtZmlsZTCCAiIwDQYJKoZI\n+hvcNAQEBBQADggIPADCCAgoCggIBAPMGiLjdiffQo3Xc8oUe7wsDhSaAJFOhO6Qs\n+i0xYrYl7jmCuz9rGD2fdgk5cLqGazKuQ6fIFzHXFU2BKs4CWXt9KO0KFEhfvZeuW\n+jG5d7C1ZUiuKOrPqjKVu8SZtFPc7y7Ke7msXzY+Z2LLyiJJ93LCMq4+cTSGNXVlI\n+KqUxhxeoD5/QkUPyQy/ilu3GMYfx/YORhDP6Edcuskfj8wRh1UxBejP8YPMvI6St\n+cE2GkxoEGqDWnQ/61F18te6WI3MD29tnKXOkXVhnSC+yvRLljotW2/tAhHKBG4tj\n+iQWT5Ri4Wrw2tXxPKRLsVWc7e1/hdxhnuvYpXkWNhKsm002jzkFXlzfEwPd8nZdw\n+5aT6gPUBN2AAzdoqZI7E200i0orEF7WaSoMfjU1tbHvExp3vyAPOfJ5PS2MQ6W03\n+Zsy5dTVH+OBH++rkRzQCFcnIv/OIhya5XZ9KX9nFPgBEP7Xq2A+IjH7B6VN/S/bv\n+8lhp2V+SQvlew9GttKC4hKuPsl5o7+CMbcqcNUdxm9gGkN8epGEKCuix97bpNlxN\n+fHZxHE5+8GMzPXMkCD56y5TNKR6ut7JGHMPtGl5lPCLqzG/HzYyFgxsDfDUu2B0A\n+GKj0lGpnLfGqwhs2/s3jpY7+pcvVQxEpvVTId5byDxu1ujP4HjO/VTQ2P72rE8Ft\n+C6J2Av0tAgMBAAGjUDBOMB0GA1UdDgQWBBTLT/RbyfBB/Pa07oBnaM+QSJPO9TAf\n+BgNVHSMEGDAWgBTLT/RbyfBB/Pa07oBnaM+QSJPO9TAMBgNVHRMEBTADAQH/MA0G\n+CSqGSIb3DQEBCwUAA4ICAQB3sCntCcQwhMgRPPyvOCMyTcQ/Iv+cpfxz2Ck14nlx\n+AkEAH2CH0ov5GWTt07/ur3aa5x+SAKi0J3wTD1cdiw4U/6Uin6jWGKKxvoo4IaeK\n+SbM8w/6eKx6UbmHx7PA/eRABY9tTlpdPCVgw7/o3WDr03QM+IAtatzvaCPPczake\n+pbdLwmBZB/v8V+6jUajy6jOgdSH0PyffGnt7MWgDETmNC6p/Xigp5eh+C8Fb4NGT\n+xgHES5PBC+sruWp4u22bJGDKTvYNdZHsnw/CaKQWNsQqwisxa3/8N5v+PCff/pxl\n+r05pE3PdHn9JrCl4iWdVlgtiI9BoPtQyDfa/OEFaScE8KYR8LxaAgdgp3zYncWls\n+BpwQ6Y/A2wIkhlD9eEp5Ib2hz7isXOs9UwjdriKqrBXqcIAE5M+YIk3+KAQKxAtd\n+4YsK3CSJ010uphr12YKqlScj4vuKFjuOtd5RyyMIxUG3lrrhAu2AzCeKCLdVgA8+\n+75FrYMApUdvcjp4uzbBoED4XRQlx9kdFHVbYgmE/+yddBYJM8u4YlgAL0hW2/D8p\n+z9JWIfxVmjJnBnXaKGBuiUyZ864A3PJndP6EMMo7TzS2CDnfCYuJjvI0KvDjFNmc\n+rQA04+qfMSEz3nmKhbbZu4eYLzlADhfH8tT4GMtXf71WLA5AUHGf2Y4+HIHTsmHG\n+vQ==\n+-----END CERTIFICATE-----"}, {"sha": "b7fc9c51861961feb4dbcc7e8f35309fd4a2e155", "filename": "libgo/go/crypto/x509/testdata/test-dir.crt", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcrypto%2Fx509%2Ftestdata%2Ftest-dir.crt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcrypto%2Fx509%2Ftestdata%2Ftest-dir.crt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Ftestdata%2Ftest-dir.crt?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -0,0 +1,31 @@\n+-----BEGIN CERTIFICATE-----\n+MIIFazCCA1OgAwIBAgIJAL8a/lsnspOqMA0GCSqGSIb3DQEBCwUAMEwxCzAJBgNV\n+BAYTAlVLMRMwEQYDVQQIDApUZXN0LVN0YXRlMRUwEwYDVQQKDAxHb2xhbmcgVGVz\n+dHMxETAPBgNVBAMMCHRlc3QtZGlyMB4XDTE3MDIwMTIzNTAyN1oXDTI3MDEzMDIz\n+NTAyN1owTDELMAkGA1UEBhMCVUsxEzARBgNVBAgMClRlc3QtU3RhdGUxFTATBgNV\n+BAoMDEdvbGFuZyBUZXN0czERMA8GA1UEAwwIdGVzdC1kaXIwggIiMA0GCSqGSIb3\n+DQEBAQUAA4ICDwAwggIKAoICAQDzBoi43Yn30KN13PKFHu8LA4UmgCRToTukLItM\n+WK2Je45grs/axg9n3YJOXC6hmsyrkOnyBcx1xVNgSrOAll7fSjtChRIX72Xrloxu\n+XewtWVIrijqz6oylbvEmbRT3O8uynu5rF82Pmdiy8oiSfdywjKuPnE0hjV1ZSCql\n+MYcXqA+f0JFD8kMv4pbtxjGH8f2DkYQz+hHXLrJH4/MEYdVMQXoz/GDzLyOkrXBN\n+hpMaBBqg1p0P+tRdfLXuliNzA9vbZylzpF1YZ0gvsr0S5Y6LVtv7QIRygRuLY4kF\n+k+UYuFq8NrV8TykS7FVnO3tf4XcYZ7r2KV5FjYSrJtNNo85BV5c3xMD3fJ2XcOWk\n++oD1ATdgAM3aKmSOxNtNItKKxBe1mkqDH41NbWx7xMad78gDznyeT0tjEOltN2bM\n+uXU1R/jgR/vq5Ec0AhXJyL/ziIcmuV2fSl/ZxT4ARD+16tgPiIx+welTf0v27/JY\n+adlfkkL5XsPRrbSguISrj7JeaO/gjG3KnDVHcZvYBpDfHqRhCgrosfe26TZcTXx2\n+cRxOfvBjMz1zJAg+esuUzSkerreyRhzD7RpeZTwi6sxvx82MhYMbA3w1LtgdABio\n+9JRqZy3xqsIbNv7N46WO/qXL1UMRKb1UyHeW8g8btboz+B4zv1U0Nj+9qxPBbQui\n+dgL9LQIDAQABo1AwTjAdBgNVHQ4EFgQUy0/0W8nwQfz2tO6AZ2jPkEiTzvUwHwYD\n+VR0jBBgwFoAUy0/0W8nwQfz2tO6AZ2jPkEiTzvUwDAYDVR0TBAUwAwEB/zANBgkq\n+hkiG9w0BAQsFAAOCAgEAvEVnUYsIOt87rggmLPqEueynkuQ+562M8EDHSQl82zbe\n+xDCxeg3DvPgKb+RvaUdt1362z/szK10SoeMgx6+EQLoV9LiVqXwNqeYfixrhrdw3\n+ppAhYYhymdkbUQCEMHypmXP1vPhAz4o8Bs+eES1M+zO6ErBiD7SqkmBElT+GixJC\n+6epC9ZQFs+dw3lPlbiZSsGE85sqc3VAs0/JgpL/pb1/Eg4s0FUhZD2C2uWdSyZGc\n+g0/v3aXJCp4j/9VoNhI1WXz3M45nysZIL5OQgXymLqJElQa1pZ3Wa4i/nidvT4AT\n+Xlxc/qijM8set/nOqp7hVd5J0uG6qdwLRILUddZ6OpXd7ZNi1EXg+Bpc7ehzGsDt\n+3UFGzYXDjxYnK2frQfjLS8stOQIqSrGthW6x0fdkVx0y8BByvd5J6+JmZl4UZfzA\n+m99VxXSt4B9x6BvnY7ktzcFDOjtuLc4B/7yg9fv1eQuStA4cHGGAttsCg1X/Kx8W\n+PvkkeH0UWDZ9vhH9K36703z89da6MWF+bz92B0+4HoOmlVaXRkvblsNaynJnL0LC\n+Ayry7QBxuh5cMnDdRwJB3AVJIiJ1GVpb7aGvBOnx+s2lwRv9HWtghb+cbwwktx1M\n+JHyBf3GZNSWTpKY7cD8V+NnBv3UuioOVVo+XAU4LF/bYUjdRpxWADJizNtZrtFo=\n+-----END CERTIFICATE-----"}, {"sha": "2b4f39d62ea3c889cfb02428b2d341e6b8c59e4a", "filename": "libgo/go/crypto/x509/verify.go", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -87,7 +87,7 @@ func (h HostnameError) Error() string {\n \t\t\tvalid += san.String()\n \t\t}\n \t} else {\n-\t\tif len(c.DNSNames) > 0 {\n+\t\tif c.hasSANExtension() {\n \t\t\tvalid = strings.Join(c.DNSNames, \", \")\n \t\t} else {\n \t\t\tvalid = c.Subject.CommonName\n@@ -166,7 +166,7 @@ const (\n \n func matchNameConstraint(domain, constraint string) bool {\n \t// The meaning of zero length constraints is not specified, but this\n-\t// code follows NSS and accepts them as valid for everything.\n+\t// code follows NSS and accepts them as matching everything.\n \tif len(constraint) == 0 {\n \t\treturn true\n \t}\n@@ -220,6 +220,12 @@ func (c *Certificate) isValid(certType int, currentChain []*Certificate, opts *V\n \t\t}\n \t}\n \n+\tfor _, constraint := range c.ExcludedDNSDomains {\n+\t\tif matchNameConstraint(opts.DNSName, constraint) {\n+\t\t\treturn CertificateInvalidError{c, CANotAuthorizedForThisName}\n+\t\t}\n+\t}\n+\n \t// KeyUsage status flags are ignored. From Engineering Security, Peter\n \t// Gutmann: A European government CA marked its signing certificates as\n \t// being valid for encryption only, but no-one noticed. Another\n@@ -482,7 +488,7 @@ func (c *Certificate) VerifyHostname(h string) error {\n \n \tlowered := toLowerCaseASCII(h)\n \n-\tif len(c.DNSNames) > 0 {\n+\tif c.hasSANExtension() {\n \t\tfor _, match := range c.DNSNames {\n \t\t\tif matchHostnames(toLowerCaseASCII(match), lowered) {\n \t\t\t\treturn nil"}, {"sha": "335c477d0da598155148b7658759aa57de2be830", "filename": "libgo/go/crypto/x509/verify_test.go", "status": "modified", "additions": 218, "deletions": 1, "changes": 219, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fverify_test.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -263,6 +263,39 @@ var verifyTests = []verifyTest{\n \n \t\terrorCallback: expectSubjectIssuerMismatcthError,\n \t},\n+\t{\n+\t\t// An X.509 v1 certificate should not be accepted as an\n+\t\t// intermediate.\n+\t\tleaf:          x509v1TestLeaf,\n+\t\tintermediates: []string{x509v1TestIntermediate},\n+\t\troots:         []string{x509v1TestRoot},\n+\t\tcurrentTime:   1481753183,\n+\t\tsystemSkip:    true,\n+\n+\t\terrorCallback: expectNotAuthorizedError,\n+\t},\n+\t{\n+\t\t// If any SAN extension is present (even one without any DNS\n+\t\t// names), the CN should be ignored.\n+\t\tleaf:        ignoreCNWithSANLeaf,\n+\t\tdnsName:     \"foo.example.com\",\n+\t\troots:       []string{ignoreCNWithSANRoot},\n+\t\tcurrentTime: 1486684488,\n+\t\tsystemSkip:  true,\n+\n+\t\terrorCallback: expectHostnameError,\n+\t},\n+\t{\n+\t\t// Test that excluded names are respected.\n+\t\tleaf:          excludedNamesLeaf,\n+\t\tdnsName:       \"bender.local\",\n+\t\tintermediates: []string{excludedNamesIntermediate},\n+\t\troots:         []string{excludedNamesRoot},\n+\t\tcurrentTime:   1486684488,\n+\t\tsystemSkip:    true,\n+\n+\t\terrorCallback: expectNameConstraintsError,\n+\t},\n }\n \n func expectHostnameError(t *testing.T, i int, err error) (ok bool) {\n@@ -330,6 +363,22 @@ func expectSubjectIssuerMismatcthError(t *testing.T, i int, err error) (ok bool)\n \treturn true\n }\n \n+func expectNameConstraintsError(t *testing.T, i int, err error) (ok bool) {\n+\tif inval, ok := err.(CertificateInvalidError); !ok || inval.Reason != CANotAuthorizedForThisName {\n+\t\tt.Errorf(\"#%d: error was not a CANotAuthorizedForThisName: %s\", i, err)\n+\t\treturn false\n+\t}\n+\treturn true\n+}\n+\n+func expectNotAuthorizedError(t *testing.T, i int, err error) (ok bool) {\n+\tif inval, ok := err.(CertificateInvalidError); !ok || inval.Reason != NotAuthorizedToSign {\n+\t\tt.Errorf(\"#%d: error was not a NotAuthorizedToSign: %s\", i, err)\n+\t\treturn false\n+\t}\n+\treturn true\n+}\n+\n func certificateFromPEM(pemBytes string) (*Certificate, error) {\n \tblock, _ := pem.Decode([]byte(pemBytes))\n \tif block == nil {\n@@ -1269,6 +1318,174 @@ vEA4PCJprUYmoj3q9MKSSRYDlq5kIbl87mSRR4GqtAwJKxIasvOvULOxziQ=\n -----END CERTIFICATE-----\n `\n \n+const x509v1TestRoot = `\n+-----BEGIN CERTIFICATE-----\n+MIICIDCCAYmgAwIBAgIIAj5CwoHlWuYwDQYJKoZIhvcNAQELBQAwIzEPMA0GA1UE\n+ChMGR29sYW5nMRAwDgYDVQQDEwdSb290IENBMB4XDTE1MDEwMTAwMDAwMFoXDTI1\n+MDEwMTAwMDAwMFowIzEPMA0GA1UEChMGR29sYW5nMRAwDgYDVQQDEwdSb290IENB\n+MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDpDn8RDOZa5oaDcPZRBy4CeBH1\n+siSSOO4mYgLHlPE+oXdqwI/VImi2XeJM2uCFETXCknJJjYG0iJdrt/yyRFvZTQZw\n++QzGj+mz36NqhGxDWb6dstB2m8PX+plZw7jl81MDvUnWs8yiQ/6twgu5AbhWKZQD\n+JKcNKCEpqa6UW0r5nwIDAQABo10wWzAOBgNVHQ8BAf8EBAMCAgQwHQYDVR0lBBYw\n+FAYIKwYBBQUHAwEGCCsGAQUFBwMCMA8GA1UdEwEB/wQFMAMBAf8wGQYDVR0OBBIE\n+EEA31wH7QC+4HH5UBCeMWQEwDQYJKoZIhvcNAQELBQADgYEAcIwqeNUpQr9cOcYm\n+YjpGpYkQ6b248xijCK7zI+lOeWN89zfSXn1AvfsC9pSdTMeDklWktbF/Ad0IN8Md\n+h2NtN34ard0hEfHc8qW8mkXdsysVmq6cPvFYaHz+dBtkHuHDoy8YQnC0zdN/WyYB\n+/1JmacUUofl+HusHuLkDxmadogI=\n+-----END CERTIFICATE-----`\n+\n+const x509v1TestIntermediate = `\n+-----BEGIN CERTIFICATE-----\n+MIIByjCCATMCCQCCdEMsT8ykqTANBgkqhkiG9w0BAQsFADAjMQ8wDQYDVQQKEwZH\n+b2xhbmcxEDAOBgNVBAMTB1Jvb3QgQ0EwHhcNMTUwMTAxMDAwMDAwWhcNMjUwMTAx\n+MDAwMDAwWjAwMQ8wDQYDVQQKEwZHb2xhbmcxHTAbBgNVBAMTFFguNTA5djEgaW50\n+ZXJtZWRpYXRlMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDJ2QyniAOT+5YL\n+jeinEBJr3NsC/Q2QJ/VKmgvp+xRxuKTHJiVmxVijmp0vWg8AWfkmuE4p3hXQbbqM\n+k5yxrk1n60ONhim2L4VXriEvCE7X2OXhTmBls5Ufr7aqIgPMikwjScCXwz8E8qI8\n+UxyAhnjeJwMYBU8TuwBImSd4LBHoQQIDAQABMA0GCSqGSIb3DQEBCwUAA4GBAIab\n+DRG6FbF9kL9jb/TDHkbVBk+sl/Pxi4/XjuFyIALlARgAkeZcPmL5tNW1ImHkwsHR\n+zWE77kJDibzd141u21ZbLsKvEdUJXjla43bdyMmEqf5VGpC3D4sFt3QVH7lGeRur\n+x5Wlq1u3YDL/j6s1nU2dQ3ySB/oP7J+vQ9V4QeM+\n+-----END CERTIFICATE-----`\n+\n+const x509v1TestLeaf = `\n+-----BEGIN CERTIFICATE-----\n+MIICMzCCAZygAwIBAgIJAPo99mqJJrpJMA0GCSqGSIb3DQEBCwUAMDAxDzANBgNV\n+BAoTBkdvbGFuZzEdMBsGA1UEAxMUWC41MDl2MSBpbnRlcm1lZGlhdGUwHhcNMTUw\n+MTAxMDAwMDAwWhcNMjUwMTAxMDAwMDAwWjArMQ8wDQYDVQQKEwZHb2xhbmcxGDAW\n+BgNVBAMTD2Zvby5leGFtcGxlLmNvbTCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkC\n+gYEApUh60Z+a5/oKJxG//Dn8CihSo2CJHNIIO3zEJZ1EeNSMZCynaIR6D3IPZEIR\n++RG2oGt+f5EEukAPYxwasp6VeZEezoQWJ+97nPCT6DpwLlWp3i2MF8piK2R9vxkG\n+Z5n0+HzYk1VM8epIrZFUXSMGTX8w1y041PX/yYLxbdEifdcCAwEAAaNaMFgwDgYD\n+VR0PAQH/BAQDAgWgMB0GA1UdJQQWMBQGCCsGAQUFBwMBBggrBgEFBQcDAjAMBgNV\n+HRMBAf8EAjAAMBkGA1UdDgQSBBBFozXe0SnzAmjy+1U6M/cvMA0GCSqGSIb3DQEB\n+CwUAA4GBADYzYUvaToO/ucBskPdqXV16AaakIhhSENswYVSl97/sODaxsjishKq9\n+5R7siu+JnIFotA7IbBe633p75xEnLN88X626N/XRFG9iScLzpj0o0PWXBUiB+fxL\n+/jt8qszOXCv2vYdUTPNuPqufXLWMoirpuXrr1liJDmedCcAHepY/\n+-----END CERTIFICATE-----`\n+\n+const ignoreCNWithSANRoot = `\n+-----BEGIN CERTIFICATE-----\n+MIIDPzCCAiegAwIBAgIIJkzCwkNrPHMwDQYJKoZIhvcNAQELBQAwMDEQMA4GA1UE\n+ChMHVEVTVElORzEcMBoGA1UEAxMTKipUZXN0aW5nKiogUm9vdCBDQTAeFw0xNTAx\n+MDEwMDAwMDBaFw0yNTAxMDEwMDAwMDBaMDAxEDAOBgNVBAoTB1RFU1RJTkcxHDAa\n+BgNVBAMTEyoqVGVzdGluZyoqIFJvb3QgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IB\n+DwAwggEKAoIBAQC4YAf5YqlXGcikvbMWtVrNICt+V/NNWljwfvSKdg4Inm7k6BwW\n+P6y4Y+n4qSYIWNU4iRkdpajufzctxQCO6ty13iw3qVktzcC5XBIiS6ymiRhhDgnY\n+VQqyakVGw9MxrPwdRZVlssUv3Hmy6tU+v5Ok31SLY5z3wKgYWvSyYs0b8bKNU8kf\n+2FmSHnBN16lxGdjhe3ji58F/zFMr0ds+HakrLIvVdFcQFAnQopM8FTHpoWNNzGU3\n+KaiO0jBbMFkd6uVjVnuRJ+xjuiqi/NWwiwQA+CEr9HKzGkxOF8nAsHamdmO1wW+w\n+OsCrC0qWQ/f5NTOVATTJe0vj88OMTvo3071VAgMBAAGjXTBbMA4GA1UdDwEB/wQE\n+AwICpDAdBgNVHSUEFjAUBggrBgEFBQcDAQYIKwYBBQUHAwIwDwYDVR0TAQH/BAUw\n+AwEB/zAZBgNVHQ4EEgQQQDfXAftAL7gcflQEJ4xZATANBgkqhkiG9w0BAQsFAAOC\n+AQEAGOn3XjxHyHbXLKrRmpwV447B7iNBXR5VlhwOgt1kWaHDL2+8f/9/h0HMkB6j\n+fC+/yyuYVqYuOeavqMGVrh33D2ODuTQcFlOx5lXukP46j3j+Lm0jjZ1qNX7vlP8I\n+VlUXERhbelkw8O4oikakwIY9GE8syuSgYf+VeBW/lvuAZQrdnPfabxe05Tre6RXy\n+nJHMB1q07YHpbwIkcV/lfCE9pig2nPXTLwYZz9cl46Ul5RCpPUi+IKURo3x8y0FU\n+aSLjI/Ya0zwUARMmyZ3RRGCyhIarPb20mKSaMf1/Nb23pS3k1QgmZhk5pAnXYsWu\n+BJ6bvwEAasFiLGP6Zbdmxb2hIA==\n+-----END CERTIFICATE-----`\n+\n+const ignoreCNWithSANLeaf = `\n+-----BEGIN CERTIFICATE-----\n+MIIDaTCCAlGgAwIBAgIJAONakvRTxgJhMA0GCSqGSIb3DQEBCwUAMDAxEDAOBgNV\n+BAoTB1RFU1RJTkcxHDAaBgNVBAMTEyoqVGVzdGluZyoqIFJvb3QgQ0EwHhcNMTUw\n+MTAxMDAwMDAwWhcNMjUwMTAxMDAwMDAwWjAsMRAwDgYDVQQKEwdURVNUSU5HMRgw\n+FgYDVQQDEw9mb28uZXhhbXBsZS5jb20wggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAw\n+ggEKAoIBAQDBqskp89V/JMIBBqcauKSOVLcMyIE/t0jgSWVrsI4sksBTabLsfMdS\n+ui2n+dHQ1dRBuw3o4g4fPrWwS3nMnV3pZUHEn2TPi5N1xkjTaxObXgKIY2GKmFP3\n+rJ9vYqHT6mT4K93kCHoRcmJWWySc7S3JAOhTcdB4G+tIdQJN63E+XRYQQfNrn5HZ\n+hxQoOzaguHFx+ZGSD4Ntk6BSZz5NfjqCYqYxe+iCpTpEEYhIpi8joSPSmkTMTxBW\n+S1W2gXbYNQ9KjNkGM6FnQsUJrSPMrWs4v3UB/U88N5LkZeF41SqD9ySFGwbGajFV\n+nyzj12+4K4D8BLhlOc0Eo/F/8GwOwvmxAgMBAAGjgYkwgYYwDgYDVR0PAQH/BAQD\n+AgWgMB0GA1UdJQQWMBQGCCsGAQUFBwMBBggrBgEFBQcDAjAMBgNVHRMBAf8EAjAA\n+MBkGA1UdDgQSBBCjeab27q+5pV43jBGANOJ1MBsGA1UdIwQUMBKAEEA31wH7QC+4\n+HH5UBCeMWQEwDwYDVR0RBAgwBocEfwAAATANBgkqhkiG9w0BAQsFAAOCAQEAGZfZ\n+ErTVxxpIg64s22mQpXSk/72THVQsfsKHzlXmztM0CJzH8ccoN67ZqKxJCfdiE/FI\n+Emb6BVV4cGPeIKpcxaM2dwX/Y+Y0JaxpQJvqLxs+EByRL0gPP3shgg86WWCjYLxv\n+AgOn862d/JXGDrC9vIlQ/DDQcyL5g0JV5UjG2G9TUigbnrXxBw7BoWK6wmoSaHnR\n+sZKEHSs3RUJvm7qqpA9Yfzm9jg+i9j32zh1xFacghAOmFRFXa9eCVeigZ/KK2mEY\n+j2kBQyvnyKsXHLAKUoUOpd6t/1PHrfXnGj+HmzZNloJ/BZ1kiWb4eLvMljoLGkZn\n+xZbqP3Krgjj4XNaXjg==\n+-----END CERTIFICATE-----`\n+\n+const excludedNamesLeaf = `\n+-----BEGIN CERTIFICATE-----\n+MIID4DCCAsigAwIBAgIHDUSFtJknhzANBgkqhkiG9w0BAQsFADCBnjELMAkGA1UE\n+BhMCVVMxEzARBgNVBAgMCkNhbGlmb3JuaWExEjAQBgNVBAcMCUxvcyBHYXRvczEU\n+MBIGA1UECgwLTmV0ZmxpeCBJbmMxLTArBgNVBAsMJFBsYXRmb3JtIFNlY3VyaXR5\n+ICgzNzM0NTE1NTYyODA2Mzk3KTEhMB8GA1UEAwwYSW50ZXJtZWRpYXRlIENBIGZv\n+ciAzMzkyMB4XDTE3MDIwODIxMTUwNFoXDTE4MDIwODIwMjQ1OFowgZAxCzAJBgNV\n+BAYTAlVTMRMwEQYDVQQIDApDYWxpZm9ybmlhMRIwEAYDVQQHDAlMb3MgR2F0b3Mx\n+FDASBgNVBAoMC05ldGZsaXggSW5jMS0wKwYDVQQLDCRQbGF0Zm9ybSBTZWN1cml0\n+eSAoMzczNDUxNTc0ODUwMjY5NikxEzARBgNVBAMMCjE3Mi4xNi4wLjEwggEiMA0G\n+CSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCZ0oP1bMv6bOeqcKbzinnGpNOpenhA\n+zdFFsgea62znWsH3Wg4+1Md8uPCqlaQIsaJQKZHc50eKD3bg0Io7c6kxHkBQr1b8\n+Q7cGeK3CjdqG3NwS/aizzrLKOwL693hFwwy7JY7GGCvogbhyQRKn6iV0U9zMm7bu\n+/9pQVV/wx8u01u2uAlLttjyQ5LJkxo5t8cATFVqxdN5J9eY//VSDiTwXnlpQITBP\n+/Ow+zYuZ3kFlzH3CtCOhOEvNG3Ar1NvP3Icq35PlHV+Eki4otnKfixwByoiGpqCB\n+UEIY04VrZJjwBxk08y/3jY2B3VLYGgi+rryyCxIqkB7UpSNPMMWSG4UpAgMBAAGj\n+LzAtMAwGA1UdEwEB/wQCMAAwHQYDVR0RBBYwFIIMYmVuZGVyLmxvY2FshwSsEAAB\n+MA0GCSqGSIb3DQEBCwUAA4IBAQCLW3JO8L7LKByjzj2RciPjCGH5XF87Wd20gYLq\n+sNKcFwCIeyZhnQy5aZ164a5G9AIk2HLvH6HevBFPhA9Ivmyv/wYEfnPd1VcFkpgP\n+hDt8MCFJ8eSjCyKdtZh1MPMLrLVymmJV+Rc9JUUYM9TIeERkpl0rskcO1YGewkYt\n+qKlWE+0S16+pzsWvKn831uylqwIb8ANBPsCX4aM4muFBHavSWAHgRO+P+yXVw8Q+\n+VQDnMHUe5PbZd1/+1KKVs1K/CkBCtoHNHp1d/JT+2zUQJphwja9CcgfFdVhSnHL4\n+oEEOFtqVMIuQfR2isi08qW/JGOHc4sFoLYB8hvdaxKWSE19A\n+-----END CERTIFICATE-----\n+`\n+\n+const excludedNamesIntermediate = `\n+-----BEGIN CERTIFICATE-----\n+MIIDzTCCArWgAwIBAgIHDUSFqYeczDANBgkqhkiG9w0BAQsFADCBmTELMAkGA1UE\n+BhMCVVMxEzARBgNVBAgMCkNhbGlmb3JuaWExEjAQBgNVBAcMCUxvcyBHYXRvczEU\n+MBIGA1UECgwLTmV0ZmxpeCBJbmMxLTArBgNVBAsMJFBsYXRmb3JtIFNlY3VyaXR5\n+ICgzNzM0NTE1NDc5MDY0NjAyKTEcMBoGA1UEAwwTTG9jYWwgUm9vdCBmb3IgMzM5\n+MjAeFw0xNzAyMDgyMTE1MDRaFw0xODAyMDgyMDI0NThaMIGeMQswCQYDVQQGEwJV\n+UzETMBEGA1UECAwKQ2FsaWZvcm5pYTESMBAGA1UEBwwJTG9zIEdhdG9zMRQwEgYD\n+VQQKDAtOZXRmbGl4IEluYzEtMCsGA1UECwwkUGxhdGZvcm0gU2VjdXJpdHkgKDM3\n+MzQ1MTU1NjI4MDYzOTcpMSEwHwYDVQQDDBhJbnRlcm1lZGlhdGUgQ0EgZm9yIDMz\n+OTIwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCOyEs6tJ/t9emQTvlx\n+3FS7uJSou5rKkuqVxZdIuYQ+B2ZviBYUnMRT9bXDB0nsVdKZdp0hdchdiwNXDG/I\n+CiWu48jkcv/BdynVyayOT+0pOJSYLaPYpzBx1Pb9M5651ct9GSbj6Tz0ChVonoIE\n+1AIZ0kkebucZRRFHd0xbAKVRKyUzPN6HJ7WfgyauUp7RmlC35wTmrmARrFohQLlL\n+7oICy+hIQePMy9x1LSFTbPxZ5AUUXVC3eUACU3vLClF/Xs8XGHebZpUXCdMQjOGS\n+nq1eFguFHR1poSB8uSmmLqm4vqUH9CDhEgiBAC8yekJ8//kZQ7lUEqZj3YxVbk+Y\n+E4H5AgMBAAGjEzARMA8GA1UdEwEB/wQFMAMBAf8wDQYJKoZIhvcNAQELBQADggEB\n+ADxrnmNX5gWChgX9K5fYwhFDj5ofxZXAKVQk+WjmkwMcmCx3dtWSm++Wdksj/ZlA\n+V1cLW3ohWv1/OAZuOlw7sLf98aJpX+UUmIYYQxDubq+4/q7VA7HzEf2k/i/oN1NI\n+JgtrhpPcZ/LMO6k7DYx0qlfYq8pTSfd6MI4LnWKgLc+JSPJJjmvspgio2ZFcnYr7\n+A264BwLo6v1Mos1o1JUvFFcp4GANlw0XFiWh7JXYRl8WmS5DoouUC+aNJ3lmyF6z\n+LbIjZCSfgZnk/LK1KU1j91FI2bc2ULYZvAC1PAg8/zvIgxn6YM2Q7ZsdEgWw0FpS\n+zMBX1/lk4wkFckeUIlkD55Y=\n+-----END CERTIFICATE-----`\n+\n+const excludedNamesRoot = `\n+-----BEGIN CERTIFICATE-----\n+MIIEGTCCAwGgAwIBAgIHDUSFpInn/zANBgkqhkiG9w0BAQsFADCBozELMAkGA1UE\n+BhMCVVMxEzARBgNVBAgMCkNhbGlmb3JuaWExEjAQBgNVBAcMCUxvcyBHYXRvczEU\n+MBIGA1UECgwLTmV0ZmxpeCBJbmMxLTArBgNVBAsMJFBsYXRmb3JtIFNlY3VyaXR5\n+ICgzNzMxNTA5NDM3NDYyNDg1KTEmMCQGA1UEAwwdTmFtZSBDb25zdHJhaW50cyBU\n+ZXN0IFJvb3QgQ0EwHhcNMTcwMjA4MjExNTA0WhcNMTgwMjA4MjAyNDU4WjCBmTEL\n+MAkGA1UEBhMCVVMxEzARBgNVBAgMCkNhbGlmb3JuaWExEjAQBgNVBAcMCUxvcyBH\n+YXRvczEUMBIGA1UECgwLTmV0ZmxpeCBJbmMxLTArBgNVBAsMJFBsYXRmb3JtIFNl\n+Y3VyaXR5ICgzNzM0NTE1NDc5MDY0NjAyKTEcMBoGA1UEAwwTTG9jYWwgUm9vdCBm\n+b3IgMzM5MjCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAJymcnX29ekc\n+7+MLyr8QuAzoHWznmGdDd2sITwWRjM89/21cdlHCGKSpULUNdFp9HDLWvYECtxt+\n+8TuzKiQz7qAerzGUT1zI5McIjHy0e/i4xIkfiBiNeTCuB/N9QRbZlcfM80ErkaA4\n+gCAFK8qZAcWkHIl6e+KaQFMPLKk9kckgAnVDHEJe8oLNCogCJ15558b65g05p9eb\n+5Lg+E98hoPRTQaDwlz3CZPfTTA2EiEZInSi8qzodFCbTpJUVTbiVUH/JtVjlibbb\n+smdcx5PORK+8ZJkhLEh54AjaWOX4tB/7Tkk8stg2VBmrIARt/j4UVj7cTrIWU3bV\n+m8TwHJG+YgsCAwEAAaNaMFgwDwYDVR0TAQH/BAUwAwEB/zBFBgNVHR4EPjA8oBww\n+CocICgEAAP//AAAwDoIMYmVuZGVyLmxvY2FsoRwwCocICgEAAP//AAAwDoIMYmVu\n+ZGVyLmxvY2FsMA0GCSqGSIb3DQEBCwUAA4IBAQAMjbheffPxtSKSv9NySW+8qmHs\n+n7Mb5GGyCFu+cMZSoSaabstbml+zHEFJvWz6/1E95K4F8jKhAcu/CwDf4IZrSD2+\n+Hee0DolVSQhZpnHgPyj7ZATz48e3aJaQPUlhCEOh0wwF4Y0N4FV0t7R6woLylYRZ\n+yU1yRHUqUYpN0DWFpsPbBqgM6uUAVO2ayBFhPgWUaqkmSbZ/Nq7isGvknaTmcIwT\n+6mOAFN0qFb4RGzfGJW7x6z7KCULS7qVDp6fU3tRoScHFEgRubks6jzQ1W5ooSm4o\n++NQCZDd5eFeU8PpNX7rgaYE4GPq+EEmLVCBYmdctr8QVdqJ//8Xu3+1phjDy\n+-----END CERTIFICATE-----`\n+\n var unknownAuthorityErrorTests = []struct {\n \tcert     string\n \texpected string\n@@ -1294,7 +1511,7 @@ func TestUnknownAuthorityError(t *testing.T) {\n \t\t\thintCert: c,\n \t\t}\n \t\tactual := uae.Error()\n-\t\tif strings.Compare(actual, tt.expected) != 0 {\n+\t\tif actual != tt.expected {\n \t\t\tt.Errorf(\"#%d: UnknownAuthorityError.Error() response invalid actual: %s expected: %s\", i, actual, tt.expected)\n \t\t}\n \t}"}, {"sha": "fdc7c5307bdcb984c201a6f099eddbdde78b534c", "filename": "libgo/go/crypto/x509/x509.go", "status": "modified", "additions": 87, "deletions": 55, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -3,6 +3,10 @@\n // license that can be found in the LICENSE file.\n \n // Package x509 parses X.509-encoded keys and certificates.\n+//\n+// On UNIX systems the environment variables SSL_CERT_FILE and SSL_CERT_DIR\n+// can be used to override the system default locations for the SSL certificate\n+// file and SSL certificate files directory, respectively.\n package x509\n \n import (\n@@ -59,7 +63,7 @@ func ParsePKIXPublicKey(derBytes []byte) (pub interface{}, err error) {\n func marshalPublicKey(pub interface{}) (publicKeyBytes []byte, publicKeyAlgorithm pkix.AlgorithmIdentifier, err error) {\n \tswitch pub := pub.(type) {\n \tcase *rsa.PublicKey:\n-\t\tpublicKeyBytes, err = asn1.Marshal(rsaPublicKey{\n+\t\tpublicKeyBytes, err = asn1.Marshal(pkcs1PublicKey{\n \t\t\tN: pub.N,\n \t\t\tE: pub.E,\n \t\t})\n@@ -69,9 +73,7 @@ func marshalPublicKey(pub interface{}) (publicKeyBytes []byte, publicKeyAlgorith\n \t\tpublicKeyAlgorithm.Algorithm = oidPublicKeyRSA\n \t\t// This is a NULL parameters value which is required by\n \t\t// https://tools.ietf.org/html/rfc3279#section-2.3.1.\n-\t\tpublicKeyAlgorithm.Parameters = asn1.RawValue{\n-\t\t\tTag: 5,\n-\t\t}\n+\t\tpublicKeyAlgorithm.Parameters = asn1.NullRawValue\n \tcase *ecdsa.PublicKey:\n \t\tpublicKeyBytes = elliptic.Marshal(pub.Curve, pub.X, pub.Y)\n \t\toid, ok := oidFromNamedCurve(pub.Curve)\n@@ -355,10 +357,8 @@ func rsaPSSParameters(hashFunc crypto.Hash) asn1.RawValue {\n \n \tparams := pssParameters{\n \t\tHash: pkix.AlgorithmIdentifier{\n-\t\t\tAlgorithm: hashOID,\n-\t\t\tParameters: asn1.RawValue{\n-\t\t\t\tTag: 5, /* ASN.1 NULL */\n-\t\t\t},\n+\t\t\tAlgorithm:  hashOID,\n+\t\t\tParameters: asn1.NullRawValue,\n \t\t},\n \t\tMGF: pkix.AlgorithmIdentifier{\n \t\t\tAlgorithm: oidMGF1,\n@@ -368,10 +368,8 @@ func rsaPSSParameters(hashFunc crypto.Hash) asn1.RawValue {\n \t}\n \n \tmgf1Params := pkix.AlgorithmIdentifier{\n-\t\tAlgorithm: hashOID,\n-\t\tParameters: asn1.RawValue{\n-\t\t\tTag: 5, /* ASN.1 NULL */\n-\t\t},\n+\t\tAlgorithm:  hashOID,\n+\t\tParameters: asn1.NullRawValue,\n \t}\n \n \tvar err error\n@@ -418,11 +416,10 @@ func getSignatureAlgorithmFromAI(ai pkix.AlgorithmIdentifier) SignatureAlgorithm\n \t// https://tools.ietf.org/html/rfc3447#section-8.1), that the\n \t// salt length matches the hash length, and that the trailer\n \t// field has the default value.\n-\tasn1NULL := []byte{0x05, 0x00}\n-\tif !bytes.Equal(params.Hash.Parameters.FullBytes, asn1NULL) ||\n+\tif !bytes.Equal(params.Hash.Parameters.FullBytes, asn1.NullBytes) ||\n \t\t!params.MGF.Algorithm.Equal(oidMGF1) ||\n \t\t!mgf1HashFunc.Algorithm.Equal(params.Hash.Algorithm) ||\n-\t\t!bytes.Equal(mgf1HashFunc.Parameters.FullBytes, asn1NULL) ||\n+\t\t!bytes.Equal(mgf1HashFunc.Parameters.FullBytes, asn1.NullBytes) ||\n \t\tparams.TrailerField != 1 {\n \t\treturn UnknownSignatureAlgorithm\n \t}\n@@ -668,13 +665,28 @@ type Certificate struct {\n \tExtKeyUsage        []ExtKeyUsage           // Sequence of extended key usages.\n \tUnknownExtKeyUsage []asn1.ObjectIdentifier // Encountered extended key usages unknown to this package.\n \n-\tBasicConstraintsValid bool // if true then the next two fields are valid.\n+\t// BasicConstraintsValid indicates whether IsCA, MaxPathLen,\n+\t// and MaxPathLenZero are valid.\n+\tBasicConstraintsValid bool\n \tIsCA                  bool\n-\tMaxPathLen            int\n-\t// MaxPathLenZero indicates that BasicConstraintsValid==true and\n-\t// MaxPathLen==0 should be interpreted as an actual maximum path length\n-\t// of zero. Otherwise, that combination is interpreted as MaxPathLen\n-\t// not being set.\n+\n+\t// MaxPathLen and MaxPathLenZero indicate the presence and\n+\t// value of the BasicConstraints' \"pathLenConstraint\".\n+\t//\n+\t// When parsing a certificate, a positive non-zero MaxPathLen\n+\t// means that the field was specified, -1 means it was unset,\n+\t// and MaxPathLenZero being true mean that the field was\n+\t// explicitly set to zero. The case of MaxPathLen==0 with MaxPathLenZero==false\n+\t// should be treated equivalent to -1 (unset).\n+\t//\n+\t// When generating a certificate, an unset pathLenConstraint\n+\t// can be requested with either MaxPathLen == -1 or using the\n+\t// zero value for both MaxPathLen and MaxPathLenZero.\n+\tMaxPathLen int\n+\t// MaxPathLenZero indicates that BasicConstraintsValid==true\n+\t// and MaxPathLen==0 should be interpreted as an actual\n+\t// maximum path length of zero. Otherwise, that combination is\n+\t// interpreted as MaxPathLen not being set.\n \tMaxPathLenZero bool\n \n \tSubjectKeyId   []byte\n@@ -692,6 +704,7 @@ type Certificate struct {\n \t// Name constraints\n \tPermittedDNSDomainsCritical bool // if true then the name constraints are marked critical.\n \tPermittedDNSDomains         []string\n+\tExcludedDNSDomains          []string\n \n \t// CRL Distribution Points\n \tCRLDistributionPoints []string\n@@ -723,6 +736,10 @@ func (c *Certificate) Equal(other *Certificate) bool {\n \treturn bytes.Equal(c.Raw, other.Raw)\n }\n \n+func (c *Certificate) hasSANExtension() bool {\n+\treturn oidInExtensions(oidExtensionSubjectAltName, c.Extensions)\n+}\n+\n // Entrust have a broken root certificate (CN=Entrust.net Certification\n // Authority (2048)) which isn't marked as a CA certificate and is thus invalid\n // according to PKIX.\n@@ -924,20 +941,17 @@ type distributionPointName struct {\n \tRelativeName pkix.RDNSequence `asn1:\"optional,tag:1\"`\n }\n \n-// asn1Null is the ASN.1 encoding of a NULL value.\n-var asn1Null = []byte{5, 0}\n-\n func parsePublicKey(algo PublicKeyAlgorithm, keyData *publicKeyInfo) (interface{}, error) {\n \tasn1Data := keyData.PublicKey.RightAlign()\n \tswitch algo {\n \tcase RSA:\n \t\t// RSA public keys must have a NULL in the parameters\n \t\t// (https://tools.ietf.org/html/rfc3279#section-2.3.1).\n-\t\tif !bytes.Equal(keyData.Algorithm.Parameters.FullBytes, asn1Null) {\n+\t\tif !bytes.Equal(keyData.Algorithm.Parameters.FullBytes, asn1.NullBytes) {\n \t\t\treturn nil, errors.New(\"x509: RSA key missing NULL parameters\")\n \t\t}\n \n-\t\tp := new(rsaPublicKey)\n+\t\tp := new(pkcs1PublicKey)\n \t\trest, err := asn1.Unmarshal(asn1Data, p)\n \t\tif err != nil {\n \t\t\treturn nil, err\n@@ -1150,7 +1164,7 @@ func parseCertificate(in *certificate) (*Certificate, error) {\n \t\t\t\tout.IsCA = constraints.IsCA\n \t\t\t\tout.MaxPathLen = constraints.MaxPathLen\n \t\t\t\tout.MaxPathLenZero = out.MaxPathLen == 0\n-\n+\t\t\t\t// TODO: map out.MaxPathLen to 0 if it has the -1 default value? (Issue 19285)\n \t\t\tcase 17:\n \t\t\t\tout.DNSNames, out.EmailAddresses, out.IPAddresses, err = parseSANExtension(e.Value)\n \t\t\t\tif err != nil {\n@@ -1185,19 +1199,27 @@ func parseCertificate(in *certificate) (*Certificate, error) {\n \t\t\t\t\treturn nil, errors.New(\"x509: trailing data after X.509 NameConstraints\")\n \t\t\t\t}\n \n-\t\t\t\tif len(constraints.Excluded) > 0 && e.Critical {\n-\t\t\t\t\treturn out, UnhandledCriticalExtension{}\n-\t\t\t\t}\n-\n-\t\t\t\tfor _, subtree := range constraints.Permitted {\n-\t\t\t\t\tif len(subtree.Name) == 0 {\n-\t\t\t\t\t\tif e.Critical {\n-\t\t\t\t\t\t\treturn out, UnhandledCriticalExtension{}\n+\t\t\t\tgetDNSNames := func(subtrees []generalSubtree, isCritical bool) (dnsNames []string, err error) {\n+\t\t\t\t\tfor _, subtree := range subtrees {\n+\t\t\t\t\t\tif len(subtree.Name) == 0 {\n+\t\t\t\t\t\t\tif isCritical {\n+\t\t\t\t\t\t\t\treturn nil, UnhandledCriticalExtension{}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tcontinue\n \t\t\t\t\t\t}\n-\t\t\t\t\t\tcontinue\n+\t\t\t\t\t\tdnsNames = append(dnsNames, subtree.Name)\n \t\t\t\t\t}\n-\t\t\t\t\tout.PermittedDNSDomains = append(out.PermittedDNSDomains, subtree.Name)\n+\n+\t\t\t\t\treturn dnsNames, nil\n+\t\t\t\t}\n+\n+\t\t\t\tif out.PermittedDNSDomains, err = getDNSNames(constraints.Permitted, e.Critical); err != nil {\n+\t\t\t\t\treturn out, err\n+\t\t\t\t}\n+\t\t\t\tif out.ExcludedDNSDomains, err = getDNSNames(constraints.Excluded, e.Critical); err != nil {\n+\t\t\t\t\treturn out, err\n \t\t\t\t}\n+\t\t\t\tout.PermittedDNSDomainsCritical = e.Critical\n \n \t\t\tcase 31:\n \t\t\t\t// RFC 5280, 4.2.1.13\n@@ -1451,7 +1473,7 @@ func marshalSANs(dnsNames, emailAddresses []string, ipAddresses []net.IP) (derBy\n \treturn asn1.Marshal(rawValues)\n }\n \n-func buildExtensions(template *Certificate) (ret []pkix.Extension, err error) {\n+func buildExtensions(template *Certificate, authorityKeyId []byte) (ret []pkix.Extension, err error) {\n \tret = make([]pkix.Extension, 10 /* maximum number of elements. */)\n \tn := 0\n \n@@ -1525,9 +1547,9 @@ func buildExtensions(template *Certificate) (ret []pkix.Extension, err error) {\n \t\tn++\n \t}\n \n-\tif len(template.AuthorityKeyId) > 0 && !oidInExtensions(oidExtensionAuthorityKeyId, template.ExtraExtensions) {\n+\tif len(authorityKeyId) > 0 && !oidInExtensions(oidExtensionAuthorityKeyId, template.ExtraExtensions) {\n \t\tret[n].Id = oidExtensionAuthorityKeyId\n-\t\tret[n].Value, err = asn1.Marshal(authKeyId{template.AuthorityKeyId})\n+\t\tret[n].Value, err = asn1.Marshal(authKeyId{authorityKeyId})\n \t\tif err != nil {\n \t\t\treturn\n \t\t}\n@@ -1581,16 +1603,22 @@ func buildExtensions(template *Certificate) (ret []pkix.Extension, err error) {\n \t\tn++\n \t}\n \n-\tif len(template.PermittedDNSDomains) > 0 &&\n+\tif (len(template.PermittedDNSDomains) > 0 || len(template.ExcludedDNSDomains) > 0) &&\n \t\t!oidInExtensions(oidExtensionNameConstraints, template.ExtraExtensions) {\n \t\tret[n].Id = oidExtensionNameConstraints\n \t\tret[n].Critical = template.PermittedDNSDomainsCritical\n \n \t\tvar out nameConstraints\n+\n \t\tout.Permitted = make([]generalSubtree, len(template.PermittedDNSDomains))\n \t\tfor i, permitted := range template.PermittedDNSDomains {\n \t\t\tout.Permitted[i] = generalSubtree{Name: permitted}\n \t\t}\n+\t\tout.Excluded = make([]generalSubtree, len(template.ExcludedDNSDomains))\n+\t\tfor i, excluded := range template.ExcludedDNSDomains {\n+\t\t\tout.Excluded[i] = generalSubtree{Name: excluded}\n+\t\t}\n+\n \t\tret[n].Value, err = asn1.Marshal(out)\n \t\tif err != nil {\n \t\t\treturn\n@@ -1646,9 +1674,7 @@ func signingParamsForPublicKey(pub interface{}, requestedSigAlgo SignatureAlgori\n \t\tpubType = RSA\n \t\thashFunc = crypto.SHA256\n \t\tsigAlgo.Algorithm = oidSignatureSHA256WithRSA\n-\t\tsigAlgo.Parameters = asn1.RawValue{\n-\t\t\tTag: 5,\n-\t\t}\n+\t\tsigAlgo.Parameters = asn1.NullRawValue\n \n \tcase *ecdsa.PublicKey:\n \t\tpubType = ECDSA\n@@ -1706,11 +1732,12 @@ func signingParamsForPublicKey(pub interface{}, requestedSigAlgo SignatureAlgori\n \treturn\n }\n \n-// CreateCertificate creates a new certificate based on a template. The\n-// following members of template are used: SerialNumber, Subject, NotBefore,\n-// NotAfter, KeyUsage, ExtKeyUsage, UnknownExtKeyUsage, BasicConstraintsValid,\n-// IsCA, MaxPathLen, SubjectKeyId, DNSNames, PermittedDNSDomainsCritical,\n-// PermittedDNSDomains, SignatureAlgorithm.\n+// CreateCertificate creates a new certificate based on a template.\n+// The following members of template are used: AuthorityKeyId,\n+// BasicConstraintsValid, DNSNames, ExcludedDNSDomains, ExtKeyUsage,\n+// IsCA, KeyUsage, MaxPathLen, MaxPathLenZero, NotAfter, NotBefore,\n+// PermittedDNSDomains, PermittedDNSDomainsCritical, SerialNumber,\n+// SignatureAlgorithm, Subject, SubjectKeyId, and UnknownExtKeyUsage.\n //\n // The certificate is signed by parent. If parent is equal to template then the\n // certificate is self-signed. The parameter pub is the public key of the\n@@ -1720,6 +1747,10 @@ func signingParamsForPublicKey(pub interface{}, requestedSigAlgo SignatureAlgori\n //\n // All keys types that are implemented via crypto.Signer are supported (This\n // includes *rsa.PublicKey and *ecdsa.PublicKey.)\n+//\n+// The AuthorityKeyId will be taken from the SubjectKeyId of parent, if any,\n+// unless the resulting certificate is self-signed. Otherwise the value from\n+// template will be used.\n func CreateCertificate(rand io.Reader, template, parent *Certificate, pub, priv interface{}) (cert []byte, err error) {\n \tkey, ok := priv.(crypto.Signer)\n \tif !ok {\n@@ -1750,11 +1781,12 @@ func CreateCertificate(rand io.Reader, template, parent *Certificate, pub, priv\n \t\treturn\n \t}\n \n+\tauthorityKeyId := template.AuthorityKeyId\n \tif !bytes.Equal(asn1Issuer, asn1Subject) && len(parent.SubjectKeyId) > 0 {\n-\t\ttemplate.AuthorityKeyId = parent.SubjectKeyId\n+\t\tauthorityKeyId = parent.SubjectKeyId\n \t}\n \n-\textensions, err := buildExtensions(template)\n+\textensions, err := buildExtensions(template, authorityKeyId)\n \tif err != nil {\n \t\treturn\n \t}\n@@ -2025,10 +2057,10 @@ func parseCSRExtensions(rawAttributes []asn1.RawValue) ([]pkix.Extension, error)\n \treturn ret, nil\n }\n \n-// CreateCertificateRequest creates a new certificate request based on a template.\n-// The following members of template are used: Subject, Attributes,\n-// SignatureAlgorithm, Extensions, DNSNames, EmailAddresses, and IPAddresses.\n-// The private key is the private key of the signer.\n+// CreateCertificateRequest creates a new certificate request based on a\n+// template. The following members of template are used: Attributes, DNSNames,\n+// EmailAddresses, ExtraExtensions, IPAddresses, SignatureAlgorithm, and\n+// Subject. The private key is the private key of the signer.\n //\n // The returned slice is the certificate request in DER encoding.\n //"}, {"sha": "2d1acf93bf599fb9f138a53c77d0662d740465d4", "filename": "libgo/go/crypto/x509/x509_test.go", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509_test.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -405,6 +405,7 @@ func TestCreateSelfSignedCertificate(t *testing.T) {\n \n \t\t\tPolicyIdentifiers:   []asn1.ObjectIdentifier{[]int{1, 2, 3}},\n \t\t\tPermittedDNSDomains: []string{\".example.com\", \"example.com\"},\n+\t\t\tExcludedDNSDomains:  []string{\"bar.example.com\"},\n \n \t\t\tCRLDistributionPoints: []string{\"http://crl1.example.com/ca1.crl\", \"http://crl2.example.com/ca1.crl\"},\n \n@@ -442,6 +443,10 @@ func TestCreateSelfSignedCertificate(t *testing.T) {\n \t\t\tt.Errorf(\"%s: failed to parse name constraints: %#v\", test.name, cert.PermittedDNSDomains)\n \t\t}\n \n+\t\tif len(cert.ExcludedDNSDomains) != 1 || cert.ExcludedDNSDomains[0] != \"bar.example.com\" {\n+\t\t\tt.Errorf(\"%s: failed to parse name constraint exclusions: %#v\", test.name, cert.ExcludedDNSDomains)\n+\t\t}\n+\n \t\tif cert.Subject.CommonName != commonName {\n \t\t\tt.Errorf(\"%s: subject wasn't correctly copied from the template. Got %s, want %s\", test.name, cert.Subject.CommonName, commonName)\n \t\t}"}, {"sha": "4983181fe750b167b31021957db80ce1c5460c45", "filename": "libgo/go/database/sql/convert.go", "status": "modified", "additions": 162, "deletions": 53, "changes": 215, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fdatabase%2Fsql%2Fconvert.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fdatabase%2Fsql%2Fconvert.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdatabase%2Fsql%2Fconvert.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -12,6 +12,7 @@ import (\n \t\"fmt\"\n \t\"reflect\"\n \t\"strconv\"\n+\t\"sync\"\n \t\"time\"\n \t\"unicode\"\n \t\"unicode/utf8\"\n@@ -37,86 +38,180 @@ func validateNamedValueName(name string) error {\n \treturn fmt.Errorf(\"name %q does not begin with a letter\", name)\n }\n \n+func driverNumInput(ds *driverStmt) int {\n+\tds.Lock()\n+\tdefer ds.Unlock() // in case NumInput panics\n+\treturn ds.si.NumInput()\n+}\n+\n+// ccChecker wraps the driver.ColumnConverter and allows it to be used\n+// as if it were a NamedValueChecker. If the driver ColumnConverter\n+// is not present then the NamedValueChecker will return driver.ErrSkip.\n+type ccChecker struct {\n+\tsync.Locker\n+\tcci  driver.ColumnConverter\n+\twant int\n+}\n+\n+func (c ccChecker) CheckNamedValue(nv *driver.NamedValue) error {\n+\tif c.cci == nil {\n+\t\treturn driver.ErrSkip\n+\t}\n+\t// The column converter shouldn't be called on any index\n+\t// it isn't expecting. The final error will be thrown\n+\t// in the argument converter loop.\n+\tindex := nv.Ordinal - 1\n+\tif c.want <= index {\n+\t\treturn nil\n+\t}\n+\n+\t// First, see if the value itself knows how to convert\n+\t// itself to a driver type. For example, a NullString\n+\t// struct changing into a string or nil.\n+\tif vr, ok := nv.Value.(driver.Valuer); ok {\n+\t\tsv, err := callValuerValue(vr)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif !driver.IsValue(sv) {\n+\t\t\treturn fmt.Errorf(\"non-subset type %T returned from Value\", sv)\n+\t\t}\n+\t\tnv.Value = sv\n+\t}\n+\n+\t// Second, ask the column to sanity check itself. For\n+\t// example, drivers might use this to make sure that\n+\t// an int64 values being inserted into a 16-bit\n+\t// integer field is in range (before getting\n+\t// truncated), or that a nil can't go into a NOT NULL\n+\t// column before going across the network to get the\n+\t// same error.\n+\tvar err error\n+\targ := nv.Value\n+\tc.Lock()\n+\tnv.Value, err = c.cci.ColumnConverter(index).ConvertValue(arg)\n+\tc.Unlock()\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tif !driver.IsValue(nv.Value) {\n+\t\treturn fmt.Errorf(\"driver ColumnConverter error converted %T to unsupported type %T\", arg, nv.Value)\n+\t}\n+\treturn nil\n+}\n+\n+// defaultCheckNamedValue wraps the default ColumnConverter to have the same\n+// function signature as the CheckNamedValue in the driver.NamedValueChecker\n+// interface.\n+func defaultCheckNamedValue(nv *driver.NamedValue) (err error) {\n+\tnv.Value, err = driver.DefaultParameterConverter.ConvertValue(nv.Value)\n+\treturn err\n+}\n+\n // driverArgs converts arguments from callers of Stmt.Exec and\n // Stmt.Query into driver Values.\n //\n // The statement ds may be nil, if no statement is available.\n-func driverArgs(ds *driverStmt, args []interface{}) ([]driver.NamedValue, error) {\n+func driverArgs(ci driver.Conn, ds *driverStmt, args []interface{}) ([]driver.NamedValue, error) {\n \tnvargs := make([]driver.NamedValue, len(args))\n+\n+\t// -1 means the driver doesn't know how to count the number of\n+\t// placeholders, so we won't sanity check input here and instead let the\n+\t// driver deal with errors.\n+\twant := -1\n+\n \tvar si driver.Stmt\n+\tvar cc ccChecker\n \tif ds != nil {\n \t\tsi = ds.si\n+\t\twant = driverNumInput(ds)\n+\t\tcc.Locker = ds.Locker\n+\t\tcc.want = want\n \t}\n-\tcc, ok := si.(driver.ColumnConverter)\n \n-\t// Normal path, for a driver.Stmt that is not a ColumnConverter.\n+\t// Check all types of interfaces from the start.\n+\t// Drivers may opt to use the NamedValueChecker for special\n+\t// argument types, then return driver.ErrSkip to pass it along\n+\t// to the column converter.\n+\tnvc, ok := si.(driver.NamedValueChecker)\n \tif !ok {\n-\t\tfor n, arg := range args {\n-\t\t\tvar err error\n-\t\t\tnv := &nvargs[n]\n-\t\t\tnv.Ordinal = n + 1\n-\t\t\tif np, ok := arg.(NamedArg); ok {\n-\t\t\t\tif err := validateNamedValueName(np.Name); err != nil {\n-\t\t\t\t\treturn nil, err\n-\t\t\t\t}\n-\t\t\t\targ = np.Value\n-\t\t\t\tnvargs[n].Name = np.Name\n-\t\t\t}\n-\t\t\tnv.Value, err = driver.DefaultParameterConverter.ConvertValue(arg)\n-\n-\t\t\tif err != nil {\n-\t\t\t\treturn nil, fmt.Errorf(\"sql: converting Exec argument %s type: %v\", describeNamedValue(nv), err)\n-\t\t\t}\n-\t\t}\n-\t\treturn nvargs, nil\n+\t\tnvc, ok = ci.(driver.NamedValueChecker)\n+\t}\n+\tcci, ok := si.(driver.ColumnConverter)\n+\tif ok {\n+\t\tcc.cci = cci\n \t}\n \n-\t// Let the Stmt convert its own arguments.\n-\tfor n, arg := range args {\n+\t// Loop through all the arguments, checking each one.\n+\t// If no error is returned simply increment the index\n+\t// and continue. However if driver.ErrRemoveArgument\n+\t// is returned the argument is not included in the query\n+\t// argument list.\n+\tvar err error\n+\tvar n int\n+\tfor _, arg := range args {\n \t\tnv := &nvargs[n]\n-\t\tnv.Ordinal = n + 1\n \t\tif np, ok := arg.(NamedArg); ok {\n-\t\t\tif err := validateNamedValueName(np.Name); err != nil {\n+\t\t\tif err = validateNamedValueName(np.Name); err != nil {\n \t\t\t\treturn nil, err\n \t\t\t}\n \t\t\targ = np.Value\n \t\t\tnv.Name = np.Name\n \t\t}\n-\t\t// First, see if the value itself knows how to convert\n-\t\t// itself to a driver type. For example, a NullString\n-\t\t// struct changing into a string or nil.\n-\t\tif vr, ok := arg.(driver.Valuer); ok {\n-\t\t\tsv, err := callValuerValue(vr)\n-\t\t\tif err != nil {\n-\t\t\t\treturn nil, fmt.Errorf(\"sql: argument %s from Value: %v\", describeNamedValue(nv), err)\n-\t\t\t}\n-\t\t\tif !driver.IsValue(sv) {\n-\t\t\t\treturn nil, fmt.Errorf(\"sql: argument %s: non-subset type %T returned from Value\", describeNamedValue(nv), sv)\n-\t\t\t}\n-\t\t\targ = sv\n+\t\tnv.Ordinal = n + 1\n+\t\tnv.Value = arg\n+\n+\t\t// Checking sequence has four routes:\n+\t\t// A: 1. Default\n+\t\t// B: 1. NamedValueChecker 2. Column Converter 3. Default\n+\t\t// C: 1. NamedValueChecker 3. Default\n+\t\t// D: 1. Column Converter 2. Default\n+\t\t//\n+\t\t// The only time a Column Converter is called is first\n+\t\t// or after NamedValueConverter. If first it is handled before\n+\t\t// the nextCheck label. Thus for repeats tries only when the\n+\t\t// NamedValueConverter is selected should the Column Converter\n+\t\t// be used in the retry.\n+\t\tchecker := defaultCheckNamedValue\n+\t\tnextCC := false\n+\t\tswitch {\n+\t\tcase nvc != nil:\n+\t\t\tnextCC = cci != nil\n+\t\t\tchecker = nvc.CheckNamedValue\n+\t\tcase cci != nil:\n+\t\t\tchecker = cc.CheckNamedValue\n \t\t}\n \n-\t\t// Second, ask the column to sanity check itself. For\n-\t\t// example, drivers might use this to make sure that\n-\t\t// an int64 values being inserted into a 16-bit\n-\t\t// integer field is in range (before getting\n-\t\t// truncated), or that a nil can't go into a NOT NULL\n-\t\t// column before going across the network to get the\n-\t\t// same error.\n-\t\tvar err error\n-\t\tds.Lock()\n-\t\tnv.Value, err = cc.ColumnConverter(n).ConvertValue(arg)\n-\t\tds.Unlock()\n-\t\tif err != nil {\n+\tnextCheck:\n+\t\terr = checker(nv)\n+\t\tswitch err {\n+\t\tcase nil:\n+\t\t\tn++\n+\t\t\tcontinue\n+\t\tcase driver.ErrRemoveArgument:\n+\t\t\tnvargs = nvargs[:len(nvargs)-1]\n+\t\t\tcontinue\n+\t\tcase driver.ErrSkip:\n+\t\t\tif nextCC {\n+\t\t\t\tnextCC = false\n+\t\t\t\tchecker = cc.CheckNamedValue\n+\t\t\t} else {\n+\t\t\t\tchecker = defaultCheckNamedValue\n+\t\t\t}\n+\t\t\tgoto nextCheck\n+\t\tdefault:\n \t\t\treturn nil, fmt.Errorf(\"sql: converting argument %s type: %v\", describeNamedValue(nv), err)\n \t\t}\n-\t\tif !driver.IsValue(nv.Value) {\n-\t\t\treturn nil, fmt.Errorf(\"sql: for argument %s, driver ColumnConverter error converted %T to unsupported type %T\",\n-\t\t\t\tdescribeNamedValue(nv), arg, nv.Value)\n-\t\t}\n+\t}\n+\n+\t// Check the length of arguments after convertion to allow for omitted\n+\t// arguments.\n+\tif want != -1 && len(nvargs) != want {\n+\t\treturn nil, fmt.Errorf(\"sql: expected %d arguments, got %d\", want, len(nvargs))\n \t}\n \n \treturn nvargs, nil\n+\n }\n \n // convertAssign copies to dest the value in src, converting it if possible.\n@@ -270,6 +365,11 @@ func convertAssign(dest, src interface{}) error {\n \t\treturn nil\n \t}\n \n+\t// The following conversions use a string value as an intermediate representation\n+\t// to convert between various numeric types.\n+\t//\n+\t// This also allows scanning into user defined types such as \"type Int int64\".\n+\t// For symmetry, also check for string destination types.\n \tswitch dv.Kind() {\n \tcase reflect.Ptr:\n \t\tif src == nil {\n@@ -306,6 +406,15 @@ func convertAssign(dest, src interface{}) error {\n \t\t}\n \t\tdv.SetFloat(f64)\n \t\treturn nil\n+\tcase reflect.String:\n+\t\tswitch v := src.(type) {\n+\t\tcase string:\n+\t\t\tdv.SetString(v)\n+\t\t\treturn nil\n+\t\tcase []byte:\n+\t\t\tdv.SetString(string(v))\n+\t\t\treturn nil\n+\t\t}\n \t}\n \n \treturn fmt.Errorf(\"unsupported Scan, storing driver.Value type %T into type %T\", src, dest)"}, {"sha": "cfe52d7f548aab6fa843e63b4ffaf8ab50030410", "filename": "libgo/go/database/sql/convert_test.go", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fdatabase%2Fsql%2Fconvert_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fdatabase%2Fsql%2Fconvert_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdatabase%2Fsql%2Fconvert_test.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -10,16 +10,19 @@ import (\n \t\"reflect\"\n \t\"runtime\"\n \t\"strings\"\n+\t\"sync\"\n \t\"testing\"\n \t\"time\"\n )\n \n var someTime = time.Unix(123, 0)\n var answer int64 = 42\n \n-type userDefined float64\n-\n-type userDefinedSlice []int\n+type (\n+\tuserDefined       float64\n+\tuserDefinedSlice  []int\n+\tuserDefinedString string\n+)\n \n type conversionTest struct {\n \ts, d interface{} // source and destination\n@@ -39,6 +42,7 @@ type conversionTest struct {\n \twantptr    *int64 // if non-nil, *d's pointed value must be equal to *wantptr\n \twantnil    bool   // if true, *d must be *int64(nil)\n \twantusrdef userDefined\n+\twantusrstr userDefinedString\n }\n \n // Target variables for scanning into.\n@@ -171,6 +175,7 @@ var conversionTests = []conversionTest{\n \t{s: int64(123), d: new(userDefined), wantusrdef: 123},\n \t{s: \"1.5\", d: new(userDefined), wantusrdef: 1.5},\n \t{s: []byte{1, 2, 3}, d: new(userDefinedSlice), wanterr: `unsupported Scan, storing driver.Value type []uint8 into type *sql.userDefinedSlice`},\n+\t{s: \"str\", d: new(userDefinedString), wantusrstr: \"str\"},\n \n \t// Other errors\n \t{s: complex(1, 2), d: &scanstr, wanterr: `unsupported Scan, storing driver.Value type complex128 into type *string`},\n@@ -260,6 +265,9 @@ func TestConversions(t *testing.T) {\n \t\tif ct.wantusrdef != 0 && ct.wantusrdef != *ct.d.(*userDefined) {\n \t\t\terrf(\"want userDefined %f, got %f\", ct.wantusrdef, *ct.d.(*userDefined))\n \t\t}\n+\t\tif len(ct.wantusrstr) != 0 && ct.wantusrstr != *ct.d.(*userDefinedString) {\n+\t\t\terrf(\"want userDefined %q, got %q\", ct.wantusrstr, *ct.d.(*userDefinedString))\n+\t\t}\n \t}\n }\n \n@@ -461,8 +469,8 @@ func TestDriverArgs(t *testing.T) {\n \t\t},\n \t}\n \tfor i, tt := range tests {\n-\t\tds := new(driverStmt)\n-\t\tgot, err := driverArgs(ds, tt.args)\n+\t\tds := &driverStmt{Locker: &sync.Mutex{}, si: stubDriverStmt{nil}}\n+\t\tgot, err := driverArgs(nil, ds, tt.args)\n \t\tif err != nil {\n \t\t\tt.Errorf(\"test[%d]: %v\", i, err)\n \t\t\tcontinue"}, {"sha": "0262ca24ba294661c0c3c8bf3f8d2c7b1e84b68d", "filename": "libgo/go/database/sql/driver/driver.go", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fdatabase%2Fsql%2Fdriver%2Fdriver.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fdatabase%2Fsql%2Fdriver%2Fdriver.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdatabase%2Fsql%2Fdriver%2Fdriver.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01", "patch": "@@ -262,9 +262,39 @@ type StmtQueryContext interface {\n \tQueryContext(ctx context.Context, args []NamedValue) (Rows, error)\n }\n \n+// ErrRemoveArgument may be returned from NamedValueChecker to instruct the\n+// sql package to not pass the argument to the driver query interface.\n+// Return when accepting query specific options or structures that aren't\n+// SQL query arguments.\n+var ErrRemoveArgument = errors.New(\"driver: remove argument from query\")\n+\n+// NamedValueChecker may be optionally implemented by Conn or Stmt. It provides\n+// the driver more control to handle Go and database types beyond the default\n+// Values types allowed.\n+//\n+// The sql package checks for value checkers in the following order,\n+// stopping at the first found match: Stmt.NamedValueChecker, Conn.NamedValueChecker,\n+// Stmt.ColumnConverter, DefaultParameterConverter.\n+//\n+// If CheckNamedValue returns ErrRemoveArgument, the NamedValue will not be included in\n+// the final query arguments. This may be used to pass special options to\n+// the query itself.\n+//\n+// If ErrSkip is returned the column converter error checking\n+// path is used for the argument. Drivers may wish to return ErrSkip after\n+// they have exhausted their own special cases.\n+type NamedValueChecker interface {\n+\t// CheckNamedValue is called before passing arguments to the driver\n+\t// and is called in place of any ColumnConverter. CheckNamedValue must do type\n+\t// validation and conversion as appropriate for the driver.\n+\tCheckNamedValue(*NamedValue) error\n+}\n+\n // ColumnConverter may be optionally implemented by Stmt if the\n // statement is aware of its own columns' types and can convert from\n // any type to a driver Value.\n+//\n+// Deprecated: Drivers should implement NamedValueChecker.\n type ColumnConverter interface {\n \t// ColumnConverter returns a ValueConverter for the provided\n \t// column index. If the type of a specific column isn't known"}, {"sha": "4dcd096ca4d20db0e4fa4d8dc0f3a37ff32f3a50", "filename": "libgo/go/database/sql/fakedb_test.go", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fdatabase%2Fsql%2Ffakedb_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fdatabase%2Fsql%2Ffakedb_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdatabase%2Fsql%2Ffakedb_test.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "c609fe4cc43198fbc2845f7a050b6fda974c3b3a", "filename": "libgo/go/database/sql/sql.go", "status": "modified", "additions": 497, "deletions": 187, "changes": 684, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "c935eb4348025756269926628187719ed7d8754d", "filename": "libgo/go/database/sql/sql_test.go", "status": "modified", "additions": 630, "deletions": 20, "changes": 650, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql_test.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "b8a25ff531de97a51f84e1a9bc7c6f4a13aab39e", "filename": "libgo/go/debug/dwarf/export_test.go", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fdebug%2Fdwarf%2Fexport_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fdebug%2Fdwarf%2Fexport_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fdwarf%2Fexport_test.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "4e6e1429d93b97beca5c277e08fa1ccd999aff86", "filename": "libgo/go/debug/dwarf/line.go", "status": "modified", "additions": 70, "deletions": 4, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fdebug%2Fdwarf%2Fline.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fdebug%2Fdwarf%2Fline.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fdwarf%2Fline.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "11a254464a254cdeff75aee30426ec4af2fd847c", "filename": "libgo/go/debug/dwarf/line_test.go", "status": "modified", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fdebug%2Fdwarf%2Fline_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fdebug%2Fdwarf%2Fline_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fdwarf%2Fline_test.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "583ad44dd07dabb77cadb01043a45e50295ae7d4", "filename": "libgo/go/debug/dwarf/testdata/line-gcc-win.bin", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fdebug%2Fdwarf%2Ftestdata%2Fline-gcc-win.bin", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fdebug%2Fdwarf%2Ftestdata%2Fline-gcc-win.bin", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fdwarf%2Ftestdata%2Fline-gcc-win.bin?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "6c06731ea18b86d06216917b421414761a3b754b", "filename": "libgo/go/debug/dwarf/type_test.go", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fdebug%2Fdwarf%2Ftype_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fdebug%2Fdwarf%2Ftype_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fdwarf%2Ftype_test.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "739671d73f155d95d3e42c7bfee9e72d50f414ff", "filename": "libgo/go/debug/pe/file_cgo_test.go", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fdebug%2Fpe%2Ffile_cgo_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fdebug%2Fpe%2Ffile_cgo_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fpe%2Ffile_cgo_test.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "8645d676b752b2cf9624ff6ab040a7a5a8cea4c9", "filename": "libgo/go/debug/pe/file_test.go", "status": "modified", "additions": 129, "deletions": 12, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fdebug%2Fpe%2Ffile_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fdebug%2Fpe%2Ffile_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fpe%2Ffile_test.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "1a3a87a596d52072b99ebfebe9a6a822d4ac22b6", "filename": "libgo/go/encoding/ascii85/ascii85_test.go", "status": "modified", "additions": 21, "deletions": 16, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fencoding%2Fascii85%2Fascii85_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fencoding%2Fascii85%2Fascii85_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fascii85%2Fascii85_test.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "b8e2770596e2e5839403b502bce116178fee1288", "filename": "libgo/go/encoding/asn1/asn1.go", "status": "modified", "additions": 26, "deletions": 9, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fencoding%2Fasn1%2Fasn1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fencoding%2Fasn1%2Fasn1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fasn1%2Fasn1.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "c9eda4069dc99f49d56268b5b259ed360d2e5e7e", "filename": "libgo/go/encoding/asn1/asn1_test.go", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fencoding%2Fasn1%2Fasn1_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fencoding%2Fasn1%2Fasn1_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fasn1%2Fasn1_test.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "cd93b27ecb85a617568d825345a64f60fa09c86f", "filename": "libgo/go/encoding/asn1/common.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fencoding%2Fasn1%2Fcommon.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fencoding%2Fasn1%2Fcommon.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fasn1%2Fcommon.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "fdadb3996efcf8afbf9f6c11beec3b20f7abb47c", "filename": "libgo/go/encoding/asn1/marshal.go", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fencoding%2Fasn1%2Fmarshal.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fencoding%2Fasn1%2Fmarshal.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fasn1%2Fmarshal.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "bf341b54f3d488646708a488891d3ea646fd0392", "filename": "libgo/go/encoding/base32/base32.go", "status": "modified", "additions": 121, "deletions": 41, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fencoding%2Fbase32%2Fbase32.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fencoding%2Fbase32%2Fbase32.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fbase32%2Fbase32.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "56b229d15a6eee1bd45d43a4c440f79544e5235c", "filename": "libgo/go/encoding/base32/base32_test.go", "status": "modified", "additions": 281, "deletions": 3, "changes": 284, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fencoding%2Fbase32%2Fbase32_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fencoding%2Fbase32%2Fbase32_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fbase32%2Fbase32_test.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "b208f9e4d8dff46f37d866a8333dfa2ee006892d", "filename": "libgo/go/encoding/base64/base64.go", "status": "modified", "additions": 43, "deletions": 19, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fencoding%2Fbase64%2Fbase64.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fencoding%2Fbase64%2Fbase64.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fbase64%2Fbase64.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "05011fbdf38d8fd48728c3d4f41201d7c53f447b", "filename": "libgo/go/encoding/base64/base64_test.go", "status": "modified", "additions": 30, "deletions": 10, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fencoding%2Fbase64%2Fbase64_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fencoding%2Fbase64%2Fbase64_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fbase64%2Fbase64_test.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "2d01a3cb287b5dc32201e64c50a8ae5db65ab6a5", "filename": "libgo/go/encoding/binary/binary.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fencoding%2Fbinary%2Fbinary.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fencoding%2Fbinary%2Fbinary.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fbinary%2Fbinary.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "0547bee43706ed6b461d78f864125dfe523cc6b1", "filename": "libgo/go/encoding/binary/binary_test.go", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fencoding%2Fbinary%2Fbinary_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fencoding%2Fbinary%2Fbinary_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fbinary%2Fbinary_test.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "bcb8ac9a459c5c20ceefe3e9ad9f69e5177b9c83", "filename": "libgo/go/encoding/binary/varint.go", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fencoding%2Fbinary%2Fvarint.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fencoding%2Fbinary%2Fvarint.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fbinary%2Fvarint.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "a3497c84f9604f872166ff053f696fc75fd0407e", "filename": "libgo/go/encoding/csv/reader.go", "status": "modified", "additions": 49, "deletions": 20, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fencoding%2Fcsv%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fencoding%2Fcsv%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fcsv%2Freader.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "5ab1b61256c2b39ceb47d399d859c1d477b87fca", "filename": "libgo/go/encoding/csv/reader_test.go", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fencoding%2Fcsv%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fencoding%2Fcsv%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fcsv%2Freader_test.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "eb9f306bcf5fcbf64a35e051e5261e6aad57ab2b", "filename": "libgo/go/encoding/gob/codec_test.go", "status": "modified", "additions": 52, "deletions": 22, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fencoding%2Fgob%2Fcodec_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fencoding%2Fgob%2Fcodec_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Fcodec_test.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "8dece42e908b87b8ad014eede09b004aab3131ad", "filename": "libgo/go/encoding/gob/decode.go", "status": "modified", "additions": 26, "deletions": 23, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fencoding%2Fgob%2Fdecode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fencoding%2Fgob%2Fdecode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Fdecode.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "8e0b1dd375067b0e6ee6b161cb2c2f21f80e2a58", "filename": "libgo/go/encoding/gob/decoder.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fencoding%2Fgob%2Fdecoder.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fencoding%2Fgob%2Fdecoder.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Fdecoder.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "db734ecc1ec7a0444f9869aa35102183e5945176", "filename": "libgo/go/encoding/gob/doc.go", "status": "modified", "additions": 48, "deletions": 42, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fencoding%2Fgob%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fencoding%2Fgob%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Fdoc.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "5371e7245f4ebb6e4744b72870b09e52241c9f40", "filename": "libgo/go/encoding/gob/encode.go", "status": "modified", "additions": 12, "deletions": 18, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fencoding%2Fgob%2Fencode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fencoding%2Fgob%2Fencode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Fencode.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "a1ca252ccd11c2b0d83f2913d580cd42c8d6ae08", "filename": "libgo/go/encoding/gob/encoder_test.go", "status": "modified", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fencoding%2Fgob%2Fencoder_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fencoding%2Fgob%2Fencoder_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Fencoder_test.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "949333bc0370177b93eaad841b431dd39e5b5e89", "filename": "libgo/go/encoding/gob/error.go", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fencoding%2Fgob%2Ferror.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fencoding%2Fgob%2Ferror.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Ferror.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "41a06b26c876ee65d1dd07dcbe5221e3e8d53789", "filename": "libgo/go/encoding/gob/gobencdec_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fencoding%2Fgob%2Fgobencdec_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fencoding%2Fgob%2Fgobencdec_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Fgobencdec_test.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "3478bd247ed8562c0a0336ca73bd55edc97dd9ad", "filename": "libgo/go/encoding/gob/timing_test.go", "status": "modified", "additions": 68, "deletions": 120, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fencoding%2Fgob%2Ftiming_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fencoding%2Fgob%2Ftiming_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Ftiming_test.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "31c0ef7af1513f462f008a85c485d2549bbcc919", "filename": "libgo/go/encoding/gob/type.go", "status": "modified", "additions": 23, "deletions": 33, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fencoding%2Fgob%2Ftype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fencoding%2Fgob%2Ftype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Ftype.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "14f25d8ac4c7fee172041d63cf08d54852a5630c", "filename": "libgo/go/encoding/gob/type_test.go", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fencoding%2Fgob%2Ftype_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fencoding%2Fgob%2Ftype_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Ftype_test.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "2768f1bac69927c5ba6d59c05ce250861c8228a7", "filename": "libgo/go/encoding/hex/hex.go", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fencoding%2Fhex%2Fhex.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fencoding%2Fhex%2Fhex.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fhex%2Fhex.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "85d7ae043b8caa77ca263e37ac11bd91c6b7fff2", "filename": "libgo/go/encoding/json/bench_test.go", "status": "modified", "additions": 83, "deletions": 54, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fencoding%2Fjson%2Fbench_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fencoding%2Fjson%2Fbench_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Fbench_test.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "420a07e1549c451bb2173cd3f00c3048ae6e9b26", "filename": "libgo/go/encoding/json/decode.go", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "0371f0a24dd3543f79402bc066fc3fae7779eeda", "filename": "libgo/go/encoding/json/encode.go", "status": "modified", "additions": 35, "deletions": 22, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fencoding%2Fjson%2Fencode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fencoding%2Fjson%2Fencode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Fencode.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "3fda6a0c719d431af2f04fec90ba53bca652c80a", "filename": "libgo/go/encoding/json/encode_test.go", "status": "modified", "additions": 160, "deletions": 16, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fencoding%2Fjson%2Fencode_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fencoding%2Fjson%2Fencode_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Fencode_test.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "ae34418d1da633f445afcee71e39410da6e3999e", "filename": "libgo/go/encoding/json/scanner.go", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fencoding%2Fjson%2Fscanner.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fencoding%2Fjson%2Fscanner.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Fscanner.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "0d4518a632b59c57339d4d151ca2e64d806d43ca", "filename": "libgo/go/encoding/json/scanner_test.go", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fencoding%2Fjson%2Fscanner_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fencoding%2Fjson%2Fscanner_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Fscanner_test.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "d0b3ffbce93a921c01897cceccdb3e0c33a49299", "filename": "libgo/go/encoding/json/stream_test.go", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fencoding%2Fjson%2Fstream_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fencoding%2Fjson%2Fstream_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Fstream_test.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "5e1ab90cffc08effcdf911bbc086a18984876089", "filename": "libgo/go/encoding/pem/pem.go", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fencoding%2Fpem%2Fpem.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fencoding%2Fpem%2Fpem.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fpem%2Fpem.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "1a1250a52f4d266e47bf6e3ec6ea58c328afa9e3", "filename": "libgo/go/encoding/pem/pem_test.go", "status": "modified", "additions": 31, "deletions": 3, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fencoding%2Fpem%2Fpem_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fencoding%2Fpem%2Fpem_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fpem%2Fpem_test.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "674c6b5b3f4de3a401613babb8260738ec1c7234", "filename": "libgo/go/encoding/xml/marshal_test.go", "status": "modified", "additions": 53, "deletions": 47, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fencoding%2Fxml%2Fmarshal_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fencoding%2Fxml%2Fmarshal_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fxml%2Fmarshal_test.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "000d9fbd0ef509bf5ed48871dbce75e6591f0f53", "filename": "libgo/go/encoding/xml/read.go", "status": "modified", "additions": 23, "deletions": 5, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fencoding%2Fxml%2Fread.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fencoding%2Fxml%2Fread.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fxml%2Fread.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "a1eb51618773c182c18a3eda7f53cdda90dba449", "filename": "libgo/go/encoding/xml/read_test.go", "status": "modified", "additions": 156, "deletions": 0, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fencoding%2Fxml%2Fread_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fencoding%2Fxml%2Fread_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fxml%2Fread_test.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "751caa97aa1b5e7bedaeb9c6d2798ef4c395b2e1", "filename": "libgo/go/encoding/xml/typeinfo.go", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fencoding%2Fxml%2Ftypeinfo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fencoding%2Fxml%2Ftypeinfo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fxml%2Ftypeinfo.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "dad6ed98c1bffe1f45b82001b14184937c524112", "filename": "libgo/go/encoding/xml/xml_test.go", "status": "modified", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fencoding%2Fxml%2Fxml_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fencoding%2Fxml%2Fxml_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fxml%2Fxml_test.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "64dae70c627063e5100315e8d8b2de3f17877dd1", "filename": "libgo/go/expvar/expvar.go", "status": "modified", "additions": 58, "deletions": 84, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fexpvar%2Fexpvar.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fexpvar%2Fexpvar.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexpvar%2Fexpvar.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "7014063d4f7276a3f0dd897a9145700ff9e771b8", "filename": "libgo/go/expvar/expvar_test.go", "status": "modified", "additions": 128, "deletions": 40, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fexpvar%2Fexpvar_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fexpvar%2Fexpvar_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexpvar%2Fexpvar_test.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "b166c5753adfb71b84f8533303e307bf1fc365aa", "filename": "libgo/go/flag/flag.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fflag%2Fflag.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fflag%2Fflag.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fflag%2Fflag.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "02da2c775063dd1e9b77d04bc8a314ba09fe14a3", "filename": "libgo/go/flag/flag_test.go", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fflag%2Fflag_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fflag%2Fflag_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fflag%2Fflag_test.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "014ba06948d42880b2add0ea85826b17fba0968d", "filename": "libgo/go/fmt/doc.go", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Ffmt%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Ffmt%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Fdoc.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "9e6fcfa70162fbc86544ed96c78ad39e743999fd", "filename": "libgo/go/fmt/fmt_test.go", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Ffmt%2Ffmt_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Ffmt%2Ffmt_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Ffmt_test.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "d4b92f812148f392bd4ace92a3cb3ae8a7b0f976", "filename": "libgo/go/fmt/format.go", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Ffmt%2Fformat.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Ffmt%2Fformat.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Fformat.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "2bd88f95a2b80a425e4df8cd35d2b0a77861620a", "filename": "libgo/go/fmt/print.go", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Ffmt%2Fprint.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Ffmt%2Fprint.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Fprint.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "9ab7b1e62568fe75754f002e605569e36944ea16", "filename": "libgo/go/go/ast/ast.go", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Fast%2Fast.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Fast%2Fast.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fast%2Fast.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "5aa32d0ae444804815e6c468566384feaf8da1e6", "filename": "libgo/go/go/build/build.go", "status": "modified", "additions": 63, "deletions": 21, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "38e2e8ad88197be2e1c3e2448ddadf43d27d92f4", "filename": "libgo/go/go/build/build_test.go", "status": "modified", "additions": 37, "deletions": 1, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild_test.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "87abfba9219db3c3f79162dd8b3dcecdddd98a55", "filename": "libgo/go/go/build/deps_test.go", "status": "modified", "additions": 69, "deletions": 63, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Fbuild%2Fdeps_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Fbuild%2Fdeps_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fdeps_test.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "422e1a5ffd20023df05923e1b03ec2d1add2ae5c", "filename": "libgo/go/go/build/doc.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Fbuild%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Fbuild%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fdoc.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "5474e73e24beadb285f1d07605a099ea540c70fe", "filename": "libgo/go/go/constant/value.go", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Fconstant%2Fvalue.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Fconstant%2Fvalue.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fconstant%2Fvalue.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "954a0e05db35bdb38bc86757a388504c8ed21881", "filename": "libgo/go/go/constant/value_test.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Fconstant%2Fvalue_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Fconstant%2Fvalue_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fconstant%2Fvalue_test.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "4228e8cd9c5573000984b0d38c581561fa88ea62", "filename": "libgo/go/go/doc/comment.go", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Fdoc%2Fcomment.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Fdoc%2Fcomment.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Fcomment.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "0523ab899ee345e00d5cab7f5fef8cca7277f612", "filename": "libgo/go/go/doc/comment_test.go", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Fdoc%2Fcomment_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Fdoc%2Fcomment_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Fcomment_test.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "ad8ba5378f3f13f7db193b5416bebb4439d0c18c", "filename": "libgo/go/go/doc/doc_test.go", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Fdoc%2Fdoc_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Fdoc%2Fdoc_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Fdoc_test.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "da9ea1f027db5efa3ba522e3a00dd593fdb69b01", "filename": "libgo/go/go/doc/exports.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Fdoc%2Fexports.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Fdoc%2Fexports.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Fexports.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "4918681de57c217505644cfbc6161f2f03557b76", "filename": "libgo/go/go/format/internal.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Fformat%2Finternal.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Fformat%2Finternal.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fformat%2Finternal.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "fab65181cd827822947a7a4c87610633a43c0911", "filename": "libgo/go/go/importer/importer.go", "status": "modified", "additions": 25, "deletions": 7, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Fimporter%2Fimporter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Fimporter%2Fimporter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fimporter%2Fimporter.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "4fca828bf607344121016b57f19e591d2d20487a", "filename": "libgo/go/go/internal/gccgoimporter/importer_test.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Finternal%2Fgccgoimporter%2Fimporter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Finternal%2Fgccgoimporter%2Fimporter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Finternal%2Fgccgoimporter%2Fimporter_test.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "8a1ad5ff07fc14d6d0ef00f07e67a40d28992a14", "filename": "libgo/go/go/internal/gccgoimporter/parser.go", "status": "modified", "additions": 32, "deletions": 18, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Finternal%2Fgccgoimporter%2Fparser.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Finternal%2Fgccgoimporter%2Fparser.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Finternal%2Fgccgoimporter%2Fparser.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "2045f5517b123e3240d8b893351b6f6e34eb36d4", "filename": "libgo/go/go/internal/gcimporter/bimport.go", "status": "modified", "additions": 125, "deletions": 83, "changes": 208, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Finternal%2Fgcimporter%2Fbimport.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Finternal%2Fgcimporter%2Fbimport.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Finternal%2Fgcimporter%2Fbimport.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "f3f90f259117ada95f7df56e7e5655ce463b4fe4", "filename": "libgo/go/go/internal/gcimporter/gcimporter.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Finternal%2Fgcimporter%2Fgcimporter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Finternal%2Fgcimporter%2Fgcimporter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Finternal%2Fgcimporter%2Fgcimporter.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "c34f07c4c35bdf9782348acb8c8a8688f8de76d5", "filename": "libgo/go/go/internal/gcimporter/gcimporter_test.go", "status": "modified", "additions": 45, "deletions": 25, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Finternal%2Fgcimporter%2Fgcimporter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Finternal%2Fgcimporter%2Fgcimporter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Finternal%2Fgcimporter%2Fgcimporter_test.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "c63ee821c959dafda6799ccc8df77347221ad46a", "filename": "libgo/go/go/internal/gcimporter/testdata/issue20046.go", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Finternal%2Fgcimporter%2Ftestdata%2Fissue20046.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Finternal%2Fgcimporter%2Ftestdata%2Fissue20046.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Finternal%2Fgcimporter%2Ftestdata%2Fissue20046.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "50cf361dbb01be39207701deeedf7c0e91413009", "filename": "libgo/go/go/internal/srcimporter/srcimporter.go", "status": "added", "additions": 211, "deletions": 0, "changes": 211, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Finternal%2Fsrcimporter%2Fsrcimporter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Finternal%2Fsrcimporter%2Fsrcimporter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Finternal%2Fsrcimporter%2Fsrcimporter.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "79921b5e7855bd0ba46f1541baa137a6fe493aaa", "filename": "libgo/go/go/internal/srcimporter/srcimporter_test.go", "status": "added", "additions": 150, "deletions": 0, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Finternal%2Fsrcimporter%2Fsrcimporter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Finternal%2Fsrcimporter%2Fsrcimporter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Finternal%2Fsrcimporter%2Fsrcimporter_test.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "ef91e1ea60ead8744cafdb94f4bf7304fad687ee", "filename": "libgo/go/go/parser/error_test.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Fparser%2Ferror_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Fparser%2Ferror_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fparser%2Ferror_test.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "2b58724521fb41cec65f9f3d8e88da50ab80e74d", "filename": "libgo/go/go/parser/parser.go", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Fparser%2Fparser.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Fparser%2Fparser.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fparser%2Fparser.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "fb35a88ba1aa5565614762df24193cb237584dff", "filename": "libgo/go/go/parser/parser_test.go", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Fparser%2Fparser_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Fparser%2Fparser_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fparser%2Fparser_test.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "f2732c0e2b18d142c121d98bf22de920f4b57eef", "filename": "libgo/go/go/parser/performance_test.go", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Fparser%2Fperformance_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Fparser%2Fperformance_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fparser%2Fperformance_test.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "6f8ef6b0f775d98c918510fd4c878f28a11f64cb", "filename": "libgo/go/go/parser/short_test.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Fparser%2Fshort_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Fparser%2Fshort_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fparser%2Fshort_test.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "4eaadeb448f6854e29ddf8020c437a7f28d940a1", "filename": "libgo/go/go/printer/nodes.go", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Fprinter%2Fnodes.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Fprinter%2Fnodes.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Fnodes.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "dbb4bbd90cf205cfbc9304b23ca63ccb81803f71", "filename": "libgo/go/go/printer/printer.go", "status": "modified", "additions": 47, "deletions": 14, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "5984d2c4d24e1911b0d802c1150417032087574a", "filename": "libgo/go/go/printer/printer_test.go", "status": "modified", "additions": 100, "deletions": 2, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter_test.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "bebc0eaa637e2c83d3a7f148fdf97af71e571565", "filename": "libgo/go/go/printer/testdata/declarations.golden", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fdeclarations.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fdeclarations.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fdeclarations.golden?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "a858051ef01a650d69a9d4a4039d53e601513cac", "filename": "libgo/go/go/printer/testdata/declarations.input", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fdeclarations.input", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fdeclarations.input", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fdeclarations.input?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "88d74168a1b4f1957e6c3b7d1c73177793be8346", "filename": "libgo/go/go/token/position.go", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Ftoken%2Fposition.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Ftoken%2Fposition.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftoken%2Fposition.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "d0ea34517a442fd25ac11751179147d1ea6fd074", "filename": "libgo/go/go/token/serialize.go", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Ftoken%2Fserialize.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Ftoken%2Fserialize.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftoken%2Fserialize.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "11e76867a1f74fb20e4dad26aa685bb31c57e6b0", "filename": "libgo/go/go/types/api.go", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Ftypes%2Fapi.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Ftypes%2Fapi.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Fapi.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "1b17579641074ffd93572fddb96af4eeaefbbd03", "filename": "libgo/go/go/types/api_test.go", "status": "modified", "additions": 52, "deletions": 133, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Ftypes%2Fapi_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Ftypes%2Fapi_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Fapi_test.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "e5ea071e864dd8112fd52484f8682e67becf27dc", "filename": "libgo/go/go/types/assignments.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Ftypes%2Fassignments.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Ftypes%2Fassignments.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Fassignments.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "ffd962977751259d2543ad905662f35464c8be3e", "filename": "libgo/go/go/types/call.go", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Ftypes%2Fcall.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Ftypes%2Fcall.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Fcall.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "26db5769b98d3fb024eef6d8edbf9164f2982a03", "filename": "libgo/go/go/types/check.go", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Ftypes%2Fcheck.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Ftypes%2Fcheck.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Fcheck.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "24b3365717b631af8fe0ae5733a516d32c2aa78e", "filename": "libgo/go/go/types/check_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Ftypes%2Fcheck_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Ftypes%2Fcheck_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Fcheck_test.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "7428f8f99500a78a03a8e8798237095637e4e9ed", "filename": "libgo/go/go/types/decl.go", "status": "modified", "additions": 52, "deletions": 142, "changes": 194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Ftypes%2Fdecl.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Ftypes%2Fdecl.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Fdecl.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "a0c9c217ff986478da827ceb84eef024bd423be3", "filename": "libgo/go/go/types/example_test.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Ftypes%2Fexample_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Ftypes%2Fexample_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Fexample_test.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "461f0a525ba88fb525262cc8049aa0b9ff398488", "filename": "libgo/go/go/types/expr.go", "status": "modified", "additions": 56, "deletions": 7, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Ftypes%2Fexpr.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Ftypes%2Fexpr.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Fexpr.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "196fc9bbd604162de61eb3dff70149a0ae40797b", "filename": "libgo/go/go/types/gotype.go", "status": "modified", "additions": 100, "deletions": 90, "changes": 190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Ftypes%2Fgotype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Ftypes%2Fgotype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Fgotype.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "500fd27ff19ece4c42ffb01cc7b74b384740ee83", "filename": "libgo/go/go/types/hilbert_test.go", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Ftypes%2Fhilbert_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Ftypes%2Fhilbert_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Fhilbert_test.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "ee8202d9e42d77d0133277755e0568a3aefaede1", "filename": "libgo/go/go/types/lookup.go", "status": "modified", "additions": 48, "deletions": 35, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Ftypes%2Flookup.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Ftypes%2Flookup.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Flookup.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "4f791d9d51c64e2bda2bec460c7708b2a5054803", "filename": "libgo/go/go/types/methodset.go", "status": "modified", "additions": 25, "deletions": 27, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Ftypes%2Fmethodset.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Ftypes%2Fmethodset.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Fmethodset.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "f0bcd6766b52eada028801f4b659f42d4bf05bdc", "filename": "libgo/go/go/types/object.go", "status": "modified", "additions": 60, "deletions": 49, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Ftypes%2Fobject.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Ftypes%2Fobject.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Fobject.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "b0acdd91bac26b87f867de9aa834923338b39263", "filename": "libgo/go/go/types/object_test.go", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Ftypes%2Fobject_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Ftypes%2Fobject_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Fobject_test.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "07247bd6f58831a3f4ba3b4854a6de2e644bc21d", "filename": "libgo/go/go/types/operand.go", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Ftypes%2Foperand.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Ftypes%2Foperand.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Foperand.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "cd202a0ed9f789c558c69c60ef6ed0ecbab966a9", "filename": "libgo/go/go/types/package.go", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Ftypes%2Fpackage.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Ftypes%2Fpackage.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Fpackage.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "c3b87dd9cd42fa27388bb1a1150a8a36da0f6a1a", "filename": "libgo/go/go/types/predicates.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Ftypes%2Fpredicates.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Ftypes%2Fpredicates.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Fpredicates.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "05603b3442d00db23436bad759e4d0cf9e7400e5", "filename": "libgo/go/go/types/resolver.go", "status": "modified", "additions": 83, "deletions": 50, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Ftypes%2Fresolver.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Ftypes%2Fresolver.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Fresolver.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "0821a61359d7a055fa130afe8f7c439a19114306", "filename": "libgo/go/go/types/sizes.go", "status": "modified", "additions": 36, "deletions": 1, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Ftypes%2Fsizes.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Ftypes%2Fsizes.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Fsizes.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}, {"sha": "56c48b7547e067c7dfbd970022168b259e90ce66", "filename": "libgo/go/go/types/stdlib_test.go", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Ftypes%2Fstdlib_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc998d034f45d1828a8663b2eed928faf22a7d01/libgo%2Fgo%2Fgo%2Ftypes%2Fstdlib_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Fstdlib_test.go?ref=bc998d034f45d1828a8663b2eed928faf22a7d01"}]}