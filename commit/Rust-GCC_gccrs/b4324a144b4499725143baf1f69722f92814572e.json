{"sha": "b4324a144b4499725143baf1f69722f92814572e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjQzMjRhMTQ0YjQ0OTk3MjUxNDNiYWYxZjY5NzIyZjkyODE0NTcyZQ==", "commit": {"author": {"name": "Paul Koning", "email": "ni1d@arrl.net", "date": "2018-06-27T21:58:24Z"}, "committer": {"name": "Paul Koning", "email": "pkoning@gcc.gnu.org", "date": "2018-06-27T21:58:24Z"}, "message": "Convert pdp11 back end to CCmode.\n\n\t* common/config/pdp11/pdp11-common.c (pdp11_handle_option): Handle\n\tmutually exclusive options.\n\t* config/pdp11/constraints.md (h): New constraint.\n\t(O): Update definition to match shift code generation.\n\t(D): New constraint.\n\t* config/pdp11/pdp11-modes.def (CCNZ): Define mode.\n\t(CCFP): Remove.\n\t* config/pdp11/pdp11-protos.h (int_no_side_effect_operand): New\n\tfunction.\n\t(output_jump): Change arguments.\n\t(pdp11_fixed_cc_regs): New function.\n\t(pdp11_cc_mode): Ditto.\n\t(pdp11_expand_shift): Ditto.\n\t(pdp11_assemble_shift): Ditto.\n\t(pdp11_small_shift): Ditto.\n\t(pdp11_branch_cost): Remove.\n\t* config/pdp11/pdp11.c (pdp11_assemble_integer): Remove comments\n\tfrom output.\n\t(pdp11_register_move_cost): Update for CC registers.\n\t(pdp11_rtx_costs): Add case for LSHIFTRT.\n\t(pdp11_output_jump): Add CCNZ mode conditional branches.\n\t(notice_update_cc_on_set): Remove.\n\t(pdp11_cc_mode): New function.\n\t(simple_memory_operand): Correct pre/post decrement case.\n\t(no_side_effect_operand): New function.\n\t(pdp11_regno_reg_class): Add CC_REGS class.\n\t(pdp11_fixed_cc_regs): New function.\n\t(pdp11_small_shift): New function.\n\t(pdp11_expand_shift): New function to expand shift insns.\n\t(pdp11_assemble_shift): New function to output shifts.\n\t(pdp11_branch_cost): Remove.\n\t(pdp11_modes_tieable_p): Make QI/HI modes tieable.\n\t* config/pdp11/pdp11.h (SIZE_TYPE): Ensure 16-bit type.\n\t(WCHAR_TYPE): Ditto.\n\t(PTRDIFF_TYPE): Ditto.\n\t(ADJUST_INSN_LENGTH): New macro.\n\t(FIXED_REGISTERS): Add CC registers.\n\t(CALL_USED_REGISTERS): Ditto.\n\t(reg_class): Ditto.\n\t(REG_CLASS_NAMES): Ditto.\n\t(REG_CLASS_CONTENTS): Ditto.\n\t(SELECT_CC_MODE): Use new function.\n\t(TARGET_FLAGS_REGNUM): New macro.\n\t(TARGET_FIXED_CONDITION_CODE_REGS): Ditto.\n\t(cc0_reg_rtx): Remove.\n\t(CC_STATUS_MDEP): Remove.\n\t(CC_STATUS_MDEFP_INIT): Remove.\n\t(CC_IN_FPU): Remove.\n\t(NOTICE_UPDATE_CC): Remove.\n\t(REGISTER_NAMES): Add CC registers.\n\t(BRANCH_COST): Change to constant 1.\n\t* config/pdp11/pdp11.md: Rewrite for CCmode condition code\n\thandling.\n\t* config/pdp11/pdp11.opt (mbcopy): Remove.\n\t(mbcopy-builtin): Remove.\n\t(mbranch-cheap): Remove.\n\t(mbranch-expensive): Remove.\n\t* config/pdp11/predicates.md (expand_shift_operand): Update to\n\tmatch shift code generation.\n\t(ccnz_operator): New predicate.\n\t* doc/invoke.texi (PDP-11 Options): Remove deleted options\n\t-mbcopy, -mbcopy-builtin, -mbranch-cheap, -mbranch-expensive.\n\tRemove non-existent option -mabshi, -mno-abshi.  Document mutually\n\texclusive options.\n\t* doc/md.texi (PDP-11): Document new D and h constraints.  Update\n\tdescription of O constraint.\n\nFrom-SVN: r262198", "tree": {"sha": "ed5e61eed2d97171a207721de22310cec011d782", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ed5e61eed2d97171a207721de22310cec011d782"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b4324a144b4499725143baf1f69722f92814572e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4324a144b4499725143baf1f69722f92814572e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b4324a144b4499725143baf1f69722f92814572e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4324a144b4499725143baf1f69722f92814572e/comments", "author": null, "committer": null, "parents": [{"sha": "356d53635faecee4b8abfc6b21208432c72eebff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/356d53635faecee4b8abfc6b21208432c72eebff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/356d53635faecee4b8abfc6b21208432c72eebff"}], "stats": {"total": 2368, "additions": 1504, "deletions": 864}, "files": [{"sha": "fc0550460b879aded8c6d9440c490deca03e0091", "filename": "gcc/ChangeLog", "status": "modified", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4324a144b4499725143baf1f69722f92814572e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4324a144b4499725143baf1f69722f92814572e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b4324a144b4499725143baf1f69722f92814572e", "patch": "@@ -1,3 +1,72 @@\n+2018-06-27  Paul Koning  <ni1d@arrl.net>\n+\n+\t* common/config/pdp11/pdp11-common.c (pdp11_handle_option): Handle\n+\tmutually exclusive options.\n+\t* config/pdp11/constraints.md (h): New constraint.\n+\t(O): Update definition to match shift code generation.\n+\t(D): New constraint.\n+\t* config/pdp11/pdp11-modes.def (CCNZ): Define mode.\n+\t(CCFP): Remove.\n+\t* config/pdp11/pdp11-protos.h (int_no_side_effect_operand): New\n+\tfunction.\n+\t(output_jump): Change arguments.\n+\t(pdp11_fixed_cc_regs): New function.\n+\t(pdp11_cc_mode): Ditto.\n+\t(pdp11_expand_shift): Ditto.\n+\t(pdp11_assemble_shift): Ditto.\n+\t(pdp11_small_shift): Ditto.\n+\t(pdp11_branch_cost): Remove.\n+\t* config/pdp11/pdp11.c (pdp11_assemble_integer): Remove comments\n+\tfrom output.\n+\t(pdp11_register_move_cost): Update for CC registers.\n+\t(pdp11_rtx_costs): Add case for LSHIFTRT.\n+\t(pdp11_output_jump): Add CCNZ mode conditional branches.\n+\t(notice_update_cc_on_set): Remove.\n+\t(pdp11_cc_mode): New function.\n+\t(simple_memory_operand): Correct pre/post decrement case.\n+\t(no_side_effect_operand): New function.\n+\t(pdp11_regno_reg_class): Add CC_REGS class.\n+\t(pdp11_fixed_cc_regs): New function.\n+\t(pdp11_small_shift): New function.\n+\t(pdp11_expand_shift): New function to expand shift insns.\n+\t(pdp11_assemble_shift): New function to output shifts.\n+\t(pdp11_branch_cost): Remove.\n+\t(pdp11_modes_tieable_p): Make QI/HI modes tieable.\n+\t* config/pdp11/pdp11.h (SIZE_TYPE): Ensure 16-bit type.\n+\t(WCHAR_TYPE): Ditto.\n+\t(PTRDIFF_TYPE): Ditto.\n+\t(ADJUST_INSN_LENGTH): New macro.\n+\t(FIXED_REGISTERS): Add CC registers.\n+\t(CALL_USED_REGISTERS): Ditto.\n+\t(reg_class): Ditto.\n+\t(REG_CLASS_NAMES): Ditto.\n+\t(REG_CLASS_CONTENTS): Ditto.\n+\t(SELECT_CC_MODE): Use new function.\n+\t(TARGET_FLAGS_REGNUM): New macro.\n+\t(TARGET_FIXED_CONDITION_CODE_REGS): Ditto.\n+\t(cc0_reg_rtx): Remove.\n+\t(CC_STATUS_MDEP): Remove.\n+\t(CC_STATUS_MDEFP_INIT): Remove.\n+\t(CC_IN_FPU): Remove.\n+\t(NOTICE_UPDATE_CC): Remove.\n+\t(REGISTER_NAMES): Add CC registers.\n+\t(BRANCH_COST): Change to constant 1.\n+\t* config/pdp11/pdp11.md: Rewrite for CCmode condition code\n+\thandling.\n+\t* config/pdp11/pdp11.opt (mbcopy): Remove.\n+\t(mbcopy-builtin): Remove.\n+\t(mbranch-cheap): Remove.\n+\t(mbranch-expensive): Remove.\n+\t* config/pdp11/predicates.md (expand_shift_operand): Update to\n+\tmatch shift code generation.\n+\t(ccnz_operator): New predicate.\n+\t* doc/invoke.texi (PDP-11 Options): Remove deleted options\n+\t-mbcopy, -mbcopy-builtin, -mbranch-cheap, -mbranch-expensive.\n+\tRemove non-existent option -mabshi, -mno-abshi.  Document mutually\n+\texclusive options.\n+\t* doc/md.texi (PDP-11): Document new D and h constraints.  Update\n+\tdescription of O constraint.\n+\n 2018-06-27  Jeff Law  <law@redhat.com>\n \t    Austin Law  <austinklaw@gmail.com>\n "}, {"sha": "9feb4fd4ea1541f138aa9a3281c9768e8962c240", "filename": "gcc/common/config/pdp11/pdp11-common.c", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4324a144b4499725143baf1f69722f92814572e/gcc%2Fcommon%2Fconfig%2Fpdp11%2Fpdp11-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4324a144b4499725143baf1f69722f92814572e/gcc%2Fcommon%2Fconfig%2Fpdp11%2Fpdp11-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon%2Fconfig%2Fpdp11%2Fpdp11-common.c?ref=b4324a144b4499725143baf1f69722f92814572e", "patch": "@@ -39,9 +39,27 @@ pdp11_handle_option (struct gcc_options *opts,\n   switch (code)\n     {\n     case OPT_m10:\n-      opts->x_target_flags &= ~(MASK_40 | MASK_45);\n+      opts->x_target_flags &= ~(MASK_40 | MASK_45 | MASK_FPU | MASK_AC0 | MASK_SPLIT);\n       return true;\n \n+    case OPT_m40:\n+      opts->x_target_flags &= ~(MASK_45 | MASK_FPU | MASK_AC0 | MASK_SPLIT);\n+      return true;\n+\n+    case OPT_mfpu:\n+      opts->x_target_flags &= ~MASK_40;\n+      opts->x_target_flags |= MASK_45;\n+      return true;\n+      \n+    case OPT_msoft_float:\n+      opts->x_target_flags &= ~MASK_AC0;\n+      return true;\n+\n+    case OPT_msplit:\n+      opts->x_target_flags &= ~MASK_40;\n+      opts->x_target_flags |= MASK_45;\n+      return true;\n+      \n     default:\n       return true;\n     }"}, {"sha": "10bf1204716350a6c1ef9cfb42a21b30df245ab1", "filename": "gcc/config/pdp11/constraints.md", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4324a144b4499725143baf1f69722f92814572e/gcc%2Fconfig%2Fpdp11%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4324a144b4499725143baf1f69722f92814572e/gcc%2Fconfig%2Fpdp11%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fconstraints.md?ref=b4324a144b4499725143baf1f69722f92814572e", "patch": "@@ -18,11 +18,14 @@\n ;; along with GCC; see the file COPYING3.  If not see\n ;; <http://www.gnu.org/licenses/>.\n \n+(define_register_constraint \"a\" \"LOAD_FPU_REGS\"\n+  \"FPU register that can be directly loaded from memory\")\n+\n (define_register_constraint \"f\" \"FPU_REGS\"\n   \"Any FPU register\")\n \n-(define_register_constraint \"a\" \"LOAD_FPU_REGS\"\n-  \"FPU register that can be directly loaded from memory\")\n+(define_register_constraint \"h\" \"NO_LOAD_FPU_REGS\"\n+  \"FPU register that cannot be directly loaded from memory\")\n \n (define_register_constraint \"d\" \"MUL_REGS\"\n   \"General register that can be used for 16-bit multiply (odd numbered)\")\n@@ -60,7 +63,7 @@\n (define_constraint \"O\"\n   \"Integer constant for which several individual shifts are better than one big one\"\n   (and (match_code \"const_int\")\n-       (match_test \"abs (ival) > 1 && abs (ival) <= 4\")))\n+       (match_test \"pdp11_small_shift (ival)\")))\n \n (define_constraint \"G\"\n   \"Defines a real zero constant.\"\n@@ -79,3 +82,9 @@\n        (match_test \"memory_address_p (GET_MODE (op), XEXP (op, 0))\n                     && simple_memory_operand (op, GET_MODE (op))\")))\n \n+(define_constraint \"D\"\n+  \"Memory reference that is encoded within the opcode, and not push or pop\"\n+  (and (match_code \"mem\")\n+       (match_test \"memory_address_p (GET_MODE (op), XEXP (op, 0))\n+                    && no_side_effect_operand (op, GET_MODE (op))\")))\n+"}, {"sha": "164889eae873c0a3bbcea53183be14de775c31c8", "filename": "gcc/config/pdp11/pdp11-modes.def", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4324a144b4499725143baf1f69722f92814572e/gcc%2Fconfig%2Fpdp11%2Fpdp11-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4324a144b4499725143baf1f69722f92814572e/gcc%2Fconfig%2Fpdp11%2Fpdp11-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11-modes.def?ref=b4324a144b4499725143baf1f69722f92814572e", "patch": "@@ -19,8 +19,26 @@ along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n /* Add any extra modes needed to represent the condition code.\n-   CCFPmode is used for FPU, but should we use a separate reg? */\n \n-CC_MODE (CCFP);\n+   The default CCmode is the CPU condition codes, as set by compare;\n+   all conditional branches are valid with this.\n+\n+   CCNZmode is the CPU condition code as a side effect of arithmetic\n+   or logic operations where N and Z reflect sign and zero status of\n+   the result, but the V bit is not meaningful.  Unsigned conditional\n+   branches don't apply then (no such thing when comparing with zero)\n+   and signed branches that use V need to clear V first if they are to\n+   be used.  CCNZ mode appears in side effects (implicit compare with\n+   zero) if V is not forced to 0 by the instruction.  In such cases, V\n+   often reflects signed overflow of the operation, which means a\n+   signed branch will get the sign backwards.  This applies both to\n+   some float and integer operations.\n+\n+   These modes are used both in the FPU and the CPU, since they have\n+   the same meaning, and also because the FPU condition codes are\n+   copied to the CPU before being used in conditional branches.  */\n+\n+CC_MODE (CCNZ);\n+\n RESET_FLOAT_FORMAT (SF, pdp11_f_format);\n RESET_FLOAT_FORMAT (DF, pdp11_d_format);"}, {"sha": "453632314d7fd699983b49f4c46fedee0acd2170", "filename": "gcc/config/pdp11/pdp11-protos.h", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4324a144b4499725143baf1f69722f92814572e/gcc%2Fconfig%2Fpdp11%2Fpdp11-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4324a144b4499725143baf1f69722f92814572e/gcc%2Fconfig%2Fpdp11%2Fpdp11-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11-protos.h?ref=b4324a144b4499725143baf1f69722f92814572e", "patch": "@@ -21,27 +21,32 @@ along with GCC; see the file COPYING3.  If not see\n /* declarations */\n #ifdef RTX_CODE\n extern int simple_memory_operand (rtx, machine_mode);\n-\n+extern int no_side_effect_operand (rtx, machine_mode);\n extern int legitimate_const_double_p (rtx);\n extern void notice_update_cc_on_set (rtx, rtx);\n extern void output_addr_const_pdp11 (FILE *, rtx);\n extern const char *output_move_multiple (rtx *);\n extern const char *output_block_move (rtx *);\n-extern const char *output_jump (enum rtx_code, int, int);\n+extern const char *output_jump (rtx *, int, int);\n extern void print_operand_address (FILE *, rtx);\n typedef enum { no_action, dec_before, inc_after } pdp11_action;\n typedef enum { little, either, big } pdp11_partorder;\n-extern bool pdp11_expand_operands (rtx *, rtx [][2], int, \n+extern bool pdp11_expand_operands (rtx *, rtx [][2], int,\n \t\t\t\t   pdp11_action *, pdp11_partorder);\n extern int pdp11_sp_frame_offset (void);\n extern int pdp11_initial_elimination_offset (int, int);\n extern enum reg_class pdp11_regno_reg_class (int);\n+extern bool pdp11_fixed_cc_regs (unsigned int *, unsigned int *);\n+extern machine_mode pdp11_cc_mode (enum rtx_code, rtx, rtx);\n+extern bool pdp11_expand_shift (rtx *, rtx (*) (rtx, rtx, rtx),\n+\t\t\t\trtx (*) (rtx, rtx, rtx));\n+extern const char * pdp11_assemble_shift (rtx *, machine_mode, int);\n+extern bool pdp11_small_shift (int);\n \n #endif /* RTX_CODE */\n \n extern void output_ascii (FILE *, const char *, int);\n extern void pdp11_asm_output_var (FILE *, const char *, int, int, bool);\n extern void pdp11_expand_prologue (void);\n extern void pdp11_expand_epilogue (void);\n-extern int pdp11_branch_cost (void);\n extern poly_int64 pdp11_push_rounding (poly_int64);"}, {"sha": "ab73693d1da4236172b8607d8d24e31e48599a7b", "filename": "gcc/config/pdp11/pdp11.c", "status": "modified", "additions": 384, "deletions": 175, "changes": 559, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4324a144b4499725143baf1f69722f92814572e/gcc%2Fconfig%2Fpdp11%2Fpdp11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4324a144b4499725143baf1f69722f92814572e/gcc%2Fconfig%2Fpdp11%2Fpdp11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11.c?ref=b4324a144b4499725143baf1f69722f92814572e", "patch": "@@ -44,6 +44,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"expr.h\"\n #include \"builtins.h\"\n #include \"dbxout.h\"\n+#include \"expmed.h\"\n \n /* This file should be included last.  */\n #include \"target-def.h\"\n@@ -146,9 +147,6 @@ decode_pdp11_d (const struct real_format *fmt ATTRIBUTE_UNUSED,\n   (*vax_d_format.decode) (fmt, r, tbuf);\n }\n \n-/* This is where the condition code register lives.  */\n-/* rtx cc0_reg_rtx; - no longer needed? */\n-\n static const char *singlemove_string (rtx *);\n static bool pdp11_assemble_integer (rtx, unsigned int, int);\n static bool pdp11_rtx_costs (rtx, machine_mode, int, int, int *, bool);\n@@ -384,7 +382,7 @@ pdp11_expand_epilogue (void)\n \t      emit_move_insn (reg, x);\n \t    else\n \t      {\n-\t        emit_move_insn (via_ac, x);\n+\t\temit_move_insn (via_ac, x);\n \t\temit_move_insn (reg, via_ac);\n \t      }\n \t  }\n@@ -872,48 +870,40 @@ pdp11_assemble_integer (rtx x, unsigned int size, int aligned_p)\n       case 1:\n \tfprintf (asm_out_file, \"\\t.byte\\t\");\n \toutput_addr_const_pdp11 (asm_out_file, GEN_INT (INTVAL (x) & 0xff));\n-;\n-\tfprintf (asm_out_file, \" /* char */\\n\");\n+\tfputs (\"\\n\", asm_out_file);\n \treturn true;\n \n       case 2:\n \tfprintf (asm_out_file, TARGET_UNIX_ASM ? \"\\t\" : \"\\t.word\\t\");\n \toutput_addr_const_pdp11 (asm_out_file, x);\n-\tfprintf (asm_out_file, \" /* short */\\n\");\n+\tfputs (\"\\n\", asm_out_file);\n \treturn true;\n       }\n   return default_assemble_integer (x, size, aligned_p);\n }\n \n \n-/* register move costs, indexed by regs */\n-\n-static const int move_costs[N_REG_CLASSES][N_REG_CLASSES] = \n-{\n-             /* NO  MUL  GEN  LFPU  NLFPU FPU ALL */\n-\n-/* NO */     {  0,   0,   0,    0,    0,    0,   0},\n-/* MUL */    {  0,   2,   2,   22,   22,   22,  22},\n-/* GEN */    {  0,   2,   2,   22,   22,   22,  22},\n-/* LFPU */   {  0,  22,  22,    2,    2,    2,  22},\n-/* NLFPU */  {  0,  22,  22,    2,   10,   10,  22},\n-/* FPU */    {  0,  22,  22,    2,   10,   10,  22},\n-/* ALL */    {  0,  22,  22,   22,   22,   22,  22}\n-}  ;\n-\n-\n-/* -- note that some moves are tremendously expensive, \n-   because they require lots of tricks! do we have to \n-   charge the costs incurred by secondary reload class \n-   -- as we do here with 10 -- or not ? */\n-\n+/* Register to register moves are cheap if both are general registers.\n+   The same is true for FPU, but there we return cost of 3 rather than\n+   2 to make reload look at the constraints.  The raeson is that\n+   load/store double require extra care since load touches condition\n+   codes and store doesn't, which is (partly anyway) described by\n+   constraints.  */\n static int \n pdp11_register_move_cost (machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\t  reg_class_t c1, reg_class_t c2)\n {\n-    return move_costs[(int)c1][(int)c2];\n+  if (((c1 == MUL_REGS || c1 == GENERAL_REGS) &&\n+       (c2 == MUL_REGS || c2 == GENERAL_REGS)))\n+    return 2;\n+  else if ((c1 >= LOAD_FPU_REGS && c1 <= FPU_REGS && c2 == LOAD_FPU_REGS) ||\n+\t   (c2 >= LOAD_FPU_REGS && c2 <= FPU_REGS && c1 == LOAD_FPU_REGS))\n+    return 3;\n+  else\n+    return 22;\n }\n \n+\n static bool\n pdp11_rtx_costs (rtx x, machine_mode mode, int outer_code ATTRIBUTE_UNUSED,\n \t\t int opno ATTRIBUTE_UNUSED, int *total,\n@@ -988,7 +978,6 @@ pdp11_rtx_costs (rtx x, machine_mode mode, int outer_code ATTRIBUTE_UNUSED,\n       return false;\n \n     case ASHIFT:\n-    case LSHIFTRT:\n     case ASHIFTRT:\n       if (optimize_size)\n         *total = COSTS_N_INSNS (1);\n@@ -1020,177 +1009,250 @@ pdp11_rtx_costs (rtx x, machine_mode mode, int outer_code ATTRIBUTE_UNUSED,\n         }\n       return false;\n \n+    case LSHIFTRT:\n+      if (optimize_size)\n+        *total = COSTS_N_INSNS (2);\n+      else if (mode ==  QImode)\n+        {\n+          if (GET_CODE (XEXP (x, 1)) != CONST_INT)\n+   \t    *total = COSTS_N_INSNS (12); /* worst case */\n+          else\n+\t    *total = COSTS_N_INSNS (1 + INTVAL (XEXP (x, 1)));\n+        }\n+      else if (mode == HImode)\n+        {\n+          if (GET_CODE (XEXP (x, 1)) == CONST_INT)\n+            {\n+\t      if (abs (INTVAL (XEXP (x, 1))) == 1)\n+                *total = COSTS_N_INSNS (2);\n+              else\n+\t        *total = COSTS_N_INSNS (3.5 + 0.5 * INTVAL (XEXP (x, 1)));\n+            }\n+          else\n+            *total = COSTS_N_INSNS (12); /* worst case */\n+        }\n+      else if (mode == SImode)\n+        {\n+          if (GET_CODE (XEXP (x, 1)) == CONST_INT)\n+\t    *total = COSTS_N_INSNS (3.5 + 0.5 * INTVAL (XEXP (x, 1)));\n+          else /* worst case */\n+            *total = COSTS_N_INSNS (20);\n+        }\n+      return false;\n+\n     default:\n       return false;\n     }\n }\n \n const char *\n-output_jump (enum rtx_code code, int inv, int length)\n+output_jump (rtx *operands, int ccnz, int length)\n {\n-    static int x = 0;\n-    \n-    static char buf[1000];\n-    const char *pos, *neg;\n+  rtx tmpop[1];\n+  static char buf[100];\n+  const char *pos, *neg;\n+  enum rtx_code code = GET_CODE (operands[0]);\n \n-    if (cc_prev_status.flags & CC_NO_OVERFLOW)\n-      {\n-\tswitch (code)\n-\t  {\n-\t  case GTU: code = GT; break;\n-\t  case LTU: code = LT; break;\n-\t  case GEU: code = GE; break;\n-\t  case LEU: code = LE; break;\n-\t  default: ;\n-\t  }\n-      }\n-    switch (code)\n-      {\n-      case EQ: pos = \"beq\", neg = \"bne\"; break;\n-      case NE: pos = \"bne\", neg = \"beq\"; break;\n-      case GT: pos = \"bgt\", neg = \"ble\"; break;\n-      case GTU: pos = \"bhi\", neg = \"blos\"; break;\n-      case LT: pos = \"blt\", neg = \"bge\"; break;\n-      case LTU: pos = \"blo\", neg = \"bhis\"; break;\n-      case GE: pos = \"bge\", neg = \"blt\"; break;\n-      case GEU: pos = \"bhis\", neg = \"blo\"; break;\n-      case LE: pos = \"ble\", neg = \"bgt\"; break;\n-      case LEU: pos = \"blos\", neg = \"bhi\"; break;\n-      default: gcc_unreachable ();\n-      }\n-\n-#if 0\n-/* currently we don't need this, because the tstdf and cmpdf \n-   copy the condition code immediately, and other float operations are not \n-   yet recognized as changing the FCC - if so, then the length-cost of all\n-   jump insns increases by one, because we have to potentially copy the \n-   FCC! */\n-    if (cc_status.flags & CC_IN_FPU)\n-\toutput_asm_insn(\"cfcc\", NULL);\n-#endif\n-\t\n-    switch (length)\n+  if (ccnz)\n     {\n-      case 2:\n-\t\n-\tsprintf(buf, \"%s %%l1\", inv ? neg : pos);\n-\t\n-\treturn buf;\n-\t\n-      case 6:\n-\t\n-\tsprintf(buf, \"%s JMP_%d\\n\\tjmp %%l1\\nJMP_%d:\", inv ? pos : neg, x, x);\n-\t\n-\tx++;\n-\t\n-\treturn buf;\n-\t\n-      default:\n-\t\n-\tgcc_unreachable ();\n+      /* These are the branches valid for CCNZmode, i.e., a comparison\n+\t with zero where the V bit is not set to zero.  These cases\n+\t occur when CC or FCC are set as a side effect of some data\n+\t manipulation, such as the ADD instruction.  */\n+      switch (code)\n+\t{\n+\tcase EQ: pos = \"beq\", neg = \"bne\"; break;\n+\tcase NE: pos = \"bne\", neg = \"beq\"; break;\n+\tcase LT: pos = \"bmi\", neg = \"bpl\"; break;\n+\tcase GE: pos = \"bpl\", neg = \"bmi\"; break;\n+\tdefault: gcc_unreachable ();\n+\t}\n+    }\n+  else\n+    {\n+      switch (code)\n+\t{\n+\tcase EQ: pos = \"beq\", neg = \"bne\"; break;\n+\tcase NE: pos = \"bne\", neg = \"beq\"; break;\n+\tcase GT: pos = \"bgt\", neg = \"ble\"; break;\n+\tcase GTU: pos = \"bhi\", neg = \"blos\"; break;\n+\tcase LT: pos = \"blt\", neg = \"bge\"; break;\n+\tcase LTU: pos = \"blo\", neg = \"bhis\"; break;\n+\tcase GE: pos = \"bge\", neg = \"blt\"; break;\n+\tcase GEU: pos = \"bhis\", neg = \"blo\"; break;\n+\tcase LE: pos = \"ble\", neg = \"bgt\"; break;\n+\tcase LEU: pos = \"blos\", neg = \"bhi\"; break;\n+\tdefault: gcc_unreachable ();\n+\t}\n+    }\n+  switch (length)\n+    {\n+    case 2:\n+      sprintf (buf, \"%s %%l1\", pos);\n+      return buf;\n+    case 6:\n+      tmpop[0] = gen_label_rtx ();\n+      sprintf (buf, \"%s %%l0\", neg);\n+      output_asm_insn (buf, tmpop);\n+      output_asm_insn (\"jmp %l1\", operands);\n+      output_asm_label (tmpop[0]);\n+      fputs (\":\\n\", asm_out_file);\n+      return \"\";\n+    default:\n+      gcc_unreachable ();\n     }\n-    \n }\n \n-void\n-notice_update_cc_on_set(rtx exp, rtx insn ATTRIBUTE_UNUSED)\n+/* Select the CC mode to be used for the side effect compare with\n+   zero, given the compare operation code in op and the compare\n+   operands in x in and y.  */\n+machine_mode\n+pdp11_cc_mode (enum rtx_code op, rtx x, rtx y)\n {\n-    if (GET_CODE (SET_DEST (exp)) == CC0)\n-    { \n-      cc_status.flags = 0;\t\t\t\t\t\n-      cc_status.value1 = SET_DEST (exp);\t\t\t\n-      cc_status.value2 = SET_SRC (exp);\t\t\t\n-    }\t\t\t\t\t\t\t\n-    else if (GET_CODE (SET_SRC (exp)) == CALL)\t\t\n-    { \n-      CC_STATUS_INIT; \n+  if (FLOAT_MODE_P (GET_MODE (x)))\n+    {\n+      switch (GET_CODE (x))\n+\t{\n+\tcase ABS:\n+\tcase NEG:\n+\tcase REG:\n+\tcase MEM:\n+\t  return CCmode;\n+\tdefault:\n+\t  return CCNZmode;\n+\t}\n     }\n-    else if (SET_DEST(exp) == pc_rtx)\n-    { \n-      /* jump */\n-    }\t\n-    else if (GET_MODE (SET_DEST(exp)) == HImode\t\t\n-\t     || GET_MODE (SET_DEST(exp)) == QImode)\n-    { \n-      cc_status.flags = GET_CODE (SET_SRC(exp)) == MINUS ? 0 : CC_NO_OVERFLOW;\n-      cc_status.value1 = SET_SRC (exp);   \t\t\t\n-      cc_status.value2 = SET_DEST (exp);\t\t\t\n-\t\n-      if (cc_status.value1 && GET_CODE (cc_status.value1) == REG\t\n-\t  && cc_status.value2\t\t\t\t\t\n-\t  && reg_overlap_mentioned_p (cc_status.value1, cc_status.value2))\n-\tcc_status.value2 = 0;\t\t\t\t\t\n-      if (cc_status.value1 && GET_CODE (cc_status.value1) == MEM\t\n-\t  && cc_status.value2\t\t\t\t\t\n-\t  && GET_CODE (cc_status.value2) == MEM)\t\t\t\n-\tcc_status.value2 = 0; \t\t\t\t\t\n-    }\t\t        \n-    else\n-    { \n-      CC_STATUS_INIT; \n+  else\n+    {\n+      switch (GET_CODE (x))\n+\t{\n+\tcase XOR:\n+\tcase AND:\n+\tcase IOR:\n+\tcase MULT:\n+\tcase NOT:\n+\tcase REG:\n+\tcase MEM:\n+\t  return CCmode;\n+\tdefault:\n+\t  return CCNZmode;\n+\t}\n     }\n }\n \n \n int\n simple_memory_operand(rtx op, machine_mode mode ATTRIBUTE_UNUSED)\n {\n-    rtx addr;\n-\n-    /* Eliminate non-memory operations */\n-    if (GET_CODE (op) != MEM)\n-\treturn FALSE;\n+  rtx addr;\n \n-#if 0\n-    /* dword operations really put out 2 instructions, so eliminate them.  */\n-    if (GET_MODE_SIZE (GET_MODE (op)) > (HAVE_64BIT_P () ? 8 : 4))\n-\treturn FALSE;\n-#endif\n+  /* Eliminate non-memory operations */\n+  if (GET_CODE (op) != MEM)\n+    return FALSE;\n \n-    /* Decode the address now.  */\n+  /* Decode the address now.  */\n \n-  indirection:\n+ indirection:\n     \n-    addr = XEXP (op, 0);\n+  addr = XEXP (op, 0);\n \n-    switch (GET_CODE (addr))\n+  switch (GET_CODE (addr))\n     {\n-      case REG:\n-\t/* (R0) - no extra cost */\n-\treturn 1;\n+    case REG:\n+      /* (R0) - no extra cost */\n+      return 1;\n \t\n-      case PRE_DEC:\n-      case POST_INC:\n-\t/* -(R0), (R0)+ - cheap! */\n+    case PRE_DEC:\n+    case POST_INC:\n+    case PRE_MODIFY:\n+    case POST_MODIFY:\n+      /* -(R0), (R0)+ - cheap! */\n+      return 1;\n+\t\n+    case MEM:\n+      /* cheap - is encoded in addressing mode info! \n+\n+\t -- except for @(R0), which has to be @0(R0) !!! */\n+\n+      if (GET_CODE (XEXP (addr, 0)) == REG)\n \treturn 0;\n \t\n-      case MEM:\n-\t/* cheap - is encoded in addressing mode info! \n+      op=addr;\n+      goto indirection;\n+\t\n+    case CONST_INT:\n+    case LABEL_REF:\t       \n+    case CONST:\n+    case SYMBOL_REF:\n+      /* @#address - extra cost */\n+      return 0;\n+\n+    case PLUS:\n+      /* X(R0) - extra cost */\n+      return 0;\n+\n+    default:\n+      break;\n+    }\n+    \n+  return FALSE;\n+}\n+\n+/* Similar to simple_memory_operand but doesn't match push/pop.  */\n+int\n+no_side_effect_operand(rtx op, machine_mode mode ATTRIBUTE_UNUSED)\n+{\n+  rtx addr;\n \n-\t   -- except for @(R0), which has to be @0(R0) !!! */\n+  /* Eliminate non-memory operations */\n+  if (GET_CODE (op) != MEM)\n+    return FALSE;\n+\n+  /* Decode the address now.  */\n+\n+ indirection:\n+    \n+  addr = XEXP (op, 0);\n \n-\tif (GET_CODE (XEXP (addr, 0)) == REG)\n-\t    return 0;\n+  switch (GET_CODE (addr))\n+    {\n+    case REG:\n+      /* (R0) - no extra cost */\n+      return 1;\n \t\n-\top=addr;\n-\tgoto indirection;\n+    case PRE_DEC:\n+    case POST_INC:\n+    case PRE_MODIFY:\n+    case POST_MODIFY:\n+      return 0;\n \t\n-      case CONST_INT:\n-      case LABEL_REF:\t       \n-      case CONST:\n-      case SYMBOL_REF:\n-\t/* @#address - extra cost */\n-\treturn 0;\n+    case MEM:\n+      /* cheap - is encoded in addressing mode info! \n \n-      case PLUS:\n-\t/* X(R0) - extra cost */\n+\t -- except for @(R0), which has to be @0(R0) !!! */\n+\n+      if (GET_CODE (XEXP (addr, 0)) == REG)\n \treturn 0;\n+\t\n+      op=addr;\n+      goto indirection;\n+\t\n+    case CONST_INT:\n+    case LABEL_REF:\t       \n+    case CONST:\n+    case SYMBOL_REF:\n+      /* @#address - extra cost */\n+      return 0;\n \n-      default:\n-\tbreak;\n+    case PLUS:\n+      /* X(R0) - extra cost */\n+      return 0;\n+\n+    default:\n+      break;\n     }\n     \n-    return FALSE;\n+  return FALSE;\n }\n \n \n@@ -1446,7 +1508,7 @@ pdp11_preferred_output_reload_class (rtx x, reg_class_t rclass)\n \n    FPU registers AC4 and AC5 (class NO_LOAD_FPU_REGS) require an \n    intermediate register (AC0-AC3: LOAD_FPU_REGS).  Everything else\n-   can be loade/stored directly.  */\n+   can be loaded/stored directly.  */\n static reg_class_t \n pdp11_secondary_reload (bool in_p ATTRIBUTE_UNUSED,\n \t\t\trtx x,\n@@ -1463,9 +1525,8 @@ pdp11_secondary_reload (bool in_p ATTRIBUTE_UNUSED,\n \n /* Implement TARGET_SECONDARY_MEMORY_NEEDED.\n \n-   The answer is yes if we're going between general register and FPU \n-   registers.  The mode doesn't matter in making this check.\n-*/\n+   The answer is yes if we're going between general register and FPU\n+   registers.  The mode doesn't matter in making this check.  */\n static bool\n pdp11_secondary_memory_needed (machine_mode, reg_class_t c1, reg_class_t c2)\n {\n@@ -1594,6 +1655,8 @@ pdp11_regno_reg_class (int regno)\n { \n   if (regno == FRAME_POINTER_REGNUM || regno == ARG_POINTER_REGNUM)\n     return GENERAL_REGS;\n+  else if (regno == CC_REGNUM || regno == FCC_REGNUM)\n+    return CC_REGS;\n   else if (regno > AC3_REGNUM)\n     return NO_LOAD_FPU_REGS;\n   else if (regno >= AC0_REGNUM)\n@@ -1604,6 +1667,14 @@ pdp11_regno_reg_class (int regno)\n     return GENERAL_REGS;\n }\n \n+/* Return the regnums of the CC registers.  */\n+bool\n+pdp11_fixed_cc_regs (unsigned int *p1, unsigned int *p2)\n+{\n+  *p1 = CC_REGNUM;\n+  *p2 = FCC_REGNUM;\n+  return true;\n+}\n \n int\n pdp11_sp_frame_offset (void)\n@@ -1804,6 +1875,151 @@ pdp11_function_value_regno_p (const unsigned int regno)\n   return (regno == RETVAL_REGNUM) || (TARGET_AC0 && (regno == AC0_REGNUM));\n }\n \n+/* Used for O constraint, matches if shift count is \"small\".  */\n+bool\n+pdp11_small_shift (int n)\n+{\n+  return (unsigned) n < 4;\n+}\n+\n+/* Expand a shift insn.  Returns true if the expansion was done,\n+   false if it needs to be handled by the caller.  */\n+bool\n+pdp11_expand_shift (rtx *operands, rtx (*shift_sc) (rtx, rtx, rtx),\n+\t\t    rtx (*shift_base) (rtx, rtx, rtx))\n+{\n+  rtx dest, n, r, test;\n+  rtx_code_label *lb, *lb2;\n+  \n+  if (CONSTANT_P (operands[2]) && pdp11_small_shift (INTVAL (operands[2])))\n+    emit_insn ((*shift_sc) (operands[0], operands[1], operands[2]));\n+  else if (TARGET_40_PLUS)\n+    return false;\n+  else\n+    {\n+      lb = gen_label_rtx ();\n+      r = gen_reg_rtx (HImode);\n+      emit_move_insn (operands[0], operands[1]);\n+      emit_move_insn (r, operands[2]);\n+      if (!CONSTANT_P (operands[2]))\n+\t{\n+\t  test = gen_rtx_LE (HImode, r, const0_rtx);\n+\t  emit_jump_insn (gen_cbranchhi4 (test, r, const0_rtx, lb));\n+\t}\n+      /* It would be nice to expand the loop here, but that's not\n+\t possible because shifts may be generated by the loop unroll\n+\t optimizer and it doesn't appreciate flow changes happening\n+\t while it's doing things.  */\n+      emit_insn ((*shift_base) (operands[0], operands[1], r));\n+      if (!CONSTANT_P (operands[2]))\n+\t{\n+\t  emit_label (lb);\n+\n+\t  /* Allow REG_NOTES to be set on last insn (labels don't have enough\n+\t     fields, and can't be used for REG_NOTES anyway).  */\n+\t  emit_use (stack_pointer_rtx);\n+\t}\n+    }\n+  return true;\n+}\n+\n+/* Emit the instructions needed to produce a shift by a small constant\n+   amount (unrolled), or a shift made from a loop for the base machine\n+   case.  */\n+const char *\n+pdp11_assemble_shift (rtx *operands, machine_mode m, int code)\n+{\n+  int i, n;\n+  rtx exops[4][2];\n+  rtx lb[1];\n+  pdp11_action action[2];\n+  const bool small = CONSTANT_P (operands[2]) && pdp11_small_shift (INTVAL (operands[2]));\n+\n+  gcc_assert (small || !TARGET_40_PLUS);\n+\n+  if (m == E_SImode)\n+      pdp11_expand_operands (operands, exops, 1, action, either);\n+\n+  if (!small)\n+    {\n+      /* Loop case, generate the top of loop label.  */\n+      lb[0] = gen_label_rtx ();\n+      output_asm_label (lb[0]);\n+      fputs (\":\\n\", asm_out_file);\n+      n = 1;\n+    }\n+  else\n+    n = INTVAL (operands[2]);\n+  if (code == LSHIFTRT)\n+    {\n+      output_asm_insn (\"clc\", NULL);\n+      switch (m)\n+\t{\n+\tcase E_QImode:\n+\t  output_asm_insn (\"rorb %0\", operands);\n+\t  break;\n+\tcase E_HImode:\n+\t  output_asm_insn (\"ror %0\", operands);\n+\t  break;\n+\tcase E_SImode:\n+\t  output_asm_insn (\"ror %0\", exops[0]);\n+\t  output_asm_insn (\"ror %0\", exops[1]);\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+      n--;\n+    }\n+  for (i = 0; i < n; i++)\n+    {\n+      switch (code)\n+\t{\n+\tcase LSHIFTRT:\n+\tcase ASHIFTRT:\n+\t  switch (m)\n+\t    {\n+\t    case E_QImode:\n+\t      output_asm_insn (\"asrb %0\", operands);\n+\t      break;\n+\t    case E_HImode:\n+\t      output_asm_insn (\"asr %0\", operands);\n+\t      break;\n+\t    case E_SImode:\n+\t      output_asm_insn (\"asr %0\", exops[0]);\n+\t      output_asm_insn (\"ror %0\", exops[1]);\n+\t      break;\n+\t    default:\n+\t      gcc_unreachable ();\n+\t    }\n+\t  break;\n+\tcase ASHIFT:\n+\t  switch (m)\n+\t    {\n+\t    case E_QImode:\n+\t      output_asm_insn (\"aslb %0\", operands);\n+\t      break;\n+\t    case E_HImode:\n+\t      output_asm_insn (\"asl %0\", operands);\n+\t      break;\n+\t    case E_SImode:\n+\t      output_asm_insn (\"asl %0\", exops[1]);\n+\t      output_asm_insn (\"rol %0\", exops[0]);\n+\t      break;\n+\t    default:\n+\t      gcc_unreachable ();\n+\t    }\n+\t  break;\n+\t}\n+    }\n+  if (!small)\n+    {\n+      /* Loop case, emit the count-down and branch if not done.  */\n+      output_asm_insn (\"dec %2\", operands);\n+      output_asm_insn (\"bne %l0\", lb);\n+    }\n+  return \"\";\n+}\n+\n /* Worker function for TARGET_TRAMPOLINE_INIT.\n \n    trampoline - how should i do it in separate i+d ? \n@@ -1814,7 +2030,6 @@ pdp11_function_value_regno_p (const unsigned int regno)\n    MOV\t#STATIC, $4\t01270Y\t0x0000 <- STATIC; Y = STATIC_CHAIN_REGNUM\n    JMP\t@#FUNCTION\t000137  0x0000 <- FUNCTION\n */\n-\n static void\n pdp11_trampoline_init (rtx m_tramp, tree fndecl, rtx chain_value)\n {\n@@ -1934,12 +2149,6 @@ pdp11_scalar_mode_supported_p (scalar_mode mode)\n   return default_scalar_mode_supported_p (mode);\n }\n \n-int\n-pdp11_branch_cost ()\n-{\n-  return (TARGET_BRANCH_CHEAP ? 0 : 1);\n-}\n-\n /* Implement TARGET_HARD_REGNO_NREGS.  */\n \n static unsigned int\n@@ -1972,9 +2181,9 @@ pdp11_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n /* Implement TARGET_MODES_TIEABLE_P.  */\n \n static bool\n-pdp11_modes_tieable_p (machine_mode, machine_mode)\n+pdp11_modes_tieable_p (machine_mode mode1, machine_mode mode2)\n {\n-  return false;\n+  return mode1 == HImode && mode2 == QImode;\n }\n \n /* Implement PUSH_ROUNDING.  On the pdp11, the stack is on an even"}, {"sha": "f995bc8672b37d979935726ebc93da861142014d", "filename": "gcc/config/pdp11/pdp11.h", "status": "modified", "additions": 68, "deletions": 74, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4324a144b4499725143baf1f69722f92814572e/gcc%2Fconfig%2Fpdp11%2Fpdp11.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4324a144b4499725143baf1f69722f92814572e/gcc%2Fconfig%2Fpdp11%2Fpdp11.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11.h?ref=b4324a144b4499725143baf1f69722f92814572e", "patch": "@@ -65,11 +65,11 @@ along with GCC; see the file COPYING3.  If not see\n #define LONG_DOUBLE_TYPE_SIZE\t64\n \n /* machine types from ansi */\n-#define SIZE_TYPE \"unsigned int\" \t/* definition of size_t */\n-#define WCHAR_TYPE \"int\" \t\t/* or long int???? */\n+#define SIZE_TYPE \"short unsigned int\" \t/* definition of size_t */\n+#define WCHAR_TYPE \"short int\" \t\t/* or long int???? */\n #define WCHAR_TYPE_SIZE 16\n \n-#define PTRDIFF_TYPE \"int\"\n+#define PTRDIFF_TYPE \"short int\"\n \n /* target machine storage layout */\n \n@@ -99,8 +99,7 @@ along with GCC; see the file COPYING3.  If not see\n extern const struct real_format pdp11_f_format;\n extern const struct real_format pdp11_d_format;\n \n-/* Maximum sized of reasonable data type \n-   DImode or Dfmode ...*/\n+/* Maximum sized of reasonable data type -- DImode ...*/\n #define MAX_FIXED_MODE_SIZE 64\t\n \n /* Allocation boundary (in *bits*) for storing pointers in memory.  */\n@@ -124,6 +123,22 @@ extern const struct real_format pdp11_d_format;\n /* Define this if move instructions will actually fail to work\n    when given unaligned data.  */\n #define STRICT_ALIGNMENT 1\n+\n+/* Adjust the length of shifts by small constant amounts.  The base\n+   value (in \"length\" on input) is the length of a shift by one, not\n+   including the CLC in logical shifts.  */\n+#define ADJUST_INSN_LENGTH(insn, length) \\\n+  if ((GET_CODE (insn) == ASHIFT ||\t \\\n+       GET_CODE (insn) == ASHIFTRT || \\\n+       GET_CODE (insn) == LSHIFTRT) && \\\n+      GET_CODE (XEXP (insn, 2)) == CONST_INT && \\\n+      pdp11_small_shift (XINT (insn, 2))) \\\n+    {\t\t\t\t\t  \\\n+      if (GET_CODE (insn) == LSHIFTRT)\t  \\\n+\tlength = (length * XINT (insn, 2)) + 2;\t\\\n+      else \\\n+\tlength *= XINT (insn, 2); \\\n+    }\n \f\n /* Standard register usage.  */\n \n@@ -147,7 +162,8 @@ extern const struct real_format pdp11_d_format;\n \n #define FIXED_REGISTERS  \\\n {0, 0, 0, 0, 0, 0, 1, 1, \\\n- 0, 0, 0, 0, 0, 0, 1, 1 }\n+ 0, 0, 0, 0, 0, 0, 1, 1, \\\n+ 1, 1 }\n \n \n \n@@ -161,7 +177,8 @@ extern const struct real_format pdp11_d_format;\n /* don't know about fp */\n #define CALL_USED_REGISTERS  \\\n {1, 1, 0, 0, 0, 0, 1, 1, \\\n- 0, 0, 0, 0, 0, 0, 1, 1 }\n+ 0, 0, 0, 0, 0, 0, 1, 1, \\\n+ 1, 1 }\n \n \n /* Specify the registers used for certain standard purposes.\n@@ -203,27 +220,47 @@ NO_LOAD_FPU_REGS is ac4 and ac5, currently - difficult to load them\n FPU_REGS is all fpu regs \n */\n \n-enum reg_class { NO_REGS, MUL_REGS, GENERAL_REGS, LOAD_FPU_REGS, NO_LOAD_FPU_REGS, FPU_REGS, ALL_REGS, LIM_REG_CLASSES };\n+enum reg_class\n+  { NO_REGS,\n+    MUL_REGS,\n+    GENERAL_REGS,\n+    LOAD_FPU_REGS,\n+    NO_LOAD_FPU_REGS,\n+    FPU_REGS,\n+    CC_REGS,\n+    ALL_REGS,\n+    LIM_REG_CLASSES };\n \n-#define N_REG_CLASSES (int) LIM_REG_CLASSES\n+#define N_REG_CLASSES ((int) LIM_REG_CLASSES)\n \n /* have to allow this till cmpsi/tstsi are fixed in a better way !! */\n #define TARGET_SMALL_REGISTER_CLASSES_FOR_MODE_P hook_bool_mode_true\n \n-/* Since GENERAL_REGS is the same class as ALL_REGS,\n-   don't give it a different class number; just make it an alias.  */\n-\n-/* #define GENERAL_REGS ALL_REGS */\n-\n /* Give names of register classes as strings for dump file.  */\n \n-#define REG_CLASS_NAMES {\"NO_REGS\", \"MUL_REGS\", \"GENERAL_REGS\", \"LOAD_FPU_REGS\", \"NO_LOAD_FPU_REGS\", \"FPU_REGS\", \"ALL_REGS\" }\n+#define REG_CLASS_NAMES  \\\n+  { \"NO_REGS\",\t\t \\\n+    \"MUL_REGS\", \t \\\n+    \"GENERAL_REGS\",\t \\\n+    \"LOAD_FPU_REGS\",\t \\\n+    \"NO_LOAD_FPU_REGS\",\t \\\n+    \"FPU_REGS\",\t\t \\\n+    \"CC_REGS\",\t\t \\\n+    \"ALL_REGS\" }\n \n /* Define which registers fit in which classes.\n    This is an initializer for a vector of HARD_REG_SET\n    of length N_REG_CLASSES.  */\n \n-#define REG_CLASS_CONTENTS {{0}, {0x00aa}, {0xc0ff}, {0x0f00}, {0x3000}, {0x3f00}, {0xffff}}\n+#define REG_CLASS_CONTENTS \\\n+  { {0x00000},\t/* NO_REGS */\t\t\\\n+    {0x000aa},\t/* MUL_REGS */\t\t\\\n+    {0x0c0ff},\t/* GENERAL_REGS */\t\\\n+    {0x00f00},\t/* LOAD_FPU_REGS */\t\\\n+    {0x03000},\t/* NO_LOAD_FPU_REGS */ \t\\\n+    {0x03f00},\t/* FPU_REGS */\t\t\\\n+    {0x30000},\t/* CC_REGS */\t\t\\\n+    {0x3ffff}}\t/* ALL_REGS */\n \n /* The same information, inverted:\n    Return the class number of the smallest class containing\n@@ -331,7 +368,7 @@ extern int may_call_alloca;\n {{ ARG_POINTER_REGNUM, STACK_POINTER_REGNUM},\t\t\\\n  { ARG_POINTER_REGNUM, HARD_FRAME_POINTER_REGNUM},\t\\\n  { FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM},\t\t\\\n- { FRAME_POINTER_REGNUM, HARD_FRAME_POINTER_REGNUM}}\t\\\n+ { FRAME_POINTER_REGNUM, HARD_FRAME_POINTER_REGNUM}}\n \n #define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET) \\\n   ((OFFSET) = pdp11_initial_elimination_offset ((FROM), (TO)))\n@@ -424,11 +461,18 @@ extern int may_call_alloca;\n #define DBX_CONTIN_LENGTH 0\n \n /* Give a comparison code (EQ, NE etc) and the first operand of a COMPARE,\n-   return the mode to be used for the comparison.  For floating-point, CCFPmode\n-   should be used.  */\n+   return the mode to be used for the comparison.  */\n+\n+#define SELECT_CC_MODE(OP,X,Y) pdp11_cc_mode (OP, X, Y)\n \n-#define SELECT_CC_MODE(OP,X,Y)\t\\\n-(GET_MODE_CLASS(GET_MODE(X)) == MODE_FLOAT? CCFPmode : CCmode)\n+/* Enable compare elimination pass.\n+   FIXME: how can this be enabled for two registers?  */\n+#undef TARGET_FLAGS_REGNUM\n+#define TARGET_FLAGS_REGNUM CC_REGNUM\n+\n+/* Specify the CC registers.  TODO: is this for \"type 1\" CC handling only?  */\n+#undef TARGET_FIXED_CONDITION_CODE_REGS\n+#define TARGET_FIXED_CONDITION_CODE_REGS pdp11_fixed_cc_regs\n \n /* Specify the machine mode that pointers have.\n    After generation of rtl, the compiler makes no further distinction\n@@ -446,54 +490,6 @@ extern int may_call_alloca;\n    but a CALL with constant address is cheap.  */\n /* #define NO_FUNCTION_CSE */\n \n-\f\n-/* Tell emit-rtl.c how to initialize special values on a per-function base.  */\n-extern rtx cc0_reg_rtx;\n-\n-#define CC_STATUS_MDEP rtx\n-\n-#define CC_STATUS_MDEP_INIT (cc_status.mdep = 0)\n-\f\n-/* Tell final.c how to eliminate redundant test instructions.  */\n-\n-/* Here we define machine-dependent flags and fields in cc_status\n-   (see `conditions.h').  */\n-\n-#define CC_IN_FPU 04000 \n-\n-/* Do UPDATE_CC if EXP is a set, used in\n-   NOTICE_UPDATE_CC \n-\n-   floats only do compare correctly, else nullify ...\n-\n-   get cc0 out soon ...\n-*/\n-\n-/* Store in cc_status the expressions\n-   that the condition codes will describe\n-   after execution of an instruction whose pattern is EXP.\n-   Do not alter them if the instruction would not alter the cc's.  */\n-\n-#define NOTICE_UPDATE_CC(EXP, INSN) \\\n-{ if (GET_CODE (EXP) == SET)\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      notice_update_cc_on_set(EXP, INSN);\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  else if (GET_CODE (EXP) == PARALLEL\t\t\t\t\\\n-\t   && GET_CODE (XVECEXP (EXP, 0, 0)) == SET)\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      notice_update_cc_on_set(XVECEXP (EXP, 0, 0), INSN);\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  else if (GET_CODE (EXP) == CALL)\t\t\t\t\\\n-    { /* all bets are off */ CC_STATUS_INIT; }\t\t\t\\\n-  if (cc_status.value1 && GET_CODE (cc_status.value1) == REG\t\\\n-      && cc_status.value2\t\t\t\t\t\\\n-      && reg_overlap_mentioned_p (cc_status.value1, cc_status.value2)) \\\n-    { \t\t\t\t\t\t\t\t\\\n-      printf (\"here!\\n\");\t\t\t\t\t\\\n-      cc_status.value2 = 0;\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-}\n \f\n /* Control the assembler format that we output.  */\n \n@@ -520,7 +516,8 @@ extern rtx cc0_reg_rtx;\n \n #define REGISTER_NAMES \\\n {\"r0\", \"r1\", \"r2\", \"r3\", \"r4\", \"r5\", \"sp\", \"pc\",     \\\n- \"ac0\", \"ac1\", \"ac2\", \"ac3\", \"ac4\", \"ac5\", \"fp\", \"ap\" }\n+ \"ac0\", \"ac1\", \"ac2\", \"ac3\", \"ac4\", \"ac5\", \"fp\", \"ap\", \\\n+ \"cc\", \"fcc\" }\n \n /* Globalizing directive for a label.  */\n #define GLOBAL_ASM_OP \"\\t.globl \"\n@@ -603,10 +600,7 @@ extern rtx cc0_reg_rtx;\n #define TRAMPOLINE_SIZE 8\n #define TRAMPOLINE_ALIGNMENT 16\n \n-/* there is no point in avoiding branches on a pdp, \n-   since branches are really cheap - I just want to find out\n-   how much difference the BRANCH_COST macro makes in code */\n-#define BRANCH_COST(speed_p, predictable_p) pdp11_branch_cost ()\n+#define BRANCH_COST(speed_p, predictable_p) 1\n \n #define COMPARE_FLAG_MODE HImode\n "}, {"sha": "1dd069ff101b7cec1faaadf2fb12b85e80590229", "filename": "gcc/config/pdp11/pdp11.md", "status": "modified", "additions": 896, "deletions": 543, "changes": 1439, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4324a144b4499725143baf1f69722f92814572e/gcc%2Fconfig%2Fpdp11%2Fpdp11.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4324a144b4499725143baf1f69722f92814572e/gcc%2Fconfig%2Fpdp11%2Fpdp11.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11.md?ref=b4324a144b4499725143baf1f69722f92814572e", "patch": "@@ -44,28 +44,80 @@\n    ;; arguments.\n    (FRAME_POINTER_REGNUM  14)\n    (ARG_POINTER_REGNUM    15)\n-   (FIRST_PSEUDO_REGISTER 16)\n+   ;; Condition code registers\n+   (CC_REGNUM             16)\n+   (FCC_REGNUM            17)\n+   ;; End of hard registers\n+   (FIRST_PSEUDO_REGISTER 18)\n+   \n    ;; Branch offset limits, as byte offsets from instruction address\n    (MIN_BRANCH            -254)\n    (MAX_BRANCH            256)\n    (MIN_SOB               -126)\n    (MAX_SOB               0)])\n \n+;; DF is 64 bit\n+;; SF is 32 bit\n+;; SI is 32 bit\n ;; HI is 16 bit\n ;; QI is 8 bit \n \n ;; Integer modes supported on the PDP11, with a mapping from machine mode\n-;; to mnemonic suffix.  SImode and DImode always are special cases.\n+;; to mnemonic suffix.  SImode and DImode are usually special cases.\n (define_mode_iterator PDPint [QI HI])\n (define_mode_attr  isfx [(QI \"b\") (HI \"\")])\n+(define_mode_attr  mname [(QI \"QImode\") (HI \"HImode\") (SI \"SImode\") (DI \"DImode\")])\n+(define_mode_attr  e_mname [(QI \"E_QImode\") (HI \"E_HImode\") (SI \"E_SImode\") (DI \"E_DImode\")])\n+(define_mode_attr  hmode [(QI \"hi\") (HI \"hi\") (SI \"si\") (DI \"di\")])\n+\n+;; These are analogous for use in splitters and expanders.\n+(define_mode_iterator HSint [HI SI])\n+(define_mode_iterator QHSint [QI HI SI])\n+(define_mode_iterator QHSDint [QI HI SI DI])\n+\n+(define_code_iterator SHF [ashift ashiftrt lshiftrt])\n+\n+;; Substitution to turn a CC clobber into a CC setter.  We have four of\n+;; these: for CCmode vs. CCNZmode, and for CC_REGNUM vs. FCC_REGNUM.\n+(define_subst \"cc_cc\"\n+  [(set (match_operand 0 \"\") (match_operand 1 \"\"))\n+   (clobber (reg CC_REGNUM))]\n+  \"\"\n+  [(set (reg:CC CC_REGNUM)\n+\t(compare:CC (match_dup 1) (const_int 0)))\n+   (set (match_dup 0) (match_dup 1))])\n \n-;;- See file \"rtl.def\" for documentation on define_insn, match_*, et. al.\n+(define_subst \"cc_ccnz\"\n+  [(set (match_operand 0 \"\") (match_operand 1 \"\"))\n+   (clobber (reg CC_REGNUM))]\n+  \"\"\n+  [(set (reg:CCNZ CC_REGNUM)\n+\t(compare:CCNZ (match_dup 1) (const_int 0)))\n+   (set (match_dup 0) (match_dup 1))])\n \n-;;- cpp macro #define NOTICE_UPDATE_CC in file tm.h handles condition code\n-;;- updates for most instructions.\n+(define_subst \"fcc_cc\"\n+  [(set (match_operand 0 \"\") (match_operand 1 \"\"))\n+   (clobber (reg FCC_REGNUM))]\n+  \"\"\n+  [(set (reg:CC FCC_REGNUM)\n+\t(compare:CC (match_dup 1) (const_int 0)))\n+   (set (match_dup 0) (match_dup 1))])\n+\n+(define_subst \"fcc_ccnz\"\n+  [(set (match_operand 0 \"\") (match_operand 1 \"\"))\n+   (clobber (reg FCC_REGNUM))]\n+  \"\"\n+  [(set (reg:CCNZ FCC_REGNUM)\n+\t(compare:CCNZ (match_dup 1) (const_int 0)))\n+   (set (match_dup 0) (match_dup 1))])\n+\n+(define_subst_attr \"cc_cc\" \"cc_cc\" \"_nocc\" \"_cc\")\n+(define_subst_attr \"fcc_cc\" \"fcc_cc\" \"_nocc\" \"_cc\")\n+(define_subst_attr \"cc_ccnz\" \"cc_ccnz\" \"_nocc\" \"_cc\")\n+(define_subst_attr \"fcc_ccnz\" \"fcc_ccnz\" \"_nocc\" \"_cc\")\n+\n+;;- See file \"rtl.def\" for documentation on define_insn, match_*, et. al.\n \n-;;- Operand classes for the register allocator:\n-\f\n ;; Compare instructions.\n \n ;; currently we only support df floats, which saves us quite some\n@@ -82,16 +134,6 @@\n ;; and ucmp_optab for mode SImode, because we don't have that!!!\n ;; - yet since no libfunc is there, we abort ()\n \n-;; The only thing that remains to be done then is output \n-;; the floats in a way the assembler can handle it (and \n-;; if you're really into it, use a PDP11 float emulation\n-;; library to do floating point constant folding - but \n-;; I guess you'll get reasonable results even when not\n-;; doing this)\n-;; the last thing to do is fix the UPDATE_CC macro to check\n-;; for floating point condition codes, and set cc_status\n-;; properly, also setting the CC_IN_FCCR flag. \n-\n ;; define attributes\n ;; currently type is only fpu or arith or unknown, maybe branch later ?\n ;; default is arith\n@@ -163,24 +205,31 @@\n \n ;; compare\n (define_insn \"*cmpdf\"\n-  [(set (cc0)\n-\t(compare (match_operand:DF 0 \"general_operand\" \"fR,fR,Q,QF\")\n-\t\t (match_operand:DF 1 \"register_or_const0_operand\" \"G,a,G,a\")))]\n-  \"TARGET_FPU\"\n+  [(set (reg:CC FCC_REGNUM)\n+\t(compare:CC (match_operand:DF 0 \"general_operand\" \"fR,fR,Q,QF\")\n+\t\t    (match_operand:DF 1 \"register_or_const0_operand\" \"G,a,G,a\")))]\n+  \"TARGET_FPU && reload_completed\"\n   \"*\n {\n-  cc_status.flags = CC_IN_FPU;\n   if (which_alternative == 0 || which_alternative == 2)\n-    return \\\"{tstd|tstf} %0\\;cfcc\\\";\n+    return \\\"{tstd|tstf} %0\\\";\n   else\n-    return \\\"{cmpd|cmpf} %0, %1\\;cfcc\\\";\n+    return \\\"{cmpd|cmpf} %0, %1\\\";\n }\"\n-  [(set_attr \"length\" \"4,4,6,6\")]) \n-\n-(define_insn \"*cmp<mode>\"\n-  [(set (cc0)\n-\t(compare (match_operand:PDPint 0 \"general_operand\" \"rR,rR,rR,Q,Qi,Qi\")\n-\t\t (match_operand:PDPint 1 \"general_operand\" \"N,rR,Qi,N,rR,Qi\")))]\n+  [(set_attr \"length\" \"2,2,4,4\")\n+   (set_attr \"type\" \"fp\")]) \n+\n+;; Copy floating point processor condition code register to main CPU\n+;; condition code register.\n+(define_insn \"*cfcc\"\n+  [(set (reg CC_REGNUM) (reg FCC_REGNUM))]\n+  \"TARGET_FPU && reload_completed\"\n+  \"cfcc\")\n+\n+(define_insn \"cmp<mode>\"\n+  [(set (reg:CC CC_REGNUM)\n+\t(compare:CC (match_operand:PDPint 0 \"general_operand\" \"rR,rR,rR,Q,Qi,Qi\")\n+\t\t    (match_operand:PDPint 1 \"general_operand\" \"N,rR,Qi,N,rR,Qi\")))]\n   \"\"\n   \"@\n    tst<PDPint:isfx> %0\n@@ -191,8 +240,7 @@\n    cmp<PDPint:isfx> %0,%1\"\n   [(set_attr \"length\" \"2,2,4,4,4,6\")])\n \n-;; sob instruction - we need an assembler which can make this instruction\n-;; valid under _all_ circumstances!\n+;; sob instruction - FIXME: this doesn't do anything, need to use doloop_end.\n \n (define_insn \"\"\n   [(set (pc)\n@@ -208,22 +256,17 @@\n   \"TARGET_40_PLUS\"\n   \"*\n {\n- static int labelcount = 0;\n- static char buf[1000];\n-\n  if (get_attr_length (insn) == 2)\n     return \\\"sob %0, %l1\\\";\n \n  /* emulate sob */\n+ operands[2] = gen_label_rtx ();\n  output_asm_insn (\\\"dec %0\\\", operands);\n- \n- sprintf (buf, \\\"bge LONG_SOB%d\\\", labelcount);\n- output_asm_insn (buf, NULL);\n-\n+ output_asm_insn (\\\"beq %l2\\\", operands);\n  output_asm_insn (\\\"jmp %l1\\\", operands);\n  \n- sprintf (buf, \\\"LONG_SOB%d:\\\", labelcount++);\n- output_asm_insn (buf, NULL);\n+ output_asm_label (operands[2]);\n+ fputs (\\\":\\\\n\\\", asm_out_file);\n \n  return \\\"\\\";\n }\"\n@@ -238,46 +281,73 @@\n \n ;; These control RTL generation for conditional jump insns\n ;; and match them for register allocation.\n-\n-(define_expand \"cbranchdf4\"\n-  [(set (cc0)\n-        (compare (match_operand:DF 1 \"general_operand\")\n-\t\t (match_operand:DF 2 \"register_or_const0_operand\")))\n-   (set (pc)\n+;; Post reload these get expanded into insns that actually\n+;; manipulate the condition code registers.  We can't do that before\n+;; because instructions generated by reload clobber condition codes (new\n+;; CC design, type #2).\n+(define_insn_and_split \"cbranchdf4\"\n+  [(set (pc)\n \t(if_then_else (match_operator 0 \"ordered_comparison_operator\"\n-\t\t       [(cc0) (const_int 0)])\n+\t\t       [(match_operand:DF 1 \"general_operand\" \"fg\")\n+\t\t\t(match_operand:DF 2 \"general_operand\" \"a\")])\n \t\t      (label_ref (match_operand 3 \"\" \"\"))\n \t\t      (pc)))]\n   \"TARGET_FPU\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(set (reg:CC FCC_REGNUM)\n+\t(compare:CC (match_dup 1) (match_dup 2)))\n+   (set (pc)\n+\t(if_then_else (match_op_dup 0\n+                      [(reg:CC FCC_REGNUM) (const_int 0)])\n+\t\t      (label_ref (match_dup 3))\n+\t\t      (pc)))]\n   \"\")\n \n-(define_expand \"cbranch<mode>4\"\n-  [(set (cc0)\n-        (compare (match_operand:PDPint 1 \"general_operand\")\n-\t\t (match_operand:PDPint 2 \"general_operand\")))\n-   (set (pc)\n+(define_insn_and_split \"cbranch<mode>4\"\n+  [(set (pc)\n \t(if_then_else (match_operator 0 \"ordered_comparison_operator\"\n-\t\t       [(cc0) (const_int 0)])\n+\t\t       [(match_operand:PDPint 1 \"general_operand\" \"g\")\n+\t\t\t(match_operand:PDPint 2 \"general_operand\" \"g\")])\n \t\t      (label_ref (match_operand 3 \"\" \"\"))\n \t\t      (pc)))]\n   \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(set (reg:CC CC_REGNUM)\n+\t(compare:CC (match_dup 1) (match_dup 2)))\n+   (set (pc)\n+\t(if_then_else (match_op_dup 0\n+                      [(reg:CC CC_REGNUM) (const_int 0)])\n+\t\t      (label_ref (match_dup 3))\n+\t\t      (pc)))]\n   \"\")\n \n-;; problem with too short jump distance! we need an assembler which can \n-;; make this valid for all jump distances!\n-;; e.g. gas!\n-\n-;; these must be changed to check for CC_IN_FCCR if float is to be \n-;; enabled\n+;; This splitter turns a branch on float condition into a branch on\n+;; CPU condition, by adding a CFCC.\n+(define_split\n+  [(set (pc)\n+\t(if_then_else (match_operator 0 \"ordered_comparison_operator\"\n+                      [(reg:CC FCC_REGNUM) (const_int 0)])\n+\t\t      (label_ref (match_operand 1 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"TARGET_FPU && reload_completed\"\n+  [(set (reg:CC CC_REGNUM) (reg:CC FCC_REGNUM))\n+   (set (pc)\n+\t(if_then_else (match_op_dup 0\n+                      [(reg:CC CC_REGNUM) (const_int 0)])\n+\t\t      (label_ref (match_dup 1))\n+\t\t      (pc)))]\n+  \"\")\n \n-(define_insn \"*branch\"\n+(define_insn \"cond_branch\"\n   [(set (pc)\n \t(if_then_else (match_operator 0 \"ordered_comparison_operator\"\n-\t\t       [(cc0) (const_int 0)])\n+\t\t       [(reg:CC CC_REGNUM) (const_int 0)])\n \t\t      (label_ref (match_operand 1 \"\" \"\"))\n \t\t      (pc)))]\n-  \"\"\n-  \"* return output_jump(GET_CODE (operands[0]), 0, get_attr_length(insn));\"\n+  \"reload_completed\"\n+  \"* return output_jump (operands, 0, get_attr_length (insn));\"\n   [(set (attr \"length\") (if_then_else (ior (lt (minus (match_dup 1)\n \t\t\t\t\t\t      (pc))\n \t\t\t\t\t       (const_int MIN_BRANCH))\n@@ -287,17 +357,14 @@\n \t\t\t\t      (const_int 6)\n \t\t\t\t      (const_int 2)))])\n \n-\n-;; These match inverted jump insns for register allocation.\n-\n-(define_insn \"*branch_inverted\"\n+(define_insn \"*branch\"\n   [(set (pc)\n-\t(if_then_else (match_operator 0 \"ordered_comparison_operator\"\n-\t\t       [(cc0) (const_int 0)])\n-\t\t      (pc)\n-\t\t      (label_ref (match_operand 1 \"\" \"\"))))]\n-  \"\"\n-  \"* return output_jump(GET_CODE (operands[0]), 1, get_attr_length(insn));\"\n+\t(if_then_else (match_operator 0 \"ccnz_operator\"\n+\t\t       [(reg:CCNZ CC_REGNUM) (const_int 0)])\n+\t\t      (label_ref (match_operand 1 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"reload_completed\"\n+  \"* return output_jump (operands, 1, get_attr_length (insn));\"\n   [(set (attr \"length\") (if_then_else (ior (lt (minus (match_dup 1)\n \t\t\t\t\t\t      (pc))\n \t\t\t\t\t       (const_int MIN_BRANCH))\n@@ -306,27 +373,62 @@\n \t\t\t\t\t       (const_int MAX_BRANCH)))\n \t\t\t\t      (const_int 6)\n \t\t\t\t      (const_int 2)))])\n+\n \f\n ;; Move instructions\n \n (define_insn \"movdi\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=&r,g\")\n \t(match_operand:DI 1 \"general_operand\" \"rN,g\"))]\n   \"\"\n+  \"\")\n+\n+\n+(define_insn \"*movdi_nocc\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=&r,g\")\n+\t(match_operand:DI 1 \"general_operand\" \"rN,g\"))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"\"\n   \"* return output_move_multiple (operands);\"\n   [(set_attr \"length\" \"16,32\")])\n \n (define_insn \"movsi\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r,g,g\")\n \t(match_operand:SI 1 \"general_operand\" \"rN,IJ,IJ,g\"))]\n   \"\"\n+  \"\")\n+\n+(define_insn \"*movsi_nocc\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r,g,g\")\n+\t(match_operand:SI 1 \"general_operand\" \"rN,IJ,IJ,g\"))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"\"\n   \"* return output_move_multiple (operands);\"\n   [(set_attr \"length\" \"4,6,8,16\")])\n \n (define_insn \"mov<mode>\"\n   [(set (match_operand:PDPint 0 \"nonimmediate_operand\" \"=rR,rR,Q,Q\")\n \t(match_operand:PDPint 1 \"general_operand\" \"rRN,Qi,rRN,Qi\"))]\n   \"\"\n+  \"\")\n+\n+;; This splits all the integer moves: DI and SI modes as well as\n+;; the simple machine operations.\n+(define_split \n+  [(set (match_operand:QHSDint 0 \"nonimmediate_operand\" \"\")\n+\t(match_operand:QHSDint 1 \"general_operand\" \"\"))]\n+  \"reload_completed\"\n+  [(parallel [(set (match_dup 0)\n+\t\t   (match_dup 1))\n+\t      (clobber (reg:CC CC_REGNUM))])]\n+  \"\")\n+  \n+;; MOV clears V\n+(define_insn \"*mov<mode>_<cc_cc>\"\n+  [(set (match_operand:PDPint 0 \"nonimmediate_operand\" \"=rR,rR,Q,Q\")\n+\t(match_operand:PDPint 1 \"general_operand\" \"rRN,Qi,rRN,Qi\"))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"reload_completed\"\n   \"*\n {\n   if (operands[1] == const0_rtx)\n@@ -336,31 +438,87 @@\n }\"\n   [(set_attr \"length\" \"2,4,4,6\")])\n \n-(define_insn \"movdf\"\n-  [(set (match_operand:DF 0 \"float_nonimm_operand\" \"=a,fR,a,Q,g\")\n-        (match_operand:DF 1 \"float_operand\" \"fR,a,FQ,a,g\"))]\n+;; movdf has unusually complicated condition code handling, because\n+;; load (into float register) updates the FCC, while store (from\n+;; float register) leaves it untouched.\n+;;\n+;; 1. Loads are:  ac4, ac5, or non-register into load-register\n+;; 2. Stores are: load-register to non-register, ac4, or ac5\n+;; 3. Moves from ac0-ac3 to another ac0-ac3 can be handled\n+;;    either as loads or as stores.\n+\n+(define_expand \"movdf\"\n+  [(set (match_operand:DF 0 \"float_nonimm_operand\" \"\")\n+        (match_operand:DF 1 \"float_operand\" \"\"))]\n   \"TARGET_FPU\"\n-  \"* if (which_alternative ==0 || which_alternative == 2)\n-       return \\\"ldd %1, %0\\\";\n-     else if (which_alternative == 1 || which_alternative == 3)\n-       return \\\"std %1, %0\\\";\n-     else \n-       return output_move_multiple (operands); \"\n-;; last one is worst-case\n-  [(set_attr \"length\" \"2,2,4,4,24\")])\n+  \"\")\n \n-(define_insn \"movsf\"\n-  [(set (match_operand:SF 0 \"float_nonimm_operand\" \"=a,fR,a,Q,g\")\n-        (match_operand:SF 1 \"float_operand\" \"fR,a,FQ,a,g\"))]\n+;; Splitter for all these cases.  Store is the first two\n+;; alternatives, which are not split.  Note that case 3\n+;; is treated as a store, i.e., not split.\n+(define_insn_and_split \"movdf_split\"\n+  [(set (match_operand:DF 0 \"float_nonimm_operand\" \"=fR,FQ,a,a,a\")\n+        (match_operand:DF 1 \"float_operand\" \"a,a,hR,FQ,G\"))]\n   \"TARGET_FPU\"\n-  \"* if (which_alternative ==0 || which_alternative == 2)\n-       return \\\"{ldcfd|movof} %1, %0\\\";\n-     else if (which_alternative == 1 || which_alternative == 3)\n-       return \\\"{stcdf|movfo} %1, %0\\\";\n-     else \n-       return output_move_multiple (operands); \"\n-;; last one is worst-case\n-  [(set_attr \"length\" \"2,2,4,4,12\")])\n+  \"*\n+  gcc_assert (which_alternative < 2);\n+  return \\\"std %1, %0\\\";\n+  \"\n+  \"&& reload_completed\"\n+  [(parallel [(set (match_dup 0)\n+\t\t   (match_dup 1))\n+\t      (clobber (reg:CC FCC_REGNUM))])]\n+  \"{\n+  if (GET_CODE (operands[1]) == REG && \n+      REGNO_REG_CLASS (REGNO (operands[1])) == LOAD_FPU_REGS)\n+    FAIL;\n+  }\"\n+  [(set_attr \"length\" \"2,4,0,0,0\")])\n+\n+;; Loads (case 1).  \n+(define_insn \"*ldd<fcc_cc>\"\n+  [(set (match_operand:DF 0 \"float_nonimm_operand\" \"=a,a,a\")\n+        (match_operand:DF 1 \"float_operand\" \"hR,FQ,G\"))\n+   (clobber (reg:CC FCC_REGNUM))]\n+  \"TARGET_FPU && reload_completed\"\n+  \"@\n+  ldd %1, %0\n+  ldd %1, %0\n+  clrd %0\"\n+  [(set_attr \"length\" \"2,4,2\")])\n+\n+;; SFmode is easier because that uses convert load/store, which\n+;; always change condition codes.\n+;; Note that these insns are cheating a bit.  We actually have\n+;; DFmode operands in the FPU registers, which is why the\n+;; ldcfd and stcdf instructions appear.  But GCC likes to think\n+;; of these as SFmode loads and does the conversion once in the\n+;; register, at least in many cases.  So we pretend to do this,\n+;; but then extend and truncate register-to-register are NOP and\n+;; generate no code.\n+(define_insn_and_split \"movsf\"\n+  [(set (match_operand:SF 0 \"float_nonimm_operand\" \"=a,fR,a,Q\")\n+        (match_operand:SF 1 \"float_operand\" \"fRG,a,FQ,a\"))]\n+  \"TARGET_FPU\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(parallel [(set (match_dup 0)\n+\t\t   (match_dup 1))\n+\t      (clobber (reg:CC FCC_REGNUM))])]\n+  \"\")\n+  \n+(define_insn \"*movsf<fcc_ccnz>\"\n+  [(set (match_operand:SF 0 \"float_nonimm_operand\" \"=a,fR,a,Q,a\")\n+        (match_operand:SF 1 \"float_operand\" \"fR,a,FQ,a,G\"))\n+   (clobber (reg:CC FCC_REGNUM))]\n+  \"TARGET_FPU && reload_completed\"\n+  \"@\n+  {ldcfd|movof} %1, %0\n+  {stcdf|movfo} %1, %0\n+  {ldcfd|movof} %1, %0\n+  {stcdf|movfo} %1, %0\n+  clrf %0\"\n+  [(set_attr \"length\" \"2,2,4,4,2\")])\n \n ;; maybe fiddle a bit with move_ratio, then \n ;; let constraints only accept a register ...\n@@ -374,7 +532,7 @@\n \t      (clobber (match_dup 4))\n \t      (clobber (match_dup 5))\n \t      (clobber (match_dup 2))])]\n-  \"(TARGET_BCOPY_BUILTIN)\"\n+  \"\"\n   \"\n {\n   operands[0]\n@@ -389,7 +547,7 @@\n }\")\n \n \n-(define_insn \"movmemhi1\"\n+(define_insn \"*movmemhi1\"\n   [(set (mem:BLK (match_operand:HI 0 \"register_operand\" \"r,r\"))\n \t(mem:BLK (match_operand:HI 1 \"register_operand\" \"r,r\")))\n    (use (match_operand:HI 2 \"general_operand\" \"n,r\"))\n@@ -398,7 +556,7 @@\n    (clobber (match_dup 0))\n    (clobber (match_dup 1))\n    (clobber (match_dup 2))]\n-  \"(TARGET_BCOPY_BUILTIN)\"\n+  \"\"\n   \"* return output_block_move (operands);\"\n ;;; just a guess\n   [(set_attr \"length\" \"80\")])\n@@ -407,29 +565,56 @@\n \f\n ;;- truncation instructions\n \n-(define_insn  \"truncdfsf2\"\n+;; We sometimes end up doing a register to register truncate,\n+;; which isn't right because we actually load registers always\n+;; with a DFmode value.  But even with PROMOTE the compiler\n+;; doesn't always get that (so we don't use it).  That means\n+;; a register to register truncate is a NOP.\n+(define_insn_and_split  \"truncdfsf2\"\n   [(set (match_operand:SF 0 \"float_nonimm_operand\" \"=f,R,Q\")\n-\t(float_truncate:SF (match_operand:DF 1 \"register_operand\" \"f,a,a\")))]\n+\t(float_truncate:SF (match_operand:DF 1 \"register_operand\" \"0,a,a\")))]\n   \"TARGET_FPU\"\n-  \"* if (which_alternative ==0)\n-     {\n-       return \\\"\\\";\n-     }\n-     else if (which_alternative == 1)\n-       return \\\"{stcdf|movfo} %1, %0\\\";\n-     else \n-       return \\\"{stcdf|movfo} %1, %0\\\";\n-  \"\n-  [(set_attr \"length\" \"0,2,4\")])\n-\n+  {\n+    gcc_assert (which_alternative == 0);\n+    return \"\";\n+  }\t      \n+  \"&& reload_completed\"\n+  [(parallel [(set (match_dup 0) (float_truncate:SF (match_dup 1)))\n+\t      (clobber (reg:CC FCC_REGNUM))])]\n+  \"{\n+  if (GET_CODE (operands[0]) == REG && \n+      GET_CODE (operands[1]) == REG && \n+      REGNO (operands[0]) == REGNO (operands[1]))\n+    FAIL;\n+  }\"\n+  [(set_attr \"length\" \"0,0,0\")])\n+\n+(define_insn \"*truncdfsf2_<fcc_cc>\"\n+  [(set (match_operand:SF 0 \"float_nonimm_operand\" \"=R,Q\")\n+\t(float_truncate:SF (match_operand:DF 1 \"register_operand\" \"a,a\")))\n+   (clobber (reg:CC FCC_REGNUM))]\n+  \"TARGET_FPU && reload_completed\"\n+   \"{stcdf|movfo} %1, %0\"\n+  [(set_attr \"length\" \"2,4\")])\n \n \f\n ;;- zero extension instructions\n \n-(define_insn \"zero_extendqihi2\"\n+(define_insn_and_split \"zero_extendqihi2\"\n   [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=rR,Q\")\n \t(zero_extend:HI (match_operand:QI 1 \"general_operand\" \"0,0\")))]\n   \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel [(set (match_dup 0) (zero_extend:HI (match_dup 1)))\n+\t      (clobber (reg:CC CC_REGNUM))])]\n+  \"\")\n+\n+(define_insn \"*zero_extendqihi2<cc_cc>\"\n+  [(parallel [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=rR,Q\")\n+\t\t   (zero_extend:HI (match_operand:QI 1 \"general_operand\" \"0,0\")))\n+\t      (clobber (reg:CC CC_REGNUM))])]\n+  \"reload_completed\"\n   \"bic $0177400, %0\"\n   [(set_attr \"length\" \"4,6\")])\n \t\t\t \n@@ -448,56 +633,73 @@\n \f\n ;;- sign extension instructions\n \n-(define_insn \"extendsfdf2\"\n+;; We sometimes end up doing a register to register extend,\n+;; which isn't right because we actually load registers always\n+;; with a DFmode value.  But even with PROMOTE the compiler\n+;; doesn't always get that (so we don't use it).  That means\n+;; a register to register truncate is a NOP.\n+(define_insn_and_split \"extendsfdf2\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=f,a,a\")\n-\t(float_extend:DF (match_operand:SF 1 \"float_operand\" \"f,R,Q\")))]\n+\t(float_extend:DF (match_operand:SF 1 \"float_operand\" \"0,R,Q\")))]\n   \"TARGET_FPU\"\n-  \"@\n-   /* nothing */\n-   {ldcfd|movof} %1, %0\n-   {ldcfd|movof} %1, %0\"\n-  [(set_attr \"length\" \"0,2,4\")])\n+  {\n+    gcc_assert (which_alternative == 0);\n+    return \"\";\n+  }\t      \n+  \"&& reload_completed\"\n+  [(parallel [(set (match_dup 0) (float_extend:DF (match_dup 1)))\n+\t      (clobber (reg:CC FCC_REGNUM))])]\n+  \"{\n+  if (GET_CODE (operands[0]) == REG && \n+      GET_CODE (operands[1]) == REG && \n+      REGNO (operands[0]) == REGNO (operands[1]))\n+    FAIL;\n+  }\"\n+  [(set_attr \"length\" \"0,0,0\")])\n+\n+(define_insn \"*extendsfdf2_<fcc_cc>\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=a,a\")\n+\t(float_extend:DF (match_operand:SF 1 \"float_operand\" \"R,Q\")))\n+   (clobber (reg:CC FCC_REGNUM))]\n+  \"TARGET_FPU && reload_completed\"\n+  \"{ldcfd|movof} %1, %0\"\n+  [(set_attr \"length\" \"2,4\")])\n \n-;; does movb sign extend in register-to-register move?\n-(define_insn \"extendqihi2\"\n+;; movb sign extends if destination is a register\n+(define_insn_and_split \"extendqihi2\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n \t(sign_extend:HI (match_operand:QI 1 \"general_operand\" \"rR,Q\")))]\n   \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel [(set (match_dup 0) (sign_extend:HI (match_dup 1)))\n+\t      (clobber (reg:CC CC_REGNUM))])]\n+  \"\")\n+\n+;; MOVB clears V\n+(define_insn \"*extendqihi2<cc_cc>\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n+\t(sign_extend:HI (match_operand:QI 1 \"general_operand\" \"rR,Q\")))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"reload_completed\"\n   \"movb %1, %0\"\n   [(set_attr \"length\" \"2,4\")])\n \n-(define_insn \"extendqisi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n-\t(sign_extend:SI (match_operand:QI 1 \"general_operand\" \"rR,Q\")))]\n-  \"TARGET_40_PLUS\"\n-  \"*\n-{\n-  rtx latehalf[2];\n-\n-  /* make register pair available */\n-  latehalf[0] = operands[0];\n-  operands[0] = gen_rtx_REG (HImode, REGNO (operands[0])+ 1);\n-\n-  output_asm_insn(\\\"movb %1, %0\\\", operands);\n-  output_asm_insn(\\\"sxt %0\\\", latehalf);\n-    \n-  return \\\"\\\";\n-}\"\n-  [(set_attr \"length\" \"4,6\")])\n-\n-;; maybe we have to use define_expand to say that we have the instruction,\n-;; unconditionally, and then match dependent on CPU type:\n-\n-(define_expand \"extendhisi2\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=g\")\n-\t(sign_extend:SI (match_operand:HI 1 \"general_operand\" \"g\")))]\n-  \"\"\n-  \"\")\n-  \n-(define_insn \"\" ; \"extendhisi2\"\n+(define_insn_and_split \"extendhisi2\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=o,<,r\")\n \t(sign_extend:SI (match_operand:HI 1 \"general_operand\" \"g,g,g\")))]\n   \"TARGET_40_PLUS\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(parallel [(set (match_dup 0) (sign_extend:SI (match_dup 1)))\n+\t      (clobber (reg:CC CC_REGNUM))])]\n+  \"\")\n+\n+(define_insn \"*extendhisi2_nocc\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=o,<,r\")\n+\t(sign_extend:SI (match_operand:HI 1 \"general_operand\" \"g,g,g\")))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"TARGET_40_PLUS && reload_completed\"\n   \"*\n {\n   rtx latehalf[2];\n@@ -542,52 +744,33 @@\n }\"\n   [(set_attr \"length\" \"10,6,6\")])\n \n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(sign_extend:SI (match_operand:HI 1 \"general_operand\" \"0\")))]\n-  \"(! TARGET_40_PLUS)\"\n-  \"*\n-{\n-  static int count = 0;\n-  char buf[100];\n-  rtx lateoperands[2];\n-\n-  lateoperands[0] = operands[0];\n-  operands[0] = gen_rtx_REG (HImode, REGNO (operands[0]) + 1);\n-\n-  output_asm_insn(\\\"tst %0\\\", operands);\n-  sprintf(buf, \\\"bge extendhisi%d\\\", count);\n-  output_asm_insn(buf, NULL);\n-  output_asm_insn(\\\"mov -1, %0\\\", lateoperands);\n-  sprintf(buf, \\\"bne extendhisi%d\\\", count+1);\n-  output_asm_insn(buf, NULL);\n-  sprintf(buf, \\\"\\\\nextendhisi%d:\\\", count);\n-  output_asm_insn(buf, NULL);\n-  output_asm_insn(\\\"clr %0\\\", lateoperands);\n-  sprintf(buf, \\\"\\\\nextendhisi%d:\\\", count+1);\n-  output_asm_insn(buf, NULL);\n-\n-  count += 2;\n-\n-  return \\\"\\\";\n-}\"\n-  [(set_attr \"length\" \"12\")])\n-\n ;; make float to int and vice versa \n-;; using the cc_status.flag field we could probably cut down\n-;; on seti and setl\n ;; assume that we are normally in double and integer mode -\n ;; what do pdp library routines do to fpu mode ?\n \n-(define_insn \"floatsidf2\"\n+;; Note: the hardware treats register source as\n+;; a 16-bit (high order only) source, which isn't\n+;; what we want.  But we do need to support register\n+;; dest because gcc asks for it.\n+(define_insn_and_split \"floatsidf2\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=a,a,a\")\n \t(float:DF (match_operand:SI 1 \"general_operand\" \"r,R,Q\")))]\n   \"TARGET_FPU\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(parallel [(set (match_dup 0) (float:DF (match_dup 1)))\n+\t      (clobber (reg:CC FCC_REGNUM))])]\n+  \"\")\n+\n+(define_insn \"*floatsidf2<fcc_cc>\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=a,a,a\")\n+\t(float:DF (match_operand:SI 1 \"general_operand\" \"r,R,Q\")))\n+   (clobber (reg:CC FCC_REGNUM))]\n+  \"TARGET_FPU && reload_completed\"\n   \"* if (which_alternative ==0)\n      {\n        rtx latehalf[2];\n-\n+ \n        latehalf[0] = NULL; \n        latehalf[1] = gen_rtx_REG (HImode, REGNO (operands[1]) + 1);\n        output_asm_insn(\\\"mov %1, -(sp)\\\", latehalf);\n@@ -598,25 +781,53 @@\n        output_asm_insn(\\\"seti\\\", operands);\n        return \\\"\\\";\n      }\n-     else if (which_alternative == 1)\n-       return \\\"setl\\;{ldcld|movif} %1, %0\\;seti\\\";\n      else \n        return \\\"setl\\;{ldcld|movif} %1, %0\\;seti\\\";\n   \"\n   [(set_attr \"length\" \"10,6,8\")])\n \n-(define_insn \"floathidf2\"\n+(define_insn_and_split \"floathidf2\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=a,a\")\n \t(float:DF (match_operand:HI 1 \"general_operand\" \"rR,Qi\")))]\n   \"TARGET_FPU\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(parallel [(set (match_dup 0) (float:DF (match_dup 1)))\n+\t      (clobber (reg:CC FCC_REGNUM))])]\n+  \"\")\n+\n+(define_insn \"*floathidf2<fcc_cc>\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=a,a\")\n+\t(float:DF (match_operand:HI 1 \"general_operand\" \"rR,Qi\")))\n+   (clobber (reg:CC FCC_REGNUM))]\n+  \"TARGET_FPU && reload_completed\"\n   \"{ldcid|movif} %1, %0\"\n   [(set_attr \"length\" \"2,4\")])\n \t\n ;; cut float to int\n-(define_insn \"fix_truncdfsi2\"\n+\n+;; Note: the hardware treats register destination as\n+;; a 16-bit (high order only) destination, which isn't\n+;; what we want.  But we do need to support register\n+;; dest because gcc asks for it.\n+(define_insn_and_split \"fix_truncdfsi2\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,R,Q\")\n \t(fix:SI (fix:DF (match_operand:DF 1 \"register_operand\" \"a,a,a\"))))]\n   \"TARGET_FPU\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(parallel [(set (match_dup 0) (fix:SI (fix:DF (match_dup 1))))\n+\t      (clobber (reg:CC CC_REGNUM))\n+\t      (clobber (reg:CC FCC_REGNUM))])]\n+  \"\")\n+\n+;; Note: this clobbers both sets of condition codes!\n+(define_insn \"*fix_truncdfsi2_nocc\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,R,Q\")\n+\t(fix:SI (fix:DF (match_operand:DF 1 \"register_operand\" \"a,a,a\"))))\n+   (clobber (reg:CC CC_REGNUM))\n+   (clobber (reg:CC FCC_REGNUM))]\n+  \"TARGET_FPU && reload_completed\"\n   \"* if (which_alternative ==0)\n      {\n        output_asm_insn(\\\"setl\\\", operands);\n@@ -627,37 +838,75 @@\n        output_asm_insn(\\\"mov (sp)+, %0\\\", operands);\n        return \\\"\\\";\n      }\n-     else if (which_alternative == 1)\n-       return \\\"setl\\;{stcdl|movfi} %1, %0\\;seti\\\";\n      else \n        return \\\"setl\\;{stcdl|movfi} %1, %0\\;seti\\\";\n   \"\n   [(set_attr \"length\" \"10,6,8\")])\n \n-(define_insn \"fix_truncdfhi2\"\n+(define_insn_and_split \"fix_truncdfhi2\"\n   [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=rR,Q\")\n \t(fix:HI (fix:DF (match_operand:DF 1 \"register_operand\" \"a,a\"))))]\n   \"TARGET_FPU\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(parallel [(set (match_dup 0) (fix:HI (fix:DF (match_dup 1))))\n+\t      (clobber (reg:CC CC_REGNUM))\n+\t      (clobber (reg:CC FCC_REGNUM))])]\n+  \"\")\n+\n+;; Note: this clobbers both sets of condition codes!\n+(define_insn \"*fix_truncdfhi2_nocc\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=rR,Q\")\n+\t(fix:HI (fix:DF (match_operand:DF 1 \"register_operand\" \"a,a\"))))\n+   (clobber (reg:CC CC_REGNUM))\n+   (clobber (reg:CC FCC_REGNUM))]\n+  \"TARGET_FPU && reload_completed\"\n   \"{stcdi|movfi} %1, %0\"\n   [(set_attr \"length\" \"2,4\")])\n \n \f\n ;;- arithmetic instructions\n ;;- add instructions\n \n-(define_insn \"adddf3\"\n+(define_insn_and_split \"adddf3\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=a,a\")\n \t(plus:DF (match_operand:DF 1 \"register_operand\" \"%0,0\")\n \t\t (match_operand:DF 2 \"general_operand\" \"fR,QF\")))]\n   \"TARGET_FPU\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(parallel [(set (match_dup 0)\n+\t\t   (plus:DF (match_dup 1) (match_dup 2)))\n+\t      (clobber (reg:CC FCC_REGNUM))])]\n+  \"\")\n+\n+;; Float add sets V if overflow from add\n+(define_insn \"*adddf3<fcc_ccnz>\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=a,a\")\n+\t(plus:DF (match_operand:DF 1 \"register_operand\" \"%0,0\")\n+\t      (match_operand:DF 2 \"general_operand\" \"fR,QF\")))\n+   (clobber (reg:CC FCC_REGNUM))]\n+  \"TARGET_FPU && reload_completed\"\n   \"{addd|addf} %2, %0\"\n   [(set_attr \"length\" \"2,4\")])\n \n-(define_insn \"adddi3\"\n+(define_insn_and_split \"adddi3\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=&r,r,o,o\")\n \t(plus:DI (match_operand:DI 1 \"general_operand\" \"%0,0,0,0\")\n \t\t (match_operand:DI 2 \"general_operand\" \"r,on,r,on\")))]\n   \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel [(set (match_dup 0) (plus:DI (match_dup 1) (match_dup 2)))\n+\t      (clobber (reg:CC CC_REGNUM))])]\n+  \"\")\n+\n+(define_insn \"*adddi3_nocc\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=&r,r,o,o\")\n+\t(plus:DI (match_operand:DI 1 \"general_operand\" \"%0,0,0,0\")\n+\t      (match_operand:DI 2 \"general_operand\" \"r,on,r,on\")))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"reload_completed\"  \n   \"*\n {\n   rtx inops[2];\n@@ -701,11 +950,23 @@\n ;; high word is added at the end, so the adding of the high parts\n ;; will always used the original high part and not a high part\n ;; modified by carry (which would amount to double carry).\n-(define_insn \"addsi3\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r,o,o\")\n+(define_insn_and_split \"addsi3\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=&r,r,o,o\")\n \t(plus:SI (match_operand:SI 1 \"general_operand\" \"%0,0,0,0\")\n \t\t (match_operand:SI 2 \"general_operand\" \"r,on,r,on\")))]\n   \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel [(set (match_dup 0) (plus:SI (match_dup 1) (match_dup 2)))\n+\t      (clobber (reg:CC CC_REGNUM))])]\n+  \"\")\n+\n+(define_insn \"*addsi3_nocc\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=&r,r,o,o\")\n+\t(plus:SI (match_operand:SI 1 \"general_operand\" \"%0,0,0,0\")\n+\t      (match_operand:SI 2 \"general_operand\" \"r,on,r,on\")))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"reload_completed\"\n   \"*\n {\n   rtx inops[2];\n@@ -727,11 +988,25 @@\n }\"\n   [(set_attr \"length\" \"6,10,12,16\")])\n \n-(define_insn \"addhi3\"\n+(define_insn_and_split \"addhi3\"\n   [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=rR,rR,Q,Q\")\n \t(plus:HI (match_operand:HI 1 \"general_operand\" \"%0,0,0,0\")\n \t\t (match_operand:HI 2 \"general_operand\" \"rRLM,Qi,rRLM,Qi\")))]\n   \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel [(set (match_dup 0)\n+\t\t   (plus:HI (match_dup 1) (match_dup 2)))\n+\t      (clobber (reg:CC CC_REGNUM))])]\n+  \"\")\n+\n+;; Add sets V if overflow from the add\n+(define_insn \"*addhi3<cc_ccnz>\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=rR,rR,Q,Q\")\n+\t(plus:HI (match_operand:HI 1 \"general_operand\" \"%0,0,0,0\")\n+\t         (match_operand:HI 2 \"general_operand\" \"rRLM,Qi,rRLM,Qi\")))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"reload_completed\"\n   \"*\n {\n   if (GET_CODE (operands[2]) == CONST_INT)\n@@ -752,19 +1027,44 @@\n ;; args, since they are canonical plus:xx now!\n ;; also for minus:DF ??\n \n-(define_insn \"subdf3\"\n+(define_insn_and_split \"subdf3\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=a,a\")\n \t(minus:DF (match_operand:DF 1 \"register_operand\" \"0,0\")\n \t\t  (match_operand:DF 2 \"general_operand\" \"fR,Q\")))]\n   \"TARGET_FPU\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(parallel [(set (match_dup 0)\n+\t\t   (minus:DF (match_dup 1) (match_dup 2)))\n+\t      (clobber (reg:CC FCC_REGNUM))])]\n+  \"\")\n+\n+(define_insn \"*subdf3<fcc_ccnz>\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=a,a\")\n+\t(minus:DF (match_operand:DF 1 \"register_operand\" \"0,0\")\n+\t          (match_operand:DF 2 \"general_operand\" \"fR,QF\")))\n+   (clobber (reg:CC FCC_REGNUM))]\n+  \"TARGET_FPU && reload_completed\"\n   \"{subd|subf} %2, %0\"\n   [(set_attr \"length\" \"2,4\")])\n \n-(define_insn \"subdi3\"\n+(define_insn_and_split \"subdi3\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=&r,r,o,o\")\n \t(minus:DI (match_operand:DI 1 \"general_operand\" \"0,0,0,0\")\n \t\t (match_operand:DI 2 \"general_operand\" \"r,on,r,on\")))]\n   \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel [(set (match_dup 0) (minus:DI (match_dup 1) (match_dup 2)))\n+\t      (clobber (reg:CC CC_REGNUM))])]\n+  \"\")\n+\n+(define_insn \"*subdi3_nocc\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=&r,r,o,o\")\n+\t(minus:DI (match_operand:DI 1 \"general_operand\" \"0,0,0,0\")\n+\t      (match_operand:DI 2 \"general_operand\" \"r,on,r,on\")))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"reload_completed\"\n   \"*\n {\n   rtx inops[2];\n@@ -799,11 +1099,23 @@\n }\"\n   [(set_attr \"length\" \"20,28,40,48\")])\n \n-(define_insn \"subsi3\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r,o,o\")\n+(define_insn_and_split \"subsi3\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=&r,r,o,o\")\n \t(minus:SI (match_operand:SI 1 \"general_operand\" \"0,0,0,0\")\n \t\t (match_operand:SI 2 \"general_operand\" \"r,on,r,on\")))]\n   \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel [(set (match_dup 0) (minus:SI (match_dup 1) (match_dup 2)))\n+\t      (clobber (reg:CC CC_REGNUM))])]\n+  \"\")\n+\n+(define_insn \"*subsi3_nocc\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=&r,r,o,o\")\n+\t(minus:SI (match_operand:SI 1 \"general_operand\" \"0,0,0,0\")\n+\t      (match_operand:SI 2 \"general_operand\" \"r,on,r,on\")))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"reload_completed\"\n   \"*\n {\n   rtx inops[2];\n@@ -825,14 +1137,37 @@\n }\"\n   [(set_attr \"length\" \"6,10,12,16\")])\n \n-(define_insn \"subhi3\"\n+(define_insn_and_split \"subhi3\"\n   [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=rR,rR,Q,Q\")\n \t(minus:HI (match_operand:HI 1 \"general_operand\" \"0,0,0,0\")\n-\t\t  (match_operand:HI 2 \"general_operand\" \"rR,Qi,rR,Qi\")))]\n+\t\t  (match_operand:HI 2 \"general_operand\" \"rRLM,Qi,rRLM,Qi\")))]\n   \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel [(set (match_dup 0)\n+\t\t   (minus:HI (match_dup 1) (match_dup 2)))\n+\t      (clobber (reg:CC CC_REGNUM))])]\n+  \"\")\n+\n+;; Note: the manual says that (minus m (const_int n)) is converted\n+;; to (plus m (const_int -n)) but that does not appear to be\n+;; the case when it's wrapped in a PARALLEL.  So instead we handle\n+;; that case here, which is easy enough.\n+(define_insn \"*subhi3<cc_ccnz>\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=rR,rR,Q,Q\")\n+\t(minus:HI (match_operand:HI 1 \"general_operand\" \"0,0,0,0\")\n+\t          (match_operand:HI 2 \"general_operand\" \"rRLM,Qi,rRLM,Qi\")))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"reload_completed\"\n   \"*\n {\n-  gcc_assert (GET_CODE (operands[2]) != CONST_INT);\n+  if (GET_CODE (operands[2]) == CONST_INT)\n+    {\n+      if (INTVAL(operands[2]) == 1)\n+\treturn \\\"dec %0\\\";\n+      else if (INTVAL(operands[2]) == -1)\n+        return \\\"inc %0\\\";\n+    }\n \n   return \\\"sub %2, %0\\\";\n }\"\n@@ -867,317 +1202,288 @@\n     operands[1] = expand_unop (<MODE>mode, one_cmpl_optab, op1, 0, 1);\n }\")\n \n-(define_insn \"*bic<mode>\"\n+(define_insn_and_split \"*bic<mode>\"\n   [(set (match_operand:PDPint 0 \"nonimmediate_operand\" \"=rR,rR,Q,Q\")\n \t(and:PDPint\n \t     (not: PDPint (match_operand:PDPint 1 \"general_operand\" \"rR,Qi,rR,Qi\"))\n \t     (match_operand:PDPint 2 \"general_operand\" \"0,0,0,0\")))]\n   \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel [(set (match_dup 0)\n+\t\t   (and:PDPint (not:PDPint (match_dup 1)) (match_dup 2)))\n+\t      (clobber (reg:CC CC_REGNUM))])]\n+  \"\")\n+\n+(define_insn \"*bic<mode><cc_cc>\"\n+  [(set (match_operand:PDPint 0 \"nonimmediate_operand\" \"=rR,rR,Q,Q\")\n+\t(and:PDPint\n+\t     (not: PDPint (match_operand:PDPint 1 \"general_operand\" \"rR,Qi,rR,Qi\"))\n+\t\t\t  (match_operand:PDPint 2 \"general_operand\" \"0,0,0,0\")))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"reload_completed\"\n   \"bic<PDPint:isfx> %1, %0\"\n   [(set_attr \"length\" \"2,4,4,6\")])\n \n ;;- Bit set (inclusive or) instructions\n-(define_insn \"ior<mode>3\"\n+(define_insn_and_split \"ior<mode>3\"\n   [(set (match_operand:PDPint 0 \"nonimmediate_operand\" \"=rR,rR,Q,Q\")\n \t(ior:PDPint (match_operand:PDPint 1 \"general_operand\" \"%0,0,0,0\")\n-\t\t(match_operand:PDPint 2 \"general_operand\" \"rR,Qi,rR,Qi\")))]\n+\t\t    (match_operand:PDPint 2 \"general_operand\" \"rR,Qi,rR,Qi\")))]\n   \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel [(set (match_dup 0)\n+\t\t   (ior:PDPint (match_dup 1) (match_dup 2)))\n+\t      (clobber (reg:CC CC_REGNUM))])]\n+  \"\")\n+\n+(define_insn \"ior<mode>3<cc_cc>\"\n+  [(set (match_operand:PDPint 0 \"nonimmediate_operand\" \"=rR,rR,Q,Q\")\n+\t(ior:PDPint (match_operand:PDPint 1 \"general_operand\" \"%0,0,0,0\")\n+\t     (match_operand:PDPint 2 \"general_operand\" \"rR,Qi,rR,Qi\")))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"reload_completed\"\n   \"bis<PDPint:isfx> %2, %0\"\n   [(set_attr \"length\" \"2,4,4,6\")])\n \n ;;- xor instructions\n-(define_insn \"xorhi3\"\n+(define_insn_and_split \"xorhi3\"\n   [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=rR,Q\")\n \t(xor:HI (match_operand:HI 1 \"general_operand\" \"%0,0\")\n \t\t(match_operand:HI 2 \"register_operand\" \"r,r\")))]\n   \"TARGET_40_PLUS\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(parallel [(set (match_dup 0)\n+\t\t   (xor:HI (match_dup 1) (match_dup 2)))\n+\t      (clobber (reg:CC CC_REGNUM))])]\n+  \"\")\n+\n+(define_insn \"*xorhi3<cc_cc>\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=rR,Q\")\n+\t(xor:HI (match_operand:HI 1 \"general_operand\" \"%0,0\")\n+\t     (match_operand:HI 2 \"register_operand\" \"r,r\")))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"TARGET_40_PLUS && reload_completed\"\n   \"xor %2, %0\"\n   [(set_attr \"length\" \"2,4\")])\n \n ;;- one complement instructions\n \n-(define_insn \"one_cmpl<mode>2\"\n+(define_insn_and_split \"one_cmpl<mode>2\"\n   [(set (match_operand:PDPint 0 \"nonimmediate_operand\" \"=rR,Q\")\n         (not:PDPint (match_operand:PDPint 1 \"general_operand\" \"0,0\")))]\n   \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel [(set (match_dup 0)\n+\t\t   (not:PDPint (match_dup 1)))\n+\t      (clobber (reg:CC CC_REGNUM))])]\n+  \"\")\n+\n+(define_insn \"*one_cmpl<mode>2<cc_cc>\"\n+  [(set (match_operand:PDPint 0 \"nonimmediate_operand\" \"=rR,Q\")\n+\t(not:PDPint (match_operand:PDPint 1 \"general_operand\" \"0,0\")))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"reload_completed\"\n   \"com<PDPint:isfx> %0\"\n   [(set_attr \"length\" \"2,4\")])\n \n ;;- arithmetic shift instructions\n-(define_insn \"ashlsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n-\t(ashift:SI (match_operand:SI 1 \"register_operand\" \"0,0\")\n-\t\t   (match_operand:HI 2 \"general_operand\" \"rR,Qi\")))]\n-  \"TARGET_40_PLUS\"\n-  \"ashc %2,%0\"\n-  [(set_attr \"length\" \"2,4\")])\n-\n-;; Arithmetic right shift on the pdp works by negating the shift count.\n-(define_expand \"ashrsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(ashift:SI (match_operand:SI 1 \"register_operand\" \"0\")\n-\t\t   (match_operand:HI 2 \"general_operand\" \"g\")))]\n+;;\n+;; There is a fair amount of complexity here because with -m10\n+;; (pdp-11/10, /20) we only have shift by one bit.  Iterators are\n+;; used to reduce the amount of very similar code.\n+;;\n+;; First the insns used for small constant shifts.\n+;\n+;; The \"length\" attribute values are modified by the ADJUST_INSN_LENGTH\n+;; macro for the small constant shift case (first two alternatives).\n+;; For those, the value coded in the length attribute is the cost of just\n+;; the shift for a single shift.\n+(define_insn \"<code><mode>_sc\"\n+  [(set (match_operand:QHSint 0 \"nonimmediate_operand\" \"=rD,Q\")\n+\t(SHF:QHSint (match_operand:QHSint 1 \"general_operand\" \"0,0\")\n+\t            (match_operand:HI 2 \"expand_shift_operand\" \"O,O\")))]\n   \"\"\n-  \"\n-{\n-  operands[2] = negate_rtx (HImode, operands[2]);\n-}\")\n-\n-;; define asl aslb asr asrb - ashc missing!\n+  \"* return pdp11_assemble_shift (operands, <QHSint:mname>, <CODE>);\"\n+  [(set_attr \"length\" \"2,4\")])\n \n-;; asl \n-(define_insn \"\" \n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=rR,Q\")\n-\t(ashift:HI (match_operand:HI 1 \"general_operand\" \"0,0\")\n-\t\t   (const_int 1)))]\n+;; Next, shifts that are done as a loop on base (11/10 class) machines.\n+;; This applies to shift counts too large to unroll, or variable shift\n+;; counts.  The check for count <= 0 is done before we get here.\n+(define_insn \"<code><mode>_base\"\n+  [(set (match_operand:QHSint 0 \"nonimmediate_operand\" \"=rD,Q\")\n+\t(SHF:QHSint (match_operand:QHSint 1 \"general_operand\" \"0,0\")\n+\t     (match_operand:HI 2 \"register_operand\" \"r,r\")))\n+   (clobber (match_dup 2))]\n   \"\"\n-  \"asl %0\"\n+  \"* return pdp11_assemble_shift (operands, <QHSint:mname>, <CODE>);\"\n   [(set_attr \"length\" \"2,4\")])\n \n-;; and another possibility for asr is << -1\n-;; might cause problems since -1 can also be encoded as 65535!\n-;; not in gcc2 ??? \n-\n-;; asr\n-(define_insn \"\" \n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=rR,Q\")\n+;; Next the insns that use the extended instructions ash and ashc.\n+;; Note that these are just left shifts, and HI/SI only.  (Right shifts\n+;; are done by shifting by a negative amount.)\n+(define_insn \"aslhi_op\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=r,r\")\n \t(ashift:HI (match_operand:HI 1 \"general_operand\" \"0,0\")\n-\t\t   (const_int -1)))]\n-  \"\"\n-  \"asr %0\"\n+\t               (match_operand:HI 2 \"general_operand\" \"rR,Q\")))]\n+  \"TARGET_40_PLUS\"\n+  \"ash %2, %0\"\n   [(set_attr \"length\" \"2,4\")])\n \n-;; lsr\n-(define_insn \"lsrhi1\" \n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=rR,Q\")\n-\t(lshiftrt:HI (match_operand:HI 1 \"general_operand\" \"0,0\")\n-\t\t   (const_int 1)))]\n-  \"\"\n-  \"clc\\;ror %0\"\n+(define_insn \"aslsi_op\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r\")\n+\t(ashift:SI (match_operand:SI 1 \"general_operand\" \"0,0\")\n+\t           (match_operand:HI 2 \"general_operand\" \"rR,Q\")))]\n+  \"TARGET_40_PLUS\"\n+  \"ashc %2, %0\"\n   [(set_attr \"length\" \"2,4\")])\n \n-(define_insn \"lsrsi1\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(lshiftrt:SI (match_operand:SI 1 \"general_operand\" \"0\")\n-                   (const_int 1)))]\n-  \"\"\n-{\n-\n-  rtx lateoperands[2];\n-\n-  lateoperands[0] = operands[0];\n-  operands[0] = gen_rtx_REG (HImode, REGNO (operands[0]) + 1);\n-\n-  lateoperands[1] = operands[1];\n-  operands[1] = gen_rtx_REG (HImode, REGNO (operands[1]) + 1);\n-\n-  output_asm_insn (\\\"clc\\\", operands);\n-  output_asm_insn (\\\"ror %0\\\", lateoperands);\n-  output_asm_insn (\\\"ror %0\\\", operands);\n-\n-  return \\\"\\\";\n-}\n-  [(set_attr \"length\" \"10\")])\n-\n-(define_expand \"lshrsi3\"\n-  [(match_operand:SI 0 \"register_operand\" \"\")\n-   (match_operand:SI 1 \"register_operand\" \"0\")\n+;; Now the expanders that produce the insns defined above. \n+(define_expand \"ashl<mode>3\"\n+  [(match_operand:QHSint 0 \"nonimmediate_operand\" \"\")\n+   (match_operand:QHSint 1 \"general_operand\" \"\")\n    (match_operand:HI 2 \"general_operand\" \"\")]\n   \"\"\n   \"\n {\n   rtx r;\n \n-  if (!TARGET_40_PLUS &&\n-      (GET_CODE (operands[2]) != CONST_INT ||\n-       (unsigned) INTVAL (operands[2]) > 3))\n-    FAIL;\n-  emit_insn (gen_lsrsi1 (operands[0], operands[1]));\n-  if (GET_CODE (operands[2]) != CONST_INT)\n+  if (!pdp11_expand_shift (operands, gen_ashift<mode>_sc, gen_ashift<mode>_base))\n     {\n-      r = gen_reg_rtx (HImode);\n-      emit_insn (gen_addhi3 (r, operands [2], GEN_INT (-1)));\n-      emit_insn (gen_ashrsi3 (operands[0], operands[0], r));\n-    }\n-  else if ((unsigned) INTVAL (operands[2]) != 1)\n-    {\n-      emit_insn (gen_ashlsi3 (operands[0], operands[0],\n-                              GEN_INT (1 - INTVAL (operands[2]))));\n+      if (<QHSint:e_mname> == E_QImode)\n+        {\n+          r = copy_to_mode_reg (HImode, gen_rtx_ZERO_EXTEND (HImode, operands[1]));\n+          emit_insn (gen_aslhi_op (r, r, operands[2]));\n+          emit_insn (gen_movqi (operands[0], gen_rtx_SUBREG (QImode, r, 0)));\n+        }\n+      else\n+        {\n+          emit_insn (gen_asl<QHSint:hmode>_op (operands[0], operands[1], operands[2]));\n+        }\n     }\n   DONE;\n-}\n-\"\n-)\n-\n-;; shift is by arbitrary count is expensive, \n-;; shift by one cheap - so let's do that, if\n-;; space doesn't matter\n-(define_insn \"\" \n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=r\")\n-\t(ashift:HI (match_operand:HI 1 \"general_operand\" \"0\")\n-\t\t   (match_operand:HI 2 \"expand_shift_operand\" \"O\")))]\n-  \"! optimize_size\"\n-  \"*\n-{\n-  register int i;\n-\n-  for (i = 1; i <= abs(INTVAL(operands[2])); i++)\n-    if (INTVAL(operands[2]) < 0)\n-      output_asm_insn(\\\"asr %0\\\", operands);\n-    else\n-      output_asm_insn(\\\"asl %0\\\", operands);\n-      \n-  return \\\"\\\";\n-}\"\n-;; longest is 4\n-  [(set (attr \"length\") (const_int 8))])\n-\n-;; aslb\n-(define_insn \"\" \n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=r,o\")\n-\t(ashift:QI (match_operand:QI 1 \"general_operand\" \"0,0\")\n-\t\t   (match_operand:HI 2 \"const_int_operand\" \"n,n\")))]\n-  \"\"\n-  \"*\n-{ /* allowing predec or post_inc is possible, but hairy! */\n-  int i, cnt;\n-\n-  cnt = INTVAL(operands[2]) & 0x0007;\n-\n-  for (i=0 ; i < cnt ; i++)\n-       output_asm_insn(\\\"aslb %0\\\", operands);\n+}\")\n \n-  return \\\"\\\";\n-}\"\n-;; set attribute length ( match_dup 2 & 7 ) *(1 or 2) !!!\n-  [(set_attr_alternative \"length\" \n-                         [(const_int 14)\n-                          (const_int 28)])])\n-\n-;;; asr \n-;(define_insn \"\" \n-;  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=rR,Q\")\n-;\t(ashiftrt:HI (match_operand:HI 1 \"general_operand\" \"0,0\")\n-;\t\t     (const_int 1)))]\n-;  \"\"\n-;  \"asr %0\"\n-;  [(set_attr \"length\" \"2,4\")])\n-\n-;; asrb\n-(define_insn \"\" \n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=r,o\")\n-\t(ashiftrt:QI (match_operand:QI 1 \"general_operand\" \"0,0\")\n-\t\t     (match_operand:HI 2 \"const_int_operand\" \"n,n\")))]\n+(define_expand \"ashr<mode>3\"\n+  [(match_operand:QHSint 0 \"nonimmediate_operand\" \"\")\n+   (match_operand:QHSint 1 \"general_operand\" \"\")\n+   (match_operand:HI 2 \"general_operand\" \"\")]\n   \"\"\n-  \"*\n-{ /* allowing predec or post_inc is possible, but hairy! */\n-  int i, cnt;\n-\n-  cnt = INTVAL(operands[2]) & 0x0007;\n-\n-  for (i=0 ; i < cnt ; i++)\n-       output_asm_insn(\\\"asrb %0\\\", operands);\n-\n-  return \\\"\\\";\n-}\"\n-  [(set_attr_alternative \"length\" \n-                         [(const_int 14)\n-                          (const_int 28)])])\n-\n-;; the following is invalid - too complex!!! - just say 14 !!!\n-;  [(set (attr \"length\") (plus (and (match_dup 2)\n-;                                   (const_int 14))\n-;                              (and (match_dup 2)\n-;                                   (const_int 14))))])\n-\n-\n-\n-;; can we get +-1 in the next pattern? should \n-;; have been caught by previous patterns!\n-\n-(define_insn \"ashlhi3\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n-\t(ashift:HI (match_operand:HI 1 \"register_operand\" \"0,0\")\n-\t\t   (match_operand:HI 2 \"general_operand\" \"rR,Qi\")))]\n-  \"TARGET_40_PLUS\"\n-  \"*\n+  \"\n {\n-  if (GET_CODE(operands[2]) == CONST_INT)\n+  rtx r;\n+\n+  if (!pdp11_expand_shift (operands, gen_ashiftrt<mode>_sc, gen_ashiftrt<mode>_base))\n     {\n-      if (INTVAL(operands[2]) == 1)\n-\treturn \\\"asl %0\\\";\n-      else if (INTVAL(operands[2]) == -1)\n-\treturn \\\"asr %0\\\";\n+      operands[2] = negate_rtx (HImode, operands[2]);\n+      if (<QHSint:e_mname> == E_QImode)\n+        {\n+          r = copy_to_mode_reg (HImode, gen_rtx_ZERO_EXTEND (HImode, operands[1]));\n+          emit_insn (gen_aslhi_op (r, r, operands[2]));\n+          emit_insn (gen_movqi (operands[0], gen_rtx_SUBREG (QImode, r, 0)));\n+        }\n+      else\n+        {\n+          emit_insn (gen_asl<QHSint:hmode>_op (operands[0], operands[1], operands[2]));\n+        }\n     }\n-\n-  return \\\"ash %2,%0\\\";\n-}\"\n-  [(set_attr \"length\" \"2,4\")])\n-\n-;; Arithmetic right shift on the pdp works by negating the shift count.\n-(define_expand \"ashrhi3\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n-\t(ashift:HI (match_operand:HI 1 \"register_operand\" \"0\")\n-\t\t   (match_operand:HI 2 \"general_operand\" \"g\")))]\n-  \"\"\n-  \"\n-{\n-  operands[2] = negate_rtx (HImode, operands[2]);\n+  DONE;\n }\")\n \n-(define_expand \"lshrhi3\"\n-  [(match_operand:HI 0 \"register_operand\" \"\")\n-   (match_operand:HI 1 \"register_operand\" \"\")\n+(define_expand \"lshr<mode>3\"\n+  [(match_operand:QHSint 0 \"nonimmediate_operand\" \"\")\n+   (match_operand:QHSint 1 \"general_operand\" \"\")\n    (match_operand:HI 2 \"general_operand\" \"\")]\n   \"\"\n   \"\n {\n-  rtx r;\n+  rtx r, n;\n \n-  if (!TARGET_40_PLUS &&\n-      (GET_CODE (operands[2]) != CONST_INT ||\n-       (unsigned) INTVAL (operands[2]) > 3))\n-    FAIL;\n-  emit_insn (gen_lsrhi1 (operands[0], operands[1]));\n-  if (GET_CODE (operands[2]) != CONST_INT)\n-    {\n-      r = gen_reg_rtx (HImode);\n-      emit_insn (gen_addhi3 (r, operands [2], GEN_INT (-1)));\n-      emit_insn (gen_ashrhi3 (operands[0], operands[0], r));\n-    }\n-  else if ((unsigned) INTVAL (operands[2]) != 1)\n+  if (!pdp11_expand_shift (operands, gen_lshiftrt<mode>_sc, gen_lshiftrt<mode>_base))\n     {\n-      emit_insn (gen_ashlhi3 (operands[0], operands[0],\n-                              GEN_INT (1 - INTVAL (operands[2]))));\n+      if (<QHSint:e_mname> == E_QImode)\n+        {\n+          r = copy_to_mode_reg (HImode, gen_rtx_ZERO_EXTEND (HImode, operands[1]));\n+          emit_insn (gen_aslhi_op (r, r, operands[2]));\n+          emit_insn (gen_movqi (operands[0], gen_rtx_SUBREG (QImode, r, 0)));\n+        }\n+      else\n+        {\n+          r = gen_reg_rtx (<QHSint:mname>);\n+          emit_insn (gen_lshiftrt<mode>_sc (r, operands[1], const1_rtx));\n+          if (GET_CODE (operands[2]) != CONST_INT)\n+            {\n+              n = gen_reg_rtx (HImode);\n+              emit_insn (gen_addhi3 (n, operands [2], GEN_INT (-1)));\n+              emit_insn (gen_ashr<mode>3 (operands[0], r, n));\n+            }\n+          else\n+            emit_insn (gen_asl<QHSint:hmode>_op (operands[0], r,\n+\t\t\t\t  GEN_INT (1 - INTVAL (operands[2]))));\n+        }\n     }\n   DONE;\n-}\n-\"\n-)\n+}\")\n \n ;; absolute \n \n-(define_insn \"absdf2\"\n+(define_insn_and_split \"absdf2\"\n   [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=fR,Q\")\n \t(abs:DF (match_operand:DF 1 \"general_operand\" \"0,0\")))]\n   \"TARGET_FPU\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(parallel [(set (match_dup 0) (abs:DF (match_dup 1)))\n+\t      (clobber (reg:CC FCC_REGNUM))])]\n+   \"\")\n+\n+(define_insn \"absdf2<fcc_cc>\"\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=fR,Q\")\n+\t(abs:DF (match_operand:DF 1 \"general_operand\" \"0,0\")))\n+   (clobber (reg:CC FCC_REGNUM))]\n+  \"TARGET_FPU && reload_completed\"\n   \"{absd|absf} %0\"\n   [(set_attr \"length\" \"2,4\")])\n \n-\n ;; negate insns\n \n-(define_insn \"negdf2\"\n-  [(set (match_operand:DF 0 \"float_nonimm_operand\" \"=fR,Q\")\n-\t(neg:DF (match_operand:DF 1 \"register_operand\" \"0,0\")))]\n+(define_insn_and_split \"negdf2\"\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=fR,Q\")\n+\t(neg:DF (match_operand:DF 1 \"general_operand\" \"0,0\")))]\n   \"TARGET_FPU\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(parallel [(set (match_dup 0) (neg:DF (match_dup 1)))\n+\t      (clobber (reg:CC FCC_REGNUM))])]\n+   \"\")\n+\n+(define_insn \"negdf2<fcc_cc>\"\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=fR,Q\")\n+\t(neg:DF (match_operand:DF 1 \"general_operand\" \"0,0\")))\n+   (clobber (reg:CC FCC_REGNUM))]\n+  \"TARGET_FPU && reload_completed\"\n   \"{negd|negf} %0\"\n   [(set_attr \"length\" \"2,4\")])\n \n-(define_insn \"negdi2\"\n+(define_insn_and_split \"negdi2\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,o\")\n \t(neg:DI (match_operand:DI 1 \"general_operand\" \"0,0\")))]\n   \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel [(set (match_dup 0) (neg:DI (match_dup 1)))\n+\t      (clobber (reg:CC CC_REGNUM))])]\n+  \"\")\n+  \n+;; TODO: this can be neg/adc/neg/adc... I believe.  Check.  Saves one word.\n+(define_insn \"negdi2_nocc\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,o\")\n+\t(neg:DI (match_operand:DI 1 \"general_operand\" \"0,0\")))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"reload_completed\"\n {\n   rtx exops[4][2];\n   \n@@ -1196,10 +1502,22 @@\n }\n [(set_attr \"length\" \"18,34\")])\n \n-(define_insn \"negsi2\"\n+(define_insn_and_split \"negsi2\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,o\")\n \t(neg:SI (match_operand:SI 1 \"general_operand\" \"0,0\")))]\n   \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel [(set (match_dup 0) (neg:SI (match_dup 1)))\n+\t      (clobber (reg:CC CC_REGNUM))])]\n+  \"\")\n+  \n+;; TODO: this can be neg/adc/neg/adc... I believe.  Check.  Saves one word.\n+(define_insn \"negsi2_nocc\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,o\")\n+\t(neg:SI (match_operand:SI 1 \"general_operand\" \"0,0\")))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"reload_completed\"\n {\n   rtx exops[2][2];\n   \n@@ -1212,13 +1530,24 @@\n \n   return \\\"\\\";\n }\n-[(set_attr \"length\" \"12,20\")])\n+[(set_attr \"length\" \"10,18\")])\n \n-(define_insn \"neg<mode>2\"\n+(define_insn_and_split \"neg<mode>2\"\n   [(set (match_operand:PDPint 0 \"nonimmediate_operand\" \"=rR,Q\")\n \t(neg:PDPint (match_operand:PDPint 1 \"general_operand\" \"0,0\")))]\n   \"\"\n-  \"neg<isfx> %0\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel [(set (match_dup 0) (neg:PDPint (match_dup 1)))\n+\t      (clobber (reg:CC CC_REGNUM))])]\n+  \"\")\n+  \n+(define_insn \"neg<mode>2<cc_ccnz>\"\n+  [(set (match_operand:PDPint 0 \"nonimmediate_operand\" \"=rR,Q\")\n+\t(neg:PDPint (match_operand:PDPint 1 \"general_operand\" \"0,0\")))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"\"\n+  \"neg<PDPint:isfx> %0\"\n   [(set_attr \"length\" \"2,4\")])\n \n \n@@ -1229,9 +1558,9 @@\n   \"\"\n   \"*\n {\n- if (get_attr_length (insn) == 2)\n+  if (get_attr_length (insn) == 2)\n     return \\\"br %l0\\\";\n- return \\\"jmp %l0\\\";\n+  return \\\"jmp %l0\\\";\n }\"\n   [(set (attr \"length\") (if_then_else (ior (lt (minus (match_dup 0)\n \t\t\t\t\t\t      (pc))\n@@ -1242,14 +1571,6 @@\n \t\t\t\t      (const_int 4)\n \t\t\t\t      (const_int 2)))])\n \n-(define_insn \"\"\n-  [(set (pc)\n-    (label_ref (match_operand 0 \"\" \"\")))\n-   (clobber (const_int 1))]\n-  \"\"\n-  \"jmp %l0\"\n-  [(set_attr \"length\" \"4\")])\n-\n (define_insn \"tablejump\"\n   [(set (pc) (match_operand:HI 0 \"general_operand\" \"r,R,Q\"))\n    (use (label_ref (match_operand 1 \"\" \"\")))]\n@@ -1260,22 +1581,20 @@\n   jmp %@%0\"\n   [(set_attr \"length\" \"2,2,4\")])\n \n-;; indirect jump - let's be conservative!\n-;; allow only register_operand, even though we could also \n-;; allow labels etc.\n-\n+;; indirect jump.  TODO: this needs a constraint that allows memory\n+;; references but not indirection, since we add a level of indirection\n+;; in the generated code.\n (define_insn \"indirect_jump\"\n-  [(set (pc) (match_operand:HI 0 \"register_operand\" \"r\"))]\n+  [(set (pc) (match_operand:HI 0 \"general_operand\" \"r\"))]\n   \"\"\n-  \"jmp (%0)\")\n+  \"jmp @%0\"\n+  [(set_attr \"length\" \"2\")])\n \n ;;- jump to subroutine\n \n (define_insn \"call\"\n   [(call (match_operand:HI 0 \"general_operand\" \"rR,Q\")\n-\t (match_operand:HI 1 \"general_operand\" \"g,g\"))\n-;;   (use (reg:HI 0)) what was that ???\n-  ]\n+\t (match_operand:HI 1 \"general_operand\" \"g,g\"))]\n   ;;- Don't use operand 1 for most machines.\n   \"\"\n   \"jsr pc, %0\"\n@@ -1285,14 +1604,38 @@\n (define_insn \"call_value\"\n   [(set (match_operand 0 \"\" \"\")\n \t(call (match_operand:HI 1 \"general_operand\" \"rR,Q\")\n-\t      (match_operand:HI 2 \"general_operand\" \"g,g\")))\n-;;   (use (reg:HI 0)) - what was that ????\n-  ]\n+\t      (match_operand:HI 2 \"general_operand\" \"g,g\")))]\n   ;;- Don't use operand 2 for most machines.\n   \"\"\n   \"jsr pc, %1\"\n   [(set_attr \"length\" \"2,4\")])\n \n+(define_expand \"untyped_call\"\n+  [(parallel [(call (match_operand 0 \"\" \"\")\n+\t\t    (const_int 0))\n+\t      (match_operand 1 \"\" \"\")\n+\t      (match_operand 2 \"\" \"\")])]\n+  \"\"\n+{\n+  int i;\n+\n+  emit_call_insn (gen_call (operands[0], const0_rtx));\n+\n+  for (i = 0; i < XVECLEN (operands[2], 0); i++)\n+    {\n+      rtx set = XVECEXP (operands[2], 0, i);\n+      emit_move_insn (SET_DEST (set), SET_SRC (set));\n+    }\n+\n+  /* The optimizer does not know that the call sets the function value\n+     registers we stored in the result block.  We avoid problems by\n+     claiming that all hard registers are used and clobbered at this\n+     point.  */\n+  emit_insn (gen_blockage ());\n+\n+  DONE;\n+})\n+\n ;;- nop instruction\n (define_insn \"nop\"\n   [(const_int 0)]\n@@ -1302,124 +1645,134 @@\n \n ;;- multiply \n \n-(define_insn \"muldf3\"\n+(define_insn_and_split \"muldf3\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=a,a\")\n \t(mult:DF (match_operand:DF 1 \"register_operand\" \"%0,0\")\n \t\t (match_operand:DF 2 \"float_operand\" \"fR,QF\")))]\n   \"TARGET_FPU\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(parallel [(set (match_dup 0) (mult:DF (match_dup 1) (match_dup 2)))\n+\t      (clobber (reg:CC FCC_REGNUM))])]\n+  \"\")\n+\n+(define_insn \"muldf3<fcc_ccnz>\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=a,a\")\n+\t(mult:DF (match_operand:DF 1 \"register_operand\" \"%0,0\")\n+\t      (match_operand:DF 2 \"float_operand\" \"fR,QF\")))\n+   (clobber (reg:CC FCC_REGNUM))]\n+  \"TARGET_FPU && reload_completed\"\n   \"{muld|mulf} %2, %0\"\n   [(set_attr \"length\" \"2,4\")])\n \n-;; 16 bit result multiply:\n-;; currently we multiply only into odd registers, so we don't use two \n-;; registers - but this is a bit inefficient at times. If we define \n-;; a register class for each register, then we can specify properly \n-;; which register need which scratch register ....\n+;; 16 bit result multiply.  This uses odd numbered registers.\n \n-(define_insn \"mulhi3\"\n+(define_insn_and_split \"mulhi3\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=d,d\") ; multiply regs\n \t(mult:HI (match_operand:HI 1 \"register_operand\" \"%0,0\")\n-\t\t (match_operand:HI 2 \"float_operand\" \"rR,Qi\")))]\n+\t\t (match_operand:HI 2 \"general_operand\" \"rR,Qi\")))]\n   \"TARGET_40_PLUS\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(parallel [(set (match_dup 0) (mult:HI (match_dup 1) (match_dup 2)))\n+\t      (clobber (reg:CC CC_REGNUM))])]\n+  \"\")\n+\n+(define_insn \"mulhi3<cc_cc>\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=d,d\")\n+\t(mult:HI (match_operand:HI 1 \"register_operand\" \"%0,0\")\n+\t      (match_operand:HI 2 \"general_operand\" \"rR,Qi\")))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"TARGET_40_PLUS && reload_completed\"\n   \"mul %2, %0\"\n   [(set_attr \"length\" \"2,4\")])\n \n-;; 32 bit result\n-(define_expand \"mulhisi3\"\n-  [(set (match_dup 3)\n-\t(match_operand:HI 1 \"nonimmediate_operand\" \"g,g\"))\n-   (set (match_operand:SI 0 \"register_operand\" \"=r,r\") ; even numbered!\n-\t(mult:SI (truncate:HI \n-                  (match_dup 0))\n-\t\t (match_operand:HI 2 \"general_operand\" \"rR,Qi\")))]\n+;; 32 bit result from 16 bit operands\n+(define_insn_and_split \"mulhisi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(mult:SI (sign_extend:SI (match_operand:HI 1 \"register_operand\" \"%0,0\"))\n+\t         (sign_extend:SI (match_operand:HI 2 \"general_operand\" \"rR,Qi\"))))]\n   \"TARGET_40_PLUS\"\n-  \"operands[3] = gen_lowpart(HImode, operands[1]);\")\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(parallel [(set (match_dup 0)\n+\t\t   (mult:SI (sign_extend:SI (match_dup 1))\n+\t\t\t (sign_extend:SI (match_dup 2))))\n+\t      (clobber (reg:CC CC_REGNUM))])]\n+  \"\")\n \n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\") ; even numbered!\n-\t(mult:SI (truncate:HI \n-                  (match_operand:SI 1 \"register_operand\" \"%0,0\"))\n-\t\t (match_operand:HI 2 \"general_operand\" \"rR,Qi\")))]\n-  \"TARGET_40_PLUS\"\n+(define_insn \"mulhisi3<cc_cc>\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(mult:SI (sign_extend:SI (match_operand:HI 1 \"register_operand\" \"%0,0\"))\n+\t      (sign_extend:SI (match_operand:HI 2 \"general_operand\" \"rR,Qi\"))))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"TARGET_40_PLUS && reload_completed\"\n   \"mul %2, %0\"\n   [(set_attr \"length\" \"2,4\")])\n \n-;(define_insn \"mulhisi3\"\n-;  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\") ; even numbered!\n-;\t(mult:SI (truncate:HI \n-;                  (match_operand:SI 1 \"register_operand\" \"%0,0\"))\n-;\t\t (match_operand:HI 2 \"general_operand\" \"rR,Qi\")))]\n-;  \"TARGET_40_PLUS\"\n-;  \"mul %2, %0\"\n-;  [(set_attr \"length\" \"2,4\")])\n-\n ;;- divide\n-(define_insn \"divdf3\"\n+(define_insn_and_split \"divdf3\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=a,a\")\n \t(div:DF (match_operand:DF 1 \"register_operand\" \"0,0\")\n \t\t(match_operand:DF 2 \"general_operand\" \"fR,QF\")))]\n   \"TARGET_FPU\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(parallel [(set (match_dup 0) (div:DF (match_dup 1) (match_dup 2)))\n+\t      (clobber (reg:CC FCC_REGNUM))])]\n+   \"\")\n+  \n+(define_insn \"divdf3<fcc_ccnz>\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=a,a\")\n+\t(div:DF (match_operand:DF 1 \"register_operand\" \"0,0\")\n+\t     (match_operand:DF 2 \"general_operand\" \"fR,QF\")))\n+   (clobber (reg:CC FCC_REGNUM))]\n+  \"TARGET_FPU && reload_completed\"\n   \"{divd|divf} %2, %0\"\n   [(set_attr \"length\" \"2,4\")])\n \n-\t \n-(define_expand \"divhi3\"\n-  [(set (subreg:HI (match_dup 1) 0)\n+(define_expand \"divmodhi4\"\n+  [(parallel\n+    [(set (subreg:HI (match_dup 1) 0)\n \t(div:HI (match_operand:SI 1 \"register_operand\" \"0\")\n \t\t(match_operand:HI 2 \"general_operand\" \"g\")))\n+     (set (subreg:HI (match_dup 1) 2)\n+\t(mod:HI (match_dup 1) (match_dup 2)))])\n    (set (match_operand:HI 0 \"register_operand\" \"=r\")\n-        (subreg:HI (match_dup 1) 0))]\n+        (subreg:HI (match_dup 1) 0))\n+   (set (match_operand:HI 3 \"register_operand\" \"=r\")\n+        (subreg:HI (match_dup 1) 2))]\n   \"TARGET_40_PLUS\"\n   \"\")\n \n-(define_insn \"\"\n-  [(set (subreg:HI (match_operand:SI 0 \"register_operand\" \"=r\") 0)\n-\t(div:HI (match_operand:SI 1 \"general_operand\" \"0\")\n-\t\t(match_operand:HI 2 \"general_operand\" \"g\")))]\n-  \"TARGET_40_PLUS\"\n-  \"div %2,%0\"\n-  [(set_attr \"length\" \"4\")])\n-\n-(define_expand \"modhi3\"\n-  [(set (subreg:HI (match_dup 1) 2)\n-\t(mod:HI (match_operand:SI 1 \"register_operand\" \"0\")\n-\t\t(match_operand:HI 2 \"general_operand\" \"g\")))\n-   (set (match_operand:HI 0 \"register_operand\" \"=r\")\n-        (subreg:HI (match_dup 1) 2))]\n+(define_insn_and_split \"*divmodhi4\"\n+  [(set (subreg:HI (match_operand:SI 0 \"register_operand\" \"=r,r\") 0)\n+\t(div:HI (match_operand:SI 1 \"register_operand\" \"0,0\")\n+\t     (match_operand:HI 2 \"general_operand\" \"rR,Qi\")))\n+   (set (subreg:HI (match_dup 1) 2)\n+\t(mod:HI (match_dup 1) (match_dup 2)))]\n   \"TARGET_40_PLUS\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(parallel [(set (subreg:HI (match_dup 0) 0)\n+\t\t   (div:HI (match_dup 1) (match_dup 2)))\n+\t      (set (subreg:HI (match_dup 1) 2)\n+\t\t   (mod:HI (match_dup 1) (match_dup 2)))\n+\t      (clobber (reg:CC CC_REGNUM))])]\n   \"\")\n \n-(define_insn \"\"\n-  [(set (subreg:HI (match_operand:SI 0 \"register_operand\" \"=r\") 2)\n-\t(mod:HI (match_operand:SI 1 \"general_operand\" \"0\")\n-\t\t(match_operand:HI 2 \"general_operand\" \"g\")))]\n+;; Note that there is no corresponding CC setter pattern.\n+;; The reason is that it won't be generated, because\n+;; compare-elim.c only does the transformation on input\n+;; insns that have a two-element PARALLEL, as opposed to\n+;; the three-element one we have here.     \n+(define_insn \"divmodhi4_nocc\"\n+  [(set (subreg:HI (match_operand:SI 0 \"register_operand\" \"=r,r\") 0)\n+\t(div:HI (match_operand:SI 1 \"register_operand\" \"0,0\")\n+\t        (match_operand:HI 2 \"general_operand\" \"rR,Qi\")))\n+   (set (subreg:HI (match_dup 1) 2)\n+\t(mod:HI (match_dup 1) (match_dup 2)))\n+   (clobber (reg:CC CC_REGNUM))]\n   \"TARGET_40_PLUS\"\n-  \"div %2,%0\"\n-  [(set_attr \"length\" \"4\")])\n-\n-;(define_expand \"divmodhi4\"\n-;  [(parallel [(set (subreg:HI (match_dup 1) 0)\n-;\t           (div:HI (match_operand:SI 1 \"register_operand\" \"0\")\n-;\t\t           (match_operand:HI 2 \"general_operand\" \"g\")))\n-;              (set (subreg:HI (match_dup 1) 2)\n-;\t           (mod:HI (match_dup 1)\n-;\t\t           (match_dup 2)))])\n-;   (set (match_operand:HI 3 \"register_operand\" \"=r\")\n-;        (subreg:HI (match_dup 1) 2))\n-;   (set (match_operand:HI 0 \"register_operand\" \"=r\")\n-;        (subreg:HI (match_dup 1) 0))]\n-;  \"TARGET_40_PLUS\"\n-;  \"\")\n-;\n-;(define_insn \"\"\n-;  [(set (subreg:HI (match_operand:SI 0 \"register_operand\" \"=r\") 0)\n-;\t           (div:HI (match_operand:SI 1 \"general_operand\" \"0\")\n-;\t\t           (match_operand:HI 2 \"general_operand\" \"g\")))\n-;   (set (subreg:HI (match_dup 0) 2)\n-;\t           (mod:HI (match_dup 1)\n-;\t\t           (match_dup 2)))]\n-;  \"TARGET_40_PLUS\"\n-;  \"div %2, %0\")\n-;\n-   \n-;; is rotate doing the right thing to be included here ????\n+   \"div %2,%0\"\n+  [(set_attr \"length\" \"2,4\")])"}, {"sha": "feebcc674fa4760a4da0270d497ac61b944ae659", "filename": "gcc/config/pdp11/pdp11.opt", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4324a144b4499725143baf1f69722f92814572e/gcc%2Fconfig%2Fpdp11%2Fpdp11.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4324a144b4499725143baf1f69722f92814572e/gcc%2Fconfig%2Fpdp11%2Fpdp11.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11.opt?ref=b4324a144b4499725143baf1f69722f92814572e", "patch": "@@ -34,22 +34,6 @@ mac0\n Target Report Mask(AC0)\n Return floating-point results in ac0 (fr0 in Unix assembler syntax).\n \n-mbcopy\n-Target RejectNegative Report Mask(BCOPY)\n-Do not use inline patterns for copying memory.\n-\n-mbcopy-builtin\n-Target RejectNegative Report InverseMask(BCOPY, BCOPY_BUILTIN)\n-Use inline patterns for copying memory.\n-\n-mbranch-cheap\n-Target RejectNegative Report InverseMask(BRANCH_EXPENSIVE, BRANCH_CHEAP)\n-Do not pretend that branches are expensive.\n-\n-mbranch-expensive\n-Target RejectNegative Report Mask(BRANCH_EXPENSIVE)\n-Pretend that branches are expensive.\n-\n mdec-asm\n Target RejectNegative Report InverseMask(UNIX_ASM)\n Use the DEC assembler syntax."}, {"sha": "eed711f7281b76af47256787f3bcad816ec19af6", "filename": "gcc/config/pdp11/predicates.md", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4324a144b4499725143baf1f69722f92814572e/gcc%2Fconfig%2Fpdp11%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4324a144b4499725143baf1f69722f92814572e/gcc%2Fconfig%2Fpdp11%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpredicates.md?ref=b4324a144b4499725143baf1f69722f92814572e", "patch": "@@ -23,17 +23,12 @@\n   (ior (match_operand 0 \"register_operand\")\n        (match_test \"op == CONST0_RTX (GET_MODE (op))\")))\n \n-;; Accept integer arguments in the range -4..-2 and 2..4, which are the\n+;; Accept integer arguments in the range 1..3, which are the\n ;; shift counts for which we unroll a shift.  This matches the rule for\n ;; the \"O\" constraint.\n (define_predicate \"expand_shift_operand\"\n-  (match_code \"const_int\")\n-{\n-  int sh;\n-\n-  sh = INTVAL (op);\n-  return (abs (sh) > 1 && abs (sh) <= 4);\n-})\n+  (and (match_code \"const_int\")\n+       (match_test \"(unsigned) INTVAL (op) < 4\")))\n \n ;; Accept anything general_operand accepts, except that registers must\n ;; be FPU registers.\n@@ -52,3 +47,7 @@\n \t\t (match_test \"REGNO_REG_CLASS (REGNO (op)) == LOAD_FPU_REGS\")\n \t\t (match_test \"REGNO_REG_CLASS (REGNO (op)) == NO_LOAD_FPU_REGS\"))\n \t\t(match_operand 0 \"nonimmediate_operand\")))\n+\n+;; Accept any comparison valid for CCNZmode\n+(define_predicate \"ccnz_operator\"\n+  (match_code \"eq,ne,ge,lt\"))"}, {"sha": "df4c55fdefbb2759a022025cd2f5410b45fba08f", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 11, "deletions": 37, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4324a144b4499725143baf1f69722f92814572e/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4324a144b4499725143baf1f69722f92814572e/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=b4324a144b4499725143baf1f69722f92814572e", "patch": "@@ -969,11 +969,9 @@ Objective-C and Objective-C++ Dialects}.\n \n @emph{PDP-11 Options}\n @gccoptlist{-mfpu  -msoft-float  -mac0  -mno-ac0  -m40  -m45  -m10 @gol\n--mbcopy  -mbcopy-builtin  -mint32  -mno-int16 @gol\n--mint16  -mno-int32  -mfloat32  -mno-float64 @gol\n--mfloat64  -mno-float32  -mabshi  -mno-abshi @gol\n--mbranch-expensive  -mbranch-cheap @gol\n--munix-asm  -mdec-asm}\n+-mint32  -mno-int16 -mint16  -mno-int32 @gol\n+-mfloat32  -mno-float64 -mfloat64  -mno-float32 @gol\n+-msplit -munix-asm  -mdec-asm}\n \n @emph{picoChip Options}\n @gccoptlist{-mae=@var{ae_type}  -mvliw-lookahead=@var{N} @gol\n@@ -22018,7 +22016,7 @@ These options are defined for the PDP-11:\n @item -mfpu\n @opindex mfpu\n Use hardware FPP floating point.  This is the default.  (FIS floating\n-point on the PDP-11/40 is not supported.)\n+point on the PDP-11/40 is not supported.)  Implies -m45.\n \n @item -msoft-float\n @opindex msoft-float\n@@ -22034,24 +22032,15 @@ Return floating-point results in memory.  This is the default.\n \n @item -m40\n @opindex m40\n-Generate code for a PDP-11/40.\n+Generate code for a PDP-11/40.  Implies -msoft-float -mno-split.\n \n @item -m45\n @opindex m45\n Generate code for a PDP-11/45.  This is the default.\n \n @item -m10\n @opindex m10\n-Generate code for a PDP-11/10.\n-\n-@item -mbcopy-builtin\n-@opindex mbcopy-builtin\n-Use inline @code{movmemhi} patterns for copying memory.  This is the\n-default.\n-\n-@item -mbcopy\n-@opindex mbcopy\n-Do not use inline @code{movmemhi} patterns for copying memory.\n+Generate code for a PDP-11/10.  Implies -msoft-float -mno-split.\n \n @item -mint16\n @itemx -mno-int32\n@@ -22077,32 +22066,17 @@ Use 64-bit @code{float}.  This is the default.\n @opindex mno-float64\n Use 32-bit @code{float}.\n \n-@item -mabshi\n-@opindex mabshi\n-Use @code{abshi2} pattern.  This is the default.\n-\n-@item -mno-abshi\n-@opindex mno-abshi\n-Do not use @code{abshi2} pattern.\n-\n-@item -mbranch-expensive\n-@opindex mbranch-expensive\n-Pretend that branches are expensive.  This is for experimenting with\n-code generation only.\n-\n-@item -mbranch-cheap\n-@opindex mbranch-cheap\n-Do not pretend that branches are expensive.  This is the default.\n+@item -msplit\n+@opindex msplit\n+Target has split instruction and data space.  Implies -m45.\n \n @item -munix-asm\n @opindex munix-asm\n-Use Unix assembler syntax.  This is the default when configured for\n-@samp{pdp11-*-bsd}.\n+Use Unix assembler syntax.\n \n @item -mdec-asm\n @opindex mdec-asm\n-Use DEC assembler syntax.  This is the default when configured for any\n-PDP-11 target other than @samp{pdp11-*-bsd}.\n+Use DEC assembler syntax.  This is the default.\n @end table\n \n @node picoChip Options"}, {"sha": "22919e4310c90763e5daa71778d68803c331f6dc", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4324a144b4499725143baf1f69722f92814572e/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4324a144b4499725143baf1f69722f92814572e/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=b4324a144b4499725143baf1f69722f92814572e", "patch": "@@ -2966,12 +2966,20 @@ memory with a single instruction.\n Odd numbered general registers (R1, R3, R5).  These are used for\n 16-bit multiply operations.\n \n+@item D\n+A memory reference that is encoded within the opcode, but not\n+auto-increment or auto-decrement.\n+\n @item f\n Any of the floating point registers (AC0 through AC5).\n \n @item G\n Floating point constant 0.\n \n+@item h\n+Floating point registers AC4 and AC5.  These cannot be loaded from/to\n+memory with a single instruction.\n+\n @item I\n An integer constant that fits in 16 bits.\n \n@@ -2992,7 +3000,7 @@ The integer constant @minus{}1.\n The integer constant 0.\n \n @item O\n-Integer constants @minus{}4 through @minus{}1 and 1 through 4; shifts by these\n+Integer constants 0 through 3; shifts by these\n amounts are handled as multiple single-bit shifts rather than a single\n variable-length shift.\n "}]}