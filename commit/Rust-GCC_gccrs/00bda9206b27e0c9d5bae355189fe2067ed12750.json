{"sha": "00bda9206b27e0c9d5bae355189fe2067ed12750", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDBiZGE5MjA2YjI3ZTBjOWQ1YmFlMzU1MTg5ZmUyMDY3ZWQxMjc1MA==", "commit": {"author": {"name": "Andreas Krebbel", "email": "krebbel1@de.ibm.com", "date": "2004-11-30T15:31:12Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2004-11-30T15:31:12Z"}, "message": "s390-modes.def: Added cc modes documentation.\n\n2004-11-30  Andreas Krebbel  <krebbel1@de.ibm.com>\n\n\t* config/s390/s390-modes.def: Added cc modes documentation.\n\t* config/s390/s390.c: (s390_tm_ccmode, s390_select_ccmode,\n\ts390_expand_addcc): Added cc mode comments.\n\t* config/s390/s390.md: Removed old cc mode documentation.\n\nFrom-SVN: r91528", "tree": {"sha": "75d3d68bc26017f3db22f4232fa43b375b5a8ad1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/75d3d68bc26017f3db22f4232fa43b375b5a8ad1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/00bda9206b27e0c9d5bae355189fe2067ed12750", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00bda9206b27e0c9d5bae355189fe2067ed12750", "html_url": "https://github.com/Rust-GCC/gccrs/commit/00bda9206b27e0c9d5bae355189fe2067ed12750", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00bda9206b27e0c9d5bae355189fe2067ed12750/comments", "author": null, "committer": null, "parents": [{"sha": "017e0eb94d164300f87adc5759eeffea42d02300", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/017e0eb94d164300f87adc5759eeffea42d02300", "html_url": "https://github.com/Rust-GCC/gccrs/commit/017e0eb94d164300f87adc5759eeffea42d02300"}], "stats": {"total": 184, "additions": 161, "deletions": 23}, "files": [{"sha": "c2e35f75462b8931e9418c382ed6141e71ba0af1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00bda9206b27e0c9d5bae355189fe2067ed12750/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00bda9206b27e0c9d5bae355189fe2067ed12750/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=00bda9206b27e0c9d5bae355189fe2067ed12750", "patch": "@@ -1,3 +1,10 @@\n+2004-11-30  Andreas Krebbel  <krebbel1@de.ibm.com>\n+\t\n+\t* config/s390/s390-modes.def: Added cc modes documentation.\n+\t* config/s390/s390.c: (s390_tm_ccmode, s390_select_ccmode,\n+\ts390_expand_addcc): Added cc mode comments.\n+\t* config/s390/s390.md: Removed old cc mode documentation.\n+\n 2004-11-30  Mark Dettinger  <dettinge@de.ibm.com>\n \n \t* config/s390/s390.c (struct processor_costs): New data type."}, {"sha": "1cb0f199032d2ee4473f0d11c48db0d0a094c8cc", "filename": "gcc/config/s390/s390-modes.def", "status": "modified", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00bda9206b27e0c9d5bae355189fe2067ed12750/gcc%2Fconfig%2Fs390%2Fs390-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00bda9206b27e0c9d5bae355189fe2067ed12750/gcc%2Fconfig%2Fs390%2Fs390-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390-modes.def?ref=00bda9206b27e0c9d5bae355189fe2067ed12750", "patch": "@@ -25,6 +25,127 @@ INT_MODE (OI, 32);\n \n /* Add any extra modes needed to represent the condition code.  */\n \n+/*\n+\n+Condition Codes\n+\n+Check for zero\n+\n+CCZ:  EQ          NE           NE          NE\n+\n+Unsigned compares\n+\n+CCU:  EQ          LTU          GTU         NE         (CLG/R, CL/R/Y, CLM/Y, CLI/Y)\n+CCUR: EQ          GTU          LTU         NE         (CLGF/R)\n+\n+Signed compares\n+\n+CCS:  EQ          LT           GT          UNORDERED  (LTGFR, LTGR, LTR, ICM/Y,\n+                                                       LTDBR, LTDR, LTEBR, LTER,\n+                                                       CG/R, C/R/Y, CGHI, CHI, \n+                                                       CDB/R, CD/R, CEB/R, CE/R, \n+                                                       ADB/R, AEB/R, SDB/R, SEB/R,\n+                                                       SRAG, SRA, SRDA)\n+CCSR: EQ          GT           LT          UNORDERED  (CGF/R, CH/Y)\n+\n+Condition codes resulting from add with overflow\n+\n+CCA:  EQ          LT           GT          Overflow\n+CCAP: EQ          LT           GT          LT         (AGHI, AHI)\n+CCAN: EQ          LT           GT          GT         (AGHI, AHI)\n+\n+Condition codes of unsigned adds and subs\n+\n+CCL:  EQ          NE           EQ          NE         (ALGF/R, ALG/R, AL/R/Y,\n+                                                       ALCG/R, ALC/R, \n+                                                       SLGF/R, SLG/R, SL/R/Y,\n+                                                       SLBG/R, SLB/R)\n+CCL1: GEU         GEU          LTU         LTU        (ALG/R, AL/R/Y)\n+CCL2: GTU         GTU          LEU         LEU        (SLG/R, SL/R/Y)\n+CCL3: EQ          LTU          EQ          GTU        (SLG/R, SL/R/Y)\n+\n+Test under mask checks\n+\n+CCT:  EQ          NE           NE          NE         (ICM/Y, TML, CG/R, CGHI, \n+                                                       C/R/Y, CHI, NG/R, N/R/Y,\n+                                                       OG/R, O/R/Y, XG/R, X/R/Y)\n+CCT1: NE          EQ           NE          NE         (TMH, TML)\n+CCT2: NE          NE           EQ          NE         (TMH, TML)\n+CCT3: NE          NE           NE          EQ         (TMH, TML)\n+\n+CCA and CCT modes are request only modes. These modes are never returned by \n+s390_select_cc_mode. They are only intended to match other modes.\n+\n+Requested mode            -> Destination CC register mode\n+\n+CCS, CCU, CCT, CCSR, CCUR -> CCZ\n+CCA                       -> CCAP, CCAN\n+\n+\n+*** Comments ***\n+\n+CCAP, CCAN\n+\n+The CC obtained from add instruction usually can't be used for comparisons \n+because its coupling with overflow flag. In case of an overflow the\n+less than/greater than data are lost. Nevertheless a comparison can be done\n+whenever immediate values are involved because they are known at compile time.\n+If you know whether the used constant is positive or negative you can predict \n+the sign of the result even in case of an overflow.\n+\n+\n+CCT, CCT1, CCT2, CCT3\n+\n+If bits of an integer masked with an AND instruction are checked, the test under\n+mask instructions turn out to be very handy for a set of special cases.\n+The simple cases are checks whether all masked bits are zero or ones:\n+\n+  int a; \n+  if ((a & (16 + 128)) == 0)          -> CCT/CCZ\n+  if ((a & (16 + 128)) == 16 + 128)   -> CCT3\n+\n+Using two extra modes makes it possible to do complete checks on two bits of an\n+integer (This is possible on register operands only. TM does not provide the\n+information necessary for CCT1 and CCT2 modes.):\n+\n+  int a;\n+  if ((a & (16 + 128)) == 16)         -> CCT1\n+  if ((a & (16 + 128)) == 128)        -> CCT2\n+\n+\n+CCSR, CCUR\n+\n+There are several instructions comparing 32 bit with 64 bit unsigned/signed\n+values. Such instructions can be considered to have a builtin zero/sign_extend.\n+The problem is that in the RTL (to be canonical) the zero/sign extended operand \n+has to be the first one but the machine instructions like it the other way \n+around. The following both modes can be considered as CCS and CCU modes with \n+exchanged operands.\n+\n+\n+CCL1, CCL2\n+\n+These modes represent the result of overflow checks. \n+\n+if (a + b < a) -> CCL1 state of the carry bit   (CC2 | CC3)\n+if (a - b > a) -> CCL2 state of the borrow bit  (CC0 | CC1)\n+\n+They are used when multi word numbers are computed dealing one SImode part after\n+another or whenever manual overflow checks like the examples above are\n+compiled.\n+\n+\n+CCL3\n+\n+A logical subtract instruction sets the borrow bit in case of an overflow.\n+The resulting condition code of those instructions is represented by the\n+CCL3 mode. Together with the CCU mode this mode is used for jumpless \n+implementations of several if-constructs - see s390_expand_addcc for more\n+details.\n+\n+*/   \n+\n+\n CC_MODE (CCZ);\n CC_MODE (CCA);\n CC_MODE (CCAP);"}, {"sha": "1526f9059d47214c5eaa68a2fd9ebaf39f0144f5", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 33, "deletions": 4, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00bda9206b27e0c9d5bae355189fe2067ed12750/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00bda9206b27e0c9d5bae355189fe2067ed12750/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=00bda9206b27e0c9d5bae355189fe2067ed12750", "patch": "@@ -472,15 +472,20 @@ s390_tm_ccmode (rtx op1, rtx op2, int mixed)\n   if (GET_CODE (op1) != CONST_INT || GET_CODE (op2) != CONST_INT)\n     return VOIDmode;\n \n-  /* Selected bits all zero: CC0.  */\n+  /* Selected bits all zero: CC0.\n+     e.g.: int a; if ((a & (16 + 128)) == 0) */\n   if (INTVAL (op2) == 0)\n     return CCTmode;\n \n-  /* Selected bits all one: CC3.  */\n+  /* Selected bits all one: CC3. \n+     e.g.: int a; if ((a & (16 + 128)) == 16 + 128) */\n   if (INTVAL (op2) == INTVAL (op1))\n     return CCT3mode;\n \n-  /* Exactly two bits selected, mixed zeroes and ones: CC1 or CC2.  */\n+  /* Exactly two bits selected, mixed zeroes and ones: CC1 or CC2. e.g.:\n+     int a;\n+     if ((a & (16 + 128)) == 16)         -> CCT1\n+     if ((a & (16 + 128)) == 128)        -> CCT2  */\n   if (mixed)\n     {\n       bit1 = exact_log2 (INTVAL (op2));\n@@ -542,9 +547,19 @@ s390_select_ccmode (enum rtx_code code, rtx op0, rtx op1)\n       case LT:\n       case GE:\n       case GT:\n+\t/* The only overflow condition of NEG and ABS happens when\n+\t   -INT_MAX is used as parameter, which stays negative. So\n+\t   we have an overflow from a positive value to a negative. \n+\t   Using CCAP mode the resulting cc can be used for comparisons.  */\n \tif ((GET_CODE (op0) == NEG || GET_CODE (op0) == ABS)\n \t    && GET_MODE_CLASS (GET_MODE (op0)) == MODE_INT)\n \t  return CCAPmode;\n+\n+ \t/* If constants are involved in an add instruction it is possible to use\n+ \t   the resulting cc for comparisons with zero. Knowing the sign of the\n+\t   constant the overflow behaviour gets predictable. e.g.:\n+ \t     int a, b; if ((b = a + c) > 0)  \n+ \t   with c as a constant value: c < 0 -> CCAN and c >= 0 -> CCAP  */\n \tif (GET_CODE (op0) == PLUS && GET_CODE (XEXP (op0, 1)) == CONST_INT\n \t    && CONST_OK_FOR_CONSTRAINT_P (INTVAL (XEXP (op0, 1)), 'K', \"K\"))\n \t  {\n@@ -3772,7 +3787,21 @@ s390_expand_cmpmem (rtx target, rtx op0, rtx op1, rtx len)\n /* Expand conditional increment or decrement using alc/slb instructions.\n    Should generate code setting DST to either SRC or SRC + INCREMENT,\n    depending on the result of the comparison CMP_OP0 CMP_CODE CMP_OP1.\n-   Returns true if successful, false otherwise.  */\n+   Returns true if successful, false otherwise.\n+\n+   That makes it possible to implement some if-constructs without jumps e.g.:\n+   (borrow = CC0 | CC1 and carry = CC2 | CC3)\n+   unsigned int a, b, c;\n+   if (a < b)  c++; -> CCU  b > a  -> CC2;    c += carry;\n+   if (a < b)  c--; -> CCL3 a - b  -> borrow; c -= borrow;\n+   if (a <= b) c++; -> CCL3 b - a  -> borrow; c += carry;\n+   if (a <= b) c--; -> CCU  a <= b -> borrow; c -= borrow;\n+\n+   Checks for EQ and NE with a nonzero value need an additional xor e.g.:\n+   if (a == b) c++; -> CCL3 a ^= b; 0 - a  -> borrow;    c += carry;\n+   if (a == b) c--; -> CCU  a ^= b; a <= 0 -> CC0 | CC1; c -= borrow;\n+   if (a != b) c++; -> CCU  a ^= b; a > 0  -> CC2;       c += carry;\n+   if (a != b) c--; -> CCL3 a ^= b; 0 - a  -> borrow;    c -= borrow; */\n \n bool\n s390_expand_addcc (enum rtx_code cmp_code, rtx cmp_op0, rtx cmp_op1,"}, {"sha": "7672e2b81b0271f9756fe85c31bc2820996412a6", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00bda9206b27e0c9d5bae355189fe2067ed12750/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00bda9206b27e0c9d5bae355189fe2067ed12750/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=00bda9206b27e0c9d5bae355189fe2067ed12750", "patch": "@@ -228,25 +228,6 @@\n ;; Pipeline description for z990. \n (include \"2084.md\")\n \n-\n-;;\n-;;  Condition Codes\n-;;\n-;\n-;   CCL:  Zero     Nonzero   Zero      Nonzero      (AL, ALR, SL, SLR, N, NC, NI, NR, O, OC, OI, OR, X, XC, XI, XR)\n-;   CCA:  Zero     <Zero     >Zero     Overflow     (A, AR, AH, AHI, S, SR, SH, SHI, LTR, LCR, LNR, LPR, SLA, SLDA, SLA, SRDA)\n-;   CCU:  Equal    ULess     UGreater  --           (CL, CLR, CLI, CLM)\n-;   CCS:  Equal    SLess     SGreater  --           (C, CR, CH, CHI, ICM)\n-;   CCT:  Zero     Mixed     Mixed     Ones         (TM, TMH, TML)\n-\n-;   CCZ  -> CCL / CCZ1\n-;   CCZ1 -> CCA/CCU/CCS/CCT\n-;   CCS  -> CCA\n-\n-;   String:    CLC, CLCL, CLCLE, CLST, CUSE, MVCL, MVCLE, MVPG, MVST, SRST\n-;   Clobber:   CKSM, CFC, CS, CDS, CUUTF, CUTFU, PLO, SPM, STCK, STCKE, TS, TRT, TRE, UPT\n-\n-\n ;;\n ;;- Compare instructions.\n ;;"}]}