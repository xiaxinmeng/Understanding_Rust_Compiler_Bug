{"sha": "245471c67f3ad27a85dce999933cec1ff298be02", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjQ1NDcxYzY3ZjNhZDI3YTg1ZGNlOTk5OTMzY2VjMWZmMjk4YmUwMg==", "commit": {"author": {"name": "Fritz Reese", "email": "fritzoreese@gmail.com", "date": "2018-07-05T15:39:27Z"}, "committer": {"name": "Fritz Reese", "email": "foreese@gcc.gnu.org", "date": "2018-07-05T15:39:27Z"}, "message": "re PR fortran/83183 (Out of memory with option -finit-derived)\n\n2018-07-05  Fritz Reese  <fritzoreese@gmail.com>\n\n    gcc/fortran/ChangeLog:\n\n\tPR fortran/83183\n\tPR fortran/86325\n\t* expr.c (class_allocatable, class_pointer, comp_allocatable,\n\tcomp_pointer): New helpers.\n\t(component_initializer): Generate EXPR_NULL for allocatable or pointer\n\tcomponents. Do not generate initializers for components within BT_CLASS.\n\tDo not assign to comp->initializer.\n\t(gfc_generate_initializer): Use new helpers; move code to generate\n\tEXPR_NULL for class allocatable components into component_initializer().\n\n    gcc/testsuite/ChangeLog:\n\n\tPR fortran/83183\n\tPR fortran/86325\n\t* gfortran.dg/init_flag_18.f90: New testcase.\n\t* gfortran.dg/init_flag_19.f03: New testcase.\n\nFrom-SVN: r262442", "tree": {"sha": "96efcde3808b455ef5b17183af71299b892cac60", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/96efcde3808b455ef5b17183af71299b892cac60"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/245471c67f3ad27a85dce999933cec1ff298be02", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/245471c67f3ad27a85dce999933cec1ff298be02", "html_url": "https://github.com/Rust-GCC/gccrs/commit/245471c67f3ad27a85dce999933cec1ff298be02", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/245471c67f3ad27a85dce999933cec1ff298be02/comments", "author": {"login": "fritzr", "id": 2230564, "node_id": "MDQ6VXNlcjIyMzA1NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2230564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fritzr", "html_url": "https://github.com/fritzr", "followers_url": "https://api.github.com/users/fritzr/followers", "following_url": "https://api.github.com/users/fritzr/following{/other_user}", "gists_url": "https://api.github.com/users/fritzr/gists{/gist_id}", "starred_url": "https://api.github.com/users/fritzr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fritzr/subscriptions", "organizations_url": "https://api.github.com/users/fritzr/orgs", "repos_url": "https://api.github.com/users/fritzr/repos", "events_url": "https://api.github.com/users/fritzr/events{/privacy}", "received_events_url": "https://api.github.com/users/fritzr/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5a1b56cc9843425557fc9ccbcf99aabfc7028123", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a1b56cc9843425557fc9ccbcf99aabfc7028123", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a1b56cc9843425557fc9ccbcf99aabfc7028123"}], "stats": {"total": 147, "additions": 122, "deletions": 25}, "files": [{"sha": "f810379aea5d1e6457beb1bcef8c804dc3120b1f", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/245471c67f3ad27a85dce999933cec1ff298be02/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/245471c67f3ad27a85dce999933cec1ff298be02/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=245471c67f3ad27a85dce999933cec1ff298be02", "patch": "@@ -1,3 +1,15 @@\n+2018-07-05  Fritz Reese  <fritzoreese@gmail.com>\n+\n+\tPR fortran/83183\n+\tPR fortran/86325\n+\t* expr.c (class_allocatable, class_pointer, comp_allocatable,\n+\tcomp_pointer): New helpers.\n+\t(component_initializer): Generate EXPR_NULL for allocatable or pointer\n+\tcomponents. Do not generate initializers for components within BT_CLASS.\n+\tDo not assign to comp->initializer.\n+\t(gfc_generate_initializer): Use new helpers; move code to generate\n+\tEXPR_NULL for class allocatable components into component_initializer().\n+\n 2018-07-04  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR fortran/82009"}, {"sha": "c5bf822cd24ddb3a2ba53df678f00c90514ed780", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 48, "deletions": 25, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/245471c67f3ad27a85dce999933cec1ff298be02/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/245471c67f3ad27a85dce999933cec1ff298be02/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=245471c67f3ad27a85dce999933cec1ff298be02", "patch": "@@ -4452,25 +4452,60 @@ get_union_initializer (gfc_symbol *union_type, gfc_component **map_p)\n   return init;\n }\n \n+static bool\n+class_allocatable (gfc_component *comp)\n+{\n+  return comp->ts.type == BT_CLASS && CLASS_DATA (comp)\n+    && CLASS_DATA (comp)->attr.allocatable;\n+}\n+\n+static bool\n+class_pointer (gfc_component *comp)\n+{\n+  return comp->ts.type == BT_CLASS && CLASS_DATA (comp)\n+    && CLASS_DATA (comp)->attr.pointer;\n+}\n+\n+static bool\n+comp_allocatable (gfc_component *comp)\n+{\n+  return comp->attr.allocatable || class_allocatable (comp);\n+}\n+\n+static bool\n+comp_pointer (gfc_component *comp)\n+{\n+  return comp->attr.pointer\n+    || comp->attr.pointer\n+    || comp->attr.proc_pointer\n+    || comp->attr.class_pointer\n+    || class_pointer (comp);\n+}\n+\n /* Fetch or generate an initializer for the given component.\n    Only generate an initializer if generate is true.  */\n \n static gfc_expr *\n-component_initializer (gfc_typespec *ts, gfc_component *c, bool generate)\n+component_initializer (gfc_component *c, bool generate)\n {\n   gfc_expr *init = NULL;\n \n-  /* See if we can find the initializer immediately.\n-     Some components should never get initializers.  */\n-  if (c->initializer || !generate\n-      || (ts->type == BT_CLASS && !c->attr.allocatable)\n-      || c->attr.pointer\n-      || c->attr.class_pointer\n-      || c->attr.proc_pointer)\n+  /* Allocatable components always get EXPR_NULL.\n+     Pointer components are only initialized when generating, and only if they\n+     do not already have an initializer.  */\n+  if (comp_allocatable (c) || (generate && comp_pointer (c) && !c->initializer))\n+    {\n+      init = gfc_get_null_expr (&c->loc);\n+      init->ts = c->ts;\n+      return init;\n+    }\n+\n+  /* See if we can find the initializer immediately.  */\n+  if (c->initializer || !generate)\n     return c->initializer;\n \n   /* Recursively handle derived type components.  */\n-  if (c->ts.type == BT_DERIVED || c->ts.type == BT_CLASS)\n+  else if (c->ts.type == BT_DERIVED || c->ts.type == BT_CLASS)\n     init = gfc_generate_initializer (&c->ts, true);\n \n   else if (c->ts.type == BT_UNION && c->ts.u.derived->components)\n@@ -4518,7 +4553,7 @@ component_initializer (gfc_typespec *ts, gfc_component *c, bool generate)\n       gfc_apply_init (&c->ts, &c->attr, init);\n     }\n \n-  return (c->initializer = init);\n+  return init;\n }\n \n \n@@ -4579,9 +4614,7 @@ gfc_generate_initializer (gfc_typespec *ts, bool generate)\n   if (!generate)\n     {\n       for (; comp; comp = comp->next)\n-        if (comp->initializer || comp->attr.allocatable\n-            || (comp->ts.type == BT_CLASS && CLASS_DATA (comp)\n-                && CLASS_DATA (comp)->attr.allocatable))\n+\tif (comp->initializer || comp_allocatable (comp))\n           break;\n     }\n \n@@ -4597,7 +4630,7 @@ gfc_generate_initializer (gfc_typespec *ts, bool generate)\n       gfc_constructor *ctor = gfc_constructor_get();\n \n       /* Fetch or generate an initializer for the component.  */\n-      tmp = component_initializer (ts, comp, generate);\n+      tmp = component_initializer (comp, generate);\n       if (tmp)\n \t{\n \t  /* Save the component ref for STRUCTUREs and UNIONs.  */\n@@ -4607,8 +4640,7 @@ gfc_generate_initializer (gfc_typespec *ts, bool generate)\n \n           /* If the initializer was not generated, we need a copy.  */\n           ctor->expr = comp->initializer ? gfc_copy_expr (tmp) : tmp;\n-\t  if ((comp->ts.type != tmp->ts.type\n-\t       || comp->ts.kind != tmp->ts.kind)\n+\t  if ((comp->ts.type != tmp->ts.type || comp->ts.kind != tmp->ts.kind)\n \t      && !comp->attr.pointer && !comp->attr.proc_pointer)\n \t    {\n \t      bool val;\n@@ -4618,15 +4650,6 @@ gfc_generate_initializer (gfc_typespec *ts, bool generate)\n \t    }\n \t}\n \n-      if (comp->attr.allocatable\n-\t  || (comp->ts.type == BT_CLASS && CLASS_DATA (comp)->attr.allocatable))\n-\t{\n-\t  ctor->expr = gfc_get_expr ();\n-\t  ctor->expr->expr_type = EXPR_NULL;\n-\t  ctor->expr->where = init->where;\n-\t  ctor->expr->ts = comp->ts;\n-\t}\n-\n       gfc_constructor_append (&init->value.constructor, ctor);\n     }\n "}, {"sha": "a812b5082411fb61799900211356431bcbbec347", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/245471c67f3ad27a85dce999933cec1ff298be02/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/245471c67f3ad27a85dce999933cec1ff298be02/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=245471c67f3ad27a85dce999933cec1ff298be02", "patch": "@@ -1,3 +1,10 @@\n+2018-07-05  Fritz Reese  <fritzoreese@gmail.com>\n+\n+\tPR fortran/83183\n+\tPR fortran/86325\n+\t* gfortran.dg/init_flag_18.f90: New testcase.\n+\t* gfortran.dg/init_flag_19.f03: New testcase.\n+\n 2018-07-05  Carl Love  <cel@us.ibm.com>\n \t* gcc.target/altivec-1-runnable.c: New test file.\n \t* gcc.target/altivec-2-runnable.c: New test file."}, {"sha": "9ab00a9afce35a2d453fa7133aa2de7ab0fb1775", "filename": "gcc/testsuite/gfortran.dg/init_flag_18.f90", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/245471c67f3ad27a85dce999933cec1ff298be02/gcc%2Ftestsuite%2Fgfortran.dg%2Finit_flag_18.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/245471c67f3ad27a85dce999933cec1ff298be02/gcc%2Ftestsuite%2Fgfortran.dg%2Finit_flag_18.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Finit_flag_18.f90?ref=245471c67f3ad27a85dce999933cec1ff298be02", "patch": "@@ -0,0 +1,19 @@\n+! { dg-do compile }\n+! { dg-options \"-finit-derived\" }\n+!\n+! PR fortran/83183\n+!\n+! Test a regression where -finit-derived recursed infinitely generating\n+! initializers for allocatable components of the same derived type.\n+!\n+\n+program pr83183\n+  type :: linked_list\n+     type(linked_list), allocatable :: link\n+     integer :: value\n+  end type\n+  type(linked_list) :: test\n+  allocate(test % link)\n+  print *, test%value\n+  print *, test%link%value\n+end program"}, {"sha": "bbcee8aa8b4308e9e8158f8eca0a5f96971967a6", "filename": "gcc/testsuite/gfortran.dg/init_flag_19.f03", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/245471c67f3ad27a85dce999933cec1ff298be02/gcc%2Ftestsuite%2Fgfortran.dg%2Finit_flag_19.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/245471c67f3ad27a85dce999933cec1ff298be02/gcc%2Ftestsuite%2Fgfortran.dg%2Finit_flag_19.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Finit_flag_19.f03?ref=245471c67f3ad27a85dce999933cec1ff298be02", "patch": "@@ -0,0 +1,36 @@\n+! { dg-do compile }\n+! { dg-options \"-finit-derived -finit-local-zero -fdump-tree-original\" }\n+!\n+! Test initializers for BT_CLASS components/variables with -finit-derived.\n+!\n+\n+implicit none\n+\n+type :: ty1\n+  integer :: ival\n+  real    :: rval\n+end type\n+\n+type :: ty2\n+  type(ty1)               :: bt\n+  type(ty1), allocatable  :: bt_alloc\n+  type(ty1), pointer      :: bt_ptr\n+  class(ty1), allocatable :: class_alloc\n+  class(ty1), pointer     :: class_ptr\n+end type\n+\n+type(ty2) basic\n+class(ty1), allocatable :: calloc\n+\n+print *, basic%bt%ival\n+print *, calloc%ival\n+\n+end\n+\n+! { dg-final { scan-tree-dump-times \"\\.ival *= *0\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"\\.rval *= *0\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"\\.bt_ptr *= *0\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"\\.bt_alloc *= *0\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"\\.class_alloc(?: *= *\\{)?\\._data *= *0\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"\\.class_ptr(?: *= *\\{)?\\._data *= *0\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"calloc(?: *= *\\{)?\\._data *= *0\" 1 \"original\" } }"}]}