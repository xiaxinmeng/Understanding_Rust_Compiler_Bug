{"sha": "19e223db83b86b7262db77c9ea67e7d6d32a0d73", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTllMjIzZGI4M2I4NmI3MjYyZGI3N2M5ZWE2N2U3ZDZkMzJhMGQ3Mw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2000-09-23T17:09:39Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-09-23T17:09:39Z"}, "message": "Make-lang.in (JAVA_SRCS): Include java-tree.h.\n\n\t* Make-lang.in (JAVA_SRCS): Include java-tree.h.\n\t* Makefile.in (parse.o): Depend on ggc.h.\n\t(class.o): Likewise.\n\t(constants.o): Likewise.\n\t(decl.o): Likewise.\n\t(expr.o): Likewise.\n\t(jcf-parse.o): Likewise.\n\t(jcf-write.o): Likewise.\n\t(mangle.o): Likewise.\n\t* class.c: Include ggc.h.\n\t(build_static_field_ref): Register GC roots.\n\t(layout_class): Likewise.\n\t(init_class_processing): Likewise.\n\t* constants.c: Include ggc.h.\n\t(current_constant_pool_data_ref): Remove.\n\t(tag_nodes): Move it to ...\n\t(get_tag_node): ... here.  Register GC roots.\n\t* decl.c: Include ggc.h.  Remove many global tree definitions.\n\t(throw_node): Define.\n\t(java_global_trees): Likewise.\n\t(predef_filenames): Make the size a constant.\n\t(init_decl_processing): Adjust accordingly.\n\t(init_decl_processing): Call init_jcf_parse.  Register GC roots.\n\t* expr.c: Include ggc.h.\n\t(init_expr_processing): Register GC roots.\n\t(build_invokeinterface): Likewise.\n\t* java-tree.h: Replace extern tree declarations with macros.\n\t(java_global_trees): New variable.\n\t(java_tree_index): New enumeration.\n\t(init_jcf_parse): Declare.\n\t* jcf-parse.c: Include ggc.h.\n\t(current_class): Remove declaration.\n\t(main_class): Likewise.\n\t(all_class_list): Likewise.\n\t(predefined_filename_p): Adjust for constant size of\n\tpredef_filenames.\n\t(init_jcf_parse): New function.\n\t* jcf-write.c: Include ggc.h.\n\t(generate_classfile): Register GC roots.\n\t(append_synthetic_attribute): Likewise.\n\t(append_innerclass_attribute_entry): Likewise.\n\t* lang.c: Include ggc.h.\n\t(lang_print_error): Register GC roots.\n\t* parse.h (struct parser_ctxt): Rename fields to avoid conflicts\n\twith macros.\n\t* parse.y: Include ggc.h.\n\t(wfl_operator): Remove.\n\t(goal): Register GC roots.\n\t(java_pop_parser_context): Adjust for new field names.\n\t(java_parser_context_save_global): Likewse.\n\t(java_parser_context_restore_global): Likewise.\n\t(java_parser_context_suspend): Likewise.\n\t(java_parser_context_resume): Likewise.\n\t(verify_constructor_circularity): Register GC roots.\n\t(lookup_cl): Likewise.\n\t(java_reorder_fields): Likewise.\n\t(build_current_this): Likewise.\n\t(class_in_current_package): Likewise.\n\t(argument_types_convertible): Likewise.\n\t(patch_cast): Rename wfl_op parameter to avoid macro conflicts.\n\nFrom-SVN: r36581", "tree": {"sha": "95f1fa9690fd278ef5602931fc5a32ddfca8d2bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/95f1fa9690fd278ef5602931fc5a32ddfca8d2bd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/19e223db83b86b7262db77c9ea67e7d6d32a0d73", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19e223db83b86b7262db77c9ea67e7d6d32a0d73", "html_url": "https://github.com/Rust-GCC/gccrs/commit/19e223db83b86b7262db77c9ea67e7d6d32a0d73", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19e223db83b86b7262db77c9ea67e7d6d32a0d73/comments", "author": null, "committer": null, "parents": [{"sha": "a3b434a23543ba4fe8ac546382475e145b8be83f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3b434a23543ba4fe8ac546382475e145b8be83f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3b434a23543ba4fe8ac546382475e145b8be83f"}], "stats": {"total": 967, "additions": 653, "deletions": 314}, "files": [{"sha": "83c564892baa96c6d2b75c6add40f854831b464c", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19e223db83b86b7262db77c9ea67e7d6d32a0d73/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19e223db83b86b7262db77c9ea67e7d6d32a0d73/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=19e223db83b86b7262db77c9ea67e7d6d32a0d73", "patch": "@@ -1,3 +1,66 @@\n+2000-09-23  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* Make-lang.in (JAVA_SRCS): Include java-tree.h.\n+\t* Makefile.in (parse.o): Depend on ggc.h.\n+\t(class.o): Likewise.\n+\t(constants.o): Likewise.\n+\t(decl.o): Likewise.\n+\t(expr.o): Likewise.\n+\t(jcf-parse.o): Likewise.\n+\t(jcf-write.o): Likewise.\n+\t(mangle.o): Likewise.\n+\t* class.c: Include ggc.h.\n+\t(build_static_field_ref): Register GC roots.\n+\t(layout_class): Likewise.\n+\t(init_class_processing): Likewise.\n+\t* constants.c: Include ggc.h.\n+\t(current_constant_pool_data_ref): Remove.\n+\t(tag_nodes): Move it to ...\n+\t(get_tag_node): ... here.  Register GC roots.\n+\t* decl.c: Include ggc.h.  Remove many global tree definitions.\n+\t(throw_node): Define.\n+\t(java_global_trees): Likewise.\n+\t(predef_filenames): Make the size a constant.\n+\t(init_decl_processing): Adjust accordingly.\n+\t(init_decl_processing): Call init_jcf_parse.  Register GC roots.\n+\t* expr.c: Include ggc.h.\n+\t(init_expr_processing): Register GC roots.\n+\t(build_invokeinterface): Likewise.\n+\t* java-tree.h: Replace extern tree declarations with macros.\n+\t(java_global_trees): New variable.\n+\t(java_tree_index): New enumeration.\n+\t(init_jcf_parse): Declare.\n+\t* jcf-parse.c: Include ggc.h.\n+\t(current_class): Remove declaration.\n+\t(main_class): Likewise.\n+\t(all_class_list): Likewise.\n+\t(predefined_filename_p): Adjust for constant size of\n+\tpredef_filenames.\n+\t(init_jcf_parse): New function.\n+\t* jcf-write.c: Include ggc.h.\n+\t(generate_classfile): Register GC roots.\n+\t(append_synthetic_attribute): Likewise.\n+\t(append_innerclass_attribute_entry): Likewise.\n+\t* lang.c: Include ggc.h.\n+\t(lang_print_error): Register GC roots.\n+\t* parse.h (struct parser_ctxt): Rename fields to avoid conflicts\n+\twith macros.\n+\t* parse.y: Include ggc.h.\n+\t(wfl_operator): Remove.\n+\t(goal): Register GC roots.\n+\t(java_pop_parser_context): Adjust for new field names.\n+\t(java_parser_context_save_global): Likewse.\n+\t(java_parser_context_restore_global): Likewise.\n+\t(java_parser_context_suspend): Likewise.\n+\t(java_parser_context_resume): Likewise.\n+\t(verify_constructor_circularity): Register GC roots.\n+\t(lookup_cl): Likewise.\n+\t(java_reorder_fields): Likewise.\n+\t(build_current_this): Likewise.\n+\t(class_in_current_package): Likewise.\n+\t(argument_types_convertible): Likewise.\n+\t(patch_cast): Rename wfl_op parameter to avoid macro conflicts.\n+\t\n 2000-09-14  Tom Tromey  <tromey@cygnus.com>\n \n \t* lex.h: Use HAVE_ICONV_H, not HAVE_ICONV."}, {"sha": "1a17a98a8f319c6d8dd7272ce56471998cdf3820", "filename": "gcc/java/Make-lang.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19e223db83b86b7262db77c9ea67e7d6d32a0d73/gcc%2Fjava%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19e223db83b86b7262db77c9ea67e7d6d32a0d73/gcc%2Fjava%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FMake-lang.in?ref=19e223db83b86b7262db77c9ea67e7d6d32a0d73", "patch": "@@ -75,7 +75,8 @@ JAVA_SRCS = $(srcdir)/java/parse.y $(srcdir)/java/class.c \\\n   $(srcdir)/java/jcf-parse.c $(srcdir)/java/mangle.c \\\n   $(srcdir)/java/jcf-write.c $(srcdir)/java/buffer.c \\\n   $(srcdir)/java/check-init.c $(srcdir)/java/lex.c $(srcdir)/java/boehm.c \\\n-  $(srcdir)/java/jcf-depend.c  $(srcdir)/java/jcf-path.c\n+  $(srcdir)/java/jcf-depend.c  $(srcdir)/java/jcf-path.c \\\n+  $(srcdir)/java/java-tree.h\n \n jvspec.o: $(srcdir)/java/jvspec.c system.h $(GCC_H)\n \t$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) \\"}, {"sha": "794ec667d1cb29b99e44116925b81d380752c977", "filename": "gcc/java/Makefile.in", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19e223db83b86b7262db77c9ea67e7d6d32a0d73/gcc%2Fjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19e223db83b86b7262db77c9ea67e7d6d32a0d73/gcc%2Fjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FMakefile.in?ref=19e223db83b86b7262db77c9ea67e7d6d32a0d73", "patch": "@@ -273,7 +273,7 @@ force:\n \n parse.o : $(PARSE_C) jcf-reader.c $(CONFIG_H) $(srcdir)/../system.h \\\n   $(srcdir)/../function.h $(JAVA_TREE_H) $(srcdir)/lex.c $(PARSE_H) \\\n-  $(srcdir)/lex.h\n+  $(srcdir)/lex.h $(srcdir)/../ggc.h\n jcf-dump.o : $(CONFIG_H) $(srcdir)/../system.h $(JAVA_TREE_H) jcf-dump.c \\\n   jcf-reader.c jcf.h javaop.h javaop.def $(srcdir)/../version.h\n gjavah.o : $(CONFIG_H) $(srcdir)/../system.h $(JAVA_TREE_H) gjavah.c \\\n@@ -286,33 +286,34 @@ check-init.o : check-init.c $(CONFIG_H) $(srcdir)/../gansidecl.h \\\n   $(JAVA_TREE_H) $(srcdir)/../system.h $(srcdir)/../toplev.h\n class.o : class.c $(CONFIG_H) $(JAVA_TREE_H) $(RTL_H) jcf.h $(PARSE_H) \\\n   $(srcdir)/../gansidecl.h $(srcdir)/../toplev.h $(srcdir)/../system.h \\\n-  $(srcdir)/../output.h\n+  $(srcdir)/../output.h $(srcdir)/../ggc.h\n constants.o : constants.c $(CONFIG_H) $(JAVA_TREE_H) jcf.h \\\n-  $(srcdir)/../toplev.h $(srcdir)/../system.h\n+  $(srcdir)/../toplev.h $(srcdir)/../system.h $(srcdir)/../ggc.h\n decl.o : decl.c $(CONFIG_H) $(JAVA_TREE_H) jcf.h \\\n   $(srcdir)/../toplev.h $(srcdir)/../system.h $(srcdir)/../function.h \\\n-  $(srcdir)/../defaults.h\n+  $(srcdir)/../defaults.h $(srcdir)/../gcc.h\n except.o : except.c $(CONFIG_H) $(JAVA_TREE_H) jcf.h $(srcdir)/../real.h \\\n   $(RTL_H) javaop.h java-opcodes.h $(srcdir)/../except.h java-except.h \\\n   $(srcdir)/../eh-common.h $(srcdir)/../toplev.h $(srcdir)/../system.h \\\n   $(srcdir)/../function.h\n expr.o : expr.c $(CONFIG_H) $(JAVA_TREE_H) jcf.h $(srcdir)/../real.h \\\n   $(RTL_H) $(EXPR_H) javaop.h java-opcodes.h $(srcdir)/../except.h \\\n   java-except.h java-except.h parse.h $(srcdir)/../toplev.h \\\n-  $(srcdir)/../system.h\n+  $(srcdir)/../system.h $(srcdir)/../ggc.h\n jcf-depend.o : jcf-depend.c $(CONFIG_H) $(srcdir)/../system.h jcf.h\n jcf-io.o : jcf-io.c $(CONFIG_H) $(srcdir)/../system.h $(JAVA_TREE_H)\n jcf-parse.o : jcf-parse.c $(CONFIG_H) $(JAVA_TREE_H) $(srcdir)/../flags.h \\\n   $(srcdir)/../input.h java-except.h $(srcdir)/../system.h \\\n-  $(srcdir)/../toplev.h $(PARSE_H)\n+  $(srcdir)/../toplev.h $(PARSE_H) $(srcdir)/../ggc.h\n jcf-write.o : jcf-write.c $(CONFIG_H) $(JAVA_TREE_H) jcf.h $(RTL_H) \\\n-  java-opcodes.h parse.h buffer.h $(srcdir)/../system.h $(srcdir)/../toplev.h\n+  java-opcodes.h parse.h buffer.h $(srcdir)/../system.h \\\n+  $(srcdir)/../toplev.h $(srcdir)/../ggc.h\n jv-scan.o : jv-scan.c $(CONFIG_H) $(srcdir)/../system.h $(srcdir)/../version.h\n jvgenmain.o : jvgenmain.c $(CONFIG_H) $(srcdir)/../system.h\n lang.o : lang.c $(CONFIG_H) $(JAVA_TREE_H) jcf.h $(srcdir)/../input.h \\\n   $(srcdir)/../toplev.h $(srcdir)/../system.h $(RTL_H) $(EXPR_H)\n mangle.o : mangle.c $(CONFIG_H) jcf.h $(JAVA_TREE_H) $(srcdir)/../system.h \\\n-  $(srcdir)/../toplev.h\n+  $(srcdir)/../toplev.h $(srcdir)/../ggc.h\n parse-scan.o : $(CONFIG_H) $(srcdir)/../system.h $(srcdir)/../toplev.h \\\n   $(srcdir)/lex.c $(PARSE_H) $(srcdir)/lex.h\n typeck.o : typeck.c $(CONFIG_H) $(JAVA_TREE_H) jcf.h convert.h \\"}, {"sha": "b69bfc1a93325010638a72710b5519f480064bc0", "filename": "gcc/java/class.c", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19e223db83b86b7262db77c9ea67e7d6d32a0d73/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19e223db83b86b7262db77c9ea67e7d6d32a0d73/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=19e223db83b86b7262db77c9ea67e7d6d32a0d73", "patch": "@@ -35,6 +35,7 @@ The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n #include \"toplev.h\"\n #include \"output.h\"\n #include \"parse.h\"\n+#include \"ggc.h\"\n \n static tree mangle_class_field PARAMS ((tree class));\n static tree make_method_value PARAMS ((tree));\n@@ -1011,9 +1012,15 @@ build_static_field_ref (fdecl)\n       int field_index = 0;\n       ref = build1 (INDIRECT_REF, class_type_node, ref);\n       if (fields_ident == NULL_TREE)\n-\tfields_ident = get_identifier (\"fields\");\n+\t{\n+\t  fields_ident = get_identifier (\"fields\");\n+\t  ggc_add_tree_root (&fields_ident, 1);\n+\t}\n       if (info_ident == NULL_TREE)\n-\tinfo_ident = get_identifier (\"info\");\n+\t{\n+\t  info_ident = get_identifier (\"info\");\n+\t  ggc_add_tree_root (&info_ident, 1);\n+\t}\n       ref = build (COMPONENT_REF, field_ptr_type_node, ref,\n \t\t   lookup_field (&class_type_node, fields_ident));\n \n@@ -1779,9 +1786,17 @@ layout_class (this_class)\n      tree this_class;\n {\n   static tree list = NULL_TREE;\n+  static int initialized_p;\n   tree super_class = CLASSTYPE_SUPER (this_class);\n   tree field;\n   \n+  /* Register LIST with the garbage collector.  */\n+  if (!initialized_p)\n+    {\n+      ggc_add_tree_root (&list, 1);\n+      initialized_p = 1;\n+    }\n+\n   list = tree_cons (this_class, NULL_TREE, list);\n   if (CLASS_BEING_LAIDOUT (this_class))\n     {\n@@ -2044,6 +2059,9 @@ static tree registered_class = NULL_TREE;\n void\n register_class ()\n {\n+  /* END does not need to be registered with the garbage collector\n+     because it always points into the list given by REGISTERED_CLASS,\n+     and that variable is registered with the collector.  */\n   static tree end;\n   tree node    = TREE_OPERAND (build_class_ref (current_class), 0);\n   tree current = copy_node (node);\n@@ -2102,4 +2120,5 @@ void\n init_class_processing ()\n {\n   registerClass_libfunc = gen_rtx (SYMBOL_REF, Pmode, \"_Jv_RegisterClass\");\n+  ggc_add_tree_root (&registered_class, 1);\n }"}, {"sha": "c1dd6719caaac443ec6e1b4faba50c501af8c934", "filename": "gcc/java/constants.c", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19e223db83b86b7262db77c9ea67e7d6d32a0d73/gcc%2Fjava%2Fconstants.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19e223db83b86b7262db77c9ea67e7d6d32a0d73/gcc%2Fjava%2Fconstants.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fconstants.c?ref=19e223db83b86b7262db77c9ea67e7d6d32a0d73", "patch": "@@ -27,6 +27,7 @@ The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n #include \"tree.h\"\n #include \"java-tree.h\"\n #include \"toplev.h\"\n+#include \"ggc.h\"\n \n extern struct obstack permanent_obstack;\n \n@@ -318,17 +319,21 @@ write_constant_pool (cpool, buffer, length)\n \n CPool *outgoing_cpool;\n \n-/* If non-NULL, an ADDR_EXPR referencing a VAR_DECL containing\n-   the constant data array for the current class. */\n-tree current_constant_pool_data_ref;\n-\n-/* A Cache for build_int_2 (CONSTANT_XXX, 0). */\n-static tree tag_nodes[13];\n-\n static tree\n get_tag_node (tag)\n      int tag;\n {\n+  /* A Cache for build_int_2 (CONSTANT_XXX, 0). */\n+  static tree tag_nodes[13];\n+  static int initialized_p;\n+\n+  /* Register the TAG_NODES with the garbage collector.  */\n+  if (!initialized_p)\n+    {\n+      ggc_add_tree_root (tag_nodes, 13);\n+      initialized_p = 1;\n+    }\n+\n   if (tag_nodes[tag] == NULL_TREE)\n     {\n       push_obstacks (&permanent_obstack, &permanent_obstack);"}, {"sha": "e1c630db4f5dfdda12aea370e943bb4995e5afbd", "filename": "gcc/java/decl.c", "status": "modified", "additions": 17, "deletions": 124, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19e223db83b86b7262db77c9ea67e7d6d32a0d73/gcc%2Fjava%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19e223db83b86b7262db77c9ea67e7d6d32a0d73/gcc%2Fjava%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fdecl.c?ref=19e223db83b86b7262db77c9ea67e7d6d32a0d73", "patch": "@@ -37,6 +37,7 @@ The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n #include \"except.h\"\n #include \"defaults.h\"\n #include \"java-except.h\"\n+#include \"ggc.h\"\n \n #if defined (DEBUG_JAVA_BINDING_LEVELS)\n extern void indent PROTO((void));\n@@ -69,6 +70,8 @@ tree decl_map;\n \n tree pending_local_decls = NULL_TREE;\n \n+tree throw_node [2];\n+\n /* Push a local variable or stack slot into the decl_map,\n    and assign it an rtl. */\n \n@@ -283,122 +286,10 @@ static int keep_next_level_flag;\n    if it has subblocks.  */\n \n static int keep_next_if_subblocks;\n+\n+tree java_global_trees[JTI_MAX];\n   \n-tree object_type_node;\n-tree unqualified_object_id_node;\n-tree object_ptr_type_node;\n-tree string_type_node;\n-tree string_ptr_type_node;\n-tree throwable_type_node;\n-tree runtime_exception_type_node;\n-tree error_exception_type_node;\n-tree rawdata_ptr_type_node;\n-tree *predef_filenames;\n-int  predef_filenames_size;\n-\n-tree boolean_type_node;\n-\n-tree return_address_type_node;\n-\n-tree byte_type_node;\n-tree short_type_node;\n-tree int_type_node;\n-tree long_type_node;\n-\n-tree promoted_byte_type_node;\n-tree promoted_short_type_node;\n-tree promoted_char_type_node;\n-tree promoted_boolean_type_node;\n-\n-tree unsigned_byte_type_node;\n-tree unsigned_short_type_node;\n-tree unsigned_int_type_node;\n-tree unsigned_long_type_node;\n-\n-/* The type for struct methodtable. */\n-tree methodtable_type;\n-tree methodtable_ptr_type;\n-\n-tree utf8const_type;\n-tree utf8const_ptr_type;\n-tree class_type_node;\n-tree class_ptr_type;\n-tree field_type_node;\n-tree field_ptr_type_node;\n-tree field_info_union_node;\n-tree jexception_type;\n-tree jexception_ptr_type;\n-tree lineNumberEntry_type;\n-tree lineNumbers_type;\n-tree constants_type_node;\n-tree dtable_type;\n-tree dtable_ptr_type;\n-tree method_type_node;\n-tree method_ptr_type_node;\n-tree nativecode_ptr_array_type_node;\n-tree one_elt_array_domain_type;\n-tree access_flags_type_node;\n-tree class_dtable_decl;\n-\n-/* Expressions that are constants with value zero, of types\n-   `long', `float' and `double'.  */\n-tree long_zero_node;\n-tree float_zero_node;\n-tree double_zero_node;\n-\n-tree empty_stmt_node;\n-\n-/* Nodes for boolean constants TRUE and FALSE. */\n-tree boolean_true_node;\n-tree boolean_false_node;\n-\n-tree TYPE_identifier_node;\n-tree init_identifier_node;\n-tree clinit_identifier_node;\n-tree finit_identifier_node;\n-tree finit_leg_identifier_node;\n-tree void_signature_node;\n-tree length_identifier_node;\n-tree this_identifier_node;\n-tree super_identifier_node;\n-tree continue_identifier_node;\n-tree access0_identifier_node;\t/* 1.1 */\n-tree end_params_node;\n-\n-/* References to internal libjava functions we use. */\n-tree alloc_object_node;\n-tree soft_instanceof_node;\n-tree soft_checkcast_node;\n-tree soft_initclass_node;\n-tree soft_newarray_node;\n-tree soft_anewarray_node;\n-tree soft_multianewarray_node;\n-tree soft_badarrayindex_node;\n-tree soft_nullpointer_node;\n-tree throw_node [2];\n-tree soft_checkarraystore_node;\n-tree soft_monitorenter_node;\n-tree soft_monitorexit_node;\n-tree soft_lookupinterfacemethod_node;\n-tree soft_lookupjnimethod_node;\n-tree soft_getjnienvnewframe_node;\n-tree soft_jnipopsystemframe_node;\n-tree soft_fmod_node;\n-tree soft_exceptioninfo_call_node;\n-tree soft_idiv_node;\n-tree soft_irem_node;\n-tree soft_ldiv_node;\n-tree soft_lrem_node;\n-\n-/* Declarations for vtables for primitive arrays.  */\n-tree boolean_array_vtable;\n-tree byte_array_vtable;\n-tree char_array_vtable;\n-tree short_array_vtable;\n-tree int_array_vtable;\n-tree long_array_vtable;\n-tree float_array_vtable;\n-tree double_array_vtable;\n+tree predef_filenames[PREDEF_FILENAMES_SIZE];\n \n /* Build (and pushdecl) a \"promoted type\" for all standard\n    types shorter than int.  */\n@@ -426,11 +317,6 @@ push_promoted_type (name, actual_type)\n   return type;\n }\n \n-/* Nodes for integer constants.  */\n-tree integer_two_node;\n-tree integer_four_node;\n-tree integer_negative_one_node;\n-\n /* Return a definition for a builtin function named NAME and whose data type\n    is TYPE.  TYPE should be a function type with argument types.\n    FUNCTION_CODE tells later passes how to compile calls to this function.\n@@ -623,10 +509,8 @@ init_decl_processing ()\n   rawdata_ptr_type_node\n     = promote_type (lookup_class (get_identifier (\"gnu.gcj.RawData\")));\n \n-  /* This section has to be updated as items are added to the previous\n-     section. */\n-  predef_filenames_size = 7;\n-  predef_filenames = (tree *)xmalloc (predef_filenames_size * sizeof (tree));\n+  /* If you add to this section, don't forget to increase\n+     PREDEF_FILENAMES_SIZE.  */\n   predef_filenames [0] = get_identifier (\"java/lang/Class.java\");\n   predef_filenames [1] = get_identifier (\"java/lang/Error.java\");\n   predef_filenames [2] = get_identifier (\"java/lang/Object.java\");\n@@ -958,6 +842,15 @@ init_decl_processing ()\n \t\t\t0, NOT_BUILT_IN, NULL_PTR);\n \n   init_class_processing ();\n+  init_jcf_parse ();\n+\n+  /* Register nodes with the garbage collector.  */\n+  ggc_add_tree_root (java_global_trees, \n+\t\t     sizeof (java_global_trees) / sizeof (tree));\n+  ggc_add_tree_root (throw_node,\n+\t\t     sizeof (throw_node) / sizeof (tree));\n+  ggc_add_tree_root (predef_filenames,\n+\t\t     sizeof (predef_filenames) / sizeof (tree));\n }\n \n "}, {"sha": "54a3332c51b41c0046c3e24e4ff6aa1db5c4e4e4", "filename": "gcc/java/expr.c", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19e223db83b86b7262db77c9ea67e7d6d32a0d73/gcc%2Fjava%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19e223db83b86b7262db77c9ea67e7d6d32a0d73/gcc%2Fjava%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexpr.c?ref=19e223db83b86b7262db77c9ea67e7d6d32a0d73", "patch": "@@ -40,6 +40,7 @@ The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n #include \"toplev.h\"\n #include \"except.h\"\n #include \"defaults.h\"\n+#include \"ggc.h\"\n \n static void flush_quick_stack PARAMS ((void));\n static void push_value PARAMS ((tree));\n@@ -83,6 +84,10 @@ static tree case_identity PARAMS ((tree, tree));\n static tree operand_type[59];\n extern struct obstack permanent_obstack;\n \n+static tree methods_ident = NULL_TREE;\n+static tree ncode_ident = NULL_TREE;\n+tree dtable_ident = NULL_TREE;\n+\n /* Set to non-zero value in order to emit class initilization code\n    before static field references.  */\n int always_initialize_class_p;\n@@ -95,6 +100,9 @@ init_expr_processing()\n   operand_type[23] = operand_type[56] = float_type_node;\n   operand_type[24] = operand_type[57] = double_type_node;\n   operand_type[25] = operand_type[58] = ptr_type_node;\n+  ggc_add_tree_root (operand_type, 59);\n+  ggc_add_tree_root (&methods_ident, 1);\n+  ggc_add_tree_root (&ncode_ident, 1);\n }\n \n /* We store the stack state in two places:\n@@ -1652,10 +1660,6 @@ build_class_init (clas, expr)\n   return init;\n }\n \n-static tree methods_ident = NULL_TREE;\n-static tree ncode_ident = NULL_TREE;\n-tree dtable_ident = NULL_TREE;\n-\n tree\n build_known_method_ref (method, method_type, self_type, method_signature, arg_list)\n      tree method, method_type ATTRIBUTE_UNUSED, self_type,\n@@ -1771,8 +1775,11 @@ build_invokeinterface (dtable, method)\n      abstract nor static.  */\n \t    \n   if (class_ident == NULL_TREE)\n-    class_ident = get_identifier (\"class\");\n-  \n+    {\n+      class_ident = get_identifier (\"class\");\n+      ggc_add_tree_root (&class_ident, 1);\n+    }\n+\n   dtable = build1 (INDIRECT_REF, dtable_type, dtable);\n   dtable = build (COMPONENT_REF, class_ptr_type, dtable,\n \t\t  lookup_field (&dtable_type, class_ident));"}, {"sha": "0b75387d8422536d0d1703f4bd42a5456b60f6a6", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 381, "deletions": 119, "changes": 500, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19e223db83b86b7262db77c9ea67e7d6d32a0d73/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19e223db83b86b7262db77c9ea67e7d6d32a0d73/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=19e223db83b86b7262db77c9ea67e7d6d32a0d73", "patch": "@@ -121,13 +121,16 @@ struct JCF;\n extern int compiling_from_source;\n \n /* The class defined by the actual (main) file we are compiling. */\n-extern tree main_class;\n+#define main_class \\\n+  java_global_trees[JTI_MAIN_CLASS]\n \n /* The class we are currently processing. */\n-extern tree current_class;\n+#define current_class \\\n+  java_global_trees[JTI_CURRENT_CLASS]\n \n /* List of all class DECLs seen so far.  */\n-extern tree all_class_list;\n+#define all_class_list \\\n+  java_global_trees[JTI_ALL_CLASS_LIST]\n \n /* Nonzero if we should make is_compiled_class always return 1 for\n    appropriate classes that we're referencing.  */\n@@ -205,139 +208,397 @@ typedef struct CPool constant_pool;\n #define COMPONENT_REF_SIGNATURE(CPOOL, IDX) \\\n   NAME_AND_TYPE_SIGNATURE (CPOOL, COMPONENT_REF_NAME_AND_TYPE(CPOOL, IDX))\n \n+enum java_tree_index\n+{\n+  JTI_PROMOTED_BYTE_TYPE_NODE,\n+  JTI_PROMOTED_SHORT_TYPE_NODE,\n+  JTI_PROMOTED_CHAR_TYPE_NODE,\n+  JTI_PROMOTED_BOOLEAN_TYPE_NODE,\n+\n+  JTI_BYTE_TYPE_NODE,\n+  JTI_SHORT_TYPE_NODE,\n+  JTI_INT_TYPE_NODE,\n+  JTI_LONG_TYPE_NODE,\n+  \n+  JTI_UNSIGNED_BYTE_TYPE_NODE,\n+  JTI_UNSIGNED_SHORT_TYPE_NODE,\n+  JTI_UNSIGNED_INT_TYPE_NODE,\n+  JTI_UNSIGNED_LONG_TYPE_NODE,\n+  \n+  JTI_BOOLEAN_TYPE_NODE,\n+\n+  JTI_OBJECT_TYPE_NODE,\n+  JTI_UNQUALIFIED_OBJECT_ID_NODE,\n+  JTI_OBJECT_PTR_TYPE_NODE,\n+  JTI_STRING_TYPE_NODE,\n+  JTI_STRING_PTR_TYPE_NODE,\n+  JTI_THROWABLE_TYPE_NODE,\n+  JTI_RUNTIME_EXCEPTION_TYPE_NODE,\n+  JTI_ERROR_EXCEPTION_TYPE_NODE,\n+  JTI_RAWDATA_PTR_TYPE_NODE,\n+\n+  JTI_BYTE_ARRAY_TYPE_NODE,\n+  JTI_SHORT_ARRAY_TYPE_NODE,\n+  JTI_INT_ARRAY_TYPE_NODE,\n+  JTI_LONG_ARRAY_TYPE_NODE,\n+  JTI_BOOLEAN_ARRAY_TYPE_NODE,\n+  JTI_CHAR_ARRAY_TYPE_NODE,\n+  JTI_DOUBLE_ARRAY_TYPE_NODE,\n+  JTI_FLOAT_ARRAY_TYPE_NODE,\n+  JTI_ARRAY_ARRAY_TYPE_NODE,\n+  JTI_OBJECT_ARRAY_TYPE_NODE,\n+  JTI_STRING_ARRAY_TYPE_NODE,\n+  JTI_BOOLEAN_ARRAY_VTABLE,\n+  JTI_BYTE_ARRAY_VTABLE,\n+  JTI_CHAR_ARRAY_VTABLE,\n+  JTI_SHORT_ARRAY_VTABLE,\n+  JTI_INT_ARRAY_VTABLE,\n+  JTI_LONG_ARRAY_VTABLE,\n+  JTI_FLOAT_ARRAY_VTABLE,\n+  JTI_DOUBLE_ARRAY_VTABLE,\n+  JTI_TYPE_IDENTIFIER_NODE,      \n+  JTI_INIT_IDENTIFIER_NODE,      \n+  JTI_CLINIT_IDENTIFIER_NODE,      \n+  JTI_FINIT_IDENTIFIER_NODE,      \n+  JTI_FINIT_LEG_IDENTIFIER_NODE,  \n+  JTI_VOID_SIGNATURE_NODE,       \n+  JTI_LENGTH_IDENTIFIER_NODE,  \n+  JTI_THIS_IDENTIFIER_NODE,  \n+  JTI_SUPER_IDENTIFIER_NODE,  \n+  JTI_CONTINUE_IDENTIFIER_NODE,  \n+  JTI_ACCESS0_IDENTIFIER_NODE, \n+  JTI_ONE_ELT_ARRAY_DOMAIN_TYPE,\n+\n+  JTI_RETURN_ADDRESS_TYPE_NODE,\n+\n+  JTI_BOOLEAN_TRUE_NODE, \n+  JTI_BOOLEAN_FALSE_NODE,\n+\n+  JTI_LONG_ZERO_NODE,\n+  JTI_FLOAT_ZERO_NODE,\n+  JTI_DOUBLE_ZERO_NODE,\n+  JTI_INTEGER_NEGATIVE_ONE_NODE,\n+  JTI_INTEGER_TWO_NODE,\n+  JTI_INTEGER_FOUR_NODE,\n+  JTI_EMPTY_STMT_NODE,\n+\n+  JTI_METHODTABLE_TYPE,\n+  JTI_METHODTABLE_PTR_TYPE,\n+\n+  JTI_UTF8CONST_TYPE,\n+  JTI_UTF8CONST_PTR_TYPE,\n+\n+  JTI_CLASS_TYPE_NODE,\n+  JTI_CLASS_PTR_TYPE,\n+  JTI_FIELD_TYPE_NODE,\n+  JTI_CONSTANTS_TYPE_NODE,\n+  JTI_DTABLE_TYPE, \n+  JTI_DTABLE_PTR_TYPE,\n+  JTI_FIELD_PTR_TYPE_NODE,\n+  JTI_FIELD_INFO_UNION_NODE,\n+  JTI_EXCEPTION_TYPE,\n+  JTI_EXCEPTION_PTR_TYPE,\n+  JTI_LINENUMBERENTRY_TYPE,\n+  JTI_LINENUMBERS_TYPE,\n+  JTI_METHOD_TYPE_NODE,\n+  JTI_METHOD_PTR_TYPE_NODE,\n+\n+  JTI_END_PARAMS_NODE,\n+\n+  JTI_ALLOC_OBJECT_NODE,\n+  JTI_SOFT_INSTANCEOF_NODE,\n+  JTI_SOFT_CHECKCAST_NODE,\n+  JTI_SOFT_INITCLASS_NODE,\n+  JTI_SOFT_NEWARRAY_NODE,\n+  JTI_SOFT_ANEWARRAY_NODE,\n+  JTI_SOFT_MULTIANEWARRAY_NODE,\n+  JTI_SOFT_BADARRAYINDEX_NODE,\n+  JTI_SOFT_NULLPOINTER_NODE,\n+  JTI_SOFT_CHECKARRAYSTORE_NODE,\n+  JTI_SOFT_MONITORENTER_NODE,\n+  JTI_SOFT_MONITOREXIT_NODE,\n+  JTI_SOFT_LOOKUPINTERFACEMETHOD_NODE,\n+  JTI_SOFT_LOOKUPJNIMETHOD_NODE,\n+  JTI_SOFT_GETJNIENVNEWFRAME_NODE,\n+  JTI_SOFT_JNIPOPSYSTEMFRAME_NODE,\n+  JTI_SOFT_FMOD_NODE,\n+  JTI_SOFT_EXCEPTIONINFO_CALL_NODE,\n+  JTI_SOFT_IDIV_NODE,\n+  JTI_SOFT_IREM_NODE,\n+  JTI_SOFT_LDIV_NODE,\n+  JTI_SOFT_LREM_NODE,\n+\n+  JTI_ACCESS_FLAGS_TYPE_NODE,\n+\n+  JTI_CLASS_DTABLE_DECL,\n+\n+  JTI_NATIVECODE_PTR_ARRAY_TYPE_NODE,\n+\n+  JTI_WFL_OPERATOR,\n+  JTI_CURRENT_CONSTANT_POOL_DATA_REF,\n+\n+  JTI_MAIN_CLASS,\n+  JTI_CURRENT_CLASS,\n+  JTI_ALL_CLASS_LIST,\n+\n+  JTI_MAX\n+};\n+\n+extern tree java_global_trees[JTI_MAX];\n+\n /* \"Promoted types\" that are used for primitive types smaller\n    than int.  We could use int_type_node, but then we would lose\n    type information (such as needed for debugging). */\n-extern tree promoted_byte_type_node;\n-extern tree promoted_short_type_node;\n-extern tree promoted_char_type_node;\n-extern tree promoted_boolean_type_node;\n-\n-extern tree byte_type_node;\n-extern tree short_type_node;\n-extern tree int_type_node;\n-extern tree long_type_node;\n-\n-extern tree unsigned_byte_type_node;\n-extern tree unsigned_short_type_node;\n-extern tree unsigned_int_type_node;\n-extern tree unsigned_long_type_node;\n-\n-extern tree boolean_type_node;\n-\n-extern tree object_type_node;\n-extern tree unqualified_object_id_node;\n-extern tree object_ptr_type_node;\n-extern tree string_type_node;\n-extern tree string_ptr_type_node;\n-extern tree throwable_type_node;\n-extern tree runtime_exception_type_node;\n-extern tree error_exception_type_node;\n-extern tree rawdata_ptr_type_node;\n-\n-extern tree *predef_filenames;\n-extern int predef_filenames_size;\n-\n-extern tree byte_array_type_node;\n-extern tree short_array_type_node;\n-extern tree int_array_type_node;\n-extern tree long_array_type_node;\n-extern tree boolean_array_type_node;\n-extern tree char_array_type_node;\n-extern tree double_array_type_node;\n-extern tree float_array_type_node;\n-extern tree array_array_type_node;\n-extern tree object_array_type_node;\n-extern tree string_array_type_node;\n-extern tree boolean_array_vtable;\n-extern tree byte_array_vtable;\n-extern tree char_array_vtable;\n-extern tree short_array_vtable;\n-extern tree int_array_vtable;\n-extern tree long_array_vtable;\n-extern tree float_array_vtable;\n-extern tree double_array_vtable;\n-extern tree TYPE_identifier_node;      /* \"TYPE\" */\n-extern tree init_identifier_node;      /* \"<init>\" */\n-extern tree clinit_identifier_node;      /* \"<clinit>\" */\n-extern tree finit_identifier_node;      /* \"finit$\" */\n-extern tree finit_leg_identifier_node;  /* \"$finit$\" */\n-extern tree void_signature_node;       /* \"()V\" */\n-extern tree length_identifier_node;  /* \"length\" */\n-extern tree this_identifier_node;  /* \"this\" */\n-extern tree super_identifier_node;  /* \"super\" */\n-extern tree continue_identifier_node;  /* \"continue\" */\n-extern tree access0_identifier_node; /* \"access$0\" */\n-extern tree one_elt_array_domain_type;\n+#define promoted_byte_type_node \\\n+  java_global_trees[JTI_PROMOTED_BYTE_TYPE_NODE]\n+#define promoted_short_type_node \\\n+  java_global_trees[JTI_PROMOTED_SHORT_TYPE_NODE]\n+#define promoted_char_type_node \\\n+  java_global_trees[JTI_PROMOTED_CHAR_TYPE_NODE]\n+#define promoted_boolean_type_node \\\n+  java_global_trees[JTI_PROMOTED_BOOLEAN_TYPE_NODE]\n+\n+#define byte_type_node \\\n+  java_global_trees[JTI_BYTE_TYPE_NODE]\n+#define short_type_node \\\n+  java_global_trees[JTI_SHORT_TYPE_NODE]\n+#define int_type_node \\\n+  java_global_trees[JTI_INT_TYPE_NODE]\n+#define long_type_node \\\n+  java_global_trees[JTI_LONG_TYPE_NODE]\n+\n+#define unsigned_byte_type_node \\\n+  java_global_trees[JTI_UNSIGNED_BYTE_TYPE_NODE]\n+#define unsigned_short_type_node \\\n+  java_global_trees[JTI_UNSIGNED_SHORT_TYPE_NODE]\n+#define unsigned_int_type_node \\\n+  java_global_trees[JTI_UNSIGNED_INT_TYPE_NODE]\n+#define unsigned_long_type_node \\\n+  java_global_trees[JTI_UNSIGNED_LONG_TYPE_NODE]\n+\n+#define boolean_type_node \\\n+  java_global_trees[JTI_BOOLEAN_TYPE_NODE]\n+\n+#define object_type_node \\\n+  java_global_trees[JTI_OBJECT_TYPE_NODE]\n+#define unqualified_object_id_node \\\n+  java_global_trees[JTI_UNQUALIFIED_OBJECT_ID_NODE]\n+#define object_ptr_type_node \\\n+  java_global_trees[JTI_OBJECT_PTR_TYPE_NODE]\n+#define string_type_node \\\n+  java_global_trees[JTI_STRING_TYPE_NODE]\n+#define string_ptr_type_node \\\n+  java_global_trees[JTI_STRING_PTR_TYPE_NODE]\n+#define throwable_type_node \\\n+  java_global_trees[JTI_THROWABLE_TYPE_NODE]\n+#define runtime_exception_type_node \\\n+  java_global_trees[JTI_RUNTIME_EXCEPTION_TYPE_NODE]\n+#define error_exception_type_node \\\n+  java_global_trees[JTI_ERROR_EXCEPTION_TYPE_NODE]\n+#define rawdata_ptr_type_node \\\n+  java_global_trees[JTI_RAWDATA_PTR_TYPE_NODE]\n+\n+#define byte_array_type_node \\\n+  java_global_trees[JTI_BYTE_ARRAY_TYPE_NODE]\n+#define short_array_type_node \\\n+  java_global_trees[JTI_SHORT_ARRAY_TYPE_NODE]\n+#define int_array_type_node \\\n+  java_global_trees[JTI_INT_ARRAY_TYPE_NODE]\n+#define long_array_type_node \\\n+  java_global_trees[JTI_LONG_ARRAY_TYPE_NODE]\n+#define boolean_array_type_node \\\n+  java_global_trees[JTI_BOOLEAN_ARRAY_TYPE_NODE]\n+#define char_array_type_node \\\n+  java_global_trees[JTI_CHAR_ARRAY_TYPE_NODE]\n+#define double_array_type_node \\\n+  java_global_trees[JTI_DOUBLE_ARRAY_TYPE_NODE]\n+#define float_array_type_node \\\n+  java_global_trees[JTI_FLOAT_ARRAY_TYPE_NODE]\n+#define array_array_type_node \\\n+  java_global_trees[JTI_ARRAY_ARRAY_TYPE_NODE]\n+#define object_array_type_node \\\n+  java_global_trees[JTI_OBJECT_ARRAY_TYPE_NODE]\n+#define string_array_type_node \\\n+  java_global_trees[JTI_STRING_ARRAY_TYPE_NODE]\n+#define boolean_array_vtable \\\n+  java_global_trees[JTI_BOOLEAN_ARRAY_VTABLE]\n+#define byte_array_vtable \\\n+  java_global_trees[JTI_BYTE_ARRAY_VTABLE]\n+#define char_array_vtable \\\n+  java_global_trees[JTI_CHAR_ARRAY_VTABLE]\n+#define short_array_vtable \\\n+  java_global_trees[JTI_SHORT_ARRAY_VTABLE]\n+#define int_array_vtable \\\n+  java_global_trees[JTI_INT_ARRAY_VTABLE]\n+#define long_array_vtable \\\n+  java_global_trees[JTI_LONG_ARRAY_VTABLE]\n+#define float_array_vtable \\\n+  java_global_trees[JTI_FLOAT_ARRAY_VTABLE]\n+#define double_array_vtable \\\n+  java_global_trees[JTI_DOUBLE_ARRAY_VTABLE]\n+#define TYPE_identifier_node \\\n+  java_global_trees[JTI_TYPE_IDENTIFIER_NODE]      /* \"TYPE\" */\n+#define init_identifier_node \\\n+  java_global_trees[JTI_INIT_IDENTIFIER_NODE]      /* \"<init>\" */\n+#define clinit_identifier_node \\\n+  java_global_trees[JTI_CLINIT_IDENTIFIER_NODE]      /* \"<clinit>\" */\n+#define finit_identifier_node \\\n+  java_global_trees[JTI_FINIT_IDENTIFIER_NODE]      /* \"finit$\" */\n+#define finit_leg_identifier_node \\\n+  java_global_trees[JTI_FINIT_LEG_IDENTIFIER_NODE]  /* \"$finit$\" */\n+#define void_signature_node \\\n+  java_global_trees[JTI_VOID_SIGNATURE_NODE]       /* \"()V\" */\n+#define length_identifier_node \\\n+  java_global_trees[JTI_LENGTH_IDENTIFIER_NODE]  /* \"length\" */\n+#define this_identifier_node \\\n+  java_global_trees[JTI_THIS_IDENTIFIER_NODE]  /* \"this\" */\n+#define super_identifier_node \\\n+  java_global_trees[JTI_SUPER_IDENTIFIER_NODE]  /* \"super\" */\n+#define continue_identifier_node \\\n+  java_global_trees[JTI_CONTINUE_IDENTIFIER_NODE]  /* \"continue\" */\n+#define access0_identifier_node \\\n+  java_global_trees[JTI_ACCESS0_IDENTIFIER_NODE] /* \"access$0\" */\n+#define one_elt_array_domain_type \\\n+  java_global_trees[JTI_ONE_ELT_ARRAY_DOMAIN_TYPE]\n /* The type of the return address of a subroutine. */\n-extern tree return_address_type_node;\n+#define return_address_type_node \\\n+  java_global_trees[JTI_RETURN_ADDRESS_TYPE_NODE]\n \n /* Nodes for boolean constants TRUE and FALSE. */\n-extern tree boolean_true_node, boolean_false_node;\n+#define boolean_true_node \\\n+  java_global_trees[JTI_BOOLEAN_TRUE_NODE]\n+#define boolean_false_node \\\n+  java_global_trees[JTI_BOOLEAN_FALSE_NODE]\n \n /* Integer constants not declared in tree.h. */\n-extern tree long_zero_node;\n-extern tree float_zero_node;\n-extern tree double_zero_node;\n-extern tree integer_negative_one_node;\n-extern tree integer_two_node;\n-extern tree integer_four_node;\n-extern tree empty_stmt_node;\n+#define long_zero_node \\\n+  java_global_trees[JTI_LONG_ZERO_NODE]\n+#define float_zero_node \\\n+  java_global_trees[JTI_FLOAT_ZERO_NODE]\n+#define double_zero_node \\\n+  java_global_trees[JTI_DOUBLE_ZERO_NODE]\n+#define integer_negative_one_node \\\n+  java_global_trees[JTI_INTEGER_NEGATIVE_ONE_NODE]\n+#define integer_two_node \\\n+  java_global_trees[JTI_INTEGER_TWO_NODE]\n+#define integer_four_node \\\n+  java_global_trees[JTI_INTEGER_FOUR_NODE]\n+#define empty_stmt_node \\\n+  java_global_trees[JTI_EMPTY_STMT_NODE]\n \n /* The type for struct methodtable. */\n-extern tree methodtable_type;\n-extern tree methodtable_ptr_type;\n-\n-extern tree utf8const_type;\n-extern tree utf8const_ptr_type;\n-\n-extern tree class_type_node;\n-extern tree class_ptr_type;\n-extern tree field_type_node;\n-extern tree constants_type_node;\n-extern tree dtable_type, dtable_ptr_type;\n-extern tree field_ptr_type_node;\n-extern tree field_info_union_node;\n-extern tree method_type_node;\n-extern tree method_ptr_type_node;\n-#define nativecode_ptr_type_node ptr_type_node\n-\n-extern tree end_params_node;\n+#define methodtable_type \\\n+  java_global_trees[JTI_METHODTABLE_TYPE]\n+#define methodtable_ptr_type \\\n+  java_global_trees[JTI_METHODTABLE_PTR_TYPE]\n+\n+#define utf8const_type \\\n+  java_global_trees[JTI_UTF8CONST_TYPE]\n+#define utf8const_ptr_type \\\n+  java_global_trees[JTI_UTF8CONST_PTR_TYPE]\n+\n+#define class_type_node \\\n+  java_global_trees[JTI_CLASS_TYPE_NODE]\n+#define class_ptr_type \\\n+  java_global_trees[JTI_CLASS_PTR_TYPE]\n+#define field_type_node \\\n+  java_global_trees[JTI_FIELD_TYPE_NODE]\n+#define constants_type_node \\\n+  java_global_trees[JTI_CONSTANTS_TYPE_NODE]\n+#define dtable_type \\\n+  java_global_trees[JTI_DTABLE_TYPE]\n+#define dtable_ptr_type \\\n+  java_global_trees[JTI_DTABLE_PTR_TYPE]\n+#define field_ptr_type_node \\\n+  java_global_trees[JTI_FIELD_PTR_TYPE_NODE]\n+#define field_info_union_node \\\n+  java_global_trees[JTI_FIELD_INFO_UNION_NODE]\n+#define jexception_type \\\n+  java_global_trees[JTI_EXCEPTION_TYPE]\n+#define jexception_ptr_type \\\n+  java_global_trees[JTI_EXCEPTION_PTR_TYPE]\n+#define lineNumberEntry_type \\\n+  java_global_trees[JTI_LINENUMBERENTRY_TYPE]\n+#define lineNumbers_type \\\n+  java_global_trees[JTI_LINENUMBERS_TYPE]\n+#define method_type_node \\\n+  java_global_trees[JTI_METHOD_TYPE_NODE]\n+#define method_ptr_type_node \\\n+  java_global_trees[JTI_METHOD_PTR_TYPE_NODE]\n+\n+#define end_params_node \\\n+  java_global_trees[JTI_END_PARAMS_NODE]\n \n /* References to internal libjava functions we use. */\n-extern tree alloc_object_node;\n-extern tree soft_instanceof_node;\n-extern tree soft_checkcast_node;\n-extern tree soft_initclass_node;\n-extern tree soft_newarray_node;\n-extern tree soft_anewarray_node;\n-extern tree soft_multianewarray_node;\n-extern tree soft_badarrayindex_node;\n-extern tree soft_nullpointer_node;\n+#define alloc_object_node \\\n+  java_global_trees[JTI_ALLOC_OBJECT_NODE]\n+#define soft_instanceof_node \\\n+  java_global_trees[JTI_SOFT_INSTANCEOF_NODE]\n+#define soft_checkcast_node \\\n+  java_global_trees[JTI_SOFT_CHECKCAST_NODE]\n+#define soft_initclass_node \\\n+  java_global_trees[JTI_SOFT_INITCLASS_NODE]\n+#define soft_newarray_node \\\n+  java_global_trees[JTI_SOFT_NEWARRAY_NODE]\n+#define soft_anewarray_node \\\n+  java_global_trees[JTI_SOFT_ANEWARRAY_NODE]\n+#define soft_multianewarray_node \\\n+  java_global_trees[JTI_SOFT_MULTIANEWARRAY_NODE]\n+#define soft_badarrayindex_node \\\n+  java_global_trees[JTI_SOFT_BADARRAYINDEX_NODE]\n+#define soft_nullpointer_node \\\n+  java_global_trees[JTI_SOFT_NULLPOINTER_NODE]\n extern tree throw_node[];\n-extern tree soft_checkarraystore_node;\n-extern tree soft_monitorenter_node;\n-extern tree soft_monitorexit_node;\n-extern tree soft_lookupinterfacemethod_node;\n-extern tree soft_lookupjnimethod_node;\n-extern tree soft_getjnienvnewframe_node;\n-extern tree soft_jnipopsystemframe_node;\n-extern tree soft_fmod_node;\n-extern tree soft_exceptioninfo_call_node;\n-extern tree soft_idiv_node;\n-extern tree soft_irem_node;\n-extern tree soft_ldiv_node;\n-extern tree soft_lrem_node;\n-\n-extern tree access_flags_type_node;\n-\n-extern tree class_dtable_decl;\n+#define soft_checkarraystore_node \\\n+  java_global_trees[JTI_SOFT_CHECKARRAYSTORE_NODE]\n+#define soft_monitorenter_node \\\n+  java_global_trees[JTI_SOFT_MONITORENTER_NODE]\n+#define soft_monitorexit_node \\\n+  java_global_trees[JTI_SOFT_MONITOREXIT_NODE]\n+#define soft_lookupinterfacemethod_node \\\n+  java_global_trees[JTI_SOFT_LOOKUPINTERFACEMETHOD_NODE]\n+#define soft_lookupjnimethod_node \\\n+  java_global_trees[JTI_SOFT_LOOKUPJNIMETHOD_NODE]\n+#define soft_getjnienvnewframe_node \\\n+  java_global_trees[JTI_SOFT_GETJNIENVNEWFRAME_NODE]\n+#define soft_jnipopsystemframe_node \\\n+  java_global_trees[JTI_SOFT_JNIPOPSYSTEMFRAME_NODE]\n+#define soft_fmod_node \\\n+  java_global_trees[JTI_SOFT_FMOD_NODE]\n+#define soft_exceptioninfo_call_node \\\n+  java_global_trees[JTI_SOFT_EXCEPTIONINFO_CALL_NODE]\n+#define soft_idiv_node \\\n+  java_global_trees[JTI_SOFT_IDIV_NODE]\n+#define soft_irem_node \\\n+  java_global_trees[JTI_SOFT_IREM_NODE]\n+#define soft_ldiv_node \\\n+  java_global_trees[JTI_SOFT_LDIV_NODE]\n+#define soft_lrem_node \\\n+  java_global_trees[JTI_SOFT_LREM_NODE]\n+\n+#define access_flags_type_node \\\n+  java_global_trees[JTI_ACCESS_FLAGS_TYPE_NODE]\n+\n+#define class_dtable_decl \\\n+  java_global_trees[JTI_CLASS_DTABLE_DECL]\n+\n+#define nativecode_ptr_array_type_node \\\n+  java_global_trees[JTI_NATIVECODE_PTR_ARRAY_TYPE_NODE]\n+\n+#define PREDEF_FILENAMES_SIZE 7\n+extern tree predef_filenames[PREDEF_FILENAMES_SIZE];\n+\n+#define nativecode_ptr_type_node ptr_type_node\n \n /* They need to be reset before processing each class */\n extern struct CPool *outgoing_cpool; \n-extern tree current_constant_pool_data_ref;\n+/* If non-NULL, an ADDR_EXPR referencing a VAR_DECL containing\n+   the constant data array for the current class. */\n+#define current_constant_pool_data_ref \\\n+  java_global_trees[JTI_CURRENT_CONSTANT_POOL_DATA_REF]\n \n-extern tree wfl_operator;\n+#define wfl_operator \\\n+  java_global_trees[JTI_WFL_OPERATOR]\n \n extern char *cyclic_inheritance_report;\n \n@@ -798,6 +1059,7 @@ extern unsigned long java_hash_hash_tree_node PARAMS ((hash_table_key));\n extern boolean java_hash_compare_tree_node PARAMS ((hash_table_key, \n \t\t\t\t\t\t    hash_table_key));\n extern void java_check_methods PARAMS ((tree));\n+extern void init_jcf_parse PARAMS((void));\n \n /* We use ARGS_SIZE_RTX to indicate that gcc/expr.h has been included\n    to declare `enum expand_modifier'. */"}, {"sha": "7abd1cbdcb2f9d53382d110986ad3f6728cc6d19", "filename": "gcc/java/jcf-parse.c", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19e223db83b86b7262db77c9ea67e7d6d32a0d73/gcc%2Fjava%2Fjcf-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19e223db83b86b7262db77c9ea67e7d6d32a0d73/gcc%2Fjava%2Fjcf-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-parse.c?ref=19e223db83b86b7262db77c9ea67e7d6d32a0d73", "patch": "@@ -34,6 +34,7 @@ The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n #include \"java-tree.h\"\n #include \"toplev.h\"\n #include \"parse.h\"\n+#include \"ggc.h\"\n \n #ifdef HAVE_LOCALE_H\n #include <locale.h>\n@@ -69,15 +70,6 @@ extern struct obstack permanent_obstack;\n    before static field references.  */\n extern int always_initialize_class_p;\n \n-/* The class we are currently processing. */\n-tree current_class = NULL_TREE;\n-\n-/* The class we started with. */\n-tree main_class = NULL_TREE;\n-\n-/* List of all class DECL seen so far.  */\n-tree all_class_list = NULL_TREE;\n-\n /* The FIELD_DECL for the current field.  */\n static tree current_field = NULL_TREE;\n \n@@ -808,7 +800,7 @@ predefined_filename_p (node)\n      tree node;\n {\n   int i;\n-  for (i = 0; i < predef_filenames_size; i++)\n+  for (i = 0; i < PREDEF_FILENAMES_SIZE; i++)\n     if (predef_filenames [i] == node)\n       return 1;\n   return 0;\n@@ -1095,3 +1087,12 @@ DEFUN(jcf_figure_file_type, (jcf),\n   return JCF_SOURCE;\n }\n \n+/* Initialization.  */\n+\n+void\n+init_jcf_parse ()\n+{\n+  /* Register roots with the garbage collector.  */\n+  ggc_add_tree_root (&current_field, 1);\n+  ggc_add_tree_root (&current_method, 1);\n+}"}, {"sha": "e08b37d54570f94d139654da396414249279c0b2", "filename": "gcc/java/jcf-write.c", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19e223db83b86b7262db77c9ea67e7d6d32a0d73/gcc%2Fjava%2Fjcf-write.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19e223db83b86b7262db77c9ea67e7d6d32a0d73/gcc%2Fjava%2Fjcf-write.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-write.c?ref=19e223db83b86b7262db77c9ea67e7d6d32a0d73", "patch": "@@ -34,6 +34,7 @@ The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n #include \"parse.h\" /* for BLOCK_EXPR_BODY */\n #include \"buffer.h\"\n #include \"toplev.h\"\n+#include \"ggc.h\"\n \n #ifndef DIR_SEPARATOR\n #define DIR_SEPARATOR '/'\n@@ -3100,7 +3101,11 @@ generate_classfile (clas, state)\n \n   /* generate the SourceFile attribute. */\n   if (SourceFile_node == NULL_TREE) \n-    SourceFile_node = get_identifier (\"SourceFile\");\n+    {\n+      SourceFile_node = get_identifier (\"SourceFile\");\n+      ggc_add_tree_root (&SourceFile_node, 1);\n+    }\n+\n   i = find_utf8_constant (&state->cpool, SourceFile_node);\n   PUT2 (i);  /* attribute_name_index */\n   PUT4 (2);\n@@ -3126,7 +3131,10 @@ append_synthetic_attribute (state)\n   int i;\n \n   if (Synthetic_node == NULL_TREE)\n-    Synthetic_node = get_identifier (\"Synthetic\");\n+    {\n+      Synthetic_node = get_identifier (\"Synthetic\");\n+      ggc_add_tree_root (&Synthetic_node, 1);\n+    }\n   i = find_utf8_constant (&state->cpool, Synthetic_node);\n   PUT2 (i);\t\t/* Attribute string index */\n   PUT4 (0);\t\t/* Attribute length */\n@@ -3150,8 +3158,11 @@ append_innerclasses_attribute (state, class)\n \n   ptr = append_chunk (NULL, 8, state); /* 2+4+2 */\n   \n-  if (InnerClasses_node == NULL_TREE)\n-    InnerClasses_node = get_identifier (\"InnerClasses\");\n+  if (InnerClasses_node == NULL_TREE) \n+    {\n+      InnerClasses_node = get_identifier (\"InnerClasses\");\n+      ggc_add_tree_root (&InnerClasses_node, 1);\n+    }\n   i = find_utf8_constant (&state->cpool, InnerClasses_node);\n   PUT2 (i);\n   length_marker = ptr; PUT4 (0); /* length, to be later patched */\n@@ -3198,8 +3209,11 @@ append_innerclasses_attribute_entry (state, decl, name)\n   unsigned char *ptr = append_chunk (NULL, 8, state);\n \n   if (!anonymous_name)\n-    anonymous_name = get_identifier (\"\");\n-  \n+    {\n+      anonymous_name = get_identifier (\"\");\n+      ggc_add_tree_root (&anonymous_name, 1);\n+    }\n+\n   icii = find_class_constant (&state->cpool, TREE_TYPE (decl));\n   ocii = find_class_constant (&state->cpool, TREE_TYPE (DECL_CONTEXT (decl))); \n "}, {"sha": "91e8f13dd5f6b1ac43e361ca343589256e32d995", "filename": "gcc/java/lang.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19e223db83b86b7262db77c9ea67e7d6d32a0d73/gcc%2Fjava%2Flang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19e223db83b86b7262db77c9ea67e7d6d32a0d73/gcc%2Fjava%2Flang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flang.c?ref=19e223db83b86b7262db77c9ea67e7d6d32a0d73", "patch": "@@ -35,6 +35,7 @@ The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n #include \"toplev.h\"\n #include \"flags.h\"\n #include \"xref.h\"\n+#include \"ggc.h\"\n \n static void put_decl_string PARAMS ((const char *, int));\n static void put_decl_node PARAMS ((tree));\n@@ -518,6 +519,16 @@ lang_print_error (file)\n {\n   static tree last_error_function_context = NULL_TREE;\n   static tree last_error_function = NULL;\n+  static int initialized_p;\n+\n+  /* Register LAST_ERROR_FUNCTION_CONTEXT and LAST_ERROR_FUNCTION with\n+     the garbage collector.  */\n+  if (!initialized_p)\n+    {\n+      ggc_add_tree_root (&last_error_function_context, 1);\n+      ggc_add_tree_root (&last_error_function, 1);\n+      initialized_p = 1;\n+    }\n \n   if (current_function_decl != NULL\n       && DECL_CONTEXT (current_function_decl) != last_error_function_context)"}, {"sha": "0f0aa9b9ca9b524b49badb72383812dae13f99b0", "filename": "gcc/java/parse.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19e223db83b86b7262db77c9ea67e7d6d32a0d73/gcc%2Fjava%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19e223db83b86b7262db77c9ea67e7d6d32a0d73/gcc%2Fjava%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.h?ref=19e223db83b86b7262db77c9ea67e7d6d32a0d73", "patch": "@@ -764,8 +764,8 @@ struct parser_ctxt {\n   /* This section is defined only if we compile jc1 */\n #ifndef JC1_LITE\n   tree modifier_ctx [11];\t    /* WFL of modifiers */\n-  tree current_class;\t\t    /* Current class */\n-  tree current_function_decl;\t    /* Current function decl, save/restore */\n+  tree class_type;\t\t    /* Current class */\n+  tree function_decl;\t            /* Current function decl, save/restore */\n \n   struct JCF *current_jcf;\t    /* CU jcf */\n "}, {"sha": "b1a8e157b5e43255689c3cb0efd94ee8f95ca410", "filename": "gcc/java/parse.y", "status": "modified", "additions": 91, "deletions": 29, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19e223db83b86b7262db77c9ea67e7d6d32a0d73/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19e223db83b86b7262db77c9ea67e7d6d32a0d73/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=19e223db83b86b7262db77c9ea67e7d6d32a0d73", "patch": "@@ -65,6 +65,7 @@ definitions and other extensions.  */\n #include \"function.h\"\n #include \"except.h\"\n #include \"defaults.h\"\n+#include \"ggc.h\"\n \n #ifndef DIR_SEPARATOR\n #define DIR_SEPARATOR '/'\n@@ -361,10 +362,6 @@ static enum tree_code binop_lookup[19] =\n    in compound assignements. */\n #define BINOP_COMPOUND_CANDIDATES 11\n \n-/* Fake WFL used to report error message. It is initialized once if\n-   needed and reused with it's location information is overriden.  */\n-tree wfl_operator = NULL_TREE;\n-\n /* The \"$L\" identifier we use to create labels.  */\n static tree label_id = NULL_TREE;\n \n@@ -399,6 +396,13 @@ static tree wpv_id;\n /* The list of all packages we've seen so far */\n static tree package_list = NULL_TREE;\n  \n+/* Hold THIS for the scope of the current public method decl.  */\n+static tree current_this;\n+\n+/* Hold a list of catch clauses list. The first element of this list is\n+   the list of the catch clauses of the currently analysed try block. */\n+static tree currently_caught_type_list;\n+\n /* Check modifiers. If one doesn't fit, retrieve it in its declaration\n    line and point it out.  */\n /* Should point out the one that don't fit. ASCII/unicode, going\n@@ -577,6 +581,23 @@ static tree package_list = NULL_TREE;\n %%\n /* 19.2 Production from 2.3: The Syntactic Grammar  */\n goal:\n+                {\n+\t\t  /* Register static variables with the garbage\n+\t\t     collector.  */\n+\t\t  ggc_add_tree_root (&label_id, 1);\n+\t\t  ggc_add_tree_root (&wfl_string_buffer, 1);\n+\t\t  ggc_add_tree_root (&wfl_append, 1);\n+\t\t  ggc_add_tree_root (&wfl_to_string, 1);\n+\t\t  ggc_add_tree_root (&java_lang_id, 1);\n+\t\t  ggc_add_tree_root (&inst_id, 1);\n+\t\t  ggc_add_tree_root (&java_lang_cloneable, 1);\n+\t\t  ggc_add_tree_root (&java_io_serializable, 1);\n+\t\t  ggc_add_tree_root (&current_static_block, 1);\n+\t\t  ggc_add_tree_root (&wpv_id, 1);\n+\t\t  ggc_add_tree_root (&package_list, 1);\n+\t\t  ggc_add_tree_root (&current_this, 1);\n+\t\t  ggc_add_tree_root (&currently_caught_type_list, 1);\n+\t\t}\n \tcompilation_unit\n \t\t{}\n ;\n@@ -2618,7 +2639,7 @@ java_pop_parser_context (generate)\n       next->incomplete_class = ctxp->incomplete_class;\n       next->gclass_list = ctxp->gclass_list;\n       lineno = ctxp->lineno;\n-      current_class = ctxp->current_class;\n+      current_class = ctxp->class_type;\n     }\n \n   /* If the old and new lexers differ, then free the old one.  */\n@@ -2665,9 +2686,9 @@ java_parser_context_save_global ()\n     create_new_parser_context (1);\n \n   ctxp->lineno = lineno;\n-  ctxp->current_class = current_class;\n+  ctxp->class_type = current_class;\n   ctxp->filename = input_filename;\n-  ctxp->current_function_decl = current_function_decl;\n+  ctxp->function_decl = current_function_decl;\n   ctxp->saved_data = 1;\n }\n \n@@ -2678,9 +2699,9 @@ void\n java_parser_context_restore_global ()\n {\n   lineno = ctxp->lineno;\n-  current_class = ctxp->current_class;\n+  current_class = ctxp->class_type;\n   input_filename = ctxp->filename;\n-  current_function_decl = ctxp->current_function_decl;\n+  current_function_decl = ctxp->function_decl;\n   ctxp->saved_data = 0;\n   if (ctxp->saved_data_ctx)\n     java_pop_parser_context (0);\n@@ -2699,8 +2720,8 @@ java_parser_context_suspend ()\n   /* Duplicate the previous context, use it to save the globals we're\n      interested in */\n   create_new_parser_context (1);\n-  ctxp->current_function_decl = current_function_decl;\n-  ctxp->current_class = current_class;\n+  ctxp->function_decl = current_function_decl;\n+  ctxp->class_type = current_class;\n \n   /* Then create a new context which inherits all data from the\n      previous one. This will be the new current context  */\n@@ -2730,8 +2751,8 @@ java_parser_context_resume ()\n   restored->class_list = old->class_list;\n \n   /* Restore the current class and function from the saver */\n-  current_class = saver->current_class;\n-  current_function_decl = saver->current_function_decl;\n+  current_class = saver->class_type;\n+  current_function_decl = saver->function_decl;\n \n   /* Retrive the restored context */\n   ctxp = restored;\n@@ -4570,7 +4591,17 @@ verify_constructor_circularity (meth, current)\n      tree meth, current;\n {\n   static tree list = NULL_TREE;\n+  static int initialized_p;\n   tree c;\n+\n+  /* If we haven't already registered LIST with the garbage collector,\n+     do so now.  */\n+  if (!initialized_p)\n+    {\n+      ggc_add_tree_root (&list, 1);\n+      initialized_p = 1;\n+    }\n+\n   for (c = DECL_CONSTRUCTOR_CALLS (current); c; c = TREE_CHAIN (c))\n     {\n       if (TREE_VALUE (c) == meth)\n@@ -6409,7 +6440,10 @@ lookup_cl (decl)\n     return NULL_TREE;\n \n   if (cl == NULL_TREE)\n-    cl = build_expr_wfl (NULL_TREE, NULL, 0, 0);\n+    {\n+      cl = build_expr_wfl (NULL_TREE, NULL, 0, 0);\n+      ggc_add_tree_root (&cl, 1);\n+    }\n \n   EXPR_WFL_FILENAME_NODE (cl) = get_identifier (DECL_SOURCE_FILE (decl));\n   EXPR_WFL_SET_LINECOL (cl, DECL_SOURCE_LINE_FIRST (decl), -1);\n@@ -7249,9 +7283,6 @@ add_stmt_to_compound (existing, type, stmt)\n     return stmt;\n }\n \n-/* Hold THIS for the scope of the current public method decl.  */\n-static tree current_this;\n-\n void java_layout_seen_class_methods ()\n {\n   tree previous_list = all_class_list;\n@@ -7278,8 +7309,16 @@ void\n java_reorder_fields ()\n {\n   static tree stop_reordering = NULL_TREE;\n-\n+  static int initialized_p;\n   tree current;\n+\n+  /* Register STOP_REORDERING with the garbage collector.  */\n+  if (!initialized_p)\n+    {\n+      ggc_add_tree_root (&stop_reordering, 1);\n+      initialized_p = 1;\n+    }\n+\n   for (current = ctxp->gclass_list; current; current = TREE_CHAIN (current))\n     {\n       current_class = TREE_TYPE (TREE_VALUE (current));\n@@ -7490,10 +7529,6 @@ java_complete_expand_methods (class_decl)\n   TYPE_CPOOL (current_class) = outgoing_cpool;\n }\n \n-/* Hold a list of catch clauses list. The first element of this list is\n-   the list of the catch clauses of the currently analysed try block. */\n-static tree currently_caught_type_list;\n-\n /* Attempt to create <clinit>. Pre-expand static fields so they can be\n    safely used in some other methods/constructors.  */\n \n@@ -8175,16 +8210,23 @@ build_current_thisn (type)\n {\n   static int saved_i = -1;\n   static tree saved_thisn = NULL_TREE;\n-\n+  static tree saved_type = NULL_TREE;\n+  static int saved_type_i = 0;\n+  static int initialized_p;\n   tree decl;\n   char buffer [80];\n   int i = 0;\n \n-  if (type)\n+  /* Register SAVED_THISN and SAVED_TYPE with the garbage collector.  */\n+  if (!initialized_p)\n     {\n-      static tree saved_type = NULL_TREE;\n-      static int saved_type_i = 0;\n+      ggc_add_tree_root (&saved_thisn, 1);\n+      ggc_add_tree_root (&saved_type, 1);\n+      initialized_p = 1;\n+    }\n \n+  if (type)\n+    {\n       if (type == saved_type)\n \ti = saved_type_i;\n       else\n@@ -8256,6 +8298,8 @@ build_dot_class_method (class)\n     {\n       get_message_wfl = build_wfl_node (get_identifier (\"getMessage\"));\n       type_parm_wfl = build_wfl_node (get_identifier (\"type$\"));\n+      ggc_add_tree_root (&get_message_wfl, 1);\n+      ggc_add_tree_root (&type_parm_wfl, 1);\n     }\n \n   /* Build the arguments */\n@@ -9547,6 +9591,14 @@ class_in_current_package (class)\n   breakdown_qualified (&left, NULL, DECL_NAME (TYPE_NAME (class)));\n   if (ctxp->package == left)\n     {\n+      static int initialized_p;\n+      /* Register CACHE with the garbage collector.  */\n+      if (!initialized_p)\n+\t{\n+\t  ggc_add_tree_root (&cache, 1);\n+\t  initialized_p = 1;\n+\t}\n+\n       cache = class;\n       return 1;\n     }\n@@ -10504,9 +10556,19 @@ argument_types_convertible (m1, m2_or_arglist)\n {\n   static tree m2_arg_value = NULL_TREE;\n   static tree m2_arg_cache = NULL_TREE;\n+  static int initialized_p;\n \n   register tree m1_arg, m2_arg;\n \n+  /* Register M2_ARG_VALUE and M2_ARG_CACHE with the garbage\n+     collector.  */\n+  if (!initialized_p)\n+    {\n+      ggc_add_tree_root (&m2_arg_value, 1);\n+      ggc_add_tree_root (&m2_arg_cache, 1);\n+      initialized_p = 1;\n+    }\n+\n   SKIP_THIS_AND_ARTIFICIAL_PARMS (m1_arg, m1)\n \n   if (m2_arg_value == m2_or_arglist)\n@@ -13459,9 +13521,9 @@ resolve_type_during_patch (type)\n    found. Otherwise NODE or something meant to replace it is returned.  */\n \n static tree\n-patch_cast (node, wfl_operator)\n+patch_cast (node, wfl_op)\n      tree node;\n-     tree wfl_operator;\n+     tree wfl_op;\n {\n   tree op = TREE_OPERAND (node, 0);\n   tree op_type = TREE_TYPE (op);\n@@ -13530,7 +13592,7 @@ patch_cast (node, wfl_operator)\n \n   /* Any other casts are proven incorrect at compile time */\n   t1 = xstrdup (lang_printable_name (op_type, 0));\n-  parse_error_context (wfl_operator, \"Invalid cast from `%s' to `%s'\",\n+  parse_error_context (wfl_op, \"Invalid cast from `%s' to `%s'\",\n \t\t       t1, lang_printable_name (cast_type, 0));\n   free (t1);\n   return error_mark_node;"}]}