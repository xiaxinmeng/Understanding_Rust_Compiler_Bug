{"sha": "07c48b61a082128b69cc9a4a7ae1d05e2b2a2ebb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDdjNDhiNjFhMDgyMTI4YjY5Y2M5YTRhN2FlMWQwNWUyYjJhMmViYg==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@gmail.com", "date": "2020-03-27T02:42:34Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gmail.com", "date": "2020-03-30T07:39:05Z"}, "message": "[RS6000] Put call cookie back in AIX/ELFv2 call patterns\n\n-mlongcall -mno-pltseq is supposed to emit long calls by using\nindirect calls.  It differs from -mlongcall -mpltseq in that the\nfunction addresses are not placed in the PLT and thus lazy PLT\nresolution is not available, affecting programs that dlopen shared\nlibraries.\n\nIn the case of -mcpu=future -mpcrel -mlongcall -mno-pltseq we see an\nindirect call being generated, but combine merrily optimises the\nsequence back to a direct call.  call_indirect_pcrel is enough like\ncall_nonlocal_aix that this can happen.\n\nThis patch puts the call cookie back in the call rtl, removed by git\ncommit f90f960ca8, in order to disable the optimisation for long\ncalls.  When that is done for call_local_aix the pattern becomes the\nsame as call_local32/64, so I merged them.  The only difference\nbesides mode between call_local32 and call_local64, dating back to\n1998 commit a260abc996, is that call_local64 has TARGET_64BIT in the\npredicate.  That alone doesn't seem reason enough to need separate\npatterns; The P mode iterator selects DI on TARGET_64BIT anyway.\n\n\t* config/rs6000/rs6000.c (rs6000_call_aix): Emit cookie to pattern.\n\t(rs6000_indirect_call_template_1): Adjust to suit.\n\t* config/rs6000/rs6000.md (call_local): Merge call_local32,\n\tcall_local64, and call_local_aix.\n\t(call_value_local): Simlarly.\n\t(call_nonlocal_aix, call_value_nonlocal_aix): Adjust rtl to suit,\n\tand disable pattern when CALL_LONG.\n\t(call_indirect_aix, call_value_indirect_aix): Adjust rtl.\n\t(call_indirect_elfv2, call_indirect_pcrel): Likewise.\n\t(call_value_indirect_elfv2, call_value_indirect_pcrel): Likewise.", "tree": {"sha": "f8f6d76102f0cafb1f5a8f8295b7cb3af0c84db7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f8f6d76102f0cafb1f5a8f8295b7cb3af0c84db7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/07c48b61a082128b69cc9a4a7ae1d05e2b2a2ebb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07c48b61a082128b69cc9a4a7ae1d05e2b2a2ebb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07c48b61a082128b69cc9a4a7ae1d05e2b2a2ebb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07c48b61a082128b69cc9a4a7ae1d05e2b2a2ebb/comments", "author": {"login": "amodra", "id": 6006325, "node_id": "MDQ6VXNlcjYwMDYzMjU=", "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4", "gravatar_id": "", "url": "https://api.github.com/users/amodra", "html_url": "https://github.com/amodra", "followers_url": "https://api.github.com/users/amodra/followers", "following_url": "https://api.github.com/users/amodra/following{/other_user}", "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}", "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/amodra/subscriptions", "organizations_url": "https://api.github.com/users/amodra/orgs", "repos_url": "https://api.github.com/users/amodra/repos", "events_url": "https://api.github.com/users/amodra/events{/privacy}", "received_events_url": "https://api.github.com/users/amodra/received_events", "type": "User", "site_admin": false}, "committer": {"login": "amodra", "id": 6006325, "node_id": "MDQ6VXNlcjYwMDYzMjU=", "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4", "gravatar_id": "", "url": "https://api.github.com/users/amodra", "html_url": "https://github.com/amodra", "followers_url": "https://api.github.com/users/amodra/followers", "following_url": "https://api.github.com/users/amodra/following{/other_user}", "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}", "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/amodra/subscriptions", "organizations_url": "https://api.github.com/users/amodra/orgs", "repos_url": "https://api.github.com/users/amodra/repos", "events_url": "https://api.github.com/users/amodra/events{/privacy}", "received_events_url": "https://api.github.com/users/amodra/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2a93fb6e962644b809f728411d2953854bfd1039", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a93fb6e962644b809f728411d2953854bfd1039", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a93fb6e962644b809f728411d2953854bfd1039"}], "stats": {"total": 141, "additions": 52, "deletions": 89}, "files": [{"sha": "4e0545de429a3979f3f9490d3fa792c6ab8d6643", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07c48b61a082128b69cc9a4a7ae1d05e2b2a2ebb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07c48b61a082128b69cc9a4a7ae1d05e2b2a2ebb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=07c48b61a082128b69cc9a4a7ae1d05e2b2a2ebb", "patch": "@@ -1,3 +1,16 @@\n+2020-03-30  Alan Modra  <amodra@gmail.com>\n+\n+\t* config/rs6000/rs6000.c (rs6000_call_aix): Emit cookie to pattern.\n+\t(rs6000_indirect_call_template_1): Adjust to suit.\n+\t* config/rs6000/rs6000.md (call_local): Merge call_local32,\n+\tcall_local64, and call_local_aix.\n+\t(call_value_local): Simlarly.\n+\t(call_nonlocal_aix, call_value_nonlocal_aix): Adjust rtl to suit,\n+\tand disable pattern when CALL_LONG.\n+\t(call_indirect_aix, call_value_indirect_aix): Adjust rtl.\n+\t(call_indirect_elfv2, call_indirect_pcrel): Likewise.\n+\t(call_value_indirect_elfv2, call_value_indirect_pcrel): Likewise.\n+\n 2020-03-29  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR driver/94381"}, {"sha": "2b6613bcb7e9784a87f33efc97ad2ab43b925fe2", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07c48b61a082128b69cc9a4a7ae1d05e2b2a2ebb/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07c48b61a082128b69cc9a4a7ae1d05e2b2a2ebb/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=07c48b61a082128b69cc9a4a7ae1d05e2b2a2ebb", "patch": "@@ -13621,7 +13621,7 @@ rs6000_indirect_call_template_1 (rtx *operands, unsigned int funop,\n   if (DEFAULT_ABI == ABI_AIX)\n     s += sprintf (s,\n \t\t  \"l%s 2,%%%u\\n\\t\",\n-\t\t  ptrload, funop + 2);\n+\t\t  ptrload, funop + 3);\n \n   /* We don't need the extra code to stop indirect call speculation if\n      calling via LR.  */\n@@ -13675,25 +13675,25 @@ rs6000_indirect_call_template_1 (rtx *operands, unsigned int funop,\n \tsprintf (s,\n \t\t \"b%%T%ul\\n\\t\"\n \t\t \"l%s 2,%%%u(1)\",\n-\t\t funop, ptrload, funop + 3);\n+\t\t funop, ptrload, funop + 4);\n       else\n \tsprintf (s,\n \t\t \"beq%%T%ul-\\n\\t\"\n \t\t \"l%s 2,%%%u(1)\",\n-\t\t funop, ptrload, funop + 3);\n+\t\t funop, ptrload, funop + 4);\n     }\n   else if (DEFAULT_ABI == ABI_ELFv2)\n     {\n       if (speculate)\n \tsprintf (s,\n \t\t \"b%%T%ul\\n\\t\"\n \t\t \"l%s 2,%%%u(1)\",\n-\t\t funop, ptrload, funop + 2);\n+\t\t funop, ptrload, funop + 3);\n       else\n \tsprintf (s,\n \t\t \"beq%%T%ul-\\n\\t\"\n \t\t \"l%s 2,%%%u(1)\",\n-\t\t funop, ptrload, funop + 2);\n+\t\t funop, ptrload, funop + 3);\n     }\n   else\n     {\n@@ -24304,7 +24304,7 @@ rs6000_call_aix (rtx value, rtx func_desc, rtx tlsarg, rtx cookie)\n   rtx toc_restore = NULL_RTX;\n   rtx func_addr;\n   rtx abi_reg = NULL_RTX;\n-  rtx call[4];\n+  rtx call[5];\n   int n_call;\n   rtx insn;\n   bool is_pltseq_longcall;\n@@ -24445,7 +24445,8 @@ rs6000_call_aix (rtx value, rtx func_desc, rtx tlsarg, rtx cookie)\n   call[0] = gen_rtx_CALL (VOIDmode, gen_rtx_MEM (SImode, func_addr), tlsarg);\n   if (value != NULL_RTX)\n     call[0] = gen_rtx_SET (value, call[0]);\n-  n_call = 1;\n+  call[1] = gen_rtx_USE (VOIDmode, cookie);\n+  n_call = 2;\n \n   if (toc_load)\n     call[n_call++] = toc_load;"}, {"sha": "dcccb03f376ee7a24446b281106c8107c42b0074", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 31, "deletions": 82, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07c48b61a082128b69cc9a4a7ae1d05e2b2a2ebb/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07c48b61a082128b69cc9a4a7ae1d05e2b2a2ebb/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=07c48b61a082128b69cc9a4a7ae1d05e2b2a2ebb", "patch": "@@ -10459,11 +10459,11 @@\n ;; variable argument function.  It is > 0 if FP registers were passed\n ;; and < 0 if they were not.\n \n-(define_insn \"*call_local32\"\n-  [(call (mem:SI (match_operand:SI 0 \"current_file_function_operand\" \"s,s\"))\n+(define_insn \"*call_local<mode>\"\n+  [(call (mem:SI (match_operand:P 0 \"current_file_function_operand\" \"s,s\"))\n \t (match_operand 1))\n    (use (match_operand:SI 2 \"immediate_operand\" \"O,n\"))\n-   (clobber (reg:SI LR_REGNO))]\n+   (clobber (reg:P LR_REGNO))]\n   \"(INTVAL (operands[2]) & CALL_LONG) == 0\"\n {\n   if (INTVAL (operands[2]) & CALL_V4_SET_FP_ARGS)\n@@ -10472,35 +10472,19 @@\n   else if (INTVAL (operands[2]) & CALL_V4_CLEAR_FP_ARGS)\n     output_asm_insn (\"creqv 6,6,6\", operands);\n \n+  if (rs6000_pcrel_p (cfun))\n+    return \"bl %z0@notoc\";\n   return (DEFAULT_ABI == ABI_V4 && flag_pic) ? \"bl %z0@local\" : \"bl %z0\";\n }\n   [(set_attr \"type\" \"branch\")\n    (set_attr \"length\" \"4,8\")])\n \n-(define_insn \"*call_local64\"\n-  [(call (mem:SI (match_operand:DI 0 \"current_file_function_operand\" \"s,s\"))\n-\t (match_operand 1))\n-   (use (match_operand:SI 2 \"immediate_operand\" \"O,n\"))\n-   (clobber (reg:DI LR_REGNO))]\n-  \"TARGET_64BIT && (INTVAL (operands[2]) & CALL_LONG) == 0\"\n-{\n-  if (INTVAL (operands[2]) & CALL_V4_SET_FP_ARGS)\n-    output_asm_insn (\"crxor 6,6,6\", operands);\n-\n-  else if (INTVAL (operands[2]) & CALL_V4_CLEAR_FP_ARGS)\n-    output_asm_insn (\"creqv 6,6,6\", operands);\n-\n-  return (DEFAULT_ABI == ABI_V4 && flag_pic) ? \"bl %z0@local\" : \"bl %z0\";\n-}\n-  [(set_attr \"type\" \"branch\")\n-   (set_attr \"length\" \"4,8\")])\n-\n-(define_insn \"*call_value_local32\"\n+(define_insn \"*call_value_local<mode>\"\n   [(set (match_operand 0 \"\" \"\")\n-\t(call (mem:SI (match_operand:SI 1 \"current_file_function_operand\" \"s,s\"))\n+\t(call (mem:SI (match_operand:P 1 \"current_file_function_operand\" \"s,s\"))\n \t      (match_operand 2)))\n    (use (match_operand:SI 3 \"immediate_operand\" \"O,n\"))\n-   (clobber (reg:SI LR_REGNO))]\n+   (clobber (reg:P LR_REGNO))]\n   \"(INTVAL (operands[3]) & CALL_LONG) == 0\"\n {\n   if (INTVAL (operands[3]) & CALL_V4_SET_FP_ARGS)\n@@ -10509,26 +10493,8 @@\n   else if (INTVAL (operands[3]) & CALL_V4_CLEAR_FP_ARGS)\n     output_asm_insn (\"creqv 6,6,6\", operands);\n \n-  return (DEFAULT_ABI == ABI_V4 && flag_pic) ? \"bl %z1@local\" : \"bl %z1\";\n-}\n-  [(set_attr \"type\" \"branch\")\n-   (set_attr \"length\" \"4,8\")])\n-\n-\n-(define_insn \"*call_value_local64\"\n-  [(set (match_operand 0 \"\" \"\")\n-\t(call (mem:SI (match_operand:DI 1 \"current_file_function_operand\" \"s,s\"))\n-\t      (match_operand 2)))\n-   (use (match_operand:SI 3 \"immediate_operand\" \"O,n\"))\n-   (clobber (reg:DI LR_REGNO))]\n-  \"TARGET_64BIT && (INTVAL (operands[3]) & CALL_LONG) == 0\"\n-{\n-  if (INTVAL (operands[3]) & CALL_V4_SET_FP_ARGS)\n-    output_asm_insn (\"crxor 6,6,6\", operands);\n-\n-  else if (INTVAL (operands[3]) & CALL_V4_CLEAR_FP_ARGS)\n-    output_asm_insn (\"creqv 6,6,6\", operands);\n-\n+  if (rs6000_pcrel_p (cfun))\n+    return \"bl %z1@notoc\";\n   return (DEFAULT_ABI == ABI_V4 && flag_pic) ? \"bl %z1@local\" : \"bl %z1\";\n }\n   [(set_attr \"type\" \"branch\")\n@@ -10687,41 +10653,16 @@\n \t  (const_int 8)\n \t  (const_int 4)))])\n \n-;; Call to AIX abi function in the same module.\n-\n-(define_insn \"*call_local_aix<mode>\"\n-  [(call (mem:SI (match_operand:P 0 \"current_file_function_operand\" \"s\"))\n-\t (match_operand 1))\n-   (clobber (reg:P LR_REGNO))]\n-  \"DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_ELFv2\"\n-{\n-  if (rs6000_pcrel_p (cfun))\n-    return \"bl %z0@notoc\";\n-  return \"bl %z0\";\n-}\n-  [(set_attr \"type\" \"branch\")])\n-\n-(define_insn \"*call_value_local_aix<mode>\"\n-  [(set (match_operand 0 \"\" \"\")\n-\t(call (mem:SI (match_operand:P 1 \"current_file_function_operand\" \"s\"))\n-\t      (match_operand 2)))\n-   (clobber (reg:P LR_REGNO))]\n-  \"DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_ELFv2\"\n-{\n-  if (rs6000_pcrel_p (cfun))\n-    return \"bl %z1@notoc\";\n-  return \"bl %z1\";\n-}\n-  [(set_attr \"type\" \"branch\")])\n-\n ;; Call to AIX abi function which may be in another module.\n ;; Restore the TOC pointer (r2) after the call.\n \n (define_insn \"*call_nonlocal_aix<mode>\"\n   [(call (mem:SI (match_operand:P 0 \"symbol_ref_operand\" \"s\"))\n \t (match_operand 1))\n+   (use (match_operand:SI 2 \"immediate_operand\" \"n\"))\n    (clobber (reg:P LR_REGNO))]\n-  \"DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_ELFv2\"\n+  \"(DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_ELFv2)\n+   && (INTVAL (operands[2]) & CALL_LONG) == 0\"\n {\n   return rs6000_call_template (operands, 0);\n }\n@@ -10735,8 +10676,10 @@\n   [(set (match_operand 0 \"\" \"\")\n \t(call (mem:SI (match_operand:P 1 \"symbol_ref_operand\" \"s\"))\n \t      (match_operand:P 2 \"unspec_tls\" \"\")))\n+   (use (match_operand:SI 3 \"immediate_operand\" \"n\"))\n    (clobber (reg:P LR_REGNO))]\n-  \"DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_ELFv2\"\n+  \"(DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_ELFv2)\n+   && (INTVAL (operands[3]) & CALL_LONG) == 0\"\n {\n   return rs6000_call_template (operands, 1);\n }\n@@ -10748,14 +10691,15 @@\n \n ;; Call to indirect functions with the AIX abi using a 3 word descriptor.\n ;; Operand0 is the addresss of the function to call\n-;; Operand2 is the location in the function descriptor to load r2 from\n-;; Operand3 is the offset of the stack location holding the current TOC pointer\n+;; Operand3 is the location in the function descriptor to load r2 from\n+;; Operand4 is the offset of the stack location holding the current TOC pointer\n \n (define_insn \"*call_indirect_aix<mode>\"\n   [(call (mem:SI (match_operand:P 0 \"indirect_call_operand\" \"c,*l,X\"))\n \t (match_operand 1))\n-   (use (match_operand:P 2 \"memory_operand\" \"<ptrm>,<ptrm>,<ptrm>\"))\n-   (set (reg:P TOC_REGNUM) (unspec:P [(match_operand:P 3 \"const_int_operand\" \"n,n,n\")] UNSPEC_TOCSLOT))\n+   (use (match_operand:SI 2 \"immediate_operand\" \"n,n,n\"))\n+   (use (match_operand:P 3 \"memory_operand\" \"<ptrm>,<ptrm>,<ptrm>\"))\n+   (set (reg:P TOC_REGNUM) (unspec:P [(match_operand:P 4 \"const_int_operand\" \"n,n,n\")] UNSPEC_TOCSLOT))\n    (clobber (reg:P LR_REGNO))]\n   \"DEFAULT_ABI == ABI_AIX\"\n {\n@@ -10772,9 +10716,10 @@\n   [(set (match_operand 0 \"\" \"\")\n \t(call (mem:SI (match_operand:P 1 \"indirect_call_operand\" \"c,*l,X\"))\n \t      (match_operand:P 2 \"unspec_tls\" \"\")))\n-   (use (match_operand:P 3 \"memory_operand\" \"<ptrm>,<ptrm>,<ptrm>\"))\n+   (use (match_operand:SI 3 \"immediate_operand\" \"n,n,n\"))\n+   (use (match_operand:P 4 \"memory_operand\" \"<ptrm>,<ptrm>,<ptrm>\"))\n    (set (reg:P TOC_REGNUM)\n-\t(unspec:P [(match_operand:P 4 \"const_int_operand\" \"n,n,n\")]\n+\t(unspec:P [(match_operand:P 5 \"const_int_operand\" \"n,n,n\")]\n \t\t  UNSPEC_TOCSLOT))\n    (clobber (reg:P LR_REGNO))]\n   \"DEFAULT_ABI == ABI_AIX\"\n@@ -10790,12 +10735,13 @@\n \n ;; Call to indirect functions with the ELFv2 ABI.\n ;; Operand0 is the addresss of the function to call\n-;; Operand2 is the offset of the stack location holding the current TOC pointer\n+;; Operand3 is the offset of the stack location holding the current TOC pointer\n \n (define_insn \"*call_indirect_elfv2<mode>\"\n   [(call (mem:SI (match_operand:P 0 \"indirect_call_operand\" \"c,*l,X\"))\n \t (match_operand 1))\n-   (set (reg:P TOC_REGNUM) (unspec:P [(match_operand:P 2 \"const_int_operand\" \"n,n,n\")] UNSPEC_TOCSLOT))\n+   (use (match_operand:SI 2 \"immediate_operand\" \"n,n,n\"))\n+   (set (reg:P TOC_REGNUM) (unspec:P [(match_operand:P 3 \"const_int_operand\" \"n,n,n\")] UNSPEC_TOCSLOT))\n    (clobber (reg:P LR_REGNO))]\n   \"DEFAULT_ABI == ABI_ELFv2\"\n {\n@@ -10811,6 +10757,7 @@\n (define_insn \"*call_indirect_pcrel<mode>\"\n   [(call (mem:SI (match_operand:P 0 \"indirect_call_operand\" \"c,*l,X\"))\n \t (match_operand 1))\n+   (use (match_operand:SI 2 \"immediate_operand\" \"n,n,n\"))\n    (clobber (reg:P LR_REGNO))]\n   \"rs6000_pcrel_p (cfun)\"\n {\n@@ -10827,8 +10774,9 @@\n   [(set (match_operand 0 \"\" \"\")\n \t(call (mem:SI (match_operand:P 1 \"indirect_call_operand\" \"c,*l,X\"))\n \t      (match_operand:P 2 \"unspec_tls\" \"\")))\n+   (use (match_operand:SI 3 \"immediate_operand\" \"n,n,n\"))\n    (set (reg:P TOC_REGNUM)\n-\t(unspec:P [(match_operand:P 3 \"const_int_operand\" \"n,n,n\")]\n+\t(unspec:P [(match_operand:P 4 \"const_int_operand\" \"n,n,n\")]\n \t\t  UNSPEC_TOCSLOT))\n    (clobber (reg:P LR_REGNO))]\n   \"DEFAULT_ABI == ABI_ELFv2\"\n@@ -10846,6 +10794,7 @@\n   [(set (match_operand 0 \"\" \"\")\n \t(call (mem:SI (match_operand:P 1 \"indirect_call_operand\" \"c,*l,X\"))\n \t      (match_operand:P 2 \"unspec_tls\" \"\")))\n+   (use (match_operand:SI 3 \"immediate_operand\" \"n,n,n\"))\n    (clobber (reg:P LR_REGNO))]\n   \"rs6000_pcrel_p (cfun)\"\n {"}]}