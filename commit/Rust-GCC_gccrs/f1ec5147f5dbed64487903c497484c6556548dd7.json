{"sha": "f1ec5147f5dbed64487903c497484c6556548dd7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjFlYzUxNDdmNWRiZWQ2NDQ4NzkwM2M0OTc0ODRjNjU1NjU0OGRkNw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2001-07-09T11:20:51Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2001-07-09T11:20:51Z"}, "message": "[multiple changes]\n\nMon Jul  9 06:41:07 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n\n\t* emit-rtl.c (adjust_address_nv, replace_equiv_address_nv): New fcns.\n\t(operand_subword): Use them.\n\t(change_address_1): Renamed from change_address; new arg VALIDATE.\n\t* expr.h: Reflect above changes; change_address now macro.\n\t* alias.c (canon_rtx): Use replace_equiv_address_nv instead of\n\tmaking MEM.\n\t* cselib.c (add_mem_for_addr): Likewise.\n\t* expr.c (protect_from_queue, emit_move_insn_1): Likewise.\n\t* regmove.c (try_apply_stack_adjustment): Likewise.\n\t* reload.c (push_reload, make_memloc): Likewise.\n\t* reload1.c (eliminate_regs): Likewise.\n\t* simplify-rtx.c (simplify_replace_rtx): Likewise.\n\t* caller-save.c (setup_save_areas): Use adjust_address_nv instead of\n\tadjust_addess.\n\t* combine.c (make_extraction, simplify_shift_const): Likewise.\n\t(gen_lowpart_for_combine): Likewise.\n\t* cse.c (gen_lowpart_if_possible): Likewise.\n\t* function.c (fixup_var_refs_1, purge_addressof_1): Likewise.\n\t* expr.c (expand_expr, case COMPONENT_REF): Likewise.\n\t* optabs.c (gen_move_insn): Likewise.\n\t* reload1.c (alter_reg): Likewise.\n\t* simplify-rtx.c (simplify_subreg): Likewise.\n\t* stmt.c (expand_anon_union_decl): Likewise.\n\t* recog.c (validate_replace_rtx_1): Likewise.\n\t(expr.h): Include.\n\t* Makefile.in (recog.o): Add $(EXPR_H).\n\t* explow.c (stabilize): Call replace_equiv_address.\n\t* expr.c (move_by_pieces_1, store_by_pieces_2): Likewise.\n\t* final.c (alter_subreg): OFFSET is HOST_WIDE_INT.\n\n2001-07-09  Bo Thorsen  <bo@suse.co.uk>\n\n\t* config/i386/unix.h (ASM_OUTPUT_MI_THUNK): Fix x86-64 vtable support.\n\n2001-07-09  Neil Booth  <neil@daikokuya.demon.co.uk>\n\n\t* final.c (output_addr_const): Use target opening and\n\tclosing parentheses.\n\t* target-def.h: Define TARGET_ASM_OPEN_PAREN, TARGET_ASM_CLOSE_PAREN\n\tdefaults, add to TARGET_ASM_OUT.\n\t* target.h (struct gcc_target): Add open_paren and close_paren.\n\t* doc/md.texi: Update.\n\t* doc/tm.texi: Document TARGET_ASM_FUNCTION_END_PROLOGUE,\n\tTARGET_ASM_FUNCTION_BEGIN_EPILOGUE, TARGET_ASM_OPEN_PAREN and\n\tTARGET_ASM_CLOSE_PAREN.\n\t* config/i386/i386.c (TARGET_ASM_OPEN_PAREN, TARGET_ASM_CLOSE_PAREN):\n\tOverride.\n\t* config/pdp11/pdp11.c (TARGET_ASM_OPEN_PAREN, TARGET_ASM_CLOSE_PAREN):\n\tOverride.\n\t* config/1750a/1750a.h (ASM_OPEN_PAREN, ASM_CLOSE_PAREN): Remove.\n\t* config/a29k/a29k.h: Similarly.\n\t* config/alpha/alpha.h: Similarly.\n\t* config/arc/arc.h: Similarly.\n\t* config/arm/aof.h: Similarly.\n\t* config/arm/aout.h: Similarly.\n\t* config/avr/avr.h: Similarly.\n\t* config/c4x/c4x.h: Similarly.\n\t* config/clipper/clipper.h: Similarly.\n\t* config/convex/convex.h: Similarly.\n\t* config/d30v/d30v.h: Similarly.\n\t* config/dsp16xx/dsp16xx.h: Similarly.\n\t* config/elxsi/elxsi.h: Similarly.\n\t* config/fr30/fr30.h: Similarly.\n\t* config/h8300/h8300.h: Similarly.\n\t* config/i370/i370.h: Similarly.\n\t* config/i386/i386.h: Similarly.\n\t* config/i860/i860.h: Similarly.\n\t* config/i960/i960.h: Similarly.\n\t* config/ia64/ia64.h: Similarly.\n\t* config/m32r/m32r.h: Similarly.\n\t* config/m68hc11/m68hc11.h: Similarly.\n\t* config/m68k/m68k.h: Similarly.\n\t* config/m88k/m88k.h: Similarly.\n\t* config/mcore/mcore.h: Similarly.\n\t* config/mips/mips.h: Similarly.\n\t* config/mn10200/mn10200.h: Similarly.\n\t* config/mn10300/mn10300.h: Similarly.\n\t* config/ns32k/ns32k.h: Similarly.\n\t* config/pa/pa.h: Similarly.\n\t* config/pdp11/pdp11.h: Similarly.\n\t* config/pj/pj.h: Similarly.\n\t* config/romp/romp.h: Similarly.\n\t* config/rs6000/rs6000.h: Similarly.\n\t* config/sh/sh.h: Similarly.\n\t* config/sparc/sparc.h: Similarly.\n\t* config/v850/v850.h: Similarly.\n\t* config/vax/vax.h: Similarly.\n\t* config/we32k/we32k.h: Similarly.\n\n2001-07-09  Joseph S. Myers  <jsm28@cam.ac.uk>\n\n\t* doc/c-tree.texi: Document representation of attributes.\n\n2001-07-08  Joseph S. Myers  <jsm28@cam.ac.uk>\n\n\t* doc/tm.texi: Update some places for the rename of target to\n\ttargetm.  Fix typo.\n\n2001-07-08  Joseph S. Myers  <jsm28@cam.ac.uk>\n\n\t* target.h (struct gcc_target): Add insert_attributes.\n\t* target-def.h (TARGET_INSERT_ATTRIBUTES): Define.\n\t(TARGET_INITIALIZER): Update.\n\t* tree.c, tree.h (default_insert_attributes): New function.\n\tUpdate comments on other default functions to refer to targetm,\n\tnot target.\n\t* doc/tm.texi (INSERT_ATTRIBUTES): Update to document\n\tTARGET_INSERT_ATTRIBUTES.\n\t(SET_DEFAULT_DECL_ATTRIBUTES): Remove.\n\t* c-common.c (decl_attributes): Use targetm.insert_attributes.\n\tDon't use PRAGMA_INSERT_ATTRIBUTES.\n\t* Makefile.in (c-common.o): Depend on $(TARGET_H).\n\t* c-decl.c (start_decl, start_function): Don't call\n\tSET_DEFAULT_DECL_ATTRIBUTES.\n\t* config/c4x/c4x.h (SET_DEFAULT_DECL_ATTRIBUTES): Don't define.\n\t* config/c4x/c4x-protos.h (c4x_set_default_attributes): Don't\n\tdeclare.\n\t* config/c4x/c4x.c (TARGET_INSERT_ATTRIBUTES): Define.\n\t(c4x_check_attribute): Avoid modifying attribute list itself.\n\t(c4x_set_default_attributes): Rename to c4x_insert_attributes.\n\tMake static.\n\t* config/sh/sh.h (PRAGMA_INSERT_ATTRIBUTES): Don't define.\n\t* config/sh/sh-protos.h (sh_pragma_insert_attributes): Don't\n\tdeclare.\n\t* config/sh/sh.c (TARGET_INSERT_ATTRIBUTES): Define.\n\t(sh_pragma_insert_attributes): Rename to sh_insert_attributes.\n\tMake static.\n\t* config/v850/v850.h (SET_DEFAULT_DECL_ATTRIBUTES): Don't define.\n\t* config/v850/v850-protos.h (v850_set_default_decl_attr): Don't\n\tdeclare.\n\t* config/v850/v850.c (TARGET_INSERT_ATTRIBUTES): Define.\n\t(v850_set_default_decl_attr): Rename to v850_insert_attributes.\n\tAdjust parameters.  Make static.\n\n2001-07-08  Joseph S. Myers  <jsm28@cam.ac.uk>\n\n\t* c-common.c (decl_attributes): Only take a single attributes\n\tparameter.\n\t* c-common.h (decl_attributes): Update prototype.\n\t* c-decl.c (start_decl, start_function): Only take a single\n\tattributes parameter.  Update calls to decl_attributes.\n\t(finish_struct, finish_enum): Update calls to decl_attributes.\n\t(push_parm_decl): Expect unified list of attributes.  Update call\n\tto decl_attributes.\n\t* c-parse.in (fndef, initdcl, notype_initdcl, nested_function,\n\tnotype_nested_function, component_declarator,\n\tcomponent_notype_declarator, label): Update calls to\n\tdecl_attributes.\n\t(absdcl_maybe_attribute, parm, firstparm, myparm): Unify attribute\n\tlists that are passed to push_parm_decl.\n\t* c-tree.h (start_function, start_decl): Update prototypes.\n\t* config/sh/sh-protos.h, config/sh/sh.c\n\t(sh_pragma_insert_attributes): Only take a single attributes\n\tparameter.\n\t* config/sh/sh.h (PRAGMA_INSERT_ATTRIBUTES): Likewise.\n\t* doc/tm.texi (INSERT_ATTRIBUTES): Update.\n\t* objc/objc-act.c (define_decl, generate_objc_symtab_decl,\n\tbuild_module_descriptor, generate_static_references,\n\tgenerate_strings, build_selector_translation_table,\n\tgenerate_descriptor_table, generate_protocols,\n\tgenerate_ivars_list, generate_dispatch_table,\n\tgenerate_protocol_list, generate_category,\n\tgenerate_shared_structures, really_start_method, add_objc_decls,\n\tgenerate_classref_translation_entry): Update calls to start_decl\n\tand start_function.\n\t(build_tmp_function_decl, start_method_def): Unify attribute lists\n\tthat are passed to push_parm_decl.\n\n2001-07-08  Neil Booth  <neil@daikokuya.demon.co.uk>\n\n\t* final.c (no_asm_to_stream): New.\n\t(final_scan_insn): Use target structures for prologue ends\n\tand epilogue starts.\n\t* output.h (no_asm_to_stream): New.\n\t* target-def.h (TARGET_ASM_FUNCTION_END_PROLOGUE,\n\tTARGET_ASM_FUNCTION_BEGIN_EPILOGUE): New.\n\t(TARGET_ASM_OUT): Update.\n\t* target.h (struct gcc_target): New members function_end_prologue\n\tand function_begin_epilogue.\n\t* config/1750/1750.h (ASM_OUTPUT_FUNNAM): Delete as unused.\n\t* config/alpha/alpha-protos.h (output_end_prologue): Delete.\n\t* config/alpha/alpha.c (output_end_prologue): Rename to\n\talpha_output_function_end_prologue.  Use in target struct\n\tand make static.\n\t* config/alpha/alpha.h (FUNCTION_END_PROLOGUE): Delete.\n\t* config/ia64/ia64-protos.h (ia64_output_end_prologue): Delete.\n\t* config/ia64/ia64.c (ia64_output_end_prologue): Rename to\n\tia64_output_function_end_prologue.  Use in target struct\n\tand make static.\n\t(ia64_function_prologue, ia64_funciton_epilogue): Rename\n\tmistyped prototypes.\n\t* config/ia64/ia64.h (FUNCTION_END_PROLOGUE): Delete.\n\t* config/m88k/m88k-protos.h (m88k_end_prologue, m88k_begin_epilogue):\n\tDelete.\n\t* config/m88k/m88k.c (m88k_end_prologue, m88k_begin_epilogue): Rename\n\tan use in target struct, make static.\n\t* config/ia64/ia64.h (FUNCTION_END_PROLOGUE, FUNCTION_BEGIN_EPILOGUE):\n\tDelete.\n\n2001-07-08  Richard Henderson  <rth@redhat.com>\n\n\t* stmt.c (emit_case_nodes): Convert modes properly in low+high test.\n\n2001-07-08  Richard Henderson  <rth@redhat.com>\n\n\t* config/i386/i386.md: Remove constraints strings from define_split\n\tand define_peephole2 patterns.\n\t(eh_return_si, eh_return_di): Split eh_return_1 for modes.\n\t(eh_return): Use them.\n\n2001-07-08  Richard Henderson  <rth@redhat.com>\n\n\t* doc/tm.texi (Exception Handling): New subnode of Stack and Calling.\n\tDocument MD_FALLBACK_FRAME_STATE_FOR.\n\n2001-07-07  Stephane Carrez  <Stephane.Carrez@worldnet.fr>\n\n\t* config/m68hc11/m68hc11.c (m68hc11_initial_elimination_offset):\n\tTake into account m68hc11_sp_correction for FRAME_POINTER_REGNUM\n\telimination.\n\t* config/m68hc11/m68hc11.h (STARTING_FRAME_OFFSET): Use 0.\n\n2001-07-07  Nick Clifton  <nickc@cambridge.redhat.com>\n\n\t* config/ia64/sysv4.h (ASM_OUTPUT_LABELREF): Append # to end\n\tof the label inside NAME as opposed to just the end of NAME.\n\n2001-07-07  Neil Booth  <neil@daikokuya.demon.co.uk>\n\n\t* config/alpha/alpha-protos.h (vms_valid_decl_attribute_p): Delete.\n\t* config/alpha/alpha.c (alpha_init_machine_status,\n\talpha_mark_machine_status, alpha_free_machine_status): Delete.\n\t(TARGET_VALID_DECL_ATTRIBUTE): Define for VMS.\n\t(vms_valid_decl_attribute_p): Make static, conditionally compile.\n\t* config/alpha/alpha.h (VALID_MACHINE_DECL_ATTRIBUTE): Delete.\n\n2001-07-06  Stan Shebs  <shebs@apple.com>\n\n\t* target.h (targetm): Rename global from \"target\", so as not to\n\tconflict with local variables.\n\t* c-decl.c: Ditto.\n\t* c-typeck.c: Ditto.\n\t* final.c: Ditto.\n\t* tree.c: Ditto.\n\t* cp/decl.c: Ditto.\n\t* cp/decl2.c: Ditto.\n\t* cp/typeck.c: Ditto.\n\t* 1750a/1750a.c: Ditto.\n\t* a29k/a29k.c: Ditto.\n\t* arc/arc.c: Ditto.\n\t* arm/arm.c: Ditto.\n\t* avr/avr.c: Ditto.\n\t* clipper/clipper.c: Ditto.\n\t* convex/convex.c: Ditto.\n\t* d30v/d30v.c: Ditto.\n\t* dsp16xx/dsp16xx.c: Ditto.\n\t* elxsi/elxsi.c: Ditto.\n\t* fr30/fr30.c: Ditto.\n\t* h8300/h8300.c: Ditto.\n\t* i370/i370.c: Ditto.\n\t* i386/i386.c: Ditto.\n\t* i860/i860.c: Ditto.\n\t* i960/i960.c: Ditto.\n\t* ia64/ia64.c: Ditto.\n\t* m32r/m32r.c: Ditto.\n\t* m68hc11/m68hc11.c: Ditto.\n\t* m68k/m68k.c: Ditto.\n\t* m88k/m88k.c: Ditto.\n\t* mips/mips.c: Ditto.\n\t* ns32k/ns32k.c: Ditto.\n\t* pa/pa.c: Ditto.\n\t* pdp11/pdp11.c: Ditto.\n\t* romp/romp.c: Ditto.\n\t* rs6000/rs6000.c: Ditto.\n\t* sh/sh.c: Ditto.\n\t* sparc/sparc.c: Ditto.\n\t* vax/vax.c: Ditto.\n\t* we32k/we32k.c: Ditto.\n\t* doc/tm.texi: Update the manual to match.\n\n2001-07-06  Richard Henderson  <rth@redhat.com>\n\n\t* except.h (MUST_USE_SJLJ_EXCEPTIONS): Examine the value of\n\tDWARF2_UNWIND_INFO not just whether it is defined.\n\n2001-07-06  Diego Novillo  <dnovillo@redhat.com>\n\n\t* combine.c (combine_simplify_rtx): Also recompute 'mode' if the\n\tcall to simplify_binary_operation returns a new pattern.\n\n2001-07-06  Roman Lechtchinsky  <rl@cs.tu-berlin.de>\n\n\t* glimits.h (__SHRT_MAX__): New.\n\t(SHRT_MIN, USHRT_MAX): Define in terms of SHRT_MAX.\n\t(SHRT_MAX): Define in terms of __SHRT_MAX__.\n\n2001-07-06  Jan van Male  <jan.vanmale@fenk.wau.nl>\n\n\t* alias.c (base_alias_check): Cast GET_MODE_UNIT_SIZE to int to\n\tavoid warnings.\n\n2001-07-06  Richard Henderson  <rth@redhat.com>\n\n\t* bitmap.c (bitmap_release_memory): Move adjacent to the\n\tallocation functions.\n\t(bitmap_first_set_bit, bitmap_last_set_bit): Streamline knowing\n\tthe implementation.  Binary search for the set bit.\n\t(bitmap_union_of_diff): Allocate the temporary on the stack\n\tinstead of using xmalloc.\n\n2001-07-06  Richard Henderson  <rth@redhat.com>\n\n\t* genrecog.c (validate_pattern): Warn for constraints in\n\tdefine_{expand,split,peephole2}.  Remove strict_low_part\n\tbefore looking up match_dup.\n\n2001-07-06  DJ Delorie  <dj@redhat.com>\n\n\t* doc/gcc.texi (Makefile): Rename to be a more general purpose\n\tchapter about various build hints and history.  Add section\n\ttalking about the various types of native and cross builds.\n\n2001-07-06  Neil Booth  <neil@daikokuya.demon.co.uk>\n\n\t* Makefile.in (final.o): Depend on target.h.\n\t* final.c: Include target.h.\n\t(default_function_pro_epilogue): New.\n\t(final_start_function): Use target structure for function prologues.\n\t(final_end_function): Use target structure for function epilogues.\n\t* fold-const.c (real_hex_to_f): Constify s and p.\n\t* output.h (default_function_pro_epilogue): New.\n\t* real.h (real_hex_to_f): Update prototype.\n\t* target-def.h (TARGET_ASM_FUNCTION_PROLOGUE,\n\tTARGET_ASM_FUNCTION_EPILOGUE, TARGET_ASM_OUT): New.\n\t(TARGET_INITIALIZER): Update.\n\t* target.h (gcc_target): Add struct asm_out.\n\t* doc/tm.texi: Update.\n\nconfig:\n\tUpdate each arch to use TARGET_ASM_FUNCTION_PROLOGUE and\n\tTARGET_ASM_FUNCTION_EPILOGUE.  Move macro code to functions\n\tin cpu/cpu.c, or rename old functions consistently.  Take\n\ta HOST_WIDE INT not an int as the SIZE parameter.  Remove now\n\tredundant macros and prototypes.  Make new functions static.\n\n\t* 1750a/1750a.c: Similarly.\n\t* 1750a/1750a.h: Similarly.\n\t* a29k/a29k-protos.h: Similarly.\n\t* a29k/a29k.c: Similarly.\n\t* a29k/a29k.h: Similarly.\n\t* arc/arc-protos.h: Similarly.\n\t* arc/arc.c: Similarly.\n\t* arc/arc.h: Similarly.\n\t* arm/arm-protos.h: Similarly.\n\t* arm/arm.c: Similarly.\n\t* arm/arm.h: Similarly.\n\t* avr/avr-protos.h: Similarly.\n\t* avr/avr.c: Similarly.\n\t* avr/avr.h: Similarly.\n\t* clipper/clipper-protos.h: Similarly.\n\t* clipper/clipper.c: Similarly.\n\t* clipper/clipper.h: Similarly.\n\t* convex/convex.c: Similarly.\n\t* convex/convex.h: Similarly.\n\t* d30v/d30v-protos.h: Similarly.\n\t* d30v/d30v.c: Similarly.\n\t* d30v/d30v.h: Similarly.\n\t* d30v/d30v.md: Similarly.\n\t* dsp16xx/dsp16xx-protos.h: Similarly.\n\t* dsp16xx/dsp16xx.c: Similarly.\n\t* dsp16xx/dsp16xx.h: Similarly.\n\t* elxsi/elxsi.c: Similarly.\n\t* elxsi/elxsi.h: Similarly.\n\t* fr30/fr30.c: Similarly.\n\t* fr30/fr30.md: Similarly.\n\t* h8300/h8300-protos.h: Similarly.\n\t* h8300/h8300.c: Similarly.\n\t* h8300/h8300.h: Similarly.\n\t* i370/i370-protos.h: Similarly.\n\t* i370/i370.c: Similarly.\n\t* i370/i370.h: Similarly.\n\t* i386/i386.c: Similarly.\n\t* i386/osf1elf.h: Similarly.\n\t* i386/osfrose.h: Similarly.\n\t* i860/i860-protos.h: Similarly.\n\t* i860/i860.c: Similarly.\n\t* i860/i860.h: Similarly.\n\t* i960/i960-protos.h: Similarly.\n\t* i960/i960.c: Similarly.\n\t* i960/i960.h: Similarly.\n\t* ia64/ia64-protos.h: Similarly.\n\t* ia64/ia64.c: Similarly.\n\t* ia64/ia64.h: Similarly.\n\t* m32r/m32r-protos.h: Similarly.\n\t* m32r/m32r.c: Similarly.\n\t* m32r/m32r.h: Similarly.\n\t* m68hc11/m68hc11-protos.h: Similarly.\n\t* m68hc11/m68hc11.c: Similarly.\n\t* m68hc11/m68hc11.h: Similarly.\n\t* m68k/crds.h: Similarly.\n\t* m68k/dpx2.h: Similarly.\n\t* m68k/m68k-protos.h: Similarly.\n\t* m68k/m68k.c: Similarly.\n\t* m68k/m68k.h: Similarly.\n\t* m68k/news.h: Similarly.\n\t* m88k/m88k-protos.h: Similarly.\n\t* m88k/m88k.c: Similarly.\n\t* m88k/m88k.h: Similarly.\n\t* mips/mips-protos.h: Similarly.\n\t* mips/mips.c: Similarly.\n\t* mips/mips.h: Similarly.\n\t* ns32k/merlin.h: Similarly.\n\t* ns32k/ns32k.c: Similarly.\n\t* ns32k/ns32k.h: Similarly.\n\t* ns32k/tek6000.h: Similarly.\n\t* pa/pa-protos.h: Similarly.\n\t* pa/pa.c: Similarly.\n\t* pa/pa.h: Similarly.\n\t* pdp11/2bsd.h: Similarly.\n\t* pdp11/pdp11-protos.h: Similarly.\n\t* pdp11/pdp11.c: Similarly.\n\t* pdp11/pdp11.h: Similarly.\n\t* romp/romp-protos.h: Similarly.\n\t* romp/romp.c: Similarly.\n\t* romp/romp.h: Similarly.\n\t* rs6000/rs6000-protos.h: Similarly.\n\t* rs6000/rs6000.c: Similarly.\n\t* rs6000/rs6000.h: Similarly.\n\t* rs6000/sysv4.h: Similarly.\n\t* sh/sh-protos.h: Similarly.\n\t* sh/sh.c: Similarly.\n\t* sh/sh.h: Similarly.\n\t* sparc/sparc-protos.h: Similarly.\n\t* sparc/sparc.c: Similarly.\n\t* sparc/sparc.h: Similarly.\n\t* vax/vax.c: Similarly.\n\t* vax/vax.h: Similarly.\n\t* vax/vms.h: Similarly.\n\t* we32k/we32k.c: Similarly.\n\t* we32k/we32k.h: Similarly.\n\nFri Jul  6 11:47:59 2001  Jeffrey A Law  (law@cygnus.com)\n\n\t* basic-block.h (first_insn_after_basic_block_note): Declare.\n\t* flow.c (first_insn_after_basic_block_note): Define.  Moved\n\tfrom...\n\t* ssa.c (first_insn_after_basic_block_note): Remove.\n\t* ssa-dce.c (find_inherently_necessary): Consider BARRIERs\n\tnecessary.\n\t(ssa_eliminate_dead_code): Properly update the CFG and PHI\n\tnodes when we find a dead conditional branch.  Insert BARRIERs\n\tafter any blocks with no successors, but which do not have\n\tany BARRIERs.\n\n2001-07-06  Zack Weinberg  <zackw@stanford.edu>\n\n\t* varray.c (varray_check_failed): Use internal_error.\n\n2001-07-05  Andrew Haley  <aph@redhat.com>\n\n\t* Makefile.in (LIB2_DIVMOD_FUNCS): New.\n\t(LIB2FUNCS): Move divmod functions to LIB2_DIVMOD_FUNCS.\n\t* mklibgcc.in: Compile LIB2_DIVMOD_FUNCS.\n\n2001-07-02  Jason Merrill  <jason_merrill@redhat.com>\n\n\t* dwarf2out.c (mem_loc_descriptor): Only look through a constant pool\n\treference if the target constant is also a SYMBOL_REF.\n\n2001-07-05  Eric Christopher  <echristo@redhat.com>\n\n\t* config/mips/mips.h (MASK_MIPS3900): Remove.\n\t(MASK_MIPS16,MASK_NO_CHECK_ZERO_DIV,MASK_CHECK_RANGE_DIV,\n\tMASK_UNINIT_CONST_IN_RODATA): Change for 3900 mask removal.\n\t(TARGET_MIPS3900): Change to use mips_arch.\n\t(TARGET_MIPS4000): New.\n\t(TARGET_MIPS4100): New.\n\t(TARGET_MIPS4300): New.\n\t(TARGET_SWITCHES): Change 3900 and 4650 options to NULL.\n\t(SUBTARGET_TARGET_OPTIONS): Add -march. Change help text\n\tfor -mipsX.\n\t(GENERATE_BRANCHLIKELY): Move TARGET_MIPS3900.\n\t(ISA_HAS_BRANCHLIKELY): To here.\n\t(CC1_CPU_SPEC):\t New.\n\t(CC1_SPEC): Use here.  Remove 4650 and 3900 options.\n\t(mips_arch_string): Declare.\n\t(mips_arch): Declare.\n\t(TARGET_OPTIONS): Add -march and -mtune.\n\n\t* config/mips/mips.c (mips_arch_string): New.\n\t(mips_arch): New.\n\t(override_options): Handle -march for codegen and -mtune\n\tfor scheduling. Use mips_arch. Move tx39 target default here.\n\t(mips_parse_cpu): Move error message to override_options.\n\n\t* config/mips/r3900.h (TARGET_DEFAULT): Remove.\n\n\t* config/mips/mips.md: Use TARGET_MIPS4000 and TARGET_MIPS4300.\n\n\t* doc/invoke.texi (Option Summary): Add -march and -mtune entries.\n\t(MIPS Options): Ditto.\tChange mcpu entry to historical text.\n\n2001-07-05  H.J. Lu  (hjl@gnu.org)\n\n        * config/mips/mips.c (mips_parse_cpu): New function to parse\n        -march=*/-mcpu=*.\n\n2001-07-05  Jim Wilson  <wilson@redhat.com>\n\n\t* config/ia64/lib1funcs.asm: Revert 2001-07-02 change.\n\t* config/ia64/t-ia64: Likewise.\n\t(LIB1ASMFUNCS): Update comment.\n\n2001-07-05  David Edelsohn  <edelsohn@gnu.org>\n\n\t* doc/install.texi (Install GCC: Binaries): Fix typo.\n\n2001-07-04  Stephane Carrez  <Stephane.Carrez@worldnet.fr>\n\n\t* config/m68hc11/m68hc11.md (\"*ashlsi3\"): Operand 1 can be a memory\n\treference using the stack pointer, adjust it since we push Y\n\ttemporarily.\n\t(\"*ashrsi3\"): Likewise.\n\t(\"*lshrsi3\"): Likewise.\n\n2001-07-05  Stephane Carrez  <Stephane.Carrez@worldnet.fr>\n\n\t* config/m68hc11/m68hc11.h (RETURN_ADDR_RTX): Fix return address\n\twhen -fomit-frame-pointer is used.\n\n2001-07-05  Jeffrey Oldham  <oldham@codesourcery.com>\n\n\t* flow.c: Reverse Jan Hubicka's patch of 02July2001.\n\t(try_redirect_by_replacing_jump): Reverse updating properly the\n\tcount and frequency information.  Reverse removing cc0 setter.\n\t(forwarder_block_p): Reverse fixing for fallthru blocks.\n\n2001-07-05  DJ Delorie  <dj@redhat.com>\n\n\t* gcc.c (TARGET_OPTION_TRANSLATE_TABLE): New.\n\t(translate_options): If the above is defined, use it to map\n\tgiven options to new options.\n\t* doc/tm.texi: Document it.\n\n2001-07-05  Brad Lucier <lucier@math.purdue.edu>\n\t    Gerald Pfeifer  <pfeifer@dbai.tuwien.ac.at>\n\n\t* doc/invoke.texi (Optimize Options): Document that -fgcse may\n\tcause programs using computed gotos to run more slowly.\n\n2001-07-05  Rainer Orth  <ro@TechFak.Uni-Bielefeld.DE>\n\n\t* doc/install.texi (Specific): Markup, spelling and typo fixes.\n\tFixed sorting.\n\tConsistently require binutils 2.11.2, not prereleases.\n\t(Specific, decstation-*): Canonicalize as mips-dec-*.\n\t(Specific, i?86-*-sco3.2v5*): Remove make bootstrap requirement,\n\talways necessary.\n\t(Specific, m68k-altos): Removed reference to README.altos, deleted.\n\t(Specific, mips-*): Reword MIPS C compiler requirements.\n\t(Specific, powerpc*-*-*): New, mention --with-cpu once.\n\t(Specific, sunv5): Removed, obsolete.\n\n2001-07-05  Nathan Sidwell  <nathan@codesourcery.com>\n\n\t* dwarf2out.c (output_loc_list): Use an all ones mask for\n\t.text asm output and don't rely on long long\n\tliterals. Reformat some long lines.\n\n2001-07-05  Andreas Jaeger  <aj@suse.de>\n\n\t* doc/gcc.texi (GNU/Linux): Remove accidental re-add of GPL\n\tsection.\n\n2001-07-04  Daniel Berlin  <dan@cgsoftware.com>\n\n\t* dwarf2out.c (dwarf2out_define): Update comment.\n\t(dwarf2out_undef): Ditto.\n\t(dwarf2out_start_source_file): Ditto.\n\t(dwarf2out_end_source_file): Ditto.\n\t(dwarf2out_finish): Output DW_MACINFO_end_file for primary file,\n\tsince we never call the start/end debug hook for the primary file.\n\n2001-07-04  Kazu Hirata  <kazu@hxi.com>\n\n\t* config/h8300/h8300.c (get_shift_alg): Remove an extra operand\n\tfrom shll.\n\n2001-07-04  Nathan Sidwell  <nathan@codesourcery.com>\n\n\t* cppinit.c (remove_dup_dirs): Inform if a system include\n        directory is being reordered.\n\t* doc/invoke.texi (Directory Options): GCC warns if you hide a\n\tsystem include.\n\t* doc/cpp.texi (Search Paths): Likewise.\n\t* doc/gcc.texi (Interoperation): Remove information about\n\t-I/usr/include.\n\n2001-07-04  Nathan Sidwell  <nathan@codesourcery.com>\n\n\t* varray.h (VARRAY_TOP_GENERIC_PTR): Remove spurious parameter.\n\t(VARRAY_TOP_CHAR_PTR): Likewise.\n\n2001-07-04  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n\n\t* gcc.c (process_command): Don't assign elements of a const char*.\n\nWed Jul  4 13:40:02 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n\n\t* emit-rtl.c (change_address): Don't abort if invalid address while\n\treload is in progress.\n\n2001-07-04  Daniel Berlin  <dan@cgsoftware.com>\n\n\t* c-lex.c (cb_file_change): Pass line number to\n\tdebug_start_source_file.\n\t(cb_undefine): Pass correct line number to debug_undef.\n\n\t* toplev.c (debug_start_source_file): Add line number to\n\tparameters. Pass it along to dwarf2out_start_source_file.\n\t(decode_g_option): Stop resetting debug level back to normal when\n\twe change debug formats, unless the current level is\n\tnone. (Before, -g3 -gdwarf-2 would use debug level 2, rather than\n\t3).\n\n\t* toplev.h (debug_start_source_file): Add line number to\n\tparameters.\n\n\t* dwarf2out.h (dwarf2out_start_source_file): Add line number to\n\tparameters.\n\n\t* dwarf2out.c (dwarf2out_start_source_file): Add line number to\n\tparameters.\n\tOutput debug_macinfo data for starting file if requested.\n\t(dwarf2out_end_source_file): Output debug_macinfo data for ending\n\tfile if requested.\n\t(dwarf2out_define): Output debug_macinfo data for defining a macro\n\tif requested.\n\t(dwarf2out_undef): Output debug_macinfo data for undefining a\n\tmacro if requested.\n\t(DEBUG_MACINFO_SECTION): New. DWARF2 macro info section name.\n\t(DEBUG_MACINFO_SECTION_LABEL): New. DWARF2 macro info section label.\n\t(macinfo_section_label): New. DWARF2 macro info section label.\n\t(dwarf2out_init): If we want macro info, output the start label\n\tfor the section.\n\t(dwarf2out_finish): If we want macro info, add a DW_AT_macro_info\n\tattribute to the compilation unit die pointing to the macro info.\n\n2001-07-04  Daniel Berlin  <dan@cgsoftware.com>\n\n\t* dwarf2out.c (new_loc_list): Move to inside #ifdef\n\tDWARF2_DEBUGGING_INFO.\n\t(add_loc_descr_to_loc_list): Ditto.\n\t(output_loc_list): Ditto.\n\tAlso, fix thinko in curr not being initialized.\n\t(gen_internal_sym): Ditto.\n\nWed Jul  4 13:40:02 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n\n\t* emit-rtl.c (replace_equiv_address): New function.\n\t* expr.h (replace_equiv_address): New declaration.\n\t* explow.c (validize_mem): Call it instead of change_address and\n\talso call if -fforce-addr and address is constant.\n\t* expr.c: Replace more calls to change_address with adjust_address\n\tand/or replace_equiv_address or to validize_mem.\n\t* function.c, regmove.c, config/alpha/alpha.c: Likewise.\n\t* config/arm/arm.md, config/clipper/clipper.md: Likewise.\n\t* config/dsp16xx/dsp16xx.md, config/fr30/fr30.c: Likewise.\n\t* config/i370/i370.md, config/i860/i860.md: Likewise.\n\t* config/i960/i960.md, config/mips/mips.c: Likewise.\n\t* config/mips/mips.md, config/pa/pa.md: Likewise.\n\t* config/pdp11/pdp11.md, config/rs6000/rs6000.c: Likewise.\n\t* config/rs6000/rs6000.md, config/sh/sh.md: Likewise.\n\n2001-07-04  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n\n\t* bitmap.c (bitmap_union_of_diff): Don't use BITMAP_ALLOCA.\n\n\t* bitmap.h (BITMAP_ALLOCA): Don't pass alloca as an argument to a\n\tfunction.\n\n2001-07-04  Joseph S. Myers  <jsm28@cam.ac.uk>\n\n\t* doc/include: New directory.\n\t* doc/fdl.texi: Move to doc/include/fdl.texi.\n\t* doc/texinfo.tex: Move to doc/include/texinfo.tex.\n\t* doc/include/funding.texi, doc/include/gpl.texi: New files.\n\t* doc/gcc.texi: Use funding.texi and gpl.texi.\n\t* Makefile.in ($(docdir)/cpp.info, $(docdir)/gcc.info,\n\t$(docdir)/cppinternals.info, cpp.dvi. gcc.dvi. cppinternals.dvi):\n\tUpdate dependencies and use -I $(docdir)/include.\n\n2001-07-04  Anthony Green  <green@redhat.com>\n\n\t* config/v850/t-v850 (v850-c.o): Add missing dependencies.\n\n2001-07-04  Gerald Pfeifer  <pfeifer@dbai.tuwien.ac.at>\n\n\t* doc/install.texi (sparc64-*-*): Remove garbage.\n\nWed Jul  4 09:07:44 2001  Jan van Male  <jan.vanmale@fenk.wau.nl>\n\n\t* i386.c (ix86_expand_builtin, case IX86_BUILTIN_SETPS):\n\tFix typo in last change to use adjust_address.\n\n2001-07-04  Gerald Pfeifer  <pfeifer@dbai.tuwien.ac.at>\n\n\t* doc/install.texi (Specific): Update information for *-*-solaris*.\n\nTue Jul  3 22:33:15 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n\n\t* explow.c (plus_constant_wide): Reinitialize Y for restart.\n\n2001-07-03  Stan Shebs  <shebs@apple.com>\n\n\t* config/darwin.h (SECTION_FUNCTION): Remove WAS_TEXT argument, remove\n\tcase for flag_no_mach_text_sections.\n\t(EXTRA_SECTION_FUNCTIONS): Remove arg from uses of SECTION_FUNCTION.\n\t* config/darwin.c (flag_no_mach_text_sections): Remove.\n\t* config/darwin-protos.h (darwin_init_pragma): Remove decl.\n\nTue Jul  3 15:35:52 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n\n\t* explow.c (plus_constant_wide, case PLUS): Call find_constant_term\n\tand avoid checking for constant as first operand.\n\t* recog.c (find_constant_term_loc): No longer static.\n\t(adj_offettable_operand): Delete.\n\t* rtl.h (adj_offsettable_operand): Delete declaration.\n\t(find_constant_term): Add declaration.\n\t* caller-save.c: Replace calls to adj_offsettable_operand with calls\n\tto adjust_address.\n\t* config/arm/arm.c, config/c4x/c4x.c: Likewise.\n\t* config/clipper/clipper.md, config/h8300/h8300.c: Likewise.\n\t* config/i386/i386.c, config/i386/i386.md: Likewise.\n\t* config/i860/i860.c, config/i960/i960.c: Likewise.\n\t* config/i960/i960.md, config/m68hc11/m68hc11.c: Likewise.\n\t* config/m68k/m68k.c, config/m68k/m68k.md: Likewise.\n\t* config/m88k/m88k.md, config/mcore/mcore.c: Likewise.\n\t* config/mips/mips.c, config/mips/mips.md: Likewise.\n\t* config/mn10200/mn10200.c, config/mn10300/mn10300.c: Likewise.\n\t* config/ns32k/ns32k.c, config/ns32k/ns32k.md: Likewise.\n\t* config/pa/pa.c, config/pdp11/pdp11.c: Likewise.\n\t* config/pdp11/pdp11.md, config/sh/sh.c, config/v850/v850.c: Likewise.\n\t* config/vax/vax.md, config/ns32k/ns32k.c: Likewise.\n\t* config/ns32k/ns32k.md: Likewise.\n\n2001-07-03  Zack Weinberg  <zackw@stanford.edu>\n\n\t* rtl.c (copy_rtx): Handle 'T' format letter.\n\t* gensupport.c (collect_insn_data): Likewise.\n\t* print-rtl.c (print_rtx): Print 'T' slots like 's'.\n\n2001-07-03  Nick Clifton  <nickc@cambridge.redhat.com>\n\n\t* doc/invoke.texi (Directory Options): Specifiy range for <N> in\n\t-B option.  Use 'dir' not 'foo' as example directory name.\n\n2001-07-03  Rainer Orth  <ro@TechFak.Uni-Bielefeld.DE>\n\n\t* config/i386/sol2.h (ASM_PREFERRED_EH_DATA_FORMAT): Define.\n\tFixes PRs bootstrap/3067, bootstrap/3249, bootstrap/3275.\n\n2001-07-03  Joseph S. Myers  <jsm28@cam.ac.uk>\n\n\t* doc/cppinternals.texi: Improve formatting and logical markup.\n\n2001-07-03  Andreas Jaeger  <aj@suse.de>\n\n\t* Makefile.in (insn-recog.o): Add dependency on reload.h.\n\n\t* genrecog.c (write_header): Include reload.h for prototypes in\n\tinsn-recog.c.\n\n2001-07-03  Neil Booth  <neil@daikokuya.demon.co.uk>\n\nconfig:\n\t* i386/cygwin.h (VALID_MACHINE_DECL_ATTRIBUTE,\n\tVALID_MACHINE_TYPE_ATTRIBUTE): Remove.\n\t* i386/i386-protos.h (i386_pe_valid_decl_attribute_p,\n\ti386_pe_valid_type_attribute_p): Add.\n\t* i386/i386.c (TARGET_INITIALIZER): Override for cygwin targets.\n\t* i386/winnt.c (i386_valid_decl_attribute_p): Return directly.\n\nMon Jul  2 21:52:19 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n\n\t* explow.c (plus_constant_wide, case LO_SUM): New case.\n\t(plus_constant_for_output_wide): Delete.\n\t* rtl.h (plus_constant_for_output): Delete.\n\t* alias.c (canon_rtx, init_alias_analysis): Call plus_constant\n\tinstead of plus_constant_for_output.\n\t* recog.c (offsettable_address_p, adj_offsettable_operand): Likewise.\n\t* config/darwin.c, config/arm/arm.c, config/m68k/m68k.c: Likewise.\n\t* config/m88k/m88k.c, config/mips/mips.c, config/pa/pa.c: Likewise.\n\t* config/rs6000/rs6000.c, config/sparc/sparc.c: Likewise.\n\t* config/sparc/sparc.md: Likewise.\n\tConvert some change_address calls to adjust_address.\n\n2001-07-03  Joseph S. Myers  <jsm28@cam.ac.uk>\n\n\t* doc/extend.texi, doc/gcc.texi, doc/invoke.texi, doc/md.texi,\n\tdoc/rtl.texi, doc/tm.texi: Improve formatting.  Improve\n\tdocumentation of -std and -Wwrite-strings.\n\n2001-07-02  Geoffrey Keating  <geoffk@redhat.com>\n\n\t* cse.c (canon_hash): Don't register registers in very small\n\tregister classes, as extending their lifetime might cause\n\treload to fail.\n\nMon Jul  2 23:14:00 CEST 2001  Jan Hubicka  <jh@suse.cz>\n\n\t* flow.c (try_redirect_by_replacing_jump): Remove cc0 setter.\n\n\t* flow.c (forwarder_block_p): Fix for fallthru blocks.\n\t(try_redirect_by_replacing_jump): Update properly the count\n\tand frequency information.\n\nMon Jul  2 14:20:13 2001  Jeffrey A Law  (law@cygnus.com)\n\n\t* toplev.c (dump_file_index): Move SSA dumps just after first\n\tjump dump.\n\t(dump_file): Corresponding changes.\n\t(rest_of_compilation): Move SSA path to just after the first\n\tjump pass.\n\t* doc/gcc.texi (Passes): Update due to movement of SSA path.\n\t* doc/invoke.texi: Update dump file #s as they were completely\n\tout of date with reality.\n\n2001-07-02  Geoffrey Keating  <geoffk@redhat.com>\n\n\t* doc/tm.texi (Frame Layout): Document STACK_PUSH_CODE.\n\n\t* expr.c (emit_move_insn_1): Deal with non-default\n\tSTACK_PUSH_CODE.\n\n\t* expr.c (emit_single_push_insn): Fix warning.\n\n2001-07-02  Toshiyasu Morita  <toshiyasu.morita@hsa.hitachi.com>\n\n\t* expr.c (emit_move_insn_1): Avoid modifying\n\tcfun->expr->x_stack_pointer when PUSH_ROUNDING is defined.\n\nMon Jul  2 15:33:31 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n\n\t* emit-rtl.c (adjust_address): New function.\n\t* expr.h (adjust_address): Add declaration.\n\t* builtins.c: Replace some calls to change_address with calls to it\n\tor to validize_mem.\n\t* caller-save.c, dwarf2out.c, except.c, expmed.c, expr.c: Likewise.\n\t* function.c, config/a29k/a29k.md, config/alpha/alpha.c: Likewise.\n\t* config/arm/arm.c, config/convex/convex.c: Likewise.\n\t* config/dsp16xx/dsp16xx.md, config/fr30/fr30.c: Likewise.\n\t* config/i386/i386.c, config/i386/i386.md: Likewise.\n\t* config/ia64/ia64.c, config/ia64/ia64.md: Likewise.\n\t* config/m32r/m32r.c, config/m68k/m68k.md: Likewise.\n\t* config/m88k/m88k.c, config/mips/mips.md: Likewise.\n\t* config/ns32k/ns32k.c, config/rs6000/rs6000.c: Likewise.\n\t* config/sh/sh.c, config/sparc/sparc.md: Likewise.\n\n2001-07-02  Jim Wilson  <wilson@redhat.com>\n\n\t* config/ia64/ia64.h: Delete obsolete lib1funcs.asm comment.\n\n2001-07-02  Steve Ellcey  <sje@cup.hp.com>\n\n        * config/ia64/t-ia64: Change LIB1ASMFUNCS to use single underscore.\n        * config/ia64/lib1funcs.asm: Change macro names to match t-ia64.\n\n2001-07-02  Zack Weinberg  <zackw@stanford.edu>\n\n\t* cppinit.c (lang_defaults): New table.\n\t(set_lang): Just read from lang_defaults into the live options\n\tstructure.\n\n2001-07-02  Zack Weinberg  <zackw@stanford.edu>\n\n\t* Makefile.in (doc): Depend on $(GENERATED_MANPAGES).\n\t* doc/.cvsignore: Add gcc.1, cpp.1, gcov.1.\n\t* doc/gcc.1, doc/cpp.1, doc/gcov.1: Removed.\n\n2001-07-02  Rainer Orth  <ro@TechFak.Uni-Bielefeld.DE>\n\n\t* doc/install.texi: Various spelling and markup fixes.\n\t(Installing GCC): Component specific installation instructions are\n\tgone.\n\tFix reference.\n\tWarn about removing old install dir in the presence of shared libs.\n\t(Configuration): Invoke with options target to match configure\n\t--help.\n\tConsistently refer to gas, gld pathnames.\n\tInvert --enable-multilib documentation.\n\tRemove references to old compiler versions.\n\nMon Jul  2 12:50:51 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n\n\t* flow.c (try_simplify_condjump): Fix typo in updating fallthru flags.\n\n2001-07-02  Rainer Orth  <ro@TechFak.Uni-Bielefeld.DE>\n\n\t* doc/install.texi (Specific, mips*-sgi-irix4): Split from IRIX 5\n\tsection.\n\t(Specific, mips*-sgi-irix5): Note IDO download.\n\tReworded MIPS C hints.\n\tUse GNU as instead of GAS.\n\tMarkup fixes.\n\tRemoved SGI Freeware reference, IRIX 6 only.\n\t(Specific, mips*-sgi-irix6): Removed ranlib caveats, obsolete.\n\tNote N64 library requirement/workaround.\n\tUpdate O32 hints.\n\tComplete list of structure passing bug victims.\n\n2001-07-02  Gerald Pfeifer  <pfeifer@dbai.tuwien.ac.at>\n\n\t* doc/install.texi: Remove CVS Id.\n\n2001-07-02  Andreas Jaeger  <aj@suse.de>\n\n\t* ssa-dce.c (note_inherently_necessary_set): Add unused attribute.\n\t(find_inherently_necessary): Remove unused variable.\n\n2001-07-02  Nathan Sidwell  <nathan@codesourcery.com>\n\n\t* c-common.h (TDI_inlined): New ast dump phase.\n\t(dump_flag_name): New function.\n\t* c-dump.c (dump_files): Add inlined phase.\n\t(dump_flag_name): Define.\n\t* doc/invoke.texi (-fdump-ast-inlined): Document.\n\nMon Jul  2 06:29:36 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n\n\t* stor-layout.c (layout_decl): Revert change to handling of alignment\n\tin packed types.\n\nSun Jul  1 11:53:52 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n\n\t* c-common.c (decl_attributes, case A_MODE): Don't call layout_decl\n\tfor FIELD_DECL.\n\n2001-07-01  Geoffrey Keating  <geoffk@redhat.com>\n\n\t* doc/tm.texi (FUNCTION_ARG): Document that the last call\n\tis special.\n\n2001-07-01  Nathan Sidwell  <nathan@codesourcery.com>\n\n\t* tlink.c (recompile_files): Remove COMPILER_PATH and\n\tLIBRARY_PATH from the environment.\n\n2001-07-01  Zack Weinberg  <zackw@stanford.edu>\n\n\t* c-common.h (enum rid): Add RID_FIRST_AT, RID_LAST_AT,\n\tRID_LAST_PQ.  Move RID_FIRST_PQ down with the other FIRST/LAST\n\tenumerators.\n\t(OBJC_IS_AT_KEYWORD, OBJC_IS_PQ_KEYWORD): New macros.\n\n\t* c-parse.in (OBJC_STRING): Kill.\n\t(objc_string): Decompose to [objc_string] '@' STRING.\n\t(reswords): Take the leading '@' off all the Objective C keywords.\n\t(objc_rid_sans_at): Kill.\n\t(init_reswords): Don't initialize it.\n\t(yylexname): Use OBJC_IS_AT_KEYWORD and OBJC_IS_PQ_KEYWORD.\n\t(_yylex): Kill reconsider label.  Look ahead one token after\n\tan '@'; if we get an identifier, check whether it's an\n\tObjective C @-keyword.  If so, return the keyword.  Otherwise,\n\tput back the token and return the '@' as a terminal.\n\n\t* cpplib.c (lex_macro_node): Remove unnecessary check for\n\tleading '@' on identifier.  Clarify control flow and commentary.\n\nSun Jul  1 11:53:52 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n\n\t* cse.c (new_label_ref): Variable deleted.\n\t(insert): Remove set of new_label_ref.\n\t(check_for_label_ref): New function.\n\t(cse_basic_block): Don't check new_label_ref; call check_for_label_ref.\n\nSee ChangeLog.5 for earlier changes.\n\nFrom-SVN: r43861", "tree": {"sha": "188de8d2dd6c3a5c47ac0281d962a85d69021008", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/188de8d2dd6c3a5c47ac0281d962a85d69021008"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f1ec5147f5dbed64487903c497484c6556548dd7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1ec5147f5dbed64487903c497484c6556548dd7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f1ec5147f5dbed64487903c497484c6556548dd7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1ec5147f5dbed64487903c497484c6556548dd7/comments", "author": null, "committer": null, "parents": [{"sha": "db42058b0b6754acd596020a42df0253d6fbe1fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db42058b0b6754acd596020a42df0253d6fbe1fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db42058b0b6754acd596020a42df0253d6fbe1fa"}], "stats": {"total": 358, "additions": 142, "deletions": 216}, "files": [{"sha": "0cffa257c46c3484c695433ac73e5b5633f89526", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1ec5147f5dbed64487903c497484c6556548dd7/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1ec5147f5dbed64487903c497484c6556548dd7/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=f1ec5147f5dbed64487903c497484c6556548dd7", "patch": "@@ -1520,8 +1520,8 @@ final.o : final.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TREE_H) flags.h intl.h \\\n    xcoffout.h toplev.h reload.h dwarfout.h dwarf2out.h sdbout.h \\\n    dbxout.h $(BASIC_BLOCK_H) $(TM_P_H) $(TARGET_H)\n recog.o : recog.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) function.h $(BASIC_BLOCK_H) \\\n-   $(REGS_H) $(RECOG_H) hard-reg-set.h flags.h insn-config.h $(INSN_ATTR_H) \\\n-   real.h toplev.h output.h reload.h $(TM_P_H)\n+   $(REGS_H) $(RECOG_H) $(EXPR_H) hard-reg-set.h flags.h insn-config.h \\\n+   $(INSN_ATTR_H) real.h toplev.h output.h reload.h $(TM_P_H)\n reg-stack.o : reg-stack.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TREE_H) $(RECOG_H) \\\n    $(REGS_H) hard-reg-set.h flags.h insn-config.h toplev.h reload.h \\\n    varray.h function.h $(TM_P_H)"}, {"sha": "3802e670fe1529faccf24f56b0acc61b782ee4d2", "filename": "gcc/alias.c", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1ec5147f5dbed64487903c497484c6556548dd7/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1ec5147f5dbed64487903c497484c6556548dd7/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=f1ec5147f5dbed64487903c497484c6556548dd7", "patch": "@@ -972,17 +972,8 @@ canon_rtx (x)\n      MEM alone, but need to return the canonicalized MEM with\n      all the flags with their original values.  */\n   else if (GET_CODE (x) == MEM)\n-    {\n-      rtx addr = canon_rtx (XEXP (x, 0));\n-\n-      if (addr != XEXP (x, 0))\n-\t{\n-\t  rtx new = gen_rtx_MEM (GET_MODE (x), addr);\n+    x = replace_equiv_address_nv (x, canon_rtx (XEXP (x, 0)));\n \n-\t  MEM_COPY_ATTRIBUTES (new, x);\n-\t  x = new;\n-\t}\n-    }\n   return x;\n }\n "}, {"sha": "ae888fb98093739a8926b9ce744a5a6cf1e98f36", "filename": "gcc/caller-save.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1ec5147f5dbed64487903c497484c6556548dd7/gcc%2Fcaller-save.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1ec5147f5dbed64487903c497484c6556548dd7/gcc%2Fcaller-save.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcaller-save.c?ref=f1ec5147f5dbed64487903c497484c6556548dd7", "patch": "@@ -332,8 +332,9 @@ setup_save_areas ()\n \t  /* This should not depend on WORDS_BIG_ENDIAN.\n \t     The order of words in regs is the same as in memory.  */\n \t  regno_save_mem[i + k][1]\n-\t    = adjust_address (regno_save_mem[i][j], regno_save_mode[i + k][1],\n-\t\t\t      k * UNITS_PER_WORD);\n+\t    = adjust_address_nv (regno_save_mem[i][j],\n+\t\t\t\t regno_save_mode[i + k][1],\n+\t\t\t\t k * UNITS_PER_WORD);\n       }\n \n   /* Now loop again and set the alias set of any save areas we made to"}, {"sha": "84e4935a20e888ab53e7141fa679e30e4786d3e4", "filename": "gcc/combine.c", "status": "modified", "additions": 10, "deletions": 21, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1ec5147f5dbed64487903c497484c6556548dd7/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1ec5147f5dbed64487903c497484c6556548dd7/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=f1ec5147f5dbed64487903c497484c6556548dd7", "patch": "@@ -5889,23 +5889,23 @@ make_extraction (mode, inner, pos, pos_rtx, len,\n \n       if (GET_CODE (inner) == MEM)\n \t{\n-\t  int offset;\n+\t  HOST_WIDE_INT offset;\n+\n \t  /* POS counts from lsb, but make OFFSET count in memory order.  */\n \t  if (BYTES_BIG_ENDIAN)\n \t    offset = (GET_MODE_BITSIZE (is_mode) - len - pos) / BITS_PER_UNIT;\n \t  else\n \t    offset = pos / BITS_PER_UNIT;\n \n-\t  new = gen_rtx_MEM (tmode, plus_constant (XEXP (inner, 0), offset));\n-\t  MEM_COPY_ATTRIBUTES (new, inner);\n+\t  new = adjust_address_nv (inner, tmode, offset);\n \t}\n       else if (GET_CODE (inner) == REG)\n \t{\n \t  /* We can't call gen_lowpart_for_combine here since we always want\n \t     a SUBREG and it would sometimes return a new hard register.  */\n \t  if (tmode != inner_mode)\n \t    {\n-\t      int final_word = pos / BITS_PER_WORD;\n+\t      HOST_WIDE_INT final_word = pos / BITS_PER_WORD;\n \n \t      if (WORDS_BIG_ENDIAN\n \t\t  && GET_MODE_SIZE (inner_mode) > UNITS_PER_WORD)\n@@ -6125,13 +6125,7 @@ make_extraction (mode, inner, pos, pos_rtx, len,\n \t\t  - GET_MODE_SIZE (wanted_inner_mode) - offset);\n \n       if (offset != 0 || inner_mode != wanted_inner_mode)\n-\t{\n-\t  rtx newmem = gen_rtx_MEM (wanted_inner_mode,\n-\t\t\t\t    plus_constant (XEXP (inner, 0), offset));\n-\n-\t  MEM_COPY_ATTRIBUTES (newmem, inner);\n-\t  inner = newmem;\n-\t}\n+\tinner = adjust_address_nv (inner, wanted_inner_mode, offset);\n     }\n \n   /* If INNER is not memory, we can always get it into the proper mode.  If we\n@@ -8976,14 +8970,10 @@ simplify_shift_const (x, code, result_mode, varop, input_count)\n \t      && (tmode = mode_for_size (GET_MODE_BITSIZE (mode) - count,\n \t\t\t\t\t MODE_INT, 1)) != BLKmode)\n \t    {\n-\t      if (BYTES_BIG_ENDIAN)\n-\t\tnew = gen_rtx_MEM (tmode, XEXP (varop, 0));\n-\t      else\n-\t\tnew = gen_rtx_MEM (tmode,\n-\t\t\t\t   plus_constant (XEXP (varop, 0),\n-\t\t\t\t\t\t  count / BITS_PER_UNIT));\n+\t      new = adjust_address_nv (varop, tmode,\n+\t\t\t\t       BYTES_BIG_ENDIAN ? 0\n+\t\t\t\t       : count / BITS_PER_UNIT);\n \n-\t      MEM_COPY_ATTRIBUTES (new, varop);\n \t      varop = gen_rtx_fmt_e (code == ASHIFTRT ? SIGN_EXTEND\n \t\t\t\t     : ZERO_EXTEND, mode, new);\n \t      count = 0;\n@@ -9749,9 +9739,8 @@ gen_lowpart_for_combine (mode, x)\n \t  offset -= (MIN (UNITS_PER_WORD, GET_MODE_SIZE (mode))\n \t\t     - MIN (UNITS_PER_WORD, GET_MODE_SIZE (GET_MODE (x))));\n \t}\n-      new = gen_rtx_MEM (mode, plus_constant (XEXP (x, 0), offset));\n-      MEM_COPY_ATTRIBUTES (new, x);\n-      return new;\n+\n+      return adjust_address_nv (x, mode, offset);\n     }\n \n   /* If X is a comparison operator, rewrite it in a new mode.  This"}, {"sha": "bc86cdc954c1ed0e63103c8d7b3b6f9dc32f45b1", "filename": "gcc/cse.c", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1ec5147f5dbed64487903c497484c6556548dd7/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1ec5147f5dbed64487903c497484c6556548dd7/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=f1ec5147f5dbed64487903c497484c6556548dd7", "patch": "@@ -4382,16 +4382,15 @@ gen_lowpart_if_possible (mode, x)\n \toffset = (MAX (GET_MODE_SIZE (GET_MODE (x)), UNITS_PER_WORD)\n \t\t  - MAX (GET_MODE_SIZE (mode), UNITS_PER_WORD));\n       if (BYTES_BIG_ENDIAN)\n-\t{\n-\t  /* Adjust the address so that the address-after-the-data is\n-\t     unchanged.  */\n-\t  offset -= (MIN (UNITS_PER_WORD, GET_MODE_SIZE (mode))\n-\t\t     - MIN (UNITS_PER_WORD, GET_MODE_SIZE (GET_MODE (x))));\n-\t}\n-      new = gen_rtx_MEM (mode, plus_constant (XEXP (x, 0), offset));\n+\t/* Adjust the address so that the address-after-the-data is\n+\t   unchanged.  */\n+\toffset -= (MIN (UNITS_PER_WORD, GET_MODE_SIZE (mode))\n+\t\t   - MIN (UNITS_PER_WORD, GET_MODE_SIZE (GET_MODE (x))));\n+\n+      new = adjust_address_nv (x, mode, offset);\n       if (! memory_address_p (mode, XEXP (new, 0)))\n \treturn 0;\n-      MEM_COPY_ATTRIBUTES (new, x);\n+\n       return new;\n     }\n   else"}, {"sha": "252d68eb6917b5ebcdcc33803e523051ac966368", "filename": "gcc/cselib.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1ec5147f5dbed64487903c497484c6556548dd7/gcc%2Fcselib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1ec5147f5dbed64487903c497484c6556548dd7/gcc%2Fcselib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.c?ref=f1ec5147f5dbed64487903c497484c6556548dd7", "patch": "@@ -706,7 +706,6 @@ add_mem_for_addr (addr_elt, mem_elt, x)\n      cselib_val *addr_elt, *mem_elt;\n      rtx x;\n {\n-  rtx new;\n   struct elt_loc_list *l;\n \n   /* Avoid duplicates.  */\n@@ -715,11 +714,10 @@ add_mem_for_addr (addr_elt, mem_elt, x)\n \t&& CSELIB_VAL_PTR (XEXP (l->loc, 0)) == addr_elt)\n       return;\n \n-  new = gen_rtx_MEM (GET_MODE (x), addr_elt->u.val_rtx);\n-  MEM_COPY_ATTRIBUTES (new, x);\n-\n   addr_elt->addr_list = new_elt_list (addr_elt->addr_list, mem_elt);\n-  mem_elt->locs = new_elt_loc_list (mem_elt->locs, new);\n+  mem_elt->locs\n+    = new_elt_loc_list (mem_elt->locs,\n+\t\t\treplace_equiv_address_nv (x, addr_elt->u.val_rtx));\n }\n \n /* Subroutine of cselib_lookup.  Return a value for X, which is a MEM rtx."}, {"sha": "3a96906424e50fcd9fb13301c355a5c750fc2d9c", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 47, "deletions": 27, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1ec5147f5dbed64487903c497484c6556548dd7/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1ec5147f5dbed64487903c497484c6556548dd7/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=f1ec5147f5dbed64487903c497484c6556548dd7", "patch": "@@ -1474,23 +1474,18 @@ operand_subword (op, offset, validate_address, mode)\n   /* Form a new MEM at the requested address.  */\n   if (GET_CODE (op) == MEM)\n     {\n-      rtx addr = plus_constant (XEXP (op, 0), (offset * UNITS_PER_WORD));\n-      rtx new;\n+      rtx new = adjust_address_nv (op, word_mode, offset * UNITS_PER_WORD);\n \n-      if (validate_address)\n+      if (! validate_address)\n+\treturn new;\n+\n+      else if (reload_completed)\n \t{\n-\t  if (reload_completed)\n-\t    {\n-\t      if (! strict_memory_address_p (word_mode, addr))\n-\t\treturn 0;\n-\t    }\n-\t  else\n-\t    addr = memory_address (word_mode, addr);\n+\t  if (! strict_memory_address_p (word_mode, XEXP (new, 0)))\n+\t    return 0;\n \t}\n-\n-      new = gen_rtx_MEM (word_mode, addr);\n-      MEM_COPY_ATTRIBUTES (new, op);\n-      return new;\n+      else\n+\treturn replace_equiv_address (new, XEXP (new, 0));\n     }\n \n   /* Rest can be handled by simplify_subreg.  */\n@@ -1567,13 +1562,16 @@ reverse_comparison (insn)\n /* Return a memory reference like MEMREF, but with its mode changed\n    to MODE and its address changed to ADDR.\n    (VOIDmode means don't change the mode.\n-   NULL for ADDR means don't change the address.)  */\n+   NULL for ADDR means don't change the address.)\n+   VALIDATE is nonzero if the returned memory location is required to be\n+   valid.  */\n \n rtx\n-change_address (memref, mode, addr)\n+change_address_1 (memref, mode, addr, validate)\n      rtx memref;\n      enum machine_mode mode;\n      rtx addr;\n+     int validate;\n {\n   rtx new;\n \n@@ -1584,19 +1582,16 @@ change_address (memref, mode, addr)\n   if (addr == 0)\n     addr = XEXP (memref, 0);\n \n-  /* If reload is in progress, don't check for validity of the address since we\n-     assume the caller knows what they are doing.  If reload has completed, the\n-     address must be valid.  Otherwise, we call memory_address to make it\n-     valid.  */\n-  if (reload_in_progress)\n-    ;\n-  else if (reload_completed)\n+  if (validate)\n     {\n-      if (! memory_address_p (mode, addr))\n-\tabort ();\n+      if (reload_in_progress || reload_completed)\n+\t{\n+\t  if (! memory_address_p (mode, addr))\n+\t    abort ();\n+\t}\n+      else\n+\taddr = memory_address (mode, addr);\n     }\n-  else\n-    addr = memory_address (mode, addr);\n \n   if (rtx_equal_p (addr, XEXP (memref, 0)) && mode == GET_MODE (memref))\n     return memref;\n@@ -1621,6 +1616,20 @@ adjust_address (memref, mode, offset)\n     change_address (memref, mode, plus_constant (XEXP (memref, 0), offset));\n }\n \n+/* Likewise, but the reference is not required to be valid.  */\n+\n+rtx\n+adjust_address_nv (memref, mode, offset)\n+     rtx memref;\n+     enum machine_mode mode;\n+     HOST_WIDE_INT offset;\n+{\n+  /* For now, this is just a wrapper for change_address, but eventually\n+     will do memref tracking.  */\n+  return change_address_1 (memref, mode,\n+\t\t\t   plus_constant (XEXP (memref, 0), offset), 0);\n+}\n+\n /* Return a memory reference like MEMREF, but with its address changed to\n    ADDR.  The caller is asserting that the actual piece of memory pointed\n    to is the same, just the form of the address is being changed, such as\n@@ -1635,6 +1644,17 @@ replace_equiv_address (memref, addr)\n      will do memref tracking.  */\n   return change_address (memref, VOIDmode, addr);\n }\n+/* Likewise, but the reference is not required to be valid.  */\n+\n+rtx\n+replace_equiv_address_nv (memref, addr)\n+     rtx memref;\n+     rtx addr;\n+{\n+  /* For now, this is just a wrapper for change_address, but eventually\n+     will do memref tracking.  */\n+  return change_address_1 (memref, VOIDmode, addr, 0);\n+}\n \f\n /* Return a newly created CODE_LABEL rtx with a unique label number.  */\n "}, {"sha": "f7e00be1ce90fbdaefa132eee571aab2d4a5d99a", "filename": "gcc/explow.c", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1ec5147f5dbed64487903c497484c6556548dd7/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1ec5147f5dbed64487903c497484c6556548dd7/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=f1ec5147f5dbed64487903c497484c6556548dd7", "patch": "@@ -715,21 +715,13 @@ rtx\n stabilize (x)\n      rtx x;\n {\n-  register rtx addr;\n \n-  if (GET_CODE (x) != MEM)\n+  if (GET_CODE (x) != MEM\n+      || ! rtx_unstable_p (XEXP (x, 0)))\n     return x;\n \n-  addr = XEXP (x, 0);\n-  if (rtx_unstable_p (addr))\n-    {\n-      rtx temp = force_reg (Pmode, copy_all_regs (addr));\n-      rtx mem = gen_rtx_MEM (GET_MODE (x), temp);\n-\n-      MEM_COPY_ATTRIBUTES (mem, x);\n-      return mem;\n-    }\n-  return x;\n+  return\n+    replace_equiv_address (x, force_reg (Pmode, copy_all_regs (XEXP (x, 0))));\n }\n \f\n /* Copy the value or contents of X to a new temp reg and return that reg.  */"}, {"sha": "9be312b9f43a13028275c7a65a47236e93806671", "filename": "gcc/expr.c", "status": "modified", "additions": 16, "deletions": 33, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1ec5147f5dbed64487903c497484c6556548dd7/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1ec5147f5dbed64487903c497484c6556548dd7/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=f1ec5147f5dbed64487903c497484c6556548dd7", "patch": "@@ -384,23 +384,23 @@ protect_from_queue (x, modify)\n       if (code == MEM && GET_MODE (x) != BLKmode\n \t  && GET_CODE (XEXP (x, 0)) == QUEUED && !modify)\n \t{\n-\t  register rtx y = XEXP (x, 0);\n-\t  register rtx new = gen_rtx_MEM (GET_MODE (x), QUEUED_VAR (y));\n-\n-\t  MEM_COPY_ATTRIBUTES (new, x);\n+\t  rtx y = XEXP (x, 0);\n+\t  rtx new = replace_equiv_address_nv (x, QUEUED_VAR (y));\n \n \t  if (QUEUED_INSN (y))\n \t    {\n-\t      register rtx temp = gen_reg_rtx (GET_MODE (new));\n+\t      rtx temp = gen_reg_rtx (GET_MODE (x));\n+\n \t      emit_insn_before (gen_move_insn (temp, new),\n \t\t\t\tQUEUED_INSN (y));\n \t      return temp;\n \t    }\n+\n \t  /* Copy the address into a pseudo, so that the returned value\n \t     remains correct across calls to emit_queue.  */\n-\t  XEXP (new, 0) = copy_to_reg (XEXP (new, 0));\n-\t  return new;\n+\t  return replace_equiv_address (new, copy_to_reg (XEXP (new, 0)));\n \t}\n+\n       /* Otherwise, recursively protect the subexpressions of all\n \t the kinds of rtx's that can contain a QUEUED.  */\n       if (code == MEM)\n@@ -1577,17 +1577,17 @@ move_by_pieces_1 (genfun, mode, data)\n \t{\n \t  if (data->autinc_to)\n \t    {\n-\t      to1 = gen_rtx_MEM (mode, data->to_addr);\n-\t      MEM_COPY_ATTRIBUTES (to1, data->to);\n+\t      to1 = replace_equiv_address (data->to, data->to_addr);\n+\t      to1 = adjust_address (to1, mode, 0);\n \t    }\n \t  else\n \t    to1 = adjust_address (data->to, mode, data->offset);\n \t}\n \n       if (data->autinc_from)\n \t{\n-\t  from1 = gen_rtx_MEM (mode, data->from_addr);\n-\t  MEM_COPY_ATTRIBUTES (from1, data->from);\n+\t  from1 = replace_equiv_address (data->from, data->from_addr);\n+\t  from1 = adjust_address (from1, mode, 0);\n \t}\n       else\n \tfrom1 = adjust_address (data->from, mode, data->offset);\n@@ -2508,8 +2508,8 @@ store_by_pieces_2 (genfun, mode, data)\n \n       if (data->autinc_to)\n \t{\n-\t  to1 = gen_rtx_MEM (mode, data->to_addr);\n-\t  MEM_COPY_ATTRIBUTES (to1, data->to);\n+\t  to1 = replace_equiv_address (data->to, data->to_addr);\n+\t  to1 = adjust_address (to1, mode, 0);\n \t}\n       else\n \tto1 = adjust_address (data->to, mode, data->offset);\n@@ -3003,20 +3003,10 @@ emit_move_insn_1 (x, y)\n \t is scheduled for replacement.  */\n       if (reload_in_progress && GET_CODE (x) == MEM\n \t  && (inner = find_replacement (&XEXP (x, 0))) != XEXP (x, 0))\n-\t{\n-\t  rtx new = gen_rtx_MEM (GET_MODE (x), inner);\n-\n-\t  MEM_COPY_ATTRIBUTES (new, x);\n-\t  x = new;\n-\t}\n+\tx = replace_equiv_address_nv (x, inner);\n       if (reload_in_progress && GET_CODE (y) == MEM\n \t  && (inner = find_replacement (&XEXP (y, 0))) != XEXP (y, 0))\n-\t{\n-\t  rtx new = gen_rtx_MEM (GET_MODE (y), inner);\n-\n-\t  MEM_COPY_ATTRIBUTES (new, y);\n-\t  y = new;\n-\t}\n+\ty = replace_equiv_address_nv (y, inner);\n \n       start_sequence ();\n \n@@ -7241,14 +7231,7 @@ expand_expr (exp, target, tmode, modifier)\n \t/* Get a reference to just this component.  */\n \tif (modifier == EXPAND_CONST_ADDRESS\n \t    || modifier == EXPAND_SUM || modifier == EXPAND_INITIALIZER)\n-\t  {\n-\t    rtx new = gen_rtx_MEM (mode1,\n-\t\t\t\t   plus_constant (XEXP (op0, 0),\n-\t\t\t\t\t\t  (bitpos / BITS_PER_UNIT)));\n-\n-\t    MEM_COPY_ATTRIBUTES (new, op0);\n-\t    op0 = new;\n-\t  }\n+\t  op0 = adjust_address_nv (op0, mode1, bitpos / BITS_PER_UNIT);\n \telse\n \t  op0 = adjust_address (op0, mode1, bitpos / BITS_PER_UNIT);\n "}, {"sha": "4808dc342c0671ed496f89152227b809bc637b66", "filename": "gcc/expr.h", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1ec5147f5dbed64487903c497484c6556548dd7/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1ec5147f5dbed64487903c497484c6556548dd7/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=f1ec5147f5dbed64487903c497484c6556548dd7", "patch": "@@ -1147,19 +1147,30 @@ extern rtx memory_address_noforce PARAMS ((enum machine_mode, rtx));\n /* Return a memory reference like MEMREF, but with its mode changed\n    to MODE and its address changed to ADDR.\n    (VOIDmode means don't change the mode.\n-   NULL for ADDR means don't change the address.)  */\n-extern rtx change_address PARAMS ((rtx, enum machine_mode, rtx));\n+   NULL for ADDR means don't change the address.)\n+   VALIDATE is nonzero if the returned memory location is required to be\n+   valid.  */\n+extern rtx change_address_1 PARAMS ((rtx, enum machine_mode, rtx, int));\n+\n+#define change_address(MEMREF, MODE, ADDR) \\\n+  change_address_1 (MEMREF, MODE, ADDR, 1)\n \n /* Return a memory reference like MEMREF, but with its mode changed\n    to MODE and its address offset by OFFSET bytes.  */\n extern rtx adjust_address PARAMS ((rtx, enum machine_mode, HOST_WIDE_INT));\n \n+/* Likewise, but the reference is not required to be valid.  */\n+extern rtx adjust_address_nv PARAMS ((rtx, enum machine_mode, HOST_WIDE_INT));\n+\n /* Return a memory reference like MEMREF, but with its address changed to\n    ADDR.  The caller is asserting that the actual piece of memory pointed\n    to is the same, just the form of the address is being changed, such as\n    by putting something into a register.  */\n extern rtx replace_equiv_address PARAMS ((rtx, rtx));\n \n+/* Likewise, but the reference is not required to be valid.  */\n+extern rtx replace_equiv_address_nv PARAMS ((rtx, rtx));\n+\n /* Return a memory reference like MEMREF, but which is known to have a\n    valid address.  */\n extern rtx validize_mem PARAMS ((rtx));"}, {"sha": "f257ea940955158cd67f9df19b49cd1ad614366e", "filename": "gcc/final.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1ec5147f5dbed64487903c497484c6556548dd7/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1ec5147f5dbed64487903c497484c6556548dd7/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=f1ec5147f5dbed64487903c497484c6556548dd7", "patch": "@@ -3093,7 +3093,7 @@ alter_subreg (x)\n     }\n   else if (GET_CODE (y) == MEM)\n     {\n-      register int offset = SUBREG_BYTE (x);\n+      HOST_WIDE_INT offset = SUBREG_BYTE (x);\n \n       /* Catch these instead of generating incorrect code.  */\n       if ((offset % GET_MODE_SIZE (GET_MODE (x))) != 0)"}, {"sha": "4019bb69a176d7872b7853c6b9509b7e3cdfbc70", "filename": "gcc/function.c", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1ec5147f5dbed64487903c497484c6556548dd7/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1ec5147f5dbed64487903c497484c6556548dd7/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=f1ec5147f5dbed64487903c497484c6556548dd7", "patch": "@@ -2094,9 +2094,7 @@ fixup_var_refs_1 (var, promoted_mode, loc, insn, replacements)\n \n \t\t  pos %= GET_MODE_BITSIZE (wanted_mode);\n \n-\t\t  newmem = gen_rtx_MEM (wanted_mode,\n-\t\t\t\t\tplus_constant (XEXP (tem, 0), offset));\n-\t\t  MEM_COPY_ATTRIBUTES (newmem, tem);\n+\t\t  newmem = adjust_address_nv (tem, wanted_mode, offset);\n \n \t\t  /* Make the change and see if the insn remains valid.  */\n \t\t  INSN_CODE (insn) = -1;\n@@ -2284,10 +2282,7 @@ fixup_var_refs_1 (var, promoted_mode, loc, insn, replacements)\n \n \t\t    pos %= GET_MODE_BITSIZE (wanted_mode);\n \n-\t\t    newmem = gen_rtx_MEM (wanted_mode,\n-\t\t\t\t\t  plus_constant (XEXP (tem, 0),\n-\t\t\t\t\t\t\t offset));\n-\t\t    MEM_COPY_ATTRIBUTES (newmem, tem);\n+\t\t    newmem = adjust_address_nv (tem, wanted_mode, offset);\n \n \t\t    /* Make the change and see if the insn remains valid.  */\n \t\t    INSN_CODE (insn) = -1;\n@@ -3027,14 +3022,9 @@ purge_addressof_1 (loc, insn, force, store, ht)\n   else if (code == MEM && GET_CODE (XEXP (x, 0)) == ADDRESSOF && ! force)\n     {\n       rtx sub = XEXP (XEXP (x, 0), 0);\n-      rtx sub2;\n \n       if (GET_CODE (sub) == MEM)\n-\t{\n-\t  sub2 = gen_rtx_MEM (GET_MODE (x), copy_rtx (XEXP (sub, 0)));\n-\t  MEM_COPY_ATTRIBUTES (sub2, sub);\n-\t  sub = sub2;\n-\t}\n+\tsub = adjust_address_nv (sub, GET_MODE (x), 0);\n       else if (GET_CODE (sub) == REG\n \t       && (MEM_VOLATILE_P (x) || GET_MODE (x) == BLKmode))\n \t;"}, {"sha": "16e1b08d87cb2f7ebfa718c04891ea265856689d", "filename": "gcc/optabs.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1ec5147f5dbed64487903c497484c6556548dd7/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1ec5147f5dbed64487903c497484c6556548dd7/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=f1ec5147f5dbed64487903c497484c6556548dd7", "patch": "@@ -3846,16 +3846,14 @@ gen_move_insn (x, y)\n \t  x = gen_lowpart_common (tmode, x1);\n \t  if (x == 0 && GET_CODE (x1) == MEM)\n \t    {\n-\t      x = gen_rtx_MEM (tmode, XEXP (x1, 0));\n-\t      MEM_COPY_ATTRIBUTES (x, x1);\n+\t      x = adjust_address_nv (x1, tmode, 0);\n \t      copy_replacements (x1, x);\n \t    }\n \n \t  y = gen_lowpart_common (tmode, y1);\n \t  if (y == 0 && GET_CODE (y1) == MEM)\n \t    {\n-\t      y = gen_rtx_MEM (tmode, XEXP (y1, 0));\n-\t      MEM_COPY_ATTRIBUTES (y, y1);\n+\t      y = adjust_address_nv (y1, tmode, 0);\n \t      copy_replacements (y1, y);\n \t    }\n \t}"}, {"sha": "01bc1f3a373af1556e8d3d439eea51e80f15f0de", "filename": "gcc/recog.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1ec5147f5dbed64487903c497484c6556548dd7/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1ec5147f5dbed64487903c497484c6556548dd7/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=f1ec5147f5dbed64487903c497484c6556548dd7", "patch": "@@ -29,6 +29,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"hard-reg-set.h\"\n #include \"recog.h\"\n #include \"regs.h\"\n+#include \"expr.h\"\n #include \"function.h\"\n #include \"flags.h\"\n #include \"real.h\"\n@@ -597,10 +598,7 @@ validate_replace_rtx_1 (loc, from, to, object)\n \n \t      pos %= GET_MODE_BITSIZE (wanted_mode);\n \n-\t      newmem = gen_rtx_MEM (wanted_mode,\n-\t\t\t\t    plus_constant (XEXP (XEXP (x, 0), 0),\n-\t\t\t\t\t\t   offset));\n-\t      MEM_COPY_ATTRIBUTES (newmem, XEXP (x, 0));\n+\t      newmem = adjust_address_nv (XEXP (x, 0), wanted_mode, offset);\n \n \t      validate_change (object, &XEXP (x, 2), GEN_INT (pos), 1);\n \t      validate_change (object, &XEXP (x, 0), newmem, 1);"}, {"sha": "faff2e4589a904aaa0c9e8110b672373dc889d5e", "filename": "gcc/regmove.c", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1ec5147f5dbed64487903c497484c6556548dd7/gcc%2Fregmove.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1ec5147f5dbed64487903c497484c6556548dd7/gcc%2Fregmove.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregmove.c?ref=f1ec5147f5dbed64487903c497484c6556548dd7", "patch": "@@ -2260,14 +2260,11 @@ try_apply_stack_adjustment (insn, memlist, new_adjust, delta)\n   validate_change (insn, &XEXP (SET_SRC (set), 1), GEN_INT (new_adjust), 1);\n \n   for (ml = memlist; ml ; ml = ml->next)\n-    {\n-      HOST_WIDE_INT c = ml->sp_offset - delta;\n-      rtx new = gen_rtx_MEM (GET_MODE (*ml->mem),\n-\t\t\t     plus_constant (stack_pointer_rtx, c));\n-\n-      MEM_COPY_ATTRIBUTES (new, *ml->mem);\n-      validate_change (ml->insn, ml->mem, new, 1);\n-    }\n+    validate_change\n+      (ml->insn, ml->mem,\n+       replace_equiv_address_nv (*ml->mem,\n+\t\t\t\t plus_constant (stack_pointer_rtx,\n+\t\t\t\t\t\tml->sp_offset - delta)), 1);\n \n   if (apply_change_group ())\n     {"}, {"sha": "adafd1a477ed4768911370ec3824a3640e0e7982", "filename": "gcc/reload.c", "status": "modified", "additions": 12, "deletions": 20, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1ec5147f5dbed64487903c497484c6556548dd7/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1ec5147f5dbed64487903c497484c6556548dd7/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=f1ec5147f5dbed64487903c497484c6556548dd7", "patch": "@@ -893,25 +893,18 @@ push_reload (in, out, inloc, outloc, class,\n   /* If we have a read-write operand with an address side-effect,\n      change either IN or OUT so the side-effect happens only once.  */\n   if (in != 0 && out != 0 && GET_CODE (in) == MEM && rtx_equal_p (in, out))\n-    {\n-      if (GET_CODE (XEXP (in, 0)) == POST_INC\n-\t  || GET_CODE (XEXP (in, 0)) == POST_DEC\n-\t  || GET_CODE (XEXP (in, 0)) == POST_MODIFY)\n-\t{\n-\t  rtx new = gen_rtx_MEM (GET_MODE (in), XEXP (XEXP (in, 0), 0));\n+    switch (GET_CODE (XEXP (in, 0)))\n+      {\n+      case POST_INC: case POST_DEC:   case POST_MODIFY:\n+\tin = replace_equiv_address_nv (in, XEXP (XEXP (in, 0), 0));\n+\tbreak;\n \n-\t  MEM_COPY_ATTRIBUTES (new, in);\n-\t  in = new;\n-\t}\n-      if (GET_CODE (XEXP (in, 0)) == PRE_INC\n-\t  || GET_CODE (XEXP (in, 0)) == PRE_DEC\n-\t  || GET_CODE (XEXP (in, 0)) == PRE_MODIFY)\n-\t{\n-\t  rtx new = gen_rtx_MEM (GET_MODE (out), XEXP (XEXP (out, 0), 0));\n+      case PRE_INC: case PRE_DEC: case PRE_MODIFY:\n+\tout = replace_equiv_address_nv (out, XEXP (XEXP (out, 0), 0));\n+\tbreak;\n \n-\t  MEM_COPY_ATTRIBUTES (new, out);\n-\t  out = new;\n-\t}\n+      default:\n+\tbreak;\n     }\n \n   /* If we are reloading a (SUBREG constant ...), really reload just the\n@@ -4484,9 +4477,8 @@ make_memloc (ad, regno)\n   if (rtx_varies_p (tem, 0))\n     tem = copy_rtx (tem);\n \n-  tem = gen_rtx_MEM (GET_MODE (ad), tem);\n-  MEM_COPY_ATTRIBUTES (tem, reg_equiv_memory_loc[regno]);\n-  return tem;\n+  tem = replace_equiv_address_nv (reg_equiv_memory_loc[regno], tem);\n+  return adjust_address_nv (tem, GET_MODE (ad), 0);\n }\n \n /* Record all reloads needed for handling memory address AD"}, {"sha": "78851c0a147d5b5fcca142d76a2898992f4ca3bc", "filename": "gcc/reload1.c", "status": "modified", "additions": 5, "deletions": 16, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1ec5147f5dbed64487903c497484c6556548dd7/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1ec5147f5dbed64487903c497484c6556548dd7/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=f1ec5147f5dbed64487903c497484c6556548dd7", "patch": "@@ -2052,13 +2052,7 @@ alter_reg (i, from_reg)\n       /* If we have any adjustment to make, or if the stack slot is the\n \t wrong mode, make a new stack slot.  */\n       if (adjust != 0 || GET_MODE (x) != GET_MODE (regno_reg_rtx[i]))\n-\t{\n-\t  rtx new = gen_rtx_MEM (GET_MODE (regno_reg_rtx[i]),\n-\t\t\t\t plus_constant (XEXP (x, 0), adjust));\n-\n-\t  MEM_COPY_ATTRIBUTES (new, x);\n-\t  x = new;\n-\t}\n+\tx = adjust_address_nv (x, GET_MODE (regno_reg_rtx[i]), adjust);\n \n       /* Save the stack slot for later.   */\n       reg_equiv_memory_loc[i] = x;\n@@ -2572,15 +2566,10 @@ eliminate_regs (x, mem_mode, insn)\n       /* Our only special processing is to pass the mode of the MEM to our\n \t recursive call and copy the flags.  While we are here, handle this\n \t case more efficiently.  */\n-      new = eliminate_regs (XEXP (x, 0), GET_MODE (x), insn);\n-      if (new != XEXP (x, 0))\n-\t{\n-\t  new = gen_rtx_MEM (GET_MODE (x), new);\n-\t  MEM_COPY_ATTRIBUTES (new, x);\n-\t  return new;\n-\t}\n-      else\n-\treturn x;\n+      return\n+\treplace_equiv_address_nv (x,\n+\t\t\t\t  eliminate_regs (XEXP (x, 0),\n+\t\t\t\t\t\t  GET_MODE (x), insn));\n \n     case USE:\n       /* Handle insn_list USE that a call to a pure function may generate.  */"}, {"sha": "3cdc3dc546d15c9fe463a18c36dd4aa49f843f51", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 5, "deletions": 23, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1ec5147f5dbed64487903c497484c6556548dd7/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1ec5147f5dbed64487903c497484c6556548dd7/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=f1ec5147f5dbed64487903c497484c6556548dd7", "patch": "@@ -265,22 +265,10 @@ simplify_replace_rtx (x, old, new)\n \n     default:\n       if (GET_CODE (x) == MEM)\n-\t{\n-\t  /* We can't use change_address here, since it verifies memory address\n-\t     for corectness.  We don't want such check, since we may handle\n-\t     addresses previously incorect (such as ones in push instructions)\n-\t     and it is caller's work to verify whether resulting insn match.  */\n-\t  rtx addr = simplify_replace_rtx (XEXP (x, 0), old, new);\n-\t  rtx mem;\n-\t  if (XEXP (x, 0) != addr)\n-\t    {\n-\t      mem = gen_rtx_MEM (GET_MODE (x), addr);\n-\t      MEM_COPY_ATTRIBUTES (mem, x);\n-\t    }\n-\t  else\n-\t    mem = x;\n-\t  return mem;\n-\t}\n+\treturn\n+\t  replace_equiv_address_nv (x,\n+\t\t\t\t    simplify_replace_rtx (XEXP (x, 0),\n+\t\t\t\t\t\t\t  old, new));\n \n       return x;\n     }\n@@ -2415,13 +2403,7 @@ simplify_subreg (outermode, op, innermode, byte)\n \t  || (mov_optab->handlers[(int) innermode].insn_code\n \t      == CODE_FOR_nothing))\n       && GET_MODE_SIZE (outermode) <= GET_MODE_SIZE (GET_MODE (op)))\n-    {\n-      rtx new;\n-\n-      new = gen_rtx_MEM (outermode, plus_constant (XEXP (op, 0), byte));\n-      MEM_COPY_ATTRIBUTES (new, op);\n-      return new;\n-    }\n+    return adjust_address_nv (op, outermode, byte);\n \n   /* Handle complex values represented as CONCAT\n      of real and imaginary part.  */"}, {"sha": "ea736473ee5ddda32dd06e6858541fd1998c5737", "filename": "gcc/stmt.c", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1ec5147f5dbed64487903c497484c6556548dd7/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1ec5147f5dbed64487903c497484c6556548dd7/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=f1ec5147f5dbed64487903c497484c6556548dd7", "patch": "@@ -4112,11 +4112,7 @@ expand_anon_union_decl (decl, cleanup, decl_elts)\n \t  if (mode == GET_MODE (x))\n \t    SET_DECL_RTL (decl_elt, x);\n \t  else\n-\t    {\n-\t      SET_DECL_RTL (decl_elt,\n-\t\t\t    gen_rtx_MEM (mode, copy_rtx (XEXP (x, 0))));\n-\t      MEM_COPY_ATTRIBUTES (DECL_RTL (decl_elt), x);\n-\t    }\n+\t    SET_DECL_RTL (decl_elt, adjust_address_nv (x, mode, 0));\n \t}\n       else if (GET_CODE (x) == REG)\n \t{"}]}