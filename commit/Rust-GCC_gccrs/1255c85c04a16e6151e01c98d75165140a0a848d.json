{"sha": "1255c85c04a16e6151e01c98d75165140a0a848d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTI1NWM4NWMwNGExNmU2MTUxZTAxYzk4ZDc1MTY1MTQwYTBhODQ4ZA==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@redhat.com", "date": "2001-09-29T16:33:20Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2001-09-29T16:33:20Z"}, "message": "Documentation for vector extensions\n\nFrom-SVN: r45880", "tree": {"sha": "be9a372813a643821987008dbcafcad682c3f60f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/be9a372813a643821987008dbcafcad682c3f60f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1255c85c04a16e6151e01c98d75165140a0a848d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1255c85c04a16e6151e01c98d75165140a0a848d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1255c85c04a16e6151e01c98d75165140a0a848d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1255c85c04a16e6151e01c98d75165140a0a848d/comments", "author": null, "committer": null, "parents": [{"sha": "86be733d75a5daae48fb2690e47d36c444d7e680", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86be733d75a5daae48fb2690e47d36c444d7e680", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86be733d75a5daae48fb2690e47d36c444d7e680"}], "stats": {"total": 475, "additions": 466, "deletions": 9}, "files": [{"sha": "103bc2c9bc9c9572626de02d30d19860940084f0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1255c85c04a16e6151e01c98d75165140a0a848d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1255c85c04a16e6151e01c98d75165140a0a848d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1255c85c04a16e6151e01c98d75165140a0a848d", "patch": "@@ -1,3 +1,11 @@\n+2001-09-29  Bernd Schmidt  <bernds@redhat.com>\n+\n+\t* config/i386/i386.c (init_mmx_sse_builtins): Fix type of storelps and\n+\tstorehps builtins.\n+\t* doc/extend.texi (Vector Extensions): New node.\n+\t* doc/invoke.texi (Machine Dependent Options): Add documentation for\n+        i386 -mmmx, -msse, -m3dnow.\n+\n Sat Sep 29 15:08:16 CEST 2001  Jan Hubicka  <jh@suse.cz>\n \n \t* doc/invoke.texi (Optimize Options): Revert an accidental checkin."}, {"sha": "a8d68de40888a0a208f550455366484c5facb23b", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1255c85c04a16e6151e01c98d75165140a0a848d/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1255c85c04a16e6151e01c98d75165140a0a848d/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=1255c85c04a16e6151e01c98d75165140a0a848d", "patch": "@@ -10989,10 +10989,10 @@ ix86_init_mmx_sse_builtins ()\n \t\t\t   tree_cons (NULL_TREE, V4SF_type_node,\n \t\t\t\t      tree_cons (NULL_TREE, pv2si_type_node,\n \t\t\t\t\t\t endlink)));\n-  tree v4sf_ftype_pv2si_v4sf\n-    = build_function_type (V4SF_type_node,\n-\t\t\t   tree_cons (NULL_TREE, V4SF_type_node,\n-\t\t\t\t      tree_cons (NULL_TREE, pv2si_type_node,\n+  tree void_ftype_pv2si_v4sf\n+    = build_function_type (void_type_node,\n+\t\t\t   tree_cons (NULL_TREE, pv2si_type_node,\n+\t\t\t\t      tree_cons (NULL_TREE, V4SF_type_node,\n \t\t\t\t\t\t endlink)));\n   tree void_ftype_pfloat_v4sf\n     = build_function_type (void_type_node,\n@@ -11151,9 +11151,9 @@ ix86_init_mmx_sse_builtins ()\n   for (i = 0, d = bdesc_comi; i < sizeof (bdesc_comi) / sizeof *d; i++, d++)\n     def_builtin (d->mask, d->name, int_ftype_v4sf_v4sf, d->code);\n \n-  def_builtin (MASK_SSE, \"__builtin_ia32_packsswb\", v8qi_ftype_v4hi_v4hi, IX86_BUILTIN_PACKSSWB);\n-  def_builtin (MASK_SSE, \"__builtin_ia32_packssdw\", v4hi_ftype_v2si_v2si, IX86_BUILTIN_PACKSSDW);\n-  def_builtin (MASK_SSE, \"__builtin_ia32_packuswb\", v8qi_ftype_v4hi_v4hi, IX86_BUILTIN_PACKUSWB);\n+  def_builtin (MASK_MMX, \"__builtin_ia32_packsswb\", v8qi_ftype_v4hi_v4hi, IX86_BUILTIN_PACKSSWB);\n+  def_builtin (MASK_MMX, \"__builtin_ia32_packssdw\", v4hi_ftype_v2si_v2si, IX86_BUILTIN_PACKSSDW);\n+  def_builtin (MASK_MMX, \"__builtin_ia32_packuswb\", v8qi_ftype_v4hi_v4hi, IX86_BUILTIN_PACKUSWB);\n \n   def_builtin (MASK_SSE, \"__builtin_ia32_cvtpi2ps\", v4sf_ftype_v4sf_v2si, IX86_BUILTIN_CVTPI2PS);\n   def_builtin (MASK_SSE, \"__builtin_ia32_cvtps2pi\", v2si_ftype_v4sf, IX86_BUILTIN_CVTPS2PI);\n@@ -11176,8 +11176,8 @@ ix86_init_mmx_sse_builtins ()\n \n   def_builtin (MASK_SSE, \"__builtin_ia32_loadhps\", v4sf_ftype_v4sf_pv2si, IX86_BUILTIN_LOADHPS);\n   def_builtin (MASK_SSE, \"__builtin_ia32_loadlps\", v4sf_ftype_v4sf_pv2si, IX86_BUILTIN_LOADLPS);\n-  def_builtin (MASK_SSE, \"__builtin_ia32_storehps\", v4sf_ftype_pv2si_v4sf, IX86_BUILTIN_STOREHPS);\n-  def_builtin (MASK_SSE, \"__builtin_ia32_storelps\", v4sf_ftype_pv2si_v4sf, IX86_BUILTIN_STORELPS);\n+  def_builtin (MASK_SSE, \"__builtin_ia32_storehps\", void_ftype_pv2si_v4sf, IX86_BUILTIN_STOREHPS);\n+  def_builtin (MASK_SSE, \"__builtin_ia32_storelps\", void_ftype_pv2si_v4sf, IX86_BUILTIN_STORELPS);\n \n   def_builtin (MASK_SSE, \"__builtin_ia32_movmskps\", int_ftype_v4sf, IX86_BUILTIN_MOVMSKPS);\n   def_builtin (MASK_SSE | MASK_3DNOW_A, \"__builtin_ia32_pmovmskb\", int_ftype_v8qi, IX86_BUILTIN_PMOVMSKB);"}, {"sha": "7ade4885f47275765a38c9cd8a24a843c2186a75", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1255c85c04a16e6151e01c98d75165140a0a848d/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1255c85c04a16e6151e01c98d75165140a0a848d/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=1255c85c04a16e6151e01c98d75165140a0a848d", "patch": "@@ -430,6 +430,7 @@ extensions, accepted by GCC in C89 mode and in C++.\n * Function Names::\tPrintable strings which are the name of the current\n \t\t\t function.\n * Return Address::      Getting the return or frame address of a function.\n+* Vector Extensions::   Using vector instructions through built-in functions.\n * Other Builtins::      Other built-in functions.\n * Pragmas::             Pragmas accepted by GCC.\n @end menu\n@@ -483,6 +484,7 @@ extensions, accepted by GCC in C89 mode and in C++.\n * Function Names::\tPrintable strings which are the name of the current\n \t\t\t function.\n * Return Address::      Getting the return or frame address of a function.\n+* Vector Extensions::   Using vector instructions through built-in functions.\n * Other Builtins::      Other built-in functions.\n * Pragmas::             Pragmas accepted by GCC.\n @end menu\n@@ -4147,6 +4149,75 @@ This function should only be used with a non-zero argument for debugging\n purposes.\n @end deftypefn\n \n+@node Vector Extensions\n+@section Using vector instructions through built-in functions\n+\n+On some targets, the instruction set contains SIMD vector instructions that\n+operate on multiple values contained in one large register at the same time.\n+For example, on the i386 the MMX, 3Dnow! and SSE extensions can be used\n+this way.\n+\n+The first step in using these extensions is to provide the necessary data\n+types.  This should be done using an appropriate @code{typedef}:\n+\n+@example\n+typedef int v4si __attribute__ ((mode(V4SI)));\n+@end example\n+\n+The base type @code{int} is effectively ignored by the compiler, the\n+actual properties of the new type @code{v4si} are defined by the\n+@code{__attribute__}.  It defines the machine mode to be used; for vector\n+types these have the form @code{VnB}; @code{n} should be the number of\n+elements in the vector, and @code{B} should be the base mode of the\n+individual elements.  The following can be used as base modes:\n+\n+@table @code\n+@item QI\n+An integer that is as wide as the smallest addressable unit, usually 8 bits.\n+@item HI\n+An integer, twice as wide as a QI mode integer, usually 16 bits.\n+@item SI\n+An integer, four times as wide as a QI mode integer, usually 32 bits.\n+@item DI\n+An integer, eight times as wide as a QI mode integer, usually 64 bits.\n+@item SF\n+A floating point value, as wide as a SI mode integer, usually 32 bits.\n+@item DF\n+A floating point value, as wide as a DI mode integer, usually 64 bits.\n+@end table\n+\n+Not all base types or combinations are always valid; which modes can be used\n+is determined by the target machine.  For example, if targetting the i386 MMX\n+extensions, only @code{V8QI}, @code{V4HI} and @code{V2SI} are allowed modes.\n+\n+There are no @code{V1xx} vector modes - they would be identical to the\n+corresponding base mode.\n+\n+There is no distinction between signed and unsigned vector modes.  This\n+distinction is made by the operations that perform on the vectors, not\n+by the data type.\n+\n+The types defined in this manner are somewhat special, they cannot be\n+used with most normal C operations (i.e., a vector addition can @emph{not}\n+be represented by a normal addition of two vector type variables).  You\n+can declare only variables and use them in function calls and returns, as\n+well as in assignments and some casts.  It is possible to cast from one\n+vector type to another, provided they are of the same size (in fact, you\n+can also cast vectors to and from other datatypes of the same size).\n+\n+A port that supports vector operations provides a set of built-in functions\n+that can be used to operate on vectors.  For example, a function to add two\n+vectors and multiply the result by a third could look like this:\n+\n+@example\n+v4si f (v4si a, v4si b, v4si c)\n+@{\n+  v4si tmp = __builtin_addv4si (a, b);\n+  return __builtin_mulv4si (tmp, c);\n+@}\n+\n+@end example\n+\n @node Other Builtins\n @section Other built-in functions provided by GCC\n @cindex built-in functions"}, {"sha": "2b5f95336cc42f90bcf0c342534db65a5ee0ac5a", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 378, "deletions": 0, "changes": 378, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1255c85c04a16e6151e01c98d75165140a0a848d/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1255c85c04a16e6151e01c98d75165140a0a848d/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=1255c85c04a16e6151e01c98d75165140a0a848d", "patch": "@@ -471,6 +471,7 @@ in the following sections.\n -mno-fp-ret-in-387  -msoft-float  -msvr3-shlib @gol\n -mno-wide-multiply  -mrtd  -malign-double @gol\n -mpreferred-stack-boundary=@var{num} @gol\n+-mmmx  -msse  -m3dnow @gol\n -mthreads  -mno-align-stringops  -minline-all-stringops @gol\n -mpush-args  -maccumulate-outgoing-args  -m128bit-long-double @gol\n -m96bit-long-double  -mregparm=@var{num}  -momit-leaf-frame-pointer}\n@@ -7600,6 +7601,383 @@ to stack space usage, such as embedded systems and operating system kernels,\n may want to reduce the preferred alignment to\n @option{-mpreferred-stack-boundary=2}.\n \n+@item -mmmx\n+@itemx -mno-mmx\n+@item -msse\n+@itemx -mno-sse\n+@item -m3dnow\n+@itemx -mno-3dnow\n+@opindex mmmx\n+@opindex mno-mmx\n+@opindex msse\n+@opindex mno-sse\n+@opindex m3dnow\n+@opindex mno-3dnow\n+These switches enable or disable the use of built-in functions that allow\n+direct access to the MMX, SSE and 3Dnow extensions of the instruction set.\n+\n+The following machine modes are available for use with MMX builtins\n+(@pxref{Vector Extensions}): @code{V2SI} for a vector of two 32 bit integers,\n+@code{V4HI} for a vector of four 16 bit integers, and @code{V8QI} for a\n+vector of eight 8 bit integers.  Some of the builtins operate on MMX\n+registers as a whole 64 bit entity, these use @code{DI} as their mode.\n+\n+If 3Dnow extensions are enabled, @code{V2SF} is used as a mode for a vector\n+of two 32 bit floating point values.\n+\n+If SSE extensions are enabled, @code{V4SF} is used for a vector of four 32 bit\n+floating point values.  Some instructions use a vector of four 32 bit\n+integers, these use @code{V4SI}.  Finally, some instructions operate on an\n+entire vector register, interpreting it as a 128 bit integer, these use mode\n+@code{TI}.\n+\n+The following builtins are made available by @option{-mmmx}:\n+@table @code\n+@item v8qi __builtin_ia32_paddb (v8qi, v8qi)\n+Generates the @code{paddb} machine instruction.\n+@item v4hi __builtin_ia32_paddw (v4hi, v4hi)\n+Generates the @code{paddw} machine instruction.\n+@item v2si __builtin_ia32_paddd (v2si, v2si)\n+Generates the @code{paddd} machine instruction.\n+@item v8qi __builtin_ia32_psubb (v8qi, v8qi)\n+Generates the @code{psubb} machine instruction.\n+@item v4hi __builtin_ia32_psubw (v4hi, v4hi)\n+Generates the @code{psubw} machine instruction.\n+@item v2si __builtin_ia32_psubd (v2si, v2si)\n+Generates the @code{psubd} machine instruction.\n+\n+@item v8qi __builtin_ia32_paddsb (v8qi, v8qi)\n+Generates the @code{paddsb} machine instruction.\n+@item v4hi __builtin_ia32_paddsw (v4hi, v4hi)\n+Generates the @code{paddsw} machine instruction.\n+@item v8qi __builtin_ia32_psubsb (v8qi, v8qi)\n+Generates the @code{psubsb} machine instruction.\n+@item v4hi __builtin_ia32_psubsw (v4hi, v4hi)\n+Generates the @code{psubsw} machine instruction.\n+\n+@item v8qi __builtin_ia32_paddusb (v8qi, v8qi)\n+Generates the @code{paddusb} machine instruction.\n+@item v4hi __builtin_ia32_paddusw (v4hi, v4hi)\n+Generates the @code{paddusw} machine instruction.\n+@item v8qi __builtin_ia32_psubusb (v8qi, v8qi)\n+Generates the @code{psubusb} machine instruction.\n+@item v4hi __builtin_ia32_psubusw (v4hi, v4hi)\n+Generates the @code{psubusw} machine instruction.\n+\n+@item v4hi __builtin_ia32_pmullw (v4hi, v4hi)\n+Generates the @code{pmullw} machine instruction.\n+@item v4hi __builtin_ia32_pmulhw (v4hi, v4hi)\n+Generates the @code{pmulhw} machine instruction.\n+\n+@item di __builtin_ia32_pand (di, di)\n+Generates the @code{pand} machine instruction.\n+@item di __builtin_ia32_pandn (di,di)\n+Generates the @code{pandn} machine instruction.\n+@item di __builtin_ia32_por (di, di)\n+Generates the @code{por} machine instruction.\n+@item di __builtin_ia32_pxor (di, di)\n+Generates the @code{pxor} machine instruction.\n+\n+@item v8qi __builtin_ia32_pcmpeqb (v8qi, v8qi)\n+Generates the @code{pcmpeqb} machine instruction.\n+@item v4hi __builtin_ia32_pcmpeqw (v4hi, v4hi)\n+Generates the @code{pcmpeqw} machine instruction.\n+@item v2si __builtin_ia32_pcmpeqd (v2si, v2si)\n+Generates the @code{pcmpeqd} machine instruction.\n+@item v8qi __builtin_ia32_pcmpgtb (v8qi, v8qi)\n+Generates the @code{pcmpgtb} machine instruction.\n+@item v4hi __builtin_ia32_pcmpgtw (v4hi, v4hi)\n+Generates the @code{pcmpgtw} machine instruction.\n+@item v2si __builtin_ia32_pcmpgtd (v2si, v2si)\n+Generates the @code{pcmpgtd} machine instruction.\n+\n+@item v8qi __builtin_ia32_punpckhbw (v8qi, v8qi)\n+Generates the @code{punpckhbw} machine instruction.\n+@item v4hi __builtin_ia32_punpckhwd (v4hi, v4hi)\n+Generates the @code{punpckhwd} machine instruction.\n+@item v2si __builtin_ia32_punpckhdq (v2si, v2si)\n+Generates the @code{punpckhdq} machine instruction.\n+@item v8qi __builtin_ia32_punpcklbw (v8qi, v8qi)\n+Generates the @code{punpcklbw} machine instruction.\n+@item v4hi __builtin_ia32_punpcklwd (v4hi, v4hi)\n+Generates the @code{punpcklwd} machine instruction.\n+@item v2si __builtin_ia32_punpckldq (v2si, v2si)\n+Generates the @code{punpckldq} machine instruction.\n+\n+@item v8qi __builtin_ia32_packsswb (v4hi, v4hi)\n+Generates the @code{packsswb} machine instruction.\n+@item v4hi __builtin_ia32_packssdw (v2si, v2si)\n+Generates the @code{packssdw} machine instruction.\n+@item v8qi __builtin_ia32_packuswb (v4hi, v4hi)\n+Generates the @code{packuswb} machine instruction.\n+\n+@end table\n+\n+The following builtins are made available either with @option{-msse}, or\n+with a combination of @option{-m3dnow} and @option{-march=athlon}.\n+@table @code\n+\n+@item v4hi __builtin_ia32_pmulhuw (v4hi, v4hi)\n+Generates the @code{pmulhuw} machine instruction.\n+\n+@item v8qi __builtin_ia32_pavgb (v8qi, v8qi)\n+Generates the @code{pavgb} machine instruction.\n+@item v4hi __builtin_ia32_pavgw (v4hi, v4hi)\n+Generates the @code{pavgw} machine instruction.\n+@item v4hi __builtin_ia32_psadbw (v8qi, v8qi)\n+Generates the @code{psadbw} machine instruction.\n+\n+@item v8qi __builtin_ia32_pmaxub (v8qi, v8qi)\n+Generates the @code{pmaxub} machine instruction.\n+@item v4hi __builtin_ia32_pmaxsw (v4hi, v4hi)\n+Generates the @code{pmaxsw} machine instruction.\n+@item v8qi __builtin_ia32_pminub (v8qi, v8qi)\n+Generates the @code{pminub} machine instruction.\n+@item v4hi __builtin_ia32_pminsw (v4hi, v4hi)\n+Generates the @code{pminsw} machine instruction.\n+\n+@item int __builtin_ia32_pextrw (v4hi, int)\n+Generates the @code{pextrw} machine instruction.\n+@item v4hi __builtin_ia32_pinsrw (v4hi, int, int)\n+Generates the @code{pinsrw} machine instruction.\n+\n+@item int __builtin_ia32_pmovmskb (v8qi)\n+Generates the @code{pmovmskb} machine instruction.\n+@item void __builtin_ia32_maskmovq (v8qi, v8qi, char *)\n+Generates the @code{maskmovq} machine instruction.\n+@item void __buitlin_ia32_movntq (di *, di)\n+Generates the @code{movntq} machine instruction.\n+@item void __buitlin_ia32_sfence (void)\n+Generates the @code{sfence} machine instruction.\n+@item void __builtin_ia32_prefetch (char *, int selector)\n+Generates a prefetch machine instruction, depending on the value of\n+selector.  If @code{selector} is 0, it generates @code{prefetchnta}; for\n+a value of 1, it generates @code{prefetcht0}; for a value of 2, it generates\n+@code{prefetcht1}; and for a value of 3 it generates @code{prefetcht2}.\n+\n+@end table\n+\n+The following builtins are available when @option{-msse} is used.\n+\n+@table @code\n+@item int __buitlin_ia32_comieq (v4sf, v4sf)\n+Generates the @code{comiss} machine instruction and performs an equality\n+comparison.  The return value is the truth value of that comparison.\n+@item int __buitlin_ia32_comineq (v4sf, v4sf)\n+Generates the @code{comiss} machine instruction and performs an inequality\n+comparison.  The return value is the truth value of that comparison.\n+@item int __buitlin_ia32_comilt (v4sf, v4sf)\n+Generates the @code{comiss} machine instruction and performs a ``less than''\n+comparison.  The return value is the truth value of that comparison.\n+@item int __buitlin_ia32_comile (v4sf, v4sf)\n+Generates the @code{comiss} machine instruction and performs a ``less or\n+equal'' comparison.  The return value is the truth value of that comparison.\n+@item int __buitlin_ia32_comigt (v4sf, v4sf)\n+Generates the @code{comiss} machine instruction and performs a ``greater than''\n+comparison.  The return value is the truth value of that comparison.\n+@item int __buitlin_ia32_comige (v4sf, v4sf)\n+Generates the @code{comiss} machine instruction and performs a ``greater or\n+equal'' comparison.  The return value is the truth value of that comparison.\n+\n+@item int __buitlin_ia32_ucomieq (v4sf, v4sf)\n+Generates the @code{ucomiss} machine instruction and performs an equality\n+comparison.  The return value is the truth value of that comparison.\n+@item int __buitlin_ia32_ucomineq (v4sf, v4sf)\n+Generates the @code{ucomiss} machine instruction and performs an inequality\n+comparison.  The return value is the truth value of that comparison.\n+@item int __buitlin_ia32_ucomilt (v4sf, v4sf)\n+Generates the @code{ucomiss} machine instruction and performs a ``less than''\n+comparison.  The return value is the truth value of that comparison.\n+@item int __buitlin_ia32_ucomile (v4sf, v4sf)\n+Generates the @code{ucomiss} machine instruction and performs a ``less or\n+equal'' comparison.  The return value is the truth value of that comparison.\n+@item int __buitlin_ia32_ucomigt (v4sf, v4sf)\n+Generates the @code{ucomiss} machine instruction and performs a ``greater than''\n+comparison.  The return value is the truth value of that comparison.\n+@item int __buitlin_ia32_ucomige (v4sf, v4sf)\n+Generates the @code{ucomiss} machine instruction and performs a ``greater or\n+equal'' comparison.  The return value is the truth value of that comparison.\n+\n+@item v4sf __buitlin_ia32_addps (v4sf, v4sf)\n+Generates the @code{addps} machine instruction.\n+@item v4sf __buitlin_ia32_addss (v4sf, v4sf)\n+Generates the @code{addss} machine instruction.\n+@item v4sf __buitlin_ia32_subps (v4sf, v4sf)\n+Generates the @code{subps} machine instruction.\n+@item v4sf __buitlin_ia32_subss (v4sf, v4sf)\n+Generates the @code{subss} machine instruction.\n+@item v4sf __buitlin_ia32_mulps (v4sf, v4sf)\n+Generates the @code{mulps} machine instruction.\n+@item v4sf __buitlin_ia32_mulss (v4sf, v4sf)\n+Generates the @code{mulss} machine instruction.\n+@item v4sf __buitlin_ia32_divps (v4sf, v4sf)\n+Generates the @code{divps} machine instruction.\n+@item v4sf __buitlin_ia32_divss (v4sf, v4sf)\n+Generates the @code{divss} machine instruction.\n+\n+@item v4si __buitlin_ia32_cmpeqps (v4sf, v4sf)\n+Generates the @code{cmpeqps} machine instruction.\n+@item v4si __buitlin_ia32_cmplts (v4sf, v4sf)\n+Generates the @code{cmpltps} machine instruction.\n+@item v4si __buitlin_ia32_cmpleps (v4sf, v4sf)\n+Generates the @code{cmpleps} machine instruction.\n+@item v4si __buitlin_ia32_cmpgtps (v4sf, v4sf)\n+Generates the @code{cmpgtps} machine instruction.\n+@item v4si __buitlin_ia32_cmpgeps (v4sf, v4sf)\n+Generates the @code{cmpgeps} machine instruction.\n+@item v4si __buitlin_ia32_cmpunordps (v4sf, v4sf)\n+Generates the @code{cmpunodps} machine instruction.\n+@item v4si __buitlin_ia32_cmpneqps (v4sf, v4sf)\n+Generates the @code{cmpeqps} machine instruction.\n+@item v4si __buitlin_ia32_cmpnltps (v4sf, v4sf)\n+Generates the @code{cmpltps} machine instruction.\n+@item v4si __buitlin_ia32_cmpnleps (v4sf, v4sf)\n+Generates the @code{cmpleps} machine instruction.\n+@item v4si __buitlin_ia32_cmpngtps (v4sf, v4sf)\n+Generates the @code{cmpgtps} machine instruction.\n+@item v4si __buitlin_ia32_cmpngeps (v4sf, v4sf)\n+Generates the @code{cmpgeps} machine instruction.\n+@item v4si __buitlin_ia32_cmpordps (v4sf, v4sf)\n+Generates the @code{cmpunodps} machine instruction.\n+\n+@item v4si __buitlin_ia32_cmpeqss (v4sf, v4sf)\n+Generates the @code{cmpeqss} machine instruction.\n+@item v4si __buitlin_ia32_cmpltss (v4sf, v4sf)\n+Generates the @code{cmpltss} machine instruction.\n+@item v4si __buitlin_ia32_cmpless (v4sf, v4sf)\n+Generates the @code{cmpless} machine instruction.\n+@item v4si __buitlin_ia32_cmpgtss (v4sf, v4sf)\n+Generates the @code{cmpgtss} machine instruction.\n+@item v4si __buitlin_ia32_cmpgess (v4sf, v4sf)\n+Generates the @code{cmpgess} machine instruction.\n+@item v4si __buitlin_ia32_cmpunordss (v4sf, v4sf)\n+Generates the @code{cmpunodss} machine instruction.\n+@item v4si __buitlin_ia32_cmpneqss (v4sf, v4sf)\n+Generates the @code{cmpeqss} machine instruction.\n+@item v4si __buitlin_ia32_cmpnlts (v4sf, v4sf)\n+Generates the @code{cmpltss} machine instruction.\n+@item v4si __buitlin_ia32_cmpnless (v4sf, v4sf)\n+Generates the @code{cmpless} machine instruction.\n+@item v4si __buitlin_ia32_cmpngtss (v4sf, v4sf)\n+Generates the @code{cmpgtss} machine instruction.\n+@item v4si __buitlin_ia32_cmpngess (v4sf, v4sf)\n+Generates the @code{cmpgess} machine instruction.\n+@item v4si __buitlin_ia32_cmpordss (v4sf, v4sf)\n+Generates the @code{cmpunodss} machine instruction.\n+\n+@item v4sf __buitlin_ia32_maxps (v4sf, v4sf)\n+Generates the @code{maxps} machine instruction.\n+@item v4sf __buitlin_ia32_maxsss (v4sf, v4sf)\n+Generates the @code{maxss} machine instruction.\n+@item v4sf __buitlin_ia32_minps (v4sf, v4sf)\n+Generates the @code{minps} machine instruction.\n+@item v4sf __buitlin_ia32_minsss (v4sf, v4sf)\n+Generates the @code{minss} machine instruction.\n+\n+@item ti __buitlin_ia32_andps (ti, ti)\n+Generates the @code{andps} machine instruction.\n+@item ti __buitlin_ia32_andnps (ti, ti)\n+Generates the @code{andnps} machine instruction.\n+@item ti __buitlin_ia32_orps (ti, ti)\n+Generates the @code{orps} machine instruction.\n+@item ti __buitlin_ia32_xorps (ti, ti)\n+Generates the @code{xorps} machine instruction.\n+\n+@item v4sf __buitlin_ia32_movps (v4sf, v4sf)\n+Generates the @code{movps} machine instruction.\n+@item v4sf __buitlin_ia32_movhlps (v4sf, v4sf)\n+Generates the @code{movhlps} machine instruction.\n+@item v4sf __buitlin_ia32_movlhps (v4sf, v4sf)\n+Generates the @code{movlhps} machine instruction.\n+@item v4sf __buitlin_ia32_unpckhps (v4sf, v4sf)\n+Generates the @code{unpckhps} machine instruction.\n+@item v4sf __buitlin_ia32_unpcklps (v4sf, v4sf)\n+Generates the @code{unpcklps} machine instruction.\n+\n+@item v4sf __buitlin_ia32_cvtpi2ps (v4sf, v2si)\n+Generates the @code{cvtpi2ps} machine instruction.\n+@item v2si __buitlin_ia32_cvtps2pi (v4sf)\n+Generates the @code{cvtps2pi} machine instruction.\n+@item v4sf __buitlin_ia32_cvtsi2ss (v4sf, int)\n+Generates the @code{cvtsi2ss} machine instruction.\n+@item int __buitlin_ia32_cvtss2si (v4sf)\n+Generates the @code{cvtsi2ss} machine instruction.\n+@item v2si __buitlin_ia32_cvttps2pi (v4sf)\n+Generates the @code{cvttps2pi} machine instruction.\n+@item int __buitlin_ia32_cvttss2si (v4sf)\n+Generates the @code{cvttsi2ss} machine instruction.\n+\n+@item v4sf __buitlin_ia32_rcpps (v4sf)\n+Generates the @code{rcpps} machine instruction.\n+@item v4sf __buitlin_ia32_rsqrtps (v4sf)\n+Generates the @code{rsqrtps} machine instruction.\n+@item v4sf __buitlin_ia32_sqrtps (v4sf)\n+Generates the @code{sqrtps} machine instruction.\n+@item v4sf __buitlin_ia32_rcpss (v4sf)\n+Generates the @code{rcpss} machine instruction.\n+@item v4sf __buitlin_ia32_rsqrtss (v4sf)\n+Generates the @code{rsqrtss} machine instruction.\n+@item v4sf __buitlin_ia32_sqrtss (v4sf)\n+Generates the @code{sqrtss} machine instruction.\n+\n+@item v4sf __buitlin_ia32_shufps (v4sf, v4sf, int)\n+Generates the @code{shufps} machine instruction.\n+\n+@item v4sf __buitlin_ia32_loadaps (float *)\n+Generates the @code{movaps} machine instruction as a load from memory.\n+@item void __buitlin_ia32_storeaps (float *, v4sf)\n+Generates the @code{movaps} machine instruction as a store to memory.\n+@item v4sf __buitlin_ia32_loadups (float *)\n+Generates the @code{movups} machine instruction as a load from memory.\n+@item void __buitlin_ia32_storeups (float *, v4sf)\n+Generates the @code{movups} machine instruction as a store to memory.\n+@item v4sf __buitlin_ia32_loadsss (float *)\n+Generates the @code{movss} machine instruction as a load from memory.\n+@item void __buitlin_ia32_storess (float *, v4sf)\n+Generates the @code{movss} machine instruction as a store to memory.\n+\n+@item v4sf __buitlin_ia32_loadhps (v4sf, v2si *)\n+Generates the @code{movhps} machine instruction as a load from memory.\n+@item v4sf __buitlin_ia32_loadlps (v4sf, v2si *)\n+Generates the @code{movlps} machine instruction as a load from memory\n+@item void __buitlin_ia32_storehps (v4sf, v2si *)\n+Generates the @code{movhps} machine instruction as a store to memory.\n+@item void __buitlin_ia32_storelps (v4sf, v2si *)\n+Generates the @code{movlps} machine instruction as a store to memory.\n+\n+@item void __buitlin_ia32_movntps (float *, v4sf)\n+Generates the @code{movntps} machine instruction.\n+@item int __buitlin_ia32_movmskps (v4sf)\n+Generates the @code{movntps} machine instruction.\n+\n+@item void __buitlin_ia32_storeps1 (float *, v4sf)\n+Generates the @code{movaps} machine instruction as a store to memory.\n+Before storing, the value is modified with a @code{shufps} instruction\n+so that the lowest of the four floating point elements is replicated\n+across the entire vector that is stored.\n+@item void __buitlin_ia32_storerps (float *, v4sf)\n+Generates the @code{movaps} machine instruction as a store to memory.\n+Before storing, the value is modified with a @code{shufps} instruction\n+so that the order of the four floating point elements in the vector is\n+reversed.\n+@item v4sf __buitlin_ia32_loadps1 (float *)\n+Generates a @code{movss} machine instruction to load a floating point\n+value from memory, and a @code{shufps} instruction to replicate the\n+loaded value across all four elements of the result vector.\n+@item v4sf __buitlin_ia32_loadrps (float *)\n+Generates a @code{movaps} machine instruction to load a vector from\n+memory, and a @code{shufps} instruction to reverse the order of the\n+four floating point elements in the result vector.\n+@item v4sf __builtin_ia32_setps (float, float, float, float)\n+Constructs a vector from four single floating point values.  The return\n+value is equal to the value that would result from storing the four\n+arguments into consecutive memory locations and then executing a\n+@code{movaps} to load the vector from memory.\n+@item v4sf __builtin_ia32_setps1 (float)\n+Constructs a vector from a single floating point value by replicating\n+it across all four elements of the result vector.\n+@end table\n+\n @item -mpush-args\n @itemx -mno-push-args\n @opindex mpush-args"}]}