{"sha": "3d30741b2b9156e49531879fdb2154fde2019129", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2QzMDc0MWIyYjkxNTZlNDk1MzE4NzlmZGIyMTU0ZmRlMjAxOTEyOQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@nildram.co.uk", "date": "2007-09-30T22:50:02Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2007-09-30T22:50:02Z"}, "message": "mips.c (mips_split_64bit_move): Use gen_rtx_REG_offset rather than gen_lowpart to change a register from DImode...\n\ngcc/\n\t* config/mips/mips.c (mips_split_64bit_move): Use gen_rtx_REG_offset\n\trather than gen_lowpart to change a register from DImode to DFmode.\n\t(mips_cannot_change_mode_class): Only allow FPRs to change mode if\n\tboth FROM and TO are integer modes that are no bigger than 4 bytes.\n\t(mips_mode_ok_for_mov_fmt_p): New function.\n\t(mips_preferred_reload_class): Use it instead of FLOAT_MODE_P.\n\t(mips_secondary_reload_class): Tweak formatting and comments.\n\tUse reg_class_subset_p instead of direct comparisons with\n\tclasses.  Only allow direct FPR<->FPR moves for modes that\n\tsatisfy mips_mode_ok_for_mov_fmt_p.  Only allow loads and stores\n\tfor 4- and 8-byte types.  Handle reloads in which X is an FPR.\n\t* config/mips/mips.md (*movdi_gp32_fp64): Remove f<-f alternative.\n\t(*movdi_64bit): Likewise.\n\t(*movsi_internal): Likewise.\n\t(*movhi_internal): Likewise.\n\t(*movqi_internal): Likewise.\n\nFrom-SVN: r128894", "tree": {"sha": "872f69f3d734d6f77088296a0efc0dfa8d489b1d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/872f69f3d734d6f77088296a0efc0dfa8d489b1d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3d30741b2b9156e49531879fdb2154fde2019129", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d30741b2b9156e49531879fdb2154fde2019129", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d30741b2b9156e49531879fdb2154fde2019129", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d30741b2b9156e49531879fdb2154fde2019129/comments", "author": null, "committer": null, "parents": [{"sha": "a45db20b7574c6a50e5b2c3bca189b21973a7b10", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a45db20b7574c6a50e5b2c3bca189b21973a7b10", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a45db20b7574c6a50e5b2c3bca189b21973a7b10"}], "stats": {"total": 278, "additions": 141, "deletions": 137}, "files": [{"sha": "5c1fdc0566cc562248ebe29b01173a72d88e9046", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d30741b2b9156e49531879fdb2154fde2019129/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d30741b2b9156e49531879fdb2154fde2019129/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3d30741b2b9156e49531879fdb2154fde2019129", "patch": "@@ -1,3 +1,22 @@\n+2007-09-30  Richard Sandiford  <rsandifo@nildram.co.uk>\n+\n+\t* config/mips/mips.c (mips_split_64bit_move): Use gen_rtx_REG_offset\n+\trather than gen_lowpart to change a register from DImode to DFmode.\n+\t(mips_cannot_change_mode_class): Only allow FPRs to change mode if\n+\tboth FROM and TO are integer modes that are no bigger than 4 bytes.\n+\t(mips_mode_ok_for_mov_fmt_p): New function.\n+\t(mips_preferred_reload_class): Use it instead of FLOAT_MODE_P.\n+\t(mips_secondary_reload_class): Tweak formatting and comments.\n+\tUse reg_class_subset_p instead of direct comparisons with\n+\tclasses.  Only allow direct FPR<->FPR moves for modes that\n+\tsatisfy mips_mode_ok_for_mov_fmt_p.  Only allow loads and stores\n+\tfor 4- and 8-byte types.  Handle reloads in which X is an FPR.\n+\t* config/mips/mips.md (*movdi_gp32_fp64): Remove f<-f alternative.\n+\t(*movdi_64bit): Likewise.\n+\t(*movsi_internal): Likewise.\n+\t(*movhi_internal): Likewise.\n+\t(*movqi_internal): Likewise.\n+\n 2007-09-30  Diego Novillo  <dnovillo@google.com>\n \n \tPR 33593"}, {"sha": "6ac976abe6e9a83f1b59eeeadbf160e4d6403d97", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 102, "deletions": 115, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d30741b2b9156e49531879fdb2154fde2019129/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d30741b2b9156e49531879fdb2154fde2019129/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=3d30741b2b9156e49531879fdb2154fde2019129", "patch": "@@ -3547,7 +3547,8 @@ mips_split_64bit_move (rtx dest, rtx src)\n       /* Loading an FPR from memory or from GPRs.  */\n       if (ISA_HAS_MXHC1)\n \t{\n-\t  dest = gen_lowpart (DFmode, dest);\n+\t  if (GET_MODE (dest) != DFmode)\n+\t    dest = gen_rtx_REG_offset (dest, DFmode, REGNO (dest), 0);\n \t  emit_insn (gen_load_df_low (dest, mips_subword (src, 0)));\n \t  emit_insn (gen_mthc1 (dest, mips_subword (src, 1),\n \t\t\t\tcopy_rtx (dest)));\n@@ -3565,7 +3566,8 @@ mips_split_64bit_move (rtx dest, rtx src)\n       /* Storing an FPR into memory or GPRs.  */\n       if (ISA_HAS_MXHC1)\n \t{\n-\t  src = gen_lowpart (DFmode, src);\n+\t  if (GET_MODE (src) != DFmode)\n+\t    src = gen_rtx_REG_offset (src, DFmode, REGNO (src), 0);\n \t  mips_emit_move (mips_subword (dest, 0), mips_subword (src, 0));\n \t  emit_insn (gen_mfhc1 (mips_subword (dest, 1), src));\n \t}\n@@ -9314,44 +9316,38 @@ mips_callee_copies (CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED,\n    to mode TO.  */\n \n bool\n-mips_cannot_change_mode_class (enum machine_mode from,\n-\t\t\t       enum machine_mode to, enum reg_class class)\n+mips_cannot_change_mode_class (enum machine_mode from ATTRIBUTE_UNUSED,\n+\t\t\t       enum machine_mode to ATTRIBUTE_UNUSED,\n+\t\t\t       enum reg_class class)\n {\n-  if (MIN (GET_MODE_SIZE (from), GET_MODE_SIZE (to)) <= UNITS_PER_WORD\n-      && MAX (GET_MODE_SIZE (from), GET_MODE_SIZE (to)) > UNITS_PER_WORD)\n-    {\n-      if (TARGET_BIG_ENDIAN)\n-\t{\n-\t  /* When a multi-word value is stored in paired floating-point\n-\t     registers, the first register always holds the low word.\n-\t     We therefore can't allow FPRs to change between single-word\n-\t     and multi-word modes.  */\n-\t  if (MAX_FPRS_PER_FMT > 1 && reg_classes_intersect_p (FP_REGS, class))\n-\t    return true;\n-\t}\n-    }\n+  /* There are several problems with changing the modes of values\n+     in floating-point registers:\n \n-  /* gcc assumes that each word of a multiword register can be accessed\n-     individually using SUBREGs.  This is not true for floating-point\n-     registers if they are bigger than a word.  */\n-  if (UNITS_PER_FPREG > UNITS_PER_WORD\n-      && GET_MODE_SIZE (from) > UNITS_PER_WORD\n-      && GET_MODE_SIZE (to) < UNITS_PER_FPREG\n-      && reg_classes_intersect_p (FP_REGS, class))\n-    return true;\n+     - When a multi-word value is stored in paired floating-point\n+       registers, the first register always holds the low word.\n+       We therefore can't allow FPRs to change between single-word\n+       and multi-word modes on big-endian targets.\n \n-  /* Loading a 32-bit value into a 64-bit floating-point register\n-     will not sign-extend the value, despite what LOAD_EXTEND_OP says.\n-     We can't allow 64-bit float registers to change from SImode to\n-     to a wider mode.  */\n-  if (TARGET_64BIT\n-      && TARGET_FLOAT64\n-      && from == SImode\n-      && GET_MODE_SIZE (to) >= UNITS_PER_WORD\n-      && reg_classes_intersect_p (FP_REGS, class))\n-    return true;\n+     - GCC assumes that each word of a multiword register can be accessed\n+       individually using SUBREGs.  This is not true for floating-point\n+       registers if they are bigger than a word.\n \n-  return false;\n+     - Loading a 32-bit value into a 64-bit floating-point register\n+       will not sign-extend the value, despite what LOAD_EXTEND_OP says.\n+       We can't allow FPRs to change from SImode to to a wider mode on\n+       64-bit targets.\n+\n+     - If the FPU has already interpreted a value in one format, we must\n+       not ask it to treat the value as having a different format.\n+\n+     We therefore only allow changes between 4-byte and smaller integer\n+     values, all of which have the \"W\" format as far as the FPU is\n+     concerned.  */\n+  return (reg_classes_intersect_p (FP_REGS, class)\n+\t  && (GET_MODE_CLASS (from) != MODE_INT\n+\t      || GET_MODE_CLASS (to) != MODE_INT\n+\t      || GET_MODE_SIZE (from) > 4\n+\t      || GET_MODE_SIZE (to) > 4));\n }\n \n /* Return true if X should not be moved directly into register $25.\n@@ -9367,6 +9363,27 @@ mips_dangerous_for_la25_p (rtx x)\n \t  && mips_global_symbol_p (x));\n }\n \n+/* Return true if moves in mode MODE can use the FPU's mov.fmt instruction.  */\n+\n+static bool\n+mips_mode_ok_for_mov_fmt_p (enum machine_mode mode)\n+{\n+  switch (mode)\n+    {\n+    case SFmode:\n+      return TARGET_HARD_FLOAT;\n+\n+    case DFmode:\n+      return TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT;\n+\n+    case V2SFmode:\n+      return TARGET_HARD_FLOAT && TARGET_PAIRED_SINGLE_FLOAT;\n+\n+    default:\n+      return false;\n+    }\n+}\n+\n /* Implement PREFERRED_RELOAD_CLASS.  */\n \n enum reg_class\n@@ -9375,9 +9392,8 @@ mips_preferred_reload_class (rtx x, enum reg_class class)\n   if (mips_dangerous_for_la25_p (x) && reg_class_subset_p (LEA_REGS, class))\n     return LEA_REGS;\n \n-  if (TARGET_HARD_FLOAT\n-      && FLOAT_MODE_P (GET_MODE (x))\n-      && reg_class_subset_p (FP_REGS, class))\n+  if (reg_class_subset_p (FP_REGS, class)\n+      && mips_mode_ok_for_mov_fmt_p (GET_MODE (x)))\n     return FP_REGS;\n \n   if (reg_class_subset_p (GR_REGS, class))\n@@ -9399,110 +9415,81 @@ enum reg_class\n mips_secondary_reload_class (enum reg_class class,\n \t\t\t     enum machine_mode mode, rtx x, int in_p)\n {\n-  enum reg_class gr_regs = TARGET_MIPS16 ? M16_REGS : GR_REGS;\n-  int regno = -1;\n-  int gp_reg_p;\n-\n-  if (REG_P (x)|| GET_CODE (x) == SUBREG)\n-    regno = true_regnum (x);\n-\n-  gp_reg_p = TARGET_MIPS16 ? M16_REG_P (regno) : GP_REG_P (regno);\n+  int regno;\n \n+  /* If X is a constant that cannot be loaded into $25, it must be loaded\n+     into some other GPR.  No other register class allows a direct move.  */\n   if (mips_dangerous_for_la25_p (x))\n+    return reg_class_subset_p (class, LEA_REGS) ? NO_REGS : LEA_REGS;\n+\n+  regno = true_regnum (x);\n+  if (TARGET_MIPS16)\n     {\n-      gr_regs = LEA_REGS;\n-      if (TEST_HARD_REG_BIT (reg_class_contents[(int) class], 25))\n-\treturn gr_regs;\n+      /* In MIPS16 mode, every move must involve a member of M16_REGS.  */\n+      if (!reg_class_subset_p (class, M16_REGS) && !M16_REG_P (regno))\n+\treturn M16_REGS;\n+\n+      /* We can't really copy to HI or LO at all in MIPS16 mode.  */\n+      if (in_p ? reg_classes_intersect_p (class, ACC_REGS) : ACC_REG_P (regno))\n+\treturn M16_REGS;\n+\n+      return NO_REGS;\n     }\n \n-  /* Copying from HI or LO to anywhere other than a general register\n-     requires a general register.\n-     This rule applies to both the original HI/LO pair and the new\n-     DSP accumulators.  */\n+  /* Copying from accumulator registers to anywhere other than a general\n+     register requires a temporary general register.  */\n   if (reg_class_subset_p (class, ACC_REGS))\n-    {\n-      if (TARGET_MIPS16 && in_p)\n-\t{\n-\t  /* We can't really copy to HI or LO at all in mips16 mode.  */\n-\t  return M16_REGS;\n-\t}\n-      return gp_reg_p ? NO_REGS : gr_regs;\n-    }\n+    return GP_REG_P (regno) ? NO_REGS : GR_REGS;\n   if (ACC_REG_P (regno))\n-    {\n-      if (TARGET_MIPS16 && ! in_p)\n-\t{\n-\t  /* We can't really copy to HI or LO at all in mips16 mode.  */\n-\t  return M16_REGS;\n-\t}\n-      return class == gr_regs ? NO_REGS : gr_regs;\n-    }\n+    return reg_class_subset_p (class, GR_REGS) ? NO_REGS : GR_REGS;\n \n   /* We can only copy a value to a condition code register from a\n      floating point register, and even then we require a scratch\n      floating point register.  We can only copy a value out of a\n      condition code register into a general register.  */\n-  if (class == ST_REGS)\n+  if (reg_class_subset_p (class, ST_REGS))\n     {\n       if (in_p)\n \treturn FP_REGS;\n-      return gp_reg_p ? NO_REGS : gr_regs;\n+      return GP_REG_P (regno) ? NO_REGS : GR_REGS;\n     }\n   if (ST_REG_P (regno))\n     {\n-      if (! in_p)\n+      if (!in_p)\n \treturn FP_REGS;\n-      return class == gr_regs ? NO_REGS : gr_regs;\n+      return reg_class_subset_p (class, GR_REGS) ? NO_REGS : GR_REGS;\n     }\n \n-  if (class == FP_REGS)\n+  if (reg_class_subset_p (class, FP_REGS))\n     {\n-      if (MEM_P (x))\n-\t{\n-\t  /* In this case we can use lwc1, swc1, ldc1 or sdc1.  */\n-\t  return NO_REGS;\n-\t}\n-      else if (CONSTANT_P (x) && GET_MODE_CLASS (mode) == MODE_FLOAT)\n-\t{\n-\t  /* We can use the l.s and l.d macros to load floating-point\n-\t     constants.  ??? For l.s, we could probably get better\n-\t     code by returning GR_REGS here.  */\n-\t  return NO_REGS;\n-\t}\n-      else if (gp_reg_p || x == CONST0_RTX (mode))\n-\t{\n-\t  /* In this case we can use mtc1, mfc1, dmtc1 or dmfc1.  */\n-\t  return NO_REGS;\n-\t}\n-      else if (FP_REG_P (regno))\n-\t{\n-\t  /* In this case we can use mov.s or mov.d.  */\n-\t  return NO_REGS;\n-\t}\n-      else\n-\t{\n-\t  /* Otherwise, we need to reload through an integer register.  */\n-\t  return gr_regs;\n-\t}\n-    }\n+      if (MEM_P (x)\n+\t  && (GET_MODE_SIZE (mode) == 4 || GET_MODE_SIZE (mode) == 8))\n+\t/* In this case we can use lwc1, swc1, ldc1 or sdc1.  We'll use\n+\t   pairs of lwc1s and swc1s if ldc1 and sdc1 are not supported.  */\n+\treturn NO_REGS;\n \n-  /* In mips16 mode, going between memory and anything but M16_REGS\n-     requires an M16_REG.  */\n-  if (TARGET_MIPS16)\n-    {\n-      if (class != M16_REGS && class != M16_NA_REGS)\n+      if (GP_REG_P (regno) || x == CONST0_RTX (mode))\n+\t/* In this case we can use mtc1, mfc1, dmtc1 or dmfc1.  */\n+\treturn NO_REGS;\n+\n+      if (mips_mode_ok_for_mov_fmt_p (mode))\n \t{\n-\t  if (gp_reg_p)\n+\t  if (CONSTANT_P (x))\n+\t    /* We can force the constants to memory and use lwc1\n+\t       and ldc1.  As above, we will use pairs of lwc1s if\n+\t       ldc1 is not supported.  */\n \t    return NO_REGS;\n-\t  return M16_REGS;\n-\t}\n-      if (! gp_reg_p)\n-\t{\n-\t  if (class == M16_REGS || class == M16_NA_REGS)\n+\n+\t  if (FP_REG_P (regno))\n+\t    /* In this case we can use mov.fmt.  */\n \t    return NO_REGS;\n-\t  return M16_REGS;\n \t}\n+\n+      /* Otherwise, we need to reload through an integer register.  */\n+      return GR_REGS;\n     }\n+  if (FP_REG_P (regno))\n+    return reg_class_subset_p (class, GR_REGS) ? NO_REGS : GR_REGS;\n \n   return NO_REGS;\n }"}, {"sha": "890cc706590a21e642a1bde8e5dd45fbb9f28efc", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 20, "deletions": 22, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d30741b2b9156e49531879fdb2154fde2019129/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d30741b2b9156e49531879fdb2154fde2019129/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=3d30741b2b9156e49531879fdb2154fde2019129", "patch": "@@ -3399,15 +3399,15 @@\n    (set_attr \"length\"   \"8,16,*,*,8,8,8,*,8,*\")])\n \n (define_insn \"*movdi_gp32_fp64\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=d,d,d,m,*a,*d,*f,*f,*f,*d,*m\")\n-\t(match_operand:DI 1 \"move_operand\" \"d,i,m,d,*J*d,*a,*f,*J*d,*m,*f,*f\"))]\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=d,d,d,m,*a,*d,*f,*f,*d,*m\")\n+\t(match_operand:DI 1 \"move_operand\" \"d,i,m,d,*J*d,*a,*J*d,*m,*f,*f\"))]\n   \"!TARGET_64BIT && TARGET_FLOAT64 && !TARGET_MIPS16\n    && (register_operand (operands[0], DImode)\n        || reg_or_0_operand (operands[1], DImode))\"\n   { return mips_output_move (operands[0], operands[1]); }\n-  [(set_attr \"type\"\t\"multi,multi,load,store,mthilo,mfhilo,fmove,mtc,fpload,mfc,fpstore\")\n+  [(set_attr \"type\"\t\"multi,multi,load,store,mthilo,mfhilo,mtc,fpload,mfc,fpstore\")\n    (set_attr \"mode\"\t\"DI\")\n-   (set_attr \"length\"   \"8,16,*,*,8,8,4,8,*,8,*\")])\n+   (set_attr \"length\"   \"8,16,*,*,8,8,8,*,8,*\")])\n \n (define_insn \"*movdi_32bit_mips16\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=d,y,d,d,d,d,m,*d\")\n@@ -3421,15 +3421,15 @@\n    (set_attr \"length\"\t\"8,8,8,8,12,*,*,8\")])\n \n (define_insn \"*movdi_64bit\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=d,d,e,d,m,*f,*f,*f,*d,*m,*x,*B*C*D,*B*C*D,*d,*m\")\n-\t(match_operand:DI 1 \"move_operand\" \"d,U,T,m,dJ,*f,*d*J,*m,*f,*f,*J*d,*d,*m,*B*C*D,*B*C*D\"))]\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=d,d,e,d,m,*f,*f,*d,*m,*x,*B*C*D,*B*C*D,*d,*m\")\n+\t(match_operand:DI 1 \"move_operand\" \"d,U,T,m,dJ,*d*J,*m,*f,*f,*J*d,*d,*m,*B*C*D,*B*C*D\"))]\n   \"TARGET_64BIT && !TARGET_MIPS16\n    && (register_operand (operands[0], DImode)\n        || reg_or_0_operand (operands[1], DImode))\"\n   { return mips_output_move (operands[0], operands[1]); }\n-  [(set_attr \"type\"\t\"move,const,const,load,store,fmove,mtc,fpload,mfc,fpstore,mthilo,mtc,load,mfc,store\")\n+  [(set_attr \"type\"\t\"move,const,const,load,store,mtc,fpload,mfc,fpstore,mthilo,mtc,load,mfc,store\")\n    (set_attr \"mode\"\t\"DI\")\n-   (set_attr \"length\"\t\"4,*,*,*,*,4,4,*,4,*,4,8,*,8,*\")])\n+   (set_attr \"length\"\t\"4,*,*,*,*,4,*,4,*,4,8,*,8,*\")])\n \n (define_insn \"*movdi_64bit_mips16\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=d,y,d,d,d,d,d,d,m\")\n@@ -3518,15 +3518,15 @@\n ;; in FP registers (off by default, use -mdebugh to enable).\n \n (define_insn \"*movsi_internal\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d,d,e,d,m,*f,*f,*f,*d,*m,*d,*z,*a,*d,*B*C*D,*B*C*D,*d,*m\")\n-\t(match_operand:SI 1 \"move_operand\" \"d,U,T,m,dJ,*f,*d*J,*m,*f,*f,*z,*d,*J*d,*A,*d,*m,*B*C*D,*B*C*D\"))]\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d,d,e,d,m,*f,*f,*d,*m,*d,*z,*a,*d,*B*C*D,*B*C*D,*d,*m\")\n+\t(match_operand:SI 1 \"move_operand\" \"d,U,T,m,dJ,*d*J,*m,*f,*f,*z,*d,*J*d,*A,*d,*m,*B*C*D,*B*C*D\"))]\n   \"!TARGET_MIPS16\n    && (register_operand (operands[0], SImode)\n        || reg_or_0_operand (operands[1], SImode))\"\n   { return mips_output_move (operands[0], operands[1]); }\n-  [(set_attr \"type\"\t\"move,const,const,load,store,fmove,mtc,fpload,mfc,fpstore,mfc,mtc,mthilo,mfhilo,mtc,load,mfc,store\")\n+  [(set_attr \"type\"\t\"move,const,const,load,store,mtc,fpload,mfc,fpstore,mfc,mtc,mthilo,mfhilo,mtc,load,mfc,store\")\n    (set_attr \"mode\"\t\"SI\")\n-   (set_attr \"length\"\t\"4,*,*,*,*,4,4,*,4,*,4,4,4,4,4,*,4,*\")])\n+   (set_attr \"length\"\t\"4,*,*,*,*,4,*,4,*,4,4,4,4,4,*,4,*\")])\n \n (define_insn \"*movsi_mips16\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d,y,d,d,d,d,d,d,m\")\n@@ -3727,8 +3727,8 @@\n })\n \n (define_insn \"*movhi_internal\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=d,d,d,m,*d,*f,*f,*x\")\n-\t(match_operand:HI 1 \"move_operand\"         \"d,I,m,dJ,*f,*d,*f,*d\"))]\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=d,d,d,m,*d,*f,*x\")\n+\t(match_operand:HI 1 \"move_operand\"         \"d,I,m,dJ,*f,*d,*d\"))]\n   \"!TARGET_MIPS16\n    && (register_operand (operands[0], HImode)\n        || reg_or_0_operand (operands[1], HImode))\"\n@@ -3739,11 +3739,10 @@\n     sh\\t%z1,%0\n     mfc1\\t%0,%1\n     mtc1\\t%1,%0\n-    mov.s\\t%0,%1\n     mt%0\\t%1\"\n-  [(set_attr \"type\"\t\"move,arith,load,store,mfc,mtc,fmove,mthilo\")\n+  [(set_attr \"type\"\t\"move,arith,load,store,mfc,mtc,mthilo\")\n    (set_attr \"mode\"\t\"HI\")\n-   (set_attr \"length\"\t\"4,4,*,*,4,4,4,4\")])\n+   (set_attr \"length\"\t\"4,4,*,*,4,4,4\")])\n \n (define_insn \"*movhi_mips16\"\n   [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=d,y,d,d,d,d,m\")\n@@ -3834,8 +3833,8 @@\n })\n \n (define_insn \"*movqi_internal\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=d,d,d,m,*d,*f,*f,*x\")\n-\t(match_operand:QI 1 \"move_operand\"         \"d,I,m,dJ,*f,*d,*f,*d\"))]\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=d,d,d,m,*d,*f,*x\")\n+\t(match_operand:QI 1 \"move_operand\"         \"d,I,m,dJ,*f,*d,*d\"))]\n   \"!TARGET_MIPS16\n    && (register_operand (operands[0], QImode)\n        || reg_or_0_operand (operands[1], QImode))\"\n@@ -3846,11 +3845,10 @@\n     sb\\t%z1,%0\n     mfc1\\t%0,%1\n     mtc1\\t%1,%0\n-    mov.s\\t%0,%1\n     mt%0\\t%1\"\n-  [(set_attr \"type\"\t\"move,arith,load,store,mfc,mtc,fmove,mthilo\")\n+  [(set_attr \"type\"\t\"move,arith,load,store,mfc,mtc,mthilo\")\n    (set_attr \"mode\"\t\"QI\")\n-   (set_attr \"length\"\t\"4,4,*,*,4,4,4,4\")])\n+   (set_attr \"length\"\t\"4,4,*,*,4,4,4\")])\n \n (define_insn \"*movqi_mips16\"\n   [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=d,y,d,d,d,d,m\")"}]}