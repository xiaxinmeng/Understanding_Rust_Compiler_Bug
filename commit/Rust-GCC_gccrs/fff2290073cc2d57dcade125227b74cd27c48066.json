{"sha": "fff2290073cc2d57dcade125227b74cd27c48066", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmZmMjI5MDA3M2NjMmQ1N2RjYWRlMTI1MjI3Yjc0Y2QyN2M0ODA2Ng==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-02-08T15:16:29Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-02-08T15:16:29Z"}, "message": "Use nonzero bits to refine range in split_constant_offset (PR 81635)\n\nThis patch is part 2 of the fix for PR 81635.  It means that\nsplit_constant_offset can handle loops like:\n\n  for (unsigned int i = 0; i < n; i += 4)\n    {\n      a[i] = ...;\n      a[i + 1] = ...;\n    }\n\nCCP records that \"i\" must have its low 2 bits clear, but we don't\ninclude this information in the range of \"i\", which remains [0, +INF].\nI tried making set_nonzero_bits update the range info in the same\nway that set_range_info updates the nonzero bits, but it regressed\ncases like vrp117.c and made some other tests worse.\n\nvrp117.c has a multiplication by 10, so CCP can infer that the low bit\nof the result is clear.  If we included that in the range, the range\nwould go from [-INF, +INF] to [-INF, not-quite-+INF].  However,\nthe multiplication is also known to overflow in all cases, so VRP\nsaturates the result to [INT_MAX, INT_MAX].  This obviously creates a\ncontradiction with the nonzero bits, and intersecting the new saturated\nrange with an existing not-quite-+INF range would make us drop to\nVR_UNDEFINED.  We're prepared to fold a comparison with an [INT_MAX,\nINT_MAX] value but not with a VR_UNDEFINED value.\n\nThe other problems were created when intersecting [-INF, not-quite-+INF]\nwith a useful VR_ANTI_RANGE like ~[-1, 1].  The intersection would\nkeep the former range rather than the latter.\n\nThe patch therefore keeps the adjustment local to split_constant_offset\nfor now, but adds a helper routine so that it's easy to move this later.\n\n2018-02-08  Richard Sandiford  <richard.sandiford@linaro.org>\n\ngcc/\n\tPR tree-optimization/81635\n\t* wide-int.h (wi::round_down_for_mask, wi::round_up_for_mask): Declare.\n\t* wide-int.cc (wi::round_down_for_mask, wi::round_up_for_mask)\n\t(test_round_for_mask): New functions.\n\t(wide_int_cc_tests): Call test_round_for_mask.\n\t* tree-vrp.h (intersect_range_with_nonzero_bits): Declare.\n\t* tree-vrp.c (intersect_range_with_nonzero_bits): New function.\n\t* tree-data-ref.c (split_constant_offset_1): Use it to refine the\n\trange returned by get_range_info.\n\ngcc/testsuite/\n\tPR tree-optimization/81635\n\t* gcc.dg/vect/bb-slp-pr81635-3.c: New test.\n\t* gcc.dg/vect/bb-slp-pr81635-4.c: Likewise.\n\nFrom-SVN: r257491", "tree": {"sha": "09569e058630b4d92cbafdd8c0bd833aa0df8da9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/09569e058630b4d92cbafdd8c0bd833aa0df8da9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fff2290073cc2d57dcade125227b74cd27c48066", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fff2290073cc2d57dcade125227b74cd27c48066", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fff2290073cc2d57dcade125227b74cd27c48066", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fff2290073cc2d57dcade125227b74cd27c48066/comments", "author": null, "committer": null, "parents": [{"sha": "39aa9b2369eff7f2be0712ea7f1ee12f8697ce36", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39aa9b2369eff7f2be0712ea7f1ee12f8697ce36", "html_url": "https://github.com/Rust-GCC/gccrs/commit/39aa9b2369eff7f2be0712ea7f1ee12f8697ce36"}], "stats": {"total": 299, "additions": 297, "deletions": 2}, "files": [{"sha": "0e8b23288a0d8d7f7a06a3c952746a70572c3a81", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fff2290073cc2d57dcade125227b74cd27c48066/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fff2290073cc2d57dcade125227b74cd27c48066/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fff2290073cc2d57dcade125227b74cd27c48066", "patch": "@@ -1,3 +1,15 @@\n+2018-02-08  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\tPR tree-optimization/81635\n+\t* wide-int.h (wi::round_down_for_mask, wi::round_up_for_mask): Declare.\n+\t* wide-int.cc (wi::round_down_for_mask, wi::round_up_for_mask)\n+\t(test_round_for_mask): New functions.\n+\t(wide_int_cc_tests): Call test_round_for_mask.\n+\t* tree-vrp.h (intersect_range_with_nonzero_bits): Declare.\n+\t* tree-vrp.c (intersect_range_with_nonzero_bits): New function.\n+\t* tree-data-ref.c (split_constant_offset_1): Use it to refine the\n+\trange returned by get_range_info.\n+\n 2018-02-08  Jan Hubicka  <hubicka@ucw.cz>\n \n \tPR ipa/81360"}, {"sha": "52cf0b53870a1e78f89ba18a2362d42594b867dc", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fff2290073cc2d57dcade125227b74cd27c48066/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fff2290073cc2d57dcade125227b74cd27c48066/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=fff2290073cc2d57dcade125227b74cd27c48066", "patch": "@@ -1,3 +1,9 @@\n+2018-02-08  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\tPR tree-optimization/81635\n+\t* gcc.dg/vect/bb-slp-pr81635-3.c: New test.\n+\t* gcc.dg/vect/bb-slp-pr81635-4.c: Likewise.\n+\n 2018-02-08  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>\n \n \t* gcc.target/s390/nobp-function-pointer-attr.c: New test."}, {"sha": "1cca1d0d2654dcf5b91ed2d1a6dae8c5008ed30a", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-pr81635-3.c", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fff2290073cc2d57dcade125227b74cd27c48066/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-pr81635-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fff2290073cc2d57dcade125227b74cd27c48066/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-pr81635-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-pr81635-3.c?ref=fff2290073cc2d57dcade125227b74cd27c48066", "patch": "@@ -0,0 +1,62 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-fno-tree-loop-vectorize\" } */\n+/* { dg-require-effective-target vect_double } */\n+/* { dg-require-effective-target lp64 } */\n+\n+void\n+f1 (double *p, double *q, unsigned int n)\n+{\n+  p = (double *) __builtin_assume_aligned (p, sizeof (double) * 2);\n+  q = (double *) __builtin_assume_aligned (q, sizeof (double) * 2);\n+  for (unsigned int i = 0; i < n; i += 4)\n+    {\n+      double a = q[i] + p[i];\n+      double b = q[i + 1] + p[i + 1];\n+      q[i] = a;\n+      q[i + 1] = b;\n+    }\n+}\n+\n+void\n+f2 (double *p, double *q, unsigned int n)\n+{\n+  p = (double *) __builtin_assume_aligned (p, sizeof (double) * 2);\n+  q = (double *) __builtin_assume_aligned (q, sizeof (double) * 2);\n+  for (unsigned int i = 0; i < n; i += 2)\n+    {\n+      double a = q[i] + p[i];\n+      double b = q[i + 1] + p[i + 1];\n+      q[i] = a;\n+      q[i + 1] = b;\n+    }\n+}\n+\n+void\n+f3 (double *p, double *q, unsigned int n)\n+{\n+  p = (double *) __builtin_assume_aligned (p, sizeof (double) * 2);\n+  q = (double *) __builtin_assume_aligned (q, sizeof (double) * 2);\n+  for (unsigned int i = 0; i < n; i += 6)\n+    {\n+      double a = q[i] + p[i];\n+      double b = q[i + 1] + p[i + 1];\n+      q[i] = a;\n+      q[i + 1] = b;\n+    }\n+}\n+\n+void\n+f4 (double *p, double *q, unsigned int start, unsigned int n)\n+{\n+  p = (double *) __builtin_assume_aligned (p, sizeof (double) * 2);\n+  q = (double *) __builtin_assume_aligned (q, sizeof (double) * 2);\n+  for (unsigned int i = start & -2; i < n; i += 2)\n+    {\n+      double a = q[i] + p[i];\n+      double b = q[i + 1] + p[i + 1];\n+      q[i] = a;\n+      q[i + 1] = b;\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"basic block vectorized\" 4 \"slp1\" } } */"}, {"sha": "1aa3c8d1bac48ac81d33b201a282fad0f56041ef", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-pr81635-4.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fff2290073cc2d57dcade125227b74cd27c48066/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-pr81635-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fff2290073cc2d57dcade125227b74cd27c48066/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-pr81635-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-pr81635-4.c?ref=fff2290073cc2d57dcade125227b74cd27c48066", "patch": "@@ -0,0 +1,47 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-fno-tree-loop-vectorize\" } */\n+/* { dg-require-effective-target lp64 } */\n+\n+void\n+f1 (double *p, double *q, unsigned int n)\n+{\n+  p = (double *) __builtin_assume_aligned (p, sizeof (double) * 2);\n+  q = (double *) __builtin_assume_aligned (q, sizeof (double) * 2);\n+  for (unsigned int i = 0; i < n; i += 1)\n+    {\n+      double a = q[i] + p[i];\n+      double b = q[i + 1] + p[i + 1];\n+      q[i] = a;\n+      q[i + 1] = b;\n+    }\n+}\n+\n+void\n+f2 (double *p, double *q, unsigned int n)\n+{\n+  p = (double *) __builtin_assume_aligned (p, sizeof (double) * 2);\n+  q = (double *) __builtin_assume_aligned (q, sizeof (double) * 2);\n+  for (unsigned int i = 0; i < n; i += 3)\n+    {\n+      double a = q[i] + p[i];\n+      double b = q[i + 1] + p[i + 1];\n+      q[i] = a;\n+      q[i + 1] = b;\n+    }\n+}\n+\n+void\n+f3 (double *p, double *q, unsigned int start, unsigned int n)\n+{\n+  p = (double *) __builtin_assume_aligned (p, sizeof (double) * 2);\n+  q = (double *) __builtin_assume_aligned (q, sizeof (double) * 2);\n+  for (unsigned int i = start; i < n; i += 2)\n+    {\n+      double a = q[i] + p[i];\n+      double b = q[i + 1] + p[i + 1];\n+      q[i] = a;\n+      q[i + 1] = b;\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"basic block vectorized\" \"slp1\" } } */"}, {"sha": "fdb2ac1b8454e4a013b83547b1fd9ab27dfc5668", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fff2290073cc2d57dcade125227b74cd27c48066/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fff2290073cc2d57dcade125227b74cd27c48066/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=fff2290073cc2d57dcade125227b74cd27c48066", "patch": "@@ -721,15 +721,20 @@ split_constant_offset_1 (tree type, tree op0, enum tree_code code, tree op1,\n \t\tif (TREE_CODE (tmp_var) != SSA_NAME)\n \t\t  return false;\n \t\twide_int var_min, var_max;\n-\t\tif (get_range_info (tmp_var, &var_min, &var_max) != VR_RANGE)\n+\t\tvalue_range_type vr_type = get_range_info (tmp_var, &var_min,\n+\t\t\t\t\t\t\t   &var_max);\n+\t\twide_int var_nonzero = get_nonzero_bits (tmp_var);\n+\t\tsignop sgn = TYPE_SIGN (itype);\n+\t\tif (intersect_range_with_nonzero_bits (vr_type, &var_min,\n+\t\t\t\t\t\t       &var_max, var_nonzero,\n+\t\t\t\t\t\t       sgn) != VR_RANGE)\n \t\t  return false;\n \n \t\t/* See whether the range of OP0 (i.e. TMP_VAR + TMP_OFF)\n \t\t   is known to be [A + TMP_OFF, B + TMP_OFF], with all\n \t\t   operations done in ITYPE.  The addition must overflow\n \t\t   at both ends of the range or at neither.  */\n \t\tbool overflow[2];\n-\t\tsignop sgn = TYPE_SIGN (itype);\n \t\tunsigned int prec = TYPE_PRECISION (itype);\n \t\twide_int woff = wi::to_wide (tmp_off, prec);\n \t\twide_int op0_min = wi::add (var_min, woff, sgn, &overflow[0]);"}, {"sha": "cba58e0279108293a2e8b923941512ded35bdac3", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fff2290073cc2d57dcade125227b74cd27c48066/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fff2290073cc2d57dcade125227b74cd27c48066/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=fff2290073cc2d57dcade125227b74cd27c48066", "patch": "@@ -171,6 +171,53 @@ vrp_val_is_min (const_tree val)\n \t      && operand_equal_p (val, type_min, 0)));\n }\n \n+/* VR_TYPE describes a range with mininum value *MIN and maximum\n+   value *MAX.  Restrict the range to the set of values that have\n+   no bits set outside NONZERO_BITS.  Update *MIN and *MAX and\n+   return the new range type.\n+\n+   SGN gives the sign of the values described by the range.  */\n+\n+enum value_range_type\n+intersect_range_with_nonzero_bits (enum value_range_type vr_type,\n+\t\t\t\t   wide_int *min, wide_int *max,\n+\t\t\t\t   const wide_int &nonzero_bits,\n+\t\t\t\t   signop sgn)\n+{\n+  if (vr_type == VR_RANGE)\n+    {\n+      *max = wi::round_down_for_mask (*max, nonzero_bits);\n+\n+      /* Check that the range contains at least one valid value.  */\n+      if (wi::gt_p (*min, *max, sgn))\n+\treturn VR_UNDEFINED;\n+\n+      *min = wi::round_up_for_mask (*min, nonzero_bits);\n+      gcc_checking_assert (wi::le_p (*min, *max, sgn));\n+    }\n+  if (vr_type == VR_ANTI_RANGE)\n+    {\n+      *max = wi::round_up_for_mask (*max, nonzero_bits);\n+\n+      /* If the calculation wrapped, we now have a VR_RANGE whose\n+\t lower bound is *MAX and whose upper bound is *MIN.  */\n+      if (wi::gt_p (*min, *max, sgn))\n+\t{\n+\t  std::swap (*min, *max);\n+\t  *max = wi::round_down_for_mask (*max, nonzero_bits);\n+\t  gcc_checking_assert (wi::le_p (*min, *max, sgn));\n+\t  return VR_RANGE;\n+\t}\n+\n+      *min = wi::round_down_for_mask (*min, nonzero_bits);\n+      gcc_checking_assert (wi::le_p (*min, *max, sgn));\n+\n+      /* Check whether we now have an empty set of values.  */\n+      if (*min - 1 == *max)\n+\treturn VR_UNDEFINED;\n+    }\n+  return vr_type;\n+}\n \n /* Set value range VR to VR_UNDEFINED.  */\n "}, {"sha": "d8f60be231122cb2f4b80ed4224f1903e6b405c4", "filename": "gcc/tree-vrp.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fff2290073cc2d57dcade125227b74cd27c48066/gcc%2Ftree-vrp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fff2290073cc2d57dcade125227b74cd27c48066/gcc%2Ftree-vrp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.h?ref=fff2290073cc2d57dcade125227b74cd27c48066", "patch": "@@ -61,6 +61,8 @@ extern void extract_range_from_unary_expr (value_range *vr,\n \t\t\t\t\t   tree op0_type);\n \n extern bool vrp_operand_equal_p (const_tree, const_tree);\n+extern enum value_range_type intersect_range_with_nonzero_bits\n+  (enum value_range_type, wide_int *, wide_int *, const wide_int &, signop);\n \n struct assert_info\n {"}, {"sha": "81731465137bff25a37d8760e63343e79ce59457", "filename": "gcc/wide-int.cc", "status": "modified", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fff2290073cc2d57dcade125227b74cd27c48066/gcc%2Fwide-int.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fff2290073cc2d57dcade125227b74cd27c48066/gcc%2Fwide-int.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fwide-int.cc?ref=fff2290073cc2d57dcade125227b74cd27c48066", "patch": "@@ -2132,6 +2132,70 @@ wi::only_sign_bit_p (const wide_int_ref &x)\n   return only_sign_bit_p (x, x.precision);\n }\n \n+/* Return VAL if VAL has no bits set outside MASK.  Otherwise round VAL\n+   down to the previous value that has no bits set outside MASK.\n+   This rounding wraps for signed values if VAL is negative and\n+   the top bit of MASK is clear.\n+\n+   For example, round_down_for_mask (6, 0xf1) would give 1 and\n+   round_down_for_mask (24, 0xf1) would give 17.  */\n+\n+wide_int\n+wi::round_down_for_mask (const wide_int &val, const wide_int &mask)\n+{\n+  /* Get the bits in VAL that are outside the mask.  */\n+  wide_int extra_bits = wi::bit_and_not (val, mask);\n+  if (extra_bits == 0)\n+    return val;\n+\n+  /* Get a mask that includes the top bit in EXTRA_BITS and is all 1s\n+     below that bit.  */\n+  unsigned int precision = val.get_precision ();\n+  wide_int lower_mask = wi::mask (precision - wi::clz (extra_bits),\n+\t\t\t\t  false, precision);\n+\n+  /* Clear the bits that aren't in MASK, but ensure that all bits\n+     in MASK below the top cleared bit are set.  */\n+  return (val & mask) | (mask & lower_mask);\n+}\n+\n+/* Return VAL if VAL has no bits set outside MASK.  Otherwise round VAL\n+   up to the next value that has no bits set outside MASK.  The rounding\n+   wraps if there are no suitable values greater than VAL.\n+\n+   For example, round_up_for_mask (6, 0xf1) would give 16 and\n+   round_up_for_mask (24, 0xf1) would give 32.  */\n+\n+wide_int\n+wi::round_up_for_mask (const wide_int &val, const wide_int &mask)\n+{\n+  /* Get the bits in VAL that are outside the mask.  */\n+  wide_int extra_bits = wi::bit_and_not (val, mask);\n+  if (extra_bits == 0)\n+    return val;\n+\n+  /* Get a mask that is all 1s above the top bit in EXTRA_BITS.  */\n+  unsigned int precision = val.get_precision ();\n+  wide_int upper_mask = wi::mask (precision - wi::clz (extra_bits),\n+\t\t\t\t  true, precision);\n+\n+  /* Get the bits of the mask that are above the top bit in EXTRA_BITS.  */\n+  upper_mask &= mask;\n+\n+  /* Conceptually we need to:\n+\n+     - clear bits of VAL outside UPPER_MASK\n+     - add the lowest bit in UPPER_MASK to VAL (or add 0 if UPPER_MASK is 0)\n+     - propagate the carry through the bits of VAL in UPPER_MASK\n+\n+     If (~VAL & UPPER_MASK) is nonzero, the carry eventually\n+     reaches that bit and the process leaves all lower bits clear.\n+     If (~VAL & UPPER_MASK) is zero then the result is also zero.  */\n+  wide_int tmp = wi::bit_and_not (upper_mask, val);\n+\n+  return (val | tmp) & -tmp;\n+}\n+\n /*\n  * Private utilities.\n  */\n@@ -2384,6 +2448,53 @@ test_overflow ()\n     }\n }\n \n+/* Test the round_{down,up}_for_mask functions.  */\n+\n+static void\n+test_round_for_mask ()\n+{\n+  unsigned int prec = 18;\n+  ASSERT_EQ (17, wi::round_down_for_mask (wi::shwi (17, prec),\n+\t\t\t\t\t  wi::shwi (0xf1, prec)));\n+  ASSERT_EQ (17, wi::round_up_for_mask (wi::shwi (17, prec),\n+\t\t\t\t\twi::shwi (0xf1, prec)));\n+\n+  ASSERT_EQ (1, wi::round_down_for_mask (wi::shwi (6, prec),\n+\t\t\t\t\t wi::shwi (0xf1, prec)));\n+  ASSERT_EQ (16, wi::round_up_for_mask (wi::shwi (6, prec),\n+\t\t\t\t\twi::shwi (0xf1, prec)));\n+\n+  ASSERT_EQ (17, wi::round_down_for_mask (wi::shwi (24, prec),\n+\t\t\t\t\t  wi::shwi (0xf1, prec)));\n+  ASSERT_EQ (32, wi::round_up_for_mask (wi::shwi (24, prec),\n+\t\t\t\t\twi::shwi (0xf1, prec)));\n+\n+  ASSERT_EQ (0x011, wi::round_down_for_mask (wi::shwi (0x22, prec),\n+\t\t\t\t\t     wi::shwi (0x111, prec)));\n+  ASSERT_EQ (0x100, wi::round_up_for_mask (wi::shwi (0x22, prec),\n+\t\t\t\t\t   wi::shwi (0x111, prec)));\n+\n+  ASSERT_EQ (100, wi::round_down_for_mask (wi::shwi (101, prec),\n+\t\t\t\t\t   wi::shwi (0xfc, prec)));\n+  ASSERT_EQ (104, wi::round_up_for_mask (wi::shwi (101, prec),\n+\t\t\t\t\t wi::shwi (0xfc, prec)));\n+\n+  ASSERT_EQ (0x2bc, wi::round_down_for_mask (wi::shwi (0x2c2, prec),\n+\t\t\t\t\t     wi::shwi (0xabc, prec)));\n+  ASSERT_EQ (0x800, wi::round_up_for_mask (wi::shwi (0x2c2, prec),\n+\t\t\t\t\t   wi::shwi (0xabc, prec)));\n+\n+  ASSERT_EQ (0xabc, wi::round_down_for_mask (wi::shwi (0xabd, prec),\n+\t\t\t\t\t     wi::shwi (0xabc, prec)));\n+  ASSERT_EQ (0, wi::round_up_for_mask (wi::shwi (0xabd, prec),\n+\t\t\t\t       wi::shwi (0xabc, prec)));\n+\n+  ASSERT_EQ (0xabc, wi::round_down_for_mask (wi::shwi (0x1000, prec),\n+\t\t\t\t\t     wi::shwi (0xabc, prec)));\n+  ASSERT_EQ (0, wi::round_up_for_mask (wi::shwi (0x1000, prec),\n+\t\t\t\t       wi::shwi (0xabc, prec)));\n+}\n+\n /* Run all of the selftests within this file, for all value types.  */\n \n void\n@@ -2393,6 +2504,7 @@ wide_int_cc_tests ()\n   run_all_wide_int_tests <offset_int> ();\n   run_all_wide_int_tests <widest_int> ();\n   test_overflow ();\n+  test_round_for_mask ();\n }\n \n } // namespace selftest"}, {"sha": "e93b36ef07af25d710e0bf5d4c68d7fc13f742ca", "filename": "gcc/wide-int.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fff2290073cc2d57dcade125227b74cd27c48066/gcc%2Fwide-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fff2290073cc2d57dcade125227b74cd27c48066/gcc%2Fwide-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fwide-int.h?ref=fff2290073cc2d57dcade125227b74cd27c48066", "patch": "@@ -3308,6 +3308,8 @@ namespace wi\n   wide_int set_bit_in_zero (unsigned int, unsigned int);\n   wide_int insert (const wide_int &x, const wide_int &y, unsigned int,\n \t\t   unsigned int);\n+  wide_int round_down_for_mask (const wide_int &, const wide_int &);\n+  wide_int round_up_for_mask (const wide_int &, const wide_int &);\n \n   template <typename T>\n   T mask (unsigned int, bool);"}]}