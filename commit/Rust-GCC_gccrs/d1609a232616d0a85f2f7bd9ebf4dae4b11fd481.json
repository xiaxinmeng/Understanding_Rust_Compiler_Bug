{"sha": "d1609a232616d0a85f2f7bd9ebf4dae4b11fd481", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDE2MDlhMjMyNjE2ZDBhODVmMmY3YmQ5ZWJmNGRhZTRiMTFmZDQ4MQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2017-06-12T03:25:04Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2017-06-12T03:25:04Z"}, "message": "elf.c (backtrace_initialize): Always set *fileline_fn.\n\n\t* elf.c (backtrace_initialize): Always set *fileline_fn.\n\t* ttest.c: New file.\n\t* btest.c: Move support functions into testlib.c.  Change calls to\n\tcheck to pass file name.\n\t* testlib.c: New file, copied from (part of) btest.c.\n\t* testlib.h: New file, declarations for testlib.c.\n\t* edtest.c: Use testlib.h and testlib.c.\n\t* configure.ac: Test for -pthread, set HAVE_PTHREAD conditional.\n\t* Makefile.am (btest_SOURCES): Add testlib.c.\n\t(edtest_SOURCES): Likewise.\n\t(CHECK_PROGRAMS): Add ttest if HAVE_PTHREAD.\n\t(ttest_SOURCES, ttest_CFLAGS, ttest_LDADD): Define.\n\t* configure, Makefile.in: Rebuild.\n\nFrom-SVN: r249111", "tree": {"sha": "9b4b2fbd658631dc5cb019d57ba0843423218b4b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9b4b2fbd658631dc5cb019d57ba0843423218b4b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d1609a232616d0a85f2f7bd9ebf4dae4b11fd481", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1609a232616d0a85f2f7bd9ebf4dae4b11fd481", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d1609a232616d0a85f2f7bd9ebf4dae4b11fd481", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1609a232616d0a85f2f7bd9ebf4dae4b11fd481/comments", "author": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1e7a4be3a1f37e9feb5b5b3a6a1f9a31d7a2cd7e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e7a4be3a1f37e9feb5b5b3a6a1f9a31d7a2cd7e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e7a4be3a1f37e9feb5b5b3a6a1f9a31d7a2cd7e"}], "stats": {"total": 1076, "additions": 656, "deletions": 420}, "files": [{"sha": "15e7017a490576ff4f35ae22e32ece1b3f934515", "filename": "libbacktrace/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1609a232616d0a85f2f7bd9ebf4dae4b11fd481/libbacktrace%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1609a232616d0a85f2f7bd9ebf4dae4b11fd481/libbacktrace%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2FChangeLog?ref=d1609a232616d0a85f2f7bd9ebf4dae4b11fd481", "patch": "@@ -1,3 +1,19 @@\n+2017-06-11  Ian Lance Taylor  <iant@golang.org>\n+\n+\t* elf.c (backtrace_initialize): Always set *fileline_fn.\n+\t* ttest.c: New file.\n+\t* btest.c: Move support functions into testlib.c.  Change calls to\n+\tcheck to pass file name.\n+\t* testlib.c: New file, copied from (part of) btest.c.\n+\t* testlib.h: New file, declarations for testlib.c.\n+\t* edtest.c: Use testlib.h and testlib.c.\n+\t* configure.ac: Test for -pthread, set HAVE_PTHREAD conditional.\n+\t* Makefile.am (btest_SOURCES): Add testlib.c.\n+\t(edtest_SOURCES): Likewise.\n+\t(CHECK_PROGRAMS): Add ttest if HAVE_PTHREAD.\n+\t(ttest_SOURCES, ttest_CFLAGS, ttest_LDADD): Define.\n+\t* configure, Makefile.in: Rebuild.\n+\n 2017-05-19  Than McIntosh  <thanm@google.com>\n \n \t* dwarf.c (free_line_header): Don't free dirs if dirs_count == 0."}, {"sha": "640eeec5e22428cde304a8cf42d7745b48fbc670", "filename": "libbacktrace/Makefile.am", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1609a232616d0a85f2f7bd9ebf4dae4b11fd481/libbacktrace%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1609a232616d0a85f2f7bd9ebf4dae4b11fd481/libbacktrace%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2FMakefile.am?ref=d1609a232616d0a85f2f7bd9ebf4dae4b11fd481", "patch": "@@ -89,7 +89,7 @@ TESTS = $(check_PROGRAMS)\n \n if NATIVE\n \n-btest_SOURCES = btest.c\n+btest_SOURCES = btest.c testlib.c\n btest_CFLAGS = $(AM_CFLAGS) -g -O\n btest_LDADD = libbacktrace.la\n \n@@ -100,7 +100,7 @@ stest_LDADD = libbacktrace.la\n \n check_PROGRAMS += stest\n \n-edtest_SOURCES = edtest.c edtest2_build.c\n+edtest_SOURCES = edtest.c edtest2_build.c testlib.c\n edtest_LDADD = libbacktrace.la\n \n check_PROGRAMS += edtest\n@@ -111,6 +111,16 @@ gen_edtest2_build: $(srcdir)/edtest2.c\n \t$(SHELL) $(srcdir)/../move-if-change tmp-edtest2_build.c edtest2_build.c\n \techo timestamp > $@\n \n+if HAVE_PTHREAD\n+\n+check_PROGRAMS += ttest\n+\n+ttest_SOURCES = ttest.c testlib.c\n+ttest_CFLAGS = -pthread\n+ttest_LDADD = libbacktrace.la\n+\n+endif HAVE_PTHREAD\n+\n endif NATIVE\n \n # We can't use automake's automatic dependency tracking, because it"}, {"sha": "a57dc235b33d8c57cf5af834890e0d30343c2216", "filename": "libbacktrace/Makefile.in", "status": "modified", "additions": 43, "deletions": 6, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1609a232616d0a85f2f7bd9ebf4dae4b11fd481/libbacktrace%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1609a232616d0a85f2f7bd9ebf4dae4b11fd481/libbacktrace%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2FMakefile.in?ref=d1609a232616d0a85f2f7bd9ebf4dae4b11fd481", "patch": "@@ -83,8 +83,9 @@ POST_UNINSTALL = :\n build_triplet = @build@\n host_triplet = @host@\n target_triplet = @target@\n-check_PROGRAMS = $(am__EXEEXT_1)\n+check_PROGRAMS = $(am__EXEEXT_1) $(am__EXEEXT_2)\n @NATIVE_TRUE@am__append_1 = btest stest edtest\n+@HAVE_PTHREAD_TRUE@@NATIVE_TRUE@am__append_2 = ttest\n subdir = .\n DIST_COMMON = README ChangeLog $(srcdir)/Makefile.in \\\n \t$(srcdir)/Makefile.am $(top_srcdir)/configure \\\n@@ -115,19 +116,29 @@ am_libbacktrace_la_OBJECTS = atomic.lo dwarf.lo fileline.lo posix.lo \\\n libbacktrace_la_OBJECTS = $(am_libbacktrace_la_OBJECTS)\n @NATIVE_TRUE@am__EXEEXT_1 = btest$(EXEEXT) stest$(EXEEXT) \\\n @NATIVE_TRUE@\tedtest$(EXEEXT)\n-@NATIVE_TRUE@am_btest_OBJECTS = btest-btest.$(OBJEXT)\n+@HAVE_PTHREAD_TRUE@@NATIVE_TRUE@am__EXEEXT_2 = ttest$(EXEEXT)\n+@NATIVE_TRUE@am_btest_OBJECTS = btest-btest.$(OBJEXT) \\\n+@NATIVE_TRUE@\tbtest-testlib.$(OBJEXT)\n btest_OBJECTS = $(am_btest_OBJECTS)\n @NATIVE_TRUE@btest_DEPENDENCIES = libbacktrace.la\n btest_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n \t--mode=link $(CCLD) $(btest_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \\\n \t$(LDFLAGS) -o $@\n @NATIVE_TRUE@am_edtest_OBJECTS = edtest.$(OBJEXT) \\\n-@NATIVE_TRUE@\tedtest2_build.$(OBJEXT)\n+@NATIVE_TRUE@\tedtest2_build.$(OBJEXT) testlib.$(OBJEXT)\n edtest_OBJECTS = $(am_edtest_OBJECTS)\n @NATIVE_TRUE@edtest_DEPENDENCIES = libbacktrace.la\n @NATIVE_TRUE@am_stest_OBJECTS = stest.$(OBJEXT)\n stest_OBJECTS = $(am_stest_OBJECTS)\n @NATIVE_TRUE@stest_DEPENDENCIES = libbacktrace.la\n+@HAVE_PTHREAD_TRUE@@NATIVE_TRUE@am_ttest_OBJECTS =  \\\n+@HAVE_PTHREAD_TRUE@@NATIVE_TRUE@\tttest-ttest.$(OBJEXT) \\\n+@HAVE_PTHREAD_TRUE@@NATIVE_TRUE@\tttest-testlib.$(OBJEXT)\n+ttest_OBJECTS = $(am_ttest_OBJECTS)\n+@HAVE_PTHREAD_TRUE@@NATIVE_TRUE@ttest_DEPENDENCIES = libbacktrace.la\n+ttest_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n+\t--mode=link $(CCLD) $(ttest_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \\\n+\t$(LDFLAGS) -o $@\n DEFAULT_INCLUDES = -I.@am__isrc@\n depcomp =\n am__depfiles_maybe =\n@@ -141,7 +152,8 @@ LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n \t--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \\\n \t$(LDFLAGS) -o $@\n SOURCES = $(libbacktrace_la_SOURCES) $(EXTRA_libbacktrace_la_SOURCES) \\\n-\t$(btest_SOURCES) $(edtest_SOURCES) $(stest_SOURCES)\n+\t$(btest_SOURCES) $(edtest_SOURCES) $(stest_SOURCES) \\\n+\t$(ttest_SOURCES)\n MULTISRCTOP = \n MULTIBUILDTOP = \n MULTIDIRS = \n@@ -218,6 +230,7 @@ PACKAGE_URL = @PACKAGE_URL@\n PACKAGE_VERSION = @PACKAGE_VERSION@\n PATH_SEPARATOR = @PATH_SEPARATOR@\n PIC_FLAG = @PIC_FLAG@\n+PTHREAD_CFLAGS = @PTHREAD_CFLAGS@\n RANLIB = @RANLIB@\n SED = @SED@\n SET_MAKE = @SET_MAKE@\n@@ -330,13 +343,16 @@ libbacktrace_la_LIBADD = \\\n \n libbacktrace_la_DEPENDENCIES = $(libbacktrace_la_LIBADD)\n TESTS = $(check_PROGRAMS)\n-@NATIVE_TRUE@btest_SOURCES = btest.c\n+@NATIVE_TRUE@btest_SOURCES = btest.c testlib.c\n @NATIVE_TRUE@btest_CFLAGS = $(AM_CFLAGS) -g -O\n @NATIVE_TRUE@btest_LDADD = libbacktrace.la\n @NATIVE_TRUE@stest_SOURCES = stest.c\n @NATIVE_TRUE@stest_LDADD = libbacktrace.la\n-@NATIVE_TRUE@edtest_SOURCES = edtest.c edtest2_build.c\n+@NATIVE_TRUE@edtest_SOURCES = edtest.c edtest2_build.c testlib.c\n @NATIVE_TRUE@edtest_LDADD = libbacktrace.la\n+@HAVE_PTHREAD_TRUE@@NATIVE_TRUE@ttest_SOURCES = ttest.c testlib.c\n+@HAVE_PTHREAD_TRUE@@NATIVE_TRUE@ttest_CFLAGS = -pthread\n+@HAVE_PTHREAD_TRUE@@NATIVE_TRUE@ttest_LDADD = libbacktrace.la\n \n # We can't use automake's automatic dependency tracking, because it\n # breaks when using bootstrap-lean.  Automatic dependency tracking\n@@ -435,6 +451,9 @@ edtest$(EXEEXT): $(edtest_OBJECTS) $(edtest_DEPENDENCIES) $(EXTRA_edtest_DEPENDE\n stest$(EXEEXT): $(stest_OBJECTS) $(stest_DEPENDENCIES) $(EXTRA_stest_DEPENDENCIES) \n \t@rm -f stest$(EXEEXT)\n \t$(LINK) $(stest_OBJECTS) $(stest_LDADD) $(LIBS)\n+ttest$(EXEEXT): $(ttest_OBJECTS) $(ttest_DEPENDENCIES) $(EXTRA_ttest_DEPENDENCIES) \n+\t@rm -f ttest$(EXEEXT)\n+\t$(ttest_LINK) $(ttest_OBJECTS) $(ttest_LDADD) $(LIBS)\n \n mostlyclean-compile:\n \t-rm -f *.$(OBJEXT)\n@@ -457,6 +476,24 @@ btest-btest.o: btest.c\n btest-btest.obj: btest.c\n \t$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(btest_CFLAGS) $(CFLAGS) -c -o btest-btest.obj `if test -f 'btest.c'; then $(CYGPATH_W) 'btest.c'; else $(CYGPATH_W) '$(srcdir)/btest.c'; fi`\n \n+btest-testlib.o: testlib.c\n+\t$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(btest_CFLAGS) $(CFLAGS) -c -o btest-testlib.o `test -f 'testlib.c' || echo '$(srcdir)/'`testlib.c\n+\n+btest-testlib.obj: testlib.c\n+\t$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(btest_CFLAGS) $(CFLAGS) -c -o btest-testlib.obj `if test -f 'testlib.c'; then $(CYGPATH_W) 'testlib.c'; else $(CYGPATH_W) '$(srcdir)/testlib.c'; fi`\n+\n+ttest-ttest.o: ttest.c\n+\t$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ttest_CFLAGS) $(CFLAGS) -c -o ttest-ttest.o `test -f 'ttest.c' || echo '$(srcdir)/'`ttest.c\n+\n+ttest-ttest.obj: ttest.c\n+\t$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ttest_CFLAGS) $(CFLAGS) -c -o ttest-ttest.obj `if test -f 'ttest.c'; then $(CYGPATH_W) 'ttest.c'; else $(CYGPATH_W) '$(srcdir)/ttest.c'; fi`\n+\n+ttest-testlib.o: testlib.c\n+\t$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ttest_CFLAGS) $(CFLAGS) -c -o ttest-testlib.o `test -f 'testlib.c' || echo '$(srcdir)/'`testlib.c\n+\n+ttest-testlib.obj: testlib.c\n+\t$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(ttest_CFLAGS) $(CFLAGS) -c -o ttest-testlib.obj `if test -f 'testlib.c'; then $(CYGPATH_W) 'testlib.c'; else $(CYGPATH_W) '$(srcdir)/testlib.c'; fi`\n+\n mostlyclean-libtool:\n \t-rm -f *.lo\n "}, {"sha": "30d9e14526cf69d29e250d5f62b9619dc5d823e9", "filename": "libbacktrace/btest.c", "status": "modified", "additions": 13, "deletions": 254, "changes": 267, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1609a232616d0a85f2f7bd9ebf4dae4b11fd481/libbacktrace%2Fbtest.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1609a232616d0a85f2f7bd9ebf4dae4b11fd481/libbacktrace%2Fbtest.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Fbtest.c?ref=d1609a232616d0a85f2f7bd9ebf4dae4b11fd481", "patch": "@@ -43,237 +43,7 @@ POSSIBILITY OF SUCH DAMAGE.  */\n #include \"backtrace.h\"\n #include \"backtrace-supported.h\"\n \n-/* Portable attribute syntax.  Actually some of these tests probably\n-   won't work if the attributes are not recognized.  */\n-\n-#ifndef GCC_VERSION\n-# define GCC_VERSION (__GNUC__ * 1000 + __GNUC_MINOR__)\n-#endif\n-\n-#if (GCC_VERSION < 2007)\n-# define __attribute__(x)\n-#endif\n-\n-#ifndef ATTRIBUTE_UNUSED\n-# define ATTRIBUTE_UNUSED __attribute__ ((__unused__))\n-#endif\n-\n-/* Used to collect backtrace info.  */\n-\n-struct info\n-{\n-  char *filename;\n-  int lineno;\n-  char *function;\n-};\n-\n-/* Passed to backtrace callback function.  */\n-\n-struct bdata\n-{\n-  struct info *all;\n-  size_t index;\n-  size_t max;\n-  int failed;\n-};\n-\n-/* Passed to backtrace_simple callback function.  */\n-\n-struct sdata\n-{\n-  uintptr_t *addrs;\n-  size_t index;\n-  size_t max;\n-  int failed;\n-};\n-\n-/* Passed to backtrace_syminfo callback function.  */\n-\n-struct symdata\n-{\n-  const char *name;\n-  uintptr_t val, size;\n-  int failed;\n-};\n-\n-/* The backtrace state.  */\n-\n-static void *state;\n-\n-/* The number of failures.  */\n-\n-static int failures;\n-\n-/* Return the base name in a path.  */\n-\n-static const char *\n-base (const char *p)\n-{\n-  const char *last;\n-  const char *s;\n-\n-  last = NULL;\n-  for (s = p; *s != '\\0'; ++s)\n-    {\n-      if (IS_DIR_SEPARATOR (*s))\n-\tlast = s + 1;\n-    }\n-  return last != NULL ? last : p;\n-}\n-\n-/* Check an entry in a struct info array.  */\n-\n-static void\n-check (const char *name, int index, const struct info *all, int want_lineno,\n-       const char *want_function, int *failed)\n-{\n-  if (*failed)\n-    return;\n-  if (all[index].filename == NULL || all[index].function == NULL)\n-    {\n-      fprintf (stderr, \"%s: [%d]: missing file name or function name\\n\",\n-\t       name, index);\n-      *failed = 1;\n-      return;\n-    }\n-  if (strcmp (base (all[index].filename), \"btest.c\") != 0)\n-    {\n-      fprintf (stderr, \"%s: [%d]: got %s expected test.c\\n\", name, index,\n-\t       all[index].filename);\n-      *failed = 1;\n-    }\n-  if (all[index].lineno != want_lineno)\n-    {\n-      fprintf (stderr, \"%s: [%d]: got %d expected %d\\n\", name, index,\n-\t       all[index].lineno, want_lineno);\n-      *failed = 1;\n-    }\n-  if (strcmp (all[index].function, want_function) != 0)\n-    {\n-      fprintf (stderr, \"%s: [%d]: got %s expected %s\\n\", name, index,\n-\t       all[index].function, want_function);\n-      *failed = 1;\n-    }\n-}\n-\n-/* The backtrace callback function.  */\n-\n-static int\n-callback_one (void *vdata, uintptr_t pc ATTRIBUTE_UNUSED,\n-\t      const char *filename, int lineno, const char *function)\n-{\n-  struct bdata *data = (struct bdata *) vdata;\n-  struct info *p;\n-\n-  if (data->index >= data->max)\n-    {\n-      fprintf (stderr, \"callback_one: callback called too many times\\n\");\n-      data->failed = 1;\n-      return 1;\n-    }\n-\n-  p = &data->all[data->index];\n-  if (filename == NULL)\n-    p->filename = NULL;\n-  else\n-    {\n-      p->filename = strdup (filename);\n-      assert (p->filename != NULL);\n-    }\n-  p->lineno = lineno;\n-  if (function == NULL)\n-    p->function = NULL;\n-  else\n-    {\n-      p->function = strdup (function);\n-      assert (p->function != NULL);\n-    }\n-  ++data->index;\n-\n-  return 0;\n-}\n-\n-/* An error callback passed to backtrace.  */\n-\n-static void\n-error_callback_one (void *vdata, const char *msg, int errnum)\n-{\n-  struct bdata *data = (struct bdata *) vdata;\n-\n-  fprintf (stderr, \"%s\", msg);\n-  if (errnum > 0)\n-    fprintf (stderr, \": %s\", strerror (errnum));\n-  fprintf (stderr, \"\\n\");\n-  data->failed = 1;\n-}\n-\n-/* The backtrace_simple callback function.  */\n-\n-static int\n-callback_two (void *vdata, uintptr_t pc)\n-{\n-  struct sdata *data = (struct sdata *) vdata;\n-\n-  if (data->index >= data->max)\n-    {\n-      fprintf (stderr, \"callback_two: callback called too many times\\n\");\n-      data->failed = 1;\n-      return 1;\n-    }\n-\n-  data->addrs[data->index] = pc;\n-  ++data->index;\n-\n-  return 0;\n-}\n-\n-/* An error callback passed to backtrace_simple.  */\n-\n-static void\n-error_callback_two (void *vdata, const char *msg, int errnum)\n-{\n-  struct sdata *data = (struct sdata *) vdata;\n-\n-  fprintf (stderr, \"%s\", msg);\n-  if (errnum > 0)\n-    fprintf (stderr, \": %s\", strerror (errnum));\n-  fprintf (stderr, \"\\n\");\n-  data->failed = 1;\n-}\n-\n-/* The backtrace_syminfo callback function.  */\n-\n-static void\n-callback_three (void *vdata, uintptr_t pc ATTRIBUTE_UNUSED,\n-\t\tconst char *symname, uintptr_t symval,\n-\t\tuintptr_t symsize)\n-{\n-  struct symdata *data = (struct symdata *) vdata;\n-\n-  if (symname == NULL)\n-    data->name = NULL;\n-  else\n-    {\n-      data->name = strdup (symname);\n-      assert (data->name != NULL);\n-    }\n-  data->val = symval;\n-  data->size = symsize;\n-}\n-\n-/* The backtrace_syminfo error callback function.  */\n-\n-static void\n-error_callback_three (void *vdata, const char *msg, int errnum)\n-{\n-  struct symdata *data = (struct symdata *) vdata;\n-\n-  fprintf (stderr, \"%s\", msg);\n-  if (errnum > 0)\n-    fprintf (stderr, \": %s\", strerror (errnum));\n-  fprintf (stderr, \"\\n\");\n-  data->failed = 1;\n-}\n+#include \"testlib.h\"\n \n /* Test the backtrace function with non-inlined functions.  */\n \n@@ -325,9 +95,9 @@ f3 (int f1line, int f2line)\n       data.failed = 1;\n     }\n \n-  check (\"test1\", 0, all, f3line, \"f3\", &data.failed);\n-  check (\"test1\", 1, all, f2line, \"f2\", &data.failed);\n-  check (\"test1\", 2, all, f1line, \"test1\", &data.failed);\n+  check (\"test1\", 0, all, f3line, \"f3\", \"btest.c\", &data.failed);\n+  check (\"test1\", 1, all, f2line, \"f2\", \"btest.c\", &data.failed);\n+  check (\"test1\", 2, all, f1line, \"test1\", \"btest.c\", &data.failed);\n \n   printf (\"%s: backtrace_full noinline\\n\", data.failed ? \"FAIL\" : \"PASS\");\n \n@@ -377,9 +147,9 @@ f13 (int f1line, int f2line)\n       data.failed = 1;\n     }\n \n-  check (\"test2\", 0, all, f3line, \"f13\", &data.failed);\n-  check (\"test2\", 1, all, f2line, \"f12\", &data.failed);\n-  check (\"test2\", 2, all, f1line, \"test2\", &data.failed);\n+  check (\"test2\", 0, all, f3line, \"f13\", \"btest.c\", &data.failed);\n+  check (\"test2\", 1, all, f2line, \"f12\", \"btest.c\", &data.failed);\n+  check (\"test2\", 2, all, f1line, \"test2\", \"btest.c\", &data.failed);\n \n   printf (\"%s: backtrace_full inline\\n\", data.failed ? \"FAIL\" : \"PASS\");\n \n@@ -462,9 +232,9 @@ f23 (int f1line, int f2line)\n \t    }\n \t}\n \n-      check (\"test3\", 0, all, f3line, \"f23\", &bdata.failed);\n-      check (\"test3\", 1, all, f2line, \"f22\", &bdata.failed);\n-      check (\"test3\", 2, all, f1line, \"test3\", &bdata.failed);\n+      check (\"test3\", 0, all, f3line, \"f23\", \"btest.c\", &bdata.failed);\n+      check (\"test3\", 1, all, f2line, \"f22\", \"btest.c\", &bdata.failed);\n+      check (\"test3\", 2, all, f1line, \"test3\", \"btest.c\", &bdata.failed);\n \n       if (bdata.failed)\n \tdata.failed = 1;\n@@ -600,9 +370,9 @@ f33 (int f1line, int f2line)\n \t  bdata.failed = 1;\n \t}\n \n-      check (\"test4\", 0, all, f3line, \"f33\", &bdata.failed);\n-      check (\"test4\", 1, all, f2line, \"f32\", &bdata.failed);\n-      check (\"test4\", 2, all, f1line, \"test4\", &bdata.failed);\n+      check (\"test4\", 0, all, f3line, \"f33\", \"btest.c\", &bdata.failed);\n+      check (\"test4\", 1, all, f2line, \"f32\", \"btest.c\", &bdata.failed);\n+      check (\"test4\", 2, all, f1line, \"test4\", \"btest.c\", &bdata.failed);\n \n       if (bdata.failed)\n \tdata.failed = 1;\n@@ -686,17 +456,6 @@ test5 (void)\n   return failures;\n }\n \n-static void\n-error_callback_create (void *data ATTRIBUTE_UNUSED, const char *msg,\n-\t\t       int errnum)\n-{\n-  fprintf (stderr, \"%s\", msg);\n-  if (errnum > 0)\n-    fprintf (stderr, \": %s\", strerror (errnum));\n-  fprintf (stderr, \"\\n\");\n-  exit (EXIT_FAILURE);\n-}\n-\n /* Run all the tests.  */\n \n int"}, {"sha": "a9c75dab15fc0043c8f4623861ff43a739733564", "filename": "libbacktrace/configure", "status": "modified", "additions": 45, "deletions": 2, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1609a232616d0a85f2f7bd9ebf4dae4b11fd481/libbacktrace%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1609a232616d0a85f2f7bd9ebf4dae4b11fd481/libbacktrace%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Fconfigure?ref=d1609a232616d0a85f2f7bd9ebf4dae4b11fd481", "patch": "@@ -604,6 +604,9 @@ LTLIBOBJS\n LIBOBJS\n NATIVE_FALSE\n NATIVE_TRUE\n+HAVE_PTHREAD_FALSE\n+HAVE_PTHREAD_TRUE\n+PTHREAD_CFLAGS\n BACKTRACE_USES_MALLOC\n ALLOC_FILE\n VIEW_FILE\n@@ -11131,7 +11134,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 11134 \"configure\"\n+#line 11137 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -11237,7 +11240,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 11240 \"configure\"\n+#line 11243 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -12458,6 +12461,42 @@ $as_echo \"#define HAVE_GETEXECNAME 1\" >>confdefs.h\n \n fi\n \n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking whether -pthread is supported\" >&5\n+$as_echo_n \"checking whether -pthread is supported... \" >&6; }\n+if test \"${libgo_cv_lib_pthread+set}\" = set; then :\n+  $as_echo_n \"(cached) \" >&6\n+else\n+  CFLAGS_hold=$CFLAGS\n+CFLAGS=\"$CFLAGS -pthread\"\n+cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+int i;\n+_ACEOF\n+if ac_fn_c_try_compile \"$LINENO\"; then :\n+  libgo_cv_lib_pthread=yes\n+else\n+  libgo_cv_lib_pthread=no\n+fi\n+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n+CFLAGS=$CFLAGS_hold\n+fi\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $libgo_cv_lib_pthread\" >&5\n+$as_echo \"$libgo_cv_lib_pthread\" >&6; }\n+PTHREAD_CFLAGS=\n+if test \"$libgo_cv_lib_pthread\" = yes; then\n+  PTHREAD_CFLAGS=-pthread\n+fi\n+\n+\n+ if test \"$libgo_cv_lib_pthread\" = yes; then\n+  HAVE_PTHREAD_TRUE=\n+  HAVE_PTHREAD_FALSE='#'\n+else\n+  HAVE_PTHREAD_TRUE='#'\n+  HAVE_PTHREAD_FALSE=\n+fi\n+\n+\n { $as_echo \"$as_me:${as_lineno-$LINENO}: checking whether tests can run\" >&5\n $as_echo_n \"checking whether tests can run... \" >&6; }\n if test \"${libbacktrace_cv_sys_native+set}\" = set; then :\n@@ -12620,6 +12659,10 @@ if test -z \"${MAINTAINER_MODE_TRUE}\" && test -z \"${MAINTAINER_MODE_FALSE}\"; then\n   as_fn_error \"conditional \\\"MAINTAINER_MODE\\\" was never defined.\n Usually this means the macro was only invoked conditionally.\" \"$LINENO\" 5\n fi\n+if test -z \"${HAVE_PTHREAD_TRUE}\" && test -z \"${HAVE_PTHREAD_FALSE}\"; then\n+  as_fn_error \"conditional \\\"HAVE_PTHREAD\\\" was never defined.\n+Usually this means the macro was only invoked conditionally.\" \"$LINENO\" 5\n+fi\n if test -z \"${NATIVE_TRUE}\" && test -z \"${NATIVE_FALSE}\"; then\n   as_fn_error \"conditional \\\"NATIVE\\\" was never defined.\n Usually this means the macro was only invoked conditionally.\" \"$LINENO\" 5"}, {"sha": "75a8ed8f0ffc6a547bc44450fb9660f1ae89d0a4", "filename": "libbacktrace/configure.ac", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1609a232616d0a85f2f7bd9ebf4dae4b11fd481/libbacktrace%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1609a232616d0a85f2f7bd9ebf4dae4b11fd481/libbacktrace%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Fconfigure.ac?ref=d1609a232616d0a85f2f7bd9ebf4dae4b11fd481", "patch": "@@ -355,6 +355,23 @@ if test \"$have_getexecname\" = \"yes\"; then\n   AC_DEFINE(HAVE_GETEXECNAME, 1, [Define if getexecname is available.])\n fi\n \n+dnl Test whether the compiler supports the -pthread option.\n+AC_CACHE_CHECK([whether -pthread is supported],\n+[libgo_cv_lib_pthread],\n+[CFLAGS_hold=$CFLAGS\n+CFLAGS=\"$CFLAGS -pthread\"\n+AC_COMPILE_IFELSE([[int i;]],\n+[libgo_cv_lib_pthread=yes],\n+[libgo_cv_lib_pthread=no])\n+CFLAGS=$CFLAGS_hold])\n+PTHREAD_CFLAGS=\n+if test \"$libgo_cv_lib_pthread\" = yes; then\n+  PTHREAD_CFLAGS=-pthread\n+fi\n+AC_SUBST(PTHREAD_CFLAGS)\n+\n+AM_CONDITIONAL(HAVE_PTHREAD, test \"$libgo_cv_lib_pthread\" = yes)\n+\n AC_CACHE_CHECK([whether tests can run],\n   [libbacktrace_cv_sys_native],\n   [AC_RUN_IFELSE([AC_LANG_PROGRAM([], [return 0;])],"}, {"sha": "54c705cb1ba358231f40d574f54eaa963e23bedf", "filename": "libbacktrace/edtest.c", "status": "modified", "additions": 1, "deletions": 146, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1609a232616d0a85f2f7bd9ebf4dae4b11fd481/libbacktrace%2Fedtest.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1609a232616d0a85f2f7bd9ebf4dae4b11fd481/libbacktrace%2Fedtest.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Fedtest.c?ref=d1609a232616d0a85f2f7bd9ebf4dae4b11fd481", "patch": "@@ -41,19 +41,7 @@ POSSIBILITY OF SUCH DAMAGE.  */\n #include \"backtrace-supported.h\"\n #include \"internal.h\"\n \n-#if defined(__MSDOS__) || defined(_WIN32) || defined(__OS2__) || defined (__CYGWIN__)\n-# define IS_DIR_SEPARATOR(c) ((c) == '/' || (c) == '\\\\')\n-#else\n-# define IS_DIR_SEPARATOR(c) ((c) == '/')\n-#endif\n-\n-/* The backtrace state.  */\n-\n-static void *state;\n-\n-/* The number of failures.  */\n-\n-int failures = 0;\n+#include \"testlib.h\"\n \n static int test1 (void) __attribute__ ((noinline, unused));\n static int test1 (void) __attribute__ ((noinline, unused));\n@@ -68,128 +56,6 @@ test1 (void)\n   return f2 (__LINE__) + 1;\n }\n \n-/* Used to collect backtrace info.  */\n-\n-struct info\n-{\n-  char *filename;\n-  int lineno;\n-  char *function;\n-};\n-\n-/* Return the base name in a path.  */\n-\n-static const char *\n-base (const char *p)\n-{\n-  const char *last;\n-  const char *s;\n-\n-  last = NULL;\n-  for (s = p; *s != '\\0'; ++s)\n-    {\n-      if (IS_DIR_SEPARATOR (*s))\n-        last = s + 1;\n-    }\n-  return last != NULL ? last : p;\n-}\n-\n-/* Check an entry in a struct info array.  */\n-\n-static void\n-check (const char *name, int index, const struct info *all, int want_lineno,\n-       const char *want_function, const char *want_file, int *failed)\n-{\n-  if (*failed)\n-    return;\n-  if (all[index].filename == NULL || all[index].function == NULL)\n-    {\n-      fprintf (stderr, \"%s: [%d]: missing file name or function name\\n\",\n-               name, index);\n-      *failed = 1;\n-      return;\n-    }\n-  if (strcmp (base (all[index].filename), want_file) != 0)\n-    {\n-      fprintf (stderr, \"%s: [%d]: got %s expected %s\\n\", name, index,\n-               all[index].filename, want_file);\n-      *failed = 1;\n-    }\n-  if (all[index].lineno != want_lineno)\n-    {\n-      fprintf (stderr, \"%s: [%d]: got %d expected %d\\n\", name, index,\n-               all[index].lineno, want_lineno);\n-      *failed = 1;\n-    }\n-  if (strcmp (all[index].function, want_function) != 0)\n-    {\n-      fprintf (stderr, \"%s: [%d]: got %s expected %s\\n\", name, index,\n-               all[index].function, want_function);\n-      *failed = 1;\n-    }\n-}\n-\n-/* Passed to backtrace callback function.  */\n-\n-struct bdata\n-{\n-  struct info *all;\n-  size_t index;\n-  size_t max;\n-  int failed;\n-};\n-\n-/* An error callback passed to backtrace.  */\n-\n-static void\n-error_callback_one (void *vdata, const char *msg, int errnum)\n-{\n-  struct bdata *data = (struct bdata *) vdata;\n-\n-  fprintf (stderr, \"%s\", msg);\n-  if (errnum > 0)\n-    fprintf (stderr, \": %s\", strerror (errnum));\n-  fprintf (stderr, \"\\n\");\n-  data->failed = 1;\n-}\n-\n-/* The backtrace callback function.  */\n-\n-static int\n-callback_one (void *vdata, uintptr_t pc ATTRIBUTE_UNUSED,\n-              const char *filename, int lineno, const char *function)\n-{\n-  struct bdata *data = (struct bdata *) vdata;\n-  struct info *p;\n-\n-  if (data->index >= data->max)\n-    {\n-      fprintf (stderr, \"callback_one: callback called too many times\\n\");\n-      data->failed = 1;\n-      return 1;\n-    }\n-\n-  p = &data->all[data->index];\n-  if (filename == NULL)\n-    p->filename = NULL;\n-  else\n-    {\n-      p->filename = strdup (filename);\n-      assert (p->filename != NULL);\n-    }\n-  p->lineno = lineno;\n-  if (function == NULL)\n-    p->function = NULL;\n-  else\n-    {\n-      p->function = strdup (function);\n-      assert (p->function != NULL);\n-    }\n-  ++data->index;\n-\n-  return 0;\n-}\n-\n int\n f3 (int f1line, int f2line)\n {\n@@ -232,17 +98,6 @@ f3 (int f1line, int f2line)\n   return failures;\n }\n \n-static void\n-error_callback_create (void *data ATTRIBUTE_UNUSED, const char *msg,\n-                       int errnum)\n-{\n-  fprintf (stderr, \"%s\", msg);\n-  if (errnum > 0)\n-    fprintf (stderr, \": %s\", strerror (errnum));\n-  fprintf (stderr, \"\\n\");\n-  exit (EXIT_FAILURE);\n-}\n-\n int\n main (int argc ATTRIBUTE_UNUSED, char **argv ATTRIBUTE_UNUSED)\n {"}, {"sha": "8e169715d32eb0c2a631f0a4bf9094fdba0d8620", "filename": "libbacktrace/elf.c", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1609a232616d0a85f2f7bd9ebf4dae4b11fd481/libbacktrace%2Felf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1609a232616d0a85f2f7bd9ebf4dae4b11fd481/libbacktrace%2Felf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Felf.c?ref=d1609a232616d0a85f2f7bd9ebf4dae4b11fd481", "patch": "@@ -962,18 +962,12 @@ backtrace_initialize (struct backtrace_state *state, int descriptor,\n     }\n \n   if (!state->threaded)\n-    {\n-      if (state->fileline_fn == NULL || state->fileline_fn == elf_nodebug)\n-\t*fileline_fn = elf_fileline_fn;\n-    }\n+    *fileline_fn = state->fileline_fn;\n   else\n-    {\n-      fileline current_fn;\n+    *fileline_fn = backtrace_atomic_load_pointer (&state->fileline_fn);\n \n-      current_fn = backtrace_atomic_load_pointer (&state->fileline_fn);\n-      if (current_fn == NULL || current_fn == elf_nodebug)\n-\t*fileline_fn = elf_fileline_fn;\n-    }\n+  if (*fileline_fn == NULL || *fileline_fn == elf_nodebug)\n+    *fileline_fn = elf_fileline_fn;\n \n   return 1;\n }"}, {"sha": "05420cad5f3afe2b5c1330ab2760d6d616299ee4", "filename": "libbacktrace/testlib.c", "status": "added", "additions": 234, "deletions": 0, "changes": 234, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1609a232616d0a85f2f7bd9ebf4dae4b11fd481/libbacktrace%2Ftestlib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1609a232616d0a85f2f7bd9ebf4dae4b11fd481/libbacktrace%2Ftestlib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Ftestlib.c?ref=d1609a232616d0a85f2f7bd9ebf4dae4b11fd481", "patch": "@@ -0,0 +1,234 @@\n+/* testlib.c -- test functions for libbacktrace library\n+   Copyright (C) 2012-2017 Free Software Foundation, Inc.\n+   Written by Ian Lance Taylor, Google.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are\n+met:\n+\n+    (1) Redistributions of source code must retain the above copyright\n+    notice, this list of conditions and the following disclaimer.\n+\n+    (2) Redistributions in binary form must reproduce the above copyright\n+    notice, this list of conditions and the following disclaimer in\n+    the documentation and/or other materials provided with the\n+    distribution.\n+\n+    (3) The name of the author may not be used to\n+    endorse or promote products derived from this software without\n+    specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n+INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n+IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+POSSIBILITY OF SUCH DAMAGE.  */\n+\n+#include <assert.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#include \"filenames.h\"\n+\n+#include \"backtrace.h\"\n+\n+#include \"testlib.h\"\n+\n+/* The backtrace state.  */\n+\n+void *state;\n+\n+/* The number of failures.  */\n+\n+int failures;\n+\n+/* Return the base name in a path.  */\n+\n+const char *\n+base (const char *p)\n+{\n+  const char *last;\n+  const char *s;\n+\n+  last = NULL;\n+  for (s = p; *s != '\\0'; ++s)\n+    {\n+      if (IS_DIR_SEPARATOR (*s))\n+\tlast = s + 1;\n+    }\n+  return last != NULL ? last : p;\n+}\n+\n+/* Check an entry in a struct info array.  */\n+\n+void\n+check (const char *name, int index, const struct info *all, int want_lineno,\n+       const char *want_function, const char *want_file, int *failed)\n+{\n+  if (*failed)\n+    return;\n+  if (all[index].filename == NULL || all[index].function == NULL)\n+    {\n+      fprintf (stderr, \"%s: [%d]: missing file name or function name\\n\",\n+\t       name, index);\n+      *failed = 1;\n+      return;\n+    }\n+  if (strcmp (base (all[index].filename), want_file) != 0)\n+    {\n+      fprintf (stderr, \"%s: [%d]: got %s expected %s\\n\", name, index,\n+\t       all[index].filename, want_file);\n+      *failed = 1;\n+    }\n+  if (all[index].lineno != want_lineno)\n+    {\n+      fprintf (stderr, \"%s: [%d]: got %d expected %d\\n\", name, index,\n+\t       all[index].lineno, want_lineno);\n+      *failed = 1;\n+    }\n+  if (strcmp (all[index].function, want_function) != 0)\n+    {\n+      fprintf (stderr, \"%s: [%d]: got %s expected %s\\n\", name, index,\n+\t       all[index].function, want_function);\n+      *failed = 1;\n+    }\n+}\n+\n+/* The backtrace callback function.  */\n+\n+int\n+callback_one (void *vdata, uintptr_t pc ATTRIBUTE_UNUSED,\n+\t      const char *filename, int lineno, const char *function)\n+{\n+  struct bdata *data = (struct bdata *) vdata;\n+  struct info *p;\n+\n+  if (data->index >= data->max)\n+    {\n+      fprintf (stderr, \"callback_one: callback called too many times\\n\");\n+      data->failed = 1;\n+      return 1;\n+    }\n+\n+  p = &data->all[data->index];\n+  if (filename == NULL)\n+    p->filename = NULL;\n+  else\n+    {\n+      p->filename = strdup (filename);\n+      assert (p->filename != NULL);\n+    }\n+  p->lineno = lineno;\n+  if (function == NULL)\n+    p->function = NULL;\n+  else\n+    {\n+      p->function = strdup (function);\n+      assert (p->function != NULL);\n+    }\n+  ++data->index;\n+\n+  return 0;\n+}\n+\n+/* An error callback passed to backtrace.  */\n+\n+void\n+error_callback_one (void *vdata, const char *msg, int errnum)\n+{\n+  struct bdata *data = (struct bdata *) vdata;\n+\n+  fprintf (stderr, \"%s\", msg);\n+  if (errnum > 0)\n+    fprintf (stderr, \": %s\", strerror (errnum));\n+  fprintf (stderr, \"\\n\");\n+  data->failed = 1;\n+}\n+\n+/* The backtrace_simple callback function.  */\n+\n+int\n+callback_two (void *vdata, uintptr_t pc)\n+{\n+  struct sdata *data = (struct sdata *) vdata;\n+\n+  if (data->index >= data->max)\n+    {\n+      fprintf (stderr, \"callback_two: callback called too many times\\n\");\n+      data->failed = 1;\n+      return 1;\n+    }\n+\n+  data->addrs[data->index] = pc;\n+  ++data->index;\n+\n+  return 0;\n+}\n+\n+/* An error callback passed to backtrace_simple.  */\n+\n+void\n+error_callback_two (void *vdata, const char *msg, int errnum)\n+{\n+  struct sdata *data = (struct sdata *) vdata;\n+\n+  fprintf (stderr, \"%s\", msg);\n+  if (errnum > 0)\n+    fprintf (stderr, \": %s\", strerror (errnum));\n+  fprintf (stderr, \"\\n\");\n+  data->failed = 1;\n+}\n+\n+/* The backtrace_syminfo callback function.  */\n+\n+void\n+callback_three (void *vdata, uintptr_t pc ATTRIBUTE_UNUSED,\n+\t\tconst char *symname, uintptr_t symval,\n+\t\tuintptr_t symsize)\n+{\n+  struct symdata *data = (struct symdata *) vdata;\n+\n+  if (symname == NULL)\n+    data->name = NULL;\n+  else\n+    {\n+      data->name = strdup (symname);\n+      assert (data->name != NULL);\n+    }\n+  data->val = symval;\n+  data->size = symsize;\n+}\n+\n+/* The backtrace_syminfo error callback function.  */\n+\n+void\n+error_callback_three (void *vdata, const char *msg, int errnum)\n+{\n+  struct symdata *data = (struct symdata *) vdata;\n+\n+  fprintf (stderr, \"%s\", msg);\n+  if (errnum > 0)\n+    fprintf (stderr, \": %s\", strerror (errnum));\n+  fprintf (stderr, \"\\n\");\n+  data->failed = 1;\n+}\n+\n+/* The backtrace_create_state error callback function.  */\n+\n+void\n+error_callback_create (void *data ATTRIBUTE_UNUSED, const char *msg,\n+                       int errnum)\n+{\n+  fprintf (stderr, \"%s\", msg);\n+  if (errnum > 0)\n+    fprintf (stderr, \": %s\", strerror (errnum));\n+  fprintf (stderr, \"\\n\");\n+  exit (EXIT_FAILURE);\n+}"}, {"sha": "2bfe62f3daac4b25b3df42cfcd86e40826ddcf66", "filename": "libbacktrace/testlib.h", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1609a232616d0a85f2f7bd9ebf4dae4b11fd481/libbacktrace%2Ftestlib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1609a232616d0a85f2f7bd9ebf4dae4b11fd481/libbacktrace%2Ftestlib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Ftestlib.h?ref=d1609a232616d0a85f2f7bd9ebf4dae4b11fd481", "patch": "@@ -0,0 +1,110 @@\n+/* testlib.h -- Header for test functions for libbacktrace library\n+   Copyright (C) 2012-2017 Free Software Foundation, Inc.\n+   Written by Ian Lance Taylor, Google.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are\n+met:\n+\n+    (1) Redistributions of source code must retain the above copyright\n+    notice, this list of conditions and the following disclaimer.\n+\n+    (2) Redistributions in binary form must reproduce the above copyright\n+    notice, this list of conditions and the following disclaimer in\n+    the documentation and/or other materials provided with the\n+    distribution.\n+\n+    (3) The name of the author may not be used to\n+    endorse or promote products derived from this software without\n+    specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n+INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n+IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+POSSIBILITY OF SUCH DAMAGE.  */\n+\n+#ifndef LIBBACKTRACE_TESTLIB_H\n+#define LIBBACKTRACE_TESTLIB_H\n+\n+/* Portable attribute syntax.  Actually some of these tests probably\n+   won't work if the attributes are not recognized.  */\n+\n+#ifndef GCC_VERSION\n+# define GCC_VERSION (__GNUC__ * 1000 + __GNUC_MINOR__)\n+#endif\n+\n+#if (GCC_VERSION < 2007)\n+# define __attribute__(x)\n+#endif\n+\n+#ifndef ATTRIBUTE_UNUSED\n+# define ATTRIBUTE_UNUSED __attribute__ ((__unused__))\n+#endif\n+\n+/* Used to collect backtrace info.  */\n+\n+struct info\n+{\n+  char *filename;\n+  int lineno;\n+  char *function;\n+};\n+\n+/* Passed to backtrace callback function.  */\n+\n+struct bdata\n+{\n+  struct info *all;\n+  size_t index;\n+  size_t max;\n+  int failed;\n+};\n+\n+/* Passed to backtrace_simple callback function.  */\n+\n+struct sdata\n+{\n+  uintptr_t *addrs;\n+  size_t index;\n+  size_t max;\n+  int failed;\n+};\n+\n+/* Passed to backtrace_syminfo callback function.  */\n+\n+struct symdata\n+{\n+  const char *name;\n+  uintptr_t val, size;\n+  int failed;\n+};\n+\n+/* The backtrace state.  */\n+\n+extern void *state;\n+\n+/* The number of failures.  */\n+\n+extern int failures;\n+\n+extern const char *base (const char *p);\n+extern void check (const char *name, int index, const struct info *all,\n+\t\t   int want_lineno, const char *want_function,\n+\t\t   const char *want_file, int *failed);\n+extern int callback_one (void *, uintptr_t, const char *, int, const char *);\n+extern void error_callback_one (void *, const char *, int);\n+extern int callback_two (void *, uintptr_t);\n+extern void error_callback_two (void *, const char *, int);\n+extern void callback_three (void *, uintptr_t, const char *, uintptr_t,\n+\t\t\t    uintptr_t);\n+extern void error_callback_three (void *, const char *, int);\n+extern void error_callback_create (void *, const char *, int);\n+\n+#endif /* !defined(LIBBACKTRACE_TESTLIB_H) */"}, {"sha": "6c2d26cafebaf1256d3a4b1c5c9d7e98bc787a59", "filename": "libbacktrace/ttest.c", "status": "added", "additions": 161, "deletions": 0, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1609a232616d0a85f2f7bd9ebf4dae4b11fd481/libbacktrace%2Fttest.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1609a232616d0a85f2f7bd9ebf4dae4b11fd481/libbacktrace%2Fttest.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Fttest.c?ref=d1609a232616d0a85f2f7bd9ebf4dae4b11fd481", "patch": "@@ -0,0 +1,161 @@\n+/* ttest.c -- Test for libbacktrace library\n+   Copyright (C) 2017 Free Software Foundation, Inc.\n+   Written by Ian Lance Taylor, Google.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are\n+met:\n+\n+    (1) Redistributions of source code must retain the above copyright\n+    notice, this list of conditions and the following disclaimer.\n+\n+    (2) Redistributions in binary form must reproduce the above copyright\n+    notice, this list of conditions and the following disclaimer in\n+    the documentation and/or other materials provided with the\n+    distribution.\n+\n+    (3) The name of the author may not be used to\n+    endorse or promote products derived from this software without\n+    specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n+INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n+IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+POSSIBILITY OF SUCH DAMAGE.  */\n+\n+/* Test using the libbacktrace library from multiple threads.  */\n+\n+#include <assert.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#include <pthread.h>\n+\n+#include \"filenames.h\"\n+\n+#include \"backtrace.h\"\n+#include \"backtrace-supported.h\"\n+\n+#include \"testlib.h\"\n+\n+static int f2 (int) __attribute__ ((noinline));\n+static int f3 (int, int) __attribute__ ((noinline));\n+\n+/* Test that a simple backtrace works.  This is called via\n+   pthread_create.  It returns the number of failures, as void *.  */\n+\n+static void *\n+test1_thread (void *arg ATTRIBUTE_UNUSED)\n+{\n+  /* Returning a value here and elsewhere avoids a tailcall which\n+     would mess up the backtrace.  */\n+  return (void *) (uintptr_t) (f2 (__LINE__) - 2);\n+}\n+\n+static int\n+f2 (int f1line)\n+{\n+  return f3 (f1line, __LINE__) + 2;\n+}\n+\n+static int\n+f3 (int f1line, int f2line)\n+{\n+  struct info all[20];\n+  struct bdata data;\n+  int f3line;\n+  int i;\n+\n+  data.all = &all[0];\n+  data.index = 0;\n+  data.max = 20;\n+  data.failed = 0;\n+\n+  f3line = __LINE__ + 1;\n+  i = backtrace_full (state, 0, callback_one, error_callback_one, &data);\n+\n+  if (i != 0)\n+    {\n+      fprintf (stderr, \"test1: unexpected return value %d\\n\", i);\n+      data.failed = 1;\n+    }\n+\n+  if (data.index < 3)\n+    {\n+      fprintf (stderr,\n+\t       \"test1: not enough frames; got %zu, expected at least 3\\n\",\n+\t       data.index);\n+      data.failed = 1;\n+    }\n+\n+  check (\"test1\", 0, all, f3line, \"f3\", \"ttest.c\", &data.failed);\n+  check (\"test1\", 1, all, f2line, \"f2\", \"ttest.c\", &data.failed);\n+  check (\"test1\", 2, all, f1line, \"test1_thread\", \"ttest.c\", &data.failed);\n+\n+  return data.failed;\n+}\n+\n+/* Run the test with 10 threads simultaneously.  */\n+\n+#define THREAD_COUNT 10\n+\n+static void test1 (void) __attribute__ ((unused));\n+\n+static void\n+test1 (void)\n+{\n+  pthread_t atid[THREAD_COUNT];\n+  int i;\n+  int errnum;\n+  int this_fail;\n+  void *ret;\n+\n+  for (i = 0; i < THREAD_COUNT; i++)\n+    {\n+      errnum = pthread_create (&atid[i], NULL, test1_thread, NULL);\n+      if (errnum != 0)\n+\t{\n+\t  fprintf (stderr, \"pthread_create %d: %s\\n\", i, strerror (errnum));\n+\t  exit (EXIT_FAILURE);\n+\t}\n+    }\n+\n+  this_fail = 0;\n+  for (i = 0; i < THREAD_COUNT; i++)\n+    {\n+      errnum = pthread_join (atid[i], &ret);\n+      if (errnum != 0)\n+\t{\n+\t  fprintf (stderr, \"pthread_join %d: %s\\n\", i, strerror (errnum));\n+\t  exit (EXIT_FAILURE);\n+\t}\n+      this_fail += (int) (uintptr_t) ret;\n+    }\n+\n+  printf (\"%s: threaded backtrace_full noinline\\n\", this_fail > 0 ? \"FAIL\" : \"PASS\");\n+\n+  failures += this_fail;\n+}\n+\n+int\n+main (int argc ATTRIBUTE_UNUSED, char **argv)\n+{\n+  state = backtrace_create_state (argv[0], BACKTRACE_SUPPORTS_THREADS,\n+\t\t\t\t  error_callback_create, NULL);\n+\n+#if BACKTRACE_SUPPORTED\n+#if BACKTRACE_SUPPORTS_THREADS\n+  test1 ();\n+#endif\n+#endif\n+\n+  exit (failures ? EXIT_FAILURE : EXIT_SUCCESS);\n+}"}]}