{"sha": "bfeebecf52cc0591c439d1988ce52b78c34c2072", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmZlZWJlY2Y1MmNjMDU5MWM0MzlkMTk4OGNlNTJiNzhjMzRjMjA3Mg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2004-07-06T23:02:22Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-07-06T23:02:22Z"}, "message": "tree-sra.c (struct sra_walk_fns): Revert 2004-07-05 change.\n\n         * tree-sra.c (struct sra_walk_fns): Revert 2004-07-05 change.\n        (sra_walk_modify_expr, scan_init): Likewise.\n        (generate_element_zero): Check visited before scanning children.\n        (generate_element_init): Set visited on error.\n        (scalarize_init): Handle generate_element_init failure similar\n        to use_block_copy.\n\nFrom-SVN: r84177", "tree": {"sha": "1fe59d68f9cc5104992d35d4d89541f6013917aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1fe59d68f9cc5104992d35d4d89541f6013917aa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bfeebecf52cc0591c439d1988ce52b78c34c2072", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bfeebecf52cc0591c439d1988ce52b78c34c2072", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bfeebecf52cc0591c439d1988ce52b78c34c2072", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bfeebecf52cc0591c439d1988ce52b78c34c2072/comments", "author": null, "committer": null, "parents": [{"sha": "82b5e52a9e41fbc4893f2dd0d2ba99bb2db70f4c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82b5e52a9e41fbc4893f2dd0d2ba99bb2db70f4c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/82b5e52a9e41fbc4893f2dd0d2ba99bb2db70f4c"}], "stats": {"total": 78, "additions": 50, "deletions": 28}, "files": [{"sha": "6c8ed693719b3b1a460afe923b9bc60af30e850d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfeebecf52cc0591c439d1988ce52b78c34c2072/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfeebecf52cc0591c439d1988ce52b78c34c2072/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bfeebecf52cc0591c439d1988ce52b78c34c2072", "patch": "@@ -1,3 +1,12 @@\n+2004-07-06  Richard Henderson  <rth@redhat.com>\n+\n+\t* tree-sra.c (struct sra_walk_fns): Revert 2004-07-05 change.\n+\t(sra_walk_modify_expr, scan_init): Likewise.\n+\t(generate_element_zero): Check visited before scanning children.\n+\t(generate_element_init): Set visited on error.\n+\t(scalarize_init): Handle generate_element_init failure similar\n+\tto use_block_copy.\n+\n 2004-07-06  Joseph S. Myers  <jsm@polyomino.org.uk>\n \n \t* toplev.h (NO_FRONT_END_DIAG, ATTRIBUTE_GCC_FE_DIAG): Define."}, {"sha": "2e2e85a812aedfa782aedfaa91bda8518db454c4", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 41, "deletions": 28, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfeebecf52cc0591c439d1988ce52b78c34c2072/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfeebecf52cc0591c439d1988ce52b78c34c2072/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=bfeebecf52cc0591c439d1988ce52b78c34c2072", "patch": "@@ -569,9 +569,8 @@ struct sra_walk_fns\n \t\tblock_stmt_iterator *bsi);\n \n   /* Invoked when ELT is initialized from a constant.  VALUE may be NULL,\n-     in which case it should be treated as an empty CONSTRUCTOR.  Return\n-     false if we found a case we couldn't handle.  */\n-  bool (*init) (struct sra_elt *elt, tree value, block_stmt_iterator *bsi);\n+     in which case it should be treated as an empty CONSTRUCTOR.  */\n+  void (*init) (struct sra_elt *elt, tree value, block_stmt_iterator *bsi);\n \n   /* Invoked when we have a copy between one scalarizable reference ELT\n      and one non-scalarizable reference OTHER.  IS_OUTPUT is true if ELT\n@@ -770,21 +769,18 @@ sra_walk_modify_expr (tree expr, block_stmt_iterator *bsi,\n     {\n       /* If this is an assignment from a constant, or constructor, then\n \t we have access to all of the elements individually.  Invoke INIT.  */\n-      if ((TREE_CODE (rhs) == COMPLEX_EXPR\n-\t   || TREE_CODE (rhs) == COMPLEX_CST\n-\t   || TREE_CODE (rhs) == CONSTRUCTOR)\n-\t  && fns->init (lhs_elt, rhs, bsi))\n-\t;\n+      if (TREE_CODE (rhs) == COMPLEX_EXPR\n+\t  || TREE_CODE (rhs) == COMPLEX_CST\n+\t  || TREE_CODE (rhs) == CONSTRUCTOR)\n+\tfns->init (lhs_elt, rhs, bsi);\n \n       /* If this is an assignment from read-only memory, treat this as if\n \t we'd been passed the constructor directly.  Invoke INIT.  */\n       else if (TREE_CODE (rhs) == VAR_DECL\n \t       && TREE_STATIC (rhs)\n \t       && TREE_READONLY (rhs)\n-\t       && targetm.binds_local_p (rhs)\n-\t       && DECL_INITIAL (rhs)\n-\t       && fns->init (lhs_elt, DECL_INITIAL (rhs), bsi))\n-\t;\n+\t       && targetm.binds_local_p (rhs))\n+\tfns->init (lhs_elt, DECL_INITIAL (rhs), bsi);\n \n       /* If this is a copy from a non-scalarizable lvalue, invoke LDST.\n \t The lvalue requirement prevents us from trying to directly scalarize\n@@ -934,12 +930,11 @@ scan_copy (struct sra_elt *lhs_elt, struct sra_elt *rhs_elt,\n   rhs_elt->n_copies += 1;\n }\n \n-static bool\n+static void\n scan_init (struct sra_elt *lhs_elt, tree rhs ATTRIBUTE_UNUSED,\n \t   block_stmt_iterator *bsi ATTRIBUTE_UNUSED)\n {\n   lhs_elt->n_copies += 1;\n-  return true;\n }\n \n static void\n@@ -1490,12 +1485,16 @@ generate_element_zero (struct sra_elt *elt, tree *list_p)\n {\n   struct sra_elt *c;\n \n+  if (elt->visited)\n+    {\n+      elt->visited = false;\n+      return;\n+    }\n+\n   for (c = elt->children; c ; c = c->sibling)\n     generate_element_zero (c, list_p);\n \n-  if (elt->visited)\n-    elt->visited = false;\n-  else if (elt->replacement)\n+  if (elt->replacement)\n     {\n       tree t;\n \n@@ -1567,6 +1566,7 @@ generate_element_init (struct sra_elt *elt, tree init, tree *list_p)\n       break;\n \n     default:\n+      elt->visited = true;\n       result = false;\n     }\n \n@@ -1760,9 +1760,9 @@ scalarize_copy (struct sra_elt *lhs_elt, struct sra_elt *rhs_elt,\n /* Scalarize an INIT.  To recap, this is an assignment to a scalarizable\n    reference from some form of constructor: CONSTRUCTOR, COMPLEX_CST or\n    COMPLEX_EXPR.  If RHS is NULL, it should be treated as an empty\n-   CONSTRUCTOR.  Return false if we didn't handle this case.  */\n+   CONSTRUCTOR.  */\n \n-static bool\n+static void\n scalarize_init (struct sra_elt *lhs_elt, tree rhs, block_stmt_iterator *bsi)\n {\n   bool result = true;\n@@ -1776,28 +1776,41 @@ scalarize_init (struct sra_elt *lhs_elt, tree rhs, block_stmt_iterator *bsi)\n      a zero value.  Initialize the rest of the instantiated elements.  */\n   generate_element_zero (lhs_elt, &list);\n \n-  /* If we didn't generate anything or couldn't handle this case return.\n-     Say which it was.  */\n-  if (!result || list == NULL)\n-    return result;\n+  if (!result)\n+    {\n+      /* If we failed to convert the entire initializer, then we must\n+\t leave the structure assignment in place and must load values\n+\t from the structure into the slots for which we did not find\n+\t constants.  The easiest way to do this is to generate a complete\n+\t copy-out, and then follow that with the constant assignments\n+\t that we were able to build.  DCE will clean things up.  */\n+      tree list0 = NULL;\n+      generate_copy_inout (lhs_elt, true, generate_element_ref (lhs_elt),\n+\t\t\t   &list0);\n+      append_to_statement_list (list, &list0);\n+      list = list0;\n+    }\n \n-  if (lhs_elt->use_block_copy)\n+  if (lhs_elt->use_block_copy || !result)\n     {\n       /* Since LHS is not fully instantiated, we must leave the structure\n \t assignment in place.  Treating this case differently from a USE\n \t exposes constants to later optimizations.  */\n-      mark_all_v_defs (expr_first (list));\n-      sra_insert_after (bsi, list);\n+      if (list)\n+\t{\n+\t  mark_all_v_defs (expr_first (list));\n+\t  sra_insert_after (bsi, list);\n+\t}\n     }\n   else\n     {\n       /* The LHS is fully instantiated.  The list of initializations\n \t replaces the original structure assignment.  */\n+      if (!list)\n+\tabort ();\n       mark_all_v_defs (bsi_stmt (*bsi));\n       sra_replace (bsi, list);\n     }\n-\n-  return true;\n }\n \n /* A subroutine of scalarize_ldst called via walk_tree.  Set TREE_NO_TRAP"}]}