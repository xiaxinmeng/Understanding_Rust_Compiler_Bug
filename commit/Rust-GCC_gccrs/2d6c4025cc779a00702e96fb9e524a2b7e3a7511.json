{"sha": "2d6c4025cc779a00702e96fb9e524a2b7e3a7511", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmQ2YzQwMjVjYzc3OWEwMDcwMmU5NmZiOWU1MjRhMmI3ZTNhNzUxMQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@wasabisystems.com", "date": "2003-12-22T15:45:12Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2003-12-22T15:45:12Z"}, "message": "cp-demangle.c (CP_DYNAMIC_ARRAYS): Define if compiler supports dynamic arrays.\n\n\t* cp-demangle.c (CP_DYNAMIC_ARRAYS): Define if compiler supports\n\tdynamic arrays.\n\t(struct d_operator_info): Add len field.\n\t(struct d_builtin_type_info): Add len and java_len fields.\n\t(struct d_standard_sub_info): Add simple_len, full_len, and\n\tset_last_name_len fields.\n\t(struct d_comp): Add len field to s_string.\n\t(struct d_info): Add send, did_subs, and expansion fields.\n\t(d_append_string_constant): Define.\n\t(d_append_string): Remove.  Change all users to use\n\td_append_string_constant or d_append_buffer instead.\n\t(d_make_sub): Add len parameter.  Change all callers.\n\t(d_name): Increase expansion when substituting std::.\n\t(d_unqualified_name): Increase expansion for an operator.\n\t(d_number): Don't use multiplication for negative numbers.\n\t(d_identifier): Make sure there are enough characters in the\n\tstring for the specified length.  Adjust expansion for an\n\tanonymous namespace.\n\t(d_operators): Initialize len field.\n\t(d_special_name, d_ctor_dtor_name): Increase expansion.\n\t(d_builtin_types): Initialize len and java_len fields.\n\t(d_type): Increase expansion for a builtin type.\n\t(d_cv_qualifiers): Increase expansion for each qualifier.\n\t(d_bare_function_type): Decrease expansion when removing single\n\tvoid parameter.\n\t(d_template_param): Increment did_subs.\n\t(d_expression): Increase expansion for an operator.\n\t(d_expr_primary): Decrease expansion for a type we will print\n\tspecially.\n\t(standard_subs): Initialize new fields.\n\t(d_substitution): Increment did_subs when doing a normal\n\tsubstitution.  Increase expansion for a special substitution.\n\t(d_print): Add estimate parameter.  Change all callers.\n\t(d_print_comp) [D_COMP_NAME]: Handle C++ case inline.\n\t(d_print_comp) [D_COMP_BINARY]: Use length to avoid strcmp call.\n\t(d_print_java_identifier): Rename from d_print_identifier.  Handle\n\tonly Java case.  Change caller.\n\t(d_init_info): Change return type to void.  Change all callers.\n\tInitialize send, did_subs, and expansion fields.  Do not\n\tinitialize comps and subs fields.\n\t(d_demangle): Ifdef CP_DYNAMIC_ARRAYS, allocate comps and subs\n\tarrays on stack.  Make an estimate of the length of the demangled\n\tname.  Ifdef CP_DEMANGLE_DEBUG, print estimation failures.\n\t(is_ctor_or_dtor): Ifdef CP_DYNAMIC_ARRAYS, allocate comps and\n\tsubs arrays on stack.\n\nFrom-SVN: r74933", "tree": {"sha": "1430188ec40fbbf7da5a3ce4bbd32be29adb13e8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1430188ec40fbbf7da5a3ce4bbd32be29adb13e8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2d6c4025cc779a00702e96fb9e524a2b7e3a7511", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d6c4025cc779a00702e96fb9e524a2b7e3a7511", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2d6c4025cc779a00702e96fb9e524a2b7e3a7511", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d6c4025cc779a00702e96fb9e524a2b7e3a7511/comments", "author": null, "committer": null, "parents": [{"sha": "a827daa06b2335bb93c09c5a8753725f40a76ef4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a827daa06b2335bb93c09c5a8753725f40a76ef4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a827daa06b2335bb93c09c5a8753725f40a76ef4"}], "stats": {"total": 813, "additions": 522, "deletions": 291}, "files": [{"sha": "c1de8dec4957beaa1505e3bf44db50103c36322c", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d6c4025cc779a00702e96fb9e524a2b7e3a7511/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d6c4025cc779a00702e96fb9e524a2b7e3a7511/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=2d6c4025cc779a00702e96fb9e524a2b7e3a7511", "patch": "@@ -1,3 +1,51 @@\n+2003-12-22  Ian Lance Taylor  <ian@wasabisystems.com>\n+\n+\t* cp-demangle.c (CP_DYNAMIC_ARRAYS): Define if compiler supports\n+\tdynamic arrays.\n+\t(struct d_operator_info): Add len field.\n+\t(struct d_builtin_type_info): Add len and java_len fields.\n+\t(struct d_standard_sub_info): Add simple_len, full_len, and\n+\tset_last_name_len fields.\n+\t(struct d_comp): Add len field to s_string.\n+\t(struct d_info): Add send, did_subs, and expansion fields.\n+\t(d_append_string_constant): Define.\n+\t(d_append_string): Remove.  Change all users to use\n+\td_append_string_constant or d_append_buffer instead.\n+\t(d_make_sub): Add len parameter.  Change all callers.\n+\t(d_name): Increase expansion when substituting std::.\n+\t(d_unqualified_name): Increase expansion for an operator.\n+\t(d_number): Don't use multiplication for negative numbers.\n+\t(d_identifier): Make sure there are enough characters in the\n+\tstring for the specified length.  Adjust expansion for an\n+\tanonymous namespace.\n+\t(d_operators): Initialize len field.\n+\t(d_special_name, d_ctor_dtor_name): Increase expansion.\n+\t(d_builtin_types): Initialize len and java_len fields.\n+\t(d_type): Increase expansion for a builtin type.\n+\t(d_cv_qualifiers): Increase expansion for each qualifier.\n+\t(d_bare_function_type): Decrease expansion when removing single\n+\tvoid parameter.\n+\t(d_template_param): Increment did_subs.\n+\t(d_expression): Increase expansion for an operator.\n+\t(d_expr_primary): Decrease expansion for a type we will print\n+\tspecially.\n+\t(standard_subs): Initialize new fields.\n+\t(d_substitution): Increment did_subs when doing a normal\n+\tsubstitution.  Increase expansion for a special substitution.\n+\t(d_print): Add estimate parameter.  Change all callers.\n+\t(d_print_comp) [D_COMP_NAME]: Handle C++ case inline.\n+\t(d_print_comp) [D_COMP_BINARY]: Use length to avoid strcmp call.\n+\t(d_print_java_identifier): Rename from d_print_identifier.  Handle\n+\tonly Java case.  Change caller.\n+\t(d_init_info): Change return type to void.  Change all callers.\n+\tInitialize send, did_subs, and expansion fields.  Do not\n+\tinitialize comps and subs fields.\n+\t(d_demangle): Ifdef CP_DYNAMIC_ARRAYS, allocate comps and subs\n+\tarrays on stack.  Make an estimate of the length of the demangled\n+\tname.  Ifdef CP_DEMANGLE_DEBUG, print estimation failures.\n+\t(is_ctor_or_dtor): Ifdef CP_DYNAMIC_ARRAYS, allocate comps and\n+\tsubs arrays on stack.\n+\n 2003-12-20  Ian Lance Taylor  <ian@wasabisystems.com>\n \n \t* cp-demangle.c (d_identifier): In Java mode, skip an optional '$'"}, {"sha": "b54cbe2bc316b6c7c69898ad3a30712849c51e03", "filename": "libiberty/cp-demangle.c", "status": "modified", "additions": 474, "deletions": 291, "changes": 765, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d6c4025cc779a00702e96fb9e524a2b7e3a7511/libiberty%2Fcp-demangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d6c4025cc779a00702e96fb9e524a2b7e3a7511/libiberty%2Fcp-demangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fcp-demangle.c?ref=2d6c4025cc779a00702e96fb9e524a2b7e3a7511", "patch": "@@ -82,6 +82,20 @@\n #include \"libiberty.h\"\n #include \"demangle.h\"\n \n+/* See if the compiler supports dynamic arrays.  */\n+\n+#ifdef __GNUC__\n+#define CP_DYNAMIC_ARRAYS\n+#else\n+#ifdef __STDC__\n+#ifdef __STDC_VERSION__\n+#if __STDC_VERSION__ >= 199901L\n+#define CP_DYNAMIC_ARRAYS\n+#endif /* __STDC__VERSION >= 199901L */\n+#endif /* defined (__STDC_VERSION__) */\n+#endif /* defined (__STDC__) */\n+#endif /* ! defined (__GNUC__) */\n+\n /* We avoid pulling in the ctype tables, to prevent pulling in\n    additional unresolved symbols when this code is used in a library.\n    FIXME: Is this really a valid reason?  This comes from the original\n@@ -109,6 +123,8 @@ struct d_operator_info\n   const char *code;\n   /* Real name.  */\n   const char *name;\n+  /* Length of real name.  */\n+  int len;\n   /* Number of arguments.  */\n   int args;\n };\n@@ -135,8 +151,12 @@ struct d_builtin_type_info\n {\n   /* Type name.  */\n   const char *name;\n+  /* Length of type name.  */\n+  int len;\n   /* Type name when using Java.  */\n   const char *java_name;\n+  /* Length of java name.  */\n+  int java_len;\n   /* How to print a value of this type.  */\n   enum d_builtin_type_print print;\n };\n@@ -149,13 +169,19 @@ struct d_standard_sub_info\n   char code;\n   /* The simple string it expands to.  */\n   const char *simple_expansion;\n+  /* The length of the simple expansion.  */\n+  int simple_len;\n   /* The results of a full, verbose, expansion.  This is used when\n      qualifying a constructor/destructor, or when in verbose mode.  */\n   const char *full_expansion;\n+  /* The length of the full expansion.  */\n+  int full_len;\n   /* What to set the last_name field of d_info to; NULL if we should\n      not set it.  This is only relevant when qualifying a\n      constructor/destructor.  */\n   const char *set_last_name;\n+  /* The length of set_last_name.  */\n+  int set_last_name_len;\n };\n \n /* Component types found in mangled names.  */\n@@ -320,6 +346,7 @@ struct d_comp\n     struct\n     {\n       const char* string;\n+      int len;\n     } s_string;\n \n     /* For D_COMP_TEMPLATE_PARAM.  */\n@@ -347,6 +374,8 @@ struct d_info\n {\n   /* The string we are demangling.  */\n   const char *s;\n+  /* The end of the string we are demangling.  */\n+  const char *send;\n   /* The options passed to the demangler.  */\n   int options;\n   /* The next character in the string to consider.  */\n@@ -363,8 +392,16 @@ struct d_info\n   int next_sub;\n   /* The number of available entries in the subs array.  */\n   int num_subs;\n+  /* The number of substitutions which we actually made from the subs\n+     array, plus the number of template parameter references we\n+     saw.  */\n+  int did_subs;\n   /* The last name we saw, for constructors and destructors.  */\n   struct d_comp *last_name;\n+  /* A running total of the length of large expansions from the\n+     mangled name to the demangled name, such as standard\n+     substitutions and builtin types.  */\n+  int expansion;\n };\n \n #define d_peek_char(di) (*((di)->n))\n@@ -444,13 +481,8 @@ struct d_print_info\n     } \\\n   while (0)\n \n-#define d_append_string(dpi, s) \\\n-  do \\\n-    { \\\n-      size_t d_append_string_len = strlen (s); \\\n-      d_append_buffer ((dpi), (s), d_append_string_len); \\\n-    } \\\n-  while (0)\n+#define d_append_string_constant(dpi, s) \\\n+  d_append_buffer (dpi, (s), sizeof (s) - 1)\n \n #define d_last_char(dpi) \\\n   ((dpi)->buf == NULL || (dpi)->len == 0 ? '\\0' : (dpi)->buf[(dpi)->len - 1])\n@@ -478,7 +510,7 @@ static struct d_comp *d_make_dtor PARAMS ((struct d_info *,\n \t\t\t\t\t   enum gnu_v3_dtor_kinds,\n \t\t\t\t\t   struct d_comp *));\n static struct d_comp *d_make_template_param PARAMS ((struct d_info *, long));\n-static struct d_comp *d_make_sub PARAMS ((struct d_info *, const char *));\n+static struct d_comp *d_make_sub PARAMS ((struct d_info *, const char *, int));\n static struct d_comp *d_mangled_name PARAMS ((struct d_info *, int));\n static int has_return_type PARAMS ((struct d_comp *));\n static int is_ctor_dtor_or_conversion PARAMS ((struct d_comp *));\n@@ -516,11 +548,11 @@ static void d_print_append_char PARAMS ((struct d_print_info *, int));\n static void d_print_append_buffer PARAMS ((struct d_print_info *, const char *,\n \t\t\t\t\t   size_t));\n static void d_print_error PARAMS ((struct d_print_info *));\n-static char *d_print PARAMS ((int, const struct d_comp *, size_t *));\n+static char *d_print PARAMS ((int, const struct d_comp *, int, size_t *));\n static void d_print_comp PARAMS ((struct d_print_info *,\n \t\t\t\t  const struct d_comp *));\n-static void d_print_identifier PARAMS ((struct d_print_info *, const char *,\n-\t\t\t\t\tint));\n+static void d_print_java_identifier PARAMS ((struct d_print_info *,\n+\t\t\t\t\t     const char *, int));\n static void d_print_mod_list PARAMS ((struct d_print_info *,\n \t\t\t\t      struct d_print_mod *, int));\n static void d_print_mod PARAMS ((struct d_print_info *,\n@@ -535,7 +567,7 @@ static void d_print_expr_op PARAMS ((struct d_print_info *,\n \t\t\t\t     const struct d_comp *));\n static void d_print_cast PARAMS ((struct d_print_info *,\n \t\t\t\t  const struct d_comp *));\n-static int d_init_info PARAMS ((const char *, int, size_t, struct d_info *));\n+static void d_init_info PARAMS ((const char *, int, size_t, struct d_info *));\n static char *d_demangle PARAMS ((const char *, int, size_t *));\n \n #ifdef CP_DEMANGLE_DEBUG\n@@ -961,15 +993,19 @@ d_make_template_param (di, i)\n /* Add a new standard substitution component.  */\n \n static struct d_comp *\n-d_make_sub (di, name)\n+d_make_sub (di, name, len)\n      struct d_info *di;\n      const char *name;\n+     int len;\n {\n   struct d_comp *p;\n \n   p = d_make_empty (di, D_COMP_SUB_STD);\n   if (p != NULL)\n-    p->u.s_string.string = name;\n+    {\n+      p->u.s_string.string = name;\n+      p->u.s_string.len = len;\n+    }\n   return p;\n }\n \n@@ -1125,6 +1161,7 @@ d_name (di)\n \t    d_advance (di, 2);\n \t    dc = d_make_comp (di, D_COMP_QUAL_NAME, d_make_name (di, \"std\", 3),\n \t\t\t      d_unqualified_name (di));\n+\t    di->expansion += 3;\n \t    subst = 0;\n \t  }\n \n@@ -1275,7 +1312,14 @@ d_unqualified_name (di)\n   if (IS_DIGIT (peek))\n     return d_source_name (di);\n   else if (IS_LOWER (peek))\n-    return d_operator_name (di);\n+    {\n+      struct d_comp *ret;\n+\n+      ret = d_operator_name (di);\n+      if (ret != NULL && ret->type == D_COMP_OPERATOR)\n+\tdi->expansion += sizeof \"operator\" + ret->u.s_operator.op->len - 2;\n+      return ret;\n+    }\n   else if (peek == 'C' || peek == 'D')\n     return d_ctor_dtor_name (di);\n   else\n@@ -1305,15 +1349,15 @@ static long\n d_number (di)\n      struct d_info *di;\n {\n-  int sign;\n+  int negative;\n   char peek;\n   long ret;\n \n-  sign = 1;\n+  negative = 0;\n   peek = d_peek_char (di);\n   if (peek == 'n')\n     {\n-      sign = -1;\n+      negative = 1;\n       d_advance (di, 1);\n       peek = d_peek_char (di);\n     }\n@@ -1322,7 +1366,11 @@ d_number (di)\n   while (1)\n     {\n       if (! IS_DIGIT (peek))\n-\treturn ret * sign;\n+\t{\n+\t  if (negative)\n+\t    ret = - ret;\n+\t  return ret;\n+\t}\n       ret = ret * 10 + peek - '0';\n       d_advance (di, 1);\n       peek = d_peek_char (di);\n@@ -1339,6 +1387,10 @@ d_identifier (di, len)\n   const char *name;\n \n   name = d_str (di);\n+\n+  if (di->send - name < len)\n+    return NULL;\n+\n   d_advance (di, len);\n \n   /* A Java mangled name may have a trailing '$' if it is a C++\n@@ -1360,8 +1412,11 @@ d_identifier (di, len)\n       s = name + ANONYMOUS_NAMESPACE_PREFIX_LEN;\n       if ((*s == '.' || *s == '_' || *s == '$')\n \t  && s[1] == 'N')\n-\treturn d_make_name (di, \"(anonymous namespace)\",\n-\t\t\t    sizeof \"(anonymous namespace)\" - 1);\n+\t{\n+\t  di->expansion -= len - sizeof \"(anonymous namespace)\";\n+\t  return d_make_name (di, \"(anonymous namespace)\",\n+\t\t\t      sizeof \"(anonymous namespace)\" - 1);\n+\t}\n     }\n \n   return d_make_name (di, name, len);\n@@ -1372,57 +1427,59 @@ d_identifier (di, len)\n                  ::= v <digit> <source-name>\n */\n \n+#define NL(s) s, (sizeof s) - 1\n+\n static const struct d_operator_info d_operators[] =\n {\n-  { \"aN\", \"&=\",        2 },\n-  { \"aS\", \"=\",         2 },\n-  { \"aa\", \"&&\",        2 },\n-  { \"ad\", \"&\",         1 },\n-  { \"an\", \"&\",         2 },\n-  { \"cl\", \"()\",        0 },\n-  { \"cm\", \",\",         2 },\n-  { \"co\", \"~\",         1 },\n-  { \"dV\", \"/=\",        2 },\n-  { \"da\", \"delete[]\",  1 },\n-  { \"de\", \"*\",         1 },\n-  { \"dl\", \"delete\",    1 },\n-  { \"dv\", \"/\",         2 },\n-  { \"eO\", \"^=\",        2 },\n-  { \"eo\", \"^\",         2 },\n-  { \"eq\", \"==\",        2 },\n-  { \"ge\", \">=\",        2 },\n-  { \"gt\", \">\",         2 },\n-  { \"ix\", \"[]\",        2 },\n-  { \"lS\", \"<<=\",       2 },\n-  { \"le\", \"<=\",        2 },\n-  { \"ls\", \"<<\",        2 },\n-  { \"lt\", \"<\",         2 },\n-  { \"mI\", \"-=\",        2 },\n-  { \"mL\", \"*=\",        2 },\n-  { \"mi\", \"-\",         2 },\n-  { \"ml\", \"*\",         2 },\n-  { \"mm\", \"--\",        1 },\n-  { \"na\", \"new[]\",     1 },\n-  { \"ne\", \"!=\",        2 },\n-  { \"ng\", \"-\",         1 },\n-  { \"nt\", \"!\",         1 },\n-  { \"nw\", \"new\",       1 },\n-  { \"oR\", \"|=\",        2 },\n-  { \"oo\", \"||\",        2 },\n-  { \"or\", \"|\",         2 },\n-  { \"pL\", \"+=\",        2 },\n-  { \"pl\", \"+\",         2 },\n-  { \"pm\", \"->*\",       2 },\n-  { \"pp\", \"++\",        1 },\n-  { \"ps\", \"+\",         1 },\n-  { \"pt\", \"->\",        2 },\n-  { \"qu\", \"?\",         3 },\n-  { \"rM\", \"%=\",        2 },\n-  { \"rS\", \">>=\",       2 },\n-  { \"rm\", \"%\",         2 },\n-  { \"rs\", \">>\",        2 },\n-  { \"st\", \"sizeof \",   1 },\n-  { \"sz\", \"sizeof \",   1 }\n+  { \"aN\", NL (\"&=\"),        2 },\n+  { \"aS\", NL (\"=\"),         2 },\n+  { \"aa\", NL (\"&&\"),        2 },\n+  { \"ad\", NL (\"&\"),         1 },\n+  { \"an\", NL (\"&\"),         2 },\n+  { \"cl\", NL (\"()\"),        0 },\n+  { \"cm\", NL (\",\"),         2 },\n+  { \"co\", NL (\"~\"),         1 },\n+  { \"dV\", NL (\"/=\"),        2 },\n+  { \"da\", NL (\"delete[]\"),  1 },\n+  { \"de\", NL (\"*\"),         1 },\n+  { \"dl\", NL (\"delete\"),    1 },\n+  { \"dv\", NL (\"/\"),         2 },\n+  { \"eO\", NL (\"^=\"),        2 },\n+  { \"eo\", NL (\"^\"),         2 },\n+  { \"eq\", NL (\"==\"),        2 },\n+  { \"ge\", NL (\">=\"),        2 },\n+  { \"gt\", NL (\">\"),         2 },\n+  { \"ix\", NL (\"[]\"),        2 },\n+  { \"lS\", NL (\"<<=\"),       2 },\n+  { \"le\", NL (\"<=\"),        2 },\n+  { \"ls\", NL (\"<<\"),        2 },\n+  { \"lt\", NL (\"<\"),         2 },\n+  { \"mI\", NL (\"-=\"),        2 },\n+  { \"mL\", NL (\"*=\"),        2 },\n+  { \"mi\", NL (\"-\"),         2 },\n+  { \"ml\", NL (\"*\"),         2 },\n+  { \"mm\", NL (\"--\"),        1 },\n+  { \"na\", NL (\"new[]\"),     1 },\n+  { \"ne\", NL (\"!=\"),        2 },\n+  { \"ng\", NL (\"-\"),         1 },\n+  { \"nt\", NL (\"!\"),         1 },\n+  { \"nw\", NL (\"new\"),       1 },\n+  { \"oR\", NL (\"|=\"),        2 },\n+  { \"oo\", NL (\"||\"),        2 },\n+  { \"or\", NL (\"|\"),         2 },\n+  { \"pL\", NL (\"+=\"),        2 },\n+  { \"pl\", NL (\"+\"),         2 },\n+  { \"pm\", NL (\"->*\"),       2 },\n+  { \"pp\", NL (\"++\"),        1 },\n+  { \"ps\", NL (\"+\"),         1 },\n+  { \"pt\", NL (\"->\"),        2 },\n+  { \"qu\", NL (\"?\"),         3 },\n+  { \"rM\", NL (\"%=\"),        2 },\n+  { \"rS\", NL (\">>=\"),       2 },\n+  { \"rm\", NL (\"%\"),         2 },\n+  { \"rs\", NL (\">>\"),        2 },\n+  { \"st\", NL (\"sizeof \"),   1 },\n+  { \"sz\", NL (\"sizeof \"),   1 }\n };\n \n static struct d_comp *\n@@ -1484,14 +1541,17 @@ d_special_name (di)\n {\n   char c;\n \n+  di->expansion += 20;\n   c = d_next_char (di);\n   if (c == 'T')\n     {\n       switch (d_next_char (di))\n \t{\n \tcase 'V':\n+\t  di->expansion -= 5;\n \t  return d_make_comp (di, D_COMP_VTABLE, d_type (di), NULL);\n \tcase 'T':\n+\t  di->expansion -= 10;\n \t  return d_make_comp (di, D_COMP_VTT, d_type (di), NULL);\n \tcase 'I':\n \t  return d_make_comp (di, D_COMP_TYPEINFO, d_type (di), NULL);\n@@ -1532,6 +1592,7 @@ d_special_name (di)\n \t    base_type = d_type (di);\n \t    /* We don't display the offset.  FIXME: We should display\n \t       it in verbose mode.  */\n+\t    di->expansion += 5;\n \t    return d_make_comp (di, D_COMP_CONSTRUCTION_VTABLE, base_type,\n \t\t\t\tderived_type);\n \t  }\n@@ -1617,6 +1678,13 @@ static struct d_comp *\n d_ctor_dtor_name (di)\n      struct d_info *di;\n {\n+  if (di->last_name != NULL)\n+    {\n+      if (di->last_name->type == D_COMP_NAME)\n+\tdi->expansion += di->last_name->u.s_name.len;\n+      else if (di->last_name->type == D_COMP_SUB_STD)\n+\tdi->expansion += di->last_name->u.s_string.len;\n+    }\n   switch (d_next_char (di))\n     {\n     case 'C':\n@@ -1687,32 +1755,32 @@ d_ctor_dtor_name (di)\n \n static const struct d_builtin_type_info d_builtin_types[26] =\n {\n-  /* a */ { \"signed char\",\t\"signed char\",\t\tD_PRINT_INT },\n-  /* b */ { \"bool\",\t\t\"boolean\",\t\tD_PRINT_BOOL },\n-  /* c */ { \"char\",\t\t\"byte\",\t\t\tD_PRINT_INT },\n-  /* d */ { \"double\",\t\t\"double\",\t\tD_PRINT_DEFAULT },\n-  /* e */ { \"long double\",\t\"long double\",\t\tD_PRINT_DEFAULT },\n-  /* f */ { \"float\",\t\t\"float\",\t\tD_PRINT_DEFAULT },\n-  /* g */ { \"__float128\",\t\"__float128\",\t\tD_PRINT_DEFAULT },\n-  /* h */ { \"unsigned char\",\t\"unsigned char\",\tD_PRINT_INT },\n-  /* i */ { \"int\",\t\t\"int\",\t\t\tD_PRINT_INT },\n-  /* j */ { \"unsigned int\",\t\"unsigned\",\t\tD_PRINT_INT },\n-  /* k */ { NULL,\t\tNULL,\t\t\tD_PRINT_DEFAULT },\n-  /* l */ { \"long\",\t\t\"long\",\t\t\tD_PRINT_LONG },\n-  /* m */ { \"unsigned long\",\t\"unsigned long\",\tD_PRINT_LONG },\n-  /* n */ { \"__int128\",\t\t\"__int128\",\t\tD_PRINT_DEFAULT },\n-  /* o */ { \"unsigned __int128\", \"unsigned __int128\",\tD_PRINT_DEFAULT },\n-  /* p */ { NULL,\t\tNULL,\t\t\tD_PRINT_DEFAULT },\n-  /* q */ { NULL,\t\tNULL,\t\t\tD_PRINT_DEFAULT },\n-  /* r */ { NULL,\t\tNULL,\t\t\tD_PRINT_DEFAULT },\n-  /* s */ { \"short\",\t\t\"short\",\t\tD_PRINT_INT },\n-  /* t */ { \"unsigned short\",\t\"unsigned short\",\tD_PRINT_INT },\n-  /* u */ { NULL,\t\tNULL,\t\t\tD_PRINT_DEFAULT },\n-  /* v */ { \"void\",\t\t\"void\",\t\t\tD_PRINT_VOID },\n-  /* w */ { \"wchar_t\",\t\t\"char\",\t\t\tD_PRINT_INT },\n-  /* x */ { \"long long\",\t\"long\",\t\t\tD_PRINT_DEFAULT },\n-  /* y */ { \"unsigned long long\", \"unsigned long long\",\tD_PRINT_DEFAULT },\n-  /* z */ { \"...\",\t\t\"...\",\t\t\tD_PRINT_DEFAULT },\n+  /* a */ { NL (\"signed char\"),\tNL (\"signed char\"),\tD_PRINT_INT },\n+  /* b */ { NL (\"bool\"),\tNL (\"boolean\"),\t\tD_PRINT_BOOL },\n+  /* c */ { NL (\"char\"),\tNL (\"byte\"),\t\tD_PRINT_INT },\n+  /* d */ { NL (\"double\"),\tNL (\"double\"),\t\tD_PRINT_DEFAULT },\n+  /* e */ { NL (\"long double\"),\tNL (\"long double\"),\tD_PRINT_DEFAULT },\n+  /* f */ { NL (\"float\"),\tNL (\"float\"),\t\tD_PRINT_DEFAULT },\n+  /* g */ { NL (\"__float128\"),\tNL (\"__float128\"),\tD_PRINT_DEFAULT },\n+  /* h */ { NL (\"unsigned char\"), NL (\"unsigned char\"),\tD_PRINT_INT },\n+  /* i */ { NL (\"int\"),\t\tNL (\"int\"),\t\tD_PRINT_INT },\n+  /* j */ { NL (\"unsigned int\"), NL (\"unsigned\"),\tD_PRINT_INT },\n+  /* k */ { NULL, 0,\t\tNULL, 0,\t\tD_PRINT_DEFAULT },\n+  /* l */ { NL (\"long\"),\tNL (\"long\"),\t\tD_PRINT_LONG },\n+  /* m */ { NL (\"unsigned long\"), NL (\"unsigned long\"),\tD_PRINT_LONG },\n+  /* n */ { NL (\"__int128\"),\tNL (\"__int128\"),\tD_PRINT_DEFAULT },\n+  /* o */ { NL (\"unsigned __int128\"), NL (\"unsigned __int128\"),\tD_PRINT_DEFAULT },\n+  /* p */ { NULL, 0,\t\tNULL, 0,\t\tD_PRINT_DEFAULT },\n+  /* q */ { NULL, 0,\t\tNULL, 0,\t\tD_PRINT_DEFAULT },\n+  /* r */ { NULL, 0,\t\tNULL, 0,\t\tD_PRINT_DEFAULT },\n+  /* s */ { NL (\"short\"),\tNL (\"short\"),\t\tD_PRINT_INT },\n+  /* t */ { NL (\"unsigned short\"), NL (\"unsigned short\"), D_PRINT_INT },\n+  /* u */ { NULL, 0,\t\tNULL, 0,\t\tD_PRINT_DEFAULT },\n+  /* v */ { NL (\"void\"),\tNL (\"void\"),\t\tD_PRINT_VOID },\n+  /* w */ { NL (\"wchar_t\"),\tNL (\"char\"),\t\tD_PRINT_INT },\n+  /* x */ { NL (\"long long\"),\tNL (\"long\"),\t\tD_PRINT_DEFAULT },\n+  /* y */ { NL (\"unsigned long long\"), NL (\"unsigned long long\"), D_PRINT_DEFAULT },\n+  /* z */ { NL (\"...\"),\t\tNL (\"...\"),\t\tD_PRINT_DEFAULT },\n };\n \n static struct d_comp *\n@@ -1761,6 +1829,7 @@ d_type (di)\n     case 'o':                               case 's': case 't':\n     case 'v': case 'w': case 'x': case 'y': case 'z':\n       ret = d_make_builtin_type (di, &d_builtin_types[peek - 'a']);\n+      di->expansion += ret->u.s_builtin.type->len;\n       can_subst = 0;\n       d_advance (di, 1);\n       break;\n@@ -1891,11 +1960,20 @@ d_cv_qualifiers (di, pret, member_fn)\n \n       d_advance (di, 1);\n       if (peek == 'r')\n-\tt = member_fn ? D_COMP_RESTRICT_THIS: D_COMP_RESTRICT;\n+\t{\n+\t  t = member_fn ? D_COMP_RESTRICT_THIS : D_COMP_RESTRICT;\n+\t  di->expansion += sizeof \"restrict\";\n+\t}\n       else if (peek == 'V')\n-\tt = member_fn ? D_COMP_VOLATILE_THIS : D_COMP_VOLATILE;\n+\t{\n+\t  t = member_fn ? D_COMP_VOLATILE_THIS : D_COMP_VOLATILE;\n+\t  di->expansion += sizeof \"volatile\";\n+\t}\n       else\n-\tt = member_fn ? D_COMP_CONST_THIS: D_COMP_CONST;\n+\t{\n+\t  t = member_fn ? D_COMP_CONST_THIS : D_COMP_CONST;\n+\t  di->expansion += sizeof \"const\";\n+\t}\n \n       *pret = d_make_comp (di, t, NULL, NULL);\n       if (*pret == NULL)\n@@ -1979,7 +2057,10 @@ d_bare_function_type (di, has_return_type)\n   if (d_right (tl) == NULL\n       && d_left (tl)->type == D_COMP_BUILTIN_TYPE\n       && d_left (tl)->u.s_builtin.type->print == D_PRINT_VOID)\n-    tl = NULL;\n+    {\n+      di->expansion -= d_left (tl)->u.s_builtin.type->len;\n+      tl = NULL;\n+    }\n \n   return d_make_comp (di, D_COMP_FUNCTION_TYPE, return_type, tl);\n }\n@@ -2100,6 +2181,8 @@ d_template_param (di)\n   if (d_next_char (di) != '_')\n     return NULL;\n \n+  ++di->did_subs;\n+\n   return d_make_template_param (di, param);\n }\n \n@@ -2221,6 +2304,9 @@ d_expression (di)\n       if (op == NULL)\n \treturn NULL;\n \n+      if (op->type == D_COMP_OPERATOR)\n+\tdi->expansion += op->u.s_operator.op->len - 2;\n+\n       if (op->type == D_COMP_OPERATOR\n \t  && strcmp (op->u.s_operator.op->code, \"st\") == 0)\n \treturn d_make_comp (di, D_COMP_UNARY, op, d_type (di));\n@@ -2296,6 +2382,12 @@ d_expr_primary (di)\n \n       type = d_type (di);\n \n+      /* If we have a type we know how to print, we aren't going to\n+\t print the type name itself.  */\n+      if (type->type == D_COMP_BUILTIN_TYPE\n+\t  && type->u.s_builtin.type->print != D_PRINT_DEFAULT)\n+\tdi->expansion -= type->u.s_builtin.type->len;\n+\n       /* Rather than try to interpret the literal value, we just\n \t collect it as a string.  Note that it's possible to have a\n \t floating point literal here.  The ABI specifies that the\n@@ -2418,21 +2510,27 @@ d_add_substitution (di, dc)\n \n static const struct d_standard_sub_info standard_subs[] =\n {\n-  { 't', \"std\", \"std\", NULL },\n-  { 'a', \"std::allocator\", \"std::allocator\", \"allocator\" },\n-  { 'b', \"std::basic_string\", \"std::basic_string\", \"basic_string\" },\n-  { 's', \"std::string\",\n-    \"std::basic_string<char, std::char_traits<char>, std::allocator<char> >\",\n-    \"basic_string\" },\n-  { 'i', \"std::istream\",\n-    \"std::basic_istream<char, std::char_traits<char> >\",\n-    \"basic_istream\" },\n-  { 'o', \"std::ostream\",\n-    \"std::basic_ostream<char, std::char_traits<char> >\",\n-    \"basic_ostream\" },\n-  { 'd', \"std::iostream\",\n-    \"std::basic_iostream<char, std::char_traits<char> >\",\n-    \"basic_iostream\" }\n+  { 't', NL (\"std\"),\n+    NL (\"std\"),\n+    NULL, 0 },\n+  { 'a', NL (\"std::allocator\"),\n+    NL (\"std::allocator\"),\n+    NL (\"allocator\") },\n+  { 'b', NL (\"std::basic_string\"),\n+    NL (\"std::basic_string\"),\n+    NL (\"basic_string\") },\n+  { 's', NL (\"std::string\"),\n+    NL (\"std::basic_string<char, std::char_traits<char>, std::allocator<char> >\"),\n+    NL (\"basic_string\") },\n+  { 'i', NL (\"std::istream\"),\n+    NL (\"std::basic_istream<char, std::char_traits<char> >\"),\n+    NL (\"basic_istream\") },\n+  { 'o', NL (\"std::ostream\"),\n+    NL (\"std::basic_ostream<char, std::char_traits<char> >\"),\n+    NL (\"basic_ostream\") },\n+  { 'd', NL (\"std::iostream\"),\n+    NL (\"std::basic_iostream<char, std::char_traits<char> >\"),\n+    NL (\"basic_iostream\") }\n };\n \n static struct d_comp *\n@@ -2471,6 +2569,8 @@ d_substitution (di, prefix)\n       if (id >= di->next_sub)\n \treturn NULL;\n \n+      ++di->did_subs;\n+\n       return di->subs[id];\n     }\n   else\n@@ -2495,12 +2595,24 @@ d_substitution (di, prefix)\n \t{\n \t  if (c == p->code)\n \t    {\n+\t      const char *s;\n+\t      int len;\n+\n \t      if (p->set_last_name != NULL)\n-\t\tdi->last_name = d_make_sub (di, p->set_last_name);\n+\t\tdi->last_name = d_make_sub (di, p->set_last_name,\n+\t\t\t\t\t    p->set_last_name_len);\n \t      if (verbose)\n-\t\treturn d_make_sub (di, p->full_expansion);\n+\t\t{\n+\t\t  s = p->full_expansion;\n+\t\t  len = p->full_len;\n+\t\t}\n \t      else\n-\t\treturn d_make_sub (di, p->simple_expansion);\n+\t\t{\n+\t\t  s = p->simple_expansion;\n+\t\t  len = p->simple_len;\n+\t\t}\n+\t      di->expansion += len;\n+\t      return d_make_sub (di, s, len);\n \t    }\n \t}\n \n@@ -2592,22 +2704,26 @@ d_print_error (dpi)\n   dpi->buf = NULL;\n }\n \n-/* Turn components into a human readable string.  Returns a string\n-   allocated by malloc, or NULL on error.  On success, this sets *PALC\n-   to the size of the allocated buffer.  On failure, this sets *PALC\n-   to 0 for a bad parse, or to 1 for a memory allocation failure.  */\n+/* Turn components into a human readable string.  OPTIONS is the\n+   options bits passed to the demangler.  DC is the tree to print.\n+   ESTIMATE is a guess at the length of the result.  This returns a\n+   string allocated by malloc, or NULL on error.  On success, this\n+   sets *PALC to the size of the allocated buffer.  On failure, this\n+   sets *PALC to 0 for a bad parse, or to 1 for a memory allocation\n+   failure.  */\n \n static char *\n-d_print (options, dc, palc)\n+d_print (options, dc, estimate, palc)\n      int options;\n      const struct d_comp *dc;\n+     int estimate;\n      size_t *palc;\n {\n   struct d_print_info dpi;\n \n   dpi.options = options;\n \n-  dpi.alc = 64;\n+  dpi.alc = estimate + 1;\n   dpi.buf = malloc (dpi.alc);\n   if (dpi.buf == NULL)\n     {\n@@ -2651,13 +2767,19 @@ d_print_comp (dpi, dc)\n   switch (dc->type)\n     {\n     case D_COMP_NAME:\n-      d_print_identifier (dpi, dc->u.s_name.s, dc->u.s_name.len);\n+      if ((dpi->options & DMGL_JAVA) == 0)\n+\td_append_buffer (dpi, dc->u.s_name.s, dc->u.s_name.len);\n+      else\n+\td_print_java_identifier (dpi, dc->u.s_name.s, dc->u.s_name.len);\n       return;\n \n     case D_COMP_QUAL_NAME:\n     case D_COMP_LOCAL_NAME:\n       d_print_comp (dpi, d_left (dc));\n-      d_append_string (dpi, (dpi->options & DMGL_JAVA) == 0 ? \"::\" : \".\");\n+      if ((dpi->options & DMGL_JAVA) == 0)\n+\td_append_string_constant (dpi, \"::\");\n+      else\n+\td_append_char (dpi, '.');\n       d_print_comp (dpi, d_right (dc));\n       return;\n \n@@ -2844,69 +2966,69 @@ d_print_comp (dpi, dc)\n       return;\n \n     case D_COMP_VTABLE:\n-      d_append_string (dpi, \"vtable for \");\n+      d_append_string_constant (dpi, \"vtable for \");\n       d_print_comp (dpi, d_left (dc));\n       return;\n \n     case D_COMP_VTT:\n-      d_append_string (dpi, \"VTT for \");\n+      d_append_string_constant (dpi, \"VTT for \");\n       d_print_comp (dpi, d_left (dc));\n       return;\n \n     case D_COMP_CONSTRUCTION_VTABLE:\n-      d_append_string (dpi, \"construction vtable for \");\n+      d_append_string_constant (dpi, \"construction vtable for \");\n       d_print_comp (dpi, d_left (dc));\n-      d_append_string (dpi, \"-in-\");\n+      d_append_string_constant (dpi, \"-in-\");\n       d_print_comp (dpi, d_right (dc));\n       return;\n \n     case D_COMP_TYPEINFO:\n-      d_append_string (dpi, \"typeinfo for \");\n+      d_append_string_constant (dpi, \"typeinfo for \");\n       d_print_comp (dpi, d_left (dc));\n       return;\n \n     case D_COMP_TYPEINFO_NAME:\n-      d_append_string (dpi, \"typeinfo name for \");\n+      d_append_string_constant (dpi, \"typeinfo name for \");\n       d_print_comp (dpi, d_left (dc));\n       return;\n \n     case D_COMP_TYPEINFO_FN:\n-      d_append_string (dpi, \"typeinfo fn for \");\n+      d_append_string_constant (dpi, \"typeinfo fn for \");\n       d_print_comp (dpi, d_left (dc));\n       return;\n \n     case D_COMP_THUNK:\n-      d_append_string (dpi, \"non-virtual thunk to \");\n+      d_append_string_constant (dpi, \"non-virtual thunk to \");\n       d_print_comp (dpi, d_left (dc));\n       return;\n \n     case D_COMP_VIRTUAL_THUNK:\n-      d_append_string (dpi, \"virtual thunk to \");\n+      d_append_string_constant (dpi, \"virtual thunk to \");\n       d_print_comp (dpi, d_left (dc));\n       return;\n \n     case D_COMP_COVARIANT_THUNK:\n-      d_append_string (dpi, \"covariant return thunk to \");\n+      d_append_string_constant (dpi, \"covariant return thunk to \");\n       d_print_comp (dpi, d_left (dc));\n       return;\n \n     case D_COMP_JAVA_CLASS:\n-      d_append_string (dpi, \"java Class for \");\n+      d_append_string_constant (dpi, \"java Class for \");\n       d_print_comp (dpi, d_left (dc));\n       return;\n \n     case D_COMP_GUARD:\n-      d_append_string (dpi, \"guard variable for \");\n+      d_append_string_constant (dpi, \"guard variable for \");\n       d_print_comp (dpi, d_left (dc));\n       return;\n \n     case D_COMP_REFTEMP:\n-      d_append_string (dpi, \"reference temporary for \");\n+      d_append_string_constant (dpi, \"reference temporary for \");\n       d_print_comp (dpi, d_left (dc));\n       return;\n \n     case D_COMP_SUB_STD:\n-      d_append_string (dpi, dc->u.s_string.string);\n+      d_append_buffer (dpi, dc->u.s_string.string, dc->u.s_string.len);\n       return;\n \n     case D_COMP_RESTRICT:\n@@ -2944,9 +3066,11 @@ d_print_comp (dpi, dc)\n \n     case D_COMP_BUILTIN_TYPE:\n       if ((dpi->options & DMGL_JAVA) == 0)\n-\td_append_string (dpi, dc->u.s_builtin.type->name);\n+\td_append_buffer (dpi, dc->u.s_builtin.type->name,\n+\t\t\t dc->u.s_builtin.type->len);\n       else\n-\td_append_string (dpi, dc->u.s_builtin.type->java_name);\n+\td_append_buffer (dpi, dc->u.s_builtin.type->java_name,\n+\t\t\t dc->u.s_builtin.type->java_len);\n       return;\n \n     case D_COMP_VENDOR_TYPE:\n@@ -3026,7 +3150,7 @@ d_print_comp (dpi, dc)\n \t  {\n \t    d_append_char (dpi, ' ');\n \t    d_print_comp (dpi, d_left (dc));\n-\t    d_append_string (dpi, \"::*\");\n+\t    d_append_string_constant (dpi, \"::*\");\n \t  }\n \n \tdpi->modifiers = dpm.next;\n@@ -3039,7 +3163,7 @@ d_print_comp (dpi, dc)\n       d_print_comp (dpi, d_left (dc));\n       if (d_right (dc) != NULL)\n \t{\n-\t  d_append_string (dpi, \", \");\n+\t  d_append_string_constant (dpi, \", \");\n \t  d_print_comp (dpi, d_right (dc));\n \t}\n       return;\n@@ -3048,21 +3172,22 @@ d_print_comp (dpi, dc)\n       {\n \tchar c;\n \n-\td_append_string (dpi, \"operator\");\n+\td_append_string_constant (dpi, \"operator\");\n \tc = dc->u.s_operator.op->name[0];\n \tif (IS_LOWER (c))\n \t  d_append_char (dpi, ' ');\n-\td_append_string (dpi, dc->u.s_operator.op->name);\n+\td_append_buffer (dpi, dc->u.s_operator.op->name,\n+\t\t\t dc->u.s_operator.op->len);\n \treturn;\n       }\n \n     case D_COMP_EXTENDED_OPERATOR:\n-      d_append_string (dpi, \"operator \");\n+      d_append_string_constant (dpi, \"operator \");\n       d_print_comp (dpi, dc->u.s_extended_operator.name);\n       return;\n \n     case D_COMP_CAST:\n-      d_append_string (dpi, \"operator \");\n+      d_append_string_constant (dpi, \"operator \");\n       d_print_cast (dpi, dc);\n       return;\n \n@@ -3071,7 +3196,7 @@ d_print_comp (dpi, dc)\n \td_print_expr_op (dpi, d_left (dc));\n       else\n \t{\n-\t  d_append_string (dpi, \"((\");\n+\t  d_append_string_constant (dpi, \"((\");\n \t  d_print_cast (dpi, d_left (dc));\n \t  d_append_char (dpi, ')');\n \t}\n@@ -3093,19 +3218,21 @@ d_print_comp (dpi, dc)\n \t an extra layer of parens so that it does not get confused\n \t with the '>' which ends the template parameters.  */\n       if (d_left (dc)->type == D_COMP_OPERATOR\n-\t  && strcmp (d_left (dc)->u.s_operator.op->name, \">\") == 0)\n+\t  && d_left (dc)->u.s_operator.op->len == 1\n+\t  && d_left (dc)->u.s_operator.op->name[0] == '>')\n \td_append_char (dpi, '(');\n \n       d_append_char (dpi, '(');\n       d_print_comp (dpi, d_left (d_right (dc)));\n-      d_append_string (dpi, \") \");\n+      d_append_string_constant (dpi, \") \");\n       d_print_expr_op (dpi, d_left (dc));\n-      d_append_string (dpi, \" (\");\n+      d_append_string_constant (dpi, \" (\");\n       d_print_comp (dpi, d_right (d_right (dc)));\n       d_append_char (dpi, ')');\n \n       if (d_left (dc)->type == D_COMP_OPERATOR\n-\t  && strcmp (d_left (dc)->u.s_operator.op->name, \">\") == 0)\n+\t  && d_left (dc)->u.s_operator.op->len == 1\n+\t  && d_left (dc)->u.s_operator.op->name[0] == '>')\n \td_append_char (dpi, ')');\n \n       return;\n@@ -3124,11 +3251,11 @@ d_print_comp (dpi, dc)\n \t}\n       d_append_char (dpi, '(');\n       d_print_comp (dpi, d_left (d_right (dc)));\n-      d_append_string (dpi, \") \");\n+      d_append_string_constant (dpi, \") \");\n       d_print_expr_op (dpi, d_left (dc));\n-      d_append_string (dpi, \" (\");\n+      d_append_string_constant (dpi, \" (\");\n       d_print_comp (dpi, d_left (d_right (d_right (dc))));\n-      d_append_string (dpi, \") : (\");\n+      d_append_string_constant (dpi, \") : (\");\n       d_print_comp (dpi, d_right (d_right (d_right (dc))));\n       d_append_char (dpi, ')');\n       return;\n@@ -3175,10 +3302,10 @@ d_print_comp (dpi, dc)\n \t\t  switch (d_right (dc)->u.s_name.s[0])\n \t\t    {\n \t\t    case '0':\n-\t\t      d_append_string (dpi, \"false\");\n+\t\t      d_append_string_constant (dpi, \"false\");\n \t\t      return;\n \t\t    case '1':\n-\t\t      d_append_string (dpi, \"true\");\n+\t\t      d_append_string_constant (dpi, \"true\");\n \t\t      return;\n \t\t    default:\n \t\t      break;\n@@ -3205,64 +3332,58 @@ d_print_comp (dpi, dc)\n     }\n }\n \n-/* Print an identifier.  */\n+/* Print a Java dentifier.  For Java we try to handle encoded extended\n+   Unicode characters.  The C++ ABI doesn't mention Unicode encoding,\n+   so we don't it for C++.  Characters are encoded as\n+   __U<hex-char>+_.  */\n \n static void\n-d_print_identifier (dpi, name, len)\n+d_print_java_identifier (dpi, name, len)\n      struct d_print_info *dpi;\n      const char *name;\n      int len;\n {\n-  if ((dpi->options & DMGL_JAVA) == 0)\n-    d_append_buffer (dpi, name, len);\n-  else\n+  const char *p;\n+  const char *end;\n+\n+  end = name + len;\n+  for (p = name; p < end; ++p)\n     {\n-      const char *p;\n-      const char *end;\n-\n-      /* For Java we try to handle encoded extended Unicode\n-\t characters.  The C++ ABI doesn't mention Unicode encoding, so\n-\t we don't it for C++.  Characters are encoded as\n-\t __U<hex-char>+_.  */\n-      end = name + len;\n-      for (p = name; p < end; ++p)\n+      if (end - p > 3\n+\t  && p[0] == '_'\n+\t  && p[1] == '_'\n+\t  && p[2] == 'U')\n \t{\n-\t  if (end - p > 3\n-\t      && p[0] == '_'\n-\t      && p[1] == '_'\n-\t      && p[2] == 'U')\n+\t  unsigned long c;\n+\t  const char *q;\n+\n+\t  c = 0;\n+\t  for (q = p + 3; q < end; ++q)\n \t    {\n-\t      unsigned long c;\n-\t      const char *q;\n+\t      int dig;\n+\n+\t      if (IS_DIGIT (*q))\n+\t\tdig = *q - '0';\n+\t      else if (*q >= 'A' && *q <= 'F')\n+\t\tdig = *q - 'A' + 10;\n+\t      else if (*q >= 'a' && *q <= 'f')\n+\t\tdig = *q - 'a' + 10;\n+\t      else\n+\t\tbreak;\n \n-\t      c = 0;\n-\t      for (q = p + 3; q < end; ++q)\n-\t\t{\n-\t\t  int dig;\n-\n-\t\t  if (IS_DIGIT (*q))\n-\t\t    dig = *q - '0';\n-\t\t  else if (*q >= 'A' && *q <= 'F')\n-\t\t    dig = *q - 'A' + 10;\n-\t\t  else if (*q >= 'a' && *q <= 'f')\n-\t\t    dig = *q - 'a' + 10;\n-\t\t  else\n-\t\t    break;\n-\n-\t\t  c = c * 16 + dig;\n-\t\t}\n-\t      /* If the Unicode character is larger than 256, we don't\n-\t\t try to deal with it here.  FIXME.  */\n-\t      if (q < end && *q == '_' && c < 256)\n-\t\t{\n-\t\t  d_append_char (dpi, c);\n-\t\t  p = q;\n-\t\t  continue;\n-\t\t}\n+\t      c = c * 16 + dig;\n+\t    }\n+\t  /* If the Unicode character is larger than 256, we don't try\n+\t     to deal with it here.  FIXME.  */\n+\t  if (q < end && *q == '_' && c < 256)\n+\t    {\n+\t      d_append_char (dpi, c);\n+\t      p = q;\n+\t      continue;\n \t    }\n-\n-\t  d_append_char (dpi, *p);\n \t}\n+\n+      d_append_char (dpi, *p);\n     }\n }\n \n@@ -3322,7 +3443,10 @@ d_print_mod_list (dpi, mods, suffix)\n       d_print_comp (dpi, d_left (mods->mod));\n       dpi->modifiers = hold_modifiers;\n \n-      d_append_string (dpi, (dpi->options & DMGL_JAVA) == 0 ? \"::\" : \".\");\n+      if ((dpi->options & DMGL_JAVA) == 0)\n+\td_append_string_constant (dpi, \"::\");\n+      else\n+\td_append_char (dpi, '.');\n \n       dc = d_right (mods->mod);\n       while (dc->type == D_COMP_RESTRICT_THIS\n@@ -3354,15 +3478,15 @@ d_print_mod (dpi, mod)\n     {\n     case D_COMP_RESTRICT:\n     case D_COMP_RESTRICT_THIS:\n-      d_append_string (dpi, \" restrict\");\n+      d_append_string_constant (dpi, \" restrict\");\n       return;\n     case D_COMP_VOLATILE:\n     case D_COMP_VOLATILE_THIS:\n-      d_append_string (dpi, \" volatile\");\n+      d_append_string_constant (dpi, \" volatile\");\n       return;\n     case D_COMP_CONST:\n     case D_COMP_CONST_THIS:\n-      d_append_string (dpi, \" const\");\n+      d_append_string_constant (dpi, \" const\");\n       return;\n     case D_COMP_VENDOR_TYPE_QUAL:\n       d_append_char (dpi, ' ');\n@@ -3377,16 +3501,16 @@ d_print_mod (dpi, mod)\n       d_append_char (dpi, '&');\n       return;\n     case D_COMP_COMPLEX:\n-      d_append_string (dpi, \"complex \");\n+      d_append_string_constant (dpi, \"complex \");\n       return;\n     case D_COMP_IMAGINARY:\n-      d_append_string (dpi, \"imaginary \");\n+      d_append_string_constant (dpi, \"imaginary \");\n       return;\n     case D_COMP_PTRMEM_TYPE:\n       if (d_last_char (dpi) != '(')\n \td_append_char (dpi, ' ');\n       d_print_comp (dpi, d_left (mod));\n-      d_append_string (dpi, \"::*\");\n+      d_append_string_constant (dpi, \"::*\");\n       return;\n     case D_COMP_TYPED_NAME:\n       d_print_comp (dpi, d_left (mod));\n@@ -3520,7 +3644,7 @@ d_print_array_type (dpi, dc, mods)\n \t}\n \n       if (need_paren)\n-\td_append_string (dpi, \" (\");\n+\td_append_string_constant (dpi, \" (\");\n \n       d_print_mod_list (dpi, mods, 0);\n \n@@ -3547,7 +3671,8 @@ d_print_expr_op (dpi, dc)\n      const struct d_comp *dc;\n {\n   if (dc->type == D_COMP_OPERATOR)\n-    d_append_string (dpi, dc->u.s_operator.op->name);\n+    d_append_buffer (dpi, dc->u.s_operator.op->name,\n+\t\t     dc->u.s_operator.op->len);\n   else\n     d_print_comp (dpi, dc);\n }\n@@ -3599,14 +3724,15 @@ d_print_cast (dpi, dc)\n /* Initialize the information structure we use to pass around\n    information.  */\n \n-static int\n+static void\n d_init_info (mangled, options, len, di)\n      const char *mangled;\n      int options;\n      size_t len;\n      struct d_info *di;\n {\n   di->s = mangled;\n+  di->send = mangled + len;\n   di->options = options;\n \n   di->n = mangled;\n@@ -3615,29 +3741,17 @@ d_init_info (mangled, options, len, di)\n      the mangled string.  Most components correspond directly to\n      chars, but the ARGLIST types are exceptions.  */\n   di->num_comps = 2 * len;\n-  di->comps = (struct d_comp *) malloc (di->num_comps\n-\t\t\t\t\t* sizeof (struct d_comp));\n   di->next_comp = 0;\n \n   /* Similarly, we can not need more substitutions than there are\n      chars in the mangled string.  */\n   di->num_subs = len;\n-  di->subs = (struct d_comp **) malloc (di->num_subs\n-\t\t\t\t\t* sizeof (struct d_comp *));\n   di->next_sub = 0;\n+  di->did_subs = 0;\n \n   di->last_name = NULL;\n \n-  if (di->comps == NULL || di->subs == NULL)\n-    {\n-      if (di->comps != NULL)\n-\tfree (di->comps);\n-      if (di->subs != NULL)\n-\tfree (di->subs);\n-      return 0;\n-    }\n-\n-  return 1;\n+  di->expansion = 0;\n }\n \n /* Entry point for the demangler.  If MANGLED is a g++ v3 ABI mangled\n@@ -3657,6 +3771,7 @@ d_demangle (mangled, options, palc)\n   int type;\n   struct d_info di;\n   struct d_comp *dc;\n+  int estimate;\n   char *ret;\n \n   *palc = 0;\n@@ -3692,39 +3807,82 @@ d_demangle (mangled, options, palc)\n       type = 1;\n     }\n \n-  if (! d_init_info (mangled, options, len, &di))\n-    {\n-      *palc = 1;\n-      return NULL;\n-    }\n+  d_init_info (mangled, options, len, &di);\n \n-  if (! type)\n-    dc = d_mangled_name (&di, 1);\n-  else\n-    dc = d_type (&di);\n+  {\n+#ifdef CP_DYNAMIC_ARRAYS\n+    __extension__ struct d_comp comps[di.num_comps];\n+    __extension__ struct d_comp *subs[di.num_subs];\n+\n+    di.comps = &comps[0];\n+    di.subs = &subs[0];\n+#else\n+    di.comps = (struct d_comp *) malloc (di.num_comps\n+\t\t\t\t\t * sizeof (struct d_comp));\n+    di.subs = (struct d_comp **) malloc (di.num_subs\n+\t\t\t\t\t * sizeof (struct d_comp *));\n+    if (di.comps == NULL || di.subs == NULL)\n+      {\n+\tif (di.comps != NULL)\n+\t  free (di.comps);\n+\tif (di.subs != NULL)\n+\t  free (di.subs);\n+\t*palc = 1;\n+\treturn NULL;\n+      }\n+#endif\n+\n+    if (! type)\n+      dc = d_mangled_name (&di, 1);\n+    else\n+      dc = d_type (&di);\n \n-  /* If DMGL_PARAMS is set, then if we didn't consume the entire\n-     mangled string, then we didn't successfully demangle it.  If\n-     DMGL_PARAMS is not set, we didn't look at the trailing\n-     parameters.  */\n-  if (((options & DMGL_PARAMS) != 0) && d_peek_char (&di) != '\\0')\n-    dc = NULL;\n+    /* If DMGL_PARAMS is set, then if we didn't consume the entire\n+       mangled string, then we didn't successfully demangle it.  If\n+       DMGL_PARAMS is not set, we didn't look at the trailing\n+       parameters.  */\n+    if (((options & DMGL_PARAMS) != 0) && d_peek_char (&di) != '\\0')\n+      dc = NULL;\n \n #ifdef CP_DEMANGLE_DEBUG\n-  if (dc == NULL)\n-    printf (\"failed demangling\\n\");\n-  else\n-    d_dump (dc, 0);\n+    if (dc == NULL)\n+      printf (\"failed demangling\\n\");\n+    else\n+      d_dump (dc, 0);\n #endif\n \n-  free (di.subs);\n-  di.subs = NULL;\n+    /* We try to guess the length of the demangled string, to minimize\n+       calls to realloc during demangling.  */\n+    estimate = len + di.expansion + 10 * di.did_subs;\n+    estimate += estimate / 8;\n \n-  ret = NULL;\n-  if (dc != NULL)\n-    ret = d_print (options, dc, palc);\n+    ret = NULL;\n+    if (dc != NULL)\n+      ret = d_print (options, dc, estimate, palc);\n \n-  free (di.comps);\n+#ifndef CP_DYNAMIC_ARRAYS\n+    free (di.comps);\n+    free (di.subs);\n+#endif\n+\n+#ifdef CP_DEMANGLE_DEBUG\n+    if (ret != NULL)\n+      {\n+\tint rlen;\n+\n+\trlen = strlen (ret);\n+\tif (rlen > 2 * estimate)\n+\t  printf (\"*** Length %d much greater than estimate %d\\n\",\n+\t\t  rlen, estimate);\n+\telse if (rlen > estimate)\n+\t  printf (\"*** Length %d greater than estimate %d\\n\",\n+\t\t  rlen, estimate);\n+\telse if (rlen < estimate / 2)\n+\t  printf (\"*** Length %d much less than estimate %d\\n\",\n+\t\t  rlen, estimate);\n+      }\n+#endif\n+  }\n \n   return ret;\n }\n@@ -3907,48 +4065,73 @@ is_ctor_or_dtor (mangled, ctor_kind, dtor_kind)\n   *ctor_kind = (enum gnu_v3_ctor_kinds) 0;\n   *dtor_kind = (enum gnu_v3_dtor_kinds) 0;\n \n-  if (! d_init_info (mangled, DMGL_GNU_V3, strlen (mangled), &di))\n-    return 0;\n+  d_init_info (mangled, DMGL_GNU_V3, strlen (mangled), &di);\n \n-  dc = d_mangled_name (&di, 1);\n+  {\n+#ifdef CP_DYNAMIC_ARRAYS\n+    __extension__ struct d_comp comps[di.num_comps];\n+    __extension__ struct d_comp *subs[di.num_subs];\n+\n+    di.comps = &comps[0];\n+    di.subs = &subs[0];\n+#else\n+    di.comps = (struct d_comp *) malloc (di.num_comps\n+\t\t\t\t\t * sizeof (struct d_comp));\n+    di.subs = (struct d_comp **) malloc (di.num_subs\n+\t\t\t\t\t * sizeof (struct d_comp *));\n+    if (di.comps == NULL || di.subs == NULL)\n+      {\n+\tif (di.comps != NULL)\n+\t  free (di.comps);\n+\tif (di.subs != NULL)\n+\t  free (di.subs);\n+\t*palc = 1;\n+\treturn NULL;\n+      }\n+#endif\n \n-  /* Note that because we did not pass DMGL_PARAMS, we don't expect to\n-     demangle the entire string.  */\n+    dc = d_mangled_name (&di, 1);\n \n-  ret = 0;\n-  while (dc != NULL)\n-    {\n-      switch (dc->type)\n-\t{\n-\tdefault:\n-\t  dc = NULL;\n-\t  break;\n-\tcase D_COMP_TYPED_NAME:\n-\tcase D_COMP_TEMPLATE:\n-\tcase D_COMP_RESTRICT_THIS:\n-\tcase D_COMP_VOLATILE_THIS:\n-\tcase D_COMP_CONST_THIS:\n-\t  dc = d_left (dc);\n-\t  break;\n-\tcase D_COMP_QUAL_NAME:\n-\tcase D_COMP_LOCAL_NAME:\n-\t  dc = d_right (dc);\n-\t  break;\n-\tcase D_COMP_CTOR:\n-\t  *ctor_kind = dc->u.s_ctor.kind;\n-\t  ret = 1;\n-\t  dc = NULL;\n-\t  break;\n-\tcase D_COMP_DTOR:\n-\t  *dtor_kind = dc->u.s_dtor.kind;\n-\t  ret = 1;\n-\t  dc = NULL;\n-\t  break;\n-\t}\n-    }\n+    /* Note that because we did not pass DMGL_PARAMS, we don't expect\n+       to demangle the entire string.  */\n \n-  free (di.subs);\n-  free (di.comps);\n+    ret = 0;\n+    while (dc != NULL)\n+      {\n+\tswitch (dc->type)\n+\t  {\n+\t  default:\n+\t    dc = NULL;\n+\t    break;\n+\t  case D_COMP_TYPED_NAME:\n+\t  case D_COMP_TEMPLATE:\n+\t  case D_COMP_RESTRICT_THIS:\n+\t  case D_COMP_VOLATILE_THIS:\n+\t  case D_COMP_CONST_THIS:\n+\t    dc = d_left (dc);\n+\t    break;\n+\t  case D_COMP_QUAL_NAME:\n+\t  case D_COMP_LOCAL_NAME:\n+\t    dc = d_right (dc);\n+\t    break;\n+\t  case D_COMP_CTOR:\n+\t    *ctor_kind = dc->u.s_ctor.kind;\n+\t    ret = 1;\n+\t    dc = NULL;\n+\t    break;\n+\t  case D_COMP_DTOR:\n+\t    *dtor_kind = dc->u.s_dtor.kind;\n+\t    ret = 1;\n+\t    dc = NULL;\n+\t    break;\n+\t  }\n+      }\n+\n+#ifndef CP_DYNAMIC_ARRAYS\n+    free (di.subs);\n+    free (di.comps);\n+#endif\n+  }\n \n   return ret;\n }"}]}