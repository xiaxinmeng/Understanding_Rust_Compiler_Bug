{"sha": "cd4241aa715260c4f2d50988c9b77648ea718757", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2Q0MjQxYWE3MTUyNjBjNGYyZDUwOTg4YzliNzc2NDhlYTcxODc1Nw==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@bigpond.net.au", "date": "2005-12-03T00:06:33Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2005-12-03T00:06:33Z"}, "message": "ffi.c: Formatting.\n\n\t* src/powerpc/ffi.c: Formatting.\n\t(ffi_prep_args_SYSV): Avoid possible aliasing problems by using unions.\n\t(ffi_prep_args64): Likewise.\n\nFrom-SVN: r107963", "tree": {"sha": "491ba6146ce7a7d248ec25219847e94134333cdb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/491ba6146ce7a7d248ec25219847e94134333cdb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cd4241aa715260c4f2d50988c9b77648ea718757", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd4241aa715260c4f2d50988c9b77648ea718757", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd4241aa715260c4f2d50988c9b77648ea718757", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd4241aa715260c4f2d50988c9b77648ea718757/comments", "author": null, "committer": null, "parents": [{"sha": "022123e660558e8b22f8c74f368e6bb05f720ac4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/022123e660558e8b22f8c74f368e6bb05f720ac4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/022123e660558e8b22f8c74f368e6bb05f720ac4"}], "stats": {"total": 602, "additions": 345, "deletions": 257}, "files": [{"sha": "49ff74fc9478679292d6e4f09df95d36466beb23", "filename": "libffi/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd4241aa715260c4f2d50988c9b77648ea718757/libffi%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd4241aa715260c4f2d50988c9b77648ea718757/libffi%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FChangeLog?ref=cd4241aa715260c4f2d50988c9b77648ea718757", "patch": "@@ -1,3 +1,9 @@\n+2005-12-03  Alan Modra  <amodra@bigpond.net.au>\n+\n+\t* src/powerpc/ffi.c: Formatting.\n+\t(ffi_prep_args_SYSV): Avoid possible aliasing problems by using unions.\n+\t(ffi_prep_args64): Likewise.\n+\n 2005-09-30  Geoffrey Keating  <geoffk@apple.com>\n \n \t* testsuite/lib/libffi-dg.exp (libffi_target_compile): For"}, {"sha": "bfd7ab6768843b9c2475171564b3d4ddde43575e", "filename": "libffi/src/powerpc/ffi.c", "status": "modified", "additions": 339, "deletions": 257, "changes": 596, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd4241aa715260c4f2d50988c9b77648ea718757/libffi%2Fsrc%2Fpowerpc%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd4241aa715260c4f2d50988c9b77648ea718757/libffi%2Fsrc%2Fpowerpc%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Fffi.c?ref=cd4241aa715260c4f2d50988c9b77648ea718757", "patch": "@@ -30,8 +30,8 @@\n #include <stdio.h>\n \n \n-extern void ffi_closure_SYSV(void);\n-extern void FFI_HIDDEN ffi_closure_LINUX64(void);\n+extern void ffi_closure_SYSV (void);\n+extern void FFI_HIDDEN ffi_closure_LINUX64 (void);\n \n enum {\n   /* The assembly depends on these exact flags.  */\n@@ -81,94 +81,120 @@ enum { ASM_NEEDS_REGISTERS = 4 };\n */\n \n /*@-exportheader@*/\n-void ffi_prep_args_SYSV(extended_cif *ecif, unsigned *const stack)\n+void\n+ffi_prep_args_SYSV (extended_cif *ecif, unsigned *const stack)\n /*@=exportheader@*/\n {\n   const unsigned bytes = ecif->cif->bytes;\n   const unsigned flags = ecif->cif->flags;\n \n+  typedef union {\n+    char *c;\n+    unsigned *u;\n+    long long *ll;\n+    float *f;\n+    double *d;\n+  } valp;\n+\n   /* 'stacktop' points at the previous backchain pointer.  */\n-  unsigned *const stacktop = stack + (bytes / sizeof(unsigned));\n+  valp stacktop;\n \n   /* 'gpr_base' points at the space for gpr3, and grows upwards as\n      we use GPR registers.  */\n-  unsigned *gpr_base = stacktop - ASM_NEEDS_REGISTERS - NUM_GPR_ARG_REGISTERS;\n-  int intarg_count = 0;\n+  valp gpr_base;\n+  int intarg_count;\n \n   /* 'fpr_base' points at the space for fpr1, and grows upwards as\n      we use FPR registers.  */\n-  double *fpr_base = (double *)gpr_base - NUM_FPR_ARG_REGISTERS;\n-  int fparg_count = 0;\n+  valp fpr_base;\n+  int fparg_count;\n \n   /* 'copy_space' grows down as we put structures in it.  It should\n      stay 16-byte aligned.  */\n-  char *copy_space = ((flags & FLAG_FP_ARGUMENTS)\n-\t\t      ? (char *)fpr_base\n-\t\t      : (char *)gpr_base);\n+  valp copy_space;\n \n   /* 'next_arg' grows up as we put parameters in it.  */\n-  unsigned *next_arg = stack + 2;\n+  valp next_arg;\n \n   int i;\n   ffi_type **ptr;\n   double double_tmp;\n-  void **p_argv;\n+  union {\n+    void **v;\n+    char **c;\n+    signed char **sc;\n+    unsigned char **uc;\n+    signed short **ss;\n+    unsigned short **us;\n+    unsigned int **ui;\n+    long long **ll;\n+    float **f;\n+    double **d;\n+  } p_argv;\n   size_t struct_copy_size;\n   unsigned gprvalue;\n \n+  stacktop.c = (char *) stack + bytes;\n+  gpr_base.u = stacktop.u - ASM_NEEDS_REGISTERS - NUM_GPR_ARG_REGISTERS;\n+  intarg_count = 0;\n+  fpr_base.d = gpr_base.d - NUM_FPR_ARG_REGISTERS;\n+  fparg_count = 0;\n+  copy_space.c = ((flags & FLAG_FP_ARGUMENTS) ? fpr_base.c : gpr_base.c);\n+  next_arg.u = stack + 2;\n+\n   /* Check that everything starts aligned properly.  */\n-  FFI_ASSERT(((unsigned)(char *)stack & 0xF) == 0);\n-  FFI_ASSERT(((unsigned)(char *)copy_space & 0xF) == 0);\n-  FFI_ASSERT(((unsigned)(char *)stacktop & 0xF) == 0);\n-  FFI_ASSERT((bytes & 0xF) == 0);\n-  FFI_ASSERT(copy_space >= (char *)next_arg);\n+  FFI_ASSERT (((unsigned) (char *) stack & 0xF) == 0);\n+  FFI_ASSERT (((unsigned) copy_space.c & 0xF) == 0);\n+  FFI_ASSERT (((unsigned) stacktop.c & 0xF) == 0);\n+  FFI_ASSERT ((bytes & 0xF) == 0);\n+  FFI_ASSERT (copy_space.c >= next_arg.c);\n \n   /* Deal with return values that are actually pass-by-reference.  */\n   if (flags & FLAG_RETVAL_REFERENCE)\n     {\n-      *gpr_base++ = (unsigned long)(char *)ecif->rvalue;\n+      *gpr_base.u++ = (unsigned long) (char *) ecif->rvalue;\n       intarg_count++;\n     }\n \n   /* Now for the arguments.  */\n-  p_argv = ecif->avalue;\n+  p_argv.v = ecif->avalue;\n   for (ptr = ecif->cif->arg_types, i = ecif->cif->nargs;\n        i > 0;\n-       i--, ptr++, p_argv++)\n+       i--, ptr++, p_argv.v++)\n     {\n       switch ((*ptr)->type)\n \t{\n \tcase FFI_TYPE_FLOAT:\n-\t  double_tmp = *(float *)*p_argv;\n+\t  double_tmp = **p_argv.f;\n \t  if (fparg_count >= NUM_FPR_ARG_REGISTERS)\n \t    {\n-\t      *(float *)next_arg = (float)double_tmp;\n-\t      next_arg += 1;\n+\t      *next_arg.f = (float) double_tmp;\n+\t      next_arg.u += 1;\n \t    }\n \t  else\n-\t    *fpr_base++ = double_tmp;\n+\t    *fpr_base.d++ = double_tmp;\n \t  fparg_count++;\n-\t  FFI_ASSERT(flags & FLAG_FP_ARGUMENTS);\n+\t  FFI_ASSERT (flags & FLAG_FP_ARGUMENTS);\n \t  break;\n \n \tcase FFI_TYPE_DOUBLE:\n-\t  double_tmp = *(double *)*p_argv;\n+\t  double_tmp = **p_argv.d;\n \n \t  if (fparg_count >= NUM_FPR_ARG_REGISTERS)\n \t    {\n \t      if (intarg_count >= NUM_GPR_ARG_REGISTERS\n \t\t  && intarg_count % 2 != 0)\n \t\t{\n \t\t  intarg_count++;\n-\t\t  next_arg++;\n+\t\t  next_arg.u++;\n \t\t}\n-\t      *(double *)next_arg = double_tmp;\n-\t      next_arg += 2;\n+\t      *next_arg.d = double_tmp;\n+\t      next_arg.u += 2;\n \t    }\n \t  else\n-\t    *fpr_base++ = double_tmp;\n+\t    *fpr_base.d++ = double_tmp;\n \t  fparg_count++;\n-\t  FFI_ASSERT(flags & FLAG_FP_ARGUMENTS);\n+\t  FFI_ASSERT (flags & FLAG_FP_ARGUMENTS);\n \t  break;\n \n \tcase FFI_TYPE_UINT64:\n@@ -177,13 +203,13 @@ void ffi_prep_args_SYSV(extended_cif *ecif, unsigned *const stack)\n \t    intarg_count++;\n \t  if (intarg_count >= NUM_GPR_ARG_REGISTERS)\n \t    {\n-\t      if (intarg_count%2 != 0)\n+\t      if (intarg_count % 2 != 0)\n \t\t{\n \t\t  intarg_count++;\n-\t\t  next_arg++;\n+\t\t  next_arg.u++;\n \t\t}\n-\t      *(long long *)next_arg = *(long long *)*p_argv;\n-\t      next_arg += 2;\n+\t      *next_arg.ll = **p_argv.ll;\n+\t      next_arg.u += 2;\n \t    }\n \t  else\n \t    {\n@@ -194,13 +220,12 @@ void ffi_prep_args_SYSV(extended_cif *ecif, unsigned *const stack)\n \t       * not correct starting register of pair then skip\n \t       * until the proper starting register\n \t       */\n-\t      if (intarg_count%2 != 0)\n+\t      if (intarg_count % 2 != 0)\n \t\t{\n \t\t  intarg_count ++;\n-\t\t  gpr_base++;\n+\t\t  gpr_base.u++;\n \t\t}\n-\t      *(long long *)gpr_base = *(long long *)*p_argv;\n-\t      gpr_base += 2;\n+\t      *gpr_base.ll++ = **p_argv.ll;\n \t    }\n \t  intarg_count += 2;\n \t  break;\n@@ -210,49 +235,50 @@ void ffi_prep_args_SYSV(extended_cif *ecif, unsigned *const stack)\n \tcase FFI_TYPE_LONGDOUBLE:\n #endif\n \t  struct_copy_size = ((*ptr)->size + 15) & ~0xF;\n-\t  copy_space -= struct_copy_size;\n-\t  memcpy(copy_space, (char *)*p_argv, (*ptr)->size);\n+\t  copy_space.c -= struct_copy_size;\n+\t  memcpy (copy_space.c, *p_argv.c, (*ptr)->size);\n \n-\t  gprvalue = (unsigned long)copy_space;\n+\t  gprvalue = (unsigned long) copy_space.c;\n \n-\t  FFI_ASSERT(copy_space > (char *)next_arg);\n-\t  FFI_ASSERT(flags & FLAG_ARG_NEEDS_COPY);\n+\t  FFI_ASSERT (copy_space.c > next_arg.c);\n+\t  FFI_ASSERT (flags & FLAG_ARG_NEEDS_COPY);\n \t  goto putgpr;\n \n \tcase FFI_TYPE_UINT8:\n-\t  gprvalue = *(unsigned char *)*p_argv;\n+\t  gprvalue = **p_argv.uc;\n \t  goto putgpr;\n \tcase FFI_TYPE_SINT8:\n-\t  gprvalue = *(signed char *)*p_argv;\n+\t  gprvalue = **p_argv.sc;\n \t  goto putgpr;\n \tcase FFI_TYPE_UINT16:\n-\t  gprvalue = *(unsigned short *)*p_argv;\n+\t  gprvalue = **p_argv.us;\n \t  goto putgpr;\n \tcase FFI_TYPE_SINT16:\n-\t  gprvalue = *(signed short *)*p_argv;\n+\t  gprvalue = **p_argv.ss;\n \t  goto putgpr;\n \n \tcase FFI_TYPE_INT:\n \tcase FFI_TYPE_UINT32:\n \tcase FFI_TYPE_SINT32:\n \tcase FFI_TYPE_POINTER:\n-\t  gprvalue = *(unsigned *)*p_argv;\n+\t  gprvalue = **p_argv.ui;\n+\n \tputgpr:\n \t  if (intarg_count >= NUM_GPR_ARG_REGISTERS)\n-\t    *next_arg++ = gprvalue;\n+\t    *next_arg.u++ = gprvalue;\n \t  else\n-\t    *gpr_base++ = gprvalue;\n+\t    *gpr_base.u++ = gprvalue;\n \t  intarg_count++;\n \t  break;\n \t}\n     }\n \n   /* Check that we didn't overrun the stack...  */\n-  FFI_ASSERT(copy_space >= (char *)next_arg);\n-  FFI_ASSERT(gpr_base <= stacktop - ASM_NEEDS_REGISTERS);\n-  FFI_ASSERT((unsigned *)fpr_base\n-\t     <= stacktop - ASM_NEEDS_REGISTERS - NUM_GPR_ARG_REGISTERS);\n-  FFI_ASSERT(flags & FLAG_4_GPR_ARGUMENTS || intarg_count <= 4);\n+  FFI_ASSERT (copy_space.c >= next_arg.c);\n+  FFI_ASSERT (gpr_base.u <= stacktop.u - ASM_NEEDS_REGISTERS);\n+  FFI_ASSERT (fpr_base.u\n+\t      <= stacktop.u - ASM_NEEDS_REGISTERS - NUM_GPR_ARG_REGISTERS);\n+  FFI_ASSERT (flags & FLAG_4_GPR_ARGUMENTS || intarg_count <= 4);\n }\n \n /* About the LINUX64 ABI.  */\n@@ -297,159 +323,187 @@ enum { ASM_NEEDS_REGISTERS64 = 4 };\n */\n \n /*@-exportheader@*/\n-void FFI_HIDDEN ffi_prep_args64(extended_cif *ecif, unsigned long *const stack)\n+void FFI_HIDDEN\n+ffi_prep_args64 (extended_cif *ecif, unsigned long *const stack)\n /*@=exportheader@*/\n {\n   const unsigned long bytes = ecif->cif->bytes;\n   const unsigned long flags = ecif->cif->flags;\n \n+  typedef union {\n+    char *c;\n+    unsigned long *ul;\n+    float *f;\n+    double *d;\n+  } valp;\n+\n   /* 'stacktop' points at the previous backchain pointer.  */\n-  unsigned long *const stacktop = stack + (bytes / sizeof(unsigned long));\n+  valp stacktop;\n \n   /* 'next_arg' points at the space for gpr3, and grows upwards as\n      we use GPR registers, then continues at rest.  */\n-  unsigned long *const gpr_base = stacktop - ASM_NEEDS_REGISTERS64\n-    - NUM_GPR_ARG_REGISTERS64;\n-  unsigned long *const gpr_end = gpr_base + NUM_GPR_ARG_REGISTERS64;\n-  unsigned long *const rest = stack + 6 + NUM_GPR_ARG_REGISTERS64;\n-  unsigned long *next_arg = gpr_base;\n+  valp gpr_base;\n+  valp gpr_end;\n+  valp rest;\n+  valp next_arg;\n \n   /* 'fpr_base' points at the space for fpr3, and grows upwards as\n      we use FPR registers.  */\n-  double *fpr_base = (double *)gpr_base - NUM_FPR_ARG_REGISTERS64;\n-  int fparg_count = 0;\n+  valp fpr_base;\n+  int fparg_count;\n \n   int i, words;\n   ffi_type **ptr;\n   double double_tmp;\n-  void **p_argv;\n+  union {\n+    void **v;\n+    char **c;\n+    signed char **sc;\n+    unsigned char **uc;\n+    signed short **ss;\n+    unsigned short **us;\n+    signed int **si;\n+    unsigned int **ui;\n+    unsigned long **ul;\n+    float **f;\n+    double **d;\n+  } p_argv;\n   unsigned long gprvalue;\n \n+  stacktop.c = (char *) stack + bytes;\n+  gpr_base.ul = stacktop.ul - ASM_NEEDS_REGISTERS64 - NUM_GPR_ARG_REGISTERS64;\n+  gpr_end.ul = gpr_base.ul + NUM_GPR_ARG_REGISTERS64;\n+  rest.ul = stack + 6 + NUM_GPR_ARG_REGISTERS64;\n+  fpr_base.d = gpr_base.d - NUM_FPR_ARG_REGISTERS64;\n+  fparg_count = 0;\n+  next_arg.ul = gpr_base.ul;\n+\n   /* Check that everything starts aligned properly.  */\n-  FFI_ASSERT(((unsigned long)(char *)stack & 0xF) == 0);\n-  FFI_ASSERT(((unsigned long)(char *)stacktop & 0xF) == 0);\n-  FFI_ASSERT((bytes & 0xF) == 0);\n+  FFI_ASSERT (((unsigned long) (char *) stack & 0xF) == 0);\n+  FFI_ASSERT (((unsigned long) stacktop.c & 0xF) == 0);\n+  FFI_ASSERT ((bytes & 0xF) == 0);\n \n   /* Deal with return values that are actually pass-by-reference.  */\n   if (flags & FLAG_RETVAL_REFERENCE)\n-    *next_arg++ = (unsigned long)(char *)ecif->rvalue;\n+    *next_arg.ul++ = (unsigned long) (char *) ecif->rvalue;\n \n   /* Now for the arguments.  */\n-  p_argv = ecif->avalue;\n+  p_argv.v = ecif->avalue;\n   for (ptr = ecif->cif->arg_types, i = ecif->cif->nargs;\n        i > 0;\n-       i--, ptr++, p_argv++)\n+       i--, ptr++, p_argv.v++)\n     {\n       switch ((*ptr)->type)\n \t{\n \tcase FFI_TYPE_FLOAT:\n-\t  double_tmp = *(float *)*p_argv;\n-\t  *(float *)next_arg = (float)double_tmp;\n-\t  if (++next_arg == gpr_end)\n-\t    next_arg = rest;\n+\t  double_tmp = **p_argv.f;\n+\t  *next_arg.f = (float) double_tmp;\n+\t  if (++next_arg.ul == gpr_end.ul)\n+\t    next_arg.ul = rest.ul;\n \t  if (fparg_count < NUM_FPR_ARG_REGISTERS64)\n-\t    *fpr_base++ = double_tmp;\n+\t    *fpr_base.d++ = double_tmp;\n \t  fparg_count++;\n-\t  FFI_ASSERT(flags & FLAG_FP_ARGUMENTS);\n+\t  FFI_ASSERT (flags & FLAG_FP_ARGUMENTS);\n \t  break;\n \n \tcase FFI_TYPE_DOUBLE:\n-\t  double_tmp = *(double *)*p_argv;\n-\t  *(double *)next_arg = double_tmp;\n-\t  if (++next_arg == gpr_end)\n-\t    next_arg = rest;\n+\t  double_tmp = **p_argv.d;\n+\t  *next_arg.d = double_tmp;\n+\t  if (++next_arg.ul == gpr_end.ul)\n+\t    next_arg.ul = rest.ul;\n \t  if (fparg_count < NUM_FPR_ARG_REGISTERS64)\n-\t    *fpr_base++ = double_tmp;\n+\t    *fpr_base.d++ = double_tmp;\n \t  fparg_count++;\n-\t  FFI_ASSERT(flags & FLAG_FP_ARGUMENTS);\n+\t  FFI_ASSERT (flags & FLAG_FP_ARGUMENTS);\n \t  break;\n \n #if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n \tcase FFI_TYPE_LONGDOUBLE:\n-\t  double_tmp = ((double *) *p_argv)[0];\n-\t  *(double *) next_arg = double_tmp;\n-\t  if (++next_arg == gpr_end)\n-\t    next_arg = rest;\n+\t  double_tmp = (*p_argv.d)[0];\n+\t  *next_arg.d = double_tmp;\n+\t  if (++next_arg.ul == gpr_end.ul)\n+\t    next_arg.ul = rest.ul;\n \t  if (fparg_count < NUM_FPR_ARG_REGISTERS64)\n-\t    *fpr_base++ = double_tmp;\n+\t    *fpr_base.d++ = double_tmp;\n \t  fparg_count++;\n-\t  double_tmp = ((double *) *p_argv)[1];\n-\t  *(double *) next_arg = double_tmp;\n-\t  if (++next_arg == gpr_end)\n-\t    next_arg = rest;\n+\t  double_tmp = (*p_argv.d)[1];\n+\t  *next_arg.d = double_tmp;\n+\t  if (++next_arg.ul == gpr_end.ul)\n+\t    next_arg.ul = rest.ul;\n \t  if (fparg_count < NUM_FPR_ARG_REGISTERS64)\n-\t    *fpr_base++ = double_tmp;\n+\t    *fpr_base.d++ = double_tmp;\n \t  fparg_count++;\n-\t  FFI_ASSERT(flags & FLAG_FP_ARGUMENTS);\n+\t  FFI_ASSERT (flags & FLAG_FP_ARGUMENTS);\n \t  break;\n #endif\n \n \tcase FFI_TYPE_STRUCT:\n \t  words = ((*ptr)->size + 7) / 8;\n-\t  if (next_arg >= gpr_base && next_arg + words > gpr_end)\n+\t  if (next_arg.ul >= gpr_base.ul && next_arg.ul + words > gpr_end.ul)\n \t    {\n-\t      size_t first = (char *) gpr_end - (char *) next_arg;\n-\t      memcpy((char *) next_arg, (char *) *p_argv, first);\n-\t      memcpy((char *) rest, (char *) *p_argv + first,\n-\t\t     (*ptr)->size - first);\n-\t      next_arg = (unsigned long *) ((char *) rest + words * 8 - first);\n+\t      size_t first = gpr_end.c - next_arg.c;\n+\t      memcpy (next_arg.c, *p_argv.c, first);\n+\t      memcpy (rest.c, *p_argv.c + first, (*ptr)->size - first);\n+\t      next_arg.c = rest.c + words * 8 - first;\n \t    }\n \t  else\n \t    {\n-\t      char *where = (char *) next_arg;\n+\t      char *where = next_arg.c;\n \n \t      /* Structures with size less than eight bytes are passed\n \t\t left-padded.  */\n \t      if ((*ptr)->size < 8)\n \t\twhere += 8 - (*ptr)->size;\n \n-\t      memcpy (where, (char *) *p_argv, (*ptr)->size);\n-\t      next_arg += words;\n-\t      if (next_arg == gpr_end)\n-\t\tnext_arg = rest;\n+\t      memcpy (where, *p_argv.c, (*ptr)->size);\n+\t      next_arg.ul += words;\n+\t      if (next_arg.ul == gpr_end.ul)\n+\t\tnext_arg.ul = rest.ul;\n \t    }\n \t  break;\n \n \tcase FFI_TYPE_UINT8:\n-\t  gprvalue = *(unsigned char *)*p_argv;\n+\t  gprvalue = **p_argv.uc;\n \t  goto putgpr;\n \tcase FFI_TYPE_SINT8:\n-\t  gprvalue = *(signed char *)*p_argv;\n+\t  gprvalue = **p_argv.sc;\n \t  goto putgpr;\n \tcase FFI_TYPE_UINT16:\n-\t  gprvalue = *(unsigned short *)*p_argv;\n+\t  gprvalue = **p_argv.us;\n \t  goto putgpr;\n \tcase FFI_TYPE_SINT16:\n-\t  gprvalue = *(signed short *)*p_argv;\n+\t  gprvalue = **p_argv.ss;\n \t  goto putgpr;\n \tcase FFI_TYPE_UINT32:\n-\t  gprvalue = *(unsigned int *)*p_argv;\n+\t  gprvalue = **p_argv.ui;\n \t  goto putgpr;\n \tcase FFI_TYPE_INT:\n \tcase FFI_TYPE_SINT32:\n-\t  gprvalue = *(signed int *)*p_argv;\n+\t  gprvalue = **p_argv.si;\n \t  goto putgpr;\n \n \tcase FFI_TYPE_UINT64:\n \tcase FFI_TYPE_SINT64:\n \tcase FFI_TYPE_POINTER:\n-\t  gprvalue = *(unsigned long *)*p_argv;\n+\t  gprvalue = **p_argv.ul;\n \tputgpr:\n-\t  *next_arg++ = gprvalue;\n-\t  if (next_arg == gpr_end)\n-\t    next_arg = rest;\n+\t  *next_arg.ul++ = gprvalue;\n+\t  if (next_arg.ul == gpr_end.ul)\n+\t    next_arg.ul = rest.ul;\n \t  break;\n \t}\n     }\n \n-  FFI_ASSERT(flags & FLAG_4_GPR_ARGUMENTS\n-\t     || (next_arg >= gpr_base && next_arg <= gpr_base + 4));\n+  FFI_ASSERT (flags & FLAG_4_GPR_ARGUMENTS\n+\t      || (next_arg.ul >= gpr_base.ul\n+\t\t  && next_arg.ul <= gpr_base.ul + 4));\n }\n \n \n \n /* Perform machine dependent cif processing */\n-ffi_status ffi_prep_cif_machdep(ffi_cif *cif)\n+ffi_status\n+ffi_prep_cif_machdep (ffi_cif *cif)\n {\n   /* All this is for the SYSV and LINUX64 ABI.  */\n   int i;\n@@ -467,21 +521,21 @@ ffi_status ffi_prep_cif_machdep(ffi_cif *cif)\n \t Redo the calculation for SYSV.  */\n \n       /* Space for the frame pointer, callee's LR, and the asm's temp regs.  */\n-      bytes = (2 + ASM_NEEDS_REGISTERS) * sizeof(int);\n+      bytes = (2 + ASM_NEEDS_REGISTERS) * sizeof (int);\n \n       /* Space for the GPR registers.  */\n-      bytes += NUM_GPR_ARG_REGISTERS * sizeof(int);\n+      bytes += NUM_GPR_ARG_REGISTERS * sizeof (int);\n     }\n   else\n     {\n       /* 64-bit ABI.  */\n \n       /* Space for backchain, CR, LR, cc/ld doubleword, TOC and the asm's temp\n \t regs.  */\n-      bytes = (6 + ASM_NEEDS_REGISTERS64) * sizeof(long);\n+      bytes = (6 + ASM_NEEDS_REGISTERS64) * sizeof (long);\n \n       /* Space for the mandatory parm save area and general registers.  */\n-      bytes += 2 * NUM_GPR_ARG_REGISTERS64 * sizeof(long);\n+      bytes += 2 * NUM_GPR_ARG_REGISTERS64 * sizeof (long);\n \n #if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n       if (type == FFI_TYPE_LONGDOUBLE)\n@@ -523,23 +577,26 @@ ffi_status ffi_prep_cif_machdep(ffi_cif *cif)\n \t     in memory.  */\n \n \t  /* Treat structs with size <= 8 bytes.  */\n-\t  if (size <= 8) {\n-\t    flags |= FLAG_RETURNS_SMST;\n-\t    /* These structs are returned in r3. We pack the type and the\n-\t       precalculated shift value (needed in the sysv.S) into flags.\n-\t       The same applies for the structs returned in r3/r4.  */\n-\t    if (size <= 4) {\n-\t      flags |= 1 << (31 - FFI_SYSV_TYPE_SMALL_STRUCT - 1 )\n-\t\t| (8 * (4 - size) << 4);\n-\t      break;\n-\t    }\n-\t    /* These structs are returned in r3 and r4. See above.   */\n-\t    if  (size <= 8) {\n-\t      flags |= 1 << (31 - FFI_SYSV_TYPE_SMALL_STRUCT - 2 )\n-\t\t| (8 * (8 - size) << 4);\n-\t    break;\n+\t  if (size <= 8)\n+\t    {\n+\t      flags |= FLAG_RETURNS_SMST;\n+\t      /* These structs are returned in r3. We pack the type and the\n+\t\t precalculated shift value (needed in the sysv.S) into flags.\n+\t\t The same applies for the structs returned in r3/r4.  */\n+\t      if (size <= 4)\n+\t\t{\n+\t\t  flags |= 1 << (31 - FFI_SYSV_TYPE_SMALL_STRUCT - 1);\n+\t\t  flags |= 8 * (4 - size) << 4;\n+\t\t  break;\n+\t\t}\n+\t      /* These structs are returned in r3 and r4. See above.   */\n+\t      if  (size <= 8)\n+\t\t{\n+\t\t  flags |= 1 << (31 - FFI_SYSV_TYPE_SMALL_STRUCT - 2);\n+\t\t  flags |= 8 * (8 - size) << 4;\n+\t\t  break;\n+\t\t}\n \t    }\n-\t  }\n \t}\n       /* else fall through.  */\n #if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n@@ -600,7 +657,7 @@ ffi_status ffi_prep_cif_machdep(ffi_cif *cif)\n \t       (r7,r8), (r9,r10).\n \t    */\n \t    if (intarg_count == NUM_GPR_ARG_REGISTERS-1\n-\t\t|| intarg_count%2 != 0)\n+\t\t|| intarg_count % 2 != 0)\n \t      intarg_count++;\n \t    intarg_count += 2;\n \t    break;\n@@ -663,23 +720,23 @@ ffi_status ffi_prep_cif_machdep(ffi_cif *cif)\n     {\n       /* Space for the FPR registers, if needed.  */\n       if (fparg_count != 0)\n-\tbytes += NUM_FPR_ARG_REGISTERS * sizeof(double);\n+\tbytes += NUM_FPR_ARG_REGISTERS * sizeof (double);\n \n       /* Stack space.  */\n       if (intarg_count > NUM_GPR_ARG_REGISTERS)\n-\tbytes += (intarg_count - NUM_GPR_ARG_REGISTERS) * sizeof(int);\n+\tbytes += (intarg_count - NUM_GPR_ARG_REGISTERS) * sizeof (int);\n       if (fparg_count > NUM_FPR_ARG_REGISTERS)\n-\tbytes += (fparg_count - NUM_FPR_ARG_REGISTERS) * sizeof(double);\n+\tbytes += (fparg_count - NUM_FPR_ARG_REGISTERS) * sizeof (double);\n     }\n   else\n     {\n       /* Space for the FPR registers, if needed.  */\n       if (fparg_count != 0)\n-\tbytes += NUM_FPR_ARG_REGISTERS64 * sizeof(double);\n+\tbytes += NUM_FPR_ARG_REGISTERS64 * sizeof (double);\n \n       /* Stack space.  */\n       if (intarg_count > NUM_GPR_ARG_REGISTERS64)\n-\tbytes += (intarg_count - NUM_GPR_ARG_REGISTERS64) * sizeof(long);\n+\tbytes += (intarg_count - NUM_GPR_ARG_REGISTERS64) * sizeof (long);\n     }\n \n   /* The stack space allocated needs to be a multiple of 16 bytes.  */\n@@ -707,10 +764,11 @@ extern void FFI_HIDDEN ffi_call_LINUX64(/*@out@*/ extended_cif *,\n /*@=declundef@*/\n /*@=exportheader@*/\n \n-void ffi_call(/*@dependent@*/ ffi_cif *cif,\n-\t      void (*fn)(),\n-\t      /*@out@*/ void *rvalue,\n-\t      /*@dependent@*/ void **avalue)\n+void\n+ffi_call(/*@dependent@*/ ffi_cif *cif,\n+\t void (*fn)(),\n+\t /*@out@*/ void *rvalue,\n+\t /*@dependent@*/ void **avalue)\n {\n   extended_cif ecif;\n \n@@ -720,8 +778,7 @@ void ffi_call(/*@dependent@*/ ffi_cif *cif,\n   /* If the return value is a struct and we don't have a return\t*/\n   /* value address then we need to make one\t\t        */\n \n-  if ((rvalue == NULL) &&\n-      (cif->rtype->type == FFI_TYPE_STRUCT))\n+  if ((rvalue == NULL) && (cif->rtype->type == FFI_TYPE_STRUCT))\n     {\n       /*@-sysunrecog@*/\n       ecif.rvalue = alloca(cif->rtype->size);\n@@ -737,47 +794,47 @@ void ffi_call(/*@dependent@*/ ffi_cif *cif,\n     case FFI_SYSV:\n     case FFI_GCC_SYSV:\n       /*@-usedef@*/\n-      ffi_call_SYSV(&ecif, -cif->bytes,\n-\t\t    cif->flags, ecif.rvalue, fn);\n+      ffi_call_SYSV (&ecif, -cif->bytes, cif->flags, ecif.rvalue, fn);\n       /*@=usedef@*/\n       break;\n #else\n     case FFI_LINUX64:\n       /*@-usedef@*/\n-      ffi_call_LINUX64(&ecif, -(long) cif->bytes,\n-\t\t       cif->flags, ecif.rvalue, fn);\n+      ffi_call_LINUX64 (&ecif, -(long) cif->bytes, cif->flags, ecif.rvalue, fn);\n       /*@=usedef@*/\n       break;\n #endif\n     default:\n-      FFI_ASSERT(0);\n+      FFI_ASSERT (0);\n       break;\n     }\n }\n \n \n #ifndef POWERPC64\n-static void flush_icache(char *, int);\n-\n #define MIN_CACHE_LINE_SIZE 8\n \n-static void flush_icache(char * addr1, int size)\n+static void\n+flush_icache (char *addr1, int size)\n {\n   int i;\n   char * addr;\n-  for (i = 0; i < size; i += MIN_CACHE_LINE_SIZE) {\n-    addr = addr1 + i;\n-    __asm__ volatile (\"icbi 0,%0;\" \"dcbf 0,%0;\" : : \"r\"(addr) : \"memory\");\n-  }\n+  for (i = 0; i < size; i += MIN_CACHE_LINE_SIZE)\n+    {\n+      addr = addr1 + i;\n+      __asm__ volatile (\"icbi 0,%0;\" \"dcbf 0,%0;\"\n+\t\t\t: : \"r\" (addr) : \"memory\");\n+    }\n   addr = addr1 + size - 1;\n-  __asm__ volatile (\"icbi 0,%0;\" \"dcbf 0,%0;\" \"sync;\" \"isync;\" : : \"r\"(addr) : \"memory\");\n+  __asm__ volatile (\"icbi 0,%0;\" \"dcbf 0,%0;\" \"sync;\" \"isync;\"\n+\t\t    : : \"r\"(addr) : \"memory\");\n }\n #endif\n \n ffi_status\n-ffi_prep_closure (ffi_closure* closure,\n-\t\t  ffi_cif* cif,\n-\t\t  void (*fun)(ffi_cif*, void*, void**, void*),\n+ffi_prep_closure (ffi_closure *closure,\n+\t\t  ffi_cif *cif,\n+\t\t  void (*fun) (ffi_cif *, void *, void **, void *),\n \t\t  void *user_data)\n {\n #ifdef POWERPC64\n@@ -801,11 +858,11 @@ ffi_prep_closure (ffi_closure* closure,\n   tramp[7] = 0x816b0004;  /*   lwz     r11,4(r11) */\n   tramp[8] = 0x7c0903a6;  /*   mtctr   r0 */\n   tramp[9] = 0x4e800420;  /*   bctr */\n-  *(void **) &tramp[2] = (void *)ffi_closure_SYSV; /* function */\n-  *(void **) &tramp[3] = (void *)closure;          /* context */\n+  *(void **) &tramp[2] = (void *) ffi_closure_SYSV; /* function */\n+  *(void **) &tramp[3] = (void *) closure;          /* context */\n \n   /* Flush the icache.  */\n-  flush_icache(&closure->tramp[0],FFI_TRAMPOLINE_SIZE);\n+  flush_icache (&closure->tramp[0],FFI_TRAMPOLINE_SIZE);\n #endif\n \n   closure->cif = cif;\n@@ -821,8 +878,8 @@ typedef union\n   double d;\n } ffi_dblfl;\n \n-int ffi_closure_helper_SYSV (ffi_closure*, void*, unsigned long*,\n-\t\t\t     ffi_dblfl*, unsigned long*);\n+int ffi_closure_helper_SYSV (ffi_closure *, void *, unsigned long *,\n+\t\t\t     ffi_dblfl *, unsigned long *);\n \n /* Basically the trampoline invokes ffi_closure_SYSV, and on\n  * entry, r11 holds the address of the closure.\n@@ -833,9 +890,9 @@ int ffi_closure_helper_SYSV (ffi_closure*, void*, unsigned long*,\n  */\n \n int\n-ffi_closure_helper_SYSV (ffi_closure* closure, void * rvalue,\n-\t\t\t unsigned long * pgr, ffi_dblfl * pfr,\n-\t\t\t unsigned long * pst)\n+ffi_closure_helper_SYSV (ffi_closure *closure, void *rvalue,\n+\t\t\t unsigned long *pgr, ffi_dblfl *pfr,\n+\t\t\t unsigned long *pst)\n {\n   /* rvalue is the pointer to space for return value in closure assembly */\n   /* pgr is the pointer to where r3-r10 are stored in ffi_closure_SYSV */\n@@ -852,7 +909,7 @@ ffi_closure_helper_SYSV (ffi_closure* closure, void * rvalue,\n   unsigned         size;\n \n   cif = closure->cif;\n-  avalue = alloca(cif->nargs * sizeof(void *));\n+  avalue = alloca (cif->nargs * sizeof (void *));\n   size = cif->rtype->size;\n \n   nf = 0;\n@@ -865,11 +922,12 @@ ffi_closure_helper_SYSV (ffi_closure* closure, void * rvalue,\n \n   if (cif->rtype->type == FFI_TYPE_STRUCT)\n     {\n-      if (!((cif->abi == FFI_SYSV) && (size <= 8))) {\n-\trvalue = (void *) *pgr;\n-\tng++;\n-\tpgr++;\n-      }\n+      if (!((cif->abi == FFI_SYSV) && (size <= 8)))\n+\t{\n+\t  rvalue = (void *) *pgr;\n+\t  ng++;\n+\t  pgr++;\n+\t}\n     }\n \n   i = 0;\n@@ -884,54 +942,66 @@ ffi_closure_helper_SYSV (ffi_closure* closure, void * rvalue,\n \tcase FFI_TYPE_SINT8:\n \tcase FFI_TYPE_UINT8:\n \t  /* there are 8 gpr registers used to pass values */\n-\t  if (ng < 8) {\n-\t    avalue[i] = (((char *)pgr)+3);\n-\t    ng++;\n-\t    pgr++;\n-\t  } else {\n-\t    avalue[i] = (((char *)pst)+3);\n-\t    pst++;\n-\t  }\n+\t  if (ng < 8)\n+\t    {\n+\t      avalue[i] = (char *) pgr + 3;\n+\t      ng++;\n+\t      pgr++;\n+\t    }\n+\t  else\n+\t    {\n+\t      avalue[i] = (char *) pst + 3;\n+\t      pst++;\n+\t    }\n \t  break;\n \n \tcase FFI_TYPE_SINT16:\n \tcase FFI_TYPE_UINT16:\n \t  /* there are 8 gpr registers used to pass values */\n-\t  if (ng < 8) {\n-\t    avalue[i] = (((char *)pgr)+2);\n-\t    ng++;\n-\t    pgr++;\n-\t  } else {\n-\t    avalue[i] = (((char *)pst)+2);\n-\t    pst++;\n-\t  }\n+\t  if (ng < 8)\n+\t    {\n+\t      avalue[i] = (char *) pgr + 2;\n+\t      ng++;\n+\t      pgr++;\n+\t    }\n+\t  else\n+\t    {\n+\t      avalue[i] = (char *) pst + 2;\n+\t      pst++;\n+\t    }\n \t  break;\n \n \tcase FFI_TYPE_SINT32:\n \tcase FFI_TYPE_UINT32:\n \tcase FFI_TYPE_POINTER:\n \t  /* there are 8 gpr registers used to pass values */\n-\t  if (ng < 8) {\n-\t    avalue[i] = pgr;\n-\t    ng++;\n-\t    pgr++;\n-\t  } else {\n-\t    avalue[i] = pst;\n-\t    pst++;\n-\t  }\n+\t  if (ng < 8)\n+\t    {\n+\t      avalue[i] = pgr;\n+\t      ng++;\n+\t      pgr++;\n+\t    }\n+\t  else\n+\t    {\n+\t      avalue[i] = pst;\n+\t      pst++;\n+\t    }\n \t  break;\n \n \tcase FFI_TYPE_STRUCT:\n \t  /* Structs are passed by reference. The address will appear in a\n \t     gpr if it is one of the first 8 arguments.  */\n-\t  if (ng < 8) {\n-\t    avalue[i] = (void *) *pgr;\n-\t    ng++;\n-\t    pgr++;\n-\t  } else {\n-\t    avalue[i] = (void *) *pst;\n-\t    pst++;\n-\t  }\n+\t  if (ng < 8)\n+\t    {\n+\t      avalue[i] = (void *) *pgr;\n+\t      ng++;\n+\t      pgr++;\n+\t    }\n+\t  else\n+\t    {\n+\t      avalue[i] = (void *) *pst;\n+\t      pst++;\n+\t    }\n \t  break;\n \n \tcase FFI_TYPE_SINT64:\n@@ -945,20 +1015,25 @@ ffi_closure_helper_SYSV (ffi_closure* closure, void * rvalue,\n \t   * or pst to find the correct address for this type\n \t   * of parameter.\n \t   */\n-\t  if (ng < 7) {\n-\t    if (ng & 0x01) {\n-\t      /* skip r4, r6, r8 as starting points */\n-\t      ng++;\n-\t      pgr++;\n+\t  if (ng < 7)\n+\t    {\n+\t      if (ng & 0x01)\n+\t\t{\n+\t\t  /* skip r4, r6, r8 as starting points */\n+\t\t  ng++;\n+\t\t  pgr++;\n+\t\t}\n+\t      avalue[i] = pgr;\n+\t      ng += 2;\n+\t      pgr += 2;\n+\t    }\n+\t  else\n+\t    {\n+\t      if (((long) pst) & 4)\n+\t\tpst++;\n+\t      avalue[i] = pst;\n+\t      pst += 2;\n \t    }\n-\t    avalue[i] = pgr;\n-\t    ng+=2;\n-\t    pgr+=2;\n-\t  } else {\n-\t    if (((long)pst) & 4) pst++;\n-\t    avalue[i] = pst;\n-\t    pst+=2;\n-\t  }\n \t  break;\n \n \tcase FFI_TYPE_FLOAT:\n@@ -969,42 +1044,49 @@ ffi_closure_helper_SYSV (ffi_closure* closure, void * rvalue,\n \n \t  /* there are 8 64bit floating point registers */\n \n-\t  if (nf < 8) {\n-\t    temp = pfr->d;\n-\t    pfr->f = (float)temp;\n-\t    avalue[i] = pfr;\n-\t    nf++;\n-\t    pfr++;\n-\t  } else {\n-\t    /* FIXME? here we are really changing the values\n-\t     * stored in the original calling routines outgoing\n-\t     * parameter stack.  This is probably a really\n-\t     * naughty thing to do but...\n-\t     */\n-\t    avalue[i] = pst;\n-\t    nf++;\n-\t    pst+=1;\n-\t  }\n+\t  if (nf < 8)\n+\t    {\n+\t      temp = pfr->d;\n+\t      pfr->f = (float) temp;\n+\t      avalue[i] = pfr;\n+\t      nf++;\n+\t      pfr++;\n+\t    }\n+\t  else\n+\t    {\n+\t      /* FIXME? here we are really changing the values\n+\t       * stored in the original calling routines outgoing\n+\t       * parameter stack.  This is probably a really\n+\t       * naughty thing to do but...\n+\t       */\n+\t      avalue[i] = pst;\n+\t      nf++;\n+\t      pst += 1;\n+\t    }\n \t  break;\n \n \tcase FFI_TYPE_DOUBLE:\n \t  /* On the outgoing stack all values are aligned to 8 */\n \t  /* there are 8 64bit floating point registers */\n \n-\t  if (nf < 8) {\n-\t    avalue[i] = pfr;\n-\t    nf++;\n-\t    pfr++;\n-\t  } else {\n-\t    if (((long)pst) & 4) pst++;\n-\t    avalue[i] = pst;\n-\t    nf++;\n-\t    pst+=2;\n-\t  }\n+\t  if (nf < 8)\n+\t    {\n+\t      avalue[i] = pfr;\n+\t      nf++;\n+\t      pfr++;\n+\t    }\n+\t  else\n+\t    {\n+\t      if (((long) pst) & 4)\n+\t\tpst++;\n+\t      avalue[i] = pst;\n+\t      nf++;\n+\t      pst += 2;\n+\t    }\n \t  break;\n \n \tdefault:\n-\t  FFI_ASSERT(0);\n+\t  FFI_ASSERT (0);\n \t}\n \n       i++;\n@@ -1023,8 +1105,8 @@ ffi_closure_helper_SYSV (ffi_closure* closure, void * rvalue,\n \n }\n \n-int FFI_HIDDEN ffi_closure_helper_LINUX64 (ffi_closure*, void*, unsigned long*,\n-\t\t\t\t\t   ffi_dblfl*);\n+int FFI_HIDDEN ffi_closure_helper_LINUX64 (ffi_closure *, void *,\n+\t\t\t\t\t   unsigned long *, ffi_dblfl *);\n \n int FFI_HIDDEN\n ffi_closure_helper_LINUX64 (ffi_closure *closure, void *rvalue,\n@@ -1153,7 +1235,7 @@ ffi_closure_helper_LINUX64 (ffi_closure *closure, void *rvalue,\n #endif\n \n \tdefault:\n-\t  FFI_ASSERT(0);\n+\t  FFI_ASSERT (0);\n \t}\n \n       i++;"}]}