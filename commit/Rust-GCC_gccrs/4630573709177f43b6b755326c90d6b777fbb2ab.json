{"sha": "4630573709177f43b6b755326c90d6b777fbb2ab", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDYzMDU3MzcwOTE3N2Y0M2I2Yjc1NTMyNmM5MGQ2Yjc3N2ZiYjJhYg==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2015-03-02T00:54:46Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2015-03-02T00:54:46Z"}, "message": "ipa-icf.c: Include stor-layout.h\n\n\n\t* ipa-icf.c: Include stor-layout.h\n\t(sem_function::compare_cgraph_references): Rename to ...\n\t(sem_item::compare_cgraph_references): ... this one.\n\t(sem_variable::equals_wpa): New function\n\t(sem_variable::equals): Do not check stuff already verified by\n\tequals_wpa.\n\t(sem_variable::equals): Reorg based on varasm.c:compare_constant.\n\t* ipa-icf.h (sem_item): Add compare_cgraph_references.\n\t(sem_function): Remove compare_cgraph_references.\n\t(sem_variable): Turns equals_wpa into non-inline.\n\nFrom-SVN: r221096", "tree": {"sha": "1bf0d2f405c6066ed16c44e927b47c0df6db8629", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1bf0d2f405c6066ed16c44e927b47c0df6db8629"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4630573709177f43b6b755326c90d6b777fbb2ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4630573709177f43b6b755326c90d6b777fbb2ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4630573709177f43b6b755326c90d6b777fbb2ab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4630573709177f43b6b755326c90d6b777fbb2ab/comments", "author": null, "committer": null, "parents": [{"sha": "3c37b96b8761e80bd99fc1e19879f94e647d6869", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c37b96b8761e80bd99fc1e19879f94e647d6869", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c37b96b8761e80bd99fc1e19879f94e647d6869"}], "stats": {"total": 248, "additions": 201, "deletions": 47}, "files": [{"sha": "7b002bbcdfc76f54259fe76b4c4b355457ca48cd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4630573709177f43b6b755326c90d6b777fbb2ab/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4630573709177f43b6b755326c90d6b777fbb2ab/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4630573709177f43b6b755326c90d6b777fbb2ab", "patch": "@@ -1,3 +1,16 @@\n+2015-02-28  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* ipa-icf.c: Include stor-layout.h\n+\t(sem_function::compare_cgraph_references): Rename to ...\n+\t(sem_item::compare_cgraph_references): ... this one.\n+\t(sem_variable::equals_wpa): New function\n+\t(sem_variable::equals): Do not check stuff already verified by\n+\tequals_wpa.\n+\t(sem_variable::equals): Reorg based on varasm.c:compare_constant.\n+\t* ipa-icf.h (sem_item): Add compare_cgraph_references.\n+\t(sem_function): Remove compare_cgraph_references.\n+\t(sem_variable): Turns equals_wpa into non-inline.\n+\n 2015-02-28  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* ipa-icf.c (sem_function::init): Fix formating; skip GIMPLE_PREDICT."}, {"sha": "a2d99e9a8e831b8a3258068f41f3a409c8515d8e", "filename": "gcc/ipa-icf.c", "status": "modified", "additions": 177, "deletions": 33, "changes": 210, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4630573709177f43b6b755326c90d6b777fbb2ab/gcc%2Fipa-icf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4630573709177f43b6b755326c90d6b777fbb2ab/gcc%2Fipa-icf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf.c?ref=4630573709177f43b6b755326c90d6b777fbb2ab", "patch": "@@ -53,6 +53,7 @@ along with GCC; see the file COPYING3.  If not see\n \n #include \"config.h\"\n #include \"system.h\"\n+#include <list>\n #include \"coretypes.h\"\n #include \"hash-set.h\"\n #include \"machmode.h\"\n@@ -119,9 +120,9 @@ along with GCC; see the file COPYING3.  If not see\n #include \"lto-streamer.h\"\n #include \"data-streamer.h\"\n #include \"ipa-utils.h\"\n-#include <list>\n #include \"ipa-icf-gimple.h\"\n #include \"ipa-icf.h\"\n+#include \"stor-layout.h\"\n \n using namespace ipa_icf_gimple;\n \n@@ -338,7 +339,7 @@ sem_function::get_hash (void)\n    contains these nodes.  ADDRESS indicate if address is taken.  */\n \n bool\n-sem_function::compare_cgraph_references (\n+sem_item::compare_cgraph_references (\n     hash_map <symtab_node *, sem_item *> &ignored_nodes,\n     symtab_node *n1, symtab_node *n2, bool address)\n {\n@@ -1395,6 +1396,56 @@ sem_variable::sem_variable (varpool_node *node, hashval_t _hash,\n   gcc_checking_assert (get_node ());\n }\n \n+/* Fast equality function based on knowledge known in WPA.  */\n+\n+bool\n+sem_variable::equals_wpa (sem_item *item,\n+\t\t\t  hash_map <symtab_node *, sem_item *> &ignored_nodes)\n+{\n+  gcc_assert (item->type == VAR);\n+\n+  if (node->num_references () != item->node->num_references ())\n+    return return_false_with_msg (\"different number of references\");\n+\n+  if (DECL_TLS_MODEL (decl) || DECL_TLS_MODEL (item->decl))\n+    return return_false_with_msg (\"TLS model\");\n+\n+  if (DECL_ALIGN (decl) != DECL_ALIGN (item->decl))\n+    return return_false_with_msg (\"alignment mismatch\");\n+\n+  if (DECL_VIRTUAL_P (decl) != DECL_VIRTUAL_P (item->decl))\n+    return return_false_with_msg (\"Virtual flag mismatch\");\n+\n+  if (DECL_SIZE (decl) != DECL_SIZE (item->decl)\n+      && ((!DECL_SIZE (decl) || !DECL_SIZE (item->decl))\n+\t  || !operand_equal_p (DECL_SIZE (decl),\n+\t\t\t       DECL_SIZE (item->decl), OEP_ONLY_CONST)))\n+    return return_false_with_msg (\"size mismatch\");\n+\n+  /* Do not attempt to mix data from different user sections;\n+     we do not know what user intends with those.  */\n+  if (((DECL_SECTION_NAME (decl) && !node->implicit_section)\n+       || (DECL_SECTION_NAME (item->decl) && !item->node->implicit_section))\n+      && DECL_SECTION_NAME (decl) != DECL_SECTION_NAME (item->decl))\n+    return return_false_with_msg (\"user section mismatch\");\n+\n+  if (DECL_IN_TEXT_SECTION (decl) != DECL_IN_TEXT_SECTION (item->decl))\n+    return return_false_with_msg (\"text section\");\n+\n+  ipa_ref *ref = NULL, *ref2 = NULL;\n+  for (unsigned i = 0; node->iterate_reference (i, ref); i++)\n+    {\n+      item->node->iterate_reference (i, ref2);\n+\n+      if (!compare_cgraph_references (ignored_nodes,\n+\t\t\t\t      ref->referred, ref2->referred,\n+\t\t\t\t      ref->address_matters_p ()))\n+\treturn false;\n+    }\n+\n+  return true;\n+}\n+\n /* Returns true if the item equals to ITEM given as argument.  */\n \n bool\n@@ -1408,17 +1459,6 @@ sem_variable::equals (sem_item *item,\n   if (!ctor || !v->ctor)\n     return return_false_with_msg (\"ctor is missing for semantic variable\");\n \n-  if (DECL_IN_CONSTANT_POOL (decl)\n-      && (DECL_IN_CONSTANT_POOL (item->decl)\n-\t  || item->node->address_matters_p ()))\n-    return return_false_with_msg (\"constant pool\");\n-\n-  if (DECL_IN_TEXT_SECTION (decl) != DECL_IN_TEXT_SECTION (item->decl))\n-    return return_false_with_msg (\"text section\");\n-\n-  if (DECL_TLS_MODEL (decl) || DECL_TLS_MODEL (item->decl))\n-    return return_false_with_msg (\"TLS model\");\n-\n   return sem_variable::equals (ctor, v->ctor);\n }\n \n@@ -1427,28 +1467,57 @@ sem_variable::equals (sem_item *item,\n bool\n sem_variable::equals (tree t1, tree t2)\n {\n+  if (!t1 || !t2)\n+    return return_with_debug (t1 == t2);\n+  if (t1 == t2)\n+    return true;\n   tree_code tc1 = TREE_CODE (t1);\n   tree_code tc2 = TREE_CODE (t2);\n \n   if (tc1 != tc2)\n-    return false;\n+    return return_false_with_msg (\"TREE_CODE mismatch\");\n \n   switch (tc1)\n     {\n     case CONSTRUCTOR:\n       {\n-\tunsigned len1 = vec_safe_length (CONSTRUCTOR_ELTS (t1));\n-\tunsigned len2 = vec_safe_length (CONSTRUCTOR_ELTS (t2));\n+\tvec<constructor_elt, va_gc> *v1, *v2;\n+\tunsigned HOST_WIDE_INT idx;\n \n-\tif (len1 != len2)\n-\t  return false;\n+\tenum tree_code typecode = TREE_CODE (TREE_TYPE (t1));\n+\tif (typecode != TREE_CODE (TREE_TYPE (t2)))\n+\t  return return_false_with_msg (\"constructor type mismatch\");\n+\n+\tif (typecode == ARRAY_TYPE)\n+\t  {\n+\t    HOST_WIDE_INT size_1 = int_size_in_bytes (TREE_TYPE (t1));\n+\t    /* For arrays, check that the sizes all match.  */\n+\t    if (TYPE_MODE (TREE_TYPE (t1)) != TYPE_MODE (TREE_TYPE (t2))\n+\t\t|| size_1 == -1\n+\t\t|| size_1 != int_size_in_bytes (TREE_TYPE (t2)))\n+\t      return return_false_with_msg (\"constructor array size mismatch\");\n+\t  }\n+\telse if (!func_checker::compatible_types_p (TREE_TYPE (t1),\n+\t\t\t\t\t\t    TREE_TYPE (t2)))\n+\t  return return_false_with_msg (\"constructor type incompatible\");\n \n-\tfor (unsigned i = 0; i < len1; i++)\n-\t  if (!sem_variable::equals (CONSTRUCTOR_ELT (t1, i)->value,\n-\t\t\t\t     CONSTRUCTOR_ELT (t2, i)->value)\n-\t      || CONSTRUCTOR_ELT (t1, i)->index != CONSTRUCTOR_ELT (t2, i)->index)\n-\t    return false;\n+\tv1 = CONSTRUCTOR_ELTS (t1);\n+\tv2 = CONSTRUCTOR_ELTS (t2);\n+\tif (vec_safe_length (v1) != vec_safe_length (v2))\n+\t  return return_false_with_msg (\"constructor number of elts mismatch\");\n \n+\tfor (idx = 0; idx < vec_safe_length (v1); ++idx)\n+\t  {\n+\t    constructor_elt *c1 = &(*v1)[idx];\n+\t    constructor_elt *c2 = &(*v2)[idx];\n+\n+\t    /* Check that each value is the same...  */\n+\t    if (!sem_variable::equals (c1->value, c2->value))\n+\t      return false;\n+\t    /* ... and that they apply to the same fields!  */\n+\t    if (!sem_variable::equals (c1->index, c2->index))\n+\t      return false;\n+\t  }\n \treturn true;\n       }\n     case MEM_REF:\n@@ -1463,32 +1532,100 @@ sem_variable::equals (tree t1, tree t2)\n \t  return return_false ();\n \n \t/* Type of the offset on MEM_REF does not matter.  */\n-\treturn sem_variable::equals (x1, x2)\n-\t       && wi::to_offset  (y1) == wi::to_offset  (y2);\n+\treturn return_with_debug (sem_variable::equals (x1, x2)\n+\t\t\t          && wi::to_offset  (y1)\n+\t\t\t\t     == wi::to_offset  (y2));\n       }\n-    case NOP_EXPR:\n     case ADDR_EXPR:\n+    case FDESC_EXPR:\n       {\n \ttree op1 = TREE_OPERAND (t1, 0);\n \ttree op2 = TREE_OPERAND (t2, 0);\n \treturn sem_variable::equals (op1, op2);\n       }\n+    /* References to other vars/decls are compared using ipa-ref.  */\n     case FUNCTION_DECL:\n     case VAR_DECL:\n+      if (decl_in_symtab_p (t1) && decl_in_symtab_p (t2))\n+\treturn true;\n+      return return_false_with_msg (\"Declaration mismatch\");\n+    case CONST_DECL:\n+      /* TODO: We can check CONST_DECL by its DECL_INITIAL, but for that we\n+\t need to process its VAR/FUNCTION references without relying on ipa-ref\n+\t compare.  */\n     case FIELD_DECL:\n     case LABEL_DECL:\n-      return t1 == t2;\n+      return return_false_with_msg (\"Declaration mismatch\");\n     case INTEGER_CST:\n-      return func_checker::compatible_types_p (TREE_TYPE (t1), TREE_TYPE (t2),\n-\t     true)\n-\t     && wi::to_offset (t1) == wi::to_offset (t2);\n+      /* Integer constants are the same only if the same width of type.  */\n+      if (TYPE_PRECISION (TREE_TYPE (t1)) != TYPE_PRECISION (TREE_TYPE (t2)))\n+        return return_false_with_msg (\"INTEGER_CST precision mismatch\");\n+      if (TYPE_MODE (TREE_TYPE (t1)) != TYPE_MODE (TREE_TYPE (t2)))\n+        return return_false_with_msg (\"INTEGER_CST mode mismatch\");\n+      return return_with_debug (tree_int_cst_equal (t1, t2));\n     case STRING_CST:\n-    case REAL_CST:\n+      if (TYPE_MODE (TREE_TYPE (t1)) != TYPE_MODE (TREE_TYPE (t2)))\n+        return return_false_with_msg (\"STRING_CST mode mismatch\");\n+      if (TREE_STRING_LENGTH (t1) != TREE_STRING_LENGTH (t2))\n+\treturn return_false_with_msg (\"STRING_CST length mismatch\");\n+      if (memcmp (TREE_STRING_POINTER (t1), TREE_STRING_POINTER (t2),\n+\t\t    TREE_STRING_LENGTH (t1)))\n+\treturn return_false_with_msg (\"STRING_CST mismatch\");\n+      return true;\n+    case FIXED_CST:\n+      /* Fixed constants are the same only if the same width of type.  */\n+      if (TYPE_PRECISION (TREE_TYPE (t1)) != TYPE_PRECISION (TREE_TYPE (t2)))\n+        return return_false_with_msg (\"FIXED_CST precision mismatch\");\n+\n+      return return_with_debug (FIXED_VALUES_IDENTICAL (TREE_FIXED_CST (t1),\n+\t\t\t\t\t\t\tTREE_FIXED_CST (t2)));\n     case COMPLEX_CST:\n-      return operand_equal_p (t1, t2, OEP_ONLY_CONST);\n-    case COMPONENT_REF:\n+      return (sem_variable::equals (TREE_REALPART (t1), TREE_REALPART (t2))\n+\t      && sem_variable::equals (TREE_IMAGPART (t1), TREE_IMAGPART (t2)));\n+    case REAL_CST:\n+      /* Real constants are the same only if the same width of type.  */\n+      if (TYPE_PRECISION (TREE_TYPE (t1)) != TYPE_PRECISION (TREE_TYPE (t2)))\n+        return return_false_with_msg (\"REAL_CST precision mismatch\");\n+      return return_with_debug (REAL_VALUES_IDENTICAL (TREE_REAL_CST (t1),\n+\t\t\t\t\t\t       TREE_REAL_CST (t2)));\n+    case VECTOR_CST:\n+      {\n+\tunsigned i;\n+\n+        if (VECTOR_CST_NELTS (t1) != VECTOR_CST_NELTS (t2))\n+          return return_false_with_msg (\"VECTOR_CST nelts mismatch\");\n+\n+\tfor (i = 0; i < VECTOR_CST_NELTS (t1); ++i)\n+\t  if (!sem_variable::equals (VECTOR_CST_ELT (t1, i),\n+\t\t\t\t     VECTOR_CST_ELT (t2, i)))\n+\t    return 0;\n+\n+\treturn 1;\n+      }\n     case ARRAY_REF:\n+    case ARRAY_RANGE_REF:\n+      {\n+\ttree x1 = TREE_OPERAND (t1, 0);\n+\ttree x2 = TREE_OPERAND (t2, 0);\n+\ttree y1 = TREE_OPERAND (t1, 1);\n+\ttree y2 = TREE_OPERAND (t2, 1);\n+\n+\tif (!sem_variable::equals (x1, x2) && sem_variable::equals (y1, y2))\n+\t  return false;\n+\tif (!sem_variable::equals (array_ref_low_bound (t1),\n+\t\t\t\t   array_ref_low_bound (t2)))\n+\t  return false;\n+        if (!sem_variable::equals (array_ref_element_size (t1),\n+\t\t\t           array_ref_element_size (t2)))\n+\t  return false;\n+\treturn true;\n+      }\n+     \n+    case COMPONENT_REF:\n     case POINTER_PLUS_EXPR:\n+    case PLUS_EXPR:\n+    case MINUS_EXPR:\n+    case RANGE_EXPR:\n       {\n \ttree x1 = TREE_OPERAND (t1, 0);\n \ttree x2 = TREE_OPERAND (t2, 0);\n@@ -1497,6 +1634,13 @@ sem_variable::equals (tree t1, tree t2)\n \n \treturn sem_variable::equals (x1, x2) && sem_variable::equals (y1, y2);\n       }\n+\n+    CASE_CONVERT:\n+    case VIEW_CONVERT_EXPR:\n+      if (!func_checker::compatible_types_p (TREE_TYPE (t1), TREE_TYPE (t2),\n+\t\t\t\t\t     true))\n+\t  return return_false ();\n+      return sem_variable::equals (TREE_OPERAND (t1, 0), TREE_OPERAND (t2, 0));\n     case ERROR_MARK:\n       return return_false_with_msg (\"ERROR_MARK\");\n     default:"}, {"sha": "b4862b7535708f52ba5a7b313269211b1f76bc24", "filename": "gcc/ipa-icf.h", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4630573709177f43b6b755326c90d6b777fbb2ab/gcc%2Fipa-icf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4630573709177f43b6b755326c90d6b777fbb2ab/gcc%2Fipa-icf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf.h?ref=4630573709177f43b6b755326c90d6b777fbb2ab", "patch": "@@ -241,9 +241,18 @@ class sem_item\n protected:\n   /* Cached, once calculated hash for the item.  */\n   hashval_t hash;\n+\n   /* Accumulate to HSTATE a hash of constructor expression EXP.  */\n   static void add_expr (const_tree exp, inchash::hash &hstate);\n \n+  /* For a given symbol table nodes N1 and N2, we check that FUNCTION_DECLs\n+     point to a same function. Comparison can be skipped if IGNORED_NODES\n+     contains these nodes.  ADDRESS indicate if address is taken.  */\n+  bool compare_cgraph_references (hash_map <symtab_node *, sem_item *>\n+\t\t\t\t  &ignored_nodes,\n+\t\t\t\t  symtab_node *n1, symtab_node *n2,\n+\t\t\t\t  bool address);\n+\n private:\n   /* Initialize internal data structures. Bitmap STACK is used for\n      bitmap memory allocation process.  */\n@@ -353,14 +362,6 @@ class sem_function: public sem_item\n      ICF flags are the same.  */\n   bool compare_edge_flags (cgraph_edge *e1, cgraph_edge *e2);\n \n-  /* For a given symbol table nodes N1 and N2, we check that FUNCTION_DECLs\n-     point to a same function. Comparison can be skipped if IGNORED_NODES\n-     contains these nodes.  ADDRESS indicate if address is taken.  */\n-  bool compare_cgraph_references (hash_map <symtab_node *, sem_item *>\n-\t\t\t\t  &ignored_nodes,\n-\t\t\t\t  symtab_node *n1, symtab_node *n2,\n-\t\t\t\t  bool address);\n-\n   /* Processes function equality comparison.  */\n   bool equals_private (sem_item *item,\n \t\t       hash_map <symtab_node *, sem_item *> &ignored_nodes);\n@@ -402,12 +403,8 @@ class sem_variable: public sem_item\n \t\t       hash_map <symtab_node *, sem_item *> &ignored_nodes);\n \n   /* Fast equality variable based on knowledge known in WPA.  */\n-  inline virtual bool equals_wpa (sem_item *item,\n-\t\t\t\t  hash_map <symtab_node *, sem_item *> & ARG_UNUSED(ignored_nodes))\n-  {\n-    gcc_assert (item->type == VAR);\n-    return true;\n-  }\n+  virtual bool equals_wpa (sem_item *item,\n+\t\t\t   hash_map <symtab_node *, sem_item *> &ignored_nodes);\n \n   /* Returns varpool_node.  */\n   inline varpool_node *get_node (void)"}]}