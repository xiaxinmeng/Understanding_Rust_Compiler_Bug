{"sha": "8d200e06a4556bd60ddc7c5fc1cd80ccdf05ca8a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGQyMDBlMDZhNDU1NmJkNjBkZGM3YzVmYzFjZDgwY2NkZjA1Y2E4YQ==", "commit": {"author": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2008-11-07T15:44:20Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2008-11-07T15:44:20Z"}, "message": "2008-11-07  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\t* Complete last commit.\n\nFrom-SVN: r141676", "tree": {"sha": "bea00592727d331fa3a0427d1eec47d36d7b4d69", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bea00592727d331fa3a0427d1eec47d36d7b4d69"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8d200e06a4556bd60ddc7c5fc1cd80ccdf05ca8a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d200e06a4556bd60ddc7c5fc1cd80ccdf05ca8a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d200e06a4556bd60ddc7c5fc1cd80ccdf05ca8a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d200e06a4556bd60ddc7c5fc1cd80ccdf05ca8a/comments", "author": null, "committer": null, "parents": [{"sha": "9f4a4394397cba5d9431410a94325b35f8432ef2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f4a4394397cba5d9431410a94325b35f8432ef2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9f4a4394397cba5d9431410a94325b35f8432ef2"}], "stats": {"total": 592, "additions": 592, "deletions": 0}, "files": [{"sha": "c31577c28edf47005b7f457e4a31837798a48142", "filename": "libstdc++-v3/include/ext/pointer.h", "status": "added", "additions": 592, "deletions": 0, "changes": 592, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d200e06a4556bd60ddc7c5fc1cd80ccdf05ca8a/libstdc%2B%2B-v3%2Finclude%2Fext%2Fpointer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d200e06a4556bd60ddc7c5fc1cd80ccdf05ca8a/libstdc%2B%2B-v3%2Finclude%2Fext%2Fpointer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fpointer.h?ref=8d200e06a4556bd60ddc7c5fc1cd80ccdf05ca8a", "patch": "@@ -0,0 +1,592 @@\n+// Custom pointer adapter and sample storage policies\n+\n+// Copyright (C) 2008\n+// Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+/**\n+ * @file ext/pointer.h\n+ * @author Bob Walters\n+ *\n+ * Provides reusable _Pointer_adapter for assisting in the development of\n+ * custom pointer types that can be used with libstdc++ STL containers via\n+ * the allocator::pointer and allocator::const_pointer typedefs.\n+ */\n+\n+#ifndef _EXT_POINTER_ADAPTER\n+#define _EXT_POINTER_ADAPTER 1\n+\n+#include <ostream>\n+#include <ext/cast.h>\n+#include <bits/concept_check.h>\n+\n+\n+// forward declaration of the iterator tag\n+namespace std {\n+  struct random_access_iterator_tag;\n+};\n+\n+\n+_GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n+\n+  /** \n+   * @brief A storage policy for use with _Pointer_adapter<> which yields a\n+   *        standard pointer.\n+   * \n+   *  A _Storage_policy is required to provide 4 things:\n+   *    1) A get() API for returning the stored pointer value.\n+   *    2) An set() API for storing a pointer value.\n+   *    3) An element_type typedef to define the type this points to.\n+   *    4) An operator<() to support pointer comparison.\n+   *    5) An operator==() to support pointer comparison.\n+   */\n+  template<typename _Type> \n+    class _Std_pointer_impl \n+    {\n+    public:\n+      // the type this pointer points to.\n+      typedef _Type element_type;\n+  \n+      // A method to fetch the pointer value as a standard T* value;\n+      inline _Type* \n+      get() const \n+      { return _M_value; }\n+  \n+      // A method to set the pointer value, from a standard T* value;\n+      inline void \n+      set(element_type* __arg) \n+      { _M_value = __arg; }\n+  \n+      // Comparison of pointers\n+      inline bool\n+      operator<(const _Std_pointer_impl& __rarg) const\n+      { return (_M_value < __rarg._M_value); }\n+  \n+      inline bool\n+      operator==(const _Std_pointer_impl& __rarg) const\n+      { return (_M_value == __rarg._M_value); }\n+\n+    private:\n+      element_type* _M_value;\n+    };\n+\n+\n+  /**\n+   * @brief A storage policy for use with _Pointer_adapter<> which stores\n+   *        the pointer's address as an offset value which is relative to\n+   *        its own address.\n+   * \n+   * This is intended for pointers\n+   * within shared memory regions which might be mapped at different\n+   * addresses by different processes.  For null pointers, a value of 1 is\n+   * used.  (0 is legitimate sometimes for nodes in circularly linked lists)\n+   * This value was chosen as the least likely to generate an incorrect null,\n+   * As there is no reason why any normal pointer would point 1 byte into\n+   * its own pointer address.\n+   */\n+  template<typename _Type> \n+    class _Relative_pointer_impl \n+    {\n+    public:\n+      typedef _Type element_type;\n+  \n+      _Type* \n+      get() const \n+      {\n+        if (_M_diff == 1)\n+          return NULL;\n+        else\n+          return reinterpret_cast<_Type*>(\n+                 const_cast<char*>(reinterpret_cast<const char*>(this))\n+                 + _M_diff);\n+      }\n+  \n+      void \n+      set(_Type* __arg)\n+      {\n+        if (__arg == NULL)\n+          _M_diff = 1;\n+        else\n+          _M_diff = reinterpret_cast<char*>(__arg) \n+                    - reinterpret_cast<char*>(this);\n+      }\n+  \n+      // Comparison of pointers\n+      inline bool\n+      operator<(const _Relative_pointer_impl& __rarg) const\n+      { return (this->get() < __rarg.get()); }\n+\n+      inline bool\n+      operator==(const _Relative_pointer_impl& __rarg) const\n+      { return (this->get() == __rarg.get()); }\n+\n+    private:\n+      ptrdiff_t _M_diff;\n+    };\n+  \n+  /**\n+   * Relative_pointer_impl needs a specialization for const T because of\n+   * the casting done during pointer arithmetic.\n+   */\n+  template<typename _Type> \n+    class _Relative_pointer_impl<const _Type> \n+    {\n+    public:\n+      typedef const _Type element_type;\n+  \n+      const _Type* \n+      get() const\n+      {\n+        if (_M_diff == 1)\n+          return NULL;\n+        else\n+          return reinterpret_cast<const _Type*>(\n+                  (reinterpret_cast<const char*>(this)) + _M_diff);\n+      }\n+  \n+      void \n+      set(const _Type* __arg) \n+      {\n+        if (__arg == NULL)\n+          _M_diff = 1;\n+        else\n+          _M_diff = reinterpret_cast<const char*>(__arg) \n+                    - reinterpret_cast<const char*>(this);\n+      }\n+  \n+      // Comparison of pointers\n+      inline bool\n+      operator<(const _Relative_pointer_impl& __rarg) const\n+      { return (this->get() < __rarg.get()); }\n+\n+      inline bool\n+      operator==(const _Relative_pointer_impl& __rarg) const\n+      { return (this->get() == __rarg.get()); }\n+  \n+    private:\n+      ptrdiff_t _M_diff;\n+    };\n+\n+\n+  /**\n+   * The specialization on this type helps resolve the problem of\n+   * reference to void, and eliminates the need to specialize _Pointer_adapter\n+   * for cases of void*, const void*, and so on.\n+   */\n+  struct _Invalid_type { };\n+  \n+  template<typename _Tp>\n+    struct _Reference_type \n+    {\n+      typedef _Tp& reference;\n+    };\n+\n+  template<> \n+    struct _Reference_type<void> \n+    {\n+      typedef _Invalid_type& reference;\n+    };\n+\n+  template<> \n+    struct _Reference_type<const void> \n+    {\n+      typedef const _Invalid_type& reference;\n+    };\n+\n+  template<> \n+    struct _Reference_type<volatile void> \n+    {\n+      typedef volatile _Invalid_type&  reference;\n+    };\n+\n+  template<> \n+    struct _Reference_type<volatile const void> \n+    {\n+      typedef const volatile _Invalid_type&  reference;\n+    };\n+\n+\n+  /**\n+   * This structure accomodates the way in which std::iterator_traits<>\n+   * is normally specialized for const T*, so that value_type is still T.\n+   */\n+  template<typename _Tp> \n+    struct _Unqualified_type \n+    {\n+      typedef _Tp type;\n+    };\n+    \n+  template<typename _Tp> \n+    struct _Unqualified_type<const _Tp> \n+    {\n+      typedef _Tp type;\n+    };\n+    \n+  template<typename _Tp> \n+    struct _Unqualified_type<volatile _Tp> \n+    {\n+      typedef volatile _Tp type;\n+    };\n+    \n+  template<typename _Tp> \n+    struct _Unqualified_type<volatile const _Tp> \n+    {\n+      typedef volatile _Tp type;\n+    };\n+    \n+  \n+  \n+  /**\n+   * The following provides an 'alternative pointer' that works with \n+   * libstdc++-v3 containers when specified as the pointer typedef of the \n+   * allocator.\n+   * \n+   * The pointer type used with the containers doesn't have to be this class,\n+   * but it must support the implicit conversions, pointer arithmetic,\n+   * comparison operators, etc. that are supported by this class, and avoid\n+   * raising compile-time ambiguities.  Because creating a working pointer can\n+   * be challenging, this pointer template was designed to wrapper an \n+   * easier storage policy type, so that it becomes reusable for creating\n+   * other pointer types. \n+   *\n+   * A key point of this class is also that it allows container writers to\n+   * 'assume' Alocator::pointer is a typedef for a normal pointer.  This class\n+   * supports most of the conventions of a true pointer, and can, for instance\n+   * handle implicit conversion to const and base class pointer types.  The\n+   * only impositions on container writers to support extended pointers are:\n+   * 1) use the Allocator::pointer typedef appropriately for pointer types.\n+   * 2) if you need pointer casting, use the __pointer_cast<> functions\n+   *    from ext/cast.h.  This allows pointer cast operations to be overloaded\n+   *    is necessary by custom pointers.\n+   *\n+   * Note:  The const qualifier works with this pointer adapter as follows:\n+   *\n+   * _Tp*             == _Pointer_adapter<_Std_pointer_impl<_Tp> >;\n+   * const _Tp*       == _Pointer_adapter<_Std_pointer_impl<const _Tp> >;\n+   * _Tp* const       == const _Pointer_adapter<_Std_pointer_impl<_Tp> >;\n+   * const _Tp* const == const _Pointer_adapter<_Std_pointer_impl<const _Tp> >;\n+   */\n+ \n+  template<typename _Storage_policy >\n+    class _Pointer_adapter : public _Storage_policy \n+    {\n+    public:\n+      typedef typename _Storage_policy::element_type element_type;\n+  \n+      // These are needed for iterator_traits\n+      typedef std::random_access_iterator_tag                iterator_category;\n+      typedef typename _Unqualified_type<element_type>::type value_type;\n+      typedef ptrdiff_t                                      difference_type;\n+      typedef _Pointer_adapter                               pointer;\n+      typedef typename _Reference_type<element_type>::reference  reference;\n+  \n+      // Reminder: 'const' methods mean that the method is valid when the \n+      // pointer is immutable, and has nothing to do with whether the \n+      // 'pointee' is const.\n+\n+      // Default Constructor (Convert from element_type*)\n+      _Pointer_adapter(element_type* __arg = NULL)\n+      { _Storage_policy::set(__arg); }\n+  \n+      // Copy constructor from _Pointer_adapter of same type.\n+      _Pointer_adapter(const _Pointer_adapter& __arg) \n+      { _Storage_policy::set(__arg.get()); }\n+  \n+      // Convert from _Up* if conversion to element_type* is valid.\n+      template<typename _Up>\n+        _Pointer_adapter(_Up*__arg)\n+        {\n+          __glibcxx_function_requires(_ConvertibleConcept<element_type*, _Up*>);\n+          _Storage_policy::set(__arg); \n+        }\n+  \n+      // Conversion from another _Pointer_adapter if _Up if static cast is\n+      // valid.\n+      template<typename _Up>\n+        _Pointer_adapter(const _Pointer_adapter<_Up>& __arg)\n+        { \n+          __glibcxx_function_requires(_ConvertibleConcept<element_type*, \n+            typename _Pointer_adapter<_Up>::element_type*>);\n+          _Storage_policy::set(__arg.get()); \n+        }\n+  \n+      // Destructor\n+      ~_Pointer_adapter() { }\n+  \n+      // Assignment operator\n+      _Pointer_adapter&\n+      operator=(const _Pointer_adapter& __arg) \n+      {\n+        _Storage_policy::set(__arg.get()); \n+        return *this; \n+      }\n+ \n+      template<typename _Up>\n+        _Pointer_adapter&\n+        operator=(const _Pointer_adapter<_Up>& __arg)\n+        {\n+          _Storage_policy::set(__arg.get()); \n+          return *this; \n+        }\n+\n+      template<typename _Up>\n+        _Pointer_adapter&\n+        operator=(_Up* __arg)\n+        {\n+          _Storage_policy::set(__arg); \n+          return *this; \n+        }\n+\n+      // Operator*, returns element_type&\n+      inline reference \n+      operator*() const \n+      { return *(_Storage_policy::get()); }\n+  \n+      // Operator->, returns element_type*\n+      inline element_type* \n+      operator->() const \n+      { return _Storage_policy::get(); }\n+  \n+      // Operator[], returns a element_type& to the item at that loc.\n+      inline reference \n+      operator[](int __index) const\n+      { return _Storage_policy::get()[__index]; }\n+  \n+      // To allow implicit conversion to \"bool\", for \"if (ptr)...\"\n+    private:\n+      typedef element_type*(_Pointer_adapter::*__unspecified_bool_type)() const;\n+\n+    public:\n+      operator __unspecified_bool_type() const\n+      {\n+        return _Storage_policy::get() == 0 ? 0 : \n+                         &_Pointer_adapter::operator->; \n+      }\n+\n+      // ! operator (for: if (!ptr)...)\n+      inline bool \n+      operator!() const \n+      { return (_Storage_policy::get()==NULL); }\n+  \n+      // Pointer differences\n+      inline friend std::ptrdiff_t \n+      operator-(const _Pointer_adapter& __lhs, element_type* __rhs) \n+      { return (__lhs.get() - __rhs); }\n+  \n+      inline friend std::ptrdiff_t \n+      operator-(element_type* __lhs, const _Pointer_adapter& __rhs) \n+      { return (__lhs - __rhs.get()); }\n+  \n+      template<class _Up>\n+        inline friend std::ptrdiff_t \n+        operator-(const _Pointer_adapter& __lhs, _Up* __rhs) \n+        { return (__lhs.get() - __rhs); }\n+    \n+      template<class _Up>\n+        inline friend std::ptrdiff_t \n+        operator-(_Up* __lhs, const _Pointer_adapter& __rhs)\n+        { return (__lhs - __rhs.get()); }\n+\n+      template<typename _Up>\n+        inline std::ptrdiff_t \n+        operator-(const _Pointer_adapter<_Up>& __rhs) const \n+        { return (_Storage_policy::get() - __rhs.get()); }\n+  \n+      // Pointer math\n+      // Note: There is a reason for all this overloading based on different\n+      // integer types.  In some libstdc++-v3 test cases, a templated\n+      // operator+ is declared which can match any types.  This operator\n+      // tends to \"steal\" the recognition of _Pointer_adapter's own operator+ \n+      // unless the integer type matches perfectly.\n+\n+#define _CXX_POINTER_ARITH_OPERATOR_SET(INT_TYPE) \\\n+      inline friend _Pointer_adapter \\\n+      operator+(const _Pointer_adapter& __lhs, INT_TYPE __offset) \\\n+      { return _Pointer_adapter(__lhs.get() + __offset); } \\\n+\\\n+      inline friend _Pointer_adapter \\\n+      operator+(INT_TYPE __offset, const _Pointer_adapter& __rhs) \\\n+      { return _Pointer_adapter(__rhs.get() + __offset); } \\\n+\\\n+      inline friend _Pointer_adapter \\\n+      operator-(const _Pointer_adapter& __lhs, INT_TYPE __offset) \\\n+      { return _Pointer_adapter(__lhs.get() - __offset); } \\\n+\\\n+      inline _Pointer_adapter& \\\n+      operator+=(INT_TYPE __offset) \\\n+      { \\\n+        _Storage_policy::set(_Storage_policy::get() + __offset); \\\n+        return *this; \\\n+      } \\\n+\\\n+      inline _Pointer_adapter& \\\n+      operator-=(INT_TYPE __offset) \\\n+      { \\\n+        _Storage_policy::set(_Storage_policy::get() - __offset); \\\n+        return *this; \\\n+      } \\\n+// END of _CXX_POINTER_ARITH_OPERATOR_SET macro\n+  \n+      // Expand into the various pointer arithmatic operators needed.\n+      _CXX_POINTER_ARITH_OPERATOR_SET(short);\n+      _CXX_POINTER_ARITH_OPERATOR_SET(unsigned short);\n+      _CXX_POINTER_ARITH_OPERATOR_SET(int);\n+      _CXX_POINTER_ARITH_OPERATOR_SET(unsigned int);\n+      _CXX_POINTER_ARITH_OPERATOR_SET(long);\n+      _CXX_POINTER_ARITH_OPERATOR_SET(unsigned long);\n+\n+      // Mathematical Manipulators\n+      inline _Pointer_adapter& \n+      operator++()\n+      {\n+        _Storage_policy::set(_Storage_policy::get() + 1); \n+        return *this;\n+      }\n+  \n+      inline _Pointer_adapter \n+      operator++(int __unused) \n+      {\n+        _Pointer_adapter tmp(*this);\n+        _Storage_policy::set(_Storage_policy::get() + 1);\n+        return tmp;\n+      }\n+  \n+      inline _Pointer_adapter& \n+      operator--() \n+      {\n+        _Storage_policy::set(_Storage_policy::get() - 1); \n+        return *this;\n+      }\n+  \n+      inline _Pointer_adapter\n+      operator--(int __unused) \n+      {\n+        _Pointer_adapter tmp(*this);\n+        _Storage_policy::set(_Storage_policy::get() - 1);\n+        return tmp;\n+      }\n+  \n+    }; // class _Pointer_adapter\n+\n+\n+#define _GCC_CXX_POINTER_COMPARISON_OPERATION_SET(OPERATOR,BLANK) \\\n+  template<typename _Tp1, typename _Tp2> \\\n+    inline bool \\\n+    operator OPERATOR##BLANK (const _Pointer_adapter<_Tp1>& __lhs, _Tp2 __rhs) \\\n+    { return __lhs.get() OPERATOR##BLANK __rhs; } \\\n+\\\n+  template<typename _Tp1, typename _Tp2> \\\n+    inline bool \\\n+    operator OPERATOR##BLANK (_Tp1 __lhs, const _Pointer_adapter<_Tp2>& __rhs) \\\n+    { return __lhs OPERATOR##BLANK __rhs.get(); } \\\n+\\\n+  template<typename _Tp1, typename _Tp2> \\\n+    inline bool \\\n+    operator OPERATOR##BLANK (const _Pointer_adapter<_Tp1>& __lhs, \\\n+                              const _Pointer_adapter<_Tp2>& __rhs) \\\n+    { return __lhs.get() OPERATOR##BLANK __rhs.get(); } \\\n+\\\n+// End GCC_CXX_POINTER_COMPARISON_OPERATION_SET Macro\n+  \n+  // Expand into the various comparison operators needed.\n+  _GCC_CXX_POINTER_COMPARISON_OPERATION_SET(==,);\n+  _GCC_CXX_POINTER_COMPARISON_OPERATION_SET(!=,);\n+  _GCC_CXX_POINTER_COMPARISON_OPERATION_SET(<,);\n+  _GCC_CXX_POINTER_COMPARISON_OPERATION_SET(<=,);\n+  _GCC_CXX_POINTER_COMPARISON_OPERATION_SET(>,);\n+  _GCC_CXX_POINTER_COMPARISON_OPERATION_SET(>=,);\n+\n+\n+  // These are here for expressions like \"ptr == 0\", \"ptr != 0\"\n+  template<typename _Tp>\n+    inline bool\n+    operator==(const _Pointer_adapter<_Tp>& __lhs, int __rhs)\n+    { return __lhs.get() == reinterpret_cast<void*>(__rhs); } \n+\n+  template<typename _Tp>\n+    inline bool\n+    operator==(int __lhs, const _Pointer_adapter<_Tp>& __rhs)\n+    { return __rhs.get() == reinterpret_cast<void*>(__lhs); } \n+\n+  template<typename _Tp>\n+    inline bool\n+    operator!=(const _Pointer_adapter<_Tp>& __lhs, int __rhs)\n+    { return __lhs.get() != reinterpret_cast<void*>(__rhs); } \n+\n+  template<typename _Tp>\n+    inline bool\n+    operator!=(int __lhs, const _Pointer_adapter<_Tp>& __rhs)\n+    { return __rhs.get() != reinterpret_cast<void*>(__lhs); } \n+\n+  /**\n+   * Comparison operators for _Pointer_adapter defer to the base class'es\n+   * comparison operators, when possible.\n+   */\n+  template<typename _Tp>\n+    inline bool\n+    operator==(const _Pointer_adapter<_Tp>& __lhs, \n+               const _Pointer_adapter<_Tp>& __rhs)\n+    { return __lhs._Tp::operator==(__rhs); }\n+  \n+  template<typename _Tp>\n+    inline bool\n+    operator<=(const _Pointer_adapter<_Tp>& __lhs, \n+               const _Pointer_adapter<_Tp>& __rhs)\n+    { return __lhs._Tp::operator<(__rhs) || __lhs._Tp::operator==(__rhs); }\n+  \n+  template<typename _Tp>\n+    inline bool\n+    operator!=(const _Pointer_adapter<_Tp>& __lhs, \n+               const _Pointer_adapter<_Tp>& __rhs)\n+    { return !(__lhs._Tp::operator==(__rhs)); }\n+  \n+  template<typename _Tp>\n+    inline bool\n+    operator>(const _Pointer_adapter<_Tp>& __lhs, \n+              const _Pointer_adapter<_Tp>& __rhs)\n+    { return !(__lhs._Tp::operator<(__rhs) || __lhs._Tp::operator==(__rhs)); }\n+  \n+  template<typename _Tp>\n+    inline bool\n+    operator>=(const _Pointer_adapter<_Tp>& __lhs, \n+               const _Pointer_adapter<_Tp>& __rhs)\n+    { return !(__lhs._Tp::operator<(__rhs)); }\n+  \n+  \n+  template<class _CharT, class _Traits, class _StoreT>\n+    std::basic_ostream<_CharT, _Traits>&\n+    operator<<(std::basic_ostream<_CharT, _Traits> &os, \n+               const _Pointer_adapter<_StoreT>& __p)\n+    {\n+      os << __p.get();\n+      return os;\n+    }\n+\n+ \n+_GLIBCXX_END_NAMESPACE\n+\n+#endif /* _GCC_EXT_POINTER_ADAPTER */"}]}