{"sha": "50c78b9ab33d5f81b5f175621d56ba10f234cd37", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTBjNzhiOWFiMzNkNWY4MWI1ZjE3NTYyMWQ1NmJhMTBmMjM0Y2QzNw==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2016-05-18T14:04:32Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2016-05-18T14:04:32Z"}, "message": "re PR target/70915 (Improve loading 0/-1 in VSX registers on PowerPC)\n\n[gcc]\n2016-05-18  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\tPR target/70915\n\t* config/rs6000/constraints.md (wE constraint): New constraint\n\tfor a vector constant that can be loaded with XXSPLTIB.\n\t(wM constraint): New constraint for a vector constant of a 1's.\n\t(wS constraint): New constraint for a vector constant that can be\n\tloaded with XXSPLTIB and a vector sign extend instruction.\n\t* config/rs6000/predicates.md (xxspltib_constant_split): New\n\tpredicates for wE/wS constraints.\n\t(xxspltib_constant_nosplit): Likewise.\n\t(easy_vector_constant): Add support for constants that can be\n\tloaded via XXSPLTIB.\n\t(all_ones_constant): New predicate for vector constant with all\n\t1's set.\n\t(splat_input_operand): Add support for ISA 3.0 word splat\n\toperations.\n\t* config/rs6000/rs6000.c (xxspltib_constant_p): New function to\n\treturn if a constant can be loaded with the ISA 3.0 XXSPLTIB\n\tinstruction and possibly with a sign extension.\n\t(output_vec_const_move): Add support for XXSPLTIB. If we are\n\tloading up 0/-1 into Altivec registers, prefer using VSPLTISW\n\tinstead of XXLXOR/XXLORC.\n\t(rs6000_expand_vector_init): Add support for ISA 3.0 word splat\n\toperations.\n\t(rs6000_legitimize_reload_address): Likewise.\n\t(rs6000_output_move_128bit): Use output_vec_const_move to emit\n\tconstants.\n\t* config/rs6000/vsx.md (VSX_M): Add TImode (if -mvsx-timode) and\n\tcombine VSX_M and VSX_M2 into one iterator.\n\t(VSX_M2): Likewise.\n\t(VSINT_84): New iterators for loading constants with XXSPLTIB.\n\t(VSINT_842): Likewise.\n\t(UNSPEC_VSX_SIGN_EXTEND): New UNSPEC.\n\t(xxspltib_v16qi): New insns to load up constants with the ISA 3.0\n\tXXSPLTIB instruction.\n\t(xxspltib_<mode>_nosplit): Likewise.\n\t(xxspltib_<mode>_split): New insn to load up constants with\n\tXXSPLTIB and a sign extend instruction.\n\t(vsx_mov<mode>): Replace single move that handled all vector types\n\twith separate 32-bit and 64-bit moves.  Combine the movti_<bit>\n\tmoves (when -mvsx-timode is in effect) into the main vector\n\tmoves.  Eliminate separate moves for <VSr> <VSa>, where the\n\tpreferred register class (<VSr>) is listed first, and the\n\tsecondary register class (<VSa>) is listed second with a '?' to\n\tdiscourage use.  Prefer loading 0/-1 in any VSX register for ISA\n\t3.0, and Altivec registers for ISA 2.06/2.07 (PR target/70915) so\n\tthat if the register was involved in a slow operation, the\n\tclear/set operation does not wait for the slow operation to\n\tfinish.  Adjust the length attributes for 32-bit mode.  Use\n\trs6000_output_move_128bit and drop the use of the string\n\tinstructions for 32-bit movti when -mvsx-timode is in effect.  Use\n\tspacing so that the alternatives and attributes don't generate\n\tlong lines, and put things in columns, so that it is easier to\n\tmatch up the operands and attributes with the insn alternatives.\n\t(vsx_mov<mode>_64bit): Likewise.\n\t(vsx_mov<mode>_32bit): Likewise.\n\t(vsx_movti_64bit): Fold movti into normal vector moves.\n\t(vsx_movti_32bit): Likewise.\n\t(vsx_splat_<mode>, V4SI/V4SF modes): Add support for ISA 3.0 word\n\tspat instructions.\n\t(vsx_splat_v4si_internal): Likewise.\n\t(vsx_splat_v4sf_internal): Likewise.\n\t(vector fusion peepholes): Use VSX_M instead of VSX_M2.\n\t(vsx_sign_extend_qi_<mode>): New ISA 3.0 instructions to sign\n\textend vector elements.\n\t(vsx_sign_extend_hi_<mode>): Likewise.\n\t(vsx_sign_extend_si_v2di): Likewise.\n\t* config/rs6000/rs6000-protos.h (xxspltib_constant_p): Add\n\tdeclaration.\n\t* doc/md.texi (PowerPC constraints): Document the wE, wM, and wS\n\tconstraints.  Add trailing period to wL documentation.\n\n[gcc/testsuite]\n2016-05-18  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\t* gcc.target/powerpc/p9-splat-1.c: New tests for ISA 3.0 word\n\tsplat operations and the XXSPLTIB instruction.\n\t* gcc.target/powerpc/p9-splat-2.c: Likewise.\n\t* gcc.target/powerpc/p9-splat-3.c: Likewise.\n\t* gcc.target/powerpc/pr47755.c: Allow vspltisw in addition to\n\txxlxor to clear a register.\n\nFrom-SVN: r236394", "tree": {"sha": "1422c79324b1451c85b95d071bf6ce225e401840", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1422c79324b1451c85b95d071bf6ce225e401840"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/50c78b9ab33d5f81b5f175621d56ba10f234cd37", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50c78b9ab33d5f81b5f175621d56ba10f234cd37", "html_url": "https://github.com/Rust-GCC/gccrs/commit/50c78b9ab33d5f81b5f175621d56ba10f234cd37", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50c78b9ab33d5f81b5f175621d56ba10f234cd37/comments", "author": null, "committer": null, "parents": [{"sha": "cf8be00de9a9e31a2f05894d429fe38948a0c255", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf8be00de9a9e31a2f05894d429fe38948a0c255", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf8be00de9a9e31a2f05894d429fe38948a0c255"}], "stats": {"total": 812, "additions": 694, "deletions": 118}, "files": [{"sha": "731a7bd3a88575a33e2cceab363043ec11f674ec", "filename": "gcc/ChangeLog", "status": "modified", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50c78b9ab33d5f81b5f175621d56ba10f234cd37/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50c78b9ab33d5f81b5f175621d56ba10f234cd37/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=50c78b9ab33d5f81b5f175621d56ba10f234cd37", "patch": "@@ -1,3 +1,76 @@\n+2016-05-18  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\tPR target/70915\n+\t* config/rs6000/constraints.md (wE constraint): New constraint\n+\tfor a vector constant that can be loaded with XXSPLTIB.\n+\t(wM constraint): New constraint for a vector constant of a 1's.\n+\t(wS constraint): New constraint for a vector constant that can be\n+\tloaded with XXSPLTIB and a vector sign extend instruction.\n+\t* config/rs6000/predicates.md (xxspltib_constant_split): New\n+\tpredicates for wE/wS constraints.\n+\t(xxspltib_constant_nosplit): Likewise.\n+\t(easy_vector_constant): Add support for constants that can be\n+\tloaded via XXSPLTIB.\n+\t(all_ones_constant): New predicate for vector constant with all\n+\t1's set.\n+\t(splat_input_operand): Add support for ISA 3.0 word splat\n+\toperations.\n+\t* config/rs6000/rs6000.c (xxspltib_constant_p): New function to\n+\treturn if a constant can be loaded with the ISA 3.0 XXSPLTIB\n+\tinstruction and possibly with a sign extension.\n+\t(output_vec_const_move): Add support for XXSPLTIB. If we are\n+\tloading up 0/-1 into Altivec registers, prefer using VSPLTISW\n+\tinstead of XXLXOR/XXLORC.\n+\t(rs6000_expand_vector_init): Add support for ISA 3.0 word splat\n+\toperations.\n+\t(rs6000_legitimize_reload_address): Likewise.\n+\t(rs6000_output_move_128bit): Use output_vec_const_move to emit\n+\tconstants.\n+\t* config/rs6000/vsx.md (VSX_M): Add TImode (if -mvsx-timode) and\n+\tcombine VSX_M and VSX_M2 into one iterator.\n+\t(VSX_M2): Likewise.\n+\t(VSINT_84): New iterators for loading constants with XXSPLTIB.\n+\t(VSINT_842): Likewise.\n+\t(UNSPEC_VSX_SIGN_EXTEND): New UNSPEC.\n+\t(xxspltib_v16qi): New insns to load up constants with the ISA 3.0\n+\tXXSPLTIB instruction.\n+\t(xxspltib_<mode>_nosplit): Likewise.\n+\t(xxspltib_<mode>_split): New insn to load up constants with\n+\tXXSPLTIB and a sign extend instruction.\n+\t(vsx_mov<mode>): Replace single move that handled all vector types\n+\twith separate 32-bit and 64-bit moves.  Combine the movti_<bit>\n+\tmoves (when -mvsx-timode is in effect) into the main vector\n+\tmoves.  Eliminate separate moves for <VSr> <VSa>, where the\n+\tpreferred register class (<VSr>) is listed first, and the\n+\tsecondary register class (<VSa>) is listed second with a '?' to\n+\tdiscourage use.  Prefer loading 0/-1 in any VSX register for ISA\n+\t3.0, and Altivec registers for ISA 2.06/2.07 (PR target/70915) so\n+\tthat if the register was involved in a slow operation, the\n+\tclear/set operation does not wait for the slow operation to\n+\tfinish.  Adjust the length attributes for 32-bit mode.  Use\n+\trs6000_output_move_128bit and drop the use of the string\n+\tinstructions for 32-bit movti when -mvsx-timode is in effect.  Use\n+\tspacing so that the alternatives and attributes don't generate\n+\tlong lines, and put things in columns, so that it is easier to\n+\tmatch up the operands and attributes with the insn alternatives.\n+\t(vsx_mov<mode>_64bit): Likewise.\n+\t(vsx_mov<mode>_32bit): Likewise.\n+\t(vsx_movti_64bit): Fold movti into normal vector moves.\n+\t(vsx_movti_32bit): Likewise.\n+\t(vsx_splat_<mode>, V4SI/V4SF modes): Add support for ISA 3.0 word\n+\tspat instructions.\n+\t(vsx_splat_v4si_internal): Likewise.\n+\t(vsx_splat_v4sf_internal): Likewise.\n+\t(vector fusion peepholes): Use VSX_M instead of VSX_M2.\n+\t(vsx_sign_extend_qi_<mode>): New ISA 3.0 instructions to sign\n+\textend vector elements.\n+\t(vsx_sign_extend_hi_<mode>): Likewise.\n+\t(vsx_sign_extend_si_v2di): Likewise.\n+\t* config/rs6000/rs6000-protos.h (xxspltib_constant_p): Add\n+\tdeclaration.\n+\t* doc/md.texi (PowerPC constraints): Document the wE, wM, and wS\n+\tconstraints.  Add trailing period to wL documentation.\n+\n 2016-05-18  Richard Sandiford  <richard.sandiford@arm.com>\n \n \tPR middle-end/71020"}, {"sha": "ef8f617d9a8784122ddcc3e29eb8aaa6d4625be8", "filename": "gcc/config/rs6000/constraints.md", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50c78b9ab33d5f81b5f175621d56ba10f234cd37/gcc%2Fconfig%2Frs6000%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50c78b9ab33d5f81b5f175621d56ba10f234cd37/gcc%2Fconfig%2Frs6000%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fconstraints.md?ref=50c78b9ab33d5f81b5f175621d56ba10f234cd37", "patch": "@@ -140,6 +140,10 @@\n   (and (match_code \"const_int\")\n        (match_test \"TARGET_VSX && (ival == VECTOR_ELEMENT_SCALAR_64BIT)\")))\n \n+(define_constraint \"wE\"\n+  \"Vector constant that can be loaded with the XXSPLTIB instruction.\"\n+  (match_test \"xxspltib_constant_nosplit (op, mode)\"))\n+\n ;; Extended fusion store\n (define_memory_constraint \"wF\"\n   \"Memory operand suitable for power9 fusion load/stores\"\n@@ -156,6 +160,12 @@\n        (and (match_test \"TARGET_DIRECT_MOVE_128\")\n \t    (match_test \"(ival == VECTOR_ELEMENT_MFVSRLD_64BIT)\"))))\n \n+;; Generate the XXORC instruction to set a register to all 1's\n+(define_constraint \"wM\"\n+  \"Match vector constant with all 1's if the XXLORC instruction is available\"\n+  (and (match_test \"TARGET_P8_VECTOR\")\n+       (match_operand 0 \"all_ones_constant\")))\n+\n ;; ISA 3.0 vector d-form addresses\n (define_memory_constraint \"wO\"\n   \"Memory operand suitable for the ISA 3.0 vector d-form instructions.\"\n@@ -166,6 +176,10 @@\n   \"Memory operand suitable for the load/store quad instructions\"\n   (match_operand 0 \"quad_memory_operand\"))\n \n+(define_constraint \"wS\"\n+  \"Vector constant that can be loaded with XXSPLTIB & sign extension.\"\n+  (match_test \"xxspltib_constant_split (op, mode)\"))\n+\n ;; Altivec style load/store that ignores the bottom bits of the address\n (define_memory_constraint \"wZ\"\n   \"Indexed or indirect memory operand, ignoring the bottom 4 bits\""}, {"sha": "5b852a12c212c047164fe9b7175e6345288f8fb4", "filename": "gcc/config/rs6000/predicates.md", "status": "modified", "additions": 49, "deletions": 1, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50c78b9ab33d5f81b5f175621d56ba10f234cd37/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50c78b9ab33d5f81b5f175621d56ba10f234cd37/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpredicates.md?ref=50c78b9ab33d5f81b5f175621d56ba10f234cd37", "patch": "@@ -565,6 +565,38 @@\n     }\n })\n \n+;; Return 1 if the operand is a CONST_VECTOR or VEC_DUPLICATE of a constant\n+;; that can loaded with a XXSPLTIB instruction and then a VUPKHSB, VECSB2W or\n+;; VECSB2D instruction.\n+\n+(define_predicate \"xxspltib_constant_split\"\n+  (match_code \"const_vector,vec_duplicate,const_int\")\n+{\n+  int value = 256;\n+  int num_insns = -1;\n+\n+  if (!xxspltib_constant_p (op, mode, &num_insns, &value))\n+    return false;\n+\n+  return num_insns > 1;\n+})\n+\n+\n+;; Return 1 if the operand is a CONST_VECTOR that can loaded directly with a\n+;; XXSPLTIB instruction.\n+\n+(define_predicate \"xxspltib_constant_nosplit\"\n+  (match_code \"const_vector,vec_duplicate,const_int\")\n+{\n+  int value = 256;\n+  int num_insns = -1;\n+\n+  if (!xxspltib_constant_p (op, mode, &num_insns, &value))\n+    return false;\n+\n+  return num_insns == 1;\n+})\n+\n ;; Return 1 if the operand is a CONST_VECTOR and can be loaded into a\n ;; vector register without using memory.\n (define_predicate \"easy_vector_constant\"\n@@ -583,7 +615,14 @@\n \n   if (VECTOR_MEM_ALTIVEC_OR_VSX_P (mode))\n     {\n-      if (zero_constant (op, mode))\n+      int value = 256;\n+      int num_insns = -1;\n+\n+      if (zero_constant (op, mode) || all_ones_constant (op, mode))\n+\treturn true;\n+\n+      if (TARGET_P9_VECTOR\n+          && xxspltib_constant_p (op, mode, &num_insns, &value))\n \treturn true;\n \n       return easy_altivec_constant (op, mode);\n@@ -662,6 +701,11 @@\n   (and (match_code \"const_int,const_double,const_wide_int,const_vector\")\n        (match_test \"op == CONST0_RTX (mode)\")))\n \n+;; Return 1 if operand is constant -1 (scalars and vectors).\n+(define_predicate \"all_ones_constant\"\n+  (and (match_code \"const_int,const_double,const_wide_int,const_vector\")\n+       (match_test \"op == CONSTM1_RTX (mode) && !FLOAT_MODE_P (mode)\")))\n+\n ;; Return 1 if operand is 0.0.\n (define_predicate \"zero_fp_constant\"\n   (and (match_code \"const_double\")\n@@ -1024,6 +1068,10 @@\n \tmode = V2DFmode;\n       else if (mode == DImode)\n \tmode = V2DImode;\n+      else if (mode == SImode && TARGET_P9_VECTOR)\n+\tmode = V4SImode;\n+      else if (mode == SFmode && TARGET_P9_VECTOR)\n+\tmode = V4SFmode;\n       else\n \tgcc_unreachable ();\n       return memory_address_addr_space_p (mode, XEXP (op, 0),"}, {"sha": "6b4d17801d08d3abbd007b4de9334a4d092ae95e", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50c78b9ab33d5f81b5f175621d56ba10f234cd37/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50c78b9ab33d5f81b5f175621d56ba10f234cd37/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=50c78b9ab33d5f81b5f175621d56ba10f234cd37", "patch": "@@ -31,6 +31,7 @@ extern void init_cumulative_args (CUMULATIVE_ARGS *, tree, rtx, int, int, int,\n #endif /* TREE_CODE */\n \n extern bool easy_altivec_constant (rtx, machine_mode);\n+extern bool xxspltib_constant_p (rtx, machine_mode, int *, int *);\n extern int vspltis_shifted (rtx);\n extern HOST_WIDE_INT const_vector_elt_as_int (rtx, unsigned int);\n extern bool macho_lo_sum_memory_operand (rtx, machine_mode);"}, {"sha": "a1841bce765d708cfc5f0ac3f1f03b54771f6717", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 201, "deletions": 22, "changes": 223, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50c78b9ab33d5f81b5f175621d56ba10f234cd37/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50c78b9ab33d5f81b5f175621d56ba10f234cd37/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=50c78b9ab33d5f81b5f175621d56ba10f234cd37", "patch": "@@ -6241,6 +6241,128 @@ gen_easy_altivec_constant (rtx op)\n   gcc_unreachable ();\n }\n \n+/* Return true if OP is of the given MODE and can be synthesized with ISA 3.0\n+   instructions (xxspltib, vupkhsb/vextsb2w/vextb2d).\n+\n+   Return the number of instructions needed (1 or 2) into the address pointed\n+   via NUM_INSNS_PTR.\n+\n+   If NOSPLIT_P, only return true for constants that only generate the XXSPLTIB\n+   instruction and can go in any VSX register.  If !NOSPLIT_P, only return true\n+   for constants that generate XXSPLTIB and need a sign extend operation, which\n+   restricts us to the Altivec registers.\n+\n+   Allow either (vec_const [...]) or (vec_duplicate <const>).  If OP is a valid\n+   XXSPLTIB constant, return the constant being set via the CONST_PTR\n+   pointer.  */\n+\n+bool\n+xxspltib_constant_p (rtx op,\n+\t\t     machine_mode mode,\n+\t\t     int *num_insns_ptr,\n+\t\t     int *constant_ptr)\n+{\n+  size_t nunits = GET_MODE_NUNITS (mode);\n+  size_t i;\n+  HOST_WIDE_INT value;\n+  rtx element;\n+\n+  /* Set the returned values to out of bound values.  */\n+  *num_insns_ptr = -1;\n+  *constant_ptr = 256;\n+\n+  if (!TARGET_P9_VECTOR)\n+    return false;\n+\n+  if (mode == VOIDmode)\n+    mode = GET_MODE (op);\n+\n+  else if (mode != GET_MODE (op))\n+    return false;\n+\n+  /* Handle (vec_duplicate <constant>).  */\n+  if (GET_CODE (op) == VEC_DUPLICATE)\n+    {\n+      if (mode != V16QImode && mode != V8HImode && mode != V4SImode\n+\t  && mode != V2DImode)\n+\treturn false;\n+\n+      element = XEXP (op, 0);\n+      if (!CONST_INT_P (element))\n+\treturn false;\n+\n+      value = INTVAL (element);\n+      if (!IN_RANGE (value, -128, 127))\n+\treturn false;\n+    }\n+\n+  /* Handle (const_vector [...]).  */\n+  else if (GET_CODE (op) == CONST_VECTOR)\n+    {\n+      if (mode != V16QImode && mode != V8HImode && mode != V4SImode\n+\t  && mode != V2DImode)\n+\treturn false;\n+\n+      element = CONST_VECTOR_ELT (op, 0);\n+      if (!CONST_INT_P (element))\n+\treturn false;\n+\n+      value = INTVAL (element);\n+      if (!IN_RANGE (value, -128, 127))\n+\treturn false;\n+\n+      for (i = 1; i < nunits; i++)\n+\t{\n+\t  element = CONST_VECTOR_ELT (op, i);\n+\t  if (!CONST_INT_P (element))\n+\t    return false;\n+\n+\t  if (value != INTVAL (element))\n+\t    return false;\n+\t}\n+\n+      /* See if we could generate vspltisw/vspltish directly instead of\n+\t xxspltib + sign extend.  Special case 0/-1 to allow getting\n+         any VSX register instead of an Altivec register.  */\n+      if (!IN_RANGE (value, -1, 0) && EASY_VECTOR_15 (value)\n+\t  && (mode == V4SImode || mode == V8HImode))\n+\treturn false;\n+    }\n+\n+  /* Handle integer constants being loaded into the upper part of the VSX\n+     register as a scalar.  If the value isn't 0/-1, only allow it if\n+     the mode can go in Altivec registers.  */\n+  else if (CONST_INT_P (op))\n+    {\n+      if (!SCALAR_INT_MODE_P (mode))\n+\treturn false;\n+\n+      value = INTVAL (op);\n+      if (!IN_RANGE (value, -128, 127))\n+\treturn false;\n+\n+      if (!IN_RANGE (value, -1, 0)\n+\t  && (reg_addr[mode].addr_mask[RELOAD_REG_VMX] & RELOAD_REG_VALID) == 0)\n+\treturn false;\n+    }\n+\n+  else\n+    return false;\n+\n+  /* Return # of instructions and the constant byte for XXSPLTIB.  */\n+  if (mode == V16QImode)\n+    *num_insns_ptr = 1;\n+\n+  else if (IN_RANGE (value, -1, 0))\n+    *num_insns_ptr = 1;\n+\n+  else\n+    *num_insns_ptr = 2;\n+\n+  *constant_ptr = (int) value;\n+  return true;\n+}\n+\n const char *\n output_vec_const_move (rtx *operands)\n {\n@@ -6254,23 +6376,60 @@ output_vec_const_move (rtx *operands)\n \n   if (TARGET_VSX)\n     {\n+      bool dest_vmx_p = ALTIVEC_REGNO_P (REGNO (dest));\n+      int xxspltib_value = 256;\n+      int num_insns = -1;\n+\n       if (zero_constant (vec, mode))\n-\treturn \"xxlxor %x0,%x0,%x0\";\n+\t{\n+\t  if (TARGET_P9_VECTOR)\n+\t    return \"xxspltib %x0,0\";\n+\n+\t  else if (dest_vmx_p)\n+\t    return \"vspltisw %0,0\";\n+\n+\t  else\n+\t    return \"xxlxor %x0,%x0,%x0\";\n+\t}\n+\n+      if (all_ones_constant (vec, mode))\n+\t{\n+\t  if (TARGET_P9_VECTOR)\n+\t    return \"xxspltib %x0,255\";\n \n-      if (TARGET_P8_VECTOR && vec == CONSTM1_RTX (mode))\n-\treturn \"xxlorc %x0,%x0,%x0\";\n+\t  else if (dest_vmx_p)\n+\t    return \"vspltisw %0,-1\";\n \n-      if ((mode == V2DImode || mode == V1TImode)\n-\t  && INTVAL (CONST_VECTOR_ELT (vec, 0)) == -1\n-\t  && INTVAL (CONST_VECTOR_ELT (vec, 1)) == -1)\n-\treturn (TARGET_P8_VECTOR) ? \"xxlorc %x0,%x0,%x0\" : \"vspltisw %0,-1\";\n+\t  else if (TARGET_P8_VECTOR)\n+\t    return \"xxlorc %x0,%x0,%x0\";\n+\n+\t  else\n+\t    gcc_unreachable ();\n+\t}\n+\n+      if (TARGET_P9_VECTOR\n+\t  && xxspltib_constant_p (vec, mode, &num_insns, &xxspltib_value))\n+\t{\n+\t  if (num_insns == 1)\n+\t    {\n+\t      operands[2] = GEN_INT (xxspltib_value & 0xff);\n+\t      return \"xxspltib %x0,%2\";\n+\t    }\n+\n+\t  return \"#\";\n+\t}\n     }\n \n   if (TARGET_ALTIVEC)\n     {\n       rtx splat_vec;\n+\n+      gcc_assert (ALTIVEC_REGNO_P (REGNO (dest)));\n       if (zero_constant (vec, mode))\n-\treturn \"vxor %0,%0,%0\";\n+\treturn \"vspltisw %0,0\";\n+\n+      if (all_ones_constant (vec, mode))\n+\treturn \"vspltisw %0,-1\";\n \n       /* Do we need to construct a value using VSLDOI?  */\n       shift = vspltis_shifted (vec);\n@@ -6543,6 +6702,15 @@ rs6000_expand_vector_init (rtx target, rtx vals)\n       return;\n     }\n \n+  /* Word values on ISA 3.0 can use mtvsrws, lxvwsx, or vspltisw.  V4SF is\n+     complicated since scalars are stored as doubles in the registers.  */\n+  if (TARGET_P9_VECTOR && mode == V4SImode && all_same\n+      && VECTOR_MEM_VSX_P (mode))\n+    {\n+      emit_insn (gen_vsx_splat_v4si (target, XVECEXP (vals, 0, 0)));\n+      return;\n+    }\n+\n   /* With single precision floating point on VSX, know that internally single\n      precision is actually represented as a double, and either make 2 V2DF\n      vectors, and convert these vectors to single precision, or do one\n@@ -6551,14 +6719,23 @@ rs6000_expand_vector_init (rtx target, rtx vals)\n     {\n       if (all_same)\n \t{\n-\t  rtx freg = gen_reg_rtx (V4SFmode);\n-\t  rtx sreg = force_reg (SFmode, XVECEXP (vals, 0, 0));\n-\t  rtx cvt  = ((TARGET_XSCVDPSPN)\n-\t\t      ? gen_vsx_xscvdpspn_scalar (freg, sreg)\n-\t\t      : gen_vsx_xscvdpsp_scalar (freg, sreg));\n+\t  rtx op0 = XVECEXP (vals, 0, 0);\n+\n+\t  if (TARGET_P9_VECTOR)\n+\t    emit_insn (gen_vsx_splat_v4sf (target, op0));\n \n-\t  emit_insn (cvt);\n-\t  emit_insn (gen_vsx_xxspltw_v4sf_direct (target, freg, const0_rtx));\n+\t  else\n+\t    {\n+\t      rtx freg = gen_reg_rtx (V4SFmode);\n+\t      rtx sreg = force_reg (SFmode, op0);\n+\t      rtx cvt  = (TARGET_XSCVDPSPN\n+\t\t\t  ? gen_vsx_xscvdpspn_scalar (freg, sreg)\n+\t\t\t  : gen_vsx_xscvdpsp_scalar (freg, sreg));\n+\n+\t      emit_insn (cvt);\n+\t      emit_insn (gen_vsx_xxspltw_v4sf_direct (target, freg,\n+\t\t\t\t\t\t      const0_rtx));\n+\t    }\n \t}\n       else\n \t{\n@@ -8326,12 +8503,16 @@ rs6000_legitimize_reload_address (rtx x, machine_mode mode,\n {\n   bool reg_offset_p = reg_offset_addressing_ok_p (mode);\n \n-  /* Nasty hack for vsx_splat_V2DF/V2DI load from mem, which takes a\n-     DFmode/DImode MEM.  */\n+  /* Nasty hack for vsx_splat_v2df/v2di load from mem, which takes a\n+     DFmode/DImode MEM.  Ditto for ISA 3.0 vsx_splat_v4sf/v4si.  */\n   if (reg_offset_p\n       && opnum == 1\n       && ((mode == DFmode && recog_data.operand_mode[0] == V2DFmode)\n-\t  || (mode == DImode && recog_data.operand_mode[0] == V2DImode)))\n+\t  || (mode == DImode && recog_data.operand_mode[0] == V2DImode)\n+\t  || (mode == SFmode && recog_data.operand_mode[0] == V4SFmode\n+\t      && TARGET_P9_VECTOR)\n+\t  || (mode == SImode && recog_data.operand_mode[0] == V4SImode\n+\t      && TARGET_P9_VECTOR)))\n     reg_offset_p = false;\n \n   /* We must recognize output that we have already generated ourselves.  */\n@@ -20111,10 +20292,8 @@ rs6000_output_move_128bit (rtx operands[])\n       if (dest_gpr_p)\n \treturn \"#\";\n \n-      else if (TARGET_VSX && dest_vsx_p && zero_constant (src, mode))\n-\treturn \"xxlxor %x0,%x0,%x0\";\n-\n-      else if (TARGET_ALTIVEC && dest_vmx_p)\n+      else if ((dest_vmx_p && TARGET_ALTIVEC)\n+\t       || (dest_vsx_p && TARGET_VSX))\n \treturn output_vec_const_move (operands);\n     }\n "}, {"sha": "2b6963b0ac50f3696cd546b87fd4928715c2bfbd", "filename": "gcc/config/rs6000/vsx.md", "status": "modified", "additions": 210, "deletions": 93, "changes": 303, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50c78b9ab33d5f81b5f175621d56ba10f234cd37/gcc%2Fconfig%2Frs6000%2Fvsx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50c78b9ab33d5f81b5f175621d56ba10f234cd37/gcc%2Fconfig%2Frs6000%2Fvsx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fvsx.md?ref=50c78b9ab33d5f81b5f175621d56ba10f234cd37", "patch": "@@ -55,8 +55,7 @@\n \t\t\t     (KF\t\"FLOAT128_VECTOR_P (KFmode)\")\n \t\t\t     (TF\t\"FLOAT128_VECTOR_P (TFmode)\")])\n \n-;; Iterator for memory move.  Handle TImode specially to allow\n-;; it to use gprs as well as vsx registers.\n+;; Iterator for memory moves.\n (define_mode_iterator VSX_M [V16QI\n \t\t\t     V8HI\n \t\t\t     V4SI\n@@ -65,18 +64,8 @@\n \t\t\t     V2DF\n \t\t\t     V1TI\n \t\t\t     (KF\t\"FLOAT128_VECTOR_P (KFmode)\")\n-\t\t\t     (TF\t\"FLOAT128_VECTOR_P (TFmode)\")])\n-\n-(define_mode_iterator VSX_M2 [V16QI\n-\t\t\t      V8HI\n-\t\t\t      V4SI\n-\t\t\t      V2DI\n-\t\t\t      V4SF\n-\t\t\t      V2DF\n-\t\t\t      V1TI\n-\t\t\t      (KF\t\"FLOAT128_VECTOR_P (KFmode)\")\n-\t\t\t      (TF\t\"FLOAT128_VECTOR_P (TFmode)\")\n-\t\t\t      (TI\t\"TARGET_VSX_TIMODE\")])\n+\t\t\t     (TF\t\"FLOAT128_VECTOR_P (TFmode)\")\n+\t\t\t     (TI\t\"TARGET_VSX_TIMODE\")])\n \n ;; Map into the appropriate load/store name based on the type\n (define_mode_attr VSm  [(V16QI \"vw4\")\n@@ -270,6 +259,10 @@\n (define_mode_attr VS_64reg [(V2DF\t\"ws\")\n \t\t\t    (V2DI\t\"wi\")])\n \n+;; Iterators for loading constants with xxspltib\n+(define_mode_iterator VSINT_84  [V4SI V2DI])\n+(define_mode_iterator VSINT_842 [V8HI V4SI V2DI])\n+\n ;; Constants for creating unspecs\n (define_c_enum \"unspec\"\n   [UNSPEC_VSX_CONCAT\n@@ -299,6 +292,7 @@\n    UNSPEC_VSX_XVCVUXDDP\n    UNSPEC_VSX_XVCVDPSXDS\n    UNSPEC_VSX_XVCVDPUXDS\n+   UNSPEC_VSX_SIGN_EXTEND\n   ])\n \n ;; VSX moves\n@@ -769,92 +763,141 @@\n \t\t\t   (const_int 64)))]\n   \"\")\n \n-(define_insn \"*vsx_mov<mode>\"\n-  [(set (match_operand:VSX_M 0 \"nonimmediate_operand\" \"=ZwO,<VSr>,<VSr>,?ZwO,?<VSa>,?<VSa>,r,we,wQ,?&r,??Y,??r,??r,<VSr>,?<VSa>,*r,v,wZ,v\")\n-\t(match_operand:VSX_M 1 \"input_operand\" \"<VSr>,ZwO,<VSr>,<VSa>,ZwO,<VSa>,we,b,r,wQ,r,Y,r,j,j,j,W,v,wZ\"))]\n-  \"VECTOR_MEM_VSX_P (<MODE>mode)\n-   && (register_operand (operands[0], <MODE>mode) \n-       || register_operand (operands[1], <MODE>mode))\"\n+;; Vector constants that can be generated with XXSPLTIB that was added in ISA\n+;; 3.0.  Both (const_vector [..]) and (vec_duplicate ...) forms are recognized.\n+(define_insn \"xxspltib_v16qi\"\n+  [(set (match_operand:V16QI 0 \"vsx_register_operand\" \"=wa\")\n+\t(vec_duplicate:V16QI (match_operand:SI 1 \"s8bit_cint_operand\" \"n\")))]\n+  \"TARGET_P9_VECTOR\"\n {\n-  return rs6000_output_move_128bit (operands);\n+  operands[2] = GEN_INT (INTVAL (operands[1]) & 0xff);\n+  return \"xxspltib %x0,%2\";\n }\n-  [(set_attr \"type\" \"vecstore,vecload,vecsimple,vecstore,vecload,vecsimple,mffgpr,mftgpr,load,store,store,load, *,vecsimple,vecsimple,*, *,vecstore,vecload\")\n-   (set_attr \"length\" \"4,4,4,4,4,4,8,4,12,12,12,12,16,4,4,*,16,4,4\")])\n-\n-;; Unlike other VSX moves, allow the GPRs even for reloading, since a normal\n-;; use of TImode is for unions.  However for plain data movement, slightly\n-;; favor the vector loads\n-(define_insn \"*vsx_movti_64bit\"\n-  [(set (match_operand:TI 0 \"nonimmediate_operand\" \"=ZwO,wa,wa,wa,r,we,v,v,wZ,wQ,&r,Y,r,r,?r\")\n-\t(match_operand:TI 1 \"input_operand\" \"wa,ZwO,wa,O,we,b,W,wZ,v,r,wQ,r,Y,r,n\"))]\n-  \"TARGET_POWERPC64 && VECTOR_MEM_VSX_P (TImode)\n-   && (register_operand (operands[0], TImode) \n-       || register_operand (operands[1], TImode))\"\n+  [(set_attr \"type\" \"vecperm\")])\n+\n+(define_insn \"xxspltib_<mode>_nosplit\"\n+  [(set (match_operand:VSINT_842 0 \"vsx_register_operand\" \"=wa\")\n+\t(match_operand:VSINT_842 1 \"xxspltib_constant_nosplit\" \"wE\"))]\n+  \"TARGET_P9_VECTOR\"\n {\n-  return rs6000_output_move_128bit (operands);\n+  rtx op1 = operands[1];\n+  int value = 256;\n+  int num_insns = -1;\n+\n+  if (!xxspltib_constant_p (op1, <MODE>mode, &num_insns, &value)\n+      || num_insns != 1)\n+    gcc_unreachable ();\n+\n+  operands[2] = GEN_INT (value & 0xff);\n+  return \"xxspltib %x0,%2\";\n }\n-  [(set_attr \"type\" \"vecstore,vecload,vecsimple,vecsimple,mffgpr,mftgpr,vecsimple,vecstore,vecload,store,load,store,load,*,*\")\n-   (set_attr \"length\" \"4,4,4,4,8,4,16,4,4,8,8,8,8,8,8\")])\n-\n-(define_insn \"*vsx_movti_32bit\"\n-  [(set (match_operand:TI 0 \"nonimmediate_operand\" \"=ZwO,wa,wa,wa,v,v,wZ,Q,Y,????r,????r,????r,r\")\n-\t(match_operand:TI 1 \"input_operand\"        \"wa,ZwO,wa,O,W,wZ,v,r,r,Q,Y,r,n\"))]\n-  \"! TARGET_POWERPC64 && VECTOR_MEM_VSX_P (TImode)\n-   && (register_operand (operands[0], TImode)\n-       || register_operand (operands[1], TImode))\"\n+  [(set_attr \"type\" \"vecperm\")])\n+\n+(define_insn_and_split \"*xxspltib_<mode>_split\"\n+  [(set (match_operand:VSINT_842 0 \"altivec_register_operand\" \"=v\")\n+\t(match_operand:VSINT_842 1 \"xxspltib_constant_split\" \"wS\"))]\n+  \"TARGET_P9_VECTOR\"\n+  \"#\"\n+  \"&& 1\"\n+  [(const_int 0)]\n {\n-  switch (which_alternative)\n-    {\n-    case 0:\n-      return \"stxvd2x %x1,%y0\";\n+  int value = 256;\n+  int num_insns = -1;\n+  rtx op0 = operands[0];\n+  rtx op1 = operands[1];\n+  rtx tmp = ((can_create_pseudo_p ())\n+\t     ? gen_reg_rtx (V16QImode)\n+\t     : gen_lowpart (V16QImode, op0));\n \n-    case 1:\n-      return \"lxvd2x %x0,%y1\";\n+  if (!xxspltib_constant_p (op1, <MODE>mode, &num_insns, &value)\n+      || num_insns != 2)\n+    gcc_unreachable ();\n \n-    case 2:\n-      return \"xxlor %x0,%x1,%x1\";\n+  emit_insn (gen_xxspltib_v16qi (tmp, GEN_INT (value)));\n \n-    case 3:\n-      return \"xxlxor %x0,%x0,%x0\";\n+  if (<MODE>mode == V2DImode)\n+    emit_insn (gen_vsx_sign_extend_qi_v2di (op0, tmp));\n \n-    case 4:\n-      return output_vec_const_move (operands);\n+  else if (<MODE>mode == V4SImode)\n+    emit_insn (gen_vsx_sign_extend_qi_v4si (op0, tmp));\n+\n+  else if (<MODE>mode == V8HImode)\n+    emit_insn (gen_altivec_vupkhsb  (op0, tmp));\n+\n+  else\n+    gcc_unreachable ();\n \n-    case 5:\n-      return \"stvx %1,%y0\";\n+  DONE;\n+}\n+  [(set_attr \"type\" \"vecperm\")\n+   (set_attr \"length\" \"8\")])\n \n-    case 6:\n-      return \"lvx %0,%y1\";\n \n-    case 7:\n-      if (TARGET_STRING)\n-        return \\\"stswi %1,%P0,16\\\";\n+;; Prefer using vector registers over GPRs.  Prefer using ISA 3.0's XXSPLTISB\n+;; or Altivec VSPLITW 0/-1 over XXLXOR/XXLORC to set a register to all 0's or\n+;; all 1's, since the machine does not have to wait for the previous\n+;; instruction using the register being set (such as a store waiting on a slow\n+;; instruction). But generate XXLXOR/XXLORC if it will avoid a register move.\n \n-    case 8:\n-      return \\\"#\\\";\n+;;              VSX store  VSX load   VSX move  VSX->GPR   GPR->VSX    LQ (GPR)\n+;;              STQ (GPR)  GPR load   GPR store GPR move   XXSPLTIB    VSPLTISW\n+;;              VSX 0/-1   GPR 0/-1   VMX const GPR const  LVX (VMX)   STVX (VMX)\n+(define_insn \"*vsx_mov<mode>_64bit\"\n+  [(set (match_operand:VSX_M 0 \"nonimmediate_operand\"\n+               \"=ZwO,      <VSa>,     <VSa>,     r,         we,        ?wQ,\n+                ?&r,       ??r,       ??Y,       ??r,       wo,        v,\n+                ?<VSa>,    *r,        v,         ??r,       wZ,        v\")\n \n-    case 9:\n-      /* If the address is not used in the output, we can use lsi.  Otherwise,\n-\t fall through to generating four loads.  */\n-      if (TARGET_STRING\n-          && ! reg_overlap_mentioned_p (operands[0], operands[1]))\n-\treturn \\\"lswi %0,%P1,16\\\";\n-      /* ... fall through ...  */\n+\t(match_operand:VSX_M 1 \"input_operand\" \n+               \"<VSa>,     ZwO,       <VSa>,     we,        r,         r,\n+                wQ,        Y,         r,         r,         wE,        jwM,\n+                ?jwM,      jwM,       W,         W,         v,         wZ\"))]\n \n-    case 10:\n-    case 11:\n-    case 12:\n-      return \\\"#\\\";\n-    default:\n-      gcc_unreachable ();\n-    }\n+  \"TARGET_POWERPC64 && VECTOR_MEM_VSX_P (<MODE>mode)\n+   && (register_operand (operands[0], <MODE>mode) \n+       || register_operand (operands[1], <MODE>mode))\"\n+{\n+  return rs6000_output_move_128bit (operands);\n+}\n+  [(set_attr \"type\"\n+               \"vecstore,  vecload,   vecsimple, mffgpr,    mftgpr,    load,\n+                store,     load,      store,     *,         vecsimple, vecsimple,\n+                vecsimple, *,         *,         *,         vecstore,  vecload\")\n+\n+   (set_attr \"length\"\n+               \"4,         4,         4,         8,         4,         8,\n+                8,         8,         8,         8,         4,         4,\n+                4,         8,         20,        20,        4,         4\")])\n+\n+;;              VSX store  VSX load   VSX move   GPR load   GPR store  GPR move\n+;;              XXSPLTIB   VSPLTISW   VSX 0/-1   GPR 0/-1   VMX const  GPR const\n+;;              LVX (VMX)  STVX (VMX)\n+(define_insn \"*vsx_mov<mode>_32bit\"\n+  [(set (match_operand:VSX_M 0 \"nonimmediate_operand\"\n+               \"=ZwO,      <VSa>,     <VSa>,     ??r,       ??Y,       ??r,\n+                wo,        v,         ?<VSa>,    *r,        v,         ??r,\n+                wZ,        v\")\n+\n+\t(match_operand:VSX_M 1 \"input_operand\" \n+               \"<VSa>,     ZwO,       <VSa>,     Y,         r,         r,\n+                wE,        jwM,       ?jwM,      jwM,       W,         W,\n+                v,         wZ\"))]\n+\n+  \"!TARGET_POWERPC64 && VECTOR_MEM_VSX_P (<MODE>mode)\n+   && (register_operand (operands[0], <MODE>mode) \n+       || register_operand (operands[1], <MODE>mode))\"\n+{\n+  return rs6000_output_move_128bit (operands);\n }\n-  [(set_attr \"type\" \"vecstore,vecload,vecsimple,vecsimple,vecsimple,vecstore,vecload,store,store,load,load, *, *\")\n-   (set_attr \"update\" \"     *,      *,        *,       *,         *,       *,      *,  yes,  yes, yes, yes, *, *\")\n-   (set_attr \"length\" \"     4,      4,        4,       4,         8,       4,      4,   16,   16,  16,  16,16,16\")\n-   (set (attr \"cell_micro\") (if_then_else (match_test \"TARGET_STRING\")\n-   \t\t\t                  (const_string \"always\")\n-\t\t\t\t\t  (const_string \"conditional\")))])\n+  [(set_attr \"type\"\n+               \"vecstore,  vecload,   vecsimple, load,      store,    *,\n+                vecsimple, vecsimple, vecsimple, *,         *,        *,\n+                vecstore,  vecload\")\n+\n+   (set_attr \"length\"\n+               \"4,         4,         4,         16,        16,        16,\n+                4,         4,         4,         16,        20,        32,\n+                4,         4\")])\n \n ;; Explicit  load/store expanders for the builtin functions\n (define_expand \"vsx_load_<mode>\"\n@@ -2354,7 +2397,52 @@\n    lxvdsx %x0,%y1\"\n   [(set_attr \"type\" \"vecperm,vecperm,vecload,vecperm,vecperm,vecload\")])\n \n-;; V4SF/V4SI splat\n+;; V4SI splat (ISA 3.0)\n+;; When SI's are allowed in VSX registers, add XXSPLTW support\n+(define_expand \"vsx_splat_<mode>\"\n+  [(set (match_operand:VSX_W 0 \"vsx_register_operand\" \"\")\n+\t(vec_duplicate:VSX_W\n+\t (match_operand:<VS_scalar> 1 \"splat_input_operand\" \"\")))]\n+  \"TARGET_P9_VECTOR\"\n+{\n+  if (MEM_P (operands[1]))\n+    operands[1] = rs6000_address_for_fpconvert (operands[1]);\n+  else if (!REG_P (operands[1]))\n+    operands[1] = force_reg (<VS_scalar>mode, operands[1]);\n+})\n+\n+(define_insn \"*vsx_splat_v4si_internal\"\n+  [(set (match_operand:V4SI 0 \"vsx_register_operand\" \"=wa,wa\")\n+\t(vec_duplicate:V4SI\n+\t (match_operand:SI 1 \"reg_or_indexed_operand\" \"r,Z\")))]\n+  \"TARGET_P9_VECTOR\"\n+  \"@\n+   mtvsrws %x0,%1\n+   lxvwsx %x0,%y1\"\n+  [(set_attr \"type\" \"mftgpr,vecload\")])\n+\n+;; V4SF splat (ISA 3.0)\n+(define_insn_and_split \"*vsx_splat_v4sf_internal\"\n+  [(set (match_operand:V4SF 0 \"vsx_register_operand\" \"=wa,wa,wa\")\n+\t(vec_duplicate:V4SF\n+\t (match_operand:SF 1 \"reg_or_indexed_operand\" \"Z,wy,r\")))]\n+  \"TARGET_P9_VECTOR\"\n+  \"@\n+   lxvwsx %x0,%y1\n+   #\n+   mtvsrws %x0,%1\"\n+  \"&& reload_completed && vsx_register_operand (operands[1], SFmode)\"\n+  [(set (match_dup 0)\n+\t(unspec:V4SF [(match_dup 1)] UNSPEC_VSX_CVDPSPN))\n+   (set (match_dup 0)\n+\t(vec_duplicate:V4SF\n+\t (vec_select:SF (match_dup 0)\n+\t\t\t(parallel [(const_int 0)]))))]\n+  \"\"\n+  [(set_attr \"type\" \"vecload,vecperm,mftgpr\")\n+   (set_attr \"length\" \"4,8,4\")])\n+\n+;; V4SF/V4SI splat from a vector element\n (define_insn \"vsx_xxspltw_<mode>\"\n   [(set (match_operand:VSX_W 0 \"vsx_register_operand\" \"=wf,?<VSa>\")\n \t(vec_duplicate:VSX_W\n@@ -2597,21 +2685,50 @@\n (define_peephole\n   [(set (match_operand:P 0 \"base_reg_operand\" \"\")\n \t(match_operand:P 1 \"short_cint_operand\" \"\"))\n-   (set (match_operand:VSX_M2 2 \"vsx_register_operand\" \"\")\n-\t(mem:VSX_M2 (plus:P (match_dup 0)\n-\t\t\t    (match_operand:P 3 \"int_reg_operand\" \"\"))))]\n+   (set (match_operand:VSX_M 2 \"vsx_register_operand\" \"\")\n+\t(mem:VSX_M (plus:P (match_dup 0)\n+\t\t\t   (match_operand:P 3 \"int_reg_operand\" \"\"))))]\n   \"TARGET_VSX && TARGET_P8_FUSION && !TARGET_P9_VECTOR\"\n-  \"li %0,%1\\t\\t\\t# vector load fusion\\;lx<VSX_M2:VSm>x %x2,%0,%3\"  \n+  \"li %0,%1\\t\\t\\t# vector load fusion\\;lx<VSX_M:VSm>x %x2,%0,%3\"  \n   [(set_attr \"length\" \"8\")\n    (set_attr \"type\" \"vecload\")])\n \n (define_peephole\n   [(set (match_operand:P 0 \"base_reg_operand\" \"\")\n \t(match_operand:P 1 \"short_cint_operand\" \"\"))\n-   (set (match_operand:VSX_M2 2 \"vsx_register_operand\" \"\")\n-\t(mem:VSX_M2 (plus:P (match_operand:P 3 \"int_reg_operand\" \"\")\n-\t\t\t    (match_dup 0))))]\n+   (set (match_operand:VSX_M 2 \"vsx_register_operand\" \"\")\n+\t(mem:VSX_M (plus:P (match_operand:P 3 \"int_reg_operand\" \"\")\n+\t\t\t   (match_dup 0))))]\n   \"TARGET_VSX && TARGET_P8_FUSION && !TARGET_P9_VECTOR\"\n-  \"li %0,%1\\t\\t\\t# vector load fusion\\;lx<VSX_M2:VSm>x %x2,%0,%3\"  \n+  \"li %0,%1\\t\\t\\t# vector load fusion\\;lx<VSX_M:VSm>x %x2,%0,%3\"  \n   [(set_attr \"length\" \"8\")\n    (set_attr \"type\" \"vecload\")])\n+\n+\f\n+;; ISA 3.0 vector extend sign support\n+\n+(define_insn \"vsx_sign_extend_qi_<mode>\"\n+  [(set (match_operand:VSINT_84 0 \"vsx_register_operand\" \"=v\")\n+\t(unspec:VSINT_84\n+\t [(match_operand:V16QI 1 \"vsx_register_operand\" \"v\")]\n+\t UNSPEC_VSX_SIGN_EXTEND))]\n+  \"TARGET_P9_VECTOR\"\n+  \"vextsb2<wd> %0,%1\"\n+  [(set_attr \"type\" \"vecsimple\")])\n+\n+(define_insn \"*vsx_sign_extend_hi_<mode>\"\n+  [(set (match_operand:VSINT_84 0 \"vsx_register_operand\" \"=v\")\n+\t(unspec:VSINT_84\n+\t [(match_operand:V8HI 1 \"vsx_register_operand\" \"v\")]\n+\t UNSPEC_VSX_SIGN_EXTEND))]\n+  \"TARGET_P9_VECTOR\"\n+  \"vextsh2<wd> %0,%1\"\n+  [(set_attr \"type\" \"vecsimple\")])\n+\n+(define_insn \"*vsx_sign_extend_si_v2di\"\n+  [(set (match_operand:V2DI 0 \"vsx_register_operand\" \"=v\")\n+\t(unspec:V2DI [(match_operand:V4SI 1 \"vsx_register_operand\" \"v\")]\n+\t\t     UNSPEC_VSX_SIGN_EXTEND))]\n+  \"TARGET_P9_VECTOR\"\n+  \"vextsw2d %0,%1\"\n+  [(set_attr \"type\" \"vecsimple\")])"}, {"sha": "e7b51c1059342752ccb9f92c5d49955a634e67f3", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50c78b9ab33d5f81b5f175621d56ba10f234cd37/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50c78b9ab33d5f81b5f175621d56ba10f234cd37/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=50c78b9ab33d5f81b5f175621d56ba10f234cd37", "patch": "@@ -3214,23 +3214,32 @@ Floating point register if the LFIWZX instruction is enabled or NO_REGS.\n @item wD\n Int constant that is the element number of the 64-bit scalar in a vector.\n \n+@item wE\n+Vector constant that can be loaded with the XXSPLTIB instruction.\n+\n @item wF\n Memory operand suitable for power9 fusion load/stores.\n \n @item wG\n Memory operand suitable for TOC fusion memory references.\n \n @item wL\n-Int constant that is the element number that the MFVSRLD instruction\n+Int constant that is the element number that the MFVSRLD instruction.\n targets.\n \n+@item wM\n+Match vector constant with all 1's if the XXLORC instruction is available.\n+\n @item wO\n A memory operand suitable for the ISA 3.0 vector d-form instructions.\n \n @item wQ\n A memory address that will work with the @code{lq} and @code{stq}\n instructions.\n \n+@item wS\n+Vector constant that can be loaded with XXSPLTIB & sign extension.\n+\n @item h\n @samp{MQ}, @samp{CTR}, or @samp{LINK} register\n "}, {"sha": "d77545d03bde055d8aa5135624662637caeb4f27", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50c78b9ab33d5f81b5f175621d56ba10f234cd37/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50c78b9ab33d5f81b5f175621d56ba10f234cd37/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=50c78b9ab33d5f81b5f175621d56ba10f234cd37", "patch": "@@ -1,3 +1,12 @@\n+2016-05-18  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* gcc.target/powerpc/p9-splat-1.c: New tests for ISA 3.0 word\n+\tsplat operations and the XXSPLTIB instruction.\n+\t* gcc.target/powerpc/p9-splat-2.c: Likewise.\n+\t* gcc.target/powerpc/p9-splat-3.c: Likewise.\n+\t* gcc.target/powerpc/pr47755.c: Allow vspltisw in addition to\n+\txxlxor to clear a register.\n+\n 2016-05-18  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* gcc.dg/torture/pr71020.c: New test."}, {"sha": "13b72872d74fd0b3ffd82875e331ccc391426741", "filename": "gcc/testsuite/gcc.target/powerpc/p9-splat-1.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50c78b9ab33d5f81b5f175621d56ba10f234cd37/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fp9-splat-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50c78b9ab33d5f81b5f175621d56ba10f234cd37/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fp9-splat-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fp9-splat-1.c?ref=50c78b9ab33d5f81b5f175621d56ba10f234cd37", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-do compile { target { powerpc64le-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-options \"-mcpu=power9 -O2\" } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+\n+#include <altivec.h>\n+\n+vector int\n+foo_r (int a)\n+{\n+  return (vector int) { a, a, a, a };\t\t/* mtvsrws */\n+}\n+\n+vector int\n+foo_r2 (int a)\n+{\n+  return vec_splats (a);\t\t\t/* mtvsrws */\n+}\n+\n+vector int\n+foo_p (int *a)\n+{\n+  return (vector int) { *a, *a, *a, *a };\t/* lxvwsx */\n+}\n+\n+/* { dg-final { scan-assembler-times \"mtvsrws\" 2 } } */\n+/* { dg-final { scan-assembler-times \"lxvwsx\"  1 } } */"}, {"sha": "2468e92dddbe1b56af2a77e8ecd3a04ae2fd4617", "filename": "gcc/testsuite/gcc.target/powerpc/p9-splat-2.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50c78b9ab33d5f81b5f175621d56ba10f234cd37/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fp9-splat-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50c78b9ab33d5f81b5f175621d56ba10f234cd37/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fp9-splat-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fp9-splat-2.c?ref=50c78b9ab33d5f81b5f175621d56ba10f234cd37", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do compile { target { powerpc64le-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-options \"-mcpu=power9 -O2\" } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+\n+#include <altivec.h>\n+\n+vector float\n+foo_r (float a)\n+{\n+  return (vector float) { a, a, a, a };\t\t\t/* xscvdpspn/xxspltw */\n+}\n+\n+vector float\n+foo_r2 (float a)\n+{\n+  return vec_splats (a);\t\t\t\t/* xscvdpspn/xxspltw */\n+}\n+\n+vector float\n+foo_g (float *a)\n+{\n+  float f = *a;\n+\n+  __asm__ (\" # %0\" : \"+r\" (f));\n+  return (vector float) { f, f, f, f };\t\t\t/* mtvsrws */\n+}\n+\n+vector float\n+foo_p (float *a)\n+{\n+  return (vector float) { *a, *a, *a, *a };\t\t/* lxvwsx */\n+}\n+\n+/* { dg-final { scan-assembler-times \"xscvdpspn\" 2 } } */\n+/* { dg-final { scan-assembler-times \"xxspltw\"   2 } } */\n+/* { dg-final { scan-assembler-times \"mtvsrws\"   1 } } */\n+/* { dg-final { scan-assembler-times \"lxvwsx\"    1 } } */"}, {"sha": "8a121da25727540722314f84cb24fe6150240e68", "filename": "gcc/testsuite/gcc.target/powerpc/p9-splat-3.c", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50c78b9ab33d5f81b5f175621d56ba10f234cd37/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fp9-splat-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50c78b9ab33d5f81b5f175621d56ba10f234cd37/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fp9-splat-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fp9-splat-3.c?ref=50c78b9ab33d5f81b5f175621d56ba10f234cd37", "patch": "@@ -0,0 +1,61 @@\n+/* { dg-do compile { target { powerpc64le-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-options \"-mcpu=power9 -O2\" } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+\n+#include <altivec.h>\n+\n+typedef vector signed char\tv16qi_t;\n+typedef vector short\t\tv8hi_t;\n+typedef vector int\t\tv4si_t;\n+typedef vector long long\tv2di_t;\n+\n+void v16qi_0a  (v16qi_t *p) { *p = (v16qi_t) { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; }\n+void v8hi_0a   (v8hi_t  *p) { *p = (v8hi_t)  { 0, 0, 0, 0, 0, 0, 0, 0 }; }\n+void v4si_0a   (v4si_t  *p) { *p = (v4si_t)  { 0, 0, 0, 0 }; }\n+void v2di_0a   (v2di_t  *p) { *p = (v2di_t)  { 0, 0 }; }\n+\n+void v16qi_0b  (v16qi_t *p) { *p = (v16qi_t) vec_splats ((signed char)0); }\n+void v8hi_0b   (v8hi_t  *p) { *p = (v8hi_t)  vec_splats ((short)0); }\n+void v4si_0b   (v4si_t  *p) { *p = (v4si_t)  vec_splats ((int)0); }\n+void v2di_0b   (v2di_t  *p) { *p = (v2di_t)  vec_splats ((long long)0); }\n+\n+void v16qi_m1a (v16qi_t *p) { *p = (v16qi_t) { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 }; }\n+void v8hi_m1a  (v8hi_t  *p) { *p = (v8hi_t)  { -1, -1, -1, -1, -1, -1, -1, -1 }; }\n+void v4si_m1a  (v4si_t  *p) { *p = (v4si_t)  { -1, -1, -1, -1 }; }\n+void v2di_m1a  (v2di_t  *p) { *p = (v2di_t)  { -1, -1 }; }\n+\n+void v16qi_m1b (v16qi_t *p) { *p = (v16qi_t) vec_splats ((signed char)-1); }\n+void v8hi_m1b  (v8hi_t  *p) { *p = (v8hi_t)  vec_splats ((short)-1); }\n+void v4si_m1b  (v4si_t  *p) { *p = (v4si_t)  vec_splats ((int)-1); }\n+void v2di_m1b  (v2di_t  *p) { *p = (v2di_t)  vec_splats ((long long)-1); }\n+\n+void v16qi_5a  (v16qi_t *p) { *p = (v16qi_t) { 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5 }; }\n+void v8hi_5a   (v8hi_t  *p) { *p = (v8hi_t)  { 5, 5, 5, 5, 5, 5, 5, 5 }; }\n+void v4si_5a   (v4si_t  *p) { *p = (v4si_t)  { 5, 5, 5, 5 }; }\n+void v2di_5a   (v2di_t  *p) { *p = (v2di_t)  { 5, 5 }; }\n+\n+void v16qi_5b  (v16qi_t *p) { *p = (v16qi_t) vec_splats ((signed char)5); }\n+void v8hi_5b   (v8hi_t  *p) { *p = (v8hi_t)  vec_splats ((short)5); }\n+void v4si_5b   (v4si_t  *p) { *p = (v4si_t)  vec_splats ((int)5); }\n+void v2di_5b   (v2di_t  *p) { *p = (v2di_t)  vec_splats ((long long)5); }\n+\n+void v16qi_33a (v16qi_t *p) { *p = (v16qi_t) { 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33 }; }\n+void v8hi_33a  (v8hi_t  *p) { *p = (v8hi_t)  { 33, 33, 33, 33, 33, 33, 33, 33 }; }\n+void v4si_33a  (v4si_t  *p) { *p = (v4si_t)  { 33, 33, 33, 33 }; }\n+void v2di_33a  (v2di_t  *p) { *p = (v2di_t)  { 33, 33 }; }\n+\n+void v16qi_33b (v16qi_t *p) { *p = (v16qi_t) vec_splats ((signed char)33); }\n+void v8hi_33b  (v8hi_t  *p) { *p = (v8hi_t)  vec_splats ((short)33); }\n+void v4si_33b  (v4si_t  *p) { *p = (v4si_t)  vec_splats ((int)33); }\n+void v2di_33b  (v2di_t  *p) { *p = (v2di_t)  vec_splats ((long long)33); }\n+\n+/* { dg-final { scan-assembler     \"xxspltib\"     } } */\n+/* { dg-final { scan-assembler     \"vextsb2d\"     } } */\n+/* { dg-final { scan-assembler     \"vextsb2w\"     } } */\n+/* { dg-final { scan-assembler     \"vupk\\[hl\\]sb\" } } */\n+/* { dg-final { scan-assembler-not \"lxvd2x\"       } } */\n+/* { dg-final { scan-assembler-not \"lxvw4x\"       } } */\n+/* { dg-final { scan-assembler-not \"lxv \"         } } */\n+/* { dg-final { scan-assembler-not \"lxvx\"         } } */\n+/* { dg-final { scan-assembler-not \"lvx\"          } } */"}, {"sha": "d5feecac6918a10b0677da706f36ecde7470c963", "filename": "gcc/testsuite/gcc.target/powerpc/pr47755.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50c78b9ab33d5f81b5f175621d56ba10f234cd37/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr47755.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50c78b9ab33d5f81b5f175621d56ba10f234cd37/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr47755.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr47755.c?ref=50c78b9ab33d5f81b5f175621d56ba10f234cd37", "patch": "@@ -3,7 +3,7 @@\n /* { dg-require-effective-target powerpc_vsx_ok } */\n /* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power7\" } } */\n /* { dg-options \"-O3 -mcpu=power7\" } */\n-/* { dg-final { scan-assembler \"xxlxor\" } } */\n+/* { dg-final { scan-assembler \"xxlxor\\|vspltis\\[bhw\\]\" } } */\n /* { dg-final { scan-assembler-not \"lxvd2x\" } } */\n /* { dg-final { scan-assembler-not \"lxvw4x\" } } */\n /* { dg-final { scan-assembler-not \"lvx\" } } */"}]}