{"sha": "eaec9b3d7ed15d4d07e0091a361e52c73d2170b3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWFlYzliM2Q3ZWQxNWQ0ZDA3ZTAwOTFhMzYxZTUyYzczZDIxNzBiMw==", "commit": {"author": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2001-11-11T11:25:28Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2001-11-11T11:25:28Z"}, "message": "ChangeLog.2, [...]: Fix spelling errors.\n\n\t* ChangeLog.2, ChangeLog.3, ChangeLog.4, ChangeLog.5, ChangeLog,\n\tcfg.c, cfganal.c, cfgcleanup.c, cfglayout.c, cfgloop.c, cfgrtl.c,\n\tcollect2.c, combine.c, config.in, configure, configure.in,\n\tconflict.c, dwarf2out.c, dwarfout.c, except.c, final.c, flow.c,\n\tgenattrtab.c, ggc-page.c, jump.c, lcm.c, predict.c, reg-stack.c,\n\treload1.c, rtlanal.c, sched-rgn.c, toplev.c, unwind-dw2-fde.h: Fix\n\tspelling errors.\n\nFrom-SVN: r46928", "tree": {"sha": "b852443590ce1b94b516d895ae6e1e58523886b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b852443590ce1b94b516d895ae6e1e58523886b8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eaec9b3d7ed15d4d07e0091a361e52c73d2170b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eaec9b3d7ed15d4d07e0091a361e52c73d2170b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eaec9b3d7ed15d4d07e0091a361e52c73d2170b3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eaec9b3d7ed15d4d07e0091a361e52c73d2170b3/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "592bf28c9096a01cf9576951123cb248d4869803", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/592bf28c9096a01cf9576951123cb248d4869803", "html_url": "https://github.com/Rust-GCC/gccrs/commit/592bf28c9096a01cf9576951123cb248d4869803"}], "stats": {"total": 196, "additions": 103, "deletions": 93}, "files": [{"sha": "eb1a3fbed72c2ca41ee4c270bb01d4c44b529305", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaec9b3d7ed15d4d07e0091a361e52c73d2170b3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaec9b3d7ed15d4d07e0091a361e52c73d2170b3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=eaec9b3d7ed15d4d07e0091a361e52c73d2170b3", "patch": "@@ -1,3 +1,13 @@\n+2001-11-11  Joseph S. Myers  <jsm28@cam.ac.uk>\n+\n+\t* ChangeLog.2, ChangeLog.3, ChangeLog.4, ChangeLog.5, ChangeLog,\n+\tcfg.c, cfganal.c, cfgcleanup.c, cfglayout.c, cfgloop.c, cfgrtl.c,\n+\tcollect2.c, combine.c, config.in, configure, configure.in,\n+\tconflict.c, dwarf2out.c, dwarfout.c, except.c, final.c, flow.c,\n+\tgenattrtab.c, ggc-page.c, jump.c, lcm.c, predict.c, reg-stack.c,\n+\treload1.c, rtlanal.c, sched-rgn.c, toplev.c, unwind-dw2-fde.h: Fix\n+\tspelling errors.\n+\n Sun Nov 11 05:56:01 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \t* config/rs6000/rs6000.c (rs6000_hash_constant, toc_hash_eq):\n@@ -927,8 +937,8 @@ Tue Nov  6 09:21:34 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n Mon Nov  5 16:15:25 CET 2001  Jan Hubicka  <jh@suse.cz>\n \n-\t* Makefile.in (bb-reoder.o): Add depdendency on cfglayout.h;\n-\tremove unneded depdendencies;\n+\t* Makefile.in (bb-reoder.o): Add dependency on cfglayout.h;\n+\tremove unneeded dependencies;\n \t(cfglayout.o): New.\n \t* cfglayout.c, cfglayout.h: New files; break out from ...\n \t* bb-reorder.c: ... here; Remove unneeded includes;\n@@ -1935,7 +1945,7 @@ Fri Oct 26 07:18:08 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n 2001-10-26  Christopher Faylor  <cgf@redhat.com>\n \n-\t* config/i386/cygwin.h: Search target specfic include directory, if\n+\t* config/i386/cygwin.h: Search target specific include directory, if\n \tappropriate.\n \n 2001-10-25  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n@@ -10303,12 +10313,12 @@ Mon Jul 30 22:16:08 CEST 2001  Jan Hubicka  <jh@suse.cz>\n \t* alias.c (loop_p): Remove.\n \t(mark_constant_function): Use mark_dfs_back_edges.\n \n-\t* reg-stack.c (block_info_def): Add predecesors counter and stack_out.\n-\t(reg_to_stack): Call mark_dfs_back_edges; count the predecesors.\n+\t* reg-stack.c (block_info_def): Add predecessors counter and stack_out.\n+\t(reg_to_stack): Call mark_dfs_back_edges; count the predecessors.\n \t(compensate_edge): Break out from ...\n \t(convert_regs_1): ... here; do smart choosing of stack_out to copy.\n \t(convert_regs_2): Set block_done once block is really done;\n-\tDo updating of the predecesors counts.\n+\tDo updating of the predecessors counts.\n \n \t* toplev.c (rest_of_compilation): Recompute block_for_insn\n \tbefore post-reload cfg_cleanup.\n@@ -10986,7 +10996,7 @@ Mon Jul 23 16:03:19 CEST 2001  Jan Hubicka  <jh@suse.cz>\n \t* toplev.c (rest_of_compilation): Conditionally call purge_all_dead_edges\n \tafter combine.\n \t* gcse.c (cprop_cc0_jump, cprop_insn): New argument \"basic_block\".\n-\t(cprop_jump): Likewise; call purge_dead_edges if substitution suceeded.\n+\t(cprop_jump): Likewise; call purge_dead_edges if substitution succeeded.\n \n 2001-07-23  Hans-Peter Nilsson  <hp@bitrange.com>\n \n@@ -11040,7 +11050,7 @@ Sun Jul 22 23:28:56 CEST 2001  Jan Hubicka  <jh@suse.cz>\n \tredirect_edge_and_branch, block_label, forwarder_block_p): Make global.\n \t(redirect_edge_and_branch_force): Fix copying of lifeness information.\n \t(block_label): Handle EXIT_BLOCK_PTR by returning NULL.\n-\t* ifcvt.c (dead_or_predictable): Take BB as an new destionation\n+\t* ifcvt.c (dead_or_predictable): Take BB as an new destination\n \tinstead of label; update CFG after transformation.\n \t(find_if_case_1): Update call, use redirect_edge_and_branch_force\n \tfor finishing the transformation; handle even case where ELSE"}, {"sha": "cba548e70a703d6b8280ad6f3d1eb4db8be98978", "filename": "gcc/ChangeLog.2", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaec9b3d7ed15d4d07e0091a361e52c73d2170b3/gcc%2FChangeLog.2", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaec9b3d7ed15d4d07e0091a361e52c73d2170b3/gcc%2FChangeLog.2", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog.2?ref=eaec9b3d7ed15d4d07e0091a361e52c73d2170b3", "patch": "@@ -9963,7 +9963,7 @@ Thu Aug 26 19:33:23 1999  Jim Wilson  <wilson@cygnus.com>\n \t* dwarf2out.c (DWARF2_ASM_LINE_DEBUG_INFO): Add default definition.\n \t(debug_dwarf): Add DWARF2_ASM_LINE_DEBUG_INFO support.\n \t(dwarf2out_line, dwarf2out_finish): Likewise.\n-\t* tm.texi (DWARF2_ASM_LINE_DEBUG_INFO): Add documetation.\n+\t* tm.texi (DWARF2_ASM_LINE_DEBUG_INFO): Add documentation.\n \n Thu Aug 26 16:10:56 1999  Gavin Romig-Koch  <gavin@cygnus.com>\n \n@@ -12356,7 +12356,7 @@ Mon Jul 26 22:52:47 1999  Richard Henderson  <rth@cygnus.com>\n \t* i960.h (BUILD_VA_LIST_TYPE): New.\n \t(EXPAND_BUILTIN_VA_START): New.\n \t(EXPAND_BUILTIN_VA_ARG): New.\n-\t* i960.md (store_multiple): Use change_address on individul mems.\n+\t* i960.md (store_multiple): Use change_address on individual mems.\n \n Mon Jul 26 22:43:12 1999  Richard Henderson  <rth@cygnus.com>\n "}, {"sha": "662e3e087773f601fe99d2397ebd71f5f764ae26", "filename": "gcc/ChangeLog.3", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaec9b3d7ed15d4d07e0091a361e52c73d2170b3/gcc%2FChangeLog.3", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaec9b3d7ed15d4d07e0091a361e52c73d2170b3/gcc%2FChangeLog.3", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog.3?ref=eaec9b3d7ed15d4d07e0091a361e52c73d2170b3", "patch": "@@ -4133,7 +4133,7 @@ Sun May  7 00:54:57 EDT 2000  John Wehle  (john@feith.com)\n \t(rtx_needs_barrier): Handle COND_EXEC.\n \t* config/ia64/ia64.h (BRANCH_COST): Define.\n \t(PREDICATE_CODES): Update.\n-\t* config/ia64/ia64.md: Docuement used unspec values.\n+\t* config/ia64/ia64.md: Document used unspec values.\n \t(attr predicable): New.\n \t(movxf, movxf_internal): New.\n \t(extendsfdf2): Don't comment out nop.\n@@ -5972,7 +5972,7 @@ Sat Apr 22 22:35:38 MET DST 2000  Jan Hubicka  <jh@suse.cz>\n \t(diagnostic.h): #include.\n \t(struct output_buffer): Move into diagnostic.h.\n \t(get_output_prefix): Rename to output_get_prefix.  Export.\n-\t(init_output_buffer): Export. Break out.  Ajust intialization.\n+\t(init_output_buffer): Export. Break out.  Adjust initialization.\n \t(output_space_left, output_append): Export.\n \t(output_newline): Rename to output_add_newline.  Export.\n \t(output_clear): Nullify additional output_buffer fields.\n@@ -5991,7 +5991,7 @@ Sat Apr 22 22:35:38 MET DST 2000  Jan Hubicka  <jh@suse.cz>\n \t(vline_wrapper_message_with_location): Ditto.\n \t(v_message_with_decl): Ditto.  Adjust call to output_puts\n \tand get_output_prefix.\n-\t(default_print_error_function): Adjust buffer intialization.\n+\t(default_print_error_function): Adjust buffer initialization.\n \n Sat Apr 22 06:45:04 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n@@ -6390,7 +6390,7 @@ Mon Apr 17 23:35:29 MET DST 2000  Jan Hubicka  <jh@suse.cz>\n \n Mon Apr 17 14:59:36 MET DST 2000  Jan Hubicka  <jh@suse.cz>\n \n-\t* cse.c (struct check_depdendence_data): New.\n+\t* cse.c (struct check_dependence_data): New.\n \t(check_dependence): New function.\n \t(invalidate): Use check_depdenence.\n \n@@ -6407,7 +6407,7 @@ Mon Apr 17 14:59:36 MET DST 2000  Jan Hubicka  <jh@suse.cz>\n \tmessage in quotes. Otherwise, IBM's make program treats the '#' as the\n \tstart of a comment and ignores the remainder of the line.\n \n-\t* c-lex.c (yylex): Change for EBCDIC, lower case characters preceed\n+\t* c-lex.c (yylex): Change for EBCDIC, lower case characters precede\n \tupper case.\n \t* cccp.c (initialize_char_syntax): Allow for holes in EBCDIC.\n \t* cexp.y (initialize_random_junk): Likewise.\n@@ -6420,7 +6420,7 @@ Mon Apr 17 14:59:36 MET DST 2000  Jan Hubicka  <jh@suse.cz>\n \t(real_hex_to_f): Use it.\n \t* real.c (CHARMASK): New.\n \t(etoasc, asctoeg): Use it.\n-\t(asctoeg): EBCDIC lower case characters preceed upper case.\n+\t(asctoeg): EBCDIC lower case characters precede upper case.\n \n \t* i370.c (mvs_add_label): Change spacing for coding conventions.\n \t* i370.h (ASM_OUTPUT_CASE_LABEL): Change to the data CSECT for the\n@@ -7756,7 +7756,7 @@ Fri Apr  7 11:50:54 2000  Jim Wilson  <wilson@cygnus.com>\n \t(compute_coalesced_reg_partition): New function.\n \t(coalesce_regs_in_copies): Likewise.\n \t(coalesce_reg_in_phi): Likewise.\n-\t(coalesce_regs_in_sucessor_phi_nodes): Likewise.\n+\t(coalesce_regs_in_successor_phi_nodes): Likewise.\n \t(for_each_successor_phi): Likewise.\n \t(rename_context): New struct.\n \t(rename_block): Use a rename_context with rename_insn_1.  When\n@@ -12922,7 +12922,7 @@ Fri Feb 18 20:08:57 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \t* function.c (assign_parms): Make thisparm_boundary unsigned.\n \t* genrecog.c (write_switch): Cast XWINT result to int.\n \t* lcm.c: Many static fcns and vars now #ifdef OPTIMIZE_MODE_SWITCHING.\n-\t* mips-tfile.c (init_file): Make two versions of FDR intializer:\n+\t* mips-tfile.c (init_file): Make two versions of FDR initializer:\n \tone for MIPS and one for Alpha.\n \t(get_tag, copy_object): Add casts to avoid warnings.\n \t* optabs.c (init_one_libfunc): Cast NAME to (char *)."}, {"sha": "c655716fa5a91028bbb5c5de90d04382582426de", "filename": "gcc/ChangeLog.4", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaec9b3d7ed15d4d07e0091a361e52c73d2170b3/gcc%2FChangeLog.4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaec9b3d7ed15d4d07e0091a361e52c73d2170b3/gcc%2FChangeLog.4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog.4?ref=eaec9b3d7ed15d4d07e0091a361e52c73d2170b3", "patch": "@@ -877,7 +877,7 @@ Fri Dec 15 14:48:37 MET 2000  Jan Hubicka  <jh@suse.cz>\n \t* genrecog.c (add_to_sequence): Remove special case for\n \tconst_int_operand.\n \t(maybe_both_true): Return 1 when falling out of sequence when\n-\ttrying to find common possition in the pattern.\n+\ttrying to find common position in the pattern.\n \n Fri Dec 15 14:44:51 MET 2000  Jan Hubicka  <jh@suse.cz>\n \n@@ -11026,7 +11026,7 @@ Mon Aug 21 07:41:12 2000  Jeffrey A Law  (law@cygnus.com)\n \t(lang_diagnostic_starter, lang_diagnostic_finalizer): New objects.\n \t(error_module_changed, record_last_error_module,\n \terror_function_changed, record_last_error_function): New functions.\n-\t(initialize_diagnostics): Default intialize\n+\t(initialize_diagnostics): Default initialize\n \tlang_diagnostic_starter, lang_diagnostic_finalizer.\n \t(init_output_buffer): Tweak.\n \t(file_name_as_prefix): New function."}, {"sha": "b44afad2ec69b80755c2d437883fd3cd5ba8ba7c", "filename": "gcc/ChangeLog.5", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaec9b3d7ed15d4d07e0091a361e52c73d2170b3/gcc%2FChangeLog.5", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaec9b3d7ed15d4d07e0091a361e52c73d2170b3/gcc%2FChangeLog.5", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog.5?ref=eaec9b3d7ed15d4d07e0091a361e52c73d2170b3", "patch": "@@ -2325,7 +2325,7 @@ Sat Jun  2 12:23:51 CEST 2001  Jan Hubicka  <jh@suse.cz>\n \t(and?i splitters): Use ext_register_operands.\n \t(test?i peep2): Remove ignored constraints.\n \t* i386.c (ext_register_operand): Check that operand is\n-\teighter pseudo or hard or 'Q' register.\n+\teither pseudo or hard or 'Q' register.\n \n Sat Jun  2 06:53:50 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n@@ -3324,7 +3324,7 @@ Sat May 19 09:40:45 2001  Denis Chertykov  <denisc@overta.ru>\n Fri May 18 22:42:04 CEST 2001  Jan Hubicka  <jh@suse.cz>\n \n \t* combine.c (combine_simplify_rtx): Clear op0_mode if simplification\n-\tsuceeded.\n+\tsucceeded.\n \n Fri May 18 07:26:34 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n@@ -10383,7 +10383,7 @@ Wed Feb 14 10:08:26 CET 2001  Jan Hubicka  <jh@suse.cz>\n \t    DJ Delorie  <dj@redhat.com>\n \n \t* jump.c (jump_optimize_1): When we delete a conditional jump\n-\tpreceeding a non-conditional jump to effectively the same place,\n+\tpreceding a non-conditional jump to effectively the same place,\n \tmake sure that the combined jump skips any clobber insns between\n \tthe two labels.\n \n@@ -12771,7 +12771,7 @@ Fri Jan 12 00:04:00 MET 2001  Jan Hubicka  <jh@suse.cz>\n \t* i386.c (ix86_comparison_operator, fcmov_comparison_operator,\n \tput_condition_code): Convert fp comparison codes to integer\n \tbefore handling.\n-\t(ix86_expand_fp_compare): Postnote the fp comparison code converison\n+\t(ix86_expand_fp_compare): Postnote the fp comparison code conversion\n \tto final.\n \n \t* i386.c (unsigned_comparison, no_comparison_operator): Kill."}, {"sha": "57743dfef0ae12c8b46bbd2461032751045d789d", "filename": "gcc/cfg.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaec9b3d7ed15d4d07e0091a361e52c73d2170b3/gcc%2Fcfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaec9b3d7ed15d4d07e0091a361e52c73d2170b3/gcc%2Fcfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfg.c?ref=eaec9b3d7ed15d4d07e0091a361e52c73d2170b3", "patch": "@@ -33,7 +33,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \t make_edge, make_single_succ_edge, cached_make_edge, remove_edge\n \t - Low level edge redirection (without updating instruction chain)\n \t     redirect_edge_succ, redirect_edge_succ_nodup, redirect_edge_pred\n-     - Dumpipng and debugging\n+     - Dumping and debugging\n \t dump_flow_info, debug_flow_info, dump_edge_info\n      - Allocation of AUX fields for basic blocks\n \t alloc_aux_for_blocks, free_aux_for_blocks, alloc_aux_for_block\n@@ -119,7 +119,7 @@ struct basic_block_def entry_exit_blocks[2]\n void debug_flow_info\t\t\tPARAMS ((void));\n static void free_edge\t\t\tPARAMS ((edge));\n \f\n-/* Called once at intialization time.  */\n+/* Called once at initialization time.  */\n \n void\n init_flow ()\n@@ -319,7 +319,7 @@ make_edge (src, dest, flags)\n   return cached_make_edge (NULL, src, dest, flags);\n }\n \n-/* Create an edge connecting SRC to DEST and set probability by knowling\n+/* Create an edge connecting SRC to DEST and set probability by knowing\n    that it is the single edge leaving SRC.  */\n \n edge\n@@ -389,7 +389,7 @@ redirect_edge_succ (e, new_succ)\n   e->dest = new_succ;\n }\n \n-/* Like previous but avoid possible dupplicate edge.  */\n+/* Like previous but avoid possible duplicate edge.  */\n \n edge\n redirect_edge_succ_nodup (e, new_succ)"}, {"sha": "679a6e67fda4099960a936c79ce5bdbad78ca72a", "filename": "gcc/cfganal.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaec9b3d7ed15d4d07e0091a361e52c73d2170b3/gcc%2Fcfganal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaec9b3d7ed15d4d07e0091a361e52c73d2170b3/gcc%2Fcfganal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfganal.c?ref=eaec9b3d7ed15d4d07e0091a361e52c73d2170b3", "patch": "@@ -210,7 +210,7 @@ need_fake_edge_p (insn)\n \n /* Add fake edges to the function exit for any non constant and non noreturn\n    calls, volatile inline assembly in the bitmap of blocks specified by\n-   BLOCKS or to the whole CFG if BLOCKS is zero.  Return the nuber of blocks\n+   BLOCKS or to the whole CFG if BLOCKS is zero.  Return the number of blocks\n    that were split.\n \n    The goal is to expose cases in which entering a basic block does not imply\n@@ -226,7 +226,7 @@ flow_call_edges_add (blocks)\n   basic_block *bbs;\n   bool check_last_block = false;\n \n-  /* Map bb indicies into basic block pointers since split_block\n+  /* Map bb indices into basic block pointers since split_block\n      will renumber the basic blocks.  */\n \n   bbs = xmalloc (n_basic_blocks * sizeof (*bbs));\n@@ -288,7 +288,7 @@ flow_call_edges_add (blocks)\n \t    {\n \t      edge e;\n \n-\t      /* The above condition should be enought to verify that there is\n+\t      /* The above condition should be enough to verify that there is\n \t\t no edge to the exit block in CFG already.  Calling make_edge in\n \t\t such case would make us to mark that edge as fake and remove it\n \t\t later.  */\n@@ -338,7 +338,7 @@ find_unreachable_blocks ()\n     BASIC_BLOCK (i)->flags &= ~BB_REACHABLE;\n \n   /* Add our starting points to the worklist.  Almost always there will\n-     be only one.  It isn't inconcievable that we might one day directly\n+     be only one.  It isn't inconceivable that we might one day directly\n      support Fortran alternate entry points.  */\n \n   for (e = ENTRY_BLOCK_PTR->succ; e; e = e->succ_next)"}, {"sha": "cb781d7fe4252fb3e8c28334771ebef1efd9ca50", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaec9b3d7ed15d4d07e0091a361e52c73d2170b3/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaec9b3d7ed15d4d07e0091a361e52c73d2170b3/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=eaec9b3d7ed15d4d07e0091a361e52c73d2170b3", "patch": "@@ -24,7 +24,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n    - Unreachable blocks removal\n    - Edge forwarding (edge to the forwarder block is forwarded to it's\n-     succesor.  Simplification of the branch instruction is performed by\n+     successor.  Simplification of the branch instruction is performed by\n      underlying infrastructure so branch can be converted to simplejump or\n      eliminated).\n    - Cross jumping (tail merging)\n@@ -176,7 +176,7 @@ try_simplify_condjump (cbranch_block)\n }\n \f\n /* Attempt to forward edges leaving basic block B.\n-   Return true if sucessful.  */\n+   Return true if successful.  */\n \n static bool\n try_forward_edges (mode, b)\n@@ -195,17 +195,17 @@ try_forward_edges (mode, b)\n \n       /* Skip complex edges because we don't know how to update them.\n \n-         Still handle fallthru edges, as we can suceed to forward fallthru\n+         Still handle fallthru edges, as we can succeed to forward fallthru\n          edge to the same place as the branch edge of conditional branch\n-         and turn conditional branch to an unconditonal branch.  */\n+         and turn conditional branch to an unconditional branch.  */\n       if (e->flags & EDGE_COMPLEX)\n \tcontinue;\n \n       target = first = e->dest;\n       counter = 0;\n \n       /* Look for the real destination of the jump.\n-         Avoid inifinite loop in the infinite empty loop by counting\n+         Avoid infinite loop in the infinite empty loop by counting\n          up to n_basic_blocks.  */\n       while (FORWARDER_BLOCK_P (target)\n \t     && target->succ->dest != EXIT_BLOCK_PTR\n@@ -680,7 +680,7 @@ flow_find_cross_jump (mode, bb1, bb2, f1, f2)\n     }\n #endif\n \n-  /* Include preceeding notes and labels in the cross-jump.  One,\n+  /* Include preceding notes and labels in the cross-jump.  One,\n      this may bring us to the head of the blocks as requested above.\n      Two, it keeps line number notes as matched as may be.  */\n   if (ninsns)"}, {"sha": "5c2ee088c8a9ed2ada4b0936c991071d0e59bbfb", "filename": "gcc/cfglayout.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaec9b3d7ed15d4d07e0091a361e52c73d2170b3/gcc%2Fcfglayout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaec9b3d7ed15d4d07e0091a361e52c73d2170b3/gcc%2Fcfglayout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfglayout.c?ref=eaec9b3d7ed15d4d07e0091a361e52c73d2170b3", "patch": "@@ -85,7 +85,7 @@ typedef struct\n /* Holds the interesting trailing notes for the function.  */\n static rtx function_tail_eff_head;\n \n-/* The scope forst of current function.  */\n+/* The scope forest of current function.  */\n static scope_forest_info forest;\n \n static rtx skip_insns_after_block\tPARAMS ((basic_block));"}, {"sha": "cabd2f22299778e5a07965eaa8c45357049ac1f4", "filename": "gcc/cfgloop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaec9b3d7ed15d4d07e0091a361e52c73d2170b3/gcc%2Fcfgloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaec9b3d7ed15d4d07e0091a361e52c73d2170b3/gcc%2Fcfgloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.c?ref=eaec9b3d7ed15d4d07e0091a361e52c73d2170b3", "patch": "@@ -559,7 +559,7 @@ flow_loop_level_compute (loop, depth)\n }\n \n /* Compute the loop nesting depth and enclosed loop level for the loop\n-   hierarchy tree specfied by LOOPS.  Return the maximum enclosed loop\n+   hierarchy tree specified by LOOPS.  Return the maximum enclosed loop\n    level.  */\n \n static int"}, {"sha": "20cb12264a3624b3ea41cf159a49f4136e110894", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaec9b3d7ed15d4d07e0091a361e52c73d2170b3/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaec9b3d7ed15d4d07e0091a361e52c73d2170b3/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=eaec9b3d7ed15d4d07e0091a361e52c73d2170b3", "patch": "@@ -34,7 +34,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \t     redirect_edge_and_branch_force, tidy_fallthru_edge, force_nonfallthru\n      - Edge splitting and commiting to edges\n \t  split_edge, insert_insn_on_edge, commit_edge_insertions\n-     - Dumpipng and debugging\n+     - Dumping and debugging\n \t  print_rtl_with_bb, dump_bb, debug_bb, debug_bb_n\n      - Consistency checking\n \t  verify_flow_info\n@@ -291,7 +291,7 @@ create_basic_block_structure (index, head, end, bb_note)\n }\n \n /* Create new basic block consisting of instructions in between HEAD and\n-   END and place it to the BB chain at possition INDEX.\n+   END and place it to the BB chain at position INDEX.\n    END can be NULL in to create new empty basic block before HEAD.\n    Both END and HEAD can be NULL to create basic block at the end of\n    INSN chain.  */\n@@ -691,7 +691,7 @@ try_redirect_by_replacing_jump (e, target)\n \tfprintf (rtl_dump_file, \"Removing jump %i.\\n\", INSN_UID (insn));\n       fallthru = 1;\n \n-      /* Selectivly unlink whole insn chain.  */\n+      /* Selectively unlink whole insn chain.  */\n       delete_insn_chain (kill_from, PREV_INSN (target->head));\n     }\n   /* If this already is simplejump, redirect it.  */\n@@ -749,9 +749,9 @@ try_redirect_by_replacing_jump (e, target)\n /* Return last loop_beg note appearing after INSN, before start of next\n    basic block.  Return INSN if there are no such notes.\n \n-   When emmiting jump to redirect an fallthru edge, it should always\n+   When emitting jump to redirect an fallthru edge, it should always\n    appear after the LOOP_BEG notes, as loop optimizer expect loop to\n-   eighter start by fallthru edge or jump following the LOOP_BEG note\n+   either start by fallthru edge or jump following the LOOP_BEG note\n    jumping to the loop exit test.  */\n \n static rtx\n@@ -774,11 +774,11 @@ last_loop_beg_note (insn)\n    Don't do that on expense of adding new instructions or reordering\n    basic blocks.\n \n-   Function can be also called with edge destionation equivalent to the\n+   Function can be also called with edge destination equivalent to the\n    TARGET.  Then it should try the simplifications and do nothing if\n    none is possible.\n \n-   Return true if transformation suceeded.  We still return flase in case\n+   Return true if transformation succeeded.  We still return false in case\n    E already destinated TARGET and we didn't managed to simplify instruction\n    stream.  */\n \n@@ -958,7 +958,7 @@ force_nonfallthru (e)\n \n /* Redirect edge even at the expense of creating new jump insn or\n    basic block.  Return new basic block if created, NULL otherwise.\n-   Abort if converison is impossible.  */\n+   Abort if conversion is impossible.  */\n \n basic_block\n redirect_edge_and_branch_force (e, target)\n@@ -1119,7 +1119,7 @@ split_edge (edge_in)\n     abort ();\n \n   /* We are going to place the new block in front of edge destination.\n-     Avoid existence of fallthru predecesors.  */\n+     Avoid existence of fallthru predecessors.  */\n   if ((edge_in->flags & EDGE_FALLTHRU) == 0)\n     {\n       edge e;\n@@ -1810,7 +1810,7 @@ verify_flow_info ()\n   free (edge_checksum);\n }\n \f\n-/* Assume that the preceeding pass has possibly eliminated jump instructions\n+/* Assume that the preceding pass has possibly eliminated jump instructions\n    or converted the unconditional jumps.  Eliminate the edges from CFG.\n    Return true if any edges are eliminated.  */\n \n@@ -1928,7 +1928,7 @@ purge_dead_edges (bb)\n   return purged;\n }\n \n-/* Search all basic blocks for potentionally dead edges and purge them.\n+/* Search all basic blocks for potentially dead edges and purge them.\n \n    Return true iff some edge has been eliminated.\n  */"}, {"sha": "a5d5472fca3d6529728d9fc89f9f1f09efc748a3", "filename": "gcc/collect2.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaec9b3d7ed15d4d07e0091a361e52c73d2170b3/gcc%2Fcollect2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaec9b3d7ed15d4d07e0091a361e52c73d2170b3/gcc%2Fcollect2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcollect2.c?ref=eaec9b3d7ed15d4d07e0091a361e52c73d2170b3", "patch": "@@ -264,7 +264,7 @@ static struct path_prefix cmdline_lib_dirs; /* directories specified with -L */\n static struct path_prefix libpath_lib_dirs; /* directories in LIBPATH */\n static struct path_prefix *libpaths[3] = {&cmdline_lib_dirs,\n \t\t\t\t\t  &libpath_lib_dirs, NULL};\n-static const char *const libexts[3] = {\"a\", \"so\", NULL};  /* possible library extentions */\n+static const char *const libexts[3] = {\"a\", \"so\", NULL};  /* possible library extensions */\n #endif\n \n static void handler\t\tPARAMS ((int));\n@@ -1594,7 +1594,7 @@ collect_execute (prog, argv, redir)\n       dup2 (stdout_save, STDOUT_FILENO);\n       dup2 (stderr_save, STDERR_FILENO);\n \n-      /* Close reponse file.  */\n+      /* Close response file.  */\n       close (redir_handle);\n     }\n "}, {"sha": "ee279196fc3243e96f89bcc8a72a2174d2819ce7", "filename": "gcc/combine.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaec9b3d7ed15d4d07e0091a361e52c73d2170b3/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaec9b3d7ed15d4d07e0091a361e52c73d2170b3/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=eaec9b3d7ed15d4d07e0091a361e52c73d2170b3", "patch": "@@ -622,7 +622,7 @@ combine_instructions (f, nregs)\n \t      rtx link = XEXP (links, 0);\n \n \t      /* If the linked insn has been replaced by a note, then there\n-\t\t is no point in persuing this chain any further.  */\n+\t\t is no point in pursuing this chain any further.  */\n \t      if (GET_CODE (link) == NOTE)\n \t\tbreak;\n \n@@ -953,14 +953,14 @@ can_combine_p (insn, i3, pred, succ, pdest, psrc)\n \t\t We depend here on combinable_i3_pat to reject them.  */\n \t      /* The code below this loop only verifies that the inputs of\n \t\t the SET in INSN do not change.  We call reg_set_between_p\n-\t\t to verify that the REG in the USE does not change betweeen\n+\t\t to verify that the REG in the USE does not change between\n \t\t I3 and INSN.\n \t\t If the USE in INSN was for a pseudo register, the matching\n \t\t insn pattern will likely match any register; combining this\n \t\t with any other USE would only be safe if we knew that the\n \t\t used registers have identical values, or if there was\n \t\t something to tell them apart, e.g. different modes.  For\n-\t\t now, we forgo such compilcated tests and simply disallow\n+\t\t now, we forgo such complicated tests and simply disallow\n \t\t combining of USES of pseudo registers with any other USE.  */\n \t      if (GET_CODE (XEXP (elt, 0)) == REG\n \t\t  && GET_CODE (PATTERN (i3)) == PARALLEL)\n@@ -6143,7 +6143,7 @@ make_extraction (mode, inner, pos, pos_rtx, len,\n       rtx temp = gen_rtx_ZERO_EXTEND (pos_mode, pos_rtx);\n \n       /* If we know that no extraneous bits are set, and that the high\n-\t bit is not set, convert extraction to cheaper one - eighter\n+\t bit is not set, convert extraction to cheaper one - either\n \t SIGN_EXTENSION or ZERO_EXTENSION, that are equivalent in these\n \t cases.  */\n       if (flag_expensive_optimizations\n@@ -6463,7 +6463,7 @@ make_compound_operation (x, in_code)\n \t\t\t\t     NULL_RTX, 0);\n \n \t  /* If we have something other than a SUBREG, we might have\n-\t     done an expansion, so rerun outselves.  */\n+\t     done an expansion, so rerun ourselves.  */\n \t  if (GET_CODE (newer) != SUBREG)\n \t    newer = make_compound_operation (newer, in_code);\n \n@@ -7234,7 +7234,7 @@ if_then_else_cond (x, ptrue, pfalse)\n \t    }\n \t}\n \n-      /* Similarly for MULT, AND and UMIN, execpt that for these the result\n+      /* Similarly for MULT, AND and UMIN, except that for these the result\n \t is always zero.  */\n       if ((STORE_FLAG_VALUE == 1 || STORE_FLAG_VALUE == -1)\n \t  && (code == MULT || code == AND || code == UMIN)\n@@ -8549,7 +8549,7 @@ num_sign_bit_copies (x, mode)\n \treturn num_sign_bit_copies (XEXP (x, 0), mode);\n \n     case UMOD:\n-      /* The result must be <= the scond operand.  */\n+      /* The result must be <= the second operand.  */\n       return num_sign_bit_copies (XEXP (x, 1), mode);\n \n     case DIV:\n@@ -11375,7 +11375,7 @@ get_last_value (x)\n      it's either a hard register, set more than once, or it's a live\n      at the beginning of the function, return 0.\n \n-     Because if it's not live at the beginnning of the function then the reg\n+     Because if it's not live at the beginning of the function then the reg\n      is always set before being used (is never used without being set).\n      And, if it's set only once, and it's always set before use, then all\n      uses must have the same last value, even if it's not from this basic"}, {"sha": "8fa5f3aa1e6448cbcde486d352afb317672d11e9", "filename": "gcc/config.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaec9b3d7ed15d4d07e0091a361e52c73d2170b3/gcc%2Fconfig.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaec9b3d7ed15d4d07e0091a361e52c73d2170b3/gcc%2Fconfig.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.in?ref=eaec9b3d7ed15d4d07e0091a361e52c73d2170b3", "patch": "@@ -563,7 +563,7 @@\n #undef HAVE_AS_GOTOFF_IN_DATA\n \n /* Define if your assembler supports dwarf2 .file/.loc directives,\n-   and preserves file table indicies exactly as given. */\n+   and preserves file table indices exactly as given. */\n #undef HAVE_AS_DWARF2_DEBUG_LINE\n \n /* Define 0/1 to force the choice for exception handling model. */"}, {"sha": "156010c7595572a607af3793202c0f3c581daab9", "filename": "gcc/configure", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaec9b3d7ed15d4d07e0091a361e52c73d2170b3/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaec9b3d7ed15d4d07e0091a361e52c73d2170b3/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=eaec9b3d7ed15d4d07e0091a361e52c73d2170b3", "patch": "@@ -7582,7 +7582,7 @@ elif test x$gcc_cv_as != x -a x\"$insn\" != x ; then\n \tif $gcc_cv_as -o conftest.o conftest.s > /dev/null 2>&1 \\\n \t   && grep debug_line conftest.o > /dev/null 2>&1 ; then\n \t\t# The .debug_line file table must be in the exact order that\n-\t\t# we specified the files, since these indicies are also used\n+\t\t# we specified the files, since these indices are also used\n \t\t# by DW_AT_decl_file.  Approximate this test by testing if\n \t\t# the assembler bitches if the same index is assigned twice.\n \t\techo '\t.file 1 \"foo.s\"' > conftest.s"}, {"sha": "56edfd7fe6ab4046c77652764d353fb88f9866c7", "filename": "gcc/configure.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaec9b3d7ed15d4d07e0091a361e52c73d2170b3/gcc%2Fconfigure.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaec9b3d7ed15d4d07e0091a361e52c73d2170b3/gcc%2Fconfigure.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.in?ref=eaec9b3d7ed15d4d07e0091a361e52c73d2170b3", "patch": "@@ -1693,7 +1693,7 @@ elif test x$gcc_cv_as != x -a x\"$insn\" != x ; then\n \tif $gcc_cv_as -o conftest.o conftest.s > /dev/null 2>&1 \\\n \t   && grep debug_line conftest.o > /dev/null 2>&1 ; then\n \t\t# The .debug_line file table must be in the exact order that\n-\t\t# we specified the files, since these indicies are also used\n+\t\t# we specified the files, since these indices are also used\n \t\t# by DW_AT_decl_file.  Approximate this test by testing if\n \t\t# the assembler bitches if the same index is assigned twice.\n \t\techo '\t.file 1 \"foo.s\"' > conftest.s\n@@ -1710,7 +1710,7 @@ fi\n if test x\"$gcc_cv_as_dwarf2_debug_line\" = xyes; then\n \tAC_DEFINE(HAVE_AS_DWARF2_DEBUG_LINE, 1,\n [Define if your assembler supports dwarf2 .file/.loc directives,\n-   and preserves file table indicies exactly as given.])\n+   and preserves file table indices exactly as given.])\n fi\n AC_MSG_RESULT($gcc_cv_as_dwarf2_debug_line)\n "}, {"sha": "99cd9ca1efad7013b98da2f987e9f1a330a589b9", "filename": "gcc/conflict.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaec9b3d7ed15d4d07e0091a361e52c73d2170b3/gcc%2Fconflict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaec9b3d7ed15d4d07e0091a361e52c73d2170b3/gcc%2Fconflict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconflict.c?ref=eaec9b3d7ed15d4d07e0091a361e52c73d2170b3", "patch": "@@ -482,7 +482,7 @@ conflict_graph_compute (regs, p)\n \t    {\n \t      /* Determine which regs are set in this insn.  Since\n   \t         we're in SSA form, if a reg is set here it isn't set\n-  \t         anywhere elso, so this insn is where the reg is born.  */\n+  \t         anywhere else, so this insn is where the reg is born.  */\n \t      CLEAR_REG_SET (born);\n \t      note_stores (PATTERN (insn), mark_reg, born);\n \t      AND_REG_SET (born, regs);"}, {"sha": "12fcadeeb32740d06b46a4329c47aeeca588e180", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaec9b3d7ed15d4d07e0091a361e52c73d2170b3/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaec9b3d7ed15d4d07e0091a361e52c73d2170b3/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=eaec9b3d7ed15d4d07e0091a361e52c73d2170b3", "patch": "@@ -10569,7 +10569,7 @@ gen_member_die (type, context_die)\n      members of this record or union type, we will also be trying to output\n      DIEs to represent the *types* of those members. However the `type'\n      function (above) will specifically avoid generating type DIEs for member\n-     types *within* the list of member DIEs for this (containing) type execpt\n+     types *within* the list of member DIEs for this (containing) type except\n      for those types (of members) which are explicitly marked as also being\n      members of this (containing) type themselves.  The g++ front- end can\n      force any given type to be treated as a member of some other"}, {"sha": "cc6886d4c97f0fe129f9016594196c28210ecf17", "filename": "gcc/dwarfout.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaec9b3d7ed15d4d07e0091a361e52c73d2170b3/gcc%2Fdwarfout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaec9b3d7ed15d4d07e0091a361e52c73d2170b3/gcc%2Fdwarfout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarfout.c?ref=eaec9b3d7ed15d4d07e0091a361e52c73d2170b3", "patch": "@@ -1818,7 +1818,7 @@ output_signed_leb128 (value)\n \n \tstruct s { my_type f; };\n \n-   Since we may be stuck here without enought information to do exactly\n+   Since we may be stuck here without enough information to do exactly\n    what is called for in the Dwarf draft specification, we do the best\n    that we can under the circumstances and always use the \"plain\" integral\n    fundamental type codes for int, short, and long types.  That's probably\n@@ -4979,7 +4979,7 @@ output_type (type, containing_scope)\n \t   to output DIEs to represent the *types* of those members.\n \t   However the `output_type' function (above) will specifically\n \t   avoid generating type DIEs for member types *within* the list\n-\t   of member DIEs for this (containing) type execpt for those\n+\t   of member DIEs for this (containing) type except for those\n \t   types (of members) which are explicitly marked as also being\n \t   members of this (containing) type themselves.  The g++ front-\n \t   end can force any given type to be treated as a member of some"}, {"sha": "1bbc9998a33e02f916ab511ebeb9a4317c016e8b", "filename": "gcc/except.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaec9b3d7ed15d4d07e0091a361e52c73d2170b3/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaec9b3d7ed15d4d07e0091a361e52c73d2170b3/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=eaec9b3d7ed15d4d07e0091a361e52c73d2170b3", "patch": "@@ -137,7 +137,7 @@ struct eh_region\n     ERT_FIXUP\n   } type;\n \n-  /* Holds the action to perform based on the preceeding type.  */\n+  /* Holds the action to perform based on the preceding type.  */\n   union {\n     /* A list of catch blocks, a surrounding try block,\n        and the label for continuing after a catch.  */\n@@ -2014,7 +2014,7 @@ sjlj_assign_call_site_values (dispatch_label, lp_info)\n \n      A region receives a dispatch index if it is directly reachable\n      and requires in-function processing.  Regions that share post-landing\n-     pads may share dispatch indicies.  */\n+     pads may share dispatch indices.  */\n   /* ??? Post-landing pad sharing doesn't actually happen at the moment\n      (see build_post_landing_pads) so we don't bother checking for it.  */\n \n@@ -3041,7 +3041,7 @@ expand_eh_return ()\n }\n \f\n /* In the following functions, we represent entries in the action table\n-   as 1-based indicies.  Special cases are:\n+   as 1-based indices.  Special cases are:\n \n \t 0:\tnull action record, non-null landing pad; implies cleanups\n \t-1:\tnull action record, null landing pad; implies no action\n@@ -3098,7 +3098,7 @@ add_action_record (ar_hash, filter, next)\n       /* The filter value goes in untouched.  The link to the next\n \t record is a \"self-relative\" byte offset, or zero to indicate\n \t that there is no next record.  So convert the absolute 1 based\n-\t indicies we've been carrying around into a displacement.  */\n+\t indices we've been carrying around into a displacement.  */\n \n       push_sleb128 (&cfun->eh->action_record_data, filter);\n       if (next)"}, {"sha": "eac597ed1cf7419771908dd087442ebf506b15b4", "filename": "gcc/final.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaec9b3d7ed15d4d07e0091a361e52c73d2170b3/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaec9b3d7ed15d4d07e0091a361e52c73d2170b3/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=eaec9b3d7ed15d4d07e0091a361e52c73d2170b3", "patch": "@@ -998,7 +998,7 @@ compute_alignments ()\n \n \t We to catch first case, we align frequently executed blocks.\n \t To catch the second, we align blocks that are executed more frequently\n-\t than the predecesor and the predecesor is likely to not be executed\n+\t than the predecessor and the predecessor is likely to not be executed\n \t when function is called.  */\n \n       if (!has_fallthru"}, {"sha": "fd5bf328a94f70fd811a7eea6537444a4f0cc6b2", "filename": "gcc/flow.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaec9b3d7ed15d4d07e0091a361e52c73d2170b3/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaec9b3d7ed15d4d07e0091a361e52c73d2170b3/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=eaec9b3d7ed15d4d07e0091a361e52c73d2170b3", "patch": "@@ -810,7 +810,7 @@ delete_noop_moves (f)\n }\n \n /* Delete any jump tables never referenced.  We can't delete them at the\n-   time of removing tablejump insn as they are referenced by the preceeding\n+   time of removing tablejump insn as they are referenced by the preceding\n    insns computing the destination, so we delay deleting and garbagecollect\n    them once life information is computed.  */\n static void"}, {"sha": "e3748a2ba035c4145ec82f10665aaf097125ad6f", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaec9b3d7ed15d4d07e0091a361e52c73d2170b3/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaec9b3d7ed15d4d07e0091a361e52c73d2170b3/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=eaec9b3d7ed15d4d07e0091a361e52c73d2170b3", "patch": "@@ -3155,7 +3155,7 @@ simplify_or_tree (exp, pterm, insn_code, insn_index)\n   return exp;\n }\n /* Compute approximate cost of the expression.  Used to decide whether\n-   expression is cheap enought for inline.  */\n+   expression is cheap enough for inline.  */\n static int\n attr_rtx_cost (x)\n      rtx x;"}, {"sha": "36b4a319b211a7d524776f4a7ff4892476c626ca", "filename": "gcc/ggc-page.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaec9b3d7ed15d4d07e0091a361e52c73d2170b3/gcc%2Fggc-page.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaec9b3d7ed15d4d07e0091a361e52c73d2170b3/gcc%2Fggc-page.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-page.c?ref=eaec9b3d7ed15d4d07e0091a361e52c73d2170b3", "patch": "@@ -405,7 +405,7 @@ ggc_allocated_p (p)\n   base = &table->table[0];\n #endif\n \n-  /* Extract the level 1 and 2 indicies.  */\n+  /* Extract the level 1 and 2 indices.  */\n   L1 = LOOKUP_L1 (p);\n   L2 = LOOKUP_L2 (p);\n \n@@ -432,7 +432,7 @@ lookup_page_table_entry(p)\n   base = &table->table[0];\n #endif\n \n-  /* Extract the level 1 and 2 indicies.  */\n+  /* Extract the level 1 and 2 indices.  */\n   L1 = LOOKUP_L1 (p);\n   L2 = LOOKUP_L2 (p);\n \n@@ -467,7 +467,7 @@ set_page_table_entry(p, entry)\n   base = &table->table[0];\n #endif\n \n-  /* Extract the level 1 and 2 indicies.  */\n+  /* Extract the level 1 and 2 indices.  */\n   L1 = LOOKUP_L1 (p);\n   L2 = LOOKUP_L2 (p);\n "}, {"sha": "a7f18c058d4324873872375284c66f10441964f2", "filename": "gcc/jump.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaec9b3d7ed15d4d07e0091a361e52c73d2170b3/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaec9b3d7ed15d4d07e0091a361e52c73d2170b3/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=eaec9b3d7ed15d4d07e0091a361e52c73d2170b3", "patch": "@@ -1772,7 +1772,7 @@ delete_related_insns (insn)\n \t\t   || GET_CODE (PATTERN (lab_next)) == ADDR_DIFF_VEC))\n \t{\n \t  /* If we're deleting the tablejump, delete the dispatch table.\n-\t     We may not be able to kill the label immediately preceeding\n+\t     We may not be able to kill the label immediately preceding\n \t     just yet, as it might be referenced in code leading up to\n \t     the tablejump.  */\n \t  delete_related_insns (lab_next);"}, {"sha": "a1e6845757c0d035f2fc42056cb24db21aa2872d", "filename": "gcc/lcm.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaec9b3d7ed15d4d07e0091a361e52c73d2170b3/gcc%2Flcm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaec9b3d7ed15d4d07e0091a361e52c73d2170b3/gcc%2Flcm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flcm.c?ref=eaec9b3d7ed15d4d07e0091a361e52c73d2170b3", "patch": "@@ -1400,7 +1400,7 @@ optimize_mode_switching (file)\n \n   /* Ideally we'd figure out what blocks were affected and start from\n      there, but this is enormously complicated by commit_edge_insertions,\n-     which would screw up any indicies we'd collected, and also need to\n+     which would screw up any indices we'd collected, and also need to\n      be involved in the update.  Bail and recompute global life info for\n      everything.  */\n "}, {"sha": "3bfa204f4e514ec08f43c3c1359597c1f2b03829", "filename": "gcc/predict.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaec9b3d7ed15d4d07e0091a361e52c73d2170b3/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaec9b3d7ed15d4d07e0091a361e52c73d2170b3/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=eaec9b3d7ed15d4d07e0091a361e52c73d2170b3", "patch": "@@ -368,7 +368,7 @@ estimate_probability (loops_info)\n       rtx cond, earliest;\n       edge e;\n \n-      /* If block has no sucessor, predict all possible paths to\n+      /* If block has no successor, predict all possible paths to\n          it as improbable, as the block contains a call to a noreturn\n \t function and thus can be executed only once.  */\n       if (bb->succ == NULL && !found_noreturn)\n@@ -609,7 +609,7 @@ typedef struct block_info_def\n   /* True if block needs to be visited in prop_freqency.  */\n   int tovisit:1;\n \n-  /* Number of predecesors we need to visit first.  */\n+  /* Number of predecessors we need to visit first.  */\n   int npredecesors;\n } *block_info;\n \n@@ -639,7 +639,7 @@ propagate_freq (head)\n   basic_block nextbb;\n   int n;\n \n-  /* For each basic block we need to visit count number of his predecesors\n+  /* For each basic block we need to visit count number of his predecessors\n      we need to visit first.  */\n   for (n = 0; n < n_basic_blocks; n++)\n     {\n@@ -800,7 +800,7 @@ expensive_function_p (threshold)\n   if (threshold > BB_FREQ_MAX)\n     abort ();\n \n-  /* Frequencies are out of range.  This eighter means that function contains\n+  /* Frequencies are out of range.  This either means that function contains\n      internal loop executing more than BB_FREQ_MAX times or profile feedback\n      is available and function has not been executed at all.  */\n   if (ENTRY_BLOCK_PTR->frequency == 0)"}, {"sha": "a2412e707d41ff9e13d5f3cffd5c927a12f2e8c9", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaec9b3d7ed15d4d07e0091a361e52c73d2170b3/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaec9b3d7ed15d4d07e0091a361e52c73d2170b3/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=eaec9b3d7ed15d4d07e0091a361e52c73d2170b3", "patch": "@@ -197,7 +197,7 @@ typedef struct block_info_def\n   struct stack_def stack_out;\t/* Output stack configuration.  */\n   HARD_REG_SET out_reg_set;\t/* Stack regs live on output.  */\n   int done;\t\t\t/* True if block already converted.  */\n-  int predecesors;\t\t/* Number of predecesors that needs\n+  int predecesors;\t\t/* Number of predecessors that needs\n \t\t\t\t   to be visited.  */\n } *block_info;\n "}, {"sha": "c66b1a33e7d6f1a8da5f1f931f266d13afcf25be", "filename": "gcc/reload1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaec9b3d7ed15d4d07e0091a361e52c73d2170b3/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaec9b3d7ed15d4d07e0091a361e52c73d2170b3/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=eaec9b3d7ed15d4d07e0091a361e52c73d2170b3", "patch": "@@ -5900,7 +5900,7 @@ choose_reload_regs (chain)\n \t     A special case are auto_inc expressions; even if the input is\n \t     inherited, we still need the address for the output.  We can\n \t     recognize them because they have RELOAD_OUT set to RELOAD_IN.\n-\t     If we suceeded removing some reload and we are doing a preliminary\n+\t     If we succeeded removing some reload and we are doing a preliminary\n \t     pass just to remove such reloads, make another pass, since the\n \t     removal of one reload might allow us to inherit another one.  */\n \t  else if (rld[r].in"}, {"sha": "eb79fe95476b6bc59be636b4f0c0c4908e847f78", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaec9b3d7ed15d4d07e0091a361e52c73d2170b3/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaec9b3d7ed15d4d07e0091a361e52c73d2170b3/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=eaec9b3d7ed15d4d07e0091a361e52c73d2170b3", "patch": "@@ -884,7 +884,7 @@ set_of_1 (x, pat, data1)\n }\n \n /* Give an INSN, return a SET or CLOBBER expression that does modify PAT\n-   (eighter directly or via STRICT_LOW_PART and similar modifiers).  */\n+   (either directly or via STRICT_LOW_PART and similar modifiers).  */\n rtx\n set_of (pat, insn)\n      rtx pat, insn;\n@@ -2859,7 +2859,7 @@ find_first_parameter_load (call_insn, boundary)\n \n       /* Our caller needs either ensure that we will find all sets\n          (in case code has not been optimized yet), or take care\n-         for possible labels in a way by setting boundary to preceeding\n+         for possible labels in a way by setting boundary to preceding\n          CODE_LABEL.  */\n       if (GET_CODE (before) == CODE_LABEL)\n \t{"}, {"sha": "19b31a03b5283b0915307574a9df404fbab41ff4", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaec9b3d7ed15d4d07e0091a361e52c73d2170b3/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaec9b3d7ed15d4d07e0091a361e52c73d2170b3/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=eaec9b3d7ed15d4d07e0091a361e52c73d2170b3", "patch": "@@ -1056,7 +1056,7 @@ compute_dom_prob_ps (bb)\n \n   fst_in_edge = nxt_in_edge = IN_EDGES (BB_TO_BLOCK (bb));\n \n-  /* Intialize dom[bb] to '111..1'.  */\n+  /* Initialize dom[bb] to '111..1'.  */\n   sbitmap_ones (dom[bb]);\n \n   do"}, {"sha": "5825c554b64139af29c5d07107a1e898d79b0463", "filename": "gcc/toplev.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaec9b3d7ed15d4d07e0091a361e52c73d2170b3/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaec9b3d7ed15d4d07e0091a361e52c73d2170b3/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=eaec9b3d7ed15d4d07e0091a361e52c73d2170b3", "patch": "@@ -1173,7 +1173,7 @@ lang_independent_options f_options[] =\n   {\"ssa\", &flag_ssa, 1,\n    N_(\"Enable SSA optimizations\") },\n   {\"ssa-ccp\", &flag_ssa_ccp, 1,\n-   N_(\"Enable SSA conditonal constant propagation\") },\n+   N_(\"Enable SSA conditional constant propagation\") },\n   {\"ssa-dce\", &flag_ssa_dce, 1,\n    N_(\"Enable aggressive SSA dead code elimination\") },\n   {\"leading-underscore\", &flag_leading_underscore, 1,\n@@ -4667,7 +4667,7 @@ toplev_main (argc, argv)\n   /* Register the language-independent parameters.  */\n   add_params (lang_independent_params, LAST_PARAM);\n \n-  /* Perform language-specific options intialization.  */\n+  /* Perform language-specific options initialization.  */\n   (*lang_hooks.init_options) ();\n \n   /* Scan to see what optimization level has been specified.  That will"}, {"sha": "758d3199cf0a879d0c3a6ea6ca32f084ed8ce13b", "filename": "gcc/unwind-dw2-fde.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaec9b3d7ed15d4d07e0091a361e52c73d2170b3/gcc%2Funwind-dw2-fde.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaec9b3d7ed15d4d07e0091a361e52c73d2170b3/gcc%2Funwind-dw2-fde.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funwind-dw2-fde.h?ref=eaec9b3d7ed15d4d07e0091a361e52c73d2170b3", "patch": "@@ -112,7 +112,7 @@ typedef unsigned char ubyte;\n    is located, and what the register lifetimes and stack layout are\n    within the function.\n \n-   The data structures are defined in the DWARF specfication, although\n+   The data structures are defined in the DWARF specification, although\n    not in a very readable way (see LITERATURE).\n \n    Every time an exception is thrown, the code needs to locate the FDE"}]}