{"sha": "c01a93915185927d45df4c6a375c146d9923fa63", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzAxYTkzOTE1MTg1OTI3ZDQ1ZGY0YzZhMzc1YzE0NmQ5OTIzZmE2Mw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2004-01-19T10:37:59Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2004-01-19T10:37:59Z"}, "message": "[multiple changes]\n\n2004-01-19  Arnaud Charlet  <charlet@act-europe.fr>\n\n\t* utils.c: Update copyright notice, missed in previous change.\n\n2004-01-19  Vincent Celier  <celier@gnat.com>\n\n\t* mlib-prj.adb (Build_Library.Add_ALI_For): Only add the ALI to the\n\targs if Bind is True. Set First_ALI, if not already done.\n\t(Build_Library): For Stand Alone Libraries, extract from one ALI file\n\tan eventual --RTS switch, for gnatbind, and all backend switches +\n\t--RTS, for linking.\n\n2004-01-19  Robert Dewar  <dewar@gnat.com>\n\n\t* sem_attr.adb, memtrack.adb: Minor reformatting\n\n2004-01-19  Ed Schonberg  <schonberg@gnat.com>\n\n\t* exp_ch6.adb (Expand_Call): Remove code to fold calls to functions\n\tthat rename enumeration literals. This is properly done in sem_eval.\n\n\t* sem_eval.ads, sem_eval.adb (Eval_Call): New procedure to fold calls\n\tto functions that rename enumeration literals.\n\n\t* sem_res.adb (Resolve_Call): Use Eval_Call to fold static calls to\n\tfunctions that rename enumeration literals.\n\nFrom-SVN: r76146", "tree": {"sha": "94817510a2b1922a0d21ee9356fdcf6573a68339", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/94817510a2b1922a0d21ee9356fdcf6573a68339"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c01a93915185927d45df4c6a375c146d9923fa63", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c01a93915185927d45df4c6a375c146d9923fa63", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c01a93915185927d45df4c6a375c146d9923fa63", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c01a93915185927d45df4c6a375c146d9923fa63/comments", "author": null, "committer": null, "parents": [{"sha": "5c9948f4e8e1f31343ea04238fa27600a9926169", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c9948f4e8e1f31343ea04238fa27600a9926169", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5c9948f4e8e1f31343ea04238fa27600a9926169"}], "stats": {"total": 328, "additions": 247, "deletions": 81}, "files": [{"sha": "ae15e9d054638b8ac73330c1578916d16398b099", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c01a93915185927d45df4c6a375c146d9923fa63/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c01a93915185927d45df4c6a375c146d9923fa63/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=c01a93915185927d45df4c6a375c146d9923fa63", "patch": "@@ -1,3 +1,30 @@\n+2004-01-19  Arnaud Charlet  <charlet@act-europe.fr>\n+\n+\t* utils.c: Update copyright notice, missed in previous change.\n+\n+2004-01-19  Vincent Celier  <celier@gnat.com>\n+\n+\t* mlib-prj.adb (Build_Library.Add_ALI_For): Only add the ALI to the\n+\targs if Bind is True. Set First_ALI, if not already done.\n+\t(Build_Library): For Stand Alone Libraries, extract from one ALI file\n+\tan eventual --RTS switch, for gnatbind, and all backend switches +\n+\t--RTS, for linking.\n+\n+2004-01-19  Robert Dewar  <dewar@gnat.com>\n+\n+\t* sem_attr.adb, memtrack.adb: Minor reformatting\n+\n+2004-01-19  Ed Schonberg  <schonberg@gnat.com>\n+\n+\t* exp_ch6.adb (Expand_Call): Remove code to fold calls to functions\n+\tthat rename enumeration literals. This is properly done in sem_eval.\n+\n+\t* sem_eval.ads, sem_eval.adb (Eval_Call): New procedure to fold calls\n+\tto functions that rename enumeration literals.\n+\n+\t* sem_res.adb (Resolve_Call): Use Eval_Call to fold static calls to\n+\tfunctions that rename enumeration literals.\n+\n 2004-01-16  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* Make-lang.in (utils.o): Depend on target.h."}, {"sha": "6a54343c67820940543ec011e603c9e72416899c", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 2, "deletions": 24, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c01a93915185927d45df4c6a375c146d9923fa63/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c01a93915185927d45df4c6a375c146d9923fa63/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=c01a93915185927d45df4c6a375c146d9923fa63", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2003, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2004, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -1828,32 +1828,10 @@ package body Exp_Ch6 is\n          Check_Restriction (No_Abort_Statements, N);\n       end if;\n \n-      --  Some more special cases for cases other than explicit dereference\n-\n-      if Nkind (Name (N)) /= N_Explicit_Dereference then\n-\n-         --  Calls to an enumeration literal are replaced by the literal\n-         --  This case occurs only when we have a call to a function that\n-         --  is a renaming of an enumeration literal. The normal case of\n-         --  a direct reference to an enumeration literal has already been\n-         --  been dealt with by Resolve_Call. If the function is itself\n-         --  inherited (see 7423-001) the literal of the parent type must\n-         --  be explicitly converted to the return type of the function.\n-\n-         if Ekind (Subp) = E_Enumeration_Literal then\n-            if Base_Type (Etype (Subp)) /= Base_Type (Etype (N)) then\n-               Rewrite\n-                 (N, Convert_To (Etype (N), New_Occurrence_Of (Subp, Loc)));\n-            else\n-               Rewrite (N, New_Occurrence_Of (Subp, Loc));\n-            end if;\n-\n-            Resolve (N);\n-         end if;\n+      if Nkind (Name (N)) = N_Explicit_Dereference then\n \n       --  Handle case of access to protected subprogram type\n \n-      else\n          if Ekind (Base_Type (Etype (Prefix (Name (N))))) =\n                                E_Access_Protected_Subprogram_Type\n          then"}, {"sha": "2531702cb7b2e40493e7e088bcd087979a6f7281", "filename": "gcc/ada/memtrack.adb", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c01a93915185927d45df4c6a375c146d9923fa63/gcc%2Fada%2Fmemtrack.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c01a93915185927d45df4c6a375c146d9923fa63/gcc%2Fada%2Fmemtrack.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmemtrack.adb?ref=c01a93915185927d45df4c6a375c146d9923fa63", "patch": "@@ -235,6 +235,7 @@ package body System.Memory is\n \n    procedure Free (Ptr : System.Address) is\n       Addr : aliased constant System.Address := Ptr;\n+\n    begin\n       Lock_Task.all;\n \n@@ -265,7 +266,6 @@ package body System.Memory is\n          c_free (Ptr);\n \n          First_Call := True;\n-\n       end if;\n \n       Unlock_Task.all;\n@@ -280,10 +280,12 @@ package body System.Memory is\n       if Needs_Init then\n          Needs_Init := False;\n          Gmemfile := fopen (Gmemfname, \"wb\" & ASCII.NUL);\n+\n          if Gmemfile = System.Null_Address then\n             Put_Line (\"Couldn't open gnatmem log file for writing\");\n             OS_Exit (255);\n          end if;\n+\n          fwrite (\"GMEM DUMP\" & ASCII.LF, 10, 1, Gmemfile);\n       end if;\n    end Gmem_Initialize;\n@@ -296,6 +298,7 @@ package body System.Memory is\n      (Ptr : System.Address; Size : size_t) return System.Address\n    is\n       Result : System.Address;\n+\n    begin\n       if Size = size_t'Last then\n          Raise_Exception (Storage_Error'Identity, \"object too large\");"}, {"sha": "daaed1cd5735a20aa82fb72c55d756af2c618d13", "filename": "gcc/ada/mlib-prj.adb", "status": "modified", "additions": 164, "deletions": 49, "changes": 213, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c01a93915185927d45df4c6a375c146d9923fa63/gcc%2Fada%2Fmlib-prj.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c01a93915185927d45df4c6a375c146d9923fa63/gcc%2Fada%2Fmlib-prj.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-prj.adb?ref=c01a93915185927d45df4c6a375c146d9923fa63", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---              Copyright (C) 2001-2003, Ada Core Technologies, Inc.        --\n+--              Copyright (C) 2001-2004, Ada Core Technologies, Inc.        --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -39,6 +39,7 @@ with Prj.Env;  use Prj.Env;\n with Prj.Util; use Prj.Util;\n with Sinput.P;\n with Snames;   use Snames;\n+with Switch;   use Switch;\n with Table;\n with Types;    use Types;\n \n@@ -353,6 +354,9 @@ package body MLib.Prj is\n       Copy_Dir : Name_Id;\n       --  Directory where to copy ALI files and possibly interface sources\n \n+      First_ALI : Name_Id := No_Name;\n+      --  Store the ALI file name of a source of the library (the first found)\n+\n       procedure Add_ALI_For (Source : Name_Id);\n       --  Add the name of the ALI file corresponding to Source to the\n       --  Arguments.\n@@ -386,14 +390,27 @@ package body MLib.Prj is\n \n       procedure Add_ALI_For (Source : Name_Id) is\n          ALI : constant String := ALI_File_Name (Get_Name_String (Source));\n+         ALI_Id : Name_Id;\n       begin\n-         Add_Argument (ALI);\n-\n-         --  Add the ALI file name to the library ALIs\n+         if Bind then\n+            Add_Argument (ALI);\n+         end if;\n \n          Name_Len := 0;\n          Add_Str_To_Name_Buffer (S => ALI);\n-         Library_ALIs.Set (Name_Find, True);\n+         ALI_Id := Name_Find;\n+\n+         --  Add the ALI file name to the library ALIs\n+\n+         if Bind then\n+            Library_ALIs.Set (ALI_Id, True);\n+         end if;\n+\n+         --  Set First_ALI, if not already done\n+\n+         if First_ALI = No_Name then\n+            First_ALI := ALI_Id;\n+         end if;\n       end Add_ALI_For;\n \n       ---------------\n@@ -850,59 +867,111 @@ package body MLib.Prj is\n                   end;\n                end if;\n             end;\n+         end if;\n \n-            --  Get all the ALI files of the project file\n+         --  Get all the ALI files of the project file. We do that even if\n+         --  Bind is False, so that First_ALI is set.\n \n-            declare\n-               Unit : Unit_Data;\n+         declare\n+            Unit : Unit_Data;\n \n-            begin\n-               Library_ALIs.Reset;\n-               Interface_ALIs.Reset;\n-               Processed_ALIs.Reset;\n-               for Source in 1 .. Com.Units.Last loop\n-                  Unit := Com.Units.Table (Source);\n-\n-                  if Unit.File_Names (Body_Part).Name /= No_Name\n-                    and then Unit.File_Names (Body_Part).Path /= Slash\n+         begin\n+            Library_ALIs.Reset;\n+            Interface_ALIs.Reset;\n+            Processed_ALIs.Reset;\n+            for Source in 1 .. Com.Units.Last loop\n+               Unit := Com.Units.Table (Source);\n+\n+               if Unit.File_Names (Body_Part).Name /= No_Name\n+                 and then Unit.File_Names (Body_Part).Path /= Slash\n+               then\n+                  if\n+                    Check_Project (Unit.File_Names (Body_Part).Project)\n                   then\n-                     if\n-                       Check_Project (Unit.File_Names (Body_Part).Project)\n-                     then\n-                        if Unit.File_Names (Specification).Name = No_Name then\n-                           declare\n-                              Src_Ind : Source_File_Index;\n-\n-                           begin\n-                              Src_Ind := Sinput.P.Load_Project_File\n-                                (Get_Name_String\n-                                   (Unit.File_Names\n-                                      (Body_Part).Path));\n+                     if Unit.File_Names (Specification).Name = No_Name then\n+                        declare\n+                           Src_Ind : Source_File_Index;\n+\n+                        begin\n+                           Src_Ind := Sinput.P.Load_Project_File\n+                             (Get_Name_String\n+                                (Unit.File_Names\n+                                   (Body_Part).Path));\n+\n+                           --  Add the ALI file only if it is not a subunit\n+\n+                           if\n+                           not Sinput.P.Source_File_Is_Subunit (Src_Ind)\n+                           then\n+                              Add_ALI_For\n+                                (Unit.File_Names (Body_Part).Name);\n+                              exit when not Bind;\n+                           end if;\n+                        end;\n+\n+                     else\n+                        Add_ALI_For (Unit.File_Names (Body_Part).Name);\n+                        exit when not Bind;\n+                     end if;\n+                  end if;\n \n-                              --  Add the ALI file only if it is not a subunit\n+               elsif Unit.File_Names (Specification).Name /= No_Name\n+                 and then Unit.File_Names (Specification).Path /= Slash\n+                 and then Check_Project\n+                   (Unit.File_Names (Specification).Project)\n+               then\n+                  Add_ALI_For (Unit.File_Names (Specification).Name);\n+                  exit when not Bind;\n+               end if;\n+            end loop;\n \n-                              if\n-                              not Sinput.P.Source_File_Is_Subunit (Src_Ind)\n-                              then\n-                                 Add_ALI_For\n-                                   (Unit.File_Names (Body_Part).Name);\n-                              end if;\n-                           end;\n+         end;\n \n-                        else\n-                           Add_ALI_For (Unit.File_Names (Body_Part).Name);\n-                        end if;\n-                     end if;\n+         --  Continue setup and call gnatbind if Bind is True\n \n-                  elsif Unit.File_Names (Specification).Name /= No_Name\n-                    and then Unit.File_Names (Specification).Path /= Slash\n-                    and then Check_Project\n-                      (Unit.File_Names (Specification).Project)\n-                  then\n-                     Add_ALI_For (Unit.File_Names (Specification).Name);\n+         if Bind then\n+            --  Get an eventual --RTS from the ALI file\n+\n+            if First_ALI /= No_Name then\n+               declare\n+                  use Types;\n+                  T : Text_Buffer_Ptr;\n+                  A : ALI_Id;\n+\n+               begin\n+                  --  Load the ALI file\n+\n+                  T := Read_Library_Info (First_ALI, True);\n+\n+                  --  Read it\n+\n+                  A := Scan_ALI\n+                         (First_ALI, T, Ignore_ED => False, Err => False);\n+\n+                  if A /= No_ALI_Id then\n+                     for Index in\n+                       ALI.Units.Table\n+                         (ALI.ALIs.Table (A).First_Unit).First_Arg ..\n+                       ALI.Units.Table\n+                         (ALI.ALIs.Table (A).First_Unit).Last_Arg\n+                     loop\n+                        --  Look for --RTS. If found, add the switch to call\n+                        --  gnatbind.\n+\n+                        declare\n+                           Arg : String_Ptr renames Args.Table (Index);\n+                        begin\n+                           if\n+                             Arg (Arg'First + 2 .. Arg'First + 5) = \"RTS=\"\n+                           then\n+                              Add_Argument (Arg.all);\n+                              exit;\n+                           end if;\n+                        end;\n+                     end loop;\n                   end if;\n-               end loop;\n-            end;\n+               end;\n+            end if;\n \n             --  Set the paths\n \n@@ -958,6 +1027,52 @@ package body MLib.Prj is\n                Add_Argument (PIC_Option);\n             end if;\n \n+            --  Get the back-end switches and --RTS from the ALI file\n+\n+            if First_ALI /= No_Name then\n+               declare\n+                  use Types;\n+                  T : Text_Buffer_Ptr;\n+                  A : ALI_Id;\n+\n+               begin\n+                  --  Load the ALI file\n+\n+                  T := Read_Library_Info (First_ALI, True);\n+\n+                  --  Read it\n+\n+                  A := Scan_ALI\n+                         (First_ALI, T, Ignore_ED => False, Err => False);\n+\n+                  if A /= No_ALI_Id then\n+                     for Index in\n+                       ALI.Units.Table\n+                         (ALI.ALIs.Table (A).First_Unit).First_Arg ..\n+                       ALI.Units.Table\n+                         (ALI.ALIs.Table (A).First_Unit).Last_Arg\n+                     loop\n+                        --  Do not compile with the front end switches except\n+                        --  for --RTS.\n+\n+                        declare\n+                           Arg : String_Ptr renames Args.Table (Index);\n+                        begin\n+                           if not Is_Front_End_Switch (Arg.all)\n+                             or else\n+                               Arg (Arg'First + 2 .. Arg'First + 5) = \"RTS=\"\n+                           then\n+                              Add_Argument (Arg.all);\n+                           end if;\n+                        end;\n+                     end loop;\n+                  end if;\n+               end;\n+            end if;\n+\n+            --  Now that all the arguments are set, compile the binder\n+            --  generated file.\n+\n             Display (Gcc);\n             GNAT.OS_Lib.Spawn\n               (Gcc_Path.all, Arguments (1 .. Argument_Number), Success);"}, {"sha": "86e7b6a73e48feeedfe9029012ba376cffb369f5", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c01a93915185927d45df4c6a375c146d9923fa63/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c01a93915185927d45df4c6a375c146d9923fa63/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=c01a93915185927d45df4c6a375c146d9923fa63", "patch": "@@ -4464,8 +4464,8 @@ package body Sem_Attr is\n         and then Raises_Constraint_Error (N)\n       then\n          Rewrite (N,\n-            Make_Raise_Program_Error (Loc,\n-              Reason => PE_Accessibility_Check_Failed));\n+           Make_Raise_Program_Error (Loc,\n+             Reason => PE_Accessibility_Check_Failed));\n          Set_Etype (N, C_Type);\n          return;\n "}, {"sha": "f884854f90624488a4180a06a1ddf8277012f5fc", "filename": "gcc/ada/sem_eval.adb", "status": "modified", "additions": 44, "deletions": 1, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c01a93915185927d45df4c6a375c146d9923fa63/gcc%2Fada%2Fsem_eval.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c01a93915185927d45df4c6a375c146d9923fa63/gcc%2Fada%2Fsem_eval.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.adb?ref=c01a93915185927d45df4c6a375c146d9923fa63", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2003 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -1180,6 +1180,49 @@ package body Sem_Eval is\n       null;\n    end Eval_Character_Literal;\n \n+   ---------------\n+   -- Eval_Call --\n+   ---------------\n+\n+   --  Static function calls are either calls to predefined operators\n+   --  with static arguments, or calls to functions that rename a literal.\n+   --  Only the latter case is handled here, predefined operators are\n+   --  constant-folded elsewhere.\n+   --  If the function is itself inherited (see 7423-001) the literal of\n+   --  the parent type must be explicitly converted to the return type\n+   --  of the function.\n+\n+   procedure Eval_Call (N : Node_Id) is\n+      Loc : constant Source_Ptr := Sloc (N);\n+      Typ : constant Entity_Id  := Etype (N);\n+      Lit : Entity_Id;\n+\n+   begin\n+      if Nkind (N) = N_Function_Call\n+        and then No (Parameter_Associations (N))\n+        and then Is_Entity_Name (Name (N))\n+        and then Present (Alias (Entity (Name (N))))\n+        and then Is_Enumeration_Type (Base_Type (Typ))\n+      then\n+         Lit := Alias (Entity (Name (N)));\n+\n+         while Present (Alias (Lit)) loop\n+            Lit := Alias (Lit);\n+         end loop;\n+\n+         if Ekind (Lit) = E_Enumeration_Literal then\n+            if Base_Type (Etype (Lit)) /= Base_Type (Typ) then\n+               Rewrite\n+                 (N, Convert_To (Typ, New_Occurrence_Of (Lit, Loc)));\n+            else\n+               Rewrite (N, New_Occurrence_Of (Lit, Loc));\n+            end if;\n+\n+            Resolve (N, Typ);\n+         end if;\n+      end if;\n+   end Eval_Call;\n+\n    ------------------------\n    -- Eval_Concatenation --\n    ------------------------"}, {"sha": "404ba58294d91f1838b8bbcd57aa9afde35df26e", "filename": "gcc/ada/sem_eval.ads", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c01a93915185927d45df4c6a375c146d9923fa63/gcc%2Fada%2Fsem_eval.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c01a93915185927d45df4c6a375c146d9923fa63/gcc%2Fada%2Fsem_eval.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.ads?ref=c01a93915185927d45df4c6a375c146d9923fa63", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2003 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -268,6 +268,7 @@ package Sem_Eval is\n    procedure Eval_Actual                 (N : Node_Id);\n    procedure Eval_Allocator              (N : Node_Id);\n    procedure Eval_Arithmetic_Op          (N : Node_Id);\n+   procedure Eval_Call                   (N : Node_Id);\n    procedure Eval_Character_Literal      (N : Node_Id);\n    procedure Eval_Concatenation          (N : Node_Id);\n    procedure Eval_Conditional_Expression (N : Node_Id);"}, {"sha": "59a98c56eaee3072d701997683dd96e4ad2f23e6", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c01a93915185927d45df4c6a375c146d9923fa63/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c01a93915185927d45df4c6a375c146d9923fa63/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=c01a93915185927d45df4c6a375c146d9923fa63", "patch": "@@ -3807,8 +3807,7 @@ package body Sem_Res is\n          Check_Intrinsic_Call (N);\n       end if;\n \n-      --  If we fall through we definitely have a non-static call\n-\n+      Eval_Call (N);\n       Check_Elab_Call (N);\n    end Resolve_Call;\n "}, {"sha": "b58ccde0ef4ae6521988e051f9d97a20b3a7f712", "filename": "gcc/ada/utils.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c01a93915185927d45df4c6a375c146d9923fa63/gcc%2Fada%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c01a93915185927d45df4c6a375c146d9923fa63/gcc%2Fada%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils.c?ref=c01a93915185927d45df4c6a375c146d9923fa63", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                          C Implementation File                           *\n  *                                                                          *\n- *          Copyright (C) 1992-2003, Free Software Foundation, Inc.         *\n+ *          Copyright (C) 1992-2004, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *"}]}