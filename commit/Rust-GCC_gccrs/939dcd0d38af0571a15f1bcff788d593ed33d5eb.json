{"sha": "939dcd0d38af0571a15f1bcff788d593ed33d5eb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTM5ZGNkMGQzOGFmMDU3MWExNWYxYmNmZjc4OGQ1OTNlZDMzZDVlYg==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2010-07-12T18:53:08Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2010-07-12T18:53:08Z"}, "message": "Makefile.in (target-globals.o): Depend on $(REGS_H).\n\ngcc/\n\t* Makefile.in (target-globals.o): Depend on $(REGS_H).\n\t* regs.h (target_reg_modes): New structure.\n\t(default_target_reg_modes): Declare.\n\t(this_target_reg_modes): Declare as a variable or define as a macro.\n\t(hard_regno_nregs, reg_raw_mode): Redefine as macros.\n\t* reginfo.c (default_target_reg_modes): New variable.\n\t(this_target_reg_modes): New conditional variable.\n\t(hard_regno_nregs, reg_raw_mode): Delete.\n\t* target-globals.h (this_target_regs): Declare.\n\t(target_globals): Add a regs field.\n\t(restore_target_globals): Copy the regs field to this_target_regs.\n\t* target-globals.c: Include regs.h.\n\t(default_target_globals): Initialize the regs field.\n\t(save_target_globals): Likewise.\n\nFrom-SVN: r162087", "tree": {"sha": "d708b56be81952da9c5f1952199355f972230b0e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d708b56be81952da9c5f1952199355f972230b0e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/939dcd0d38af0571a15f1bcff788d593ed33d5eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/939dcd0d38af0571a15f1bcff788d593ed33d5eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/939dcd0d38af0571a15f1bcff788d593ed33d5eb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/939dcd0d38af0571a15f1bcff788d593ed33d5eb/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3bd36029de1b586b49b3b021385b275ba5427611", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3bd36029de1b586b49b3b021385b275ba5427611", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3bd36029de1b586b49b3b021385b275ba5427611"}], "stats": {"total": 76, "additions": 55, "deletions": 21}, "files": [{"sha": "eec56ce60ec252e874c8796d8a7f2ac1416af31c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/939dcd0d38af0571a15f1bcff788d593ed33d5eb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/939dcd0d38af0571a15f1bcff788d593ed33d5eb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=939dcd0d38af0571a15f1bcff788d593ed33d5eb", "patch": "@@ -1,3 +1,20 @@\n+2010-07-12  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* Makefile.in (target-globals.o): Depend on $(REGS_H).\n+\t* regs.h (target_reg_modes): New structure.\n+\t(default_target_reg_modes): Declare.\n+\t(this_target_reg_modes): Declare as a variable or define as a macro.\n+\t(hard_regno_nregs, reg_raw_mode): Redefine as macros.\n+\t* reginfo.c (default_target_reg_modes): New variable.\n+\t(this_target_reg_modes): New conditional variable.\n+\t(hard_regno_nregs, reg_raw_mode): Delete.\n+\t* target-globals.h (this_target_regs): Declare.\n+\t(target_globals): Add a regs field.\n+\t(restore_target_globals): Copy the regs field to this_target_regs.\n+\t* target-globals.c: Include regs.h.\n+\t(default_target_globals): Initialize the regs field.\n+\t(save_target_globals): Likewise.\n+\n 2010-07-12  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \t* doc/tm.texi.in (SWITCHABLE_TARGET): Document."}, {"sha": "136522723bcfa498e661360aef3c2ece0b93a381", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/939dcd0d38af0571a15f1bcff788d593ed33d5eb/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/939dcd0d38af0571a15f1bcff788d593ed33d5eb/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=939dcd0d38af0571a15f1bcff788d593ed33d5eb", "patch": "@@ -3477,7 +3477,7 @@ lower-subreg.o : lower-subreg.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(EXPR_H) $(EXCEPT_H) $(REGS_H) $(TREE_PASS_H) $(DF_H)\n target-globals.o : target-globals.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(TM_H) insn-config.h $(MACHMODE_H) $(GGC_H) $(TOPLEV_H) target-globals.h \\\n-   $(FLAGS_H)\n+   $(FLAGS_H) $(REGS_H)\n \n $(out_object_file): $(out_file) $(CONFIG_H) coretypes.h $(TM_H) $(TREE_H) \\\n    $(RTL_H) $(REGS_H) hard-reg-set.h insn-config.h conditions.h \\"}, {"sha": "87bc630daf3745f4da951eb02329e1f0e8a036c5", "filename": "gcc/reginfo.c", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/939dcd0d38af0571a15f1bcff788d593ed33d5eb/gcc%2Freginfo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/939dcd0d38af0571a15f1bcff788d593ed33d5eb/gcc%2Freginfo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freginfo.c?ref=939dcd0d38af0571a15f1bcff788d593ed33d5eb", "patch": "@@ -59,6 +59,11 @@ along with GCC; see the file COPYING3.  If not see\n int max_regno;\n \n \f\n+struct target_regs default_target_regs;\n+#if SWITCHABLE_TARGET\n+struct target_regs *this_target_regs = &default_target_regs;\n+#endif\n+\n /* Register tables used by many passes.  */\n \n /* Indexed by hard register number, contains 1 for registers\n@@ -175,12 +180,6 @@ const char * reg_names[] = REGISTER_NAMES;\n /* Array containing all of the register class names.  */\n const char * reg_class_names[] = REG_CLASS_NAMES;\n \n-/* For each hard register, the widest mode object that it can contain.\n-   This will be a MODE_INT mode if the register can hold integers.  Otherwise\n-   it will be a MODE_FLOAT or a MODE_CC mode, whichever is valid for the\n-   register.  */\n-enum machine_mode reg_raw_mode[FIRST_PSEUDO_REGISTER];\n-\n /* 1 if there is a register of given mode.  */\n bool have_regs_of_mode [MAX_MACHINE_MODE];\n \n@@ -209,9 +208,6 @@ static GTY(()) rtx top_of_stack[MAX_MACHINE_MODE];\n    reginfo has been initialized.  */\n static int no_global_reg_vars = 0;\n \n-/* Specify number of hard registers given machine mode occupy.  */\n-unsigned char hard_regno_nregs[FIRST_PSEUDO_REGISTER][MAX_MACHINE_MODE];\n-\n /* Given a register bitmap, turn on the bits in a HARD_REG_SET that\n    correspond to the hard registers, if any, set in that map.  This\n    could be done far more efficiently by having all sorts of special-cases"}, {"sha": "6ae427cd19739a1f25ea34fde192d2b596b9f65c", "filename": "gcc/regs.h", "status": "modified", "additions": 25, "deletions": 10, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/939dcd0d38af0571a15f1bcff788d593ed33d5eb/gcc%2Fregs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/939dcd0d38af0571a15f1bcff788d593ed33d5eb/gcc%2Fregs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregs.h?ref=939dcd0d38af0571a15f1bcff788d593ed33d5eb", "patch": "@@ -218,13 +218,6 @@ extern short *reg_renumber;\n \n extern bool have_regs_of_mode [MAX_MACHINE_MODE];\n \n-/* For each hard register, the widest mode object that it can contain.\n-   This will be a MODE_INT mode if the register can hold integers.  Otherwise\n-   it will be a MODE_FLOAT or a MODE_CC mode, whichever is valid for the\n-   register.  */\n-\n-extern enum machine_mode reg_raw_mode[FIRST_PSEUDO_REGISTER];\n-\n /* Flag set by local-alloc or global-alloc if they decide to allocate\n    something in a call-clobbered register.  */\n \n@@ -266,9 +259,6 @@ typedef unsigned short move_table[N_REG_CLASSES];\n    in another class.  */\n extern move_table *move_cost[MAX_MACHINE_MODE];\n \n-/* Specify number of hard registers given machine mode occupy.  */\n-extern unsigned char hard_regno_nregs[FIRST_PSEUDO_REGISTER][MAX_MACHINE_MODE];\n-\n /* Similar, but here we don't have to move if the first index is a\n    subset of the second so in that case the cost is zero.  */\n extern move_table *may_move_in_cost[MAX_MACHINE_MODE];\n@@ -277,6 +267,31 @@ extern move_table *may_move_in_cost[MAX_MACHINE_MODE];\n    superset of the second so in that case the cost is zero.  */\n extern move_table *may_move_out_cost[MAX_MACHINE_MODE];\n \n+/* Target-dependent globals.  */\n+struct target_regs {\n+  /* For each starting hard register, the number of consecutive hard\n+     registers that a given machine mode occupies.  */\n+  unsigned char x_hard_regno_nregs[FIRST_PSEUDO_REGISTER][MAX_MACHINE_MODE];\n+\n+  /* For each hard register, the widest mode object that it can contain.\n+     This will be a MODE_INT mode if the register can hold integers.  Otherwise\n+     it will be a MODE_FLOAT or a MODE_CC mode, whichever is valid for the\n+     register.  */\n+  enum machine_mode x_reg_raw_mode[FIRST_PSEUDO_REGISTER];\n+};\n+\n+extern struct target_regs default_target_regs;\n+#if SWITCHABLE_TARGET\n+extern struct target_regs *this_target_regs;\n+#else\n+#define this_target_regs (&default_target_regs)\n+#endif\n+\n+#define hard_regno_nregs \\\n+  (this_target_regs->x_hard_regno_nregs)\n+#define reg_raw_mode \\\n+  (this_target_regs->x_reg_raw_mode)\n+\n /* Return an exclusive upper bound on the registers occupied by hard\n    register (reg:MODE REGNO).  */\n "}, {"sha": "3a7f2d4c5e64e06d26821a513a415cafb3626fc2", "filename": "gcc/target-globals.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/939dcd0d38af0571a15f1bcff788d593ed33d5eb/gcc%2Ftarget-globals.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/939dcd0d38af0571a15f1bcff788d593ed33d5eb/gcc%2Ftarget-globals.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-globals.c?ref=939dcd0d38af0571a15f1bcff788d593ed33d5eb", "patch": "@@ -27,10 +27,12 @@ along with GCC; see the file COPYING3.  If not see\n #include \"toplev.h\"\n #include \"target-globals.h\"\n #include \"flags.h\"\n+#include \"regs.h\"\n \n #if SWITCHABLE_TARGET\n struct target_globals default_target_globals = {\n-  &default_target_flag_state\n+  &default_target_flag_state,\n+  &default_target_regs\n };\n \n struct target_globals *\n@@ -40,6 +42,7 @@ save_target_globals (void)\n \n   g = ggc_alloc_target_globals ();\n   g->flag_state = XCNEW (struct target_flag_state);\n+  g->regs = XCNEW (struct target_regs);\n   restore_target_globals (g);\n   target_reinit ();\n   return g;"}, {"sha": "a733aa52b89e77ad65e0c25a24d7f8c112fb1b48", "filename": "gcc/target-globals.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/939dcd0d38af0571a15f1bcff788d593ed33d5eb/gcc%2Ftarget-globals.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/939dcd0d38af0571a15f1bcff788d593ed33d5eb/gcc%2Ftarget-globals.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-globals.h?ref=939dcd0d38af0571a15f1bcff788d593ed33d5eb", "patch": "@@ -22,9 +22,11 @@ along with GCC; see the file COPYING3.  If not see\n \n #if SWITCHABLE_TARGET\n extern struct target_flag_state *this_target_flag_state;\n+extern struct target_regs *this_target_regs;\n \n struct GTY(()) target_globals {\n   struct target_flag_state *GTY((skip)) flag_state;\n+  struct target_regs *GTY((skip)) regs;\n };\n \n extern struct target_globals default_target_globals;\n@@ -35,6 +37,7 @@ static inline void\n restore_target_globals (struct target_globals *g)\n {\n   this_target_flag_state = g->flag_state;\n+  this_target_regs = g->regs;\n }\n #endif\n "}]}