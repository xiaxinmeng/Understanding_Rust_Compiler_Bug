{"sha": "a6c5361c08c88e0db15bec581813b8910ba62116", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTZjNTM2MWMwOGM4OGUwZGIxNWJlYzU4MTgxM2I4OTEwYmE2MjExNg==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2015-12-01T06:36:02Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2015-12-01T06:36:02Z"}, "message": "ipa-devirt.c (type_with_linkage_p, [...]): Move to ...\n\n\n\t* ipa-devirt.c (type_with_linkage_p, type_in_anonymous_namespace_p,\n\todr_type_p): Move to ...\n\t* ipa-utils.h (type_with_linkage_p, type_in_anonymous_namespace_p,\n\todr_type_p): here; miscro-optimize.\n\nFrom-SVN: r231098", "tree": {"sha": "8f756ea4913b71dd970ede50db1931bd8d6092ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8f756ea4913b71dd970ede50db1931bd8d6092ff"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a6c5361c08c88e0db15bec581813b8910ba62116", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6c5361c08c88e0db15bec581813b8910ba62116", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a6c5361c08c88e0db15bec581813b8910ba62116", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6c5361c08c88e0db15bec581813b8910ba62116/comments", "author": null, "committer": null, "parents": [{"sha": "cdf66caf4fa836a4398f74faceb373d84e019bb7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cdf66caf4fa836a4398f74faceb373d84e019bb7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cdf66caf4fa836a4398f74faceb373d84e019bb7"}], "stats": {"total": 182, "additions": 93, "deletions": 89}, "files": [{"sha": "c1114532c2e2c6324b75a2093ab541bd62d3ea91", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6c5361c08c88e0db15bec581813b8910ba62116/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6c5361c08c88e0db15bec581813b8910ba62116/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a6c5361c08c88e0db15bec581813b8910ba62116", "patch": "@@ -1,3 +1,10 @@\n+2015-12-01  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* ipa-devirt.c (type_with_linkage_p, type_in_anonymous_namespace_p,\n+\todr_type_p): Move to ...\n+\t* ipa-utils.h (type_with_linkage_p, type_in_anonymous_namespace_p,\n+\todr_type_p): here; miscro-optimize.\n+\n 2015-12-01  Bin Cheng  <bin.cheng@arm.com>\n \n \tPR tree-optimization/68529"}, {"sha": "7a77b5a10d6453cc276b457dc8ae6dfe1db0115c", "filename": "gcc/ipa-devirt.c", "status": "modified", "additions": 0, "deletions": 87, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6c5361c08c88e0db15bec581813b8910ba62116/gcc%2Fipa-devirt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6c5361c08c88e0db15bec581813b8910ba62116/gcc%2Fipa-devirt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-devirt.c?ref=a6c5361c08c88e0db15bec581813b8910ba62116", "patch": "@@ -209,93 +209,6 @@ struct GTY(()) odr_type_d\n   bool rtti_broken;\n };\n \n-/* Return true if T is a type with linkage defined.  */\n-\n-bool\n-type_with_linkage_p (const_tree t)\n-{\n-  /* Builtin types do not define linkage, their TYPE_CONTEXT is NULL.  */\n-  if (!TYPE_CONTEXT (t)\n-      || !TYPE_NAME (t) || TREE_CODE (TYPE_NAME (t)) != TYPE_DECL\n-      || !TYPE_STUB_DECL (t))\n-    return false;\n-\n-  /* In LTO do not get confused by non-C++ produced types or types built\n-     with -fno-lto-odr-type-merigng.  */\n-  if (in_lto_p)\n-    {\n-      /* To support -fno-lto-odr-type-merigng recognize types with vtables\n-         to have linkage.  */\n-      if (RECORD_OR_UNION_TYPE_P (t)\n-\t  && TYPE_BINFO (t) && BINFO_VTABLE (TYPE_BINFO (t)))\n-        return true;\n-      /* Do not accept any other types - we do not know if they were produced\n-         by C++ FE.  */\n-      if (!DECL_ASSEMBLER_NAME_SET_P (TYPE_NAME (t)))\n-        return false;\n-    }\n-\n-  return (RECORD_OR_UNION_TYPE_P (t)\n-\t  || TREE_CODE (t) == ENUMERAL_TYPE);\n-}\n-\n-/* Return true if T is in anonymous namespace.\n-   This works only on those C++ types with linkage defined.  */\n-\n-bool\n-type_in_anonymous_namespace_p (const_tree t)\n-{\n-  gcc_assert (type_with_linkage_p (t));\n-\n-  /* Keep -fno-lto-odr-type-merging working by recognizing classes with vtables\n-     properly into anonymous namespaces.  */\n-  if (RECORD_OR_UNION_TYPE_P (t)\n-      && TYPE_BINFO (t) && BINFO_VTABLE (TYPE_BINFO (t)))\n-    return (TYPE_STUB_DECL (t) && !TREE_PUBLIC (TYPE_STUB_DECL (t)));\n-\n-  if (TYPE_STUB_DECL (t) && !TREE_PUBLIC (TYPE_STUB_DECL (t)))\n-    {\n-      /* C++ FE uses magic <anon> as assembler names of anonymous types.\n- \t verify that this match with type_in_anonymous_namespace_p.  */\n-      if (in_lto_p)\n-\tgcc_checking_assert (!strcmp (\"<anon>\",\n-\t\t\t\t      IDENTIFIER_POINTER\n-\t\t\t\t\t(DECL_ASSEMBLER_NAME (TYPE_NAME (t)))));\n-      return true;\n-    }\n-  return false;\n-}\n-\n-/* Return true of T is type with One Definition Rule info attached. \n-   It means that either it is anonymous type or it has assembler name\n-   set.  */\n-\n-bool\n-odr_type_p (const_tree t)\n-{\n-  /* We do not have this information when not in LTO, but we do not need\n-     to care, since it is used only for type merging.  */\n-  gcc_checking_assert (in_lto_p || flag_lto);\n-\n-  /* To support -fno-lto-odr-type-merging consider types with vtables ODR.  */\n-  if (type_with_linkage_p (t) && type_in_anonymous_namespace_p (t))\n-    return true;\n-\n-  if (TYPE_NAME (t) && TREE_CODE (TYPE_NAME (t)) == TYPE_DECL\n-      && (DECL_ASSEMBLER_NAME_SET_P (TYPE_NAME (t))))\n-    {\n-      /* C++ FE uses magic <anon> as assembler names of anonymous types.\n- \t verify that this match with type_in_anonymous_namespace_p.  */\n-      gcc_checking_assert (!type_with_linkage_p (t)\n-\t\t\t   || strcmp (\"<anon>\",\n-\t\t\t\t      IDENTIFIER_POINTER\n-\t\t\t\t\t(DECL_ASSEMBLER_NAME (TYPE_NAME (t))))\n-\t\t\t   || type_in_anonymous_namespace_p (t));\n-      return true;\n-    }\n-  return false;\n-}\n-\n /* Return TRUE if all derived types of T are known and thus\n    we may consider the walk of derived type complete.\n "}, {"sha": "b537f3c8f311456b3bc81ce2bc080603028d7a27", "filename": "gcc/ipa-utils.h", "status": "modified", "additions": 86, "deletions": 2, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6c5361c08c88e0db15bec581813b8910ba62116/gcc%2Fipa-utils.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6c5361c08c88e0db15bec581813b8910ba62116/gcc%2Fipa-utils.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.h?ref=a6c5361c08c88e0db15bec581813b8910ba62116", "patch": "@@ -63,8 +63,6 @@ possible_polymorphic_call_targets (tree, HOST_WIDE_INT,\n \t\t\t\t   void **cache_token = NULL,\n \t\t\t\t   bool speuclative = false);\n odr_type get_odr_type (tree, bool insert = false);\n-bool type_in_anonymous_namespace_p (const_tree);\n-bool type_with_linkage_p (const_tree);\n bool odr_type_p (const_tree);\n bool possible_polymorphic_call_target_p (tree ref, gimple *stmt, struct cgraph_node *n);\n void dump_possible_polymorphic_call_targets (FILE *, tree, HOST_WIDE_INT,\n@@ -176,6 +174,92 @@ polymorphic_type_binfo_p (const_tree binfo)\n   return (BINFO_TYPE (binfo) && TYPE_BINFO (BINFO_TYPE (binfo))\n \t  && BINFO_VTABLE (TYPE_BINFO (BINFO_TYPE (binfo))));\n }\n+\n+/* Return true if T is a type with linkage defined.  */\n+\n+inline bool\n+type_with_linkage_p (const_tree t)\n+{\n+  if (!TYPE_NAME (t) || TREE_CODE (TYPE_NAME (t)) != TYPE_DECL\n+      || !TYPE_STUB_DECL (t))\n+    return false;\n+  /* In LTO do not get confused by non-C++ produced types or types built\n+     with -fno-lto-odr-type-merigng.  */\n+  if (in_lto_p)\n+    {\n+      /* To support -fno-lto-odr-type-merigng recognize types with vtables\n+         to have linkage.  */\n+      if (RECORD_OR_UNION_TYPE_P (t)\n+\t  && TYPE_BINFO (t) && BINFO_VTABLE (TYPE_BINFO (t)))\n+        return true;\n+      /* With -flto-odr-type-merging C++ FE specify mangled names\n+\t for all types with the linkage.  */\n+      return DECL_ASSEMBLER_NAME_SET_P (TYPE_NAME (t));\n+    }\n+\n+  if (!RECORD_OR_UNION_TYPE_P (t) && TREE_CODE (t) != ENUMERAL_TYPE)\n+    return false;\n+\n+  /* Builtin types do not define linkage, their TYPE_CONTEXT is NULL.  */\n+  if (!TYPE_CONTEXT (t))\n+    return false;\n+\n+  return true;\n+}\n+\n+/* Return true if T is in anonymous namespace.\n+   This works only on those C++ types with linkage defined.  */\n+\n+inline bool\n+type_in_anonymous_namespace_p (const_tree t)\n+{\n+  gcc_checking_assert (type_with_linkage_p (t));\n+\n+  if (!TREE_PUBLIC (TYPE_STUB_DECL (t)))\n+    {\n+      /* C++ FE uses magic <anon> as assembler names of anonymous types.\n+ \t verify that this match with type_in_anonymous_namespace_p.  */\n+      gcc_checking_assert (!in_lto_p || !DECL_ASSEMBLER_NAME_SET_P (t)\n+\t\t\t   || !strcmp\n+\t\t\t\t (\"<anon>\",\n+\t\t\t\t  IDENTIFIER_POINTER\n+\t\t\t\t     (DECL_ASSEMBLER_NAME (TYPE_NAME (t)))));\n+      return true;\n+    }\n+  return false;\n+}\n+\n+/* Return true of T is type with One Definition Rule info attached. \n+   It means that either it is anonymous type or it has assembler name\n+   set.  */\n+\n+inline bool\n+odr_type_p (const_tree t)\n+{\n+  /* We do not have this information when not in LTO, but we do not need\n+     to care, since it is used only for type merging.  */\n+  gcc_checking_assert (in_lto_p || flag_lto);\n+\n+  if (!type_with_linkage_p (t))\n+    return false;\n+\n+  /* To support -fno-lto-odr-type-merging consider types with vtables ODR.  */\n+  if (type_in_anonymous_namespace_p (t))\n+    return true;\n+\n+  if (TYPE_NAME (t) && TREE_CODE (TYPE_NAME (t)) == TYPE_DECL\n+      && DECL_ASSEMBLER_NAME_SET_P (TYPE_NAME (t)))\n+    {\n+      /* C++ FE uses magic <anon> as assembler names of anonymous types.\n+ \t verify that this match with type_in_anonymous_namespace_p.  */\n+      gcc_checking_assert (strcmp (\"<anon>\",\n+\t\t\t\t      IDENTIFIER_POINTER\n+\t\t\t\t\t(DECL_ASSEMBLER_NAME (TYPE_NAME (t)))));\n+      return true;\n+    }\n+  return false;\n+}\n+\n #endif  /* GCC_IPA_UTILS_H  */\n \n "}]}