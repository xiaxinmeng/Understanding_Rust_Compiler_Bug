{"sha": "197ddd06a0f70f89b2ffc376592d4e9318a9596a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTk3ZGRkMDZhMGY3MGY4OWIyZmZjMzc2NTkyZDRlOTMxOGE5NTk2YQ==", "commit": {"author": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2012-10-30T09:07:08Z"}, "committer": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2012-10-30T09:07:08Z"}, "message": "re PR c++/54988 (fpmath=sse target pragma causes inlining failure because of target specific option mismatch)\n\n\tPR target/54988\n\t* config/sh/sh.md (tstqi_t_zero): Rename to *tstqi_t_zero.\n\t(*tst<mode>_t_zero): New insns.\n\t* config/sh/iterators.md (lowpart_be, lowpart_le): New mode attributes.\n\n\tPR target/54988\n\t* gcc.target/sh/pr53988.c: New.\n\nFrom-SVN: r192982", "tree": {"sha": "eaa935a8ef9ba701ffd47ed7e9e919c6ac16819e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eaa935a8ef9ba701ffd47ed7e9e919c6ac16819e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/197ddd06a0f70f89b2ffc376592d4e9318a9596a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/197ddd06a0f70f89b2ffc376592d4e9318a9596a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/197ddd06a0f70f89b2ffc376592d4e9318a9596a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/197ddd06a0f70f89b2ffc376592d4e9318a9596a/comments", "author": null, "committer": null, "parents": [{"sha": "3a8ebb9268a572b1cba79373ac0fdafeef607fa4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a8ebb9268a572b1cba79373ac0fdafeef607fa4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a8ebb9268a572b1cba79373ac0fdafeef607fa4"}], "stats": {"total": 119, "additions": 117, "deletions": 2}, "files": [{"sha": "a6fcec3a2e52c09a71ffd0275f795163450985c2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/197ddd06a0f70f89b2ffc376592d4e9318a9596a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/197ddd06a0f70f89b2ffc376592d4e9318a9596a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=197ddd06a0f70f89b2ffc376592d4e9318a9596a", "patch": "@@ -1,3 +1,10 @@\n+2012-10-30  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\tPR target/54988\n+\t* config/sh/sh.md (tstqi_t_zero): Rename to *tstqi_t_zero.\n+\t(*tst<mode>_t_zero): New insns.\n+\t* config/sh/iterators.md (lowpart_be, lowpart_le): New mode attributes.\n+\n 2012-10-30  H.J. Lu  <hongjiu.lu@intel.com>\n \n \t* gimple-pretty-print.c (dump_gimple_bb_header): Avoid alloca."}, {"sha": "c68c37eed2d5f2143c39d188c72a0fd19afee594", "filename": "gcc/config/sh/iterators.md", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/197ddd06a0f70f89b2ffc376592d4e9318a9596a/gcc%2Fconfig%2Fsh%2Fiterators.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/197ddd06a0f70f89b2ffc376592d4e9318a9596a/gcc%2Fconfig%2Fsh%2Fiterators.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fiterators.md?ref=197ddd06a0f70f89b2ffc376592d4e9318a9596a", "patch": "@@ -38,3 +38,6 @@\n ;; Return codes.\n (define_code_iterator any_return [return simple_return])\n \n+;; Lowpart subreg byte position code attributes for big and little endian.\n+(define_mode_attr lowpart_be [(QI \"3\") (HI \"2\")])\n+(define_mode_attr lowpart_le [(QI \"0\") (HI \"0\")])"}, {"sha": "d9843228ff5a9c8548d4efad75ebb42ab7c221c2", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 28, "deletions": 2, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/197ddd06a0f70f89b2ffc376592d4e9318a9596a/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/197ddd06a0f70f89b2ffc376592d4e9318a9596a/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=197ddd06a0f70f89b2ffc376592d4e9318a9596a", "patch": "@@ -633,13 +633,39 @@\n ;; Test low QI subreg against zero.\n ;; This avoids unnecessary zero extension before the test.\n \n-(define_insn \"tstqi_t_zero\"\n+(define_insn \"*tstqi_t_zero\"\n   [(set (reg:SI T_REG)\n \t(eq:SI (match_operand:QI 0 \"logical_operand\" \"z\") (const_int 0)))]\n   \"TARGET_SH1\"\n   \"tst\t#255,%0\"\n   [(set_attr \"type\" \"mt_group\")])\n \n+;; This pattern might be risky because it also tests the upper bits and not\n+;; only the subreg.  However, it seems that combine will get to this only\n+;; when testing sign/zero extended values.  In this case the extended upper\n+;; bits do not matter.\n+(define_insn \"*tst<mode>_t_zero\"\n+  [(set (reg:SI T_REG)\n+\t(eq:SI\n+\t  (subreg:QIHI\n+\t    (and:SI (match_operand:SI 0 \"arith_reg_operand\" \"%r\")\n+\t\t    (match_operand:SI 1 \"arith_reg_operand\" \"r\")) <lowpart_le>)\n+\t  (const_int 0)))]\n+  \"TARGET_SH1 && TARGET_LITTLE_ENDIAN\"\n+  \"tst\t%0,%1\"\n+  [(set_attr \"type\" \"mt_group\")])\n+\n+(define_insn \"*tst<mode>_t_zero\"\n+  [(set (reg:SI T_REG)\n+\t(eq:SI\n+\t  (subreg:QIHI\n+\t    (and:SI (match_operand:SI 0 \"arith_reg_operand\" \"%r\")\n+\t\t    (match_operand:SI 1 \"arith_reg_operand\" \"r\")) <lowpart_be>)\n+\t  (const_int 0)))]\n+  \"TARGET_SH1 && !TARGET_LITTLE_ENDIAN\"\n+  \"tst\t%0,%1\"\n+  [(set_attr \"type\" \"mt_group\")])\n+\n ;; Extract LSB, negate and store in T bit.\n \n (define_insn \"tstsi_t_and_not\"\n@@ -3514,7 +3540,7 @@ label:\n   /* If it is possible to turn the and insn into a zero extension\n      already, redundant zero extensions will be folded, which results\n      in better code.  \n-     Ideally the splitter of *andsi_compact would be enough, if reundant\n+     Ideally the splitter of *andsi_compact would be enough, if redundant\n      zero extensions were detected after the combine pass, which does not\n      happen at the moment.  */\n   if (TARGET_SH1)"}, {"sha": "7acc07a7533e1d68b7181ad3ca395ee0b3794292", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/197ddd06a0f70f89b2ffc376592d4e9318a9596a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/197ddd06a0f70f89b2ffc376592d4e9318a9596a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=197ddd06a0f70f89b2ffc376592d4e9318a9596a", "patch": "@@ -1,3 +1,8 @@\n+2012-10-30  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\tPR target/54988\n+\t* gcc.target/sh/pr53988.c: New.\n+\n 2012-10-30  Bin Cheng  <bin.cheng@arm.com>\n \n \tPR target/54989"}, {"sha": "4bade1efb73f48b141c20d4ec23a102a8393ce5f", "filename": "gcc/testsuite/gcc.target/sh/pr53988.c", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/197ddd06a0f70f89b2ffc376592d4e9318a9596a/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr53988.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/197ddd06a0f70f89b2ffc376592d4e9318a9596a/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr53988.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr53988.c?ref=197ddd06a0f70f89b2ffc376592d4e9318a9596a", "patch": "@@ -0,0 +1,74 @@\n+/* Check that the tst Rm,Rn instruction is generated for QImode and HImode\n+   values loaded from memory.  If everything goes as expected we won't see\n+   any sign/zero extensions or and ops.  On SH2A we don't expect to see the\n+   movu insn.  */\n+/* { dg-do compile { target \"sh*-*-*\" } } */\n+/* { dg-options \"-O1\" } */\n+/* { dg-skip-if \"\" { \"sh*-*-*\" } { \"-m5*\"} { \"\" } }  */\n+/* { dg-final { scan-assembler-times \"tst\\tr\" 8 } } */\n+/* { dg-final { scan-assembler-not \"tst\\t#255\" } } */\n+/* { dg-final { scan-assembler-not \"exts|extu|and|movu\" } } */\n+\n+int\n+test00 (char* a, char* b, int c, int d)\n+{\n+  if (*a & *b)\n+    return c;\n+  return d;\n+}\n+\n+int\n+test01 (unsigned char* a, unsigned char* b, int c, int d)\n+{\n+  if (*a & *b)\n+    return c;\n+  return d;\n+}\n+\n+int\n+test02 (short* a, short* b, int c, int d)\n+{\n+  if (*a & *b)\n+    return c;\n+  return d;\n+}\n+\n+int\n+test03 (unsigned short* a, unsigned short* b, int c, int d)\n+{\n+  if (*a & *b)\n+    return c;\n+  return d;\n+}\n+\n+int\n+test04 (char* a, short* b, int c, int d)\n+{\n+  if (*a & *b)\n+    return c;\n+  return d;\n+}\n+\n+int\n+test05 (short* a, char* b, int c, int d)\n+{\n+  if (*a & *b)\n+    return c;\n+  return d;\n+}\n+\n+int\n+test06 (int* a, char* b, int c, int d)\n+{\n+  if (*a & *b)\n+    return c;\n+  return d;\n+}\n+\n+int\n+test07 (int* a, short* b, int c, int d)\n+{\n+  if (*a & *b)\n+    return c;\n+  return d;\n+}"}]}