{"sha": "32b1d51f16fe56b34e979fcfba4bc74dbd3592a9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzJiMWQ1MWYxNmZlNTZiMzRlOTc5ZmNmYmE0YmM3NGRiZDM1OTJhOQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2019-08-28T20:39:32Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2019-08-28T20:39:32Z"}, "message": "runtime: move osinit to Go\n    \n    This is a step toward updating libgo to 1.13.  This adds the 1.13\n    version of the osinit function to Go code, and removes the\n    corresponding code from the C runtime.  This should simplify future updates.\n    Some additional 1.13 code was brought in to simplify this change.\n    \n    Reviewed-on: https://go-review.googlesource.com/c/gofrontend/+/191717\n\nFrom-SVN: r275010", "tree": {"sha": "cd54b1786061eb18e64ce26e6392df3096b5ba35", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cd54b1786061eb18e64ce26e6392df3096b5ba35"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/32b1d51f16fe56b34e979fcfba4bc74dbd3592a9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32b1d51f16fe56b34e979fcfba4bc74dbd3592a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/32b1d51f16fe56b34e979fcfba4bc74dbd3592a9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32b1d51f16fe56b34e979fcfba4bc74dbd3592a9/comments", "author": null, "committer": null, "parents": [{"sha": "c980510a5ab79614fcbaf5f411b1273dc9a8c7ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c980510a5ab79614fcbaf5f411b1273dc9a8c7ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c980510a5ab79614fcbaf5f411b1273dc9a8c7ca"}], "stats": {"total": 1233, "additions": 494, "deletions": 739}, "files": [{"sha": "3ae07c4f6df1b060b8644af7f0fc771ef548cc62", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32b1d51f16fe56b34e979fcfba4bc74dbd3592a9/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32b1d51f16fe56b34e979fcfba4bc74dbd3592a9/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=32b1d51f16fe56b34e979fcfba4bc74dbd3592a9", "patch": "@@ -1,4 +1,4 @@\n-5d15923ada640befb236d5fe94f0c724e98e99d7\n+db738935c77443840994e5a9f77e619e67a4c43a\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "341bac021ee7f1d69ae7e946cc4ac77634bc4e66", "filename": "libgo/Makefile.am", "status": "modified", "additions": 1, "deletions": 36, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32b1d51f16fe56b34e979fcfba4bc74dbd3592a9/libgo%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32b1d51f16fe56b34e979fcfba4bc74dbd3592a9/libgo%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.am?ref=32b1d51f16fe56b34e979fcfba4bc74dbd3592a9", "patch": "@@ -413,40 +413,6 @@ else\n rtems_task_variable_add_file =\n endif\n \n-if LIBGO_IS_LINUX\n-runtime_getncpu_file = runtime/getncpu-linux.c\n-else\n-if LIBGO_IS_DARWIN\n-runtime_getncpu_file = runtime/getncpu-bsd.c\n-else\n-if LIBGO_IS_IRIX\n-runtime_getncpu_file = runtime/getncpu-irix.c\n-else\n-if LIBGO_IS_SOLARIS\n-runtime_getncpu_file = runtime/getncpu-solaris.c\n-else\n-if LIBGO_IS_FREEBSD\n-runtime_getncpu_file = runtime/getncpu-bsd.c\n-else\n-if LIBGO_IS_NETBSD\n-runtime_getncpu_file = runtime/getncpu-bsd.c\n-else\n-if LIBGO_IS_AIX\n-runtime_getncpu_file = runtime/getncpu-aix.c\n-else\n-if LIBGO_IS_HURD\n-runtime_getncpu_file = runtime/getncpu-hurd.c\n-else\n-runtime_getncpu_file = runtime/getncpu-none.c\n-endif\n-endif\n-endif\n-endif\n-endif\n-endif\n-endif\n-endif\n-\n runtime_files = \\\n \truntime/aeshash.c \\\n \truntime/go-assert.c \\\n@@ -479,8 +445,7 @@ runtime_files = \\\n \truntime/stack.c \\\n \truntime/yield.c \\\n \truntime/go-context.S \\\n-\t$(rtems_task_variable_add_file) \\\n-\t$(runtime_getncpu_file)\n+\t$(rtems_task_variable_add_file)\n \n version.go: s-version; @true\n s-version: Makefile"}, {"sha": "f415ca601167a8673e64848dcfce4f109b57b1a7", "filename": "libgo/Makefile.in", "status": "modified", "additions": 5, "deletions": 46, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32b1d51f16fe56b34e979fcfba4bc74dbd3592a9/libgo%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32b1d51f16fe56b34e979fcfba4bc74dbd3592a9/libgo%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.in?ref=32b1d51f16fe56b34e979fcfba4bc74dbd3592a9", "patch": "@@ -230,16 +230,7 @@ am__DEPENDENCIES_4 = $(am__DEPENDENCIES_2) \\\n libgo_llgo_la_DEPENDENCIES = $(am__DEPENDENCIES_4)\n @LIBGO_IS_RTEMS_TRUE@am__objects_1 =  \\\n @LIBGO_IS_RTEMS_TRUE@\truntime/rtems-task-variable-add.lo\n-@LIBGO_IS_AIX_FALSE@@LIBGO_IS_DARWIN_FALSE@@LIBGO_IS_FREEBSD_FALSE@@LIBGO_IS_HURD_FALSE@@LIBGO_IS_IRIX_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_NETBSD_FALSE@@LIBGO_IS_SOLARIS_FALSE@am__objects_2 = runtime/getncpu-none.lo\n-@LIBGO_IS_AIX_FALSE@@LIBGO_IS_DARWIN_FALSE@@LIBGO_IS_FREEBSD_FALSE@@LIBGO_IS_HURD_TRUE@@LIBGO_IS_IRIX_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_NETBSD_FALSE@@LIBGO_IS_SOLARIS_FALSE@am__objects_2 = runtime/getncpu-hurd.lo\n-@LIBGO_IS_AIX_TRUE@@LIBGO_IS_DARWIN_FALSE@@LIBGO_IS_FREEBSD_FALSE@@LIBGO_IS_IRIX_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_NETBSD_FALSE@@LIBGO_IS_SOLARIS_FALSE@am__objects_2 = runtime/getncpu-aix.lo\n-@LIBGO_IS_DARWIN_FALSE@@LIBGO_IS_FREEBSD_FALSE@@LIBGO_IS_IRIX_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_NETBSD_TRUE@@LIBGO_IS_SOLARIS_FALSE@am__objects_2 = runtime/getncpu-bsd.lo\n-@LIBGO_IS_DARWIN_FALSE@@LIBGO_IS_FREEBSD_TRUE@@LIBGO_IS_IRIX_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_SOLARIS_FALSE@am__objects_2 = runtime/getncpu-bsd.lo\n-@LIBGO_IS_DARWIN_FALSE@@LIBGO_IS_IRIX_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_SOLARIS_TRUE@am__objects_2 = runtime/getncpu-solaris.lo\n-@LIBGO_IS_DARWIN_FALSE@@LIBGO_IS_IRIX_TRUE@@LIBGO_IS_LINUX_FALSE@am__objects_2 = runtime/getncpu-irix.lo\n-@LIBGO_IS_DARWIN_TRUE@@LIBGO_IS_LINUX_FALSE@am__objects_2 = runtime/getncpu-bsd.lo\n-@LIBGO_IS_LINUX_TRUE@am__objects_2 = runtime/getncpu-linux.lo\n-am__objects_3 = runtime/aeshash.lo runtime/go-assert.lo \\\n+am__objects_2 = runtime/aeshash.lo runtime/go-assert.lo \\\n \truntime/go-caller.lo runtime/go-callers.lo runtime/go-cdiv.lo \\\n \truntime/go-cgo.lo runtime/go-construct-map.lo \\\n \truntime/go-ffi.lo runtime/go-fieldtrack.lo \\\n@@ -252,9 +243,8 @@ am__objects_3 = runtime/aeshash.lo runtime/go-assert.lo \\\n \truntime/go-unwind.lo runtime/go-varargs.lo \\\n \truntime/env_posix.lo runtime/panic.lo runtime/print.lo \\\n \truntime/proc.lo runtime/runtime_c.lo runtime/stack.lo \\\n-\truntime/yield.lo runtime/go-context.lo $(am__objects_1) \\\n-\t$(am__objects_2)\n-am_libgo_llgo_la_OBJECTS = $(am__objects_3)\n+\truntime/yield.lo runtime/go-context.lo $(am__objects_1)\n+am_libgo_llgo_la_OBJECTS = $(am__objects_2)\n libgo_llgo_la_OBJECTS = $(am_libgo_llgo_la_OBJECTS)\n AM_V_lt = $(am__v_lt_@AM_V@)\n am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)\n@@ -265,7 +255,7 @@ libgo_llgo_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \\\n \t$(libgo_llgo_la_LDFLAGS) $(LDFLAGS) -o $@\n @GOC_IS_LLGO_TRUE@am_libgo_llgo_la_rpath = -rpath $(toolexeclibdir)\n libgo_la_DEPENDENCIES = $(am__DEPENDENCIES_4)\n-am_libgo_la_OBJECTS = $(am__objects_3)\n+am_libgo_la_OBJECTS = $(am__objects_2)\n libgo_la_OBJECTS = $(am_libgo_la_OBJECTS)\n libgo_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \\\n \t$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \\\n@@ -871,15 +861,6 @@ noinst_DATA = internal/x/net/internal/nettest.gox \\\n \tzdefaultcc.go\n @LIBGO_IS_RTEMS_FALSE@rtems_task_variable_add_file = \n @LIBGO_IS_RTEMS_TRUE@rtems_task_variable_add_file = runtime/rtems-task-variable-add.c\n-@LIBGO_IS_AIX_FALSE@@LIBGO_IS_DARWIN_FALSE@@LIBGO_IS_FREEBSD_FALSE@@LIBGO_IS_HURD_FALSE@@LIBGO_IS_IRIX_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_NETBSD_FALSE@@LIBGO_IS_SOLARIS_FALSE@runtime_getncpu_file = runtime/getncpu-none.c\n-@LIBGO_IS_AIX_FALSE@@LIBGO_IS_DARWIN_FALSE@@LIBGO_IS_FREEBSD_FALSE@@LIBGO_IS_HURD_TRUE@@LIBGO_IS_IRIX_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_NETBSD_FALSE@@LIBGO_IS_SOLARIS_FALSE@runtime_getncpu_file = runtime/getncpu-hurd.c\n-@LIBGO_IS_AIX_TRUE@@LIBGO_IS_DARWIN_FALSE@@LIBGO_IS_FREEBSD_FALSE@@LIBGO_IS_IRIX_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_NETBSD_FALSE@@LIBGO_IS_SOLARIS_FALSE@runtime_getncpu_file = runtime/getncpu-aix.c\n-@LIBGO_IS_DARWIN_FALSE@@LIBGO_IS_FREEBSD_FALSE@@LIBGO_IS_IRIX_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_NETBSD_TRUE@@LIBGO_IS_SOLARIS_FALSE@runtime_getncpu_file = runtime/getncpu-bsd.c\n-@LIBGO_IS_DARWIN_FALSE@@LIBGO_IS_FREEBSD_TRUE@@LIBGO_IS_IRIX_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_SOLARIS_FALSE@runtime_getncpu_file = runtime/getncpu-bsd.c\n-@LIBGO_IS_DARWIN_FALSE@@LIBGO_IS_IRIX_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_SOLARIS_TRUE@runtime_getncpu_file = runtime/getncpu-solaris.c\n-@LIBGO_IS_DARWIN_FALSE@@LIBGO_IS_IRIX_TRUE@@LIBGO_IS_LINUX_FALSE@runtime_getncpu_file = runtime/getncpu-irix.c\n-@LIBGO_IS_DARWIN_TRUE@@LIBGO_IS_LINUX_FALSE@runtime_getncpu_file = runtime/getncpu-bsd.c\n-@LIBGO_IS_LINUX_TRUE@runtime_getncpu_file = runtime/getncpu-linux.c\n runtime_files = \\\n \truntime/aeshash.c \\\n \truntime/go-assert.c \\\n@@ -912,8 +893,7 @@ runtime_files = \\\n \truntime/stack.c \\\n \truntime/yield.c \\\n \truntime/go-context.S \\\n-\t$(rtems_task_variable_add_file) \\\n-\t$(runtime_getncpu_file)\n+\t$(rtems_task_variable_add_file)\n \n GCCGO_INSTALL_NAME := $(shell echo gccgo|sed '$(program_transform_name)')\n GCC_INSTALL_NAME := $(shell echo gcc|sed '$(program_transform_name)')\n@@ -1385,20 +1365,6 @@ runtime/go-context.lo: runtime/$(am__dirstamp) \\\n \truntime/$(DEPDIR)/$(am__dirstamp)\n runtime/rtems-task-variable-add.lo: runtime/$(am__dirstamp) \\\n \truntime/$(DEPDIR)/$(am__dirstamp)\n-runtime/getncpu-none.lo: runtime/$(am__dirstamp) \\\n-\truntime/$(DEPDIR)/$(am__dirstamp)\n-runtime/getncpu-hurd.lo: runtime/$(am__dirstamp) \\\n-\truntime/$(DEPDIR)/$(am__dirstamp)\n-runtime/getncpu-aix.lo: runtime/$(am__dirstamp) \\\n-\truntime/$(DEPDIR)/$(am__dirstamp)\n-runtime/getncpu-bsd.lo: runtime/$(am__dirstamp) \\\n-\truntime/$(DEPDIR)/$(am__dirstamp)\n-runtime/getncpu-solaris.lo: runtime/$(am__dirstamp) \\\n-\truntime/$(DEPDIR)/$(am__dirstamp)\n-runtime/getncpu-irix.lo: runtime/$(am__dirstamp) \\\n-\truntime/$(DEPDIR)/$(am__dirstamp)\n-runtime/getncpu-linux.lo: runtime/$(am__dirstamp) \\\n-\truntime/$(DEPDIR)/$(am__dirstamp)\n \n libgo-llgo.la: $(libgo_llgo_la_OBJECTS) $(libgo_llgo_la_DEPENDENCIES) $(EXTRA_libgo_llgo_la_DEPENDENCIES) \n \t$(AM_V_CCLD)$(libgo_llgo_la_LINK) $(am_libgo_llgo_la_rpath) $(libgo_llgo_la_OBJECTS) $(libgo_llgo_la_LIBADD) $(LIBS)\n@@ -1416,13 +1382,6 @@ distclean-compile:\n \n @AMDEP_TRUE@@am__include@ @am__quote@runtime/$(DEPDIR)/aeshash.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@runtime/$(DEPDIR)/env_posix.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@runtime/$(DEPDIR)/getncpu-aix.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@runtime/$(DEPDIR)/getncpu-bsd.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@runtime/$(DEPDIR)/getncpu-hurd.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@runtime/$(DEPDIR)/getncpu-irix.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@runtime/$(DEPDIR)/getncpu-linux.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@runtime/$(DEPDIR)/getncpu-none.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@runtime/$(DEPDIR)/getncpu-solaris.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@runtime/$(DEPDIR)/go-assert.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@runtime/$(DEPDIR)/go-caller.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@runtime/$(DEPDIR)/go-callers.Plo@am__quote@"}, {"sha": "68e549493507b4472ba7a144189e0d678fd4531f", "filename": "libgo/go/runtime/malloc.go", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32b1d51f16fe56b34e979fcfba4bc74dbd3592a9/libgo%2Fgo%2Fruntime%2Fmalloc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32b1d51f16fe56b34e979fcfba4bc74dbd3592a9/libgo%2Fgo%2Fruntime%2Fmalloc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmalloc.go?ref=32b1d51f16fe56b34e979fcfba4bc74dbd3592a9", "patch": "@@ -335,6 +335,23 @@ const (\n // mallocinit.\n var physPageSize uintptr\n \n+// physHugePageSize is the size in bytes of the OS's default physical huge\n+// page size whose allocation is opaque to the application. It is assumed\n+// and verified to be a power of two.\n+//\n+// If set, this must be set by the OS init code (typically in osinit) before\n+// mallocinit. However, setting it at all is optional, and leaving the default\n+// value is always safe (though potentially less efficient).\n+//\n+// Since physHugePageSize is always assumed to be a power of two,\n+// physHugePageShift is defined as physHugePageSize == 1 << physHugePageShift.\n+// The purpose of physHugePageShift is to avoid doing divisions in\n+// performance critical functions.\n+var (\n+\tphysHugePageSize  uintptr\n+\tphysHugePageShift uint\n+)\n+\n // OS-defined helpers:\n //\n // sysAlloc obtains a large chunk of zeroed memory from the"}, {"sha": "4ea3ac9f27e6940a4dd0233ba376a287b87288f2", "filename": "libgo/go/runtime/netpoll_kqueue.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32b1d51f16fe56b34e979fcfba4bc74dbd3592a9/libgo%2Fgo%2Fruntime%2Fnetpoll_kqueue.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32b1d51f16fe56b34e979fcfba4bc74dbd3592a9/libgo%2Fgo%2Fruntime%2Fnetpoll_kqueue.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fnetpoll_kqueue.go?ref=32b1d51f16fe56b34e979fcfba4bc74dbd3592a9", "patch": "@@ -20,6 +20,7 @@ func kevent(kq int32, ch *keventt, nch uintptr, ev *keventt, nev uintptr, ts *ti\n //extern __go_fcntl_uintptr\n func fcntlUintptr(fd, cmd, arg uintptr) (uintptr, uintptr)\n \n+//go:nosplit\n func closeonexec(fd int32) {\n \tfcntlUintptr(uintptr(fd), _F_SETFD, _FD_CLOEXEC)\n }"}, {"sha": "d5fbccd36e7c328aa2910f707f24a6f9e27e7db1", "filename": "libgo/go/runtime/os3_solaris.go", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32b1d51f16fe56b34e979fcfba4bc74dbd3592a9/libgo%2Fgo%2Fruntime%2Fos3_solaris.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32b1d51f16fe56b34e979fcfba4bc74dbd3592a9/libgo%2Fgo%2Fruntime%2Fos3_solaris.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fos3_solaris.go?ref=32b1d51f16fe56b34e979fcfba4bc74dbd3592a9", "patch": "@@ -12,10 +12,27 @@ var executablePath string\n func getexecname() *byte\n \n //extern getpagesize\n-func getpagesize() int32\n+func getPageSize() int32\n+\n+//extern sysconf\n+func sysconf(int32) _C_long\n+\n+func getncpu() int32 {\n+\tn := int32(sysconf(__SC_NPROCESSORS_ONLN))\n+\tif n < 1 {\n+\t\treturn 1\n+\t}\n+\treturn n\n+}\n+\n+func osinit() {\n+\tncpu = getncpu()\n+\tif physPageSize == 0 {\n+\t\tphysPageSize = uintptr(getPageSize())\n+\t}\n+}\n \n func sysargs(argc int32, argv **byte) {\n-\tphysPageSize = uintptr(getpagesize())\n \texecutablePath = gostringnocopy(getexecname())\n }\n "}, {"sha": "b337330c8f276b5441be35173265131c4cb680fb", "filename": "libgo/go/runtime/os_aix.go", "status": "modified", "additions": 35, "deletions": 1, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32b1d51f16fe56b34e979fcfba4bc74dbd3592a9/libgo%2Fgo%2Fruntime%2Fos_aix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32b1d51f16fe56b34e979fcfba4bc74dbd3592a9/libgo%2Fgo%2Fruntime%2Fos_aix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fos_aix.go?ref=32b1d51f16fe56b34e979fcfba4bc74dbd3592a9", "patch": "@@ -6,7 +6,16 @@\n \n package runtime\n \n-import \"unsafe\"\n+import (\n+\t\"internal/cpu\"\n+\t\"unsafe\"\n+)\n+\n+//extern sysconf\n+func sysconf(int32) _C_long\n+\n+//extern getsystemcfg\n+func getsystemcfg(int32) uint64\n \n type mOS struct {\n \twaitsema uintptr // semaphore for parking on locks\n@@ -106,7 +115,32 @@ func semawakeup(mp *m) {\n \t}\n }\n \n+func osinit() {\n+\tncpu = int32(sysconf(__SC_NPROCESSORS_ONLN))\n+\tphysPageSize = uintptr(sysconf(__SC_PAGE_SIZE))\n+\tsetupSystemConf()\n+}\n+\n const (\n \t_CLOCK_REALTIME  = 9\n \t_CLOCK_MONOTONIC = 10\n )\n+\n+const (\n+\t// getsystemcfg constants\n+\t_SC_IMPL     = 2\n+\t_IMPL_POWER8 = 0x10000\n+\t_IMPL_POWER9 = 0x20000\n+)\n+\n+// setupSystemConf retrieves information about the CPU and updates\n+// cpu.HWCap variables.\n+func setupSystemConf() {\n+\timpl := getsystemcfg(_SC_IMPL)\n+\tif impl&_IMPL_POWER8 != 0 {\n+\t\tcpu.HWCap2 |= cpu.PPC_FEATURE2_ARCH_2_07\n+\t}\n+\tif impl&_IMPL_POWER9 != 0 {\n+\t\tcpu.HWCap2 |= cpu.PPC_FEATURE2_ARCH_3_00\n+\t}\n+}"}, {"sha": "deaa9e9d26d77da934f0da458a0bd36deafbe2d2", "filename": "libgo/go/runtime/os_darwin.go", "status": "modified", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32b1d51f16fe56b34e979fcfba4bc74dbd3592a9/libgo%2Fgo%2Fruntime%2Fos_darwin.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32b1d51f16fe56b34e979fcfba4bc74dbd3592a9/libgo%2Fgo%2Fruntime%2Fos_darwin.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fos_darwin.go?ref=32b1d51f16fe56b34e979fcfba4bc74dbd3592a9", "patch": "@@ -6,6 +6,24 @@ package runtime\n \n import \"unsafe\"\n \n+//extern pipe\n+func libcPipe([2]int32) int32\n+\n+func pipe() (r, w int32, e int32) {\n+\tvar p [2]int32\n+\tr := libcPipe(noescape(unsafe.Pointer(&p)))\n+\tif r < 0 {\n+\t\te = int32(errno())\n+\t}\n+\treturn p[0], p[1], e\n+}\n+\n+//go:nosplit\n+func setNonblock(fd int32) {\n+\tflags := fcntlUintptr(uintptr(fd), _F_GETFL, 0)\n+\tfcntlUintptr(uintptr(fd), _F_SETFL, flags|_O_NONBLOCK)\n+}\n+\n type mOS struct {\n \tinitialized bool\n \tmutex       pthreadmutex\n@@ -74,3 +92,58 @@ func semawakeup(mp *m) {\n \t}\n \tpthread_mutex_unlock(&mp.mutex)\n }\n+\n+// The read and write file descriptors used by the sigNote functions.\n+var sigNoteRead, sigNoteWrite int32\n+\n+// sigNoteSetup initializes an async-signal-safe note.\n+//\n+// The current implementation of notes on Darwin is not async-signal-safe,\n+// because the functions pthread_mutex_lock, pthread_cond_signal, and\n+// pthread_mutex_unlock, called by semawakeup, are not async-signal-safe.\n+// There is only one case where we need to wake up a note from a signal\n+// handler: the sigsend function. The signal handler code does not require\n+// all the features of notes: it does not need to do a timed wait.\n+// This is a separate implementation of notes, based on a pipe, that does\n+// not support timed waits but is async-signal-safe.\n+func sigNoteSetup(*note) {\n+\tif sigNoteRead != 0 || sigNoteWrite != 0 {\n+\t\tthrow(\"duplicate sigNoteSetup\")\n+\t}\n+\tvar errno int32\n+\tsigNoteRead, sigNoteWrite, errno = pipe()\n+\tif errno != 0 {\n+\t\tthrow(\"pipe failed\")\n+\t}\n+\tcloseonexec(sigNoteRead)\n+\tcloseonexec(sigNoteWrite)\n+\n+\t// Make the write end of the pipe non-blocking, so that if the pipe\n+\t// buffer is somehow full we will not block in the signal handler.\n+\t// Leave the read end of the pipe blocking so that we will block\n+\t// in sigNoteSleep.\n+\tsetNonblock(sigNoteWrite)\n+}\n+\n+// sigNoteWakeup wakes up a thread sleeping on a note created by sigNoteSetup.\n+func sigNoteWakeup(*note) {\n+\tvar b byte\n+\twrite(uintptr(sigNoteWrite), unsafe.Pointer(&b), 1)\n+}\n+\n+// sigNoteSleep waits for a note created by sigNoteSetup to be woken.\n+func sigNoteSleep(*note) {\n+\tentersyscallblock()\n+\tvar b byte\n+\tread(sigNoteRead, unsafe.Pointer(&b), 1)\n+\texitsyscall()\n+}\n+\n+// BSD interface for threading.\n+func osinit() {\n+\t// pthread_create delayed until end of goenvs so that we\n+\t// can look at the environment first.\n+\n+\tncpu = getncpu()\n+\tphysPageSize = getPageSize()\n+}"}, {"sha": "d214f7f537b7bd6be168ec924bbdc2cd8c3d20ab", "filename": "libgo/go/runtime/os_dragonfly.go", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32b1d51f16fe56b34e979fcfba4bc74dbd3592a9/libgo%2Fgo%2Fruntime%2Fos_dragonfly.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32b1d51f16fe56b34e979fcfba4bc74dbd3592a9/libgo%2Fgo%2Fruntime%2Fos_dragonfly.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fos_dragonfly.go?ref=32b1d51f16fe56b34e979fcfba4bc74dbd3592a9", "patch": "@@ -19,6 +19,32 @@ func sys_umtx_sleep(addr *uint32, val, timeout int32) int32\n //extern umtx_wakeup\n func sys_umtx_wakeup(addr *uint32, val int32) int32\n \n+//go:noescape\n+//extern sysctl\n+func sysctl(*uint32, uint32, *byte, *uintptr, *byte, uintptr) int32\n+\n+func getncpu() int32 {\n+\tmib := [2]uint32{_CTL_HW, _HW_NCPU}\n+\tout := uint32(0)\n+\tnout := uintptr(unsafe.Sizeof(out))\n+\tret := sysctl(&mib[0], 2, (*byte)(unsafe.Pointer(&out)), &nout, nil, 0)\n+\tif ret >= 0 {\n+\t\treturn int32(out)\n+\t}\n+\treturn 1\n+}\n+\n+func getPageSize() uintptr {\n+\tmib := [2]uint32{_CTL_HW, _HW_PAGESIZE}\n+\tout := uint32(0)\n+\tnout := uintptr(unsafe.Sizeof(out))\n+\tret := sysctl(&mib[0], 2, (*byte)(unsafe.Pointer(&out)), &nout, nil, 0)\n+\tif ret >= 0 {\n+\t\treturn uintptr(out)\n+\t}\n+\treturn 0\n+}\n+\n //go:nosplit\n func futexsleep(addr *uint32, val uint32, ns int64) {\n \tsystemstack(func() {\n@@ -61,3 +87,10 @@ func futexwakeup(addr *uint32, cnt uint32) {\n \t\t*(*int32)(unsafe.Pointer(uintptr(0x1006))) = 0x1006\n \t})\n }\n+\n+func osinit() {\n+\tncpu = getncpu()\n+\tif physPageSize == 0 {\n+\t\tphysPageSize = getPageSize()\n+\t}\n+}"}, {"sha": "f8577e4226ec2b706b8c6eed9d50920712389cd2", "filename": "libgo/go/runtime/os_freebsd.go", "status": "modified", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32b1d51f16fe56b34e979fcfba4bc74dbd3592a9/libgo%2Fgo%2Fruntime%2Fos_freebsd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32b1d51f16fe56b34e979fcfba4bc74dbd3592a9/libgo%2Fgo%2Fruntime%2Fos_freebsd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fos_freebsd.go?ref=32b1d51f16fe56b34e979fcfba4bc74dbd3592a9", "patch": "@@ -14,6 +14,104 @@ type mOS struct{}\n //extern _umtx_op\n func sys_umtx_op(addr *uint32, mode int32, val uint32, uaddr1 uinptr, ts *umtx_time) int32\n \n+//go:noescape\n+//extern sysctl\n+func sysctl(*uint32, uint32, *byte, *uintptr, *byte, uintptr) int32\n+\n+const (\n+\t_CTL_MAXNAME     = 24\n+\t_CPU_LEVEL_WHICH = 3\n+\t_CPU_WHICH_PID   = 2\n+)\n+\n+// From FreeBSD's <sys/sysctl.h>\n+const (\n+\t_CTL_HW      = 6\n+\t_HW_PAGESIZE = 7\n+)\n+\n+// Undocumented numbers from FreeBSD's lib/libc/gen/sysctlnametomib.c.\n+const (\n+\t_CTL_QUERY     = 0\n+\t_CTL_QUERY_MIB = 3\n+)\n+\n+// sysctlnametomib fill mib with dynamically assigned sysctl entries of name,\n+// return count of effected mib slots, return 0 on error.\n+func sysctlnametomib(name []byte, mib *[_CTL_MAXNAME]uint32) uint32 {\n+\toid := [2]uint32{_CTL_QUERY, _CTL_QUERY_MIB}\n+\tmiblen := uintptr(_CTL_MAXNAME)\n+\tif sysctl(&oid[0], 2, (*byte)(unsafe.Pointer(mib)), &miblen, (*byte)(unsafe.Pointer(&name[0])), (uintptr)(len(name))) < 0 {\n+\t\treturn 0\n+\t}\n+\tmiblen /= unsafe.Sizeof(uint32(0))\n+\tif miblen <= 0 {\n+\t\treturn 0\n+\t}\n+\treturn uint32(miblen)\n+}\n+\n+const (\n+\t_CPU_CURRENT_PID = -1 // Current process ID.\n+)\n+\n+//go:noescape\n+//extern cpuset_getaffinity\n+func cpuset_getaffinity(level int32, which int32, id int64, size uintptr, mask *byte) int32\n+\n+//go:systemstack\n+func getncpu() int32 {\n+\t// Use a large buffer for the CPU mask. We're on the system\n+\t// stack, so this is fine, and we can't allocate memory for a\n+\t// dynamically-sized buffer at this point.\n+\tconst maxCPUs = 64 * 1024\n+\tvar mask [maxCPUs / 8]byte\n+\tvar mib [_CTL_MAXNAME]uint32\n+\n+\t// According to FreeBSD's /usr/src/sys/kern/kern_cpuset.c,\n+\t// cpuset_getaffinity return ERANGE when provided buffer size exceed the limits in kernel.\n+\t// Querying kern.smp.maxcpus to calculate maximum buffer size.\n+\t// See https://bugs.freebsd.org/bugzilla/show_bug.cgi?id=200802\n+\n+\t// Variable kern.smp.maxcpus introduced at Dec 23 2003, revision 123766,\n+\t// with dynamically assigned sysctl entries.\n+\tmiblen := sysctlnametomib([]byte(\"kern.smp.maxcpus\"), &mib)\n+\tif miblen == 0 {\n+\t\treturn 1\n+\t}\n+\n+\t// Query kern.smp.maxcpus.\n+\tdstsize := uintptr(4)\n+\tmaxcpus := uint32(0)\n+\tif sysctl(&mib[0], miblen, (*byte)(unsafe.Pointer(&maxcpus)), &dstsize, nil, 0) != 0 {\n+\t\treturn 1\n+\t}\n+\n+\tmaskSize := uintptr(int(maxcpus+7) / 8)\n+\tif maskSize < sys.PtrSize {\n+\t\tmaskSize = sys.PtrSize\n+\t}\n+\tif maskSize > uintptr(len(mask)) {\n+\t\tmaskSize = uintptr(len(mask))\n+\t}\n+\n+\tif cpuset_getaffinity(_CPU_LEVEL_WHICH, _CPU_WHICH_PID, _CPU_CURRENT_PID,\n+\t\tmaskSize, (*byte)(unsafe.Pointer(&mask[0]))) != 0 {\n+\t\treturn 1\n+\t}\n+\tn := int32(0)\n+\tfor _, v := range mask[:maskSize] {\n+\t\tfor v != 0 {\n+\t\t\tn += int32(v & 1)\n+\t\t\tv >>= 1\n+\t\t}\n+\t}\n+\tif n == 0 {\n+\t\treturn 1\n+\t}\n+\treturn n\n+}\n+\n func getPageSize() uintptr {\n \tmib := [2]uint32{_CTL_HW, _HW_PAGESIZE}\n \tout := uint32(0)\n@@ -64,6 +162,13 @@ func futexwakeup(addr *uint32, cnt uint32) {\n \t})\n }\n \n+func osinit() {\n+\tncpu = getncpu()\n+\tif physPageSize == 0 {\n+\t\tphysPageSize = getPageSize()\n+\t}\n+}\n+\n func sysargs(argc int32, argv **byte) {\n \tn := argc + 1\n "}, {"sha": "3a545d0768d4ce5e573b5f03b0f490ed6cda768a", "filename": "libgo/go/runtime/os_hurd.go", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32b1d51f16fe56b34e979fcfba4bc74dbd3592a9/libgo%2Fgo%2Fruntime%2Fos_hurd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32b1d51f16fe56b34e979fcfba4bc74dbd3592a9/libgo%2Fgo%2Fruntime%2Fos_hurd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fos_hurd.go?ref=32b1d51f16fe56b34e979fcfba4bc74dbd3592a9", "patch": "@@ -8,6 +8,12 @@ package runtime\n \n import \"unsafe\"\n \n+//extern sysconf\n+func sysconf(int32) _C_long\n+\n+//extern getpagesize\n+func getPageSize() int32\n+\n type mOS struct {\n \twaitsema uintptr // semaphore for parking on locks\n }\n@@ -85,3 +91,18 @@ func semawakeup(mp *m) {\n \t\tthrow(\"sem_post\")\n \t}\n }\n+\n+func getncpu() int32 {\n+\tn := int32(sysconf(_SC_NPROCESSORS_ONLN))\n+\tif n < 1 {\n+\t\treturn 1\n+\t}\n+\treturn n\n+}\n+\n+func osinit() {\n+\tncpu = getncpu()\n+\tif physPageSize == 0 {\n+\t\tphysPageSize = uintptr(getPageSize())\n+\t}\n+}"}, {"sha": "b72872f182238403bf43e97d88703268dc5f9034", "filename": "libgo/go/runtime/os_linux.go", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32b1d51f16fe56b34e979fcfba4bc74dbd3592a9/libgo%2Fgo%2Fruntime%2Fos_linux.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32b1d51f16fe56b34e979fcfba4bc74dbd3592a9/libgo%2Fgo%2Fruntime%2Fos_linux.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fos_linux.go?ref=32b1d51f16fe56b34e979fcfba4bc74dbd3592a9", "patch": "@@ -17,6 +17,12 @@ func futex(addr unsafe.Pointer, op int32, val uint32, ts, addr2 unsafe.Pointer,\n \treturn int32(syscall(_SYS_futex, uintptr(addr), uintptr(op), uintptr(val), uintptr(ts), uintptr(addr2), uintptr(val3)))\n }\n \n+// For sched_getaffinity use the system call rather than the libc call,\n+// because the system call returns the number of entries set by the kernel.\n+func sched_getaffinity(pid _pid_t, cpusetsize uintptr, mask *byte) int32 {\n+\treturn int32(syscall(_SYS_sched_getaffinity, uintptr(pid), cpusetsize, uintptr(unsafe.Pointer(mask)), 0, 0, 0))\n+}\n+\n // Linux futex.\n //\n //\tfutexsleep(uint32 *addr, uint32 val)\n@@ -84,6 +90,33 @@ func futexwakeup(addr *uint32, cnt uint32) {\n \t*(*int32)(unsafe.Pointer(uintptr(0x1006))) = 0x1006\n }\n \n+func getproccount() int32 {\n+\t// This buffer is huge (8 kB) but we are on the system stack\n+\t// and there should be plenty of space (64 kB).\n+\t// Also this is a leaf, so we're not holding up the memory for long.\n+\t// See golang.org/issue/11823.\n+\t// The suggested behavior here is to keep trying with ever-larger\n+\t// buffers, but we don't have a dynamic memory allocator at the\n+\t// moment, so that's a bit tricky and seems like overkill.\n+\tconst maxCPUs = 64 * 1024\n+\tvar buf [maxCPUs / 8]byte\n+\tr := sched_getaffinity(0, unsafe.Sizeof(buf), &buf[0])\n+\tif r < 0 {\n+\t\treturn 1\n+\t}\n+\tn := int32(0)\n+\tfor _, v := range buf[:r] {\n+\t\tfor v != 0 {\n+\t\t\tn += int32(v & 1)\n+\t\t\tv >>= 1\n+\t\t}\n+\t}\n+\tif n == 0 {\n+\t\tn = 1\n+\t}\n+\treturn n\n+}\n+\n const (\n \t_AT_NULL   = 0  // End of vector\n \t_AT_PAGESZ = 6  // System physical page size\n@@ -178,3 +211,33 @@ func sysauxv(auxv []uintptr) int {\n \t}\n \treturn i / 2\n }\n+\n+var sysTHPSizePath = []byte(\"/sys/kernel/mm/transparent_hugepage/hpage_pmd_size\\x00\")\n+\n+func getHugePageSize() uintptr {\n+\tvar numbuf [20]byte\n+\tfd := open(&sysTHPSizePath[0], 0 /* O_RDONLY */, 0)\n+\tif fd < 0 {\n+\t\treturn 0\n+\t}\n+\tn := read(fd, noescape(unsafe.Pointer(&numbuf[0])), int32(len(numbuf)))\n+\tclosefd(fd)\n+\tif n <= 0 {\n+\t\treturn 0\n+\t}\n+\tl := n - 1 // remove trailing newline\n+\tv, ok := atoi(slicebytetostringtmp(numbuf[:l]))\n+\tif !ok || v < 0 {\n+\t\tv = 0\n+\t}\n+\tif v&(v-1) != 0 {\n+\t\t// v is not a power of 2\n+\t\treturn 0\n+\t}\n+\treturn uintptr(v)\n+}\n+\n+func osinit() {\n+\tncpu = getproccount()\n+\tphysHugePageSize = getHugePageSize()\n+}"}, {"sha": "b7aa9535df3f349a36b27fcd2a9d2a6d009c7f1e", "filename": "libgo/go/runtime/os_netbsd.go", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32b1d51f16fe56b34e979fcfba4bc74dbd3592a9/libgo%2Fgo%2Fruntime%2Fos_netbsd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32b1d51f16fe56b34e979fcfba4bc74dbd3592a9/libgo%2Fgo%2Fruntime%2Fos_netbsd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fos_netbsd.go?ref=32b1d51f16fe56b34e979fcfba4bc74dbd3592a9", "patch": "@@ -22,6 +22,39 @@ func lwp_park(ts int32, rel int32, abstime *timespec, unpark int32, hint, unpark\n //extern lwp_unpark\n func lwp_unpark(lwp int32, hint unsafe.Pointer) int32\n \n+//go:noescape\n+//extern sysctl\n+func sysctl(*uint32, uint32, *byte, *uintptr, *byte, uintptr) int32\n+\n+// From NetBSD's <sys/sysctl.h>\n+const (\n+\t_CTL_HW      = 6\n+\t_HW_NCPU     = 3\n+\t_HW_PAGESIZE = 7\n+)\n+\n+func getncpu() int32 {\n+\tmib := [2]uint32{_CTL_HW, _HW_NCPU}\n+\tout := uint32(0)\n+\tnout := unsafe.Sizeof(out)\n+\tret := sysctl(&mib[0], 2, (*byte)(unsafe.Pointer(&out)), &nout, nil, 0)\n+\tif ret >= 0 {\n+\t\treturn int32(out)\n+\t}\n+\treturn 1\n+}\n+\n+func getPageSize() uintptr {\n+\tmib := [2]uint32{_CTL_HW, _HW_PAGESIZE}\n+\tout := uint32(0)\n+\tnout := unsafe.Sizeof(out)\n+\tret := sysctl(&mib[0], 2, (*byte)(unsafe.Pointer(&out)), &nout, nil, 0)\n+\tif ret >= 0 {\n+\t\treturn uintptr(out)\n+\t}\n+\treturn 0\n+}\n+\n //go:nosplit\n func semacreate(mp *m) {\n }\n@@ -77,3 +110,10 @@ func semawakeup(mp *m) {\n \t\t})\n \t}\n }\n+\n+func osinit() {\n+\tncpu = getncpu()\n+\tif physPageSize == 0 {\n+\t\tphysPageSize = getPageSize()\n+\t}\n+}"}, {"sha": "4298172b0546f8d10343d820f10f07dee8dfddde", "filename": "libgo/go/runtime/os_openbsd.go", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32b1d51f16fe56b34e979fcfba4bc74dbd3592a9/libgo%2Fgo%2Fruntime%2Fos_openbsd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32b1d51f16fe56b34e979fcfba4bc74dbd3592a9/libgo%2Fgo%2Fruntime%2Fos_openbsd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fos_openbsd.go?ref=32b1d51f16fe56b34e979fcfba4bc74dbd3592a9", "patch": "@@ -22,6 +22,58 @@ func thrsleep(ident uintptr, clock_id int32, tsp *timespec, lock uintptr, abort\n //extern thrwakeup\n func thrwakeup(ident uintptr, n int32) int32\n \n+//go:noescape\n+//extern sysctl\n+func sysctl(*uint32, uint32, *byte, *uintptr, *byte, uintptr) int32\n+\n+// From OpenBSD's <sys/sysctl.h>\n+const (\n+\t_CTL_KERN   = 1\n+\t_KERN_OSREV = 3\n+\n+\t_CTL_HW        = 6\n+\t_HW_NCPU       = 3\n+\t_HW_PAGESIZE   = 7\n+\t_HW_NCPUONLINE = 25\n+)\n+\n+func sysctlInt(mib []uint32) (int32, bool) {\n+\tvar out int32\n+\tnout := unsafe.Sizeof(out)\n+\tret := sysctl(&mib[0], uint32(len(mib)), (*byte)(unsafe.Pointer(&out)), &nout, nil, 0)\n+\tif ret < 0 {\n+\t\treturn 0, false\n+\t}\n+\treturn out, true\n+}\n+\n+func getncpu() int32 {\n+\t// Try hw.ncpuonline first because hw.ncpu would report a number twice as\n+\t// high as the actual CPUs running on OpenBSD 6.4 with hyperthreading\n+\t// disabled (hw.smt=0). See https://golang.org/issue/30127\n+\tif n, ok := sysctlInt([]uint32{_CTL_HW, _HW_NCPUONLINE}); ok {\n+\t\treturn int32(n)\n+\t}\n+\tif n, ok := sysctlInt([]uint32{_CTL_HW, _HW_NCPU}); ok {\n+\t\treturn int32(n)\n+\t}\n+\treturn 1\n+}\n+\n+func getPageSize() uintptr {\n+\tif ps, ok := sysctlInt([]uint32{_CTL_HW, _HW_PAGESIZE}); ok {\n+\t\treturn uintptr(ps)\n+\t}\n+\treturn 0\n+}\n+\n+func getOSRev() int {\n+\tif osrev, ok := sysctlInt([]uint32{_CTL_KERN, _KERN_OSREV}); ok {\n+\t\treturn int(osrev)\n+\t}\n+\treturn 0\n+}\n+\n //go:nosplit\n func semacreate(mp *m) {\n }\n@@ -75,3 +127,11 @@ func semawakeup(mp *m) {\n \t\t})\n \t}\n }\n+\n+func osinit() {\n+\tncpu = getncpu()\n+\tphysPageSize = getPageSize()\n+\thaveMapStack = getOSRev() >= 201805 // OpenBSD 6.3\n+}\n+\n+var haveMapStack = false"}, {"sha": "a81bf92ad4f91f1d6daf6a807f96b6b107097b15", "filename": "libgo/go/runtime/stubs.go", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32b1d51f16fe56b34e979fcfba4bc74dbd3592a9/libgo%2Fgo%2Fruntime%2Fstubs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32b1d51f16fe56b34e979fcfba4bc74dbd3592a9/libgo%2Fgo%2Fruntime%2Fstubs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fstubs.go?ref=32b1d51f16fe56b34e979fcfba4bc74dbd3592a9", "patch": "@@ -333,20 +333,6 @@ func rethrowException()\n // used by the stack unwinder.\n func unwindExceptionSize() uintptr\n \n-// Called by C code to set the number of CPUs.\n-//go:linkname setncpu runtime.setncpu\n-func setncpu(n int32) {\n-\tncpu = n\n-}\n-\n-// Called by C code to set the page size.\n-//go:linkname setpagesize runtime.setpagesize\n-func setpagesize(s uintptr) {\n-\tif physPageSize == 0 {\n-\t\tphysPageSize = s\n-\t}\n-}\n-\n const uintptrMask = 1<<(8*sys.PtrSize) - 1\n \n type bitvector struct {"}, {"sha": "dcbbffa9180fa7a47be7be2977425e206fe3cd76", "filename": "libgo/go/runtime/stubs2.go", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32b1d51f16fe56b34e979fcfba4bc74dbd3592a9/libgo%2Fgo%2Fruntime%2Fstubs2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32b1d51f16fe56b34e979fcfba4bc74dbd3592a9/libgo%2Fgo%2Fruntime%2Fstubs2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fstubs2.go?ref=32b1d51f16fe56b34e979fcfba4bc74dbd3592a9", "patch": "@@ -6,7 +6,6 @@\n // +build !windows\n // +build !nacl\n // +build !js\n-// +build !darwin\n \n package runtime\n \n@@ -32,3 +31,6 @@ func exitThread(wait *uint32) {\n \t// This is never used by gccgo.\n \tthrow(\"exitThread\")\n }\n+\n+// So that the C initialization code can call osinit.\n+//go:linkname osinit runtime.osinit"}, {"sha": "f34ac88352465dad554f4911883361fb3ce4882c", "filename": "libgo/go/runtime/sys_darwin.go", "status": "removed", "additions": 0, "deletions": 429, "changes": 429, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c980510a5ab79614fcbaf5f411b1273dc9a8c7ca/libgo%2Fgo%2Fruntime%2Fsys_darwin.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c980510a5ab79614fcbaf5f411b1273dc9a8c7ca/libgo%2Fgo%2Fruntime%2Fsys_darwin.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fsys_darwin.go?ref=c980510a5ab79614fcbaf5f411b1273dc9a8c7ca", "patch": "@@ -1,429 +0,0 @@\n-// Copyright 2018 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package runtime\n-\n-import \"unsafe\"\n-\n-// Call fn with arg as its argument. Return what fn returns.\n-// fn is the raw pc value of the entry point of the desired function.\n-// Switches to the system stack, if not already there.\n-// Preserves the calling point as the location where a profiler traceback will begin.\n-//go:nosplit\n-func libcCall(fn, arg unsafe.Pointer) int32 {\n-\t// Leave caller's PC/SP/G around for traceback.\n-\tgp := getg()\n-\tvar mp *m\n-\tif gp != nil {\n-\t\tmp = gp.m\n-\t}\n-\tif mp != nil && mp.libcallsp == 0 {\n-\t\tmp.libcallg.set(gp)\n-\t\tmp.libcallpc = getcallerpc()\n-\t\t// sp must be the last, because once async cpu profiler finds\n-\t\t// all three values to be non-zero, it will use them\n-\t\tmp.libcallsp = getcallersp()\n-\t} else {\n-\t\t// Make sure we don't reset libcallsp. This makes\n-\t\t// libcCall reentrant; We remember the g/pc/sp for the\n-\t\t// first call on an M, until that libcCall instance\n-\t\t// returns.  Reentrance only matters for signals, as\n-\t\t// libc never calls back into Go.  The tricky case is\n-\t\t// where we call libcX from an M and record g/pc/sp.\n-\t\t// Before that call returns, a signal arrives on the\n-\t\t// same M and the signal handling code calls another\n-\t\t// libc function.  We don't want that second libcCall\n-\t\t// from within the handler to be recorded, and we\n-\t\t// don't want that call's completion to zero\n-\t\t// libcallsp.\n-\t\t// We don't need to set libcall* while we're in a sighandler\n-\t\t// (even if we're not currently in libc) because we block all\n-\t\t// signals while we're handling a signal. That includes the\n-\t\t// profile signal, which is the one that uses the libcall* info.\n-\t\tmp = nil\n-\t}\n-\tres := asmcgocall(fn, arg)\n-\tif mp != nil {\n-\t\tmp.libcallsp = 0\n-\t}\n-\treturn res\n-}\n-\n-// The X versions of syscall expect the libc call to return a 64-bit result.\n-// Otherwise (the non-X version) expects a 32-bit result.\n-// This distinction is required because an error is indicated by returning -1,\n-// and we need to know whether to check 32 or 64 bits of the result.\n-// (Some libc functions that return 32 bits put junk in the upper 32 bits of AX.)\n-\n-//go:linkname syscall_syscall syscall.syscall\n-//go:nosplit\n-//go:cgo_unsafe_args\n-func syscall_syscall(fn, a1, a2, a3 uintptr) (r1, r2, err uintptr) {\n-\tentersyscallblock()\n-\tlibcCall(unsafe.Pointer(funcPC(syscall)), unsafe.Pointer(&fn))\n-\texitsyscall()\n-\treturn\n-}\n-func syscall()\n-\n-//go:linkname syscall_syscall6 syscall.syscall6\n-//go:nosplit\n-//go:cgo_unsafe_args\n-func syscall_syscall6(fn, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2, err uintptr) {\n-\tentersyscallblock()\n-\tlibcCall(unsafe.Pointer(funcPC(syscall6)), unsafe.Pointer(&fn))\n-\texitsyscall()\n-\treturn\n-}\n-func syscall6()\n-\n-//go:linkname syscall_syscall6X syscall.syscall6X\n-//go:nosplit\n-//go:cgo_unsafe_args\n-func syscall_syscall6X(fn, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2, err uintptr) {\n-\tentersyscallblock()\n-\tlibcCall(unsafe.Pointer(funcPC(syscall6X)), unsafe.Pointer(&fn))\n-\texitsyscall()\n-\treturn\n-}\n-func syscall6X()\n-\n-//go:linkname syscall_rawSyscall syscall.rawSyscall\n-//go:nosplit\n-//go:cgo_unsafe_args\n-func syscall_rawSyscall(fn, a1, a2, a3 uintptr) (r1, r2, err uintptr) {\n-\tlibcCall(unsafe.Pointer(funcPC(syscall)), unsafe.Pointer(&fn))\n-\treturn\n-}\n-\n-//go:linkname syscall_rawSyscall6 syscall.rawSyscall6\n-//go:nosplit\n-//go:cgo_unsafe_args\n-func syscall_rawSyscall6(fn, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2, err uintptr) {\n-\tlibcCall(unsafe.Pointer(funcPC(syscall6)), unsafe.Pointer(&fn))\n-\treturn\n-}\n-\n-// The *_trampoline functions convert from the Go calling convention to the C calling convention\n-// and then call the underlying libc function.  They are defined in sys_darwin_$ARCH.s.\n-\n-//go:nosplit\n-//go:cgo_unsafe_args\n-func pthread_attr_init(attr *pthreadattr) int32 {\n-\treturn libcCall(unsafe.Pointer(funcPC(pthread_attr_init_trampoline)), unsafe.Pointer(&attr))\n-}\n-func pthread_attr_init_trampoline()\n-\n-//go:nosplit\n-//go:cgo_unsafe_args\n-func pthread_attr_setstacksize(attr *pthreadattr, size uintptr) int32 {\n-\treturn libcCall(unsafe.Pointer(funcPC(pthread_attr_setstacksize_trampoline)), unsafe.Pointer(&attr))\n-}\n-func pthread_attr_setstacksize_trampoline()\n-\n-//go:nosplit\n-//go:cgo_unsafe_args\n-func pthread_attr_setdetachstate(attr *pthreadattr, state int) int32 {\n-\treturn libcCall(unsafe.Pointer(funcPC(pthread_attr_setdetachstate_trampoline)), unsafe.Pointer(&attr))\n-}\n-func pthread_attr_setdetachstate_trampoline()\n-\n-//go:nosplit\n-//go:cgo_unsafe_args\n-func pthread_create(attr *pthreadattr, start uintptr, arg unsafe.Pointer) int32 {\n-\treturn libcCall(unsafe.Pointer(funcPC(pthread_create_trampoline)), unsafe.Pointer(&attr))\n-}\n-func pthread_create_trampoline()\n-\n-//go:nosplit\n-//go:cgo_unsafe_args\n-func raise(sig uint32) {\n-\tlibcCall(unsafe.Pointer(funcPC(raise_trampoline)), unsafe.Pointer(&sig))\n-}\n-func raise_trampoline()\n-\n-//go:nosplit\n-//go:cgo_unsafe_args\n-func pthread_self() (t pthread) {\n-\tlibcCall(unsafe.Pointer(funcPC(pthread_self_trampoline)), unsafe.Pointer(&t))\n-\treturn\n-}\n-func pthread_self_trampoline()\n-\n-func mmap(addr unsafe.Pointer, n uintptr, prot, flags, fd int32, off uint32) (unsafe.Pointer, int) {\n-\targs := struct {\n-\t\taddr            unsafe.Pointer\n-\t\tn               uintptr\n-\t\tprot, flags, fd int32\n-\t\toff             uint32\n-\t\tret1            unsafe.Pointer\n-\t\tret2            int\n-\t}{addr, n, prot, flags, fd, off, nil, 0}\n-\tlibcCall(unsafe.Pointer(funcPC(mmap_trampoline)), unsafe.Pointer(&args))\n-\treturn args.ret1, args.ret2\n-}\n-func mmap_trampoline()\n-\n-//go:nosplit\n-//go:cgo_unsafe_args\n-func munmap(addr unsafe.Pointer, n uintptr) {\n-\tlibcCall(unsafe.Pointer(funcPC(munmap_trampoline)), unsafe.Pointer(&addr))\n-}\n-func munmap_trampoline()\n-\n-//go:nosplit\n-//go:cgo_unsafe_args\n-func madvise(addr unsafe.Pointer, n uintptr, flags int32) {\n-\tlibcCall(unsafe.Pointer(funcPC(madvise_trampoline)), unsafe.Pointer(&addr))\n-}\n-func madvise_trampoline()\n-\n-//go:nosplit\n-//go:cgo_unsafe_args\n-func read(fd int32, p unsafe.Pointer, n int32) int32 {\n-\treturn libcCall(unsafe.Pointer(funcPC(read_trampoline)), unsafe.Pointer(&fd))\n-}\n-func read_trampoline()\n-\n-//go:nosplit\n-//go:cgo_unsafe_args\n-func closefd(fd int32) int32 {\n-\treturn libcCall(unsafe.Pointer(funcPC(close_trampoline)), unsafe.Pointer(&fd))\n-}\n-func close_trampoline()\n-\n-//go:nosplit\n-//go:cgo_unsafe_args\n-func exit(code int32) {\n-\tlibcCall(unsafe.Pointer(funcPC(exit_trampoline)), unsafe.Pointer(&code))\n-}\n-func exit_trampoline()\n-\n-//go:nosplit\n-//go:cgo_unsafe_args\n-func usleep(usec uint32) {\n-\tlibcCall(unsafe.Pointer(funcPC(usleep_trampoline)), unsafe.Pointer(&usec))\n-}\n-func usleep_trampoline()\n-\n-//go:nosplit\n-//go:cgo_unsafe_args\n-func write(fd uintptr, p unsafe.Pointer, n int32) int32 {\n-\treturn libcCall(unsafe.Pointer(funcPC(write_trampoline)), unsafe.Pointer(&fd))\n-}\n-func write_trampoline()\n-\n-//go:nosplit\n-//go:cgo_unsafe_args\n-func open(name *byte, mode, perm int32) (ret int32) {\n-\treturn libcCall(unsafe.Pointer(funcPC(open_trampoline)), unsafe.Pointer(&name))\n-}\n-func open_trampoline()\n-\n-//go:nosplit\n-//go:cgo_unsafe_args\n-func nanotime() int64 {\n-\tvar r struct {\n-\t\tt            int64  // raw timer\n-\t\tnumer, denom uint32 // conversion factors. nanoseconds = t * numer / denom.\n-\t}\n-\tlibcCall(unsafe.Pointer(funcPC(nanotime_trampoline)), unsafe.Pointer(&r))\n-\t// Note: Apple seems unconcerned about overflow here. See\n-\t// https://developer.apple.com/library/content/qa/qa1398/_index.html\n-\t// Note also, numer == denom == 1 is common.\n-\tt := r.t\n-\tif r.numer != 1 {\n-\t\tt *= int64(r.numer)\n-\t}\n-\tif r.denom != 1 {\n-\t\tt /= int64(r.denom)\n-\t}\n-\treturn t\n-}\n-func nanotime_trampoline()\n-\n-//go:nosplit\n-//go:cgo_unsafe_args\n-func walltime() (int64, int32) {\n-\tvar t timeval\n-\tlibcCall(unsafe.Pointer(funcPC(walltime_trampoline)), unsafe.Pointer(&t))\n-\treturn int64(t.tv_sec), 1000 * t.tv_usec\n-}\n-func walltime_trampoline()\n-\n-//go:nosplit\n-//go:cgo_unsafe_args\n-func sigaction(sig uint32, new *usigactiont, old *usigactiont) {\n-\tlibcCall(unsafe.Pointer(funcPC(sigaction_trampoline)), unsafe.Pointer(&sig))\n-}\n-func sigaction_trampoline()\n-\n-//go:nosplit\n-//go:cgo_unsafe_args\n-func sigprocmask(how uint32, new *sigset, old *sigset) {\n-\tlibcCall(unsafe.Pointer(funcPC(sigprocmask_trampoline)), unsafe.Pointer(&how))\n-}\n-func sigprocmask_trampoline()\n-\n-//go:nosplit\n-//go:cgo_unsafe_args\n-func sigaltstack(new *stackt, old *stackt) {\n-\tif new != nil && new.ss_flags&_SS_DISABLE != 0 && new.ss_size == 0 {\n-\t\t// Despite the fact that Darwin's sigaltstack man page says it ignores the size\n-\t\t// when SS_DISABLE is set, it doesn't. sigaltstack returns ENOMEM\n-\t\t// if we don't give it a reasonable size.\n-\t\t// ref: http://lists.llvm.org/pipermail/llvm-commits/Week-of-Mon-20140421/214296.html\n-\t\tnew.ss_size = 32768\n-\t}\n-\tlibcCall(unsafe.Pointer(funcPC(sigaltstack_trampoline)), unsafe.Pointer(&new))\n-}\n-func sigaltstack_trampoline()\n-\n-//go:nosplit\n-//go:cgo_unsafe_args\n-func raiseproc(sig uint32) {\n-\tlibcCall(unsafe.Pointer(funcPC(raiseproc_trampoline)), unsafe.Pointer(&sig))\n-}\n-func raiseproc_trampoline()\n-\n-//go:nosplit\n-//go:cgo_unsafe_args\n-func setitimer(mode int32, new, old *itimerval) {\n-\tlibcCall(unsafe.Pointer(funcPC(setitimer_trampoline)), unsafe.Pointer(&mode))\n-}\n-func setitimer_trampoline()\n-\n-//go:nosplit\n-//go:cgo_unsafe_args\n-func sysctl(mib *uint32, miblen uint32, out *byte, size *uintptr, dst *byte, ndst uintptr) int32 {\n-\treturn libcCall(unsafe.Pointer(funcPC(sysctl_trampoline)), unsafe.Pointer(&mib))\n-}\n-func sysctl_trampoline()\n-\n-//go:nosplit\n-//go:cgo_unsafe_args\n-func fcntl(fd, cmd, arg int32) int32 {\n-\treturn libcCall(unsafe.Pointer(funcPC(fcntl_trampoline)), unsafe.Pointer(&fd))\n-}\n-func fcntl_trampoline()\n-\n-//go:nosplit\n-//go:cgo_unsafe_args\n-func kqueue() int32 {\n-\tv := libcCall(unsafe.Pointer(funcPC(kqueue_trampoline)), nil)\n-\treturn v\n-}\n-func kqueue_trampoline()\n-\n-//go:nosplit\n-//go:cgo_unsafe_args\n-func kevent(kq int32, ch *keventt, nch int32, ev *keventt, nev int32, ts *timespec) int32 {\n-\treturn libcCall(unsafe.Pointer(funcPC(kevent_trampoline)), unsafe.Pointer(&kq))\n-}\n-func kevent_trampoline()\n-\n-//go:nosplit\n-//go:cgo_unsafe_args\n-func pthread_mutex_init(m *pthreadmutex, attr *pthreadmutexattr) int32 {\n-\treturn libcCall(unsafe.Pointer(funcPC(pthread_mutex_init_trampoline)), unsafe.Pointer(&m))\n-}\n-func pthread_mutex_init_trampoline()\n-\n-//go:nosplit\n-//go:cgo_unsafe_args\n-func pthread_mutex_lock(m *pthreadmutex) int32 {\n-\treturn libcCall(unsafe.Pointer(funcPC(pthread_mutex_lock_trampoline)), unsafe.Pointer(&m))\n-}\n-func pthread_mutex_lock_trampoline()\n-\n-//go:nosplit\n-//go:cgo_unsafe_args\n-func pthread_mutex_unlock(m *pthreadmutex) int32 {\n-\treturn libcCall(unsafe.Pointer(funcPC(pthread_mutex_unlock_trampoline)), unsafe.Pointer(&m))\n-}\n-func pthread_mutex_unlock_trampoline()\n-\n-//go:nosplit\n-//go:cgo_unsafe_args\n-func pthread_cond_init(c *pthreadcond, attr *pthreadcondattr) int32 {\n-\treturn libcCall(unsafe.Pointer(funcPC(pthread_cond_init_trampoline)), unsafe.Pointer(&c))\n-}\n-func pthread_cond_init_trampoline()\n-\n-//go:nosplit\n-//go:cgo_unsafe_args\n-func pthread_cond_wait(c *pthreadcond, m *pthreadmutex) int32 {\n-\treturn libcCall(unsafe.Pointer(funcPC(pthread_cond_wait_trampoline)), unsafe.Pointer(&c))\n-}\n-func pthread_cond_wait_trampoline()\n-\n-//go:nosplit\n-//go:cgo_unsafe_args\n-func pthread_cond_timedwait_relative_np(c *pthreadcond, m *pthreadmutex, t *timespec) int32 {\n-\treturn libcCall(unsafe.Pointer(funcPC(pthread_cond_timedwait_relative_np_trampoline)), unsafe.Pointer(&c))\n-}\n-func pthread_cond_timedwait_relative_np_trampoline()\n-\n-//go:nosplit\n-//go:cgo_unsafe_args\n-func pthread_cond_signal(c *pthreadcond) int32 {\n-\treturn libcCall(unsafe.Pointer(funcPC(pthread_cond_signal_trampoline)), unsafe.Pointer(&c))\n-}\n-func pthread_cond_signal_trampoline()\n-\n-// Not used on Darwin, but must be defined.\n-func exitThread(wait *uint32) {\n-}\n-\n-//go:nosplit\n-func closeonexec(fd int32) {\n-\tfcntl(fd, _F_SETFD, _FD_CLOEXEC)\n-}\n-\n-// Tell the linker that the libc_* functions are to be found\n-// in a system library, with the libc_ prefix missing.\n-\n-//go:cgo_import_dynamic libc_pthread_attr_init pthread_attr_init \"/usr/lib/libSystem.B.dylib\"\n-//go:cgo_import_dynamic libc_pthread_attr_setstacksize pthread_attr_setstacksize \"/usr/lib/libSystem.B.dylib\"\n-//go:cgo_import_dynamic libc_pthread_attr_setdetachstate pthread_attr_setdetachstate \"/usr/lib/libSystem.B.dylib\"\n-//go:cgo_import_dynamic libc_pthread_create pthread_create \"/usr/lib/libSystem.B.dylib\"\n-//go:cgo_import_dynamic libc_exit exit \"/usr/lib/libSystem.B.dylib\"\n-//go:cgo_import_dynamic libc_raise raise \"/usr/lib/libSystem.B.dylib\"\n-\n-//go:cgo_import_dynamic libc_open open \"/usr/lib/libSystem.B.dylib\"\n-//go:cgo_import_dynamic libc_close close \"/usr/lib/libSystem.B.dylib\"\n-//go:cgo_import_dynamic libc_read read \"/usr/lib/libSystem.B.dylib\"\n-//go:cgo_import_dynamic libc_write write \"/usr/lib/libSystem.B.dylib\"\n-\n-//go:cgo_import_dynamic libc_mmap mmap \"/usr/lib/libSystem.B.dylib\"\n-//go:cgo_import_dynamic libc_munmap munmap \"/usr/lib/libSystem.B.dylib\"\n-//go:cgo_import_dynamic libc_madvise madvise \"/usr/lib/libSystem.B.dylib\"\n-//go:cgo_import_dynamic libc_error __error \"/usr/lib/libSystem.B.dylib\"\n-//go:cgo_import_dynamic libc_usleep usleep \"/usr/lib/libSystem.B.dylib\"\n-\n-//go:cgo_import_dynamic libc_mach_timebase_info mach_timebase_info \"/usr/lib/libSystem.B.dylib\"\n-//go:cgo_import_dynamic libc_mach_absolute_time mach_absolute_time \"/usr/lib/libSystem.B.dylib\"\n-//go:cgo_import_dynamic libc_gettimeofday gettimeofday \"/usr/lib/libSystem.B.dylib\"\n-//go:cgo_import_dynamic libc_sigaction sigaction \"/usr/lib/libSystem.B.dylib\"\n-//go:cgo_import_dynamic libc_pthread_sigmask pthread_sigmask \"/usr/lib/libSystem.B.dylib\"\n-//go:cgo_import_dynamic libc_sigaltstack sigaltstack \"/usr/lib/libSystem.B.dylib\"\n-//go:cgo_import_dynamic libc_getpid getpid \"/usr/lib/libSystem.B.dylib\"\n-//go:cgo_import_dynamic libc_kill kill \"/usr/lib/libSystem.B.dylib\"\n-//go:cgo_import_dynamic libc_setitimer setitimer \"/usr/lib/libSystem.B.dylib\"\n-//go:cgo_import_dynamic libc_sysctl sysctl \"/usr/lib/libSystem.B.dylib\"\n-//go:cgo_import_dynamic libc_fcntl fcntl \"/usr/lib/libSystem.B.dylib\"\n-//go:cgo_import_dynamic libc_kqueue kqueue \"/usr/lib/libSystem.B.dylib\"\n-//go:cgo_import_dynamic libc_kevent kevent \"/usr/lib/libSystem.B.dylib\"\n-\n-//go:cgo_import_dynamic libc_pthread_mutex_init pthread_mutex_init \"/usr/lib/libSystem.B.dylib\"\n-//go:cgo_import_dynamic libc_pthread_mutex_lock pthread_mutex_lock \"/usr/lib/libSystem.B.dylib\"\n-//go:cgo_import_dynamic libc_pthread_mutex_unlock pthread_mutex_unlock \"/usr/lib/libSystem.B.dylib\"\n-//go:cgo_import_dynamic libc_pthread_cond_init pthread_cond_init \"/usr/lib/libSystem.B.dylib\"\n-//go:cgo_import_dynamic libc_pthread_cond_wait pthread_cond_wait \"/usr/lib/libSystem.B.dylib\"\n-//go:cgo_import_dynamic libc_pthread_cond_timedwait_relative_np pthread_cond_timedwait_relative_np \"/usr/lib/libSystem.B.dylib\"\n-//go:cgo_import_dynamic libc_pthread_cond_signal pthread_cond_signal \"/usr/lib/libSystem.B.dylib\"\n-\n-// Magic incantation to get libSystem actually dynamically linked.\n-// TODO: Why does the code require this?  See cmd/link/internal/ld/go.go\n-//go:cgo_import_dynamic _ _ \"/usr/lib/libSystem.B.dylib\""}, {"sha": "2f17091327dae730960b52a0d55dda1d62b56b66", "filename": "libgo/go/runtime/sys_darwin_32.go", "status": "removed", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c980510a5ab79614fcbaf5f411b1273dc9a8c7ca/libgo%2Fgo%2Fruntime%2Fsys_darwin_32.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c980510a5ab79614fcbaf5f411b1273dc9a8c7ca/libgo%2Fgo%2Fruntime%2Fsys_darwin_32.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fsys_darwin_32.go?ref=c980510a5ab79614fcbaf5f411b1273dc9a8c7ca", "patch": "@@ -1,32 +0,0 @@\n-// Copyright 2018 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// +build darwin\n-// +build 386 arm\n-\n-package runtime\n-\n-import \"unsafe\"\n-\n-//go:linkname syscall_syscall9 syscall.syscall9\n-//go:nosplit\n-//go:cgo_unsafe_args\n-func syscall_syscall9(fn, a1, a2, a3, a4, a5, a6, a7, a8, a9 uintptr) (r1, r2, err uintptr) {\n-\tentersyscallblock()\n-\tlibcCall(unsafe.Pointer(funcPC(syscall9)), unsafe.Pointer(&fn))\n-\texitsyscall()\n-\treturn\n-}\n-func syscall9()\n-\n-//go:linkname syscall_syscallPtr syscall.syscallPtr\n-//go:nosplit\n-//go:cgo_unsafe_args\n-func syscall_syscallPtr(fn, a1, a2, a3 uintptr) (r1, r2, err uintptr) {\n-\tentersyscallblock()\n-\tlibcCall(unsafe.Pointer(funcPC(syscallPtr)), unsafe.Pointer(&fn))\n-\texitsyscall()\n-\treturn\n-}\n-func syscallPtr()"}, {"sha": "8c128811b9f5d8ff9d9cf54c9359aad472997ce7", "filename": "libgo/go/runtime/sys_darwin_64.go", "status": "removed", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c980510a5ab79614fcbaf5f411b1273dc9a8c7ca/libgo%2Fgo%2Fruntime%2Fsys_darwin_64.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c980510a5ab79614fcbaf5f411b1273dc9a8c7ca/libgo%2Fgo%2Fruntime%2Fsys_darwin_64.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fsys_darwin_64.go?ref=c980510a5ab79614fcbaf5f411b1273dc9a8c7ca", "patch": "@@ -1,32 +0,0 @@\n-// Copyright 2018 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// +build darwin\n-// +build amd64 arm64\n-\n-package runtime\n-\n-import \"unsafe\"\n-\n-//go:linkname syscall_syscallX syscall.syscallX\n-//go:nosplit\n-//go:cgo_unsafe_args\n-func syscall_syscallX(fn, a1, a2, a3 uintptr) (r1, r2, err uintptr) {\n-\tentersyscallblock()\n-\tlibcCall(unsafe.Pointer(funcPC(syscallX)), unsafe.Pointer(&fn))\n-\texitsyscall()\n-\treturn\n-}\n-func syscallX()\n-\n-//go:linkname syscall_syscallXPtr syscall.syscallXPtr\n-//go:nosplit\n-//go:cgo_unsafe_args\n-func syscall_syscallXPtr(fn, a1, a2, a3 uintptr) (r1, r2, err uintptr) {\n-\tentersyscallblock()\n-\tlibcCall(unsafe.Pointer(funcPC(syscallXPtr)), unsafe.Pointer(&fn))\n-\texitsyscall()\n-\treturn\n-}\n-func syscallXPtr()"}, {"sha": "f1aa7241cd6eb6f0d603e2c5b60078498a2ad109", "filename": "libgo/mkrsysinfo.sh", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32b1d51f16fe56b34e979fcfba4bc74dbd3592a9/libgo%2Fmkrsysinfo.sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32b1d51f16fe56b34e979fcfba4bc74dbd3592a9/libgo%2Fmkrsysinfo.sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmkrsysinfo.sh?ref=32b1d51f16fe56b34e979fcfba4bc74dbd3592a9", "patch": "@@ -31,6 +31,19 @@ grep -v '^// ' gen-sysinfo.go | \\\n       -e 's/\\([^a-zA-Z0-9_]\\)_timespec\\([^a-zA-Z0-9_]\\)/\\1timespec\\2/g' \\\n     >> ${OUT}\n \n+# The C long type, needed because that is the type that ptrace returns.\n+sizeof_long=`grep '^const ___SIZEOF_LONG__ = ' gen-sysinfo.go | sed -e 's/.*= //'`\n+if test \"$sizeof_long\" = \"4\"; then\n+  echo \"type _C_long int32\" >> ${OUT}\n+  echo \"type _C_ulong uint32\" >> ${OUT}\n+elif test \"$sizeof_long\" = \"8\"; then\n+  echo \"type _C_long int64\" >> ${OUT}\n+  echo \"type _C_ulong uint64\" >> ${OUT}\n+else\n+  echo 1>&2 \"mkrsysinfo.sh: could not determine size of long (got $sizeof_long)\"\n+  exit 1\n+fi\n+\n # On AIX, the _arpcom struct, is filtered by the above grep sequence, as it as\n # a field of type _in6_addr, but other types depend on _arpcom, so we need to\n # put it back."}, {"sha": "064eed8570cdf3533b4f1c8adf236709d90d63a6", "filename": "libgo/runtime/getncpu-aix.c", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c980510a5ab79614fcbaf5f411b1273dc9a8c7ca/libgo%2Fruntime%2Fgetncpu-aix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c980510a5ab79614fcbaf5f411b1273dc9a8c7ca/libgo%2Fruntime%2Fgetncpu-aix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgetncpu-aix.c?ref=c980510a5ab79614fcbaf5f411b1273dc9a8c7ca", "patch": "@@ -1,15 +0,0 @@\n-// Copyright 2012 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-#include <sys/types.h>\n-#include <sys/systemcfg.h>\n-\n-#include \"runtime.h\"\n-#include \"defs.h\"\n-\n-int32_t\n-getproccount(void)\n-{\n-\treturn _system_configuration.ncpus;\n-}"}, {"sha": "00a81d1ddae50662292fdf5928407393fbaf2cd4", "filename": "libgo/runtime/getncpu-bsd.c", "status": "removed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c980510a5ab79614fcbaf5f411b1273dc9a8c7ca/libgo%2Fruntime%2Fgetncpu-bsd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c980510a5ab79614fcbaf5f411b1273dc9a8c7ca/libgo%2Fruntime%2Fgetncpu-bsd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgetncpu-bsd.c?ref=c980510a5ab79614fcbaf5f411b1273dc9a8c7ca", "patch": "@@ -1,24 +0,0 @@\n-// Copyright 2012 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-#include <sys/types.h>\n-#include <sys/sysctl.h>\n-\n-#include \"runtime.h\"\n-#include \"defs.h\"\n-\n-int32\n-getproccount(void)\n-{\n-\tint mib[2], out;\n-\tsize_t len;\n-\n-\tmib[0] = CTL_HW;\n-\tmib[1] = HW_NCPU;\n-\tlen = sizeof(out);\n-\tif(sysctl(mib, 2, &out, &len, NULL, 0) >= 0)\n-\t\treturn (int32)out;\n-\telse\n-\t\treturn 0;\n-}"}, {"sha": "5d5d7025dfe430fe987186fbcd4f0fd3f18f17ad", "filename": "libgo/runtime/getncpu-hurd.c", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c980510a5ab79614fcbaf5f411b1273dc9a8c7ca/libgo%2Fruntime%2Fgetncpu-hurd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c980510a5ab79614fcbaf5f411b1273dc9a8c7ca/libgo%2Fruntime%2Fgetncpu-hurd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgetncpu-hurd.c?ref=c980510a5ab79614fcbaf5f411b1273dc9a8c7ca", "patch": "@@ -1,16 +0,0 @@\n-// Copyright 2012 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-#include <unistd.h>\n-\n-#include \"runtime.h\"\n-#include \"defs.h\"\n-\n-int32\n-getproccount(void)\n-{\n-\tint32 n;\n-\tn = (int32)sysconf(_SC_NPROCESSORS_ONLN);\n-\treturn n > 1 ? n : 1;\n-}"}, {"sha": "a65ca63d2aed68c35cba730120347cad5761c435", "filename": "libgo/runtime/getncpu-irix.c", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c980510a5ab79614fcbaf5f411b1273dc9a8c7ca/libgo%2Fruntime%2Fgetncpu-irix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c980510a5ab79614fcbaf5f411b1273dc9a8c7ca/libgo%2Fruntime%2Fgetncpu-irix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgetncpu-irix.c?ref=c980510a5ab79614fcbaf5f411b1273dc9a8c7ca", "patch": "@@ -1,16 +0,0 @@\n-// Copyright 2012 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-#include <unistd.h>\n-\n-#include \"runtime.h\"\n-#include \"defs.h\"\n-\n-int32\n-getproccount(void)\n-{\n-\tint32 n;\n-\tn = (int32)sysconf(_SC_NPROC_ONLN);\n-\treturn n > 1 ? n : 1;\n-}"}, {"sha": "de6606ff47cb2eee4ae943b28200fb9bb60d77fb", "filename": "libgo/runtime/getncpu-linux.c", "status": "removed", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c980510a5ab79614fcbaf5f411b1273dc9a8c7ca/libgo%2Fruntime%2Fgetncpu-linux.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c980510a5ab79614fcbaf5f411b1273dc9a8c7ca/libgo%2Fruntime%2Fgetncpu-linux.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgetncpu-linux.c?ref=c980510a5ab79614fcbaf5f411b1273dc9a8c7ca", "patch": "@@ -1,36 +0,0 @@\n-// Copyright 2012 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-#include <features.h>\n-#include <sched.h>\n-\n-// CPU_COUNT is only provided by glibc 2.6 or higher\n-#ifndef CPU_COUNT\n-#define CPU_COUNT(set) _CPU_COUNT((unsigned int *)(set), sizeof(*(set))/sizeof(unsigned int))\n-static int _CPU_COUNT(unsigned int *set, size_t len) {\n-\tint cnt;\n-\n-\tcnt = 0;\n-\twhile (len--)\n-\t\tcnt += __builtin_popcount(*set++);\n-\treturn cnt;\n-}\n-#endif\n-\n-#include \"runtime.h\"\n-#include \"defs.h\"\n-\n-int32\n-getproccount(void)\n-{\n-\tcpu_set_t set;\n-\tint32 r, cnt;\n-\n-\tcnt = 0;\n-\tr = sched_getaffinity(0, sizeof(set), &set);\n-\tif(r == 0)\n-\t\tcnt += CPU_COUNT(&set);\n-\n-\treturn cnt ? cnt : 1;\n-}"}, {"sha": "ba6fd4e689d3b189fe669a009000bc4652f37fc1", "filename": "libgo/runtime/getncpu-none.c", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c980510a5ab79614fcbaf5f411b1273dc9a8c7ca/libgo%2Fruntime%2Fgetncpu-none.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c980510a5ab79614fcbaf5f411b1273dc9a8c7ca/libgo%2Fruntime%2Fgetncpu-none.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgetncpu-none.c?ref=c980510a5ab79614fcbaf5f411b1273dc9a8c7ca", "patch": "@@ -1,12 +0,0 @@\n-// Copyright 2012 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-#include \"runtime.h\"\n-#include \"defs.h\"\n-\n-int32\n-getproccount(void)\n-{\n-\treturn 0;\n-}"}, {"sha": "5d5d7025dfe430fe987186fbcd4f0fd3f18f17ad", "filename": "libgo/runtime/getncpu-solaris.c", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c980510a5ab79614fcbaf5f411b1273dc9a8c7ca/libgo%2Fruntime%2Fgetncpu-solaris.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c980510a5ab79614fcbaf5f411b1273dc9a8c7ca/libgo%2Fruntime%2Fgetncpu-solaris.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgetncpu-solaris.c?ref=c980510a5ab79614fcbaf5f411b1273dc9a8c7ca", "patch": "@@ -1,16 +0,0 @@\n-// Copyright 2012 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-#include <unistd.h>\n-\n-#include \"runtime.h\"\n-#include \"defs.h\"\n-\n-int32\n-getproccount(void)\n-{\n-\tint32 n;\n-\tn = (int32)sysconf(_SC_NPROCESSORS_ONLN);\n-\treturn n > 1 ? n : 1;\n-}"}, {"sha": "10b202bf8f8888d4675ad6c4fa109e7cd4075ac2", "filename": "libgo/runtime/go-libmain.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32b1d51f16fe56b34e979fcfba4bc74dbd3592a9/libgo%2Fruntime%2Fgo-libmain.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32b1d51f16fe56b34e979fcfba4bc74dbd3592a9/libgo%2Fruntime%2Fgo-libmain.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-libmain.c?ref=32b1d51f16fe56b34e979fcfba4bc74dbd3592a9", "patch": "@@ -228,8 +228,7 @@ gostart (void *arg)\n   runtime_ginit ();\n   runtime_check ();\n   runtime_args (a->argc, (byte **) a->argv);\n-  setncpu (getproccount ());\n-  setpagesize (getpagesize ());\n+  runtime_osinit ();\n   runtime_schedinit ();\n   __go_go ((uintptr)(runtime_main), NULL);\n   runtime_mstart (runtime_m ());"}, {"sha": "dcf763af8c85eb550309ea76b2c6d103e380e26f", "filename": "libgo/runtime/go-main.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32b1d51f16fe56b34e979fcfba4bc74dbd3592a9/libgo%2Fruntime%2Fgo-main.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32b1d51f16fe56b34e979fcfba4bc74dbd3592a9/libgo%2Fruntime%2Fgo-main.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-main.c?ref=32b1d51f16fe56b34e979fcfba4bc74dbd3592a9", "patch": "@@ -52,8 +52,7 @@ main (int argc, char **argv)\n   runtime_cpuinit ();\n   runtime_check ();\n   runtime_args (argc, (byte **) argv);\n-  setncpu (getproccount ());\n-  setpagesize (getpagesize ());\n+  runtime_osinit ();\n   runtime_schedinit ();\n   __go_go ((uintptr)(runtime_main), NULL);\n   runtime_mstart (runtime_m ());"}, {"sha": "4102f5da0a045a12944407646ddd55d2cc127fed", "filename": "libgo/runtime/runtime.h", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32b1d51f16fe56b34e979fcfba4bc74dbd3592a9/libgo%2Fruntime%2Fruntime.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32b1d51f16fe56b34e979fcfba4bc74dbd3592a9/libgo%2Fruntime%2Fruntime.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fruntime.h?ref=32b1d51f16fe56b34e979fcfba4bc74dbd3592a9", "patch": "@@ -211,6 +211,8 @@ void\truntime_gogo(G*)\n struct __go_func_type;\n void\truntime_args(int32, byte**)\n   __asm__ (GOSYM_PREFIX \"runtime.args\");\n+void\truntime_osinit(void)\n+  __asm__ (GOSYM_PREFIX \"runtime.osinit\");\n void\truntime_alginit(void)\n   __asm__ (GOSYM_PREFIX \"runtime.alginit\");\n void\truntime_goargs(void)\n@@ -429,8 +431,6 @@ extern void __go_syminfo_fnname_callback(void*, uintptr_t, const char*,\n extern void runtime_main(void*)\n   __asm__(GOSYM_PREFIX \"runtime.main\");\n \n-int32 getproccount(void);\n-\n #define PREFETCH(p) __builtin_prefetch(p)\n \n void\truntime_badsignal(int);\n@@ -456,12 +456,8 @@ extern void setSupportAES(bool)\n   __asm__ (GOSYM_PREFIX \"runtime.setSupportAES\");\n extern void typedmemmove(const Type *, void *, const void *)\n   __asm__ (GOSYM_PREFIX \"runtime.typedmemmove\");\n-extern void setncpu(int32)\n-  __asm__(GOSYM_PREFIX \"runtime.setncpu\");\n extern Sched* runtime_getsched(void)\n   __asm__ (GOSYM_PREFIX \"runtime.getsched\");\n-extern void setpagesize(uintptr_t)\n-  __asm__(GOSYM_PREFIX \"runtime.setpagesize\");\n \n struct funcfileline_return\n {"}]}