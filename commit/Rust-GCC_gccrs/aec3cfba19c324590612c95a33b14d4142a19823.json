{"sha": "aec3cfba19c324590612c95a33b14d4142a19823", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWVjM2NmYmExOWMzMjQ1OTA2MTJjOTVhMzNiMTRkNDE0MmExOTgyMw==", "commit": {"author": {"name": "Nick Clifton", "email": "nickc@cygnus.com", "date": "1999-03-17T14:47:27Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "1999-03-17T14:47:27Z"}, "message": "Fix compile time warnings.\n\nImprove target CPU selection.\n\nFrom-SVN: r25824", "tree": {"sha": "54972253682ab13e4ff3c77187303288b51112e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/54972253682ab13e4ff3c77187303288b51112e1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aec3cfba19c324590612c95a33b14d4142a19823", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aec3cfba19c324590612c95a33b14d4142a19823", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aec3cfba19c324590612c95a33b14d4142a19823", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aec3cfba19c324590612c95a33b14d4142a19823/comments", "author": null, "committer": null, "parents": [{"sha": "13bb79d45ec025042ffaa3a359222d32eb5a7dff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13bb79d45ec025042ffaa3a359222d32eb5a7dff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/13bb79d45ec025042ffaa3a359222d32eb5a7dff"}], "stats": {"total": 603, "additions": 356, "deletions": 247}, "files": [{"sha": "d4d97d8451e353176e81dc8904066483ef9aba80", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aec3cfba19c324590612c95a33b14d4142a19823/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aec3cfba19c324590612c95a33b14d4142a19823/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=aec3cfba19c324590612c95a33b14d4142a19823", "patch": "@@ -1,3 +1,16 @@\n+Wed Mar 17 14:41:41 1999  Nick Clifton  <nickc@cygnus.com>\n+\n+\t* config/arm/aout.h (ASM_GENERATE_INTERNAL_LABEL): Fix compile\n+\ttime warning. \t\n+\t* config/arm/arm.md: Fix various compile time warnings.\n+\t* config/arm/arm.h: Fix various compile time warnings.  Add\n+\tfunction prototypes.\n+\t* config/arm/arm.c: Fix various compile time warnings.\n+\t(arm_override_options): Reorganise to seperate tuning from\n+\ttargetting.\n+\t(bit_count): New function: Return a count of the number of bits\n+\tset in a word.\n+\n Wed Mar 17 21:29:12 1999  J\"orn Rennecke <amylaar@cygnus.co.uk>\n \n \t* reload1.c (eliminate_regs): Don't keep REG_DEAD notes around for"}, {"sha": "4f9d4da0c6aa186e97e86b28e0d5f9a2be352d6e", "filename": "gcc/config/arm/aout.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aec3cfba19c324590612c95a33b14d4142a19823/gcc%2Fconfig%2Farm%2Faout.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aec3cfba19c324590612c95a33b14d4142a19823/gcc%2Fconfig%2Farm%2Faout.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Faout.h?ref=aec3cfba19c324590612c95a33b14d4142a19823", "patch": "@@ -148,7 +148,7 @@ do {\t\t\t\t\t\\\n /* Make an internal label into a string.  */\n #ifndef ASM_GENERATE_INTERNAL_LABEL\n #define ASM_GENERATE_INTERNAL_LABEL(STRING, PREFIX, NUM)  \\\n-  sprintf (STRING, \"*%s%s%d\", LOCAL_LABEL_PREFIX, PREFIX, NUM)\n+  sprintf (STRING, \"*%s%s%u\", LOCAL_LABEL_PREFIX, PREFIX, (unsigned int)(NUM))\n #endif\n      \n /* Nothing special is done about jump tables */"}, {"sha": "23b55492769864c25165215910d7a57a86d173e0", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 199, "deletions": 120, "changes": 319, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aec3cfba19c324590612c95a33b14d4142a19823/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aec3cfba19c324590612c95a33b14d4142a19823/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=aec3cfba19c324590612c95a33b14d4142a19823", "patch": "@@ -37,6 +37,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"tree.h\"\n #include \"expr.h\"\n #include \"toplev.h\"\n+#include \"recog.h\"\n \n /* The maximum number of insns skipped which will be conditionalised if\n    possible.  */\n@@ -70,7 +71,6 @@ static enum arm_cond_code get_arm_condition_code PROTO ((rtx));\n \n /*  Define the information needed to generate branch insns.  This is\n    stored from the compare operation. */\n-\n rtx arm_compare_op0, arm_compare_op1;\n int arm_compare_fp;\n \n@@ -90,13 +90,34 @@ char * target_fp_name = NULL;\n char * structure_size_string = NULL;\n int    arm_structure_size_boundary = 32; /* Used to be 8 */\n \n+/* Bit values used to identify processor capabilities.  */\n+#define FL_CO_PROC    0x01            /* Has external co-processor bus */\n+#define FL_FAST_MULT  0x02            /* Fast multiply */\n+#define FL_MODE26     0x04            /* 26-bit mode support */\n+#define FL_MODE32     0x08            /* 32-bit mode support */\n+#define FL_ARCH4      0x10            /* Architecture rel 4 */\n+#define FL_THUMB      0x20            /* Thumb aware */\n+#define FL_LDSCHED    0x40\t      /* Load scheduling necessary */\n+#define FL_STRONG     0x80\t      /* StrongARM */\n+\n+/* The bits in this mask specify which instructions we are allowed to generate.  */\n+static int insn_flags = 0;\n+/* The bits in this mask specify which instruction scheduling options should\n+   be used.  Note - there is an overlap with the FL_FAST_MULT.  For some\n+   hardware we want to be able to generate the multiply instructions, but to\n+   tune as if they were not present in the architecture.  */\n+static int tune_flags = 0;\n+\n+/* The following are used in the arm.md file as equivalents to bits\n+   in the above two flag variables.  */\n+\n /* Nonzero if this is an \"M\" variant of the processor.  */\n int arm_fast_multiply = 0;\n \n /* Nonzero if this chip supports the ARM Architecture 4 extensions */\n int arm_arch4 = 0;\n \n-/* Nonzero if this chip can benefit from laod scheduling.  */\n+/* Nonzero if this chip can benefit from load scheduling.  */\n int arm_ld_sched = 0;\n \n /* Nonzero if this chip is a StrongARM.  */\n@@ -125,11 +146,13 @@ int lr_save_eliminated;\n \n /* Set to 1 when a return insn is output, this means that the epilogue\n    is not needed. */\n-\n static int return_used_this_function;\n \n+/* Set to 1 after arm_reorg has started.  Reset to start at the start of\n+   the next function.  */\n static int after_arm_reorg = 0;\n \n+/* The maximum number of insns to be used when loading a constant.  */\n static int arm_constant_limit = 3;\n \n /* For an explanation of these variables, see final_prescan_insn below.  */\n@@ -151,15 +174,6 @@ static enum arm_cond_code get_arm_condition_code ();\n \f\n /* Initialization code */\n \n-#define FL_CO_PROC    0x01            /* Has external co-processor bus */\n-#define FL_FAST_MULT  0x02            /* Fast multiply */\n-#define FL_MODE26     0x04            /* 26-bit mode support */\n-#define FL_MODE32     0x08            /* 32-bit mode support */\n-#define FL_ARCH4      0x10            /* Architecture rel 4 */\n-#define FL_THUMB      0x20            /* Thumb aware */\n-#define FL_LDSCHED    0x40\t      /* Load scheduling necessary */\n-#define FL_STRONG     0x80\t      /* StrongARM */\n-\n struct processors\n {\n   char *       name;\n@@ -233,14 +247,28 @@ struct arm_cpu_select arm_select[] =\n   { NULL,\t\"-mtune=\",\tall_cores }\n };\n \n+/* Return the number of bits set in value' */\n+static unsigned int\n+bit_count (value)\n+     signed int value;\n+{\n+  unsigned int count = 0;\n+  \n+  while (value)\n+    {\n+      value &= ~(value & - value);\n+      ++ count;\n+    }\n+\n+  return count;\n+}\n+\n /* Fix up any incompatible options that the user has specified.\n    This has now turned into a maze.  */\n void\n arm_override_options ()\n {\n-  unsigned int flags = 0;\n   unsigned i;\n-  struct arm_cpu_select * ptr;\n   \n   /* Set up the flags based on the cpu/architecture selected by the user.  */\n   for (i = sizeof (arm_select) / sizeof (arm_select[0]); i--;)\n@@ -254,23 +282,20 @@ arm_override_options ()\n           for (sel = ptr->processors; sel->name != NULL; sel ++)\n             if (streq (ptr->string, sel->name))\n               {\n-\t\tif (flags != 0)\n+\t\tif (i == 2)\n+\t\t  tune_flags = sel->flags;\n+\t\telse\n \t\t  {\n-\t\t    /* We scan the arm_select array in the order:\n-\t\t         tune -> arch -> cpu\n-\t\t       So if we have been asked to tune for, say, an ARM8,\n-\t\t       but we are told that the cpu is only an ARM6, then\n-\t\t       we have problems.  We detect this by seeing if the\n-\t\t       flags bits accumulated so far can be supported by the\n-\t\t       cpu/architecture type now being parsed.  If they can,\n-\t\t       then OR in any new bits.  If they cannot then report\n-\t\t       an error.  */\n-\t\t    if ((flags & sel->flags) != flags)\n-\t\t      error (\"switch %s%s overridden by another switch\",\n-\t\t\t     ptr->string, sel->name );\n+\t\t    /* If we have been given an architecture and a processor\n+\t\t       make sure that they are compatible.  We only generate\n+\t\t       a warning though, and we prefer the CPU over the\n+\t\t       architecture. */\n+\t\t    if (insn_flags != 0 && (insn_flags ^ sel->flags))\n+\t\t      warning (\"switch -mcpu=%s conflicts with -mtune= switch\",\n+\t\t\t       ptr->string);\n+\t\t    \n+\t\t    insn_flags = sel->flags;\n \t\t  }\n-\n-\t\tflags = sel->flags;\n \t\t\n                 break;\n               }\n@@ -279,97 +304,148 @@ arm_override_options ()\n             error (\"bad value (%s) for %s switch\", ptr->string, ptr->name);\n         }\n     }\n-\n+  \n   /* If the user did not specify a processor, choose one for them.  */\n-  if (flags == 0)\n+  if (insn_flags == 0)\n     {\n       struct processors * sel;\n-      int                 sought = 0;\n+      unsigned int        sought;\n+      static struct cpu_default\n+      {\n+\tint    cpu;\n+\tchar * name;\n+      }\n+      cpu_defaults[] =\n+      {\n+\t{ TARGET_CPU_arm2,      \"arm2\" },\n+\t{ TARGET_CPU_arm6,      \"arm6\" },\n+\t{ TARGET_CPU_arm610,    \"arm610\" },\n+\t{ TARGET_CPU_arm7m,     \"arm7m\" },\n+\t{ TARGET_CPU_arm7500fe, \"arm7500fe\" },\n+\t{ TARGET_CPU_arm7tdmi,  \"arm7tdmi\" },\n+\t{ TARGET_CPU_arm8,      \"arm8\" },\n+\t{ TARGET_CPU_arm810,    \"arm810\" },\n+\t{ TARGET_CPU_arm9,      \"arm9\" },\n+\t{ TARGET_CPU_strongarm, \"strongarm\" },\n+\t{ TARGET_CPU_generic,   \"arm\" },\n+\t{ 0, 0 }\n+      };\n+      struct cpu_default * def;\n+\t  \n+      /* Find the default.  */\n+      for (def = cpu_defaults; def->name; def ++)\n+\tif (def->cpu == TARGET_CPU_DEFAULT)\n+\t  break;\n+\n+      /* Make sure we found the default CPU.  */\n+      if (def->name == NULL)\n+\tabort ();\n+      \n+      /* Find the default CPU's flags.  */\n+      for (sel = all_cores; sel->name != NULL; sel ++)\n+\tif (streq (def->name, sel->name))\n+\t  break;\n+      \n+      if (sel->name == NULL)\n+\tabort ();\n+\n+      insn_flags = sel->flags;\n+      \n+      /* Now check to see if the user has specified some command line\n+\t switch that require certain abilities from the cpu.  */\n+      sought = 0;\n       \n       if (TARGET_THUMB_INTERWORK)\n \t{\n-\t  sought |= FL_THUMB;\n-\n-\t  /* Force apcs-32 to be used for Thumb targets.  */\n+\t  sought |= (FL_THUMB | FL_MODE32);\n+\t  \n+\t  /* Force apcs-32 to be used for interworking.  */\n \t  target_flags |= ARM_FLAG_APCS_32;\n+\n+\t  /* There are no ARM processor that supports both APCS-26 and\n+\t     interworking.  Therefore we force FL_MODE26 to be removed\n+\t     from insn_flags here (if it was set), so that the search\n+\t     below will always be able to find a compatible processor.  */\n+\t  insn_flags &= ~ FL_MODE26;\n \t}\n       \n       if (! TARGET_APCS_32)\n \tsought |= FL_MODE26;\n \n-      if (sought != 0)\n+      if (sought != 0 && ((sought & insn_flags) != sought))\n \t{\n-\t  for (sel = all_cores; sel->name != NULL; sel++)\n-\t    if ((sel->flags & sought) == sought)\n-\t      {\n-\t\tflags = sel->flags;\n-\t\tbreak;\n-\t      }\n-\t  \n-\t  if (sel->name == NULL)\n-\t    fatal (\"Unable to select a cpu that matches command line specification\");\n-\t}\n-      else\n-\t{\n-\t  /* The user did not specify any command line switches that require\n-\t     a certain kind of CPU.  Use TARGET_CPU_DEFAULT instead.  */\n-\n-\t  static struct cpu_default\n-\t  {\n-\t    int    cpu;\n-\t    char * name;\n-\t  }\n-\t  cpu_defaults[] =\n-\t  {\n-\t    { TARGET_CPU_arm2,      \"arm2\" },\n-\t    { TARGET_CPU_arm6,      \"arm6\" },\n-\t    { TARGET_CPU_arm610,    \"arm610\" },\n-\t    { TARGET_CPU_arm7m,     \"arm7m\" },\n-\t    { TARGET_CPU_arm7500fe, \"arm7500fe\" },\n-\t    { TARGET_CPU_arm7tdmi,  \"arm7tdmi\" },\n-\t    { TARGET_CPU_arm8,      \"arm8\" },\n-\t    { TARGET_CPU_arm810,    \"arm810\" },\n-\t    { TARGET_CPU_arm9,      \"arm9\" },\n-\t    { TARGET_CPU_strongarm, \"strongarm\" },\n-\t    { TARGET_CPU_generic,   \"arm\" },\n-\t    { 0, 0 }\n-\t  };\n-\t  struct cpu_default * def;\n-\t  \n-\t  /* Find the default.  */\n-\t  for (def = cpu_defaults; def->name; def ++)\n-\t    if (def->cpu == TARGET_CPU_DEFAULT)\n-\t      break;\n-\t  \n-\t  if (def->name == NULL)\n-\t    abort ();\n-\n-\t  /* Find the default CPU's flags.  */\n+\t  /* Try to locate a CPU type that supports all of the abilities\n+\t     of the default CPU, plus the extra abilities requested by\n+\t     the user.  */\n \t  for (sel = all_cores; sel->name != NULL; sel ++)\n-\t    if (streq (def->name, sel->name))\n+\t    if ((sel->flags & sought) == (sought | insn_flags))\n \t      break;\n \n \t  if (sel->name == NULL)\n-\t    abort ();\n+\t    {\n+\t      unsigned int        current_bit_count = 0;\n+\t      struct processors * best_fit = NULL;\n+\t      \n+\t      /* Ideally we would like to issue an error message here\n+\t\t saying that it was not possible to find a CPU compatible\n+\t\t with the default CPU, but which also supports the command\n+\t\t line options specified by the programmer, and so they\n+\t\t ought to use the -mcpu=<name> command line option to\n+\t\t override the default CPU type.\n+\n+\t\t Unfortunately this does not work with multilibing.  We\n+\t\t need to be able to support multilibs for -mapcs-26 and for\n+\t\t -mthumb-interwork and there is no CPU that can support both\n+\t\t options.  Instead if we cannot find a cpu that has both the\n+\t\t characteristics of the default cpu and the given command line\n+\t\t options we scan the array again looking for a best match.  */\n+\t      for (sel = all_cores; sel->name != NULL; sel ++)\n+\t\tif ((sel->flags & sought) == sought)\n+\t\t  {\n+\t\t    unsigned int count;\n+\n+\t\t    count = bit_count (sel->flags & insn_flags);\n \n-\t  flags = sel->flags;\n+\t\t    if (count >= current_bit_count)\n+\t\t      {\n+\t\t\tbest_fit = sel;\n+\t\t\tcurrent_bit_count = count;\n+\t\t      }\n+\t\t  }\n+\n+\t      if (best_fit == NULL)\n+\t\tabort ();\n+\t      else\n+\t\tsel = best_fit;\n+\t    }\n+\n+\t  insn_flags = sel->flags;\n \t}\n     }\n-\n+  \n+  /* If tuning has not been specified, tune for whichever processor or\n+     architecture has been selected.  */\n+  if (tune_flags == 0)\n+    tune_flags = insn_flags;\n+  \n   /* Make sure that the processor choice does not conflict with any of the\n      other command line choices.  */\n-  if (TARGET_APCS_32 && !(flags & FL_MODE32))\n+  if (TARGET_APCS_32 && !(insn_flags & FL_MODE32))\n     {\n-      warning (\"target CPU does not support APCS-32\" );\n+      /* If APCS-32 was not the default then it must have been set by the\n+\t user, so issue a warning message.  If the user has specified\n+\t \"-mapcs-32 -mcpu=arm2\" then we loose here.  */\n+      if ((TARGET_DEFAULT & ARM_FLAG_APCS_32) == 0)\n+\twarning (\"target CPU does not support APCS-32\" );\n       target_flags &= ~ ARM_FLAG_APCS_32;\n     }\n-  else if (! TARGET_APCS_32 && !(flags & FL_MODE26))\n+  else if (! TARGET_APCS_32 && !(insn_flags & FL_MODE26))\n     {\n       warning (\"target CPU does not support APCS-26\" );\n       target_flags |= ARM_FLAG_APCS_32;\n     }\n   \n-  if (TARGET_THUMB_INTERWORK && !(flags & FL_THUMB))\n+  if (TARGET_THUMB_INTERWORK && !(insn_flags & FL_THUMB))\n     {\n       warning (\"target CPU does not support interworking\" );\n       target_flags &= ~ARM_FLAG_THUMB;\n@@ -388,52 +464,49 @@ arm_override_options ()\n       warning (\"-mapcs-stack-check incompatible with -mno-apcs-frame\");\n       target_flags |= ARM_FLAG_APCS_FRAME;\n     }\n-\n+  \n   if (write_symbols != NO_DEBUG && flag_omit_frame_pointer)\n     warning (\"-g with -fomit-frame-pointer may not give sensible debugging\");\n-\n+  \n   if (TARGET_POKE_FUNCTION_NAME)\n     target_flags |= ARM_FLAG_APCS_FRAME;\n-\n+  \n   if (TARGET_APCS_REENT && flag_pic)\n     fatal (\"-fpic and -mapcs-reent are incompatible\");\n-\n+  \n   if (TARGET_APCS_REENT)\n     warning (\"APCS reentrant code not supported.  Ignored\");\n-\n+  \n   /* If stack checking is disabled, we can use r10 as the PIC register,\n      which keeps r9 available.  */\n   if (flag_pic && ! TARGET_APCS_STACK)\n     arm_pic_register = 10;\n-\n+  \n   /* Well, I'm about to have a go, but pic is NOT going to be compatible\n      with APCS reentrancy, since that requires too much support in the\n      assembler and linker, and the ARMASM assembler seems to lack some\n      required directives.  */\n   if (flag_pic)\n     warning (\"Position independent code not supported\");\n-\n+  \n   if (TARGET_APCS_FLOAT)\n     warning (\"Passing floating point arguments in fp regs not yet supported\");\n-\n-  /* Initialise booleans used elsewhere in this file, and in arm.md  */\n-  arm_fast_multiply = (flags & FL_FAST_MULT) != 0;\n-  arm_arch4         = (flags & FL_ARCH4) != 0;\n-  arm_ld_sched      = (flags & FL_LDSCHED) != 0;\n-  arm_is_strong     = (flags & FL_STRONG);\n   \n-  /* The arm.md file needs to know if theprocessor is an ARM6 or an ARM7  */\n-  arm_is_6_or_7 = ((flags & (FL_MODE26 | FL_MODE32)) && !(flags & FL_ARCH4));\n+  /* Initialise boolean versions of the flags, for use in the arm.md file.  */\n+  arm_fast_multiply = insn_flags & FL_FAST_MULT;\n+  arm_arch4         = insn_flags & FL_ARCH4;\n+  \n+  arm_ld_sched      = tune_flags & FL_LDSCHED;\n+  arm_is_strong     = tune_flags & FL_STRONG;\n+  arm_is_6_or_7     = ((tune_flags & (FL_MODE26 | FL_MODE32))\n+\t\t       && !(tune_flags & FL_ARCH4));\n   \n   /* Default value for floating point code... if no co-processor\n      bus, then schedule for emulated floating point.  Otherwise,\n      assume the user has an FPA.\n      Note: this does not prevent use of floating point instructions,\n      -msoft-float does that.  */\n-  if ((flags & FL_CO_PROC) == 0)\n-    arm_fpu = FP_SOFT3;\n-  else\n-    arm_fpu = FP_HARD;\n+  arm_fpu = (tune_flags & FL_CO_PROC) ? FP_HARD : FP_SOFT3;\n   \n   if (target_fp_name)\n     {\n@@ -450,12 +523,12 @@ arm_override_options ()\n   \n   if (TARGET_FPE && arm_fpu != FP_HARD)\n     arm_fpu = FP_SOFT2;\n-\n+  \n   /* For arm2/3 there is no need to do any scheduling if there is only\n      a floating point emulator, or we are doing software floating-point.  */\n-  if ((TARGET_SOFT_FLOAT || arm_fpu != FP_HARD) && (flags & FL_MODE32) == 0)\n+  if ((TARGET_SOFT_FLOAT || arm_fpu != FP_HARD) && (tune_flags & FL_MODE32) == 0)\n     flag_schedule_insns = flag_schedule_insns_after_reload = 0;\n-\n+  \n   arm_prog_mode = TARGET_APCS_32 ? PROG_MODE_PROG32 : PROG_MODE_PROG26;\n   \n   if (structure_size_string != NULL)\n@@ -471,9 +544,9 @@ arm_override_options ()\n   /* If optimizing for space, don't synthesize constants.\n      For processors with load scheduling, it never costs more than 2 cycles\n      to load a constant, and the load scheduler may well reduce that to 1.  */\n-  if (optimize_size || (flags & FL_LDSCHED))\n+  if (optimize_size || (tune_flags & FL_LDSCHED))\n     arm_constant_limit = 1;\n-\n+  \n   /* If optimizing for size, bump the number of instructions that we\n      are prepared to conditionally execute (even on a StrongARM). \n      Otherwise for the StrongARM, which has early execution of branches,\n@@ -611,7 +684,11 @@ arm_split_constant (code, mode, val, target, source, subtargets)\n \t them in-line, regardless of the cost.  This is only likely to\n \t be more costly on chips that have load delay slots and we are\n \t compiling without running the scheduler (so no splitting\n-\t occurred before the final instruction emission.  */\n+\t occurred before the final instruction emission).\n+\n+\t Ref: gcc -O1 -mcpu=strongarm gcc.c-torture/compile/980506-2.c\n+\t      gcc -O0 -mcpu=strongarm plumhall/c/conform/exprtest/assign.c\n+      */\n       if (! after_arm_reorg\n \t  && (arm_gen_constant (code, mode, val, target, source, 1, 0)\n \t      > arm_constant_limit + (code != SET)))\n@@ -1671,7 +1748,7 @@ arm_rtx_costs (x, code, outer_code)\n \t  int add_cost = const_ok_for_arm (i) ? 4 : 8;\n \t  int j;\n \t  /* Tune as appropriate */ \n-\t  int booth_unit_size = (arm_fast_multiply ? 8 : 2);\n+\t  int booth_unit_size = ((tune_flags & FL_FAST_MULT) ? 8 : 2);\n \t  \n \t  for (j = 0; i && j < 32; j += booth_unit_size)\n \t    {\n@@ -1682,7 +1759,7 @@ arm_rtx_costs (x, code, outer_code)\n \t  return add_cost;\n \t}\n \n-      return ((arm_fast_multiply ? 8 : 30)\n+      return (((tune_flags & FL_FAST_MULT) ? 8 : 30)\n \t      + (REG_OR_SUBREG_REG (XEXP (x, 0)) ? 0 : 4)\n \t      + (REG_OR_SUBREG_REG (XEXP (x, 1)) ? 0 : 4));\n \n@@ -2227,7 +2304,7 @@ shift_operator (x, mode)\n       enum rtx_code code = GET_CODE (x);\n \n       if (code == MULT)\n-\treturn power_of_two_operand (XEXP (x, 1));\n+\treturn power_of_two_operand (XEXP (x, 1), mode);\n \n       return (code == ASHIFT || code == ASHIFTRT || code == LSHIFTRT\n \t      || code == ROTATERT);\n@@ -4317,7 +4394,7 @@ output_mov_double_arm_from_fpu (operands)\n \n char *\n output_move_double (operands)\n-     rtx *operands;\n+     rtx * operands;\n {\n   enum rtx_code code0 = GET_CODE (operands[0]);\n   enum rtx_code code1 = GET_CODE (operands[1]);\n@@ -4328,6 +4405,7 @@ output_move_double (operands)\n       int reg0 = REGNO (operands[0]);\n \n       otherops[0] = gen_rtx_REG (SImode, 1 + reg0);\n+      \n       if (code1 == REG)\n \t{\n \t  int reg1 = REGNO (operands[1]);\n@@ -4430,7 +4508,8 @@ output_move_double (operands)\n \t      break;\n \n \t    default:\n-\t      if (arm_add_operand (XEXP (XEXP (operands[1], 0), 1)))\n+\t      if (arm_add_operand (XEXP (XEXP (operands[1], 0), 1),\n+\t\t\t\t   GET_MODE (XEXP (XEXP (operands[1], 0), 1))))\n \t\t{\n \t\t  otherops[0] = operands[0];\n \t\t  otherops[1] = XEXP (XEXP (operands[1], 0), 0);"}, {"sha": "a150aba4087e5b35190c0fe40952c80172b267c1", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 138, "deletions": 117, "changes": 255, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aec3cfba19c324590612c95a33b14d4142a19823/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aec3cfba19c324590612c95a33b14d4142a19823/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=aec3cfba19c324590612c95a33b14d4142a19823", "patch": "@@ -823,12 +823,12 @@ enum reg_class\n /* Define which registers fit in which classes.\n    This is an initializer for a vector of HARD_REG_SET\n    of length N_REG_CLASSES.  */\n-#define REG_CLASS_CONTENTS  \\\n-{\t\t\t\t\\\n-  0x0000000, /* NO_REGS  */\t\\\n-  0x0FF0000, /* FPU_REGS */\t\\\n-  0x200FFFF, /* GENERAL_REGS */\t\\\n-  0x2FFFFFF  /* ALL_REGS */\t\\\n+#define REG_CLASS_CONTENTS  \t\t\\\n+{\t\t\t\t\t\\\n+  { 0x0000000 }, /* NO_REGS  */\t\t\\\n+  { 0x0FF0000 }, /* FPU_REGS */\t\t\\\n+  { 0x200FFFF }, /* GENERAL_REGS */\t\\\n+  { 0x2FFFFFF }  /* ALL_REGS */\t\t\\\n }\n \n /* The same information, inverted:\n@@ -1037,7 +1037,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n /* 1 if N is a possible register number for a function value.\n    On the ARM, only r0 and f0 can return results.  */\n #define FUNCTION_VALUE_REGNO_P(REGNO)  \\\n-  ((REGNO) == 0 || ((REGNO) == 16) && TARGET_HARD_FLOAT)\n+  ((REGNO) == 0 || (((REGNO) == 16) && TARGET_HARD_FLOAT))\n \n /* How large values are returned */\n /* A C expression which can inhibit the returning of certain function values\n@@ -1200,7 +1200,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n   else if ((FROM) == FRAME_POINTER_REGNUM\t\t\t\t\\\n \t   && (TO) == STACK_POINTER_REGNUM)\t\t\t\t\\\n     (OFFSET) = (current_function_outgoing_args_size\t\t\t\\\n-\t\t+ (get_frame_size () + 3 & ~3));\t\t\t\\\n+\t\t+ ((get_frame_size () + 3) & ~3));\t\t\t\\\n   else\t\t\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n       int regno;\t\t\t\t\t\t\t\\\n@@ -1226,7 +1226,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n \t       && (regs_ever_live[14] || saved_hard_reg)) \t\t\\\n \t     offset += 4;\t\t\t\t\t\t\\\n \t   offset += current_function_outgoing_args_size;\t\t\\\n-\t   (OFFSET) = (get_frame_size () + 3 & ~3) + offset;\t\t\\\n+\t   (OFFSET) = ((get_frame_size () + 3) & ~3) + offset;\t\t\\\n          }\t\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n }\n@@ -1784,12 +1784,10 @@ extern int arm_pic_register;\n   \"CC_DNE\", \"CC_DEQ\", \"CC_DLE\", \"CC_DLT\", \"CC_DGE\", \"CC_DGT\", \"CC_DLEU\", \\\n   \"CC_DLTU\", \"CC_DGEU\", \"CC_DGTU\", \"CC_C\"\n \n-enum machine_mode arm_select_cc_mode ();\n #define SELECT_CC_MODE(OP,X,Y)  arm_select_cc_mode ((OP), (X), (Y))\n \n #define REVERSIBLE_CC_MODE(MODE) ((MODE) != CCFPEmode)\n \n-enum rtx_code arm_canonicalize_comparison ();\n #define CANONICALIZE_COMPARISON(CODE,OP0,OP1)\t\t\t\\\n do\t\t\t\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\\\n@@ -2047,113 +2045,136 @@ do {\t\t\t\t\t\t\t\t\t\\\n      when running in 32 bit mode.  */\t\t\t\t\t\\\n   ((!TARGET_APCS_32) ? (GEN_INT (0x03fffffc)) : (GEN_INT (0xffffffff)))\n \n-/* Prototypes for arm.c -- actually, they aren't since the types aren't \n-   fully defined yet.  */\n-\n-void arm_override_options PROTO ((void));\n-int use_return_insn PROTO ((int));\n-int const_ok_for_arm (/* HOST_WIDE_INT */);\n-int const_ok_for_op (/* HOST_WIDE_INT, enum rtx_code, \n-\t\t\tenum machine_mode */);\n-int arm_split_constant (/* enum rtx_code, enum machine_mode, \n-\t\t\t   HOST_WIDE_INT, struct rtx_def *,\n-\t\t\t   struct rtx_def *, int */);\n-enum rtx_code arm_canonicalize_comparison (/* enum rtx_code, \n-\t\t\t\t\t      struct rtx_def ** */);\n-int arm_return_in_memory (/* union tree_node * */);\n-int legitimate_pic_operand_p (/* struct rtx_def * */);\n-struct rtx_def *legitimize_pic_address (/* struct rtx_def *, \n-\t\t\t\t\t   enum machine_mode,\n-\t\t\t\t\t   struct rtx_def * */);\n-int is_pic (/* struct rtx_def * */);\n-void arm_finalize_pic (/* void */);\n-int arm_rtx_costs (/* struct rtx_def *, enum rtx_code, enum rtx_code */);\n-int arm_adjust_cost (/* struct rtx_def *, struct rtx_def *, \n-\t\t\tstruct rtx_def *, int */);\n-int const_double_rtx_ok_for_fpu (/* struct rtx_def * */);\n-int neg_const_double_rtx_ok_for_fpu (/* struct rtx_def * */);\n-int s_register_operand (/* struct rtx_def *, enum machine_mode */);\n-int f_register_operand (/* struct rtx_def *, enum machine_mode */);\n-int reg_or_int_operand (/* struct rtx_def *, enum machine_mode */);\n-int reload_memory_operand (/* struct rtx_def *, enum machine_mode */);\n-int arm_rhs_operand (/* struct rtx_def *, enum machine_mode */);\n-int arm_rhsm_operand (/* struct rtx_def *, enum machine_mode */);\n-int arm_add_operand (/* struct rtx_def *, enum machine_mode */);\n-int arm_not_operand (/* struct rtx_def *, enum machine_mode */);\n-int offsettable_memory_operand (/* struct rtx_def *, enum machine_mode */);\n-int alignable_memory_operand (/* struct rtx_def *, enum machine_mode */);\n-int bad_signed_byte_operand (/* struct rtx_def *, enum machine_mode */);\n-int fpu_rhs_operand (/* struct rtx_def *, enum machine_mode */);\n-int fpu_add_operand (/* struct rtx_def *, enum machine_mode */);\n-int power_of_two_operand (/* struct rtx_def *, enum machine_mode */);\n-int di_operand (/* struct rtx_def *, enum machine_mode */);\n-int soft_df_operand (/* struct rtx_def *, enum machine_mode */);\n-int index_operand (/* struct rtx_def *, enum machine_mode */);\n-int const_shift_operand (/* struct rtx_def *, enum machine_mode */);\n-int shiftable_operator (/* struct rtx_def *, enum machine_mode */);\n-int shift_operator (/* struct rtx_def *, enum machine_mode */);\n-int equality_operator (/* struct rtx_def *, enum machine_mode */);\n-int minmax_operator (/* struct rtx_def *, enum machine_mode */);\n-int cc_register (/* struct rtx_def *, enum machine_mode */);\n-int dominant_cc_register (/* struct rtx_def *, enum machine_mode */);\n-int symbol_mentioned_p (/* struct rtx_def * */);\n-int label_mentioned_p (/* struct rtx_def * */);\n-enum rtx_code minmax_code (/* struct rtx_def * */);\n-int adjacent_mem_locations (/* struct rtx_def *, struct rtx_def * */);\n-int load_multiple_operation (/* struct rtx_def *, enum machine_mode */);\n-int store_multiple_operation (/* struct rtx_def *, enum machine_mode */);\n-int load_multiple_sequence (/* struct rtx_def **, int, int *, int *,\n-\t\t\t       HOST_WIDE_INT * */);\n-char *emit_ldm_seq (/* struct rtx_def **, int */);\n-int store_multiple_sequence (/* struct rtx_def **, int, int *, int *,\n-\t\t\t\tHOST_WIDE_INT * */);\n-char *emit_stm_seq (/* struct rtx_def **, int */);\n-int multi_register_push (/* struct rtx_def *, enum machine_mode */);\n-int arm_valid_machine_decl_attribute (/* union tree_node *, union tree_node *,\n-\t\t\t\t\t union tree_node *,\n-\t\t\t\t\t union tree_node * */);\n-struct rtx_def *arm_gen_load_multiple (/* int, int, struct rtx_def *, \n-\t\t\t\t\t  int, int, int, int, int */);\n-struct rtx_def *arm_gen_store_multiple (/* int, int, struct rtx_def *,\n-\t\t\t\t\t   int, int, int, int, int */);\n-int arm_gen_movstrqi (/* struct rtx_def ** */);\n-struct rtx_def *gen_rotated_half_load (/* struct rtx_def * */);\n-enum machine_mode arm_select_cc_mode (/* enum rtx_code, struct rtx_def *,\n-\t\t\t\t\t struct rtx_def * */);\n-struct rtx_def *gen_compare_reg (/* enum rtx_code, struct rtx_def *,\n-\t\t\t\t    struct rtx_def * */);\n-void arm_reload_in_hi (/* struct rtx_def ** */);\n-void arm_reload_out_hi (/* struct rtx_def ** */);\n-void arm_reorg (/* struct rtx_def * */);\n-char *fp_immediate_constant (/* struct rtx_def * */);\n-void print_multi_reg (/* FILE *, char *, int, int */);\n-char *output_call (/* struct rtx_def ** */);\n-char *output_call_mem (/* struct rtx_def ** */);\n-char *output_mov_long_double_fpu_from_arm (/* struct rtx_def ** */);\n-char *output_mov_long_double_arm_from_fpu (/* struct rtx_def ** */);\n-char *output_mov_long_double_arm_from_arm (/* struct rtx_def ** */);\n-char *output_mov_double_fpu_from_arm (/* struct rtx_def ** */);\n-char *output_mov_double_arm_from_fpu (/* struct rtx_def ** */);\n-char *output_move_double (/* struct rtx_def ** */);\n-char *output_mov_immediate (/* struct rtx_def ** */);\n-char *output_add_immediate (/* struct rtx_def ** */);\n-char *arithmetic_instr (/* struct rtx_def *, int */);\n-void output_ascii_pseudo_op (/* FILE *, unsigned char *, int */);\n-char *output_return_instruction (/* struct rtx_def *, int, int */);\n-int arm_volatile_func (/* void */);\n-void output_func_prologue (/* FILE *, int */);\n-void output_func_epilogue (/* FILE *, int */);\n-void arm_expand_prologue (/* void */);\n-void arm_print_operand (/* FILE *, struct rtx_def *, int */);\n-void final_prescan_insn (/* struct rtx_def *, struct rtx_def **, int */);\n+/* Prototypes for arm.c  */\n+\n+#ifdef BUFSIZ\t\t/* stdio.h has been included, ok to use FILE * */\n+#define STDIO_PROTO(ARGS) PROTO (ARGS)\n+#else\n+#define STDIO_PROTO(ARGS) ()\n+#endif\n+\n+#ifndef TREE_CODE\n+union tree_node;\n+#define Tree union tree_node *\n+#else\n+#define Tree tree\n+#endif\n+\n+#ifndef RTX_CODE\n+struct rtx_def;\n+#define Rtx struct rtx_def *\n+#else\n+#define Rtx rtx\n+#endif\n+\n+#ifndef HOST_WIDE_INT\n+#include \"hwint.h\"\n+#endif\n+#define Hint HOST_WIDE_INT\n+\n+#ifndef HAVE_MACHINE_MODES\n+#include \"machmode.h\"\n+#endif\n+#define Mmode enum machine_mode\n+\n+#ifdef RTX_CODE\n+#define RTX_CODE_PROTO(ARGS) PROTO (ARGS)\n+#else\n+#define RTX_CODE_PROTO(ARGS) ()\n+#endif\n+#define Rcode enum rtx_code\n+\n+void   arm_override_options PROTO ((void));\n+int    use_return_insn PROTO ((int));\n+int    const_ok_for_arm PROTO ((Hint));\n+int    const_ok_for_op RTX_CODE_PROTO ((Hint, Rcode, Mmode));\n+int    arm_split_constant RTX_CODE_PROTO ((Rcode, Mmode, Hint, Rtx, Rtx, int));\n+Rcode  arm_canonicalize_comparison RTX_CODE_PROTO ((Rcode,  Rtx *));\n+int    arm_return_in_memory PROTO ((Tree));\n+int    legitimate_pic_operand_p PROTO ((Rtx));\n+Rtx    legitimize_pic_address PROTO ((Rtx, Mmode, Rtx));\n+int    is_pic PROTO ((Rtx));\n+void   arm_finalize_pic PROTO ((void));\n+int    arm_rtx_costs RTX_CODE_PROTO ((Rtx, Rcode, Rcode));\n+int    arm_adjust_cost PROTO ((Rtx, Rtx, Rtx, int));\n+int    const_double_rtx_ok_for_fpu PROTO ((Rtx));\n+int    neg_const_double_rtx_ok_for_fpu PROTO ((Rtx));\n+int    s_register_operand PROTO ((Rtx, Mmode));\n+int    f_register_operand PROTO ((Rtx, Mmode));\n+int    reg_or_int_operand PROTO ((Rtx, Mmode));\n+int    reload_memory_operand PROTO ((Rtx, Mmode));\n+int    arm_rhs_operand PROTO ((Rtx, Mmode));\n+int    arm_rhsm_operand PROTO ((Rtx, Mmode));\n+int    arm_add_operand PROTO ((Rtx, Mmode));\n+int    arm_not_operand PROTO ((Rtx, Mmode));\n+int    offsettable_memory_operand PROTO ((Rtx, Mmode));\n+int    alignable_memory_operand PROTO ((Rtx, Mmode));\n+int    bad_signed_byte_operand PROTO ((Rtx, Mmode));\n+int    fpu_rhs_operand PROTO ((Rtx, Mmode));\n+int    fpu_add_operand PROTO ((Rtx, Mmode));\n+int    power_of_two_operand PROTO ((Rtx, Mmode));\n+int    di_operand PROTO ((Rtx, Mmode));\n+int    soft_df_operand PROTO ((Rtx, Mmode));\n+int    index_operand PROTO ((Rtx, Mmode));\n+int    const_shift_operand PROTO ((Rtx, Mmode));\n+int    shiftable_operator PROTO ((Rtx, Mmode));\n+int    shift_operator PROTO ((Rtx, Mmode));\n+int    equality_operator PROTO ((Rtx, Mmode));\n+int    minmax_operator PROTO ((Rtx, Mmode));\n+int    cc_register PROTO ((Rtx, Mmode));\n+int    dominant_cc_register PROTO ((Rtx, Mmode));\n+int    symbol_mentioned_p PROTO ((Rtx));\n+int    label_mentioned_p PROTO ((Rtx));\n+Rcode  minmax_code PROTO ((Rtx));\n+int    adjacent_mem_locations PROTO ((Rtx, Rtx));\n+int    load_multiple_operation PROTO ((Rtx, Mmode));\n+int    store_multiple_operation PROTO ((Rtx, Mmode));\n+int    load_multiple_sequence PROTO ((Rtx *, int, int *, int *, Hint *));\n+char * emit_ldm_seq PROTO ((Rtx *, int));\n+int    store_multiple_sequence PROTO ((Rtx *, int, int *, int *, Hint *));\n+char * emit_stm_seq PROTO ((Rtx *, int));\n+int    arm_valid_machine_decl_attribute PROTO ((Tree, Tree, Tree, Tree));\n+Rtx    arm_gen_load_multiple PROTO ((int, int, Rtx, int, int, int, int, int));\n+Rtx    arm_gen_store_multiple PROTO ((int, int, Rtx, int, int, int, int, int));\n+int    arm_gen_movstrqi PROTO ((Rtx *));\n+Rtx    gen_rotated_half_load PROTO ((Rtx));\n+Mmode  arm_select_cc_mode RTX_CODE_PROTO ((Rcode, Rtx, Rtx));\n+Rtx    gen_compare_reg RTX_CODE_PROTO ((Rcode, Rtx, Rtx, int));\n+void   arm_reload_in_hi PROTO ((Rtx *));\n+void   arm_reload_out_hi PROTO ((Rtx *));\n+void   arm_reorg PROTO ((Rtx));\n+char * fp_immediate_constant PROTO ((Rtx));\n+void   print_multi_reg STDIO_PROTO ((FILE *, char *, int, int));\n+char * output_call PROTO ((Rtx *));\n+char * output_call_mem PROTO ((Rtx *));\n+char * output_mov_long_double_fpu_from_arm PROTO ((Rtx *));\n+char * output_mov_long_double_arm_from_fpu PROTO ((Rtx *));\n+char * output_mov_long_double_arm_from_arm PROTO ((Rtx *));\n+char * output_mov_double_fpu_from_arm PROTO ((Rtx *));\n+char * output_mov_double_arm_from_fpu PROTO ((Rtx *));\n+char * output_move_double PROTO ((Rtx *));\n+char * output_mov_immediate PROTO ((Rtx *));\n+char * output_add_immediate PROTO ((Rtx *));\n+char * arithmetic_instr PROTO ((Rtx, int));\n+void   output_ascii_pseudo_op STDIO_PROTO ((FILE *, unsigned char *, int));\n+char * output_return_instruction PROTO ((Rtx, int, int));\n+int    arm_volatile_func PROTO ((void));\n+void   output_func_prologue STDIO_PROTO ((FILE *, int));\n+void   output_func_epilogue STDIO_PROTO ((FILE *, int));\n+void   arm_expand_prologue PROTO ((void));\n+void   arm_print_operand STDIO_PROTO ((FILE *, Rtx, int));\n+void   final_prescan_insn PROTO ((Rtx, Rtx *, int));\n+int    short_branch PROTO ((int, int));\n+void   assemble_align PROTO((int)); /* Used in arm.md, but defined in output.c */\n+int    multi_register_push PROTO ((Rtx, Mmode));\n #ifdef AOF_ASSEMBLER\n-struct rtx_def *aof_pic_entry (/* struct rtx_def * */);\n-void aof_dump_pic_table (/* FILE * */);\n-char *aof_text_section (/* void */);\n-char *aof_data_section (/* void */);\n-void aof_add_import (/* char * */);\n-void aof_delete_import (/* char * */);\n-void aof_dump_imports (/* FILE * */);\n+Rtx    aof_pic_entry PROTO ((Rtx));\n+void   aof_dump_pic_table STDIO_PROTO ((FILE *));\n+char * aof_text_section PROTO ((void));\n+char * aof_data_section PROTO ((void));\n+void   aof_add_import PROTO ((char *));\n+void   aof_delete_import PROTO ((char *));\n+void   aof_dump_imports STDIO_PROTO ((FILE *));\n #endif\n \n #endif /* __ARM_H__ */"}, {"sha": "c64857b7abe5912910b7addb8c51d05522a17e71", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aec3cfba19c324590612c95a33b14d4142a19823/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aec3cfba19c324590612c95a33b14d4142a19823/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=aec3cfba19c324590612c95a33b14d4142a19823", "patch": "@@ -2403,7 +2403,7 @@\n   \"arm_arch4\"\n   \"*\n   /* If the address is invalid, this will split the instruction into two. */\n-  if (bad_signed_byte_operand(operands[1], QImode))\n+  if (bad_signed_byte_operand (operands[1], QImode))\n     return \\\"#\\\";\n   return \\\"ldr%?sb\\\\t%0, %1\\\";\n \"\n@@ -2476,7 +2476,7 @@\n   \"arm_arch4\"\n   \"*\n   /* If the address is invalid, this will split the instruction into two. */\n-  if (bad_signed_byte_operand(operands[1], QImode))\n+  if (bad_signed_byte_operand (operands[1], QImode))\n     return \\\"#\\\";\n   return \\\"ldr%?sb\\\\t%0, %1\\\";\n \"\n@@ -2638,7 +2638,7 @@\n \n (define_insn \"*movsi_insn\"\n   [(set (match_operand:SI 0 \"general_operand\" \"=r,r,r,m\")\n-\t(match_operand:SI 1 \"general_operand\"  \"rI,K,mi,r\"))]\n+\t(match_operand:SI 1 \"general_operand\" \"rI,K,mi,r\"))]\n   \"register_operand (operands[0], SImode)\n    || register_operand (operands[1], SImode)\"\n   \"@\n@@ -2852,8 +2852,6 @@\n   \"\"\n   \"\n {\n-  rtx insn;\n-\n   if (! (reload_in_progress || reload_completed))\n     {\n       if (GET_CODE (operands[0]) == MEM)\n@@ -3068,7 +3066,6 @@\n \")\n \n ;; Pattern to recognise insn generated default case above\n-\n (define_insn \"*movhi_insn_arch4\"\n   [(set (match_operand:HI 0 \"general_operand\" \"=r,r,r,m\")\n \t(match_operand:HI 1 \"general_operand\"  \"rI,K,m,r\"))]\n@@ -3289,10 +3286,9 @@\n        || register_operand (operands[1], DFmode))\"\n   \"*\n {\n-  rtx ops[3];\n-\n   switch (which_alternative)\n     {\n+    default:\n     case 0: return \\\"ldm%?ia\\\\t%m1, %M0\\\\t%@ double\\\";\n     case 1: return \\\"stm%?ia\\\\t%m0, %M1\\\\t%@ double\\\";\n     case 2: case 3: case 4: return output_move_double (operands);\n@@ -3337,6 +3333,7 @@\n   \"*\n   switch (which_alternative)\n     {\n+    default:\n     case 0: return \\\"mvf%?e\\\\t%0, %1\\\";\n     case 1: return \\\"mnf%?e\\\\t%0, #%N1\\\";\n     case 2: return \\\"ldf%?e\\\\t%0, %1\\\";\n@@ -6223,7 +6220,6 @@\n   \"*\n {\n   char pattern[100];\n-  int i;\n \n   sprintf (pattern, \\\"sfmfd\\\\t%%1, %d, [%%m0]!\\\", XVECLEN (operands[2], 0));\n   output_asm_insn (pattern, operands);"}]}