{"sha": "d09c938561f6a1fe3fb6733b14ecc3877fe19d05", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDA5YzkzODU2MWY2YTFmZTNmYjY3MzNiMTRlY2MzODc3ZmUxOWQwNQ==", "commit": {"author": {"name": "John Carr", "email": "jfc@mit.edu", "date": "1998-04-21T13:51:41Z"}, "committer": {"name": "John Carr", "email": "jfc@gcc.gnu.org", "date": "1998-04-21T13:51:41Z"}, "message": "alias.c (mode_alias_check): New function.\n\n\t* alias.c (mode_alias_check): New function.\n\t(true_dependence, anti_dependence, output_dependence): Call\n\tmode_alias_check.\n\nFrom-SVN: r19357", "tree": {"sha": "85a798e956994997f7ff54250fc4d3d9c8011a5d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/85a798e956994997f7ff54250fc4d3d9c8011a5d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d09c938561f6a1fe3fb6733b14ecc3877fe19d05", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d09c938561f6a1fe3fb6733b14ecc3877fe19d05", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d09c938561f6a1fe3fb6733b14ecc3877fe19d05", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d09c938561f6a1fe3fb6733b14ecc3877fe19d05/comments", "author": {"login": "VoxSciurorum", "id": 60116679, "node_id": "MDQ6VXNlcjYwMTE2Njc5", "avatar_url": "https://avatars.githubusercontent.com/u/60116679?v=4", "gravatar_id": "", "url": "https://api.github.com/users/VoxSciurorum", "html_url": "https://github.com/VoxSciurorum", "followers_url": "https://api.github.com/users/VoxSciurorum/followers", "following_url": "https://api.github.com/users/VoxSciurorum/following{/other_user}", "gists_url": "https://api.github.com/users/VoxSciurorum/gists{/gist_id}", "starred_url": "https://api.github.com/users/VoxSciurorum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/VoxSciurorum/subscriptions", "organizations_url": "https://api.github.com/users/VoxSciurorum/orgs", "repos_url": "https://api.github.com/users/VoxSciurorum/repos", "events_url": "https://api.github.com/users/VoxSciurorum/events{/privacy}", "received_events_url": "https://api.github.com/users/VoxSciurorum/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f7554e8cffcd6f3f99c66e18b5af15311fbce2c3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7554e8cffcd6f3f99c66e18b5af15311fbce2c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f7554e8cffcd6f3f99c66e18b5af15311fbce2c3"}], "stats": {"total": 134, "additions": 85, "deletions": 49}, "files": [{"sha": "4d1586dd01a34a1000440dbd8ab11606584aada1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d09c938561f6a1fe3fb6733b14ecc3877fe19d05/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d09c938561f6a1fe3fb6733b14ecc3877fe19d05/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d09c938561f6a1fe3fb6733b14ecc3877fe19d05", "patch": "@@ -1,3 +1,9 @@\n+Tue Apr 21 16:36:01 1998  John Carr  <jfc@mit.edu>\n+\n+\t* alias.c (mode_alias_check): New function.\n+\t(true_dependence, anti_dependence, output_dependence): Call\n+\tmode_alias_check.\n+\n Tue Apr 21 12:05:32 1998  Jeffrey A Law  (law@cygnus.com)\n \n \t* c-common.c (type_for_mode): Handle TI types."}, {"sha": "bc0b49c2322900734ed7be7338b85957f486ddef", "filename": "gcc/alias.c", "status": "modified", "additions": 79, "deletions": 49, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d09c938561f6a1fe3fb6733b14ecc3877fe19d05/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d09c938561f6a1fe3fb6733b14ecc3877fe19d05/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=d09c938561f6a1fe3fb6733b14ecc3877fe19d05", "patch": "@@ -35,6 +35,7 @@ static int memrefs_conflict_p\t\tPROTO((int, rtx, int, rtx,\n static void record_set\t\t\tPROTO((rtx, rtx));\n static rtx find_base_term\t\tPROTO((rtx));\n static int base_alias_check\t\tPROTO((rtx, rtx));\n+static int mode_alias_check\t\tPROTO((rtx, rtx, int (*)(rtx)));\n \n /* Set up all info needed to perform alias analysis on memory references.  */\n \n@@ -633,7 +634,11 @@ base_alias_check (x, y)\n    align memory references, as is done on the Alpha.\n \n    Nice to notice that varying addresses cannot conflict with fp if no\n-   local variables had their addresses taken, but that's too hard now.  */\n+   local variables had their addresses taken, but that's too hard now.\n+\n+   TODO: (symbol_ref foo) can not alias (plus REG N) if N is a positive\n+   integer because REG would have to point outside of the object, which\n+   is not allowed in C or C++.  */\n \n \n static int\n@@ -815,6 +820,64 @@ memrefs_conflict_p (xsize, x, ysize, y, c)\n    generate aligned addresses from unaligned addresses, for instance, the\n    alpha storeqi_unaligned pattern.  */\n \n+\n+/* This subroutine implements the type and struct/varying part of the\n+   alias check.\n+\n+   Return 0 if the memory references can never alias.\n+   Return 1 if the values of the addresses should be checked.  */\n+\n+static int\n+mode_alias_check (x, y, varies)\n+     register rtx x, y;\n+     int (*varies) PROTO ((rtx));\n+{\n+  enum machine_mode x_mode = GET_MODE (x), y_mode = GET_MODE (y);\n+  rtx x_addr = XEXP (x, 0), y_addr = XEXP (y, 0);\n+  int x_varies, y_varies, x_struct, y_struct;\n+\n+  /* If either address is an AND then neither the mode check nor the\n+     struct/varying check is valid.  */\n+  if (GET_CODE (x_addr) == AND || GET_CODE (y_addr) == AND)\n+    return 1;\n+\n+  x_struct = MEM_IN_STRUCT_P (x);\n+  y_struct = MEM_IN_STRUCT_P (y);\n+\n+  /* QImode and BLKmode references can alias anything.  */\n+  if (x_mode == QImode || x_mode == BLKmode\n+      || y_mode == QImode || y_mode == BLKmode)\n+    return 1;\n+\n+  /* Otherwise, different modes can only alias if they are structure\n+     references.  gcc bitfield operations can access an entire word,\n+     but that word may also contain integers accessed directly.\n+\n+     ??? It appears that bitfield accesses can not be larger than\n+     word_mode?\n+     ??? Can complex modes alias their components? */\n+  if (x_mode != y_mode && ! (x_struct && y_struct))\n+    return 0;\n+\n+  /* Modes are the same or may alias.  */\n+\n+  /* No alias if one reference is a struct at a varying address and the\n+     other is a scalar at a fixed address.\n+\n+     If either reference is a varying scalar or a fixed struct nothing\n+     is known about aliasing.  */\n+  x_varies = varies (x_addr);\n+  if (x_struct != x_varies)\n+    return 1;\n+  y_varies = varies (y_addr);\n+  if (y_struct != y_varies)\n+    return 1;\n+\n+  /* Both are varying structs or fixed scalars.  Check that they are not\n+     the same type.  */\n+  return (x_struct == y_struct);\n+}\n+\n /* Read dependence: X is read after read in MEM takes place.  There can\n    only be a dependence here if both reads are volatile.  */\n \n@@ -853,40 +916,17 @@ true_dependence (mem, mem_mode, x, varies)\n   if (! base_alias_check (XEXP (x, 0), XEXP (mem, 0)))\n     return 0;\n \n+  if (! mode_alias_check (x, mem, varies))\n+    return 0;\n+\n   x_addr = canon_rtx (XEXP (x, 0));\n   mem_addr = canon_rtx (XEXP (mem, 0));\n \n   if (mem_mode == VOIDmode)\n     mem_mode = GET_MODE (mem);\n \n-  if (! memrefs_conflict_p (GET_MODE_SIZE (mem_mode), mem_addr,\n-\t\t\t    SIZE_FOR_MODE (x), x_addr, 0))\n-    return 0;\n-\n-  /* If both references are struct references, or both are not, nothing\n-     is known about aliasing.\n-\n-     If either reference is QImode or BLKmode, ANSI C permits aliasing.\n-\n-     If both addresses are constant, or both are not, nothing is known\n-     about aliasing.  */\n-  if (MEM_IN_STRUCT_P (x) == MEM_IN_STRUCT_P (mem)\n-      || mem_mode == QImode || mem_mode == BLKmode\n-      || GET_MODE (x) == QImode || GET_MODE (x) == BLKmode\n-      || GET_CODE (x_addr) == AND || GET_CODE (mem_addr) == AND\n-      || varies (x_addr) == varies (mem_addr))\n-    return 1;\n-\n-  /* One memory reference is to a constant address, one is not.\n-     One is to a structure, the other is not.\n-\n-     If either memory reference is a variable structure the other is a\n-     fixed scalar and there is no aliasing.  */\n-  if ((MEM_IN_STRUCT_P (mem) && varies (mem_addr))\n-      || (MEM_IN_STRUCT_P (x) && varies (x_addr)))\n-    return 0;\n-\n-  return 1;\n+  return memrefs_conflict_p (GET_MODE_SIZE (mem_mode), mem_addr,\n+\t\t\t     SIZE_FOR_MODE (x), x_addr, 0);\n }\n \n /* Anti dependence: X is written after read in MEM takes place.  */\n@@ -916,16 +956,11 @@ anti_dependence (mem, x)\n   x_addr = XEXP (x, 0);\n   mem_addr = XEXP (mem, 0);\n \n-  return (memrefs_conflict_p (SIZE_FOR_MODE (mem), mem_addr,\n-\t\t\t      SIZE_FOR_MODE (x), x_addr, 0)\n-\t  && ! (MEM_IN_STRUCT_P (mem) && rtx_addr_varies_p (mem)\n-\t\t&& GET_MODE (mem) != QImode\n-\t\t&& GET_CODE (mem_addr) != AND\n-\t\t&& ! MEM_IN_STRUCT_P (x) && ! rtx_addr_varies_p (x))\n-\t  && ! (MEM_IN_STRUCT_P (x) && rtx_addr_varies_p (x)\n-\t\t&& GET_MODE (x) != QImode\n-\t\t&& GET_CODE (x_addr) != AND\n-\t\t&& ! MEM_IN_STRUCT_P (mem) && ! rtx_addr_varies_p (mem)));\n+  if (! mode_alias_check (x, mem, rtx_varies_p))\n+    return 0;\n+\n+  return memrefs_conflict_p (SIZE_FOR_MODE (mem), mem_addr,\n+\t\t\t     SIZE_FOR_MODE (x), x_addr, 0);\n }\n \n /* Output dependence: X is written after store in MEM takes place.  */\n@@ -944,16 +979,11 @@ output_dependence (mem, x)\n   x = canon_rtx (x);\n   mem = canon_rtx (mem);\n \n-  return (memrefs_conflict_p (SIZE_FOR_MODE (mem), XEXP (mem, 0),\n-\t\t\t      SIZE_FOR_MODE (x), XEXP (x, 0), 0)\n-\t  && ! (MEM_IN_STRUCT_P (mem) && rtx_addr_varies_p (mem)\n-\t\t&& GET_MODE (mem) != QImode\n-\t\t&& GET_CODE (XEXP (mem, 0)) != AND\n-\t\t&& ! MEM_IN_STRUCT_P (x) && ! rtx_addr_varies_p (x))\n-\t  && ! (MEM_IN_STRUCT_P (x) && rtx_addr_varies_p (x)\n-\t\t&& GET_MODE (x) != QImode\n-\t\t&& GET_CODE (XEXP (x, 0)) != AND\n-\t\t&& ! MEM_IN_STRUCT_P (mem) && ! rtx_addr_varies_p (mem)));\n+  if (! mode_alias_check (x, mem, rtx_varies_p))\n+    return 0;\n+\n+  return memrefs_conflict_p (SIZE_FOR_MODE (mem), XEXP (mem, 0),\n+\t\t\t     SIZE_FOR_MODE (x), XEXP (x, 0), 0);\n }\n \n "}]}