{"sha": "e9e808584efc60a8d2de1327cc2217b33dae4b32", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTllODA4NTg0ZWZjNjBhOGQyZGUxMzI3Y2MyMjE3YjMzZGFlNGIzMg==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@freesoft.cz", "date": "1999-12-17T00:45:03Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "1999-12-17T00:45:03Z"}, "message": "i386.md (HI to SImode promoting splitters): Rewrite.\n\n\t* i386.md (HI to SImode promoting splitters): Rewrite.\n\t(pushsf mem peep2): New.\n\t(testhi to andhi peep2): Remove.\n\t* i386.h (x86_promote_QImode): New.\n\t(TARGET_PROMOTE_QImode): New.\n\t(PREDICATE_CODES): Add promotable_binary_operator.\n\t* i386.c (x86_promote_QImode0: New.\n\t(promotable_binary_operator): New.\n\t* i386-protos.h (promotable_binary_operator): New.\n\nFrom-SVN: r30985", "tree": {"sha": "992641373226966909b1c51495ad6577b0174238", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/992641373226966909b1c51495ad6577b0174238"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e9e808584efc60a8d2de1327cc2217b33dae4b32", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9e808584efc60a8d2de1327cc2217b33dae4b32", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e9e808584efc60a8d2de1327cc2217b33dae4b32", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9e808584efc60a8d2de1327cc2217b33dae4b32/comments", "author": null, "committer": null, "parents": [{"sha": "a1cbdd7f515eb1b2b444e3d1b5c8ac64df62042e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1cbdd7f515eb1b2b444e3d1b5c8ac64df62042e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a1cbdd7f515eb1b2b444e3d1b5c8ac64df62042e"}], "stats": {"total": 270, "additions": 153, "deletions": 117}, "files": [{"sha": "cef71f44ea7bbe0f4683a0cceba18a0286c5b550", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e808584efc60a8d2de1327cc2217b33dae4b32/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e808584efc60a8d2de1327cc2217b33dae4b32/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e9e808584efc60a8d2de1327cc2217b33dae4b32", "patch": "@@ -1,5 +1,15 @@\n Fri Dec 17 01:32:38 MET 1999  Jan Hubicka  <hubicka@freesoft.cz>\n \n+\t* i386.md (HI to SImode promoting splitters): Rewrite.\n+\t(pushsf mem peep2): New.\n+\t(testhi to andhi peep2): Remove.\n+\t* i386.h (x86_promote_QImode): New.\n+\t(TARGET_PROMOTE_QImode): New.\n+\t(PREDICATE_CODES): Add promotable_binary_operator.\n+\t* i386.c (x86_promote_QImode0: New.\n+\t(promotable_binary_operator): New.\n+\t* i386-protos.h (promotable_binary_operator): New.\n+\n \t* i386.md (test?i_1): Use \"nonmemory_operand\" predicate, simplify\n \tcondition.\n \t(one_cmpl?i*): Pass \"NOT\" to unary_operator_ok."}, {"sha": "d95dbb6669e58b76463186481ffe7d20903232c2", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e808584efc60a8d2de1327cc2217b33dae4b32/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e808584efc60a8d2de1327cc2217b33dae4b32/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=e9e808584efc60a8d2de1327cc2217b33dae4b32", "patch": "@@ -60,6 +60,7 @@ extern int binary_fp_operator PROTO((rtx, enum machine_mode));\n extern int mult_operator PROTO((rtx, enum machine_mode));\n extern int div_operator PROTO((rtx, enum machine_mode));\n extern int arith_or_logical_operator PROTO((rtx, enum machine_mode));\n+extern int promotable_binary_operator PROTO((rtx, enum machine_mode));\n extern int memory_displacement_operand PROTO((rtx, enum machine_mode));\n extern int cmpsi_operand PROTO((rtx, enum machine_mode));\n extern int long_memory_operand PROTO((rtx, enum machine_mode));"}, {"sha": "74d67c200093475fb93d82f851aaa3a4b9090c77", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e808584efc60a8d2de1327cc2217b33dae4b32/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e808584efc60a8d2de1327cc2217b33dae4b32/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=e9e808584efc60a8d2de1327cc2217b33dae4b32", "patch": "@@ -205,6 +205,7 @@ const int x86_use_cltd = ~(m_PENT | m_K6);\n const int x86_read_modify_write = ~m_PENT;\n const int x86_read_modify = ~(m_PENT | m_PPRO);\n const int x86_split_long_moves = m_PPRO;\n+const int x86_promote_QImode = m_K6 | m_PENT | m_386 | m_486;\n \n #define AT_BP(mode) (gen_rtx_MEM ((mode), frame_pointer_rtx))\n \n@@ -1177,6 +1178,30 @@ fcmov_comparison_operator (op, mode)\n \t  && GET_CODE (op) == unsigned_condition (GET_CODE (op)));\n }\n \n+/* Return 1 if OP is a binary operator that can be promoted to wider mode.  */\n+\n+int\n+promotable_binary_operator (op, mode)\n+     register rtx op;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n+{\n+  switch (GET_CODE (op))\n+    {\n+    case MULT:\n+      /* Modern CPUs have same latency for HImode and SImode multiply,\n+         but 386 and 486 do HImode multiply faster.  */\n+      return ix86_cpu > PROCESSOR_I486;\n+    case PLUS:\n+    case AND:\n+    case IOR:\n+    case XOR:\n+    case ASHIFT:\n+      return 1;\n+    default:\n+      return 0;\n+    }\n+}\n+\n /* Nearly general operand, but accept any const_double, since we wish\n    to be able to drop them into memory rather than have them get pulled\n    into registers.  */"}, {"sha": "7cdfe37bc3626bbffc645396aa13a1e7e40c2522", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e808584efc60a8d2de1327cc2217b33dae4b32/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e808584efc60a8d2de1327cc2217b33dae4b32/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=e9e808584efc60a8d2de1327cc2217b33dae4b32", "patch": "@@ -161,6 +161,7 @@ extern const int x86_double_with_add, x86_partial_reg_stall, x86_movx;\n extern const int x86_use_loop, x86_use_fiop, x86_use_mov0;\n extern const int x86_use_cltd, x86_read_modify_write;\n extern const int x86_read_modify, x86_split_long_moves;\n+extern const int x86_promote_QImode;\n \n #define TARGET_USE_LEAVE (x86_use_leave & CPUMASK)\n #define TARGET_PUSH_MEMORY (x86_push_memory & CPUMASK)\n@@ -182,6 +183,7 @@ extern const int x86_read_modify, x86_split_long_moves;\n #define TARGET_SPLIT_LONG_MOVES (x86_split_long_moves & CPUMASK)\n #define TARGET_READ_MODIFY_WRITE (x86_read_modify_write & CPUMASK)\n #define TARGET_READ_MODIFY (x86_read_modify & CPUMASK)\n+#define TARGET_PROMOTE_QImode (x86_promote_QImode & CPUMASK)\n \n #define TARGET_STACK_PROBE (target_flags & MASK_STACK_PROBE)\n \n@@ -2437,6 +2439,7 @@ do { long l;\t\t\t\t\t\t\\\n \t\t\t\t UMIN, UMAX, COMPARE, MINUS, DIV, MOD,\t\\\n \t\t\t\t UDIV, UMOD, ASHIFT, ROTATE, ASHIFTRT,\t\\\n \t\t\t\t LSHIFTRT, ROTATERT}},\t\t\t\\\n+  {\"promotable_binary_operator\", {PLUS, MULT, AND, IOR, XOR, ASHIFT}},\t\\\n   {\"memory_displacement_operand\", {MEM}},\t\t\t\t\\\n   {\"cmpsi_operand\", {CONST_INT, CONST_DOUBLE, CONST, SYMBOL_REF,\t\\\n \t\t     LABEL_REF, SUBREG, REG, MEM, AND}},\t\t\\"}, {"sha": "bd2304fe568a918add9bef5d4b0d8b84b73c3ead", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 114, "deletions": 117, "changes": 231, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e808584efc60a8d2de1327cc2217b33dae4b32/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e808584efc60a8d2de1327cc2217b33dae4b32/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=e9e808584efc60a8d2de1327cc2217b33dae4b32", "patch": "@@ -3344,19 +3344,6 @@\n \t(const_string \"incdec\")\n \t(const_string \"alu\")))])\n \n-;; If we know we're not touching memory, promote HImode references to SImode.\n-(define_split\n-  [(set (match_operand:HI 0 \"register_operand\" \"\")\n-\t(plus:HI (match_operand:HI 1 \"register_operand\" \"\")\n-\t\t (match_operand:HI 2 \"nonmemory_operand\" \"\")))\n-   (clobber (reg:CC 17))]\n-  \"! TARGET_PARTIAL_REG_STALL && reload_completed\"\n-  [(parallel [(set (match_dup 0) (plus:SI (match_dup 1) (match_dup 2)))\n-\t      (clobber (reg:CC 17))])]\n-  \"operands[0] = gen_lowpart (SImode, operands[0]);\n-   operands[1] = gen_lowpart (SImode, operands[1]);\n-   operands[2] = gen_lowpart (SImode, operands[2]);\")\n-\n (define_insn \"*addhi_2\"\n   [(set (reg:CCNO 17)\n \t(compare:CCNO\n@@ -4456,18 +4443,6 @@\n }\"\n   [(set_attr \"type\" \"alu,alu,imovx\")])\n \n-(define_split\n-  [(set (match_operand:HI 0 \"register_operand\" \"\")\n-\t(and:HI (match_operand:HI 1 \"register_operand\" \"\")\n-\t\t(match_operand:HI 2 \"nonmemory_operand\" \"\")))\n-   (clobber (reg:CC 17))]\n-  \"! TARGET_PARTIAL_REG_STALL && reload_completed\"\n-  [(parallel [(set (match_dup 0) (and:SI (match_dup 1) (match_dup 2)))\n-\t      (clobber (reg:CC 17))])]\n-  \"operands[0] = gen_lowpart (SImode, operands[0]);\n-   operands[1] = gen_lowpart (SImode, operands[1]);\n-   operands[2] = gen_lowpart (SImode, operands[2]);\")\n-\n (define_insn \"*andhi_2\"\n   [(set (reg:CCNO 17)\n \t(compare:CCNO (and:HI (match_operand:HI 1 \"nonimmediate_operand\" \"%0,0\")\n@@ -4479,23 +4454,6 @@\n   \"and{w}\\\\t{%2, %0|%0, %2}\"\n   [(set_attr \"type\" \"alu\")])\n \n-(define_split\n-  [(set (reg:CCNO 17)\n-\t(compare:CCNO (and:HI (match_operand:HI 1 \"register_operand\" \"\")\n-\t\t\t      (match_operand:HI 2 \"immediate_operand\" \"\"))\n-\t\t      (const_int 0)))\n-   (set (match_operand:HI 0 \"register_operand\" \"\")\n-\t(and:HI (match_dup 1) (match_dup 2)))]\n-  \"! TARGET_PARTIAL_REG_STALL && reload_completed\"\n-  [(parallel [(set (reg:CCNO 17)\n-\t\t   (compare:CCNO (and:SI (match_dup 1) (match_dup 2))\n-\t\t\t         (const_int 0)))\n-\t      (set (match_dup 0)\n-\t\t   (and:SI (match_dup 1) (match_dup 2)))])]\n-  \"operands[0] = gen_lowpart (SImode, operands[0]);\n-   operands[1] = gen_lowpart (SImode, operands[1]);\n-   operands[2] = gen_lowpart (SImode, operands[2]);\")\n-\n (define_expand \"andqi3\"\n   [(set (match_operand:QI 0 \"nonimmediate_operand\" \"\")\n \t(and:QI (match_operand:QI 1 \"nonimmediate_operand\" \"\")\n@@ -4661,18 +4619,6 @@\n   \"or{w}\\\\t{%2, %0|%0, %2}\"\n   [(set_attr \"type\" \"alu\")])\n \n-(define_split\n-  [(set (match_operand:HI 0 \"register_operand\" \"\")\n-\t(ior:HI (match_operand:HI 1 \"register_operand\" \"\")\n-\t\t(match_operand:HI 2 \"nonmemory_operand\" \"\")))\n-   (clobber (reg:CC 17))]\n-  \"! TARGET_PARTIAL_REG_STALL && reload_completed\"\n-  [(parallel [(set (match_dup 0) (ior:SI (match_dup 1) (match_dup 2)))\n-\t      (clobber (reg:CC 17))])]\n-  \"operands[0] = gen_lowpart (SImode, operands[0]);\n-   operands[1] = gen_lowpart (SImode, operands[1]);\n-   operands[2] = gen_lowpart (SImode, operands[2]);\")\n-\n (define_insn \"*iorhi_2\"\n   [(set (reg:CCNO 17)\n \t(compare:CCNO (ior:HI (match_operand:HI 1 \"nonimmediate_operand\" \"%0,0\")\n@@ -4766,18 +4712,6 @@\n   \"xor{w}\\\\t{%2, %0|%0, %2}\"\n   [(set_attr \"type\" \"alu\")])\n \n-(define_split\n-  [(set (match_operand:HI 0 \"register_operand\" \"\")\n-\t(xor:HI (match_operand:HI 1 \"register_operand\" \"\")\n-\t\t(match_operand:HI 2 \"nonmemory_operand\" \"\")))\n-   (clobber (reg:CC 17))]\n-  \"! TARGET_PARTIAL_REG_STALL && reload_completed\"\n-  [(parallel [(set (match_dup 0) (xor:SI (match_dup 1) (match_dup 2)))\n-\t      (clobber (reg:CC 17))])]\n-  \"operands[0] = gen_lowpart (SImode, operands[0]);\n-   operands[1] = gen_lowpart (SImode, operands[1]);\n-   operands[2] = gen_lowpart (SImode, operands[2]);\")\n-\n (define_insn \"*xorhi_2\"\n   [(set (reg:CCNO 17)\n \t(compare:CCNO (xor:HI (match_operand:HI 1 \"nonimmediate_operand\" \"%0,0\")\n@@ -5396,16 +5330,6 @@\n   \"not{w}\\\\t%0\"\n   [(set_attr \"type\" \"negnot\")])\n \n-(define_split\n-  [(set (match_operand:HI 0 \"register_operand\" \"\")\n-\t(not:HI (match_operand:HI 1 \"register_operand\" \"\")))\n-   (clobber (reg:CC 17))]\n-  \"! TARGET_PARTIAL_REG_STALL && reload_completed\"\n-  [(parallel [(set (match_dup 0) (not:SI (match_dup 1)))\n-\t      (clobber (reg:CC 17))])]\n-  \"operands[0] = gen_lowpart (SImode, operands[0]);\n-   operands[1] = gen_lowpart (SImode, operands[1]);\")\n-\n (define_insn \"*one_cmplhi2_2\"\n   [(set (reg:CCNO 17)\n \t(compare:CCNO (not:HI (match_operand:HI 1 \"nonimmediate_operand\" \"0\"))\n@@ -5746,17 +5670,6 @@\n \t   ]\n \t   (const_string \"ishift\")))])\n \n-(define_split\n-  [(set (match_operand:HI 0 \"register_operand\" \"\")\n-\t(ashift:HI (match_operand:HI 1 \"register_operand\" \"\")\n-\t\t   (match_operand:QI 2 \"nonmemory_operand\" \"\")))\n-   (clobber (reg:CC 17))]\n-  \"! TARGET_PARTIAL_REG_STALL && reload_completed\"\n-  [(parallel [(set (match_dup 0) (ashift:SI (match_dup 1) (match_dup 2)))\n-\t      (clobber (reg:CC 17))])]\n-  \"operands[0] = gen_lowpart (SImode, operands[0]);\n-   operands[1] = gen_lowpart (SImode, operands[1]);\")\n-\n (define_insn \"*ashlhi3_cmpno\"\n   [(set (reg:CCNO 17)\n \t(compare:CCNO\n@@ -8277,19 +8190,6 @@\n    cmov%c1\\\\t{%3, %0|%0, %3}\"\n   [(set_attr \"type\" \"icmov\")])\n \n-(define_split \n-  [(set (match_operand:HI 0 \"register_operand\" \"\")\n-\t(if_then_else:HI (match_operator 1 \"comparison_operator\" \n-\t\t\t\t[(reg 17) (const_int 0)])\n-\t\t      (match_operand:HI 2 \"register_operand\" \"\")\n-\t\t      (match_operand:HI 3 \"register_operand\" \"\")))]\n-  \"! TARGET_PARTIAL_REG_STALL && TARGET_CMOVE\"\n-  [(set (match_dup 0)\n-\t(if_then_else:SI (match_dup 1) (match_dup 2) (match_dup 3)))]\n-  \"operands[0] = gen_lowpart (SImode, operands[0]);\n-   operands[2] = gen_lowpart (SImode, operands[2]);\n-   operands[3] = gen_lowpart (SImode, operands[3]);\")\n-\t\t\t\n (define_expand \"movsfcc\"\n   [(set (match_operand:SF 0 \"register_operand\" \"\")\n \t(if_then_else:SF (match_operand 1 \"comparison_operator\" \"\")\n@@ -8435,6 +8335,107 @@\n   load_pic_register ();\n   DONE;\n }\")\n+\f\n+;; Avoid redundant prefixes by splitting HImode arithmetic to SImode.\n+\n+(define_split\n+  [(set (match_operand 0 \"register_operand\" \"\")\n+\t(match_operator 3 \"promotable_binary_operator\"\n+\t   [(match_operand 1 \"register_operand\" \"\")\n+\t    (match_operand 2 \"nonmemory_operand\" \"\")]))\n+   (clobber (reg:CC 17))]\n+  \"! TARGET_PARTIAL_REG_STALL && reload_completed\n+   && ((GET_MODE (operands[0]) == HImode \n+\t&& (!optimize_size || GET_CODE (operands[2]) != CONST_INT\n+\t    || CONST_OK_FOR_LETTER_P (INTVAL (operands[2]), 'K')))\n+       || (GET_MODE (operands[0]) == QImode \n+\t   && (TARGET_PROMOTE_QImode || optimize_size)))\"\n+  [(parallel [(set (match_dup 0)\n+\t\t   (match_op_dup 3 [(match_dup 1) (match_dup 2)]))\n+\t      (clobber (reg:CC 17))])]\n+  \"operands[0] = gen_lowpart (SImode, operands[0]);\n+   operands[1] = gen_lowpart (SImode, operands[1]);\n+   if (GET_CODE (operands[3]) != ASHIFT)\n+     operands[2] = gen_lowpart (SImode, operands[2]);\n+   GET_MODE (operands[3]) = SImode;\")\n+\n+(define_split\n+  [(set (reg:CCNO 17)\n+\t(compare:CCNO (and (match_operand 1 \"register_operand\" \"\")\n+\t\t\t   (match_operand 2 \"immediate_operand\" \"\"))\n+\t\t      (const_int 0)))\n+   (set (match_operand 0 \"register_operand\" \"\")\n+\t(and (match_dup 1) (match_dup 2)))]\n+  \"! TARGET_PARTIAL_REG_STALL && reload_completed\n+   && (GET_MODE (operands[0]) == HImode\n+       || (GET_MODE (operands[0]) == QImode \n+\t   && (TARGET_PROMOTE_QImode || optimize_size)))\"\n+  [(parallel [(set (reg:CCNO 17)\n+\t\t   (compare:CCNO (and:SI (match_dup 1) (match_dup 2))\n+\t\t\t         (const_int 0)))\n+\t      (set (match_dup 0)\n+\t\t   (and:SI (match_dup 1) (match_dup 2)))])]\n+  \"operands[0] = gen_lowpart (SImode, operands[0]);\n+   operands[1] = gen_lowpart (SImode, operands[1]);\n+   operands[2] = gen_lowpart (SImode, operands[2]);\")\n+\n+(define_split\n+  [(set (reg:CCNO 17)\n+\t(compare:CCNO (and (match_operand 0 \"register_operand\" \"\")\n+\t\t\t   (match_operand 1 \"immediate_operand\" \"\"))\n+\t\t      (const_int 0)))]\n+  \"! TARGET_PARTIAL_REG_STALL && reload_completed\n+   && (GET_MODE (operands[0]) == HImode\n+       || (GET_MODE (operands[0]) == QImode \n+\t   && (TARGET_PROMOTE_QImode || optimize_size)))\"\n+  [(set (reg:CCNO 17)\n+\t(compare:CCNO (and:SI (match_dup 0) (match_dup 1))\n+\t\t      (const_int 0)))]\n+  \"operands[0] = gen_lowpart (SImode, operands[0]);\n+   operands[1] = gen_lowpart (SImode, operands[1]);\")\n+\n+(define_split\n+  [(set (match_operand 0 \"register_operand\" \"\")\n+\t(neg (match_operand 1 \"register_operand\" \"\")))\n+   (clobber (reg:CC 17))]\n+  \"! TARGET_PARTIAL_REG_STALL && reload_completed\n+   && (GET_MODE (operands[0]) == HImode\n+       || (GET_MODE (operands[0]) == QImode \n+\t   && (TARGET_PROMOTE_QImode || optimize_size)))\"\n+  [(parallel [(set (match_dup 0)\n+\t\t   (neg:SI (match_dup 1)))\n+\t      (clobber (reg:CC 17))])]\n+  \"operands[0] = gen_lowpart (SImode, operands[0]);\n+   operands[1] = gen_lowpart (SImode, operands[1]);\")\n+\n+(define_split\n+  [(set (match_operand 0 \"register_operand\" \"\")\n+\t(not (match_operand 1 \"register_operand\" \"\")))]\n+  \"! TARGET_PARTIAL_REG_STALL && reload_completed\n+   && (GET_MODE (operands[0]) == HImode\n+       || (GET_MODE (operands[0]) == QImode \n+\t   && (TARGET_PROMOTE_QImode || optimize_size)))\"\n+  [(set (match_dup 0)\n+\t(not:SI (match_dup 1)))]\n+  \"operands[0] = gen_lowpart (SImode, operands[0]);\n+   operands[1] = gen_lowpart (SImode, operands[1]);\")\n+\n+(define_split \n+  [(set (match_operand 0 \"register_operand\" \"\")\n+\t(if_then_else (match_operator 1 \"comparison_operator\" \n+\t\t\t\t[(reg 17) (const_int 0)])\n+\t\t      (match_operand 2 \"register_operand\" \"\")\n+\t\t      (match_operand 3 \"register_operand\" \"\")))]\n+  \"! TARGET_PARTIAL_REG_STALL && TARGET_CMOVE\n+   && (GET_MODE (operands[0]) == HImode\n+       || (GET_MODE (operands[0]) == QImode \n+\t   && (TARGET_PROMOTE_QImode || optimize_size)))\"\n+  [(set (match_dup 0)\n+\t(if_then_else:SI (match_dup 1) (match_dup 2) (match_dup 3)))]\n+  \"operands[0] = gen_lowpart (SImode, operands[0]);\n+   operands[2] = gen_lowpart (SImode, operands[2]);\n+   operands[3] = gen_lowpart (SImode, operands[3]);\")\n+\t\t\t\n \f\n ;; RTL Peephole optimizations, run before sched2.  These primarily look to\n ;; transform a complex memory operation into two memory to register operations.\n@@ -8449,6 +8450,17 @@\n    (set (match_dup 0) (match_dup 2))]\n   \"\")\n \n+;; We need to handle SFmode only, because DFmode and XFmode is split to\n+;; SImode pushes.\n+(define_peephole2\n+  [(set (match_operand:SF 0 \"push_operand\" \"\")\n+\t(match_operand:SF 1 \"memory_operand\" \"\"))\n+   (match_scratch:SF 2 \"r\")]\n+  \"! optimize_size && ! TARGET_PUSH_MEMORY\"\n+  [(set (match_dup 2) (match_dup 1))\n+   (set (match_dup 0) (match_dup 2))]\n+  \"\")\n+\n (define_peephole2\n   [(set (match_operand:HI 0 \"push_operand\" \"\")\n \t(match_operand:HI 1 \"memory_operand\" \"\"))\n@@ -8626,23 +8638,8 @@\n \t   (and:SI (match_dup 0) (match_dup 1)))])]\n   \"\")\n \n-(define_peephole2\n-  [(set (reg:CCNO 17)\n-\t(compare:CCNO (and:HI (match_operand:HI 0 \"register_operand\" \"\")\n-\t\t\t      (match_operand:HI 1 \"immediate_operand\" \"\"))\n-\t\t      (const_int 0)))]\n-  \"! TARGET_PARTIAL_REG_STALL\n-   && (true_regnum (operands[0]) != 0\n-       || CONST_OK_FOR_LETTER_P (INTVAL (operands[1]), 'K'))\n-   && find_regno_note (insn, REG_DEAD, true_regnum (operands[0]))\"\n-  [(parallel\n-     [(set (reg:CCNO 17)\n-\t   (compare:CCNO (and:HI (match_dup 0)\n-\t\t\t         (match_dup 1))\n-\t\t         (const_int 0)))\n-      (set (match_dup 0)\n-\t   (and:HI (match_dup 0) (match_dup 1)))])]\n-  \"\")\n+;; We don't need to handle HImode case, because it will be promoted to SImode\n+;; on ! TARGET_PARTIAL_REG_STALL\n \n (define_peephole2\n   [(set (reg:CCNO 17)"}]}