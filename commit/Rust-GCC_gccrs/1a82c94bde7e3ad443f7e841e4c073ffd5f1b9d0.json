{"sha": "1a82c94bde7e3ad443f7e841e4c073ffd5f1b9d0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWE4MmM5NGJkZTdlM2FkNDQzZjdlODQxZTRjMDczZmZkNWYxYjlkMA==", "commit": {"author": {"name": "Artur Biesiadowski", "email": "abies@pg.gda.pl", "date": "2003-01-02T21:01:24Z"}, "committer": {"name": "Mark Wielaard", "email": "mark@gcc.gnu.org", "date": "2003-01-02T21:01:24Z"}, "message": "ZipFile.java (entries): Now HashMap.\n\n\t* java/util/zip/ZipFile.java (entries): Now HashMap.\n\t(readLeShort(DataInput, byte[])): Read from given byte array.\n\t(readLeInt(DataInput, byte[]): Likewise.\n\t(readLeShort(byte[] b, int off)): New method.\n\t(readLeInt(byte[] b, int off)): Likewise.\n\t(readEntries): Use byte arrays to read info in bigger chunks.\n\t(getEntries): Return HashMap.\n\t(getEntry): Use HashMap.\n\t(locBuf): New private field.\n\t(checkLocalHeader): Use locBuf to read info in one chunk.\n\t(getInputStream): Use entries HashMap, wrap PartialInputStream\n\tin BufferedInputStream.\n\t(ZipEntryEnumeration): Use HashMap and Interator.\n\nCo-Authored-By: Mark Wielaard <mark@klomp.org>\n\nFrom-SVN: r60803", "tree": {"sha": "3561bff61d37cdf84f2ae6eadbbbfaac40e0503e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3561bff61d37cdf84f2ae6eadbbbfaac40e0503e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1a82c94bde7e3ad443f7e841e4c073ffd5f1b9d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a82c94bde7e3ad443f7e841e4c073ffd5f1b9d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a82c94bde7e3ad443f7e841e4c073ffd5f1b9d0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a82c94bde7e3ad443f7e841e4c073ffd5f1b9d0/comments", "author": null, "committer": null, "parents": [{"sha": "1092805d387f6aa958ae2c7e26831a5ad511bb80", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1092805d387f6aa958ae2c7e26831a5ad511bb80", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1092805d387f6aa958ae2c7e26831a5ad511bb80"}], "stats": {"total": 194, "additions": 130, "deletions": 64}, "files": [{"sha": "2d1b238e9c5a22379e262ff81e3d2f6ab4b0d689", "filename": "libjava/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a82c94bde7e3ad443f7e841e4c073ffd5f1b9d0/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a82c94bde7e3ad443f7e841e4c073ffd5f1b9d0/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=1a82c94bde7e3ad443f7e841e4c073ffd5f1b9d0", "patch": "@@ -1,3 +1,20 @@\n+2003-01-02  Artur Biesiadowski  <abies@pg.gda.pl>\n+\t    Mark Wielaard  <mark@klomp.org>\n+\n+\t* java/util/zip/ZipFile.java (entries): Now HashMap.\n+\t(readLeShort(DataInput, byte[])): Read from given byte array.\n+\t(readLeInt(DataInput, byte[]): Likewise.\n+\t(readLeShort(byte[] b, int off)): New method.\n+\t(readLeInt(byte[] b, int off)): Likewise.\n+\t(readEntries): Use byte arrays to read info in bigger chunks.\n+\t(getEntries): Return HashMap.\n+\t(getEntry): Use HashMap.\n+\t(locBuf): New private field.\n+\t(checkLocalHeader): Use locBuf to read info in one chunk.\n+\t(getInputStream): Use entries HashMap, wrap PartialInputStream\n+\tin BufferedInputStream.\n+\t(ZipEntryEnumeration): Use HashMap and Interator.\n+\n 2003-01-02  Mark Wielaard  <mark@klomp.org>\n \t    Jeroen Frijters  <jeroen@sumatra.nl>\n "}, {"sha": "4b027b088a99ce650b95e824ba0feb9cef79b6bf", "filename": "libjava/java/util/zip/ZipFile.java", "status": "modified", "additions": 113, "deletions": 64, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a82c94bde7e3ad443f7e841e4c073ffd5f1b9d0/libjava%2Fjava%2Futil%2Fzip%2FZipFile.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a82c94bde7e3ad443f7e841e4c073ffd5f1b9d0/libjava%2Fjava%2Futil%2Fzip%2FZipFile.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2Fzip%2FZipFile.java?ref=1a82c94bde7e3ad443f7e841e4c073ffd5f1b9d0", "patch": "@@ -1,5 +1,5 @@\n /* java.util.zip.ZipFile\n-   Copyright (C) 2001, 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -37,6 +37,7 @@\n \n package java.util.zip;\n \n+import java.io.BufferedInputStream;\n import java.io.ByteArrayInputStream;\n import java.io.DataInput;\n import java.io.DataInputStream;\n@@ -46,7 +47,8 @@\n import java.io.EOFException;\n import java.io.RandomAccessFile;\n import java.util.Enumeration;\n-import java.util.Hashtable;\n+import java.util.HashMap;\n+import java.util.Iterator;\n import java.util.NoSuchElementException;\n \n /**\n@@ -58,6 +60,7 @@\n  * entries in different threads.\n  *\n  * @author Jochen Hoenicke\n+ * @author Artur Biesiadowski\n  */\n public class ZipFile implements ZipConstants\n {\n@@ -79,7 +82,7 @@ public class ZipFile implements ZipConstants\n   private final RandomAccessFile raf;\n \n   // The entries of this zip file when initialized and not yet closed.\n-  private Hashtable entries;\n+  private HashMap entries;\n \n   private boolean closed = false;\n \n@@ -137,33 +140,74 @@ public ZipFile(File file, int mode) throws ZipException, IOException\n   }\n \n   /**\n-   * Read an unsigned short in little endian byte order.\n+   * Read an unsigned short in little endian byte order from the given\n+   * DataInput stream using the given byte buffer.\n+   *\n+   * @param di DataInput stream to read from.\n+   * @param b the byte buffer to read in (must be at least 2 bytes long).\n+   * @return The value read.\n+   *\n    * @exception IOException if a i/o error occured.\n    * @exception EOFException if the file ends prematurely\n    */\n-  private final int readLeShort(DataInput di) throws IOException\n+  private final int readLeShort(DataInput di, byte[] b) throws IOException\n   {\n-    byte[] b = new byte[2];\n-    di.readFully(b);\n+    di.readFully(b, 0, 2);\n     return (b[0] & 0xff) | (b[1] & 0xff) << 8;\n   }\n \n   /**\n-   * Read an int in little endian byte order.\n+   * Read an int in little endian byte order from the given\n+   * DataInput stream using the given byte buffer.\n+   *\n+   * @param di DataInput stream to read from.\n+   * @param b the byte buffer to read in (must be at least 4 bytes long).\n+   * @return The value read.\n+   *\n    * @exception IOException if a i/o error occured.\n    * @exception EOFException if the file ends prematurely\n    */\n-  private final int readLeInt(DataInput di) throws IOException\n+  private final int readLeInt(DataInput di, byte[] b) throws IOException\n   {\n-    byte[] b = new byte[4];\n-    di.readFully(b);\n+    di.readFully(b, 0, 4);\n     return ((b[0] & 0xff) | (b[1] & 0xff) << 8)\n \t    | ((b[2] & 0xff) | (b[3] & 0xff) << 8) << 16;\n   }\n \n+  \n+  /**\n+   * Read an unsigned short in little endian byte order from the given\n+   * byte buffer at the given offset.\n+   *\n+   * @param b the byte array to read from.\n+   * @param off the offset to read from.\n+   * @return The value read.\n+   */\n+  private final int readLeShort(byte[] b, int off)\n+  {\n+    return (b[off] & 0xff) | (b[off+1] & 0xff) << 8;\n+  }\n+\n+  /**\n+   * Read an int in little endian byte order from the given\n+   * byte buffer at the given offset.\n+   *\n+   * @param b the byte array to read from.\n+   * @param off the offset to read from.\n+   * @return The value read.\n+   */\n+  private final int readLeInt(byte[] b, int off)\n+  {\n+    return ((b[off] & 0xff) | (b[off+1] & 0xff) << 8)\n+\t    | ((b[off+2] & 0xff) | (b[off+3] & 0xff) << 8) << 16;\n+  }\n+  \n+\n   /**\n    * Read the central directory of a zip file and fill the entries\n-   * array.  This is called exactly once when first needed.\n+   * array.  This is called exactly once when first needed. It is called\n+   * while holding the lock on <code>raf</code>.\n+   *\n    * @exception IOException if a i/o error occured.\n    * @exception ZipException if the central directory is malformed \n    */\n@@ -175,52 +219,51 @@ private void readEntries() throws ZipException, IOException\n      * file isn't a zip file.\n      */\n     long pos = raf.length() - ENDHDR;\n+    byte[] ebs  = new byte[CENHDR];\n+    \n     do\n       {\n \tif (pos < 0)\n \t  throw new ZipException\n \t    (\"central directory not found, probably not a zip file: \" + name);\n \traf.seek(pos--);\n       }\n-    while (readLeInt(raf) != ENDSIG);\n+    while (readLeInt(raf, ebs) != ENDSIG);\n+    \n     if (raf.skipBytes(ENDTOT - ENDNRD) != ENDTOT - ENDNRD)\n       throw new EOFException(name);\n-    int count = readLeShort(raf);\n+    int count = readLeShort(raf, ebs);\n     if (raf.skipBytes(ENDOFF - ENDSIZ) != ENDOFF - ENDSIZ)\n       throw new EOFException(name);\n-    int centralOffset = readLeInt(raf);\n+    int centralOffset = readLeInt(raf, ebs);\n \n-    entries = new Hashtable(count);\n+    entries = new HashMap(count+count/2);\n     raf.seek(centralOffset);\n-    byte[] ebs  = new byte[24];\n-    ByteArrayInputStream ebais = new ByteArrayInputStream(ebs);\n-    DataInputStream edip = new DataInputStream(ebais);\n+    \n+    byte[] buffer = new byte[16];\n     for (int i = 0; i < count; i++)\n       {\n-\tif (readLeInt(raf) != CENSIG)\n+      \traf.readFully(ebs);\n+\tif (readLeInt(ebs, 0) != CENSIG)\n \t  throw new ZipException(\"Wrong Central Directory signature: \" + name);\n-\tif (raf.skipBytes(CENHOW - CENVEM) != CENHOW - CENVEM)\n-\t  throw new EOFException(name);\n-\n-\traf.readFully(ebs);\n-\tebais.reset();\n-\tint method = readLeShort(edip);\n-\tint dostime = readLeInt(edip);\n-\tint crc = readLeInt(edip);\n-\tint csize = readLeInt(edip);\n-\tint size = readLeInt(edip);\n-\tint nameLen = readLeShort(edip);\n-\tint extraLen = readLeShort(edip);\n-\tint commentLen = readLeShort(edip);\n-\n-\tif (raf.skipBytes(CENOFF - CENDSK) != CENOFF - CENDSK)\n-\t  throw new EOFException(name);\n-\tint offset = readLeInt(raf);\n-\n-\tbyte[] buffer = new byte[Math.max(nameLen, commentLen)];\n+\n+\tint method = readLeShort(ebs, CENHOW);\n+\tint dostime = readLeInt(ebs, CENTIM);\n+\tint crc = readLeInt(ebs, CENCRC);\n+\tint csize = readLeInt(ebs, CENSIZ);\n+\tint size = readLeInt(ebs, CENLEN);\n+\tint nameLen = readLeShort(ebs, CENNAM);\n+\tint extraLen = readLeShort(ebs, CENEXT);\n+\tint commentLen = readLeShort(ebs, CENCOM);\n+\t\n+\tint offset = readLeInt(ebs, CENOFF);\n+\n+\tint needBuffer = Math.max(nameLen, commentLen);\n+\tif (buffer.length < needBuffer)\n+\t  buffer = new byte[needBuffer];\n \n \traf.readFully(buffer, 0, nameLen);\n-\tString name = new String(buffer, 0, nameLen);\n+\tString name = new String(buffer, 0, 0, nameLen);\n \n \tZipEntry entry = new ZipEntry(name);\n \tentry.setMethod(method);\n@@ -248,6 +291,7 @@ private void readEntries() throws ZipException, IOException\n    * Closes the ZipFile.  This also closes all input streams given by\n    * this class.  After this is called, no further method should be\n    * called.\n+   * \n    * @exception IOException if a i/o error occured.\n    */\n   public void close() throws IOException\n@@ -267,7 +311,7 @@ public Enumeration entries()\n   {\n     try\n       {\n-\treturn new ZipEntryEnumeration(getEntries().elements());\n+\treturn new ZipEntryEnumeration(getEntries().values().iterator());\n       }\n     catch (IOException ioe)\n       {\n@@ -281,7 +325,7 @@ public Enumeration entries()\n    * @exception IllegalStateException when the ZipFile has already been closed.\n    * @exception IOEexception when the entries could not be read.\n    */\n-  private Hashtable getEntries() throws IOException\n+  private HashMap getEntries() throws IOException\n   {\n     synchronized(raf)\n       {\n@@ -297,15 +341,16 @@ private Hashtable getEntries() throws IOException\n \n   /**\n    * Searches for a zip entry in this archive with the given name.\n+   *\n    * @param the name. May contain directory components separated by\n    * slashes ('/').\n    * @return the zip entry, or null if no entry with that name exists.\n-   * @see #entries */\n+   */\n   public ZipEntry getEntry(String name)\n   {\n     try\n       {\n-\tHashtable entries = getEntries();\n+\tHashMap entries = getEntries();\n \tZipEntry entry = (ZipEntry) entries.get(name);\n \treturn entry != null ? (ZipEntry) entry.clone() : null;\n       }\n@@ -315,10 +360,17 @@ public ZipEntry getEntry(String name)\n       }\n   }\n \n+\n+  //access should be protected by synchronized(raf)\n+  private byte[] locBuf = new byte[LOCHDR];\n+\n   /**\n    * Checks, if the local header of the entry at index i matches the\n    * central directory, and returns the offset to the data.\n+   * \n+   * @param entry to check.\n    * @return the start offset of the (compressed) data.\n+   *\n    * @exception IOException if a i/o error occured.\n    * @exception ZipException if the local header doesn't match the \n    * central directory header\n@@ -328,24 +380,18 @@ private long checkLocalHeader(ZipEntry entry) throws IOException\n     synchronized (raf)\n       {\n \traf.seek(entry.offset);\n-\tif (readLeInt(raf) != LOCSIG)\n+\traf.readFully(locBuf);\n+\t\n+\tif (readLeInt(locBuf, 0) != LOCSIG)\n \t  throw new ZipException(\"Wrong Local header signature: \" + name);\n \n-\t/* skip version and flags */\n-\tif (raf.skipBytes(LOCHOW - LOCVER) != LOCHOW - LOCVER)\n-\t  throw new EOFException(name);\n-\n-\tif (entry.getMethod() != readLeShort(raf))\n+\tif (entry.getMethod() != readLeShort(locBuf, LOCHOW))\n \t  throw new ZipException(\"Compression method mismatch: \" + name);\n \n-\t/* Skip time, crc, size and csize */\n-\tif (raf.skipBytes(LOCNAM - LOCTIM) != LOCNAM - LOCTIM)\n-\t  throw new EOFException(name);\n-\n-\tif (entry.getName().length() != readLeShort(raf))\n+\tif (entry.getName().length() != readLeShort(locBuf, LOCNAM))\n \t  throw new ZipException(\"file name length mismatch: \" + name);\n \n-\tint extraLen = entry.getName().length() + readLeShort(raf);\n+\tint extraLen = entry.getName().length() + readLeShort(locBuf, LOCEXT);\n \treturn entry.offset + LOCHDR + extraLen;\n       }\n   }\n@@ -354,22 +400,25 @@ private long checkLocalHeader(ZipEntry entry) throws IOException\n    * Creates an input stream reading the given zip entry as\n    * uncompressed data.  Normally zip entry should be an entry\n    * returned by getEntry() or entries().\n+   *\n+   * @param entry the entry to create an InputStream for.\n    * @return the input stream.\n+   *\n    * @exception IOException if a i/o error occured.\n    * @exception ZipException if the Zip archive is malformed.  \n    */\n   public InputStream getInputStream(ZipEntry entry) throws IOException\n   {\n-    Hashtable entries = getEntries();\n+    HashMap entries = getEntries();\n     String name = entry.getName();\n     ZipEntry zipEntry = (ZipEntry) entries.get(name);\n     if (zipEntry == null)\n       throw new NoSuchElementException(name);\n \n     long start = checkLocalHeader(zipEntry);\n     int method = zipEntry.getMethod();\n-    InputStream is = new PartialInputStream\n-      (raf, start, zipEntry.getCompressedSize());\n+    InputStream is = new BufferedInputStream(new PartialInputStream\n+      (raf, start, zipEntry.getCompressedSize()));\n     switch (method)\n       {\n       case ZipOutputStream.STORED:\n@@ -406,30 +455,30 @@ public int size()\n   \n   private static class ZipEntryEnumeration implements Enumeration\n   {\n-    private final Enumeration elements;\n+    private final Iterator elements;\n \n-    public ZipEntryEnumeration(Enumeration elements)\n+    public ZipEntryEnumeration(Iterator elements)\n     {\n       this.elements = elements;\n     }\n \n     public boolean hasMoreElements()\n     {\n-      return elements.hasMoreElements();\n+      return elements.hasNext();\n     }\n \n     public Object nextElement()\n     {\n       /* We return a clone, just to be safe that the user doesn't\n        * change the entry.  \n        */\n-      return ((ZipEntry)elements.nextElement()).clone();\n+      return ((ZipEntry)elements.next()).clone();\n     }\n   }\n \n   private static class PartialInputStream extends InputStream\n   {\n-    RandomAccessFile raf;\n+    private final RandomAccessFile raf;\n     long filepos, end;\n \n     public PartialInputStream(RandomAccessFile raf, long start, long len)"}]}