{"sha": "bb3976df48aecf734211898d6d954dc8ebed0713", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmIzOTc2ZGY0OGFlY2Y3MzQyMTE4OThkNmQ5NTRkYzhlYmVkMDcxMw==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-05-30T00:16:58Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-05-30T00:16:58Z"}, "message": "cmd/go, cmd/vet: make vet work with gccgo\n    \n    Backport https://golang.org/cl/113715 and https://golang.org/cl/113716:\n    \n    cmd/go: don't pass -compiler flag to vet\n    \n    Without this running go vet -compiler=gccgo causes vet to fail.\n    The vet tool does need to know the compiler, but it is passed in\n    vetConfig.Compiler.\n    \n    cmd/go, cmd/vet, go/internal/gccgoimport: make vet work with gccgo\n    \n    When using gccgo/GoLLVM, there is no package file for a standard\n    library package. Since it is impossible for the go tool to rebuild the\n    package, and since the package file exists only in the form of a .gox\n    file, this seems like the best choice. Unfortunately it was confusing\n    vet, which wanted to see a real file. This caused vet to report errors\n    about missing package files for standard library packages. The\n    gccgoimporter knows how to correctly handle this case. Fix this by\n    \n    1) telling vet which packages are standard;\n    2) letting vet skip those packages;\n    3) letting the gccgoimporter handle this case.\n    \n    As a separate required fix, gccgo/GoLLVM has no runtime/cgo package,\n    so don't try to depend on it (as it happens, this fixes golang/go#25324).\n    \n    The result is that the cmd/go vet tests pass when using -compiler=gccgo.\n    \n    Reviewed-on: https://go-review.googlesource.com/114516\n\nFrom-SVN: r260913", "tree": {"sha": "f26362247107542c54e9b998b7c9003de6914215", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f26362247107542c54e9b998b7c9003de6914215"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bb3976df48aecf734211898d6d954dc8ebed0713", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb3976df48aecf734211898d6d954dc8ebed0713", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb3976df48aecf734211898d6d954dc8ebed0713", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb3976df48aecf734211898d6d954dc8ebed0713/comments", "author": null, "committer": null, "parents": [{"sha": "fc27db2b4243ab71276a93ced42c17aa88bb0620", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc27db2b4243ab71276a93ced42c17aa88bb0620", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc27db2b4243ab71276a93ced42c17aa88bb0620"}], "stats": {"total": 46, "additions": 35, "deletions": 11}, "files": [{"sha": "8500b37108bd9fcab14537c05e336a88095e4868", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb3976df48aecf734211898d6d954dc8ebed0713/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb3976df48aecf734211898d6d954dc8ebed0713/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=bb3976df48aecf734211898d6d954dc8ebed0713", "patch": "@@ -1,4 +1,4 @@\n-572b19513766e9e5cc4aa8d984a89c93880726ba\n+9731580e76c065b76e3a103356bb8920da05a685\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "882b86d148fe3ba976142248c37906c9727920a9", "filename": "libgo/go/cmd/go/internal/load/pkg.go", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb3976df48aecf734211898d6d954dc8ebed0713/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fpkg.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb3976df48aecf734211898d6d954dc8ebed0713/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fpkg.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fpkg.go?ref=bb3976df48aecf734211898d6d954dc8ebed0713", "patch": "@@ -1010,7 +1010,7 @@ func (p *Package) load(stk *ImportStack, bp *build.Package, err error) {\n \n \t// Cgo translation adds imports of \"runtime/cgo\" and \"syscall\",\n \t// except for certain packages, to avoid circular dependencies.\n-\tif p.UsesCgo() && (!p.Standard || !cgoExclude[p.ImportPath]) {\n+\tif p.UsesCgo() && (!p.Standard || !cgoExclude[p.ImportPath]) && cfg.BuildContext.Compiler != \"gccgo\" {\n \t\taddImport(\"runtime/cgo\")\n \t}\n \tif p.UsesCgo() && (!p.Standard || !cgoSyscallExclude[p.ImportPath]) {\n@@ -1019,7 +1019,9 @@ func (p *Package) load(stk *ImportStack, bp *build.Package, err error) {\n \n \t// SWIG adds imports of some standard packages.\n \tif p.UsesSwig() {\n-\t\taddImport(\"runtime/cgo\")\n+\t\tif cfg.BuildContext.Compiler != \"gccgo\" {\n+\t\t\taddImport(\"runtime/cgo\")\n+\t\t}\n \t\taddImport(\"syscall\")\n \t\taddImport(\"sync\")\n \n@@ -1225,7 +1227,7 @@ func LinkerDeps(p *Package) []string {\n \tdeps := []string{\"runtime\"}\n \n \t// External linking mode forces an import of runtime/cgo.\n-\tif externalLinkingForced(p) {\n+\tif externalLinkingForced(p) && cfg.BuildContext.Compiler != \"gccgo\" {\n \t\tdeps = append(deps, \"runtime/cgo\")\n \t}\n \t// On ARM with GOARM=5, it forces an import of math, for soft floating point."}, {"sha": "03770ea920eb6065bca5f0bd66c8aae807bc769c", "filename": "libgo/go/cmd/go/internal/vet/vetflag.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb3976df48aecf734211898d6d954dc8ebed0713/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvet%2Fvetflag.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb3976df48aecf734211898d6d954dc8ebed0713/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvet%2Fvetflag.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvet%2Fvetflag.go?ref=bb3976df48aecf734211898d6d954dc8ebed0713", "patch": "@@ -90,7 +90,7 @@ func vetFlags(args []string) (passToVet, packageNames []string) {\n \t\t\t}\n \t\t\tswitch f.Name {\n \t\t\t// Flags known to the build but not to vet, so must be dropped.\n-\t\t\tcase \"x\", \"n\", \"vettool\":\n+\t\t\tcase \"x\", \"n\", \"vettool\", \"compiler\":\n \t\t\t\tif extraWord {\n \t\t\t\t\targs = append(args[:i], args[i+2:]...)\n \t\t\t\t\textraWord = false"}, {"sha": "837ffb5e0fd3afcdc97be269ea3ed4ba6cf0fb20", "filename": "libgo/go/cmd/go/internal/work/exec.go", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb3976df48aecf734211898d6d954dc8ebed0713/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fexec.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb3976df48aecf734211898d6d954dc8ebed0713/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fexec.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fexec.go?ref=bb3976df48aecf734211898d6d954dc8ebed0713", "patch": "@@ -512,6 +512,7 @@ func (b *Builder) build(a *Action) (err error) {\n \t\t\tImportPath:  a.Package.ImportPath,\n \t\t\tImportMap:   make(map[string]string),\n \t\t\tPackageFile: make(map[string]string),\n+\t\t\tStandard:    make(map[string]bool),\n \t\t}\n \t\ta.vetCfg = vcfg\n \t\tfor i, raw := range a.Package.Internal.RawImports {\n@@ -548,17 +549,24 @@ func (b *Builder) build(a *Action) (err error) {\n \n \tfor _, a1 := range a.Deps {\n \t\tp1 := a1.Package\n-\t\tif p1 == nil || p1.ImportPath == \"\" || a1.built == \"\" {\n+\t\tif p1 == nil || p1.ImportPath == \"\" {\n \t\t\tcontinue\n \t\t}\n-\t\tfmt.Fprintf(&icfg, \"packagefile %s=%s\\n\", p1.ImportPath, a1.built)\n+\t\tif a1.built != \"\" {\n+\t\t\tfmt.Fprintf(&icfg, \"packagefile %s=%s\\n\", p1.ImportPath, a1.built)\n+\t\t}\n \t\tif vcfg != nil {\n \t\t\t// Add import mapping if needed\n \t\t\t// (for imports like \"runtime/cgo\" that appear only in generated code).\n \t\t\tif !vcfgMapped[p1.ImportPath] {\n \t\t\t\tvcfg.ImportMap[p1.ImportPath] = p1.ImportPath\n \t\t\t}\n-\t\t\tvcfg.PackageFile[p1.ImportPath] = a1.built\n+\t\t\tif a1.built != \"\" {\n+\t\t\t\tvcfg.PackageFile[p1.ImportPath] = a1.built\n+\t\t\t}\n+\t\t\tif p1.Standard {\n+\t\t\t\tvcfg.Standard[p1.ImportPath] = true\n+\t\t\t}\n \t\t}\n \t}\n \n@@ -693,6 +701,7 @@ type vetConfig struct {\n \tGoFiles     []string\n \tImportMap   map[string]string\n \tPackageFile map[string]string\n+\tStandard    map[string]bool\n \tImportPath  string\n \n \tSucceedOnTypecheckFailure bool\n@@ -722,7 +731,10 @@ func (b *Builder) vet(a *Action) error {\n \tif vcfg.ImportMap[\"fmt\"] == \"\" {\n \t\ta1 := a.Deps[1]\n \t\tvcfg.ImportMap[\"fmt\"] = \"fmt\"\n-\t\tvcfg.PackageFile[\"fmt\"] = a1.built\n+\t\tif a1.built != \"\" {\n+\t\t\tvcfg.PackageFile[\"fmt\"] = a1.built\n+\t\t}\n+\t\tvcfg.Standard[\"fmt\"] = true\n \t}\n \n \t// During go test, ignore type-checking failures during vet."}, {"sha": "49c1d32f13d1244ed1cf04d7e034285e5826f09b", "filename": "libgo/go/cmd/vet/main.go", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb3976df48aecf734211898d6d954dc8ebed0713/libgo%2Fgo%2Fcmd%2Fvet%2Fmain.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb3976df48aecf734211898d6d954dc8ebed0713/libgo%2Fgo%2Fcmd%2Fvet%2Fmain.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fvet%2Fmain.go?ref=bb3976df48aecf734211898d6d954dc8ebed0713", "patch": "@@ -292,6 +292,7 @@ type vetConfig struct {\n \tGoFiles     []string\n \tImportMap   map[string]string\n \tPackageFile map[string]string\n+\tStandard    map[string]bool\n \n \tSucceedOnTypecheckFailure bool\n \n@@ -309,7 +310,12 @@ func (v *vetConfig) Import(path string) (*types.Package, error) {\n \tif p == \"\" {\n \t\treturn nil, fmt.Errorf(\"unknown import path %q\", path)\n \t}\n-\tif v.PackageFile[p] == \"\" && v.Compiler != \"gccgo\" {\n+\tif v.PackageFile[p] == \"\" {\n+\t\tif v.Compiler == \"gccgo\" && v.Standard[path] {\n+\t\t\t// gccgo doesn't have sources for standard library packages,\n+\t\t\t// but the importer will do the right thing.\n+\t\t\treturn v.imp.Import(path)\n+\t\t}\n \t\treturn nil, fmt.Errorf(\"unknown package file for import %q\", path)\n \t}\n \treturn v.imp.Import(p)\n@@ -318,6 +324,10 @@ func (v *vetConfig) Import(path string) (*types.Package, error) {\n func (v *vetConfig) openPackageFile(path string) (io.ReadCloser, error) {\n \tfile := v.PackageFile[path]\n \tif file == \"\" {\n+\t\tif v.Compiler == \"gccgo\" && v.Standard[path] {\n+\t\t\t// The importer knows how to handle this.\n+\t\t\treturn nil, nil\n+\t\t}\n \t\t// Note that path here has been translated via v.ImportMap,\n \t\t// unlike in the error in Import above. We prefer the error in\n \t\t// Import, but it's worth diagnosing this one too, just in case."}, {"sha": "ddaed405c18ca02eca79a302982e186233363d95", "filename": "libgo/go/go/internal/gccgoimporter/importer.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb3976df48aecf734211898d6d954dc8ebed0713/libgo%2Fgo%2Fgo%2Finternal%2Fgccgoimporter%2Fimporter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb3976df48aecf734211898d6d954dc8ebed0713/libgo%2Fgo%2Fgo%2Finternal%2Fgccgoimporter%2Fimporter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Finternal%2Fgccgoimporter%2Fimporter.go?ref=bb3976df48aecf734211898d6d954dc8ebed0713", "patch": "@@ -176,7 +176,7 @@ func GetImporter(searchpaths []string, initmap map[*types.Package]InitData) Impo\n \t\t\t\treturn p, nil\n \t\t\t}\n \t\t\trc, err := lookup(pkgpath)\n-\t\t\tif err == nil {\n+\t\t\tif err == nil && rc != nil {\n \t\t\t\tdefer rc.Close()\n \t\t\t\trs, ok := rc.(io.ReadSeeker)\n \t\t\t\tif !ok {"}]}