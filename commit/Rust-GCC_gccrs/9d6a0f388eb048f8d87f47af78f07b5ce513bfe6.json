{"sha": "9d6a0f388eb048f8d87f47af78f07b5ce513bfe6", "node_id": "C_kwDOANBUbNoAKDlkNmEwZjM4OGViMDQ4ZjhkODdmNDdhZjc4ZjA3YjVjZTUxM2JmZTY", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2022-01-15T23:41:40Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2022-01-15T23:45:56Z"}, "message": "Add -Wdangling-pointer [PR63272].\n\nResolves:\nPR c/63272 - GCC should warn when using pointer to dead scoped variable with\nin the same function\n\ngcc/c-family/ChangeLog:\n\n\tPR c/63272\n\t* c.opt (-Wdangling-pointer): New option.\n\ngcc/ChangeLog:\n\n\tPR c/63272\n\t* diagnostic-spec.c (nowarn_spec_t::nowarn_spec_t): Handle\n\t-Wdangling-pointer.\n\t* doc/invoke.texi (-Wdangling-pointer): Document new option.\n\t* gimple-ssa-warn-access.cc (pass_waccess::clone): Set new member.\n\t(pass_waccess::check_pointer_uses): New function.\n\t(pass_waccess::gimple_call_return_arg): New function.\n\t(pass_waccess::gimple_call_return_arg_ref): New function.\n\t(pass_waccess::check_call_dangling): New function.\n\t(pass_waccess::check_dangling_uses): New function overloads.\n\t(pass_waccess::check_dangling_stores): New function.\n\t(pass_waccess::check_dangling_stores): New function.\n\t(pass_waccess::m_clobbers): New data member.\n\t(pass_waccess::m_func): New data member.\n\t(pass_waccess::m_run_number): New data member.\n\t(pass_waccess::m_check_dangling_p): New data member.\n\t(pass_waccess::check_alloca): Check m_early_checks_p.\n\t(pass_waccess::check_alloc_size_call): Same.\n\t(pass_waccess::check_strcat): Same.\n\t(pass_waccess::check_strncat): Same.\n\t(pass_waccess::check_stxcpy): Same.\n\t(pass_waccess::check_stxncpy): Same.\n\t(pass_waccess::check_strncmp): Same.\n\t(pass_waccess::check_memop_access): Same.\n\t(pass_waccess::check_read_access): Same.\n\t(pass_waccess::check_builtin): Call check_pointer_uses.\n\t(pass_waccess::warn_invalid_pointer): Add arguments.\n\t(is_auto_decl): New function.\n\t(pass_waccess::check_stmt): New function.\n\t(pass_waccess::check_block): Call check_stmt.\n\t(pass_waccess::execute): Call check_dangling_uses,\n\tcheck_dangling_stores.  Empty m_clobbers.\n\t* passes.def (pass_warn_access): Invoke pass two more times.\n\ngcc/testsuite/ChangeLog:\n\n\tPR c/63272\n\t* g++.dg/warn/Wfree-nonheap-object-6.C: Disable valid warnings.\n\t* g++.dg/warn/ref-temp1.C: Prune expected warning.\n\t* gcc.dg/uninit-pr50476.c: Expect a new warning.\n\t* c-c++-common/Wdangling-pointer-2.c: New test.\n\t* c-c++-common/Wdangling-pointer-3.c: New test.\n\t* c-c++-common/Wdangling-pointer-4.c: New test.\n\t* c-c++-common/Wdangling-pointer-5.c: New test.\n\t* c-c++-common/Wdangling-pointer-6.c: New test.\n\t* c-c++-common/Wdangling-pointer.c: New test.\n\t* g++.dg/warn/Wdangling-pointer-2.C: New test.\n\t* g++.dg/warn/Wdangling-pointer.C: New test.\n\t* gcc.dg/Wdangling-pointer-2.c: New test.\n\t* gcc.dg/Wdangling-pointer.c: New test.", "tree": {"sha": "2faf3aed7f6102a234d4afa5e4b727925a2249d8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2faf3aed7f6102a234d4afa5e4b727925a2249d8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9d6a0f388eb048f8d87f47af78f07b5ce513bfe6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d6a0f388eb048f8d87f47af78f07b5ce513bfe6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9d6a0f388eb048f8d87f47af78f07b5ce513bfe6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d6a0f388eb048f8d87f47af78f07b5ce513bfe6/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "671a283636de75f7ed638ee6b01ed2d44361b8b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/671a283636de75f7ed638ee6b01ed2d44361b8b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/671a283636de75f7ed638ee6b01ed2d44361b8b6"}], "stats": {"total": 2104, "additions": 2043, "deletions": 61}, "files": [{"sha": "db65c14a7a5af99d3652b9fb5b2c86e9e8b53857", "filename": "gcc/c-family/c.opt", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d6a0f388eb048f8d87f47af78f07b5ce513bfe6/gcc%2Fc-family%2Fc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d6a0f388eb048f8d87f47af78f07b5ce513bfe6/gcc%2Fc-family%2Fc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc.opt?ref=9d6a0f388eb048f8d87f47af78f07b5ce513bfe6", "patch": "@@ -548,6 +548,14 @@ Wdangling-else\n C ObjC C++ ObjC++ Var(warn_dangling_else) Warning LangEnabledBy(C ObjC C++ ObjC++,Wparentheses)\n Warn about dangling else.\n \n+Wdangling-pointer\n+C ObjC C++ LTO ObjC++ Alias(Wdangling-pointer=, 2, 0) Warning\n+Warn for uses of pointers to auto variables whose lifetime has ended.\n+\n+Wdangling-pointer=\n+C ObjC C++ ObjC++ Joined RejectNegative UInteger Var(warn_dangling_pointer) Warning LangEnabledBy(C ObjC C++ ObjC++,Wall, 2, 0) IntegerRange(0, 2)\n+Warn for uses of pointers to auto variables whose lifetime has ended.\n+\n Wdate-time\n C ObjC C++ ObjC++ CPP(warn_date_time) CppReason(CPP_W_DATE_TIME) Var(cpp_warn_date_time) Init(0) Warning\n Warn about __TIME__, __DATE__ and __TIMESTAMP__ usage."}, {"sha": "a8af229d67733719d74f1c1ac235b698d8f563b9", "filename": "gcc/diagnostic-spec.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d6a0f388eb048f8d87f47af78f07b5ce513bfe6/gcc%2Fdiagnostic-spec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d6a0f388eb048f8d87f47af78f07b5ce513bfe6/gcc%2Fdiagnostic-spec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic-spec.c?ref=9d6a0f388eb048f8d87f47af78f07b5ce513bfe6", "patch": "@@ -99,6 +99,7 @@ nowarn_spec_t::nowarn_spec_t (opt_code opt)\n \tm_bits = NW_UNINIT;\n       break;\n \n+    case OPT_Wdangling_pointer_:\n     case OPT_Wreturn_local_addr:\n     case OPT_Wuse_after_free_:\n       m_bits = NW_DANGLING;"}, {"sha": "7f2205e4a8594ec08644bb19ed0582dc1ca0685f", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 61, "deletions": 1, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d6a0f388eb048f8d87f47af78f07b5ce513bfe6/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d6a0f388eb048f8d87f47af78f07b5ce513bfe6/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=9d6a0f388eb048f8d87f47af78f07b5ce513bfe6", "patch": "@@ -341,7 +341,8 @@ Objective-C and Objective-C++ Dialects}.\n -Wchar-subscripts @gol\n -Wclobbered  -Wcomment @gol\n -Wconversion  -Wno-coverage-mismatch  -Wno-cpp @gol\n--Wdangling-else  -Wdate-time @gol\n+-Wdangling-else  -Wdangling-pointer  -Wdangling-pointer=@var{n}  @gol\n+-Wdate-time @gol\n -Wno-deprecated  -Wno-deprecated-declarations  -Wno-designated-init @gol\n -Wdisabled-optimization @gol\n -Wno-discarded-array-qualifiers  -Wno-discarded-qualifiers @gol\n@@ -4389,6 +4390,8 @@ Warn about overriding virtual functions that are not marked with the\n @opindex Wno-use-after-free\n Warn about uses of pointers to dynamically allocated objects that have\n been rendered indeterminate by a call to a deallocation function.\n+The warning is enabled at all optimization levels but may yield different\n+results with optimization than without.\n \n @table @gcctabopt\n @item -Wuse-after-free=1\n@@ -5714,6 +5717,7 @@ Options} and @ref{Objective-C and Objective-C++ Dialect Options}.\n -Wcatch-value @r{(C++ and Objective-C++ only)}  @gol\n -Wchar-subscripts  @gol\n -Wcomment  @gol\n+-Wdangling-pointer=2  @gol\n -Wduplicate-decl-specifier @r{(C and Objective-C only)} @gol\n -Wenum-compare @r{(in C/ObjC; this is on by default in C++)} @gol\n -Wformat   @gol\n@@ -8587,6 +8591,62 @@ looks like this:\n \n This warning is enabled by @option{-Wparentheses}.\n \n+@item -Wdangling-pointer\n+@itemx -Wdangling-pointer=@var{n}\n+@opindex Wdangling-pointer\n+@opindex Wno-dangling-pointer\n+Warn about uses of pointers (or C++ references) to objects with automatic\n+storage duration after their lifetime has ended.  This includes local\n+variables declared in nested blocks, compound literals and other unnamed\n+temporary objects.  In addition, warn about storing the address of such\n+objects in escaped pointers.  The warning is enabled at all optimization\n+levels but may yield different results with optimization than without.\n+\n+@table @gcctabopt\n+@item -Wdangling-pointer=1\n+At level 1 the warning diagnoses only unconditional uses of dangling pointers.\n+For example\n+@smallexample\n+int f (int c1, int c2, x)\n+@{\n+  char *p = strchr ((char[])@{ c1, c2 @}, c3);\n+  return p ? *p : 'x';   // warning: dangling pointer to a compound literal\n+@}\n+@end smallexample\n+In the following function the store of the address of the local variable\n+@code{x} in the escaped pointer @code{*p} also triggers the warning.\n+@smallexample\n+void g (int **p)\n+@{\n+  int x = 7;\n+  *p = &x;   // warning: storing the address of a local variable in *p\n+@}\n+@end smallexample\n+\n+@item -Wdangling-pointer=2\n+At level 2, in addition to unconditional uses the warning also diagnoses\n+conditional uses of dangling pointers.\n+\n+For example, because the array @var{a} in the following function is out of\n+scope when the pointer @var{s} that was set to point is used, the warning\n+triggers at this level.\n+\n+@smallexample\n+void f (char *s)\n+@{\n+  if (!s)\n+    @{\n+      char a[12] = \"tmpname\";\n+      s = a;\n+    @}\n+  strcat (s, \".tmp\");   // warning: dangling pointer to a may be used\n+  ...\n+@}\n+@end smallexample\n+@end table\n+\n+@option{-Wdangling-pointer=2} is included in @option{-Wall}.\n+\n @item -Wdate-time\n @opindex Wdate-time\n @opindex Wno-date-time"}, {"sha": "f639807a78a6938d708d969e1e4336f3cd679d1b", "filename": "gcc/gimple-ssa-warn-access.cc", "status": "modified", "additions": 578, "deletions": 57, "changes": 635, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d6a0f388eb048f8d87f47af78f07b5ce513bfe6/gcc%2Fgimple-ssa-warn-access.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d6a0f388eb048f8d87f47af78f07b5ce513bfe6/gcc%2Fgimple-ssa-warn-access.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-warn-access.cc?ref=9d6a0f388eb048f8d87f47af78f07b5ce513bfe6", "patch": "@@ -2069,10 +2069,12 @@ class pass_waccess : public gimple_opt_pass\n \n   ~pass_waccess ();\n \n-  opt_pass *clone () { return new pass_waccess (m_ctxt); }\n+  opt_pass *clone ();\n \n   virtual bool gate (function *);\n \n+  void set_pass_param (unsigned, bool);\n+\n   virtual unsigned int execute (function *);\n \n private:\n@@ -2089,6 +2091,9 @@ class pass_waccess : public gimple_opt_pass\n   /* Check a call to an ordinary function for invalid accesses.  */\n   bool check_call_access (gcall *);\n \n+  /* Check a non-call statement.  */\n+  void check_stmt (gimple *);\n+\n   /* Check statements in a basic block.  */\n   void check_block (basic_block);\n \n@@ -2112,26 +2117,41 @@ class pass_waccess : public gimple_opt_pass\n   void check_atomic_memmodel (gimple *, tree, tree, const unsigned char *);\n \n   /* Check for uses of indeterminate pointers.  */\n-  void check_pointer_uses (gimple *, tree);\n+  void check_pointer_uses (gimple *, tree, tree = NULL_TREE, bool = false);\n \n   /* Return the argument that a call returns.  */\n   tree gimple_call_return_arg (gcall *);\n+  tree gimple_call_return_arg_ref (gcall *);\n+\n+  /* Check a call for uses of a dangling pointer arguments.  */\n+  void check_call_dangling (gcall *);\n+\n+  /* Check uses of a dangling pointer or those derived from it.  */\n+  void check_dangling_uses (tree, tree, bool = false, bool = false);\n+  void check_dangling_uses ();\n+  void check_dangling_stores ();\n+  void check_dangling_stores (basic_block, hash_set<tree> &, auto_bitmap &);\n \n-  void warn_invalid_pointer (tree, gimple *, gimple *, bool, bool = false);\n+  void warn_invalid_pointer (tree, gimple *, gimple *, tree, bool, bool = false);\n \n   /* Return true if use follows an invalidating statement.  */\n-  bool use_after_inval_p (gimple *, gimple *);\n+  bool use_after_inval_p (gimple *, gimple *, bool = false);\n \n   /* A pointer_query object and its cache to store information about\n      pointers and their targets in.  */\n   pointer_query m_ptr_qry;\n   pointer_query::cache_type m_var_cache;\n-\n+  /* Mapping from DECLs and their clobber statements in the function.  */\n+  hash_map<tree, gimple *> m_clobbers;\n   /* A bit is set for each basic block whose statements have been assigned\n      valid UIDs.  */\n   bitmap m_bb_uids_set;\n   /* The current function.  */\n   function *m_func;\n+  /* True to run checks for uses of dangling pointers.  */\n+  bool m_check_dangling_p;\n+  /* True to run checks early on in the optimization pipeline.  */\n+  bool m_early_checks_p;\n };\n \n /* Construct the pass.  */\n@@ -2140,18 +2160,37 @@ pass_waccess::pass_waccess (gcc::context *ctxt)\n   : gimple_opt_pass (pass_data_waccess, ctxt),\n     m_ptr_qry (NULL, &m_var_cache),\n     m_var_cache (),\n+    m_clobbers (),\n     m_bb_uids_set (),\n-    m_func ()\n+    m_func (),\n+    m_check_dangling_p (),\n+    m_early_checks_p ()\n {\n }\n \n+/* Return a copy of the pass with RUN_NUMBER one greater than THIS.  */\n+\n+opt_pass*\n+pass_waccess::clone ()\n+{\n+  return new pass_waccess (m_ctxt);\n+}\n+\n /* Release pointer_query cache.  */\n \n pass_waccess::~pass_waccess ()\n {\n   m_ptr_qry.flush_cache ();\n }\n \n+void\n+pass_waccess::set_pass_param (unsigned int n, bool early)\n+{\n+  gcc_assert (n == 0);\n+\n+  m_early_checks_p = early;\n+}\n+\n /* Return true when any checks performed by the pass are enabled.  */\n \n bool\n@@ -2340,6 +2379,9 @@ maybe_warn_alloc_args_overflow (gimple *stmt, const tree args[2],\n void\n pass_waccess::check_alloca (gcall *stmt)\n {\n+  if (m_early_checks_p)\n+    return;\n+\n   if ((warn_vla_limit >= HOST_WIDE_INT_MAX\n        && warn_alloc_size_limit < warn_vla_limit)\n       || (warn_alloca_limit >= HOST_WIDE_INT_MAX\n@@ -2361,6 +2403,13 @@ pass_waccess::check_alloca (gcall *stmt)\n void\n pass_waccess::check_alloc_size_call (gcall *stmt)\n {\n+  if (m_early_checks_p)\n+    return;\n+\n+  if (gimple_call_num_args (stmt) < 1)\n+    /* Avoid invalid calls to functions without a prototype.  */\n+    return;\n+\n   tree fndecl = gimple_call_fndecl (stmt);\n   if (fndecl && gimple_call_builtin_p (stmt, BUILT_IN_NORMAL))\n     {\n@@ -2413,6 +2462,9 @@ pass_waccess::check_alloc_size_call (gcall *stmt)\n void\n pass_waccess::check_strcat (gcall *stmt)\n {\n+  if (m_early_checks_p)\n+    return;\n+\n   if (!warn_stringop_overflow && !warn_stringop_overread)\n     return;\n \n@@ -2438,6 +2490,9 @@ pass_waccess::check_strcat (gcall *stmt)\n void\n pass_waccess::check_strncat (gcall *stmt)\n {\n+  if (m_early_checks_p)\n+    return;\n+\n   if (!warn_stringop_overflow && !warn_stringop_overread)\n     return;\n \n@@ -2507,6 +2562,9 @@ pass_waccess::check_strncat (gcall *stmt)\n void\n pass_waccess::check_stxcpy (gcall *stmt)\n {\n+  if (m_early_checks_p)\n+    return;\n+\n   tree dst = call_arg (stmt, 0);\n   tree src = call_arg (stmt, 1);\n \n@@ -2545,7 +2603,7 @@ pass_waccess::check_stxcpy (gcall *stmt)\n void\n pass_waccess::check_stxncpy (gcall *stmt)\n {\n-  if (!warn_stringop_overflow)\n+  if (m_early_checks_p || !warn_stringop_overflow)\n     return;\n \n   tree dst = call_arg (stmt, 0);\n@@ -2569,7 +2627,7 @@ pass_waccess::check_stxncpy (gcall *stmt)\n void\n pass_waccess::check_strncmp (gcall *stmt)\n {\n-  if (!warn_stringop_overread)\n+  if (m_early_checks_p || !warn_stringop_overread)\n     return;\n \n   tree arg1 = call_arg (stmt, 0);\n@@ -2674,6 +2732,9 @@ pass_waccess::check_strncmp (gcall *stmt)\n void\n pass_waccess::check_memop_access (gimple *stmt, tree dest, tree src, tree size)\n {\n+  if (m_early_checks_p)\n+    return;\n+\n   /* For functions like memset and memcpy that operate on raw memory\n      try to determine the size of the largest source and destination\n      object using type-0 Object Size regardless of the object size\n@@ -2695,7 +2756,7 @@ pass_waccess::check_read_access (gimple *stmt, tree src,\n \t\t\t\t tree bound /* = NULL_TREE */,\n \t\t\t\t int ost /* = 1 */)\n {\n-  if (!warn_stringop_overread)\n+  if (m_early_checks_p || !warn_stringop_overread)\n     return;\n \n   if (bound && !useless_type_conversion_p (size_type_node, TREE_TYPE (bound)))\n@@ -2938,7 +2999,7 @@ pass_waccess::check_atomic_memmodel (gimple *stmt, tree ord_sucs,\n   if (warning_suppressed_p (stmt, OPT_Winvalid_memory_model))\n     return;\n \n-  if (maybe_warn_memmodel (stmt, ord_sucs, ord_fail, valid))\n+  if (!maybe_warn_memmodel (stmt, ord_sucs, ord_fail, valid))\n     return;\n \n   suppress_warning (stmt, OPT_Winvalid_memory_model);\n@@ -3094,11 +3155,12 @@ pass_waccess::check_builtin (gcall *stmt)\n \n     case BUILT_IN_FREE:\n     case BUILT_IN_REALLOC:\n-      {\n-\ttree arg = call_arg (stmt, 0);\n-\tif (TREE_CODE (arg) == SSA_NAME)\n-\t  check_pointer_uses (stmt, arg);\n-      }\n+      if (!m_early_checks_p)\n+\t{\n+\t  tree arg = call_arg (stmt, 0);\n+\t  if (TREE_CODE (arg) == SSA_NAME)\n+\t    check_pointer_uses (stmt, arg);\n+\t}\n       return true;\n \n     case BUILT_IN_GETTEXT:\n@@ -3725,16 +3787,67 @@ pass_waccess::maybe_check_dealloc_call (gcall *call)\n \n /* Return true if either USE_STMT's basic block (that of a pointer's use)\n    is dominated by INVAL_STMT's (that of a pointer's invalidating statement,\n-   or if they're in the same block, USE_STMT follows INVAL_STMT.  */\n+   which is either a clobber or a deallocation call), or if they're in\n+   the same block, USE_STMT follows INVAL_STMT.  */\n \n bool\n-pass_waccess::use_after_inval_p (gimple *inval_stmt, gimple *use_stmt)\n+pass_waccess::use_after_inval_p (gimple *inval_stmt, gimple *use_stmt,\n+\t\t\t\t bool last_block /* = false */)\n {\n+  tree clobvar =\n+    gimple_clobber_p (inval_stmt) ? gimple_assign_lhs (inval_stmt) : NULL_TREE;\n+\n   basic_block inval_bb = gimple_bb (inval_stmt);\n   basic_block use_bb = gimple_bb (use_stmt);\n \n+  if (!inval_bb || !use_bb)\n+    return false;\n+\n   if (inval_bb != use_bb)\n-    return dominated_by_p (CDI_DOMINATORS, use_bb, inval_bb);\n+    {\n+      if (dominated_by_p (CDI_DOMINATORS, use_bb, inval_bb))\n+\treturn true;\n+\n+      if (!clobvar || !last_block)\n+\treturn false;\n+\n+      /* Proceed only when looking for uses of dangling pointers.  */\n+      auto gsi = gsi_for_stmt (use_stmt);\n+\n+      auto_bitmap visited;\n+\n+      /* A use statement in the last basic block in a function or one that\n+\t falls through to it is after any other prior clobber of the used\n+\t variable unless it's followed by a clobber of the same variable. */\n+      basic_block bb = use_bb;\n+      while (bb != inval_bb\n+\t     && single_succ_p (bb)\n+\t     && !(single_succ_edge (bb)->flags & (EDGE_EH|EDGE_DFS_BACK)))\n+\t{\n+\t  if (!bitmap_set_bit (visited, bb->index))\n+\t    /* Avoid cycles. */\n+\t    return true;\n+\n+\t  for (; !gsi_end_p (gsi); gsi_next_nondebug (&gsi))\n+\t    {\n+\t      gimple *stmt = gsi_stmt (gsi);\n+\t      if (gimple_clobber_p (stmt))\n+\t\t{\n+\t\t  if (clobvar == gimple_assign_lhs (stmt))\n+\t\t    /* The use is followed by a clobber.  */\n+\t\t    return false;\n+\t\t}\n+\t    }\n+\n+\t  bb = single_succ (bb);\n+\t  gsi = gsi_start_bb (bb);\n+\t}\n+\n+      /* The use is one of a dangling pointer if a clobber of the variable\n+\t [the pointer points to] has not been found before the function exit\n+\t point.  */\n+      return bb == EXIT_BLOCK_PTR_FOR_FN (cfun);\n+    }\n \n   if (bitmap_set_bit (m_bb_uids_set, inval_bb->index))\n     /* The first time this basic block is visited assign increasing ids\n@@ -3752,27 +3865,30 @@ pass_waccess::use_after_inval_p (gimple *inval_stmt, gimple *use_stmt)\n   return gimple_uid (inval_stmt) < gimple_uid (use_stmt);\n }\n \n-/* Issue a warning for the USE_STMT of pointer PTR rendered invalid\n-   by INVAL_STMT.  PTR may be null when it's been optimized away.\n-   MAYBE is true to issue the \"maybe\" kind of warning.  EQUALITY is\n-   true when the pointer is used in an equality expression.  */\n+/* Issue a warning for the USE_STMT of pointer or reference REF rendered\n+   invalid by INVAL_STMT.  REF may be null when it's been optimized away.\n+   When nonnull, INVAL_STMT is the deallocation function that rendered\n+   the pointer or reference dangling.  Otherwise, VAR is the auto variable\n+   (including an unnamed temporary such as a compound literal) whose\n+   lifetime's rended it dangling.  MAYBE is true to issue the \"maybe\"\n+   kind of warning.  EQUALITY is true when the pointer is used in\n+   an equality expression.  */\n \n void\n-pass_waccess::warn_invalid_pointer (tree ptr, gimple *use_stmt,\n-\t\t\t\t    gimple *inval_stmt,\n-\t\t\t\t    bool maybe,\n-\t\t\t\t    bool equality /* = false */)\n+pass_waccess::warn_invalid_pointer (tree ref, gimple *use_stmt,\n+\t\t\t\t    gimple *inval_stmt, tree var,\n+\t\t\t\t    bool maybe, bool equality /* = false */)\n {\n   /* Avoid printing the unhelpful \"<unknown>\" in the diagnostics.  */\n-  if (ptr && TREE_CODE (ptr) == SSA_NAME\n-      && (!SSA_NAME_VAR (ptr) || DECL_ARTIFICIAL (SSA_NAME_VAR (ptr))))\n-    ptr = NULL_TREE;\n+  if (ref && TREE_CODE (ref) == SSA_NAME\n+      && (!SSA_NAME_VAR (ref) || DECL_ARTIFICIAL (SSA_NAME_VAR (ref))))\n+    ref = NULL_TREE;\n \n   location_t use_loc = gimple_location (use_stmt);\n   if (use_loc == UNKNOWN_LOCATION)\n     {\n-      use_loc = cfun->function_end_locus;\n-      if (!ptr)\n+      use_loc = m_func->function_end_locus;\n+      if (!ref)\n \t/* Avoid issuing a warning with no context other than\n \t   the function.  That would make it difficult to debug\n \t   in any but very simple cases.  */\n@@ -3788,12 +3904,12 @@ pass_waccess::warn_invalid_pointer (tree ptr, gimple *use_stmt,\n \n       const tree inval_decl = gimple_call_fndecl (inval_stmt);\n \n-      if ((ptr && warning_at (use_loc, OPT_Wuse_after_free,\n+      if ((ref && warning_at (use_loc, OPT_Wuse_after_free,\n \t\t\t      (maybe\n \t\t\t       ? G_(\"pointer %qE may be used after %qD\")\n \t\t\t       : G_(\"pointer %qE used after %qD\")),\n-\t\t\t      ptr, inval_decl))\n-\t  || (!ptr && warning_at (use_loc, OPT_Wuse_after_free,\n+\t\t\t      ref, inval_decl))\n+\t  || (!ref && warning_at (use_loc, OPT_Wuse_after_free,\n \t\t\t      (maybe\n \t\t\t       ? G_(\"pointer may be used after %qD\")\n \t\t\t       : G_(\"pointer used after %qD\")),\n@@ -3805,6 +3921,52 @@ pass_waccess::warn_invalid_pointer (tree ptr, gimple *use_stmt,\n \t}\n       return;\n     }\n+\n+  if ((maybe && warn_dangling_pointer < 2)\n+      || warning_suppressed_p (use_stmt, OPT_Wdangling_pointer_))\n+    return;\n+\n+  if (DECL_NAME (var))\n+    {\n+      if ((ref\n+\t   && warning_at (use_loc, OPT_Wdangling_pointer_,\n+\t\t\t  (maybe\n+\t\t\t   ? G_(\"dangling pointer %qE to %qD may be used\")\n+\t\t\t   : G_(\"using dangling pointer %qE to %qD\")),\n+\t\t\t  ref, var))\n+\t  || (!ref\n+\t      && warning_at (use_loc, OPT_Wdangling_pointer_,\n+\t\t\t     (maybe\n+\t\t\t      ? G_(\"dangling pointer to %qD may be used\")\n+\t\t\t      : G_(\"using a dangling pointer to %qD\")),\n+\t\t\t     var)))\n+\tinform (DECL_SOURCE_LOCATION (var),\n+\t\t\"%qD declared here\", var);\n+      suppress_warning (use_stmt, OPT_Wdangling_pointer_);\n+      return;\n+    }\n+\n+  if ((ref\n+       && warning_at (use_loc, OPT_Wdangling_pointer_,\n+\t\t      (maybe\n+\t\t       ? G_(\"dangling pointer %qE to an unnamed temporary \"\n+\t\t\t    \"may be used\")\n+\t\t       : G_(\"using dangling pointer %qE to an unnamed \"\n+\t\t\t    \"temporary\")),\n+\t\t      ref, var))\n+      || (!ref\n+\t  && warning_at (use_loc, OPT_Wdangling_pointer_,\n+\t\t\t (maybe\n+\t\t\t  ? G_(\"dangling pointer to an unnamed temporary \"\n+\t\t\t       \"may be used\")\n+\t\t\t  : G_(\"using a dangling pointer to an unnamed \"\n+\t\t\t       \"temporary\")),\n+\t\t\t var)))\n+    {\n+      inform (DECL_SOURCE_LOCATION (var),\n+\t      \"unnamed temporary defined here\");\n+      suppress_warning (use_stmt, OPT_Wdangling_pointer_);\n+    }\n }\n \n /* If STMT is a call to either the standard realloc or to a user-defined\n@@ -3927,10 +4089,14 @@ pointers_related_p (gimple *stmt, tree p, tree q, pointer_query &qry)\n \n /* For a STMT either a call to a deallocation function or a clobber, warn\n    for uses of the pointer PTR it was called with (including its copies\n-   or others derived from it by pointer arithmetic).  */\n+   or others derived from it by pointer arithmetic).  If STMT is a clobber,\n+   VAR is the decl of the clobbered variable.  When MAYBE is true use\n+   a \"maybe\" form of diagnostic.  */\n \n void\n-pass_waccess::check_pointer_uses (gimple *stmt, tree ptr)\n+pass_waccess::check_pointer_uses (gimple *stmt, tree ptr,\n+\t\t\t\t  tree var /* = NULL_TREE */,\n+\t\t\t\t  bool maybe /* = false */)\n {\n   gcc_assert (TREE_CODE (ptr) == SSA_NAME);\n \n@@ -4013,18 +4179,25 @@ pass_waccess::check_pointer_uses (gimple *stmt, tree ptr)\n \t  /* Warn if USE_STMT is dominated by the deallocation STMT.\n \t     Otherwise, add the pointer to POINTERS so that the uses\n \t     of any other pointers derived from it can be checked.  */\n-\t  if (use_after_inval_p (stmt, use_stmt))\n+\t  if (use_after_inval_p (stmt, use_stmt, check_dangling))\n \t    {\n-\t      /* TODO: Handle PHIs but careful of false positives.  */\n-\t      if (gimple_code (use_stmt) != GIMPLE_PHI)\n+\t      if (gimple_code (use_stmt) == GIMPLE_PHI)\n \t\t{\n-\t\t  basic_block use_bb = gimple_bb (use_stmt);\n-\t\t  bool this_maybe\n-\t\t    = !dominated_by_p (CDI_POST_DOMINATORS, use_bb, stmt_bb);\n-\t\t  warn_invalid_pointer (*use_p->use, use_stmt, stmt,\n-\t\t\t\t\tthis_maybe, equality);\n-\t\t  continue;\n+\t\t  tree lhs = gimple_phi_result (use_stmt);\n+\t\t  if (TREE_CODE (lhs) == SSA_NAME)\n+\t\t    {\n+\t\t      pointers.safe_push (lhs);\n+\t\t      continue;\n+\t\t    }\n \t\t}\n+\n+\t      basic_block use_bb = gimple_bb (use_stmt);\n+\t      bool this_maybe\n+\t\t= (maybe\n+\t\t   || !dominated_by_p (CDI_POST_DOMINATORS, use_bb, stmt_bb));\n+\t      warn_invalid_pointer (*use_p->use, use_stmt, stmt, var,\n+\t\t\t\t    this_maybe, equality);\n+\t      continue;\n \t    }\n \n \t  if (is_gimple_assign (use_stmt))\n@@ -4059,26 +4232,100 @@ pass_waccess::check_call (gcall *stmt)\n   if (gimple_call_builtin_p (stmt, BUILT_IN_NORMAL))\n     check_builtin (stmt);\n \n-  if (tree callee = gimple_call_fndecl (stmt))\n-    {\n-      /* Check for uses of the pointer passed to either a standard\n-\t or a user-defined deallocation function.  */\n-      unsigned argno = fndecl_dealloc_argno (callee);\n-      if (argno < (unsigned) call_nargs (stmt))\n-\t{\n-\t  tree arg = call_arg (stmt, argno);\n-\t  if (TREE_CODE (arg) == SSA_NAME)\n-\t    check_pointer_uses (stmt, arg);\n-\t}\n-    }\n+  if (!m_early_checks_p)\n+    if (tree callee = gimple_call_fndecl (stmt))\n+      {\n+\t/* Check for uses of the pointer passed to either a standard\n+\t   or a user-defined deallocation function.  */\n+\tunsigned argno = fndecl_dealloc_argno (callee);\n+\tif (argno < (unsigned) call_nargs (stmt))\n+\t  {\n+\t    tree arg = call_arg (stmt, argno);\n+\t    if (TREE_CODE (arg) == SSA_NAME)\n+\t      check_pointer_uses (stmt, arg);\n+\t  }\n+      }\n \n   check_call_access (stmt);\n+  check_call_dangling (stmt);\n+\n+  if (m_early_checks_p)\n+    return;\n \n   maybe_check_dealloc_call (stmt);\n   check_nonstring_args (stmt);\n }\n \n \n+/* Return true of X is a DECL with automatic storage duration.  */\n+\n+static inline bool\n+is_auto_decl (tree x)\n+{\n+  return DECL_P (x) && !DECL_EXTERNAL (x) && !TREE_STATIC (x);\n+}\n+\n+/* Check non-call STMT for invalid accesses.  */\n+\n+void\n+pass_waccess::check_stmt (gimple *stmt)\n+{\n+  if (m_check_dangling_p && gimple_clobber_p (stmt))\n+    {\n+      /* Ignore clobber statemts in blocks with exceptional edges.  */\n+      basic_block bb = gimple_bb (stmt);\n+      edge e = EDGE_PRED (bb, 0);\n+      if (e->flags & EDGE_EH)\n+\treturn;\n+\n+      tree var = gimple_assign_lhs (stmt);\n+      m_clobbers.put (var, stmt);\n+      return;\n+    }\n+\n+  if (is_gimple_assign (stmt))\n+    {\n+      /* Clobbered unnamed temporaries such as compound literals can be\n+\t revived.  Check for an assignment to one and remove it from\n+\t M_CLOBBERS.  */\n+      tree lhs = gimple_assign_lhs (stmt);\n+      while (handled_component_p (lhs))\n+\tlhs = TREE_OPERAND (lhs, 0);\n+\n+      if (is_auto_decl (lhs))\n+\tm_clobbers.remove (lhs);\n+      return;\n+    }\n+\n+  if (greturn *ret = dyn_cast <greturn *> (stmt))\n+    {\n+      if (optimize && flag_isolate_erroneous_paths_dereference)\n+\t/* Avoid interfering with -Wreturn-local-addr (which runs only\n+\t   with optimization enabled).  */\n+\treturn;\n+\n+      tree arg = gimple_return_retval (ret);\n+      if (!arg || TREE_CODE (arg) != ADDR_EXPR)\n+\treturn;\n+\n+      arg = TREE_OPERAND (arg, 0);\n+      while (handled_component_p (arg))\n+\targ = TREE_OPERAND (arg, 0);\n+\n+      if (!is_auto_decl (arg))\n+\treturn;\n+\n+      gimple **pclobber = m_clobbers.get (arg);\n+      if (!pclobber)\n+\treturn;\n+\n+      if (!use_after_inval_p (*pclobber, stmt))\n+\treturn;\n+\n+      warn_invalid_pointer (NULL_TREE, stmt, *pclobber, arg, false);\n+    }\n+}\n+\n /* Check basic block BB for invalid accesses.  */\n \n void\n@@ -4091,6 +4338,8 @@ pass_waccess::check_block (basic_block bb)\n       gimple *stmt = gsi_stmt (si);\n       if (gcall *call = dyn_cast <gcall *> (stmt))\n \tcheck_call (call);\n+      else\n+\tcheck_stmt (stmt);\n     }\n }\n \n@@ -4139,6 +4388,262 @@ pass_waccess::gimple_call_return_arg (gcall *call)\n   return gimple_call_arg (call, argno);\n }\n \n+/* Return the decl referenced by the argument that the call STMT to\n+   a built-in function returns (including with an offset) or null if\n+   it doesn't.  */\n+\n+tree\n+pass_waccess::gimple_call_return_arg_ref (gcall *call)\n+{\n+  if (tree arg = gimple_call_return_arg (call))\n+    {\n+      access_ref aref;\n+      if (m_ptr_qry.get_ref (arg, call, &aref, 0)\n+\t  && DECL_P (aref.ref))\n+\treturn aref.ref;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Check for and diagnose all uses of the dangling pointer VAR to the auto\n+   object DECL whose lifetime has ended.  OBJREF is true when VAR denotes\n+   an access to a DECL that may have been clobbered.  */\n+\n+void\n+pass_waccess::check_dangling_uses (tree var, tree decl, bool maybe /* = false */,\n+\t\t\t\t   bool objref /* = false */)\n+{\n+  if (!decl || !is_auto_decl (decl))\n+    return;\n+\n+  gimple **pclob = m_clobbers.get (decl);\n+  if (!pclob)\n+    return;\n+\n+  if (!objref)\n+    {\n+      check_pointer_uses (*pclob, var, decl, maybe);\n+      return;\n+    }\n+\n+  gimple *use_stmt = SSA_NAME_DEF_STMT (var);\n+  if (!use_after_inval_p (*pclob, use_stmt, true))\n+    return;\n+\n+  basic_block use_bb = gimple_bb (use_stmt);\n+  basic_block clob_bb = gimple_bb (*pclob);\n+  maybe = maybe || !dominated_by_p (CDI_POST_DOMINATORS, use_bb, clob_bb);\n+  warn_invalid_pointer (var, use_stmt, *pclob, decl, maybe, false);\n+}\n+\n+/* Diagnose stores in BB and (recursively) its predecessors of the addresses\n+   of local variables into nonlocal pointers that are left dangling after\n+   the function returns.  BBS is a bitmap of basic blocks visited.  */\n+\n+void\n+pass_waccess::check_dangling_stores (basic_block bb,\n+\t\t\t\t     hash_set<tree> &stores,\n+\t\t\t\t     auto_bitmap &bbs)\n+{\n+  if (!bitmap_set_bit (bbs, bb->index))\n+    /* Avoid cycles. */\n+    return;\n+\n+  /* Iterate backwards over the statements looking for a store of\n+     the address of a local variable into a nonlocal pointer.  */\n+  for (auto gsi = gsi_last_nondebug_bb (bb); ; gsi_prev_nondebug (&gsi))\n+    {\n+      gimple *stmt = gsi_stmt (gsi);\n+      if (!stmt)\n+\tbreak;\n+\n+      if (is_gimple_call (stmt)\n+\t  && !(gimple_call_flags (stmt) & (ECF_CONST | ECF_PURE)))\n+\t/* Avoid looking before nonconst, nonpure calls since those might\n+\t   use the escaped locals.  */\n+\treturn;\n+\n+      if (!is_gimple_assign (stmt) || gimple_clobber_p (stmt))\n+\tcontinue;\n+\n+      access_ref lhs_ref;\n+      tree lhs = gimple_assign_lhs (stmt);\n+      if (!m_ptr_qry.get_ref (lhs, stmt, &lhs_ref, 0))\n+\tcontinue;\n+\n+      if (is_auto_decl (lhs_ref.ref))\n+\tcontinue;\n+\n+      if (DECL_P (lhs_ref.ref))\n+\t{\n+\t  if (!POINTER_TYPE_P (TREE_TYPE (lhs_ref.ref))\n+\t      || lhs_ref.deref > 0)\n+\t    continue;\n+\t}\n+      else if (TREE_CODE (lhs_ref.ref) == SSA_NAME)\n+\t{\n+\t  /* Avoid looking at or before stores into unknown objects.  */\n+\t  gimple *def_stmt = SSA_NAME_DEF_STMT (lhs_ref.ref);\n+\t  if (!gimple_nop_p (def_stmt))\n+\t    return;\n+\t}\n+      else if (TREE_CODE (lhs_ref.ref) == MEM_REF)\n+\t{\n+\t  tree arg = TREE_OPERAND (lhs_ref.ref, 0);\n+\t  if (TREE_CODE (arg) == SSA_NAME)\n+\t    {\n+\t      gimple *def_stmt = SSA_NAME_DEF_STMT (arg);\n+\t      if (!gimple_nop_p (def_stmt))\n+\t\treturn;\n+\t    }\n+\t}\n+      else\n+\tcontinue;\n+\n+      if (stores.add (lhs_ref.ref))\n+\tcontinue;\n+\n+      /* FIXME: Handle stores of alloca() and VLA.  */\n+      access_ref rhs_ref;\n+      tree rhs = gimple_assign_rhs1 (stmt);\n+      if (!m_ptr_qry.get_ref (rhs, stmt, &rhs_ref, 0)\n+\t  || rhs_ref.deref != -1)\n+\tcontinue;\n+\n+      if (!is_auto_decl (rhs_ref.ref))\n+\tcontinue;\n+\n+      location_t loc = gimple_location (stmt);\n+      if (warning_at (loc, OPT_Wdangling_pointer_,\n+\t\t      \"storing the address of local variable %qD in %qE\",\n+\t\t      rhs_ref.ref, lhs))\n+\t{\n+\t  location_t loc = DECL_SOURCE_LOCATION (rhs_ref.ref);\n+\t  inform (loc, \"%qD declared here\", rhs_ref.ref);\n+\n+\t  if (DECL_P (lhs_ref.ref))\n+\t    loc = DECL_SOURCE_LOCATION (lhs_ref.ref);\n+\t  else if (EXPR_HAS_LOCATION (lhs_ref.ref))\n+\t    loc = EXPR_LOCATION (lhs_ref.ref);\n+\n+\t  if (loc != UNKNOWN_LOCATION)\n+\t    inform (loc, \"%qE declared here\", lhs_ref.ref);\n+\t}\n+    }\n+\n+  edge e;\n+  edge_iterator ei;\n+  FOR_EACH_EDGE (e, ei, bb->preds)\n+    {\n+      basic_block pred = e->src;\n+      check_dangling_stores (pred, stores, bbs);\n+    }\n+}\n+\n+/* Diagnose stores of the addresses of local variables into nonlocal\n+   pointers that are left dangling after the function returns.  */\n+\n+void\n+pass_waccess::check_dangling_stores ()\n+{\n+  auto_bitmap bbs;\n+  hash_set<tree> stores;\n+  check_dangling_stores (EXIT_BLOCK_PTR_FOR_FN (m_func), stores, bbs);\n+}\n+\n+/* Check for and diagnose uses of dangling pointers to auto objects\n+   whose lifetime has ended.  */\n+\n+void\n+pass_waccess::check_dangling_uses ()\n+{\n+  tree var;\n+  unsigned i;\n+  FOR_EACH_SSA_NAME (i, var, m_func)\n+    {\n+      /* For each SSA_NAME pointer VAR find the DECL it points to.\n+\t If the DECL is a clobbered local variable, check to see\n+\t if any of VAR's uses (or those of other pointers derived\n+\t from VAR) happens after the clobber.  If so, warn.  */\n+      tree decl = NULL_TREE;\n+\n+      gimple *def_stmt = SSA_NAME_DEF_STMT (var);\n+      if (is_gimple_assign (def_stmt))\n+\t{\n+\t  tree rhs = gimple_assign_rhs1 (def_stmt);\n+\t  if (TREE_CODE (rhs) == ADDR_EXPR)\n+\t    {\n+\t      if (!POINTER_TYPE_P (TREE_TYPE (var)))\n+\t\tcontinue;\n+\t      decl = TREE_OPERAND (rhs, 0);\n+\t    }\n+\t  else\n+\t    {\n+\t      /* For other expressions, check the base DECL to see\n+\t\t if it's been clobbered, most likely as a result of\n+\t\t inlining a reference to it.  */\n+\t      decl = get_base_address (rhs);\n+\t      if (DECL_P (decl))\n+\t\tcheck_dangling_uses (var, decl, false, true);\n+\t      continue;\n+\t    }\n+\t}\n+      else if (POINTER_TYPE_P (TREE_TYPE (var)))\n+\t{\n+\t  if (gcall *call = dyn_cast<gcall *>(def_stmt))\n+\t    decl = gimple_call_return_arg_ref (call);\n+\t  else if (gphi *phi = dyn_cast <gphi *>(def_stmt))\n+\t    {\n+\t      unsigned nargs = gimple_phi_num_args (phi);\n+\t      for (unsigned i = 0; i != nargs; ++i)\n+\t\t{\n+\t\t  access_ref aref;\n+\t\t  tree arg = gimple_phi_arg_def (phi, i);\n+\t\t  if (!m_ptr_qry.get_ref (arg, phi, &aref, 0)\n+\t\t      || (aref.deref == 0\n+\t\t\t  && POINTER_TYPE_P (TREE_TYPE (aref.ref))))\n+\t\t    continue;\n+\t\t  check_dangling_uses (var, aref.ref, true);\n+\t\t}\n+\t      continue;\n+\t    }\n+\t  else\n+\t    continue;\n+\t}\n+\n+      check_dangling_uses (var, decl);\n+    }\n+}\n+\n+/* Check CALL arguments for dangling pointers (those that have been\n+   clobbered) and warn if found.  */\n+\n+void\n+pass_waccess::check_call_dangling (gcall *call)\n+{\n+  unsigned nargs = gimple_call_num_args (call);\n+  for (unsigned i = 0; i != nargs; ++i)\n+    {\n+      tree arg = gimple_call_arg (call, i);\n+      if (TREE_CODE (arg) != ADDR_EXPR)\n+\tcontinue;\n+\n+      arg = TREE_OPERAND (arg, 0);\n+      if (!DECL_P (arg))\n+\tcontinue;\n+\n+      gimple **pclobber = m_clobbers.get (arg);\n+      if (!pclobber)\n+\tcontinue;\n+\n+      if (!use_after_inval_p (*pclobber, call))\n+\tcontinue;\n+\n+      warn_invalid_pointer (NULL_TREE, call, *pclobber, arg, false);\n+    }\n+}\n+\n /* Check function FUN for invalid accesses.  */\n \n unsigned\n@@ -4151,6 +4656,15 @@ pass_waccess::execute (function *fun)\n   m_ptr_qry.rvals = enable_ranger (fun);\n   m_func = fun;\n \n+  /* Check for dangling pointers in the earliest run of the pass.\n+     The latest point -Wdangling-pointer should run is just before\n+     loop unrolling which introduces uses after clobbers.  Most cases\n+     can be detected without optimization; cases where the address of\n+     the local variable is passed to and then returned from a user-\n+     defined function before its lifetime ends and the returned pointer\n+     becomes dangling depend on inlining.  */\n+  m_check_dangling_p = m_early_checks_p;\n+\n   auto_bitmap bb_uids_set (&bitmap_default_obstack);\n   m_bb_uids_set = bb_uids_set;\n \n@@ -4160,6 +4674,12 @@ pass_waccess::execute (function *fun)\n   FOR_EACH_BB_FN (bb, fun)\n     check_block (bb);\n \n+  if (m_check_dangling_p)\n+    {\n+      check_dangling_uses ();\n+      check_dangling_stores ();\n+    }\n+\n   if (dump_file)\n     m_ptr_qry.dump (dump_file, (dump_flags & TDF_DETAILS) != 0);\n \n@@ -4170,6 +4690,7 @@ pass_waccess::execute (function *fun)\n   disable_ranger (fun);\n   m_ptr_qry.rvals = NULL;\n \n+  m_clobbers.empty ();\n   m_bb_uids_set = NULL;\n \n   free_dominance_info (CDI_POST_DOMINATORS);"}, {"sha": "78808424070e4d5bd7d9283307ccca210c8ad565", "filename": "gcc/passes.def", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d6a0f388eb048f8d87f47af78f07b5ce513bfe6/gcc%2Fpasses.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d6a0f388eb048f8d87f47af78f07b5ce513bfe6/gcc%2Fpasses.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.def?ref=9d6a0f388eb048f8d87f47af78f07b5ce513bfe6", "patch": "@@ -63,6 +63,7 @@ along with GCC; see the file COPYING3.  If not see\n       NEXT_PASS (pass_ubsan);\n       NEXT_PASS (pass_nothrow);\n       NEXT_PASS (pass_rebuild_cgraph_edges);\n+      NEXT_PASS (pass_warn_access, /*early=*/true);\n   POP_INSERT_PASSES ()\n \n   NEXT_PASS (pass_local_optimization_passes);\n@@ -201,6 +202,8 @@ along with GCC; see the file COPYING3.  If not see\n \t form if possible.  */\n       NEXT_PASS (pass_object_sizes);\n       NEXT_PASS (pass_post_ipa_warn);\n+      /* Must run before loop unrolling.  */\n+      NEXT_PASS (pass_warn_access, /*early=*/true);\n       NEXT_PASS (pass_complete_unrolli);\n       NEXT_PASS (pass_backprop);\n       NEXT_PASS (pass_phiprop);\n@@ -426,7 +429,7 @@ along with GCC; see the file COPYING3.  If not see\n   NEXT_PASS (pass_harden_compares);\n   NEXT_PASS (pass_cleanup_cfg_post_optimizing);\n   NEXT_PASS (pass_warn_function_noreturn);\n-  NEXT_PASS (pass_warn_access);\n+  NEXT_PASS (pass_warn_access, /*early=*/false);\n \n   NEXT_PASS (pass_expand);\n "}, {"sha": "527e5e7b2c6f884f5d033531c93f32616e7d88b8", "filename": "gcc/testsuite/c-c++-common/Wdangling-pointer-2.c", "status": "added", "additions": 437, "deletions": 0, "changes": 437, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d6a0f388eb048f8d87f47af78f07b5ce513bfe6/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWdangling-pointer-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d6a0f388eb048f8d87f47af78f07b5ce513bfe6/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWdangling-pointer-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWdangling-pointer-2.c?ref=9d6a0f388eb048f8d87f47af78f07b5ce513bfe6", "patch": "@@ -0,0 +1,437 @@\n+/* PR middle-end/63272 - GCC should warn when using pointer to dead scoped\n+   variable within the same function\n+   Exercise basic cases of -Wdangling-pointer with optimization.\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall -Wno-uninitialized -Wno-return-local-addr -ftrack-macro-expansion=0\" } */\n+\n+typedef __INTPTR_TYPE__ intptr_t;\n+typedef __SIZE_TYPE__   size_t;\n+\n+#if __cplusplus\n+#  define EXTERN_C extern \"C\"\n+#else\n+#  define EXTERN_C extern\n+#endif\n+\n+#define NOIPA __attribute__ ((noipa))\n+\n+EXTERN_C void* alloca (size_t);\n+EXTERN_C void* malloc (size_t);\n+EXTERN_C void* memchr (const void*, int, size_t);\n+EXTERN_C char* strchr (const char*, int);\n+\n+int sink (const void*, ...);\n+#define sink(...) sink (0, __VA_ARGS__)\n+\n+\n+NOIPA void nowarn_addr (void)\n+{\n+  int *p;\n+  {\n+    int a[] = { 1, 2, 3 };\n+    p = a;\n+  }\n+\n+  // This is suspect but not a clear error.\n+  sink (&p);\n+}\n+\n+\n+NOIPA char* nowarn_ptr (void)\n+{\n+  char *p;\n+  sink (&p);\n+  return p;\n+}\n+\n+\n+NOIPA char* nowarn_cond_ptr (void)\n+{\n+  // Distilled from a false positive in Glibc dlerror.c.\n+  char *q;\n+  if (sink (&q))\n+    return q;\n+\n+  return 0;\n+}\n+\n+\n+NOIPA void nowarn_loop_ptr (int n, int *p)\n+{\n+  // Distilled from a false positive in Glibc td_thr_get_info.c.\n+  for (int i = 0; i != 2; ++i)\n+    {\n+      int x;\n+      sink (&x);\n+      *p++ = x;\n+    }\n+\n+  /* With the loop unrolled, Q is clobbered just before the call to\n+     sink(), making it indistinguishable from passing it a pointer\n+     to an out-of-scope variable.  Verify that the warning doesn't\n+     suffer from false positives due to this.\n+     int * q;\n+     int * q.1_17;\n+     int * q.1_26;\n+\n+     <bb 2>:\n+     f (&q);\n+     q.1_17 = q;\n+     *p_5(D) = q.1_17;\n+     q ={v} {CLOBBER};\n+     f (&q);\n+     q.1_26 = q;\n+     MEM[(void * *)p_5(D) + 8B] = q.1_26;\n+     q ={v} {CLOBBER};\n+     return;\n+  */\n+}\n+\n+\n+NOIPA void nowarn_intptr_t (void)\n+{\n+  intptr_t ip;\n+  {\n+    int a[] = { 1, 2, 3 };\n+    ip = (intptr_t)a;\n+  }\n+\n+  // Using an intptr_t is not diagnosed.\n+  sink (0, ip);\n+}\n+\n+\n+NOIPA void nowarn_string_literal (void)\n+{\n+  const char *s;\n+  {\n+    s = \"123\";\n+  }\n+\n+  sink (s);\n+}\n+\n+\n+NOIPA void nowarn_extern_array (int x)\n+{\n+  {\n+    /* This is a silly sanity check.  */\n+    extern int eia[];\n+    int *p;\n+    {\n+      p = eia;\n+    }\n+    sink (p);\n+  }\n+}\n+\n+\n+NOIPA void nowarn_static_array (int x)\n+{\n+  {\n+    const char *s;\n+    {\n+      static const char sca[] = \"123\";\n+      s = sca;\n+    }\n+\n+    sink (s);\n+  }\n+  {\n+    const int *p;\n+    {\n+      static const int sia[] = { 1, 2, 3 };\n+      p = sia;\n+    }\n+\n+    sink (p);\n+  }\n+  {\n+    const int *p;\n+    {\n+      static const int sia[] = { 1, 2, 3 };\n+      p = (const int*)memchr (sia, x, sizeof sia);\n+    }\n+\n+    sink (p);\n+  }\n+}\n+\n+\n+NOIPA void nowarn_alloca (unsigned n)\n+{\n+  {\n+    char *p;\n+    {\n+      p = (char*)alloca (n);\n+    }\n+    sink (p);\n+  }\n+  {\n+    int *p;\n+    {\n+      p = (int*)alloca (n * sizeof *p);\n+      sink (p);\n+    }\n+    sink (p);\n+  }\n+  {\n+    long *p;\n+    {\n+      p = (long*)alloca (n * sizeof *p);\n+      sink (p);\n+      p = p + 1;\n+    }\n+    sink (p);\n+  }\n+}\n+\n+\n+#pragma GCC diagnostic push\n+/* Verify that -Wdangling-pointer works with #pragma diagnostic.  */\n+#pragma GCC diagnostic ignored \"-Wdangling-pointer\"\n+\n+\n+NOIPA void* nowarn_return_local_addr (void)\n+{\n+  int a[] = { 1, 2, 3 };\n+  int *p = a;\n+\n+  /* This is a likely bug but it's not really one of using a dangling\n+     pointer but rather of returning the address of a local variable\n+     which is diagnosed by -Wreturn-local-addr.  */\n+  return p;\n+}\n+\n+NOIPA void* warn_return_local_addr (void)\n+{\n+  int *p = 0;\n+  {\n+    int a[] = { 1, 2, 3 };\n+    sink (a);\n+    p = a;\n+  }\n+\n+  /* Unlike the above case, here the pointer is dangling when it's\n+     used.  */\n+  return p;                   // { dg-warning \"using dangling pointer 'p' to 'a'\" \"pr??????\" { xfail *-*-* } }\n+}\n+\n+\n+NOIPA void* nowarn_return_alloca (int n)\n+{\n+  int *p = (int*)alloca (n);\n+  sink (p);\n+\n+  /* This is a likely bug but it's not really one of using a dangling\n+     pointer but rather of returning the address of a local variable\n+     which is diagnosed by -Wreturn-local-addr.  */\n+  return p;\n+}\n+\n+\n+NOIPA void nowarn_scalar_call_ignored (void *vp)\n+{\n+  int *p;\n+  {\n+    int i;\n+    p = &i;\n+  }\n+  sink (p);\n+}\n+\n+#pragma GCC diagnostic pop\n+\n+NOIPA void warn_scalar_call (void)\n+{\n+  int *p;\n+  {\n+    int i;                    // { dg-message \"'i' declared\" \"note\" }\n+    p = &i;\n+  }\n+  // When the 'p' is optimized away it's not mentioned in the warning.\n+  sink (p);                   // { dg-warning \"using \\(a \\)?dangling pointer \\('p' \\)?to 'i'\" \"array\" }\n+}\n+\n+\n+NOIPA void warn_array_call (void)\n+{\n+  int *p;\n+  {\n+    int a[] = { 1, 2, 3 };    // { dg-message \"'a' declared\" \"note\" }\n+    p = a;\n+  }\n+  sink (p);                   // { dg-warning \"using \\(a \\)?dangling pointer \\('p' \\)?to 'a'\" \"array\" }\n+}\n+\n+\n+NOIPA void* warn_array_return (void)\n+{\n+  int *p;\n+  {\n+    int a[] = { 1, 2, 3 };    // { dg-message \"'a' declared\" \"note\" }\n+    p = a;\n+  }\n+\n+  return p;                   // { dg-warning \"using \\(a \\)?dangling pointer \\('p' \\)?to 'a'\" \"array\" }\n+}\n+\n+\n+NOIPA void warn_pr63272_c1 (int i)\n+{\n+  int *p = 0;\n+\n+  if (i)\n+    {\n+      int k = i;              // { dg-message \"'k' declared\" \"note\" }\n+      p = &k;\n+    }\n+\n+  sink (p ? *p : 0);          // { dg-warning \"dangling pointer 'p' to 'k' may be used\" }\n+}\n+\n+\n+NOIPA void warn_pr63272_c4 (void)\n+{\n+  int *p = 0;\n+\n+  {\n+    int b;                    // { dg-message \"'b' declared\" \"note\" }\n+    p = &b;\n+  }\n+\n+  sink (p);                   // { dg-warning \"using \\(a \\)?dangling pointer \\('p' \\)?to 'b'\" \"scalar\" }\n+}\n+\n+\n+NOIPA void warn_cond_if (int i, int n)\n+{\n+  int *p;\n+  if (i)\n+    {\n+      int a[] = { 1, 2 };     // { dg-message \"'a' declared\" \"note\" }\n+      sink (a);\n+      p = a;\n+    }\n+  else\n+   {\n+     int *b = (int*)malloc (n);\n+     sink (b);\n+     p = b;\n+   }\n+\n+  sink (p);                   // { dg-warning \"dangling pointer 'p' to 'a' may be used\" }\n+}\n+\n+\n+NOIPA void warn_cond_else (int i, int n)\n+{\n+  int *p;\n+  if (i)\n+    {\n+      int *a = (int*)malloc (n);\n+      sink (a);\n+      p = a;\n+    }\n+  else\n+   {\n+     int b[] = { 2, 3 };\n+     sink (b);\n+     p = b;\n+   }\n+\n+  sink (p);                   // { dg-warning \"dangling pointer 'p' to 'b' may be used\" }\n+}\n+\n+\n+NOIPA void warn_cond_if_else (int i)\n+{\n+  int *p;\n+  if (i)\n+    {\n+      int a[] = { 1, 2 };     // { dg-message \"'a' declared\" \"note\" }\n+      sink (a);\n+      p = a;\n+    }\n+  else\n+   {\n+     int b[] = { 3, 4 };      // { dg-message \"'b' declared\" \"pr??????\" { xfail *-*-* } }\n+     sink (b);\n+     p = b;\n+   }\n+\n+  /* With a PHI with more than invalid argument, only one use is diagnosed\n+     because after the first diagnostic the code suppresses subsequent\n+     ones for the same use.  This needs to be fixed.  */\n+  sink (p);                   // { dg-warning \"dangling pointer 'p' to 'a' may be used\" }\n+                              // { dg-warning \"dangling pointer 'p' to 'b' may be used\" \"pr??????\" { xfail *-*-* } .-1 }\n+}\n+\n+\n+NOIPA void nowarn_gcc_i386 (int i)\n+{\n+  // Regression test reduced from gcc's i386.c.\n+  char a[32], *p;\n+\n+  if (i != 1)\n+    p = a;\n+  else\n+    p = 0;\n+\n+  if (i == 2)\n+    sink (p);\n+  else\n+    {\n+      if (p)\n+\t{\n+\t  sink (p);\n+\t  return;\n+\t}\n+      sink (p);\n+    }\n+}\n+\n+\n+NOIPA void warn_memchr (char c1, char c2, char c3, char c4)\n+{\n+  char *p = 0;\n+  {\n+    char a[] = { c1, c2, c3 };// { dg-message \"'a' declared\" \"note\" }\n+    p = (char*)memchr (a, c4, 3);\n+    if (!p)\n+      return;\n+  }\n+\n+  sink (p);                   // { dg-warning \"using dangling pointer 'p' to 'a'\" }\n+}\n+\n+\n+NOIPA void warn_strchr (char c1, char c2, char c3, char c4)\n+{\n+  char *p = 0;\n+  {\n+    char a[] = { c1, c2, c3 }; // { dg-message \"'a' declared\" \"note\" }\n+    p = (char*)strchr (a, c4);\n+    if (!p)\n+      return;\n+  }\n+\n+  sink (p);                   // { dg-warning \"using dangling pointer 'p' to 'a'\" }\n+}\n+\n+\n+static inline int* return_arg (int *p)\n+{\n+  return p;\n+}\n+\n+NOIPA void warn_inline (int i1, int i2, int i3)\n+{\n+  int *p;\n+  {\n+    int a[] = { i1, i2, i3 }; // { dg-message \"'a' declared\" \"note\" }\n+    p = return_arg (a);\n+  }\n+\n+  sink (p);                   // { dg-warning \"using \\(a \\)?dangling pointer \\('p' \\)?to 'a'\" \"inline\" }\n+}"}, {"sha": "d2f8f432ebad29fdb6ca4c437af9ad690969f912", "filename": "gcc/testsuite/c-c++-common/Wdangling-pointer-3.c", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d6a0f388eb048f8d87f47af78f07b5ce513bfe6/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWdangling-pointer-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d6a0f388eb048f8d87f47af78f07b5ce513bfe6/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWdangling-pointer-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWdangling-pointer-3.c?ref=9d6a0f388eb048f8d87f47af78f07b5ce513bfe6", "patch": "@@ -0,0 +1,64 @@\n+/* PR middle-end/63272 - GCC should warn when using pointer to dead scoped\n+   variable within the same function\n+   Exercise conditional uses dangling pointers with optimization.\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall -Wno-maybe-uninitialized\" } */\n+\n+typedef __INTPTR_TYPE__ intptr_t;\n+typedef __SIZE_TYPE__   size_t;\n+\n+#if __cplusplus\n+#  define EXTERN_C extern \"C\"\n+#else\n+#  define EXTERN_C extern\n+#endif\n+\n+EXTERN_C void* memcpy (void*, const void*, size_t);\n+\n+void sink (const void*, ...);\n+\n+char* nowarn_conditional (char *s)\n+{\n+  // Reduced from Glibc's tmpnam.c.\n+  extern char a[5];\n+  char b[5];\n+  char *p = s ? s : b;\n+\n+  sink (p);\n+\n+  if (s == 0)\n+    return a;\n+\n+  return s;\n+}\n+\n+\n+char* nowarn_conditional_memcpy (char *s)\n+{\n+  // Reduced from Glibc's tmpnam.c.\n+  extern char a[5];\n+  char b[5];\n+  char *p = s ? s : b;\n+\n+  sink (p);\n+\n+  if (s == 0)\n+    return (char*)memcpy (a, p, 5);\n+\n+  return s;\n+}\n+\n+\n+int warn_conditional_block (int i)\n+{\n+  int *p;\n+  if (i)\n+  {\n+    int a[] = { 1, 2, 3 };\n+    p = &a[i];\n+  }\n+  else\n+    p = &i;\n+\n+  return *p;        // { dg-warning \"dangling pointer \\('p' \\)to 'a' may be used\" }\n+}"}, {"sha": "e57e66f833682780e1d018b4c4644ba4cff7a4b4", "filename": "gcc/testsuite/c-c++-common/Wdangling-pointer-4.c", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d6a0f388eb048f8d87f47af78f07b5ce513bfe6/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWdangling-pointer-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d6a0f388eb048f8d87f47af78f07b5ce513bfe6/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWdangling-pointer-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWdangling-pointer-4.c?ref=9d6a0f388eb048f8d87f47af78f07b5ce513bfe6", "patch": "@@ -0,0 +1,73 @@\n+/* PR middle-end/63272 - GCC should warn when using pointer to dead scoped\n+   variable within the same function\n+   Exercise -Wdangling-pointer for VLAs.\n+   { dg-do compile }\n+   { dg-options \"-O0 -Wall -ftrack-macro-expansion=0\" } */\n+\n+void sink (void*, ...);\n+\n+void nowarn_vla (int n)\n+{\n+  {\n+    int vla1[n];\n+    int *p1 = vla1;\n+    sink (p1);\n+\n+    {\n+      int vla2[n];\n+      int *p2 = vla2;\n+      sink (p1, p2);\n+\n+      {\n+\tint vla3[n];\n+\tint *p3 = vla3;\n+\tsink (p1, p2, p3);\n+      }\n+      sink (p1, p2);\n+    }\n+    sink (p1);\n+  }\n+}\n+\n+void warn_one_vla (int n)\n+{\n+  int *p;\n+  {\n+    int vla[n];               // { dg-message \"'vla' declared\" \"pr??????\" { xfail *-*-* } }\n+    p = vla;\n+  }\n+  sink (p);                   // { dg-warning \"using a dangling pointer to 'vla'\" \"vla\" { xfail *-*-* } }\n+}\n+\n+\n+void warn_two_vlas_same_block (int n)\n+{\n+  int *p, *q;\n+  {\n+    int vla1[n];              // { dg-message \"'vla1' declared\" \"pr??????\" { xfail *-*-* } }\n+    int vla2[n];              // { dg-message \"'vla2' declared\" \"pr??????\" { xfail *-*-* } }\n+    p = vla1;\n+    q = vla2;\n+  }\n+\n+  sink (p);                   // { dg-warning \"using a dangling pointer to 'vla1'\" \"vla\" { xfail *-*-* } }\n+  sink (q);                   // { dg-warning \"using a dangling pointer to 'vla2'\" \"vla\" { xfail *-*-* } }\n+}\n+\n+\n+void warn_two_vlas_in_series (int n)\n+{\n+  int *p;\n+  {\n+    int vla1[n];              // { dg-message \"'vla1' declared\" \"pr??????\" { xfail *-*-* } }\n+    p = vla1;\n+  }\n+  sink (p);                   // { dg-warning \"using a dangling pointer to 'vla1'\" \"vla\" { xfail *-*-* } }\n+\n+  int *q;\n+  {\n+    int vla2[n];              // { dg-message \"'vla2' declared\" \"pr??????\" { xfail *-*-* } }\n+    q = vla2;\n+  }\n+  sink (q);                   // { dg-warning \"using a dangling pointer to 'vla2'\" \"vla\" { xfail *-*-* } }\n+}"}, {"sha": "1f549ca70a76618bd21ec7f9689c429f19603b87", "filename": "gcc/testsuite/c-c++-common/Wdangling-pointer-5.c", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d6a0f388eb048f8d87f47af78f07b5ce513bfe6/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWdangling-pointer-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d6a0f388eb048f8d87f47af78f07b5ce513bfe6/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWdangling-pointer-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWdangling-pointer-5.c?ref=9d6a0f388eb048f8d87f47af78f07b5ce513bfe6", "patch": "@@ -0,0 +1,90 @@\n+/* PR middle-end/63272 - GCC should warn when using pointer to dead scoped\n+   variable within the same function\n+   Exercise -Wdangling-pointer for escaping stores of addreses of auto\n+   variables.\n+   { dg-do compile }\n+   { dg-options \"-O0 -Wall -ftrack-macro-expansion=0\" } */\n+\n+void* alloca (__SIZE_TYPE__);\n+\n+void* sink (void*, ...);\n+\n+extern void *evp;\n+\n+void nowarn_store_extern_call (void)\n+{\n+  int x;\n+  evp = &x;\n+  sink (0);\n+}\n+\n+void nowarn_store_extern_ovrwrite (void)\n+{\n+  int x;\n+  evp = &x;\n+  evp = 0;\n+}\n+\n+void nowarn_store_extern_store (void)\n+{\n+  int x;\n+  void **p = (void**)sink (&evp);\n+  evp = &x;\n+  *p = 0;\n+}\n+\n+\n+void warn_store_alloca (int n)\n+{\n+  // This fails because of a bug in the warning.\n+  void *p = alloca (n);\n+  evp = p;           // { dg-warning \"storing the address of local variable 'x' in 'evp1'\" \"pr??????\" { xfail *-*-* } }\n+}\n+\n+\n+void warn_store_extern (void)\n+{\n+  extern void *evp1;  // { dg-message \"'evp1' declared here\" }\n+  int x;              // { dg-message \"'x' declared here\" }\n+  evp1 = &x;          // { dg-warning \"storing the address of local variable 'x' in 'evp1'\" }\n+}\n+\n+\n+void nowarn_store_arg_call (void **vpp)\n+{\n+  int x;\n+  *vpp = &x;\n+  sink (0);\n+}\n+\n+void nowarn_store_arg_ovrwrite (void **vpp)\n+{\n+  int x;\n+  *vpp = &x;\n+  *vpp = 0;\n+}\n+\n+void nowarn_store_arg_store (void **vpp)\n+{\n+  int x;\n+  void **p = (void**)sink (0);\n+  *vpp = &x;\n+  *p = 0;\n+}\n+\n+void* nowarn_store_arg_store_arg (void **vpp1, void **vpp2)\n+{\n+  int x;\n+  void **p = (void**)sink (0);\n+  *vpp1 = &x;         // warn here?\n+  *vpp2 = 0;          // might overwrite *vpp1\n+  return p;\n+}\n+\n+void warn_store_arg (void **vpp)\n+{\n+  int x;              // { dg-message \"'x' declared here\" }\n+  *vpp = &x;          // { dg-warning \"storing the address of local variable 'x' in '\\\\*vpp'\" }\n+}\n+\n+"}, {"sha": "9c05891ab23e4b8364615e4241fea9efb0271383", "filename": "gcc/testsuite/c-c++-common/Wdangling-pointer-6.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d6a0f388eb048f8d87f47af78f07b5ce513bfe6/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWdangling-pointer-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d6a0f388eb048f8d87f47af78f07b5ce513bfe6/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWdangling-pointer-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWdangling-pointer-6.c?ref=9d6a0f388eb048f8d87f47af78f07b5ce513bfe6", "patch": "@@ -0,0 +1,32 @@\n+/* PR middle-end/63272 - GCC should warn when using pointer to dead scoped\n+   variable within the same function\n+   Exercise -Wdangling-pointer with inlining.\n+   { dg-do compile }\n+   { dg-options \"-O1 -Wall\" } */\n+\n+void* sink (void*, ...);\n+\n+extern int *eip;      // { dg-message \"'eip' declared here\" }\n+\n+static inline void store (int **p, int *q)\n+{\n+  *p = q;             // { dg-warning \"storing the address of local variable 'auto_x' in 'eip'\" }\n+}\n+\n+void nowarn_inlined_store_extern (void)\n+{\n+  extern int extern_x;\n+  store (&eip, &extern_x);\n+}\n+\n+void nowarn_inlined_store_static (void)\n+{\n+  static int static_x;\n+  store (&eip, &static_x);\n+}\n+\n+void warn_inlined_store_auto (void)\n+{\n+  int auto_x;         // { dg-message \"'auto_x' declared here\" }\n+  store (&eip, &auto_x);\n+}"}, {"sha": "394ff923746db3835014faad9506713172c13ad1", "filename": "gcc/testsuite/c-c++-common/Wdangling-pointer.c", "status": "added", "additions": 434, "deletions": 0, "changes": 434, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d6a0f388eb048f8d87f47af78f07b5ce513bfe6/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWdangling-pointer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d6a0f388eb048f8d87f47af78f07b5ce513bfe6/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWdangling-pointer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWdangling-pointer.c?ref=9d6a0f388eb048f8d87f47af78f07b5ce513bfe6", "patch": "@@ -0,0 +1,434 @@\n+/* PR middle-end/63272 - GCC should warn when using pointer to dead scoped\n+   variable within the same function\n+   Exercise basic cases of -Wdangling-pointer without optimization.\n+   { dg-do compile }\n+   { dg-options \"-O0 -Wall -Wno-uninitialized -ftrack-macro-expansion=0\" } */\n+\n+typedef __INTPTR_TYPE__ intptr_t;\n+typedef __SIZE_TYPE__   size_t;\n+\n+#if __cplusplus\n+#  define EXTERN_C extern \"C\"\n+#else\n+#  define EXTERN_C extern\n+#endif\n+\n+EXTERN_C void* alloca (size_t);\n+EXTERN_C void* malloc (size_t);\n+EXTERN_C void* memchr (const void*, int, size_t);\n+EXTERN_C char* strchr (const char*, int);\n+\n+int sink (const void*, ...);\n+#define sink(...) sink (0, __VA_ARGS__)\n+\n+/* Verify that integer assignments don't cause bogus warnings.\n+   Reduced from GFlibc's s_nextafter.c.  */\n+\n+int nowarn_integer (float x)\n+{\n+  int i;\n+\n+  {\n+    union\n+    {\n+      float x;\n+      int i;\n+    } u;\n+\n+    u.x = x;\n+    i = u.i;\n+  }\n+\n+  return i;\n+}\n+\n+void nowarn_addr (void)\n+{\n+  int *p;\n+  {\n+    int a[] = { 1, 2, 3 };\n+    p = a;\n+  }\n+\n+  // This is suspect but not a clear error.\n+  sink (&p);\n+}\n+\n+\n+char* nowarn_ptr (void)\n+{\n+  char *p;\n+  sink (&p);\n+  return p;\n+}\n+\n+\n+char* nowarn_cond_ptr (void)\n+{\n+  // Distilled from a false positive in Glibc dlerror.c.\n+  char *q;\n+  if (sink (&q))\n+    return q;\n+\n+  return 0;\n+}\n+\n+\n+void nowarn_loop_ptr (int n, int *p)\n+{\n+  // Distilled from a false positive in Glibc td_thr_get_info.c.\n+  for (int i = 0; i != 2; ++i)\n+    {\n+      int x;\n+      sink (&x);\n+      *p++ = x;\n+    }\n+}\n+\n+\n+void nowarn_intptr_t (void)\n+{\n+  intptr_t ip;\n+  {\n+    int a[] = { 1, 2, 3 };\n+    ip = (intptr_t)a;\n+  }\n+\n+  // Using an intptr_t is not diagnosed.\n+  sink (0, ip);\n+}\n+\n+\n+void nowarn_string_literal (void)\n+{\n+  const char *s;\n+  {\n+    s = \"123\";\n+  }\n+\n+  sink (s);\n+}\n+\n+\n+void nowarn_extern_array (int x)\n+{\n+  {\n+    /* This is a silly sanity check.  */\n+    extern int eia[];\n+    int *p;\n+    {\n+      p = eia;\n+    }\n+    sink (p);\n+  }\n+}\n+\n+\n+void nowarn_static_array (int x)\n+{\n+  {\n+    const char *s;\n+    {\n+      static const char sca[] = \"123\";\n+      s = sca;\n+    }\n+\n+    sink (s);\n+  }\n+  {\n+    const int *p;\n+    {\n+      static const int sia[] = { 1, 2, 3 };\n+      p = sia;\n+    }\n+\n+    sink (p);\n+  }\n+  {\n+    const int *p;\n+    {\n+      static const int sia[] = { 1, 2, 3 };\n+      p = (const int*)memchr (sia, x, sizeof sia);\n+    }\n+\n+    sink (p);\n+  }\n+}\n+\n+\n+void nowarn_alloca (unsigned n)\n+{\n+  {\n+    char *p;\n+    {\n+      p = (char*)alloca (n);\n+    }\n+    sink (p);\n+  }\n+  {\n+    int *p;\n+    {\n+      p = (int*)alloca (n * sizeof *p);\n+      sink (p);\n+    }\n+    sink (p);\n+  }\n+  {\n+    long *p;\n+    {\n+      p = (long*)alloca (n * sizeof *p);\n+      sink (p);\n+      p = p + 1;\n+    }\n+    sink (p);\n+  }\n+}\n+\n+\n+#pragma GCC diagnostic push\n+/* Verify that -Wdangling-pointer works with #pragma diagnostic.  */\n+#pragma GCC diagnostic ignored \"-Wdangling-pointer\"\n+\n+void nowarn_scalar_call_ignored (void *vp)\n+{\n+  int *p;\n+  {\n+    int i;\n+    p = &i;\n+  }\n+  sink (p);\n+}\n+\n+#pragma GCC diagnostic pop\n+\n+\n+void* nowarn_return_local_addr (void)\n+{\n+  int a[] = { 1, 2, 3 };\n+  int *p = a;\n+\n+  /* This is a likely bug but it's not really one of using a dangling\n+     pointer but rather of returning the address of a local variable\n+     which is diagnosed by -Wreturn-local-addr.  */\n+  return p;\n+}\n+\n+void* warn_return_local_addr (void)\n+{\n+  int *p = 0;\n+  {\n+    int a[] = { 1, 2, 3 };\n+    p = a;\n+  }\n+\n+  /* Unlike the above case, here the pointer is dangling when it's\n+     used.  */\n+  return p;                   // { dg-warning \"using dangling pointer 'p' to 'a'\" \"array\" }\n+}\n+\n+\n+void* nowarn_return_alloca (int n)\n+{\n+  int *p = (int*)alloca (n);\n+  sink (p);\n+\n+  /* This is a likely bug but it's not really one of using a dangling\n+     pointer but rather of returning the address of a local variable\n+     which is diagnosed by -Wreturn-local-addr.  */\n+  return p;\n+}\n+\n+\n+void warn_scalar_call (void)\n+{\n+  int *p;\n+  {\n+    int i;                    // { dg-message \"'i' declared\" \"note\" }\n+    p = &i;\n+  }\n+  sink (p);                   // { dg-warning \"using dangling pointer 'p' to 'i'\" \"array\" }\n+}\n+\n+\n+void warn_array_call (void)\n+{\n+  int *p;\n+  {\n+    int a[] = { 1, 2, 3 };    // { dg-message \"'a' declared\" \"note\" }\n+    p = a;\n+  }\n+  sink (p);                   // { dg-warning \"using dangling pointer 'p' to 'a'\" \"array\" }\n+}\n+\n+\n+void* warn_array_return (void)\n+{\n+  int *p;\n+  {\n+    int a[] = { 1, 2, 3 };    // { dg-message \"'a' declared\" \"note\" }\n+    p = a;\n+  }\n+  return p;                   // { dg-warning \"using dangling pointer 'p' to 'a'\" \"array\" }\n+}\n+\n+\n+void warn_pr63272_c1 (int i)\n+{\n+  int *p = 0;\n+\n+  if (i)\n+    {\n+      int k = i;              // { dg-message \"'k' declared\" \"note\" }\n+      p = &k;\n+    }\n+\n+  sink (p ? *p : 0);          // { dg-warning \"dangling pointer 'p' to 'k' may be used\" }\n+}\n+\n+\n+void warn_pr63272_c4 (void)\n+{\n+  int *p = 0;\n+\n+  {\n+    int b;                    // { dg-message \"'b' declared\" \"note\" }\n+    p = &b;\n+  }\n+\n+  sink (p);                   // { dg-warning \"using dangling pointer 'p' to 'b'\" \"scalar\" }\n+}\n+\n+void nowarn_cond_if (int i, int n)\n+{\n+  int *p;\n+  if (i)\n+    {\n+      int a[] = { 1, 2 };\n+      p = a;\n+      sink (p);\n+    }\n+  else\n+   {\n+     int *b = (int*)malloc (n);\n+     p = b;\n+     sink (p);\n+   }\n+\n+  p = 0;\n+}\n+\n+\n+void warn_cond_if (int i, int n)\n+{\n+  int *p;\n+  if (i)\n+    {\n+      int a[] = { 1, 2 };     // { dg-message \"'a' declared\" \"note\" }\n+      sink (a);\n+      p = a;\n+    }\n+  else\n+   {\n+     int *b = (int*)malloc (n);\n+     sink (b);\n+     p = b;\n+   }\n+\n+  sink (p);                   // { dg-warning \"dangling pointer 'p' to 'a' may be used\" }\n+}\n+\n+\n+void warn_cond_else (int i, int n)\n+{\n+  int *p;\n+  if (i)\n+    {\n+      int *a = (int*)malloc (n);\n+      sink (a);\n+      p = a;\n+    }\n+  else\n+   {\n+     int b[] = { 2, 3 };\n+     sink (b);\n+     p = b;\n+   }\n+\n+  sink (p);                   // { dg-warning \"dangling pointer 'p' to 'b' may be used\" }\n+}\n+\n+\n+void warn_cond_if_else (int i)\n+{\n+  int *p;\n+  if (i)\n+    {\n+      int a[] = { 1, 2 };     // { dg-message \"'a' declared\" \"note\" }\n+      sink (a);\n+      p = a;\n+    }\n+  else\n+   {\n+     int b[] = { 3, 4 };      // { dg-message \"'b' declared\" \"note\" { xfail *-*-* } }\n+     sink (b);\n+     p = b;\n+   }\n+\n+  /* With a PHI with more than invalid argument, only one use is diagnosed\n+     because after the first diagnostic the code suppresses subsequent\n+     ones for the same use.  This needs to be fixed.  */\n+  sink (p);                   // { dg-warning \"dangling pointer 'p' to 'a' may be used\" }\n+                              // { dg-warning \"dangling pointer 'p' to 'b' may be used\" \"pr??????\" { xfail *-*-* } .-1 }\n+}\n+\n+\n+void nowarn_gcc_i386 (int i)\n+{\n+  // Regression test reduced from gcc's i386.c.\n+  char a[32], *p;\n+\n+  if (i != 1)\n+    p = a;\n+  else\n+    p = 0;\n+\n+  if (i == 2)\n+    sink (p);\n+  else\n+    {\n+      if (p)\n+\t{\n+\t  sink (p);\n+\t  return;\n+\t}\n+      sink (p);\n+    }\n+}\n+\n+\n+void warn_memchr (char c1, char c2, char c3, char c4)\n+{\n+  char *p = 0;\n+  {\n+    char a[] = { c1, c2, c3 };// { dg-message \"'a' declared\" \"note\" }\n+    p = (char*)memchr (a, c4, 3);\n+    if (!p)\n+      return;\n+  }\n+\n+  sink (p);                   // { dg-warning \"using dangling pointer 'p' to 'a'\" }\n+}\n+\n+\n+void warn_strchr (char c1, char c2, char c3, char c4)\n+{\n+  char *p = 0;\n+  {\n+    char a[] = { c1, c2, c3 }; // { dg-message \"'a' declared\" \"note\" }\n+    p = (char*)strchr (a, c4);\n+    if (!p)\n+      return;\n+  }\n+\n+  sink (p);                   // { dg-warning \"using dangling pointer 'p' to 'a'\" }\n+}"}, {"sha": "151418f3c320a6dcda269a4507a6bcdc0853fc2d", "filename": "gcc/testsuite/g++.dg/warn/Wdangling-pointer-2.C", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d6a0f388eb048f8d87f47af78f07b5ce513bfe6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWdangling-pointer-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d6a0f388eb048f8d87f47af78f07b5ce513bfe6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWdangling-pointer-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWdangling-pointer-2.C?ref=9d6a0f388eb048f8d87f47af78f07b5ce513bfe6", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do compile }\n+   { dg-options \"-O1 -Wall -Wno-class-memaccess\" } */\n+\n+struct A { A (); };\n+\n+const A& return_arg (const A &a)\n+{\n+  return a;\n+}\n+\n+void sink (const void*);\n+\n+void nowarn_ref (int i)\n+{\n+  const A &a = return_arg (A ()); // { dg-note \"unnamed temporary\" }\n+  sink (&a);                      // { dg-warning \"-Wdangling-pointer\" }\n+}\n+\n+void warn_dangling_ref (int i)\n+{\n+  const A &a = return_arg (A ()); // { dg-note \"unnamed temporary\" }\n+  sink (&a);                      // { dg-warning \"-Wdangling-pointer\" }\n+}"}, {"sha": "22c559e4adafea3e6c86b31c78258be9c092138c", "filename": "gcc/testsuite/g++.dg/warn/Wdangling-pointer.C", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d6a0f388eb048f8d87f47af78f07b5ce513bfe6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWdangling-pointer.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d6a0f388eb048f8d87f47af78f07b5ce513bfe6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWdangling-pointer.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWdangling-pointer.C?ref=9d6a0f388eb048f8d87f47af78f07b5ce513bfe6", "patch": "@@ -0,0 +1,74 @@\n+/* Exercise basic C++-only cases of -Wdangling-pointer.\n+   { dg-do compile }\n+   { dg-options \"-Wall -Wno-class-memaccess\" } */\n+\n+extern \"C\" void* memset (void*, int, __SIZE_TYPE__);\n+\n+void sink (const void*, ...);\n+\n+struct S { S (); };\n+\n+void nowarn_int_ref (int i)\n+{\n+  const S &sref = S ();\n+  const int &iref = 1 + i;\n+  sink (&sref, &iref);\n+}\n+\n+void warn_init_ref_member ()\n+{\n+  struct AS\n+  {\n+    const S &sref;\n+    AS ():\n+      // The temporary S object is destroyed when AS::AS() returns.\n+      sref (S ())  // { dg-warning \"storing the address\" }\n+    { }\n+  } as;\n+\n+  struct Ai\n+  {\n+    const int &iref;\n+    Ai ():\n+      // The temporary int is destroyed when Ai::Ai() returns.\n+      iref (1 + 1)  // { dg-warning \"storing the address\" }\n+    { }\n+  } ai;\n+\n+  sink (&as, &ai);\n+}\n+\n+\n+void default_ref_arg (const S& = S ());\n+\n+void nowarn_call_default_ref_arg ()\n+{\n+  default_ref_arg ();\n+}\n+\n+\n+void nowarn_array_access ()\n+{\n+  /* Verify that the clobber in the exceptional basic block doesn't\n+     cause bogus warnings.  */\n+  S a[1];\n+  memset (a, 0, sizeof a);\n+  sink (a);\n+}\n+\n+\n+void nowarn_array_access_cond (int i)\n+{\n+  if (i)\n+    {\n+      S a1[1];\n+      memset (a1, 0, sizeof a1);\n+      sink (a1);\n+    }\n+  else\n+    {\n+      S a2[2];\n+      memset (a2, 0, sizeof a2);\n+      sink (a2);\n+    }\n+}"}, {"sha": "91a87786ae02c2c9ac1da225d27898373368d383", "filename": "gcc/testsuite/g++.dg/warn/Wfree-nonheap-object-6.C", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d6a0f388eb048f8d87f47af78f07b5ce513bfe6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWfree-nonheap-object-6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d6a0f388eb048f8d87f47af78f07b5ce513bfe6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWfree-nonheap-object-6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWfree-nonheap-object-6.C?ref=9d6a0f388eb048f8d87f47af78f07b5ce513bfe6", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile }\n-   { dg-options \"-O0 -Wall\" } */\n+   { dg-options \"-O0 -Wall -Wno-dangling-pointer -Wno-return-local-address\" } */\n \n #if __cplusplus < 201103L\n # define noexcept throw ()\n@@ -18,6 +18,8 @@ extern void *p;\n void nowarn_placement_new ()\n {\n   char a[sizeof (A)];\n+  /* The store to the global p might trigger -Wdangling pointer or\n+     -Wreturn-local-address (if/when it runs without optimization).  */\n   p = new (a) A ();           // { dg-bogus \"-Wfree-nonheap-object\" }\n }\n "}, {"sha": "b09d9215310d6ca8f86a177592ffe23561096271", "filename": "gcc/testsuite/g++.dg/warn/ref-temp1.C", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d6a0f388eb048f8d87f47af78f07b5ce513bfe6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Fref-temp1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d6a0f388eb048f8d87f47af78f07b5ce513bfe6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Fref-temp1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Fref-temp1.C?ref=9d6a0f388eb048f8d87f47af78f07b5ce513bfe6", "patch": "@@ -9,3 +9,6 @@ struct Y {\n };\n \n Y::Y () : x(1) {}\t\t// { dg-warning \"temporary\" }\n+\n+/* The initialization of x with the temporary might also trigger:\n+   { dg-prune-output \"-Wdangling-pointer\" } */"}, {"sha": "017026394920df242733414bfd00d25fad1a6d80", "filename": "gcc/testsuite/gcc.dg/Wdangling-pointer-2.c", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d6a0f388eb048f8d87f47af78f07b5ce513bfe6/gcc%2Ftestsuite%2Fgcc.dg%2FWdangling-pointer-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d6a0f388eb048f8d87f47af78f07b5ce513bfe6/gcc%2Ftestsuite%2Fgcc.dg%2FWdangling-pointer-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWdangling-pointer-2.c?ref=9d6a0f388eb048f8d87f47af78f07b5ce513bfe6", "patch": "@@ -0,0 +1,82 @@\n+/* Exercise conditional C-only uses of dangling pointers with optimization.\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall\" } */\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+extern void* memchr (const void*, int, size_t);\n+extern char* strchr (const char*, int);\n+\n+void sink (void*, ...);\n+\n+\n+void nowarn_compound_literal (int i, int j)\n+{\n+  {\n+    int *p = i ? (int[]){ 1, 2, 3 } : (int[]){ 4, 5, 6 };\n+    sink (p);\n+  }\n+  {\n+    int a[] = { 1, 2, 3 };\n+    int *q = i ? (int[]){ 4, 5, 6 } : a;\n+    int *p = &q[1];\n+    sink (p);\n+  }\n+  {\n+    int *p = i ? (int[]){ 1, 2, 3 } : (int[]){ 4, 5, 6 };\n+    int *q = __builtin_memchr (p, 2, 3 * sizeof *p);\n+    sink (q);\n+  }\n+  {\n+    int a[] = { i, i + 1, i + 2, 3 };\n+    int *p = i ? (int[]){ j, j + 1, j + 2, 3 } : a;\n+    int *q = __builtin_memchr (p, 3, 4 * sizeof *p);\n+    sink (q);\n+  }\n+}\n+\n+\n+void warn_maybe_compound_literal (int i, int j)\n+{\n+  int a[] = { 1, 2, 3 }, *p;\n+  {\n+    p = i ? (int[]){ 4, 5, 6 } : a;\n+  }\n+  // When the 'p' is optimized away it's not mentioned in the warning.\n+  sink (p);         // { dg-warning \"dangling pointer \\('p' \\)?to an unnamed temporary may be used\" }\n+}\n+\n+\n+void warn_maybe_compound_literal_memchr (int i, int j, int x)\n+{\n+  int a[] = { 1, 2, 3 }, *p;\n+  {\n+    int *q = i ? (int[]){ 4, 5, 6 } : a;\n+    p = memchr (q, x, 3 * sizeof *q);\n+  }\n+  sink (p);         // { dg-warning \"dangling pointer 'p' to an unnamed temporary may be used\" }\n+}\n+\n+\n+void warn_maybe_array (int i, int j)\n+{\n+  int a[] = { 1, 2, 3 }, *p;\n+  {\n+    int b[] = { 4, 5, 6 };\n+    p = i ? a : b;\n+  }\n+  // When the 'p' is optimized away it's not mentioned in the warning.\n+  sink (p);         // { dg-warning \"dangling pointer \\('p' \\)?to 'b' may be used\" }\n+}\n+\n+\n+void warn_maybe_array_memchr (int i, int j, int x)\n+{\n+  int a[] = { 1, 2, 3 }, *p;\n+  {\n+    int b[] = { 4, 5, 6 };\n+    int *q = i ? a : b;\n+    p = memchr (q, x, 3 * sizeof *q);\n+  }\n+  sink (p);         // { dg-warning \"dangling pointer 'p' to 'b' may be used\" }\n+}"}, {"sha": "d792d09ffca49ce91802a1e770fef4dc2e23ab67", "filename": "gcc/testsuite/gcc.dg/Wdangling-pointer.c", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d6a0f388eb048f8d87f47af78f07b5ce513bfe6/gcc%2Ftestsuite%2Fgcc.dg%2FWdangling-pointer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d6a0f388eb048f8d87f47af78f07b5ce513bfe6/gcc%2Ftestsuite%2Fgcc.dg%2FWdangling-pointer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWdangling-pointer.c?ref=9d6a0f388eb048f8d87f47af78f07b5ce513bfe6", "patch": "@@ -0,0 +1,75 @@\n+/* Exercise basic C-only cases of -Wdangling-pointer.\n+   { dg-do compile }\n+   { dg-options \"-O0 -Wall\" } */\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+extern void* memchr (const void*, int, size_t);\n+extern char* strchr (const char*, int);\n+\n+void sink (const void*, ...);\n+\n+\n+void nowarn_compound_literal (int i)\n+{\n+  {\n+    int *p = (int[]){ 1, 2, 3 };\n+    sink (p);\n+  }\n+  {\n+    int *q = (int[]){ 1, 2, 3 };\n+    int *p = &q[1];\n+    sink (p);\n+  }\n+  {\n+    int *p = __builtin_memchr ((int[]){ 1, 2, 3 }, 2, 3 * sizeof *p);\n+    sink (p);\n+  }\n+  {\n+    int *p = __builtin_memchr ((int[]){ i, i + 1 }, 3, 2 * sizeof *p);\n+    sink (p);\n+  }\n+}\n+\n+\n+void warn_compound_literal (int i)\n+{\n+  int *p;\n+  {\n+    p = (int[]){ 1, 2, 3 };   // { dg-message \"unnamed temporary\" },\n+  }\n+  sink (p);                   // { dg-warning \"using dangling pointer 'p' to an unnamed temporary\" }\n+\n+  {\n+    int *q =\n+      (int[]){ 1, 2, 3 };     // { dg-message \"unnamed temporary\" },\n+    p = &q[1];\n+  }\n+  sink (p);                   // { dg-warning \"using dangling pointer 'p' to an unnamed temporary\" }\n+  {\n+    p = (int*)memchr (\n+\t  (int[]){ 1, 2, 3 }, // { dg-message \"unnamed temporary\" }\n+\t  2, 3 * sizeof *p);\n+  }\n+  sink (p);                   // { dg-warning \"using dangling pointer 'p' to an unnamed temporary\" }\n+\n+  {\n+    p = (int*)memchr (\n+\t  (int[]){ i, i + 1 },// { dg-message \"unnamed temporary\" }\n+\t  3, 2 * sizeof *p);\n+  }\n+  sink (p);                   // { dg-warning \"using dangling pointer 'p' to an unnamed temporary\" }\n+}\n+\n+\n+void warn_store_compound_literal (int **p)\n+{\n+  int *q = (int[]) { 1, 2, 3 };\n+  p[0] = q;                   // { dg-warning \"storing the address\" }\n+}\n+\n+void warn_store_vla (int n, int **p)\n+{\n+  int a[n];\n+  p[1] = &a[1];               // { dg-warning \"-Wdangling-pointer\" \"pr??????\" { xfail *-*-* } }\n+}"}, {"sha": "37201841ad5e5b552099ed8ebe6a91e1be930c3a", "filename": "gcc/testsuite/gcc.dg/uninit-pr50476.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d6a0f388eb048f8d87f47af78f07b5ce513bfe6/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pr50476.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d6a0f388eb048f8d87f47af78f07b5ce513bfe6/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pr50476.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-pr50476.c?ref=9d6a0f388eb048f8d87f47af78f07b5ce513bfe6", "patch": "@@ -7,7 +7,7 @@ int *x = 0;\n void f (void)\n {\n   int y = 1;\n-  x = &y;\n+  x = &y;       // { dg-warning \"\\\\\\[-Wdangling-pointer\" }\n }\n \n int g (void)"}]}