{"sha": "48126a9798aace080f17f517d6eb43500471cdb6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDgxMjZhOTc5OGFhY2UwODBmMTdmNTE3ZDZlYjQzNTAwNDcxY2RiNg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2002-10-17T17:09:17Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2002-10-17T17:09:17Z"}, "message": "re PR other/8062 (double precision loads and stores missing from xmmintrin.h)\n\n\n\t* mmintrin.h: Guard by __MMX__\n\t* xmmintrin.h: Guard by __SSE__\n\n\tPR other/8062\n\t* xmmintrin.h (_MM_SHUFFLE2): New macro.\n\t(_mm_load*_?d): New functions.\n\t(_mm_set*_?d): New functions.\n\t(_mm_store*_?d): New functions.\n\nFrom-SVN: r58252", "tree": {"sha": "beaad9a59843edfafe6849b2e9b20496e1cba455", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/beaad9a59843edfafe6849b2e9b20496e1cba455"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/48126a9798aace080f17f517d6eb43500471cdb6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48126a9798aace080f17f517d6eb43500471cdb6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/48126a9798aace080f17f517d6eb43500471cdb6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48126a9798aace080f17f517d6eb43500471cdb6/comments", "author": null, "committer": null, "parents": [{"sha": "d768a5895b5949df369fec4e91d7923ba7097261", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d768a5895b5949df369fec4e91d7923ba7097261", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d768a5895b5949df369fec4e91d7923ba7097261"}], "stats": {"total": 188, "additions": 187, "deletions": 1}, "files": [{"sha": "3ec27fbbd657198f58d34279658ae56cb00a046c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48126a9798aace080f17f517d6eb43500471cdb6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48126a9798aace080f17f517d6eb43500471cdb6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=48126a9798aace080f17f517d6eb43500471cdb6", "patch": "@@ -1,3 +1,14 @@\n+Thu Oct 17 18:40:47 CEST 2002  Jan Hubicka  <jh@suse.cz>\n+\n+\t* mmintrin.h: Guard by __MMX__\n+\t* xmmintrin.h: Guard by __SSE__\n+\n+\tPR other/8062\n+\t* xmmintrin.h (_MM_SHUFFLE2): New macro.\n+\t(_mm_load*_?d): New functions.\n+\t(_mm_set*_?d): New functions.\n+\t(_mm_store*_?d): New functions.\n+\n Wed Oct 16 15:01:29 CEST 2002  Jan Hubicka  <jh@suse.cz>\n \n \tReally commit patch announced at Oct 14"}, {"sha": "739db6a287e38d430bed685d5389030e5bcbe130", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48126a9798aace080f17f517d6eb43500471cdb6/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48126a9798aace080f17f517d6eb43500471cdb6/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=48126a9798aace080f17f517d6eb43500471cdb6", "patch": "@@ -13315,6 +13315,11 @@ ix86_expand_builtin (exp, target, subtarget, mode, ignore)\n     case IX86_BUILTIN_STORERPD:\n       return ix86_expand_store_builtin (CODE_FOR_sse2_movapd, arglist);\n \n+    case IX86_BUILTIN_CLRPD:\n+      target = gen_reg_rtx (V2DFmode);\n+      emit_insn (gen_sse_clrv2df (target));\n+      return target;\n+\n     case IX86_BUILTIN_MFENCE:\n \temit_insn (gen_sse2_mfence ());\n \treturn 0;"}, {"sha": "095de745e40f7b8b36c27889dcfc2db69db38669", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48126a9798aace080f17f517d6eb43500471cdb6/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48126a9798aace080f17f517d6eb43500471cdb6/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=48126a9798aace080f17f517d6eb43500471cdb6", "patch": "@@ -18810,6 +18810,17 @@\n    (set_attr \"memory\" \"none\")\n    (set_attr \"mode\" \"V4SF\")])\n \n+;; Use xor, but don't show input operands so they aren't live before\n+;; this insn.\n+(define_insn \"sse_clrv2df\"\n+  [(set (match_operand:V2DF 0 \"register_operand\" \"=x\")\n+        (unspec:V2DF [(const_int 0)] UNSPEC_NOP))]\n+  \"TARGET_SSE2\"\n+  \"xorpd\\t{%0, %0|%0, %0}\"\n+  [(set_attr \"type\" \"sselog\")\n+   (set_attr \"memory\" \"none\")\n+   (set_attr \"mode\" \"V4SF\")])\n+\n ;; SSE mask-generating compares\n \n (define_insn \"maskcmpv4sf3\""}, {"sha": "2defd50d6d642669c50da4bd8f29bbdcc103bb30", "filename": "gcc/config/i386/mmintrin.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48126a9798aace080f17f517d6eb43500471cdb6/gcc%2Fconfig%2Fi386%2Fmmintrin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48126a9798aace080f17f517d6eb43500471cdb6/gcc%2Fconfig%2Fi386%2Fmmintrin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fmmintrin.h?ref=48126a9798aace080f17f517d6eb43500471cdb6", "patch": "@@ -30,6 +30,9 @@\n #ifndef _MMINTRIN_H_INCLUDED\n #define _MMINTRIN_H_INCLUDED\n \n+#ifndef __MMX__\n+# error \"MMX instruction set not enabled\"\n+#else\n /* The data type intended for user use.  */\n typedef unsigned long long __m64 __attribute__ ((__aligned__ (8)));\n \n@@ -539,4 +542,5 @@ _mm_set1_pi8 (char __b)\n   return _mm_set1_pi32 (__i);\n }\n \n+#endif /* __MMX__ */\n #endif /* _MMINTRIN_H_INCLUDED */"}, {"sha": "8c4aa62acbf0b472a6517f6f5ed696e4f15172d7", "filename": "gcc/config/i386/xmmintrin.h", "status": "modified", "additions": 156, "deletions": 1, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48126a9798aace080f17f517d6eb43500471cdb6/gcc%2Fconfig%2Fi386%2Fxmmintrin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48126a9798aace080f17f517d6eb43500471cdb6/gcc%2Fconfig%2Fi386%2Fxmmintrin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fxmmintrin.h?ref=48126a9798aace080f17f517d6eb43500471cdb6", "patch": "@@ -30,6 +30,10 @@\n #ifndef _XMMINTRIN_H_INCLUDED\n #define _XMMINTRIN_H_INCLUDED\n \n+#ifndef __SSE__\n+# error \"SSE instruction set not enabled\"\n+#else\n+\n /* We need type definitions from the MMX header file.  */\n #include <mmintrin.h>\n \n@@ -1082,9 +1086,159 @@ typedef int __v4si __attribute__ ((mode (V4SI)));\n typedef int __v8hi __attribute__ ((mode (V8HI)));\n typedef int __v16qi __attribute__ ((mode (V16QI)));\n \n+/* Create a selector for use with the SHUFPD instruction.  */\n+#define _MM_SHUFFLE2(fp1,fp0) \\\n+ (((fp1) << 1) | (fp0))\n+\n #define __m128i __v2di\n #define __m128d __v2df\n \n+/* Create a vector with element 0 as *P and the rest zero.  */\n+static __inline __m128d\n+_mm_load_sd (double *__P)\n+{\n+  return (__m128d) __builtin_ia32_loadsd (__P);\n+}\n+\n+/* Create a vector with all two elements equal to *P.  */\n+static __inline __m128d\n+_mm_load1_pd (double *__P)\n+{\n+  __v2df __tmp = __builtin_ia32_loadsd (__P);\n+  return (__m128d) __builtin_ia32_shufpd (__tmp, __tmp, _MM_SHUFFLE2 (0,0));\n+}\n+\n+static __inline __m128d\n+_mm_load_pd1 (double *__P)\n+{\n+  return _mm_load1_pd (__P);\n+}\n+\n+/* Load two DPFP values from P.  The addresd must be 16-byte aligned.  */\n+static __inline __m128d\n+_mm_load_pd (double *__P)\n+{\n+  return (__m128d) __builtin_ia32_loadapd (__P);\n+}\n+\n+/* Load two DPFP values from P.  The addresd need not be 16-byte aligned.  */\n+static __inline __m128d\n+_mm_loadu_pd (double *__P)\n+{\n+  return (__m128d) __builtin_ia32_loadupd (__P);\n+}\n+\n+/* Load two DPFP values in reverse order.  The addresd must be aligned.  */\n+static __inline __m128d\n+_mm_loadr_pd (double *__P)\n+{\n+  __v2df __tmp = __builtin_ia32_loadapd (__P);\n+  return (__m128d) __builtin_ia32_shufpd (__tmp, __tmp, _MM_SHUFFLE2 (0,1));\n+}\n+\n+/* Create a vector with element 0 as F and the rest zero.  */\n+static __inline __m128d\n+_mm_set_sd (double __F)\n+{\n+  return (__m128d) __builtin_ia32_loadsd (&__F);\n+}\n+\n+/* Create a vector with all two elements equal to F.  */\n+static __inline __m128d\n+_mm_set1_pd (double __F)\n+{\n+  __v2df __tmp = __builtin_ia32_loadsd (&__F);\n+  return (__m128d) __builtin_ia32_shufpd (__tmp, __tmp, _MM_SHUFFLE2 (0,0));\n+}\n+\n+static __inline __m128d\n+_mm_set_pd1 (double __F)\n+{\n+  return _mm_set1_pd (__F);\n+}\n+\n+/* Create the vector [Z Y].  */\n+static __inline __m128d\n+_mm_set_pd (double __Z, double __Y)\n+{\n+  union {\n+    double __a[2];\n+    __m128d __v;\n+  } __u;\n+\n+  __u.__a[0] = __Y;\n+  __u.__a[1] = __Z;\n+\n+  return __u.__v;\n+}\n+\n+/* Create the vector [Y Z].  */\n+static __inline __m128d\n+_mm_setr_pd (double __Z, double __Y)\n+{\n+  return _mm_set_pd (__Y, __Z);\n+}\n+\n+/* Create a vector of zeros.  */\n+static __inline __m128d\n+_mm_setzero_pd (void)\n+{\n+  return (__m128d) __builtin_ia32_setzeropd ();\n+}\n+\n+/* Stores the lower DPFP value.  */\n+static __inline void\n+_mm_store_sd (double *__P, __m128d __A)\n+{\n+  __builtin_ia32_storesd (__P, (__v2df)__A);\n+}\n+\n+/* Store the lower DPFP value acrosd two words.  */\n+static __inline void\n+_mm_store1_pd (double *__P, __m128d __A)\n+{\n+  __v2df __va = (__v2df)__A;\n+  __v2df __tmp = __builtin_ia32_shufpd (__va, __va, _MM_SHUFFLE2 (0,0));\n+  __builtin_ia32_storeapd (__P, __tmp);\n+}\n+\n+static __inline void\n+_mm_store_pd1 (double *__P, __m128d __A)\n+{\n+  _mm_store1_pd (__P, __A);\n+}\n+\n+/* Store two DPFP values.  The addresd must be 16-byte aligned.  */\n+static __inline void\n+_mm_store_pd (double *__P, __m128d __A)\n+{\n+  __builtin_ia32_storeapd (__P, (__v2df)__A);\n+}\n+\n+/* Store two DPFP values.  The addresd need not be 16-byte aligned.  */\n+static __inline void\n+_mm_storeu_pd (double *__P, __m128d __A)\n+{\n+  __builtin_ia32_storeupd (__P, (__v2df)__A);\n+}\n+\n+/* Store two DPFP values in reverse order.  The addresd must be aligned.  */\n+static __inline void\n+_mm_storer_pd (double *__P, __m128d __A)\n+{\n+  __v2df __va = (__v2df)__A;\n+  __v2df __tmp = __builtin_ia32_shufpd (__va, __va, _MM_SHUFFLE2 (0,1));\n+  __builtin_ia32_storeapd (__P, __tmp);\n+}\n+\n+/* Sets the low DPFP value of A from the low value of B.  */\n+static __inline __m128d\n+_mm_move_sd (__m128d __A, __m128d __B)\n+{\n+  return (__m128d) __builtin_ia32_movsd ((__v2df)__A, (__v2df)__B);\n+}\n+\n+\n static __inline __m128d\n _mm_add_pd (__m128d __A, __m128d __B)\n {\n@@ -2013,6 +2167,7 @@ _mm_mfence (void)\n   __builtin_ia32_mfence ();\n }\n \n-#endif /* __SSE2_BUILTINS__  */\n+#endif /* __SSE2__  */\n \n+#endif /* __SSE__ */\n #endif /* _XMMINTRIN_H_INCLUDED */"}]}