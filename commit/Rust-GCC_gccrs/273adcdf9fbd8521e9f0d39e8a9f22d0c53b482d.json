{"sha": "273adcdf9fbd8521e9f0d39e8a9f22d0c53b482d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjczYWRjZGY5ZmJkODUyMWU5ZjBkMzllOGE5ZjIyZDBjNTNiNDgyZA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-02T10:31:12Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-02T10:31:12Z"}, "message": "[multiple changes]\n\n2011-08-02  Jerome Guitton  <guitton@adacore.com>\n\n\t* a-except-2005.adb (Raise_From_Signal_Handler): Call\n\tDebug_Raise_Exception before propagation starts.\n\n2011-08-02  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* exp_ch6.adb (Expand_Call): Guard restriction checks with a call\n\tto Restriction_Check_Required.\n\t* sem_ch3.adb (Analyze_Object_Declaration): Likewise.\n\t* sem_res.adb (Resolve_Call): Likewise.\n\t* sem_attr.adb (Check_Stream_Attribute): Likewise.\n\n2011-08-02  Bob Duff  <duff@adacore.com>\n\n\t* stylesw.ads: Update comment.\n\t* style.adb: Minor: Use Error_Msg_NE instead of Error_Msg_N.\n\t* errout.ads: Remove obsolete comment.\n\n2011-08-02  Javier Miranda  <miranda@adacore.com>\n\n\t* einfo.ads, einfo.adb (Is_Safe_To_Reevaluate): new function.\n\t(Set_Is_Safe_To_Reevaluate): new procedure.\n\t* sem_ch5.adb (Analyze_Assignment): Add one assertion to ensure that no\n\tassignment is allowed on safe-to-reevaluate variables.\n\t(Analyze_Iteration_Schine.Process_Bounds.One_Bound): Decorate the\n\ttemporary created to remove side effects in expressions that use\n\tthe secondary stack as safe-to-reevaluate.\n\t* exp_util.adb (Side_Effect_Free): Add missing code to handle well\n\tvariables that are not true constants.\n\nFrom-SVN: r177129", "tree": {"sha": "c6d75d4be98fa0d41f80672f7a72776b9bf54c64", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c6d75d4be98fa0d41f80672f7a72776b9bf54c64"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/273adcdf9fbd8521e9f0d39e8a9f22d0c53b482d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/273adcdf9fbd8521e9f0d39e8a9f22d0c53b482d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/273adcdf9fbd8521e9f0d39e8a9f22d0c53b482d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/273adcdf9fbd8521e9f0d39e8a9f22d0c53b482d/comments", "author": null, "committer": null, "parents": [{"sha": "6320f5e18ed03cb41e65e640566d2a9cf1cd5690", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6320f5e18ed03cb41e65e640566d2a9cf1cd5690", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6320f5e18ed03cb41e65e640566d2a9cf1cd5690"}], "stats": {"total": 584, "additions": 331, "deletions": 253}, "files": [{"sha": "693d865430258a70000a8e8e4f34e332084fbd6e", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/273adcdf9fbd8521e9f0d39e8a9f22d0c53b482d/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/273adcdf9fbd8521e9f0d39e8a9f22d0c53b482d/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=273adcdf9fbd8521e9f0d39e8a9f22d0c53b482d", "patch": "@@ -1,3 +1,34 @@\n+2011-08-02  Jerome Guitton  <guitton@adacore.com>\n+\n+\t* a-except-2005.adb (Raise_From_Signal_Handler): Call\n+\tDebug_Raise_Exception before propagation starts.\n+\n+2011-08-02  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* exp_ch6.adb (Expand_Call): Guard restriction checks with a call\n+\tto Restriction_Check_Required.\n+\t* sem_ch3.adb (Analyze_Object_Declaration): Likewise.\n+\t* sem_res.adb (Resolve_Call): Likewise.\n+\t* sem_attr.adb (Check_Stream_Attribute): Likewise.\n+\n+2011-08-02  Bob Duff  <duff@adacore.com>\n+\n+\t* stylesw.ads: Update comment.\n+\t* style.adb: Minor: Use Error_Msg_NE instead of Error_Msg_N.\n+\t* errout.ads: Remove obsolete comment.\n+\n+2011-08-02  Javier Miranda  <miranda@adacore.com>\n+\n+\t* einfo.ads, einfo.adb (Is_Safe_To_Reevaluate): new function.\n+\t(Set_Is_Safe_To_Reevaluate): new procedure.\n+\t* sem_ch5.adb (Analyze_Assignment): Add one assertion to ensure that no\n+\tassignment is allowed on safe-to-reevaluate variables.\n+\t(Analyze_Iteration_Schine.Process_Bounds.One_Bound): Decorate the\n+\ttemporary created to remove side effects in expressions that use\n+\tthe secondary stack as safe-to-reevaluate.\n+\t* exp_util.adb (Side_Effect_Free): Add missing code to handle well\n+\tvariables that are not true constants.\n+\n 2011-08-02  Robert Dewar  <dewar@adacore.com>\n \n \t* sem_ch5.adb, sem_ch7.adb, einfo.ads, sem_util.adb, sem_util.ads,"}, {"sha": "d7763db6b8cf5df12de0e30b2c6fb5cdcc3904e5", "filename": "gcc/ada/a-except-2005.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/273adcdf9fbd8521e9f0d39e8a9f22d0c53b482d/gcc%2Fada%2Fa-except-2005.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/273adcdf9fbd8521e9f0d39e8a9f22d0c53b482d/gcc%2Fada%2Fa-except-2005.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-except-2005.adb?ref=273adcdf9fbd8521e9f0d39e8a9f22d0c53b482d", "patch": "@@ -924,6 +924,7 @@ package body Ada.Exceptions is\n    begin\n       Exception_Data.Set_Exception_C_Msg (E, M);\n       Abort_Defer.all;\n+      Debug_Raise_Exception (E => SSL.Exception_Data_Ptr (E));\n       Exception_Propagation.Propagate_Exception\n         (E => E, From_Signal_Handler => True);\n    end Raise_From_Signal_Handler;"}, {"sha": "eb217d49d59390fdbfd53290ab9668f18399afed", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/273adcdf9fbd8521e9f0d39e8a9f22d0c53b482d/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/273adcdf9fbd8521e9f0d39e8a9f22d0c53b482d/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=273adcdf9fbd8521e9f0d39e8a9f22d0c53b482d", "patch": "@@ -514,9 +514,9 @@ package body Einfo is\n    --    Is_Underlying_Record_View       Flag246\n    --    OK_To_Rename                    Flag247\n    --    Has_Inheritable_Invariants      Flag248\n+   --    Is_Safe_To_Reevaluate           Flag249\n    --    Has_Predicates                  Flag250\n \n-   --    (unused)                        Flag249\n    --    (unused)                        Flag251\n    --    (unused)                        Flag252\n    --    (unused)                        Flag253\n@@ -2058,6 +2058,11 @@ package body Einfo is\n       return Flag209 (Id);\n    end Is_Return_Object;\n \n+   function Is_Safe_To_Reevaluate (Id : E) return B is\n+   begin\n+      return Flag249 (Id);\n+   end Is_Safe_To_Reevaluate;\n+\n    function Is_Shared_Passive (Id : E) return B is\n    begin\n       return Flag60 (Id);\n@@ -4542,6 +4547,12 @@ package body Einfo is\n       Set_Flag209 (Id, V);\n    end Set_Is_Return_Object;\n \n+   procedure Set_Is_Safe_To_Reevaluate (Id : E; V : B := True) is\n+   begin\n+      pragma Assert (Ekind (Id) = E_Variable);\n+      Set_Flag249 (Id, V);\n+   end Set_Is_Safe_To_Reevaluate;\n+\n    procedure Set_Is_Shared_Passive (Id : E; V : B := True) is\n    begin\n       Set_Flag60 (Id, V);\n@@ -7501,6 +7512,7 @@ package body Einfo is\n       W (\"Is_Remote_Types\",                 Flag61  (Id));\n       W (\"Is_Renaming_Of_Object\",           Flag112 (Id));\n       W (\"Is_Return_Object\",                Flag209 (Id));\n+      W (\"Is_Safe_To_Reevaluate\",           Flag249 (Id));\n       W (\"Is_Shared_Passive\",               Flag60  (Id));\n       W (\"Is_Statically_Allocated\",         Flag28  (Id));\n       W (\"Is_Tag\",                          Flag78  (Id));"}, {"sha": "e69704d86ab6a22efbf3863408c1b97aa3884572", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/273adcdf9fbd8521e9f0d39e8a9f22d0c53b482d/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/273adcdf9fbd8521e9f0d39e8a9f22d0c53b482d/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=273adcdf9fbd8521e9f0d39e8a9f22d0c53b482d", "patch": "@@ -2683,6 +2683,12 @@ package Einfo is\n --       Present in all object entities. True if the object is the return\n --       object of an extended_return_statement; False otherwise.\n \n+--    Is_Safe_To_Reevaluate (Flag249)\n+--       Present in all entities. Set in variables that are initialized by\n+--       means of an assignment statement. When initialized their contents\n+--       never change and hence they can be seen by the backend as constants.\n+--       See also Is_True_Constant.\n+\n --    Is_Scalar_Type (synthesized)\n --       Applies to all entities, true for scalar types and subtypes\n \n@@ -2771,7 +2777,7 @@ package Einfo is\n --       treated as a constant by the code generator. For a constant, it means\n --       that the constant was not modified by generated code (e.g. to set a\n --       discriminant in an init proc). Assignments by user or generated code\n---       will reset this flag.\n+--       will reset this flag. See also Is_Safe_To_Reevaluate.\n \n --    Is_Type (synthesized)\n --       Applies to all entities, true for a type entity\n@@ -5659,6 +5665,7 @@ package Einfo is\n    --    Has_Volatile_Components             (Flag87)\n    --    Is_Atomic                           (Flag85)\n    --    Is_Eliminated                       (Flag124)\n+   --    Is_Safe_To_Reevaluate               (Flag249)\n    --    Is_Shared_Passive                   (Flag60)\n    --    Is_True_Constant                    (Flag163)\n    --    Is_Volatile                         (Flag16)\n@@ -6165,6 +6172,7 @@ package Einfo is\n    function Is_Remote_Types                     (Id : E) return B;\n    function Is_Renaming_Of_Object               (Id : E) return B;\n    function Is_Return_Object                    (Id : E) return B;\n+   function Is_Safe_To_Reevaluate               (Id : E) return B;\n    function Is_Shared_Passive                   (Id : E) return B;\n    function Is_Statically_Allocated             (Id : E) return B;\n    function Is_Tag                              (Id : E) return B;\n@@ -6753,6 +6761,7 @@ package Einfo is\n    procedure Set_Is_Remote_Types                 (Id : E; V : B := True);\n    procedure Set_Is_Renaming_Of_Object           (Id : E; V : B := True);\n    procedure Set_Is_Return_Object                (Id : E; V : B := True);\n+   procedure Set_Is_Safe_To_Reevaluate           (Id : E; V : B := True);\n    procedure Set_Is_Shared_Passive               (Id : E; V : B := True);\n    procedure Set_Is_Statically_Allocated         (Id : E; V : B := True);\n    procedure Set_Is_Tag                          (Id : E; V : B := True);\n@@ -7480,6 +7489,7 @@ package Einfo is\n    pragma Inline (Is_Remote_Types);\n    pragma Inline (Is_Renaming_Of_Object);\n    pragma Inline (Is_Return_Object);\n+   pragma Inline (Is_Safe_To_Reevaluate);\n    pragma Inline (Is_Scalar_Type);\n    pragma Inline (Is_Shared_Passive);\n    pragma Inline (Is_Signed_Integer_Type);\n@@ -7882,6 +7892,7 @@ package Einfo is\n    pragma Inline (Set_Is_Remote_Types);\n    pragma Inline (Set_Is_Renaming_Of_Object);\n    pragma Inline (Set_Is_Return_Object);\n+   pragma Inline (Set_Is_Safe_To_Reevaluate);\n    pragma Inline (Set_Is_Shared_Passive);\n    pragma Inline (Set_Is_Statically_Allocated);\n    pragma Inline (Set_Is_Tag);"}, {"sha": "fc2cf49158f8de9e5d12ab75b1b71be57c2f94ec", "filename": "gcc/ada/errout.ads", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/273adcdf9fbd8521e9f0d39e8a9f22d0c53b482d/gcc%2Fada%2Ferrout.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/273adcdf9fbd8521e9f0d39e8a9f22d0c53b482d/gcc%2Fada%2Ferrout.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ferrout.ads?ref=273adcdf9fbd8521e9f0d39e8a9f22d0c53b482d", "patch": "@@ -624,8 +624,7 @@ package Errout is\n    --       (parameters ....)\n \n    --  Any message marked with this -- CODEFIX comment should not be modified\n-   --  without appropriate coordination. If new messages are added which may\n-   --  be susceptible to automatic codefix action, they are marked using:\n+   --  without appropriate coordination.\n \n    ------------------------------\n    -- Error Output Subprograms --"}, {"sha": "0d2c12c147ad7b7c85154a387bc481f2705987f2", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/273adcdf9fbd8521e9f0d39e8a9f22d0c53b482d/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/273adcdf9fbd8521e9f0d39e8a9f22d0c53b482d/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=273adcdf9fbd8521e9f0d39e8a9f22d0c53b482d", "patch": "@@ -2936,12 +2936,15 @@ package body Exp_Ch6 is\n \n       --  Check for violation of No_Abort_Statements\n \n-      if Is_RTE (Subp, RE_Abort_Task) then\n+      if Restriction_Check_Required (No_Abort_Statements)\n+        and then Is_RTE (Subp, RE_Abort_Task)\n+      then\n          Check_Restriction (No_Abort_Statements, Call_Node);\n \n       --  Check for violation of No_Dynamic_Attachment\n \n-      elsif RTU_Loaded (Ada_Interrupts)\n+      elsif Restriction_Check_Required (No_Dynamic_Attachment)\n+        and then RTU_Loaded (Ada_Interrupts)\n         and then (Is_RTE (Subp, RE_Is_Reserved)      or else\n                   Is_RTE (Subp, RE_Is_Attached)      or else\n                   Is_RTE (Subp, RE_Current_Handler)  or else"}, {"sha": "80c806c7ae4304fef1f74cc0ab2555cf64779e52", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 232, "deletions": 227, "changes": 459, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/273adcdf9fbd8521e9f0d39e8a9f22d0c53b482d/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/273adcdf9fbd8521e9f0d39e8a9f22d0c53b482d/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=273adcdf9fbd8521e9f0d39e8a9f22d0c53b482d", "patch": "@@ -69,20 +69,20 @@ package body Exp_Util is\n       Id_Ref : Node_Id;\n       A_Type : Entity_Id;\n       Dyn    : Boolean := False) return Node_Id;\n-   --  Build function to generate the image string for a task that is an\n-   --  array component, concatenating the images of each index. To avoid\n-   --  storage leaks, the string is built with successive slice assignments.\n-   --  The flag Dyn indicates whether this is called for the initialization\n-   --  procedure of an array of tasks, or for the name of a dynamically\n-   --  created task that is assigned to an indexed component.\n+   --  Build function to generate the image string for a task that is an array\n+   --  component, concatenating the images of each index. To avoid storage\n+   --  leaks, the string is built with successive slice assignments. The flag\n+   --  Dyn indicates whether this is called for the initialization procedure of\n+   --  an array of tasks, or for the name of a dynamically created task that is\n+   --  assigned to an indexed component.\n \n    function Build_Task_Image_Function\n      (Loc   : Source_Ptr;\n       Decls : List_Id;\n       Stats : List_Id;\n       Res   : Entity_Id) return Node_Id;\n-   --  Common processing for Task_Array_Image and Task_Record_Image.\n-   --  Build function body that computes image.\n+   --  Common processing for Task_Array_Image and Task_Record_Image. Build\n+   --  function body that computes image.\n \n    procedure Build_Task_Image_Prefix\n       (Loc    : Source_Ptr;\n@@ -93,34 +93,34 @@ package body Exp_Util is\n        Sum    : Node_Id;\n        Decls  : List_Id;\n        Stats  : List_Id);\n-   --  Common processing for Task_Array_Image and Task_Record_Image.\n-   --  Create local variables and assign prefix of name to result string.\n+   --  Common processing for Task_Array_Image and Task_Record_Image. Create\n+   --  local variables and assign prefix of name to result string.\n \n    function Build_Task_Record_Image\n      (Loc    : Source_Ptr;\n       Id_Ref : Node_Id;\n       Dyn    : Boolean := False) return Node_Id;\n-   --  Build function to generate the image string for a task that is a\n-   --  record component. Concatenate name of variable with that of selector.\n-   --  The flag Dyn indicates whether this is called for the initialization\n-   --  procedure of record with task components, or for a dynamically\n-   --  created task that is assigned to a selected component.\n+   --  Build function to generate the image string for a task that is a record\n+   --  component. Concatenate name of variable with that of selector. The flag\n+   --  Dyn indicates whether this is called for the initialization procedure of\n+   --  record with task components, or for a dynamically created task that is\n+   --  assigned to a selected component.\n \n    function Make_CW_Equivalent_Type\n      (T : Entity_Id;\n       E : Node_Id) return Entity_Id;\n    --  T is a class-wide type entity, E is the initial expression node that\n-   --  constrains T in case such as: \" X: T := E\" or \"new T'(E)\"\n-   --  This function returns the entity of the Equivalent type and inserts\n-   --  on the fly the necessary declaration such as:\n+   --  constrains T in case such as: \" X: T := E\" or \"new T'(E)\". This function\n+   --  returns the entity of the Equivalent type and inserts on the fly the\n+   --  necessary declaration such as:\n    --\n    --    type anon is record\n    --       _parent : Root_Type (T); constrained with E discriminants (if any)\n    --       Extension : String (1 .. expr to match size of E);\n    --    end record;\n    --\n-   --  This record is compatible with any object of the class of T thanks\n-   --  to the first field and has the same size as E thanks to the second.\n+   --  This record is compatible with any object of the class of T thanks to\n+   --  the first field and has the same size as E thanks to the second.\n \n    function Make_Literal_Range\n      (Loc         : Source_Ptr;\n@@ -163,14 +163,14 @@ package body Exp_Util is\n          Ti  : Entity_Id;\n \n       begin\n-         --  For now, we simply ignore a call where the argument has no\n-         --  type (probably case of unanalyzed condition), or has a type\n-         --  that is not Boolean. This is because this is a pretty marginal\n-         --  piece of functionality, and violations of these rules are\n-         --  likely to be truly marginal (how much code uses Fortran Logical\n-         --  as the barrier to a protected entry?) and we do not want to\n-         --  blow up existing programs. We can change this to an assertion\n-         --  after 3.12a is released ???\n+         --  For now, we simply ignore a call where the argument has no type\n+         --  (probably case of unanalyzed condition), or has a type that is not\n+         --  Boolean. This is because this is a pretty marginal piece of\n+         --  functionality, and violations of these rules are likely to be\n+         --  truly marginal (how much code uses Fortran Logical as the barrier\n+         --  to a protected entry?) and we do not want to blow up existing\n+         --  programs. We can change this to an assertion after 3.12a is\n+         --  released ???\n \n          if No (T) or else not Is_Boolean_Type (T) then\n             return;\n@@ -194,8 +194,8 @@ package body Exp_Util is\n \n          --      ityp!(N) /= False'Enum_Rep\n \n-         --  where ityp is an integer type with large enough size to hold\n-         --  any value of type T.\n+         --  where ityp is an integer type with large enough size to hold any\n+         --  value of type T.\n \n          if Nonzero_Is_True (T) or else Has_Non_Standard_Rep (T) then\n             if Esize (T) <= Esize (Standard_Integer) then\n@@ -262,8 +262,8 @@ package body Exp_Util is\n             then\n                return;\n \n-            --  Otherwise we perform a conversion from the current type,\n-            --  which must be Standard.Boolean, to the desired type.\n+            --  Otherwise we perform a conversion from the current type, which\n+            --  must be Standard.Boolean, to the desired type.\n \n             else\n                Set_Analyzed (N);\n@@ -340,6 +340,7 @@ package body Exp_Util is\n    --  of the components. The constructed image has the form of an indexed\n    --  component, whose prefix is the outer variable of the array type.\n    --  The n-dimensional array type has known indexes Index, Index2...\n+\n    --  Id_Ref is an indexed component form created by the enclosing init proc.\n    --  Its successive indexes are Val1, Val2, ... which are the loop variables\n    --  in the loops that call the individual task init proc on each component.\n@@ -372,8 +373,8 @@ package body Exp_Util is\n    --     return Res;\n    --  end F;\n    --\n-   --  Needless to say, multidimensional arrays of tasks are rare enough\n-   --  that the bulkiness of this code is not really a concern.\n+   --  Needless to say, multidimensional arrays of tasks are rare enough that\n+   --  the bulkiness of this code is not really a concern.\n \n    function Build_Task_Array_Image\n      (Loc    : Source_Ptr;\n@@ -415,8 +416,8 @@ package body Exp_Util is\n       Stats : constant List_Id := New_List;\n \n    begin\n-      --  For a dynamic task, the name comes from the target variable.\n-      --  For a static one it is a formal of the enclosing init proc.\n+      --  For a dynamic task, the name comes from the target variable. For a\n+      --  static one it is a formal of the enclosing init proc.\n \n       if Dyn then\n          Get_Name_String (Chars (Entity (Prefix (Id_Ref))));\n@@ -624,9 +625,9 @@ package body Exp_Util is\n            or else Nkind (Id_Ref) = N_Defining_Identifier\n          then\n             --  For a simple variable, the image of the task is built from\n-            --  the name of the variable. To avoid possible conflict with\n-            --  the anonymous type created for a single protected object,\n-            --  add a numeric suffix.\n+            --  the name of the variable. To avoid possible conflict with the\n+            --  anonymous type created for a single protected object, add a\n+            --  numeric suffix.\n \n             T_Id :=\n               Make_Defining_Identifier (Loc,\n@@ -694,8 +695,8 @@ package body Exp_Util is\n         Defining_Unit_Name => Make_Temporary (Loc, 'F'),\n         Result_Definition  => New_Occurrence_Of (Standard_String, Loc));\n \n-      --  Calls to 'Image use the secondary stack, which must be cleaned\n-      --  up after the task name is built.\n+      --  Calls to 'Image use the secondary stack, which must be cleaned up\n+      --  after the task name is built.\n \n       return Make_Subprogram_Body (Loc,\n          Specification => Spec,\n@@ -1170,6 +1171,7 @@ package body Exp_Util is\n    --  This function is applicable for both static and dynamic allocation of\n    --  objects which are constrained by an initial expression. Basically it\n    --  transforms an unconstrained subtype indication into a constrained one.\n+\n    --  The expression may also be transformed in certain cases in order to\n    --  avoid multiple evaluation. In the static allocation case, the general\n    --  scheme is:\n@@ -1267,9 +1269,9 @@ package body Exp_Util is\n          if Is_Itype (Exp_Typ) then\n \n             --  Within an initialization procedure, a selected component\n-            --  denotes a component of the enclosing record, and it appears\n-            --  as an actual in a call to its own initialization procedure.\n-            --  If this component depends on the outer discriminant, we must\n+            --  denotes a component of the enclosing record, and it appears as\n+            --  an actual in a call to its own initialization procedure. If\n+            --  this component depends on the outer discriminant, we must\n             --  generate the proper actual subtype for it.\n \n             if Nkind (Exp) = N_Selected_Component\n@@ -1301,10 +1303,10 @@ package body Exp_Util is\n                 Defining_Identifier => T,\n                 Subtype_Indication  => New_Reference_To (Exp_Typ, Loc)));\n \n-            --  This type is marked as an itype even though it has an\n-            --  explicit declaration because otherwise it can be marked\n-            --  with Is_Generic_Actual_Type and generate spurious errors.\n-            --  (see sem_ch8.Analyze_Package_Renaming and sem_type.covers)\n+            --  This type is marked as an itype even though it has an explicit\n+            --  declaration since otherwise Is_Generic_Actual_Type can get\n+            --  set, resulting in the generation of spurious errors. (See\n+            --  sem_ch8.Analyze_Package_Renaming and sem_type.covers)\n \n             Set_Is_Itype (T);\n             Set_Associated_Node_For_Itype (T, Exp);\n@@ -2353,9 +2355,9 @@ package body Exp_Util is\n \n       --  If the action derives from stuff inside a record, then the actions\n       --  are attached to the current scope, to be inserted and analyzed on\n-      --  exit from the scope. The reason for this is that we may also\n-      --  be generating freeze actions at the same time, and they must\n-      --  eventually be elaborated in the correct order.\n+      --  exit from the scope. The reason for this is that we may also be\n+      --  generating freeze actions at the same time, and they must eventually\n+      --  be elaborated in the correct order.\n \n       if Is_Record_Type (Current_Scope)\n         and then not Is_Frozen (Current_Scope)\n@@ -2375,18 +2377,18 @@ package body Exp_Util is\n       end if;\n \n       --  We now intend to climb up the tree to find the right point to\n-      --  insert the actions. We start at Assoc_Node, unless this node is\n-      --  a subexpression in which case we start with its parent. We do this\n-      --  for two reasons. First it speeds things up. Second, if Assoc_Node\n-      --  is itself one of the special nodes like N_And_Then, then we assume\n-      --  that an initial request to insert actions for such a node does not\n-      --  expect the actions to get deposited in the node for later handling\n-      --  when the node is expanded, since clearly the node is being dealt\n-      --  with by the caller. Note that in the subexpression case, N is\n-      --  always the child we came from.\n-\n-      --  N_Raise_xxx_Error is an annoying special case, it is a statement\n-      --  if it has type Standard_Void_Type, and a subexpression otherwise.\n+      --  insert the actions. We start at Assoc_Node, unless this node is a\n+      --  subexpression in which case we start with its parent. We do this for\n+      --  two reasons. First it speeds things up. Second, if Assoc_Node is\n+      --  itself one of the special nodes like N_And_Then, then we assume that\n+      --  an initial request to insert actions for such a node does not expect\n+      --  the actions to get deposited in the node for later handling when the\n+      --  node is expanded, since clearly the node is being dealt with by the\n+      --  caller. Note that in the subexpression case, N is always the child we\n+      --  came from.\n+\n+      --  N_Raise_xxx_Error is an annoying special case, it is a statement if\n+      --  it has type Standard_Void_Type, and a subexpression otherwise.\n       --  otherwise. Procedure attribute references are also statements.\n \n       if Nkind (Assoc_Node) in N_Subexpr\n@@ -2400,8 +2402,8 @@ package body Exp_Util is\n          P := Assoc_Node;             -- ??? does not agree with above!\n          N := Parent (Assoc_Node);\n \n-      --  Non-subexpression case. Note that N is initially Empty in this\n-      --  case (N is only guaranteed Non-Empty in the subexpr case).\n+      --  Non-subexpression case. Note that N is initially Empty in this case\n+      --  (N is only guaranteed Non-Empty in the subexpr case).\n \n       else\n          P := Assoc_Node;\n@@ -2649,11 +2651,11 @@ package body Exp_Util is\n                elsif Nkind (Parent (P)) = N_Component_Association then\n                   null;\n \n-               --  Do not insert if the parent of P is either an N_Variant\n-               --  node or an N_Record_Definition node, meaning in either\n-               --  case that P is a member of a component list, and that\n-               --  therefore the actions should be inserted outside the\n-               --  complete record declaration.\n+               --  Do not insert if the parent of P is either an N_Variant node\n+               --  or an N_Record_Definition node, meaning in either case that\n+               --  P is a member of a component list, and that therefore the\n+               --  actions should be inserted outside the complete record\n+               --  declaration.\n \n                elsif Nkind (Parent (P)) = N_Variant\n                  or else Nkind (Parent (P)) = N_Record_Definition\n@@ -2666,8 +2668,8 @@ package body Exp_Util is\n                --  loop is part of the elaboration procedure and is only\n                --  elaborated during the second pass.\n \n-               --  If the loop comes from source, or the entity is local to\n-               --  the loop itself it must remain within.\n+               --  If the loop comes from source, or the entity is local to the\n+               --  loop itself it must remain within.\n \n                elsif Nkind (Parent (P)) = N_Loop_Statement\n                  and then not Comes_From_Source (Parent (P))\n@@ -3157,8 +3159,8 @@ package body Exp_Util is\n          return Is_Possibly_Unaligned_Object (Renamed_Object (Entity (N)));\n       end if;\n \n-      --  Tagged and controlled types and aliased types are always aligned,\n-      --  as are concurrent types.\n+      --  Tagged and controlled types and aliased types are always aligned, as\n+      --  are concurrent types.\n \n       if Is_Aliased (T)\n         or else Has_Controlled_Component (T)\n@@ -3186,9 +3188,9 @@ package body Exp_Util is\n \n          begin\n             --  If component reference is for an array with non-static bounds,\n-            --  then it is always aligned: we can only process unaligned\n-            --  arrays with static bounds (more accurately bounds known at\n-            --  compile time).\n+            --  then it is always aligned: we can only process unaligned arrays\n+            --  with static bounds (more accurately bounds known at compile\n+            --  time).\n \n             if Is_Array_Type (T)\n               and then not Compile_Time_Known_Bounds (T)\n@@ -3355,9 +3357,9 @@ package body Exp_Util is\n             if Nkind (Pref) = N_Indexed_Component then\n                Ptyp := Etype (Prefix (Pref));\n \n-               --  The only problematic case is when the array is packed,\n-               --  in which case we really know nothing about the alignment\n-               --  of individual components.\n+               --  The only problematic case is when the array is packed, in\n+               --  which case we really know nothing about the alignment of\n+               --  individual components.\n \n                if Is_Bit_Packed_Array (Ptyp) then\n                   return True;\n@@ -3370,8 +3372,8 @@ package body Exp_Util is\n \n                --  We are definitely in trouble if the record in question\n                --  has an alignment, and either we know this alignment is\n-               --  inconsistent with the alignment of the slice, or we\n-               --  don't know what the alignment of the slice should be.\n+               --  inconsistent with the alignment of the slice, or we don't\n+               --  know what the alignment of the slice should be.\n \n                if Known_Alignment (Ptyp)\n                  and then (Unknown_Alignment (Styp)\n@@ -3407,8 +3409,8 @@ package body Exp_Util is\n                   end if;\n                end;\n \n-            --  For cases other than selected or indexed components we\n-            --  know we are OK, since no issues arise over alignment.\n+            --  For cases other than selected or indexed components we know we\n+            --  are OK, since no issues arise over alignment.\n \n             else\n                return False;\n@@ -3624,8 +3626,8 @@ package body Exp_Util is\n             Kill_Dead_Code (Private_Declarations (Specification (N)));\n \n             --  ??? After this point, Delete_Tree has been called on all\n-            --  declarations in Specification (N), so references to\n-            --  entities therein look suspicious.\n+            --  declarations in Specification (N), so references to entities\n+            --  therein look suspicious.\n \n             declare\n                E : Entity_Id := First_Entity (Defining_Entity (N));\n@@ -3639,8 +3641,8 @@ package body Exp_Util is\n                end loop;\n             end;\n \n-         --  Recurse into composite statement to kill individual statements,\n-         --  in particular instantiations.\n+         --  Recurse into composite statement to kill individual statements in\n+         --  particular instantiations.\n \n          elsif Nkind (N) = N_If_Statement then\n             Kill_Dead_Code (Then_Statements (N));\n@@ -4003,8 +4005,8 @@ package body Exp_Util is\n                   Component_Items => Comp_List,\n                   Variant_Part    => Empty))));\n \n-      --  Suppress all checks during the analysis of the expanded code\n-      --  to avoid the generation of spurious warnings under ZFP run-time.\n+      --  Suppress all checks during the analysis of the expanded code to avoid\n+      --  the generation of spurious warnings under ZFP run-time.\n \n       Insert_Actions (E, List_Def, Suppress => All_Checks);\n       return Equiv_Type;\n@@ -4247,11 +4249,11 @@ package body Exp_Util is\n \n             if Expander_Active and then Tagged_Type_Expansion then\n \n-               --  If this is the class_wide type of a completion that is\n-               --  a record subtype, set the type of the class_wide type\n-               --  to be the full base type, for use in the expanded code\n-               --  for the equivalent type. Should this be done earlier when\n-               --  the completion is analyzed ???\n+               --  If this is the class_wide type of a completion that is a\n+               --  record subtype, set the type of the class_wide type to be\n+               --  the full base type, for use in the expanded code for the\n+               --  equivalent type. Should this be done earlier when the\n+               --  completion is analyzed ???\n \n                if Is_Private_Type (Etype (Unc_Typ))\n                  and then\n@@ -4296,10 +4298,10 @@ package body Exp_Util is\n    -- May_Generate_Large_Temp --\n    -----------------------------\n \n-   --  At the current time, the only types that we return False for (i.e.\n-   --  where we decide we know they cannot generate large temps) are ones\n-   --  where we know the size is 256 bits or less at compile time, and we\n-   --  are still not doing a thorough job on arrays and records ???\n+   --  At the current time, the only types that we return False for (i.e. where\n+   --  we decide we know they cannot generate large temps) are ones where we\n+   --  know the size is 256 bits or less at compile time, and we are still not\n+   --  doing a thorough job on arrays and records ???\n \n    function May_Generate_Large_Temp (Typ : Entity_Id) return Boolean is\n    begin\n@@ -4331,21 +4333,21 @@ package body Exp_Util is\n    is\n    begin\n \n-      --  If we have no initialization of any kind, then we don't need to\n-      --  place any restrictions on the address clause, because the object\n-      --  will be elaborated after the address clause is evaluated. This\n-      --  happens if the declaration has no initial expression, or the type\n-      --  has no implicit initialization, or the object is imported.\n+      --  If we have no initialization of any kind, then we don't need to place\n+      --  any restrictions on the address clause, because the object will be\n+      --  elaborated after the address clause is evaluated. This happens if the\n+      --  declaration has no initial expression, or the type has no implicit\n+      --  initialization, or the object is imported.\n \n-      --  The same holds for all initialized scalar types and all access\n-      --  types. Packed bit arrays of size up to 64 are represented using a\n-      --  modular type with an initialization (to zero) and can be processed\n-      --  like other initialized scalar types.\n+      --  The same holds for all initialized scalar types and all access types.\n+      --  Packed bit arrays of size up to 64 are represented using a modular\n+      --  type with an initialization (to zero) and can be processed like other\n+      --  initialized scalar types.\n \n       --  If the type is controlled, code to attach the object to a\n-      --  finalization chain is generated at the point of declaration,\n-      --  and therefore the elaboration of the object cannot be delayed:\n-      --  the address expression must be a constant.\n+      --  finalization chain is generated at the point of declaration, and\n+      --  therefore the elaboration of the object cannot be delayed: the\n+      --  address expression must be a constant.\n \n       if No (Expression (Decl))\n         and then not Needs_Finalization (Typ)\n@@ -4369,8 +4371,8 @@ package body Exp_Util is\n          --  the call to the initialization procedure (or the attach code) has\n          --  to happen at the point of the declaration.\n \n-         --  Actually the IP call has been moved to the freeze actions\n-         --  anyway, so maybe we can relax this restriction???\n+         --  Actually the IP call has been moved to the freeze actions anyway,\n+         --  so maybe we can relax this restriction???\n \n          return True;\n       end if;\n@@ -4653,6 +4655,7 @@ package body Exp_Util is\n          --  The following test is the simplest way of solving a complex\n          --  problem uncovered by BB08-010: Side effect on loop bound that\n          --  is a subcomponent of a global variable:\n+\n          --    If a loop bound is a subcomponent of a global variable, a\n          --    modification of that variable within the loop may incorrectly\n          --    affect the execution of the loop.\n@@ -4689,12 +4692,12 @@ package body Exp_Util is\n \n          if Is_Entity_Name (N) then\n \n-            --  If the entity is a constant, it is definitely side effect\n-            --  free. Note that the test of Is_Variable (N) below might\n-            --  be expected to catch this case, but it does not, because\n-            --  this test goes to the original tree, and we may have\n-            --  already rewritten a variable node with a constant as\n-            --  a result of an earlier Force_Evaluation call.\n+            --  If the entity is a constant, it is definitely side effect free.\n+            --  Note that the test of Is_Variable (N) below might be expected\n+            --  to catch this case, but it does not, because this test goes to\n+            --  the original tree, and we may have already rewritten a variable\n+            --  node with a constant as a result of an earlier Force_Evaluation\n+            --  call.\n \n             if Ekind_In (Entity (N), E_Constant, E_In_Parameter) then\n                return True;\n@@ -4709,7 +4712,12 @@ package body Exp_Util is\n             --  If Name_Req is True then we can't help returning a name which\n             --  effectively allows multiple references in any case.\n \n-            elsif Is_Variable (N) then\n+            --  Need comment for Is_True_Constant test below ???\n+\n+            elsif Is_Variable (N)\n+               or else (Ekind (Entity (N)) = E_Variable\n+                          and then not Is_True_Constant (Entity (N)))\n+            then\n                return not Variable_Ref\n                  and then (not Is_Volatile_Reference (N) or else Name_Req);\n \n@@ -4725,16 +4733,16 @@ package body Exp_Util is\n          elsif Compile_Time_Known_Value (N) then\n             return True;\n \n-         --  A variable renaming is not side-effect free, because the\n-         --  renaming will function like a macro in the front-end in\n-         --  some cases, and an assignment can modify the component\n-         --  designated by N, so we need to create a temporary for it.\n+         --  A variable renaming is not side-effect free, because the renaming\n+         --  will function like a macro in the front-end in some cases, and an\n+         --  assignment can modify the component designated by N, so we need to\n+         --  create a temporary for it.\n \n-         --  The guard testing for Entity being present is needed at least\n-         --  in the case of rewritten predicate expressions, and may be\n+         --  The guard testing for Entity being present is needed at least in\n+         --  the case of rewritten predicate expressions, and may well also be\n          --  appropriate elsewhere. Obviously we can't go testing the entity\n-         --  field if it does not exist, so it's reasonable to say that this\n-         --  is not the renaming case if it does not exist.\n+         --  field if it does not exist, so it's reasonable to say that this is\n+         --  not the renaming case if it does not exist.\n \n          elsif Is_Entity_Name (Original_Node (N))\n            and then Present (Entity (Original_Node (N)))\n@@ -4746,7 +4754,7 @@ package body Exp_Util is\n          --  Remove_Side_Effects generates an object renaming declaration to\n          --  capture the expression of a class-wide expression. In VM targets\n          --  the frontend performs no expansion for dispatching calls to\n-         --  class-wide types since they are handled by the VM. Hence, we must\n+         --  class- wide types since they are handled by the VM. Hence, we must\n          --  locate here if this node corresponds to a previous invocation of\n          --  Remove_Side_Effects to avoid a never ending loop in the frontend.\n \n@@ -4775,9 +4783,9 @@ package body Exp_Util is\n                  and then (Is_Entity_Name (Prefix (N))\n                             or else Side_Effect_Free (Prefix (N)));\n \n-            --  A binary operator is side effect free if and both operands\n-            --  are side effect free. For this purpose binary operators\n-            --  include membership tests and short circuit forms\n+            --  A binary operator is side effect free if and both operands are\n+            --  side effect free. For this purpose binary operators include\n+            --  membership tests and short circuit forms\n \n             when N_Binary_Op | N_Membership_Test | N_Short_Circuit =>\n                return Side_Effect_Free (Left_Opnd  (N))\n@@ -4792,10 +4800,10 @@ package body Exp_Util is\n \n             --  A call to _rep_to_pos is side effect free, since we generate\n             --  this pure function call ourselves. Moreover it is critically\n-            --  important to make this exception, since otherwise we can\n-            --  have discriminants in array components which don't look\n-            --  side effect free in the case of an array whose index type\n-            --  is an enumeration type with an enumeration rep clause.\n+            --  important to make this exception, since otherwise we can have\n+            --  discriminants in array components which don't look side effect\n+            --  free in the case of an array whose index type is an enumeration\n+            --  type with an enumeration rep clause.\n \n             --  All other function calls are not side effect free\n \n@@ -4819,15 +4827,15 @@ package body Exp_Util is\n             when N_Qualified_Expression =>\n                return Side_Effect_Free (Expression (N));\n \n-            --  A selected component is side effect free only if it is a\n-            --  side effect free prefixed reference. If it designates a\n-            --  component with a rep. clause it must be treated has having\n-            --  a potential side effect, because it may be modified through\n-            --  a renaming, and a subsequent use of the renaming as a macro\n-            --  will yield the wrong value. This complex interaction between\n-            --  renaming and removing side effects is a reminder that the\n-            --  latter has become a headache to maintain, and that it should\n-            --  be removed in favor of the gcc mechanism to capture values ???\n+            --  A selected component is side effect free only if it is a side\n+            --  effect free prefixed reference. If it designates a component\n+            --  with a rep. clause it must be treated has having a potential\n+            --  side effect, because it may be modified through a renaming, and\n+            --  a subsequent use of the renaming as a macro will yield the\n+            --  wrong value. This complex interaction between renaming and\n+            --  removing side effects is a reminder that the latter has become\n+            --  a headache to maintain, and that it should be removed in favor\n+            --  of the gcc mechanism to capture values ???\n \n             when N_Selected_Component =>\n                if Nkind (Parent (N)) = N_Explicit_Dereference\n@@ -4894,8 +4902,8 @@ package body Exp_Util is\n          end case;\n       end Side_Effect_Free;\n \n-      --  A list is side effect free if all elements of the list are\n-      --  side effect free.\n+      --  A list is side effect free if all elements of the list are side\n+      --  effect free.\n \n       function Side_Effect_Free (L : List_Id) return Boolean is\n          N : Node_Id;\n@@ -4985,10 +4993,10 @@ package body Exp_Util is\n          Set_Etype (Def_Id, Exp_Type);\n          Res := New_Reference_To (Def_Id, Loc);\n \n-         --  If the expression is a packed reference, it must be reanalyzed\n-         --  and expanded, depending on context. This is the case for actuals\n-         --  where a constraint check may capture the actual before expansion\n-         --  of the call is complete.\n+         --  If the expression is a packed reference, it must be reanalyzed and\n+         --  expanded, depending on context. This is the case for actuals where\n+         --  a constraint check may capture the actual before expansion of the\n+         --  call is complete.\n \n          if Nkind (Exp) = N_Indexed_Component\n            and then Is_Packed (Etype (Prefix (Exp)))\n@@ -5007,8 +5015,8 @@ package body Exp_Util is\n          Set_Assignment_OK (E);\n          Insert_Action (Exp, E);\n \n-      --  If the expression has the form v.all then we can just capture\n-      --  the pointer, and then do an explicit dereference on the result.\n+      --  If the expression has the form v.all then we can just capture the\n+      --  pointer, and then do an explicit dereference on the result.\n \n       elsif Nkind (Exp) = N_Explicit_Dereference then\n          Def_Id := Make_Temporary (Loc, 'R', Exp);\n@@ -5023,8 +5031,8 @@ package body Exp_Util is\n              Constant_Present    => True,\n              Expression          => Relocate_Node (Prefix (Exp))));\n \n-      --  Similar processing for an unchecked conversion of an expression\n-      --  of the form v.all, where we want the same kind of treatment.\n+      --  Similar processing for an unchecked conversion of an expression of\n+      --  the form v.all, where we want the same kind of treatment.\n \n       elsif Nkind (Exp) = N_Unchecked_Type_Conversion\n         and then Nkind (Expression (Exp)) = N_Explicit_Dereference\n@@ -5035,8 +5043,8 @@ package body Exp_Util is\n \n       --  If this is a type conversion, leave the type conversion and remove\n       --  the side effects in the expression. This is important in several\n-      --  circumstances: for change of representations, and also when this is\n-      --  a view conversion to a smaller object, where gigi can end up creating\n+      --  circumstances: for change of representations, and also when this is a\n+      --  view conversion to a smaller object, where gigi can end up creating\n       --  its own temporary of the wrong size.\n \n       elsif Nkind (Exp) = N_Type_Conversion then\n@@ -5081,13 +5089,12 @@ package body Exp_Util is\n          end if;\n \n       --  For expressions that denote objects, we can use a renaming scheme.\n-      --  This is needed for correctness in the case of a volatile object\n-      --  of a non-volatile type because the Make_Reference call of the\n-      --  \"default\" approach would generate an illegal access value (an access\n-      --  value cannot designate such an object - see Analyze_Reference).\n-      --  We skip using this scheme if we have an object of a volatile type\n-      --  and we do not have Name_Req set true (see comments above for\n-      --  Side_Effect_Free).\n+      --  This is needed for correctness in the case of a volatile object of a\n+      --  non-volatile type because the Make_Reference call of the \"default\"\n+      --  approach would generate an illegal access value (an access value\n+      --  cannot designate such an object - see Analyze_Reference). We skip\n+      --  using this scheme if we have an object of a volatile type and we do\n+      --  not have Name_Req set true (see comments above for Side_Effect_Free).\n \n       elsif Is_Object_Reference (Exp)\n         and then Nkind (Exp) /= N_Function_Call\n@@ -5126,9 +5133,9 @@ package body Exp_Util is\n                 Name                => Relocate_Node (Exp)));\n          end if;\n \n-         --  If this is a packed reference, or a selected component with a\n-         --  non-standard representation, a reference to the temporary will\n-         --  be replaced by a copy of the original expression (see\n+         --  If this is a packed reference, or a selected component with\n+         --  a non-standard representation, a reference to the temporary\n+         --  will be replaced by a copy of the original expression (see\n          --  Exp_Ch2.Expand_Renaming). Otherwise the temporary must be\n          --  elaborated by gigi, and is of course not to be replaced in-line\n          --  by the expression it renames, which would defeat the purpose of\n@@ -5209,10 +5216,10 @@ package body Exp_Util is\n \n             --  The expansion of nested aggregates is delayed until the\n             --  enclosing aggregate is expanded. As aggregates are often\n-            --  qualified, the predicate applies to qualified expressions\n-            --  as well, indicating that the enclosing aggregate has not\n-            --  been expanded yet. At this point the aggregate is part of\n-            --  a stand-alone declaration, and must be fully expanded.\n+            --  qualified, the predicate applies to qualified expressions as\n+            --  well, indicating that the enclosing aggregate has not been\n+            --  expanded yet. At this point the aggregate is part of a\n+            --  stand-alone declaration, and must be fully expanded.\n \n             if Nkind (E) = N_Qualified_Expression then\n                Set_Expansion_Delayed (Expression (E), False);\n@@ -5232,9 +5239,9 @@ package body Exp_Util is\n              Expression          => New_Exp));\n       end if;\n \n-      --  Preserve the Assignment_OK flag in all copies, since at least\n-      --  one copy may be used in a context where this flag must be set\n-      --  (otherwise why would the flag be set in the first place).\n+      --  Preserve the Assignment_OK flag in all copies, since at least one\n+      --  copy may be used in a context where this flag must be set (otherwise\n+      --  why would the flag be set in the first place).\n \n       Set_Assignment_OK (Res, Assignment_OK (Exp));\n \n@@ -5261,9 +5268,9 @@ package body Exp_Util is\n    -- Safe_Unchecked_Type_Conversion --\n    ------------------------------------\n \n-   --  Note: this function knows quite a bit about the exact requirements\n-   --  of Gigi with respect to unchecked type conversions, and its code\n-   --  must be coordinated with any changes in Gigi in this area.\n+   --  Note: this function knows quite a bit about the exact requirements of\n+   --  Gigi with respect to unchecked type conversions, and its code must be\n+   --  coordinated with any changes in Gigi in this area.\n \n    --  The above requirements should be documented in Sinfo ???\n \n@@ -5289,12 +5296,11 @@ package body Exp_Util is\n       then\n          return True;\n \n-      --  If the expression is the prefix of an N_Selected_Component\n-      --  we should also be OK because GCC knows to look inside the\n-      --  conversion except if the type is discriminated. We assume\n-      --  that we are OK anyway if the type is not set yet or if it is\n-      --  controlled since we can't afford to introduce a temporary in\n-      --  this case.\n+      --  If the expression is the prefix of an N_Selected_Component we should\n+      --  also be OK because GCC knows to look inside the conversion except if\n+      --  the type is discriminated. We assume that we are OK anyway if the\n+      --  type is not set yet or if it is controlled since we can't afford to\n+      --  introduce a temporary in this case.\n \n       elsif Nkind (Pexp) = N_Selected_Component\n          and then Prefix (Pexp) = Exp\n@@ -5308,9 +5314,9 @@ package body Exp_Util is\n          end if;\n       end if;\n \n-      --  Set the output type, this comes from Etype if it is set, otherwise\n-      --  we take it from the subtype mark, which we assume was already\n-      --  fully analyzed.\n+      --  Set the output type, this comes from Etype if it is set, otherwise we\n+      --  take it from the subtype mark, which we assume was already fully\n+      --  analyzed.\n \n       if Present (Etype (Exp)) then\n          Otyp := Etype (Exp);\n@@ -5328,10 +5334,10 @@ package body Exp_Util is\n       Oalign := No_Uint;\n       Ialign := No_Uint;\n \n-      --  Replace a concurrent type by its corresponding record type\n-      --  and each type by its underlying type and do the tests on those.\n-      --  The original type may be a private type whose completion is a\n-      --  concurrent type, so find the underlying type first.\n+      --  Replace a concurrent type by its corresponding record type and each\n+      --  type by its underlying type and do the tests on those. The original\n+      --  type may be a private type whose completion is a concurrent type, so\n+      --  find the underlying type first.\n \n       if Present (Underlying_Type (Otyp)) then\n          Otyp := Underlying_Type (Otyp);\n@@ -5365,22 +5371,22 @@ package body Exp_Util is\n       then\n          return True;\n \n-      --  If the expression has an access type (object or subprogram) we\n-      --  assume that the conversion is safe, because the size of the target\n-      --  is safe, even if it is a record (which might be treated as having\n-      --  unknown size at this point).\n+      --  If the expression has an access type (object or subprogram) we assume\n+      --  that the conversion is safe, because the size of the target is safe,\n+      --  even if it is a record (which might be treated as having unknown size\n+      --  at this point).\n \n       elsif Is_Access_Type (Ityp) then\n          return True;\n \n-      --  If the size of output type is known at compile time, there is\n-      --  never a problem.  Note that unconstrained records are considered\n-      --  to be of known size, but we can't consider them that way here,\n-      --  because we are talking about the actual size of the object.\n+      --  If the size of output type is known at compile time, there is never\n+      --  a problem. Note that unconstrained records are considered to be of\n+      --  known size, but we can't consider them that way here, because we are\n+      --  talking about the actual size of the object.\n \n-      --  We also make sure that in addition to the size being known, we do\n-      --  not have a case which might generate an embarrassingly large temp\n-      --  in stack checking mode.\n+      --  We also make sure that in addition to the size being known, we do not\n+      --  have a case which might generate an embarrassingly large temp in\n+      --  stack checking mode.\n \n       elsif Size_Known_At_Compile_Time (Otyp)\n         and then\n@@ -5396,8 +5402,8 @@ package body Exp_Util is\n       elsif Is_Tagged_Type (Otyp) or else Is_Tagged_Type (Ityp) then\n          return True;\n \n-      --  If either type is a limited record type, we cannot do a copy, so\n-      --  say safe since there's nothing else we can do.\n+      --  If either type is a limited record type, we cannot do a copy, so say\n+      --  safe since there's nothing else we can do.\n \n       elsif Is_Limited_Record (Otyp) or else Is_Limited_Record (Ityp) then\n          return True;\n@@ -5414,9 +5420,8 @@ package body Exp_Util is\n       --  The only other cases known to be safe is if the input type's\n       --  alignment is known to be at least the maximum alignment for the\n       --  target or if both alignments are known and the output type's\n-      --  alignment is no stricter than the input's.  We can use the alignment\n-      --  of the component type of an array if a type is an unpacked\n-      --  array type.\n+      --  alignment is no stricter than the input's. We can use the component\n+      --  type alignement for an array if a type is an unpacked array type.\n \n       if Present (Alignment_Clause (Otyp)) then\n          Oalign := Expr_Value (Expression (Alignment_Clause (Otyp)));\n@@ -5491,17 +5496,17 @@ package body Exp_Util is\n                   return;\n                end if;\n \n-               --  Here we have a case where the Current_Value field may\n-               --  need to be set. We set it if it is not already set to a\n-               --  compile time expression value.\n+               --  Here we have a case where the Current_Value field may need\n+               --  to be set. We set it if it is not already set to a compile\n+               --  time expression value.\n \n                --  Note that this represents a decision that one condition\n-               --  blots out another previous one. That's certainly right\n-               --  if they occur at the same level. If the second one is\n-               --  nested, then the decision is neither right nor wrong (it\n-               --  would be equally OK to leave the outer one in place, or\n-               --  take the new inner one. Really we should record both, but\n-               --  our data structures are not that elaborate.\n+               --  blots out another previous one. That's certainly right if\n+               --  they occur at the same level. If the second one is nested,\n+               --  then the decision is neither right nor wrong (it would be\n+               --  equally OK to leave the outer one in place, or take the new\n+               --  inner one. Really we should record both, but our data\n+               --  structures are not that elaborate.\n \n                if Nkind (Current_Value (Ent)) not in N_Subexpr then\n                   Set_Current_Value (Ent, Cnode);\n@@ -5642,9 +5647,9 @@ package body Exp_Util is\n    --  False op False = False, and True op True = True. For the XOR case,\n    --  see Silly_Boolean_Array_Xor_Test.\n \n-   --  Believe it or not, this was reported as a bug. Note that nearly\n-   --  always, the test will evaluate statically to False, so the code will\n-   --  be statically removed, and no extra overhead caused.\n+   --  Believe it or not, this was reported as a bug. Note that nearly always,\n+   --  the test will evaluate statically to False, so the code will be\n+   --  statically removed, and no extra overhead caused.\n \n    procedure Silly_Boolean_Array_Not_Test (N : Node_Id; T : Entity_Id) is\n       Loc : constant Source_Ptr := Sloc (N);\n@@ -5740,12 +5745,12 @@ package body Exp_Util is\n    --------------------------\n \n    Integer_Sized_Small : Ureal;\n-   --  Set to 2.0 ** -(Integer'Size - 1) the first time that this\n-   --  function is called (we don't want to compute it more than once!)\n+   --  Set to 2.0 ** -(Integer'Size - 1) the first time that this function is\n+   --  called (we don't want to compute it more than once!)\n \n    Long_Integer_Sized_Small : Ureal;\n-   --  Set to 2.0 ** -(Long_Integer'Size - 1) the first time that this\n-   --  function is called (we don't want to compute it more than once)\n+   --  Set to 2.0 ** -(Long_Integer'Size - 1) the first time that this function\n+   --  is called (we don't want to compute it more than once)\n \n    First_Time_For_THFO : Boolean := True;\n    --  Set to False after first call (if Fractional_Fixed_Ops_On_Target)\n@@ -5758,8 +5763,8 @@ package body Exp_Util is\n       function Is_Fractional_Type (Typ : Entity_Id) return Boolean;\n       --  Return True if the given type is a fixed-point type with a small\n       --  value equal to 2 ** (-(T'Object_Size - 1)) and whose values have\n-      --  an absolute value less than 1.0. This is currently limited\n-      --  to fixed-point types that map to Integer or Long_Integer.\n+      --  an absolute value less than 1.0. This is currently limited to\n+      --  fixed-point types that map to Integer or Long_Integer.\n \n       ------------------------\n       -- Is_Fractional_Type --\n@@ -5806,9 +5811,9 @@ package body Exp_Util is\n               Rbase => 2);\n       end if;\n \n-      --  Return True if target supports fixed-by-fixed multiply/divide\n-      --  for fractional fixed-point types (see Is_Fractional_Type) and\n-      --  the operand and result types are equivalent fractional types.\n+      --  Return True if target supports fixed-by-fixed multiply/divide for\n+      --  fractional fixed-point types (see Is_Fractional_Type) and the operand\n+      --  and result types are equivalent fractional types.\n \n       return Is_Fractional_Type (Base_Type (Left_Typ))\n         and then Is_Fractional_Type (Base_Type (Right_Typ))"}, {"sha": "35f27bafcdc6eb4805c64420085d6f124007fd8d", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/273adcdf9fbd8521e9f0d39e8a9f22d0c53b482d/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/273adcdf9fbd8521e9f0d39e8a9f22d0c53b482d/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=273adcdf9fbd8521e9f0d39e8a9f22d0c53b482d", "patch": "@@ -1646,9 +1646,10 @@ package body Sem_Attr is\n          --  Check special case of Exception_Id and Exception_Occurrence which\n          --  are not allowed for restriction No_Exception_Registration.\n \n-         if Is_RTE (P_Type, RE_Exception_Id)\n-              or else\n-            Is_RTE (P_Type, RE_Exception_Occurrence)\n+         if Restriction_Check_Required (No_Exception_Registration)\n+           and then (Is_RTE (P_Type, RE_Exception_Id)\n+                       or else\n+                     Is_RTE (P_Type, RE_Exception_Occurrence))\n          then\n             Check_Restriction (No_Exception_Registration, P);\n          end if;"}, {"sha": "627e993f4f8124f41d254133d8997b4b5e2d35ba", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/273adcdf9fbd8521e9f0d39e8a9f22d0c53b482d/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/273adcdf9fbd8521e9f0d39e8a9f22d0c53b482d/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=273adcdf9fbd8521e9f0d39e8a9f22d0c53b482d", "patch": "@@ -3671,8 +3671,9 @@ package body Sem_Ch3 is\n \n       --  Check for violation of No_Local_Timing_Events\n \n-      if Is_RTE (Etype (Id), RE_Timing_Event)\n+      if Restriction_Check_Required (No_Local_Timing_Events)\n         and then not Is_Library_Level_Entity (Id)\n+        and then Is_RTE (Etype (Id), RE_Timing_Event)\n       then\n          Check_Restriction (No_Local_Timing_Events, N);\n       end if;"}, {"sha": "c665c2d04c348b8c9e57e5c321ce7d6cfd1101fc", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/273adcdf9fbd8521e9f0d39e8a9f22d0c53b482d/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/273adcdf9fbd8521e9f0d39e8a9f22d0c53b482d/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=273adcdf9fbd8521e9f0d39e8a9f22d0c53b482d", "patch": "@@ -257,6 +257,13 @@ package body Sem_Ch5 is\n       Analyze (Rhs);\n       Analyze (Lhs);\n \n+      --  Ensure that we never do an assignment on a variable marked as\n+      --  as Safe_To_Reevaluate.\n+\n+      pragma Assert (not Is_Entity_Name (Lhs)\n+        or else Ekind (Entity (Lhs)) /= E_Variable\n+        or else not Is_Safe_To_Reevaluate (Entity (Lhs)));\n+\n       --  Start type analysis for assignment\n \n       T1 := Etype (Lhs);\n@@ -1603,7 +1610,7 @@ package body Sem_Ch5 is\n             Id := Make_Temporary (Loc, 'R', Original_Bound);\n \n             --  Here we make a declaration with a separate assignment\n-            --   statement, and insert before loop header.\n+            --  statement, and insert before loop header.\n \n             Decl :=\n               Make_Object_Declaration (Loc,\n@@ -1625,6 +1632,15 @@ package body Sem_Ch5 is\n \n             Insert_Actions (Parent (N), New_List (Decl, Assign));\n \n+            --  Now that this temporary variable is initialized we decorate it\n+            --  as safe-to-reevaluate to inform to the backend that no further\n+            --  asignment will be issued and hence it can be handled as side\n+            --  effect free. Note that this decoration must be done when the\n+            --  assignment has been analyzed because otherwise it will be\n+            --  rejected (see Analyze_Assignment).\n+\n+            Set_Is_Safe_To_Reevaluate (Id);\n+\n             Rewrite (Original_Bound, New_Occurrence_Of (Id, Loc));\n \n             if Nkind (Assign) = N_Assignment_Statement then"}, {"sha": "22234c807b54fff36d3f5fa8603f4626d310ba94", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/273adcdf9fbd8521e9f0d39e8a9f22d0c53b482d/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/273adcdf9fbd8521e9f0d39e8a9f22d0c53b482d/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=273adcdf9fbd8521e9f0d39e8a9f22d0c53b482d", "patch": "@@ -5702,9 +5702,10 @@ package body Sem_Res is\n       --  Check for violation of restriction No_Specific_Termination_Handlers\n       --  and warn on a potentially blocking call to Abort_Task.\n \n-      if Is_RTE (Nam, RE_Set_Specific_Handler)\n-           or else\n-         Is_RTE (Nam, RE_Specific_Handler)\n+      if Restriction_Check_Required (No_Specific_Termination_Handlers)\n+        and then (Is_RTE (Nam, RE_Set_Specific_Handler)\n+                    or else\n+                  Is_RTE (Nam, RE_Specific_Handler))\n       then\n          Check_Restriction (No_Specific_Termination_Handlers, N);\n \n@@ -5717,7 +5718,8 @@ package body Sem_Res is\n       --  need to check the second argument to determine whether it is an\n       --  absolute or relative timing event.\n \n-      if Is_RTE (Nam, RE_Set_Handler)\n+      if Restriction_Check_Required (No_Relative_Delay)\n+        and then Is_RTE (Nam, RE_Set_Handler)\n         and then Is_RTE (Etype (Next_Actual (First_Actual (N))), RE_Time_Span)\n       then\n          Check_Restriction (No_Relative_Delay, N);"}, {"sha": "727a0cdf452387782676adb0607f2e91a04882c6", "filename": "gcc/ada/style.adb", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/273adcdf9fbd8521e9f0d39e8a9f22d0c53b482d/gcc%2Fada%2Fstyle.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/273adcdf9fbd8521e9f0d39e8a9f22d0c53b482d/gcc%2Fada%2Fstyle.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fstyle.adb?ref=273adcdf9fbd8521e9f0d39e8a9f22d0c53b482d", "patch": "@@ -236,18 +236,14 @@ package body Style is\n \n    procedure Missing_Overriding (N : Node_Id; E : Entity_Id) is\n    begin\n-      --  Note that Error_Msg_NE, which would be more natural to use here,\n-      --  is not visible from this generic unit ???\n-\n-      Error_Msg_Name_1 := Chars (E);\n-\n       if Style_Check_Missing_Overriding and then Comes_From_Source (N) then\n          if Nkind (N) = N_Subprogram_Body then\n-            Error_Msg_N -- CODEFIX\n-              (\"(style) missing OVERRIDING indicator in body of%\", N);\n+            Error_Msg_NE -- CODEFIX\n+              (\"(style) missing OVERRIDING indicator in body of&\", N, E);\n          else\n-            Error_Msg_N -- CODEFIX\n-              (\"(style) missing OVERRIDING indicator in declaration of%\", N);\n+            Error_Msg_NE -- CODEFIX\n+              (\"(style) missing OVERRIDING indicator in declaration of&\",\n+               N, E);\n          end if;\n       end if;\n    end Missing_Overriding;"}, {"sha": "401373474ad737151be1a099051ab05bbf1de493", "filename": "gcc/ada/stylesw.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/273adcdf9fbd8521e9f0d39e8a9f22d0c53b482d/gcc%2Fada%2Fstylesw.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/273adcdf9fbd8521e9f0d39e8a9f22d0c53b482d/gcc%2Fada%2Fstylesw.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fstylesw.ads?ref=273adcdf9fbd8521e9f0d39e8a9f22d0c53b482d", "patch": "@@ -174,8 +174,8 @@ package Stylesw is\n \n    Style_Check_Missing_Overriding : Boolean := False;\n    --  This can be set True by using the -gnatyO switch. If it is True, then\n-   --  \"[not] overriding\" is required in subprogram declarations and bodies\n-   --  where appropriate.\n+   --  \"overriding\" is required in subprogram declarations and bodies where\n+   --  appropriate. Note that \"not overriding\" is never required.\n \n    Style_Check_Mode_In : Boolean := False;\n    --  This can be set True by using -gnatyI. If True, it activates checking"}]}