{"sha": "16e85390507ea92331c9052393b591202007f5ab", "node_id": "C_kwDOANBUbNoAKDE2ZTg1MzkwNTA3ZWE5MjMzMWM5MDUyMzkzYjU5MTIwMjAwN2Y1YWI", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2021-11-24T21:27:17Z"}, "committer": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2021-11-24T21:28:12Z"}, "message": "Fix handling of static chain in ipa_merge_modref_summary_after_inlining\n\ngcc/ChangeLog:\n\n2021-11-24  Jan Hubicka  <hubicka@ucw.cz>\n\n\t* ipa-modref.c (implicit_eaf_flags_for_edge_and_arg): Break out from...\n\t(modref_merge_call_site_flags): ... here.\n\t(ipa_merge_modref_summary_after_inlining): Use it.\n\ngcc/testsuite/ChangeLog:\n\n2021-11-24  Jan Hubicka  <hubicka@ucw.cz>\n\n\t* gcc.c-torture/execute/pr103405.c: New test.", "tree": {"sha": "f45d5516d2fd429adcc4c84a7d82fa1f904402b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f45d5516d2fd429adcc4c84a7d82fa1f904402b3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/16e85390507ea92331c9052393b591202007f5ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16e85390507ea92331c9052393b591202007f5ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16e85390507ea92331c9052393b591202007f5ab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16e85390507ea92331c9052393b591202007f5ab/comments", "author": null, "committer": null, "parents": [{"sha": "9e026da720091704ca0456d405f16a3bc5f3a799", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e026da720091704ca0456d405f16a3bc5f3a799", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e026da720091704ca0456d405f16a3bc5f3a799"}], "stats": {"total": 105, "additions": 88, "deletions": 17}, "files": [{"sha": "c2edc0d28a6f1afb40942871d068befe5c7e0762", "filename": "gcc/ipa-modref.c", "status": "modified", "additions": 51, "deletions": 17, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16e85390507ea92331c9052393b591202007f5ab/gcc%2Fipa-modref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16e85390507ea92331c9052393b591202007f5ab/gcc%2Fipa-modref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref.c?ref=16e85390507ea92331c9052393b591202007f5ab", "patch": "@@ -4827,6 +4827,30 @@ modref_propagate_dump_scc (cgraph_node *component_node)\n       }\n }\n \n+/* Determine EAF flags know for call E with CALLEE_ECF_FLAGS and ARG.  */\n+\n+int\n+implicit_eaf_flags_for_edge_and_arg (cgraph_edge *e, int callee_ecf_flags,\n+\t\t\t\t     bool ignore_stores, int arg)\n+{\n+  /* Returning the value is already accounted to at local propagation.  */\n+  int implicit_flags = EAF_NOT_RETURNED_DIRECTLY\n+\t\t       | EAF_NOT_RETURNED_INDIRECTLY;\n+  if (ignore_stores)\n+     implicit_flags |= ignore_stores_eaf_flags;\n+  if (callee_ecf_flags & ECF_PURE)\n+    implicit_flags |= implicit_pure_eaf_flags;\n+  if (callee_ecf_flags & (ECF_CONST | ECF_NOVOPS))\n+    implicit_flags |= implicit_const_eaf_flags;\n+  class fnspec_summary *fnspec_sum = fnspec_summaries->get (e);\n+  if (fnspec_sum)\n+    {\n+      attr_fnspec fnspec (fnspec_sum->fnspec);\n+      implicit_flags |= fnspec.arg_eaf_flags (arg);\n+    }\n+  return implicit_flags;\n+}\n+\n /* Process escapes in SUM and merge SUMMARY to CUR_SUMMARY\n    and SUMMARY_LTO to CUR_SUMMARY_LTO.\n    Return true if something changed.  */\n@@ -4857,9 +4881,8 @@ modref_merge_call_site_flags (escape_summary *sum,\n     {\n       int flags = 0;\n       int flags_lto = 0;\n-      /* Returning the value is already accounted to at local propagation.  */\n-      int implicit_flags = EAF_NOT_RETURNED_DIRECTLY\n-\t\t\t   | EAF_NOT_RETURNED_INDIRECTLY;\n+      int implicit_flags = implicit_eaf_flags_for_edge_and_arg\n+\t\t\t\t(e, callee_ecf_flags, ignore_stores, ee->arg);\n \n       if (summary && ee->arg < summary->arg_flags.length ())\n \tflags = summary->arg_flags[ee->arg];\n@@ -4995,6 +5018,7 @@ modref_propagate_flags_in_scc (cgraph_node *component_node)\n \t      if (ecf_flags & (ECF_CONST | ECF_NOVOPS)\n \t\t  || !callee_edge->inline_failed)\n \t\tcontinue;\n+\n \t      /* Get the callee and its summary.  */\n \t      enum availability avail;\n \t      callee = callee_edge->callee->function_or_virtual_thunk_symbol\n@@ -5081,6 +5105,9 @@ ipa_merge_modref_summary_after_inlining (cgraph_edge *edge)\n   class modref_summary_lto *callee_info_lto\n \t\t = summaries_lto ? summaries_lto->get (edge->callee) : NULL;\n   int flags = flags_from_decl_or_type (edge->callee->decl);\n+  /* Combine in outer flags.  */\n+  for (cgraph_node *n = edge->caller; n->inlined_to; n = n->callers->caller)\n+    flags |= flags_from_decl_or_type (edge->callee->decl);\n   bool ignore_stores = ignore_stores_p (edge->caller->decl, flags);\n \n   if (!callee_info && to_info)\n@@ -5148,22 +5175,26 @@ ipa_merge_modref_summary_after_inlining (cgraph_edge *edge)\n     FOR_EACH_VEC_ELT (sum->esc, i, ee)\n       {\n \tbool needed = false;\n-\t/* TODO: We do not have jump functions for return slots, so we\n-\t   never propagate them to outer function.  */\n-\tif (ee->parm_index < 0)\n-\t  continue;\n+\tint implicit_flags = implicit_eaf_flags_for_edge_and_arg\n+\t\t\t\t(edge, flags, ignore_stores,\n+\t\t\t\t ee->arg);\n+\tif (!ee->direct)\n+\t  implicit_flags = deref_flags (implicit_flags, ignore_stores);\n \tif (to_info && (int)to_info->arg_flags.length () > ee->parm_index)\n \t  {\n \t    int flags = callee_info\n \t\t\t&& callee_info->arg_flags.length () > ee->arg\n \t\t\t? callee_info->arg_flags[ee->arg] : 0;\n \t    if (!ee->direct)\n \t      flags = deref_flags (flags, ignore_stores);\n-\t    else if (ignore_stores)\n-\t      flags |= ignore_stores_eaf_flags;\n-\t    flags |= ee->min_flags;\n-\t    to_info->arg_flags[ee->parm_index] &= flags;\n-\t    if (to_info->arg_flags[ee->parm_index])\n+\t    flags |= ee->min_flags | implicit_flags;\n+\t    eaf_flags_t &f = ee->parm_index == MODREF_RETSLOT_PARM\n+\t\t\t     ? to_info->retslot_flags\n+\t\t\t     : ee->parm_index == MODREF_STATIC_CHAIN_PARM\n+\t\t\t     ? to_info->static_chain_flags\n+\t\t\t     : to_info->arg_flags[ee->parm_index];\n+\t    f &= flags;\n+\t    if (f)\n \t      needed = true;\n \t  }\n \tif (to_info_lto\n@@ -5174,11 +5205,14 @@ ipa_merge_modref_summary_after_inlining (cgraph_edge *edge)\n \t\t\t? callee_info_lto->arg_flags[ee->arg] : 0;\n \t    if (!ee->direct)\n \t      flags = deref_flags (flags, ignore_stores);\n-\t    else if (ignore_stores)\n-\t      flags |= ignore_stores_eaf_flags;\n-\t    flags |= ee->min_flags;\n-\t    to_info_lto->arg_flags[ee->parm_index] &= flags;\n-\t    if (to_info_lto->arg_flags[ee->parm_index])\n+\t    flags |= ee->min_flags | implicit_flags;\n+\t    eaf_flags_t &f = ee->parm_index == MODREF_RETSLOT_PARM\n+\t\t\t     ? to_info_lto->retslot_flags\n+\t\t\t     : ee->parm_index == MODREF_STATIC_CHAIN_PARM\n+\t\t\t     ? to_info_lto->static_chain_flags\n+\t\t\t     : to_info_lto->arg_flags[ee->parm_index];\n+\t    f &= flags;\n+\t    if (f)\n \t      needed = true;\n \t  }\n \tstruct escape_map entry = {ee->parm_index, ee->direct};"}, {"sha": "f6005dc2983dd13b664bdcb3328a61cd5e6a2c47", "filename": "gcc/testsuite/gcc.c-torture/execute/pr103405.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16e85390507ea92331c9052393b591202007f5ab/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr103405.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16e85390507ea92331c9052393b591202007f5ab/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr103405.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr103405.c?ref=16e85390507ea92331c9052393b591202007f5ab", "patch": "@@ -0,0 +1,37 @@\n+typedef __SIZE_TYPE__ size_t;\n+void *malloc(size_t);\n+\n+static inline int *starter(int a)\n+{\n+    int *b = malloc(sizeof(int));\n+    *b = a;\n+    return b;\n+}\n+\n+static inline _Bool equal(int *l, int *r)\n+{\n+    if (l == 0)\n+      __builtin_abort();\n+    if (r == 0)\n+      __builtin_abort();\n+    return *r == *l;\n+}\n+\n+int main(void)\n+{\n+  int *i;\n+  int *j;\n+  void check(_Bool a)\n+  {\n+    _Bool t = equal(i, j);\n+    if (a && t) __builtin_abort ();\n+    _Bool t1 = equal(i, j);\n+    if (!a && !t1) __builtin_abort ();\n+  }\n+  i = starter(1);\n+  j = starter(0);\n+  check(1);\n+  i = starter(0);\n+  check(0);\n+\n+}"}]}