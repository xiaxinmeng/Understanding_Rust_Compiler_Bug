{"sha": "29a72a4f09d8606f1414e5380c5eeb2ad5fc6737", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjlhNzJhNGYwOWQ4NjA2ZjE0MTRlNTM4MGM1ZWViMmFkNWZjNjczNw==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2000-03-28T21:45:02Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2000-03-28T21:45:02Z"}, "message": "cppfiles.c (hash_IHASH): Just return i->hash.\n\n2000-03-28  Zack Weinberg  <zack@wolery.cumb.org>\n\n\t* cppfiles.c (hash_IHASH): Just return i->hash.\n\t(cpp_included): Set dummy.hash using _cpp_calc_hash.  Use\n\thtab_find_with_hash.\n\t(cpp_read_file): Likewise.\n\t(find_include_file): Likewise.  Properly initialize\n\tih->nshort.  Share ih->name and ih->nshort if possible.\n\t* cpphash.c (_cpp_calc_hash): New function.\n\t(hash_HASHNODE): Just return h->hash.\n\t(_cpp_lookup): Set dummy.hash using _cpp_calc_hash.  Use\n\thtab_find_with_hash.\n\t* cpphash.h: Prototype _cpp_calc_hash.\n\t* cppinit.c (initialize_builtins): Provide a valid hash\n\tto _cpp_make_hashnode, using _cpp_calc_hash.\n\n\t* cpphash.c (collect_expansion): # is not a special character\n\tin object-like macros.  In -traditional mode, /**/ is not\n\ttoken paste at the beginning or end of the line.\n\t* cpplib.c (do_include, do_import, do_include_next): If\n\tparse_include fails, return immediately.\n\nFrom-SVN: r32792", "tree": {"sha": "ed8035556cbbe82211a22a58d3beaeef00e865d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ed8035556cbbe82211a22a58d3beaeef00e865d0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/29a72a4f09d8606f1414e5380c5eeb2ad5fc6737", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29a72a4f09d8606f1414e5380c5eeb2ad5fc6737", "html_url": "https://github.com/Rust-GCC/gccrs/commit/29a72a4f09d8606f1414e5380c5eeb2ad5fc6737", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29a72a4f09d8606f1414e5380c5eeb2ad5fc6737/comments", "author": null, "committer": null, "parents": [{"sha": "1e9d75e87b82126fc5249149e5e85f2f1f308eea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e9d75e87b82126fc5249149e5e85f2f1f308eea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e9d75e87b82126fc5249149e5e85f2f1f308eea"}], "stats": {"total": 142, "additions": 95, "deletions": 47}, "files": [{"sha": "2f07047620be06ec1d51f360cde8e9515e36f0ef", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29a72a4f09d8606f1414e5380c5eeb2ad5fc6737/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29a72a4f09d8606f1414e5380c5eeb2ad5fc6737/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=29a72a4f09d8606f1414e5380c5eeb2ad5fc6737", "patch": "@@ -1,3 +1,25 @@\n+2000-03-28  Zack Weinberg  <zack@wolery.cumb.org>\n+\n+\t* cppfiles.c (hash_IHASH): Just return i->hash.\n+\t(cpp_included): Set dummy.hash using _cpp_calc_hash.  Use\n+\thtab_find_with_hash.\n+\t(cpp_read_file): Likewise.\n+\t(find_include_file): Likewise.  Properly initialize\n+\tih->nshort.  Share ih->name and ih->nshort if possible.\n+\t* cpphash.c (_cpp_calc_hash): New function.\n+\t(hash_HASHNODE): Just return h->hash.\n+\t(_cpp_lookup): Set dummy.hash using _cpp_calc_hash.  Use\n+\thtab_find_with_hash.\n+\t* cpphash.h: Prototype _cpp_calc_hash.\n+\t* cppinit.c (initialize_builtins): Provide a valid hash\n+\tto _cpp_make_hashnode, using _cpp_calc_hash.\n+\n+\t* cpphash.c (collect_expansion): # is not a special character\n+\tin object-like macros.  In -traditional mode, /**/ is not\n+\ttoken paste at the beginning or end of the line.\n+\t* cpplib.c (do_include, do_import, do_include_next): If\n+\tparse_include fails, return immediately.\n+\n 2000-03-28  Jason Merrill  <jason@casey.cygnus.com>\n \n \t* config/arm/arm.md (return peepholes): Update to reflect the new\n@@ -36,11 +58,11 @@ Tue Mar 28 08:29:46 2000  Jan Hubicka  <jh@suse.cz>\n \n 2000-03-28  Neil Booth  <NeilB@earthling.net>\n \n-        * (cpplex.c) _cpp_read_and_prescan.  Mark end of input buffer with\n+        * cpplex.c (_cpp_read_and_prescan): Mark end of input buffer with\n \t'\\\\' rather than a null character, so nulls are not special.  Fix\n \t\"\\\\\\n\" handling in end-of-buffer conditions.  Use trigraph map to\n \tspeed trigraph conversion.\n-        (_cpp_init_input_buffer) Initialize trigraph map.\n+        (_cpp_init_input_buffer): Initialize trigraph map.\n \n 2000-03-27  Alan Modra  <alan@linuxcare.com.au>\n "}, {"sha": "f46052e8b2940a095966cc9426ed8f756255d1d6", "filename": "gcc/cppfiles.c", "status": "modified", "additions": 27, "deletions": 24, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29a72a4f09d8606f1414e5380c5eeb2ad5fc6737/gcc%2Fcppfiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29a72a4f09d8606f1414e5380c5eeb2ad5fc6737/gcc%2Fcppfiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppfiles.c?ref=29a72a4f09d8606f1414e5380c5eeb2ad5fc6737", "patch": "@@ -66,18 +66,8 @@ static unsigned int\n hash_IHASH (x)\n      const void *x;\n {\n-  IHASH *i = (IHASH *)x;\n-  unsigned int r = 0, len = 0;\n-  const U_CHAR *s = i->nshort;\n-\n-  if (i->hash != (unsigned long)-1)\n-    return i->hash;\n-\n-  do\n-    len++, r = r * 67 + (*s++ - 113);\n-  while (*s && *s != '.');\n-  i->hash = r + len;\n-  return r + len;\n+  const IHASH *i = (const IHASH *)x;\n+  return i->hash;\n }\n \n /* Compare an existing IHASH structure with a potential one.  */\n@@ -158,8 +148,9 @@ cpp_included (pfile, fname)\n {\n   IHASH dummy, *ptr;\n   dummy.nshort = fname;\n-  dummy.hash = -1;\n-  ptr = htab_find (pfile->all_include_files, (const void *)&dummy);\n+  dummy.hash = _cpp_calc_hash (fname, strlen (fname));\n+  ptr = htab_find_with_hash (pfile->all_include_files,\n+\t\t\t     (const void *)&dummy, dummy.hash);\n   return (ptr != NULL);\n }\n \n@@ -219,11 +210,12 @@ find_include_file (pfile, fname, search_start, ihash, before)\n   int f;\n   char *name;\n \n-  dummy.hash = -1;\n   dummy.nshort = fname;\n+  dummy.hash = _cpp_calc_hash (fname, strlen (fname));\n   path = (fname[0] == '/') ? ABSOLUTE_PATH : search_start;\n-  slot = (IHASH **) htab_find_slot (pfile->all_include_files,\n-\t\t\t\t    (const void *)&dummy, 1);\n+  slot = (IHASH **) htab_find_slot_with_hash (pfile->all_include_files,\n+\t\t\t\t\t      (const void *)&dummy,\n+\t\t\t\t\t      dummy.hash, 1);\n \n   if (*slot && (ih = redundant_include_p (pfile, *slot, path)))\n     {\n@@ -280,10 +272,20 @@ find_include_file (pfile, fname, search_start, ihash, before)\n     }\n   else\n     {\n-      ih = (IHASH *) xmalloc (sizeof (IHASH) + strlen (name)\n-\t\t\t      + strlen (fname) + 1);\n-      ih->nshort = ih->name + strlen (fname) + 1;\n-      strcpy ((char *)ih->nshort, fname);\n+      char *s;\n+      \n+      if ((s = strstr (name, fname)) != NULL)\n+\t{\n+\t  ih = (IHASH *) xmalloc (sizeof (IHASH) + strlen (name));\n+\t  ih->nshort = ih->name + (s - name);\n+\t}\n+      else\n+\t{\n+\t  ih = (IHASH *) xmalloc (sizeof (IHASH) + strlen (name)\n+\t\t\t\t  + strlen (fname) + 1);\n+\t  ih->nshort = ih->name + strlen (name) + 1;\n+\t  strcpy ((char *)ih->nshort, fname);\n+\t}\n     }\n   strcpy ((char *)ih->name, name);\n   ih->foundhere = path;\n@@ -620,10 +622,11 @@ cpp_read_file (pfile, fname)\n   if (fname == NULL)\n     fname = \"\";\n \n-  dummy.hash = -1;\n   dummy.nshort = fname;\n-  slot = (IHASH **) htab_find_slot (pfile->all_include_files,\n-\t\t\t\t    (const void *) &dummy, 1);\n+  dummy.hash = _cpp_calc_hash (fname, strlen (fname));\n+  slot = (IHASH **) htab_find_slot_with_hash (pfile->all_include_files,\n+\t\t\t\t\t      (const void *) &dummy,\n+\t\t\t\t\t      dummy.hash, 1);\n   if (*slot && (ih = redundant_include_p (pfile, *slot, ABSOLUTE_PATH)))\n     {\n       if (ih == (IHASH *)-1)"}, {"sha": "f0f131989925c6bfceba64090b1dda11d1a31938", "filename": "gcc/cpphash.c", "status": "modified", "additions": 35, "deletions": 19, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29a72a4f09d8606f1414e5380c5eeb2ad5fc6737/gcc%2Fcpphash.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29a72a4f09d8606f1414e5380c5eeb2ad5fc6737/gcc%2Fcpphash.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.c?ref=29a72a4f09d8606f1414e5380c5eeb2ad5fc6737", "patch": "@@ -99,26 +99,30 @@ struct argdata\n   int stringified_length;\n };\n \n-/* Calculate hash of a HASHNODE structure.  */\n-static unsigned int\n-hash_HASHNODE (x)\n-     const void *x;\n+/* Calculate hash of a string of length LEN.  */\n+unsigned int\n+_cpp_calc_hash (str, len)\n+     const U_CHAR *str;\n+     size_t len;\n {\n-  HASHNODE *h = (HASHNODE *)x;\n-  const U_CHAR *s = h->name;\n-  unsigned int len = h->length;\n-  unsigned int n = len, r = 0;\n+  size_t n = len;\n+  unsigned int r = 0;\n \n-  if (h->hash != (unsigned long)-1)\n-    return h->hash;\n-  \n   do\n-    r = r * 67 + (*s++ - 113);\n+    r = r * 67 + (*str++ - 113);\n   while (--n);\n-  h->hash = r + len;\n   return r + len;\n }\n \n+/* Calculate hash of a HASHNODE structure.  */\n+static unsigned int\n+hash_HASHNODE (x)\n+     const void *x;\n+{\n+  const HASHNODE *h = (const HASHNODE *)x;\n+  return h->hash;\n+}\n+\n /* Compare two HASHNODE structures.  */\n static int\n eq_HASHNODE (x, y)\n@@ -192,9 +196,10 @@ _cpp_lookup (pfile, name, len)\n \n   dummy.name = name;\n   dummy.length = len;\n-  dummy.hash = -1;\n+  dummy.hash = _cpp_calc_hash (name, len);\n \n-  return (HASHNODE *) htab_find (pfile->hashtab, (void *)&dummy);\n+  return (HASHNODE *) htab_find_with_hash (pfile->hashtab,\n+\t\t\t\t\t   (void *)&dummy, dummy.hash);\n }\n \n /* Find the hashtable slot for name \"name\".  Used to insert or delete.  */\n@@ -218,9 +223,11 @@ _cpp_lookup_slot (pfile, name, len, insert, hash)\n \n   dummy.name = name;\n   dummy.length = len;\n-  dummy.hash = -1;\n+  dummy.hash = _cpp_calc_hash (name, len);\n \n-  slot = (HASHNODE **) htab_find_slot (pfile->hashtab, (void *)&dummy, insert);\n+  slot = (HASHNODE **) htab_find_slot_with_hash (pfile->hashtab,\n+\t\t\t\t\t\t (void *)&dummy,\n+\t\t\t\t\t\t dummy.hash, insert);\n   if (insert)\n     *hash = dummy.hash;\n   return slot;\n@@ -336,8 +343,13 @@ collect_expansion (pfile, arglist)\n \t  break;\n \n \tcase CPP_STRINGIZE:\n+\t  /* # is not special in object-like macros.  It is special in\n+\t     function-like macros with no args.  (6.10.3.2 para 1.) */\n+\t  if (arglist == NULL)\n+\t    goto norm;\n+\t  /* # is not special immediately after PASTE.\n+\t     (Implied by 6.10.3.3 para 4.)  */\n \t  if (last_token == PASTE)\n-\t    /* Not really a stringifier.  */\n \t    goto norm;\n \t  last_token = STRIZE;\n \t  CPP_SET_WRITTEN (pfile, here);  /* delete from replacement text */\n@@ -374,12 +386,16 @@ collect_expansion (pfile, arglist)\n \tcase CPP_COMMENT:\n \t  /* We must be in -traditional mode.  Pretend this was a\n \t     token paste, but only if there was no leading or\n-\t     trailing space.  */\n+\t     trailing space and it's in the middle of the line.  */\n \t  CPP_SET_WRITTEN (pfile, here);\n+\t  if (last_token == START)\n+\t    break;\n \t  if (is_hspace (pfile->token_buffer[here-1]))\n \t    break;\n \t  if (is_hspace (PEEKC ()))\n \t    break;\n+\t  if (PEEKC () == '\\n')\n+\t    break;\n \t  if (last_token == ARG)\n \t    endpat->raw_after = 1;\n \t  last_token = PASTE;"}, {"sha": "2cfbad7acf3d37eabcf8c3a631e7256580193b0e", "filename": "gcc/cpphash.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29a72a4f09d8606f1414e5380c5eeb2ad5fc6737/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29a72a4f09d8606f1414e5380c5eeb2ad5fc6737/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=29a72a4f09d8606f1414e5380c5eeb2ad5fc6737", "patch": "@@ -255,6 +255,7 @@ enum file_change_code {same_file, rename_file, enter_file, leave_file};\n extern HASHNODE *_cpp_make_hashnode\tPARAMS ((const U_CHAR *, size_t,\n \t\t\t\t\t\t enum node_type,\n \t\t\t\t\t\t unsigned long));\n+extern unsigned int _cpp_calc_hash\tPARAMS ((const U_CHAR *, size_t));\n extern HASHNODE *_cpp_lookup\t\tPARAMS ((cpp_reader *,\n \t\t\t\t\t\t const U_CHAR *, int));\n extern HASHNODE **_cpp_lookup_slot\tPARAMS ((cpp_reader *,"}, {"sha": "1410d7370f0b32d83239f2f495dccf86862db530", "filename": "gcc/cppinit.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29a72a4f09d8606f1414e5380c5eeb2ad5fc6737/gcc%2Fcppinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29a72a4f09d8606f1414e5380c5eeb2ad5fc6737/gcc%2Fcppinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppinit.c?ref=29a72a4f09d8606f1414e5380c5eeb2ad5fc6737", "patch": "@@ -660,7 +660,8 @@ initialize_builtins (pfile)\n \tval = b->value;\n \n       len = strlen (b->name);\n-      hp = _cpp_make_hashnode (b->name, len, b->type, -1);\n+      hp = _cpp_make_hashnode (b->name, len, b->type,\n+\t\t\t       _cpp_calc_hash (b->name, len));\n       hp->value.cpval = val;\n       *(htab_find_slot (pfile->hashtab, (void *)hp, 1)) = hp;\n "}, {"sha": "88433f829c92c3bae902f9e85cc24377bdcb7162", "filename": "gcc/cpplib.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29a72a4f09d8606f1414e5380c5eeb2ad5fc6737/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29a72a4f09d8606f1414e5380c5eeb2ad5fc6737/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=29a72a4f09d8606f1414e5380c5eeb2ad5fc6737", "patch": "@@ -508,6 +508,8 @@ do_include (pfile)\n   char *token;\n \n   len = parse_include (pfile, dtable[T_INCLUDE].name);\n+  if (len == 0)\n+    return 0;\n   token = alloca (len + 1);\n   strcpy (token, CPP_PWRITTEN (pfile));\n   \n@@ -537,6 +539,8 @@ do_import (pfile)\n     }\n \n   len = parse_include (pfile, dtable[T_IMPORT].name);\n+  if (len == 0)\n+    return 0;\n   token = alloca (len + 1);\n   strcpy (token, CPP_PWRITTEN (pfile));\n   \n@@ -559,7 +563,8 @@ do_include_next (pfile)\n     cpp_pedwarn (pfile, \"ANSI C does not allow `#include_next'\");\n   \n   len = parse_include (pfile, dtable[T_INCLUDE_NEXT].name);\n-\n+  if (len == 0)\n+    return 0;\n   token = alloca (len + 1);\n   strcpy (token, CPP_PWRITTEN (pfile));\n   "}]}