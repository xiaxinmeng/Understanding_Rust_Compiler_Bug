{"sha": "7959d59810ec21b730305b2331ee131f87cfe889", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Nzk1OWQ1OTgxMGVjMjFiNzMwMzA1YjIzMzFlZTEzMWY4N2NmZTg4OQ==", "commit": {"author": {"name": "Michael Koch", "email": "konqueror@gmx.de", "date": "2004-02-05T18:20:46Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2004-02-05T18:20:46Z"}, "message": "2004-02-05  Michael Koch  <konqueror@gmx.de>\n\n\t* java/lang/Thread.java\n\t(Thread): Reordered.\n\t(setContextClassLoader): Fixed javadoc comment.\n\t(setPriority): Reordered.\n\t(yield): Reordered.\n\t(initialize_native): Reordered.\n\t(gen_name): Reordered.\n\nFrom-SVN: r77327", "tree": {"sha": "8315685cdee9554121417df461261a365220ea7f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8315685cdee9554121417df461261a365220ea7f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7959d59810ec21b730305b2331ee131f87cfe889", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7959d59810ec21b730305b2331ee131f87cfe889", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7959d59810ec21b730305b2331ee131f87cfe889", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7959d59810ec21b730305b2331ee131f87cfe889/comments", "author": null, "committer": null, "parents": [{"sha": "20a20bf0610a75c574bba3130cfb8d9a50e2c4df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20a20bf0610a75c574bba3130cfb8d9a50e2c4df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/20a20bf0610a75c574bba3130cfb8d9a50e2c4df"}], "stats": {"total": 534, "additions": 270, "deletions": 264}, "files": [{"sha": "b16b603b7fd352fb517f7960b312c26acdaf4634", "filename": "libjava/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7959d59810ec21b730305b2331ee131f87cfe889/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7959d59810ec21b730305b2331ee131f87cfe889/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=7959d59810ec21b730305b2331ee131f87cfe889", "patch": "@@ -1,3 +1,13 @@\n+2004-02-05  Michael Koch  <konqueror@gmx.de>\n+\n+\t* java/lang/Thread.java\n+\t(Thread): Reordered.\n+\t(setContextClassLoader): Fixed javadoc comment.\n+\t(setPriority): Reordered.\n+\t(yield): Reordered.\n+\t(initialize_native): Reordered.\n+\t(gen_name): Reordered.\n+\n 2004-02-05  Michael Koch  <konqueror@gmx.de>\n \n \t* java/lang/Thread.java: Reordered fields, reformated much code,"}, {"sha": "30c35aa8f3c26a753b42659cf0e860a437bea2fe", "filename": "libjava/java/lang/Thread.java", "status": "modified", "additions": 260, "deletions": 264, "changes": 524, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7959d59810ec21b730305b2331ee131f87cfe889/libjava%2Fjava%2Flang%2FThread.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7959d59810ec21b730305b2331ee131f87cfe889/libjava%2Fjava%2Flang%2FThread.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FThread.java?ref=7959d59810ec21b730305b2331ee131f87cfe889", "patch": "@@ -125,6 +125,243 @@ public class Thread implements Runnable\n   // Our native data - points to an instance of struct natThread.\n   private Object data;\n \n+  /**\n+   * Allocates a new <code>Thread</code> object. This constructor has\n+   * the same effect as <code>Thread(null, null,</code>\n+   * <i>gname</i><code>)</code>, where <b><i>gname</i></b> is\n+   * a newly generated name. Automatically generated names are of the\n+   * form <code>\"Thread-\"+</code><i>n</i>, where <i>n</i> is an integer.\n+   * <p>\n+   * Threads created this way must have overridden their\n+   * <code>run()</code> method to actually do anything.  An example\n+   * illustrating this method being used follows:\n+   * <p><blockquote><pre>\n+   *     import java.lang.*;\n+   *\n+   *     class plain01 implements Runnable {\n+   *         String name;\n+   *         plain01() {\n+   *             name = null;\n+   *         }\n+   *         plain01(String s) {\n+   *             name = s;\n+   *         }\n+   *         public void run() {\n+   *             if (name == null)\n+   *                 System.out.println(\"A new thread created\");\n+   *             else\n+   *                 System.out.println(\"A new thread with name \" + name +\n+   *                                    \" created\");\n+   *         }\n+   *     }\n+   *     class threadtest01 {\n+   *         public static void main(String args[] ) {\n+   *             int failed = 0 ;\n+   *\n+   *             <b>Thread t1 = new Thread();</b>\n+   *             if (t1 != null)\n+   *                 System.out.println(\"new Thread() succeed\");\n+   *             else {\n+   *                 System.out.println(\"new Thread() failed\");\n+   *                 failed++;\n+   *             }\n+   *         }\n+   *     }\n+   * </pre></blockquote>\n+   *\n+   * @see     java.lang.Thread#Thread(java.lang.ThreadGroup,\n+   *          java.lang.Runnable, java.lang.String)\n+   */\n+  public Thread()\n+  {\n+    this(null, null, gen_name());\n+  }\n+\n+  /**\n+   * Allocates a new <code>Thread</code> object. This constructor has\n+   * the same effect as <code>Thread(null, target,</code>\n+   * <i>gname</i><code>)</code>, where <i>gname</i> is\n+   * a newly generated name. Automatically generated names are of the\n+   * form <code>\"Thread-\"+</code><i>n</i>, where <i>n</i> is an integer.\n+   *\n+   * @param target the object whose <code>run</code> method is called.\n+   * @see java.lang.Thread#Thread(java.lang.ThreadGroup,\n+   *                              java.lang.Runnable, java.lang.String)\n+   */\n+  public Thread(Runnable target)\n+  {\n+    this(null, target, gen_name());\n+  }\n+\n+  /**\n+   * Allocates a new <code>Thread</code> object. This constructor has\n+   * the same effect as <code>Thread(null, null, name)</code>.\n+   *\n+   * @param   name   the name of the new thread.\n+   * @see     java.lang.Thread#Thread(java.lang.ThreadGroup,\n+   *          java.lang.Runnable, java.lang.String)\n+   */\n+  public Thread(String name)\n+  {\n+    this(null, null, name);\n+  }\n+\n+  /**\n+   * Allocate a new Thread object, with the specified ThreadGroup and name, and\n+   * using the specified Runnable object's <code>run()</code> method to\n+   * execute.  If the Runnable object is null, <code>this</code> (which is\n+   * a Runnable) is used instead.\n+   *\n+   * <p>If the ThreadGroup is null, the security manager is checked. If a\n+   * manager exists and returns a non-null object for\n+   * <code>getThreadGroup</code>, that group is used; otherwise the group\n+   * of the creating thread is used. Note that the security manager calls\n+   * <code>checkAccess</code> if the ThreadGroup is not null.\n+   *\n+   * <p>The new Thread will inherit its creator's priority and daemon status.\n+   * These can be changed with <code>setPriority</code> and\n+   * <code>setDaemon</code>.\n+   *\n+   * @param group the group to put the Thread into\n+   * @param target the Runnable object to execute\n+   * @param name the name for the Thread\n+   * @throws NullPointerException if name is null\n+   * @throws SecurityException if this thread cannot access <code>group</code>\n+   * @throws IllegalThreadStateException if group is destroyed\n+   * @see Runnable#run()\n+   * @see #run()\n+   * @see #setDaemon(boolean)\n+   * @see #setPriority(int)\n+   * @see SecurityManager#checkAccess(ThreadGroup)\n+   * @see ThreadGroup#checkAccess()\n+   */\n+  public Thread(ThreadGroup group, Runnable target, String name)\n+  {\n+    this(currentThread(), group, target, name);\n+  }\n+\n+  /**\n+   * Allocate a new Thread object, as if by\n+   * <code>Thread(group, null, name)</code>, and give it the specified stack\n+   * size, in bytes. The stack size is <b>highly platform independent</b>,\n+   * and the virtual machine is free to round up or down, or ignore it\n+   * completely.  A higher value might let you go longer before a\n+   * <code>StackOverflowError</code>, while a lower value might let you go\n+   * longer before an <code>OutOfMemoryError</code>.  Or, it may do absolutely\n+   * nothing! So be careful, and expect to need to tune this value if your\n+   * virtual machine even supports it.\n+   *\n+   * @param group the group to put the Thread into\n+   * @param target the Runnable object to execute\n+   * @param name the name for the Thread\n+   * @param size the stack size, in bytes; 0 to be ignored\n+   * @throws NullPointerException if name is null\n+   * @throws SecurityException if this thread cannot access <code>group</code>\n+   * @throws IllegalThreadStateException if group is destroyed\n+   * @since 1.4\n+   */\n+  public Thread(ThreadGroup group, Runnable target, String name, long size)\n+  {\n+    // Just ignore stackSize for now.\n+    this(currentThread(), group, target, name);\n+  }\n+\n+  /**\n+   * Allocates a new <code>Thread</code> object. This constructor has\n+   * the same effect as <code>Thread(group, target,</code>\n+   * <i>gname</i><code>)</code>, where <i>gname</i> is\n+   * a newly generated name. Automatically generated names are of the\n+   * form <code>\"Thread-\"+</code><i>n</i>, where <i>n</i> is an integer.\n+   *\n+   * @param      group    the thread group.\n+   * @param      target   the object whose <code>run</code> method is called.\n+   * @exception  SecurityException  if the current thread cannot create a\n+   *             thread in the specified thread group.\n+   * @see        java.lang.Thread#Thread(java.lang.ThreadGroup,\n+   *             java.lang.Runnable, java.lang.String)\n+   */\n+  public Thread(ThreadGroup group, Runnable target)\n+  {\n+    this(group, target, gen_name());\n+  }\n+\n+  /**\n+   * Allocates a new <code>Thread</code> object. This constructor has\n+   * the same effect as <code>Thread(group, null, name)</code>\n+   *\n+   * @param      group   the thread group.\n+   * @param      name    the name of the new thread.\n+   * @exception  SecurityException  if the current thread cannot create a\n+   *               thread in the specified thread group.\n+   * @see        java.lang.Thread#Thread(java.lang.ThreadGroup,\n+   *          java.lang.Runnable, java.lang.String)\n+   */\n+  public Thread(ThreadGroup group, String name)\n+  {\n+    this(group, null, name);\n+  }\n+\n+  /**\n+   * Allocates a new <code>Thread</code> object. This constructor has\n+   * the same effect as <code>Thread(null, target, name)</code>.\n+   *\n+   * @param   target   the object whose <code>run</code> method is called.\n+   * @param   name     the name of the new thread.\n+   * @see     java.lang.Thread#Thread(java.lang.ThreadGroup,\n+   *          java.lang.Runnable, java.lang.String)\n+   */\n+  public Thread(Runnable target, String name)\n+  {\n+    this(null, target, name);\n+  }\n+\n+  private Thread (Thread current, ThreadGroup g, Runnable r, String n)\n+  {\n+    // The Class Libraries book says ``threadName cannot be null''.  I\n+    // take this to mean NullPointerException.\n+    if (n == null)\n+      throw new NullPointerException ();\n+      \n+    if (g == null)\n+      {\n+\t// If CURRENT is null, then we are bootstrapping the first thread. \n+\t// Use ThreadGroup.root, the main threadgroup.\n+\tif (current == null)\n+\t  group = ThreadGroup.root;\n+\telse\n+\t  group = current.getThreadGroup();\n+      }\n+    else\n+      group = g;\n+      \n+    data = null;\n+    interrupt_flag = false;\n+    alive_flag = false;\n+    startable_flag = true;\n+\n+    if (current != null)\n+      {\n+\tgroup.checkAccess();\n+\n+\tdaemon_flag = current.isDaemon();\n+        int gmax = group.getMaxPriority();\n+\tint pri = current.getPriority();\n+\tpriority = (gmax < pri ? gmax : pri);\n+\tcontext_class_loader = current.context_class_loader;\n+\tInheritableThreadLocal.newChildThread(this);\n+      }\n+    else\n+      {\n+\tdaemon_flag = false;\n+\tpriority = NORM_PRIORITY;\n+      }\n+\n+    name = n;\n+    group.addThread(this);\n+    runnable = r;\n+\n+    initialize_native ();\n+  }\n \n   /**\n    * Get the number of active threads in the current Thread's ThreadGroup.\n@@ -465,13 +702,11 @@ public synchronized ClassLoader getContextClassLoader()\n   }\n \n   /**\n-   * Returns the context classloader of this Thread. The context\n-   * classloader can be used by code that want to load classes depending\n-   * on the current thread. Normally classes are loaded depending on\n-   * the classloader of the current class. There may be a security check\n-   * for <code>RuntimePermission(\"getClassLoader\")</code> if the caller's\n-   * class loader is not null or an ancestor of this thread's context class\n-   * loader.\n+   * Sets the context classloader for this Thread. When not explicitly set,\n+   * the context classloader for a thread is the same as the context\n+   * classloader of the thread that created this thread. The first thread has\n+   * as context classloader the system classloader. There may be a security\n+   * check for <code>RuntimePermission(\"setContextClassLoader\")</code>.\n    *\n    * @param classloader the new context class loader\n    * @throws SecurityException when permission is denied\n@@ -505,21 +740,10 @@ public final void setName(String name)\n   }\n \n   /**\n-   * Set this Thread's priority. There may be a security check,\n-   * <code>checkAccess</code>, then the priority is set to the smaller of\n-   * priority and the ThreadGroup maximum priority.\n-   *\n-   * @param priority the new priority for this Thread\n-   * @throws IllegalArgumentException if priority exceeds MIN_PRIORITY or\n-   *         MAX_PRIORITY\n-   * @throws SecurityException if you cannot modify this Thread\n-   * @see #getPriority()\n-   * @see #checkAccess()\n-   * @see ThreadGroup#getMaxPriority()\n-   * @see #MIN_PRIORITY\n-   * @see #MAX_PRIORITY\n+   * Causes the currently executing thread object to temporarily pause\n+   * and allow other threads to execute.\n    */\n-  public final native void setPriority (int newPriority);\n+  public static native void yield();\n \n   /**\n    * Suspend the current Thread's execution for the specified amount of\n@@ -646,247 +870,22 @@ public final void stop()\n    */\n   public final native void suspend();\n \n-  private final native void initialize_native ();\n-\n-  private final native static String gen_name ();\n-\n-  /**\n-   * Allocate a new Thread object, with the specified ThreadGroup and name, and\n-   * using the specified Runnable object's <code>run()</code> method to\n-   * execute.  If the Runnable object is null, <code>this</code> (which is\n-   * a Runnable) is used instead.\n-   *\n-   * <p>If the ThreadGroup is null, the security manager is checked. If a\n-   * manager exists and returns a non-null object for\n-   * <code>getThreadGroup</code>, that group is used; otherwise the group\n-   * of the creating thread is used. Note that the security manager calls\n-   * <code>checkAccess</code> if the ThreadGroup is not null.\n-   *\n-   * <p>The new Thread will inherit its creator's priority and daemon status.\n-   * These can be changed with <code>setPriority</code> and\n-   * <code>setDaemon</code>.\n-   *\n-   * @param group the group to put the Thread into\n-   * @param target the Runnable object to execute\n-   * @param name the name for the Thread\n-   * @throws NullPointerException if name is null\n-   * @throws SecurityException if this thread cannot access <code>group</code>\n-   * @throws IllegalThreadStateException if group is destroyed\n-   * @see Runnable#run()\n-   * @see #run()\n-   * @see #setDaemon(boolean)\n-   * @see #setPriority(int)\n-   * @see SecurityManager#checkAccess(ThreadGroup)\n-   * @see ThreadGroup#checkAccess()\n-   */\n-  public Thread (ThreadGroup g, Runnable r, String n)\n-  {\n-    this (currentThread (), g, r, n);\n-  }\n-\n-  /**\n-   * Allocate a new Thread object, as if by\n-   * <code>Thread(group, null, name)</code>, and give it the specified stack\n-   * size, in bytes. The stack size is <b>highly platform independent</b>,\n-   * and the virtual machine is free to round up or down, or ignore it\n-   * completely.  A higher value might let you go longer before a\n-   * <code>StackOverflowError</code>, while a lower value might let you go\n-   * longer before an <code>OutOfMemoryError</code>.  Or, it may do absolutely\n-   * nothing! So be careful, and expect to need to tune this value if your\n-   * virtual machine even supports it.\n-   *\n-   * @param group the group to put the Thread into\n-   * @param target the Runnable object to execute\n-   * @param name the name for the Thread\n-   * @param size the stack size, in bytes; 0 to be ignored\n-   * @throws NullPointerException if name is null\n-   * @throws SecurityException if this thread cannot access <code>group</code>\n-   * @throws IllegalThreadStateException if group is destroyed\n-   * @since 1.4\n-   */\n-  public Thread (ThreadGroup g, Runnable r, String n, long size)\n-  {\n-    // Just ignore stackSize for now.\n-    this (currentThread (), g, r, n);\n-  }\n-\n-  private Thread (Thread current, ThreadGroup g, Runnable r, String n)\n-  {\n-    // The Class Libraries book says ``threadName cannot be null''.  I\n-    // take this to mean NullPointerException.\n-    if (n == null)\n-      throw new NullPointerException ();\n-      \n-    if (g == null)\n-      {\n-\t// If CURRENT is null, then we are bootstrapping the first thread. \n-\t// Use ThreadGroup.root, the main threadgroup.\n-\tif (current == null)\n-\t  group = ThreadGroup.root;\n-\telse\n-\t  group = current.getThreadGroup();\n-      }\n-    else\n-      group = g;\n-      \n-    data = null;\n-    interrupt_flag = false;\n-    alive_flag = false;\n-    startable_flag = true;\n-\n-    if (current != null)\n-      {\n-\tgroup.checkAccess();\n-\n-\tdaemon_flag = current.isDaemon();\n-        int gmax = group.getMaxPriority();\n-\tint pri = current.getPriority();\n-\tpriority = (gmax < pri ? gmax : pri);\n-\tcontext_class_loader = current.context_class_loader;\n-\tInheritableThreadLocal.newChildThread(this);\n-      }\n-    else\n-      {\n-\tdaemon_flag = false;\n-\tpriority = NORM_PRIORITY;\n-      }\n-\n-    name = n;\n-    group.addThread(this);\n-    runnable = r;\n-\n-    initialize_native ();\n-  }\n-\n-  /**\n-   * Allocates a new <code>Thread</code> object. This constructor has\n-   * the same effect as <code>Thread(null, null,</code>\n-   * <i>gname</i><code>)</code>, where <b><i>gname</i></b> is\n-   * a newly generated name. Automatically generated names are of the\n-   * form <code>\"Thread-\"+</code><i>n</i>, where <i>n</i> is an integer.\n-   * <p>\n-   * Threads created this way must have overridden their\n-   * <code>run()</code> method to actually do anything.  An example\n-   * illustrating this method being used follows:\n-   * <p><blockquote><pre>\n-   *     import java.lang.*;\n-   *\n-   *     class plain01 implements Runnable {\n-   *         String name;\n-   *         plain01() {\n-   *             name = null;\n-   *         }\n-   *         plain01(String s) {\n-   *             name = s;\n-   *         }\n-   *         public void run() {\n-   *             if (name == null)\n-   *                 System.out.println(\"A new thread created\");\n-   *             else\n-   *                 System.out.println(\"A new thread with name \" + name +\n-   *                                    \" created\");\n-   *         }\n-   *     }\n-   *     class threadtest01 {\n-   *         public static void main(String args[] ) {\n-   *             int failed = 0 ;\n-   *\n-   *             <b>Thread t1 = new Thread();</b>\n-   *             if (t1 != null)\n-   *                 System.out.println(\"new Thread() succeed\");\n-   *             else {\n-   *                 System.out.println(\"new Thread() failed\");\n-   *                 failed++;\n-   *             }\n-   *         }\n-   *     }\n-   * </pre></blockquote>\n-   *\n-   * @see     java.lang.Thread#Thread(java.lang.ThreadGroup,\n-   *          java.lang.Runnable, java.lang.String)\n-   */\n-  public Thread ()\n-  {\n-    this (null, null, gen_name ());\n-  }\n-\n-  /**\n-   * Allocates a new <code>Thread</code> object. This constructor has\n-   * the same effect as <code>Thread(null, target,</code>\n-   * <i>gname</i><code>)</code>, where <i>gname</i> is\n-   * a newly generated name. Automatically generated names are of the\n-   * form <code>\"Thread-\"+</code><i>n</i>, where <i>n</i> is an integer.\n-   *\n-   * @param   target   the object whose <code>run</code> method is called.\n-   * @see     java.lang.Thread#Thread(java.lang.ThreadGroup,\n-   *          java.lang.Runnable, java.lang.String)\n-   */\n-  public Thread (Runnable r)\n-  {\n-    this (null, r, gen_name ());\n-  }\n-\n   /**\n-   * Allocates a new <code>Thread</code> object. This constructor has\n-   * the same effect as <code>Thread(null, null, name)</code>.\n-   *\n-   * @param   name   the name of the new thread.\n-   * @see     java.lang.Thread#Thread(java.lang.ThreadGroup,\n-   *          java.lang.Runnable, java.lang.String)\n-   */\n-  public Thread (String n)\n-  {\n-    this (null, null, n);\n-  }\n-\n-  /**\n-   * Allocates a new <code>Thread</code> object. This constructor has\n-   * the same effect as <code>Thread(group, target,</code>\n-   * <i>gname</i><code>)</code>, where <i>gname</i> is\n-   * a newly generated name. Automatically generated names are of the\n-   * form <code>\"Thread-\"+</code><i>n</i>, where <i>n</i> is an integer.\n-   *\n-   * @param      group    the thread group.\n-   * @param      target   the object whose <code>run</code> method is called.\n-   * @exception  SecurityException  if the current thread cannot create a\n-   *             thread in the specified thread group.\n-   * @see        java.lang.Thread#Thread(java.lang.ThreadGroup,\n-   *             java.lang.Runnable, java.lang.String)\n-   */\n-  public Thread (ThreadGroup g, Runnable r)\n-  {\n-    this (g, r, gen_name ());\n-  }\n-\n-  /**\n-   * Allocates a new <code>Thread</code> object. This constructor has\n-   * the same effect as <code>Thread(group, null, name)</code>\n-   *\n-   * @param      group   the thread group.\n-   * @param      name    the name of the new thread.\n-   * @exception  SecurityException  if the current thread cannot create a\n-   *               thread in the specified thread group.\n-   * @see        java.lang.Thread#Thread(java.lang.ThreadGroup,\n-   *          java.lang.Runnable, java.lang.String)\n-   */\n-  public Thread (ThreadGroup g, String n)\n-  {\n-    this (g, null, n);\n-  }\n-\n-  /**\n-   * Allocates a new <code>Thread</code> object. This constructor has\n-   * the same effect as <code>Thread(null, target, name)</code>.\n+   * Set this Thread's priority. There may be a security check,\n+   * <code>checkAccess</code>, then the priority is set to the smaller of\n+   * priority and the ThreadGroup maximum priority.\n    *\n-   * @param   target   the object whose <code>run</code> method is called.\n-   * @param   name     the name of the new thread.\n-   * @see     java.lang.Thread#Thread(java.lang.ThreadGroup,\n-   *          java.lang.Runnable, java.lang.String)\n+   * @param priority the new priority for this Thread\n+   * @throws IllegalArgumentException if priority exceeds MIN_PRIORITY or\n+   *         MAX_PRIORITY\n+   * @throws SecurityException if you cannot modify this Thread\n+   * @see #getPriority()\n+   * @see #checkAccess()\n+   * @see ThreadGroup#getMaxPriority()\n+   * @see #MIN_PRIORITY\n+   * @see #MAX_PRIORITY\n    */\n-  public Thread (Runnable r, String n)\n-  {\n-    this (null, r, n);\n-  }\n+  public final native void setPriority(int newPriority);\n \n   /**\n    * Returns a string representation of this thread, including the\n@@ -900,10 +899,7 @@ public String toString()\n \t    + (group == null ? \"\" : group.getName()) + \"]\");\n   }\n \n-  /**\n-   * Causes the currently executing thread object to temporarily pause\n-   * and allow other threads to execute.\n-   */\n-  public static native void yield ();\n+  private final native void initialize_native();\n \n+  private final native static String gen_name();\n }"}]}