{"sha": "02d92e3b707a5433814ca22aab53da2d229dc3e1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDJkOTJlM2I3MDdhNTQzMzgxNGNhMjJhYWI1M2RhMmQyMjlkYzNlMQ==", "commit": {"author": {"name": "Stephen M. Webb", "email": "stephen@bregmasoft.com", "date": "2001-07-18T17:09:02Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2001-07-18T17:09:02Z"}, "message": "All occurrences of the __value_type() and __distance_type() functions...\n\n\n2001-07-17  Stephen M. Webb   <stephen@bregmasoft.com>r\n\n\tAll occurrences of the __value_type() and __distance_type()\n\tfunctions, which were required to support the HP STL, have been\n\tremoved along with all the auxiliary forwarding functions that\n\twere required to support their use.\n\n\tThe __iterator_category() function was pretty much left alone\n\tbecause there was no benefit to removing it and its use made code\n\tjust a little more readable.\n\n\tIncidences of distance() with nonstandard argument list were\n\treplaced by calls to the standard function (only in the files\n\taffected by the removal of the other HP functions).\n\n\tThe signature of the rotate() algorithm was changed to match the\n\tstandard.\n\n\tHeaders were reformatted under C++STYLE guidelines (indentation,\n\tlinebreaks, typename keyword).\n\n\t* include/bits/stl_algo.h: replaced __value_type() and\n\t__distance_type() with iterator_traits, eliminated auxiliary\n\tsupport functions required to support said function usage.\n\tChanged nonstandard distance() call to standard call.\n\n\t* include/bits/stl_algobase.h: Same.\n\t* include/bits/stl_heap.h: Same.\n\t* include/bits/stl_numeric.h: Same.\n\t* include/bits/stl_uninitialized.h: Same.\n\t* include/bits/stl_iterator_base_types.h (__value_type()):\n\tRemoved.\n\t(__distance_type()): Removed.\n\t(value_type()): Gone.\n\t(distance_type()): Done in.\n\t(iterator_category()): Hasta la vista, baby.\n\n\t* include/bits/stl_iterator_base_funcs.h (iterator_category()):\n\tReplaced with __iterator_category().\n\t* include/backward/iterator.h: moved definition of value_type(),\n\tdistance_type(), and iterator_category() out of std:: and into\n\there.\n\t* testsuite/23_containers/vector_ctor.cc (test03): New testcases.\n\t* testsuite/23_containers/vector_modifiers.cc (test03): New testcases.\n\t* testsuite/25_algorithms/rotate.cc: New testcase.\n\t* testsuite/25_algorithms/copy.cc: New testcase.\n\t* testsuite/25_algorithms/sort.cc: Same.\n\t* testsuite/25_algorithms/heap.cc: Same.\n\t* testsuite/25_algorithms/partition.cc: Same.\n\t* testsuite/25_algorithms/binary_search.cc: Same.\n\t* testsuite/26_numerics/sum_diff.cc: Ditto.\n\nFrom-SVN: r44117", "tree": {"sha": "88f4d5e7d2b5ab64060c9f83b95b512349e2552d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/88f4d5e7d2b5ab64060c9f83b95b512349e2552d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/02d92e3b707a5433814ca22aab53da2d229dc3e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02d92e3b707a5433814ca22aab53da2d229dc3e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02d92e3b707a5433814ca22aab53da2d229dc3e1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02d92e3b707a5433814ca22aab53da2d229dc3e1/comments", "author": null, "committer": null, "parents": [{"sha": "860a15368d564787c79e76fefb37cecd57ee8c12", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/860a15368d564787c79e76fefb37cecd57ee8c12", "html_url": "https://github.com/Rust-GCC/gccrs/commit/860a15368d564787c79e76fefb37cecd57ee8c12"}], "stats": {"total": 12946, "additions": 6644, "deletions": 6302}, "files": [{"sha": "ff2efd386c7bdc9dfd64811b491c07e8e6c7600a", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 53, "deletions": 1, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02d92e3b707a5433814ca22aab53da2d229dc3e1/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02d92e3b707a5433814ca22aab53da2d229dc3e1/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=02d92e3b707a5433814ca22aab53da2d229dc3e1", "patch": "@@ -1,4 +1,56 @@\n-2001-07-17  Benjamin Kosnik  <bkoz@redhat.com>\n+2001-07-17  Stephen M. Webb   <stephen@bregmasoft.com>r\n+\n+\tAll occurrences of the __value_type() and __distance_type()\n+\tfunctions, which were required to support the HP STL, have been\n+\tremoved along with all the auxiliary forwarding functions that\n+\twere required to support their use.\n+\n+\tThe __iterator_category() function was pretty much left alone\n+\tbecause there was no benefit to removing it and its use made code\n+\tjust a little more readable.\n+\n+\tIncidences of distance() with nonstandard argument list were\n+\treplaced by calls to the standard function (only in the files\n+\taffected by the removal of the other HP functions).\n+\n+\tThe signature of the rotate() algorithm was changed to match the\n+\tstandard.\n+\n+\tHeaders were reformatted under C++STYLE guidelines (indentation,\n+\tlinebreaks, typename keyword).\n+\n+\t* include/bits/stl_algo.h: replaced __value_type() and\n+\t__distance_type() with iterator_traits, eliminated auxiliary\n+\tsupport functions required to support said function usage.\n+\tChanged nonstandard distance() call to standard call.\n+\n+\t* include/bits/stl_algobase.h: Same.\n+\t* include/bits/stl_heap.h: Same.\n+\t* include/bits/stl_numeric.h: Same.\n+\t* include/bits/stl_uninitialized.h: Same.\n+\t* include/bits/stl_iterator_base_types.h (__value_type()):\n+\tRemoved.\n+\t(__distance_type()): Removed.\n+\t(value_type()): Gone.\n+\t(distance_type()): Done in.\n+\t(iterator_category()): Hasta la vista, baby.\n+\n+\t* include/bits/stl_iterator_base_funcs.h (iterator_category()):\n+\tReplaced with __iterator_category().\n+\t* include/backward/iterator.h: moved definition of value_type(),\n+\tdistance_type(), and iterator_category() out of std:: and into\n+\there.\n+\t* testsuite/23_containers/vector_ctor.cc (test03): New testcases.\n+\t* testsuite/23_containers/vector_modifiers.cc (test03): New testcases.\n+\t* testsuite/25_algorithms/rotate.cc: New testcase.\n+\t* testsuite/25_algorithms/copy.cc: New testcase.\n+\t* testsuite/25_algorithms/sort.cc: Same.\n+\t* testsuite/25_algorithms/heap.cc: Same.\n+\t* testsuite/25_algorithms/partition.cc: Same.\n+\t* testsuite/25_algorithms/binary_search.cc: Same.\n+\t* testsuite/26_numerics/sum_diff.cc: Ditto.\n+\n+001-07-17  Benjamin Kosnik  <bkoz@redhat.com>\n \n \t* testsuite/README: Add notes on naming test cases.\n \t* testsuite/22_locale/members.cc: Mark as xfail."}, {"sha": "08f3f6165492fb99493432341c81fa7c17db87a9", "filename": "libstdc++-v3/Makefile.in", "status": "modified", "additions": 1, "deletions": 38, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02d92e3b707a5433814ca22aab53da2d229dc3e1/libstdc%2B%2B-v3%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02d92e3b707a5433814ca22aab53da2d229dc3e1/libstdc%2B%2B-v3%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FMakefile.in?ref=02d92e3b707a5433814ca22aab53da2d229dc3e1", "patch": "@@ -145,44 +145,7 @@ MULTICLEAN = true\n # Work around what appears to be a GNU make bug handling MAKEFLAGS\n # values defined in terms of make variables, as is the case for CC and\n # friends when we are called from the top level Makefile.\n-AM_MAKEFLAGS = \\\n-\t\"AR_FLAGS=$(AR_FLAGS)\" \\\n-\t\"CC_FOR_BUILD=$(CC_FOR_BUILD)\" \\\n-\t\"CC_FOR_TARGET=$(CC_FOR_TARGET)\" \\\n-\t\"CFLAGS=$(CFLAGS)\" \\\n-\t\"CXXFLAGS=$(CXXFLAGS)\" \\\n-\t\"CFLAGS_FOR_BUILD=$(CFLAGS_FOR_BUILD)\" \\\n-\t\"CFLAGS_FOR_TARGET=$(CFLAGS_FOR_TARGET)\" \\\n-\t\"INSTALL=$(INSTALL)\" \\\n-\t\"INSTALL_DATA=$(INSTALL_DATA)\" \\\n-\t\"INSTALL_PROGRAM=$(INSTALL_PROGRAM)\" \\\n-\t\"INSTALL_SCRIPT=$(INSTALL_SCRIPT)\" \\\n-\t\"LDFLAGS=$(LDFLAGS)\" \\\n-\t\"LIBCFLAGS=$(LIBCFLAGS)\" \\\n-\t\"LIBCFLAGS_FOR_TARGET=$(LIBCFLAGS_FOR_TARGET)\" \\\n-\t\"MAKE=$(MAKE)\" \\\n-\t\"MAKEINFO=$(MAKEINFO) $(MAKEINFOFLAGS)\" \\\n-\t\"PICFLAG=$(PICFLAG)\" \\\n-\t\"PICFLAG_FOR_TARGET=$(PICFLAG_FOR_TARGET)\" \\\n-\t\"SHELL=$(SHELL)\" \\\n-\t\"RUNTESTFLAGS=$(RUNTESTFLAGS)\" \\\n-\t\"exec_prefix=$(exec_prefix)\" \\\n-\t\"infodir=$(infodir)\" \\\n-\t\"libdir=$(libdir)\" \\\n-\t\"includedir=$(includedir)\" \\\n-\t\"prefix=$(prefix)\" \\\n-\t\"tooldir=$(tooldir)\" \\\n-\t\"AR=$(AR)\" \\\n-\t\"AS=$(AS)\" \\\n-\t\"LD=$(LD)\" \\\n-\t\"LIBCFLAGS=$(LIBCFLAGS)\" \\\n-\t\"PICFLAG=$(PICFLAG)\" \\\n-\t\"RANLIB=$(RANLIB)\" \\\n-\t\"NM=$(NM)\" \\\n-\t\"NM_FOR_BUILD=$(NM_FOR_BUILD)\" \\\n-\t\"NM_FOR_TARGET=$(NM_FOR_TARGET)\" \\\n-\t\"DESTDIR=$(DESTDIR)\" \\\n-\t\"WERROR=$(WERROR)\" \n+AM_MAKEFLAGS =  \t\"AR_FLAGS=$(AR_FLAGS)\" \t\"CC_FOR_BUILD=$(CC_FOR_BUILD)\" \t\"CC_FOR_TARGET=$(CC_FOR_TARGET)\" \t\"CFLAGS=$(CFLAGS)\" \t\"CXXFLAGS=$(CXXFLAGS)\" \t\"CFLAGS_FOR_BUILD=$(CFLAGS_FOR_BUILD)\" \t\"CFLAGS_FOR_TARGET=$(CFLAGS_FOR_TARGET)\" \t\"INSTALL=$(INSTALL)\" \t\"INSTALL_DATA=$(INSTALL_DATA)\" \t\"INSTALL_PROGRAM=$(INSTALL_PROGRAM)\" \t\"INSTALL_SCRIPT=$(INSTALL_SCRIPT)\" \t\"LDFLAGS=$(LDFLAGS)\" \t\"LIBCFLAGS=$(LIBCFLAGS)\" \t\"LIBCFLAGS_FOR_TARGET=$(LIBCFLAGS_FOR_TARGET)\" \t\"MAKE=$(MAKE)\" \t\"MAKEINFO=$(MAKEINFO) $(MAKEINFOFLAGS)\" \t\"PICFLAG=$(PICFLAG)\" \t\"PICFLAG_FOR_TARGET=$(PICFLAG_FOR_TARGET)\" \t\"SHELL=$(SHELL)\" \t\"RUNTESTFLAGS=$(RUNTESTFLAGS)\" \t\"exec_prefix=$(exec_prefix)\" \t\"infodir=$(infodir)\" \t\"libdir=$(libdir)\" \t\"includedir=$(includedir)\" \t\"prefix=$(prefix)\" \t\"tooldir=$(tooldir)\" \t\"AR=$(AR)\" \t\"AS=$(AS)\" \t\"LD=$(LD)\" \t\"LIBCFLAGS=$(LIBCFLAGS)\" \t\"PICFLAG=$(PICFLAG)\" \t\"RANLIB=$(RANLIB)\" \t\"NM=$(NM)\" \t\"NM_FOR_BUILD=$(NM_FOR_BUILD)\" \t\"NM_FOR_TARGET=$(NM_FOR_TARGET)\" \t\"DESTDIR=$(DESTDIR)\" \t\"WERROR=$(WERROR)\" \n \n ACLOCAL_M4 = $(top_srcdir)/aclocal.m4\n CONFIG_HEADER = config.h"}, {"sha": "46075a08dc578215eda3cabfcf578a0c6425a68a", "filename": "libstdc++-v3/configure", "status": "modified", "additions": 854, "deletions": 865, "changes": 1719, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02d92e3b707a5433814ca22aab53da2d229dc3e1/libstdc%2B%2B-v3%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02d92e3b707a5433814ca22aab53da2d229dc3e1/libstdc%2B%2B-v3%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfigure?ref=02d92e3b707a5433814ca22aab53da2d229dc3e1"}, {"sha": "339607aa447458a435b4df9f70c4ea91e7464f9c", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 8, "deletions": 219, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02d92e3b707a5433814ca22aab53da2d229dc3e1/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02d92e3b707a5433814ca22aab53da2d229dc3e1/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=02d92e3b707a5433814ca22aab53da2d229dc3e1", "patch": "@@ -131,254 +131,43 @@ glibcpp_builddir = @glibcpp_builddir@\n \n bits_srcdir = ${glibcpp_srcdir}/include/bits\n bits_builddir = ./bits\n-bits_headers = \\\n-\t${bits_srcdir}/basic_file.h \\\n-\t${bits_srcdir}/basic_ios.h \\\n-\t${bits_srcdir}/basic_ios.tcc \\\n-\t${bits_srcdir}/basic_string.h \\\n-\t${bits_srcdir}/basic_string.tcc \\\n-\t${bits_srcdir}/boost_concept_check.h \\\n-\t${bits_srcdir}/char_traits.h \\\n-\t${bits_srcdir}/codecvt.h \\\n-\t${bits_srcdir}/concept_check.h \\\n-\t${bits_srcdir}/cpp_type_traits.h \\\n-\t${bits_srcdir}/fpos.h \\\n-\t${bits_srcdir}/fstream.tcc \\\n-\t${bits_srcdir}/functexcept.h \\\n-\t${bits_srcdir}/generic_shadow.h \\\n-\t${bits_srcdir}/gslice.h \\\n-\t${bits_srcdir}/gslice_array.h \\\n-\t${bits_srcdir}/indirect_array.h \\\n-\t${bits_srcdir}/ios_base.h \\\n-\t${bits_srcdir}/istream.tcc \\\n-\t${bits_srcdir}/locale_facets.h \\\n-\t${bits_srcdir}/locale_facets.tcc \\\n-\t${bits_srcdir}/localefwd.h \\\n-\t${bits_srcdir}/mask_array.h \\\n-\t${bits_srcdir}/ostream.tcc \\\n-\t${bits_srcdir}/pthread_allocimpl.h \\\n-\t${bits_srcdir}/stream_iterator.h \\\n-\t${bits_srcdir}/streambuf_iterator.h \\\n-\t${bits_srcdir}/slice.h \\\n-\t${bits_srcdir}/slice_array.h \\\n-\t${bits_srcdir}/sstream.tcc \\\n-\t${bits_srcdir}/std_algorithm.h \\\n-\t${bits_srcdir}/std_bitset.h \\\n-\t${bits_srcdir}/std_complex.h \\\n-\t${bits_srcdir}/std_deque.h \\\n-\t${bits_srcdir}/std_fstream.h \\\n-\t${bits_srcdir}/std_functional.h \\\n-\t${bits_srcdir}/std_iomanip.h \\\n-\t${bits_srcdir}/std_ios.h \\\n-\t${bits_srcdir}/std_iosfwd.h \\\n-\t${bits_srcdir}/std_iostream.h \\\n-\t${bits_srcdir}/std_istream.h \\\n-\t${bits_srcdir}/std_iterator.h \\\n-\t${bits_srcdir}/std_list.h \\\n-\t${bits_srcdir}/std_locale.h \\\n-\t${bits_srcdir}/std_map.h \\\n-\t${bits_srcdir}/std_memory.h \\\n-\t${bits_srcdir}/std_numeric.h \\\n-\t${bits_srcdir}/std_ostream.h \\\n-\t${bits_srcdir}/std_queue.h \\\n-\t${bits_srcdir}/std_set.h \\\n-\t${bits_srcdir}/std_sstream.h \\\n-\t${bits_srcdir}/std_stack.h \\\n-\t${bits_srcdir}/std_stdexcept.h \\\n-\t${bits_srcdir}/std_streambuf.h \\\n-\t${bits_srcdir}/std_string.h \\\n-\t${bits_srcdir}/std_utility.h \\\n-\t${bits_srcdir}/std_valarray.h \\\n-\t${bits_srcdir}/std_vector.h \\\n-\t${bits_srcdir}/stl_algo.h \\\n-\t${bits_srcdir}/stl_algobase.h \\\n-\t${bits_srcdir}/stl_alloc.h \\\n-\t${bits_srcdir}/stl_bvector.h \\\n-\t${bits_srcdir}/stl_construct.h \\\n-\t${bits_srcdir}/stl_deque.h \\\n-\t${bits_srcdir}/stl_function.h \\\n-\t${bits_srcdir}/stl_heap.h \\\n-\t${bits_srcdir}/stl_iterator.h \\\n-\t${bits_srcdir}/stl_iterator_base_funcs.h \\\n-\t${bits_srcdir}/stl_iterator_base_types.h \\\n-\t${bits_srcdir}/stl_list.h \\\n-\t${bits_srcdir}/stl_map.h \\\n-\t${bits_srcdir}/stl_multimap.h \\\n-\t${bits_srcdir}/stl_multiset.h \\\n-\t${bits_srcdir}/stl_numeric.h \\\n-\t${bits_srcdir}/stl_pair.h \\\n-\t${bits_srcdir}/stl_pthread_alloc.h \\\n-\t${bits_srcdir}/stl_queue.h \\\n-\t${bits_srcdir}/stl_raw_storage_iter.h \\\n-\t${bits_srcdir}/stl_relops.h \\\n-\t${bits_srcdir}/stl_set.h \\\n-\t${bits_srcdir}/stl_stack.h \\\n-\t${bits_srcdir}/stl_tempbuf.h \\\n-\t${bits_srcdir}/stl_threads.h \\\n-\t${bits_srcdir}/stl_tree.h \\\n-\t${bits_srcdir}/stl_uninitialized.h \\\n-\t${bits_srcdir}/stl_vector.h \\\n-\t${bits_srcdir}/streambuf.tcc \\\n-\t${bits_srcdir}/stringfwd.h \\\n-\t${bits_srcdir}/type_traits.h \\\n-\t${bits_srcdir}/valarray_array.h \\\n-\t${bits_srcdir}/valarray_array.tcc \\\n-\t${bits_srcdir}/valarray_meta.h\n+bits_headers =  \t${bits_srcdir}/basic_file.h \t${bits_srcdir}/basic_ios.h \t${bits_srcdir}/basic_ios.tcc \t${bits_srcdir}/basic_string.h \t${bits_srcdir}/basic_string.tcc \t${bits_srcdir}/boost_concept_check.h \t${bits_srcdir}/char_traits.h \t${bits_srcdir}/codecvt.h \t${bits_srcdir}/concept_check.h \t${bits_srcdir}/cpp_type_traits.h \t${bits_srcdir}/fpos.h \t${bits_srcdir}/fstream.tcc \t${bits_srcdir}/functexcept.h \t${bits_srcdir}/generic_shadow.h \t${bits_srcdir}/gslice.h \t${bits_srcdir}/gslice_array.h \t${bits_srcdir}/indirect_array.h \t${bits_srcdir}/ios_base.h \t${bits_srcdir}/istream.tcc \t${bits_srcdir}/locale_facets.h \t${bits_srcdir}/locale_facets.tcc \t${bits_srcdir}/localefwd.h \t${bits_srcdir}/mask_array.h \t${bits_srcdir}/ostream.tcc \t${bits_srcdir}/pthread_allocimpl.h \t${bits_srcdir}/stream_iterator.h \t${bits_srcdir}/streambuf_iterator.h \t${bits_srcdir}/slice.h \t${bits_srcdir}/slice_array.h \t${bits_srcdir}/sstream.tcc \t${bits_srcdir}/std_algorithm.h \t${bits_srcdir}/std_bitset.h \t${bits_srcdir}/std_complex.h \t${bits_srcdir}/std_deque.h \t${bits_srcdir}/std_fstream.h \t${bits_srcdir}/std_functional.h \t${bits_srcdir}/std_iomanip.h \t${bits_srcdir}/std_ios.h \t${bits_srcdir}/std_iosfwd.h \t${bits_srcdir}/std_iostream.h \t${bits_srcdir}/std_istream.h \t${bits_srcdir}/std_iterator.h \t${bits_srcdir}/std_list.h \t${bits_srcdir}/std_locale.h \t${bits_srcdir}/std_map.h \t${bits_srcdir}/std_memory.h \t${bits_srcdir}/std_numeric.h \t${bits_srcdir}/std_ostream.h \t${bits_srcdir}/std_queue.h \t${bits_srcdir}/std_set.h \t${bits_srcdir}/std_sstream.h \t${bits_srcdir}/std_stack.h \t${bits_srcdir}/std_stdexcept.h \t${bits_srcdir}/std_streambuf.h \t${bits_srcdir}/std_string.h \t${bits_srcdir}/std_utility.h \t${bits_srcdir}/std_valarray.h \t${bits_srcdir}/std_vector.h \t${bits_srcdir}/stl_algo.h \t${bits_srcdir}/stl_algobase.h \t${bits_srcdir}/stl_alloc.h \t${bits_srcdir}/stl_bvector.h \t${bits_srcdir}/stl_construct.h \t${bits_srcdir}/stl_deque.h \t${bits_srcdir}/stl_function.h \t${bits_srcdir}/stl_heap.h \t${bits_srcdir}/stl_iterator.h \t${bits_srcdir}/stl_iterator_base_funcs.h \t${bits_srcdir}/stl_iterator_base_types.h \t${bits_srcdir}/stl_list.h \t${bits_srcdir}/stl_map.h \t${bits_srcdir}/stl_multimap.h \t${bits_srcdir}/stl_multiset.h \t${bits_srcdir}/stl_numeric.h \t${bits_srcdir}/stl_pair.h \t${bits_srcdir}/stl_pthread_alloc.h \t${bits_srcdir}/stl_queue.h \t${bits_srcdir}/stl_raw_storage_iter.h \t${bits_srcdir}/stl_relops.h \t${bits_srcdir}/stl_set.h \t${bits_srcdir}/stl_stack.h \t${bits_srcdir}/stl_tempbuf.h \t${bits_srcdir}/stl_threads.h \t${bits_srcdir}/stl_tree.h \t${bits_srcdir}/stl_uninitialized.h \t${bits_srcdir}/stl_vector.h \t${bits_srcdir}/streambuf.tcc \t${bits_srcdir}/stringfwd.h \t${bits_srcdir}/type_traits.h \t${bits_srcdir}/valarray_array.h \t${bits_srcdir}/valarray_array.tcc \t${bits_srcdir}/valarray_meta.h\n \n \n backward_srcdir = ${glibcpp_srcdir}/include/backward\n backward_builddir = ./backward\n-backward_headers = \\\n-\t${backward_srcdir}/complex.h \\\n-\t${backward_srcdir}/iomanip.h \\\n-\t${backward_srcdir}/istream.h \\\n-\t${backward_srcdir}/ostream.h \\\n-\t${backward_srcdir}/stream.h \\\n-\t${backward_srcdir}/streambuf.h \\\n-\t${backward_srcdir}/algo.h \\\n-\t${backward_srcdir}/algobase.h \\\n-\t${backward_srcdir}/alloc.h \\\n-\t${backward_srcdir}/bvector.h \\\n-\t${backward_srcdir}/defalloc.h \\\n-\t${backward_srcdir}/deque.h \\\n-\t${backward_srcdir}/function.h \\\n-\t${backward_srcdir}/hash_map.h \\\n-\t${backward_srcdir}/hash_set.h \\\n-\t${backward_srcdir}/hashtable.h \\\n-\t${backward_srcdir}/heap.h \\\n-\t${backward_srcdir}/iostream.h \\\n-\t${backward_srcdir}/iterator.h \\\n-\t${backward_srcdir}/list.h \\\n-\t${backward_srcdir}/map.h \\\n-\t${backward_srcdir}/multimap.h \\\n-\t${backward_srcdir}/new.h \\\n-\t${backward_srcdir}/multiset.h \\\n-\t${backward_srcdir}/pair.h \\\n-\t${backward_srcdir}/queue.h \\\n-\t${backward_srcdir}/rope.h \\\n-\t${backward_srcdir}/set.h \\\n-\t${backward_srcdir}/slist.h \\\n-\t${backward_srcdir}/stack.h \\\n-\t${backward_srcdir}/tempbuf.h \\\n-\t${backward_srcdir}/tree.h \\\n-\t${backward_srcdir}/vector.h \\\n-\t${backward_srcdir}/fstream.h \\\n-\t${backward_srcdir}/strstream.h \\\n-\t${backward_srcdir}/strstream \\\n-\t${backward_srcdir}/backward_warning.h\n+backward_headers =  \t${backward_srcdir}/complex.h \t${backward_srcdir}/iomanip.h \t${backward_srcdir}/istream.h \t${backward_srcdir}/ostream.h \t${backward_srcdir}/stream.h \t${backward_srcdir}/streambuf.h \t${backward_srcdir}/algo.h \t${backward_srcdir}/algobase.h \t${backward_srcdir}/alloc.h \t${backward_srcdir}/bvector.h \t${backward_srcdir}/defalloc.h \t${backward_srcdir}/deque.h \t${backward_srcdir}/function.h \t${backward_srcdir}/hash_map.h \t${backward_srcdir}/hash_set.h \t${backward_srcdir}/hashtable.h \t${backward_srcdir}/heap.h \t${backward_srcdir}/iostream.h \t${backward_srcdir}/iterator.h \t${backward_srcdir}/list.h \t${backward_srcdir}/map.h \t${backward_srcdir}/multimap.h \t${backward_srcdir}/new.h \t${backward_srcdir}/multiset.h \t${backward_srcdir}/pair.h \t${backward_srcdir}/queue.h \t${backward_srcdir}/rope.h \t${backward_srcdir}/set.h \t${backward_srcdir}/slist.h \t${backward_srcdir}/stack.h \t${backward_srcdir}/tempbuf.h \t${backward_srcdir}/tree.h \t${backward_srcdir}/vector.h \t${backward_srcdir}/fstream.h \t${backward_srcdir}/strstream.h \t${backward_srcdir}/strstream \t${backward_srcdir}/backward_warning.h\n \n \n ext_srcdir = ${glibcpp_srcdir}/include/ext\n ext_builddir = ./ext\n-ext_headers = \\\n-\t${ext_srcdir}/rope \\\n-\t${ext_srcdir}/ropeimpl.h \\\n-\t${ext_srcdir}/stl_rope.h \\\n-\t${ext_srcdir}/slist \\\n-\t${ext_srcdir}/hash_map \\\n-\t${ext_srcdir}/hash_set \\\n-\t${ext_srcdir}/stl_hashtable.h \\\n-\t${ext_srcdir}/stl_hash_fun.h\n+ext_headers =  \t${ext_srcdir}/rope \t${ext_srcdir}/ropeimpl.h \t${ext_srcdir}/stl_rope.h \t${ext_srcdir}/slist \t${ext_srcdir}/hash_map \t${ext_srcdir}/hash_set \t${ext_srcdir}/stl_hashtable.h \t${ext_srcdir}/stl_hash_fun.h\n \n \n # This is the common subset of files that all three \"C\" header models use.\n c_base_srcdir = @C_INCLUDE_DIR@/bits\n c_base_builddir = ./bits\n-c_base_headers = \\\n-\t${c_base_srcdir}/std_cassert.h \\\n-\t${c_base_srcdir}/std_cctype.h \\\n-\t${c_base_srcdir}/std_cerrno.h \\\n-\t${c_base_srcdir}/std_cfloat.h \\\n-\t${c_base_srcdir}/std_climits.h \\\n-\t${c_base_srcdir}/std_clocale.h \\\n-\t${c_base_srcdir}/std_cmath.h \\\n-\t${c_base_srcdir}/std_csetjmp.h \\\n-\t${c_base_srcdir}/std_csignal.h \\\n-\t${c_base_srcdir}/std_cstdarg.h \\\n-\t${c_base_srcdir}/std_cstddef.h \\\n-\t${c_base_srcdir}/std_cstdio.h \\\n-\t${c_base_srcdir}/std_cstdlib.h \\\n-\t${c_base_srcdir}/std_cstring.h \\\n-\t${c_base_srcdir}/std_ctime.h \\\n-\t${c_base_srcdir}/std_cwchar.h \\\n-\t${c_base_srcdir}/std_cwctype.h \\\n-\t${c_base_srcdir}/cmath.tcc \n+c_base_headers =  \t${c_base_srcdir}/std_cassert.h \t${c_base_srcdir}/std_cctype.h \t${c_base_srcdir}/std_cerrno.h \t${c_base_srcdir}/std_cfloat.h \t${c_base_srcdir}/std_climits.h \t${c_base_srcdir}/std_clocale.h \t${c_base_srcdir}/std_cmath.h \t${c_base_srcdir}/std_csetjmp.h \t${c_base_srcdir}/std_csignal.h \t${c_base_srcdir}/std_cstdarg.h \t${c_base_srcdir}/std_cstddef.h \t${c_base_srcdir}/std_cstdio.h \t${c_base_srcdir}/std_cstdlib.h \t${c_base_srcdir}/std_cstring.h \t${c_base_srcdir}/std_ctime.h \t${c_base_srcdir}/std_cwchar.h \t${c_base_srcdir}/std_cwctype.h \t${c_base_srcdir}/cmath.tcc \n \n \n std_srcdir = ${glibcpp_srcdir}/include/std\n std_builddir = ./\n-std_headers = \\\n-\t${std_srcdir}/algorithm \\\n-\t${std_srcdir}/bitset \\\n-\t${std_srcdir}/complex \\\n-\t${std_srcdir}/deque \\\n-\t${std_srcdir}/fstream \\\n-\t${std_srcdir}/functional \\\n-\t${std_srcdir}/iomanip \\\n-\t${std_srcdir}/ios \\\n-\t${std_srcdir}/iosfwd \\\n-\t${std_srcdir}/iostream \\\n-\t${std_srcdir}/istream \\\n-\t${std_srcdir}/iterator \\\n-\t${std_srcdir}/limits \\\n-\t${std_srcdir}/list \\\n-\t${std_srcdir}/locale \\\n-\t${std_srcdir}/map \\\n-\t${std_srcdir}/memory \\\n-\t${std_srcdir}/numeric \\\n-\t${std_srcdir}/ostream \\\n-\t${std_srcdir}/queue \\\n-\t${std_srcdir}/set \\\n-\t${std_srcdir}/sstream \\\n-\t${std_srcdir}/stack \\\n-\t${std_srcdir}/stdexcept \\\n-\t${std_srcdir}/streambuf \\\n-\t${std_srcdir}/string \\\n-\t${std_srcdir}/utility \\\n-\t${std_srcdir}/valarray \\\n-\t${std_srcdir}/vector \\\n-\t${std_srcdir}/cassert \\\n-\t${std_srcdir}/cctype \\\n-\t${std_srcdir}/cerrno \\\n-\t${std_srcdir}/cfloat \\\n-\t${std_srcdir}/climits \\\n-\t${std_srcdir}/clocale \\\n-\t${std_srcdir}/ciso646 \\\n-\t${std_srcdir}/cmath \\\n-\t${std_srcdir}/csetjmp \\\n-\t${std_srcdir}/csignal \\\n-\t${std_srcdir}/cstdarg \\\n-\t${std_srcdir}/cstddef \\\n-\t${std_srcdir}/cstdio \\\n-\t${std_srcdir}/cstdlib \\\n-\t${std_srcdir}/cstring \\\n-\t${std_srcdir}/ctime \\\n-\t${std_srcdir}/cwchar \\\n-\t${std_srcdir}/cwctype\n+std_headers =  \t${std_srcdir}/algorithm \t${std_srcdir}/bitset \t${std_srcdir}/complex \t${std_srcdir}/deque \t${std_srcdir}/fstream \t${std_srcdir}/functional \t${std_srcdir}/iomanip \t${std_srcdir}/ios \t${std_srcdir}/iosfwd \t${std_srcdir}/iostream \t${std_srcdir}/istream \t${std_srcdir}/iterator \t${std_srcdir}/limits \t${std_srcdir}/list \t${std_srcdir}/locale \t${std_srcdir}/map \t${std_srcdir}/memory \t${std_srcdir}/numeric \t${std_srcdir}/ostream \t${std_srcdir}/queue \t${std_srcdir}/set \t${std_srcdir}/sstream \t${std_srcdir}/stack \t${std_srcdir}/stdexcept \t${std_srcdir}/streambuf \t${std_srcdir}/string \t${std_srcdir}/utility \t${std_srcdir}/valarray \t${std_srcdir}/vector \t${std_srcdir}/cassert \t${std_srcdir}/cctype \t${std_srcdir}/cerrno \t${std_srcdir}/cfloat \t${std_srcdir}/climits \t${std_srcdir}/clocale \t${std_srcdir}/ciso646 \t${std_srcdir}/cmath \t${std_srcdir}/csetjmp \t${std_srcdir}/csignal \t${std_srcdir}/cstdarg \t${std_srcdir}/cstddef \t${std_srcdir}/cstdio \t${std_srcdir}/cstdlib \t${std_srcdir}/cstring \t${std_srcdir}/ctime \t${std_srcdir}/cwchar \t${std_srcdir}/cwctype\n \n \n target_srcdir = ${glibcpp_srcdir}/@OS_INC_SRCDIR@\n target_builddir = ./${target_alias}/bits\n-target_headers = \\\n-\t${target_srcdir}/ctype_base.h \\\n-\t${target_srcdir}/ctype_inline.h \\\n-\t${target_srcdir}/ctype_noninline.h \\\n-\t${target_srcdir}/os_defines.h \\\n-\t${glibcpp_srcdir}/@ATOMICITY_INC_SRCDIR@/atomicity.h\n+target_headers =  \t${target_srcdir}/ctype_base.h \t${target_srcdir}/ctype_inline.h \t${target_srcdir}/ctype_noninline.h \t${target_srcdir}/os_defines.h \t${glibcpp_srcdir}/@ATOMICITY_INC_SRCDIR@/atomicity.h\n \n \n thread_builddir = ./${target_alias}/bits\n-thread_headers = \\\n-\t${thread_builddir}/gthr.h \\\n-\t${thread_builddir}/gthr-single.h \\\n-\t${thread_builddir}/gthr-default.h\n+thread_headers =  \t${thread_builddir}/gthr.h \t${thread_builddir}/gthr-single.h \t${thread_builddir}/gthr-default.h\n \n \n # List of all timestamp files.  By keeping only one copy of this list, both\n # CLEANFILES and all-local are kept up-to-date.\n # XXX stamp-c_compatibility \n-allstamps = stamp-std stamp-bits stamp-c_base stamp-backward stamp-ext \\\n-\tstamp-target stamp-thread stamp-file_model stamp-io stamp-locale\n+allstamps = stamp-std stamp-bits stamp-c_base stamp-backward stamp-ext \tstamp-target stamp-thread stamp-file_model stamp-io stamp-locale\n \n \n # By adding these files here, automake will remove them for 'make clean'"}, {"sha": "d213c1d3025cfbf51c7fccd258f8fb33e61fe1c5", "filename": "libstdc++-v3/include/backward/iterator.h", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02d92e3b707a5433814ca22aab53da2d229dc3e1/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fiterator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02d92e3b707a5433814ca22aab53da2d229dc3e1/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fiterator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Fiterator.h?ref=02d92e3b707a5433814ca22aab53da2d229dc3e1", "patch": "@@ -54,9 +54,20 @@ using std::random_access_iterator;\n \n using std::iterator_traits;\n \n-using std::iterator_category;\n-using std::distance_type;\n-using std::value_type;\n+template <class _Iter>\n+  inline typename iterator_traits<_Iter>::iterator_category\n+  iterator_category(const _Iter& __i)\n+  { return __iterator_category(__i); }\n+\n+template <class _Iter>\n+  inline typename iterator_traits<_Iter>::difference_type*\n+  distance_type(const _Iter&)\n+  { return static_cast<typename iterator_traits<_Iter>::difference_type*>(0); }\n+\n+template<class _Iter>\n+  inline typename iterator_traits<_Iter>::value_type*\n+  value_type(const _Iter& __i)\n+  { return static_cast<typename iterator_traits<_Iter>::value_type*>(0); }\n \n using std::distance; \n using std::advance; "}, {"sha": "353e4219c3e74fbaa1b037518087325319a73db1", "filename": "libstdc++-v3/include/bits/stl_algo.h", "status": "modified", "additions": 3409, "deletions": 3475, "changes": 6884, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02d92e3b707a5433814ca22aab53da2d229dc3e1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02d92e3b707a5433814ca22aab53da2d229dc3e1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algo.h?ref=02d92e3b707a5433814ca22aab53da2d229dc3e1"}, {"sha": "bd8c62502ae6a01cf69095e9a55ca6c1c9ce94e5", "filename": "libstdc++-v3/include/bits/stl_algobase.h", "status": "modified", "additions": 636, "deletions": 625, "changes": 1261, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02d92e3b707a5433814ca22aab53da2d229dc3e1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algobase.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02d92e3b707a5433814ca22aab53da2d229dc3e1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algobase.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algobase.h?ref=02d92e3b707a5433814ca22aab53da2d229dc3e1", "patch": "@@ -62,12 +62,8 @@\n #define __SGI_STL_INTERNAL_ALGOBASE_H\n \n #include <bits/c++config.h>\n-#ifndef __SGI_STL_INTERNAL_PAIR_H\n #include <bits/stl_pair.h>\n-#endif\n-#ifndef _CPP_BITS_TYPE_TRAITS_H\n #include <bits/type_traits.h>\n-#endif\n #include <bits/std_cstring.h>\n #include <bits/std_climits.h>\n #include <bits/std_cstdlib.h>\n@@ -83,648 +79,663 @@\n namespace std\n {\n \n-// swap and iter_swap\n-\n-template <class _ForwardIter1, class _ForwardIter2, class _Tp>\n-inline void __iter_swap(_ForwardIter1 __a, _ForwardIter2 __b, _Tp*)\n-{\n-  _Tp __tmp = *__a;\n-  *__a = *__b;\n-  *__b = __tmp;\n-}\n-\n-template <class _ForwardIter1, class _ForwardIter2>\n-inline void iter_swap(_ForwardIter1 __a, _ForwardIter2 __b)\n-{\n-  // concept requirements\n-  __glibcpp_function_requires(_Mutable_ForwardIteratorConcept<_ForwardIter1>);\n-  __glibcpp_function_requires(_Mutable_ForwardIteratorConcept<_ForwardIter2>);\n-  __glibcpp_function_requires(_ConvertibleConcept<\n-        typename iterator_traits<_ForwardIter1>::value_type,\n-        typename iterator_traits<_ForwardIter2>::value_type>);\n-  __glibcpp_function_requires(_ConvertibleConcept<\n-        typename iterator_traits<_ForwardIter2>::value_type,\n-        typename iterator_traits<_ForwardIter1>::value_type>);\n-\n-  __iter_swap(__a, __b, __value_type(__a));\n-}\n-\n-template <class _Tp>\n-inline void swap(_Tp& __a, _Tp& __b)\n-{\n-  // concept requirements\n-  __glibcpp_function_requires(_SGIAssignableConcept<_Tp>);\n-\n-  _Tp __tmp = __a;\n-  __a = __b;\n-  __b = __tmp;\n-}\n-\n-//--------------------------------------------------\n-// min and max\n-\n-#undef min\n-#undef max\n-\n-template <class _Tp>\n-inline const _Tp& min(const _Tp& __a, const _Tp& __b) {\n-  // concept requirements\n-  __glibcpp_function_requires(_LessThanComparableConcept<_Tp>);\n-  //return __b < __a ? __b : __a;\n-  if (__b < __a) return __b; return __a;\n-}\n-\n-template <class _Tp>\n-inline const _Tp& max(const _Tp& __a, const _Tp& __b) {\n-  // concept requirements\n-  __glibcpp_function_requires(_LessThanComparableConcept<_Tp>);\n-  //return  __a < __b ? __b : __a;\n-  if (__a < __b) return __b; return __a;\n-}\n-\n-template <class _Tp, class _Compare>\n-inline const _Tp& min(const _Tp& __a, const _Tp& __b, _Compare __comp) {\n-  //return __comp(__b, __a) ? __b : __a;\n-  if (__comp(__b, __a)) return __b; return __a;\n-}\n-\n-template <class _Tp, class _Compare>\n-inline const _Tp& max(const _Tp& __a, const _Tp& __b, _Compare __comp) {\n-  //return __comp(__a, __b) ? __b : __a;\n-  if (__comp(__a, __b)) return __b; return __a;\n-}\n-\n-//--------------------------------------------------\n-// copy\n-\n-// All of these auxiliary functions serve two purposes.  (1) Replace\n-// calls to copy with memmove whenever possible.  (Memmove, not memcpy,\n-// because the input and output ranges are permitted to overlap.)\n-// (2) If we're using random access iterators, then write the loop as\n-// a for loop with an explicit count.\n-\n-template <class _InputIter, class _OutputIter, class _Distance>\n-inline _OutputIter __copy(_InputIter __first, _InputIter __last,\n-                          _OutputIter __result,\n-                          input_iterator_tag, _Distance*)\n-{\n-  for ( ; __first != __last; ++__result, ++__first)\n-    *__result = *__first;\n-  return __result;\n-}\n-\n-template <class _RandomAccessIter, class _OutputIter, class _Distance>\n-inline _OutputIter\n-__copy(_RandomAccessIter __first, _RandomAccessIter __last,\n-       _OutputIter __result, random_access_iterator_tag, _Distance*)\n-{\n-  for (_Distance __n = __last - __first; __n > 0; --__n) {\n-    *__result = *__first;\n-    ++__first;\n-    ++__result;\n-  }\n-  return __result;\n-}\n-\n-template <class _Tp>\n-inline _Tp*\n-__copy_trivial(const _Tp* __first, const _Tp* __last, _Tp* __result)\n-{\n-  memmove(__result, __first, sizeof(_Tp) * (__last - __first));\n-  return __result + (__last - __first);\n-}\n-\n-\n-template <class _InputIter, class _OutputIter>\n-inline _OutputIter __copy_aux2(_InputIter __first, _InputIter __last,\n-                               _OutputIter __result, __false_type)\n-{\n-  return __copy(__first, __last, __result,\n-                __iterator_category(__first),\n-                __distance_type(__first));\n-}\n-\n-template <class _InputIter, class _OutputIter>\n-inline _OutputIter __copy_aux2(_InputIter __first, _InputIter __last,\n-                               _OutputIter __result, __true_type)\n-{\n-  return __copy(__first, __last, __result,\n-                __iterator_category(__first),\n-                __distance_type(__first));\n-}\n-\n-template <class _Tp>\n-inline _Tp* __copy_aux2(_Tp* __first, _Tp* __last, _Tp* __result,\n-                        __true_type)\n-{\n-  return __copy_trivial(__first, __last, __result);\n-}\n-\n-template <class _Tp>\n-inline _Tp* __copy_aux2(const _Tp* __first, const _Tp* __last, _Tp* __result,\n-                        __true_type)\n-{\n-  return __copy_trivial(__first, __last, __result);\n-}\n-\n-\n-template <class _InputIter, class _OutputIter, class _Tp>\n-inline _OutputIter __copy_aux(_InputIter __first, _InputIter __last,\n-                              _OutputIter __result, _Tp*)\n-{\n-  typedef typename __type_traits<_Tp>::has_trivial_assignment_operator\n-          _Trivial;\n-  return __copy_aux2(__first, __last, __result, _Trivial());\n-}\n-\n-template<typename _InputIter, typename _OutputIter>\n-inline _OutputIter __copy_ni2(_InputIter __first, _InputIter __last,\n-                               _OutputIter __result, __true_type)\n-{\n-  return _OutputIter(__copy_aux(__first, __last, __result.base(),\n-                                __value_type(__first)));\n-}\n-\n-template<typename _InputIter, typename _OutputIter>\n-inline _OutputIter __copy_ni2(_InputIter __first, _InputIter __last,\n-\t\t\t      _OutputIter __result, __false_type)\n-{\n-  return __copy_aux(__first, __last, __result, __value_type(__first));\n-}\n-\n-template<typename _InputIter, typename _OutputIter>\n-inline _OutputIter __copy_ni1(_InputIter __first, _InputIter __last,\n-                               _OutputIter __result, __true_type)\n-{\n-  typedef typename _Is_normal_iterator<_OutputIter>::_Normal __Normal;\n-  return __copy_ni2(__first.base(), __last.base(), __result, __Normal());\n-}\n-\n-template<typename _InputIter, typename _OutputIter>\n-inline _OutputIter __copy_ni1(_InputIter __first, _InputIter __last,\n-                               _OutputIter __result, __false_type)\n-{\n-  typedef typename _Is_normal_iterator<_OutputIter>::_Normal __Normal;\n-  return __copy_ni2(__first, __last, __result, __Normal());\n-}\n-\n-template <class _InputIter, class _OutputIter>\n-inline _OutputIter copy(_InputIter __first, _InputIter __last,\n-                        _OutputIter __result)\n-{\n-  // concept requirements\n-  __glibcpp_function_requires(_InputIteratorConcept<_InputIter>);\n-  __glibcpp_function_requires(_OutputIteratorConcept<_OutputIter,\n-        typename iterator_traits<_InputIter>::value_type>);\n-\n-   typedef typename _Is_normal_iterator<_InputIter>::_Normal __Normal;\n-   return __copy_ni1(__first, __last, __result, __Normal());\n-}\n-\n-//--------------------------------------------------\n-// copy_backward\n-\n-template <class _BidirectionalIter1, class _BidirectionalIter2, \n-          class _Distance>\n-inline _BidirectionalIter2 __copy_backward(_BidirectionalIter1 __first, \n-                                           _BidirectionalIter1 __last, \n-                                           _BidirectionalIter2 __result,\n-                                           bidirectional_iterator_tag,\n-                                           _Distance*)\n-{\n-  while (__first != __last)\n-    *--__result = *--__last;\n-  return __result;\n-}\n-\n-template <class _RandomAccessIter, class _BidirectionalIter, class _Distance>\n-inline _BidirectionalIter __copy_backward(_RandomAccessIter __first, \n-                                          _RandomAccessIter __last, \n-                                          _BidirectionalIter __result,\n-                                          random_access_iterator_tag,\n-                                          _Distance*)\n-{\n-  for (_Distance __n = __last - __first; __n > 0; --__n)\n-    *--__result = *--__last;\n-  return __result;\n-}\n-\n-\n-// This dispatch class is a workaround for compilers that do not \n-// have partial ordering of function templates.  All we're doing is\n-// creating a specialization so that we can turn a call to copy_backward\n-// into a memmove whenever possible.\n-\n-template <class _BidirectionalIter1, class _BidirectionalIter2,\n-          class _BoolType>\n-struct __copy_backward_dispatch\n-{\n-  typedef typename iterator_traits<_BidirectionalIter1>::iterator_category \n-          _Cat;\n-  typedef typename iterator_traits<_BidirectionalIter1>::difference_type\n+  // swap and iter_swap\n+\n+  template<typename _ForwardIter1, typename _ForwardIter2>\n+    inline void\n+    iter_swap(_ForwardIter1 __a, _ForwardIter2 __b)\n+    {\n+      typedef typename iterator_traits<_ForwardIter1>::value_type _ValueType1;\n+      typedef typename iterator_traits<_ForwardIter2>::value_type _ValueType2;\n+\n+      // concept requirements\n+      __glibcpp_function_requires(_Mutable_ForwardIteratorConcept<_ForwardIter1>);\n+      __glibcpp_function_requires(_Mutable_ForwardIteratorConcept<_ForwardIter2>);\n+      __glibcpp_function_requires(_ConvertibleConcept<_ValueType1, _ValueType2>);\n+      __glibcpp_function_requires(_ConvertibleConcept<_ValueType2, _ValueType1>);\n+\n+      _ValueType1 __tmp = *__a;\n+      *__a = *__b;\n+      *__b = __tmp;\n+    }\n+\n+  template<typename _Tp>\n+    inline void\n+    swap(_Tp& __a, _Tp& __b)\n+    {\n+      // concept requirements\n+      __glibcpp_function_requires(_SGIAssignableConcept<_Tp>);\n+      \n+      _Tp __tmp = __a;\n+      __a = __b;\n+      __b = __tmp;\n+    }\n+\n+  //--------------------------------------------------\n+  // min and max\n+\n+  #undef min\n+  #undef max\n+\n+  template<typename _Tp>\n+    inline const _Tp&\n+    min(const _Tp& __a, const _Tp& __b)\n+    {\n+      // concept requirements\n+      __glibcpp_function_requires(_LessThanComparableConcept<_Tp>);\n+      //return __b < __a ? __b : __a;\n+      if (__b < __a) return __b; return __a;\n+    }\n+\n+  template<typename _Tp>\n+    inline const _Tp&\n+    max(const _Tp& __a, const _Tp& __b) \n+    {\n+      // concept requirements\n+      __glibcpp_function_requires(_LessThanComparableConcept<_Tp>);\n+      //return  __a < __b ? __b : __a;\n+      if (__a < __b) return __b; return __a;\n+    }\n+\n+  template<typename _Tp, typename _Compare>\n+    inline const _Tp&\n+    min(const _Tp& __a, const _Tp& __b, _Compare __comp)\n+    {\n+      //return __comp(__b, __a) ? __b : __a;\n+      if (__comp(__b, __a)) return __b; return __a;\n+    }\n+\n+  template<typename _Tp, typename _Compare>\n+    inline const _Tp&\n+    max(const _Tp& __a, const _Tp& __b, _Compare __comp)\n+    {\n+      //return __comp(__a, __b) ? __b : __a;\n+      if (__comp(__a, __b)) return __b; return __a;\n+    }\n+\n+  //--------------------------------------------------\n+  // copy\n+\n+  // All of these auxiliary functions serve two purposes.  (1) Replace\n+  // calls to copy with memmove whenever possible.  (Memmove, not memcpy,\n+  // because the input and output ranges are permitted to overlap.)\n+  // (2) If we're using random access iterators, then write the loop as\n+  // a for loop with an explicit count.\n+\n+  template<typename _InputIter, typename _OutputIter>\n+    inline _OutputIter\n+    __copy(_InputIter __first, _InputIter __last,\n+\t   _OutputIter __result,\n+\t   input_iterator_tag)\n+    {\n+      for ( ; __first != __last; ++__result, ++__first)\n+\t*__result = *__first;\n+      return __result;\n+    }\n+\n+  template<typename _RandomAccessIter, typename _OutputIter>\n+    inline _OutputIter\n+    __copy(_RandomAccessIter __first, _RandomAccessIter __last,\n+\t   _OutputIter __result,\n+\t   random_access_iterator_tag)\n+    {\n+      typedef typename iterator_traits<_RandomAccessIter>::difference_type\n           _Distance;\n-\n-  static _BidirectionalIter2 copy(_BidirectionalIter1 __first, \n-                                  _BidirectionalIter1 __last, \n-                                  _BidirectionalIter2 __result) {\n-    return __copy_backward(__first, __last, __result, _Cat(), (_Distance*) 0);\n-  }\n-};\n-\n-template <class _Tp>\n-struct __copy_backward_dispatch<_Tp*, _Tp*, __true_type>\n-{\n-  static _Tp* copy(const _Tp* __first, const _Tp* __last, _Tp* __result) {\n-    const ptrdiff_t _Num = __last - __first;\n-    memmove(__result - _Num, __first, sizeof(_Tp) * _Num);\n-    return __result - _Num;\n-  }\n-};\n-\n-template <class _Tp>\n-struct __copy_backward_dispatch<const _Tp*, _Tp*, __true_type>\n-{\n-  static _Tp* copy(const _Tp* __first, const _Tp* __last, _Tp* __result) {\n-    return  __copy_backward_dispatch<_Tp*, _Tp*, __true_type>\n-      ::copy(__first, __last, __result);\n-  }\n-};\n-\n-template <class _BI1, class _BI2>\n-inline _BI2 __copy_backward_aux(_BI1 __first, _BI1 __last, _BI2 __result) {\n-  typedef typename __type_traits<typename iterator_traits<_BI2>::value_type>\n-                        ::has_trivial_assignment_operator\n+      for (_Distance __n = __last - __first; __n > 0; --__n) {\n+\t*__result = *__first;\n+\t++__first;\n+\t++__result;\n+      }\n+      return __result;\n+    }\n+\n+  template<typename _Tp>\n+    inline _Tp*\n+    __copy_trivial(const _Tp* __first, const _Tp* __last, _Tp* __result)\n+    {\n+      memmove(__result, __first, sizeof(_Tp) * (__last - __first));\n+      return __result + (__last - __first);\n+    }\n+\n+  template<typename _InputIter, typename _OutputIter>\n+    inline _OutputIter\n+    __copy_aux2(_InputIter __first, _InputIter __last,\n+\t\t_OutputIter __result, __false_type)\n+    { return __copy(__first, __last, __result, __iterator_category(__first)); }\n+\n+  template<typename _InputIter, typename _OutputIter>\n+    inline _OutputIter\n+    __copy_aux2(_InputIter __first, _InputIter __last,\n+\t\t_OutputIter __result, __true_type)\n+    { return __copy(__first, __last, __result, __iterator_category(__first)); }\n+\n+  template<typename _Tp>\n+    inline _Tp*\n+    __copy_aux2(_Tp* __first, _Tp* __last,\n+\t\t_Tp* __result, __true_type)\n+    { return __copy_trivial(__first, __last, __result); }\n+\n+  template<typename _Tp>\n+    inline _Tp*\n+    __copy_aux2(const _Tp* __first, const _Tp* __last,\n+\t\t_Tp* __result, __true_type)\n+    { return __copy_trivial(__first, __last, __result); }\n+\n+  template<typename _InputIter, typename _OutputIter>\n+    inline _OutputIter\n+    __copy_ni2(_InputIter __first, _InputIter __last,\n+\t       _OutputIter __result, __true_type)\n+    {\n+      typedef typename iterator_traits<_InputIter>::value_type\n+\t  _ValueType;\n+      typedef typename __type_traits<_ValueType>::has_trivial_assignment_operator\n+\t  _Trivial;\n+      return _OutputIter(__copy_aux2(__first, __last,\n+                                     __result.base(),\n+\t\t\t\t     _Trivial()));\n+    }\n+\n+  template<typename _InputIter, typename _OutputIter>\n+    inline _OutputIter\n+    __copy_ni2(_InputIter __first, _InputIter __last,\n+\t       _OutputIter __result, __false_type)\n+    {\n+      typedef typename iterator_traits<_InputIter>::value_type\n+          _ValueType;\n+      typedef typename __type_traits<_ValueType>::has_trivial_assignment_operator\n           _Trivial;\n-  return __copy_backward_dispatch<_BI1, _BI2, _Trivial>\n-              ::copy(__first, __last, __result);\n-}\n-\n-template <typename _BI1, typename _BI2>\n-inline _BI2 __copy_backward_output_normal_iterator(_BI1 __first, _BI1 __last,\n-                                                   _BI2 __result, __true_type) {\n-  return _BI2(__copy_backward_aux(__first, __last, __result.base()));\n-}\n-\n-template <typename _BI1, typename _BI2>\n-inline _BI2 __copy_backward_output_normal_iterator(_BI1 __first, _BI1 __last,\n-                                                   _BI2 __result, __false_type){\n-  return __copy_backward_aux(__first, __last, __result);\n-}\n-\n-template <typename _BI1, typename _BI2>\n-inline _BI2 __copy_backward_input_normal_iterator(_BI1 __first, _BI1 __last,\n-                                                  _BI2 __result, __true_type) {\n-  typedef typename _Is_normal_iterator<_BI2>::_Normal __Normal;\n-  return __copy_backward_output_normal_iterator(__first.base(), __last.base(),\n-                                                __result, __Normal());\n-}\n-\n-template <typename _BI1, typename _BI2>\n-inline _BI2 __copy_backward_input_normal_iterator(_BI1 __first, _BI1 __last,\n-                                                  _BI2 __result, __false_type) {\n-  typedef typename _Is_normal_iterator<_BI2>::_Normal __Normal;\n-  return __copy_backward_output_normal_iterator(__first, __last, __result,\n-                                                __Normal());\n-}\n-\n-template <typename _BI1, typename _BI2>\n-inline _BI2 copy_backward(_BI1 __first, _BI1 __last, _BI2 __result)\n-{\n-  // concept requirements\n-  __glibcpp_function_requires(_BidirectionalIteratorConcept<_BI1>);\n-  __glibcpp_function_requires(_Mutable_BidirectionalIteratorConcept<_BI2>);\n-  __glibcpp_function_requires(_ConvertibleConcept<\n-        typename iterator_traits<_BI1>::value_type,\n-        typename iterator_traits<_BI2>::value_type>);\n-\n-  typedef typename _Is_normal_iterator<_BI1>::_Normal __Normal;\n-  return __copy_backward_input_normal_iterator(__first, __last, __result,\n-                                               __Normal());\n-}\n-\n-//--------------------------------------------------\n-// copy_n (not part of the C++ standard)\n-\n-template <class _InputIter, class _Size, class _OutputIter>\n-pair<_InputIter, _OutputIter> __copy_n(_InputIter __first, _Size __count,\n-                                       _OutputIter __result,\n-                                       input_iterator_tag) {\n-  for ( ; __count > 0; --__count) {\n-    *__result = *__first;\n-    ++__first;\n-    ++__result;\n+      return __copy_aux2(__first, __last,\n+                         __result,\n+\t\t\t _Trivial());\n+    }\n+\n+  template<typename _InputIter, typename _OutputIter>\n+    inline _OutputIter\n+    __copy_ni1(_InputIter __first, _InputIter __last,\n+\t       _OutputIter __result, __true_type)\n+    {\n+      typedef typename _Is_normal_iterator<_OutputIter>::_Normal __Normal;\n+      return __copy_ni2(__first.base(), __last.base(), __result, __Normal());\n+    }\n+\n+  template<typename _InputIter, typename _OutputIter>\n+    inline _OutputIter\n+    __copy_ni1(_InputIter __first, _InputIter __last,\n+\t       _OutputIter __result, __false_type)\n+    {\n+      typedef typename _Is_normal_iterator<_OutputIter>::_Normal __Normal;\n+      return __copy_ni2(__first, __last, __result, __Normal());\n+    }\n+\n+  template<typename _InputIter, typename _OutputIter>\n+    inline _OutputIter\n+    copy(_InputIter __first, _InputIter __last, _OutputIter __result)\n+    {\n+      // concept requirements\n+      __glibcpp_function_requires(_InputIteratorConcept<_InputIter>);\n+      __glibcpp_function_requires(_OutputIteratorConcept<_OutputIter,\n+\t    typename iterator_traits<_InputIter>::value_type>);\n+\n+       typedef typename _Is_normal_iterator<_InputIter>::_Normal __Normal;\n+       return __copy_ni1(__first, __last, __result, __Normal());\n+    }\n+\n+  //--------------------------------------------------\n+  // copy_backward\n+\n+  template<typename _BidirectionalIter1, typename _BidirectionalIter2>\n+    inline _BidirectionalIter2\n+    __copy_backward(_BidirectionalIter1 __first, _BidirectionalIter1 __last, \n+\t\t    _BidirectionalIter2 __result,\n+\t\t    bidirectional_iterator_tag)\n+    {\n+      while (__first != __last)\n+        *--__result = *--__last;\n+      return __result;\n+    }\n+\n+  template<typename _RandomAccessIter, typename _BidirectionalIter>\n+    inline _BidirectionalIter\n+    __copy_backward(_RandomAccessIter __first, _RandomAccessIter __last, \n+\t\t    _BidirectionalIter __result,\n+\t\t    random_access_iterator_tag)\n+    {\n+      typename iterator_traits<_RandomAccessIter>::difference_type __n;\n+      for (__n = __last - __first; __n > 0; --__n)\n+        *--__result = *--__last;\n+      return __result;\n+    }\n+\n+\n+  // This dispatch class is a workaround for compilers that do not \n+  // have partial ordering of function templates.  All we're doing is\n+  // creating a specialization so that we can turn a call to copy_backward\n+  // into a memmove whenever possible.\n+\n+  template<typename _BidirectionalIter1, typename _BidirectionalIter2,\n+           typename _BoolType>\n+    struct __copy_backward_dispatch\n+    {\n+      static _BidirectionalIter2\n+      copy(_BidirectionalIter1 __first, _BidirectionalIter1 __last, \n+\t   _BidirectionalIter2 __result)\n+      {\n+        return __copy_backward(__first, __last,\n+\t                       __result,\n+\t\t\t       __iterator_category(__first));\n+      }\n+    };\n+\n+  template<typename _Tp>\n+    struct __copy_backward_dispatch<_Tp*, _Tp*, __true_type>\n+    {\n+      static _Tp*\n+      copy(const _Tp* __first, const _Tp* __last, _Tp* __result)\n+      {\n+\tconst ptrdiff_t _Num = __last - __first;\n+\tmemmove(__result - _Num, __first, sizeof(_Tp) * _Num);\n+\treturn __result - _Num;\n+      }\n+    };\n+\n+  template<typename _Tp>\n+    struct __copy_backward_dispatch<const _Tp*, _Tp*, __true_type>\n+    {\n+      static _Tp*\n+      copy(const _Tp* __first, const _Tp* __last, _Tp* __result)\n+      {\n+\treturn  __copy_backward_dispatch<_Tp*, _Tp*, __true_type>\n+\t  ::copy(__first, __last, __result);\n+      }\n+    };\n+\n+  template<typename _BI1, typename _BI2>\n+    inline _BI2\n+    __copy_backward_aux(_BI1 __first, _BI1 __last, _BI2 __result)\n+    {\n+      typedef typename __type_traits<typename iterator_traits<_BI2>::value_type>\n+\t\t\t    ::has_trivial_assignment_operator _Trivial;\n+      return __copy_backward_dispatch<_BI1, _BI2, _Trivial>\n+\t\t  ::copy(__first, __last, __result);\n+    }\n+\n+  template <typename _BI1, typename _BI2>\n+    inline _BI2\n+    __copy_backward_output_normal_iterator(_BI1 __first, _BI1 __last,\n+\t\t\t\t\t   _BI2 __result, __true_type)\n+    { return _BI2(__copy_backward_aux(__first, __last, __result.base())); }\n+\n+  template <typename _BI1, typename _BI2>\n+    inline _BI2\n+    __copy_backward_output_normal_iterator(_BI1 __first, _BI1 __last,\n+\t\t\t\t\t   _BI2 __result, __false_type)\n+    { return __copy_backward_aux(__first, __last, __result); }\n+\n+  template <typename _BI1, typename _BI2>\n+    inline _BI2\n+    __copy_backward_input_normal_iterator(_BI1 __first, _BI1 __last,\n+\t\t\t\t\t  _BI2 __result, __true_type)\n+    {\n+      typedef typename _Is_normal_iterator<_BI2>::_Normal __Normal;\n+      return __copy_backward_output_normal_iterator(__first.base(), __last.base(),\n+\t\t\t\t\t\t    __result, __Normal());\n+    }\n+\n+  template <typename _BI1, typename _BI2>\n+    inline _BI2\n+    __copy_backward_input_normal_iterator(_BI1 __first, _BI1 __last,\n+\t\t\t\t\t  _BI2 __result, __false_type)\n+    {\n+      typedef typename _Is_normal_iterator<_BI2>::_Normal __Normal;\n+      return __copy_backward_output_normal_iterator(__first, __last, __result,\n+\t\t\t\t\t\t    __Normal());\n+    }\n+\n+  template <typename _BI1, typename _BI2>\n+    inline _BI2\n+    copy_backward(_BI1 __first, _BI1 __last, _BI2 __result)\n+    {\n+      // concept requirements\n+      __glibcpp_function_requires(_BidirectionalIteratorConcept<_BI1>);\n+      __glibcpp_function_requires(_Mutable_BidirectionalIteratorConcept<_BI2>);\n+      __glibcpp_function_requires(_ConvertibleConcept<\n+\t    typename iterator_traits<_BI1>::value_type,\n+\t    typename iterator_traits<_BI2>::value_type>);\n+\n+      typedef typename _Is_normal_iterator<_BI1>::_Normal __Normal;\n+      return __copy_backward_input_normal_iterator(__first, __last, __result,\n+\t\t\t\t\t\t   __Normal());\n+    }\n+\n+  //--------------------------------------------------\n+  // copy_n (not part of the C++ standard)\n+\n+  template<typename _InputIter, typename _Size, typename _OutputIter>\n+    pair<_InputIter, _OutputIter>\n+    __copy_n(_InputIter __first, _Size __count,\n+\t     _OutputIter __result,\n+\t     input_iterator_tag)\n+    {\n+      for ( ; __count > 0; --__count) {\n+\t*__result = *__first;\n+\t++__first;\n+\t++__result;\n+      }\n+      return pair<_InputIter, _OutputIter>(__first, __result);\n+    }\n+\n+  template<typename _RAIter, typename _Size, typename _OutputIter>\n+    inline pair<_RAIter, _OutputIter>\n+    __copy_n(_RAIter __first, _Size __count,\n+\t     _OutputIter __result,\n+\t     random_access_iterator_tag)\n+    {\n+      _RAIter __last = __first + __count;\n+      return pair<_RAIter, _OutputIter>(__last, copy(__first, __last, __result));\n+    }\n+\n+  template<typename _InputIter, typename _Size, typename _OutputIter>\n+    inline pair<_InputIter, _OutputIter>\n+    copy_n(_InputIter __first, _Size __count, _OutputIter __result)\n+    {\n+      // concept requirements\n+      __glibcpp_function_requires(_InputIteratorConcept<_InputIter>);\n+      __glibcpp_function_requires(_OutputIteratorConcept<_OutputIter,\n+\t    typename iterator_traits<_InputIter>::value_type>);\n+\n+      return __copy_n(__first, __count, __result, __iterator_category(__first));\n+    }\n+\n+  //--------------------------------------------------\n+  // fill and fill_n\n+\n+\n+  template<typename _ForwardIter, typename _Tp>\n+    void\n+    fill(_ForwardIter __first, _ForwardIter __last, const _Tp& __value)\n+    {\n+      // concept requirements\n+      __glibcpp_function_requires(_Mutable_ForwardIteratorConcept<_ForwardIter>);\n+\n+      for ( ; __first != __last; ++__first)\n+\t*__first = __value;\n+    }\n+\n+  template<typename _OutputIter, typename _Size, typename _Tp>\n+    _OutputIter\n+    fill_n(_OutputIter __first, _Size __n, const _Tp& __value)\n+    {\n+      // concept requirements\n+      __glibcpp_function_requires(_OutputIteratorConcept<_OutputIter,_Tp>);\n+\n+      for ( ; __n > 0; --__n, ++__first)\n+\t*__first = __value;\n+      return __first;\n+    }\n+\n+  // Specialization: for one-byte types we can use memset.\n+\n+  inline void\n+  fill(unsigned char* __first, unsigned char* __last, const unsigned char& __c)\n+  {\n+    unsigned char __tmp = __c;\n+    memset(__first, __tmp, __last - __first);\n   }\n-  return pair<_InputIter, _OutputIter>(__first, __result);\n-}\n-\n-template <class _RAIter, class _Size, class _OutputIter>\n-inline pair<_RAIter, _OutputIter>\n-__copy_n(_RAIter __first, _Size __count,\n-         _OutputIter __result,\n-         random_access_iterator_tag) {\n-  _RAIter __last = __first + __count;\n-  return pair<_RAIter, _OutputIter>(__last, copy(__first, __last, __result));\n-}\n-\n-template <class _InputIter, class _Size, class _OutputIter>\n-inline pair<_InputIter, _OutputIter>\n-__copy_n(_InputIter __first, _Size __count, _OutputIter __result) {\n-  return __copy_n(__first, __count, __result,\n-                  __iterator_category(__first));\n-}\n-\n-template <class _InputIter, class _Size, class _OutputIter>\n-inline pair<_InputIter, _OutputIter>\n-copy_n(_InputIter __first, _Size __count, _OutputIter __result)\n-{\n-  // concept requirements\n-  __glibcpp_function_requires(_InputIteratorConcept<_InputIter>);\n-  __glibcpp_function_requires(_OutputIteratorConcept<_OutputIter,\n-        typename iterator_traits<_InputIter>::value_type>);\n-\n-  return __copy_n(__first, __count, __result);\n-}\n-\n-//--------------------------------------------------\n-// fill and fill_n\n-\n-\n-template <class _ForwardIter, class _Tp>\n-void fill(_ForwardIter __first, _ForwardIter __last, const _Tp& __value)\n-{\n-  // concept requirements\n-  __glibcpp_function_requires(_Mutable_ForwardIteratorConcept<_ForwardIter>);\n-\n-  for ( ; __first != __last; ++__first)\n-    *__first = __value;\n-}\n-\n-template <class _OutputIter, class _Size, class _Tp>\n-_OutputIter fill_n(_OutputIter __first, _Size __n, const _Tp& __value)\n-{\n-  // concept requirements\n-  __glibcpp_function_requires(_OutputIteratorConcept<_OutputIter,_Tp>);\n-\n-  for ( ; __n > 0; --__n, ++__first)\n-    *__first = __value;\n-  return __first;\n-}\n \n-// Specialization: for one-byte types we can use memset.\n-\n-inline void fill(unsigned char* __first, unsigned char* __last,\n-                 const unsigned char& __c)\n-{\n-  unsigned char __tmp = __c;\n-  memset(__first, __tmp, __last - __first);\n-}\n-\n-inline void fill(signed char* __first, signed char* __last,\n-                 const signed char& __c)\n-{\n-  signed char __tmp = __c;\n-  memset(__first, static_cast<unsigned char>(__tmp), __last - __first);\n-}\n-\n-inline void fill(char* __first, char* __last, const char& __c)\n-{\n-  char __tmp = __c;\n-  memset(__first, static_cast<unsigned char>(__tmp), __last - __first);\n-}\n-\n-template <class _Size>\n-inline unsigned char* fill_n(unsigned char* __first, _Size __n,\n-                             const unsigned char& __c)\n-{\n-  fill(__first, __first + __n, __c);\n-  return __first + __n;\n-}\n-\n-template <class _Size>\n-inline signed char* fill_n(char* __first, _Size __n,\n-                           const signed char& __c)\n-{\n-  fill(__first, __first + __n, __c);\n-  return __first + __n;\n-}\n-\n-template <class _Size>\n-inline char* fill_n(char* __first, _Size __n, const char& __c)\n-{\n-  fill(__first, __first + __n, __c);\n-  return __first + __n;\n-}\n-\n-\n-//--------------------------------------------------\n-// equal and mismatch\n-\n-template <class _InputIter1, class _InputIter2>\n-pair<_InputIter1, _InputIter2> mismatch(_InputIter1 __first1,\n-                                        _InputIter1 __last1,\n-                                        _InputIter2 __first2)\n-{\n-  // concept requirements\n-  __glibcpp_function_requires(_InputIteratorConcept<_InputIter1>);\n-  __glibcpp_function_requires(_InputIteratorConcept<_InputIter2>);\n-  __glibcpp_function_requires(_EqualityComparableConcept<\n-        typename iterator_traits<_InputIter1>::value_type>);\n-  __glibcpp_function_requires(_EqualityComparableConcept<\n-        typename iterator_traits<_InputIter2>::value_type>);\n-\n-  while (__first1 != __last1 && *__first1 == *__first2) {\n-    ++__first1;\n-    ++__first2;\n+  inline void\n+  fill(signed char* __first, signed char* __last, const signed char& __c)\n+  {\n+    signed char __tmp = __c;\n+    memset(__first, static_cast<unsigned char>(__tmp), __last - __first);\n   }\n-  return pair<_InputIter1, _InputIter2>(__first1, __first2);\n-}\n-\n-template <class _InputIter1, class _InputIter2, class _BinaryPredicate>\n-pair<_InputIter1, _InputIter2> mismatch(_InputIter1 __first1,\n-                                        _InputIter1 __last1,\n-                                        _InputIter2 __first2,\n-                                        _BinaryPredicate __binary_pred)\n-{\n-  // concept requirements\n-  __glibcpp_function_requires(_InputIteratorConcept<_InputIter1>);\n-  __glibcpp_function_requires(_InputIteratorConcept<_InputIter2>);\n \n-  while (__first1 != __last1 && __binary_pred(*__first1, *__first2)) {\n-    ++__first1;\n-    ++__first2;\n+  inline void\n+  fill(char* __first, char* __last, const char& __c)\n+  {\n+    char __tmp = __c;\n+    memset(__first, static_cast<unsigned char>(__tmp), __last - __first);\n   }\n-  return pair<_InputIter1, _InputIter2>(__first1, __first2);\n-}\n \n-template <class _InputIter1, class _InputIter2>\n-inline bool equal(_InputIter1 __first1, _InputIter1 __last1,\n-                  _InputIter2 __first2)\n-{\n-  // concept requirements\n-  __glibcpp_function_requires(_InputIteratorConcept<_InputIter1>);\n-  __glibcpp_function_requires(_InputIteratorConcept<_InputIter2>);\n-  __glibcpp_function_requires(_EqualOpConcept<\n-        typename iterator_traits<_InputIter1>::value_type,\n-        typename iterator_traits<_InputIter2>::value_type>);\n-\n-  for ( ; __first1 != __last1; ++__first1, ++__first2)\n-    if (!(*__first1 == *__first2))\n-      return false;\n-  return true;\n-}\n-\n-template <class _InputIter1, class _InputIter2, class _BinaryPredicate>\n-inline bool equal(_InputIter1 __first1, _InputIter1 __last1,\n-                  _InputIter2 __first2, _BinaryPredicate __binary_pred)\n-{\n-  // concept requirements\n-  __glibcpp_function_requires(_InputIteratorConcept<_InputIter1>);\n-  __glibcpp_function_requires(_InputIteratorConcept<_InputIter2>);\n-\n-  for ( ; __first1 != __last1; ++__first1, ++__first2)\n-    if (!__binary_pred(*__first1, *__first2))\n-      return false;\n-  return true;\n-}\n-\n-//--------------------------------------------------\n-// lexicographical_compare and lexicographical_compare_3way.\n-// (the latter is not part of the C++ standard.)\n-\n-template <class _InputIter1, class _InputIter2>\n-bool lexicographical_compare(_InputIter1 __first1, _InputIter1 __last1,\n-                             _InputIter2 __first2, _InputIter2 __last2)\n-{\n-  // concept requirements\n-  __glibcpp_function_requires(_InputIteratorConcept<_InputIter1>);\n-  __glibcpp_function_requires(_InputIteratorConcept<_InputIter2>);\n-  __glibcpp_function_requires(_LessThanComparableConcept<\n-        typename iterator_traits<_InputIter1>::value_type>);\n-  __glibcpp_function_requires(_LessThanComparableConcept<\n-        typename iterator_traits<_InputIter2>::value_type>);\n-\n-  for ( ; __first1 != __last1 && __first2 != __last2\n-        ; ++__first1, ++__first2) {\n-    if (*__first1 < *__first2)\n+  template<typename _Size>\n+    inline unsigned char*\n+    fill_n(unsigned char* __first, _Size __n, const unsigned char& __c)\n+    {\n+      fill(__first, __first + __n, __c);\n+      return __first + __n;\n+    }\n+\n+  template<typename _Size>\n+    inline signed char*\n+    fill_n(char* __first, _Size __n, const signed char& __c)\n+    {\n+      fill(__first, __first + __n, __c);\n+      return __first + __n;\n+    }\n+\n+  template<typename _Size>\n+    inline char*\n+    fill_n(char* __first, _Size __n, const char& __c)\n+    {\n+      fill(__first, __first + __n, __c);\n+      return __first + __n;\n+    }\n+\n+\n+  //--------------------------------------------------\n+  // equal and mismatch\n+\n+  template<typename _InputIter1, typename _InputIter2>\n+    pair<_InputIter1, _InputIter2>\n+    mismatch(_InputIter1 __first1, _InputIter1 __last1,\n+\t     _InputIter2 __first2)\n+    {\n+      // concept requirements\n+      __glibcpp_function_requires(_InputIteratorConcept<_InputIter1>);\n+      __glibcpp_function_requires(_InputIteratorConcept<_InputIter2>);\n+      __glibcpp_function_requires(_EqualityComparableConcept<\n+\t    typename iterator_traits<_InputIter1>::value_type>);\n+      __glibcpp_function_requires(_EqualityComparableConcept<\n+\t    typename iterator_traits<_InputIter2>::value_type>);\n+\n+      while (__first1 != __last1 && *__first1 == *__first2) {\n+\t++__first1;\n+\t++__first2;\n+      }\n+      return pair<_InputIter1, _InputIter2>(__first1, __first2);\n+    }\n+\n+  template<typename _InputIter1, typename _InputIter2, typename _BinaryPredicate>\n+    pair<_InputIter1, _InputIter2>\n+    mismatch(_InputIter1 __first1, _InputIter1 __last1,\n+\t     _InputIter2 __first2,\n+\t     _BinaryPredicate __binary_pred)\n+    {\n+      // concept requirements\n+      __glibcpp_function_requires(_InputIteratorConcept<_InputIter1>);\n+      __glibcpp_function_requires(_InputIteratorConcept<_InputIter2>);\n+\n+      while (__first1 != __last1 && __binary_pred(*__first1, *__first2)) {\n+\t++__first1;\n+\t++__first2;\n+      }\n+      return pair<_InputIter1, _InputIter2>(__first1, __first2);\n+    }\n+\n+  template<typename _InputIter1, typename _InputIter2>\n+    inline bool\n+    equal(_InputIter1 __first1, _InputIter1 __last1,\n+\t  _InputIter2 __first2)\n+    {\n+      // concept requirements\n+      __glibcpp_function_requires(_InputIteratorConcept<_InputIter1>);\n+      __glibcpp_function_requires(_InputIteratorConcept<_InputIter2>);\n+      __glibcpp_function_requires(_EqualOpConcept<\n+\t    typename iterator_traits<_InputIter1>::value_type,\n+\t    typename iterator_traits<_InputIter2>::value_type>);\n+\n+      for ( ; __first1 != __last1; ++__first1, ++__first2)\n+\tif (!(*__first1 == *__first2))\n+\t  return false;\n       return true;\n-    if (*__first2 < *__first1)\n-      return false;\n-  }\n-  return __first1 == __last1 && __first2 != __last2;\n-}\n-\n-template <class _InputIter1, class _InputIter2, class _Compare>\n-bool lexicographical_compare(_InputIter1 __first1, _InputIter1 __last1,\n-                             _InputIter2 __first2, _InputIter2 __last2,\n-                             _Compare __comp)\n-{\n-  // concept requirements\n-  __glibcpp_function_requires(_InputIteratorConcept<_InputIter1>);\n-  __glibcpp_function_requires(_InputIteratorConcept<_InputIter2>);\n-\n-  for ( ; __first1 != __last1 && __first2 != __last2\n-        ; ++__first1, ++__first2) {\n-    if (__comp(*__first1, *__first2))\n+    }\n+\n+  template<typename _InputIter1, typename _InputIter2, typename _BinaryPredicate>\n+    inline bool\n+    equal(_InputIter1 __first1, _InputIter1 __last1,\n+\t  _InputIter2 __first2,\n+\t  _BinaryPredicate __binary_pred)\n+    {\n+      // concept requirements\n+      __glibcpp_function_requires(_InputIteratorConcept<_InputIter1>);\n+      __glibcpp_function_requires(_InputIteratorConcept<_InputIter2>);\n+\n+      for ( ; __first1 != __last1; ++__first1, ++__first2)\n+\tif (!__binary_pred(*__first1, *__first2))\n+\t  return false;\n       return true;\n-    if (__comp(*__first2, *__first1))\n-      return false;\n+    }\n+\n+  //--------------------------------------------------\n+  // lexicographical_compare and lexicographical_compare_3way.\n+  // (the latter is not part of the C++ standard.)\n+\n+  template<typename _InputIter1, typename _InputIter2>\n+    bool\n+    lexicographical_compare(_InputIter1 __first1, _InputIter1 __last1,\n+\t\t\t    _InputIter2 __first2, _InputIter2 __last2)\n+    {\n+      // concept requirements\n+      __glibcpp_function_requires(_InputIteratorConcept<_InputIter1>);\n+      __glibcpp_function_requires(_InputIteratorConcept<_InputIter2>);\n+      __glibcpp_function_requires(_LessThanComparableConcept<\n+\t    typename iterator_traits<_InputIter1>::value_type>);\n+      __glibcpp_function_requires(_LessThanComparableConcept<\n+\t    typename iterator_traits<_InputIter2>::value_type>);\n+\n+      for ( ; __first1 != __last1 && __first2 != __last2\n+\t    ; ++__first1, ++__first2) {\n+\tif (*__first1 < *__first2)\n+\t  return true;\n+\tif (*__first2 < *__first1)\n+\t  return false;\n+      }\n+      return __first1 == __last1 && __first2 != __last2;\n+    }\n+\n+  template<typename _InputIter1, typename _InputIter2, typename _Compare>\n+    bool\n+    lexicographical_compare(_InputIter1 __first1, _InputIter1 __last1,\n+\t\t\t    _InputIter2 __first2, _InputIter2 __last2,\n+\t\t\t    _Compare __comp)\n+    {\n+      // concept requirements\n+      __glibcpp_function_requires(_InputIteratorConcept<_InputIter1>);\n+      __glibcpp_function_requires(_InputIteratorConcept<_InputIter2>);\n+\n+      for ( ; __first1 != __last1 && __first2 != __last2\n+\t    ; ++__first1, ++__first2) {\n+\tif (__comp(*__first1, *__first2))\n+\t  return true;\n+\tif (__comp(*__first2, *__first1))\n+\t  return false;\n+      }\n+      return __first1 == __last1 && __first2 != __last2;\n+    }\n+\n+  inline bool \n+  lexicographical_compare(const unsigned char* __first1, const unsigned char* __last1,\n+\t\t\t  const unsigned char* __first2, const unsigned char* __last2)\n+  {\n+    const size_t __len1 = __last1 - __first1;\n+    const size_t __len2 = __last2 - __first2;\n+    const int __result = memcmp(__first1, __first2, min(__len1, __len2));\n+    return __result != 0 ? __result < 0 : __len1 < __len2;\n   }\n-  return __first1 == __last1 && __first2 != __last2;\n-}\n-\n-inline bool \n-lexicographical_compare(const unsigned char* __first1,\n-                        const unsigned char* __last1,\n-                        const unsigned char* __first2,\n-                        const unsigned char* __last2)\n-{\n-  const size_t __len1 = __last1 - __first1;\n-  const size_t __len2 = __last2 - __first2;\n-  const int __result = memcmp(__first1, __first2, min(__len1, __len2));\n-  return __result != 0 ? __result < 0 : __len1 < __len2;\n-}\n-\n-inline bool lexicographical_compare(const char* __first1, const char* __last1,\n-                                    const char* __first2, const char* __last2)\n-{\n+\n+  inline bool\n+  lexicographical_compare(const char* __first1, const char* __last1,\n+\t\t\t  const char* __first2, const char* __last2)\n+  {\n #if CHAR_MAX == SCHAR_MAX\n-  return lexicographical_compare((const signed char*) __first1,\n-                                 (const signed char*) __last1,\n-                                 (const signed char*) __first2,\n-                                 (const signed char*) __last2);\n+    return lexicographical_compare((const signed char*) __first1,\n+\t\t\t\t   (const signed char*) __last1,\n+\t\t\t\t   (const signed char*) __first2,\n+\t\t\t\t   (const signed char*) __last2);\n #else /* CHAR_MAX == SCHAR_MAX */\n-  return lexicographical_compare((const unsigned char*) __first1,\n-                                 (const unsigned char*) __last1,\n-                                 (const unsigned char*) __first2,\n-                                 (const unsigned char*) __last2);\n+    return lexicographical_compare((const unsigned char*) __first1,\n+\t\t\t\t   (const unsigned char*) __last1,\n+\t\t\t\t   (const unsigned char*) __first2,\n+\t\t\t\t   (const unsigned char*) __last2);\n #endif /* CHAR_MAX == SCHAR_MAX */\n-}\n-\n-template <class _InputIter1, class _InputIter2>\n-int __lexicographical_compare_3way(_InputIter1 __first1, _InputIter1 __last1,\n-                                   _InputIter2 __first2, _InputIter2 __last2)\n-{\n-  while (__first1 != __last1 && __first2 != __last2) {\n-    if (*__first1 < *__first2)\n-      return -1;\n-    if (*__first2 < *__first1)\n-      return 1;\n-    ++__first1;\n-    ++__first2;\n-  }\n-  if (__first2 == __last2) {\n-    return !(__first1 == __last1);\n   }\n-  else {\n-    return -1;\n+\n+  template<typename _InputIter1, typename _InputIter2>\n+    int\n+    __lexicographical_compare_3way(_InputIter1 __first1, _InputIter1 __last1,\n+\t\t\t\t   _InputIter2 __first2, _InputIter2 __last2)\n+    {\n+      while (__first1 != __last1 && __first2 != __last2) {\n+\tif (*__first1 < *__first2)\n+\t  return -1;\n+\tif (*__first2 < *__first1)\n+\t  return 1;\n+\t++__first1;\n+\t++__first2;\n+      }\n+      if (__first2 == __last2) {\n+\treturn !(__first1 == __last1);\n+      }\n+      else {\n+\treturn -1;\n+      }\n+    }\n+\n+  inline int\n+  __lexicographical_compare_3way(const unsigned char* __first1,\n+\t\t\t\t const unsigned char* __last1,\n+\t\t\t\t const unsigned char* __first2,\n+\t\t\t\t const unsigned char* __last2)\n+  {\n+    const ptrdiff_t __len1 = __last1 - __first1;\n+    const ptrdiff_t __len2 = __last2 - __first2;\n+    const int __result = memcmp(__first1, __first2, min(__len1, __len2));\n+    return __result != 0 ? __result \n+\t\t\t : (__len1 == __len2 ? 0 : (__len1 < __len2 ? -1 : 1));\n   }\n-}\n \n-inline int\n-__lexicographical_compare_3way(const unsigned char* __first1,\n-                               const unsigned char* __last1,\n-                               const unsigned char* __first2,\n-                               const unsigned char* __last2)\n-{\n-  const ptrdiff_t __len1 = __last1 - __first1;\n-  const ptrdiff_t __len2 = __last2 - __first2;\n-  const int __result = memcmp(__first1, __first2, min(__len1, __len2));\n-  return __result != 0 ? __result \n-                       : (__len1 == __len2 ? 0 : (__len1 < __len2 ? -1 : 1));\n-}\n-\n-inline int \n-__lexicographical_compare_3way(const char* __first1, const char* __last1,\n-                               const char* __first2, const char* __last2)\n-{\n+  inline int \n+  __lexicographical_compare_3way(const char* __first1, const char* __last1,\n+\t\t\t\t const char* __first2, const char* __last2)\n+  {\n #if CHAR_MAX == SCHAR_MAX\n-  return __lexicographical_compare_3way(\n-                                (const signed char*) __first1,\n-                                (const signed char*) __last1,\n-                                (const signed char*) __first2,\n-                                (const signed char*) __last2);\n+    return __lexicographical_compare_3way(\n+\t\t\t\t  (const signed char*) __first1,\n+\t\t\t\t  (const signed char*) __last1,\n+\t\t\t\t  (const signed char*) __first2,\n+\t\t\t\t  (const signed char*) __last2);\n #else\n-  return __lexicographical_compare_3way((const unsigned char*) __first1,\n-                                        (const unsigned char*) __last1,\n-                                        (const unsigned char*) __first2,\n-                                        (const unsigned char*) __last2);\n+    return __lexicographical_compare_3way((const unsigned char*) __first1,\n+\t\t\t\t\t  (const unsigned char*) __last1,\n+\t\t\t\t\t  (const unsigned char*) __first2,\n+\t\t\t\t\t  (const unsigned char*) __last2);\n #endif\n-}\n+  }\n \n-template <class _InputIter1, class _InputIter2>\n-int lexicographical_compare_3way(_InputIter1 __first1, _InputIter1 __last1,\n-                                 _InputIter2 __first2, _InputIter2 __last2)\n-{\n-  // concept requirements\n-  __glibcpp_function_requires(_InputIteratorConcept<_InputIter1>);\n-  __glibcpp_function_requires(_InputIteratorConcept<_InputIter2>);\n-  __glibcpp_function_requires(_LessThanComparableConcept<\n-        typename iterator_traits<_InputIter1>::value_type>);\n-  __glibcpp_function_requires(_LessThanComparableConcept<\n-        typename iterator_traits<_InputIter2>::value_type>);\n-\n-  return __lexicographical_compare_3way(__first1, __last1, __first2, __last2);\n-}\n+  template<typename _InputIter1, typename _InputIter2>\n+    int\n+    lexicographical_compare_3way(_InputIter1 __first1, _InputIter1 __last1,\n+\t\t\t\t _InputIter2 __first2, _InputIter2 __last2)\n+    {\n+      // concept requirements\n+      __glibcpp_function_requires(_InputIteratorConcept<_InputIter1>);\n+      __glibcpp_function_requires(_InputIteratorConcept<_InputIter2>);\n+      __glibcpp_function_requires(_LessThanComparableConcept<\n+\t    typename iterator_traits<_InputIter1>::value_type>);\n+      __glibcpp_function_requires(_LessThanComparableConcept<\n+\t    typename iterator_traits<_InputIter2>::value_type>);\n+\n+      return __lexicographical_compare_3way(__first1, __last1, __first2, __last2);\n+    }\n \n } // namespace std\n "}, {"sha": "eebf2ca3b7e10392a47d01e3ac5b3c65f2fb152e", "filename": "libstdc++-v3/include/bits/stl_heap.h", "status": "modified", "additions": 235, "deletions": 271, "changes": 506, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02d92e3b707a5433814ca22aab53da2d229dc3e1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_heap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02d92e3b707a5433814ca22aab53da2d229dc3e1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_heap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_heap.h?ref=02d92e3b707a5433814ca22aab53da2d229dc3e1", "patch": "@@ -62,277 +62,241 @@\n namespace std\n {\n \n-// Heap-manipulation functions: push_heap, pop_heap, make_heap, sort_heap.\n-\n-template <class _RandomAccessIterator, class _Distance, class _Tp>\n-void \n-__push_heap(_RandomAccessIterator __first,\n-            _Distance __holeIndex, _Distance __topIndex, _Tp __value)\n-{\n-  _Distance __parent = (__holeIndex - 1) / 2;\n-  while (__holeIndex > __topIndex && *(__first + __parent) < __value) {\n-    *(__first + __holeIndex) = *(__first + __parent);\n-    __holeIndex = __parent;\n-    __parent = (__holeIndex - 1) / 2;\n-  }    \n-  *(__first + __holeIndex) = __value;\n-}\n-\n-template <class _RandomAccessIterator, class _Distance, class _Tp>\n-inline void \n-__push_heap_aux(_RandomAccessIterator __first,\n-                _RandomAccessIterator __last, _Distance*, _Tp*)\n-{\n-  __push_heap(__first, _Distance((__last - __first) - 1), _Distance(0), \n-              _Tp(*(__last - 1)));\n-}\n-\n-template <class _RandomAccessIterator>\n-inline void \n-push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n-{\n-  // concept requirements\n-  __glibcpp_function_requires(_Mutable_RandomAccessIteratorConcept<\n-        _RandomAccessIterator>);\n-  __glibcpp_function_requires(_LessThanComparableConcept<\n-        typename iterator_traits<_RandomAccessIterator>::value_type>);\n-\n-  __push_heap_aux(__first, __last,\n-                  __distance_type(__first), __value_type(__first));\n-}\n-\n-template <class _RandomAccessIterator, class _Distance, class _Tp, \n-          class _Compare>\n-void\n-__push_heap(_RandomAccessIterator __first, _Distance __holeIndex,\n-            _Distance __topIndex, _Tp __value, _Compare __comp)\n-{\n-  _Distance __parent = (__holeIndex - 1) / 2;\n-  while (__holeIndex > __topIndex && __comp(*(__first + __parent), __value)) {\n-    *(__first + __holeIndex) = *(__first + __parent);\n-    __holeIndex = __parent;\n-    __parent = (__holeIndex - 1) / 2;\n-  }\n-  *(__first + __holeIndex) = __value;\n-}\n-\n-template <class _RandomAccessIterator, class _Compare,\n-          class _Distance, class _Tp>\n-inline void \n-__push_heap_aux(_RandomAccessIterator __first,\n-                _RandomAccessIterator __last, _Compare __comp,\n-                _Distance*, _Tp*) \n-{\n-  __push_heap(__first, _Distance((__last - __first) - 1), _Distance(0), \n-              _Tp(*(__last - 1)), __comp);\n-}\n-\n-template <class _RandomAccessIterator, class _Compare>\n-inline void \n-push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,\n-          _Compare __comp)\n-{\n-  // concept requirements\n-  __glibcpp_function_requires(_Mutable_RandomAccessIteratorConcept<\n-        _RandomAccessIterator>);\n-\n-  __push_heap_aux(__first, __last, __comp,\n-                  __distance_type(__first), __value_type(__first));\n-}\n-\n-template <class _RandomAccessIterator, class _Distance, class _Tp>\n-void \n-__adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,\n-              _Distance __len, _Tp __value)\n-{\n-  _Distance __topIndex = __holeIndex;\n-  _Distance __secondChild = 2 * __holeIndex + 2;\n-  while (__secondChild < __len) {\n-    if (*(__first + __secondChild) < *(__first + (__secondChild - 1)))\n-      __secondChild--;\n-    *(__first + __holeIndex) = *(__first + __secondChild);\n-    __holeIndex = __secondChild;\n-    __secondChild = 2 * (__secondChild + 1);\n-  }\n-  if (__secondChild == __len) {\n-    *(__first + __holeIndex) = *(__first + (__secondChild - 1));\n-    __holeIndex = __secondChild - 1;\n-  }\n-  __push_heap(__first, __holeIndex, __topIndex, __value);\n-}\n-\n-template <class _RandomAccessIterator, class _Tp, class _Distance>\n-inline void \n-__pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,\n-           _RandomAccessIterator __result, _Tp __value, _Distance*)\n-{\n-  *__result = *__first;\n-  __adjust_heap(__first, _Distance(0), _Distance(__last - __first), __value);\n-}\n-\n-template <class _RandomAccessIterator, class _Tp>\n-inline void \n-__pop_heap_aux(_RandomAccessIterator __first, _RandomAccessIterator __last,\n-               _Tp*)\n-{\n-  __pop_heap(__first, __last - 1, __last - 1, \n-             _Tp(*(__last - 1)), __distance_type(__first));\n-}\n-\n-template <class _RandomAccessIterator>\n-inline void pop_heap(_RandomAccessIterator __first, \n-                     _RandomAccessIterator __last)\n-{\n-  // concept requirements\n-  __glibcpp_function_requires(_Mutable_RandomAccessIteratorConcept<\n-        _RandomAccessIterator>);\n-  __glibcpp_function_requires(_LessThanComparableConcept<\n-        typename iterator_traits<_RandomAccessIterator>::value_type>);\n-\n-  __pop_heap_aux(__first, __last, __value_type(__first));\n-}\n-\n-template <class _RandomAccessIterator, class _Distance,\n-          class _Tp, class _Compare>\n-void\n-__adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,\n-              _Distance __len, _Tp __value, _Compare __comp)\n-{\n-  _Distance __topIndex = __holeIndex;\n-  _Distance __secondChild = 2 * __holeIndex + 2;\n-  while (__secondChild < __len) {\n-    if (__comp(*(__first + __secondChild), *(__first + (__secondChild - 1))))\n-      __secondChild--;\n-    *(__first + __holeIndex) = *(__first + __secondChild);\n-    __holeIndex = __secondChild;\n-    __secondChild = 2 * (__secondChild + 1);\n-  }\n-  if (__secondChild == __len) {\n-    *(__first + __holeIndex) = *(__first + (__secondChild - 1));\n-    __holeIndex = __secondChild - 1;\n-  }\n-  __push_heap(__first, __holeIndex, __topIndex, __value, __comp);\n-}\n-\n-template <class _RandomAccessIterator, class _Tp, class _Compare, \n-          class _Distance>\n-inline void \n-__pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,\n-           _RandomAccessIterator __result, _Tp __value, _Compare __comp,\n-           _Distance*)\n-{\n-  *__result = *__first;\n-  __adjust_heap(__first, _Distance(0), _Distance(__last - __first), \n-                __value, __comp);\n-}\n-\n-template <class _RandomAccessIterator, class _Tp, class _Compare>\n-inline void \n-__pop_heap_aux(_RandomAccessIterator __first,\n-               _RandomAccessIterator __last, _Tp*, _Compare __comp)\n-{\n-  __pop_heap(__first, __last - 1, __last - 1, _Tp(*(__last - 1)), __comp,\n-             __distance_type(__first));\n-}\n-\n-template <class _RandomAccessIterator, class _Compare>\n-inline void \n-pop_heap(_RandomAccessIterator __first,\n-         _RandomAccessIterator __last, _Compare __comp)\n-{\n-  // concept requirements\n-  __glibcpp_function_requires(_Mutable_RandomAccessIteratorConcept<\n-        _RandomAccessIterator>);\n-\n-  __pop_heap_aux(__first, __last, __value_type(__first), __comp);\n-}\n-\n-template <class _RandomAccessIterator, class _Tp, class _Distance>\n-void \n-__make_heap(_RandomAccessIterator __first,\n-            _RandomAccessIterator __last, _Tp*, _Distance*)\n-{\n-  if (__last - __first < 2) return;\n-  _Distance __len = __last - __first;\n-  _Distance __parent = (__len - 2)/2;\n-    \n-  while (true) {\n-    __adjust_heap(__first, __parent, __len, _Tp(*(__first + __parent)));\n-    if (__parent == 0) return;\n-    __parent--;\n-  }\n-}\n-\n-template <class _RandomAccessIterator>\n-inline void \n-make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n-{\n-  // concept requirements\n-  __glibcpp_function_requires(_Mutable_RandomAccessIteratorConcept<\n-        _RandomAccessIterator>);\n-  __glibcpp_function_requires(_LessThanComparableConcept<\n-        typename iterator_traits<_RandomAccessIterator>::value_type>);\n-\n-  __make_heap(__first, __last,\n-              __value_type(__first), __distance_type(__first));\n-}\n-\n-template <class _RandomAccessIterator, class _Compare,\n-          class _Tp, class _Distance>\n-void\n-__make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,\n-            _Compare __comp, _Tp*, _Distance*)\n-{\n-  if (__last - __first < 2) return;\n-  _Distance __len = __last - __first;\n-  _Distance __parent = (__len - 2)/2;\n-    \n-  while (true) {\n-    __adjust_heap(__first, __parent, __len, _Tp(*(__first + __parent)),\n-                  __comp);\n-    if (__parent == 0) return;\n-    __parent--;\n-  }\n-}\n-\n-template <class _RandomAccessIterator, class _Compare>\n-inline void \n-make_heap(_RandomAccessIterator __first, \n-          _RandomAccessIterator __last, _Compare __comp)\n-{\n-  // concept requirements\n-  __glibcpp_function_requires(_Mutable_RandomAccessIteratorConcept<\n-        _RandomAccessIterator>);\n-\n-  __make_heap(__first, __last, __comp,\n-              __value_type(__first), __distance_type(__first));\n-}\n-\n-template <class _RandomAccessIterator>\n-void sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n-{\n-  // concept requirements\n-  __glibcpp_function_requires(_Mutable_RandomAccessIteratorConcept<\n-        _RandomAccessIterator>);\n-  __glibcpp_function_requires(_LessThanComparableConcept<\n-        typename iterator_traits<_RandomAccessIterator>::value_type>);\n-\n-  while (__last - __first > 1)\n-    pop_heap(__first, __last--);\n-}\n-\n-template <class _RandomAccessIterator, class _Compare>\n-void \n-sort_heap(_RandomAccessIterator __first,\n-          _RandomAccessIterator __last, _Compare __comp)\n-{\n-  // concept requirements\n-  __glibcpp_function_requires(_Mutable_RandomAccessIteratorConcept<\n-        _RandomAccessIterator>);\n-\n-  while (__last - __first > 1)\n-    pop_heap(__first, __last--, __comp);\n-}\n+  // Heap-manipulation functions: push_heap, pop_heap, make_heap, sort_heap.\n+\n+  template<typename _RandomAccessIterator, typename _Distance, typename _Tp>\n+    void \n+    __push_heap(_RandomAccessIterator __first,\n+\t\t_Distance __holeIndex, _Distance __topIndex, _Tp __value)\n+    {\n+      _Distance __parent = (__holeIndex - 1) / 2;\n+      while (__holeIndex > __topIndex && *(__first + __parent) < __value) {\n+\t*(__first + __holeIndex) = *(__first + __parent);\n+\t__holeIndex = __parent;\n+\t__parent = (__holeIndex - 1) / 2;\n+      }    \n+      *(__first + __holeIndex) = __value;\n+    }\n+\n+  template<typename _RandomAccessIterator>\n+    inline void \n+    push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n+    {\n+      typedef typename iterator_traits<_RandomAccessIterator>::value_type\n+\t  _ValueType;\n+      typedef typename iterator_traits<_RandomAccessIterator>::difference_type\n+\t  _DistanceType;\n+\n+      // concept requirements\n+      __glibcpp_function_requires(_Mutable_RandomAccessIteratorConcept<\n+\t    _RandomAccessIterator>);\n+      __glibcpp_function_requires(_LessThanComparableConcept<_ValueType>);\n+\n+      __push_heap(__first, _DistanceType((__last - __first) - 1), _DistanceType(0), \n+\t\t  _ValueType(*(__last - 1)));\n+    }\n+\n+  template<typename _RandomAccessIterator, typename _Distance, typename _Tp, \n+\t    typename _Compare>\n+    void\n+    __push_heap(_RandomAccessIterator __first, _Distance __holeIndex,\n+\t\t_Distance __topIndex, _Tp __value, _Compare __comp)\n+    {\n+      _Distance __parent = (__holeIndex - 1) / 2;\n+      while (__holeIndex > __topIndex && __comp(*(__first + __parent), __value)) {\n+\t*(__first + __holeIndex) = *(__first + __parent);\n+\t__holeIndex = __parent;\n+\t__parent = (__holeIndex - 1) / 2;\n+      }\n+      *(__first + __holeIndex) = __value;\n+    }\n+\n+  template<typename _RandomAccessIterator, typename _Compare>\n+    inline void \n+    push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,\n+\t      _Compare __comp)\n+    {\n+      typedef typename iterator_traits<_RandomAccessIterator>::value_type\n+\t  _ValueType;\n+      typedef typename iterator_traits<_RandomAccessIterator>::difference_type\n+\t  _DistanceType;\n+\n+      // concept requirements\n+      __glibcpp_function_requires(_Mutable_RandomAccessIteratorConcept<\n+\t    _RandomAccessIterator>);\n+\n+      __push_heap(__first, _DistanceType((__last - __first) - 1), _DistanceType(0), \n+\t\t  _ValueType(*(__last - 1)), __comp);\n+    }\n+\n+  template<typename _RandomAccessIterator, typename _Distance, typename _Tp>\n+    void \n+    __adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,\n+\t\t  _Distance __len, _Tp __value)\n+    {\n+      _Distance __topIndex = __holeIndex;\n+      _Distance __secondChild = 2 * __holeIndex + 2;\n+      while (__secondChild < __len) {\n+\tif (*(__first + __secondChild) < *(__first + (__secondChild - 1)))\n+\t  __secondChild--;\n+\t*(__first + __holeIndex) = *(__first + __secondChild);\n+\t__holeIndex = __secondChild;\n+\t__secondChild = 2 * (__secondChild + 1);\n+      }\n+      if (__secondChild == __len) {\n+\t*(__first + __holeIndex) = *(__first + (__secondChild - 1));\n+\t__holeIndex = __secondChild - 1;\n+      }\n+      __push_heap(__first, __holeIndex, __topIndex, __value);\n+    }\n+\n+  template<typename _RandomAccessIterator, typename _Tp>\n+    inline void \n+    __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,\n+\t       _RandomAccessIterator __result, _Tp __value)\n+    {\n+      typedef typename iterator_traits<_RandomAccessIterator>::difference_type _Distance;\n+      *__result = *__first;\n+      __adjust_heap(__first, _Distance(0), _Distance(__last - __first), __value);\n+    }\n+\n+  template<typename _RandomAccessIterator>\n+    inline void\n+    pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n+    {\n+      typedef typename iterator_traits<_RandomAccessIterator>::value_type _ValueType;\n+\n+      // concept requirements\n+      __glibcpp_function_requires(_Mutable_RandomAccessIteratorConcept<\n+\t    _RandomAccessIterator>);\n+      __glibcpp_function_requires(_LessThanComparableConcept<_ValueType>);\n+\n+      __pop_heap(__first, __last - 1, __last - 1, _ValueType(*(__last - 1)));\n+    }\n+\n+  template<typename _RandomAccessIterator, typename _Distance,\n+\t   typename _Tp, typename _Compare>\n+    void\n+    __adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,\n+\t\t  _Distance __len, _Tp __value, _Compare __comp)\n+    {\n+      _Distance __topIndex = __holeIndex;\n+      _Distance __secondChild = 2 * __holeIndex + 2;\n+      while (__secondChild < __len) {\n+\tif (__comp(*(__first + __secondChild), *(__first + (__secondChild - 1))))\n+\t  __secondChild--;\n+\t*(__first + __holeIndex) = *(__first + __secondChild);\n+\t__holeIndex = __secondChild;\n+\t__secondChild = 2 * (__secondChild + 1);\n+      }\n+      if (__secondChild == __len) {\n+\t*(__first + __holeIndex) = *(__first + (__secondChild - 1));\n+\t__holeIndex = __secondChild - 1;\n+      }\n+      __push_heap(__first, __holeIndex, __topIndex, __value, __comp);\n+    }\n+\n+  template<typename _RandomAccessIterator, typename _Tp, typename _Compare>\n+    inline void \n+    __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,\n+\t       _RandomAccessIterator __result, _Tp __value, _Compare __comp)\n+    {\n+      typedef typename iterator_traits<_RandomAccessIterator>::difference_type _Distance;\n+      *__result = *__first;\n+      __adjust_heap(__first, _Distance(0), _Distance(__last - __first), \n+\t\t    __value, __comp);\n+    }\n+\n+  template<typename _RandomAccessIterator, typename _Compare>\n+    inline void \n+    pop_heap(_RandomAccessIterator __first,\n+\t     _RandomAccessIterator __last, _Compare __comp)\n+    {\n+      // concept requirements\n+      __glibcpp_function_requires(_Mutable_RandomAccessIteratorConcept<\n+\t    _RandomAccessIterator>);\n+\n+      typedef typename iterator_traits<_RandomAccessIterator>::value_type _ValueType;\n+      __pop_heap(__first, __last - 1, __last - 1, _ValueType(*(__last - 1)), __comp);\n+    }\n+\n+  template<typename _RandomAccessIterator>\n+    void \n+    make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n+    {\n+      typedef typename iterator_traits<_RandomAccessIterator>::value_type\n+\t  _ValueType;\n+      typedef typename iterator_traits<_RandomAccessIterator>::difference_type\n+\t  _DistanceType;\n+\n+      // concept requirements\n+      __glibcpp_function_requires(_Mutable_RandomAccessIteratorConcept<\n+\t    _RandomAccessIterator>);\n+      __glibcpp_function_requires(_LessThanComparableConcept<_ValueType>);\n+\n+      if (__last - __first < 2) return;\n+      _DistanceType __len = __last - __first;\n+      _DistanceType __parent = (__len - 2)/2;\n+\t\n+      while (true) {\n+\t__adjust_heap(__first, __parent, __len, _ValueType(*(__first + __parent)));\n+\tif (__parent == 0) return;\n+\t__parent--;\n+      }\n+    }\n+\n+  template<typename _RandomAccessIterator, typename _Compare>\n+    inline void \n+    make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,\n+\t      _Compare __comp)\n+    {\n+      typedef typename iterator_traits<_RandomAccessIterator>::value_type\n+\t  _ValueType;\n+      typedef typename iterator_traits<_RandomAccessIterator>::difference_type\n+\t  _DistanceType;\n+\n+      // concept requirements\n+      __glibcpp_function_requires(_Mutable_RandomAccessIteratorConcept<\n+\t    _RandomAccessIterator>);\n+\n+      if (__last - __first < 2) return;\n+      _DistanceType __len = __last - __first;\n+      _DistanceType __parent = (__len - 2)/2;\n+\t\n+      while (true) {\n+\t__adjust_heap(__first, __parent, __len,\n+\t              _ValueType(*(__first + __parent)), __comp);\n+\tif (__parent == 0) return;\n+\t__parent--;\n+      }\n+    }\n+\n+  template<typename _RandomAccessIterator>\n+    void\n+    sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n+    {\n+      // concept requirements\n+      __glibcpp_function_requires(_Mutable_RandomAccessIteratorConcept<\n+\t    _RandomAccessIterator>);\n+      __glibcpp_function_requires(_LessThanComparableConcept<\n+\t    typename iterator_traits<_RandomAccessIterator>::value_type>);\n+\n+      while (__last - __first > 1)\n+\tpop_heap(__first, __last--);\n+    }\n+\n+  template<typename _RandomAccessIterator, typename _Compare>\n+    void \n+    sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,\n+\t      _Compare __comp)\n+    {\n+      // concept requirements\n+      __glibcpp_function_requires(_Mutable_RandomAccessIteratorConcept<\n+\t    _RandomAccessIterator>);\n+\n+      while (__last - __first > 1)\n+\tpop_heap(__first, __last--, __comp);\n+    }\n \n } // namespace std\n "}, {"sha": "97eb8b5208db4701c17df6390de99981b06f3d90", "filename": "libstdc++-v3/include/bits/stl_iterator_base_funcs.h", "status": "modified", "additions": 101, "deletions": 99, "changes": 200, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02d92e3b707a5433814ca22aab53da2d229dc3e1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_iterator_base_funcs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02d92e3b707a5433814ca22aab53da2d229dc3e1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_iterator_base_funcs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_iterator_base_funcs.h?ref=02d92e3b707a5433814ca22aab53da2d229dc3e1", "patch": "@@ -71,105 +71,107 @@\n namespace std\n {\n \n-// There are two signatures for distance.  In addition to the one taking\n-// two iterators and returning a result, there is another taking two\n-// iterators and a reference-to-result variable, and returning nothing.\n-// The latter seems to be an SGI extension.   -- pedwards\n-template <class _InputIterator, class _Distance>\n-inline void __distance(_InputIterator __first, _InputIterator __last,\n-                       _Distance& __n, input_iterator_tag)\n-{\n-  // concept requirements\n-  __glibcpp_function_requires(_InputIteratorConcept<_InputIterator>);\n-  while (__first != __last) { ++__first; ++__n; }\n-}\n-\n-template <class _RandomAccessIterator, class _Distance>\n-inline void __distance(_RandomAccessIterator __first, \n-                       _RandomAccessIterator __last, \n-                       _Distance& __n, random_access_iterator_tag)\n-{\n-  // concept requirements\n-  __glibcpp_function_requires(_RandomAccessIteratorConcept<_RandomAccessIterator>);\n-  __n += __last - __first;\n-}\n-\n-template <class _InputIterator, class _Distance>\n-inline void distance(_InputIterator __first, \n-                     _InputIterator __last, _Distance& __n)\n-{\n-  // concept requirements -- taken care of in __distance\n-  __distance(__first, __last, __n, iterator_category(__first));\n-}\n-\n-template <class _InputIterator>\n-inline typename iterator_traits<_InputIterator>::difference_type\n-__distance(_InputIterator __first, _InputIterator __last, input_iterator_tag)\n-{\n-  // concept requirements\n-  __glibcpp_function_requires(_InputIteratorConcept<_InputIterator>);\n-  typename iterator_traits<_InputIterator>::difference_type __n = 0;\n-  while (__first != __last) {\n-    ++__first; ++__n;\n-  }\n-  return __n;\n-}\n-\n-template <class _RandomAccessIterator>\n-inline typename iterator_traits<_RandomAccessIterator>::difference_type\n-__distance(_RandomAccessIterator __first, _RandomAccessIterator __last,\n-           random_access_iterator_tag)\n-{\n-  // concept requirements\n-  __glibcpp_function_requires(_RandomAccessIteratorConcept<_RandomAccessIterator>);\n-  return __last - __first;\n-}\n-\n-template <class _InputIterator>\n-inline typename iterator_traits<_InputIterator>::difference_type\n-distance(_InputIterator __first, _InputIterator __last)\n-{\n-  // concept requirements -- taken care of in __distance\n-  typedef typename iterator_traits<_InputIterator>::iterator_category \n-    _Category;\n-  return __distance(__first, __last, _Category());\n-}\n-\n-template <class _InputIter, class _Distance>\n-inline void __advance(_InputIter& __i, _Distance __n, input_iterator_tag)\n-{\n-  // concept requirements\n-  __glibcpp_function_requires(_InputIteratorConcept<_InputIter>);\n-  while (__n--) ++__i;\n-}\n-\n-template <class _BidirectionalIterator, class _Distance>\n-inline void __advance(_BidirectionalIterator& __i, _Distance __n, \n-                      bidirectional_iterator_tag)\n-{\n-  // concept requirements\n-__glibcpp_function_requires(_BidirectionalIteratorConcept<_BidirectionalIterator>);\n-  if (__n > 0)\n-    while (__n--) ++__i;\n-  else\n-    while (__n++) --__i;\n-}\n-\n-template <class _RandomAccessIterator, class _Distance>\n-inline void __advance(_RandomAccessIterator& __i, _Distance __n, \n-                      random_access_iterator_tag)\n-{\n-  // concept requirements\n-  __glibcpp_function_requires(_RandomAccessIteratorConcept<_RandomAccessIterator>);\n-  __i += __n;\n-}\n-\n-template <class _InputIterator, class _Distance>\n-inline void advance(_InputIterator& __i, _Distance __n)\n-{\n-  // concept requirements -- taken care of in __advance\n-  __advance(__i, __n, iterator_category(__i));\n-}\n+  // There are two signatures for distance.  In addition to the one taking\n+  // two iterators and returning a result, there is another taking two\n+  // iterators and a reference-to-result variable, and returning nothing.\n+  // The latter seems to be an SGI extension.   -- pedwards\n+  template<typename _InputIterator, typename _Distance>\n+    inline void\n+    __distance(_InputIterator __first, _InputIterator __last,\n+\t       _Distance& __n, input_iterator_tag)\n+    {\n+      // concept requirements\n+      __glibcpp_function_requires(_InputIteratorConcept<_InputIterator>);\n+      while (__first != __last) { ++__first; ++__n; }\n+    }\n+\n+  template<typename _RandomAccessIterator, typename _Distance>\n+    inline void\n+    __distance(_RandomAccessIterator __first, _RandomAccessIterator __last, \n+\t       _Distance& __n, random_access_iterator_tag)\n+    {\n+      // concept requirements\n+      __glibcpp_function_requires(_RandomAccessIteratorConcept<_RandomAccessIterator>);\n+      __n += __last - __first;\n+    }\n+\n+  template<typename _InputIterator, typename _Distance>\n+    inline void\n+    distance(_InputIterator __first, _InputIterator __last,\n+             _Distance& __n)\n+    {\n+      // concept requirements -- taken care of in __distance\n+      __distance(__first, __last, __n, __iterator_category(__first));\n+    }\n+\n+  template<typename _InputIterator>\n+    inline typename iterator_traits<_InputIterator>::difference_type\n+    __distance(_InputIterator __first, _InputIterator __last, input_iterator_tag)\n+    {\n+      // concept requirements\n+      __glibcpp_function_requires(_InputIteratorConcept<_InputIterator>);\n+      typename iterator_traits<_InputIterator>::difference_type __n = 0;\n+      while (__first != __last) {\n+\t++__first; ++__n;\n+      }\n+      return __n;\n+    }\n+\n+  template<typename _RandomAccessIterator>\n+    inline typename iterator_traits<_RandomAccessIterator>::difference_type\n+    __distance(_RandomAccessIterator __first, _RandomAccessIterator __last,\n+\t\t\t   random_access_iterator_tag)\n+    {\n+      // concept requirements\n+      __glibcpp_function_requires(_RandomAccessIteratorConcept<_RandomAccessIterator>);\n+      return __last - __first;\n+    }\n+\n+  template<typename _InputIterator>\n+    inline typename iterator_traits<_InputIterator>::difference_type\n+    distance(_InputIterator __first, _InputIterator __last)\n+    {\n+      // concept requirements -- taken care of in __distance\n+      return __distance(__first, __last, __iterator_category(__first));\n+    }\n+\n+  template<typename _InputIter, typename _Distance>\n+    inline void\n+    __advance(_InputIter& __i, _Distance __n, input_iterator_tag)\n+    {\n+      // concept requirements\n+      __glibcpp_function_requires(_InputIteratorConcept<_InputIter>);\n+      while (__n--) ++__i;\n+    }\n+\n+  template<typename _BidirectionalIterator, typename _Distance>\n+    inline void\n+    __advance(_BidirectionalIterator& __i, _Distance __n, bidirectional_iterator_tag)\n+    {\n+      // concept requirements\n+      __glibcpp_function_requires(_BidirectionalIteratorConcept<_BidirectionalIterator>);\n+      if (__n > 0)\n+\twhile (__n--) ++__i;\n+      else\n+\twhile (__n++) --__i;\n+    }\n+\n+  template<typename _RandomAccessIterator, typename _Distance>\n+    inline void\n+    __advance(_RandomAccessIterator& __i, _Distance __n, random_access_iterator_tag)\n+    {\n+      // concept requirements\n+      __glibcpp_function_requires(_RandomAccessIteratorConcept<_RandomAccessIterator>);\n+      __i += __n;\n+    }\n+\n+  template<typename _InputIterator, typename _Distance>\n+    inline void\n+    advance(_InputIterator& __i, _Distance __n)\n+    {\n+      // concept requirements -- taken care of in __advance\n+      __advance(__i, __n, __iterator_category(__i));\n+    }\n \n } // namespace std\n "}, {"sha": "bb6b8ead924baded5a05191c485cec1093916e02", "filename": "libstdc++-v3/include/bits/stl_iterator_base_types.h", "status": "modified", "additions": 99, "deletions": 133, "changes": 232, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02d92e3b707a5433814ca22aab53da2d229dc3e1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_iterator_base_types.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02d92e3b707a5433814ca22aab53da2d229dc3e1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_iterator_base_types.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_iterator_base_types.h?ref=02d92e3b707a5433814ca22aab53da2d229dc3e1", "patch": "@@ -67,142 +67,108 @@\n \n #pragma GCC system_header\n \n-#include <bits/std_cstddef.h>     // for ptrdiff_t\n-\n-\n namespace std\n {\n \n-struct input_iterator_tag {};\n-struct output_iterator_tag {};\n-struct forward_iterator_tag : public input_iterator_tag {};\n-struct bidirectional_iterator_tag : public forward_iterator_tag {};\n-struct random_access_iterator_tag : public bidirectional_iterator_tag {};\n-\n-// The base classes input_iterator, output_iterator, forward_iterator,\n-// bidirectional_iterator, and random_access_iterator are not part of\n-// the C++ standard.  (They have been replaced by struct iterator.)\n-// They are included for backward compatibility with the HP STL.\n-\n-template <class _Tp, class _Distance> struct input_iterator {\n-  typedef input_iterator_tag iterator_category;\n-  typedef _Tp                value_type;\n-  typedef _Distance          difference_type;\n-  typedef _Tp*               pointer;\n-  typedef _Tp&               reference;\n-};\n-\n-struct output_iterator {\n-  typedef output_iterator_tag iterator_category;\n-  typedef void                value_type;\n-  typedef void                difference_type;\n-  typedef void                pointer;\n-  typedef void                reference;\n-};\n-\n-template <class _Tp, class _Distance> struct forward_iterator {\n-  typedef forward_iterator_tag iterator_category;\n-  typedef _Tp                  value_type;\n-  typedef _Distance            difference_type;\n-  typedef _Tp*                 pointer;\n-  typedef _Tp&                 reference;\n-};\n-\n-\n-template <class _Tp, class _Distance> struct bidirectional_iterator {\n-  typedef bidirectional_iterator_tag iterator_category;\n-  typedef _Tp                        value_type;\n-  typedef _Distance                  difference_type;\n-  typedef _Tp*                       pointer;\n-  typedef _Tp&                       reference;\n-};\n-\n-template <class _Tp, class _Distance> struct random_access_iterator {\n-  typedef random_access_iterator_tag iterator_category;\n-  typedef _Tp                        value_type;\n-  typedef _Distance                  difference_type;\n-  typedef _Tp*                       pointer;\n-  typedef _Tp&                       reference;\n-};\n-\n-template <class _Category, class _Tp, class _Distance = ptrdiff_t,\n-          class _Pointer = _Tp*, class _Reference = _Tp&>\n-struct iterator {\n-  typedef _Category  iterator_category;\n-  typedef _Tp        value_type;\n-  typedef _Distance  difference_type;\n-  typedef _Pointer   pointer;\n-  typedef _Reference reference;\n-};\n-\n-template <class _Iterator>\n-struct iterator_traits {\n-  typedef typename _Iterator::iterator_category iterator_category;\n-  typedef typename _Iterator::value_type        value_type;\n-  typedef typename _Iterator::difference_type   difference_type;\n-  typedef typename _Iterator::pointer           pointer;\n-  typedef typename _Iterator::reference         reference;\n-};\n-\n-template <class _Tp>\n-struct iterator_traits<_Tp*> {\n-  typedef random_access_iterator_tag iterator_category;\n-  typedef _Tp                         value_type;\n-  typedef ptrdiff_t                   difference_type;\n-  typedef _Tp*                        pointer;\n-  typedef _Tp&                        reference;\n-};\n-\n-template <class _Tp>\n-struct iterator_traits<const _Tp*> {\n-  typedef random_access_iterator_tag iterator_category;\n-  typedef _Tp                         value_type;\n-  typedef ptrdiff_t                   difference_type;\n-  typedef const _Tp*                  pointer;\n-  typedef const _Tp&                  reference;\n-};\n-\n-// The overloaded functions iterator_category, distance_type, and\n-// value_type are not part of the C++ standard.  (They have been\n-// replaced by struct iterator_traits.)  They are included for\n-// backward compatibility with the HP STL.\n-\n-// We introduce internal names for these functions.\n-\n-template <class _Iter>\n-inline typename iterator_traits<_Iter>::iterator_category\n-__iterator_category(const _Iter&)\n-{\n-  typedef typename iterator_traits<_Iter>::iterator_category _Category;\n-  return _Category();\n-}\n-\n-template <class _Iter>\n-inline typename iterator_traits<_Iter>::difference_type*\n-__distance_type(const _Iter&)\n-{\n-  return static_cast<typename iterator_traits<_Iter>::difference_type*>(0);\n-}\n-\n-template <class _Iter>\n-inline typename iterator_traits<_Iter>::value_type*\n-__value_type(const _Iter&)\n-{\n-  return static_cast<typename iterator_traits<_Iter>::value_type*>(0);\n-}\n-\n-template <class _Iter>\n-inline typename iterator_traits<_Iter>::iterator_category\n-iterator_category(const _Iter& __i) { return __iterator_category(__i); }\n-\n-\n-template <class _Iter>\n-inline typename iterator_traits<_Iter>::difference_type*\n-distance_type(const _Iter& __i) { return __distance_type(__i); }\n-\n-template <class _Iter>\n-inline typename iterator_traits<_Iter>::value_type*\n-value_type(const _Iter& __i) { return __value_type(__i); }\n+  struct input_iterator_tag {};\n+  struct output_iterator_tag {};\n+  struct forward_iterator_tag : public input_iterator_tag {};\n+  struct bidirectional_iterator_tag : public forward_iterator_tag {};\n+  struct random_access_iterator_tag : public bidirectional_iterator_tag {};\n+\n+  // The base classes input_iterator, output_iterator, forward_iterator,\n+  // bidirectional_iterator, and random_access_iterator are not part of\n+  // the C++ standard.  (They have been replaced by struct iterator.)\n+  // They are included for backward compatibility with the HP STL.\n+\n+  template<typename _Tp, typename _Distance>\n+    struct input_iterator {\n+      typedef input_iterator_tag iterator_category;\n+      typedef _Tp                value_type;\n+      typedef _Distance          difference_type;\n+      typedef _Tp*               pointer;\n+      typedef _Tp&               reference;\n+    };\n+\n+  struct output_iterator {\n+    typedef output_iterator_tag iterator_category;\n+    typedef void                value_type;\n+    typedef void                difference_type;\n+    typedef void                pointer;\n+    typedef void                reference;\n+  };\n+\n+  template<typename _Tp, typename _Distance>\n+    struct forward_iterator {\n+      typedef forward_iterator_tag iterator_category;\n+      typedef _Tp                  value_type;\n+      typedef _Distance            difference_type;\n+      typedef _Tp*                 pointer;\n+      typedef _Tp&                 reference;\n+    };\n+\n+  template<typename _Tp, typename _Distance>\n+    struct bidirectional_iterator {\n+      typedef bidirectional_iterator_tag iterator_category;\n+      typedef _Tp                        value_type;\n+      typedef _Distance                  difference_type;\n+      typedef _Tp*                       pointer;\n+      typedef _Tp&                       reference;\n+    };\n+\n+  template<typename _Tp, typename _Distance>\n+    struct random_access_iterator {\n+      typedef random_access_iterator_tag iterator_category;\n+      typedef _Tp                        value_type;\n+      typedef _Distance                  difference_type;\n+      typedef _Tp*                       pointer;\n+      typedef _Tp&                       reference;\n+    };\n+\n+  template<typename _Category, typename _Tp, typename _Distance = ptrdiff_t,\n+\t   typename _Pointer = _Tp*, typename _Reference = _Tp&>\n+    struct iterator {\n+      typedef _Category  iterator_category;\n+      typedef _Tp        value_type;\n+      typedef _Distance  difference_type;\n+      typedef _Pointer   pointer;\n+      typedef _Reference reference;\n+    };\n+\n+  template<typename _Iterator>\n+    struct iterator_traits {\n+      typedef typename _Iterator::iterator_category iterator_category;\n+      typedef typename _Iterator::value_type        value_type;\n+      typedef typename _Iterator::difference_type   difference_type;\n+      typedef typename _Iterator::pointer           pointer;\n+      typedef typename _Iterator::reference         reference;\n+    };\n+\n+  template<typename _Tp>\n+    struct iterator_traits<_Tp*> {\n+      typedef random_access_iterator_tag iterator_category;\n+      typedef _Tp                         value_type;\n+      typedef ptrdiff_t                   difference_type;\n+      typedef _Tp*                        pointer;\n+      typedef _Tp&                        reference;\n+    };\n+\n+  template<typename _Tp>\n+    struct iterator_traits<const _Tp*> {\n+      typedef random_access_iterator_tag iterator_category;\n+      typedef _Tp                         value_type;\n+      typedef ptrdiff_t                   difference_type;\n+      typedef const _Tp*                  pointer;\n+      typedef const _Tp&                  reference;\n+    };\n+\n+  // This function is not a part of the C++ standard but is syntactic\n+  // sugar for internal library use only.\n+\n+  template<typename _Iter>\n+    inline typename iterator_traits<_Iter>::iterator_category\n+    __iterator_category(const _Iter&)\n+    { return typename iterator_traits<_Iter>::iterator_category(); }\n \n } // namespace std\n "}, {"sha": "868143189c8abeebc27d5fd40ca21e47a9f3423b", "filename": "libstdc++-v3/include/bits/stl_numeric.h", "status": "modified", "additions": 191, "deletions": 223, "changes": 414, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02d92e3b707a5433814ca22aab53da2d229dc3e1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_numeric.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02d92e3b707a5433814ca22aab53da2d229dc3e1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_numeric.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_numeric.h?ref=02d92e3b707a5433814ca22aab53da2d229dc3e1", "patch": "@@ -64,240 +64,208 @@\n namespace std\n {\n \n-template <class _InputIterator, class _Tp>\n-_Tp accumulate(_InputIterator __first, _InputIterator __last, _Tp __init)\n-{\n-  // concept requirements\n-  __glibcpp_function_requires(_InputIteratorConcept<_InputIterator>);\n-\n-  for ( ; __first != __last; ++__first)\n-    __init = __init + *__first;\n-  return __init;\n-}\n-\n-template <class _InputIterator, class _Tp, class _BinaryOperation>\n-_Tp accumulate(_InputIterator __first, _InputIterator __last, _Tp __init,\n-              _BinaryOperation __binary_op)\n-{\n-  // concept requirements\n-  __glibcpp_function_requires(_InputIteratorConcept<_InputIterator>);\n+  template<typename _InputIterator, typename _Tp>\n+    _Tp\n+    accumulate(_InputIterator __first, _InputIterator __last, _Tp __init)\n+    {\n+      // concept requirements\n+      __glibcpp_function_requires(_InputIteratorConcept<_InputIterator>);\n+\n+      for ( ; __first != __last; ++__first)\n+\t__init = __init + *__first;\n+      return __init;\n+    }\n \n-  for ( ; __first != __last; ++__first)\n-    __init = __binary_op(__init, *__first);\n-  return __init;\n-}\n+  template<typename _InputIterator, typename _Tp, typename _BinaryOperation>\n+    _Tp\n+    accumulate(_InputIterator __first, _InputIterator __last, _Tp __init,\n+\t       _BinaryOperation __binary_op)\n+    {\n+      // concept requirements\n+      __glibcpp_function_requires(_InputIteratorConcept<_InputIterator>);\n+\n+      for ( ; __first != __last; ++__first)\n+\t__init = __binary_op(__init, *__first);\n+      return __init;\n+    }\n \n-template <class _InputIterator1, class _InputIterator2, class _Tp>\n-_Tp inner_product(_InputIterator1 __first1, _InputIterator1 __last1,\n-                 _InputIterator2 __first2, _Tp __init)\n-{\n-  // concept requirements\n-  __glibcpp_function_requires(_InputIteratorConcept<_InputIterator1>);\n-  __glibcpp_function_requires(_InputIteratorConcept<_InputIterator2>);\n-\n-  for ( ; __first1 != __last1; ++__first1, ++__first2)\n-    __init = __init + (*__first1 * *__first2);\n-  return __init;\n-}\n-\n-template <class _InputIterator1, class _InputIterator2, class _Tp,\n-          class _BinaryOperation1, class _BinaryOperation2>\n-_Tp inner_product(_InputIterator1 __first1, _InputIterator1 __last1,\n-                 _InputIterator2 __first2, _Tp __init, \n-                 _BinaryOperation1 __binary_op1,\n-                 _BinaryOperation2 __binary_op2)\n-{\n-  // concept requirements\n-  __glibcpp_function_requires(_InputIteratorConcept<_InputIterator1>);\n-  __glibcpp_function_requires(_InputIteratorConcept<_InputIterator2>);\n-\n-  for ( ; __first1 != __last1; ++__first1, ++__first2)\n-    __init = __binary_op1(__init, __binary_op2(*__first1, *__first2));\n-  return __init;\n-}\n-\n-template <class _InputIterator, class _OutputIterator, class _Tp>\n-_OutputIterator \n-__partial_sum(_InputIterator __first, _InputIterator __last,\n-              _OutputIterator __result, _Tp*)\n-{\n-  _Tp __value = *__first;\n-  while (++__first != __last) {\n-    __value = __value + *__first;\n-    *++__result = __value;\n-  }\n-  return ++__result;\n-}\n-\n-template <class _InputIterator, class _OutputIterator>\n-_OutputIterator \n-partial_sum(_InputIterator __first, _InputIterator __last,\n-            _OutputIterator __result)\n-{\n-  // concept requirements\n-  __glibcpp_function_requires(_InputIteratorConcept<_InputIterator>);\n-  __glibcpp_function_requires(_OutputIteratorConcept<_OutputIterator,\n-        typename iterator_traits<_InputIterator>::value_type>);\n-\n-  if (__first == __last) return __result;\n-  *__result = *__first;\n-  return __partial_sum(__first, __last, __result, __value_type(__first));\n-}\n-\n-template <class _InputIterator, class _OutputIterator, class _Tp,\n-          class _BinaryOperation>\n-_OutputIterator \n-__partial_sum(_InputIterator __first, _InputIterator __last, \n-              _OutputIterator __result, _Tp*, _BinaryOperation __binary_op)\n-{\n-  _Tp __value = *__first;\n-  while (++__first != __last) {\n-    __value = __binary_op(__value, *__first);\n-    *++__result = __value;\n-  }\n-  return ++__result;\n-}\n-\n-template <class _InputIterator, class _OutputIterator, class _BinaryOperation>\n-_OutputIterator \n-partial_sum(_InputIterator __first, _InputIterator __last,\n-            _OutputIterator __result, _BinaryOperation __binary_op)\n-{\n-  // concept requirements\n-  __glibcpp_function_requires(_InputIteratorConcept<_InputIterator>);\n-  __glibcpp_function_requires(_OutputIteratorConcept<_OutputIterator,\n-        typename iterator_traits<_InputIterator>::value_type>);\n-\n-  if (__first == __last) return __result;\n-  *__result = *__first;\n-  return __partial_sum(__first, __last, __result, __value_type(__first), \n-                       __binary_op);\n-}\n-\n-template <class _InputIterator, class _OutputIterator, class _Tp>\n-_OutputIterator \n-__adjacent_difference(_InputIterator __first, _InputIterator __last,\n-                      _OutputIterator __result, _Tp*)\n-{\n-  _Tp __value = *__first;\n-  while (++__first != __last) {\n-    _Tp __tmp = *__first;\n-    *++__result = __tmp - __value;\n-    __value = __tmp;\n-  }\n-  return ++__result;\n-}\n-\n-template <class _InputIterator, class _OutputIterator>\n-_OutputIterator\n-adjacent_difference(_InputIterator __first,\n-                    _InputIterator __last, _OutputIterator __result)\n-{\n-  // concept requirements\n-  __glibcpp_function_requires(_InputIteratorConcept<_InputIterator>);\n-  __glibcpp_function_requires(_OutputIteratorConcept<_OutputIterator,\n-        typename iterator_traits<_InputIterator>::value_type>);\n-\n-  if (__first == __last) return __result;\n-  *__result = *__first;\n-  return __adjacent_difference(__first, __last, __result,\n-                               __value_type(__first));\n-}\n-\n-template <class _InputIterator, class _OutputIterator, class _Tp, \n-          class _BinaryOperation>\n-_OutputIterator\n-__adjacent_difference(_InputIterator __first, _InputIterator __last, \n-                      _OutputIterator __result, _Tp*,\n-                      _BinaryOperation __binary_op) {\n-  _Tp __value = *__first;\n-  while (++__first != __last) {\n-    _Tp __tmp = *__first;\n-    *++__result = __binary_op(__tmp, __value);\n-    __value = __tmp;\n-  }\n-  return ++__result;\n-}\n-\n-template <class _InputIterator, class _OutputIterator, class _BinaryOperation>\n-_OutputIterator \n-adjacent_difference(_InputIterator __first, _InputIterator __last,\n-                    _OutputIterator __result, _BinaryOperation __binary_op)\n-{\n-  // concept requirements\n-  __glibcpp_function_requires(_InputIteratorConcept<_InputIterator>);\n-  __glibcpp_function_requires(_OutputIteratorConcept<_OutputIterator,\n-        typename iterator_traits<_InputIterator>::value_type>);\n-\n-  if (__first == __last) return __result;\n-  *__result = *__first;\n-  return __adjacent_difference(__first, __last, __result,\n-                               __value_type(__first),\n-                               __binary_op);\n-}\n-\n-// Returns __x ** __n, where __n >= 0.  _Note that \"multiplication\"\n-// is required to be associative, but not necessarily commutative.\n-\n- \n-template <class _Tp, class _Integer, class _MonoidOperation>\n-_Tp __power(_Tp __x, _Integer __n, _MonoidOperation __monoid_op)\n-{\n-  if (__n == 0)\n-    return identity_element(__monoid_op);\n-  else {\n-    while ((__n & 1) == 0) {\n-      __n >>= 1;\n-      __x = __monoid_op(__x, __x);\n+  template<typename _InputIterator1, typename _InputIterator2, typename _Tp>\n+    _Tp\n+    inner_product(_InputIterator1 __first1, _InputIterator1 __last1,\n+\t\t  _InputIterator2 __first2, _Tp __init)\n+    {\n+      // concept requirements\n+      __glibcpp_function_requires(_InputIteratorConcept<_InputIterator1>);\n+      __glibcpp_function_requires(_InputIteratorConcept<_InputIterator2>);\n+\n+      for ( ; __first1 != __last1; ++__first1, ++__first2)\n+\t__init = __init + (*__first1 * *__first2);\n+      return __init;\n     }\n \n-    _Tp __result = __x;\n-    __n >>= 1;\n-    while (__n != 0) {\n-      __x = __monoid_op(__x, __x);\n-      if ((__n & 1) != 0)\n-        __result = __monoid_op(__result, __x);\n-      __n >>= 1;\n+  template<typename _InputIterator1, typename _InputIterator2, typename _Tp,\n+\t    typename _BinaryOperation1, typename _BinaryOperation2>\n+    _Tp\n+    inner_product(_InputIterator1 __first1, _InputIterator1 __last1,\n+\t\t  _InputIterator2 __first2, _Tp __init, \n+\t\t  _BinaryOperation1 __binary_op1,\n+\t\t  _BinaryOperation2 __binary_op2)\n+    {\n+      // concept requirements\n+      __glibcpp_function_requires(_InputIteratorConcept<_InputIterator1>);\n+      __glibcpp_function_requires(_InputIteratorConcept<_InputIterator2>);\n+\n+      for ( ; __first1 != __last1; ++__first1, ++__first2)\n+\t__init = __binary_op1(__init, __binary_op2(*__first1, *__first2));\n+      return __init;\n     }\n-    return __result;\n-  }\n-}\n \n-template <class _Tp, class _Integer>\n-inline _Tp __power(_Tp __x, _Integer __n)\n-{\n-  return __power(__x, __n, multiplies<_Tp>());\n-}\n+  template<typename _InputIterator, typename _OutputIterator>\n+    _OutputIterator \n+    partial_sum(_InputIterator __first, _InputIterator __last,\n+\t\t_OutputIterator __result)\n+    {\n+      typedef typename iterator_traits<_InputIterator>::value_type _ValueType;\n+\n+      // concept requirements\n+      __glibcpp_function_requires(_InputIteratorConcept<_InputIterator>);\n+      __glibcpp_function_requires(_OutputIteratorConcept<_OutputIterator, _ValueType>);\n+\n+      if (__first == __last) return __result;\n+      *__result = *__first;\n+      _ValueType __value = *__first;\n+      while (++__first != __last) {\n+\t__value = __value + *__first;\n+\t*++__result = __value;\n+      }\n+      return ++__result;\n+    }\n \n-// Alias for the internal name __power.  Note that power is an extension,\n-// not part of the C++ standard.\n+  template<typename _InputIterator, typename _OutputIterator, typename _BinaryOperation>\n+    _OutputIterator \n+    partial_sum(_InputIterator __first, _InputIterator __last,\n+\t\t_OutputIterator __result, _BinaryOperation __binary_op)\n+    {\n+      typedef typename iterator_traits<_InputIterator>::value_type _ValueType;\n+\n+      // concept requirements\n+      __glibcpp_function_requires(_InputIteratorConcept<_InputIterator>);\n+      __glibcpp_function_requires(_OutputIteratorConcept<_OutputIterator, _ValueType>);\n+\n+      if (__first == __last) return __result;\n+      *__result = *__first;\n+      _ValueType __value = *__first;\n+      while (++__first != __last) {\n+\t__value = __binary_op(__value, *__first);\n+\t*++__result = __value;\n+      }\n+      return ++__result;\n+    }\n \n-template <class _Tp, class _Integer, class _MonoidOperation>\n-inline _Tp power(_Tp __x, _Integer __n, _MonoidOperation __monoid_op)\n-{\n-  return __power(__x, __n, __monoid_op);\n-}\n+  template<typename _InputIterator, typename _OutputIterator>\n+    _OutputIterator\n+    adjacent_difference(_InputIterator __first,\n+\t\t\t_InputIterator __last, _OutputIterator __result)\n+    {\n+      typedef typename iterator_traits<_InputIterator>::value_type _ValueType;\n+\n+      // concept requirements\n+      __glibcpp_function_requires(_InputIteratorConcept<_InputIterator>);\n+      __glibcpp_function_requires(_OutputIteratorConcept<_OutputIterator, _ValueType>);\n+\n+      if (__first == __last) return __result;\n+      *__result = *__first;\n+      _ValueType __value = *__first;\n+      while (++__first != __last) {\n+\t_ValueType __tmp = *__first;\n+\t*++__result = __tmp - __value;\n+\t__value = __tmp;\n+      }\n+      return ++__result;\n+    }\n \n-template <class _Tp, class _Integer>\n-inline _Tp power(_Tp __x, _Integer __n)\n-{\n-  return __power(__x, __n);\n-}\n+  template<typename _InputIterator, typename _OutputIterator, typename _BinaryOperation>\n+    _OutputIterator \n+    adjacent_difference(_InputIterator __first, _InputIterator __last,\n+\t\t\t_OutputIterator __result, _BinaryOperation __binary_op)\n+    {\n+      typedef typename iterator_traits<_InputIterator>::value_type _ValueType;\n+\n+      // concept requirements\n+      __glibcpp_function_requires(_InputIteratorConcept<_InputIterator>);\n+      __glibcpp_function_requires(_OutputIteratorConcept<_OutputIterator, _ValueType>);\n+\n+      if (__first == __last) return __result;\n+      *__result = *__first;\n+      _ValueType __value = *__first;\n+      while (++__first != __last) {\n+\t_ValueType __tmp = *__first;\n+\t*++__result = __binary_op(__tmp, __value);\n+\t__value = __tmp;\n+      }\n+      return ++__result;\n+    }\n \n-// iota is not part of the C++ standard.  It is an extension.\n+  // Returns __x ** __n, where __n >= 0.  _Note that \"multiplication\"\n+  // is required to be associative, but not necessarily commutative.\n+\n+   \n+  template<typename _Tp, typename _Integer, typename _MonoidOperation>\n+    _Tp\n+    __power(_Tp __x, _Integer __n, _MonoidOperation __monoid_op)\n+    {\n+      if (__n == 0)\n+\treturn identity_element(__monoid_op);\n+      else {\n+\twhile ((__n & 1) == 0) {\n+\t  __n >>= 1;\n+\t  __x = __monoid_op(__x, __x);\n+\t}\n+\n+\t_Tp __result = __x;\n+\t__n >>= 1;\n+\twhile (__n != 0) {\n+\t  __x = __monoid_op(__x, __x);\n+\t  if ((__n & 1) != 0)\n+\t    __result = __monoid_op(__result, __x);\n+\t  __n >>= 1;\n+\t}\n+\treturn __result;\n+      }\n+    }\n \n-template <class _ForwardIter, class _Tp>\n-void \n-iota(_ForwardIter __first, _ForwardIter __last, _Tp __value)\n-{\n-  // concept requirements\n-  __glibcpp_function_requires(_Mutable_ForwardIteratorConcept<_ForwardIter>);\n-  __glibcpp_function_requires(_ConvertibleConcept<_Tp,\n-        typename iterator_traits<_ForwardIter>::value_type>);\n-\n-  while (__first != __last)\n-    *__first++ = __value++;\n-}\n+  template<typename _Tp, typename _Integer>\n+    inline _Tp\n+    __power(_Tp __x, _Integer __n)\n+    { return __power(__x, __n, multiplies<_Tp>()); }\n+\n+  // Alias for the internal name __power.  Note that power is an extension,\n+  // not part of the C++ standard.\n+\n+  template<typename _Tp, typename _Integer, typename _MonoidOperation>\n+    inline _Tp\n+    power(_Tp __x, _Integer __n, _MonoidOperation __monoid_op)\n+    { return __power(__x, __n, __monoid_op); }\n+\n+  template<typename _Tp, typename _Integer>\n+    inline _Tp\n+    power(_Tp __x, _Integer __n)\n+    { return __power(__x, __n); }\n+\n+  // iota is not part of the C++ standard.  It is an extension.\n+\n+  template<typename _ForwardIter, typename _Tp>\n+    void \n+    iota(_ForwardIter __first, _ForwardIter __last, _Tp __value)\n+    {\n+      // concept requirements\n+      __glibcpp_function_requires(_Mutable_ForwardIteratorConcept<_ForwardIter>);\n+      __glibcpp_function_requires(_ConvertibleConcept<_Tp,\n+\t    typename iterator_traits<_ForwardIter>::value_type>);\n+\n+      while (__first != __last)\n+\t*__first++ = __value++;\n+    }\n \n } // namespace std\n "}, {"sha": "f62364098bf9241d5ec9ac39967d6bcfaa712be0", "filename": "libstdc++-v3/include/bits/stl_uninitialized.h", "status": "modified", "additions": 204, "deletions": 232, "changes": 436, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02d92e3b707a5433814ca22aab53da2d229dc3e1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_uninitialized.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02d92e3b707a5433814ca22aab53da2d229dc3e1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_uninitialized.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_uninitialized.h?ref=02d92e3b707a5433814ca22aab53da2d229dc3e1", "patch": "@@ -65,242 +65,214 @@\n namespace std\n {\n \n-// uninitialized_copy\n-\n-// Valid if copy construction is equivalent to assignment, and if the\n-//  destructor is trivial.\n-template <class _InputIter, class _ForwardIter>\n-inline _ForwardIter \n-__uninitialized_copy_aux(_InputIter __first, _InputIter __last,\n-                         _ForwardIter __result,\n-                         __true_type)\n-{\n-  return copy(__first, __last, __result);\n-}\n-\n-template <class _InputIter, class _ForwardIter>\n-_ForwardIter \n-__uninitialized_copy_aux(_InputIter __first, _InputIter __last,\n-                         _ForwardIter __result,\n-                         __false_type)\n-{\n-  _ForwardIter __cur = __result;\n-  __STL_TRY {\n-    for ( ; __first != __last; ++__first, ++__cur)\n-      _Construct(&*__cur, *__first);\n-    return __cur;\n+  // uninitialized_copy\n+\n+  template<typename _InputIter, typename _ForwardIter>\n+    inline _ForwardIter \n+    __uninitialized_copy_aux(_InputIter __first, _InputIter __last,\n+\t\t\t     _ForwardIter __result,\n+\t\t\t     __true_type)\n+    { return copy(__first, __last, __result); }\n+\n+  template<typename _InputIter, typename _ForwardIter>\n+    _ForwardIter \n+    __uninitialized_copy_aux(_InputIter __first, _InputIter __last,\n+\t\t\t     _ForwardIter __result,\n+\t\t\t     __false_type)\n+    {\n+      _ForwardIter __cur = __result;\n+      __STL_TRY {\n+\tfor ( ; __first != __last; ++__first, ++__cur)\n+\t  _Construct(&*__cur, *__first);\n+\treturn __cur;\n+      }\n+      __STL_UNWIND(_Destroy(__result, __cur));\n+    }\n+\n+  template<typename _InputIter, typename _ForwardIter>\n+    inline _ForwardIter\n+    uninitialized_copy(_InputIter __first, _InputIter __last, _ForwardIter __result)\n+    {\n+      typedef typename iterator_traits<_InputIter>::value_type _ValueType;\n+      typedef typename __type_traits<_ValueType>::is_POD_type _Is_POD;\n+      return __uninitialized_copy_aux(__first, __last, __result, _Is_POD());\n+    }\n+\n+  inline char*\n+  uninitialized_copy(const char* __first, const char* __last, char* __result)\n+  {\n+    memmove(__result, __first, __last - __first);\n+    return __result + (__last - __first);\n   }\n-  __STL_UNWIND(_Destroy(__result, __cur));\n-}\n-\n-\n-template <class _InputIter, class _ForwardIter, class _Tp>\n-inline _ForwardIter\n-__uninitialized_copy(_InputIter __first, _InputIter __last,\n-                     _ForwardIter __result, _Tp*)\n-{\n-  typedef typename __type_traits<_Tp>::is_POD_type _Is_POD;\n-  return __uninitialized_copy_aux(__first, __last, __result, _Is_POD());\n-}\n-\n-template <class _InputIter, class _ForwardIter>\n-inline _ForwardIter\n-  uninitialized_copy(_InputIter __first, _InputIter __last,\n-                     _ForwardIter __result)\n-{\n-  return __uninitialized_copy(__first, __last, __result,\n-                              __value_type(__result));\n-}\n-\n-inline char* uninitialized_copy(const char* __first, const char* __last,\n-                                char* __result) {\n-  memmove(__result, __first, __last - __first);\n-  return __result + (__last - __first);\n-}\n-\n-inline wchar_t* \n-uninitialized_copy(const wchar_t* __first, const wchar_t* __last,\n-                   wchar_t* __result)\n-{\n-  memmove(__result, __first, sizeof(wchar_t) * (__last - __first));\n-  return __result + (__last - __first);\n-}\n-\n-// uninitialized_copy_n (not part of the C++ standard)\n \n-template <class _InputIter, class _Size, class _ForwardIter>\n-pair<_InputIter, _ForwardIter>\n-__uninitialized_copy_n(_InputIter __first, _Size __count,\n-                       _ForwardIter __result,\n-                       input_iterator_tag)\n-{\n-  _ForwardIter __cur = __result;\n-  __STL_TRY {\n-    for ( ; __count > 0 ; --__count, ++__first, ++__cur) \n-      _Construct(&*__cur, *__first);\n-    return pair<_InputIter, _ForwardIter>(__first, __cur);\n+  inline wchar_t* \n+  uninitialized_copy(const wchar_t* __first, const wchar_t* __last,\n+\t\t     wchar_t* __result)\n+  {\n+    memmove(__result, __first, sizeof(wchar_t) * (__last - __first));\n+    return __result + (__last - __first);\n   }\n-  __STL_UNWIND(_Destroy(__result, __cur));\n-}\n-\n-template <class _RandomAccessIter, class _Size, class _ForwardIter>\n-inline pair<_RandomAccessIter, _ForwardIter>\n-__uninitialized_copy_n(_RandomAccessIter __first, _Size __count,\n-                       _ForwardIter __result,\n-                       random_access_iterator_tag) {\n-  _RandomAccessIter __last = __first + __count;\n-  return pair<_RandomAccessIter, _ForwardIter>(\n-                 __last,\n-                 uninitialized_copy(__first, __last, __result));\n-}\n-\n-template <class _InputIter, class _Size, class _ForwardIter>\n-inline pair<_InputIter, _ForwardIter>\n-__uninitialized_copy_n(_InputIter __first, _Size __count,\n-                     _ForwardIter __result) {\n-  return __uninitialized_copy_n(__first, __count, __result,\n-                                __iterator_category(__first));\n-}\n-\n-template <class _InputIter, class _Size, class _ForwardIter>\n-inline pair<_InputIter, _ForwardIter>\n-uninitialized_copy_n(_InputIter __first, _Size __count,\n-                     _ForwardIter __result) {\n-  return __uninitialized_copy_n(__first, __count, __result,\n-                                __iterator_category(__first));\n-}\n-\n-// Valid if copy construction is equivalent to assignment, and if the\n-// destructor is trivial.\n-template <class _ForwardIter, class _Tp>\n-inline void\n-__uninitialized_fill_aux(_ForwardIter __first, _ForwardIter __last, \n-                         const _Tp& __x, __true_type)\n-{\n-  fill(__first, __last, __x);\n-}\n \n-template <class _ForwardIter, class _Tp>\n-void\n-__uninitialized_fill_aux(_ForwardIter __first, _ForwardIter __last, \n-                         const _Tp& __x, __false_type)\n-{\n-  _ForwardIter __cur = __first;\n-  __STL_TRY {\n-    for ( ; __cur != __last; ++__cur)\n-      _Construct(&*__cur, __x);\n-  }\n-  __STL_UNWIND(_Destroy(__first, __cur));\n-}\n-\n-template <class _ForwardIter, class _Tp, class _Tp1>\n-inline void __uninitialized_fill(_ForwardIter __first, \n-                                 _ForwardIter __last, const _Tp& __x, _Tp1*)\n-{\n-  typedef typename __type_traits<_Tp1>::is_POD_type _Is_POD;\n-  __uninitialized_fill_aux(__first, __last, __x, _Is_POD());\n-                   \n-}\n-\n-template <class _ForwardIter, class _Tp>\n-inline void uninitialized_fill(_ForwardIter __first,\n-                               _ForwardIter __last, \n-                               const _Tp& __x)\n-{\n-  __uninitialized_fill(__first, __last, __x, __value_type(__first));\n-}\n-\n-// Valid if copy construction is equivalent to assignment, and if the\n-//  destructor is trivial.\n-template <class _ForwardIter, class _Size, class _Tp>\n-inline _ForwardIter\n-__uninitialized_fill_n_aux(_ForwardIter __first, _Size __n,\n-                           const _Tp& __x, __true_type)\n-{\n-  return fill_n(__first, __n, __x);\n-}\n-\n-template <class _ForwardIter, class _Size, class _Tp>\n-_ForwardIter\n-__uninitialized_fill_n_aux(_ForwardIter __first, _Size __n,\n-                           const _Tp& __x, __false_type)\n-{\n-  _ForwardIter __cur = __first;\n-  __STL_TRY {\n-    for ( ; __n > 0; --__n, ++__cur)\n-      _Construct(&*__cur, __x);\n-    return __cur;\n-  }\n-  __STL_UNWIND(_Destroy(__first, __cur));\n-}\n-\n-template <class _ForwardIter, class _Size, class _Tp, class _Tp1>\n-inline _ForwardIter \n-__uninitialized_fill_n(_ForwardIter __first, _Size __n, const _Tp& __x, _Tp1*)\n-{\n-  typedef typename __type_traits<_Tp1>::is_POD_type _Is_POD;\n-  return __uninitialized_fill_n_aux(__first, __n, __x, _Is_POD());\n-}\n-\n-template <class _ForwardIter, class _Size, class _Tp>\n-inline _ForwardIter \n-uninitialized_fill_n(_ForwardIter __first, _Size __n, const _Tp& __x)\n-{\n-  return __uninitialized_fill_n(__first, __n, __x, __value_type(__first));\n-}\n-\n-// Extensions: __uninitialized_copy_copy, __uninitialized_copy_fill, \n-// __uninitialized_fill_copy.\n-\n-// __uninitialized_copy_copy\n-// Copies [first1, last1) into [result, result + (last1 - first1)), and\n-//  copies [first2, last2) into\n-//  [result, result + (last1 - first1) + (last2 - first2)).\n-\n-template <class _InputIter1, class _InputIter2, class _ForwardIter>\n-inline _ForwardIter\n-__uninitialized_copy_copy(_InputIter1 __first1, _InputIter1 __last1,\n-                          _InputIter2 __first2, _InputIter2 __last2,\n-                          _ForwardIter __result)\n-{\n-  _ForwardIter __mid = uninitialized_copy(__first1, __last1, __result);\n-  __STL_TRY {\n-    return uninitialized_copy(__first2, __last2, __mid);\n-  }\n-  __STL_UNWIND(_Destroy(__result, __mid));\n-}\n-\n-// __uninitialized_fill_copy\n-// Fills [result, mid) with x, and copies [first, last) into\n-//  [mid, mid + (last - first)).\n-template <class _ForwardIter, class _Tp, class _InputIter>\n-inline _ForwardIter \n-__uninitialized_fill_copy(_ForwardIter __result, _ForwardIter __mid,\n-                          const _Tp& __x,\n-                          _InputIter __first, _InputIter __last)\n-{\n-  uninitialized_fill(__result, __mid, __x);\n-  __STL_TRY {\n-    return uninitialized_copy(__first, __last, __mid);\n-  }\n-  __STL_UNWIND(_Destroy(__result, __mid));\n-}\n-\n-// __uninitialized_copy_fill\n-// Copies [first1, last1) into [first2, first2 + (last1 - first1)), and\n-//  fills [first2 + (last1 - first1), last2) with x.\n-template <class _InputIter, class _ForwardIter, class _Tp>\n-inline void\n-__uninitialized_copy_fill(_InputIter __first1, _InputIter __last1,\n-                          _ForwardIter __first2, _ForwardIter __last2,\n-                          const _Tp& __x)\n-{\n-  _ForwardIter __mid2 = uninitialized_copy(__first1, __last1, __first2);\n-  __STL_TRY {\n-    uninitialized_fill(__mid2, __last2, __x);\n-  }\n-  __STL_UNWIND(_Destroy(__first2, __mid2));\n-}\n+  // uninitialized_copy_n (not part of the C++ standard)\n+\n+  template<typename _InputIter, typename _Size, typename _ForwardIter>\n+    pair<_InputIter, _ForwardIter>\n+    __uninitialized_copy_n(_InputIter __first, _Size __count,\n+\t\t\t   _ForwardIter __result,\n+\t\t\t   input_iterator_tag)\n+    {\n+      _ForwardIter __cur = __result;\n+      __STL_TRY {\n+\tfor ( ; __count > 0 ; --__count, ++__first, ++__cur) \n+\t  _Construct(&*__cur, *__first);\n+\treturn pair<_InputIter, _ForwardIter>(__first, __cur);\n+      }\n+      __STL_UNWIND(_Destroy(__result, __cur));\n+    }\n+\n+  template<typename _RandomAccessIter, typename _Size, typename _ForwardIter>\n+    inline pair<_RandomAccessIter, _ForwardIter>\n+    __uninitialized_copy_n(_RandomAccessIter __first, _Size __count,\n+\t\t\t   _ForwardIter __result,\n+\t\t\t   random_access_iterator_tag)\n+    {\n+      _RandomAccessIter __last = __first + __count;\n+      return pair<_RandomAccessIter, _ForwardIter>(\n+\t\t     __last,\n+\t\t     uninitialized_copy(__first, __last, __result));\n+    }\n+\n+  template<typename _InputIter, typename _Size, typename _ForwardIter>\n+    inline pair<_InputIter, _ForwardIter>\n+    __uninitialized_copy_n(_InputIter __first, _Size __count,\n+\t\t\t _ForwardIter __result) {\n+      return __uninitialized_copy_n(__first, __count, __result,\n+\t\t\t\t    __iterator_category(__first));\n+    }\n+\n+  template<typename _InputIter, typename _Size, typename _ForwardIter>\n+    inline pair<_InputIter, _ForwardIter>\n+    uninitialized_copy_n(_InputIter __first, _Size __count,\n+\t\t\t _ForwardIter __result) {\n+      return __uninitialized_copy_n(__first, __count, __result,\n+\t\t\t\t    __iterator_category(__first));\n+    }\n+\n+  // Valid if copy construction is equivalent to assignment, and if the\n+  // destructor is trivial.\n+  template<typename _ForwardIter, typename _Tp>\n+    inline void\n+    __uninitialized_fill_aux(_ForwardIter __first, _ForwardIter __last, \n+\t\t\t     const _Tp& __x, __true_type)\n+    { fill(__first, __last, __x); }\n+\n+  template<typename _ForwardIter, typename _Tp>\n+    void\n+    __uninitialized_fill_aux(_ForwardIter __first, _ForwardIter __last, \n+\t\t\t     const _Tp& __x, __false_type)\n+    {\n+      _ForwardIter __cur = __first;\n+      __STL_TRY {\n+\tfor ( ; __cur != __last; ++__cur)\n+\t  _Construct(&*__cur, __x);\n+      }\n+      __STL_UNWIND(_Destroy(__first, __cur));\n+    }\n+\n+  template<typename _ForwardIter, typename _Tp>\n+    inline void\n+    uninitialized_fill(_ForwardIter __first, _ForwardIter __last, const _Tp& __x)\n+    {\n+      typedef typename iterator_traits<_ForwardIter>::value_type _ValueType;\n+      typedef typename __type_traits<_ValueType>::is_POD_type _Is_POD;\n+      __uninitialized_fill_aux(__first, __last, __x, _Is_POD());\n+    }\n+\n+  // Valid if copy construction is equivalent to assignment, and if the\n+  //  destructor is trivial.\n+  template<typename _ForwardIter, typename _Size, typename _Tp>\n+    inline _ForwardIter\n+    __uninitialized_fill_n_aux(_ForwardIter __first, _Size __n,\n+\t\t\t       const _Tp& __x, __true_type)\n+    {\n+      return fill_n(__first, __n, __x);\n+    }\n+\n+  template<typename _ForwardIter, typename _Size, typename _Tp>\n+    _ForwardIter\n+    __uninitialized_fill_n_aux(_ForwardIter __first, _Size __n,\n+\t\t\t       const _Tp& __x, __false_type)\n+    {\n+      _ForwardIter __cur = __first;\n+      __STL_TRY {\n+\tfor ( ; __n > 0; --__n, ++__cur)\n+\t  _Construct(&*__cur, __x);\n+\treturn __cur;\n+      }\n+      __STL_UNWIND(_Destroy(__first, __cur));\n+    }\n+\n+  template<typename _ForwardIter, typename _Size, typename _Tp>\n+    inline _ForwardIter \n+    uninitialized_fill_n(_ForwardIter __first, _Size __n, const _Tp& __x)\n+    {\n+      typedef typename iterator_traits<_ForwardIter>::value_type _ValueType;\n+      typedef typename __type_traits<_ValueType>::is_POD_type _Is_POD;\n+      return __uninitialized_fill_n_aux(__first, __n, __x, _Is_POD());\n+    }\n+\n+  // Extensions: __uninitialized_copy_copy, __uninitialized_copy_fill, \n+  // __uninitialized_fill_copy.\n+\n+  // __uninitialized_copy_copy\n+  // Copies [first1, last1) into [result, result + (last1 - first1)), and\n+  //  copies [first2, last2) into\n+  //  [result, result + (last1 - first1) + (last2 - first2)).\n+\n+  template<typename _InputIter1, typename _InputIter2, typename _ForwardIter>\n+    inline _ForwardIter\n+    __uninitialized_copy_copy(_InputIter1 __first1, _InputIter1 __last1,\n+\t\t\t      _InputIter2 __first2, _InputIter2 __last2,\n+\t\t\t      _ForwardIter __result)\n+    {\n+      _ForwardIter __mid = uninitialized_copy(__first1, __last1, __result);\n+      __STL_TRY {\n+\treturn uninitialized_copy(__first2, __last2, __mid);\n+      }\n+      __STL_UNWIND(_Destroy(__result, __mid));\n+    }\n+\n+  // __uninitialized_fill_copy\n+  // Fills [result, mid) with x, and copies [first, last) into\n+  //  [mid, mid + (last - first)).\n+  template<typename _ForwardIter, typename _Tp, typename _InputIter>\n+    inline _ForwardIter \n+    __uninitialized_fill_copy(_ForwardIter __result, _ForwardIter __mid,\n+\t\t\t      const _Tp& __x,\n+\t\t\t      _InputIter __first, _InputIter __last)\n+    {\n+      uninitialized_fill(__result, __mid, __x);\n+      __STL_TRY {\n+\treturn uninitialized_copy(__first, __last, __mid);\n+      }\n+      __STL_UNWIND(_Destroy(__result, __mid));\n+    }\n+\n+  // __uninitialized_copy_fill\n+  // Copies [first1, last1) into [first2, first2 + (last1 - first1)), and\n+  //  fills [first2 + (last1 - first1), last2) with x.\n+  template<typename _InputIter, typename _ForwardIter, typename _Tp>\n+    inline void\n+    __uninitialized_copy_fill(_InputIter __first1, _InputIter __last1,\n+\t\t\t      _ForwardIter __first2, _ForwardIter __last2,\n+\t\t\t      const _Tp& __x)\n+    {\n+      _ForwardIter __mid2 = uninitialized_copy(__first1, __last1, __first2);\n+      __STL_TRY {\n+\tuninitialized_fill(__mid2, __last2, __x);\n+      }\n+      __STL_UNWIND(_Destroy(__first2, __mid2));\n+    }\n \n } // namespace std\n "}, {"sha": "17e886cb074a11aeec2490277680b0cc455be2a1", "filename": "libstdc++-v3/libio/Makefile.in", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02d92e3b707a5433814ca22aab53da2d229dc3e1/libstdc%2B%2B-v3%2Flibio%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02d92e3b707a5433814ca22aab53da2d229dc3e1/libstdc%2B%2B-v3%2Flibio%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibio%2FMakefile.in?ref=02d92e3b707a5433814ca22aab53da2d229dc3e1", "patch": "@@ -124,28 +124,22 @@ toplevel_srcdir = @toplevel_srcdir@\n AUTOMAKE_OPTIONS = 1.3 cygnus\n \n mkinstalldirs = $(SHELL) $(toplevel_srcdir)/mkinstalldirs\n-@GLIBCPP_BUILD_LIBIO_TRUE@noinst_LTLIBRARIES = @GLIBCPP_BUILD_LIBIO_TRUE@libio.la\n+@GLIBCPP_BUILD_LIBIO_TRUE@noinst_LTLIBRARIES = libio.la\n @GLIBCPP_BUILD_LIBIO_FALSE@noinst_LTLIBRARIES = \n \n # Use common includes from acinclude.m4/GLIBCPP_EXPORT_INCLUDES\n GLIBCPP_INCLUDES = @GLIBCPP_INCLUDES@\n TOPLEVEL_INCLUDES = @TOPLEVEL_INCLUDES@\n LIBIO_INCLUDES = @LIBIO_INCLUDES@\n \n-INCLUDES = \\\n-\t-nostdinc++ \\\n-\t$(GLIBCPP_INCLUDES) $(LIBIO_INCLUDES) $(TOPLEVEL_INCLUDES)\t\n+INCLUDES =  \t-nostdinc++ \t$(GLIBCPP_INCLUDES) $(LIBIO_INCLUDES) $(TOPLEVEL_INCLUDES)\t\n \n \n-libio_headers = \\\n-        libio.h libioP.h iolibio.h\n+libio_headers =          libio.h libioP.h iolibio.h\n \n-@GLIBCPP_NEED_LIBIO_TRUE@LIBIO_SRCS = @GLIBCPP_NEED_LIBIO_TRUE@\\\n-@GLIBCPP_NEED_LIBIO_TRUE@\tfiledoalloc.c genops.c fileops.c stdfiles.c c_codecvt.c \\\n-@GLIBCPP_NEED_LIBIO_TRUE@\tiofclose.c iofopen.c \n+@GLIBCPP_NEED_LIBIO_TRUE@LIBIO_SRCS = \tfiledoalloc.c genops.c fileops.c stdfiles.c c_codecvt.c \tiofclose.c iofopen.c \n @GLIBCPP_NEED_LIBIO_FALSE@LIBIO_SRCS = \n-@GLIBCPP_NEED_WLIBIO_TRUE@LIBIO_WSRCS = @GLIBCPP_NEED_WLIBIO_TRUE@\\\n-@GLIBCPP_NEED_WLIBIO_TRUE@\twfiledoalloc.c wfileops.c wgenops.c iofwide.c\n+@GLIBCPP_NEED_WLIBIO_TRUE@LIBIO_WSRCS = \twfiledoalloc.c wfileops.c wgenops.c iofwide.c\n @GLIBCPP_NEED_WLIBIO_FALSE@LIBIO_WSRCS = \n \n EXTRA_DIST = iostreamP.h"}, {"sha": "17581f23533d484305353078b71117bfa12f6092", "filename": "libstdc++-v3/libmath/Makefile.in", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02d92e3b707a5433814ca22aab53da2d229dc3e1/libstdc%2B%2B-v3%2Flibmath%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02d92e3b707a5433814ca22aab53da2d229dc3e1/libstdc%2B%2B-v3%2Flibmath%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibmath%2FMakefile.in?ref=02d92e3b707a5433814ca22aab53da2d229dc3e1", "patch": "@@ -129,18 +129,13 @@ mkinstalldirs = $(SHELL) $(toplevel_srcdir)/mkinstalldirs\n \n noinst_LTLIBRARIES = libmath.la\n \n-EXTRA_LONG_DOUBLE_yes = \\\n-\thypotl.c signbitl.c\n+EXTRA_LONG_DOUBLE_yes =  \thypotl.c signbitl.c\n \n \n-EXTRA_DIST = \\\n-\thypot.c hypotf.c \\\n-\t$(EXTRA_LONG_DOUBLE_yes) \n+EXTRA_DIST =  \thypot.c hypotf.c \t$(EXTRA_LONG_DOUBLE_yes) \n \n \n-libmath_la_LIBADD = \\\n-\t@LIBMATHOBJS@ \\\n-\t$(EXTRA_LONG_DOUBLE_$(USE_COMPLEX_LONG_DOUBLE)) \n+libmath_la_LIBADD =  \t@LIBMATHOBJS@ \t$(EXTRA_LONG_DOUBLE_$(USE_COMPLEX_LONG_DOUBLE)) \n \n \n libmath_la_DEPENDENCIES = $(libmath_la_LIBADD)\n@@ -152,8 +147,7 @@ LINK = $(LIBTOOL) --mode=link \"$(CCLD)\" $(AM_CFLAGS) $(CFLAGS) $(LDFLAGS) -o $@\n # Use common includes from acinclude.m4/GLIBCPP_EXPORT_INCLUDES\n TOPLEVEL_INCLUDES = @TOPLEVEL_INCLUDES@\n \n-INCLUDES = \\\n-\t$(TOPLEVEL_INCLUDES) \n+INCLUDES =  \t$(TOPLEVEL_INCLUDES) \n \n CONFIG_HEADER = ../config.h\n CONFIG_CLEAN_FILES = "}, {"sha": "10197f5b96eb866c279495667dc645d68dedcfec", "filename": "libstdc++-v3/libsupc++/Makefile.in", "status": "modified", "additions": 12, "deletions": 47, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02d92e3b707a5433814ca22aab53da2d229dc3e1/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02d92e3b707a5433814ca22aab53da2d229dc3e1/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2FMakefile.in?ref=02d92e3b707a5433814ca22aab53da2d229dc3e1", "patch": "@@ -144,50 +144,24 @@ OPTIMIZE_CXXFLAGS = @OPTIMIZE_CXXFLAGS@\n # These bits are all figured out from configure. Look in acinclude.m4\n # or configure.in to see how they are set. See GLIBCPP_EXPORT_FLAGS\n # NB: DEBUGFLAGS have to be at the end so that -O2 can be overridden.\n-CONFIG_CXXFLAGS = \\\n-\t@EXTRA_CXX_FLAGS@ @SECTION_FLAGS@ @CSHADOW_FLAGS@ @DEBUG_FLAGS@ \n+CONFIG_CXXFLAGS =  \t@EXTRA_CXX_FLAGS@ @SECTION_FLAGS@ @CSHADOW_FLAGS@ @DEBUG_FLAGS@ \n \n \n # Warning flags to use.\n-WARN_CXXFLAGS = \\\n-\t@WARN_FLAGS@ $(WERROR) -fdiagnostics-show-location=once\n+WARN_CXXFLAGS =  \t@WARN_FLAGS@ $(WERROR) -fdiagnostics-show-location=once\n \n \n # Use common includes from acinclude.m4/GLIBCPP_EXPORT_INCLUDES\n GLIBCPP_INCLUDES = @GLIBCPP_INCLUDES@\n LIBSUPCXX_INCLUDES = @LIBSUPCXX_INCLUDES@\n \n-INCLUDES = \\\n-\t-I$(toplevel_srcdir)/gcc -I$(toplevel_srcdir)/include \\\n-\t$(GLIBCPP_INCLUDES) $(LIBSUPCXX_INCLUDES)\n-\n-\n-headers = \\\n-\texception new typeinfo cxxabi.h exception_defines.h \n-\n-\n-sources = \\\n-\tdel_op.cc \\\n-\tdel_opnt.cc \\\n-\tdel_opv.cc \\\n-\tdel_opvnt.cc \\\n-\teh_alloc.cc \\\n-\teh_aux_runtime.cc \\\n-\teh_catch.cc \\\n-\teh_exception.cc \\\n-\teh_globals.cc \\\n-\teh_personality.cc \\\n-\teh_terminate.cc \\\n-\teh_throw.cc \\\n-\tnew_handler.cc \\\n-\tnew_op.cc \\\n-\tnew_opnt.cc \\\n-\tnew_opv.cc \\\n-\tnew_opvnt.cc \\\n-\tpure.cc \\\n-\ttinfo.cc \\\n-\ttinfo2.cc \\\n-\tvec.cc\n+INCLUDES =  \t-I$(toplevel_srcdir)/gcc -I$(toplevel_srcdir)/include \t$(GLIBCPP_INCLUDES) $(LIBSUPCXX_INCLUDES)\n+\n+\n+headers =  \texception new typeinfo cxxabi.h exception_defines.h \n+\n+\n+sources =  \tdel_op.cc \tdel_opnt.cc \tdel_opv.cc \tdel_opvnt.cc \teh_alloc.cc \teh_aux_runtime.cc \teh_catch.cc \teh_exception.cc \teh_globals.cc \teh_personality.cc \teh_terminate.cc \teh_throw.cc \tnew_handler.cc \tnew_op.cc \tnew_opnt.cc \tnew_opv.cc \tnew_opvnt.cc \tpure.cc \ttinfo.cc \ttinfo2.cc \tvec.cc\n \n \n libsupc___la_SOURCES = $(sources)\n@@ -203,12 +177,7 @@ LIBSUPCXX_CXXFLAGS = $(LIBSUPCXX_PICFLAGS)\n # set this option because CONFIG_CXXFLAGS has to be after\n # OPTIMIZE_CXXFLAGS on the compile line so that -O2 can be overridden\n # as the occasion call for it. (ie, --enable-debug)\n-AM_CXXFLAGS = \\\n-\t-fno-implicit-templates \\\n-\t$(LIBSUPCXX_CXXFLAGS) \\\n-\t$(WARN_CXXFLAGS) \\\n-\t$(OPTIMIZE_CXXFLAGS) \\\n-\t$(CONFIG_CXXFLAGS) \n+AM_CXXFLAGS =  \t-fno-implicit-templates \t$(LIBSUPCXX_CXXFLAGS) \t$(WARN_CXXFLAGS) \t$(OPTIMIZE_CXXFLAGS) \t$(CONFIG_CXXFLAGS) \n \n \n # libstdc++ libtool notes\n@@ -232,9 +201,7 @@ AM_CXXFLAGS = \\\n #\n # We have to put --tag disable-shared after --tag CXX lest things\n # CXX undo the affect of disable-shared.\n-LTCXXCOMPILE = $(LIBTOOL) --tag CXX --tag disable-shared \\\n-               --mode=compile $(CXX) $(INCLUDES) \\\n-\t       $(AM_CPPFLAGS) $(CPPFLAGS) $(CXXFLAGS) $(AM_CXXFLAGS) \n+LTCXXCOMPILE = $(LIBTOOL) --tag CXX --tag disable-shared                --mode=compile $(CXX) $(INCLUDES) \t       $(AM_CPPFLAGS) $(CPPFLAGS) $(CXXFLAGS) $(AM_CXXFLAGS) \n \n \n # 3) We'd have a problem when building the shared libstdc++ object if\n@@ -243,9 +210,7 @@ LTCXXCOMPILE = $(LIBTOOL) --tag CXX --tag disable-shared \\\n # course is problematic at this point.  So, we get the top-level\n # directory to configure libstdc++-v3 to use gcc as the C++\n # compilation driver.\n-CXXLINK = $(LIBTOOL) --tag CXX --tag disable-shared \\\n-          --mode=link $(CXX) \\\n-          @OPT_LDFLAGS@ @SECTION_LDFLAGS@ $(AM_CXXFLAGS) $(LDFLAGS) -o $@\n+CXXLINK = $(LIBTOOL) --tag CXX --tag disable-shared           --mode=link $(CXX)           @OPT_LDFLAGS@ @SECTION_LDFLAGS@ $(AM_CXXFLAGS) $(LDFLAGS) -o $@\n \n CONFIG_HEADER = ../config.h\n CONFIG_CLEAN_FILES = "}, {"sha": "f6c3124e5fd359e3c5caa071ac173f82e66bbe21", "filename": "libstdc++-v3/src/Makefile.in", "status": "modified", "additions": 8, "deletions": 28, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02d92e3b707a5433814ca22aab53da2d229dc3e1/libstdc%2B%2B-v3%2Fsrc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02d92e3b707a5433814ca22aab53da2d229dc3e1/libstdc%2B%2B-v3%2Fsrc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2FMakefile.in?ref=02d92e3b707a5433814ca22aab53da2d229dc3e1", "patch": "@@ -134,13 +134,11 @@ OPTIMIZE_CXXFLAGS = @OPTIMIZE_CXXFLAGS@\n # These bits are all figured out from configure. Look in acinclude.m4\n # or configure.in to see how they are set. See GLIBCPP_EXPORT_FLAGS\n # NB: DEBUGFLAGS have to be at the end so that -O2 can be overridden.\n-CONFIG_CXXFLAGS = \\\n-\t@EXTRA_CXX_FLAGS@ @SECTION_FLAGS@ @CSHADOW_FLAGS@ @DEBUG_FLAGS@ \n+CONFIG_CXXFLAGS =  \t@EXTRA_CXX_FLAGS@ @SECTION_FLAGS@ @CSHADOW_FLAGS@ @DEBUG_FLAGS@ \n \n \n # Warning flags to use.\n-WARN_CXXFLAGS = \\\n-\t@WARN_FLAGS@ $(WERROR) -fdiagnostics-show-location=once\n+WARN_CXXFLAGS =  \t@WARN_FLAGS@ $(WERROR) -fdiagnostics-show-location=once\n \n \n # Use common includes from acinclude.m4/GLIBCPP_EXPORT_INCLUDES\n@@ -150,28 +148,17 @@ LIBSUPCXX_INCLUDES = @LIBSUPCXX_INCLUDES@\n LIBIO_INCLUDES = @LIBIO_INCLUDES@\n TOPLEVEL_INCLUDES = @TOPLEVEL_INCLUDES@\n \n-INCLUDES = \\\n-\t-nostdinc++ \\\n-\t$(GLIBCPP_INCLUDES) \\\n-\t$(LIBSUPCXX_INCLUDES) $(LIBIO_INCLUDES) $(LIBMATH_INCLUDES) \\\n-\t$(TOPLEVEL_INCLUDES)\n+INCLUDES =  \t-nostdinc++ \t$(GLIBCPP_INCLUDES) \t$(LIBSUPCXX_INCLUDES) $(LIBIO_INCLUDES) $(LIBMATH_INCLUDES) \t$(TOPLEVEL_INCLUDES)\n \n \n-sources = \\\n-\tbasic_file.cc bitset.cc c++locale.cc cmath.cc codecvt.cc \\\n-\tcomplex_io.cc functexcept.cc globals.cc ios.cc limitsMEMBERS.cc \\\n-\tlocale.cc locale-inst.cc localename.cc misc-inst.cc stdexcept.cc \\\n-\tstl-inst.cc string-inst.cc strstream.cc valarray-inst.cc \\\n-\twstring-inst.cc\n+sources =  \tbasic_file.cc bitset.cc c++locale.cc cmath.cc codecvt.cc \tcomplex_io.cc functexcept.cc globals.cc ios.cc limitsMEMBERS.cc \tlocale.cc locale-inst.cc localename.cc misc-inst.cc stdexcept.cc \tstl-inst.cc string-inst.cc strstream.cc valarray-inst.cc \twstring-inst.cc\n \n \n VPATH = $(top_srcdir):$(top_srcdir)/src\n \n libstdc___la_SOURCES = $(sources)\n \n-libstdc___la_LIBADD = \\\n-\t../libmath/libmath.la @libio_la@ \\\n-\t../libsupc++/libsupc++convenience.la\n+libstdc___la_LIBADD =  \t../libmath/libmath.la @libio_la@ \t../libsupc++/libsupc++convenience.la\n \n \n libstdc___la_LDFLAGS = -version-info 3:0:0 -lm\n@@ -191,12 +178,7 @@ GLIBCPP_INCLUDE_DIR = @glibcpp_builddir@/include\n # The no-implicit-templates flag will generate unresolved references to\n # the concept-checking symbols.  So we must disable the checks while\n # actually building the library.\n-AM_CXXFLAGS = \\\n-\t-fno-implicit-templates \\\n-\t$(LIBSUPCXX_CXXFLAGS) \\\n-\t$(WARN_CXXFLAGS) \\\n-\t$(OPTIMIZE_CXXFLAGS) \\\n-\t$(CONFIG_CXXFLAGS) \n+AM_CXXFLAGS =  \t-fno-implicit-templates \t$(LIBSUPCXX_CXXFLAGS) \t$(WARN_CXXFLAGS) \t$(OPTIMIZE_CXXFLAGS) \t$(CONFIG_CXXFLAGS) \n \n \n # libstdc++ libtool notes\n@@ -217,8 +199,7 @@ AM_CXXFLAGS = \\\n # correct solution is to add `--tag CXX' to LTCXXCOMPILE and maybe\n # CXXLINK, just after $(LIBTOOL), so that libtool doesn't have to\n # attempt to infer which configuration to use\n-LTCXXCOMPILE = $(LIBTOOL) --tag CXX --mode=compile $(CXX) $(INCLUDES) \\\n-\t       $(AM_CPPFLAGS) $(CPPFLAGS) $(CXXFLAGS) $(AM_CXXFLAGS) \n+LTCXXCOMPILE = $(LIBTOOL) --tag CXX --mode=compile $(CXX) $(INCLUDES) \t       $(AM_CPPFLAGS) $(CPPFLAGS) $(CXXFLAGS) $(AM_CXXFLAGS) \n \n \n # 3) We'd have a problem when building the shared libstdc++ object if\n@@ -227,8 +208,7 @@ LTCXXCOMPILE = $(LIBTOOL) --tag CXX --mode=compile $(CXX) $(INCLUDES) \\\n # course is problematic at this point.  So, we get the top-level\n # directory to configure libstdc++-v3 to use gcc as the C++\n # compilation driver.\n-CXXLINK = $(LIBTOOL) --tag CXX --mode=link $(CXX) \\\n-\t  @OPT_LDFLAGS@ @SECTION_LDFLAGS@ $(AM_CXXFLAGS) $(LDFLAGS) -o $@\n+CXXLINK = $(LIBTOOL) --tag CXX --mode=link $(CXX) \t  @OPT_LDFLAGS@ @SECTION_LDFLAGS@ $(AM_CXXFLAGS) $(LDFLAGS) -o $@\n \n CONFIG_HEADER = ../config.h\n CONFIG_CLEAN_FILES = "}, {"sha": "94782bf2509509a9a9af62e390a4af11d6c0c5e3", "filename": "libstdc++-v3/testsuite/23_containers/vector_ctor.cc", "status": "modified", "additions": 28, "deletions": 3, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02d92e3b707a5433814ca22aab53da2d229dc3e1/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector_ctor.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02d92e3b707a5433814ca22aab53da2d229dc3e1/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector_ctor.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector_ctor.cc?ref=02d92e3b707a5433814ca22aab53da2d229dc3e1", "patch": "@@ -1,7 +1,6 @@\n-// 1999-06-29\n-// bkoz \n+// 1999-06-29 bkoz\n \n-// Copyright (C) 1999, 2000 Free Software Foundation, Inc.\n+// Copyright (C) 1999-2001 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -57,10 +56,36 @@ void test02()\n   std::vector<int> v2 (v1);\n }\n \n+// test range constructors and range-fill constructor\n+void\n+test03()\n+{\n+    const int A[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17};\n+    const int B[] = {7, 7, 7, 7, 7};\n+    const int N = sizeof(A) / sizeof(int);\n+    const int M = sizeof(B) / sizeof(int);\n+    bool test = true;\n+\n+    std::vector<int> v3(A, A + N);\n+    VERIFY(std::equal(v3.begin(), v3.end(), A));\n+\n+    std::vector<int> v4(v3.begin(), v3.end());\n+    VERIFY(std::equal(v4.begin(), v4.end(), A));\n+\n+    std::vector<int> v5(M, 7);\n+    VERIFY(std::equal(v5.begin(), v5.end(), B));\n+    VERIFY(std::equal(B, B + M, v5.begin()));\n+\n+#ifdef DEBUG_ASSERT\n+  assert(test);\n+#endif\n+}\n \n int main()\n {\n   test01();\n   test02(); \n+  test03();\n+\n   return 0;\n }"}, {"sha": "db18b9a41a3b6dde22886fdaf37d1868de234766", "filename": "libstdc++-v3/testsuite/23_containers/vector_modifiers.cc", "status": "modified", "additions": 36, "deletions": 13, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02d92e3b707a5433814ca22aab53da2d229dc3e1/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector_modifiers.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02d92e3b707a5433814ca22aab53da2d229dc3e1/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector_modifiers.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector_modifiers.cc?ref=02d92e3b707a5433814ca22aab53da2d229dc3e1", "patch": "@@ -1,6 +1,6 @@\n // 1999-11-09 bkoz\n \n-// Copyright (C) 1999 Free Software Foundation, Inc.\n+// Copyright (C) 1999, 2001 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -21,18 +21,19 @@\n // 23.2.4.3 vector modifiers\n \n #include <vector>\n-#include <debug_assert.h>\n+#include \"debug_assert.h\"\n+\n+bool test = true;\n \n template<typename T>\n   struct A { };\n \n struct B { };\n \n // vector::insert(iterator, inputiterator first, inputiterator last)\n-bool test01()\n+void\n+test01()\n {\n-  bool test = true;\n-\n   // POD types\n   typedef std::vector<int> \tvec_POD;\n   vec_POD\tvec01;\n@@ -46,20 +47,42 @@ bool test01()\n   A<B>\t\tnp01;\n   A<B>*\t\tpnp01 = &np01;\n   vec02.insert(vec02.begin(), pnp01, pnp01 + 1);\n+}\n+\n+// test the assign() function\n+void\n+test03()\n+{\n+  const int K = 417;\n+  const int A[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17};\n+  const int B[] = {K, K, K, K, K};\n+  const int N = sizeof(A) / sizeof(int);\n+  const int M = sizeof(B) / sizeof(int);\n+  bool test = true;\n+\n+  // assign from pointer range\n+  std::vector<int> v3;\n+  v3.assign(A, A + N);\n+  VERIFY(std::equal(v3.begin(), v3.end(), A));\n+  VERIFY(v3.size() == N);\n \n-  // Test that assign compiles.\n-  vec01.assign (pi01, pi01 + 1);\n+  // assign from iterator range\n+  std::vector<int> v4;\n+  v4.assign(v3.begin(), v3.end());\n+  VERIFY(std::equal(v4.begin(), v4.end(), A));\n+  VERIFY(std::equal(A, A + N, v4.begin()));\n \n-#ifdef DEBUG_ASSERT\n-  assert(test);\n-#endif\n-  \n-  return test;\n+  // assign from initializer range with resize\n+  v4.assign(M, K);\n+  VERIFY(std::equal(v4.begin(), v4.end(), B));\n+  VERIFY(std::equal(B, B + M, v4.begin()));\n+  VERIFY((v4.size() == M) && (M != N));\n }\n \n int main()\n {\n   test01();\n+  test03();\n \n-  return 0;\n+  return !test;\n }"}, {"sha": "7e4396b4cb5afb6d9cec8aa87530260d4a0dc67f", "filename": "libstdc++-v3/testsuite/25_algorithms/binary_search.cc", "status": "added", "additions": 183, "deletions": 0, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02d92e3b707a5433814ca22aab53da2d229dc3e1/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fbinary_search.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02d92e3b707a5433814ca22aab53da2d229dc3e1/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fbinary_search.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fbinary_search.cc?ref=02d92e3b707a5433814ca22aab53da2d229dc3e1", "patch": "@@ -0,0 +1,183 @@\n+// Copyright (C) 2001 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 25.3.3 [lib.alg.binary.search] Binary search algorithms.\n+\n+#include <algorithm>\n+#include <debug_assert.h>\n+\n+bool test = true;\n+\n+const int A[] = {1, 2, 3, 3, 3, 5, 8};\n+const int C[] = {8, 5, 3, 3, 3, 2, 1};\n+const int N = sizeof(A) / sizeof(int);\n+\n+// A comparison, equalivalent to std::greater<int> without the\n+// dependency on <functional>.\n+\n+struct gt\n+{\n+    bool\n+    operator()(const int& x, const int& y) const\n+    { return x > y; }\n+};\n+\n+// Each test performs general-case, bookend, not-found condition,\n+// and predicate functional checks.\n+\n+// 25.3.3.1 lower_bound, with and without comparison predicate\n+void\n+test01()\n+{\n+    using std::lower_bound;\n+\n+    const int first = A[0];\n+    const int last = A[N - 1];\n+\n+    const int* p = lower_bound(A, A + N, 3);\n+    VERIFY(p == A + 2);\n+\n+    const int* q = lower_bound(A, A + N, first);\n+    VERIFY(q == A + 0);\n+\n+    const int* r = lower_bound(A, A + N, last);\n+    VERIFY(r == A + N - 1);\n+\n+    const int* s = lower_bound(A, A + N, 4);\n+    VERIFY(s == A + 5);\n+\n+    const int* t = lower_bound(C, C + N, 3, gt());\n+    VERIFY(t == C + 2);\n+\n+    const int* u = lower_bound(C, C + N, first, gt());\n+    VERIFY(u == C + N - 1);\n+\n+    const int* v = lower_bound(C, C + N, last, gt());\n+    VERIFY(v == C + 0);\n+\n+    const int* w = lower_bound(C, C + N, 4, gt());\n+    VERIFY(w == C + 2);\n+}\n+\n+// 25.3.3.2 upper_bound, with and without comparison predicate\n+void\n+test02()\n+{\n+    using std::upper_bound;\n+\n+    const int first = A[0];\n+    const int last = A[N - 1];\n+\n+    const int* p = upper_bound(A, A + N, 3);\n+    VERIFY(p == A + 5);\n+\n+    const int* q = upper_bound(A, A + N, first);\n+    VERIFY(q == A + 1);\n+\n+    const int* r = upper_bound(A, A + N, last);\n+    VERIFY(r == A + N);\n+\n+    const int* s = upper_bound(A, A + N, 4);\n+    VERIFY(s == A + 5);\n+\n+    const int* t = upper_bound(C, C + N, 3, gt());\n+    VERIFY(t == C + 5);\n+\n+    const int* u = upper_bound(C, C + N, first, gt());\n+    VERIFY(u == C + N);\n+\n+    const int* v = upper_bound(C, C + N, last, gt());\n+    VERIFY(v == C + 1);\n+\n+    const int* w = upper_bound(C, C + N, 4, gt());\n+    VERIFY(w == C + 2);\n+}\n+\n+// 25.3.3.3 equal_range, with and without comparison predicate\n+void\n+test03()\n+{\n+    using std::equal_range;\n+    typedef std::pair<const int*, const int*> Ipair;\n+    \n+    const int first = A[0];\n+    const int last = A[N - 1];\n+\n+    Ipair p = equal_range(A, A + N, 3);\n+    VERIFY(p.first == A + 2);\n+    VERIFY(p.second == A + 5);\n+    \n+    Ipair q = equal_range(A, A + N, first);\n+    VERIFY(q.first == A + 0);\n+    VERIFY(q.second == A + 1);\n+    \n+    Ipair r = equal_range(A, A + N, last);\n+    VERIFY(r.first == A + N - 1);\n+    VERIFY(r.second == A + N);\n+    \n+    Ipair s = equal_range(A, A + N, 4);\n+    VERIFY(s.first == A + 5);\n+    VERIFY(s.second == A + 5);\n+    \n+    Ipair t = equal_range(C, C + N, 3, gt());\n+    VERIFY(t.first == C + 2);\n+    VERIFY(t.second == C + 5);\n+    \n+    Ipair u = equal_range(C, C + N, first, gt());\n+    VERIFY(u.first == C + N - 1);\n+    VERIFY(u.second == C + N);\n+    \n+    Ipair v = equal_range(C, C + N, last, gt());\n+    VERIFY(v.first == C + 0);\n+    VERIFY(v.second == C + 1);\n+    \n+    Ipair w = equal_range(C, C + N, 4, gt());\n+    VERIFY(w.first == C + 2);\n+    VERIFY(w.second == C + 2);\n+}\n+\n+// 25.3.3.4 binary_search, with and without comparison predicate\n+void\n+test04()\n+{\n+    using std::binary_search;\n+    \n+    const int first = A[0];\n+    const int last = A[N - 1];\n+\n+    VERIFY(binary_search(A, A + N, 5));\n+    VERIFY(binary_search(A, A + N, first));\n+    VERIFY(binary_search(A, A + N, last));\n+    VERIFY(!binary_search(A, A + N, 4));\n+\n+    VERIFY(binary_search(C, C + N, 5, gt()));\n+    VERIFY(binary_search(C, C + N, first, gt()));\n+    VERIFY(binary_search(C, C + N, last, gt()));\n+    VERIFY(!binary_search(C, C + N, 4, gt()));\n+}\n+\n+int\n+main(int argc, char* argv[])\n+{\n+    test01();\n+    test02();\n+    test03();\n+    test04();\n+\n+    return !test;\n+}"}, {"sha": "f08694f28b3ca06ddd8d879cc4106e4b517b2e74", "filename": "libstdc++-v3/testsuite/25_algorithms/copy.cc", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02d92e3b707a5433814ca22aab53da2d229dc3e1/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fcopy.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02d92e3b707a5433814ca22aab53da2d229dc3e1/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fcopy.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fcopy.cc?ref=02d92e3b707a5433814ca22aab53da2d229dc3e1", "patch": "@@ -0,0 +1,58 @@\n+// Copyright (C) 2001 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without Pred the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 25.2.12 [lib.alg.partitions] Partitions.\n+\n+#include <algorithm>\n+#include <debug_assert.h>\n+\n+bool test = true;\n+\n+const int A[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17};\n+const int N = sizeof(A) / sizeof(int);\n+\n+// copy\n+void\n+test01()\n+{\n+    using std::copy;\n+\n+    int s1[N];\n+    copy(A, A + N, s1);\n+    VERIFY(std::equal(s1, s1 + N, A));\n+}\n+\n+// copy_backward\n+void\n+test02()\n+{\n+    using std::copy_backward;\n+\n+    int s1[N];\n+    copy_backward(A, A + N, s1 + N);\n+    VERIFY(std::equal(s1, s1 + N, A));\n+}\n+\n+int\n+main(int argc, char* argv[])\n+{\n+    test01();\n+    test02();\n+\n+    return !test;\n+}"}, {"sha": "452b6aaa905b194c4ba87aa24790e36ac17b6f97", "filename": "libstdc++-v3/testsuite/25_algorithms/heap.cc", "status": "added", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02d92e3b707a5433814ca22aab53da2d229dc3e1/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fheap.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02d92e3b707a5433814ca22aab53da2d229dc3e1/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fheap.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fheap.cc?ref=02d92e3b707a5433814ca22aab53da2d229dc3e1", "patch": "@@ -0,0 +1,132 @@\n+// Copyright (C) 2001 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without Pred the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 25.3.6 Heap operations [lib.alg.heap.operations]\n+\n+#include <algorithm>\n+//#include <cmath>\n+#include <debug_assert.h>\n+\n+bool test = true;\n+\n+const int A[] = {1, 11, 12, 3, 10, 6, 17, 4, 8, 2, 5, 13, 9, 15, 14, 16, 7};\n+const int B[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17};\n+const int C[] = {17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1};\n+const int N = sizeof(A) / sizeof(int);\n+\n+// This functor has the equivalent functionality of std::geater<>,\n+// but there is no dependency on <functional> and it also tracks the\n+// number of invocations since creation.\n+class Gt\n+{\n+public:\n+    static int count() { return itsCount; }\n+    static void reset() { itsCount = 0; }\n+\n+    bool\n+    operator()(const int& x, const int& y)\n+    {\n+        ++itsCount;\n+        return x > y; \n+    }\n+\n+private:\n+    static int itsCount;\n+};\n+\n+int Gt::itsCount = 0;\n+\n+// Exercise all of the heap functions for operator<.  The\n+// intermediate results between push_heap and pop_heap and\n+// make_heap and sort_heap are not checked (they could be).\n+void\n+test01()\n+{\n+    // sort array s1 using push_heap/pop_heap\n+    int s1[N];\n+    std::copy(A, A + N, s1);\n+    VERIFY(std::equal(s1, s1 + N, A));\n+\n+    for (int i = 2; i <= N; ++i) {\n+        std::push_heap(s1, s1 + i);\n+    }\n+    for (int i = N; i >= 2; --i) {\n+        std::pop_heap(s1, s1 + i);\n+    }\n+    VERIFY(std::equal(s1, s1 + N, B));\n+\n+    // sort array s2 using make_heap/sort_heap\n+    int s2[N];\n+    std::copy(A, A + N, s2);\n+    VERIFY(std::equal(s2, s2 + N, A));\n+\n+    std::make_heap(s2, s2 + N);\n+    std::sort_heap(s2, s2 + N);\n+    VERIFY(std::equal(s2, s2 + N, B));\n+}\n+\n+// Perform same tests as above but with the comparison predicate\n+// versions, and add complexity constraint checks.\n+void\n+test02()\n+{\n+    Gt gt;\n+//    const int logN = static_cast<int>(std::log(static_cast<double>(N)) + 0.5);\n+    const int logN = 3;\n+\n+    int s1[N];\n+    std::copy(A, A + N, s1);\n+    VERIFY(std::equal(s1, s1 + N, A));\n+\n+    for (int i = 2; i <= N; ++i) {\n+        std::push_heap(s1, s1 + i, gt);\n+        VERIFY(gt.count() <= logN);\n+        gt.reset();\n+    }\n+\n+    for (int i = N; i >= 2; --i) {\n+        std::pop_heap(s1, s1 + i, gt);\n+        VERIFY(gt.count() <= 2 * logN);\n+        gt.reset();\n+    }\n+\n+    VERIFY(std::equal(s1, s1 + N, C));\n+\n+    // sort array s2 using make_heap/sort_heap\n+    int s2[N];\n+    std::copy(A, A + N, s2);\n+    VERIFY(std::equal(s2, s2 + N, A));\n+\n+    std::make_heap(s2, s2 + N, gt);\n+    VERIFY(gt.count() <= 3 * N);\n+    gt.reset();\n+\n+    std::sort_heap(s2, s2 + N, gt);\n+    VERIFY(gt.count() <= N * logN);\n+\n+    VERIFY(std::equal(s2, s2 + N, C));\n+}\n+\n+int\n+main(int argc, char* argv[])\n+{\n+    test01();\n+    test02();\n+\n+    return !test;\n+}"}, {"sha": "6623cd3f0ed153ef6e9865e7ed23fc5331c8f00f", "filename": "libstdc++-v3/testsuite/25_algorithms/partition.cc", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02d92e3b707a5433814ca22aab53da2d229dc3e1/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpartition.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02d92e3b707a5433814ca22aab53da2d229dc3e1/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpartition.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fpartition.cc?ref=02d92e3b707a5433814ca22aab53da2d229dc3e1", "patch": "@@ -0,0 +1,73 @@\n+// Copyright (C) 2001 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without Pred the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 25.2.12 [lib.alg.partitions] Partitions.\n+\n+#include <algorithm>\n+#include <functional>\n+#include <debug_assert.h>\n+\n+bool test = true;\n+\n+const int A[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17};\n+const int B[] = {2, 4, 6, 8, 10, 12, 14, 16, 1, 3, 5, 7, 9, 11, 13, 15, 17};\n+const int N = sizeof(A) / sizeof(int);\n+\n+struct Pred\n+{\n+    bool\n+    operator()(const int& x) const\n+    { return (x % 2) == 0; }\n+};\n+\n+// 25.2.12 partition()\n+void\n+test01()\n+{\n+    using std::partition;\n+\n+    int s1[N];\n+    std::copy(A, A + N, s1);\n+\n+    Pred pred;\n+    int* m = partition(s1, s1 + N, pred);\n+    for (const int* i = s1; i < m; ++i) VERIFY(pred(*i));\n+    for (const int* i = m; i < s1 + N; ++i) VERIFY(!pred(*i));\n+}\n+\n+// 25.2.12 stable_partition()\n+void\n+test02()\n+{\n+    using std::stable_partition;\n+\n+    int s1[N];\n+    std::copy(A, A + N, s1);\n+\n+    stable_partition(s1, s1 + N, Pred());\n+    VERIFY(std::equal(s1, s1 + N, B));\n+}\n+\n+int\n+main(int argc, char* argv[])\n+{\n+    test01();\n+    test02();\n+\n+    return !test;\n+}"}, {"sha": "e80d3cd3cd39575dd8c43e5be6fda7e72410f6e6", "filename": "libstdc++-v3/testsuite/25_algorithms/rotate.cc", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02d92e3b707a5433814ca22aab53da2d229dc3e1/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Frotate.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02d92e3b707a5433814ca22aab53da2d229dc3e1/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Frotate.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Frotate.cc?ref=02d92e3b707a5433814ca22aab53da2d229dc3e1", "patch": "@@ -0,0 +1,80 @@\n+// Copyright (C) 2001 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 25.?? algorithms, rotate()\n+\n+#include <algorithm>\n+#include <debug_assert.h>\n+#include <list>\n+\n+bool test = true;\n+\n+int A[] = {1, 2, 3, 4, 5, 6, 7};\n+int B[] = {2, 3, 4, 5, 6, 7, 1};\n+int C[] = {1, 2, 3, 4, 5, 6, 7};\n+int D[] = {5, 6, 7, 1, 2, 3, 4};\n+const int N = sizeof(A) / sizeof(int);\n+\n+/* need a test for a forward iterator -- can't think of one that makes sense */\n+\n+/* biderectional iterator */\n+void\n+test02()\n+{\n+    using std::rotate;\n+    typedef std::list<int> Container;\n+\n+    Container a(A, A + N);\n+    VERIFY(std::equal(a.begin(), a.end(), A));\n+\n+    Container::iterator i = a.begin();\n+    rotate(a.begin(), ++i, a.end());\n+    VERIFY(std::equal(a.begin(), a.end(), B));\n+\n+    i = a.end();\n+    rotate(a.begin(), --i, a.end());\n+    VERIFY(std::equal(a.begin(), a.end(), C));\n+\n+    i = a.begin();\n+    std::advance(i, 3);\n+    rotate(a.begin(), ++i, a.end());\n+    VERIFY(std::equal(a.begin(), a.end(), D));\n+}\n+\n+/* random iterator */\n+void\n+test03()\n+{\n+    using std::rotate;\n+    rotate(A, A + 1, A + N);\n+    VERIFY(std::equal(A, A + N, B));\n+\n+    rotate(A, A + N - 1, A + N);\n+    VERIFY(std::equal(A, A + N, C));\n+\n+    rotate(A, A + 4, A + N);\n+    VERIFY(std::equal(A, A + N, D));\n+}\n+\n+int\n+main(int argc, char* argv[])\n+{\n+    test02();\n+    test03();\n+    return !test;\n+}"}, {"sha": "f26dd018727fb1e3e399e7408145424f6577c96d", "filename": "libstdc++-v3/testsuite/25_algorithms/sort.cc", "status": "added", "additions": 171, "deletions": 0, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02d92e3b707a5433814ca22aab53da2d229dc3e1/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fsort.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02d92e3b707a5433814ca22aab53da2d229dc3e1/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fsort.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fsort.cc?ref=02d92e3b707a5433814ca22aab53da2d229dc3e1", "patch": "@@ -0,0 +1,171 @@\n+// Copyright (C) 2001 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 25.3.1 algorithms, sort()\n+\n+#include <algorithm>\n+#include <debug_assert.h>\n+\n+bool test = true;\n+\n+const int A[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20};\n+const int B[] = {10, 20, 1, 11, 2, 12, 3, 13, 4, 14, 5, 15, 6, 16, 7, 17, 8, 18, 9, 19};\n+const int C[] = {20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1};\n+const int N = sizeof(A) / sizeof(int);\n+const int logN = 3; // ln(N) rounded up\n+const int P = 7;\n+\n+// comparison predicate for stable_sort: order by rightmost digit\n+struct CompLast\n+{\n+    bool\n+    operator()(const int x, const int y)\n+    { return x % 10 < y % 10; }\n+};\n+\n+// This functor has the equivalent functionality of std::geater<>,\n+// but there is no dependency on <functional> and it also tracks the\n+// number of invocations since creation.\n+class Gt\n+{\n+public:\n+    static int count() { return itsCount; }\n+    static void reset() { itsCount = 0; }\n+\n+    bool\n+    operator()(const int& x, const int& y)\n+    {\n+        ++itsCount;\n+        return x > y; \n+    }\n+\n+private:\n+    static int itsCount;\n+};\n+\n+int Gt::itsCount = 0;\n+\n+\n+// 25.3.1.1 sort()\n+void\n+test01()\n+{\n+    int s1[N];\n+    std::copy(B, B + N, s1);\n+    VERIFY(std::equal(s1, s1 + N, B));\n+\n+    std::sort(s1, s1 + N);\n+    VERIFY(std::equal(s1, s1 + N, A));\n+\n+    Gt gt;\n+    gt.reset();\n+    std::sort(s1, s1 + N, gt);\n+    VERIFY(std::equal(s1, s1 + N, C));\n+}\n+\n+// 25.3.1.2 stable_sort()\n+void\n+test02()\n+{\n+    int s1[N];\n+    std::copy(A, A + N, s1);\n+    VERIFY(std::equal(s1, s1 + N, A));\n+\n+    std::stable_sort(s1, s1 + N, CompLast());\n+    VERIFY(std::equal(s1, s1 + N, B));\n+\n+    std::stable_sort(s1, s1 + N);\n+    VERIFY(std::equal(s1, s1 + N, A));\n+\n+    Gt gt;\n+    gt.reset();\n+    std::stable_sort(s1, s1 + N, gt);\n+    VERIFY(std::equal(s1, s1 + N, C));\n+    VERIFY(gt.count() <= N * logN * logN);\n+}\n+\n+// 25.3.1.3 partial_sort()\n+void\n+test03()\n+{\n+    int s1[N];\n+    std::copy(B, B + N, s1);\n+    VERIFY(std::equal(s1, s1 + N, B));\n+\n+    std::partial_sort(s1, s1 + P, s1 + N);\n+    VERIFY(std::equal(s1, s1 + P, A));\n+\n+    Gt gt;\n+    gt.reset();\n+    std::partial_sort(s1, s1 + P, s1 + N, gt);\n+    VERIFY(std::equal(s1, s1 + P, C));\n+}\n+\n+// 25.3.1.4 partial_sort_copy()\n+void\n+test04()\n+{\n+    using std::partial_sort_copy;\n+\n+    int s1[N];\n+    std::copy(B, B + N, s1);\n+    VERIFY(std::equal(s1, s1 + N, B));\n+\n+    int s2[2*N];\n+\n+    partial_sort_copy(s1, s1 + N, s2, s2 + P);\n+    VERIFY(std::equal(s2, s2 + P, A));\n+\n+    Gt gt;\n+    gt.reset();\n+    partial_sort_copy(s1, s1 + N, s2, s2 + P, gt);\n+    VERIFY(std::equal(s2, s2 + P, C));\n+\n+    VERIFY(std::equal(s2, partial_sort_copy(s1, s1 + N, s2, s2 + 2*N), A));\n+}\n+\n+// 25.3.2 nth_element()\n+void\n+test05()\n+{\n+    using std::nth_element;\n+\n+    int s1[N];\n+    std::copy(B, B + N, s1);\n+    VERIFY(std::equal(s1, s1 + N, B));\n+\n+    int* pn = s1 + (N / 2) - 1;\n+    nth_element(s1, pn, s1 + N);\n+    for (const int* i = pn; i < s1 + N; ++i) VERIFY(!(*i < *pn));\n+\n+    CompLast pred;\n+    nth_element(s1, pn, s1 + N, pred);\n+    for (const int* i = pn; i < s1 + N; ++i) VERIFY(!pred(*i, *pn));\n+}\n+\n+int\n+main(int argc, char* argv[])\n+{\n+    test01();\n+    test02();\n+    test03();\n+    test04();\n+    test05();\n+\n+    return !test;\n+}"}, {"sha": "ffc4e639c1c97fe8eeb7279a336de6a8273cbd08", "filename": "libstdc++-v3/testsuite/26_numerics/sum_diff.cc", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02d92e3b707a5433814ca22aab53da2d229dc3e1/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fsum_diff.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02d92e3b707a5433814ca22aab53da2d229dc3e1/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fsum_diff.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fsum_diff.cc?ref=02d92e3b707a5433814ca22aab53da2d229dc3e1", "patch": "@@ -0,0 +1,47 @@\n+// Copyright (C) 2001 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 26.4.3 [lib.partial.sum]\n+// 26.4.4 [lib.adjacent.difference]\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <cassert>\n+\n+int A[] = {1, 4, 9, 16, 25, 36, 49, 64, 81, 100};\n+int B[] = {1, 3, 5, 7, 9, 11, 13, 15, 17, 19};\n+const int N = sizeof(A) / sizeof(int);\n+\n+void\n+test01()\n+{\n+    int D[N];\n+\n+    std::adjacent_difference(A, A + N, D);\n+    assert(std::equal(D, D + N, B));\n+\n+    std::partial_sum(D, D + N, D);\n+    assert(std::equal(D, D + N, A));\n+}\n+\n+int\n+main(int argc, char* argv[])\n+{\n+    test01();\n+    return 0;\n+}"}, {"sha": "1af4d4e6d0c3774c424ed5984d837aa001dc67e7", "filename": "libstdc++-v3/testsuite/Makefile.in", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02d92e3b707a5433814ca22aab53da2d229dc3e1/libstdc%2B%2B-v3%2Ftestsuite%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02d92e3b707a5433814ca22aab53da2d229dc3e1/libstdc%2B%2B-v3%2Ftestsuite%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2FMakefile.in?ref=02d92e3b707a5433814ca22aab53da2d229dc3e1", "patch": "@@ -128,14 +128,10 @@ AUTOMAKE_OPTIONS = foreign dejagnu\n \n DEJATOOL = libstdc++-v3\n \n-EXPECT = `if [ -f @glibcpp_builddir@/../../expect/expect ] ; then \\\n-            echo @glibcpp_builddir@/../../expect/expect ; \\\n-          else echo expect ; fi`\n+EXPECT = `if [ -f @glibcpp_builddir@/../../expect/expect ] ; then             echo @glibcpp_builddir@/../../expect/expect ;           else echo expect ; fi`\n \n \n-RUNTEST = `if [ -f @glibcpp_srcdir@/../dejagnu/runtest ] ; then \\\n-\t       echo @glibcpp_srcdir@/../dejagnu/runtest ; \\\n-\t    else echo runtest; fi`\n+RUNTEST = `if [ -f @glibcpp_srcdir@/../dejagnu/runtest ] ; then \t       echo @glibcpp_srcdir@/../dejagnu/runtest ; \t    else echo runtest; fi`\n \n \n RUNTESTFLAGS = "}]}