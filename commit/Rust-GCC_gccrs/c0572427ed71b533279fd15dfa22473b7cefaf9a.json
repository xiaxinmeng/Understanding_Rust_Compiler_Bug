{"sha": "c0572427ed71b533279fd15dfa22473b7cefaf9a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzA1NzI0MjdlZDcxYjUzMzI3OWZkMTVkZmEyMjQ3M2I3Y2VmYWY5YQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2005-11-07T03:47:34Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2005-11-07T03:47:34Z"}, "message": "class.c (record_subobject_offsets): Don't record offsets past biggest empty class for non-empty base classes.\n\n\t* class.c (record_subobject_offsets): Don't record offsets past\n\tbiggest empty class for non-empty base classes.\n\t(layout_class_type): Use TYPE_SIZE_UNIT, not TYPE_SIZE, when\n\tkeeping track of the size of emptyclasses.\n\nFrom-SVN: r106580", "tree": {"sha": "04f9640c29d5faec46b76728cab7f25912d08710", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/04f9640c29d5faec46b76728cab7f25912d08710"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c0572427ed71b533279fd15dfa22473b7cefaf9a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0572427ed71b533279fd15dfa22473b7cefaf9a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c0572427ed71b533279fd15dfa22473b7cefaf9a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0572427ed71b533279fd15dfa22473b7cefaf9a/comments", "author": null, "committer": null, "parents": [{"sha": "405a3684f54d08c4e3e4612a90fb83b99db5247a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/405a3684f54d08c4e3e4612a90fb83b99db5247a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/405a3684f54d08c4e3e4612a90fb83b99db5247a"}], "stats": {"total": 34, "additions": 21, "deletions": 13}, "files": [{"sha": "86b9decf5e2292bcea34a066f09f5b0b81136e48", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0572427ed71b533279fd15dfa22473b7cefaf9a/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0572427ed71b533279fd15dfa22473b7cefaf9a/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=c0572427ed71b533279fd15dfa22473b7cefaf9a", "patch": "@@ -1,5 +1,10 @@\n 2005-11-06  Mark Mitchell  <mark@codesourcery.com>\n \n+\t* class.c (record_subobject_offsets): Don't record offsets past\n+\tbiggest empty class for non-empty base classes.\n+\t(layout_class_type): Use TYPE_SIZE_UNIT, not TYPE_SIZE, when\n+\tkeeping track of the size of emptyclasses.\n+\n \tPR c++/21308\n \t* class.c (sizeof_biggest_empty_class): New variable.\n \t(record_subobject_offsets): Don't record offsets past biggest"}, {"sha": "7c43d3b242ed3af3d2f5b0984af1c4329655d54b", "filename": "gcc/cp/class.c", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0572427ed71b533279fd15dfa22473b7cefaf9a/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0572427ed71b533279fd15dfa22473b7cefaf9a/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=c0572427ed71b533279fd15dfa22473b7cefaf9a", "patch": "@@ -3286,8 +3286,8 @@ walk_subobject_offsets (tree type,\n   return 0;\n }\n \n-/* Record all of the empty subobjects of TYPE (located at OFFSET) in\n-   OFFSETS.  If IS_DATA_MEMBER is true, then a non-static data member\n+/* Record all of the empty subobjects of TYPE (either a type or a\n+   binfo).  If IS_DATA_MEMBER is true, then a non-static data member\n    is being placed at OFFSET; otherwise, it is a base class that is\n    being placed at OFFSET.  */\n \n@@ -3298,19 +3298,21 @@ record_subobject_offsets (tree type,\n \t\t\t  bool is_data_member)\n {\n   tree max_offset;\n-  /* If recording subobjects for a non-static data member, do not need\n-     to record offsets beyond the size of the biggest empty class.\n-     Additional data members will go at the end of the class.\n-     Additional base classes will go either at offset zero (if empty,\n-     in which case they cannot overlap with offsets past the size of\n-     the biggest empty class) or at the end of the class.  \n-\n-     However, if we are placing an empty class, then we must record\n+  /* If recording subobjects for a non-static data member or a\n+     non-empty base class , we do not need to record offsets beyond\n+     the size of the biggest empty class.  Additional data members\n+     will go at the end of the class.  Additional base classes will go\n+     either at offset zero (if empty, in which case they cannot\n+     overlap with offsets past the size of the biggest empty class) or\n+     at the end of the class.\n+\n+     However, if we are placing an empty base class, then we must record\n      all offsets, as either the empty class is at offset zero (where\n      other empty classes might later be placed) or at the end of the\n      class (where other objects might then be placed, so other empty\n      subobjects might later overlap).  */\n-  if (is_data_member)\n+  if (is_data_member \n+      || !is_empty_class (BINFO_TYPE (type)))\n     max_offset = sizeof_biggest_empty_class;\n   else\n     max_offset = NULL_TREE;\n@@ -4850,8 +4852,9 @@ layout_class_type (tree t, tree *virtuals_p)\n   splay_tree_delete (empty_base_offsets);\n \n   if (CLASSTYPE_EMPTY_P (t)\n-      && tree_int_cst_lt (sizeof_biggest_empty_class, TYPE_SIZE (t)))\n-    sizeof_biggest_empty_class = TYPE_SIZE (t);\n+      && tree_int_cst_lt (sizeof_biggest_empty_class, \n+\t\t\t  TYPE_SIZE_UNIT (t)))\n+    sizeof_biggest_empty_class = TYPE_SIZE_UNIT (t);\n }\n \n /* Determine the \"key method\" for the class type indicated by TYPE,"}]}