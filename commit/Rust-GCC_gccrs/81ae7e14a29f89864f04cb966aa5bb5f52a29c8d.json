{"sha": "81ae7e14a29f89864f04cb966aa5bb5f52a29c8d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODFhZTdlMTRhMjlmODk4NjRmMDRjYjk2NmFhNWJiNWY1MmEyOWM4ZA==", "commit": {"author": {"name": "Jeremie Salvucci", "email": "jeremie.salvucci@free.fr", "date": "2010-11-22T07:35:17Z"}, "committer": {"name": "Basile Starynkevitch", "email": "bstarynk@gcc.gnu.org", "date": "2010-11-22T07:35:17Z"}, "message": "gengtype.c: Include xregex.h and obstack.h Added comments about role of...\n\n\n2010-11-22  Jeremie Salvucci  <jeremie.salvucci@free.fr>\n\t    Basile Starynkevitch  <basile@starynkevitch.net>\n\n\t* gengtype.c: Include xregex.h and obstack.h\n\tAdded comments about role of get_output_file_with_visibility and\n\tour regexpr machinery.\n\t(frul_actionrout_t, struct file_rule_st): New.\n\t(hader_dot_h_frul, source_dot_c_frul): New functions.\n\t(NULL_REGEX,  NULL_FRULACT): New.\n\t(files_rules): New.\n\t(matching_file_name_substitute): New function.\n\t(get_output_file_with_visibility): Updated comments and rewritten\n\tto use the new files_rules machinery.\n\n        * Makefile.in (XREGEX_H): Added variable.\n        (build/gengtype.o): Added dependencies for xregex.h and obstack.h\n\n\nCo-Authored-By: Basile Starynkevitch <basile@starynkevitch.net>\n\nFrom-SVN: r167024", "tree": {"sha": "06663069ba20f7ad4b204eb33762496833536e81", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/06663069ba20f7ad4b204eb33762496833536e81"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/81ae7e14a29f89864f04cb966aa5bb5f52a29c8d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81ae7e14a29f89864f04cb966aa5bb5f52a29c8d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/81ae7e14a29f89864f04cb966aa5bb5f52a29c8d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81ae7e14a29f89864f04cb966aa5bb5f52a29c8d/comments", "author": null, "committer": null, "parents": [{"sha": "b27c742b220779e98728059b1dd252ca1ee7e604", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b27c742b220779e98728059b1dd252ca1ee7e604", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b27c742b220779e98728059b1dd252ca1ee7e604"}], "stats": {"total": 436, "additions": 383, "deletions": 53}, "files": [{"sha": "b9063309f5d17b4533e9c136e96943899fcdf9ab", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81ae7e14a29f89864f04cb966aa5bb5f52a29c8d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81ae7e14a29f89864f04cb966aa5bb5f52a29c8d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=81ae7e14a29f89864f04cb966aa5bb5f52a29c8d", "patch": "@@ -1,3 +1,21 @@\n+\n+2010-11-22  Jeremie Salvucci  <jeremie.salvucci@free.fr>\n+\t    Basile Starynkevitch  <basile@starynkevitch.net>\n+\n+\t* gengtype.c: Include xregex.h and obstack.h\n+\tAdded comments about role of get_output_file_with_visibility and\n+\tour regexpr machinery.\n+\t(frul_actionrout_t, struct file_rule_st): New.\n+\t(hader_dot_h_frul, source_dot_c_frul): New functions.\n+\t(NULL_REGEX,  NULL_FRULACT): New.\n+\t(files_rules): New.\n+\t(matching_file_name_substitute): New function.\n+\t(get_output_file_with_visibility): Updated comments and rewritten\n+\tto use the new files_rules machinery.\n+\n+        * Makefile.in (XREGEX_H): Added variable.\n+        (build/gengtype.o): Added dependencies for xregex.h and obstack.h\n+\n 2010-11-21  Nathan Froyd  <froydnj@codesourcery.com>\n \n \t* system.h (FUNCTION_ARG_BOUNDARY): Really poison."}, {"sha": "08da89d0c75066949b2a827cc69509b046bb3bd8", "filename": "gcc/Makefile.in", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81ae7e14a29f89864f04cb966aa5bb5f52a29c8d/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81ae7e14a29f89864f04cb966aa5bb5f52a29c8d/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=81ae7e14a29f89864f04cb966aa5bb5f52a29c8d", "patch": "@@ -433,6 +433,7 @@ FIBHEAP_H   = $(srcdir)/../include/fibheap.h\n PARTITION_H = $(srcdir)/../include/partition.h\n MD5_H\t    = $(srcdir)/../include/md5.h\n DWARF2_H    = $(srcdir)/../include/dwarf2.h\n+XREGEX_H    =  $(srcdir)/../include/xregex.h\n \n # Linker plugin API headers\n LINKER_PLUGIN_API_H = $(srcdir)/../include/plugin-api.h\n@@ -3914,7 +3915,8 @@ build/gengtype-lex.o : gengtype-lex.c gengtype.h $(BCONFIG_H) $(SYSTEM_H)\n build/gengtype-parse.o : gengtype-parse.c gengtype.h $(BCONFIG_H)\t\\\n   $(SYSTEM_H)\n build/gengtype.o : gengtype.c $(BCONFIG_H) $(SYSTEM_H) gengtype.h \t\\\n-  rtl.def insn-notes.def errors.h double-int.h $(HASHTAB_H)\n+  rtl.def insn-notes.def errors.h double-int.h $(HASHTAB_H)             \\\n+  $(OBSTACK_H) $(XREGEX_H)\n build/genmddeps.o: genmddeps.c $(BCONFIG_H) $(SYSTEM_H) coretypes.h\t\\\n   errors.h $(READ_MD_H)\n build/genmodes.o : genmodes.c $(BCONFIG_H) $(SYSTEM_H) errors.h\t\t\\"}, {"sha": "d24623491a9511763da11bf0d4894a3fe39bc59f", "filename": "gcc/gengtype.c", "status": "modified", "additions": 362, "deletions": 52, "changes": 414, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81ae7e14a29f89864f04cb966aa5bb5f52a29c8d/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81ae7e14a29f89864f04cb966aa5bb5f52a29c8d/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=81ae7e14a29f89864f04cb966aa5bb5f52a29c8d", "patch": "@@ -25,6 +25,8 @@\n #include \"double-int.h\"\n #include \"version.h\"\t\t/* for version_string & pkgversion_string.  */\n #include \"hashtab.h\"\n+#include \"xregex.h\"\n+#include \"obstack.h\"\n #include \"gengtype.h\"\n \n /* Data types, macros, etc. used only in this file.  */\n@@ -1727,6 +1729,251 @@ get_file_gtfilename (const input_file *inpf)\n   return result;\n }\n \n+/* Each input_file has its associated output file outf_p.  The\n+   association is computed by the function\n+   get_output_file_with_visibility.  The associated file is cached\n+   inside input_file in its inpoutf field, so is really computed only\n+   once.  Associated output file paths (i.e. output_name-s) are\n+   computed by a rule based regexp machinery, using the files_rules\n+   array of struct file_rule_st.  A for_name is also computed, giving\n+   the source file name for which the output_file is generated; it is\n+   often the last component of the input_file path.  */\n+\n+\n+/*\n+ Regexpr machinery to compute the output_name and for_name-s of each\n+ input_file.  We have a sequence of file rules which gives the POSIX\n+ extended regular expression to match an input file path, and two\n+ transformed strings for the corresponding output_name and the\n+ corresponding for_name.  The transformed string contain dollars: $0\n+ is replaced by the entire match, $1 is replaced by the substring\n+ matching the first parenthesis in the regexp, etc.  And $$ is replaced\n+ by a single verbatim dollar.  The rule order is important.  The\n+ general case is last, and the particular cases should come before.\n+ An action routine can, when needed, update the out_name & for_name\n+ and/or return the appropriate output file.  It is invoked only when a\n+ rule is triggered.  When a rule is triggered, the output_name and\n+ for_name are computed using their transform string in while $$, $0,\n+ $1, ... are suitably replaced.  If there is an action, it is called.\n+ In some few cases, the action can directly return the outf_p, but\n+ usually it just updates the output_name and for_name so should free\n+ them before replacing them.  The get_output_file_with_visibility\n+ function creates an outf_p only once per each output_name, so it\n+ scans the output_files list for previously seen output file names.\n+ */\n+\n+/* Signature of actions in file rules.  */\n+typedef outf_p (frul_actionrout_t) (input_file*, char**, char**);\n+\n+\n+struct file_rule_st {\n+  const char* frul_srcexpr;\t/* Source string for regexp.  */\n+  int frul_rflags;\t\t/* Flags passed to regcomp, usually\n+\t\t\t\t * REG_EXTENDED.  */\n+  regex_t* frul_re;\t\t/* Compiled regular expression\n+\t\t\t\t   obtained by regcomp.  */\n+  const char* frul_tr_out;\t/* Transformation string for making\n+\t\t\t\t * the output_name, with $1 ... $9 for\n+\t\t\t\t * subpatterns and $0 for the whole\n+\t\t\t\t * matched filename.  */\n+  const char* frul_tr_for;\t/* Tranformation string for making the\n+\t\t\t\t   for_name.  */\n+  frul_actionrout_t* frul_action; /* The action, if non null, is\n+\t\t\t\t   * called once the rule matches, on\n+\t\t\t\t   * the transformed out_name &\n+\t\t\t\t   * for_name.  It could change them\n+\t\t\t\t   * and/or give the output file.  */\n+};\n+\n+/* File rule action handling *.h files.  */\n+static outf_p header_dot_h_frul (input_file*, char**, char**);\n+\n+/* File rule action handling *.c files.  */\n+static outf_p source_dot_c_frul (input_file*, char**, char**);\n+\n+#define NULL_REGEX (regex_t*)0\n+\n+/* The prefix in our regexp-s matching the directory.  */\n+#define DIR_PREFIX_REGEX \"^(([^/]*/)*)\"\n+\n+#define NULL_FRULACT (frul_actionrout_t*)0\n+\n+/* The array of our rules governing file name generation.  Rules order\n+   matters, so change with extreme care!  */\n+\n+struct file_rule_st files_rules[] = {\n+  /* the c-family/ source directory is special.  */\n+  { DIR_PREFIX_REGEX \"c-family/([[:alnum:]_-]*)\\\\.c$\",\n+    REG_EXTENDED, NULL_REGEX,\n+    \"gt-c-family-$3.h\", \"c-family/$3.c\", NULL_FRULACT},\n+\n+  { DIR_PREFIX_REGEX \"c-family/([[:alnum:]_-]*)\\\\.h$\",\n+    REG_EXTENDED, NULL_REGEX,\n+    \"gt-c-family-$3.h\", \"c-family/$3.h\", NULL_FRULACT},\n+\n+  /* Both c-lang.h & c-tree.h gives gt-c-decl.h for c-decl.c !  */\n+  { DIR_PREFIX_REGEX \"c-lang\\\\.h$\",\n+    REG_EXTENDED, NULL_REGEX, \"gt-c-decl.h\", \"c-decl.c\", NULL_FRULACT},\n+\n+  { DIR_PREFIX_REGEX \"c-tree\\\\.h$\",\n+    REG_EXTENDED, NULL_REGEX, \"gt-c-decl.h\", \"c-decl.c\", NULL_FRULACT},\n+\n+  /* cp/cp-tree.h gives gt-cp-tree.h for cp/tree.c !  */\n+  { DIR_PREFIX_REGEX \"cp/cp-tree\\\\.h$\",\n+    REG_EXTENDED, NULL_REGEX,\n+    \"gt-cp-tree.h\", \"cp/tree.c\", NULL_FRULACT },\n+\n+  /* cp/decl.h & cp/decl.c gives gt-cp-decl.h for cp/decl.c !  */\n+  { DIR_PREFIX_REGEX \"cp/decl\\\\.[ch]$\",\n+    REG_EXTENDED, NULL_REGEX,\n+    \"gt-cp-decl.h\", \"cp/decl.c\", NULL_FRULACT },\n+\n+  /* cp/name-lookup.h gives gt-cp-name-lookup.h for cp/name-lookup.c !  */\n+  { DIR_PREFIX_REGEX \"cp/name-lookup\\\\.h$\",\n+    REG_EXTENDED, NULL_REGEX,\n+    \"gt-cp-name-lookup.h\", \"cp/name-lookup.c\", NULL_FRULACT },\n+\n+  /* objc/objc-act.h fives gt-objc-objc-act.h for objc/objc-act.c !  */\n+  { DIR_PREFIX_REGEX \"objc/objc-act\\\\.h$\",\n+    REG_EXTENDED, NULL_REGEX,\n+    \"gt-objc-objc-act.h\", \"objc/objc-act.c\", NULL_FRULACT },\n+\n+  /* General cases.  For header *.h and source *.c files, we need\n+   * special actions to handle the language.  */\n+\n+  /* Source *.c files are using get_file_gtfilename to compute their\n+     output_name and get_file_basename to compute their for_name\n+     thru the source_dot_c_frul action.  */\n+  { DIR_PREFIX_REGEX \"([[:alnum:]_-]*)\\\\.c$\",\n+    REG_EXTENDED, NULL_REGEX, \"gt-$3.h\", \"$3.c\", source_dot_c_frul},\n+  /* Common header files get \"gtype-desc.c\" as their output_name,\n+   * while language specific header files are handled specially.  So\n+   * we need the header_dot_h_frul action.  */\n+  { DIR_PREFIX_REGEX \"([[:alnum:]_-]*)\\\\.h$\",\n+    REG_EXTENDED, NULL_REGEX, \"gt-$3.h\", \"$3.h\", header_dot_h_frul},\n+\n+  { DIR_PREFIX_REGEX \"([[:alnum:]_-]*)\\\\.in$\",\n+    REG_EXTENDED, NULL_REGEX, \"gt-$3.h\", \"$3.in\", NULL_FRULACT},\n+\n+  /* Mandatory null last entry signaling end of rules.  */\n+  {NULL, 0, NULL_REGEX, NULL, NULL, NULL_FRULACT}\n+};\n+\n+/* Special file rules action for handling *.h header files.  It gives\n+   \"gtype-desc.c\" for common headers and corresponding output\n+   files for language-specific header files.  */\n+static outf_p\n+header_dot_h_frul (input_file* inpf, char**poutname, char**pforname)\n+{\n+  const char *basename = 0;\n+  int lang_index = 0;\n+  const char *inpname = get_input_file_name (inpf);\n+  DBGPRINTF (\"inpf %p inpname %s outname %s forname %s\",\n+\t     (void*) inpf, inpname, *poutname, *pforname);\n+  basename = get_file_basename (inpf);\n+  lang_index = get_prefix_langdir_index (basename);\n+  DBGPRINTF (\"basename %s lang_index %d\", basename, lang_index);\n+\n+  if (lang_index >= 0)\n+    {\n+      /* The header is language specific.  Given output_name &\n+\t for_name remains unchanged.  The base_files array gives the\n+\t outf_p.  */\n+      DBGPRINTF (\"header_dot_h found language specific @ %p '%s'\",\n+\t\t (void*) base_files[lang_index],\n+\t\t (base_files[lang_index])->name);\n+      return base_files[lang_index];\n+    }\n+  else\n+    {\n+      /* The header is common to all front-end languages.  So\n+\t output_name is \"gtype-desc.c\" file.  The calling function\n+\t get_output_file_with_visibility will find its outf_p.  */\n+      free (*poutname);\n+      *poutname = xstrdup (\"gtype-desc.c\");\n+      DBGPRINTF (\"special 'gtype-desc.c' for inpname %s\", inpname);\n+      return NULL;\n+    }\n+}\n+\n+\n+/* Special file rules action for handling *.c source files using\n+ * get_file_gtfilename to compute their output_name and\n+ * get_file_basename to compute their for_name.  The output_name is\n+ * gt-<LANG>-<BASE>.h for language specific source files, and\n+ * gt-<BASE>.h for common source files.  */\n+static outf_p\n+source_dot_c_frul (input_file* inpf, char**poutname, char**pforname)\n+{\n+  char *newbasename = CONST_CAST (char*, get_file_basename (inpf));\n+  char *newoutname = CONST_CAST (char*, get_file_gtfilename (inpf));\n+  const char *inpname = get_input_file_name (inpf);\n+  DBGPRINTF (\"inpf %p inpname %s original outname %s forname %s\",\n+\t     (void*) inpf, inpname, *poutname, *pforname);\n+  DBGPRINTF (\"newoutname %s\", newoutname);\n+  DBGPRINTF (\"newbasename %s\", newbasename);\n+  free (*poutname);\n+  free (*pforname);\n+  *poutname = newoutname;\n+  *pforname = newbasename;\n+  return NULL;\n+}\n+\n+/* Utility function for get_output_file_with_visibility which returns\n+ * a malloc-ed substituted string using TRS on matching of the FILNAM\n+ * file name, using the PMATCH array.  */\n+static char*\n+matching_file_name_substitute (const char *filnam, regmatch_t pmatch[10],\n+\t\t\t       const char *trs)\n+{\n+  struct obstack str_obstack;\n+  char *str = NULL;\n+  char *rawstr = NULL;\n+  const char *pt = NULL;\n+  DBGPRINTF (\"filnam %s\", filnam);\n+  obstack_init (&str_obstack);\n+  for (pt = trs; *pt; pt++) {\n+    char c = *pt;\n+    if (c == '$')\n+      {\n+\tif (pt[1] == '$')\n+\t  {\n+\t    /* A double dollar $$ is substituted by a single verbatim\n+\t       dollar, but who really uses dollar signs in file\n+\t       paths? */\n+\t    obstack_1grow (&str_obstack, '$');\n+\t  }\n+\telse if (ISDIGIT (pt[1]))\n+\t  {\n+\t    /* Handle $0 $1 ... $9 by appropriate substitution.  */\n+\t    int dolnum = pt[1] - '0';\n+\t    int so = pmatch[dolnum].rm_so;\n+\t    int eo = pmatch[dolnum].rm_eo;\n+\t    DBGPRINTF (\"so=%d eo=%d dolnum=%d\", so, eo, dolnum);\n+\t    if (so>=0 && eo>=so)\n+\t      obstack_grow (&str_obstack, filnam + so, eo - so);\n+\t  }\n+\telse\n+\t  {\n+\t    /* This can happen only when files_rules is buggy! */\n+\t    gcc_unreachable();\n+\t  }\n+\t/* Always skip the character after the dollar.  */\n+\tpt++;\n+      }\n+    else\n+      obstack_1grow (&str_obstack, c);\n+  }\n+  obstack_1grow (&str_obstack, '\\0');\n+  rawstr = XOBFINISH (&str_obstack, char *);\n+  str = xstrdup (rawstr);\n+  obstack_free (&str_obstack, rawstr);\n+  DBGPRINTF (\"matched replacement %s\", str);\n+  rawstr = NULL;\n+  return str;\n+}\n+\n+\n /* An output file, suitable for definitions, that can see declarations\n    made in INPF and is linked into every language that uses INPF.\n    Since the the result is cached inside INPF, that argument cannot be\n@@ -1736,87 +1983,150 @@ outf_p\n get_output_file_with_visibility (input_file *inpf)\n {\n   outf_p r;\n-  size_t len;\n-  const char *basename;\n-  const char *for_name;\n-  const char *output_name;\n+  char *for_name = NULL;\n+  char *output_name = NULL;\n+  const char* inpfname;\n \n   /* This can happen when we need a file with visibility on a\n      structure that we've never seen.  We have to just hope that it's\n      globally visible.  */\n   if (inpf == NULL)\n     inpf = system_h_file;\n \n+  /* The result is cached in INPF, so return it if already known.  */\n+  if (inpf->inpoutf)\n+    return inpf->inpoutf;\n+\n   /* In plugin mode, return NULL unless the input_file is one of the\n      plugin_files.  */\n   if (plugin_files)\n     {\n       size_t i;\n       for (i = 0; i < nb_plugin_files; i++)\n-\tif (inpf == plugin_files[i])\n-\t  return plugin_output;\n+\tif (inpf == plugin_files[i]) \n+\t  {\n+\t    inpf->inpoutf = plugin_output;\n+\t    return plugin_output;\n+\t  }\n \n       return NULL;\n     }\n \n-  /* Determine the output file name.  */\n-  basename = get_file_basename (inpf);\n+  inpfname = get_input_file_name (inpf);\n \n-  len = strlen (basename);\n-  if ((len > 2 && memcmp (basename + len - 2, \".c\", 2) == 0)\n-      || (len > 2 && memcmp (basename + len - 2, \".y\", 2) == 0)\n-      || (len > 3 && memcmp (basename + len - 3, \".in\", 3) == 0))\n-    {\n-      output_name = get_file_gtfilename (inpf);\n-      for_name = basename;\n-    }\n-  /* Some headers get used by more than one front-end; hence, it\n-     would be inappropriate to spew them out to a single gtype-<lang>.h\n-     (and gengtype doesn't know how to direct spewage into multiple\n-     gtype-<lang>.h headers at this time).  Instead, we pair up these\n-     headers with source files (and their special purpose gt-*.h headers).  */\n-  else if (strncmp (basename, \"c-family\", 8) == 0\n-\t   && IS_DIR_SEPARATOR (basename[8])\n-\t   && strcmp (basename + 9, \"c-common.h\") == 0)\n-    output_name = \"gt-c-family-c-common.h\", for_name = \"c-family/c-common.c\";\n-  else if (strcmp (basename, \"c-lang.h\") == 0)\n-    output_name = \"gt-c-decl.h\", for_name = \"c-decl.c\";\n-  else if (strcmp (basename, \"c-tree.h\") == 0)\n-    output_name = \"gt-c-decl.h\", for_name = \"c-decl.c\";\n-  else if (strncmp (basename, \"cp\", 2) == 0 && IS_DIR_SEPARATOR (basename[2])\n-\t   && strcmp (basename + 3, \"cp-tree.h\") == 0)\n-    output_name = \"gt-cp-tree.h\", for_name = \"cp/tree.c\";\n-  else if (strncmp (basename, \"cp\", 2) == 0 && IS_DIR_SEPARATOR (basename[2])\n-\t   && strcmp (basename + 3, \"decl.h\") == 0)\n-    output_name = \"gt-cp-decl.h\", for_name = \"cp/decl.c\";\n-  else if (strncmp (basename, \"cp\", 2) == 0 && IS_DIR_SEPARATOR (basename[2])\n-\t   && strcmp (basename + 3, \"name-lookup.h\") == 0)\n-    output_name = \"gt-cp-name-lookup.h\", for_name = \"cp/name-lookup.c\";\n-  else if (strncmp (basename, \"objc\", 4) == 0\n-\t   && IS_DIR_SEPARATOR (basename[4])\n-\t   && strcmp (basename + 5, \"objc-act.h\") == 0)\n-    output_name = \"gt-objc-objc-act.h\", for_name = \"objc/objc-act.c\";\n-  else\n-    {\n-      int lang_index = get_prefix_langdir_index (basename);\n+  /* Try each rule in sequence in files_rules until one is triggered. */\n+  {\n+    int rulix = 0;\n+    DBGPRINTF (\"passing input file @ %p named %s thru the files_rules\",\n+\t       (void*) inpf, inpfname);\n+\n+    for (; files_rules[rulix].frul_srcexpr != NULL; rulix++)\n+      {\n+\tDBGPRINTF (\"rulix#%d srcexpr %s\",\n+\t\t   rulix, files_rules[rulix].frul_srcexpr);\n+\n+\tif (!files_rules[rulix].frul_re)\n+\t  {\n+\t    /* Compile the regexpr lazily.  */\n+\t    int err = 0;\n+\t    files_rules[rulix].frul_re = XCNEW (regex_t);\n+\t    err = regcomp (files_rules[rulix].frul_re,\n+\t\t\t   files_rules[rulix].frul_srcexpr,\n+\t\t\t   files_rules[rulix].frul_rflags);\n+\t    if (err)\n+\t      {\n+\t\t/* The regular expression compilation fails only when\n+\t\t   file_rules is buggy.  */\n+\t\tgcc_unreachable ();\n+\t      }\n+\t  }\n \n-      if (lang_index >= 0)\n-\treturn base_files[lang_index];\n+\toutput_name = NULL;\n+\tfor_name = NULL;\n \n-      output_name = \"gtype-desc.c\";\n-      for_name = NULL;\n+\t/* Match the regexpr and trigger the rule if matched.  */\n+\t{\n+\t  /* We have exactly ten pmatch-s, one for each $0, $1, $2,\n+\t     $3, ... $9.  */\n+\t  regmatch_t pmatch[10];\n+\t  memset (pmatch, 0, sizeof (pmatch));\n+\t  if (!regexec (files_rules[rulix].frul_re,\n+\t\t\tinpfname, 10, pmatch, 0))\n+\t    {\n+\t      DBGPRINTF (\"input @ %p filename %s matched rulix#%d pattern %s\",\n+\t\t\t (void*) inpf, inpfname, rulix,\n+\t\t\t files_rules[rulix].frul_srcexpr);\n+\t      for_name =\n+\t\tmatching_file_name_substitute (inpfname, pmatch,\n+\t\t\t\t\t       files_rules[rulix].frul_tr_for);\n+\t      DBGPRINTF (\"for_name %s\", for_name);\n+\t      output_name =\n+\t\tmatching_file_name_substitute (inpfname, pmatch,\n+\t\t\t\t\t       files_rules[rulix].frul_tr_out);\n+\t      DBGPRINTF (\"output_name %s\", output_name);\n+\t      if (files_rules[rulix].frul_action)\n+\t\t{\n+\t\t  /* Invoke our action routine.  */\n+\t\t  outf_p of = NULL;\n+\t\t  DBGPRINTF (\"before action rulix#%d output_name %s for_name %s\",\n+\t\t\t     rulix, output_name, for_name);\n+\t\t  of =\n+\t\t    (files_rules[rulix].frul_action) (inpf,\n+\t\t\t\t\t\t      &output_name, &for_name);\n+\t\t  DBGPRINTF (\"after action rulix#%d of=%p output_name %s for_name %s\",\n+\t\t\t     rulix, (void*)of, output_name, for_name);\n+\t\t  /* If the action routine returned something, give it back\n+\t\t     immediately and cache it in inpf.  */\n+\t\t  if (of)\n+\t\t    {\n+\t\t      inpf->inpoutf = of;\n+\t\t      return of;\n+\t\t    }\n+\t\t}\n+\t      /* The rule matched, and had no action, or that action did\n+\t\t not return any output file but could have changed the\n+\t\t output_name or for_name.  We break out of the loop on the\n+\t\t files_rules.  */\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      /* The regexpr did not match.  */\n+\t      DBGPRINTF (\"rulix#%d did not match %s pattern %s\",\n+\t\t\t rulix, inpfname, files_rules[rulix].frul_srcexpr);\n+\t      continue;\n+\t    }\n+\t}\n+      }\n+  }\n+  if (!output_name || !for_name)\n+    {\n+      /* This is impossible, and could only happen if the files_rules is\n+\t incomplete or buggy.  */\n+      gcc_unreachable ();\n     }\n \n-  /* Look through to see if we've ever seen this output filename before.  */\n+  /* Look through to see if we've ever seen this output filename\n+     before.  If found, cache the result in inpf.  */\n   for (r = output_files; r; r = r->next)\n     if (strcmp (r->name, output_name) == 0)\n-      return r;\n+      {\n+\tinpf->inpoutf = r;\n+\tDBGPRINTF (\"found r @ %p for output_name %s for_name %s\", (void*)r,\n+\t\t   output_name, for_name);\n+\treturn r;\n+      }\n \n-  /* If not, create it.  */\n+  /* If not found, create it, and cache it in inpf.  */\n   r = create_file (for_name, output_name);\n \n   gcc_assert (r && r->name);\n+  DBGPRINTF (\"created r @ %p for output_name %s for_name %s\", (void*) r,\n+\t     output_name, for_name);\n+  inpf->inpoutf = r;\n   return r;\n+\n+\n }\n \n /* The name of an output file, suitable for definitions, that can see"}]}