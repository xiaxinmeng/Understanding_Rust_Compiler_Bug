{"sha": "7a1bdd662bc670ee14646b371699c724df3ba643", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2ExYmRkNjYyYmM2NzBlZTE0NjQ2YjM3MTY5OWM3MjRkZjNiYTY0Mw==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2017-11-06T15:51:16Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2017-11-06T15:51:16Z"}, "message": "re PR target/82788 (wrong code with -fstack-clash-protection --param=stack-clash-protection-probe-interval=10 on simple code)\n\n\tPR target/82788\n\t* config/i386/i386.c (PROBE_INTERVAL): Remove.\n\t(get_probe_interval): New functions.\n\t(ix86_adjust_stack_and_probe_stack_clash): Use get_probe_interval.\n\t(ix86_adjust_stack_and_probe): Likewise.\n\t(output_adjust_stack_and_probe): Likewise.\n\t(ix86_emit_probe_stack_range): Likewise.\n\t(ix86_expand_prologue): Likewise.\n\n\tPR target/82788\n\t* gcc.dg/pr82788.c: New test.\n\nFrom-SVN: r254456", "tree": {"sha": "e620c8eedd9a17b561fd485087c4b5f6491ea767", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e620c8eedd9a17b561fd485087c4b5f6491ea767"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7a1bdd662bc670ee14646b371699c724df3ba643", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a1bdd662bc670ee14646b371699c724df3ba643", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a1bdd662bc670ee14646b371699c724df3ba643", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a1bdd662bc670ee14646b371699c724df3ba643/comments", "author": null, "committer": null, "parents": [{"sha": "5422b1f0bd98e715f9f01ce3db2af5450a071568", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5422b1f0bd98e715f9f01ce3db2af5450a071568", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5422b1f0bd98e715f9f01ce3db2af5450a071568"}], "stats": {"total": 77, "additions": 54, "deletions": 23}, "files": [{"sha": "1cda8a32a7a443dcce10ced4d55ba3705d5d7491", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a1bdd662bc670ee14646b371699c724df3ba643/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a1bdd662bc670ee14646b371699c724df3ba643/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7a1bdd662bc670ee14646b371699c724df3ba643", "patch": "@@ -1,3 +1,14 @@\n+2017-11-06  Jeff Law  <law@redhat.com>\n+\n+\tPR target/82788\n+\t* config/i386/i386.c (PROBE_INTERVAL): Remove.\n+\t(get_probe_interval): New functions.\n+\t(ix86_adjust_stack_and_probe_stack_clash): Use get_probe_interval.\n+\t(ix86_adjust_stack_and_probe): Likewise.\n+\t(output_adjust_stack_and_probe): Likewise.\n+\t(ix86_emit_probe_stack_range): Likewise.\n+\t(ix86_expand_prologue): Likewise.\n+\n 2017-11-06  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "0d5e2726a33cd19de0f801023831f0b595d2e1cb", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 34, "deletions": 23, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a1bdd662bc670ee14646b371699c724df3ba643/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a1bdd662bc670ee14646b371699c724df3ba643/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=7a1bdd662bc670ee14646b371699c724df3ba643", "patch": "@@ -12099,7 +12099,17 @@ release_scratch_register_on_entry (struct scratch_reg *sr)\n     }\n }\n \n-#define PROBE_INTERVAL (1 << STACK_CHECK_PROBE_INTERVAL_EXP)\n+/* Return the probing interval for -fstack-clash-protection.  */\n+\n+static HOST_WIDE_INT\n+get_probe_interval (void)\n+{\n+  if (flag_stack_clash_protection)\n+    return (HOST_WIDE_INT_1U\n+\t    << PARAM_VALUE (PARAM_STACK_CLASH_PROTECTION_PROBE_INTERVAL));\n+  else\n+    return (HOST_WIDE_INT_1U << STACK_CHECK_PROBE_INTERVAL_EXP);\n+}\n \n /* Emit code to adjust the stack pointer by SIZE bytes while probing it.\n \n@@ -12168,8 +12178,7 @@ ix86_adjust_stack_and_probe_stack_clash (const HOST_WIDE_INT size)\n   /* We're allocating a large enough stack frame that we need to\n      emit probes.  Either emit them inline or in a loop depending\n      on the size.  */\n-  HOST_WIDE_INT probe_interval\n-    = 1 << PARAM_VALUE (PARAM_STACK_CLASH_PROTECTION_PROBE_INTERVAL);\n+  HOST_WIDE_INT probe_interval = get_probe_interval ();\n   if (size <= 4 * probe_interval)\n     {\n       HOST_WIDE_INT i;\n@@ -12178,7 +12187,7 @@ ix86_adjust_stack_and_probe_stack_clash (const HOST_WIDE_INT size)\n \t  /* Allocate PROBE_INTERVAL bytes.  */\n \t  rtx insn\n \t    = pro_epilogue_adjust_stack (stack_pointer_rtx, stack_pointer_rtx,\n-\t\t\t\t\t GEN_INT (-PROBE_INTERVAL), -1,\n+\t\t\t\t\t GEN_INT (-probe_interval), -1,\n \t\t\t\t\t m->fs.cfa_reg == stack_pointer_rtx);\n \t  add_reg_note (insn, REG_STACK_CHECK, const0_rtx);\n \n@@ -12271,7 +12280,7 @@ ix86_adjust_stack_and_probe (const HOST_WIDE_INT size)\n      that's the easy case.  The run-time loop is made up of 9 insns in the\n      generic case while the compile-time loop is made up of 3+2*(n-1) insns\n      for n # of intervals.  */\n-  if (size <= 4 * PROBE_INTERVAL)\n+  if (size <= 4 * get_probe_interval ())\n     {\n       HOST_WIDE_INT i, adjust;\n       bool first_probe = true;\n@@ -12280,15 +12289,15 @@ ix86_adjust_stack_and_probe (const HOST_WIDE_INT size)\n \t values of N from 1 until it exceeds SIZE.  If only one probe is\n \t needed, this will not generate any code.  Then adjust and probe\n \t to PROBE_INTERVAL + SIZE.  */\n-      for (i = PROBE_INTERVAL; i < size; i += PROBE_INTERVAL)\n+      for (i = get_probe_interval (); i < size; i += get_probe_interval ())\n \t{\n \t  if (first_probe)\n \t    {\n-\t      adjust = 2 * PROBE_INTERVAL + dope;\n+\t      adjust = 2 * get_probe_interval () + dope;\n \t      first_probe = false;\n \t    }\n \t  else\n-\t    adjust = PROBE_INTERVAL;\n+\t    adjust = get_probe_interval ();\n \n \t  emit_insn (gen_rtx_SET (stack_pointer_rtx,\n \t\t\t\t  plus_constant (Pmode, stack_pointer_rtx,\n@@ -12297,9 +12306,9 @@ ix86_adjust_stack_and_probe (const HOST_WIDE_INT size)\n \t}\n \n       if (first_probe)\n-\tadjust = size + PROBE_INTERVAL + dope;\n+\tadjust = size + get_probe_interval () + dope;\n       else\n-        adjust = size + PROBE_INTERVAL - i;\n+        adjust = size + get_probe_interval () - i;\n \n       emit_insn (gen_rtx_SET (stack_pointer_rtx,\n \t\t\t      plus_constant (Pmode, stack_pointer_rtx,\n@@ -12309,7 +12318,8 @@ ix86_adjust_stack_and_probe (const HOST_WIDE_INT size)\n       /* Adjust back to account for the additional first interval.  */\n       last = emit_insn (gen_rtx_SET (stack_pointer_rtx,\n \t\t\t\t     plus_constant (Pmode, stack_pointer_rtx,\n-\t\t\t\t\t\t    PROBE_INTERVAL + dope)));\n+\t\t\t\t\t\t    (get_probe_interval ()\n+\t\t\t\t\t\t     + dope))));\n     }\n \n   /* Otherwise, do the same as above, but in a loop.  Note that we must be\n@@ -12327,15 +12337,15 @@ ix86_adjust_stack_and_probe (const HOST_WIDE_INT size)\n \n       /* Step 1: round SIZE to the previous multiple of the interval.  */\n \n-      rounded_size = ROUND_DOWN (size, PROBE_INTERVAL);\n+      rounded_size = ROUND_DOWN (size, get_probe_interval ());\n \n \n       /* Step 2: compute initial and final value of the loop counter.  */\n \n       /* SP = SP_0 + PROBE_INTERVAL.  */\n       emit_insn (gen_rtx_SET (stack_pointer_rtx,\n \t\t\t      plus_constant (Pmode, stack_pointer_rtx,\n-\t\t\t\t\t     - (PROBE_INTERVAL + dope))));\n+\t\t\t\t\t     - (get_probe_interval () + dope))));\n \n       /* LAST_ADDR = SP_0 + PROBE_INTERVAL + ROUNDED_SIZE.  */\n       if (rounded_size <= (HOST_WIDE_INT_1 << 31))\n@@ -12380,7 +12390,8 @@ ix86_adjust_stack_and_probe (const HOST_WIDE_INT size)\n       /* Adjust back to account for the additional first interval.  */\n       last = emit_insn (gen_rtx_SET (stack_pointer_rtx,\n \t\t\t\t     plus_constant (Pmode, stack_pointer_rtx,\n-\t\t\t\t\t\t    PROBE_INTERVAL + dope)));\n+\t\t\t\t\t\t    (get_probe_interval ()\n+\t\t\t\t\t\t     + dope))));\n \n       release_scratch_register_on_entry (&sr);\n     }\n@@ -12397,7 +12408,7 @@ ix86_adjust_stack_and_probe (const HOST_WIDE_INT size)\n       XVECEXP (expr, 0, 1)\n \t= gen_rtx_SET (stack_pointer_rtx,\n \t\t       plus_constant (Pmode, stack_pointer_rtx,\n-\t\t\t\t      PROBE_INTERVAL + dope + size));\n+\t\t\t\t      get_probe_interval () + dope + size));\n       add_reg_note (last, REG_FRAME_RELATED_EXPR, expr);\n       RTX_FRAME_RELATED_P (last) = 1;\n \n@@ -12424,7 +12435,7 @@ output_adjust_stack_and_probe (rtx reg)\n \n   /* SP = SP + PROBE_INTERVAL.  */\n   xops[0] = stack_pointer_rtx;\n-  xops[1] = GEN_INT (PROBE_INTERVAL);\n+  xops[1] = GEN_INT (get_probe_interval ());\n   output_asm_insn (\"sub%z0\\t{%1, %0|%0, %1}\", xops);\n \n   /* Probe at SP.  */\n@@ -12454,14 +12465,14 @@ ix86_emit_probe_stack_range (HOST_WIDE_INT first, HOST_WIDE_INT size)\n      that's the easy case.  The run-time loop is made up of 6 insns in the\n      generic case while the compile-time loop is made up of n insns for n #\n      of intervals.  */\n-  if (size <= 6 * PROBE_INTERVAL)\n+  if (size <= 6 * get_probe_interval ())\n     {\n       HOST_WIDE_INT i;\n \n       /* Probe at FIRST + N * PROBE_INTERVAL for values of N from 1 until\n \t it exceeds SIZE.  If only one probe is needed, this will not\n \t generate any code.  Then probe at FIRST + SIZE.  */\n-      for (i = PROBE_INTERVAL; i < size; i += PROBE_INTERVAL)\n+      for (i = get_probe_interval (); i < size; i += get_probe_interval ())\n \temit_stack_probe (plus_constant (Pmode, stack_pointer_rtx,\n \t\t\t\t\t -(first + i)));\n \n@@ -12484,7 +12495,7 @@ ix86_emit_probe_stack_range (HOST_WIDE_INT first, HOST_WIDE_INT size)\n \n       /* Step 1: round SIZE to the previous multiple of the interval.  */\n \n-      rounded_size = ROUND_DOWN (size, PROBE_INTERVAL);\n+      rounded_size = ROUND_DOWN (size, get_probe_interval ());\n \n \n       /* Step 2: compute initial and final value of the loop counter.  */\n@@ -12545,7 +12556,7 @@ output_probe_stack_range (rtx reg, rtx end)\n \n   /* TEST_ADDR = TEST_ADDR + PROBE_INTERVAL.  */\n   xops[0] = reg;\n-  xops[1] = GEN_INT (PROBE_INTERVAL);\n+  xops[1] = GEN_INT (get_probe_interval ());\n   output_asm_insn (\"sub%z0\\t{%1, %0|%0, %1}\", xops);\n \n   /* Probe at TEST_ADDR.  */\n@@ -13223,7 +13234,7 @@ ix86_expand_prologue (void)\n       else if (STACK_CHECK_MOVING_SP)\n \t{\n \t  if (!(crtl->is_leaf && !cfun->calls_alloca\n-\t\t&& allocate <= PROBE_INTERVAL))\n+\t\t&& allocate <= get_probe_interval ()))\n \t    {\n \t      ix86_adjust_stack_and_probe (allocate);\n \t      allocate = 0;\n@@ -13240,7 +13251,7 @@ ix86_expand_prologue (void)\n \t    {\n \t      if (crtl->is_leaf && !cfun->calls_alloca)\n \t\t{\n-\t\t  if (size > PROBE_INTERVAL)\n+\t\t  if (size > get_probe_interval ())\n \t\t    ix86_emit_probe_stack_range (0, size);\n \t\t}\n \t      else\n@@ -13251,7 +13262,7 @@ ix86_expand_prologue (void)\n \t    {\n \t      if (crtl->is_leaf && !cfun->calls_alloca)\n \t\t{\n-\t\t  if (size > PROBE_INTERVAL\n+\t\t  if (size > get_probe_interval ()\n \t\t      && size > get_stack_check_protect ())\n \t\t    ix86_emit_probe_stack_range (get_stack_check_protect (),\n \t\t\t\t\t\t size - get_stack_check_protect ());"}, {"sha": "de0e0a8ebeeb495d29bfd1f0f524073a917b47dc", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a1bdd662bc670ee14646b371699c724df3ba643/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a1bdd662bc670ee14646b371699c724df3ba643/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7a1bdd662bc670ee14646b371699c724df3ba643", "patch": "@@ -1,3 +1,8 @@\n+2017-11-06  Jeff Law  <law@redhat.com>\n+\n+\tPR target/82788\n+\t* gcc.dg/pr82788.c: New test.\n+\n 2017-11-06  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "a8f628fd7f66c3e56739f6ff491df38b23f4d4df", "filename": "gcc/testsuite/gcc.dg/pr82788.c", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a1bdd662bc670ee14646b371699c724df3ba643/gcc%2Ftestsuite%2Fgcc.dg%2Fpr82788.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a1bdd662bc670ee14646b371699c724df3ba643/gcc%2Ftestsuite%2Fgcc.dg%2Fpr82788.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr82788.c?ref=7a1bdd662bc670ee14646b371699c724df3ba643", "patch": "@@ -0,0 +1,4 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fstack-clash-protection --param stack-clash-protection-probe-interval=10 --param stack-clash-protection-guard-size=12\" } */\n+/* { dg-require-effective-target supports_stack_clash_protection } */\n+int main() { int a[1442]; return 0;}"}]}