{"sha": "6b6bce610bb78e3cbe6a7d00d66270b9ba71e5a8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmI2YmNlNjEwYmI3OGUzY2JlNmE3ZDAwZDY2MjcwYjliYTcxZTVhOA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-07-30T14:19:54Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-07-30T14:19:54Z"}, "message": "[multiple changes]\n\n2014-07-30  Ed Schonberg  <schonberg@adacore.com>\n\n\t* a-chtgop.ads, a-chtgop.adb (Delete_Node_At_Index): New\n\tsubprogram, used by all versions of hashed sets, to delete a node\n\twhose element has been improperly updated through a Reference_\n\tPreserving key.\n\t* a-cohase.adb: Remove Delete_Node, use new common procedure\n\tDelete_Node_At_Index.\n\t* a-cihase.ads: Add Reference_Control_Type to package Generic_Keys.\n\t* a-cihase.adb: Add Adjust and Finalize routines for\n\tReference_Control_Type.\n\t(Reference_Preserving_Key): Build aggregate for\n\tReference_Control_Type\n\n2014-07-30  Yannick Moy  <moy@adacore.com>\n\n\t* checks.adb, checks.ads (Determine_Range_R): New procedure to\n\tdetermine the possible range of a floating-point expression.\n\n2014-07-30  Ed Schonberg  <schonberg@adacore.com>\n\n\t* a-cborse.ads: Add Reference_Control_Type to package Generic_Keys.\n\t* a-cborse.adb: Add Adjust and Finalize routines for\n\tReference_Control_Type.\n\t(Reference_Preserving_Key): Build aggregate for\n\tReference_Control_Type.\n\t(Delete): Check for tampering, and raise Program_Error (not\n\tConstraint_Error) when attempting to delete an element not in\n\tthe set.\n\t(Insert): Ditto.\n\n2014-07-30  Bob Duff  <duff@adacore.com>\n\n\t* a-elchha.adb, a-except-2005.adb, a-except.adb, a-exexda.adb,\n\t* a-exextr.adb, a-exstat.adb, exp_intr.ads, s-tassta.adb:\n\tException_Information is used to produce useful debugging\n\tinformation for the programmer. However, it was also used to\n\timplement the stream attributes for type Exception_Occurrence. The\n\tlatter requires a stable and portable interface, which meant\n\tthat we couldn't include a symbolic traceback. A separate set of\n\troutines was used to provide symbolic tracebacks under program\n\tcontrol (i.e. not automatically). The goal of this ticket is\n\tto provide such automatic tracebacks, so the change here is to\n\tsplit the two functionalities: Exception_Information gives the\n\tmaximally useful information for debugging (i.e. it now includes\n\ta symbolic traceback when a decorator is set, and it can be\n\timproved freely in the future without disturbing streaming).\n\tUntailored_Exception_Information always uses hexadecimal addresses\n\tin the traceback, has a stable and portable output, and is now\n\tused for streaming.\n\n2014-07-30  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* exp_aggr.adb (Expand_Array_Aggregate): Add missing test\n\ton the target of the assignment to find out whether it\n\tcan be directly done by the back-end.\n\t* exp_util.adb (Is_Possibly_Unaligned_Slice): Remove obscure test.\n\nFrom-SVN: r213279", "tree": {"sha": "5a27c9cce12e8e664f23c1dc8956804c65b0ee10", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5a27c9cce12e8e664f23c1dc8956804c65b0ee10"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6b6bce610bb78e3cbe6a7d00d66270b9ba71e5a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b6bce610bb78e3cbe6a7d00d66270b9ba71e5a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b6bce610bb78e3cbe6a7d00d66270b9ba71e5a8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b6bce610bb78e3cbe6a7d00d66270b9ba71e5a8/comments", "author": null, "committer": null, "parents": [{"sha": "facfa16502ba988917c46d40d0b2cad07c989bc3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/facfa16502ba988917c46d40d0b2cad07c989bc3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/facfa16502ba988917c46d40d0b2cad07c989bc3"}], "stats": {"total": 1131, "additions": 897, "deletions": 234}, "files": [{"sha": "8db9279cfd031d8304d47df34b21012ad6536e85", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6bce610bb78e3cbe6a7d00d66270b9ba71e5a8/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6bce610bb78e3cbe6a7d00d66270b9ba71e5a8/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=6b6bce610bb78e3cbe6a7d00d66270b9ba71e5a8", "patch": "@@ -1,3 +1,61 @@\n+2014-07-30  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* a-chtgop.ads, a-chtgop.adb (Delete_Node_At_Index): New\n+\tsubprogram, used by all versions of hashed sets, to delete a node\n+\twhose element has been improperly updated through a Reference_\n+\tPreserving key.\n+\t* a-cohase.adb: Remove Delete_Node, use new common procedure\n+\tDelete_Node_At_Index.\n+\t* a-cihase.ads: Add Reference_Control_Type to package Generic_Keys.\n+\t* a-cihase.adb: Add Adjust and Finalize routines for\n+\tReference_Control_Type.\n+\t(Reference_Preserving_Key): Build aggregate for\n+\tReference_Control_Type\n+\n+2014-07-30  Yannick Moy  <moy@adacore.com>\n+\n+\t* checks.adb, checks.ads (Determine_Range_R): New procedure to\n+\tdetermine the possible range of a floating-point expression.\n+\n+2014-07-30  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* a-cborse.ads: Add Reference_Control_Type to package Generic_Keys.\n+\t* a-cborse.adb: Add Adjust and Finalize routines for\n+\tReference_Control_Type.\n+\t(Reference_Preserving_Key): Build aggregate for\n+\tReference_Control_Type.\n+\t(Delete): Check for tampering, and raise Program_Error (not\n+\tConstraint_Error) when attempting to delete an element not in\n+\tthe set.\n+\t(Insert): Ditto.\n+\n+2014-07-30  Bob Duff  <duff@adacore.com>\n+\n+\t* a-elchha.adb, a-except-2005.adb, a-except.adb, a-exexda.adb,\n+\t* a-exextr.adb, a-exstat.adb, exp_intr.ads, s-tassta.adb:\n+\tException_Information is used to produce useful debugging\n+\tinformation for the programmer. However, it was also used to\n+\timplement the stream attributes for type Exception_Occurrence. The\n+\tlatter requires a stable and portable interface, which meant\n+\tthat we couldn't include a symbolic traceback. A separate set of\n+\troutines was used to provide symbolic tracebacks under program\n+\tcontrol (i.e. not automatically). The goal of this ticket is\n+\tto provide such automatic tracebacks, so the change here is to\n+\tsplit the two functionalities: Exception_Information gives the\n+\tmaximally useful information for debugging (i.e. it now includes\n+\ta symbolic traceback when a decorator is set, and it can be\n+\timproved freely in the future without disturbing streaming).\n+\tUntailored_Exception_Information always uses hexadecimal addresses\n+\tin the traceback, has a stable and portable output, and is now\n+\tused for streaming.\n+\n+2014-07-30  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* exp_aggr.adb (Expand_Array_Aggregate): Add missing test\n+\ton the target of the assignment to find out whether it\n+\tcan be directly done by the back-end.\n+\t* exp_util.adb (Is_Possibly_Unaligned_Slice): Remove obscure test.\n+\n 2014-07-30  Robert Dewar  <dewar@adacore.com>\n \n \t* inline.adb, a-coorse.adb, a-coorse.ads, a-cohase.adb, a-cohase.ads,"}, {"sha": "db9c8c69e5b8d1e186f97d22cc294b675335373d", "filename": "gcc/ada/a-cborse.adb", "status": "modified", "additions": 80, "deletions": 7, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6bce610bb78e3cbe6a7d00d66270b9ba71e5a8/gcc%2Fada%2Fa-cborse.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6bce610bb78e3cbe6a7d00d66270b9ba71e5a8/gcc%2Fada%2Fa-cborse.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cborse.adb?ref=6b6bce610bb78e3cbe6a7d00d66270b9ba71e5a8", "patch": "@@ -482,6 +482,11 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n          raise Program_Error with \"Position cursor designates wrong set\";\n       end if;\n \n+      if Container.Busy > 0 then\n+         raise Program_Error with\n+           \"attempt to tamper with cursors (set is busy)\";\n+      end if;\n+\n       pragma Assert (Vet (Container, Position.Node),\n                      \"bad cursor in Delete\");\n \n@@ -496,7 +501,7 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n \n    begin\n       if X = 0 then\n-         raise Constraint_Error with \"attempt to delete element not in set\";\n+         raise Program_Error with \"attempt to delete element not in set\";\n       end if;\n \n       Tree_Operations.Delete_Node_Sans_Free (Container, X);\n@@ -734,6 +739,23 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n            Is_Less_Key_Node    => Is_Less_Key_Node,\n            Is_Greater_Key_Node => Is_Greater_Key_Node);\n \n+      ------------\n+      -- Adjust --\n+      ------------\n+\n+      procedure Adjust (Control : in out Reference_Control_Type) is\n+      begin\n+         if Control.Container /= null then\n+            declare\n+               B : Natural renames Control.Container.Busy;\n+               L : Natural renames Control.Container.Lock;\n+            begin\n+               B := B + 1;\n+               L := L + 1;\n+            end;\n+         end if;\n+      end Adjust;\n+\n       -------------\n       -- Ceiling --\n       -------------\n@@ -842,6 +864,30 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n          end if;\n       end Exclude;\n \n+      --------------\n+      -- Finalize --\n+      --------------\n+\n+      procedure Finalize (Control : in out Reference_Control_Type) is\n+      begin\n+         if Control.Container /= null then\n+            declare\n+               B : Natural renames Control.Container.Busy;\n+               L : Natural renames Control.Container.Lock;\n+            begin\n+               B := B - 1;\n+               L := L - 1;\n+            end;\n+\n+            if not (Key (Control.Pos) = Control.Old_Key.all) then\n+               Delete (Control.Container.all, Key (Control.Pos));\n+               raise Program_Error;\n+            end if;\n+\n+            Control.Container := null;\n+         end if;\n+      end Finalize;\n+\n       ----------\n       -- Find --\n       ----------\n@@ -939,15 +985,24 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n            (Vet (Container, Position.Node),\n             \"bad cursor in function Reference_Preserving_Key\");\n \n-         --  Some form of finalization will be required in order to actually\n-         --  check that the key-part of the element designated by Position has\n-         --  not changed.  ???\n-\n          declare\n             N : Node_Type renames Container.Nodes (Position.Node);\n+            B : Natural renames Container.Busy;\n+            L : Natural renames Container.Lock;\n          begin\n-            return (Element => N.Element'Access);\n+            return R : constant Reference_Type :=\n+                (Element  => N.Element'Access,\n+                 Control =>\n+                    (Controlled with\n+                      Container => Container'Access,\n+                      Pos       => Position,\n+                      Old_Key   => new Key_Type'(Key (Position))))\n+            do\n+               B := B + 1;\n+               L := L + 1;\n+            end return;\n          end;\n+\n       end Reference_Preserving_Key;\n \n       function Reference_Preserving_Key\n@@ -963,8 +1018,21 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n \n          declare\n             N : Node_Type renames Container.Nodes (Node);\n+            B : Natural renames Container.Busy;\n+            L : Natural renames Container.Lock;\n          begin\n-            return (Element => N.Element'Access);\n+            return R : constant Reference_Type :=\n+                (Element  => N.Element'Access,\n+                 Control =>\n+                    (Controlled with\n+                      Container => Container'Access,\n+                       Pos      => Find (Container, Key),\n+                       Old_Key  => new Key_Type'(Key)))\n+            do\n+               B := B + 1;\n+               L := L + 1;\n+            end return;\n+\n          end;\n       end Reference_Preserving_Key;\n \n@@ -1181,6 +1249,11 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n    --  Start of processing for Insert_Sans_Hint\n \n    begin\n+      if Container.Busy > 0 then\n+         raise Program_Error with\n+           \"attemot to tamper with cursors (set is busy)\";\n+      end if;\n+\n       Conditional_Insert_Sans_Hint\n         (Container,\n          New_Item,"}, {"sha": "aee0bf968a1010a380d0324f60a3d3f2921b9fd5", "filename": "gcc/ada/a-cborse.ads", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6bce610bb78e3cbe6a7d00d66270b9ba71e5a8/gcc%2Fada%2Fa-cborse.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6bce610bb78e3cbe6a7d00d66270b9ba71e5a8/gcc%2Fada%2Fa-cborse.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cborse.ads?ref=6b6bce610bb78e3cbe6a7d00d66270b9ba71e5a8", "patch": "@@ -277,11 +277,33 @@ package Ada.Containers.Bounded_Ordered_Sets is\n          Key       : Key_Type) return Reference_Type;\n \n    private\n-      type Reference_Type (Element : not null access Element_Type) is\n-        null record;\n+      type Set_Access is access all Set;\n+      for Set_Access'Storage_Size use 0;\n+\n+      type Key_Access is access all Key_Type;\n \n       use Ada.Streams;\n \n+      type Reference_Control_Type is\n+        new Ada.Finalization.Controlled with\n+      record\n+         Container : Set_Access;\n+         Pos       : Cursor;\n+         Old_Key   : Key_Access;\n+      end record;\n+\n+      overriding procedure\n+         Adjust (Control : in out Reference_Control_Type);\n+      pragma Inline (Adjust);\n+\n+      overriding procedure\n+         Finalize (Control : in out Reference_Control_Type);\n+      pragma Inline (Finalize);\n+\n+      type Reference_Type (Element : not null access Element_Type) is record\n+         Control  : Reference_Control_Type;\n+      end record;\n+\n       procedure Read\n         (Stream : not null access Root_Stream_Type'Class;\n          Item   : out Reference_Type);"}, {"sha": "2b3fbd333ffe2e9b39ee6cce4cfbccd8e7193a21", "filename": "gcc/ada/a-chtgop.adb", "status": "modified", "additions": 46, "deletions": 1, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6bce610bb78e3cbe6a7d00d66270b9ba71e5a8/gcc%2Fada%2Fa-chtgop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6bce610bb78e3cbe6a7d00d66270b9ba71e5a8/gcc%2Fada%2Fa-chtgop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-chtgop.adb?ref=6b6bce610bb78e3cbe6a7d00d66270b9ba71e5a8", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2013, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -195,6 +195,51 @@ package body Ada.Containers.Hash_Tables.Generic_Operations is\n       end loop;\n    end Clear;\n \n+   --------------------------\n+   -- Delete_Node_At_Index --\n+   --------------------------\n+\n+   procedure Delete_Node_At_Index\n+     (HT   : in out Hash_Table_Type;\n+      Indx : Hash_Type;\n+      X    : in out Node_Access)\n+   is\n+      Prev : Node_Access;\n+      Curr : Node_Access;\n+\n+   begin\n+      Prev := HT.Buckets (Indx);\n+      if Prev = X then\n+         HT.Buckets (Indx) := Next (Prev);\n+         HT.Length := HT.Length - 1;\n+         Free (X);\n+         return;\n+      end if;\n+\n+      if HT.Length = 1 then\n+         raise Program_Error with\n+           \"attempt to delete node not in its proper hash bucket\";\n+      end if;\n+\n+      loop\n+         Curr := Next (Prev);\n+\n+         if Curr = null then\n+            raise Program_Error with\n+              \"attempt to delete node not in its proper hash bucket\";\n+         end if;\n+\n+         if Curr = X then\n+            Set_Next (Node => Prev, Next => Next (Curr));\n+            HT.Length := HT.Length - 1;\n+            Free (X);\n+            return;\n+         end if;\n+         Prev := Curr;\n+      end loop;\n+\n+   end Delete_Node_At_Index\n+;\n    ---------------------------\n    -- Delete_Node_Sans_Free --\n    ---------------------------"}, {"sha": "994f520fcc361140b3cdb2b251c8b392266661b1", "filename": "gcc/ada/a-chtgop.ads", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6bce610bb78e3cbe6a7d00d66270b9ba71e5a8/gcc%2Fada%2Fa-chtgop.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6bce610bb78e3cbe6a7d00d66270b9ba71e5a8/gcc%2Fada%2Fa-chtgop.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-chtgop.ads?ref=6b6bce610bb78e3cbe6a7d00d66270b9ba71e5a8", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2004-2013, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -128,6 +128,16 @@ package Ada.Containers.Hash_Tables.Generic_Operations is\n    --  rehashed onto the new buckets array, and the old buckets array is\n    --  deallocated. Program_Error is raised if the hash table is busy.\n \n+   procedure Delete_Node_At_Index\n+     (HT    : in out Hash_Table_Type;\n+      Indx  : Hash_Type;\n+      X     : in out Node_Access);\n+\n+   --  Delete a node whose bucket position is known. Used to remove a node\n+   --  whose element has been modified through a key_preserving reference.\n+   --  We cannot use the value of the element precisely because the current\n+   --  value does not correspond to the hash code that determines the bucket.\n+\n    procedure Delete_Node_Sans_Free\n      (HT : in out Hash_Table_Type;\n       X  : Node_Access);"}, {"sha": "44d3dc14516abd984f0538de703925e102ec8ad5", "filename": "gcc/ada/a-cihase.adb", "status": "modified", "additions": 82, "deletions": 9, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6bce610bb78e3cbe6a7d00d66270b9ba71e5a8/gcc%2Fada%2Fa-cihase.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6bce610bb78e3cbe6a7d00d66270b9ba71e5a8/gcc%2Fada%2Fa-cihase.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cihase.adb?ref=6b6bce610bb78e3cbe6a7d00d66270b9ba71e5a8", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2013, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -2139,6 +2139,24 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n            Hash      => Hash,\n            Equivalent_Keys => Equivalent_Key_Node);\n \n+      ------------\n+      -- Adjust --\n+      ------------\n+\n+      procedure Adjust (Control : in out Reference_Control_Type) is\n+      begin\n+         if Control.Container /= null then\n+            declare\n+               HT : Hash_Table_Type renames Control.Container.HT;\n+               B : Natural renames HT.Busy;\n+               L : Natural renames HT.Lock;\n+            begin\n+               B := B + 1;\n+               L := L + 1;\n+            end;\n+         end if;\n+      end Adjust;\n+\n       ------------------------\n       -- Constant_Reference --\n       ------------------------\n@@ -2249,6 +2267,32 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n          Free (X);\n       end Exclude;\n \n+      --------------\n+      -- Finalize --\n+      --------------\n+\n+      procedure Finalize (Control : in out Reference_Control_Type) is\n+      begin\n+         if Control.Container /= null then\n+            declare\n+               HT   : Hash_Table_Type renames Control.Container.HT;\n+               B : Natural renames HT.Busy;\n+               L : Natural renames HT.Lock;\n+            begin\n+               B := B - 1;\n+               L := L - 1;\n+            end;\n+\n+            if Hash (Key (Control.Old_Pos)) /= Control.Old_Hash then\n+               HT_Ops.Delete_Node_At_Index\n+                 (Control.Container.HT, Control.Index,  Control.Old_Pos.Node);\n+               raise Program_Error;\n+            end if;\n+\n+            Control.Container := null;\n+         end if;\n+      end Finalize;\n+\n       ----------\n       -- Find --\n       ----------\n@@ -2322,11 +2366,25 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n            (Vet (Position),\n             \"bad cursor in function Reference_Preserving_Key\");\n \n-         --  Some form of finalization will be required in order to actually\n-         --  check that the key-part of the element designated by Position has\n-         --  not changed.  ???\n+         declare\n+            HT : Hash_Table_Type renames Container.HT;\n+            B : Natural renames HT.Busy;\n+            L : Natural renames HT.Lock;\n \n-         return (Element => Position.Node.Element.all'Access);\n+         begin\n+            return R : constant Reference_Type :=\n+              (Element  => Position.Node.Element.all'Access,\n+                 Control =>\n+                   (Controlled with\n+                     Container => Container'Access,\n+                     Index     => HT_Ops.Index (HT, Position.Node),\n+                     Old_Pos   => Position,\n+                     Old_Hash  => Hash (Key (Position))))\n+            do\n+               B := B + 1;\n+               L := L + 1;\n+            end return;\n+         end;\n       end Reference_Preserving_Key;\n \n       function Reference_Preserving_Key\n@@ -2345,11 +2403,26 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n             raise Program_Error with \"Node has no element\";\n          end if;\n \n-         --  Some form of finalization will be required in order to actually\n-         --  check that the key-part of the element designated by Key has not\n-         --  changed.  ???\n+         declare\n+            HT : Hash_Table_Type renames Container.HT;\n+            B : Natural renames HT.Busy;\n+            L : Natural renames HT.Lock;\n+            P : constant Cursor := Find (Container, Key);\n \n-         return (Element => Node.Element.all'Access);\n+         begin\n+            return R : constant Reference_Type :=\n+              (Element  => Node.Element.all'Access,\n+                 Control =>\n+                   (Controlled with\n+                     Container => Container'Access,\n+                     Index  => HT_Ops.Index (HT, P.Node),\n+                     Old_Pos => P,\n+                     Old_Hash => Hash (Key)))\n+            do\n+               B := B + 1;\n+               L := L + 1;\n+            end return;\n+         end;\n       end Reference_Preserving_Key;\n \n       -------------"}, {"sha": "86eb4d05f2cd10ee31acf3fcf6c0918766488213", "filename": "gcc/ada/a-cihase.ads", "status": "modified", "additions": 24, "deletions": 3, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6bce610bb78e3cbe6a7d00d66270b9ba71e5a8/gcc%2Fada%2Fa-cihase.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6bce610bb78e3cbe6a7d00d66270b9ba71e5a8/gcc%2Fada%2Fa-cihase.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cihase.ads?ref=6b6bce610bb78e3cbe6a7d00d66270b9ba71e5a8", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2004-2013, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -430,8 +430,29 @@ package Ada.Containers.Indefinite_Hashed_Sets is\n          Key       : Key_Type) return Reference_Type;\n \n    private\n-      type Reference_Type (Element : not null access Element_Type)\n-         is null record;\n+      type Set_Access is access all Set;\n+      for Set_Access'Storage_Size use 0;\n+\n+      type Reference_Control_Type is\n+        new Ada.Finalization.Controlled with\n+      record\n+         Container : Set_Access;\n+         Index     : Hash_Type;\n+         Old_Pos   : Cursor;\n+         Old_Hash  : Hash_Type;\n+      end record;\n+\n+      overriding procedure\n+         Adjust (Control : in out Reference_Control_Type);\n+      pragma Inline (Adjust);\n+\n+      overriding procedure\n+         Finalize (Control : in out Reference_Control_Type);\n+      pragma Inline (Finalize);\n+\n+      type Reference_Type (Element : not null access Element_Type) is record\n+         Control  : Reference_Control_Type;\n+      end record;\n \n       use Ada.Streams;\n "}, {"sha": "841cec2706b49019e17ee2d7468b35a255c13754", "filename": "gcc/ada/a-cohase.adb", "status": "modified", "additions": 2, "deletions": 53, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6bce610bb78e3cbe6a7d00d66270b9ba71e5a8/gcc%2Fada%2Fa-cohase.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6bce610bb78e3cbe6a7d00d66270b9ba71e5a8/gcc%2Fada%2Fa-cohase.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cohase.adb?ref=6b6bce610bb78e3cbe6a7d00d66270b9ba71e5a8", "patch": "@@ -132,15 +132,6 @@ package body Ada.Containers.Hashed_Sets is\n    procedure Write_Nodes is\n       new HT_Ops.Generic_Write (Write_Node);\n \n-   procedure Delete_Node\n-     (C    : in out Set;\n-      Indx : Hash_Type;\n-      X    : in out Node_Access);\n-   --  Delete a node whose bucket position is known. Used to remove a node\n-   --  whose element has been modified through a key_preserving reference.\n-   --  We cannot use the value of the element precisely because the current\n-   --  value does not correspond to the hash code that determines the bucket.\n-\n    ---------\n    -- \"=\" --\n    ---------\n@@ -337,48 +328,6 @@ package body Ada.Containers.Hashed_Sets is\n       Position.Container := null;\n    end Delete;\n \n-   procedure Delete_Node\n-     (C    : in out Set;\n-      Indx : Hash_Type;\n-      X    : in out Node_Access)\n-   is\n-      HT   : Hash_Table_Type renames C.HT;\n-      Prev : Node_Access;\n-      Curr : Node_Access;\n-\n-   begin\n-      Prev := HT.Buckets (Indx);\n-      if Prev = X then\n-         HT.Buckets (Indx) := Next (Prev);\n-         HT.Length := HT.Length - 1;\n-         Free (X);\n-         return;\n-      end if;\n-\n-      if HT.Length = 1 then\n-         raise Program_Error with\n-           \"attempt to delete node not in its proper hash bucket\";\n-      end if;\n-\n-      loop\n-         Curr := Next (Prev);\n-\n-         if Curr = null then\n-            raise Program_Error with\n-              \"attempt to delete node not in its proper hash bucket\";\n-         end if;\n-\n-         if Curr = X then\n-            Set_Next (Node => Prev, Next => Next (Curr));\n-            HT.Length := HT.Length - 1;\n-            Free (X);\n-            return;\n-         end if;\n-         Prev := Curr;\n-      end loop;\n-\n-   end Delete_Node;\n-\n    ----------------\n    -- Difference --\n    ----------------\n@@ -2138,8 +2087,8 @@ package body Ada.Containers.Hashed_Sets is\n \n             if Hash (Key (Element (Control.Old_Pos))) /= Control.Old_Hash\n             then\n-               Delete_Node\n-                 (Control.Container.all, Control.Index,  Control.Old_Pos.Node);\n+               HT_Ops.Delete_Node_At_Index\n+                (Control.Container.HT, Control.Index,  Control.Old_Pos.Node);\n                raise Program_Error with \"key not preserved in reference\";\n             end if;\n "}, {"sha": "d48afb332c154b9903ae5afee54f5f00b3e0c7b3", "filename": "gcc/ada/a-elchha.adb", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6bce610bb78e3cbe6a7d00d66270b9ba71e5a8/gcc%2Fada%2Fa-elchha.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6bce610bb78e3cbe6a7d00d66270b9ba71e5a8/gcc%2Fada%2Fa-elchha.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-elchha.adb?ref=6b6bce610bb78e3cbe6a7d00d66270b9ba71e5a8", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2003-2013, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2003-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -53,10 +53,11 @@ is\n    pragma Import\n      (Ada, Append_Info_Exception_Message, \"__gnat_append_info_e_msg\");\n \n-   procedure Append_Info_Exception_Information\n+   procedure Append_Info_Untailored_Exception_Information\n      (X : Exception_Occurrence; Info : in out String; Ptr : in out Natural);\n    pragma Import\n-     (Ada, Append_Info_Exception_Information, \"__gnat_append_info_e_info\");\n+     (Ada, Append_Info_Untailored_Exception_Information,\n+      \"__gnat_append_info_u_e_info\");\n \n    procedure To_Stderr (S : String);\n    pragma Import (Ada, To_Stderr, \"__gnat_to_stderr\");\n@@ -129,7 +130,7 @@ begin\n       To_Stderr (\"Execution terminated by unhandled exception\");\n       To_Stderr (Nline);\n \n-      Append_Info_Exception_Information (Except, Nobuf, Ptr);\n+      Append_Info_Untailored_Exception_Information (Except, Nobuf, Ptr);\n    end if;\n \n    Unhandled_Terminate;"}, {"sha": "c09bc14f3f88999273f3dc3453a44b25f242fa42", "filename": "gcc/ada/a-except-2005.adb", "status": "modified", "additions": 23, "deletions": 27, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6bce610bb78e3cbe6a7d00d66270b9ba71e5a8/gcc%2Fada%2Fa-except-2005.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6bce610bb78e3cbe6a7d00d66270b9ba71e5a8/gcc%2Fada%2Fa-except-2005.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-except-2005.adb?ref=6b6bce610bb78e3cbe6a7d00d66270b9ba71e5a8", "patch": "@@ -138,12 +138,17 @@ package body Ada.Exceptions is\n       --  to contain the indicated Id value and message. Message is a string\n       --  which is generated as the exception message.\n \n-      --------------------------------------\n-      -- Exception information subprogram --\n-      --------------------------------------\n+      ---------------------------------------\n+      -- Exception information subprograms --\n+      ---------------------------------------\n \n-      function Exception_Information (X : Exception_Occurrence) return String;\n-      --  The format of the exception information is as follows:\n+      function Untailored_Exception_Information\n+        (X : Exception_Occurrence) return String;\n+      --  This is used by Stream_Attributes.EO_To_String to convert an\n+      --  Exception_Occurrence to a String for the stream attributes.\n+      --  String_To_EO understands the format, as documented here.\n+      --\n+      --  The format of the string is as follows:\n       --\n       --    Exception_Name: <exception name> (as in Exception_Name)\n       --    Message: <message> (only if Exception_Message is empty)\n@@ -164,10 +169,6 @@ package body Ada.Exceptions is\n       --  that an equivalent modification to the routine String_To_EO must be\n       --  made to preserve proper functioning of the stream attributes.\n \n-      ---------------------------------------\n-      -- Exception backtracing subprograms --\n-      ---------------------------------------\n-\n       --  What is automatically output when exception tracing is on is the\n       --  usual exception information with the call chain backtrace possibly\n       --  tailored by a backtrace decorator. Modifying Exception_Information\n@@ -177,28 +178,23 @@ package body Ada.Exceptions is\n       --  the possibly tailored output, which is equivalent if no decorator is\n       --  currently set:\n \n-      function Tailored_Exception_Information\n-        (X : Exception_Occurrence) return String;\n-      --  Exception information to be output in the case of automatic tracing\n-      --  requested through GNAT.Exception_Traces.\n+      function Exception_Information (X : Exception_Occurrence) return String;\n+      --  This is the implementation of Ada.Exceptions.Exception_Information,\n+      --  as defined in the Ada RM.\n       --\n-      --  This is the same as Exception_Information if no backtrace decorator\n-      --  is currently in place. Otherwise, this is Exception_Information with\n-      --  the call chain raw addresses replaced by the result of a call to the\n-      --  current decorator provided with the call chain addresses.\n-\n-      pragma Export\n-        (Ada, Tailored_Exception_Information,\n-           \"__gnat_tailored_exception_information\");\n-      --  This is currently used by System.Tasking.Stages\n+      --  If no traceback decorator (see GNAT.Exception_Traces) is currently\n+      --  in place, this is the same as Untailored_Exception_Information.\n+      --  Otherwise, the decorator is used to produce a symbolic traceback\n+      --  instead of hexadecimal addresses.\n+      --\n+      --  Note that unlike Untailored_Exception_Information, there is no need\n+      --  to keep the output of Exception_Information stable for streaming\n+      --  purposes, and in fact the output differs across platforms.\n \n    end Exception_Data;\n \n    package Exception_Traces is\n \n-      use Exception_Data;\n-      --  Imports Tailored_Exception_Information\n-\n       ----------------------------------------------\n       -- Run-Time Exception Notification Routines --\n       ----------------------------------------------\n@@ -737,8 +733,8 @@ package body Ada.Exceptions is\n    -- EO_To_String --\n    ------------------\n \n-   --  We use the null string to represent the null occurrence, otherwise\n-   --  we output the Exception_Information string for the occurrence.\n+   --  We use the null string to represent the null occurrence, otherwise we\n+   --  output the Untailored_Exception_Information string for the occurrence.\n \n    function EO_To_String (X : Exception_Occurrence) return String\n      renames Stream_Attributes.EO_To_String;"}, {"sha": "f90858e1937026a63bbb5efcbd9ffed70d4dead0", "filename": "gcc/ada/a-except.adb", "status": "modified", "additions": 28, "deletions": 34, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6bce610bb78e3cbe6a7d00d66270b9ba71e5a8/gcc%2Fada%2Fa-except.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6bce610bb78e3cbe6a7d00d66270b9ba71e5a8/gcc%2Fada%2Fa-except.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-except.adb?ref=6b6bce610bb78e3cbe6a7d00d66270b9ba71e5a8", "patch": "@@ -116,38 +116,37 @@ package body Ada.Exceptions is\n       --  message. Message is a string which is generated as the exception\n       --  message.\n \n-      --------------------------------------\n-      -- Exception information subprogram --\n-      --------------------------------------\n+      ---------------------------------------\n+      -- Exception information subprograms --\n+      ---------------------------------------\n \n-      function Exception_Information (X : Exception_Occurrence) return String;\n-      --  The format of the exception information is as follows:\n+      function Untailored_Exception_Information\n+        (X : Exception_Occurrence) return String;\n+      --  This is used by Stream_Attributes.EO_To_String to convert an\n+      --  Exception_Occurrence to a String for the stream attributes.\n+      --  String_To_EO understands the format, as documented here.\n+      --\n+      --  The format of the string is as follows:\n       --\n       --    Exception_Name: <exception name> (as in Exception_Name)\n       --    Message: <message> (only if Exception_Message is empty)\n       --    PID=nnnn (only if != 0)\n       --    Call stack traceback locations:  (only if at least one location)\n       --    <0xyyyyyyyy 0xyyyyyyyy ...>      (is recorded)\n       --\n-      --  The lines are separated by a ASCII.LF character\n-      --\n-      --  The nnnn is the partition Id given as decimal digits\n-      --\n+      --  The lines are separated by a ASCII.LF character.\n+      --  The nnnn is the partition Id given as decimal digits.\n       --  The 0x... line represents traceback program counter locations, in\n       --  execution order with the first one being the exception location. It\n       --  is present only\n       --\n-      --  The Exception_Name and Message lines are omitted in the abort signal\n-      --  case, since this is not really an exception.\n+      --  The Exception_Name and Message lines are omitted in the abort\n+      --  signal case, since this is not really an exception.\n \n       --  Note: If the format of the generated string is changed, please note\n       --  that an equivalent modification to the routine String_To_EO must be\n       --  made to preserve proper functioning of the stream attributes.\n \n-      ---------------------------------------\n-      -- Exception backtracing subprograms --\n-      ---------------------------------------\n-\n       --  What is automatically output when exception tracing is on is the\n       --  usual exception information with the call chain backtrace possibly\n       --  tailored by a backtrace decorator. Modifying Exception_Information\n@@ -157,28 +156,23 @@ package body Ada.Exceptions is\n       --  the possibly tailored output, which is equivalent if no decorator is\n       --  currently set:\n \n-      function Tailored_Exception_Information\n-        (X : Exception_Occurrence) return String;\n-      --  Exception information to be output in the case of automatic tracing\n-      --  requested through GNAT.Exception_Traces.\n+      function Exception_Information (X : Exception_Occurrence) return String;\n+      --  This is the implementation of Ada.Exceptions.Exception_Information,\n+      --  as defined in the Ada RM.\n       --\n-      --  This is the same as Exception_Information if no backtrace decorator\n-      --  is currently in place. Otherwise, this is Exception_Information with\n-      --  the call chain raw addresses replaced by the result of a call to the\n-      --  current decorator provided with the call chain addresses.\n-\n-      pragma Export\n-        (Ada, Tailored_Exception_Information,\n-           \"__gnat_tailored_exception_information\");\n-      --  This is currently used by System.Tasking.Stages\n+      --  If no traceback decorator (see GNAT.Exception_Traces) is currently\n+      --  in place, this is the same as Untailored_Exception_Information.\n+      --  Otherwise, the decorator is used to produce a symbolic traceback\n+      --  instead of hexadecimal addresses.\n+      --\n+      --  Note that unlike Untailored_Exception_Information, there is no need\n+      --  to keep the output of Exception_Information stable for streaming\n+      --  purposes, and in fact the output differs across platforms.\n \n    end Exception_Data;\n \n    package Exception_Traces is\n \n-      use Exception_Data;\n-      --  Imports Tailored_Exception_Information\n-\n       ----------------------------------------------\n       -- Run-Time Exception Notification Routines --\n       ----------------------------------------------\n@@ -774,7 +768,7 @@ package body Ada.Exceptions is\n    ------------------\n \n    --  We use the null string to represent the null occurrence, otherwise we\n-   --  output the Exception_Information string for the occurrence.\n+   --  output the Untailored_Exception_Information string for the occurrence.\n \n    function EO_To_String (X : Exception_Occurrence) return String\n      renames Stream_Attributes.EO_To_String;\n@@ -806,9 +800,9 @@ package body Ada.Exceptions is\n    begin\n       if X.Id = Null_Id then\n          raise Constraint_Error;\n+      else\n+         return Exception_Data.Exception_Information (X);\n       end if;\n-\n-      return Exception_Data.Exception_Information (X);\n    end Exception_Information;\n \n    -----------------------"}, {"sha": "efe9b58d2560cf0a82145684d02c55fd3c541856", "filename": "gcc/ada/a-exexda.adb", "status": "modified", "additions": 57, "deletions": 54, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6bce610bb78e3cbe6a7d00d66270b9ba71e5a8/gcc%2Fada%2Fa-exexda.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6bce610bb78e3cbe6a7d00d66270b9ba71e5a8/gcc%2Fada%2Fa-exexda.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-exexda.adb?ref=6b6bce610bb78e3cbe6a7d00d66270b9ba71e5a8", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -36,39 +36,40 @@ package body Exception_Data is\n \n    --  This unit implements the Exception_Information related services for\n    --  both the Ada standard requirements and the GNAT.Exception_Traces\n-   --  facility.\n+   --  facility. This is also used by the implementation of the stream\n+   --  attributes of types Exception_Id and Exception_Occurrence.\n \n    --  There are common parts between the contents of Exception_Information\n-   --  (the regular Ada interface) and Tailored_Exception_Information (what\n-   --  the automatic backtracing output includes). The overall structure is\n-   --  sketched below:\n+   --  (the regular Ada interface) and Untailored_Exception_Information (used\n+   --  for streaming, and when there is no symbolic traceback available) The\n+   --  overall structure is sketched below:\n \n    --\n-   --                      Exception_Information\n+   --                 Untailored_Exception_Information\n    --                               |\n    --                       +-------+--------+\n    --                       |                |\n-   --                Basic_Exc_Info & Basic_Exc_Tback\n-   --                    (B_E_I)          (B_E_TB)\n+   --                Basic_Exc_Info & Untailored_Exc_Tback\n+   --                    (B_E_I)         (U_E_TB)\n \n    --           o--\n    --  (B_E_I)  |  Exception_Name: <exception name> (as in Exception_Name)\n    --           |  Message: <message> (or a null line if no message)\n    --           |  PID=nnnn (if != 0)\n    --           o--\n-   --  (B_E_TB) |  Call stack traceback locations:\n+   --  (U_E_TB) |  Call stack traceback locations:\n    --           |  <0xyyyyyyyy 0xyyyyyyyy ...>\n    --           o--\n \n-   --                  Tailored_Exception_Information\n+   --                     Exception_Information\n    --                               |\n    --                    +----------+----------+\n    --                    |                     |\n-   --             Basic_Exc_Info    &  Tailored_Exc_Tback\n+   --             Basic_Exc_Info    &      traceback\n    --                                          |\n    --                              +-----------+------------+\n    --                              |                        |\n-   --                       Basic_Exc_Tback    Or    Tback_Decorator\n+   --                     Untailored_Exc_Tback    Or    Tback_Decorator\n    --                     if no decorator set           otherwise\n \n    --  Functions returning String imply secondary stack use, which is a heavy\n@@ -81,8 +82,8 @@ package body Exception_Data is\n \n    --  The procedural interface is composed of two major sections: a neutral\n    --  section for basic types like Address, Character, Natural or String, and\n-   --  an exception oriented section for the e.g. Basic_Exception_Information.\n-   --  This is the Append_Info family of procedures below.\n+   --  an exception oriented section for the exception names, messages, and\n+   --  information. This is the Append_Info family of procedures below.\n \n    --  Output to stderr is commanded by passing an empty buffer to update, and\n    --  care is taken not to overflow otherwise.\n@@ -140,12 +141,12 @@ package body Exception_Data is\n       Info : in out String;\n       Ptr  : in out Natural);\n \n-   procedure Append_Info_Basic_Exception_Traceback\n+   procedure Append_Info_Untailored_Exception_Traceback\n      (X    : Exception_Occurrence;\n       Info : in out String;\n       Ptr  : in out Natural);\n \n-   procedure Append_Info_Exception_Information\n+   procedure Append_Info_Untailored_Exception_Information\n      (X    : Exception_Occurrence;\n       Info : in out String;\n       Ptr  : in out Natural);\n@@ -162,7 +163,7 @@ package body Exception_Data is\n    function Basic_Exception_Info_Maxlength\n      (X : Exception_Occurrence) return Natural;\n \n-   function Basic_Exception_Tback_Maxlength\n+   function Untailored_Exception_Traceback_Maxlength\n      (X : Exception_Occurrence) return Natural;\n \n    function Exception_Info_Maxlength\n@@ -181,11 +182,11 @@ package body Exception_Data is\n    -- Functional Interface --\n    --------------------------\n \n-   function Basic_Exception_Traceback\n+   function Untailored_Exception_Traceback\n      (X : Exception_Occurrence) return String;\n    --  Returns an image of the complete call chain associated with an\n    --  exception occurrence in its most basic form, that is as a raw sequence\n-   --  of hexadecimal binary addresses.\n+   --  of hexadecimal addresses.\n \n    function Tailored_Exception_Traceback\n      (X : Exception_Occurrence) return String;\n@@ -201,7 +202,8 @@ package body Exception_Data is\n      (Ada, Append_Info_Exception_Message, \"__gnat_append_info_e_msg\");\n \n    pragma Export\n-     (Ada, Append_Info_Exception_Information, \"__gnat_append_info_e_info\");\n+     (Ada, Append_Info_Untailored_Exception_Information,\n+      \"__gnat_append_info_u_e_info\");\n \n    pragma Export\n      (Ada, Exception_Message_Length, \"__gnat_exception_msg_len\");\n@@ -375,16 +377,16 @@ package body Exception_Data is\n         + BEI_PID_Header'Length + 15;\n    end Basic_Exception_Info_Maxlength;\n \n-   -------------------------------------------\n-   -- Append_Info_Basic_Exception_Traceback --\n-   -------------------------------------------\n+   ------------------------------------------------\n+   -- Append_Info_Untailored_Exception_Traceback --\n+   ------------------------------------------------\n \n    --  As for Basic_Exception_Information:\n \n    BETB_Header : constant String := \"Call stack traceback locations:\";\n    LDAD_Header : constant String := \"Load address: \";\n \n-   procedure Append_Info_Basic_Exception_Traceback\n+   procedure Append_Info_Untailored_Exception_Traceback\n      (X    : Exception_Occurrence;\n       Info : in out String;\n       Ptr  : in out Natural)\n@@ -417,13 +419,13 @@ package body Exception_Data is\n       end loop;\n \n       Append_Info_NL (Info, Ptr);\n-   end Append_Info_Basic_Exception_Traceback;\n+   end Append_Info_Untailored_Exception_Traceback;\n \n-   -----------------------------------------\n-   -- Basic_Exception_Traceback_Maxlength --\n-   -----------------------------------------\n+   ----------------------------------------------\n+   -- Untailored_Exception_Traceback_Maxlength --\n+   ----------------------------------------------\n \n-   function Basic_Exception_Tback_Maxlength\n+   function Untailored_Exception_Traceback_Maxlength\n      (X : Exception_Occurrence) return Natural\n    is\n       Space_Per_Address : constant := 2 + 16 + 1;\n@@ -432,21 +434,21 @@ package body Exception_Data is\n       return\n         LDAD_Header'Length + Space_Per_Address + BETB_Header'Length + 1 +\n           X.Num_Tracebacks * Space_Per_Address + 1;\n-   end Basic_Exception_Tback_Maxlength;\n+   end Untailored_Exception_Traceback_Maxlength;\n \n-   ---------------------------------------\n-   -- Append_Info_Exception_Information --\n-   ---------------------------------------\n+   --------------------------------------------------\n+   -- Append_Info_Untailored_Exception_Information --\n+   --------------------------------------------------\n \n-   procedure Append_Info_Exception_Information\n+   procedure Append_Info_Untailored_Exception_Information\n      (X    : Exception_Occurrence;\n       Info : in out String;\n       Ptr  : in out Natural)\n    is\n    begin\n       Append_Info_Basic_Exception_Information (X, Info, Ptr);\n-      Append_Info_Basic_Exception_Traceback   (X, Info, Ptr);\n-   end Append_Info_Exception_Information;\n+      Append_Info_Untailored_Exception_Traceback (X, Info, Ptr);\n+   end Append_Info_Untailored_Exception_Information;\n \n    ------------------------------\n    -- Exception_Info_Maxlength --\n@@ -458,7 +460,7 @@ package body Exception_Data is\n    begin\n       return\n         Basic_Exception_Info_Maxlength (X)\n-        + Basic_Exception_Tback_Maxlength (X);\n+        + Untailored_Exception_Traceback_Maxlength (X);\n    end Exception_Info_Maxlength;\n \n    -----------------------------------\n@@ -546,32 +548,33 @@ package body Exception_Data is\n    end Exception_Message_Length;\n \n    -------------------------------\n-   -- Basic_Exception_Traceback --\n+   -- Untailored_Exception_Traceback --\n    -------------------------------\n \n-   function Basic_Exception_Traceback\n+   function Untailored_Exception_Traceback\n      (X : Exception_Occurrence) return String\n    is\n-      Info : aliased String (1 .. Basic_Exception_Tback_Maxlength (X));\n+      Info : aliased String\n+                       (1 .. Untailored_Exception_Traceback_Maxlength (X));\n       Ptr  : Natural := Info'First - 1;\n    begin\n-      Append_Info_Basic_Exception_Traceback (X, Info, Ptr);\n+      Append_Info_Untailored_Exception_Traceback (X, Info, Ptr);\n       return Info (Info'First .. Ptr);\n-   end Basic_Exception_Traceback;\n+   end Untailored_Exception_Traceback;\n \n-   ---------------------------\n-   -- Exception_Information --\n-   ---------------------------\n+   --------------------------------------\n+   -- Untailored_Exception_Information --\n+   --------------------------------------\n \n-   function Exception_Information\n+   function Untailored_Exception_Information\n      (X : Exception_Occurrence) return String\n    is\n       Info : String (1 .. Exception_Info_Maxlength (X));\n       Ptr  : Natural := Info'First - 1;\n    begin\n-      Append_Info_Exception_Information (X, Info, Ptr);\n+      Append_Info_Untailored_Exception_Information (X, Info, Ptr);\n       return Info (Info'First .. Ptr);\n-   end Exception_Information;\n+   end Untailored_Exception_Information;\n \n    -------------------------\n    -- Set_Exception_C_Msg --\n@@ -713,17 +716,17 @@ package body Exception_Data is\n \n    begin\n       if Wrapper = null then\n-         return Basic_Exception_Traceback (X);\n+         return Untailored_Exception_Traceback (X);\n       else\n          return Wrapper.all (X.Tracebacks'Address, X.Num_Tracebacks);\n       end if;\n    end Tailored_Exception_Traceback;\n \n-   ------------------------------------\n-   -- Tailored_Exception_Information --\n-   ------------------------------------\n+   ---------------------------\n+   -- Exception_Information --\n+   ---------------------------\n \n-   function Tailored_Exception_Information\n+   function Exception_Information\n      (X : Exception_Occurrence) return String\n    is\n       --  The tailored exception information is the basic information\n@@ -739,6 +742,6 @@ package body Exception_Data is\n       Append_Info_Basic_Exception_Information (X, Info, Ptr);\n       Append_Info_String (Tback_Info, Info, Ptr);\n       return Info (Info'First .. Ptr);\n-   end Tailored_Exception_Information;\n+   end Exception_Information;\n \n end Exception_Data;"}, {"sha": "94ec48338f9284ce084fa1cd16fddf1e2fabd387", "filename": "gcc/ada/a-exextr.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6bce610bb78e3cbe6a7d00d66270b9ba71e5a8/gcc%2Fada%2Fa-exextr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6bce610bb78e3cbe6a7d00d66270b9ba71e5a8/gcc%2Fada%2Fa-exextr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-exextr.adb?ref=6b6bce610bb78e3cbe6a7d00d66270b9ba71e5a8", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -99,7 +99,7 @@ package body Exception_Traces is\n \n          To_Stderr (\"Exception raised\");\n          To_Stderr (Nline);\n-         To_Stderr (Tailored_Exception_Information (Excep.all));\n+         To_Stderr (Exception_Information (Excep.all));\n          Unlock_Task.all;\n       end if;\n "}, {"sha": "cd7565f2a644c60b612f8c1a228a293d8438991c", "filename": "gcc/ada/a-exstat.adb", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6bce610bb78e3cbe6a7d00d66270b9ba71e5a8/gcc%2Fada%2Fa-exstat.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6bce610bb78e3cbe6a7d00d66270b9ba71e5a8/gcc%2Fada%2Fa-exstat.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-exstat.adb?ref=6b6bce610bb78e3cbe6a7d00d66270b9ba71e5a8", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -59,15 +59,15 @@ package body Stream_Attributes is\n    -- EO_To_String --\n    ------------------\n \n-   --  We use the null string to represent the null occurrence, otherwise\n-   --  we output the Exception_Information string for the occurrence.\n+   --  We use the null string to represent the null occurrence, otherwise we\n+   --  output the Untailored_Exception_Information string for the occurrence.\n \n    function EO_To_String (X : Exception_Occurrence) return String is\n    begin\n       if X.Id = Null_Id then\n          return \"\";\n       else\n-         return Exception_Information (X);\n+         return Exception_Data.Untailored_Exception_Information (X);\n       end if;\n    end EO_To_String;\n "}, {"sha": "4de06a4d05a9cf77fea313df4363f42b83e42502", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 435, "deletions": 13, "changes": 448, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6bce610bb78e3cbe6a7d00d66270b9ba71e5a8/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6bce610bb78e3cbe6a7d00d66270b9ba71e5a8/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=6b6bce610bb78e3cbe6a7d00d66270b9ba71e5a8", "patch": "@@ -61,7 +61,6 @@ with Stringt;  use Stringt;\n with Targparm; use Targparm;\n with Tbuild;   use Tbuild;\n with Ttypes;   use Ttypes;\n-with Urealp;   use Urealp;\n with Validsw;  use Validsw;\n \n package body Checks is\n@@ -4076,18 +4075,20 @@ package body Checks is\n    type Cache_Index is range 0 .. Cache_Size - 1;\n    --  Determine size of below cache (power of 2 is more efficient)\n \n-   Determine_Range_Cache_N  : array (Cache_Index) of Node_Id;\n-   Determine_Range_Cache_V  : array (Cache_Index) of Boolean;\n-   Determine_Range_Cache_Lo : array (Cache_Index) of Uint;\n-   Determine_Range_Cache_Hi : array (Cache_Index) of Uint;\n+   Determine_Range_Cache_N    : array (Cache_Index) of Node_Id;\n+   Determine_Range_Cache_V    : array (Cache_Index) of Boolean;\n+   Determine_Range_Cache_Lo   : array (Cache_Index) of Uint;\n+   Determine_Range_Cache_Hi   : array (Cache_Index) of Uint;\n+   Determine_Range_Cache_Lo_R : array (Cache_Index) of Ureal;\n+   Determine_Range_Cache_Hi_R : array (Cache_Index) of Ureal;\n    --  The above arrays are used to implement a small direct cache for\n-   --  Determine_Range calls. Because of the way Determine_Range recursively\n-   --  traces subexpressions, and because overflow checking calls the routine\n-   --  on the way up the tree, a quadratic behavior can otherwise be\n-   --  encountered in large expressions. The cache entry for node N is stored\n-   --  in the (N mod Cache_Size) entry, and can be validated by checking the\n-   --  actual node value stored there. The Range_Cache_V array records the\n-   --  setting of Assume_Valid for the cache entry.\n+   --  Determine_Range and Determine_Range_R calls. Because of the way these\n+   --  subprograms recursively traces subexpressions, and because overflow\n+   --  checking calls the routine on the way up the tree, a quadratic behavior\n+   --  can otherwise be encountered in large expressions. The cache entry for\n+   --  node N is stored in the (N mod Cache_Size) entry, and can be validated\n+   --  by checking the actual node value stored there. The Range_Cache_V array\n+   --  records the setting of Assume_Valid for the cache entry.\n \n    procedure Determine_Range\n      (N            : Node_Id;\n@@ -4544,7 +4545,7 @@ package body Checks is\n       if OK1 then\n \n          --  If the refined value of the low bound is greater than the type\n-         --  high bound, then reset it to the more restrictive value. However,\n+         --  low bound, then reset it to the more restrictive value. However,\n          --  we do NOT do this for the case of a modular type where the\n          --  possible upper bound on the value is above the base type high\n          --  bound, because that means the result could wrap.\n@@ -4596,6 +4597,427 @@ package body Checks is\n          end if;\n    end Determine_Range;\n \n+   -----------------------\n+   -- Determine_Range_R --\n+   -----------------------\n+\n+   procedure Determine_Range_R\n+     (N            : Node_Id;\n+      OK           : out Boolean;\n+      Lo           : out Ureal;\n+      Hi           : out Ureal;\n+      Assume_Valid : Boolean := False)\n+   is\n+      Typ : Entity_Id := Etype (N);\n+      --  Type to use, may get reset to base type for possibly invalid entity\n+\n+      Lo_Left : Ureal;\n+      Hi_Left : Ureal;\n+      --  Lo and Hi bounds of left operand\n+\n+      Lo_Right : Ureal;\n+      Hi_Right : Ureal;\n+      --  Lo and Hi bounds of right (or only) operand\n+\n+      Bound : Node_Id;\n+      --  Temp variable used to hold a bound node\n+\n+      Hbound : Ureal;\n+      --  High bound of base type of expression\n+\n+      Lor : Ureal;\n+      Hir : Ureal;\n+      --  Refined values for low and high bounds, after tightening\n+\n+      OK1 : Boolean;\n+      --  Used in lower level calls to indicate if call succeeded\n+\n+      Cindex : Cache_Index;\n+      --  Used to search cache\n+\n+      Btyp : Entity_Id;\n+      --  Base type\n+\n+      function OK_Operands return Boolean;\n+      --  Used for binary operators. Determines the ranges of the left and\n+      --  right operands, and if they are both OK, returns True, and puts\n+      --  the results in Lo_Right, Hi_Right, Lo_Left, Hi_Left.\n+\n+      function Round_Machine (B : Ureal) return Ureal;\n+      --  B is a real bound. Round it using mode Round_Even.\n+\n+      -----------------\n+      -- OK_Operands --\n+      -----------------\n+\n+      function OK_Operands return Boolean is\n+      begin\n+         Determine_Range_R\n+           (Left_Opnd  (N), OK1, Lo_Left,  Hi_Left, Assume_Valid);\n+\n+         if not OK1 then\n+            return False;\n+         end if;\n+\n+         Determine_Range_R\n+           (Right_Opnd (N), OK1, Lo_Right, Hi_Right, Assume_Valid);\n+         return OK1;\n+      end OK_Operands;\n+\n+      -------------------\n+      -- Round_Machine --\n+      -------------------\n+\n+      function Round_Machine (B : Ureal) return Ureal is\n+      begin\n+         return Machine (Typ, B, Round_Even, N);\n+      end Round_Machine;\n+\n+   --  Start of processing for Determine_Range_R\n+\n+   begin\n+      --  Prevent junk warnings by initializing range variables\n+\n+      Lo  := No_Ureal;\n+      Hi  := No_Ureal;\n+      Lor := No_Ureal;\n+      Hir := No_Ureal;\n+\n+      --  For temporary constants internally generated to remove side effects\n+      --  we must use the corresponding expression to determine the range of\n+      --  the expression. But note that the expander can also generate\n+      --  constants in other cases, including deferred constants.\n+\n+      if Is_Entity_Name (N)\n+        and then Nkind (Parent (Entity (N))) = N_Object_Declaration\n+        and then Ekind (Entity (N)) = E_Constant\n+        and then Is_Internal_Name (Chars (Entity (N)))\n+      then\n+         if Present (Expression (Parent (Entity (N)))) then\n+            Determine_Range_R\n+              (Expression (Parent (Entity (N))), OK, Lo, Hi, Assume_Valid);\n+\n+         elsif Present (Full_View (Entity (N))) then\n+            Determine_Range_R\n+              (Expression (Parent (Full_View (Entity (N)))),\n+               OK, Lo, Hi, Assume_Valid);\n+\n+         else\n+            OK := False;\n+         end if;\n+         return;\n+      end if;\n+\n+      --  If type is not defined, we can't determine its range\n+\n+      if No (Typ)\n+\n+        --  We don't deal with anything except IEEE floating-point types\n+\n+        or else not Is_Floating_Point_Type (Typ)\n+        or else Float_Rep (Typ) /= IEEE_Binary\n+\n+        --  Ignore type for which an error has been posted, since range in\n+        --  this case may well be a bogosity deriving from the error. Also\n+        --  ignore if error posted on the reference node.\n+\n+        or else Error_Posted (N) or else Error_Posted (Typ)\n+      then\n+         OK := False;\n+         return;\n+      end if;\n+\n+      --  For all other cases, we can determine the range\n+\n+      OK := True;\n+\n+      --  If value is compile time known, then the possible range is the one\n+      --  value that we know this expression definitely has.\n+\n+      if Compile_Time_Known_Value (N) then\n+         Lo := Expr_Value_R (N);\n+         Hi := Lo;\n+         return;\n+      end if;\n+\n+      --  Return if already in the cache\n+\n+      Cindex := Cache_Index (N mod Cache_Size);\n+\n+      if Determine_Range_Cache_N (Cindex) = N\n+           and then\n+         Determine_Range_Cache_V (Cindex) = Assume_Valid\n+      then\n+         Lo := Determine_Range_Cache_Lo_R (Cindex);\n+         Hi := Determine_Range_Cache_Hi_R (Cindex);\n+         return;\n+      end if;\n+\n+      --  Otherwise, start by finding the bounds of the type of the expression,\n+      --  the value cannot be outside this range (if it is, then we have an\n+      --  overflow situation, which is a separate check, we are talking here\n+      --  only about the expression value).\n+\n+      --  First a check, never try to find the bounds of a generic type, since\n+      --  these bounds are always junk values, and it is only valid to look at\n+      --  the bounds in an instance.\n+\n+      if Is_Generic_Type (Typ) then\n+         OK := False;\n+         return;\n+      end if;\n+\n+      --  First step, change to use base type unless we know the value is valid\n+\n+      if (Is_Entity_Name (N) and then Is_Known_Valid (Entity (N)))\n+        or else Assume_No_Invalid_Values\n+        or else Assume_Valid\n+      then\n+         null;\n+      else\n+         Typ := Underlying_Type (Base_Type (Typ));\n+      end if;\n+\n+      --  Retrieve the base type. Handle the case where the base type is a\n+      --  private type.\n+\n+      Btyp := Base_Type (Typ);\n+\n+      if Is_Private_Type (Btyp) and then Present (Full_View (Btyp)) then\n+         Btyp := Full_View (Btyp);\n+      end if;\n+\n+      --  We use the actual bound unless it is dynamic, in which case use the\n+      --  corresponding base type bound if possible. If we can't get a bound\n+      --  then we figure we can't determine the range (a peculiar case, that\n+      --  perhaps cannot happen, but there is no point in bombing in this\n+      --  optimization circuit).\n+\n+      --  First the low bound\n+\n+      Bound := Type_Low_Bound (Typ);\n+\n+      if Compile_Time_Known_Value (Bound) then\n+         Lo := Expr_Value_R (Bound);\n+\n+      elsif Compile_Time_Known_Value (Type_Low_Bound (Btyp)) then\n+         Lo := Expr_Value_R (Type_Low_Bound (Btyp));\n+\n+      else\n+         OK := False;\n+         return;\n+      end if;\n+\n+      --  Now the high bound\n+\n+      Bound := Type_High_Bound (Typ);\n+\n+      --  We need the high bound of the base type later on, and this should\n+      --  always be compile time known. Again, it is not clear that this\n+      --  can ever be false, but no point in bombing.\n+\n+      if Compile_Time_Known_Value (Type_High_Bound (Btyp)) then\n+         Hbound := Expr_Value_R (Type_High_Bound (Btyp));\n+         Hi := Hbound;\n+\n+      else\n+         OK := False;\n+         return;\n+      end if;\n+\n+      --  If we have a static subtype, then that may have a tighter bound so\n+      --  use the upper bound of the subtype instead in this case.\n+\n+      if Compile_Time_Known_Value (Bound) then\n+         Hi := Expr_Value_R (Bound);\n+      end if;\n+\n+      --  We may be able to refine this value in certain situations. If any\n+      --  refinement is possible, then Lor and Hir are set to possibly tighter\n+      --  bounds, and OK1 is set to True.\n+\n+      case Nkind (N) is\n+\n+         --  For unary plus, result is limited by range of operand\n+\n+         when N_Op_Plus =>\n+            Determine_Range_R\n+              (Right_Opnd (N), OK1, Lor, Hir, Assume_Valid);\n+\n+         --  For unary minus, determine range of operand, and negate it\n+\n+         when N_Op_Minus =>\n+            Determine_Range_R\n+              (Right_Opnd (N), OK1, Lo_Right, Hi_Right, Assume_Valid);\n+\n+            if OK1 then\n+               Lor := -Hi_Right;\n+               Hir := -Lo_Right;\n+            end if;\n+\n+         --  For binary addition, get range of each operand and do the\n+         --  addition to get the result range.\n+\n+         when N_Op_Add =>\n+            if OK_Operands then\n+               Lor := Round_Machine (Lo_Left + Lo_Right);\n+               Hir := Round_Machine (Hi_Left + Hi_Right);\n+            end if;\n+\n+         --  For binary subtraction, get range of each operand and do the worst\n+         --  case subtraction to get the result range.\n+\n+         when N_Op_Subtract =>\n+            if OK_Operands then\n+               Lor := Round_Machine (Lo_Left - Hi_Right);\n+               Hir := Round_Machine (Hi_Left - Lo_Right);\n+            end if;\n+\n+         --  For multiplication, get range of each operand and do the\n+         --  four multiplications to get the result range.\n+\n+         when N_Op_Multiply =>\n+            if OK_Operands then\n+               declare\n+                  M1 : constant Ureal := Round_Machine (Lo_Left * Lo_Right);\n+                  M2 : constant Ureal := Round_Machine (Lo_Left * Hi_Right);\n+                  M3 : constant Ureal := Round_Machine (Hi_Left * Lo_Right);\n+                  M4 : constant Ureal := Round_Machine (Hi_Left * Hi_Right);\n+               begin\n+                  Lor := UR_Min (UR_Min (M1, M2), UR_Min (M3, M4));\n+                  Hir := UR_Max (UR_Max (M1, M2), UR_Max (M3, M4));\n+               end;\n+            end if;\n+\n+         --  For division, consider separately the cases where the right\n+         --  operand is positive or negative. Otherwise, the right operand\n+         --  can be arbitrarily close to zero, so the result is likely to\n+         --  be unbounded in one direction, do not attempt to compute it.\n+\n+         when N_Op_Divide =>\n+            if OK_Operands then\n+\n+               --  Right operand is positive\n+\n+               if Lo_Right > Ureal_0 then\n+\n+                  --  If the low bound of the left operand is negative, obtain\n+                  --  the overall low bound by dividing it by the smallest\n+                  --  value of the right operand, and otherwise by the largest\n+                  --  value of the right operand.\n+\n+                  if Lo_Left < Ureal_0 then\n+                     Lor := Round_Machine (Lo_Left / Lo_Right);\n+                  else\n+                     Lor := Round_Machine (Lo_Left / Hi_Right);\n+                  end if;\n+\n+                  --  If the high bound of the left operand is negative, obtain\n+                  --  the overall high bound by dividing it by the largest\n+                  --  value of the right operand, and otherwise by the\n+                  --  smallest value of the right operand.\n+\n+                  if Hi_Left < Ureal_0 then\n+                     Hir := Round_Machine (Hi_Left / Hi_Right);\n+                  else\n+                     Hir := Round_Machine (Hi_Left / Lo_Right);\n+                  end if;\n+\n+               --  Right operand is negative\n+\n+               elsif Hi_Right < Ureal_0 then\n+\n+                  --  If the low bound of the left operand is negative, obtain\n+                  --  the overall low bound by dividing it by the largest\n+                  --  value of the right operand, and otherwise by the smallest\n+                  --  value of the right operand.\n+\n+                  if Lo_Left < Ureal_0 then\n+                     Lor := Round_Machine (Lo_Left / Hi_Right);\n+                  else\n+                     Lor := Round_Machine (Lo_Left / Lo_Right);\n+                  end if;\n+\n+                  --  If the high bound of the left operand is negative, obtain\n+                  --  the overall high bound by dividing it by the smallest\n+                  --  value of the right operand, and otherwise by the\n+                  --  largest value of the right operand.\n+\n+                  if Hi_Left < Ureal_0 then\n+                     Hir := Round_Machine (Hi_Left / Lo_Right);\n+                  else\n+                     Hir := Round_Machine (Hi_Left / Hi_Right);\n+                  end if;\n+\n+               else\n+                  OK1 := False;\n+               end if;\n+            end if;\n+\n+         --  For type conversion from one floating-point type to another, we\n+         --  can refine the range using the converted value.\n+\n+         when N_Type_Conversion =>\n+            Determine_Range_R (Expression (N), OK1, Lor, Hir, Assume_Valid);\n+\n+         --  Nothing special to do for all other expression kinds\n+\n+         when others =>\n+            OK1 := False;\n+            Lor := No_Ureal;\n+            Hir := No_Ureal;\n+      end case;\n+\n+      --  At this stage, if OK1 is true, then we know that the actual result of\n+      --  the computed expression is in the range Lor .. Hir. We can use this\n+      --  to restrict the possible range of results.\n+\n+      if OK1 then\n+\n+         --  If the refined value of the low bound is greater than the type\n+         --  low bound, then reset it to the more restrictive value.\n+\n+         if Lor > Lo then\n+            Lo := Lor;\n+         end if;\n+\n+         --  Similarly, if the refined value of the high bound is less than the\n+         --  value so far, then reset it to the more restrictive value.\n+\n+         if Hir < Hi then\n+            Hi := Hir;\n+         end if;\n+      end if;\n+\n+      --  Set cache entry for future call and we are all done\n+\n+      Determine_Range_Cache_N    (Cindex) := N;\n+      Determine_Range_Cache_V    (Cindex) := Assume_Valid;\n+      Determine_Range_Cache_Lo_R (Cindex) := Lo;\n+      Determine_Range_Cache_Hi_R (Cindex) := Hi;\n+      return;\n+\n+   --  If any exception occurs, it means that we have some bug in the compiler,\n+   --  possibly triggered by a previous error, or by some unforeseen peculiar\n+   --  occurrence. However, this is only an optimization attempt, so there is\n+   --  really no point in crashing the compiler. Instead we just decide, too\n+   --  bad, we can't figure out a range in this case after all.\n+\n+   exception\n+      when others =>\n+\n+         --  Debug flag K disables this behavior (useful for debugging)\n+\n+         if Debug_Flag_K then\n+            raise;\n+         else\n+            OK := False;\n+            Lo := No_Ureal;\n+            Hi := No_Ureal;\n+            return;\n+         end if;\n+   end Determine_Range_R;\n+\n    ------------------------------------\n    -- Discriminant_Checks_Suppressed --\n    ------------------------------------"}, {"sha": "56dcbf50da23d7f9c404b37e09053ad23f9ce09a", "filename": "gcc/ada/checks.ads", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6bce610bb78e3cbe6a7d00d66270b9ba71e5a8/gcc%2Fada%2Fchecks.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6bce610bb78e3cbe6a7d00d66270b9ba71e5a8/gcc%2Fada%2Fchecks.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.ads?ref=6b6bce610bb78e3cbe6a7d00d66270b9ba71e5a8", "patch": "@@ -40,6 +40,7 @@ with Namet;  use Namet;\n with Table;\n with Types;  use Types;\n with Uintp;  use Uintp;\n+with Urealp; use Urealp;\n \n package Checks is\n \n@@ -302,6 +303,18 @@ package Checks is\n    --  then this assumption is valid, if False, then processing is done using\n    --  base types to allow invalid values.\n \n+   procedure Determine_Range_R\n+     (N            : Node_Id;\n+      OK           : out Boolean;\n+      Lo           : out Ureal;\n+      Hi           : out Ureal;\n+      Assume_Valid : Boolean := False);\n+   --  Similar to Determine_Range, but for a node N of floating-point type. OK\n+   --  is True on return only for IEEE floating-point types and only if we do\n+   --  not have to worry about extended precision (i.e. on the x86, we must be\n+   --  using -msse2 -mfpmath=sse. At the current time, this is used only in\n+   --  GNATprove, though we could consider using it more generally in future.\n+\n    procedure Install_Null_Excluding_Check (N : Node_Id);\n    --  Determines whether an access node requires a runtime access check and\n    --  if so inserts the appropriate run-time check."}, {"sha": "d19ca28bfacbcc9e793be62e1b0afa6e026603fb", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6bce610bb78e3cbe6a7d00d66270b9ba71e5a8/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6bce610bb78e3cbe6a7d00d66270b9ba71e5a8/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=6b6bce610bb78e3cbe6a7d00d66270b9ba71e5a8", "patch": "@@ -5345,10 +5345,11 @@ package body Exp_Aggr is\n          --  then we could go into an infinite recursion.\n \n          if (In_Place_Assign_OK_For_Declaration or else Maybe_In_Place_OK)\n-           and then not AAMP_On_Target\n            and then VM_Target = No_VM\n+           and then not AAMP_On_Target\n            and then not Generate_SCIL\n            and then not Possible_Bit_Aligned_Component (Target)\n+           and then not Is_Possibly_Unaligned_Slice (Target)\n            and then Aggr_Assignment_OK_For_Backend (N)\n          then\n             if Maybe_In_Place_OK then"}, {"sha": "6c2adbac5e8e29bea1472ee6dce97902ea6d212d", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6bce610bb78e3cbe6a7d00d66270b9ba71e5a8/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6bce610bb78e3cbe6a7d00d66270b9ba71e5a8/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=6b6bce610bb78e3cbe6a7d00d66270b9ba71e5a8", "patch": "@@ -5041,18 +5041,6 @@ package body Exp_Util is\n          return False;\n       end if;\n \n-      --  Always assume the worst for a nested record component with a\n-      --  component clause, which gigi/gcc does not appear to handle well.\n-      --  It is not clear why this special test is needed at all ???\n-\n-      if Nkind (Prefix (N)) = N_Selected_Component\n-        and then Nkind (Prefix (Prefix (N))) = N_Selected_Component\n-        and then\n-          Present (Component_Clause (Entity (Selector_Name (Prefix (N)))))\n-      then\n-         return True;\n-      end if;\n-\n       --  We only need to worry if the target has strict alignment\n \n       if not Target_Strict_Alignment then"}, {"sha": "46a4be55113feb784b7aeab526f449f135dd7df4", "filename": "gcc/ada/s-tassta.adb", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b6bce610bb78e3cbe6a7d00d66270b9ba71e5a8/gcc%2Fada%2Fs-tassta.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b6bce610bb78e3cbe6a7d00d66270b9ba71e5a8/gcc%2Fada%2Fs-tassta.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tassta.adb?ref=6b6bce610bb78e3cbe6a7d00d66270b9ba71e5a8", "patch": "@@ -1524,12 +1524,6 @@ package body System.Tasking.Stages is\n         Ada.Unchecked_Conversion\n          (Task_Id, System.Task_Primitives.Task_Address);\n \n-      function Tailored_Exception_Information\n-        (E : Exception_Occurrence) return String;\n-      pragma Import\n-        (Ada, Tailored_Exception_Information,\n-         \"__gnat_tailored_exception_information\");\n-\n       Excep : constant Exception_Occurrence_Access :=\n                 SSL.Get_Current_Excep.all;\n \n@@ -1553,7 +1547,7 @@ package body System.Tasking.Stages is\n       To_Stderr (System.Address_Image (To_Address (Self_Id)));\n       To_Stderr (\" terminated by unhandled exception\");\n       To_Stderr ((1 => ASCII.LF));\n-      To_Stderr (Tailored_Exception_Information (Excep.all));\n+      To_Stderr (Exception_Information (Excep.all));\n       Initialization.Task_Unlock (Self_Id);\n    end Trace_Unhandled_Exception_In_Task;\n "}]}