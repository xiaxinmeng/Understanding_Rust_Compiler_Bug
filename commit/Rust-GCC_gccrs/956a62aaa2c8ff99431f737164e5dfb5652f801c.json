{"sha": "956a62aaa2c8ff99431f737164e5dfb5652f801c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTU2YTYyYWFhMmM4ZmY5OTQzMWY3MzcxNjRlNWRmYjU2NTJmODAxYw==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2019-05-14T16:46:07Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2019-05-14T16:46:07Z"}, "message": "Add __raw_visit and __raw_idx_visit, use INVOKE<R>\n\nThis change simplifies visitation for variants, by using INVOKE<R> for\nthe visit<R> form, and explicitly specifying the tag types for raw\nvisitation, instead of inferring them from the return types of the\nlambda functions used as visitors.\n\n\t* include/std/variant (__visit_with_index): Remove typedef.\n\t(__deduce_visit_result): New tag type.\n\t(__raw_visit, __raw_idx_visit): New helper functions for \"raw\"\n\tvisitation of possibly-valueless variants, forwarding to __do_visit\n\twith the relevant tag type.\n\t(_Variant_storage<false, _Types...>::_M_reset_impl): Use __raw_visit\n\tand make lambda return void.\n\t(__variant_construct): Likewise.\n\t(_Copy_assign_base::operator=, _Move_assign_base::operator=): Use\n\t__raw_idx_visit and make lambda return void.\n\t(_Multi_array::__untag_result): Add metafunction to check the function\n\tpointer type for a tag type that dictates the kind of visitation.\n\t(_Multi_array<_Ret(*)(_Visitor, _Variants...), __first, __rest...>):\n\tUse decltype(auto) instead of tagged function pointer type.\n\t(__gen_vtable_impl): Remove bool non-type parameter and unused\n\t_Variant_tuple parameter.\n\t(__gen_vtable_impl::__visit_invoke_impl): Remove.\n\t(__gen_vtable_impl::__do_visit_invoke): Remove.\n\t(__gen_vtable_impl::__do_visit_invoke_r): Remove.\n\t(__gen_vtable_impl::__visit_invoke): Use if-constexpr and __invoke_r\n\tfor the visit<R> case, rather than dispatching to separate functions.\n\t(_VARIANT_RELATION_FUNCTION_TEMPLATE): Use __raw_idx_visit and make\n\tlambda return void.\n\t(variant::swap): Likewise.\n\t(__do_visit): Replace two non-type template parameters with a single\n\ttype parameter, so that the caller must specify the visitor's return\n\ttype (or one of the tag types).\n\t(visit): Deduce a return type from the visitor and use the\n\t__deduce_visit_result tag to enforce that all overloads return the\n\tsame type.\n\t(visit<R>): Call __do_visit<R> with explicit result type.\n\t(__variant_hash_call_base_impl::operator()): Use __raw_visit and make\n\tlambda return void.\n\nFrom-SVN: r271182", "tree": {"sha": "3d97a643a0c42a488d851e96128edd5edd8ab92b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3d97a643a0c42a488d851e96128edd5edd8ab92b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/956a62aaa2c8ff99431f737164e5dfb5652f801c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/956a62aaa2c8ff99431f737164e5dfb5652f801c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/956a62aaa2c8ff99431f737164e5dfb5652f801c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/956a62aaa2c8ff99431f737164e5dfb5652f801c/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "00f0898d2f11c54cfe39e497ec3f60235483a839", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00f0898d2f11c54cfe39e497ec3f60235483a839", "html_url": "https://github.com/Rust-GCC/gccrs/commit/00f0898d2f11c54cfe39e497ec3f60235483a839"}], "stats": {"total": 262, "additions": 139, "deletions": 123}, "files": [{"sha": "efb70a7724ebc7b2a3358300ca51a27f44d27d3a", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/956a62aaa2c8ff99431f737164e5dfb5652f801c/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/956a62aaa2c8ff99431f737164e5dfb5652f801c/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=956a62aaa2c8ff99431f737164e5dfb5652f801c", "patch": "@@ -1,3 +1,39 @@\n+2019-05-14  Jonathan Wakely  <jwakely@redhat.com>\n+\n+\t* include/std/variant (__visit_with_index): Remove typedef.\n+\t(__deduce_visit_result): New tag type.\n+\t(__raw_visit, __raw_idx_visit): New helper functions for \"raw\"\n+\tvisitation of possibly-valueless variants, forwarding to __do_visit\n+\twith the relevant tag type.\n+\t(_Variant_storage<false, _Types...>::_M_reset_impl): Use __raw_visit\n+\tand make lambda return void.\n+\t(__variant_construct): Likewise.\n+\t(_Copy_assign_base::operator=, _Move_assign_base::operator=): Use\n+\t__raw_idx_visit and make lambda return void.\n+\t(_Multi_array::__untag_result): Add metafunction to check the function\n+\tpointer type for a tag type that dictates the kind of visitation.\n+\t(_Multi_array<_Ret(*)(_Visitor, _Variants...), __first, __rest...>):\n+\tUse decltype(auto) instead of tagged function pointer type.\n+\t(__gen_vtable_impl): Remove bool non-type parameter and unused\n+\t_Variant_tuple parameter.\n+\t(__gen_vtable_impl::__visit_invoke_impl): Remove.\n+\t(__gen_vtable_impl::__do_visit_invoke): Remove.\n+\t(__gen_vtable_impl::__do_visit_invoke_r): Remove.\n+\t(__gen_vtable_impl::__visit_invoke): Use if-constexpr and __invoke_r\n+\tfor the visit<R> case, rather than dispatching to separate functions.\n+\t(_VARIANT_RELATION_FUNCTION_TEMPLATE): Use __raw_idx_visit and make\n+\tlambda return void.\n+\t(variant::swap): Likewise.\n+\t(__do_visit): Replace two non-type template parameters with a single\n+\ttype parameter, so that the caller must specify the visitor's return\n+\ttype (or one of the tag types).\n+\t(visit): Deduce a return type from the visitor and use the\n+\t__deduce_visit_result tag to enforce that all overloads return the\n+\tsame type.\n+\t(visit<R>): Call __do_visit<R> with explicit result type.\n+\t(__variant_hash_call_base_impl::operator()): Use __raw_visit and make\n+\tlambda return void.\n+\n 2019-05-14  Nina Dinka Ranns  <dinka.ranns@gmail.com>\n \n \tnonesuch is insufficiently useless (lwg2996)"}, {"sha": "dc4bbb7f356f416f1c87de76b1021823dd15e8eb", "filename": "libstdc++-v3/include/std/variant", "status": "modified", "additions": 103, "deletions": 123, "changes": 226, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/956a62aaa2c8ff99431f737164e5dfb5652f801c/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fvariant", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/956a62aaa2c8ff99431f737164e5dfb5652f801c/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fvariant", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fvariant?ref=956a62aaa2c8ff99431f737164e5dfb5652f801c", "patch": "@@ -138,9 +138,7 @@ namespace __variant\n     constexpr variant_alternative_t<_Np, variant<_Types...>> const&&\n     get(const variant<_Types...>&&);\n \n-  template<bool __use_index=false,\n-\t   bool __same_return_types = true,\n-\t   typename _Visitor, typename... _Variants>\n+  template<typename _Result_type, typename _Visitor, typename... _Variants>\n     constexpr decltype(auto)\n     __do_visit(_Visitor&& __visitor, _Variants&&... __variants);\n \n@@ -180,8 +178,26 @@ namespace __variant\n   struct __variant_cookie {};\n   // used for raw visitation with indices passed in\n   struct __variant_idx_cookie { using type = __variant_idx_cookie; };\n-  // a more explanatory name than 'true'\n-  inline constexpr auto __visit_with_index = bool_constant<true>{};\n+  // Used to enable deduction (and same-type checking) for std::visit:\n+  template<typename> struct __deduce_visit_result { };\n+\n+  // Visit variants that might be valueless.\n+  template<typename _Visitor, typename... _Variants>\n+    constexpr void\n+    __raw_visit(_Visitor&& __visitor, _Variants&&... __variants)\n+    {\n+      std::__do_visit<__variant_cookie>(std::forward<_Visitor>(__visitor),\n+\t\t\t\t        std::forward<_Variants>(__variants)...);\n+    }\n+\n+  // Visit variants that might be valueless, passing indices to the visitor.\n+  template<typename _Visitor, typename... _Variants>\n+    constexpr void\n+    __raw_idx_visit(_Visitor&& __visitor, _Variants&&... __variants)\n+    {\n+      std::__do_visit<__variant_idx_cookie>(std::forward<_Visitor>(__visitor),\n+\t  std::forward<_Variants>(__variants)...);\n+    }\n \n   // _Uninitialized<T> is guaranteed to be a literal type, even if T is not.\n   // We have to do this, because [basic.types]p10.5.3 (n4606) is not implemented\n@@ -382,13 +398,11 @@ namespace __variant\n \n       constexpr void _M_reset_impl()\n       {\n-\t__do_visit([](auto&& __this_mem) mutable\n-\t\t   -> __detail::__variant::__variant_cookie\n+\t__variant::__raw_visit([](auto&& __this_mem) mutable\n \t  {\n \t    if constexpr (!is_same_v<remove_reference_t<decltype(__this_mem)>,\n \t\t\t  __variant_cookie>)\n \t      std::_Destroy(std::__addressof(__this_mem));\n-\t    return {};\n \t  }, __variant_cast<_Types...>(*this));\n       }\n \n@@ -473,12 +487,10 @@ namespace __variant\n     void __variant_construct(_Tp&& __lhs, _Up&& __rhs)\n     {\n       __lhs._M_index = __rhs._M_index;\n-      __do_visit([&__lhs](auto&& __rhs_mem) mutable\n-\t\t -> __detail::__variant::__variant_cookie\n+      __variant::__raw_visit([&__lhs](auto&& __rhs_mem) mutable\n         {\n \t  __variant_construct_single(std::forward<_Tp>(__lhs),\n \t      std::forward<decltype(__rhs_mem)>(__rhs_mem));\n-\t  return {};\n \t}, __variant_cast<_Types...>(std::forward<_Up>(__rhs)));\n     }\n \n@@ -583,9 +595,8 @@ namespace __variant\n       operator=(const _Copy_assign_base& __rhs)\n \t  noexcept(_Traits<_Types...>::_S_nothrow_copy_assign)\n       {\n-\t__do_visit<__visit_with_index>([this](auto&& __rhs_mem,\n-\t\t\t\t\t      auto __rhs_index) mutable\n-\t    -> __detail::__variant::__variant_idx_cookie\n+\t__variant::__raw_idx_visit(\n+\t  [this](auto&& __rhs_mem, auto __rhs_index) mutable\n \t  {\n \t    if constexpr (__rhs_index != variant_npos)\n \t      {\n@@ -611,7 +622,6 @@ namespace __variant\n \t      }\n \t    else\n \t      this->_M_reset();\n-\t    return {};\n \t  }, __variant_cast<_Types...>(__rhs));\n \treturn *this;\n       }\n@@ -642,9 +652,8 @@ namespace __variant\n       operator=(_Move_assign_base&& __rhs)\n \t  noexcept(_Traits<_Types...>::_S_nothrow_move_assign)\n       {\n-\t__do_visit<__visit_with_index>([this](auto&& __rhs_mem,\n-\t\t\t\t\t      auto __rhs_index) mutable\n-\t    -> __detail::__variant::__variant_idx_cookie\n+\t__variant::__raw_idx_visit(\n+\t  [this](auto&& __rhs_mem, auto __rhs_index) mutable\n \t  {\n \t    if constexpr (__rhs_index != variant_npos)\n \t      {\n@@ -656,7 +665,6 @@ namespace __variant\n \t      }\n \t    else\n \t      this->_M_reset();\n-\t    return {};\n \t  }, __variant_cast<_Types...>(__rhs));\n \treturn *this;\n       }\n@@ -786,11 +794,38 @@ namespace __variant\n   template<typename _Tp>\n     struct _Multi_array<_Tp>\n     {\n-      constexpr const _Tp&\n+      template<typename>\n+\tstruct __untag_result\n+\t: false_type\n+\t{ using element_type = _Tp; };\n+\n+      template <typename... _Args>\n+\tstruct __untag_result<const void(*)(_Args...)>\n+\t: false_type\n+\t{ using element_type = void(*)(_Args...); };\n+\n+      template <typename... _Args>\n+\tstruct __untag_result<__variant_cookie(*)(_Args...)>\n+\t: false_type\n+\t{ using element_type = void(*)(_Args...); };\n+\n+      template <typename... _Args>\n+\tstruct __untag_result<__variant_idx_cookie(*)(_Args...)>\n+\t: false_type\n+\t{ using element_type = void(*)(_Args...); };\n+\n+      template <typename _Res, typename... _Args>\n+\tstruct __untag_result<__deduce_visit_result<_Res>(*)(_Args...)>\n+\t: true_type\n+\t{ using element_type = _Res(*)(_Args...); };\n+\n+      using __result_is_deduced = __untag_result<_Tp>;\n+\n+      constexpr const typename __untag_result<_Tp>::element_type&\n       _M_access() const\n       { return _M_data; }\n \n-      _Tp _M_data;\n+      typename __untag_result<_Tp>::element_type _M_data;\n     };\n \n   // Partial specialization with rank >= 1.\n@@ -811,7 +846,7 @@ namespace __variant\n       using _Tp = _Ret(*)(_Visitor, _Variants...);\n \n       template<typename... _Args>\n-\tconstexpr const _Tp&\n+\tconstexpr decltype(auto)\n \t_M_access(size_t __first_index, _Args... __rest_indices) const\n         {\n \t  return _M_arr[__first_index + __do_cookie]\n@@ -823,37 +858,32 @@ namespace __variant\n \n   // Creates a multi-dimensional vtable recursively.\n   //\n-  // The __same_return_types non-type template parameter specifies whether\n-  // to enforce that all visitor invocations return the same type. This is\n-  // required by std::visit but not std::visit<R>.\n-  //\n   // For example,\n   // visit([](auto, auto){},\n   //       variant<int, char>(),  // typedef'ed as V1\n   //       variant<float, double, long double>())  // typedef'ed as V2\n   // will trigger instantiations of:\n-  // __gen_vtable_impl<true, _Multi_array<void(*)(V1&&, V2&&), 2, 3>,\n+  // __gen_vtable_impl<_Multi_array<void(*)(V1&&, V2&&), 2, 3>,\n   //                   tuple<V1&&, V2&&>, std::index_sequence<>>\n-  //   __gen_vtable_impl<true, _Multi_array<void(*)(V1&&, V2&&), 3>,\n+  //   __gen_vtable_impl<_Multi_array<void(*)(V1&&, V2&&), 3>,\n   //                     tuple<V1&&, V2&&>, std::index_sequence<0>>\n-  //     __gen_vtable_impl<true, _Multi_array<void(*)(V1&&, V2&&)>,\n+  //     __gen_vtable_impl<_Multi_array<void(*)(V1&&, V2&&)>,\n   //                       tuple<V1&&, V2&&>, std::index_sequence<0, 0>>\n-  //     __gen_vtable_impl<true, _Multi_array<void(*)(V1&&, V2&&)>,\n+  //     __gen_vtable_impl<_Multi_array<void(*)(V1&&, V2&&)>,\n   //                       tuple<V1&&, V2&&>, std::index_sequence<0, 1>>\n-  //     __gen_vtable_impl<true, _Multi_array<void(*)(V1&&, V2&&)>,\n+  //     __gen_vtable_impl<_Multi_array<void(*)(V1&&, V2&&)>,\n   //                       tuple<V1&&, V2&&>, std::index_sequence<0, 2>>\n-  //   __gen_vtable_impl<true, _Multi_array<void(*)(V1&&, V2&&), 3>,\n+  //   __gen_vtable_impl<_Multi_array<void(*)(V1&&, V2&&), 3>,\n   //                     tuple<V1&&, V2&&>, std::index_sequence<1>>\n-  //     __gen_vtable_impl<true, _Multi_array<void(*)(V1&&, V2&&)>,\n+  //     __gen_vtable_impl<_Multi_array<void(*)(V1&&, V2&&)>,\n   //                       tuple<V1&&, V2&&>, std::index_sequence<1, 0>>\n-  //     __gen_vtable_impl<true, _Multi_array<void(*)(V1&&, V2&&)>,\n+  //     __gen_vtable_impl<_Multi_array<void(*)(V1&&, V2&&)>,\n   //                       tuple<V1&&, V2&&>, std::index_sequence<1, 1>>\n-  //     __gen_vtable_impl<true, _Multi_array<void(*)(V1&&, V2&&)>,\n+  //     __gen_vtable_impl<_Multi_array<void(*)(V1&&, V2&&)>,\n   //                       tuple<V1&&, V2&&>, std::index_sequence<1, 2>>\n   // The returned multi-dimensional vtable can be fast accessed by the visitor\n   // using index calculation.\n-  template<bool __same_return_types,\n-\t   typename _Array_type, typename _Variant_tuple, typename _Index_seq>\n+  template<typename _Array_type, typename _Index_seq>\n     struct __gen_vtable_impl;\n \n   // Defines the _S_apply() member that returns a _Multi_array populated\n@@ -863,13 +893,11 @@ namespace __variant\n   // This partial specialization builds up the index sequences by recursively\n   // calling _S_apply() on the next specialization of __gen_vtable_impl.\n   // The base case of the recursion defines the actual function pointers.\n-  template<bool __same_return_types,\n-\t   typename _Result_type, typename _Visitor, size_t... __dimensions,\n+  template<typename _Result_type, typename _Visitor, size_t... __dimensions,\n \t   typename... _Variants, size_t... __indices>\n     struct __gen_vtable_impl<\n-        __same_return_types,\n \t_Multi_array<_Result_type (*)(_Visitor, _Variants...), __dimensions...>,\n-\ttuple<_Variants...>, std::index_sequence<__indices...>>\n+\tstd::index_sequence<__indices...>>\n     {\n       using _Next =\n \t  remove_reference_t<typename _Nth_type<sizeof...(__indices),\n@@ -905,25 +933,19 @@ namespace __variant\n \tstatic constexpr void\n \t_S_apply_single_alt(_Tp& __element, _Tp* __cookie_element = nullptr)\n \t{\n-\t  using _Alternative = variant_alternative_t<__index, _Next>;\n \t  if constexpr (__do_cookie)\n \t    {\n \t      __element = __gen_vtable_impl<\n-\t\t__same_return_types,\n \t\t_Tp,\n-\t\ttuple<_Variants...>,\n \t\tstd::index_sequence<__indices..., __index>>::_S_apply();\n \t      *__cookie_element = __gen_vtable_impl<\n-\t\t__same_return_types,\n \t\t_Tp,\n-\t\ttuple<_Variants...>,\n \t\tstd::index_sequence<__indices..., variant_npos>>::_S_apply();\n \t    }\n \t  else\n \t    {\n \t      __element = __gen_vtable_impl<\n-\t\t__same_return_types,\n-\t\tremove_reference_t<decltype(__element)>, tuple<_Variants...>,\n+\t\tremove_reference_t<decltype(__element)>,\n \t\tstd::index_sequence<__indices..., __index>>::_S_apply();\n \t    }\n \t}\n@@ -932,13 +954,11 @@ namespace __variant\n   // This partial specialization is the base case for the recursion.\n   // It populates a _Multi_array element with the address of a function\n   // that invokes the visitor with the alternatives specified by __indices.\n-  template<bool __same_return_types,\n-\t   typename _Result_type, typename _Visitor, typename... _Variants,\n+  template<typename _Result_type, typename _Visitor, typename... _Variants,\n \t   size_t... __indices>\n     struct __gen_vtable_impl<\n-      __same_return_types,\n       _Multi_array<_Result_type (*)(_Visitor, _Variants...)>,\n-\t\t   tuple<_Variants...>, std::index_sequence<__indices...>>\n+\t\t   std::index_sequence<__indices...>>\n     {\n       using _Array_type =\n \t  _Multi_array<_Result_type (*)(_Visitor, _Variants...)>;\n@@ -954,69 +974,45 @@ namespace __variant\n \t}\n \n       static constexpr decltype(auto)\n-      __visit_invoke_impl(_Visitor&& __visitor, _Variants... __vars)\n+      __visit_invoke(_Visitor&& __visitor, _Variants... __vars)\n       {\n-\t// For raw visitation using indices, pass the indices to the visitor:\n \tif constexpr (is_same_v<_Result_type, __variant_idx_cookie>)\n-\t  return std::__invoke(std::forward<_Visitor>(__visitor),\n+\t  // For raw visitation using indices, pass the indices to the visitor\n+\t  // and discard the return value:\n+\t  std::__invoke(std::forward<_Visitor>(__visitor),\n \t      __element_by_index_or_cookie<__indices>(\n \t\tstd::forward<_Variants>(__vars))...,\n \t      integral_constant<size_t, __indices>()...);\n-\t// For std::visit<cv void>, cast the result to void:\n-\telse if constexpr (!__same_return_types &&\n-\t\t\t   std::is_void_v<_Result_type>)\n-\t  return (void)std::__invoke(std::forward<_Visitor>(__visitor),\n+\telse if constexpr (is_same_v<_Result_type, __variant_cookie>)\n+\t  // For raw visitation without indices, and discard the return value:\n+\t  std::__invoke(std::forward<_Visitor>(__visitor),\n \t      __element_by_index_or_cookie<__indices>(\n \t\tstd::forward<_Variants>(__vars))...);\n-\telse\n+\telse if constexpr (_Array_type::__result_is_deduced::value)\n+\t  // For the usual std::visit case deduce the return value:\n \t  return std::__invoke(std::forward<_Visitor>(__visitor),\n \t      __element_by_index_or_cookie<__indices>(\n \t\tstd::forward<_Variants>(__vars))...);\n-      }\n-\n-      static constexpr decltype(auto)\n-      __do_visit_invoke(_Visitor&& __visitor, _Variants... __vars)\n-      {\n-\treturn __visit_invoke_impl(std::forward<_Visitor>(__visitor),\n-\t\t\t\t   std::forward<_Variants>(__vars)...);\n-      }\n-\n-      // Perform the implicit conversion to _Result_type for std::visit<R>.\n-      static constexpr _Result_type\n-      __do_visit_invoke_r(_Visitor&& __visitor, _Variants... __vars)\n-      {\n-\treturn __visit_invoke_impl(std::forward<_Visitor>(__visitor),\n-\t\t\t\t   std::forward<_Variants>(__vars)...);\n-      }\n-\n-      static constexpr decltype(auto)\n-      __visit_invoke(_Visitor&& __visitor, _Variants... __vars)\n-      {\n-\tif constexpr (__same_return_types)\n-\t  return __do_visit_invoke(std::forward<_Visitor>(__visitor),\n-\t\t\t\t   std::forward<_Variants>(__vars)...);\n-\telse\n-\t  return __do_visit_invoke_r(std::forward<_Visitor>(__visitor),\n-\t\t\t\t     std::forward<_Variants>(__vars)...);\n+\telse // for std::visit<R> use INVOKE<R>\n+\t  return std::__invoke_r<_Result_type>(\n+\t      std::forward<_Visitor>(__visitor),\n+\t      __variant::__get<__indices>(std::forward<_Variants>(__vars))...);\n       }\n \n       static constexpr auto\n       _S_apply()\n       { return _Array_type{&__visit_invoke}; }\n     };\n \n-  template<bool __same_return_types,\n-\t   typename _Result_type, typename _Visitor, typename... _Variants>\n+  template<typename _Result_type, typename _Visitor, typename... _Variants>\n     struct __gen_vtable\n     {\n       using _Array_type =\n \t  _Multi_array<_Result_type (*)(_Visitor, _Variants...),\n \t\t       variant_size_v<remove_reference_t<_Variants>>...>;\n \n       static constexpr _Array_type _S_vtable\n-\t= __gen_vtable_impl<__same_return_types,\n-\t\t\t    _Array_type, tuple<_Variants...>,\n-\t\t\t    std::index_sequence<>>::_S_apply();\n+\t= __gen_vtable_impl<_Array_type, std::index_sequence<>>::_S_apply();\n     };\n \n   template<size_t _Np, typename _Tp>\n@@ -1147,10 +1143,8 @@ namespace __variant\n \t\t\t\t const variant<_Types...>& __rhs) \\\n     { \\\n       bool __ret = true; \\\n-      __do_visit<__detail::__variant::__visit_with_index>( \\\n-        [&__ret, &__lhs] \\\n-\t\t (auto&& __rhs_mem, auto __rhs_index) mutable \\\n-\t\t   -> __detail::__variant::__variant_idx_cookie \\\n+      __detail::__variant::__raw_idx_visit( \\\n+        [&__ret, &__lhs] (auto&& __rhs_mem, auto __rhs_index) mutable \\\n         { \\\n \t  if constexpr (__rhs_index != variant_npos) \\\n \t    { \\\n@@ -1164,7 +1158,6 @@ namespace __variant\n             } \\\n           else \\\n             __ret = (__lhs.index() + 1) __OP (__rhs_index + 1); \\\n-\t  return {}; \\\n \t}, __rhs); \\\n       return __ret; \\\n     } \\\n@@ -1504,10 +1497,8 @@ namespace __variant\n       noexcept((__is_nothrow_swappable<_Types>::value && ...)\n \t       && is_nothrow_move_constructible_v<variant>)\n       {\n-\t__do_visit<__detail::__variant::__visit_with_index>(\n-\t  [this, &__rhs](auto&& __rhs_mem,\n-\t\t\t auto __rhs_index) mutable\n-\t    -> __detail::__variant::__variant_idx_cookie\n+\t__detail::__variant::__raw_idx_visit(\n+\t  [this, &__rhs](auto&& __rhs_mem, auto __rhs_index) mutable\n \t  {\n \t    if constexpr (__rhs_index != variant_npos)\n \t      {\n@@ -1543,7 +1534,6 @@ namespace __variant\n \t\t    this->_M_reset();\n \t\t  }\n \t      }\n-\t    return {};\n \t  }, __rhs);\n       }\n \n@@ -1623,21 +1613,11 @@ namespace __variant\n       return __detail::__variant::__get<_Np>(std::move(__v));\n     }\n \n-  template<bool __use_index,\n-\t   bool __same_return_types,\n-\t   typename _Visitor, typename... _Variants>\n+  template<typename _Result_type, typename _Visitor, typename... _Variants>\n     constexpr decltype(auto)\n     __do_visit(_Visitor&& __visitor, _Variants&&... __variants)\n     {\n-      using _Deduced_type = std::invoke_result<_Visitor,\n-\tdecltype(std::get<0>(std::declval<_Variants>()))...>;\n-\n-      using _Result_type = typename std::conditional_t<__use_index,\n-\t__detail::__variant::__variant_idx_cookie,\n-\t_Deduced_type>::type;\n-\n       constexpr auto& __vtable = __detail::__variant::__gen_vtable<\n-\t__same_return_types,\n \t_Result_type, _Visitor&&, _Variants&&...>::_S_vtable;\n \n       auto __func_ptr = __vtable._M_access(__variants.index()...);\n@@ -1652,8 +1632,13 @@ namespace __variant\n       if ((__variants.valueless_by_exception() || ...))\n \t__throw_bad_variant_access(\"Unexpected index\");\n \n-      return __do_visit(std::forward<_Visitor>(__visitor),\n-\t\t\tstd::forward<_Variants>(__variants)...);\n+      using _Result_type = std::invoke_result_t<_Visitor,\n+\tdecltype(std::get<0>(std::declval<_Variants>()))...>;\n+\n+      using _Tag = __detail::__variant::__deduce_visit_result<_Result_type>;\n+\n+      return __do_visit<_Tag>(std::forward<_Visitor>(__visitor),\n+\t\t\t      std::forward<_Variants>(__variants)...);\n     }\n \n #if __cplusplus > 201703L\n@@ -1664,12 +1649,8 @@ namespace __variant\n       if ((__variants.valueless_by_exception() || ...))\n \t__throw_bad_variant_access(\"Unexpected index\");\n \n-      if constexpr (std::is_void_v<_Res>)\n-        (void) __do_visit<false, false>(std::forward<_Visitor>(__visitor),\n-\t\t\t\t\tstd::forward<_Variants>(__variants)...);\n-      else\n-\treturn __do_visit<false, false>(std::forward<_Visitor>(__visitor),\n-\t\t\t\t\tstd::forward<_Variants>(__variants)...);\n+      return __do_visit<_Res>(std::forward<_Visitor>(__visitor),\n+\t\t\t      std::forward<_Variants>(__variants)...);\n     }\n #endif\n \n@@ -1681,8 +1662,8 @@ namespace __variant\n       noexcept((is_nothrow_invocable_v<hash<decay_t<_Types>>, _Types> && ...))\n       {\n \tsize_t __ret;\n-\t__do_visit([&__t, &__ret](auto&& __t_mem) mutable\n-\t\t   -> __detail::__variant::__variant_cookie\n+\t__detail::__variant::__raw_visit(\n+\t  [&__t, &__ret](auto&& __t_mem) mutable\n \t  {\n \t    using _Type = __remove_cvref_t<decltype(__t_mem)>;\n \t    if constexpr (!is_same_v<_Type,\n@@ -1691,7 +1672,6 @@ namespace __variant\n \t\t      + std::hash<_Type>{}(__t_mem);\n \t    else\n \t      __ret = std::hash<size_t>{}(__t.index());\n-\t    return {};\n \t  }, __t);\n \treturn __ret;\n       }"}]}