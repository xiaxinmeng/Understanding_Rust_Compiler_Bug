{"sha": "848205e6edc05cb41e877c5835244ce3bd133fda", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODQ4MjA1ZTZlZGMwNWNiNDFlODc3YzU4MzUyNDRjZTNiZDEzM2ZkYQ==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@cygnus.com", "date": "1998-07-02T11:42:39Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1998-07-02T11:42:39Z"}, "message": "Add initial varray support infrastructure\n\nFrom-SVN: r20892", "tree": {"sha": "3c0b7c2e8e7833bd540531f442c4612435c1c382", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3c0b7c2e8e7833bd540531f442c4612435c1c382"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/848205e6edc05cb41e877c5835244ce3bd133fda", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/848205e6edc05cb41e877c5835244ce3bd133fda", "html_url": "https://github.com/Rust-GCC/gccrs/commit/848205e6edc05cb41e877c5835244ce3bd133fda", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/848205e6edc05cb41e877c5835244ce3bd133fda/comments", "author": null, "committer": null, "parents": [{"sha": "44bb0e9324d7bdd892a20e816314be646a920f06", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44bb0e9324d7bdd892a20e816314be646a920f06", "html_url": "https://github.com/Rust-GCC/gccrs/commit/44bb0e9324d7bdd892a20e816314be646a920f06"}], "stats": {"total": 286, "additions": 281, "deletions": 5}, "files": [{"sha": "9f0bfba2e2e2ec9691a72c2a772e46caf2a1b27d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/848205e6edc05cb41e877c5835244ce3bd133fda/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/848205e6edc05cb41e877c5835244ce3bd133fda/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=848205e6edc05cb41e877c5835244ce3bd133fda", "patch": "@@ -1,3 +1,13 @@\n+Thu Jul  2 14:16:11 1998  Michael Meissner  <meissner@cygnus.com>\n+\n+\t* varray.{c,h}: New files to provide virtual array support.\n+\t* Makefile.in (OBJS): Add varray.o.\n+\t(varray.o): Add new file.\n+\n+\t* toplev.c (x{m,re}alloc): If size is 0, allocate 1 byte.\n+\t(xcalloc): Provide frontend for calloc.\n+\t* {tree,rtl}.h (xcalloc): Add declaration.\n+\n Thu Jul  2 10:11:47 1998  Robert Lipe  <robertl@dgii.com>\n \n \t* install.texi (sco3.2v5): Document new --with-gnu-as flag."}, {"sha": "7515dcf4c3cb89bc9c4381b0221335e285b19432", "filename": "gcc/rtl.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/848205e6edc05cb41e877c5835244ce3bd133fda/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/848205e6edc05cb41e877c5835244ce3bd133fda/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=848205e6edc05cb41e877c5835244ce3bd133fda", "patch": "@@ -830,9 +830,11 @@ extern rtx read_rtx\t\t\tPROTO((FILE *));\n    cast their pointers to char *, and all of the xrealloc's don't use\n    void * yet.  */\n extern char *xmalloc\t\t\tPROTO((size_t));\n+extern char *xcalloc\t\t\tPROTO((size_t, size_t));\n extern char *xrealloc\t\t\tPROTO((void *, size_t));\n #else\n extern char *xmalloc ();\n+extern char *xcalloc ();\n extern char *xrealloc ();\n #endif\n "}, {"sha": "6bc76632a2a55ac17ee2754788cb3a46ecfe8949", "filename": "gcc/toplev.c", "status": "modified", "additions": 35, "deletions": 5, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/848205e6edc05cb41e877c5835244ce3bd133fda/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/848205e6edc05cb41e877c5835244ce3bd133fda/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=848205e6edc05cb41e877c5835244ce3bd133fda", "patch": "@@ -1968,12 +1968,35 @@ char *\n xmalloc (size)\n      unsigned size;\n {\n-  register char *value = (char *) malloc (size);\n-  if (value == 0 && size != 0)\n+  register char *value;\n+\n+  if (size == 0)\n+    size = 1;\n+\n+  value = (char *) malloc (size);\n+  if (value == 0)\n+    fatal (\"virtual memory exhausted\");\n+  return value;\n+}\n+\n+/* Same as `calloc' but report error if no memory available.  */\n+\n+char *\n+xcalloc (size1, size2)\n+     unsigned size1, size2;\n+{\n+  register char *value;\n+\n+  if (size1 == 0 || size2 == 0)\n+    size1 = size2 = 1;\n+\n+  value = (char *) calloc (size1, size2);\n+  if (value == 0)\n     fatal (\"virtual memory exhausted\");\n   return value;\n }\n \n+\n /* Same as `realloc' but report error if no memory available.  \n    Also handle null PTR even if the vendor realloc gets it wrong.  */\n \n@@ -1982,11 +2005,18 @@ xrealloc (ptr, size)\n      char *ptr;\n      int size;\n {\n-  char *result = (ptr\n-\t\t  ? (char *) realloc (ptr, size)\n-\t\t  : (char *) malloc (size));\n+  char *result;\n+\n+  if (size == 0)\n+    size = 1;\n+\n+  result = (ptr\n+\t    ? (char *) realloc (ptr, size)\n+\t    : (char *) malloc (size));\n+\n   if (!result)\n     fatal (\"virtual memory exhausted\");\n+\n   return result;\n }\n "}, {"sha": "b98f5552fa64f94008f337c6711114bcac66c319", "filename": "gcc/tree.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/848205e6edc05cb41e877c5835244ce3bd133fda/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/848205e6edc05cb41e877c5835244ce3bd133fda/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=848205e6edc05cb41e877c5835244ce3bd133fda", "patch": "@@ -1314,9 +1314,11 @@ extern int floor_log2_wide             PROTO((unsigned HOST_WIDE_INT));\n    cast their pointers to char *, and all of the xrealloc's don't use\n    void * yet.  */\n extern char *xmalloc\t\t\tPROTO((size_t));\n+extern char *xcalloc\t\t\tPROTO((size_t, size_t));\n extern char *xrealloc\t\t\tPROTO((void *, size_t));\n #else\n extern char *xmalloc ();\n+extern char *xcalloc ();\n extern char *xrealloc ();\n #endif\n "}, {"sha": "80f15b264b4dde1be1f6de513081c013d01aae02", "filename": "gcc/varray.c", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/848205e6edc05cb41e877c5835244ce3bd133fda/gcc%2Fvarray.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/848205e6edc05cb41e877c5835244ce3bd133fda/gcc%2Fvarray.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarray.c?ref=848205e6edc05cb41e877c5835244ce3bd133fda", "patch": "@@ -0,0 +1,70 @@\n+/* Virtual array support.\n+   Copyright (C) 1998 Free Software Foundation, Inc.\n+   Contributed by Cygnus Solutions.\n+\n+   This file is part of GNU CC.\n+\n+   GNU CC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 2, or (at your option)\n+   any later version.\n+\n+   GNU CC is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GNU CC; see the file COPYING.  If not, write to the Free\n+   the Free Software Foundation, 59 Temple Place - Suite 330,\n+   Boston, MA 02111-1307, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"rtl.h\"\n+#include \"tree.h\"\n+#include \"bitmap.h\"\n+#include \"varray.h\"\n+\n+#define VARRAY_HDR_SIZE (sizeof (struct varray_head_tag) - sizeof (varray_data))\n+\n+/* Allocate a virtual array with NUM_ELEMENT elements, each of which is\n+   ELEMENT_SIZE bytes long, named NAME.  Array elements are zeroed.  */\n+varray_type\n+varray_init (num_elements, element_size, name)\n+     size_t num_elements;\n+     size_t element_size;\n+     const char *name;\n+{\n+  size_t data_size = num_elements * element_size;\n+  varray_type ptr = (varray_type) xcalloc (VARRAY_HDR_SIZE + data_size, 1);\n+\n+  ptr->num_elements = num_elements;\n+  ptr->element_size = element_size;\n+  ptr->name\t    = name;\n+  return ptr;\n+}\n+\n+/* Grow/shrink the virtual array VA to N elements.  Zero any new elements\n+   allocated.  */\n+varray_type\n+varray_grow (va, n)\n+     varray_type va;\n+     size_t n;\n+{\n+  size_t old_elements = va->num_elements;\n+\n+  if (n != old_elements)\n+    {\n+      size_t element_size = va->element_size;\n+      size_t old_data_size = old_elements * element_size;\n+      size_t data_size = n * element_size;\n+\n+      va = (varray_type) xrealloc ((char *)va, VARRAY_HDR_SIZE + data_size);\n+      va->num_elements = n;\n+      if (n > old_elements)\n+\tbzero (&va->data.c[old_data_size], data_size - old_data_size);\n+    }\n+\n+  return va;\n+}"}, {"sha": "373bb5c4f17897223f94292bbb2101754ad2dbae", "filename": "gcc/varray.h", "status": "added", "additions": 162, "deletions": 0, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/848205e6edc05cb41e877c5835244ce3bd133fda/gcc%2Fvarray.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/848205e6edc05cb41e877c5835244ce3bd133fda/gcc%2Fvarray.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarray.h?ref=848205e6edc05cb41e877c5835244ce3bd133fda", "patch": "@@ -0,0 +1,162 @@\n+/* Virtual array support.\n+   Copyright (C) 1998 Free Software Foundation, Inc.\n+   Contributed by Cygnus Solutions.\n+\n+   This file is part of GNU CC.\n+\n+   GNU CC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 2, or (at your option)\n+   any later version.\n+\n+   GNU CC is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GNU CC; see the file COPYING.  If not, write to the Free\n+   the Free Software Foundation, 59 Temple Place - Suite 330,\n+   Boston, MA 02111-1307, USA.  */\n+\n+#ifndef _VARRAY_H_\n+#define _VARRAY_H_\n+\n+#ifndef PROTO\n+#include \"gansidecl.h\"\n+#endif\n+\n+#ifndef HOST_WIDE_INT\n+#include \"machmode.h\"\n+#endif\n+\n+/* Union of various array types that are used.  */\n+typedef union varray_data_tag {\n+  char\t\t\t c[1];\n+  unsigned char\t\t uc[1];\n+  short\t\t\t s[1];\n+  unsigned short\t us[1];\n+  int\t\t\t i[1];\n+  unsigned int\t\t u[1];\n+  long\t\t\t l[1];\n+  unsigned long\t\t ul[1];\n+  HOST_WIDE_INT\t\t hint[1];\n+  unsigned HOST_WIDE_INT uhint[1];\n+  GENERIC_PTR\t\t generic[1];\n+  char\t\t\t *cptr[1];\n+  struct rtx_def\t *rtx[1];\n+  struct rtvec_def\t *rtvec[1];\n+  union tree_node\t *tree[1];\n+  struct bitmap_head_def *bitmap[1];\n+  struct sched_info_tag\t *sched[1];\n+  struct reg_info_def\t *reg[1];\n+} varray_data;\n+\n+/* Virtual array of pointers header.  */\n+typedef struct varray_head_tag {\n+  size_t\tnum_elements;\t/* maximum element number allocated */\n+  size_t\telement_size;\t/* size of each data element */\n+  const char   *name;\t\t/* name of the varray for reporting errors */\n+  varray_data\tdata;\t\t/* data elements follow, must be last */\n+} *varray_type;\n+\n+/* Allocate a virtual array with NUM elements, each of which is SIZE bytes\n+   long, named NAME.  Array elements are zeroed.  */\n+extern varray_type varray_init\tPROTO ((size_t, size_t, const char *));\n+\n+#define VARRAY_CHAR_INIT(va, num, name) \\\n+  va = varray_init (num, sizeof (char), name)\n+\n+#define VARRAY_UCHAR_INIT(va, num, name) \\\n+  va = varray_init (num, sizeof (unsigned char), name)\n+\n+#define VARRAY_SHORT_INIT(va, num, name) \\\n+  va = varray_init (num, sizeof (short), name)\n+\n+#define VARRAY_USHORT_INIT(va, num, name) \\\n+  va = varray_init (num, sizeof (unsigned short), name)\n+\n+#define VARRAY_INT_INIT(va, num, name) \\\n+  va = varray_init (num, sizeof (int), name)\n+\n+#define VARRAY_UINT_INIT(va, num, name) \\\n+  va = varray_init (num, sizeof (unsigned int), name)\n+\n+#define VARRAY_LONG_INIT(va, num, name) \\\n+  va = varray_init (num, sizeof (long), name)\n+\n+#define VARRAY_ULONG_INIT(va, num, name) \\\n+  va = varray_init (num, sizeof (unsigned long), name)\n+\n+#define VARRAY_WIDE_INT_INIT(va, num, name) \\\n+  va = varray_init (num, sizeof (HOST_WIDE_INT), name)\n+\n+#define VARRAY_UWIDE_INT_INIT(va, num, name) \\\n+  va = varray_init (num, sizeof (unsigned HOST_WIDE_INT), name)\n+\n+#define VARRAY_GENERIC_PTR_INIT(va, num, name) \\\n+  va = varray_init (num, sizeof (GENERIC_PTR), name)\n+\n+#define VARRAY_CHAR_PTR_INIT(va, num, name) \\\n+  va = varray_init (num, sizeof (char *), name)\n+\n+#define VARRAY_RTX_INIT(va, num, name) \\\n+  va = varray_init (num, sizeof (struct rtx_def *), name)\n+\n+#define VARRAY_RTVEC_INIT(va, num, name) \\\n+  va = varray_init (num, sizeof (struct rtvec_def), name)\n+\n+#define VARRAY_TREE_INIT(va, num, name) \\\n+  va = varray_init (num, sizeof (union tree_node *), name)\n+\n+#define VARRAY_BITMAP_INIT(va, num, name) \\\n+  va = varray_init (num, sizeof (struct bitmap_head_def *), name)\n+\n+#define VARRAY_SCHED_INIT(va, num, name) \\\n+  va = varray_init (num, sizeof (struct sched_info_tag *), name)\n+\n+#define VARRAY_REG_INIT(va, num, name) \\\n+  va = varray_init (num, sizeof (struct reg_info_def *), name)\n+\n+/* Free up memory allocated by the virtual array, but do not free any of the\n+   elements involved.  */\n+#define VARRAY_FREE(vp) ((vp) && (free (vp), (vp = (varray_type)0)))\n+\n+/* Grow/shrink the virtual array VA to N elements.  */\n+extern varray_type varray_grow\tPROTO((varray_type, size_t));\n+\n+#define VARRAY_GROW(VA, N) ((VA) = varray_grow (VA, N))\n+\n+/* Check for VARRAY_xxx macros being in bound, return N for use as an\n+   index.  */\n+#ifdef ENABLE_CHECKING\n+#define VARRAY_CHECK(VA, N)\t\t\t\t\t\t\\\n+((((size_t)(N) < (VA)->num_elements)\t\t\t\t\t\\\n+  ? 0\t\t\t\t\t\t\t\t\t\\\n+  : (fatal (\"Virtual array %s element %ld out of bounds, at %s:%d\",\t\\\n+\t    (VA)->name, (long)(N), __FILE__, __LINE__), 0)),\t\t\\\n+ (N))\n+#else\n+#define VARRAY_CHECK(VA, N) (N)\n+#endif\n+\n+#define VARRAY_CHAR(VA, N)\t((VA)->data.c[ VARRAY_CHECK (VA, N) ])\n+#define VARRAY_UCHAR(VA, N)\t((VA)->data.uc[ VARRAY_CHECK (VA, N) ])\n+#define VARRAY_SHORT(VA, N)\t((VA)->data.s[ VARRAY_CHECK (VA, N) ])\n+#define VARRAY_USHORT(VA, N)\t((VA)->data.us[ VARRAY_CHECK (VA, N) ])\n+#define VARRAY_INT(VA, N)\t((VA)->data.i[ VARRAY_CHECK (VA, N) ])\n+#define VARRAY_UINT(VA, N)\t((VA)->data.u[ VARRAY_CHECK (VA, N) ])\n+#define VARRAY_LONG(VA, N)\t((VA)->data.l[ VARRAY_CHECK (VA, N) ])\n+#define VARRAY_ULONG(VA, N)\t((VA)->data.ul[ VARRAY_CHECK (VA, N) ])\n+#define VARRAY_WIDE_INT(VA, N)\t((VA)->data.hint[ VARRAY_CHECK (VA, N) ])\n+#define VARRAY_UWIDE_INT(VA, N)\t((VA)->data.uhint[ VARRAY_CHECK (VA, N) ])\n+#define VARRAY_GENERIC_PTR(VA,N) ((VA)->data.generic[ VARRAY_CHECK (VA, N) ])\n+#define VARRAY_CHAR_PTR(VA,N)\t((VA)->data.cptr[ VARRAY_CHECK (VA, N) ])\n+#define VARRAY_RTX(VA, N)\t((VA)->data.rtx[ VARRAY_CHECK (VA, N) ])\n+#define VARRAY_RTVEC(VA, N)\t((VA)->data.rtvec[ VARRAY_CHECK (VA, N) ])\n+#define VARRAY_TREE(VA, N)\t((VA)->data.tree[ VARRAY_CHECK (VA, N) ])\n+#define VARRAY_BITMAP(VA, N)\t((VA)->data.bitmap[ VARRAY_CHECK (VA, N) ])\n+#define VARRAY_SCHED(VA, N)\t((VA)->data.sched[ VARRAY_CHECK (VA, N) ])\n+#define VARRAY_REG(VA, N)\t((VA)->data.reg[ VARRAY_CHECK (VA, N) ])\n+\n+#endif /* _VARRAY_H_ */"}]}