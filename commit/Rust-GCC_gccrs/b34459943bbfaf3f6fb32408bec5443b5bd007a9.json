{"sha": "b34459943bbfaf3f6fb32408bec5443b5bd007a9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjM0NDU5OTQzYmJmYWYzZjZmYjMyNDA4YmVjNTQ0M2I1YmQwMDdhOQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2003-07-14T03:04:29Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2003-07-14T03:04:29Z"}, "message": "re PR c++/11493 (tree check ICE in error.c)\n\n\t* cp-tree.h (cp_id_kind): New type.\n\t(unqualified_name_lookup_error): Change prototype.\n\t(unqualified_fn_lookup_error): New function.\n\t(do_identifier): Remove.\n\t(do_scoped_id): Likewise.\n\t(tsubst_copy_and_build): Change prototype.\n\t(reregister_specialization): New function.\n\t(perform_koenig_lookup): Likewise.\n\t(finish_id_expression): Likewise.\n\t* call.c (build_method_call): Adjust call to\n\tunqualified_name_lookup_error.\n\t* decl.c (duplicate_decls): Use reregister_specialization.\n\t* lex.c (is_global): Remove.\n\t(unqualified_name_lookup_error): Return a value.\n\t(do_identifier): Remove.\n\t(do_scoped_id): Likewise.\n\t(identifier_typedecl_value): Remove.\n\t(unqualified_fn_lookup_error): New function.\n\t* parser.c (cp_parser_id_kind): Remove.\n\t(cp_parser_non_constant_id_expression): Remove.\n\t(cp_parser_primary_expression): Use finish_id_expression.\n\t(cp_parser_class_or_namespace_name): Use cp_id_kind, not\n\tcp_parser_id_kind.\n\t(cp_parser_postfix_expression): Use perform_koenig_lookup.\n\t(cp_parser_template_argument): Use cp_id_kind.\n\t(cp_parser_fold_non_dependent_expr): Adjust call to\n\ttsubst_copy_and_build.\n\t* pt.c (unregister_specialization): Rename to ...\n\t(reregister_specialization): This.\n\t(tsubst_friend_function): Use it.\n\t(maybe_fold_nontype_arg): Adjust call to tsubst_copy_and_build.\n\t(tsubst_qualified_id): Likewise.\n\t(tsubst_expr): Likewise.\n\t(tsubst_copy_and_build): Add function_p parameter.  Use\n\tfinish_id_expression.  Introduce RECUR macro.\n\t(tsubst_non_call_postfix_expression): New function.\n\t(regenerate_decl_from_template): Use reregister_specialization.\n\t* semantics.c (perform_koenig_lookup): New function.\n\t(finish_id_expression): Likewise.\n\n\tPR c++/11493\n\tPR c++/11495\n\t* g++.dg/parse/template9.C: Likewise.\n\t* g++.dg/template/crash4.C: New test.\n\t* g++.dg/template/koenig1.C: Likewise.\n\t* g++.old-deja/g++.benjamin/tem03.C: Adjust error markers.\n\t* g++.old-deja/g++.benjamin/tem06.C: Declare \"x\".\n\t* g++.old-deja/g++.jason/overload33.C: Use this-> when calling\n\tfunctions.\n\t* g++.old-deja/g++.jason/template36.C: Likewise.\n\t* g++.old-deja/g++.mike/p1989.C: Likewise.\n\t* g++.old-deja/g++.pt/lookup2.C: Use -fpermissive when compiling.\n\t* g++.old-deja/g++.pt/ttp20.C: Use this->.\n\t* g++.old-deja/g++.pt/ttp21.C: Use this->.\n\t* g++.old-deja/g++.pt/typename13.C: Use -fpermissive when\n\tcompiling.\n\t* g++.old-deja/g++.pt/union2.C: Use this->.\n\nFrom-SVN: r69316", "tree": {"sha": "3ddf8b782e57d44ab82415af48c1283130465744", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3ddf8b782e57d44ab82415af48c1283130465744"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b34459943bbfaf3f6fb32408bec5443b5bd007a9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b34459943bbfaf3f6fb32408bec5443b5bd007a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b34459943bbfaf3f6fb32408bec5443b5bd007a9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b34459943bbfaf3f6fb32408bec5443b5bd007a9/comments", "author": null, "committer": null, "parents": [{"sha": "f2ffecb11286fbe36b305bff8e8374214f6f9463", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2ffecb11286fbe36b305bff8e8374214f6f9463", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f2ffecb11286fbe36b305bff8e8374214f6f9463"}], "stats": {"total": 1470, "additions": 726, "deletions": 744}, "files": [{"sha": "c096405890f22135da27cf4a8dc16ba8273db9a9", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b34459943bbfaf3f6fb32408bec5443b5bd007a9/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b34459943bbfaf3f6fb32408bec5443b5bd007a9/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=b34459943bbfaf3f6fb32408bec5443b5bd007a9", "patch": "@@ -1,3 +1,45 @@\n+2003-07-13  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* cp-tree.h (cp_id_kind): New type.\n+\t(unqualified_name_lookup_error): Change prototype.\n+\t(unqualified_fn_lookup_error): New function.\n+\t(do_identifier): Remove.\n+\t(do_scoped_id): Likewise.\n+\t(tsubst_copy_and_build): Change prototype.\n+\t(reregister_specialization): New function.\n+\t(perform_koenig_lookup): Likewise.\n+\t(finish_id_expression): Likewise.\n+\t* call.c (build_method_call): Adjust call to\n+\tunqualified_name_lookup_error.\n+\t* decl.c (duplicate_decls): Use reregister_specialization.\n+\t* lex.c (is_global): Remove.\n+\t(unqualified_name_lookup_error): Return a value.\n+\t(do_identifier): Remove.\n+\t(do_scoped_id): Likewise.\n+\t(identifier_typedecl_value): Remove.\n+\t(unqualified_fn_lookup_error): New function.\n+\t* parser.c (cp_parser_id_kind): Remove.\n+\t(cp_parser_non_constant_id_expression): Remove.\n+\t(cp_parser_primary_expression): Use finish_id_expression.\n+\t(cp_parser_class_or_namespace_name): Use cp_id_kind, not\n+\tcp_parser_id_kind.\n+\t(cp_parser_postfix_expression): Use perform_koenig_lookup.\n+\t(cp_parser_template_argument): Use cp_id_kind.\n+\t(cp_parser_fold_non_dependent_expr): Adjust call to\n+\ttsubst_copy_and_build.\n+\t* pt.c (unregister_specialization): Rename to ...\n+\t(reregister_specialization): This.\n+\t(tsubst_friend_function): Use it.\n+\t(maybe_fold_nontype_arg): Adjust call to tsubst_copy_and_build.\n+\t(tsubst_qualified_id): Likewise.\n+\t(tsubst_expr): Likewise.\n+\t(tsubst_copy_and_build): Add function_p parameter.  Use\n+\tfinish_id_expression.  Introduce RECUR macro.\n+\t(tsubst_non_call_postfix_expression): New function.\n+\t(regenerate_decl_from_template): Use reregister_specialization.\n+\t* semantics.c (perform_koenig_lookup): New function.\n+\t(finish_id_expression): Likewise.\n+\t\n 2003-07-13  Kriang Lerdsuwanakij  <lerdsuwa@users.sourceforge.net>\n \n \t* pt.c (push_access_scope_real): Remove."}, {"sha": "39f82211b759ff0221ff1a9d7464bb1bb4837f2c", "filename": "gcc/cp/call.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b34459943bbfaf3f6fb32408bec5443b5bd007a9/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b34459943bbfaf3f6fb32408bec5443b5bd007a9/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=b34459943bbfaf3f6fb32408bec5443b5bd007a9", "patch": "@@ -423,10 +423,7 @@ build_method_call (tree instance, tree name, tree parms,\n \n   /* If the name could not be found, issue an error.  */\n   if (!fn)\n-    {\n-      unqualified_name_lookup_error (name);\n-      return error_mark_node;\n-    }\n+    return unqualified_name_lookup_error (name);\n \n   if (BASELINK_P (fn) && has_template_args)\n     BASELINK_FUNCTIONS (fn)"}, {"sha": "24fd278c5371507568e2b15d0c0021557f270e97", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 23, "deletions": 5, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b34459943bbfaf3f6fb32408bec5443b5bd007a9/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b34459943bbfaf3f6fb32408bec5443b5bd007a9/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=b34459943bbfaf3f6fb32408bec5443b5bd007a9", "patch": "@@ -350,6 +350,20 @@ struct tree_wrapper GTY(())\n   struct z_candidate *z_c;\n };\n \n+/* The different kinds of ids that we ecounter.  */\n+\n+typedef enum cp_id_kind\n+{\n+  /* Not an id at all.  */\n+  CP_ID_KIND_NONE,\n+  /* An unqualified-id that is not a template-id.  */\n+  CP_ID_KIND_UNQUALIFIED,\n+  /* An unqualified template-id.  */\n+  CP_ID_KIND_TEMPLATE_ID,\n+  /* A qualified-id.  */\n+  CP_ID_KIND_QUALIFIED\n+} cp_id_kind;\n+\n /* Macros for access to language-specific slots in an identifier.  */\n \n #define IDENTIFIER_NAMESPACE_BINDINGS(NODE)\t\\\n@@ -3883,10 +3897,8 @@ extern void snarf_method\t\t\t(tree);\n extern void note_got_semicolon\t\t\t(tree);\n extern void note_list_got_semicolon\t\t(tree);\n extern void see_typename\t\t\t(void);\n-extern void unqualified_name_lookup_error       (tree);\n-extern tree do_identifier\t\t\t(tree, tree);\n-extern tree do_scoped_id\t\t\t(tree, tree);\n-extern tree identifier_typedecl_value\t\t(tree);\n+extern tree unqualified_name_lookup_error       (tree);\n+extern tree unqualified_fn_lookup_error         (tree);\n extern tree build_lang_decl\t\t\t(enum tree_code, tree, tree);\n extern void retrofit_lang_decl\t\t\t(tree);\n extern tree copy_decl                           (tree);\n@@ -3963,7 +3975,7 @@ extern tree most_specialized_instantiation      (tree);\n extern void print_candidates                    (tree);\n extern int instantiate_pending_templates        (void);\n extern tree tsubst_default_argument             (tree, tree, tree);\n-extern tree tsubst_copy_and_build               (tree, tree, tsubst_flags_t, tree);\n+extern tree tsubst_copy_and_build               (tree, tree, tsubst_flags_t, tree, bool);\n extern tree most_general_template\t\t(tree);\n extern tree get_mostly_instantiated_function_type (tree);\n extern int problematic_instantiation_changed    (void);\n@@ -3982,6 +3994,7 @@ extern tree resolve_typename_type               (tree, bool);\n extern tree template_for_substitution           (tree);\n extern tree build_non_dependent_expr            (tree);\n extern tree build_non_dependent_args            (tree);\n+extern bool reregister_specialization           (tree, tree, tree);\n \n /* in repo.c */\n extern void repo_template_used (tree);\n@@ -4111,6 +4124,7 @@ extern tree finish_parenthesized_expr           (tree);\n extern tree finish_non_static_data_member       (tree, tree);\n extern tree begin_stmt_expr                     (void);\n extern tree finish_stmt_expr                    (tree);\n+extern tree perform_koenig_lookup               (tree, tree);\n extern tree finish_call_expr                    (tree, tree, bool);\n extern tree finish_increment_expr               (tree, enum tree_code);\n extern tree finish_this_expr                    (void);\n@@ -4133,6 +4147,10 @@ extern tree finish_template_type                (tree, tree, int);\n extern tree finish_base_specifier               (tree, tree, bool);\n extern void finish_member_declaration           (tree);\n extern void check_multiple_declarators          (void);\n+extern tree finish_id_expression                (tree, tree, tree,\n+\t\t\t\t\t\t cp_id_kind *, tree *,\n+\t\t\t\t\t\t bool, bool, bool *, \n+\t\t\t\t\t\t const char **);\n extern tree finish_typeof\t\t\t(tree);\n extern tree finish_sizeof\t\t\t(tree);\n extern tree finish_alignof\t\t\t(tree);"}, {"sha": "d4c212f3e7665c2e71dcf693b7bba035ea119ca7", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 24, "deletions": 30, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b34459943bbfaf3f6fb32408bec5443b5bd007a9/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b34459943bbfaf3f6fb32408bec5443b5bd007a9/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=b34459943bbfaf3f6fb32408bec5443b5bd007a9", "patch": "@@ -3558,36 +3558,30 @@ duplicate_decls (tree newdecl, tree olddecl)\n \t      function_size - sizeof (struct tree_common));\n \n       if (DECL_TEMPLATE_INSTANTIATION (newdecl))\n-\t{\n-\t  /* If newdecl is a template instantiation, it is possible that\n-\t     the following sequence of events has occurred:\n-\n-\t     o A friend function was declared in a class template.  The\n-\t     class template was instantiated.\n-\n-\t     o The instantiation of the friend declaration was\n-\t     recorded on the instantiation list, and is newdecl.\n-\n-\t     o Later, however, instantiate_class_template called pushdecl\n-\t     on the newdecl to perform name injection.  But, pushdecl in\n-\t     turn called duplicate_decls when it discovered that another\n-\t     declaration of a global function with the same name already\n-\t     existed.\n-\n-\t     o Here, in duplicate_decls, we decided to clobber newdecl.\n-\n-\t     If we're going to do that, we'd better make sure that\n-\t     olddecl, and not newdecl, is on the list of\n-\t     instantiations so that if we try to do the instantiation\n-\t     again we won't get the clobbered declaration.  */\n-\n-\t  tree tmpl = DECL_TI_TEMPLATE (newdecl);\n-\t  tree decls = DECL_TEMPLATE_SPECIALIZATIONS (tmpl);\n-\n-\t  for (; decls; decls = TREE_CHAIN (decls))\n-\t    if (TREE_VALUE (decls) == newdecl)\n-\t      TREE_VALUE (decls) = olddecl;\n-\t}\n+\t/* If newdecl is a template instantiation, it is possible that\n+\t   the following sequence of events has occurred:\n+\n+\t   o A friend function was declared in a class template.  The\n+\t   class template was instantiated.\n+\n+\t   o The instantiation of the friend declaration was\n+\t   recorded on the instantiation list, and is newdecl.\n+\n+\t   o Later, however, instantiate_class_template called pushdecl\n+\t   on the newdecl to perform name injection.  But, pushdecl in\n+\t   turn called duplicate_decls when it discovered that another\n+\t   declaration of a global function with the same name already\n+\t   existed.\n+\n+\t   o Here, in duplicate_decls, we decided to clobber newdecl.\n+\n+\t   If we're going to do that, we'd better make sure that\n+\t   olddecl, and not newdecl, is on the list of\n+\t   instantiations so that if we try to do the instantiation\n+\t   again we won't get the clobbered declaration.  */\n+\treregister_specialization (newdecl, \n+\t\t\t\t   DECL_TI_TEMPLATE (newdecl), \n+\t\t\t\t   olddecl);\n     }\n   else\n     {"}, {"sha": "eb0287c9d34d4a815b710c1e9b3de327e3a8ada4", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 28, "deletions": 170, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b34459943bbfaf3f6fb32408bec5443b5bd007a9/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b34459943bbfaf3f6fb32408bec5443b5bd007a9/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=b34459943bbfaf3f6fb32408bec5443b5bd007a9", "patch": "@@ -49,7 +49,6 @@ static void handle_pragma_interface (cpp_reader *);\n static void handle_pragma_implementation (cpp_reader *);\n static void handle_pragma_java_exceptions (cpp_reader *);\n \n-static int is_global (tree);\n static void init_operators (void);\n static void copy_lang_type (tree);\n \n@@ -662,30 +661,10 @@ handle_pragma_java_exceptions (cpp_reader* dfile ATTRIBUTE_UNUSED )\n   choose_personality_routine (lang_java);\n }\n \n-/* Return true if d is in a global scope.  */\n-\n-static int\n-is_global (tree d)\n-{\n-  while (1)\n-    switch (TREE_CODE (d))\n-      {\n-      case ERROR_MARK:\n-\treturn 1;\n-\n-      case OVERLOAD: d = OVL_FUNCTION (d); continue;\n-      case TREE_LIST: d = TREE_VALUE (d); continue;\n-      default:\n-        my_friendly_assert (DECL_P (d), 980629);\n-\n-\treturn DECL_NAMESPACE_SCOPE_P (d);\n-      }\n-}\n-\n /* Issue an error message indicating that the lookup of NAME (an\n-   IDENTIFIER_NODE) failed.  */\n+   IDENTIFIER_NODE) failed.  Returns the ERROR_MARK_NODE.  */\n \n-void\n+tree\n unqualified_name_lookup_error (tree name)\n {\n   if (IDENTIFIER_OPNAME_P (name))\n@@ -714,164 +693,43 @@ unqualified_name_lookup_error (tree name)\n       SET_IDENTIFIER_NAMESPACE_VALUE (name, error_mark_node);\n       SET_IDENTIFIER_ERROR_LOCUS (name, current_function_decl);\n     }\n-}\n-\n-tree\n-do_identifier (register tree token, tree args)\n-{\n-  register tree id;\n-\n-  timevar_push (TV_NAME_LOOKUP);\n-  id = lookup_name (token, 0);\n-\n-  /* Do Koenig lookup if appropriate (inside templates we build lookup\n-     expressions instead).\n-\n-     [basic.lookup.koenig]: If the ordinary unqualified lookup of the name\n-     finds the declaration of a class member function, the associated\n-     namespaces and classes are not considered.  */\n-\n-  if (args && !current_template_parms && (!id || is_global (id)))\n-    id = lookup_arg_dependent (token, id, args);\n-\n-  if (id == error_mark_node)\n-    {\n-      /* lookup_name quietly returns error_mark_node if we're parsing,\n-\t as we don't want to complain about an identifier that ends up\n-\t being used as a declarator.  So we call it again to get the error\n-\t message.  */\n-      id = lookup_name (token, 0);\n-      POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, error_mark_node);\n-    }\n \n-  if (!id || (TREE_CODE (id) == FUNCTION_DECL\n-\t      && DECL_ANTICIPATED (id)))\n-    {\n-      if (current_template_parms)\n-        POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP,\n-                                build_min_nt (LOOKUP_EXPR, token));\n-      else if (IDENTIFIER_TYPENAME_P (token))\n-\t/* A templated conversion operator might exist.  */\n-\tPOP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, token);\n-      else\n-\t{\n-\t  unqualified_name_lookup_error (token);\n-\t  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, error_mark_node);\n-\t}\n-    }\n-\n-  id = check_for_out_of_scope_variable (id);\n-\n-  /* TREE_USED is set in `hack_identifier'.  */\n-  if (TREE_CODE (id) == CONST_DECL)\n-    {\n-      /* Check access.  */\n-      if (IDENTIFIER_CLASS_VALUE (token) == id)\n-\tperform_or_defer_access_check (TYPE_BINFO (DECL_CONTEXT (id)), id);\n-      if (!processing_template_decl || DECL_TEMPLATE_PARM_P (id))\n-\tid = DECL_INITIAL (id);\n-    }\n-  else\n-    id = hack_identifier (id, token);\n-\n-  /* We must look up dependent names when the template is\n-     instantiated, not while parsing it.  For now, we don't\n-     distinguish between dependent and independent names.  So, for\n-     example, we look up all overloaded functions at\n-     instantiation-time, even though in some cases we should just use\n-     the DECL we have here.  We also use LOOKUP_EXPRs to find things\n-     like local variables, rather than creating TEMPLATE_DECLs for the\n-     local variables and then finding matching instantiations.  */\n-  if (current_template_parms\n-      && (is_overloaded_fn (id)\n-\t  || (TREE_CODE (id) == VAR_DECL\n-\t      && CP_DECL_CONTEXT (id)\n-\t      && TREE_CODE (CP_DECL_CONTEXT (id)) == FUNCTION_DECL)\n-\t  || TREE_CODE (id) == PARM_DECL\n-\t  || TREE_CODE (id) == RESULT_DECL\n-\t  || TREE_CODE (id) == USING_DECL))\n-    id = build_min_nt (LOOKUP_EXPR, token);\n-\n-  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, id);\n+  return error_mark_node;\n }\n \n+/* Like unqualified_name_lookup_error, but NAME is an unqualified-id\n+   used as a function.  Returns an appropriate expression for\n+   NAME.  */\n+\n tree\n-do_scoped_id (tree token, tree id)\n+unqualified_fn_lookup_error (tree name)\n {\n-  timevar_push (TV_NAME_LOOKUP);\n-  if (!id || (TREE_CODE (id) == FUNCTION_DECL\n-\t      && DECL_ANTICIPATED (id)))\n-    {\n-      if (processing_template_decl)\n-\t{\n-\t  id = build_min_nt (LOOKUP_EXPR, token);\n-\t  LOOKUP_EXPR_GLOBAL (id) = 1;\n-\t  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, id);\n-\t}\n-      if (IDENTIFIER_NAMESPACE_VALUE (token) != error_mark_node)\n-        error (\"`::%D' undeclared (first use here)\", token);\n-      id = error_mark_node;\n-      /* Prevent repeated error messages.  */\n-      SET_IDENTIFIER_NAMESPACE_VALUE (token, error_mark_node);\n-    }\n-  else\n-    {\n-      if (TREE_CODE (id) == ADDR_EXPR)\n-\tmark_used (TREE_OPERAND (id, 0));\n-      else if (TREE_CODE (id) != OVERLOAD)\n-\tmark_used (id);\n-    }\n-  if (TREE_CODE (id) == CONST_DECL && ! processing_template_decl)\n-    {\n-      /* XXX CHS - should we set TREE_USED of the constant? */\n-      id = DECL_INITIAL (id);\n-      /* This is to prevent an enum whose value is 0\n-\t from being considered a null pointer constant.  */\n-      id = build1 (NOP_EXPR, TREE_TYPE (id), id);\n-      TREE_CONSTANT (id) = 1;\n-    }\n-\n   if (processing_template_decl)\n     {\n-      if (is_overloaded_fn (id))\n+      /* In a template, it is invalid to write \"f()\" or \"f(3)\" if no\n+\t declaration of \"f\" is available.  Historically, G++ and most\n+\t other compilers accepted that usage; explain to the user what\n+\t is going wrong.  */\n+      (flag_permissive ? warning : error)\n+\t(\"there are no arguments to `%D' that depend on a template \"\n+\t \"parameter, so a declaration of `%D' must be available\", name,\n+\t name);\n+      \n+      if (!flag_permissive)\n \t{\n-\t  id = build_min_nt (LOOKUP_EXPR, token);\n-\t  LOOKUP_EXPR_GLOBAL (id) = 1;\n-\t  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, id);\n+\t  static bool hint;\n+\t  if (!hint)\n+\t    {\n+\t      error (\"(if you use `-fpermissive', G++ will accept your code, \"\n+\t\t     \"but allowing the use of an undeclared name is \"\n+\t\t     \"deprecated)\");\n+\t      hint = true;\n+\t    }\n \t}\n-      /* else just use the decl */\n+      return build_min_nt (LOOKUP_EXPR, name);\n     }\n-  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, convert_from_reference (id));\n-}\n-\n-tree\n-identifier_typedecl_value (tree node)\n-{\n-  tree t, type;\n-  type = IDENTIFIER_TYPE_VALUE (node);\n-  if (type == NULL_TREE)\n-    return NULL_TREE;\n-\n-  if (IDENTIFIER_BINDING (node))\n-    {\n-      t = IDENTIFIER_VALUE (node);\n-      if (t && TREE_CODE (t) == TYPE_DECL && TREE_TYPE (t) == type)\n-\treturn t;\n-    }\n-  if (IDENTIFIER_NAMESPACE_VALUE (node))\n-    {\n-      t = IDENTIFIER_NAMESPACE_VALUE (node);\n-      if (t && TREE_CODE (t) == TYPE_DECL && TREE_TYPE (t) == type)\n-\treturn t;\n-    }\n-\n-  /* Will this one ever happen?  */\n-  if (TYPE_MAIN_DECL (type))\n-    return TYPE_MAIN_DECL (type);\n \n-  /* We used to do an internal error of 62 here, but instead we will\n-     handle the return of a null appropriately in the callers.  */\n-  return NULL_TREE;\n+  return unqualified_name_lookup_error (name);\n }\n \n #ifdef GATHER_STATISTICS"}, {"sha": "98411a6abdbb745855cfe3512388ac18432784cd", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 34, "deletions": 366, "changes": 400, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b34459943bbfaf3f6fb32408bec5443b5bd007a9/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b34459943bbfaf3f6fb32408bec5443b5bd007a9/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=b34459943bbfaf3f6fb32408bec5443b5bd007a9", "patch": "@@ -1047,20 +1047,6 @@ typedef enum cp_parser_flags\n   CP_PARSER_FLAGS_NO_USER_DEFINED_TYPES = 0x2\n } cp_parser_flags;\n \n-/* The different kinds of ids that we ecounter.  */\n-\n-typedef enum cp_parser_id_kind\n-{\n-  /* Not an id at all.  */\n-  CP_PARSER_ID_KIND_NONE,\n-  /* An unqualified-id that is not a template-id.  */\n-  CP_PARSER_ID_KIND_UNQUALIFIED,\n-  /* An unqualified template-id.  */\n-  CP_PARSER_ID_KIND_TEMPLATE_ID,\n-  /* A qualified-id.  */\n-  CP_PARSER_ID_KIND_QUALIFIED\n-} cp_parser_id_kind;\n-\n /* The different kinds of declarators we want to parse.  */\n \n typedef enum cp_parser_declarator_kind\n@@ -1311,7 +1297,7 @@ static bool cp_parser_translation_unit\n /* Expressions [gram.expr]  */\n \n static tree cp_parser_primary_expression\n-  (cp_parser *, cp_parser_id_kind *, tree *);\n+  (cp_parser *, cp_id_kind *, tree *);\n static tree cp_parser_id_expression\n   (cp_parser *, bool, bool, bool *);\n static tree cp_parser_unqualified_id\n@@ -1695,8 +1681,6 @@ static void cp_parser_check_type_definition\n   (cp_parser *);\n static tree cp_parser_non_constant_expression\n   (const char *);\n-static tree cp_parser_non_constant_id_expression\n-  (tree);\n static bool cp_parser_diagnose_invalid_type_name\n   (cp_parser *);\n static int cp_parser_skip_to_closing_parenthesis\n@@ -1794,16 +1778,6 @@ cp_parser_non_constant_expression (const char *thing)\n   return error_mark_node;\n }\n \n-/* Issue an eror message about the fact that DECL appeared in a\n-   constant-expression.  Returns ERROR_MARK_NODE.  */\n-\n-static tree\n-cp_parser_non_constant_id_expression (tree decl)\n-{\n-  error (\"`%D' cannot appear in a constant-expression\", decl);\n-  return error_mark_node;\n-}\n-\n /* Check for a common situation where a type-name should be present,\n    but is not, and issue a sensible error message.  Returns true if an\n    invalid type-name was detected.  */\n@@ -2215,13 +2189,13 @@ cp_parser_translation_unit (cp_parser* parser)\n \n static tree\n cp_parser_primary_expression (cp_parser *parser, \n-\t\t\t      cp_parser_id_kind *idk,\n+\t\t\t      cp_id_kind *idk,\n \t\t\t      tree *qualifying_class)\n {\n   cp_token *token;\n \n   /* Assume the primary expression is not an id-expression.  */\n-  *idk = CP_PARSER_ID_KIND_NONE;\n+  *idk = CP_ID_KIND_NONE;\n   /* And that it cannot be used as pointer-to-member.  */\n   *qualifying_class = NULL_TREE;\n \n@@ -2397,6 +2371,7 @@ cp_parser_primary_expression (cp_parser *parser,\n       {\n \ttree id_expression;\n \ttree decl;\n+\tconst char *error_msg;\n \n       id_expression:\n \t/* Parse the id-expression.  */\n@@ -2457,281 +2432,16 @@ cp_parser_primary_expression (cp_parser *parser,\n \t\t    return error_mark_node;\n \t\t  }\n \t      }\n-\n-\t    if (decl == error_mark_node)\n-\t      {\n-\t\t/* Name lookup failed.  */\n-\t\tif (!parser->scope \n-\t\t    && processing_template_decl)\n-\t\t  {\n-\t\t    /* Unqualified name lookup failed while processing a\n-\t\t       template.  */\n-\t\t    *idk = CP_PARSER_ID_KIND_UNQUALIFIED;\n-\t\t    /* If the next token is a parenthesis, assume that\n-\t\t       Koenig lookup will succeed when instantiating the\n-\t\t       template.  */\n-\t\t    if (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_PAREN))\n-\t\t      return build_min_nt (LOOKUP_EXPR, id_expression);\n-\t\t    /* If we're not doing Koenig lookup, issue an error.  */\n-\t\t    error (\"`%D' has not been declared\", id_expression);\n-\t\t    return error_mark_node;\n-\t\t  }\n-\t\telse if (parser->scope\n-\t\t\t && (!TYPE_P (parser->scope)\n-\t\t\t     || !dependent_type_p (parser->scope)))\n-\t\t  {\n-\t\t    /* Qualified name lookup failed, and the\n-\t\t       qualifying name was not a dependent type.  That\n-\t\t       is always an error.  */\n-\t\t    if (TYPE_P (parser->scope)\n-\t\t\t&& !COMPLETE_TYPE_P (parser->scope))\n-\t\t      error (\"incomplete type `%T' used in nested name \"\n-\t\t\t     \"specifier\",\n-\t\t\t     parser->scope);\n-\t\t    else if (parser->scope != global_namespace)\n-\t\t      error (\"`%D' is not a member of `%D'\",\n-\t\t\t     id_expression, parser->scope);\n-\t\t    else\n-\t\t      error (\"`::%D' has not been declared\", id_expression);\n-\t\t    return error_mark_node;\n-\t\t  }\n-\t\telse if (!parser->scope && !processing_template_decl)\n-\t\t  {\n-\t\t    /* It may be resolvable as a koenig lookup function\n-\t\t       call.  */\n-\t\t    *idk = CP_PARSER_ID_KIND_UNQUALIFIED;\n-\t\t    return id_expression;\n-\t\t  }\n-\t      }\n-\t    /* If DECL is a variable that would be out of scope under\n-\t       ANSI/ISO rules, but in scope in the ARM, name lookup\n-\t       will succeed.  Issue a diagnostic here.  */\n-\t    else\n-\t      decl = check_for_out_of_scope_variable (decl);\n-\n-\t    /* Remember that the name was used in the definition of\n-\t       the current class so that we can check later to see if\n-\t       the meaning would have been different after the class\n-\t       was entirely defined.  */\n-\t    if (!parser->scope && decl != error_mark_node)\n-\t      maybe_note_name_used_in_class (id_expression, decl);\n-\t  }\n-\n-\t/* If we didn't find anything, or what we found was a type,\n-\t   then this wasn't really an id-expression.  */\n-\tif (TREE_CODE (decl) == TEMPLATE_DECL\n-\t    && !DECL_FUNCTION_TEMPLATE_P (decl))\n-\t  {\n-\t    cp_parser_error (parser, \"missing template arguments\");\n-\t    return error_mark_node;\n \t  }\n-\telse if (TREE_CODE (decl) == TYPE_DECL\n-\t\t || TREE_CODE (decl) == NAMESPACE_DECL)\n-\t  {\n-\t    cp_parser_error (parser, \n-\t\t\t     \"expected primary-expression\");\n-\t    return error_mark_node;\n-\t  }\n-\n-\t/* If the name resolved to a template parameter, there is no\n-\t   need to look it up again later.  Similarly, we resolve\n-\t   enumeration constants to their underlying values.  */\n-\tif (TREE_CODE (decl) == CONST_DECL)\n-\t  {\n-\t    *idk = CP_PARSER_ID_KIND_NONE;\n-\t    if (DECL_TEMPLATE_PARM_P (decl) || !processing_template_decl)\n-\t      return DECL_INITIAL (decl);\n-\t    return decl;\n-\t  }\n-\telse\n-\t  {\n-\t    bool dependent_p;\n-\n-\t    /* If the declaration was explicitly qualified indicate\n-\t       that.  The semantics of `A::f(3)' are different than\n-\t       `f(3)' if `f' is virtual.  */\n-\t    *idk = (parser->scope \n-\t\t    ? CP_PARSER_ID_KIND_QUALIFIED\n-\t\t    : (TREE_CODE (decl) == TEMPLATE_ID_EXPR\n-\t\t       ? CP_PARSER_ID_KIND_TEMPLATE_ID\n-\t\t       : CP_PARSER_ID_KIND_UNQUALIFIED));\n-\n-\n-\t    /* [temp.dep.expr]\n-\t       \n-\t       An id-expression is type-dependent if it contains an\n-\t       identifier that was declared with a dependent type.\n-\t       \n-\t       As an optimization, we could choose not to create a\n-\t       LOOKUP_EXPR for a name that resolved to a local\n-\t       variable in the template function that we are currently\n-\t       declaring; such a name cannot ever resolve to anything\n-\t       else.  If we did that we would not have to look up\n-\t       these names at instantiation time.\n-\t       \n-\t       The standard is not very specific about an\n-\t       id-expression that names a set of overloaded functions.\n-\t       What if some of them have dependent types and some of\n-\t       them do not?  Presumably, such a name should be treated\n-\t       as a dependent name.  */\n-\t    /* Assume the name is not dependent.  */\n-\t    dependent_p = false;\n-\t    if (!processing_template_decl)\n-\t      /* No names are dependent outside a template.  */\n-\t      ;\n-\t    /* A template-id where the name of the template was not\n-\t       resolved is definitely dependent.  */\n-\t    else if (TREE_CODE (decl) == TEMPLATE_ID_EXPR\n-\t\t     && (TREE_CODE (TREE_OPERAND (decl, 0)) \n-\t\t\t == IDENTIFIER_NODE))\n-\t      dependent_p = true;\n-\t    /* For anything except an overloaded function, just check\n-\t       its type.  */\n-\t    else if (!is_overloaded_fn (decl))\n-\t      dependent_p \n-\t\t= dependent_type_p (TREE_TYPE (decl));\n-\t    /* For a set of overloaded functions, check each of the\n-\t       functions.  */\n-\t    else\n-\t      {\n-\t\ttree fns = decl;\n-\n-\t\tif (BASELINK_P (fns))\n-\t\t  fns = BASELINK_FUNCTIONS (fns);\n-\t\t  \n-\t\t/* For a template-id, check to see if the template\n-\t\t   arguments are dependent.  */\n-\t\tif (TREE_CODE (fns) == TEMPLATE_ID_EXPR)\n-\t\t  {\n-\t\t    tree args = TREE_OPERAND (fns, 1);\n-\t\t    dependent_p = any_dependent_template_arguments_p (args);\n-\t\t    /* The functions are those referred to by the\n-\t\t       template-id.  */\n-\t\t    fns = TREE_OPERAND (fns, 0);\n-\t\t  }\n-\n-\t\t/* If there are no dependent template arguments, go\n-\t\t   through the overlaoded functions.  */\n-\t\twhile (fns && !dependent_p)\n-\t\t  {\n-\t\t    tree fn = OVL_CURRENT (fns);\n-\t\t    \n-\t\t    /* Member functions of dependent classes are\n-\t\t       dependent.  */\n-\t\t    if (TREE_CODE (fn) == FUNCTION_DECL\n-\t\t\t&& type_dependent_expression_p (fn))\n-\t\t      dependent_p = true;\n-\t\t    else if (TREE_CODE (fn) == TEMPLATE_DECL\n-\t\t\t     && dependent_template_p (fn))\n-\t\t      dependent_p = true;\n-\t\t    \n-\t\t    fns = OVL_NEXT (fns);\n-\t\t  }\n-\t      }\n-\n-\t    /* If the name was dependent on a template parameter,\n-\t       we will resolve the name at instantiation time.  */\n-\t    if (dependent_p)\n-\t      {\n-\t\t/* Create a SCOPE_REF for qualified names, if the\n-\t\t   scope is dependent.  */\n-\t\tif (parser->scope)\n-\t\t  {\n-\t\t    if (TYPE_P (parser->scope))\n-\t\t      *qualifying_class = parser->scope;\n-\t\t    /* Since this name was dependent, the expression isn't\n-\t\t       constant -- yet.  No error is issued because it\n-\t\t       might be constant when things are instantiated.  */\n-\t\t    if (parser->constant_expression_p)\n-\t\t      parser->non_constant_expression_p = true;\n-\t\t    if (TYPE_P (parser->scope)\n-\t\t\t&& dependent_type_p (parser->scope))\n-\t\t      return build_nt (SCOPE_REF, \n-\t\t\t\t       parser->scope, \n-\t\t\t\t       id_expression);\n-\t\t    else if (TYPE_P (parser->scope)\n-\t\t\t     && DECL_P (decl))\n-\t\t      return build (SCOPE_REF,\n-\t\t\t\t    TREE_TYPE (decl),\n-\t\t\t\t    parser->scope,\n-\t\t\t\t    id_expression);\n-\t\t    else\n-\t\t      return decl;\n-\t\t  }\n-\t\t/* A TEMPLATE_ID already contains all the information\n-\t\t   we need.  */\n-\t\tif (TREE_CODE (id_expression) == TEMPLATE_ID_EXPR)\n-\t\t  return id_expression;\n-\t\t/* Since this name was dependent, the expression isn't\n-\t\t   constant -- yet.  No error is issued because it\n-\t\t   might be constant when things are instantiated.  */\n-\t\tif (parser->constant_expression_p)\n-\t\t  parser->non_constant_expression_p = true;\n-\t\t/* Create a LOOKUP_EXPR for other unqualified names.  */\n-\t\treturn build_min_nt (LOOKUP_EXPR, id_expression);\n-\t      }\n-\n-\t    /* Only certain kinds of names are allowed in constant\n-\t       expression.  Enumerators have already been handled\n-\t       above.  */\n-\t    if (parser->constant_expression_p)\n-\t      {\n-\t\t/* Non-type template parameters of integral or\n-\t\t   enumeration type are OK.  */\n-\t\tif (TREE_CODE (decl) == TEMPLATE_PARM_INDEX\n-\t\t    && INTEGRAL_OR_ENUMERATION_TYPE_P (TREE_TYPE (decl)))\n-\t\t  ;\n-\t\t/* Const variables or static data members of integral\n-\t\t   or enumeration types initialized with constant\n-                   expressions are OK.  We also accept dependent\n-\t\t   initializers; they may turn out to be constant at\n-\t\t   instantiation-time.  */\n-\t\telse if (TREE_CODE (decl) == VAR_DECL\n-\t\t\t && CP_TYPE_CONST_P (TREE_TYPE (decl))\n-\t\t\t && INTEGRAL_OR_ENUMERATION_TYPE_P (TREE_TYPE (decl))\n-\t\t\t && DECL_INITIAL (decl)\n-\t\t\t && (TREE_CONSTANT (DECL_INITIAL (decl))\n-\t\t\t     || type_dependent_expression_p (DECL_INITIAL \n-\t\t\t\t\t\t\t     (decl))\n-\t\t\t     || value_dependent_expression_p (DECL_INITIAL \n-\t\t\t\t\t\t\t      (decl))))\n-\t\t  ;\n-\t\telse\n-\t\t  {\n-\t\t    if (!parser->allow_non_constant_expression_p)\n-\t\t      return cp_parser_non_constant_id_expression (decl);\n-\t\t    parser->non_constant_expression_p = true;\n-\t\t  }\n-\t      }\n-\n-\t    if (parser->scope)\n-\t      {\n-\t\tdecl = (adjust_result_of_qualified_name_lookup \n-\t\t\t(decl, parser->scope, current_class_type));\n-\t\tif (TREE_CODE (decl) == FIELD_DECL || BASELINK_P (decl))\n-\t\t  *qualifying_class = parser->scope;\n-\t\telse if (!processing_template_decl)\n-\t\t  decl = convert_from_reference (decl);\n-\t\telse if (TYPE_P (parser->scope))\n-\t\t  decl = build (SCOPE_REF,\n-\t\t\t\tTREE_TYPE (decl),\n-\t\t\t\tparser->scope,\n-\t\t\t\tdecl);\n-\t      }\n-\t    else\n-\t      /* Transform references to non-static data members into\n-\t\t COMPONENT_REFs.  */\n-\t      decl = hack_identifier (decl, id_expression);\n-\n-\t    /* Resolve references to variables of anonymous unions\n-\t       into COMPONENT_REFs.  */\n-\t    if (TREE_CODE (decl) == ALIAS_DECL)\n-\t      decl = DECL_INITIAL (decl);\n-\t  }\n-\n-\tif (TREE_DEPRECATED (decl))\n-\t  warn_deprecated_use (decl);\n-\n+\t\n+\tdecl = finish_id_expression (id_expression, decl, parser->scope, \n+\t\t\t\t     idk, qualifying_class,\n+\t\t\t\t     parser->constant_expression_p,\n+\t\t\t\t     parser->allow_non_constant_expression_p,\n+\t\t\t\t     &parser->non_constant_expression_p,\n+\t\t\t\t     &error_msg);\n+\tif (error_msg)\n+\t  cp_parser_error (parser, error_msg);\n \treturn decl;\n       }\n \n@@ -3463,7 +3173,7 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p)\n {\n   cp_token *token;\n   enum rid keyword;\n-  cp_parser_id_kind idk = CP_PARSER_ID_KIND_NONE;\n+  cp_id_kind idk = CP_ID_KIND_NONE;\n   tree postfix_expression = NULL_TREE;\n   /* Non-NULL only if the current postfix-expression can be used to\n      form a pointer-to-member.  In that case, QUALIFYING_CLASS is the\n@@ -3730,11 +3440,9 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p)\n     {\n       if (TREE_CODE (postfix_expression) == IDENTIFIER_NODE\n \t  && cp_lexer_next_token_is_not (parser->lexer, CPP_OPEN_PAREN))\n-\t{\n-\t  /* It is not a Koenig lookup function call.  */\n-\t  unqualified_name_lookup_error (postfix_expression);\n-\t  postfix_expression = error_mark_node;\n-\t}\n+\t/* It is not a Koenig lookup function call.  */\n+\tpostfix_expression \n+\t  = unqualified_name_lookup_error (postfix_expression);\n       \n       /* Peek at the next token.  */\n       token = cp_lexer_peek_token (parser->lexer);\n@@ -3756,7 +3464,7 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p)\n \t    /* Build the ARRAY_REF.  */\n \t    postfix_expression \n \t      = grok_array_decl (postfix_expression, index);\n-\t    idk = CP_PARSER_ID_KIND_NONE;\n+\t    idk = CP_ID_KIND_NONE;\n \t  }\n \t  break;\n \n@@ -3780,58 +3488,17 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p)\n \t\tparser->non_constant_expression_p = true;\n \t      }\n \n-\t    if (idk == CP_PARSER_ID_KIND_UNQUALIFIED\n+\t    if (idk == CP_ID_KIND_UNQUALIFIED\n \t\t&& (is_overloaded_fn (postfix_expression)\n \t\t    || DECL_P (postfix_expression)\n \t\t    || TREE_CODE (postfix_expression) == IDENTIFIER_NODE)\n \t\t&& args)\n-\t      {\n-\t\ttree identifier = NULL_TREE;\n-\t\ttree functions = NULL_TREE;\n-\n-\t\t/* Find the name of the overloaded function.  */\n-\t\tif (TREE_CODE (postfix_expression) == IDENTIFIER_NODE)\n-\t\t  identifier = postfix_expression;\n-\t\telse if (is_overloaded_fn (postfix_expression))\n-\t\t  {\n-\t\t    functions = postfix_expression;\n-\t\t    identifier = DECL_NAME (get_first_fn (functions));\n-\t\t  }\n-\t\telse if (DECL_P (postfix_expression))\n-\t\t  {\n-\t\t    functions = postfix_expression;\n-\t\t    identifier = DECL_NAME (postfix_expression);\n-\t\t  }\n-\n-\t\t/* A call to a namespace-scope function using an\n-\t\t   unqualified name.\n-\n-\t\t   Do Koenig lookup -- unless any of the arguments are\n-\t\t   type-dependent.  */\n-\t\tif (!any_type_dependent_arguments_p (args))\n-\t\t  {\n-\t\t    postfix_expression \n-\t\t      = lookup_arg_dependent (identifier, functions, args);\n-\t\t    if (!postfix_expression)\n-\t\t      {\n-\t\t\t/* The unqualified name could not be resolved.  */\n-\t\t\tunqualified_name_lookup_error (identifier);\n-\t\t\tpostfix_expression = error_mark_node;\n-\t\t\tbreak;\n-\t\t      }\n-\t\t  }\n-\t\telse\n-\t\t  postfix_expression = build_min_nt (LOOKUP_EXPR,\n-\t\t\t\t\t\t     identifier);\n-\t      }\n-\t    else if (idk == CP_PARSER_ID_KIND_UNQUALIFIED \n+\t      postfix_expression \n+\t\t= perform_koenig_lookup (postfix_expression, args);\n+\t    else if (idk == CP_ID_KIND_UNQUALIFIED \n \t\t     && TREE_CODE (postfix_expression) == IDENTIFIER_NODE)\n-\t      {\n-\t\t/* The unqualified name could not be resolved.  */\n-\t\tunqualified_name_lookup_error (postfix_expression);\n-\t\tpostfix_expression = error_mark_node;\n-\t\tbreak;\n-\t      }\n+\t      postfix_expression\n+\t\t= unqualified_fn_lookup_error (postfix_expression);\n \n \t    if (TREE_CODE (postfix_expression) == COMPONENT_REF)\n \t      {\n@@ -3853,15 +3520,15 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p)\n \t\tpostfix_expression\n \t\t  = (build_new_method_call \n \t\t     (instance, fn, args, NULL_TREE, \n-\t\t      (idk == CP_PARSER_ID_KIND_QUALIFIED \n+\t\t      (idk == CP_ID_KIND_QUALIFIED \n \t\t       ? LOOKUP_NONVIRTUAL : LOOKUP_NORMAL)));\n \t      }\n \t    else if (TREE_CODE (postfix_expression) == OFFSET_REF\n \t\t     || TREE_CODE (postfix_expression) == MEMBER_REF\n \t\t     || TREE_CODE (postfix_expression) == DOTSTAR_EXPR)\n \t      postfix_expression = (build_offset_ref_call_from_tree\n \t\t\t\t    (postfix_expression, args));\n-\t    else if (idk == CP_PARSER_ID_KIND_QUALIFIED)\n+\t    else if (idk == CP_ID_KIND_QUALIFIED)\n \t      /* A call to a static class member, or a namespace-scope\n \t\t function.  */\n \t      postfix_expression\n@@ -3874,7 +3541,7 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p)\n \t\t\t\t    /*disallow_virtual=*/false);\n \n \t    /* The POSTFIX_EXPRESSION is certainly no longer an id.  */\n-\t    idk = CP_PARSER_ID_KIND_NONE;\n+\t    idk = CP_ID_KIND_NONE;\n \t  }\n \t  break;\n \t  \n@@ -3901,7 +3568,7 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p)\n \t    parser->scope = NULL_TREE;\n \t    parser->qualifying_scope = NULL_TREE;\n \t    parser->object_scope = NULL_TREE;\n-\t    idk = CP_PARSER_ID_KIND_NONE;\n+\t    idk = CP_ID_KIND_NONE;\n \t    /* Enter the scope corresponding to the type of the object\n \t       given by the POSTFIX_EXPRESSION.  */\n \t    if (!dependent_p \n@@ -3969,7 +3636,7 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p)\n \t\t/* But we do need to remember that there was an explicit\n \t\t   scope for virtual function calls.  */\n \t\tif (parser->scope)\n-\t\t  idk = CP_PARSER_ID_KIND_QUALIFIED;\n+\t\t  idk = CP_ID_KIND_QUALIFIED;\n \n \t\tif (name != error_mark_node \n \t\t    && !BASELINK_P (name)\n@@ -4019,7 +3686,7 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p)\n \t  postfix_expression \n \t    = finish_increment_expr (postfix_expression, \n \t\t\t\t     POSTINCREMENT_EXPR);\n-\t  idk = CP_PARSER_ID_KIND_NONE;\n+\t  idk = CP_ID_KIND_NONE;\n \t  break;\n \n \tcase CPP_MINUS_MINUS:\n@@ -4037,7 +3704,7 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p)\n \t  postfix_expression \n \t    = finish_increment_expr (postfix_expression, \n \t\t\t\t     POSTDECREMENT_EXPR);\n-\t  idk = CP_PARSER_ID_KIND_NONE;\n+\t  idk = CP_ID_KIND_NONE;\n \t  break;\n \n \tdefault:\n@@ -8065,7 +7732,7 @@ cp_parser_template_argument (cp_parser* parser)\n   bool template_p;\n   bool address_p;\n   cp_token *token;\n-  cp_parser_id_kind idk;\n+  cp_id_kind idk;\n   tree qualifying_class;\n \n   /* There's really no way to know what we're looking at, so we just\n@@ -14184,7 +13851,8 @@ cp_parser_fold_non_dependent_expr (tree expr)\n       expr = tsubst_copy_and_build (expr,\n \t\t\t\t    /*args=*/NULL_TREE,\n \t\t\t\t    tf_error,\n-\t\t\t\t    /*in_decl=*/NULL_TREE);\n+\t\t\t\t    /*in_decl=*/NULL_TREE,\n+\t\t\t\t    /*function_p=*/false);\n       processing_template_decl = saved_processing_template_decl;\n     }\n   return expr;"}, {"sha": "37ec8688637aad6bcffcdb0298d4357fe6bc7789", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 170, "deletions": 153, "changes": 323, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b34459943bbfaf3f6fb32408bec5443b5bd007a9/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b34459943bbfaf3f6fb32408bec5443b5bd007a9/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=b34459943bbfaf3f6fb32408bec5443b5bd007a9", "patch": "@@ -125,7 +125,6 @@ static tree retrieve_specialization (tree, tree);\n static tree retrieve_local_specialization (tree);\n static tree register_specialization (tree, tree, tree);\n static void register_local_specialization (tree, tree);\n-static int unregister_specialization (tree, tree);\n static tree reduce_template_parm_level (tree, tree, int);\n static tree build_template_decl (tree, tree);\n static int mark_template_parm (tree, void *);\n@@ -987,11 +986,11 @@ register_specialization (tree spec, tree tmpl, tree args)\n }\n \n /* Unregister the specialization SPEC as a specialization of TMPL.\n-   Returns nonzero if the SPEC was listed as a specialization of\n-   TMPL.  */\n+   Replace it with NEW_SPEC, if NEW_SPEC is non-NULL.  Returns true\n+   if the SPEC was listed as a specialization of TMPL.  */\n \n-static int\n-unregister_specialization (tree spec, tree tmpl)\n+bool\n+reregister_specialization (tree spec, tree tmpl, tree new_spec)\n {\n   tree* s;\n \n@@ -1000,7 +999,10 @@ unregister_specialization (tree spec, tree tmpl)\n        s = &TREE_CHAIN (*s))\n     if (TREE_VALUE (*s) == spec)\n       {\n-\t*s = TREE_CHAIN (*s);\n+\tif (!new_spec)\n+\t  *s = TREE_CHAIN (*s);\n+\telse\n+\t  TREE_VALUE (*s) == new_spec;\n \treturn 1;\n       }\n \n@@ -4910,8 +4912,17 @@ tsubst_friend_function (tree decl, tree args)\n \t      DECL_TEMPLATE_INFO (old_decl) = new_friend_template_info;\n \n \t      if (TREE_CODE (old_decl) != TEMPLATE_DECL)\n-\t\t/* duplicate_decls will take care of this case.  */\n-\t\t;\n+\t\t{\n+\t\t  tree t;\n+\t\t  tree spec;\n+\n+\t\t  t = most_general_template (old_decl);\n+\t\t  for (spec = DECL_TEMPLATE_SPECIALIZATIONS (t);\n+\t\t       spec;\n+\t\t       spec = TREE_CHAIN (spec))\n+\t\t    if (TREE_VALUE (spec) == new_friend)\n+\t\t      TREE_VALUE (spec) = old_decl;\n+\t\t}\n \t      else \n \t\t{\n \t\t  tree t;\n@@ -5503,7 +5514,8 @@ maybe_fold_nontype_arg (tree arg)\n \t  arg = tsubst_copy_and_build (arg,\n \t\t\t\t       /*args=*/NULL_TREE,\n \t\t\t\t       tf_error,\n-\t\t\t\t       /*in_decl=*/NULL_TREE);\n+\t\t\t\t       /*in_decl=*/NULL_TREE,\n+\t\t\t\t       /*function_p=*/false);\n \t  processing_template_decl = saved_processing_template_decl; \n \t}\n \n@@ -7071,7 +7083,8 @@ tsubst_baselink (tree baselink, tree object_type,\n \ttemplate_args = TREE_OPERAND (fns, 1);\n \tfns = TREE_OPERAND (fns, 0);\n \ttemplate_args = tsubst_copy_and_build (template_args, args,\n-\t\t\t\t\t       complain, in_decl);\n+\t\t\t\t\t       complain, in_decl,\n+\t\t\t\t\t       /*function_p=*/false);\n       }\n     name = DECL_NAME (get_first_fn (fns));\n     baselink = lookup_fnfields (qualifying_scope, name, /*protect=*/1);\n@@ -7112,7 +7125,8 @@ tsubst_qualified_id (tree qualified_id, tree args,\n     {\n       is_template = true;\n       template_args = tsubst_copy_and_build (TREE_OPERAND (name, 1), \n-\t\t\t\t\t     args, complain, in_decl);\n+\t\t\t\t\t     args, complain, in_decl,\n+\t\t\t\t\t     /*function_p=*/false);\n       name = TREE_OPERAND (name, 0);\n     }\n   else\n@@ -7549,7 +7563,8 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n     return tsubst_copy (t, args, complain, in_decl);\n \n   if (!STATEMENT_CODE_P (TREE_CODE (t)))\n-    return tsubst_copy_and_build (t, args, complain, in_decl);\n+    return tsubst_copy_and_build (t, args, complain, in_decl,\n+\t\t\t\t  /*function_p=*/false);\n     \n   switch (TREE_CODE (t))\n     {\n@@ -7857,61 +7872,100 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n   return tsubst_expr (TREE_CHAIN (t), args, complain, in_decl);\n }\n \n+/* T is a postfix-expression that is not being used in a function\n+   call.  Return the substituted version of T.  */\n+\n+static tree\n+tsubst_non_call_postfix_expression (tree t, tree args, \n+\t\t\t\t    tsubst_flags_t complain,\n+\t\t\t\t    tree in_decl)\n+{\n+  if (TREE_CODE (t) == SCOPE_REF)\n+    t = tsubst_qualified_id (t, args, complain, in_decl,\n+\t\t\t     /*done=*/false, /*address_p=*/false);\n+  else\n+    t = tsubst_copy_and_build (t, args, complain, in_decl,\n+\t\t\t       /*function_p=*/false);\n+\n+  return t;\n+}\n+\n /* Like tsubst but deals with expressions and performs semantic\n-   analysis.  */\n+   analysis.  FUNCTION_P is true if T is the \"F\" in \"F (ARGS)\".  */\n \n tree\n tsubst_copy_and_build (tree t, \n                        tree args, \n                        tsubst_flags_t complain, \n-                       tree in_decl)\n+                       tree in_decl,\n+\t\t       bool function_p)\n {\n+#define RECUR(NODE) \\\n+  tsubst_copy_and_build (NODE, args, complain, in_decl, /*function_p=*/false)\n+\n   tree op1;\n \n   if (t == NULL_TREE || t == error_mark_node)\n     return t;\n \n   switch (TREE_CODE (t))\n     {\n-    case IDENTIFIER_NODE:\n-      if (IDENTIFIER_TYPENAME_P (t))\n-\t{\n-\t  tree new_type = tsubst (TREE_TYPE (t), args, complain, in_decl);\n-\t  return do_identifier (mangle_conv_op_name_for_type (new_type),\n-\t\t\t\tNULL_TREE);\n-\t}\n-      else\n-\treturn do_identifier (t, NULL_TREE);\n-\n     case LOOKUP_EXPR:\n+    case IDENTIFIER_NODE:\n       {\n-\tif (LOOKUP_EXPR_GLOBAL (t))\n-\t  {\n-\t    tree token\n-\t      = tsubst_copy (TREE_OPERAND (t, 0), args, complain, in_decl);\n-\t    return do_scoped_id (token, IDENTIFIER_GLOBAL_VALUE (token));\n-\t  }\n+\ttree decl;\n+\ttree scope;\n+\tcp_id_kind idk;\n+\ttree qualifying_class;\n+\tbool non_constant_expression_p;\n+\tconst char *error_msg;\n+\n+\t/* Remember whether this identifier was explicitly qualified\n+\t   with \"::\".  */\n+\tif (TREE_CODE (t) == LOOKUP_EXPR && LOOKUP_EXPR_GLOBAL (t))\n+\t  scope = global_namespace;\n \telse\n+\t  scope = NULL_TREE;\n+\t/* Get at the underlying identifier.  */\n+\tif (TREE_CODE (t) == LOOKUP_EXPR)\n+\t  t = TREE_OPERAND (t, 0);\n+\n+\tif (IDENTIFIER_TYPENAME_P (t))\n \t  {\n-\t    t = do_identifier\n-\t      (tsubst_copy\n-\t       (TREE_OPERAND (t, 0), args, complain, in_decl),\n-\t       NULL_TREE);\n-\t    if (TREE_CODE (t) == ALIAS_DECL)\n-\t      t = DECL_INITIAL (t);\n-\t    return t;\n+\t    tree new_type = tsubst (TREE_TYPE (t), args, complain, in_decl);\n+\t    t = mangle_conv_op_name_for_type (new_type);\n \t  }\n+\n+\t/* Look up the name.  */\n+\tif (scope == global_namespace)\n+\t  decl = IDENTIFIER_GLOBAL_VALUE (t);\n+\telse\n+\t  decl = lookup_name (t, 0);\n+\n+\t/* By convention, expressions use ERROR_MARK_NODE to indicate\n+\t   failure, not NULL_TREE.  */\n+\tif (decl == NULL_TREE)\n+\t  decl = error_mark_node;\n+\n+\tdecl = finish_id_expression (t, decl, scope,\n+\t\t\t\t     &idk,\n+\t\t\t\t     &qualifying_class,\n+\t\t\t\t     /*constant_expression_p=*/false,\n+\t\t\t\t     /*allow_non_constant_expression_p=*/false,\n+\t\t\t\t     &non_constant_expression_p,\n+\t\t\t\t     &error_msg);\n+\tif (error_msg)\n+\t  error (error_msg);\n+\tif (!function_p && TREE_CODE (decl) == IDENTIFIER_NODE)\n+\t  decl = unqualified_name_lookup_error (decl);\n+\treturn decl;\n       }\n \n     case TEMPLATE_ID_EXPR:\n       {\n \ttree object;\n-\ttree template\n-\t  = tsubst_copy_and_build (TREE_OPERAND (t, 0), args, complain, \n-\t\t\t\t   in_decl);\n-\ttree targs\n-\t  = tsubst_copy_and_build (TREE_OPERAND (t, 1), args, complain, \n-\t\t\t\t   in_decl);\n+\ttree template = RECUR (TREE_OPERAND (t, 0));\n+\ttree targs = RECUR (TREE_OPERAND (t, 1));\n \t\n \tif (TREE_CODE (template) == COMPONENT_REF)\n \t  {\n@@ -7930,46 +7984,37 @@ tsubst_copy_and_build (tree t,\n       }\n \n     case INDIRECT_REF:\n-      return build_x_indirect_ref\n-\t(tsubst_copy_and_build (TREE_OPERAND (t, 0), args, complain, in_decl),\n-\t \"unary *\");\n+      return build_x_indirect_ref (RECUR (TREE_OPERAND (t, 0)), \"unary *\");\n \n     case CAST_EXPR:\n       return build_functional_cast\n \t(tsubst (TREE_TYPE (t), args, complain, in_decl),\n-\t tsubst_copy_and_build (TREE_OPERAND (t, 0), args, complain, in_decl));\n+\t RECUR (TREE_OPERAND (t, 0)));\n \n     case REINTERPRET_CAST_EXPR:\n       return build_reinterpret_cast\n \t(tsubst (TREE_TYPE (t), args, complain, in_decl),\n-\t tsubst_copy_and_build (TREE_OPERAND (t, 0), args, complain, in_decl));\n+\t RECUR (TREE_OPERAND (t, 0)));\n \n     case CONST_CAST_EXPR:\n       return build_const_cast\n \t(tsubst (TREE_TYPE (t), args, complain, in_decl),\n-\t tsubst_copy_and_build (TREE_OPERAND (t, 0), args, complain, in_decl));\n+\t RECUR (TREE_OPERAND (t, 0)));\n \n     case DYNAMIC_CAST_EXPR:\n       return build_dynamic_cast\n \t(tsubst (TREE_TYPE (t), args, complain, in_decl),\n-\t tsubst_copy_and_build (TREE_OPERAND (t, 0), args, complain, in_decl));\n+\t RECUR (TREE_OPERAND (t, 0)));\n \n     case STATIC_CAST_EXPR:\n       return build_static_cast\n \t(tsubst (TREE_TYPE (t), args, complain, in_decl),\n-\t tsubst_copy_and_build (TREE_OPERAND (t, 0), args, complain, in_decl));\n+\t RECUR (TREE_OPERAND (t, 0)));\n \n     case POSTDECREMENT_EXPR:\n     case POSTINCREMENT_EXPR:\n-      op1 = TREE_OPERAND (t, 0);\n-      if (TREE_CODE (op1) == SCOPE_REF)\n-\top1 = tsubst_qualified_id (TREE_OPERAND (t, 0),\n-\t\t\t\t   args, complain, \n-\t\t\t\t   in_decl,\n-\t\t\t\t   /*done=*/false,\n-\t\t\t\t   /*address_p=*/false);\n-      else\n-\top1 = tsubst_copy_and_build (op1, args, complain, in_decl);\n+      op1 = tsubst_non_call_postfix_expression (TREE_OPERAND (t, 0),\n+\t\t\t\t\t\targs, complain, in_decl);\n       return build_x_unary_op (TREE_CODE (t), op1);\n \n     case PREDECREMENT_EXPR:\n@@ -7981,18 +8026,16 @@ tsubst_copy_and_build (tree t,\n     case CONVERT_EXPR:  /* Unary + */\n     case REALPART_EXPR:\n     case IMAGPART_EXPR:\n-      return (build_x_unary_op\n-\t      (TREE_CODE (t),\n-\t       tsubst_copy_and_build (TREE_OPERAND (t, 0), args, complain,\n-\t\t\t\t      in_decl)));\n+      return build_x_unary_op (TREE_CODE (t), RECUR (TREE_OPERAND (t, 0)));\n \n     case ADDR_EXPR:\n       op1 = TREE_OPERAND (t, 0);\n       if (TREE_CODE (op1) == SCOPE_REF)\n \top1 = tsubst_qualified_id (op1, args, complain, in_decl, \n \t\t\t\t   /*done=*/true, /*address_p=*/true);\n       else\n-\top1 = tsubst_copy_and_build (op1, args, complain, in_decl);\n+\top1 = tsubst_non_call_postfix_expression (op1, args, complain, \n+\t\t\t\t\t\t  in_decl);\n       return build_x_unary_op (ADDR_EXPR, op1);\n \n     case PLUS_EXPR:\n@@ -8026,15 +8069,11 @@ tsubst_copy_and_build (tree t,\n     case LT_EXPR:\n     case GT_EXPR:\n     case MEMBER_REF:\n+    case DOTSTAR_EXPR:\n       return build_x_binary_op\n \t(TREE_CODE (t), \n-\t tsubst_copy_and_build (TREE_OPERAND (t, 0), args, complain, in_decl),\n-\t tsubst_copy_and_build (TREE_OPERAND (t, 1), args, complain, in_decl));\n-\n-    case DOTSTAR_EXPR:\n-      return build_m_component_ref\n-\t(tsubst_copy_and_build (TREE_OPERAND (t, 0), args, complain, in_decl),\n-\t tsubst_copy_and_build (TREE_OPERAND (t, 1), args, complain, in_decl));\n+\t RECUR (TREE_OPERAND (t, 0)),\n+\t RECUR (TREE_OPERAND (t, 1)));\n \n     case SCOPE_REF:\n       return tsubst_qualified_id (t, args, complain, in_decl, /*done=*/true,\n@@ -8044,24 +8083,14 @@ tsubst_copy_and_build (tree t,\n       if (tsubst_copy (TREE_OPERAND (t, 0), args, complain, in_decl)\n \t  == NULL_TREE)\n \t/* new-type-id */\n-\treturn build_nt\n-\t  (ARRAY_REF, NULL_TREE,\n-\t   tsubst_copy_and_build (TREE_OPERAND (t, 1), args, complain,\n-\t\t\t\t  in_decl));\n+\treturn build_nt (ARRAY_REF, NULL_TREE, RECUR (TREE_OPERAND (t, 1)));\n \n-      op1 = TREE_OPERAND (t, 0);\n-      if (TREE_CODE (op1) == SCOPE_REF)\n-\top1 = tsubst_qualified_id (op1, args, complain, in_decl,\n-\t\t\t\t   /*done=*/false, /*address_p=*/false);\n-      else\n-\top1 = tsubst_copy_and_build (op1, args, complain, in_decl);\n+      op1 = tsubst_non_call_postfix_expression (TREE_OPERAND (t, 0),\n+\t\t\t\t\t\targs, complain, in_decl);\n       /* Remember that there was a reference to this entity.  */\n       if (DECL_P (op1))\n \tmark_used (op1);\n-      return grok_array_decl (op1, \n-\t\t\t      tsubst_copy_and_build (TREE_OPERAND (t, 1), \n-\t\t\t\t\t\t     args, complain,\n-\t\t\t\t\t\t     in_decl));\n+      return grok_array_decl (op1, RECUR (TREE_OPERAND (t, 1)));\n \n     case SIZEOF_EXPR:\n     case ALIGNOF_EXPR:\n@@ -8077,7 +8106,7 @@ tsubst_copy_and_build (tree t,\n       else\n \t{\n \t  ++skip_evaluation;\n-\t  op1 = tsubst_copy_and_build (op1, args, complain, in_decl);\n+\t  op1 = RECUR (op1);\n \t  --skip_evaluation;\n \t}\n       if (TREE_CODE (t) == SIZEOF_EXPR)\n@@ -8087,56 +8116,43 @@ tsubst_copy_and_build (tree t,\n \n     case MODOP_EXPR:\n       return build_x_modify_expr\n-\t(tsubst_copy_and_build (TREE_OPERAND (t, 0), args, complain, in_decl),\n+\t(RECUR (TREE_OPERAND (t, 0)),\n \t TREE_CODE (TREE_OPERAND (t, 1)),\n-\t tsubst_copy_and_build (TREE_OPERAND (t, 2), args, complain, in_decl));\n+\t RECUR (TREE_OPERAND (t, 2)));\n \n     case ARROW_EXPR:\n-      op1 = TREE_OPERAND (t, 0);\n-      if (TREE_CODE (op1) == SCOPE_REF)\n-\top1 = tsubst_qualified_id (op1, args, complain, in_decl,\n-\t\t\t\t   /*done=*/false, /*address_p=*/false);\n-      else\n-\top1 = tsubst_copy_and_build (op1, args, complain, in_decl);\n+      op1 = tsubst_non_call_postfix_expression (TREE_OPERAND (t, 0),\n+\t\t\t\t\t\targs, complain, in_decl);\n       /* Remember that there was a reference to this entity.  */\n       if (DECL_P (op1))\n \tmark_used (op1);\n       return build_x_arrow (op1);\n \n     case NEW_EXPR:\n       return build_new\n-\t(tsubst_copy_and_build (TREE_OPERAND (t, 0), args, complain, in_decl),\n-\t tsubst_copy_and_build (TREE_OPERAND (t, 1), args, complain, in_decl),\n-\t tsubst_copy_and_build (TREE_OPERAND (t, 2), args, complain, in_decl),\n+\t(RECUR (TREE_OPERAND (t, 0)),\n+\t RECUR (TREE_OPERAND (t, 1)),\n+\t RECUR (TREE_OPERAND (t, 2)),\n \t NEW_EXPR_USE_GLOBAL (t));\n \n     case DELETE_EXPR:\n      return delete_sanity\n-       (tsubst_copy_and_build (TREE_OPERAND (t, 0), args, complain, in_decl),\n-\ttsubst_copy_and_build (TREE_OPERAND (t, 1), args, complain, in_decl),\n+       (RECUR (TREE_OPERAND (t, 0)),\n+\tRECUR (TREE_OPERAND (t, 1)),\n \tDELETE_EXPR_USE_VEC (t),\n \tDELETE_EXPR_USE_GLOBAL (t));\n \n     case COMPOUND_EXPR:\n-      return (build_x_compound_expr\n-\t      (tsubst_copy_and_build (TREE_OPERAND (t, 0), args, complain, \n-\t\t\t\t      in_decl),\n-\t       tsubst_copy_and_build (TREE_OPERAND (t, 1), args, complain, \n-\t\t\t\t      in_decl)));\n+      return build_x_compound_expr (RECUR (TREE_OPERAND (t, 0)),\n+\t\t\t\t    RECUR (TREE_OPERAND (t, 1)));\n \n     case CALL_EXPR:\n       {\n \ttree function;\n \ttree call_args;\n-\ttree koenig_name;\n \tbool qualified_p;\n \n \tfunction = TREE_OPERAND (t, 0);\n-\tif (TREE_CODE (function) == LOOKUP_EXPR\n-\t    && !LOOKUP_EXPR_GLOBAL (function))\n-\t  koenig_name = TREE_OPERAND (function, 0);\n-\telse\n-\t  koenig_name = NULL_TREE;\n \tif (TREE_CODE (function) == SCOPE_REF)\n \t  {\n \t    qualified_p = true;\n@@ -8150,24 +8166,32 @@ tsubst_copy_and_build (tree t,\n \t\t\t   && (TREE_CODE (TREE_OPERAND (function, 1))\n \t\t\t       == SCOPE_REF));\n \t    function = tsubst_copy_and_build (function, args, complain, \n-\t\t\t\t\t      in_decl);\n-\t    function = convert_from_reference (function);\n+\t\t\t\t\t      in_decl,\n+\t\t\t\t\t      !qualified_p);\n \t  }\n \n-\t/* Remember that there was a reference to this entity.  */\n-\tif (DECL_P (function))\n-\t  mark_used (function);\n-\n-\tcall_args = tsubst_copy_and_build (TREE_OPERAND (t, 1), args,\n-\t\t\t\t\t   complain, in_decl);\n+\tcall_args = RECUR (TREE_OPERAND (t, 1));\n \t  \n \tif (BASELINK_P (function))\n \t  qualified_p = 1;\n \n-\tif (call_args != NULL_TREE && koenig_name)\n-\t  function = lookup_arg_dependent (koenig_name,\n-\t\t\t\t\t   function, \n-\t\t\t\t\t   call_args);\n+\tif (!qualified_p\n+\t    && TREE_CODE (function) != TEMPLATE_ID_EXPR\n+\t    && (is_overloaded_fn (function)\n+\t\t|| DECL_P (function)\n+\t\t|| TREE_CODE (function) == IDENTIFIER_NODE))\n+\t  {\n+\t    if (call_args)\n+\t      function = perform_koenig_lookup (function, call_args);\n+\t    else if (TREE_CODE (function) == IDENTIFIER_NODE)\n+\t      function = unqualified_name_lookup_error (function);\n+\t  }\n+\n+\t/* Remember that there was a reference to this entity.  */\n+\tif (DECL_P (function))\n+\t  mark_used (function);\n+\n+\tfunction = convert_from_reference (function);\n \n \tif (TREE_CODE (function) == OFFSET_REF)\n \t  return build_offset_ref_call_from_tree (function, call_args);\n@@ -8183,15 +8207,15 @@ tsubst_copy_and_build (tree t,\n \n     case COND_EXPR:\n       return build_x_conditional_expr\n-\t(tsubst_copy_and_build (TREE_OPERAND (t, 0), args, complain, in_decl),\n-\t tsubst_copy_and_build (TREE_OPERAND (t, 1), args, complain, in_decl),\n-\t tsubst_copy_and_build (TREE_OPERAND (t, 2), args, complain, in_decl));\n+\t(RECUR (TREE_OPERAND (t, 0)),\n+\t RECUR (TREE_OPERAND (t, 1)),\n+\t RECUR (TREE_OPERAND (t, 2)));\n \n     case PSEUDO_DTOR_EXPR:\n       return finish_pseudo_destructor_expr \n-\t(tsubst_copy_and_build (TREE_OPERAND (t, 0), args, complain, in_decl),\n-\t tsubst_copy_and_build (TREE_OPERAND (t, 1), args, complain, in_decl),\n-\t tsubst_copy_and_build (TREE_OPERAND (t, 2), args, complain, in_decl));\n+\t(RECUR (TREE_OPERAND (t, 0)),\n+\t RECUR (TREE_OPERAND (t, 1)),\n+\t RECUR (TREE_OPERAND (t, 2)));\n \n     case TREE_LIST:\n       {\n@@ -8202,13 +8226,13 @@ tsubst_copy_and_build (tree t,\n \n \tpurpose = TREE_PURPOSE (t);\n \tif (purpose)\n-\t  purpose = tsubst_copy_and_build (purpose, args, complain, in_decl);\n+\t  purpose = RECUR (purpose);\n \tvalue = TREE_VALUE (t);\n \tif (value)\n-\t  value = tsubst_copy_and_build (value, args, complain, in_decl);\n+\t  value = RECUR (value);\n \tchain = TREE_CHAIN (t);\n \tif (chain && chain != void_type_node)\n-\t  chain = tsubst_copy_and_build (chain, args, complain, in_decl);\n+\t  chain = RECUR (chain);\n \tif (purpose == TREE_PURPOSE (t)\n \t    && value == TREE_VALUE (t)\n \t    && chain == TREE_CHAIN (t))\n@@ -8221,13 +8245,8 @@ tsubst_copy_and_build (tree t,\n \ttree object;\n \ttree member;\n \n-\tobject = TREE_OPERAND (t, 0);\n-\tif (TREE_CODE (object) == SCOPE_REF)\n-\t  object = tsubst_qualified_id (object, args, complain, in_decl,\n-\t\t\t\t\t/*done=*/false, /*address_p=*/false);\n-\telse\n-\t  object = tsubst_copy_and_build (object, args, complain, in_decl);\n-\n+\tobject = tsubst_non_call_postfix_expression (TREE_OPERAND (t, 0),\n+\t\t\t\t\t\t     args, complain, in_decl);\n \t/* Remember that there was a reference to this entity.  */\n \tif (DECL_P (object))\n \t  mark_used (object);\n@@ -8282,7 +8301,7 @@ tsubst_copy_and_build (tree t,\n \n     case THROW_EXPR:\n       return build_throw\n-\t(tsubst_copy_and_build (TREE_OPERAND (t, 0), args, complain, in_decl));\n+\t(RECUR (TREE_OPERAND (t, 0)));\n \n     case CONSTRUCTOR:\n       {\n@@ -8308,9 +8327,8 @@ tsubst_copy_and_build (tree t,\n \t    tree value = TREE_VALUE (elts);\n \t    \n \t    if (purpose && purpose_p)\n-\t      purpose\n-\t\t= tsubst_copy_and_build (purpose, args, complain, in_decl);\n-\t    value = tsubst_copy_and_build (value, args, complain, in_decl);\n+\t      purpose = RECUR (purpose);\n+\t    value = RECUR (value);\n \t    r = tree_cons (purpose, value, r);\n \t  }\n \t\n@@ -8324,10 +8342,7 @@ tsubst_copy_and_build (tree t,\n \n     case TYPEID_EXPR:\n       {\n-\ttree operand_0\n-\t  = tsubst_copy_and_build (TREE_OPERAND (t, 0), args, complain,\n-\t\t\t\t   in_decl);\n-\t\n+\ttree operand_0 = RECUR (TREE_OPERAND (t, 0));\n \tif (TYPE_P (operand_0))\n \t  return get_typeid (operand_0);\n \treturn build_typeid (operand_0);\n@@ -8347,14 +8362,15 @@ tsubst_copy_and_build (tree t,\n       return convert_from_reference (t);\n \n     case VA_ARG_EXPR:\n-\treturn build_x_va_arg\n-\t  (tsubst_copy_and_build\n-\t   (TREE_OPERAND (t, 0), args, complain, in_decl),\n-\t   tsubst_copy (TREE_TYPE (t), args, complain, in_decl));\n+      return build_x_va_arg (RECUR (TREE_OPERAND (t, 0)),\n+\t\t\t     tsubst_copy (TREE_TYPE (t), args, complain, \n+\t\t\t\t\t  in_decl));\n \n     default:\n       return tsubst_copy (t, args, complain, in_decl);\n     }\n+\n+#undef RECUR\n }\n \n /* Verify that the instantiated ARGS are valid. For type arguments,\n@@ -10576,7 +10592,7 @@ regenerate_decl_from_template (tree decl, tree tmpl)\n   tree args;\n   tree code_pattern;\n   tree new_decl;\n-  int unregistered;\n+  bool unregistered;\n \n   args = DECL_TI_ARGS (decl);\n   code_pattern = DECL_TEMPLATE_RESULT (tmpl);\n@@ -10587,7 +10603,8 @@ regenerate_decl_from_template (tree decl, tree tmpl)\n      instantiation of a specialization, which it isn't: it's a full\n      instantiation.  */\n   gen_tmpl = most_general_template (tmpl);\n-  unregistered = unregister_specialization (decl, gen_tmpl);\n+  unregistered = reregister_specialization (decl, gen_tmpl,\n+\t\t\t\t\t    /*new_spec=*/NULL_TREE);\n \n   /* If the DECL was not unregistered then something peculiar is\n      happening: we created a specialization but did not call"}, {"sha": "ab9376b48a687f7aa94d9b2ae57941e997e293ca", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 341, "deletions": 0, "changes": 341, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b34459943bbfaf3f6fb32408bec5443b5bd007a9/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b34459943bbfaf3f6fb32408bec5443b5bd007a9/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=b34459943bbfaf3f6fb32408bec5443b5bd007a9", "patch": "@@ -1473,6 +1473,47 @@ finish_stmt_expr (tree rtl_expr)\n   return result;\n }\n \n+/* Perform Koenig lookup.  FN is the postfix-expression representing\n+   the call; ARGS are the arguments to the call.  Returns the\n+   functions to be considered by overload resolution.  */\n+\n+tree\n+perform_koenig_lookup (tree fn, tree args)\n+{\n+  tree identifier = NULL_TREE;\n+  tree functions = NULL_TREE;\n+\n+  /* Find the name of the overloaded function.  */\n+  if (TREE_CODE (fn) == IDENTIFIER_NODE)\n+    identifier = fn;\n+  else if (is_overloaded_fn (fn))\n+    {\n+      functions = fn;\n+      identifier = DECL_NAME (get_first_fn (functions));\n+    }\n+  else if (DECL_P (fn))\n+    {\n+      functions = fn;\n+      identifier = DECL_NAME (fn);\n+    }\n+\n+  /* A call to a namespace-scope function using an unqualified name.\n+\n+     Do Koenig lookup -- unless any of the arguments are\n+     type-dependent.  */\n+  if (!any_type_dependent_arguments_p (args))\n+    {\n+      fn = lookup_arg_dependent (identifier, functions, args);\n+      if (!fn)\n+\t/* The unqualified name could not be resolved.  */\n+\tfn = unqualified_fn_lookup_error (identifier);\n+    }\n+  else\n+    fn = build_min_nt (LOOKUP_EXPR, identifier);\n+\n+  return fn;\n+}\n+\n /* Generate an expression for `FN (ARGS)'.\n \n    If DISALLOW_VIRTUAL is true, the call to FN will be not generated\n@@ -2191,6 +2232,306 @@ check_multiple_declarators (void)\n     error (\"multiple declarators in template declaration\");\n }\n \n+/* ID_EXPRESSION is a representation of parsed, but unprocessed,\n+   id-expression.  (See cp_parser_id_expression for details.)  SCOPE,\n+   if non-NULL, is the type or namespace used to explicitly qualify\n+   ID_EXPRESSION.  DECL is the entity to which that name has been\n+   resolved.  \n+\n+   *CONSTANT_EXPRESSION_P is true if we are presently parsing a\n+   constant-expression.  In that case, *NON_CONSTANT_EXPRESSION_P will\n+   be set to true if this expression isn't permitted in a\n+   constant-expression, but it is otherwise not set by this function.\n+   *ALLOW_NON_CONSTANT_EXPRESSION_P is true if we are parsing a\n+   constant-expression, but a non-constant expression is also\n+   permissible.\n+\n+   If an error occurs, and it is the kind of error that might cause\n+   the parser to abort a tentative parse, *ERROR_MSG is filled in.  It\n+   is the caller's responsibility to issue the message.  *ERROR_MSG\n+   will be a string with static storage duration, so the caller need\n+   not \"free\" it.\n+\n+   Return an expression for the entity, after issuing appropriate\n+   diagnostics.  This function is also responsible for transforming a\n+   reference to a non-static member into a COMPONENT_REF that makes\n+   the use of \"this\" explicit.  \n+\n+   Upon return, *IDK will be filled in appropriately.  */\n+\n+tree\n+finish_id_expression (tree id_expression, \n+\t\t      tree decl,\n+\t\t      tree scope,\n+\t\t      cp_id_kind *idk,\n+\t\t      tree *qualifying_class,\n+\t\t      bool constant_expression_p,\n+\t\t      bool allow_non_constant_expression_p,\n+\t\t      bool *non_constant_expression_p,\n+\t\t      const char **error_msg)\n+{\n+  /* Initialize the output parameters.  */\n+  *idk = CP_ID_KIND_NONE;\n+  *error_msg = NULL;\n+\n+  if (id_expression == error_mark_node)\n+    return error_mark_node;\n+  /* If we have a template-id, then no further lookup is\n+     required.  If the template-id was for a template-class, we\n+     will sometimes have a TYPE_DECL at this point.  */\n+  else if (TREE_CODE (decl) == TEMPLATE_ID_EXPR\n+      || TREE_CODE (decl) == TYPE_DECL)\n+    ;\n+  /* Look up the name.  */\n+  else \n+    {\n+      if (decl == error_mark_node)\n+\t{\n+\t  /* Name lookup failed.  */\n+\t  if (scope && (!TYPE_P (scope) || !dependent_type_p (scope)))\n+\t    {\n+\t      /* Qualified name lookup failed, and the qualifying name\n+\t\t was not a dependent type.  That is always an\n+\t\t error.  */\n+\t      if (TYPE_P (scope) && !COMPLETE_TYPE_P (scope))\n+\t\terror (\"incomplete type `%T' used in nested name \"\n+\t\t       \"specifier\",\n+\t\t       scope);\n+\t      else if (scope != global_namespace)\n+\t\terror (\"`%D' is not a member of `%D'\",\n+\t\t       id_expression, scope);\n+\t      else\n+\t\terror (\"`::%D' has not been declared\", id_expression);\n+\t      return error_mark_node;\n+\t    }\n+\t  else if (!scope)\n+\t    {\n+\t      /* It may be resolved via Koenig lookup.  */\n+\t      *idk = CP_ID_KIND_UNQUALIFIED;\n+\t      return id_expression;\n+\t    }\n+\t}\n+      /* If DECL is a variable that would be out of scope under\n+\t ANSI/ISO rules, but in scope in the ARM, name lookup\n+\t will succeed.  Issue a diagnostic here.  */\n+      else\n+\tdecl = check_for_out_of_scope_variable (decl);\n+\n+      /* Remember that the name was used in the definition of\n+\t the current class so that we can check later to see if\n+\t the meaning would have been different after the class\n+\t was entirely defined.  */\n+      if (!scope && decl != error_mark_node)\n+\tmaybe_note_name_used_in_class (id_expression, decl);\n+    }\n+\n+  /* If we didn't find anything, or what we found was a type,\n+     then this wasn't really an id-expression.  */\n+  if (TREE_CODE (decl) == TEMPLATE_DECL\n+      && !DECL_FUNCTION_TEMPLATE_P (decl))\n+    {\n+      *error_msg = \"missing template arguments\";\n+      return error_mark_node;\n+    }\n+  else if (TREE_CODE (decl) == TYPE_DECL\n+\t   || TREE_CODE (decl) == NAMESPACE_DECL)\n+    {\n+      *error_msg = \"expected primary-expression\";\n+      return error_mark_node;\n+    }\n+\n+  /* If the name resolved to a template parameter, there is no\n+     need to look it up again later.  Similarly, we resolve\n+     enumeration constants to their underlying values.  */\n+  if (TREE_CODE (decl) == CONST_DECL)\n+    {\n+      *idk = CP_ID_KIND_NONE;\n+      if (DECL_TEMPLATE_PARM_P (decl) || !processing_template_decl)\n+\treturn DECL_INITIAL (decl);\n+      return decl;\n+    }\n+  else\n+    {\n+      bool dependent_p;\n+\n+      /* If the declaration was explicitly qualified indicate\n+\t that.  The semantics of `A::f(3)' are different than\n+\t `f(3)' if `f' is virtual.  */\n+      *idk = (scope \n+\t      ? CP_ID_KIND_QUALIFIED\n+\t      : (TREE_CODE (decl) == TEMPLATE_ID_EXPR\n+\t\t ? CP_ID_KIND_TEMPLATE_ID\n+\t\t : CP_ID_KIND_UNQUALIFIED));\n+\n+\n+      /* [temp.dep.expr]\n+\n+\t An id-expression is type-dependent if it contains an\n+\t identifier that was declared with a dependent type.\n+\n+\t As an optimization, we could choose not to create a\n+\t LOOKUP_EXPR for a name that resolved to a local variable in\n+\t the template function that we are currently declaring; such a\n+\t name cannot ever resolve to anything else.  If we did that we\n+\t would not have to look up these names at instantiation time.\n+\n+\t The standard is not very specific about an id-expression that\n+\t names a set of overloaded functions.  What if some of them\n+\t have dependent types and some of them do not?  Presumably,\n+\t such a name should be treated as a dependent name.  */\n+      /* Assume the name is not dependent.  */\n+      dependent_p = false;\n+      if (!processing_template_decl)\n+\t/* No names are dependent outside a template.  */\n+\t;\n+      /* A template-id where the name of the template was not resolved\n+\t is definitely dependent.  */\n+      else if (TREE_CODE (decl) == TEMPLATE_ID_EXPR\n+\t       && (TREE_CODE (TREE_OPERAND (decl, 0)) \n+\t\t   == IDENTIFIER_NODE))\n+\tdependent_p = true;\n+      /* For anything except an overloaded function, just check its\n+\t type.  */\n+      else if (!is_overloaded_fn (decl))\n+\tdependent_p \n+\t  = dependent_type_p (TREE_TYPE (decl));\n+      /* For a set of overloaded functions, check each of the\n+\t functions.  */\n+      else\n+\t{\n+\t  tree fns = decl;\n+\n+\t  if (BASELINK_P (fns))\n+\t    fns = BASELINK_FUNCTIONS (fns);\n+\n+\t  /* For a template-id, check to see if the template\n+\t     arguments are dependent.  */\n+\t  if (TREE_CODE (fns) == TEMPLATE_ID_EXPR)\n+\t    {\n+\t      tree args = TREE_OPERAND (fns, 1);\n+\t      dependent_p = any_dependent_template_arguments_p (args);\n+\t      /* The functions are those referred to by the\n+\t\t template-id.  */\n+\t      fns = TREE_OPERAND (fns, 0);\n+\t    }\n+\n+\t  /* If there are no dependent template arguments, go through\n+\t     the overlaoded functions.  */\n+\t  while (fns && !dependent_p)\n+\t    {\n+\t      tree fn = OVL_CURRENT (fns);\n+\n+\t      /* Member functions of dependent classes are\n+\t\t dependent.  */\n+\t      if (TREE_CODE (fn) == FUNCTION_DECL\n+\t\t  && type_dependent_expression_p (fn))\n+\t\tdependent_p = true;\n+\t      else if (TREE_CODE (fn) == TEMPLATE_DECL\n+\t\t       && dependent_template_p (fn))\n+\t\tdependent_p = true;\n+\n+\t      fns = OVL_NEXT (fns);\n+\t    }\n+\t}\n+\n+      /* If the name was dependent on a template parameter, we will\n+\t resolve the name at instantiation time.  */\n+      if (dependent_p)\n+\t{\n+\t  /* Create a SCOPE_REF for qualified names, if the scope is\n+\t     dependent.  */\n+\t  if (scope)\n+\t    {\n+\t      if (TYPE_P (scope))\n+\t\t*qualifying_class = scope;\n+\t      /* Since this name was dependent, the expression isn't\n+\t\t constant -- yet.  No error is issued because it might\n+\t\t be constant when things are instantiated.  */\n+\t      if (constant_expression_p)\n+\t\t*non_constant_expression_p = true;\n+\t      if (TYPE_P (scope) && dependent_type_p (scope))\n+\t\treturn build_nt (SCOPE_REF, scope, id_expression);\n+\t      else if (TYPE_P (scope) && DECL_P (decl))\n+\t\treturn build (SCOPE_REF, TREE_TYPE (decl), scope,\n+\t\t\t      id_expression);\n+\t      else\n+\t\treturn decl;\n+\t    }\n+\t  /* A TEMPLATE_ID already contains all the information we\n+\t     need.  */\n+\t  if (TREE_CODE (id_expression) == TEMPLATE_ID_EXPR)\n+\t    return id_expression;\n+\t  /* Since this name was dependent, the expression isn't\n+\t     constant -- yet.  No error is issued because it might be\n+\t     constant when things are instantiated.  */\n+\t  if (constant_expression_p)\n+\t    *non_constant_expression_p = true;\n+\t  /* Create a LOOKUP_EXPR for other unqualified names.  */\n+\t  return build_min_nt (LOOKUP_EXPR, id_expression);\n+\t}\n+\n+      /* Only certain kinds of names are allowed in constant\n+\t expression.  Enumerators have already been handled above.  */\n+      if (constant_expression_p)\n+\t{\n+\t  /* Non-type template parameters of integral or enumeration\n+\t     type are OK.  */\n+\t  if (TREE_CODE (decl) == TEMPLATE_PARM_INDEX\n+\t      && INTEGRAL_OR_ENUMERATION_TYPE_P (TREE_TYPE (decl)))\n+\t  ;\n+\t  /* Const variables or static data members of integral or\n+\t     enumeration types initialized with constant expressions\n+\t     are OK.  We also accept dependent initializers; they may\n+\t     turn out to be constant at instantiation-time.  */\n+\t  else if (TREE_CODE (decl) == VAR_DECL\n+\t\t   && CP_TYPE_CONST_P (TREE_TYPE (decl))\n+\t\t   && INTEGRAL_OR_ENUMERATION_TYPE_P (TREE_TYPE (decl))\n+\t\t   && DECL_INITIAL (decl)\n+\t\t   && (TREE_CONSTANT (DECL_INITIAL (decl))\n+\t\t       || type_dependent_expression_p (DECL_INITIAL \n+\t\t\t\t\t\t       (decl))\n+\t\t       || value_dependent_expression_p (DECL_INITIAL \n+\t\t\t\t\t\t\t(decl))))\n+\t    ;\n+\t  else\n+\t    {\n+\t      if (!allow_non_constant_expression_p)\n+\t\t{\n+\t\t  error (\"`%D' cannot appear in a constant-expression\", decl);\n+\t\t  return error_mark_node;\n+\t\t}\n+\t      *non_constant_expression_p = true;\n+\t    }\n+\t}\n+\n+      if (scope)\n+\t{\n+\t  decl = (adjust_result_of_qualified_name_lookup \n+\t\t  (decl, scope, current_class_type));\n+\t  if (TREE_CODE (decl) == FIELD_DECL || BASELINK_P (decl))\n+\t    *qualifying_class = scope;\n+\t  else if (!processing_template_decl)\n+\t    decl = convert_from_reference (decl);\n+\t  else if (TYPE_P (scope))\n+\t    decl = build (SCOPE_REF, TREE_TYPE (decl), scope, decl);\n+\t}\n+      else\n+\t/* Transform references to non-static data members into\n+\t   COMPONENT_REFs.  */\n+\tdecl = hack_identifier (decl, id_expression);\n+\n+      /* Resolve references to variables of anonymous unions\n+\t into COMPONENT_REFs.  */\n+      if (TREE_CODE (decl) == ALIAS_DECL)\n+\tdecl = DECL_INITIAL (decl);\n+    }\n+\n+  if (TREE_DEPRECATED (decl))\n+    warn_deprecated_use (decl);\n+\n+  return decl;\n+}\n+\n /* Implement the __typeof keyword: Return the type of EXPR, suitable for\n    use as a type-specifier.  */\n "}, {"sha": "1dedd6563d4551f5761756f58b8434ee1f925a1a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b34459943bbfaf3f6fb32408bec5443b5bd007a9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b34459943bbfaf3f6fb32408bec5443b5bd007a9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b34459943bbfaf3f6fb32408bec5443b5bd007a9", "patch": "@@ -1,3 +1,23 @@\n+2003-07-13  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/11493\n+\tPR c++/11495\n+\t* g++.dg/parse/template9.C: Likewise.\n+\t* g++.dg/template/crash4.C: New test.\n+\t* g++.dg/template/koenig1.C: Likewise.\n+\t* g++.old-deja/g++.benjamin/tem03.C: Adjust error markers.\n+\t* g++.old-deja/g++.benjamin/tem06.C: Declare \"x\".\n+\t* g++.old-deja/g++.jason/overload33.C: Use this-> when calling\n+\tfunctions.\n+\t* g++.old-deja/g++.jason/template36.C: Likewise.\n+\t* g++.old-deja/g++.mike/p1989.C: Likewise.\n+\t* g++.old-deja/g++.pt/lookup2.C: Use -fpermissive when compiling.\n+\t* g++.old-deja/g++.pt/ttp20.C: Use this->.\n+\t* g++.old-deja/g++.pt/ttp21.C: Use this->.\n+\t* g++.old-deja/g++.pt/typename13.C: Use -fpermissive when\n+\tcompiling.\n+\t* g++.old-deja/g++.pt/union2.C: Use this->.\n+\n 2003-07-11  Jakub Jelinek  <jakub@redhat.com>\n \n \t* gcc.dg/20030711-1.c: New test."}, {"sha": "90ce9fe61acf268464d8224545e1be33d2efb05d", "filename": "gcc/testsuite/g++.dg/parse/template9.C", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b34459943bbfaf3f6fb32408bec5443b5bd007a9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ftemplate9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b34459943bbfaf3f6fb32408bec5443b5bd007a9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ftemplate9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ftemplate9.C?ref=b34459943bbfaf3f6fb32408bec5443b5bd007a9", "patch": "@@ -0,0 +1,5 @@\n+template <typename T> \n+void f() {\n+  g(); // { dg-error \"\" }\n+  h(3); // { dg-error \"\" }\n+}"}, {"sha": "72b2bb18b9f0f217a685d691e1be4172a24be200", "filename": "gcc/testsuite/g++.dg/template/crash4.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b34459943bbfaf3f6fb32408bec5443b5bd007a9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcrash4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b34459943bbfaf3f6fb32408bec5443b5bd007a9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcrash4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcrash4.C?ref=b34459943bbfaf3f6fb32408bec5443b5bd007a9", "patch": "@@ -0,0 +1,12 @@\n+namespace NS {\n+    struct C {};\n+    void foo();\n+}\n+\n+template <class T> struct X {};\n+\n+template <class T> struct A {\n+    A() { foo (X<T>()); }\n+    void foo(X<T>);\n+};\n+template struct A<NS::C>;"}, {"sha": "850d38828241dc3155879a4779e2603f92a1204d", "filename": "gcc/testsuite/g++.dg/template/koenig1.C", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b34459943bbfaf3f6fb32408bec5443b5bd007a9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fkoenig1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b34459943bbfaf3f6fb32408bec5443b5bd007a9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fkoenig1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fkoenig1.C?ref=b34459943bbfaf3f6fb32408bec5443b5bd007a9", "patch": "@@ -0,0 +1,8 @@\n+namespace NS {\n+    struct C {};\n+    void foo(C);\n+}\n+\n+template <class T> void bar() { T t; foo (t); }\n+\n+template void bar<NS::C> ();"}, {"sha": "73b99659e121d4264c6b6bec7af185e933d9b907", "filename": "gcc/testsuite/g++.old-deja/g++.benjamin/tem03.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b34459943bbfaf3f6fb32408bec5443b5bd007a9/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.benjamin%2Ftem03.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b34459943bbfaf3f6fb32408bec5443b5bd007a9/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.benjamin%2Ftem03.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.benjamin%2Ftem03.C?ref=b34459943bbfaf3f6fb32408bec5443b5bd007a9", "patch": "@@ -195,7 +195,7 @@ struct Xthirteen {\n     if (local_value > value) // { dg-error \"\" } .*\n       return local_value;\n     else\n-      return value; // { dg-error \"\" } .*\n+      return value;\n   }\n };\n "}, {"sha": "3233e0e964d5b687a2cbfefe6c15068dfcabe656", "filename": "gcc/testsuite/g++.old-deja/g++.benjamin/tem06.C", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b34459943bbfaf3f6fb32408bec5443b5bd007a9/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.benjamin%2Ftem06.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b34459943bbfaf3f6fb32408bec5443b5bd007a9/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.benjamin%2Ftem06.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.benjamin%2Ftem06.C?ref=b34459943bbfaf3f6fb32408bec5443b5bd007a9", "patch": "@@ -14,6 +14,8 @@ public:\n   friend void x (const T &) { }\n };\n \n+void x(const int &);\n+\n template<class T>\n void blah (const T &) {\n   T y;"}, {"sha": "2cc34c6b2098a1b3885f964ffc2617373fcd8838", "filename": "gcc/testsuite/g++.old-deja/g++.jason/overload33.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b34459943bbfaf3f6fb32408bec5443b5bd007a9/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.jason%2Foverload33.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b34459943bbfaf3f6fb32408bec5443b5bd007a9/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.jason%2Foverload33.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.jason%2Foverload33.C?ref=b34459943bbfaf3f6fb32408bec5443b5bd007a9", "patch": "@@ -58,10 +58,10 @@ class SmartPtr : public ConstSmartPtr<T>\n \t\t\t  : ConstSmartPtr<T>(theItem) {}\n \n     T*\t\t\titem() const\n-\t\t\t\t{ return _item(); }\n+\t\t\t\t{ return this->_item(); }\n \n \t\t\toperator T*() const\n-\t\t\t\t{ return _item(); }\n+\t\t\t\t{ return this->_item(); }\n };\n \n /* ------------------------------------------------------------ */"}, {"sha": "23cdb00e6debf8f9f50ed724e5c50401bbd276ee", "filename": "gcc/testsuite/g++.old-deja/g++.jason/template36.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b34459943bbfaf3f6fb32408bec5443b5bd007a9/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.jason%2Ftemplate36.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b34459943bbfaf3f6fb32408bec5443b5bd007a9/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.jason%2Ftemplate36.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.jason%2Ftemplate36.C?ref=b34459943bbfaf3f6fb32408bec5443b5bd007a9", "patch": "@@ -33,7 +33,7 @@ public:\n     int base::* g ();\n \n     int zowee() const\n-    { return bar(); }  \n+    { return this->bar(); }  \n };\n \n template <class T>"}, {"sha": "bbecdd8d8a4273df2f5f2cb6e21e1122d7072c0c", "filename": "gcc/testsuite/g++.old-deja/g++.mike/p1989.C", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b34459943bbfaf3f6fb32408bec5443b5bd007a9/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.mike%2Fp1989.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b34459943bbfaf3f6fb32408bec5443b5bd007a9/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.mike%2Fp1989.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.mike%2Fp1989.C?ref=b34459943bbfaf3f6fb32408bec5443b5bd007a9", "patch": "@@ -195,8 +195,8 @@ template<class T>\n Pix\n List_DLS<T>::search(const T& item) const\n {\n-    for (Pix x=first(); 0 != x; next(x)) {\n-\tif (item == operator()(x)) // { dg-error \"\" } const subversion\n+    for (Pix x=this->first(); 0 != x; this->next(x)) {\n+\tif (item == this->operator()(x)) // { dg-error \"\" } const subversion\n \t    return x;\n     }\n     return 0;\n@@ -223,8 +223,8 @@ template<class T>\n bool\n List_DLSp<T>::contains(const T& item) const\n {\n-    for (Pix x=first(); 0 != x; next(x)) {\n-\tif (*item == *operator()(x))\n+    for (Pix x=this->first(); 0 != x; this->next(x)) {\n+        if (*item == *(this->operator()(x)))\n \t    return TRUE;\n     }\n     return FALSE;"}, {"sha": "3d9f0605a18640c609e1d46ea21f93d78b8e491a", "filename": "gcc/testsuite/g++.old-deja/g++.pt/lookup2.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b34459943bbfaf3f6fb32408bec5443b5bd007a9/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Flookup2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b34459943bbfaf3f6fb32408bec5443b5bd007a9/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Flookup2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Flookup2.C?ref=b34459943bbfaf3f6fb32408bec5443b5bd007a9", "patch": "@@ -1,5 +1,5 @@\n // { dg-do assemble  }\n-// { dg-options \"\" }\n+// { dg-options \"-fpermissive\" }\n \n class A\n {\n@@ -15,6 +15,6 @@ protected:\n template <class T> class D : private B<T>\n {\n public:\n-  void f2() { f1(); };\n+  void f2() { f1(); }; // { dg-warning \"\" }\n };\n "}, {"sha": "c54119efda233db2b7ec11ace41aaf9be129d755", "filename": "gcc/testsuite/g++.old-deja/g++.pt/ttp20.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b34459943bbfaf3f6fb32408bec5443b5bd007a9/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fttp20.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b34459943bbfaf3f6fb32408bec5443b5bd007a9/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fttp20.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fttp20.C?ref=b34459943bbfaf3f6fb32408bec5443b5bd007a9", "patch": "@@ -18,7 +18,7 @@ template<template<class> class D,class E> class C : D<E>\n \n template<template<class> class D,class E> int C<D,E>::g()\n {\n-\treturn f();\n+\treturn this->f();\n }\n \n int main()"}, {"sha": "f0b41bf3f569ada8ab3d16d7262fed4758428b5f", "filename": "gcc/testsuite/g++.old-deja/g++.pt/ttp21.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b34459943bbfaf3f6fb32408bec5443b5bd007a9/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fttp21.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b34459943bbfaf3f6fb32408bec5443b5bd007a9/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fttp21.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fttp21.C?ref=b34459943bbfaf3f6fb32408bec5443b5bd007a9", "patch": "@@ -18,13 +18,13 @@ template<template<class> class D,class E> class C : D<E>\n \n template<template<class> class D,class E> int C<D,E>::g()\n {\n-\treturn f();\n+\treturn this->f();\n }\n \n class E : C<D,int>\n {\n \tpublic:\n-\t\tint h() { return g(); }\n+\t\tint h() { return this->g(); }\n };\n \n int main()"}, {"sha": "385834b959d33e3f69a6f6a6841d7af6bc1589a6", "filename": "gcc/testsuite/g++.old-deja/g++.pt/typename13.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b34459943bbfaf3f6fb32408bec5443b5bd007a9/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ftypename13.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b34459943bbfaf3f6fb32408bec5443b5bd007a9/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ftypename13.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ftypename13.C?ref=b34459943bbfaf3f6fb32408bec5443b5bd007a9", "patch": "@@ -1,5 +1,5 @@\n // { dg-do assemble  }\n-// { dg-options \"\" }\n+// { dg-options \"-fpermissive\" }\n \n template <class T>\n struct B \n@@ -18,7 +18,7 @@ struct D : public B<T>\n template <class T>\n void D<T>::f()\n {\n-  I();\n+  I(); // { dg-warning \"\" }\n }\n \n "}, {"sha": "fdb038f20b06c815b00376029d76a1e6aae473da", "filename": "gcc/testsuite/g++.old-deja/g++.pt/union2.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b34459943bbfaf3f6fb32408bec5443b5bd007a9/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Funion2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b34459943bbfaf3f6fb32408bec5443b5bd007a9/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Funion2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Funion2.C?ref=b34459943bbfaf3f6fb32408bec5443b5bd007a9", "patch": "@@ -12,7 +12,7 @@ protected:\n };\n \n template<class T> struct vector : public vector_base<T> {\n-  vector () { def_basep (); }\n+  vector () { this->def_basep (); }\n };\n \n vector<int> iv;"}]}