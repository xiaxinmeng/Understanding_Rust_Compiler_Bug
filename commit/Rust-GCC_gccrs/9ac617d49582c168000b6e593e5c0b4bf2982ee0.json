{"sha": "9ac617d49582c168000b6e593e5c0b4bf2982ee0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWFjNjE3ZDQ5NTgyYzE2ODAwMGI2ZTU5M2U1YzBiNGJmMjk4MmVlMA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@libertysurf.fr", "date": "2004-06-30T10:31:30Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2004-06-30T10:31:30Z"}, "message": "RTL prologue/epilogue for SPARC\n\n\tRTL prologue/epilogue for SPARC\n\t* config/sparc/sparc-protos.h (sparc_emitting_epilogue): Delete.\n\t(sparc_skip_caller_unimp): Likewise.\n\t(load_pic_register): Likewise.\n\t(leaf_return_peephole_ok): Likewise.\n\t(compute_frame_size): Rename into sparc_compute_frame_size.\n\t(sparc_expand_prologue): New prototype.\n\t(sparc_expand_epilogue): Likewise.\n\t(output_return): Likewise.\n\t(eligible_for_epilogue_delay): Rename into eligible_for_return_delay.\n\t* config/sparc/sparc.h (INITIAL_ELIMINATION_OFFSET): Adjust call to\n\tcompute_frame_size.  Move comment up.\n\t(DELAY_SLOTS_FOR_EPILOGUE): Delete.\n\t(ELIGIBLE_FOR_EPILOGUE_DELAY): Likewise.\n\t(EPILOGUE_USES): Return true for %g1 if the function uses EH return.\n\t* config/sparc/sparc.md (UNSPECV_SAVEW): New constant.\n\t(type attribute): Add 'return' and 'savew'.\n\t(eligible_for_return_delay): New attribute.\n\t(return): New delay_slot.\n\t(sibcall_epilogue): Call sparc_expand_epilogue.\n\t(prologue): Likewise.  Move up.\n\t(save_register_window): New expander.\n\t(save_register_windowsi): New pattern.\n\t(save_register_windowdi): Likewise.\n\t(epilogue): New expander.\n\t(return_internal): New pattern.\n\t(Return peepholes): Delete.\n\t* config/sparc/sparc.c (SIBCALL_SLOT_EMPTY_P): New macro.\n\t(sparc_emitting_epilogue): Delete.\n\t(sparc_skip_caller_unimp): Likewise.\n\t(sparc_sr_alias_set): New global variable.\n\t(frame_base_name): Delete.\n\t(frame_base_reg): New global variable.\n\t(sparc_override_options): Get new alias set for save/restore.\n\t(leaf_return_peephole_ok): Delete.\n\t(eligible_for_epilogue_delay): Rename into eligible_for_return_delay.\n\tFactor out code into eligible_for_restore_insn_delay.\n\t(eligible_for_restore_insn_delay): New function extraced from above.\n\tUse IN_UNCOND_BRANCH_DELAY_TRUE instead of IN_BRANCH_DELAY_TRUE.\n\t(eligible_for_sibcall_delay): Use SIBCALL_SLOT_EMPTY_P.\n\tFactor out code into eligible_for_restore_insn_delay.\n\t(load_pic_register): Make static.  Remove check.\n\t(save_regs): Delete.\n\t(restore_regs): Likewise.\n\t(compute_frame_size): Rename into sparc_compute_frame_size.\n\tRename leaf_function into leaf_function_p.\n\t(build_big_number): Delete.\n\t(save_or_restore_regs): New function.\n\t(emit_save_regs): Likewise.\n\t(emit_restore_regs): Likewise.\n\t(emit_stack_pointer_increment ): Likewise.\n\t(emit_stack_pointer_decrement): Likewise.\n\t(sparc_expand_prologue): Likewise.\n\t(sparc_function_prologue): Rename into sparc_asm_function_prologue.\n\tRemove all code to emit instructions.\n\t(sparc_expand_epilogue): New function.\n\t(sparc_function_epilogue): Rename into sparc_asm_function_epilogue.\n\tRemove all code to emit instructions.\n\t(output_restore): New function.\n\t(output_return): Likewise.\n\t(output_sibcall): Factor out code into output_restore.\n\t(print_operand): Adjust for frame_base_reg.\n\t* target.h (struct gcc_target): New field 'late_rtl_prologue_epilogue'.\n\t* target-def.h (TARGET_LATE_RTL_PROLOGUE_EPILOGUE): New define.\n\t(TARGET_INITIALIZER): Add it.\n\t* passes.c (rest_of_compilation): Set the conditional predicate\n\t'current_function_uses_only_leaf_regs' before sched2.  If target\n\thas 'late_rtl_prologue_epilogue', emit RTL prologue/epilogue right\n\tbefore sched2.\n\t* reorg.c (return_insn_p): New predicate.\n\t(find_end_label): Use it.\n\t(relax_delay_slots): Do not thread an unconditional jump that points\n\tto the end return label.\n\t* doc/tm.texi (Registers) <Leaf Functions>: Clarify the validity\n\tdomain of 'current_function_uses_only_leaf_regs'.\n\t(Stack and Calling) <Function Entry>: Document new target hook\n\tTARGET_LATE_RTL_PROLOGUE_EPILOGUE.\n\nFrom-SVN: r83901", "tree": {"sha": "b97b5461a829ec280cef91bfec87507aa0ea48a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b97b5461a829ec280cef91bfec87507aa0ea48a1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9ac617d49582c168000b6e593e5c0b4bf2982ee0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ac617d49582c168000b6e593e5c0b4bf2982ee0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ac617d49582c168000b6e593e5c0b4bf2982ee0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ac617d49582c168000b6e593e5c0b4bf2982ee0/comments", "author": {"login": "ebotcazou", "id": 48091907, "node_id": "MDQ6VXNlcjQ4MDkxOTA3", "avatar_url": "https://avatars.githubusercontent.com/u/48091907?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ebotcazou", "html_url": "https://github.com/ebotcazou", "followers_url": "https://api.github.com/users/ebotcazou/followers", "following_url": "https://api.github.com/users/ebotcazou/following{/other_user}", "gists_url": "https://api.github.com/users/ebotcazou/gists{/gist_id}", "starred_url": "https://api.github.com/users/ebotcazou/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ebotcazou/subscriptions", "organizations_url": "https://api.github.com/users/ebotcazou/orgs", "repos_url": "https://api.github.com/users/ebotcazou/repos", "events_url": "https://api.github.com/users/ebotcazou/events{/privacy}", "received_events_url": "https://api.github.com/users/ebotcazou/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "df62f18ae1401944493ecccd47f7b0714d0ab8f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df62f18ae1401944493ecccd47f7b0714d0ab8f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df62f18ae1401944493ecccd47f7b0714d0ab8f8"}], "stats": {"total": 1790, "additions": 795, "deletions": 995}, "files": [{"sha": "b680a35e861382b7ee0d50b85a0c3b92d4673c8d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ac617d49582c168000b6e593e5c0b4bf2982ee0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ac617d49582c168000b6e593e5c0b4bf2982ee0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9ac617d49582c168000b6e593e5c0b4bf2982ee0", "patch": "@@ -1,3 +1,83 @@\n+2004-06-30  Eric Botcazou  <ebotcazou@libertysurf.fr>\n+\n+\tRTL prologue/epilogue for SPARC\n+\t* config/sparc/sparc-protos.h (sparc_emitting_epilogue): Delete.\n+\t(sparc_skip_caller_unimp): Likewise.\n+\t(load_pic_register): Likewise.\n+\t(leaf_return_peephole_ok): Likewise.\n+\t(compute_frame_size): Rename into sparc_compute_frame_size.\n+\t(sparc_expand_prologue): New prototype.\n+\t(sparc_expand_epilogue): Likewise.\n+\t(output_return): Likewise.\n+\t(eligible_for_epilogue_delay): Rename into eligible_for_return_delay.\n+\t* config/sparc/sparc.h (INITIAL_ELIMINATION_OFFSET): Adjust call to\n+\tcompute_frame_size.  Move comment up.\n+\t(DELAY_SLOTS_FOR_EPILOGUE): Delete.\n+\t(ELIGIBLE_FOR_EPILOGUE_DELAY): Likewise.\n+\t(EPILOGUE_USES): Return true for %g1 if the function uses EH return.\n+\t* config/sparc/sparc.md (UNSPECV_SAVEW): New constant.\n+\t(type attribute): Add 'return' and 'savew'.\n+\t(eligible_for_return_delay): New attribute.\n+\t(return): New delay_slot.\n+\t(sibcall_epilogue): Call sparc_expand_epilogue.\n+\t(prologue): Likewise.  Move up.\n+\t(save_register_window): New expander.\n+\t(save_register_windowsi): New pattern.\n+\t(save_register_windowdi): Likewise.\n+\t(epilogue): New expander.\n+\t(return_internal): New pattern.\n+\t(Return peepholes): Delete.\n+\t* config/sparc/sparc.c (SIBCALL_SLOT_EMPTY_P): New macro.\n+\t(sparc_emitting_epilogue): Delete.\n+\t(sparc_skip_caller_unimp): Likewise.\n+\t(sparc_sr_alias_set): New global variable.\n+\t(frame_base_name): Delete.\n+\t(frame_base_reg): New global variable.\n+\t(sparc_override_options): Get new alias set for save/restore.\n+\t(leaf_return_peephole_ok): Delete.\n+\t(eligible_for_epilogue_delay): Rename into eligible_for_return_delay.\n+\tFactor out code into eligible_for_restore_insn_delay.\n+\t(eligible_for_restore_insn_delay): New function extraced from above.\n+\tUse IN_UNCOND_BRANCH_DELAY_TRUE instead of IN_BRANCH_DELAY_TRUE.\n+\t(eligible_for_sibcall_delay): Use SIBCALL_SLOT_EMPTY_P.\n+\tFactor out code into eligible_for_restore_insn_delay.\n+\t(load_pic_register): Make static.  Remove check.\n+\t(save_regs): Delete.\n+\t(restore_regs): Likewise.\n+\t(compute_frame_size): Rename into sparc_compute_frame_size.\n+\tRename leaf_function into leaf_function_p.\n+\t(build_big_number): Delete.\n+\t(save_or_restore_regs): New function.\n+\t(emit_save_regs): Likewise.\n+\t(emit_restore_regs): Likewise.\n+\t(emit_stack_pointer_increment ): Likewise.\n+\t(emit_stack_pointer_decrement): Likewise.\n+\t(sparc_expand_prologue): Likewise.\n+\t(sparc_function_prologue): Rename into sparc_asm_function_prologue.\n+\tRemove all code to emit instructions.\n+\t(sparc_expand_epilogue): New function.\n+\t(sparc_function_epilogue): Rename into sparc_asm_function_epilogue.\n+\tRemove all code to emit instructions.\n+\t(output_restore): New function.\n+\t(output_return): Likewise.\n+\t(output_sibcall): Factor out code into output_restore.\n+\t(print_operand): Adjust for frame_base_reg.\n+\t* target.h (struct gcc_target): New field 'late_rtl_prologue_epilogue'.\n+\t* target-def.h (TARGET_LATE_RTL_PROLOGUE_EPILOGUE): New define.\n+\t(TARGET_INITIALIZER): Add it.\n+\t* passes.c (rest_of_compilation): Set the conditional predicate\n+\t'current_function_uses_only_leaf_regs' before sched2.  If target\n+\thas 'late_rtl_prologue_epilogue', emit RTL prologue/epilogue right\n+\tbefore sched2.\n+\t* reorg.c (return_insn_p): New predicate.\n+\t(find_end_label): Use it.\n+\t(relax_delay_slots): Do not thread an unconditional jump that points\n+\tto the end return label.\n+\t* doc/tm.texi (Registers) <Leaf Functions>: Clarify the validity\n+\tdomain of 'current_function_uses_only_leaf_regs'.\n+\t(Stack and Calling) <Function Entry>: Document new target hook\n+\tTARGET_LATE_RTL_PROLOGUE_EPILOGUE.\n+\n 2004-06-30  Jakub Jelinek  <jakub@redhat.com>\n \n \t* simplify-rtx.c (simplify_binary_operation): Simplify"}, {"sha": "2f2ee5192e76c661a6ccc1295bf68ee960c386b3", "filename": "gcc/config/sparc/sparc-protos.h", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ac617d49582c168000b6e593e5c0b4bf2982ee0/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ac617d49582c168000b6e593e5c0b4bf2982ee0/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h?ref=9ac617d49582c168000b6e593e5c0b4bf2982ee0", "patch": "@@ -24,9 +24,6 @@ Boston, MA 02111-1307, USA.  */\n #ifndef __SPARC_PROTOS_H__\n #define __SPARC_PROTOS_H__\n \n-extern bool sparc_emitting_epilogue;\n-extern bool sparc_skip_caller_unimp;\n-\n #ifdef TREE_CODE\n extern struct rtx_def *function_value (tree, enum machine_mode, int);\n extern void function_arg_advance (CUMULATIVE_ARGS *,\n@@ -49,14 +46,14 @@ extern enum direction function_arg_padding (enum machine_mode, tree);\n #endif /* ARGS_SIZE_RTX */\n #endif /* TREE_CODE */\n \n-extern void load_pic_register (void);\n extern void order_regs_for_local_alloc (void);\n-extern HOST_WIDE_INT compute_frame_size (HOST_WIDE_INT, int);\n+extern HOST_WIDE_INT sparc_compute_frame_size (HOST_WIDE_INT, int);\n+extern void sparc_expand_prologue (void);\n+extern void sparc_expand_epilogue (void);\n extern int check_pic (int);\n extern int short_branch (int, int);\n extern void sparc_profile_hook (int);\n extern void sparc_override_options (void);\n-extern int leaf_return_peephole_ok (void);\n extern void sparc_output_scratch_registers (FILE *);\n \n #ifdef RTX_CODE\n@@ -87,6 +84,7 @@ extern void sparc_emit_set_symbolic_const64 (rtx, rtx, rtx);\n extern int sparc_splitdi_legitimate (rtx, rtx);\n extern int sparc_absnegfloat_split_legitimate (rtx, rtx);\n extern char *output_cbranch (rtx, rtx, int, int, int, int, rtx);\n+extern const char *output_return (rtx);\n extern const char *output_sibcall (rtx, rtx);\n extern char *output_v9branch (rtx, rtx, int, int, int, int, int, rtx);\n extern void emit_v9_brxx_insn (enum rtx_code, rtx, rtx);\n@@ -99,7 +97,7 @@ extern int fp_zero_operand (rtx, enum machine_mode);\n extern int reg_or_0_operand (rtx, enum machine_mode);\n extern int tls_symbolic_operand (rtx);\n extern int empty_delay_slot (rtx);\n-extern int eligible_for_epilogue_delay (rtx, int);\n+extern int eligible_for_return_delay (rtx);\n extern int eligible_for_sibcall_delay (rtx);\n extern int tls_call_delay (rtx);\n extern int emit_move_sequence (rtx, enum machine_mode);"}, {"sha": "cf2526f7ef7b799495a8620d2dfd0c35e956fd81", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 541, "deletions": 757, "changes": 1298, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ac617d49582c168000b6e593e5c0b4bf2982ee0/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ac617d49582c168000b6e593e5c0b4bf2982ee0/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=9ac617d49582c168000b6e593e5c0b4bf2982ee0", "patch": "@@ -49,12 +49,23 @@ Boston, MA 02111-1307, USA.  */\n #include \"cfglayout.h\"\n #include \"tree-gimple.h\"\n \n+#ifdef HAVE_AS_RELAX_OPTION\n+/* If 'as' and 'ld' are relaxing tail call insns into branch always, use\n+   \"or %o7,%g0,X; call Y; or X,%g0,%o7\" always, so that it can be optimized.\n+   With sethi/jmp, neither 'as' nor 'ld' has an easy way how to find out if\n+   somebody does not branch between the sethi and jmp.  */\n+#define SIBCALL_SLOT_EMPTY_P 0\n+#else\n+#define SIBCALL_SLOT_EMPTY_P \\\n+  ((TARGET_ARCH32 || TARGET_CM_MEDLOW) && ! flag_pic)\n+#endif\n+\n /* Global variables for machine-dependent things.  */\n \n /* Size of frame.  Need to know this to emit return insns from leaf procedures.\n-   ACTUAL_FSIZE is set by compute_frame_size() which is called during the\n-   reload pass.  This is important as the value is later used in insn\n-   scheduling (to see what can go in a delay slot).\n+   ACTUAL_FSIZE is set by sparc_compute_frame_size() which is called during the\n+   reload pass.  This is important as the value is later used for scheduling\n+   (to see what can go in a delay slot).\n    APPARENT_FSIZE is the size of the stack less the register save area and less\n    the outgoing argument area.  It is used when saving call preserved regs.  */\n static HOST_WIDE_INT apparent_fsize;\n@@ -64,15 +75,13 @@ static HOST_WIDE_INT actual_fsize;\n    saved (as 4-byte quantities).  */\n static int num_gfregs;\n \n+/* The alias set for prologue/epilogue register save/restore.  */\n+static GTY(()) int sparc_sr_alias_set;\n+\n /* Save the operands last given to a compare for use when we\n    generate a scc or bcc insn.  */\n rtx sparc_compare_op0, sparc_compare_op1;\n \n-/* Coordinate with the md file wrt special insns created by\n-   sparc_function_epilogue.  */\n-bool sparc_emitting_epilogue;\n-bool sparc_skip_caller_unimp;\n-\n /* Vector to say how input registers are mapped to output registers.\n    HARD_FRAME_POINTER_REGNUM cannot be remapped by this function to\n    eliminate it.  You must use -fomit-frame-pointer to get that.  */\n@@ -116,18 +125,15 @@ struct machine_function GTY(())\n   const char *some_ld_name;\n };\n \n-/* Name of where we pretend to think the frame pointer points.\n-   Normally, this is \"%fp\", but if we are in a leaf procedure,\n-   this is \"%sp+something\".  We record \"something\" separately as it may be\n-   too big for reg+constant addressing.  */\n+/* Register we pretend to think the frame pointer is allocated to.\n+   Normally, this is %fp, but if we are in a leaf procedure, this\n+   is %sp+\"something\".  We record \"something\" separately as it may\n+   be too big for reg+constant addressing.  */\n \n-static const char *frame_base_name;\n+static rtx frame_base_reg;\n static HOST_WIDE_INT frame_base_offset;\n \n static void sparc_init_modes (void);\n-static int save_regs (FILE *, int, int, const char *, int, int, HOST_WIDE_INT);\n-static int restore_regs (FILE *, int, int, const char *, int, int);\n-static void build_big_number (FILE *, HOST_WIDE_INT, const char *);\n static void scan_record_type (tree, int *, int *, int *);\n static int function_arg_slotno (const CUMULATIVE_ARGS *, enum machine_mode,\n \t\t\t\ttree, int, int, int *, int *);\n@@ -138,16 +144,16 @@ static int hypersparc_adjust_cost (rtx, rtx, rtx, int);\n static void sparc_output_addr_vec (rtx);\n static void sparc_output_addr_diff_vec (rtx);\n static void sparc_output_deferred_case_vectors (void);\n-static int check_return_regs (rtx);\n static rtx sparc_builtin_saveregs (void);\n static int epilogue_renumber (rtx *, int);\n static bool sparc_assemble_integer (rtx, unsigned int, int);\n static int set_extends (rtx);\n-static void output_restore_regs (FILE *, int);\n-static void sparc_output_function_prologue (FILE *, HOST_WIDE_INT);\n-static void sparc_output_function_epilogue (FILE *, HOST_WIDE_INT);\n-static void sparc_function_epilogue (FILE *, HOST_WIDE_INT, int);\n-static void sparc_function_prologue (FILE *, HOST_WIDE_INT, int);\n+static void load_pic_register (void);\n+static int save_or_restore_regs (int, int, rtx, int, int);\n+static void emit_save_regs (void);\n+static void emit_restore_regs (void);\n+static void sparc_asm_function_prologue (FILE *, HOST_WIDE_INT);\n+static void sparc_asm_function_epilogue (FILE *, HOST_WIDE_INT);\n #ifdef OBJECT_FORMAT_ELF\n static void sparc_elf_asm_named_section (const char *, unsigned int);\n #endif\n@@ -225,9 +231,9 @@ enum processor_type sparc_cpu;\n #define TARGET_ASM_INTEGER sparc_assemble_integer\n \n #undef TARGET_ASM_FUNCTION_PROLOGUE\n-#define TARGET_ASM_FUNCTION_PROLOGUE sparc_output_function_prologue\n+#define TARGET_ASM_FUNCTION_PROLOGUE sparc_asm_function_prologue\n #undef TARGET_ASM_FUNCTION_EPILOGUE\n-#define TARGET_ASM_FUNCTION_EPILOGUE sparc_output_function_epilogue\n+#define TARGET_ASM_FUNCTION_EPILOGUE sparc_asm_function_epilogue\n \n #undef TARGET_SCHED_ADJUST_COST\n #define TARGET_SCHED_ADJUST_COST sparc_adjust_cost\n@@ -291,6 +297,9 @@ enum processor_type sparc_cpu;\n #undef TARGET_GIMPLIFY_VA_ARG_EXPR\n #define TARGET_GIMPLIFY_VA_ARG_EXPR sparc_gimplify_va_arg\n \n+#undef TARGET_LATE_RTL_PROLOGUE_EPILOGUE\n+#define TARGET_LATE_RTL_PROLOGUE_EPILOGUE true\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n /* Validate and override various options, and do some machine dependent\n@@ -490,6 +499,9 @@ sparc_override_options (void)\n   /* Do various machine dependent initializations.  */\n   sparc_init_modes ();\n \n+  /* Acquire a unique set number for our register saves and restores.  */\n+  sparc_sr_alias_set = new_alias_set ();\n+\n   /* Set up function hooks.  */\n   init_machine_status = sparc_init_machine_status;\n }\n@@ -705,14 +717,6 @@ icc_or_fcc_reg_operand (rtx op, enum machine_mode mode)\n   return fcc_reg_operand (op, mode);\n }\n \n-/* Nonzero if OP can appear as the dest of a RESTORE insn.  */\n-int\n-restore_operand (rtx op, enum machine_mode mode)\n-{\n-  return (GET_CODE (op) == REG && GET_MODE (op) == mode\n-\t  && (REGNO (op) < 8 || (REGNO (op) >= 24 && REGNO (op) < 32)));\n-}\n-\n /* Call insn on SPARC can take a PC-relative constant address, or any regular\n    memory address.  */\n \n@@ -1136,7 +1140,7 @@ arith10_operand (rtx op, enum machine_mode mode)\n /* Return true if OP is a register, is a CONST_INT that fits in a 13 bit\n    immediate field, or is a CONST_DOUBLE whose both parts fit in a 13 bit\n    immediate field.\n-   v9: Return true if OP is a register, or is a CONST_INT or CONST_DOUBLE that\n+   ARCH64: Return true if OP is a register, or is a CONST_INT or CONST_DOUBLE that\n    can fit in a 13 bit immediate field.  This is an acceptable DImode operand\n    for most 3 address instructions.  */\n \n@@ -2749,14 +2753,6 @@ emit_tfmode_cvt (enum rtx_code code, rtx *operands)\n     emit_soft_tfmode_cvt (code, operands);\n }\n \f\n-/* Return nonzero if a return peephole merging return with\n-   setting of output register is ok.  */\n-int\n-leaf_return_peephole_ok (void)\n-{\n-  return (actual_fsize == 0);\n-}\n-\n /* Return nonzero if a branch/jump/call instruction will be emitting\n    nop into its delay slot.  */\n \n@@ -2776,69 +2772,48 @@ empty_delay_slot (rtx insn)\n   return 1;\n }\n \n-/* Return nonzero if TRIAL can go into the function epilogue's\n-   delay slot.  SLOT is the slot we are trying to fill.  */\n+/* Return nonzero if TRIAL can go into the call delay slot.  */\n \n int\n-eligible_for_epilogue_delay (rtx trial, int slot)\n+tls_call_delay (rtx trial)\n {\n-  rtx pat, src;\n-\n-  if (slot >= 1)\n-    return 0;\n-\n-  if (GET_CODE (trial) != INSN || GET_CODE (PATTERN (trial)) != SET)\n-    return 0;\n-\n-  if (get_attr_length (trial) != 1)\n-    return 0;\n-\n-  /* If there are any call-saved registers, we should scan TRIAL if it\n-     does not reference them.  For now just make it easy.  */\n-  if (num_gfregs)\n-    return 0;\n-\n-  /* If the function uses __builtin_eh_return, the eh_return machinery\n-     occupies the delay slot.  */\n-  if (current_function_calls_eh_return)\n-    return 0;\n+  rtx pat, unspec;\n \n-  /* In the case of a true leaf function, anything can go into the delay slot.\n-     A delay slot only exists however if the frame size is zero, otherwise\n-     we will put an insn to adjust the stack after the return.  */\n-  if (current_function_uses_only_leaf_regs)\n-    {\n-      if (leaf_return_peephole_ok ())\n-\treturn ((get_attr_in_uncond_branch_delay (trial)\n-\t\t == IN_BRANCH_DELAY_TRUE));\n-      return 0;\n-    }\n+  /* Binutils allows\n+     call __tls_get_addr, %tgd_call (foo)\n+      add %l7, %o0, %o0, %tgd_add (foo)\n+     while Sun as/ld does not.  */\n+  if (TARGET_GNU_TLS || !TARGET_TLS)\n+    return 1;\n \n   pat = PATTERN (trial);\n+  if (GET_CODE (pat) != SET || GET_CODE (SET_DEST (pat)) != PLUS)\n+    return 1;\n \n-  /* Otherwise, only operations which can be done in tandem with\n-     a `restore' or `return' insn can go into the delay slot.  */\n-  if (GET_CODE (SET_DEST (pat)) != REG\n-      || REGNO (SET_DEST (pat)) < 24)\n-    return 0;\n+  unspec = XEXP (SET_DEST (pat), 1);\n+  if (GET_CODE (unspec) != UNSPEC\n+      || (XINT (unspec, 1) != UNSPEC_TLSGD\n+\t  && XINT (unspec, 1) != UNSPEC_TLSLDM))\n+    return 1;\n \n-  /* If this instruction sets up floating point register and we have a return\n-     instruction, it can probably go in.  But restore will not work\n-     with FP_REGS.  */\n-  if (REGNO (SET_DEST (pat)) >= 32)\n-    {\n-      if (TARGET_V9 && ! epilogue_renumber (&pat, 1)\n-\t  && (get_attr_in_uncond_branch_delay (trial) == IN_BRANCH_DELAY_TRUE))\n-\treturn 1;\n-      return 0;\n-    }\n+  return 0;\n+}\n+\n+/* Return nonzero if TRIAL, an insn, can be combined with a 'restore'\n+   instruction.  RETURN_P is true if the v9 variant 'return' is to be\n+   considered in the test too.\n \n-  /* The set of insns matched here must agree precisely with the set of\n-     patterns paired with a RETURN in sparc.md.  */\n+   TRIAL must be a SET whose destination is a REG appropriate for the\n+   'restore' instruction or, if RETURN_P is true, for the 'return'\n+   instruction.  */\n \n-  src = SET_SRC (pat);\n+static int\n+eligible_for_restore_insn (rtx trial, bool return_p)\n+{\n+  rtx pat = PATTERN (trial);\n+  rtx src = SET_SRC (pat);\n \n-  /* This matches \"*return_[qhs]i\" or even \"*return_di\" on TARGET_ARCH64.  */\n+  /* The 'restore src,%g0,dest' pattern for word mode and below.  */\n   if (GET_MODE_CLASS (GET_MODE (src)) != MODE_FLOAT\n       && arith_operand (src, GET_MODE (src)))\n     {\n@@ -2848,41 +2823,39 @@ eligible_for_epilogue_delay (rtx trial, int slot)\n         return GET_MODE_SIZE (GET_MODE (src)) <= GET_MODE_SIZE (SImode);\n     }\n \n-  /* This matches \"*return_di\".  */\n+  /* The 'restore src,%g0,dest' pattern for double-word mode.  */\n   else if (GET_MODE_CLASS (GET_MODE (src)) != MODE_FLOAT\n \t   && arith_double_operand (src, GET_MODE (src)))\n     return GET_MODE_SIZE (GET_MODE (src)) <= GET_MODE_SIZE (DImode);\n \n-  /* This matches \"*return_sf_no_fpu\".  */\n-  else if (! TARGET_FPU && restore_operand (SET_DEST (pat), SFmode)\n-\t   && register_operand (src, SFmode))\n+  /* The 'restore src,%g0,dest' pattern for float if no FPU.  */\n+  else if (! TARGET_FPU && register_operand (src, SFmode))\n+    return 1;\n+\n+  /* The 'restore src,%g0,dest' pattern for double if no FPU.  */\n+  else if (! TARGET_FPU && TARGET_ARCH64 && register_operand (src, DFmode))\n     return 1;\n \n-  /* If we have return instruction, anything that does not use\n+  /* If we have the 'return' instruction, anything that does not use\n      local or output registers and can go into a delay slot wins.  */\n-  else if (TARGET_V9 && ! epilogue_renumber (&pat, 1)\n-\t   && (get_attr_in_uncond_branch_delay (trial) == IN_BRANCH_DELAY_TRUE))\n+  else if (return_p && TARGET_V9 && ! epilogue_renumber (&pat, 1)\n+\t   && (get_attr_in_uncond_branch_delay (trial)\n+\t       == IN_UNCOND_BRANCH_DELAY_TRUE))\n     return 1;\n \n-  /* This matches \"*return_addsi\".  */\n+  /* The 'restore src1,src2,dest' pattern for SImode.  */\n   else if (GET_CODE (src) == PLUS\n-\t   && arith_operand (XEXP (src, 0), SImode)\n-\t   && arith_operand (XEXP (src, 1), SImode)\n-\t   && (register_operand (XEXP (src, 0), SImode)\n-\t       || register_operand (XEXP (src, 1), SImode)))\n+\t   && register_operand (XEXP (src, 0), SImode)\n+\t   && arith_operand (XEXP (src, 1), SImode))\n     return 1;\n \n-  /* This matches \"*return_adddi\".  */\n+  /* The 'restore src1,src2,dest' pattern for DImode.  */\n   else if (GET_CODE (src) == PLUS\n-\t   && arith_double_operand (XEXP (src, 0), DImode)\n-\t   && arith_double_operand (XEXP (src, 1), DImode)\n-\t   && (register_operand (XEXP (src, 0), DImode)\n-\t       || register_operand (XEXP (src, 1), DImode)))\n+\t   && register_operand (XEXP (src, 0), DImode)\n+\t   && arith_double_operand (XEXP (src, 1), DImode))\n     return 1;\n \n-  /* This can match \"*return_losum_[sd]i\".\n-     Catch only some cases, so that return_losum* don't have\n-     to be too big.  */\n+  /* The 'restore src1,%lo(src2),dest' pattern.  */\n   else if (GET_CODE (src) == LO_SUM\n \t   && ! TARGET_CM_MEDMID\n \t   && ((register_operand (XEXP (src, 0), SImode)\n@@ -2892,7 +2865,7 @@ eligible_for_epilogue_delay (rtx trial, int slot)\n \t\t   && immediate_operand (XEXP (src, 1), DImode))))\n     return 1;\n \n-  /* sll{,x} reg,1,reg2 is add reg,reg,reg2 as well.  */\n+  /* The 'restore src,src,dest' pattern.  */\n   else if (GET_CODE (src) == ASHIFT\n \t   && (register_operand (XEXP (src, 0), SImode)\n \t       || register_operand (XEXP (src, 0), DImode))\n@@ -2902,39 +2875,64 @@ eligible_for_epilogue_delay (rtx trial, int slot)\n   return 0;\n }\n \n-/* Return nonzero if TRIAL can go into the call delay slot.  */\n+/* Return nonzero if TRIAL can go into the function return's\n+   delay slot.  */\n+\n int\n-tls_call_delay (rtx trial)\n+eligible_for_return_delay (rtx trial)\n {\n-  rtx pat, unspec;\n+  int leaf_function_p = current_function_uses_only_leaf_regs;\n+  rtx pat;\n \n-  /* Binutils allows\n-     call __tls_get_addr, %tgd_call (foo)\n-      add %l7, %o0, %o0, %tgd_add (foo)\n-     while Sun as/ld does not.  */\n-  if (TARGET_GNU_TLS || !TARGET_TLS)\n-    return 1;\n+  if (GET_CODE (trial) != INSN || GET_CODE (PATTERN (trial)) != SET)\n+    return 0;\n+\n+  if (get_attr_length (trial) != 1)\n+    return 0;\n+\n+  /* If there are any call-saved registers, we should scan TRIAL if it\n+     does not reference them.  For now just make it easy.  */\n+  if (num_gfregs)\n+    return 0;\n+\n+  /* If the function uses __builtin_eh_return, the eh_return machinery\n+     occupies the delay slot.  */\n+  if (current_function_calls_eh_return)\n+    return 0;\n+\n+  /* In the case of a true leaf function, anything can go into the slot.  */\n+  if (leaf_function_p)\n+    return get_attr_in_uncond_branch_delay (trial)\n+\t   == IN_UNCOND_BRANCH_DELAY_TRUE;\n \n   pat = PATTERN (trial);\n-  if (GET_CODE (pat) != SET || GET_CODE (SET_DEST (pat)) != PLUS)\n-    return 1;\n \n-  unspec = XEXP (SET_DEST (pat), 1);\n-  if (GET_CODE (unspec) != UNSPEC\n-      || (XINT (unspec, 1) != UNSPEC_TLSGD\n-\t  && XINT (unspec, 1) != UNSPEC_TLSLDM))\n-    return 1;\n+  /* Otherwise, only operations which can be done in tandem with\n+     a `restore' or `return' insn can go into the delay slot.  */\n+  if (GET_CODE (SET_DEST (pat)) != REG\n+      || (REGNO (SET_DEST (pat)) >= 8 && REGNO (SET_DEST (pat)) < 24))\n+    return 0;\n \n-  return 0;\n+  /* If this instruction sets up floating point register and we have a return\n+     instruction, it can probably go in.  But restore will not work\n+     with FP_REGS.  */\n+  if (REGNO (SET_DEST (pat)) >= 32)\n+    return (TARGET_V9\n+\t    && ! epilogue_renumber (&pat, 1)\n+\t    && (get_attr_in_uncond_branch_delay (trial)\n+\t\t== IN_UNCOND_BRANCH_DELAY_TRUE));\n+\n+  return eligible_for_restore_insn (trial, true);\n }\n \n-/* Return nonzero if TRIAL can go into the sibling call\n+/* Return nonzero if TRIAL can go into the sibling call's\n    delay slot.  */\n \n int\n eligible_for_sibcall_delay (rtx trial)\n {\n-  rtx pat, src;\n+  int leaf_function_p = current_function_uses_only_leaf_regs;\n+  rtx pat;\n \n   if (GET_CODE (trial) != INSN || GET_CODE (PATTERN (trial)) != SET)\n     return 0;\n@@ -2944,11 +2942,11 @@ eligible_for_sibcall_delay (rtx trial)\n \n   pat = PATTERN (trial);\n \n-  if (current_function_uses_only_leaf_regs)\n+  if (leaf_function_p)\n     {\n       /* If the tail call is done using the call instruction,\n \t we have to restore %o7 in the delay slot.  */\n-      if ((TARGET_ARCH64 && ! TARGET_CM_MEDLOW) || flag_pic)\n+      if (! SIBCALL_SLOT_EMPTY_P)\n \treturn 0;\n \n       /* %g1 is used to build the function address */\n@@ -2961,7 +2959,7 @@ eligible_for_sibcall_delay (rtx trial)\n   /* Otherwise, only operations which can be done in tandem with\n      a `restore' insn can go into the delay slot.  */\n   if (GET_CODE (SET_DEST (pat)) != REG\n-      || REGNO (SET_DEST (pat)) < 24\n+      || (REGNO (SET_DEST (pat)) >= 8 && REGNO (SET_DEST (pat)) < 24)\n       || REGNO (SET_DEST (pat)) >= 32)\n     return 0;\n \n@@ -2970,89 +2968,7 @@ eligible_for_sibcall_delay (rtx trial)\n   if (reg_mentioned_p (gen_rtx_REG (Pmode, 15), pat))\n     return 0;\n \n-  src = SET_SRC (pat);\n-\n-  if (GET_MODE_CLASS (GET_MODE (src)) != MODE_FLOAT\n-      && arith_operand (src, GET_MODE (src)))\n-    {\n-      if (TARGET_ARCH64)\n-        return GET_MODE_SIZE (GET_MODE (src)) <= GET_MODE_SIZE (DImode);\n-      else\n-        return GET_MODE_SIZE (GET_MODE (src)) <= GET_MODE_SIZE (SImode);\n-    }\n-\n-  else if (GET_MODE_CLASS (GET_MODE (src)) != MODE_FLOAT\n-\t   && arith_double_operand (src, GET_MODE (src)))\n-    return GET_MODE_SIZE (GET_MODE (src)) <= GET_MODE_SIZE (DImode);\n-\n-  else if (! TARGET_FPU && restore_operand (SET_DEST (pat), SFmode)\n-\t   && register_operand (src, SFmode))\n-    return 1;\n-\n-  else if (GET_CODE (src) == PLUS\n-\t   && arith_operand (XEXP (src, 0), SImode)\n-\t   && arith_operand (XEXP (src, 1), SImode)\n-\t   && (register_operand (XEXP (src, 0), SImode)\n-\t       || register_operand (XEXP (src, 1), SImode)))\n-    return 1;\n-\n-  else if (GET_CODE (src) == PLUS\n-\t   && arith_double_operand (XEXP (src, 0), DImode)\n-\t   && arith_double_operand (XEXP (src, 1), DImode)\n-\t   && (register_operand (XEXP (src, 0), DImode)\n-\t       || register_operand (XEXP (src, 1), DImode)))\n-    return 1;\n-\n-  else if (GET_CODE (src) == LO_SUM\n-\t   && ! TARGET_CM_MEDMID\n-\t   && ((register_operand (XEXP (src, 0), SImode)\n-\t        && immediate_operand (XEXP (src, 1), SImode))\n-\t       || (TARGET_ARCH64\n-\t\t   && register_operand (XEXP (src, 0), DImode)\n-\t\t   && immediate_operand (XEXP (src, 1), DImode))))\n-    return 1;\n-\n-  else if (GET_CODE (src) == ASHIFT\n-\t   && (register_operand (XEXP (src, 0), SImode)\n-\t       || register_operand (XEXP (src, 0), DImode))\n-\t   && XEXP (src, 1) == const1_rtx)\n-    return 1;\n-\n-  return 0;\n-}\n-\n-static int\n-check_return_regs (rtx x)\n-{\n-  switch (GET_CODE (x))\n-    {\n-    case REG:\n-      return IN_OR_GLOBAL_P (x);\n-\n-    case CONST_INT:\n-    case CONST_DOUBLE:\n-    case CONST:\n-    case SYMBOL_REF:\n-    case LABEL_REF:\n-    return 1;\n-\n-    case SET:\n-    case IOR:\n-    case AND:\n-    case XOR:\n-    case PLUS:\n-    case MINUS:\n-      if (check_return_regs (XEXP (x, 1)) == 0)\n-  return 0;\n-    case NOT:\n-    case NEG:\n-    case MEM:\n-      return check_return_regs (XEXP (x, 0));\n-      \n-    default:\n-      return 0;\n-    }\n-\n+  return eligible_for_restore_insn (trial, false);\n }\n \n int\n@@ -3722,17 +3638,14 @@ legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED, enum machine_mode mode)\n   return x;\n }\n \n-/* Emit special PIC prologues.  */\n+/* Emit the special PIC prologue.  */\n \n-void\n+static void\n load_pic_register (void)\n {\n   /* Labels to get the PC in the prologue of this function.  */\n   int orig_flag_pic = flag_pic;\n \n-  if (! flag_pic)\n-    abort ();\n-\n   /* If we haven't emitted the special get_pc helper function, do so now.  */\n   if (get_pc_symbol_name[0] == 0)\n     {\n@@ -4033,128 +3946,16 @@ sparc_init_modes (void)\n     }\n }\n \f\n-/* Save non call used registers from LOW to HIGH at BASE+OFFSET.\n-   N_REGS is the number of 4-byte regs saved thus far.  This applies even to\n-   v9 int regs as it simplifies the code.  */\n-\n-static int\n-save_regs (FILE *file, int low, int high, const char *base,\n-\t   int offset, int n_regs, HOST_WIDE_INT real_offset)\n-{\n-  int i;\n-\n-  if (TARGET_ARCH64 && high <= 32)\n-    {\n-      for (i = low; i < high; i++)\n-\t{\n-\t  if (regs_ever_live[i] && ! call_used_regs[i])\n-\t    {\n-\t      fprintf (file, \"\\tstx\\t%s, [%s+%d]\\n\",\n-\t\t       reg_names[i], base, offset + 4 * n_regs);\n-\t      if (dwarf2out_do_frame ())\n-\t\tdwarf2out_reg_save (\"\", i, real_offset + 4 * n_regs);\n-\t      n_regs += 2;\n-\t    }\n-\t}\n-    }\n-  else\n-    {\n-      for (i = low; i < high; i += 2)\n-\t{\n-\t  if (regs_ever_live[i] && ! call_used_regs[i])\n-\t    {\n-\t      if (regs_ever_live[i+1] && ! call_used_regs[i+1])\n-\t\t{\n-\t\t  fprintf (file, \"\\tstd\\t%s, [%s+%d]\\n\",\n-\t\t\t   reg_names[i], base, offset + 4 * n_regs);\n-\t\t  if (dwarf2out_do_frame ())\n-\t\t    {\n-\t\t      char *l = dwarf2out_cfi_label ();\n-\t\t      dwarf2out_reg_save (l, i, real_offset + 4 * n_regs);\n-\t\t      dwarf2out_reg_save (l, i+1, real_offset + 4 * n_regs + 4);\n-\t\t    }\n-\t\t  n_regs += 2;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  fprintf (file, \"\\tst\\t%s, [%s+%d]\\n\",\n-\t\t\t   reg_names[i], base, offset + 4 * n_regs);\n-\t\t  if (dwarf2out_do_frame ())\n-\t\t    dwarf2out_reg_save (\"\", i, real_offset + 4 * n_regs);\n-\t\t  n_regs += 2;\n-\t\t}\n-\t    }\n-\t  else\n-\t    {\n-\t      if (regs_ever_live[i+1] && ! call_used_regs[i+1])\n-\t\t{\n-\t\t  fprintf (file, \"\\tst\\t%s, [%s+%d]\\n\",\n-\t\t\t   reg_names[i+1], base, offset + 4 * n_regs + 4);\n-\t\t  if (dwarf2out_do_frame ())\n-\t\t    dwarf2out_reg_save (\"\", i + 1, real_offset + 4 * n_regs + 4);\n-\t\t  n_regs += 2;\n-\t\t}\n-\t    }\n-\t}\n-    }\n-  return n_regs;\n-}\n-\n-/* Restore non call used registers from LOW to HIGH at BASE+OFFSET.\n-\n-   N_REGS is the number of 4-byte regs saved thus far.  This applies even to\n-   v9 int regs as it simplifies the code.  */\n-\n-static int\n-restore_regs (FILE *file, int low, int high, const char *base,\n-\t      int offset, int n_regs)\n-{\n-  int i;\n-\n-  if (TARGET_ARCH64 && high <= 32)\n-    {\n-      for (i = low; i < high; i++)\n-\t{\n-\t  if (regs_ever_live[i] && ! call_used_regs[i])\n-\t    fprintf (file, \"\\tldx\\t[%s+%d], %s\\n\",\n-\t      base, offset + 4 * n_regs, reg_names[i]),\n-\t    n_regs += 2;\n-\t}\n-    }\n-  else\n-    {\n-      for (i = low; i < high; i += 2)\n-\t{\n-\t  if (regs_ever_live[i] && ! call_used_regs[i])\n-\t    if (regs_ever_live[i+1] && ! call_used_regs[i+1])\n-\t      fprintf (file, \"\\tldd\\t[%s+%d], %s\\n\",\n-\t\t       base, offset + 4 * n_regs, reg_names[i]),\n-\t      n_regs += 2;\n-\t    else\n-\t      fprintf (file, \"\\tld\\t[%s+%d], %s\\n\",\n-\t\t       base, offset + 4 * n_regs, reg_names[i]),\n-\t      n_regs += 2;\n-\t  else if (regs_ever_live[i+1] && ! call_used_regs[i+1])\n-\t    fprintf (file, \"\\tld\\t[%s+%d], %s\\n\",\n-\t\t     base, offset + 4 * n_regs + 4, reg_names[i+1]),\n-\t    n_regs += 2;\n-\t}\n-    }\n-  return n_regs;\n-}\n-\n /* Compute the frame size required by the function.  This function is called\n-   during the reload pass and also by output_function_prologue().  */\n+   during the reload pass and also by sparc_expand_prologue.  */\n \n HOST_WIDE_INT\n-compute_frame_size (HOST_WIDE_INT size, int leaf_function)\n+sparc_compute_frame_size (HOST_WIDE_INT size, int leaf_function_p)\n {\n-  int n_regs = 0, i;\n   int outgoing_args_size = (current_function_outgoing_args_size\n \t\t\t    + REG_PARM_STACK_SPACE (current_function_decl));\n-\n-  /* N_REGS is the number of 4-byte regs saved thus far.  This applies\n-     even to v9 int regs to be consistent with save_regs/restore_regs.  */\n+  int n_regs = 0;  /* N_REGS is the number of 4-byte regs saved thus far.  */\n+  int i;\n \n   if (TARGET_ARCH64)\n     {\n@@ -4175,14 +3976,14 @@ compute_frame_size (HOST_WIDE_INT size, int leaf_function)\n \t|| (regs_ever_live[i+1] && ! call_used_regs[i+1]))\n       n_regs += 2;\n \n-  /* Set up values for use in `function_epilogue'.  */\n+  /* Set up values for use in prologue and epilogue.  */\n   num_gfregs = n_regs;\n \n-  if (leaf_function && n_regs == 0\n-      && size == 0 && current_function_outgoing_args_size == 0)\n-    {\n-      actual_fsize = apparent_fsize = 0;\n-    }\n+  if (leaf_function_p\n+      && n_regs == 0\n+      && size == 0\n+      && current_function_outgoing_args_size == 0)\n+    actual_fsize = apparent_fsize = 0;\n   else\n     {\n       /* We subtract STARTING_FRAME_OFFSET, remember it's negative.  */\n@@ -4195,108 +3996,16 @@ compute_frame_size (HOST_WIDE_INT size, int leaf_function)\n      If a SAVE must be done, or there is a stack-local variable,\n      the register window area must be allocated.\n      ??? For v8 we apparently need an additional 8 bytes of reserved space.  */\n-  if (leaf_function == 0 || size > 0)\n+  if (! leaf_function_p || size > 0)\n     actual_fsize += (16 * UNITS_PER_WORD) + (TARGET_ARCH64 ? 0 : 8);\n \n   return SPARC_STACK_ALIGN (actual_fsize);\n }\n \n-/* Build big number NUM in register REG and output the result to FILE.\n-   REG is guaranteed to be the only clobbered register.  The function\n-   will very likely emit several instructions, so it must not be called\n-   from within a delay slot.  */\n+/* Output any necessary .register pseudo-ops.  */\n \n-static void\n-build_big_number (FILE *file, HOST_WIDE_INT num, const char *reg)\n-{\n-#if HOST_BITS_PER_WIDE_INT == 64\n-  HOST_WIDE_INT high_bits = (num >> 32) & 0xffffffff;\n-\n-  if (high_bits == 0\n-#else\n-  if (num >= 0\n-#endif\n-      || ! TARGET_ARCH64)\n-    {\n-      /* We don't use the 'set' macro because it appears to be broken\n-\t in the Solaris 7 assembler.  */\n-      fprintf (file, \"\\tsethi\\t%%hi(\"HOST_WIDE_INT_PRINT_DEC\"), %s\\n\",\n-\t       num, reg);\n-      if ((num & 0x3ff) != 0)\n-\tfprintf (file, \"\\tor\\t%s, %%lo(\"HOST_WIDE_INT_PRINT_DEC\"), %s\\n\",\n-\t\t reg, num, reg);\n-    }\n-#if HOST_BITS_PER_WIDE_INT == 64\n-  else if (high_bits == 0xffffffff) /* && TARGET_ARCH64 */\n-#else\n-  else /* num < 0 && TARGET_ARCH64 */\n-#endif\n-    {\n-      /* Sethi does not sign extend, so we must use a little trickery\n-\t to use it for negative numbers.  Invert the constant before\n-\t loading it in, then use xor immediate to invert the loaded bits\n-\t (along with the upper 32 bits) to the desired constant.  This\n-\t works because the sethi and immediate fields overlap.  */\n-      HOST_WIDE_INT inv = ~num;\n-      HOST_WIDE_INT low = -0x400 + (num & 0x3ff);\n-\t  \n-      fprintf (file, \"\\tsethi\\t%%hi(\"HOST_WIDE_INT_PRINT_DEC\"), %s\\n\",\n-\t       inv, reg);\n-      fprintf (file, \"\\txor\\t%s, \"HOST_WIDE_INT_PRINT_DEC\", %s\\n\",\n-\t       reg, low, reg);\n-    }\n-#if HOST_BITS_PER_WIDE_INT == 64\n-  else /* TARGET_ARCH64 */\n-    {\n-      /* We don't use the 'setx' macro because if requires a scratch register.\n-         This is the translation of sparc_emit_set_const64_longway into asm.\n-         Hopefully we will soon have prologue/epilogue emitted as RTL.  */\n-      HOST_WIDE_INT low1 = (num >> (32 - 12))          & 0xfff;\n-      HOST_WIDE_INT low2 = (num >> (32 - 12 - 12))     & 0xfff;\n-      HOST_WIDE_INT low3 = (num >> (32 - 12 - 12 - 8)) & 0x0ff;\n-      int to_shift = 12;\n-\n-      /* We don't use the 'set' macro because it appears to be broken\n-\t in the Solaris 7 assembler.  */\n-      fprintf (file, \"\\tsethi\\t%%hi(\"HOST_WIDE_INT_PRINT_DEC\"), %s\\n\",\n-\t       high_bits, reg);\n-      if ((high_bits & 0x3ff) != 0)\n-\tfprintf (file, \"\\tor\\t%s, %%lo(\"HOST_WIDE_INT_PRINT_DEC\"), %s\\n\",\n-\t\t reg, high_bits, reg);\n-\n-      if (low1 != 0)\n-\t{\n-\t  fprintf (file, \"\\tsllx\\t%s, %d, %s\\n\", reg, to_shift, reg);\n-\t  fprintf (file, \"\\tor\\t%s, \"HOST_WIDE_INT_PRINT_DEC\", %s\\n\",\n-\t\t   reg, low1, reg);\n-\t  to_shift = 12;\n-\t}\n-      else\n-\t{\n-\t  to_shift += 12;\n-\t}\n-      if (low2 != 0)\n-\t{\n-\t  fprintf (file, \"\\tsllx\\t%s, %d, %s\\n\", reg, to_shift, reg);\n-\t  fprintf (file, \"\\tor\\t%s, \"HOST_WIDE_INT_PRINT_DEC\", %s\\n\",\n-\t\t   reg, low2, reg);\n-\t  to_shift = 8;\n-\t}\n-      else\n-\t{\n-\t  to_shift += 8;\n-\t}\n-      fprintf (file, \"\\tsllx\\t%s, %d, %s\\n\", reg, to_shift, reg);\n-      if (low3 != 0)\n-\tfprintf (file, \"\\tor\\t%s, \"HOST_WIDE_INT_PRINT_DEC\", %s\\n\",\n-\t\t reg, low3, reg);\n-    }\n-#endif\n-}\n-\n-/* Output any necessary .register pseudo-ops.  */\n-void\n-sparc_output_scratch_registers (FILE *file ATTRIBUTE_UNUSED)\n+void\n+sparc_output_scratch_registers (FILE *file ATTRIBUTE_UNUSED)\n {\n #ifdef HAVE_AS_REGISTER_PSEUDO_OP\n   int i;\n@@ -4319,101 +4028,260 @@ sparc_output_scratch_registers (FILE *file ATTRIBUTE_UNUSED)\n #endif\n }\n \n-/* This function generates the assembly code for function entry.\n-   FILE is a stdio stream to output the code to.\n-   SIZE is an int: how many units of temporary storage to allocate.\n-   Refer to the array `regs_ever_live' to determine which registers\n-   to save; `regs_ever_live[I]' is nonzero if register number I\n-   is ever used in the function.  This macro is responsible for\n-   knowing which registers should not be saved even if used.  */\n+/* Save/restore call-saved registers from LOW to HIGH at BASE+OFFSET\n+   as needed.  LOW should be double-word aligned for 32-bit registers.\n+   Return the new OFFSET.  */\n+\n+#define SORR_SAVE    0\n+#define SORR_RESTORE 1\n+\n+static int\n+save_or_restore_regs (int low, int high, rtx base, int offset, int action)\n+{\n+  rtx mem, insn;\n+  int i;\n+\n+  if (TARGET_ARCH64 && high <= 32)\n+    {\n+      for (i = low; i < high; i++)\n+\t{\n+\t  if (regs_ever_live[i] && ! call_used_regs[i])\n+\t    {\n+\t      mem = gen_rtx_MEM (DImode, plus_constant (base, offset));\n+\t      set_mem_alias_set (mem, sparc_sr_alias_set);\n+\t      if (action == SORR_SAVE)\n+\t\t{\n+\t\t  insn = emit_move_insn (mem, gen_rtx_REG (DImode, i));\n+\t\t  RTX_FRAME_RELATED_P (insn) = 1;\n+\t\t}\n+\t      else  /* action == SORR_RESTORE */\n+\t\temit_move_insn (gen_rtx_REG (DImode, i), mem);\n+\t      offset += 8;\n+\t    }\n+\t}\n+    }\n+  else\n+    {\n+      for (i = low; i < high; i += 2)\n+\t{\n+\t  bool reg0 = regs_ever_live[i] && ! call_used_regs[i];\n+\t  bool reg1 = regs_ever_live[i+1] && ! call_used_regs[i+1];\n+\t  enum machine_mode mode;\n+\t  int regno;\n+\n+\t  if (reg0 && reg1)\n+\t    {\n+\t      mode = i < 32 ? DImode : DFmode;\n+\t      regno = i;\n+\t    }\n+\t  else if (reg0)\n+\t    {\n+\t      mode = i < 32 ? SImode : SFmode;\n+\t      regno = i;\n+\t    }\n+\t  else if (reg1)\n+\t    {\n+\t      mode = i < 32 ? SImode : SFmode;\n+\t      regno = i + 1;\n+\t      offset += 4;\n+\t    }\n+\t  else\n+\t    continue;\n+\n+\t  mem = gen_rtx_MEM (mode, plus_constant (base, offset));\n+\t  set_mem_alias_set (mem, sparc_sr_alias_set);\n+\t  if (action == SORR_SAVE)\n+\t    {\n+\t      insn = emit_move_insn (mem, gen_rtx_REG (mode, regno));\n+\t      RTX_FRAME_RELATED_P (insn) = 1;\n+\t    }\n+\t  else  /* action == SORR_RESTORE */\n+\t    emit_move_insn (gen_rtx_REG (mode, regno), mem);\n+\n+\t  /* Always preserve double-word alignment.  */\n+\t  offset = (offset + 7) & -8;\n+\t}\n+    }\n+\n+  return offset;\n+}\n+\n+/* Emit code to save call-saved registers.  */\n+\n+static void\n+emit_save_regs (void)\n+{\n+  HOST_WIDE_INT offset;\n+  rtx base;\n+\n+  offset = frame_base_offset - apparent_fsize;\n+\n+  if (offset < -4096 || offset + num_gfregs * 4 > 4096)\n+    {\n+      /* ??? This might be optimized a little as %g1 might already have a\n+\t value close enough that a single add insn will do.  */\n+      /* ??? Although, all of this is probably only a temporary fix\n+\t because if %g1 can hold a function result, then\n+\t sparc_expand_epilogue will lose (the result will be\n+\t clobbered).  */\n+      base = gen_rtx_REG (Pmode, 1);\n+      emit_move_insn (base, GEN_INT (offset));\n+      emit_insn (gen_rtx_SET (VOIDmode,\n+\t\t\t      base,\n+\t\t\t      gen_rtx_PLUS (Pmode, frame_base_reg, base)));\n+      offset = 0;\n+    }\n+  else\n+    base = frame_base_reg;\n \n-/* On SPARC, move-double insns between fpu and cpu need an 8-byte block\n-   of memory.  If any fpu reg is used in the function, we allocate\n-   such a block here, at the bottom of the frame, just in case it's needed.\n+  offset = save_or_restore_regs (0, 8, base, offset, SORR_SAVE);\n+  save_or_restore_regs (32, TARGET_V9 ? 96 : 64, base, offset, SORR_SAVE);\n+}\n \n-   If this function is a leaf procedure, then we may choose not\n-   to do a \"save\" insn.  The decision about whether or not\n-   to do this is made in regclass.c.  */\n+/* Emit code to restore call-saved registers.  */\n \n static void\n-sparc_output_function_prologue (FILE *file, HOST_WIDE_INT size)\n+emit_restore_regs (void)\n {\n-  sparc_function_prologue (file, size,\n-\t\t\t   current_function_uses_only_leaf_regs);\n+  HOST_WIDE_INT offset;\n+  rtx base;\n+\n+  offset = frame_base_offset - apparent_fsize;\n+\n+  if (offset < -4096 || offset + num_gfregs * 4 > 4096 - 8 /*double*/)\n+    {\n+      base = gen_rtx_REG (Pmode, 1);\n+      emit_move_insn (base, GEN_INT (offset));\n+      emit_insn (gen_rtx_SET (VOIDmode,\n+\t\t\t      base,\n+\t\t\t      gen_rtx_PLUS (Pmode, frame_base_reg, base)));\n+      offset = 0;\n+    }\n+  else\n+    base = frame_base_reg;\n+\n+  offset = save_or_restore_regs (0, 8, base, offset, SORR_RESTORE);\n+  save_or_restore_regs (32, TARGET_V9 ? 96 : 64, base, offset, SORR_RESTORE);\n }\n \n-/* Output code for the function prologue.  */\n+/* Emit an increment for the stack pointer.  */\n \n static void\n-sparc_function_prologue (FILE *file, HOST_WIDE_INT size, int leaf_function)\n+emit_stack_pointer_increment (rtx increment)\n {\n-  sparc_output_scratch_registers (file);\n+  if (TARGET_ARCH64)\n+    emit_insn (gen_adddi3 (stack_pointer_rtx, stack_pointer_rtx, increment));\n+  else\n+    emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx, increment));\n+}\n+\n+/* Emit a decrement for the stack pointer.  */\n+\n+static void\n+emit_stack_pointer_decrement (rtx decrement)\n+{\n+  if (TARGET_ARCH64)\n+    emit_insn (gen_subdi3 (stack_pointer_rtx, stack_pointer_rtx, decrement));\n+  else\n+    emit_insn (gen_subsi3 (stack_pointer_rtx, stack_pointer_rtx, decrement));\n+}\n+\n+/* Expand the function prologue.  The prologue is responsible for reserving\n+   storage for the frame, saving the call-saved registers and loading the\n+   PIC register if needed.  */\n+\n+void\n+sparc_expand_prologue (void)\n+{\n+  int leaf_function_p = current_function_uses_only_leaf_regs;\n \n   /* Need to use actual_fsize, since we are also allocating\n      space for our callee (and our own register save area).  */\n-  actual_fsize = compute_frame_size (size, leaf_function);\n+  actual_fsize = sparc_compute_frame_size (get_frame_size(), leaf_function_p);\n \n-  if (leaf_function)\n+  if (leaf_function_p)\n     {\n-      frame_base_name = \"%sp\";\n+      frame_base_reg = stack_pointer_rtx;\n       frame_base_offset = actual_fsize + SPARC_STACK_BIAS;\n     }\n   else\n     {\n-      frame_base_name = \"%fp\";\n+      frame_base_reg = hard_frame_pointer_rtx;\n       frame_base_offset = SPARC_STACK_BIAS;\n     }\n \n-  /* This is only for the human reader.  */\n-  fprintf (file, \"\\t%s#PROLOGUE# 0\\n\", ASM_COMMENT_START);\n-\n   if (actual_fsize == 0)\n     /* do nothing.  */ ;\n-  else if (! leaf_function)\n+  else if (leaf_function_p)\n     {\n       if (actual_fsize <= 4096)\n-\tfprintf (file, \"\\tsave\\t%%sp, -\"HOST_WIDE_INT_PRINT_DEC\", %%sp\\n\",\n-\t\t actual_fsize);\n+\temit_stack_pointer_increment (GEN_INT (- actual_fsize));\n       else if (actual_fsize <= 8192)\n \t{\n-\t  fprintf (file, \"\\tsave\\t%%sp, -4096, %%sp\\n\");\n-\t  fprintf (file, \"\\tadd\\t%%sp, -\"HOST_WIDE_INT_PRINT_DEC\", %%sp\\n\",\n-\t\t   actual_fsize - 4096);\n+\t  emit_stack_pointer_increment (GEN_INT (-4096));\n+\t  emit_stack_pointer_increment (GEN_INT (4096 - actual_fsize));\n \t}\n       else\n \t{\n-\t  build_big_number (file, -actual_fsize, \"%g1\");\n-\t  fprintf (file, \"\\tsave\\t%%sp, %%g1, %%sp\\n\");\n+\t  rtx reg = gen_rtx_REG (Pmode, 1);\n+\t  emit_move_insn (reg, GEN_INT (-actual_fsize));\n+\t  emit_stack_pointer_increment (reg);\n \t}\n     }\n-  else /* leaf function */\n+  else\n     {\n       if (actual_fsize <= 4096)\n-\tfprintf (file, \"\\tadd\\t%%sp, -\"HOST_WIDE_INT_PRINT_DEC\", %%sp\\n\",\n-\t\t actual_fsize);\n+        emit_insn (gen_save_register_window (GEN_INT (-actual_fsize)));\n       else if (actual_fsize <= 8192)\n \t{\n-\t  fprintf (file, \"\\tadd\\t%%sp, -4096, %%sp\\n\");\n-\t  fprintf (file, \"\\tadd\\t%%sp, -\"HOST_WIDE_INT_PRINT_DEC\", %%sp\\n\",\n-\t\t   actual_fsize - 4096);\n+\t  emit_insn (gen_save_register_window (GEN_INT (-4096)));\n+\t  emit_stack_pointer_increment (GEN_INT (4096 - actual_fsize));\n \t}\n       else\n \t{\n-\t  build_big_number (file, -actual_fsize, \"%g1\");\n-\t  fprintf (file, \"\\tadd\\t%%sp, %%g1, %%sp\\n\");\n+\t  rtx reg = gen_rtx_REG (Pmode, 1);\n+\t  emit_move_insn (reg, GEN_INT (-actual_fsize));\n+\t  emit_insn (gen_save_register_window (reg));\n \t}\n     }\n \n+  /* Call-saved registers are saved just above the outgoing argument area.  */\n+  if (num_gfregs)\n+    emit_save_regs ();\n+\n+  /* Load the PIC register if needed.  */\n+  if (flag_pic && current_function_uses_pic_offset_table)\n+    load_pic_register ();\n+}\n+ \n+/* This function generates the assembly code for function entry, which boils\n+   down to emitting the necessary .register directives.  It also informs the\n+   DWARF-2 back-end on the layout of the frame.\n+\n+   ??? Historical cruft: \"On SPARC, move-double insns between fpu and cpu need\n+   an 8-byte block of memory.  If any fpu reg is used in the function, we\n+   allocate such a block here, at the bottom of the frame, just in case it's\n+   needed.\"  Could this explain the -8 in emit_restore_regs?  */\n+\n+static void\n+sparc_asm_function_prologue (FILE *file, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n+{\n+  int leaf_function_p = current_function_uses_only_leaf_regs;\n+\n+  sparc_output_scratch_registers (file);\n+\n   if (dwarf2out_do_frame () && actual_fsize)\n     {\n       char *label = dwarf2out_cfi_label ();\n \n       /* The canonical frame address refers to the top of the frame.  */\n-      dwarf2out_def_cfa (label, (leaf_function ? STACK_POINTER_REGNUM\n-\t\t\t\t : HARD_FRAME_POINTER_REGNUM),\n+      dwarf2out_def_cfa (label,\n+\t\t\t leaf_function_p\n+\t\t\t ? STACK_POINTER_REGNUM\n+\t\t\t : HARD_FRAME_POINTER_REGNUM,\n \t\t\t frame_base_offset);\n \n-      if (! leaf_function)\n+      if (! leaf_function_p)\n \t{\n \t  /* Note the register window save.  This tells the unwinder that\n \t     it needs to restore the window registers from the previous\n@@ -4424,368 +4292,283 @@ sparc_function_prologue (FILE *file, HOST_WIDE_INT size, int leaf_function)\n \t  dwarf2out_return_reg (label, 31);\n \t}\n     }\n+}\n \n-  /* If doing anything with PIC, do it now.  */\n-  if (! flag_pic)\n-    fprintf (file, \"\\t%s#PROLOGUE# 1\\n\", ASM_COMMENT_START);\n+/* Expand the function epilogue, either normal or part of a sibcall.\n+   We emit all the instructions except the return or the call.  */\n+\n+void\n+sparc_expand_epilogue (void)\n+{\n+  int leaf_function_p = current_function_uses_only_leaf_regs;\n \n-  /* Call saved registers are saved just above the outgoing argument area.  */\n   if (num_gfregs)\n-    {\n-      HOST_WIDE_INT offset, real_offset;\n-      int n_regs;\n-      const char *base;\n+    emit_restore_regs ();\n \n-      real_offset = -apparent_fsize;\n-      offset = -apparent_fsize + frame_base_offset;\n-      if (offset < -4096 || offset + num_gfregs * 4 > 4096)\n+  if (actual_fsize == 0)\n+    /* do nothing.  */ ;\n+  else if (leaf_function_p)\n+    {\n+      if (actual_fsize <= 4096)\n+\temit_stack_pointer_decrement (GEN_INT (- actual_fsize));\n+      else if (actual_fsize <= 8192)\n \t{\n-\t  /* ??? This might be optimized a little as %g1 might already have a\n-\t     value close enough that a single add insn will do.  */\n-\t  /* ??? Although, all of this is probably only a temporary fix\n-\t     because if %g1 can hold a function result, then\n-\t     output_function_epilogue will lose (the result will get\n-\t     clobbered).  */\n-\t  build_big_number (file, offset, \"%g1\");\n-\t  fprintf (file, \"\\tadd\\t%s, %%g1, %%g1\\n\", frame_base_name);\n-\t  base = \"%g1\";\n-\t  offset = 0;\n+\t  emit_stack_pointer_decrement (GEN_INT (-4096));\n+\t  emit_stack_pointer_decrement (GEN_INT (4096 - actual_fsize));\n \t}\n       else\n \t{\n-\t  base = frame_base_name;\n+\t  rtx reg = gen_rtx_REG (Pmode, 1);\n+\t  emit_move_insn (reg, GEN_INT (-actual_fsize));\n+\t  emit_stack_pointer_decrement (reg);\n \t}\n-\n-      n_regs = save_regs (file, 0, 8, base, offset, 0, real_offset);\n-      save_regs (file, 32, TARGET_V9 ? 96 : 64, base, offset, n_regs,\n-\t\t real_offset);\n     }\n }\n+  \n+/* This function generates the assembly code for function exit.  */\n+  \n+static void\n+sparc_asm_function_epilogue (FILE *file, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n+{\n+  /* If code does not drop into the epilogue, we have to still output\n+     a dummy nop for the sake of sane backtraces.  Otherwise, if the\n+     last two instructions of a function were \"call foo; dslot;\" this\n+     can make the return PC of foo (ie. address of call instruction\n+     plus 8) point to the first instruction in the next function.  */\n+\n+  rtx insn, last_real_insn;\n+\n+  insn = get_last_insn ();\n+\n+  last_real_insn = prev_real_insn (insn);\n+  if (last_real_insn\n+      && GET_CODE (last_real_insn) == INSN\n+      && GET_CODE (PATTERN (last_real_insn)) == SEQUENCE)\n+    last_real_insn = XVECEXP (PATTERN (last_real_insn), 0, 0);\n \n-/* Output code to restore any call saved registers.  */\n+  if (last_real_insn && GET_CODE (last_real_insn) == CALL_INSN)\n+    fputs(\"\\tnop\\n\", file);\n \n+  sparc_output_deferred_case_vectors ();\n+}\n+  \n+/* Output a 'restore' instruction.  */\n+ \n static void\n-output_restore_regs (FILE *file, int leaf_function ATTRIBUTE_UNUSED)\n+output_restore (rtx insn)\n {\n-  HOST_WIDE_INT offset;\n-  int n_regs;\n-  const char *base;\n+  rtx operands[3], pat;\n \n-  offset = -apparent_fsize + frame_base_offset;\n-  if (offset < -4096 || offset + num_gfregs * 4 > 4096 - 8 /*double*/)\n-    {\n-      build_big_number (file, offset, \"%g1\");\n-      fprintf (file, \"\\tadd\\t%s, %%g1, %%g1\\n\", frame_base_name);\n-      base = \"%g1\";\n-      offset = 0;\n-    }\n-  else\n+  if (! insn)\n     {\n-      base = frame_base_name;\n+      fputs (\"\\t restore\\n\", asm_out_file);\n+      return;\n     }\n \n-  n_regs = restore_regs (file, 0, 8, base, offset, 0);\n-  restore_regs (file, 32, TARGET_V9 ? 96 : 64, base, offset, n_regs);\n-}\n-\n-/* This function generates the assembly code for function exit,\n-   on machines that need it.\n+  pat = PATTERN (insn);\n+  if (GET_CODE (pat) != SET)\n+    abort ();\n \n-   The function epilogue should not depend on the current stack pointer!\n-   It should use the frame pointer only.  This is mandatory because\n-   of alloca; we also take advantage of it to omit stack adjustments\n-   before returning.  */\n+  operands[0] = SET_DEST (pat);\n+  pat = SET_SRC (pat);\n \n-static void\n-sparc_output_function_epilogue (FILE *file, HOST_WIDE_INT size)\n-{\n-  sparc_function_epilogue (file, size,\n-\t\t\t   current_function_uses_only_leaf_regs);\n+  switch (GET_CODE (pat))\n+    {\n+      case PLUS:\n+\toperands[1] = XEXP (pat, 0);\n+\toperands[2] = XEXP (pat, 1);\n+\toutput_asm_insn (\" restore %r1, %2, %Y0\", operands);\n+\tbreak;\n+      case LO_SUM:\n+\toperands[1] = XEXP (pat, 0);\n+\toperands[2] = XEXP (pat, 1);\n+\toutput_asm_insn (\" restore %r1, %%lo(%a2), %Y0\", operands);\n+\tbreak;\n+      case ASHIFT:\n+\toperands[1] = XEXP (pat, 0);\n+\tif (XEXP (pat, 1) != const1_rtx)\n+\t  abort();\n+\toutput_asm_insn (\" restore %r1, %r1, %Y0\", operands);\n+\tbreak;\n+      default:\n+\toperands[1] = pat;\n+\toutput_asm_insn (\" restore %%g0, %1, %Y0\", operands);\n+\tbreak;\n+    }\n }\n+  \n+/* Output a return.  */\n \n-/* Output code for the function epilogue.  */\n-\n-static void\n-sparc_function_epilogue (FILE *file,\n-\t\t\t HOST_WIDE_INT size ATTRIBUTE_UNUSED,\n-\t\t\t int leaf_function)\n+const char *\n+output_return (rtx insn)\n {\n-  const char *ret;\n-\n+  int leaf_function_p = current_function_uses_only_leaf_regs;\n+  bool delay_slot_filled_p = dbr_sequence_length () > 0;\n   /* True if the caller has placed an \"unimp\" insn immediately after the call.\n      This insn is used in the 32-bit ABI when calling a function that returns\n      a non zero-sized structure. The 64-bit ABI doesn't have it.  Be careful\n      to have this test be the same as that used on the call.  */\n-  sparc_skip_caller_unimp\n+  bool sparc_skip_caller_unimp\n     = ! TARGET_ARCH64\n       && current_function_returns_struct\n       && (TREE_CODE (DECL_SIZE (DECL_RESULT (current_function_decl)))\n \t  == INTEGER_CST)\n       && ! integer_zerop (DECL_SIZE (DECL_RESULT (current_function_decl)));\n \n-  if (current_function_epilogue_delay_list == 0)\n+  if (leaf_function_p)\n     {\n-      /* If code does not drop into the epilogue, we need\n-\t do nothing except output pending case vectors.\n-\n-\t We have to still output a dummy nop for the sake of\n-\t sane backtraces.  Otherwise, if the last two instructions\n-\t of a function were call foo; dslot; this can make the return\n-\t PC of foo (ie. address of call instruction plus 8) point to\n-\t the first instruction in the next function.  */\n-      rtx insn, last_real_insn;\n+      /* This is a leaf function so we don't have to bother restoring the\n+\t register window, which frees us from dealing with the convoluted\n+\t semantics of restore/return.  We simply output the jump to the\n+\t return address and the insn in the delay slot, which usually is\n+\t the substraction restoring the stack pointer %sp.  */\n \n-      insn = get_last_insn ();\n+      if (current_function_calls_eh_return)\n+\tabort ();\n \n-      last_real_insn = prev_real_insn (insn);\n-      if (last_real_insn\n-\t  && GET_CODE (last_real_insn) == INSN\n-\t  && GET_CODE (PATTERN (last_real_insn)) == SEQUENCE)\n-\tlast_real_insn = XVECEXP (PATTERN (last_real_insn), 0, 0);\n+      fprintf (asm_out_file, \"\\tjmp\\t%%o7+%d\\n\", sparc_skip_caller_unimp ? 12 : 8);\n \n-      if (last_real_insn && GET_CODE (last_real_insn) == CALL_INSN)\n-\tfputs(\"\\tnop\\n\", file);\n+      if (delay_slot_filled_p)\n+\t{\n+\t  rtx delay = NEXT_INSN (insn);\n+\t  if (! delay)\n+\t    abort ();\n \n-      if (GET_CODE (insn) == NOTE)\n-\t      insn = prev_nonnote_insn (insn);\n-      if (insn && GET_CODE (insn) == BARRIER)\n-\t      goto output_vectors;\n+\t  final_scan_insn (delay, asm_out_file, 1, 0, 1, NULL);\n+\t  PATTERN (delay) = gen_blockage ();\n+\t  INSN_CODE (delay) = -1;\n+\t}\n+      else\n+\tfputs (\"\\t nop\\n\", asm_out_file);\n     }\n-\n-  if (num_gfregs)\n-    output_restore_regs (file, leaf_function);\n-\n-  /* Work out how to skip the caller's unimp instruction if required.  */\n-  if (leaf_function)\n-    ret = (sparc_skip_caller_unimp ? \"jmp\\t%o7+12\" : \"retl\");\n   else\n-    ret = (sparc_skip_caller_unimp ? \"jmp\\t%i7+12\" : \"ret\");\n-\n-  if (! leaf_function)\n     {\n+      /* This is a regular function so we have to restore the register window.\n+\t We may have a pending insn for the delay slot, which will be either\n+\t combined with the 'restore' instruction or put in the delay slot of\n+\t the 'return' instruction.  */\n+\n       if (current_function_calls_eh_return)\n \t{\n-\t  if (current_function_epilogue_delay_list)\n-\t    abort ();\n-\t  if (sparc_skip_caller_unimp)\n+\t  /* If the function uses __builtin_eh_return, the eh_return\n+\t     machinery occupies the delay slot.  */\n+\t  if (delay_slot_filled_p || sparc_skip_caller_unimp)\n \t    abort ();\n \n-\t  fputs (\"\\trestore\\n\\tretl\\n\\tadd\\t%sp, %g1, %sp\\n\", file);\n+\t  if (TARGET_V9)\n+\t    fputs (\"\\treturn\\t%i7+8\\n\", asm_out_file);\n+\t  else\n+\t    fputs (\"\\trestore\\n\\tjmp\\t%o7+8\\n\", asm_out_file);\n+\n+\t  fputs (\"\\t add\\t%sp, %g1, %sp\\n\", asm_out_file);\n \t}\n-      /* If we wound up with things in our delay slot, flush them here.  */\n-      else if (current_function_epilogue_delay_list)\n+      else if (delay_slot_filled_p)\n \t{\n-\t  rtx delay = PATTERN (XEXP (current_function_epilogue_delay_list, 0));\n+\t  rtx delay, pat;\n+\n+\t  delay = NEXT_INSN (insn);\n+\t  if (! delay)\n+\t    abort ();\n \n-\t  if (TARGET_V9 && ! epilogue_renumber (&delay, 1))\n+\t  pat = PATTERN (delay);\n+\n+\t  if (TARGET_V9 && ! epilogue_renumber (&pat, 1))\n \t    {\n-\t      epilogue_renumber (&delay, 0);\n-\t      fputs (sparc_skip_caller_unimp\n-\t\t     ? \"\\treturn\\t%i7+12\\n\"\n-\t\t     : \"\\treturn\\t%i7+8\\n\", file);\n-\t      final_scan_insn (XEXP (current_function_epilogue_delay_list, 0),\n-\t\t\t       file, 1, 0, 0, NULL);\n+\t      epilogue_renumber (&pat, 0);\n+\t      fprintf (asm_out_file, \"\\treturn\\t%%i7+%d\\n\",\n+\t\t       sparc_skip_caller_unimp ? 12 : 8);\n+\t      final_scan_insn (delay, asm_out_file, 1, 0, 0, NULL);\n \t    }\n \t  else\n \t    {\n-\t      rtx insn, src;\n-\n-\t      if (GET_CODE (delay) != SET)\n-\t\tabort();\n-\n-\t      src = SET_SRC (delay);\n-\t      if (GET_CODE (src) == ASHIFT)\n-\t\t{\n-\t\t  if (XEXP (src, 1) != const1_rtx)\n-\t\t    abort();\n-\t\t  SET_SRC (delay)\n-\t\t    = gen_rtx_PLUS (GET_MODE (src), XEXP (src, 0),\n-\t\t\t\t    XEXP (src, 0));\n-\t\t}\n-\n-\t      insn = gen_rtx_PARALLEL (VOIDmode,\n-\t\t\t\t       gen_rtvec (2, delay,\n-\t\t\t\t\t\t  gen_rtx_RETURN (VOIDmode)));\n-\t      insn = emit_jump_insn (insn);\n-\n-\t      sparc_emitting_epilogue = true;\n-\t      final_scan_insn (insn, file, 1, 0, 1, NULL);\n-\t      sparc_emitting_epilogue = false;\n+\t      fprintf (asm_out_file, \"\\tjmp\\t%%i7+%d\\n\",\n+\t\t       sparc_skip_caller_unimp ? 12 : 8);\n+\t      output_restore (delay);\n \t    }\n+\n+\t  PATTERN (delay) = gen_blockage ();\n+\t  INSN_CODE (delay) = -1;\n \t}\n-      else if (TARGET_V9 && ! sparc_skip_caller_unimp)\n-\tfputs (\"\\treturn\\t%i7+8\\n\\tnop\\n\", file);\n       else\n-\tfprintf (file, \"\\t%s\\n\\trestore\\n\", ret);\n-    }\n-  /* All of the following cases are for leaf functions.  */\n-  else if (current_function_calls_eh_return)\n-    abort ();\n-  else if (current_function_epilogue_delay_list)\n-    {\n-      /* eligible_for_epilogue_delay_slot ensures that if this is a\n-\t leaf function, then we will only have insn in the delay slot\n-\t if the frame size is zero, thus no adjust for the stack is\n-\t needed here.  */\n-      if (actual_fsize != 0)\n-\tabort ();\n-      fprintf (file, \"\\t%s\\n\", ret);\n-      final_scan_insn (XEXP (current_function_epilogue_delay_list, 0),\n-\t\t       file, 1, 0, 1, NULL);\n-    }\n-  /* Output 'nop' instead of 'sub %sp,-0,%sp' when no frame, so as to\n-\t avoid generating confusing assembly language output.  */\n-  else if (actual_fsize == 0)\n-    fprintf (file, \"\\t%s\\n\\tnop\\n\", ret);\n-  else if (actual_fsize <= 4096)\n-    fprintf (file, \"\\t%s\\n\\tsub\\t%%sp, -\"HOST_WIDE_INT_PRINT_DEC\", %%sp\\n\",\n-\t     ret, actual_fsize);\n-  else if (actual_fsize <= 8192)\n-    fprintf (file, \"\\tsub\\t%%sp, -4096, %%sp\\n\\t%s\\n\\tsub\\t%%sp, -\"HOST_WIDE_INT_PRINT_DEC\", %%sp\\n\",\n-\t     ret, actual_fsize - 4096);\n-  else\n-    {\n-      build_big_number (file, actual_fsize, \"%g1\");\n-      fprintf (file, \"\\t%s\\n\\tadd\\t%%sp, %%g1, %%sp\\n\", ret);\n+        {\n+\t  /* The delay slot is empty.  */\n+\t  if (TARGET_V9)\n+\t    fprintf (asm_out_file, \"\\treturn\\t%%i7+%d\\n\\t nop\\n\",\n+\t\t     sparc_skip_caller_unimp ? 12 : 8);\n+\t  else\n+\t    fprintf (asm_out_file, \"\\tjmp\\t%%i7+%d\\n\\t restore\\n\",\n+\t\t     sparc_skip_caller_unimp ? 12 : 8);\n+\t}\n     }\n \n- output_vectors:\n-  sparc_output_deferred_case_vectors ();\n+  return \"\";\n }\n \n /* Output a sibling call.  */\n \n const char *\n output_sibcall (rtx insn, rtx call_operand)\n {\n-  int leaf_regs = current_function_uses_only_leaf_regs;\n-  rtx operands[3];\n-  int delay_slot = dbr_sequence_length () > 0;\n-\n-  if (num_gfregs)\n-    {\n-      /* Call to restore global regs might clobber\n-\t the delay slot. Instead of checking for this\n-\t output the delay slot now.  */\n-      if (delay_slot)\n-\t{\n-\t  rtx delay = NEXT_INSN (insn);\n-\n-\t  if (! delay)\n-\t    abort ();\n-\n-\t  final_scan_insn (delay, asm_out_file, 1, 0, 1, NULL);\n-\t  PATTERN (delay) = gen_blockage ();\n-\t  INSN_CODE (delay) = -1;\n-\t  delay_slot = 0;\n-\t}\n-      output_restore_regs (asm_out_file, leaf_regs);\n-    }\n+  int leaf_function_p = current_function_uses_only_leaf_regs;\n+  bool delay_slot_filled_p = dbr_sequence_length () > 0;\n+  rtx operands[1];\n \n   operands[0] = call_operand;\n \n-  if (leaf_regs)\n+  if (leaf_function_p)\n     {\n-#ifdef HAVE_AS_RELAX_OPTION\n-      /* If as and ld are relaxing tail call insns into branch always,\n-\t use or %o7,%g0,X; call Y; or X,%g0,%o7 always, so that it can\n-\t be optimized.  With sethi/jmpl as nor ld has no easy way how to\n-\t find out if somebody does not branch between the sethi and jmpl.  */\n-      int spare_slot = 0;\n-#else\n-      int spare_slot = ((TARGET_ARCH32 || TARGET_CM_MEDLOW) && ! flag_pic);\n-#endif\n-      HOST_WIDE_INT size = 0;\n+      /* This is a leaf function so we don't have to bother restoring the\n+\t register window.  We simply output the jump to the function and\n+\t the insn in the delay slot (if any).  */\n \n-      if ((actual_fsize || ! spare_slot) && delay_slot)\n+      if (! SIBCALL_SLOT_EMPTY_P && delay_slot_filled_p)\n+\tabort();\n+\n+      if (delay_slot_filled_p)\n \t{\n \t  rtx delay = NEXT_INSN (insn);\n-\n \t  if (! delay)\n \t    abort ();\n \n-\t  final_scan_insn (delay, asm_out_file, 1, 0, 1, NULL);\n+\t  output_asm_insn (\"sethi\\t%%hi(%a0), %%g1\", operands);\n+\t  output_asm_insn (\"jmp\\t%%g1 + %%lo(%a0)\", operands);\n+\t  final_scan_insn (delay, asm_out_file, 1, 0, 0, NULL);\n+\n \t  PATTERN (delay) = gen_blockage ();\n \t  INSN_CODE (delay) = -1;\n-\t  delay_slot = 0;\n-\t}\n-      if (actual_fsize)\n-\t{\n-\t  if (actual_fsize <= 4096)\n-\t    size = actual_fsize;\n-\t  else if (actual_fsize <= 8192)\n-\t    {\n-\t      fputs (\"\\tsub\\t%sp, -4096, %sp\\n\", asm_out_file);\n-\t      size = actual_fsize - 4096;\n-\t    }\n-\t  else\n-\t    {\n-\t      build_big_number (asm_out_file, actual_fsize, \"%g1\");\n-\t      fputs (\"\\tadd\\t%%sp, %%g1, %%sp\\n\", asm_out_file);\n-\t    }\n-\t}\n-      if (spare_slot)\n-\t{\n-\t  output_asm_insn (\"sethi\\t%%hi(%a0), %%g1\", operands);\n-\t  output_asm_insn (\"jmpl\\t%%g1 + %%lo(%a0), %%g0\", operands);\n-\t  if (size)\n-\t    fprintf (asm_out_file, \"\\t sub\\t%%sp, -\"HOST_WIDE_INT_PRINT_DEC\", %%sp\\n\", size);\n-\t  else if (! delay_slot)\n-\t    fputs (\"\\t nop\\n\", asm_out_file);\n \t}\n       else\n \t{\n-\t  if (size)\n-\t    fprintf (asm_out_file, \"\\tsub\\t%%sp, -\"HOST_WIDE_INT_PRINT_DEC\", %%sp\\n\", size);\n \t  /* Use or with rs2 %%g0 instead of mov, so that as/ld can optimize\n \t     it into branch if possible.  */\n \t  output_asm_insn (\"or\\t%%o7, %%g0, %%g1\", operands);\n \t  output_asm_insn (\"call\\t%a0, 0\", operands);\n \t  output_asm_insn (\" or\\t%%g1, %%g0, %%o7\", operands);\n \t}\n-      return \"\";\n     }\n-\n-  output_asm_insn (\"call\\t%a0, 0\", operands);\n-  if (delay_slot)\n+  else\n     {\n-      rtx delay = NEXT_INSN (insn), pat;\n+      /* This is a regular function so we have to restore the register window.\n+\t We may have a pending insn for the delay slot, which will be combined\n+\t with the 'restore' instruction.  */\n \n-      if (! delay)\n-\tabort ();\n+      output_asm_insn (\"call\\t%a0, 0\", operands);\n \n-      pat = PATTERN (delay);\n-      if (GET_CODE (pat) != SET)\n-\tabort ();\n-\n-      operands[0] = SET_DEST (pat);\n-      pat = SET_SRC (pat);\n-      switch (GET_CODE (pat))\n+      if (delay_slot_filled_p)\n \t{\n-\tcase PLUS:\n-\t  operands[1] = XEXP (pat, 0);\n-\t  operands[2] = XEXP (pat, 1);\n-\t  output_asm_insn (\" restore %r1, %2, %Y0\", operands);\n-\t  break;\n-\tcase LO_SUM:\n-\t  operands[1] = XEXP (pat, 0);\n-\t  operands[2] = XEXP (pat, 1);\n-\t  output_asm_insn (\" restore %r1, %%lo(%a2), %Y0\", operands);\n-\t  break;\n-\tcase ASHIFT:\n-\t  operands[1] = XEXP (pat, 0);\n-\t  output_asm_insn (\" restore %r1, %r1, %Y0\", operands);\n-\t  break;\n-\tdefault:\n-\t  operands[1] = pat;\n-\t  output_asm_insn (\" restore %%g0, %1, %Y0\", operands);\n-\t  break;\n+\t  rtx delay = NEXT_INSN (insn);\n+\t  if (! delay)\n+\t    abort ();\n+\n+\t  output_restore (delay);\n+\n+\t  PATTERN (delay) = gen_blockage ();\n+\t  INSN_CODE (delay) = -1;\n \t}\n-      PATTERN (delay) = gen_blockage ();\n-      INSN_CODE (delay) = -1;\n+      else\n+\toutput_restore (0);\n     }\n-  else\n-    fputs (\"\\t restore\\n\", asm_out_file);\n+\n   return \"\";\n }\n \f\n@@ -6965,7 +6748,8 @@ print_operand (FILE *file, rtx x, int code)\n       /* Print out what we are using as the frame pointer.  This might\n \t be %fp, or might be %sp+offset.  */\n       /* ??? What if offset is too big? Perhaps the caller knows it isn't? */\n-      fprintf (file, \"%s+\"HOST_WIDE_INT_PRINT_DEC, frame_base_name, frame_base_offset);\n+      fprintf (file, \"%s+\"HOST_WIDE_INT_PRINT_DEC,\n+\t       reg_names[REGNO (frame_base_reg)], frame_base_offset);\n       return;\n     case '&':\n       /* Print some local dynamic TLS name.  */"}, {"sha": "0cf64b84a0df6a973f20701ad0b2b03e5ea534b6", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 11, "deletions": 17, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ac617d49582c168000b6e593e5c0b4bf2982ee0/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ac617d49582c168000b6e593e5c0b4bf2982ee0/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=9ac617d49582c168000b6e593e5c0b4bf2982ee0", "patch": "@@ -1511,16 +1511,15 @@ extern char leaf_reg_remap[];\n #define CAN_ELIMINATE(FROM, TO) \\\n   ((TO) == HARD_FRAME_POINTER_REGNUM || !FRAME_POINTER_REQUIRED)\n \n-#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET) \\\n-  do {\t\t\t\t\t\t\t\t\\\n-    (OFFSET) = 0;\t\t\t\t\t\t\\\n-    if ((TO) == STACK_POINTER_REGNUM)\t\t\t\t\\\n-      /* Note, we always pretend that this is a leaf function\t\\\n-\t because if it's not, there's no point in trying to\t\\\n-\t eliminate the frame pointer.  If it is a leaf\t\t\\\n-\t function, we guessed right!  */\t\t\t\\\n-      (OFFSET) = compute_frame_size (get_frame_size (), 1);\t\\\n-    (OFFSET) += SPARC_STACK_BIAS;\t\t\t\t\\\n+/* We always pretend that this is a leaf function because if it's not,\n+   there's no point in trying to eliminate the frame pointer.  If it\n+   is a leaf function, we guessed right!  */\n+#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET) \t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    (OFFSET) = 0;\t\t\t\t\t\t\t\\\n+    if ((TO) == STACK_POINTER_REGNUM)\t\t\t\t\t\\\n+      (OFFSET) = sparc_compute_frame_size (get_frame_size (), 1);\t\\\n+    (OFFSET) += SPARC_STACK_BIAS;\t\t\t\t\t\\\n   } while (0)\n \n /* Keep the stack pointer constant throughout the function.\n@@ -1775,13 +1774,9 @@ do {\t\t\t\t\t\t\t\t\t\\\n  (get_frame_size () != 0\t\\\n   || current_function_calls_alloca || current_function_outgoing_args_size)\n \n-#define DELAY_SLOTS_FOR_EPILOGUE 1\n-\n-#define ELIGIBLE_FOR_EPILOGUE_DELAY(trial, slots_filled) \\\n-  eligible_for_epilogue_delay (trial, slots_filled)\n-\n /* Define registers used by the epilogue and return instruction.  */\n-#define EPILOGUE_USES(REGNO) (REGNO == 31)\n+#define EPILOGUE_USES(REGNO) ((REGNO) == 31 \\\n+  || (current_function_calls_eh_return && (REGNO) == 1))\n \f\n /* Length in units of the trampoline for entering a nested function.  */\n \n@@ -2581,7 +2576,6 @@ do {\t\t\t\t\t\t\t\t\t\\\n {\"fcc_reg_operand\", {REG}},\t\t\t\t\t\t\\\n {\"fcc0_reg_operand\", {REG}},\t\t\t\t\t\t\\\n {\"icc_or_fcc_reg_operand\", {REG}},\t\t\t\t\t\\\n-{\"restore_operand\", {REG}},\t\t\t\t\t\t\\\n {\"call_operand\", {MEM}},\t\t\t\t\t\t\\\n {\"call_operand_address\", {SYMBOL_REF, LABEL_REF, CONST, CONST_DOUBLE,\t\\\n \tADDRESSOF, SUBREG, REG, PLUS, LO_SUM, CONST_INT}},\t\t\\"}, {"sha": "f3ce4368e753456169632acfc3789fc8faecfd33", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 78, "deletions": 181, "changes": 259, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ac617d49582c168000b6e593e5c0b4bf2982ee0/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ac617d49582c168000b6e593e5c0b4bf2982ee0/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=9ac617d49582c168000b6e593e5c0b4bf2982ee0", "patch": "@@ -54,6 +54,7 @@\n    (UNSPECV_GOTO_V9\t\t3)\n    (UNSPECV_FLUSH\t\t4)\n    (UNSPECV_SETJMP\t\t5)\n+   (UNSPECV_SAVEW\t\t6)\n   ])\n \n ;; The upper 32 fp regs on the v9 can't hold SFmode values.  To deal with this\n@@ -98,7 +99,7 @@\n (define_attr \"type\"\n   \"ialu,compare,shift,\n    load,sload,store,\n-   uncond_branch,branch,call,sibcall,call_no_delay_slot,\n+   uncond_branch,branch,call,sibcall,call_no_delay_slot,return,\n    imul,idiv,\n    fpload,fpstore,\n    fp,fpmove,\n@@ -109,7 +110,7 @@\n    fga,fgm_pack,fgm_mul,fgm_pdist,fgm_cmp,\n    cmove,\n    ialuX,\n-   multi,flushw,iflush,trap\"\n+   multi,savew,flushw,iflush,trap\"\n   (const_string \"ialu\"))\n \n ;; true if branch/call has empty delay slot and will emit a nop in it\n@@ -219,19 +220,13 @@\n \t\t      (const_string \"true\")\n \t\t      (const_string \"false\"))))\n \n-(define_delay (eq_attr \"type\" \"call\")\n-  [(eq_attr \"in_call_delay\" \"true\") (nil) (nil)])\n-\n (define_attr \"eligible_for_sibcall_delay\" \"false,true\"\n   (symbol_ref \"eligible_for_sibcall_delay (insn)\"))\n \n-(define_delay (eq_attr \"type\" \"sibcall\")\n-  [(eq_attr \"eligible_for_sibcall_delay\" \"true\") (nil) (nil)])\n-\n-(define_attr \"leaf_function\" \"false,true\"\n-  (const (symbol_ref \"current_function_uses_only_leaf_regs\")))\n+(define_attr \"eligible_for_return_delay\" \"false,true\"\n+  (symbol_ref \"eligible_for_return_delay (insn)\"))\n \n-;; ??? Should implement the notion of predelay slots for floating point\n+;; ??? !v9: Should implement the notion of predelay slots for floating-point\n ;; branches.  This would allow us to remove the nop always inserted before\n ;; a floating point branch.\n \n@@ -261,14 +256,23 @@\n \t\t(const_string \"true\")\n \t\t(const_string \"false\")))\n \n+(define_delay (eq_attr \"type\" \"call\")\n+  [(eq_attr \"in_call_delay\" \"true\") (nil) (nil)])\n+\n+(define_delay (eq_attr \"type\" \"sibcall\")\n+  [(eq_attr \"eligible_for_sibcall_delay\" \"true\") (nil) (nil)])\n+\n (define_delay (eq_attr \"type\" \"branch\")\n   [(eq_attr \"in_branch_delay\" \"true\")\n    (nil) (eq_attr \"in_annul_branch_delay\" \"true\")])\n \n (define_delay (eq_attr \"type\" \"uncond_branch\")\n   [(eq_attr \"in_uncond_branch_delay\" \"true\")\n    (nil) (nil)])\n-   \n+\n+(define_delay (eq_attr \"type\" \"return\")\n+  [(eq_attr \"eligible_for_return_delay\" \"true\") (nil) (nil)])\n+\n ;; Include SPARC DFA schedulers\n \n (include \"cypress.md\")\n@@ -7619,9 +7623,70 @@\n   [(set_attr \"type\" \"sibcall\")])\n \n (define_expand \"sibcall_epilogue\"\n+  [(return)]\n+  \"\"\n+{\n+  sparc_expand_epilogue ();\n+  DONE;\n+})\n+\n+(define_expand \"prologue\"\n   [(const_int 0)]\n   \"\"\n-  \"DONE;\")\n+{\n+  sparc_expand_prologue ();\n+  DONE;\n+})\n+\n+(define_expand \"save_register_window\"\n+  [(use (match_operand 0 \"arith_operand\" \"\"))]\n+  \"\"\n+{\n+  rtvec vec;\n+\n+  vec = gen_rtvec (2,\n+\t\t   gen_rtx_SET (VOIDmode,\n+\t\t\t\tstack_pointer_rtx,\n+\t\t\t\tgen_rtx_PLUS (Pmode,\n+\t\t\t\t\t      hard_frame_pointer_rtx,\n+\t\t\t\t\t      operands[0])),\n+\t\t   gen_rtx_UNSPEC_VOLATILE (VOIDmode,\n+\t\t\t\t\t    gen_rtvec (1, const0_rtx),\n+\t\t\t\t\t    UNSPECV_SAVEW));\n+\n+  emit_insn (gen_rtx_PARALLEL (VOIDmode, vec));\n+  DONE;\n+})\n+\n+(define_insn \"*save_register_windowsi\"\n+  [(set (reg:SI 14) (plus:SI (reg:SI 30)\n+\t\t\t     (match_operand:SI 0 \"arith_operand\" \"rI\")))\n+   (unspec_volatile [(const_int 0)] UNSPECV_SAVEW)]\n+  \"! TARGET_ARCH64\"\n+  \"save\\t%%sp, %0, %%sp\"\n+  [(set_attr \"type\" \"savew\")])\n+\n+(define_insn \"*save_register_windowdi\"\n+  [(set (reg:DI 14) (plus:DI (reg:DI 30)\n+\t\t\t     (match_operand:DI 0 \"arith_operand\" \"rI\")))\n+   (unspec_volatile [(const_int 0)] UNSPECV_SAVEW)]\n+  \"TARGET_ARCH64\"\n+  \"save\\t%%sp, %0, %%sp\"\n+  [(set_attr \"type\" \"savew\")])\n+\n+(define_expand \"epilogue\"\n+  [(return)]\n+  \"\"\n+{\n+  sparc_expand_epilogue ();\n+})\n+\n+(define_insn \"*return_internal\"\n+  [(return)]\n+  \"\"\n+  \"* return output_return (insn);\"\n+  [(set_attr \"type\" \"return\")\n+   (set_attr \"length\" \"2\")])\n \n ;; UNSPEC_VOLATILE is considered to use and clobber all hard registers and\n ;; all of memory.  This blocks insns from being moved across this point.\n@@ -8086,166 +8151,6 @@\n \t\t   (compare:CCX (match_dup 1) (const_int 0)))])]\n   \"\")\n \n-;; Return peepholes.  These are generated by sparc_function_epilogue\n-;; who then immediately calls final_scan_insn.\n-\n-(define_insn \"*return_qi\"\n-  [(set (match_operand:QI 0 \"restore_operand\" \"\")\n-\t(match_operand:QI 1 \"arith_operand\" \"rI\"))\n-   (return)]\n-  \"sparc_emitting_epilogue\"\n-{\n-  if (sparc_skip_caller_unimp)\n-    return \"jmp\\t%%i7+12\\n\\trestore %%g0, %1, %Y0\";\n-  else if (TARGET_V9 && (GET_CODE (operands[1]) == CONST_INT\n-\t\t\t || IN_OR_GLOBAL_P (operands[1])))\n-    return \"return\\t%%i7+8\\n\\tmov\\t%Y1, %Y0\";\n-  else\n-    return \"ret\\n\\trestore %%g0, %1, %Y0\";\n-}\n-  [(set_attr \"type\" \"multi\")\n-   (set_attr \"length\" \"2\")])\n-\n-(define_insn \"*return_hi\"\n-  [(set (match_operand:HI 0 \"restore_operand\" \"\")\n-\t(match_operand:HI 1 \"arith_operand\" \"rI\"))\n-   (return)]\n-  \"sparc_emitting_epilogue\"\n-{\n-  if (sparc_skip_caller_unimp)\n-    return \"jmp\\t%%i7+12\\n\\trestore %%g0, %1, %Y0\";\n-  else if (TARGET_V9 && (GET_CODE (operands[1]) == CONST_INT\n-\t\t\t || IN_OR_GLOBAL_P (operands[1])))\n-    return \"return\\t%%i7+8\\n\\tmov\\t%Y1, %Y0\";\n-  else\n-    return \"ret\\;restore %%g0, %1, %Y0\";\n-}\n-  [(set_attr \"type\" \"multi\")\n-   (set_attr \"length\" \"2\")])\n-\n-(define_insn \"*return_si\"\n-  [(set (match_operand:SI 0 \"restore_operand\" \"\")\n-\t(match_operand:SI 1 \"arith_operand\" \"rI\"))\n-   (return)]\n-  \"sparc_emitting_epilogue\"\n-{\n-  if (sparc_skip_caller_unimp)\n-    return \"jmp\\t%%i7+12\\n\\trestore %%g0, %1, %Y0\";\n-  else if (TARGET_V9 && (GET_CODE (operands[1]) == CONST_INT\n-\t\t\t || IN_OR_GLOBAL_P (operands[1])))\n-    return \"return\\t%%i7+8\\n\\tmov\\t%Y1, %Y0\";\n-  else\n-    return \"ret\\;restore %%g0, %1, %Y0\";\n-}\n-  [(set_attr \"type\" \"multi\")\n-   (set_attr \"length\" \"2\")])\n-\n-(define_insn \"*return_sf_no_fpu\"\n-  [(set (match_operand:SF 0 \"restore_operand\" \"=r\")\n-\t(match_operand:SF 1 \"register_operand\" \"r\"))\n-   (return)]\n-  \"sparc_emitting_epilogue\"\n-{\n-  if (sparc_skip_caller_unimp)\n-    return \"jmp\\t%%i7+12\\n\\trestore %%g0, %1, %Y0\";\n-  else if (TARGET_V9 && IN_OR_GLOBAL_P (operands[1]))\n-    return \"return\\t%%i7+8\\n\\tmov\\t%Y1, %Y0\";\n-  else\n-    return \"ret\\;restore %%g0, %1, %Y0\";\n-}\n-  [(set_attr \"type\" \"multi\")\n-   (set_attr \"length\" \"2\")])\n-\n-(define_insn \"*return_df_no_fpu\"\n-  [(set (match_operand:DF 0 \"restore_operand\" \"=r\")\n-\t(match_operand:DF 1 \"register_operand\" \"r\"))\n-   (return)]\n-  \"sparc_emitting_epilogue && TARGET_ARCH64\"\n-{\n-  if (IN_OR_GLOBAL_P (operands[1]))\n-    return \"return\\t%%i7+8\\n\\tmov\\t%Y1, %Y0\";\n-  else\n-    return \"ret\\;restore %%g0, %1, %Y0\";\n-}\n-  [(set_attr \"type\" \"multi\")\n-   (set_attr \"length\" \"2\")])\n-\n-(define_insn \"*return_addsi\"\n-  [(set (match_operand:SI 0 \"restore_operand\" \"\")\n-\t(plus:SI (match_operand:SI 1 \"register_operand\" \"r\")\n-\t\t (match_operand:SI 2 \"arith_operand\" \"rI\")))\n-   (return)]\n-  \"sparc_emitting_epilogue\"\n-{\n-  if (sparc_skip_caller_unimp)\n-    return \"jmp\\t%%i7+12\\n\\trestore %r1, %2, %Y0\";\n-  /* If operands are global or in registers, can use return */\n-  else if (TARGET_V9 && IN_OR_GLOBAL_P (operands[1])\n-\t   && (GET_CODE (operands[2]) == CONST_INT\n-\t       || IN_OR_GLOBAL_P (operands[2])))\n-    return \"return\\t%%i7+8\\n\\tadd\\t%Y1, %Y2, %Y0\";\n-  else\n-    return \"ret\\;restore %r1, %2, %Y0\";\n-}\n-  [(set_attr \"type\" \"multi\")\n-   (set_attr \"length\" \"2\")])\n-\n-(define_insn \"*return_losum_si\"\n-  [(set (match_operand:SI 0 \"restore_operand\" \"\")\n-\t(lo_sum:SI (match_operand:SI 1 \"register_operand\" \"r\")\n-\t\t   (match_operand:SI 2 \"immediate_operand\" \"in\")))\n-   (return)]\n-  \"sparc_emitting_epilogue && ! TARGET_CM_MEDMID\"\n-{\n-  if (sparc_skip_caller_unimp)\n-    return \"jmp\\t%%i7+12\\n\\trestore %r1, %%lo(%a2), %Y0\";\n-  /* If operands are global or in registers, can use return */\n-  else if (TARGET_V9 && IN_OR_GLOBAL_P (operands[1]))\n-    return \"return\\t%%i7+8\\n\\tor\\t%Y1, %%lo(%a2), %Y0\";\n-  else\n-    return \"ret\\;restore %r1, %%lo(%a2), %Y0\";\n-}\n-  [(set_attr \"type\" \"multi\")\n-   (set_attr \"length\" \"2\")])\n-\n-(define_insn \"*return_di\"\n-  [(set (match_operand:DI 0 \"restore_operand\" \"\")\n-\t(match_operand:DI 1 \"arith_double_operand\" \"rHI\"))\n-   (return)]\n-  \"sparc_emitting_epilogue && TARGET_ARCH64\"\n-  \"ret\\;restore %%g0, %1, %Y0\"\n-  [(set_attr \"type\" \"multi\")\n-   (set_attr \"length\" \"2\")])\n-\n-(define_insn \"*return_adddi\"\n-  [(set (match_operand:DI 0 \"restore_operand\" \"\")\n-\t(plus:DI (match_operand:DI 1 \"arith_operand\" \"%r\")\n-\t\t (match_operand:DI 2 \"arith_double_operand\" \"rHI\")))\n-   (return)]\n-  \"sparc_emitting_epilogue && TARGET_ARCH64\"\n-  \"ret\\;restore %r1, %2, %Y0\"\n-  [(set_attr \"type\" \"multi\")\n-   (set_attr \"length\" \"2\")])\n-\n-(define_insn \"*return_losum_di\"\n-  [(set (match_operand:DI 0 \"restore_operand\" \"\")\n-\t(lo_sum:DI (match_operand:DI 1 \"arith_operand\" \"%r\")\n-\t\t   (match_operand:DI 2 \"immediate_operand\" \"in\")))\n-   (return)]\n-  \"sparc_emitting_epilogue && TARGET_ARCH64 && ! TARGET_CM_MEDMID\"\n-  \"ret\\;restore %r1, %%lo(%a2), %Y0\"\n-  [(set_attr \"type\" \"multi\")\n-   (set_attr \"length\" \"2\")])\n-\n-(define_insn \"*return_sf\"\n-  [(set (reg:SF 32)\n-\t(match_operand:SF 0 \"register_operand\" \"f\"))\n-   (return)]\n-  \"sparc_emitting_epilogue\"\n-  \"ret\\;fmovs\\t%0, %%f0\"\n-  [(set_attr \"type\" \"multi\")\n-   (set_attr \"length\" \"2\")])\n-\n ;; ??? UltraSPARC-III note: A memory operation loading into the floating point register\n ;; ??? file, if it hits the prefetch cache, has a chance to dual-issue with other memory\n ;; ??? operations.  With DFA we might be able to model this, but it requires a lot of\n@@ -8317,14 +8222,6 @@\n }\n   [(set_attr \"type\" \"load\")])\n \f\n-(define_expand \"prologue\"\n-  [(const_int 1)]\n-  \"flag_pic && current_function_uses_pic_offset_table\"\n-{\n-  load_pic_register ();\n-  DONE;\n-})\n-\f\n (define_insn \"trap\"\n   [(trap_if (const_int 1) (const_int 5))]\n   \"\""}, {"sha": "718694c8178987ee8e603f8706ca6683605b17af", "filename": "gcc/config/sparc/ultra1_2.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ac617d49582c168000b6e593e5c0b4bf2982ee0/gcc%2Fconfig%2Fsparc%2Fultra1_2.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ac617d49582c168000b6e593e5c0b4bf2982ee0/gcc%2Fconfig%2Fsparc%2Fultra1_2.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fultra1_2.md?ref=9ac617d49582c168000b6e593e5c0b4bf2982ee0", "patch": "@@ -80,7 +80,7 @@\n \n (define_insn_reservation \"us1_single\" 1\n   (and (eq_attr \"cpu\" \"ultrasparc\")\n-    (eq_attr \"type\" \"multi,flushw,iflush,trap\"))\n+    (eq_attr \"type\" \"multi,savew,flushw,iflush,trap\"))\n   \"us1_single_issue\")\n \n (define_insn_reservation \"us1_simple_ieuN\" 1"}, {"sha": "2f2ea5b5a4bbc643fc445f2cd2fd63c9330f0050", "filename": "gcc/config/sparc/ultra3.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ac617d49582c168000b6e593e5c0b4bf2982ee0/gcc%2Fconfig%2Fsparc%2Fultra3.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ac617d49582c168000b6e593e5c0b4bf2982ee0/gcc%2Fconfig%2Fsparc%2Fultra3.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fultra3.md?ref=9ac617d49582c168000b6e593e5c0b4bf2982ee0", "patch": "@@ -37,7 +37,7 @@\n \n (define_insn_reservation \"us3_single\" 1\n   (and (eq_attr \"cpu\" \"ultrasparc3\")\n-    (eq_attr \"type\" \"multi,flushw,iflush,trap\"))\n+    (eq_attr \"type\" \"multi,savew,flushw,iflush,trap\"))\n   \"us3_single_issue\")\n \n (define_insn_reservation \"us3_integer\" 1"}, {"sha": "5f325815d14302f654900fc145f75d1d89c3035a", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ac617d49582c168000b6e593e5c0b4bf2982ee0/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ac617d49582c168000b6e593e5c0b4bf2982ee0/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=9ac617d49582c168000b6e593e5c0b4bf2982ee0", "patch": "@@ -2218,8 +2218,9 @@ set prior to local register allocation and is valid for the remaining\n compiler passes.  They can also test the C variable\n @code{current_function_uses_only_leaf_regs} which is nonzero for leaf\n functions which only use leaf registers.\n-@code{current_function_uses_only_leaf_regs} is valid after reload and is\n-only useful if @code{LEAF_REGISTERS} is defined.\n+@code{current_function_uses_only_leaf_regs} is valid after all passes\n+that modify the instructions have been run and is only useful if\n+@code{LEAF_REGISTERS} is defined.\n @c changed this to fix overfull.  ALSO:  why the \"it\" at the beginning\n @c of the next paragraph?!  --mew 2feb93\n \n@@ -4211,6 +4212,16 @@ arguments that a function should pop.  @xref{Scalar Return}.\n @c tell?  --mew 5feb93\n @end deftypefn\n \n+@deftypefn {Target Hook} bool TARGET_LATE_RTL_PROLOGUE_EPILOGUE\n+If set to @code{true}, it instructs the compiler to emit the RTL prologue\n+and epilogue later in the game than usual, namely after all passes that\n+modify the instructions (and not merely reorder them) have been run.  In\n+particular, the C variable @code{current_function_uses_only_leaf_regs} is\n+valid at that point.  This can be used on machines that have \"register\n+windows\" to optimize away the regular \"push\" on the register stack.\n+@xref{Leaf Functions}.\n+@end deftypefn\n+\n @itemize @bullet\n @item\n @findex current_function_pretend_args_size\n@@ -4245,12 +4256,6 @@ Optionally, when @code{ACCUMULATE_OUTGOING_ARGS} is defined, a region of\n argument lists of the function.  @xref{Stack Arguments}.\n @end itemize\n \n-Normally, it is necessary for the macros\n-@code{TARGET_ASM_FUNCTION_PROLOGUE} and\n-@code{TARGET_ASM_FUNCTION_EPILOGUE} to treat leaf functions specially.\n-The C variable @code{current_function_is_leaf} is nonzero for such a\n-function.\n-\n @defmac EXIT_IGNORE_STACK\n Define this macro as a C expression that is nonzero if the return\n instruction or the function epilogue ignores the value of the stack"}, {"sha": "34fdf7660c7b704acccc59b4cfd368a49b8b608f", "filename": "gcc/passes.c", "status": "modified", "additions": 29, "deletions": 14, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ac617d49582c168000b6e593e5c0b4bf2982ee0/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ac617d49582c168000b6e593e5c0b4bf2982ee0/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=9ac617d49582c168000b6e593e5c0b4bf2982ee0", "patch": "@@ -1727,15 +1727,18 @@ rest_of_compilation (void)\n \tggc_collect ();\n       }\n \n-  if (optimize)\n-    cleanup_cfg (CLEANUP_EXPENSIVE);\n-\n-  /* On some machines, the prologue and epilogue code, or parts thereof,\n-     can be represented as RTL.  Doing so lets us schedule get_insns () between\n-     it and the rest of the code and also allows delayed branch\n-     scheduling to operate in the epilogue.  */\n-  thread_prologue_and_epilogue_insns (get_insns ());\n-  epilogue_completed = 1;\n+  if (! targetm.late_rtl_prologue_epilogue)\n+    {\n+      if (optimize)\n+\tcleanup_cfg (CLEANUP_EXPENSIVE);\n+\n+      /* On some machines, the prologue and epilogue code, or parts thereof,\n+\t can be represented as RTL.  Doing so lets us schedule insns between\n+\t it and the rest of the code and also allows delayed branch\n+\t scheduling to operate in the epilogue.  */\n+      thread_prologue_and_epilogue_insns (get_insns ());\n+      epilogue_completed = 1;\n+    }\n \n   if (optimize)\n     {\n@@ -1816,16 +1819,28 @@ rest_of_compilation (void)\n       ggc_collect ();\n     }\n \n-#ifdef INSN_SCHEDULING\n-  if (optimize > 0 && flag_schedule_insns_after_reload)\n-    rest_of_handle_sched2 ();\n-#endif\n-\n #ifdef LEAF_REGISTERS\n   current_function_uses_only_leaf_regs\n     = optimize > 0 && only_leaf_regs_used () && leaf_function_p ();\n #endif\n \n+  if (targetm.late_rtl_prologue_epilogue)\n+    {\n+      /* On some machines, the prologue and epilogue code, or parts thereof,\n+\t can be represented as RTL.  Doing so lets us schedule insns between\n+\t it and the rest of the code and also allows delayed branch\n+\t scheduling to operate in the epilogue.  */\n+      thread_prologue_and_epilogue_insns (get_insns ());\n+      epilogue_completed = 1;\n+      if (optimize)\n+\tlife_analysis (dump_file, PROP_POSTRELOAD);\n+    }\n+\n+#ifdef INSN_SCHEDULING\n+  if (optimize > 0 && flag_schedule_insns_after_reload)\n+    rest_of_handle_sched2 ();\n+#endif\n+\n #ifdef STACK_REGS\n   rest_of_handle_stack_regs ();\n #endif"}, {"sha": "da4a1a03e83691d474f43a9561a69a6d557e4847", "filename": "gcc/reorg.c", "status": "modified", "additions": 28, "deletions": 9, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ac617d49582c168000b6e593e5c0b4bf2982ee0/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ac617d49582c168000b6e593e5c0b4bf2982ee0/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=9ac617d49582c168000b6e593e5c0b4bf2982ee0", "patch": "@@ -317,6 +317,20 @@ insn_sets_resource_p (rtx insn, struct resources *res,\n   mark_set_resources (insn, &insn_sets, 0, include_delayed_effects);\n   return resource_conflicts_p (&insn_sets, res);\n }\n+\n+/* Return TRUE if INSN is a return, possibly with a filled delay slot.  */\n+\n+static bool\n+return_insn_p (rtx insn)\n+{\n+  if (GET_CODE (insn) == JUMP_INSN && GET_CODE (PATTERN (insn)) == RETURN)\n+    return true;\n+\n+  if (GET_CODE (insn) == INSN && GET_CODE (PATTERN (insn)) == SEQUENCE)\n+    return return_insn_p (XVECEXP (PATTERN (insn), 0, 0));\n+\n+  return false;\n+}\n \f\n /* Find a label at the end of the function or before a RETURN.  If there is\n    none, make one.  */\n@@ -344,15 +358,13 @@ find_end_label (void)\n   /* When a target threads its epilogue we might already have a\n      suitable return insn.  If so put a label before it for the\n      end_of_function_label.  */\n-  if (GET_CODE (insn) == BARRIER\n-      && GET_CODE (PREV_INSN (insn)) == JUMP_INSN\n-      && GET_CODE (PATTERN (PREV_INSN (insn))) == RETURN)\n+  if (GET_CODE (insn) == BARRIER && return_insn_p (PREV_INSN (insn)))\n     {\n       rtx temp = PREV_INSN (PREV_INSN (insn));\n       end_of_function_label = gen_label_rtx ();\n       LABEL_NUSES (end_of_function_label) = 0;\n \n-      /* Put the label before an USE insns that may proceed the RETURN insn.  */\n+      /* Put the label before an USE insn that may precede the RETURN insn.  */\n       while (GET_CODE (temp) == USE)\n \ttemp = PREV_INSN (temp);\n \n@@ -368,8 +380,7 @@ find_end_label (void)\n       /* If the basic block reorder pass moves the return insn to\n \t some other place try to locate it again and put our\n \t end_of_function_label there.  */\n-      while (insn && ! (GET_CODE (insn) == JUMP_INSN\n-\t\t        && (GET_CODE (PATTERN (insn)) == RETURN)))\n+      while (insn && ! return_insn_p (insn))\n \tinsn = PREV_INSN (insn);\n       if (insn)\n \t{\n@@ -3275,10 +3286,18 @@ relax_delay_slots (rtx first)\n \t    {\n \t      target_label = JUMP_LABEL (XVECEXP (PATTERN (trial), 0, 0));\n \t      if (target_label == 0)\n-\t\ttarget_label = find_end_label ();\n+\t\t{\n+\t\t  target_label = find_end_label ();\n+\t\t  /* The following condition may be true if TRIAL contains\n+\t\t     the unique RETURN.  In this case, threading would be\n+\t\t     a nop and we would enter an infinite loop if we did it.  */\n+\t\t  if (next_active_insn (target_label) == trial)\n+\t\t    target_label = 0;\n+\t\t}\n \n-\t      if (redirect_with_delay_slots_safe_p (delay_insn, target_label,\n-\t\t\t\t\t\t    insn))\n+\t      if (target_label\n+\t\t  && redirect_with_delay_slots_safe_p (delay_insn, target_label,\n+\t\t\t\t\t\t       insn))\n \t\t{\n \t\t  reorg_redirect_jump (delay_insn, target_label);\n \t\t  next = insn;"}, {"sha": "fbc84b6d421371c37ab60e1e4182260c1bce3b1e", "filename": "gcc/target-def.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ac617d49582c168000b6e593e5c0b4bf2982ee0/gcc%2Ftarget-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ac617d49582c168000b6e593e5c0b4bf2982ee0/gcc%2Ftarget-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-def.h?ref=9ac617d49582c168000b6e593e5c0b4bf2982ee0", "patch": "@@ -366,6 +366,8 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n #define TARGET_GIMPLIFY_VA_ARG_EXPR std_gimplify_va_arg_expr\n #endif\n \n+#define TARGET_LATE_RTL_PROLOGUE_EPILOGUE false\n+\n #define TARGET_CALLS {\t\t\t\t\t\t\\\n    TARGET_PROMOTE_FUNCTION_ARGS,\t\t\t\t\\\n    TARGET_PROMOTE_FUNCTION_RETURN,\t\t\t\t\\\n@@ -471,6 +473,7 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n   TARGET_ASM_FILE_START_FILE_DIRECTIVE,\t\t\\\n   TARGET_HANDLE_PRAGMA_REDEFINE_EXTNAME,\t\\\n   TARGET_HANDLE_PRAGMA_EXTERN_PREFIX,\t\t\\\n+  TARGET_LATE_RTL_PROLOGUE_EPILOGUE,\t\t\\\n }\n \n #include \"hooks.h\""}, {"sha": "300ef57063d2a9b31fd8300d7fdb13e86737838a", "filename": "gcc/target.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ac617d49582c168000b6e593e5c0b4bf2982ee0/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ac617d49582c168000b6e593e5c0b4bf2982ee0/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=9ac617d49582c168000b6e593e5c0b4bf2982ee0", "patch": "@@ -521,6 +521,11 @@ struct gcc_target\n   /* True if #pragma extern_prefix is to be supported.  */\n   bool handle_pragma_extern_prefix;\n \n+  /* True if the RTL prologue and epilogue should be expanded after all\n+     passes that modify the instructions (and not merely reorder them)\n+     have been run.  */\n+  bool late_rtl_prologue_epilogue;\n+\n   /* Leave the boolean fields at the end.  */\n };\n "}]}