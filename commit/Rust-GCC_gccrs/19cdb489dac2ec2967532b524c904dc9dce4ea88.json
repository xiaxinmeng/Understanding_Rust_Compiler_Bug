{"sha": "19cdb489dac2ec2967532b524c904dc9dce4ea88", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTljZGI0ODlkYWMyZWMyOTY3NTMyYjUyNGM5MDRkYzlkY2U0ZWE4OA==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2013-09-27T19:33:52Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2013-09-27T19:33:52Z"}, "message": "rs6000.c (rs6000_hard_regno_mode_ok): Allow DFmode...\n\n[gcc]\n2013-09-27  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\t* config/rs6000/rs6000.c (rs6000_hard_regno_mode_ok): Allow\n\tDFmode, DImode, and SFmode in the upper VSX registers based on the\n\t-mupper-regs-{df,sf} flags.  Fix wu constraint to be ALTIVEC_REGS\n\tif -mpower8-vector.  Combine -mvsx-timode handling with the rest\n\tof the VSX register handling.\n\n\t* config/rs6000/rs6000.md (f32_lv): Use %x0 for VSX regsters.\n\t(f32_sv): Likewise.\n\t(zero_extendsidi2_lfiwzx): Add support for loading into the\n\tAltivec registers with -mpower8-vector.  Use wu/wv constraints to\n\tonly do VSX memory options on Altivec registers.\n\t(extendsidi2_lfiwax): Likewise.\n\t(extendsfdf2_fpr): Likewise.\n\t(mov<mode>_hardfloat, SF/SD modes): Likewise.\n\t(mov<mode>_hardfloat32, DF/DD modes): Likewise.\n\t(mov<mode>_hardfloat64, DF/DD modes): Likewise.\n\t(movdi_internal64): Likewise.\n\n[gcc/testsuite]\n2013-09-27  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\t* gcc.target/powerpc/p8vector-ldst.c: New test for -mupper-regs-sf\n\tand -mupper-regs-df.\n\nFrom-SVN: r202984", "tree": {"sha": "57bd4201f7f23a7459b159408dd7f0545ef4f526", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/57bd4201f7f23a7459b159408dd7f0545ef4f526"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/19cdb489dac2ec2967532b524c904dc9dce4ea88", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19cdb489dac2ec2967532b524c904dc9dce4ea88", "html_url": "https://github.com/Rust-GCC/gccrs/commit/19cdb489dac2ec2967532b524c904dc9dce4ea88", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19cdb489dac2ec2967532b524c904dc9dce4ea88/comments", "author": null, "committer": null, "parents": [{"sha": "8bcd5487e589c17afc77c982589247b106caba73", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8bcd5487e589c17afc77c982589247b106caba73", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8bcd5487e589c17afc77c982589247b106caba73"}], "stats": {"total": 186, "additions": 129, "deletions": 57}, "files": [{"sha": "d7f20cb367783237606ac930e2da79abb381947b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19cdb489dac2ec2967532b524c904dc9dce4ea88/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19cdb489dac2ec2967532b524c904dc9dce4ea88/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=19cdb489dac2ec2967532b524c904dc9dce4ea88", "patch": "@@ -1,3 +1,23 @@\n+2013-09-27  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* config/rs6000/rs6000.c (rs6000_hard_regno_mode_ok): Allow\n+\tDFmode, DImode, and SFmode in the upper VSX registers based on the\n+\t-mupper-regs-{df,sf} flags.  Fix wu constraint to be ALTIVEC_REGS\n+\tif -mpower8-vector.  Combine -mvsx-timode handling with the rest\n+\tof the VSX register handling.\n+\n+\t* config/rs6000/rs6000.md (f32_lv): Use %x0 for VSX regsters.\n+\t(f32_sv): Likewise.\n+\t(zero_extendsidi2_lfiwzx): Add support for loading into the\n+\tAltivec registers with -mpower8-vector.  Use wu/wv constraints to\n+\tonly do VSX memory options on Altivec registers.\n+\t(extendsidi2_lfiwax): Likewise.\n+\t(extendsfdf2_fpr): Likewise.\n+\t(mov<mode>_hardfloat, SF/SD modes): Likewise.\n+\t(mov<mode>_hardfloat32, DF/DD modes): Likewise.\n+\t(mov<mode>_hardfloat64, DF/DD modes): Likewise.\n+\t(movdi_internal64): Likewise.\n+\n 2013-09-27  Xinliang David Li  <davidxl@google.com>\n \n \t* opts.c (finish_options): Adjust parameters"}, {"sha": "4197687c083ef986d106452d4b395948b5952e69", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 32, "deletions": 15, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19cdb489dac2ec2967532b524c904dc9dce4ea88/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19cdb489dac2ec2967532b524c904dc9dce4ea88/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=19cdb489dac2ec2967532b524c904dc9dce4ea88", "patch": "@@ -1626,19 +1626,28 @@ rs6000_hard_regno_mode_ok (int regno, enum machine_mode mode)\n \n   /* VSX registers that overlap the FPR registers are larger than for non-VSX\n      implementations.  Don't allow an item to be split between a FP register\n-     and an Altivec register.  */\n-  if (VECTOR_MEM_VSX_P (mode))\n+     and an Altivec register.  Allow TImode in all VSX registers if the user\n+     asked for it.  */\n+  if (TARGET_VSX && VSX_REGNO_P (regno)\n+      && (VECTOR_MEM_VSX_P (mode)\n+\t  || (TARGET_VSX_SCALAR_FLOAT && mode == SFmode)\n+\t  || (TARGET_VSX_SCALAR_DOUBLE && (mode == DFmode || mode == DImode))\n+\t  || (TARGET_VSX_TIMODE && mode == TImode)))\n     {\n       if (FP_REGNO_P (regno))\n \treturn FP_REGNO_P (last_regno);\n \n       if (ALTIVEC_REGNO_P (regno))\n-\treturn ALTIVEC_REGNO_P (last_regno);\n-    }\n+\t{\n+\t  if (mode == SFmode && !TARGET_UPPER_REGS_SF)\n+\t    return 0;\n \n-  /* Allow TImode in all VSX registers if the user asked for it.  */\n-  if (mode == TImode && TARGET_VSX_TIMODE && VSX_REGNO_P (regno))\n-    return 1;\n+\t  if ((mode == DFmode || mode == DImode) && !TARGET_UPPER_REGS_DF)\n+\t    return 0;\n+\n+\t  return ALTIVEC_REGNO_P (last_regno);\n+\t}\n+    }\n \n   /* The GPRs can hold any mode, but values bigger than one register\n      cannot go past R31.  */\n@@ -2385,13 +2394,17 @@ rs6000_init_hard_regno_mode_ok (bool global_init_p)\n       rs6000_constraints[RS6000_CONSTRAINT_wa] = VSX_REGS;\n       rs6000_constraints[RS6000_CONSTRAINT_wd] = VSX_REGS;\n       rs6000_constraints[RS6000_CONSTRAINT_wf] = VSX_REGS;\n-      rs6000_constraints[RS6000_CONSTRAINT_wv] = ALTIVEC_REGS;\n \n       if (TARGET_VSX_TIMODE)\n \trs6000_constraints[RS6000_CONSTRAINT_wt] = VSX_REGS;\n \n-      rs6000_constraints[RS6000_CONSTRAINT_ws]\n-\t= (TARGET_UPPER_REGS_DF) ? VSX_REGS : FLOAT_REGS;\n+      if (TARGET_UPPER_REGS_DF)\n+\t{\n+\t  rs6000_constraints[RS6000_CONSTRAINT_ws] = VSX_REGS;\n+\t  rs6000_constraints[RS6000_CONSTRAINT_wv] = ALTIVEC_REGS;\n+\t}\n+      else\n+\trs6000_constraints[RS6000_CONSTRAINT_ws] = FLOAT_REGS;\n     }\n \n   /* Add conditional constraints based on various options, to allow us to\n@@ -2411,12 +2424,16 @@ rs6000_init_hard_regno_mode_ok (bool global_init_p)\n   if (TARGET_POWERPC64)\n     rs6000_constraints[RS6000_CONSTRAINT_wr] = GENERAL_REGS;\n \n-  if (TARGET_P8_VECTOR)\n+  if (TARGET_P8_VECTOR && TARGET_UPPER_REGS_SF)\n+    {\n+      rs6000_constraints[RS6000_CONSTRAINT_wu] = ALTIVEC_REGS;\n+      rs6000_constraints[RS6000_CONSTRAINT_wy] = VSX_REGS;\n+      rs6000_constraints[RS6000_CONSTRAINT_ww] = VSX_REGS;\n+    }\n+  else if (TARGET_P8_VECTOR)\n     {\n-      rs6000_constraints[RS6000_CONSTRAINT_wv] = ALTIVEC_REGS;\n-      rs6000_constraints[RS6000_CONSTRAINT_wy]\n-\t= rs6000_constraints[RS6000_CONSTRAINT_ww]\n-\t= (TARGET_UPPER_REGS_SF) ? VSX_REGS : FLOAT_REGS;\n+      rs6000_constraints[RS6000_CONSTRAINT_wy] = FLOAT_REGS;\n+      rs6000_constraints[RS6000_CONSTRAINT_ww] = FLOAT_REGS;\n     }\n   else if (TARGET_VSX)\n     rs6000_constraints[RS6000_CONSTRAINT_ww] = FLOAT_REGS;"}, {"sha": "3ab031622d6d1bcbbe3c310520e5fafb1600b2c2", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 30, "deletions": 42, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19cdb489dac2ec2967532b524c904dc9dce4ea88/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19cdb489dac2ec2967532b524c904dc9dce4ea88/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=19cdb489dac2ec2967532b524c904dc9dce4ea88", "patch": "@@ -314,13 +314,13 @@\n (define_mode_attr f32_lr [(SF \"f\")\t\t (SD \"wz\")])\n (define_mode_attr f32_lm [(SF \"m\")\t\t (SD \"Z\")])\n (define_mode_attr f32_li [(SF \"lfs%U1%X1 %0,%1\") (SD \"lfiwzx %0,%y1\")])\n-(define_mode_attr f32_lv [(SF \"lxsspx %0,%y1\")\t (SD \"lxsiwzx %0,%y1\")])\n+(define_mode_attr f32_lv [(SF \"lxsspx %x0,%y1\")\t (SD \"lxsiwzx %x0,%y1\")])\n \n ; Definitions for store from 32-bit fpr register\n (define_mode_attr f32_sr [(SF \"f\")\t\t  (SD \"wx\")])\n (define_mode_attr f32_sm [(SF \"m\")\t\t  (SD \"Z\")])\n (define_mode_attr f32_si [(SF \"stfs%U0%X0 %1,%0\") (SD \"stfiwx %1,%y0\")])\n-(define_mode_attr f32_sv [(SF \"stxsspx %1,%y0\")\t  (SD \"stxsiwzx %1,%y0\")])\n+(define_mode_attr f32_sv [(SF \"stxsspx %x1,%y0\")  (SD \"stxsiwzx %x1,%y0\")])\n \n ; Definitions for 32-bit fpr direct move\n (define_mode_attr f32_dm [(SF \"wn\") (SD \"wm\")])\n@@ -541,7 +541,7 @@\n   \"\")\n \n (define_insn \"*zero_extendsidi2_lfiwzx\"\n-  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r,r,??wm,!wz,!wm\")\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r,r,??wm,!wz,!wu\")\n \t(zero_extend:DI (match_operand:SI 1 \"reg_or_mem_operand\" \"m,r,r,Z,Z\")))]\n   \"TARGET_POWERPC64 && TARGET_LFIWZX\"\n   \"@\n@@ -711,7 +711,7 @@\n   \"\")\n \n (define_insn \"*extendsidi2_lfiwax\"\n-  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r,r,??wm,!wl,!wm\")\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r,r,??wm,!wl,!wu\")\n \t(sign_extend:DI (match_operand:SI 1 \"lwa_operand\" \"m,r,r,Z,Z\")))]\n   \"TARGET_POWERPC64 && TARGET_LFIWAX\"\n   \"@\n@@ -5066,13 +5066,16 @@\n   \"\")\n \n (define_insn_and_split \"*extendsfdf2_fpr\"\n-  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=d,?d,d\")\n-\t(float_extend:DF (match_operand:SF 1 \"reg_or_mem_operand\" \"0,f,m\")))]\n+  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=d,?d,d,wy,?wy,wv\")\n+\t(float_extend:DF (match_operand:SF 1 \"reg_or_mem_operand\" \"0,f,m,0,wz,Z\")))]\n   \"TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT\"\n   \"@\n    #\n    fmr %0,%1\n-   lfs%U1%X1 %0,%1\"\n+   lfs%U1%X1 %0,%1\n+   #\n+   xxlor %x0,%x1,%x1\n+   lxsspx %x0,%y1\"\n   \"&& reload_completed && REG_P (operands[1]) && REGNO (operands[0]) == REGNO (operands[1])\"\n   [(const_int 0)]\n {\n@@ -5088,7 +5091,16 @@\n \t (if_then_else\n \t   (match_test \"update_address_mem (operands[1], VOIDmode)\")\n \t   (const_string \"fpload_u\")\n-\t   (const_string \"fpload\")))])])\n+\t   (const_string \"fpload\")))\n+       (const_string \"fp\")\n+       (const_string \"vecsimple\")\n+       (if_then_else\n+\t(match_test \"update_indexed_address_mem (operands[1], VOIDmode)\")\n+\t(const_string \"fpload_ux\")\n+\t(if_then_else\n+\t (match_test \"update_address_mem (operands[1], VOIDmode)\")\n+\t (const_string \"fpload_u\")\n+\t (const_string \"fpload\")))])])\n \n (define_expand \"truncdfsf2\"\n   [(set (match_operand:SF 0 \"gpc_reg_operand\" \"\")\n@@ -9290,8 +9302,8 @@\n }\")\n \n (define_insn \"mov<mode>_hardfloat\"\n-  [(set (match_operand:FMOVE32 0 \"nonimmediate_operand\" \"=!r,!r,m,f,wa,wa,<f32_lr>,<f32_sm>,wm,Z,?<f32_dm>,?r,*c*l,!r,*h,!r,!r\")\n-\t(match_operand:FMOVE32 1 \"input_operand\" \"r,m,r,f,wa,j,<f32_lm>,<f32_sr>,Z,wm,r,<f32_dm>,r,h,0,G,Fn\"))]\n+  [(set (match_operand:FMOVE32 0 \"nonimmediate_operand\" \"=!r,!r,m,f,wa,wa,<f32_lr>,<f32_sm>,wu,Z,?<f32_dm>,?r,*c*l,!r,*h,!r,!r\")\n+\t(match_operand:FMOVE32 1 \"input_operand\" \"r,m,r,f,wa,j,<f32_lm>,<f32_sr>,Z,wu,r,<f32_dm>,r,h,0,G,Fn\"))]\n   \"(gpc_reg_operand (operands[0], <MODE>mode)\n    || gpc_reg_operand (operands[1], <MODE>mode))\n    && (TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_SINGLE_FLOAT)\"\n@@ -9492,8 +9504,8 @@\n ;; reloading.\n \n (define_insn \"*mov<mode>_hardfloat32\"\n-  [(set (match_operand:FMOVE64 0 \"nonimmediate_operand\" \"=m,d,d,ws,?wa,Z,?Z,ws,?wa,wa,Y,r,!r,!r,!r,!r\")\n-\t(match_operand:FMOVE64 1 \"input_operand\" \"d,m,d,Z,Z,ws,wa,ws,wa,j,r,Y,r,G,H,F\"))]\n+  [(set (match_operand:FMOVE64 0 \"nonimmediate_operand\" \"=m,d,d,wv,Z,wa,wa,Y,r,!r,!r,!r,!r\")\n+\t(match_operand:FMOVE64 1 \"input_operand\" \"d,m,d,Z,wv,wa,j,r,Y,r,G,H,F\"))]\n   \"! TARGET_POWERPC64 && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT \n    && (gpc_reg_operand (operands[0], <MODE>mode)\n        || gpc_reg_operand (operands[1], <MODE>mode))\"\n@@ -9502,11 +9514,8 @@\n    lfd%U1%X1 %0,%1\n    fmr %0,%1\n    lxsd%U1x %x0,%y1\n-   lxsd%U1x %x0,%y1\n-   stxsd%U0x %x1,%y0\n    stxsd%U0x %x1,%y0\n    xxlor %x0,%x1,%x1\n-   xxlor %x0,%x1,%x1\n    xxlxor %x0,%x0,%x0\n    #\n    #\n@@ -9534,28 +9543,19 @@\n \t (match_test \"update_indexed_address_mem (operands[1], VOIDmode)\")\n \t (const_string \"fpload_ux\")\n \t (const_string \"fpload\"))\n-       (if_then_else\n-\t (match_test \"update_indexed_address_mem (operands[1], VOIDmode)\")\n-\t (const_string \"fpload_ux\")\n-\t (const_string \"fpload\"))\n-       (if_then_else\n-\t (match_test \"update_indexed_address_mem (operands[0], VOIDmode)\")\n-\t (const_string \"fpstore_ux\")\n-\t (const_string \"fpstore\"))\n        (if_then_else\n \t (match_test \"update_indexed_address_mem (operands[0], VOIDmode)\")\n \t (const_string \"fpstore_ux\")\n \t (const_string \"fpstore\"))\n        (const_string \"vecsimple\")\n        (const_string \"vecsimple\")\n-       (const_string \"vecsimple\")\n        (const_string \"store\")\n        (const_string \"load\")\n        (const_string \"two\")\n        (const_string \"fp\")\n        (const_string \"fp\")\n        (const_string \"*\")])\n-   (set_attr \"length\" \"4,4,4,4,4,4,4,4,4,4,8,8,8,8,12,16\")])\n+   (set_attr \"length\" \"4,4,4,4,4,4,4,8,8,8,8,12,16\")])\n \n (define_insn \"*mov<mode>_softfloat32\"\n   [(set (match_operand:FMOVE64 0 \"nonimmediate_operand\" \"=Y,r,r,r,r,r\")\n@@ -9572,8 +9572,8 @@\n ; ld/std require word-aligned displacements -> 'Y' constraint.\n ; List Y->r and r->Y before r->r for reload.\n (define_insn \"*mov<mode>_hardfloat64\"\n-  [(set (match_operand:FMOVE64 0 \"nonimmediate_operand\" \"=m,d,d,ws,?wa,Z,?Z,ws,?wa,wa,Y,r,!r,*c*l,!r,*h,!r,!r,!r,r,wg,r,wm\")\n-\t(match_operand:FMOVE64 1 \"input_operand\" \"d,m,d,Z,Z,ws,wa,ws,wa,j,r,Y,r,r,h,0,G,H,F,wg,r,wm,r\"))]\n+  [(set (match_operand:FMOVE64 0 \"nonimmediate_operand\" \"=m,d,d,wv,Z,wa,wa,Y,r,!r,*c*l,!r,*h,!r,!r,!r,r,wg,r,wm\")\n+\t(match_operand:FMOVE64 1 \"input_operand\" \"d,m,d,Z,wv,wa,j,r,Y,r,r,h,0,G,H,F,wg,r,wm,r\"))]\n   \"TARGET_POWERPC64 && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT\n    && (gpc_reg_operand (operands[0], <MODE>mode)\n        || gpc_reg_operand (operands[1], <MODE>mode))\"\n@@ -9582,11 +9582,8 @@\n    lfd%U1%X1 %0,%1\n    fmr %0,%1\n    lxsd%U1x %x0,%y1\n-   lxsd%U1x %x0,%y1\n-   stxsd%U0x %x1,%y0\n    stxsd%U0x %x1,%y0\n    xxlor %x0,%x1,%x1\n-   xxlor %x0,%x1,%x1\n    xxlxor %x0,%x0,%x0\n    std%U0%X0 %1,%0\n    ld%U1%X1 %0,%1\n@@ -9621,21 +9618,12 @@\n \t (match_test \"update_indexed_address_mem (operands[1], VOIDmode)\")\n \t (const_string \"fpload_ux\")\n \t (const_string \"fpload\"))\n-       (if_then_else\n-\t (match_test \"update_indexed_address_mem (operands[1], VOIDmode)\")\n-\t (const_string \"fpload_ux\")\n-\t (const_string \"fpload\"))\n-       (if_then_else\n-\t (match_test \"update_indexed_address_mem (operands[0], VOIDmode)\")\n-\t (const_string \"fpstore_ux\")\n-\t (const_string \"fpstore\"))\n        (if_then_else\n \t (match_test \"update_indexed_address_mem (operands[0], VOIDmode)\")\n \t (const_string \"fpstore_ux\")\n \t (const_string \"fpstore\"))\n        (const_string \"vecsimple\")\n        (const_string \"vecsimple\")\n-       (const_string \"vecsimple\")\n        (if_then_else\n \t (match_test \"update_indexed_address_mem (operands[0], VOIDmode)\")\n \t (const_string \"store_ux\")\n@@ -9661,7 +9649,7 @@\n        (const_string \"mffgpr\")\n        (const_string \"mftgpr\")\n        (const_string \"mffgpr\")])\n-   (set_attr \"length\" \"4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,8,12,16,4,4,4,4\")])\n+   (set_attr \"length\" \"4,4,4,4,4,4,4,4,4,4,4,4,4,8,12,16,4,4,4,4\")])\n \n (define_insn \"*mov<mode>_softfloat64\"\n   [(set (match_operand:FMOVE64 0 \"nonimmediate_operand\" \"=Y,r,r,cl,r,r,r,r,*h\")\n@@ -10324,8 +10312,8 @@\n { rs6000_split_multireg_move (operands[0], operands[1]); DONE; })\n \n (define_insn \"*movdi_internal64\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=Y,r,r,r,r,r,?m,?*d,?*d,?Z,?wa,?wa,r,*h,*h,?wa,r,?*wg,r,?*wm\")\n-\t(match_operand:DI 1 \"input_operand\" \"r,Y,r,I,L,nF,d,m,d,wa,Z,wa,*h,r,0,O,*wg,r,*wm,r\"))]\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=Y,r,r,r,r,r,?m,?*d,?*d,?Z,?wv,?wa,r,*h,*h,?wa,r,?*wg,r,?*wm\")\n+\t(match_operand:DI 1 \"input_operand\" \"r,Y,r,I,L,nF,d,m,d,wv,Z,wa,*h,r,0,O,*wg,r,*wm,r\"))]\n   \"TARGET_POWERPC64\n    && (gpc_reg_operand (operands[0], DImode)\n        || gpc_reg_operand (operands[1], DImode))\""}, {"sha": "0543842af205a8102bcac73fa8d94b28e3dbd69f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19cdb489dac2ec2967532b524c904dc9dce4ea88/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19cdb489dac2ec2967532b524c904dc9dce4ea88/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=19cdb489dac2ec2967532b524c904dc9dce4ea88", "patch": "@@ -1,3 +1,8 @@\n+2013-09-27  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* gcc.target/powerpc/p8vector-ldst.c: New test for -mupper-regs-sf\n+\tand -mupper-regs-df.\n+\n 2013-09-27  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR middle-end/58551"}, {"sha": "d0b3eb09ef7e0c64fbfc6cae220e82b0dfd52e6a", "filename": "gcc/testsuite/gcc.target/powerpc/p8vector-ldst.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19cdb489dac2ec2967532b524c904dc9dce4ea88/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fp8vector-ldst.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19cdb489dac2ec2967532b524c904dc9dce4ea88/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fp8vector-ldst.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fp8vector-ldst.c?ref=19cdb489dac2ec2967532b524c904dc9dce4ea88", "patch": "@@ -0,0 +1,42 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target powerpc_p8vector_ok } */\n+/* { dg-options \"-mcpu=power8 -O2 -mupper-regs-df -mupper-regs-sf\" } */\n+\n+float load_sf (float *p)\n+{\n+  float f = *p;\n+  __asm__ (\"# reg %x0\" : \"+v\" (f));\n+  return f;\n+}\n+\n+double load_df (double *p)\n+{\n+  double d = *p;\n+  __asm__ (\"# reg %x0\" : \"+v\" (d));\n+  return d;\n+}\n+\n+double load_dfsf (float *p)\n+{\n+  double d = (double) *p;\n+  __asm__ (\"# reg %x0\" : \"+v\" (d));\n+  return d;\n+}\n+\n+void store_sf (float *p, float f)\n+{\n+  __asm__ (\"# reg %x0\" : \"+v\" (f));\n+  *p = f;\n+}\n+\n+void store_df (double *p, double d)\n+{\n+  __asm__ (\"# reg %x0\" : \"+v\" (d));\n+  *p = d;\n+}\n+\n+/* { dg-final { scan-assembler-times \"lxsspx\"  2 } } */\n+/* { dg-final { scan-assembler-times \"lxsdx\"   1 } } */\n+/* { dg-final { scan-assembler-times \"stxsspx\" 1 } } */\n+/* { dg-final { scan-assembler-times \"stxsdx\"  1 } } */"}]}