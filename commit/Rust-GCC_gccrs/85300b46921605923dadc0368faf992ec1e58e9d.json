{"sha": "85300b46921605923dadc0368faf992ec1e58e9d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODUzMDBiNDY5MjE2MDU5MjNkYWRjMDM2OGZhZjk5MmVjMWU1OGU5ZA==", "commit": {"author": {"name": "Daniel Berlin", "email": "dberlin@dberlin.org", "date": "2006-02-06T14:22:00Z"}, "committer": {"name": "Daniel Berlin", "email": "dberlin@gcc.gnu.org", "date": "2006-02-06T14:22:00Z"}, "message": "tree-ssa-pre.c (bb_value_sets_t): Add antic_safe_loads.\n\n2006-02-06  Daniel Berlin  <dberlin@dberlin.org>\n\n\t* tree-ssa-pre.c (bb_value_sets_t): Add antic_safe_loads.\n\t(ANTIC_SAFE_LOADS): New macro.\n\t(find_or_generate_expression): Add prototype.\n\t(set_contains_value): Allow null set for sake of not always having\n\tto allocate ANTIC_SAFE_LOADS.\n\t(phi_translate): Move placement of AGGREGATE_TYPE_P check.\n\tAllow COMPONENT_REF too.\n\t(valid_in_set): Allow COMPONENT_REF.\n\tCheck ANTIC_SAFE_LOADS too.\n\t(compute_antic_aux): Print out ANTIC_SAFE_LOADS.\n\t(compute_rvuse_and_antic_safe): Add ANTIC_SAFE computation, and\n\trename.\n\t(can_PRE_operation): Add COMPONENT_REF.\n\t(create_component_ref_by_pieces): New function.\n\t(create_expression_by_pieces): Use create_component_ref_by_pieces.\n\t(insert_aux): Move AGGREGATE_TYPE_P check here.\n\t(compute_avail): Set bb local stmt uids.\n\t(pass_pre): Use TODO_update_ssa_only_virtuals.\n\n2006-02-06  Daniel Berlin  <dberlin@dberlin.org>\n\n\t* gcc.dg/tree-ssa/loadpre10.c: New test.\n\t* gcc.dg/tree-ssa/loadpre11.c: Ditto.\n\t* gcc.dg/tree-ssa/loadpre6.c: Expect one more elimination.\n\t* gcc.dg/tree-ssa/loadpre4.c: This should pass now.\n\nFrom-SVN: r110644", "tree": {"sha": "ee74efc37bf5d056e4f314db64056e617cb96387", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ee74efc37bf5d056e4f314db64056e617cb96387"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/85300b46921605923dadc0368faf992ec1e58e9d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85300b46921605923dadc0368faf992ec1e58e9d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/85300b46921605923dadc0368faf992ec1e58e9d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85300b46921605923dadc0368faf992ec1e58e9d/comments", "author": {"login": "dberlin", "id": 324715, "node_id": "MDQ6VXNlcjMyNDcxNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/324715?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dberlin", "html_url": "https://github.com/dberlin", "followers_url": "https://api.github.com/users/dberlin/followers", "following_url": "https://api.github.com/users/dberlin/following{/other_user}", "gists_url": "https://api.github.com/users/dberlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/dberlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dberlin/subscriptions", "organizations_url": "https://api.github.com/users/dberlin/orgs", "repos_url": "https://api.github.com/users/dberlin/repos", "events_url": "https://api.github.com/users/dberlin/events{/privacy}", "received_events_url": "https://api.github.com/users/dberlin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8a46b94f6ce2aeeb147184fbeaee8d6fb2e7a256", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a46b94f6ce2aeeb147184fbeaee8d6fb2e7a256", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a46b94f6ce2aeeb147184fbeaee8d6fb2e7a256"}], "stats": {"total": 328, "additions": 296, "deletions": 32}, "files": [{"sha": "4dc53896671e20dfe32b2635dbf62a9fee37d37f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85300b46921605923dadc0368faf992ec1e58e9d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85300b46921605923dadc0368faf992ec1e58e9d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=85300b46921605923dadc0368faf992ec1e58e9d", "patch": "@@ -1,3 +1,24 @@\n+2006-02-06  Daniel Berlin  <dberlin@dberlin.org>\n+\n+\t* tree-ssa-pre.c (bb_value_sets_t): Add antic_safe_loads.\n+\t(ANTIC_SAFE_LOADS): New macro.\n+\t(find_or_generate_expression): Add prototype.\n+\t(set_contains_value): Allow null set for sake of not always having\n+\tto allocate ANTIC_SAFE_LOADS.\n+\t(phi_translate): Move placement of AGGREGATE_TYPE_P check.\n+\tAllow COMPONENT_REF too.\n+\t(valid_in_set): Allow COMPONENT_REF.\n+\tCheck ANTIC_SAFE_LOADS too.\n+\t(compute_antic_aux): Print out ANTIC_SAFE_LOADS.\n+\t(compute_rvuse_and_antic_safe): Add ANTIC_SAFE computation, and\n+\trename.\n+\t(can_PRE_operation): Add COMPONENT_REF.\n+\t(create_component_ref_by_pieces): New function.\n+\t(create_expression_by_pieces): Use create_component_ref_by_pieces.\n+\t(insert_aux): Move AGGREGATE_TYPE_P check here.\n+\t(compute_avail): Set bb local stmt uids.\n+\t(pass_pre): Use TODO_update_ssa_only_virtuals.\n+\t\n 2006-02-06  Ben Elliston  <bje@au.ibm.com>\n \n \t* configure.ac: Unconditionally disable decimal float by default."}, {"sha": "624e5985622e9cca7ba5cb92e014e1f04b9e3767", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85300b46921605923dadc0368faf992ec1e58e9d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85300b46921605923dadc0368faf992ec1e58e9d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=85300b46921605923dadc0368faf992ec1e58e9d", "patch": "@@ -1,3 +1,10 @@\n+2006-02-06  Daniel Berlin  <dberlin@dberlin.org>\n+\n+\t* gcc.dg/tree-ssa/loadpre10.c: New test.\n+\t* gcc.dg/tree-ssa/loadpre11.c: Ditto.\n+\t* gcc.dg/tree-ssa/loadpre6.c: Expect one more elimination.\n+\t* gcc.dg/tree-ssa/loadpre4.c: This should pass now.\n+\n 2006-02-06  Francois-Xavier Coudert  <coudert@clipper.ens.fr>\n \n \tPR libfortran/24685"}, {"sha": "4147a702ae41716047f7333c07d9d9c4364deeb2", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loadpre10.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85300b46921605923dadc0368faf992ec1e58e9d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floadpre10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85300b46921605923dadc0368faf992ec1e58e9d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floadpre10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floadpre10.c?ref=85300b46921605923dadc0368faf992ec1e58e9d", "patch": "@@ -0,0 +1,49 @@\n+/* { dg-do compile } */ \n+/* { dg-options \"-O2 -fdump-tree-pre-stats\" } */\n+struct tree_common \n+{ \n+  int code; \n+}; \n+union tree_node \n+{ \n+  struct tree_common common; \n+}; \n+typedef union tree_node *tree; \n+ \n+extern tree test (tree, int, int); \n+extern tree foo (void); \n+extern void abort (void) __attribute__ ((__noreturn__)); \n+\n+/* Redundant loads of expr->common.code */\n+tree \n+test (tree expr, int t, int D17630) \n+{ \n+  int __i; \n+ \n+L0: \n+  if (expr->common.code != 142) goto L23; else goto L2; \n+ \n+L2: \n+  __i = 0; \n+  goto L10; \n+ \n+L10: \n+  __i = __i + 1; \n+  if (D17630 != __i) goto L8; else goto L19; \n+ \n+L8: \n+  if (t) goto L15; else goto L10; \n+ \n+L15: \n+  expr = foo (); \n+  if (expr->common.code != 142) goto L23; else goto L0; \n+ \n+L19: \n+  abort (); \n+ \n+L23: \n+  return expr; \n+} \n+/* { dg-final { scan-tree-dump-times \"Eliminated: 1\" 1 \"pre\"} } */\n+/* { dg-final { cleanup-tree-dump \"pre\" } } */\n+"}, {"sha": "2980ac0f38ec9a1ca346d74f68ebf88263bc7c3b", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loadpre11.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85300b46921605923dadc0368faf992ec1e58e9d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floadpre11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85300b46921605923dadc0368faf992ec1e58e9d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floadpre11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floadpre11.c?ref=85300b46921605923dadc0368faf992ec1e58e9d", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile } */ \n+/* { dg-options \"-O2 -fdump-tree-pre-stats\" } */\n+int *t;\n+int g(int);\n+int f(int tt)\n+{\n+    int *t1 = t;\n+    if (*t1)\n+      *t1 = 2;\n+    return g(*t1);\n+} \n+/* { dg-final { scan-tree-dump-times \"Eliminated: 1\" 1 \"pre\"} } */\n+/* { dg-final { cleanup-tree-dump \"pre\" } } */\n+"}, {"sha": "1e2660317baa514966f2ad0f825598abd57fd9e1", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loadpre4.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85300b46921605923dadc0368faf992ec1e58e9d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floadpre4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85300b46921605923dadc0368faf992ec1e58e9d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floadpre4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floadpre4.c?ref=85300b46921605923dadc0368faf992ec1e58e9d", "patch": "@@ -7,8 +7,6 @@ int main(int *a, int argc)\n   int i;\n   int d, e;\n \n-  /* With smarter load PRE, we'd be able to recompute the value at the \n-     kill point.  arguably not worth it.  */\n   for (i = 0; i < argc; i++)\n     {\n       e = *a;\n@@ -17,5 +15,5 @@ int main(int *a, int argc)\n   return d + e;\n }\n \n-/* { dg-final { scan-tree-dump-times \"Eliminated: 1\" 1 \"pre\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"Eliminated: 1\" 1 \"pre\"  } } */\n /* { dg-final { cleanup-tree-dump \"pre\" } } */"}, {"sha": "28a71a8e63ffcee1186608fbca270a39a40fc96f", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loadpre6.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85300b46921605923dadc0368faf992ec1e58e9d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floadpre6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85300b46921605923dadc0368faf992ec1e58e9d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floadpre6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floadpre6.c?ref=85300b46921605923dadc0368faf992ec1e58e9d", "patch": "@@ -30,6 +30,8 @@ foo (void)\n   abort ();\n }\n \n+/* There are some reloaded loads of *cell, and cell->common.chain on various\n+   branches.  */\n void __attribute__((noinline))\n remove_useless_vars (tree *unexpanded_var_list, int dump_file)\n {\n@@ -69,6 +71,6 @@ main (void)\n   remove_useless_vars (&unexpanded_var_list, 0);\n   return 0;\n }\n-/* { dg-final { scan-tree-dump-times \"Eliminated: 1\" 1 \"pre\" } } */\n+/* { dg-final { scan-tree-dump-times \"Eliminated: 2\" 1 \"pre\" } } */\n /* { dg-final { cleanup-tree-dump \"pre\" } } */\n "}, {"sha": "0df5a19ef97f288bf307255baf25b9fe2dcf1e96", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 201, "deletions": 28, "changes": 229, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85300b46921605923dadc0368faf992ec1e58e9d/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85300b46921605923dadc0368faf992ec1e58e9d/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=85300b46921605923dadc0368faf992ec1e58e9d", "patch": "@@ -53,6 +53,11 @@ Boston, MA 02110-1301, USA.  */\n       we can repair later on.\n    3. We can do back-substitution or smarter value numbering to catch\n       commutative expressions split up over multiple statements.\n+   4. ANTIC_SAFE_LOADS could be a lot smarter than it is now.\n+      Right now, it is simply calculating loads that occur before\n+      any store in a block, instead of loads that occur before\n+      stores that affect them.  This is relatively more expensive, and\n+      it's not clear how much more it will buy us.\n */   \n \n /* For ease of terminology, \"expression node\" in the below refers to\n@@ -258,6 +263,11 @@ typedef struct bb_value_sets\n   bitmap rvuse_out;\n   bitmap rvuse_gen;\n   bitmap rvuse_kill;\n+\n+  /* For actually occuring loads, as long as they occur before all the\n+     other stores in the block, we know they are antic at the top of\n+     the block, regardless of RVUSE_KILL.  */\n+  value_set_t antic_safe_loads;\n } *bb_value_sets_t;\n \n #define EXP_GEN(BB)\t((bb_value_sets_t) ((BB)->aux))->exp_gen\n@@ -270,6 +280,7 @@ typedef struct bb_value_sets\n #define RVUSE_KILL(BB)   ((bb_value_sets_t) ((BB)->aux))->rvuse_kill\n #define RVUSE_OUT(BB)    ((bb_value_sets_t) ((BB)->aux))->rvuse_out\n #define NEW_SETS(BB)\t((bb_value_sets_t) ((BB)->aux))->new_sets\n+#define ANTIC_SAFE_LOADS(BB) ((bb_value_sets_t) ((BB)->aux))->antic_safe_loads\n \n /* This structure is used to keep track of statistics on what\n    optimization PRE was able to perform.  */\n@@ -302,6 +313,7 @@ static bitmap_set_t bitmap_set_new (void);\n static value_set_t set_new  (bool);\n static bool is_undefined_value (tree);\n static tree create_expression_by_pieces (basic_block, tree, tree);\n+static tree find_or_generate_expression (basic_block, tree, tree);\n \n \n /* We can add and remove elements and entries to and from sets\n@@ -701,7 +713,7 @@ set_contains_value (value_set_t set, tree val)\n   if (is_gimple_min_invariant (val))\n     return true;\n   \n-  if (set->length == 0)\n+  if (!set || set->length == 0)\n     return false;\n   \n   return value_exists_in_set_bitmap (set, val);\n@@ -1102,6 +1114,18 @@ phi_translate (tree expr, value_set_t set, basic_block pred,\n \t\ttree newval;\n \t\tif (oldval)\n \t\t  {\n+\t\t    /* This may seem like a weird place for this\n+\t\t       check, but it's actually the easiest place to\n+\t\t       do it.  We can't do it lower on in the\n+\t\t       recursion because it's valid for pieces of a\n+\t\t       component ref to be of AGGREGATE_TYPE, as long\n+\t\t       as the outermost one is not.\n+\t\t       To avoid *that* case, we have a check for\n+\t\t       AGGREGATE_TYPE_P in insert_aux.  However, that\n+\t\t       check will *not* catch this case because here\n+\t\t       it occurs in the argument list.  */\n+\t\t    if (AGGREGATE_TYPE_P (TREE_TYPE (oldval)))\n+\t\t      return NULL;\n \t\t    newval = phi_translate (find_leader (set, oldval),\n \t\t\t\t\t    set, pred, phiblock);\n \t\t    if (newval == NULL)\n@@ -1160,7 +1184,7 @@ phi_translate (tree expr, value_set_t set, basic_block pred,\n \tVEC (tree, gc) * newvuses = NULL;\n \n \tif (TREE_CODE (expr) != INDIRECT_REF\n-\t    || AGGREGATE_TYPE_P (TREE_TYPE (expr)))\n+\t    && TREE_CODE (expr) != COMPONENT_REF)\n \t  return NULL;\n \n \tnewop1 = phi_translate (find_leader (set, oldop1),\n@@ -1435,12 +1459,11 @@ vuses_dies_in_block_x (VEC (tree, gc) *vuses, basic_block block)\n \n   for (i = 0; VEC_iterate (tree, vuses, i, vuse); i++)\n     {\n-      /* Any places where this is too conservative, are  places\n+      /* Any places where this is too conservative, are places\n \t where we created a new version and shouldn't have.  */\n \n       if (!bitmap_bit_p (RVUSE_IN (block), SSA_NAME_VERSION (vuse))\n-\t  || bitmap_bit_p (RVUSE_KILL (block), SSA_NAME_VERSION\n-\t\t\t   (vuse)))\n+\t  || bitmap_bit_p (RVUSE_KILL (block), SSA_NAME_VERSION (vuse)))\n \treturn true;\n     }\n   return false;\n@@ -1501,16 +1524,21 @@ valid_in_set (value_set_t set, tree expr, basic_block block)\n       \n     case tcc_reference:\n       {\n-\tif (TREE_CODE (expr) == INDIRECT_REF)\n+\tif (TREE_CODE (expr) == INDIRECT_REF \n+\t    || TREE_CODE (expr) == COMPONENT_REF)\n \t  {\n \t    tree op0 = TREE_OPERAND (expr, 0);\n \t    if (is_gimple_min_invariant (op0)\n \t\t|| TREE_CODE (op0) == VALUE_HANDLE)\n \t      {\n \t\tbool retval = set_contains_value (set, op0);\n \t\tif (retval)\n-\t\t  return !vuses_dies_in_block_x (VALUE_HANDLE_VUSES (vh),\n+\t\t  {\n+\t\t    return set_contains_value (ANTIC_SAFE_LOADS (block),\n+\t\t\t\t\t       vh)\n+\t\t      || !vuses_dies_in_block_x (VALUE_HANDLE_VUSES (vh),\n \t\t\t\t\t\t block);\n+\t\t  }\n \t\treturn false;\n \t      }\n \t  }\n@@ -1649,7 +1677,12 @@ compute_antic_aux (basic_block block, bool block_has_abnormal_pred_edge)\n     {\n       if (ANTIC_OUT)\n \tprint_value_set (dump_file, ANTIC_OUT, \"ANTIC_OUT\", block->index);\n+\n+      if (ANTIC_SAFE_LOADS (block))\n+\tprint_value_set (dump_file, ANTIC_SAFE_LOADS (block), \n+\t\t\t \"ANTIC_SAFE_LOADS\", block->index);\n       print_value_set (dump_file, ANTIC_IN (block), \"ANTIC_IN\", block->index);\n+\n       if (S)\n \tprint_value_set (dump_file, S, \"S\", block->index);\n     }\n@@ -1803,24 +1836,48 @@ compute_vuse_representatives (void)\n   VEC_free (tree, heap, phis);\n }\n \n-/* Compute reaching vuses.  This is a small bit of iterative dataflow\n-   to determine what virtual uses reach what blocks.  Because we can't\n-   generate overlapping virtual uses, and virtual uses *do* actually\n-   die, this ends up being faster in most cases than continually\n-   walking the virtual use/def chains to determine whether we are\n-   inside a block where a given virtual is still available to be\n-   used.  */\n+/* Compute reaching vuses and antic safe loads.  RVUSE computation is\n+   is a small bit of iterative dataflow to determine what virtual uses\n+   reach what blocks.  Because we can't generate overlapping virtual\n+   uses, and virtual uses *do* actually die, this ends up being faster\n+   in most cases than continually walking the virtual use/def chains\n+   to determine whether we are inside a block where a given virtual is\n+   still available to be used.  \n+\n+   ANTIC_SAFE_LOADS are those loads that actually occur before any kill to\n+   their vuses in the block,and thus, are safe at the top of the\n+   block.  \n+\n+   An example:\n+\n+   <block begin>\n+   b = *a\n+   *a = 9\n+   <block end>\n+   \n+   b = *a is an antic safe load because it still safe to consider it\n+   ANTIC at the top of the block.\n+\n+   We currently compute a conservative approximation to\n+   ANTIC_SAFE_LOADS.  We compute those loads that occur before *any*\n+   stores in the block.  This is not because it is difficult to\n+   compute the precise answer, but because it is expensive.  More\n+   testing is necessary to determine whether it is worth computing the\n+   precise answer.  */\n \n static void\n-compute_rvuse (void)\n+compute_rvuse_and_antic_safe (void)\n {\n \n   size_t i;\n   tree phi;\n   basic_block bb;\n   int *postorder;\n   bool changed = true;\n+  unsigned int *first_store_uid;\n \n+  first_store_uid = xcalloc (n_basic_blocks, sizeof (unsigned int));\n+  \n   compute_vuse_representatives ();\n \n   FOR_ALL_BB (bb)\n@@ -1829,9 +1886,9 @@ compute_rvuse (void)\n       RVUSE_GEN (bb) = BITMAP_ALLOC (&grand_bitmap_obstack);\n       RVUSE_KILL (bb) = BITMAP_ALLOC (&grand_bitmap_obstack);\n       RVUSE_OUT (bb) = BITMAP_ALLOC (&grand_bitmap_obstack);\n+      ANTIC_SAFE_LOADS (bb) = NULL;\n     }\n \n-\n   /* Mark live on entry */\n   for (i = 0; i < num_ssa_names; i++)\n     {\n@@ -1854,10 +1911,18 @@ compute_rvuse (void)\n       def_operand_p defp;\n       use_operand_p usep;\n \n-\n       for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n \t{\n \t  tree stmt = bsi_stmt (bsi);\n+\t  \n+\t  if (first_store_uid[bb->index] == 0 \n+\t      && !ZERO_SSA_OPERANDS (stmt, SSA_OP_VMAYUSE | SSA_OP_VMAYDEF \n+\t\t\t\t     | SSA_OP_VMUSTDEF | SSA_OP_VMUSTKILL))\n+\t    {\n+\t      first_store_uid[bb->index] = stmt_ann (stmt)->uid;\n+\t    }\n+\t  \n+\n \t  FOR_EACH_SSA_USE_OPERAND (usep, stmt, iter, SSA_OP_VIRTUAL_KILLS\n \t\t\t\t    | SSA_OP_VMAYUSE)\n \t    {\n@@ -1950,6 +2015,40 @@ compute_rvuse (void)\n \t  dump_bitmap_of_names (dump_file, RVUSE_OUT (bb));\n \t}\n     }\n+\n+  FOR_EACH_BB (bb)\n+    {      \n+      value_set_node_t node;\n+      if (bitmap_empty_p (RVUSE_KILL (bb)))\n+\tcontinue;\n+      \n+      for (node = EXP_GEN (bb)->head; node; node = node->next)\n+\t{\n+\t  if (REFERENCE_CLASS_P (node->expr))\n+\t    {\n+\t      tree vh = get_value_handle (node->expr);\n+\t      tree maybe = bitmap_find_leader (AVAIL_OUT (bb), vh);\n+\t      \n+\t      if (maybe)\n+\t\t{\n+\t\t  tree def = SSA_NAME_DEF_STMT (maybe);\n+\n+\t\t  if (bb_for_stmt (def) != bb)\n+\t\t    continue;\n+\t\t  \n+\t\t  if (TREE_CODE (def) == PHI_NODE\n+\t\t      || stmt_ann (def)->uid < first_store_uid[bb->index])\n+\t\t    {\n+\t\t      if (ANTIC_SAFE_LOADS (bb) == NULL)\n+\t\t\tANTIC_SAFE_LOADS (bb) = set_new (true);\n+\t\t      value_insert_into_set (ANTIC_SAFE_LOADS (bb), \n+\t\t\t\t\t     node->expr);\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+    }\n+  free (first_store_uid);\n }\n \n /* Return true if we can value number the call in STMT.  This is true\n@@ -1991,6 +2090,7 @@ can_PRE_operation (tree op)\n     || BINARY_CLASS_P (op)\n     || COMPARISON_CLASS_P (op)\n     || TREE_CODE (op) == INDIRECT_REF\n+    || TREE_CODE (op) == COMPONENT_REF\n     || TREE_CODE (op) == CALL_EXPR;\n }\n \n@@ -2005,6 +2105,70 @@ static VEC(tree,heap) *inserted_exprs;\n    to see which expressions need to be put into GC'able memory  */\n static VEC(tree, heap) *need_creation;\n \n+/* For COMPONENT_REF's, we can't have any intermediates for the\n+   COMPONENT_REF or INDIRECT_REF portion, because we'd end up with\n+   trying to rename aggregates into ssa form directly, which is a no\n+   no.\n+\n+   Thus, this routine doesn't create temporaries, it just builds a\n+   single access expression for the array, calling\n+   find_or_generate_expression to build the innermost pieces.\n+   \n+   This function is a subroutine of create_expression_by_pieces, and\n+   should not be called on it's own unless you really know what you\n+   are doing.\n+*/\n+static tree\n+create_component_ref_by_pieces (basic_block block, tree expr, tree stmts)\n+{\n+  tree genop = expr;\n+  tree folded;\n+\n+  if (TREE_CODE (genop) == VALUE_HANDLE)\n+    {\n+      tree found = bitmap_find_leader (AVAIL_OUT (block), expr);\n+      if (found)\n+\treturn found;\n+    }\n+  \n+  if (TREE_CODE (genop) == VALUE_HANDLE)\n+    genop = VALUE_HANDLE_EXPR_SET (expr)->head->expr;\n+\n+  switch TREE_CODE (genop)\n+    {\n+    case COMPONENT_REF:\n+      {\n+\ttree op0;\n+\ttree op1;\n+\top0 = create_component_ref_by_pieces (block, \n+\t\t\t\t\t      TREE_OPERAND (genop, 0),\n+\t\t\t\t\t      stmts);\n+\top1 = VALUE_HANDLE_EXPR_SET (TREE_OPERAND (genop, 1))->head->expr;\n+\tfolded = fold_build3 (COMPONENT_REF, TREE_TYPE (genop), op0, op1, \n+\t\t\t      NULL_TREE);\n+\treturn folded;\n+      }\n+      break;\n+    case INDIRECT_REF:\n+      {\n+\ttree op1 = TREE_OPERAND (genop, 0);\n+\ttree genop1 = find_or_generate_expression (block, op1, stmts);\n+\t\n+\tfolded = fold_build1 (TREE_CODE (genop), TREE_TYPE (genop),\n+\t\t\t      genop1);\n+\treturn folded;\n+      }\n+      break;\n+    case VAR_DECL:\n+    case PARM_DECL:\n+    case SSA_NAME:\n+      return genop;\n+    default:\n+      gcc_unreachable ();      \n+    }\n+\n+  return NULL_TREE;\n+}\n \n /* Find a leader for an expression, or generate one using\n    create_expression_by_pieces if it's ANTIC but\n@@ -2093,13 +2257,19 @@ create_expression_by_pieces (basic_block block, tree expr, tree stmts)\n       }\n       break;\n     case tcc_reference:\n-      gcc_assert (TREE_CODE (expr) == INDIRECT_REF);\n       {\n-\ttree op1 = TREE_OPERAND (expr, 0);\n-\ttree genop1 = find_or_generate_expression (block, op1, stmts);\n-\n-\tfolded = fold_build1 (TREE_CODE (expr), TREE_TYPE (expr),\n-\t\t\t      genop1);\n+\tif (TREE_CODE (expr) == COMPONENT_REF)\n+\t  {\n+\t    folded = create_component_ref_by_pieces (block, expr, stmts);\n+\t  }\n+\telse\n+\t  {\n+\t    tree op1 = TREE_OPERAND (expr, 0);\n+\t    tree genop1 = find_or_generate_expression (block, op1, stmts);\n+\t    \n+\t    folded = fold_build1 (TREE_CODE (expr), TREE_TYPE (expr),\n+\t\t\t\t  genop1);\n+\t  }\n \tbreak;\n       }\n       \n@@ -2404,7 +2574,8 @@ insert_aux (basic_block block)\n \t\t   node;\n \t\t   node = node->next)\n \t\t{\n-\t\t  if (can_PRE_operation (node->expr))\n+\t\t  if (can_PRE_operation (node->expr)\n+\t\t      && !AGGREGATE_TYPE_P (TREE_TYPE (node->expr)))\n \t\t    {\n \t\t      tree *avail;\n \t\t      tree val;\n@@ -2746,7 +2917,7 @@ insert_extra_phis (basic_block block, basic_block dom)\n \n       FOR_EACH_EDGE (e, ei, block->preds)\n \t{\n-\t  /* We cannot handle abnormal incomming edges correctly.  */\n+\t  /* We cannot handle abnormal incoming edges correctly.  */\n \t  if (e->flags & EDGE_ABNORMAL)\n \t    return;\n \n@@ -3076,7 +3247,6 @@ compute_avail (void)\n   basic_block *worklist;\n   size_t sp = 0;\n   tree param;\n-\n   /* For arguments with default definitions, we pretend they are\n      defined in the entry block.  */\n   for (param = DECL_ARGUMENTS (current_function_decl);\n@@ -3121,6 +3291,7 @@ compute_avail (void)\n       block_stmt_iterator bsi;\n       tree stmt, phi;\n       basic_block dom;\n+      unsigned int stmt_uid = 1;\n \n       /* Pick a block from the worklist.  */\n       block = worklist[--sp];\n@@ -3152,6 +3323,8 @@ compute_avail (void)\n \n \t  stmt = bsi_stmt (bsi);\n \t  ann = stmt_ann (stmt);\n+\t  \n+\t  ann->uid = stmt_uid++;\n \n \t  /* For regular value numbering, we are only interested in\n \t     assignments of the form X_i = EXPR, where EXPR represents\n@@ -3597,7 +3770,7 @@ execute_pre (bool do_fre)\n   if (!do_fre && n_basic_blocks < 4000)\n     {\n       vuse_names = XCNEWVEC (bitmap, num_ssa_names);\n-      compute_rvuse ();\n+      compute_rvuse_and_antic_safe ();\n       compute_antic ();\n       insert ();\n       free (vuse_names);\n@@ -3655,7 +3828,7 @@ struct tree_opt_pass pass_pre =\n   0,\t\t\t\t\t/* properties_provided */\n   0,\t\t\t\t\t/* properties_destroyed */\n   0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_update_ssa | TODO_dump_func | TODO_ggc_collect \n+  TODO_update_ssa_only_virtuals | TODO_dump_func | TODO_ggc_collect \n   | TODO_verify_ssa, /* todo_flags_finish */\n   0\t\t\t\t\t/* letter */\n };"}]}