{"sha": "e7d23ce3b5d32958e32f57dd291d0068ed2b5849", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTdkMjNjZTNiNWQzMjk1OGUzMmY1N2RkMjkxZDAwNjhlZDJiNTg0OQ==", "commit": {"author": {"name": "J. Brobecker", "email": "brobecker@gnat.com", "date": "2004-01-17T05:30:48Z"}, "committer": {"name": "Joel Brobecker", "email": "brobecke@gcc.gnu.org", "date": "2004-01-17T05:30:48Z"}, "message": "dwarf2out.c (is_subrange_type): Renamed from is_ada_subrange_type().\n\n        * dwarf2out.c (is_subrange_type): Renamed from is_ada_subrange_type().\n        Remove checks for is_ada() and TREE_UNSIGNED.\n        (subrange_type_die): Emit a byte_size attribute if the subrange\n        type size is different from the base type size.\n        (modified_type_die): Replace call to is_ada_subrange_type() by\n        call to is_subrange_type().\n\nFrom-SVN: r76025", "tree": {"sha": "e517b60a446030d1672b32891c55247f48c9405e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e517b60a446030d1672b32891c55247f48c9405e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e7d23ce3b5d32958e32f57dd291d0068ed2b5849", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7d23ce3b5d32958e32f57dd291d0068ed2b5849", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e7d23ce3b5d32958e32f57dd291d0068ed2b5849", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7d23ce3b5d32958e32f57dd291d0068ed2b5849/comments", "author": null, "committer": null, "parents": [{"sha": "cf5da2b9d8ff2725bc2eb90795ff8472c0102b80", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf5da2b9d8ff2725bc2eb90795ff8472c0102b80", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf5da2b9d8ff2725bc2eb90795ff8472c0102b80"}], "stats": {"total": 39, "additions": 23, "deletions": 16}, "files": [{"sha": "943fd3e1ee20bee0fd6e6e1acc2a287c8bdbc224", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7d23ce3b5d32958e32f57dd291d0068ed2b5849/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7d23ce3b5d32958e32f57dd291d0068ed2b5849/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e7d23ce3b5d32958e32f57dd291d0068ed2b5849", "patch": "@@ -1,3 +1,12 @@\n+2004-01-17  J. Brobecker  <brobecker at gnat dot com>\n+\n+\t* dwarf2out.c (is_subrange_type): Renamed from is_ada_subrange_type().\n+\tRemove checks for is_ada() and TREE_UNSIGNED.\n+\t(subrange_type_die): Emit a byte_size attribute if the subrange\n+\ttype size is different from the base type size.\n+\t(modified_type_die): Replace call to is_ada_subrange_type() by\n+\tcall to is_subrange_type().\n+\n 2004-01-16  Andrew Pinski  <pinskia@physics.uc.edu>\n \n \t* config/sh/sh.c: Include ggc.h."}, {"sha": "51c0f1c4297eaa0358285962e5de7ab68118062a", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7d23ce3b5d32958e32f57dd291d0068ed2b5849/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7d23ce3b5d32958e32f57dd291d0068ed2b5849/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=e7d23ce3b5d32958e32f57dd291d0068ed2b5849", "patch": "@@ -3703,7 +3703,7 @@ static void output_file_names (void);\n static dw_die_ref base_type_die (tree);\n static tree root_type (tree);\n static int is_base_type (tree);\n-static bool is_ada_subrange_type (tree);\n+static bool is_subrange_type (tree);\n static dw_die_ref subrange_type_die (tree, dw_die_ref);\n static dw_die_ref modified_type_die (tree, int, int, dw_die_ref);\n static int type_is_enum (tree);\n@@ -7812,24 +7812,14 @@ simple_type_size_in_bits (tree type)\n    emitted as a subrange type.  */\n \n static inline bool\n-is_ada_subrange_type (tree type)\n-{\n-  /* We should use a subrange type in the following situations:\n-     - For Ada modular types: These types are stored as integer subtypes\n-       of an unsigned integer type;\n-     - For subtypes of an Ada enumeration type: These types are stored\n-       as integer subtypes of enumeral types.\n-     \n-     This subrange type is mostly for the benefit of debugger users.\n-     A nameless type would therefore not be very useful, so no need\n-     to generate a subrange type in these cases.  */\n+is_subrange_type (tree type)\n+{\n   tree subtype = TREE_TYPE (type);\n \n-  if (is_ada ()\n-      && TREE_CODE (type) == INTEGER_TYPE\n+  if (TREE_CODE (type) == INTEGER_TYPE\n       && subtype != NULL_TREE)\n     {\n-      if (TREE_CODE (subtype) == INTEGER_TYPE && TREE_UNSIGNED (subtype))\n+      if (TREE_CODE (subtype) == INTEGER_TYPE)\n         return true;\n       if (TREE_CODE (subtype) == ENUMERAL_TYPE)\n         return true;\n@@ -7846,6 +7836,7 @@ subrange_type_die (tree type, dw_die_ref context_die)\n   dw_die_ref subtype_die;\n   dw_die_ref subrange_die;\n   tree name = TYPE_NAME (type);\n+  const HOST_WIDE_INT size_in_bytes = int_size_in_bytes (type);\n \n   if (context_die == NULL)\n     context_die = comp_unit_die;\n@@ -7864,6 +7855,13 @@ subrange_type_die (tree type, dw_die_ref context_die)\n       add_name_attribute (subrange_die, IDENTIFIER_POINTER (name));\n     }\n \n+  if (int_size_in_bytes (TREE_TYPE (type)) != size_in_bytes)\n+    {\n+      /* The size of the subrange type and its base type do not match,\n+         so we need to generate a size attribute for the subrange type.  */\n+      add_AT_unsigned (subrange_die, DW_AT_byte_size, size_in_bytes);\n+    }\n+\n   if (TYPE_MIN_VALUE (type) != NULL)\n     add_bound_info (subrange_die, DW_AT_lower_bound,\n                     TYPE_MIN_VALUE (type));\n@@ -7966,7 +7964,7 @@ modified_type_die (tree type, int is_const_type, int is_volatile_type,\n #endif\n \t  item_type = TREE_TYPE (type);\n \t}\n-      else if (is_ada_subrange_type (type))\n+      else if (is_subrange_type (type))\n         mod_type_die = subrange_type_die (type, context_die);\n       else if (is_base_type (type))\n \tmod_type_die = base_type_die (type);"}]}