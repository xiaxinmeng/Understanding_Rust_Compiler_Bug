{"sha": "afbe632536736558f24680aa2c4c00b2d451e0b6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWZiZTYzMjUzNjczNjU1OGYyNDY4MGFhMmM0YzAwYjJkNDUxZTBiNg==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2015-05-22T09:00:28Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2015-05-22T09:00:28Z"}, "message": "tree-vect-loop.c (get_reduction_op): New function.\n\n2015-05-22  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vect-loop.c (get_reduction_op): New function.\n\t(vect_model_reduction_cost): Use it, add reduc_index parameter.\n\tMake ready for BB reductions.\n\t(vect_create_epilog_for_reduction): Use get_reduction_op.\n\t(vectorizable_reduction): Init reduc_index to a valid value.\n\tAdjust vect_model_reduction_cost call.\n\t* tree-vect-slp.c (vect_get_constant_vectors): Use the proper\n\toperand for reduction defaults.  Add SAD_EXPR support.\n\tAssert we have a neutral op for SLP reductions.\n\t* tree-vect-stmts.c (vect_mark_stmts_to_be_vectorized): When\n\twalking pattern stmt ops only recurse to SSA names.\n\nFrom-SVN: r223526", "tree": {"sha": "d0eacad77020a0aa1c97435bd56829e44fc17a26", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d0eacad77020a0aa1c97435bd56829e44fc17a26"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/afbe632536736558f24680aa2c4c00b2d451e0b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/afbe632536736558f24680aa2c4c00b2d451e0b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/afbe632536736558f24680aa2c4c00b2d451e0b6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/afbe632536736558f24680aa2c4c00b2d451e0b6/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "328dc4771b6a34b8630f6508577d10d5ea1774a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/328dc4771b6a34b8630f6508577d10d5ea1774a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/328dc4771b6a34b8630f6508577d10d5ea1774a2"}], "stats": {"total": 118, "additions": 65, "deletions": 53}, "files": [{"sha": "090dcddd3f828a0c41a424f1660b2e9a69f6be76", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afbe632536736558f24680aa2c4c00b2d451e0b6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afbe632536736558f24680aa2c4c00b2d451e0b6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=afbe632536736558f24680aa2c4c00b2d451e0b6", "patch": "@@ -1,3 +1,17 @@\n+2015-05-22  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-vect-loop.c (get_reduction_op): New function.\n+\t(vect_model_reduction_cost): Use it, add reduc_index parameter.\n+\tMake ready for BB reductions.\n+\t(vect_create_epilog_for_reduction): Use get_reduction_op.\n+\t(vectorizable_reduction): Init reduc_index to a valid value.\n+\tAdjust vect_model_reduction_cost call.\n+\t* tree-vect-slp.c (vect_get_constant_vectors): Use the proper\n+\toperand for reduction defaults.  Add SAD_EXPR support.\n+\tAssert we have a neutral op for SLP reductions.\n+\t* tree-vect-stmts.c (vect_mark_stmts_to_be_vectorized): When\n+\twalking pattern stmt ops only recurse to SSA names.\n+\n 2015-05-22  Richard Biener  <rguenther@suse.de>\n \n \t* tree-vect-patterns.c (vect_recog_dot_prod_pattern): Replace"}, {"sha": "123958b31ca352a39b8cc2a63c1510421fbb3cc3", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 41, "deletions": 45, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afbe632536736558f24680aa2c4c00b2d451e0b6/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afbe632536736558f24680aa2c4c00b2d451e0b6/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=afbe632536736558f24680aa2c4c00b2d451e0b6", "patch": "@@ -3166,6 +3166,29 @@ have_whole_vector_shift (enum machine_mode mode)\n   return true;\n }\n \n+/* Return the reduction operand (with index REDUC_INDEX) of STMT.  */\n+\n+static tree\n+get_reduction_op (gimple stmt, int reduc_index)\n+{\n+  switch (get_gimple_rhs_class (gimple_assign_rhs_code (stmt)))\n+    {\n+    case GIMPLE_SINGLE_RHS:\n+      gcc_assert (TREE_OPERAND_LENGTH (gimple_assign_rhs1 (stmt))\n+\t\t  == ternary_op);\n+      return TREE_OPERAND (gimple_assign_rhs1 (stmt), reduc_index);\n+    case GIMPLE_UNARY_RHS:\n+      return gimple_assign_rhs1 (stmt);\n+    case GIMPLE_BINARY_RHS:\n+      return (reduc_index\n+\t      ? gimple_assign_rhs2 (stmt) : gimple_assign_rhs1 (stmt));\n+    case GIMPLE_TERNARY_RHS:\n+      return gimple_op (stmt, reduc_index + 1);\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n /* TODO: Close dependency between vect_model_*_cost and vectorizable_*\n    functions. Design better to avoid maintenance issues.  */\n \n@@ -3177,7 +3200,7 @@ have_whole_vector_shift (enum machine_mode mode)\n \n static bool\n vect_model_reduction_cost (stmt_vec_info stmt_info, enum tree_code reduc_code,\n-\t\t\t   int ncopies)\n+\t\t\t   int ncopies, int reduc_index)\n {\n   int prologue_cost = 0, epilogue_cost = 0;\n   enum tree_code code;\n@@ -3187,32 +3210,23 @@ vect_model_reduction_cost (stmt_vec_info stmt_info, enum tree_code reduc_code,\n   tree reduction_op;\n   machine_mode mode;\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n-  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n-  void *target_cost_data = LOOP_VINFO_TARGET_COST_DATA (loop_vinfo);\n+  struct loop *loop = NULL;\n+  void *target_cost_data;\n+\n+  if (loop_vinfo)\n+    {\n+      loop = LOOP_VINFO_LOOP (loop_vinfo);\n+      target_cost_data = LOOP_VINFO_TARGET_COST_DATA (loop_vinfo);\n+    }\n+  else\n+    target_cost_data = BB_VINFO_TARGET_COST_DATA (STMT_VINFO_BB_VINFO (stmt_info));\n \n   /* Cost of reduction op inside loop.  */\n   unsigned inside_cost = add_stmt_cost (target_cost_data, ncopies, vector_stmt,\n \t\t\t\t\tstmt_info, 0, vect_body);\n   stmt = STMT_VINFO_STMT (stmt_info);\n \n-  switch (get_gimple_rhs_class (gimple_assign_rhs_code (stmt)))\n-    {\n-    case GIMPLE_SINGLE_RHS:\n-      gcc_assert (TREE_OPERAND_LENGTH (gimple_assign_rhs1 (stmt)) == ternary_op);\n-      reduction_op = TREE_OPERAND (gimple_assign_rhs1 (stmt), 2);\n-      break;\n-    case GIMPLE_UNARY_RHS:\n-      reduction_op = gimple_assign_rhs1 (stmt);\n-      break;\n-    case GIMPLE_BINARY_RHS:\n-      reduction_op = gimple_assign_rhs2 (stmt);\n-      break;\n-    case GIMPLE_TERNARY_RHS:\n-      reduction_op = gimple_assign_rhs3 (stmt);\n-      break;\n-    default:\n-      gcc_unreachable ();\n-    }\n+  reduction_op = get_reduction_op (stmt, reduc_index);\n \n   vectype = get_vectype_for_scalar_type (TREE_TYPE (reduction_op));\n   if (!vectype)\n@@ -3245,7 +3259,7 @@ vect_model_reduction_cost (stmt_vec_info stmt_info, enum tree_code reduc_code,\n      We have a reduction operator that will reduce the vector in one statement.\n      Also requires scalar extract.  */\n \n-  if (!nested_in_vect_loop_p (loop, orig_stmt))\n+  if (!loop || !nested_in_vect_loop_p (loop, orig_stmt))\n     {\n       if (reduc_code != ERROR_MARK)\n \t{\n@@ -3992,26 +4006,7 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple stmt,\n       gcc_assert (!slp_node);\n     }\n \n-  switch (get_gimple_rhs_class (gimple_assign_rhs_code (stmt)))\n-    {\n-    case GIMPLE_SINGLE_RHS:\n-      gcc_assert (TREE_OPERAND_LENGTH (gimple_assign_rhs1 (stmt))\n-\t\t  == ternary_op);\n-      reduction_op = TREE_OPERAND (gimple_assign_rhs1 (stmt), reduc_index);\n-      break;\n-    case GIMPLE_UNARY_RHS:\n-      reduction_op = gimple_assign_rhs1 (stmt);\n-      break;\n-    case GIMPLE_BINARY_RHS:\n-      reduction_op = reduc_index ?\n-                     gimple_assign_rhs2 (stmt) : gimple_assign_rhs1 (stmt);\n-      break;\n-    case GIMPLE_TERNARY_RHS:\n-      reduction_op = gimple_op (stmt, reduc_index + 1);\n-      break;\n-    default:\n-      gcc_unreachable ();\n-    }\n+  reduction_op = get_reduction_op (stmt, reduc_index);\n \n   vectype = get_vectype_for_scalar_type (TREE_TYPE (reduction_op));\n   gcc_assert (vectype);\n@@ -4845,8 +4840,6 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n   tree ops[3];\n   bool nested_cycle = false, found_nested_cycle_def = false;\n   gimple reduc_def_stmt = NULL;\n-  /* The default is that the reduction variable is the last in statement.  */\n-  int reduc_index = 2;\n   bool double_reduc = false, dummy;\n   basic_block def_bb;\n   struct loop * def_stmt_loop, *outer_loop = NULL;\n@@ -4951,6 +4944,8 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n     default:\n       gcc_unreachable ();\n     }\n+  /* The default is that the reduction variable is the last in statement.  */\n+  int reduc_index = op_type - 1;\n \n   if (code == COND_EXPR && slp_node)\n     return false;\n@@ -5248,7 +5243,8 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n \n   if (!vec_stmt) /* transformation not required.  */\n     {\n-      if (!vect_model_reduction_cost (stmt_info, epilog_reduc_code, ncopies))\n+      if (!vect_model_reduction_cost (stmt_info, epilog_reduc_code, ncopies,\n+\t\t\t\t      reduc_index))\n         return false;\n       STMT_VINFO_TYPE (stmt_info) = reduc_vec_info_type;\n       return true;"}, {"sha": "21489b3ed3af8cd3460507f0dd1454c4e4dab2d3", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afbe632536736558f24680aa2c4c00b2d451e0b6/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afbe632536736558f24680aa2c4c00b2d451e0b6/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=afbe632536736558f24680aa2c4c00b2d451e0b6", "patch": "@@ -2664,18 +2664,22 @@ vect_get_constant_vectors (tree op, slp_tree slp_node,\n   struct loop *loop;\n   gimple_seq ctor_seq = NULL;\n \n+  vector_type = get_vectype_for_scalar_type (TREE_TYPE (op));\n+  nunits = TYPE_VECTOR_SUBPARTS (vector_type);\n+\n   if (STMT_VINFO_DEF_TYPE (stmt_vinfo) == vect_reduction_def\n       && reduc_index != -1)\n     {\n-      op_num = reduc_index - 1;\n-      op = gimple_op (stmt, reduc_index);\n+      op_num = reduc_index;\n+      op = gimple_op (stmt, op_num + 1);\n       /* For additional copies (see the explanation of NUMBER_OF_COPIES below)\n          we need either neutral operands or the original operands.  See\n          get_initial_def_for_reduction() for details.  */\n       switch (code)\n         {\n           case WIDEN_SUM_EXPR:\n           case DOT_PROD_EXPR:\n+\t  case SAD_EXPR:\n           case PLUS_EXPR:\n           case MINUS_EXPR:\n           case BIT_IOR_EXPR:\n@@ -2716,6 +2720,7 @@ vect_get_constant_vectors (tree op, slp_tree slp_node,\n \t    break;\n \n           default:\n+\t    gcc_assert (!GROUP_FIRST_ELEMENT (stmt_vinfo));\n             neutral_op = NULL;\n         }\n     }\n@@ -2735,10 +2740,6 @@ vect_get_constant_vectors (tree op, slp_tree slp_node,\n   else\n     constant_p = false;\n \n-  vector_type = get_vectype_for_scalar_type (TREE_TYPE (op));\n-  gcc_assert (vector_type);\n-  nunits = TYPE_VECTOR_SUBPARTS (vector_type);\n-\n   /* NUMBER_OF_COPIES is the number of times we need to use the same values in\n      created vectors. It is greater than 1 if unrolling is performed.\n "}, {"sha": "1f68ff52698e035378c25224237643251371ed84", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afbe632536736558f24680aa2c4c00b2d451e0b6/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afbe632536736558f24680aa2c4c00b2d451e0b6/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=afbe632536736558f24680aa2c4c00b2d451e0b6", "patch": "@@ -812,8 +812,9 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n \t      for (; i < gimple_num_ops (stmt); i++)\n                 {\n \t\t  op = gimple_op (stmt, i);\n-                  if (!process_use (stmt, op, loop_vinfo, live_p, relevant,\n-\t\t\t\t    &worklist, false))\n+                  if (TREE_CODE (op) == SSA_NAME\n+\t\t      && !process_use (stmt, op, loop_vinfo, live_p, relevant,\n+\t\t\t\t       &worklist, false))\n                     return false;\n                  }\n             }"}]}