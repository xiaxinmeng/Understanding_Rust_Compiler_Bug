{"sha": "6d9f1f5f63493bfe17c9b648084abe348d842834", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmQ5ZjFmNWY2MzQ5M2JmZTE3YzliNjQ4MDg0YWJlMzQ4ZDg0MjgzNA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-07-13T18:44:38Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-07-13T18:44:38Z"}, "message": "(decode_field_reference): Merge operand of a BIT_AND_EXPR with the\nmask made from the description of the field.\n\nFrom-SVN: r7766", "tree": {"sha": "ddfad204698bdea2b22a3ac4e4aaa179cad3b3e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ddfad204698bdea2b22a3ac4e4aaa179cad3b3e4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6d9f1f5f63493bfe17c9b648084abe348d842834", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d9f1f5f63493bfe17c9b648084abe348d842834", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d9f1f5f63493bfe17c9b648084abe348d842834", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d9f1f5f63493bfe17c9b648084abe348d842834/comments", "author": null, "committer": null, "parents": [{"sha": "4be40f361984880793e17b2658445eba4fcf9898", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4be40f361984880793e17b2658445eba4fcf9898", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4be40f361984880793e17b2658445eba4fcf9898"}], "stats": {"total": 38, "additions": 21, "deletions": 17}, "files": [{"sha": "0417aab48b3f1b507b686cb4d7da030962cf176f", "filename": "gcc/fold-const.c", "status": "modified", "additions": 21, "deletions": 17, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d9f1f5f63493bfe17c9b648084abe348d842834/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d9f1f5f63493bfe17c9b648084abe348d842834/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=6d9f1f5f63493bfe17c9b648084abe348d842834", "patch": "@@ -2387,9 +2387,10 @@ decode_field_reference (exp, pbitsize, pbitpos, pmode, punsignedp,\n      int *punsignedp, *pvolatilep;\n      tree *pmask;\n {\n-  tree mask = 0;\n-  tree inner;\n-  tree offset;\n+  tree and_mask = 0;\n+  tree mask, inner, offset;\n+  tree unsigned_type;\n+  int precision;\n \n   /* All the optimizations using this function assume integer fields.  \n      There are problems with FP fields since the type_for_size call\n@@ -2401,10 +2402,10 @@ decode_field_reference (exp, pbitsize, pbitpos, pmode, punsignedp,\n \n   if (TREE_CODE (exp) == BIT_AND_EXPR)\n     {\n-      mask = TREE_OPERAND (exp, 1);\n+      and_mask = TREE_OPERAND (exp, 1);\n       exp = TREE_OPERAND (exp, 0);\n-      STRIP_NOPS (exp); STRIP_NOPS (mask);\n-      if (TREE_CODE (mask) != INTEGER_CST)\n+      STRIP_NOPS (exp); STRIP_NOPS (and_mask);\n+      if (TREE_CODE (and_mask) != INTEGER_CST)\n \treturn 0;\n     }\n \n@@ -2417,17 +2418,20 @@ decode_field_reference (exp, pbitsize, pbitpos, pmode, punsignedp,\n   if (inner == exp || *pbitsize < 0 || offset != 0)\n     return 0;\n   \n-  if (mask == 0)\n-    {\n-      tree unsigned_type = type_for_size (*pbitsize, 1);\n-      int precision = TYPE_PRECISION (unsigned_type);\n-\n-      mask = build_int_2 (~0, ~0);\n-      TREE_TYPE (mask) = unsigned_type;\n-      force_fit_type (mask, 0);\n-      mask = const_binop (LSHIFT_EXPR, mask, size_int (precision - *pbitsize), 0);\n-      mask = const_binop (RSHIFT_EXPR, mask, size_int (precision - *pbitsize), 0);\n-    }\n+  /* Compute the mask to access the bitfield.  */\n+  unsigned_type = type_for_size (*pbitsize, 1);\n+  precision = TYPE_PRECISION (unsigned_type);\n+\n+  mask = build_int_2 (~0, ~0);\n+  TREE_TYPE (mask) = unsigned_type;\n+  force_fit_type (mask, 0);\n+  mask = const_binop (LSHIFT_EXPR, mask, size_int (precision - *pbitsize), 0);\n+  mask = const_binop (RSHIFT_EXPR, mask, size_int (precision - *pbitsize), 0);\n+\n+  /* Merge it with the mask we found in the BIT_AND_EXPR, if any.  */\n+  if (and_mask != 0)\n+    mask = fold (build (BIT_AND_EXPR, unsigned_type,\n+\t\t\tconvert (unsigned_type, and_mask), mask));\n \n   *pmask = mask;\n   return inner;"}]}