{"sha": "39ecc018798bc85d22bfc3c3155986ab5b35f5ac", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzllY2MwMTg3OThiYzg1ZDIyYmZjM2MzMTU1OTg2YWI1YjM1ZjVhYw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2008-09-03T18:16:26Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2008-09-03T18:16:26Z"}, "message": "re PR tree-optimization/37315 (gcc.c-torture/execute/931018-1.c  int-compare.c ieee/inf-2.c mzero6.c)\n\n\n\tPR tree-optimization/37315\n\t* cgraph.c (cgraph_create_edge): Use gimple_has_body_p.\n\t* cgraphunit.c (verify_cgraph_node): drop gimple_body check.\n\t(cgraph_analyze_functions): Use node->analyzed\n\t(cgraph_mark_functions_to_output): Likewise.\n\t(cgraph_expand_function): All functions can be released after\n\texpanding.\n\t(cgraph_optimize): Use gimple_has_body_p.\n\t* ipa-inline.c (cgraph_clone_inlined_nodes): Use analyzed flag.\n\t(cgraph_decide_inlining_incrementally): Likewise.\n\t(inline_transform): Inline transform.\n\t* tree-inline.c (initialize_cfun): Do now shallow copy structure;\n\tcopy fields needed.\n\t(inlinable_function_p): Drop gimple_body check.\n\t(expand_call_inline): Use gimple_has_body_p.\n\t* gimple.c (gimple_has_body_p): New.\n\t* gimple.h (gimple_has_body_p): Add prototype.\n\t* tree-cfg.c (execute_build_cfg): Remove gimple_body.\n\t(dump_function_to_file): Use gimple_has_body_p check.\n\nFrom-SVN: r139945", "tree": {"sha": "2ec6cd14c2fd416d7473c8942ba129ded5f4824b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2ec6cd14c2fd416d7473c8942ba129ded5f4824b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/39ecc018798bc85d22bfc3c3155986ab5b35f5ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39ecc018798bc85d22bfc3c3155986ab5b35f5ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/39ecc018798bc85d22bfc3c3155986ab5b35f5ac", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39ecc018798bc85d22bfc3c3155986ab5b35f5ac/comments", "author": null, "committer": null, "parents": [{"sha": "cafea0e43647f764861b625232460c584fe11086", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cafea0e43647f764861b625232460c584fe11086", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cafea0e43647f764861b625232460c584fe11086"}], "stats": {"total": 134, "additions": 91, "deletions": 43}, "files": [{"sha": "b3bad2f21336fb173c6020f513098781596e33b6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39ecc018798bc85d22bfc3c3155986ab5b35f5ac/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39ecc018798bc85d22bfc3c3155986ab5b35f5ac/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=39ecc018798bc85d22bfc3c3155986ab5b35f5ac", "patch": "@@ -1,3 +1,25 @@\n+2008-09-03  Jan Hubicka  <jh@suse.cz>\n+\n+\tPR tree-optimization/37315\n+\t* cgraph.c (cgraph_create_edge): Use gimple_has_body_p.\n+\t* cgraphunit.c (verify_cgraph_node): drop gimple_body check.\n+\t(cgraph_analyze_functions): Use node->analyzed\n+\t(cgraph_mark_functions_to_output): Likewise.\n+\t(cgraph_expand_function): All functions can be released after\n+\texpanding.\n+\t(cgraph_optimize): Use gimple_has_body_p.\n+\t* ipa-inline.c (cgraph_clone_inlined_nodes): Use analyzed flag.\n+\t(cgraph_decide_inlining_incrementally): Likewise.\n+\t(inline_transform): Inline transform.\n+\t* tree-inline.c (initialize_cfun): Do now shallow copy structure;\n+\tcopy fields needed.\n+\t(inlinable_function_p): Drop gimple_body check.\n+\t(expand_call_inline): Use gimple_has_body_p.\n+\t* gimple.c (gimple_has_body_p): New.\n+\t* gimple.h (gimple_has_body_p): Add prototype.\n+\t* tree-cfg.c (execute_build_cfg): Remove gimple_body.\n+\t(dump_function_to_file): Use gimple_has_body_p check.\n+\n 2008-09-03  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/37346"}, {"sha": "a12ed155b458088cd44b81d65b424a788737bb13", "filename": "gcc/cgraph.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39ecc018798bc85d22bfc3c3155986ab5b35f5ac/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39ecc018798bc85d22bfc3c3155986ab5b35f5ac/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=39ecc018798bc85d22bfc3c3155986ab5b35f5ac", "patch": "@@ -645,7 +645,7 @@ cgraph_create_edge (struct cgraph_node *caller, struct cgraph_node *callee,\n \n   gcc_assert (is_gimple_call (call_stmt));\n \n-  if (!gimple_body (callee->decl))\n+  if (!callee->analyzed)\n     edge->inline_failed = N_(\"function body not available\");\n   else if (callee->local.redefined_extern_inline)\n     edge->inline_failed = N_(\"redefined extern inline functions are not \"\n@@ -1073,7 +1073,7 @@ dump_cgraph_node (FILE *f, struct cgraph_node *node)\n     fprintf (f, \" needed\");\n   else if (node->reachable)\n     fprintf (f, \" reachable\");\n-  if (gimple_body (node->decl))\n+  if (gimple_has_body_p (node->decl))\n     fprintf (f, \" body\");\n   if (node->output)\n     fprintf (f, \" output\");"}, {"sha": "d011041b9d763f3d01205c815effc88c47e05a68", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 14, "deletions": 18, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39ecc018798bc85d22bfc3c3155986ab5b35f5ac/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39ecc018798bc85d22bfc3c3155986ab5b35f5ac/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=39ecc018798bc85d22bfc3c3155986ab5b35f5ac", "patch": "@@ -639,7 +639,6 @@ verify_cgraph_node (struct cgraph_node *node)\n     }\n \n   if (node->analyzed\n-      && gimple_body (node->decl)\n       && !TREE_ASM_WRITTEN (node->decl)\n       && (!DECL_EXTERNAL (node->decl) || node->global.inlined_to))\n     {\n@@ -860,7 +859,7 @@ cgraph_analyze_functions (void)\n     {\n       fprintf (cgraph_dump_file, \"Initial entry points:\");\n       for (node = cgraph_nodes; node != first_analyzed; node = node->next)\n-\tif (node->needed && gimple_body (node->decl))\n+\tif (node->needed)\n \t  fprintf (cgraph_dump_file, \" %s\", cgraph_node_name (node));\n       fprintf (cgraph_dump_file, \"\\n\");\n     }\n@@ -912,7 +911,7 @@ cgraph_analyze_functions (void)\n     {\n       fprintf (cgraph_dump_file, \"Unit entry points:\");\n       for (node = cgraph_nodes; node != first_analyzed; node = node->next)\n-\tif (node->needed && gimple_body (node->decl))\n+\tif (node->needed)\n \t  fprintf (cgraph_dump_file, \" %s\", cgraph_node_name (node));\n       fprintf (cgraph_dump_file, \"\\n\\nInitial \");\n       dump_cgraph (cgraph_dump_file);\n@@ -926,10 +925,10 @@ cgraph_analyze_functions (void)\n       tree decl = node->decl;\n       next = node->next;\n \n-      if (node->local.finalized && !gimple_body (decl))\n+      if (node->local.finalized && !gimple_has_body_p (decl))\n \tcgraph_reset_node (node);\n \n-      if (!node->reachable && gimple_body (decl))\n+      if (!node->reachable && gimple_has_body_p (decl))\n \t{\n \t  if (cgraph_dump_file)\n \t    fprintf (cgraph_dump_file, \" %s\", cgraph_node_name (node));\n@@ -938,7 +937,7 @@ cgraph_analyze_functions (void)\n \t}\n       else\n \tnode->next_needed = NULL;\n-      gcc_assert (!node->local.finalized || gimple_body (decl));\n+      gcc_assert (!node->local.finalized || gimple_has_body_p (decl));\n       gcc_assert (node->analyzed == node->local.finalized);\n     }\n   if (cgraph_dump_file)\n@@ -991,7 +990,7 @@ cgraph_mark_functions_to_output (void)\n       /* We need to output all local functions that are used and not\n \t always inlined, as well as those that are reachable from\n \t outside the current compilation unit.  */\n-      if (gimple_body (decl)\n+      if (node->analyzed\n \t  && !node->global.inlined_to\n \t  && (node->needed\n \t      || (e && node->reachable))\n@@ -1003,15 +1002,15 @@ cgraph_mark_functions_to_output (void)\n \t  /* We should've reclaimed all functions that are not needed.  */\n #ifdef ENABLE_CHECKING\n \t  if (!node->global.inlined_to\n-\t      && gimple_body (decl)\n+\t      && gimple_has_body_p (decl)\n \t      && !DECL_EXTERNAL (decl))\n \t    {\n \t      dump_cgraph_node (stderr, node);\n \t      internal_error (\"failed to reclaim unneeded function\");\n \t    }\n #endif\n \t  gcc_assert (node->global.inlined_to\n-\t\t      || !gimple_body (decl)\n+\t\t      || !gimple_has_body_p (decl)\n \t\t      || DECL_EXTERNAL (decl));\n \n \t}\n@@ -1039,16 +1038,13 @@ cgraph_expand_function (struct cgraph_node *node)\n   tree_rest_of_compilation (decl);\n \n   /* Make sure that BE didn't give up on compiling.  */\n-  /* ??? Can happen with nested function of extern inline.  */\n   gcc_assert (TREE_ASM_WRITTEN (decl));\n   current_function_decl = NULL;\n-  if (!cgraph_preserve_function_body_p (decl))\n-    {\n-      cgraph_release_function_body (node);\n-      /* Eliminate all call edges.  This is important so the call_expr no longer\n-\t points to the dead function body.  */\n-      cgraph_node_remove_callees (node);\n-    }\n+  gcc_assert (!cgraph_preserve_function_body_p (decl));\n+  cgraph_release_function_body (node);\n+  /* Eliminate all call edges.  This is important so the GIMPLE_CALL no longer\n+     points to the dead function body.  */\n+  cgraph_node_remove_callees (node);\n \n   cgraph_function_flags_ready = true;\n }\n@@ -1329,7 +1325,7 @@ cgraph_optimize (void)\n       for (node = cgraph_nodes; node; node = node->next)\n \tif (node->analyzed\n \t    && (node->global.inlined_to\n-\t\t|| gimple_body (node->decl)))\n+\t\t|| gimple_has_body_p (node->decl)))\n \t  {\n \t    error_found = true;\n \t    dump_cgraph_node (stderr, node);"}, {"sha": "7419d853dc0fa74ece10d86d728769c61b2db644", "filename": "gcc/gimple.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39ecc018798bc85d22bfc3c3155986ab5b35f5ac/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39ecc018798bc85d22bfc3c3155986ab5b35f5ac/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=39ecc018798bc85d22bfc3c3155986ab5b35f5ac", "patch": "@@ -1816,6 +1816,14 @@ gimple_body (tree fndecl)\n   return fn ? fn->gimple_body : NULL;\n }\n \n+/* Return true when FNDECL has Gimple body either in unlowered\n+   or CFG form.  */\n+bool\n+gimple_has_body_p (tree fndecl)\n+{\n+  struct function *fn = DECL_STRUCT_FUNCTION (fndecl);\n+  return (gimple_body (fndecl) || (fn && fn->cfg));\n+}\n \n /* Detect flags from a GIMPLE_CALL.  This is just like\n    call_expr_flags, but for gimple tuples.  */"}, {"sha": "03b6217ebab018c628faa4737e157a37e3fe389a", "filename": "gcc/gimple.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39ecc018798bc85d22bfc3c3155986ab5b35f5ac/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39ecc018798bc85d22bfc3c3155986ab5b35f5ac/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=39ecc018798bc85d22bfc3c3155986ab5b35f5ac", "patch": "@@ -822,6 +822,7 @@ enum gimple_statement_structure_enum gss_for_assign (enum tree_code);\n void sort_case_labels (VEC(tree,heap) *);\n void gimple_set_body (tree, gimple_seq);\n gimple_seq gimple_body (tree);\n+bool gimple_has_body_p (tree);\n gimple_seq gimple_seq_alloc (void);\n void gimple_seq_free (gimple_seq);\n void gimple_seq_add_seq (gimple_seq *, gimple_seq);"}, {"sha": "66b9bac79de3865b9a08c1c23d9f3480c41cd2a8", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39ecc018798bc85d22bfc3c3155986ab5b35f5ac/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39ecc018798bc85d22bfc3c3155986ab5b35f5ac/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=39ecc018798bc85d22bfc3c3155986ab5b35f5ac", "patch": "@@ -212,7 +212,7 @@ cgraph_clone_inlined_nodes (struct cgraph_edge *e, bool duplicate,\n \t  && !cgraph_new_nodes)\n \t{\n \t  gcc_assert (!e->callee->global.inlined_to);\n-\t  if (gimple_body (e->callee->decl))\n+\t  if (e->callee->analyzed)\n \t    overall_insns -= e->callee->global.insns, nfunctions_inlined++;\n \t  duplicate = false;\n \t}\n@@ -1388,7 +1388,7 @@ cgraph_decide_inlining_incrementally (struct cgraph_node *node,\n \t    }\n \t  continue;\n \t}\n-      if (!gimple_body (e->callee->decl) && !e->callee->inline_decl)\n+      if (!e->callee->analyzed && !e->callee->inline_decl)\n \t{\n \t  if (dump_file)\n \t    {\n@@ -1463,7 +1463,7 @@ cgraph_decide_inlining_incrementally (struct cgraph_node *node,\n \t      }\n \t    continue;\n \t  }\n-\tif (!gimple_body (e->callee->decl) && !e->callee->inline_decl)\n+\tif (!e->callee->analyzed && !e->callee->inline_decl)\n \t  {\n \t    if (dump_file)\n \t      {\n@@ -1706,7 +1706,7 @@ inline_transform (struct cgraph_node *node)\n \n   /* We might need the body of this function so that we can expand\n      it inline somewhere else.  */\n-  if (cgraph_preserve_function_body_p (current_function_decl))\n+  if (cgraph_preserve_function_body_p (node->decl))\n     save_inline_function_body (node);\n \n   for (e = node->callees; e; e = e->next_callee)"}, {"sha": "ce0649db1d8ffabb9881f53f7214473b5015181e", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39ecc018798bc85d22bfc3c3155986ab5b35f5ac/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39ecc018798bc85d22bfc3c3155986ab5b35f5ac/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=39ecc018798bc85d22bfc3c3155986ab5b35f5ac", "patch": "@@ -217,7 +217,10 @@ build_gimple_cfg (gimple_seq seq)\n static unsigned int\n execute_build_cfg (void)\n {\n-  build_gimple_cfg (gimple_body (current_function_decl));\n+  gimple_seq body = gimple_body (current_function_decl);\n+\n+  build_gimple_cfg (body);\n+  gimple_set_body (current_function_decl, NULL);\n   return 0;\n }\n \n@@ -5898,7 +5901,7 @@ dump_function_to_file (tree fn, FILE *file, int flags)\n   if (dsf && (flags & TDF_DETAILS))\n     dump_eh_tree (file, dsf);\n \n-  if (flags & TDF_RAW && !gimple_body (fn))\n+  if (flags & TDF_RAW && !gimple_has_body_p (fn))\n     {\n       dump_node (fn, TDF_SLIM | flags, file);\n       return;"}, {"sha": "8b603f0a37c5786e9170340c702571a95648d022", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 35, "deletions": 17, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39ecc018798bc85d22bfc3c3155986ab5b35f5ac/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39ecc018798bc85d22bfc3c3155986ab5b35f5ac/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=39ecc018798bc85d22bfc3c3155986ab5b35f5ac", "patch": "@@ -1692,8 +1692,6 @@ static void\n initialize_cfun (tree new_fndecl, tree callee_fndecl, gcov_type count,\n \t\t int frequency)\n {\n-  struct function *new_cfun\n-     = (struct function *) ggc_alloc_cleared (sizeof (struct function));\n   struct function *src_cfun = DECL_STRUCT_FUNCTION (callee_fndecl);\n   gcov_type count_scale, frequency_scale;\n \n@@ -1712,14 +1710,40 @@ initialize_cfun (tree new_fndecl, tree callee_fndecl, gcov_type count,\n \n   /* Register specific tree functions.  */\n   gimple_register_cfg_hooks ();\n-  *new_cfun = *DECL_STRUCT_FUNCTION (callee_fndecl);\n-  new_cfun->funcdef_no = get_next_funcdef_no ();\n-  VALUE_HISTOGRAMS (new_cfun) = NULL;\n-  new_cfun->local_decls = NULL;\n-  new_cfun->cfg = NULL;\n-  new_cfun->decl = new_fndecl /*= copy_node (callee_fndecl)*/;\n-  DECL_STRUCT_FUNCTION (new_fndecl) = new_cfun;\n-  push_cfun (new_cfun);\n+\n+  /* Get clean struct function.  */\n+  push_struct_function (new_fndecl);\n+\n+  /* We will rebuild these, so just sanity check that they are empty.  */\n+  gcc_assert (VALUE_HISTOGRAMS (cfun) == NULL);\n+  gcc_assert (cfun->local_decls == NULL);\n+  gcc_assert (cfun->cfg == NULL);\n+  gcc_assert (cfun->decl == new_fndecl);\n+\n+  /* No need to copy; this is initialized later in compilation.  */\n+  gcc_assert (!src_cfun->calls_setjmp);\n+  gcc_assert (!src_cfun->calls_alloca);\n+\n+  /* Copy items we preserve during clonning.  */\n+  cfun->static_chain_decl = src_cfun->static_chain_decl;\n+  cfun->nonlocal_goto_save_area = src_cfun->nonlocal_goto_save_area;\n+  cfun->function_end_locus = src_cfun->function_end_locus;\n+  cfun->curr_properties = src_cfun->curr_properties;\n+  cfun->last_verified = src_cfun->last_verified;\n+  if (src_cfun->ipa_transforms_to_apply)\n+    cfun->ipa_transforms_to_apply = VEC_copy (ipa_opt_pass, heap,\n+\t\t\t\t\t      src_cfun->ipa_transforms_to_apply);\n+  cfun->va_list_gpr_size = src_cfun->va_list_gpr_size;\n+  cfun->va_list_fpr_size = src_cfun->va_list_fpr_size;\n+  cfun->function_frequency = src_cfun->function_frequency;\n+  cfun->has_nonlocal_label = src_cfun->has_nonlocal_label;\n+  cfun->stdarg = src_cfun->stdarg;\n+  cfun->dont_save_pending_sizes_p = src_cfun->dont_save_pending_sizes_p;\n+  cfun->after_inlining = src_cfun->after_inlining;\n+  cfun->returns_struct = src_cfun->returns_struct;\n+  cfun->returns_pcc_struct = src_cfun->returns_pcc_struct;\n+  cfun->after_tree_profile = src_cfun->after_tree_profile;\n+\n   init_empty_tree_cfg ();\n \n   ENTRY_BLOCK_PTR->count =\n@@ -2581,12 +2605,6 @@ inlinable_function_p (tree fn)\n       inlinable = false;\n     }\n \n-  /* If we don't have the function body available, we can't inline it.\n-     However, this should not be recorded since we also get here for\n-     forward declared inline functions.  Therefore, return at once.  */\n-  if (!gimple_body (fn))\n-    return false;\n-\n   else if (inline_forbidden_p (fn))\n     {\n       /* See if we should warn about uninlinable functions.  Previously,\n@@ -3089,7 +3107,7 @@ expand_call_inline (basic_block bb, gimple stmt, copy_body_data *id)\n      gimple_body.  */\n   if (!DECL_INITIAL (fn)\n       && DECL_ABSTRACT_ORIGIN (fn)\n-      && gimple_body (DECL_ABSTRACT_ORIGIN (fn)))\n+      && gimple_has_body_p (DECL_ABSTRACT_ORIGIN (fn)))\n     fn = DECL_ABSTRACT_ORIGIN (fn);\n \n   /* Objective C and fortran still calls tree_rest_of_compilation directly."}]}