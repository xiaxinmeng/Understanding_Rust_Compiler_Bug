{"sha": "973c150c2d564fbe077f14cb80c17da175c89323", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTczYzE1MGMyZDU2NGZiZTA3N2YxNGNiODBjMTdkYTE3NWM4OTMyMw==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2017-09-26T17:15:29Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2017-09-26T17:15:29Z"}, "message": "Make SRA qsort comparator transitive\n\n2017-09-26  Martin Jambor  <mjambor@suse.cz>\n\n\t* tree-sra.c (compare_access_positions): Put integral types first,\n\tstabilize sorting of integral types, remove conditions putting\n\tnon-full-precision integers last.\n\t(sort_and_splice_var_accesses): Disable scalarization if a\n\tnon-integert would be represented by a non-full-precision integer.\n\nFrom-SVN: r253207", "tree": {"sha": "8608b6c9baa1858a00c6b1d4c38c4a409a782802", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8608b6c9baa1858a00c6b1d4c38c4a409a782802"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/973c150c2d564fbe077f14cb80c17da175c89323", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/973c150c2d564fbe077f14cb80c17da175c89323", "html_url": "https://github.com/Rust-GCC/gccrs/commit/973c150c2d564fbe077f14cb80c17da175c89323", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/973c150c2d564fbe077f14cb80c17da175c89323/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5714abfff8a8b04cdd294bd9968bcc72924213ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5714abfff8a8b04cdd294bd9968bcc72924213ec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5714abfff8a8b04cdd294bd9968bcc72924213ec"}], "stats": {"total": 50, "additions": 40, "deletions": 10}, "files": [{"sha": "b2a2755dcf4072bbed8ba5f29031cbd31bb2fe53", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/973c150c2d564fbe077f14cb80c17da175c89323/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/973c150c2d564fbe077f14cb80c17da175c89323/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=973c150c2d564fbe077f14cb80c17da175c89323", "patch": "@@ -1,3 +1,11 @@\n+2017-09-26  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* tree-sra.c (compare_access_positions): Put integral types first,\n+\tstabilize sorting of integral types, remove conditions putting\n+\tnon-full-precision integers last.\n+\t(sort_and_splice_var_accesses): Disable scalarization if a\n+\tnon-integert would be represented by a non-full-precision integer.\n+\n 2017-09-26  Joseph Myers  <joseph@codesourcery.com>\n \n \t* config/microblaze/linux.h (TARGET_ASM_FILE_END): Likewise."}, {"sha": "f5675edc7f1090d79e04398c6707c4af60f78454", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 32, "deletions": 10, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/973c150c2d564fbe077f14cb80c17da175c89323/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/973c150c2d564fbe077f14cb80c17da175c89323/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=973c150c2d564fbe077f14cb80c17da175c89323", "patch": "@@ -1542,19 +1542,20 @@ compare_access_positions (const void *a, const void *b)\n \t       && TREE_CODE (f2->type) != COMPLEX_TYPE\n \t       && TREE_CODE (f2->type) != VECTOR_TYPE)\n \treturn -1;\n-      /* Put the integral type with the bigger precision first.  */\n+      /* Put any integral type before any non-integral type.  When splicing, we\n+\t make sure that those with insufficient precision and occupying the\n+\t same space are not scalarized.  */\n       else if (INTEGRAL_TYPE_P (f1->type)\n+\t       && !INTEGRAL_TYPE_P (f2->type))\n+\treturn -1;\n+      else if (!INTEGRAL_TYPE_P (f1->type)\n \t       && INTEGRAL_TYPE_P (f2->type))\n-\treturn TYPE_PRECISION (f2->type) - TYPE_PRECISION (f1->type);\n-      /* Put any integral type with non-full precision last.  */\n-      else if (INTEGRAL_TYPE_P (f1->type)\n-\t       && (TREE_INT_CST_LOW (TYPE_SIZE (f1->type))\n-\t\t   != TYPE_PRECISION (f1->type)))\n \treturn 1;\n-      else if (INTEGRAL_TYPE_P (f2->type)\n-\t       && (TREE_INT_CST_LOW (TYPE_SIZE (f2->type))\n-\t\t   != TYPE_PRECISION (f2->type)))\n-\treturn -1;\n+      /* Put the integral type with the bigger precision first.  */\n+      else if (INTEGRAL_TYPE_P (f1->type)\n+\t       && INTEGRAL_TYPE_P (f2->type)\n+\t       && (TYPE_PRECISION (f2->type) != TYPE_PRECISION (f1->type)))\n+\treturn TYPE_PRECISION (f2->type) - TYPE_PRECISION (f1->type);\n       /* Stabilize the sort.  */\n       return TYPE_UID (f1->type) - TYPE_UID (f2->type);\n     }\n@@ -2055,6 +2056,11 @@ sort_and_splice_var_accesses (tree var)\n       bool grp_partial_lhs = access->grp_partial_lhs;\n       bool first_scalar = is_gimple_reg_type (access->type);\n       bool unscalarizable_region = access->grp_unscalarizable_region;\n+      bool bf_non_full_precision\n+\t= (INTEGRAL_TYPE_P (access->type)\n+\t   && TYPE_PRECISION (access->type) != access->size\n+\t   && TREE_CODE (access->expr) == COMPONENT_REF\n+\t   && DECL_BIT_FIELD (TREE_OPERAND (access->expr, 1)));\n \n       if (first || access->offset >= high)\n \t{\n@@ -2102,6 +2108,22 @@ sort_and_splice_var_accesses (tree var)\n \t     this combination of size and offset, the comparison function\n \t     should have put the scalars first.  */\n \t  gcc_assert (first_scalar || !is_gimple_reg_type (ac2->type));\n+\t  /* It also prefers integral types to non-integral.  However, when the\n+\t     precision of the selected type does not span the entire area and\n+\t     should also be used for a non-integer (i.e. float), we must not\n+\t     let that happen.  Normally analyze_access_subtree expands the type\n+\t     to cover the entire area but for bit-fields it doesn't.  */\n+\t  if (bf_non_full_precision && !INTEGRAL_TYPE_P (ac2->type))\n+\t    {\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t{\n+\t\t  fprintf (dump_file, \"Cannot scalarize the following access \"\n+\t\t\t   \"because insufficient precision integer type was \"\n+\t\t\t   \"selected.\\n  \");\n+\t\t  dump_access (dump_file, access, false);\n+\t\t}\n+\t      unscalarizable_region = true;\n+\t    }\n \t  ac2->group_representative = access;\n \t  j++;\n \t}"}]}