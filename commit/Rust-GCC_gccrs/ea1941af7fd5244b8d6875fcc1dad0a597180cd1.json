{"sha": "ea1941af7fd5244b8d6875fcc1dad0a597180cd1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWExOTQxYWY3ZmQ1MjQ0YjhkNjg3NWZjYzFkYWQwYTU5NzE4MGNkMQ==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2007-04-06T09:17:34Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-04-06T09:17:34Z"}, "message": "exp_ch3.ads, [...] (Analyze_N_Full_Type_Declaration): For an anonymous access component...\n\n2007-04-06  Ed Schonberg  <schonberg@adacore.com>\n\t    Javier Miranda  <miranda@adacore.com>\n\n\t* exp_ch3.ads, exp_ch3.adb (Analyze_N_Full_Type_Declaration): For an\n\tanonymous access component, do not create a master_id if type already\n\thas one, as may happen if the type is a subcomponent of a packed array\n\ttype.\n\t(Build_Init_Procedure, Component_Needs_Simple_Initialization,\n\tInitialize_Tag): Remove code associated with the old CPP pragmas.\n\tCPP_Virtual and CPP_Vtable are no longer supported.\n\t(Build_Offset_To_Top_Internal): Add support for concurrent record types\n\t(Build_Offset_To_Top_Functions): Add support for concurrent record types\n\t(Freeze_Record_Type): Remove call to\n\tInit_Predefined_Interface_Primitives.\n\t(Init_Secondary_Tags.Initialize_Tag): New subprogram containing all the\n\tcode required to initialize the tags of the secondary dispatch tables.\n\tThis leaves the algoritm more clear.\n\t(Init_Secondary_Tags): Add support for concurrent record types\n\t(Make_Predefined_Primitive_Specs): Code cleanup.\n\t(Predefined_Primitive_Bodies): Code cleanup.\n\t(Build_Master_Renaming): New local subprogram.\n\t(Expand_N_Full_Type_Declaration): Build the master_id associated with\n\tanonymous access to task type components.\n\t(Expand_N_Subtype_Indication): The bounds of a range constraint in a\n\tsubtype indication are resolved during analysis, and must not be done\n\there.\n\t(Stream_Operation_OK): Check Restriction_Active before RTE_Available.\n\nFrom-SVN: r123551", "tree": {"sha": "c6d990134c0a3e32e79bb1e35a41a5c158d69b15", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c6d990134c0a3e32e79bb1e35a41a5c158d69b15"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ea1941af7fd5244b8d6875fcc1dad0a597180cd1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea1941af7fd5244b8d6875fcc1dad0a597180cd1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea1941af7fd5244b8d6875fcc1dad0a597180cd1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea1941af7fd5244b8d6875fcc1dad0a597180cd1/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3d6efb77de361ca80a8988350863ef02499148ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d6efb77de361ca80a8988350863ef02499148ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d6efb77de361ca80a8988350863ef02499148ee"}], "stats": {"total": 1028, "additions": 632, "deletions": 396}, "files": [{"sha": "8c84a2df697b1aec6de2628f68135e2dfaefbdb2", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 622, "deletions": 385, "changes": 1007, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea1941af7fd5244b8d6875fcc1dad0a597180cd1/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea1941af7fd5244b8d6875fcc1dad0a597180cd1/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=ea1941af7fd5244b8d6875fcc1dad0a597180cd1", "patch": "@@ -26,10 +26,10 @@\n \n with Atree;    use Atree;\n with Checks;   use Checks;\n-with Debug;    use Debug;\n with Einfo;    use Einfo;\n with Errout;   use Errout;\n with Exp_Aggr; use Exp_Aggr;\n+with Exp_Atag; use Exp_Atag;\n with Exp_Ch4;  use Exp_Ch4;\n with Exp_Ch6;  use Exp_Ch6;\n with Exp_Ch7;  use Exp_Ch7;\n@@ -92,6 +92,20 @@ package body Exp_Ch3 is\n    --  of the type. Otherwise new identifiers are created, with the source\n    --  names of the discriminants.\n \n+   function Build_Master_Renaming\n+     (N : Node_Id;\n+      T : Entity_Id) return Entity_Id;\n+   --  If the designated type of an access type is a task type or contains\n+   --  tasks, we make sure that a _Master variable is declared in the current\n+   --  scope, and then declare a renaming for it:\n+   --\n+   --    atypeM : Master_Id renames _Master;\n+   --\n+   --  where atyp is the name of the access type. This declaration is used when\n+   --  an allocator for the access type is expanded. The node is the full\n+   --  declaration of the designated type that contains tasks. The renaming\n+   --  declaration is inserted before N, and after the Master declaration.\n+\n    procedure Build_Record_Init_Proc (N : Node_Id; Pe : Entity_Id);\n    --  Build record initialization procedure. N is the type declaration\n    --  node, and Pe is the corresponding entity for the record type.\n@@ -508,7 +522,10 @@ package body Exp_Ch3 is\n          else\n             Clean_Task_Names (Comp_Type, Proc_Id);\n             return\n-              Build_Initialization_Call (Loc, Comp, Comp_Type, True, A_Type);\n+              Build_Initialization_Call\n+                (Loc, Comp, Comp_Type,\n+                 In_Init_Proc => True,\n+                 Enclos_Type  => A_Type);\n          end if;\n       end Init_Component;\n \n@@ -1143,6 +1160,7 @@ package body Exp_Ch3 is\n             --  for the value 3 (should be rtsfindable constant ???)\n \n             Append_To (Args, Make_Integer_Literal (Loc, 3));\n+\n          else\n             Append_To (Args, Make_Identifier (Loc, Name_uMaster));\n          end if;\n@@ -1343,7 +1361,10 @@ package body Exp_Ch3 is\n    -- Build_Master_Renaming --\n    ---------------------------\n \n-   procedure Build_Master_Renaming (N : Node_Id; T : Entity_Id) is\n+   function Build_Master_Renaming\n+     (N : Node_Id;\n+      T : Entity_Id) return Entity_Id\n+   is\n       Loc  : constant Source_Ptr := Sloc (N);\n       M_Id : Entity_Id;\n       Decl : Node_Id;\n@@ -1352,7 +1373,7 @@ package body Exp_Ch3 is\n       --  Nothing to do if there is no task hierarchy\n \n       if Restriction_Active (No_Task_Hierarchy) then\n-         return;\n+         return Empty;\n       end if;\n \n       M_Id :=\n@@ -1366,7 +1387,28 @@ package body Exp_Ch3 is\n           Name => Make_Identifier (Loc, Name_uMaster));\n       Insert_Before (N, Decl);\n       Analyze (Decl);\n+      return M_Id;\n \n+   exception\n+      when RE_Not_Available =>\n+         return Empty;\n+   end Build_Master_Renaming;\n+\n+   ---------------------------\n+   -- Build_Master_Renaming --\n+   ---------------------------\n+\n+   procedure Build_Master_Renaming (N : Node_Id; T : Entity_Id) is\n+      M_Id : Entity_Id;\n+\n+   begin\n+      --  Nothing to do if there is no task hierarchy\n+\n+      if Restriction_Active (No_Task_Hierarchy) then\n+         return;\n+      end if;\n+\n+      M_Id := Build_Master_Renaming (N, T);\n       Set_Master_Id (T, M_Id);\n \n    exception\n@@ -1764,9 +1806,20 @@ package body Exp_Ch3 is\n \n          procedure Build_Offset_To_Top_Internal (Typ : Entity_Id) is\n          begin\n-            --  Climb to the ancestor (if any) handling private types\n+            --  Climb to the ancestor (if any) handling synchronized interface\n+            --  derivations and private types\n \n-            if Present (Full_View (Etype (Typ))) then\n+            if Is_Concurrent_Record_Type (Typ) then\n+               declare\n+                  Iface_List : constant List_Id :=\n+                                 Abstract_Interface_List (Typ);\n+               begin\n+                  if Is_Non_Empty_List (Iface_List) then\n+                     Build_Offset_To_Top_Internal (Etype (First (Iface_List)));\n+                  end if;\n+               end;\n+\n+            elsif Present (Full_View (Etype (Typ))) then\n                if Full_View (Etype (Typ)) /= Typ then\n                   Build_Offset_To_Top_Internal (Full_View (Etype (Typ)));\n                end if;\n@@ -1842,7 +1895,12 @@ package body Exp_Ch3 is\n       --  Start of processing for Build_Offset_To_Top_Functions\n \n       begin\n-         if Etype (Rec_Type) = Rec_Type\n+         if Is_Concurrent_Record_Type (Rec_Type)\n+           and then Is_Empty_List (Abstract_Interface_List (Rec_Type))\n+         then\n+            return;\n+\n+         elsif Etype (Rec_Type) = Rec_Type\n            or else not Has_Discriminants (Etype (Rec_Type))\n            or else No (Abstract_Interfaces (Rec_Type))\n            or else Is_Empty_Elmt_List (Abstract_Interfaces (Rec_Type))\n@@ -2011,7 +2069,6 @@ package body Exp_Ch3 is\n                declare\n                   Nod   : Node_Id := First (Body_Stmts);\n                   New_N : Node_Id;\n-                  Args  : List_Id;\n \n                begin\n                   --  We assume the first init_proc call is for the parent\n@@ -2026,82 +2083,61 @@ package body Exp_Ch3 is\n                   --  Generate:\n                   --     ancestor_constructor (_init.parent);\n                   --     if Arg2 then\n+                  --        inherit_prim_ops (_init._tag, new_dt, num_prims);\n                   --        _init._tag := new_dt;\n                   --     end if;\n \n-                  if Debug_Flag_QQ then\n-                     Init_Tag :=\n-                       Make_If_Statement (Loc,\n-                         Condition => New_Occurrence_Of (Set_Tag, Loc),\n-                         Then_Statements => New_List (Init_Tag));\n-                     Insert_After (Nod, Init_Tag);\n+                  New_N :=\n+                    Build_Inherit_Prims (Loc,\n+                      Old_Tag_Node =>\n+                        Make_Selected_Component (Loc,\n+                          Prefix => Make_Identifier (Loc, Name_uInit),\n+                          Selector_Name =>\n+                            New_Reference_To\n+                              (First_Tag_Component (Rec_Type), Loc)),\n+                      New_Tag_Node =>\n+                        New_Reference_To\n+                          (Node (First_Elmt (Access_Disp_Table (Rec_Type))),\n+                           Loc),\n+                      Num_Prims =>\n+                        UI_To_Int\n+                          (DT_Entry_Count (First_Tag_Component (Rec_Type))));\n+\n+                  Init_Tag :=\n+                    Make_If_Statement (Loc,\n+                      Condition => New_Occurrence_Of (Set_Tag, Loc),\n+                      Then_Statements => New_List (New_N, Init_Tag));\n+\n+                  Insert_After (Nod, Init_Tag);\n+\n+                  --  We have inherited the whole contents of the DT table\n+                  --  from the CPP side. Therefore all our previous initia-\n+                  --  lization has been lost and we must refill entries\n+                  --  associated with Ada primitives. This needs more work\n+                  --  to avoid its execution each time an object is\n+                  --  initialized???\n+\n+                  declare\n+                     E    : Elmt_Id;\n+                     Prim : Node_Id;\n \n-                  --  Generate:\n-                  --     ancestor_constructor (_init.parent);\n-                  --     if Arg2 then\n-                  --        inherit_dt (_init._tag, new_dt, num_prims);\n-                  --        _init._tag := new_dt;\n-                  --     end if;\n-                  else\n-                     Args := New_List (\n-                        Node1 =>\n-                          Make_Selected_Component (Loc,\n-                            Prefix => Make_Identifier (Loc, Name_uInit),\n-                            Selector_Name =>\n-                              New_Reference_To\n-                                (First_Tag_Component (Rec_Type), Loc)),\n-\n-                        Node2 =>\n-                          New_Reference_To\n-                            (Node (First_Elmt (Access_Disp_Table (Rec_Type))),\n-                             Loc),\n-\n-                        Node3 =>\n-                          Make_Integer_Literal (Loc,\n-                            DT_Entry_Count (First_Tag_Component (Rec_Type))));\n-\n-                     New_N :=\n-                       Make_Procedure_Call_Statement (Loc,\n-                         Name => New_Reference_To (RTE (RE_Inherit_CPP_DT),\n-                                                   Loc),\n-                         Parameter_Associations => Args);\n-\n-                     Init_Tag :=\n-                       Make_If_Statement (Loc,\n-                         Condition => New_Occurrence_Of (Set_Tag, Loc),\n-                         Then_Statements => New_List (New_N, Init_Tag));\n-\n-                     Insert_After (Nod, Init_Tag);\n-\n-                     --  We have inherited the whole contents of the DT table\n-                     --  from the CPP side. Therefore all our previous initia-\n-                     --  lization has been lost and we must refill entries\n-                     --  associated with Ada primitives. This needs more work\n-                     --  to avoid its execution each time an object is\n-                     --  initialized???\n-\n-                     declare\n-                        E    : Elmt_Id;\n-                        Prim : Node_Id;\n-\n-                     begin\n-                        E := First_Elmt (Primitive_Operations (Rec_Type));\n-                        while Present (E) loop\n-                           Prim := Node (E);\n-\n-                           if not Is_Imported (Prim)\n-                             and then Convention (Prim) = Convention_CPP\n-                             and then not Present (Abstract_Interface_Alias\n-                                                    (Prim))\n-                           then\n-                              Insert_After (Init_Tag,\n-                                 Fill_DT_Entry (Loc, Prim));\n-                           end if;\n+                  begin\n+                     E := First_Elmt (Primitive_Operations (Rec_Type));\n+                     while Present (E) loop\n+                        Prim := Node (E);\n+\n+                        if not Is_Imported (Prim)\n+                          and then Convention (Prim) = Convention_CPP\n+                          and then not Present (Abstract_Interface_Alias\n+                                                 (Prim))\n+                        then\n+                           Insert_After (Init_Tag,\n+                              Fill_DT_Entry (Loc, Prim));\n+                        end if;\n \n-                           Next_Elmt (E);\n-                        end loop;\n-                     end;\n-                  end if;\n+                        Next_Elmt (E);\n+                     end loop;\n+                  end;\n                end;\n             end if;\n \n@@ -2244,8 +2280,8 @@ package body Exp_Ch3 is\n                          Prefix => Make_Identifier (Loc, Name_uInit),\n                          Selector_Name => New_Occurrence_Of (Id, Loc)),\n                        Typ,\n-                       True,\n-                       Rec_Type,\n+                       In_Init_Proc => True,\n+                       Enclos_Type => Rec_Type,\n                        Discr_Map => Discr_Map);\n \n                   Clean_Task_Names (Typ, Proc_Id);\n@@ -2276,7 +2312,7 @@ package body Exp_Ch3 is\n                   --  if the parent holds discriminants that can be used\n                   --  to compute the offset of the controller. We assume here\n                   --  that the last statement of the initialization call is the\n-                  --  attachement of the parent (see Build_Initialization_Call)\n+                  --  attachment of the parent (see Build_Initialization_Call)\n \n                   if Chars (Id) = Name_uController\n                     and then Rec_Type /= Etype (Rec_Type)\n@@ -2311,9 +2347,12 @@ package body Exp_Ch3 is\n                      Append_List_To (Statement_List,\n                        Build_Initialization_Call (Loc,\n                          Make_Selected_Component (Loc,\n-                           Prefix => Make_Identifier (Loc, Name_uInit),\n+                           Prefix        => Make_Identifier (Loc, Name_uInit),\n                            Selector_Name => New_Occurrence_Of (Id, Loc)),\n-                         Typ, True, Rec_Type, Discr_Map => Discr_Map));\n+                         Typ,\n+                         In_Init_Proc => True,\n+                         Enclos_Type  => Rec_Type,\n+                         Discr_Map    => Discr_Map));\n \n                      Clean_Task_Names (Typ, Proc_Id);\n \n@@ -2486,7 +2525,6 @@ package body Exp_Ch3 is\n          return\n            Needs_Simple_Initialization (T)\n              and then not Is_RTE (T, RE_Tag)\n-             and then not Is_RTE (T, RE_Vtable_Ptr)\n \n                --  Ada 2005 (AI-251): Check also the tag of abstract interfaces\n \n@@ -3453,9 +3491,15 @@ package body Exp_Ch3 is\n       Par_Id : Entity_Id;\n       FN     : Node_Id;\n \n-   begin\n-      if Is_Access_Type (Def_Id) then\n+      procedure Build_Master (Def_Id : Entity_Id);\n+      --  Create the master associated with Def_Id\n \n+      ------------------\n+      -- Build_Master --\n+      ------------------\n+\n+      procedure Build_Master (Def_Id : Entity_Id) is\n+      begin\n          --  Anonymous access types are created for the components of the\n          --  record parameter for an entry declaration. No master is created\n          --  for such a type.\n@@ -3497,46 +3541,123 @@ package body Exp_Ch3 is\n            and then Convention (Designated_Type (Def_Id)) /= Convention_Java\n          then\n             Build_Class_Wide_Master (Def_Id);\n+         end if;\n+      end Build_Master;\n+\n+   --  Start of processing for Expand_N_Full_Type_Declaration\n+\n+   begin\n+      if Is_Access_Type (Def_Id) then\n+         Build_Master (Def_Id);\n \n-         elsif Ekind (Def_Id) = E_Access_Protected_Subprogram_Type then\n+         if Ekind (Def_Id) = E_Access_Protected_Subprogram_Type then\n             Expand_Access_Protected_Subprogram_Type (N);\n          end if;\n \n+      elsif Ada_Version >= Ada_05\n+        and then Is_Array_Type (Def_Id)\n+        and then Is_Access_Type (Component_Type (Def_Id))\n+        and then Ekind (Component_Type (Def_Id)) = E_Anonymous_Access_Type\n+      then\n+         Build_Master (Component_Type (Def_Id));\n+\n       elsif Has_Task (Def_Id) then\n          Expand_Previous_Access_Type (Def_Id);\n+\n+      elsif Ada_Version >= Ada_05\n+        and then\n+         (Is_Record_Type (Def_Id)\n+           or else (Is_Array_Type (Def_Id)\n+                      and then Is_Record_Type (Component_Type (Def_Id))))\n+      then\n+         declare\n+            Comp : Entity_Id;\n+            Typ  : Entity_Id;\n+            M_Id : Entity_Id;\n+\n+         begin\n+            --  Look for the first anonymous access type component\n+\n+            if Is_Array_Type (Def_Id) then\n+               Comp := First_Entity (Component_Type (Def_Id));\n+            else\n+               Comp := First_Entity (Def_Id);\n+            end if;\n+\n+            while Present (Comp) loop\n+               Typ := Etype (Comp);\n+\n+               exit when Is_Access_Type (Typ)\n+                 and then Ekind (Typ) = E_Anonymous_Access_Type;\n+\n+               Next_Entity (Comp);\n+            end loop;\n+\n+            --  If found we add a renaming reclaration of master_id and we\n+            --  associate it to each anonymous access type component. Do\n+            --  nothing if the access type already has a master. This will be\n+            --  the case if the array type is the packed array created for a\n+            --  user-defined array type T, where the master_id is created when\n+            --  expanding the declaration for T.\n+\n+            if Present (Comp)\n+              and then not Restriction_Active (No_Task_Hierarchy)\n+              and then No (Master_Id (Typ))\n+            then\n+               Build_Master_Entity (Def_Id);\n+               M_Id := Build_Master_Renaming (N, Def_Id);\n+\n+               if Is_Array_Type (Def_Id) then\n+                  Comp := First_Entity (Component_Type (Def_Id));\n+               else\n+                  Comp := First_Entity (Def_Id);\n+               end if;\n+\n+               while Present (Comp) loop\n+                  Typ := Etype (Comp);\n+\n+                  if Is_Access_Type (Typ)\n+                    and then Ekind (Typ) = E_Anonymous_Access_Type\n+                  then\n+                     Set_Master_Id (Typ, M_Id);\n+                  end if;\n+\n+                  Next_Entity (Comp);\n+               end loop;\n+            end if;\n+         end;\n       end if;\n \n       Par_Id := Etype (B_Id);\n \n-      --  The parent type is private then we need to inherit\n-      --  any TSS operations from the full view.\n+      --  The parent type is private then we need to inherit any TSS operations\n+      --  from the full view.\n \n       if Ekind (Par_Id) in Private_Kind\n         and then Present (Full_View (Par_Id))\n       then\n          Par_Id := Base_Type (Full_View (Par_Id));\n       end if;\n \n-      if Nkind (Type_Definition (Original_Node (N)))\n-         = N_Derived_Type_Definition\n+      if Nkind (Type_Definition (Original_Node (N))) =\n+                                                N_Derived_Type_Definition\n         and then not Is_Tagged_Type (Def_Id)\n         and then Present (Freeze_Node (Par_Id))\n         and then Present (TSS_Elist (Freeze_Node (Par_Id)))\n       then\n          Ensure_Freeze_Node (B_Id);\n-         FN :=  Freeze_Node (B_Id);\n+         FN := Freeze_Node (B_Id);\n \n          if No (TSS_Elist (FN)) then\n             Set_TSS_Elist (FN, New_Elmt_List);\n          end if;\n \n          declare\n-            T_E   : constant Elist_Id := TSS_Elist (FN);\n-            Elmt  : Elmt_Id;\n+            T_E  : constant Elist_Id := TSS_Elist (FN);\n+            Elmt : Elmt_Id;\n \n          begin\n-            Elmt  := First_Elmt (TSS_Elist (Freeze_Node (Par_Id)));\n-\n+            Elmt := First_Elmt (TSS_Elist (Freeze_Node (Par_Id)));\n             while Present (Elmt) loop\n                if Chars (Node (Elmt)) /= Name_uInit then\n                   Append_Elmt (Node (Elmt), T_E);\n@@ -3572,13 +3693,12 @@ package body Exp_Ch3 is\n \n    procedure Expand_N_Object_Declaration (N : Node_Id) is\n       Def_Id  : constant Entity_Id  := Defining_Identifier (N);\n-      Typ     : constant Entity_Id  := Etype (Def_Id);\n-      Loc     : constant Source_Ptr := Sloc (N);\n       Expr    : constant Node_Id    := Expression (N);\n-\n-      New_Ref : Node_Id;\n-      Id_Ref  : Node_Id;\n+      Loc     : constant Source_Ptr := Sloc (N);\n+      Typ     : constant Entity_Id  := Etype (Def_Id);\n       Expr_Q  : Node_Id;\n+      Id_Ref  : Node_Id;\n+      New_Ref : Node_Id;\n \n    begin\n       --  Don't do anything for deferred constants. All proper actions will\n@@ -3650,16 +3770,16 @@ package body Exp_Ch3 is\n \n             declare\n                L   : constant List_Id :=\n-                      Make_Init_Call (\n-                        Ref         => New_Occurrence_Of (Def_Id, Loc),\n-                        Typ         => Base_Type (Typ),\n-                        Flist_Ref   => Find_Final_List (Def_Id),\n-                        With_Attach => Make_Integer_Literal (Loc, 1));\n+                       Make_Init_Call\n+                         (Ref         => New_Occurrence_Of (Def_Id, Loc),\n+                          Typ         => Base_Type (Typ),\n+                          Flist_Ref   => Find_Final_List (Def_Id),\n+                          With_Attach => Make_Integer_Literal (Loc, 1));\n \n                Blk : constant Node_Id :=\n-                 Make_Block_Statement (Loc,\n-                   Handled_Statement_Sequence =>\n-                     Make_Handled_Sequence_Of_Statements (Loc, L));\n+                       Make_Block_Statement (Loc,\n+                         Handled_Statement_Sequence =>\n+                           Make_Handled_Sequence_Of_Statements (Loc, L));\n \n             begin\n                Prepend_To (L, Build_Runtime_Call (Loc, RE_Abort_Defer));\n@@ -3680,12 +3800,12 @@ package body Exp_Ch3 is\n          if Has_Non_Null_Base_Init_Proc (Typ)\n            and then not No_Initialization (N)\n          then\n-            --  The call to the initialization procedure does NOT freeze\n-            --  the object being initialized. This is because the call is\n-            --  not a source level call. This works fine, because the only\n-            --  possible statements depending on freeze status that can\n-            --  appear after the _Init call are rep clauses which can\n-            --  safely appear after actual references to the object.\n+            --  The call to the initialization procedure does NOT freeze the\n+            --  object being initialized. This is because the call is not a\n+            --  source level call. This works fine, because the only possible\n+            --  statements depending on freeze status that can appear after the\n+            --  _Init call are rep clauses which can safely appear after actual\n+            --  references to the object.\n \n             Id_Ref := New_Reference_To (Def_Id, Loc);\n             Set_Must_Not_Freeze (Id_Ref);\n@@ -3699,8 +3819,8 @@ package body Exp_Ch3 is\n          --  initialization is required even though No_Init_Flag is present.\n \n          --  An internally generated temporary needs no initialization because\n-         --  it will be assigned subsequently. In particular, there is no\n-         --  point in applying Initialize_Scalars to such a temporary.\n+         --  it will be assigned subsequently. In particular, there is no point\n+         --  in applying Initialize_Scalars to such a temporary.\n \n          elsif Needs_Simple_Initialization (Typ)\n             and then not Is_Internal (Def_Id)\n@@ -3791,23 +3911,112 @@ package body Exp_Ch3 is\n                end if;\n             end if;\n \n-            --  If the type is controlled we attach the object to the final\n-            --  list and adjust the target after the copy. This\n-            --  ??? incomplete sentence\n+            --  Ada 2005 (AI-251): Rewrite the expression that initializes a\n+            --  class-wide object to ensure that we copy the full object.\n+\n+            --  Replace\n+            --      CW : I'Class := Obj;\n+            --  by\n+            --      CW__1 : I'Class := I'Class (Base_Address (Obj'Address));\n+            --      CW    : I'Class renames Displace (CW__1, I'Tag);\n+\n+            if Is_Interface (Typ)\n+              and then Is_Class_Wide_Type (Etype (Expr))\n+              and then Comes_From_Source (Def_Id)\n+            then\n+               declare\n+                  Decl_1 : Node_Id;\n+                  Decl_2 : Node_Id;\n \n-            --  Ada 2005 (AI-251): Do not register in the final list objects\n-            --  containing class-wide interfaces; otherwise we erroneously\n-            --  register the tag of the interface in the final list. Example:\n+               begin\n+                  Decl_1 :=\n+                    Make_Object_Declaration (Loc,\n+                      Defining_Identifier =>\n+                        Make_Defining_Identifier (Loc,\n+                          New_Internal_Name ('D')),\n \n-            --    Obj1 : T; --  Controlled object that implements Iface\n-            --    Obj2 : Iface'Class := Iface'Class (Obj1);\n+                      Object_Definition =>\n+                        Make_Attribute_Reference (Loc,\n+                          Prefix => Make_Identifier (Loc,\n+                                      Chars (Root_Type (Etype (Def_Id)))),\n+                          Attribute_Name => Name_Class),\n \n-            --  Obj1 is registered in the final list; Obj2 is not registered.\n+                      Expression =>\n+                        Unchecked_Convert_To\n+                          (Class_Wide_Type (Root_Type (Etype (Def_Id))),\n+                            Make_Explicit_Dereference (Loc,\n+                              Unchecked_Convert_To (RTE (RE_Tag_Ptr),\n+                                Make_Function_Call (Loc,\n+                                  Name =>\n+                                    New_Reference_To (RTE (RE_Base_Address),\n+                                                      Loc),\n+                                  Parameter_Associations => New_List (\n+                                    Make_Attribute_Reference (Loc,\n+                                      Prefix         => Relocate_Node (Expr),\n+                                      Attribute_Name => Name_Address)))))));\n \n-            if Controlled_Type (Typ)\n-              and then not (Is_Interface (Typ)\n-                             and then Is_Class_Wide_Type (Typ))\n-            then\n+                  Insert_Action (N, Decl_1);\n+\n+                  Decl_2 :=\n+                    Make_Object_Renaming_Declaration (Loc,\n+                      Defining_Identifier =>\n+                        Make_Defining_Identifier (Loc,\n+                          New_Internal_Name ('D')),\n+\n+                      Subtype_Mark =>\n+                        Make_Attribute_Reference (Loc,\n+                          Prefix =>\n+                            Make_Identifier (Loc,\n+                              Chars => Chars (Root_Type (Etype (Def_Id)))),\n+                          Attribute_Name => Name_Class),\n+\n+                      Name =>\n+                        Unchecked_Convert_To (\n+                          Class_Wide_Type (Root_Type (Etype (Def_Id))),\n+                          Make_Explicit_Dereference (Loc,\n+                            Unchecked_Convert_To (RTE (RE_Tag_Ptr),\n+                              Make_Function_Call (Loc,\n+                                Name =>\n+                                  New_Reference_To (RTE (RE_Displace), Loc),\n+\n+                                Parameter_Associations => New_List (\n+                                  Make_Attribute_Reference (Loc,\n+                                    Prefix =>\n+                                      New_Reference_To\n+                                        (Defining_Identifier (Decl_1), Loc),\n+                                    Attribute_Name => Name_Address),\n+\n+                                  Unchecked_Convert_To (RTE (RE_Tag),\n+                                    New_Reference_To\n+                                      (Node\n+                                        (First_Elmt\n+                                          (Access_Disp_Table\n+                                             (Root_Type (Typ)))),\n+                                       Loc))))))));\n+\n+                  Rewrite (N, Decl_2);\n+                  Analyze (N);\n+\n+                  --  Replace internal identifier of Decl_2 by the identifier\n+                  --  found in the sources. We also have to exchange entities\n+                  --  containing their defining identifiers to ensure the\n+                  --  correct replacement of the object declaration by this\n+                  --  object renaming declaration (because such definings\n+                  --  identifier have been previously added by Enter_Name to\n+                  --  the current scope).\n+\n+                  Set_Chars (Defining_Identifier (N), Chars (Def_Id));\n+                  Exchange_Entities (Defining_Identifier (N), Def_Id);\n+\n+                  return;\n+               end;\n+            end if;\n+\n+            --  If the type is controlled we attach the object to the final\n+            --  list and adjust the target after the copy. This\n+            --  ??? incomplete sentence\n+\n+            if Controlled_Type (Typ) then\n                declare\n                   Flist : Node_Id;\n                   F     : Entity_Id;\n@@ -3984,7 +4193,6 @@ package body Exp_Ch3 is\n            or else\n          Nkind (Parent (N)) = N_Slice\n       then\n-         Resolve (Ran, Typ);\n          Apply_Range_Check (Ran, Typ);\n       end if;\n    end Expand_N_Subtype_Indication;\n@@ -3996,10 +4204,9 @@ package body Exp_Ch3 is\n    --  If the last variant does not contain the Others choice, replace it with\n    --  an N_Others_Choice node since Gigi always wants an Others. Note that we\n    --  do not bother to call Analyze on the modified variant part, since it's\n-   --  only effect would be to compute the contents of the\n-   --  Others_Discrete_Choices node laboriously, and of course we already know\n-   --  the list of choices that corresponds to the others choice (it's the\n-   --  list we are replacing!)\n+   --  only effect would be to compute the Others_Discrete_Choices node\n+   --  laboriously, and of course we already know the list of choices that\n+   --  corresponds to the others choice (it's the list we are replacing!)\n \n    procedure Expand_N_Variant_Part (N : Node_Id) is\n       Last_Var    : constant Node_Id := Last_Non_Pragma (Variants (N));\n@@ -4096,8 +4303,8 @@ package body Exp_Ch3 is\n \n       else\n          --  The controller cannot be placed before the _Parent field since\n-         --  gigi lays out field in order and _parent must be first to\n-         --  preserve the polymorphism of tagged types.\n+         --  gigi lays out field in order and _parent must be first to preserve\n+         --  the polymorphism of tagged types.\n \n          First_Comp := First (Component_Items (Comp_List));\n \n@@ -4770,9 +4977,15 @@ package body Exp_Ch3 is\n             --  must be before the freeze point).\n \n             Set_Is_Frozen (Def_Id, False);\n-            Make_Predefined_Primitive_Specs\n-              (Def_Id, Predef_List, Renamed_Eq);\n-            Insert_List_Before_And_Analyze (N, Predef_List);\n+\n+            --  Do not add the spec of the predefined primitives if we are\n+            --  compiling under restriction No_Dispatching_Calls\n+\n+            if not Restriction_Active (No_Dispatching_Calls) then\n+               Make_Predefined_Primitive_Specs\n+                 (Def_Id, Predef_List, Renamed_Eq);\n+               Insert_List_Before_And_Analyze (N, Predef_List);\n+            end if;\n \n             --  Ada 2005 (AI-391): For a nonabstract null extension, create\n             --  wrapper functions for each nonoverridden inherited function\n@@ -4781,7 +4994,7 @@ package body Exp_Ch3 is\n             --  the parent function.\n \n             if Ada_Version >= Ada_05\n-              and then not Is_Abstract (Def_Id)\n+              and then not Is_Abstract_Type (Def_Id)\n               and then Is_Null_Extension (Def_Id)\n             then\n                Make_Controlling_Function_Wrappers\n@@ -4797,7 +5010,7 @@ package body Exp_Ch3 is\n \n             if Ada_Version >= Ada_05\n               and then Etype (Def_Id) /= Def_Id\n-              and then not Is_Abstract (Def_Id)\n+              and then not Is_Abstract_Type (Def_Id)\n             then\n                Make_Null_Procedure_Specs (Def_Id, Null_Proc_Decl_List);\n                Insert_Actions (N, Null_Proc_Decl_List);\n@@ -4839,7 +5052,13 @@ package body Exp_Ch3 is\n                   begin\n                      --  Climb to the ancestor (if any) handling private types\n \n-                     if Present (Full_View (Etype (Typ))) then\n+                     if Is_Concurrent_Record_Type (Typ) then\n+                        if Present (Abstract_Interface_List (Typ)) then\n+                           Add_Secondary_Tables\n+                             (Etype (First (Abstract_Interface_List (Typ))));\n+                        end if;\n+\n+                     elsif Present (Full_View (Etype (Typ))) then\n                         if Full_View (Etype (Typ)) /= Typ then\n                            Add_Secondary_Tables (Full_View (Etype (Typ)));\n                         end if;\n@@ -4913,12 +5132,14 @@ package body Exp_Ch3 is\n                    (Find_Prim_Op (Def_Id, Name_Finalize), Sloc (Def_Id)));\n             end if;\n \n-            --  Freeze rest of primitive operations\n+            --  Freeze rest of primitive operations. There is no need to handle\n+            --  the predefined primitives if we are compiling under restriction\n+            --  No_Dispatching_Calls\n \n-            Append_Freeze_Actions\n-              (Def_Id, Predefined_Primitive_Freeze (Def_Id));\n-            Append_Freeze_Actions\n-              (Def_Id, Init_Predefined_Interface_Primitives (Def_Id));\n+            if not Restriction_Active (No_Dispatching_Calls) then\n+               Append_Freeze_Actions\n+                 (Def_Id, Predefined_Primitive_Freeze (Def_Id));\n+            end if;\n          end if;\n \n       --  In the non-tagged case, an equality function is provided only for\n@@ -4990,8 +5211,14 @@ package body Exp_Ch3 is\n       --  the primitive operations may need the initialization routine\n \n       if Is_Tagged_Type (Def_Id) then\n-         Predef_List := Predefined_Primitive_Bodies (Def_Id, Renamed_Eq);\n-         Append_Freeze_Actions (Def_Id, Predef_List);\n+\n+         --  Do not add the body of the predefined primitives if we are\n+         --  compiling under restriction No_Dispatching_Calls\n+\n+         if not Restriction_Active (No_Dispatching_Calls) then\n+            Predef_List := Predefined_Primitive_Bodies (Def_Id, Renamed_Eq);\n+            Append_Freeze_Actions (Def_Id, Predef_List);\n+         end if;\n \n          --  Ada 2005 (AI-391): If any wrappers were created for nonoverridden\n          --  inherited functions, then add their bodies to the freeze actions.\n@@ -5007,10 +5234,7 @@ package body Exp_Ch3 is\n          if Ada_Version >= Ada_05\n            and then not Restriction_Active (No_Dispatching_Calls)\n            and then Is_Concurrent_Record_Type (Def_Id)\n-           and then Implements_Interface (\n-                      Typ          => Def_Id,\n-                      Kind         => Any_Limited_Interface,\n-                      Check_Parent => True)\n+           and then Has_Abstract_Interfaces (Def_Id)\n          then\n             Append_Freeze_Actions (Def_Id,\n               Make_Select_Specific_Data_Table (Def_Id));\n@@ -5867,31 +6091,227 @@ package body Exp_Ch3 is\n       Target     : Node_Id;\n       Stmts_List : List_Id)\n    is\n-      Loc      : constant Source_Ptr := Sloc (Target);\n-      ADT      : Elmt_Id;\n-      Full_Typ : Entity_Id;\n+      Loc         : constant Source_Ptr := Sloc (Target);\n+      ADT         : Elmt_Id;\n+      Full_Typ    : Entity_Id;\n+      AI_Tag_Comp : Entity_Id;\n+\n+      Is_Synch_Typ : Boolean := False;\n+      --  In case of non concurrent-record-types each parent-type has the\n+      --  tags associated with the interface types that are not implemented\n+      --  by the ancestors; concurrent-record-types have their whole list of\n+      --  interface tags (and this case requires some special management).\n+\n+      procedure Initialize_Tag\n+        (Typ       : Entity_Id;\n+         Iface     : Entity_Id;\n+         Tag_Comp  : in out Entity_Id;\n+         Iface_Tag : Node_Id);\n+      --  Initialize the tag of the secondary dispatch table of Typ associated\n+      --  with Iface. Tag_Comp is the component of Typ that stores Iface_Tag.\n \n       procedure Init_Secondary_Tags_Internal (Typ : Entity_Id);\n       --  Internal subprogram used to recursively climb to the root type.\n       --  We assume that all the primitives of the imported C++ class are\n       --  defined in the C side.\n \n+      --------------------\n+      -- Initialize_Tag --\n+      --------------------\n+\n+      procedure Initialize_Tag\n+        (Typ       : Entity_Id;\n+         Iface     : Entity_Id;\n+         Tag_Comp  : in out Entity_Id;\n+         Iface_Tag : Node_Id)\n+      is\n+         Prev_E : Entity_Id;\n+\n+      begin\n+         --  If we are compiling under the CPP full ABI compatibility mode and\n+         --  the ancestor is a CPP_Pragma tagged type then we generate code to\n+         --  inherit the contents of the dispatch table directly from the\n+         --  ancestor.\n+\n+         if Is_CPP_Class (Etype (Typ)) then\n+            Append_To (Stmts_List,\n+              Build_Inherit_Prims (Loc,\n+                Old_Tag_Node =>\n+                  Make_Selected_Component (Loc,\n+                    Prefix        => New_Copy_Tree (Target),\n+                    Selector_Name => New_Reference_To (Tag_Comp, Loc)),\n+                New_Tag_Node =>\n+                  New_Reference_To (Iface_Tag, Loc),\n+                Num_Prims =>\n+                  UI_To_Int\n+                    (DT_Entry_Count (First_Tag_Component (Iface)))));\n+         end if;\n+\n+         --  Initialize the pointer to the secondary DT associated with the\n+         --  interface.\n+\n+         Append_To (Stmts_List,\n+           Make_Assignment_Statement (Loc,\n+             Name =>\n+               Make_Selected_Component (Loc,\n+                 Prefix => New_Copy_Tree (Target),\n+                 Selector_Name => New_Reference_To (Tag_Comp, Loc)),\n+             Expression =>\n+               New_Reference_To (Iface_Tag, Loc)));\n+\n+         --  If the ancestor is CPP_Class, nothing else to do here\n+\n+         if Is_CPP_Class (Etype (Typ)) then\n+            null;\n+\n+         --  Otherwise, comment required ???\n+\n+         else\n+            --  Issue error if Set_Offset_To_Top is not available in a\n+            --  configurable run-time environment.\n+\n+            if not RTE_Available (RE_Set_Offset_To_Top) then\n+               Error_Msg_CRT (\"abstract interface types\", Typ);\n+               return;\n+            end if;\n+\n+            --  We generate a different call when the parent of the type has\n+            --  discriminants.\n+\n+            if Typ /= Etype (Typ)\n+              and then Has_Discriminants (Etype (Typ))\n+            then\n+               pragma Assert\n+                 (Present (DT_Offset_To_Top_Func (Tag_Comp)));\n+\n+               --  Generate:\n+               --    Set_Offset_To_Top\n+               --      (This         => Init,\n+               --       Interface_T  => Iface'Tag,\n+               --       Is_Constant  => False,\n+               --       Offset_Value => n,\n+               --       Offset_Func  => Fn'Address)\n+\n+               Append_To (Stmts_List,\n+                 Make_Procedure_Call_Statement (Loc,\n+                   Name => New_Reference_To\n+                             (RTE (RE_Set_Offset_To_Top), Loc),\n+                   Parameter_Associations => New_List (\n+                     Make_Attribute_Reference (Loc,\n+                       Prefix => New_Copy_Tree (Target),\n+                       Attribute_Name => Name_Address),\n+\n+                     Unchecked_Convert_To (RTE (RE_Tag),\n+                       New_Reference_To\n+                         (Node (First_Elmt (Access_Disp_Table (Iface))),\n+                          Loc)),\n+\n+                     New_Occurrence_Of (Standard_False, Loc),\n+\n+                     Unchecked_Convert_To\n+                       (RTE (RE_Storage_Offset),\n+                        Make_Attribute_Reference (Loc,\n+                          Prefix         =>\n+                            Make_Selected_Component (Loc,\n+                              Prefix => New_Copy_Tree (Target),\n+                              Selector_Name =>\n+                                New_Reference_To (Tag_Comp, Loc)),\n+                          Attribute_Name => Name_Position)),\n+\n+                     Unchecked_Convert_To (RTE (RE_Address),\n+                       Make_Attribute_Reference (Loc,\n+                         Prefix => New_Reference_To\n+                                     (DT_Offset_To_Top_Func (Tag_Comp), Loc),\n+                         Attribute_Name => Name_Address)))));\n+\n+               --  In this case the next component stores the value of the\n+               --  offset to the top.\n+\n+               Prev_E := Tag_Comp;\n+               Next_Entity (Tag_Comp);\n+               pragma Assert (Present (Tag_Comp));\n+\n+               Append_To (Stmts_List,\n+                 Make_Assignment_Statement (Loc,\n+                   Name =>\n+                     Make_Selected_Component (Loc,\n+                       Prefix => New_Copy_Tree (Target),\n+                       Selector_Name => New_Reference_To (Tag_Comp, Loc)),\n+                   Expression =>\n+                     Make_Attribute_Reference (Loc,\n+                       Prefix         =>\n+                         Make_Selected_Component (Loc,\n+                           Prefix => New_Copy_Tree (Target),\n+                           Selector_Name =>\n+                             New_Reference_To (Prev_E, Loc)),\n+                     Attribute_Name => Name_Position)));\n+\n+            --  Normal case: No discriminants in the parent type\n+\n+            else\n+               --  Generate:\n+               --    Set_Offset_To_Top\n+               --      (This         => Init,\n+               --       Interface_T  => Iface'Tag,\n+               --       Is_Constant  => True,\n+               --       Offset_Value => n,\n+               --       Offset_Func  => null);\n+\n+               Append_To (Stmts_List,\n+                 Make_Procedure_Call_Statement (Loc,\n+                   Name => New_Reference_To\n+                             (RTE (RE_Set_Offset_To_Top), Loc),\n+                   Parameter_Associations => New_List (\n+                     Make_Attribute_Reference (Loc,\n+                       Prefix => New_Copy_Tree (Target),\n+                       Attribute_Name => Name_Address),\n+\n+                     Unchecked_Convert_To (RTE (RE_Tag),\n+                       New_Reference_To\n+                         (Node (First_Elmt\n+                                (Access_Disp_Table (Iface))),\n+                          Loc)),\n+\n+                     New_Occurrence_Of (Standard_True, Loc),\n+\n+                     Unchecked_Convert_To\n+                       (RTE (RE_Storage_Offset),\n+                        Make_Attribute_Reference (Loc,\n+                          Prefix =>\n+                            Make_Selected_Component (Loc,\n+                              Prefix => New_Copy_Tree (Target),\n+                              Selector_Name  =>\n+                                New_Reference_To (Tag_Comp, Loc)),\n+                         Attribute_Name => Name_Position)),\n+\n+                     New_Reference_To\n+                       (RTE (RE_Null_Address), Loc))));\n+            end if;\n+         end if;\n+      end Initialize_Tag;\n+\n       ----------------------------------\n       -- Init_Secondary_Tags_Internal --\n       ----------------------------------\n \n       procedure Init_Secondary_Tags_Internal (Typ : Entity_Id) is\n-         Args   : List_Id;\n-         Aux_N  : Node_Id;\n-         E      : Entity_Id;\n-         Iface  : Entity_Id;\n-         New_N  : Node_Id;\n-         Prev_E : Entity_Id;\n+         AI_Elmt : Elmt_Id;\n \n       begin\n-         --  Climb to the ancestor (if any) handling private types\n+         --  Climb to the ancestor (if any) handling synchronized interface\n+         --  derivations and private types\n \n-         if Present (Full_View (Etype (Typ))) then\n+         if Is_Concurrent_Record_Type (Typ) then\n+            declare\n+               Iface_List : constant List_Id := Abstract_Interface_List (Typ);\n+\n+            begin\n+               if Is_Non_Empty_List (Iface_List) then\n+                  Init_Secondary_Tags_Internal (Etype (First (Iface_List)));\n+               end if;\n+            end;\n+\n+         elsif Present (Full_View (Etype (Typ))) then\n             if Full_View (Etype (Typ)) /= Typ then\n                Init_Secondary_Tags_Internal (Full_View (Etype (Typ)));\n             end if;\n@@ -5916,220 +6336,36 @@ package body Exp_Ch3 is\n                   Make_Attribute_Reference (Loc,\n                     Prefix => New_Copy_Tree (Target),\n                     Attribute_Name => Name_Address),\n-\n                   Unchecked_Convert_To (RTE (RE_Tag),\n                     New_Reference_To\n                       (Node (First_Elmt (Access_Disp_Table (Typ))),\n                        Loc)),\n-\n                   New_Occurrence_Of (Standard_True, Loc),\n-\n                   Make_Integer_Literal (Loc, Uint_0),\n-\n                   New_Reference_To (RTE (RE_Null_Address), Loc))));\n          end if;\n \n          if Present (Abstract_Interfaces (Typ))\n            and then not Is_Empty_Elmt_List (Abstract_Interfaces (Typ))\n          then\n-            E := First_Entity (Typ);\n-            while Present (E) loop\n-               if Is_Tag (E)\n-                 and then Chars (E) /= Name_uTag\n-               then\n-                  Aux_N := Node (ADT);\n-                  pragma Assert (Present (Aux_N));\n-\n-                  Iface := Find_Interface (Typ, E);\n-\n-                  --  If we are compiling under the CPP full ABI compatibility\n-                  --  mode and the ancestor is a CPP_Pragma tagged type then\n-                  --  we generate code to inherit the contents of the dispatch\n-                  --  table directly from the ancestor.\n-\n-                  if Is_CPP_Class (Etype (Typ))\n-                    and then not Debug_Flag_QQ\n-                  then\n-                     Args := New_List (\n-                       Node1 =>\n-                         Unchecked_Convert_To (RTE (RE_Tag),\n-                           Make_Selected_Component (Loc,\n-                             Prefix        => New_Copy_Tree (Target),\n-                             Selector_Name => New_Reference_To (E, Loc))),\n-                       Node2 =>\n-                         Unchecked_Convert_To (RTE (RE_Tag),\n-                           New_Reference_To (Aux_N, Loc)),\n-\n-                       Node3 =>\n-                         Make_Integer_Literal (Loc,\n-                           DT_Entry_Count (First_Tag_Component (Iface))));\n-\n-                     --  Issue error if Inherit_CPP_DT is not available\n-                     --  in a configurable run-time environment.\n-\n-                     if not RTE_Available (RE_Inherit_CPP_DT) then\n-                        Error_Msg_CRT (\"cpp interfacing\", Typ);\n-                        return;\n-                     end if;\n-\n-                     New_N :=\n-                       Make_Procedure_Call_Statement (Loc,\n-                         Name => New_Reference_To (RTE (RE_Inherit_CPP_DT),\n-                                                   Loc),\n-                         Parameter_Associations => Args);\n-\n-                     Append_To (Stmts_List, New_N);\n-                  end if;\n-\n-                  --  Initialize the pointer to the secondary DT associated\n-                  --  with the interface\n-\n-                  Append_To (Stmts_List,\n-                    Make_Assignment_Statement (Loc,\n-                      Name =>\n-                        Make_Selected_Component (Loc,\n-                          Prefix => New_Copy_Tree (Target),\n-                          Selector_Name => New_Reference_To (E, Loc)),\n-                      Expression =>\n-                        New_Reference_To (Aux_N, Loc)));\n-\n-                  --  If the ancestor is CPP_Class, nothing else to do here\n-\n-                  if Is_CPP_Class (Etype (Typ)) and then not Debug_Flag_QQ then\n-                     null;\n-\n-                  --  Otherwise, comment required ???\n-\n-                  else\n-                     --  Issue error if Set_Offset_To_Top is not available in a\n-                     --  configurable run-time environment.\n-\n-                     if not RTE_Available (RE_Set_Offset_To_Top) then\n-                        Error_Msg_CRT (\"abstract interface types\", Typ);\n-                        return;\n-                     end if;\n-\n-                     --  We generate a different call when the parent of the\n-                     --  type has discriminants.\n-\n-                     if Typ /= Etype (Typ)\n-                       and then Has_Discriminants (Etype (Typ))\n-                     then\n-                        pragma Assert\n-                          (Present (DT_Offset_To_Top_Func (E)));\n-\n-                        --  Generate:\n-                        --    Set_Offset_To_Top\n-                        --      (This         => Init,\n-                        --       Interface_T  => Iface'Tag,\n-                        --       Is_Constant  => False,\n-                        --       Offset_Value => n,\n-                        --       Offset_Func  => Fn'Address)\n-\n-                        Append_To (Stmts_List,\n-                          Make_Procedure_Call_Statement (Loc,\n-                            Name => New_Reference_To\n-                                      (RTE (RE_Set_Offset_To_Top), Loc),\n-                            Parameter_Associations => New_List (\n-                              Make_Attribute_Reference (Loc,\n-                                Prefix => New_Copy_Tree (Target),\n-                                Attribute_Name => Name_Address),\n-\n-                              Unchecked_Convert_To (RTE (RE_Tag),\n-                                New_Reference_To\n-                                  (Node (First_Elmt\n-                                         (Access_Disp_Table (Iface))),\n-                                   Loc)),\n-\n-                              New_Occurrence_Of (Standard_False, Loc),\n-\n-                              Unchecked_Convert_To\n-                                (RTE (RE_Storage_Offset),\n-                                 Make_Attribute_Reference (Loc,\n-                                   Prefix         =>\n-                                     Make_Selected_Component (Loc,\n-                                       Prefix => New_Copy_Tree (Target),\n-                                       Selector_Name =>\n-                                         New_Reference_To (E, Loc)),\n-                                   Attribute_Name => Name_Position)),\n-\n-                              Unchecked_Convert_To (RTE (RE_Address),\n-                                Make_Attribute_Reference (Loc,\n-                                  Prefix => New_Reference_To\n-                                              (DT_Offset_To_Top_Func (E),\n-                                               Loc),\n-                                  Attribute_Name =>\n-                                    Name_Address)))));\n-\n-                        --  In this case the next component stores the\n-                        --  value of the offset to the top.\n-\n-                        Prev_E := E;\n-                        Next_Entity (E);\n-                        pragma Assert (Present (E));\n-\n-                        Append_To (Stmts_List,\n-                          Make_Assignment_Statement (Loc,\n-                            Name =>\n-                              Make_Selected_Component (Loc,\n-                                Prefix => New_Copy_Tree (Target),\n-                                Selector_Name => New_Reference_To (E, Loc)),\n-                            Expression =>\n-                              Make_Attribute_Reference (Loc,\n-                                Prefix         =>\n-                                  Make_Selected_Component (Loc,\n-                                    Prefix => New_Copy_Tree (Target),\n-                                    Selector_Name =>\n-                                      New_Reference_To (Prev_E, Loc)),\n-                              Attribute_Name => Name_Position)));\n-\n-                     --  Normal case: No discriminants in the parent type\n-\n-                     else\n-                        --  Generate:\n-                        --    Set_Offset_To_Top\n-                        --      (This         => Init,\n-                        --       Interface_T  => Iface'Tag,\n-                        --       Is_Constant  => True,\n-                        --       Offset_Value => n,\n-                        --       Offset_Func  => null);\n-\n-                        Append_To (Stmts_List,\n-                          Make_Procedure_Call_Statement (Loc,\n-                            Name => New_Reference_To\n-                                      (RTE (RE_Set_Offset_To_Top), Loc),\n-                            Parameter_Associations => New_List (\n-                              Make_Attribute_Reference (Loc,\n-                                Prefix => New_Copy_Tree (Target),\n-                                Attribute_Name => Name_Address),\n-\n-                              Unchecked_Convert_To (RTE (RE_Tag),\n-                                New_Reference_To\n-                                  (Node (First_Elmt\n-                                         (Access_Disp_Table (Iface))),\n-                                   Loc)),\n-\n-                              New_Occurrence_Of (Standard_True, Loc),\n+            if not Is_Synch_Typ then\n+               AI_Tag_Comp := Next_Tag_Component (First_Tag_Component (Typ));\n+               pragma Assert (Present (AI_Tag_Comp));\n+            end if;\n \n-                              Unchecked_Convert_To\n-                                (RTE (RE_Storage_Offset),\n-                                 Make_Attribute_Reference (Loc,\n-                                   Prefix =>\n-                                    Make_Selected_Component (Loc,\n-                                      Prefix => New_Copy_Tree (Target),\n-                                      Selector_Name  =>\n-                                        New_Reference_To (E, Loc)),\n-                                  Attribute_Name => Name_Position)),\n+            AI_Elmt := First_Elmt (Abstract_Interfaces (Typ));\n+            while Present (AI_Elmt) loop\n+               pragma Assert (Present (Node (ADT)));\n \n-                              New_Reference_To\n-                                (RTE (RE_Null_Address), Loc))));\n-                     end if;\n-                  end if;\n+               Initialize_Tag\n+                 (Typ       => Typ,\n+                  Iface     => Node (AI_Elmt),\n+                  Tag_Comp  => AI_Tag_Comp,\n+                  Iface_Tag => Node (ADT));\n \n-                  Next_Elmt (ADT);\n-               end if;\n-\n-               Next_Entity (E);\n+               Next_Elmt (ADT);\n+               AI_Tag_Comp := Next_Tag_Component (AI_Tag_Comp);\n+               Next_Elmt (AI_Elmt);\n             end loop;\n          end if;\n       end Init_Secondary_Tags_Internal;\n@@ -6150,6 +6386,11 @@ package body Exp_Ch3 is\n          Full_Typ := Typ;\n       end if;\n \n+      if Is_Concurrent_Record_Type (Typ) then\n+         Is_Synch_Typ := True;\n+         AI_Tag_Comp  := Next_Tag_Component (First_Tag_Component (Typ));\n+      end if;\n+\n       Init_Secondary_Tags_Internal (Full_Typ);\n    end Init_Secondary_Tags;\n \n@@ -6195,9 +6436,9 @@ package body Exp_Ch3 is\n          --  is needed to distinguish inherited operations from renamings\n          --  (which also have Alias set).\n \n-         if Is_Abstract (Subp)\n+         if Is_Abstract_Subprogram (Subp)\n            and then Present (Alias (Subp))\n-           and then not Is_Abstract (Alias (Subp))\n+           and then not Is_Abstract_Subprogram (Alias (Subp))\n            and then not Comes_From_Source (Subp)\n            and then Ekind (Subp) = E_Function\n            and then Has_Controlling_Result (Subp)\n@@ -6668,7 +6909,7 @@ package body Exp_Ch3 is\n \n             elsif Chars (Node (Prim)) = Name_Op_Eq\n               and then Present (Alias (Node (Prim)))\n-              and then Is_Abstract (Alias (Node (Prim)))\n+              and then Is_Abstract_Subprogram (Alias (Node (Prim)))\n             then\n                Eq_Needed := False;\n                exit;\n@@ -6767,12 +7008,8 @@ package body Exp_Ch3 is\n       if Ada_Version >= Ada_05\n         and then\n           ((Is_Interface (Tag_Typ) and then Is_Limited_Record (Tag_Typ))\n-              or else\n-                (Is_Concurrent_Record_Type (Tag_Typ)\n-                   and then Implements_Interface (\n-                              Typ          => Tag_Typ,\n-                              Kind         => Any_Limited_Interface,\n-                              Check_Parent => True)))\n+              or else (Is_Concurrent_Record_Type (Tag_Typ)\n+                        and then Has_Abstract_Interfaces (Tag_Typ)))\n       then\n          Append_To (Res,\n            Make_Subprogram_Declaration (Loc,\n@@ -7002,7 +7239,7 @@ package body Exp_Ch3 is\n       elsif (Is_TSS (Name, TSS_Stream_Input)\n               or else\n              Is_TSS (Name, TSS_Stream_Output))\n-        and then Is_Abstract (Tag_Typ)\n+        and then Is_Abstract_Type (Tag_Typ)\n       then\n          return Make_Abstract_Subprogram_Declaration (Loc, Spec);\n \n@@ -7147,7 +7384,7 @@ package body Exp_Ch3 is\n       --  Skip bodies of _Input and _Output for the abstract case, since\n       --  the corresponding specs are abstract (see Predef_Spec_Or_Body)\n \n-      if not Is_Abstract (Tag_Typ) then\n+      if not Is_Abstract_Type (Tag_Typ) then\n          if Stream_Operation_OK (Tag_Typ, TSS_Stream_Input)\n            and then No (TSS (Tag_Typ, TSS_Stream_Input))\n          then\n@@ -7181,12 +7418,8 @@ package body Exp_Ch3 is\n           not Restriction_Active (No_Dispatching_Calls)\n         and then\n           ((Is_Interface (Tag_Typ) and then Is_Limited_Record (Tag_Typ))\n-              or else\n-                (Is_Concurrent_Record_Type (Tag_Typ)\n-                   and then Implements_Interface (\n-                              Typ          => Tag_Typ,\n-                              Kind         => Any_Limited_Interface,\n-                              Check_Parent => True)))\n+              or else (Is_Concurrent_Record_Type (Tag_Typ)\n+                        and then Has_Abstract_Interfaces (Tag_Typ)))\n       then\n          Append_To (Res, Make_Disp_Asynchronous_Select_Body (Tag_Typ));\n          Append_To (Res, Make_Disp_Conditional_Select_Body  (Tag_Typ));\n@@ -7415,9 +7648,13 @@ package body Exp_Ch3 is\n         not (Is_Limited_Type (Typ)\n                and then not Has_Inheritable_Stream_Attribute)\n           and then not Has_Unknown_Discriminants (Typ)\n-          and then RTE_Available (RE_Tag)\n-          and then RTE_Available (RE_Root_Stream_Type)\n+          and then not (Is_Interface (Typ)\n+                         and then (Is_Task_Interface (Typ)\n+                                   or else Is_Protected_Interface (Typ)\n+                                   or else Is_Synchronized_Interface (Typ)))\n+          and then not Restriction_Active (No_Streams)\n           and then not Restriction_Active (No_Dispatch)\n-          and then not Restriction_Active (No_Streams);\n+          and then RTE_Available (RE_Tag)\n+          and then RTE_Available (RE_Root_Stream_Type);\n    end Stream_Operation_OK;\n end Exp_Ch3;"}, {"sha": "20136be6ed19fe13065647d56c4b494bbe7e7090", "filename": "gcc/ada/exp_ch3.ads", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea1941af7fd5244b8d6875fcc1dad0a597180cd1/gcc%2Fada%2Fexp_ch3.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea1941af7fd5244b8d6875fcc1dad0a597180cd1/gcc%2Fada%2Fexp_ch3.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.ads?ref=ea1941af7fd5244b8d6875fcc1dad0a597180cd1", "patch": "@@ -69,17 +69,16 @@ package Exp_Ch3 is\n       Enclos_Type       : Entity_Id := Empty;\n       Discr_Map         : Elist_Id := New_Elmt_List;\n       With_Default_Init : Boolean := False) return List_Id;\n-   --  Builds a call to the initialization procedure of the Id entity. Id_Ref\n-   --  is either a new reference to Id (for record fields), or an indexed\n-   --  component (for array elements). Loc is the source location for the\n-   --  constructed tree, and Typ is the type of the entity (the initialization\n-   --  procedure of the base type is the procedure that actually gets called).\n-   --  In_Init_Proc has to be set to True when the call is itself in an init\n-   --  proc in order to enable the use of discriminals. Enclos_type is the type\n-   --  of the init proc and it is used for various expansion cases including\n-   --  the case where Typ is a task type which is a array component, the\n-   --  indices of the enclosing type are used to build the string that\n-   --  identifies each task at runtime.\n+   --  Builds a call to the initialization procedure for the base type of Typ,\n+   --  passing it the object denoted by Id_Ref, plus additional parameters as\n+   --  appropriate for the type (the _Master, for task types, for example).\n+   --  Loc is the source location for the constructed tree. In_Init_Proc has\n+   --  to be set to True when the call is itself in an init proc in order to\n+   --  enable the use of discriminals. Enclos_Type is the enclosing type when\n+   --  initializing a component in an outer init proc, and it is used for\n+   --  various expansion cases including the case where Typ is a task type\n+   --  which is an array component, the indices of the enclosing type are\n+   --  used to build the string that identifies each task at runtime.\n    --\n    --  Discr_Map is used to replace discriminants by their discriminals in\n    --  expressions used to constrain record components. In the presence of"}]}