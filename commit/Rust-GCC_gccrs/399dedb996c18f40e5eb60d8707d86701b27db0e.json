{"sha": "399dedb996c18f40e5eb60d8707d86701b27db0e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mzk5ZGVkYjk5NmMxOGY0MGU1ZWI2MGQ4NzA3ZDg2NzAxYjI3ZGIwZQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2003-07-29T11:16:50Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2003-07-29T11:16:50Z"}, "message": "re PR c++/9447 (using Base<T>::member does not work)\n\ncp:\n\tPR c++/9447\n\t* decl.c (add_binding): Add bval local variable.\n\t(push_class_level_binding): Likewise. Allow a USING_DECL to be\n\tpushed.\n\t* decl2.c (do_class_using_decl):  The type of a using decl is\n\tunknown.\n\t* parser.c (cp_parser_postfix_expression): Refactor unqualified-id\n\tfunction call lookup code.\n\t* pt.c (tsubst): A USING_DECL will have unknown type.\n\t(tsubst_copy_and_build): Allow a using decl.\n\t(type_dependent_expression_p): A USING_DECL will make it\n\tdependent.\n\t* semantics.c (finish_member_declaration): Push a dependent using\n\tdeclaration.\ntestsuite:\n\tPR c++/9447\n\t* g++.dg/template/using1.C: New test.\n\t* g++.dg/template/using2.C: New test.\n\t* g++.dg/template/using3.C: New test.\n\t* g++.dg/template/using4.C: New test.\n\nFrom-SVN: r69921", "tree": {"sha": "f933bf28ffc6e8514814d1f5e3aab7549afff83b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f933bf28ffc6e8514814d1f5e3aab7549afff83b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/399dedb996c18f40e5eb60d8707d86701b27db0e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/399dedb996c18f40e5eb60d8707d86701b27db0e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/399dedb996c18f40e5eb60d8707d86701b27db0e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/399dedb996c18f40e5eb60d8707d86701b27db0e/comments", "author": null, "committer": null, "parents": [{"sha": "16ff3a23ffdeb49c8b0b8672bbd26bdcd06681e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16ff3a23ffdeb49c8b0b8672bbd26bdcd06681e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16ff3a23ffdeb49c8b0b8672bbd26bdcd06681e4"}], "stats": {"total": 326, "additions": 259, "deletions": 67}, "files": [{"sha": "12d843583f1fd824cefd1100ebc1caa36a55438c", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/399dedb996c18f40e5eb60d8707d86701b27db0e/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/399dedb996c18f40e5eb60d8707d86701b27db0e/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=399dedb996c18f40e5eb60d8707d86701b27db0e", "patch": "@@ -1,3 +1,20 @@\n+2003-07-29  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\tPR c++/9447\n+\t* decl.c (add_binding): Add bval local variable.\n+\t(push_class_level_binding): Likewise. Allow a USING_DECL to be\n+\tpushed.\n+\t* decl2.c (do_class_using_decl):  The type of a using decl is\n+\tunknown.\n+\t* parser.c (cp_parser_postfix_expression): Refactor unqualified-id\n+\tfunction call lookup code.\n+\t* pt.c (tsubst): A USING_DECL will have unknown type.\n+\t(tsubst_copy_and_build): Allow a using decl.\n+\t(type_dependent_expression_p): A USING_DECL will make it\n+\tdependent.\n+\t* semantics.c (finish_member_declaration): Push a dependent using\n+\tdeclaration.\n+\n 2003-07-28  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/11530"}, {"sha": "637ad1f36d5fcb7a11b2dfce3789cdfce9a4f1fc", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 55, "deletions": 51, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/399dedb996c18f40e5eb60d8707d86701b27db0e/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/399dedb996c18f40e5eb60d8707d86701b27db0e/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=399dedb996c18f40e5eb60d8707d86701b27db0e", "patch": "@@ -922,38 +922,37 @@ static int\n add_binding (tree id, tree decl)\n {\n   cxx_binding *binding = IDENTIFIER_BINDING (id);\n+  tree bval = BINDING_VALUE (binding);\n   int ok = 1;\n \n   timevar_push (TV_NAME_LOOKUP);\n   if (TREE_CODE (decl) == TYPE_DECL && DECL_ARTIFICIAL (decl))\n     /* The new name is the type name.  */\n     BINDING_TYPE (binding) = decl;\n-  else if (!BINDING_VALUE (binding))\n+  else if (!bval)\n     /* This situation arises when push_class_level_binding moves an\n        inherited type-binding out of the way to make room for a new\n        value binding.  */\n     BINDING_VALUE (binding) = decl;\n-  else if (TREE_CODE (BINDING_VALUE (binding)) == TYPE_DECL\n-\t   && DECL_ARTIFICIAL (BINDING_VALUE (binding)))\n+  else if (TREE_CODE (bval) == TYPE_DECL && DECL_ARTIFICIAL (bval))\n     {\n       /* The old binding was a type name.  It was placed in\n \t BINDING_VALUE because it was thought, at the point it was\n \t declared, to be the only entity with such a name.  Move the\n \t type name into the type slot; it is now hidden by the new\n \t binding.  */\n-      BINDING_TYPE (binding) = BINDING_VALUE (binding);\n+      BINDING_TYPE (binding) = bval;\n       BINDING_VALUE (binding) = decl;\n       INHERITED_VALUE_BINDING_P (binding) = 0;\n     }\n-  else if (TREE_CODE (BINDING_VALUE (binding)) == TYPE_DECL\n+  else if (TREE_CODE (bval) == TYPE_DECL\n \t   && TREE_CODE (decl) == TYPE_DECL\n-\t   && DECL_NAME (decl) == DECL_NAME (BINDING_VALUE (binding))\n-\t   && (same_type_p (TREE_TYPE (decl),\n-\t\t\t    TREE_TYPE (BINDING_VALUE (binding)))\n+\t   && DECL_NAME (decl) == DECL_NAME (bval)\n+\t   && (same_type_p (TREE_TYPE (decl), TREE_TYPE (bval))\n \t       /* If either type involves template parameters, we must\n \t\t  wait until instantiation.  */\n \t       || uses_template_parms (TREE_TYPE (decl))\n-\t       || uses_template_parms (TREE_TYPE (BINDING_VALUE (binding)))))\n+\t       || uses_template_parms (TREE_TYPE (bval))))\n     /* We have two typedef-names, both naming the same type to have\n        the same name.  This is OK because of:\n \n@@ -971,10 +970,8 @@ add_binding (tree id, tree decl)\n \n        A member shall not be declared twice in the\n        member-specification.  */\n-  else if (TREE_CODE (decl) == VAR_DECL\n-\t   && TREE_CODE (BINDING_VALUE (binding)) == VAR_DECL\n-\t   && DECL_EXTERNAL (decl)\n-\t   && DECL_EXTERNAL (BINDING_VALUE (binding))\n+  else if (TREE_CODE (decl) == VAR_DECL && TREE_CODE (bval) == VAR_DECL\n+\t   && DECL_EXTERNAL (decl) && DECL_EXTERNAL (bval)\n \t   && !DECL_CLASS_SCOPE_P (decl))\n     {\n       duplicate_decls (decl, BINDING_VALUE (binding));\n@@ -4273,47 +4270,54 @@ push_class_level_binding (tree name, tree x)\n      class, then we will need to restore IDENTIFIER_CLASS_VALUE when\n      we leave this class.  Record the shadowed declaration here.  */\n   binding = IDENTIFIER_BINDING (name);\n-  if (binding\n-      && ((TREE_CODE (x) == OVERLOAD\n-\t   && BINDING_VALUE (binding)\n-\t   && is_overloaded_fn (BINDING_VALUE (binding)))\n-\t  || INHERITED_VALUE_BINDING_P (binding)))\n+  if (binding && BINDING_VALUE (binding))\n     {\n-      tree shadow;\n-      tree old_decl;\n+      tree bval = BINDING_VALUE (binding);\n+      tree old_decl = NULL_TREE;\n \n-      /* If the old binding was from a base class, and was for a tag\n-\t name, slide it over to make room for the new binding.  The\n-\t old binding is still visible if explicitly qualified with a\n-\t class-key.  */\n-      if (INHERITED_VALUE_BINDING_P (binding)\n-\t  && BINDING_VALUE (binding)\n-\t  && TREE_CODE (BINDING_VALUE (binding)) == TYPE_DECL\n-\t  && DECL_ARTIFICIAL (BINDING_VALUE (binding))\n-\t  && !(TREE_CODE (x) == TYPE_DECL && DECL_ARTIFICIAL (x)))\n-\t{\n-\t  old_decl = BINDING_TYPE (binding);\n-\t  BINDING_TYPE (binding) = BINDING_VALUE (binding);\n-\t  BINDING_VALUE (binding) = NULL_TREE;\n-\t  INHERITED_VALUE_BINDING_P (binding) = 0;\n+      if (INHERITED_VALUE_BINDING_P (binding))\n+\t{\n+\t  /* If the old binding was from a base class, and was for a\n+  \t     tag name, slide it over to make room for the new binding.\n+  \t     The old binding is still visible if explicitly qualified\n+  \t     with a class-key.  */\n+\t  if (TREE_CODE (bval) == TYPE_DECL && DECL_ARTIFICIAL (bval)\n+\t      && !(TREE_CODE (x) == TYPE_DECL && DECL_ARTIFICIAL (x)))\n+\t    {\n+\t      BINDING_TYPE (binding) = bval;\n+\t      BINDING_VALUE (binding) = NULL_TREE;\n+\t      INHERITED_VALUE_BINDING_P (binding) = 0;\n+\t    }\n+\t  old_decl = bval;\n+\t}\n+      else if (TREE_CODE (x) == OVERLOAD && is_overloaded_fn (bval))\n+\told_decl = bval;\n+      else if (TREE_CODE (x) == USING_DECL && TREE_CODE (bval) == USING_DECL)\n+\tPOP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, true);\n+      else if (TREE_CODE (x) == USING_DECL && is_overloaded_fn (bval))\n+\told_decl = bval;\n+      else if (TREE_CODE (bval) == USING_DECL && is_overloaded_fn (x))\n+\tPOP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, true);\n+      \n+      if (old_decl)\n+\t{\n+\t  tree shadow;\n+\t  \n+\t  /* Find the previous binding of name on the class-shadowed\n+             list, and update it.  */\n+\t  for (shadow = class_binding_level->class_shadowed;\n+\t       shadow;\n+\t       shadow = TREE_CHAIN (shadow))\n+\t    if (TREE_PURPOSE (shadow) == name\n+\t\t&& TREE_TYPE (shadow) == old_decl)\n+\t      {\n+\t\tBINDING_VALUE (binding) = x;\n+\t\tINHERITED_VALUE_BINDING_P (binding) = 0;\n+\t\tTREE_TYPE (shadow) = x;\n+\t\tIDENTIFIER_CLASS_VALUE (name) = x;\n+\t\tPOP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, true);\n+\t      }\n \t}\n-      else\n-\told_decl = BINDING_VALUE (binding);\n-\n-      /* Find the previous binding of name on the class-shadowed\n-         list, and update it.  */\n-      for (shadow = class_binding_level->class_shadowed;\n-\t   shadow;\n-\t   shadow = TREE_CHAIN (shadow))\n-\tif (TREE_PURPOSE (shadow) == name\n-\t    && TREE_TYPE (shadow) == old_decl)\n-\t  {\n-\t    BINDING_VALUE (binding) = x;\n-\t    INHERITED_VALUE_BINDING_P (binding) = 0;\n-\t    TREE_TYPE (shadow) = x;\n-\t    IDENTIFIER_CLASS_VALUE (name) = x;\n-\t    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, true);\n-\t  }\n     }\n \n   /* If we didn't replace an existing binding, put the binding on the"}, {"sha": "896282c770d2bbb92bb58514abebe33245b77123", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/399dedb996c18f40e5eb60d8707d86701b27db0e/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/399dedb996c18f40e5eb60d8707d86701b27db0e/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=399dedb996c18f40e5eb60d8707d86701b27db0e", "patch": "@@ -4126,7 +4126,7 @@ do_class_using_decl (tree decl)\n \n   my_friendly_assert (TREE_CODE (name) == IDENTIFIER_NODE, 980716);\n \n-  value = build_lang_decl (USING_DECL, name, void_type_node);\n+  value = build_lang_decl (USING_DECL, name, unknown_type_node);\n   DECL_INITIAL (value) = TREE_OPERAND (decl, 0);\n   return value;\n }"}, {"sha": "3aa684b3d2c56a604912a193f9b3090347f1a42c", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/399dedb996c18f40e5eb60d8707d86701b27db0e/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/399dedb996c18f40e5eb60d8707d86701b27db0e/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=399dedb996c18f40e5eb60d8707d86701b27db0e", "patch": "@@ -3483,18 +3483,19 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p)\n \t\tparser->non_constant_expression_p = true;\n \t      }\n \n-\t    if (idk == CP_ID_KIND_UNQUALIFIED\n-\t\t&& (is_overloaded_fn (postfix_expression)\n-\t\t    || DECL_P (postfix_expression)\n-\t\t    || TREE_CODE (postfix_expression) == IDENTIFIER_NODE)\n-\t\t&& args)\n-\t      postfix_expression \n-\t\t= perform_koenig_lookup (postfix_expression, args);\n-\t    else if (idk == CP_ID_KIND_UNQUALIFIED \n-\t\t     && TREE_CODE (postfix_expression) == IDENTIFIER_NODE)\n-\t      postfix_expression\n-\t\t= unqualified_fn_lookup_error (postfix_expression);\n-\n+\t    if (idk == CP_ID_KIND_UNQUALIFIED)\n+\t      {\n+\t\tif (args\n+\t\t    && (is_overloaded_fn (postfix_expression)\n+\t\t\t|| DECL_P (postfix_expression)\n+\t\t\t|| TREE_CODE (postfix_expression) == IDENTIFIER_NODE))\n+\t\t  postfix_expression \n+\t\t    = perform_koenig_lookup (postfix_expression, args);\n+\t\telse if (TREE_CODE (postfix_expression) == IDENTIFIER_NODE)\n+\t\t  postfix_expression\n+\t\t    = unqualified_fn_lookup_error (postfix_expression);\n+\t      }\n+\t  \n \t    if (TREE_CODE (postfix_expression) == COMPONENT_REF)\n \t      {\n \t\ttree instance = TREE_OPERAND (postfix_expression, 0);"}, {"sha": "6966afdc8f5ebde2acbe1c70a87b6141987047e6", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/399dedb996c18f40e5eb60d8707d86701b27db0e/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/399dedb996c18f40e5eb60d8707d86701b27db0e/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=399dedb996c18f40e5eb60d8707d86701b27db0e", "patch": "@@ -6430,14 +6430,16 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n     type = IDENTIFIER_TYPE_VALUE (t);\n   else\n     type = TREE_TYPE (t);\n-  if (type == unknown_type_node)\n-    abort ();\n+\n+  my_friendly_assert (type != unknown_type_node\n+\t\t      || TREE_CODE (t) == USING_DECL, 20030716);\n \n   if (type && TREE_CODE (t) != FUNCTION_DECL\n       && TREE_CODE (t) != TYPENAME_TYPE\n       && TREE_CODE (t) != TEMPLATE_DECL\n       && TREE_CODE (t) != IDENTIFIER_NODE\n       && TREE_CODE (t) != FUNCTION_TYPE\n+      && TREE_CODE (t) != USING_DECL\n       && TREE_CODE (t) != METHOD_TYPE)\n     type = tsubst (type, args, complain, in_decl);\n   if (type == error_mark_node)\n@@ -7907,6 +7909,9 @@ tsubst_copy_and_build (tree t,\n \n   switch (TREE_CODE (t))\n     {\n+    case USING_DECL:\n+      t = DECL_NAME (t);\n+      /* Fallthrough. */\n     case IDENTIFIER_NODE:\n       {\n \ttree decl;\n@@ -11618,6 +11623,8 @@ type_dependent_expression_p (tree expression)\n \n   if (TREE_TYPE (expression) == unknown_type_node)\n     {\n+      if (TREE_CODE (expression) == USING_DECL)\n+\treturn true;\n       if (TREE_CODE (expression) == ADDR_EXPR)\n \treturn type_dependent_expression_p (TREE_OPERAND (expression, 0));\n       if (TREE_CODE (expression) == BASELINK)"}, {"sha": "a94174ad945b433aaddb48af7eecac836fc25f97", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/399dedb996c18f40e5eb60d8707d86701b27db0e/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/399dedb996c18f40e5eb60d8707d86701b27db0e/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=399dedb996c18f40e5eb60d8707d86701b27db0e", "patch": "@@ -2030,7 +2030,9 @@ finish_member_declaration (tree decl)\n \t\t\t\t\t  /*friend_p=*/0);\n     }\n   /* Enter the DECL into the scope of the class.  */\n-  else if (TREE_CODE (decl) == USING_DECL || pushdecl_class_level (decl))\n+  else if ((TREE_CODE (decl) == USING_DECL && !processing_template_decl\n+\t    && !dependent_type_p (DECL_INITIAL (decl)))\n+\t   || pushdecl_class_level (decl))\n     {\n       /* All TYPE_DECLs go at the end of TYPE_FIELDS.  Ordinary fields\n \t go at the beginning.  The reason is that lookup_field_1"}, {"sha": "520d8d0c2a7313e7612b06ca9a42d3eb51a3fea1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/399dedb996c18f40e5eb60d8707d86701b27db0e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/399dedb996c18f40e5eb60d8707d86701b27db0e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=399dedb996c18f40e5eb60d8707d86701b27db0e", "patch": "@@ -1,3 +1,11 @@\n+2003-07-29  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\tPR c++/9447\n+\t* g++.dg/template/using1.C: New test.\n+\t* g++.dg/template/using2.C: New test.\n+\t* g++.dg/template/using3.C: New test.\n+\t* g++.dg/template/using4.C: New test.\n+\n 2003-07-29  Alexandre Oliva  <aoliva@redhat.com>\n \n \t* gcc.c-torture/execute/string-opt-9.c: strcmp returns int."}, {"sha": "e4d4a004e32e4dbdef01fe1b45a656955e6dbbe5", "filename": "gcc/testsuite/g++.dg/template/using1.C", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/399dedb996c18f40e5eb60d8707d86701b27db0e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fusing1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/399dedb996c18f40e5eb60d8707d86701b27db0e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fusing1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fusing1.C?ref=399dedb996c18f40e5eb60d8707d86701b27db0e", "patch": "@@ -0,0 +1,42 @@\n+// { dg-do run }\n+\n+// Copyright (C) 2003 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 22 Jul 2003 <nathan@codesourcery.com>\n+\n+// PR 9447. Using decls in template classes.\n+\n+template <class T>\n+struct Foo {\n+  int i;\n+};\n+\n+struct Baz \n+{\n+  int j;\n+};\n+\n+template <class T>\n+struct Bar : public Foo<T>, Baz {\n+  using Foo<T>::i;\n+  using Baz::j;\n+  \n+  int foo () { return i; }\n+  int baz () { return j; }\n+};\n+\n+int main()\n+{\n+  Bar<int> bar;\n+\n+  bar.i = 1;\n+  bar.j = 2;\n+  \n+  if (bar.foo() != 1)\n+    return 1;\n+  \n+  if (bar.baz() != 2)\n+    return 1;\n+  \n+  return 0;\n+}\n+"}, {"sha": "87cdbc1865712e926e8f1744cf959a4e4b379878", "filename": "gcc/testsuite/g++.dg/template/using2.C", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/399dedb996c18f40e5eb60d8707d86701b27db0e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fusing2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/399dedb996c18f40e5eb60d8707d86701b27db0e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fusing2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fusing2.C?ref=399dedb996c18f40e5eb60d8707d86701b27db0e", "patch": "@@ -0,0 +1,30 @@\n+// { dg-do compile }\n+\n+// Copyright (C) 2003 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 22 Jul 2003 <nathan@codesourcery.com>\n+\n+// PR 9447. Using decls in template classes.\n+\n+template <class T>\n+struct Foo {\n+  int i; // { dg-error \"\" \"\" }\n+};\n+\n+struct Baz \n+{\n+  int i; // { dg-error \"\" \"\" }\n+};\n+\n+template <class T>\n+struct Bar : public Foo<T>, Baz {\n+  using Foo<T>::i;\n+  using Baz::i;\n+\n+  int foo () { return i; } // { dg-error \"request for member\" \"\" }\n+};\n+\n+void foo (Bar<int> &bar)\n+{\n+  bar.foo(); // { dg-error \"instantiated\" \"\" }\n+}\n+"}, {"sha": "11f2899c592b6a39c505a8829fd7dc529002f8bc", "filename": "gcc/testsuite/g++.dg/template/using3.C", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/399dedb996c18f40e5eb60d8707d86701b27db0e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fusing3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/399dedb996c18f40e5eb60d8707d86701b27db0e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fusing3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fusing3.C?ref=399dedb996c18f40e5eb60d8707d86701b27db0e", "patch": "@@ -0,0 +1,42 @@\n+// { dg-do run }\n+\n+// Copyright (C) 2003 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 22 Jul 2003 <nathan@codesourcery.com>\n+\n+// PR 9447. Using decls in template classes.\n+\n+template <class T>\n+struct Foo {\n+  int i (int) {return 1;}\n+};\n+\n+struct Baz \n+{\n+  int k (int) {return 2;}\n+};\n+\n+template <class T>\n+struct Bar : public Foo<T> , Baz {\n+  using Foo<T>::i;\n+  using Baz::k;\n+\n+  int i (float) {return 3;}\n+  int k (float) {return 3;}\n+  \n+  int foo()\n+  {\n+    if (i (1) != 1)\n+      return 1;\n+    if (k (1) != 2)\n+      return 2;\n+\n+    return 0;\n+  }\n+};\n+\n+int main()\n+{\n+  Bar<int> bar;\n+\n+  return bar.foo();\n+}"}, {"sha": "8c46da464a12fd7f72fd91a33b7b8c20478e0eb6", "filename": "gcc/testsuite/g++.dg/template/using4.C", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/399dedb996c18f40e5eb60d8707d86701b27db0e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fusing4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/399dedb996c18f40e5eb60d8707d86701b27db0e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fusing4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fusing4.C?ref=399dedb996c18f40e5eb60d8707d86701b27db0e", "patch": "@@ -0,0 +1,39 @@\n+// { dg-do run }\n+\n+// Copyright (C) 2003 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 22 Jul 2003 <nathan@codesourcery.com>\n+\n+// PR 9447. Using decls in template classes.\n+\n+template <class T>\n+struct Foo {\n+  int k (float) {return 1;}\n+};\n+\n+struct Baz \n+{\n+  int k (int) {return 2;}\n+};\n+\n+template <class T>\n+struct Bar : public Foo<T> , Baz {\n+  using Foo<T>::k;\n+  using Baz::k;\n+\n+  int foo()\n+  {\n+    if (k (1.0f) != 1)\n+      return 1;\n+    if (k (1) != 2)\n+      return 2;\n+\n+    return 0;\n+  }\n+};\n+\n+int main()\n+{\n+  Bar<int> bar;\n+\n+  return bar.foo();\n+}"}]}