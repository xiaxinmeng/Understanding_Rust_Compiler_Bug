{"sha": "e6ff97b1c4f478ca3565810aa4bc81cc3aa114ae", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTZmZjk3YjFjNGY0NzhjYTM1NjU4MTBhYTRiYzgxY2MzYWExMTRhZQ==", "commit": {"author": {"name": "Rodney Brown", "email": "RodneyBrown@mynd.com", "date": "2001-03-12T19:21:29Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2001-03-12T19:21:29Z"}, "message": "gen-num-limits.cc (traps): Add fflush prior to trapping signal (UnixWare 7 workaround).\n\n\n2001-03-12  Rodney Brown  <RodneyBrown@mynd.com>\n\n        * src/gen-num-limits.cc (traps) [SPECIALIZE_TRAPPING]: Add fflush\n        prior to trapping signal (UnixWare 7 workaround).\n\nFrom-SVN: r40422", "tree": {"sha": "91b82b05d40bfbd3d9a483744448efda248e9bfa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/91b82b05d40bfbd3d9a483744448efda248e9bfa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e6ff97b1c4f478ca3565810aa4bc81cc3aa114ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6ff97b1c4f478ca3565810aa4bc81cc3aa114ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e6ff97b1c4f478ca3565810aa4bc81cc3aa114ae", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6ff97b1c4f478ca3565810aa4bc81cc3aa114ae/comments", "author": null, "committer": null, "parents": [{"sha": "23712c118ddef30ff8a132bcb3c0b63e5a85eb05", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23712c118ddef30ff8a132bcb3c0b63e5a85eb05", "html_url": "https://github.com/Rust-GCC/gccrs/commit/23712c118ddef30ff8a132bcb3c0b63e5a85eb05"}], "stats": {"total": 383, "additions": 200, "deletions": 183}, "files": [{"sha": "e871a6588373119306128d7cfc105ffa04256013", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6ff97b1c4f478ca3565810aa4bc81cc3aa114ae/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6ff97b1c4f478ca3565810aa4bc81cc3aa114ae/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=e6ff97b1c4f478ca3565810aa4bc81cc3aa114ae", "patch": "@@ -1,3 +1,8 @@\n+2001-03-12  Rodney Brown  <RodneyBrown@mynd.com>\n+\n+        * src/gen-num-limits.cc (traps) [SPECIALIZE_TRAPPING]: Add fflush\n+        prior to trapping signal (UnixWare 7 workaround).\n+\n 2001-03-12  Craig Rodrigues  <rodrigc@mediaone.net>\n \n \t* include/backward/hashtable.h: Same."}, {"sha": "1a9df6fdd3cd5e6c4270465b0c40e772e4df9323", "filename": "libstdc++-v3/src/gen-num-limits.cc", "status": "modified", "additions": 195, "deletions": 183, "changes": 378, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6ff97b1c4f478ca3565810aa4bc81cc3aa114ae/libstdc%2B%2B-v3%2Fsrc%2Fgen-num-limits.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6ff97b1c4f478ca3565810aa4bc81cc3aa114ae/libstdc%2B%2B-v3%2Fsrc%2Fgen-num-limits.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fgen-num-limits.cc?ref=e6ff97b1c4f478ca3565810aa4bc81cc3aa114ae", "patch": "@@ -139,49 +139,55 @@ bool trapping(const Operation& op)\n     return false;\n }\n \n-template<typename T> struct division_by_zero {\n+template<typename T> \n+  struct division_by_zero \n+  {\n     void operator() () const\n     {\n-        volatile T zero = T();\n-        volatile T one = T(1);\n-        volatile T infinity = one / zero;\n+      volatile T zero = T();\n+      volatile T one = T(1);\n+      volatile T infinity = one / zero;\n     }\n-};\n+  };\n \n-template<typename T> struct overflow {\n+template<typename T> \n+  struct overflow \n+  {\n     void operator() () const\n     {\n-        T i = T(1);\n-        T j = T();\n-        while (i>j) {\n-            j = i;\n-            i = i * 2 + 1;\n-        }\n+      T i = T(1);\n+      T j = T();\n+      while (i>j) {\n+\tj = i;\n+\ti = i * 2 + 1;\n+      }\n     }\n-};\n+  };\n \n-template<typename T> struct underflow {};\n+template<typename T> struct underflow { };\n \n // traps\n template<typename T> void traps()\n {\n-    signal_adapter (signal, SIGFPE, signal_handler);\n-    signal_adapter (signal, SIGTRAP, signal_handler);\n-    bool trap_flag = trapping(division_by_zero<T>());\n-    signal_adapter (signal, SIGFPE, signal_handler);\n-    signal_adapter (signal, SIGTRAP, signal_handler);\n-    trap_flag = trap_flag || trapping(overflow<T>());\n-    const char* p = bool_alpha[trap_flag];\n-    printf(\"%s%s = %s;\\n\", tab2, \"static const bool traps\", p);    \n+  fflush(NULL);\n+  signal_adapter (signal, SIGFPE, signal_handler);\n+  signal_adapter (signal, SIGTRAP, signal_handler);\n+  bool trap_flag = trapping(division_by_zero<T>());\n+  signal_adapter (signal, SIGFPE, signal_handler);\n+  signal_adapter (signal, SIGTRAP, signal_handler);\n+  trap_flag = trap_flag || trapping(overflow<T>());\n+  const char* p = bool_alpha[trap_flag];\n+  printf(\"%s%s = %s;\\n\", tab2, \"static const bool traps\", p);    \n }\n \n #define SPECIALIZE_TRAPPING(T)                                          \\\n template<> void traps< T >()                                            \\\n-{                                                                       \\\n-    signal_adapter (signal, SIGFPE, signal_handler);                    \\\n-    signal_adapter (signal, SIGTRAP, signal_handler);                    \\\n-    const char* p = bool_alpha[trapping(division_by_zero<T>())];        \\\n-    printf(\"%s%s = %s;\\n\", tab2, \"static const bool traps\", p);         \\\n+{       \t\t\t\t\t\t\t\t\\\n+  fflush(NULL);                                                         \\\n+  signal_adapter (signal, SIGFPE, signal_handler);                      \\\n+  signal_adapter (signal, SIGTRAP, signal_handler);                     \\\n+  const char* p = bool_alpha[trapping(division_by_zero<T>())];          \\\n+  printf(\"%s%s = %s;\\n\", tab2, \"static const bool traps\", p);           \\\n }\n \n SPECIALIZE_TRAPPING(unsigned char);\n@@ -194,10 +200,12 @@ SPECIALIZE_TRAPPING(unsigned long long);\n \n #undef SPECIALIZE_TRAPPING\n \n-template<typename T> struct type_name_trait {\n+template<typename T> \n+  struct type_name_trait \n+  {\n     static const char type_name[];\n     static const char trait_name[];\n-};\n+  };\n \n #define DEFINED_TYPE_NAME(T)                                            \\\n const char type_name_trait< T >::type_name[] = #T;                      \\\n@@ -225,40 +233,41 @@ DEFINED_TYPE_NAME(long double);\n #undef DEFINED_TYPE_NAME\n \n // declarator\n-template<typename T> struct declarator : type_name_trait<T> {\n+template<typename T> \n+  struct declarator : type_name_trait<T> \n+  {\n     typedef type_name_trait<T> base;\n     static void start()\n-    {\n-        printf(\"%s%s %s %s\\n\", tab, \"template<> struct\",\n-               base::trait_name, \"{\");\n+    { \n+      printf(\"%s%s %s %s\\n\", tab, \"template<> struct\", base::trait_name, \"{\"); \n     }\n-\n+    \n     static void end()\n-    {\n-        printf(\"%s};\\n\\n\", tab);\n-    }\n-};\n+    { printf(\"%s};\\n\\n\", tab); }\n+  };\n \n \n //\n // Predicates\n // \n-template<typename T> struct predicate {\n+template<typename T> \n+  struct predicate \n+  {\n     static const bool is_signed;\n     static const bool is_integer;\n     static const bool is_exact;\n-\n+    \n     static const bool has_infinity;\n     static const bool has_quiet_nan;\n     static const bool has_signaling_nan;\n     static const bool has_denorm;\n     static const bool has_denorm_loss;\n-\n+    \n     static const bool is_iec559;\n     static const bool is_bounded;\n-\n+    \n     static const bool traps;\n-};\n+  };\n \n template<typename T>\n const bool predicate<T>::is_signed = T(-1) < 0;\n@@ -321,23 +330,24 @@ SPECIALIZE_IEC559(unsigned long long);\n //\n // Values\n // \n-\n-template<typename T> struct value {\n+template<typename T> \n+  struct value \n+  {\n     static const char min[];\n     static const char max[];\n-\n+    \n     static const int digits;\n     static const int digits10;\n     \n     static const int radix;\n     static const char epsilon[];\n     static const char round_error[];\n-\n+    \n     static const int min_exponent;\n     static const int min_exponent10;\n     static const int max_exponent;\n     static const int max_exponent10;\n-};\n+  };\n \n #define DEFINE_EXTREMA(T, m, M)  DO_DEFINE_EXTREMA(T, m, M)\n #define DO_DEFINE_EXTREMA(T, m, M)\t\t\t\t\t\\\n@@ -507,283 +517,285 @@ SPECIALIZE_EXPONENTS(long double, LDBL_MIN_EXP, LDBL_MIN_10_EXP,\n \n template<typename T> void is_signed()\n {\n-    printf(\"%s%s = %s;\\n\", tab2, \"static const bool is_signed\",\n-           bool_alpha[predicate<T>::is_signed]);\n+  printf(\"%s%s = %s;\\n\", tab2, \"static const bool is_signed\",\n+\t bool_alpha[predicate<T>::is_signed]);\n }\n \n // a fundamental type is modulo iff it isn't signed\n template<typename T> void is_modulo()\n {\n-    printf(\"%s%s = %s;\\n\", tab2, \"static const bool is_modulo\",\n-           bool_alpha[! predicate<T>::is_signed]);\n+  printf(\"%s%s = %s;\\n\", tab2, \"static const bool is_modulo\",\n+\t bool_alpha[! predicate<T>::is_signed]);\n }\n \n template<typename T>\n void min()\n {\n-    printf(\"%s%s%s%s\\n%s%s%s%s\\n\", tab2, \"static \", declarator<T>::type_name,\n-           \" min() throw()\", tab2, \"{ return \", value<T>::min, \"; }\");\n+  printf(\"%s%s%s%s\\n%s%s%s%s\\n\", tab2, \"static \", declarator<T>::type_name,\n+\t \" min() throw()\", tab2, \"{ return \", value<T>::min, \"; }\");\n }\n \n template<typename T>\n void max()\n {\n-    printf(\"%s%s%s%s\\n%s%s%s%s\\n\", tab2, \"static \", declarator<T>::type_name,\n-           \" max() throw()\", tab2, \"{ return \", value<T>::max, \"; }\");\n+  printf(\"%s%s%s%s\\n%s%s%s%s\\n\", tab2, \"static \", declarator<T>::type_name,\n+\t \" max() throw()\", tab2, \"{ return \", value<T>::max, \"; }\");\n }\n \n template<typename T>\n void is_integer()\n {\n-    printf(\"%s%s = %s;\\n\", tab2, \"static const bool is_integer\",\n-           bool_alpha[predicate<T>::is_integer]);        \n+  printf(\"%s%s = %s;\\n\", tab2, \"static const bool is_integer\",\n+\t bool_alpha[predicate<T>::is_integer]);        \n }\n \n template<typename T>\n void is_exact()\n {\n-    printf(\"%s%s = %s;\\n\", tab2, \"static const bool is_exact\",\n-           bool_alpha[predicate<T>::is_exact]);    \n+  printf(\"%s%s = %s;\\n\", tab2, \"static const bool is_exact\",\n+\t bool_alpha[predicate<T>::is_exact]);    \n }\n \n template<typename T>\n void digits()\n {\n-    printf(\"%s%s = %d;\\n\", tab2, \"static const int digits\",\n-           value<T>::digits);\n+  printf(\"%s%s = %d;\\n\", tab2, \"static const int digits\",\n+\t value<T>::digits);\n }\n \n template<typename T>\n void digits10()\n {\n-    printf(\"%s%s = %d;\\n\", tab2, \"static const int digits10\",\n-           int(log10_of_two * value<T>::digits));\n+  printf(\"%s%s = %d;\\n\", tab2, \"static const int digits10\",\n+\t int(log10_of_two * value<T>::digits));\n }\n \n template<typename T>\n void radix()\n {\n-    printf(\"%s%s = %d;\\n\", tab2, \"static const int radix\",\n-           value<T>::radix);\n+  printf(\"%s%s = %d;\\n\", tab2, \"static const int radix\",\n+\t value<T>::radix);\n }\n \n template<typename T>\n void epsilon()\n {\n-    printf(\"%s%s %s %s\\n%s%s %s%s\\n\", tab2, \"static\",\n-           declarator<T>::type_name, \"epsilon() throw()\",\n-           tab2, \"{ return\", value<T>::epsilon, \"; }\");\n+  printf(\"%s%s %s %s\\n%s%s %s%s\\n\", tab2, \"static\",\n+\t declarator<T>::type_name, \"epsilon() throw()\",\n+\t tab2, \"{ return\", value<T>::epsilon, \"; }\");\n }\n \n template<typename T>\n void round_error()\n {\n-    printf(\"%s%s %s %s\\n%s%s %s%s\\n\", tab2, \"static\",\n-           declarator<T>::type_name, \"round_error() throw()\",\n-           tab2, \"{ return\", value<T>::round_error, \"; }\");\n+  printf(\"%s%s %s %s\\n%s%s %s%s\\n\", tab2, \"static\",\n+\t declarator<T>::type_name, \"round_error() throw()\",\n+\t tab2, \"{ return\", value<T>::round_error, \"; }\");\n }\n \n template<typename T>\n void min_exponent()\n {\n-    printf(\"%s%s = %d;\\n\", tab2, \"static const int min_exponent\",\n-           value<T>::min_exponent);    \n+  printf(\"%s%s = %d;\\n\", tab2, \"static const int min_exponent\",\n+\t value<T>::min_exponent);    \n }\n \n template<typename T>\n void min_exponent10()\n {\n-    printf(\"%s%s = %d;\\n\", tab2, \"static const int min_exponent10\",\n-           value<T>::min_exponent10);    \n+  printf(\"%s%s = %d;\\n\", tab2, \"static const int min_exponent10\",\n+\t value<T>::min_exponent10);    \n }\n \n template<typename T>\n void max_exponent()\n {\n-    printf(\"%s%s = %d;\\n\", tab2, \"static const int max_exponent\",\n-           value<T>::max_exponent);    \n+  printf(\"%s%s = %d;\\n\", tab2, \"static const int max_exponent\",\n+\t value<T>::max_exponent);    \n }\n \n template<typename T>\n void max_exponent10()\n {\n-    printf(\"%s%s = %d;\\n\", tab2, \"static const int max_exponent10\",\n-           value<T>::max_exponent10);    \n+  printf(\"%s%s = %d;\\n\", tab2, \"static const int max_exponent10\",\n+\t value<T>::max_exponent10);    \n }\n \n template<typename T>\n void has_infinity()\n {\n-    printf(\"%s%s = %s;\\n\", tab2, \"static const bool has_infinity\",\n-           bool_alpha[predicate<T>::has_infinity]);\n+  printf(\"%s%s = %s;\\n\", tab2, \"static const bool has_infinity\",\n+\t bool_alpha[predicate<T>::has_infinity]);\n }\n \n template<typename T>\n void has_quiet_nan()\n {\n-    printf(\"%s%s = %s;\\n\", tab2, \"static const bool has_quiet_NaN\",\n-           bool_alpha[predicate<T>::has_quiet_nan]);\n+  printf(\"%s%s = %s;\\n\", tab2, \"static const bool has_quiet_NaN\",\n+\t bool_alpha[predicate<T>::has_quiet_nan]);\n }\n \n template<typename T>\n void has_signaling_nan()\n {\n-    printf(\"%s%s = %s;\\n\", tab2, \"static const bool has_signaling_NaN\",\n-           bool_alpha[predicate<T>::has_signaling_nan]);\n+  printf(\"%s%s = %s;\\n\", tab2, \"static const bool has_signaling_NaN\",\n+\t bool_alpha[predicate<T>::has_signaling_nan]);\n }\n \n template<typename T>\n void has_denorm_loss()\n {\n-    printf(\"%s%s = %s;\\n\", tab2, \"static const bool has_denorm_loss\",\n-           bool_alpha[predicate<T>::has_denorm_loss]);\n+  printf(\"%s%s = %s;\\n\", tab2, \"static const bool has_denorm_loss\",\n+\t bool_alpha[predicate<T>::has_denorm_loss]);\n }\n \n-template<typename T> struct infinity_trait {\n+template<typename T> \n+  struct infinity_trait \n+  {\n     static void has_denorm()\n     {\n-        printf(\"%s%s;\\n\", tab2, \"static const float_denorm_style \"\n-               \"has_denorm = denorm_absent\");\n+      printf(\"%s%s;\\n\", tab2, \"static const float_denorm_style \"\n+\t     \"has_denorm = denorm_absent\");\n     }\n-\n+    \n     static void infinity()\n     {\n-        printf(\"%s%s %s %s\\n%s%s%s%s\\n\", tab2, \"static\",\n-               declarator<T>::type_name, \"infinity() throw()\",\n-               tab2, \"{ return static_cast<\", declarator<T>::type_name, \n-\t       \">(0); }\");\n+      printf(\"%s%s %s %s\\n%s%s%s%s\\n\", tab2, \"static\",\n+\t     declarator<T>::type_name, \"infinity() throw()\", tab2, \n+\t     \"{ return static_cast<\", declarator<T>::type_name, \">(0); }\");\n     }\n \n     static void quiet_NaN()\n     {\n-        printf(\"%s%s %s %s\\n%s%s%s%s\\n\", tab2, \"static\",\n-               declarator<T>::type_name, \"quiet_NaN() throw()\",\n-               tab2, \"{ return static_cast<\", declarator<T>::type_name, \n-\t       \">(0); }\");\n+      printf(\"%s%s %s %s\\n%s%s%s%s\\n\", tab2, \"static\",\n+\t     declarator<T>::type_name, \"quiet_NaN() throw()\",\n+\t     tab2, \"{ return static_cast<\", declarator<T>::type_name, \n+\t     \">(0); }\");\n     }\n-\n+    \n     static void signaling_NaN()\n     {\n-        printf(\"%s%s %s %s\\n%s%s%s%s\\n\", tab2, \"static\",\n-               declarator<T>::type_name, \"signaling_NaN() throw()\",\n-               tab2, \"{ return static_cast<\", declarator<T>::type_name, \n-\t       \">(0); }\");\n+      printf(\"%s%s %s %s\\n%s%s%s%s\\n\", tab2, \"static\",\n+\t     declarator<T>::type_name, \"signaling_NaN() throw()\",\n+\t     tab2, \"{ return static_cast<\", declarator<T>::type_name, \n+\t     \">(0); }\");\n     }\n \n     static void denorm_min()\n     {\n-        printf(\"%s%s %s %s\\n%s%s%s%s\\n\", tab2, \"static\",\n-               declarator<T>::type_name, \"denorm_min() throw()\",\n-               tab2, \"{ return static_cast<\", declarator<T>::type_name, \n-\t       \">(0); }\");\n+      printf(\"%s%s %s %s\\n%s%s%s%s\\n\", tab2, \"static\",\n+\t     declarator<T>::type_name, \"denorm_min() throw()\",\n+\t     tab2, \"{ return static_cast<\", declarator<T>::type_name, \n+\t     \">(0); }\");\n     }\n-};\n+  };\n \n \n template<typename T>\n void is_iec559()\n {\n-    printf(\"%s%s = %s;\\n\", tab2, \"static const bool is_iec559\",\n-           bool_alpha[predicate<T>::is_iec559]);\n+  printf(\"%s%s = %s;\\n\", tab2, \"static const bool is_iec559\",\n+\t bool_alpha[predicate<T>::is_iec559]);\n }\n \n // tinyness_before\n template<typename T>\n void tinyness_before()\n {\n-    printf(\"%s%s;\\n\", tab2, \"static const bool tinyness_before = false\");\n+  printf(\"%s%s;\\n\", tab2, \"static const bool tinyness_before = false\");\n }\n \n // round style\n template<typename T>\n void round_style()\n {\n-    printf(\"%s%s;\\n\", tab2, \"static const float_round_style \"\n-           \"round_style = round_toward_zero\");    \n+  printf(\"%s%s;\\n\", tab2, \"static const float_round_style \"\n+\t \"round_style = round_toward_zero\");    \n }\n \n \n \n // type traits\n-template<typename T> struct type_trait {\n-    \n+template<typename T> \n+  struct type_trait \n+  {\n     type_trait()\n     {\n-        declarator<T>::start();\n-        printf(\"%s%s;\\n\\n\", tab2, \"static const bool is_specialized = true\");\n-        min<T>();\n-        max<T>();\n-        printf(\"\\n\");\n-        digits<T>();\n-        digits10<T>();\n-        is_signed<T>();\n-        is_integer<T>();\n-        is_exact<T>();\n-        radix<T>();\n-        epsilon<T>();\n-        round_error<T>();\n-        printf(\"\\n\");\n-        min_exponent<T>();\n-        min_exponent10<T>();\n-        max_exponent<T>();\n-        max_exponent10<T>();\n-        printf(\"\\n\");\n-        has_infinity<T>();\n-        has_quiet_nan<T>();\n-        has_signaling_nan<T>();\n-        infinity_trait<T>::has_denorm();\n-        has_denorm_loss<T>();\n-        printf(\"\\n\");\n-        infinity_trait<T>::infinity();\n-        infinity_trait<T>::quiet_NaN();\n-        infinity_trait<T>::signaling_NaN();\n-        infinity_trait<T>::denorm_min();\n-        printf(\"\\n\");\n-        is_iec559<T>();\n-        printf(\"%s%s;\\n\", tab2, \"static const bool is_bounded = true\");\n-        is_modulo<T>();\n-        printf(\"\\n\");\n-        traps<T>();\n-        tinyness_before<T>();\n-        round_style<T>();\n-        declarator<T>::end();\n+      declarator<T>::start();\n+      printf(\"%s%s;\\n\\n\", tab2, \"static const bool is_specialized = true\");\n+      min<T>();\n+      max<T>();\n+      printf(\"\\n\");\n+      digits<T>();\n+      digits10<T>();\n+      is_signed<T>();\n+      is_integer<T>();\n+      is_exact<T>();\n+      radix<T>();\n+      epsilon<T>();\n+      round_error<T>();\n+      printf(\"\\n\");\n+      min_exponent<T>();\n+      min_exponent10<T>();\n+      max_exponent<T>();\n+      max_exponent10<T>();\n+      printf(\"\\n\");\n+      has_infinity<T>();\n+      has_quiet_nan<T>();\n+      has_signaling_nan<T>();\n+      infinity_trait<T>::has_denorm();\n+      has_denorm_loss<T>();\n+      printf(\"\\n\");\n+      infinity_trait<T>::infinity();\n+      infinity_trait<T>::quiet_NaN();\n+      infinity_trait<T>::signaling_NaN();\n+      infinity_trait<T>::denorm_min();\n+      printf(\"\\n\");\n+      is_iec559<T>();\n+      printf(\"%s%s;\\n\", tab2, \"static const bool is_bounded = true\");\n+      is_modulo<T>();\n+      printf(\"\\n\");\n+      traps<T>();\n+      tinyness_before<T>();\n+      round_style<T>();\n+      declarator<T>::end();\n     }\n-};\n+  };\n \n int main()\n {\n-    type_trait<bool>();\n-\n-    type_trait<char>();\n-    type_trait<signed char>();\n-    type_trait<unsigned char>();\n+  type_trait<bool>();\n+  \n+  type_trait<char>();\n+  type_trait<signed char>();\n+  type_trait<unsigned char>();\n #if defined( _GLIBCPP_USE_WCHAR_T) \n-    type_trait<wchar_t>();\n+  type_trait<wchar_t>();\n #endif\n-    \n-    type_trait<short>();\n-    type_trait<unsigned short>();\n-\n-    type_trait<int>();\n-    type_trait<unsigned int>();\n-\n-    type_trait<long>();\n-    type_trait<unsigned long>();\n-\n+  \n+  type_trait<short>();\n+  type_trait<unsigned short>();\n+  \n+  type_trait<int>();\n+  type_trait<unsigned int>();\n+  \n+  type_trait<long>();\n+  type_trait<unsigned long>();\n+  \n #ifdef _GLIBCPP_USE_LONG_LONG\n-    type_trait<long long>();\n-    type_trait<unsigned long long>();\n+  type_trait<long long>();\n+  type_trait<unsigned long long>();\n #endif\n \n-    type_trait<float>();\n-    type_trait<double>();\n-    type_trait<long double>();\n-\n-    // x86/linux gets this weirdness for the min/max functions:\n-    // static long double min() throw()\n-    // { return (__extension__ ((union __convert_long_double) \n-    // {__convert_long_double_i: {0x0, 0x80000000, 0x1, 0x0}})\n-    // .__convert_long_double_d); }\n+  type_trait<float>();\n+  type_trait<double>();\n+  type_trait<long double>();\n+  \n+  // x86/linux gets this weirdness for the min/max functions:\n+  // static long double min() throw()\n+  // { return (__extension__ ((union __convert_long_double) \n+  // {__convert_long_double_i: {0x0, 0x80000000, 0x1, 0x0}})\n+  // .__convert_long_double_d); }\n }\n \n // G++ doesn't have support for automatic instantiation of static data"}]}