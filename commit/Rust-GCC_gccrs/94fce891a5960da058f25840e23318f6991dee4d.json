{"sha": "94fce891a5960da058f25840e23318f6991dee4d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTRmY2U4OTFhNTk2MGRhMDU4ZjI1ODQwZTIzMzE4ZjY5OTFkZWU0ZA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2012-12-10T12:14:36Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2012-12-10T12:14:36Z"}, "message": "asan.c (asan_init_shadow_ptr_types): Move earlier in the file.\n\n\t* asan.c (asan_init_shadow_ptr_types): Move earlier in the file.\n\tCall initialize_sanitizer_builtins at the end.\n\t(asan_pp_string): Use TREE_TYPE (shadow_ptr_types[0])\n\tas character type instead of char_type_node.\n\t(asan_emit_stack_protection): Call asan_init_shadow_ptr_types\n\tif shadow_ptr_types isn't initialized.\n\t(asan_protect_global): Return true for STRING_CSTs except those\n\tcreated by asan_pp_string.\n\t(count_string_csts, add_string_csts): New functions.\n\t(struct asan_add_string_csts_data): New type.\n\t(asan_finish_file): Clear flag_asan at the beginning, restore at the\n\tend.  Traverse constant_pool_htab () to look for protected\n\tSTRING_CSTs.  Don't call initialize_sanitizer_builtins,\n\tinstead call asan_init_shadow_ptr_types if shadow_ptr_types isn't\n\tinitialized yet.\n\t(asan_instrument): Don't call initialize_sanitizer_builtins.\n\t* varasm.c (output_constant_def_contents): If STRING_CST should be\n\tasan protected, align it sufficiently and emit padding after it.\n\t(categorize_decl_for_section): If flag_asan, don't put STRING_CSTs\n\tthat should be asan protected into mergeable sections.  For\n\t-fmerge-all-constants, ignore it for -fmudflap or if decl is\n\tasan protected.\n\nFrom-SVN: r194355", "tree": {"sha": "3bd1c13134ce9fb42d46d64f6d4cfee4d5b21d3f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3bd1c13134ce9fb42d46d64f6d4cfee4d5b21d3f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/94fce891a5960da058f25840e23318f6991dee4d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94fce891a5960da058f25840e23318f6991dee4d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/94fce891a5960da058f25840e23318f6991dee4d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94fce891a5960da058f25840e23318f6991dee4d/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8d28afb446c64aacecad1af490215718093b250d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d28afb446c64aacecad1af490215718093b250d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d28afb446c64aacecad1af490215718093b250d"}], "stats": {"total": 154, "additions": 131, "deletions": 23}, "files": [{"sha": "d02c124426d9612ac719da4563fd7010e8e063b2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94fce891a5960da058f25840e23318f6991dee4d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94fce891a5960da058f25840e23318f6991dee4d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=94fce891a5960da058f25840e23318f6991dee4d", "patch": "@@ -1,3 +1,28 @@\n+2012-12-10  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* asan.c (asan_init_shadow_ptr_types): Move earlier in the file.\n+\tCall initialize_sanitizer_builtins at the end.\n+\t(asan_pp_string): Use TREE_TYPE (shadow_ptr_types[0])\n+\tas character type instead of char_type_node.\n+\t(asan_emit_stack_protection): Call asan_init_shadow_ptr_types\n+\tif shadow_ptr_types isn't initialized.\n+\t(asan_protect_global): Return true for STRING_CSTs except those\n+\tcreated by asan_pp_string.\n+\t(count_string_csts, add_string_csts): New functions.\n+\t(struct asan_add_string_csts_data): New type.\n+\t(asan_finish_file): Clear flag_asan at the beginning, restore at the\n+\tend.  Traverse constant_pool_htab () to look for protected\n+\tSTRING_CSTs.  Don't call initialize_sanitizer_builtins,\n+\tinstead call asan_init_shadow_ptr_types if shadow_ptr_types isn't\n+\tinitialized yet.\n+\t(asan_instrument): Don't call initialize_sanitizer_builtins.\n+\t* varasm.c (output_constant_def_contents): If STRING_CST should be\n+\tasan protected, align it sufficiently and emit padding after it.\n+\t(categorize_decl_for_section): If flag_asan, don't put STRING_CSTs\n+\tthat should be asan protected into mergeable sections.  For\n+\t-fmerge-all-constants, ignore it for -fmudflap or if decl is\n+\tasan protected.\n+\n 2012-12-10  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \t* config/arm/neon.ml (opcode): Add Vrintn, Vrinta, Vrintp, Vrintm,"}, {"sha": "6c8ef187189b077aac8eed13568dcf1556d7e3a6", "filename": "gcc/asan.c", "status": "modified", "additions": 89, "deletions": 21, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94fce891a5960da058f25840e23318f6991dee4d/gcc%2Fasan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94fce891a5960da058f25840e23318f6991dee4d/gcc%2Fasan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fasan.c?ref=94fce891a5960da058f25840e23318f6991dee4d", "patch": "@@ -212,6 +212,21 @@ alias_set_type asan_shadow_set = -1;\n    alias set is used for all shadow memory accesses.  */\n static GTY(()) tree shadow_ptr_types[2];\n \n+/* Initialize shadow_ptr_types array.  */\n+\n+static void\n+asan_init_shadow_ptr_types (void)\n+{\n+  asan_shadow_set = new_alias_set ();\n+  shadow_ptr_types[0] = build_distinct_type_copy (signed_char_type_node);\n+  TYPE_ALIAS_SET (shadow_ptr_types[0]) = asan_shadow_set;\n+  shadow_ptr_types[0] = build_pointer_type (shadow_ptr_types[0]);\n+  shadow_ptr_types[1] = build_distinct_type_copy (short_integer_type_node);\n+  TYPE_ALIAS_SET (shadow_ptr_types[1]) = asan_shadow_set;\n+  shadow_ptr_types[1] = build_pointer_type (shadow_ptr_types[1]);\n+  initialize_sanitizer_builtins ();\n+}\n+\n /* Asan pretty-printer, used for buidling of the description STRING_CSTs.  */\n static pretty_printer asan_pp;\n static bool asan_pp_initialized;\n@@ -234,10 +249,11 @@ asan_pp_string (void)\n   size_t len = strlen (buf);\n   tree ret = build_string (len + 1, buf);\n   TREE_TYPE (ret)\n-    = build_array_type (char_type_node, build_index_type (size_int (len)));\n+    = build_array_type (TREE_TYPE (shadow_ptr_types[0]),\n+\t\t\tbuild_index_type (size_int (len)));\n   TREE_READONLY (ret) = 1;\n   TREE_STATIC (ret) = 1;\n-  return build1 (ADDR_EXPR, build_pointer_type (char_type_node), ret);\n+  return build1 (ADDR_EXPR, shadow_ptr_types[0], ret);\n }\n \n /* Return a CONST_INT representing 4 subsequent shadow memory bytes.  */\n@@ -276,6 +292,9 @@ asan_emit_stack_protection (rtx base, HOST_WIDE_INT *offsets, tree *decls,\n   unsigned char cur_shadow_byte = ASAN_STACK_MAGIC_LEFT;\n   tree str_cst;\n \n+  if (shadow_ptr_types[0] == NULL_TREE)\n+    asan_init_shadow_ptr_types ();\n+\n   /* First of all, prepare the description string.  */\n   if (!asan_pp_initialized)\n     asan_pp_initialize ();\n@@ -430,6 +449,16 @@ asan_protect_global (tree decl)\n   rtx rtl, symbol;\n   section *sect;\n \n+  if (TREE_CODE (decl) == STRING_CST)\n+    {\n+      /* Instrument all STRING_CSTs except those created\n+\t by asan_pp_string here.  */\n+      if (shadow_ptr_types[0] != NULL_TREE\n+\t  && TREE_CODE (TREE_TYPE (decl)) == ARRAY_TYPE\n+\t  && TREE_TYPE (TREE_TYPE (decl)) == TREE_TYPE (shadow_ptr_types[0]))\n+\treturn false;\n+      return true;\n+    }\n   if (TREE_CODE (decl) != VAR_DECL\n       /* TLS vars aren't statically protectable.  */\n       || DECL_THREAD_LOCAL_P (decl)\n@@ -1580,6 +1609,50 @@ initialize_sanitizer_builtins (void)\n #undef DEF_SANITIZER_BUILTIN\n }\n \n+/* Called via htab_traverse.  Count number of emitted\n+   STRING_CSTs in the constant hash table.  */\n+\n+static int\n+count_string_csts (void **slot, void *data)\n+{\n+  struct constant_descriptor_tree *desc\n+    = (struct constant_descriptor_tree *) *slot;\n+  if (TREE_CODE (desc->value) == STRING_CST\n+      && TREE_ASM_WRITTEN (desc->value)\n+      && asan_protect_global (desc->value))\n+    ++*((unsigned HOST_WIDE_INT *) data);\n+  return 1;\n+}\n+\n+/* Helper structure to pass two parameters to\n+   add_string_csts.  */\n+\n+struct asan_add_string_csts_data\n+{\n+  tree type;\n+  vec<constructor_elt, va_gc> *v;\n+};\n+\n+/* Called via htab_traverse.  Call asan_add_global\n+   on emitted STRING_CSTs from the constant hash table.  */\n+\n+static int\n+add_string_csts (void **slot, void *data)\n+{\n+  struct constant_descriptor_tree *desc\n+    = (struct constant_descriptor_tree *) *slot;\n+  if (TREE_CODE (desc->value) == STRING_CST\n+      && TREE_ASM_WRITTEN (desc->value)\n+      && asan_protect_global (desc->value))\n+    {\n+      struct asan_add_string_csts_data *aascd\n+\t= (struct asan_add_string_csts_data *) data;\n+      asan_add_global (SYMBOL_REF_DECL (XEXP (desc->rtl, 0)),\n+\t\t       aascd->type, aascd->v);\n+    }\n+  return 1;\n+}\n+\n /* Needs to be GTY(()), because cgraph_build_static_cdtor may\n    invoke ggc_collect.  */\n static GTY(()) tree asan_ctor_statements;\n@@ -1595,13 +1668,20 @@ asan_finish_file (void)\n   struct varpool_node *vnode;\n   unsigned HOST_WIDE_INT gcount = 0;\n \n-  initialize_sanitizer_builtins ();\n+  if (shadow_ptr_types[0] == NULL_TREE)\n+    asan_init_shadow_ptr_types ();\n+  /* Avoid instrumenting code in the asan ctors/dtors.\n+     We don't need to insert padding after the description strings,\n+     nor after .LASAN* array.  */\n+  flag_asan = 0;\n \n   tree fn = builtin_decl_implicit (BUILT_IN_ASAN_INIT);\n   append_to_statement_list (build_call_expr (fn, 0), &asan_ctor_statements);\n   FOR_EACH_DEFINED_VARIABLE (vnode)\n     if (asan_protect_global (vnode->symbol.decl))\n       ++gcount;\n+  htab_t const_desc_htab = constant_pool_htab ();\n+  htab_traverse (const_desc_htab, count_string_csts, &gcount);\n   if (gcount)\n     {\n       tree type = asan_global_struct (), var, ctor;\n@@ -1622,6 +1702,10 @@ asan_finish_file (void)\n       FOR_EACH_DEFINED_VARIABLE (vnode)\n \tif (asan_protect_global (vnode->symbol.decl))\n \t  asan_add_global (vnode->symbol.decl, TREE_TYPE (type), v);\n+      struct asan_add_string_csts_data aascd;\n+      aascd.type = TREE_TYPE (type);\n+      aascd.v = v;\n+      htab_traverse (const_desc_htab, add_string_csts, &aascd);\n       ctor = build_constructor (type, v);\n       TREE_CONSTANT (ctor) = 1;\n       TREE_STATIC (ctor) = 1;\n@@ -1644,20 +1728,7 @@ asan_finish_file (void)\n     }\n   cgraph_build_static_cdtor ('I', asan_ctor_statements,\n \t\t\t     MAX_RESERVED_INIT_PRIORITY - 1);\n-}\n-\n-/* Initialize shadow_ptr_types array.  */\n-\n-static void\n-asan_init_shadow_ptr_types (void)\n-{\n-  asan_shadow_set = new_alias_set ();\n-  shadow_ptr_types[0] = build_distinct_type_copy (signed_char_type_node);\n-  TYPE_ALIAS_SET (shadow_ptr_types[0]) = asan_shadow_set;\n-  shadow_ptr_types[0] = build_pointer_type (shadow_ptr_types[0]);\n-  shadow_ptr_types[1] = build_distinct_type_copy (short_integer_type_node);\n-  TYPE_ALIAS_SET (shadow_ptr_types[1]) = asan_shadow_set;\n-  shadow_ptr_types[1] = build_pointer_type (shadow_ptr_types[1]);\n+  flag_asan = 1;\n }\n \n /* Instrument the current function.  */\n@@ -1666,10 +1737,7 @@ static unsigned int\n asan_instrument (void)\n {\n   if (shadow_ptr_types[0] == NULL_TREE)\n-    {\n-      asan_init_shadow_ptr_types ();\n-      initialize_sanitizer_builtins ();\n-    }\n+    asan_init_shadow_ptr_types ();\n   transform_statements ();\n   return 0;\n }"}, {"sha": "3c420c013d8a0c450081180f04fec7e8b532b1f8", "filename": "gcc/varasm.c", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94fce891a5960da058f25840e23318f6991dee4d/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94fce891a5960da058f25840e23318f6991dee4d/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=94fce891a5960da058f25840e23318f6991dee4d", "patch": "@@ -3249,11 +3249,23 @@ output_constant_def_contents (rtx symbol)\n     place_block_symbol (symbol);\n   else\n     {\n+      bool asan_protected = false;\n       align = DECL_ALIGN (decl);\n       switch_to_section (get_constant_section (exp, align));\n+      if (flag_asan && TREE_CODE (exp) == STRING_CST\n+\t  && asan_protect_global (exp))\n+\t{\n+\t  asan_protected = true;\n+\t  align = MAX (align, ASAN_RED_ZONE_SIZE * BITS_PER_UNIT);\n+\t}\n       if (align > BITS_PER_UNIT)\n \tASM_OUTPUT_ALIGN (asm_out_file, floor_log2 (align / BITS_PER_UNIT));\n       assemble_constant_contents (exp, XSTR (symbol, 0), align);\n+      if (asan_protected)\n+\t{\n+\t  HOST_WIDE_INT size = get_constant_size (exp);\n+\t  assemble_zeros (asan_red_zone_size (size));\n+\t}\n     }\n   if (flag_mudflap)\n     mudflap_enqueue_constant (exp);\n@@ -6157,7 +6169,9 @@ categorize_decl_for_section (const_tree decl, int reloc)\n     return SECCAT_TEXT;\n   else if (TREE_CODE (decl) == STRING_CST)\n     {\n-      if (flag_mudflap) /* or !flag_merge_constants */\n+      if (flag_mudflap\n+\t  || (flag_asan && asan_protect_global (CONST_CAST_TREE (decl))))\n+      /* or !flag_merge_constants */\n         return SECCAT_RODATA;\n       else\n \treturn SECCAT_RODATA_MERGE_STR;\n@@ -6181,7 +6195,8 @@ categorize_decl_for_section (const_tree decl, int reloc)\n \t}\n       else if (reloc & targetm.asm_out.reloc_rw_mask ())\n \tret = reloc == 1 ? SECCAT_DATA_REL_RO_LOCAL : SECCAT_DATA_REL_RO;\n-      else if (reloc || flag_merge_constants < 2)\n+      else if (reloc || flag_merge_constants < 2 || flag_mudflap\n+\t       || (flag_asan && asan_protect_global (CONST_CAST_TREE (decl))))\n \t/* C and C++ don't allow different variables to share the same\n \t   location.  -fmerge-all-constants allows even that (at the\n \t   expense of not conforming).  */"}]}