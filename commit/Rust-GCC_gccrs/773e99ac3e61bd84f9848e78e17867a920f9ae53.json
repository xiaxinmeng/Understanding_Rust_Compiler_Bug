{"sha": "773e99ac3e61bd84f9848e78e17867a920f9ae53", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzczZTk5YWMzZTYxYmQ4NGY5ODQ4ZTc4ZTE3ODY3YTkyMGY5YWU1Mw==", "commit": {"author": {"name": "Justin Squirek", "email": "squirek@adacore.com", "date": "2020-03-12T11:01:43Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-06-15T08:04:31Z"}, "message": "[Ada] Bad access checks on if/case expression as actual\n\n2020-06-15  Justin Squirek  <squirek@adacore.com>\n\ngcc/ada/\n\n\t* exp_ch4.adb (Expand_N_Case_Expression): Set default value for\n\tTarget to silence potential warnings.\n\t(Expand_N_If_Expression): Add calculation to check when the if\n\texpression is used directly in the context of an actual of an\n\tanonymous access type and add a special path to force expansion\n\tof the if expression in this case.\n\t* exp_ch6.adb (Expand_Branch): Generate an assignment to the\n\tlevel temporary for a given branch.\n\t(Expand_Call_Helper): Add expansion to allow for creating a\n\ttemporary to store associated accessiblity levels on each branch\n\tof the conditional expression.  Also perform expansion of\n\tfunction calls into expressions with actions, and fixup\n\treferences to N with Call_Node.\n\t(Insert_Level_Assign): Move through nested conditional\n\texpressions to each branch.\n\t* sem_util.ads, sem_util.adb (Is_Anonymous_Access_Actual): Added\n\tto detect when to force expansion of if expressions.", "tree": {"sha": "2be9737f01ffa0ed2c05f6d40ffddbad55c9802c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2be9737f01ffa0ed2c05f6d40ffddbad55c9802c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/773e99ac3e61bd84f9848e78e17867a920f9ae53", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/773e99ac3e61bd84f9848e78e17867a920f9ae53", "html_url": "https://github.com/Rust-GCC/gccrs/commit/773e99ac3e61bd84f9848e78e17867a920f9ae53", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/773e99ac3e61bd84f9848e78e17867a920f9ae53/comments", "author": {"login": "AdaDoom3", "id": 3445599, "node_id": "MDQ6VXNlcjM0NDU1OTk=", "avatar_url": "https://avatars.githubusercontent.com/u/3445599?v=4", "gravatar_id": "", "url": "https://api.github.com/users/AdaDoom3", "html_url": "https://github.com/AdaDoom3", "followers_url": "https://api.github.com/users/AdaDoom3/followers", "following_url": "https://api.github.com/users/AdaDoom3/following{/other_user}", "gists_url": "https://api.github.com/users/AdaDoom3/gists{/gist_id}", "starred_url": "https://api.github.com/users/AdaDoom3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/AdaDoom3/subscriptions", "organizations_url": "https://api.github.com/users/AdaDoom3/orgs", "repos_url": "https://api.github.com/users/AdaDoom3/repos", "events_url": "https://api.github.com/users/AdaDoom3/events{/privacy}", "received_events_url": "https://api.github.com/users/AdaDoom3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fdcbc0764dee19e9e1eeeb17c960567474b4d688", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fdcbc0764dee19e9e1eeeb17c960567474b4d688", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fdcbc0764dee19e9e1eeeb17c960567474b4d688"}], "stats": {"total": 343, "additions": 323, "deletions": 20}, "files": [{"sha": "bf8822517329de71ae0e550403a5abc80fae8829", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 78, "deletions": 8, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/773e99ac3e61bd84f9848e78e17867a920f9ae53/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/773e99ac3e61bd84f9848e78e17867a920f9ae53/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=773e99ac3e61bd84f9848e78e17867a920f9ae53", "patch": "@@ -5314,7 +5314,7 @@ package body Exp_Ch4 is\n       Case_Stmt  : Node_Id;\n       Decl       : Node_Id;\n       Expr       : Node_Id;\n-      Target     : Entity_Id;\n+      Target     : Entity_Id := Empty;\n       Target_Typ : Entity_Id;\n \n       In_Predicate : Boolean := False;\n@@ -5771,11 +5771,21 @@ package body Exp_Ch4 is\n       Elsex : constant Node_Id    := Next (Thenx);\n       Typ   : constant Entity_Id  := Etype (N);\n \n-      Actions : List_Id;\n-      Decl    : Node_Id;\n-      Expr    : Node_Id;\n-      New_If  : Node_Id;\n-      New_N   : Node_Id;\n+      Actions      : List_Id;\n+      Decl         : Node_Id;\n+      Expr         : Node_Id;\n+      New_If       : Node_Id;\n+      New_N        : Node_Id;\n+\n+      --  Determine if we are dealing with a special case of a conditional\n+      --  expression used as an actual for an anonymous access type which\n+      --  forces us to transform the if expression into an expression with\n+      --  actions in order to create a temporary to capture the level of the\n+      --  expression in each branch.\n+\n+      Force_Expand : constant Boolean := Is_Anonymous_Access_Actual (N);\n+\n+   --  Start of processing for Expand_N_If_Expression\n \n    begin\n       --  Check for MINIMIZED/ELIMINATED overflow mode\n@@ -5975,9 +5985,13 @@ package body Exp_Ch4 is\n          end;\n \n       --  For other types, we only need to expand if there are other actions\n-      --  associated with either branch.\n+      --  associated with either branch or we need to force expansion to deal\n+      --  with if expressions used as an actual of an anonymous access type.\n \n-      elsif Present (Then_Actions (N)) or else Present (Else_Actions (N)) then\n+      elsif Present (Then_Actions (N))\n+        or else Present (Else_Actions (N))\n+        or else Force_Expand\n+      then\n \n          --  We now wrap the actions into the appropriate expression\n \n@@ -6051,6 +6065,62 @@ package body Exp_Ch4 is\n                Analyze_And_Resolve (Elsex, Typ);\n             end if;\n \n+            --  We must force expansion into an expression with actions when\n+            --  an if expression gets used directly as an actual for an\n+            --  anonymous access type.\n+\n+            if Force_Expand then\n+               declare\n+                  Cnn  : constant Entity_Id := Make_Temporary (Loc, 'C');\n+                  Acts : List_Id;\n+               begin\n+                  Acts := New_List;\n+\n+                  --  Generate:\n+                  --    Cnn : Ann;\n+\n+                  Decl :=\n+                    Make_Object_Declaration (Loc,\n+                      Defining_Identifier => Cnn,\n+                      Object_Definition   => New_Occurrence_Of (Typ, Loc));\n+                  Append_To (Acts, Decl);\n+\n+                  Set_No_Initialization (Decl);\n+\n+                  --  Generate:\n+                  --    if Cond then\n+                  --       Cnn := <Thenx>;\n+                  --    else\n+                  --       Cnn := <Elsex>;\n+                  --    end if;\n+\n+                  New_If :=\n+                    Make_Implicit_If_Statement (N,\n+                      Condition       => Relocate_Node (Cond),\n+                      Then_Statements => New_List (\n+                        Make_Assignment_Statement (Sloc (Thenx),\n+                          Name       => New_Occurrence_Of (Cnn, Sloc (Thenx)),\n+                          Expression => Relocate_Node (Thenx))),\n+\n+                      Else_Statements => New_List (\n+                        Make_Assignment_Statement (Sloc (Elsex),\n+                          Name       => New_Occurrence_Of (Cnn, Sloc (Elsex)),\n+                          Expression => Relocate_Node (Elsex))));\n+                  Append_To (Acts, New_If);\n+\n+                  --  Generate:\n+                  --    do\n+                  --       ...\n+                  --    in Cnn end;\n+\n+                  Rewrite (N,\n+                    Make_Expression_With_Actions (Loc,\n+                      Expression => New_Occurrence_Of (Cnn, Loc),\n+                      Actions    => Acts));\n+                  Analyze_And_Resolve (N, Typ);\n+               end;\n+            end if;\n+\n             return;\n          end if;\n "}, {"sha": "e7d2cccda58c96aba02d39e9647f9448ce0a22d9", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 219, "deletions": 12, "changes": 231, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/773e99ac3e61bd84f9848e78e17867a920f9ae53/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/773e99ac3e61bd84f9848e78e17867a920f9ae53/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=773e99ac3e61bd84f9848e78e17867a920f9ae53", "patch": "@@ -2645,7 +2645,7 @@ package body Exp_Ch6 is\n          end loop;\n \n          if not Is_Empty_List (Inv_Checks) then\n-            Insert_Actions_After (N, Inv_Checks);\n+            Insert_Actions_After (Call_Node, Inv_Checks);\n          end if;\n       end Add_View_Conversion_Invariants;\n \n@@ -2919,7 +2919,7 @@ package body Exp_Ch6 is\n                Formal : Node_Id;\n \n             begin\n-               Actual := First (Parameter_Associations (N));\n+               Actual := First (Parameter_Associations (Call_Node));\n                Formal := First_Formal (Subp);\n                while Present (Actual)\n                  and then Present (Formal)\n@@ -3610,10 +3610,215 @@ package body Exp_Ch6 is\n                   --  Prev_Orig denotes an original expression that has\n                   --  not been analyzed.\n \n+                  --  However, when the actual is wrapped in a conditional\n+                  --  expression we must add a local temporary to store the\n+                  --  level at each branch, and, possibly, expand the call\n+                  --  into an expression with actions.\n+\n                   when others =>\n-                     Add_Extra_Actual\n-                       (Expr => Dynamic_Accessibility_Level (Prev),\n-                        EF   => Get_Accessibility (Formal));\n+                     if Nkind (Prev) = N_Expression_With_Actions\n+                       and then Nkind_In (Original_Node (Prev),\n+                                           N_If_Expression,\n+                                           N_Case_Expression)\n+                     then\n+                        declare\n+                           Decl : Node_Id;\n+                           Lvl  : Entity_Id;\n+                           Res  : Entity_Id;\n+                           Temp : Node_Id;\n+                           Typ  : Node_Id;\n+\n+                           procedure Insert_Level_Assign (Branch : Node_Id);\n+                           --  Recursivly add assignment of the level temporary\n+                           --  on each branch while moving through nested\n+                           --  conditional expressions.\n+\n+                           -------------------------\n+                           -- Insert_Level_Assign --\n+                           -------------------------\n+\n+                           procedure Insert_Level_Assign (Branch : Node_Id) is\n+\n+                              procedure Expand_Branch (Assn : Node_Id);\n+                              --  Perform expansion or iterate further within\n+                              --  nested conditionals.\n+\n+                              -------------------\n+                              -- Expand_Branch --\n+                              -------------------\n+\n+                              procedure Expand_Branch (Assn : Node_Id) is\n+                              begin\n+                                 pragma Assert (Nkind (Assn) =\n+                                                 N_Assignment_Statement);\n+\n+                                 --  There are more nested conditional\n+                                 --  expressions so we must go deeper.\n+\n+                                 if Nkind (Expression (Assn)) =\n+                                      N_Expression_With_Actions\n+                                 then\n+                                    Insert_Level_Assign (Expression (Assn));\n+\n+                                 --  Add the level assignment\n+\n+                                 else\n+                                    Insert_Before_And_Analyze (Assn,\n+                                      Make_Assignment_Statement (Loc,\n+                                        Name       =>\n+                                          New_Occurrence_Of\n+                                            (Lvl, Loc),\n+                                        Expression =>\n+                                          Dynamic_Accessibility_Level\n+                                            (Expression (Assn))));\n+                                 end if;\n+                              end Expand_Branch;\n+\n+                              Cond : Node_Id;\n+                              Alt  : Node_Id;\n+\n+                           --  Start of processing for Insert_Level_Assign\n+\n+                           begin\n+                              --  Examine further nested condtionals\n+\n+                              pragma Assert (Nkind (Branch) =\n+                                              N_Expression_With_Actions);\n+\n+                              --  Find the relevant statement in the actions\n+\n+                              Cond := First (Actions (Branch));\n+                              loop\n+                                 exit when Nkind_In (Cond, N_Case_Statement,\n+                                                           N_If_Statement);\n+\n+                                 Next (Cond);\n+                                 pragma Assert (Present (Cond));\n+                              end loop;\n+\n+                              --  Iterate through if expression branches\n+\n+                              if Nkind (Cond) = N_If_Statement then\n+                                 Expand_Branch (Last (Then_Statements (Cond)));\n+                                 Expand_Branch (Last (Else_Statements (Cond)));\n+\n+                              --  Iterate through case alternatives\n+\n+                              elsif Nkind (Cond) = N_Case_Statement then\n+\n+                                 Alt := First (Alternatives (Cond));\n+                                 while Present (Alt) loop\n+                                    Expand_Branch (Last (Statements (Alt)));\n+\n+                                    Next (Alt);\n+                                 end loop;\n+                              end if;\n+                           end Insert_Level_Assign;\n+\n+                        --  Start of processing for cond expression case\n+\n+                        begin\n+                           --  Create declaration of a temporary to store the\n+                           --  accessibility level of each branch of the\n+                           --  conditional expression.\n+\n+                           Lvl  := Make_Temporary (Loc, 'L');\n+                           Decl :=\n+                              Make_Object_Declaration (Loc,\n+                                Defining_Identifier => Lvl,\n+                                Object_Definition   =>\n+                                  New_Occurrence_Of (Standard_Natural, Loc));\n+\n+                           --  Install the declaration and perform necessary\n+                           --  expansion if we are dealing with a function\n+                           --  call.\n+\n+                           if Nkind (Call_Node) =\n+                                N_Procedure_Call_Statement\n+                           then\n+                              --  Generate:\n+                              --    Lvl : Natural;\n+                              --    Call (\n+                              --     {do\n+                              --        If_Exp_Res : Typ;\n+                              --        if Cond then\n+                              --           Lvl        := 0; --  Access level\n+                              --           If_Exp_Res := Exp;\n+                              --        ...\n+                              --      in If_Exp_Res end;},\n+                              --      Lvl,\n+                              --      ...\n+                              --    )\n+\n+                              Insert_Before_And_Analyze (Call_Node, Decl);\n+\n+                           --  A function call must be transformed into an\n+                           --  expression with actions.\n+\n+                           else\n+                              --  Generate:\n+                              --    do\n+                              --      Lvl : Natural;\n+                              --    in Call (do{\n+                              --               If_Exp_Res : Typ\n+                              --               if Cond then\n+                              --                 Lvl := 0; --  Access level\n+                              --                 If_Exp_Res := Exp;\n+                              --               in If_Exp_Res end;},\n+                              --             Lvl,\n+                              --             ...\n+                              --             )\n+                              --    end;\n+\n+                              Res  := Make_Temporary (Loc, 'R');\n+                              Typ  := Etype (Call_Node);\n+                              Temp := Relocate_Node (Call_Node);\n+\n+                              --  Perform the rewrite with the dummy\n+\n+                              Rewrite (Call_Node,\n+\n+                                Make_Expression_With_Actions (Loc,\n+                                  Expression => New_Occurrence_Of (Res, Loc),\n+                                  Actions    => New_List (\n+                                    Decl,\n+\n+                                    Make_Object_Declaration (Loc,\n+                                      Defining_Identifier => Res,\n+                                      Object_Definition   =>\n+                                        New_Occurrence_Of (Typ, Loc)))));\n+\n+                              --  Analyze the expression with the dummy\n+\n+                              Analyze_And_Resolve (Call_Node, Typ);\n+\n+                              --  Properly set the expression and move our view\n+                              --  of the call node\n+\n+                              Set_Expression (Call_Node, Relocate_Node (Temp));\n+                              Call_Node := Expression (Call_Node);\n+                              Remove (Next (Decl));\n+                           end if;\n+\n+                           --  Decorate the conditional expression with\n+                           --  assignments to our level temporary.\n+\n+                           Insert_Level_Assign (Prev);\n+\n+                           --  Make our level temporary the passed actual\n+\n+                           Add_Extra_Actual\n+                             (Expr => New_Occurrence_Of (Lvl, Loc),\n+                              EF   => Get_Accessibility (Formal));\n+                        end;\n+\n+                     --  General case uncomplicated by conditional expressions\n+\n+                     else\n+                        Add_Extra_Actual\n+                          (Expr => Dynamic_Accessibility_Level (Prev),\n+                           EF   => Get_Accessibility (Formal));\n+                     end if;\n                end case;\n             end if;\n          end if;\n@@ -3801,7 +4006,7 @@ package body Exp_Ch6 is\n          --  generating spurious checks on complex expansion such as object\n          --  initialization through an extension aggregate.\n \n-         if Comes_From_Source (N)\n+         if Comes_From_Source (Call_Node)\n            and then Ekind (Formal) /= E_In_Parameter\n            and then Nkind (Actual) = N_Type_Conversion\n          then\n@@ -4313,7 +4518,7 @@ package body Exp_Ch6 is\n \n       if Nkind (Name (Call_Node)) = N_Explicit_Dereference then\n \n-      --  Handle case of access to protected subprogram type\n+         --  Handle case of access to protected subprogram type\n \n          if Is_Access_Protected_Subprogram_Type\n               (Base_Type (Etype (Prefix (Name (Call_Node)))))\n@@ -4461,8 +4666,9 @@ package body Exp_Ch6 is\n          --  back-end inlining is enabled).\n \n          elsif Is_Inlinable_Expression_Function (Subp) then\n-            Rewrite (N, New_Copy (Expression_Of_Expression_Function (Subp)));\n-            Analyze (N);\n+            Rewrite\n+              (Call_Node, New_Copy (Expression_Of_Expression_Function (Subp)));\n+            Analyze (Call_Node);\n             return;\n \n          --  Handle front-end inlining\n@@ -4533,7 +4739,7 @@ package body Exp_Ch6 is\n \n                   elsif Modify_Tree_For_C\n                     and then In_Same_Extended_Unit (Sloc (Bod), Loc)\n-                    and then Chars (Name (N)) = Name_uPostconditions\n+                    and then Chars (Name (Call_Node)) = Name_uPostconditions\n                   then\n                      Must_Inline := True;\n                   end if;\n@@ -4641,8 +4847,9 @@ package body Exp_Ch6 is\n                               N_Slice)\n            and then\n              (Ekind (Current_Scope) /= E_Loop\n-               or else Nkind (Parent (N)) /= N_Function_Call\n-               or else not Is_Build_In_Place_Function_Call (Parent (N)))\n+               or else Nkind (Parent (Call_Node)) /= N_Function_Call\n+               or else not Is_Build_In_Place_Function_Call\n+                             (Parent (Call_Node)))\n          then\n             Establish_Transient_Scope (Call_Node, Manage_Sec_Stack => True);\n          end if;"}, {"sha": "203cada0956bc63801181231fcd203abf4ce95e8", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/773e99ac3e61bd84f9848e78e17867a920f9ae53/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/773e99ac3e61bd84f9848e78e17867a920f9ae53/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=773e99ac3e61bd84f9848e78e17867a920f9ae53", "patch": "@@ -14170,6 +14170,28 @@ package body Sem_Util is\n       end if;\n    end Invalid_Scalar_Value;\n \n+   --------------------------------\n+   -- Is_Anonymous_Access_Actual --\n+   --------------------------------\n+\n+   function Is_Anonymous_Access_Actual (N : Node_Id) return Boolean is\n+      Par : Node_Id;\n+   begin\n+      if Ekind (Etype (N)) /= E_Anonymous_Access_Type then\n+         return False;\n+      end if;\n+\n+      Par := Parent (N);\n+      while Present (Par)\n+        and then Nkind_In (Par, N_Case_Expression,\n+                                N_If_Expression,\n+                                N_Parameter_Association)\n+      loop\n+         Par := Parent (Par);\n+      end loop;\n+      return Nkind (Par) in N_Subprogram_Call;\n+   end Is_Anonymous_Access_Actual;\n+\n    -----------------------------\n    -- Is_Actual_Out_Parameter --\n    -----------------------------"}, {"sha": "ebc917512bfd19adef3695600de36c190bfb288b", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/773e99ac3e61bd84f9848e78e17867a920f9ae53/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/773e99ac3e61bd84f9848e78e17867a920f9ae53/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=773e99ac3e61bd84f9848e78e17867a920f9ae53", "patch": "@@ -1579,6 +1579,10 @@ package Sem_Util is\n    --  pragma Initialize_Scalars or by the binder. Return an expression created\n    --  at source location Loc, which denotes the invalid value.\n \n+   function Is_Anonymous_Access_Actual (N : Node_Id) return Boolean;\n+   --  Determine if N is used as an actual for a call whose corresponding\n+   --  formal is of an anonymous access type.\n+\n    function Is_Access_Subprogram_Wrapper (E : Entity_Id) return Boolean;\n    --  True if E is the constructed wrapper for an access_to_subprogram\n    --  type with Pre/Postconditions."}]}