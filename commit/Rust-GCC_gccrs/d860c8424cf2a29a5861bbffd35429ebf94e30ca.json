{"sha": "d860c8424cf2a29a5861bbffd35429ebf94e30ca", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDg2MGM4NDI0Y2YyYTI5YTU4NjFiYmZmZDM1NDI5ZWJmOTRlMzBjYQ==", "commit": {"author": {"name": "Paolo Carlini", "email": "paolo.carlini@oracle.com", "date": "2010-06-27T09:29:25Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2010-06-27T09:29:25Z"}, "message": "regex_compiler.h: Trivial formatting / stylistic fixes.\n\n2010-06-27  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\t* include/bits/regex_compiler.h: Trivial formatting / stylistic fixes.\n\t* include/bits/regex_grep_matcher.tcc: Likewise.\n\t* include/bits/regex_cursor.h: Likewise.\n\t* include/bits/regex.h: Likewise.\n\nFrom-SVN: r161462", "tree": {"sha": "49853af4759975c3013cb9d84c2a0d4c4837bf75", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/49853af4759975c3013cb9d84c2a0d4c4837bf75"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d860c8424cf2a29a5861bbffd35429ebf94e30ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d860c8424cf2a29a5861bbffd35429ebf94e30ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d860c8424cf2a29a5861bbffd35429ebf94e30ca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d860c8424cf2a29a5861bbffd35429ebf94e30ca/comments", "author": null, "committer": null, "parents": [{"sha": "83e279c4c3fee56680e63abd25fcd1a1429fa8dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83e279c4c3fee56680e63abd25fcd1a1429fa8dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/83e279c4c3fee56680e63abd25fcd1a1429fa8dc"}], "stats": {"total": 1020, "additions": 515, "deletions": 505}, "files": [{"sha": "394d56026348318681960244e328613731a5b3cf", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d860c8424cf2a29a5861bbffd35429ebf94e30ca/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d860c8424cf2a29a5861bbffd35429ebf94e30ca/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=d860c8424cf2a29a5861bbffd35429ebf94e30ca", "patch": "@@ -1,3 +1,10 @@\n+2010-06-27  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\t* include/bits/regex_compiler.h: Trivial formatting / stylistic fixes.\n+\t* include/bits/regex_grep_matcher.tcc: Likewise.\n+\t* include/bits/regex_cursor.h: Likewise.\n+\t* include/bits/regex.h: Likewise.\n+\n 2010-06-26  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \t* testsuite/util/testsuite_hooks.h: Cast fn to bool."}, {"sha": "f035fd4ade49fc59e3e9a6e08b60867361f10295", "filename": "libstdc++-v3/include/bits/regex.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d860c8424cf2a29a5861bbffd35429ebf94e30ca/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d860c8424cf2a29a5861bbffd35429ebf94e30ca/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex.h?ref=d860c8424cf2a29a5861bbffd35429ebf94e30ca", "patch": "@@ -451,7 +451,8 @@ namespace std\n        */\n       template<typename _Ch_traits, typename _Ch_alloc>\n         explicit\n-        basic_regex(const std::basic_string<_Ch_type, _Ch_traits, _Ch_alloc>& __s,\n+        basic_regex(const std::basic_string<_Ch_type, _Ch_traits,\n+\t\t    _Ch_alloc>& __s,\n \t\t    flag_type __f = regex_constants::ECMAScript)\n \t: _M_flags(__f),\n \t  _M_automaton(__regex::__compile(__s.begin(), __s.end(),"}, {"sha": "0bc362dc77e134d0e6ad98242c293925ac58c5a7", "filename": "libstdc++-v3/include/bits/regex_compiler.h", "status": "modified", "additions": 447, "deletions": 443, "changes": 890, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d860c8424cf2a29a5861bbffd35429ebf94e30ca/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_compiler.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d860c8424cf2a29a5861bbffd35429ebf94e30ca/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_compiler.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_compiler.h?ref=d860c8424cf2a29a5861bbffd35429ebf94e30ca", "patch": "@@ -34,7 +34,8 @@ namespace __regex\n {\n   struct _Scanner_base\n   {\n-    typedef unsigned int _StateT; // FIXME: replace these constanst with constexpr\n+    // FIXME: replace these constanst with constexpr\n+    typedef unsigned int _StateT;\n \n     static const _StateT _S_state_at_start    = 1 << 0;\n     static const _StateT _S_state_in_brace    = 1 << 2;\n@@ -153,92 +154,92 @@ namespace __regex\n     _M_advance()\n     {\n       if (_M_current == _M_end)\n-      {\n-\t_M_curToken = _S_token_eof;\n-\treturn;\n-      }\n+\t{\n+\t  _M_curToken = _S_token_eof;\n+\t  return;\n+\t}\n \n       _CharT __c = *_M_current;\n       if (_M_state & _S_state_in_bracket)\n-      {\n-\t_M_scan_in_bracket();\n-\treturn;\n-      }\n+\t{\n+\t  _M_scan_in_bracket();\n+\t  return;\n+\t}\n       if (_M_state & _S_state_in_brace)\n-      {\n-\t_M_scan_in_brace();\n-\treturn;\n-      }\n+\t{\n+\t  _M_scan_in_brace();\n+\t  return;\n+\t}\n       else if (_M_state & _S_state_at_start && __c == _M_ctype.widen('^'))\n-      {\n-\t_M_curToken = _S_token_line_begin;\n-\t++_M_current;\n-\treturn;\n-      }\n+\t{\n+\t  _M_curToken = _S_token_line_begin;\n+\t  ++_M_current;\n+\t  return;\n+\t}\n       else if (__c == _M_ctype.widen('$'))\n-      {\n-\t_M_curToken = _S_token_line_end;\n-\t++_M_current;\n-\treturn;\n-      }\n+\t{\n+\t  _M_curToken = _S_token_line_end;\n+\t  ++_M_current;\n+\t  return;\n+\t}\n       else if (__c == _M_ctype.widen('.'))\n-      {\n-\t_M_curToken = _S_token_anychar;\n-\t++_M_current;\n-\treturn;\n-      }\n+\t{\n+\t  _M_curToken = _S_token_anychar;\n+\t  ++_M_current;\n+\t  return;\n+\t}\n       else if (__c == _M_ctype.widen('*'))\n-      {\n-\t_M_curToken = _S_token_closure0;\n-\t++_M_current;\n-\treturn;\n-      }\n+\t{\n+\t  _M_curToken = _S_token_closure0;\n+\t  ++_M_current;\n+\t  return;\n+\t}\n       else if (__c == _M_ctype.widen('+'))\n-      {\n-\t_M_curToken = _S_token_closure1;\n-\t++_M_current;\n-\treturn;\n-      }\n-      else if (__c == _M_ctype.widen('|'))\n-      {\n-\t_M_curToken = _S_token_or;\n-\t++_M_current;\n-\treturn;\n-      }\n-      else if (__c == _M_ctype.widen('['))\n-      {\n-\t_M_curToken = _S_token_bracket_begin;\n-\t_M_state |= (_S_state_in_bracket | _S_state_at_start);\n-\t++_M_current;\n-\treturn;\n-      }\n-      else if (__c == _M_ctype.widen('\\\\'))\n-      {\n-\t_M_eat_escape();\n-\treturn;\n-      }\n-      else if (!(_M_flags & (regex_constants::basic | regex_constants::grep)))\n-      {\n-\tif (__c == _M_ctype.widen('('))\n \t{\n-\t  _M_curToken = _S_token_subexpr_begin;\n+\t  _M_curToken = _S_token_closure1;\n \t  ++_M_current;\n \t  return;\n \t}\n-\telse if (__c == _M_ctype.widen(')'))\n+      else if (__c == _M_ctype.widen('|'))\n \t{\n-\t  _M_curToken = _S_token_subexpr_end;\n+\t  _M_curToken = _S_token_or;\n \t  ++_M_current;\n \t  return;\n \t}\n-\telse if (__c == _M_ctype.widen('{'))\n+      else if (__c == _M_ctype.widen('['))\n \t{\n-\t  _M_curToken = _S_token_interval_begin;\n-\t  _M_state |= _S_state_in_brace;\n+\t  _M_curToken = _S_token_bracket_begin;\n+\t  _M_state |= (_S_state_in_bracket | _S_state_at_start);\n \t  ++_M_current;\n \t  return;\n \t}\n-      }\n+      else if (__c == _M_ctype.widen('\\\\'))\n+\t{\n+\t  _M_eat_escape();\n+\t  return;\n+\t}\n+      else if (!(_M_flags & (regex_constants::basic | regex_constants::grep)))\n+\t{\n+\t  if (__c == _M_ctype.widen('('))\n+\t    {\n+\t      _M_curToken = _S_token_subexpr_begin;\n+\t      ++_M_current;\n+\t      return;\n+\t    }\n+\t  else if (__c == _M_ctype.widen(')'))\n+\t    {\n+\t      _M_curToken = _S_token_subexpr_end;\n+\t      ++_M_current;\n+\t      return;\n+\t    }\n+\t  else if (__c == _M_ctype.widen('{'))\n+\t    {\n+\t      _M_curToken = _S_token_interval_begin;\n+\t      _M_state |= _S_state_in_brace;\n+\t      ++_M_current;\n+\t      return;\n+\t    }\n+\t}\n \n       _M_curToken = _S_token_ord_char;\n       _M_curValue.assign(1, __c);\n@@ -252,38 +253,39 @@ namespace __regex\n     _M_scan_in_brace()\n     {\n       if (_M_ctype.is(_CtypeT::digit, *_M_current))\n-      {\n-\t_M_curToken = _S_token_dup_count;\n-\t_M_curValue.assign(1, *_M_current);\n-\t++_M_current;\n-\twhile (_M_current != _M_end && _M_ctype.is(_CtypeT::digit, *_M_current))\n \t{\n-\t  _M_curValue += *_M_current;\n+\t  _M_curToken = _S_token_dup_count;\n+\t  _M_curValue.assign(1, *_M_current);\n \t  ++_M_current;\n+\t  while (_M_current != _M_end\n+\t\t && _M_ctype.is(_CtypeT::digit, *_M_current))\n+\t    {\n+\t      _M_curValue += *_M_current;\n+\t      ++_M_current;\n+\t    }\n+\t  return;\n \t}\n-\treturn;\n-      }\n       else if (*_M_current == _M_ctype.widen(','))\n-      {\n-\t_M_curToken = _S_token_comma;\n-\t++_M_current;\n-\treturn;\n-      }\n-      if (_M_flags & (regex_constants::basic | regex_constants::grep))\n-      {\n-\tif (*_M_current == _M_ctype.widen('\\\\'))\n-\t{ _M_eat_escape(); }\n-      }\n-      else \n-      {\n-\tif (*_M_current == _M_ctype.widen('}'))\n \t{\n-\t  _M_curToken = _S_token_interval_end;\n-\t  _M_state &= ~_S_state_in_brace;\n+\t  _M_curToken = _S_token_comma;\n \t  ++_M_current;\n \t  return;\n \t}\n-      }\n+      if (_M_flags & (regex_constants::basic | regex_constants::grep))\n+\t{\n+\t  if (*_M_current == _M_ctype.widen('\\\\'))\n+\t    _M_eat_escape();\n+\t}\n+      else \n+\t{\n+\t  if (*_M_current == _M_ctype.widen('}'))\n+\t    {\n+\t      _M_curToken = _S_token_interval_end;\n+\t      _M_state &= ~_S_state_in_brace;\n+\t      ++_M_current;\n+\t      return;\n+\t    }\n+\t}\n     }\n \n   template<typename _InputIterator>\n@@ -292,58 +294,58 @@ namespace __regex\n     _M_scan_in_bracket()\n     {\n       if (_M_state & _S_state_at_start && *_M_current == _M_ctype.widen('^'))\n-      {\n-\t_M_curToken = _S_token_inverse_class;\n-\t_M_state &= ~_S_state_at_start;\n-\t++_M_current;\n-\treturn;\n-      }\n-      else if (*_M_current == _M_ctype.widen('['))\n-      {\n-\t++_M_current;\n-\tif (_M_current == _M_end)\n-\t{\n-\t  _M_curToken = _S_token_eof;\n-\t  return;\n-\t}\n-\n-\tif (*_M_current == _M_ctype.widen('.'))\n \t{\n-\t  _M_curToken = _S_token_collsymbol;\n-\t  _M_eat_collsymbol();\n+\t  _M_curToken = _S_token_inverse_class;\n+\t  _M_state &= ~_S_state_at_start;\n+\t  ++_M_current;\n \t  return;\n \t}\n-\telse if (*_M_current == _M_ctype.widen(':'))\n+      else if (*_M_current == _M_ctype.widen('['))\n \t{\n-\t  _M_curToken = _S_token_char_class_name;\n-\t  _M_eat_charclass();\n-\t  return;\n+\t  ++_M_current;\n+\t  if (_M_current == _M_end)\n+\t    {\n+\t      _M_curToken = _S_token_eof;\n+\t      return;\n+\t    }\n+\n+\t  if (*_M_current == _M_ctype.widen('.'))\n+\t    {\n+\t      _M_curToken = _S_token_collsymbol;\n+\t      _M_eat_collsymbol();\n+\t      return;\n+\t    }\n+\t  else if (*_M_current == _M_ctype.widen(':'))\n+\t    {\n+\t      _M_curToken = _S_token_char_class_name;\n+\t      _M_eat_charclass();\n+\t      return;\n+\t    }\n+\t  else if (*_M_current == _M_ctype.widen('='))\n+\t    {\n+\t      _M_curToken = _S_token_equiv_class_name;\n+\t      _M_eat_equivclass();\n+\t      return;\n+\t    }\n \t}\n-\telse if (*_M_current == _M_ctype.widen('='))\n+      else if (*_M_current == _M_ctype.widen('-'))\n \t{\n-\t  _M_curToken = _S_token_equiv_class_name;\n-\t  _M_eat_equivclass();\n+\t  _M_curToken = _S_token_dash;\n+\t  ++_M_current;\n \t  return;\n \t}\n-      }\n-      else if (*_M_current == _M_ctype.widen('-'))\n-      {\n-\t_M_curToken = _S_token_dash;\n-\t++_M_current;\n-\treturn;\n-      }\n       else if (*_M_current == _M_ctype.widen(']'))\n-      {\n-\tif (!(_M_flags & regex_constants::ECMAScript)\n-\t || !(_M_state & _S_state_at_start))\n \t{\n-\t  // special case: only if  _not_ chr first after '[' or '[^' and if not\n-\t  // ECMAscript\n-\t  _M_curToken = _S_token_bracket_end;\n-\t  ++_M_current;\n-\t  return;\n+\t  if (!(_M_flags & regex_constants::ECMAScript)\n+\t      || !(_M_state & _S_state_at_start))\n+\t    {\n+\t      // special case: only if  _not_ chr first after\n+\t      // '[' or '[^' and if not ECMAscript\n+\t      _M_curToken = _S_token_bracket_end;\n+\t      ++_M_current;\n+\t      return;\n+\t    }\n \t}\n-      }\n       _M_curToken = _S_token_collelem_single;\n       _M_curValue.assign(1, *_M_current);\n       ++_M_current;\n@@ -356,108 +358,102 @@ namespace __regex\n     {\n       ++_M_current;\n       if (_M_current == _M_end)\n-      {\n-\t_M_curToken = _S_token_eof;\n-\treturn;\n-      }\n+\t{\n+\t  _M_curToken = _S_token_eof;\n+\t  return;\n+\t}\n       _CharT __c = *_M_current;\n       ++_M_current;\n \n       if (__c == _M_ctype.widen('('))\n-      {\n-\tif (!(_M_flags & (regex_constants::basic | regex_constants::grep)))\n \t{\n-\t  _M_curToken = _S_token_ord_char;\n-\t  _M_curValue.assign(1, __c);\n-\t}\n-\telse\n-\t{\n-\t  _M_curToken = _S_token_subexpr_begin;\n+\t  if (!(_M_flags & (regex_constants::basic | regex_constants::grep)))\n+\t    {\n+\t      _M_curToken = _S_token_ord_char;\n+\t      _M_curValue.assign(1, __c);\n+\t    }\n+\t  else\n+\t    _M_curToken = _S_token_subexpr_begin;\n \t}\n-      }\n       else if (__c == _M_ctype.widen(')'))\n-      {\n-\tif (!(_M_flags & (regex_constants::basic | regex_constants::grep)))\n-\t{\n-\t  _M_curToken = _S_token_ord_char;\n-\t  _M_curValue.assign(1, __c);\n-\t}\n-\telse\n \t{\n-\t  _M_curToken = _S_token_subexpr_end;\n+\t  if (!(_M_flags & (regex_constants::basic | regex_constants::grep)))\n+\t    {\n+\t      _M_curToken = _S_token_ord_char;\n+\t      _M_curValue.assign(1, __c);\n+\t    }\n+\t  else\n+\t    _M_curToken = _S_token_subexpr_end;\n \t}\n-      }\n       else if (__c == _M_ctype.widen('{'))\n-      {\n-\tif (!(_M_flags & (regex_constants::basic | regex_constants::grep)))\n \t{\n-\t  _M_curToken = _S_token_ord_char;\n-\t  _M_curValue.assign(1, __c);\n-\t}\n-\telse\n-\t{\n-\t  _M_curToken = _S_token_interval_begin;\n-\t  _M_state |= _S_state_in_brace;\n+\t  if (!(_M_flags & (regex_constants::basic | regex_constants::grep)))\n+\t    {\n+\t      _M_curToken = _S_token_ord_char;\n+\t      _M_curValue.assign(1, __c);\n+\t    }\n+\t  else\n+\t    {\n+\t      _M_curToken = _S_token_interval_begin;\n+\t      _M_state |= _S_state_in_brace;\n+\t    }\n \t}\n-      }\n       else if (__c == _M_ctype.widen('}'))\n-      {\n-\tif (!(_M_flags & (regex_constants::basic | regex_constants::grep)))\n-\t{\n-\t  _M_curToken = _S_token_ord_char;\n-\t  _M_curValue.assign(1, __c);\n-\t}\n-\telse\n \t{\n-\t  if (!(_M_state && _S_state_in_brace))\n-\t    __throw_regex_error(regex_constants::error_badbrace);\n-\t  _M_state &= ~_S_state_in_brace;\n-\t  _M_curToken = _S_token_interval_end;\n+\t  if (!(_M_flags & (regex_constants::basic | regex_constants::grep)))\n+\t    {\n+\t      _M_curToken = _S_token_ord_char;\n+\t      _M_curValue.assign(1, __c);\n+\t    }\n+\t  else\n+\t    {\n+\t      if (!(_M_state && _S_state_in_brace))\n+\t\t__throw_regex_error(regex_constants::error_badbrace);\n+\t      _M_state &= ~_S_state_in_brace;\n+\t      _M_curToken = _S_token_interval_end;\n+\t    }\n \t}\n-      }\n       else if (__c == _M_ctype.widen('x'))\n-      {\n-\t++_M_current;\n-\tif (_M_current == _M_end)\n \t{\n-\t  _M_curToken = _S_token_eof;\n-\t  return;\n-\t}\n-\tif (_M_ctype.is(_CtypeT::digit, *_M_current))\n-\t{\n-\t  _M_curValue.assign(1, *_M_current);\n \t  ++_M_current;\n \t  if (_M_current == _M_end)\n-\t  {\n-\t    _M_curToken = _S_token_eof;\n-\t    return;\n-\t  }\n+\t    {\n+\t      _M_curToken = _S_token_eof;\n+\t      return;\n+\t    }\n \t  if (_M_ctype.is(_CtypeT::digit, *_M_current))\n-\t  {\n-\t    _M_curValue += *_M_current;\n-\t    ++_M_current;\n-\t    return;\n-\t  }\n+\t    {\n+\t      _M_curValue.assign(1, *_M_current);\n+\t      ++_M_current;\n+\t      if (_M_current == _M_end)\n+\t\t{\n+\t\t  _M_curToken = _S_token_eof;\n+\t\t  return;\n+\t\t}\n+\t      if (_M_ctype.is(_CtypeT::digit, *_M_current))\n+\t\t{\n+\t\t  _M_curValue += *_M_current;\n+\t\t  ++_M_current;\n+\t\t  return;\n+\t\t}\n+\t    }\n \t}\n-      }\n       else if (__c == _M_ctype.widen('^')\n-\t    || __c == _M_ctype.widen('.')\n-\t    || __c == _M_ctype.widen('*')\n-\t    || __c == _M_ctype.widen('$')\n-\t    || __c == _M_ctype.widen('\\\\'))\n-      {\n-\t_M_curToken = _S_token_ord_char;\n-\t_M_curValue.assign(1, __c);\n-      }\n+\t       || __c == _M_ctype.widen('.')\n+\t       || __c == _M_ctype.widen('*')\n+\t       || __c == _M_ctype.widen('$')\n+\t       || __c == _M_ctype.widen('\\\\'))\n+\t{\n+\t  _M_curToken = _S_token_ord_char;\n+\t  _M_curValue.assign(1, __c);\n+\t}\n       else if (_M_ctype.is(_CtypeT::digit, __c))\n-      {\n-\t_M_curToken = _S_token_backref;\n-\t_M_curValue.assign(1, __c);\n-      }\n+\t{\n+\t  _M_curToken = _S_token_backref;\n+\t  _M_curValue.assign(1, __c);\n+\t}\n       else\n-      {\n \t__throw_regex_error(regex_constants::error_escape);\n-      }\n     }\n \n \n@@ -534,89 +530,89 @@ namespace __regex\n       switch (_M_curToken)\n       {\n \tcase _S_token_anychar:\n-\t\tostr << \"any-character\\n\";\n-\t\tbreak;\n+\t  ostr << \"any-character\\n\";\n+\t  break;\n \tcase _S_token_backref:\n-\t\tostr << \"backref\\n\";\n-\t\tbreak;\n+\t  ostr << \"backref\\n\";\n+\t  break;\n \tcase _S_token_bracket_begin:\n-\t\tostr << \"bracket-begin\\n\";\n-\t\tbreak;\n+\t  ostr << \"bracket-begin\\n\";\n+\t  break;\n \tcase _S_token_bracket_end:\n-\t\tostr << \"bracket-end\\n\";\n-\t\tbreak;\n+\t  ostr << \"bracket-end\\n\";\n+\t  break;\n \tcase _S_token_char_class_name:\n-\t\tostr << \"char-class-name \\\"\" << _M_curValue << \"\\\"\\n\";\n-\t\tbreak;\n+\t  ostr << \"char-class-name \\\"\" << _M_curValue << \"\\\"\\n\";\n+\t  break;\n \tcase _S_token_closure0:\n-\t\tostr << \"closure0\\n\";\n-\t\tbreak;\n+\t  ostr << \"closure0\\n\";\n+\t  break;\n \tcase _S_token_closure1:\n-\t\tostr << \"closure1\\n\";\n-\t\tbreak;\n+\t  ostr << \"closure1\\n\";\n+\t  break;\n \tcase _S_token_collelem_multi:\n-\t\tostr << \"coll-elem-multi \\\"\" << _M_curValue << \"\\\"\\n\";\n-\t\tbreak;\n+\t  ostr << \"coll-elem-multi \\\"\" << _M_curValue << \"\\\"\\n\";\n+\t  break;\n \tcase _S_token_collelem_single:\n-\t\tostr << \"coll-elem-single \\\"\" << _M_curValue << \"\\\"\\n\";\n-\t\tbreak;\n+\t  ostr << \"coll-elem-single \\\"\" << _M_curValue << \"\\\"\\n\";\n+\t  break;\n \tcase _S_token_collsymbol:\n-\t\tostr << \"collsymbol \\\"\" << _M_curValue << \"\\\"\\n\";\n-\t\tbreak;\n+\t  ostr << \"collsymbol \\\"\" << _M_curValue << \"\\\"\\n\";\n+\t  break;\n \tcase _S_token_comma:\n-\t\tostr << \"comma\\n\";\n-\t\tbreak;\n+\t  ostr << \"comma\\n\";\n+\t  break;\n \tcase _S_token_dash:\n-\t\tostr << \"dash\\n\";\n-\t\tbreak;\n+\t  ostr << \"dash\\n\";\n+\t  break;\n \tcase _S_token_dup_count:\n-\t\tostr << \"dup count: \" << _M_curValue << \"\\n\";\n-\t\tbreak;\n+\t  ostr << \"dup count: \" << _M_curValue << \"\\n\";\n+\t  break;\n \tcase _S_token_eof:\n-\t\tostr << \"EOF\\n\";\n-\t\tbreak;\n+\t  ostr << \"EOF\\n\";\n+\t  break;\n \tcase _S_token_equiv_class_name:\n-\t\tostr << \"equiv-class-name \\\"\" << _M_curValue << \"\\\"\\n\";\n-\t\tbreak;\n+\t  ostr << \"equiv-class-name \\\"\" << _M_curValue << \"\\\"\\n\";\n+\t  break;\n \tcase _S_token_interval_begin:\n-\t\tostr << \"interval begin\\n\";\n-\t\tbreak;\n+\t  ostr << \"interval begin\\n\";\n+\t  break;\n \tcase _S_token_interval_end:\n-\t\tostr << \"interval end\\n\";\n-\t\tbreak;\n+\t  ostr << \"interval end\\n\";\n+\t  break;\n \tcase _S_token_line_begin:\n-\t\tostr << \"line begin\\n\";\n-\t\tbreak;\n+\t  ostr << \"line begin\\n\";\n+\t  break;\n \tcase _S_token_line_end:\n-\t\tostr << \"line end\\n\";\n-\t\tbreak;\n+\t  ostr << \"line end\\n\";\n+\t  break;\n \tcase _S_token_opt:\n-\t\tostr << \"opt\\n\";\n-\t\tbreak;\n+\t  ostr << \"opt\\n\";\n+\t  break;\n \tcase _S_token_or:\n-\t\tostr << \"or\\n\";\n-\t\tbreak;\n+\t  ostr << \"or\\n\";\n+\t  break;\n \tcase _S_token_ord_char:\n-\t\tostr << \"ordinary character: \\\"\" << _M_value() << \"\\\"\\n\";\n-\t\tbreak;\n+\t  ostr << \"ordinary character: \\\"\" << _M_value() << \"\\\"\\n\";\n+\t  break;\n \tcase _S_token_quoted_char:\n-\t\tostr << \"quoted char\\n\";\n-\t\tbreak;\n+\t  ostr << \"quoted char\\n\";\n+\t  break;\n \tcase _S_token_subexpr_begin:\n-\t\tostr << \"subexpr begin\\n\";\n-\t\tbreak;\n+\t  ostr << \"subexpr begin\\n\";\n+\t  break;\n \tcase _S_token_subexpr_end:\n-\t\tostr << \"subexpr end\\n\";\n-\t\tbreak;\n+\t  ostr << \"subexpr end\\n\";\n+\t  break;\n \tcase _S_token_word_begin:\n-\t\tostr << \"word begin\\n\";\n-\t\tbreak;\n+\t  ostr << \"word begin\\n\";\n+\t  break;\n \tcase _S_token_word_end:\n-\t\tostr << \"word end\\n\";\n-\t\tbreak;\n+\t  ostr << \"word end\\n\";\n+\t  break;\n \tcase _S_token_unknown:\n-\t\tostr << \"-- unknown token --\\n\";\n-\t\tbreak;\n+\t  ostr << \"-- unknown token --\\n\";\n+\t  break;\n       }\n       return ostr;\n     }\n@@ -648,7 +644,7 @@ namespace __regex\n \n       // accepts a specific token or returns false.\n       bool\n-      _M_match_token(_TokenT token);\n+      _M_match_token(_TokenT __token);\n \n       void\n       _M_disjunction();\n@@ -727,12 +723,12 @@ namespace __regex\n                         bind(_Start(0), _1, _2)));\n       _M_disjunction();\n       if (!_M_stack.empty())\n-      {\n-\t__r._M_append(_M_stack.top());\n-\t_M_stack.pop();\n-      }\n-      __r._M_append(_M_state_store._M_insert_subexpr_end(0,\n-                        bind(_End(0), _1, _2)));\n+\t{\n+\t  __r._M_append(_M_stack.top());\n+\t  _M_stack.pop();\n+\t}\n+      __r._M_append(_M_state_store.\n+\t\t    _M_insert_subexpr_end(0, bind(_End(0), _1, _2)));\n       __r._M_append(_M_state_store._M_insert_accept());\n     }\n \n@@ -742,11 +738,11 @@ namespace __regex\n     _M_match_token(_Compiler<_InIter, _TraitsT>::_TokenT token)\n     { \n       if (token == _M_scanner._M_token())\n-      {\n-\t_M_cur_value = _M_scanner._M_value();\n-\t_M_scanner._M_advance();\n-\treturn true;\n-      }\n+\t{\n+\t  _M_cur_value = _M_scanner._M_value();\n+\t  _M_scanner._M_advance();\n+\t  return true;\n+\t}\n       return false;\n     }\n \n@@ -757,12 +753,12 @@ namespace __regex\n     {\n       this->_M_alternative();\n       if (_M_match_token(_ScannerT::_S_token_or))\n-      {\n-\t_StateSeq __alt1 = _M_stack.top(); _M_stack.pop();\n-\tthis->_M_disjunction();\n-\t_StateSeq __alt2 = _M_stack.top(); _M_stack.pop();\n-\t_M_stack.push(_StateSeq(__alt1, __alt2));\n-      }\n+\t{\n+\t  _StateSeq __alt1 = _M_stack.top(); _M_stack.pop();\n+\t  this->_M_disjunction();\n+\t  _StateSeq __alt2 = _M_stack.top(); _M_stack.pop();\n+\t  _M_stack.push(_StateSeq(__alt1, __alt2));\n+\t}\n     }\n \n   template<typename _InIter, typename _TraitsT>\n@@ -771,17 +767,17 @@ namespace __regex\n     _M_alternative()\n     {\n       if (this->_M_term())\n-      {\n-\t_StateSeq __re = _M_stack.top(); _M_stack.pop();\n-\tthis->_M_alternative();\n-\tif (!_M_stack.empty())\n \t{\n-\t  __re._M_append(_M_stack.top());\n-\t  _M_stack.pop();\n+\t  _StateSeq __re = _M_stack.top(); _M_stack.pop();\n+\t  this->_M_alternative();\n+\t  if (!_M_stack.empty())\n+\t    {\n+\t      __re._M_append(_M_stack.top());\n+\t      _M_stack.pop();\n+\t    }\n+\t  _M_stack.push(__re);\n+\t  return true;\n \t}\n-\t_M_stack.push(__re);\n-\treturn true;\n-      }\n       return false;\n     }\n \n@@ -793,10 +789,10 @@ namespace __regex\n       if (this->_M_assertion())\n \treturn true;\n       if (this->_M_atom())\n-      {\n-\tthis->_M_quantifier();\n-\treturn true;\n-      }\n+\t{\n+\t  this->_M_quantifier();\n+\t  return true;\n+\t}\n       return false;\n     }\n \n@@ -806,25 +802,25 @@ namespace __regex\n     _M_assertion()\n     {\n       if (_M_match_token(_ScannerT::_S_token_line_begin))\n-      {\n-\t// __m.push(_Matcher::_S_opcode_line_begin);\n-\treturn true;\n-      }\n+\t{\n+\t  // __m.push(_Matcher::_S_opcode_line_begin);\n+\t  return true;\n+\t}\n       if (_M_match_token(_ScannerT::_S_token_line_end))\n-      {\n-\t// __m.push(_Matcher::_S_opcode_line_end);\n-\treturn true;\n-      }\n+\t{\n+\t  // __m.push(_Matcher::_S_opcode_line_end);\n+\t  return true;\n+\t}\n       if (_M_match_token(_ScannerT::_S_token_word_begin))\n-      {\n-\t// __m.push(_Matcher::_S_opcode_word_begin);\n-\treturn true;\n-      }\n+\t{\n+\t  // __m.push(_Matcher::_S_opcode_word_begin);\n+\t  return true;\n+\t}\n       if (_M_match_token(_ScannerT::_S_token_word_end))\n-      {\n-\t// __m.push(_Matcher::_S_opcode_word_end);\n-\treturn true;\n-      }\n+\t{\n+\t  // __m.push(_Matcher::_S_opcode_word_end);\n+\t  return true;\n+\t}\n       return false;\n     }\n \n@@ -834,69 +830,71 @@ namespace __regex\n     _M_quantifier()\n     {\n       if (_M_match_token(_ScannerT::_S_token_closure0))\n-      {\n-\tif (_M_stack.empty())\n-\t  __throw_regex_error(regex_constants::error_badrepeat);\n-\t_StateSeq __r(_M_stack.top(), -1);\n-\t__r._M_append(__r._M_front());\n-\t_M_stack.pop();\n-\t_M_stack.push(__r);\n-\treturn true;\n-      }\n+\t{\n+\t  if (_M_stack.empty())\n+\t    __throw_regex_error(regex_constants::error_badrepeat);\n+\t  _StateSeq __r(_M_stack.top(), -1);\n+\t  __r._M_append(__r._M_front());\n+\t  _M_stack.pop();\n+\t  _M_stack.push(__r);\n+\t  return true;\n+\t}\n       if (_M_match_token(_ScannerT::_S_token_closure1))\n-      {\n-\tif (_M_stack.empty())\n-\t  __throw_regex_error(regex_constants::error_badrepeat);\n-\t_StateSeq __r(_M_state_store,\n-\t\t       _M_state_store._M_insert_alt(_S_invalid_state_id,\n-\t\t\t\t\t    _M_stack.top()._M_front()));\n-\t_M_stack.top()._M_append(__r);\n-\treturn true;\n-      }\n+\t{\n+\t  if (_M_stack.empty())\n+\t    __throw_regex_error(regex_constants::error_badrepeat);\n+\t  _StateSeq __r(_M_state_store,\n+\t\t\t_M_state_store.\n+\t\t\t_M_insert_alt(_S_invalid_state_id,\n+\t\t\t\t      _M_stack.top()._M_front()));\n+\t  _M_stack.top()._M_append(__r);\n+\t  return true;\n+\t}\n       if (_M_match_token(_ScannerT::_S_token_opt))\n-      {\n-\tif (_M_stack.empty())\n+\t{\n+\t  if (_M_stack.empty())\n \t  __throw_regex_error(regex_constants::error_badrepeat);\n-\t_StateSeq __r(_M_stack.top(), -1);\n-\t_M_stack.pop();\n-\t_M_stack.push(__r);\n-\treturn true;\n-      }\n+\t  _StateSeq __r(_M_stack.top(), -1);\n+\t  _M_stack.pop();\n+\t  _M_stack.push(__r);\n+\t  return true;\n+\t}\n       if (_M_match_token(_ScannerT::_S_token_interval_begin))\n-      {\n-\tif (_M_stack.empty())\n-\t  __throw_regex_error(regex_constants::error_badrepeat);\n-\tif (!_M_match_token(_ScannerT::_S_token_dup_count))\n-\t  __throw_regex_error(regex_constants::error_badbrace);\n-\t_StateSeq __r(_M_stack.top());\n-\tint __min_rep = _M_cur_int_value(10);\n-\tfor (int __i = 1; __i < __min_rep; ++__i)\n-\t  _M_stack.top()._M_append(__r._M_clone()); \n-\tif (_M_match_token(_ScannerT::_S_token_comma))\n-\t  if (_M_match_token(_ScannerT::_S_token_dup_count))\n-\t  {\n-\t    int __n = _M_cur_int_value(10) - __min_rep;\n-\t    if (__n < 0)\n-\t      __throw_regex_error(regex_constants::error_badbrace);\n-\t    for (int __i = 0; __i < __n; ++__i)\n-\t    {\n-\t      _StateSeq __r(_M_state_store,\n-\t\t\t    _M_state_store._M_insert_alt(_S_invalid_state_id,\n-\t\t\t\t\t\t  _M_stack.top()._M_front()));\n-\t      _M_stack.top()._M_append(__r);\n-\t    }\n-\t  }\n-\t  else\n-\t  {\n-\t    _StateSeq __r(_M_stack.top(), -1);\n-\t    __r._M_push_back(__r._M_front());\n-\t    _M_stack.pop();\n-\t    _M_stack.push(__r);\n-\t  }\n-\tif (!_M_match_token(_ScannerT::_S_token_interval_end))\n-\t  __throw_regex_error(regex_constants::error_brace);\n-\treturn true;\n-      }\n+\t{\n+\t  if (_M_stack.empty())\n+\t    __throw_regex_error(regex_constants::error_badrepeat);\n+\t  if (!_M_match_token(_ScannerT::_S_token_dup_count))\n+\t    __throw_regex_error(regex_constants::error_badbrace);\n+\t  _StateSeq __r(_M_stack.top());\n+\t  int __min_rep = _M_cur_int_value(10);\n+\t  for (int __i = 1; __i < __min_rep; ++__i)\n+\t    _M_stack.top()._M_append(__r._M_clone()); \n+\t  if (_M_match_token(_ScannerT::_S_token_comma))\n+\t    if (_M_match_token(_ScannerT::_S_token_dup_count))\n+\t      {\n+\t\tint __n = _M_cur_int_value(10) - __min_rep;\n+\t\tif (__n < 0)\n+\t\t  __throw_regex_error(regex_constants::error_badbrace);\n+\t\tfor (int __i = 0; __i < __n; ++__i)\n+\t\t  {\n+\t\t    _StateSeq __r(_M_state_store,\n+\t\t\t\t  _M_state_store.\n+\t\t\t\t  _M_insert_alt(_S_invalid_state_id,\n+\t\t\t\t\t\t_M_stack.top()._M_front()));\n+\t\t    _M_stack.top()._M_append(__r);\n+\t\t  }\n+\t      }\n+\t    else\n+\t      {\n+\t\t_StateSeq __r(_M_stack.top(), -1);\n+\t\t__r._M_push_back(__r._M_front());\n+\t\t_M_stack.pop();\n+\t\t_M_stack.push(__r);\n+\t      }\n+\t  if (!_M_match_token(_ScannerT::_S_token_interval_end))\n+\t    __throw_regex_error(regex_constants::error_brace);\n+\t  return true;\n+\t}\n       return false;\n     }\n \n@@ -913,49 +911,54 @@ namespace __regex\n       typedef _EndTagger<_InIter, _TraitsT> _End;\n \n       if (_M_match_token(_ScannerT::_S_token_anychar))\n-      {\n-\t_M_stack.push(_StateSeq(_M_state_store,\n-\t     _M_state_store._M_insert_matcher(bind(_AnyMatcher, _1))));\n-\treturn true;\n-      }\n+\t{\n+\t  _M_stack.push(_StateSeq(_M_state_store,\n+\t\t\t\t  _M_state_store.\n+\t\t\t\t  _M_insert_matcher(bind(_AnyMatcher, _1))));\n+\t  return true;\n+\t}\n       if (_M_match_token(_ScannerT::_S_token_ord_char))\n-      {\n-\t_M_stack.push(_StateSeq(_M_state_store,\n-\t                        _M_state_store._M_insert_matcher(\n-\t                        bind(_CMatcher(_M_cur_value[0], _M_traits), _1))));\n-\treturn true;\n-      }\n+\t{\n+\t  _M_stack.push(_StateSeq\n+\t\t\t(_M_state_store, _M_state_store. \n+\t\t\t _M_insert_matcher\n+\t\t\t (bind(_CMatcher(_M_cur_value[0], _M_traits), _1))));\n+\t  return true;\n+\t}\n       if (_M_match_token(_ScannerT::_S_token_quoted_char))\n-      {\n-\t// note that in the ECMA grammar, this case covers backrefs.\n-\t_M_stack.push(_StateSeq(_M_state_store,\n-\t                        _M_state_store._M_insert_matcher(\n-\t                        bind(_CMatcher(_M_cur_value[0], _M_traits), _1))));\n-\treturn true;\n-      }\n+\t{\n+\t  // note that in the ECMA grammar, this case covers backrefs.\n+\t  _M_stack.push(_StateSeq(_M_state_store,\n+\t\t\t\t  _M_state_store.\n+\t\t\t\t  _M_insert_matcher\n+\t\t\t\t  (bind(_CMatcher(_M_cur_value[0], _M_traits),\n+\t\t\t\t\t_1))));\n+\t  return true;\n+\t}\n       if (_M_match_token(_ScannerT::_S_token_backref))\n-      {\n-\t// __m.push(_Matcher::_S_opcode_ordchar, _M_cur_value);\n-\treturn true;\n-      }\n+\t{\n+\t  // __m.push(_Matcher::_S_opcode_ordchar, _M_cur_value);\n+\t  return true;\n+\t}\n       if (_M_match_token(_ScannerT::_S_token_subexpr_begin))\n-      {\n-\tint __mark = _M_state_store._M_sub_count();\n-\t_StateSeq __r(_M_state_store,\n-\t\t      _M_state_store._M_insert_subexpr_begin(bind(_Start(__mark), _1, _2)));\n-\tthis->_M_disjunction();\n-\tif (!_M_match_token(_ScannerT::_S_token_subexpr_end))\n-\t  __throw_regex_error(regex_constants::error_paren);\n-\tif (!_M_stack.empty())\n \t{\n-\t  __r._M_append(_M_stack.top());\n-\t  _M_stack.pop();\n+\t  int __mark = _M_state_store._M_sub_count();\n+\t  _StateSeq __r(_M_state_store,\n+\t\t\t_M_state_store.\n+\t\t\t_M_insert_subexpr_begin(bind(_Start(__mark), _1, _2)));\n+\t  this->_M_disjunction();\n+\t  if (!_M_match_token(_ScannerT::_S_token_subexpr_end))\n+\t    __throw_regex_error(regex_constants::error_paren);\n+\t  if (!_M_stack.empty())\n+\t    {\n+\t      __r._M_append(_M_stack.top());\n+\t      _M_stack.pop();\n+\t    }\n+\t  __r._M_append(_M_state_store._M_insert_subexpr_end\n+\t\t\t(__mark, bind(_End(__mark), _1, _2)));\n+\t  _M_stack.push(__r);\n+\t  return true;\n \t}\n-\t__r._M_append(_M_state_store._M_insert_subexpr_end(__mark,\n-\t                  bind(_End(__mark), _1, _2)));\n-\t_M_stack.push(__r);\n-\treturn true;\n-      }\n       return _M_bracket_expression();\n     }\n \n@@ -967,17 +970,17 @@ namespace __regex\n       using std::bind;\n       using std::placeholders::_1;\n       if (_M_match_token(_ScannerT::_S_token_bracket_begin))\n-      {\n-\t_RMatcherT __matcher(_M_match_token(_ScannerT::_S_token_line_begin),\n-\t                     _M_traits);\n-\tif (!_M_bracket_list(__matcher)\n-\t || !_M_match_token(_ScannerT::_S_token_bracket_end))\n-\t  __throw_regex_error(regex_constants::error_brack);\n-\t_M_stack.push(_StateSeq(_M_state_store,\n-\t                        _M_state_store._M_insert_matcher(\n-\t                            bind(__matcher, _1))));\n-\treturn true;\n-      }\n+\t{\n+\t  _RMatcherT __matcher(_M_match_token(_ScannerT::_S_token_line_begin),\n+\t\t\t       _M_traits);\n+\t  if (!_M_bracket_list(__matcher)\n+\t      || !_M_match_token(_ScannerT::_S_token_bracket_end))\n+\t    __throw_regex_error(regex_constants::error_brack);\n+\t  _M_stack.push(_StateSeq(_M_state_store,\n+\t\t\t\t  _M_state_store._M_insert_matcher\n+\t\t\t\t  (bind(__matcher, _1))));\n+\t  return true;\n+\t}\n       return false;\n     }\n \n@@ -989,11 +992,11 @@ namespace __regex\n     _M_bracket_list(_RMatcherT& __matcher)\n     {\n       if (_M_follow_list(__matcher))\n-      {\n-\tif (_M_match_token(_ScannerT::_S_token_dash))\n-\t  __matcher._M_add_char(_M_cur_value[0]);\n-\treturn true;\n-      }\n+\t{\n+\t  if (_M_match_token(_ScannerT::_S_token_dash))\n+\t    __matcher._M_add_char(_M_cur_value[0]);\n+\t  return true;\n+\t}\n       return false;\n     }\n \n@@ -1018,10 +1021,11 @@ namespace __regex\n     _Compiler<_InIter, _TraitsT>::\n     _M_expression_term(_RMatcherT& __matcher)\n     {\n-      return _M_collating_symbol(__matcher)\n-\t  || _M_character_class(__matcher)\n-\t  || _M_equivalence_class(__matcher)\n-\t  || (_M_start_range(__matcher) && _M_range_expression(__matcher));\n+      return (_M_collating_symbol(__matcher)\n+\t      || _M_character_class(__matcher)\n+\t      || _M_equivalence_class(__matcher)\n+\t      || (_M_start_range(__matcher)\n+\t\t  && _M_range_expression(__matcher)));\n     }\n \n   template<typename _InIter, typename _TraitsT>\n@@ -1048,15 +1052,15 @@ namespace __regex\n     _M_collating_symbol(_RMatcherT& __matcher)\n     {\n       if (_M_match_token(_ScannerT::_S_token_collelem_single))\n-      {\n-\t__matcher._M_add_char(_M_cur_value[0]);\n-\treturn true;\n-      }\n+\t{\n+\t  __matcher._M_add_char(_M_cur_value[0]);\n+\t  return true;\n+\t}\n       if (_M_match_token(_ScannerT::_S_token_collsymbol))\n-      {\n-\t__matcher._M_add_collating_element(_M_cur_value);\n-\treturn true;\n-      }\n+\t{\n+\t  __matcher._M_add_collating_element(_M_cur_value);\n+\t  return true;\n+\t}\n       return false;\n     }\n \n@@ -1066,10 +1070,10 @@ namespace __regex\n     _M_equivalence_class(_RMatcherT& __matcher)\n     {\n       if (_M_match_token(_ScannerT::_S_token_equiv_class_name))\n-      {\n-\t__matcher._M_add_equivalence_class(_M_cur_value);\n-\treturn true;\n-      }\n+\t{\n+\t  __matcher._M_add_equivalence_class(_M_cur_value);\n+\t  return true;\n+\t}\n       return false;\n     }\n \n@@ -1079,10 +1083,10 @@ namespace __regex\n     _M_character_class(_RMatcherT& __matcher)\n     {\n       if (_M_match_token(_ScannerT::_S_token_char_class_name))\n-      {\n-\t__matcher._M_add_character_class(_M_cur_value);\n-\treturn true;\n-      }\n+\t{\n+\t  __matcher._M_add_character_class(_M_cur_value);\n+\t  return true;\n+\t}\n       return false;\n     }\n "}, {"sha": "e8330fb7885920a067f902cee098a09c926d0569", "filename": "libstdc++-v3/include/bits/regex_cursor.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d860c8424cf2a29a5861bbffd35429ebf94e30ca/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_cursor.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d860c8424cf2a29a5861bbffd35429ebf94e30ca/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_cursor.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_cursor.h?ref=d860c8424cf2a29a5861bbffd35429ebf94e30ca", "patch": "@@ -64,11 +64,11 @@ namespace __regex\n \n       const _FwdIterT&\n       _M_begin() const\n-\t\t\t{ return _M_b; }\n+      { return _M_b; }\n \n       const _FwdIterT&\n       _M_end() const\n-\t\t\t{ return _M_e; }\n+      { return _M_e; }\n \n       bool\n       _M_at_end() const\n@@ -82,9 +82,9 @@ namespace __regex\n \n   // Helper funxtion to create a cursor specialized for an iterator class.\n   template<typename _FwdIterT>\n-  \t_SpecializedCursor<_FwdIterT>\n-  \t__cursor(const _FwdIterT& __b, const _FwdIterT __e)\n-\t\t{ return _SpecializedCursor<_FwdIterT>(__b, __e); }\n+    inline _SpecializedCursor<_FwdIterT>\n+    __cursor(const _FwdIterT& __b, const _FwdIterT __e)\n+    { return _SpecializedCursor<_FwdIterT>(__b, __e); }\n \n } // namespace __regex\n } // namespace std"}, {"sha": "17d1e6449dc2a3e1518d0c9af7db3e6be0616dcc", "filename": "libstdc++-v3/include/bits/regex_grep_matcher.tcc", "status": "modified", "additions": 54, "deletions": 56, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d860c8424cf2a29a5861bbffd35429ebf94e30ca/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_grep_matcher.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d860c8424cf2a29a5861bbffd35429ebf94e30ca/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_grep_matcher.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_grep_matcher.tcc?ref=d860c8424cf2a29a5861bbffd35429ebf94e30ca", "patch": "@@ -34,10 +34,9 @@ namespace\n {\n \n   // A stack of states used in evaluating the NFA.\n-  typedef std::stack<\n-                     std::__regex::_StateIdT,\n+  typedef std::stack<std::__regex::_StateIdT,\n                      std::vector<std::__regex::_StateIdT>\n-                    > _StateStack;\n+\t\t     > _StateStack;\n \n   // Obtains the next state set given the current state set __s and the current\n   // input character.\n@@ -48,16 +47,16 @@ namespace\n   {\n     std::__regex::_StateSet __m;\n     for (std::__regex::_StateSet::const_iterator __i = __s.begin();\n-\t\t     __i != __s.end(); ++__i)\n-    {\n-      if (*__i == std::__regex::_S_invalid_state_id)\n-\tcontinue;\n-\n-      const std::__regex::_State& __state = __nfa[*__i];\n-      if (__state._M_opcode == std::__regex::_S_opcode_match\n-       && __state._M_matches(__p))\n+\t __i != __s.end(); ++__i)\n+      {\n+\tif (*__i == std::__regex::_S_invalid_state_id)\n+\t  continue;\n+\n+\tconst std::__regex::_State& __state = __nfa[*__i];\n+\tif (__state._M_opcode == std::__regex::_S_opcode_match\n+\t    && __state._M_matches(__p))\n \t  __m.insert(__state._M_next);\n-    }\n+      }\n     return __m;\n   }\n \n@@ -67,19 +66,19 @@ namespace\n                   const std::__regex::_StateSet& __t)\n   {\n     if (__s.size() > 0 && __t.size() > 0)\n-    {\n-      std::__regex::_StateSet::const_iterator __first = __s.begin();\n-      std::__regex::_StateSet::const_iterator __second = __t.begin();\n-      while (__first != __s.end() && __second != __t.end())\n       {\n-\tif (*__first < *__second)\n-\t  ++__first;\n-\telse if (*__second < *__first)\n-\t  ++__second;\n-\telse\n-\t  return true;\n+\tstd::__regex::_StateSet::const_iterator __first = __s.begin();\n+\tstd::__regex::_StateSet::const_iterator __second = __t.begin();\n+\twhile (__first != __s.end() && __second != __t.end())\n+\t  {\n+\t    if (*__first < *__second)\n+\t      ++__first;\n+\t    else if (*__second < *__first)\n+\t      ++__second;\n+\t    else\n+\t      return true;\n+\t  }\n       }\n-    }\n     return false;\n   }\n \n@@ -91,20 +90,19 @@ namespace\n                       std::__regex::_StateSet&      __e)\n   {\n     if (__e.count(__u) == 0)\n-    {\n-      __e.insert(__u);\n-      __s.push(__u);\n-    }\n+      {\n+\t__e.insert(__u);\n+\t__s.push(__u);\n+      }\n   }\n \n } // anonymous namespace\n \n namespace __regex\n {\n   inline _Grep_matcher::\n-  _Grep_matcher(_PatternCursor&                  __p,\n-\t\t_Results&                        __r,\n-\t\tconst _AutomatonPtr&             __nfa,\n+  _Grep_matcher(_PatternCursor& __p, _Results& __r,\n+\t\tconst _AutomatonPtr& __nfa,\n \t\tregex_constants::match_flag_type __flags)\n   : _M_nfa(static_pointer_cast<_Nfa>(__nfa)), _M_pattern(__p), _M_results(__r)\n   {\n@@ -142,34 +140,34 @@ namespace __regex\n   {\n     _StateSet __e = __s;\n     while (!__stack.empty())\n-    {\n-      _StateIdT __t = __stack.top(); __stack.pop();\n-      if (__t == _S_invalid_state_id)\n-\tcontinue;\n-      // for each __u with edge from __t to __u labeled e do ...\n-      const _State& __state = _M_nfa->operator[](__t);\n-      switch (__state._M_opcode)\n       {\n-\tcase _S_opcode_alternative:\n-\t  __add_visited_state(__state._M_next, __stack, __e);\n-\t  __add_visited_state(__state._M_alt, __stack, __e);\n-\t  break;\n-\tcase _S_opcode_subexpr_begin:\n-\t  __add_visited_state(__state._M_next, __stack, __e);\n-\t  __state._M_tagger(_M_pattern, _M_results);\n-\t  break;\n-\tcase _S_opcode_subexpr_end:\n-\t  __add_visited_state(__state._M_next, __stack, __e);\n-\t  __state._M_tagger(_M_pattern, _M_results);\n-\t  _M_results._M_set_matched(__state._M_subexpr, true);\n-\t  break;\n-\tcase _S_opcode_accept:\n-\t  __add_visited_state(__state._M_next, __stack, __e);\n-\t  break;\n-\tdefault:\n-\t  break;\n+\t_StateIdT __t = __stack.top(); __stack.pop();\n+\tif (__t == _S_invalid_state_id)\n+\t  continue;\n+\t// for each __u with edge from __t to __u labeled e do ...\n+\tconst _State& __state = _M_nfa->operator[](__t);\n+\tswitch (__state._M_opcode)\n+\t  {\n+\t  case _S_opcode_alternative:\n+\t    __add_visited_state(__state._M_next, __stack, __e);\n+\t    __add_visited_state(__state._M_alt, __stack, __e);\n+\t    break;\n+\t  case _S_opcode_subexpr_begin:\n+\t    __add_visited_state(__state._M_next, __stack, __e);\n+\t    __state._M_tagger(_M_pattern, _M_results);\n+\t    break;\n+\t  case _S_opcode_subexpr_end:\n+\t    __add_visited_state(__state._M_next, __stack, __e);\n+\t    __state._M_tagger(_M_pattern, _M_results);\n+\t    _M_results._M_set_matched(__state._M_subexpr, true);\n+\t    break;\n+\t  case _S_opcode_accept:\n+\t    __add_visited_state(__state._M_next, __stack, __e);\n+\t    break;\n+\t  default:\n+\t    break;\n+\t  }\n       }\n-    }\n     return __e;\n   }\n "}]}