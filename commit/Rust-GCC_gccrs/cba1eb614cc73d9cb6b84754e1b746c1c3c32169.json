{"sha": "cba1eb614cc73d9cb6b84754e1b746c1c3c32169", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2JhMWViNjE0Y2M3M2Q5Y2I2Yjg0NzU0ZTFiNzQ2YzFjM2MzMjE2OQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2010-11-05T11:15:28Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2010-11-05T11:15:28Z"}, "message": "re PR tree-optimization/46099 (ICE: in replace_ssa_name, at tree-cfg.c:5643 with -ftree-parallelize-loops -g)\n\n\tPR tree-optimization/46099\n\t* tree-parloops.c (take_address_of): Add GSI argument.  Return NULL\n\tif it is NULL and uid wasn't found in the hash table.  Just fold the\n\tresult if it is NULL otherwise.  Insert other potentially needed\n\tstmts right before current stmt instead of on the entry edge.\n\t(struct elv_data): Add gsi and reset fields.\n\t(eliminate_local_variables_1): Adjust caller.  If take_address_of\n\tfailed for debug stmt, set dta->reset and return.\n\t(eliminate_local_variables_stmt): Change STMT argument for GSI,\n\tpass GSI through to the callback, handle resetting of debug stmts.\n\t(eliminate_local_variables): Adjust caller.  Process debug stmts\n\tin second phase.\n\n\t* gcc.dg/autopar/pr46099.c: New test.\n\nFrom-SVN: r166355", "tree": {"sha": "497bf216ccc6089f923a3ccd4a77deee89c2538a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/497bf216ccc6089f923a3ccd4a77deee89c2538a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cba1eb614cc73d9cb6b84754e1b746c1c3c32169", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cba1eb614cc73d9cb6b84754e1b746c1c3c32169", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cba1eb614cc73d9cb6b84754e1b746c1c3c32169", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cba1eb614cc73d9cb6b84754e1b746c1c3c32169/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "502c50846ce1ee2c46022fe2f004c19b7ea42314", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/502c50846ce1ee2c46022fe2f004c19b7ea42314", "html_url": "https://github.com/Rust-GCC/gccrs/commit/502c50846ce1ee2c46022fe2f004c19b7ea42314"}], "stats": {"total": 134, "additions": 121, "deletions": 13}, "files": [{"sha": "b5c8c4bd7650b5e8c9330dcaeb016ed2d56c1a76", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cba1eb614cc73d9cb6b84754e1b746c1c3c32169/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cba1eb614cc73d9cb6b84754e1b746c1c3c32169/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cba1eb614cc73d9cb6b84754e1b746c1c3c32169", "patch": "@@ -3,6 +3,19 @@\n \t* cfgexpand.c (expand_debug_expr): Handle MEM_REF\n \twith non-zero offset.\n \n+\tPR tree-optimization/46099\n+\t* tree-parloops.c (take_address_of): Add GSI argument.  Return NULL\n+\tif it is NULL and uid wasn't found in the hash table.  Just fold the\n+\tresult if it is NULL otherwise.  Insert other potentially needed\n+\tstmts right before current stmt instead of on the entry edge.\n+\t(struct elv_data): Add gsi and reset fields.\n+\t(eliminate_local_variables_1): Adjust caller.  If take_address_of\n+\tfailed for debug stmt, set dta->reset and return.\n+\t(eliminate_local_variables_stmt): Change STMT argument for GSI,\n+\tpass GSI through to the callback, handle resetting of debug stmts.\n+\t(eliminate_local_variables): Adjust caller.  Process debug stmts\n+\tin second phase.\n+\n \tPR middle-end/43690\n \t* gimplify.c (gimplify_asm_expr): If a \"m\" input is a\n \t{pre,post}{in,de}crement, fail."}, {"sha": "963177201404c033f26f497a12d23b220d11a5df", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cba1eb614cc73d9cb6b84754e1b746c1c3c32169/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cba1eb614cc73d9cb6b84754e1b746c1c3c32169/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=cba1eb614cc73d9cb6b84754e1b746c1c3c32169", "patch": "@@ -1,5 +1,8 @@\n 2010-11-05  Jakub Jelinek  <jakub@redhat.com>\n \n+\tPR tree-optimization/46099\n+\t* gcc.dg/autopar/pr46099.c: New test.\n+\n \tPR middle-end/43690\n \t* c-c++-common/pr43690.c: New test.\n "}, {"sha": "074278e644b503bfe57bbdf9796ba3b013c4a2ab", "filename": "gcc/testsuite/gcc.dg/autopar/pr46099.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cba1eb614cc73d9cb6b84754e1b746c1c3c32169/gcc%2Ftestsuite%2Fgcc.dg%2Fautopar%2Fpr46099.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cba1eb614cc73d9cb6b84754e1b746c1c3c32169/gcc%2Ftestsuite%2Fgcc.dg%2Fautopar%2Fpr46099.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fautopar%2Fpr46099.c?ref=cba1eb614cc73d9cb6b84754e1b746c1c3c32169", "patch": "@@ -0,0 +1,47 @@\n+/* PR tree-optimization/46099 */\n+/* { dg-do compile } */\n+/* { dg-options \"-ftree-parallelize-loops=2 -fcompare-debug -O\" } */\n+\n+static inline void\n+bar (int *i)\n+{\n+  int j = *i;\n+}\n+\n+void baz (int *, int *, int *);\n+\n+void\n+f1 (int n)\n+{\n+  int i;\n+  for (i = 0; i < n; i++)\n+    bar (&i);\n+}\n+\n+void\n+f2 (int n)\n+{\n+  int i;\n+  int a[10000], b[10000], c[10000];\n+  baz (a, b, c);\n+  for (i = 0; i < n; i++)\n+    {\n+      void *p = c;\n+      a[i] = b[i] + c[i];\n+    }\n+  baz (a, b, c);\n+}\n+\n+void\n+f3 (int n)\n+{\n+  int i;\n+  int a[10000], b[10000], c[10000];\n+  baz (a, b, c);\n+  for (i = 0; i < n; i++)\n+    {\n+      a[i] = b[i] + c[i];\n+      void *p = c;\n+    }\n+  baz (a, b, c);\n+}"}, {"sha": "a634b249a6130fdb84df31c01745e7a9c79d1c45", "filename": "gcc/tree-parloops.c", "status": "modified", "additions": 58, "deletions": 13, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cba1eb614cc73d9cb6b84754e1b746c1c3c32169/gcc%2Ftree-parloops.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cba1eb614cc73d9cb6b84754e1b746c1c3c32169/gcc%2Ftree-parloops.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-parloops.c?ref=cba1eb614cc73d9cb6b84754e1b746c1c3c32169", "patch": "@@ -314,10 +314,12 @@ loop_has_blocks_with_irreducible_flag (struct loop *loop)\n /* Assigns the address of OBJ in TYPE to an ssa name, and returns this name.\n    The assignment statement is placed on edge ENTRY.  DECL_ADDRESS maps decls\n    to their addresses that can be reused.  The address of OBJ is known to\n-   be invariant in the whole function.  */\n+   be invariant in the whole function.  Other needed statements are placed\n+   right before GSI.  */\n \n static tree\n-take_address_of (tree obj, tree type, edge entry, htab_t decl_address)\n+take_address_of (tree obj, tree type, edge entry, htab_t decl_address,\n+\t\t gimple_stmt_iterator *gsi)\n {\n   int uid;\n   void **dslot;\n@@ -346,6 +348,8 @@ take_address_of (tree obj, tree type, edge entry, htab_t decl_address)\n   dslot = htab_find_slot_with_hash (decl_address, &ielt, uid, INSERT);\n   if (!*dslot)\n     {\n+      if (gsi == NULL)\n+\treturn NULL;\n       addr = TREE_OPERAND (*var_p, 0);\n       bvar = create_tmp_var (TREE_TYPE (addr),\n \t\t\t     get_name (TREE_OPERAND\n@@ -366,17 +370,20 @@ take_address_of (tree obj, tree type, edge entry, htab_t decl_address)\n \n   /* Express the address in terms of the canonical SSA name.  */\n   TREE_OPERAND (*var_p, 0) = name;\n+  if (gsi == NULL)\n+    return build_fold_addr_expr_with_type (obj, type);\n+\n   name = force_gimple_operand (build_addr (obj, current_function_decl),\n \t\t\t       &stmts, true, NULL_TREE);\n   if (!gimple_seq_empty_p (stmts))\n-    gsi_insert_seq_on_edge_immediate (entry, stmts);\n+    gsi_insert_seq_before (gsi, stmts, GSI_SAME_STMT);\n \n   if (!useless_type_conversion_p (type, TREE_TYPE (name)))\n     {\n       name = force_gimple_operand (fold_convert (type, name), &stmts, true,\n \t\t\t\t   NULL_TREE);\n       if (!gimple_seq_empty_p (stmts))\n-\tgsi_insert_seq_on_edge_immediate (entry, stmts);\n+\tgsi_insert_seq_before (gsi, stmts, GSI_SAME_STMT);\n     }\n \n   return name;\n@@ -438,7 +445,9 @@ struct elv_data\n   struct walk_stmt_info info;\n   edge entry;\n   htab_t decl_address;\n+  gimple_stmt_iterator *gsi;\n   bool changed;\n+  bool reset;\n };\n \n /* Eliminates references to local variables in *TP out of the single\n@@ -462,7 +471,14 @@ eliminate_local_variables_1 (tree *tp, int *walk_subtrees, void *data)\n \n       type = TREE_TYPE (t);\n       addr_type = build_pointer_type (type);\n-      addr = take_address_of (t, addr_type, dta->entry, dta->decl_address);\n+      addr = take_address_of (t, addr_type, dta->entry, dta->decl_address,\n+\t\t\t      dta->gsi);\n+      if (dta->gsi == NULL && addr == NULL_TREE)\n+\t{\n+\t  dta->reset = true;\n+\t  return NULL_TREE;\n+\t}\n+\n       *tp = build_simple_mem_ref (addr);\n \n       dta->changed = true;\n@@ -492,7 +508,13 @@ eliminate_local_variables_1 (tree *tp, int *walk_subtrees, void *data)\n \treturn NULL_TREE;\n \n       addr_type = TREE_TYPE (t);\n-      addr = take_address_of (obj, addr_type, dta->entry, dta->decl_address);\n+      addr = take_address_of (obj, addr_type, dta->entry, dta->decl_address,\n+\t\t\t      dta->gsi);\n+      if (dta->gsi == NULL && addr == NULL_TREE)\n+\t{\n+\t  dta->reset = true;\n+\t  return NULL_TREE;\n+\t}\n       *tp = addr;\n \n       dta->changed = true;\n@@ -505,27 +527,40 @@ eliminate_local_variables_1 (tree *tp, int *walk_subtrees, void *data)\n   return NULL_TREE;\n }\n \n-/* Moves the references to local variables in STMT out of the single\n+/* Moves the references to local variables in STMT at *GSI out of the single\n    entry single exit region starting at ENTRY.  DECL_ADDRESS contains\n    addresses of the references that had their address taken\n    already.  */\n \n static void\n-eliminate_local_variables_stmt (edge entry, gimple stmt,\n+eliminate_local_variables_stmt (edge entry, gimple_stmt_iterator *gsi,\n \t\t\t\thtab_t decl_address)\n {\n   struct elv_data dta;\n+  gimple stmt = gsi_stmt (*gsi);\n \n   memset (&dta.info, '\\0', sizeof (dta.info));\n   dta.entry = entry;\n   dta.decl_address = decl_address;\n   dta.changed = false;\n+  dta.reset = false;\n \n   if (gimple_debug_bind_p (stmt))\n-    walk_tree (gimple_debug_bind_get_value_ptr (stmt),\n-\t       eliminate_local_variables_1, &dta.info, NULL);\n+    {\n+      dta.gsi = NULL;\n+      walk_tree (gimple_debug_bind_get_value_ptr (stmt),\n+\t\t eliminate_local_variables_1, &dta.info, NULL);\n+      if (dta.reset)\n+\t{\n+\t  gimple_debug_bind_reset_value (stmt);\n+\t  dta.changed = true;\n+\t}\n+    }\n   else\n-    walk_gimple_op (stmt, eliminate_local_variables_1, &dta.info);\n+    {\n+      dta.gsi = gsi;\n+      walk_gimple_op (stmt, eliminate_local_variables_1, &dta.info);\n+    }\n \n   if (dta.changed)\n     update_stmt (stmt);\n@@ -549,6 +584,7 @@ eliminate_local_variables (edge entry, edge exit)\n   VEC (basic_block, heap) *body = VEC_alloc (basic_block, heap, 3);\n   unsigned i;\n   gimple_stmt_iterator gsi;\n+  bool has_debug_stmt = false;\n   htab_t decl_address = htab_create (10, int_tree_map_hash, int_tree_map_eq,\n \t\t\t\t     free);\n   basic_block entry_bb = entry->src;\n@@ -559,8 +595,17 @@ eliminate_local_variables (edge entry, edge exit)\n   FOR_EACH_VEC_ELT (basic_block, body, i, bb)\n     if (bb != entry_bb && bb != exit_bb)\n       for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n-\teliminate_local_variables_stmt (entry, gsi_stmt (gsi),\n-\t\t\t\t\tdecl_address);\n+\tif (gimple_debug_bind_p (gsi_stmt (gsi)))\n+\t  has_debug_stmt = true;\n+\telse\n+\t  eliminate_local_variables_stmt (entry, &gsi, decl_address);\n+\n+  if (has_debug_stmt)\n+    FOR_EACH_VEC_ELT (basic_block, body, i, bb)\n+      if (bb != entry_bb && bb != exit_bb)\n+\tfor (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+\t  if (gimple_debug_bind_p (gsi_stmt (gsi)))\n+\t    eliminate_local_variables_stmt (entry, &gsi, decl_address);\n \n   htab_delete (decl_address);\n   VEC_free (basic_block, heap, body);"}]}