{"sha": "7598036b5a94ff138f7ae9a007b385d1b6000afd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzU5ODAzNmI1YTk0ZmYxMzhmN2FlOWEwMDdiMzg1ZDFiNjAwMGFmZA==", "commit": {"author": {"name": "Anatoly Sokolov", "email": "aesok@post.ru", "date": "2011-12-15T14:43:02Z"}, "committer": {"name": "Anatoly Sokolov", "email": "aesok@gcc.gnu.org", "date": "2011-12-15T14:43:02Z"}, "message": "arm.h (REGISTER_MOVE_COST, [...]): Remove.\n\n\t* config/arm/arm.h (REGISTER_MOVE_COST, MEMORY_MOVE_COST): Remove.\n\t* config/arm/arm.c (arm_memory_move_cost, arm_register_move_cost):\n\tNew functions.\n\t(TARGET_REGISTER_MOVE_COST, TARGET_MEMORY_MOVE_COST): Define.\n\nFrom-SVN: r182369", "tree": {"sha": "0fd471a47d6d04f805c05e5b11d45f4b0b70ab58", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0fd471a47d6d04f805c05e5b11d45f4b0b70ab58"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7598036b5a94ff138f7ae9a007b385d1b6000afd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7598036b5a94ff138f7ae9a007b385d1b6000afd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7598036b5a94ff138f7ae9a007b385d1b6000afd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7598036b5a94ff138f7ae9a007b385d1b6000afd/comments", "author": null, "committer": null, "parents": [{"sha": "dec6faf1db26d2c0a47eff4ea31d92cfdf0eec15", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dec6faf1db26d2c0a47eff4ea31d92cfdf0eec15", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dec6faf1db26d2c0a47eff4ea31d92cfdf0eec15"}], "stats": {"total": 98, "additions": 72, "deletions": 26}, "files": [{"sha": "3357e8fa806d28472996fead5f7458673fffd787", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7598036b5a94ff138f7ae9a007b385d1b6000afd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7598036b5a94ff138f7ae9a007b385d1b6000afd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7598036b5a94ff138f7ae9a007b385d1b6000afd", "patch": "@@ -1,3 +1,10 @@\n+2011-12-15  Anatoly Sokolov  <aesok@post.ru>\n+\n+\t* config/arm/arm.h (REGISTER_MOVE_COST, MEMORY_MOVE_COST): Remove.\n+\t* config/arm/arm.c (arm_memory_move_cost, arm_register_move_cost):\n+\tNew functions.\n+\t(TARGET_REGISTER_MOVE_COST, TARGET_MEMORY_MOVE_COST): Define.\n+\n 2011-12-15  Richard Guenther  <rguenther@suse.de>\n \n \tPR lto/51564"}, {"sha": "3d3c4523c756353841c4f920a337d3286feaf686", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7598036b5a94ff138f7ae9a007b385d1b6000afd/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7598036b5a94ff138f7ae9a007b385d1b6000afd/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=7598036b5a94ff138f7ae9a007b385d1b6000afd", "patch": "@@ -164,6 +164,8 @@ static bool arm_xscale_rtx_costs (rtx, enum rtx_code, enum rtx_code, int *, bool\n static bool arm_9e_rtx_costs (rtx, enum rtx_code, enum rtx_code, int *, bool);\n static bool arm_rtx_costs (rtx, int, int, int, int *, bool);\n static int arm_address_cost (rtx, bool);\n+static int arm_register_move_cost (enum machine_mode, reg_class_t, reg_class_t);\n+static int arm_memory_move_cost (enum machine_mode, reg_class_t, bool);\n static bool arm_memory_load_p (rtx);\n static bool arm_cirrus_insn_p (rtx);\n static void cirrus_reorg (rtx);\n@@ -363,6 +365,12 @@ static const struct attribute_spec arm_attribute_table[] =\n #undef  TARGET_SCHED_ADJUST_COST\n #define TARGET_SCHED_ADJUST_COST arm_adjust_cost\n \n+#undef TARGET_REGISTER_MOVE_COST\n+#define TARGET_REGISTER_MOVE_COST arm_register_move_cost\n+\n+#undef TARGET_MEMORY_MOVE_COST\n+#define TARGET_MEMORY_MOVE_COST arm_memory_move_cost\n+\n #undef TARGET_ENCODE_SECTION_INFO\n #ifdef ARM_PE\n #define TARGET_ENCODE_SECTION_INFO  arm_pe_encode_section_info\n@@ -8484,6 +8492,63 @@ fa726te_sched_adjust_cost (rtx insn, rtx link, rtx dep, int * cost)\n   return true;\n }\n \n+/* Implement TARGET_REGISTER_MOVE_COST.\n+\n+   Moves between FPA_REGS and GENERAL_REGS are two memory insns.\n+   Moves between VFP_REGS and GENERAL_REGS are a single insn, but\n+   it is typically more expensive than a single memory access.  We set\n+   the cost to less than two memory accesses so that floating\n+   point to integer conversion does not go through memory.  */\n+\n+int\n+arm_register_move_cost (enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\treg_class_t from, reg_class_t to)\n+{\n+  if (TARGET_32BIT)\n+    {\n+      if ((from == FPA_REGS && to != FPA_REGS)\n+\t  || (from != FPA_REGS && to == FPA_REGS))\n+\treturn 20;\n+      else if ((IS_VFP_CLASS (from) && !IS_VFP_CLASS (to))\n+\t       || (!IS_VFP_CLASS (from) && IS_VFP_CLASS (to)))\n+\treturn 15;\n+      else if ((from == IWMMXT_REGS && to != IWMMXT_REGS)\n+\t       || (from != IWMMXT_REGS && to == IWMMXT_REGS))\n+\treturn 4;\n+      else if (from == IWMMXT_GR_REGS || to == IWMMXT_GR_REGS)\n+\treturn 20;\n+      else if ((from == CIRRUS_REGS && to != CIRRUS_REGS)\n+\t       || (from != CIRRUS_REGS && to == CIRRUS_REGS))\n+\treturn 20;\n+      else\n+\treturn 2;\n+    }\n+  else\n+    {\n+      if (from == HI_REGS || to == HI_REGS)\n+\treturn 4;\n+      else\n+\treturn 2;\n+    }\n+}\n+\n+/* Implement TARGET_MEMORY_MOVE_COST.  */\n+\n+int\n+arm_memory_move_cost (enum machine_mode mode, reg_class_t rclass,\n+\t\t      bool in ATTRIBUTE_UNUSED)\n+{\n+  if (TARGET_32BIT)\n+    return 10;\n+  else\n+    {\n+      if (GET_MODE_SIZE (mode) < 4)\n+\treturn 8;\n+      else\n+\treturn ((2 * GET_MODE_SIZE (mode)) * (rclass == LO_REGS ? 1 : 2));\n+    }\n+}\n+\n /* This function implements the target macro TARGET_SCHED_ADJUST_COST.\n    It corrects the value of COST based on the relationship between\n    INSN and DEP through the dependence LINK.  It returns the new"}, {"sha": "5a781256b207e8db503d12d0da3401fa497ec69f", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7598036b5a94ff138f7ae9a007b385d1b6000afd/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7598036b5a94ff138f7ae9a007b385d1b6000afd/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=7598036b5a94ff138f7ae9a007b385d1b6000afd", "patch": "@@ -1281,26 +1281,6 @@ do {\t\t\t\t\t\t\t\t\t      \\\n \n /* If defined, gives a class of registers that cannot be used as the\n    operand of a SUBREG that changes the mode of the object illegally.  */\n-\n-/* Moves between FPA_REGS and GENERAL_REGS are two memory insns.\n-   Moves between VFP_REGS and GENERAL_REGS are a single insn, but\n-   it is typically more expensive than a single memory access.  We set\n-   the cost to less than two memory accesses so that floating\n-   point to integer conversion does not go through memory.  */\n-#define REGISTER_MOVE_COST(MODE, FROM, TO)\t\t\\\n-  (TARGET_32BIT ?\t\t\t\t\t\t\\\n-   ((FROM) == FPA_REGS && (TO) != FPA_REGS ? 20 :\t\\\n-    (FROM) != FPA_REGS && (TO) == FPA_REGS ? 20 :\t\\\n-    IS_VFP_CLASS (FROM) && !IS_VFP_CLASS (TO) ? 15 :\t\\\n-    !IS_VFP_CLASS (FROM) && IS_VFP_CLASS (TO) ? 15 :\t\\\n-    (FROM) == IWMMXT_REGS && (TO) != IWMMXT_REGS ? 4 :  \\\n-    (FROM) != IWMMXT_REGS && (TO) == IWMMXT_REGS ? 4 :  \\\n-    (FROM) == IWMMXT_GR_REGS || (TO) == IWMMXT_GR_REGS ? 20 :  \\\n-    (FROM) == CIRRUS_REGS && (TO) != CIRRUS_REGS ? 20 :\t\\\n-    (FROM) != CIRRUS_REGS && (TO) == CIRRUS_REGS ? 20 :\t\\\n-   2)\t\t\t\t\t\t\t\\\n-   :\t\t\t\t\t\t\t\\\n-   ((FROM) == HI_REGS || (TO) == HI_REGS) ? 4 : 2)\n \f\n /* Stack layout; function entry, exit and calling.  */\n \n@@ -1953,12 +1933,6 @@ typedef struct\n   (   (X) == frame_pointer_rtx || (X) == stack_pointer_rtx\t\\\n    || (X) == arg_pointer_rtx)\n \n-/* Moves to and from memory are quite expensive */\n-#define MEMORY_MOVE_COST(M, CLASS, IN)\t\t\t\\\n-  (TARGET_32BIT ? 10 :\t\t\t\t\t\\\n-   ((GET_MODE_SIZE (M) < 4 ? 8 : 2 * GET_MODE_SIZE (M))\t\\\n-    * (CLASS == LO_REGS ? 1 : 2)))\n-\n /* Try to generate sequences that don't involve branches, we can then use\n    conditional instructions */\n #define BRANCH_COST(speed_p, predictable_p) \\"}]}