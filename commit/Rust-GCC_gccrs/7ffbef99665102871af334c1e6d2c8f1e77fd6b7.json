{"sha": "7ffbef99665102871af334c1e6d2c8f1e77fd6b7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2ZmYmVmOTk2NjUxMDI4NzFhZjMzNGMxZTZkMmM4ZjFlNzdmZDZiNw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@adacore.com", "date": "2016-06-22T10:31:47Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2016-06-22T10:31:47Z"}, "message": "spark_xrefs.ads (Scope_Num): type refined to positive integers.\n\n2016-06-22  Arnaud Charlet  <charlet@adacore.com>\n\n\t* spark_xrefs.ads (Scope_Num): type refined to positive integers.\n\t* lib-xref-spark_specific.adb (Detect_And_Add_SPARK_Scope):\n\tmoved into scope of Collect_SPARK_Xrefs.\n\t(Add_SPARK_Scope): moved into scope of Collect_SPARK_Xrefs;\n\tnow uses Dspec and Scope_Id from Collect_SPARK_Xrefs.\n\t(Collect_SPARK_Xrefs): refactored to avoid retraversing the list\n\tof scopes.\n\t(Traverse_Compilation_Unit): refactored as a generic procedure.\n\t* types.ads (Unit_Number_Type): range refined.\n\nFrom-SVN: r237690", "tree": {"sha": "49362ba0c5da270c0b28861ed83db581ae76eb3e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/49362ba0c5da270c0b28861ed83db581ae76eb3e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7ffbef99665102871af334c1e6d2c8f1e77fd6b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ffbef99665102871af334c1e6d2c8f1e77fd6b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ffbef99665102871af334c1e6d2c8f1e77fd6b7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ffbef99665102871af334c1e6d2c8f1e77fd6b7/comments", "author": {"login": "ArnaudCharlet", "id": 30291825, "node_id": "MDQ6VXNlcjMwMjkxODI1", "avatar_url": "https://avatars.githubusercontent.com/u/30291825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ArnaudCharlet", "html_url": "https://github.com/ArnaudCharlet", "followers_url": "https://api.github.com/users/ArnaudCharlet/followers", "following_url": "https://api.github.com/users/ArnaudCharlet/following{/other_user}", "gists_url": "https://api.github.com/users/ArnaudCharlet/gists{/gist_id}", "starred_url": "https://api.github.com/users/ArnaudCharlet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ArnaudCharlet/subscriptions", "organizations_url": "https://api.github.com/users/ArnaudCharlet/orgs", "repos_url": "https://api.github.com/users/ArnaudCharlet/repos", "events_url": "https://api.github.com/users/ArnaudCharlet/events{/privacy}", "received_events_url": "https://api.github.com/users/ArnaudCharlet/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "71b235999de097baad9739568b21f7d2714a306a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71b235999de097baad9739568b21f7d2714a306a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/71b235999de097baad9739568b21f7d2714a306a"}], "stats": {"total": 792, "additions": 377, "deletions": 415}, "files": [{"sha": "b6d23ea146e3b5cd416e661549b951a5639bb42b", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ffbef99665102871af334c1e6d2c8f1e77fd6b7/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ffbef99665102871af334c1e6d2c8f1e77fd6b7/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=7ffbef99665102871af334c1e6d2c8f1e77fd6b7", "patch": "@@ -1,3 +1,15 @@\n+2016-06-22  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* spark_xrefs.ads (Scope_Num): type refined to positive integers.\n+\t* lib-xref-spark_specific.adb (Detect_And_Add_SPARK_Scope):\n+\tmoved into scope of Collect_SPARK_Xrefs.\n+\t(Add_SPARK_Scope): moved into scope of Collect_SPARK_Xrefs;\n+\tnow uses Dspec and Scope_Id from Collect_SPARK_Xrefs.\n+\t(Collect_SPARK_Xrefs): refactored to avoid retraversing the list\n+\tof scopes.\n+\t(Traverse_Compilation_Unit): refactored as a generic procedure.\n+\t* types.ads (Unit_Number_Type): range refined.\n+\n 2016-06-22  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* lib-xref-spark_specific.adb, a-cuprqu.ads, sem_ch6.adb: Minor"}, {"sha": "3e5026bb1d1bdaea781e378982fe8d9cd45d4867", "filename": "gcc/ada/lib-xref-spark_specific.adb", "status": "modified", "additions": 362, "deletions": 402, "changes": 764, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ffbef99665102871af334c1e6d2c8f1e77fd6b7/gcc%2Fada%2Flib-xref-spark_specific.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ffbef99665102871af334c1e6d2c8f1e77fd6b7/gcc%2Fada%2Flib-xref-spark_specific.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-xref-spark_specific.adb?ref=7ffbef99665102871af334c1e6d2c8f1e77fd6b7", "patch": "@@ -85,160 +85,68 @@ package body SPARK_Specific is\n    -- Local Subprograms --\n    -----------------------\n \n-   procedure Add_SPARK_File (Ubody, Uspec : Unit_Number_Type; Dspec : Nat);\n+   procedure Add_SPARK_File (Uspec, Ubody : Unit_Number_Type; Dspec : Nat);\n    --  Add file and corresponding scopes for unit to the tables\n-   --  SPARK_File_Table and SPARK_Scope_Table. When two units are present for\n-   --  the same compilation unit, as it happens for library-level\n-   --  instantiations of generics, then Ubody /= Uspec, and all scopes are\n-   --  added to the same SPARK file. Otherwise Ubody = Uspec.\n-\n-   procedure Add_SPARK_Scope (N : Node_Id);\n-   --  Add scope N to the table SPARK_Scope_Table\n+   --  SPARK_File_Table and SPARK_Scope_Table. When two units are present\n+   --  for the same compilation unit, as it happens for library-level\n+   --  instantiations of generics, then Ubody is the number of the body\n+   --  unit; otherwise it is No_Unit.\n \n    procedure Add_SPARK_Xrefs;\n    --  Filter table Xrefs to add all references used in SPARK to the table\n    --  SPARK_Xref_Table.\n \n-   procedure Detect_And_Add_SPARK_Scope (N : Node_Id);\n-   --  Call Add_SPARK_Scope on scopes\n-\n    function Entity_Hash (E : Entity_Id) return Entity_Hashed_Range;\n    --  Hash function for hash table\n \n-   procedure Traverse_Declaration_Or_Statement\n-     (N            : Node_Id;\n-      Process      : Node_Processing;\n-      Inside_Stubs : Boolean);\n-   procedure Traverse_Declarations_Or_Statements\n-     (L            : List_Id;\n-      Process      : Node_Processing;\n-      Inside_Stubs : Boolean);\n-   procedure Traverse_Handled_Statement_Sequence\n-     (N            : Node_Id;\n-      Process      : Node_Processing;\n-      Inside_Stubs : Boolean);\n-   procedure Traverse_Protected_Body\n-     (N            : Node_Id;\n-      Process      : Node_Processing;\n-      Inside_Stubs : Boolean);\n-   procedure Traverse_Package_Body\n-     (N            : Node_Id;\n-      Process      : Node_Processing;\n-      Inside_Stubs : Boolean);\n-   procedure Traverse_Subprogram_Body\n-     (N            : Node_Id;\n-      Process      : Node_Processing;\n-      Inside_Stubs : Boolean);\n-   --  Traverse corresponding construct, calling Process on all declarations\n+   generic\n+      with procedure Process (N : Node_Id) is <>;\n+   procedure Traverse_Compilation_Unit (CU : Node_Id; Inside_Stubs : Boolean);\n+   --  Call Process on all declarations in compilation unit CU. If\n+   --  Inside_Stubs is True, then the body of stubs is also traversed.\n+   --  Generic declarations are ignored.\n \n    --------------------\n    -- Add_SPARK_File --\n    --------------------\n \n-   procedure Add_SPARK_File (Ubody, Uspec : Unit_Number_Type; Dspec : Nat) is\n+   procedure Add_SPARK_File (Uspec, Ubody : Unit_Number_Type; Dspec : Nat) is\n       File : constant Source_File_Index := Source_Index (Uspec);\n-      From : Scope_Index;\n+      From : constant Scope_Index       := SPARK_Scope_Table.Last + 1;\n \n       File_Name      : String_Ptr;\n       Unit_File_Name : String_Ptr;\n \n-   begin\n-      --  Source file could be inexistant as a result of an error, if option\n-      --  gnatQ is used.\n+      Scope_Id : Pos := 1;\n \n-      if File = No_Source_File then\n-         return;\n-      end if;\n+      procedure Add_SPARK_Scope (N : Node_Id);\n+      --  Add scope N to the table SPARK_Scope_Table\n \n-      --  Subunits are traversed as part of the top-level unit to which they\n-      --  belong.\n-\n-      if Nkind (Unit (Cunit (Ubody))) = N_Subunit then\n-         return;\n-      end if;\n+      procedure Detect_And_Add_SPARK_Scope (N : Node_Id);\n+      --  Call Add_SPARK_Scope on scopes\n \n-      From := SPARK_Scope_Table.Last + 1;\n-\n-      Traverse_Compilation_Unit\n-        (CU           => Cunit (Ubody),\n-         Process      => Detect_And_Add_SPARK_Scope'Access,\n-         Inside_Stubs => True);\n+      ---------------------\n+      -- Add_SPARK_Scope --\n+      ---------------------\n \n-      --  When two units are present for the same compilation unit, as it\n-      --  happens for library-level instantiations of generics, then add all\n-      --  scopes to the same SPARK file.\n+      procedure Add_SPARK_Scope (N : Node_Id) is\n+         E   : constant Entity_Id  := Defining_Entity (N);\n+         Loc : constant Source_Ptr := Sloc (E);\n \n-      if Ubody /= Uspec then\n-         Traverse_Compilation_Unit\n-           (CU           => Cunit (Uspec),\n-            Process      => Detect_And_Add_SPARK_Scope'Access,\n-            Inside_Stubs => True);\n-      end if;\n+         --  The character describing the kind of scope is chosen to be the\n+         --  same as the one describing the corresponding entity in cross\n+         --  references, see Xref_Entity_Letters in lib-xrefs.ads\n \n-      --  Update scope numbers\n+         Typ : Character;\n \n-      declare\n-         Scope_Id : Pos;\n       begin\n-         Scope_Id := 1;\n-         for Index in From .. SPARK_Scope_Table.Last loop\n-            declare\n-               S : SPARK_Scope_Record renames SPARK_Scope_Table.Table (Index);\n-            begin\n-               S.Scope_Num := Scope_Id;\n-               S.File_Num  := Dspec;\n-               Scope_Id    := Scope_Id + 1;\n-            end;\n-         end loop;\n-      end;\n-\n-      --  Make entry for new file in file table\n-\n-      Get_Name_String (Reference_Name (File));\n-      File_Name := new String'(Name_Buffer (1 .. Name_Len));\n-\n-      --  For subunits, also retrieve the file name of the unit. Only do so if\n-      --  unit has an associated compilation unit.\n+         --  Ignore scopes without a proper location\n \n-      if Present (Cunit (Unit (File)))\n-        and then Nkind (Unit (Cunit (Unit (File)))) = N_Subunit\n-      then\n-         Get_Name_String (Reference_Name (Main_Source_File));\n-         Unit_File_Name := new String'(Name_Buffer (1 .. Name_Len));\n-      else\n-         Unit_File_Name := null;\n-      end if;\n-\n-      SPARK_File_Table.Append (\n-        (File_Name      => File_Name,\n-         Unit_File_Name => Unit_File_Name,\n-         File_Num       => Dspec,\n-         From_Scope     => From,\n-         To_Scope       => SPARK_Scope_Table.Last));\n-   end Add_SPARK_File;\n-\n-   ---------------------\n-   -- Add_SPARK_Scope --\n-   ---------------------\n-\n-   procedure Add_SPARK_Scope (N : Node_Id) is\n-      E   : constant Entity_Id  := Defining_Entity (N);\n-      Loc : constant Source_Ptr := Sloc (E);\n-\n-      --  The character describing the kind of scope is chosen to be the same\n-      --  as the one describing the corresponding entity in cross references,\n-      --  see Xref_Entity_Letters in lib-xrefs.ads\n-\n-      Typ : Character;\n-\n-   begin\n-      --  Ignore scopes without a proper location\n-\n-      if Sloc (N) = No_Location then\n-         return;\n-      end if;\n+         if Sloc (N) = No_Location then\n+            return;\n+         end if;\n \n-      case Ekind (E) is\n+         case Ekind (E) is\n          when E_Entry\n             | E_Entry_Family\n             | E_Generic_Function\n@@ -247,16 +155,16 @@ package body SPARK_Specific is\n             | E_Package\n             | E_Protected_Type\n             | E_Task_Type\n-         =>\n+            =>\n             Typ := Xref_Entity_Letters (Ekind (E));\n \n          when E_Function\n             | E_Procedure\n-         =>\n+            =>\n             --  In SPARK we need to distinguish protected functions and\n             --  procedures from ordinary subprograms, but there are no special\n-            --  Xref letters for them. Since this distiction is only needed\n-            --  to detect protected calls, we pretend that such calls are entry\n+            --  Xref letters for them. Since this distiction is only needed to\n+            --  detect protected calls, we pretend that such calls are entry\n             --  calls.\n \n             if Ekind (Scope (E)) = E_Protected_Type then\n@@ -269,7 +177,7 @@ package body SPARK_Specific is\n             | E_Protected_Body\n             | E_Subprogram_Body\n             | E_Task_Body\n-         =>\n+            =>\n             Typ := Xref_Entity_Letters (Ekind (Unique_Entity (E)));\n \n          when E_Void =>\n@@ -282,24 +190,111 @@ package body SPARK_Specific is\n \n          when others =>\n             raise Program_Error;\n-      end case;\n-\n-      --  File_Num and Scope_Num are filled later. From_Xref and To_Xref are\n-      --  filled even later, but are initialized to represent an empty range.\n-\n-      SPARK_Scope_Table.Append (\n-        (Scope_Name     => new String'(Unique_Name (E)),\n-         File_Num       => 0,\n-         Scope_Num      => 0,\n-         Spec_File_Num  => 0,\n-         Spec_Scope_Num => 0,\n-         Line           => Nat (Get_Logical_Line_Number (Loc)),\n-         Stype          => Typ,\n-         Col            => Nat (Get_Column_Number (Loc)),\n-         From_Xref      => 1,\n-         To_Xref        => 0,\n-         Scope_Entity   => E));\n-   end Add_SPARK_Scope;\n+         end case;\n+\n+         --  File_Num and Scope_Num are filled later. From_Xref and To_Xref\n+         --  are filled even later, but are initialized to represent an empty\n+         --  range.\n+\n+         SPARK_Scope_Table.Append\n+           ((Scope_Name     => new String'(Unique_Name (E)),\n+             File_Num       => Dspec,\n+             Scope_Num      => Scope_Id,\n+             Spec_File_Num  => 0,\n+             Spec_Scope_Num => 0,\n+             Line           => Nat (Get_Logical_Line_Number (Loc)),\n+             Stype          => Typ,\n+             Col            => Nat (Get_Column_Number (Loc)),\n+             From_Xref      => 1,\n+             To_Xref        => 0,\n+             Scope_Entity   => E));\n+\n+         Scope_Id := Scope_Id + 1;\n+      end Add_SPARK_Scope;\n+\n+      --------------------------------\n+      -- Detect_And_Add_SPARK_Scope --\n+      --------------------------------\n+\n+      procedure Detect_And_Add_SPARK_Scope (N : Node_Id) is\n+      begin\n+         if Nkind_In (N, N_Entry_Body,             --  entries\n+                      N_Entry_Declaration)\n+           or else\n+             Nkind_In (N, N_Package_Body,           --  packages\n+                       N_Package_Body_Stub,\n+                       N_Package_Declaration)\n+           or else\n+             Nkind_In (N, N_Protected_Body,         --  protected objects\n+                       N_Protected_Body_Stub,\n+                       N_Protected_Type_Declaration)\n+           or else\n+             Nkind_In (N, N_Subprogram_Body,        --  subprograms\n+                       N_Subprogram_Body_Stub,\n+                       N_Subprogram_Declaration)\n+           or else\n+             Nkind_In (N, N_Task_Body,              --  tasks\n+                       N_Task_Body_Stub,\n+                       N_Task_Type_Declaration)\n+         then\n+            Add_SPARK_Scope (N);\n+         end if;\n+      end Detect_And_Add_SPARK_Scope;\n+\n+      procedure Traverse_Scopes is new\n+        Traverse_Compilation_Unit (Detect_And_Add_SPARK_Scope);\n+\n+   --  Start of processing for Add_SPARK_File\n+\n+   begin\n+      --  Source file could be inexistant as a result of an error, if option\n+      --  gnatQ is used.\n+\n+      if File = No_Source_File then\n+         return;\n+      end if;\n+\n+      --  Subunits are traversed as part of the top-level unit to which they\n+      --  belong.\n+\n+      if Nkind (Unit (Cunit (Uspec))) = N_Subunit then\n+         return;\n+      end if;\n+\n+      Traverse_Scopes (CU => Cunit (Uspec), Inside_Stubs => True);\n+\n+      --  When two units are present for the same compilation unit, as it\n+      --  happens for library-level instantiations of generics, then add all\n+      --  scopes to the same SPARK file.\n+\n+      if Ubody /= No_Unit then\n+         Traverse_Scopes (CU => Cunit (Ubody), Inside_Stubs => True);\n+      end if;\n+\n+      --  Make entry for new file in file table\n+\n+      Get_Name_String (Reference_Name (File));\n+      File_Name := new String'(Name_Buffer (1 .. Name_Len));\n+\n+      --  For subunits, also retrieve the file name of the unit. Only do so if\n+      --  unit has an associated compilation unit.\n+\n+      if Present (Cunit (Unit (File)))\n+        and then Nkind (Unit (Cunit (Unit (File)))) = N_Subunit\n+      then\n+         Get_Name_String (Reference_Name (Main_Source_File));\n+         Unit_File_Name := new String'(Name_Buffer (1 .. Name_Len));\n+      else\n+         Unit_File_Name := null;\n+      end if;\n+\n+      SPARK_File_Table.Append (\n+        (File_Name      => File_Name,\n+         Unit_File_Name => Unit_File_Name,\n+         File_Num       => Dspec,\n+         From_Scope     => From,\n+         To_Scope       => SPARK_Scope_Table.Last));\n+   end Add_SPARK_File;\n \n    ---------------------\n    -- Add_SPARK_Xrefs --\n@@ -905,8 +900,17 @@ package body SPARK_Specific is\n      (Sdep_Table : Unit_Ref_Table;\n       Num_Sdep   : Nat)\n    is\n-      D1 : Pos;\n-      D2 : Pos;\n+      Sdep, Sdep_Next : Pos;\n+      --  Index of the current and next source dependency\n+\n+      Sdep_File : Pos;\n+      --  Index of the file to which the scopes need to be assigned; for\n+      --  library-level instances of generic units this points to the unit\n+      --  of the body, because this is where references are assigned to.\n+\n+      Uspec, Ubody : Unit_Number_Type;\n+      --  Unit numbers for the dependency spec and possibly its body (only in\n+      --  the case of library-level instance of a generic package).\n \n    begin\n       --  Cross-references should have been computed first\n@@ -917,70 +921,82 @@ package body SPARK_Specific is\n \n       --  Generate file and scope SPARK cross-reference information\n \n-      D1 := 1;\n-      while D1 <= Num_Sdep loop\n+      Sdep := 1;\n+      while Sdep <= Num_Sdep loop\n \n-         --  In rare cases, when treating the library-level instantiation of a\n-         --  generic, two consecutive units refer to the same compilation unit\n-         --  node and entity. In that case, treat them as a single unit for the\n-         --  sake of SPARK cross references by passing to Add_SPARK_File.\n+         --  For library-level instantiation of a generic, two consecutive\n+         --  units refer to the same compilation unit node and entity (one to\n+         --  body, one to spec). In that case, treat them as a single unit for\n+         --  the sake of SPARK cross references by passing to Add_SPARK_File.\n \n-         if D1 < Num_Sdep\n-           and then Cunit_Entity (Sdep_Table (D1)) =\n-                    Cunit_Entity (Sdep_Table (D1 + 1))\n+         if Sdep < Num_Sdep\n+           and then Cunit_Entity (Sdep_Table (Sdep)) =\n+                    Cunit_Entity (Sdep_Table (Sdep + 1))\n          then\n             declare\n-               Cunit1 : Node_Id renames Cunit (Sdep_Table (D1));\n-               Cunit2 : Node_Id renames Cunit (Sdep_Table (D1 + 1));\n-\n+               Cunit1 : Node_Id renames Cunit (Sdep_Table (Sdep));\n+               Cunit2 : Node_Id renames Cunit (Sdep_Table (Sdep + 1));\n             begin\n                --  Both Cunit point to compilation unit nodes\n-\n-               pragma Assert\n-                 (Nkind (Cunit1) = N_Compilation_Unit\n-                   and then Nkind (Cunit2) = N_Compilation_Unit);\n+               pragma Assert (Nkind (Cunit1) = N_Compilation_Unit\n+                                and then\n+                              Nkind (Cunit2) = N_Compilation_Unit);\n \n                --  Do not depend on the sorting order, which is based on\n                --  Unit_Name and for library-level instances of nested\n                --  generic-packages they are equal.\n \n-               --  If declaration comes before the body then just set D2\n-\n+               --  If declaration comes before the body\n                if Nkind (Unit (Cunit1)) = N_Package_Declaration\n-                 and then Nkind (Unit (Cunit2)) = N_Package_Body\n+                 and then\n+                  Nkind (Unit (Cunit2)) = N_Package_Body\n                then\n-                  D2 := D1 + 1;\n+                  Uspec := Sdep_Table (Sdep);\n+                  Ubody := Sdep_Table (Sdep + 1);\n+\n+                  Sdep_File := Sdep + 1;\n \n-               --  If body comes before declaration then set D2 and adjust D1\n+               --  If body comes before declaration\n \n                elsif Nkind (Unit (Cunit1)) = N_Package_Body\n-                 and then Nkind (Unit (Cunit2)) = N_Package_Declaration\n+                       and then\n+                     Nkind (Unit (Cunit2)) = N_Package_Declaration\n                then\n-                  D2 := D1;\n-                  D1 := D1 + 1;\n+                  Uspec := Sdep_Table (Sdep + 1);\n+                  Ubody := Sdep_Table (Sdep);\n+\n+                  Sdep_File := Sdep;\n+\n+               --  Otherwise it is an error\n \n                else\n+\n                   raise Program_Error;\n                end if;\n+\n+               Sdep_Next := Sdep + 2;\n             end;\n          else\n-            D2 := D1;\n+            Uspec := Sdep_Table (Sdep);\n+            Ubody := No_Unit;\n+\n+            Sdep_File := Sdep;\n+\n+            Sdep_Next := Sdep + 1;\n          end if;\n \n          --  Skip dependencies with no entity node, e.g. configuration files\n          --  with pragmas (.adc) or target description (.atp), since they\n          --  present no interest for SPARK cross references.\n \n-         if Present (Cunit_Entity (Sdep_Table (D1))) then\n+         if Present (Cunit_Entity (Uspec)) then\n             Add_SPARK_File\n-              (Ubody => Sdep_Table (D1),\n-               Uspec => Sdep_Table (D2),\n-               Dspec => D2);\n+              (Uspec => Uspec,\n+               Ubody => Ubody,\n+               Dspec => Sdep_File);\n          end if;\n \n-         --  ??? this needs a comment\n-\n-         D1 := Pos'Max (D1, D2) + 1;\n+         Sdep := Sdep_Next;\n       end loop;\n \n       --  Fill in the spec information when relevant\n@@ -1037,35 +1053,6 @@ package body SPARK_Specific is\n       Add_SPARK_Xrefs;\n    end Collect_SPARK_Xrefs;\n \n-   --------------------------------\n-   -- Detect_And_Add_SPARK_Scope --\n-   --------------------------------\n-\n-   procedure Detect_And_Add_SPARK_Scope (N : Node_Id) is\n-   begin\n-      if Nkind_In (N, N_Entry_Body,             --  entries\n-                      N_Entry_Declaration)\n-           or else\n-         Nkind_In (N, N_Package_Body,           --  packages\n-                      N_Package_Body_Stub,\n-                      N_Package_Declaration)\n-           or else\n-         Nkind_In (N, N_Protected_Body,         --  protected objects\n-                      N_Protected_Body_Stub,\n-                      N_Protected_Type_Declaration)\n-           or else\n-         Nkind_In (N, N_Subprogram_Body,        --  subprograms\n-                      N_Subprogram_Body_Stub,\n-                      N_Subprogram_Declaration)\n-           or else\n-         Nkind_In (N, N_Task_Body,              --  tasks\n-                      N_Task_Body_Stub,\n-                      N_Task_Type_Declaration)\n-      then\n-         Add_SPARK_Scope (N);\n-      end if;\n-   end Detect_And_Add_SPARK_Scope;\n-\n    -------------------------------------\n    -- Enclosing_Subprogram_Or_Package --\n    -------------------------------------\n@@ -1245,65 +1232,44 @@ package body SPARK_Specific is\n \n    procedure Traverse_Compilation_Unit\n      (CU           : Node_Id;\n-      Process      : Node_Processing;\n       Inside_Stubs : Boolean)\n    is\n       Lu : Node_Id;\n \n-   begin\n-      --  Get Unit (checking case of subunit)\n-\n-      Lu := Unit (CU);\n-\n-      if Nkind (Lu) = N_Subunit then\n-         Lu := Proper_Body (Lu);\n-      end if;\n-\n-      --  Do not add scopes for generic units\n+      procedure Traverse_Block                      (N : Node_Id);\n+      procedure Traverse_Declarations_And_HSS       (N : Node_Id);\n+      procedure Traverse_Declaration_Or_Statement   (N : Node_Id);\n+      procedure Traverse_Declarations_Or_Statements (L : List_Id);\n+      procedure Traverse_Handled_Statement_Sequence (N : Node_Id);\n+      procedure Traverse_Package_Body               (N : Node_Id);\n+      procedure Traverse_Visible_And_Private_Parts  (N : Node_Id);\n+      procedure Traverse_Protected_Body             (N : Node_Id);\n+      procedure Traverse_Subprogram_Body            (N : Node_Id);\n+      procedure Traverse_Task_Body                  (N : Node_Id);\n \n-      if Nkind (Lu) = N_Package_Body\n-        and then Ekind (Corresponding_Spec (Lu)) in Generic_Unit_Kind\n-      then\n-         return;\n-      end if;\n-\n-      --  Call Process on all declarations\n-\n-      if Nkind (Lu) in N_Declaration\n-        or else Nkind (Lu) in N_Later_Decl_Item\n-      then\n-         Process (Lu);\n-      end if;\n+      --  Traverse corresponding construct, calling Process on all declarations\n \n-      --  Traverse the unit\n+      --------------------\n+      -- Traverse_Block --\n+      --------------------\n \n-      Traverse_Declaration_Or_Statement (Lu, Process, Inside_Stubs);\n-   end Traverse_Compilation_Unit;\n+      procedure Traverse_Block (N : Node_Id) renames\n+        Traverse_Declarations_And_HSS;\n \n-   ---------------------------------------\n-   -- Traverse_Declaration_Or_Statement --\n-   ---------------------------------------\n+      ---------------------------------------\n+      -- Traverse_Declaration_Or_Statement --\n+      ---------------------------------------\n \n-   procedure Traverse_Declaration_Or_Statement\n-     (N            : Node_Id;\n-      Process      : Node_Processing;\n-      Inside_Stubs : Boolean)\n-   is\n-   begin\n-      case Nkind (N) is\n+      procedure Traverse_Declaration_Or_Statement (N : Node_Id)\n+      is\n+      begin\n+         case Nkind (N) is\n          when N_Package_Declaration =>\n-            declare\n-               Spec : constant Node_Id := Specification (N);\n-            begin\n-               Traverse_Declarations_Or_Statements\n-                 (Visible_Declarations (Spec), Process, Inside_Stubs);\n-               Traverse_Declarations_Or_Statements\n-                 (Private_Declarations (Spec), Process, Inside_Stubs);\n-            end;\n+            Traverse_Visible_And_Private_Parts (Specification (N));\n \n          when N_Package_Body =>\n             if Ekind (Defining_Entity (N)) /= E_Generic_Package then\n-               Traverse_Package_Body (N, Process, Inside_Stubs);\n+               Traverse_Package_Body (N);\n             end if;\n \n          when N_Package_Body_Stub =>\n@@ -1315,19 +1281,19 @@ package body SPARK_Specific is\n                     and then\n                       Ekind (Defining_Entity (Body_N)) /= E_Generic_Package\n                   then\n-                     Traverse_Package_Body (Body_N, Process, Inside_Stubs);\n+                     Traverse_Package_Body (Body_N);\n                   end if;\n                end;\n             end if;\n \n-         when N_Subprogram_Declaration =>\n-            null;\n-\n-         when N_Entry_Body | N_Subprogram_Body =>\n+         when N_Subprogram_Body =>\n             if not Is_Generic_Subprogram (Defining_Entity (N)) then\n-               Traverse_Subprogram_Body (N, Process, Inside_Stubs);\n+               Traverse_Subprogram_Body (N);\n             end if;\n \n+         when N_Entry_Body =>\n+            Traverse_Subprogram_Body (N);\n+\n          when N_Subprogram_Body_Stub =>\n             if Present (Library_Unit (N)) then\n                declare\n@@ -1337,75 +1303,45 @@ package body SPARK_Specific is\n                     and then\n                       not Is_Generic_Subprogram (Defining_Entity (Body_N))\n                   then\n-                     Traverse_Subprogram_Body (Body_N, Process, Inside_Stubs);\n+                     Traverse_Subprogram_Body (Body_N);\n                   end if;\n                end;\n             end if;\n \n          when N_Protected_Body =>\n-            Traverse_Protected_Body (N, Process, Inside_Stubs);\n+            Traverse_Protected_Body (N);\n \n          when N_Protected_Body_Stub =>\n             if Present (Library_Unit (N)) then\n-               declare\n-                  Body_N : constant Node_Id := Get_Body_From_Stub (N);\n-               begin\n-                  if Inside_Stubs then\n-                     Traverse_Declarations_Or_Statements\n-                       (Declarations (Body_N), Process, Inside_Stubs);\n-                  end if;\n-               end;\n+               if Inside_Stubs then\n+                  Traverse_Protected_Body (Get_Body_From_Stub (N));\n+               end if;\n             end if;\n \n          when N_Protected_Type_Declaration | N_Single_Protected_Declaration =>\n-            declare\n-               Def : constant Node_Id := Protected_Definition (N);\n-            begin\n-               Traverse_Declarations_Or_Statements\n-                 (Visible_Declarations (Def), Process, Inside_Stubs);\n-               Traverse_Declarations_Or_Statements\n-                 (Private_Declarations (Def), Process, Inside_Stubs);\n-            end;\n+            Traverse_Visible_And_Private_Parts (Protected_Definition (N));\n \n          when N_Task_Definition =>\n-            Traverse_Declarations_Or_Statements\n-              (Visible_Declarations (N), Process, Inside_Stubs);\n-            Traverse_Declarations_Or_Statements\n-              (Private_Declarations (N), Process, Inside_Stubs);\n+            Traverse_Visible_And_Private_Parts (N);\n \n          when N_Task_Body =>\n-            Traverse_Declarations_Or_Statements\n-              (Declarations (N), Process, Inside_Stubs);\n-            Traverse_Handled_Statement_Sequence\n-              (Handled_Statement_Sequence (N), Process, Inside_Stubs);\n+            Traverse_Task_Body (N);\n \n          when N_Task_Body_Stub =>\n             if Present (Library_Unit (N)) then\n-               declare\n-                  Body_N : constant Node_Id := Get_Body_From_Stub (N);\n-               begin\n-                  if Inside_Stubs then\n-                     Traverse_Declarations_Or_Statements\n-                       (Declarations (Body_N), Process, Inside_Stubs);\n-                     Traverse_Handled_Statement_Sequence\n-                       (Handled_Statement_Sequence (Body_N), Process,\n-                        Inside_Stubs);\n-                  end if;\n-               end;\n+               if Inside_Stubs then\n+                  Traverse_Task_Body (Get_Body_From_Stub (N));\n+               end if;\n             end if;\n \n          when N_Block_Statement =>\n-            Traverse_Declarations_Or_Statements\n-              (Declarations (N), Process, Inside_Stubs);\n-            Traverse_Handled_Statement_Sequence\n-              (Handled_Statement_Sequence (N), Process, Inside_Stubs);\n+            Traverse_Block (N);\n \n          when N_If_Statement =>\n \n             --  Traverse the statements in the THEN part\n \n-            Traverse_Declarations_Or_Statements\n-              (Then_Statements (N), Process, Inside_Stubs);\n+            Traverse_Declarations_Or_Statements (Then_Statements (N));\n \n             --  Loop through ELSIF parts if present\n \n@@ -1416,16 +1352,15 @@ package body SPARK_Specific is\n                begin\n                   while Present (Elif) loop\n                      Traverse_Declarations_Or_Statements\n-                       (Then_Statements (Elif), Process, Inside_Stubs);\n+                       (Then_Statements (Elif));\n                      Next (Elif);\n                   end loop;\n                end;\n             end if;\n \n             --  Finally traverse the ELSE statements if present\n \n-            Traverse_Declarations_Or_Statements\n-              (Else_Statements (N), Process, Inside_Stubs);\n+            Traverse_Declarations_Or_Statements (Else_Statements (N));\n \n          when N_Case_Statement =>\n \n@@ -1436,129 +1371,154 @@ package body SPARK_Specific is\n             begin\n                Alt := First (Alternatives (N));\n                while Present (Alt) loop\n-                  Traverse_Declarations_Or_Statements\n-                    (Statements (Alt), Process, Inside_Stubs);\n+                  Traverse_Declarations_Or_Statements (Statements (Alt));\n                   Next (Alt);\n                end loop;\n             end;\n \n          when N_Extended_Return_Statement =>\n             Traverse_Handled_Statement_Sequence\n-              (Handled_Statement_Sequence (N), Process, Inside_Stubs);\n+              (Handled_Statement_Sequence (N));\n \n          when N_Loop_Statement =>\n-            Traverse_Declarations_Or_Statements\n-              (Statements (N), Process, Inside_Stubs);\n+            Traverse_Declarations_Or_Statements (Statements (N));\n \n-         --  Generic declarations are ignored\n+            --  Generic declarations are ignored\n \n          when others =>\n             null;\n-      end case;\n-   end Traverse_Declaration_Or_Statement;\n+         end case;\n+      end Traverse_Declaration_Or_Statement;\n \n-   -----------------------------------------\n-   -- Traverse_Declarations_Or_Statements --\n-   -----------------------------------------\n+      -----------------------------------\n+      -- Traverse_Declarations_And_HSS --\n+      -----------------------------------\n \n-   procedure Traverse_Declarations_Or_Statements\n-     (L            : List_Id;\n-      Process      : Node_Processing;\n-      Inside_Stubs : Boolean)\n-   is\n-      N : Node_Id;\n+      procedure Traverse_Declarations_And_HSS (N : Node_Id)\n+      is\n+      begin\n+         Traverse_Declarations_Or_Statements (Declarations (N));\n+         Traverse_Handled_Statement_Sequence (Handled_Statement_Sequence (N));\n+      end Traverse_Declarations_And_HSS;\n \n-   begin\n-      --  Loop through statements or declarations\n+      -----------------------------------------\n+      -- Traverse_Declarations_Or_Statements --\n+      -----------------------------------------\n \n-      N := First (L);\n-      while Present (N) loop\n-         --  Call Process on all declarations\n+      procedure Traverse_Declarations_Or_Statements (L : List_Id)\n+      is\n+         N : Node_Id;\n \n-         if Nkind (N) in N_Declaration\n+      begin\n+         --  Loop through statements or declarations\n+\n+         N := First (L);\n+         while Present (N) loop\n+            --  Call Process on all declarations\n+\n+            if Nkind (N) in N_Declaration\n               or else\n-            Nkind (N) in N_Later_Decl_Item\n+                Nkind (N) in N_Later_Decl_Item\n               or else\n-            Nkind (N) = N_Entry_Body\n-         then\n-            Process (N);\n+                Nkind (N) = N_Entry_Body\n+            then\n+               Process (N);\n+            end if;\n+\n+            Traverse_Declaration_Or_Statement (N);\n+\n+            Next (N);\n+         end loop;\n+      end Traverse_Declarations_Or_Statements;\n+\n+      -----------------------------------------\n+      -- Traverse_Handled_Statement_Sequence --\n+      -----------------------------------------\n+\n+      procedure Traverse_Handled_Statement_Sequence (N : Node_Id)\n+      is\n+         Handler : Node_Id;\n+\n+      begin\n+         if Present (N) then\n+            Traverse_Declarations_Or_Statements (Statements (N));\n+\n+            if Present (Exception_Handlers (N)) then\n+               Handler := First (Exception_Handlers (N));\n+               while Present (Handler) loop\n+                  Traverse_Declarations_Or_Statements (Statements (Handler));\n+                  Next (Handler);\n+               end loop;\n+            end if;\n          end if;\n+      end Traverse_Handled_Statement_Sequence;\n \n-         Traverse_Declaration_Or_Statement (N, Process, Inside_Stubs);\n+      ---------------------------\n+      -- Traverse_Package_Body --\n+      ---------------------------\n \n-         Next (N);\n-      end loop;\n-   end Traverse_Declarations_Or_Statements;\n+      procedure Traverse_Package_Body (N : Node_Id) renames\n+        Traverse_Declarations_And_HSS;\n \n-   -----------------------------------------\n-   -- Traverse_Handled_Statement_Sequence --\n-   -----------------------------------------\n+      -----------------------------\n+      -- Traverse_Protected_Body --\n+      -----------------------------\n \n-   procedure Traverse_Handled_Statement_Sequence\n-     (N            : Node_Id;\n-      Process      : Node_Processing;\n-      Inside_Stubs : Boolean)\n-   is\n-      Handler : Node_Id;\n+      procedure Traverse_Protected_Body (N : Node_Id) is\n+      begin\n+         Traverse_Declarations_Or_Statements (Declarations (N));\n+      end Traverse_Protected_Body;\n+\n+      ------------------------------\n+      -- Traverse_Subprogram_Body --\n+      ------------------------------\n+\n+      procedure Traverse_Subprogram_Body (N : Node_Id) renames\n+        Traverse_Declarations_And_HSS;\n+\n+      ------------------------\n+      -- Traverse_Task_Body --\n+      ------------------------\n+\n+      procedure Traverse_Task_Body (N : Node_Id) renames\n+        Traverse_Declarations_And_HSS;\n+\n+      procedure Traverse_Visible_And_Private_Parts (N : Node_Id) is\n+      begin\n+         Traverse_Declarations_Or_Statements (Visible_Declarations (N));\n+         Traverse_Declarations_Or_Statements (Private_Declarations (N));\n+      end Traverse_Visible_And_Private_Parts;\n+\n+   --  Start of processing for Traverse_Compilation_Unit\n \n    begin\n-      if Present (N) then\n-         Traverse_Declarations_Or_Statements\n-           (Statements (N), Process, Inside_Stubs);\n-\n-         if Present (Exception_Handlers (N)) then\n-            Handler := First (Exception_Handlers (N));\n-            while Present (Handler) loop\n-               Traverse_Declarations_Or_Statements\n-                 (Statements (Handler), Process, Inside_Stubs);\n-               Next (Handler);\n-            end loop;\n-         end if;\n+      --  Get Unit (checking case of subunit)\n+\n+      Lu := Unit (CU);\n+\n+      if Nkind (Lu) = N_Subunit then\n+         Lu := Proper_Body (Lu);\n       end if;\n-   end Traverse_Handled_Statement_Sequence;\n \n-   ---------------------------\n-   -- Traverse_Package_Body --\n-   ---------------------------\n+      --  Do not add scopes for generic units\n \n-   procedure Traverse_Package_Body\n-     (N            : Node_Id;\n-      Process      : Node_Processing;\n-      Inside_Stubs : Boolean) is\n-   begin\n-      Traverse_Declarations_Or_Statements\n-        (Declarations (N), Process, Inside_Stubs);\n-      Traverse_Handled_Statement_Sequence\n-        (Handled_Statement_Sequence (N), Process, Inside_Stubs);\n-   end Traverse_Package_Body;\n-\n-   -----------------------------\n-   -- Traverse_Protected_Body --\n-   -----------------------------\n-\n-   procedure Traverse_Protected_Body\n-     (N            : Node_Id;\n-      Process      : Node_Processing;\n-      Inside_Stubs : Boolean) is\n-   begin\n-      Traverse_Declarations_Or_Statements\n-        (Declarations (N), Process, Inside_Stubs);\n-   end Traverse_Protected_Body;\n+      if Nkind (Lu) = N_Package_Body\n+        and then Ekind (Corresponding_Spec (Lu)) in Generic_Unit_Kind\n+      then\n+         return;\n+      end if;\n \n-   ------------------------------\n-   -- Traverse_Subprogram_Body --\n-   ------------------------------\n+      --  Call Process on all declarations\n \n-   procedure Traverse_Subprogram_Body\n-     (N            : Node_Id;\n-      Process      : Node_Processing;\n-      Inside_Stubs : Boolean)\n-   is\n-   begin\n-      Traverse_Declarations_Or_Statements\n-        (Declarations (N), Process, Inside_Stubs);\n-      Traverse_Handled_Statement_Sequence\n-        (Handled_Statement_Sequence (N), Process, Inside_Stubs);\n-   end Traverse_Subprogram_Body;\n+      if Nkind (Lu) in N_Declaration\n+        or else Nkind (Lu) in N_Later_Decl_Item\n+      then\n+         Process (Lu);\n+      end if;\n+\n+      --  Traverse the unit\n+\n+      Traverse_Declaration_Or_Statement (Lu);\n+   end Traverse_Compilation_Unit;\n \n end SPARK_Specific;"}, {"sha": "5325fc0eadd15261e60e0e16bf168af492a96d70", "filename": "gcc/ada/lib-xref.ads", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ffbef99665102871af334c1e6d2c8f1e77fd6b7/gcc%2Fada%2Flib-xref.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ffbef99665102871af334c1e6d2c8f1e77fd6b7/gcc%2Fada%2Flib-xref.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-xref.ads?ref=7ffbef99665102871af334c1e6d2c8f1e77fd6b7", "patch": "@@ -639,16 +639,6 @@ package Lib.Xref is\n       --  This procedure is called to record a dereference. N is the location\n       --  of the dereference.\n \n-      type Node_Processing is access procedure (N : Node_Id);\n-\n-      procedure Traverse_Compilation_Unit\n-        (CU           : Node_Id;\n-         Process      : Node_Processing;\n-         Inside_Stubs : Boolean);\n-      --  Call Process on all declarations in compilation unit CU. If\n-      --  Inside_Stubs is True, then the body of stubs is also traversed.\n-      --  Generic declarations are ignored.\n-\n       procedure Collect_SPARK_Xrefs\n         (Sdep_Table : Unit_Ref_Table;\n          Num_Sdep   : Nat);"}, {"sha": "704b1ea10b5660a59ef884b530604702db5225f1", "filename": "gcc/ada/spark_xrefs.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ffbef99665102871af334c1e6d2c8f1e77fd6b7/gcc%2Fada%2Fspark_xrefs.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ffbef99665102871af334c1e6d2c8f1e77fd6b7/gcc%2Fada%2Fspark_xrefs.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fspark_xrefs.ads?ref=7ffbef99665102871af334c1e6d2c8f1e77fd6b7", "patch": "@@ -285,7 +285,7 @@ package SPARK_Xrefs is\n       File_Num : Nat;\n       --  Set to the file dependency number for the scope\n \n-      Scope_Num : Nat;\n+      Scope_Num : Pos;\n       --  Set to the scope number for the scope\n \n       Spec_File_Num : Nat;"}, {"sha": "20093c19abd2f6af7936c4612847294285424d1a", "filename": "gcc/ada/types.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ffbef99665102871af334c1e6d2c8f1e77fd6b7/gcc%2Fada%2Ftypes.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ffbef99665102871af334c1e6d2c8f1e77fd6b7/gcc%2Fada%2Ftypes.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftypes.ads?ref=7ffbef99665102871af334c1e6d2c8f1e77fd6b7", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -554,7 +554,7 @@ package Types is\n    -- Types used for Library Management --\n    ---------------------------------------\n \n-   type Unit_Number_Type is new Int;\n+   type Unit_Number_Type is new Int range -1 .. Int'Last;\n    --  Unit number. The main source is unit 0, and subsidiary sources have\n    --  non-zero numbers starting with 1. Unit numbers are used to index the\n    --  Units table in package Lib."}]}