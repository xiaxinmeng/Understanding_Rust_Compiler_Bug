{"sha": "4fb94ef9aa797bb3ccd23157aa8fd66ff8e80bc0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGZiOTRlZjlhYTc5N2JiM2NjZDIzMTU3YWE4ZmQ2NmZmOGU4MGJjMA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2015-09-17T11:06:57Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2015-09-17T11:06:57Z"}, "message": "re PR middle-end/65958 (-fstack-check breaks alloca on architectures using generic stack checking)\n\n\tPR middle-end/65958\n\t* config/arm/linux-elf.h (STACK_CHECK_STATIC_BUILTIN): Define.\n\t* config/arm/arm-protos.h (output_probe_stack_range): Declare.\n\t* config/arm/arm.c: Include common/common-target.h.\n\t(use_return_insn): Return 0 if the static chain register was saved\n\tabove a non-APCS frame.\n\t(arm_compute_static_chain_stack_bytes): Adjust for stack checking.\n\t(struct scratch_reg): New.\n\t(get_scratch_register_on_entry): New function.\n\t(release_scratch_register_on_entry): Likewise.\n\t(arm_emit_probe_stack_range): Likewise.\n\t(output_probe_stack_range): Likewise.\n\t(arm_expand_prologue): Factor out code dealing with the IP register\n\tfor nested function and adjust it for stack checking.\n\tInvoke arm_emit_probe_stack_range if static builtin stack checking\n\tis enabled.\n\t(thumb1_expand_prologue): Sorry out if static builtin stack checking\n\tis enabled.\n\t(arm_expand_epilogue): Add the saved static chain register, if any, to\n\tthe amount of pre-pushed registers to pop.\n\t(arm_frame_pointer_required): Return true if static stack checking is\n\tenabled and we want to catch the exception with the EABI unwinder.\n\t* config/arm/unspecs.md (UNSPEC_PROBE_STACK): New constant.\n\t(UNSPEC_PROBE_STACK_RANGE): Likewise.\n\t* config/arm/arm.md (probe_stack): New insn.\n\t(probe_stack_range): Likewise.\n\nFrom-SVN: r227860", "tree": {"sha": "bd682013d2435ee656e6f825c2b7bede0f1aa2aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bd682013d2435ee656e6f825c2b7bede0f1aa2aa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4fb94ef9aa797bb3ccd23157aa8fd66ff8e80bc0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fb94ef9aa797bb3ccd23157aa8fd66ff8e80bc0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4fb94ef9aa797bb3ccd23157aa8fd66ff8e80bc0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fb94ef9aa797bb3ccd23157aa8fd66ff8e80bc0/comments", "author": null, "committer": null, "parents": [{"sha": "2e96ac06b296e3b66440d5e862dd1761e7a6cb39", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e96ac06b296e3b66440d5e862dd1761e7a6cb39", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e96ac06b296e3b66440d5e862dd1761e7a6cb39"}], "stats": {"total": 620, "additions": 507, "deletions": 113}, "files": [{"sha": "8ac2d3da26689f26a515abdcb694c5367462b912", "filename": "gcc/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fb94ef9aa797bb3ccd23157aa8fd66ff8e80bc0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fb94ef9aa797bb3ccd23157aa8fd66ff8e80bc0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4fb94ef9aa797bb3ccd23157aa8fd66ff8e80bc0", "patch": "@@ -1,3 +1,32 @@\n+2015-09-17  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\tPR middle-end/65958\n+\t* config/arm/linux-elf.h (STACK_CHECK_STATIC_BUILTIN): Define.\n+\t* config/arm/arm-protos.h (output_probe_stack_range): Declare.\n+\t* config/arm/arm.c: Include common/common-target.h.\n+\t(use_return_insn): Return 0 if the static chain register was saved\n+\tabove a non-APCS frame.\n+\t(arm_compute_static_chain_stack_bytes): Adjust for stack checking.\n+\t(struct scratch_reg): New.\n+\t(get_scratch_register_on_entry): New function.\n+\t(release_scratch_register_on_entry): Likewise.\n+\t(arm_emit_probe_stack_range): Likewise.\n+\t(output_probe_stack_range): Likewise.\n+\t(arm_expand_prologue): Factor out code dealing with the IP register\n+\tfor nested function and adjust it for stack checking.\n+\tInvoke arm_emit_probe_stack_range if static builtin stack checking\n+\tis enabled.\n+\t(thumb1_expand_prologue): Sorry out if static builtin stack checking\n+\tis enabled.\n+\t(arm_expand_epilogue): Add the saved static chain register, if any, to\n+\tthe amount of pre-pushed registers to pop.\n+\t(arm_frame_pointer_required): Return true if static stack checking is\n+\tenabled and we want to catch the exception with the EABI unwinder.\n+\t* config/arm/unspecs.md (UNSPEC_PROBE_STACK): New constant.\n+\t(UNSPEC_PROBE_STACK_RANGE): Likewise.\n+\t* config/arm/arm.md (probe_stack): New insn.\n+\t(probe_stack_range): Likewise.\n+\n 2015-09-17  Richard Biener  <rguenther@suse.de>\n \n \t* genmatch.c (parser::parse_expr): Improve error message"}, {"sha": "f9b12764b094c4931e2201bb23aa211a17be3bc9", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fb94ef9aa797bb3ccd23157aa8fd66ff8e80bc0/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fb94ef9aa797bb3ccd23157aa8fd66ff8e80bc0/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=4fb94ef9aa797bb3ccd23157aa8fd66ff8e80bc0", "patch": "@@ -146,6 +146,7 @@ extern const char *output_add_immediate (rtx *);\n extern const char *arithmetic_instr (rtx, int);\n extern void output_ascii_pseudo_op (FILE *, const unsigned char *, int);\n extern const char *output_return_instruction (rtx, bool, bool, bool);\n+extern const char *output_probe_stack_range (rtx, rtx);\n extern void arm_poke_function_name (FILE *, const char *);\n extern void arm_final_prescan_insn (rtx_insn *);\n extern int arm_debugger_arg_offset (int, rtx);"}, {"sha": "b0239776b0c3db9811ce38ed44c06a30d2f3b7e5", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 423, "deletions": 113, "changes": 536, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fb94ef9aa797bb3ccd23157aa8fd66ff8e80bc0/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fb94ef9aa797bb3ccd23157aa8fd66ff8e80bc0/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=4fb94ef9aa797bb3ccd23157aa8fd66ff8e80bc0", "patch": "@@ -61,6 +61,7 @@\n #include \"tm_p.h\"\n #include \"target.h\"\n #include \"sched-int.h\"\n+#include \"common/common-target.h\"\n #include \"debug.h\"\n #include \"langhooks.h\"\n #include \"intl.h\"\n@@ -3669,7 +3670,11 @@ use_return_insn (int iscond, rtx sibling)\n       /* Or if there is a stack adjustment.  However, if the stack pointer\n \t is saved on the stack, we can use a pre-incrementing stack load.  */\n       || !(stack_adjust == 0 || (TARGET_APCS_FRAME && frame_pointer_needed\n-\t\t\t\t && stack_adjust == 4)))\n+\t\t\t\t && stack_adjust == 4))\n+      /* Or if the static chain register was saved above the frame, under the\n+\t assumption that the stack pointer isn't saved on the stack.  */\n+      || (!(TARGET_APCS_FRAME && frame_pointer_needed)\n+          && arm_compute_static_chain_stack_bytes() != 0))\n     return 0;\n \n   saved_int_regs = offsets->saved_regs_mask;\n@@ -19174,8 +19179,10 @@ static int\n arm_compute_static_chain_stack_bytes (void)\n {\n   /* See the defining assertion in arm_expand_prologue.  */\n-  if (TARGET_APCS_FRAME && frame_pointer_needed && TARGET_ARM\n-      && IS_NESTED (arm_current_func_type ())\n+  if (IS_NESTED (arm_current_func_type ())\n+      && ((TARGET_APCS_FRAME && frame_pointer_needed && TARGET_ARM)\n+\t  || (flag_stack_check == STATIC_BUILTIN_STACK_CHECK\n+\t      && !df_regs_ever_live_p (LR_REGNUM)))\n       && arm_r3_live_at_start_p ()\n       && crtl->args.pretend_args_size == 0)\n     return 4;\n@@ -19270,7 +19277,6 @@ arm_compute_save_reg_mask (void)\n   return save_reg_mask;\n }\n \n-\n /* Compute a bit mask of which registers need to be\n    saved on the stack for the current function.  */\n static unsigned long\n@@ -21098,6 +21104,240 @@ thumb_set_frame_pointer (arm_stack_offsets *offsets)\n   RTX_FRAME_RELATED_P (insn) = 1;\n }\n \n+struct scratch_reg {\n+  rtx reg;\n+  bool saved;\n+};\n+\n+/* Return a short-lived scratch register for use as a 2nd scratch register on\n+   function entry after the registers are saved in the prologue.  This register\n+   must be released by means of release_scratch_register_on_entry.  IP is not\n+   considered since it is always used as the 1st scratch register if available.\n+\n+   REGNO1 is the index number of the 1st scratch register and LIVE_REGS is the\n+   mask of live registers.  */\n+\n+static void\n+get_scratch_register_on_entry (struct scratch_reg *sr, unsigned int regno1,\n+\t\t\t       unsigned long live_regs)\n+{\n+  int regno = -1;\n+\n+  sr->saved = false;\n+\n+  if (regno1 != LR_REGNUM && (live_regs & (1 << LR_REGNUM)) != 0)\n+    regno = LR_REGNUM;\n+  else\n+    {\n+      unsigned int i;\n+\n+      for (i = 4; i < 11; i++)\n+\tif (regno1 != i && (live_regs & (1 << i)) != 0)\n+\t  {\n+\t    regno = i;\n+\t    break;\n+\t  }\n+\n+      if (regno < 0)\n+\t{\n+\t  /* If IP is used as the 1st scratch register for a nested function,\n+\t     then either r3 wasn't available or is used to preserve IP.  */\n+\t  if (regno1 == IP_REGNUM && IS_NESTED (arm_current_func_type ()))\n+\t    regno1 = 3;\n+\t  regno = (regno1 == 3 ? 2 : 3);\n+\t  sr->saved\n+\t    = REGNO_REG_SET_P (df_get_live_out (ENTRY_BLOCK_PTR_FOR_FN (cfun)),\n+\t\t\t       regno);\n+\t}\n+    }\n+\n+  sr->reg = gen_rtx_REG (SImode, regno);\n+  if (sr->saved)\n+    {\n+      rtx addr = gen_rtx_PRE_DEC (Pmode, stack_pointer_rtx);\n+      rtx insn = emit_set_insn (gen_frame_mem (SImode, addr), sr->reg);\n+      rtx x = gen_rtx_SET (stack_pointer_rtx,\n+\t\t           plus_constant (Pmode, stack_pointer_rtx, -4));\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+      add_reg_note (insn, REG_FRAME_RELATED_EXPR, x);\n+    }\n+}\n+\n+/* Release a scratch register obtained from the preceding function.  */\n+\n+static void\n+release_scratch_register_on_entry (struct scratch_reg *sr)\n+{\n+  if (sr->saved)\n+    {\n+      rtx addr = gen_rtx_POST_INC (Pmode, stack_pointer_rtx);\n+      rtx insn = emit_set_insn (sr->reg, gen_frame_mem (SImode, addr));\n+      rtx x = gen_rtx_SET (stack_pointer_rtx,\n+\t\t\t   plus_constant (Pmode, stack_pointer_rtx, 4));\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+      add_reg_note (insn, REG_FRAME_RELATED_EXPR, x);\n+    }\n+}\n+\n+#define PROBE_INTERVAL (1 << STACK_CHECK_PROBE_INTERVAL_EXP)\n+\n+#if PROBE_INTERVAL > 4096\n+#error Cannot use indexed addressing mode for stack probing\n+#endif\n+\n+/* Emit code to probe a range of stack addresses from FIRST to FIRST+SIZE,\n+   inclusive.  These are offsets from the current stack pointer.  REGNO1\n+   is the index number of the 1st scratch register and LIVE_REGS is the\n+   mask of live registers.  */\n+\n+static void\n+arm_emit_probe_stack_range (HOST_WIDE_INT first, HOST_WIDE_INT size,\n+\t\t\t    unsigned int regno1, unsigned long live_regs)\n+{\n+  rtx reg1 = gen_rtx_REG (Pmode, regno1);\n+\n+  /* See if we have a constant small number of probes to generate.  If so,\n+     that's the easy case.  */\n+  if (size <= PROBE_INTERVAL)\n+    {\n+      emit_move_insn (reg1, GEN_INT (first + PROBE_INTERVAL));\n+      emit_set_insn (reg1, gen_rtx_MINUS (Pmode, stack_pointer_rtx, reg1));\n+      emit_stack_probe (plus_constant (Pmode, reg1, PROBE_INTERVAL - size));\n+    }\n+\n+  /* The run-time loop is made up of 10 insns in the generic case while the\n+     compile-time loop is made up of 4+2*(n-2) insns for n # of intervals.  */\n+  else if (size <= 5 * PROBE_INTERVAL)\n+    {\n+      HOST_WIDE_INT i, rem;\n+\n+      emit_move_insn (reg1, GEN_INT (first + PROBE_INTERVAL));\n+      emit_set_insn (reg1, gen_rtx_MINUS (Pmode, stack_pointer_rtx, reg1));\n+      emit_stack_probe (reg1);\n+\n+      /* Probe at FIRST + N * PROBE_INTERVAL for values of N from 2 until\n+\t it exceeds SIZE.  If only two probes are needed, this will not\n+\t generate any code.  Then probe at FIRST + SIZE.  */\n+      for (i = 2 * PROBE_INTERVAL; i < size; i += PROBE_INTERVAL)\n+\t{\n+\t  emit_set_insn (reg1, plus_constant (Pmode, reg1, -PROBE_INTERVAL));\n+\t  emit_stack_probe (reg1);\n+\t}\n+\n+      rem = size - (i - PROBE_INTERVAL);\n+      if (rem > 4095 || (TARGET_THUMB2 && rem > 255))\n+\t{\n+\t  emit_set_insn (reg1, plus_constant (Pmode, reg1, -PROBE_INTERVAL));\n+\t  emit_stack_probe (plus_constant (Pmode, reg1, PROBE_INTERVAL - rem));\n+\t}\n+      else\n+\temit_stack_probe (plus_constant (Pmode, reg1, -rem));\n+    }\n+\n+  /* Otherwise, do the same as above, but in a loop.  Note that we must be\n+     extra careful with variables wrapping around because we might be at\n+     the very top (or the very bottom) of the address space and we have\n+     to be able to handle this case properly; in particular, we use an\n+     equality test for the loop condition.  */\n+  else\n+    {\n+      HOST_WIDE_INT rounded_size;\n+      struct scratch_reg sr;\n+\n+      get_scratch_register_on_entry (&sr, regno1, live_regs);\n+\n+      emit_move_insn (reg1, GEN_INT (first));\n+\n+\n+      /* Step 1: round SIZE to the previous multiple of the interval.  */\n+\n+      rounded_size = size & -PROBE_INTERVAL;\n+      emit_move_insn (sr.reg, GEN_INT (rounded_size));\n+\n+\n+      /* Step 2: compute initial and final value of the loop counter.  */\n+\n+      /* TEST_ADDR = SP + FIRST.  */\n+      emit_set_insn (reg1, gen_rtx_MINUS (Pmode, stack_pointer_rtx, reg1));\n+\n+      /* LAST_ADDR = SP + FIRST + ROUNDED_SIZE.  */\n+      emit_set_insn (sr.reg, gen_rtx_MINUS (Pmode, reg1, sr.reg));\n+\n+\n+      /* Step 3: the loop\n+\n+\t while (TEST_ADDR != LAST_ADDR)\n+\t   {\n+\t     TEST_ADDR = TEST_ADDR + PROBE_INTERVAL\n+\t     probe at TEST_ADDR\n+\t   }\n+\n+\t probes at FIRST + N * PROBE_INTERVAL for values of N from 1\n+\t until it is equal to ROUNDED_SIZE.  */\n+\n+      emit_insn (gen_probe_stack_range (reg1, reg1, sr.reg));\n+\n+\n+      /* Step 4: probe at FIRST + SIZE if we cannot assert at compile-time\n+\t that SIZE is equal to ROUNDED_SIZE.  */\n+\n+      if (size != rounded_size)\n+\t{\n+\t  HOST_WIDE_INT rem = size - rounded_size;\n+\n+\t  if (rem > 4095 || (TARGET_THUMB2 && rem > 255))\n+\t    {\n+\t      emit_set_insn (sr.reg,\n+\t\t\t     plus_constant (Pmode, sr.reg, -PROBE_INTERVAL));\n+\t      emit_stack_probe (plus_constant (Pmode, sr.reg,\n+\t\t\t\t\t       PROBE_INTERVAL - rem));\n+\t    }\n+\t  else\n+\t    emit_stack_probe (plus_constant (Pmode, sr.reg, -rem));\n+\t}\n+\n+      release_scratch_register_on_entry (&sr);\n+    }\n+\n+  /* Make sure nothing is scheduled before we are done.  */\n+  emit_insn (gen_blockage ());\n+}\n+\n+/* Probe a range of stack addresses from REG1 to REG2 inclusive.  These are\n+   absolute addresses.  */\n+\n+const char *\n+output_probe_stack_range (rtx reg1, rtx reg2)\n+{\n+  static int labelno = 0;\n+  char loop_lab[32];\n+  rtx xops[2];\n+\n+  ASM_GENERATE_INTERNAL_LABEL (loop_lab, \"LPSRL\", labelno++);\n+\n+  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, loop_lab);\n+\n+   /* Test if TEST_ADDR == LAST_ADDR.  */\n+  xops[0] = reg1;\n+  xops[1] = reg2;\n+  output_asm_insn (\"cmp\\t%0, %1\", xops);\n+\n+  if (TARGET_THUMB2)\n+    fputs (\"\\tittt\\tne\\n\", asm_out_file);\n+\n+  /* TEST_ADDR = TEST_ADDR + PROBE_INTERVAL.  */\n+  xops[1] = GEN_INT (PROBE_INTERVAL);\n+  output_asm_insn (\"subne\\t%0, %0, %1\", xops);\n+\n+  /* Probe at TEST_ADDR and branch.  */\n+  output_asm_insn (\"strne\\tr0, [%0, #0]\", xops);\n+  fputs (\"\\tbne\\t\", asm_out_file);\n+  assemble_name_raw (asm_out_file, loop_lab);\n+  fputc ('\\n', asm_out_file);\n+\n+  return \"\";\n+}\n+\n /* Generate the prologue instructions for entry into an ARM or Thumb-2\n    function.  */\n void\n@@ -21112,7 +21352,9 @@ arm_expand_prologue (void)\n   int saved_pretend_args = 0;\n   int saved_regs = 0;\n   unsigned HOST_WIDE_INT args_to_push;\n+  HOST_WIDE_INT size;\n   arm_stack_offsets *offsets;\n+  bool clobber_ip;\n \n   func_type = arm_current_func_type ();\n \n@@ -21163,109 +21405,108 @@ arm_expand_prologue (void)\n       emit_insn (gen_movsi (stack_pointer_rtx, r1));\n     }\n \n-  /* For APCS frames, if IP register is clobbered\n-     when creating frame, save that register in a special\n-     way.  */\n-  if (TARGET_APCS_FRAME && frame_pointer_needed && TARGET_ARM)\n+  /* The static chain register is the same as the IP register.  If it is\n+     clobbered when creating the frame, we need to save and restore it.  */\n+  clobber_ip = IS_NESTED (func_type)\n+\t       && ((TARGET_APCS_FRAME && frame_pointer_needed && TARGET_ARM)\n+\t\t   || (flag_stack_check == STATIC_BUILTIN_STACK_CHECK\n+\t\t       && !df_regs_ever_live_p (LR_REGNUM)\n+\t\t       && arm_r3_live_at_start_p ()));\n+\n+  /* Find somewhere to store IP whilst the frame is being created.\n+     We try the following places in order:\n+\n+       1. The last argument register r3 if it is available.\n+       2. A slot on the stack above the frame if there are no\n+\t  arguments to push onto the stack.\n+       3. Register r3 again, after pushing the argument registers\n+\t  onto the stack, if this is a varargs function.\n+       4. The last slot on the stack created for the arguments to\n+\t  push, if this isn't a varargs function.\n+\n+     Note - we only need to tell the dwarf2 backend about the SP\n+     adjustment in the second variant; the static chain register\n+     doesn't need to be unwound, as it doesn't contain a value\n+     inherited from the caller.  */\n+  if (clobber_ip)\n     {\n-      if (IS_INTERRUPT (func_type))\n+      if (!arm_r3_live_at_start_p ())\n+\tinsn = emit_set_insn (gen_rtx_REG (SImode, 3), ip_rtx);\n+      else if (args_to_push == 0)\n \t{\n-\t  /* Interrupt functions must not corrupt any registers.\n-\t     Creating a frame pointer however, corrupts the IP\n-\t     register, so we must push it first.  */\n-\t  emit_multi_reg_push (1 << IP_REGNUM, 1 << IP_REGNUM);\n+\t  rtx addr, dwarf;\n \n-\t  /* Do not set RTX_FRAME_RELATED_P on this insn.\n-\t     The dwarf stack unwinding code only wants to see one\n-\t     stack decrement per function, and this is not it.  If\n-\t     this instruction is labeled as being part of the frame\n-\t     creation sequence then dwarf2out_frame_debug_expr will\n-\t     die when it encounters the assignment of IP to FP\n-\t     later on, since the use of SP here establishes SP as\n-\t     the CFA register and not IP.\n+\t  gcc_assert(arm_compute_static_chain_stack_bytes() == 4);\n+\t  saved_regs += 4;\n \n-\t     Anyway this instruction is not really part of the stack\n-\t     frame creation although it is part of the prologue.  */\n+\t  addr = gen_rtx_PRE_DEC (Pmode, stack_pointer_rtx);\n+\t  insn = emit_set_insn (gen_frame_mem (SImode, addr), ip_rtx);\n+\t  fp_offset = 4;\n+\n+\t  /* Just tell the dwarf backend that we adjusted SP.  */\n+\t  dwarf = gen_rtx_SET (stack_pointer_rtx,\n+\t\t\t       plus_constant (Pmode, stack_pointer_rtx,\n+\t\t\t\t\t      -fp_offset));\n+\t  RTX_FRAME_RELATED_P (insn) = 1;\n+\t  add_reg_note (insn, REG_FRAME_RELATED_EXPR, dwarf);\n \t}\n-      else if (IS_NESTED (func_type))\n-\t{\n-\t  /* The static chain register is the same as the IP register\n-\t     used as a scratch register during stack frame creation.\n-\t     To get around this need to find somewhere to store IP\n-\t     whilst the frame is being created.  We try the following\n-\t     places in order:\n-\n-\t       1. The last argument register r3 if it is available.\n-\t       2. A slot on the stack above the frame if there are no\n-\t\t  arguments to push onto the stack.\n-\t       3. Register r3 again, after pushing the argument registers\n-\t          onto the stack, if this is a varargs function.\n-\t       4. The last slot on the stack created for the arguments to\n-\t\t  push, if this isn't a varargs function.\n-\n-\t     Note - we only need to tell the dwarf2 backend about the SP\n-\t     adjustment in the second variant; the static chain register\n-\t     doesn't need to be unwound, as it doesn't contain a value\n-\t     inherited from the caller.  */\n-\n-\t  if (!arm_r3_live_at_start_p ())\n-\t    insn = emit_set_insn (gen_rtx_REG (SImode, 3), ip_rtx);\n-\t  else if (args_to_push == 0)\n+      else\n+\t{\n+\t  /* Store the args on the stack.  */\n+\t  if (cfun->machine->uses_anonymous_args)\n+\t    {\n+\t      insn = emit_multi_reg_push ((0xf0 >> (args_to_push / 4)) & 0xf,\n+\t\t\t\t\t  (0xf0 >> (args_to_push / 4)) & 0xf);\n+\t      emit_set_insn (gen_rtx_REG (SImode, 3), ip_rtx);\n+\t      saved_pretend_args = 1;\n+\t    }\n+\t  else\n \t    {\n \t      rtx addr, dwarf;\n \n-\t      gcc_assert(arm_compute_static_chain_stack_bytes() == 4);\n-\t      saved_regs += 4;\n+\t      if (args_to_push == 4)\n+\t\taddr = gen_rtx_PRE_DEC (Pmode, stack_pointer_rtx);\n+\t      else\n+\t\taddr = gen_rtx_PRE_MODIFY (Pmode, stack_pointer_rtx,\n+\t\t\t\t\t   plus_constant (Pmode,\n+\t\t\t\t\t\t\t  stack_pointer_rtx,\n+\t\t\t\t\t\t\t  -args_to_push));\n \n-\t      addr = gen_rtx_PRE_DEC (Pmode, stack_pointer_rtx);\n \t      insn = emit_set_insn (gen_frame_mem (SImode, addr), ip_rtx);\n-\t      fp_offset = 4;\n \n \t      /* Just tell the dwarf backend that we adjusted SP.  */\n \t      dwarf = gen_rtx_SET (stack_pointer_rtx,\n \t\t\t\t   plus_constant (Pmode, stack_pointer_rtx,\n-\t\t\t\t\t\t  -fp_offset));\n-\t      RTX_FRAME_RELATED_P (insn) = 1;\n+\t\t\t\t\t\t  -args_to_push));\n \t      add_reg_note (insn, REG_FRAME_RELATED_EXPR, dwarf);\n \t    }\n-\t  else\n-\t    {\n-\t      /* Store the args on the stack.  */\n-\t      if (cfun->machine->uses_anonymous_args)\n-\t\t{\n-\t\t  insn\n-\t\t    = emit_multi_reg_push ((0xf0 >> (args_to_push / 4)) & 0xf,\n-\t\t\t\t\t   (0xf0 >> (args_to_push / 4)) & 0xf);\n-\t\t  emit_set_insn (gen_rtx_REG (SImode, 3), ip_rtx);\n-\t\t  saved_pretend_args = 1;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  rtx addr, dwarf;\n \n-\t\t  if (args_to_push == 4)\n-\t\t    addr = gen_rtx_PRE_DEC (Pmode, stack_pointer_rtx);\n-\t\t  else\n-\t\t    addr\n-\t\t      = gen_rtx_PRE_MODIFY (Pmode, stack_pointer_rtx,\n-\t\t\t\t\t    plus_constant (Pmode,\n-\t\t\t\t\t\t\t   stack_pointer_rtx,\n-\t\t\t\t\t\t\t   -args_to_push));\n+\t  RTX_FRAME_RELATED_P (insn) = 1;\n+\t  fp_offset = args_to_push;\n+\t  args_to_push = 0;\n+\t}\n+    }\n \n-\t\t  insn = emit_set_insn (gen_frame_mem (SImode, addr), ip_rtx);\n+  if (TARGET_APCS_FRAME && frame_pointer_needed && TARGET_ARM)\n+    {\n+      if (IS_INTERRUPT (func_type))\n+\t{\n+\t  /* Interrupt functions must not corrupt any registers.\n+\t     Creating a frame pointer however, corrupts the IP\n+\t     register, so we must push it first.  */\n+\t  emit_multi_reg_push (1 << IP_REGNUM, 1 << IP_REGNUM);\n \n-\t\t  /* Just tell the dwarf backend that we adjusted SP.  */\n-\t\t  dwarf\n-\t\t    = gen_rtx_SET (stack_pointer_rtx,\n-\t\t\t\t   plus_constant (Pmode, stack_pointer_rtx,\n-\t\t\t\t\t\t  -args_to_push));\n-\t\t  add_reg_note (insn, REG_FRAME_RELATED_EXPR, dwarf);\n-\t\t}\n+\t  /* Do not set RTX_FRAME_RELATED_P on this insn.\n+\t     The dwarf stack unwinding code only wants to see one\n+\t     stack decrement per function, and this is not it.  If\n+\t     this instruction is labeled as being part of the frame\n+\t     creation sequence then dwarf2out_frame_debug_expr will\n+\t     die when it encounters the assignment of IP to FP\n+\t     later on, since the use of SP here establishes SP as\n+\t     the CFA register and not IP.\n \n-\t      RTX_FRAME_RELATED_P (insn) = 1;\n-\t      fp_offset = args_to_push;\n-\t      args_to_push = 0;\n-\t    }\n+\t     Anyway this instruction is not really part of the stack\n+\t     frame creation although it is part of the prologue.  */\n \t}\n \n       insn = emit_set_insn (ip_rtx,\n@@ -21364,34 +21605,60 @@ arm_expand_prologue (void)\n \t  insn = GEN_INT (-(4 + args_to_push + fp_offset));\n \t  insn = emit_insn (gen_addsi3 (hard_frame_pointer_rtx, ip_rtx, insn));\n \t  RTX_FRAME_RELATED_P (insn) = 1;\n-\n-\t  if (IS_NESTED (func_type))\n-\t    {\n-\t      /* Recover the static chain register.  */\n-\t      if (!arm_r3_live_at_start_p () || saved_pretend_args)\n-\t\tinsn = gen_rtx_REG (SImode, 3);\n-\t      else\n-\t\t{\n-\t\t  insn = plus_constant (Pmode, hard_frame_pointer_rtx, 4);\n-\t\t  insn = gen_frame_mem (SImode, insn);\n-\t\t}\n-\t      emit_set_insn (ip_rtx, insn);\n-\t      /* Add a USE to stop propagate_one_insn() from barfing.  */\n-\t      emit_insn (gen_force_register_use (ip_rtx));\n-\t    }\n \t}\n       else\n \t{\n-\t  insn = GEN_INT (saved_regs - 4);\n+\t  insn = GEN_INT (saved_regs - (4 + fp_offset));\n \t  insn = emit_insn (gen_addsi3 (hard_frame_pointer_rtx,\n \t\t\t\t\tstack_pointer_rtx, insn));\n \t  RTX_FRAME_RELATED_P (insn) = 1;\n \t}\n     }\n \n+  size = offsets->outgoing_args - offsets->saved_args;\n   if (flag_stack_usage_info)\n-    current_function_static_stack_size\n-      = offsets->outgoing_args - offsets->saved_args;\n+    current_function_static_stack_size = size;\n+\n+  /* If this isn't an interrupt service routine and we have a frame, then do\n+     stack checking.  We use IP as the first scratch register, except for the\n+     non-APCS nested functions if LR or r3 are available (see clobber_ip).  */\n+  if (!IS_INTERRUPT (func_type)\n+      && flag_stack_check == STATIC_BUILTIN_STACK_CHECK)\n+    {\n+      unsigned int regno;\n+\n+      if (!IS_NESTED (func_type) || clobber_ip)\n+\tregno = IP_REGNUM;\n+      else if (df_regs_ever_live_p (LR_REGNUM))\n+\tregno = LR_REGNUM;\n+      else\n+\tregno = 3;\n+\n+      if (crtl->is_leaf && !cfun->calls_alloca)\n+\t{\n+\t  if (size > PROBE_INTERVAL && size > STACK_CHECK_PROTECT)\n+\t    arm_emit_probe_stack_range (STACK_CHECK_PROTECT,\n+\t\t\t\t\tsize - STACK_CHECK_PROTECT,\n+\t\t\t\t\tregno, live_regs_mask);\n+\t}\n+      else if (size > 0)\n+\tarm_emit_probe_stack_range (STACK_CHECK_PROTECT, size,\n+\t\t\t\t    regno, live_regs_mask);\n+    }\n+\n+  /* Recover the static chain register.  */\n+  if (clobber_ip)\n+    {\n+      if (!arm_r3_live_at_start_p () || saved_pretend_args)\n+\tinsn = gen_rtx_REG (SImode, 3);\n+      else\n+\t{\n+\t  insn = plus_constant (Pmode, hard_frame_pointer_rtx, 4);\n+\t  insn = gen_frame_mem (SImode, insn);\n+\t}\n+      emit_set_insn (ip_rtx, insn);\n+      emit_insn (gen_force_register_use (ip_rtx));\n+    }\n \n   if (offsets->outgoing_args != offsets->saved_args + saved_regs)\n     {\n@@ -24370,6 +24637,7 @@ thumb1_expand_prologue (void)\n   rtx_insn *insn;\n \n   HOST_WIDE_INT amount;\n+  HOST_WIDE_INT size;\n   arm_stack_offsets *offsets;\n   unsigned long func_type;\n   int regno;\n@@ -24604,9 +24872,13 @@ thumb1_expand_prologue (void)\n     emit_move_insn (gen_rtx_REG (Pmode, ARM_HARD_FRAME_POINTER_REGNUM),\n \t\t    stack_pointer_rtx);\n \n+  size = offsets->outgoing_args - offsets->saved_args;\n   if (flag_stack_usage_info)\n-    current_function_static_stack_size\n-      = offsets->outgoing_args - offsets->saved_args;\n+    current_function_static_stack_size = size;\n+\n+  /* If we have a frame, then do stack checking.  FIXME: not implemented.  */\n+  if (flag_stack_check == STATIC_BUILTIN_STACK_CHECK && size)\n+    sorry (\"-fstack-check=specific for THUMB1\");\n \n   amount = offsets->outgoing_args - offsets->saved_regs;\n   amount -= 4 * thumb1_extra_regs_pushed (offsets, true);\n@@ -25177,14 +25449,16 @@ arm_expand_epilogue (bool really_return)\n         return;\n     }\n \n-  if (crtl->args.pretend_args_size)\n+  amount\n+    = crtl->args.pretend_args_size + arm_compute_static_chain_stack_bytes();\n+  if (amount)\n     {\n       int i, j;\n       rtx dwarf = NULL_RTX;\n       rtx_insn *tmp =\n \temit_insn (gen_addsi3 (stack_pointer_rtx,\n \t\t\t       stack_pointer_rtx,\n-\t\t\t       GEN_INT (crtl->args.pretend_args_size)));\n+\t\t\t       GEN_INT (amount)));\n \n       RTX_FRAME_RELATED_P (tmp) = 1;\n \n@@ -25203,7 +25477,7 @@ arm_expand_epilogue (bool really_return)\n \t      }\n \t  REG_NOTES (tmp) = dwarf;\n \t}\n-      arm_add_cfa_adjust_cfa_note (tmp, crtl->args.pretend_args_size,\n+      arm_add_cfa_adjust_cfa_note (tmp, amount,\n \t\t\t\t   stack_pointer_rtx, stack_pointer_rtx);\n     }\n \n@@ -27212,9 +27486,45 @@ arm_order_regs_for_local_alloc (void)\n bool\n arm_frame_pointer_required (void)\n {\n-  return (cfun->has_nonlocal_label\n-          || SUBTARGET_FRAME_POINTER_REQUIRED\n-          || (TARGET_ARM && TARGET_APCS_FRAME && ! leaf_function_p ()));\n+  if (SUBTARGET_FRAME_POINTER_REQUIRED)\n+    return true;\n+\n+  /* If the function receives nonlocal gotos, it needs to save the frame\n+     pointer in the nonlocal_goto_save_area object.  */\n+  if (cfun->has_nonlocal_label)\n+    return true;\n+\n+  /* The frame pointer is required for non-leaf APCS frames.  */\n+  if (TARGET_ARM && TARGET_APCS_FRAME && !leaf_function_p ())\n+    return true;\n+\n+  /* If we are probing the stack in the prologue, we will have a faulting\n+     instruction prior to the stack adjustment and this requires a frame\n+     pointer if we want to catch the exception using the EABI unwinder.  */\n+  if (!IS_INTERRUPT (arm_current_func_type ())\n+      && flag_stack_check == STATIC_BUILTIN_STACK_CHECK\n+      && arm_except_unwind_info (&global_options) == UI_TARGET\n+      && cfun->can_throw_non_call_exceptions)\n+    {\n+      HOST_WIDE_INT size = get_frame_size ();\n+\n+      /* That's irrelevant if there is no stack adjustment.  */\n+      if (size <= 0)\n+\treturn false;\n+\n+      /* That's relevant only if there is a stack probe.  */\n+      if (crtl->is_leaf && !cfun->calls_alloca)\n+\t{\n+\t  /* We don't have the final size of the frame so adjust.  */\n+\t  size += 32 * UNITS_PER_WORD;\n+\t  if (size > PROBE_INTERVAL && size > STACK_CHECK_PROTECT)\n+\t    return true;\n+\t}\n+      else\n+\treturn true;\n+    }\n+\n+  return false;\n }\n \n /* Only thumb1 can't support conditional execution, so return true if"}, {"sha": "1a8f32fa6703af498b4d95bcd5e1a77f0b16ea41", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fb94ef9aa797bb3ccd23157aa8fd66ff8e80bc0/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fb94ef9aa797bb3ccd23157aa8fd66ff8e80bc0/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=4fb94ef9aa797bb3ccd23157aa8fd66ff8e80bc0", "patch": "@@ -8259,6 +8259,30 @@\n    (set_attr \"type\" \"block\")]\n )\n \n+(define_insn \"probe_stack\"\n+  [(set (match_operand 0 \"memory_operand\" \"=m\")\n+        (unspec [(const_int 0)] UNSPEC_PROBE_STACK))]\n+  \"TARGET_32BIT\"\n+{\n+  return \"str%?\\\\tr0, %0\";\n+}\n+  [(set_attr \"type\" \"store1\")\n+   (set_attr \"predicable\" \"yes\")]\n+)\n+\n+(define_insn \"probe_stack_range\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(unspec_volatile:SI [(match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t\t     (match_operand:SI 2 \"register_operand\" \"r\")]\n+\t\t\t     UNSPEC_PROBE_STACK_RANGE))]\n+  \"TARGET_32BIT\"\n+{\n+  return output_probe_stack_range (operands[0], operands[2]);\n+}\n+  [(set_attr \"type\" \"multiple\")\n+   (set_attr \"conds\" \"clob\")]\n+)\n+\n (define_expand \"casesi\"\n   [(match_operand:SI 0 \"s_register_operand\" \"\")\t; index to jump on\n    (match_operand:SI 1 \"const_int_operand\" \"\")\t; lower bound"}, {"sha": "297a83f1f772b2ed07f79a2654c90d50835dc5a8", "filename": "gcc/config/arm/linux-elf.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fb94ef9aa797bb3ccd23157aa8fd66ff8e80bc0/gcc%2Fconfig%2Farm%2Flinux-elf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fb94ef9aa797bb3ccd23157aa8fd66ff8e80bc0/gcc%2Fconfig%2Farm%2Flinux-elf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Flinux-elf.h?ref=4fb94ef9aa797bb3ccd23157aa8fd66ff8e80bc0", "patch": "@@ -124,3 +124,6 @@\n    to COPY relocated symbol in the executable.  See PR65780.  */\n #undef TARGET_BINDS_LOCAL_P\n #define TARGET_BINDS_LOCAL_P default_binds_local_p_2\n+\n+/* Define this to be nonzero if static stack checking is supported.  */\n+#define STACK_CHECK_STATIC_BUILTIN 1"}, {"sha": "44d4e7dae8abc9069458fd754253c9998b432cae", "filename": "gcc/config/arm/unspecs.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fb94ef9aa797bb3ccd23157aa8fd66ff8e80bc0/gcc%2Fconfig%2Farm%2Funspecs.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fb94ef9aa797bb3ccd23157aa8fd66ff8e80bc0/gcc%2Fconfig%2Farm%2Funspecs.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Funspecs.md?ref=4fb94ef9aa797bb3ccd23157aa8fd66ff8e80bc0", "patch": "@@ -83,6 +83,8 @@\n                         ; FPSCR rounding mode and signal inexactness.\n   UNSPEC_VRINTA         ; Represent a float to integral float rounding\n                         ; towards nearest, ties away from zero.\n+  UNSPEC_PROBE_STACK    ; Probe stack memory reference\n+  UNSPEC_PROBE_STACK_RANGE ; Probe stack range\n ])\n \n (define_c_enum \"unspec\" ["}, {"sha": "82091b846979f094e626961675d3277c3a17da68", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fb94ef9aa797bb3ccd23157aa8fd66ff8e80bc0/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fb94ef9aa797bb3ccd23157aa8fd66ff8e80bc0/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4fb94ef9aa797bb3ccd23157aa8fd66ff8e80bc0", "patch": "@@ -1,3 +1,7 @@\n+2015-09-17  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc.target/arm/stack-checking.c: New test.\n+\n 2015-09-17  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/52846"}, {"sha": "adee92af744e9b7f17c2d324a3b63a257eecfc34", "filename": "gcc/testsuite/gcc.target/arm/stack-checking.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fb94ef9aa797bb3ccd23157aa8fd66ff8e80bc0/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fstack-checking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fb94ef9aa797bb3ccd23157aa8fd66ff8e80bc0/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fstack-checking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fstack-checking.c?ref=4fb94ef9aa797bb3ccd23157aa8fd66ff8e80bc0", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do run { target { *-*-linux* } } } */\n+/* { dg-options \"-fstack-check\" } */\n+\n+int main(void)\n+{\n+  char *p;\n+  if (1)\n+    {\n+      char i[48];\n+      p = __builtin_alloca(8);\n+      p[0] = 1;\n+    }\n+\n+  if (1)\n+    {\n+      char i[48], j[64];\n+      j[48] = 0;\n+    }\n+\n+  return !p[0];\n+}"}]}