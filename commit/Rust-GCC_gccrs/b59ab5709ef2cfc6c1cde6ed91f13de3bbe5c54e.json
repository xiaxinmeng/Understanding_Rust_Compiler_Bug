{"sha": "b59ab5709ef2cfc6c1cde6ed91f13de3bbe5c54e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjU5YWI1NzA5ZWYyY2ZjNmMxY2RlNmVkOTFmMTNkZTNiYmU1YzU0ZQ==", "commit": {"author": {"name": "Alexander Monakov", "email": "amonakov@gcc.gnu.org", "date": "2010-01-14T10:28:47Z"}, "committer": {"name": "Alexander Monakov", "email": "amonakov@gcc.gnu.org", "date": "2010-01-14T10:28:47Z"}, "message": "re PR middle-end/42245 (ICE in verify_backedges for 197.parser with sel-sched)\n\n2010-01-14  Andrey Belevantsev  <abel@ispras.ru>\n\t    Alexander Monakov  <amonakov@ispras.ru>\n\n\tPR middle-end/42245\n\t* sel-sched-ir.c (sel_recompute_toporder): New.  Use it...\n\t(maybe_tidy_empty_bb): ... here.  Make static.  Add new\n\targument.  Update all callers.\n\t(tidy_control_flow): ... and here.  Recompute topological order\n\tof basic blocks in region if necessary.\n\t(sel_redirect_edge_and_branch): Change return type.  Return true\n\tif topological order might have been invalidated.\n\t(purge_empty_blocks): Export and move from...\n\t* sel-sched.c (purge_empty_blocks): ... here.\n\t* sel-sched-ir.h (sel_redirect_edge_and_branch): Update prototype.\n        (maybe_tidy_empty_bb): Delete prototype.\n\t(purge_empty_blocks): Declare.\n\n\t* gcc.dg/pr42245.c: New.\n\t* gcc.dg/pr42245-2.c: New.\n\nFrom-SVN: r155890", "tree": {"sha": "58d8950f43c2356fc70a2c8f766cbde3b179e266", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/58d8950f43c2356fc70a2c8f766cbde3b179e266"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b59ab5709ef2cfc6c1cde6ed91f13de3bbe5c54e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b59ab5709ef2cfc6c1cde6ed91f13de3bbe5c54e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b59ab5709ef2cfc6c1cde6ed91f13de3bbe5c54e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b59ab5709ef2cfc6c1cde6ed91f13de3bbe5c54e/comments", "author": null, "committer": null, "parents": [{"sha": "0666ff4e33e39bd94ea8f34bf4ef1af1a004bd53", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0666ff4e33e39bd94ea8f34bf4ef1af1a004bd53", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0666ff4e33e39bd94ea8f34bf4ef1af1a004bd53"}], "stats": {"total": 129, "additions": 99, "deletions": 30}, "files": [{"sha": "fda47c6414388bd3991075c53cad79f07e49a268", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b59ab5709ef2cfc6c1cde6ed91f13de3bbe5c54e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b59ab5709ef2cfc6c1cde6ed91f13de3bbe5c54e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b59ab5709ef2cfc6c1cde6ed91f13de3bbe5c54e", "patch": "@@ -1,6 +1,23 @@\n+2010-01-14  Andrey Belevantsev  <abel@ispras.ru>\n+\t    Alexander Monakov  <amonakov@ispras.ru>\n+\n+\tPR middle-end/42245\n+\t* sel-sched-ir.c (sel_recompute_toporder): New.  Use it...\n+\t(maybe_tidy_empty_bb): ... here.  Make static.  Add new\n+\targument.  Update all callers.\n+\t(tidy_control_flow): ... and here.  Recompute topological order\n+\tof basic blocks in region if necessary.\n+\t(sel_redirect_edge_and_branch): Change return type.  Return true\n+\tif topological order might have been invalidated.\n+\t(purge_empty_blocks): Export and move from...\n+\t* sel-sched.c (purge_empty_blocks): ... here.\n+\t* sel-sched-ir.h (sel_redirect_edge_and_branch): Update prototype.\n+        (maybe_tidy_empty_bb): Delete prototype.\n+\t(purge_empty_blocks): Declare.\n+\n 2010-01-14  Andrey Belevantsev <abel@ispras.ru>\n \n-\tPR rtl-optimization/42294\n+\tPR rtl-optimization/42249\n \t* sel-sched.c (try_replace_dest_reg): When chosen register\n \tand original register is the same, do not bail out early, but\n \tstill check all original insns for validity of replacing destination"}, {"sha": "ad1dcb212de9757e68787d045e9bd2895a6cd526", "filename": "gcc/sel-sched-ir.c", "status": "modified", "additions": 72, "deletions": 8, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b59ab5709ef2cfc6c1cde6ed91f13de3bbe5c54e/gcc%2Fsel-sched-ir.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b59ab5709ef2cfc6c1cde6ed91f13de3bbe5c54e/gcc%2Fsel-sched-ir.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched-ir.c?ref=b59ab5709ef2cfc6c1cde6ed91f13de3bbe5c54e", "patch": "@@ -3503,9 +3503,36 @@ verify_backedges (void)\n \n /* Functions to work with control flow.  */\n \n+/* Recompute BLOCK_TO_BB and BB_FOR_BLOCK for current region so that blocks\n+   are sorted in topological order (it might have been invalidated by\n+   redirecting an edge).  */\n+static void\n+sel_recompute_toporder (void)\n+{\n+  int i, n, rgn;\n+  int *postorder, n_blocks;\n+\n+  postorder = XALLOCAVEC (int, n_basic_blocks);\n+  n_blocks = post_order_compute (postorder, false, false);\n+\n+  rgn = CONTAINING_RGN (BB_TO_BLOCK (0));\n+  for (n = 0, i = n_blocks - 1; i >= 0; i--)\n+    if (CONTAINING_RGN (postorder[i]) == rgn)\n+      {\n+\tBLOCK_TO_BB (postorder[i]) = n;\n+\tBB_TO_BLOCK (n) = postorder[i];\n+\tn++;\n+      }\n+\n+  /* Assert that we updated info for all blocks.  We may miss some blocks if\n+     this function is called when redirecting an edge made a block\n+     unreachable, but that block is not deleted yet.  */\n+  gcc_assert (n == RGN_NR_BLOCKS (rgn));\n+}\n+\n /* Tidy the possibly empty block BB.  */\n-bool\n-maybe_tidy_empty_bb (basic_block bb)\n+static bool\n+maybe_tidy_empty_bb (basic_block bb, bool recompute_toporder_p)\n {\n   basic_block succ_bb, pred_bb;\n   edge e;\n@@ -3552,7 +3579,7 @@ maybe_tidy_empty_bb (basic_block bb)\n \n           if (!(e->flags & EDGE_FALLTHRU))\n             {\n-              sel_redirect_edge_and_branch (e, succ_bb);\n+              recompute_toporder_p |= sel_redirect_edge_and_branch (e, succ_bb);\n               rescan_p = true;\n               break;\n             }\n@@ -3572,6 +3599,9 @@ maybe_tidy_empty_bb (basic_block bb)\n       remove_empty_bb (bb, true);\n     }\n \n+  if (recompute_toporder_p)\n+    sel_recompute_toporder ();\n+\n #ifdef ENABLE_CHECKING\n   verify_backedges ();\n #endif\n@@ -3589,7 +3619,7 @@ tidy_control_flow (basic_block xbb, bool full_tidying)\n   insn_t first, last;\n \n   /* First check whether XBB is empty.  */\n-  changed = maybe_tidy_empty_bb (xbb);\n+  changed = maybe_tidy_empty_bb (xbb, false);\n   if (changed || !full_tidying)\n     return changed;\n \n@@ -3640,22 +3670,45 @@ tidy_control_flow (basic_block xbb, bool full_tidying)\n       /* Also this jump is not at the scheduling boundary.  */\n       && !IN_CURRENT_FENCE_P (BB_END (xbb->prev_bb)))\n     {\n+      bool recompute_toporder_p;\n       /* Clear data structures of jump - jump itself will be removed\n          by sel_redirect_edge_and_branch.  */\n       clear_expr (INSN_EXPR (BB_END (xbb->prev_bb)));\n-      sel_redirect_edge_and_branch (EDGE_SUCC (xbb->prev_bb, 0), xbb);\n+      recompute_toporder_p\n+        = sel_redirect_edge_and_branch (EDGE_SUCC (xbb->prev_bb, 0), xbb);\n+\n       gcc_assert (EDGE_SUCC (xbb->prev_bb, 0)->flags & EDGE_FALLTHRU);\n \n       /* It can turn out that after removing unused jump, basic block\n          that contained that jump, becomes empty too.  In such case\n          remove it too.  */\n       if (sel_bb_empty_p (xbb->prev_bb))\n-        changed = maybe_tidy_empty_bb (xbb->prev_bb);\n+        changed = maybe_tidy_empty_bb (xbb->prev_bb, recompute_toporder_p);\n+      else if (recompute_toporder_p)\n+\tsel_recompute_toporder ();\n     }\n \n   return changed;\n }\n \n+/* Purge meaningless empty blocks in the middle of a region.  */\n+void\n+purge_empty_blocks (void)\n+{\n+  /* Do not attempt to delete preheader.  */\n+  int i = sel_is_loop_preheader_p (BASIC_BLOCK (BB_TO_BLOCK (0))) ? 1 : 0;\n+\n+  while (i < current_nr_blocks)\n+    {\n+      basic_block b = BASIC_BLOCK (BB_TO_BLOCK (i));\n+\n+      if (maybe_tidy_empty_bb (b, false))\n+\tcontinue;\n+\n+      i++;\n+    }\n+}\n+\n /* Rip-off INSN from the insn stream.  When ONLY_DISCONNECT is true,\n    do not delete insn's data, because it will be later re-emitted.\n    Return true if we have removed some blocks afterwards.  */\n@@ -5355,15 +5408,17 @@ sel_redirect_edge_and_branch_force (edge e, basic_block to)\n     sel_init_new_insn (jump, INSN_INIT_TODO_LUID | INSN_INIT_TODO_SIMPLEJUMP);\n }\n \n-/* A wrapper for redirect_edge_and_branch.  */\n-void\n+/* A wrapper for redirect_edge_and_branch.  Return TRUE if blocks connected by\n+   redirected edge are in reverse topological order.  */\n+bool\n sel_redirect_edge_and_branch (edge e, basic_block to)\n {\n   bool latch_edge_p;\n   basic_block src;\n   int prev_max_uid;\n   rtx jump;\n   edge redirected;\n+  bool recompute_toporder_p = false;\n \n   latch_edge_p = (pipelining_p\n                   && current_loop_nest\n@@ -5383,9 +5438,18 @@ sel_redirect_edge_and_branch (edge e, basic_block to)\n       gcc_assert (loop_latch_edge (current_loop_nest));\n     }\n \n+  /* In rare situations, the topological relation between the blocks connected\n+     by the redirected edge can change (see PR42245 for an example).  Update\n+     block_to_bb/bb_to_block.  */\n+  if (CONTAINING_RGN (e->src->index) == CONTAINING_RGN (to->index)\n+      && BLOCK_TO_BB (e->src->index) > BLOCK_TO_BB (to->index))\n+    recompute_toporder_p = true;\n+\n   jump = find_new_jump (src, NULL, prev_max_uid);\n   if (jump)\n     sel_init_new_insn (jump, INSN_INIT_TODO_LUID | INSN_INIT_TODO_SIMPLEJUMP);\n+\n+  return recompute_toporder_p;\n }\n \n /* This variable holds the cfg hooks used by the selective scheduler.  */"}, {"sha": "db2989b61117fd95ac064957a19f7d2c54295b23", "filename": "gcc/sel-sched-ir.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b59ab5709ef2cfc6c1cde6ed91f13de3bbe5c54e/gcc%2Fsel-sched-ir.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b59ab5709ef2cfc6c1cde6ed91f13de3bbe5c54e/gcc%2Fsel-sched-ir.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched-ir.h?ref=b59ab5709ef2cfc6c1cde6ed91f13de3bbe5c54e", "patch": "@@ -1613,11 +1613,11 @@ extern bool tidy_control_flow (basic_block, bool);\n extern void free_bb_note_pool (void);\n \n extern void sel_remove_empty_bb (basic_block, bool, bool);\n-extern bool maybe_tidy_empty_bb (basic_block bb);\n+extern void purge_empty_blocks (void);\n extern basic_block sel_split_edge (edge);\n extern basic_block sel_create_recovery_block (insn_t);\n extern void sel_merge_blocks (basic_block, basic_block);\n-extern void sel_redirect_edge_and_branch (edge, basic_block);\n+extern bool sel_redirect_edge_and_branch (edge, basic_block);\n extern void sel_redirect_edge_and_branch_force (edge, basic_block);\n extern void sel_init_pipelining (void);\n extern void sel_finish_pipelining (void);"}, {"sha": "4ca8ab22f8586885c39155d1f0e0dfdc33f9db6a", "filename": "gcc/sel-sched.c", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b59ab5709ef2cfc6c1cde6ed91f13de3bbe5c54e/gcc%2Fsel-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b59ab5709ef2cfc6c1cde6ed91f13de3bbe5c54e/gcc%2Fsel-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched.c?ref=b59ab5709ef2cfc6c1cde6ed91f13de3bbe5c54e", "patch": "@@ -6765,24 +6765,6 @@ setup_current_loop_nest (int rgn)\n   gcc_assert (LOOP_MARKED_FOR_PIPELINING_P (current_loop_nest));\n }\n \n-/* Purge meaningless empty blocks in the middle of a region.  */\n-static void\n-purge_empty_blocks (void)\n-{\n-  /* Do not attempt to delete preheader.  */\n-  int i = sel_is_loop_preheader_p (BASIC_BLOCK (BB_TO_BLOCK (0))) ? 1 : 0;\n-\n-  while (i < current_nr_blocks)\n-    {\n-      basic_block b = BASIC_BLOCK (BB_TO_BLOCK (i));\n-\n-      if (maybe_tidy_empty_bb (b))\n-\tcontinue;\n-\n-      i++;\n-    }\n-}\n-\n /* Compute instruction priorities for current region.  */\n static void\n sel_compute_priorities (int rgn)"}, {"sha": "855b25673f87bde6a0fa9a0d88a4e1874a44278c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b59ab5709ef2cfc6c1cde6ed91f13de3bbe5c54e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b59ab5709ef2cfc6c1cde6ed91f13de3bbe5c54e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b59ab5709ef2cfc6c1cde6ed91f13de3bbe5c54e", "patch": "@@ -1,6 +1,12 @@\n 2010-01-14  Alexander Monakov <amonakov@ispras.ru>\n \n-        PR rtl-optimization/42294\n+\tPR middle-end/42245\n+\t* gcc.dg/pr42245.c: New.\n+\t* gcc.dg/pr42245-2.c: New.\n+\n+2010-01-14  Alexander Monakov <amonakov@ispras.ru>\n+\n+        PR rtl-optimization/42249\n         * gcc.dg/pr42249.c: New.\n \n 2010-01-14  Jakub Jelinek  <jakub@redhat.com>"}]}