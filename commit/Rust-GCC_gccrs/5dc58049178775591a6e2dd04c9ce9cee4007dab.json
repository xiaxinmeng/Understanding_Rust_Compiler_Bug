{"sha": "5dc58049178775591a6e2dd04c9ce9cee4007dab", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWRjNTgwNDkxNzg3NzU1OTFhNmUyZGQwNGM5Y2U5Y2VlNDAwN2RhYg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2015-12-07T04:34:43Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2015-12-07T04:34:43Z"}, "message": "PR c++/68597, fix auto9.C and auto-neg1.C with -std=c++1z.\n\n\t* decl.c (check_tag_decl): Use ds_type_spec in auto diagnostic.\n\t* typeck.c (check_return_expr): Check for inconsistent deduction.\n\t* parser.c (class type_id_in_expr_sentinel): New.\n\t(cp_parser_primary_expression) [RID_VA_ARG]: Use it.\n\t(cp_parser_new_expression): Use it.\n\t(cp_parser_trait_expr): Use it.\n\t(cp_parser_type_id_1): Complain about auto if in_type_id_in_expr_p.\n\t(cp_parser_default_type_template_argument): Check for auto.\n\t(cp_parser_type_id_list): Likewise.\n\t(cp_parser_simple_type_specifier): Allow auto parms if flag_concepts.\n\t* pt.c (do_auto_deduction): Handle erroneous type.\n\nFrom-SVN: r231349", "tree": {"sha": "3301952703831d6af8b321a802640f7212d328df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3301952703831d6af8b321a802640f7212d328df"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5dc58049178775591a6e2dd04c9ce9cee4007dab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5dc58049178775591a6e2dd04c9ce9cee4007dab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5dc58049178775591a6e2dd04c9ce9cee4007dab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5dc58049178775591a6e2dd04c9ce9cee4007dab/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "adcef2743040ffe09dedd3bc909adf02a26a6803", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/adcef2743040ffe09dedd3bc909adf02a26a6803", "html_url": "https://github.com/Rust-GCC/gccrs/commit/adcef2743040ffe09dedd3bc909adf02a26a6803"}], "stats": {"total": 163, "additions": 126, "deletions": 37}, "files": [{"sha": "2c04ea0133be810bbe2bc97dcd99ff4cc9f3f6f8", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dc58049178775591a6e2dd04c9ce9cee4007dab/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dc58049178775591a6e2dd04c9ce9cee4007dab/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=5dc58049178775591a6e2dd04c9ce9cee4007dab", "patch": "@@ -1,3 +1,18 @@\n+2015-12-05  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/68597, fix auto9.C and auto-neg1.C with -std=c++1z.\n+\t* decl.c (check_tag_decl): Use ds_type_spec in auto diagnostic.\n+\t* typeck.c (check_return_expr): Check for inconsistent deduction.\n+\t* parser.c (class type_id_in_expr_sentinel): New.\n+\t(cp_parser_primary_expression) [RID_VA_ARG]: Use it.\n+\t(cp_parser_new_expression): Use it.\n+\t(cp_parser_trait_expr): Use it.\n+\t(cp_parser_type_id_1): Complain about auto if in_type_id_in_expr_p.\n+\t(cp_parser_default_type_template_argument): Check for auto.\n+\t(cp_parser_type_id_list): Likewise.\n+\t(cp_parser_simple_type_specifier): Allow auto parms if flag_concepts.\n+\t* pt.c (do_auto_deduction): Handle erroneous type.\n+\n 2015-12-04  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/68645"}, {"sha": "0af7bd49224e76f56af3d370c2c0bd8db953bbc5", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dc58049178775591a6e2dd04c9ce9cee4007dab/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dc58049178775591a6e2dd04c9ce9cee4007dab/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=5dc58049178775591a6e2dd04c9ce9cee4007dab", "patch": "@@ -4555,8 +4555,9 @@ check_tag_decl (cp_decl_specifier_seq *declspecs,\n     permerror (input_location, \"declaration does not declare anything\");\n   else if (declared_type != NULL_TREE && type_uses_auto (declared_type))\n     {\n-      error (\"%<auto%> can only be specified for variables \"\n-\t     \"or function declarations\");\n+      error_at (declspecs->locations[ds_type_spec],\n+\t\t\"%<auto%> can only be specified for variables \"\n+\t\t\"or function declarations\");\n       return error_mark_node;\n     }\n   /* Check for an anonymous union.  */"}, {"sha": "85f6cc18aec2863774ab4880564d8a77cdafe3f7", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 75, "deletions": 6, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dc58049178775591a6e2dd04c9ce9cee4007dab/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dc58049178775591a6e2dd04c9ce9cee4007dab/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=5dc58049178775591a6e2dd04c9ce9cee4007dab", "patch": "@@ -178,6 +178,22 @@ enum required_token {\n   RT_TRANSACTION_CANCEL /* __transaction_cancel */\n };\n \n+/* RAII wrapper for parser->in_type_id_in_expr_p, setting it on creation and\n+   reverting it on destruction.  */\n+\n+class type_id_in_expr_sentinel\n+{\n+  cp_parser *parser;\n+  bool saved;\n+public:\n+  type_id_in_expr_sentinel (cp_parser *parser, bool set = true)\n+    : parser (parser),\n+      saved (parser->in_type_id_in_expr_p)\n+  { parser->in_type_id_in_expr_p = set; }\n+  ~type_id_in_expr_sentinel ()\n+  { parser->in_type_id_in_expr_p = saved; }\n+};\n+\n /* Prototypes.  */\n \n static cp_lexer *cp_lexer_new_main\n@@ -4888,7 +4904,10 @@ cp_parser_primary_expression (cp_parser *parser,\n \t    cp_parser_require (parser, CPP_COMMA, RT_COMMA);\n \t    type_location = cp_lexer_peek_token (parser->lexer)->location;\n \t    /* Parse the type-id.  */\n-\t    type = cp_parser_type_id (parser);\n+\t    {\n+\t      type_id_in_expr_sentinel s (parser);\n+\t      type = cp_parser_type_id (parser);\n+\t    }\n \t    /* Look for the closing `)'.  */\n \t    location_t finish_loc\n \t      = cp_lexer_peek_token (parser->lexer)->location;\n@@ -7907,7 +7926,10 @@ cp_parser_new_expression (cp_parser* parser)\n       /* Parse the type-id.  */\n       parser->type_definition_forbidden_message\n \t= G_(\"types may not be defined in a new-expression\");\n-      type = cp_parser_type_id (parser);\n+      {\n+\ttype_id_in_expr_sentinel s (parser);\n+\ttype = cp_parser_type_id (parser);\n+      }\n       parser->type_definition_forbidden_message = saved_message;\n \n       /* Look for the closing `)'.  */\n@@ -9391,7 +9413,10 @@ cp_parser_trait_expr (cp_parser* parser, enum rid keyword)\n \n   cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN);\n \n-  type1 = cp_parser_type_id (parser);\n+  {\n+    type_id_in_expr_sentinel s (parser);\n+    type1 = cp_parser_type_id (parser);\n+  }\n \n   if (type1 == error_mark_node)\n     return error_mark_node;\n@@ -9400,7 +9425,10 @@ cp_parser_trait_expr (cp_parser* parser, enum rid keyword)\n     {\n       cp_parser_require (parser, CPP_COMMA, RT_COMMA);\n  \n-      type2 = cp_parser_type_id (parser);\n+      {\n+\ttype_id_in_expr_sentinel s (parser);\n+\ttype2 = cp_parser_type_id (parser);\n+      }\n \n       if (type2 == error_mark_node)\n \treturn error_mark_node;\n@@ -12149,6 +12177,11 @@ cp_parser_simple_declaration (cp_parser* parser,\n       && !cp_parser_error_occurred (parser))\n     cp_parser_commit_to_tentative_parse (parser);\n \n+  tree last_type, auto_node;\n+\n+  last_type = NULL_TREE;\n+  auto_node = type_uses_auto (decl_specifiers.type);\n+\n   /* Keep going until we hit the `;' at the end of the simple\n      declaration.  */\n   saw_declarator = false;\n@@ -12190,6 +12223,24 @@ cp_parser_simple_declaration (cp_parser* parser,\n \t otherwise.)  */\n       if (cp_parser_error_occurred (parser))\n \tgoto done;\n+\n+      if (auto_node)\n+\t{\n+\t  tree type = TREE_TYPE (decl);\n+\t  if (last_type && !same_type_p (type, last_type))\n+\t    {\n+\t      /* If the list of declarators contains more than one declarator,\n+\t\t the type of each declared variable is determined as described\n+\t\t above. If the type deduced for the template parameter U is not\n+\t\t the same in each deduction, the program is ill-formed.  */\n+\t      error_at (decl_specifiers.locations[ds_type_spec],\n+\t\t\t\"inconsistent deduction for %qT: %qT and then %qT\",\n+\t\t\tdecl_specifiers.type, last_type, type);\n+\t      auto_node = NULL_TREE;\n+\t    }\n+\t  last_type = type;\n+\t}\n+\n       /* Handle function definitions specially.  */\n       if (function_definition_p)\n \t{\n@@ -14188,11 +14239,20 @@ cp_parser_default_type_template_argument (cp_parser *parser)\n   /* Consume the `=' token.  */\n   cp_lexer_consume_token (parser->lexer);\n \n+  cp_token *token = cp_lexer_peek_token (parser->lexer);\n+\n   /* Parse the default-argument.  */\n   push_deferring_access_checks (dk_no_deferred);\n   tree default_argument = cp_parser_type_id (parser);\n   pop_deferring_access_checks ();\n \n+  if (flag_concepts && type_uses_auto (default_argument))\n+    {\n+      error_at (token->location,\n+\t\t\"invalid use of %<auto%> in default template argument\");\n+      return error_mark_node;\n+    }\n+\n   return default_argument;\n }\n \n@@ -15870,7 +15930,7 @@ cp_parser_simple_type_specifier (cp_parser* parser,\n \t\t     \"use of %<auto%> in parameter declaration \"\n \t\t     \"only available with \"\n \t\t     \"-std=c++14 or -std=gnu++14\");\n-\t  else\n+\t  else if (!flag_concepts)\n \t    pedwarn (token->location, OPT_Wpedantic,\n \t\t     \"ISO C++ forbids use of %<auto%> in parameter \"\n \t\t     \"declaration\");\n@@ -19647,7 +19707,7 @@ cp_parser_type_id_1 (cp_parser* parser, bool is_template_arg,\n \n   if (type_specifier_seq.type\n       /* The concepts TS allows 'auto' as a type-id.  */\n-      && !flag_concepts\n+      && (!flag_concepts || parser->in_type_id_in_expr_p)\n       /* None of the valid uses of 'auto' in C++14 involve the type-id\n \t nonterminal, but it is valid in a trailing-return-type.  */\n       && !(cxx_dialect >= cxx14 && is_trailing_return)\n@@ -22875,8 +22935,17 @@ cp_parser_type_id_list (cp_parser* parser)\n       cp_token *token;\n       tree type;\n \n+      token = cp_lexer_peek_token (parser->lexer);\n+\n       /* Get the next type-id.  */\n       type = cp_parser_type_id (parser);\n+      /* Check for invalid 'auto'.  */\n+      if (flag_concepts && type_uses_auto (type))\n+\t{\n+\t  error_at (token->location,\n+\t\t    \"invalid use of %<auto%> in exception-specification\");\n+\t  type = error_mark_node;\n+\t}\n       /* Parse the optional ellipsis. */\n       if (cp_lexer_next_token_is (parser->lexer, CPP_ELLIPSIS))\n         {"}, {"sha": "6e50fcd1ee9244db47b911d90b894fb0ec36fdad", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 6, "deletions": 21, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dc58049178775591a6e2dd04c9ce9cee4007dab/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dc58049178775591a6e2dd04c9ce9cee4007dab/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=5dc58049178775591a6e2dd04c9ce9cee4007dab", "patch": "@@ -23712,6 +23712,9 @@ do_auto_deduction (tree type, tree init, tree auto_node,\n \t}\n     }\n \n+  if (type == error_mark_node)\n+    return error_mark_node;\n+\n   init = resolve_nondeduced_context (init);\n \n   if (AUTO_IS_DECLTYPE (auto_node))\n@@ -23770,26 +23773,6 @@ do_auto_deduction (tree type, tree init, tree auto_node,\n \t}\n     }\n \n-  /* If the list of declarators contains more than one declarator, the type\n-     of each declared variable is determined as described above. If the\n-     type deduced for the template parameter U is not the same in each\n-     deduction, the program is ill-formed.  */\n-  if (!flag_concepts && TREE_TYPE (auto_node)\n-      && !same_type_p (TREE_TYPE (auto_node), TREE_VEC_ELT (targs, 0)))\n-    {\n-      if (cfun && auto_node == current_function_auto_return_pattern\n-\t  && LAMBDA_FUNCTION_P (current_function_decl))\n-\terror (\"inconsistent types %qT and %qT deduced for \"\n-\t       \"lambda return type\", TREE_TYPE (auto_node),\n-\t       TREE_VEC_ELT (targs, 0));\n-      else\n-\terror (\"inconsistent deduction for %qT: %qT and then %qT\",\n-\t       auto_node, TREE_TYPE (auto_node), TREE_VEC_ELT (targs, 0));\n-      return error_mark_node;\n-    }\n-  if (!flag_concepts)\n-    TREE_TYPE (auto_node) = TREE_VEC_ELT (targs, 0);\n-\n   /* Check any placeholder constraints against the deduced type. */\n   if (flag_concepts && !processing_template_decl)\n     if (tree constr = PLACEHOLDER_TYPE_CONSTRAINTS (auto_node))\n@@ -23877,7 +23860,9 @@ is_auto_r (tree tp, void */*data*/)\n tree\n type_uses_auto (tree type)\n {\n-  if (flag_concepts)\n+  if (type == NULL_TREE)\n+    return NULL_TREE;\n+  else if (flag_concepts)\n     {\n       /* The Concepts TS allows multiple autos in one type-specifier; just\n \t return the first one we find, do_auto_deduction will collect all of"}, {"sha": "3cf3c953f4b8d96efd09d6023e3b3eaf0843a65b", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dc58049178775591a6e2dd04c9ce9cee4007dab/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dc58049178775591a6e2dd04c9ce9cee4007dab/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=5dc58049178775591a6e2dd04c9ce9cee4007dab", "patch": "@@ -8644,9 +8644,15 @@ check_return_expr (tree retval, bool *no_warning)\n \t/* Leave it.  */;\n       else if (functype == current_function_auto_return_pattern)\n \tapply_deduced_return_type (current_function_decl, type);\n-      else\n-\t/* A mismatch should have been diagnosed in do_auto_deduction.  */\n-\tgcc_assert (same_type_p (type, functype));\n+      else if (!same_type_p (type, functype))\n+\t{\n+\t  if (LAMBDA_FUNCTION_P (current_function_decl))\n+\t    error (\"inconsistent types %qT and %qT deduced for \"\n+\t\t   \"lambda return type\", functype, type);\n+\t  else\n+\t    error (\"inconsistent deduction for auto return type: \"\n+\t\t   \"%qT and then %qT\", functype, type);\n+\t}\n       functype = type;\n     }\n "}, {"sha": "ee204410368a16b150adf83733968d345e58501e", "filename": "gcc/testsuite/g++.dg/cpp0x/auto9.C", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dc58049178775591a6e2dd04c9ce9cee4007dab/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fauto9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dc58049178775591a6e2dd04c9ce9cee4007dab/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fauto9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fauto9.C?ref=5dc58049178775591a6e2dd04c9ce9cee4007dab", "patch": "@@ -114,10 +114,10 @@ badthrow2 () throw (auto &)\t\t\t// { dg-error \"invalid use of|expected\" }\n template <auto V = 4> struct G {};\t\t// { dg-error \"auto\" }\n \n template <typename T> struct H { H (); ~H (); };\n-H<auto> h;\t\t\t\t\t// { dg-error \"invalid\" }\n+H<auto> h;\t\t\t\t\t// { dg-error \"invalid|initializer\" }\n \n-void qq (auto);\t\t\t// { dg-error \"auto\" }\n-void qr (auto*);\t\t// { dg-error \"auto\" }\n+void qq (auto);\t\t       // { dg-error \"auto\" \"\" { target { ! c++1z } } }\n+void qr (auto*);\t       // { dg-error \"auto\" \"\" { target { ! c++1z } } }\n \n // PR c++/46145\n typedef auto autot;\t\t// { dg-error \"auto\" }"}, {"sha": "c45fe177cb153c1a0f84cf079c92637dac3a614c", "filename": "gcc/testsuite/g++.dg/cpp1y/lambda-deduce-mult-neg.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dc58049178775591a6e2dd04c9ce9cee4007dab/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Flambda-deduce-mult-neg.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dc58049178775591a6e2dd04c9ce9cee4007dab/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Flambda-deduce-mult-neg.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Flambda-deduce-mult-neg.C?ref=5dc58049178775591a6e2dd04c9ce9cee4007dab", "patch": "@@ -0,0 +1,13 @@\n+// PR c++/68597\n+// { dg-do compile { target c++14 } }\n+\n+auto make_test_objective3(double beta) {\n+  auto phi0_prime = [=](double alpha) {\n+    if (alpha <= 1-beta)\n+      return -1;\n+    else if (alpha >= 1+beta)\n+      return 1;\n+    else\n+      return 1 / beta * (alpha - 1); // { dg-error \"type\" }\n+  };\n+}"}, {"sha": "3d9982893eea91c80e3cb3753d379a7d915b19c9", "filename": "gcc/testsuite/g++.dg/other/anon-union3.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5dc58049178775591a6e2dd04c9ce9cee4007dab/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fanon-union3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5dc58049178775591a6e2dd04c9ce9cee4007dab/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fanon-union3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fanon-union3.C?ref=5dc58049178775591a6e2dd04c9ce9cee4007dab", "patch": "@@ -3,9 +3,9 @@\n class C\n {\n   auto union      // { dg-error \"storage class\" \"\" { target { ! c++11 } } }\n-    {\n+    {\t\t  // { dg-error \"auto\" \"\" { target c++11 } 5 }\n       int a;\n-    };            // { dg-error \"multiple|specified\" \"\" { target c++11 } }\n+    };            // { dg-error \"multiple types\" \"\" { target c++11 } }\n   register union  // { dg-error \"storage class\" }\n     {\n       int b;"}]}