{"sha": "993f8920f402a8292fae58b22c03e31f3a308cf8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTkzZjg5MjBmNDAyYTgyOTJmYWU1OGIyMmMwM2UzMWYzYTMwOGNmOA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-05T15:50:24Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-05T15:50:24Z"}, "message": "[multiple changes]\n\n2011-08-05  Matthew Heaney  <heaney@adacore.com>\n\n\t* a-comutr.adb, a-cimutr.adb, a-cbmutr.adb (Child_Count, Child_Depth):\n\tsubprogram bodies declared out-of-order.\n\n2011-08-05  Yannick Moy  <moy@adacore.com>\n\n\t* sem_util.adb (Unique_Name): only prefix with \"standard\" the names of\n\tentities directly in package Standard, otherwise skip the standard\n\tprefix.\n\nFrom-SVN: r177461", "tree": {"sha": "65a3f7febd2b18b1496fce3f32191972afd0c06e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/65a3f7febd2b18b1496fce3f32191972afd0c06e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/993f8920f402a8292fae58b22c03e31f3a308cf8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/993f8920f402a8292fae58b22c03e31f3a308cf8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/993f8920f402a8292fae58b22c03e31f3a308cf8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/993f8920f402a8292fae58b22c03e31f3a308cf8/comments", "author": null, "committer": null, "parents": [{"sha": "9b3956ddfccf087a37c4ed3abb034e12096fdcd1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b3956ddfccf087a37c4ed3abb034e12096fdcd1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b3956ddfccf087a37c4ed3abb034e12096fdcd1"}], "stats": {"total": 466, "additions": 250, "deletions": 216}, "files": [{"sha": "1dcb3eb5981c7bd53ac8a4f5b90021edf46cbe1e", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/993f8920f402a8292fae58b22c03e31f3a308cf8/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/993f8920f402a8292fae58b22c03e31f3a308cf8/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=993f8920f402a8292fae58b22c03e31f3a308cf8", "patch": "@@ -1,3 +1,14 @@\n+2011-08-05  Matthew Heaney  <heaney@adacore.com>\n+\n+\t* a-comutr.adb, a-cimutr.adb, a-cbmutr.adb (Child_Count, Child_Depth):\n+\tsubprogram bodies declared out-of-order.\n+\n+2011-08-05  Yannick Moy  <moy@adacore.com>\n+\n+\t* sem_util.adb (Unique_Name): only prefix with \"standard\" the names of\n+\tentities directly in package Standard, otherwise skip the standard\n+\tprefix.\n+\n 2011-08-05  Robert Dewar  <dewar@adacore.com>\n \n \t* a-cbmutr.adb: Minor reformatting"}, {"sha": "cc569e8367336998e5bae0ace32681bb99749330", "filename": "gcc/ada/a-cbmutr.adb", "status": "modified", "additions": 80, "deletions": 80, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/993f8920f402a8292fae58b22c03e31f3a308cf8/gcc%2Fada%2Fa-cbmutr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/993f8920f402a8292fae58b22c03e31f3a308cf8/gcc%2Fada%2Fa-cbmutr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cbmutr.adb?ref=993f8920f402a8292fae58b22c03e31f3a308cf8", "patch": "@@ -427,6 +427,86 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n       Target.Count := Source.Count;\n    end Assign;\n \n+   -----------------\n+   -- Child_Count --\n+   -----------------\n+\n+   function Child_Count (Parent : Cursor) return Count_Type is\n+   begin\n+      if Parent = No_Element then\n+         return 0;\n+      end if;\n+\n+      if Parent.Container.Count = 0 then\n+         pragma Assert (Is_Root (Parent));\n+         return 0;\n+      end if;\n+\n+      return Child_Count (Parent.Container.all, Parent.Node);\n+   end Child_Count;\n+\n+   function Child_Count\n+     (Container : Tree;\n+      Parent    : Count_Type) return Count_Type\n+   is\n+      NN : Tree_Node_Array renames Container.Nodes;\n+      CC : Children_Type renames NN (Parent).Children;\n+\n+      Result : Count_Type;\n+      Node   : Count_Type'Base;\n+\n+   begin\n+      Result := 0;\n+      Node := CC.First;\n+      while Node > 0 loop\n+         Result := Result + 1;\n+         Node := NN (Node).Next;\n+      end loop;\n+\n+      return Result;\n+   end Child_Count;\n+\n+   -----------------\n+   -- Child_Depth --\n+   -----------------\n+\n+   function Child_Depth (Parent, Child : Cursor) return Count_Type is\n+      Result : Count_Type;\n+      N      : Count_Type'Base;\n+\n+   begin\n+      if Parent = No_Element then\n+         raise Constraint_Error with \"Parent cursor has no element\";\n+      end if;\n+\n+      if Child = No_Element then\n+         raise Constraint_Error with \"Child cursor has no element\";\n+      end if;\n+\n+      if Parent.Container /= Child.Container then\n+         raise Program_Error with \"Parent and Child in different containers\";\n+      end if;\n+\n+      if Parent.Container.Count = 0 then\n+         pragma Assert (Is_Root (Parent));\n+         pragma Assert (Child = Parent);\n+         return 0;\n+      end if;\n+\n+      Result := 0;\n+      N := Child.Node;\n+      while N /= Parent.Node loop\n+         Result := Result + 1;\n+         N := Parent.Container.Nodes (N).Parent;\n+\n+         if N < 0 then\n+            raise Program_Error with \"Parent is not ancestor of Child\";\n+         end if;\n+      end loop;\n+\n+      return Result;\n+   end Child_Depth;\n+\n    -----------\n    -- Clear --\n    -----------\n@@ -581,86 +661,6 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n       T_Node.Children := T_CC;\n    end Copy_Children;\n \n-   -----------------\n-   -- Child_Count --\n-   -----------------\n-\n-   function Child_Count (Parent : Cursor) return Count_Type is\n-   begin\n-      if Parent = No_Element then\n-         return 0;\n-      end if;\n-\n-      if Parent.Container.Count = 0 then\n-         pragma Assert (Is_Root (Parent));\n-         return 0;\n-      end if;\n-\n-      return Child_Count (Parent.Container.all, Parent.Node);\n-   end Child_Count;\n-\n-   function Child_Count\n-     (Container : Tree;\n-      Parent    : Count_Type) return Count_Type\n-   is\n-      NN : Tree_Node_Array renames Container.Nodes;\n-      CC : Children_Type renames NN (Parent).Children;\n-\n-      Result : Count_Type;\n-      Node   : Count_Type'Base;\n-\n-   begin\n-      Result := 0;\n-      Node := CC.First;\n-      while Node > 0 loop\n-         Result := Result + 1;\n-         Node := NN (Node).Next;\n-      end loop;\n-\n-      return Result;\n-   end Child_Count;\n-\n-   -----------------\n-   -- Child_Depth --\n-   -----------------\n-\n-   function Child_Depth (Parent, Child : Cursor) return Count_Type is\n-      Result : Count_Type;\n-      N      : Count_Type'Base;\n-\n-   begin\n-      if Parent = No_Element then\n-         raise Constraint_Error with \"Parent cursor has no element\";\n-      end if;\n-\n-      if Child = No_Element then\n-         raise Constraint_Error with \"Child cursor has no element\";\n-      end if;\n-\n-      if Parent.Container /= Child.Container then\n-         raise Program_Error with \"Parent and Child in different containers\";\n-      end if;\n-\n-      if Parent.Container.Count = 0 then\n-         pragma Assert (Is_Root (Parent));\n-         pragma Assert (Child = Parent);\n-         return 0;\n-      end if;\n-\n-      Result := 0;\n-      N := Child.Node;\n-      while N /= Parent.Node loop\n-         Result := Result + 1;\n-         N := Parent.Container.Nodes (N).Parent;\n-\n-         if N < 0 then\n-            raise Program_Error with \"Parent is not ancestor of Child\";\n-         end if;\n-      end loop;\n-\n-      return Result;\n-   end Child_Depth;\n-\n    ------------------\n    -- Copy_Subtree --\n    ------------------"}, {"sha": "a7f16ae1574609635a411d408ae0510c0662cc9c", "filename": "gcc/ada/a-cimutr.adb", "status": "modified", "additions": 63, "deletions": 63, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/993f8920f402a8292fae58b22c03e31f3a308cf8/gcc%2Fada%2Fa-cimutr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/993f8920f402a8292fae58b22c03e31f3a308cf8/gcc%2Fada%2Fa-cimutr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cimutr.adb?ref=993f8920f402a8292fae58b22c03e31f3a308cf8", "patch": "@@ -295,6 +295,69 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n       Target.Count := Source_Count;\n    end Assign;\n \n+   -----------------\n+   -- Child_Count --\n+   -----------------\n+\n+   function Child_Count (Parent : Cursor) return Count_Type is\n+   begin\n+      if Parent = No_Element then\n+         return 0;\n+      end if;\n+\n+      return Child_Count (Parent.Node.Children);\n+   end Child_Count;\n+\n+   function Child_Count (Children : Children_Type) return Count_Type is\n+      Result : Count_Type;\n+      Node   : Tree_Node_Access;\n+\n+   begin\n+      Result := 0;\n+      Node := Children.First;\n+      while Node /= null loop\n+         Result := Result + 1;\n+         Node := Node.Next;\n+      end loop;\n+\n+      return Result;\n+   end Child_Count;\n+\n+   -----------------\n+   -- Child_Depth --\n+   -----------------\n+\n+   function Child_Depth (Parent, Child : Cursor) return Count_Type is\n+      Result : Count_Type;\n+      N      : Tree_Node_Access;\n+\n+   begin\n+      if Parent = No_Element then\n+         raise Constraint_Error with \"Parent cursor has no element\";\n+      end if;\n+\n+      if Child = No_Element then\n+         raise Constraint_Error with \"Child cursor has no element\";\n+      end if;\n+\n+      if Parent.Container /= Child.Container then\n+         raise Program_Error with \"Parent and Child in different containers\";\n+      end if;\n+\n+      Result := 0;\n+      N := Child.Node;\n+      while N /= Parent.Node loop\n+         Result := Result + 1;\n+         N := N.Parent;\n+\n+         if N = null then\n+            raise Program_Error with \"Parent is not ancestor of Child\";\n+         end if;\n+      end loop;\n+\n+      return Result;\n+   end Child_Depth;\n+\n    -----------\n    -- Clear --\n    -----------\n@@ -418,69 +481,6 @@ package body Ada.Containers.Indefinite_Multiway_Trees is\n       Parent.Children := CC;\n    end Copy_Children;\n \n-   -----------------\n-   -- Child_Count --\n-   -----------------\n-\n-   function Child_Count (Parent : Cursor) return Count_Type is\n-   begin\n-      if Parent = No_Element then\n-         return 0;\n-      end if;\n-\n-      return Child_Count (Parent.Node.Children);\n-   end Child_Count;\n-\n-   function Child_Count (Children : Children_Type) return Count_Type is\n-      Result : Count_Type;\n-      Node   : Tree_Node_Access;\n-\n-   begin\n-      Result := 0;\n-      Node := Children.First;\n-      while Node /= null loop\n-         Result := Result + 1;\n-         Node := Node.Next;\n-      end loop;\n-\n-      return Result;\n-   end Child_Count;\n-\n-   -----------------\n-   -- Child_Depth --\n-   -----------------\n-\n-   function Child_Depth (Parent, Child : Cursor) return Count_Type is\n-      Result : Count_Type;\n-      N      : Tree_Node_Access;\n-\n-   begin\n-      if Parent = No_Element then\n-         raise Constraint_Error with \"Parent cursor has no element\";\n-      end if;\n-\n-      if Child = No_Element then\n-         raise Constraint_Error with \"Child cursor has no element\";\n-      end if;\n-\n-      if Parent.Container /= Child.Container then\n-         raise Program_Error with \"Parent and Child in different containers\";\n-      end if;\n-\n-      Result := 0;\n-      N := Child.Node;\n-      while N /= Parent.Node loop\n-         Result := Result + 1;\n-         N := N.Parent;\n-\n-         if N = null then\n-            raise Program_Error with \"Parent is not ancestor of Child\";\n-         end if;\n-      end loop;\n-\n-      return Result;\n-   end Child_Depth;\n-\n    ------------------\n    -- Copy_Subtree --\n    ------------------"}, {"sha": "f3c77ed6211ec3090ff7d8ee4a00a17f3ecdbdfa", "filename": "gcc/ada/a-comutr.adb", "status": "modified", "additions": 63, "deletions": 63, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/993f8920f402a8292fae58b22c03e31f3a308cf8/gcc%2Fada%2Fa-comutr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/993f8920f402a8292fae58b22c03e31f3a308cf8/gcc%2Fada%2Fa-comutr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-comutr.adb?ref=993f8920f402a8292fae58b22c03e31f3a308cf8", "patch": "@@ -291,6 +291,69 @@ package body Ada.Containers.Multiway_Trees is\n       Target.Count := Source_Count;\n    end Assign;\n \n+   -----------------\n+   -- Child_Count --\n+   -----------------\n+\n+   function Child_Count (Parent : Cursor) return Count_Type is\n+   begin\n+      if Parent = No_Element then\n+         return 0;\n+      end if;\n+\n+      return Child_Count (Parent.Node.Children);\n+   end Child_Count;\n+\n+   function Child_Count (Children : Children_Type) return Count_Type is\n+      Result : Count_Type;\n+      Node   : Tree_Node_Access;\n+\n+   begin\n+      Result := 0;\n+      Node := Children.First;\n+      while Node /= null loop\n+         Result := Result + 1;\n+         Node := Node.Next;\n+      end loop;\n+\n+      return Result;\n+   end Child_Count;\n+\n+   -----------------\n+   -- Child_Depth --\n+   -----------------\n+\n+   function Child_Depth (Parent, Child : Cursor) return Count_Type is\n+      Result : Count_Type;\n+      N      : Tree_Node_Access;\n+\n+   begin\n+      if Parent = No_Element then\n+         raise Constraint_Error with \"Parent cursor has no element\";\n+      end if;\n+\n+      if Child = No_Element then\n+         raise Constraint_Error with \"Child cursor has no element\";\n+      end if;\n+\n+      if Parent.Container /= Child.Container then\n+         raise Program_Error with \"Parent and Child in different containers\";\n+      end if;\n+\n+      Result := 0;\n+      N := Child.Node;\n+      while N /= Parent.Node loop\n+         Result := Result + 1;\n+         N := N.Parent;\n+\n+         if N = null then\n+            raise Program_Error with \"Parent is not ancestor of Child\";\n+         end if;\n+      end loop;\n+\n+      return Result;\n+   end Child_Depth;\n+\n    -----------\n    -- Clear --\n    -----------\n@@ -413,69 +476,6 @@ package body Ada.Containers.Multiway_Trees is\n       Parent.Children := CC;\n    end Copy_Children;\n \n-   -----------------\n-   -- Child_Count --\n-   -----------------\n-\n-   function Child_Count (Parent : Cursor) return Count_Type is\n-   begin\n-      if Parent = No_Element then\n-         return 0;\n-      end if;\n-\n-      return Child_Count (Parent.Node.Children);\n-   end Child_Count;\n-\n-   function Child_Count (Children : Children_Type) return Count_Type is\n-      Result : Count_Type;\n-      Node   : Tree_Node_Access;\n-\n-   begin\n-      Result := 0;\n-      Node := Children.First;\n-      while Node /= null loop\n-         Result := Result + 1;\n-         Node := Node.Next;\n-      end loop;\n-\n-      return Result;\n-   end Child_Count;\n-\n-   -----------------\n-   -- Child_Depth --\n-   -----------------\n-\n-   function Child_Depth (Parent, Child : Cursor) return Count_Type is\n-      Result : Count_Type;\n-      N      : Tree_Node_Access;\n-\n-   begin\n-      if Parent = No_Element then\n-         raise Constraint_Error with \"Parent cursor has no element\";\n-      end if;\n-\n-      if Child = No_Element then\n-         raise Constraint_Error with \"Child cursor has no element\";\n-      end if;\n-\n-      if Parent.Container /= Child.Container then\n-         raise Program_Error with \"Parent and Child in different containers\";\n-      end if;\n-\n-      Result := 0;\n-      N := Child.Node;\n-      while N /= Parent.Node loop\n-         Result := Result + 1;\n-         N := N.Parent;\n-\n-         if N = null then\n-            raise Program_Error with \"Parent is not ancestor of Child\";\n-         end if;\n-      end loop;\n-\n-      return Result;\n-   end Child_Depth;\n-\n    ------------------\n    -- Copy_Subtree --\n    ------------------"}, {"sha": "f97dbb4adb1ed577a607d3fb7c38ea3d08212984", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 33, "deletions": 10, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/993f8920f402a8292fae58b22c03e31f3a308cf8/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/993f8920f402a8292fae58b22c03e31f3a308cf8/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=993f8920f402a8292fae58b22c03e31f3a308cf8", "patch": "@@ -12357,14 +12357,37 @@ package body Sem_Util is\n    -----------------\n \n    function Unique_Name (E : Entity_Id) return String is\n-      Name : constant String := Get_Name_String (Chars (E));\n+\n+      function Get_Scoped_Name (E : Entity_Id) return String;\n+      --  Return the name of E prefixed by all the names of the scopes to which\n+      --  E belongs, except for Standard.\n+\n+      ---------------------\n+      -- Get_Scoped_Name --\n+      ---------------------\n+\n+      function Get_Scoped_Name (E : Entity_Id) return String is\n+         Name : constant String := Get_Name_String (Chars (E));\n+      begin\n+         if Has_Fully_Qualified_Name (E)\n+           or else Scope (E) = Standard_Standard\n+         then\n+            return Name;\n+         else\n+            return Get_Scoped_Name (Scope (E)) & \"__\" & Name;\n+         end if;\n+      end Get_Scoped_Name;\n+\n    begin\n-      if Has_Fully_Qualified_Name (E)\n-        or else E = Standard_Standard\n-      then\n-         return Name;\n+      if E = Standard_Standard then\n+         return Get_Name_String (Name_Standard);\n+\n+      elsif Scope (E) = Standard_Standard then\n+         return Get_Name_String (Name_Standard) & \"__\" &\n+           Get_Name_String (Chars (E));\n+\n       else\n-         return Unique_Name (Scope (E)) & \"__\" & Name;\n+         return Get_Scoped_Name (E);\n       end if;\n    end Unique_Name;\n \n@@ -12478,15 +12501,15 @@ package body Sem_Util is\n    --  Start of processing for Unit_Is_Visible\n \n    begin\n-      --  The currrent unit is directly visible.\n+      --  The currrent unit is directly visible\n \n       if Curr = U then\n          return True;\n \n       elsif Unit_In_Context (Curr) then\n          return True;\n \n-      --  If the current unit is a body, check the context of the spec.\n+      --  If the current unit is a body, check the context of the spec\n \n       elsif Nkind (Unit (Curr)) = N_Package_Body\n         or else\n@@ -12498,7 +12521,7 @@ package body Sem_Util is\n          end if;\n       end if;\n \n-      --  If the spec is a child unit, examine the parents.\n+      --  If the spec is a child unit, examine the parents\n \n       if Is_Child_Unit (Curr_Entity) then\n          if Nkind (Unit (Curr)) in N_Unit_Body then\n@@ -12670,7 +12693,7 @@ package body Sem_Util is\n             if Comes_From_Source (Expec_Type) then\n                Matching_Field := Expec_Type;\n \n-            --  For an assignment, use name of target.\n+            --  For an assignment, use name of target\n \n             elsif Nkind (Parent (Expr)) = N_Assignment_Statement\n               and then Is_Entity_Name (Name (Parent (Expr)))"}]}