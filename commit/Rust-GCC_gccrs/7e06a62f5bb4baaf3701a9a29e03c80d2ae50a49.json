{"sha": "7e06a62f5bb4baaf3701a9a29e03c80d2ae50a49", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2UwNmE2MmY1YmI0YmFhZjM3MDFhOWEyOWUwM2M4MGQyYWU1MGE0OQ==", "commit": {"author": {"name": "Gary Dismukes", "email": "dismukes@adacore.com", "date": "2020-06-03T23:53:33Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-07-16T09:17:55Z"}, "message": "[Ada] AI12-0042: Type invariant checking rules\n\ngcc/ada/\n\n\t* exp_ch4.adb (Expand_N_Type_Conversion): Handle the case of\n\tapplying an invariant check for a conversion to a class-wide\n\ttype whose root type has a type invariant, when the conversion\n\tappears within the immediate scope of the type and the\n\texpression is of a specific tagged type.\n\t* sem_ch3.adb (Is_Private_Primitive): New function to determine\n\twhether a primitive subprogram is a private operation.\n\t(Check_Abstract_Overriding): Enforce the restriction imposed by\n\tAI12-0042 of requiring overriding of an inherited nonabstract\n\tprivate operation when the ancestor has a class-wide type\n\tinvariant and the ancestor's private operation is visible.\n\t(Derive_Subprogram): Set Requires_Overriding on a subprogram\n\tinherited from a visible private operation of an ancestor to\n\twhich a Type_Invariant'Class expression applies.", "tree": {"sha": "b55d885e03702f44a908632cd9dc4d6b9fc7545c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b55d885e03702f44a908632cd9dc4d6b9fc7545c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7e06a62f5bb4baaf3701a9a29e03c80d2ae50a49", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e06a62f5bb4baaf3701a9a29e03c80d2ae50a49", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e06a62f5bb4baaf3701a9a29e03c80d2ae50a49", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e06a62f5bb4baaf3701a9a29e03c80d2ae50a49/comments", "author": {"login": "dismukes", "id": 50880541, "node_id": "MDQ6VXNlcjUwODgwNTQx", "avatar_url": "https://avatars.githubusercontent.com/u/50880541?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dismukes", "html_url": "https://github.com/dismukes", "followers_url": "https://api.github.com/users/dismukes/followers", "following_url": "https://api.github.com/users/dismukes/following{/other_user}", "gists_url": "https://api.github.com/users/dismukes/gists{/gist_id}", "starred_url": "https://api.github.com/users/dismukes/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dismukes/subscriptions", "organizations_url": "https://api.github.com/users/dismukes/orgs", "repos_url": "https://api.github.com/users/dismukes/repos", "events_url": "https://api.github.com/users/dismukes/events{/privacy}", "received_events_url": "https://api.github.com/users/dismukes/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6805c1c6a6254b6df6799d820c0d08a3dbfbec96", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6805c1c6a6254b6df6799d820c0d08a3dbfbec96", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6805c1c6a6254b6df6799d820c0d08a3dbfbec96"}], "stats": {"total": 109, "additions": 108, "deletions": 1}, "files": [{"sha": "fd75eb8e38a06f38e9a5bd71a28c2b7830d51738", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e06a62f5bb4baaf3701a9a29e03c80d2ae50a49/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e06a62f5bb4baaf3701a9a29e03c80d2ae50a49/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=7e06a62f5bb4baaf3701a9a29e03c80d2ae50a49", "patch": "@@ -11951,6 +11951,39 @@ package body Exp_Ch4 is\n          Remove_Side_Effects (N);\n          Insert_Action (N, Make_Invariant_Call (Duplicate_Subexpr (N)));\n          goto Done;\n+\n+      --  AI12-0042: For a view conversion to a class-wide type occurring\n+      --  within the immediate scope of T, from a specific type that is\n+      --  a descendant of T (including T itself), an invariant check is\n+      --  performed on the part of the object that is of type T. (We don't\n+      --  need to explicitly check for the operand type being a descendant,\n+      --  just that it's a specific type, because the conversion would be\n+      --  illegal if it's specific and not a descendant -- downward conversion\n+      --  is not allowed).\n+\n+      elsif Is_Class_Wide_Type (Target_Type)\n+        and then not Is_Class_Wide_Type (Etype (Expression (N)))\n+        and then Present (Invariant_Procedure (Root_Type (Target_Type)))\n+        and then Comes_From_Source (N)\n+        and then Within_Scope (Find_Enclosing_Scope (N), Scope (Target_Type))\n+      then\n+         Remove_Side_Effects (N);\n+\n+         --  Perform the invariant check on a conversion to the class-wide\n+         --  type's root type.\n+\n+         declare\n+            Root_Conv : constant Node_Id :=\n+              Make_Type_Conversion (Loc,\n+                Subtype_Mark =>\n+                  New_Occurrence_Of (Root_Type (Target_Type), Loc),\n+                Expression   => Duplicate_Subexpr (Expression (N)));\n+         begin\n+            Set_Etype (Root_Conv, Root_Type (Target_Type));\n+\n+            Insert_Action (N, Make_Invariant_Call (Root_Conv));\n+            goto Done;\n+         end;\n       end if;\n \n       --  Here if we may need to expand conversion"}, {"sha": "78a22a44a3f0d31309455d3514e95b68466de097", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 75, "deletions": 1, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e06a62f5bb4baaf3701a9a29e03c80d2ae50a49/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e06a62f5bb4baaf3701a9a29e03c80d2ae50a49/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=7e06a62f5bb4baaf3701a9a29e03c80d2ae50a49", "patch": "@@ -579,6 +579,12 @@ package body Sem_Ch3 is\n    --  Extensions_Visible with value False and has at least one controlling\n    --  parameter of mode OUT.\n \n+   function Is_Private_Primitive (Prim : Entity_Id) return Boolean;\n+   --  Subsidiary to Check_Abstract_Overriding and Derive_Subprogram.\n+   --  When applied to a primitive subprogram Prim, returns True if Prim is\n+   --  declared as a private operation within a package or generic package,\n+   --  and returns False otherwise.\n+\n    function Is_Valid_Constraint_Kind\n      (T_Kind          : Type_Kind;\n       Constraint_Kind : Node_Kind) return Boolean;\n@@ -10754,6 +10760,32 @@ package body Sem_Ch3 is\n          elsif Present (Interface_Alias (Subp)) then\n             null;\n \n+         --  AI12-0042: Test for rule in 7.3.2(6.1/4), that requires overriding\n+         --  of a visible private primitive inherited from an ancestor with\n+         --  the aspect Type_Invariant'Class, unless the inherited primitive\n+         --  is abstract. (The test for the extension occurring in a different\n+         --  scope than the ancestor is to avoid requiring overriding when\n+         --  extending in the same scope, because the inherited primitive will\n+         --  also be private in that case, which looks like an unhelpful\n+         --  restriction that may break reasonable code, though the rule\n+         --  appears to apply in the same-scope case as well???)\n+\n+         elsif not Is_Abstract_Subprogram (Subp)\n+           and then not Comes_From_Source (Subp) -- An inherited subprogram\n+           and then Requires_Overriding (Subp)\n+           and then Present (Alias_Subp)\n+           and then Has_Invariants (Etype (T))\n+           and then Present (Get_Pragma (Etype (T), Pragma_Invariant))\n+           and then Class_Present (Get_Pragma (Etype (T), Pragma_Invariant))\n+           and then Is_Private_Primitive (Alias_Subp)\n+           and then Scope (Subp) /= Scope (Alias_Subp)\n+         then\n+            Error_Msg_NE\n+              (\"inherited private primitive & must be overridden\", T, Subp);\n+            Error_Msg_N\n+              (\"\\because ancestor type has 'Type_'Invariant''Class \" &\n+               \"(RM 7.3.2(6.1))\", T);\n+\n          elsif (Is_Abstract_Subprogram (Subp)\n                  or else Requires_Overriding (Subp)\n                  or else\n@@ -15676,6 +15708,9 @@ package body Sem_Ch3 is\n       --  Ada 2005 (AI-228): Calculate the \"require overriding\" and \"abstract\"\n       --  properties of the subprogram, as defined in RM-3.9.3(4/2-6/2).\n \n+      --  Ada 202x (AI12-0042): Similarly, set those properties for\n+      --  implementing the rule of RM 7.3.2(6.1/4).\n+\n       --  A subprogram subject to pragma Extensions_Visible with value False\n       --  requires overriding if the subprogram has at least one controlling\n       --  OUT parameter (SPARK RM 6.1.7(6)).\n@@ -15692,7 +15727,23 @@ package body Sem_Ch3 is\n                                                         Derived_Type\n                              and then not Is_Null_Extension (Derived_Type))\n                    or else (Comes_From_Source (Alias (New_Subp))\n-                             and then Is_EVF_Procedure (Alias (New_Subp))))\n+                             and then Is_EVF_Procedure (Alias (New_Subp)))\n+\n+                   --  AI12-0042: Set Requires_Overriding when a type extension\n+                   --  inherits a private operation that is visible at the\n+                   --  point of extension (Has_Private_Ancestor is False) from\n+                   --  an ancestor that has Type_Invariant'Class.\n+\n+                   or else\n+                     (not Has_Private_Ancestor (Derived_Type)\n+                       and then Has_Invariants (Parent_Type)\n+                       and then\n+                         Present (Get_Pragma (Parent_Type, Pragma_Invariant))\n+                       and then\n+                         Class_Present\n+                           (Get_Pragma (Parent_Type, Pragma_Invariant))\n+                       and then Is_Private_Primitive (Parent_Subp)))\n+\n         and then No (Actual_Subp)\n       then\n          if not Is_Tagged_Type (Derived_Type)\n@@ -18727,6 +18778,29 @@ package body Sem_Ch3 is\n       end if;\n    end Is_Null_Extension;\n \n+   --------------------------\n+   -- Is_Private_Primitive --\n+   --------------------------\n+\n+   function Is_Private_Primitive (Prim : Entity_Id) return Boolean is\n+      Prim_Scope  : constant Entity_Id := Scope (Prim);\n+      Priv_Entity : Entity_Id;\n+   begin\n+      if Is_Package_Or_Generic_Package (Prim_Scope) then\n+         Priv_Entity := First_Private_Entity (Prim_Scope);\n+\n+         while Present (Priv_Entity) loop\n+            if Priv_Entity = Prim then\n+               return True;\n+            end if;\n+\n+            Next_Entity (Priv_Entity);\n+         end loop;\n+      end if;\n+\n+      return False;\n+   end Is_Private_Primitive;\n+\n    ------------------------------\n    -- Is_Valid_Constraint_Kind --\n    ------------------------------"}]}