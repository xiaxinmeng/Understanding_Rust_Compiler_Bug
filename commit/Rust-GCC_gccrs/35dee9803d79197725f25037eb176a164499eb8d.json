{"sha": "35dee9803d79197725f25037eb176a164499eb8d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzVkZWU5ODAzZDc5MTk3NzI1ZjI1MDM3ZWIxNzZhMTY0NDk5ZWI4ZA==", "commit": {"author": {"name": "Hans-Peter Nilsson", "email": "hp@axis.com", "date": "2008-02-19T04:13:05Z"}, "committer": {"name": "Hans-Peter Nilsson", "email": "hp@gcc.gnu.org", "date": "2008-02-19T04:13:05Z"}, "message": "Support valgrind 3.3 for --enable-checking=valgrind.\n\n\t* system.h: Consolidate ENABLE_VALGRIND_CHECKING-dependent defines\n\there.\n\t[!VALGRIND_MAKE_MEM_NOACCESS]: Define as VALGRIND_MAKE_NOACCESS.\n\t[!VALGRIND_MAKE_MEM_DEFINED]: Define as VALGRIND_MAKE_READABLE.\n\t[!VALGRIND_MAKE_MEM_UNDEFINED]: Define as VALGRIND_MAKE_WRITABLE.\n\t* ggc-common.c: Remove ENABLE_VALGRIND_CHECKING-dependent defines.\n\tReplace use of VALGRIND_MAKE_READABLE, VALGRIND_MAKE_WRITABLE, and\n\tVALGRIND_MAKE_NOACCESS with VALGRIND_MAKE_MEM_DEFINED,\n\tVALGRIND_MAKE_MEM_UNDEFINED, and VALGRIND_MAKE_MEM_NOACCESS\n\trespectively.\n\t* ggc-zone.c: Similar.\n\t* ggc-page.c: Similar.\n\nFrom-SVN: r132407", "tree": {"sha": "ea3822f937ca2bf97d74dca204d93f8e7bb15773", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ea3822f937ca2bf97d74dca204d93f8e7bb15773"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/35dee9803d79197725f25037eb176a164499eb8d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35dee9803d79197725f25037eb176a164499eb8d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/35dee9803d79197725f25037eb176a164499eb8d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35dee9803d79197725f25037eb176a164499eb8d/comments", "author": {"login": "hpataxisdotcom", "id": 80339731, "node_id": "MDQ6VXNlcjgwMzM5NzMx", "avatar_url": "https://avatars.githubusercontent.com/u/80339731?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hpataxisdotcom", "html_url": "https://github.com/hpataxisdotcom", "followers_url": "https://api.github.com/users/hpataxisdotcom/followers", "following_url": "https://api.github.com/users/hpataxisdotcom/following{/other_user}", "gists_url": "https://api.github.com/users/hpataxisdotcom/gists{/gist_id}", "starred_url": "https://api.github.com/users/hpataxisdotcom/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hpataxisdotcom/subscriptions", "organizations_url": "https://api.github.com/users/hpataxisdotcom/orgs", "repos_url": "https://api.github.com/users/hpataxisdotcom/repos", "events_url": "https://api.github.com/users/hpataxisdotcom/events{/privacy}", "received_events_url": "https://api.github.com/users/hpataxisdotcom/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5ff3a2088013a1ba1dd79ca6cd27cc78f5640a3d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ff3a2088013a1ba1dd79ca6cd27cc78f5640a3d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ff3a2088013a1ba1dd79ca6cd27cc78f5640a3d"}], "stats": {"total": 161, "additions": 88, "deletions": 73}, "files": [{"sha": "7201027a80347567efc72f7d42af8c8065346442", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35dee9803d79197725f25037eb176a164499eb8d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35dee9803d79197725f25037eb176a164499eb8d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=35dee9803d79197725f25037eb176a164499eb8d", "patch": "@@ -1,3 +1,19 @@\n+2008-02-19  Hans-Peter Nilsson  <hp@axis.com>\n+\n+\tSupport valgrind 3.3 for --enable-checking=valgrind.\n+\t* system.h: Consolidate ENABLE_VALGRIND_CHECKING-dependent defines\n+\there.\n+\t[!VALGRIND_MAKE_MEM_NOACCESS]: Define as VALGRIND_MAKE_NOACCESS.\n+\t[!VALGRIND_MAKE_MEM_DEFINED]: Define as VALGRIND_MAKE_READABLE.\n+\t[!VALGRIND_MAKE_MEM_UNDEFINED]: Define as VALGRIND_MAKE_WRITABLE.\n+\t* ggc-common.c: Remove ENABLE_VALGRIND_CHECKING-dependent defines.\n+\tReplace use of VALGRIND_MAKE_READABLE, VALGRIND_MAKE_WRITABLE, and\n+\tVALGRIND_MAKE_NOACCESS with VALGRIND_MAKE_MEM_DEFINED,\n+\tVALGRIND_MAKE_MEM_UNDEFINED, and VALGRIND_MAKE_MEM_NOACCESS\n+\trespectively.\n+\t* ggc-zone.c: Similar.\n+\t* ggc-page.c: Similar.\n+\n 2008-02-19  Paul Brook  <paul@codesourcery.com>\n \n \tPR target/35071"}, {"sha": "8e67f760b5c111ab46c33bf49616d90445d4ef44", "filename": "gcc/ggc-common.c", "status": "modified", "additions": 4, "deletions": 17, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35dee9803d79197725f25037eb176a164499eb8d/gcc%2Fggc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35dee9803d79197725f25037eb176a164499eb8d/gcc%2Fggc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-common.c?ref=35dee9803d79197725f25037eb176a164499eb8d", "patch": "@@ -47,19 +47,6 @@ along with GCC; see the file COPYING3.  If not see\n # define MAP_FAILED ((void *)-1)\n #endif\n \n-#ifdef ENABLE_VALGRIND_CHECKING\n-# ifdef HAVE_VALGRIND_MEMCHECK_H\n-#  include <valgrind/memcheck.h>\n-# elif defined HAVE_MEMCHECK_H\n-#  include <memcheck.h>\n-# else\n-#  include <valgrind.h>\n-# endif\n-#else\n-/* Avoid #ifdef:s when we can help it.  */\n-#define VALGRIND_DISCARD(x)\n-#endif\n-\n /* When set, ggc_collect will do collection.  */\n bool ggc_force_collect;\n \n@@ -163,9 +150,9 @@ ggc_realloc_stat (void *x, size_t size MEM_STAT_DECL)\n \t old_size as reachable, but that would lose tracking of writes\n \t after the end of the object (by small offsets).  Discard the\n \t handle to avoid handle leak.  */\n-      VALGRIND_DISCARD (VALGRIND_MAKE_NOACCESS ((char *) x + size,\n-\t\t\t\t\t\told_size - size));\n-      VALGRIND_DISCARD (VALGRIND_MAKE_READABLE (x, size));\n+      VALGRIND_DISCARD (VALGRIND_MAKE_MEM_NOACCESS ((char *) x + size,\n+\t\t\t\t\t\t    old_size - size));\n+      VALGRIND_DISCARD (VALGRIND_MAKE_MEM_DEFINED (x, size));\n       return x;\n     }\n \n@@ -175,7 +162,7 @@ ggc_realloc_stat (void *x, size_t size MEM_STAT_DECL)\n      individually allocated object, we'd access parts of the old object\n      that were marked invalid with the memcpy below.  We lose a bit of the\n      initialization-tracking since some of it may be uninitialized.  */\n-  VALGRIND_DISCARD (VALGRIND_MAKE_READABLE (x, old_size));\n+  VALGRIND_DISCARD (VALGRIND_MAKE_MEM_DEFINED (x, old_size));\n \n   memcpy (r, x, old_size);\n "}, {"sha": "ea637b1b63c2869f4eed2362cebe3d4d639e9249", "filename": "gcc/ggc-page.c", "status": "modified", "additions": 11, "deletions": 22, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35dee9803d79197725f25037eb176a164499eb8d/gcc%2Fggc-page.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35dee9803d79197725f25037eb176a164499eb8d/gcc%2Fggc-page.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-page.c?ref=35dee9803d79197725f25037eb176a164499eb8d", "patch": "@@ -31,18 +31,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"timevar.h\"\n #include \"params.h\"\n #include \"tree-flow.h\"\n-#ifdef ENABLE_VALGRIND_CHECKING\n-# ifdef HAVE_VALGRIND_MEMCHECK_H\n-#  include <valgrind/memcheck.h>\n-# elif defined HAVE_MEMCHECK_H\n-#  include <memcheck.h>\n-# else\n-#  include <valgrind.h>\n-# endif\n-#else\n-/* Avoid #ifdef:s when we can help it.  */\n-#define VALGRIND_DISCARD(x)\n-#endif\n \n /* Prefer MAP_ANON(YMOUS) to /dev/zero, since we don't need to keep a\n    file open.  Prefer either to valloc.  */\n@@ -689,7 +677,7 @@ alloc_anon (char *pref ATTRIBUTE_UNUSED, size_t size)\n   /* Pretend we don't have access to the allocated pages.  We'll enable\n      access to smaller pieces of the area in ggc_alloc.  Discard the\n      handle to avoid handle leak.  */\n-  VALGRIND_DISCARD (VALGRIND_MAKE_NOACCESS (page, size));\n+  VALGRIND_DISCARD (VALGRIND_MAKE_MEM_NOACCESS (page, size));\n \n   return page;\n }\n@@ -933,7 +921,7 @@ free_page (page_entry *entry)\n \n   /* Mark the page as inaccessible.  Discard the handle to avoid handle\n      leak.  */\n-  VALGRIND_DISCARD (VALGRIND_MAKE_NOACCESS (entry->page, entry->bytes));\n+  VALGRIND_DISCARD (VALGRIND_MAKE_MEM_NOACCESS (entry->page, entry->bytes));\n \n   set_page_table_entry (entry->page, NULL);\n \n@@ -1208,22 +1196,22 @@ ggc_alloc_stat (size_t size MEM_STAT_DECL)\n      exact same semantics in presence of memory bugs, regardless of\n      ENABLE_VALGRIND_CHECKING.  We override this request below.  Drop the\n      handle to avoid handle leak.  */\n-  VALGRIND_DISCARD (VALGRIND_MAKE_WRITABLE (result, object_size));\n+  VALGRIND_DISCARD (VALGRIND_MAKE_MEM_UNDEFINED (result, object_size));\n \n   /* `Poison' the entire allocated object, including any padding at\n      the end.  */\n   memset (result, 0xaf, object_size);\n \n   /* Make the bytes after the end of the object unaccessible.  Discard the\n      handle to avoid handle leak.  */\n-  VALGRIND_DISCARD (VALGRIND_MAKE_NOACCESS ((char *) result + size,\n-\t\t\t\t\t    object_size - size));\n+  VALGRIND_DISCARD (VALGRIND_MAKE_MEM_NOACCESS ((char *) result + size,\n+\t\t\t\t\t\tobject_size - size));\n #endif\n \n   /* Tell Valgrind that the memory is there, but its content isn't\n      defined.  The bytes at the end of the object are still marked\n      unaccessible.  */\n-  VALGRIND_DISCARD (VALGRIND_MAKE_WRITABLE (result, size));\n+  VALGRIND_DISCARD (VALGRIND_MAKE_MEM_UNDEFINED (result, size));\n \n   /* Keep track of how many bytes are being allocated.  This\n      information is used in deciding when to collect.  */\n@@ -1358,11 +1346,11 @@ ggc_free (void *p)\n \n #ifdef ENABLE_GC_CHECKING\n   /* Poison the data, to indicate the data is garbage.  */\n-  VALGRIND_DISCARD (VALGRIND_MAKE_WRITABLE (p, size));\n+  VALGRIND_DISCARD (VALGRIND_MAKE_MEM_UNDEFINED (p, size));\n   memset (p, 0xa5, size);\n #endif\n   /* Let valgrind know the object is free.  */\n-  VALGRIND_DISCARD (VALGRIND_MAKE_NOACCESS (p, size));\n+  VALGRIND_DISCARD (VALGRIND_MAKE_MEM_NOACCESS (p, size));\n \n #ifdef ENABLE_GC_ALWAYS_COLLECT\n   /* In the completely-anal-checking mode, we do *not* immediately free\n@@ -1815,11 +1803,12 @@ poison_pages (void)\n \t\t     so the exact same memory semantics is kept, in case\n \t\t     there are memory errors.  We override this request\n \t\t     below.  */\n-\t\t  VALGRIND_DISCARD (VALGRIND_MAKE_WRITABLE (object, size));\n+\t\t  VALGRIND_DISCARD (VALGRIND_MAKE_MEM_UNDEFINED (object,\n+\t\t\t\t\t\t\t\t size));\n \t\t  memset (object, 0xa5, size);\n \n \t\t  /* Drop the handle to avoid handle leak.  */\n-\t\t  VALGRIND_DISCARD (VALGRIND_MAKE_NOACCESS (object, size));\n+\t\t  VALGRIND_DISCARD (VALGRIND_MAKE_MEM_NOACCESS (object, size));\n \t\t}\n \t    }\n \t}"}, {"sha": "e8185a06381b406cb458102fd7295263aacd1b33", "filename": "gcc/ggc-zone.c", "status": "modified", "additions": 32, "deletions": 34, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35dee9803d79197725f25037eb176a164499eb8d/gcc%2Fggc-zone.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35dee9803d79197725f25037eb176a164499eb8d/gcc%2Fggc-zone.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-zone.c?ref=35dee9803d79197725f25037eb176a164499eb8d", "patch": "@@ -37,21 +37,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"params.h\"\n #include \"bitmap.h\"\n \n-#ifdef ENABLE_VALGRIND_CHECKING\n-# ifdef HAVE_VALGRIND_MEMCHECK_H\n-#  include <valgrind/memcheck.h>\n-# elif defined HAVE_MEMCHECK_H\n-#  include <memcheck.h>\n-# else\n-#  include <valgrind.h>\n-# endif\n-#else\n-/* Avoid #ifdef:s when we can help it.  */\n-#define VALGRIND_DISCARD(x)\n-#define VALGRIND_MALLOCLIKE_BLOCK(w,x,y,z)\n-#define VALGRIND_FREELIKE_BLOCK(x,y)\n-#endif\n-\n /* Prefer MAP_ANON(YMOUS) to /dev/zero, since we don't need to keep a\n    file open.  Prefer either to valloc.  */\n #ifdef HAVE_MMAP_ANON\n@@ -787,7 +772,7 @@ alloc_anon (char *pref ATTRIBUTE_UNUSED, size_t size, struct alloc_zone *zone)\n   /* Pretend we don't have access to the allocated pages.  We'll enable\n      access to smaller pieces of the area in ggc_alloc.  Discard the\n      handle to avoid handle leak.  */\n-  VALGRIND_DISCARD (VALGRIND_MAKE_NOACCESS (page, size));\n+  VALGRIND_DISCARD (VALGRIND_MAKE_MEM_NOACCESS (page, size));\n \n   return page;\n }\n@@ -903,8 +888,8 @@ free_small_page (struct small_page_entry *entry)\n \n   /* Mark the page as inaccessible.  Discard the handle to\n      avoid handle leak.  */\n-  VALGRIND_DISCARD (VALGRIND_MAKE_NOACCESS (entry->common.page,\n-\t\t\t\t\t    SMALL_PAGE_SIZE));\n+  VALGRIND_DISCARD (VALGRIND_MAKE_MEM_NOACCESS (entry->common.page,\n+\t\t\t\t\t\tSMALL_PAGE_SIZE));\n \n   entry->next = entry->common.zone->free_pages;\n   entry->common.zone->free_pages = entry;\n@@ -978,18 +963,30 @@ free_chunk (char *ptr, size_t size, struct alloc_zone *zone)\n   if (bin > NUM_FREE_BINS)\n     {\n       bin = 0;\n-      VALGRIND_DISCARD (VALGRIND_MAKE_WRITABLE (chunk, sizeof (struct alloc_chunk)));\n+      VALGRIND_DISCARD (VALGRIND_MAKE_MEM_UNDEFINED (chunk,\n+\t\t\t\t\t\t     sizeof (struct\n+\t\t\t\t\t\t\t     alloc_chunk)));\n       chunk->size = size;\n       chunk->next_free = zone->free_chunks[bin];\n-      VALGRIND_DISCARD (VALGRIND_MAKE_NOACCESS (ptr + sizeof (struct alloc_chunk),\n-\t\t\t\t\t\tsize - sizeof (struct alloc_chunk)));\n+      VALGRIND_DISCARD (VALGRIND_MAKE_MEM_NOACCESS (ptr\n+\t\t\t\t\t\t    + sizeof (struct\n+\t\t\t\t\t\t\t      alloc_chunk),\n+\t\t\t\t\t\t    size\n+\t\t\t\t\t\t    - sizeof (struct\n+\t\t\t\t\t\t\t      alloc_chunk)));\n     }\n   else\n     {\n-      VALGRIND_DISCARD (VALGRIND_MAKE_WRITABLE (chunk, sizeof (struct alloc_chunk *)));\n+      VALGRIND_DISCARD (VALGRIND_MAKE_MEM_UNDEFINED (chunk,\n+\t\t\t\t\t\t     sizeof (struct\n+\t\t\t\t\t\t\t     alloc_chunk *)));\n       chunk->next_free = zone->free_chunks[bin];\n-      VALGRIND_DISCARD (VALGRIND_MAKE_NOACCESS (ptr + sizeof (struct alloc_chunk *),\n-\t\t\t\t\t\tsize - sizeof (struct alloc_chunk *)));\n+      VALGRIND_DISCARD (VALGRIND_MAKE_MEM_NOACCESS (ptr\n+\t\t\t\t\t\t    + sizeof (struct\n+\t\t\t\t\t\t\t      alloc_chunk *),\n+\t\t\t\t\t\t    size\n+\t\t\t\t\t\t    - sizeof (struct\n+\t\t\t\t\t\t\t      alloc_chunk *)));\n     }\n \n   zone->free_chunks[bin] = chunk;\n@@ -1213,16 +1210,16 @@ ggc_alloc_zone_stat (size_t orig_size, struct alloc_zone *zone\n \n #ifdef ENABLE_GC_CHECKING\n   /* `Poison' the entire allocated object.  */\n-  VALGRIND_DISCARD (VALGRIND_MAKE_WRITABLE (result, size));\n+  VALGRIND_DISCARD (VALGRIND_MAKE_MEM_UNDEFINED (result, size));\n   memset (result, 0xaf, size);\n-  VALGRIND_DISCARD (VALGRIND_MAKE_NOACCESS (result + orig_size,\n-\t\t\t\t\t    size - orig_size));\n+  VALGRIND_DISCARD (VALGRIND_MAKE_MEM_NOACCESS (result + orig_size,\n+\t\t\t\t\t\tsize - orig_size));\n #endif\n \n   /* Tell Valgrind that the memory is there, but its content isn't\n      defined.  The bytes at the end of the object are still marked\n      unaccessible.  */\n-  VALGRIND_DISCARD (VALGRIND_MAKE_WRITABLE (result, orig_size));\n+  VALGRIND_DISCARD (VALGRIND_MAKE_MEM_UNDEFINED (result, orig_size));\n \n   /* Keep track of how many bytes are being allocated.  This\n      information is used in deciding when to collect.  */\n@@ -1701,9 +1698,9 @@ sweep_pages (struct alloc_zone *zone)\n \t\t{\n \t\t  if (last_free)\n \t\t    {\n-\t\t      VALGRIND_DISCARD (VALGRIND_MAKE_WRITABLE (last_free,\n-\t\t\t\t\t\t\t\tobject\n-\t\t\t\t\t\t\t\t- last_free));\n+\t\t      VALGRIND_DISCARD (VALGRIND_MAKE_MEM_UNDEFINED (last_free,\n+\t\t\t\t\t\t\t\t     object\n+\t\t\t\t\t\t\t\t     - last_free));\n \t\t      poison_region (last_free, object - last_free);\n \t\t      free_chunk (last_free, object - last_free, zone);\n \t\t      last_free = NULL;\n@@ -1739,7 +1736,8 @@ sweep_pages (struct alloc_zone *zone)\n \t{\n \t  *spp = snext;\n #ifdef ENABLE_GC_CHECKING\n-\t  VALGRIND_DISCARD (VALGRIND_MAKE_WRITABLE (sp->common.page, SMALL_PAGE_SIZE));\n+\t  VALGRIND_DISCARD (VALGRIND_MAKE_MEM_UNDEFINED (sp->common.page,\n+\t\t\t\t\t\t\t SMALL_PAGE_SIZE));\n \t  /* Poison the page.  */\n \t  memset (sp->common.page, 0xb5, SMALL_PAGE_SIZE);\n #endif\n@@ -1748,8 +1746,8 @@ sweep_pages (struct alloc_zone *zone)\n \t}\n       else if (last_free)\n \t{\n-\t  VALGRIND_DISCARD (VALGRIND_MAKE_WRITABLE (last_free,\n-\t\t\t\t\t\t    object - last_free));\n+\t  VALGRIND_DISCARD (VALGRIND_MAKE_MEM_UNDEFINED (last_free,\n+\t\t\t\t\t\t\t object - last_free));\n \t  poison_region (last_free, object - last_free);\n \t  free_chunk (last_free, object - last_free, zone);\n \t}"}, {"sha": "568bd751a4c6826bcfc6fdc6dbebe251a9bb8254", "filename": "gcc/system.h", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35dee9803d79197725f25037eb176a164499eb8d/gcc%2Fsystem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35dee9803d79197725f25037eb176a164499eb8d/gcc%2Fsystem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsystem.h?ref=35dee9803d79197725f25037eb176a164499eb8d", "patch": "@@ -804,4 +804,29 @@ extern void fancy_abort (const char *, int, const char *) ATTRIBUTE_NORETURN;\n #endif\n #endif\n \n+#ifdef ENABLE_VALGRIND_CHECKING\n+# ifdef HAVE_VALGRIND_MEMCHECK_H\n+#  include <valgrind/memcheck.h>\n+# elif defined HAVE_MEMCHECK_H\n+#  include <memcheck.h>\n+# else\n+#  include <valgrind.h>\n+# endif\n+/* Compatibility macros to let valgrind 3.1 work.  */\n+# ifndef VALGRIND_MAKE_MEM_NOACCESS\n+#  define VALGRIND_MAKE_MEM_NOACCESS VALGRIND_MAKE_NOACCESS\n+# endif\n+# ifndef VALGRIND_MAKE_MEM_DEFINED\n+#  define VALGRIND_MAKE_MEM_DEFINED VALGRIND_MAKE_READABLE\n+# endif\n+# ifndef VALGRIND_MAKE_MEM_UNDEFINED\n+#  define VALGRIND_MAKE_MEM_UNDEFINED VALGRIND_MAKE_WRITABLE\n+# endif\n+#else\n+/* Avoid #ifdef:s when we can help it.  */\n+#define VALGRIND_DISCARD(x)\n+#define VALGRIND_MALLOCLIKE_BLOCK(w,x,y,z)\n+#define VALGRIND_FREELIKE_BLOCK(x,y)\n+#endif\n+\n #endif /* ! GCC_SYSTEM_H */"}]}