{"sha": "dcb7fae249bd3b867d91dd85c2e66fd51eb2b45e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGNiN2ZhZTI0OWJkM2I4NjdkOTFkZDg1YzJlNjZmZDUxZWIyYjQ1ZQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2014-08-27T12:48:23Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2014-08-27T12:48:23Z"}, "message": "gimple-fold.c (get_maxval_strlen): Add overload wrapping get_maxval_strlen inside a more useful API.\n\n2014-08-27  Richard Biener  <rguenther@suse.de>\n\n\t* gimple-fold.c (get_maxval_strlen): Add overload wrapping\n\tget_maxval_strlen inside a more useful API.\n\t(gimple_fold_builtin_with_strlen): Remove and fold into ...\n\t(gimple_fold_builtin): ... caller.\n\t(gimple_fold_builtin_strlen, gimple_fold_builtin_strcpy,\n\tgimple_fold_builtin_strncpy, gimple_fold_builtin_strcat,\n\tgimple_fold_builtin_fputs, gimple_fold_builtin_memory_chk,\n\tgimple_fold_builtin_stxcpy_chk, gimple_fold_builtin_stxncpy_chk,\n\tgimple_fold_builtin_snprintf_chk, gimple_fold_builtin_snprintf,\n\tgimple_fold_builtin_sprintf): Adjust to compute maxval\n\tthemselves.\n\nFrom-SVN: r214574", "tree": {"sha": "6f07640491cfff476e56389a61fa27bec7ea6293", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6f07640491cfff476e56389a61fa27bec7ea6293"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dcb7fae249bd3b867d91dd85c2e66fd51eb2b45e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dcb7fae249bd3b867d91dd85c2e66fd51eb2b45e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dcb7fae249bd3b867d91dd85c2e66fd51eb2b45e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dcb7fae249bd3b867d91dd85c2e66fd51eb2b45e/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "14562eb9c47f3be8257f674e8196ac6ac5a967c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14562eb9c47f3be8257f674e8196ac6ac5a967c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/14562eb9c47f3be8257f674e8196ac6ac5a967c7"}], "stats": {"total": 325, "additions": 121, "deletions": 204}, "files": [{"sha": "6ccb0d32e9deac993c8379aae750a40fde79bcbd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dcb7fae249bd3b867d91dd85c2e66fd51eb2b45e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dcb7fae249bd3b867d91dd85c2e66fd51eb2b45e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dcb7fae249bd3b867d91dd85c2e66fd51eb2b45e", "patch": "@@ -1,3 +1,17 @@\n+2014-08-27  Richard Biener  <rguenther@suse.de>\n+\n+\t* gimple-fold.c (get_maxval_strlen): Add overload wrapping\n+\tget_maxval_strlen inside a more useful API.\n+\t(gimple_fold_builtin_with_strlen): Remove and fold into ...\n+\t(gimple_fold_builtin): ... caller.\n+\t(gimple_fold_builtin_strlen, gimple_fold_builtin_strcpy,\n+\tgimple_fold_builtin_strncpy, gimple_fold_builtin_strcat,\n+\tgimple_fold_builtin_fputs, gimple_fold_builtin_memory_chk,\n+\tgimple_fold_builtin_stxcpy_chk, gimple_fold_builtin_stxncpy_chk,\n+\tgimple_fold_builtin_snprintf_chk, gimple_fold_builtin_snprintf,\n+\tgimple_fold_builtin_sprintf): Adjust to compute maxval\n+\tthemselves.\n+\n 2014-08-27  Yvan Roux  <yvan.roux@linaro.org>\n \n \tPR other/62248"}, {"sha": "1a2ed6d895812f0ad4d68bf7cfd014bc950c1bd3", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 107, "deletions": 204, "changes": 311, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dcb7fae249bd3b867d91dd85c2e66fd51eb2b45e/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dcb7fae249bd3b867d91dd85c2e66fd51eb2b45e/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=dcb7fae249bd3b867d91dd85c2e66fd51eb2b45e", "patch": "@@ -1285,7 +1285,7 @@ gimple_fold_builtin_memset (gimple_stmt_iterator *gsi, tree c, tree len)\n    length and 2 for maximum value ARG can have.  */\n \n static bool\n-get_maxval_strlen (tree arg, tree *length, bitmap visited, int type)\n+get_maxval_strlen (tree arg, tree *length, bitmap *visited, int type)\n {\n   tree var, val;\n   gimple def_stmt;\n@@ -1342,7 +1342,9 @@ get_maxval_strlen (tree arg, tree *length, bitmap visited, int type)\n     return false;\n \n   /* If we were already here, break the infinite cycle.  */\n-  if (!bitmap_set_bit (visited, SSA_NAME_VERSION (arg)))\n+  if (!*visited)\n+    *visited = BITMAP_ALLOC (NULL);\n+  if (!bitmap_set_bit (*visited, SSA_NAME_VERSION (arg)))\n     return true;\n \n   var = arg;\n@@ -1399,15 +1401,29 @@ get_maxval_strlen (tree arg, tree *length, bitmap visited, int type)\n     }\n }\n \n+tree\n+get_maxval_strlen (tree arg, int type)\n+{\n+  bitmap visited = NULL;\n+  tree len = NULL_TREE;\n+  if (!get_maxval_strlen (arg, &len, &visited, type))\n+    len = NULL_TREE;\n+  if (visited)\n+    BITMAP_FREE (visited);\n+\n+  return len;\n+}\n+\n \n /* Fold function call to builtin strcpy with arguments DEST and SRC.\n    If LEN is not NULL, it represents the length of the string to be\n    copied.  Return NULL_TREE if no simplification can be made.  */\n \n static bool\n gimple_fold_builtin_strcpy (gimple_stmt_iterator *gsi,\n-\t\t\t    location_t loc, tree dest, tree src, tree len)\n+\t\t\t    tree dest, tree src)\n {\n+  location_t loc = gimple_location (gsi_stmt (*gsi));\n   tree fn;\n \n   /* If SRC and DEST are the same (and not volatile), return DEST.  */\n@@ -1424,12 +1440,9 @@ gimple_fold_builtin_strcpy (gimple_stmt_iterator *gsi,\n   if (!fn)\n     return false;\n \n+  tree len = get_maxval_strlen (src, 1);\n   if (!len)\n-    {\n-      len = c_strlen (src, 1);\n-      if (! len || TREE_SIDE_EFFECTS (len))\n-\treturn NULL_TREE;\n-    }\n+    return false;\n \n   len = fold_convert_loc (loc, size_type_node, len);\n   len = size_binop_loc (loc, PLUS_EXPR, len, build_int_cst (size_type_node, 1));\n@@ -1445,9 +1458,10 @@ gimple_fold_builtin_strcpy (gimple_stmt_iterator *gsi,\n    Return NULL_TREE if no simplification can be made.  */\n \n static bool\n-gimple_fold_builtin_strncpy (gimple_stmt_iterator *gsi, location_t loc,\n-\t\t\t     tree dest, tree src, tree len, tree slen)\n+gimple_fold_builtin_strncpy (gimple_stmt_iterator *gsi,\n+\t\t\t     tree dest, tree src, tree len)\n {\n+  location_t loc = gimple_location (gsi_stmt (*gsi));\n   tree fn;\n \n   /* If the LEN parameter is zero, return DEST.  */\n@@ -1459,14 +1473,12 @@ gimple_fold_builtin_strncpy (gimple_stmt_iterator *gsi, location_t loc,\n \n   /* We can't compare slen with len as constants below if len is not a\n      constant.  */\n-  if (len == 0 || TREE_CODE (len) != INTEGER_CST)\n+  if (TREE_CODE (len) != INTEGER_CST)\n     return false;\n \n-  if (!slen)\n-    slen = c_strlen (src, 1);\n-\n   /* Now, we must be passed a constant src ptr parameter.  */\n-  if (slen == 0 || TREE_CODE (slen) != INTEGER_CST)\n+  tree slen = get_maxval_strlen (src, 1);\n+  if (!slen || TREE_CODE (slen) != INTEGER_CST)\n     return false;\n \n   slen = size_binop_loc (loc, PLUS_EXPR, slen, ssize_int (1));\n@@ -1509,11 +1521,10 @@ gimple_fold_builtin_strncpy (gimple_stmt_iterator *gsi, location_t loc,\n    form of the builtin function call.  */\n \n static bool\n-gimple_fold_builtin_strcat (gimple_stmt_iterator *gsi,\n-\t\t\t    location_t loc ATTRIBUTE_UNUSED, tree dst, tree src,\n-\t\t\t    tree len)\n+gimple_fold_builtin_strcat (gimple_stmt_iterator *gsi, tree dst, tree src)\n {\n   gimple stmt = gsi_stmt (*gsi);\n+  location_t loc = gimple_location (stmt);\n \n   const char *p = c_getstr (src);\n \n@@ -1537,9 +1548,8 @@ gimple_fold_builtin_strcat (gimple_stmt_iterator *gsi,\n \n   /* If the length of the source string isn't computable don't\n      split strcat into strlen and memcpy.  */\n+  tree len = get_maxval_strlen (src, 0);\n   if (! len)\n-    len = c_strlen (src, 1);\n-  if (! len || TREE_SIDE_EFFECTS (len))\n     return false;\n \n   /* Create strlen (dst).  */\n@@ -1631,10 +1641,11 @@ gimple_fold_builtin_strcat_chk (gimple_stmt_iterator *gsi)\n \n static bool\n gimple_fold_builtin_fputs (gimple_stmt_iterator *gsi,\n-\t\t\t   location_t loc ATTRIBUTE_UNUSED,\n \t\t\t   tree arg0, tree arg1,\n-\t\t\t   bool ignore, bool unlocked, tree len)\n+\t\t\t   bool unlocked)\n {\n+  gimple stmt = gsi_stmt (*gsi);\n+\n   /* If we're using an unlocked function, assume the other unlocked\n      functions exist explicitly.  */\n   tree const fn_fputc = (unlocked\n@@ -1645,14 +1656,12 @@ gimple_fold_builtin_fputs (gimple_stmt_iterator *gsi,\n \t\t\t  : builtin_decl_implicit (BUILT_IN_FWRITE));\n \n   /* If the return value is used, don't do the transformation.  */\n-  if (!ignore)\n+  if (gimple_call_lhs (stmt))\n     return false;\n \n-  if (! len)\n-    len = c_strlen (arg0, 0);\n-\n   /* Get the length of the string passed to fputs.  If the length\n      can't be determined, punt.  */\n+  tree len = get_maxval_strlen (arg0, 0);\n   if (!len\n       || TREE_CODE (len) != INTEGER_CST)\n     return false;\n@@ -1708,11 +1717,12 @@ gimple_fold_builtin_fputs (gimple_stmt_iterator *gsi,\n \n static bool\n gimple_fold_builtin_memory_chk (gimple_stmt_iterator *gsi,\n-\t\t\t\tlocation_t loc,\n \t\t\t\ttree dest, tree src, tree len, tree size,\n-\t\t\t\ttree maxlen, bool ignore,\n \t\t\t\tenum built_in_function fcode)\n {\n+  gimple stmt = gsi_stmt (*gsi);\n+  location_t loc = gimple_location (stmt);\n+  bool ignore = gimple_call_lhs (stmt) == NULL_TREE;\n   tree fn;\n \n   /* If SRC and DEST are the same (and not volatile), return DEST\n@@ -1738,6 +1748,7 @@ gimple_fold_builtin_memory_chk (gimple_stmt_iterator *gsi,\n   if (! tree_fits_uhwi_p (size))\n     return false;\n \n+  tree maxlen = get_maxval_strlen (len, 2);\n   if (! integer_all_onesp (size))\n     {\n       if (! tree_fits_uhwi_p (len))\n@@ -1806,11 +1817,13 @@ gimple_fold_builtin_memory_chk (gimple_stmt_iterator *gsi,\n \n static bool\n gimple_fold_builtin_stxcpy_chk (gimple_stmt_iterator *gsi,\n-\t\t\t\tlocation_t loc, tree dest,\n+\t\t\t\ttree dest,\n \t\t\t\ttree src, tree size,\n-\t\t\t\ttree maxlen, bool ignore,\n \t\t\t\tenum built_in_function fcode)\n {\n+  gimple stmt = gsi_stmt (*gsi);\n+  location_t loc = gimple_location (stmt);\n+  bool ignore = gimple_call_lhs (stmt) == NULL_TREE;\n   tree len, fn;\n \n   /* If SRC and DEST are the same (and not volatile), return DEST.  */\n@@ -1823,6 +1836,7 @@ gimple_fold_builtin_stxcpy_chk (gimple_stmt_iterator *gsi,\n   if (! tree_fits_uhwi_p (size))\n     return false;\n \n+  tree maxlen = get_maxval_strlen (src, 1);\n   if (! integer_all_onesp (size))\n     {\n       len = c_strlen (src, 1);\n@@ -1894,9 +1908,11 @@ gimple_fold_builtin_stxcpy_chk (gimple_stmt_iterator *gsi,\n static bool\n gimple_fold_builtin_stxncpy_chk (gimple_stmt_iterator *gsi,\n \t\t\t\t tree dest, tree src,\n-\t\t\t\t tree len, tree size, tree maxlen, bool ignore,\n+\t\t\t\t tree len, tree size,\n \t\t\t\t enum built_in_function fcode)\n {\n+  gimple stmt = gsi_stmt (*gsi);\n+  bool ignore = gimple_call_lhs (stmt) == NULL_TREE;\n   tree fn;\n \n   if (fcode == BUILT_IN_STPNCPY_CHK && ignore)\n@@ -1915,6 +1931,7 @@ gimple_fold_builtin_stxncpy_chk (gimple_stmt_iterator *gsi,\n   if (! tree_fits_uhwi_p (size))\n     return false;\n \n+  tree maxlen = get_maxval_strlen (len, 2);\n   if (! integer_all_onesp (size))\n     {\n       if (! tree_fits_uhwi_p (len))\n@@ -1951,7 +1968,7 @@ gimple_fold_builtin_stxncpy_chk (gimple_stmt_iterator *gsi,\n \n static bool\n gimple_fold_builtin_snprintf_chk (gimple_stmt_iterator *gsi,\n-\t\t\t\t  tree maxlen, enum built_in_function fcode)\n+\t\t\t\t  enum built_in_function fcode)\n {\n   gimple stmt = gsi_stmt (*gsi);\n   tree dest, size, len, fn, fmt, flag;\n@@ -1972,6 +1989,7 @@ gimple_fold_builtin_snprintf_chk (gimple_stmt_iterator *gsi,\n \n   if (! integer_all_onesp (size))\n     {\n+      tree maxlen = get_maxval_strlen (len, 2);\n       if (! tree_fits_uhwi_p (len))\n \t{\n \t  /* If LEN is not constant, try MAXLEN too.\n@@ -2128,7 +2146,7 @@ gimple_fold_builtin_sprintf_chk (gimple_stmt_iterator *gsi,\n    the caller does not use the returned value of the function.  */\n \n static bool\n-gimple_fold_builtin_sprintf (gimple_stmt_iterator *gsi, tree orig_len)\n+gimple_fold_builtin_sprintf (gimple_stmt_iterator *gsi)\n {\n   gimple stmt = gsi_stmt (*gsi);\n   tree dest = gimple_call_arg (stmt, 0);\n@@ -2206,10 +2224,10 @@ gimple_fold_builtin_sprintf (gimple_stmt_iterator *gsi, tree orig_len)\n       if (!orig)\n \treturn false;\n \n-      if (gimple_call_lhs (stmt)\n-\t  && !orig_len)\n+      tree orig_len = NULL_TREE;\n+      if (gimple_call_lhs (stmt))\n \t{\n-\t  orig_len = c_strlen (orig, 1);\n+\t  orig_len = get_maxval_strlen (orig, 0);\n \t  if (!orig_len)\n \t    return false;\n \t}\n@@ -2253,7 +2271,7 @@ gimple_fold_builtin_sprintf (gimple_stmt_iterator *gsi, tree orig_len)\n    the caller does not use the returned value of the function.  */\n \n static bool\n-gimple_fold_builtin_snprintf (gimple_stmt_iterator *gsi, tree orig_len)\n+gimple_fold_builtin_snprintf (gimple_stmt_iterator *gsi)\n {\n   gimple stmt = gsi_stmt (*gsi);\n   tree dest = gimple_call_arg (stmt, 0);\n@@ -2338,12 +2356,9 @@ gimple_fold_builtin_snprintf (gimple_stmt_iterator *gsi, tree orig_len)\n       if (!orig)\n \treturn false;\n \n+      tree orig_len = get_maxval_strlen (orig, 0);\n       if (!orig_len)\n-\t{\n-\t  orig_len = c_strlen (orig, 1);\n-\t  if (!orig_len)\n-\t    return false;\n-\t}\n+\treturn false;\n \n       /* We could expand this as\n \t memcpy (str1, str2, cst - 1); str1[cst - 1] = '\\0';\n@@ -2390,222 +2405,110 @@ gimple_fold_builtin_snprintf (gimple_stmt_iterator *gsi, tree orig_len)\n /* Fold a call to __builtin_strlen with known length LEN.  */\n \n static bool\n-gimple_fold_builtin_strlen (gimple_stmt_iterator *gsi, tree len)\n+gimple_fold_builtin_strlen (gimple_stmt_iterator *gsi)\n {\n-  if (!len)\n-    {\n-      gimple stmt = gsi_stmt (*gsi);\n-      len = c_strlen (gimple_call_arg (stmt, 0), 0);\n-    }\n+  gimple stmt = gsi_stmt (*gsi);\n+  tree len = get_maxval_strlen (gimple_call_arg (stmt, 0), 0);\n   if (!len)\n     return false;\n   replace_call_with_value (gsi, len);\n   return true;\n }\n \n \n-/* Fold builtins at *GSI with knowledge about a length argument.  */\n+/* Fold the non-target builtin at *GSI and return whether any simplification\n+   was made.  */\n \n static bool\n-gimple_fold_builtin_with_strlen (gimple_stmt_iterator *gsi)\n+gimple_fold_builtin (gimple_stmt_iterator *gsi)\n {\n   gimple stmt = gsi_stmt (*gsi);\n-  tree val[4];\n-  tree a;\n-  int arg_idx, type;\n-  bitmap visited;\n-  bool ignore;\n-  location_t loc = gimple_location (stmt);\n-\n-  ignore = (gimple_call_lhs (stmt) == NULL);\n-\n-  /* Limit the work only for builtins we know how to simplify.  */\n   tree callee = gimple_call_fndecl (stmt);\n-  switch (DECL_FUNCTION_CODE (callee))\n-    {\n-    case BUILT_IN_STRLEN:\n-    case BUILT_IN_FPUTS:\n-    case BUILT_IN_FPUTS_UNLOCKED:\n-      arg_idx = 0;\n-      type = 0;\n-      break;\n-    case BUILT_IN_STRCPY:\n-    case BUILT_IN_STRNCPY:\n-    case BUILT_IN_STRCAT:\n-      arg_idx = 1;\n-      type = 0;\n-      break;\n-    case BUILT_IN_MEMCPY_CHK:\n-    case BUILT_IN_MEMPCPY_CHK:\n-    case BUILT_IN_MEMMOVE_CHK:\n-    case BUILT_IN_MEMSET_CHK:\n-    case BUILT_IN_STRNCPY_CHK:\n-    case BUILT_IN_STPNCPY_CHK:\n-      arg_idx = 2;\n-      type = 2;\n-      break;\n-    case BUILT_IN_STRCPY_CHK:\n-    case BUILT_IN_STPCPY_CHK:\n-      arg_idx = 1;\n-      type = 1;\n-      break;\n-    case BUILT_IN_SNPRINTF_CHK:\n-    case BUILT_IN_VSNPRINTF_CHK:\n-      arg_idx = 1;\n-      type = 2;\n-      break;\n-    case BUILT_IN_SPRINTF:\n-      arg_idx = 2;\n-      type = 0;\n-      break;\n-    case BUILT_IN_SNPRINTF:\n-      arg_idx = 3;\n-      type = 0;\n-      break;\n-    default:\n-      return false;\n-    }\n-\n-  int nargs = gimple_call_num_args (stmt);\n-\n-  /* Try to use the dataflow information gathered by the CCP process.  */\n-  visited = BITMAP_ALLOC (NULL);\n-  bitmap_clear (visited);\n-\n-  memset (val, 0, sizeof (val));\n-  if (arg_idx < nargs)\n-    {\n-      a = gimple_call_arg (stmt, arg_idx);\n-      if (!get_maxval_strlen (a, &val[arg_idx], visited, type)\n-\t  || !is_gimple_val (val[arg_idx]))\n-\tval[arg_idx] = NULL_TREE;\n-    }\n \n-  BITMAP_FREE (visited);\n+  /* Give up for always_inline inline builtins until they are\n+     inlined.  */\n+  if (avoid_folding_inline_builtin (callee))\n+    return false;\n \n   switch (DECL_FUNCTION_CODE (callee))\n     {\n+    case BUILT_IN_BZERO:\n+      return gimple_fold_builtin_memset (gsi, integer_zero_node,\n+\t\t\t\t\t gimple_call_arg (stmt, 1));\n+    case BUILT_IN_MEMSET:\n+      return gimple_fold_builtin_memset (gsi,\n+\t\t\t\t\t gimple_call_arg (stmt, 1),\n+\t\t\t\t\t gimple_call_arg (stmt, 2));\n+    case BUILT_IN_BCOPY:\n+      return gimple_fold_builtin_memory_op (gsi, gimple_call_arg (stmt, 1),\n+\t\t\t\t\t    gimple_call_arg (stmt, 0), 3);\n+    case BUILT_IN_MEMCPY:\n+      return gimple_fold_builtin_memory_op (gsi, gimple_call_arg (stmt, 0),\n+\t\t\t\t\t    gimple_call_arg (stmt, 1), 0);\n+    case BUILT_IN_MEMPCPY:\n+      return gimple_fold_builtin_memory_op (gsi, gimple_call_arg (stmt, 0),\n+\t\t\t\t\t    gimple_call_arg (stmt, 1), 1);\n+    case BUILT_IN_MEMMOVE:\n+      return gimple_fold_builtin_memory_op (gsi, gimple_call_arg (stmt, 0),\n+\t\t\t\t\t    gimple_call_arg (stmt, 1), 3);\n+    case BUILT_IN_SPRINTF_CHK:\n+    case BUILT_IN_VSPRINTF_CHK:\n+      return gimple_fold_builtin_sprintf_chk (gsi, DECL_FUNCTION_CODE (callee));\n+    case BUILT_IN_STRCAT_CHK:\n+      return gimple_fold_builtin_strcat_chk (gsi);\n     case BUILT_IN_STRLEN:\n-      return gimple_fold_builtin_strlen (gsi, val[0]);\n-\n+      return gimple_fold_builtin_strlen (gsi);\n     case BUILT_IN_STRCPY:\n-      return gimple_fold_builtin_strcpy (gsi, loc,\n+      return gimple_fold_builtin_strcpy (gsi,\n \t\t\t\t\t gimple_call_arg (stmt, 0),\n-\t\t\t\t\t gimple_call_arg (stmt, 1),\n-\t\t\t\t\t val[1]);\n-\n+\t\t\t\t\t gimple_call_arg (stmt, 1));\n     case BUILT_IN_STRNCPY:\n-      return gimple_fold_builtin_strncpy (gsi, loc,\n+      return gimple_fold_builtin_strncpy (gsi,\n \t\t\t\t\t  gimple_call_arg (stmt, 0),\n \t\t\t\t\t  gimple_call_arg (stmt, 1),\n-\t\t\t\t\t  gimple_call_arg (stmt, 2),\n-\t\t\t\t\t  val[1]);\n-\n+\t\t\t\t\t  gimple_call_arg (stmt, 2));\n     case BUILT_IN_STRCAT:\n-      return gimple_fold_builtin_strcat (gsi, loc, gimple_call_arg (stmt, 0),\n-\t\t\t\t\t gimple_call_arg (stmt, 1),\n-\t\t\t\t\t val[1]);\n-\n+      return gimple_fold_builtin_strcat (gsi, gimple_call_arg (stmt, 0),\n+\t\t\t\t\t gimple_call_arg (stmt, 1));\n     case BUILT_IN_FPUTS:\n-      return gimple_fold_builtin_fputs (gsi, loc, gimple_call_arg (stmt, 0),\n-\t\t\t\t\tgimple_call_arg (stmt, 1),\n-\t\t\t\t\tignore, false, val[0]);\n-\n+      return gimple_fold_builtin_fputs (gsi, gimple_call_arg (stmt, 0),\n+\t\t\t\t\tgimple_call_arg (stmt, 1), false);\n     case BUILT_IN_FPUTS_UNLOCKED:\n-      return gimple_fold_builtin_fputs (gsi, loc, gimple_call_arg (stmt, 0),\n-\t\t\t\t\tgimple_call_arg (stmt, 1),\n-\t\t\t\t\tignore, true, val[0]);\n-\n+      return gimple_fold_builtin_fputs (gsi, gimple_call_arg (stmt, 0),\n+\t\t\t\t\tgimple_call_arg (stmt, 1), true);\n     case BUILT_IN_MEMCPY_CHK:\n     case BUILT_IN_MEMPCPY_CHK:\n     case BUILT_IN_MEMMOVE_CHK:\n     case BUILT_IN_MEMSET_CHK:\n-      return gimple_fold_builtin_memory_chk (gsi, loc,\n+      return gimple_fold_builtin_memory_chk (gsi,\n \t\t\t\t\t     gimple_call_arg (stmt, 0),\n \t\t\t\t\t     gimple_call_arg (stmt, 1),\n \t\t\t\t\t     gimple_call_arg (stmt, 2),\n \t\t\t\t\t     gimple_call_arg (stmt, 3),\n-\t\t\t\t\t     val[2], ignore,\n \t\t\t\t\t     DECL_FUNCTION_CODE (callee));\n-\n     case BUILT_IN_STRCPY_CHK:\n     case BUILT_IN_STPCPY_CHK:\n-      return gimple_fold_builtin_stxcpy_chk (gsi, loc,\n+      return gimple_fold_builtin_stxcpy_chk (gsi,\n \t\t\t\t\t     gimple_call_arg (stmt, 0),\n \t\t\t\t\t     gimple_call_arg (stmt, 1),\n \t\t\t\t\t     gimple_call_arg (stmt, 2),\n-\t\t\t\t\t     val[1], ignore,\n \t\t\t\t\t     DECL_FUNCTION_CODE (callee));\n-\n     case BUILT_IN_STRNCPY_CHK:\n     case BUILT_IN_STPNCPY_CHK:\n       return gimple_fold_builtin_stxncpy_chk (gsi,\n \t\t\t\t\t      gimple_call_arg (stmt, 0),\n \t\t\t\t\t      gimple_call_arg (stmt, 1),\n \t\t\t\t\t      gimple_call_arg (stmt, 2),\n \t\t\t\t\t      gimple_call_arg (stmt, 3),\n-\t\t\t\t\t      val[2], ignore,\n \t\t\t\t\t      DECL_FUNCTION_CODE (callee));\n-\n     case BUILT_IN_SNPRINTF_CHK:\n     case BUILT_IN_VSNPRINTF_CHK:\n-      return gimple_fold_builtin_snprintf_chk (gsi, val[1],\n+      return gimple_fold_builtin_snprintf_chk (gsi,\n \t\t\t\t\t       DECL_FUNCTION_CODE (callee));\n     case BUILT_IN_SNPRINTF:\n-      return gimple_fold_builtin_snprintf (gsi, val[3]);\n+      return gimple_fold_builtin_snprintf (gsi);\n     case BUILT_IN_SPRINTF:\n-      return gimple_fold_builtin_sprintf (gsi, val[2]);\n-    default:\n-      gcc_unreachable ();\n-    }\n-\n-  return false;\n-}\n-\n-\n-/* Fold the non-target builtin at *GSI and return whether any simplification\n-   was made.  */\n-\n-static bool\n-gimple_fold_builtin (gimple_stmt_iterator *gsi)\n-{\n-  gimple stmt = gsi_stmt (*gsi);\n-  tree callee = gimple_call_fndecl (stmt);\n-\n-  /* Give up for always_inline inline builtins until they are\n-     inlined.  */\n-  if (avoid_folding_inline_builtin (callee))\n-    return false;\n-\n-  if (gimple_fold_builtin_with_strlen (gsi))\n-    return true;\n-\n-  switch (DECL_FUNCTION_CODE (callee))\n-    {\n-    case BUILT_IN_BZERO:\n-      return gimple_fold_builtin_memset (gsi, integer_zero_node,\n-\t\t\t\t\t gimple_call_arg (stmt, 1));\n-    case BUILT_IN_MEMSET:\n-      return gimple_fold_builtin_memset (gsi,\n-\t\t\t\t\t gimple_call_arg (stmt, 1),\n-\t\t\t\t\t gimple_call_arg (stmt, 2));\n-    case BUILT_IN_BCOPY:\n-      return gimple_fold_builtin_memory_op (gsi, gimple_call_arg (stmt, 1),\n-\t\t\t\t\t    gimple_call_arg (stmt, 0), 3);\n-    case BUILT_IN_MEMCPY:\n-      return gimple_fold_builtin_memory_op (gsi, gimple_call_arg (stmt, 0),\n-\t\t\t\t\t    gimple_call_arg (stmt, 1), 0);\n-    case BUILT_IN_MEMPCPY:\n-      return gimple_fold_builtin_memory_op (gsi, gimple_call_arg (stmt, 0),\n-\t\t\t\t\t    gimple_call_arg (stmt, 1), 1);\n-    case BUILT_IN_MEMMOVE:\n-      return gimple_fold_builtin_memory_op (gsi, gimple_call_arg (stmt, 0),\n-\t\t\t\t\t    gimple_call_arg (stmt, 1), 3);\n-    case BUILT_IN_SPRINTF_CHK:\n-    case BUILT_IN_VSPRINTF_CHK:\n-      return gimple_fold_builtin_sprintf_chk (gsi, DECL_FUNCTION_CODE (callee));\n-    case BUILT_IN_STRCAT_CHK:\n-      return gimple_fold_builtin_strcat_chk (gsi);\n+      return gimple_fold_builtin_sprintf (gsi);\n     default:;\n     }\n "}]}