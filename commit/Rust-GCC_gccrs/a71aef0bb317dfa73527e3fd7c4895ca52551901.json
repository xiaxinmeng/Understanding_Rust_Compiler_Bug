{"sha": "a71aef0bb317dfa73527e3fd7c4895ca52551901", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTcxYWVmMGJiMzE3ZGZhNzM1MjdlM2ZkN2M0ODk1Y2E1MjU1MTkwMQ==", "commit": {"author": {"name": "Jan Beulich", "email": "jbeulich@novell.com", "date": "2005-07-28T06:58:58Z"}, "committer": {"name": "Jan Beulich", "email": "jbeulich@gcc.gnu.org", "date": "2005-07-28T06:58:58Z"}, "message": "ia64.c (ia64_load_pair_ok): New.\n\ngcc/\n2005-07-28 Jan Beulich <jbeulich@novell.com>\n\n\t* config/ia64/ia64.c (ia64_load_pair_ok): New.\n\t(ia64_print_operand): Describe and handle 'X'.\n\t(ia64_register_move_cost): Also handle FP_REGS.\n\t(ia64_preferred_reload_class): Likewise.\n\t(ia64_secondary_reload_class): Likewise.\n\t(ia64_dependencies_evaluation_hook): New local variable c. Initialize\n\tit. Also check for ITANIUM_CLASS_FLDP.\n\t* config/ia64/ia64.h (FP_REGNO_P): New.\n\t(HARD_REGNO_MODE_OK): Remove explusion of TImode.\n\t(reg_class): Add FP_REGS.\n\t(REG_CLASS_NAMES): Adjust for it.\n\t(REG_CLASS_CONTENTS): Likewise.\n\t(REGNO_REG_CLASS): Use FP_REGS where appropriate.\n\t(REG_CLASS_FROM_LETTER): Handle 'x'.\n\t(CLASS_MAX_NREGS): Handle FP_REGS.\n\t(MEMORY_MOVE_COST): Likewise.\n\t* config/ia64/ia64.md (itanium_class): Add fldp.\n\t(type): Handle fldp.\n\t(movti_internal): More allowable operand combinations. Use ldfp8 when\n\tsplitting unnecessary. Remove predicable attribute. Adjust\n\titanium_class attribute.\n\t(smuldi3_highpart): Remove outdated comment.\n\t(mulditi3, umulditi3, rotlti3): New expanders.\n\t(addti3, subti3, mulditi3_internal, umulditi3_internal, negti2, rotlti3_internal): New insns.\n\t(absti2): Disabled new insn for future reference.\n\tRespective new splitters.\n\t* config/ia64/itanium1.md (1_fldp, 1b_fldp): New insn reservations.\n\t* config/ia64/itanium2.md (2_fldp, 2b_fldp): Likewise.\n\t* config/ia64/ia64-protos.h (ia64_load_pair_ok): New.\n\nFrom-SVN: r102463", "tree": {"sha": "838ce6bab9b932926e15434849dd188a4a00c659", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/838ce6bab9b932926e15434849dd188a4a00c659"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a71aef0bb317dfa73527e3fd7c4895ca52551901", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a71aef0bb317dfa73527e3fd7c4895ca52551901", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a71aef0bb317dfa73527e3fd7c4895ca52551901", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a71aef0bb317dfa73527e3fd7c4895ca52551901/comments", "author": null, "committer": null, "parents": [{"sha": "9e7705cbd19b0fc8e5b3589e2a2c2a36eeb954c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e7705cbd19b0fc8e5b3589e2a2c2a36eeb954c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e7705cbd19b0fc8e5b3589e2a2c2a36eeb954c5"}], "stats": {"total": 392, "additions": 369, "deletions": 23}, "files": [{"sha": "264b07212c21f7466579fa5bb8c64fcc0b9a093b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a71aef0bb317dfa73527e3fd7c4895ca52551901/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a71aef0bb317dfa73527e3fd7c4895ca52551901/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a71aef0bb317dfa73527e3fd7c4895ca52551901", "patch": "@@ -1,3 +1,35 @@\n+2005-07-28 Jan Beulich <jbeulich@novell.com>\n+\n+\t* config/ia64/ia64.c (ia64_load_pair_ok): New.\n+\t(ia64_print_operand): Describe and handle 'X'.\n+\t(ia64_register_move_cost): Also handle FP_REGS.\n+\t(ia64_preferred_reload_class): Likewise.\n+\t(ia64_secondary_reload_class): Likewise.\n+\t(ia64_dependencies_evaluation_hook): New local variable c. Initialize\n+\tit. Also check for ITANIUM_CLASS_FLDP.\n+\t* config/ia64/ia64.h (FP_REGNO_P): New.\n+\t(HARD_REGNO_MODE_OK): Remove explusion of TImode.\n+\t(reg_class): Add FP_REGS.\n+\t(REG_CLASS_NAMES): Adjust for it.\n+\t(REG_CLASS_CONTENTS): Likewise.\n+\t(REGNO_REG_CLASS): Use FP_REGS where appropriate.\n+\t(REG_CLASS_FROM_LETTER): Handle 'x'.\n+\t(CLASS_MAX_NREGS): Handle FP_REGS.\n+\t(MEMORY_MOVE_COST): Likewise.\n+\t* config/ia64/ia64.md (itanium_class): Add fldp.\n+\t(type): Handle fldp.\n+\t(movti_internal): More allowable operand combinations. Use ldfp8 when\n+\tsplitting unnecessary. Remove predicable attribute. Adjust\n+\titanium_class attribute.\n+\t(smuldi3_highpart): Remove outdated comment.\n+\t(mulditi3, umulditi3, rotlti3): New expanders.\n+\t(addti3, subti3, mulditi3_internal, umulditi3_internal, negti2, rotlti3_internal): New insns.\n+\t(absti2): Disabled new insn for future reference.\n+\tRespective new splitters.\n+\t* config/ia64/itanium1.md (1_fldp, 1b_fldp): New insn reservations.\n+\t* config/ia64/itanium2.md (2_fldp, 2b_fldp): Likewise.\n+\t* config/ia64/ia64-protos.h (ia64_load_pair_ok): New.\n+\n 2005-07-25  James A. Morrison  <phython@gcc.gnu.org>\n \n \tPR rtl-optimization/23047"}, {"sha": "0c6355ade2b3382ee36228deb8cb2798dd7475f5", "filename": "gcc/config/ia64/ia64-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a71aef0bb317dfa73527e3fd7c4895ca52551901/gcc%2Fconfig%2Fia64%2Fia64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a71aef0bb317dfa73527e3fd7c4895ca52551901/gcc%2Fconfig%2Fia64%2Fia64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64-protos.h?ref=a71aef0bb317dfa73527e3fd7c4895ca52551901", "patch": "@@ -41,6 +41,7 @@ extern bool ia64_legitimate_constant_p (rtx);\n \n extern rtx ia64_expand_move (rtx, rtx);\n extern int ia64_move_ok (rtx, rtx);\n+extern int ia64_load_pair_ok (rtx, rtx);\n extern int addp4_optimize_ok (rtx, rtx);\n extern void ia64_emit_cond_move (rtx, rtx, rtx);\n extern int ia64_depz_field_mask (rtx, rtx);"}, {"sha": "1873f898142643b20b1461b79f9eee3ddae11085", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 50, "deletions": 5, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a71aef0bb317dfa73527e3fd7c4895ca52551901/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a71aef0bb317dfa73527e3fd7c4895ca52551901/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=a71aef0bb317dfa73527e3fd7c4895ca52551901", "patch": "@@ -690,6 +690,37 @@ ia64_move_ok (rtx dst, rtx src)\n     return GET_CODE (src) == CONST_DOUBLE && CONST_DOUBLE_OK_FOR_G (src);\n }\n \n+/* Return 1 if the operands are ok for a floating point load pair.  */\n+\n+int\n+ia64_load_pair_ok (rtx dst, rtx src)\n+{\n+  if (GET_CODE (dst) != REG || !FP_REGNO_P (REGNO (dst)))\n+    return 0;\n+  if (GET_CODE (src) != MEM || MEM_VOLATILE_P (src))\n+    return 0;\n+  switch (GET_CODE (XEXP (src, 0)))\n+    {\n+    case REG:\n+    case POST_INC:\n+      break;\n+    case POST_DEC:\n+      return 0;\n+    case POST_MODIFY:\n+      {\n+\trtx adjust = XEXP (XEXP (XEXP (src, 0), 1), 1);\n+\n+\tif (GET_CODE (adjust) != CONST_INT\n+\t    || INTVAL (adjust) != GET_MODE_SIZE (GET_MODE (src)))\n+\t  return 0;\n+      }\n+      break;\n+    default:\n+      abort ();\n+    }\n+  return 1;\n+}\n+\n int\n addp4_optimize_ok (rtx op1, rtx op2)\n {\n@@ -4305,6 +4336,7 @@ ia64_print_operand_address (FILE * stream ATTRIBUTE_UNUSED,\n \tfor Intel assembler.\n    U\tPrint an 8-bit sign extended number (K) as a 64-bit unsigned number\n \tfor Intel assembler.\n+   X\tA pair of floating point registers.\n    r\tPrint register name, or constant 0 as r0.  HP compatibility for\n \tLinux kernel.\n    v    Print vector constant value as an 8-byte integer value.  */\n@@ -4453,6 +4485,13 @@ ia64_print_operand (FILE * file, rtx x, int code)\n \t}\n       break;\n \n+    case 'X':\n+      {\n+\tunsigned int regno = REGNO (x);\n+\tfprintf (file, \"%s, %s\", reg_names [regno], reg_names [regno + 1]);\n+      }\n+      return;\n+\n     case 'r':\n       /* If this operand is the constant zero, write it as register zero.\n \t Any register, zero, or CONST_INT value is OK here.  */\n@@ -4682,6 +4721,7 @@ ia64_register_move_cost (enum machine_mode mode, enum reg_class from,\n \n     case GR_REGS:\n     case FR_REGS:\n+    case FP_REGS:\n     case GR_AND_FR_REGS:\n     case GR_AND_BR_REGS:\n     case ALL_REGS:\n@@ -4703,6 +4743,7 @@ ia64_preferred_reload_class (rtx x, enum reg_class class)\n   switch (class)\n     {\n     case FR_REGS:\n+    case FP_REGS:\n       /* Don't allow volatile mem reloads into floating point registers.\n \t This is defined to force reload to choose the r/m case instead\n \t of the f/f case when reloading (set (reg fX) (mem/v)).  */\n@@ -4768,6 +4809,7 @@ ia64_secondary_reload_class (enum reg_class class,\n       break;\n \n     case FR_REGS:\n+    case FP_REGS:\n       /* Need to go through general registers to get to other class regs.  */\n       if (regno >= 0 && ! (FR_REGNO_P (regno) || GENERAL_REGNO_P (regno)))\n \treturn GR_REGS;\n@@ -6113,16 +6155,19 @@ ia64_dependencies_evaluation_hook (rtx head, rtx tail)\n       {\n \tfor (link = INSN_DEPEND (insn); link != 0; link = XEXP (link, 1))\n \t  {\n+\t    enum attr_itanium_class c;\n+\n \t    if (REG_NOTE_KIND (link) != REG_DEP_TRUE)\n \t      continue;\n \t    next = XEXP (link, 0);\n-\t    if ((ia64_safe_itanium_class (next) == ITANIUM_CLASS_ST\n-\t\t || ia64_safe_itanium_class (next) == ITANIUM_CLASS_STF)\n+\t    c = ia64_safe_itanium_class (next);\n+\t    if ((c == ITANIUM_CLASS_ST\n+\t\t || c == ITANIUM_CLASS_STF)\n \t\t&& ia64_st_address_bypass_p (insn, next))\n \t      break;\n-\t    else if ((ia64_safe_itanium_class (next) == ITANIUM_CLASS_LD\n-\t\t      || ia64_safe_itanium_class (next)\n-\t\t      == ITANIUM_CLASS_FLD)\n+\t    else if ((c == ITANIUM_CLASS_LD\n+\t\t      || c == ITANIUM_CLASS_FLD\n+\t\t      || c == ITANIUM_CLASS_FLDP)\n \t\t     && ia64_ld_address_bypass_p (insn, next))\n \t      break;\n \t  }"}, {"sha": "8b92cedf511fc035353295c8908ead5d22534823", "filename": "gcc/config/ia64/ia64.h", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a71aef0bb317dfa73527e3fd7c4895ca52551901/gcc%2Fconfig%2Fia64%2Fia64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a71aef0bb317dfa73527e3fd7c4895ca52551901/gcc%2Fconfig%2Fia64%2Fia64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.h?ref=a71aef0bb317dfa73527e3fd7c4895ca52551901", "patch": "@@ -324,6 +324,7 @@ while (0)\n #define ADDL_REGNO_P(REGNO) ((unsigned HOST_WIDE_INT) (REGNO) <= 3)\n #define GR_REGNO_P(REGNO) ((unsigned HOST_WIDE_INT) (REGNO) <= 127)\n #define FR_REGNO_P(REGNO) ((REGNO) >= 128 && (REGNO) <= 255)\n+#define FP_REGNO_P(REGNO) ((REGNO) >= 128 && (REGNO) <= 254 && (REGNO) != 159)\n #define PR_REGNO_P(REGNO) ((REGNO) >= 256 && (REGNO) <= 319)\n #define BR_REGNO_P(REGNO) ((REGNO) >= 320 && (REGNO) <= 327)\n #define GENERAL_REGNO_P(REGNO) \\\n@@ -651,7 +652,6 @@ while (0)\n #define HARD_REGNO_MODE_OK(REGNO, MODE)\t\t\t\t\\\n   (FR_REGNO_P (REGNO) ?\t\t\t\t\t\t\\\n      GET_MODE_CLASS (MODE) != MODE_CC &&\t\t\t\\\n-     (MODE) != TImode &&\t\t\t\t\t\\\n      (MODE) != BImode &&\t\t\t\t\t\\\n      (MODE) != TFmode \t\t\t\t\t\t\\\n    : PR_REGNO_P (REGNO) ?\t\t\t\t\t\\\n@@ -721,6 +721,7 @@ enum reg_class\n   AR_I_REGS,\n   ADDL_REGS,\n   GR_REGS,\n+  FP_REGS,\n   FR_REGS,\n   GR_AND_BR_REGS,\n   GR_AND_FR_REGS,\n@@ -737,7 +738,7 @@ enum reg_class\n    constants.  These names are used in writing some of the debugging dumps.  */\n #define REG_CLASS_NAMES \\\n { \"NO_REGS\", \"PR_REGS\", \"BR_REGS\", \"AR_M_REGS\", \"AR_I_REGS\", \\\n-  \"ADDL_REGS\", \"GR_REGS\", \"FR_REGS\", \\\n+  \"ADDL_REGS\", \"GR_REGS\", \"FP_REGS\", \"FR_REGS\", \\\n   \"GR_AND_BR_REGS\", \"GR_AND_FR_REGS\", \"ALL_REGS\" }\n \n /* An initializer containing the contents of the register classes, as integers\n@@ -774,6 +775,10 @@ enum reg_class\n   { 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,\t\\\n     0x00000000, 0x00000000, 0x00000000, 0x00000000,\t\\\n     0x00000000, 0x00000000, 0x0100 },\t\t\t\\\n+  /* FP_REGS.  */\t\t\t\t\t\\\n+  { 0x00000000, 0x00000000, 0x00000000, 0x00000000,\t\\\n+    0x7FFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x7FFFFFFF,\t\\\n+    0x00000000, 0x00000000, 0x0000 },\t\t\t\\\n   /* FR_REGS.  */\t\t\t\t\t\\\n   { 0x00000000, 0x00000000, 0x00000000, 0x00000000,\t\\\n     0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,\t\\\n@@ -801,7 +806,8 @@ enum reg_class\n #define REGNO_REG_CLASS(REGNO) \\\n (ADDL_REGNO_P (REGNO) ? ADDL_REGS\t\\\n  : GENERAL_REGNO_P (REGNO) ? GR_REGS\t\\\n- : FR_REGNO_P (REGNO) ? FR_REGS\t\t\\\n+ : FR_REGNO_P (REGNO) ? (REGNO) != R_FR (31) \\\n+\t\t\t&& (REGNO) != R_FR(127) ? FP_REGS : FR_REGS \\\n  : PR_REGNO_P (REGNO) ? PR_REGS\t\t\\\n  : BR_REGNO_P (REGNO) ? BR_REGS\t\t\\\n  : AR_M_REGNO_P (REGNO) ? AR_M_REGS\t\\\n@@ -832,6 +838,7 @@ enum reg_class\n  : (CHAR) == 'c' ? PR_REGS\t\t\\\n  : (CHAR) == 'd' ? AR_M_REGS\t\t\\\n  : (CHAR) == 'e' ? AR_I_REGS\t\t\\\n+ : (CHAR) == 'x' ? FP_REGS\t\t\\\n  : NO_REGS)\n \n /* A C expression which is nonzero if register number NUM is suitable for use\n@@ -888,8 +895,8 @@ enum reg_class\n \n #define CLASS_MAX_NREGS(CLASS, MODE) \\\n   ((MODE) == BImode && (CLASS) == PR_REGS ? 2\t\t\t\\\n-   : ((CLASS) == FR_REGS && (MODE) == XFmode) ? 1\t\t\\\n-   : ((CLASS) == FR_REGS && (MODE) == XCmode) ? 2\t\t\\\n+   : (((CLASS) == FR_REGS || (CLASS) == FP_REGS) && (MODE) == XFmode) ? 1 \\\n+   : (((CLASS) == FR_REGS || (CLASS) == FP_REGS) && (MODE) == XCmode) ? 2 \\\n    : (GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n \n /* In FP regs, we can't change FP values to integer values and vice versa,\n@@ -1414,7 +1421,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n /* A C expression for the cost of moving data of mode M between a\n    register and memory.  */\n #define MEMORY_MOVE_COST(MODE,CLASS,IN) \\\n-  ((CLASS) == GENERAL_REGS || (CLASS) == FR_REGS \\\n+  ((CLASS) == GENERAL_REGS || (CLASS) == FR_REGS || (CLASS) == FP_REGS \\\n    || (CLASS) == GR_AND_FR_REGS ? 4 : 10)\n \n /* A C expression for the cost of a branch instruction.  A value of 1 is the"}, {"sha": "3f43e48ea753fcf455ba3eabc970246cba7f2951", "filename": "gcc/config/ia64/ia64.md", "status": "modified", "additions": 255, "deletions": 12, "changes": 267, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a71aef0bb317dfa73527e3fd7c4895ca52551901/gcc%2Fconfig%2Fia64%2Fia64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a71aef0bb317dfa73527e3fd7c4895ca52551901/gcc%2Fconfig%2Fia64%2Fia64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.md?ref=a71aef0bb317dfa73527e3fd7c4895ca52551901", "patch": "@@ -123,15 +123,15 @@\n ;; which emit instruction that can go in any slot (e.g. nop).\n \n (define_attr \"itanium_class\" \"unknown,ignore,stop_bit,br,fcmp,fcvtfx,fld,\n-\tfmac,fmisc,frar_i,frar_m,frbr,frfr,frpr,ialu,icmp,ilog,ishf,ld,\n-\tchk_s,long_i,mmalua,mmmul,mmshf,mmshfi,rse_m,scall,sem,stf,\n+\tfldp,fmac,fmisc,frar_i,frar_m,frbr,frfr,frpr,ialu,icmp,ilog,ishf,\n+\tld,chk_s,long_i,mmalua,mmmul,mmshf,mmshfi,rse_m,scall,sem,stf,\n         st,syst_m0, syst_m,tbit,toar_i,toar_m,tobr,tofr,topr,xmpy,xtd,nop,\n         nop_b,nop_f,nop_i,nop_m,nop_x,lfetch,pre_cycle\"\n   (const_string \"unknown\"))\n \n ;; chk_s has an I and an M form; use type A for convenience.\n (define_attr \"type\" \"unknown,A,I,M,F,B,L,X,S\"\n-  (cond [(eq_attr \"itanium_class\" \"ld,st,fld,stf,sem,nop_m\") (const_string \"M\")\n+  (cond [(eq_attr \"itanium_class\" \"ld,st,fld,fldp,stf,sem,nop_m\") (const_string \"M\")\n \t (eq_attr \"itanium_class\" \"rse_m,syst_m,syst_m0\") (const_string \"M\")\n \t (eq_attr \"itanium_class\" \"frar_m,toar_m,frfr,tofr\") (const_string \"M\")\n \t (eq_attr \"itanium_class\" \"lfetch\") (const_string \"M\")\n@@ -659,18 +659,22 @@\n })\n \n (define_insn_and_split \"*movti_internal\"\n-  [(set (match_operand:TI 0 \"nonimmediate_operand\" \"=r,r,m\")\n-\t(match_operand:TI 1 \"general_operand\"      \"ri,m,r\"))]\n+  [(set (match_operand:TI 0 \"nonimmediate_operand\" \"=r,   *fm,*x,*f,  Q\")\n+\t(match_operand:TI 1 \"general_operand\"      \"r*fim,r,  Q, *fOQ,*f\"))]\n   \"ia64_move_ok (operands[0], operands[1])\"\n-  \"#\"\n-  \"reload_completed\"\n+  \"@\n+   #\n+   #\n+   ldfp8 %X0 = %1%P1\n+   #\n+   #\"\n+  \"reload_completed && !ia64_load_pair_ok(operands[0], operands[1])\"\n   [(const_int 0)]\n {\n   ia64_split_tmode_move (operands);\n   DONE;\n }\n-  [(set_attr \"itanium_class\" \"unknown\")\n-   (set_attr \"predicable\" \"no\")])\n+  [(set_attr \"itanium_class\" \"unknown,unknown,fldp,unknown,unknown\")])\n \n ;; Floating Point Moves\n ;;\n@@ -2140,9 +2144,6 @@\n    (set (match_dup 0) (plus:DI (match_dup 0) (match_dup 4)))]\n   \"\")\n \n-;; ??? There are highpart multiply and add instructions, but we have no way\n-;; to generate them.\n-\n (define_insn \"smuldi3_highpart\"\n   [(set (match_operand:DI 0 \"fr_register_operand\" \"=f\")\n \t(truncate:DI\n@@ -2493,6 +2494,200 @@\n \f\n ;; ::::::::::::::::::::\n ;; ::\n+;; :: 128 bit Integer arithmetic\n+;; ::\n+;; ::::::::::::::::::::\n+\n+(define_insn \"addti3\"\n+  [(set (match_operand:TI 0 \"gr_register_operand\" \"=&r\")\n+\t(plus:TI (match_operand:TI 1 \"gr_register_operand\" \"%r\")\n+\t\t (match_operand:TI 2 \"gr_reg_or_14bit_operand\" \"rI\")))\n+   (clobber (match_scratch:BI 3 \"=&c\"))]\n+  \"\"\n+  \"#\"\n+  [(set_attr \"itanium_class\" \"unknown\")])\n+\n+(define_split\n+  [(set (match_operand:TI 0 \"register_operand\" \"\")\n+\t(plus:TI (match_operand:TI 1 \"register_operand\" \"\")\n+\t\t (match_operand:TI 2 \"register_operand\" \"\")))\n+   (clobber (match_scratch:BI 3 \"\"))]\n+  \"reload_completed\"\n+  [(set (match_dup 0) (plus:DI (match_dup 1) (match_dup 2)))\n+   (set (match_dup 3) (ltu:BI (match_dup 0) (match_dup 1)))\n+   (cond_exec (eq (match_dup 3) (const_int 0))\n+\t      (set (match_dup 4) (plus:DI (match_dup 5) (match_dup 6))))\n+   (cond_exec (ne (match_dup 3) (const_int 0))\n+\t      (set (match_dup 4)\n+\t\t   (plus:DI (plus:DI (match_dup 5) (match_dup 6))\n+\t\t\t    (const_int 1))))]\n+{\n+  operands[4] = gen_highpart (DImode, operands[0]);\n+  operands[0] = gen_lowpart (DImode, operands[0]);\n+  operands[5] = gen_highpart (DImode, operands[1]);\n+  operands[1] = gen_lowpart (DImode, operands[1]);\n+  operands[6] = gen_highpart (DImode, operands[2]);\n+  operands[2] = gen_lowpart (DImode, operands[2]);\n+})\n+\n+(define_split\n+  [(set (match_operand:TI 0 \"register_operand\" \"\")\n+\t(plus:TI (match_operand:TI 1 \"register_operand\" \"\")\n+\t\t (match_operand:TI 2 \"immediate_operand\" \"\")))\n+   (clobber (match_scratch:BI 3 \"\"))]\n+  \"reload_completed\"\n+  [(set (match_dup 0) (plus:DI (match_dup 1) (match_dup 2)))\n+   (set (match_dup 3) (ltu:BI (match_dup 0) (match_dup 1)))\n+   (cond_exec (eq (match_dup 3) (const_int 0))\n+\t      (set (match_dup 4)\n+\t\t   (plus:DI (match_dup 5) (match_dup 6))))\n+   (cond_exec (ne (match_dup 3) (const_int 0))\n+\t      (set (match_dup 4)\n+\t\t   (plus:DI (match_dup 5) (match_dup 7))))]\n+{\n+  operands[4] = gen_highpart (DImode, operands[0]);\n+  operands[0] = gen_lowpart (DImode, operands[0]);\n+  operands[5] = gen_highpart (DImode, operands[1]);\n+  operands[1] = gen_lowpart (DImode, operands[1]);\n+  operands[6] = INTVAL (operands[2]) < 0 ? constm1_rtx : const0_rtx;\n+  operands[7] = INTVAL (operands[2]) < 0 ? const0_rtx : const1_rtx;\n+})\n+\n+(define_insn \"subti3\"\n+  [(set (match_operand:TI 0 \"gr_register_operand\" \"=&r\")\n+\t(minus:TI (match_operand:TI 1 \"gr_reg_or_8bit_operand\" \"rK\")\n+\t\t  (match_operand:TI 2 \"gr_register_operand\" \"r\")))\n+   (clobber (match_scratch:BI 3 \"=&c\"))]\n+  \"\"\n+  \"#\"\n+  [(set_attr \"itanium_class\" \"unknown\")])\n+\n+(define_split\n+  [(set (match_operand:TI 0 \"register_operand\" \"\")\n+\t(minus:TI (match_operand:TI 1 \"register_operand\" \"\")\n+\t\t  (match_operand:TI 2 \"register_operand\" \"\")))\n+   (clobber (match_scratch:BI 3 \"=&c\"))]\n+  \"reload_completed\"\n+  [(set (match_dup 0) (minus:DI (match_dup 1) (match_dup 2)))\n+   (set (match_dup 3) (ltu:BI (match_dup 1) (match_dup 0)))\n+   (cond_exec (eq (match_dup 3) (const_int 0))\n+\t      (set (match_dup 4) (minus:DI (match_dup 5) (match_dup 6))))\n+   (cond_exec (ne (match_dup 3) (const_int 0))\n+\t      (set (match_dup 4)\n+\t\t   (plus:DI (not:DI (match_dup 6)) (match_dup 5))))]\n+{\n+  operands[4] = gen_highpart (DImode, operands[0]);\n+  operands[0] = gen_lowpart (DImode, operands[0]);\n+  operands[5] = gen_highpart (DImode, operands[1]);\n+  operands[1] = gen_lowpart (DImode, operands[1]);\n+  operands[6] = gen_highpart (DImode, operands[2]);\n+  operands[2] = gen_lowpart (DImode, operands[2]);\n+})\n+\n+(define_split\n+  [(set (match_operand:TI 0 \"register_operand\" \"\")\n+\t(minus:TI (match_operand:TI 1 \"immediate_operand\" \"\")\n+\t\t  (match_operand:TI 2 \"register_operand\" \"\")))\n+   (clobber (match_scratch:BI 3 \"=&c\"))]\n+  \"reload_completed && CONST_OK_FOR_K (INTVAL (operands[1]))\"\n+  [(set (match_dup 0) (minus:DI (match_dup 1) (match_dup 2)))\n+   (set (match_dup 3) (gtu:BI (match_dup 0) (match_dup 1)))\n+   (cond_exec (ne (match_dup 3) (const_int 0))\n+\t      (set (match_dup 4) (minus:DI (match_dup 6) (match_dup 5))))\n+   (cond_exec (eq (match_dup 3) (const_int 0))\n+\t      (set (match_dup 4) (minus:DI (match_dup 7) (match_dup 5))))]\n+{\n+  operands[4] = gen_highpart (DImode, operands[0]);\n+  operands[0] = gen_lowpart (DImode, operands[0]);\n+  operands[5] = gen_highpart (DImode, operands[2]);\n+  operands[2] = gen_lowpart (DImode, operands[2]);\n+  operands[6] = INTVAL (operands[1]) < 0 ? GEN_INT (-2) : constm1_rtx;\n+  operands[7] = INTVAL (operands[1]) < 0 ? constm1_rtx : const0_rtx;\n+})\n+\n+(define_expand \"mulditi3\"\n+  [(set (match_operand:TI 0 \"fr_register_operand\" \"\")\n+\t(mult:TI (sign_extend:TI\n+\t\t   (match_operand:DI 1 \"fr_register_operand\" \"\"))\n+\t\t (sign_extend:TI\n+\t\t   (match_operand:DI 2 \"fr_register_operand\" \"\"))))]\n+  \"\"\n+  \"\")\n+\n+(define_insn_and_split \"*mulditi3_internal\"\n+  [(set (match_operand:TI 0 \"fr_register_operand\" \"=&f\")\n+\t(mult:TI (sign_extend:TI\n+\t\t   (match_operand:DI 1 \"fr_register_operand\" \"%f\"))\n+\t\t (sign_extend:TI\n+\t\t   (match_operand:DI 2 \"fr_register_operand\" \"f\"))))]\n+  \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(set (match_dup 0) (mult:DI (match_dup 1) (match_dup 2)))\n+   (set (match_dup 3) (truncate:DI\n+\t\t\t(lshiftrt:TI\n+\t\t\t  (mult:TI (sign_extend:TI (match_dup 1))\n+\t\t\t\t   (sign_extend:TI (match_dup 2)))\n+\t\t\t  (const_int 64))))]\n+{\n+  operands[3] = gen_highpart (DImode, operands[0]);\n+  operands[0] = gen_lowpart (DImode, operands[0]);\n+}\n+  [(set_attr \"itanium_class\" \"unknown\")])\n+\n+(define_expand \"umulditi3\"\n+  [(set (match_operand:TI 0 \"fr_register_operand\" \"\")\n+\t(mult:TI (zero_extend:TI\n+\t\t   (match_operand:DI 1 \"fr_register_operand\" \"\"))\n+\t\t (zero_extend:TI\n+\t\t   (match_operand:DI 2 \"fr_register_operand\" \"\"))))]\n+  \"\"\n+  \"\")\n+\n+(define_insn_and_split \"*umulditi3_internal\"\n+  [(set (match_operand:TI 0 \"fr_register_operand\" \"=&f\")\n+\t(mult:TI (zero_extend:TI\n+\t\t   (match_operand:DI 1 \"fr_register_operand\" \"%f\"))\n+\t\t (zero_extend:TI\n+\t\t   (match_operand:DI 2 \"fr_register_operand\" \"f\"))))]\n+  \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(set (match_dup 0) (mult:DI (match_dup 1) (match_dup 2)))\n+   (set (match_dup 3) (truncate:DI\n+\t\t\t(lshiftrt:TI\n+\t\t\t  (mult:TI (zero_extend:TI (match_dup 1))\n+\t\t\t\t   (zero_extend:TI (match_dup 2)))\n+\t\t\t  (const_int 64))))]\n+{\n+  operands[3] = gen_highpart (DImode, operands[0]);\n+  operands[0] = gen_lowpart (DImode, operands[0]);\n+}\n+  [(set_attr \"itanium_class\" \"unknown\")])\n+\n+(define_insn_and_split \"negti2\"\n+  [(set (match_operand:TI 0 \"gr_register_operand\" \"=&r\")\n+\t(neg:TI (match_operand:TI 1 \"gr_register_operand\" \"r\")))\n+   (clobber (match_scratch:BI 2 \"=&c\"))]\n+  \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(set (match_dup 2) (eq:BI (match_dup 1) (const_int 0)))\n+   (set (match_dup 0) (minus:DI (const_int 0) (match_dup 1)))\n+   (cond_exec (eq (match_dup 2) (const_int 0))\n+\t      (set (match_dup 3) (minus:DI (const_int -1) (match_dup 4))))\n+   (cond_exec (ne (match_dup 2) (const_int 0))\n+\t      (set (match_dup 3) (minus:DI (const_int 0) (match_dup 4))))]\n+{\n+  operands[3] = gen_highpart (DImode, operands[0]);\n+  operands[0] = gen_lowpart (DImode, operands[0]);\n+  operands[4] = gen_highpart (DImode, operands[1]);\n+  operands[1] = gen_lowpart (DImode, operands[1]);\n+}\n+  [(set_attr \"itanium_class\" \"unknown\")])\n+\f\n+;; ::::::::::::::::::::\n+;; ::\n ;; :: 32 bit floating point arithmetic\n ;; ::\n ;; ::::::::::::::::::::\n@@ -4505,6 +4700,54 @@\n   DONE;\n })\n \n+(define_expand \"rotlti3\"\n+  [(set (match_operand:TI 0 \"gr_register_operand\" \"\")\n+\t(rotate:TI (match_operand:TI 1 \"gr_register_operand\" \"\")\n+\t\t   (match_operand:DI 2 \"nonmemory_operand\" \"\")))]\n+  \"\"\n+{\n+  if (! dshift_count_operand (operands[2], DImode))\n+    FAIL;\n+})\n+\n+(define_insn_and_split \"*rotlti3_internal\"\n+  [(set (match_operand:TI 0 \"gr_register_operand\" \"=&r\")\n+\t(rotate:TI (match_operand:TI 1 \"gr_register_operand\" \"r\")\n+\t\t   (match_operand:DI 2 \"dshift_count_operand\" \"n\")))]\n+  \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(const_int 0)]\n+{\n+  HOST_WIDE_INT count = INTVAL (operands[2]);\n+  rtx rl = gen_lowpart (DImode, operands[0]);\n+  rtx rh = gen_highpart (DImode, operands[0]);\n+  rtx lo = gen_lowpart (DImode, operands[1]);\n+  rtx hi = gen_highpart (DImode, operands[1]);\n+  rtx countlo = GEN_INT (-count & 63);\n+\n+  if (count & 64)\n+    {\n+      if (count & 63)\n+\t{\n+\t  emit_insn (gen_shrp (rl, hi, lo, countlo));\n+\t  emit_insn (gen_shrp (rh, lo, hi, countlo));\n+\t}\n+      else\n+\t{\n+\t  emit_move_insn (rl, hi);\n+\t  emit_move_insn (rh, lo);\n+\t}\n+    }\n+  else\n+    {\n+      emit_insn (gen_shrp (rl, lo, hi, countlo));\n+      emit_insn (gen_shrp (rh, hi, lo, countlo));\n+    }\n+  DONE;\n+}\n+  [(set_attr \"itanium_class\" \"unknown\")])\n+\n (define_insn \"shrp\"\n   [(set (match_operand:DI 0 \"gr_register_operand\" \"=r\")\n \t(unspec:DI [(match_operand:DI 1 \"gr_register_operand\" \"r\")"}, {"sha": "e93475ada7e52444d02c3470af77246243a2f5fb", "filename": "gcc/config/ia64/itanium1.md", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a71aef0bb317dfa73527e3fd7c4895ca52551901/gcc%2Fconfig%2Fia64%2Fitanium1.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a71aef0bb317dfa73527e3fd7c4895ca52551901/gcc%2Fconfig%2Fia64%2Fitanium1.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fitanium1.md?ref=a71aef0bb317dfa73527e3fd7c4895ca52551901", "patch": "@@ -529,6 +529,10 @@\n   (and (and (eq_attr \"cpu\" \"itanium\")\n             (eq_attr \"itanium_class\" \"fld\"))\n        (eq (symbol_ref \"bundling_p\") (const_int 0))) \"1_M\")\n+(define_insn_reservation \"1_fldp\"    9\n+  (and (and (eq_attr \"cpu\" \"itanium\")\n+            (eq_attr \"itanium_class\" \"fldp\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0))) \"1_M\")\n (define_insn_reservation \"1_fmac\"    5\n   (and (and (eq_attr \"cpu\" \"itanium\")\n             (eq_attr \"itanium_class\" \"fmac\"))\n@@ -1407,6 +1411,10 @@\n   (and (and (eq_attr \"cpu\" \"itanium\")\n             (eq_attr \"itanium_class\" \"fld\"))\n        (ne (symbol_ref \"bundling_p\") (const_int 0))) \"1b_M\")\n+(define_insn_reservation \"1b_fldp\"    9\n+  (and (and (eq_attr \"cpu\" \"itanium\")\n+            (eq_attr \"itanium_class\" \"fldp\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0))) \"1b_M\")\n (define_insn_reservation \"1b_fmac\"    5\n   (and (and (eq_attr \"cpu\" \"itanium\")\n             (eq_attr \"itanium_class\" \"fmac\"))"}, {"sha": "f16d185e52ba4c0a0c65487a6b9042f1fd31682c", "filename": "gcc/config/ia64/itanium2.md", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a71aef0bb317dfa73527e3fd7c4895ca52551901/gcc%2Fconfig%2Fia64%2Fitanium2.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a71aef0bb317dfa73527e3fd7c4895ca52551901/gcc%2Fconfig%2Fia64%2Fitanium2.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fitanium2.md?ref=a71aef0bb317dfa73527e3fd7c4895ca52551901", "patch": "@@ -734,6 +734,11 @@\n   (and (and (eq_attr \"cpu\" \"itanium2\")\n             (eq_attr \"itanium_class\" \"fld\"))\n        (eq (symbol_ref \"bundling_p\") (const_int 0))) \"2_M\")\n+(define_insn_reservation \"2_fldp\"    6\n+  (and (and (eq_attr \"cpu\" \"itanium2\")\n+            (eq_attr \"itanium_class\" \"fldp\"))\n+       (eq (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"2_M_only_um01\")\n (define_insn_reservation \"2_fmac\"    4\n   (and (and (eq_attr \"cpu\" \"itanium2\")\n             (eq_attr \"itanium_class\" \"fmac\"))\n@@ -1541,6 +1546,11 @@\n   (and (and (eq_attr \"cpu\" \"itanium2\")\n             (eq_attr \"itanium_class\" \"fld\"))\n        (ne (symbol_ref \"bundling_p\") (const_int 0))) \"2b_M\")\n+(define_insn_reservation \"2b_fldp\"    6\n+  (and (and (eq_attr \"cpu\" \"itanium2\")\n+            (eq_attr \"itanium_class\" \"fldp\"))\n+       (ne (symbol_ref \"bundling_p\") (const_int 0)))\n+  \"2b_M_only_um01\")\n (define_insn_reservation \"2b_fmac\"    4\n   (and (and (eq_attr \"cpu\" \"itanium2\")\n             (eq_attr \"itanium_class\" \"fmac\"))"}]}