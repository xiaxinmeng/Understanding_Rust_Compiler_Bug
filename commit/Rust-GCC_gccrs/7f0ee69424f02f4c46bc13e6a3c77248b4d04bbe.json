{"sha": "7f0ee69424f02f4c46bc13e6a3c77248b4d04bbe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2YwZWU2OTQyNGYwMmY0YzQ2YmMxM2U2YTNjNzcyNDhiNGQwNGJiZQ==", "commit": {"author": {"name": "Bob Wilson", "email": "bob.wilson@acm.org", "date": "2007-12-20T22:35:59Z"}, "committer": {"name": "Bob Wilson", "email": "bwilson@gcc.gnu.org", "date": "2007-12-20T22:35:59Z"}, "message": "xtensa.md (fix_return_addr): Remove.\n\n\t* config/xtensa/xtensa.md (fix_return_addr): Remove.\n\t* config/xtensa/xtensa-protos.h (xtensa_initialize_trampoline): New.\n\t(xtensa_trampoline_template): New.\n\t* config/xtensa/xtensa.c (MIN_FRAME_SIZE): Moved here from xtensa.h.\n\t(xtensa_return_addr): Expand to standard Xtensa insns instead of\n\tfix_return_addr.  Get high bits from a local label.\n\t(xtensa_trampoline_template): New function with code moved from\n\tTRAMPOLINE_TEMPLATE in xtensa.h.  Use L32R instead of CALL0 except\n\twhen using CONST16 or absolute-mode literals.\n\t(xtensa_initialize_trampoline): New function with code moved from\n\tINITIALIZE_TRAMPOLINE in xtensa.h.  Use different offsets depending\n\ton which trampoline version is used.\n\t* config/xtensa/lib2funcs.S (TRAMPOLINE_SIZE): Add comment.\n\t* config/xtensa/xtensa.h (TARGET_ABSOLUTE_LITERALS): Define.\n\t(MIN_FRAME_SIZE): Moved to xtensa.c.\n\t(TRAMPOLINE_TEMPLATE): Use xtensa_trampoline_template.\n\t(TRAMPOLINE_SIZE): Two versions of the trampoline have different sizes.\n\t(INITIALIZE_TRAMPOLINE): Use xtensa_initialize_trampoline.\n\t* config/xtensa/ieee754-df.S (XCHAL_NO_MUL): Define.\n\t(__muldf3): Use CALL12 instead of CALL0 to invoke .Lmul_mulsi3\n\thelper when not using the CALL0 ABI.  Change .Lmul_mulsi3 to match.\n\t* config/xtensa/lib1funcs.asm (__umulsidi3): Likewise.\n\t* config/xtensa/ieee754-sf.S (__mulsf3): Likewise.\n\nFrom-SVN: r131108", "tree": {"sha": "1f8ed8887da3e944685f3aeb71c9a3a4d12fcef4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1f8ed8887da3e944685f3aeb71c9a3a4d12fcef4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7f0ee69424f02f4c46bc13e6a3c77248b4d04bbe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f0ee69424f02f4c46bc13e6a3c77248b4d04bbe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f0ee69424f02f4c46bc13e6a3c77248b4d04bbe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f0ee69424f02f4c46bc13e6a3c77248b4d04bbe/comments", "author": null, "committer": null, "parents": [{"sha": "4c12c8ea94136784569197991369ed98329719ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c12c8ea94136784569197991369ed98329719ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c12c8ea94136784569197991369ed98329719ae"}], "stats": {"total": 520, "additions": 333, "deletions": 187}, "files": [{"sha": "9674a7c0877f7f9146687fa8c9b44db7f1992d4d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f0ee69424f02f4c46bc13e6a3c77248b4d04bbe/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f0ee69424f02f4c46bc13e6a3c77248b4d04bbe/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7f0ee69424f02f4c46bc13e6a3c77248b4d04bbe", "patch": "@@ -1,3 +1,29 @@\n+2007-12-20  Bob Wilson  <bob.wilson@acm.org>\n+\n+\t* config/xtensa/xtensa.md (fix_return_addr): Remove.\n+\t* config/xtensa/xtensa-protos.h (xtensa_initialize_trampoline): New.\n+\t(xtensa_trampoline_template): New.\n+\t* config/xtensa/xtensa.c (MIN_FRAME_SIZE): Moved here from xtensa.h.\n+\t(xtensa_return_addr): Expand to standard Xtensa insns instead of\n+\tfix_return_addr.  Get high bits from a local label.\n+\t(xtensa_trampoline_template): New function with code moved from\n+\tTRAMPOLINE_TEMPLATE in xtensa.h.  Use L32R instead of CALL0 except\n+\twhen using CONST16 or absolute-mode literals.\n+\t(xtensa_initialize_trampoline): New function with code moved from\n+\tINITIALIZE_TRAMPOLINE in xtensa.h.  Use different offsets depending\n+\ton which trampoline version is used.\n+\t* config/xtensa/lib2funcs.S (TRAMPOLINE_SIZE): Add comment.\n+\t* config/xtensa/xtensa.h (TARGET_ABSOLUTE_LITERALS): Define.\n+\t(MIN_FRAME_SIZE): Moved to xtensa.c.\n+\t(TRAMPOLINE_TEMPLATE): Use xtensa_trampoline_template.\n+\t(TRAMPOLINE_SIZE): Two versions of the trampoline have different sizes.\n+\t(INITIALIZE_TRAMPOLINE): Use xtensa_initialize_trampoline.\n+\t* config/xtensa/ieee754-df.S (XCHAL_NO_MUL): Define.\n+\t(__muldf3): Use CALL12 instead of CALL0 to invoke .Lmul_mulsi3\n+\thelper when not using the CALL0 ABI.  Change .Lmul_mulsi3 to match.\n+\t* config/xtensa/lib1funcs.asm (__umulsidi3): Likewise.\n+\t* config/xtensa/ieee754-sf.S (__mulsf3): Likewise.\n+\t\n 2007-12-20  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/34459"}, {"sha": "381e6ce31f34284aa06941334bbee96f9ff60505", "filename": "gcc/config/xtensa/ieee754-df.S", "status": "modified", "additions": 62, "deletions": 34, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f0ee69424f02f4c46bc13e6a3c77248b4d04bbe/gcc%2Fconfig%2Fxtensa%2Fieee754-df.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f0ee69424f02f4c46bc13e6a3c77248b4d04bbe/gcc%2Fconfig%2Fxtensa%2Fieee754-df.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fieee754-df.S?ref=7f0ee69424f02f4c46bc13e6a3c77248b4d04bbe", "patch": "@@ -1,5 +1,5 @@\n /* IEEE-754 double-precision functions for Xtensa\n-   Copyright (C) 2006 Free Software Foundation, Inc.\n+   Copyright (C) 2006, 2007 Free Software Foundation, Inc.\n    Contributed by Bob Wilson (bwilson@tensilica.com) at Tensilica.\n \n    This file is part of GCC.\n@@ -607,6 +607,10 @@ __subdf3:\n #ifdef L_muldf3\n \n \t/* Multiplication */\n+#if !XCHAL_HAVE_MUL16 && !XCHAL_HAVE_MUL32 && !XCHAL_HAVE_MAC16\n+#define XCHAL_NO_MUL 1\n+#endif\n+\n __muldf3_aux:\n \n \t/* Handle unusual cases (zeros, subnormals, NaNs and Infinities).\n@@ -728,13 +732,19 @@ __muldf3_aux:\n \t.global\t__muldf3\n \t.type\t__muldf3, @function\n __muldf3:\n-\tleaf_entry sp, 32\n #if __XTENSA_CALL0_ABI__\n+\tleaf_entry sp, 32\n \taddi\tsp, sp, -32\n \ts32i\ta12, sp, 16\n \ts32i\ta13, sp, 20\n \ts32i\ta14, sp, 24\n \ts32i\ta15, sp, 28\n+#elif XCHAL_NO_MUL\n+\t/* This is not really a leaf function; allocate enough stack space\n+\t   to allow CALL12s to a helper function.  */\n+\tleaf_entry sp, 64\n+#else\n+\tleaf_entry sp, 32\n #endif\n \tmovi\ta6, 0x7ff00000\n \n@@ -809,7 +819,7 @@ __muldf3:\n \tmuluh\txh, xh, yh\n \tadd\txh, xh, a9\n \n-#else\n+#else /* ! XCHAL_HAVE_MUL32_HIGH */\n \n \t/* Break the inputs into 16-bit chunks and compute 16 32-bit partial\n \t   products.  These partial products are:\n@@ -847,7 +857,7 @@ __muldf3:\n \n \t/* Save a7 since it is needed to hold a temporary value.  */\n \ts32i\ta7, sp, 4\n-#if !XCHAL_HAVE_MUL16 && !XCHAL_HAVE_MUL32 && !XCHAL_HAVE_MAC16\n+#if __XTENSA_CALL0_ABI__ && XCHAL_NO_MUL\n \t/* Calling a separate multiply function will clobber a0 and requires\n \t   use of a8 as a temporary, so save those values now.  (The function\n \t   uses a custom ABI so nothing else needs to be saved.)  */\n@@ -915,12 +925,21 @@ __muldf3:\n #define set_arg_h(dst, src) \\\n \tsrli\tdst, src, 16\n \n+#if __XTENSA_CALL0_ABI__\n #define do_mul(dst, xreg, xhalf, yreg, yhalf) \\\n \tset_arg_ ## xhalf (a13, xreg); \\\n \tset_arg_ ## yhalf (a14, yreg); \\\n \tcall0\t.Lmul_mulsi3; \\\n \tmov\tdst, a12\n-#endif\n+#else\n+#define do_mul(dst, xreg, xhalf, yreg, yhalf) \\\n+\tset_arg_ ## xhalf (a14, xreg); \\\n+\tset_arg_ ## yhalf (a15, yreg); \\\n+\tcall12\t.Lmul_mulsi3; \\\n+\tmov\tdst, a14\n+#endif /* __XTENSA_CALL0_ABI__ */\n+\n+#endif /* no multiply hardware */\n \n \t/* Add pp1 and pp2 into a10 with carry-out in a9.  */\n \tdo_mul(a10, xl, l, yl, h)\t/* pp 1 */\n@@ -1032,11 +1051,11 @@ __muldf3:\n \n \t/* Restore values saved on the stack during the multiplication.  */\n \tl32i\ta7, sp, 4\n-#if !XCHAL_HAVE_MUL16 && !XCHAL_HAVE_MUL32 && !XCHAL_HAVE_MAC16\n+#if __XTENSA_CALL0_ABI__ && XCHAL_NO_MUL\n \tl32i\ta0, sp, 0\n \tl32i\ta8, sp, 8\n #endif\n-#endif\n+#endif /* ! XCHAL_HAVE_MUL32_HIGH */\n \n \t/* Shift left by 12 bits, unless there was a carry-out from the\n \t   multiply, in which case, shift by 11 bits and increment the\n@@ -1157,38 +1176,47 @@ __muldf3:\n \tmovi\txl, 0\n \tj\t.Lmul_done\n \n-#if !XCHAL_HAVE_MUL16 && !XCHAL_HAVE_MUL32 && !XCHAL_HAVE_MAC16\n+#if XCHAL_NO_MUL\n \t\n \t/* For Xtensa processors with no multiply hardware, this simplified\n \t   version of _mulsi3 is used for multiplying 16-bit chunks of\n-\t   the floating-point mantissas.  It uses a custom ABI:\tthe inputs\n-\t   are passed in a13 and a14, the result is returned in a12, and\n-\t   a8 and a15 are clobbered.  */\n+\t   the floating-point mantissas.  When using CALL0, this function\n+\t   uses a custom ABI: the inputs are passed in a13 and a14, the\n+\t   result is returned in a12, and a8 and a15 are clobbered.  */\n \t.align\t4\n .Lmul_mulsi3:\n-\tmovi\ta12, 0\n-.Lmul_mult_loop:\n-\tadd\ta15, a14, a12\n-\textui\ta8, a13, 0, 1\n-\tmovnez\ta12, a15, a8\n-\n-\tdo_addx2 a15, a14, a12, a15\n-\textui\ta8, a13, 1, 1\n-\tmovnez\ta12, a15, a8\n-\n-\tdo_addx4 a15, a14, a12, a15\n-\textui\ta8, a13, 2, 1\n-\tmovnez\ta12, a15, a8\n-\n-\tdo_addx8 a15, a14, a12, a15\n-\textui\ta8, a13, 3, 1\n-\tmovnez\ta12, a15, a8\n-\n-\tsrli\ta13, a13, 4\n-\tslli\ta14, a14, 4\n-\tbnez\ta13, .Lmul_mult_loop\n-\tret\n-#endif /* !MUL16 && !MUL32 && !MAC16 */\n+\tleaf_entry sp, 16\n+\t.macro mul_mulsi3_body dst, src1, src2, tmp1, tmp2\n+\tmovi\t\\dst, 0\n+1:\tadd\t\\tmp1, \\src2, \\dst\n+\textui\t\\tmp2, \\src1, 0, 1\n+\tmovnez\t\\dst, \\tmp1, \\tmp2\n+\n+\tdo_addx2 \\tmp1, \\src2, \\dst, \\tmp1\n+\textui\t\\tmp2, \\src1, 1, 1\n+\tmovnez\t\\dst, \\tmp1, \\tmp2\n+\n+\tdo_addx4 \\tmp1, \\src2, \\dst, \\tmp1\n+\textui\t\\tmp2, \\src1, 2, 1\n+\tmovnez\t\\dst, \\tmp1, \\tmp2\n+\n+\tdo_addx8 \\tmp1, \\src2, \\dst, \\tmp1\n+\textui\t\\tmp2, \\src1, 3, 1\n+\tmovnez\t\\dst, \\tmp1, \\tmp2\n+\n+\tsrli\t\\src1, \\src1, 4\n+\tslli\t\\src2, \\src2, 4\n+\tbnez\t\\src1, 1b\n+\t.endm\n+#if __XTENSA_CALL0_ABI__\n+\tmul_mulsi3_body a12, a13, a14, a15, a8\n+#else\n+\t/* The result will be written into a2, so save that argument in a4.  */\n+\tmov\ta4, a2\n+\tmul_mulsi3_body a2, a4, a3, a5, a6\n+#endif\n+\tleaf_return\n+#endif /* XCHAL_NO_MUL */\n #endif /* L_muldf3 */\n \n #ifdef L_divdf3"}, {"sha": "abb641d9456b9be3151de184f6c4794f78d3e264", "filename": "gcc/config/xtensa/ieee754-sf.S", "status": "modified", "additions": 61, "deletions": 33, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f0ee69424f02f4c46bc13e6a3c77248b4d04bbe/gcc%2Fconfig%2Fxtensa%2Fieee754-sf.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f0ee69424f02f4c46bc13e6a3c77248b4d04bbe/gcc%2Fconfig%2Fxtensa%2Fieee754-sf.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fieee754-sf.S?ref=7f0ee69424f02f4c46bc13e6a3c77248b4d04bbe", "patch": "@@ -1,5 +1,5 @@\n /* IEEE-754 single-precision functions for Xtensa\n-   Copyright (C) 2006 Free Software Foundation, Inc.\n+   Copyright (C) 2006, 2007 Free Software Foundation, Inc.\n    Contributed by Bob Wilson (bwilson@tensilica.com) at Tensilica.\n \n    This file is part of GCC.\n@@ -488,6 +488,10 @@ __subsf3:\n #ifdef L_mulsf3\n \n \t/* Multiplication */\n+#if !XCHAL_HAVE_MUL16 && !XCHAL_HAVE_MUL32 && !XCHAL_HAVE_MAC16\n+#define XCHAL_NO_MUL 1\n+#endif\n+\n __mulsf3_aux:\n \n \t/* Handle unusual cases (zeros, subnormals, NaNs and Infinities).\n@@ -570,13 +574,19 @@ __mulsf3_aux:\n \t.global\t__mulsf3\n \t.type\t__mulsf3, @function\n __mulsf3:\n-\tleaf_entry sp, 32\n #if __XTENSA_CALL0_ABI__\n+\tleaf_entry sp, 32\n \taddi\tsp, sp, -32\n \ts32i\ta12, sp, 16\n \ts32i\ta13, sp, 20\n \ts32i\ta14, sp, 24\n \ts32i\ta15, sp, 28\n+#elif XCHAL_NO_MUL\n+\t/* This is not really a leaf function; allocate enough stack space\n+\t   to allow CALL12s to a helper function.  */\n+\tleaf_entry sp, 64\n+#else\n+\tleaf_entry sp, 32\n #endif\n \tmovi\ta6, 0x7f800000\n \n@@ -633,7 +643,7 @@ __mulsf3:\n \t   chunks can be extracted when setting up the arguments to the\n \t   separate multiply function.  */\n \n-#if !XCHAL_HAVE_MUL16 && !XCHAL_HAVE_MUL32 && !XCHAL_HAVE_MAC16\n+#if __XTENSA_CALL0_ABI__ && XCHAL_NO_MUL\n \t/* Calling a separate multiply function will clobber a0 and requires\n \t   use of a8 as a temporary, so save those values now.  (The function\n \t   uses a custom ABI so nothing else needs to be saved.)  */\n@@ -693,12 +703,21 @@ __mulsf3:\n #define set_arg_h(dst, src) \\\n \tsrli\tdst, src, 16\n \n+#if __XTENSA_CALL0_ABI__\n #define do_mul(dst, xreg, xhalf, yreg, yhalf) \\\n \tset_arg_ ## xhalf (a13, xreg); \\\n \tset_arg_ ## yhalf (a14, yreg); \\\n \tcall0\t.Lmul_mulsi3; \\\n \tmov\tdst, a12\n-#endif\n+#else\n+#define do_mul(dst, xreg, xhalf, yreg, yhalf) \\\n+\tset_arg_ ## xhalf (a14, xreg); \\\n+\tset_arg_ ## yhalf (a15, yreg); \\\n+\tcall12\t.Lmul_mulsi3; \\\n+\tmov\tdst, a14\n+#endif /* __XTENSA_CALL0_ABI__ */\n+\n+#endif /* no multiply hardware */\n \n \t/* Add pp1 and pp2 into a6 with carry-out in a9.  */\n \tdo_mul(a6, a2, l, a3, h)\t/* pp 1 */\n@@ -724,12 +743,12 @@ __mulsf3:\n \tdo_mul(a2, a2, h, a3, h)\t/* pp 3 */\n \tadd\ta2, a2, a9\n \t\n-#if !XCHAL_HAVE_MUL16 && !XCHAL_HAVE_MUL32 && !XCHAL_HAVE_MAC16\n+#if __XTENSA_CALL0_ABI__ && XCHAL_NO_MUL\n \t/* Restore values saved on the stack during the multiplication.  */\n \tl32i\ta0, sp, 0\n \tl32i\ta8, sp, 4\n #endif\n-#endif\n+#endif /* ! XCHAL_HAVE_MUL32_HIGH */\n \n \t/* Shift left by 9 bits, unless there was a carry-out from the\n \t   multiply, in which case, shift by 8 bits and increment the\n@@ -825,38 +844,47 @@ __mulsf3:\n \tslli\ta2, a2, 31\n \tj\t.Lmul_done\n \n-#if !XCHAL_HAVE_MUL16 && !XCHAL_HAVE_MUL32 && !XCHAL_HAVE_MAC16\n+#if XCHAL_NO_MUL\n \t\n \t/* For Xtensa processors with no multiply hardware, this simplified\n \t   version of _mulsi3 is used for multiplying 16-bit chunks of\n-\t   the floating-point mantissas.  It uses a custom ABI:\tthe inputs\n-\t   are passed in a13 and a14, the result is returned in a12, and\n-\t   a8 and a15 are clobbered.  */\n+\t   the floating-point mantissas.  When using CALL0, this function\n+\t   uses a custom ABI: the inputs are passed in a13 and a14, the\n+\t   result is returned in a12, and a8 and a15 are clobbered.  */\n \t.align\t4\n .Lmul_mulsi3:\n-\tmovi\ta12, 0\n-.Lmul_mult_loop:\n-\tadd\ta15, a14, a12\n-\textui\ta8, a13, 0, 1\n-\tmovnez\ta12, a15, a8\n-\n-\tdo_addx2 a15, a14, a12, a15\n-\textui\ta8, a13, 1, 1\n-\tmovnez\ta12, a15, a8\n-\n-\tdo_addx4 a15, a14, a12, a15\n-\textui\ta8, a13, 2, 1\n-\tmovnez\ta12, a15, a8\n-\n-\tdo_addx8 a15, a14, a12, a15\n-\textui\ta8, a13, 3, 1\n-\tmovnez\ta12, a15, a8\n-\n-\tsrli\ta13, a13, 4\n-\tslli\ta14, a14, 4\n-\tbnez\ta13, .Lmul_mult_loop\n-\tret\n-#endif /* !MUL16 && !MUL32 && !MAC16 */\n+\tleaf_entry sp, 16\n+\t.macro mul_mulsi3_body dst, src1, src2, tmp1, tmp2\n+\tmovi\t\\dst, 0\n+1:\tadd\t\\tmp1, \\src2, \\dst\n+\textui\t\\tmp2, \\src1, 0, 1\n+\tmovnez\t\\dst, \\tmp1, \\tmp2\n+\n+\tdo_addx2 \\tmp1, \\src2, \\dst, \\tmp1\n+\textui\t\\tmp2, \\src1, 1, 1\n+\tmovnez\t\\dst, \\tmp1, \\tmp2\n+\n+\tdo_addx4 \\tmp1, \\src2, \\dst, \\tmp1\n+\textui\t\\tmp2, \\src1, 2, 1\n+\tmovnez\t\\dst, \\tmp1, \\tmp2\n+\n+\tdo_addx8 \\tmp1, \\src2, \\dst, \\tmp1\n+\textui\t\\tmp2, \\src1, 3, 1\n+\tmovnez\t\\dst, \\tmp1, \\tmp2\n+\n+\tsrli\t\\src1, \\src1, 4\n+\tslli\t\\src2, \\src2, 4\n+\tbnez\t\\src1, 1b\n+\t.endm\n+#if __XTENSA_CALL0_ABI__\n+\tmul_mulsi3_body a12, a13, a14, a15, a8\n+#else\n+\t/* The result will be written into a2, so save that argument in a4.  */\n+\tmov\ta4, a2\n+\tmul_mulsi3_body a2, a4, a3, a5, a6\n+#endif\n+\tleaf_return\n+#endif /* XCHAL_NO_MUL */\n #endif /* L_mulsf3 */\n \n #ifdef L_divsf3"}, {"sha": "69162f036e999fb3f13885c3d4a39414748f8742", "filename": "gcc/config/xtensa/lib1funcs.asm", "status": "modified", "additions": 60, "deletions": 31, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f0ee69424f02f4c46bc13e6a3c77248b4d04bbe/gcc%2Fconfig%2Fxtensa%2Flib1funcs.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f0ee69424f02f4c46bc13e6a3c77248b4d04bbe/gcc%2Fconfig%2Fxtensa%2Flib1funcs.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Flib1funcs.asm?ref=7f0ee69424f02f4c46bc13e6a3c77248b4d04bbe", "patch": "@@ -201,17 +201,28 @@ __mulsi3:\n \n \n #ifdef L_umulsidi3\n+\n+#if !XCHAL_HAVE_MUL16 && !XCHAL_HAVE_MUL32 && !XCHAL_HAVE_MAC16\n+#define XCHAL_NO_MUL 1\n+#endif\n+\n \t.align\t4\n \t.global\t__umulsidi3\n \t.type\t__umulsidi3, @function\n __umulsidi3:\n-\tleaf_entry sp, 32\n #if __XTENSA_CALL0_ABI__\n+\tleaf_entry sp, 32\n \taddi\tsp, sp, -32\n \ts32i\ta12, sp, 16\n \ts32i\ta13, sp, 20\n \ts32i\ta14, sp, 24\n \ts32i\ta15, sp, 28\n+#elif XCHAL_NO_MUL\n+\t/* This is not really a leaf function; allocate enough stack space\n+\t   to allow CALL12s to a helper function.  */\n+\tleaf_entry sp, 48\n+#else\n+\tleaf_entry sp, 16\n #endif\n \n #ifdef __XTENSA_EB__\n@@ -232,7 +243,7 @@ __umulsidi3:\n \n #else /* ! MUL32_HIGH */\n \n-#if !XCHAL_HAVE_MUL16 && !XCHAL_HAVE_MUL32 && !XCHAL_HAVE_MAC16\n+#if __XTENSA_CALL0_ABI__ && XCHAL_NO_MUL\n \t/* a0 and a8 will be clobbered by calling the multiply function\n \t   but a8 is not used here and need not be saved.  */\n \ts32i\ta0, sp, 0\n@@ -290,12 +301,21 @@ __umulsidi3:\n #define set_arg_h(dst, src) \\\n \tsrli\tdst, src, 16\n \n+#if __XTENSA_CALL0_ABI__\n #define do_mul(dst, xreg, xhalf, yreg, yhalf) \\\n \tset_arg_ ## xhalf (a13, xreg); \\\n \tset_arg_ ## yhalf (a14, yreg); \\\n \tcall0\t.Lmul_mulsi3; \\\n \tmov\tdst, a12\n-#endif\n+#else\n+#define do_mul(dst, xreg, xhalf, yreg, yhalf) \\\n+\tset_arg_ ## xhalf (a14, xreg); \\\n+\tset_arg_ ## yhalf (a15, yreg); \\\n+\tcall12\t.Lmul_mulsi3; \\\n+\tmov\tdst, a14\n+#endif /* __XTENSA_CALL0_ABI__ */\n+\n+#endif /* no multiply hardware */\n \n \t/* Add pp1 and pp2 into a6 with carry-out in a9.  */\n \tdo_mul(a6, a2, l, a3, h)\t/* pp 1 */\n@@ -324,7 +344,7 @@ __umulsidi3:\n \n #endif /* !MUL32_HIGH */\n \n-#if !XCHAL_HAVE_MUL16 && !XCHAL_HAVE_MUL32 && !XCHAL_HAVE_MAC16\n+#if __XTENSA_CALL0_ABI__ && XCHAL_NO_MUL\n \t/* Restore the original return address.  */\n \tl32i\ta0, sp, 0\n #endif\n@@ -337,38 +357,47 @@ __umulsidi3:\n #endif\n \tleaf_return\n \n-#if !XCHAL_HAVE_MUL16 && !XCHAL_HAVE_MUL32 && !XCHAL_HAVE_MAC16\n+#if XCHAL_NO_MUL\n \n \t/* For Xtensa processors with no multiply hardware, this simplified\n \t   version of _mulsi3 is used for multiplying 16-bit chunks of\n-\t   the floating-point mantissas.  It uses a custom ABI:\tthe inputs\n-\t   are passed in a13 and a14, the result is returned in a12, and\n-\t   a8 and a15 are clobbered.  */\n+\t   the floating-point mantissas.  When using CALL0, this function\n+\t   uses a custom ABI: the inputs are passed in a13 and a14, the\n+\t   result is returned in a12, and a8 and a15 are clobbered.  */\n \t.align\t4\n .Lmul_mulsi3:\n-\tmovi\ta12, 0\n-.Lmul_mult_loop:\n-\tadd\ta15, a14, a12\n-\textui\ta8, a13, 0, 1\n-\tmovnez\ta12, a15, a8\n-\n-\tdo_addx2 a15, a14, a12, a15\n-\textui\ta8, a13, 1, 1\n-\tmovnez\ta12, a15, a8\n-\n-\tdo_addx4 a15, a14, a12, a15\n-\textui\ta8, a13, 2, 1\n-\tmovnez\ta12, a15, a8\n-\n-\tdo_addx8 a15, a14, a12, a15\n-\textui\ta8, a13, 3, 1\n-\tmovnez\ta12, a15, a8\n-\n-\tsrli\ta13, a13, 4\n-\tslli\ta14, a14, 4\n-\tbnez\ta13, .Lmul_mult_loop\n-\tret\n-#endif /* !MUL16 && !MUL32 && !MAC16 */\n+\tleaf_entry sp, 16\n+\t.macro mul_mulsi3_body dst, src1, src2, tmp1, tmp2\n+\tmovi\t\\dst, 0\n+1:\tadd\t\\tmp1, \\src2, \\dst\n+\textui\t\\tmp2, \\src1, 0, 1\n+\tmovnez\t\\dst, \\tmp1, \\tmp2\n+\n+\tdo_addx2 \\tmp1, \\src2, \\dst, \\tmp1\n+\textui\t\\tmp2, \\src1, 1, 1\n+\tmovnez\t\\dst, \\tmp1, \\tmp2\n+\n+\tdo_addx4 \\tmp1, \\src2, \\dst, \\tmp1\n+\textui\t\\tmp2, \\src1, 2, 1\n+\tmovnez\t\\dst, \\tmp1, \\tmp2\n+\n+\tdo_addx8 \\tmp1, \\src2, \\dst, \\tmp1\n+\textui\t\\tmp2, \\src1, 3, 1\n+\tmovnez\t\\dst, \\tmp1, \\tmp2\n+\n+\tsrli\t\\src1, \\src1, 4\n+\tslli\t\\src2, \\src2, 4\n+\tbnez\t\\src1, 1b\n+\t.endm\n+#if __XTENSA_CALL0_ABI__\n+\tmul_mulsi3_body a12, a13, a14, a15, a8\n+#else\n+\t/* The result will be written into a2, so save that argument in a4.  */\n+\tmov\ta4, a2\n+\tmul_mulsi3_body a2, a4, a3, a5, a6\n+#endif\n+\tleaf_return\n+#endif /* XCHAL_NO_MUL */\n \n \t.size\t__umulsidi3, . - __umulsidi3\n "}, {"sha": "16d6734c277349ed5981fa63b2e544e30ae7302b", "filename": "gcc/config/xtensa/lib2funcs.S", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f0ee69424f02f4c46bc13e6a3c77248b4d04bbe/gcc%2Fconfig%2Fxtensa%2Flib2funcs.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f0ee69424f02f4c46bc13e6a3c77248b4d04bbe/gcc%2Fconfig%2Fxtensa%2Flib2funcs.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Flib2funcs.S?ref=7f0ee69424f02f4c46bc13e6a3c77248b4d04bbe", "patch": "@@ -1,5 +1,5 @@\n /* Assembly functions for libgcc2.\n-   Copyright (C) 2001, 2006 Free Software Foundation, Inc.\n+   Copyright (C) 2001, 2006, 2007 Free Software Foundation, Inc.\n    Contributed by Bob Wilson (bwilson@tensilica.com) at Tensilica.\n \n This file is part of GCC.\n@@ -151,6 +151,7 @@ __xtensa_nonlocal_goto:\n    make sure that the modified instructions are loaded into the instruction\n    fetch buffer.  */\n \n+/* Use the maximum trampoline size.  Flushing a bit extra is OK.  */\n #define TRAMPOLINE_SIZE 60\n \n \t.text"}, {"sha": "82d7262922de6abccb9ed14e6f89b428f396fc50", "filename": "gcc/config/xtensa/xtensa-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f0ee69424f02f4c46bc13e6a3c77248b4d04bbe/gcc%2Fconfig%2Fxtensa%2Fxtensa-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f0ee69424f02f4c46bc13e6a3c77248b4d04bbe/gcc%2Fconfig%2Fxtensa%2Fxtensa-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa-protos.h?ref=7f0ee69424f02f4c46bc13e6a3c77248b4d04bbe", "patch": "@@ -69,6 +69,7 @@ extern enum reg_class xtensa_preferred_reload_class (rtx, enum reg_class, int);\n extern enum reg_class xtensa_secondary_reload_class (enum reg_class,\n \t\t\t\t\t\t     enum machine_mode, rtx,\n \t\t\t\t\t\t     int);\n+extern void xtensa_initialize_trampoline (rtx, rtx, rtx);\n #endif /* RTX_CODE */\n \n #ifdef TREE_CODE\n@@ -85,5 +86,6 @@ extern long compute_frame_size (int);\n extern int xtensa_frame_pointer_required (void);\n extern void xtensa_expand_prologue (void);\n extern void order_regs_for_local_alloc (void);\n+extern void xtensa_trampoline_template (FILE *);\n \n #endif /* !__XTENSA_PROTOS_H__ */"}, {"sha": "62eadbb97982a14a62d2761cf6c5942fec1ee935", "filename": "gcc/config/xtensa/xtensa.c", "status": "modified", "additions": 114, "deletions": 4, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f0ee69424f02f4c46bc13e6a3c77248b4d04bbe/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f0ee69424f02f4c46bc13e6a3c77248b4d04bbe/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.c?ref=7f0ee69424f02f4c46bc13e6a3c77248b4d04bbe", "patch": "@@ -2301,6 +2301,10 @@ xtensa_frame_pointer_required (void)\n }\n \n \n+/* minimum frame = reg save area (4 words) plus static chain (1 word)\n+   and the total number of words must be a multiple of 128 bits.  */\n+#define MIN_FRAME_SIZE (8 * UNITS_PER_WORD)\n+\n void\n xtensa_expand_prologue (void)\n {\n@@ -2379,7 +2383,7 @@ xtensa_function_epilogue (FILE *file ATTRIBUTE_UNUSED,\n rtx\n xtensa_return_addr (int count, rtx frame)\n {\n-  rtx result, retaddr;\n+  rtx result, retaddr, curaddr, label;\n \n   if (count == -1)\n     retaddr = gen_rtx_REG (Pmode, A0_REG);\n@@ -2393,10 +2397,25 @@ xtensa_return_addr (int count, rtx frame)\n \n   /* The 2 most-significant bits of the return address on Xtensa hold\n      the register window size.  To get the real return address, these\n-     bits must be replaced with the high bits from the current PC.  */\n-\n+     bits must be replaced with the high bits from some address in the\n+     code.  */\n+\n+  /* Get the 2 high bits of a local label in the code.  */\n+  curaddr = gen_reg_rtx (Pmode);\n+  label = gen_label_rtx ();\n+  emit_label (label);\n+  LABEL_PRESERVE_P (label) = 1;\n+  emit_move_insn (curaddr, gen_rtx_LABEL_REF (Pmode, label));\n+  emit_insn (gen_lshrsi3 (curaddr, curaddr, GEN_INT (30)));\n+  emit_insn (gen_ashlsi3 (curaddr, curaddr, GEN_INT (30)));\n+\n+  /* Clear the 2 high bits of the return address.  */\n   result = gen_reg_rtx (Pmode);\n-  emit_insn (gen_fix_return_addr (result, retaddr));\n+  emit_insn (gen_ashlsi3 (result, retaddr, GEN_INT (2)));\n+  emit_insn (gen_lshrsi3 (result, result, GEN_INT (2)));\n+\n+  /* Combine them to get the result.  */\n+  emit_insn (gen_iorsi3 (result, result, curaddr));\n   return result;\n }\n \n@@ -3126,4 +3145,95 @@ xtensa_return_in_memory (const_tree type, const_tree fntype ATTRIBUTE_UNUSED)\n \t  > 4 * UNITS_PER_WORD);\n }\n \n+\n+/* TRAMPOLINE_TEMPLATE: For Xtensa, the trampoline must perform an ENTRY\n+   instruction with a minimal stack frame in order to get some free\n+   registers.  Once the actual call target is known, the proper stack frame\n+   size is extracted from the ENTRY instruction at the target and the\n+   current frame is adjusted to match.  The trampoline then transfers\n+   control to the instruction following the ENTRY at the target.  Note:\n+   this assumes that the target begins with an ENTRY instruction.  */\n+\n+void\n+xtensa_trampoline_template (FILE *stream)\n+{\n+  bool use_call0 = (TARGET_CONST16 || TARGET_ABSOLUTE_LITERALS);\n+\n+  fprintf (stream, \"\\t.begin no-transform\\n\");\n+  fprintf (stream, \"\\tentry\\tsp, %d\\n\", MIN_FRAME_SIZE);\n+\n+  if (use_call0)\n+    {\n+      /* Save the return address.  */\n+      fprintf (stream, \"\\tmov\\ta10, a0\\n\");\n+\n+      /* Use a CALL0 instruction to skip past the constants and in the\n+\t process get the PC into A0.  This allows PC-relative access to\n+\t the constants without relying on L32R.  */\n+      fprintf (stream, \"\\tcall0\\t.Lskipconsts\\n\");\n+    }\n+  else\n+    fprintf (stream, \"\\tj\\t.Lskipconsts\\n\");\n+\n+  fprintf (stream, \"\\t.align\\t4\\n\");\n+  fprintf (stream, \".Lchainval:%s0\\n\", integer_asm_op (4, TRUE));\n+  fprintf (stream, \".Lfnaddr:%s0\\n\", integer_asm_op (4, TRUE));\n+  fprintf (stream, \".Lskipconsts:\\n\");\n+\n+  /* Load the static chain and function address from the trampoline.  */\n+  if (use_call0)\n+    {\n+      fprintf (stream, \"\\taddi\\ta0, a0, 3\\n\");\n+      fprintf (stream, \"\\tl32i\\ta9, a0, 0\\n\");\n+      fprintf (stream, \"\\tl32i\\ta8, a0, 4\\n\");\n+    }\n+  else\n+    {\n+      fprintf (stream, \"\\tl32r\\ta9, .Lchainval\\n\");\n+      fprintf (stream, \"\\tl32r\\ta8, .Lfnaddr\\n\");\n+    }\n+\n+  /* Store the static chain.  */\n+  fprintf (stream, \"\\ts32i\\ta9, sp, %d\\n\", MIN_FRAME_SIZE - 20);\n+\n+  /* Set the proper stack pointer value.  */\n+  fprintf (stream, \"\\tl32i\\ta9, a8, 0\\n\");\n+  fprintf (stream, \"\\textui\\ta9, a9, %d, 12\\n\",\n+\t   TARGET_BIG_ENDIAN ? 8 : 12);\n+  fprintf (stream, \"\\tslli\\ta9, a9, 3\\n\");\n+  fprintf (stream, \"\\taddi\\ta9, a9, %d\\n\", -MIN_FRAME_SIZE);\n+  fprintf (stream, \"\\tsub\\ta9, sp, a9\\n\");\n+  fprintf (stream, \"\\tmovsp\\tsp, a9\\n\");\n+\n+  if (use_call0)\n+    /* Restore the return address.  */\n+    fprintf (stream, \"\\tmov\\ta0, a10\\n\");\n+\n+  /* Jump to the instruction following the ENTRY.  */\n+  fprintf (stream, \"\\taddi\\ta8, a8, 3\\n\");\n+  fprintf (stream, \"\\tjx\\ta8\\n\");\n+\n+  /* Pad size to a multiple of TRAMPOLINE_ALIGNMENT.  */\n+  if (use_call0)\n+    fprintf (stream, \"\\t.byte\\t0\\n\");\n+  else\n+    fprintf (stream, \"\\tnop\\n\");\n+\n+  fprintf (stream, \"\\t.end no-transform\\n\");\n+}\n+\n+\n+void\n+xtensa_initialize_trampoline (rtx addr, rtx func, rtx chain)\n+{\n+  bool use_call0 = (TARGET_CONST16 || TARGET_ABSOLUTE_LITERALS);\n+  int chain_off = use_call0 ? 12 : 8;\n+  int func_off = use_call0 ? 16 : 12;\n+  emit_move_insn (gen_rtx_MEM (SImode, plus_constant (addr, chain_off)), chain);\n+  emit_move_insn (gen_rtx_MEM (SImode, plus_constant (addr, func_off)), func);\n+  emit_library_call (gen_rtx_SYMBOL_REF (Pmode, \"__xtensa_sync_caches\"),\n+\t\t     0, VOIDmode, 1, addr, Pmode);\n+}\n+\n+\n #include \"gt-xtensa.h\""}, {"sha": "7e0e9400aadbd514ecc87434d785afbb15071ede", "filename": "gcc/config/xtensa/xtensa.h", "status": "modified", "additions": 6, "deletions": 69, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f0ee69424f02f4c46bc13e6a3c77248b4d04bbe/gcc%2Fconfig%2Fxtensa%2Fxtensa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f0ee69424f02f4c46bc13e6a3c77248b4d04bbe/gcc%2Fconfig%2Fxtensa%2Fxtensa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.h?ref=7f0ee69424f02f4c46bc13e6a3c77248b4d04bbe", "patch": "@@ -72,6 +72,7 @@ extern unsigned xtensa_current_frame_size;\n #define TARGET_ADDX\t\tXCHAL_HAVE_ADDX\n #define TARGET_RELEASE_SYNC\tXCHAL_HAVE_RELEASE_SYNC\n #define TARGET_S32C1I\t\tXCHAL_HAVE_S32C1I\n+#define TARGET_ABSOLUTE_LITERALS XSHAL_USE_ABSOLUTE_LITERALS\n \n #define TARGET_DEFAULT (\t\t\t\t\t\t\\\n   (XCHAL_HAVE_L32R\t? 0 : MASK_CONST16))\n@@ -704,83 +705,19 @@ typedef struct xtensa_args\n /* Stack pointer value doesn't matter at exit.  */\n #define EXIT_IGNORE_STACK 1\n \n-/* A C statement to output, on the stream FILE, assembler code for a\n-   block of data that contains the constant parts of a trampoline. \n-   This code should not include a label--the label is taken care of\n-   automatically.\n-\n-   For Xtensa, the trampoline must perform an entry instruction with a\n-   minimal stack frame in order to get some free registers.  Once the\n-   actual call target is known, the proper stack frame size is extracted\n-   from the entry instruction at the target and the current frame is\n-   adjusted to match.  The trampoline then transfers control to the\n-   instruction following the entry at the target.  Note: this assumes\n-   that the target begins with an entry instruction.  */\n-\n-/* minimum frame = reg save area (4 words) plus static chain (1 word)\n-   and the total number of words must be a multiple of 128 bits */\n-#define MIN_FRAME_SIZE (8 * UNITS_PER_WORD)\n-\n-#define TRAMPOLINE_TEMPLATE(STREAM)\t\t\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\t\\\n-    fprintf (STREAM, \"\\t.begin no-transform\\n\");\t\t\t\\\n-    fprintf (STREAM, \"\\tentry\\tsp, %d\\n\", MIN_FRAME_SIZE);\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    /* save the return address */\t\t\t\t\t\\\n-    fprintf (STREAM, \"\\tmov\\ta10, a0\\n\");\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    /* Use a CALL0 instruction to skip past the constants and in the\t\\\n-       process get the PC into A0.  This allows PC-relative access to\t\\\n-       the constants without relying on L32R, which may not always be\t\\\n-       available.  */\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    fprintf (STREAM, \"\\tcall0\\t.Lskipconsts\\n\");\t\t\t\\\n-    fprintf (STREAM, \"\\t.align\\t4\\n\");\t\t\t\t\t\\\n-    fprintf (STREAM, \".Lchainval:%s0\\n\", integer_asm_op (4, TRUE));\t\\\n-    fprintf (STREAM, \".Lfnaddr:%s0\\n\", integer_asm_op (4, TRUE));\t\\\n-    fprintf (STREAM, \".Lskipconsts:\\n\");\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    /* store the static chain */\t\t\t\t\t\\\n-    fprintf (STREAM, \"\\taddi\\ta0, a0, 3\\n\");\t\t\t\t\\\n-    fprintf (STREAM, \"\\tl32i\\ta8, a0, 0\\n\");\t\t\t\t\\\n-    fprintf (STREAM, \"\\ts32i\\ta8, sp, %d\\n\", MIN_FRAME_SIZE - 20);\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    /* set the proper stack pointer value */\t\t\t\t\\\n-    fprintf (STREAM, \"\\tl32i\\ta8, a0, 4\\n\");\t\t\t\t\\\n-    fprintf (STREAM, \"\\tl32i\\ta9, a8, 0\\n\");\t\t\t\t\\\n-    fprintf (STREAM, \"\\textui\\ta9, a9, %d, 12\\n\",\t\t\t\\\n-\t     TARGET_BIG_ENDIAN ? 8 : 12);\t\t\t\t\\\n-    fprintf (STREAM, \"\\tslli\\ta9, a9, 3\\n\");\t\t\t\t\\\n-    fprintf (STREAM, \"\\taddi\\ta9, a9, %d\\n\", -MIN_FRAME_SIZE);\t\t\\\n-    fprintf (STREAM, \"\\tsub\\ta9, sp, a9\\n\");\t\t\t\t\\\n-    fprintf (STREAM, \"\\tmovsp\\tsp, a9\\n\");\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    /* restore the return address */\t\t\t\t\t\\\n-    fprintf (STREAM, \"\\tmov\\ta0, a10\\n\");\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-    /* jump to the instruction following the entry */\t\t\t\\\n-    fprintf (STREAM, \"\\taddi\\ta8, a8, 3\\n\");\t\t\t\t\\\n-    fprintf (STREAM, \"\\tjx\\ta8\\n\");\t\t\t\t\t\\\n-    fprintf (STREAM, \"\\t.byte\\t0\\n\");\t\t\t\t\t\\\n-    fprintf (STREAM, \"\\t.end no-transform\\n\");\t\t\t\t\\\n-  } while (0)\n+#define TRAMPOLINE_TEMPLATE(STREAM) xtensa_trampoline_template (STREAM)\n \n /* Size in bytes of the trampoline, as an integer.  Make sure this is\n    a multiple of TRAMPOLINE_ALIGNMENT to avoid -Wpadded warnings.  */\n-#define TRAMPOLINE_SIZE 60\n+#define TRAMPOLINE_SIZE (TARGET_CONST16 || TARGET_ABSOLUTE_LITERALS ? 60 : 52)\n \n /* Alignment required for trampolines, in bits.  */\n-#define TRAMPOLINE_ALIGNMENT (32)\n+#define TRAMPOLINE_ALIGNMENT 32\n \n /* A C statement to initialize the variable parts of a trampoline.  */\n #define INITIALIZE_TRAMPOLINE(ADDR, FUNC, CHAIN)\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\t\\\n-    rtx addr = ADDR;\t\t\t\t\t\t\t\\\n-    emit_move_insn (gen_rtx_MEM (SImode, plus_constant (addr, 12)), CHAIN); \\\n-    emit_move_insn (gen_rtx_MEM (SImode, plus_constant (addr, 16)), FUNC); \\\n-    emit_library_call (gen_rtx_SYMBOL_REF (Pmode, \"__xtensa_sync_caches\"), \\\n-\t\t       0, VOIDmode, 1, addr, Pmode);\t\t\t\\\n-  } while (0)\n+  xtensa_initialize_trampoline (ADDR, FUNC, CHAIN)\n+\n \n /* If defined, a C expression that produces the machine-specific code\n    to setup the stack so that arbitrary frames can be accessed."}, {"sha": "3774a61131a8e4465ed11f76420577894bfcc89d", "filename": "gcc/config/xtensa/xtensa.md", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f0ee69424f02f4c46bc13e6a3c77248b4d04bbe/gcc%2Fconfig%2Fxtensa%2Fxtensa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f0ee69424f02f4c46bc13e6a3c77248b4d04bbe/gcc%2Fconfig%2Fxtensa%2Fxtensa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.md?ref=7f0ee69424f02f4c46bc13e6a3c77248b4d04bbe", "patch": "@@ -1666,21 +1666,6 @@\n    (set_attr \"mode\"\t\"none\")\n    (set_attr \"length\"\t\"0\")])\n \n-;; The fix_return_addr pattern sets the high 2 bits of an address in a\n-;; register to match the high bits of the current PC.\n-(define_insn \"fix_return_addr\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=a\")\n-\t(unspec:SI [(match_operand:SI 1 \"register_operand\" \"r\")]\n-\t\t   UNSPEC_RET_ADDR))\n-   (clobber (match_scratch:SI 2 \"=r\"))\n-   (clobber (match_scratch:SI 3 \"=r\"))]\n-  \"\"\n-  \"mov\\t%2, a0\\;call0\\t0f\\;.align\\t4\\;0:\\;mov\\t%3, a0\\;mov\\ta0, %2\\;\\\n-srli\\t%3, %3, 30\\;slli\\t%0, %1, 2\\;ssai\\t2\\;src\\t%0, %3, %0\"\n-  [(set_attr \"type\"\t\"multi\")\n-   (set_attr \"mode\"\t\"SI\")\n-   (set_attr \"length\"\t\"24\")])\n-\n \f\n ;; Instructions for the Xtensa \"boolean\" option.\n "}]}