{"sha": "62efd1c481dfd3b9cd69e64a9d6053dd8fcc3382", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjJlZmQxYzQ4MWRmZDNiOWNkNjllNjRhOWQ2MDUzZGQ4ZmNjMzM4Mg==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2020-05-17T13:03:20Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2020-06-01T07:50:48Z"}, "message": "Move array bounds checking into its own file.\n\ngcc/\n\t* Makefile.in (gimple-array-bounds.o): New.\n\t* tree-vrp.c: Move array bounds code...\n\t* gimple-array-bounds.cc: ...here...\n\t* gimple-array-bounds.h: ...and here.", "tree": {"sha": "3a3b0b28161e8c451d24745cbede46c37d7d9d8b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3a3b0b28161e8c451d24745cbede46c37d7d9d8b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/62efd1c481dfd3b9cd69e64a9d6053dd8fcc3382", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62efd1c481dfd3b9cd69e64a9d6053dd8fcc3382", "html_url": "https://github.com/Rust-GCC/gccrs/commit/62efd1c481dfd3b9cd69e64a9d6053dd8fcc3382", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62efd1c481dfd3b9cd69e64a9d6053dd8fcc3382/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4a5e9d0089cc59523a3830b35be5e9849e634130", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a5e9d0089cc59523a3830b35be5e9849e634130", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a5e9d0089cc59523a3830b35be5e9849e634130"}], "stats": {"total": 1426, "additions": 745, "deletions": 681}, "files": [{"sha": "aab1dbba57b48f835d95ff0043b4f6625f210f37", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62efd1c481dfd3b9cd69e64a9d6053dd8fcc3382/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62efd1c481dfd3b9cd69e64a9d6053dd8fcc3382/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=62efd1c481dfd3b9cd69e64a9d6053dd8fcc3382", "patch": "@@ -1352,6 +1352,7 @@ OBJS = \\\n \tggc-common.o \\\n \tggc-tests.o \\\n \tgimple.o \\\n+\tgimple-array-bounds.o \\\n \tgimple-builder.o \\\n \tgimple-expr.o \\\n \tgimple-iterator.o \\"}, {"sha": "352d0745178f97502723469746322f548bef5407", "filename": "gcc/gimple-array-bounds.cc", "status": "added", "additions": 700, "deletions": 0, "changes": 700, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62efd1c481dfd3b9cd69e64a9d6053dd8fcc3382/gcc%2Fgimple-array-bounds.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62efd1c481dfd3b9cd69e64a9d6053dd8fcc3382/gcc%2Fgimple-array-bounds.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-array-bounds.cc?ref=62efd1c481dfd3b9cd69e64a9d6053dd8fcc3382", "patch": "@@ -0,0 +1,700 @@\n+/* Array bounds checking.\n+   Copyright (C) 2005-2020 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"backend.h\"\n+#include \"tree.h\"\n+#include \"gimple.h\"\n+#include \"ssa.h\"\n+#include \"gimple-array-bounds.h\"\n+#include \"gimple-iterator.h\"\n+#include \"gimple-walk.h\"\n+#include \"tree-dfa.h\"\n+#include \"fold-const.h\"\n+#include \"diagnostic-core.h\"\n+#include \"intl.h\"\n+#include \"tree-vrp.h\"\n+#include \"alloc-pool.h\"\n+#include \"vr-values.h\"\n+#include \"domwalk.h\"\n+#include \"tree-cfg.h\"\n+\n+// This purposely returns a value_range, not a value_range_equiv, to\n+// break the dependency on equivalences for this pass.\n+\n+const value_range *\n+array_bounds_checker::get_value_range (const_tree op)\n+{\n+  return ranges->get_value_range (op);\n+}\n+\n+/* Checks one ARRAY_REF in REF, located at LOCUS. Ignores flexible\n+   arrays and \"struct\" hacks. If VRP can determine that the array\n+   subscript is a constant, check if it is outside valid range.  If\n+   the array subscript is a RANGE, warn if it is non-overlapping with\n+   valid range.  IGNORE_OFF_BY_ONE is true if the ARRAY_REF is inside\n+   a ADDR_EXPR.  Returns true if a warning has been issued.  */\n+\n+bool\n+array_bounds_checker::check_array_ref (location_t location, tree ref,\n+\t\t\t\t       bool ignore_off_by_one)\n+{\n+  if (TREE_NO_WARNING (ref))\n+    return false;\n+\n+  tree low_sub = TREE_OPERAND (ref, 1);\n+  tree up_sub = low_sub;\n+  tree up_bound = array_ref_up_bound (ref);\n+\n+  /* Referenced decl if one can be determined.  */\n+  tree decl = NULL_TREE;\n+\n+  /* Set for accesses to interior zero-length arrays.  */\n+  bool interior_zero_len = false;\n+\n+  tree up_bound_p1;\n+\n+  if (!up_bound\n+      || TREE_CODE (up_bound) != INTEGER_CST\n+      || (warn_array_bounds < 2\n+\t  && array_at_struct_end_p (ref)))\n+    {\n+      /* Accesses to trailing arrays via pointers may access storage\n+\t beyond the types array bounds.  For such arrays, or for flexible\n+\t array members, as well as for other arrays of an unknown size,\n+\t replace the upper bound with a more permissive one that assumes\n+\t the size of the largest object is PTRDIFF_MAX.  */\n+      tree eltsize = array_ref_element_size (ref);\n+\n+      if (TREE_CODE (eltsize) != INTEGER_CST\n+\t  || integer_zerop (eltsize))\n+\t{\n+\t  up_bound = NULL_TREE;\n+\t  up_bound_p1 = NULL_TREE;\n+\t}\n+      else\n+\t{\n+\t  tree ptrdiff_max = TYPE_MAX_VALUE (ptrdiff_type_node);\n+\t  tree maxbound = ptrdiff_max;\n+\t  tree arg = TREE_OPERAND (ref, 0);\n+\n+\t  const bool compref = TREE_CODE (arg) == COMPONENT_REF;\n+\t  if (compref)\n+\t    {\n+\t      /* Try to determine the size of the trailing array from\n+\t\t its initializer (if it has one).  */\n+\t      if (tree refsize = component_ref_size (arg, &interior_zero_len))\n+\t\tif (TREE_CODE (refsize) == INTEGER_CST)\n+\t\t  maxbound = refsize;\n+\t    }\n+\n+\t  if (maxbound == ptrdiff_max)\n+\t    {\n+\t      /* Try to determine the size of the base object.  Avoid\n+\t\t COMPONENT_REF already tried above.  Using its DECL_SIZE\n+\t\t size wouldn't necessarily be correct if the reference is\n+\t\t to its flexible array member initialized in a different\n+\t\t translation unit.  */\n+\t      poly_int64 off;\n+\t      if (tree base = get_addr_base_and_unit_offset (arg, &off))\n+\t\t{\n+\t\t  if (!compref && DECL_P (base))\n+\t\t    if (tree basesize = DECL_SIZE_UNIT (base))\n+\t\t      if (TREE_CODE (basesize) == INTEGER_CST)\n+\t\t\t{\n+\t\t\t  maxbound = basesize;\n+\t\t\t  decl = base;\n+\t\t\t}\n+\n+\t\t  if (known_gt (off, 0))\n+\t\t    maxbound = wide_int_to_tree (sizetype,\n+\t\t\t\t\t\t wi::sub (wi::to_wide (maxbound),\n+\t\t\t\t\t\t\t  off));\n+\t\t}\n+\t    }\n+\t  else\n+\t    maxbound = fold_convert (sizetype, maxbound);\n+\n+\t  up_bound_p1 = int_const_binop (TRUNC_DIV_EXPR, maxbound, eltsize);\n+\n+\t  if (up_bound_p1 != NULL_TREE)\n+\t    up_bound = int_const_binop (MINUS_EXPR, up_bound_p1,\n+\t\t\t\t\tbuild_int_cst (ptrdiff_type_node, 1));\n+\t  else\n+\t    up_bound = NULL_TREE;\n+\t}\n+    }\n+  else\n+    up_bound_p1 = int_const_binop (PLUS_EXPR, up_bound,\n+\t\t\t\t   build_int_cst (TREE_TYPE (up_bound), 1));\n+\n+  tree low_bound = array_ref_low_bound (ref);\n+\n+  tree artype = TREE_TYPE (TREE_OPERAND (ref, 0));\n+\n+  bool warned = false;\n+\n+  /* Empty array.  */\n+  if (up_bound && tree_int_cst_equal (low_bound, up_bound_p1))\n+    warned = warning_at (location, OPT_Warray_bounds,\n+\t\t\t \"array subscript %E is outside array bounds of %qT\",\n+\t\t\t low_sub, artype);\n+\n+  const value_range *vr = NULL;\n+  if (TREE_CODE (low_sub) == SSA_NAME)\n+    {\n+      vr = get_value_range (low_sub);\n+      if (!vr->undefined_p () && !vr->varying_p ())\n+\t{\n+\t  low_sub = vr->kind () == VR_RANGE ? vr->max () : vr->min ();\n+\t  up_sub = vr->kind () == VR_RANGE ? vr->min () : vr->max ();\n+\t}\n+    }\n+\n+  if (warned)\n+    ; /* Do nothing.  */\n+  else if (vr && vr->kind () == VR_ANTI_RANGE)\n+    {\n+      if (up_bound\n+\t  && TREE_CODE (up_sub) == INTEGER_CST\n+\t  && (ignore_off_by_one\n+\t      ? tree_int_cst_lt (up_bound, up_sub)\n+\t      : tree_int_cst_le (up_bound, up_sub))\n+\t  && TREE_CODE (low_sub) == INTEGER_CST\n+\t  && tree_int_cst_le (low_sub, low_bound))\n+\twarned = warning_at (location, OPT_Warray_bounds,\n+\t\t\t     \"array subscript [%E, %E] is outside \"\n+\t\t\t     \"array bounds of %qT\",\n+\t\t\t     low_sub, up_sub, artype);\n+    }\n+  else if (up_bound\n+\t   && TREE_CODE (up_sub) == INTEGER_CST\n+\t   && (ignore_off_by_one\n+\t       ? !tree_int_cst_le (up_sub, up_bound_p1)\n+\t       : !tree_int_cst_le (up_sub, up_bound)))\n+    warned = warning_at (location, OPT_Warray_bounds,\n+\t\t\t \"array subscript %E is above array bounds of %qT\",\n+\t\t\t up_sub, artype);\n+  else if (TREE_CODE (low_sub) == INTEGER_CST\n+\t   && tree_int_cst_lt (low_sub, low_bound))\n+    warned = warning_at (location, OPT_Warray_bounds,\n+\t\t\t \"array subscript %E is below array bounds of %qT\",\n+\t\t\t low_sub, artype);\n+\n+  if (!warned && interior_zero_len)\n+    warned = warning_at (location, OPT_Wzero_length_bounds,\n+\t\t\t (TREE_CODE (low_sub) == INTEGER_CST\n+\t\t\t  ? G_(\"array subscript %E is outside the bounds \"\n+\t\t\t       \"of an interior zero-length array %qT\")\n+\t\t\t  : G_(\"array subscript %qE is outside the bounds \"\n+\t\t\t       \"of an interior zero-length array %qT\")),\n+\t\t\t low_sub, artype);\n+\n+  if (warned)\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  fprintf (dump_file, \"Array bound warning for \");\n+\t  dump_generic_expr (MSG_NOTE, TDF_SLIM, ref);\n+\t  fprintf (dump_file, \"\\n\");\n+\t}\n+\n+      ref = decl ? decl : TREE_OPERAND (ref, 0);\n+\n+      tree rec = NULL_TREE;\n+      if (TREE_CODE (ref) == COMPONENT_REF)\n+\t{\n+\t  /* For a reference to a member of a struct object also mention\n+\t     the object if it's known.  It may be defined in a different\n+\t     function than the out-of-bounds access.  */\n+\t  rec = TREE_OPERAND (ref, 0);\n+\t  if (!VAR_P (rec))\n+\t    rec = NULL_TREE;\n+\t  ref = TREE_OPERAND (ref, 1);\n+\t}\n+\n+      if (DECL_P (ref))\n+\tinform (DECL_SOURCE_LOCATION (ref), \"while referencing %qD\", ref);\n+      if (rec && DECL_P (rec))\n+\tinform (DECL_SOURCE_LOCATION (rec), \"defined here %qD\", rec);\n+\n+      TREE_NO_WARNING (ref) = 1;\n+    }\n+\n+  return warned;\n+}\n+\n+/* Checks one MEM_REF in REF, located at LOCATION, for out-of-bounds\n+   references to string constants.  If VRP can determine that the array\n+   subscript is a constant, check if it is outside valid range.\n+   If the array subscript is a RANGE, warn if it is non-overlapping\n+   with valid range.\n+   IGNORE_OFF_BY_ONE is true if the MEM_REF is inside an ADDR_EXPR\n+   (used to allow one-past-the-end indices for code that takes\n+   the address of the just-past-the-end element of an array).\n+   Returns true if a warning has been issued.  */\n+\n+bool\n+array_bounds_checker::check_mem_ref (location_t location, tree ref,\n+\t\t\t\t     bool ignore_off_by_one)\n+{\n+  if (TREE_NO_WARNING (ref))\n+    return false;\n+\n+  tree arg = TREE_OPERAND (ref, 0);\n+  /* The constant and variable offset of the reference.  */\n+  tree cstoff = TREE_OPERAND (ref, 1);\n+  tree varoff = NULL_TREE;\n+\n+  const offset_int maxobjsize = tree_to_shwi (max_object_size ());\n+\n+  /* The array or string constant bounds in bytes.  Initially set\n+     to [-MAXOBJSIZE - 1, MAXOBJSIZE]  until a tighter bound is\n+     determined.  */\n+  offset_int arrbounds[2] = { -maxobjsize - 1, maxobjsize };\n+\n+  /* The minimum and maximum intermediate offset.  For a reference\n+     to be valid, not only does the final offset/subscript must be\n+     in bounds but all intermediate offsets should be as well.\n+     GCC may be able to deal gracefully with such out-of-bounds\n+     offsets so the checking is only enbaled at -Warray-bounds=2\n+     where it may help detect bugs in uses of the intermediate\n+     offsets that could otherwise not be detectable.  */\n+  offset_int ioff = wi::to_offset (fold_convert (ptrdiff_type_node, cstoff));\n+  offset_int extrema[2] = { 0, wi::abs (ioff) };\n+\n+  /* The range of the byte offset into the reference.  */\n+  offset_int offrange[2] = { 0, 0 };\n+\n+  const value_range *vr = NULL;\n+\n+  /* Determine the offsets and increment OFFRANGE for the bounds of each.\n+     The loop computes the range of the final offset for expressions such\n+     as (A + i0 + ... + iN)[CSTOFF] where i0 through iN are SSA_NAMEs in\n+     some range.  */\n+  const unsigned limit = param_ssa_name_def_chain_limit;\n+  for (unsigned n = 0; TREE_CODE (arg) == SSA_NAME && n < limit; ++n)\n+    {\n+      gimple *def = SSA_NAME_DEF_STMT (arg);\n+      if (!is_gimple_assign (def))\n+\tbreak;\n+\n+      tree_code code = gimple_assign_rhs_code (def);\n+      if (code == POINTER_PLUS_EXPR)\n+\t{\n+\t  arg = gimple_assign_rhs1 (def);\n+\t  varoff = gimple_assign_rhs2 (def);\n+\t}\n+      else if (code == ASSERT_EXPR)\n+\t{\n+\t  arg = TREE_OPERAND (gimple_assign_rhs1 (def), 0);\n+\t  continue;\n+\t}\n+      else\n+\treturn false;\n+\n+      /* VAROFF should always be a SSA_NAME here (and not even\n+\t INTEGER_CST) but there's no point in taking chances.  */\n+      if (TREE_CODE (varoff) != SSA_NAME)\n+\tbreak;\n+\n+      vr = get_value_range (varoff);\n+      if (!vr || vr->undefined_p () || vr->varying_p ())\n+\tbreak;\n+\n+      if (!vr->constant_p ())\n+\tbreak;\n+\n+      if (vr->kind () == VR_RANGE)\n+\t{\n+\t  offset_int min\n+\t    = wi::to_offset (fold_convert (ptrdiff_type_node, vr->min ()));\n+\t  offset_int max\n+\t    = wi::to_offset (fold_convert (ptrdiff_type_node, vr->max ()));\n+\t  if (min < max)\n+\t    {\n+\t      offrange[0] += min;\n+\t      offrange[1] += max;\n+\t    }\n+\t  else\n+\t    {\n+\t      /* When MIN >= MAX, the offset is effectively in a union\n+\t\t of two ranges: [-MAXOBJSIZE -1, MAX] and [MIN, MAXOBJSIZE].\n+\t\t Since there is no way to represent such a range across\n+\t\t additions, conservatively add [-MAXOBJSIZE -1, MAXOBJSIZE]\n+\t\t to OFFRANGE.  */\n+\t      offrange[0] += arrbounds[0];\n+\t      offrange[1] += arrbounds[1];\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  /* For an anti-range, analogously to the above, conservatively\n+\t     add [-MAXOBJSIZE -1, MAXOBJSIZE] to OFFRANGE.  */\n+\t  offrange[0] += arrbounds[0];\n+\t  offrange[1] += arrbounds[1];\n+\t}\n+\n+      /* Keep track of the minimum and maximum offset.  */\n+      if (offrange[1] < 0 && offrange[1] < extrema[0])\n+\textrema[0] = offrange[1];\n+      if (offrange[0] > 0 && offrange[0] > extrema[1])\n+\textrema[1] = offrange[0];\n+\n+      if (offrange[0] < arrbounds[0])\n+\toffrange[0] = arrbounds[0];\n+\n+      if (offrange[1] > arrbounds[1])\n+\toffrange[1] = arrbounds[1];\n+    }\n+\n+  if (TREE_CODE (arg) == ADDR_EXPR)\n+    {\n+      arg = TREE_OPERAND (arg, 0);\n+      if (TREE_CODE (arg) != STRING_CST\n+\t  && TREE_CODE (arg) != PARM_DECL\n+\t  && TREE_CODE (arg) != VAR_DECL)\n+\treturn false;\n+    }\n+  else\n+    return false;\n+\n+  /* The type of the object being referred to.  It can be an array,\n+     string literal, or a non-array type when the MEM_REF represents\n+     a reference/subscript via a pointer to an object that is not\n+     an element of an array.  Incomplete types are excluded as well\n+     because their size is not known.  */\n+  tree reftype = TREE_TYPE (arg);\n+  if (POINTER_TYPE_P (reftype)\n+      || !COMPLETE_TYPE_P (reftype)\n+      || TREE_CODE (TYPE_SIZE_UNIT (reftype)) != INTEGER_CST)\n+    return false;\n+\n+  /* Except in declared objects, references to trailing array members\n+     of structs and union objects are excluded because MEM_REF doesn't\n+     make it possible to identify the member where the reference\n+     originated.  */\n+  if (RECORD_OR_UNION_TYPE_P (reftype)\n+      && (!VAR_P (arg)\n+\t  || (DECL_EXTERNAL (arg) && array_at_struct_end_p (ref))))\n+    return false;\n+\n+  arrbounds[0] = 0;\n+\n+  offset_int eltsize;\n+  if (TREE_CODE (reftype) == ARRAY_TYPE)\n+    {\n+      eltsize = wi::to_offset (TYPE_SIZE_UNIT (TREE_TYPE (reftype)));\n+      if (tree dom = TYPE_DOMAIN (reftype))\n+\t{\n+\t  tree bnds[] = { TYPE_MIN_VALUE (dom), TYPE_MAX_VALUE (dom) };\n+\t  if (TREE_CODE (arg) == COMPONENT_REF)\n+\t    {\n+\t      offset_int size = maxobjsize;\n+\t      if (tree fldsize = component_ref_size (arg))\n+\t\tsize = wi::to_offset (fldsize);\n+\t      arrbounds[1] = wi::lrshift (size, wi::floor_log2 (eltsize));\n+\t    }\n+\t  else if (array_at_struct_end_p (arg) || !bnds[0] || !bnds[1])\n+\t    arrbounds[1] = wi::lrshift (maxobjsize, wi::floor_log2 (eltsize));\n+\t  else\n+\t    arrbounds[1] = (wi::to_offset (bnds[1]) - wi::to_offset (bnds[0])\n+\t\t\t    + 1) * eltsize;\n+\t}\n+      else\n+\tarrbounds[1] = wi::lrshift (maxobjsize, wi::floor_log2 (eltsize));\n+\n+      /* Determine a tighter bound of the non-array element type.  */\n+      tree eltype = TREE_TYPE (reftype);\n+      while (TREE_CODE (eltype) == ARRAY_TYPE)\n+\teltype = TREE_TYPE (eltype);\n+      eltsize = wi::to_offset (TYPE_SIZE_UNIT (eltype));\n+    }\n+  else\n+    {\n+      eltsize = 1;\n+      tree size = TYPE_SIZE_UNIT (reftype);\n+      if (VAR_P (arg))\n+\tif (tree initsize = DECL_SIZE_UNIT (arg))\n+\t  if (tree_int_cst_lt (size, initsize))\n+\t    size = initsize;\n+\n+      arrbounds[1] = wi::to_offset (size);\n+    }\n+\n+  offrange[0] += ioff;\n+  offrange[1] += ioff;\n+\n+  /* Compute the more permissive upper bound when IGNORE_OFF_BY_ONE\n+     is set (when taking the address of the one-past-last element\n+     of an array) but always use the stricter bound in diagnostics. */\n+  offset_int ubound = arrbounds[1];\n+  if (ignore_off_by_one)\n+    ubound += 1;\n+\n+  if (arrbounds[0] == arrbounds[1]\n+      || offrange[0] >= ubound\n+      || offrange[1] < arrbounds[0])\n+    {\n+      /* Treat a reference to a non-array object as one to an array\n+\t of a single element.  */\n+      if (TREE_CODE (reftype) != ARRAY_TYPE)\n+\treftype = build_array_type_nelts (reftype, 1);\n+\n+      /* Extract the element type out of MEM_REF and use its size\n+\t to compute the index to print in the diagnostic; arrays\n+\t in MEM_REF don't mean anything.  A type with no size like\n+\t void is as good as having a size of 1.  */\n+      tree type = TREE_TYPE (ref);\n+      while (TREE_CODE (type) == ARRAY_TYPE)\n+\ttype = TREE_TYPE (type);\n+      if (tree size = TYPE_SIZE_UNIT (type))\n+\t{\n+\t  offrange[0] = offrange[0] / wi::to_offset (size);\n+\t  offrange[1] = offrange[1] / wi::to_offset (size);\n+\t}\n+\n+      bool warned;\n+      if (offrange[0] == offrange[1])\n+\twarned = warning_at (location, OPT_Warray_bounds,\n+\t\t\t     \"array subscript %wi is outside array bounds \"\n+\t\t\t     \"of %qT\",\n+\t\t\t     offrange[0].to_shwi (), reftype);\n+      else\n+\twarned = warning_at (location, OPT_Warray_bounds,\n+\t\t\t     \"array subscript [%wi, %wi] is outside \"\n+\t\t\t     \"array bounds of %qT\",\n+\t\t\t     offrange[0].to_shwi (),\n+\t\t\t     offrange[1].to_shwi (), reftype);\n+      if (warned && DECL_P (arg))\n+\tinform (DECL_SOURCE_LOCATION (arg), \"while referencing %qD\", arg);\n+\n+      if (warned)\n+\tTREE_NO_WARNING (ref) = 1;\n+      return warned;\n+    }\n+\n+  if (warn_array_bounds < 2)\n+    return false;\n+\n+  /* At level 2 check also intermediate offsets.  */\n+  int i = 0;\n+  if (extrema[i] < -arrbounds[1] || extrema[i = 1] > ubound)\n+    {\n+      HOST_WIDE_INT tmpidx = extrema[i].to_shwi () / eltsize.to_shwi ();\n+\n+      if (warning_at (location, OPT_Warray_bounds,\n+\t\t      \"intermediate array offset %wi is outside array bounds \"\n+\t\t      \"of %qT\", tmpidx, reftype))\n+\t{\n+\t  TREE_NO_WARNING (ref) = 1;\n+\t  return true;\n+\t}\n+    }\n+\n+  return false;\n+}\n+\n+/* Searches if the expr T, located at LOCATION computes\n+   address of an ARRAY_REF, and call check_array_ref on it.  */\n+\n+void\n+array_bounds_checker::check_addr_expr (location_t location, tree t)\n+{\n+  /* Check each ARRAY_REF and MEM_REF in the reference chain. */\n+  do\n+    {\n+      bool warned = false;\n+      if (TREE_CODE (t) == ARRAY_REF)\n+\twarned = check_array_ref (location, t, true /*ignore_off_by_one*/);\n+      else if (TREE_CODE (t) == MEM_REF)\n+\twarned = check_mem_ref (location, t, true /*ignore_off_by_one*/);\n+\n+      if (warned)\n+\tTREE_NO_WARNING (t) = true;\n+\n+      t = TREE_OPERAND (t, 0);\n+    }\n+  while (handled_component_p (t) || TREE_CODE (t) == MEM_REF);\n+\n+  if (TREE_CODE (t) != MEM_REF\n+      || TREE_CODE (TREE_OPERAND (t, 0)) != ADDR_EXPR\n+      || TREE_NO_WARNING (t))\n+    return;\n+\n+  tree tem = TREE_OPERAND (TREE_OPERAND (t, 0), 0);\n+  tree low_bound, up_bound, el_sz;\n+  if (TREE_CODE (TREE_TYPE (tem)) != ARRAY_TYPE\n+      || TREE_CODE (TREE_TYPE (TREE_TYPE (tem))) == ARRAY_TYPE\n+      || !TYPE_DOMAIN (TREE_TYPE (tem)))\n+    return;\n+\n+  low_bound = TYPE_MIN_VALUE (TYPE_DOMAIN (TREE_TYPE (tem)));\n+  up_bound = TYPE_MAX_VALUE (TYPE_DOMAIN (TREE_TYPE (tem)));\n+  el_sz = TYPE_SIZE_UNIT (TREE_TYPE (TREE_TYPE (tem)));\n+  if (!low_bound\n+      || TREE_CODE (low_bound) != INTEGER_CST\n+      || !up_bound\n+      || TREE_CODE (up_bound) != INTEGER_CST\n+      || !el_sz\n+      || TREE_CODE (el_sz) != INTEGER_CST)\n+    return;\n+\n+  offset_int idx;\n+  if (!mem_ref_offset (t).is_constant (&idx))\n+    return;\n+\n+  bool warned = false;\n+  idx = wi::sdiv_trunc (idx, wi::to_offset (el_sz));\n+  if (idx < 0)\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  fprintf (dump_file, \"Array bound warning for \");\n+\t  dump_generic_expr (MSG_NOTE, TDF_SLIM, t);\n+\t  fprintf (dump_file, \"\\n\");\n+\t}\n+      warned = warning_at (location, OPT_Warray_bounds,\n+\t\t\t   \"array subscript %wi is below \"\n+\t\t\t   \"array bounds of %qT\",\n+\t\t\t   idx.to_shwi (), TREE_TYPE (tem));\n+    }\n+  else if (idx > (wi::to_offset (up_bound)\n+\t\t  - wi::to_offset (low_bound) + 1))\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  fprintf (dump_file, \"Array bound warning for \");\n+\t  dump_generic_expr (MSG_NOTE, TDF_SLIM, t);\n+\t  fprintf (dump_file, \"\\n\");\n+\t}\n+      warned = warning_at (location, OPT_Warray_bounds,\n+\t\t\t   \"array subscript %wu is above \"\n+\t\t\t   \"array bounds of %qT\",\n+\t\t\t   idx.to_uhwi (), TREE_TYPE (tem));\n+    }\n+\n+  if (warned)\n+    {\n+      if (DECL_P (t))\n+\tinform (DECL_SOURCE_LOCATION (t), \"while referencing %qD\", t);\n+\n+      TREE_NO_WARNING (t) = 1;\n+    }\n+}\n+\n+/* Callback for walk_tree to check a tree for out of bounds array\n+   accesses.  The array_bounds_checker class is passed in DATA.  */\n+\n+tree\n+array_bounds_checker::check_array_bounds (tree *tp, int *walk_subtree,\n+\t\t\t\t\t  void *data)\n+{\n+  tree t = *tp;\n+  struct walk_stmt_info *wi = (struct walk_stmt_info *) data;\n+  location_t location;\n+\n+  if (EXPR_HAS_LOCATION (t))\n+    location = EXPR_LOCATION (t);\n+  else\n+    location = gimple_location (wi->stmt);\n+\n+  *walk_subtree = TRUE;\n+\n+  bool warned = false;\n+  array_bounds_checker *checker = (array_bounds_checker *) wi->info;\n+  if (TREE_CODE (t) == ARRAY_REF)\n+    warned = checker->check_array_ref (location, t,\n+\t\t\t\t       false/*ignore_off_by_one*/);\n+  else if (TREE_CODE (t) == MEM_REF)\n+    warned = checker->check_mem_ref (location, t,\n+\t\t\t\t     false /*ignore_off_by_one*/);\n+  else if (TREE_CODE (t) == ADDR_EXPR)\n+    {\n+      checker->check_addr_expr (location, t);\n+      *walk_subtree = FALSE;\n+    }\n+  /* Propagate the no-warning bit to the outer expression.  */\n+  if (warned)\n+    TREE_NO_WARNING (t) = true;\n+\n+  return NULL_TREE;\n+}\n+\n+/* A dom_walker subclass for use by check_all_array_refs, to walk over\n+   all statements of all reachable BBs and call check_array_bounds on\n+   them.  */\n+\n+class check_array_bounds_dom_walker : public dom_walker\n+{\n+public:\n+  check_array_bounds_dom_walker (array_bounds_checker *checker)\n+    : dom_walker (CDI_DOMINATORS,\n+\t\t  /* Discover non-executable edges, preserving EDGE_EXECUTABLE\n+\t\t     flags, so that we can merge in information on\n+\t\t     non-executable edges from vrp_folder .  */\n+\t\t  REACHABLE_BLOCKS_PRESERVING_FLAGS),\n+    checker (checker) { }\n+  ~check_array_bounds_dom_walker () {}\n+\n+  edge before_dom_children (basic_block) FINAL OVERRIDE;\n+\n+private:\n+  array_bounds_checker *checker;\n+};\n+\n+/* Implementation of dom_walker::before_dom_children.\n+\n+   Walk over all statements of BB and call check_array_bounds on them,\n+   and determine if there's a unique successor edge.  */\n+\n+edge\n+check_array_bounds_dom_walker::before_dom_children (basic_block bb)\n+{\n+  gimple_stmt_iterator si;\n+  for (si = gsi_start_bb (bb); !gsi_end_p (si); gsi_next (&si))\n+    {\n+      gimple *stmt = gsi_stmt (si);\n+      struct walk_stmt_info wi;\n+      if (!gimple_has_location (stmt)\n+\t  || is_gimple_debug (stmt))\n+\tcontinue;\n+\n+      memset (&wi, 0, sizeof (wi));\n+\n+      wi.info = checker;\n+\n+      walk_gimple_op (stmt, array_bounds_checker::check_array_bounds, &wi);\n+    }\n+\n+  /* Determine if there's a unique successor edge, and if so, return\n+     that back to dom_walker, ensuring that we don't visit blocks that\n+     became unreachable during the VRP propagation\n+     (PR tree-optimization/83312).  */\n+  return find_taken_edge (bb, NULL_TREE);\n+}\n+\n+void\n+array_bounds_checker::check ()\n+{\n+  check_array_bounds_dom_walker w (this);\n+  w.walk (ENTRY_BLOCK_PTR_FOR_FN (fun));\n+}"}, {"sha": "faa227d900535779e7c996c5ef9f14179d13c373", "filename": "gcc/gimple-array-bounds.h", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62efd1c481dfd3b9cd69e64a9d6053dd8fcc3382/gcc%2Fgimple-array-bounds.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62efd1c481dfd3b9cd69e64a9d6053dd8fcc3382/gcc%2Fgimple-array-bounds.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-array-bounds.h?ref=62efd1c481dfd3b9cd69e64a9d6053dd8fcc3382", "patch": "@@ -0,0 +1,43 @@\n+/* Array bounds checking.\n+   Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_GIMPLE_ARRAY_BOUNDS_H\n+#define GCC_GIMPLE_ARRAY_BOUNDS_H\n+\n+class array_bounds_checker\n+{\n+  friend class check_array_bounds_dom_walker;\n+\n+public:\n+  array_bounds_checker (struct function *fun, class vr_values *v)\n+    : fun (fun), ranges (v) { }\n+  void check ();\n+\n+private:\n+  static tree check_array_bounds (tree *tp, int *walk_subtree, void *data);\n+  bool check_array_ref (location_t, tree, bool ignore_off_by_one);\n+  bool check_mem_ref (location_t, tree, bool ignore_off_by_one);\n+  void check_addr_expr (location_t, tree);\n+  const value_range *get_value_range (const_tree op);\n+\n+  struct function *fun;\n+  class vr_values *ranges;\n+};\n+\n+#endif // GCC_GIMPLE_ARRAY_BOUNDS_H"}, {"sha": "811fe0d20bbffcbfe93d41904b76ba6e43a17571", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 1, "deletions": 681, "changes": 682, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62efd1c481dfd3b9cd69e64a9d6053dd8fcc3382/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62efd1c481dfd3b9cd69e64a9d6053dd8fcc3382/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=62efd1c481dfd3b9cd69e64a9d6053dd8fcc3382", "patch": "@@ -31,7 +31,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"ssa.h\"\n #include \"optabs-tree.h\"\n #include \"gimple-pretty-print.h\"\n-#include \"diagnostic-core.h\"\n #include \"flags.h\"\n #include \"fold-const.h\"\n #include \"stor-layout.h\"\n@@ -42,13 +41,11 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimple-iterator.h\"\n #include \"gimple-walk.h\"\n #include \"tree-cfg.h\"\n-#include \"tree-dfa.h\"\n #include \"tree-ssa-loop-manip.h\"\n #include \"tree-ssa-loop-niter.h\"\n #include \"tree-ssa-loop.h\"\n #include \"tree-into-ssa.h\"\n #include \"tree-ssa.h\"\n-#include \"intl.h\"\n #include \"cfgloop.h\"\n #include \"tree-scalar-evolution.h\"\n #include \"tree-ssa-propagate.h\"\n@@ -68,6 +65,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"builtins.h\"\n #include \"range-op.h\"\n #include \"value-range-equiv.h\"\n+#include \"gimple-array-bounds.h\"\n \n /* Set of SSA names found live during the RPO traversal of the function\n    for still active basic-blocks.  */\n@@ -3398,684 +3396,6 @@ class vrp_prop : public ssa_propagation_engine\n     { vr_values.extract_range_from_phi_node (phi, vr); }\n };\n \n-/* Array bounds checking pass.  */\n-\n-class array_bounds_checker\n-{\n-  friend class check_array_bounds_dom_walker;\n-\n-public:\n-  array_bounds_checker (struct function *fun, class vr_values *v)\n-    : fun (fun), ranges (v) { }\n-  void check ();\n-\n-private:\n-  static tree check_array_bounds (tree *tp, int *walk_subtree, void *data);\n-  bool check_array_ref (location_t, tree, bool ignore_off_by_one);\n-  bool check_mem_ref (location_t, tree, bool ignore_off_by_one);\n-  void check_addr_expr (location_t, tree);\n-  const value_range_equiv *get_value_range (const_tree op)\n-    { return ranges->get_value_range (op); }\n-  struct function *fun;\n-  class vr_values *ranges;\n-};\n-\n-/* Checks one ARRAY_REF in REF, located at LOCUS. Ignores flexible arrays\n-   and \"struct\" hacks. If VRP can determine that the\n-   array subscript is a constant, check if it is outside valid\n-   range. If the array subscript is a RANGE, warn if it is\n-   non-overlapping with valid range.\n-   IGNORE_OFF_BY_ONE is true if the ARRAY_REF is inside a ADDR_EXPR.\n-   Returns true if a warning has been issued.  */\n-\n-bool\n-array_bounds_checker::check_array_ref (location_t location, tree ref,\n-\t\t\t\t       bool ignore_off_by_one)\n-{\n-  if (TREE_NO_WARNING (ref))\n-    return false;\n-\n-  tree low_sub = TREE_OPERAND (ref, 1);\n-  tree up_sub = low_sub;\n-  tree up_bound = array_ref_up_bound (ref);\n-\n-  /* Referenced decl if one can be determined.  */\n-  tree decl = NULL_TREE;\n-\n-  /* Set for accesses to interior zero-length arrays.  */\n-  bool interior_zero_len = false;\n-\n-  tree up_bound_p1;\n-\n-  if (!up_bound\n-      || TREE_CODE (up_bound) != INTEGER_CST\n-      || (warn_array_bounds < 2\n-\t  && array_at_struct_end_p (ref)))\n-    {\n-      /* Accesses to trailing arrays via pointers may access storage\n-\t beyond the types array bounds.  For such arrays, or for flexible\n-\t array members, as well as for other arrays of an unknown size,\n-\t replace the upper bound with a more permissive one that assumes\n-\t the size of the largest object is PTRDIFF_MAX.  */\n-      tree eltsize = array_ref_element_size (ref);\n-\n-      if (TREE_CODE (eltsize) != INTEGER_CST\n-\t  || integer_zerop (eltsize))\n-\t{\n-\t  up_bound = NULL_TREE;\n-\t  up_bound_p1 = NULL_TREE;\n-\t}\n-      else\n-\t{\n-\t  tree ptrdiff_max = TYPE_MAX_VALUE (ptrdiff_type_node);\n-\t  tree maxbound = ptrdiff_max;\n-\t  tree arg = TREE_OPERAND (ref, 0);\n-\n-\t  const bool compref = TREE_CODE (arg) == COMPONENT_REF;\n-\t  if (compref)\n-\t    {\n-\t      /* Try to determine the size of the trailing array from\n-\t\t its initializer (if it has one).  */\n-\t      if (tree refsize = component_ref_size (arg, &interior_zero_len))\n-\t\tif (TREE_CODE (refsize) == INTEGER_CST)\n-\t\t  maxbound = refsize;\n-\t    }\n-\n-\t  if (maxbound == ptrdiff_max)\n-\t    {\n-\t      /* Try to determine the size of the base object.  Avoid\n-\t\t COMPONENT_REF already tried above.  Using its DECL_SIZE\n-\t\t size wouldn't necessarily be correct if the reference is\n-\t\t to its flexible array member initialized in a different\n-\t\t translation unit.  */\n-\t      poly_int64 off;\n-\t      if (tree base = get_addr_base_and_unit_offset (arg, &off))\n-\t\t{\n-\t\t  if (!compref && DECL_P (base))\n-\t\t    if (tree basesize = DECL_SIZE_UNIT (base))\n-\t\t      if (TREE_CODE (basesize) == INTEGER_CST)\n-\t\t\t{\n-\t\t\t  maxbound = basesize;\n-\t\t\t  decl = base;\n-\t\t\t}\n-\n-\t\t  if (known_gt (off, 0))\n-\t\t    maxbound = wide_int_to_tree (sizetype,\n-\t\t\t\t\t\t wi::sub (wi::to_wide (maxbound),\n-\t\t\t\t\t\t\t  off));\n-\t\t}\n-\t    }\n-\t  else\n-\t    maxbound = fold_convert (sizetype, maxbound);\n-\n-\t  up_bound_p1 = int_const_binop (TRUNC_DIV_EXPR, maxbound, eltsize);\n-\n-\t  if (up_bound_p1 != NULL_TREE)\n-\t    up_bound = int_const_binop (MINUS_EXPR, up_bound_p1,\n-\t\t\t\t\tbuild_int_cst (ptrdiff_type_node, 1));\n-\t  else\n-\t    up_bound = NULL_TREE;\n-\t}\n-    }\n-  else\n-    up_bound_p1 = int_const_binop (PLUS_EXPR, up_bound,\n-\t\t\t\t   build_int_cst (TREE_TYPE (up_bound), 1));\n-\n-  tree low_bound = array_ref_low_bound (ref);\n-\n-  tree artype = TREE_TYPE (TREE_OPERAND (ref, 0));\n-\n-  bool warned = false;\n-\n-  /* Empty array.  */\n-  if (up_bound && tree_int_cst_equal (low_bound, up_bound_p1))\n-    warned = warning_at (location, OPT_Warray_bounds,\n-\t\t\t \"array subscript %E is outside array bounds of %qT\",\n-\t\t\t low_sub, artype);\n-\n-  const value_range_equiv *vr = NULL;\n-  if (TREE_CODE (low_sub) == SSA_NAME)\n-    {\n-      vr = get_value_range (low_sub);\n-      if (!vr->undefined_p () && !vr->varying_p ())\n-        {\n-          low_sub = vr->kind () == VR_RANGE ? vr->max () : vr->min ();\n-          up_sub = vr->kind () == VR_RANGE ? vr->min () : vr->max ();\n-        }\n-    }\n-\n-  if (warned)\n-    ; /* Do nothing.  */\n-  else if (vr && vr->kind () == VR_ANTI_RANGE)\n-    {\n-      if (up_bound\n-\t  && TREE_CODE (up_sub) == INTEGER_CST\n-          && (ignore_off_by_one\n-\t      ? tree_int_cst_lt (up_bound, up_sub)\n-\t      : tree_int_cst_le (up_bound, up_sub))\n-          && TREE_CODE (low_sub) == INTEGER_CST\n-          && tree_int_cst_le (low_sub, low_bound))\n-\twarned = warning_at (location, OPT_Warray_bounds,\n-\t\t\t     \"array subscript [%E, %E] is outside \"\n-\t\t\t     \"array bounds of %qT\",\n-\t\t\t     low_sub, up_sub, artype);\n-    }\n-  else if (up_bound\n-\t   && TREE_CODE (up_sub) == INTEGER_CST\n-\t   && (ignore_off_by_one\n-\t       ? !tree_int_cst_le (up_sub, up_bound_p1)\n-\t       : !tree_int_cst_le (up_sub, up_bound)))\n-    warned = warning_at (location, OPT_Warray_bounds,\n-\t\t\t \"array subscript %E is above array bounds of %qT\",\n-\t\t\t up_sub, artype);\n-  else if (TREE_CODE (low_sub) == INTEGER_CST\n-           && tree_int_cst_lt (low_sub, low_bound))\n-    warned = warning_at (location, OPT_Warray_bounds,\n-\t\t\t \"array subscript %E is below array bounds of %qT\",\n-\t\t\t low_sub, artype);\n-\n-  if (!warned && interior_zero_len)\n-    warned = warning_at (location, OPT_Wzero_length_bounds,\n-\t\t\t (TREE_CODE (low_sub) == INTEGER_CST\n-\t\t\t  ? G_(\"array subscript %E is outside the bounds \"\n-\t\t\t       \"of an interior zero-length array %qT\")\n-\t\t\t  : G_(\"array subscript %qE is outside the bounds \"\n-\t\t\t       \"of an interior zero-length array %qT\")),\n-\t\t\t low_sub, artype);\n-\n-  if (warned)\n-    {\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t{\n-\t  fprintf (dump_file, \"Array bound warning for \");\n-\t  dump_generic_expr (MSG_NOTE, TDF_SLIM, ref);\n-\t  fprintf (dump_file, \"\\n\");\n-\t}\n-\n-      ref = decl ? decl : TREE_OPERAND (ref, 0);\n-\n-      tree rec = NULL_TREE;\n-      if (TREE_CODE (ref) == COMPONENT_REF)\n-\t{\n-\t  /* For a reference to a member of a struct object also mention\n-\t     the object if it's known.  It may be defined in a different\n-\t     function than the out-of-bounds access.  */\n-\t  rec = TREE_OPERAND (ref, 0);\n-\t  if (!VAR_P (rec))\n-\t    rec = NULL_TREE;\n-\t  ref = TREE_OPERAND (ref, 1);\n-\t}\n-\n-      if (DECL_P (ref))\n-\tinform (DECL_SOURCE_LOCATION (ref), \"while referencing %qD\", ref);\n-      if (rec && DECL_P (rec))\n-\tinform (DECL_SOURCE_LOCATION (rec), \"defined here %qD\", rec);\n-\n-      TREE_NO_WARNING (ref) = 1;\n-    }\n-\n-  return warned;\n-}\n-\n-/* Checks one MEM_REF in REF, located at LOCATION, for out-of-bounds\n-   references to string constants.  If VRP can determine that the array\n-   subscript is a constant, check if it is outside valid range.\n-   If the array subscript is a RANGE, warn if it is non-overlapping\n-   with valid range.\n-   IGNORE_OFF_BY_ONE is true if the MEM_REF is inside an ADDR_EXPR\n-   (used to allow one-past-the-end indices for code that takes\n-   the address of the just-past-the-end element of an array).\n-   Returns true if a warning has been issued.  */\n-\n-bool\n-array_bounds_checker::check_mem_ref (location_t location, tree ref,\n-\t\t\t\t     bool ignore_off_by_one)\n-{\n-  if (TREE_NO_WARNING (ref))\n-    return false;\n-\n-  tree arg = TREE_OPERAND (ref, 0);\n-  /* The constant and variable offset of the reference.  */\n-  tree cstoff = TREE_OPERAND (ref, 1);\n-  tree varoff = NULL_TREE;\n-\n-  const offset_int maxobjsize = tree_to_shwi (max_object_size ());\n-\n-  /* The array or string constant bounds in bytes.  Initially set\n-     to [-MAXOBJSIZE - 1, MAXOBJSIZE]  until a tighter bound is\n-     determined.  */\n-  offset_int arrbounds[2] = { -maxobjsize - 1, maxobjsize };\n-\n-  /* The minimum and maximum intermediate offset.  For a reference\n-     to be valid, not only does the final offset/subscript must be\n-     in bounds but all intermediate offsets should be as well.\n-     GCC may be able to deal gracefully with such out-of-bounds\n-     offsets so the checking is only enbaled at -Warray-bounds=2\n-     where it may help detect bugs in uses of the intermediate\n-     offsets that could otherwise not be detectable.  */\n-  offset_int ioff = wi::to_offset (fold_convert (ptrdiff_type_node, cstoff));\n-  offset_int extrema[2] = { 0, wi::abs (ioff) };\n-\n-  /* The range of the byte offset into the reference.  */\n-  offset_int offrange[2] = { 0, 0 };\n-\n-  const value_range_equiv *vr = NULL;\n-\n-  /* Determine the offsets and increment OFFRANGE for the bounds of each.\n-     The loop computes the range of the final offset for expressions such\n-     as (A + i0 + ... + iN)[CSTOFF] where i0 through iN are SSA_NAMEs in\n-     some range.  */\n-  const unsigned limit = param_ssa_name_def_chain_limit;\n-  for (unsigned n = 0; TREE_CODE (arg) == SSA_NAME && n < limit; ++n)\n-    {\n-      gimple *def = SSA_NAME_DEF_STMT (arg);\n-      if (!is_gimple_assign (def))\n-\tbreak;\n-\n-      tree_code code = gimple_assign_rhs_code (def);\n-      if (code == POINTER_PLUS_EXPR)\n-\t{\n-\t  arg = gimple_assign_rhs1 (def);\n-\t  varoff = gimple_assign_rhs2 (def);\n-\t}\n-      else if (code == ASSERT_EXPR)\n-\t{\n-\t  arg = TREE_OPERAND (gimple_assign_rhs1 (def), 0);\n-\t  continue;\n-\t}\n-      else\n-\treturn false;\n-\n-      /* VAROFF should always be a SSA_NAME here (and not even\n-\t INTEGER_CST) but there's no point in taking chances.  */\n-      if (TREE_CODE (varoff) != SSA_NAME)\n-\tbreak;\n-\n-      vr = get_value_range (varoff);\n-      if (!vr || vr->undefined_p () || vr->varying_p ())\n-\tbreak;\n-\n-      if (!vr->constant_p ())\n-        break;\n-\n-      if (vr->kind () == VR_RANGE)\n-\t{\n-\t  offset_int min\n-\t    = wi::to_offset (fold_convert (ptrdiff_type_node, vr->min ()));\n-\t  offset_int max\n-\t    = wi::to_offset (fold_convert (ptrdiff_type_node, vr->max ()));\n-\t  if (min < max)\n-\t    {\n-\t      offrange[0] += min;\n-\t      offrange[1] += max;\n-\t    }\n-\t  else\n-\t    {\n-\t      /* When MIN >= MAX, the offset is effectively in a union\n-\t\t of two ranges: [-MAXOBJSIZE -1, MAX] and [MIN, MAXOBJSIZE].\n-\t\t Since there is no way to represent such a range across\n-\t\t additions, conservatively add [-MAXOBJSIZE -1, MAXOBJSIZE]\n-\t\t to OFFRANGE.  */\n-\t      offrange[0] += arrbounds[0];\n-\t      offrange[1] += arrbounds[1];\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  /* For an anti-range, analogously to the above, conservatively\n-\t     add [-MAXOBJSIZE -1, MAXOBJSIZE] to OFFRANGE.  */\n-\t  offrange[0] += arrbounds[0];\n-\t  offrange[1] += arrbounds[1];\n-\t}\n-\n-      /* Keep track of the minimum and maximum offset.  */\n-      if (offrange[1] < 0 && offrange[1] < extrema[0])\n-\textrema[0] = offrange[1];\n-      if (offrange[0] > 0 && offrange[0] > extrema[1])\n-\textrema[1] = offrange[0];\n-\n-      if (offrange[0] < arrbounds[0])\n-\toffrange[0] = arrbounds[0];\n-\n-      if (offrange[1] > arrbounds[1])\n-\toffrange[1] = arrbounds[1];\n-    }\n-\n-  if (TREE_CODE (arg) == ADDR_EXPR)\n-    {\n-      arg = TREE_OPERAND (arg, 0);\n-      if (TREE_CODE (arg) != STRING_CST\n-\t  && TREE_CODE (arg) != PARM_DECL\n-\t  && TREE_CODE (arg) != VAR_DECL)\n-\treturn false;\n-    }\n-  else\n-    return false;\n-\n-  /* The type of the object being referred to.  It can be an array,\n-     string literal, or a non-array type when the MEM_REF represents\n-     a reference/subscript via a pointer to an object that is not\n-     an element of an array.  Incomplete types are excluded as well\n-     because their size is not known.  */\n-  tree reftype = TREE_TYPE (arg);\n-  if (POINTER_TYPE_P (reftype)\n-      || !COMPLETE_TYPE_P (reftype)\n-      || TREE_CODE (TYPE_SIZE_UNIT (reftype)) != INTEGER_CST)\n-    return false;\n-\n-  /* Except in declared objects, references to trailing array members\n-     of structs and union objects are excluded because MEM_REF doesn't\n-     make it possible to identify the member where the reference\n-     originated.  */\n-  if (RECORD_OR_UNION_TYPE_P (reftype)\n-      && (!VAR_P (arg)\n-\t  || (DECL_EXTERNAL (arg) && array_at_struct_end_p (ref))))\n-    return false;\n-\n-  arrbounds[0] = 0;\n-\n-  offset_int eltsize;\n-  if (TREE_CODE (reftype) == ARRAY_TYPE)\n-    {\n-      eltsize = wi::to_offset (TYPE_SIZE_UNIT (TREE_TYPE (reftype)));\n-      if (tree dom = TYPE_DOMAIN (reftype))\n-\t{\n-\t  tree bnds[] = { TYPE_MIN_VALUE (dom), TYPE_MAX_VALUE (dom) };\n-\t  if (TREE_CODE (arg) == COMPONENT_REF)\n-\t    {\n-\t      offset_int size = maxobjsize;\n-\t      if (tree fldsize = component_ref_size (arg))\n-\t\tsize = wi::to_offset (fldsize);\n-\t      arrbounds[1] = wi::lrshift (size, wi::floor_log2 (eltsize));\n-\t    }\n-\t  else if (array_at_struct_end_p (arg) || !bnds[0] || !bnds[1])\n-\t    arrbounds[1] = wi::lrshift (maxobjsize, wi::floor_log2 (eltsize));\n-\t  else\n-\t    arrbounds[1] = (wi::to_offset (bnds[1]) - wi::to_offset (bnds[0])\n-\t\t\t    + 1) * eltsize;\n-\t}\n-      else\n-\tarrbounds[1] = wi::lrshift (maxobjsize, wi::floor_log2 (eltsize));\n-\n-      /* Determine a tighter bound of the non-array element type.  */\n-      tree eltype = TREE_TYPE (reftype);\n-      while (TREE_CODE (eltype) == ARRAY_TYPE)\n-\teltype = TREE_TYPE (eltype);\n-      eltsize = wi::to_offset (TYPE_SIZE_UNIT (eltype));\n-    }\n-  else\n-    {\n-      eltsize = 1;\n-      tree size = TYPE_SIZE_UNIT (reftype);\n-      if (VAR_P (arg))\n-\tif (tree initsize = DECL_SIZE_UNIT (arg))\n-\t  if (tree_int_cst_lt (size, initsize))\n-\t    size = initsize;\n-\n-      arrbounds[1] = wi::to_offset (size);\n-    }\n-\n-  offrange[0] += ioff;\n-  offrange[1] += ioff;\n-\n-  /* Compute the more permissive upper bound when IGNORE_OFF_BY_ONE\n-     is set (when taking the address of the one-past-last element\n-     of an array) but always use the stricter bound in diagnostics. */\n-  offset_int ubound = arrbounds[1];\n-  if (ignore_off_by_one)\n-    ubound += 1;\n-\n-  if (arrbounds[0] == arrbounds[1]\n-      || offrange[0] >= ubound\n-      || offrange[1] < arrbounds[0])\n-    {\n-      /* Treat a reference to a non-array object as one to an array\n-\t of a single element.  */\n-      if (TREE_CODE (reftype) != ARRAY_TYPE)\n-\treftype = build_array_type_nelts (reftype, 1);\n-\n-      /* Extract the element type out of MEM_REF and use its size\n-\t to compute the index to print in the diagnostic; arrays\n-\t in MEM_REF don't mean anything.  A type with no size like\n-\t void is as good as having a size of 1.  */\n-      tree type = TREE_TYPE (ref);\n-      while (TREE_CODE (type) == ARRAY_TYPE)\n-\ttype = TREE_TYPE (type);\n-      if (tree size = TYPE_SIZE_UNIT (type))\n-\t{\n-\t  offrange[0] = offrange[0] / wi::to_offset (size);\n-\t  offrange[1] = offrange[1] / wi::to_offset (size);\n-\t}\n-\n-      bool warned;\n-      if (offrange[0] == offrange[1])\n-\twarned = warning_at (location, OPT_Warray_bounds,\n-\t\t\t     \"array subscript %wi is outside array bounds \"\n-\t\t\t     \"of %qT\",\n-\t\t\t     offrange[0].to_shwi (), reftype);\n-      else\n-\twarned = warning_at (location, OPT_Warray_bounds,\n-\t\t\t     \"array subscript [%wi, %wi] is outside \"\n-\t\t\t     \"array bounds of %qT\",\n-\t\t\t     offrange[0].to_shwi (),\n-\t\t\t     offrange[1].to_shwi (), reftype);\n-      if (warned && DECL_P (arg))\n-\tinform (DECL_SOURCE_LOCATION (arg), \"while referencing %qD\", arg);\n-\n-      if (warned)\n-\tTREE_NO_WARNING (ref) = 1;\n-      return warned;\n-    }\n-\n-  if (warn_array_bounds < 2)\n-    return false;\n-\n-  /* At level 2 check also intermediate offsets.  */\n-  int i = 0;\n-  if (extrema[i] < -arrbounds[1] || extrema[i = 1] > ubound)\n-    {\n-      HOST_WIDE_INT tmpidx = extrema[i].to_shwi () / eltsize.to_shwi ();\n-\n-      if (warning_at (location, OPT_Warray_bounds,\n-\t\t      \"intermediate array offset %wi is outside array bounds \"\n-\t\t      \"of %qT\", tmpidx, reftype))\n-\t{\n-\t  TREE_NO_WARNING (ref) = 1;\n-\t  return true;\n-\t}\n-    }\n-\n-  return false;\n-}\n-\n-/* Searches if the expr T, located at LOCATION computes\n-   address of an ARRAY_REF, and call check_array_ref on it.  */\n-\n-void\n-array_bounds_checker::check_addr_expr (location_t location, tree t)\n-{\n-  /* Check each ARRAY_REF and MEM_REF in the reference chain. */\n-  do\n-    {\n-      bool warned = false;\n-      if (TREE_CODE (t) == ARRAY_REF)\n-\twarned = check_array_ref (location, t, true /*ignore_off_by_one*/);\n-      else if (TREE_CODE (t) == MEM_REF)\n-\twarned = check_mem_ref (location, t, true /*ignore_off_by_one*/);\n-\n-      if (warned)\n-\tTREE_NO_WARNING (t) = true;\n-\n-      t = TREE_OPERAND (t, 0);\n-    }\n-  while (handled_component_p (t) || TREE_CODE (t) == MEM_REF);\n-\n-  if (TREE_CODE (t) != MEM_REF\n-      || TREE_CODE (TREE_OPERAND (t, 0)) != ADDR_EXPR\n-      || TREE_NO_WARNING (t))\n-    return;\n-\n-  tree tem = TREE_OPERAND (TREE_OPERAND (t, 0), 0);\n-  tree low_bound, up_bound, el_sz;\n-  if (TREE_CODE (TREE_TYPE (tem)) != ARRAY_TYPE\n-      || TREE_CODE (TREE_TYPE (TREE_TYPE (tem))) == ARRAY_TYPE\n-      || !TYPE_DOMAIN (TREE_TYPE (tem)))\n-    return;\n-\n-  low_bound = TYPE_MIN_VALUE (TYPE_DOMAIN (TREE_TYPE (tem)));\n-  up_bound = TYPE_MAX_VALUE (TYPE_DOMAIN (TREE_TYPE (tem)));\n-  el_sz = TYPE_SIZE_UNIT (TREE_TYPE (TREE_TYPE (tem)));\n-  if (!low_bound\n-      || TREE_CODE (low_bound) != INTEGER_CST\n-      || !up_bound\n-      || TREE_CODE (up_bound) != INTEGER_CST\n-      || !el_sz\n-      || TREE_CODE (el_sz) != INTEGER_CST)\n-    return;\n-\n-  offset_int idx;\n-  if (!mem_ref_offset (t).is_constant (&idx))\n-    return;\n-\n-  bool warned = false;\n-  idx = wi::sdiv_trunc (idx, wi::to_offset (el_sz));\n-  if (idx < 0)\n-    {\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t{\n-\t  fprintf (dump_file, \"Array bound warning for \");\n-\t  dump_generic_expr (MSG_NOTE, TDF_SLIM, t);\n-\t  fprintf (dump_file, \"\\n\");\n-\t}\n-      warned = warning_at (location, OPT_Warray_bounds,\n-\t\t\t   \"array subscript %wi is below \"\n-\t\t\t   \"array bounds of %qT\",\n-\t\t\t   idx.to_shwi (), TREE_TYPE (tem));\n-    }\n-  else if (idx > (wi::to_offset (up_bound)\n-\t\t  - wi::to_offset (low_bound) + 1))\n-    {\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t{\n-\t  fprintf (dump_file, \"Array bound warning for \");\n-\t  dump_generic_expr (MSG_NOTE, TDF_SLIM, t);\n-\t  fprintf (dump_file, \"\\n\");\n-\t}\n-      warned = warning_at (location, OPT_Warray_bounds,\n-\t\t\t   \"array subscript %wu is above \"\n-\t\t\t   \"array bounds of %qT\",\n-\t\t\t   idx.to_uhwi (), TREE_TYPE (tem));\n-    }\n-\n-  if (warned)\n-    {\n-      if (DECL_P (t))\n-\tinform (DECL_SOURCE_LOCATION (t), \"while referencing %qD\", t);\n-\n-      TREE_NO_WARNING (t) = 1;\n-    }\n-}\n-\n-/* Callback for walk_tree to check a tree for out of bounds array\n-   accesses.  The array_bounds_checker class is passed in DATA.  */\n-\n-tree\n-array_bounds_checker::check_array_bounds (tree *tp, int *walk_subtree,\n-\t\t\t\t\t  void *data)\n-{\n-  tree t = *tp;\n-  struct walk_stmt_info *wi = (struct walk_stmt_info *) data;\n-  location_t location;\n-\n-  if (EXPR_HAS_LOCATION (t))\n-    location = EXPR_LOCATION (t);\n-  else\n-    location = gimple_location (wi->stmt);\n-\n-  *walk_subtree = TRUE;\n-\n-  bool warned = false;\n-  array_bounds_checker *checker = (array_bounds_checker *) wi->info;\n-  if (TREE_CODE (t) == ARRAY_REF)\n-    warned = checker->check_array_ref (location, t,\n-\t\t\t\t       false/*ignore_off_by_one*/);\n-  else if (TREE_CODE (t) == MEM_REF)\n-    warned = checker->check_mem_ref (location, t,\n-\t\t\t\t     false /*ignore_off_by_one*/);\n-  else if (TREE_CODE (t) == ADDR_EXPR)\n-    {\n-      checker->check_addr_expr (location, t);\n-      *walk_subtree = FALSE;\n-    }\n-  /* Propagate the no-warning bit to the outer expression.  */\n-  if (warned)\n-    TREE_NO_WARNING (t) = true;\n-\n-  return NULL_TREE;\n-}\n-\n-/* A dom_walker subclass for use by check_all_array_refs, to walk over\n-   all statements of all reachable BBs and call check_array_bounds on\n-   them.  */\n-\n-class check_array_bounds_dom_walker : public dom_walker\n-{\n-public:\n-  check_array_bounds_dom_walker (array_bounds_checker *checker)\n-    : dom_walker (CDI_DOMINATORS,\n-\t\t  /* Discover non-executable edges, preserving EDGE_EXECUTABLE\n-\t\t     flags, so that we can merge in information on\n-\t\t     non-executable edges from vrp_folder .  */\n-\t\t  REACHABLE_BLOCKS_PRESERVING_FLAGS),\n-    checker (checker) { }\n-  ~check_array_bounds_dom_walker () {}\n-\n-  edge before_dom_children (basic_block) FINAL OVERRIDE;\n-\n-private:\n-  array_bounds_checker *checker;\n-};\n-\n-/* Implementation of dom_walker::before_dom_children.\n-\n-   Walk over all statements of BB and call check_array_bounds on them,\n-   and determine if there's a unique successor edge.  */\n-\n-edge\n-check_array_bounds_dom_walker::before_dom_children (basic_block bb)\n-{\n-  gimple_stmt_iterator si;\n-  for (si = gsi_start_bb (bb); !gsi_end_p (si); gsi_next (&si))\n-    {\n-      gimple *stmt = gsi_stmt (si);\n-      struct walk_stmt_info wi;\n-      if (!gimple_has_location (stmt)\n-\t  || is_gimple_debug (stmt))\n-\tcontinue;\n-\n-      memset (&wi, 0, sizeof (wi));\n-\n-      wi.info = checker;\n-\n-      walk_gimple_op (stmt, array_bounds_checker::check_array_bounds, &wi);\n-    }\n-\n-  /* Determine if there's a unique successor edge, and if so, return\n-     that back to dom_walker, ensuring that we don't visit blocks that\n-     became unreachable during the VRP propagation\n-     (PR tree-optimization/83312).  */\n-  return find_taken_edge (bb, NULL_TREE);\n-}\n-\n-/* Entry point into array bounds checking pass.  */\n-\n-void\n-array_bounds_checker::check ()\n-{\n-  check_array_bounds_dom_walker w (this);\n-  w.walk (ENTRY_BLOCK_PTR_FOR_FN (fun));\n-}\n-\n /* Return true if all imm uses of VAR are either in STMT, or\n    feed (optionally through a chain of single imm uses) GIMPLE_COND\n    in basic block COND_BB.  */"}]}