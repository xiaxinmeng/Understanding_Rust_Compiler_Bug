{"sha": "e3174bdf35c172f69daf08350401aa177f8f1498", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTMxNzRiZGYzNWMxNzJmNjlkYWYwODM1MDQwMWFhMTc3ZjhmMTQ5OA==", "commit": {"author": {"name": "Maxim Ostapenko", "email": "m.ostapenko@samsung.com", "date": "2017-07-06T16:02:06Z"}, "committer": {"name": "Maxim Ostapenko", "email": "chefmax@gcc.gnu.org", "date": "2017-07-06T16:02:06Z"}, "message": "ASAN: Implement dynamic allocas/VLAs sanitization.\n\ngcc/\n\t* asan.c: Include gimple-fold.h.\n\t(get_last_alloca_addr): New function.\n\t(handle_builtin_stackrestore): Likewise.\n\t(handle_builtin_alloca): Likewise.\n\t(asan_emit_allocas_unpoison): Likewise.\n\t(get_mem_refs_of_builtin_call): Add new parameter, remove const\n\tquallifier from first paramerer. Handle BUILT_IN_ALLOCA,\n\tBUILT_IN_ALLOCA_WITH_ALIGN and BUILT_IN_STACK_RESTORE builtins.\n\t(instrument_builtin_call): Pass gimple iterator to\n\tget_mem_refs_of_builtin_call.\n\t(last_alloca_addr): New global.\n\t* asan.h (asan_emit_allocas_unpoison): Declare.\n\t* builtins.c (expand_asan_emit_allocas_unpoison): New function.\n\t(expand_builtin): Handle BUILT_IN_ASAN_ALLOCAS_UNPOISON.\n\t* cfgexpand.c (expand_used_vars): Call asan_emit_allocas_unpoison\n\tif function calls alloca.\n\t* gimple-fold.c (replace_call_with_value): Remove static keyword.\n\t* gimple-fold.h (replace_call_with_value): Declare.\n\t* internal-fn.c: Include asan.h.\n\t* sanitizer.def (BUILT_IN_ASAN_ALLOCA_POISON,\n\tBUILT_IN_ASAN_ALLOCAS_UNPOISON): New builtins.\n\ngcc/testsuite/\n\t* c-c++-common/asan/alloca_big_alignment.c: New test.\n\t* c-c++-common/asan/alloca_detect_custom_size.c: Likewise.\n\t* c-c++-common/asan/alloca_instruments_all_paddings.c: Likewise.\n\t* c-c++-common/asan/alloca_loop_unpoisoning.c: Likewise.\n\t* c-c++-common/asan/alloca_overflow_partial.c: Likewise.\n\t* c-c++-common/asan/alloca_overflow_right.c: Likewise.\n\t* c-c++-common/asan/alloca_safe_access.c: Likewise.\n\t* c-c++-common/asan/alloca_underflow_left.c: Likewise.\n\nFrom-SVN: r250031", "tree": {"sha": "e7632bf6f8c4e541f5dbf209ad90d807a7b79318", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e7632bf6f8c4e541f5dbf209ad90d807a7b79318"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e3174bdf35c172f69daf08350401aa177f8f1498", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3174bdf35c172f69daf08350401aa177f8f1498", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e3174bdf35c172f69daf08350401aa177f8f1498", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3174bdf35c172f69daf08350401aa177f8f1498/comments", "author": null, "committer": null, "parents": [{"sha": "b6f4312871d39547c2e286b6eadac4408ab494ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6f4312871d39547c2e286b6eadac4408ab494ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6f4312871d39547c2e286b6eadac4408ab494ae"}], "stats": {"total": 472, "additions": 468, "deletions": 4}, "files": [{"sha": "f5614b01dcd81e4a88e0057e39f72dcdbde3e948", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3174bdf35c172f69daf08350401aa177f8f1498/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3174bdf35c172f69daf08350401aa177f8f1498/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e3174bdf35c172f69daf08350401aa177f8f1498", "patch": "@@ -1,3 +1,27 @@\n+2017-07-06  Maxim Ostapenko  <m.ostapenko@samsung.com>\n+\n+\t* asan.c: Include gimple-fold.h.\n+\t(get_last_alloca_addr): New function.\n+\t(handle_builtin_stackrestore): Likewise.\n+\t(handle_builtin_alloca): Likewise.\n+\t(asan_emit_allocas_unpoison): Likewise.\n+\t(get_mem_refs_of_builtin_call): Add new parameter, remove const\n+\tquallifier from first paramerer. Handle BUILT_IN_ALLOCA,\n+\tBUILT_IN_ALLOCA_WITH_ALIGN and BUILT_IN_STACK_RESTORE builtins.\n+\t(instrument_builtin_call): Pass gimple iterator to\n+\tget_mem_refs_of_builtin_call.\n+\t(last_alloca_addr): New global.\n+\t* asan.h (asan_emit_allocas_unpoison): Declare.\n+\t* builtins.c (expand_asan_emit_allocas_unpoison): New function.\n+\t(expand_builtin): Handle BUILT_IN_ASAN_ALLOCAS_UNPOISON.\n+\t* cfgexpand.c (expand_used_vars): Call asan_emit_allocas_unpoison\n+\tif function calls alloca.\n+\t* gimple-fold.c (replace_call_with_value): Remove static keyword.\n+\t* gimple-fold.h (replace_call_with_value): Declare.\n+\t* internal-fn.c: Include asan.h.\n+\t* sanitizer.def (BUILT_IN_ASAN_ALLOCA_POISON,\n+\tBUILT_IN_ASAN_ALLOCAS_UNPOISON): New builtins.\n+\n 2017-07-06  David Malcolm  <dmalcolm@redhat.com>\n \n \t* Makefile.in (SELFTEST_FLAGS): Drop \"-x c\", moving it to..."}, {"sha": "252e59fcd4d7c4d127304a08365857b21eec5140", "filename": "gcc/asan.c", "status": "modified", "additions": 212, "deletions": 3, "changes": 215, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3174bdf35c172f69daf08350401aa177f8f1498/gcc%2Fasan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3174bdf35c172f69daf08350401aa177f8f1498/gcc%2Fasan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fasan.c?ref=e3174bdf35c172f69daf08350401aa177f8f1498", "patch": "@@ -55,6 +55,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"langhooks.h\"\n #include \"cfgloop.h\"\n #include \"gimple-builder.h\"\n+#include \"gimple-fold.h\"\n #include \"ubsan.h\"\n #include \"params.h\"\n #include \"builtins.h\"\n@@ -245,6 +246,7 @@ along with GCC; see the file COPYING3.  If not see\n static unsigned HOST_WIDE_INT asan_shadow_offset_value;\n static bool asan_shadow_offset_computed;\n static vec<char *> sanitized_sections;\n+static tree last_alloca_addr;\n \n /* Set of variable declarations that are going to be guarded by\n    use-after-scope sanitizer.  */\n@@ -529,11 +531,186 @@ get_mem_ref_of_assignment (const gassign *assignment,\n   return true;\n }\n \n+/* Return address of last allocated dynamic alloca.  */\n+\n+static tree\n+get_last_alloca_addr ()\n+{\n+  if (last_alloca_addr)\n+    return last_alloca_addr;\n+\n+  last_alloca_addr = create_tmp_reg (ptr_type_node, \"last_alloca_addr\");\n+  gassign *g = gimple_build_assign (last_alloca_addr, null_pointer_node);\n+  edge e = single_succ_edge (ENTRY_BLOCK_PTR_FOR_FN (cfun));\n+  gsi_insert_on_edge_immediate (e, g);\n+  return last_alloca_addr;\n+}\n+\n+/* Insert __asan_allocas_unpoison (top, bottom) call after\n+   __builtin_stack_restore (new_sp) call.\n+   The pseudocode of this routine should look like this:\n+     __builtin_stack_restore (new_sp);\n+     top = last_alloca_addr;\n+     bot = new_sp;\n+     __asan_allocas_unpoison (top, bot);\n+     last_alloca_addr = new_sp;\n+   In general, we can't use new_sp as bot parameter because on some\n+   architectures SP has non zero offset from dynamic stack area.  Moreover, on\n+   some architectures this offset (STACK_DYNAMIC_OFFSET) becomes known for each\n+   particular function only after all callees were expanded to rtl.\n+   The most noticeable example is PowerPC{,64}, see\n+   http://refspecs.linuxfoundation.org/ELF/ppc64/PPC-elf64abi.html#DYNAM-STACK.\n+   To overcome the issue we use following trick: pass new_sp as a second\n+   parameter to __asan_allocas_unpoison and rewrite it during expansion with\n+   virtual_dynamic_stack_rtx later in expand_asan_emit_allocas_unpoison\n+   function.\n+*/\n+\n+static void\n+handle_builtin_stack_restore (gcall *call, gimple_stmt_iterator *iter)\n+{\n+  if (!iter)\n+    return;\n+\n+  tree last_alloca = get_last_alloca_addr ();\n+  tree restored_stack = gimple_call_arg (call, 0);\n+  tree fn = builtin_decl_implicit (BUILT_IN_ASAN_ALLOCAS_UNPOISON);\n+  gimple *g = gimple_build_call (fn, 2, last_alloca, restored_stack);\n+  gsi_insert_after (iter, g, GSI_NEW_STMT);\n+  g = gimple_build_assign (last_alloca, restored_stack);\n+  gsi_insert_after (iter, g, GSI_NEW_STMT);\n+}\n+\n+/* Deploy and poison redzones around __builtin_alloca call.  To do this, we\n+   should replace this call with another one with changed parameters and\n+   replace all its uses with new address, so\n+       addr = __builtin_alloca (old_size, align);\n+   is replaced by\n+       left_redzone_size = max (align, ASAN_RED_ZONE_SIZE);\n+   Following two statements are optimized out if we know that\n+   old_size & (ASAN_RED_ZONE_SIZE - 1) == 0, i.e. alloca doesn't need partial\n+   redzone.\n+       misalign = old_size & (ASAN_RED_ZONE_SIZE - 1);\n+       partial_redzone_size = ASAN_RED_ZONE_SIZE - misalign;\n+       right_redzone_size = ASAN_RED_ZONE_SIZE;\n+       additional_size = left_redzone_size + partial_redzone_size +\n+                         right_redzone_size;\n+       new_size = old_size + additional_size;\n+       new_alloca = __builtin_alloca (new_size, max (align, 32))\n+       __asan_alloca_poison (new_alloca, old_size)\n+       addr = new_alloca + max (align, ASAN_RED_ZONE_SIZE);\n+       last_alloca_addr = new_alloca;\n+   ADDITIONAL_SIZE is added to make new memory allocation contain not only\n+   requested memory, but also left, partial and right redzones as well as some\n+   additional space, required by alignment.  */\n+\n+static void\n+handle_builtin_alloca (gcall *call, gimple_stmt_iterator *iter)\n+{\n+  if (!iter)\n+    return;\n+\n+  gassign *g;\n+  gcall *gg;\n+  const HOST_WIDE_INT redzone_mask = ASAN_RED_ZONE_SIZE - 1;\n+\n+  tree last_alloca = get_last_alloca_addr ();\n+  tree callee = gimple_call_fndecl (call);\n+  tree old_size = gimple_call_arg (call, 0);\n+  tree ptr_type = gimple_call_lhs (call) ? TREE_TYPE (gimple_call_lhs (call))\n+\t\t\t\t\t : ptr_type_node;\n+  tree partial_size = NULL_TREE;\n+  bool alloca_with_align\n+    = DECL_FUNCTION_CODE (callee) == BUILT_IN_ALLOCA_WITH_ALIGN;\n+  unsigned int align\n+    = alloca_with_align ? tree_to_uhwi (gimple_call_arg (call, 1)) : 0;\n+\n+  /* If ALIGN > ASAN_RED_ZONE_SIZE, we embed left redzone into first ALIGN\n+     bytes of allocated space.  Otherwise, align alloca to ASAN_RED_ZONE_SIZE\n+     manually.  */\n+  align = MAX (align, ASAN_RED_ZONE_SIZE * BITS_PER_UNIT);\n+\n+  tree alloca_rz_mask = build_int_cst (size_type_node, redzone_mask);\n+  tree redzone_size = build_int_cst (size_type_node, ASAN_RED_ZONE_SIZE);\n+\n+  /* Extract lower bits from old_size.  */\n+  wide_int size_nonzero_bits = get_nonzero_bits (old_size);\n+  wide_int rz_mask\n+    = wi::uhwi (redzone_mask, wi::get_precision (size_nonzero_bits));\n+  wide_int old_size_lower_bits = wi::bit_and (size_nonzero_bits, rz_mask);\n+\n+  /* If alloca size is aligned to ASAN_RED_ZONE_SIZE, we don't need partial\n+     redzone.  Otherwise, compute its size here.  */\n+  if (wi::ne_p (old_size_lower_bits, 0))\n+    {\n+      /* misalign = size & (ASAN_RED_ZONE_SIZE - 1)\n+         partial_size = ASAN_RED_ZONE_SIZE - misalign.  */\n+      g = gimple_build_assign (make_ssa_name (size_type_node, NULL),\n+\t\t\t       BIT_AND_EXPR, old_size, alloca_rz_mask);\n+      gsi_insert_before (iter, g, GSI_SAME_STMT);\n+      tree misalign = gimple_assign_lhs (g);\n+      g = gimple_build_assign (make_ssa_name (size_type_node, NULL), MINUS_EXPR,\n+\t\t\t       redzone_size, misalign);\n+      gsi_insert_before (iter, g, GSI_SAME_STMT);\n+      partial_size = gimple_assign_lhs (g);\n+    }\n+\n+  /* additional_size = align + ASAN_RED_ZONE_SIZE.  */\n+  tree additional_size = build_int_cst (size_type_node, align / BITS_PER_UNIT\n+\t\t\t\t\t\t\t+ ASAN_RED_ZONE_SIZE);\n+  /* If alloca has partial redzone, include it to additional_size too.  */\n+  if (partial_size)\n+    {\n+      /* additional_size += partial_size.  */\n+      g = gimple_build_assign (make_ssa_name (size_type_node), PLUS_EXPR,\n+\t\t\t       partial_size, additional_size);\n+      gsi_insert_before (iter, g, GSI_SAME_STMT);\n+      additional_size = gimple_assign_lhs (g);\n+    }\n+\n+  /* new_size = old_size + additional_size.  */\n+  g = gimple_build_assign (make_ssa_name (size_type_node), PLUS_EXPR, old_size,\n+\t\t\t   additional_size);\n+  gsi_insert_before (iter, g, GSI_SAME_STMT);\n+  tree new_size = gimple_assign_lhs (g);\n+\n+  /* Build new __builtin_alloca call:\n+       new_alloca_with_rz = __builtin_alloca (new_size, align).  */\n+  tree fn = builtin_decl_implicit (BUILT_IN_ALLOCA_WITH_ALIGN);\n+  gg = gimple_build_call (fn, 2, new_size,\n+\t\t\t  build_int_cst (size_type_node, align));\n+  tree new_alloca_with_rz = make_ssa_name (ptr_type, gg);\n+  gimple_call_set_lhs (gg, new_alloca_with_rz);\n+  gsi_insert_before (iter, gg, GSI_SAME_STMT);\n+\n+  /* new_alloca = new_alloca_with_rz + align.  */\n+  g = gimple_build_assign (make_ssa_name (ptr_type), POINTER_PLUS_EXPR,\n+\t\t\t   new_alloca_with_rz,\n+\t\t\t   build_int_cst (size_type_node,\n+\t\t\t\t\t  align / BITS_PER_UNIT));\n+  gsi_insert_before (iter, g, GSI_SAME_STMT);\n+  tree new_alloca = gimple_assign_lhs (g);\n+\n+  /* Poison newly created alloca redzones:\n+      __asan_alloca_poison (new_alloca, old_size).  */\n+  fn = builtin_decl_implicit (BUILT_IN_ASAN_ALLOCA_POISON);\n+  gg = gimple_build_call (fn, 2, new_alloca, old_size);\n+  gsi_insert_before (iter, gg, GSI_SAME_STMT);\n+\n+  /* Save new_alloca_with_rz value into last_alloca to use it during\n+     allocas unpoisoning.  */\n+  g = gimple_build_assign (last_alloca, new_alloca_with_rz);\n+  gsi_insert_before (iter, g, GSI_SAME_STMT);\n+\n+  /* Finally, replace old alloca ptr with NEW_ALLOCA.  */\n+  replace_call_with_value (iter, new_alloca);\n+}\n+\n /* Return the memory references contained in a gimple statement\n    representing a builtin call that has to do with memory access.  */\n \n static bool\n-get_mem_refs_of_builtin_call (const gcall *call,\n+get_mem_refs_of_builtin_call (gcall *call,\n \t\t\t      asan_mem_ref *src0,\n \t\t\t      tree *src0_len,\n \t\t\t      bool *src0_is_store,\n@@ -544,7 +721,8 @@ get_mem_refs_of_builtin_call (const gcall *call,\n \t\t\t      tree *dst_len,\n \t\t\t      bool *dst_is_store,\n \t\t\t      bool *dest_is_deref,\n-\t\t\t      bool *intercepted_p)\n+\t\t\t      bool *intercepted_p,\n+\t\t\t      gimple_stmt_iterator *iter = NULL)\n {\n   gcc_checking_assert (gimple_call_builtin_p (call, BUILT_IN_NORMAL));\n \n@@ -603,6 +781,14 @@ get_mem_refs_of_builtin_call (const gcall *call,\n       len = gimple_call_lhs (call);\n       break;\n \n+    case BUILT_IN_STACK_RESTORE:\n+      handle_builtin_stack_restore (call, iter);\n+      break;\n+\n+    case BUILT_IN_ALLOCA_WITH_ALIGN:\n+    case BUILT_IN_ALLOCA:\n+      handle_builtin_alloca (call, iter);\n+      break;\n     /* And now the __atomic* and __sync builtins.\n        These are handled differently from the classical memory memory\n        access builtins above.  */\n@@ -1363,6 +1549,28 @@ asan_emit_stack_protection (rtx base, rtx pbase, unsigned int alignb,\n   return insns;\n }\n \n+/* Emit __asan_allocas_unpoison (top, bot) call.  The BASE parameter corresponds\n+   to BOT argument, for TOP virtual_stack_dynamic_rtx is used.  NEW_SEQUENCE\n+   indicates whether we're emitting new instructions sequence or not.  */\n+\n+rtx_insn *\n+asan_emit_allocas_unpoison (rtx top, rtx bot, rtx_insn *before)\n+{\n+  if (before)\n+    push_to_sequence (before);\n+  else\n+    start_sequence ();\n+  rtx ret = init_one_libfunc (\"__asan_allocas_unpoison\");\n+  ret = emit_library_call_value (ret, NULL_RTX, LCT_NORMAL, ptr_mode, 2, top,\n+\t\t\t\t TYPE_MODE (pointer_sized_int_node), bot,\n+\t\t\t\t TYPE_MODE (pointer_sized_int_node));\n+\n+  do_pending_stack_adjust ();\n+  rtx_insn *insns = get_insns ();\n+  end_sequence ();\n+  return insns;\n+}\n+\n /* Return true if DECL, a global var, might be overridden and needs\n    therefore a local alias.  */\n \n@@ -2002,7 +2210,7 @@ instrument_builtin_call (gimple_stmt_iterator *iter)\n \t\t\t\t    &src0, &src0_len, &src0_is_store,\n \t\t\t\t    &src1, &src1_len, &src1_is_store,\n \t\t\t\t    &dest, &dest_len, &dest_is_store,\n-\t\t\t\t    &dest_is_deref, &intercepted_p))\n+\t\t\t\t    &dest_is_deref, &intercepted_p, iter))\n     {\n       if (dest_is_deref)\n \t{\n@@ -3192,6 +3400,7 @@ asan_instrument (void)\n   if (shadow_ptr_types[0] == NULL_TREE)\n     asan_init_shadow_ptr_types ();\n   transform_statements ();\n+  last_alloca_addr = NULL_TREE;\n   return 0;\n }\n "}, {"sha": "4e8120ef76164d8114645a68942d27815ba04e6d", "filename": "gcc/asan.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3174bdf35c172f69daf08350401aa177f8f1498/gcc%2Fasan.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3174bdf35c172f69daf08350401aa177f8f1498/gcc%2Fasan.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fasan.h?ref=e3174bdf35c172f69daf08350401aa177f8f1498", "patch": "@@ -25,6 +25,7 @@ extern void asan_function_start (void);\n extern void asan_finish_file (void);\n extern rtx_insn *asan_emit_stack_protection (rtx, rtx, unsigned int,\n \t\t\t\t\t     HOST_WIDE_INT *, tree *, int);\n+extern rtx_insn *asan_emit_allocas_unpoison (rtx, rtx, rtx_insn *);\n extern bool asan_protect_global (tree);\n extern void initialize_sanitizer_builtins (void);\n extern tree asan_dynamic_init_call (bool);"}, {"sha": "608993afc1b6caba92a22e03f51a637c0b08e05e", "filename": "gcc/builtins.c", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3174bdf35c172f69daf08350401aa177f8f1498/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3174bdf35c172f69daf08350401aa177f8f1498/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=e3174bdf35c172f69daf08350401aa177f8f1498", "patch": "@@ -4962,6 +4962,26 @@ expand_builtin_alloca (tree exp)\n   return result;\n }\n \n+/* Emit a call to __asan_allocas_unpoison call in EXP.  Replace second argument\n+   of the call with virtual_stack_dynamic_rtx because in asan pass we emit a\n+   dummy value into second parameter relying on this function to perform the\n+   change.  See motivation for this in comment to handle_builtin_stack_restore\n+   function.  */\n+\n+static rtx\n+expand_asan_emit_allocas_unpoison (tree exp)\n+{\n+  tree arg0 = CALL_EXPR_ARG (exp, 0);\n+  rtx top = expand_expr (arg0, NULL_RTX, GET_MODE (virtual_stack_dynamic_rtx),\n+\t\t\t EXPAND_NORMAL);\n+  rtx ret = init_one_libfunc (\"__asan_allocas_unpoison\");\n+  ret = emit_library_call_value (ret, NULL_RTX, LCT_NORMAL, ptr_mode, 2, top,\n+\t\t\t\t TYPE_MODE (pointer_sized_int_node),\n+\t\t\t\t virtual_stack_dynamic_rtx,\n+\t\t\t\t TYPE_MODE (pointer_sized_int_node));\n+  return ret;\n+}\n+\n /* Expand a call to bswap builtin in EXP.\n    Return NULL_RTX if a normal call should be emitted rather than expanding the\n    function in-line.  If convenient, the result should be placed in TARGET.\n@@ -6763,6 +6783,9 @@ expand_builtin (tree exp, rtx target, rtx subtarget, machine_mode mode,\n \treturn target;\n       break;\n \n+    case BUILT_IN_ASAN_ALLOCAS_UNPOISON:\n+      return expand_asan_emit_allocas_unpoison (exp);\n+\n     case BUILT_IN_STACK_SAVE:\n       return expand_stack_save ();\n "}, {"sha": "dd7277f4a73013ac9b3c25fb50b01c24febd95b4", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3174bdf35c172f69daf08350401aa177f8f1498/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3174bdf35c172f69daf08350401aa177f8f1498/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=e3174bdf35c172f69daf08350401aa177f8f1498", "patch": "@@ -2241,6 +2241,11 @@ expand_used_vars (void)\n       expand_stack_vars (NULL, &data);\n     }\n \n+  if ((flag_sanitize & SANITIZE_ADDRESS) && cfun->calls_alloca)\n+    var_end_seq = asan_emit_allocas_unpoison (virtual_stack_dynamic_rtx,\n+\t\t\t\t\t      virtual_stack_vars_rtx,\n+\t\t\t\t\t      var_end_seq);\n+\n   fini_vars_expansion ();\n \n   /* If there were any artificial non-ignored vars without rtl"}, {"sha": "d94dc9cd563ca1d4b7d56dd443ef04ba7fd367de", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3174bdf35c172f69daf08350401aa177f8f1498/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3174bdf35c172f69daf08350401aa177f8f1498/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=e3174bdf35c172f69daf08350401aa177f8f1498", "patch": "@@ -571,7 +571,7 @@ gimplify_and_update_call_from_tree (gimple_stmt_iterator *si_p, tree expr)\n \n /* Replace the call at *GSI with the gimple value VAL.  */\n \n-static void\n+void\n replace_call_with_value (gimple_stmt_iterator *gsi, tree val)\n {\n   gimple *stmt = gsi_stmt (*gsi);"}, {"sha": "2cee38508fc23bab79e60fa3c7e41922f7a00489", "filename": "gcc/gimple-fold.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3174bdf35c172f69daf08350401aa177f8f1498/gcc%2Fgimple-fold.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3174bdf35c172f69daf08350401aa177f8f1498/gcc%2Fgimple-fold.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.h?ref=e3174bdf35c172f69daf08350401aa177f8f1498", "patch": "@@ -58,6 +58,7 @@ extern bool gimple_fold_builtin_sprintf (gimple_stmt_iterator *);\n extern bool gimple_fold_builtin_snprintf (gimple_stmt_iterator *);\n extern bool arith_code_with_undefined_signed_overflow (tree_code);\n extern gimple_seq rewrite_to_defined_overflow (gimple *);\n+extern void replace_call_with_value (gimple_stmt_iterator *, tree);\n \n /* gimple_build, functionally matching fold_buildN, outputs stmts\n    int the provided sequence, matching and simplifying them on-the-fly."}, {"sha": "1dc754124843f044ee22a5e8a829d5a30fb520d4", "filename": "gcc/internal-fn.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3174bdf35c172f69daf08350401aa177f8f1498/gcc%2Finternal-fn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3174bdf35c172f69daf08350401aa177f8f1498/gcc%2Finternal-fn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.c?ref=e3174bdf35c172f69daf08350401aa177f8f1498", "patch": "@@ -39,6 +39,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"stor-layout.h\"\n #include \"dojump.h\"\n #include \"expr.h\"\n+#include \"asan.h\"\n #include \"ubsan.h\"\n #include \"recog.h\"\n #include \"builtins.h\""}, {"sha": "91759a8957ac25f92b97f790a0551c1a508430e8", "filename": "gcc/sanitizer.def", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3174bdf35c172f69daf08350401aa177f8f1498/gcc%2Fsanitizer.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3174bdf35c172f69daf08350401aa177f8f1498/gcc%2Fsanitizer.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsanitizer.def?ref=e3174bdf35c172f69daf08350401aa177f8f1498", "patch": "@@ -171,6 +171,10 @@ DEF_SANITIZER_BUILTIN(BUILT_IN_ASAN_POISON_STACK_MEMORY,\n DEF_SANITIZER_BUILTIN(BUILT_IN_ASAN_UNPOISON_STACK_MEMORY,\n \t\t      \"__asan_unpoison_stack_memory\",\n \t\t      BT_FN_VOID_PTR_PTRMODE, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SANITIZER_BUILTIN(BUILT_IN_ASAN_ALLOCA_POISON, \"__asan_alloca_poison\",\n+\t\t      BT_FN_VOID_PTR_PTRMODE, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SANITIZER_BUILTIN(BUILT_IN_ASAN_ALLOCAS_UNPOISON, \"__asan_allocas_unpoison\",\n+\t\t      BT_FN_VOID_PTR_PTRMODE, ATTR_NOTHROW_LEAF_LIST)\n \n /* Thread Sanitizer */\n DEF_SANITIZER_BUILTIN(BUILT_IN_TSAN_INIT, \"__tsan_init\", "}, {"sha": "886689f6c9c04b81cf4d37d3661d002d4a517b68", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3174bdf35c172f69daf08350401aa177f8f1498/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3174bdf35c172f69daf08350401aa177f8f1498/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e3174bdf35c172f69daf08350401aa177f8f1498", "patch": "@@ -1,3 +1,14 @@\n+2017-07-06  Maxim Ostapenko  <m.ostapenko@samsung.com>\n+\n+\t* c-c++-common/asan/alloca_big_alignment.c: New test.\n+\t* c-c++-common/asan/alloca_detect_custom_size.c: Likewise.\n+\t* c-c++-common/asan/alloca_instruments_all_paddings.c: Likewise.\n+\t* c-c++-common/asan/alloca_loop_unpoisoning.c: Likewise.\n+\t* c-c++-common/asan/alloca_overflow_partial.c: Likewise.\n+\t* c-c++-common/asan/alloca_overflow_right.c: Likewise.\n+\t* c-c++-common/asan/alloca_safe_access.c: Likewise.\n+\t* c-c++-common/asan/alloca_underflow_left.c: Likewise.\n+\n 2017-07-06  Georg-Johann Lay  <avr@gjlay.de>\n \n \tPR target/81305"}, {"sha": "54f03b8e301be83b2614f39fc2caf5cb2bc0f59a", "filename": "gcc/testsuite/c-c++-common/asan/alloca_big_alignment.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3174bdf35c172f69daf08350401aa177f8f1498/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Falloca_big_alignment.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3174bdf35c172f69daf08350401aa177f8f1498/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Falloca_big_alignment.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Falloca_big_alignment.c?ref=e3174bdf35c172f69daf08350401aa177f8f1498", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do run } */\n+/* { dg-shouldfail \"asan\" } */\n+\n+#include <assert.h>\n+\n+volatile int ten = 10;\n+\n+__attribute__((noinline)) void foo(int index, int len) {\n+  volatile char str[len] __attribute__((aligned(128)));\n+  assert(!((long) str & 127L));\n+  str[index] = '1'; // BOOM\n+}\n+\n+int main() {\n+  foo(ten, ten);\n+  return 0;\n+}\n+\n+/* { dg-output \"WRITE of size 1 at 0x\\[0-9a-f\\]+ thread T0\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"    #0 0x\\[0-9a-f\\]+ +(in _*foo(\\[^\\n\\r]*alloca_big_alignment.c:11|\\[^\\n\\r]*:0)|\\[(\\]).*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*Address 0x\\[0-9a-f\\]+ is located in stack of thread T0.*(\\n|\\r\\n|\\r)\" */\n+/* { dg-output \"\\[^\\n\\r]*in foo.*alloca_big_alignment.c.*(\\n|\\r\\n|\\r)\" */"}, {"sha": "609dafe7bd84e02c8f9f4807488ea53111c4e91f", "filename": "gcc/testsuite/c-c++-common/asan/alloca_detect_custom_size.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3174bdf35c172f69daf08350401aa177f8f1498/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Falloca_detect_custom_size.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3174bdf35c172f69daf08350401aa177f8f1498/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Falloca_detect_custom_size.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Falloca_detect_custom_size.c?ref=e3174bdf35c172f69daf08350401aa177f8f1498", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-do run } */\n+/* { dg-shouldfail \"asan\" } */\n+\n+#include <assert.h>\n+\n+struct A {\n+  char a[3];\n+  int b[3];\n+};\n+\n+volatile int ten = 10;\n+\n+__attribute__((noinline)) void foo(int index, int len) {\n+  volatile struct A str[len] __attribute__((aligned(32)));\n+  assert(!((long) str & 31L));\n+  str[index].a[0] = '1'; // BOOM\n+}\n+\n+int main(int argc, char **argv) {\n+  foo(ten, ten);\n+  return 0;\n+}\n+\n+/* { dg-output \"WRITE of size 1 at 0x\\[0-9a-f\\]+ thread T0\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"    #0 0x\\[0-9a-f\\]+ +(in _*foo(\\[^\\n\\r]*alloca_detect_custom_size.c:16|\\[^\\n\\r]*:0)|\\[(\\]).*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*Address 0x\\[0-9a-f\\]+ is located in stack of thread T0.*(\\n|\\r\\n|\\r)\" */\n+/* { dg-output \"\\[^\\n\\r]*in foo.*alloca_detect_custom_size.c.*(\\n|\\r\\n|\\r)\" */"}, {"sha": "6b08c0bf6140995c2fb54f8dae7b8595cfc316d8", "filename": "gcc/testsuite/c-c++-common/asan/alloca_instruments_all_paddings.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3174bdf35c172f69daf08350401aa177f8f1498/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Falloca_instruments_all_paddings.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3174bdf35c172f69daf08350401aa177f8f1498/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Falloca_instruments_all_paddings.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Falloca_instruments_all_paddings.c?ref=e3174bdf35c172f69daf08350401aa177f8f1498", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do run } */\n+\n+#include \"sanitizer/asan_interface.h\"\n+#include <assert.h>\n+\n+__attribute__((noinline)) void foo(int index, int len) {\n+  volatile char str[len] __attribute__((aligned(32)));\n+  assert(!((long) str & 31L));\n+  char *q = (char *)__asan_region_is_poisoned((char *)str, 64);\n+  assert(q && ((q - str) == index));\n+}\n+\n+int main(int argc, char **argv) {\n+  for (int i = 1; i < 33; ++i)\n+    foo(i, i);\n+\n+  for (int i = 1; i < 33; ++i)\n+    foo(i, i);\n+\n+  return 0;\n+}"}, {"sha": "0ddadb9c3853c51ab5476f0f7958ecdb87e176ca", "filename": "gcc/testsuite/c-c++-common/asan/alloca_loop_unpoisoning.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3174bdf35c172f69daf08350401aa177f8f1498/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Falloca_loop_unpoisoning.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3174bdf35c172f69daf08350401aa177f8f1498/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Falloca_loop_unpoisoning.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Falloca_loop_unpoisoning.c?ref=e3174bdf35c172f69daf08350401aa177f8f1498", "patch": "@@ -0,0 +1,34 @@\n+/* { dg-do run } */\n+\n+/* This testcase checks that allocas and VLAs inside loop are correctly unpoisoned.  */\n+\n+#include <assert.h>\n+#include <stdint.h>\n+#include <stdlib.h>\n+#include <stdio.h>\n+#include \"sanitizer/asan_interface.h\"\n+\n+void *top, *bot;\n+volatile int thirty_two = 32;\n+\n+__attribute__((noinline)) void foo(int len) {\n+  char x;\n+  top = &x;\n+  volatile char array[len];\n+  assert(!((uintptr_t) array & 31L));\n+  alloca(len);\n+  for (int i = 0; i < thirty_two; ++i) {\n+    char array[i];\n+    bot = array;\n+    /* Just to prevent optimization.  */\n+    printf(\"%p\\n\", bot);\n+    assert(!((uintptr_t) bot & 31L));\n+  }\n+}\n+\n+int main(int argc, char **argv) {\n+  foo(thirty_two);\n+  void *q = __asan_region_is_poisoned(bot, (char *)top - (char *)bot);\n+  assert(!q);\n+  return 0;\n+}"}, {"sha": "9f4d0780bff3b24ef1a1c0000000c749835f8a17", "filename": "gcc/testsuite/c-c++-common/asan/alloca_overflow_partial.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3174bdf35c172f69daf08350401aa177f8f1498/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Falloca_overflow_partial.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3174bdf35c172f69daf08350401aa177f8f1498/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Falloca_overflow_partial.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Falloca_overflow_partial.c?ref=e3174bdf35c172f69daf08350401aa177f8f1498", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do run } */\n+/* { dg-shouldfail \"asan\" } */\n+\n+#include <assert.h>\n+\n+volatile const int ten = 10;\n+\n+__attribute__((noinline)) void foo(int index, int len) {\n+  volatile char str[len] __attribute__((aligned(32)));\n+  assert(!((long) str & 31L));\n+  str[index] = '1'; // BOOM\n+}\n+\n+int main(int argc, char **argv) {\n+  foo(ten, ten);\n+  return 0;\n+}\n+\n+/* { dg-output \"WRITE of size 1 at 0x\\[0-9a-f\\]+ thread T0\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"    #0 0x\\[0-9a-f\\]+ +(in _*foo(\\[^\\n\\r]*alloca_overflow_partial.c:11|\\[^\\n\\r]*:0)|\\[(\\]).*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*Address 0x\\[0-9a-f\\]+ is located in stack of thread T0.*(\\n|\\r\\n|\\r)\" */\n+/* { dg-output \"\\[^\\n\\r]*in foo.*alloca_overflow_partial.c.*(\\n|\\r\\n|\\r)\" */"}, {"sha": "085fdae350b6787d4046315ccb712dc0b19eabee", "filename": "gcc/testsuite/c-c++-common/asan/alloca_overflow_right.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3174bdf35c172f69daf08350401aa177f8f1498/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Falloca_overflow_right.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3174bdf35c172f69daf08350401aa177f8f1498/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Falloca_overflow_right.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Falloca_overflow_right.c?ref=e3174bdf35c172f69daf08350401aa177f8f1498", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do run } */\n+/* { dg-shouldfail \"asan\" } */\n+\n+#include <assert.h>\n+\n+volatile const int ten = 10;\n+\n+__attribute__((noinline)) void foo(int index, int len) {\n+  volatile char str[len] __attribute__((aligned(32)));\n+  assert(!((long) str & 31L));\n+  str[index] = '1'; // BOOM\n+}\n+\n+int main(int argc, char **argv) {\n+  foo(33, ten);\n+  return 0;\n+}\n+\n+/* { dg-output \"WRITE of size 1 at 0x\\[0-9a-f\\]+ thread T0\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"    #0 0x\\[0-9a-f\\]+ +(in _*foo(\\[^\\n\\r]*alloca_overflow_right.c:11|\\[^\\n\\r]*:0)|\\[(\\]).*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*Address 0x\\[0-9a-f\\]+ is located in stack of thread T0.*(\\n|\\r\\n|\\r)\" */\n+/* { dg-output \"\\[^\\n\\r]*in foo.*alloca_overflow_right.c.*(\\n|\\r\\n|\\r)\" */"}, {"sha": "92da1b2ed464ecae50132e208c09c87b8d8ad1c6", "filename": "gcc/testsuite/c-c++-common/asan/alloca_safe_access.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3174bdf35c172f69daf08350401aa177f8f1498/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Falloca_safe_access.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3174bdf35c172f69daf08350401aa177f8f1498/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Falloca_safe_access.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Falloca_safe_access.c?ref=e3174bdf35c172f69daf08350401aa177f8f1498", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do run } */\n+\n+#include <assert.h>\n+\n+__attribute__((noinline)) void foo(int index, int len) {\n+  volatile char str[len] __attribute__((aligned(32)));\n+  assert(!((long)str & 31L));\n+  str[index] = '1';\n+}\n+\n+int main(int argc, char **argv) {\n+  foo(4, 5);\n+  foo(39, 40);\n+  return 0;\n+}"}, {"sha": "fe2abe11461869b1e047cf625eaaa62d63d836a4", "filename": "gcc/testsuite/c-c++-common/asan/alloca_underflow_left.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3174bdf35c172f69daf08350401aa177f8f1498/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Falloca_underflow_left.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3174bdf35c172f69daf08350401aa177f8f1498/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Falloca_underflow_left.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Falloca_underflow_left.c?ref=e3174bdf35c172f69daf08350401aa177f8f1498", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do run } */\n+/* { dg-shouldfail \"asan\" } */\n+\n+#include <assert.h>\n+\n+volatile const int ten = 10;\n+\n+__attribute__((noinline)) void foo(int index, int len) {\n+  volatile char str[len] __attribute__((aligned(32)));\n+  assert(!((long) str & 31L));\n+  str[index] = '1'; // BOOM\n+}\n+\n+int main(int argc, char **argv) {\n+  foo(-1, ten);\n+  return 0;\n+}\n+\n+/* { dg-output \"WRITE of size 1 at 0x\\[0-9a-f\\]+ thread T0\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"    #0 0x\\[0-9a-f\\]+ +(in _*foo(\\[^\\n\\r]*alloca_underflow_left.c:11|\\[^\\n\\r]*:0)|\\[(\\]).*(\\n|\\r\\n|\\r)\" } */\n+/* { dg-output \"\\[^\\n\\r]*Address 0x\\[0-9a-f\\]+ is located in stack of thread T0.*(\\n|\\r\\n|\\r)\" */\n+/* { dg-output \"\\[^\\n\\r]*in foo.*alloca_underflow_left.c.*(\\n|\\r\\n|\\r)\" */"}]}