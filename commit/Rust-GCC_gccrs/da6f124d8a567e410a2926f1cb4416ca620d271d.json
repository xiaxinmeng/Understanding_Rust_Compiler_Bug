{"sha": "da6f124d8a567e410a2926f1cb4416ca620d271d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGE2ZjEyNGQ4YTU2N2U0MTBhMjkyNmYxY2I0NDE2Y2E2MjBkMjcxZA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2014-06-25T09:16:12Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2014-06-25T09:16:12Z"}, "message": "langhooks-def.h (LANG_HOOKS_OMP_CLAUSE_LINEAR_CTOR): Define.\n\n\t* langhooks-def.h (LANG_HOOKS_OMP_CLAUSE_LINEAR_CTOR): Define.\n\t(LANG_HOOKS_DECLS): Add it.\n\t* gimplify.c (gimplify_omp_for): Make sure OMP_CLAUSE_LINEAR_STEP\n\thas correct type.\n\t* tree.h (OMP_CLAUSE_LINEAR_ARRAY): Define.\n\t* langhooks.h (struct lang_hooks_for_decls): Add\n\tomp_clause_linear_ctor hook.\n\t* omp-low.c (lower_rec_input_clauses): Set max_vf even if\n\tOMP_CLAUSE_LINEAR_ARRAY is set.  Don't fold_convert\n\tOMP_CLAUSE_LINEAR_STEP.  For OMP_CLAUSE_LINEAR_ARRAY in\n\tcombined simd loop use omp_clause_linear_ctor hook.\ngcc/c/\n\t* c-typeck.c (c_finish_omp_clauses): Make sure\n\tOMP_CLAUSE_LINEAR_STEP has correct type.\ngcc/cp/\n\t* semantics.c (finish_omp_clauses): Make sure\n\tOMP_CLAUSE_LINEAR_STEP has correct type.\ngcc/fortran/\n\t* trans.h (gfc_omp_clause_linear_ctor): New prototype.\n\t* trans-openmp.c (gfc_omp_linear_clause_add_loop,\n\tgfc_omp_clause_linear_ctor): New functions.\n\t(gfc_trans_omp_clauses): Make sure OMP_CLAUSE_LINEAR_STEP has\n\tcorrect type.  Set OMP_CLAUSE_LINEAR_ARRAY flag if needed.\n\t* f95-lang.c (LANG_HOOKS_OMP_CLAUSE_LINEAR_CTOR): Redefine.\nlibgomp/\n\t* testsuite/libgomp.fortran/simd5.f90: New test.\n\t* testsuite/libgomp.fortran/simd6.f90: New test.\n\t* testsuite/libgomp.fortran/simd7.f90: New test.\n\nFrom-SVN: r211971", "tree": {"sha": "553a56ba818b9c31b883fbfc783c1b85ead87337", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/553a56ba818b9c31b883fbfc783c1b85ead87337"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/da6f124d8a567e410a2926f1cb4416ca620d271d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da6f124d8a567e410a2926f1cb4416ca620d271d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/da6f124d8a567e410a2926f1cb4416ca620d271d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da6f124d8a567e410a2926f1cb4416ca620d271d/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d49f446ecd2dbe68081d25da06a528c7f2198efe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d49f446ecd2dbe68081d25da06a528c7f2198efe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d49f446ecd2dbe68081d25da06a528c7f2198efe"}], "stats": {"total": 678, "additions": 658, "deletions": 20}, "files": [{"sha": "dcbb23bd4b2f4a421b973441c05d48d75cd2f2f0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da6f124d8a567e410a2926f1cb4416ca620d271d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da6f124d8a567e410a2926f1cb4416ca620d271d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=da6f124d8a567e410a2926f1cb4416ca620d271d", "patch": "@@ -1,3 +1,17 @@\n+2014-06-25  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* langhooks-def.h (LANG_HOOKS_OMP_CLAUSE_LINEAR_CTOR): Define.\n+\t(LANG_HOOKS_DECLS): Add it.\n+\t* gimplify.c (gimplify_omp_for): Make sure OMP_CLAUSE_LINEAR_STEP\n+\thas correct type.\n+\t* tree.h (OMP_CLAUSE_LINEAR_ARRAY): Define.\n+\t* langhooks.h (struct lang_hooks_for_decls): Add\n+\tomp_clause_linear_ctor hook.\n+\t* omp-low.c (lower_rec_input_clauses): Set max_vf even if\n+\tOMP_CLAUSE_LINEAR_ARRAY is set.  Don't fold_convert\n+\tOMP_CLAUSE_LINEAR_STEP.  For OMP_CLAUSE_LINEAR_ARRAY in\n+\tcombined simd loop use omp_clause_linear_ctor hook.\n+\n 2014-06-24  Cong Hou  <congh@google.com>\n \n \t* tree-vect-patterns.c (vect_recog_sad_pattern): New function for SAD"}, {"sha": "955828c03d30c2e99e8f1309e12cd10daa94e056", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da6f124d8a567e410a2926f1cb4416ca620d271d/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da6f124d8a567e410a2926f1cb4416ca620d271d/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=da6f124d8a567e410a2926f1cb4416ca620d271d", "patch": "@@ -1,3 +1,8 @@\n+2014-06-25  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* c-typeck.c (c_finish_omp_clauses): Make sure\n+\tOMP_CLAUSE_LINEAR_STEP has correct type.\n+\n 2014-06-24  Trevor Saunders  <tsaunders@mozilla.com>\n \n \t* c-decl.c: Adjust."}, {"sha": "4deeae76a073257199a0068566ae9e5e1405cee4", "filename": "gcc/c/c-typeck.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da6f124d8a567e410a2926f1cb4416ca620d271d/gcc%2Fc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da6f124d8a567e410a2926f1cb4416ca620d271d/gcc%2Fc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.c?ref=da6f124d8a567e410a2926f1cb4416ca620d271d", "patch": "@@ -12005,6 +12005,9 @@ c_finish_omp_clauses (tree clauses)\n \t\ts = size_one_node;\n \t      OMP_CLAUSE_LINEAR_STEP (c) = s;\n \t    }\n+\t  else\n+\t    OMP_CLAUSE_LINEAR_STEP (c)\n+\t      = fold_convert (TREE_TYPE (t), OMP_CLAUSE_LINEAR_STEP (c));\n \t  goto check_dup_generic;\n \n \tcheck_dup_generic:"}, {"sha": "99bca4967bf6631bf886336093a10e2b185b2a22", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da6f124d8a567e410a2926f1cb4416ca620d271d/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da6f124d8a567e410a2926f1cb4416ca620d271d/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=da6f124d8a567e410a2926f1cb4416ca620d271d", "patch": "@@ -1,3 +1,8 @@\n+2014-06-25  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* semantics.c (finish_omp_clauses): Make sure\n+\tOMP_CLAUSE_LINEAR_STEP has correct type.\n+\n 2014-06-24  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* class.c (check_methods, create_vtable_ptr, determine_key_method,"}, {"sha": "241884cfffec944160535736772d2f694b39a229", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da6f124d8a567e410a2926f1cb4416ca620d271d/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da6f124d8a567e410a2926f1cb4416ca620d271d/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=da6f124d8a567e410a2926f1cb4416ca620d271d", "patch": "@@ -5287,6 +5287,8 @@ finish_omp_clauses (tree clauses)\n \t\t\t  break;\n \t\t\t}\n \t\t    }\n+\t\t  else\n+\t\t    t = fold_convert (TREE_TYPE (OMP_CLAUSE_DECL (c)), t);\n \t\t}\n \t      OMP_CLAUSE_LINEAR_STEP (c) = t;\n \t    }"}, {"sha": "b4bbb0a8a498115549f0012337a3af1db4927e12", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da6f124d8a567e410a2926f1cb4416ca620d271d/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da6f124d8a567e410a2926f1cb4416ca620d271d/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=da6f124d8a567e410a2926f1cb4416ca620d271d", "patch": "@@ -1,3 +1,12 @@\n+2014-06-25  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* trans.h (gfc_omp_clause_linear_ctor): New prototype.\n+\t* trans-openmp.c (gfc_omp_linear_clause_add_loop,\n+\tgfc_omp_clause_linear_ctor): New functions.\n+\t(gfc_trans_omp_clauses): Make sure OMP_CLAUSE_LINEAR_STEP has\n+\tcorrect type.  Set OMP_CLAUSE_LINEAR_ARRAY flag if needed.\n+\t* f95-lang.c (LANG_HOOKS_OMP_CLAUSE_LINEAR_CTOR): Redefine.\n+\n 2014-06-24  Jakub Jelinek  <jakub@redhat.com>\n \n \t* dump-parse-tree.c (show_omp_namelist): Use n->udr->udr instead"}, {"sha": "83f7eb2238dd9086ac17f17c11453f3146cf5932", "filename": "gcc/fortran/f95-lang.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da6f124d8a567e410a2926f1cb4416ca620d271d/gcc%2Ffortran%2Ff95-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da6f124d8a567e410a2926f1cb4416ca620d271d/gcc%2Ffortran%2Ff95-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ff95-lang.c?ref=da6f124d8a567e410a2926f1cb4416ca620d271d", "patch": "@@ -126,6 +126,7 @@ static const struct attribute_spec gfc_attribute_table[] =\n #undef LANG_HOOKS_OMP_CLAUSE_DEFAULT_CTOR\n #undef LANG_HOOKS_OMP_CLAUSE_COPY_CTOR\n #undef LANG_HOOKS_OMP_CLAUSE_ASSIGN_OP\n+#undef LANG_HOOKS_OMP_CLAUSE_LINEAR_CTOR\n #undef LANG_HOOKS_OMP_CLAUSE_DTOR\n #undef LANG_HOOKS_OMP_FINISH_CLAUSE\n #undef LANG_HOOKS_OMP_DISREGARD_VALUE_EXPR\n@@ -158,6 +159,7 @@ static const struct attribute_spec gfc_attribute_table[] =\n #define LANG_HOOKS_OMP_CLAUSE_DEFAULT_CTOR\tgfc_omp_clause_default_ctor\n #define LANG_HOOKS_OMP_CLAUSE_COPY_CTOR\t\tgfc_omp_clause_copy_ctor\n #define LANG_HOOKS_OMP_CLAUSE_ASSIGN_OP\t\tgfc_omp_clause_assign_op\n+#define LANG_HOOKS_OMP_CLAUSE_LINEAR_CTOR\tgfc_omp_clause_linear_ctor\n #define LANG_HOOKS_OMP_CLAUSE_DTOR\t\tgfc_omp_clause_dtor\n #define LANG_HOOKS_OMP_FINISH_CLAUSE\t\tgfc_omp_finish_clause\n #define LANG_HOOKS_OMP_DISREGARD_VALUE_EXPR\tgfc_omp_disregard_value_expr"}, {"sha": "da01a9034cb5126b679c488c15cc38725de4631b", "filename": "gcc/fortran/trans-openmp.c", "status": "modified", "additions": 136, "deletions": 1, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da6f124d8a567e410a2926f1cb4416ca620d271d/gcc%2Ffortran%2Ftrans-openmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da6f124d8a567e410a2926f1cb4416ca620d271d/gcc%2Ffortran%2Ftrans-openmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-openmp.c?ref=da6f124d8a567e410a2926f1cb4416ca620d271d", "patch": "@@ -822,6 +822,137 @@ gfc_omp_clause_assign_op (tree clause, tree dest, tree src)\n   return gfc_finish_block (&block);\n }\n \n+static void\n+gfc_omp_linear_clause_add_loop (stmtblock_t *block, tree dest, tree src,\n+\t\t\t\ttree add, tree nelems)\n+{\n+  stmtblock_t tmpblock;\n+  tree desta, srca, index = gfc_create_var (gfc_array_index_type, \"S\");\n+  nelems = gfc_evaluate_now (nelems, block);\n+\n+  gfc_init_block (&tmpblock);\n+  if (TREE_CODE (TREE_TYPE (dest)) == ARRAY_TYPE)\n+    {\n+      desta = gfc_build_array_ref (dest, index, NULL);\n+      srca = gfc_build_array_ref (src, index, NULL);\n+    }\n+  else\n+    {\n+      gcc_assert (POINTER_TYPE_P (TREE_TYPE (dest)));\n+      tree idx = fold_build2 (MULT_EXPR, sizetype,\n+\t\t\t      fold_convert (sizetype, index),\n+\t\t\t      TYPE_SIZE_UNIT (TREE_TYPE (TREE_TYPE (dest))));\n+      desta = build_fold_indirect_ref (fold_build2 (POINTER_PLUS_EXPR,\n+\t\t\t\t\t\t    TREE_TYPE (dest), dest,\n+\t\t\t\t\t\t    idx));\n+      srca = build_fold_indirect_ref (fold_build2 (POINTER_PLUS_EXPR,\n+\t\t\t\t\t\t   TREE_TYPE (src), src,\n+\t\t\t\t\t\t    idx));\n+    }\n+  gfc_add_modify (&tmpblock, desta,\n+\t\t  fold_build2 (PLUS_EXPR, TREE_TYPE (desta),\n+\t\t\t       srca, add));\n+\n+  gfc_loopinfo loop;\n+  gfc_init_loopinfo (&loop);\n+  loop.dimen = 1;\n+  loop.from[0] = gfc_index_zero_node;\n+  loop.loopvar[0] = index;\n+  loop.to[0] = nelems;\n+  gfc_trans_scalarizing_loops (&loop, &tmpblock);\n+  gfc_add_block_to_block (block, &loop.pre);\n+}\n+\n+/* Build and return code for a constructor of DEST that initializes\n+   it to SRC plus ADD (ADD is scalar integer).  */\n+\n+tree\n+gfc_omp_clause_linear_ctor (tree clause, tree dest, tree src, tree add)\n+{\n+  tree type = TREE_TYPE (dest), ptr, size, nelems = NULL_TREE;\n+  stmtblock_t block;\n+\n+  gcc_assert (OMP_CLAUSE_CODE (clause) == OMP_CLAUSE_LINEAR);\n+\n+  gfc_start_block (&block);\n+  add = gfc_evaluate_now (add, &block);\n+\n+  if ((! GFC_DESCRIPTOR_TYPE_P (type)\n+       || GFC_TYPE_ARRAY_AKIND (type) != GFC_ARRAY_ALLOCATABLE)\n+      && !GFC_DECL_GET_SCALAR_ALLOCATABLE (OMP_CLAUSE_DECL (clause)))\n+    {\n+      gcc_assert (TREE_CODE (type) == ARRAY_TYPE);\n+      if (!TYPE_DOMAIN (type)\n+\t  || TYPE_MAX_VALUE (TYPE_DOMAIN (type)) == NULL_TREE\n+\t  || TYPE_MIN_VALUE (TYPE_DOMAIN (type)) == error_mark_node\n+\t  || TYPE_MAX_VALUE (TYPE_DOMAIN (type)) == error_mark_node)\n+\t{\n+\t  nelems = fold_build2 (EXACT_DIV_EXPR, sizetype,\n+\t\t\t\tTYPE_SIZE_UNIT (type),\n+\t\t\t\tTYPE_SIZE_UNIT (TREE_TYPE (type)));\n+\t  nelems = size_binop (MINUS_EXPR, nelems, size_one_node);\n+\t}\n+      else\n+\tnelems = array_type_nelts (type);\n+      nelems = fold_convert (gfc_array_index_type, nelems);\n+\n+      gfc_omp_linear_clause_add_loop (&block, dest, src, add, nelems);\n+      return gfc_finish_block (&block);\n+    }\n+\n+  /* Allocatable arrays in LINEAR clauses need to be allocated\n+     and copied from SRC.  */\n+  gfc_add_modify (&block, dest, src);\n+  if (GFC_DESCRIPTOR_TYPE_P (type))\n+    {\n+      tree rank = gfc_rank_cst[GFC_TYPE_ARRAY_RANK (type) - 1];\n+      size = gfc_conv_descriptor_ubound_get (dest, rank);\n+      size = fold_build2_loc (input_location, MINUS_EXPR, gfc_array_index_type,\n+\t\t\t      size,\n+\t\t\t      gfc_conv_descriptor_lbound_get (dest, rank));\n+      size = fold_build2_loc (input_location, PLUS_EXPR, gfc_array_index_type,\n+\t\t\t      size, gfc_index_one_node);\n+      if (GFC_TYPE_ARRAY_RANK (type) > 1)\n+\tsize = fold_build2_loc (input_location, MULT_EXPR,\n+\t\t\t\tgfc_array_index_type, size,\n+\t\t\t\tgfc_conv_descriptor_stride_get (dest, rank));\n+      tree esize = fold_convert (gfc_array_index_type,\n+\t\t\t\t TYPE_SIZE_UNIT (gfc_get_element_type (type)));\n+      nelems = gfc_evaluate_now (unshare_expr (size), &block);\n+      size = fold_build2_loc (input_location, MULT_EXPR, gfc_array_index_type,\n+\t\t\t      nelems, unshare_expr (esize));\n+      size = gfc_evaluate_now (fold_convert (size_type_node, size),\n+\t\t\t       &block);\n+      nelems = fold_build2_loc (input_location, MINUS_EXPR,\n+\t\t\t\tgfc_array_index_type, nelems,\n+\t\t\t\tgfc_index_one_node);\n+    }\n+  else\n+    size = fold_convert (size_type_node, TYPE_SIZE_UNIT (TREE_TYPE (type)));\n+  ptr = gfc_create_var (pvoid_type_node, NULL);\n+  gfc_allocate_using_malloc (&block, ptr, size, NULL_TREE);\n+  if (GFC_DESCRIPTOR_TYPE_P (type))\n+    {\n+      gfc_conv_descriptor_data_set (&block, unshare_expr (dest), ptr);\n+      tree etype = gfc_get_element_type (type);\n+      ptr = fold_convert (build_pointer_type (etype), ptr);\n+      tree srcptr = gfc_conv_descriptor_data_get (unshare_expr (src));\n+      srcptr = fold_convert (build_pointer_type (etype), srcptr);\n+      gfc_omp_linear_clause_add_loop (&block, ptr, srcptr, add, nelems);\n+    }\n+  else\n+    {\n+      gfc_add_modify (&block, unshare_expr (dest),\n+\t\t      fold_convert (TREE_TYPE (dest), ptr));\n+      ptr = fold_convert (TREE_TYPE (dest), ptr);\n+      tree dstm = build_fold_indirect_ref (ptr);\n+      tree srcm = build_fold_indirect_ref (unshare_expr (src));\n+      gfc_add_modify (&block, dstm,\n+\t\t      fold_build2 (PLUS_EXPR, TREE_TYPE (add), srcm, add));\n+    }\n+  return gfc_finish_block (&block);\n+}\n+\n /* Build and return code destructing DECL.  Return NULL if nothing\n    to be done.  */\n \n@@ -1667,7 +1798,11 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n \t\t\t\tgfc_add_block_to_block (block, &se.post);\n \t\t\t      }\n \t\t\t  }\n-\t\t\tOMP_CLAUSE_LINEAR_STEP (node) = last_step;\n+\t\t\tOMP_CLAUSE_LINEAR_STEP (node)\n+\t\t\t  = fold_convert (gfc_typenode_for_spec (&n->sym->ts),\n+\t\t\t\t\t  last_step);\n+\t\t\tif (n->sym->attr.dimension || n->sym->attr.allocatable)\n+\t\t\t  OMP_CLAUSE_LINEAR_ARRAY (node) = 1;\n \t\t\tomp_clauses = gfc_trans_add_clause (node, omp_clauses);\n \t\t      }\n \t\t  }"}, {"sha": "472b8419b9630c0f973bfc161b0204566c547d96", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da6f124d8a567e410a2926f1cb4416ca620d271d/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da6f124d8a567e410a2926f1cb4416ca620d271d/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=da6f124d8a567e410a2926f1cb4416ca620d271d", "patch": "@@ -670,6 +670,7 @@ tree gfc_omp_report_decl (tree);\n tree gfc_omp_clause_default_ctor (tree, tree, tree);\n tree gfc_omp_clause_copy_ctor (tree, tree, tree);\n tree gfc_omp_clause_assign_op (tree, tree, tree);\n+tree gfc_omp_clause_linear_ctor (tree, tree, tree, tree);\n tree gfc_omp_clause_dtor (tree, tree);\n void gfc_omp_finish_clause (tree, gimple_seq *);\n bool gfc_omp_disregard_value_expr (tree, bool);"}, {"sha": "f3c7d610e3f1501943f242744e419c00bc4d52c6", "filename": "gcc/gimplify.c", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da6f124d8a567e410a2926f1cb4416ca620d271d/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da6f124d8a567e410a2926f1cb4416ca620d271d/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=da6f124d8a567e410a2926f1cb4416ca620d271d", "patch": "@@ -6913,8 +6913,8 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n \tcase POSTINCREMENT_EXPR:\n \t  {\n \t    tree decl = TREE_OPERAND (t, 0);\n-\t    // c_omp_for_incr_canonicalize_ptr() should have been\n-\t    // called to massage things appropriately.\n+\t    /* c_omp_for_incr_canonicalize_ptr() should have been\n+\t       called to massage things appropriately.  */\n \t    gcc_assert (!POINTER_TYPE_P (TREE_TYPE (decl)));\n \n \t    if (orig_for_stmt != for_stmt)\n@@ -6930,6 +6930,9 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n \n \tcase PREDECREMENT_EXPR:\n \tcase POSTDECREMENT_EXPR:\n+\t  /* c_omp_for_incr_canonicalize_ptr() should have been\n+\t     called to massage things appropriately.  */\n+\t  gcc_assert (!POINTER_TYPE_P (TREE_TYPE (decl)));\n \t  if (orig_for_stmt != for_stmt)\n \t    break;\n \t  t = build_int_cst (TREE_TYPE (decl), -1);\n@@ -6970,12 +6973,16 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n \t  ret = MIN (ret, tret);\n \t  if (c)\n \t    {\n-\t      OMP_CLAUSE_LINEAR_STEP (c) = TREE_OPERAND (t, 1);\n+\t      tree step = TREE_OPERAND (t, 1);\n+\t      tree stept = TREE_TYPE (decl);\n+\t      if (POINTER_TYPE_P (stept))\n+\t\tstept = sizetype;\n+\t      step = fold_convert (stept, step);\n \t      if (TREE_CODE (t) == MINUS_EXPR)\n+\t\tstep = fold_build1 (NEGATE_EXPR, stept, step);\n+\t      OMP_CLAUSE_LINEAR_STEP (c) = step;\n+\t      if (step != TREE_OPERAND (t, 1))\n \t\t{\n-\t\t  t = TREE_OPERAND (t, 1);\n-\t\t  OMP_CLAUSE_LINEAR_STEP (c)\n-\t\t    = fold_build1 (NEGATE_EXPR, TREE_TYPE (t), t);\n \t\t  tret = gimplify_expr (&OMP_CLAUSE_LINEAR_STEP (c),\n \t\t\t\t\t&for_pre_body, NULL,\n \t\t\t\t\tis_gimple_val, fb_rvalue);"}, {"sha": "e77d2d9100e3bc6614e5e75e5d33a15ade5c35c0", "filename": "gcc/langhooks-def.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da6f124d8a567e410a2926f1cb4416ca620d271d/gcc%2Flanghooks-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da6f124d8a567e410a2926f1cb4416ca620d271d/gcc%2Flanghooks-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks-def.h?ref=da6f124d8a567e410a2926f1cb4416ca620d271d", "patch": "@@ -215,6 +215,7 @@ extern tree lhd_make_node (enum tree_code);\n #define LANG_HOOKS_OMP_CLAUSE_DEFAULT_CTOR hook_tree_tree_tree_tree_null\n #define LANG_HOOKS_OMP_CLAUSE_COPY_CTOR lhd_omp_assignment\n #define LANG_HOOKS_OMP_CLAUSE_ASSIGN_OP lhd_omp_assignment\n+#define LANG_HOOKS_OMP_CLAUSE_LINEAR_CTOR NULL\n #define LANG_HOOKS_OMP_CLAUSE_DTOR hook_tree_tree_tree_null\n #define LANG_HOOKS_OMP_FINISH_CLAUSE lhd_omp_finish_clause\n \n@@ -238,6 +239,7 @@ extern tree lhd_make_node (enum tree_code);\n   LANG_HOOKS_OMP_CLAUSE_DEFAULT_CTOR, \\\n   LANG_HOOKS_OMP_CLAUSE_COPY_CTOR, \\\n   LANG_HOOKS_OMP_CLAUSE_ASSIGN_OP, \\\n+  LANG_HOOKS_OMP_CLAUSE_LINEAR_CTOR, \\\n   LANG_HOOKS_OMP_CLAUSE_DTOR, \\\n   LANG_HOOKS_OMP_FINISH_CLAUSE \\\n }"}, {"sha": "72fa85ec0bb4e8819aab4edf73c2c33e1dbfebe6", "filename": "gcc/langhooks.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da6f124d8a567e410a2926f1cb4416ca620d271d/gcc%2Flanghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da6f124d8a567e410a2926f1cb4416ca620d271d/gcc%2Flanghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.h?ref=da6f124d8a567e410a2926f1cb4416ca620d271d", "patch": "@@ -225,6 +225,10 @@ struct lang_hooks_for_decls\n   /* Similarly, except use an assignment operator instead.  */\n   tree (*omp_clause_assign_op) (tree clause, tree dst, tree src);\n \n+  /* Build and return code for a constructor of DST that sets it to\n+     SRC + ADD.  */\n+  tree (*omp_clause_linear_ctor) (tree clause, tree dst, tree src, tree add);\n+\n   /* Build and return code destructing DECL.  Return NULL if nothing\n      to be done.  */\n   tree (*omp_clause_dtor) (tree clause, tree decl);"}, {"sha": "e1bf34d8f87ec9e2cd3d820b38b03ece1833bbb9", "filename": "gcc/omp-low.c", "status": "modified", "additions": 20, "deletions": 13, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da6f124d8a567e410a2926f1cb4416ca620d271d/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da6f124d8a567e410a2926f1cb4416ca620d271d/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=da6f124d8a567e410a2926f1cb4416ca620d271d", "patch": "@@ -3083,11 +3083,14 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n     for (c = clauses; c ; c = OMP_CLAUSE_CHAIN (c))\n       switch (OMP_CLAUSE_CODE (c))\n \t{\n+\tcase OMP_CLAUSE_LINEAR:\n+\t  if (OMP_CLAUSE_LINEAR_ARRAY (c))\n+\t    max_vf = 1;\n+\t  /* FALLTHRU */\n \tcase OMP_CLAUSE_REDUCTION:\n \tcase OMP_CLAUSE_PRIVATE:\n \tcase OMP_CLAUSE_FIRSTPRIVATE:\n \tcase OMP_CLAUSE_LASTPRIVATE:\n-\tcase OMP_CLAUSE_LINEAR:\n \t  if (is_variable_sized (OMP_CLAUSE_DECL (c)))\n \t    max_vf = 1;\n \t  break;\n@@ -3413,14 +3416,12 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t\t  if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_LINEAR\n \t\t      && gimple_omp_for_combined_into_p (ctx->stmt))\n \t\t    {\n-\t\t      tree stept = POINTER_TYPE_P (TREE_TYPE (x))\n-\t\t\t\t   ? sizetype : TREE_TYPE (x);\n-\t\t      tree t = fold_convert (stept,\n-\t\t\t\t\t     OMP_CLAUSE_LINEAR_STEP (c));\n-\t\t      tree c = find_omp_clause (clauses,\n-\t\t\t\t\t\tOMP_CLAUSE__LOOPTEMP_);\n-\t\t      gcc_assert (c);\n-\t\t      tree l = OMP_CLAUSE_DECL (c);\n+\t\t      tree t = OMP_CLAUSE_LINEAR_STEP (c);\n+\t\t      tree stept = TREE_TYPE (t);\n+\t\t      tree ct = find_omp_clause (clauses,\n+\t\t\t\t\t\t OMP_CLAUSE__LOOPTEMP_);\n+\t\t      gcc_assert (ct);\n+\t\t      tree l = OMP_CLAUSE_DECL (ct);\n \t\t      tree n1 = fd->loop.n1;\n \t\t      tree step = fd->loop.step;\n \t\t      tree itype = TREE_TYPE (l);\n@@ -3437,6 +3438,15 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t\t\tl = fold_build2 (TRUNC_DIV_EXPR, itype, l, step);\n \t\t      t = fold_build2 (MULT_EXPR, stept,\n \t\t\t\t       fold_convert (stept, l), t);\n+\n+\t\t      if (OMP_CLAUSE_LINEAR_ARRAY (c))\n+\t\t\t{\n+\t\t\t  x = lang_hooks.decls.omp_clause_linear_ctor\n+\t\t\t\t\t\t\t(c, new_var, x, t);\n+\t\t\t  gimplify_and_add (x, ilist);\n+\t\t\t  goto do_dtor;\n+\t\t\t}\n+\n \t\t      if (POINTER_TYPE_P (TREE_TYPE (x)))\n \t\t\tx = fold_build2 (POINTER_PLUS_EXPR,\n \t\t\t\t\t TREE_TYPE (x), x, t);\n@@ -3460,10 +3470,7 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t\t\t    = gimple_build_assign (unshare_expr (lvar), iv);\n \t\t\t  gsi_insert_before_without_update (&gsi, g,\n \t\t\t\t\t\t\t    GSI_SAME_STMT);\n-\t\t\t  tree stept = POINTER_TYPE_P (TREE_TYPE (iv))\n-\t\t\t\t       ? sizetype : TREE_TYPE (iv);\n-\t\t\t  tree t = fold_convert (stept,\n-\t\t\t\t\t\t OMP_CLAUSE_LINEAR_STEP (c));\n+\t\t\t  tree t = OMP_CLAUSE_LINEAR_STEP (c);\n \t\t\t  enum tree_code code = PLUS_EXPR;\n \t\t\t  if (POINTER_TYPE_P (TREE_TYPE (new_var)))\n \t\t\t    code = POINTER_PLUS_EXPR;"}, {"sha": "a80fa3864083e07d17d7c95eecb8074d4460fe01", "filename": "gcc/tree.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da6f124d8a567e410a2926f1cb4416ca620d271d/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da6f124d8a567e410a2926f1cb4416ca620d271d/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=da6f124d8a567e410a2926f1cb4416ca620d271d", "patch": "@@ -1330,6 +1330,11 @@ extern void protected_set_expr_location (tree, location_t);\n #define OMP_CLAUSE_LINEAR_VARIABLE_STRIDE(NODE) \\\n   TREE_PROTECTED (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_LINEAR))\n \n+/* True if a LINEAR clause is for an array or allocatable variable that\n+   needs special handling by the frontend.  */\n+#define OMP_CLAUSE_LINEAR_ARRAY(NODE) \\\n+  (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_LINEAR)->base.deprecated_flag)\n+\n #define OMP_CLAUSE_LINEAR_STEP(NODE) \\\n   OMP_CLAUSE_OPERAND (OMP_CLAUSE_SUBCODE_CHECK (NODE, OMP_CLAUSE_LINEAR), 1)\n "}, {"sha": "6745b3e75e8680039903a6b7304e6cb12e275c18", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da6f124d8a567e410a2926f1cb4416ca620d271d/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da6f124d8a567e410a2926f1cb4416ca620d271d/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=da6f124d8a567e410a2926f1cb4416ca620d271d", "patch": "@@ -1,3 +1,9 @@\n+2014-06-25  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* testsuite/libgomp.fortran/simd5.f90: New test.\n+\t* testsuite/libgomp.fortran/simd6.f90: New test.\n+\t* testsuite/libgomp.fortran/simd7.f90: New test.\n+\n 2014-06-24  Jakub Jelinek  <jakub@redhat.com>\n \n \t* testsuite/libgomp.c/for-2.c: Define SC to static for"}, {"sha": "7a5efecac069741b94da6885697133807e0b4367", "filename": "libgomp/testsuite/libgomp.fortran/simd5.f90", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da6f124d8a567e410a2926f1cb4416ca620d271d/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fsimd5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da6f124d8a567e410a2926f1cb4416ca620d271d/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fsimd5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fsimd5.f90?ref=da6f124d8a567e410a2926f1cb4416ca620d271d", "patch": "@@ -0,0 +1,124 @@\n+! { dg-do run }\n+! { dg-additional-options \"-msse2\" { target sse2_runtime } }\n+! { dg-additional-options \"-mavx\" { target avx_runtime } }\n+\n+  integer :: i, j, b, c\n+  c = 0\n+  i = 4\n+  j = 4\n+  b = 7\n+!$omp simd linear(b:2) reduction(+:c)\n+  do i = 0, 63\n+    c = c + b - (7 + 2 * i)\n+    b = b + 2\n+  end do\n+  if (c /= 0 .or. i /= 64 .or. b /= 7 + 64 * 2) call abort\n+  i = 4\n+  j = 4\n+  b = 7\n+!$omp simd linear(b:3) reduction(+:c)\n+  do i = 0, 63, 4\n+    c = c + b - (7 + i / 4 * 3)\n+    b = b + 3\n+  end do\n+  if (c /= 0 .or. i /= 64 .or. b /= 7 + 16 * 3) call abort\n+  i = 4\n+  j = 4\n+  b = 7\n+!$omp simd linear(i) linear(b:2) reduction(+:c)\n+  do i = 0, 63\n+    c = c + b - (7 + 2 * i)\n+    b = b + 2\n+  end do\n+  if (c /= 0 .or. i /= 64 .or. b /= 7 + 64 * 2) call abort\n+  i = 4\n+  j = 4\n+  b = 7\n+!$omp simd linear(i:4) linear(b:3) reduction(+:c)\n+  do i = 0, 63, 4\n+    c = c + b - (7 + i / 4 * 3)\n+    b = b + 3\n+  end do\n+  if (c /= 0 .or. i /= 64 .or. b /= 7 + 16 * 3) call abort\n+  i = 4\n+  j = 4\n+  b = 7\n+!$omp simd collapse(2) linear(b:2) reduction(+:c)\n+  do i = 0, 7\n+    do j = 0, 7\n+      c = c + b - (7 + 2 * j + 2 * 8 * i)\n+      b = b + 2\n+    end do\n+  end do\n+  if (c /= 0 .or. i /= 8 .or. j /= 8 .or. b /= 7 + 64 * 2) call abort\n+  i = 4\n+  j = 4\n+  b = 7\n+!$omp simd collapse(2) linear(b:2) reduction(+:c) lastprivate (i, j)\n+  do i = 0, 7\n+    do j = 0, 7\n+      c = c + b - (7 + 2 * j + 2 * 8 * i)\n+      b = b + 2\n+    end do\n+  end do\n+  if (c /= 0 .or. i /= 8 .or. j /= 8 .or. b /= 7 + 64 * 2) call abort\n+  i = 4\n+  j = 4\n+  b = 7\n+!$omp parallel do simd schedule (static, 4) linear(b:2) reduction(+:c)\n+  do i = 0, 63\n+    c = c + b - (7 + 2 * i)\n+    b = b + 2\n+  end do\n+  if (c /= 0 .or. i /= 64 .or. b /= 7 + 64 * 2) call abort\n+  i = 4\n+  j = 4\n+  b = 7\n+!$omp parallel do simd schedule (static, 4) linear(b:3) reduction(+:c)\n+  do i = 0, 63, 4\n+    c = c + b - (7 + i / 4 * 3)\n+    b = b + 3\n+  end do\n+  if (c /= 0 .or. i /= 64 .or. b /= 7 + 16 * 3) call abort\n+  i = 4\n+  j = 4\n+  b = 7\n+!$omp parallel do simd schedule (static, 4) linear(i) linear(b:2) reduction(+:c)\n+  do i = 0, 63\n+    c = c + b - (7 + 2 * i)\n+    b = b + 2\n+  end do\n+  if (c /= 0 .or. i /= 64 .or. b /= 7 + 64 * 2) call abort\n+  i = 4\n+  j = 4\n+  b = 7\n+!$omp parallel do simd schedule (static, 4) linear(i:4) linear(b:3) reduction(+:c)\n+  do i = 0, 63, 4\n+    c = c + b - (7 + i / 4 * 3)\n+    b = b + 3\n+  end do\n+  if (c /= 0 .or. i /= 64 .or. b /= 7 + 16 * 3) call abort\n+  i = 4\n+  j = 4\n+  b = 7\n+!$omp parallel do simd schedule (static, 4) collapse(2) linear(b:2) reduction(+:c)\n+  do i = 0, 7\n+    do j = 0, 7\n+      c = c + b - (7 + 2 * j + 2 * 8 * i)\n+      b = b + 2\n+    end do\n+  end do\n+  if (c /= 0 .or. i /= 8 .or. j /= 8 .or. b /= 7 + 64 * 2) call abort\n+  i = 4\n+  j = 4\n+  b = 7\n+!$omp parallel do simd schedule (static, 4) collapse(2) linear(b:2) &\n+!$omp & reduction(+:c) lastprivate (i, j)\n+  do i = 0, 7\n+    do j = 0, 7\n+      c = c + b - (7 + 2 * j + 2 * 8 * i)\n+      b = b + 2\n+    end do\n+  end do\n+  if (c /= 0 .or. i /= 8 .or. j /= 8 .or. b /= 7 + 64 * 2) call abort\n+end"}, {"sha": "881a8fb8db4b77bbb2bd14b156b5d9cf54d5e83c", "filename": "libgomp/testsuite/libgomp.fortran/simd6.f90", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da6f124d8a567e410a2926f1cb4416ca620d271d/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fsimd6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da6f124d8a567e410a2926f1cb4416ca620d271d/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fsimd6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fsimd6.f90?ref=da6f124d8a567e410a2926f1cb4416ca620d271d", "patch": "@@ -0,0 +1,135 @@\n+! { dg-do run }\n+! { dg-additional-options \"-msse2\" { target sse2_runtime } }\n+! { dg-additional-options \"-mavx\" { target avx_runtime } }\n+\n+  interface\n+    subroutine foo (b, i, j, x)\n+      integer, intent (inout) :: b\n+      integer, intent (in) :: i, j, x\n+    end subroutine\n+  end interface\n+  integer :: i, j, b, c\n+  c = 0\n+  i = 4\n+  j = 4\n+  b = 7\n+!$omp simd linear(b:2) reduction(+:c)\n+  do i = 0, 63\n+    c = c + b - (7 + 2 * i)\n+    call foo (b, i, j, 2)\n+  end do\n+  if (c /= 0 .or. i /= 64 .or. b /= 7 + 64 * 2) call abort\n+  i = 4\n+  j = 4\n+  b = 7\n+!$omp simd linear(b:3) reduction(+:c)\n+  do i = 0, 63, 4\n+    c = c + b - (7 + i / 4 * 3)\n+    call foo (b, i, j, 3)\n+  end do\n+  if (c /= 0 .or. i /= 64 .or. b /= 7 + 16 * 3) call abort\n+  i = 4\n+  j = 4\n+  b = 7\n+!$omp simd linear(i) linear(b:2) reduction(+:c)\n+  do i = 0, 63\n+    c = c + b - (7 + 2 * i)\n+    call foo (b, i, j, 2)\n+  end do\n+  if (c /= 0 .or. i /= 64 .or. b /= 7 + 64 * 2) call abort\n+  i = 4\n+  j = 4\n+  b = 7\n+!$omp simd linear(i:4) linear(b:3) reduction(+:c)\n+  do i = 0, 63, 4\n+    c = c + b - (7 + i / 4 * 3)\n+    call foo (b, i, j, 3)\n+  end do\n+  if (c /= 0 .or. i /= 64 .or. b /= 7 + 16 * 3) call abort\n+  i = 4\n+  j = 4\n+  b = 7\n+!$omp simd collapse(2) linear(b:2) reduction(+:c)\n+  do i = 0, 7\n+    do j = 0, 7\n+      c = c + b - (7 + 2 * j + 2 * 8 * i)\n+      call foo (b, i, j, 2)\n+    end do\n+  end do\n+  if (c /= 0 .or. i /= 8 .or. j /= 8 .or. b /= 7 + 64 * 2) call abort\n+  i = 4\n+  j = 4\n+  b = 7\n+!$omp simd collapse(2) linear(b:2) reduction(+:c) lastprivate (i, j)\n+  do i = 0, 7\n+    do j = 0, 7\n+      c = c + b - (7 + 2 * j + 2 * 8 * i)\n+      call foo (b, i, j, 2)\n+    end do\n+  end do\n+  if (c /= 0 .or. i /= 8 .or. j /= 8 .or. b /= 7 + 64 * 2) call abort\n+  i = 4\n+  j = 4\n+  b = 7\n+!$omp parallel do simd schedule (static, 4) linear(b:2) reduction(+:c)\n+  do i = 0, 63\n+    c = c + b - (7 + 2 * i)\n+    call foo (b, i, j, 2)\n+  end do\n+  if (c /= 0 .or. i /= 64 .or. b /= 7 + 64 * 2) call abort\n+  i = 4\n+  j = 4\n+  b = 7\n+!$omp parallel do simd schedule (static, 4) linear(b:3) reduction(+:c)\n+  do i = 0, 63, 4\n+    c = c + b - (7 + i / 4 * 3)\n+    call foo (b, i, j, 3)\n+  end do\n+  if (c /= 0 .or. i /= 64 .or. b /= 7 + 16 * 3) call abort\n+  i = 4\n+  j = 4\n+  b = 7\n+!$omp parallel do simd schedule (static, 4) linear(i) linear(b:2) reduction(+:c)\n+  do i = 0, 63\n+    c = c + b - (7 + 2 * i)\n+    call foo (b, i, j, 2)\n+  end do\n+  if (c /= 0 .or. i /= 64 .or. b /= 7 + 64 * 2) call abort\n+  i = 4\n+  j = 4\n+  b = 7\n+!$omp parallel do simd schedule (static, 4) linear(i:4) linear(b:3) reduction(+:c)\n+  do i = 0, 63, 4\n+    c = c + b - (7 + i / 4 * 3)\n+    call foo (b, i, j, 3)\n+  end do\n+  if (c /= 0 .or. i /= 64 .or. b /= 7 + 16 * 3) call abort\n+  i = 4\n+  j = 4\n+  b = 7\n+!$omp parallel do simd schedule (static, 4) collapse(2) linear(b:2) reduction(+:c)\n+  do i = 0, 7\n+    do j = 0, 7\n+      c = c + b - (7 + 2 * j + 2 * 8 * i)\n+      call foo (b, i, j, 2)\n+    end do\n+  end do\n+  if (c /= 0 .or. i /= 8 .or. j /= 8 .or. b /= 7 + 64 * 2) call abort\n+  i = 4\n+  j = 4\n+  b = 7\n+!$omp parallel do simd schedule (static, 4) collapse(2) linear(b:2) &\n+!$omp & reduction(+:c) lastprivate (i, j)\n+  do i = 0, 7\n+    do j = 0, 7\n+      c = c + b - (7 + 2 * j + 2 * 8 * i)\n+      call foo (b, i, j, 2)\n+    end do\n+  end do\n+  if (c /= 0 .or. i /= 8 .or. j /= 8 .or. b /= 7 + 64 * 2) call abort\n+end\n+subroutine foo (b, i, j, x)\n+  integer, intent (inout) :: b\n+  integer, intent (in) :: i, j, x\n+  b = b + (i - i) + (j - j) + x\n+end subroutine"}, {"sha": "b0473faa9e5719e2f5b7c01aaf586805042ae7eb", "filename": "libgomp/testsuite/libgomp.fortran/simd7.f90", "status": "added", "additions": 172, "deletions": 0, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da6f124d8a567e410a2926f1cb4416ca620d271d/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fsimd7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da6f124d8a567e410a2926f1cb4416ca620d271d/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fsimd7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fsimd7.f90?ref=da6f124d8a567e410a2926f1cb4416ca620d271d", "patch": "@@ -0,0 +1,172 @@\n+! { dg-do run }\n+! { dg-additional-options \"-msse2\" { target sse2_runtime } }\n+! { dg-additional-options \"-mavx\" { target avx_runtime } }\n+\n+subroutine foo (d, e, f, g, m, n)\n+  integer :: i, j, b(2:9), c(3:n), d(:), e(2:n), f(2:,3:), n\n+  integer, allocatable :: g(:), h(:), k, m\n+  logical :: l\n+  l = .false.\n+  allocate (h(2:7))\n+  i = 4; j = 4; b = 7; c = 8; d = 9; e = 10; f = 11; g = 12; h = 13; k = 14; m = 15\n+!$omp simd linear(b)linear(c:2)linear(d:3)linear(e:4)linear(f:5)linear(g:6) &\n+!$omp & linear(h:7)linear(k:8)linear(m:9) reduction(.or.:l)\n+  do i = 0, 63\n+    l = l .or. .not.allocated (g) .or. .not.allocated (h)\n+    l = l .or. .not.allocated (k) .or. .not.allocated (m)\n+    l = l .or. any (b /= 7 + i) .or. any (c /= 8 + 2 * i)\n+    l = l .or. any (d /= 9 + 3 * i) .or. any (e /= 10 + 4 * i)\n+    l = l .or. any (f /= 11 + 5 * i) .or. any (g /= 12 + 6 * i)\n+    l = l .or. any (h /= 13 + 7 * i) .or. (k /= 14 + 8 * i)\n+    l = l .or. (m /= 15 + 9 * i)\n+    l = l .or. (lbound (b, 1) /= 2) .or. (ubound (b, 1) /= 9)\n+    l = l .or. (lbound (c, 1) /= 3) .or. (ubound (c, 1) /= n)\n+    l = l .or. (lbound (d, 1) /= 1) .or. (ubound (d, 1) /= 17)\n+    l = l .or. (lbound (e, 1) /= 2) .or. (ubound (e, 1) /= n)\n+    l = l .or. (lbound (f, 1) /= 2) .or. (ubound (f, 1) /= 3)\n+    l = l .or. (lbound (f, 2) /= 3) .or. (ubound (f, 2) /= 5)\n+    l = l .or. (lbound (g, 1) /= 7) .or. (ubound (g, 1) /= 10)\n+    l = l .or. (lbound (h, 1) /= 2) .or. (ubound (h, 1) /= 7)\n+    b = b + 1; c = c + 2; d = d + 3; e = e + 4; f = f + 5; g = g + 6\n+    h = h + 7; k = k + 8; m = m + 9\n+  end do\n+  if (l .or. i /= 64) call abort\n+  if (any (b /= 7 + 64) .or. any (c /= 8 + 2 * 64)) call abort\n+  if (any (d /= 9 + 3 * 64) .or. any (e /= 10 + 4 * 64)) call abort\n+  if (any (f /= 11 + 5 * 64) .or. any (g /= 12 + 6 * 64)) call abort\n+  if (any (h /= 13 + 7 * 64) .or. (k /= 14 + 8 * 64)) call abort\n+  if (m /= 15 + 9 * 64) call abort\n+  if ((lbound (b, 1) /= 2) .or. (ubound (b, 1) /= 9)) call abort\n+  if ((lbound (c, 1) /= 3) .or. (ubound (c, 1) /= n)) call abort\n+  if ((lbound (d, 1) /= 1) .or. (ubound (d, 1) /= 17)) call abort\n+  if ((lbound (e, 1) /= 2) .or. (ubound (e, 1) /= n)) call abort\n+  if ((lbound (f, 1) /= 2) .or. (ubound (f, 1) /= 3)) call abort\n+  if ((lbound (f, 2) /= 3) .or. (ubound (f, 2) /= 5)) call abort\n+  if ((lbound (g, 1) /= 7) .or. (ubound (g, 1) /= 10)) call abort\n+  if ((lbound (h, 1) /= 2) .or. (ubound (h, 1) /= 7)) call abort\n+  i = 4; j = 4; b = 7; c = 8; d = 9; e = 10; f = 11; g = 12; h = 13; k = 14; m = 15\n+!$omp simd linear(b)linear(c:2)linear(d:3)linear(e:4)linear(f:5)linear(g:6) &\n+!$omp & linear(h:7)linear(k:8)linear(m:9) reduction(.or.:l) collapse(2)\n+  do i = 0, 7\n+    do j = 0, 7\n+      l = l .or. .not.allocated (g) .or. .not.allocated (h)\n+      l = l .or. .not.allocated (k) .or. .not.allocated (m)\n+      l = l .or. any (b /= 7 + (8 * i + j)) .or. any (c /= 8 + 2 * (8 * i + j))\n+      l = l .or. any (d /= 9 + 3 * (8 * i + j)) .or. any (e /= 10 + 4 * (8 * i + j))\n+      l = l .or. any (f /= 11 + 5 * (8 * i + j)) .or. any (g /= 12 + 6 * (8 * i + j))\n+      l = l .or. any (h /= 13 + 7 * (8 * i + j)) .or. (k /= 14 + 8 * (8 * i + j))\n+      l = l .or. (m /= 15 + 9 * (8 * i + j))\n+      l = l .or. (lbound (b, 1) /= 2) .or. (ubound (b, 1) /= 9)\n+      l = l .or. (lbound (c, 1) /= 3) .or. (ubound (c, 1) /= n)\n+      l = l .or. (lbound (d, 1) /= 1) .or. (ubound (d, 1) /= 17)\n+      l = l .or. (lbound (e, 1) /= 2) .or. (ubound (e, 1) /= n)\n+      l = l .or. (lbound (f, 1) /= 2) .or. (ubound (f, 1) /= 3)\n+      l = l .or. (lbound (f, 2) /= 3) .or. (ubound (f, 2) /= 5)\n+      l = l .or. (lbound (g, 1) /= 7) .or. (ubound (g, 1) /= 10)\n+      l = l .or. (lbound (h, 1) /= 2) .or. (ubound (h, 1) /= 7)\n+      b = b + 1; c = c + 2; d = d + 3; e = e + 4; f = f + 5; g = g + 6\n+      h = h + 7; k = k + 8; m = m + 9\n+    end do\n+  end do\n+  if (l .or. i /= 8 .or. j /= 8) call abort\n+  if (any (b /= 7 + 64) .or. any (c /= 8 + 2 * 64)) call abort\n+  if (any (d /= 9 + 3 * 64) .or. any (e /= 10 + 4 * 64)) call abort\n+  if (any (f /= 11 + 5 * 64) .or. any (g /= 12 + 6 * 64)) call abort\n+  if (any (h /= 13 + 7 * 64) .or. (k /= 14 + 8 * 64)) call abort\n+  if (m /= 15 + 9 * 64) call abort\n+  if ((lbound (b, 1) /= 2) .or. (ubound (b, 1) /= 9)) call abort\n+  if ((lbound (c, 1) /= 3) .or. (ubound (c, 1) /= n)) call abort\n+  if ((lbound (d, 1) /= 1) .or. (ubound (d, 1) /= 17)) call abort\n+  if ((lbound (e, 1) /= 2) .or. (ubound (e, 1) /= n)) call abort\n+  if ((lbound (f, 1) /= 2) .or. (ubound (f, 1) /= 3)) call abort\n+  if ((lbound (f, 2) /= 3) .or. (ubound (f, 2) /= 5)) call abort\n+  if ((lbound (g, 1) /= 7) .or. (ubound (g, 1) /= 10)) call abort\n+  if ((lbound (h, 1) /= 2) .or. (ubound (h, 1) /= 7)) call abort\n+  i = 4; j = 4; b = 7; c = 8; d = 9; e = 10; f = 11; g = 12; h = 13; k = 14; m = 15\n+!$omp parallel do simd linear(b)linear(c:2)linear(d:3)linear(e:4)linear(f:5) &\n+!$omp & linear(g:6)linear(h:7)linear(k:8)linear(m:9) reduction(.or.:l)\n+  do i = 0, 63\n+    l = l .or. .not.allocated (g) .or. .not.allocated (h)\n+    l = l .or. .not.allocated (k) .or. .not.allocated (m)\n+    l = l .or. any (b /= 7 + i) .or. any (c /= 8 + 2 * i)\n+    l = l .or. any (d /= 9 + 3 * i) .or. any (e /= 10 + 4 * i)\n+    l = l .or. any (f /= 11 + 5 * i) .or. any (g /= 12 + 6 * i)\n+    l = l .or. any (h /= 13 + 7 * i) .or. (k /= 14 + 8 * i)\n+    l = l .or. (m /= 15 + 9 * i)\n+    l = l .or. (lbound (b, 1) /= 2) .or. (ubound (b, 1) /= 9)\n+    l = l .or. (lbound (c, 1) /= 3) .or. (ubound (c, 1) /= n)\n+    l = l .or. (lbound (d, 1) /= 1) .or. (ubound (d, 1) /= 17)\n+    l = l .or. (lbound (e, 1) /= 2) .or. (ubound (e, 1) /= n)\n+    l = l .or. (lbound (f, 1) /= 2) .or. (ubound (f, 1) /= 3)\n+    l = l .or. (lbound (f, 2) /= 3) .or. (ubound (f, 2) /= 5)\n+    l = l .or. (lbound (g, 1) /= 7) .or. (ubound (g, 1) /= 10)\n+    l = l .or. (lbound (h, 1) /= 2) .or. (ubound (h, 1) /= 7)\n+    b = b + 1; c = c + 2; d = d + 3; e = e + 4; f = f + 5; g = g + 6\n+    h = h + 7; k = k + 8; m = m + 9\n+  end do\n+  if (l .or. i /= 64) call abort\n+  if (any (b /= 7 + 64) .or. any (c /= 8 + 2 * 64)) call abort\n+  if (any (d /= 9 + 3 * 64) .or. any (e /= 10 + 4 * 64)) call abort\n+  if (any (f /= 11 + 5 * 64) .or. any (g /= 12 + 6 * 64)) call abort\n+  if (any (h /= 13 + 7 * 64) .or. (k /= 14 + 8 * 64)) call abort\n+  if (m /= 15 + 9 * 64) call abort\n+  if ((lbound (b, 1) /= 2) .or. (ubound (b, 1) /= 9)) call abort\n+  if ((lbound (c, 1) /= 3) .or. (ubound (c, 1) /= n)) call abort\n+  if ((lbound (d, 1) /= 1) .or. (ubound (d, 1) /= 17)) call abort\n+  if ((lbound (e, 1) /= 2) .or. (ubound (e, 1) /= n)) call abort\n+  if ((lbound (f, 1) /= 2) .or. (ubound (f, 1) /= 3)) call abort\n+  if ((lbound (f, 2) /= 3) .or. (ubound (f, 2) /= 5)) call abort\n+  if ((lbound (g, 1) /= 7) .or. (ubound (g, 1) /= 10)) call abort\n+  if ((lbound (h, 1) /= 2) .or. (ubound (h, 1) /= 7)) call abort\n+  i = 4; j = 4; b = 7; c = 8; d = 9; e = 10; f = 11; g = 12; h = 13; k = 14; m = 15\n+!$omp parallel do simd linear(b)linear(c:2)linear(d:3)linear(e:4)linear(f:5) &\n+!$omp & linear(g:6)linear(h:7)linear(k:8)linear(m:9) reduction(.or.:l) collapse(2)\n+  do i = 0, 7\n+    do j = 0, 7\n+      l = l .or. .not.allocated (g) .or. .not.allocated (h)\n+      l = l .or. .not.allocated (k) .or. .not.allocated (m)\n+      l = l .or. any (b /= 7 + (8 * i + j)) .or. any (c /= 8 + 2 * (8 * i + j))\n+      l = l .or. any (d /= 9 + 3 * (8 * i + j)) .or. any (e /= 10 + 4 * (8 * i + j))\n+      l = l .or. any (f /= 11 + 5 * (8 * i + j)) .or. any (g /= 12 + 6 * (8 * i + j))\n+      l = l .or. any (h /= 13 + 7 * (8 * i + j)) .or. (k /= 14 + 8 * (8 * i + j))\n+      l = l .or. (m /= 15 + 9 * (8 * i + j))\n+      l = l .or. (lbound (b, 1) /= 2) .or. (ubound (b, 1) /= 9)\n+      l = l .or. (lbound (c, 1) /= 3) .or. (ubound (c, 1) /= n)\n+      l = l .or. (lbound (d, 1) /= 1) .or. (ubound (d, 1) /= 17)\n+      l = l .or. (lbound (e, 1) /= 2) .or. (ubound (e, 1) /= n)\n+      l = l .or. (lbound (f, 1) /= 2) .or. (ubound (f, 1) /= 3)\n+      l = l .or. (lbound (f, 2) /= 3) .or. (ubound (f, 2) /= 5)\n+      l = l .or. (lbound (g, 1) /= 7) .or. (ubound (g, 1) /= 10)\n+      l = l .or. (lbound (h, 1) /= 2) .or. (ubound (h, 1) /= 7)\n+      b = b + 1; c = c + 2; d = d + 3; e = e + 4; f = f + 5; g = g + 6\n+      h = h + 7; k = k + 8; m = m + 9\n+    end do\n+  end do\n+  if (l .or. i /= 8 .or. j /= 8) call abort\n+  if (any (b /= 7 + 64) .or. any (c /= 8 + 2 * 64)) call abort\n+  if (any (d /= 9 + 3 * 64) .or. any (e /= 10 + 4 * 64)) call abort\n+  if (any (f /= 11 + 5 * 64) .or. any (g /= 12 + 6 * 64)) call abort\n+  if (any (h /= 13 + 7 * 64) .or. (k /= 14 + 8 * 64)) call abort\n+  if (m /= 15 + 9 * 64) call abort\n+  if ((lbound (b, 1) /= 2) .or. (ubound (b, 1) /= 9)) call abort\n+  if ((lbound (c, 1) /= 3) .or. (ubound (c, 1) /= n)) call abort\n+  if ((lbound (d, 1) /= 1) .or. (ubound (d, 1) /= 17)) call abort\n+  if ((lbound (e, 1) /= 2) .or. (ubound (e, 1) /= n)) call abort\n+  if ((lbound (f, 1) /= 2) .or. (ubound (f, 1) /= 3)) call abort\n+  if ((lbound (f, 2) /= 3) .or. (ubound (f, 2) /= 5)) call abort\n+  if ((lbound (g, 1) /= 7) .or. (ubound (g, 1) /= 10)) call abort\n+  if ((lbound (h, 1) /= 2) .or. (ubound (h, 1) /= 7)) call abort\n+end subroutine\n+\n+  interface\n+    subroutine foo (d, e, f, g, m, n)\n+      integer :: d(:), e(2:n), f(2:,3:), n\n+      integer, allocatable :: g(:), m\n+    end subroutine\n+  end interface\n+  integer, parameter :: n = 8\n+  integer :: d(2:18), e(3:n+1), f(5:6,7:9)\n+  integer, allocatable :: g(:), m\n+  allocate (g(7:10))\n+  call foo (d, e, f, g, m, n)\n+end"}]}