{"sha": "2c43f5ec9db163696de8691eb529df06c4999bcc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmM0M2Y1ZWM5ZGIxNjM2OTZkZTg2OTFlYjUyOWRmMDZjNDk5OWJjYw==", "commit": {"author": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2020-08-25T19:31:23Z"}, "committer": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2021-05-24T19:51:06Z"}, "message": "libstdc++: Limit allocation on iterator insertion in Hashtable [PR 96088]\n\nWhen inserting into unordered_multiset or unordered_multimap first instantiate\nthe node to store and compute the hash code from it to avoid a potential\nintermediate key_type instantiation.\n\nWhen inserting into unordered_set or unordered_map check if invoking the hash\nfunctor with container key_type is noexcept and invoking the same hash functor\nwith key part of the iterator value_type can throw. In this case create a\ntemporary key_type instance at Hashtable level and use it to compute the hash\ncode. This temporary instance is moved to the final storage location if needed.\n\nlibstdc++-v3/ChangeLog:\n\n\tPR libstdc++/96088\n\t* include/bits/hashtable_policy.h (_Select2nd): New.\n\t(_NodeBuilder<>): New.\n\t(_ReuseOrAllocNode<>::operator()): Use variadic template args.\n\t(_AllocNode<>::operator()): Likewise.\n\t* include/bits/hashtable.h\n\t(_Hashtable<>::__node_builder_t): New.\n\t(_Hashtable<>::_M_insert_unique<>(_Kt&&, _Arg&&, const _NodeGenerator&)):\n\t New.\n\t(_Hashtable<>::_S_forward_key): New.\n\t(_Hashtable<>::_M_insert): Use latter.\n\t(_Hashtable<>::_M_insert(const_iterator, _Arg&&, const _NodeGenerator&, false_type)):\n\tInstantiate node first, compute hash code second.\n\t* testsuite/23_containers/unordered_map/96088.cc: New test.\n\t* testsuite/23_containers/unordered_multimap/96088.cc: New test.\n\t* testsuite/23_containers/unordered_multiset/96088.cc: New test.\n\t* testsuite/23_containers/unordered_set/96088.cc: New test.\n\t* testsuite/util/replacement_memory_operators.h\n\t(counter::_M_increment): New.\n\t(counter::_M_decrement): New.\n\t(counter::reset()): New.", "tree": {"sha": "43b6f57544634afafbdca1e491e1b58f4c6bd89a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/43b6f57544634afafbdca1e491e1b58f4c6bd89a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2c43f5ec9db163696de8691eb529df06c4999bcc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c43f5ec9db163696de8691eb529df06c4999bcc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c43f5ec9db163696de8691eb529df06c4999bcc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c43f5ec9db163696de8691eb529df06c4999bcc/comments", "author": null, "committer": null, "parents": [{"sha": "a8764071f2eb6b4cdc9ecb788dfaa2b095b52598", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8764071f2eb6b4cdc9ecb788dfaa2b095b52598", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a8764071f2eb6b4cdc9ecb788dfaa2b095b52598"}], "stats": {"total": 804, "additions": 782, "deletions": 22}, "files": [{"sha": "4bdbe7dd9ccaf3a67ec859379a20d6c85500ac04", "filename": "libstdc++-v3/include/bits/hashtable.h", "status": "modified", "additions": 46, "deletions": 13, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c43f5ec9db163696de8691eb529df06c4999bcc/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c43f5ec9db163696de8691eb529df06c4999bcc/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h?ref=2c43f5ec9db163696de8691eb529df06c4999bcc", "patch": "@@ -274,6 +274,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t__detail::_ReuseOrAllocNode<__node_alloc_type>;\n       using __alloc_node_gen_t =\n \t__detail::_AllocNode<__node_alloc_type>;\n+      using __node_builder_t =\n+\t__detail::_NodeBuilder<_ExtractKey>;\n \n       // Simple RAII type for managing a node containing an element\n       struct _Scoped_node\n@@ -850,9 +852,35 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \titerator\n \t_M_emplace(const_iterator, false_type __uks, _Args&&... __args);\n \n+      template<typename _Kt, typename _Arg, typename _NodeGenerator>\n+\tstd::pair<iterator, bool>\n+\t_M_insert_unique(_Kt&&, _Arg&&, const _NodeGenerator&);\n+\n+      template<typename _Kt>\n+\tstatic typename conditional<\n+\t  __and_<__is_nothrow_invocable<_Hash&, const key_type&>,\n+\t\t __not_<__is_nothrow_invocable<_Hash&, _Kt>>>::value,\n+\t  key_type, _Kt&&>::type\n+\t_S_forward_key(_Kt&& __k)\n+\t{ return std::forward<_Kt>(__k); }\n+\n+      static const key_type&\n+      _S_forward_key(const key_type& __k)\n+      { return __k; }\n+\n+      static key_type&&\n+      _S_forward_key(key_type&& __k)\n+      { return std::move(__k); }\n+\n       template<typename _Arg, typename _NodeGenerator>\n \tstd::pair<iterator, bool>\n-\t_M_insert(_Arg&&, const _NodeGenerator&, true_type __uks);\n+\t_M_insert(_Arg&& __arg, const _NodeGenerator& __node_gen,\n+\t\t  true_type /* __uks */)\n+\t{\n+\t  return _M_insert_unique(\n+\t    _S_forward_key(_ExtractKey{}(std::forward<_Arg>(__arg))),\n+\t    std::forward<_Arg>(__arg), __node_gen);\n+\t}\n \n       template<typename _Arg, typename _NodeGenerator>\n \titerator\n@@ -2067,22 +2095,26 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t   typename _ExtractKey, typename _Equal,\n \t   typename _Hash, typename _RangeHash, typename _Unused,\n \t   typename _RehashPolicy, typename _Traits>\n-    template<typename _Arg, typename _NodeGenerator>\n+    template<typename _Kt, typename _Arg, typename _NodeGenerator>\n       auto\n       _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n \t\t _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::\n-      _M_insert(_Arg&& __v, const _NodeGenerator& __node_gen,\n-\t\ttrue_type /* __uks */)\n+      _M_insert_unique(_Kt&& __k, _Arg&& __v,\n+\t\t       const _NodeGenerator& __node_gen)\n       -> pair<iterator, bool>\n       {\n-\tconst key_type& __k = _ExtractKey{}(__v);\n-\t__hash_code __code = this->_M_hash_code(__k);\n+\t__hash_code __code = this->_M_hash_code_tr(__k);\n \tsize_type __bkt = _M_bucket_index(__code);\n \n-\tif (__node_ptr __node = _M_find_node(__bkt, __k, __code))\n+\tif (__node_ptr __node = _M_find_node_tr(__bkt, __k, __code))\n \t  return { iterator(__node), false };\n \n-\t_Scoped_node __node{ __node_gen(std::forward<_Arg>(__v)), this };\n+\t_Scoped_node __node {\n+\t  __node_builder_t::_S_build(std::forward<_Kt>(__k),\n+\t\t\t\t     std::forward<_Arg>(__v),\n+\t\t\t\t     __node_gen),\n+\t  this\n+\t};\n \tauto __pos\n \t  = _M_insert_unique_node(__bkt, __code, __node._M_node);\n \t__node._M_node = nullptr;\n@@ -2103,12 +2135,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\tfalse_type /* __uks */)\n       -> iterator\n       {\n-\t// First compute the hash code so that we don't do anything if it\n-\t// throws.\n-\t__hash_code __code = this->_M_hash_code(_ExtractKey{}(__v));\n-\n-\t// Second allocate new node so that we don't rehash if it throws.\n+\t// First allocate new node so that we don't do anything if it throws.\n \t_Scoped_node __node{ __node_gen(std::forward<_Arg>(__v)), this };\n+\n+\t// Second compute the hash code so that we don't rehash if it throws.\n+\t__hash_code __code\n+\t  = this->_M_hash_code(_ExtractKey{}(__node._M_node->_M_v()));\n+\n \tauto __pos\n \t  = _M_insert_multi_node(__hint._M_cur, __code, __node._M_node);\n \t__node._M_node = nullptr;"}, {"sha": "1090a398e1e0788232238a0b76175526210dbfc6", "filename": "libstdc++-v3/include/bits/hashtable_policy.h", "status": "modified", "additions": 46, "deletions": 7, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c43f5ec9db163696de8691eb529df06c4999bcc/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c43f5ec9db163696de8691eb529df06c4999bcc/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h?ref=2c43f5ec9db163696de8691eb529df06c4999bcc", "patch": "@@ -94,6 +94,45 @@ namespace __detail\n       { return std::get<0>(std::forward<_Tp>(__x)); }\n   };\n \n+  struct _Select2nd\n+  {\n+    template<typename _Tp>\n+      auto\n+      operator()(_Tp&& __x) const noexcept\n+      -> decltype(std::get<1>(std::forward<_Tp>(__x)))\n+      { return std::get<1>(std::forward<_Tp>(__x)); }\n+  };\n+\n+  template<typename _ExKey>\n+    struct _NodeBuilder;\n+\n+  template<>\n+    struct _NodeBuilder<_Select1st>\n+    {\n+      template<typename _Kt, typename _Arg, typename _NodeGenerator>\n+\tstatic auto\n+\t_S_build(_Kt&& __k, _Arg&& __arg, const _NodeGenerator& __node_gen)\n+\t-> decltype(__node_gen(std::piecewise_construct,\n+\t\t\t       std::forward_as_tuple(std::forward<_Kt>(__k)),\n+\t\t\t       std::forward_as_tuple(_Select2nd{}(\n+\t\t\t\t\t\tstd::forward<_Arg>(__arg)))))\n+\t{\n+\t  return __node_gen(std::piecewise_construct,\n+\t    std::forward_as_tuple(std::forward<_Kt>(__k)),\n+\t    std::forward_as_tuple(_Select2nd{}(std::forward<_Arg>(__arg))));\n+\t}\n+    };\n+\n+  template<>\n+    struct _NodeBuilder<_Identity>\n+    {\n+      template<typename _Kt, typename _Arg, typename _NodeGenerator>\n+\tstatic auto\n+\t_S_build(_Kt&& __k, _Arg&&, const _NodeGenerator& __node_gen)\n+\t-> decltype(__node_gen(std::forward<_Kt>(__k)))\n+\t{ return __node_gen(std::forward<_Kt>(__k)); }\n+    };\n+\n   template<typename _NodeAlloc>\n     struct _Hashtable_alloc;\n \n@@ -117,9 +156,9 @@ namespace __detail\n       ~_ReuseOrAllocNode()\n       { _M_h._M_deallocate_nodes(_M_nodes); }\n \n-      template<typename _Arg>\n+      template<typename... _Args>\n \t__node_type*\n-\toperator()(_Arg&& __arg) const\n+\toperator()(_Args&&... __args) const\n \t{\n \t  if (_M_nodes)\n \t    {\n@@ -131,7 +170,7 @@ namespace __detail\n \t      __try\n \t\t{\n \t\t  __node_alloc_traits::construct(__a, __node->_M_valptr(),\n-\t\t\t\t\t\t std::forward<_Arg>(__arg));\n+\t\t\t\t\t\t std::forward<_Args>(__args)...);\n \t\t}\n \t      __catch(...)\n \t\t{\n@@ -140,7 +179,7 @@ namespace __detail\n \t\t}\n \t      return __node;\n \t    }\n-\t  return _M_h._M_allocate_node(std::forward<_Arg>(__arg));\n+\t  return _M_h._M_allocate_node(std::forward<_Args>(__args)...);\n \t}\n \n     private:\n@@ -161,10 +200,10 @@ namespace __detail\n       _AllocNode(__hashtable_alloc& __h)\n       : _M_h(__h) { }\n \n-      template<typename _Arg>\n+      template<typename... _Args>\n \t__node_type*\n-\toperator()(_Arg&& __arg) const\n-\t{ return _M_h._M_allocate_node(std::forward<_Arg>(__arg)); }\n+\toperator()(_Args&&... __args) const\n+\t{ return _M_h._M_allocate_node(std::forward<_Args>(__args)...); }\n \n     private:\n       __hashtable_alloc& _M_h;"}, {"sha": "062c8316a9ec4de0f13ed3e5edecdceaafbfd11b", "filename": "libstdc++-v3/testsuite/23_containers/unordered_map/96088.cc", "status": "added", "additions": 269, "deletions": 0, "changes": 269, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c43f5ec9db163696de8691eb529df06c4999bcc/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2F96088.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c43f5ec9db163696de8691eb529df06c4999bcc/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2F96088.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2F96088.cc?ref=2c43f5ec9db163696de8691eb529df06c4999bcc", "patch": "@@ -0,0 +1,269 @@\n+// { dg-do run { target c++11 } }\n+\n+// Copyright (C) 2021 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// libstdc++/96088\n+\n+#include <string_view>\n+#include <string>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <testsuite_hooks.h>\n+#include <replacement_memory_operators.h>\n+\n+static constexpr std::initializer_list<std::pair<const char*, int>> lst = {\n+    {\"long_str_for_dynamic_allocating\", 1}\n+};\n+\n+void\n+test01()\n+{\n+  __gnu_test::counter::reset();\n+  std::unordered_map<std::string, int> um;\n+  um.insert(lst.begin(), lst.end());\n+  VERIFY( um.size() == 1 );\n+\n+  VERIFY( __gnu_test::counter::count() == 3 );\n+  VERIFY( __gnu_test::counter::get()._M_increments == 3 );\n+\n+  um.insert(lst.begin(), lst.end());\n+  VERIFY( um.size() == 1 );\n+\n+  VERIFY( __gnu_test::counter::count() == 3 );\n+  VERIFY( __gnu_test::counter::get()._M_increments == 4 );\n+}\n+\n+void\n+test02()\n+{\n+  __gnu_test::counter::reset();\n+  std::unordered_map<std::string, int,\n+\t\t     std::hash<std::string_view>,\n+\t\t     std::equal_to<std::string_view>> um;\n+  um.insert(lst.begin(), lst.end());\n+  VERIFY( um.size() == 1 );\n+\n+  VERIFY( __gnu_test::counter::count() == 3 );\n+  VERIFY( __gnu_test::counter::get()._M_increments == 3 );\n+\n+  um.insert(lst.begin(), lst.end());\n+  VERIFY( um.size() == 1 );\n+\n+  VERIFY( __gnu_test::counter::count() == 3 );\n+  VERIFY( __gnu_test::counter::get()._M_increments == 3 );\n+}\n+\n+std::size_t\n+hash_string_f(const std::string& str) noexcept\n+{\n+  std::hash<std::string> h;\n+  return h(str);\n+}\n+\n+void\n+test11()\n+{\n+  typedef std::size_t (*hash_string_t)(const std::string&) noexcept;\n+  __gnu_test::counter::reset();\n+  hash_string_t hasher = &hash_string_f;\n+  std::unordered_map<std::string, int,\n+\t\t     hash_string_t,\n+\t\t     std::equal_to<std::string>> um(0, hasher);\n+  um.insert(lst.begin(), lst.end());\n+  VERIFY( um.size() == 1 );\n+\n+  VERIFY( __gnu_test::counter::count() == 3 );\n+  VERIFY( __gnu_test::counter::get()._M_increments == 3 );\n+\n+  um.insert(lst.begin(), lst.end());\n+  VERIFY( um.size() == 1 );\n+\n+  VERIFY( __gnu_test::counter::count() == 3 );\n+  VERIFY( __gnu_test::counter::get()._M_increments == 4 );\n+}\n+\n+std::size_t\n+hash_string_view_f(const std::string_view& str) noexcept\n+{\n+  std::hash<std::string_view> h;\n+  return h(str);\n+}\n+\n+void\n+test12()\n+{\n+  typedef std::size_t (*hash_stringview_t) (const std::string_view&) noexcept;\n+  __gnu_test::counter::reset();\n+  hash_stringview_t hasher = &hash_string_view_f;\n+  std::unordered_map<std::string, int, hash_stringview_t,\n+\t\t     std::equal_to<std::string_view>> um(0, hasher);\n+  um.insert(lst.begin(), lst.end());\n+  VERIFY( um.size() == 1 );\n+\n+  VERIFY( __gnu_test::counter::count() == 3 );\n+  VERIFY( __gnu_test::counter::get()._M_increments == 3 );\n+\n+  um.insert(lst.begin(), lst.end());\n+  VERIFY( um.size() == 1 );\n+\n+  VERIFY( __gnu_test::counter::count() == 3 );\n+  VERIFY( __gnu_test::counter::get()._M_increments == 3 );\n+}\n+\n+struct hash_string_functor\n+{\n+  std::size_t\n+  operator()(const std::string& str) const noexcept\n+  {\n+    std::hash<std::string> h;\n+    return h(str);\n+  }\n+};\n+\n+void\n+test21()\n+{\n+  __gnu_test::counter::reset();\n+  std::unordered_map<std::string, int,\n+\t\t     hash_string_functor,\n+\t\t     std::equal_to<std::string>> um;\n+  um.insert(lst.begin(), lst.end());\n+  VERIFY( um.size() == 1 );\n+\n+  VERIFY( __gnu_test::counter::count() == 3 );\n+  VERIFY( __gnu_test::counter::get()._M_increments == 3 );\n+\n+  um.insert(lst.begin(), lst.end());\n+  VERIFY( um.size() == 1 );\n+\n+  VERIFY( __gnu_test::counter::count() == 3 );\n+  VERIFY( __gnu_test::counter::get()._M_increments == 4 );\n+}\n+\n+struct hash_string_view_noexcept_functor\n+{\n+  std::size_t\n+  operator()(const std::string_view& str) const noexcept\n+  {\n+    std::hash<std::string_view> h;\n+    return h(str);\n+  }\n+};\n+\n+void\n+test22()\n+{\n+  __gnu_test::counter::reset();\n+  std::unordered_map<std::string, int,\n+\t\t     hash_string_view_noexcept_functor,\n+\t\t     std::equal_to<std::string_view>> um;\n+  um.insert(lst.begin(), lst.end());\n+  VERIFY( um.size() == 1 );\n+\n+  VERIFY( __gnu_test::counter::count() == 3 );\n+  VERIFY( __gnu_test::counter::get()._M_increments == 3 );\n+\n+  um.insert(lst.begin(), lst.end());\n+  VERIFY( um.size() == 1 );\n+\n+  VERIFY( __gnu_test::counter::count() == 3 );\n+  VERIFY( __gnu_test::counter::get()._M_increments == 3 );\n+}\n+\n+struct hash_string_view_functor\n+{\n+  std::size_t\n+  operator()(const std::string_view& str) const\n+  {\n+    std::hash<std::string_view> h;\n+    return h(str);\n+  }\n+};\n+\n+void\n+test23()\n+{\n+  __gnu_test::counter::reset();\n+  std::unordered_map<std::string, int,\n+\t\t     hash_string_view_functor,\n+\t\t     std::equal_to<std::string_view>> um;\n+  um.insert(lst.begin(), lst.end());\n+  VERIFY( um.size() == 1 );\n+\n+  VERIFY( __gnu_test::counter::count() == 3 );\n+  VERIFY( __gnu_test::counter::get()._M_increments == 3 );\n+\n+  um.insert(lst.begin(), lst.end());\n+  VERIFY( um.size() == 1 );\n+\n+  VERIFY( __gnu_test::counter::count() == 3 );\n+  VERIFY( __gnu_test::counter::get()._M_increments == 3 );\n+}\n+\n+void\n+test03()\n+{\n+  std::vector<std::pair<std::string, int>> v;\n+  v.insert(v.end(), lst.begin(), lst.end());\n+\n+  auto __offset = __gnu_test::counter::count();\n+  {\n+    __gnu_test::counter::reset();\n+    std::unordered_map<std::string, int,\n+\t\t       std::hash<std::string_view>,\n+\t\t       std::equal_to<std::string_view>> um;\n+    um.insert(v.begin(), v.end());\n+    VERIFY( um.size() == 1 );\n+\n+    VERIFY( __gnu_test::counter::count() - __offset == 3 );\n+    VERIFY( __gnu_test::counter::get()._M_increments == 3 );\n+\n+    um.insert(v.begin(), v.end());\n+    VERIFY( um.size() == 1 );\n+\n+    VERIFY( __gnu_test::counter::count() - __offset == 3 );\n+    VERIFY( __gnu_test::counter::get()._M_increments == 3 );\n+  }\n+\n+  {\n+    __gnu_test::counter::reset();\n+    std::unordered_map<std::string, int,\n+\t\t       std::hash<std::string_view>,\n+\t\t       std::equal_to<std::string_view>> um;\n+    um.insert(std::make_move_iterator(v.begin()),\n+\t      std::make_move_iterator(v.end()));\n+    VERIFY( um.size() == 1 );\n+\n+    VERIFY( __gnu_test::counter::count() - __offset == 2 );\n+    VERIFY( __gnu_test::counter::get()._M_increments == 2 );\n+  }\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test11();\n+  test12();\n+  test21();\n+  test22();\n+  test03();\n+  return 0;\n+}"}, {"sha": "de7f009dadc1840a3353845170814326522f5c6f", "filename": "libstdc++-v3/testsuite/23_containers/unordered_multimap/96088.cc", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c43f5ec9db163696de8691eb529df06c4999bcc/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2F96088.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c43f5ec9db163696de8691eb529df06c4999bcc/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2F96088.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2F96088.cc?ref=2c43f5ec9db163696de8691eb529df06c4999bcc", "patch": "@@ -0,0 +1,65 @@\n+// { dg-do run { target c++17 } }\n+\n+// Copyright (C) 2021 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// libstdc++/96088\n+\n+#include <string_view>\n+#include <string>\n+#include <unordered_map>\n+\n+#include <testsuite_hooks.h>\n+#include <replacement_memory_operators.h>\n+\n+static constexpr std::initializer_list<std::pair<const char*, int>> lst = {\n+    {\"long_str_for_dynamic_allocating\", 1}\n+};\n+\n+void\n+test01()\n+{\n+  __gnu_test::counter::reset();\n+  std::unordered_multimap<std::string, int,\n+\t\t\t  std::hash<std::string_view>,\n+\t\t\t  std::equal_to<std::string_view>> foo;\n+  foo.insert(lst.begin(), lst.end());\n+  VERIFY( foo.size() == 1 );\n+\n+  VERIFY( __gnu_test::counter::count() == 3 );\n+  VERIFY( __gnu_test::counter::get()._M_increments == 3 );\n+}\n+\n+void\n+test02()\n+{\n+  __gnu_test::counter::reset();\n+  std::unordered_multimap<std::string, int> foo;\n+  foo.insert(lst.begin(), lst.end());\n+  VERIFY( foo.size() == 1 );\n+\n+  VERIFY( __gnu_test::counter::count() == 3 );\n+  VERIFY( __gnu_test::counter::get()._M_increments == 3 );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "b9bbf63b8630141703aa184794f56de8bd18dae1", "filename": "libstdc++-v3/testsuite/23_containers/unordered_multiset/96088.cc", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c43f5ec9db163696de8691eb529df06c4999bcc/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2F96088.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c43f5ec9db163696de8691eb529df06c4999bcc/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2F96088.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2F96088.cc?ref=2c43f5ec9db163696de8691eb529df06c4999bcc", "patch": "@@ -0,0 +1,65 @@\n+// { dg-do run { target c++17 } }\n+\n+// Copyright (C) 2021 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// libstdc++/96088\n+\n+#include <string_view>\n+#include <string>\n+#include <unordered_set>\n+\n+#include <testsuite_hooks.h>\n+#include <replacement_memory_operators.h>\n+\n+static constexpr std::initializer_list<const char*> lst = {\n+  \"long_str_for_dynamic_allocating\"\n+};\n+\n+void\n+test01()\n+{\n+  __gnu_test::counter::reset();\n+  std::unordered_multiset<std::string,\n+\t\t\t  std::hash<std::string_view>,\n+\t\t\t  std::equal_to<std::string_view>> foo;\n+  foo.insert(lst.begin(), lst.end());\n+  VERIFY( foo.size() == 1 );\n+\n+  VERIFY( __gnu_test::counter::count() == 3 );\n+  VERIFY( __gnu_test::counter::get()._M_increments == 3 );\n+}\n+\n+void\n+test02()\n+{\n+  __gnu_test::counter::reset();\n+  std::unordered_multiset<std::string> foo;\n+  foo.insert(lst.begin(), lst.end());\n+  VERIFY( foo.size() == 1 );\n+\n+  VERIFY( __gnu_test::counter::count() == 3 );\n+  VERIFY( __gnu_test::counter::get()._M_increments == 3 );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "53bb754dab6d2665cd3798b8298fb76b56bfd770", "filename": "libstdc++-v3/testsuite/23_containers/unordered_set/96088.cc", "status": "added", "additions": 271, "deletions": 0, "changes": 271, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c43f5ec9db163696de8691eb529df06c4999bcc/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2F96088.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c43f5ec9db163696de8691eb529df06c4999bcc/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2F96088.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2F96088.cc?ref=2c43f5ec9db163696de8691eb529df06c4999bcc", "patch": "@@ -0,0 +1,271 @@\n+// { dg-do run { target c++11 } }\n+\n+// Copyright (C) 2021 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// libstdc++/96088\n+\n+#include <string_view>\n+#include <string>\n+#include <unordered_set>\n+#include <vector>\n+\n+#include <testsuite_hooks.h>\n+#include <replacement_memory_operators.h>\n+\n+static constexpr std::initializer_list<const char*> lst = {\n+  \"long_str_for_dynamic_allocating\"\n+};\n+\n+void\n+test01()\n+{\n+  __gnu_test::counter::reset();\n+  std::unordered_set<std::string> us;\n+  us.insert(lst.begin(), lst.end());\n+  VERIFY( us.size() == 1 );\n+\n+  VERIFY( __gnu_test::counter::count() == 3 );\n+  VERIFY( __gnu_test::counter::get()._M_increments == 3 );\n+\n+  us.insert(lst.begin(), lst.end());\n+  VERIFY( us.size() == 1 );\n+\n+  VERIFY( __gnu_test::counter::count() == 3 );\n+  VERIFY( __gnu_test::counter::get()._M_increments == 4 );\n+}\n+\n+void\n+test02()\n+{\n+  __gnu_test::counter::reset();\n+  std::unordered_set<std::string,\n+\t\t     std::hash<std::string_view>,\n+\t\t     std::equal_to<std::string_view>> us;\n+  us.insert(lst.begin(), lst.end());\n+  VERIFY( us.size() == 1 );\n+\n+  VERIFY( __gnu_test::counter::count() == 3 );\n+  VERIFY( __gnu_test::counter::get()._M_increments == 3 );\n+\n+  us.insert(lst.begin(), lst.end());\n+  VERIFY( us.size() == 1 );\n+\n+  VERIFY( __gnu_test::counter::count() == 3 );\n+  VERIFY( __gnu_test::counter::get()._M_increments == 3 );\n+}\n+\n+std::size_t\n+hash_string_f(const std::string& str) noexcept\n+{\n+  std::hash<std::string> h;\n+  return h(str);\n+}\n+\n+void\n+test11()\n+{\n+  typedef std::size_t (*hash_string_t)(const std::string&) noexcept;\n+  __gnu_test::counter::reset();\n+  hash_string_t hasher = &hash_string_f;\n+  std::unordered_set<std::string,\n+\t\t     hash_string_t,\n+\t\t     std::equal_to<std::string>> us(0, hasher);\n+  us.insert(lst.begin(), lst.end());\n+  VERIFY( us.size() == 1 );\n+\n+  VERIFY( __gnu_test::counter::count() == 3 );\n+  VERIFY( __gnu_test::counter::get()._M_increments == 3 );\n+\n+  us.insert(lst.begin(), lst.end());\n+  VERIFY( us.size() == 1 );\n+\n+  VERIFY( __gnu_test::counter::count() == 3 );\n+  VERIFY( __gnu_test::counter::get()._M_increments == 4 );\n+}\n+\n+std::size_t\n+hash_string_view_f(const std::string_view& str) noexcept\n+{\n+  std::hash<std::string_view> h;\n+  return h(str);\n+}\n+\n+void\n+test12()\n+{\n+  typedef std::size_t (*hash_stringview_t)(const std::string_view&) noexcept;\n+  __gnu_test::counter::reset();\n+  hash_stringview_t hasher = &hash_string_view_f;\n+  std::unordered_set<std::string,\n+\t\t     hash_stringview_t,\n+\t\t     std::equal_to<std::string_view>> us(0, hasher);\n+  us.insert(lst.begin(), lst.end());\n+  VERIFY( us.size() == 1 );\n+\n+  VERIFY( __gnu_test::counter::count() == 3 );\n+  VERIFY( __gnu_test::counter::get()._M_increments == 3 );\n+\n+  us.insert(lst.begin(), lst.end());\n+  VERIFY( us.size() == 1 );\n+\n+  VERIFY( __gnu_test::counter::count() == 3 );\n+  VERIFY( __gnu_test::counter::get()._M_increments == 3 );\n+}\n+\n+struct hash_string_functor\n+{\n+  std::size_t\n+  operator()(const std::string& str) const noexcept\n+  {\n+    std::hash<std::string> h;\n+    return h(str);\n+  }\n+};\n+\n+void\n+test21()\n+{\n+  __gnu_test::counter::reset();\n+  std::unordered_set<std::string,\n+\t\t     hash_string_functor,\n+\t\t     std::equal_to<std::string>> us;\n+  us.insert(lst.begin(), lst.end());\n+  VERIFY( us.size() == 1 );\n+\n+  VERIFY( __gnu_test::counter::count() == 3 );\n+  VERIFY( __gnu_test::counter::get()._M_increments == 3 );\n+\n+  us.insert(lst.begin(), lst.end());\n+  VERIFY( us.size() == 1 );\n+\n+  VERIFY( __gnu_test::counter::count() == 3 );\n+  VERIFY( __gnu_test::counter::get()._M_increments == 4 );\n+}\n+\n+struct hash_string_view_noexcept_functor\n+{\n+  std::size_t\n+  operator()(const std::string_view& str) const noexcept\n+  {\n+    std::hash<std::string_view> h;\n+    return h(str);\n+  }\n+};\n+\n+void\n+test22()\n+{\n+  __gnu_test::counter::reset();\n+  std::unordered_set<std::string,\n+\t\t     hash_string_view_noexcept_functor,\n+\t\t     std::equal_to<std::string_view>> us;\n+  us.insert(lst.begin(), lst.end());\n+  VERIFY( us.size() == 1 );\n+\n+  VERIFY( __gnu_test::counter::count() == 3 );\n+  VERIFY( __gnu_test::counter::get()._M_increments == 3 );\n+\n+  us.insert(lst.begin(), lst.end());\n+  VERIFY( us.size() == 1 );\n+\n+  VERIFY( __gnu_test::counter::count() == 3 );\n+  VERIFY( __gnu_test::counter::get()._M_increments == 3 );\n+}\n+\n+struct hash_string_view_functor\n+{\n+  std::size_t\n+  operator()(const std::string_view& str) const\n+  {\n+    std::hash<std::string_view> h;\n+    return h(str);\n+  }\n+};\n+\n+void\n+test23()\n+{\n+  __gnu_test::counter::reset();\n+  std::unordered_set<std::string,\n+\t\t     hash_string_view_functor,\n+\t\t     std::equal_to<std::string_view>> us;\n+  us.insert(lst.begin(), lst.end());\n+  VERIFY( us.size() == 1 );\n+\n+  VERIFY( __gnu_test::counter::count() == 3 );\n+  VERIFY( __gnu_test::counter::get()._M_increments == 3 );\n+\n+  us.insert(lst.begin(), lst.end());\n+  VERIFY( us.size() == 1 );\n+\n+  VERIFY( __gnu_test::counter::count() == 3 );\n+  VERIFY( __gnu_test::counter::get()._M_increments == 3 );\n+}\n+\n+void\n+test03()\n+{\n+  std::vector<std::string> v;\n+  v.insert(v.end(), lst.begin(), lst.end());\n+\n+  auto __offset = __gnu_test::counter::count();\n+  {\n+    __gnu_test::counter::reset();\n+    std::unordered_set<std::string,\n+\t\t       std::hash<std::string_view>,\n+\t\t       std::equal_to<std::string_view>> us;\n+    us.insert(v.begin(), v.end());\n+    VERIFY( us.size() == 1 );\n+\n+    VERIFY( __gnu_test::counter::count() - __offset == 3 );\n+    VERIFY( __gnu_test::counter::get()._M_increments == 3 );\n+\n+    us.insert(v.begin(), v.end());\n+    VERIFY( us.size() == 1 );\n+\n+    VERIFY( __gnu_test::counter::count() - __offset == 3 );\n+    VERIFY( __gnu_test::counter::get()._M_increments == 3 );\n+  }\n+\n+  {\n+    __gnu_test::counter::reset();\n+    std::unordered_set<std::string,\n+\t\t       std::hash<std::string_view>,\n+\t\t       std::equal_to<std::string_view>> us;\n+    us.insert(std::make_move_iterator(v.begin()),\n+\t      std::make_move_iterator(v.end()));\n+    VERIFY( us.size() == 1 );\n+\n+    VERIFY( __gnu_test::counter::count() - __offset == 2 );\n+    VERIFY( __gnu_test::counter::get()._M_increments == 2 );\n+  }\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test11();\n+  test12();\n+  test21();\n+  test22();\n+  test23();\n+  test03();\n+  return 0;\n+}"}, {"sha": "e460c419ff21b0db4be5d4fff41d65a1a80af04d", "filename": "libstdc++-v3/testsuite/util/replacement_memory_operators.h", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c43f5ec9db163696de8691eb529df06c4999bcc/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Freplacement_memory_operators.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c43f5ec9db163696de8691eb529df06c4999bcc/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Freplacement_memory_operators.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Freplacement_memory_operators.h?ref=2c43f5ec9db163696de8691eb529df06c4999bcc", "patch": "@@ -29,6 +29,7 @@ namespace __gnu_test\n   struct counter\n   {\n     std::size_t _M_count;\n+    std::size_t _M_increments, _M_decrements;\n     bool\t_M_throw;\n \n     counter() : _M_count(0), _M_throw(true) { }\n@@ -40,10 +41,20 @@ namespace __gnu_test\n     }\n \n     static void\n-    increment() { get()._M_count++; }\n+    increment()\n+    {\n+      counter& cntr = get();\n+      cntr._M_count++;\n+      cntr._M_increments++;\n+    }\n \n     static void\n-    decrement() { get()._M_count--; }\n+    decrement()\n+    {\n+      counter& cntr = get();\n+      cntr._M_count--;\n+      cntr._M_decrements++;\n+    }\n \n     static counter&\n     get()\n@@ -57,6 +68,13 @@ namespace __gnu_test\n \n     static void\n     exceptions(bool __b) { get()._M_throw = __b; }\n+\n+    static void\n+    reset()\n+    {\n+      counter& cntr = get();\n+      cntr._M_increments = cntr._M_decrements = 0;\n+    }\n   };\n \n   template<typename Alloc, bool uses_global_new>"}]}