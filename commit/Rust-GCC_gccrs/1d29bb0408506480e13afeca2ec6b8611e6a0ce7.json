{"sha": "1d29bb0408506480e13afeca2ec6b8611e6a0ce7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWQyOWJiMDQwODUwNjQ4MGUxM2FmZWNhMmVjNmI4NjExZTZhMGNlNw==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-08-24T18:15:04Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-08-24T18:15:04Z"}, "message": "runtime: remove the dummy arg of getcallersp\n    \n    This is a port of https://golang.org/cl/109596 to the gofrontend, in\n    preparation for updating libgo to 1.11.\n    \n    Original CL description:\n    \n        getcallersp is intrinsified, and so the dummy arg is no longer\n        needed. Remove it, as well as a few dummy args that are solely\n        to feed getcallersp.\n    \n    Reviewed-on: https://go-review.googlesource.com/131116\n\nFrom-SVN: r263840", "tree": {"sha": "1aba1d63f8e8f960b6130e1f8a595548106b1403", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1aba1d63f8e8f960b6130e1f8a595548106b1403"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1d29bb0408506480e13afeca2ec6b8611e6a0ce7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d29bb0408506480e13afeca2ec6b8611e6a0ce7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d29bb0408506480e13afeca2ec6b8611e6a0ce7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d29bb0408506480e13afeca2ec6b8611e6a0ce7/comments", "author": null, "committer": null, "parents": [{"sha": "9ca2ac699ab2eee4ef6a2904426fa38f58af5a0b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ca2ac699ab2eee4ef6a2904426fa38f58af5a0b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ca2ac699ab2eee4ef6a2904426fa38f58af5a0b"}], "stats": {"total": 88, "additions": 40, "deletions": 48}, "files": [{"sha": "8fc3878e3a2c03f72f47c9a6e78144cd671615dd", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d29bb0408506480e13afeca2ec6b8611e6a0ce7/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d29bb0408506480e13afeca2ec6b8611e6a0ce7/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=1d29bb0408506480e13afeca2ec6b8611e6a0ce7", "patch": "@@ -1,4 +1,4 @@\n-274c88df4d6f9360dcd657b6e069a3b5a1d37a90\n+8deaafd14414bb5cbbdf3e2673f61b6d836d7d2a\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "143f0a73df68f1783bbc4e4169864b0398dc0231", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d29bb0408506480e13afeca2ec6b8611e6a0ce7/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d29bb0408506480e13afeca2ec6b8611e6a0ce7/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=1d29bb0408506480e13afeca2ec6b8611e6a0ce7", "patch": "@@ -9635,13 +9635,9 @@ Call_expression::do_lower(Gogo* gogo, Named_object* function,\n \t\t\t\t\t    \"__builtin_return_address\",\n \t\t\t\t\t    0);\n \t    }\n-\t  else if (this->args_ != NULL\n-\t\t   && this->args_->size() == 1\n+\t  else if ((this->args_ == NULL || this->args_->size() == 0)\n \t\t   && n == \"getcallersp\")\n \t    {\n-\t      // The actual argument to getcallersp is always the\n-\t      // address of a parameter; we don't need that for the\n-\t      // GCC builtin function, so we just ignore it.\n \t      static Named_object* builtin_frame_address;\n \t      return this->lower_to_builtin(&builtin_frame_address,\n \t\t\t\t\t    \"__builtin_frame_address\","}, {"sha": "e689b0e26169b1876d4149843ca8853855d2b6b3", "filename": "libgo/go/runtime/cgo_gccgo.go", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d29bb0408506480e13afeca2ec6b8611e6a0ce7/libgo%2Fgo%2Fruntime%2Fcgo_gccgo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d29bb0408506480e13afeca2ec6b8611e6a0ce7/libgo%2Fgo%2Fruntime%2Fcgo_gccgo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fcgo_gccgo.go?ref=1d29bb0408506480e13afeca2ec6b8611e6a0ce7", "patch": "@@ -47,7 +47,7 @@ func Cgocall() {\n \tmp := getg().m\n \tmp.ncgocall++\n \tmp.ncgo++\n-\tentersyscall(0)\n+\tentersyscall()\n \tmp.incgo = true\n }\n \n@@ -63,7 +63,7 @@ func CgocallDone() {\n \t// If we are invoked because the C function called _cgo_panic,\n \t// then _cgo_panic will already have exited syscall mode.\n \tif readgstatus(gp)&^_Gscan == _Gsyscall {\n-\t\texitsyscall(0)\n+\t\texitsyscall()\n \t}\n }\n \n@@ -84,7 +84,7 @@ func CgocallBack() {\n \n \tlockOSThread()\n \n-\texitsyscall(0)\n+\texitsyscall()\n \tgp.m.incgo = false\n \n \tif gp.m.ncgo == 0 {\n@@ -134,7 +134,7 @@ func CgocallBackDone() {\n \t}\n \n \tgp.m.incgo = true\n-\tentersyscall(0)\n+\tentersyscall()\n \n \tif drop {\n \t\tmp.dropextram = false\n@@ -144,7 +144,7 @@ func CgocallBackDone() {\n \n // _cgo_panic may be called by SWIG code to panic.\n func _cgo_panic(p *byte) {\n-\texitsyscall(0)\n+\texitsyscall()\n \tpanic(gostringnocopy(p))\n }\n "}, {"sha": "b2c9ccb37ee17591853d264c0812c47ed4d4e3ce", "filename": "libgo/go/runtime/lock_futex.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d29bb0408506480e13afeca2ec6b8611e6a0ce7/libgo%2Fgo%2Fruntime%2Flock_futex.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d29bb0408506480e13afeca2ec6b8611e6a0ce7/libgo%2Fgo%2Fruntime%2Flock_futex.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Flock_futex.go?ref=1d29bb0408506480e13afeca2ec6b8611e6a0ce7", "patch": "@@ -236,8 +236,8 @@ func notetsleepg(n *note, ns int64) bool {\n \t\tthrow(\"notetsleepg on g0\")\n \t}\n \n-\tentersyscallblock(0)\n+\tentersyscallblock()\n \tok := notetsleep_internal(n, ns)\n-\texitsyscall(0)\n+\texitsyscall()\n \treturn ok\n }"}, {"sha": "b5cce6af58314e6750020d739ba6ef45e92adec1", "filename": "libgo/go/runtime/lock_sema.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d29bb0408506480e13afeca2ec6b8611e6a0ce7/libgo%2Fgo%2Fruntime%2Flock_sema.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d29bb0408506480e13afeca2ec6b8611e6a0ce7/libgo%2Fgo%2Fruntime%2Flock_sema.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Flock_sema.go?ref=1d29bb0408506480e13afeca2ec6b8611e6a0ce7", "patch": "@@ -289,8 +289,8 @@ func notetsleepg(n *note, ns int64) bool {\n \t\tthrow(\"notetsleepg on g0\")\n \t}\n \tsemacreate(gp.m)\n-\tentersyscallblock(0)\n+\tentersyscallblock()\n \tok := notetsleep_internal(n, ns, nil, 0)\n-\texitsyscall(0)\n+\texitsyscall()\n \treturn ok\n }"}, {"sha": "523989e2181146991d50b852ad80b92cfb0c25c4", "filename": "libgo/go/runtime/malloc.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d29bb0408506480e13afeca2ec6b8611e6a0ce7/libgo%2Fgo%2Fruntime%2Fmalloc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d29bb0408506480e13afeca2ec6b8611e6a0ce7/libgo%2Fgo%2Fruntime%2Fmalloc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmalloc.go?ref=1d29bb0408506480e13afeca2ec6b8611e6a0ce7", "patch": "@@ -621,7 +621,7 @@ func mallocgc(size uintptr, typ *_type, needzero bool) unsafe.Pointer {\n \t// callback.\n \tincallback := false\n \tif gomcache() == nil && getg().m.ncgo > 0 {\n-\t\texitsyscall(0)\n+\t\texitsyscall()\n \t\tincallback = true\n \t}\n \n@@ -709,7 +709,7 @@ func mallocgc(size uintptr, typ *_type, needzero bool) unsafe.Pointer {\n \t\t\t\tmp.mallocing = 0\n \t\t\t\treleasem(mp)\n \t\t\t\tif incallback {\n-\t\t\t\t\tentersyscall(0)\n+\t\t\t\t\tentersyscall()\n \t\t\t\t}\n \t\t\t\treturn x\n \t\t\t}\n@@ -835,7 +835,7 @@ func mallocgc(size uintptr, typ *_type, needzero bool) unsafe.Pointer {\n \t}\n \n \tif incallback {\n-\t\tentersyscall(0)\n+\t\tentersyscall()\n \t}\n \n \treturn x"}, {"sha": "e90128bb6d412a866656713b42a949c28f186583", "filename": "libgo/go/runtime/norace_test.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d29bb0408506480e13afeca2ec6b8611e6a0ce7/libgo%2Fgo%2Fruntime%2Fnorace_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d29bb0408506480e13afeca2ec6b8611e6a0ce7/libgo%2Fgo%2Fruntime%2Fnorace_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fnorace_test.go?ref=1d29bb0408506480e13afeca2ec6b8611e6a0ce7", "patch": "@@ -34,12 +34,12 @@ func benchmarkSyscall(b *testing.B, work, excess int) {\n \tb.RunParallel(func(pb *testing.PB) {\n \t\tfoo := 42\n \t\tfor pb.Next() {\n-\t\t\truntime.Entersyscall(0)\n+\t\t\truntime.Entersyscall()\n \t\t\tfor i := 0; i < work; i++ {\n \t\t\t\tfoo *= 2\n \t\t\t\tfoo /= 2\n \t\t\t}\n-\t\t\truntime.Exitsyscall(0)\n+\t\t\truntime.Exitsyscall()\n \t\t}\n \t\t_ = foo\n \t})"}, {"sha": "4c217cc1c0af1f1563f1c8e3513176a4124a5df8", "filename": "libgo/go/runtime/proc.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d29bb0408506480e13afeca2ec6b8611e6a0ce7/libgo%2Fgo%2Fruntime%2Fproc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d29bb0408506480e13afeca2ec6b8611e6a0ce7/libgo%2Fgo%2Fruntime%2Fproc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fproc.go?ref=1d29bb0408506480e13afeca2ec6b8611e6a0ce7", "patch": "@@ -1168,7 +1168,7 @@ func kickoff() {\n \tgoexit1()\n }\n \n-func mstart1(dummy int32) {\n+func mstart1() {\n \t_g_ := getg()\n \n \tif _g_ != _g_.m.g0 {\n@@ -2774,7 +2774,7 @@ func entersyscallblock_handoff() {\n //\n //go:nosplit\n //go:nowritebarrierrec\n-func exitsyscall(dummy int32) {\n+func exitsyscall() {\n \t_g_ := getg()\n \n \t_g_.m.locks++ // see comment in entersyscall\n@@ -2984,13 +2984,13 @@ func exitsyscallclear(gp *g) {\n //go:linkname syscall_entersyscall syscall.Entersyscall\n //go:nosplit\n func syscall_entersyscall() {\n-\tentersyscall(0)\n+\tentersyscall()\n }\n \n //go:linkname syscall_exitsyscall syscall.Exitsyscall\n //go:nosplit\n func syscall_exitsyscall() {\n-\texitsyscall(0)\n+\texitsyscall()\n }\n \n func beforefork() {"}, {"sha": "1d214454ed4d7ffaeb2a7d169b88490f4e7463e8", "filename": "libgo/go/runtime/stubs.go", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d29bb0408506480e13afeca2ec6b8611e6a0ce7/libgo%2Fgo%2Fruntime%2Fstubs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d29bb0408506480e13afeca2ec6b8611e6a0ce7/libgo%2Fgo%2Fruntime%2Fstubs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fstubs.go?ref=1d29bb0408506480e13afeca2ec6b8611e6a0ce7", "patch": "@@ -199,16 +199,14 @@ func publicationBarrier()\n // getcallerpc returns the program counter (PC) of its caller's caller.\n // getcallersp returns the stack pointer (SP) of its caller's caller.\n // argp must be a pointer to the caller's first function argument.\n-// The implementation may or may not use argp, depending on\n-// the architecture. The implementation may be a compiler\n-// intrinsic; there is not necessarily code implementing this\n-// on every platform.\n+// The implementation may be a compiler intrinsic; there is not\n+// necessarily code implementing this on every platform.\n //\n // For example:\n //\n //\tfunc f(arg1, arg2, arg3 int) {\n //\t\tpc := getcallerpc()\n-//\t\tsp := getcallersp(unsafe.Pointer(&arg1))\n+//\t\tsp := getcallersp()\n //\t}\n //\n // These two lines find the PC and SP immediately following\n@@ -230,7 +228,7 @@ func publicationBarrier()\n func getcallerpc() uintptr\n \n //go:noescape\n-func getcallersp(argp unsafe.Pointer) uintptr\n+func getcallersp() uintptr\n \n func asmcgocall(fn, arg unsafe.Pointer) int32 {\n \tthrow(\"asmcgocall\")\n@@ -309,9 +307,9 @@ func setSupportAES(v bool) {\n // Here for gccgo.\n func errno() int\n \n-// Temporary for gccgo until we port proc.go.\n-func entersyscall(int32)\n-func entersyscallblock(int32)\n+// For gccgo these are written in C.\n+func entersyscall()\n+func entersyscallblock()\n \n // For gccgo to call from C code, so that the C code and the Go code\n // can share the memstats variable for now."}, {"sha": "d8d231bae30d848e67a07157d347d75a974c9fa7", "filename": "libgo/runtime/proc.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d29bb0408506480e13afeca2ec6b8611e6a0ce7/libgo%2Fruntime%2Fproc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d29bb0408506480e13afeca2ec6b8611e6a0ce7/libgo%2Fruntime%2Fproc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fproc.c?ref=1d29bb0408506480e13afeca2ec6b8611e6a0ce7", "patch": "@@ -382,7 +382,7 @@ extern void kickoff(void)\n   __asm__(GOSYM_PREFIX \"runtime.kickoff\");\n extern void minit(void)\n   __asm__(GOSYM_PREFIX \"runtime.minit\");\n-extern void mstart1(int32)\n+extern void mstart1()\n   __asm__(GOSYM_PREFIX \"runtime.mstart1\");\n extern void stopm(void)\n   __asm__(GOSYM_PREFIX \"runtime.stopm\");\n@@ -542,7 +542,7 @@ runtime_mstart(void *arg)\n \t}\n #endif\n \n-\tmstart1(0);\n+\tmstart1();\n \n \t// mstart1 does not return, but we need a return statement\n \t// here to avoid a compiler warning.\n@@ -621,12 +621,12 @@ makeGContext(G* gp, byte* sp, uintptr spsize) {\n // make g->sched refer to the caller's stack segment, because\n // entersyscall is going to return immediately after.\n \n-void runtime_entersyscall(int32) __attribute__ ((no_split_stack));\n+void runtime_entersyscall() __attribute__ ((no_split_stack));\n static void doentersyscall(uintptr, uintptr)\n   __attribute__ ((no_split_stack, noinline));\n \n void\n-runtime_entersyscall(int32 dummy __attribute__ ((unused)))\n+runtime_entersyscall()\n {\n \t// Save the registers in the g structure so that any pointers\n \t// held in registers will be seen by the garbage collector.\n@@ -638,8 +638,8 @@ runtime_entersyscall(int32 dummy __attribute__ ((unused)))\n \t// callee-saved registers to access the TLS variable g.  We\n \t// don't want to put the ucontext_t on the stack because it is\n \t// large and we can not split the stack here.\n-\tdoentersyscall((uintptr)runtime_getcallerpc(&dummy),\n-\t\t       (uintptr)runtime_getcallersp(&dummy));\n+\tdoentersyscall((uintptr)runtime_getcallerpc(),\n+\t\t       (uintptr)runtime_getcallersp());\n }\n \n static void\n@@ -672,15 +672,15 @@ static void doentersyscallblock(uintptr, uintptr)\n \n // The same as runtime_entersyscall(), but with a hint that the syscall is blocking.\n void\n-runtime_entersyscallblock(int32 dummy __attribute__ ((unused)))\n+runtime_entersyscallblock()\n {\n \t// Save the registers in the g structure so that any pointers\n \t// held in registers will be seen by the garbage collector.\n \tgetcontext(ucontext_arg(&g->gcregs[0]));\n \n \t// See comment in runtime_entersyscall.\n-\tdoentersyscallblock((uintptr)runtime_getcallerpc(&dummy),\n-\t\t\t    (uintptr)runtime_getcallersp(&dummy));\n+\tdoentersyscallblock((uintptr)runtime_getcallerpc(),\n+\t\t\t    (uintptr)runtime_getcallersp());\n }\n \n static void"}, {"sha": "0856618b4998f7df7d43b42555c0df26432ae9bd", "filename": "libgo/runtime/runtime.h", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d29bb0408506480e13afeca2ec6b8611e6a0ce7/libgo%2Fruntime%2Fruntime.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d29bb0408506480e13afeca2ec6b8611e6a0ce7/libgo%2Fruntime%2Fruntime.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fruntime.h?ref=1d29bb0408506480e13afeca2ec6b8611e6a0ce7", "patch": "@@ -268,7 +268,7 @@ void*\truntime_sysAlloc(uintptr, uint64*)\n void\truntime_sysFree(void*, uintptr, uint64*)\n   __asm__ (GOSYM_PREFIX \"runtime.sysFree\");\n void\truntime_mprofinit(void);\n-#define runtime_getcallersp(p) __builtin_frame_address(0)\n+#define runtime_getcallersp() __builtin_frame_address(0)\n void\truntime_mcall(FuncVal*)\n   __asm__ (GOSYM_PREFIX \"runtime.mcall\");\n int32\truntime_timediv(int64, int32, int32*)\n@@ -305,12 +305,10 @@ void\truntime_schedtrace(bool)\n void\truntime_goparkunlock(Lock*, String, byte, intgo)\n   __asm__ (GOSYM_PREFIX \"runtime.goparkunlock\");\n void\truntime_tsleep(int64, const char*);\n-void\truntime_entersyscall(int32)\n+void\truntime_entersyscall()\n   __asm__ (GOSYM_PREFIX \"runtime.entersyscall\");\n-void\truntime_entersyscallblock(int32)\n+void\truntime_entersyscallblock()\n   __asm__ (GOSYM_PREFIX \"runtime.entersyscallblock\");\n-void\truntime_exitsyscall(int32)\n-  __asm__ (GOSYM_PREFIX \"runtime.exitsyscall\");\n G*\t__go_go(void (*pfn)(void*), void*);\n int32\truntime_callers(int32, Location*, int32, bool keep_callers);\n int64\truntime_nanotime(void)\t// monotonic time\n@@ -385,7 +383,7 @@ bool\truntime_notetsleepg(Note*, int64)  // false - timeout\n #define runtime_munmap munmap\n #define runtime_madvise madvise\n #define runtime_memclr(buf, size) __builtin_memset((buf), 0, (size))\n-#define runtime_getcallerpc(p) __builtin_return_address(0)\n+#define runtime_getcallerpc() __builtin_return_address(0)\n \n #ifdef __rtems__\n void __wrap_rtems_task_variable_add(void **);"}]}