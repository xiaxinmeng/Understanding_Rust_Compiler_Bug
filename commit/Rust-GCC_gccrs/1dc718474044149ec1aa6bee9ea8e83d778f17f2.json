{"sha": "1dc718474044149ec1aa6bee9ea8e83d778f17f2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWRjNzE4NDc0MDQ0MTQ5ZWMxYWE2YmVlOWVhOGU4M2Q3NzhmMTdmMg==", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-08-17T16:28:15Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-08-19T14:39:21Z"}, "message": "optional trait item with associated types", "tree": {"sha": "688bcd5d3a550681afaa87b90c848f365d425bcb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/688bcd5d3a550681afaa87b90c848f365d425bcb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1dc718474044149ec1aa6bee9ea8e83d778f17f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1dc718474044149ec1aa6bee9ea8e83d778f17f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1dc718474044149ec1aa6bee9ea8e83d778f17f2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1dc718474044149ec1aa6bee9ea8e83d778f17f2/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c25cdc84600e81bfd4d1ae104ff9eb524f7c49f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c25cdc84600e81bfd4d1ae104ff9eb524f7c49f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c25cdc84600e81bfd4d1ae104ff9eb524f7c49f0"}], "stats": {"total": 846, "additions": 756, "deletions": 90}, "files": [{"sha": "7ed380eed732fce222a0d1cd337e604e8465b6a0", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1dc718474044149ec1aa6bee9ea8e83d778f17f2/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1dc718474044149ec1aa6bee9ea8e83d778f17f2/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=1dc718474044149ec1aa6bee9ea8e83d778f17f2", "patch": "@@ -80,6 +80,7 @@ GRS_OBJS = \\\n     rust/rust-tyty.o \\\n     rust/rust-tyctx.o \\\n     rust/rust-tyty-bounds.o \\\n+    rust/rust-hir-type-check-util.o \\\n     rust/rust-hir-trait-resolve.o \\\n     rust/rust-hir-const-fold.o \\\n     rust/rust-lint-marklive.o \\"}, {"sha": "6356ccc456d2de4b886c9d9308f9fa8cb08160ec", "filename": "gcc/rust/backend/rust-compile-context.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1dc718474044149ec1aa6bee9ea8e83d778f17f2/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1dc718474044149ec1aa6bee9ea8e83d778f17f2/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-context.h?ref=1dc718474044149ec1aa6bee9ea8e83d778f17f2", "patch": "@@ -336,10 +336,13 @@ class TyTyResolveCompile : public TyTy::TyVisitor\n \n   void visit (TyTy::InferType &) override { gcc_unreachable (); }\n \n-  void visit (TyTy::PlaceholderType &) override { gcc_unreachable (); }\n-\n   void visit (TyTy::ProjectionType &) override { gcc_unreachable (); }\n \n+  void visit (TyTy::PlaceholderType &type) override\n+  {\n+    type.resolve ()->accept_vis (*this);\n+  }\n+\n   void visit (TyTy::ParamType &param) override\n   {\n     param.resolve ()->accept_vis (*this);"}, {"sha": "809cf56d321551af54e6f610db6e80a1df0c52b3", "filename": "gcc/rust/backend/rust-compile-implitem.h", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1dc718474044149ec1aa6bee9ea8e83d778f17f2/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1dc718474044149ec1aa6bee9ea8e83d778f17f2/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h?ref=1dc718474044149ec1aa6bee9ea8e83d778f17f2", "patch": "@@ -319,15 +319,17 @@ class CompileTraitItem : public HIRCompileBase\n     // items can be forward compiled which means we may not need to invoke this\n     // code. We might also have already compiled this generic function as well.\n     Bfunction *lookup = nullptr;\n-    if (ctx->lookup_function_decl (fntype->get_ty_ref (), &lookup, fntype))\n+    if (ctx->lookup_function_decl (fntype->get_ty_ref (), &lookup))\n       {\n \t// has this been added to the list then it must be finished\n \tif (ctx->function_completed (lookup))\n \t  {\n \t    Bfunction *dummy = nullptr;\n \t    if (!ctx->lookup_function_decl (fntype->get_ty_ref (), &dummy))\n-\t      ctx->insert_function_decl (fntype->get_ty_ref (), lookup, fntype);\n-\n+\t      {\n+\t\tctx->insert_function_decl (fntype->get_ty_ref (), lookup,\n+\t\t\t\t\t   fntype);\n+\t      }\n \t    return;\n \t  }\n       }"}, {"sha": "1b892d22a13e89c7972699b1a9652dd39903b96a", "filename": "gcc/rust/backend/rust-compile-resolve-path.cc", "status": "modified", "additions": 27, "deletions": 22, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1dc718474044149ec1aa6bee9ea8e83d778f17f2/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1dc718474044149ec1aa6bee9ea8e83d778f17f2/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc?ref=1dc718474044149ec1aa6bee9ea8e83d778f17f2", "patch": "@@ -76,6 +76,7 @@ ResolvePathRef::visit (HIR::PathInExpression &expr)\n \t\t\t\t\t    &lookup);\n   rust_assert (ok);\n   rust_assert (lookup->get_kind () == TyTy::TypeKind::FNDEF);\n+  TyTy::FnType *fntype = static_cast<TyTy::FnType *> (lookup);\n \n   Bfunction *fn = nullptr;\n   if (!ctx->lookup_function_decl (lookup->get_ty_ref (), &fn))\n@@ -145,28 +146,32 @@ ResolvePathRef::visit (HIR::PathInExpression &expr)\n \t\t  rust_assert (\n \t\t    trait_item_ref->is_optional ()); // has definition\n \n-\t\t  // FIXME\n-\t\t  // TyTy::BaseType *self_type = nullptr;\n-\t\t  // if (!ctx->get_tyctx ()->lookup_type (\n-\t\t  //       expr.get_receiver ()->get_mappings ().get_hirid (),\n-\t\t  //       &self_type))\n-\t\t  //   {\n-\t\t  //     rust_error_at (expr.get_locus (),\n-\t\t  //       \t     \"failed to resolve type for self param\");\n-\t\t  //     return;\n-\t\t  //   }\n-\n-\t\t  // CompileTraitItem::Compile (\n-\t\t  //   self_type, trait_item_ref->get_hir_trait_item (), ctx,\n-\t\t  //   fntype);\n-\t\t  // if (!ctx->lookup_function_decl (fntype->get_ty_ref (),\n-\t\t  // &fn))\n-\t\t  //   {\n-\t\t  //     translated = ctx->get_backend ()->error_expression ();\n-\t\t  //     rust_error_at (expr.get_locus (),\n-\t\t  //       \t     \"forward declaration was not compiled\");\n-\t\t  //     return;\n-\t\t  //   }\n+\t\t  Analysis::NodeMapping trait_mappings\n+\t\t    = trait_item_ref->get_parent_trait_mappings ();\n+\t\t  auto associated_impl_id\n+\t\t    = ctx->get_tyctx ()\n+\t\t\t->lookup_associated_impl_mapping_for_self (\n+\t\t\t  trait_mappings.get_hirid (), receiver);\n+\t\t  rust_assert (associated_impl_id != UNKNOWN_HIRID);\n+\n+\t\t  Resolver::AssociatedImplTrait *associated = nullptr;\n+\t\t  bool found_associated_trait_impl\n+\t\t    = ctx->get_tyctx ()->lookup_associated_trait_impl (\n+\t\t      associated_impl_id, &associated);\n+\t\t  rust_assert (found_associated_trait_impl);\n+\t\t  associated->setup_associated_types ();\n+\n+\t\t  CompileTraitItem::Compile (\n+\t\t    receiver, trait_item_ref->get_hir_trait_item (), ctx,\n+\t\t    fntype);\n+\n+\t\t  if (!ctx->lookup_function_decl (fntype->get_ty_ref (), &fn))\n+\t\t    {\n+\t\t      resolved = ctx->get_backend ()->error_expression ();\n+\t\t      rust_error_at (expr.get_locus (),\n+\t\t\t\t     \"forward declaration was not compiled\");\n+\t\t      return;\n+\t\t    }\n \t\t}\n \t      else\n \t\t{"}, {"sha": "f737141d897ca53f50caf5459a0440e6a35ecf86", "filename": "gcc/rust/typecheck/rust-hir-path-probe.h", "status": "modified", "additions": 29, "deletions": 18, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1dc718474044149ec1aa6bee9ea8e83d778f17f2/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1dc718474044149ec1aa6bee9ea8e83d778f17f2/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.h?ref=1dc718474044149ec1aa6bee9ea8e83d778f17f2", "patch": "@@ -51,6 +51,7 @@ struct PathProbeCandidate\n   {\n     const TraitReference *trait_ref;\n     const TraitItemReference *item_ref;\n+    HIR::ImplBlock *impl;\n   };\n \n   CandidateType type;\n@@ -128,19 +129,22 @@ class PathProbeType : public TypeCheckBase\n     if (!probe_bounds)\n       return probe.candidates;\n \n-    std::vector<TraitReference *> probed_bounds\n+    std::vector<std::pair<TraitReference *, HIR::ImplBlock *>> probed_bounds\n       = TypeBoundsProbe::Probe (receiver);\n \n-    std::vector<const TraitReference *> specified_bounds;\n+    std::vector<std::pair<const TraitReference *, HIR::ImplBlock *>>\n+      specified_bounds;\n     for (const TyTy::TypeBoundPredicate &predicate :\n \t receiver->get_specified_bounds ())\n       {\n \tconst TraitReference *trait_item = predicate.get ();\n-\tspecified_bounds.push_back (trait_item);\n+\n+\t// FIXME lookup impl_block for this trait impl for this receiver\n+\tspecified_bounds.push_back ({trait_item, nullptr});\n       }\n \n-    std::vector<const TraitReference *> union_type_bounds\n-      = probe.union_bounds (probed_bounds, specified_bounds);\n+    std::vector<std::pair<const TraitReference *, HIR::ImplBlock *>>\n+      union_type_bounds = probe.union_bounds (probed_bounds, specified_bounds);\n     probe.process_traits_for_candidates (union_type_bounds,\n \t\t\t\t\t ignore_mandatory_trait_items);\n     return probe.candidates;\n@@ -230,11 +234,15 @@ class PathProbeType : public TypeCheckBase\n   }\n \n   void process_traits_for_candidates (\n-    const std::vector<const TraitReference *> traits,\n+    const std::vector<std::pair<const TraitReference *, HIR::ImplBlock *>>\n+      traits,\n     bool ignore_mandatory_trait_items)\n   {\n-    for (const TraitReference *trait_ref : traits)\n+    for (auto &ref : traits)\n       {\n+\tconst TraitReference *trait_ref = ref.first;\n+\tHIR::ImplBlock *impl = ref.second;\n+\n \tconst TraitItemReference *trait_item_ref = nullptr;\n \tif (!trait_ref->lookup_trait_item (search.as_string (),\n \t\t\t\t\t   &trait_item_ref))\n@@ -296,7 +304,7 @@ class PathProbeType : public TypeCheckBase\n \t  }\n \n \tPathProbeCandidate::TraitItemCandidate trait_item_candidate{\n-\t  trait_ref, trait_item_ref};\n+\t  trait_ref, trait_item_ref, impl};\n \tPathProbeCandidate candidate{candidate_type,\n \t\t\t\t     trait_item_tyty,\n \t\t\t\t     trait_ref->get_locus (),\n@@ -312,24 +320,27 @@ class PathProbeType : public TypeCheckBase\n       current_impl (nullptr)\n   {}\n \n-  std::vector<const TraitReference *>\n-  union_bounds (const std::vector</*const*/ TraitReference *> a,\n-\t\tconst std::vector<const TraitReference *> b) const\n+  std::vector<std::pair<const TraitReference *, HIR::ImplBlock *>>\n+  union_bounds (\n+    const std::vector<std::pair</*const*/ TraitReference *, HIR::ImplBlock *>>\n+      a,\n+    const std::vector<std::pair<const TraitReference *, HIR::ImplBlock *>> b)\n+    const\n   {\n-    std::map<DefId, const TraitReference *> mapper;\n-    for (const TraitReference *ref : a)\n+    std::map<DefId, std::pair<const TraitReference *, HIR::ImplBlock *>> mapper;\n+    for (auto &ref : a)\n       {\n-\tmapper.insert ({ref->get_mappings ().get_defid (), ref});\n+\tmapper.insert ({ref.first->get_mappings ().get_defid (), ref});\n       }\n-    for (const TraitReference *ref : b)\n+    for (auto &ref : b)\n       {\n-\tmapper.insert ({ref->get_mappings ().get_defid (), ref});\n+\tmapper.insert ({ref.first->get_mappings ().get_defid (), ref});\n       }\n \n-    std::vector<const TraitReference *> union_set;\n+    std::vector<std::pair<const TraitReference *, HIR::ImplBlock *>> union_set;\n     for (auto it = mapper.begin (); it != mapper.end (); it++)\n       {\n-\tunion_set.push_back (it->second);\n+\tunion_set.push_back ({it->second.first, it->second.second});\n       }\n     return union_set;\n   }"}, {"sha": "2c7a0e82f16f65bb8fec96bd2bef276793bf8a37", "filename": "gcc/rust/typecheck/rust-hir-trait-ref.h", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1dc718474044149ec1aa6bee9ea8e83d778f17f2/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1dc718474044149ec1aa6bee9ea8e83d778f17f2/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-ref.h?ref=1dc718474044149ec1aa6bee9ea8e83d778f17f2", "patch": "@@ -21,6 +21,7 @@\n \n #include \"rust-hir-full.h\"\n #include \"rust-tyty-visitor.h\"\n+#include \"rust-hir-type-check-util.h\"\n \n namespace Rust {\n namespace Resolver {\n@@ -148,13 +149,19 @@ class TraitItemReference\n     return get_error ();\n   }\n \n+  Analysis::NodeMapping get_parent_trait_mappings () const;\n+\n   // this is called when the trait is completed resolution and gives the items a\n   // chance to run their specific type resolution passes. If we call their\n   // resolution on construction it can lead to a case where the trait being\n   // resolved recursively trying to resolve the trait itself infinitely since\n   // the trait will not be stored in its own map yet\n   void on_resolved ();\n \n+  void associated_type_set (TyTy::BaseType *ty);\n+\n+  void associated_type_reset ();\n+\n private:\n   TyTy::ErrorType *get_error () const\n   {\n@@ -186,6 +193,7 @@ class TraitItemReference\n   Resolver::TypeCheckContext *context;\n };\n \n+// this wraps up the HIR::Trait so we can do analysis on it\n class TraitReference\n {\n public:\n@@ -316,11 +324,48 @@ class TraitReference\n       }\n   }\n \n+  void clear_associated_types ()\n+  {\n+    for (auto &item : item_refs)\n+      {\n+\tbool is_assoc_type = item.get_trait_item_type ()\n+\t\t\t     == TraitItemReference::TraitItemType::TYPE;\n+\tif (is_assoc_type)\n+\t  item.associated_type_reset ();\n+      }\n+  }\n+\n private:\n   const HIR::Trait *hir_trait_ref;\n   std::vector<TraitItemReference> item_refs;\n };\n \n+class AssociatedImplTrait\n+{\n+public:\n+  AssociatedImplTrait (TraitReference *trait, HIR::ImplBlock *impl,\n+\t\t       TyTy::BaseType *self,\n+\t\t       Resolver::TypeCheckContext *context)\n+    : trait (trait), impl (impl), self (self), context (context)\n+  {}\n+\n+  TraitReference *get_trait () { return trait; }\n+\n+  HIR::ImplBlock *get_impl_block () { return impl; }\n+\n+  TyTy::BaseType *get_self () { return self; }\n+\n+  void setup_associated_types ();\n+\n+  void reset_associated_types ();\n+\n+private:\n+  TraitReference *trait;\n+  HIR::ImplBlock *impl;\n+  TyTy::BaseType *self;\n+  Resolver::TypeCheckContext *context;\n+};\n+\n } // namespace Resolver\n } // namespace Rust\n "}, {"sha": "5d7c71e7b72a617d999e37b43d377f71d3bbd3a4", "filename": "gcc/rust/typecheck/rust-hir-trait-resolve.cc", "status": "modified", "additions": 70, "deletions": 5, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1dc718474044149ec1aa6bee9ea8e83d778f17f2/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1dc718474044149ec1aa6bee9ea8e83d778f17f2/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.cc?ref=1dc718474044149ec1aa6bee9ea8e83d778f17f2", "patch": "@@ -25,10 +25,6 @@ namespace Resolver {\n void\n ResolveTraitItemToRef::visit (HIR::TraitItemType &type)\n {\n-  TyTy::BaseType *ty\n-    = new TyTy::PlaceholderType (type.get_mappings ().get_hirid ());\n-  context->insert_type (type.get_mappings (), ty);\n-\n   // create trait-item-ref\n   Location locus = type.get_locus ();\n   bool is_optional = false;\n@@ -92,7 +88,10 @@ TraitItemReference::on_resolved ()\n void\n TraitItemReference::resolve_item (HIR::TraitItemType &type)\n {\n-  // TODO\n+  TyTy::BaseType *ty\n+    = new TyTy::PlaceholderType (type.get_name (),\n+\t\t\t\t type.get_mappings ().get_hirid ());\n+  context->insert_type (type.get_mappings (), ty);\n }\n \n void\n@@ -128,5 +127,71 @@ TraitItemReference::resolve_item (HIR::TraitItemFunc &func)\n     expected_ret_tyty->unify (block_expr_ty);\n }\n \n+void\n+TraitItemReference::associated_type_set (TyTy::BaseType *ty)\n+{\n+  rust_assert (get_trait_item_type () == TraitItemType::TYPE);\n+\n+  TyTy::BaseType *item_ty = get_tyty ();\n+  rust_assert (item_ty->get_kind () == TyTy::TypeKind::PLACEHOLDER);\n+  TyTy::PlaceholderType *placeholder\n+    = static_cast<TyTy::PlaceholderType *> (item_ty);\n+\n+  placeholder->set_associated_type (ty->get_ref ());\n+}\n+\n+void\n+TraitItemReference::associated_type_reset ()\n+{\n+  rust_assert (get_trait_item_type () == TraitItemType::TYPE);\n+\n+  TyTy::BaseType *item_ty = get_tyty ();\n+  rust_assert (item_ty->get_kind () == TyTy::TypeKind::PLACEHOLDER);\n+  TyTy::PlaceholderType *placeholder\n+    = static_cast<TyTy::PlaceholderType *> (item_ty);\n+\n+  placeholder->clear_associated_type ();\n+}\n+\n+void\n+AssociatedImplTrait::setup_associated_types ()\n+{\n+  ImplTypeIterator iter (*impl, [&] (HIR::TypeAlias &type) {\n+    TraitItemReference *resolved_trait_item = nullptr;\n+    bool ok = trait->lookup_trait_item (type.get_new_type_name (),\n+\t\t\t\t\t&resolved_trait_item);\n+    if (!ok)\n+      return;\n+    if (resolved_trait_item->get_trait_item_type ()\n+\t!= TraitItemReference::TraitItemType::TYPE)\n+      return;\n+\n+    TyTy::BaseType *lookup;\n+    if (!context->lookup_type (type.get_mappings ().get_hirid (), &lookup))\n+      return;\n+\n+    resolved_trait_item->associated_type_set (lookup);\n+  });\n+  iter.go ();\n+}\n+\n+void\n+AssociatedImplTrait::reset_associated_types ()\n+{\n+  trait->clear_associated_types ();\n+}\n+\n+Analysis::NodeMapping\n+TraitItemReference::get_parent_trait_mappings () const\n+{\n+  auto mappings = Analysis::Mappings::get ();\n+\n+  HIR::Trait *trait\n+    = mappings->lookup_trait_item_mapping (get_mappings ().get_hirid ());\n+  rust_assert (trait != nullptr);\n+\n+  return trait->get_mappings ();\n+}\n+\n } // namespace Resolver\n } // namespace Rust"}, {"sha": "1ba60493b97bdd8a8cb76bcc321631b1221b4976", "filename": "gcc/rust/typecheck/rust-hir-type-bounds.h", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1dc718474044149ec1aa6bee9ea8e83d778f17f2/gcc%2Frust%2Ftypecheck%2Frust-hir-type-bounds.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1dc718474044149ec1aa6bee9ea8e83d778f17f2/gcc%2Frust%2Ftypecheck%2Frust-hir-type-bounds.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-bounds.h?ref=1dc718474044149ec1aa6bee9ea8e83d778f17f2", "patch": "@@ -31,7 +31,8 @@ class TypeBoundsProbe : public TypeCheckBase\n   using Rust::Resolver::TypeCheckBase::visit;\n \n public:\n-  static std::vector<TraitReference *> Probe (const TyTy::BaseType *receiver)\n+  static std::vector<std::pair<TraitReference *, HIR::ImplBlock *>>\n+  Probe (const TyTy::BaseType *receiver)\n   {\n     TypeBoundsProbe probe (receiver);\n     probe.scan ();\n@@ -41,9 +42,11 @@ class TypeBoundsProbe : public TypeCheckBase\n   static bool is_bound_satisfied_for_type (TyTy::BaseType *receiver,\n \t\t\t\t\t   TraitReference *ref)\n   {\n-    std::vector<TraitReference *> bounds = Probe (receiver);\n-    for (TraitReference *b : bounds)\n+    std::vector<std::pair<TraitReference *, HIR::ImplBlock *>> bounds\n+      = Probe (receiver);\n+    for (auto &bound : bounds)\n       {\n+\tTraitReference *b = bound.first;\n \tif (b == ref)\n \t  return true;\n       }\n@@ -59,7 +62,7 @@ class TypeBoundsProbe : public TypeCheckBase\n   {}\n \n   const TyTy::BaseType *receiver;\n-  std::vector<TraitReference *> trait_references;\n+  std::vector<std::pair<TraitReference *, HIR::ImplBlock *>> trait_references;\n };\n \n } // namespace Resolver"}, {"sha": "0ac60c23ba3780e3e7d393a6136ef803e42a268f", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.h", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1dc718474044149ec1aa6bee9ea8e83d778f17f2/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1dc718474044149ec1aa6bee9ea8e83d778f17f2/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h?ref=1dc718474044149ec1aa6bee9ea8e83d778f17f2", "patch": "@@ -975,7 +975,6 @@ class TypeCheckExpr : public TypeCheckBase\n       }\n \n     // TODO self and generic arguments\n-\n     infered = trait_item_ref->get_tyty ();\n     rust_debug_loc (expr.get_locus (), \"resolved to:\");\n     infered->debug ();\n@@ -1370,6 +1369,22 @@ class TypeCheckExpr : public TypeCheckBase\n \t  {\n \t    resolved_node_id\n \t      = candidate.item.trait.item_ref->get_mappings ().get_nodeid ();\n+\n+\t    // lookup the associated-impl-trait\n+\t    HIR::ImplBlock *impl = candidate.item.trait.impl;\n+\t    if (impl != nullptr)\n+\t      {\n+\t\tAssociatedImplTrait *lookup_associated = nullptr;\n+\t\tbool found_impl_trait = context->lookup_associated_trait_impl (\n+\t\t  impl->get_mappings ().get_hirid (), &lookup_associated);\n+\t\trust_assert (found_impl_trait);\n+\n+\t\tlookup_associated->setup_associated_types ();\n+\n+\t\t// we need a new ty_ref_id for this trait item\n+\t\ttyseg = tyseg->clone ();\n+\t\ttyseg->set_ty_ref (mappings->get_next_hir_id ());\n+\t      }\n \t  }\n \n \tif (seg.has_generic_args ())"}, {"sha": "3d83523c1c14e1260fb579262bc173eb3622feb3", "filename": "gcc/rust/typecheck/rust-hir-type-check-implitem.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1dc718474044149ec1aa6bee9ea8e83d778f17f2/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1dc718474044149ec1aa6bee9ea8e83d778f17f2/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h?ref=1dc718474044149ec1aa6bee9ea8e83d778f17f2", "patch": "@@ -383,8 +383,7 @@ class TypeCheckImplItemWithTrait : public TypeCheckImplItem\n \t  trait_reference.get_name ().c_str ());\n       }\n \n-    context->insert_type (resolved_trait_item.get_mappings (),\n-\t\t\t  lookup->clone ());\n+    resolved_trait_item.associated_type_set (lookup);\n   }\n \n   void visit (HIR::Function &function) override"}, {"sha": "72da26dffaaa6cba9a9da1b18a6451aa2ae91dd0", "filename": "gcc/rust/typecheck/rust-hir-type-check-item.h", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1dc718474044149ec1aa6bee9ea8e83d778f17f2/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1dc718474044149ec1aa6bee9ea8e83d778f17f2/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h?ref=1dc718474044149ec1aa6bee9ea8e83d778f17f2", "patch": "@@ -123,6 +123,19 @@ class TypeCheckItem : public TypeCheckBase\n \t\t\t   trait_reference->get_name ().c_str ());\n \t  }\n       }\n+\n+    if (is_trait_impl_block)\n+      {\n+\ttrait_reference->clear_associated_types ();\n+\n+\tAssociatedImplTrait associated (trait_reference, &impl_block, self,\n+\t\t\t\t\tcontext);\n+\tcontext->insert_associated_trait_impl (\n+\t  impl_block.get_mappings ().get_hirid (), std::move (associated));\n+\tcontext->insert_associated_impl_mapping (\n+\t  trait_reference->get_mappings ().get_hirid (), self,\n+\t  impl_block.get_mappings ().get_hirid ());\n+      }\n   }\n \n   void visit (HIR::Function &function) override"}, {"sha": "82bd081997ec083bc7d5cc177a690d6977df683f", "filename": "gcc/rust/typecheck/rust-hir-type-check-util.cc", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1dc718474044149ec1aa6bee9ea8e83d778f17f2/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-util.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1dc718474044149ec1aa6bee9ea8e83d778f17f2/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-util.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-util.cc?ref=1dc718474044149ec1aa6bee9ea8e83d778f17f2", "patch": "@@ -0,0 +1,41 @@\n+// Copyright (C) 2021 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-hir-type-check-util.h\"\n+#include \"rust-hir-full.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+void\n+ImplTypeIterator::go ()\n+{\n+  for (auto &item : impl.get_impl_items ())\n+    {\n+      item->accept_vis (*this);\n+    }\n+}\n+\n+void\n+ImplTypeIterator::visit (HIR::TypeAlias &alias)\n+{\n+  cb (alias);\n+}\n+\n+} // namespace Resolver\n+} // namespace Rust"}, {"sha": "0ba07a189f751498e8c8864a44b4ddf78a67e0dc", "filename": "gcc/rust/typecheck/rust-hir-type-check-util.h", "status": "added", "additions": 216, "deletions": 0, "changes": 216, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1dc718474044149ec1aa6bee9ea8e83d778f17f2/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-util.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1dc718474044149ec1aa6bee9ea8e83d778f17f2/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-util.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-util.h?ref=1dc718474044149ec1aa6bee9ea8e83d778f17f2", "patch": "@@ -0,0 +1,216 @@\n+// Copyright (C) 2021 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_HIR_TYPE_CHECK_UTIL_H\n+#define RUST_HIR_TYPE_CHECK_UTIL_H\n+\n+#include <functional>\n+#include \"rust-hir-visitor.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+class SimpleHirVisitor : public HIR::HIRVisitor\n+{\n+public:\n+  virtual ~SimpleHirVisitor () {}\n+\n+  virtual void visit (HIR::IdentifierExpr &) override {}\n+  virtual void visit (HIR::Lifetime &) override {}\n+  virtual void visit (HIR::LifetimeParam &) override {}\n+  virtual void visit (HIR::PathInExpression &) override {}\n+  virtual void visit (HIR::TypePathSegment &) override {}\n+  virtual void visit (HIR::TypePathSegmentGeneric &) override {}\n+  virtual void visit (HIR::TypePathSegmentFunction &) override {}\n+  virtual void visit (HIR::TypePath &) override {}\n+  virtual void visit (HIR::QualifiedPathInExpression &) override {}\n+  virtual void visit (HIR::QualifiedPathInType &) override {}\n+\n+  virtual void visit (HIR::LiteralExpr &) override {}\n+  virtual void visit (HIR::BorrowExpr &) override {}\n+  virtual void visit (HIR::DereferenceExpr &) override {}\n+  virtual void visit (HIR::ErrorPropagationExpr &) override {}\n+  virtual void visit (HIR::NegationExpr &) override {}\n+  virtual void visit (HIR::ArithmeticOrLogicalExpr &) override {}\n+  virtual void visit (HIR::ComparisonExpr &) override {}\n+  virtual void visit (HIR::LazyBooleanExpr &) override {}\n+  virtual void visit (HIR::TypeCastExpr &) override {}\n+  virtual void visit (HIR::AssignmentExpr &) override {}\n+\n+  virtual void visit (HIR::GroupedExpr &) override {}\n+\n+  virtual void visit (HIR::ArrayElemsValues &) override {}\n+  virtual void visit (HIR::ArrayElemsCopied &) override {}\n+  virtual void visit (HIR::ArrayExpr &) override {}\n+  virtual void visit (HIR::ArrayIndexExpr &) override {}\n+  virtual void visit (HIR::TupleExpr &) override {}\n+  virtual void visit (HIR::TupleIndexExpr &) override {}\n+  virtual void visit (HIR::StructExprStruct &) override {}\n+\n+  virtual void visit (HIR::StructExprFieldIdentifier &) override {}\n+  virtual void visit (HIR::StructExprFieldIdentifierValue &) override {}\n+\n+  virtual void visit (HIR::StructExprFieldIndexValue &) override {}\n+  virtual void visit (HIR::StructExprStructFields &) override {}\n+  virtual void visit (HIR::StructExprStructBase &) override {}\n+  virtual void visit (HIR::StructExprTuple &) override {}\n+  virtual void visit (HIR::StructExprUnit &) override {}\n+\n+  virtual void visit (HIR::EnumExprFieldIdentifier &) override {}\n+  virtual void visit (HIR::EnumExprFieldIdentifierValue &) override {}\n+\n+  virtual void visit (HIR::EnumExprFieldIndexValue &) override {}\n+  virtual void visit (HIR::EnumExprStruct &) override {}\n+  virtual void visit (HIR::EnumExprTuple &) override {}\n+  virtual void visit (HIR::EnumExprFieldless &) override {}\n+  virtual void visit (HIR::CallExpr &) override {}\n+  virtual void visit (HIR::MethodCallExpr &) override {}\n+  virtual void visit (HIR::FieldAccessExpr &) override {}\n+  virtual void visit (HIR::ClosureExprInner &) override {}\n+  virtual void visit (HIR::BlockExpr &) override {}\n+  virtual void visit (HIR::ClosureExprInnerTyped &) override {}\n+  virtual void visit (HIR::ContinueExpr &) override {}\n+  virtual void visit (HIR::BreakExpr &) override {}\n+  virtual void visit (HIR::RangeFromToExpr &) override {}\n+  virtual void visit (HIR::RangeFromExpr &) override {}\n+  virtual void visit (HIR::RangeToExpr &) override {}\n+  virtual void visit (HIR::RangeFullExpr &) override {}\n+  virtual void visit (HIR::RangeFromToInclExpr &) override {}\n+  virtual void visit (HIR::RangeToInclExpr &) override {}\n+  virtual void visit (HIR::ReturnExpr &) override {}\n+  virtual void visit (HIR::UnsafeBlockExpr &) override {}\n+  virtual void visit (HIR::LoopExpr &) override {}\n+  virtual void visit (HIR::WhileLoopExpr &) override {}\n+  virtual void visit (HIR::WhileLetLoopExpr &) override {}\n+  virtual void visit (HIR::ForLoopExpr &) override {}\n+  virtual void visit (HIR::IfExpr &) override {}\n+  virtual void visit (HIR::IfExprConseqElse &) override {}\n+  virtual void visit (HIR::IfExprConseqIf &) override {}\n+  virtual void visit (HIR::IfExprConseqIfLet &) override {}\n+  virtual void visit (HIR::IfLetExpr &) override {}\n+  virtual void visit (HIR::IfLetExprConseqElse &) override {}\n+  virtual void visit (HIR::IfLetExprConseqIf &) override {}\n+  virtual void visit (HIR::IfLetExprConseqIfLet &) override {}\n+\n+  virtual void visit (HIR::MatchExpr &) override {}\n+  virtual void visit (HIR::AwaitExpr &) override {}\n+  virtual void visit (HIR::AsyncBlockExpr &) override {}\n+\n+  virtual void visit (HIR::TypeParam &) override {}\n+\n+  virtual void visit (HIR::LifetimeWhereClauseItem &) override {}\n+  virtual void visit (HIR::TypeBoundWhereClauseItem &) override {}\n+  virtual void visit (HIR::ModuleBodied &) override {}\n+  virtual void visit (HIR::ModuleNoBody &) override {}\n+  virtual void visit (HIR::ExternCrate &) override {}\n+\n+  virtual void visit (HIR::UseTreeGlob &) override {}\n+  virtual void visit (HIR::UseTreeList &) override {}\n+  virtual void visit (HIR::UseTreeRebind &) override {}\n+  virtual void visit (HIR::UseDeclaration &) override {}\n+  virtual void visit (HIR::Function &) override {}\n+  virtual void visit (HIR::TypeAlias &) override {}\n+  virtual void visit (HIR::StructStruct &) override {}\n+  virtual void visit (HIR::TupleStruct &) override {}\n+  virtual void visit (HIR::EnumItem &) override {}\n+  virtual void visit (HIR::EnumItemTuple &) override {}\n+  virtual void visit (HIR::EnumItemStruct &) override {}\n+  virtual void visit (HIR::EnumItemDiscriminant &) override {}\n+  virtual void visit (HIR::Enum &) override {}\n+  virtual void visit (HIR::Union &) override {}\n+  virtual void visit (HIR::ConstantItem &) override {}\n+  virtual void visit (HIR::StaticItem &) override {}\n+  virtual void visit (HIR::TraitItemFunc &) override {}\n+  virtual void visit (HIR::TraitItemConst &) override {}\n+  virtual void visit (HIR::TraitItemType &) override {}\n+  virtual void visit (HIR::Trait &) override {}\n+  virtual void visit (HIR::ImplBlock &) override {}\n+\n+  virtual void visit (HIR::ExternalStaticItem &) override {}\n+  virtual void visit (HIR::ExternalFunctionItem &) override {}\n+  virtual void visit (HIR::ExternBlock &) override {}\n+\n+  virtual void visit (HIR::LiteralPattern &) override {}\n+  virtual void visit (HIR::IdentifierPattern &) override {}\n+  virtual void visit (HIR::WildcardPattern &) override {}\n+\n+  virtual void visit (HIR::RangePatternBoundLiteral &) override {}\n+  virtual void visit (HIR::RangePatternBoundPath &) override {}\n+  virtual void visit (HIR::RangePatternBoundQualPath &) override {}\n+  virtual void visit (HIR::RangePattern &) override {}\n+  virtual void visit (HIR::ReferencePattern &) override {}\n+\n+  virtual void visit (HIR::StructPatternFieldTuplePat &) override {}\n+  virtual void visit (HIR::StructPatternFieldIdentPat &) override {}\n+  virtual void visit (HIR::StructPatternFieldIdent &) override {}\n+  virtual void visit (HIR::StructPattern &) override {}\n+\n+  virtual void visit (HIR::TupleStructItemsNoRange &) override {}\n+  virtual void visit (HIR::TupleStructItemsRange &) override {}\n+  virtual void visit (HIR::TupleStructPattern &) override {}\n+\n+  virtual void visit (HIR::TuplePatternItemsMultiple &) override {}\n+  virtual void visit (HIR::TuplePatternItemsRanged &) override {}\n+  virtual void visit (HIR::TuplePattern &) override {}\n+  virtual void visit (HIR::GroupedPattern &) override {}\n+  virtual void visit (HIR::SlicePattern &) override {}\n+\n+  virtual void visit (HIR::EmptyStmt &) override {}\n+  virtual void visit (HIR::LetStmt &) override {}\n+  virtual void visit (HIR::ExprStmtWithoutBlock &) override {}\n+  virtual void visit (HIR::ExprStmtWithBlock &) override {}\n+\n+  virtual void visit (HIR::TraitBound &) override {}\n+  virtual void visit (HIR::ImplTraitType &) override {}\n+  virtual void visit (HIR::TraitObjectType &) override {}\n+  virtual void visit (HIR::ParenthesisedType &) override {}\n+  virtual void visit (HIR::ImplTraitTypeOneBound &) override {}\n+  virtual void visit (HIR::TraitObjectTypeOneBound &) override {}\n+  virtual void visit (HIR::TupleType &) override {}\n+  virtual void visit (HIR::NeverType &) override {}\n+  virtual void visit (HIR::RawPointerType &) override {}\n+  virtual void visit (HIR::ReferenceType &) override {}\n+  virtual void visit (HIR::ArrayType &) override {}\n+  virtual void visit (HIR::SliceType &) override {}\n+  virtual void visit (HIR::InferredType &) override {}\n+  virtual void visit (HIR::BareFunctionType &) override {}\n+};\n+\n+class ImplTypeIterator : public SimpleHirVisitor\n+{\n+  using SimpleHirVisitor::visit;\n+\n+public:\n+  ImplTypeIterator (HIR::ImplBlock &impl,\n+\t\t    std::function<void (HIR::TypeAlias &alias)> cb)\n+    : impl (impl), cb (cb)\n+  {}\n+\n+  void go ();\n+\n+  void visit (HIR::TypeAlias &alias) override;\n+\n+private:\n+  HIR::ImplBlock &impl;\n+  std::function<void (HIR::TypeAlias &alias)> cb;\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_HIR_TYPE_CHECK_UTIL_H"}, {"sha": "27b7f1297a4d5ce58b4986fbdf30b39f2e56da49", "filename": "gcc/rust/typecheck/rust-hir-type-check.h", "status": "modified", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1dc718474044149ec1aa6bee9ea8e83d778f17f2/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1dc718474044149ec1aa6bee9ea8e83d778f17f2/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.h?ref=1dc718474044149ec1aa6bee9ea8e83d778f17f2", "patch": "@@ -117,6 +117,70 @@ class TypeCheckContext\n     return true;\n   }\n \n+  void insert_associated_trait_impl (HirId id, AssociatedImplTrait &&associated)\n+  {\n+    rust_assert (associated_impl_traits.find (id)\n+\t\t == associated_impl_traits.end ());\n+    associated_impl_traits.emplace (id, std::move (associated));\n+  }\n+\n+  bool lookup_associated_trait_impl (HirId id, AssociatedImplTrait **associated)\n+  {\n+    auto it = associated_impl_traits.find (id);\n+    if (it == associated_impl_traits.end ())\n+      return false;\n+\n+    *associated = &it->second;\n+    return true;\n+  }\n+\n+  void insert_associated_type_mapping (HirId id, HirId mapping)\n+  {\n+    associated_type_mappings[id] = mapping;\n+  }\n+\n+  void clear_associated_type_mapping (HirId id)\n+  {\n+    associated_type_mappings[id] = UNKNOWN_HIRID;\n+  }\n+\n+  HirId lookup_associated_type_mapping (HirId id, HirId default_value)\n+  {\n+    auto it = associated_type_mappings.find (id);\n+    if (it == associated_type_mappings.end ())\n+      return default_value;\n+\n+    return it->second;\n+  }\n+\n+  void insert_associated_impl_mapping (HirId trait_id,\n+\t\t\t\t       const TyTy::BaseType *impl_type,\n+\t\t\t\t       HirId impl_id)\n+  {\n+    auto it = associated_traits_to_impls.find (trait_id);\n+    if (it == associated_traits_to_impls.end ())\n+      {\n+\tassociated_traits_to_impls[trait_id] = {};\n+      }\n+\n+    associated_traits_to_impls[trait_id].push_back ({impl_type, impl_id});\n+  }\n+\n+  HirId lookup_associated_impl_mapping_for_self (HirId trait_id,\n+\t\t\t\t\t\t const TyTy::BaseType *self)\n+  {\n+    auto it = associated_traits_to_impls.find (trait_id);\n+    if (it == associated_traits_to_impls.end ())\n+      return UNKNOWN_HIRID;\n+\n+    for (auto &item : it->second)\n+      {\n+\tif (item.first->can_eq (self, false))\n+\t  return item.second;\n+      }\n+    return UNKNOWN_HIRID;\n+  }\n+\n private:\n   TypeCheckContext ();\n \n@@ -127,6 +191,13 @@ class TypeCheckContext\n   std::vector<TyTy::BaseType *> loop_type_stack;\n   std::map<DefId, TraitReference> trait_context;\n   std::map<HirId, TyTy::BaseType *> receiver_context;\n+  std::map<HirId, AssociatedImplTrait> associated_impl_traits;\n+\n+  // trait-id -> list of < self-tyty:impl-id>\n+  std::map<HirId, std::vector<std::pair<const TyTy::BaseType *, HirId>>>\n+    associated_traits_to_impls;\n+\n+  std::map<HirId, HirId> associated_type_mappings;\n };\n \n class TypeResolution"}, {"sha": "1bd7865ab0e90fca5239b685da2a6d309b92b2d0", "filename": "gcc/rust/typecheck/rust-tyty-bounds.cc", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1dc718474044149ec1aa6bee9ea8e83d778f17f2/gcc%2Frust%2Ftypecheck%2Frust-tyty-bounds.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1dc718474044149ec1aa6bee9ea8e83d778f17f2/gcc%2Frust%2Ftypecheck%2Frust-tyty-bounds.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-bounds.cc?ref=1dc718474044149ec1aa6bee9ea8e83d778f17f2", "patch": "@@ -25,7 +25,8 @@ namespace Resolver {\n void\n TypeBoundsProbe::scan ()\n {\n-  std::vector<HIR::TypePath *> possible_trait_paths;\n+  std::vector<std::pair<HIR::TypePath *, HIR::ImplBlock *>>\n+    possible_trait_paths;\n   mappings->iterate_impl_blocks (\n     [&] (HirId id, HIR::ImplBlock *impl) mutable -> bool {\n       // we are filtering for trait-impl-blocks\n@@ -42,16 +43,17 @@ TypeBoundsProbe::scan ()\n       if (!receiver->can_eq (impl_type, false))\n \treturn true;\n \n-      possible_trait_paths.push_back (impl->get_trait_ref ().get ());\n+      possible_trait_paths.push_back ({impl->get_trait_ref ().get (), impl});\n       return true;\n     });\n \n-  for (auto &trait_path : possible_trait_paths)\n+  for (auto &path : possible_trait_paths)\n     {\n+      HIR::TypePath *trait_path = path.first;\n       TraitReference *trait_ref = TraitResolver::Resolve (*trait_path);\n \n       if (!trait_ref->is_error ())\n-\ttrait_references.push_back (trait_ref);\n+\ttrait_references.push_back ({trait_ref, path.second});\n     }\n }\n "}, {"sha": "100e384da2bf95a61e7ea5b6316ea8d5af204dee", "filename": "gcc/rust/typecheck/rust-tyty-cmp.h", "status": "modified", "additions": 41, "deletions": 19, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1dc718474044149ec1aa6bee9ea8e83d778f17f2/gcc%2Frust%2Ftypecheck%2Frust-tyty-cmp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1dc718474044149ec1aa6bee9ea8e83d778f17f2/gcc%2Frust%2Ftypecheck%2Frust-tyty-cmp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-cmp.h?ref=1dc718474044149ec1aa6bee9ea8e83d778f17f2", "patch": "@@ -43,6 +43,16 @@ class BaseCmp : public TyConstVisitor\n \t    return ok;\n \t  }\n       }\n+    else if (other->get_kind () == TypeKind::PLACEHOLDER)\n+      {\n+\tconst PlaceholderType *p = static_cast<const PlaceholderType *> (other);\n+\tif (p->can_resolve ())\n+\t  {\n+\t    const BaseType *resolved = p->resolve ();\n+\t    resolved->accept_vis (*this);\n+\t    return ok;\n+\t  }\n+      }\n \n     other->accept_vis (*this);\n     return ok;\n@@ -1165,43 +1175,55 @@ class PlaceholderCmp : public BaseCmp\n     : BaseCmp (base, emit_errors), base (base)\n   {}\n \n-  virtual void visit (const TupleType &) override { ok = true; }\n+  bool can_eq (const BaseType *other) override\n+  {\n+    if (!base->can_resolve ())\n+      return BaseCmp::can_eq (other);\n+\n+    BaseType *lookup = base->resolve ();\n+    return lookup->can_eq (other, emit_error_flag);\n+  }\n+\n+  void visit (const TupleType &) override { ok = true; }\n \n-  virtual void visit (const ADTType &) override { ok = true; }\n+  void visit (const ADTType &) override { ok = true; }\n \n-  virtual void visit (const InferType &) override { ok = true; }\n+  void visit (const InferType &) override { ok = true; }\n \n-  virtual void visit (const FnType &) override { ok = true; }\n+  void visit (const FnType &) override { ok = true; }\n \n-  virtual void visit (const FnPtr &) override { ok = true; }\n+  void visit (const FnPtr &) override { ok = true; }\n \n-  virtual void visit (const ArrayType &) override { ok = true; }\n+  void visit (const ArrayType &) override { ok = true; }\n \n-  virtual void visit (const BoolType &) override { ok = true; }\n+  void visit (const BoolType &) override { ok = true; }\n \n-  virtual void visit (const IntType &) override { ok = true; }\n+  void visit (const IntType &) override { ok = true; }\n \n-  virtual void visit (const UintType &) override { ok = true; }\n+  void visit (const UintType &) override { ok = true; }\n \n-  virtual void visit (const USizeType &) override { ok = true; }\n+  void visit (const USizeType &) override { ok = true; }\n \n-  virtual void visit (const ISizeType &) override { ok = true; }\n+  void visit (const ISizeType &) override { ok = true; }\n \n-  virtual void visit (const FloatType &) override { ok = true; }\n+  void visit (const FloatType &) override { ok = true; }\n \n-  virtual void visit (const ErrorType &) override { ok = true; }\n+  void visit (const ErrorType &) override { ok = true; }\n \n-  virtual void visit (const CharType &) override { ok = true; }\n+  void visit (const CharType &) override { ok = true; }\n \n-  virtual void visit (const ReferenceType &) override { ok = true; }\n+  void visit (const ReferenceType &) override { ok = true; }\n \n-  virtual void visit (const ParamType &) override { ok = true; }\n+  void visit (const ParamType &) override { ok = true; }\n \n-  virtual void visit (const StrType &) override { ok = true; }\n+  void visit (const StrType &) override { ok = true; }\n \n-  virtual void visit (const NeverType &) override { ok = true; }\n+  void visit (const NeverType &) override { ok = true; }\n \n-  virtual void visit (const PlaceholderType &) override { ok = true; }\n+  void visit (const PlaceholderType &type) override\n+  {\n+    ok = base->get_symbol ().compare (type.get_symbol ()) == 0;\n+  }\n \n private:\n   const BaseType *get_base () const override { return base; }"}, {"sha": "4d0b977d961b8679ca6577bd317561434910469c", "filename": "gcc/rust/typecheck/rust-tyty-rules.h", "status": "modified", "additions": 40, "deletions": 1, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1dc718474044149ec1aa6bee9ea8e83d778f17f2/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1dc718474044149ec1aa6bee9ea8e83d778f17f2/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h?ref=1dc718474044149ec1aa6bee9ea8e83d778f17f2", "patch": "@@ -68,6 +68,14 @@ class BaseRules : public TyVisitor\n \t    other = p->resolve ();\n \t  }\n       }\n+    else if (other->get_kind () == TypeKind::PLACEHOLDER)\n+      {\n+\tPlaceholderType *p = static_cast<PlaceholderType *> (other);\n+\tif (p->can_resolve ())\n+\t  {\n+\t    other = p->resolve ();\n+\t  }\n+      }\n \n     other->accept_vis (*this);\n     if (resolved->get_kind () == TyTy::TypeKind::ERROR)\n@@ -1249,7 +1257,7 @@ class NeverRules : public BaseRules\n public:\n   NeverRules (NeverType *base) : BaseRules (base), base (base) {}\n \n-  virtual void visit (NeverType &type) override { resolved = type.clone (); }\n+  void visit (NeverType &type) override { resolved = type.clone (); }\n \n private:\n   BaseType *get_base () override { return base; }\n@@ -1264,6 +1272,37 @@ class PlaceholderRules : public BaseRules\n public:\n   PlaceholderRules (PlaceholderType *base) : BaseRules (base), base (base) {}\n \n+  BaseType *unify (BaseType *other) override final\n+  {\n+    if (!base->can_resolve ())\n+      return BaseRules::unify (other);\n+\n+    BaseType *lookup = base->resolve ();\n+    return lookup->unify (other);\n+  }\n+\n+  void visit (PlaceholderType &type) override\n+  {\n+    if (base->get_symbol ().compare (type.get_symbol ()) != 0)\n+      {\n+\tBaseRules::visit (type);\n+\treturn;\n+      }\n+\n+    resolved = type.clone ();\n+  }\n+\n+  void visit (InferType &type) override\n+  {\n+    if (type.get_infer_kind () != InferType::InferTypeKind::GENERAL)\n+      {\n+\tBaseRules::visit (type);\n+\treturn;\n+      }\n+\n+    resolved = base->clone ();\n+  }\n+\n private:\n   BaseType *get_base () override { return base; }\n "}, {"sha": "18ccaee4332cf3473aef9ce927e73d162f6e4bc5", "filename": "gcc/rust/typecheck/rust-tyty.cc", "status": "modified", "additions": 69, "deletions": 5, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1dc718474044149ec1aa6bee9ea8e83d778f17f2/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1dc718474044149ec1aa6bee9ea8e83d778f17f2/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc?ref=1dc718474044149ec1aa6bee9ea8e83d778f17f2", "patch": "@@ -49,10 +49,10 @@ BaseType::satisfies_bound (const TypeBoundPredicate &predicate) const\n \treturn true;\n     }\n \n-  std::vector<Resolver::TraitReference *> probed\n-    = Resolver::TypeBoundsProbe::Probe (this);\n-  for (const Resolver::TraitReference *bound : probed)\n+  auto probed = Resolver::TypeBoundsProbe::Probe (this);\n+  for (auto &b : probed)\n     {\n+      const Resolver::TraitReference *bound = b.first;\n       bool found = bound->get_mappings ().get_defid ()\n \t\t   == query->get_mappings ().get_defid ();\n       if (found)\n@@ -2032,7 +2032,8 @@ PlaceholderType::accept_vis (TyConstVisitor &vis) const\n std::string\n PlaceholderType::as_string () const\n {\n-  return \"<placeholder>\";\n+  return \"<placeholder:\" + (can_resolve () ? resolve ()->as_string () : \"\")\n+\t + \">\";\n }\n \n BaseType *\n@@ -2066,7 +2067,59 @@ PlaceholderType::can_eq (const BaseType *other, bool emit_errors) const\n BaseType *\n PlaceholderType::clone () const\n {\n-  return new PlaceholderType (get_ref (), get_ty_ref (), get_combined_refs ());\n+  return new PlaceholderType (get_symbol (), get_ref (), get_ty_ref (),\n+\t\t\t      get_combined_refs ());\n+}\n+\n+void\n+PlaceholderType::set_associated_type (HirId ref)\n+{\n+  auto context = Resolver::TypeCheckContext::get ();\n+  context->insert_associated_type_mapping (get_ty_ref (), ref);\n+}\n+\n+void\n+PlaceholderType::clear_associated_type ()\n+{\n+  auto context = Resolver::TypeCheckContext::get ();\n+  context->clear_associated_type_mapping (get_ty_ref ());\n+}\n+\n+bool\n+PlaceholderType::can_resolve () const\n+{\n+  auto context = Resolver::TypeCheckContext::get ();\n+  HirId val\n+    = context->lookup_associated_type_mapping (get_ty_ref (), UNKNOWN_HIRID);\n+  return val != UNKNOWN_HIRID;\n+}\n+\n+BaseType *\n+PlaceholderType::resolve () const\n+{\n+  auto context = Resolver::TypeCheckContext::get ();\n+\n+  rust_assert (can_resolve ());\n+  HirId val\n+    = context->lookup_associated_type_mapping (get_ty_ref (), UNKNOWN_HIRID);\n+  rust_assert (val != UNKNOWN_HIRID);\n+\n+  return TyVar (val).get_tyty ();\n+}\n+\n+bool\n+PlaceholderType::is_equal (const BaseType &other) const\n+{\n+  if (get_kind () != other.get_kind ())\n+    {\n+      if (!can_resolve ())\n+\treturn false;\n+\n+      return resolve ()->is_equal (other);\n+    }\n+\n+  auto other2 = static_cast<const PlaceholderType &> (other);\n+  return get_symbol ().compare (other2.get_symbol ()) == 0;\n }\n \n // Projection type\n@@ -2243,6 +2296,17 @@ TypeCheckCallExpr::visit (FnType &type)\n       return;\n     }\n \n+  if (type.get_return_type ()->get_kind () == TyTy::TypeKind::PLACEHOLDER)\n+    {\n+      const TyTy::PlaceholderType *p\n+\t= static_cast<const TyTy::PlaceholderType *> (type.get_return_type ());\n+      if (p->can_resolve ())\n+\t{\n+\t  resolved = p->resolve ()->clone ();\n+\t  return;\n+\t}\n+    }\n+\n   resolved = type.get_return_type ()->clone ();\n }\n "}, {"sha": "2fc6b534831f425e1354d0900e093e86b0727b8d", "filename": "gcc/rust/typecheck/rust-tyty.h", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1dc718474044149ec1aa6bee9ea8e83d778f17f2/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1dc718474044149ec1aa6bee9ea8e83d778f17f2/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.h?ref=1dc718474044149ec1aa6bee9ea8e83d778f17f2", "patch": "@@ -1683,13 +1683,15 @@ class NeverType : public BaseType\n class PlaceholderType : public BaseType\n {\n public:\n-  PlaceholderType (HirId ref, std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ref, TypeKind::PLACEHOLDER, refs)\n+  PlaceholderType (std::string symbol, HirId ref,\n+\t\t   std::set<HirId> refs = std::set<HirId> ())\n+    : BaseType (ref, ref, TypeKind::PLACEHOLDER, refs), symbol (symbol)\n+\n   {}\n \n-  PlaceholderType (HirId ref, HirId ty_ref,\n+  PlaceholderType (std::string symbol, HirId ref, HirId ty_ref,\n \t\t   std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ty_ref, TypeKind::PLACEHOLDER, refs)\n+    : BaseType (ref, ty_ref, TypeKind::PLACEHOLDER, refs), symbol (symbol)\n   {}\n \n   void accept_vis (TyVisitor &vis) override;\n@@ -1707,6 +1709,21 @@ class PlaceholderType : public BaseType\n   std::string get_name () const override final { return as_string (); }\n \n   bool is_unit () const override { return true; }\n+\n+  std::string get_symbol () const { return symbol; }\n+\n+  void set_associated_type (HirId ref);\n+\n+  void clear_associated_type ();\n+\n+  bool can_resolve () const;\n+\n+  BaseType *resolve () const;\n+\n+  bool is_equal (const BaseType &other) const override;\n+\n+private:\n+  std::string symbol;\n };\n \n class ProjectionType : public BaseType"}, {"sha": "b5fc023e6a8ee7e2ea1a7b1122c2d4e3e720d2a9", "filename": "gcc/testsuite/rust/compile/torture/traits11.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1dc718474044149ec1aa6bee9ea8e83d778f17f2/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits11.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1dc718474044149ec1aa6bee9ea8e83d778f17f2/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits11.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits11.rs?ref=1dc718474044149ec1aa6bee9ea8e83d778f17f2", "patch": "@@ -0,0 +1,32 @@\n+trait Foo {\n+    type A;\n+    // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+\n+    fn test(a: Self::A) -> Self::A {\n+        a\n+    }\n+}\n+\n+struct Bar(i32);\n+impl Foo for Bar {\n+    type A = i32;\n+}\n+\n+struct Baz(f32);\n+impl Foo for Baz {\n+    type A = f32;\n+}\n+\n+fn main() {\n+    let a;\n+    a = Bar(123);\n+\n+    let b;\n+    b = Bar::test(a.0);\n+\n+    let c;\n+    c = Baz(123f32);\n+\n+    let d;\n+    d = Baz::test(c.0);\n+}"}]}