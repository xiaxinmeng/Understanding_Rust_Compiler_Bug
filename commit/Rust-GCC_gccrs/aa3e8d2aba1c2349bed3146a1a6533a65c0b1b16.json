{"sha": "aa3e8d2aba1c2349bed3146a1a6533a65c0b1b16", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWEzZThkMmFiYTFjMjM0OWJlZDMxNDZhMWE2NTMzYTY1YzBiMWIxNg==", "commit": {"author": {"name": "James Van Artsdalen", "email": "jrv@gnu.org", "date": "1992-10-12T13:12:08Z"}, "committer": {"name": "James Van Artsdalen", "email": "jrv@gnu.org", "date": "1992-10-12T13:12:08Z"}, "message": "(PRINT_REG): Undo Oct 11 change.\n\n(DEBUG_PRINT_REG): New macro, used from print-rtl.c.\n\nFrom-SVN: r2408", "tree": {"sha": "9a011948799698d97d721e9dff74fdde78a19586", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9a011948799698d97d721e9dff74fdde78a19586"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aa3e8d2aba1c2349bed3146a1a6533a65c0b1b16", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa3e8d2aba1c2349bed3146a1a6533a65c0b1b16", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa3e8d2aba1c2349bed3146a1a6533a65c0b1b16", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa3e8d2aba1c2349bed3146a1a6533a65c0b1b16/comments", "author": null, "committer": null, "parents": [{"sha": "83e9c679c039868eebe522bbb03cdf18eba90b34", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83e9c679c039868eebe522bbb03cdf18eba90b34", "html_url": "https://github.com/Rust-GCC/gccrs/commit/83e9c679c039868eebe522bbb03cdf18eba90b34"}], "stats": {"total": 45, "additions": 39, "deletions": 6}, "files": [{"sha": "ec7daeac483fda17bca48d20ef1c34de79d2a334", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 39, "deletions": 6, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa3e8d2aba1c2349bed3146a1a6533a65c0b1b16/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa3e8d2aba1c2349bed3146a1a6533a65c0b1b16/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=aa3e8d2aba1c2349bed3146a1a6533a65c0b1b16", "patch": "@@ -1460,11 +1460,13 @@ do { union { float f; long l;} tem;\t\t\t\\\n    If CODE is 'h', pretend the reg is the `high' byte register.\n    If CODE is 'y', print \"st(0)\" instead of \"st\", if the reg is stack op. */\n \n+extern char *hi_reg_name[];\n+extern char *qi_reg_name[];\n+extern char *qi_high_reg_name[];\n+\n #define PRINT_REG(X, CODE, FILE) \\\n-  do { static char *hi_reg_name[] = HI_REGISTER_NAMES;\t\\\n-       static char *qi_reg_name[] = QI_REGISTER_NAMES;\t\\\n-       static char *qi_high_reg_name[] = QI_HIGH_REGISTER_NAMES;\t\\\n-       if (REGNO (X) == ARG_POINTER_REGNUM) abort ();\t\\\n+  do { if (REGNO (X) == ARG_POINTER_REGNUM)\t\t\\\n+\t abort ();\t\t\t\t\t\\\n        fprintf (FILE, \"%s\", RP);\t\t\t\\\n        switch ((CODE == 'w' ? 2 \t\t\t\\\n \t\t: CODE == 'b' ? 1\t\t\t\\\n@@ -1475,8 +1477,12 @@ do { union { float f; long l;} tem;\t\t\t\\\n \t {\t\t\t\t\t\t\\\n \t case 3:\t\t\t\t\t\\\n \t   if (STACK_TOP_P (X))\t\t\t\t\\\n-\t     { fputs (\"st(0)\", FILE); break; }\t\t\\\n-\t case 4: case 8:\t\t\t\t\\\n+\t     {\t\t\t\t\t\t\\\n+\t       fputs (\"st(0)\", FILE);\t\t\t\\\n+\t       break;\t\t\t\t\t\\\n+\t     }\t\t\t\t\t\t\\\n+\t case 4:\t\t\t\t\t\\\n+\t case 8:\t\t\t\t\t\\\n \t   if (! FP_REG_P (X)) fputs (\"e\", FILE);\t\\\n \t case 2:\t\t\t\t\t\\\n \t   fputs (hi_reg_name[REGNO (X)], FILE);\t\\\n@@ -1496,6 +1502,33 @@ do { union { float f; long l;} tem;\t\t\t\\\n #define PRINT_OPERAND_ADDRESS(FILE, ADDR)  \\\n   print_operand_address (FILE, ADDR)\n \n+/* Print the name of a register for based on its machine mode and number.\n+   This macro is used to print debugging output.\n+   This macro is different from PRINT_REG in that it may be used in\n+   programs that are not linked with aux-output.o.  */\n+\n+#define DEBUG_PRINT_REG(X, CODE, FILE) \\\n+  do { static char *hi_name[] = HI_REGISTER_NAMES;\t\\\n+       static char *qi_name[] = QI_REGISTER_NAMES;\t\\\n+       fprintf (FILE, \"%s\", RP);\t\t\t\\\n+       if (REGNO (X) == ARG_POINTER_REGNUM)\t\t\\\n+\t { fputs (\"argp\", FILE); break; }\t\t\\\n+       if (STACK_TOP_P (X))\t\t\t\t\\\n+\t { fputs (\"st(0)\", FILE); break; }\t\t\\\n+       switch (GET_MODE_SIZE (GET_MODE (X)))\t\t\\\n+\t {\t\t\t\t\t\t\\\n+\t case 8:\t\t\t\t\t\\\n+\t case 4:\t\t\t\t\t\\\n+\t   if (! FP_REG_P (X)) fputs (\"e\", FILE);\t\\\n+\t case 2:\t\t\t\t\t\\\n+\t   fputs (hi_name[REGNO (X)], FILE);\t\t\\\n+\t   break;\t\t\t\t\t\\\n+\t case 1:\t\t\t\t\t\\\n+\t   fputs (qi_name[REGNO (X)], FILE);\t\t\\\n+\t   break;\t\t\t\t\t\\\n+\t }\t\t\t\t\t\t\\\n+     } while (0)\n+\n /* Output the prefix for an immediate operand, or for an offset operand.  */\n #define PRINT_IMMED_PREFIX(FILE)  fputs (IP, (FILE))\n #define PRINT_OFFSET_PREFIX(FILE)  fputs (IP, (FILE))"}]}