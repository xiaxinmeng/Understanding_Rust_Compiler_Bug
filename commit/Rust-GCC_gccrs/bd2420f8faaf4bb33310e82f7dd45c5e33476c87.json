{"sha": "bd2420f8faaf4bb33310e82f7dd45c5e33476c87", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmQyNDIwZjhmYWFmNGJiMzMzMTBlODJmN2RkNDVjNWUzMzQ3NmM4Nw==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-04-17T22:41:04Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-04-17T22:41:04Z"}, "message": "libstdc++: Add comparison operators to sequence containers\n\nSome more C++20 changes from P1614R2, \"The Mothership has Landed\".\n\nThis implements <=> for sequence containers (and the __normal_iterator\nand _Pointer_adapter class templates).\n\n\t* include/bits/forward_list.h (forward_list): Define operator<=> and\n\tremove redundant comparison operators for C++20.\n\t* include/bits/stl_bvector.h (vector<bool, Alloc>): Likewise.\n\t* include/bits/stl_deque.h (deque): Likewise.\n\t* include/bits/stl_iterator.h (__normal_iterator): Likewise.\n\t* include/bits/stl_list.h (list): Likewise.\n\t* include/bits/stl_vector.h (vector): Likewise.\n\t* include/debug/deque (__gnu_debug::deque): Likewise.\n\t* include/debug/forward_list (__gnu_debug::forward_list): Likewise.\n\t* include/debug/list (__gnu_debug::list): Likewise.\n\t* include/debug/safe_iterator.h (__gnu_debug::_Safe_iterator):\n\tLikewise.\n\t* include/debug/vector (__gnu_debug::vector): Likewise.\n\t* include/ext/pointer.h (__gnu_cxx::_Pointer_adapter): Define\n\toperator<=> for C++20.\n\t* testsuite/23_containers/deque/operators/cmp_c++20.cc: New test.\n\t* testsuite/23_containers/forward_list/cmp_c++20.cc: New test.\n\t* testsuite/23_containers/list/cmp_c++20.cc: New test.\n\t* testsuite/23_containers/vector/bool/cmp_c++20.cc: New test.\n\t* testsuite/23_containers/vector/cmp_c++20.cc: New test.", "tree": {"sha": "195aaff3ff206340a940f18b91d19c5ae9e2c507", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/195aaff3ff206340a940f18b91d19c5ae9e2c507"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bd2420f8faaf4bb33310e82f7dd45c5e33476c87", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd2420f8faaf4bb33310e82f7dd45c5e33476c87", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd2420f8faaf4bb33310e82f7dd45c5e33476c87", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd2420f8faaf4bb33310e82f7dd45c5e33476c87/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3737ccc424c56a2cecff202dd79f88d28850eeb2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3737ccc424c56a2cecff202dd79f88d28850eeb2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3737ccc424c56a2cecff202dd79f88d28850eeb2"}], "stats": {"total": 936, "additions": 908, "deletions": 28}, "files": [{"sha": "de9323bebe07f1aa4e220525878ffa9bf25e07f9", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2420f8faaf4bb33310e82f7dd45c5e33476c87/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2420f8faaf4bb33310e82f7dd45c5e33476c87/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=bd2420f8faaf4bb33310e82f7dd45c5e33476c87", "patch": "@@ -1,5 +1,26 @@\n 2020-04-17  Jonathan Wakely  <jwakely@redhat.com>\n \n+\t* include/bits/forward_list.h (forward_list): Define operator<=> and\n+\tremove redundant comparison operators for C++20.\n+\t* include/bits/stl_bvector.h (vector<bool, Alloc>): Likewise.\n+\t* include/bits/stl_deque.h (deque): Likewise.\n+\t* include/bits/stl_iterator.h (__normal_iterator): Likewise.\n+\t* include/bits/stl_list.h (list): Likewise.\n+\t* include/bits/stl_vector.h (vector): Likewise.\n+\t* include/debug/deque (__gnu_debug::deque): Likewise.\n+\t* include/debug/forward_list (__gnu_debug::forward_list): Likewise.\n+\t* include/debug/list (__gnu_debug::list): Likewise.\n+\t* include/debug/safe_iterator.h (__gnu_debug::_Safe_iterator):\n+\tLikewise.\n+\t* include/debug/vector (__gnu_debug::vector): Likewise.\n+\t* include/ext/pointer.h (__gnu_cxx::_Pointer_adapter): Define\n+\toperator<=> for C++20.\n+\t* testsuite/23_containers/deque/operators/cmp_c++20.cc: New test.\n+\t* testsuite/23_containers/forward_list/cmp_c++20.cc: New test.\n+\t* testsuite/23_containers/list/cmp_c++20.cc: New test.\n+\t* testsuite/23_containers/vector/bool/cmp_c++20.cc: New test.\n+\t* testsuite/23_containers/vector/cmp_c++20.cc: New test.\n+\n \t* include/bits/basic_string.h (basic_string): Define operator<=> and\n \tremove redundant comparison operators for C++20.\n \t* include/bits/char_traits.h (__gnu_cxx::char_traits, char_traits):"}, {"sha": "49b2a9737188102ece281762102313b1df277598", "filename": "libstdc++-v3/include/bits/forward_list.h", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2420f8faaf4bb33310e82f7dd45c5e33476c87/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fforward_list.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2420f8faaf4bb33310e82f7dd45c5e33476c87/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fforward_list.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fforward_list.h?ref=bd2420f8faaf4bb33310e82f7dd45c5e33476c87", "patch": "@@ -180,13 +180,14 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       operator==(const _Self& __x, const _Self& __y) noexcept\n       { return __x._M_node == __y._M_node; }\n \n-\n+#if __cpp_impl_three_way_comparison < 201907L\n       /**\n        *  @brief  Forward list iterator inequality comparison.\n        */\n       friend bool\n       operator!=(const _Self& __x, const _Self& __y) noexcept\n       { return __x._M_node != __y._M_node; }\n+#endif\n \n       _Self\n       _M_next() const noexcept\n@@ -258,12 +259,14 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       operator==(const _Self& __x, const _Self& __y) noexcept\n       { return __x._M_node == __y._M_node; }\n \n+#if __cpp_impl_three_way_comparison < 201907L\n       /**\n        *  @brief  Forward list const_iterator inequality comparison.\n        */\n       friend bool\n       operator!=(const _Self& __x, const _Self& __y) noexcept\n       { return __x._M_node != __y._M_node; }\n+#endif\n \n       _Self\n       _M_next() const noexcept\n@@ -1426,6 +1429,28 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n     operator==(const forward_list<_Tp, _Alloc>& __lx,\n \t       const forward_list<_Tp, _Alloc>& __ly);\n \n+#if __cpp_lib_three_way_comparison\n+  /**\n+   *  @brief  Forward list ordering relation.\n+   *  @param  __x  A `forward_list`.\n+   *  @param  __y  A `forward_list` of the same type as `__x`.\n+   *  @return  A value indicating whether `__x` is less than, equal to,\n+   *           greater than, or incomparable with `__y`.\n+   *\n+   *  See `std::lexicographical_compare_three_way()` for how the determination\n+   *  is made. This operator is used to synthesize relational operators like\n+   *  `<` and `>=` etc.\n+  */\n+  template<typename _Tp, typename _Alloc>\n+    inline __detail::__synth3way_t<_Tp>\n+    operator<=>(const forward_list<_Tp, _Alloc>& __x,\n+\t\tconst forward_list<_Tp, _Alloc>& __y)\n+    {\n+      return std::lexicographical_compare_three_way(__x.begin(), __x.end(),\n+\t\t\t\t\t\t    __y.begin(), __y.end(),\n+\t\t\t\t\t\t    __detail::__synth3way);\n+    }\n+#else\n   /**\n    *  @brief  Forward list ordering relation.\n    *  @param  __lx  A %forward_list.\n@@ -1472,6 +1497,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n     operator<=(const forward_list<_Tp, _Alloc>& __lx,\n \t       const forward_list<_Tp, _Alloc>& __ly)\n     { return !(__ly < __lx); }\n+#endif // three-way comparison\n \n   /// See std::forward_list::swap().\n   template<typename _Tp, typename _Alloc>"}, {"sha": "f245e52b25da229fc001f87ce5b3b4dab047e974", "filename": "libstdc++-v3/include/bits/stl_bvector.h", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2420f8faaf4bb33310e82f7dd45c5e33476c87/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_bvector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2420f8faaf4bb33310e82f7dd45c5e33476c87/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_bvector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_bvector.h?ref=bd2420f8faaf4bb33310e82f7dd45c5e33476c87", "patch": "@@ -182,10 +182,20 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       _M_offset = static_cast<unsigned int>(__n);\n     }\n \n-    friend bool\n+    friend _GLIBCXX20_CONSTEXPR bool\n     operator==(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y)\n     { return __x._M_p == __y._M_p && __x._M_offset == __y._M_offset; }\n \n+#if __cpp_lib_three_way_comparison\n+    friend constexpr strong_ordering\n+    operator<=>(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y)\n+    noexcept\n+    {\n+      if (const auto __cmp = __x._M_p <=> __y._M_p; __cmp != 0)\n+\treturn __cmp;\n+      return __x._M_offset <=> __y._M_offset;\n+    }\n+#else\n     friend bool\n     operator<(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y)\n     {\n@@ -208,6 +218,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n     friend bool\n     operator>=(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y)\n     { return !(__x < __y); }\n+#endif // three-way comparison\n \n     friend ptrdiff_t\n     operator-(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y)"}, {"sha": "3959dd7899d64a11dedb294e7ed662c1abd084d9", "filename": "libstdc++-v3/include/bits/stl_deque.h", "status": "modified", "additions": 49, "deletions": 8, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2420f8faaf4bb33310e82f7dd45c5e33476c87/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_deque.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2420f8faaf4bb33310e82f7dd45c5e33476c87/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_deque.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_deque.h?ref=bd2420f8faaf4bb33310e82f7dd45c5e33476c87", "patch": "@@ -63,6 +63,9 @@\n #include <initializer_list>\n #include <bits/stl_uninitialized.h> // for __is_bitwise_relocatable\n #endif\n+#if __cplusplus > 201703L\n+# include <compare>\n+#endif\n \n #include <debug/assertions.h>\n \n@@ -266,22 +269,33 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       { return __x._M_cur == __y._M_cur; }\n \n       // Note: we also provide overloads whose operands are of the same type in\n-      // order to avoid ambiguous overload resolution when std::rel_ops operators\n-      // are in scope (for additional details, see libstdc++/3628)\n+      // order to avoid ambiguous overload resolution when std::rel_ops\n+      // operators are in scope (for additional details, see libstdc++/3628)\n       template<typename _RefR, typename _PtrR>\n \tfriend bool\n \toperator==(const _Self& __x,\n-\t\t   const _Deque_iterator<_Tp, _RefR, _PtrR>& __y) _GLIBCXX_NOEXCEPT\n+\t\t   const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)\n+\t_GLIBCXX_NOEXCEPT\n \t{ return __x._M_cur == __y._M_cur; }\n \n+#if __cpp_lib_three_way_comparison\n+      friend strong_ordering\n+      operator<=>(const _Self& __x, const _Self& __y) noexcept\n+      {\n+\tif (const auto __cmp = __x._M_node <=> __y._M_node; __cmp != 0)\n+\t  return __cmp;\n+\treturn __x._M_cur <=> __y._M_cur;\n+      }\n+#else\n       friend bool\n       operator!=(const _Self& __x, const _Self& __y) _GLIBCXX_NOEXCEPT\n       { return !(__x == __y); }\n \n       template<typename _RefR, typename _PtrR>\n \tfriend bool\n \toperator!=(const _Self& __x,\n-\t\t   const _Deque_iterator<_Tp, _RefR, _PtrR>& __y) _GLIBCXX_NOEXCEPT\n+\t\t   const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)\n+\t_GLIBCXX_NOEXCEPT\n \t{ return !(__x == __y); }\n \n       friend bool\n@@ -294,7 +308,8 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       template<typename _RefR, typename _PtrR>\n \tfriend bool\n \toperator<(const _Self& __x,\n-\t\t  const _Deque_iterator<_Tp, _RefR, _PtrR>& __y) _GLIBCXX_NOEXCEPT\n+\t\t  const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)\n+\t_GLIBCXX_NOEXCEPT\n \t{\n \t  return (__x._M_node == __y._M_node)\n \t    ? (__x._M_cur < __y._M_cur) : (__x._M_node < __y._M_node);\n@@ -307,7 +322,8 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       template<typename _RefR, typename _PtrR>\n \tfriend bool\n \toperator>(const _Self& __x,\n-\t\t  const _Deque_iterator<_Tp, _RefR, _PtrR>& __y) _GLIBCXX_NOEXCEPT\n+\t\t  const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)\n+\t_GLIBCXX_NOEXCEPT\n \t{ return __y < __x; }\n \n       friend bool\n@@ -317,7 +333,8 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       template<typename _RefR, typename _PtrR>\n \tfriend bool\n \toperator<=(const _Self& __x,\n-\t\t   const _Deque_iterator<_Tp, _RefR, _PtrR>& __y) _GLIBCXX_NOEXCEPT\n+\t\t   const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)\n+\t_GLIBCXX_NOEXCEPT\n \t{ return !(__y < __x); }\n \n       friend bool\n@@ -327,8 +344,10 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       template<typename _RefR, typename _PtrR>\n \tfriend bool\n \toperator>=(const _Self& __x,\n-\t\t   const _Deque_iterator<_Tp, _RefR, _PtrR>& __y) _GLIBCXX_NOEXCEPT\n+\t\t   const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)\n+\t_GLIBCXX_NOEXCEPT\n \t{ return !(__x < __y); }\n+#endif // three-way comparison\n \n       friend difference_type\n       operator-(const _Self& __x, const _Self& __y) _GLIBCXX_NOEXCEPT\n@@ -2223,6 +2242,27 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n     { return __x.size() == __y.size()\n \t     && std::equal(__x.begin(), __x.end(), __y.begin()); }\n \n+#if __cpp_lib_three_way_comparison\n+  /**\n+   *  @brief  Deque ordering relation.\n+   *  @param  __x  A `deque`.\n+   *  @param  __y  A `deque` of the same type as `__x`.\n+   *  @return  A value indicating whether `__x` is less than, equal to,\n+   *           greater than, or incomparable with `__y`.\n+   *\n+   *  See `std::lexicographical_compare_three_way()` for how the determination\n+   *  is made. This operator is used to synthesize relational operators like\n+   *  `<` and `>=` etc.\n+  */\n+  template<typename _Tp, typename _Alloc>\n+    inline __detail::__synth3way_t<_Tp>\n+    operator<=>(const deque<_Tp, _Alloc>& __x, const deque<_Tp, _Alloc>& __y)\n+    {\n+      return std::lexicographical_compare_three_way(__x.begin(), __x.end(),\n+\t\t\t\t\t\t    __y.begin(), __y.end(),\n+\t\t\t\t\t\t    __detail::__synth3way);\n+    }\n+#else\n   /**\n    *  @brief  Deque ordering relation.\n    *  @param  __x  A %deque.\n@@ -2263,6 +2303,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n     inline bool\n     operator>=(const deque<_Tp, _Alloc>& __x, const deque<_Tp, _Alloc>& __y)\n     { return !(__x < __y); }\n+#endif // three-way comparison\n \n   /// See std::deque::swap().\n   template<typename _Tp, typename _Alloc>"}, {"sha": "5bfdce6af2d59ad51bb2823d7971f37e179047fc", "filename": "libstdc++-v3/include/bits/stl_iterator.h", "status": "modified", "additions": 20, "deletions": 17, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2420f8faaf4bb33310e82f7dd45c5e33476c87/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_iterator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2420f8faaf4bb33310e82f7dd45c5e33476c87/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_iterator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_iterator.h?ref=bd2420f8faaf4bb33310e82f7dd45c5e33476c87", "patch": "@@ -1037,7 +1037,25 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   // provide overloads whose operands are of the same type.  Can someone\n   // remind me what generic programming is about? -- Gaby\n \n-  // Forward iterator requirements\n+#if __cpp_lib_three_way_comparison\n+  template<typename _IteratorL, typename _IteratorR, typename _Container>\n+    requires requires (_IteratorL __lhs, _IteratorR __rhs)\n+    { { __lhs == __rhs } -> std::convertible_to<bool>; }\n+    constexpr bool\n+    operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,\n+\t       const __normal_iterator<_IteratorR, _Container>& __rhs)\n+    noexcept(noexcept(__lhs.base() == __rhs.base()))\n+    { return __lhs.base() == __rhs.base(); }\n+\n+  template<typename _IteratorL, typename _IteratorR, typename _Container>\n+    constexpr auto\n+    operator<=>(const __normal_iterator<_IteratorL, _Container>& __lhs,\n+\t\tconst __normal_iterator<_IteratorR, _Container>& __rhs)\n+    noexcept(noexcept(__lhs.base() <=> __rhs.base()))\n+    -> decltype(__lhs.base() <=> __rhs.base())\n+    { return __lhs.base() <=> __rhs.base(); }\n+#else\n+   // Forward iterator requirements\n   template<typename _IteratorL, typename _IteratorR, typename _Container>\n     _GLIBCXX20_CONSTEXPR\n     inline bool\n@@ -1072,11 +1090,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   // Random access iterator requirements\n   template<typename _IteratorL, typename _IteratorR, typename _Container>\n-#if __cplusplus > 201703L\n-    constexpr auto\n-#else\n     inline bool\n-#endif\n     operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,\n \t      const __normal_iterator<_IteratorR, _Container>& __rhs)\n     _GLIBCXX_NOEXCEPT\n@@ -1091,11 +1105,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     { return __lhs.base() < __rhs.base(); }\n \n   template<typename _IteratorL, typename _IteratorR, typename _Container>\n-#if __cplusplus > 201703L\n-    constexpr auto\n-#else\n     inline bool\n-#endif\n     operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,\n \t      const __normal_iterator<_IteratorR, _Container>& __rhs)\n     _GLIBCXX_NOEXCEPT\n@@ -1110,11 +1120,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     { return __lhs.base() > __rhs.base(); }\n \n   template<typename _IteratorL, typename _IteratorR, typename _Container>\n-#if __cplusplus > 201703L\n-    constexpr auto\n-#else\n     inline bool\n-#endif\n     operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,\n \t       const __normal_iterator<_IteratorR, _Container>& __rhs)\n     _GLIBCXX_NOEXCEPT\n@@ -1129,11 +1135,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     { return __lhs.base() <= __rhs.base(); }\n \n   template<typename _IteratorL, typename _IteratorR, typename _Container>\n-#if __cplusplus > 201703L\n-    constexpr auto\n-#else\n     inline bool\n-#endif\n     operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,\n \t       const __normal_iterator<_IteratorR, _Container>& __rhs)\n     _GLIBCXX_NOEXCEPT\n@@ -1146,6 +1148,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t       const __normal_iterator<_Iterator, _Container>& __rhs)\n     _GLIBCXX_NOEXCEPT\n     { return __lhs.base() >= __rhs.base(); }\n+#endif // three-way comparison\n \n   // _GLIBCXX_RESOLVE_LIB_DEFECTS\n   // According to the resolution of DR179 not only the various comparison"}, {"sha": "e7135e3e7ed8524e3d0667a8ed796486657632ca", "filename": "libstdc++-v3/include/bits/stl_list.h", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2420f8faaf4bb33310e82f7dd45c5e33476c87/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_list.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2420f8faaf4bb33310e82f7dd45c5e33476c87/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_list.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_list.h?ref=bd2420f8faaf4bb33310e82f7dd45c5e33476c87", "patch": "@@ -247,9 +247,11 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       operator==(const _Self& __x, const _Self& __y) _GLIBCXX_NOEXCEPT\n       { return __x._M_node == __y._M_node; }\n \n+#if __cpp_impl_three_way_comparison < 201907L\n       friend bool\n       operator!=(const _Self& __x, const _Self& __y) _GLIBCXX_NOEXCEPT\n       { return __x._M_node != __y._M_node; }\n+#endif\n \n       // The only member points to the %list element.\n       __detail::_List_node_base* _M_node;\n@@ -331,9 +333,11 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       operator==(const _Self& __x, const _Self& __y) _GLIBCXX_NOEXCEPT\n       { return __x._M_node == __y._M_node; }\n \n+#if __cpp_impl_three_way_comparison < 201907L\n       friend bool\n       operator!=(const _Self& __x, const _Self& __y) _GLIBCXX_NOEXCEPT\n       { return __x._M_node != __y._M_node; }\n+#endif\n \n       // The only member points to the %list element.\n       const __detail::_List_node_base* _M_node;\n@@ -2009,6 +2013,27 @@ _GLIBCXX_END_NAMESPACE_CXX11\n       return __i1 == __end1 && __i2 == __end2;\n     }\n \n+#if __cpp_lib_three_way_comparison\n+/**\n+   *  @brief  List ordering relation.\n+   *  @param  __x  A `list`.\n+   *  @param  __y  A `list` of the same type as `__x`.\n+   *  @return  A value indicating whether `__x` is less than, equal to,\n+   *           greater than, or incomparable with `__y`.\n+   *\n+   *  See `std::lexicographical_compare_three_way()` for how the determination\n+   *  is made. This operator is used to synthesize relational operators like\n+   *  `<` and `>=` etc.\n+  */\n+  template<typename _Tp, typename _Alloc>\n+    inline __detail::__synth3way_t<_Tp>\n+    operator<=>(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)\n+    {\n+      return std::lexicographical_compare_three_way(__x.begin(), __x.end(),\n+\t\t\t\t\t\t    __y.begin(), __y.end(),\n+\t\t\t\t\t\t    __detail::__synth3way);\n+    }\n+#else\n   /**\n    *  @brief  List ordering relation.\n    *  @param  __x  A %list.\n@@ -2049,6 +2074,7 @@ _GLIBCXX_END_NAMESPACE_CXX11\n     inline bool\n     operator>=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)\n     { return !(__x < __y); }\n+#endif // three-way comparison\n \n   /// See std::list::swap().\n   template<typename _Tp, typename _Alloc>"}, {"sha": "d3f1b1fae5cd45773ddcbb73a432305c6417a128", "filename": "libstdc++-v3/include/bits/stl_vector.h", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2420f8faaf4bb33310e82f7dd45c5e33476c87/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2420f8faaf4bb33310e82f7dd45c5e33476c87/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h?ref=bd2420f8faaf4bb33310e82f7dd45c5e33476c87", "patch": "@@ -62,6 +62,9 @@\n #if __cplusplus >= 201103L\n #include <initializer_list>\n #endif\n+#if __cplusplus > 201703L\n+# include <compare>\n+#endif\n \n #include <debug/assertions.h>\n \n@@ -1890,6 +1893,27 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n     { return (__x.size() == __y.size()\n \t      && std::equal(__x.begin(), __x.end(), __y.begin())); }\n \n+#if __cpp_lib_three_way_comparison\n+  /**\n+   *  @brief  Vector ordering relation.\n+   *  @param  __x  A `vector`.\n+   *  @param  __y  A `vector` of the same type as `__x`.\n+   *  @return  A value indicating whether `__x` is less than, equal to,\n+   *           greater than, or incomparable with `__y`.\n+   *\n+   *  See `std::lexicographical_compare_three_way()` for how the determination\n+   *  is made. This operator is used to synthesize relational operators like\n+   *  `<` and `>=` etc.\n+  */\n+  template<typename _Tp, typename _Alloc>\n+    inline __detail::__synth3way_t<_Tp>\n+    operator<=>(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)\n+    {\n+      return std::lexicographical_compare_three_way(__x.begin(), __x.end(),\n+\t\t\t\t\t\t    __y.begin(), __y.end(),\n+\t\t\t\t\t\t    __detail::__synth3way);\n+    }\n+#else\n   /**\n    *  @brief  Vector ordering relation.\n    *  @param  __x  A %vector.\n@@ -1930,6 +1954,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n     inline bool\n     operator>=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)\n     { return !(__x < __y); }\n+#endif // three-way comparison\n \n   /// See std::vector::swap().\n   template<typename _Tp, typename _Alloc>"}, {"sha": "4d525bfc0aa7ae68ba257222ec3b418a564222de", "filename": "libstdc++-v3/include/debug/deque", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2420f8faaf4bb33310e82f7dd45c5e33476c87/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fdeque", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2420f8faaf4bb33310e82f7dd45c5e33476c87/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fdeque", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fdeque?ref=bd2420f8faaf4bb33310e82f7dd45c5e33476c87", "patch": "@@ -648,6 +648,12 @@ namespace __debug\n \t       const deque<_Tp, _Alloc>& __rhs)\n     { return __lhs._M_base() == __rhs._M_base(); }\n \n+#if __cpp_lib_three_way_comparison\n+  template<typename _Tp, typename _Alloc>\n+    constexpr __detail::__synth3way_t<_Tp>\n+    operator<=>(const deque<_Tp, _Alloc>& __x, const deque<_Tp, _Alloc>& __y)\n+    { return __x._M_base() <=> __y._M_base(); }\n+#else\n   template<typename _Tp, typename _Alloc>\n     inline bool\n     operator!=(const deque<_Tp, _Alloc>& __lhs,\n@@ -677,6 +683,7 @@ namespace __debug\n     operator>(const deque<_Tp, _Alloc>& __lhs,\n \t      const deque<_Tp, _Alloc>& __rhs)\n     { return __lhs._M_base() > __rhs._M_base(); }\n+#endif // three-way comparison\n \n   template<typename _Tp, typename _Alloc>\n     inline void"}, {"sha": "2fd03e704996c04a67d0f89f2db1518f99918700", "filename": "libstdc++-v3/include/debug/forward_list", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2420f8faaf4bb33310e82f7dd45c5e33476c87/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fforward_list", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2420f8faaf4bb33310e82f7dd45c5e33476c87/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fforward_list", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fforward_list?ref=bd2420f8faaf4bb33310e82f7dd45c5e33476c87", "patch": "@@ -838,6 +838,13 @@ namespace __debug\n \t       const forward_list<_Tp, _Alloc>& __ly)\n     { return __lx._M_base() == __ly._M_base(); }\n \n+#if __cpp_lib_three_way_comparison\n+  template<typename _Tp, typename _Alloc>\n+    constexpr __detail::__synth3way_t<_Tp>\n+    operator<=>(const forward_list<_Tp, _Alloc>& __x,\n+\t\tconst forward_list<_Tp, _Alloc>& __y)\n+    { return __x._M_base() <=> __y._M_base(); }\n+#else\n   template<typename _Tp, typename _Alloc>\n     inline bool\n     operator<(const forward_list<_Tp, _Alloc>& __lx,\n@@ -870,6 +877,7 @@ namespace __debug\n     operator<=(const forward_list<_Tp, _Alloc>& __lx,\n \t       const forward_list<_Tp, _Alloc>& __ly)\n     { return !(__ly < __lx); }\n+#endif // three-way comparison\n \n   /// See std::forward_list::swap().\n   template<typename _Tp, typename _Alloc>"}, {"sha": "6dd85741f8133fb305b46cc475a7a7d254707da5", "filename": "libstdc++-v3/include/debug/list", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2420f8faaf4bb33310e82f7dd45c5e33476c87/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Flist", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2420f8faaf4bb33310e82f7dd45c5e33476c87/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Flist", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Flist?ref=bd2420f8faaf4bb33310e82f7dd45c5e33476c87", "patch": "@@ -864,6 +864,12 @@ namespace __debug\n \t       const list<_Tp, _Alloc>& __rhs)\n     { return __lhs._M_base() == __rhs._M_base(); }\n \n+#if __cpp_lib_three_way_comparison\n+  template<typename _Tp, typename _Alloc>\n+    constexpr __detail::__synth3way_t<_Tp>\n+    operator<=>(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)\n+    { return __x._M_base() <=> __y._M_base(); }\n+#else\n   template<typename _Tp, typename _Alloc>\n     inline bool\n     operator!=(const list<_Tp, _Alloc>& __lhs,\n@@ -893,6 +899,7 @@ namespace __debug\n     operator>(const list<_Tp, _Alloc>& __lhs,\n \t      const list<_Tp, _Alloc>& __rhs)\n     { return __lhs._M_base() > __rhs._M_base(); }\n+#endif // three-way comparison\n \n   template<typename _Tp, typename _Alloc>\n     inline void"}, {"sha": "687b844fd755ead5dd6013fa4b7363928cd43e1e", "filename": "libstdc++-v3/include/debug/safe_iterator.h", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2420f8faaf4bb33310e82f7dd45c5e33476c87/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_iterator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2420f8faaf4bb33310e82f7dd45c5e33476c87/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_iterator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_iterator.h?ref=bd2420f8faaf4bb33310e82f7dd45c5e33476c87", "patch": "@@ -35,6 +35,9 @@\n #include <debug/safe_base.h>\n #include <bits/stl_pair.h>\n #include <ext/type_traits.h>\n+#if __cplusplus > 201703L\n+# include <compare>\n+#endif\n \n #define _GLIBCXX_DEBUG_VERIFY_OPERANDS(_Lhs, _Rhs, _BadMsgId, _DiffMsgId) \\\n   _GLIBCXX_DEBUG_VERIFY(!_Lhs._M_singular() && !_Rhs._M_singular(),\t\\\n@@ -469,6 +472,7 @@ namespace __gnu_debug\n \t  return __lhs.base() == __rhs.base();\n \t}\n \n+#if ! __cpp_lib_three_way_comparison\n       friend bool\n       operator!=(const _Self& __lhs, const _Self& __rhs) _GLIBCXX_NOEXCEPT\n       {\n@@ -485,6 +489,7 @@ namespace __gnu_debug\n \t  _GLIBCXX_DEBUG_VERIFY_EQ_OPERANDS(__lhs, __rhs);\n \t  return __lhs.base() != __rhs.base();\n \t}\n+#endif // three-way comparison\n     };\n \n   template<typename _Iterator, typename _Sequence>\n@@ -805,6 +810,21 @@ namespace __gnu_debug\n \treturn *this;\n       }\n \n+#if __cpp_lib_three_way_comparison\n+      friend auto\n+      operator<=>(const _Self& __lhs, const _Self& __rhs) noexcept\n+      {\n+\t_GLIBCXX_DEBUG_VERIFY_REL_OPERANDS(__lhs, __rhs);\n+\treturn __lhs.base() <=> __rhs.base();\n+      }\n+\n+      friend auto\n+      operator<=>(const _Self& __lhs, const _OtherSelf& __rhs) noexcept\n+      {\n+\t_GLIBCXX_DEBUG_VERIFY_REL_OPERANDS(__lhs, __rhs);\n+\treturn __lhs.base() <=> __rhs.base();\n+      }\n+#else\n       friend bool\n       operator<(const _Self& __lhs, const _Self& __rhs) _GLIBCXX_NOEXCEPT\n       {\n@@ -860,6 +880,7 @@ namespace __gnu_debug\n \t_GLIBCXX_DEBUG_VERIFY_REL_OPERANDS(__lhs, __rhs);\n \treturn __lhs.base() >= __rhs.base();\n       }\n+#endif // three-way comparison\n \n       // _GLIBCXX_RESOLVE_LIB_DEFECTS\n       // According to the resolution of DR179 not only the various comparison"}, {"sha": "4c08ab61ce809844a676885e61346905ef8d4f53", "filename": "libstdc++-v3/include/debug/vector", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2420f8faaf4bb33310e82f7dd45c5e33476c87/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fvector", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2420f8faaf4bb33310e82f7dd45c5e33476c87/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fvector", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fvector?ref=bd2420f8faaf4bb33310e82f7dd45c5e33476c87", "patch": "@@ -731,6 +731,12 @@ namespace __debug\n \t       const vector<_Tp, _Alloc>& __rhs)\n     { return __lhs._M_base() == __rhs._M_base(); }\n \n+#if __cpp_lib_three_way_comparison\n+  template<typename _Tp, typename _Alloc>\n+    constexpr __detail::__synth3way_t<_Tp>\n+    operator<=>(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)\n+    { return __x._M_base() <=> __y._M_base(); }\n+#else\n   template<typename _Tp, typename _Alloc>\n     inline bool\n     operator!=(const vector<_Tp, _Alloc>& __lhs,\n@@ -760,6 +766,7 @@ namespace __debug\n     operator>(const vector<_Tp, _Alloc>& __lhs,\n \t      const vector<_Tp, _Alloc>& __rhs)\n     { return __lhs._M_base() > __rhs._M_base(); }\n+#endif // three-way comparison\n \n   template<typename _Tp, typename _Alloc>\n     inline void"}, {"sha": "a0ade4a677e3080def1709d09eb405793a62f991", "filename": "libstdc++-v3/include/ext/pointer.h", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2420f8faaf4bb33310e82f7dd45c5e33476c87/libstdc%2B%2B-v3%2Finclude%2Fext%2Fpointer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2420f8faaf4bb33310e82f7dd45c5e33476c87/libstdc%2B%2B-v3%2Finclude%2Fext%2Fpointer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fpointer.h?ref=bd2420f8faaf4bb33310e82f7dd45c5e33476c87", "patch": "@@ -479,7 +479,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n         _Storage_policy::set(_Storage_policy::get() - 1);\n         return __tmp;\n       }\n-  \n+\n+#if __cpp_lib_three_way_comparison\n+      friend std::strong_ordering\n+      operator<=>(const _Pointer_adapter& __lhs, const _Pointer_adapter& __rhs)\n+      noexcept\n+      { return __lhs.get() <=> __rhs.get(); }\n+#endif\n     }; // class _Pointer_adapter\n \n "}, {"sha": "77668fcd1f631d9f7bfe6b216c4ee969110f8dcb", "filename": "libstdc++-v3/testsuite/23_containers/deque/operators/cmp_c++20.cc", "status": "added", "additions": 161, "deletions": 0, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2420f8faaf4bb33310e82f7dd45c5e33476c87/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Foperators%2Fcmp_c%2B%2B20.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2420f8faaf4bb33310e82f7dd45c5e33476c87/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Foperators%2Fcmp_c%2B%2B20.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Foperators%2Fcmp_c%2B%2B20.cc?ref=bd2420f8faaf4bb33310e82f7dd45c5e33476c87", "patch": "@@ -0,0 +1,161 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <deque>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  std::deque<int> c1{ 1, 2, 3 }, c2{ 1, 2, 3, 4 }, c3{ 1, 2, 4 };\n+  VERIFY( c1 == c1 );\n+  VERIFY( std::is_eq(c1 <=> c1) );\n+  VERIFY( c1 < c2 );\n+  VERIFY( std::is_lt(c1 <=> c2) );\n+  VERIFY( c1 < c3 );\n+  VERIFY( std::is_lt(c1 <=> c3) );\n+  VERIFY( c2 < c3 );\n+  VERIFY( std::is_lt(c2 <=> c3) );\n+\n+  static_assert( std::totally_ordered<std::deque<int>> );\n+\n+  static_assert( std::three_way_comparable<std::deque<int>,\n+\t\t\t\t\t   std::strong_ordering> );\n+  static_assert( ! std::three_way_comparable<std::deque<float>,\n+\t\t\t\t\t     std::strong_ordering> );\n+  static_assert( ! std::three_way_comparable<std::deque<float>,\n+\t\t\t\t\t     std::weak_ordering> );\n+  static_assert( std::three_way_comparable<std::deque<float>,\n+\t\t\t\t\t   std::partial_ordering> );\n+\n+  struct E\n+  {\n+    bool operator==(E) { return true; }\n+  };\n+  static_assert( ! std::totally_ordered<std::deque<E>> );\n+  static_assert( ! std::three_way_comparable<E> );\n+  static_assert( ! std::three_way_comparable<std::deque<E>> );\n+}\n+\n+void\n+test02()\n+{\n+  struct W\n+  {\n+    int value = 0;\n+\n+    bool operator==(W rhs) const noexcept\n+    { return (value | 1) == (rhs.value | 1); }\n+\n+    std::weak_ordering\n+    operator<=>(W rhs) const noexcept\n+    { return (value | 1) <=> (rhs.value | 1); }\n+  };\n+\n+  static_assert( std::totally_ordered<std::deque<W>> );\n+\n+  std::deque<W> c1{ {1}, {2}, {3} }, c2{ {0}, {3}, {3} };\n+  static_assert( std::same_as<decltype(c1 <=> c1), std::weak_ordering> );\n+  VERIFY( c1 == c2 );\n+  VERIFY( std::is_eq(c1 <=> c2) );\n+}\n+\n+void\n+test03()\n+{\n+  struct P\n+  {\n+    int value = 0;\n+\n+    bool operator==(P rhs) const noexcept\n+    {\n+      if (value < 0 || rhs.value < 0)\n+\treturn false;\n+      return value == rhs.value;\n+    }\n+\n+    std::partial_ordering\n+    operator<=>(P rhs) const noexcept\n+    {\n+      if (value < 0 || rhs.value < 0)\n+\treturn std::partial_ordering::unordered;\n+      return value <=> rhs.value;\n+    }\n+  };\n+\n+  static_assert( std::totally_ordered<std::deque<P>> );\n+\n+  std::deque<P> c{ {1}, {2}, {-3} };\n+  static_assert( std::three_way_comparable<P> );\n+  static_assert( std::same_as<decltype(c <=> c), std::partial_ordering> );\n+  VERIFY( (c <=> c) == std::partial_ordering::unordered );\n+}\n+\n+void\n+test04()\n+{\n+  struct L\n+  {\n+    int value = 0;\n+\n+    bool operator<(L rhs) const noexcept { return value < rhs.value; }\n+  };\n+\n+  static_assert( std::totally_ordered<std::deque<L>> );\n+\n+  std::deque<L> c{ {1}, {2}, {3} }, d{ {1}, {2}, {3}, {4} };\n+  static_assert( std::same_as<decltype(c <=> c), std::weak_ordering> );\n+  VERIFY( std::is_lt(c <=> d) );\n+}\n+\n+void\n+test05()\n+{\n+  // deque iterators are random access, so should support <=>\n+\n+  std::deque<int> c{ 1, 2, 3 };\n+  VERIFY( c.begin() == c.cbegin() );\n+  VERIFY( std::is_eq(c.begin() <=> c.cbegin()) );\n+\n+  VERIFY( c.begin() < c.end() );\n+  VERIFY( std::is_lt(c.begin() <=> c.end()) );\n+\n+  VERIFY( c.begin() < c.cend() );\n+  VERIFY( std::is_lt(c.begin() <=> c.cend()) );\n+\n+  VERIFY( c.crbegin() == c.rbegin() );\n+  VERIFY( std::is_eq(c.crbegin() <=> c.rbegin()) );\n+\n+  VERIFY( c.rend() > c.rbegin() );\n+  VERIFY( std::is_gt(c.rend() <=> c.rbegin()) );\n+\n+  static_assert( std::same_as<decltype(c.begin() <=> c.begin()),\n+\t\t\t      std::strong_ordering> );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  test04();\n+  test05();\n+}"}, {"sha": "5a26d497ea6b37ea90fc6daa92beb319029dd41e", "filename": "libstdc++-v3/testsuite/23_containers/forward_list/cmp_c++20.cc", "status": "added", "additions": 138, "deletions": 0, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2420f8faaf4bb33310e82f7dd45c5e33476c87/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fcmp_c%2B%2B20.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2420f8faaf4bb33310e82f7dd45c5e33476c87/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fcmp_c%2B%2B20.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fcmp_c%2B%2B20.cc?ref=bd2420f8faaf4bb33310e82f7dd45c5e33476c87", "patch": "@@ -0,0 +1,138 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <forward_list>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  std::forward_list<int> c1{ 1, 2, 3 }, c2{ 1, 2, 3, 4 }, c3{ 1, 2, 4 };\n+  VERIFY( c1 == c1 );\n+  VERIFY( std::is_eq(c1 <=> c1) );\n+  VERIFY( c1 < c2 );\n+  VERIFY( std::is_lt(c1 <=> c2) );\n+  VERIFY( c1 < c3 );\n+  VERIFY( std::is_lt(c1 <=> c3) );\n+  VERIFY( c2 < c3 );\n+  VERIFY( std::is_lt(c2 <=> c3) );\n+\n+  static_assert( std::totally_ordered<std::forward_list<int>> );\n+\n+  static_assert( std::three_way_comparable<std::forward_list<int>,\n+\t\t\t\t\t   std::strong_ordering> );\n+  static_assert( ! std::three_way_comparable<std::forward_list<float>,\n+\t\t\t\t\t     std::strong_ordering> );\n+  static_assert( ! std::three_way_comparable<std::forward_list<float>,\n+\t\t\t\t\t     std::weak_ordering> );\n+  static_assert( std::three_way_comparable<std::forward_list<float>,\n+\t\t\t\t\t   std::partial_ordering> );\n+\n+  struct E\n+  {\n+    bool operator==(E) { return true; }\n+  };\n+  static_assert( ! std::totally_ordered<std::forward_list<E>> );\n+  static_assert( ! std::three_way_comparable<E> );\n+  static_assert( ! std::three_way_comparable<std::forward_list<E>> );\n+}\n+\n+void\n+test02()\n+{\n+  struct W\n+  {\n+    int value = 0;\n+\n+    bool operator==(W rhs) const noexcept\n+    { return (value | 1) == (rhs.value | 1); }\n+\n+    std::weak_ordering\n+    operator<=>(W rhs) const noexcept\n+    { return (value | 1) <=> (rhs.value | 1); }\n+  };\n+\n+  static_assert( std::totally_ordered<std::forward_list<W>> );\n+\n+  std::forward_list<W> c1{ {1}, {2}, {3} }, c2{ {0}, {3}, {3} };\n+  static_assert( std::same_as<decltype(c1 <=> c1), std::weak_ordering> );\n+  VERIFY( c1 == c2 );\n+  VERIFY( std::is_eq(c1 <=> c2) );\n+}\n+\n+void\n+test03()\n+{\n+  struct P\n+  {\n+    int value = 0;\n+\n+    bool operator==(P rhs) const noexcept\n+    {\n+      if (value < 0 || rhs.value < 0)\n+\treturn false;\n+      return value == rhs.value;\n+    }\n+\n+    std::partial_ordering\n+    operator<=>(P rhs) const noexcept\n+    {\n+      if (value < 0 || rhs.value < 0)\n+\treturn std::partial_ordering::unordered;\n+      return value <=> rhs.value;\n+    }\n+  };\n+\n+  static_assert( std::totally_ordered<std::forward_list<P>> );\n+\n+  std::forward_list<P> c{ {1}, {2}, {-3} };\n+  static_assert( std::three_way_comparable<P> );\n+  static_assert( std::same_as<decltype(c <=> c), std::partial_ordering> );\n+  VERIFY( (c <=> c) == std::partial_ordering::unordered );\n+}\n+\n+void\n+test04()\n+{\n+  struct L\n+  {\n+    int value = 0;\n+\n+    bool operator<(L rhs) const noexcept { return value < rhs.value; }\n+  };\n+\n+  static_assert( std::totally_ordered<std::forward_list<L>> );\n+\n+  std::forward_list<L> c{ {1}, {2}, {3} }, d{ {1}, {2}, {3}, {4} };\n+  static_assert( std::same_as<decltype(c <=> c), std::weak_ordering> );\n+  VERIFY( std::is_lt(c <=> d) );\n+}\n+\n+static_assert( ! std::totally_ordered<std::forward_list<int>::iterator> );\n+static_assert( ! std::three_way_comparable<std::forward_list<int>::iterator> );\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  test04();\n+}"}, {"sha": "a5b9f8f5459a99b51d54eaea6f7ca4e1a0b54b1a", "filename": "libstdc++-v3/testsuite/23_containers/list/cmp_c++20.cc", "status": "added", "additions": 138, "deletions": 0, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2420f8faaf4bb33310e82f7dd45c5e33476c87/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Fcmp_c%2B%2B20.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2420f8faaf4bb33310e82f7dd45c5e33476c87/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Fcmp_c%2B%2B20.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Fcmp_c%2B%2B20.cc?ref=bd2420f8faaf4bb33310e82f7dd45c5e33476c87", "patch": "@@ -0,0 +1,138 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <list>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  std::list<int> c1{ 1, 2, 3 }, c2{ 1, 2, 3, 4 }, c3{ 1, 2, 4 };\n+  VERIFY( c1 == c1 );\n+  VERIFY( std::is_eq(c1 <=> c1) );\n+  VERIFY( c1 < c2 );\n+  VERIFY( std::is_lt(c1 <=> c2) );\n+  VERIFY( c1 < c3 );\n+  VERIFY( std::is_lt(c1 <=> c3) );\n+  VERIFY( c2 < c3 );\n+  VERIFY( std::is_lt(c2 <=> c3) );\n+\n+  static_assert( std::totally_ordered<std::list<int>> );\n+\n+  static_assert( std::three_way_comparable<std::list<int>,\n+\t\t\t\t\t   std::strong_ordering> );\n+  static_assert( ! std::three_way_comparable<std::list<float>,\n+\t\t\t\t\t     std::strong_ordering> );\n+  static_assert( ! std::three_way_comparable<std::list<float>,\n+\t\t\t\t\t     std::weak_ordering> );\n+  static_assert( std::three_way_comparable<std::list<float>,\n+\t\t\t\t\t   std::partial_ordering> );\n+\n+  struct E\n+  {\n+    bool operator==(E) { return true; }\n+  };\n+  static_assert( ! std::totally_ordered<std::list<E>> );\n+  static_assert( ! std::three_way_comparable<E> );\n+  static_assert( ! std::three_way_comparable<std::list<E>> );\n+}\n+\n+void\n+test02()\n+{\n+  struct W\n+  {\n+    int value = 0;\n+\n+    bool operator==(W rhs) const noexcept\n+    { return (value | 1) == (rhs.value | 1); }\n+\n+    std::weak_ordering\n+    operator<=>(W rhs) const noexcept\n+    { return (value | 1) <=> (rhs.value | 1); }\n+  };\n+\n+  static_assert( std::totally_ordered<std::list<W>> );\n+\n+  std::list<W> c1{ {1}, {2}, {3} }, c2{ {0}, {3}, {3} };\n+  static_assert( std::same_as<decltype(c1 <=> c1), std::weak_ordering> );\n+  VERIFY( c1 == c2 );\n+  VERIFY( std::is_eq(c1 <=> c2) );\n+}\n+\n+void\n+test03()\n+{\n+  struct P\n+  {\n+    int value = 0;\n+\n+    bool operator==(P rhs) const noexcept\n+    {\n+      if (value < 0 || rhs.value < 0)\n+\treturn false;\n+      return value == rhs.value;\n+    }\n+\n+    std::partial_ordering\n+    operator<=>(P rhs) const noexcept\n+    {\n+      if (value < 0 || rhs.value < 0)\n+\treturn std::partial_ordering::unordered;\n+      return value <=> rhs.value;\n+    }\n+  };\n+\n+  static_assert( std::totally_ordered<std::list<P>> );\n+\n+  std::list<P> c{ {1}, {2}, {-3} };\n+  static_assert( std::three_way_comparable<P> );\n+  static_assert( std::same_as<decltype(c <=> c), std::partial_ordering> );\n+  VERIFY( (c <=> c) == std::partial_ordering::unordered );\n+}\n+\n+void\n+test04()\n+{\n+  struct L\n+  {\n+    int value = 0;\n+\n+    bool operator<(L rhs) const noexcept { return value < rhs.value; }\n+  };\n+\n+  static_assert( std::totally_ordered<std::list<L>> );\n+\n+  std::list<L> c{ {1}, {2}, {3} }, d{ {1}, {2}, {3}, {4} };\n+  static_assert( std::same_as<decltype(c <=> c), std::weak_ordering> );\n+  VERIFY( std::is_lt(c <=> d) );\n+}\n+\n+static_assert( ! std::totally_ordered<std::list<int>::iterator> );\n+static_assert( ! std::three_way_comparable<std::list<int>::iterator> );\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  test04();\n+}"}, {"sha": "a586ab65cd766f517bda4995989fbaf284ee7654", "filename": "libstdc++-v3/testsuite/23_containers/vector/bool/cmp_c++20.cc", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2420f8faaf4bb33310e82f7dd45c5e33476c87/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fbool%2Fcmp_c%2B%2B20.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2420f8faaf4bb33310e82f7dd45c5e33476c87/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fbool%2Fcmp_c%2B%2B20.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fbool%2Fcmp_c%2B%2B20.cc?ref=bd2420f8faaf4bb33310e82f7dd45c5e33476c87", "patch": "@@ -0,0 +1,73 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <vector>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  std::vector<bool> c1{ 1, 0, 1 }, c2{ 1, 0, 1, 0 }, c3{ 1, 1, 1 };\n+  VERIFY( c1 == c1 );\n+  VERIFY( std::is_eq(c1 <=> c1) );\n+  VERIFY( c1 < c2 );\n+  VERIFY( std::is_lt(c1 <=> c2) );\n+  VERIFY( c1 < c3 );\n+  VERIFY( std::is_lt(c1 <=> c3) );\n+  VERIFY( c2 < c3 );\n+  VERIFY( std::is_lt(c2 <=> c3) );\n+\n+  static_assert( std::totally_ordered<std::vector<bool>> );\n+\n+  static_assert( std::three_way_comparable<std::vector<bool>,\n+\t\t\t\t\t   std::strong_ordering> );\n+}\n+\n+void\n+test05()\n+{\n+  // vector<bool> iterators are random access, so should support <=>\n+\n+  std::vector<bool> c{ 1, 1, 1 };\n+  VERIFY( c.begin() == c.cbegin() );\n+  VERIFY( std::is_eq(c.begin() <=> c.cbegin()) );\n+\n+  VERIFY( c.begin() < c.end() );\n+  VERIFY( std::is_lt(c.begin() <=> c.end()) );\n+\n+  VERIFY( c.begin() < c.cend() );\n+  VERIFY( std::is_lt(c.begin() <=> c.cend()) );\n+\n+  VERIFY( c.crbegin() == c.rbegin() );\n+  VERIFY( std::is_eq(c.crbegin() <=> c.rbegin()) );\n+\n+  VERIFY( c.rend() > c.rbegin() );\n+  VERIFY( std::is_gt(c.rend() <=> c.rbegin()) );\n+\n+  static_assert( std::same_as<decltype(c.begin() <=> c.begin()),\n+\t\t\t      std::strong_ordering> );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test05();\n+}"}, {"sha": "ca6a4f43e22893a426a42e47d89cd8ac41c7c1e0", "filename": "libstdc++-v3/testsuite/23_containers/vector/cmp_c++20.cc", "status": "added", "additions": 161, "deletions": 0, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd2420f8faaf4bb33310e82f7dd45c5e33476c87/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fcmp_c%2B%2B20.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd2420f8faaf4bb33310e82f7dd45c5e33476c87/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fcmp_c%2B%2B20.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fcmp_c%2B%2B20.cc?ref=bd2420f8faaf4bb33310e82f7dd45c5e33476c87", "patch": "@@ -0,0 +1,161 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <vector>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  std::vector<int> c1{ 1, 2, 3 }, c2{ 1, 2, 3, 4 }, c3{ 1, 2, 4 };\n+  VERIFY( c1 == c1 );\n+  VERIFY( std::is_eq(c1 <=> c1) );\n+  VERIFY( c1 < c2 );\n+  VERIFY( std::is_lt(c1 <=> c2) );\n+  VERIFY( c1 < c3 );\n+  VERIFY( std::is_lt(c1 <=> c3) );\n+  VERIFY( c2 < c3 );\n+  VERIFY( std::is_lt(c2 <=> c3) );\n+\n+  static_assert( std::totally_ordered<std::vector<int>> );\n+\n+  static_assert( std::three_way_comparable<std::vector<int>,\n+\t\t\t\t\t   std::strong_ordering> );\n+  static_assert( ! std::three_way_comparable<std::vector<float>,\n+\t\t\t\t\t     std::strong_ordering> );\n+  static_assert( ! std::three_way_comparable<std::vector<float>,\n+\t\t\t\t\t     std::weak_ordering> );\n+  static_assert( std::three_way_comparable<std::vector<float>,\n+\t\t\t\t\t   std::partial_ordering> );\n+\n+  struct E\n+  {\n+    bool operator==(E) { return true; }\n+  };\n+  static_assert( ! std::totally_ordered<std::vector<E>> );\n+  static_assert( ! std::three_way_comparable<E> );\n+  static_assert( ! std::three_way_comparable<std::vector<E>> );\n+}\n+\n+void\n+test02()\n+{\n+  struct W\n+  {\n+    int value = 0;\n+\n+    bool operator==(W rhs) const noexcept\n+    { return (value | 1) == (rhs.value | 1); }\n+\n+    std::weak_ordering\n+    operator<=>(W rhs) const noexcept\n+    { return (value | 1) <=> (rhs.value | 1); }\n+  };\n+\n+  static_assert( std::totally_ordered<std::vector<W>> );\n+\n+  std::vector<W> c1{ {1}, {2}, {3} }, c2{ {0}, {3}, {3} };\n+  static_assert( std::same_as<decltype(c1 <=> c1), std::weak_ordering> );\n+  VERIFY( c1 == c2 );\n+  VERIFY( std::is_eq(c1 <=> c2) );\n+}\n+\n+void\n+test03()\n+{\n+  struct P\n+  {\n+    int value = 0;\n+\n+    bool operator==(P rhs) const noexcept\n+    {\n+      if (value < 0 || rhs.value < 0)\n+\treturn false;\n+      return value == rhs.value;\n+    }\n+\n+    std::partial_ordering\n+    operator<=>(P rhs) const noexcept\n+    {\n+      if (value < 0 || rhs.value < 0)\n+\treturn std::partial_ordering::unordered;\n+      return value <=> rhs.value;\n+    }\n+  };\n+\n+  static_assert( std::totally_ordered<std::vector<P>> );\n+\n+  std::vector<P> c{ {1}, {2}, {-3} };\n+  static_assert( std::three_way_comparable<P> );\n+  static_assert( std::same_as<decltype(c <=> c), std::partial_ordering> );\n+  VERIFY( (c <=> c) == std::partial_ordering::unordered );\n+}\n+\n+void\n+test04()\n+{\n+  struct L\n+  {\n+    int value = 0;\n+\n+    bool operator<(L rhs) const noexcept { return value < rhs.value; }\n+  };\n+\n+  static_assert( std::totally_ordered<std::vector<L>> );\n+\n+  std::vector<L> c{ {1}, {2}, {3} }, d{ {1}, {2}, {3}, {4} };\n+  static_assert( std::same_as<decltype(c <=> c), std::weak_ordering> );\n+  VERIFY( std::is_lt(c <=> d) );\n+}\n+\n+void\n+test05()\n+{\n+  // vector iterators are random access, so should support <=>\n+\n+  std::vector<int> c{ 1, 2, 3 };\n+  VERIFY( c.begin() == c.cbegin() );\n+  VERIFY( std::is_eq(c.begin() <=> c.cbegin()) );\n+\n+  VERIFY( c.begin() < c.end() );\n+  VERIFY( std::is_lt(c.begin() <=> c.end()) );\n+\n+  VERIFY( c.begin() < c.cend() );\n+  VERIFY( std::is_lt(c.begin() <=> c.cend()) );\n+\n+  VERIFY( c.crbegin() == c.rbegin() );\n+  VERIFY( std::is_eq(c.crbegin() <=> c.rbegin()) );\n+\n+  VERIFY( c.rend() > c.rbegin() );\n+  VERIFY( std::is_gt(c.rend() <=> c.rbegin()) );\n+\n+  static_assert( std::same_as<decltype(c.begin() <=> c.begin()),\n+\t\t\t      std::strong_ordering> );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  test04();\n+  test05();\n+}"}]}