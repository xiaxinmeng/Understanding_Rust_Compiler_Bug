{"sha": "8c2bf92af150355c9bf356fd57a0a4438bdeb2d4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGMyYmY5MmFmMTUwMzU1YzliZjM1NmZkNTdhMGE0NDM4YmRlYjJkNA==", "commit": {"author": {"name": "James Van Artsdalen", "email": "jrv@gnu.org", "date": "1992-08-31T07:06:56Z"}, "committer": {"name": "James Van Artsdalen", "email": "jrv@gnu.org", "date": "1992-08-31T07:06:56Z"}, "message": "(TARGET_FLOAT_RETURNS_IN_80387): New macro.\n\n(TARGET_SWITCHES): Add \"no-80387\", \"no-soft-float\", \"fp-ret-in-387\", and\n\"no-fp-ret-in-387\".\nChange no* switches to no-*.\n(CONDITIONAL_REGISTER_USAGE): Make 387 regs fixed if the 387 is not used\nat all.\n(REG_CLASS_FROM_LETTER): Constraint letters 'f', 't' and 'u' are NO_REGS\nif the 387 is not used.\n(TRAMPOLINE_TEMPLATE): Use GEN_INT to generate const_int rtx.\n\nFrom-SVN: r2001", "tree": {"sha": "d24b420eb4031641c7aa882611437a7a000f5cbd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d24b420eb4031641c7aa882611437a7a000f5cbd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8c2bf92af150355c9bf356fd57a0a4438bdeb2d4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c2bf92af150355c9bf356fd57a0a4438bdeb2d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c2bf92af150355c9bf356fd57a0a4438bdeb2d4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c2bf92af150355c9bf356fd57a0a4438bdeb2d4/comments", "author": null, "committer": null, "parents": [{"sha": "bbda1b9c4a004f8174adfb0500a6d728d4d9579c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bbda1b9c4a004f8174adfb0500a6d728d4d9579c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bbda1b9c4a004f8174adfb0500a6d728d4d9579c"}], "stats": {"total": 78, "additions": 53, "deletions": 25}, "files": [{"sha": "cef246aab6d4c5fa35eca88290ede75a64a6d632", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 53, "deletions": 25, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c2bf92af150355c9bf356fd57a0a4438bdeb2d4/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c2bf92af150355c9bf356fd57a0a4438bdeb2d4/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=8c2bf92af150355c9bf356fd57a0a4438bdeb2d4", "patch": "@@ -80,6 +80,11 @@ extern int target_flags;\n    generated in such cases, in which case this isn't needed.  */\n #define TARGET_IEEE_FP (target_flags & 0100)\n \n+/* Functions that return a floating point value may return that value\n+   in the 387 FPU or in 386 integer registers.  If set, this flag causes\n+   the 387 to be used, which is compatible with most calling conventions. */\n+#define TARGET_FLOAT_RETURNS_IN_80387 (target_flags & 0200)\n+\n /* Macro to define tables used to set the flags.\n    This is a list in braces of pairs in braces,\n    each pair being { \"NAME\", VALUE }\n@@ -88,18 +93,22 @@ extern int target_flags;\n \n #define TARGET_SWITCHES  \\\n   { { \"80387\", 1},\t\t\t\t\\\n+    { \"no-80387\", -1},\t\t\t\t\\\n     { \"soft-float\", -1},\t\t\t\\\n+    { \"no-soft-float\", 1},\t\t\t\\\n     { \"486\", 2},\t\t\t\t\\\n-    { \"no486\", -2},\t\t\t\t\\\n+    { \"no-486\", -2},\t\t\t\t\\\n     { \"386\", -2},\t\t\t\t\\\n     { \"rtd\", 8},\t\t\t\t\\\n-    { \"nortd\", -8},\t\t\t\t\\\n+    { \"no-rtd\", -8},\t\t\t\t\\\n     { \"regparm\", 020},\t\t\t\t\\\n-    { \"noregparm\", -020},\t\t\t\\\n+    { \"no-regparm\", -020},\t\t\t\\\n     { \"svr3-shlib\", 040},\t\t\t\\\n-    { \"nosvr3-shlib\", -040},\t\t\t\\\n+    { \"no-svr3-shlib\", -040},\t\t\t\\\n     { \"ieee-fp\", 0100},\t\t\t\t\\\n-    { \"noieee-fp\", -0100},\t\t\t\\\n+    { \"no-ieee-fp\", -0100},\t\t\t\\\n+    { \"fp-ret-in-387\", 0200},\t\t\t\\\n+    { \"no-fp-ret-in-387\", -0200},\t\t\\\n     SUBTARGET_SWITCHES                          \\\n     { \"\", TARGET_DEFAULT}}\n \n@@ -231,6 +240,15 @@ extern int target_flags;\n \tfixed_regs[PIC_OFFSET_TABLE_REGNUM] = 1;\t\\\n \tcall_used_regs[PIC_OFFSET_TABLE_REGNUM] = 1;\t\\\n       }\t\t\t\t\t\t\t\\\n+    if (! TARGET_80387 && ! TARGET_FLOAT_RETURNS_IN_80387) \\\n+      { \t\t\t\t\t\t\\\n+\tint i; \t\t\t\t\t\t\\\n+\tHARD_REG_SET x;\t\t\t\t\t\\\n+        COPY_HARD_REG_SET (x, reg_class_contents[(int)FLOAT_REGS]); \\\n+        for (i = 0; i < FIRST_PSEUDO_REGISTER; i++ )\t\\\n+         if (TEST_HARD_REG_BIT (x, i)) \t\t\t\\\n+\t  fixed_regs[i] = call_used_regs[i] = 1; \t\\\n+      }\t\t\t\t\t\t\t\\\n   }\n \n /* Return number of consecutive hard regs needed starting at reg REGNO\n@@ -438,16 +456,22 @@ extern enum reg_class regclass_map[FIRST_PSEUDO_REGISTER];\n /* Get reg_class from a letter such as appears in the machine description.  */\n \n #define REG_CLASS_FROM_LETTER(C)\t\\\n-  ((C) == 'r' ? GENERAL_REGS :\t\t\\\n-   (C) == 'q' ? Q_REGS :\t\t\\\n-   (C) == 'f' ? FLOAT_REGS :\t\t\\\n-   (C) == 't' ? FP_TOP_REG :\t\t\\\n-   (C) == 'u' ? FP_SECOND_REG :\t\t\\\n-   (C) == 'a' ? AREG :\t\t\t\\\n-   (C) == 'b' ? BREG :\t\t\t\\\n-   (C) == 'c' ? CREG :\t\t\t\\\n-   (C) == 'd' ? DREG :\t\t\t\\\n-   (C) == 'D' ? DIREG :\t\t\t\\\n+  ((C) == 'r' ? GENERAL_REGS :\t\t\t\t\t\\\n+   (C) == 'q' ? Q_REGS :\t\t\t\t\t\\\n+   (C) == 'f' ? (TARGET_80387 || TARGET_FLOAT_RETURNS_IN_80387\t\\\n+\t\t ? FLOAT_REGS\t\t\t\t\t\\\n+\t\t : NO_REGS) :\t\t\t\t\t\\\n+   (C) == 't' ? (TARGET_80387 || TARGET_FLOAT_RETURNS_IN_80387\t\\\n+\t\t ? FP_TOP_REG\t\t\t\t\t\\\n+\t\t : NO_REGS) :\t\t\t\t\t\\\n+   (C) == 'u' ? (TARGET_80387 || TARGET_FLOAT_RETURNS_IN_80387\t\\\n+\t\t ? FP_SECOND_REG\t\t\t\t\\\n+\t\t : NO_REGS) :\t\t\t\t\t\\\n+   (C) == 'a' ? AREG :\t\t\t\t\t\t\\\n+   (C) == 'b' ? BREG :\t\t\t\t\t\t\\\n+   (C) == 'c' ? CREG :\t\t\t\t\t\t\\\n+   (C) == 'd' ? DREG :\t\t\t\t\t\t\\\n+   (C) == 'D' ? DIREG :\t\t\t\t\t\t\\\n    (C) == 'S' ? SIREG : NO_REGS)\n \n /* The letters I, J, K, L and M in a register constraint string\n@@ -568,6 +592,10 @@ extern enum reg_class regclass_map[FIRST_PSEUDO_REGISTER];\n \t      == void_type_node))) ? (SIZE)\t\t\t\\\n    : (aggregate_value_p (FUNTYPE)) ? GET_MODE_SIZE (Pmode) : 0)\n \n+/* Define how to find the value returned by a function.\n+   VALTYPE is the data type of the value (as a tree).\n+   If the precise function being called is known, FUNC is its FUNCTION_DECL;\n+   otherwise, FUNC is 0.  */\n #define FUNCTION_VALUE(VALTYPE, FUNC)  \\\n    gen_rtx (REG, TYPE_MODE (VALTYPE), \\\n \t    VALUE_REGNO (TYPE_MODE (VALTYPE)))\n@@ -718,16 +746,16 @@ do {\t\t\t\t\t\t\\\n      mov #STATIC,ecx\n      mov #FUNCTION,eax\n      jmp @eax  */\n-#define TRAMPOLINE_TEMPLATE(FILE)\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  ASM_OUTPUT_CHAR (FILE, gen_rtx (CONST_INT, VOIDmode, 0xb9));\t\t\\\n-  ASM_OUTPUT_SHORT (FILE, const0_rtx);\t\t\t\t\t\\\n-  ASM_OUTPUT_SHORT (FILE, const0_rtx);\t\t\t\t\t\\\n-  ASM_OUTPUT_CHAR (FILE, gen_rtx (CONST_INT, VOIDmode, 0xb8));\t\t\\\n-  ASM_OUTPUT_SHORT (FILE, const0_rtx);\t\t\t\t\t\\\n-  ASM_OUTPUT_SHORT (FILE, const0_rtx);\t\t\t\t\t\\\n-  ASM_OUTPUT_CHAR (FILE, gen_rtx (CONST_INT, VOIDmode, 0xff));\t\t\\\n-  ASM_OUTPUT_CHAR (FILE, gen_rtx (CONST_INT, VOIDmode, 0xe0));\t\t\\\n+#define TRAMPOLINE_TEMPLATE(FILE)\t\t\t\\\n+{\t\t\t\t\t\t\t\\\n+  ASM_OUTPUT_CHAR (FILE, GEN_INT (0xb9));\t\t\\\n+  ASM_OUTPUT_SHORT (FILE, const0_rtx);\t\t\t\\\n+  ASM_OUTPUT_SHORT (FILE, const0_rtx);\t\t\t\\\n+  ASM_OUTPUT_CHAR (FILE, GEN_INT (0xb8));\t\t\\\n+  ASM_OUTPUT_SHORT (FILE, const0_rtx);\t\t\t\\\n+  ASM_OUTPUT_SHORT (FILE, const0_rtx);\t\t\t\\\n+  ASM_OUTPUT_CHAR (FILE, GEN_INT (0xff));\t\t\\\n+  ASM_OUTPUT_CHAR (FILE, GEN_INT (0xe0));\t\t\\\n }\n \n /* Length in units of the trampoline for entering a nested function.  */"}]}