{"sha": "ef950eba664843fe4cb27c6d85809e84189b1381", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWY5NTBlYmE2NjQ4NDNmZTRjYjI3YzZkODU4MDllODQxODliMTM4MQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2006-11-11T16:54:57Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2006-11-11T16:54:57Z"}, "message": "extended.texi (__builtin_expect): We no longer require second argument to be constant.\n\n\n\t* extended.texi (__builtin_expect): We no longer require second argument\n\tto be constant.\n\t* gengtype.c (adjust_field_rtx_def): Drop NOTE_INSN_EXPECTED_VALUE.\n\t* builtins.c (expand_builtin_expect): Simplify.\n\t(expand_builtin_expect_jump): Kill.\n\t* final.c (final_scan_insn): Do not skip the removed notes.\n\t* insn-notes.def (LOOP_BEG, LOOP_END, REPEATED_LINE_NUMBER,\n\tEXPECTED_VALUE): Remove.\n\t* dojump.c (do_jump): Do not care about __builtin_expect.\n\t* predict.c (expected_value_to_br_prob): Kill.\n\t* function.c (expand_function_end): Do not expand\n\tNOTE_INSN_REPEATED_LINE_NUMBER.\n\t* print-rtl.c (print_rtx): Do not pretty print the removed notes.\n\t* expect.c (sjlj_emit_function_enter): Emit directly branch probability.\n\t* cfgexpand.c (add_reg_br_prob_note): Export.\n\t* cfgcleanup.c (rest_of_handle_jump2): Do not call\n\texpected_value_to_br_prob.\n\t* cfglayout.c (duplicate_insn_chain): Do not deal with removed notes.\n\t* rtl.h (add_reg_br_prob_note): Declare.\n\nFrom-SVN: r118696", "tree": {"sha": "9d45a239029f3b75636cf09bd64a3c4a7e6031d7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9d45a239029f3b75636cf09bd64a3c4a7e6031d7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ef950eba664843fe4cb27c6d85809e84189b1381", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef950eba664843fe4cb27c6d85809e84189b1381", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef950eba664843fe4cb27c6d85809e84189b1381", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef950eba664843fe4cb27c6d85809e84189b1381/comments", "author": null, "committer": null, "parents": [{"sha": "89fa98d6b981d00d1f753f010e0747c8024a0441", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89fa98d6b981d00d1f753f010e0747c8024a0441", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89fa98d6b981d00d1f753f010e0747c8024a0441"}], "stats": {"total": 305, "additions": 34, "deletions": 271}, "files": [{"sha": "020768fefed66724a7ba468fcf7c42418d09f042", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef950eba664843fe4cb27c6d85809e84189b1381/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef950eba664843fe4cb27c6d85809e84189b1381/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ef950eba664843fe4cb27c6d85809e84189b1381", "patch": "@@ -1,3 +1,25 @@\n+2006-11-11  Jan Hubicka  <jh@suse.cz>\n+\n+\t* extended.texi (__builtin_expect): We no longer require second argument\n+\tto be constant.\n+\t* gengtype.c (adjust_field_rtx_def): Drop NOTE_INSN_EXPECTED_VALUE.\n+\t* builtins.c (expand_builtin_expect): Simplify.\n+\t(expand_builtin_expect_jump): Kill.\n+\t* final.c (final_scan_insn): Do not skip the removed notes.\n+\t* insn-notes.def (LOOP_BEG, LOOP_END, REPEATED_LINE_NUMBER,\n+\tEXPECTED_VALUE): Remove.\n+\t* dojump.c (do_jump): Do not care about __builtin_expect.\n+\t* predict.c (expected_value_to_br_prob): Kill.\n+\t* function.c (expand_function_end): Do not expand\n+\tNOTE_INSN_REPEATED_LINE_NUMBER.\n+\t* print-rtl.c (print_rtx): Do not pretty print the removed notes.\n+\t* expect.c (sjlj_emit_function_enter): Emit directly branch probability.\n+\t* cfgexpand.c (add_reg_br_prob_note): Export.\n+\t* cfgcleanup.c (rest_of_handle_jump2): Do not call\n+\texpected_value_to_br_prob.\n+\t* cfglayout.c (duplicate_insn_chain): Do not deal with removed notes.\n+\t* rtl.h (add_reg_br_prob_note): Declare.\n+\n 2006-11-11  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* tree-pretty-print.c (dump_generic_node): Print sign of Inf."}, {"sha": "5aa9e6fe456de50e6cd34b17dc1aa449bf302b78", "filename": "gcc/builtins.c", "status": "modified", "additions": 5, "deletions": 142, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef950eba664843fe4cb27c6d85809e84189b1381/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef950eba664843fe4cb27c6d85809e84189b1381/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=ef950eba664843fe4cb27c6d85809e84189b1381", "patch": "@@ -4693,9 +4693,9 @@ expand_builtin_fputs (tree arglist, rtx target, bool unlocked)\n   return 0;\n }\n \n-/* Expand a call to __builtin_expect.  We return our argument and emit a\n-   NOTE_INSN_EXPECTED_VALUE note.  This is the expansion of __builtin_expect in\n-   a non-jump context.  */\n+/* Expand a call to __builtin_expect.  We just return our argument \n+   as the builtin_expect semantic should've been already executed by\n+   tree branch prediction pass. */\n \n static rtx\n expand_builtin_expect (tree arglist, rtx target)\n@@ -4709,149 +4709,12 @@ expand_builtin_expect (tree arglist, rtx target)\n   exp = TREE_VALUE (arglist);\n   c = TREE_VALUE (TREE_CHAIN (arglist));\n \n-  if (TREE_CODE (c) != INTEGER_CST)\n-    {\n-      error (\"second argument to %<__builtin_expect%> must be a constant\");\n-      c = integer_zero_node;\n-    }\n-\n   target = expand_expr (exp, target, VOIDmode, EXPAND_NORMAL);\n-\n-  /* Don't bother with expected value notes for integral constants.  */\n-  if (flag_guess_branch_prob && GET_CODE (target) != CONST_INT)\n-    {\n-      /* We do need to force this into a register so that we can be\n-\t moderately sure to be able to correctly interpret the branch\n-\t condition later.  */\n-      target = force_reg (GET_MODE (target), target);\n-\n-      rtx_c = expand_expr (c, NULL_RTX, GET_MODE (target), EXPAND_NORMAL);\n-\n-      note = emit_note (NOTE_INSN_EXPECTED_VALUE);\n-      NOTE_EXPECTED_VALUE (note) = gen_rtx_EQ (VOIDmode, target, rtx_c);\n-    }\n-\n+  /* When guessing was done, the hints should be already stripped away.  */\n+  gcc_assert (!flag_guess_branch_prob);\n   return target;\n }\n \n-/* Like expand_builtin_expect, except do this in a jump context.  This is\n-   called from do_jump if the conditional is a __builtin_expect.  Return either\n-   a list of insns to emit the jump or NULL if we cannot optimize\n-   __builtin_expect.  We need to optimize this at jump time so that machines\n-   like the PowerPC don't turn the test into a SCC operation, and then jump\n-   based on the test being 0/1.  */\n-\n-rtx\n-expand_builtin_expect_jump (tree exp, rtx if_false_label, rtx if_true_label)\n-{\n-  tree arglist = TREE_OPERAND (exp, 1);\n-  tree arg0 = TREE_VALUE (arglist);\n-  tree arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n-  rtx ret = NULL_RTX;\n-\n-  /* Only handle __builtin_expect (test, 0) and\n-     __builtin_expect (test, 1).  */\n-  if (TREE_CODE (TREE_TYPE (arg1)) == INTEGER_TYPE\n-      && (integer_zerop (arg1) || integer_onep (arg1)))\n-    {\n-      rtx insn, drop_through_label, temp;\n-\n-      /* Expand the jump insns.  */\n-      start_sequence ();\n-      do_jump (arg0, if_false_label, if_true_label);\n-      ret = get_insns ();\n-\n-      drop_through_label = get_last_insn ();\n-      if (drop_through_label && NOTE_P (drop_through_label))\n-\tdrop_through_label = prev_nonnote_insn (drop_through_label);\n-      if (drop_through_label && !LABEL_P (drop_through_label))\n-\tdrop_through_label = NULL_RTX;\n-      end_sequence ();\n-\n-      if (! if_true_label)\n-\tif_true_label = drop_through_label;\n-      if (! if_false_label)\n-\tif_false_label = drop_through_label;\n-\n-      /* Go through and add the expect's to each of the conditional jumps.  */\n-      insn = ret;\n-      while (insn != NULL_RTX)\n-\t{\n-\t  rtx next = NEXT_INSN (insn);\n-\n-\t  if (JUMP_P (insn) && any_condjump_p (insn))\n-\t    {\n-\t      rtx ifelse = SET_SRC (pc_set (insn));\n-\t      rtx then_dest = XEXP (ifelse, 1);\n-\t      rtx else_dest = XEXP (ifelse, 2);\n-\t      int taken = -1;\n-\n-\t      /* First check if we recognize any of the labels.  */\n-\t      if (GET_CODE (then_dest) == LABEL_REF\n-\t\t  && XEXP (then_dest, 0) == if_true_label)\n-\t\ttaken = 1;\n-\t      else if (GET_CODE (then_dest) == LABEL_REF\n-\t\t       && XEXP (then_dest, 0) == if_false_label)\n-\t\ttaken = 0;\n-\t      else if (GET_CODE (else_dest) == LABEL_REF\n-\t\t       && XEXP (else_dest, 0) == if_false_label)\n-\t\ttaken = 1;\n-\t      else if (GET_CODE (else_dest) == LABEL_REF\n-\t\t       && XEXP (else_dest, 0) == if_true_label)\n-\t\ttaken = 0;\n-\t      /* Otherwise check where we drop through.  */\n-\t      else if (else_dest == pc_rtx)\n-\t\t{\n-\t\t  if (next && NOTE_P (next))\n-\t\t    next = next_nonnote_insn (next);\n-\n-\t\t  if (next && JUMP_P (next)\n-\t\t      && any_uncondjump_p (next))\n-\t\t    temp = XEXP (SET_SRC (pc_set (next)), 0);\n-\t\t  else\n-\t\t    temp = next;\n-\n-\t\t  /* TEMP is either a CODE_LABEL, NULL_RTX or something\n-\t\t     else that can't possibly match either target label.  */\n-\t\t  if (temp == if_false_label)\n-\t\t    taken = 1;\n-\t\t  else if (temp == if_true_label)\n-\t\t    taken = 0;\n-\t\t}\n-\t      else if (then_dest == pc_rtx)\n-\t\t{\n-\t\t  if (next && NOTE_P (next))\n-\t\t    next = next_nonnote_insn (next);\n-\n-\t\t  if (next && JUMP_P (next)\n-\t\t      && any_uncondjump_p (next))\n-\t\t    temp = XEXP (SET_SRC (pc_set (next)), 0);\n-\t\t  else\n-\t\t    temp = next;\n-\n-\t\t  if (temp == if_false_label)\n-\t\t    taken = 0;\n-\t\t  else if (temp == if_true_label)\n-\t\t    taken = 1;\n-\t\t}\n-\n-\t      if (taken != -1)\n-\t\t{\n-\t\t  /* If the test is expected to fail, reverse the\n-\t\t     probabilities.  */\n-\t\t  if (integer_zerop (arg1))\n-\t\t    taken = 1 - taken;\n-\t\t  predict_insn_def (insn, PRED_BUILTIN_EXPECT, taken);\n-\t\t}\n-\t    }\n-\n-\t  insn = next;\n-\t}\n-    }\n-\n-  return ret;\n-}\n-\n void\n expand_builtin_trap (void)\n {"}, {"sha": "046ee779fe721d489ae535c25d0b92dcbae2e09f", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef950eba664843fe4cb27c6d85809e84189b1381/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef950eba664843fe4cb27c6d85809e84189b1381/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=ef950eba664843fe4cb27c6d85809e84189b1381", "patch": "@@ -2300,11 +2300,6 @@ struct tree_opt_pass pass_jump =\n static unsigned int\n rest_of_handle_jump2 (void)\n {\n-  /* Turn NOTE_INSN_EXPECTED_VALUE into REG_BR_PROB.  Do this\n-     before jump optimization switches branch directions.  */\n-  if (flag_guess_branch_prob)\n-    expected_value_to_br_prob ();\n-\n   delete_trivially_dead_insns (get_insns (), max_reg_num ());\n   reg_scan (get_insns (), max_reg_num ());\n   if (dump_file)"}, {"sha": "76f603f78200de14f7cd9b9e107f79f210861dad", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef950eba664843fe4cb27c6d85809e84189b1381/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef950eba664843fe4cb27c6d85809e84189b1381/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=ef950eba664843fe4cb27c6d85809e84189b1381", "patch": "@@ -45,7 +45,7 @@ Boston, MA 02110-1301, USA.  */\n    ??? We really ought to pass the probability down to RTL expanders and let it\n    re-distribute it when the conditional expands into multiple conditionals.\n    This is however difficult to do.  */\n-static void\n+void\n add_reg_br_prob_note (rtx last, int probability)\n {\n   if (profile_status == PROFILE_ABSENT)"}, {"sha": "6bd63c250a1f41d9d9b81f741b0e4e68afcc7989", "filename": "gcc/cfglayout.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef950eba664843fe4cb27c6d85809e84189b1381/gcc%2Fcfglayout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef950eba664843fe4cb27c6d85809e84189b1381/gcc%2Fcfglayout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfglayout.c?ref=ef950eba664843fe4cb27c6d85809e84189b1381", "patch": "@@ -997,7 +997,6 @@ duplicate_insn_chain (rtx from, rtx to)\n \t    case NOTE_INSN_BASIC_BLOCK:\n \t      break;\n \n-\t    case NOTE_INSN_REPEATED_LINE_NUMBER:\n \t    case NOTE_INSN_SWITCH_TEXT_SECTIONS:\n \t      emit_note_copy (insn);\n \t      break;"}, {"sha": "2a1391ef3cd13ff687755fac6724357d704efdd3", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef950eba664843fe4cb27c6d85809e84189b1381/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef950eba664843fe4cb27c6d85809e84189b1381/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=ef950eba664843fe4cb27c6d85809e84189b1381", "patch": "@@ -5874,10 +5874,9 @@ programmers are notoriously bad at predicting how their programs\n actually perform.  However, there are applications in which this\n data is hard to collect.\n \n-The return value is the value of @var{exp}, which should be an\n-integral expression.  The value of @var{c} must be a compile-time\n-constant.  The semantics of the built-in are that it is expected\n-that @var{exp} == @var{c}.  For example:\n+The return value is the value of @var{exp}, which should be an integral\n+expression.  The semantics of the built-in are that it is expected that\n+@var{exp} == @var{c}.  For example:\n \n @smallexample\n if (__builtin_expect (x, 0))"}, {"sha": "05bcd9b0b19f78cb836b6480b0dd61bf84f3ae3c", "filename": "gcc/dojump.c", "status": "modified", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef950eba664843fe4cb27c6d85809e84189b1381/gcc%2Fdojump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef950eba664843fe4cb27c6d85809e84189b1381/gcc%2Fdojump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdojump.c?ref=ef950eba664843fe4cb27c6d85809e84189b1381", "patch": "@@ -551,37 +551,6 @@ do_jump (tree exp, rtx if_false_label, rtx if_true_label)\n \t}\n       break;\n \n-      /* Special case:\n-          __builtin_expect (<test>, 0)\tand\n-          __builtin_expect (<test>, 1)\n-\n-         We need to do this here, so that <test> is not converted to a SCC\n-         operation on machines that use condition code registers and COMPARE\n-         like the PowerPC, and then the jump is done based on whether the SCC\n-         operation produced a 1 or 0.  */\n-    case CALL_EXPR:\n-      /* Check for a built-in function.  */\n-      {\n-\ttree fndecl = get_callee_fndecl (exp);\n-\ttree arglist = TREE_OPERAND (exp, 1);\n-\n-\tif (fndecl\n-\t    && DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_NORMAL\n-\t    && DECL_FUNCTION_CODE (fndecl) == BUILT_IN_EXPECT\n-\t    && arglist != NULL_TREE\n-\t    && TREE_CHAIN (arglist) != NULL_TREE)\n-\t  {\n-\t    rtx seq = expand_builtin_expect_jump (exp, if_false_label,\n-\t\t\t\t\t\t  if_true_label);\n-\n-\t    if (seq != NULL_RTX)\n-\t      {\n-\t\temit_insn (seq);\n-\t\treturn;\n-\t      }\n-\t  }\n-      }\n- \n       /* Fall through and generate the normal code.  */\n     default:\n     normal:"}, {"sha": "4bfebcfdf99cdd0e557ead5e9f2c6282eedb3fb5", "filename": "gcc/except.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef950eba664843fe4cb27c6d85809e84189b1381/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef950eba664843fe4cb27c6d85809e84189b1381/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=ef950eba664843fe4cb27c6d85809e84189b1381", "patch": "@@ -1875,11 +1875,9 @@ sjlj_emit_function_enter (rtx dispatch_label)\n \t\t\t\t plus_constant (XEXP (fc, 0),\n \t\t\t\t\t\tsjlj_fc_jbuf_ofs), Pmode);\n \n-    note = emit_note (NOTE_INSN_EXPECTED_VALUE);\n-    NOTE_EXPECTED_VALUE (note) = gen_rtx_EQ (VOIDmode, x, const0_rtx);\n-\n     emit_cmp_and_jump_insns (x, const0_rtx, NE, 0,\n \t\t\t     TYPE_MODE (integer_type_node), 0, dispatch_label);\n+    add_reg_br_prob_note (get_insns (), REG_BR_PROB_BASE/100);\n   }\n #else\n   expand_builtin_setjmp_setup (plus_constant (XEXP (fc, 0), sjlj_fc_jbuf_ofs),"}, {"sha": "9b3d69601c409da9a17d2dfebb61e513f6cf2bf9", "filename": "gcc/final.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef950eba664843fe4cb27c6d85809e84189b1381/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef950eba664843fe4cb27c6d85809e84189b1381/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=ef950eba664843fe4cb27c6d85809e84189b1381", "patch": "@@ -1698,8 +1698,6 @@ final_scan_insn (rtx insn, FILE *file, int optimize ATTRIBUTE_UNUSED,\n \t{\n \tcase NOTE_INSN_DELETED:\n \tcase NOTE_INSN_FUNCTION_END:\n-\tcase NOTE_INSN_REPEATED_LINE_NUMBER:\n-\tcase NOTE_INSN_EXPECTED_VALUE:\n \t  break;\n \n \tcase NOTE_INSN_SWITCH_TEXT_SECTIONS:"}, {"sha": "1464c5f26af75340ae018b57b89ee050e585288d", "filename": "gcc/gengtype.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef950eba664843fe4cb27c6d85809e84189b1381/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef950eba664843fe4cb27c6d85809e84189b1381/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=ef950eba664843fe4cb27c6d85809e84189b1381", "patch": "@@ -519,7 +519,6 @@ adjust_field_rtx_def (type_p t, options_p ARG_UNUSED (opt))\n \t    note_flds = create_field (note_flds, tree_tp, \"rt_tree\");\n \t    break;\n \n-\t  case NOTE_INSN_EXPECTED_VALUE:\n \t  case NOTE_INSN_VAR_LOCATION:\n \t    note_flds = create_field (note_flds, rtx_tp, \"rt_rtx\");\n \t    break;"}, {"sha": "5dd9e60b821cd2d311e791a97b17d2de3ef75bfb", "filename": "gcc/predict.c", "status": "modified", "additions": 0, "deletions": 73, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef950eba664843fe4cb27c6d85809e84189b1381/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef950eba664843fe4cb27c6d85809e84189b1381/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=ef950eba664843fe4cb27c6d85809e84189b1381", "patch": "@@ -1340,79 +1340,6 @@ tree_estimate_probability (void)\n   return 0;\n }\n \f\n-/* __builtin_expect dropped tokens into the insn stream describing expected\n-   values of registers.  Generate branch probabilities based off these\n-   values.  */\n-\n-void\n-expected_value_to_br_prob (void)\n-{\n-  rtx insn, cond, ev = NULL_RTX, ev_reg = NULL_RTX;\n-\n-  for (insn = get_insns (); insn ; insn = NEXT_INSN (insn))\n-    {\n-      switch (GET_CODE (insn))\n-\t{\n-\tcase NOTE:\n-\t  /* Look for expected value notes.  */\n-\t  if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_EXPECTED_VALUE)\n-\t    {\n-\t      ev = NOTE_EXPECTED_VALUE (insn);\n-\t      ev_reg = XEXP (ev, 0);\n-\t      delete_insn (insn);\n-\t    }\n-\t  continue;\n-\n-\tcase CODE_LABEL:\n-\t  /* Never propagate across labels.  */\n-\t  ev = NULL_RTX;\n-\t  continue;\n-\n-\tcase JUMP_INSN:\n-\t  /* Look for simple conditional branches.  If we haven't got an\n-\t     expected value yet, no point going further.  */\n-\t  if (!JUMP_P (insn) || ev == NULL_RTX\n-\t      || ! any_condjump_p (insn))\n-\t    continue;\n-\t  break;\n-\n-\tdefault:\n-\t  /* Look for insns that clobber the EV register.  */\n-\t  if (ev && reg_set_p (ev_reg, insn))\n-\t    ev = NULL_RTX;\n-\t  continue;\n-\t}\n-\n-      /* Collect the branch condition, hopefully relative to EV_REG.  */\n-      /* ???  At present we'll miss things like\n-\t\t(expected_value (eq r70 0))\n-\t\t(set r71 -1)\n-\t\t(set r80 (lt r70 r71))\n-\t\t(set pc (if_then_else (ne r80 0) ...))\n-\t as canonicalize_condition will render this to us as\n-\t\t(lt r70, r71)\n-\t Could use cselib to try and reduce this further.  */\n-      cond = XEXP (SET_SRC (pc_set (insn)), 0);\n-      cond = canonicalize_condition (insn, cond, 0, NULL, ev_reg,\n-\t\t\t\t     false, false);\n-      if (! cond || XEXP (cond, 0) != ev_reg\n-\t  || GET_CODE (XEXP (cond, 1)) != CONST_INT)\n-\tcontinue;\n-\n-      /* Substitute and simplify.  Given that the expression we're\n-\t building involves two constants, we should wind up with either\n-\t true or false.  */\n-      cond = gen_rtx_fmt_ee (GET_CODE (cond), VOIDmode,\n-\t\t\t     XEXP (ev, 1), XEXP (cond, 1));\n-      cond = simplify_rtx (cond);\n-\n-      /* Turn the condition into a scaled branch probability.  */\n-      gcc_assert (cond == const_true_rtx || cond == const0_rtx);\n-      predict_insn_def (insn, PRED_BUILTIN_EXPECT,\n-\t\t        cond == const_true_rtx ? TAKEN : NOT_TAKEN);\n-    }\n-}\n-\f\n /* Check whether this is the last basic block of function.  Commonly\n    there is one extra common cleanup block.  */\n static bool"}, {"sha": "d8ddc9bf4df8f9ee086c021f2eaaa14ec5b6d587", "filename": "gcc/print-rtl.c", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef950eba664843fe4cb27c6d85809e84189b1381/gcc%2Fprint-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef950eba664843fe4cb27c6d85809e84189b1381/gcc%2Fprint-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-rtl.c?ref=ef950eba664843fe4cb27c6d85809e84189b1381", "patch": "@@ -299,14 +299,6 @@ print_rtx (rtx in_rtx)\n \t\t  break;\n \t        }\n \n-\t      case NOTE_INSN_EXPECTED_VALUE:\n-\t\tindent += 2;\n-\t\tif (!sawclose)\n-\t\t  fprintf (outfile, \" \");\n-\t\tprint_rtx (NOTE_EXPECTED_VALUE (in_rtx));\n-\t\tindent -= 2;\n-\t\tbreak;\n-\n \t      case NOTE_INSN_DELETED_LABEL:\n \t\t{\n \t\t  const char *label = NOTE_DELETED_LABEL_NAME (in_rtx);"}, {"sha": "54dad700087ab14ec384b2de4daaf26eaf54463a", "filename": "gcc/rtl.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef950eba664843fe4cb27c6d85809e84189b1381/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef950eba664843fe4cb27c6d85809e84189b1381/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=ef950eba664843fe4cb27c6d85809e84189b1381", "patch": "@@ -2250,6 +2250,8 @@ extern GTY(()) rtx stack_limit_rtx;\n /* In predict.c */\n extern void invert_br_probabilities (rtx);\n extern bool expensive_function_p (int);\n+/* In cfgexpand.c */\n+extern void add_reg_br_prob_note (rtx last, int probability);\n /* In tracer.c */\n extern void tracer (unsigned int);\n "}]}