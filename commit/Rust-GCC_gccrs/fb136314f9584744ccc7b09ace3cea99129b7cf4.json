{"sha": "fb136314f9584744ccc7b09ace3cea99129b7cf4", "node_id": "C_kwDOANBUbNoAKGZiMTM2MzE0Zjk1ODQ3NDRjY2M3YjA5YWNlM2NlYTk5MTI5YjdjZjQ", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-05-02T14:32:12Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-05-02T14:32:12Z"}, "message": "Merge #1191\n\n1191: Resolve simple paths in use items r=CohenArthur a=CohenArthur\n\nIn order to resolve `SimplePath`s, we have to expand all paths present\r\nin a `UseDeclaration` and resolve them. For example, we want to resolve\r\ntwo paths with the following statement `use foo::bar::{baz, bul}`:\r\n`foo::bar::baz` and `foo::bar::bul`\r\nThis also removes the prelude inclusion (`use std::prelude::v1::*`)\r\nsince we cannot resolve it (yet!)\r\n\r\nNeeds #1172 to compile\r\nAdresses #1159 \r\nAdresses #1187 \n\nCo-authored-by: Arthur Cohen <arthur.cohen@embecosm.com>", "tree": {"sha": "49040fe0347cbe57412c4fd79d7e2e55c18abcc0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/49040fe0347cbe57412c4fd79d7e2e55c18abcc0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fb136314f9584744ccc7b09ace3cea99129b7cf4", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJib+tsCRBK7hj4Ov3rIwAAz9gIAKbr6BgfZIZ1K2tHX5yY7Hgm\npNWUQGXLwJOUpOxmKa+B+wEPkAhIEB6xwbM51KLsMgxZqdoOCPgtMzIrwDJW60Fj\nmxlLpayzBuiDZtHuMt4Cp5cLYry/1AspXeRVTnzFjatMZNuKI/leCCHPBDcnsvi1\nAaUcHLUHGJdsCHlQYyGCjseasXF5la8JUvUo/lxm/Jj+UGnyQN63vijvwE5jWM4K\nvqqNitBjd3RYdSiAHU3BMOP1REBVP4lGKouOfWAGymd3ffrUW6HBGv2vU3TYTWEo\nLCyfqga4QM2mj0HXL6FBy5wmVj3KTluO3ewUoQqUBG95GVTnODKi3kYO6ig1JSk=\n=WFFM\n-----END PGP SIGNATURE-----\n", "payload": "tree 49040fe0347cbe57412c4fd79d7e2e55c18abcc0\nparent 27e562a2c07c9f09c80f905cf7ebc4a5b25672eb\nparent 98e1de2d8fdc0f39af161284d2cc74755aa1d260\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1651501932 +0000\ncommitter GitHub <noreply@github.com> 1651501932 +0000\n\nMerge #1191\n\n1191: Resolve simple paths in use items r=CohenArthur a=CohenArthur\n\nIn order to resolve `SimplePath`s, we have to expand all paths present\r\nin a `UseDeclaration` and resolve them. For example, we want to resolve\r\ntwo paths with the following statement `use foo::bar::{baz, bul}`:\r\n`foo::bar::baz` and `foo::bar::bul`\r\nThis also removes the prelude inclusion (`use std::prelude::v1::*`)\r\nsince we cannot resolve it (yet!)\r\n\r\nNeeds #1172 to compile\r\nAdresses #1159 \r\nAdresses #1187 \n\nCo-authored-by: Arthur Cohen <arthur.cohen@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb136314f9584744ccc7b09ace3cea99129b7cf4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb136314f9584744ccc7b09ace3cea99129b7cf4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb136314f9584744ccc7b09ace3cea99129b7cf4/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "27e562a2c07c9f09c80f905cf7ebc4a5b25672eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27e562a2c07c9f09c80f905cf7ebc4a5b25672eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/27e562a2c07c9f09c80f905cf7ebc4a5b25672eb"}, {"sha": "98e1de2d8fdc0f39af161284d2cc74755aa1d260", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98e1de2d8fdc0f39af161284d2cc74755aa1d260", "html_url": "https://github.com/Rust-GCC/gccrs/commit/98e1de2d8fdc0f39af161284d2cc74755aa1d260"}], "stats": {"total": 525, "additions": 455, "deletions": 70}, "files": [{"sha": "69ad6eb13fd9b1c5a7274f2ef4bce94a20b979a4", "filename": "gcc/rust/ast/rust-ast.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb136314f9584744ccc7b09ace3cea99129b7cf4/gcc%2Frust%2Fast%2Frust-ast.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb136314f9584744ccc7b09ace3cea99129b7cf4/gcc%2Frust%2Fast%2Frust-ast.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast.h?ref=fb136314f9584744ccc7b09ace3cea99129b7cf4", "patch": "@@ -410,6 +410,8 @@ class SimplePath\n   {\n     return segments;\n   }\n+\n+  std::vector<SimplePathSegment> &get_segments () { return segments; }\n };\n \n // path-to-string inverse comparison operator"}, {"sha": "4bed5af51eeb237b193829599153b52531c436fd", "filename": "gcc/rust/ast/rust-item.h", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb136314f9584744ccc7b09ace3cea99129b7cf4/gcc%2Frust%2Fast%2Frust-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb136314f9584744ccc7b09ace3cea99129b7cf4/gcc%2Frust%2Fast%2Frust-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-item.h?ref=fb136314f9584744ccc7b09ace3cea99129b7cf4", "patch": "@@ -1179,15 +1179,37 @@ class UseTree\n   Location locus;\n \n public:\n+  enum Kind\n+  {\n+    Glob,\n+    Rebind,\n+    List,\n+  };\n+\n   virtual ~UseTree () {}\n \n+  // Overload assignment operator to clone\n+  UseTree &operator= (UseTree const &other)\n+  {\n+    locus = other.locus;\n+\n+    return *this;\n+  }\n+\n+  UseTree (const UseTree &other) = default;\n+\n+  // move constructors\n+  UseTree (UseTree &&other) = default;\n+  UseTree &operator= (UseTree &&other) = default;\n+\n   // Unique pointer custom clone function\n   std::unique_ptr<UseTree> clone_use_tree () const\n   {\n     return std::unique_ptr<UseTree> (clone_use_tree_impl ());\n   }\n \n   virtual std::string as_string () const = 0;\n+  virtual Kind get_kind () const = 0;\n \n   Location get_locus () const { return locus; }\n \n@@ -1237,6 +1259,14 @@ class UseTreeGlob : public UseTree\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  Kind get_kind () const override { return Glob; }\n+\n+  SimplePath get_path () const\n+  {\n+    rust_assert (has_path ());\n+    return path;\n+  }\n+\n   /* TODO: find way to ensure only PATH_PREFIXED glob_type has path - factory\n    * methods? */\n protected:\n@@ -1318,6 +1348,18 @@ class UseTreeList : public UseTree\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  Kind get_kind () const override { return List; }\n+  SimplePath get_path () const\n+  {\n+    rust_assert (has_path ());\n+    return path;\n+  }\n+\n+  const std::vector<std::unique_ptr<UseTree>> &get_trees () const\n+  {\n+    return trees;\n+  }\n+\n   // TODO: find way to ensure only PATH_PREFIXED path_type has path - factory\n   // methods?\n protected:\n@@ -1363,6 +1405,20 @@ class UseTreeRebind : public UseTree\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  Kind get_kind () const override { return Rebind; }\n+\n+  SimplePath get_path () const\n+  {\n+    rust_assert (has_path ());\n+    return path;\n+  }\n+\n+  const Identifier &get_identifier () const\n+  {\n+    rust_assert (has_identifier ());\n+    return identifier;\n+  }\n+\n   // TODO: find way to ensure only PATH_PREFIXED path_type has path - factory\n   // methods?\n protected:\n@@ -1420,6 +1476,7 @@ class UseDeclaration : public VisItem\n   UseDeclaration &operator= (UseDeclaration &&other) = default;\n \n   Location get_locus () const override final { return locus; }\n+  const std::unique_ptr<UseTree> &get_tree () const { return use_tree; }\n \n   void accept_vis (ASTVisitor &vis) override;\n "}, {"sha": "93eca1b9df2a2b9fbf0dcb77678a64b5fa8ad339", "filename": "gcc/rust/resolve/rust-ast-resolve-item.cc", "status": "modified", "additions": 295, "deletions": 2, "changes": 297, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb136314f9584744ccc7b09ace3cea99129b7cf4/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb136314f9584744ccc7b09ace3cea99129b7cf4/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.cc?ref=fb136314f9584744ccc7b09ace3cea99129b7cf4", "patch": "@@ -17,6 +17,8 @@\n // <http://www.gnu.org/licenses/>.\n \n #include \"rust-ast-resolve-item.h\"\n+#include \"rust-ast-resolve-path.h\"\n+#include \"selftest.h\"\n \n namespace Rust {\n namespace Resolver {\n@@ -133,7 +135,7 @@ ResolveTraitItems::visit (AST::TraitItemMethod &func)\n \t\t\t\t       self_param.get_is_mut (),\n \t\t\t\t       std::unique_ptr<AST::Pattern> (nullptr));\n \n-  std::vector<std::unique_ptr<AST::TypePathSegment> > segments;\n+  std::vector<std::unique_ptr<AST::TypePathSegment>> segments;\n   segments.push_back (std::unique_ptr<AST::TypePathSegment> (\n     new AST::TypePathSegment (\"Self\", false, self_param.get_locus ())));\n \n@@ -694,7 +696,7 @@ ResolveItem::visit (AST::Method &method)\n \t\t\t\t       self_param.get_is_mut (),\n \t\t\t\t       std::unique_ptr<AST::Pattern> (nullptr));\n \n-  std::vector<std::unique_ptr<AST::TypePathSegment> > segments;\n+  std::vector<std::unique_ptr<AST::TypePathSegment>> segments;\n   segments.push_back (std::unique_ptr<AST::TypePathSegment> (\n     new AST::TypePathSegment (\"Self\", false, self_param.get_locus ())));\n \n@@ -902,6 +904,133 @@ ResolveItem::visit (AST::ExternBlock &extern_block)\n     }\n }\n \n+static void\n+flatten_glob (const AST::UseTreeGlob &glob,\n+\t      std::vector<AST::SimplePath> &paths);\n+static void\n+flatten_rebind (const AST::UseTreeRebind &glob,\n+\t\tstd::vector<AST::SimplePath> &paths);\n+static void\n+flatten_list (const AST::UseTreeList &glob,\n+\t      std::vector<AST::SimplePath> &paths);\n+\n+static void\n+flatten (const AST::UseTree *tree, std::vector<AST::SimplePath> &paths)\n+{\n+  switch (tree->get_kind ())\n+    {\n+      case AST::UseTree::Glob: {\n+\tauto glob = static_cast<const AST::UseTreeGlob *> (tree);\n+\tflatten_glob (*glob, paths);\n+\tbreak;\n+      }\n+      case AST::UseTree::Rebind: {\n+\tauto rebind = static_cast<const AST::UseTreeRebind *> (tree);\n+\tflatten_rebind (*rebind, paths);\n+\tbreak;\n+      }\n+      case AST::UseTree::List: {\n+\tauto list = static_cast<const AST::UseTreeList *> (tree);\n+\tflatten_list (*list, paths);\n+\tbreak;\n+      }\n+      break;\n+    }\n+}\n+\n+static void\n+flatten_glob (const AST::UseTreeGlob &glob, std::vector<AST::SimplePath> &paths)\n+{\n+  if (glob.has_path ())\n+    paths.emplace_back (glob.get_path ());\n+}\n+\n+static void\n+flatten_rebind (const AST::UseTreeRebind &rebind,\n+\t\tstd::vector<AST::SimplePath> &paths)\n+{\n+  auto path = rebind.get_path ();\n+  if (rebind.has_path ())\n+    paths.emplace_back (path);\n+\n+  // FIXME: Do we want to emplace the rebind here as well?\n+  if (rebind.has_identifier ())\n+    {\n+      auto rebind_path = path;\n+      auto new_seg = rebind.get_identifier ();\n+\n+      // Add the identifier as a new path\n+      rebind_path.get_segments ().back ()\n+\t= AST::SimplePathSegment (new_seg, Location ());\n+\n+      paths.emplace_back (rebind_path);\n+    }\n+}\n+\n+static void\n+flatten_list (const AST::UseTreeList &list, std::vector<AST::SimplePath> &paths)\n+{\n+  auto prefix = AST::SimplePath::create_empty ();\n+  if (list.has_path ())\n+    prefix = list.get_path ();\n+\n+  for (const auto &tree : list.get_trees ())\n+    {\n+      auto sub_paths = std::vector<AST::SimplePath> ();\n+      flatten (tree.get (), sub_paths);\n+\n+      for (auto &sub_path : sub_paths)\n+\t{\n+\t  auto new_path = prefix;\n+\t  std::copy (sub_path.get_segments ().begin (),\n+\t\t     sub_path.get_segments ().end (),\n+\t\t     std::back_inserter (new_path.get_segments ()));\n+\n+\t  paths.emplace_back (new_path);\n+\t}\n+    }\n+}\n+\n+/**\n+ * Flatten a UseDeclaration's UseTree into multiple simple paths to resolve.\n+ *\n+ * Given the following use declarations:\n+ * ```\n+ * use some::path::to_resolve; #1\n+ * use some::path::to_glob::*; #2\n+ * use some::path::{one, two}; #2\n+ * ```\n+ *\n+ * In the first case, we simply want to return a vector with a single\n+ * SimplePath:\n+ * [some::path::to_resolve]\n+ *\n+ * In the second case, we want to resolve the glob's \"origin path\":\n+ * [some::path::to_glob]\n+ *\n+ * Finally in the third case, we want to create two SimplePaths to resolve:\n+ * [some::path::one, some::path::two]\n+ */\n+static std::vector<AST::SimplePath>\n+flatten_use_dec_to_paths (const AST::UseDeclaration &use_item)\n+{\n+  auto paths = std::vector<AST::SimplePath> ();\n+\n+  const auto &tree = use_item.get_tree ();\n+  flatten (tree.get (), paths);\n+\n+  return paths;\n+}\n+\n+void\n+ResolveItem::visit (AST::UseDeclaration &use_item)\n+{\n+  auto to_resolve = flatten_use_dec_to_paths (use_item);\n+\n+  for (auto &path : to_resolve)\n+    ResolvePath::go (&path, parent);\n+}\n+\n void\n ResolveImplItems::go (AST::InherentImplItem *item, const CanonicalPath &prefix,\n \t\t      const CanonicalPath &canonical_prefix)\n@@ -991,3 +1120,167 @@ ResolveExternItem::visit (AST::ExternalStaticItem &item)\n \n } // namespace Resolver\n } // namespace Rust\n+\n+#if CHECKING_P\n+\n+namespace selftest {\n+\n+static void\n+rust_flatten_nested_glob (void)\n+{\n+  auto foo = Rust::AST::SimplePathSegment (\"foo\", Location ());\n+  auto bar = Rust::AST::SimplePathSegment (\"bar\", Location ());\n+  auto foobar = Rust::AST::SimplePath ({foo, bar});\n+\n+  auto glob\n+    = Rust::AST::UseTreeGlob (Rust::AST::UseTreeGlob::PathType::PATH_PREFIXED,\n+\t\t\t      foobar, Location ());\n+\n+  auto paths = std::vector<Rust::AST::SimplePath> ();\n+  Rust::Resolver::flatten_glob (glob, paths);\n+\n+  ASSERT_TRUE (!paths.empty ());\n+  ASSERT_EQ (paths.size (), 1);\n+  ASSERT_EQ (paths[0].get_segments ()[0].as_string (), \"foo\");\n+  ASSERT_EQ (paths[0].get_segments ()[1].as_string (), \"bar\");\n+}\n+\n+static void\n+rust_flatten_glob (void)\n+{\n+  auto frob = Rust::AST::SimplePath::from_str (\"frobulator\", Location ());\n+\n+  auto glob\n+    = Rust::AST::UseTreeGlob (Rust::AST::UseTreeGlob::PathType::PATH_PREFIXED,\n+\t\t\t      frob, Location ());\n+\n+  auto paths = std::vector<Rust::AST::SimplePath> ();\n+  Rust::Resolver::flatten_glob (glob, paths);\n+\n+  ASSERT_TRUE (!paths.empty ());\n+  ASSERT_EQ (paths.size (), 1);\n+  ASSERT_EQ (paths[0], \"frobulator\");\n+}\n+\n+static void\n+rust_flatten_rebind_none (void)\n+{\n+  auto foo = Rust::AST::SimplePathSegment (\"foo\", Location ());\n+  auto bar = Rust::AST::SimplePathSegment (\"bar\", Location ());\n+  auto foobar = Rust::AST::SimplePath ({foo, bar});\n+\n+  auto rebind = Rust::AST::UseTreeRebind (Rust::AST::UseTreeRebind::NONE,\n+\t\t\t\t\t  foobar, Location ());\n+\n+  auto paths = std::vector<Rust::AST::SimplePath> ();\n+  Rust::Resolver::flatten_rebind (rebind, paths);\n+\n+  ASSERT_TRUE (!paths.empty ());\n+  ASSERT_EQ (paths.size (), 1);\n+  ASSERT_EQ (paths[0].get_segments ()[0].as_string (), \"foo\");\n+  ASSERT_EQ (paths[0].get_segments ()[1].as_string (), \"bar\");\n+}\n+\n+static void\n+rust_flatten_rebind (void)\n+{\n+  auto frob = Rust::AST::SimplePath::from_str (\"frobulator\", Location ());\n+\n+  auto rebind = Rust::AST::UseTreeRebind (Rust::AST::UseTreeRebind::IDENTIFIER,\n+\t\t\t\t\t  frob, Location (), \"saindoux\");\n+\n+  auto paths = std::vector<Rust::AST::SimplePath> ();\n+  Rust::Resolver::flatten_rebind (rebind, paths);\n+\n+  ASSERT_TRUE (!paths.empty ());\n+  ASSERT_EQ (paths.size (), 2);\n+  ASSERT_EQ (paths[0], \"frobulator\");\n+  ASSERT_EQ (paths[1], \"saindoux\");\n+}\n+\n+static void\n+rust_flatten_rebind_nested (void)\n+{\n+  auto foo = Rust::AST::SimplePathSegment (\"foo\", Location ());\n+  auto bar = Rust::AST::SimplePathSegment (\"bar\", Location ());\n+  auto baz = Rust::AST::SimplePathSegment (\"baz\", Location ());\n+\n+  auto foo_bar_baz = Rust::AST::SimplePath ({foo, bar, baz});\n+\n+  auto rebind = Rust::AST::UseTreeRebind (Rust::AST::UseTreeRebind::IDENTIFIER,\n+\t\t\t\t\t  foo_bar_baz, Location (), \"saindoux\");\n+\n+  auto paths = std::vector<Rust::AST::SimplePath> ();\n+  Rust::Resolver::flatten_rebind (rebind, paths);\n+\n+  ASSERT_TRUE (!paths.empty ());\n+  ASSERT_EQ (paths.size (), 2);\n+  ASSERT_EQ (paths[0].get_segments ()[0].as_string (), \"foo\");\n+  ASSERT_EQ (paths[0].get_segments ()[1].as_string (), \"bar\");\n+  ASSERT_EQ (paths[0].get_segments ()[2].as_string (), \"baz\");\n+  ASSERT_EQ (paths[1].get_segments ()[0].as_string (), \"foo\");\n+  ASSERT_EQ (paths[1].get_segments ()[1].as_string (), \"bar\");\n+  ASSERT_EQ (paths[1].get_segments ()[2].as_string (), \"saindoux\");\n+}\n+\n+static void\n+rust_flatten_list (void)\n+{\n+  auto foo = Rust::AST::SimplePathSegment (\"foo\", Location ());\n+  auto bar = Rust::AST::SimplePathSegment (\"bar\", Location ());\n+  auto foo_bar = Rust::AST::SimplePath ({foo, bar});\n+\n+  auto baz = Rust::AST::SimplePath::from_str (\"baz\", Location ());\n+  auto bul = Rust::AST::SimplePath::from_str (\"bul\", Location ());\n+\n+  // use foo::bar::{baz, bul};\n+\n+  auto use0 = std::unique_ptr<Rust::AST::UseTree> (\n+    new Rust::AST::UseTreeRebind (Rust::AST::UseTreeRebind::NONE, baz,\n+\t\t\t\t  Location ()));\n+  auto use1 = std::unique_ptr<Rust::AST::UseTree> (\n+    new Rust::AST::UseTreeRebind (Rust::AST::UseTreeRebind::NONE, bul,\n+\t\t\t\t  Location ()));\n+\n+  auto uses = std::vector<std::unique_ptr<Rust::AST::UseTree>> ();\n+  uses.emplace_back (std::move (use0));\n+  uses.emplace_back (std::move (use1));\n+\n+  auto list = Rust::AST::UseTreeList (Rust::AST::UseTreeList::PATH_PREFIXED,\n+\t\t\t\t      foo_bar, std::move (uses), Location ());\n+\n+  auto paths = std::vector<Rust::AST::SimplePath> ();\n+  Rust::Resolver::flatten_list (list, paths);\n+\n+  for (auto &path : paths)\n+    fprintf (stderr, \"%s\\n\", path.as_string ().c_str ());\n+\n+  ASSERT_TRUE (!paths.empty ());\n+  ASSERT_EQ (paths.size (), 2);\n+  ASSERT_EQ (paths[0].get_segments ()[0].as_string (), \"foo\");\n+  ASSERT_EQ (paths[0].get_segments ()[1].as_string (), \"bar\");\n+  ASSERT_EQ (paths[0].get_segments ()[2].as_string (), \"baz\");\n+  ASSERT_EQ (paths[1].get_segments ()[0].as_string (), \"foo\");\n+  ASSERT_EQ (paths[1].get_segments ()[1].as_string (), \"bar\");\n+  ASSERT_EQ (paths[1].get_segments ()[2].as_string (), \"bul\");\n+}\n+\n+static void\n+rust_use_dec_flattening (void)\n+{\n+  rust_flatten_glob ();\n+  rust_flatten_nested_glob ();\n+  rust_flatten_rebind_none ();\n+  rust_flatten_rebind ();\n+  rust_flatten_rebind_nested ();\n+  rust_flatten_list ();\n+}\n+\n+void\n+rust_simple_path_resolve_test (void)\n+{\n+  rust_use_dec_flattening ();\n+}\n+} // namespace selftest\n+\n+#endif // CHECKING_P"}, {"sha": "e6b11f514cba12582b06617138638ed7ec10fffa", "filename": "gcc/rust/resolve/rust-ast-resolve-item.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb136314f9584744ccc7b09ace3cea99129b7cf4/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb136314f9584744ccc7b09ace3cea99129b7cf4/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h?ref=fb136314f9584744ccc7b09ace3cea99129b7cf4", "patch": "@@ -26,6 +26,7 @@\n #include \"rust-ast-resolve-type.h\"\n #include \"rust-ast-resolve-pattern.h\"\n #include \"rust-ast-resolve-stmt.h\"\n+#include \"config.h\"\n \n namespace Rust {\n namespace Resolver {\n@@ -81,6 +82,7 @@ class ResolveItem : public ResolverBase\n   void visit (AST::TraitImpl &impl_block) override;\n   void visit (AST::Trait &trait) override;\n   void visit (AST::ExternBlock &extern_block) override;\n+  void visit (AST::UseDeclaration &) override;\n \n protected:\n   void resolve_impl_item (AST::TraitImplItem *item, const CanonicalPath &prefix,\n@@ -136,4 +138,13 @@ class ResolveExternItem : public ResolverBase\n } // namespace Resolver\n } // namespace Rust\n \n+#if CHECKING_P\n+\n+namespace selftest {\n+extern void\n+rust_simple_path_resolve_test (void);\n+} // namespace selftest\n+\n+#endif // CHECKING_P\n+\n #endif // RUST_AST_RESOLVE_ITEM_H"}, {"sha": "141788019ee8706a4159d4e7e1403f4fca2aeb9b", "filename": "gcc/rust/resolve/rust-ast-resolve-type.cc", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb136314f9584744ccc7b09ace3cea99129b7cf4/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb136314f9584744ccc7b09ace3cea99129b7cf4/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.cc?ref=fb136314f9584744ccc7b09ace3cea99129b7cf4", "patch": "@@ -248,5 +248,52 @@ ResolveType::visit (AST::SliceType &type)\n   type.get_elem_type ()->accept_vis (*this);\n }\n \n+ResolveRelativeTypePath::ResolveRelativeTypePath (CanonicalPath qualified_path)\n+  : ResolveTypeToCanonicalPath (true, true)\n+{\n+  result = qualified_path;\n+}\n+\n+bool\n+ResolveRelativeTypePath::go (AST::QualifiedPathInType &path)\n+{\n+  // resolve the type and trait path\n+  auto &qualified_path = path.get_qualified_path_type ();\n+  CanonicalPath result = CanonicalPath::create_empty ();\n+  if (!resolve_qual_seg (qualified_path, result))\n+    return false;\n+\n+  // resolve the associated impl if available but it can also be from a trait\n+  // and this is allowed to fail\n+  auto resolver = Resolver::get ();\n+  NodeId projection_resolved_id = UNKNOWN_NODEID;\n+  if (resolver->get_name_scope ().lookup (result, &projection_resolved_id))\n+    {\n+      // mark the resolution for this\n+      resolver->insert_resolved_name (qualified_path.get_node_id (),\n+\t\t\t\t      projection_resolved_id);\n+    }\n+\n+  // qualified types are similar to other paths in that we cannot guarantee\n+  // that we can resolve the path at name resolution. We must look up\n+  // associated types and type information to figure this out properly\n+\n+  ResolveRelativeTypePath o (result);\n+  std::unique_ptr<AST::TypePathSegment> &associated\n+    = path.get_associated_segment ();\n+\n+  associated->accept_vis (o);\n+  if (o.failure_flag)\n+    return false;\n+\n+  for (auto &seg : path.get_segments ())\n+    {\n+      seg->accept_vis (o);\n+      if (o.failure_flag)\n+\treturn false;\n+    }\n+\n+  return true;\n+}\n } // namespace Resolver\n } // namespace Rust"}, {"sha": "933413537b6dfdbfb9ebf5e1441b5dc76243f638", "filename": "gcc/rust/resolve/rust-ast-resolve-type.h", "status": "modified", "additions": 5, "deletions": 50, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb136314f9584744ccc7b09ace3cea99129b7cf4/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb136314f9584744ccc7b09ace3cea99129b7cf4/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h?ref=fb136314f9584744ccc7b09ace3cea99129b7cf4", "patch": "@@ -190,54 +190,10 @@ class ResolveRelativeTypePath : public ResolveTypeToCanonicalPath\n   using ResolveTypeToCanonicalPath::visit;\n \n public:\n-  static bool go (AST::QualifiedPathInType &path, NodeId parent,\n-\t\t  bool canonicalize_type_with_generics)\n-  {\n-    // resolve the type and trait path\n-    auto &qualified_path = path.get_qualified_path_type ();\n-    CanonicalPath result = CanonicalPath::create_empty ();\n-    if (!resolve_qual_seg (qualified_path, result))\n-      return false;\n-\n-    // resolve the associated impl if available but it can also be from a trait\n-    // and this is allowed to fail\n-    auto resolver = Resolver::get ();\n-    NodeId projection_resolved_id = UNKNOWN_NODEID;\n-    if (resolver->get_name_scope ().lookup (result, &projection_resolved_id))\n-      {\n-\t// mark the resolution for this\n-\tresolver->insert_resolved_name (qualified_path.get_node_id (),\n-\t\t\t\t\tprojection_resolved_id);\n-      }\n-\n-    // qualified types are similar to other paths in that we cannot guarantee\n-    // that we can resolve the path at name resolution. We must look up\n-    // associated types and type information to figure this out properly\n-\n-    ResolveRelativeTypePath o (result);\n-    std::unique_ptr<AST::TypePathSegment> &associated\n-      = path.get_associated_segment ();\n-\n-    associated->accept_vis (o);\n-    if (o.failure_flag)\n-      return false;\n-\n-    for (auto &seg : path.get_segments ())\n-      {\n-\tseg->accept_vis (o);\n-\tif (o.failure_flag)\n-\t  return false;\n-      }\n-\n-    return true;\n-  }\n+  static bool go (AST::QualifiedPathInType &path);\n \n private:\n-  ResolveRelativeTypePath (CanonicalPath qualified_path)\n-    : ResolveTypeToCanonicalPath (true, true)\n-  {\n-    result = qualified_path;\n-  }\n+  ResolveRelativeTypePath (CanonicalPath qualified_path);\n \n   static bool resolve_qual_seg (AST::QualifiedPathType &seg,\n \t\t\t\tCanonicalPath &result);\n@@ -375,8 +331,7 @@ class ResolveType : public ResolverBase\n \n   void visit (AST::QualifiedPathInType &path) override\n   {\n-    ok = ResolveRelativeTypePath::go (path, parent,\n-\t\t\t\t      canonicalize_type_with_generics);\n+    ok = ResolveRelativeTypePath::go (path);\n   }\n \n   void visit (AST::ArrayType &type) override;\n@@ -431,7 +386,7 @@ class ResolveTypeBound : public ResolverBase\n     ok = resolved_node != UNKNOWN_NODEID;\n   }\n \n-  void visit (AST::Lifetime &bound) override { ok = true; }\n+  void visit (AST::Lifetime &) override { ok = true; }\n \n private:\n   ResolveTypeBound (NodeId parent, bool canonicalize_type_with_generics)\n@@ -459,7 +414,7 @@ class ResolveGenericParam : public ResolverBase\n     return resolver.resolved_node;\n   };\n \n-  void visit (AST::LifetimeParam &param) override\n+  void visit (AST::LifetimeParam &) override\n   {\n     // For now do not do anything and accept everything.\n     ok = true;"}, {"sha": "73f9839ee3e6743784dd46da4d1866021a34c377", "filename": "gcc/rust/rust-lang.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb136314f9584744ccc7b09ace3cea99129b7cf4/gcc%2Frust%2Frust-lang.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb136314f9584744ccc7b09ace3cea99129b7cf4/gcc%2Frust%2Frust-lang.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-lang.cc?ref=fb136314f9584744ccc7b09ace3cea99129b7cf4", "patch": "@@ -36,6 +36,7 @@\n #include \"selftest.h\"\n #include \"rust-cfg-parser.h\"\n #include \"rust-privacy-ctx.h\"\n+#include \"rust-ast-resolve-item.h\"\n \n #include <mpfr.h>\n // note: header files must be in this order or else forward declarations don't\n@@ -459,6 +460,7 @@ run_rust_tests ()\n   rust_cfg_parser_test ();\n   rust_privacy_ctx_test ();\n   rust_crate_name_validation_test ();\n+  rust_simple_path_resolve_test ();\n }\n } // namespace selftest\n "}, {"sha": "0b0e5af915f48c955aafc22f9117c669466f1559", "filename": "gcc/rust/rust-session-manager.cc", "status": "modified", "additions": 19, "deletions": 17, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb136314f9584744ccc7b09ace3cea99129b7cf4/gcc%2Frust%2Frust-session-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb136314f9584744ccc7b09ace3cea99129b7cf4/gcc%2Frust%2Frust-session-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-session-manager.cc?ref=fb136314f9584744ccc7b09ace3cea99129b7cf4", "patch": "@@ -932,23 +932,25 @@ Session::injection (AST::Crate &crate)\n \n   // create use tree path\n   // prelude is injected_crate_name\n-  std::vector<AST::SimplePathSegment> segments\n-    = {AST::SimplePathSegment (injected_crate_name, Location ()),\n-       AST::SimplePathSegment (\"prelude\", Location ()),\n-       AST::SimplePathSegment (\"v1\", Location ())};\n-  // create use tree and decl\n-  std::unique_ptr<AST::UseTreeGlob> use_tree (\n-    new AST::UseTreeGlob (AST::UseTreeGlob::PATH_PREFIXED,\n-\t\t\t  AST::SimplePath (std::move (segments)), Location ()));\n-  AST::Attribute prelude_attr (AST::SimplePath::from_str (\"prelude_import\",\n-\t\t\t\t\t\t\t  Location ()),\n-\t\t\t       nullptr);\n-  std::unique_ptr<AST::UseDeclaration> use_decl (\n-    new AST::UseDeclaration (std::move (use_tree),\n-\t\t\t     AST::Visibility::create_error (),\n-\t\t\t     {std::move (prelude_attr)}, Location ()));\n-\n-  crate.items.insert (crate.items.begin (), std::move (use_decl));\n+  // FIXME: Once we do want to include the standard library, add the prelude\n+  // use item\n+  // std::vector<AST::SimplePathSegment> segments\n+  //   = {AST::SimplePathSegment (injected_crate_name, Location ()),\n+  //      AST::SimplePathSegment (\"prelude\", Location ()),\n+  //      AST::SimplePathSegment (\"v1\", Location ())};\n+  // // create use tree and decl\n+  // std::unique_ptr<AST::UseTreeGlob> use_tree (\n+  //   new AST::UseTreeGlob (AST::UseTreeGlob::PATH_PREFIXED,\n+  //     \t\t  AST::SimplePath (std::move (segments)), Location ()));\n+  // AST::Attribute prelude_attr (AST::SimplePath::from_str (\"prelude_import\",\n+  //     \t\t\t\t\t\t  Location ()),\n+  //     \t\t       nullptr);\n+  // std::unique_ptr<AST::UseDeclaration> use_decl (\n+  //   new AST::UseDeclaration (std::move (use_tree),\n+  //     \t\t     AST::Visibility::create_error (),\n+  //     \t\t     {std::move (prelude_attr)}, Location ()));\n+\n+  // crate.items.insert (crate.items.begin (), std::move (use_decl));\n \n   /* TODO: potentially add checking attribute crate type? I can't figure out\n    * what this does currently comment says \"Unconditionally collect crate"}, {"sha": "d65faf2972a044cc1d2ba0309e3ed235dabe7bd8", "filename": "gcc/testsuite/rust/compile/torture/cfg_attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb136314f9584744ccc7b09ace3cea99129b7cf4/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fcfg_attr.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb136314f9584744ccc7b09ace3cea99129b7cf4/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fcfg_attr.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fcfg_attr.rs?ref=fb136314f9584744ccc7b09ace3cea99129b7cf4", "patch": "@@ -1,4 +1,4 @@\n-use std::env; // Add one line so gccrs doesn't believe we're parsing a shebang\n+mod fake {} // Add one line so gccrs doesn't believe we're parsing a shebang\n \n #[cfg_attr(feature = \"somefeature\", attribute = \"someattr\")]\n struct Feature;"}, {"sha": "94b96321a6353476aac869768e4ca45e875430bb", "filename": "gcc/testsuite/rust/compile/use_1.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb136314f9584744ccc7b09ace3cea99129b7cf4/gcc%2Ftestsuite%2Frust%2Fcompile%2Fuse_1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb136314f9584744ccc7b09ace3cea99129b7cf4/gcc%2Ftestsuite%2Frust%2Fcompile%2Fuse_1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fuse_1.rs?ref=fb136314f9584744ccc7b09ace3cea99129b7cf4", "patch": "@@ -0,0 +1,16 @@\n+mod frob {}\n+\n+use foo::bar::baz; // { dg-error \"cannot find simple path segment .foo.\" }\n+use frob::ulator; // { dg-error \"cannot find simple path segment .ulator.\" }\n+\n+mod sain {\n+    mod doux {}\n+\n+    mod dron {}\n+}\n+\n+use not_sain::*; // { dg-error \"cannot find simple path segment .not_sain.\" }\n+\n+use sain::*;\n+use sain::{doux, dron};\n+use sain::{doux, dron, graal}; // { dg-error \"cannot find simple path segment .graal.\" }"}]}