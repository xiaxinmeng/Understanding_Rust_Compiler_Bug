{"sha": "eb3921e89a276761fba9562652ec83cbe03f25a9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWIzOTIxZTg5YTI3Njc2MWZiYTk1NjI2NTJlYzgzY2JlMDNmMjVhOQ==", "commit": {"author": {"name": "Nick Clifton", "email": "nickc@cygnus.com", "date": "1999-11-09T16:45:49Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "1999-11-09T16:45:49Z"}, "message": "Add prototypes file.\n\nFrom-SVN: r30460", "tree": {"sha": "b22d25bded1963d37333ae544c6caf7f8a9f2617", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b22d25bded1963d37333ae544c6caf7f8a9f2617"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eb3921e89a276761fba9562652ec83cbe03f25a9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb3921e89a276761fba9562652ec83cbe03f25a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb3921e89a276761fba9562652ec83cbe03f25a9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb3921e89a276761fba9562652ec83cbe03f25a9/comments", "author": null, "committer": null, "parents": [{"sha": "56e2e7627ef54dfc219481aa09b5367f00c79e47", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56e2e7627ef54dfc219481aa09b5367f00c79e47", "html_url": "https://github.com/Rust-GCC/gccrs/commit/56e2e7627ef54dfc219481aa09b5367f00c79e47"}], "stats": {"total": 382, "additions": 195, "deletions": 187}, "files": [{"sha": "5870287d399f8a0177036cd69876bbaae37603f5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb3921e89a276761fba9562652ec83cbe03f25a9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb3921e89a276761fba9562652ec83cbe03f25a9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=eb3921e89a276761fba9562652ec83cbe03f25a9", "patch": "@@ -1,3 +1,12 @@\n+Tue Nov  9 16:43:00 1999  Nick Clifton  <nickc@cygnus.com>\n+\n+\t* config/arm/arm-protos.h: New file: Prototypes for functions\n+\tdefined in arm.c and pe.c.\n+\t* config/arm/arm.h: Fix compile time warnings.\n+\t* config/arm/arm.c: Fix compile time warnings.\n+\t* config/arm/pe.h: Fix compile time warnings.\n+\t* config/arm/aout.h: Fix compile time warnings.\n+\n Tue Nov  9 14:55:44 1999  Nick Clifton  <nickc@cygnus.com>\n \n \t* config/m32r/m32r-protos.h: New file: Prototypes for functions"}, {"sha": "79003d28b08626a9ffedfaf7ebabb082f11ef0bb", "filename": "gcc/config/arm/aout.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb3921e89a276761fba9562652ec83cbe03f25a9/gcc%2Fconfig%2Farm%2Faout.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb3921e89a276761fba9562652ec83cbe03f25a9/gcc%2Fconfig%2Farm%2Faout.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Faout.h?ref=eb3921e89a276761fba9562652ec83cbe03f25a9", "patch": "@@ -37,8 +37,8 @@ Boston, MA 02111-1307, USA.  */\n }\n #endif\n \n-#define ASM_APP_ON  \t\t\"\"\n-#define ASM_APP_OFF  \t\t\"\"\n+#define ASM_APP_ON  \t\t\" \"\n+#define ASM_APP_OFF  \t\t\" \"\n \n /* Switch to the text or data segment.  */\n #define TEXT_SECTION_ASM_OP  \t\".text\""}, {"sha": "3da3cd8e07e270573f9093698f6e030426317a0c", "filename": "gcc/config/arm/arm-protos.h", "status": "added", "additions": 155, "deletions": 0, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb3921e89a276761fba9562652ec83cbe03f25a9/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb3921e89a276761fba9562652ec83cbe03f25a9/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=eb3921e89a276761fba9562652ec83cbe03f25a9", "patch": "@@ -0,0 +1,155 @@\n+/* Prototypes for exported functions defined in arm.c and pe.c\n+   Copyright (C) 1999 Free Software Foundation, Inc.\n+   Contributed by Richard Earnshaw (rearnsha@arm.com)\n+   Minor hacks by Nick Clifton (nickc@cygnus.com)\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+extern void   arm_expand_prologue\t\tPROTO ((void));\n+extern void   arm_finalize_pic \t\t\tPROTO ((void));\n+extern char * arm_output_epilogue\t\tPROTO ((void));\n+extern void   arm_override_options \t\tPROTO ((void));\n+extern void   arm_poke_function_name \t\tPROTO ((FILE *, char *));\n+extern int    arm_process_pragma\t\tPROTO ((int (*)(void), void (*) (int), char *));\n+extern int    arm_regno_class \t\t\tPROTO ((int));\n+extern int    arm_volatile_func\t\t\tPROTO ((void));\n+extern int    const_ok_for_arm\t\t\tPROTO ((HOST_WIDE_INT));\n+extern void   output_arm_prologue\t\tPROTO ((FILE *, int));\n+extern void   output_ascii_pseudo_op\t\tPROTO ((FILE *, unsigned char *, int));\n+extern void   output_func_epilogue\t\tPROTO ((int));\n+extern void   output_func_prologue\t\tPROTO ((FILE *, int));\n+extern int    use_return_insn\t\t\tPROTO ((int));\n+#if defined AOF_ASSEMBLER \n+extern void   aof_add_import\t\t\tPROTO ((char *));\n+extern char * aof_data_section\t\t\tPROTO ((void));\n+extern void   aof_delete_import\t\t\tPROTO ((char *));\n+extern void   aof_dump_imports\t\t\tPROTO ((FILE *));\n+extern void   aof_dump_pic_table\t\tPROTO ((FILE *));\n+extern char * aof_text_section\t\t\tPROTO ((void));\n+#endif /* AOF_ASSEMBLER */\n+/* Defined in pe.c */\n+extern int    arm_dllexport_name_p \t\tPROTO ((char *));\n+extern int    arm_dllimport_name_p \t\tPROTO ((char *));\n+\n+#define Mmode enum machine_mode\n+\n+#ifdef TREE_CODE\n+extern int    arm_comp_type_attributes\t\tPROTO ((tree, tree));\n+extern int    arm_return_in_memory\t\tPROTO ((tree));\n+extern int    arm_valid_machine_decl_attribute\tPROTO ((tree, tree, tree));\n+extern int    arm_valid_type_attribute_p \tPROTO ((tree, tree, tree, tree));\n+/* Defined in pe.c */\n+extern int    arm_dllexport_p \t\t\tPROTO ((tree));\n+extern int    arm_dllimport_p \t\t\tPROTO ((tree));\n+extern void   arm_mark_dllexport \t\tPROTO ((tree));\n+extern void   arm_mark_dllimport \t\tPROTO ((tree));\n+extern void   arm_pe_encode_section_info \tPROTO ((tree));\n+extern tree   arm_pe_merge_machine_decl_attributes PROTO ((tree, tree));\n+extern void   arm_pe_unique_section \t\tPROTO ((tree, int));\n+extern int    arm_pe_valid_machine_decl_attribute PROTO ((tree, tree, tree, tree));\n+#endif\n+\n+#ifdef RTX_CODE\n+extern int    adjacent_mem_locations\t\tPROTO ((rtx, rtx));\n+extern char * arithmetic_instr\t\t\tPROTO ((rtx, int));\n+extern int    arm_adjust_cost\t\t\tPROTO ((rtx, rtx, rtx, int));\n+extern RTX_CODE arm_canonicalize_comparison \tPROTO ((RTX_CODE, rtx *));\n+extern int    arm_debugger_arg_offset\t\tPROTO ((int, rtx));\n+extern void   arm_final_prescan_insn\t\tPROTO ((rtx));\n+extern rtx    arm_gen_load_multiple\t\tPROTO ((int, int, rtx, int, int, int, int, int));\n+extern int    arm_gen_movstrqi\t\t\tPROTO ((rtx *));\n+extern rtx    arm_gen_store_multiple\t\tPROTO ((int, int, rtx, int, int, int, int, int));\n+extern void   arm_print_operand\t\t\tPROTO ((FILE *, rtx, int));\n+extern void   arm_reload_in_hi\t\t\tPROTO ((rtx *));\n+extern void   arm_reload_out_hi\t\t\tPROTO ((rtx *));\n+extern void   arm_reorg\t\t\t\tPROTO ((rtx));\n+extern int    arm_rtx_costs\t\t\tPROTO ((rtx, RTX_CODE));\n+extern Mmode  arm_select_cc_mode \t\tPROTO ((RTX_CODE, rtx, rtx));\n+extern int    const_double_rtx_ok_for_fpu\tPROTO ((rtx));\n+extern int    const_ok_for_arm\t\t\tPROTO ((HOST_WIDE_INT));\n+extern char * emit_ldm_seq\t\t\tPROTO ((rtx *, int));\n+extern char * emit_stm_seq\t\t\tPROTO ((rtx *, int));\n+extern char * fp_immediate_constant\t\tPROTO ((rtx));\n+extern rtx    gen_compare_reg\t\t\tPROTO ((RTX_CODE, rtx, rtx));\n+extern rtx    gen_rotated_half_load\t\tPROTO ((rtx));\n+extern int    is_pic\t\t\t\tPROTO ((rtx));\n+extern int    label_mentioned_p \t\tPROTO ((rtx));\n+extern int    legitimate_pic_operand_p\t\tPROTO ((rtx));\n+extern int    load_multiple_sequence\t\tPROTO ((rtx *, int, int *, int *, HOST_WIDE_INT *));\n+extern RTX_CODE minmax_code\t\t\tPROTO ((rtx));\n+extern int    neg_const_double_rtx_ok_for_fpu\tPROTO ((rtx));\n+extern char * output_add_immediate\t\tPROTO ((rtx *));\n+extern char * output_call\t\t\tPROTO ((rtx *));\n+extern char * output_call_mem\t\t\tPROTO ((rtx *));\n+extern char * output_mov_double_arm_from_fpu    PROTO ((rtx *));\n+extern char * output_mov_double_fpu_from_arm    PROTO ((rtx *));\n+extern char * output_mov_immediate\t\tPROTO ((rtx *));\n+extern char * output_mov_long_double_arm_from_arm PROTO ((rtx *));\n+extern char * output_mov_long_double_arm_from_fpu PROTO ((rtx *));\n+extern char * output_mov_long_double_fpu_from_arm PROTO ((rtx *));\n+extern char * output_move_double\t\tPROTO ((rtx *));\n+extern char * output_return_instruction\t\tPROTO ((rtx, int, int));\n+extern int    store_multiple_sequence\t\tPROTO ((rtx *, int, int *, int *, HOST_WIDE_INT *));\n+extern int    symbol_mentioned_p\t\tPROTO ((rtx));\n+#if defined AOF_ASSEMBLER \n+extern rtx    aof_pic_entry\t\t\tPROTO ((rtx));\n+#endif /* AOF_ASSEMBLER */\n+\n+#ifdef HAVE_MACHINE_MODES\n+extern int    alignable_memory_operand\t\tPROTO ((rtx, Mmode));\n+extern int    arm_add_operand\t\t\tPROTO ((rtx, Mmode));\n+extern int    arm_go_if_legitimate_address \tPROTO ((Mmode, rtx));\n+extern int    arm_not_operand\t\t\tPROTO ((rtx, Mmode));\n+extern int    arm_reload_memory_operand\t\tPROTO ((rtx, Mmode));\n+extern int    arm_rhs_operand\t\t\tPROTO ((rtx, Mmode));\n+extern int    arm_rhsm_operand\t\t\tPROTO ((rtx, Mmode));\n+extern Mmode  arm_select_cc_mode \t\tPROTO ((RTX_CODE, rtx, rtx));\n+extern int    arm_split_constant\t\tPROTO ((RTX_CODE, Mmode, HOST_WIDE_INT, rtx, rtx, int));\n+extern int    bad_signed_byte_operand\t\tPROTO ((rtx, Mmode));\n+extern int    cc_register\t\t\tPROTO ((rtx, Mmode));\n+extern int    const_shift_operand\t\tPROTO ((rtx, Mmode));\n+extern int    di_operand\t\t\tPROTO ((rtx, Mmode));\n+extern int    dominant_cc_register\t\tPROTO ((rtx, Mmode));\n+extern int    equality_operator\t\t\tPROTO ((rtx, Mmode));\n+extern int    f_register_operand\t\tPROTO ((rtx, Mmode));\n+extern int    fpu_add_operand\t\t\tPROTO ((rtx, Mmode));\n+extern int    fpu_rhs_operand\t\t\tPROTO ((rtx, Mmode));\n+extern int    index_operand\t\t\tPROTO ((rtx, Mmode));\n+extern rtx    legitimize_pic_address\t\tPROTO ((rtx, Mmode, rtx));\n+extern int    load_multiple_operation\t\tPROTO ((rtx, Mmode));\n+extern int    logical_binary_operator\t\tPROTO ((rtx, Mmode));\n+extern int    minmax_operator\t\t\tPROTO ((rtx, Mmode));\n+extern int    multi_register_push\t\tPROTO ((rtx, Mmode));\n+extern int    nonimmediate_di_operand\t\tPROTO ((rtx, Mmode));\n+extern int    nonimmediate_soft_df_operand \tPROTO ((rtx, Mmode));\n+extern int    offsettable_memory_operand \tPROTO ((rtx, Mmode));\n+extern int    power_of_two_operand\t\tPROTO ((rtx, Mmode));\n+extern int    reg_or_int_operand\t\tPROTO ((rtx, Mmode));\n+extern int    s_register_operand\t\tPROTO ((rtx, Mmode));\n+extern int    shift_operator\t\t\tPROTO ((rtx, Mmode));\n+extern int    shiftable_operator\t\tPROTO ((rtx, Mmode));\n+extern int    soft_df_operand\t\t\tPROTO ((rtx, Mmode));\n+extern int    store_multiple_operation\t\tPROTO ((rtx, Mmode));\n+#if defined TREE_CODE\n+extern rtx    arm_function_arg\t\t\tPROTO ((CUMULATIVE_ARGS *, Mmode, tree, int));\n+extern void   arm_init_cumulative_args\t\tPROTO ((CUMULATIVE_ARGS *, tree, rtx, int));\n+#endif /* TREE_CODE */\n+#endif /* HAVE_MACHINE_MODES */\n+#endif /* RTX_CODE */\n+\n+#undef Mmode"}, {"sha": "9429d2c46ef94f41d586e6fbdbab8aa6ff3a3df1", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb3921e89a276761fba9562652ec83cbe03f25a9/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb3921e89a276761fba9562652ec83cbe03f25a9/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=eb3921e89a276761fba9562652ec83cbe03f25a9", "patch": "@@ -40,6 +40,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"toplev.h\"\n #include \"recog.h\"\n #include \"ggc.h\"\n+#include \"arm-protos.h\"\n \n /* The maximum number of insns skipped which will be conditionalised if\n    possible.  */\n@@ -48,32 +49,32 @@ static int max_insns_skipped = 5;\n extern FILE * asm_out_file;\n /* Some function declarations.  */\n \n-static HOST_WIDE_INT int_log2 PROTO ((HOST_WIDE_INT));\n-static char * output_multi_immediate PROTO ((rtx *, char *, char *, int,\n-\t\t\t\t\t    HOST_WIDE_INT));\n-static int arm_gen_constant PROTO ((enum rtx_code, enum machine_mode,\n-\t\t\t\t    HOST_WIDE_INT, rtx, rtx, int, int));\n-static int arm_naked_function_p PROTO ((tree));\n-static void init_fpa_table PROTO ((void));\n-static enum machine_mode select_dominance_cc_mode PROTO ((rtx, rtx,\n-\t\t\t\t\t\t\t  HOST_WIDE_INT));\n-static HOST_WIDE_INT add_minipool_constant PROTO ((rtx, enum machine_mode));\n-static void dump_minipool PROTO ((rtx));\n-static rtx find_barrier PROTO ((rtx, int));\n-static void push_minipool_fix PROTO ((rtx, int, rtx *, enum machine_mode,\n-\t\t\t\t      rtx));\n-static void push_minipool_barrier PROTO ((rtx, int));\n-static void note_invalid_constants PROTO ((rtx, int));\n-static char * fp_const_from_val PROTO ((REAL_VALUE_TYPE *));\n-static int eliminate_lr2ip PROTO ((rtx *));\n-static char * shift_op PROTO ((rtx, HOST_WIDE_INT *));\n-static int pattern_really_clobbers_lr PROTO ((rtx));\n-static int function_really_clobbers_lr PROTO ((rtx));\n-static void emit_multi_reg_push PROTO ((int));\n-static void emit_sfm PROTO ((int, int));\n+#ifndef Mmode\n+#define Mmode enum machine_mode\n+#endif\n+\n+static HOST_WIDE_INT int_log2 \t\tPROTO ((HOST_WIDE_INT));\n+static char * output_multi_immediate \tPROTO ((rtx *, char *, char *, int, HOST_WIDE_INT));\n+static int arm_gen_constant \t\tPROTO ((enum rtx_code, Mmode, HOST_WIDE_INT, rtx, rtx, int, int));\n+static int arm_naked_function_p \tPROTO ((tree));\n+static void init_fpa_table \t\tPROTO ((void));\n+static enum machine_mode select_dominance_cc_mode PROTO ((rtx, rtx, HOST_WIDE_INT));\n+static HOST_WIDE_INT add_minipool_constant PROTO ((rtx, Mmode));\n+static void dump_minipool \t\tPROTO ((rtx));\n+static rtx find_barrier \t\tPROTO ((rtx, int));\n+static void push_minipool_fix \t\tPROTO ((rtx, int, rtx *, Mmode, rtx));\n+static void push_minipool_barrier \tPROTO ((rtx, int));\n+static void note_invalid_constants \tPROTO ((rtx, int));\n+static char * fp_const_from_val \tPROTO ((REAL_VALUE_TYPE *));\n+static int eliminate_lr2ip \t\tPROTO ((rtx *));\n+static char * shift_op \t\t\tPROTO ((rtx, HOST_WIDE_INT *));\n+static int pattern_really_clobbers_lr \tPROTO ((rtx));\n+static int function_really_clobbers_lr \tPROTO ((rtx));\n+static void emit_multi_reg_push \tPROTO ((int));\n+static void emit_sfm \t\t\tPROTO ((int, int));\n static enum arm_cond_code get_arm_condition_code PROTO ((rtx));\n-static int const_ok_for_op RTX_CODE_PROTO ((HOST_WIDE_INT, Rcode));\n-static void arm_add_gc_roots PROTO ((void));\n+static int const_ok_for_op \t\tPROTO ((HOST_WIDE_INT, enum rtx_code));\n+static void arm_add_gc_roots \t\tPROTO ((void));\n \n /* True if we are currently building a constant table. */\n int making_const_table;\n@@ -5928,8 +5929,7 @@ arm_output_epilogue ()\n }\n \n void\n-output_func_epilogue (f, frame_size)\n-     FILE *f ATTRIBUTE_UNUSED;\n+output_func_epilogue (frame_size)\n      int frame_size;\n {\n   if (use_return_insn (FALSE) && return_used_this_function"}, {"sha": "a7ecbb508393f2309e8cbd7ef716c5f16ba5af67", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 1, "deletions": 153, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb3921e89a276761fba9562652ec83cbe03f25a9/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb3921e89a276761fba9562652ec83cbe03f25a9/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=eb3921e89a276761fba9562652ec83cbe03f25a9", "patch": "@@ -1275,7 +1275,7 @@ enum reg_class\n \n /* Generate the assembly code for function exit. */\n #define FUNCTION_EPILOGUE(STREAM, SIZE)  \\\n-  output_func_epilogue (STREAM, SIZE)\n+  output_func_epilogue (SIZE)\n \n /* Determine if the epilogue should be output as RTL.\n    You should override this if you define FUNCTION_EXTRA_EPILOGUE.  */\n@@ -2200,156 +2200,4 @@ extern struct rtx_def * arm_compare_op1;\n      when running in 32 bit mode.  */\t\t\t\t\t\\\n   ((!TARGET_APCS_32) ? (GEN_INT (0x03fffffc)) : (GEN_INT (0xffffffff)))\n \n-/* The remainder of this file is only needed for building the compiler \n-   itself, not for the collateral.  */\n-#ifdef HAVE_CONFIG_H\n-\n-/* Prototypes for functions in arm.c  */\n-\n-#ifdef BUFSIZ\t\t/* stdio.h has been included, ok to use FILE * */\n-#define STDIO_PROTO(ARGS) PROTO (ARGS)\n-#else\n-#define STDIO_PROTO(ARGS) ()\n-#endif\n-\n-#ifndef TREE_CODE\n-union tree_node;\n-#define Tree union tree_node *\n-#else\n-#define Tree tree\n-#endif\n-\n-#ifndef RTX_CODE\n-struct rtx_def;\n-#define Rtx struct rtx_def *\n-#else\n-#define Rtx rtx\n-#endif\n-\n-#ifndef HOST_WIDE_INT\n-#include \"hwint.h\"\n-#endif\n-\n-\n-#ifndef HAVE_MACHINE_MODES\n-#include \"machmode.h\"\n-#endif\n-\n-#define Mmode enum machine_mode\n-\n-#ifdef RTX_CODE\n-#define RTX_CODE_PROTO(ARGS) PROTO (ARGS)\n-#else\n-#define RTX_CODE_PROTO(ARGS) ()\n-#endif\n-\n-#define Rcode enum rtx_code\n-\n-void   arm_override_options PROTO ((void));\n-int    use_return_insn PROTO ((int));\n-int    const_ok_for_arm PROTO ((HOST_WIDE_INT));\n-int    arm_split_constant RTX_CODE_PROTO ((Rcode, Mmode, HOST_WIDE_INT, Rtx,\n-\t\t\t\t\t   Rtx, int));\n-Rcode  arm_canonicalize_comparison RTX_CODE_PROTO ((Rcode,  Rtx *));\n-int    arm_return_in_memory PROTO ((Tree));\n-int    legitimate_pic_operand_p PROTO ((Rtx));\n-Rtx    legitimize_pic_address PROTO ((Rtx, Mmode, Rtx));\n-int    is_pic PROTO ((Rtx));\n-void   arm_finalize_pic PROTO ((void));\n-int    arm_rtx_costs RTX_CODE_PROTO ((Rtx, Rcode));\n-int    arm_adjust_cost PROTO ((Rtx, Rtx, Rtx, int));\n-int    const_double_rtx_ok_for_fpu PROTO ((Rtx));\n-int    neg_const_double_rtx_ok_for_fpu PROTO ((Rtx));\n-int    s_register_operand PROTO ((Rtx, Mmode));\n-int    f_register_operand PROTO ((Rtx, Mmode));\n-int    reg_or_int_operand PROTO ((Rtx, Mmode));\n-int    reload_memory_operand PROTO ((Rtx, Mmode));\n-int    arm_rhs_operand PROTO ((Rtx, Mmode));\n-int    arm_rhsm_operand PROTO ((Rtx, Mmode));\n-int    arm_add_operand PROTO ((Rtx, Mmode));\n-int    arm_not_operand PROTO ((Rtx, Mmode));\n-int    offsettable_memory_operand PROTO ((Rtx, Mmode));\n-int    alignable_memory_operand PROTO ((Rtx, Mmode));\n-int    bad_signed_byte_operand PROTO ((Rtx, Mmode));\n-int    fpu_rhs_operand PROTO ((Rtx, Mmode));\n-int    fpu_add_operand PROTO ((Rtx, Mmode));\n-int    power_of_two_operand PROTO ((Rtx, Mmode));\n-int    di_operand PROTO ((Rtx, Mmode));\n-int    soft_df_operand PROTO ((Rtx, Mmode));\n-int    index_operand PROTO ((Rtx, Mmode));\n-int    const_shift_operand PROTO ((Rtx, Mmode));\n-int    shiftable_operator PROTO ((Rtx, Mmode));\n-int    logical_binary_operator PROTO ((Rtx, Mmode));\n-int    shift_operator PROTO ((Rtx, Mmode));\n-int    equality_operator PROTO ((Rtx, Mmode));\n-int    minmax_operator PROTO ((Rtx, Mmode));\n-int    cc_register PROTO ((Rtx, Mmode));\n-int    dominant_cc_register PROTO ((Rtx, Mmode));\n-int    symbol_mentioned_p PROTO ((Rtx));\n-int    label_mentioned_p PROTO ((Rtx));\n-Rcode  minmax_code PROTO ((Rtx));\n-int    adjacent_mem_locations PROTO ((Rtx, Rtx));\n-int    load_multiple_operation PROTO ((Rtx, Mmode));\n-int    store_multiple_operation PROTO ((Rtx, Mmode));\n-int    load_multiple_sequence PROTO ((Rtx *, int, int *, int *,\n-\t\t\t\t      HOST_WIDE_INT *));\n-char * emit_ldm_seq PROTO ((Rtx *, int));\n-int    store_multiple_sequence PROTO ((Rtx *, int, int *, int *,\n-\t\t\t\t       HOST_WIDE_INT *));\n-char * emit_stm_seq PROTO ((Rtx *, int));\n-int    arm_valid_machine_decl_attribute PROTO ((Tree, Tree, Tree));\n-Rtx    arm_gen_load_multiple PROTO ((int, int, Rtx, int, int, int, int, int));\n-Rtx    arm_gen_store_multiple PROTO ((int, int, Rtx, int, int, int, int, int));\n-int    arm_gen_movstrqi PROTO ((Rtx *));\n-Rtx    gen_rotated_half_load PROTO ((Rtx));\n-Mmode  arm_select_cc_mode RTX_CODE_PROTO ((Rcode, Rtx, Rtx));\n-Rtx    gen_compare_reg RTX_CODE_PROTO ((Rcode, Rtx, Rtx, int));\n-void   arm_reload_in_hi PROTO ((Rtx *));\n-void   arm_reload_out_hi PROTO ((Rtx *));\n-void   arm_reorg PROTO ((Rtx));\n-char * fp_immediate_constant PROTO ((Rtx));\n-void   print_multi_reg STDIO_PROTO ((FILE *, char *, int, int));\n-char * output_call PROTO ((Rtx *));\n-char * output_call_mem PROTO ((Rtx *));\n-char * output_mov_long_double_fpu_from_arm PROTO ((Rtx *));\n-char * output_mov_long_double_arm_from_fpu PROTO ((Rtx *));\n-char * output_mov_long_double_arm_from_arm PROTO ((Rtx *));\n-char * output_mov_double_fpu_from_arm PROTO ((Rtx *));\n-char * output_mov_double_arm_from_fpu PROTO ((Rtx *));\n-char * output_move_double PROTO ((Rtx *));\n-char * output_mov_immediate PROTO ((Rtx *));\n-char * output_add_immediate PROTO ((Rtx *));\n-char * arithmetic_instr PROTO ((Rtx, int));\n-void   output_ascii_pseudo_op STDIO_PROTO ((FILE *, unsigned char *, int));\n-char * output_return_instruction PROTO ((Rtx, int, int));\n-int    arm_volatile_func PROTO ((void));\n-void   arm_poke_function_name STDIO_PROTO ((FILE *, char *));\n-void   output_func_prologue STDIO_PROTO ((FILE *, int));\n-void   output_func_epilogue STDIO_PROTO ((FILE *, int));\n-void   arm_expand_prologue PROTO ((void));\n-char * arm_output_epilogue PROTO ((void));\n-void   arm_print_operand STDIO_PROTO ((FILE *, Rtx, int));\n-void   arm_final_prescan_insn PROTO ((Rtx));\n-int    short_branch PROTO ((int, int));\n-void   assemble_align PROTO((int)); /* Used in arm.md, but defined in output.c */\n-int    multi_register_push PROTO ((Rtx, Mmode));\n-#ifdef AOF_ASSEMBLER\n-Rtx    aof_pic_entry PROTO ((Rtx));\n-void   aof_dump_pic_table STDIO_PROTO ((FILE *));\n-char * aof_text_section PROTO ((void));\n-char * aof_data_section PROTO ((void));\n-void   aof_add_import PROTO ((char *));\n-void   aof_delete_import PROTO ((char *));\n-void   aof_dump_imports STDIO_PROTO ((FILE *));\n-#endif\n-\n-/* Define in pe.c */\n-int   arm_pe_return_in_memory PROTO ((Tree));\n-int   arm_dllexport_p PROTO ((Tree));\n-int   arm_dllimport_p PROTO ((Tree));\n-int   arm_dllexport_name_p PROTO ((char *));\n-int   arm_dllimport_name_p PROTO ((char *));\n-\n-#endif /* HAVE_CONFIG_H */\n-\n #endif /* __ARM_H__ */"}, {"sha": "978c296c40e274b9bcf4cc82499e256b05c7ba6e", "filename": "gcc/config/arm/pe.h", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb3921e89a276761fba9562652ec83cbe03f25a9/gcc%2Fconfig%2Farm%2Fpe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb3921e89a276761fba9562652ec83cbe03f25a9/gcc%2Fconfig%2Farm%2Fpe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fpe.h?ref=eb3921e89a276761fba9562652ec83cbe03f25a9", "patch": "@@ -89,7 +89,6 @@ Boston, MA 02111-1307, USA.  */\n /* A C expression whose value is nonzero if IDENTIFIER with arguments ARGS\n    is a valid machine specific attribute for DECL.\n    The attributes in ATTRIBUTES have previously been assigned to DECL.  */\n-extern int arm_pe_valid_machine_decl_attribute ();\n #undef  VALID_MACHINE_DECL_ATTRIBUTE\n #define VALID_MACHINE_DECL_ATTRIBUTE(DECL, ATTRIBUTES, IDENTIFIER, ARGS) \\\n arm_pe_valid_machine_decl_attribute (DECL, ATTRIBUTES, IDENTIFIER, ARGS)\n@@ -99,12 +98,10 @@ arm_pe_valid_machine_decl_attribute (DECL, ATTRIBUTES, IDENTIFIER, ARGS)\n    TYPE1 and TYPE2 are incompatible, one if they are compatible,\n    and two if they are nearly compatible (which causes a warning to be\n    generated).  */\n-extern int arm_pe_comp_type_attributes ();\n #define COMP_TYPE_ATTRIBUTES(TYPE1, TYPE2) \\\n arm_pe_comp_type_attributes ((TYPE1), (TYPE2))\n #endif\n \n-extern union tree_node *arm_pe_merge_machine_decl_attributes ();\n #define MERGE_MACHINE_DECL_ATTRIBUTES(OLD, NEW) \\\n arm_pe_merge_machine_decl_attributes ((OLD), (NEW))\n \n@@ -115,7 +112,6 @@ arm_pe_merge_machine_decl_attributes ((OLD), (NEW))\n    This is also needed to implement one-only vtables: they go into their own\n    section and we need to set DECL_SECTION_NAME so we do that here.\n    Note that we can be called twice on the same decl.  */\n-extern void arm_pe_encode_section_info ();\n #undef  ENCODE_SECTION_INFO\n #define ENCODE_SECTION_INFO(DECL) \\\n arm_pe_encode_section_info (DECL)\n@@ -149,7 +145,7 @@ arm_pe_encode_section_info (DECL)\n #define MULTIPLE_SYMBOL_SPACES\n \n #define UNIQUE_SECTION_P(DECL) DECL_ONE_ONLY (DECL)\n-extern void arm_pe_unique_section ();\n+\n #define UNIQUE_SECTION(DECL,RELOC) arm_pe_unique_section (DECL, RELOC)\n \n #define SUPPORTS_ONE_ONLY 1"}]}