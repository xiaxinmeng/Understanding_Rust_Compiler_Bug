{"sha": "e5f14571a8c82e5a3a627e40a480c62e504d9f1e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTVmMTQ1NzFhOGM4MmU1YTNhNjI3ZTQwYTQ4MGM2MmU1MDRkOWYxZQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@redhat.com", "date": "2004-08-25T19:18:22Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2004-08-25T19:18:22Z"}, "message": "mips.md (any_shift): New code macro.\n\n\t* config/mips/mips.md (any_shift): New code macro.\n\t(optab, insn): New code attributes.\n\t({ashl,ashr,lshr}[sd]i3): Redefine using :GPR and any_shift.\n\tUse the standard rather than internal patterns for the MIPS16\n\tdouble-shift optimization.\n\t(*{ashl,ashr,lshr}[sd]i3): New names for the non-mips16 shift patterns.\n\tRedefine using :GPR and any_shift.\n\t(*{ashl,ashr,lshr}si3_extend): Generalize ashlsi3_internal1_extend\n\tto cover all three shifts.\n\t(*{ashl,ashr,lshr}si3_mips16): New names for the mips16 SImode shifts.\n\tRedefine using any_shift.  Use :GPR and any_shift to combine splitters.\n\t(*{ashl,ashr,lshr}di3_mips16): New names for the mips16 DImode shifts.\n\nFrom-SVN: r86566", "tree": {"sha": "5abfaa699a4662e46516b45897e35a6dca9e4030", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5abfaa699a4662e46516b45897e35a6dca9e4030"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e5f14571a8c82e5a3a627e40a480c62e504d9f1e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5f14571a8c82e5a3a627e40a480c62e504d9f1e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e5f14571a8c82e5a3a627e40a480c62e504d9f1e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5f14571a8c82e5a3a627e40a480c62e504d9f1e/comments", "author": null, "committer": null, "parents": [{"sha": "769cf6cd9d267369dc8fb959a84813f620f5cf54", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/769cf6cd9d267369dc8fb959a84813f620f5cf54", "html_url": "https://github.com/Rust-GCC/gccrs/commit/769cf6cd9d267369dc8fb959a84813f620f5cf54"}], "stats": {"total": 526, "additions": 99, "deletions": 427}, "files": [{"sha": "27c859fb726c097849ed8f4004fc2074662ce488", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5f14571a8c82e5a3a627e40a480c62e504d9f1e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5f14571a8c82e5a3a627e40a480c62e504d9f1e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e5f14571a8c82e5a3a627e40a480c62e504d9f1e", "patch": "@@ -1,3 +1,18 @@\n+2004-08-25  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t* config/mips/mips.md (any_shift): New code macro.\n+\t(optab, insn): New code attributes.\n+\t({ashl,ashr,lshr}[sd]i3): Redefine using :GPR and any_shift.\n+\tUse the standard rather than internal patterns for the MIPS16\n+\tdouble-shift optimization.\n+\t(*{ashl,ashr,lshr}[sd]i3): New names for the non-mips16 shift patterns.\n+\tRedefine using :GPR and any_shift.\n+\t(*{ashl,ashr,lshr}si3_extend): Generalize ashlsi3_internal1_extend\n+\tto cover all three shifts.\n+\t(*{ashl,ashr,lshr}si3_mips16): New names for the mips16 SImode shifts.\n+\tRedefine using any_shift.  Use :GPR and any_shift to combine splitters.\n+\t(*{ashl,ashr,lshr}di3_mips16): New names for the mips16 DImode shifts.\n+\n 2004-08-24  Geoffrey Keating  <geoffk@apple.com>\n \n \t* gimplify.c (lookup_tmp_var): Separate temporaries when not"}, {"sha": "7f1af4657f6f5c3dea8caf00e715226a8299b18e", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 84, "deletions": 427, "changes": 511, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5f14571a8c82e5a3a627e40a480c62e504d9f1e/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5f14571a8c82e5a3a627e40a480c62e504d9f1e/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=e5f14571a8c82e5a3a627e40a480c62e504d9f1e", "patch": "@@ -323,12 +323,26 @@\n ;; to use the same template.\n (define_code_macro any_extend [sign_extend zero_extend])\n \n+;; This code macro allows the three shift instructions to be generated\n+;; from the same template.\n+(define_code_macro any_shift [ashift ashiftrt lshiftrt])\n+\n ;; <u> expands to an empty string when doing a signed operation and\n ;; \"u\" when doing an unsigned operation.\n (define_code_attr u [(sign_extend \"\") (zero_extend \"u\")])\n \n ;; <su> is like <u>, but the signed form expands to \"s\" rather than \"\".\n (define_code_attr su [(sign_extend \"s\") (zero_extend \"u\")])\n+\n+;; <optab> expands to the name of the optab for a particular code.\n+(define_code_attr optab [(ashift \"ashl\")\n+\t\t\t (ashiftrt \"ashr\")\n+\t\t\t (lshiftrt \"lshr\")])\n+\n+;; <insn> expands to the name of the insn that implements a particular code.\n+(define_code_attr insn [(ashift \"sll\")\n+\t\t\t(ashiftrt \"sra\")\n+\t\t\t(lshiftrt \"srl\")])\n \f\n ;; .........................\n ;;\n@@ -4217,13 +4231,10 @@ beq\\t%2,%.,1b\\;\\\n ;;\n ;;  ....................\n \n-;; Many of these instructions use trivial define_expands, because we\n-;; want to use a different set of constraints when TARGET_MIPS16.\n-\n-(define_expand \"ashlsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\")\n-\t(ashift:SI (match_operand:SI 1 \"register_operand\")\n-\t\t   (match_operand:SI 2 \"arith_operand\")))]\n+(define_expand \"<optab><mode>3\"\n+  [(set (match_operand:GPR 0 \"register_operand\")\n+\t(any_shift:GPR (match_operand:GPR 1 \"register_operand\")\n+\t\t       (match_operand:SI 2 \"arith_operand\")))]\n   \"\"\n {\n   /* On the mips16, a shift of more than 8 is a four byte instruction,\n@@ -4238,129 +4249,71 @@ beq\\t%2,%.,1b\\;\\\n       && GET_CODE (operands[2]) == CONST_INT\n       && INTVAL (operands[2]) > 8\n       && INTVAL (operands[2]) <= 16\n-      && ! reload_in_progress\n-      && ! reload_completed)\n+      && !reload_in_progress\n+      && !reload_completed)\n     {\n-      rtx temp = gen_reg_rtx (SImode);\n+      rtx temp = gen_reg_rtx (<MODE>mode);\n \n-      emit_insn (gen_ashlsi3_internal2 (temp, operands[1], GEN_INT (8)));\n-      emit_insn (gen_ashlsi3_internal2 (operands[0], temp,\n-\t\t\t\t\tGEN_INT (INTVAL (operands[2]) - 8)));\n+      emit_insn (gen_<optab><mode>3 (temp, operands[1], GEN_INT (8)));\n+      emit_insn (gen_<optab><mode>3 (operands[0], temp,\n+\t\t\t\t     GEN_INT (INTVAL (operands[2]) - 8)));\n       DONE;\n     }\n })\n \n-(define_insn \"ashlsi3_internal1\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(ashift:SI (match_operand:SI 1 \"register_operand\" \"d\")\n-\t\t   (match_operand:SI 2 \"arith_operand\" \"dI\")))]\n+(define_insn \"*<optab><mode>3\"\n+  [(set (match_operand:GPR 0 \"register_operand\" \"=d\")\n+\t(any_shift:GPR (match_operand:GPR 1 \"register_operand\" \"d\")\n+\t\t       (match_operand:SI 2 \"arith_operand\" \"dI\")))]\n   \"!TARGET_MIPS16\"\n {\n   if (GET_CODE (operands[2]) == CONST_INT)\n-    operands[2] = GEN_INT (INTVAL (operands[2]) & 0x1f);\n+    operands[2] = GEN_INT (INTVAL (operands[2])\n+\t\t\t   & (GET_MODE_BITSIZE (<MODE>mode) - 1));\n \n-  return \"sll\\t%0,%1,%2\";\n+  return \"<d><insn>\\t%0,%1,%2\";\n }\n-  [(set_attr \"type\"\t\"shift\")\n-   (set_attr \"mode\"\t\"SI\")])\n+  [(set_attr \"type\" \"shift\")\n+   (set_attr \"mode\" \"<MODE>\")])\n \n-(define_insn \"ashlsi3_internal1_extend\"\n+(define_insn \"*<optab>si3_extend\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n-       (sign_extend:DI (ashift:SI (match_operand:SI 1 \"register_operand\" \"d\")\n-                                  (match_operand:SI 2 \"arith_operand\" \"dI\"))))]\n+\t(sign_extend:DI\n+\t   (any_shift:SI (match_operand:SI 1 \"register_operand\" \"d\")\n+\t\t\t (match_operand:SI 2 \"arith_operand\" \"dI\"))))]\n   \"TARGET_64BIT && !TARGET_MIPS16\"\n {\n   if (GET_CODE (operands[2]) == CONST_INT)\n     operands[2] = GEN_INT (INTVAL (operands[2]) & 0x1f);\n \n-  return \"sll\\t%0,%1,%2\";\n+  return \"<insn>\\t%0,%1,%2\";\n }\n-  [(set_attr \"type\"    \"shift\")\n-   (set_attr \"mode\"    \"DI\")])\n-\n+  [(set_attr \"type\" \"shift\")\n+   (set_attr \"mode\" \"SI\")])\n \n-(define_insn \"ashlsi3_internal2\"\n+(define_insn \"*<optab>si3_mips16\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d,d\")\n-\t(ashift:SI (match_operand:SI 1 \"register_operand\" \"0,d\")\n-\t\t   (match_operand:SI 2 \"arith_operand\" \"d,I\")))]\n+\t(any_shift:SI (match_operand:SI 1 \"register_operand\" \"0,d\")\n+\t\t      (match_operand:SI 2 \"arith_operand\" \"d,I\")))]\n   \"TARGET_MIPS16\"\n {\n   if (which_alternative == 0)\n-    return \"sll\\t%0,%2\";\n-\n-  if (GET_CODE (operands[2]) == CONST_INT)\n-    operands[2] = GEN_INT (INTVAL (operands[2]) & 0x1f);\n+    return \"<insn>\\t%0,%2\";\n \n-  return \"sll\\t%0,%1,%2\";\n+  operands[2] = GEN_INT (INTVAL (operands[2]) & 0x1f);\n+  return \"<insn>\\t%0,%1,%2\";\n }\n-  [(set_attr \"type\"\t\"shift\")\n-   (set_attr \"mode\"\t\"SI\")\n+  [(set_attr \"type\" \"shift\")\n+   (set_attr \"mode\" \"SI\")\n    (set_attr_alternative \"length\"\n \t\t[(const_int 4)\n-\t\t (if_then_else (match_operand:VOID 2 \"m16_uimm3_b\")\n+\t\t (if_then_else (match_operand 2 \"m16_uimm3_b\")\n \t\t\t       (const_int 4)\n \t\t\t       (const_int 8))])])\n \n-;; On the mips16, we can split a 4 byte shift into 2 2 byte shifts.\n-\n-(define_split\n-  [(set (match_operand:SI 0 \"register_operand\")\n-\t(ashift:SI (match_operand:SI 1 \"register_operand\")\n-\t\t   (match_operand:SI 2 \"const_int_operand\")))]\n-  \"TARGET_MIPS16 && reload_completed && !TARGET_DEBUG_D_MODE\n-   && GET_CODE (operands[2]) == CONST_INT\n-   && INTVAL (operands[2]) > 8\n-   && INTVAL (operands[2]) <= 16\"\n-  [(set (match_dup 0) (ashift:SI (match_dup 1) (const_int 8)))\n-   (set (match_dup 0) (ashift:SI (match_dup 0) (match_dup 2)))]\n-  { operands[2] = GEN_INT (INTVAL (operands[2]) - 8); })\n-\n-(define_expand \"ashldi3\"\n-  [(set (match_operand:DI 0 \"register_operand\")\n-\t(ashift:DI (match_operand:DI 1 \"register_operand\")\n-\t\t   (match_operand:SI 2 \"arith_operand\")))]\n-  \"TARGET_64BIT\"\n-{\n-  /* On the mips16, a shift of more than 8 is a four byte\n-     instruction, so, for a shift between 8 and 16, it is just as\n-     fast to do two shifts of 8 or less.  If there is a lot of\n-     shifting going on, we may win in CSE.  Otherwise combine will\n-     put the shifts back together again.  This can be called by\n-     function_arg, so we must be careful not to allocate a new\n-     register if we've reached the reload pass.  */\n-  if (TARGET_MIPS16\n-      && optimize\n-      && GET_CODE (operands[2]) == CONST_INT\n-      && INTVAL (operands[2]) > 8\n-      && INTVAL (operands[2]) <= 16\n-      && ! reload_in_progress\n-      && ! reload_completed)\n-    {\n-      rtx temp = gen_reg_rtx (DImode);\n-\n-      emit_insn (gen_ashldi3_internal (temp, operands[1], GEN_INT (8)));\n-      emit_insn (gen_ashldi3_internal (operands[0], temp,\n-\t\t\t\t       GEN_INT (INTVAL (operands[2]) - 8)));\n-      DONE;\n-    }\n-})\n-\n-\n-(define_insn \"ashldi3_internal\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n-\t(ashift:DI (match_operand:DI 1 \"register_operand\" \"d\")\n-\t\t   (match_operand:SI 2 \"arith_operand\" \"dI\")))]\n-  \"TARGET_64BIT && !TARGET_MIPS16\"\n-{\n-  if (GET_CODE (operands[2]) == CONST_INT)\n-    operands[2] = GEN_INT (INTVAL (operands[2]) & 0x3f);\n-\n-  return \"dsll\\t%0,%1,%2\";\n-}\n-  [(set_attr \"type\"\t\"shift\")\n-   (set_attr \"mode\"\t\"DI\")])\n-\n-(define_insn \"\"\n+;; We need separate DImode MIPS16 patterns because of the irregularity\n+;; of right shifts.\n+(define_insn \"*ashldi3_mips16\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=d,d\")\n \t(ashift:DI (match_operand:DI 1 \"register_operand\" \"0,d\")\n \t\t   (match_operand:SI 2 \"arith_operand\" \"d,I\")))]\n@@ -4369,154 +4322,18 @@ beq\\t%2,%.,1b\\;\\\n   if (which_alternative == 0)\n     return \"dsll\\t%0,%2\";\n \n-  if (GET_CODE (operands[2]) == CONST_INT)\n-    operands[2] = GEN_INT (INTVAL (operands[2]) & 0x3f);\n-\n+  operands[2] = GEN_INT (INTVAL (operands[2]) & 0x3f);\n   return \"dsll\\t%0,%1,%2\";\n }\n-  [(set_attr \"type\"\t\"shift\")\n-   (set_attr \"mode\"\t\"DI\")\n-   (set_attr_alternative \"length\"\n-\t\t[(const_int 4)\n-\t\t (if_then_else (match_operand:VOID 2 \"m16_uimm3_b\")\n-\t\t\t       (const_int 4)\n-\t\t\t       (const_int 8))])])\n-\n-\n-;; On the mips16, we can split a 4 byte shift into 2 2 byte shifts.\n-\n-(define_split\n-  [(set (match_operand:DI 0 \"register_operand\")\n-\t(ashift:DI (match_operand:DI 1 \"register_operand\")\n-\t\t   (match_operand:SI 2 \"const_int_operand\")))]\n-  \"TARGET_MIPS16 && TARGET_64BIT && !TARGET_DEBUG_D_MODE\n-   && reload_completed\n-   && GET_CODE (operands[2]) == CONST_INT\n-   && INTVAL (operands[2]) > 8\n-   && INTVAL (operands[2]) <= 16\"\n-  [(set (match_dup 0) (ashift:DI (match_dup 1) (const_int 8)))\n-   (set (match_dup 0) (ashift:DI (match_dup 0) (match_dup 2)))]\n-  { operands[2] = GEN_INT (INTVAL (operands[2]) - 8); })\n-\n-(define_expand \"ashrsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\")\n-\t(ashiftrt:SI (match_operand:SI 1 \"register_operand\")\n-\t\t     (match_operand:SI 2 \"arith_operand\")))]\n-  \"\"\n-{\n-  /* On the mips16, a shift of more than 8 is a four byte instruction,\n-     so, for a shift between 8 and 16, it is just as fast to do two\n-     shifts of 8 or less.  If there is a lot of shifting going on, we\n-     may win in CSE.  Otherwise combine will put the shifts back\n-     together again.  */\n-  if (TARGET_MIPS16\n-      && optimize\n-      && GET_CODE (operands[2]) == CONST_INT\n-      && INTVAL (operands[2]) > 8\n-      && INTVAL (operands[2]) <= 16)\n-    {\n-      rtx temp = gen_reg_rtx (SImode);\n-\n-      emit_insn (gen_ashrsi3_internal2 (temp, operands[1], GEN_INT (8)));\n-      emit_insn (gen_ashrsi3_internal2 (operands[0], temp,\n-\t\t\t\t\tGEN_INT (INTVAL (operands[2]) - 8)));\n-      DONE;\n-    }\n-})\n-\n-(define_insn \"ashrsi3_internal1\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(ashiftrt:SI (match_operand:SI 1 \"register_operand\" \"d\")\n-\t\t     (match_operand:SI 2 \"arith_operand\" \"dI\")))]\n-  \"!TARGET_MIPS16\"\n-{\n-  if (GET_CODE (operands[2]) == CONST_INT)\n-    operands[2] = GEN_INT (INTVAL (operands[2]) & 0x1f);\n-\n-  return \"sra\\t%0,%1,%2\";\n-}\n-  [(set_attr \"type\"\t\"shift\")\n-   (set_attr \"mode\"\t\"SI\")])\n-\n-(define_insn \"ashrsi3_internal2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d,d\")\n-\t(ashiftrt:SI (match_operand:SI 1 \"register_operand\" \"0,d\")\n-\t\t     (match_operand:SI 2 \"arith_operand\" \"d,I\")))]\n-  \"TARGET_MIPS16\"\n-{\n-  if (which_alternative == 0)\n-    return \"sra\\t%0,%2\";\n-\n-  if (GET_CODE (operands[2]) == CONST_INT)\n-    operands[2] = GEN_INT (INTVAL (operands[2]) & 0x1f);\n-\n-  return \"sra\\t%0,%1,%2\";\n-}\n-  [(set_attr \"type\"\t\"shift\")\n-   (set_attr \"mode\"\t\"SI\")\n+  [(set_attr \"type\" \"shift\")\n+   (set_attr \"mode\" \"DI\")\n    (set_attr_alternative \"length\"\n \t\t[(const_int 4)\n-\t\t (if_then_else (match_operand:VOID 2 \"m16_uimm3_b\")\n+\t\t (if_then_else (match_operand 2 \"m16_uimm3_b\")\n \t\t\t       (const_int 4)\n \t\t\t       (const_int 8))])])\n \n-\n-;; On the mips16, we can split a 4 byte shift into 2 2 byte shifts.\n-\n-(define_split\n-  [(set (match_operand:SI 0 \"register_operand\")\n-\t(ashiftrt:SI (match_operand:SI 1 \"register_operand\")\n-\t\t     (match_operand:SI 2 \"const_int_operand\")))]\n-  \"TARGET_MIPS16 && reload_completed && !TARGET_DEBUG_D_MODE\n-   && GET_CODE (operands[2]) == CONST_INT\n-   && INTVAL (operands[2]) > 8\n-   && INTVAL (operands[2]) <= 16\"\n-  [(set (match_dup 0) (ashiftrt:SI (match_dup 1) (const_int 8)))\n-   (set (match_dup 0) (ashiftrt:SI (match_dup 0) (match_dup 2)))]\n-  { operands[2] = GEN_INT (INTVAL (operands[2]) - 8); })\n-\n-(define_expand \"ashrdi3\"\n-  [(set (match_operand:DI 0 \"register_operand\")\n-\t(ashiftrt:DI (match_operand:DI 1 \"register_operand\")\n-\t\t     (match_operand:SI 2 \"arith_operand\")))]\n-  \"TARGET_64BIT\"\n-{\n-  /* On the mips16, a shift of more than 8 is a four byte\n-     instruction, so, for a shift between 8 and 16, it is just as\n-     fast to do two shifts of 8 or less.  If there is a lot of\n-     shifting going on, we may win in CSE.  Otherwise combine will\n-     put the shifts back together again.  */\n-  if (TARGET_MIPS16\n-      && optimize\n-      && GET_CODE (operands[2]) == CONST_INT\n-      && INTVAL (operands[2]) > 8\n-      && INTVAL (operands[2]) <= 16)\n-    {\n-      rtx temp = gen_reg_rtx (DImode);\n-\n-      emit_insn (gen_ashrdi3_internal (temp, operands[1], GEN_INT (8)));\n-      emit_insn (gen_ashrdi3_internal (operands[0], temp,\n-\t\t\t\t       GEN_INT (INTVAL (operands[2]) - 8)));\n-      DONE;\n-    }\n-})\n-\n-\n-(define_insn \"ashrdi3_internal\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n-\t(ashiftrt:DI (match_operand:DI 1 \"register_operand\" \"d\")\n-\t\t     (match_operand:SI 2 \"arith_operand\" \"dI\")))]\n-  \"TARGET_64BIT && !TARGET_MIPS16\"\n-{\n-  if (GET_CODE (operands[2]) == CONST_INT)\n-    operands[2] = GEN_INT (INTVAL (operands[2]) & 0x3f);\n-\n-  return \"dsra\\t%0,%1,%2\";\n-}\n-  [(set_attr \"type\"\t\"shift\")\n-   (set_attr \"mode\"\t\"DI\")])\n-\n-(define_insn \"\"\n+(define_insn \"*ashrdi3_mips16\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=d,d\")\n \t(ashiftrt:DI (match_operand:DI 1 \"register_operand\" \"0,0\")\n \t\t     (match_operand:SI 2 \"arith_operand\" \"d,I\")))]\n@@ -4527,104 +4344,45 @@ beq\\t%2,%.,1b\\;\\\n \n   return \"dsra\\t%0,%2\";\n }\n-  [(set_attr \"type\"\t\"shift\")\n-   (set_attr \"mode\"\t\"DI\")\n+  [(set_attr \"type\" \"shift\")\n+   (set_attr \"mode\" \"DI\")\n    (set_attr_alternative \"length\"\n \t\t[(const_int 4)\n-\t\t (if_then_else (match_operand:VOID 2 \"m16_uimm3_b\")\n+\t\t (if_then_else (match_operand 2 \"m16_uimm3_b\")\n \t\t\t       (const_int 4)\n \t\t\t       (const_int 8))])])\n \n-;; On the mips16, we can split a 4 byte shift into 2 2 byte shifts.\n-\n-(define_split\n-  [(set (match_operand:DI 0 \"register_operand\")\n-\t(ashiftrt:DI (match_operand:DI 1 \"register_operand\")\n-\t\t     (match_operand:SI 2 \"const_int_operand\")))]\n-  \"TARGET_MIPS16 && TARGET_64BIT && !TARGET_DEBUG_D_MODE\n-   && reload_completed\n-   && GET_CODE (operands[2]) == CONST_INT\n-   && INTVAL (operands[2]) > 8\n-   && INTVAL (operands[2]) <= 16\"\n-  [(set (match_dup 0) (ashiftrt:DI (match_dup 1) (const_int 8)))\n-   (set (match_dup 0) (ashiftrt:DI (match_dup 0) (match_dup 2)))]\n-  { operands[2] = GEN_INT (INTVAL (operands[2]) - 8); })\n-\n-(define_expand \"lshrsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\")\n-\t(lshiftrt:SI (match_operand:SI 1 \"register_operand\")\n-\t\t     (match_operand:SI 2 \"arith_operand\")))]\n-  \"\"\n-{\n-  /* On the mips16, a shift of more than 8 is a four byte instruction,\n-     so, for a shift between 8 and 16, it is just as fast to do two\n-     shifts of 8 or less.  If there is a lot of shifting going on, we\n-     may win in CSE.  Otherwise combine will put the shifts back\n-     together again.  */\n-  if (TARGET_MIPS16\n-      && optimize\n-      && GET_CODE (operands[2]) == CONST_INT\n-      && INTVAL (operands[2]) > 8\n-      && INTVAL (operands[2]) <= 16)\n-    {\n-      rtx temp = gen_reg_rtx (SImode);\n-\n-      emit_insn (gen_lshrsi3_internal2 (temp, operands[1], GEN_INT (8)));\n-      emit_insn (gen_lshrsi3_internal2 (operands[0], temp,\n-\t\t\t\t\tGEN_INT (INTVAL (operands[2]) - 8)));\n-      DONE;\n-    }\n-})\n-\n-(define_insn \"lshrsi3_internal1\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"d\")\n-\t\t     (match_operand:SI 2 \"arith_operand\" \"dI\")))]\n-  \"!TARGET_MIPS16\"\n-{\n-  if (GET_CODE (operands[2]) == CONST_INT)\n-    operands[2] = GEN_INT (INTVAL (operands[2]) & 0x1f);\n-\n-  return \"srl\\t%0,%1,%2\";\n-}\n-  [(set_attr \"type\"\t\"shift\")\n-   (set_attr \"mode\"\t\"SI\")])\n-\n-(define_insn \"lshrsi3_internal2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d,d\")\n-\t(lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"0,d\")\n+(define_insn \"*lshrdi3_mips16\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=d,d\")\n+\t(lshiftrt:DI (match_operand:DI 1 \"register_operand\" \"0,0\")\n \t\t     (match_operand:SI 2 \"arith_operand\" \"d,I\")))]\n-  \"TARGET_MIPS16\"\n+  \"TARGET_64BIT && TARGET_MIPS16\"\n {\n-  if (which_alternative == 0)\n-    return \"srl\\t%0,%2\";\n-\n   if (GET_CODE (operands[2]) == CONST_INT)\n-    operands[2] = GEN_INT (INTVAL (operands[2]) & 0x1f);\n+    operands[2] = GEN_INT (INTVAL (operands[2]) & 0x3f);\n \n-  return \"srl\\t%0,%1,%2\";\n+  return \"dsrl\\t%0,%2\";\n }\n-  [(set_attr \"type\"\t\"shift\")\n-   (set_attr \"mode\"\t\"SI\")\n+  [(set_attr \"type\" \"shift\")\n+   (set_attr \"mode\" \"DI\")\n    (set_attr_alternative \"length\"\n \t\t[(const_int 4)\n-\t\t (if_then_else (match_operand:VOID 2 \"m16_uimm3_b\")\n+\t\t (if_then_else (match_operand 2 \"m16_uimm3_b\")\n \t\t\t       (const_int 4)\n \t\t\t       (const_int 8))])])\n \n-\n ;; On the mips16, we can split a 4 byte shift into 2 2 byte shifts.\n \n (define_split\n-  [(set (match_operand:SI 0 \"register_operand\")\n-\t(lshiftrt:SI (match_operand:SI 1 \"register_operand\")\n-\t\t     (match_operand:SI 2 \"const_int_operand\")))]\n+  [(set (match_operand:GPR 0 \"register_operand\")\n+\t(any_shift:GPR (match_operand:GPR 1 \"register_operand\")\n+\t\t       (match_operand:GPR 2 \"const_int_operand\")))]\n   \"TARGET_MIPS16 && reload_completed && !TARGET_DEBUG_D_MODE\n    && GET_CODE (operands[2]) == CONST_INT\n    && INTVAL (operands[2]) > 8\n    && INTVAL (operands[2]) <= 16\"\n-  [(set (match_dup 0) (lshiftrt:SI (match_dup 1) (const_int 8)))\n-   (set (match_dup 0) (lshiftrt:SI (match_dup 0) (match_dup 2)))]\n+  [(set (match_dup 0) (any_shift:GPR (match_dup 1) (const_int 8)))\n+   (set (match_dup 0) (any_shift:GPR (match_dup 0) (match_dup 2)))]\n   { operands[2] = GEN_INT (INTVAL (operands[2]) - 8); })\n \n ;; If we load a byte on the mips16 as a bitfield, the resulting\n@@ -4650,122 +4408,21 @@ beq\\t%2,%.,1b\\;\\\n    (set_attr \"mode\"\t\"SI\")\n    (set_attr \"length\"\t\"16\")])\n \n-(define_expand \"lshrdi3\"\n-  [(set (match_operand:DI 0 \"register_operand\")\n-\t(lshiftrt:DI (match_operand:DI 1 \"register_operand\")\n-\t\t     (match_operand:SI 2 \"arith_operand\")))]\n-  \"TARGET_64BIT\"\n-{\n-  /* On the mips16, a shift of more than 8 is a four byte\n-     instruction, so, for a shift between 8 and 16, it is just as\n-     fast to do two shifts of 8 or less.  If there is a lot of\n-     shifting going on, we may win in CSE.  Otherwise combine will\n-     put the shifts back together again.  */\n-  if (TARGET_MIPS16\n-      && optimize\n-      && GET_CODE (operands[2]) == CONST_INT\n-      && INTVAL (operands[2]) > 8\n-      && INTVAL (operands[2]) <= 16)\n-    {\n-      rtx temp = gen_reg_rtx (DImode);\n-\n-      emit_insn (gen_lshrdi3_internal (temp, operands[1], GEN_INT (8)));\n-      emit_insn (gen_lshrdi3_internal (operands[0], temp,\n-\t\t\t\t       GEN_INT (INTVAL (operands[2]) - 8)));\n-      DONE;\n-    }\n-})\n-\n-\n-(define_insn \"lshrdi3_internal\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n-\t(lshiftrt:DI (match_operand:DI 1 \"register_operand\" \"d\")\n-\t\t     (match_operand:SI 2 \"arith_operand\" \"dI\")))]\n-  \"TARGET_64BIT && !TARGET_MIPS16\"\n-{\n-  if (GET_CODE (operands[2]) == CONST_INT)\n-    operands[2] = GEN_INT (INTVAL (operands[2]) & 0x3f);\n-\n-  return \"dsrl\\t%0,%1,%2\";\n-}\n-  [(set_attr \"type\"\t\"shift\")\n-   (set_attr \"mode\"\t\"DI\")])\n-\n-(define_insn \"\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=d,d\")\n-\t(lshiftrt:DI (match_operand:DI 1 \"register_operand\" \"0,0\")\n-\t\t     (match_operand:SI 2 \"arith_operand\" \"d,I\")))]\n-  \"TARGET_64BIT && TARGET_MIPS16\"\n-{\n-  if (GET_CODE (operands[2]) == CONST_INT)\n-    operands[2] = GEN_INT (INTVAL (operands[2]) & 0x3f);\n-\n-  return \"dsrl\\t%0,%2\";\n-}\n-  [(set_attr \"type\"\t\"shift\")\n-   (set_attr \"mode\"\t\"DI\")\n-   (set_attr_alternative \"length\"\n-\t\t[(const_int 4)\n-\t\t (if_then_else (match_operand:VOID 2 \"m16_uimm3_b\")\n-\t\t\t       (const_int 4)\n-\t\t\t       (const_int 8))])])\n-\n-(define_insn \"rotrsi3\"\n-  [(set (match_operand:SI              0 \"register_operand\" \"=d\")\n-        (rotatert:SI (match_operand:SI 1 \"register_operand\" \"d\")\n-                     (match_operand:SI 2 \"arith_operand\"    \"dn\")))]\n-  \"ISA_HAS_ROTR_SI\"\n-{\n-  if (TARGET_SR71K && GET_CODE (operands[2]) != CONST_INT)\n-    return \"rorv\\t%0,%1,%2\";\n-\n-  if ((GET_CODE (operands[2]) == CONST_INT)\n-      && (INTVAL (operands[2]) < 0 || INTVAL (operands[2]) >= 32))\n-    abort ();\n-\n-  return \"ror\\t%0,%1,%2\";\n-}\n-  [(set_attr \"type\"     \"shift\")\n-   (set_attr \"mode\"     \"SI\")])\n-\n-(define_insn \"rotrdi3\"\n-  [(set (match_operand:DI              0 \"register_operand\" \"=d\")\n-        (rotatert:DI (match_operand:DI 1 \"register_operand\" \"d\")\n-                     (match_operand:DI 2 \"arith_operand\"    \"dn\")))]\n-  \"ISA_HAS_ROTR_DI\"\n+(define_insn \"rotr<mode>3\"\n+  [(set (match_operand:GPR 0 \"register_operand\" \"=d\")\n+\t(rotatert:GPR (match_operand:GPR 1 \"register_operand\" \"d\")\n+\t\t      (match_operand:SI 2 \"arith_operand\" \"dI\")))]\n+  \"ISA_HAS_ROTR_<MODE>\"\n {\n-  if (TARGET_SR71K)\n-    {\n-      if (GET_CODE (operands[2]) != CONST_INT)\n-\treturn \"drorv\\t%0,%1,%2\";\n-\n-      if (INTVAL (operands[2]) >= 32 && INTVAL (operands[2]) <= 63)\n-\treturn \"dror32\\t%0,%1,%2\";\n-    }\n-\n   if ((GET_CODE (operands[2]) == CONST_INT)\n-      && (INTVAL (operands[2]) < 0 || INTVAL (operands[2]) >= 64))\n+      && (INTVAL (operands[2]) < 0\n+\t  || INTVAL (operands[2]) >= GET_MODE_BITSIZE (<MODE>mode)))\n     abort ();\n \n-  return \"dror\\t%0,%1,%2\";\n+  return \"<d>ror\\t%0,%1,%2\";\n }\n-  [(set_attr \"type\"     \"shift\")\n-   (set_attr \"mode\"     \"DI\")])\n-\n-\n-;; On the mips16, we can split a 4 byte shift into 2 2 byte shifts.\n-\n-(define_split\n-  [(set (match_operand:DI 0 \"register_operand\")\n-\t(lshiftrt:DI (match_operand:DI 1 \"register_operand\")\n-\t\t     (match_operand:SI 2 \"const_int_operand\")))]\n-  \"TARGET_MIPS16 && reload_completed && !TARGET_DEBUG_D_MODE\n-   && GET_CODE (operands[2]) == CONST_INT\n-   && INTVAL (operands[2]) > 8\n-   && INTVAL (operands[2]) <= 16\"\n-  [(set (match_dup 0) (lshiftrt:DI (match_dup 1) (const_int 8)))\n-   (set (match_dup 0) (lshiftrt:DI (match_dup 0) (match_dup 2)))]\n-  { operands[2] = GEN_INT (INTVAL (operands[2]) - 8); })\n+  [(set_attr \"type\" \"shift\")\n+   (set_attr \"mode\" \"<MODE>\")])\n \f\n ;;\n ;;  ...................."}]}