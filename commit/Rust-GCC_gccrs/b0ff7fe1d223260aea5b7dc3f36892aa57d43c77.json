{"sha": "b0ff7fe1d223260aea5b7dc3f36892aa57d43c77", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjBmZjdmZTFkMjIzMjYwYWVhNWI3ZGMzZjM2ODkyYWE1N2Q0M2M3Nw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2014-02-26T17:08:20Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2014-02-26T17:08:20Z"}, "message": "re PR c++/54440 ([c++11] g++ prematurely applying rule that a template parameter pack cannot be followed by a template parameter)\n\n\tPR c++/54440\n\t* pt.c (get_template_parm_index): New.\n\t(fixed_parameter_pack_p_1, fixed_parameter_pack_p): New.\n\t(process_template_parm): Allow bare packs in template template\n\tparm template parms.\n\t(coerce_template_parameter_pack): Handle fixed template template\n\tparm packs and fixed packs not at the end of the parm list.\n\t(coerce_template_parms): Handle template parm packs not at the end\n\tof the parm list.\n\t(gen_elem_of_pack_expansion_instantiation): Handle a decl expansion.\n\nFrom-SVN: r208178", "tree": {"sha": "93a6ef5477c74881949f92fb28e63918dedd14d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/93a6ef5477c74881949f92fb28e63918dedd14d6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b0ff7fe1d223260aea5b7dc3f36892aa57d43c77", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0ff7fe1d223260aea5b7dc3f36892aa57d43c77", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0ff7fe1d223260aea5b7dc3f36892aa57d43c77", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0ff7fe1d223260aea5b7dc3f36892aa57d43c77/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f3417723b7829dda4e795a4cbff2765553667b5a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3417723b7829dda4e795a4cbff2765553667b5a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f3417723b7829dda4e795a4cbff2765553667b5a"}], "stats": {"total": 267, "additions": 208, "deletions": 59}, "files": [{"sha": "f1f1195b7fd7d9fa6f0ace8a0a64a2e4f973e035", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0ff7fe1d223260aea5b7dc3f36892aa57d43c77/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0ff7fe1d223260aea5b7dc3f36892aa57d43c77/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=b0ff7fe1d223260aea5b7dc3f36892aa57d43c77", "patch": "@@ -1,5 +1,16 @@\n 2014-02-26  Jason Merrill  <jason@redhat.com>\n \n+\tPR c++/54440\n+\t* pt.c (get_template_parm_index): New.\n+\t(fixed_parameter_pack_p_1, fixed_parameter_pack_p): New.\n+\t(process_template_parm): Allow bare packs in template template\n+\tparm template parms.\n+\t(coerce_template_parameter_pack): Handle fixed template template\n+\tparm packs and fixed packs not at the end of the parm list.\n+\t(coerce_template_parms): Handle template parm packs not at the end\n+\tof the parm list.\n+\t(gen_elem_of_pack_expansion_instantiation): Handle a decl expansion.\n+\n \tPR c++/60182\n \t* pt.c (unify): Ignore alias templates when deducing a template\n \ttemplate parameter."}, {"sha": "1f5a2b73532d38a18f0d599ffbb5ee6419df8b08", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 174, "deletions": 59, "changes": 233, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0ff7fe1d223260aea5b7dc3f36892aa57d43c77/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0ff7fe1d223260aea5b7dc3f36892aa57d43c77/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=b0ff7fe1d223260aea5b7dc3f36892aa57d43c77", "patch": "@@ -3697,7 +3697,10 @@ process_template_parm (tree list, location_t parm_loc, tree parm,\n \t     return chainon (list, err_parm_list);\n           }\n \n-        if (uses_parameter_packs (TREE_TYPE (parm)) && !is_parameter_pack)\n+        if (uses_parameter_packs (TREE_TYPE (parm)) && !is_parameter_pack\n+\t    /* If we're in a nested template parameter list, the template\n+\t       template parameter could be a parameter pack.  */\n+\t    && processing_template_parmlist == 1)\n \t  {\n \t    /* This template parameter is not a parameter pack, but it\n \t       should be. Complain about \"bare\" parameter packs.  */\n@@ -4326,6 +4329,77 @@ process_partial_specialization (tree decl)\n   return decl;\n }\n \n+/* PARM is a template parameter of some form; return the corresponding\n+   TEMPLATE_PARM_INDEX.  */\n+\n+static tree\n+get_template_parm_index (tree parm)\n+{\n+  if (TREE_CODE (parm) == PARM_DECL\n+      || TREE_CODE (parm) == CONST_DECL)\n+    parm = DECL_INITIAL (parm);\n+  else if (TREE_CODE (parm) == TYPE_DECL\n+\t   || TREE_CODE (parm) == TEMPLATE_DECL)\n+    parm = TREE_TYPE (parm);\n+  if (TREE_CODE (parm) == TEMPLATE_TYPE_PARM\n+      || TREE_CODE (parm) == TEMPLATE_TEMPLATE_PARM)\n+    parm = TEMPLATE_TYPE_PARM_INDEX (parm);\n+  gcc_assert (TREE_CODE (parm) == TEMPLATE_PARM_INDEX);\n+  return parm;\n+}\n+\n+/* Subroutine of fixed_parameter_pack_p below.  Look for any template\n+   parameter packs used by the template parameter PARM.  */\n+\n+static void\n+fixed_parameter_pack_p_1 (tree parm, struct find_parameter_pack_data *ppd)\n+{\n+  /* A type parm can't refer to another parm.  */\n+  if (TREE_CODE (parm) == TYPE_DECL)\n+    return;\n+  else if (TREE_CODE (parm) == PARM_DECL)\n+    {\n+      cp_walk_tree (&TREE_TYPE (parm), &find_parameter_packs_r,\n+\t\t    ppd, ppd->visited);\n+      return;\n+    }\n+\n+  gcc_assert (TREE_CODE (parm) == TEMPLATE_DECL);\n+\n+  tree vec = INNERMOST_TEMPLATE_PARMS (DECL_TEMPLATE_PARMS (parm));\n+  for (int i = 0; i < TREE_VEC_LENGTH (vec); ++i)\n+    fixed_parameter_pack_p_1 (TREE_VALUE (TREE_VEC_ELT (vec, i)), ppd);\n+}\n+\n+/* PARM is a template parameter pack.  Return any parameter packs used in\n+   its type or the type of any of its template parameters.  If there are\n+   any such packs, it will be instantiated into a fixed template parameter\n+   list by partial instantiation rather than be fully deduced.  */\n+\n+tree\n+fixed_parameter_pack_p (tree parm)\n+{\n+  /* This can only be true in a member template.  */\n+  if (TEMPLATE_PARM_ORIG_LEVEL (get_template_parm_index (parm)) < 2)\n+    return NULL_TREE;\n+  /* This can only be true for a parameter pack.  */\n+  if (!template_parameter_pack_p (parm))\n+    return NULL_TREE;\n+  /* A type parm can't refer to another parm.  */\n+  if (TREE_CODE (parm) == TYPE_DECL)\n+    return NULL_TREE;\n+\n+  tree parameter_packs = NULL_TREE;\n+  struct find_parameter_pack_data ppd;\n+  ppd.parameter_packs = &parameter_packs;\n+  ppd.visited = pointer_set_create ();\n+\n+  fixed_parameter_pack_p_1 (parm, &ppd);\n+\n+  pointer_set_destroy (ppd.visited);\n+  return parameter_packs;\n+}\n+\n /* Check that a template declaration's use of default arguments and\n    parameter packs is not invalid.  Here, PARMS are the template\n    parameters.  IS_PRIMARY is true if DECL is the thing declared by\n@@ -4431,7 +4505,10 @@ check_default_tmpl_args (tree decl, tree parms, bool is_primary,\n \t\t       && parm_level == parms\n \t\t       && TREE_CODE (decl) == TYPE_DECL\n \t\t       && i < ntparms - 1\n-\t\t       && template_parameter_pack_p (TREE_VALUE (parm)))\n+\t\t       && template_parameter_pack_p (TREE_VALUE (parm))\n+\t\t       /* A fixed parameter pack will be partially\n+\t\t\t  instantiated into a fixed length list.  */\n+\t\t       && !fixed_parameter_pack_p (TREE_VALUE (parm)))\n \t\t{\n \t\t  /* A primary class template can only have one\n \t\t     parameter pack, at the end of the template\n@@ -6531,77 +6608,73 @@ coerce_template_parameter_pack (tree parms,\n   int nargs = inner_args ? NUM_TMPL_ARGS (inner_args) : 0;\n   tree packed_args;\n   tree argument_pack;\n-  tree packed_types = NULL_TREE;\n+  tree packed_parms = NULL_TREE;\n \n   if (arg_idx > nargs)\n     arg_idx = nargs;\n \n-  packed_args = make_tree_vec (nargs - arg_idx);\n-\n-  if (TREE_CODE (TREE_VALUE (parm)) == PARM_DECL\n-      && uses_parameter_packs (TREE_TYPE (TREE_VALUE (parm))))\n-    {\n-      /* When the template parameter is a non-type template\n-         parameter pack whose type uses parameter packs, we need\n-         to look at each of the template arguments\n-         separately. Build a vector of the types for these\n-         non-type template parameters in PACKED_TYPES.  */\n-      tree expansion \n-        = make_pack_expansion (TREE_TYPE (TREE_VALUE (parm)));\n-      packed_types = tsubst_pack_expansion (expansion, args,\n-                                            complain, in_decl);\n-\n-      if (packed_types == error_mark_node)\n+  if (tree packs = fixed_parameter_pack_p (TREE_VALUE (parm)))\n+    {\n+      /* When the template parameter is a non-type template parameter pack\n+         or template template parameter pack whose type or template\n+         parameters use parameter packs, we know exactly how many arguments\n+         we are looking for.  Build a vector of the instantiated decls for\n+         these template parameters in PACKED_PARMS.  */\n+      /* We can't use make_pack_expansion here because it would interpret a\n+\t _DECL as a use rather than a declaration.  */\n+      tree decl = TREE_VALUE (parm);\n+      tree exp = cxx_make_type (TYPE_PACK_EXPANSION);\n+      SET_PACK_EXPANSION_PATTERN (exp, decl);\n+      PACK_EXPANSION_PARAMETER_PACKS (exp) = packs;\n+      SET_TYPE_STRUCTURAL_EQUALITY (exp);\n+\n+      TREE_VEC_LENGTH (args)--;\n+      packed_parms = tsubst_pack_expansion (exp, args, complain, decl);\n+      TREE_VEC_LENGTH (args)++;\n+\n+      if (packed_parms == error_mark_node)\n         return error_mark_node;\n \n-      /* Check that we have the right number of arguments.  */\n-      if (arg_idx < nargs\n-          && !PACK_EXPANSION_P (TREE_VEC_ELT (inner_args, arg_idx))\n-          && nargs - arg_idx != TREE_VEC_LENGTH (packed_types))\n-        {\n-          int needed_parms \n-            = TREE_VEC_LENGTH (parms) - 1 + TREE_VEC_LENGTH (packed_types);\n-          error (\"wrong number of template arguments (%d, should be %d)\",\n-                 nargs, needed_parms);\n-          return error_mark_node;\n-        }\n-\n-      /* If we aren't able to check the actual arguments now\n-         (because they haven't been expanded yet), we can at least\n+      /* If we're doing a partial instantiation of a member template,\n          verify that all of the types used for the non-type\n          template parameter pack are, in fact, valid for non-type\n          template parameters.  */\n-      if (arg_idx < nargs \n+      if (arg_idx < nargs\n           && PACK_EXPANSION_P (TREE_VEC_ELT (inner_args, arg_idx)))\n         {\n-          int j, len = TREE_VEC_LENGTH (packed_types);\n+          int j, len = TREE_VEC_LENGTH (packed_parms);\n           for (j = 0; j < len; ++j)\n             {\n-              tree t = TREE_VEC_ELT (packed_types, j);\n+              tree t = TREE_TYPE (TREE_VEC_ELT (packed_parms, j));\n               if (invalid_nontype_parm_type_p (t, complain))\n                 return error_mark_node;\n             }\n         }\n+\n+      packed_args = make_tree_vec (TREE_VEC_LENGTH (packed_parms));\n     }\n+  else\n+    packed_args = make_tree_vec (nargs - arg_idx);\n \n   /* Convert the remaining arguments, which will be a part of the\n      parameter pack \"parm\".  */\n   for (; arg_idx < nargs; ++arg_idx)\n     {\n       tree arg = TREE_VEC_ELT (inner_args, arg_idx);\n       tree actual_parm = TREE_VALUE (parm);\n+      int pack_idx = arg_idx - parm_idx;\n \n-      if (packed_types && !PACK_EXPANSION_P (arg))\n+      if (packed_parms)\n         {\n-          /* When we have a vector of types (corresponding to the\n-             non-type template parameter pack that uses parameter\n-             packs in its type, as mention above), and the\n-             argument is not an expansion (which expands to a\n-             currently unknown number of arguments), clone the\n-             parm and give it the next type in PACKED_TYPES.  */\n-          actual_parm = copy_node (actual_parm);\n-          TREE_TYPE (actual_parm) = \n-            TREE_VEC_ELT (packed_types, arg_idx - parm_idx);\n+\t  /* Once we've packed as many args as we have types, stop.  */\n+\t  if (pack_idx >= TREE_VEC_LENGTH (packed_parms))\n+\t    break;\n+\t  else if (PACK_EXPANSION_P (arg))\n+\t    /* We don't know how many args we have yet, just\n+\t       use the unconverted ones for now.  */\n+\t    return NULL_TREE;\n+\t  else\n+\t    actual_parm = TREE_VEC_ELT (packed_parms, pack_idx);\n         }\n \n       if (arg == error_mark_node)\n@@ -6615,7 +6688,15 @@ coerce_template_parameter_pack (tree parms,\n \t\t\t\t\t in_decl);\n       if (arg == error_mark_node)\n         (*lost)++;\n-      TREE_VEC_ELT (packed_args, arg_idx - parm_idx) = arg; \n+      TREE_VEC_ELT (packed_args, pack_idx) = arg;\n+    }\n+\n+  if (arg_idx - parm_idx < TREE_VEC_LENGTH (packed_args)\n+      && TREE_VEC_LENGTH (packed_args) > 0)\n+    {\n+      error (\"wrong number of template arguments (%d, should be %d)\",\n+\t     arg_idx - parm_idx, TREE_VEC_LENGTH (packed_args));\n+      return error_mark_node;\n     }\n \n   if (TREE_CODE (TREE_VALUE (parm)) == TYPE_DECL\n@@ -6676,6 +6757,7 @@ coerce_template_parms (tree parms,\n \t\t       bool use_default_args)\n {\n   int nparms, nargs, parm_idx, arg_idx, lost = 0;\n+  tree orig_inner_args;\n   tree inner_args;\n   tree new_args;\n   tree new_inner_args;\n@@ -6705,7 +6787,7 @@ coerce_template_parms (tree parms,\n \t++variadic_p;\n     }\n \n-  inner_args = INNERMOST_TEMPLATE_ARGS (args);\n+  inner_args = orig_inner_args = INNERMOST_TEMPLATE_ARGS (args);\n   /* If there are no parameters that follow a parameter pack, we need to\n      expand any argument packs so that we can deduce a parameter pack from\n      some non-packed args followed by an argument pack, as in variadic85.C.\n@@ -6783,6 +6865,7 @@ coerce_template_parms (tree parms,\n   c_inhibit_evaluation_warnings = 0;\n   new_inner_args = make_tree_vec (nparms);\n   new_args = add_outermost_template_args (args, new_inner_args);\n+  int pack_adjust = 0;\n   for (parm_idx = 0, arg_idx = 0; parm_idx < nparms; parm_idx++, arg_idx++)\n     {\n       tree arg;\n@@ -6806,22 +6889,36 @@ coerce_template_parms (tree parms,\n       if (template_parameter_pack_p (TREE_VALUE (parm))\n \t  && !(arg && ARGUMENT_PACK_P (arg)))\n         {\n-\t  /* All remaining arguments will be placed in the\n+\t  /* Some arguments will be placed in the\n \t     template parameter pack PARM.  */\n \t  arg = coerce_template_parameter_pack (parms, parm_idx, args, \n \t\t\t\t\t\tinner_args, arg_idx,\n \t\t\t\t\t\tnew_args, &lost,\n \t\t\t\t\t\tin_decl, complain);\n \n-          /* Store this argument.  */\n-          if (arg == error_mark_node)\n-            lost++;\n-\t  if (lost)\n-\t    break;\n+\t  if (arg == NULL_TREE)\n+\t    {\n+\t      /* We don't know how many args we have yet, just use the\n+\t\t unconverted (and still packed) ones for now.  */\n+\t      new_inner_args = orig_inner_args;\n+\t      arg_idx = nargs;\n+\t      break;\n+\t    }\n+\n           TREE_VEC_ELT (new_inner_args, parm_idx) = arg;\n \n-\t  /* We are done with all of the arguments.  */\n-\t  arg_idx = nargs;\n+          /* Store this argument.  */\n+          if (arg == error_mark_node)\n+\t    {\n+\t      lost++;\n+\t      /* We are done with all of the arguments.  */\n+\t      arg_idx = nargs;\n+\t    }\n+\t  else\n+\t    {\n+\t      pack_adjust = TREE_VEC_LENGTH (ARGUMENT_PACK_ARGS (arg)) - 1;\n+\t      arg_idx += pack_adjust;\n+\t    }\n           \n           continue;\n         }\n@@ -6832,6 +6929,7 @@ coerce_template_parms (tree parms,\n               /* We don't know how many args we have yet, just\n                  use the unconverted ones for now.  */\n               new_inner_args = inner_args;\n+\t      arg_idx = nargs;\n               break;\n             }\n         }\n@@ -6844,7 +6942,8 @@ coerce_template_parms (tree parms,\n \t     is also the number of non-defaulted arguments in NEW_INNER_ARGS.\n \t     Record that.  */\n \t  if (!NON_DEFAULT_TEMPLATE_ARGS_COUNT (new_inner_args))\n-\t    SET_NON_DEFAULT_TEMPLATE_ARGS_COUNT (new_inner_args, arg_idx);\n+\t    SET_NON_DEFAULT_TEMPLATE_ARGS_COUNT (new_inner_args,\n+\t\t\t\t\t\t arg_idx - pack_adjust);\n \t}\n       else\n \tbreak;\n@@ -6868,11 +6967,23 @@ coerce_template_parms (tree parms,\n \n       if (arg == error_mark_node)\n \tlost++;\n-      TREE_VEC_ELT (new_inner_args, arg_idx) = arg;\n+      TREE_VEC_ELT (new_inner_args, arg_idx - pack_adjust) = arg;\n     }\n   cp_unevaluated_operand = saved_unevaluated_operand;\n   c_inhibit_evaluation_warnings = saved_inhibit_evaluation_warnings;\n \n+  if (variadic_p && arg_idx < nargs)\n+    {\n+      if (complain & tf_error)\n+\t{\n+\t  error (\"wrong number of template arguments \"\n+\t\t \"(%d, should be %d)\", nargs, arg_idx);\n+\t  if (in_decl)\n+\t    error (\"provided for %q+D\", in_decl);\n+\t}\n+      return error_mark_node;\n+    }\n+\n   if (lost)\n     return error_mark_node;\n \n@@ -9509,7 +9620,11 @@ gen_elem_of_pack_expansion_instantiation (tree pattern,\n \n   /* Substitute into the PATTERN with the (possibly altered)\n      arguments.  */\n-  if (!TYPE_P (pattern))\n+  if (pattern == in_decl)\n+    /* Expanding a fixed parameter pack from\n+       coerce_template_parameter_pack.  */\n+    t = tsubst_decl (pattern, args, complain);\n+  else if (!TYPE_P (pattern))\n     t = tsubst_expr (pattern, args, complain, in_decl,\n \t\t     /*integral_constant_expression_p=*/false);\n   else"}, {"sha": "a65351db4105f7f079791d4892cd001047f255ad", "filename": "gcc/testsuite/g++.dg/cpp0x/variadic151.C", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0ff7fe1d223260aea5b7dc3f36892aa57d43c77/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic151.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0ff7fe1d223260aea5b7dc3f36892aa57d43c77/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic151.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic151.C?ref=b0ff7fe1d223260aea5b7dc3f36892aa57d43c77", "patch": "@@ -0,0 +1,9 @@\n+// PR c++/54440\n+// { dg-do compile { target c++11 } }\n+\n+template <class...T> struct A\n+{\n+  template <T... t, class U> struct B { };\n+};\n+\n+A<int,char>::B<42,'a',float> b;"}, {"sha": "d7dccc53f6b41d182797a03aa543f8eca0d9aaff", "filename": "gcc/testsuite/g++.dg/cpp0x/variadic152.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0ff7fe1d223260aea5b7dc3f36892aa57d43c77/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic152.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0ff7fe1d223260aea5b7dc3f36892aa57d43c77/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic152.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic152.C?ref=b0ff7fe1d223260aea5b7dc3f36892aa57d43c77", "patch": "@@ -0,0 +1,12 @@\n+// PR c++/54440\n+// { dg-do compile { target c++11 } }\n+\n+template <class...T> struct A\n+{\n+  template <template <T> class... TP, class U> struct B { };\n+};\n+\n+template <int I> struct C { };\n+template <char C> struct D { };\n+\n+A<int,char>::B<C,D,float> b;"}, {"sha": "1af6531796b326c5aa6f76809c4292d4caafd8ac", "filename": "gcc/testsuite/g++.dg/cpp0x/variadic74.C", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0ff7fe1d223260aea5b7dc3f36892aa57d43c77/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic74.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0ff7fe1d223260aea5b7dc3f36892aa57d43c77/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic74.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic74.C?ref=b0ff7fe1d223260aea5b7dc3f36892aa57d43c77", "patch": "@@ -24,3 +24,5 @@ A<int*, float*>::X<&i> apple2; // { dg-error \"wrong number of template arguments\n A<int*, float*>::X<&i, &f, &f> apple3; // { dg-error \"wrong number of template arguments\" \"wrong number\" }\n // { dg-error \"invalid type\" \"invalid\" { target *-*-* } 24 }\n A<int, float> apple4;\n+\n+// { dg-prune-output \"provided for\" }"}]}