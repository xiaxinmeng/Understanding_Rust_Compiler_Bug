{"sha": "c0ee00211f683cd8a0974cb211822c50b35b6782", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzBlZTAwMjExZjY4M2NkOGEwOTc0Y2IyMTE4MjJjNTBiMzViNjc4Mg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2008-12-06T08:34:20Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2008-12-06T08:34:20Z"}, "message": "re PR middle-end/38074 (missed inlining on Core2 Duo due  to apparent wrong branch prediction/profile)\n\n\n\tPR tree-optimization/38074\n\t* cgraphbuild.c (compute_call_stmt_bb_frequency): Fix handling of 0\n\tentry frequency.\n\t* predict.c (combine_predictions_for_bb): Ignore predictor predicting\n\tin both dirrection for first match heuristics.\n\t(tree_bb_level_predictions): Disable noreturn heuristic when there\n\tis no returning path.\n\nCo-Authored-By: Jakub Jelinek <jakub@redhat.com>\n\nFrom-SVN: r142517", "tree": {"sha": "1c3592ee7c56ccfdd8c2ce7168b872880b33ba1d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1c3592ee7c56ccfdd8c2ce7168b872880b33ba1d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c0ee00211f683cd8a0974cb211822c50b35b6782", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0ee00211f683cd8a0974cb211822c50b35b6782", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c0ee00211f683cd8a0974cb211822c50b35b6782", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0ee00211f683cd8a0974cb211822c50b35b6782/comments", "author": null, "committer": null, "parents": [{"sha": "abc79c3a6d295d42b0a9ab48cea07090b0161ee8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/abc79c3a6d295d42b0a9ab48cea07090b0161ee8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/abc79c3a6d295d42b0a9ab48cea07090b0161ee8"}], "stats": {"total": 58, "additions": 52, "deletions": 6}, "files": [{"sha": "248ba67c660d9dcba3b38e2840d069ec43ac53d1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0ee00211f683cd8a0974cb211822c50b35b6782/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0ee00211f683cd8a0974cb211822c50b35b6782/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c0ee00211f683cd8a0974cb211822c50b35b6782", "patch": "@@ -1,3 +1,14 @@\n+2008-12-06  Jan Hubicka  <jh@suse.cz>\n+\t    Jakub Jelinek <jakub@redhat.com>\n+\n+\tPR tree-optimization/38074\n+\t* cgraphbuild.c (compute_call_stmt_bb_frequency): Fix handling of 0\n+\tentry frequency.\n+\t* predict.c (combine_predictions_for_bb): Ignore predictor predicting\n+\tin both dirrection for first match heuristics.\n+\t(tree_bb_level_predictions): Disable noreturn heuristic when there\n+\tis no returning path.\n+\n 2008-12-05  Bernd Schmidt  <bernd.schmidt@analog.com>\n \n \tPR rtl-optimization/38272"}, {"sha": "75db87544cea3706c6e65c3cbc541f3da8b95d9f", "filename": "gcc/cgraphbuild.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0ee00211f683cd8a0974cb211822c50b35b6782/gcc%2Fcgraphbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0ee00211f683cd8a0974cb211822c50b35b6782/gcc%2Fcgraphbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphbuild.c?ref=c0ee00211f683cd8a0974cb211822c50b35b6782", "patch": "@@ -109,13 +109,12 @@ int\n compute_call_stmt_bb_frequency (basic_block bb)\n {\n   int entry_freq = ENTRY_BLOCK_PTR->frequency;\n-  int freq;\n+  int freq = bb->frequency;\n \n   if (!entry_freq)\n-    entry_freq = 1;\n+    entry_freq = 1, freq++;\n \n-  freq = (!bb->frequency && !entry_freq ? CGRAPH_FREQ_BASE\n-\t      : bb->frequency * CGRAPH_FREQ_BASE / entry_freq);\n+  freq = freq * CGRAPH_FREQ_BASE / entry_freq;\n   if (freq > CGRAPH_FREQ_MAX)\n     freq = CGRAPH_FREQ_MAX;\n "}, {"sha": "73dbcbdc4cea99d469bd359882f6c1d9cc867539", "filename": "gcc/predict.c", "status": "modified", "additions": 38, "deletions": 2, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0ee00211f683cd8a0974cb211822c50b35b6782/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0ee00211f683cd8a0974cb211822c50b35b6782/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=c0ee00211f683cd8a0974cb211822c50b35b6782", "patch": "@@ -820,8 +820,33 @@ combine_predictions_for_bb (basic_block bb)\n \t    probability = REG_BR_PROB_BASE - probability;\n \n \t  found = true;\n+\t  /* First match heuristics would be widly confused if we predicted\n+\t     both directions.  */\n \t  if (best_predictor > predictor)\n-\t    best_probability = probability, best_predictor = predictor;\n+\t    {\n+              struct edge_prediction *pred2;\n+\t      int prob = probability;\n+\n+              for (pred2 = (struct edge_prediction *) *preds; pred2; pred2 = pred2->ep_next)\n+\t       if (pred2 != pred && pred2->ep_predictor == pred->ep_predictor)\n+\t         {\n+\t           int probability2 = pred->ep_probability;\n+\n+\t\t   if (pred2->ep_edge != first)\n+\t\t     probability2 = REG_BR_PROB_BASE - probability2;\n+\n+\t\t   if ((probability < REG_BR_PROB_BASE / 2) != \n+\t\t       (probability2 < REG_BR_PROB_BASE / 2))\n+\t\t     break;\n+\n+\t\t   /* If the same predictor later gave better result, go for it! */\n+\t\t   if ((probability >= REG_BR_PROB_BASE / 2 && (probability2 > probability))\n+\t\t       || (probability <= REG_BR_PROB_BASE / 2 && (probability2 < probability)))\n+\t\t     prob = probability2;\n+\t\t }\n+\t      if (!pred2)\n+\t        best_probability = prob, best_predictor = predictor;\n+\t    }\n \n \t  d = (combined_probability * probability\n \t       + (REG_BR_PROB_BASE - combined_probability)\n@@ -1521,6 +1546,16 @@ static void\n tree_bb_level_predictions (void)\n {\n   basic_block bb;\n+  bool has_return_edges = false;\n+  edge e;\n+  edge_iterator ei;\n+\n+  FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR->preds)\n+    if (!(e->flags & (EDGE_ABNORMAL | EDGE_FAKE | EDGE_EH)))\n+      {\n+        has_return_edges = true;\n+\tbreak;\n+      }\n \n   apply_return_prediction ();\n \n@@ -1535,7 +1570,8 @@ tree_bb_level_predictions (void)\n \n \t  if (is_gimple_call (stmt))\n \t    {\n-\t      if (gimple_call_flags (stmt) & ECF_NORETURN)\n+\t      if ((gimple_call_flags (stmt) & ECF_NORETURN)\n+\t          && has_return_edges)\n \t\tpredict_paths_leading_to (bb, PRED_NORETURN,\n \t\t\t\t\t  NOT_TAKEN);\n \t      decl = gimple_call_fndecl (stmt);"}]}