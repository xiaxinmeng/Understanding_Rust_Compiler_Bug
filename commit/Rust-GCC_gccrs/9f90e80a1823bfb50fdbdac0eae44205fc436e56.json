{"sha": "9f90e80a1823bfb50fdbdac0eae44205fc436e56", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWY5MGU4MGExODIzYmZiNTBmZGJkYWMwZWFlNDQyMDVmYzQzNmU1Ng==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2010-05-22T14:48:40Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2010-05-22T14:48:40Z"}, "message": "decl2.c (maybe_emit_vtables): Produce same comdat group when outputting comdat vtables.\n\n\t* decl2.c (maybe_emit_vtables): Produce same comdat group when outputting\n\tcomdat vtables.\n\t(cxx_callgraph_analyze_expr): Remove code marking vtables needed.\n\n\t* cgraph.h (struct varpool_node): Add same_comdat_group.\n\t* lto-cgrpah.c (lto_output_varpool_node): Output same_comdat_group\n\tpointer.\n\t(output_varpool): Update call of lto_output_varpool_node.\n\t(input_varpool): Read same_comdat_group pointer.\n\t(input_varpool_1): Fixup same_comdat_group pointer.\n\t* ipa.c (cgraph_remove_unreachable_nodes): WHen one of same comdat\n\tgroup is needed, all are.\n\t* varpool.c (varpool_remove_node): Remove node from same comdat group\n\tlinklist too.\n\t(varpool_analyze_pending_decls): Walk same comdat groups.\n\nFrom-SVN: r159699", "tree": {"sha": "c6700f8a244d310bf2e05c428d125caeecbd1ffe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c6700f8a244d310bf2e05c428d125caeecbd1ffe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9f90e80a1823bfb50fdbdac0eae44205fc436e56", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f90e80a1823bfb50fdbdac0eae44205fc436e56", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9f90e80a1823bfb50fdbdac0eae44205fc436e56", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f90e80a1823bfb50fdbdac0eae44205fc436e56/comments", "author": null, "committer": null, "parents": [{"sha": "a2c9fe42531a2ef2259e4128c50632b2df37202b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2c9fe42531a2ef2259e4128c50632b2df37202b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a2c9fe42531a2ef2259e4128c50632b2df37202b"}], "stats": {"total": 118, "additions": 103, "deletions": 15}, "files": [{"sha": "e7f0f716e6feba2272bc3bcdfbddac2681e78d9a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f90e80a1823bfb50fdbdac0eae44205fc436e56/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f90e80a1823bfb50fdbdac0eae44205fc436e56/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9f90e80a1823bfb50fdbdac0eae44205fc436e56", "patch": "@@ -1,3 +1,17 @@\n+2010-05-22  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cgraph.h (struct varpool_node): Add same_comdat_group.\n+\t* lto-cgrpah.c (lto_output_varpool_node): Output same_comdat_group\n+\tpointer.\n+\t(output_varpool): Update call of lto_output_varpool_node.\n+\t(input_varpool): Read same_comdat_group pointer.\n+\t(input_varpool_1): Fixup same_comdat_group pointer.\n+\t* ipa.c (cgraph_remove_unreachable_nodes): WHen one of same comdat\n+\tgroup is needed, all are.\n+\t* varpool.c (varpool_remove_node): Remove node from same comdat group\n+\tlinklist too.\n+\t(varpool_analyze_pending_decls): Walk same comdat groups.\n+\n 2010-05-22  Steven Bosscher  <steven@gcc.gnu.org>\n \n \t* rtl.h (union rtunion_def): Remove rt_bit member."}, {"sha": "a9a2962eb0b4df6552329e0d173d17acf66d5f0c", "filename": "gcc/cgraph.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f90e80a1823bfb50fdbdac0eae44205fc436e56/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f90e80a1823bfb50fdbdac0eae44205fc436e56/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=9f90e80a1823bfb50fdbdac0eae44205fc436e56", "patch": "@@ -457,6 +457,8 @@ struct GTY((chain_next (\"%h.next\"), chain_prev (\"%h.prev\"))) varpool_node {\n   /* For normal nodes a pointer to the first extra name alias.  For alias\n      nodes a pointer to the normal node.  */\n   struct varpool_node *extra_name;\n+  /* Circular list of nodes in the same comdat group if non-NULL.  */\n+  struct varpool_node *same_comdat_group;\n   struct ipa_ref_list ref_list;\n   PTR GTY ((skip)) aux;\n   /* Ordering of all cgraph nodes.  */"}, {"sha": "47f53080a315642cecac41bcdaf043d7d5a5f5ad", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f90e80a1823bfb50fdbdac0eae44205fc436e56/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f90e80a1823bfb50fdbdac0eae44205fc436e56/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=9f90e80a1823bfb50fdbdac0eae44205fc436e56", "patch": "@@ -1,3 +1,9 @@\n+2010-05-22  Jan Hubicka  <jh@suse.cz>\n+\n+\t* decl2.c (maybe_emit_vtables): Produce same comdat group when outputting\n+\tcomdat vtables.\n+\t(cxx_callgraph_analyze_expr): Remove code marking vtables needed.\n+\n 2010-05-21  Joseph Myers  <joseph@codesourcery.com>\n \n \t* cxx-pretty-print.c: Correct merge error."}, {"sha": "2fd63056016768217655a091672eb21794bf167a", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f90e80a1823bfb50fdbdac0eae44205fc436e56/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f90e80a1823bfb50fdbdac0eae44205fc436e56/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=9f90e80a1823bfb50fdbdac0eae44205fc436e56", "patch": "@@ -1808,6 +1808,7 @@ maybe_emit_vtables (tree ctype)\n   tree vtbl;\n   tree primary_vtbl;\n   int needed = 0;\n+  struct varpool_node *current = NULL, *last = NULL, *first = NULL;\n \n   /* If the vtables for this class have already been emitted there is\n      nothing more to do.  */\n@@ -1865,8 +1866,20 @@ maybe_emit_vtables (tree ctype)\n \t actually marking the variable as written.  */\n       if (flag_syntax_only)\n \tTREE_ASM_WRITTEN (vtbl) = 1;\n+      else if (DECL_COMDAT (vtbl))\n+\t{\n+\t  current = varpool_node (vtbl);\n+\t  if (last)\n+\t    last->same_comdat_group = current;\n+\t  last = current;\n+\t  if (!first)\n+\t    first = current;\n+\t}\n     }\n \n+  if (first != last)\n+    last->same_comdat_group = first;\n+\n   /* Since we're writing out the vtable here, also write the debug\n      info.  */\n   note_debug_info_needed (ctype);\n@@ -3358,19 +3371,9 @@ cxx_callgraph_analyze_expr (tree *tp, int *walk_subtrees ATTRIBUTE_UNUSED)\n \tcgraph_mark_address_taken_node (cgraph_node (BASELINK_FUNCTIONS (t)));\n       break;\n     case VAR_DECL:\n-      if (DECL_VTABLE_OR_VTT_P (t))\n-\t{\n-\t  /* The ABI requires that all virtual tables be emitted\n-\t     whenever one of them is.  */\n-\t  tree vtbl;\n-\t  for (vtbl = CLASSTYPE_VTABLES (DECL_CONTEXT (t));\n-\t       vtbl;\n-\t       vtbl = TREE_CHAIN (vtbl))\n-\t    mark_decl_referenced (vtbl);\n-\t}\n-      else if (DECL_CONTEXT (t)\n-\t       && flag_use_repository\n-\t       && TREE_CODE (DECL_CONTEXT (t)) == FUNCTION_DECL)\n+      if (DECL_CONTEXT (t)\n+\t  && flag_use_repository\n+\t  && TREE_CODE (DECL_CONTEXT (t)) == FUNCTION_DECL)\n \t/* If we need a static variable in a function, then we\n \t   need the containing function.  */\n \tmark_decl_referenced (DECL_CONTEXT (t));"}, {"sha": "319a3f1b8bb9a921b822c2e63c69146211aebacf", "filename": "gcc/ipa.c", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f90e80a1823bfb50fdbdac0eae44205fc436e56/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f90e80a1823bfb50fdbdac0eae44205fc436e56/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=9f90e80a1823bfb50fdbdac0eae44205fc436e56", "patch": "@@ -334,6 +334,21 @@ cgraph_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \t  first_varpool = (struct varpool_node *)first_varpool->aux;\n \t  vnode->aux = NULL;\n \t  process_references (&vnode->ref_list, &first, &first_varpool, before_inlining_p);\n+\t  /* If any function in a comdat group is reachable, force\n+\t     all other functions in the same comdat group to be\n+\t     also reachable.  */\n+\t  if (vnode->same_comdat_group)\n+\t    {\n+\t      struct varpool_node *next;\n+\t      for (next = vnode->same_comdat_group;\n+\t\t   next != vnode;\n+\t\t   next = next->same_comdat_group)\n+\t\tif (!next->needed)\n+\t\t  {\n+\t\t    varpool_mark_needed_node (next);\n+\t\t    enqueue_varpool_node (next, &first_varpool);\n+\t\t  }\n+\t    }\n \t}\n     }\n "}, {"sha": "f911c3ac1043f705708bbce41ddc5a9d09bce0b4", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f90e80a1823bfb50fdbdac0eae44205fc436e56/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f90e80a1823bfb50fdbdac0eae44205fc436e56/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=9f90e80a1823bfb50fdbdac0eae44205fc436e56", "patch": "@@ -565,12 +565,14 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n \n static void\n lto_output_varpool_node (struct lto_simple_output_block *ob, struct varpool_node *node,\n+\t\t\t lto_varpool_encoder_t varpool_encoder,\n \t\t         cgraph_node_set set, varpool_node_set vset)\n {\n   bool boundary_p = !varpool_node_in_set_p (node, vset) && node->analyzed;\n   struct bitpack_d *bp;\n   struct varpool_node *alias;\n   int count = 0;\n+  int ref;\n \n   lto_output_var_decl_index (ob->decl_state, ob->main_stream, node->decl);\n   bp = bitpack_create ();\n@@ -602,6 +604,14 @@ lto_output_varpool_node (struct lto_simple_output_block *ob, struct varpool_node\n   bp_pack_value (bp, count != 0, 1);\n   lto_output_bitpack (ob->main_stream, bp);\n   bitpack_delete (bp);\n+  if (node->same_comdat_group && !boundary_p)\n+    {\n+      ref = lto_varpool_encoder_lookup (varpool_encoder, node->same_comdat_group);\n+      gcc_assert (ref != LCC_NOT_FOUND);\n+    }\n+  else\n+    ref = LCC_NOT_FOUND;\n+  lto_output_sleb128_stream (ob->main_stream, ref);\n \n   if (count)\n     {\n@@ -961,6 +971,7 @@ output_varpool (cgraph_node_set set, varpool_node_set vset)\n   for (i = 0; i < len; i++)\n     {\n       lto_output_varpool_node (ob, lto_varpool_encoder_deref (varpool_encoder, i),\n+      \t\t\t       varpool_encoder,\n \t\t\t       set, vset);\n     }\n \n@@ -1081,6 +1092,7 @@ input_varpool_node (struct lto_file_decl_data *file_data,\n   struct bitpack_d *bp;\n   bool aliases_p;\n   int count;\n+  int ref = LCC_NOT_FOUND;\n \n   decl_index = lto_input_uleb128 (ib);\n   var_decl = lto_file_decl_data_get_var_decl (file_data, decl_index);\n@@ -1098,6 +1110,9 @@ input_varpool_node (struct lto_file_decl_data *file_data,\n   if (node->finalized)\n     varpool_mark_needed_node (node);\n   bitpack_delete (bp);\n+  ref = lto_input_sleb128 (ib);\n+  /* Store a reference for now, and fix up later to be a pointer.  */\n+  node->same_comdat_group = (struct varpool_node *) (intptr_t) ref;\n   if (aliases_p)\n     {\n       count = lto_input_uleb128 (ib);\n@@ -1291,6 +1306,8 @@ input_varpool_1 (struct lto_file_decl_data *file_data,\n {\n   unsigned HOST_WIDE_INT len;\n   VEC(varpool_node_ptr, heap) *varpool = NULL;\n+  int i;\n+  struct varpool_node *node;\n \n   len = lto_input_uleb128 (ib);\n   while (len)\n@@ -1299,6 +1316,16 @@ input_varpool_1 (struct lto_file_decl_data *file_data,\n \t\t     input_varpool_node (file_data, ib));\n       len--;\n     }\n+  for (i = 0; VEC_iterate (varpool_node_ptr, varpool, i, node); i++)\n+    {\n+      int ref = (int) (intptr_t) node->same_comdat_group;\n+\n+      /* Fixup same_comdat_group from reference to pointer.  */\n+      if (ref != LCC_NOT_FOUND)\n+\tnode->same_comdat_group = VEC_index (varpool_node_ptr, varpool, ref);\n+      else\n+\tnode->same_comdat_group = NULL;\n+    }\n   return varpool;\n }\n "}, {"sha": "73d39f33901af147cba489f83d0deb8f23afb36a", "filename": "gcc/varpool.c", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f90e80a1823bfb50fdbdac0eae44205fc436e56/gcc%2Fvarpool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f90e80a1823bfb50fdbdac0eae44205fc436e56/gcc%2Fvarpool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarpool.c?ref=9f90e80a1823bfb50fdbdac0eae44205fc436e56", "patch": "@@ -194,6 +194,19 @@ varpool_remove_node (struct varpool_node *node)\n       gcc_assert (varpool_nodes_queue == node);\n       varpool_nodes_queue = node->next_needed;\n     }\n+  if (node->same_comdat_group)\n+    {\n+      struct varpool_node *prev;\n+      for (prev = node->same_comdat_group;\n+\t   prev->same_comdat_group != node;\n+\t   prev = prev->same_comdat_group)\n+\t;\n+      if (node->same_comdat_group == prev)\n+\tprev->same_comdat_group = NULL;\n+      else\n+\tprev->same_comdat_group = node->same_comdat_group;\n+      node->same_comdat_group = NULL;\n+    }\n   ipa_remove_all_references (&node->ref_list);\n   ipa_remove_all_refering (&node->ref_list);\n   ggc_free (node);\n@@ -416,8 +429,9 @@ varpool_analyze_pending_decls (void)\n   timevar_push (TV_VARPOOL);\n   while (varpool_first_unanalyzed_node)\n     {\n-      tree decl = varpool_first_unanalyzed_node->decl;\n-      bool analyzed = varpool_first_unanalyzed_node->analyzed;\n+      struct varpool_node *node = varpool_first_unanalyzed_node, *next;\n+      tree decl = node->decl;\n+      bool analyzed = node->analyzed;\n \n       varpool_first_unanalyzed_node->analyzed = true;\n \n@@ -435,6 +449,13 @@ varpool_analyze_pending_decls (void)\n \t}\n       if (DECL_INITIAL (decl))\n \trecord_references_in_initializer (decl, analyzed);\n+      if (node->same_comdat_group)\n+\t{\n+\t  for (next = node->same_comdat_group;\n+\t       next != node;\n+\t       next = next->same_comdat_group)\n+\t    varpool_mark_needed_node (next);\n+\t}\n       changed = true;\n     }\n   timevar_pop (TV_VARPOOL);"}]}