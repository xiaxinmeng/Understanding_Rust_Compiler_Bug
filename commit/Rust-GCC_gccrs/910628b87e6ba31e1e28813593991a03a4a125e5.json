{"sha": "910628b87e6ba31e1e28813593991a03a4a125e5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTEwNjI4Yjg3ZTZiYTMxZTFlMjg4MTM1OTM5OTFhMDNhNGExMjVlNQ==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1996-06-17T18:58:25Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1996-06-17T18:58:25Z"}, "message": "(mips_split_addresses): New variable.\n\n(simple_memory_operand): Add comment about mode check.  Add check\nfor LO_SUM.\n(call_insn_operand): OP is now an addresses instead of a MEM.\n(move_operand, mips_check_split): New functions.\n(mips_count_memory_refs): Add check for LO_SUM.\n(mips_move_1word): Add HIGH support.\n(mips_address_cost): Delete check for HIGH.\n(output_block_move): Handle LO_SUM addresses.\n(override_options): Set mips_split_addresses.\n(print_operand_address): Add LO_SUM support.\n\nFrom-SVN: r12285", "tree": {"sha": "ce9eb11f5bf83a0c2054639e6176006f92816148", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ce9eb11f5bf83a0c2054639e6176006f92816148"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/910628b87e6ba31e1e28813593991a03a4a125e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/910628b87e6ba31e1e28813593991a03a4a125e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/910628b87e6ba31e1e28813593991a03a4a125e5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/910628b87e6ba31e1e28813593991a03a4a125e5/comments", "author": null, "committer": null, "parents": [{"sha": "7fc5b3310d130db1d1f7d300abbad6c3ae2fdeb0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7fc5b3310d130db1d1f7d300abbad6c3ae2fdeb0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7fc5b3310d130db1d1f7d300abbad6c3ae2fdeb0"}], "stats": {"total": 138, "additions": 129, "deletions": 9}, "files": [{"sha": "64c6ce790047d5967d63c168450fad13da8c87b4", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 129, "deletions": 9, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/910628b87e6ba31e1e28813593991a03a4a125e5/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/910628b87e6ba31e1e28813593991a03a4a125e5/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=910628b87e6ba31e1e28813593991a03a4a125e5", "patch": "@@ -203,6 +203,9 @@ char *mips_cpu_string;\t\t/* for -mcpu=<xxx> */\n char *mips_isa_string;\t\t/* for -mips{1,2,3,4} */\n char *mips_abi_string;\t\t/* for -mabi={32,n32,64} */\n \n+/* If TRUE, we split addresses into their high and low parts in the RTL.  */\n+int mips_split_addresses;\n+\n /* Generating calls to position independent functions?  */\n enum mips_abicalls_type mips_abicalls;\n \n@@ -536,6 +539,9 @@ simple_memory_operand (op, mode)\n     return FALSE;\n \n   /* dword operations really put out 2 instructions, so eliminate them.  */\n+  /* ??? This isn't strictly correct.  It is OK to accept multiword modes\n+     here, since the length attributes are being set correctly, but only\n+     if the address is offsettable.  LO_SUM is not offsettable.  */\n   if (GET_MODE_SIZE (GET_MODE (op)) > UNITS_PER_WORD)\n     return FALSE;\n \n@@ -547,6 +553,7 @@ simple_memory_operand (op, mode)\n       break;\n \n     case REG:\n+    case LO_SUM:\n       return TRUE;\n \n     case CONST_INT:\n@@ -655,15 +662,61 @@ call_insn_operand (op, mode)\n      rtx op;\n      enum machine_mode mode;\n {\n-  if (GET_CODE (op) == MEM\n-      && (CONSTANT_ADDRESS_P (XEXP (op, 0))\n-\t  || (GET_CODE (XEXP (op, 0)) == REG\n-\t      && XEXP (op, 0) != arg_pointer_rtx\n-\t      && !(REGNO (XEXP (op, 0)) >= FIRST_PSEUDO_REGISTER\n-\t\t   && REGNO (XEXP (op, 0)) <= LAST_VIRTUAL_REGISTER))))\n+  if (CONSTANT_ADDRESS_P (op)\n+      || (GET_CODE (op) == REG && op != arg_pointer_rtx\n+\t  && ! (REGNO (op) >= FIRST_PSEUDO_REGISTER\n+\t\t&& REGNO (op) <= LAST_VIRTUAL_REGISTER)))\n     return 1;\n   return 0;\n }\n+\n+/* Return true if OPERAND is valid as a source operand for a move\n+   instruction.  */\n+\n+int\n+move_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return (general_operand (op, mode)\n+\t  && ! (mips_split_addresses && mips_check_split (op, mode)));\n+}\n+\n+/* Return true if we split the address into high and low parts.  */\n+\n+/* ??? We should also handle reg+array somewhere.  We get four\n+   instructions currently, lui %hi/addui %lo/addui reg/lw.  Better is\n+   lui %hi/addui reg/lw %lo.  Fixing GO_IF_LEGITIMATE_ADDRESS to accept\n+   (plus (reg) (symbol_ref)) doesn't work because the SYMBOL_REF is broken\n+   out of the address, then we have 4 instructions to combine.  Perhaps\n+   add a 3->2 define_split for combine.  */\n+\n+/* ??? We could also split a CONST_INT here if it is a large_int().\n+   However, it doesn't seem to be very useful to have %hi(constant).\n+   We would be better off by doing the masking ourselves and then putting\n+   the explicit high part of the constant in the RTL.  This will give better\n+   optimization.  Also, %hi(constant) needs assembler changes to work.\n+   There is already a define_split that does this.  */\n+\n+int\n+mips_check_split (address, mode)\n+     rtx address;\n+     enum machine_mode mode;\n+{     \n+  /* ??? This is the same check used in simple_memory_operand.\n+     We use it here because LO_SUM is not offsettable.  */\n+  if (GET_MODE_SIZE (mode) > UNITS_PER_WORD)\n+    return 0;\n+\n+  if ((GET_CODE (address) == SYMBOL_REF && ! SYMBOL_REF_FLAG (address))\n+      || (GET_CODE (address) == CONST\n+\t  && GET_CODE (XEXP (XEXP (address, 0), 0)) == SYMBOL_REF\n+\t  && ! SYMBOL_REF_FLAG (XEXP (XEXP (address, 0), 0)))\n+      || GET_CODE (address) == LABEL_REF)\n+    return 1;\n+\n+  return 0;\n+}\n \f\n /* Returns an operand string for the given instruction's delay slot,\n    after updating filled delay slot statistics.\n@@ -787,6 +840,7 @@ mips_count_memory_refs (op, num)\n \n \tcase REG:\n \tcase CONST_INT:\n+\tcase LO_SUM:\n \t  break;\n \n \tcase PLUS:\n@@ -1179,6 +1233,12 @@ mips_move_1word (operands, insn, unsignedp)\n \t  operands[3] = add_op1;\n \t  ret = \"add%:\\t%0,%2,%3\";\n \t}\n+\n+      else if (code1 == HIGH)\n+\t{\n+\t  operands[1] = XEXP (op1, 0);\n+\t  ret = \"lui\\t%0,%%hi(%1)\";\n+\t}\n     }\n \n   else if (code0 == MEM)\n@@ -1622,7 +1682,6 @@ mips_address_cost (addr)\n       break;\n \n     case LO_SUM:\n-    case HIGH:\n       return 1;\n \n     case LABEL_REF:\n@@ -2554,6 +2613,42 @@ output_block_move (insn, operands, num_regs, move_type)\n \t}\n     }\n \n+  /* ??? We really shouldn't get any LO_SUM addresses here, because they\n+     are not offsettable, however, offsettable_address_p says they are\n+     offsettable. I think this is a bug in offsettable_address_p.\n+     For expediency, we fix this by just loading the address into a register\n+     if we happen to get one.  */\n+\n+  if (GET_CODE (src_reg) == LO_SUM)\n+    {\n+      src_reg = operands[ 3 + num_regs-- ];\n+      if (move_type != BLOCK_MOVE_LAST)\n+\t{\n+\t  xoperands[2] = XEXP (XEXP (operands[1], 0), 1);\n+\t  xoperands[1] = XEXP (XEXP (operands[1], 0), 0);\n+\t  xoperands[0] = src_reg;\n+\t  if (Pmode == DImode)\n+\t    output_asm_insn (\"daddiu\\t%0,%1,%%lo(%2)\", xoperands);\n+\t  else\n+\t    output_asm_insn (\"addiu\\t%0,%1,%%lo(%2)\", xoperands);\n+\t}\n+    }\n+\n+  if (GET_CODE (dest_reg) == LO_SUM)\n+    {\n+      dest_reg = operands[ 3 + num_regs-- ];\n+      if (move_type != BLOCK_MOVE_LAST)\n+\t{\n+\t  xoperands[2] = XEXP (XEXP (operands[0], 0), 1);\n+\t  xoperands[1] = XEXP (XEXP (operands[0], 0), 0);\n+\t  xoperands[0] = dest_reg;\n+\t  if (Pmode == DImode)\n+\t    output_asm_insn (\"daddiu\\t%0,%1,%%lo(%2)\", xoperands);\n+\t  else\n+\t    output_asm_insn (\"addiu\\t%0,%1,%%lo(%2)\", xoperands);\n+\t}\n+    }\n+\n   if (num_regs > (sizeof (load_store) / sizeof (load_store[0])))\n     num_regs = (sizeof (load_store) / sizeof (load_store[0]));\n \n@@ -3436,6 +3531,14 @@ override_options ()\n       mips_section_threshold = 0x7fffffff;\n     }\n \n+  /* ??? This does not work when target addresses are DImode.\n+     This is because we are missing DImode high/lo_sum patterns.  */\n+\n+  if (TARGET_GAS && optimize && ! flag_pic && Pmode == SImode)\n+    mips_split_addresses = 1;\n+  else\n+    mips_split_addresses = 0;\n+\n   /* -mrnames says to use the MIPS software convention for register\n      names instead of the hardware names (ie, $a0 instead of $4).\n      We do this by switching the names in mips_reg_names, which the\n@@ -3918,6 +4021,23 @@ print_operand_address (file, addr)\n \tfprintf (file, \"0(%s)\", reg_names [REGNO (addr)]);\n \tbreak;\n \n+      case LO_SUM:\n+\t{\n+\t  register rtx arg0   = XEXP (addr, 0);\n+\t  register rtx arg1   = XEXP (addr, 1);\n+\n+\t  if (! mips_split_addresses)\n+\t    abort_with_insn (addr, \"PRINT_OPERAND_ADDRESS, Spurious LO_SUM.\");\n+\n+\t  if (GET_CODE (arg0) != REG)\n+\t    abort_with_insn (addr, \"PRINT_OPERAND_ADDRESS, LO_SUM with #1 not REG.\");\n+\n+\t  fprintf (file, \"%%lo(\");\n+\t  print_operand_address (file, arg1);\n+\t  fprintf (file, \")(%s)\", reg_names [REGNO (arg0)]);\n+\t}\n+\tbreak;\n+\n       case PLUS:\n \t{\n \t  register rtx reg    = (rtx)0;\n@@ -3948,8 +4068,8 @@ print_operand_address (file, addr)\n \t  if (!CONSTANT_P (offset))\n \t    abort_with_insn (addr, \"PRINT_OPERAND_ADDRESS, invalid insn #2\");\n \n-\tif (REGNO (reg) == ARG_POINTER_REGNUM)\n-\t  abort_with_insn (addr, \"Arg pointer not eliminated.\");\n+\t  if (REGNO (reg) == ARG_POINTER_REGNUM)\n+\t    abort_with_insn (addr, \"Arg pointer not eliminated.\");\n \n \t  output_addr_const (file, offset);\n \t  fprintf (file, \"(%s)\", reg_names [REGNO (reg)]);"}]}