{"sha": "ac0e4fdebcb5796d4f21c47f2b75bad7866f6366", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWMwZTRmZGViY2I1Nzk2ZDRmMjFjNDdmMmI3NWJhZDc4NjZmNjM2Ng==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2016-05-06T11:27:28Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2016-05-06T11:27:28Z"}, "message": "Manual changes to GCC coding style in tree-ssa-uninit.c\n\n\t* tree-ssa-uninit.c: Apply manual changes\n\tto the GNU coding style.\n\t(prune_uninit_phi_opnds): Rename from\n\tprune_uninit_phi_opnds_in_unrealizable_paths.\n\nFrom-SVN: r235961", "tree": {"sha": "cda8d96df040168f935f3a95c0846117314ce858", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cda8d96df040168f935f3a95c0846117314ce858"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ac0e4fdebcb5796d4f21c47f2b75bad7866f6366", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac0e4fdebcb5796d4f21c47f2b75bad7866f6366", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac0e4fdebcb5796d4f21c47f2b75bad7866f6366", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac0e4fdebcb5796d4f21c47f2b75bad7866f6366/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d8997c4415d531a6e800e5b3a9393f67a9015d44", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8997c4415d531a6e800e5b3a9393f67a9015d44", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d8997c4415d531a6e800e5b3a9393f67a9015d44"}], "stats": {"total": 408, "additions": 186, "deletions": 222}, "files": [{"sha": "ed6c31b28241766797e891f7294f67f92ea865c5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac0e4fdebcb5796d4f21c47f2b75bad7866f6366/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac0e4fdebcb5796d4f21c47f2b75bad7866f6366/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ac0e4fdebcb5796d4f21c47f2b75bad7866f6366", "patch": "@@ -1,3 +1,10 @@\n+2016-05-06  Martin Liska  <mliska@suse.cz>\n+\n+\t* tree-ssa-uninit.c: Apply manual changes\n+\tto the GNU coding style.\n+\t(prune_uninit_phi_opnds): Rename from\n+\tprune_uninit_phi_opnds_in_unrealizable_paths.\n+\n 2016-05-06  Oleg Endo  <olegendo@gcc.gnu.org>\n \n \t* config/sh/sh.opt (madjust-unroll, minvalid-symbols, msoft-atomic,"}, {"sha": "941d575f848d11e95bae9d96df5cdd8f5dbbfca2", "filename": "gcc/tree-ssa-uninit.c", "status": "modified", "additions": 179, "deletions": 222, "changes": 401, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac0e4fdebcb5796d4f21c47f2b75bad7866f6366/gcc%2Ftree-ssa-uninit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac0e4fdebcb5796d4f21c47f2b75bad7866f6366/gcc%2Ftree-ssa-uninit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-uninit.c?ref=ac0e4fdebcb5796d4f21c47f2b75bad7866f6366", "patch": "@@ -35,16 +35,15 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-cfg.h\"\n \n /* This implements the pass that does predicate aware warning on uses of\n-   possibly uninitialized variables. The pass first collects the set of\n-   possibly uninitialized SSA names. For each such name, it walks through\n-   all its immediate uses. For each immediate use, it rebuilds the condition\n-   expression (the predicate) that guards the use. The predicate is then\n+   possibly uninitialized variables.  The pass first collects the set of\n+   possibly uninitialized SSA names.  For each such name, it walks through\n+   all its immediate uses.  For each immediate use, it rebuilds the condition\n+   expression (the predicate) that guards the use.  The predicate is then\n    examined to see if the variable is always defined under that same condition.\n    This is done either by pruning the unrealizable paths that lead to the\n    default definitions or by checking if the predicate set that guards the\n    defining paths is a superset of the use predicate.  */\n \n-\n /* Pointer set of potentially undefined ssa names, i.e.,\n    ssa names that are defined by phi with operands that\n    are not defined or potentially undefined.  */\n@@ -56,7 +55,7 @@ static hash_set<tree> *possibly_undefined_names = 0;\n #define MASK_EMPTY(mask) (mask == 0)\n \n /* Returns the first bit position (starting from LSB)\n-   in mask that is non zero. Returns -1 if the mask is empty.  */\n+   in mask that is non zero.  Returns -1 if the mask is empty.  */\n static int\n get_mask_first_set_bit (unsigned mask)\n {\n@@ -80,13 +79,12 @@ has_undefined_value_p (tree t)\n \t      && possibly_undefined_names->contains (t)));\n }\n \n-\n-\n /* Like has_undefined_value_p, but don't return true if TREE_NO_WARNING\n    is set on SSA_NAME_VAR.  */\n \n static inline bool\n-uninit_undefined_value_p (tree t) {\n+uninit_undefined_value_p (tree t)\n+{\n   if (!has_undefined_value_p (t))\n     return false;\n   if (SSA_NAME_VAR (t) && TREE_NO_WARNING (SSA_NAME_VAR (t)))\n@@ -112,7 +110,7 @@ uninit_undefined_value_p (tree t) {\n /* Emit a warning for EXPR based on variable VAR at the point in the\n    program T, an SSA_NAME, is used being uninitialized.  The exact\n    warning text is in MSGID and DATA is the gimple stmt with info about\n-   the location in source code. When DATA is a GIMPLE_PHI, PHIARG_IDX\n+   the location in source code.  When DATA is a GIMPLE_PHI, PHIARG_IDX\n    gives which argument of the phi node to take the location from.  WC\n    is the warning code.  */\n \n@@ -149,8 +147,7 @@ warn_uninit (enum opt_code wc, tree t, tree expr, tree var,\n   else\n     location = DECL_SOURCE_LOCATION (var);\n   location = linemap_resolve_location (line_table, location,\n-\t\t\t\t       LRK_SPELLING_LOCATION,\n-\t\t\t\t       NULL);\n+\t\t\t\t       LRK_SPELLING_LOCATION, NULL);\n   cfun_loc = DECL_SOURCE_LOCATION (cfun->decl);\n   xloc = expand_location (location);\n   floc = expand_location (cfun_loc);\n@@ -161,10 +158,8 @@ warn_uninit (enum opt_code wc, tree t, tree expr, tree var,\n       if (location == DECL_SOURCE_LOCATION (var))\n \treturn;\n       if (xloc.file != floc.file\n-\t  || linemap_location_before_p (line_table,\n-\t\t\t\t\tlocation, cfun_loc)\n-\t  || linemap_location_before_p (line_table,\n-\t\t\t\t\tcfun->function_end_locus,\n+\t  || linemap_location_before_p (line_table, location, cfun_loc)\n+\t  || linemap_location_before_p (line_table, cfun->function_end_locus,\n \t\t\t\t\tlocation))\n \tinform (DECL_SOURCE_LOCATION (var), \"%qD was declared here\", var);\n     }\n@@ -178,8 +173,8 @@ warn_uninitialized_vars (bool warn_possibly_uninitialized)\n \n   FOR_EACH_BB_FN (bb, cfun)\n     {\n-      bool always_executed = dominated_by_p (CDI_POST_DOMINATORS,\n-\t\t\t\t\t     single_succ (ENTRY_BLOCK_PTR_FOR_FN (cfun)), bb);\n+      basic_block succ = single_succ (ENTRY_BLOCK_PTR_FOR_FN (cfun));\n+      bool always_executed = dominated_by_p (CDI_POST_DOMINATORS, succ, bb);\n       for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n \t{\n \t  gimple *stmt = gsi_stmt (gsi);\n@@ -196,13 +191,13 @@ warn_uninitialized_vars (bool warn_possibly_uninitialized)\n \t    {\n \t      use = USE_FROM_PTR (use_p);\n \t      if (always_executed)\n-\t\twarn_uninit (OPT_Wuninitialized, use,\n-\t\t\t     SSA_NAME_VAR (use), SSA_NAME_VAR (use),\n-\t\t\t     \"%qD is used uninitialized in this function\",\n-\t\t\t     stmt, UNKNOWN_LOCATION);\n+\t\twarn_uninit (OPT_Wuninitialized, use, SSA_NAME_VAR (use),\n+\t\t\t     SSA_NAME_VAR (use),\n+\t\t\t     \"%qD is used uninitialized in this function\", stmt,\n+\t\t\t     UNKNOWN_LOCATION);\n \t      else if (warn_possibly_uninitialized)\n-\t\twarn_uninit (OPT_Wmaybe_uninitialized, use,\n-\t\t\t     SSA_NAME_VAR (use), SSA_NAME_VAR (use),\n+\t\twarn_uninit (OPT_Wmaybe_uninitialized, use, SSA_NAME_VAR (use),\n+\t\t\t     SSA_NAME_VAR (use),\n \t\t\t     \"%qD may be used uninitialized in this function\",\n \t\t\t     stmt, UNKNOWN_LOCATION);\n \t    }\n@@ -232,9 +227,8 @@ warn_uninitialized_vars (bool warn_possibly_uninitialized)\n \t\tcontinue;\n \n \t      if (always_executed)\n-\t\twarn_uninit (OPT_Wuninitialized, use,\n-\t\t\t     gimple_assign_rhs1 (stmt), base,\n-\t\t\t     \"%qE is used uninitialized in this function\",\n+\t\twarn_uninit (OPT_Wuninitialized, use, gimple_assign_rhs1 (stmt),\n+\t\t\t     base, \"%qE is used uninitialized in this function\",\n \t\t\t     stmt, UNKNOWN_LOCATION);\n \t      else if (warn_possibly_uninitialized)\n \t\twarn_uninit (OPT_Wmaybe_uninitialized, use,\n@@ -250,9 +244,9 @@ warn_uninitialized_vars (bool warn_possibly_uninitialized)\n \n /* Checks if the operand OPND of PHI is defined by\n    another phi with one operand defined by this PHI,\n-   but the rest operands are all defined. If yes,\n+   but the rest operands are all defined.  If yes,\n    returns true to skip this operand as being\n-   redundant. Can be enhanced to be more general.  */\n+   redundant.  Can be enhanced to be more general.  */\n \n static bool\n can_skip_redundant_opnd (tree opnd, gimple *phi)\n@@ -318,37 +312,35 @@ compute_uninit_opnds_pos (gphi *phi)\n static inline basic_block\n find_pdom (basic_block block)\n {\n-   if (block == EXIT_BLOCK_PTR_FOR_FN (cfun))\n-     return EXIT_BLOCK_PTR_FOR_FN (cfun);\n-   else\n-     {\n-       basic_block bb\n-\t   = get_immediate_dominator (CDI_POST_DOMINATORS, block);\n-       if (! bb)\n-\t return EXIT_BLOCK_PTR_FOR_FN (cfun);\n-       return bb;\n-     }\n+  if (block == EXIT_BLOCK_PTR_FOR_FN (cfun))\n+    return EXIT_BLOCK_PTR_FOR_FN (cfun);\n+  else\n+    {\n+      basic_block bb = get_immediate_dominator (CDI_POST_DOMINATORS, block);\n+      if (!bb)\n+\treturn EXIT_BLOCK_PTR_FOR_FN (cfun);\n+      return bb;\n+    }\n }\n \n-/* Find the immediate DOM of the specified\n-   basic block BLOCK.  */\n+/* Find the immediate DOM of the specified basic block BLOCK.  */\n \n static inline basic_block\n find_dom (basic_block block)\n {\n-   if (block == ENTRY_BLOCK_PTR_FOR_FN (cfun))\n-     return ENTRY_BLOCK_PTR_FOR_FN (cfun);\n-   else\n-     {\n-       basic_block bb = get_immediate_dominator (CDI_DOMINATORS, block);\n-       if (! bb)\n-\t return ENTRY_BLOCK_PTR_FOR_FN (cfun);\n-       return bb;\n-     }\n+  if (block == ENTRY_BLOCK_PTR_FOR_FN (cfun))\n+    return ENTRY_BLOCK_PTR_FOR_FN (cfun);\n+  else\n+    {\n+      basic_block bb = get_immediate_dominator (CDI_DOMINATORS, block);\n+      if (!bb)\n+\treturn ENTRY_BLOCK_PTR_FOR_FN (cfun);\n+      return bb;\n+    }\n }\n \n /* Returns true if BB1 is postdominating BB2 and BB1 is\n-   not a loop exit bb. The loop exit bb check is simple and does\n+   not a loop exit bb.  The loop exit bb check is simple and does\n    not cover all cases.  */\n \n static bool\n@@ -366,7 +358,7 @@ is_non_loop_exit_postdominating (basic_block bb1, basic_block bb2)\n /* Find the closest postdominator of a specified BB, which is control\n    equivalent to BB.  */\n \n-static inline  basic_block\n+static inline basic_block\n find_control_equiv_block (basic_block bb)\n {\n   basic_block pdom;\n@@ -424,7 +416,7 @@ compute_control_dep_chain (basic_block bb, basic_block dep_bb,\n   for (i = 0; i < cur_chain_len; i++)\n     {\n       edge e = (*cur_cd_chain)[i];\n-      /* Cycle detected. */\n+      /* Cycle detected.  */\n       if (e->src == bb)\n \treturn false;\n     }\n@@ -454,17 +446,17 @@ compute_control_dep_chain (basic_block bb, basic_block dep_bb,\n \t    }\n \n \t  /* Now check if DEP_BB is indirectly control dependent on BB.  */\n-\t  if (compute_control_dep_chain (cd_bb, dep_bb, cd_chains,\n-\t\t\t\t\t num_chains, cur_cd_chain, num_calls))\n+\t  if (compute_control_dep_chain (cd_bb, dep_bb, cd_chains, num_chains,\n+\t\t\t\t\t cur_cd_chain, num_calls))\n \t    {\n \t      found_cd_chain = true;\n \t      break;\n \t    }\n \n \t  cd_bb = find_pdom (cd_bb);\n \t  post_dom_check++;\n-\t  if (cd_bb == EXIT_BLOCK_PTR_FOR_FN (cfun) || post_dom_check >\n-\t      MAX_POSTDOM_CHECK)\n+\t  if (cd_bb == EXIT_BLOCK_PTR_FOR_FN (cfun)\n+\t      || post_dom_check > MAX_POSTDOM_CHECK)\n \t    break;\n \t}\n       cur_cd_chain->pop ();\n@@ -475,7 +467,7 @@ compute_control_dep_chain (basic_block bb, basic_block dep_bb,\n   return found_cd_chain;\n }\n \n-/* The type to represent a simple predicate  */\n+/* The type to represent a simple predicate.  */\n \n struct pred_info\n {\n@@ -496,13 +488,13 @@ typedef vec<pred_info, va_heap, vl_ptr> pred_chain;\n typedef vec<pred_chain, va_heap, vl_ptr> pred_chain_union;\n \n /* Converts the chains of control dependence edges into a set of\n-   predicates. A control dependence chain is represented by a vector\n-   edges. DEP_CHAINS points to an array of dependence chains.\n-   NUM_CHAINS is the size of the chain array. One edge in a dependence\n+   predicates.  A control dependence chain is represented by a vector\n+   edges.  DEP_CHAINS points to an array of dependence chains.\n+   NUM_CHAINS is the size of the chain array.  One edge in a dependence\n    chain is mapped to predicate expression represented by pred_info\n-   type. One dependence chain is converted to a composite predicate that\n+   type.  One dependence chain is converted to a composite predicate that\n    is the result of AND operation of pred_info mapped to each edge.\n-   A composite predicate is presented by a vector of pred_info. On\n+   A composite predicate is presented by a vector of pred_info.  On\n    return, *PREDS points to the resulting array of composite predicates.\n    *NUM_PREDS is the number of composite predictes.  */\n \n@@ -543,13 +535,9 @@ convert_control_dep_chain_into_preds (vec<edge> *dep_chains,\n \t      break;\n \t    }\n \t  cond_stmt = gsi_stmt (gsi);\n-\t  if (is_gimple_call (cond_stmt)\n-\t      && EDGE_COUNT (e->src->succs) >= 2)\n-\t    {\n-\t      /* Ignore EH edge. Can add assertion\n-\t\t on the other edge's flag.  */\n-\t      continue;\n-\t    }\n+\t  if (is_gimple_call (cond_stmt) && EDGE_COUNT (e->src->succs) >= 2)\n+\t    /* Ignore EH edge.  Can add assertion on the other edge's flag.  */\n+\t    continue;\n \t  /* Skip if there is essentially one succesor.  */\n \t  if (EDGE_COUNT (e->src->succs) == 2)\n \t    {\n@@ -577,7 +565,7 @@ convert_control_dep_chain_into_preds (vec<edge> *dep_chains,\n \t      t_chain.safe_push (one_pred);\n \t      has_valid_pred = true;\n \t    }\n-\t  else if (gswitch *gs = dyn_cast <gswitch *> (cond_stmt))\n+\t  else if (gswitch *gs = dyn_cast<gswitch *> (cond_stmt))\n \t    {\n \t      /* Avoid quadratic behavior.  */\n \t      if (gimple_switch_num_labels (gs) > MAX_SWITCH_CASES)\n@@ -607,8 +595,8 @@ convert_control_dep_chain_into_preds (vec<edge> *dep_chains,\n \t\t fail.  */\n \t      if (!l\n \t\t  || !CASE_LOW (l)\n-\t\t  || (CASE_HIGH (l) && !operand_equal_p (CASE_LOW (l),\n-\t\t\t\t\t\t\t CASE_HIGH (l), 0)))\n+\t\t  || (CASE_HIGH (l)\n+\t\t      && !operand_equal_p (CASE_LOW (l), CASE_HIGH (l), 0)))\n \t\t{\n \t\t  has_valid_pred = false;\n \t\t  break;\n@@ -635,7 +623,7 @@ convert_control_dep_chain_into_preds (vec<edge> *dep_chains,\n   return has_valid_pred;\n }\n \n-/* Computes all control dependence chains for USE_BB. The control\n+/* Computes all control dependence chains for USE_BB.  The control\n    dependence chains are then converted to an array of composite\n    predicates pointed to by PREDS.  PHI_BB is the basic block of\n    the phi whose result is used in USE_BB.  */\n@@ -676,8 +664,8 @@ find_predicates (pred_chain_union *preds,\n \n /* Computes the set of incoming edges of PHI that have non empty\n    definitions of a phi chain.  The collection will be done\n-   recursively on operands that are defined by phis. CD_ROOT\n-   is the control dependence root. *EDGES holds the result, and\n+   recursively on operands that are defined by phis.  CD_ROOT\n+   is the control dependence root.  *EDGES holds the result, and\n    VISITED_PHIS is a pointer set for detecting cycles.  */\n \n static void\n@@ -702,7 +690,7 @@ collect_phi_def_edges (gphi *phi, basic_block cd_root,\n \t{\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    {\n-\t      fprintf (dump_file, \"\\n[CHECK] Found def edge %d in \", (int)i);\n+\t      fprintf (dump_file, \"\\n[CHECK] Found def edge %d in \", (int) i);\n \t      print_gimple_stmt (dump_file, phi, 0, 0);\n \t    }\n \t  edges->safe_push (opnd_edge);\n@@ -712,15 +700,15 @@ collect_phi_def_edges (gphi *phi, basic_block cd_root,\n \t  gimple *def = SSA_NAME_DEF_STMT (opnd);\n \n \t  if (gimple_code (def) == GIMPLE_PHI\n-\t      && dominated_by_p (CDI_DOMINATORS,\n-\t\t\t\t gimple_bb (def), cd_root))\n-\t    collect_phi_def_edges (as_a <gphi *> (def), cd_root, edges,\n+\t      && dominated_by_p (CDI_DOMINATORS, gimple_bb (def), cd_root))\n+\t    collect_phi_def_edges (as_a<gphi *> (def), cd_root, edges,\n \t\t\t\t   visited_phis);\n \t  else if (!uninit_undefined_value_p (opnd))\n \t    {\n \t      if (dump_file && (dump_flags & TDF_DETAILS))\n \t\t{\n-\t\t  fprintf (dump_file, \"\\n[CHECK] Found def edge %d in \", (int)i);\n+\t\t  fprintf (dump_file, \"\\n[CHECK] Found def edge %d in \",\n+\t\t\t   (int) i);\n \t\t  print_gimple_stmt (dump_file, phi, 0, 0);\n \t\t}\n \t      edges->safe_push (opnd_edge);\n@@ -745,7 +733,7 @@ find_def_preds (pred_chain_union *preds, gphi *phi)\n \n   phi_bb = gimple_bb (phi);\n   /* First find the closest dominating bb to be\n-     the control dependence root  */\n+     the control dependence root.  */\n   cd_root = find_dom (phi_bb);\n   if (!cd_root)\n     return false;\n@@ -789,8 +777,7 @@ find_def_preds (pred_chain_union *preds, gphi *phi)\n /* Dumps the predicates (PREDS) for USESTMT.  */\n \n static void\n-dump_predicates (gimple *usestmt, pred_chain_union preds,\n-\t\t const char* msg)\n+dump_predicates (gimple *usestmt, pred_chain_union preds, const char *msg)\n {\n   size_t i, j;\n   pred_chain one_pred_chain = vNULL;\n@@ -839,13 +826,11 @@ destroy_predicate_vecs (pred_chain_union *preds)\n   preds->release ();\n }\n \n-\n /* Computes the 'normalized' conditional code with operand\n    swapping and condition inversion.  */\n \n static enum tree_code\n-get_cmp_code (enum tree_code orig_cmp_code,\n-\t      bool swap_cond, bool invert)\n+get_cmp_code (enum tree_code orig_cmp_code, bool swap_cond, bool invert)\n {\n   enum tree_code tc = orig_cmp_code;\n \n@@ -880,14 +865,12 @@ is_value_included_in (tree val, tree boundary, enum tree_code cmpc)\n   bool result;\n \n   /* Only handle integer constant here.  */\n-  if (TREE_CODE (val) != INTEGER_CST\n-      || TREE_CODE (boundary) != INTEGER_CST)\n+  if (TREE_CODE (val) != INTEGER_CST || TREE_CODE (boundary) != INTEGER_CST)\n     return true;\n \n   is_unsigned = TYPE_UNSIGNED (TREE_TYPE (val));\n \n-  if (cmpc == GE_EXPR || cmpc == GT_EXPR\n-      || cmpc == NE_EXPR)\n+  if (cmpc == GE_EXPR || cmpc == GT_EXPR || cmpc == NE_EXPR)\n     {\n       cmpc = invert_tree_comparison (cmpc, false);\n       inverted = true;\n@@ -949,7 +932,7 @@ find_matching_predicate_in_rest_chains (pred_info pred,\n \t{\n \t  pred_info pred2 = one_chain[j];\n \t  /* Can relax the condition comparison to not\n-\t     use address comparison. However, the most common\n+\t     use address comparison.  However, the most common\n \t     case is that multiple control dependent paths share\n \t     a common path prefix, so address comparison should\n \t     be ok.  */\n@@ -969,16 +952,15 @@ find_matching_predicate_in_rest_chains (pred_info pred,\n }\n \n /* Forward declaration.  */\n-static bool\n-is_use_properly_guarded (gimple *use_stmt,\n-\t\t\t basic_block use_bb,\n-\t\t\t gphi *phi,\n-\t\t\t unsigned uninit_opnds,\n-\t\t\t pred_chain_union *def_preds,\n-\t\t\t hash_set<gphi *> *visited_phis);\n-\n-/* Returns true if all uninitialized opnds are pruned. Returns false\n-   otherwise. PHI is the phi node with uninitialized operands,\n+static bool is_use_properly_guarded (gimple *use_stmt,\n+\t\t\t\t     basic_block use_bb,\n+\t\t\t\t     gphi *phi,\n+\t\t\t\t     unsigned uninit_opnds,\n+\t\t\t\t     pred_chain_union *def_preds,\n+\t\t\t\t     hash_set<gphi *> *visited_phis);\n+\n+/* Returns true if all uninitialized opnds are pruned.  Returns false\n+   otherwise.  PHI is the phi node with uninitialized operands,\n    UNINIT_OPNDS is the bitmap of the uninitialize operand positions,\n    FLAG_DEF is the statement defining the flag guarding the use of the\n    PHI output, BOUNDARY_CST is the const value used in the predicate\n@@ -990,7 +972,7 @@ is_use_properly_guarded (gimple *use_stmt,\n    Example scenario:\n \n    BB1:\n-   flag_1 = phi <0, 1>\t\t  // (1)\n+   flag_1 = phi <0, 1>\t\t\t// (1)\n    var_1  = phi <undef, some_val>\n \n \n@@ -1001,24 +983,20 @@ is_use_properly_guarded (gimple *use_stmt,\n       goto BB3;\n \n    BB3:\n-   use of var_2\t\t\t // (3)\n+   use of var_2\t\t\t\t// (3)\n \n    Because some flag arg in (1) is not constant, if we do not look into the\n    flag phis recursively, it is conservatively treated as unknown and var_1\n-   is thought to be flowed into use at (3). Since var_1 is potentially uninitialized\n-   a false warning will be emitted. Checking recursively into (1), the compiler can\n-   find out that only some_val (which is defined) can flow into (3) which is OK.\n-\n-*/\n+   is thought to be flowed into use at (3).  Since var_1 is potentially\n+   uninitialized a false warning will be emitted.\n+   Checking recursively into (1), the compiler can find out that only some_val\n+   (which is defined) can flow into (3) which is OK.  */\n \n static bool\n-prune_uninit_phi_opnds_in_unrealizable_paths (gphi *phi,\n-\t\t\t\t\t      unsigned uninit_opnds,\n-\t\t\t\t\t      gphi *flag_def,\n-\t\t\t\t\t      tree boundary_cst,\n-\t\t\t\t\t      enum tree_code cmp_code,\n-\t\t\t\t\t      hash_set<gphi *> *visited_phis,\n-\t\t\t\t\t      bitmap *visited_flag_phis)\n+prune_uninit_phi_opnds (gphi *phi, unsigned uninit_opnds, gphi *flag_def,\n+\t\t\ttree boundary_cst, enum tree_code cmp_code,\n+\t\t\thash_set<gphi *> *visited_phis,\n+\t\t\tbitmap *visited_flag_phis)\n {\n   unsigned i;\n \n@@ -1038,15 +1016,15 @@ prune_uninit_phi_opnds_in_unrealizable_paths (gphi *phi,\n \n \t  if (TREE_CODE (flag_arg) != SSA_NAME)\n \t    return false;\n-\t  flag_arg_def = dyn_cast <gphi *> (SSA_NAME_DEF_STMT (flag_arg));\n+\t  flag_arg_def = dyn_cast<gphi *> (SSA_NAME_DEF_STMT (flag_arg));\n \t  if (!flag_arg_def)\n \t    return false;\n \n \t  phi_arg = gimple_phi_arg_def (phi, i);\n \t  if (TREE_CODE (phi_arg) != SSA_NAME)\n \t    return false;\n \n-\t  phi_arg_def = dyn_cast <gphi *> (SSA_NAME_DEF_STMT (phi_arg));\n+\t  phi_arg_def = dyn_cast<gphi *> (SSA_NAME_DEF_STMT (phi_arg));\n \t  if (!phi_arg_def)\n \t    return false;\n \n@@ -1056,22 +1034,22 @@ prune_uninit_phi_opnds_in_unrealizable_paths (gphi *phi,\n \t  if (!*visited_flag_phis)\n \t    *visited_flag_phis = BITMAP_ALLOC (NULL);\n \n-\t  if (bitmap_bit_p (*visited_flag_phis,\n-\t\t\t    SSA_NAME_VERSION (gimple_phi_result (flag_arg_def))))\n+\t  tree phi_result = gimple_phi_result (flag_arg_def);\n+\t  if (bitmap_bit_p (*visited_flag_phis, SSA_NAME_VERSION (phi_result)))\n \t    return false;\n \n \t  bitmap_set_bit (*visited_flag_phis,\n \t\t\t  SSA_NAME_VERSION (gimple_phi_result (flag_arg_def)));\n \n \t  /* Now recursively prune the uninitialized phi args.  */\n \t  uninit_opnds_arg_phi = compute_uninit_opnds_pos (phi_arg_def);\n-\t  if (!prune_uninit_phi_opnds_in_unrealizable_paths\n-\t\t (phi_arg_def, uninit_opnds_arg_phi, flag_arg_def,\n-\t\t  boundary_cst, cmp_code, visited_phis, visited_flag_phis))\n+\t  if (!prune_uninit_phi_opnds\n+\t      (phi_arg_def, uninit_opnds_arg_phi, flag_arg_def, boundary_cst,\n+\t       cmp_code, visited_phis, visited_flag_phis))\n \t    return false;\n \n-\t  bitmap_clear_bit (*visited_flag_phis,\n-\t\t\t    SSA_NAME_VERSION (gimple_phi_result (flag_arg_def)));\n+\t  phi_result = gimple_phi_result (flag_arg_def);\n+\t  bitmap_clear_bit (*visited_flag_phis, SSA_NAME_VERSION (phi_result));\n \t  continue;\n \t}\n \n@@ -1082,7 +1060,7 @@ prune_uninit_phi_opnds_in_unrealizable_paths (gphi *phi,\n \t  gimple *opnd_def;\n \n \t  /* Now that we know that this undefined edge is not\n-\t     pruned. If the operand is defined by another phi,\n+\t     pruned.  If the operand is defined by another phi,\n \t     we can further prune the incoming edges of that\n \t     phi by checking the predicates of this operands.  */\n \n@@ -1091,8 +1069,7 @@ prune_uninit_phi_opnds_in_unrealizable_paths (gphi *phi,\n \t  if (gphi *opnd_def_phi = dyn_cast <gphi *> (opnd_def))\n \t    {\n \t      edge opnd_edge;\n-\t      unsigned uninit_opnds2\n-\t\t  = compute_uninit_opnds_pos (opnd_def_phi);\n+\t      unsigned uninit_opnds2 = compute_uninit_opnds_pos (opnd_def_phi);\n \t      if (!MASK_EMPTY (uninit_opnds2))\n \t\t{\n \t\t  pred_chain_union def_preds = vNULL;\n@@ -1143,11 +1120,11 @@ prune_uninit_phi_opnds_in_unrealizable_paths (gphi *phi,\n \t     return true;\n \t }\n \n-\t void foo(..)\n+\t void foo (..)\n \t {\n \t     int x;\n \n-\t     if (!init_func(&x))\n+\t     if (!init_func (&x))\n \t\treturn;\n \n \t     .. some_code ...\n@@ -1179,26 +1156,25 @@ prune_uninit_phi_opnds_in_unrealizable_paths (gphi *phi,\n \t<==> false\n \n      This implementation provides framework that can handle\n-     scenarios. (Note that many simple cases are handled properly\n+     scenarios.  (Note that many simple cases are handled properly\n      without the predicate analysis -- this is due to jump threading\n      transformation which eliminates the merge point thus makes\n      path sensitive analysis unnecessary.)\n \n      NUM_PREDS is the number is the number predicate chains, PREDS is\n      the array of chains, PHI is the phi node whose incoming (undefined)\n      paths need to be pruned, and UNINIT_OPNDS is the bitmap holding\n-     uninit operand positions. VISITED_PHIS is the pointer set of phi\n+     uninit operand positions.  VISITED_PHIS is the pointer set of phi\n      stmts being checked.  */\n \n-\n static bool\n use_pred_not_overlap_with_undef_path_pred (pred_chain_union preds,\n \t\t\t\t\t   gphi *phi, unsigned uninit_opnds,\n \t\t\t\t\t   hash_set<gphi *> *visited_phis)\n {\n   unsigned int i, n;\n   gimple *flag_def = 0;\n-  tree  boundary_cst = 0;\n+  tree boundary_cst = 0;\n   enum tree_code cmp_code;\n   bool swap_cond = false;\n   bool invert = false;\n@@ -1265,13 +1241,9 @@ use_pred_not_overlap_with_undef_path_pred (pred_chain_union preds,\n   if (cmp_code == ERROR_MARK)\n     return false;\n \n-  all_pruned = prune_uninit_phi_opnds_in_unrealizable_paths (phi,\n-\t\t\t\t\t\t\t     uninit_opnds,\n-\t\t\t\t\t\t\t     as_a <gphi *> (flag_def),\n-\t\t\t\t\t\t\t     boundary_cst,\n-\t\t\t\t\t\t\t     cmp_code,\n-\t\t\t\t\t\t\t     visited_phis,\n-\t\t\t\t\t\t\t     &visited_flag_phis);\n+  all_pruned = prune_uninit_phi_opnds\n+    (phi, uninit_opnds, as_a<gphi *> (flag_def), boundary_cst, cmp_code,\n+     visited_phis, &visited_flag_phis);\n \n   if (visited_flag_phis)\n     BITMAP_FREE (visited_flag_phis);\n@@ -1280,7 +1252,7 @@ use_pred_not_overlap_with_undef_path_pred (pred_chain_union preds,\n }\n \n /* The helper function returns true if two predicates X1 and X2\n-   are equivalent. It assumes the expressions have already\n+   are equivalent.  It assumes the expressions have already\n    properly re-associated.  */\n \n static inline bool\n@@ -1307,8 +1279,8 @@ static inline bool\n is_neq_relop_p (pred_info pred)\n {\n \n-  return (pred.cond_code == NE_EXPR && !pred.invert)\n-\t  || (pred.cond_code == EQ_EXPR && pred.invert);\n+  return ((pred.cond_code == NE_EXPR && !pred.invert)\n+\t  || (pred.cond_code == EQ_EXPR && pred.invert));\n }\n \n /* Returns true if pred is of the form X != 0.  */\n@@ -1335,7 +1307,7 @@ pred_expr_equal_p (pred_info x1, tree x2)\n }\n \n /* Returns true of the domain of single predicate expression\n-   EXPR1 is a subset of that of EXPR2. Returns false if it\n+   EXPR1 is a subset of that of EXPR2.  Returns false if it\n    can not be proved.  */\n \n static bool\n@@ -1360,8 +1332,7 @@ is_pred_expr_subset_of (pred_info expr1, pred_info expr2)\n   if (expr2.invert)\n     code2 = invert_tree_comparison (code2, false);\n \n-  if ((code1 == EQ_EXPR || code1 == BIT_AND_EXPR)\n-      && code2 == BIT_AND_EXPR)\n+  if ((code1 == EQ_EXPR || code1 == BIT_AND_EXPR) && code2 == BIT_AND_EXPR)\n     return wi::eq_p (expr1.pred_rhs,\n \t\t     wi::bit_and (expr1.pred_rhs, expr2.pred_rhs));\n \n@@ -1375,11 +1346,10 @@ is_pred_expr_subset_of (pred_info expr1, pred_info expr2)\n }\n \n /* Returns true if the domain of PRED1 is a subset\n-   of that of PRED2. Returns false if it can not be proved so.  */\n+   of that of PRED2.  Returns false if it can not be proved so.  */\n \n static bool\n-is_pred_chain_subset_of (pred_chain pred1,\n-\t\t\t pred_chain pred2)\n+is_pred_chain_subset_of (pred_chain pred1, pred_chain pred2)\n {\n   size_t np1, np2, i1, i2;\n \n@@ -1407,7 +1377,7 @@ is_pred_chain_subset_of (pred_chain pred1,\n \n /* Returns true if the domain defined by\n    one pred chain ONE_PRED is a subset of the domain\n-   of *PREDS. It returns false if ONE_PRED's domain is\n+   of *PREDS.  It returns false if ONE_PRED's domain is\n    not a subset of any of the sub-domains of PREDS\n    (corresponding to each individual chains in it), even\n    though it may be still be a subset of whole domain\n@@ -1431,15 +1401,15 @@ is_included_in (pred_chain one_pred, pred_chain_union preds)\n \n /* Compares two predicate sets PREDS1 and PREDS2 and returns\n    true if the domain defined by PREDS1 is a superset\n-   of PREDS2's domain. N1 and N2 are array sizes of PREDS1 and\n-   PREDS2 respectively. The implementation chooses not to build\n+   of PREDS2's domain.  N1 and N2 are array sizes of PREDS1 and\n+   PREDS2 respectively.  The implementation chooses not to build\n    generic trees (and relying on the folding capability of the\n    compiler), but instead performs brute force comparison of\n    individual predicate chains (won't be a compile time problem\n-   as the chains are pretty short). When the function returns\n+   as the chains are pretty short).  When the function returns\n    false, it does not necessarily mean *PREDS1 is not a superset\n    of *PREDS2, but mean it may not be so since the analysis can\n-   not prove it. In such cases, false warnings may still be\n+   not prove it.  In such cases, false warnings may still be\n    emitted.  */\n \n static bool\n@@ -1536,19 +1506,19 @@ simplify_pred (pred_chain *one_chain)\n \n \t      if (pred_expr_equal_p (*b_pred, gimple_assign_rhs1 (def_stmt))\n \t\t  || pred_expr_equal_p (*b_pred, gimple_assign_rhs2 (def_stmt)))\n-\t\t {\n-\t\t   /* Mark a_pred for removal.  */\n-\t\t   a_pred->pred_lhs = NULL;\n-\t\t   a_pred->pred_rhs = NULL;\n-\t\t   simplified = true;\n-\t\t   break;\n-\t\t }\n+\t\t{\n+\t\t  /* Mark a_pred for removal.  */\n+\t\t  a_pred->pred_lhs = NULL;\n+\t\t  a_pred->pred_rhs = NULL;\n+\t\t  simplified = true;\n+\t\t  break;\n+\t\t}\n \t    }\n \t}\n     }\n \n   if (!simplified)\n-     return;\n+    return;\n \n   for (i = 0; i < n; i++)\n     {\n@@ -1558,8 +1528,8 @@ simplify_pred (pred_chain *one_chain)\n       s_chain.safe_push (*a_pred);\n     }\n \n-   one_chain->release ();\n-   *one_chain = s_chain;\n+  one_chain->release ();\n+  *one_chain = s_chain;\n }\n \n /* The helper function implements the rule 2 for the\n@@ -1746,8 +1716,7 @@ simplify_preds_4 (pred_chain_union *preds)\n \n \t  x2 = (*b_chain)[0];\n \t  y2 = (*b_chain)[1];\n-\t  if (!is_neq_zero_form_p (x2)\n-\t      || !is_neq_zero_form_p (y2))\n+\t  if (!is_neq_zero_form_p (x2) || !is_neq_zero_form_p (y2))\n \t    continue;\n \n \t  if ((pred_expr_equal_p (x2, gimple_assign_rhs1 (def_stmt))\n@@ -1780,7 +1749,6 @@ simplify_preds_4 (pred_chain_union *preds)\n   return simplified;\n }\n \n-\n /* This function simplifies predicates in PREDS.  */\n \n static void\n@@ -1815,14 +1783,14 @@ simplify_preds (pred_chain_union *preds, gimple *use_or_def, bool is_use)\n \n       if (simplify_preds_4 (preds))\n \tchanged = true;\n-\n-    } while (changed);\n+    }\n+  while (changed);\n \n   return;\n }\n \n /* This is a helper function which attempts to normalize predicate chains\n-  by following UD chains. It basically builds up a big tree of either IOR\n+  by following UD chains.  It basically builds up a big tree of either IOR\n   operations or AND operations, and convert the IOR tree into a\n   pred_chain_union or BIT_AND tree into a pred_chain.\n   Example:\n@@ -1895,7 +1863,7 @@ get_pred_info_from_cmp (gimple *cmp_assign)\n }\n \n /* Returns true if the PHI is a degenerated phi with\n-   all args with the same value (relop). In that case, *PRED\n+   all args with the same value (relop).  In that case, *PRED\n    will be updated to that value.  */\n \n static bool\n@@ -1915,8 +1883,7 @@ is_degenerated_phi (gimple *phi, pred_info *pred_p)\n   def0 = SSA_NAME_DEF_STMT (op0);\n   if (gimple_code (def0) != GIMPLE_ASSIGN)\n     return false;\n-  if (TREE_CODE_CLASS (gimple_assign_rhs_code (def0))\n-      != tcc_comparison)\n+  if (TREE_CODE_CLASS (gimple_assign_rhs_code (def0)) != tcc_comparison)\n     return false;\n   pred0 = get_pred_info_from_cmp (def0);\n \n@@ -1932,8 +1899,7 @@ is_degenerated_phi (gimple *phi, pred_info *pred_p)\n       def = SSA_NAME_DEF_STMT (op);\n       if (gimple_code (def) != GIMPLE_ASSIGN)\n \treturn false;\n-      if (TREE_CODE_CLASS (gimple_assign_rhs_code (def))\n-\t  != tcc_comparison)\n+      if (TREE_CODE_CLASS (gimple_assign_rhs_code (def)) != tcc_comparison)\n \treturn false;\n       pred = get_pred_info_from_cmp (def);\n       if (!pred_equal_p (pred, pred0))\n@@ -1971,13 +1937,12 @@ normalize_one_pred_1 (pred_chain_union *norm_preds,\n   if (gimple_code (def_stmt) == GIMPLE_PHI\n       && is_degenerated_phi (def_stmt, &pred))\n     work_list->safe_push (pred);\n-  else if (gimple_code (def_stmt) == GIMPLE_PHI\n-\t   && and_or_code == BIT_IOR_EXPR)\n+  else if (gimple_code (def_stmt) == GIMPLE_PHI && and_or_code == BIT_IOR_EXPR)\n     {\n       int i, n;\n       n = gimple_phi_num_args (def_stmt);\n \n-      /* If we see non zero constant, we should punt. The predicate\n+      /* If we see non zero constant, we should punt.  The predicate\n        * should be one guarding the phi edge.  */\n       for (i = 0; i < n; ++i)\n \t{\n@@ -2048,8 +2013,7 @@ normalize_one_pred_1 (pred_chain_union *norm_preds,\n /* Normalize PRED and store the normalized predicates into NORM_PREDS.  */\n \n static void\n-normalize_one_pred (pred_chain_union *norm_preds,\n-\t\t    pred_info pred)\n+normalize_one_pred (pred_chain_union *norm_preds, pred_info pred)\n {\n   vec<pred_info, va_heap, vl_ptr> work_list = vNULL;\n   enum tree_code and_or_code = ERROR_MARK;\n@@ -2064,17 +2028,15 @@ normalize_one_pred (pred_chain_union *norm_preds,\n   gimple *def_stmt = SSA_NAME_DEF_STMT (pred.pred_lhs);\n   if (gimple_code (def_stmt) == GIMPLE_ASSIGN)\n     and_or_code = gimple_assign_rhs_code (def_stmt);\n-  if (and_or_code != BIT_IOR_EXPR\n-      && and_or_code != BIT_AND_EXPR)\n+  if (and_or_code != BIT_IOR_EXPR && and_or_code != BIT_AND_EXPR)\n     {\n-      if (TREE_CODE_CLASS (and_or_code)\n-\t  == tcc_comparison)\n+      if (TREE_CODE_CLASS (and_or_code) == tcc_comparison)\n \t{\n \t  pred_info n_pred = get_pred_info_from_cmp (def_stmt);\n \t  push_pred (norm_preds, n_pred);\n \t}\n-       else\n-\t  push_pred (norm_preds, pred);\n+      else\n+\tpush_pred (norm_preds, pred);\n       return;\n     }\n \n@@ -2084,8 +2046,8 @@ normalize_one_pred (pred_chain_union *norm_preds,\n   while (!work_list.is_empty ())\n     {\n       pred_info a_pred = work_list.pop ();\n-      normalize_one_pred_1 (norm_preds, &norm_chain, a_pred,\n-\t\t\t    and_or_code, &work_list, &mark_set);\n+      normalize_one_pred_1 (norm_preds, &norm_chain, a_pred, and_or_code,\n+\t\t\t    &work_list, &mark_set);\n     }\n   if (and_or_code == BIT_AND_EXPR)\n     norm_preds->safe_push (norm_chain);\n@@ -2094,8 +2056,7 @@ normalize_one_pred (pred_chain_union *norm_preds,\n }\n \n static void\n-normalize_one_pred_chain (pred_chain_union *norm_preds,\n-\t\t\t  pred_chain one_chain)\n+normalize_one_pred_chain (pred_chain_union *norm_preds, pred_chain one_chain)\n {\n   vec<pred_info, va_heap, vl_ptr> work_list = vNULL;\n   hash_set<tree> mark_set;\n@@ -2111,8 +2072,8 @@ normalize_one_pred_chain (pred_chain_union *norm_preds,\n   while (!work_list.is_empty ())\n     {\n       pred_info a_pred = work_list.pop ();\n-      normalize_one_pred_1 (0, &norm_chain, a_pred,\n-\t\t\t    BIT_AND_EXPR, &work_list, &mark_set);\n+      normalize_one_pred_1 (0, &norm_chain, a_pred, BIT_AND_EXPR, &work_list,\n+\t\t\t    &mark_set);\n     }\n \n   norm_preds->safe_push (norm_chain);\n@@ -2148,26 +2109,26 @@ normalize_preds (pred_chain_union preds, gimple *use_or_def, bool is_use)\n   if (dump_file)\n     {\n       fprintf (dump_file, \"[AFTER NORMALIZATION -- \");\n-      dump_predicates (use_or_def, norm_preds, is_use ? \"[USE]:\\n\" : \"[DEF]:\\n\");\n+      dump_predicates (use_or_def, norm_preds,\n+\t\t       is_use ? \"[USE]:\\n\" : \"[DEF]:\\n\");\n     }\n \n   destroy_predicate_vecs (&preds);\n   return norm_preds;\n }\n \n-\n /* Computes the predicates that guard the use and checks\n    if the incoming paths that have empty (or possibly\n-   empty) definition can be pruned/filtered. The function returns\n+   empty) definition can be pruned/filtered.  The function returns\n    true if it can be determined that the use of PHI's def in\n    USE_STMT is guarded with a predicate set not overlapping with\n    predicate sets of all runtime paths that do not have a definition.\n \n-   Returns false if it is not or it can not be determined. USE_BB is\n+   Returns false if it is not or it can not be determined.  USE_BB is\n    the bb of the use (for phi operand use, the bb is not the bb of\n    the phi stmt, but the src bb of the operand edge).\n \n-   UNINIT_OPNDS is a bit vector. If an operand of PHI is uninitialized, the\n+   UNINIT_OPNDS is a bit vector.  If an operand of PHI is uninitialized, the\n    corresponding bit in the vector is 1.  VISITED_PHIS is a pointer\n    set of phis being visited.\n \n@@ -2206,7 +2167,7 @@ is_use_properly_guarded (gimple *use_stmt,\n       return false;\n     }\n \n-  /* Try to prune the dead incoming phi edges. */\n+  /* Try to prune the dead incoming phi edges.  */\n   is_properly_guarded\n     = use_pred_not_overlap_with_undef_path_pred (preds, phi, uninit_opnds,\n \t\t\t\t\t\t visited_phis);\n@@ -2242,11 +2203,11 @@ is_use_properly_guarded (gimple *use_stmt,\n \n /* Searches through all uses of a potentially\n    uninitialized variable defined by PHI and returns a use\n-   statement if the use is not properly guarded. It returns\n-   NULL if all uses are guarded. UNINIT_OPNDS is a bitvector\n-   holding the position(s) of uninit PHI operands. WORKLIST\n+   statement if the use is not properly guarded.  It returns\n+   NULL if all uses are guarded.  UNINIT_OPNDS is a bitvector\n+   holding the position(s) of uninit PHI operands.  WORKLIST\n    is the vector of candidate phis that may be updated by this\n-   function. ADDED_TO_WORKLIST is the pointer set tracking\n+   function.  ADDED_TO_WORKLIST is the pointer set tracking\n    if the new phi is already in the worklist.  */\n \n static gimple *\n@@ -2271,7 +2232,7 @@ find_uninit_use (gphi *phi, unsigned uninit_opnds,\n       if (is_gimple_debug (use_stmt))\n \tcontinue;\n \n-      if (gphi *use_phi = dyn_cast <gphi *> (use_stmt))\n+      if (gphi *use_phi = dyn_cast<gphi *> (use_stmt))\n \tuse_bb = gimple_phi_arg_edge (use_phi,\n \t\t\t\t      PHI_ARG_INDEX_FROM_USE (use_p))->src;\n       else\n@@ -2296,15 +2257,15 @@ find_uninit_use (gphi *phi, unsigned uninit_opnds,\n \n       /* Found a phi use that is not guarded,\n \t add the phi to the worklist.  */\n-      if (!added_to_worklist->add (as_a <gphi *> (use_stmt)))\n+      if (!added_to_worklist->add (as_a<gphi *> (use_stmt)))\n \t{\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    {\n \t      fprintf (dump_file, \"[WORKLIST]: Update worklist with phi: \");\n \t      print_gimple_stmt (dump_file, use_stmt, 0, 0);\n \t    }\n \n-\t  worklist->safe_push (as_a <gphi *> (use_stmt));\n+\t  worklist->safe_push (as_a<gphi *> (use_stmt));\n \t  possibly_undefined_names->add (phi_result);\n \t}\n     }\n@@ -2315,10 +2276,10 @@ find_uninit_use (gphi *phi, unsigned uninit_opnds,\n \n /* Look for inputs to PHI that are SSA_NAMEs that have empty definitions\n    and gives warning if there exists a runtime path from the entry to a\n-   use of the PHI def that does not contain a definition. In other words,\n-   the warning is on the real use. The more dead paths that can be pruned\n-   by the compiler, the fewer false positives the warning is. WORKLIST\n-   is a vector of candidate phis to be examined. ADDED_TO_WORKLIST is\n+   use of the PHI def that does not contain a definition.  In other words,\n+   the warning is on the real use.  The more dead paths that can be pruned\n+   by the compiler, the fewer false positives the warning is.  WORKLIST\n+   is a vector of candidate phis to be examined.  ADDED_TO_WORKLIST is\n    a pointer set tracking if the new phi is added to the worklist or not.  */\n \n static void\n@@ -2337,7 +2298,7 @@ warn_uninitialized_phi (gphi *phi, vec<gphi *> *worklist,\n \n   uninit_opnds = compute_uninit_opnds_pos (phi);\n \n-  if  (MASK_EMPTY (uninit_opnds))\n+  if (MASK_EMPTY (uninit_opnds))\n     return;\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -2366,7 +2327,6 @@ warn_uninitialized_phi (gphi *phi, vec<gphi *> *worklist,\n \t       SSA_NAME_VAR (uninit_op),\n \t       \"%qD may be used uninitialized in this function\",\n \t       uninit_use_stmt, loc);\n-\n }\n \n static bool\n@@ -2398,7 +2358,7 @@ class pass_late_warn_uninitialized : public gimple_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  opt_pass * clone () { return new pass_late_warn_uninitialized (m_ctxt); }\n+  opt_pass *clone () { return new pass_late_warn_uninitialized (m_ctxt); }\n   virtual bool gate (function *) { return gate_warn_uninitialized (); }\n   virtual unsigned int execute (function *);\n \n@@ -2439,8 +2399,7 @@ pass_late_warn_uninitialized::execute (function *fun)\n \tfor (i = 0; i < n; ++i)\n \t  {\n \t    tree op = gimple_phi_arg_def (phi, i);\n-\t    if (TREE_CODE (op) == SSA_NAME\n-\t\t&& uninit_undefined_value_p (op))\n+\t    if (TREE_CODE (op) == SSA_NAME && uninit_undefined_value_p (op))\n \t      {\n \t\tworklist.safe_push (phi);\n \t\tadded_to_worklist.add (phi);\n@@ -2477,27 +2436,25 @@ make_pass_late_warn_uninitialized (gcc::context *ctxt)\n   return new pass_late_warn_uninitialized (ctxt);\n }\n \n-\n static unsigned int\n execute_early_warn_uninitialized (void)\n {\n   /* Currently, this pass runs always but\n-     execute_late_warn_uninitialized only runs with optimization. With\n+     execute_late_warn_uninitialized only runs with optimization.  With\n      optimization we want to warn about possible uninitialized as late\n      as possible, thus don't do it here.  However, without\n      optimization we need to warn here about \"may be uninitialized\".  */\n   calculate_dominance_info (CDI_POST_DOMINATORS);\n \n   warn_uninitialized_vars (/*warn_possibly_uninitialized=*/!optimize);\n \n-  /* Post-dominator information can not be reliably updated. Free it\n+  /* Post-dominator information can not be reliably updated.  Free it\n      after the use.  */\n \n   free_dominance_info (CDI_POST_DOMINATORS);\n   return 0;\n }\n \n-\n namespace {\n \n const pass_data pass_data_early_warn_uninitialized =\n@@ -2523,9 +2480,9 @@ class pass_early_warn_uninitialized : public gimple_opt_pass\n   /* opt_pass methods: */\n   virtual bool gate (function *) { return gate_warn_uninitialized (); }\n   virtual unsigned int execute (function *)\n-    {\n-      return execute_early_warn_uninitialized ();\n-    }\n+  {\n+    return execute_early_warn_uninitialized ();\n+  }\n \n }; // class pass_early_warn_uninitialized\n "}]}