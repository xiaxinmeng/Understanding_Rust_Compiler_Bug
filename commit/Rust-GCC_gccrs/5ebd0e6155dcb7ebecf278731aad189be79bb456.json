{"sha": "5ebd0e6155dcb7ebecf278731aad189be79bb456", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWViZDBlNjE1NWRjYjdlYmVjZjI3ODczMWFhZDE4OWJlNzliYjQ1Ng==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2015-02-26T20:21:38Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2015-02-26T20:21:38Z"}, "message": "re PR lto/64693 (PCH failed with --with-build-config=bootstrap-lto)\n\nFix PR ipa/64693\n\n\tPR ipa/64693\n\t* ipa-icf.c (symbol_compare_collection::symbol_compare_collection): New.\n\t(sem_item_optimizer::subdivide_classes_by_sensitive_refs): New function.\n\t(sem_item_optimizer::process_cong_reduction): Include division by\n\tsensitive references.\n\t* ipa-icf.h (struct symbol_compare_hashmap_traits): New class.\n\t* ipa-ref.c (ipa_ref::address_matters_p): New function.\n\t* ipa-ref.h (ipa_ref::address_matters_p): Likewise.\n\t* g++.dg/ipa/pr64146.C: Update expected results.\n\t* gcc.dg/ipa/ipa-icf-26.c: Update test.\n\t* gcc.dg/ipa/ipa-icf-33.c: Remove redundant line.\n\t* gcc.dg/ipa/ipa-icf-34.c: New test.\n\nCo-Authored-By: Jan Hubicka <hubicka@ucw.cz>\n\nFrom-SVN: r221031", "tree": {"sha": "31bd542ab4137d5e5826c62a637c3f0f03c24b46", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/31bd542ab4137d5e5826c62a637c3f0f03c24b46"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5ebd0e6155dcb7ebecf278731aad189be79bb456", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ebd0e6155dcb7ebecf278731aad189be79bb456", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ebd0e6155dcb7ebecf278731aad189be79bb456", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ebd0e6155dcb7ebecf278731aad189be79bb456/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ff5ed3f6def9e24f907c6b9df66b9a582b327ac9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff5ed3f6def9e24f907c6b9df66b9a582b327ac9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff5ed3f6def9e24f907c6b9df66b9a582b327ac9"}], "stats": {"total": 246, "additions": 241, "deletions": 5}, "files": [{"sha": "f303d0ad3ac0bc2cb4117d58c4a98145e1c462c8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ebd0e6155dcb7ebecf278731aad189be79bb456/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ebd0e6155dcb7ebecf278731aad189be79bb456/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5ebd0e6155dcb7ebecf278731aad189be79bb456", "patch": "@@ -1,3 +1,15 @@\n+2015-02-26  Martin Liska  <mliska@suse.cz>\n+\t    Jan Hubicka  <hubicka@ucw.cz>\n+\n+\tPR ipa/64693\n+\t* ipa-icf.c (symbol_compare_collection::symbol_compare_collection): New.\n+\t(sem_item_optimizer::subdivide_classes_by_sensitive_refs): New function.\n+\t(sem_item_optimizer::process_cong_reduction): Include division by\n+\tsensitive references.\n+\t* ipa-icf.h (struct symbol_compare_hashmap_traits): New class.\n+\t* ipa-ref.c (ipa_ref::address_matters_p): New function.\n+\t* ipa-ref.h (ipa_ref::address_matters_p): Likewise.\n+\n 2015-02-26  Georg-Johann Lay  <avr@gjlay.de>\n \n \tPR target/65192"}, {"sha": "1d6cbebdf9c327e01ed93f59095eaa642d618565", "filename": "gcc/ipa-icf.c", "status": "modified", "additions": 125, "deletions": 0, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ebd0e6155dcb7ebecf278731aad189be79bb456/gcc%2Fipa-icf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ebd0e6155dcb7ebecf278731aad189be79bb456/gcc%2Fipa-icf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf.c?ref=5ebd0e6155dcb7ebecf278731aad189be79bb456", "patch": "@@ -126,6 +126,44 @@ along with GCC; see the file COPYING3.  If not see\n using namespace ipa_icf_gimple;\n \n namespace ipa_icf {\n+\n+/* Constructor.  */\n+\n+symbol_compare_collection::symbol_compare_collection (symtab_node *node)\n+{\n+  m_references.create (0);\n+  m_interposables.create (0);\n+\n+  ipa_ref *ref;\n+\n+  if (is_a <varpool_node *> (node) && DECL_VIRTUAL_P (node->decl))\n+    return;\n+\n+  for (unsigned i = 0; i < node->num_references (); i++)\n+    {\n+      ref = node->iterate_reference (i, ref);\n+      if (ref->address_matters_p ())\n+\tm_references.safe_push (ref->referred);\n+\n+      if (ref->referred->get_availability () <= AVAIL_INTERPOSABLE)\n+        {\n+\t  if (ref->use == IPA_REF_ADDR)\n+\t    m_references.safe_push (ref->referred);\n+\t  else\n+\t    m_interposables.safe_push (ref->referred);\n+\t}\n+    }\n+\n+  if (is_a <cgraph_node *> (node))\n+    {\n+      cgraph_node *cnode = dyn_cast <cgraph_node *> (node);\n+\n+      for (cgraph_edge *e = cnode->callees; e; e = e->next_callee)\n+\tif (e->callee->get_availability () <= AVAIL_INTERPOSABLE)\n+\t  m_interposables.safe_push (e->callee);\n+    }\n+}\n+\n /* Constructor for key value pair, where _ITEM is key and _INDEX is a target.  */\n \n sem_usage_pair::sem_usage_pair (sem_item *_item, unsigned int _index):\n@@ -1967,6 +2005,84 @@ sem_item_optimizer::subdivide_classes_by_equality (bool in_wpa)\n   verify_classes ();\n }\n \n+/* Subdivide classes by address references that members of the class\n+   reference. Example can be a pair of functions that have an address\n+   taken from a function. If these addresses are different the class\n+   is split.  */\n+\n+unsigned\n+sem_item_optimizer::subdivide_classes_by_sensitive_refs ()\n+{\n+  unsigned newly_created_classes = 0;\n+\n+  for (hash_table <congruence_class_group_hash>::iterator it = m_classes.begin ();\n+       it != m_classes.end (); ++it)\n+    {\n+      unsigned int class_count = (*it)->classes.length ();\n+      auto_vec<congruence_class *> new_classes;\n+\n+      for (unsigned i = 0; i < class_count; i++)\n+\t{\n+\t  congruence_class *c = (*it)->classes [i];\n+\n+\t  if (c->members.length() > 1)\n+\t    {\n+\t      hash_map <symbol_compare_collection *, vec <sem_item *>,\n+\t\tsymbol_compare_hashmap_traits> split_map;\n+\n+\t      for (unsigned j = 0; j < c->members.length (); j++)\n+\t        {\n+\t\t  sem_item *source_node = c->members[j];\n+\n+\t\t  symbol_compare_collection *collection = new symbol_compare_collection (source_node->node);\n+\n+\t\t  vec <sem_item *> *slot = &split_map.get_or_insert (collection);\n+\t\t  gcc_checking_assert (slot);\n+\n+\t\t  slot->safe_push (source_node);\n+\t        }\n+\n+\t       /* If the map contains more than one key, we have to split the map\n+\t\t  appropriately.  */\n+\t      if (split_map.elements () != 1)\n+\t        {\n+\t\t  bool first_class = true;\n+\n+\t\t  hash_map <symbol_compare_collection *, vec <sem_item *>,\n+\t\t  symbol_compare_hashmap_traits>::iterator it2 = split_map.begin ();\n+\t\t  for (; it2 != split_map.end (); ++it2)\n+\t\t    {\n+\t\t      congruence_class *new_cls;\n+\t\t      new_cls = new congruence_class (class_id++);\n+\n+\t\t      for (unsigned k = 0; k < (*it2).second.length (); k++)\n+\t\t\tadd_item_to_class (new_cls, (*it2).second[k]);\n+\n+\t\t      worklist_push (new_cls);\n+\t\t      newly_created_classes++;\n+\n+\t\t      if (first_class)\n+\t\t        {\n+\t\t\t  (*it)->classes[i] = new_cls;\n+\t\t\t  first_class = false;\n+\t\t\t}\n+\t\t      else\n+\t\t        {\n+\t\t          new_classes.safe_push (new_cls);\n+\t\t\t  m_classes_count++;\n+\t\t        }\n+\t\t    }\n+\t\t}\n+\t    }\n+\t  }\n+\n+\tfor (unsigned i = 0; i < new_classes.length (); i++)\n+\t  (*it)->classes.safe_push (new_classes[i]);\n+    }\n+\n+  return newly_created_classes;\n+}\n+\n /* Verify congruence classes if checking is enabled.  */\n \n void\n@@ -2256,8 +2372,17 @@ sem_item_optimizer::process_cong_reduction (void)\n     fprintf (dump_file, \"Congruence class reduction\\n\");\n \n   congruence_class *cls;\n+\n+  /* Process complete congruence reduction.  */\n   while ((cls = worklist_pop ()) != NULL)\n     do_congruence_step (cls);\n+\n+  /* Subdivide newly created classes according to references.  */\n+  unsigned new_classes = subdivide_classes_by_sensitive_refs ();\n+\n+  if (dump_file)\n+    fprintf (dump_file, \"Address reference subdivision created: %u \"\n+\t     \"new classes.\\n\", new_classes);\n }\n \n /* Debug function prints all informations about congruence classes.  */"}, {"sha": "9e762398ab15e73fa3f2aa9c5f050b6416608c8f", "filename": "gcc/ipa-icf.h", "status": "modified", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ebd0e6155dcb7ebecf278731aad189be79bb456/gcc%2Fipa-icf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ebd0e6155dcb7ebecf278731aad189be79bb456/gcc%2Fipa-icf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf.h?ref=5ebd0e6155dcb7ebecf278731aad189be79bb456", "patch": "@@ -63,6 +63,70 @@ enum sem_item_type\n   VAR\n };\n \n+/* Class is container for address references for a symtab_node.  */\n+\n+class symbol_compare_collection\n+{\n+public:\n+  /* Constructor.  */\n+  symbol_compare_collection (symtab_node *node);\n+\n+  /* Destructor.  */\n+  ~symbol_compare_collection ()\n+  {\n+    m_references.release ();\n+    m_interposables.release ();\n+  }\n+\n+  /* Vector of address references.  */\n+  vec<symtab_node *> m_references;\n+\n+  /* Vector of interposable references.  */\n+  vec<symtab_node *> m_interposables;\n+};\n+\n+/* Hash traits for symbol_compare_collection map.  */\n+\n+struct symbol_compare_hashmap_traits: default_hashmap_traits\n+{\n+  static hashval_t\n+  hash (const symbol_compare_collection *v)\n+  {\n+    inchash::hash hstate;\n+    hstate.add_int (v->m_references.length ());\n+\n+    for (unsigned i = 0; i < v->m_references.length (); i++)\n+      hstate.add_ptr (v->m_references[i]->ultimate_alias_target ());\n+\n+    hstate.add_int (v->m_interposables.length ());\n+\n+    for (unsigned i = 0; i < v->m_interposables.length (); i++)\n+      hstate.add_ptr (v->m_interposables[i]->ultimate_alias_target ());\n+\n+    return hstate.end ();\n+  }\n+\n+  static bool\n+  equal_keys (const symbol_compare_collection *a,\n+\t      const symbol_compare_collection *b)\n+  {\n+    if (a->m_references.length () != b->m_references.length ())\n+      return false;\n+\n+    for (unsigned i = 0; i < a->m_references.length (); i++)\n+      if (a->m_references[i]->equal_address_to (b->m_references[i]) != 1)\n+\treturn false;\n+\n+    for (unsigned i = 0; i < a->m_interposables.length (); i++)\n+      if (!a->m_interposables[i]->semantically_equivalent_p\n+\t(b->m_interposables[i]))\n+\treturn false;\n+\n+    return true;\n+  }\n+};\n+\n+\n /* Semantic item usage pair.  */\n class sem_usage_pair\n {\n@@ -467,6 +531,13 @@ class sem_item_optimizer\n      classes. If IN_WPA, fast equality function is invoked.  */\n   void subdivide_classes_by_equality (bool in_wpa = false);\n \n+  /* Subdivide classes by address and interposable references\n+     that members of the class reference.\n+     Example can be a pair of functions that have an address\n+     taken from a function. If these addresses are different the class\n+     is split.  */\n+  unsigned subdivide_classes_by_sensitive_refs();\n+\n   /* Debug function prints all informations about congruence classes.  */\n   void dump_cong_classes (void);\n "}, {"sha": "f9af352f2f938ba153e356614fb65ab0b0d87af5", "filename": "gcc/ipa-ref.c", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ebd0e6155dcb7ebecf278731aad189be79bb456/gcc%2Fipa-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ebd0e6155dcb7ebecf278731aad189be79bb456/gcc%2Fipa-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-ref.c?ref=5ebd0e6155dcb7ebecf278731aad189be79bb456", "patch": "@@ -124,3 +124,23 @@ ipa_ref::referred_ref_list (void)\n {\n   return &referred->ref_list;\n }\n+\n+/* Return true if refernece may be used in address compare.  */\n+bool\n+ipa_ref::address_matters_p ()\n+{\n+  if (use != IPA_REF_ADDR)\n+    return false;\n+  /* Addresses taken from virtual tables are never compared.  */\n+  if (is_a <varpool_node *> (referring)\n+      && DECL_VIRTUAL_P (referring->decl))\n+    return false;\n+  /* Address of virtual tables and functions is never compared.  */\n+  if (DECL_VIRTUAL_P (referred->decl))\n+    return false;\n+  /* Address of C++ cdtors is never compared.  */\n+  if (is_a <cgraph_node *> (referred)\n+      && (DECL_CXX_CONSTRUCTOR_P (referred->decl) || DECL_CXX_DESTRUCTOR_P (referred->decl)))\n+    return false;\n+  return true;\n+}"}, {"sha": "38df8c98b5ebffaa3c2ae6ff45a0802a6742173b", "filename": "gcc/ipa-ref.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ebd0e6155dcb7ebecf278731aad189be79bb456/gcc%2Fipa-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ebd0e6155dcb7ebecf278731aad189be79bb456/gcc%2Fipa-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-ref.h?ref=5ebd0e6155dcb7ebecf278731aad189be79bb456", "patch": "@@ -47,6 +47,9 @@ struct GTY(()) ipa_ref\n      function.  */\n   bool cannot_lead_to_return ();\n \n+  /* Return true if refernece may be used in address compare.  */\n+  bool address_matters_p ();\n+\n   /* Return reference list this reference is in.  */\n   struct ipa_ref_list * referring_ref_list (void);\n "}, {"sha": "31bb2688b6c037754c94b495e0395016cb85b4dc", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ebd0e6155dcb7ebecf278731aad189be79bb456/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ebd0e6155dcb7ebecf278731aad189be79bb456/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5ebd0e6155dcb7ebecf278731aad189be79bb456", "patch": "@@ -1,3 +1,11 @@\n+2015-02-26  Martin Liska  <mliska@suse.cz>\n+\t    Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* g++.dg/ipa/pr64146.C: Update expected results.\n+\t* gcc.dg/ipa/ipa-icf-26.c: Update test.\n+\t* gcc.dg/ipa/ipa-icf-33.c: Remove redundant line.\n+\t* gcc.dg/ipa/ipa-icf-34.c: New test.\n+\n 2015-02-26  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* gcc.dg/vect/vect-pr61917.c: Rename to ..."}, {"sha": "c9a2590b67b6c243bb04567d9f0f1ca8e6d40d69", "filename": "gcc/testsuite/g++.dg/ipa/pr64146.C", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ebd0e6155dcb7ebecf278731aad189be79bb456/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fpr64146.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ebd0e6155dcb7ebecf278731aad189be79bb456/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fpr64146.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fpr64146.C?ref=5ebd0e6155dcb7ebecf278731aad189be79bb456", "patch": "@@ -34,6 +34,5 @@ int main (int argc, char **argv)\n   return 0;\n }\n \n-/* { dg-final { scan-ipa-dump-times \"Declaration does not bind to currect definition.\" 2 \"icf\"  } } */\n-/* { dg-final { scan-ipa-dump \"Equal symbols: 2\" \"icf\"  } } */\n+/* { dg-final { scan-ipa-dump \"Equal symbols: 1\" \"icf\"  } } */\n /* { dg-final { cleanup-ipa-dump \"icf\" } } */"}, {"sha": "f48c04098abf5af04dc3bfb76e89cc3a0ad16b89", "filename": "gcc/testsuite/gcc.dg/ipa/ipa-icf-26.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ebd0e6155dcb7ebecf278731aad189be79bb456/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-icf-26.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ebd0e6155dcb7ebecf278731aad189be79bb456/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-icf-26.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-icf-26.c?ref=5ebd0e6155dcb7ebecf278731aad189be79bb456", "patch": "@@ -38,7 +38,6 @@ int main()\n   return 0;\n }\n \n-/* { dg-final { scan-ipa-dump \"Semantic equality hit:bar->foo\" \"icf\"  } } */\n /* { dg-final { scan-ipa-dump \"Semantic equality hit:remove->destroy\" \"icf\"  } } */\n-/* { dg-final { scan-ipa-dump \"Equal symbols: 2\" \"icf\"  } } */\n+/* { dg-final { scan-ipa-dump \"Equal symbols: 1\" \"icf\"  } } */\n /* { dg-final { cleanup-ipa-dump \"icf\" } } */"}, {"sha": "7b6a8ae51d9606fb0e217210789c596f237f0000", "filename": "gcc/testsuite/gcc.dg/ipa/ipa-icf-33.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ebd0e6155dcb7ebecf278731aad189be79bb456/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-icf-33.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ebd0e6155dcb7ebecf278731aad189be79bb456/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-icf-33.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipa-icf-33.c?ref=5ebd0e6155dcb7ebecf278731aad189be79bb456", "patch": "@@ -22,6 +22,5 @@ int main()\n   return foo() - bar();\n }\n \n-/* { dg-final { scan-ipa-dump \"Equal symbols: 1\" \"icf\"  } } */\n /* { dg-final { scan-ipa-dump \"Equal symbols: 1\" \"icf\"  } } */\n /* { dg-final { cleanup-ipa-dump \"icf\" } } */"}]}