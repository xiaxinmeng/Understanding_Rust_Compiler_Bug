{"sha": "600be7f09ea1ea4b59e4e733fda2aca3ba892a6b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjAwYmU3ZjA5ZWExZWE0YjU5ZTRlNzMzZmRhMmFjYTNiYTg5MmE2Yg==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-11-06T15:57:05Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-11-06T19:30:00Z"}, "message": "rework PRE PHI translation cache\n\nTurns out its size and time requirements can be stripped down\ndramatically.\n\n2020-11-06  Richard Biener  <rguenther@suse.de>\n\n\t* tree-ssa-pre.c (expr_pred_trans_d): Modify so elements\n\tare embedded rather than allocated.  Remove hashval member,\n\tmake all members integers.\n\t(phi_trans_add): Adjust accordingly.\n\t(phi_translate): Likewise.  Deal with re-allocation\n\tof the table.", "tree": {"sha": "a492b05d676a0fd0443743a6ba9dfcafcbcefa07", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a492b05d676a0fd0443743a6ba9dfcafcbcefa07"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/600be7f09ea1ea4b59e4e733fda2aca3ba892a6b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/600be7f09ea1ea4b59e4e733fda2aca3ba892a6b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/600be7f09ea1ea4b59e4e733fda2aca3ba892a6b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/600be7f09ea1ea4b59e4e733fda2aca3ba892a6b/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "129e1a8a96d140150705fab30d25afb464eb1d99", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/129e1a8a96d140150705fab30d25afb464eb1d99", "html_url": "https://github.com/Rust-GCC/gccrs/commit/129e1a8a96d140150705fab30d25afb464eb1d99"}], "stats": {"total": 104, "additions": 68, "deletions": 36}, "files": [{"sha": "3496891f8b5f0be2adf3ae7b0b5ba4a1c29aa88e", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 68, "deletions": 36, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/600be7f09ea1ea4b59e4e733fda2aca3ba892a6b/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/600be7f09ea1ea4b59e4e733fda2aca3ba892a6b/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=600be7f09ea1ea4b59e4e733fda2aca3ba892a6b", "patch": "@@ -545,45 +545,74 @@ static bitmap_obstack grand_bitmap_obstack;\n /* A three tuple {e, pred, v} used to cache phi translations in the\n    phi_translate_table.  */\n \n-typedef struct expr_pred_trans_d : free_ptr_hash<expr_pred_trans_d>\n+typedef struct expr_pred_trans_d : public typed_noop_remove <expr_pred_trans_d>\n {\n-  /* The expression.  */\n-  pre_expr e;\n+  typedef expr_pred_trans_d value_type;\n+  typedef expr_pred_trans_d compare_type;\n \n-  /* The predecessor block along which we translated the expression.  */\n-  basic_block pred;\n+  /* The expression ID.  */\n+  unsigned e;\n \n-  /* The value that resulted from the translation.  */\n-  pre_expr v;\n+  /* The predecessor block index along which we translated the expression.  */\n+  int pred;\n \n-  /* The hashcode for the expression, pred pair. This is cached for\n-     speed reasons.  */\n-  hashval_t hashcode;\n+  /* The value expression ID that resulted from the translation.  */\n+  unsigned v;\n \n   /* hash_table support.  */\n-  static inline hashval_t hash (const expr_pred_trans_d *);\n-  static inline int equal (const expr_pred_trans_d *, const expr_pred_trans_d *);\n+  static inline void mark_empty (expr_pred_trans_d &);\n+  static inline bool is_empty (const expr_pred_trans_d &);\n+  static inline void mark_deleted (expr_pred_trans_d &);\n+  static inline bool is_deleted (const expr_pred_trans_d &);\n+  static const bool empty_zero_p = true;\n+  static inline hashval_t hash (const expr_pred_trans_d &);\n+  static inline int equal (const expr_pred_trans_d &, const expr_pred_trans_d &);\n } *expr_pred_trans_t;\n typedef const struct expr_pred_trans_d *const_expr_pred_trans_t;\n \n+inline bool\n+expr_pred_trans_d::is_empty (const expr_pred_trans_d &e)\n+{\n+  return e.e == 0;\n+}\n+\n+inline bool\n+expr_pred_trans_d::is_deleted (const expr_pred_trans_d &e)\n+{\n+  return e.e == -1u;\n+}\n+\n+inline void\n+expr_pred_trans_d::mark_empty (expr_pred_trans_d &e)\n+{\n+  e.e = 0;\n+}\n+\n+inline void\n+expr_pred_trans_d::mark_deleted (expr_pred_trans_d &e)\n+{\n+  e.e = -1u;\n+}\n+\n inline hashval_t\n-expr_pred_trans_d::hash (const expr_pred_trans_d *e)\n+expr_pred_trans_d::hash (const expr_pred_trans_d &e)\n {\n-  return e->hashcode;\n+  return iterative_hash_hashval_t (e.e, e.pred);\n }\n \n inline int\n-expr_pred_trans_d::equal (const expr_pred_trans_d *ve1,\n-\t\t\t  const expr_pred_trans_d *ve2)\n+expr_pred_trans_d::equal (const expr_pred_trans_d &ve1,\n+\t\t\t  const expr_pred_trans_d &ve2)\n {\n-  basic_block b1 = ve1->pred;\n-  basic_block b2 = ve2->pred;\n+  int b1 = ve1.pred;\n+  int b2 = ve2.pred;\n \n   /* If they are not translations for the same basic block, they can't\n      be equal.  */\n   if (b1 != b2)\n     return false;\n-  return pre_expr_d::equal (ve1->e, ve2->e);\n+\n+  return ve1.e == ve2.e;\n }\n \n /* The phi_translate_table caches phi translations for a given\n@@ -596,24 +625,22 @@ static hash_table<expr_pred_trans_d> *phi_translate_table;\n static inline bool\n phi_trans_add (expr_pred_trans_t *entry, pre_expr e, basic_block pred)\n {\n-  expr_pred_trans_t *slot;\n+  expr_pred_trans_t slot;\n   expr_pred_trans_d tem;\n-  hashval_t hash = iterative_hash_hashval_t (pre_expr_d::hash (e),\n-\t\t\t\t\t     pred->index);\n-  tem.e = e;\n-  tem.pred = pred;\n-  tem.hashcode = hash;\n-  slot = phi_translate_table->find_slot_with_hash (&tem, hash, INSERT);\n-  if (*slot)\n+  unsigned id = get_expression_id (e);\n+  hashval_t hash = iterative_hash_hashval_t (id, pred->index);\n+  tem.e = id;\n+  tem.pred = pred->index;\n+  slot = phi_translate_table->find_slot_with_hash (tem, hash, INSERT);\n+  if (slot->e)\n     {\n-      *entry = *slot;\n+      *entry = slot;\n       return true;\n     }\n \n-  *entry = *slot = XNEW (struct expr_pred_trans_d);\n-  (*entry)->e = e;\n-  (*entry)->pred = pred;\n-  (*entry)->hashcode = hash;\n+  *entry = slot;\n+  slot->e = id;\n+  slot->pred = pred->index;\n   return false;\n }\n \n@@ -1675,6 +1702,7 @@ phi_translate (bitmap_set_t dest, pre_expr expr,\n \t       bitmap_set_t set1, bitmap_set_t set2, edge e)\n {\n   expr_pred_trans_t slot = NULL;\n+  size_t slot_size = 0;\n   pre_expr phitrans;\n \n   if (!expr)\n@@ -1691,10 +1719,11 @@ phi_translate (bitmap_set_t dest, pre_expr expr,\n   if (expr->kind != NAME)\n     {\n       if (phi_trans_add (&slot, expr, e->src))\n-\treturn slot->v;\n+\treturn slot->v == 0 ? NULL : expression_for_id (slot->v);\n       /* Store NULL for the value we want to return in the case of\n \t recursing.  */\n-      slot->v = NULL;\n+      slot->v = 0;\n+      slot_size = phi_translate_table->size ();\n     }\n \n   /* Translate.  */\n@@ -1705,12 +1734,15 @@ phi_translate (bitmap_set_t dest, pre_expr expr,\n \n   if (slot)\n     {\n+      /* Check for reallocation.  */\n+      if (phi_translate_table->size () != slot_size)\n+\tphi_trans_add (&slot, expr, e->src);\n       if (phitrans)\n-\tslot->v = phitrans;\n+\tslot->v = get_expression_id (phitrans);\n       else\n \t/* Remove failed translations again, they cause insert\n \t   iteration to not pick up new opportunities reliably.  */\n-\tphi_translate_table->remove_elt_with_hash (slot, slot->hashcode);\n+\tphi_translate_table->clear_slot (slot);\n     }\n \n   return phitrans;"}]}