{"sha": "d74b97cc7e574d56c7542f40a76b151e7088829b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDc0Yjk3Y2M3ZTU3NGQ1NmM3NTQyZjQwYTc2YjE1MWU3MDg4ODI5Yg==", "commit": {"author": {"name": "Francois-Xavier Coudert", "email": "fxcoudert@gcc.gnu.org", "date": "2007-09-03T16:44:15Z"}, "committer": {"name": "Fran\u00e7ois-Xavier Coudert", "email": "fxcoudert@gcc.gnu.org", "date": "2007-09-03T16:44:15Z"}, "message": "re PR fortran/31675 (Fortran front-end and libgfortran should have a common header file)\n\n\tPR fortran/31675\n\n\t* libgfortran.h: New file.\n\t* iso-fortran-env.def: Use macros in the new header instead of\n\thardcoded integer constants.\n\t* Make-lang.in (F95_PARSER_OBJS, GFORTRAN_TRANS_DEPS): Add\n\tfortran/libgfortran.h.\n\t* gfortran.h (GFC_STD_*, GFC_FPE_*, options_convert,\n\tioerror_codes): Remove.\n\t* trans.c (ERROR_ALLOCATION): Remove.\n\t(gfc_call_malloc, gfc_allocate_with_status,\n\tgfc_allocate_array_with_status): Use LIBERROR_ALLOCATION.\n\t* trans-types.h (GFC_DTYPE_*): Remove.\n\t* trans-decl.c (gfc_generate_function_code): Use\n\tGFC_CONVERT_NATIVE instead of CONVERT_NATIVE.\n\t* trans-io.c (set_parameter_value, set_parameter_ref): Use\n\tLIBERROR_* macros instead of IOERROR_ macros.\n\t* trans-intrinsic.c (gfc_conv_intrinsic_function): Use\n\tLIBERROR_END and LIBERROR_EOR instead of hardcoded constants.\n\t* options.c (gfc_init_options): Use GFC_CONVERT_NATIVE instead of\n\tCONVERT_NATIVE.\n\t(gfc_handle_option): Use GFC_CONVERT_* macros instead of CONVERT_*.\n\n\t* libgfortran.h: Include gcc/fortran/libgfortran.h.\n\tRemove M_PI, GFC_MAX_DIMENSIONS, GFC_DTYPE_*, GFC_NUM_RANK_BITS,\n\terror_codes, GFC_STD_*, GFC_FPE_* and unit_convert.\n\t* runtime/environ.c (variable_table): Use GFC_*_UNIT_NUMBER instead\n\tof hardcoded constants.\n\t(do_parse, init_unformatted): Use GFC_CONVERT_* macros instead of\n\tCONVERT_*.\n\t* runtime/string.c (find_option): Use LIBERROR_BAD_OPTION instead\n\tof ERROR_BAD_OPTION.\n\t* runtime/error.c (translate_error, generate_error): Use\n\tLIBERROR_* macros instead of ERROR_*.\n\t* io/file_pos.c (formatted_backspace, unformatted_backspace,\n\tst_backspace, st_rewind, st_flush): Rename macros.\n\t* io/open.c (convert_opt, edit_modes, new_unit, already_open,\n\tst_open): Likewise.\n\t* io/close.c (st_close): Likewise.\n\t* io/list_read.c (next_char, convert_integer, parse_repeat,\n\tread_logical, read_integer, read_character, parse_real,\n\tcheck_type, list_formatted_read_scalar, namelist_read,\n\tnml_err_ret): Likewise.\n\t* io/read.c (convert_real, read_l, read_decimal, read_radix,\n\tread_f): Likewise.\n\t* io/inquire.c (inquire_via_unit): Likewise.\n\t* io/unit.c (get_internal_unit): Likewise.\n\t* io/transfer.c (read_sf, read_block, read_block_direct,\n\twrite_block, write_buf, unformatted_read, unformatted_write,\n\tformatted_transfer_scalar, us_read, us_write, data_transfer_init,\n\tskip_record, next_record_r, write_us_marker, next_record_w_unf,\n\tnext_record_w, finalize_transfer, st_read, st_write_done):\n\tLikewise.\n\t* io/format.c (format_error): Likewise.\n\nFrom-SVN: r128050", "tree": {"sha": "50eb90c08b7f37c0d1ff93a565a55dd6872e3e21", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/50eb90c08b7f37c0d1ff93a565a55dd6872e3e21"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d74b97cc7e574d56c7542f40a76b151e7088829b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d74b97cc7e574d56c7542f40a76b151e7088829b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d74b97cc7e574d56c7542f40a76b151e7088829b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d74b97cc7e574d56c7542f40a76b151e7088829b/comments", "author": {"login": "fxcoudert", "id": 1980544, "node_id": "MDQ6VXNlcjE5ODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1980544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fxcoudert", "html_url": "https://github.com/fxcoudert", "followers_url": "https://api.github.com/users/fxcoudert/followers", "following_url": "https://api.github.com/users/fxcoudert/following{/other_user}", "gists_url": "https://api.github.com/users/fxcoudert/gists{/gist_id}", "starred_url": "https://api.github.com/users/fxcoudert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fxcoudert/subscriptions", "organizations_url": "https://api.github.com/users/fxcoudert/orgs", "repos_url": "https://api.github.com/users/fxcoudert/repos", "events_url": "https://api.github.com/users/fxcoudert/events{/privacy}", "received_events_url": "https://api.github.com/users/fxcoudert/received_events", "type": "User", "site_admin": false}, "committer": {"login": "fxcoudert", "id": 1980544, "node_id": "MDQ6VXNlcjE5ODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1980544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fxcoudert", "html_url": "https://github.com/fxcoudert", "followers_url": "https://api.github.com/users/fxcoudert/followers", "following_url": "https://api.github.com/users/fxcoudert/following{/other_user}", "gists_url": "https://api.github.com/users/fxcoudert/gists{/gist_id}", "starred_url": "https://api.github.com/users/fxcoudert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fxcoudert/subscriptions", "organizations_url": "https://api.github.com/users/fxcoudert/orgs", "repos_url": "https://api.github.com/users/fxcoudert/repos", "events_url": "https://api.github.com/users/fxcoudert/events{/privacy}", "received_events_url": "https://api.github.com/users/fxcoudert/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4392a547f5434b483090f592c6a723a4377b8535", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4392a547f5434b483090f592c6a723a4377b8535", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4392a547f5434b483090f592c6a723a4377b8535"}], "stats": {"total": 798, "additions": 400, "deletions": 398}, "files": [{"sha": "ce57c1358ca55e0d2e5a1992dc20ae99b6002f1a", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d74b97cc7e574d56c7542f40a76b151e7088829b/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d74b97cc7e574d56c7542f40a76b151e7088829b/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=d74b97cc7e574d56c7542f40a76b151e7088829b", "patch": "@@ -1,3 +1,27 @@\n+2007-09-03  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n+\n+\tPR fortran/31675\n+\t* libgfortran.h: New file.\n+\t* iso-fortran-env.def: Use macros in the new header instead of\n+\thardcoded integer constants.\n+\t* Make-lang.in (F95_PARSER_OBJS, GFORTRAN_TRANS_DEPS): Add\n+\tfortran/libgfortran.h.\n+\t* gfortran.h (GFC_STD_*, GFC_FPE_*, options_convert,\n+\tioerror_codes): Remove.\n+\t* trans.c (ERROR_ALLOCATION): Remove.\n+\t(gfc_call_malloc, gfc_allocate_with_status,\n+\tgfc_allocate_array_with_status): Use LIBERROR_ALLOCATION.\n+\t* trans-types.h (GFC_DTYPE_*): Remove.\n+\t* trans-decl.c (gfc_generate_function_code): Use\n+\tGFC_CONVERT_NATIVE instead of CONVERT_NATIVE.\n+\t* trans-io.c (set_parameter_value, set_parameter_ref): Use\n+\tLIBERROR_* macros instead of IOERROR_ macros.\n+\t* trans-intrinsic.c (gfc_conv_intrinsic_function): Use\n+\tLIBERROR_END and LIBERROR_EOR instead of hardcoded constants.\n+\t* options.c (gfc_init_options): Use GFC_CONVERT_NATIVE instead of\n+\tCONVERT_NATIVE.\n+\t(gfc_handle_option): Use GFC_CONVERT_* macros instead of CONVERT_*.\n+\n 2007-09-02  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \t* invoke.texi: Fix the -frange-checking option entry."}, {"sha": "c217b026c5f2d6780ff0f8ec5a85f838f6ec7ea2", "filename": "gcc/fortran/Make-lang.in", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d74b97cc7e574d56c7542f40a76b151e7088829b/gcc%2Ffortran%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d74b97cc7e574d56c7542f40a76b151e7088829b/gcc%2Ffortran%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FMake-lang.in?ref=d74b97cc7e574d56c7542f40a76b151e7088829b", "patch": "@@ -289,14 +289,16 @@ fortran.stagefeedback: stageprofile-start\n # which objects depend on what.  FIXME\n # TODO: Add dependencies on the backend/tree header files\n \n-$(F95_PARSER_OBJS): fortran/gfortran.h fortran/intrinsic.h fortran/match.h \\\n+$(F95_PARSER_OBJS): fortran/gfortran.h fortran/libgfortran.h \\\n+\t\tfortran/intrinsic.h fortran/match.h \\\n \t\tfortran/parse.h fortran/arith.h fortran/target-memory.h \\\n \t\t$(CONFIG_H) $(SYSTEM_H) $(TM_H) $(TM_P_H) coretypes.h \\\n \t\t$(RTL_H) $(TREE_H) $(TREE_DUMP_H) $(GGC_H) $(EXPR_H) \\\n \t\t$(FLAGS_H) output.h $(DIAGNOSTIC_H) errors.h $(FUNCTION_H) \n fortran/openmp.o: pointer-set.h $(TARGET_H) toplev.h\n \n-GFORTRAN_TRANS_DEPS = fortran/gfortran.h fortran/intrinsic.h fortran/trans-array.h \\\n+GFORTRAN_TRANS_DEPS = fortran/gfortran.h fortran/libgfortran.h \\\n+    fortran/intrinsic.h fortran/trans-array.h \\\n     fortran/trans-const.h fortran/trans-const.h fortran/trans.h \\\n     fortran/trans-stmt.h fortran/trans-types.h \\\n     $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(TM_H) coretypes.h $(GGC_H)"}, {"sha": "b9c6c31e97fea374a1ab7b0da8034205a3b48119", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 5, "deletions": 60, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d74b97cc7e574d56c7542f40a76b151e7088829b/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d74b97cc7e574d56c7542f40a76b151e7088829b/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=d74b97cc7e574d56c7542f40a76b151e7088829b", "patch": "@@ -28,6 +28,11 @@ along with GCC; see the file COPYING3.  If not see\n    multiple header files.  Besides, Microsoft's winnt.h was 250k last\n    time I looked, so by comparison this is perfectly reasonable.  */\n \n+/* Declarations common to the front-end and library are put in\n+   libgfortran/libgfortran_frontend.h  */\n+#include \"libgfortran.h\"\n+\n+\n #include \"system.h\"\n #include \"intl.h\"\n #include \"coretypes.h\"\n@@ -57,7 +62,6 @@ char *alloca ();\n #define GFC_MAX_SYMBOL_LEN 63   /* Must be at least 63 for F2003.  */\n #define GFC_MAX_BINDING_LABEL_LEN 126 /* (2 * GFC_MAX_SYMBOL_LEN) */\n #define GFC_MAX_LINE 132\t/* Characters beyond this are not seen.  */\n-#define GFC_MAX_DIMENSIONS 7\t/* Maximum dimensions in an array.  */\n #define GFC_LETTERS 26\t\t/* Number of letters in the alphabet.  */\n \n #define MAX_SUBRECORD_LENGTH 2147483639   /* 2**31-9 */\n@@ -96,33 +100,6 @@ typedef struct\n mstring;\n \n \n-/* Flags to specify which standard/extension contains a feature.  */\n-#define GFC_STD_LEGACY\t\t(1<<6) /* Backward compatibility.  */\n-#define GFC_STD_GNU\t\t(1<<5)    /* GNU Fortran extension.  */\n-#define GFC_STD_F2003\t\t(1<<4)    /* New in F2003.  */\n-/* Note that no additional features were deleted or made obsolescent\n-   in F2003.  */\n-#define GFC_STD_F95\t\t(1<<3)    /* New in F95.  */\n-#define GFC_STD_F95_DEL\t\t(1<<2)    /* Deleted in F95.  */\n-#define GFC_STD_F95_OBS\t\t(1<<1)    /* Obsolescent in F95.  */\n-#define GFC_STD_F77\t\t(1<<0)    /* Included in F77, but not\n-\t\t\t\t\t     deleted or obsolescent in\n-\t\t\t\t\t     later standards.  */\n-\n-/* Bitmasks for the various FPE that can be enabled.  */\n-#define GFC_FPE_INVALID    (1<<0)\n-#define GFC_FPE_DENORMAL   (1<<1)\n-#define GFC_FPE_ZERO       (1<<2)\n-#define GFC_FPE_OVERFLOW   (1<<3)\n-#define GFC_FPE_UNDERFLOW  (1<<4)\n-#define GFC_FPE_PRECISION  (1<<5)\n-\n-/* Keep this in sync with libgfortran/io/io.h ! */\n-\n-typedef enum\n-  { CONVERT_NATIVE=0, CONVERT_SWAP, CONVERT_BIG, CONVERT_LITTLE }\n-options_convert;\n-\n \n /*************************** Enums *****************************/\n \n@@ -532,38 +509,6 @@ enum gfc_isym_id\n };\n typedef enum gfc_isym_id gfc_isym_id;\n \n-/* Runtime errors.  The EOR and EOF errors are required to be negative.\n-   These codes must be kept synchronized with their equivalents in\n-   libgfortran/libgfortran.h .  */\n-\n-typedef enum\n-{\n-  IOERROR_FIRST = -3,\t\t/* Marker for the first error.  */\n-  IOERROR_EOR = -2,\n-  IOERROR_END = -1,\n-  IOERROR_OK = 0,\t\t\t/* Indicates success, must be zero.  */\n-  IOERROR_OS = 5000,\t\t/* Operating system error, more info in errno.  */\n-  IOERROR_OPTION_CONFLICT,\n-  IOERROR_BAD_OPTION,\n-  IOERROR_MISSING_OPTION,\n-  IOERROR_ALREADY_OPEN,\n-  IOERROR_BAD_UNIT,\n-  IOERROR_FORMAT,\n-  IOERROR_BAD_ACTION,\n-  IOERROR_ENDFILE,\n-  IOERROR_BAD_US,\n-  IOERROR_READ_VALUE,\n-  IOERROR_READ_OVERFLOW,\n-  IOERROR_INTERNAL,\n-  IOERROR_INTERNAL_UNIT,\n-  IOERROR_ALLOCATION,\n-  IOERROR_DIRECT_EOR,\n-  IOERROR_SHORT_RECORD,\n-  IOERROR_CORRUPT_FILE,\n-  IOERROR_LAST\t\t\t/* Not a real error, the last error # + 1.  */\n-}\n-ioerror_codes;\n-\n \n /************************* Structures *****************************/\n "}, {"sha": "8ef5597d3b28cf33b3f13b9e8682e03a93c83089", "filename": "gcc/fortran/iso-fortran-env.def", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d74b97cc7e574d56c7542f40a76b151e7088829b/gcc%2Ffortran%2Fiso-fortran-env.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d74b97cc7e574d56c7542f40a76b151e7088829b/gcc%2Ffortran%2Fiso-fortran-env.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fiso-fortran-env.def?ref=d74b97cc7e574d56c7542f40a76b151e7088829b", "patch": "@@ -26,11 +26,11 @@ along with GCC; see the file COPYING3.  If not see\n \n NAMED_INTCST (ISOFORTRANENV_CHARACTER_STORAGE_SIZE, \"character_storage_size\", \\\n               gfc_character_storage_size)\n-NAMED_INTCST (ISOFORTRANENV_ERROR_UNIT, \"error_unit\", 0)\n+NAMED_INTCST (ISOFORTRANENV_ERROR_UNIT, \"error_unit\", GFC_STDERR_UNIT_NUMBER)\n NAMED_INTCST (ISOFORTRANENV_FILE_STORAGE_SIZE, \"file_storage_size\", 8)\n-NAMED_INTCST (ISOFORTRANENV_INPUT_UNIT, \"input_unit\", 5)\n-NAMED_INTCST (ISOFORTRANENV_IOSTAT_END, \"iostat_end\", -1)\n-NAMED_INTCST (ISOFORTRANENV_IOSTAT_EOR, \"iostat_eor\", -2)\n+NAMED_INTCST (ISOFORTRANENV_INPUT_UNIT, \"input_unit\", GFC_STDIN_UNIT_NUMBER)\n+NAMED_INTCST (ISOFORTRANENV_IOSTAT_END, \"iostat_end\", LIBERROR_END)\n+NAMED_INTCST (ISOFORTRANENV_IOSTAT_EOR, \"iostat_eor\", LIBERROR_EOR)\n NAMED_INTCST (ISOFORTRANENV_NUMERIC_STORAGE_SIZE, \"numeric_storage_size\", \\\n               gfc_numeric_storage_size)\n-NAMED_INTCST (ISOFORTRANENV_OUTPUT_UNIT, \"output_unit\", 6)\n+NAMED_INTCST (ISOFORTRANENV_OUTPUT_UNIT, \"output_unit\", GFC_STDOUT_UNIT_NUMBER)"}, {"sha": "d9bfa05e80a0a330e89f4c9b1cdf00ecc218bb32", "filename": "gcc/fortran/libgfortran.h", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d74b97cc7e574d56c7542f40a76b151e7088829b/gcc%2Ffortran%2Flibgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d74b97cc7e574d56c7542f40a76b151e7088829b/gcc%2Ffortran%2Flibgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Flibgfortran.h?ref=d74b97cc7e574d56c7542f40a76b151e7088829b", "patch": "@@ -0,0 +1,108 @@\n+/* Header file to the Fortran front-end and runtime library\n+   Copyright (C) 2007 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+\n+/* Flags to specify which standard/extension contains a feature.\n+   Note that no features were obsoleted nor deleted in F2003.  */\n+#define GFC_STD_LEGACY\t(1<<6)\t/* Backward compatibility.  */\n+#define GFC_STD_GNU\t(1<<5)\t/* GNU Fortran extension.  */\n+#define GFC_STD_F2003\t(1<<4)\t/* New in F2003.  */\n+#define GFC_STD_F95\t(1<<3)\t/* New in F95.  */\n+#define GFC_STD_F95_DEL\t(1<<2)\t/* Deleted in F95.  */\n+#define GFC_STD_F95_OBS\t(1<<1)\t/* Obsolescent in F95.  */\n+#define GFC_STD_F77\t(1<<0)\t/* Included in F77, but not deleted or\n+\t\t\t\t   obsolescent in later standards.  */\n+\n+\n+/* Bitmasks for the various FPE that can be enabled.  */\n+#define GFC_FPE_INVALID    (1<<0)\n+#define GFC_FPE_DENORMAL   (1<<1)\n+#define GFC_FPE_ZERO       (1<<2)\n+#define GFC_FPE_OVERFLOW   (1<<3)\n+#define GFC_FPE_UNDERFLOW  (1<<4)\n+#define GFC_FPE_PRECISION  (1<<5)\n+\n+\n+/* Possible values for the CONVERT I/O specifier.  */\n+typedef enum\n+{\n+  GFC_CONVERT_NONE = -1,\n+  GFC_CONVERT_NATIVE = 0,\n+  GFC_CONVERT_SWAP,\n+  GFC_CONVERT_BIG,\n+  GFC_CONVERT_LITTLE\n+}\n+unit_convert;\n+\n+\n+/* Runtime errors.  */\n+typedef enum\n+{\n+  LIBERROR_FIRST = -3,\t\t/* Marker for the first error.  */\n+  LIBERROR_EOR = -2,\t\t/* End of record, must be negative.  */\n+  LIBERROR_END = -1,\t\t/* End of file, must be negative.  */\n+  LIBERROR_OK = 0,\t\t/* Indicates success, must be zero.  */\n+  LIBERROR_OS = 5000,\t\t/* OS error, more info in errno.  */\n+  LIBERROR_OPTION_CONFLICT,\n+  LIBERROR_BAD_OPTION,\n+  LIBERROR_MISSING_OPTION,\n+  LIBERROR_ALREADY_OPEN,\n+  LIBERROR_BAD_UNIT,\n+  LIBERROR_FORMAT,\n+  LIBERROR_BAD_ACTION,\n+  LIBERROR_ENDFILE,\n+  LIBERROR_BAD_US,\n+  LIBERROR_READ_VALUE,\n+  LIBERROR_READ_OVERFLOW,\n+  LIBERROR_INTERNAL,\n+  LIBERROR_INTERNAL_UNIT,\n+  LIBERROR_ALLOCATION,\n+  LIBERROR_DIRECT_EOR,\n+  LIBERROR_SHORT_RECORD,\n+  LIBERROR_CORRUPT_FILE,\n+  LIBERROR_LAST\t\t\t/* Not a real error, the last error # + 1.  */\n+}\n+libgfortran_error_codes;\n+\n+\n+/* Default unit number for preconnected standard input and output.  */\n+#define GFC_STDIN_UNIT_NUMBER 5\n+#define GFC_STDOUT_UNIT_NUMBER 6\n+#define GFC_STDERR_UNIT_NUMBER 0\n+\n+\n+#define GFC_MAX_DIMENSIONS 7\n+\n+#define GFC_DTYPE_RANK_MASK 0x07\n+#define GFC_DTYPE_TYPE_SHIFT 3\n+#define GFC_DTYPE_TYPE_MASK 0x38\n+#define GFC_DTYPE_SIZE_SHIFT 6\n+\n+enum\n+{\n+  GFC_DTYPE_UNKNOWN = 0,\n+  GFC_DTYPE_INTEGER,\n+  /* TODO: recognize logical types.  */\n+  GFC_DTYPE_LOGICAL,\n+  GFC_DTYPE_REAL,\n+  GFC_DTYPE_COMPLEX,\n+  GFC_DTYPE_DERIVED,\n+  GFC_DTYPE_CHARACTER\n+};\n+"}, {"sha": "a68c3bed781935b4df071976e8df631da5ba41ad", "filename": "gcc/fortran/options.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d74b97cc7e574d56c7542f40a76b151e7088829b/gcc%2Ffortran%2Foptions.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d74b97cc7e574d56c7542f40a76b151e7088829b/gcc%2Ffortran%2Foptions.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Foptions.c?ref=d74b97cc7e574d56c7542f40a76b151e7088829b", "patch": "@@ -62,7 +62,7 @@ gfc_init_options (unsigned int argc ATTRIBUTE_UNUSED,\n   gfc_option.max_continue_free = 39;\n   gfc_option.max_identifier_length = GFC_MAX_SYMBOL_LEN;\n   gfc_option.max_subrecord_length = 0;\n-  gfc_option.convert = CONVERT_NATIVE;\n+  gfc_option.convert = GFC_CONVERT_NATIVE;\n   gfc_option.record_marker = 0;\n   gfc_option.verbose = 0;\n \n@@ -704,19 +704,19 @@ gfc_handle_option (size_t scode, const char *arg, int value)\n       break;\n \n     case OPT_fconvert_little_endian:\n-      gfc_option.convert = CONVERT_LITTLE;\n+      gfc_option.convert = GFC_CONVERT_LITTLE;\n       break;\n \n     case OPT_fconvert_big_endian:\n-      gfc_option.convert = CONVERT_BIG;\n+      gfc_option.convert = GFC_CONVERT_BIG;\n       break;\n \n     case OPT_fconvert_native:\n-      gfc_option.convert = CONVERT_NATIVE;\n+      gfc_option.convert = GFC_CONVERT_NATIVE;\n       break;\n \n     case OPT_fconvert_swap:\n-      gfc_option.convert = CONVERT_SWAP;\n+      gfc_option.convert = GFC_CONVERT_SWAP;\n       break;\n \n     case OPT_frecord_marker_4:"}, {"sha": "0b709030d4748be4650846c5d6bca6c02401e26d", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d74b97cc7e574d56c7542f40a76b151e7088829b/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d74b97cc7e574d56c7542f40a76b151e7088829b/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=d74b97cc7e574d56c7542f40a76b151e7088829b", "patch": "@@ -3212,7 +3212,7 @@ gfc_generate_function_code (gfc_namespace * ns)\n   /* If this is the main program and an -fconvert option was provided,\n      add a call to set_convert.  */\n \n-  if (sym->attr.is_main_program && gfc_option.convert != CONVERT_NATIVE)\n+  if (sym->attr.is_main_program && gfc_option.convert != GFC_CONVERT_NATIVE)\n     {\n       tmp = build_call_expr (gfor_fndecl_set_convert, 1,\n \t\t\t     build_int_cst (integer_type_node,"}, {"sha": "ebe855542bd40217f09ce49346648a5620485b7d", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d74b97cc7e574d56c7542f40a76b151e7088829b/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d74b97cc7e574d56c7542f40a76b151e7088829b/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=d74b97cc7e574d56c7542f40a76b151e7088829b", "patch": "@@ -3928,11 +3928,11 @@ gfc_conv_intrinsic_function (gfc_se * se, gfc_expr * expr)\n       break;\n \n     case GFC_ISYM_IS_IOSTAT_END:\n-      gfc_conv_has_intvalue (se, expr, -1);\n+      gfc_conv_has_intvalue (se, expr, LIBERROR_END);\n       break;\n \n     case GFC_ISYM_IS_IOSTAT_EOR:\n-      gfc_conv_has_intvalue (se, expr, -2);\n+      gfc_conv_has_intvalue (se, expr, LIBERROR_EOR);\n       break;\n \n     case GFC_ISYM_ISNAN:"}, {"sha": "289c2d2e2fc2087d3c2241a4590f170ec2c267b0", "filename": "gcc/fortran/trans-io.c", "status": "modified", "additions": 8, "deletions": 19, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d74b97cc7e574d56c7542f40a76b151e7088829b/gcc%2Ffortran%2Ftrans-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d74b97cc7e574d56c7542f40a76b151e7088829b/gcc%2Ffortran%2Ftrans-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-io.c?ref=d74b97cc7e574d56c7542f40a76b151e7088829b", "patch": "@@ -457,18 +457,15 @@ set_parameter_value (stmtblock_t *block, tree var, enum iofield type,\n   if (type == IOPARM_common_unit && e->ts.kind != 4)\n     {\n       tree cond, max;\n-      ioerror_codes bad_unit;\n       int i;\n \n-      bad_unit = IOERROR_BAD_UNIT;\n-\n       /* Don't evaluate the UNIT number multiple times.  */\n       se.expr = gfc_evaluate_now (se.expr, &se.pre);\n \n       /* UNIT numbers should be nonnegative.  */\n       cond = fold_build2 (LT_EXPR, boolean_type_node, se.expr,\n \t\t\t  build_int_cst (TREE_TYPE (se.expr),0));\n-      gfc_trans_io_runtime_check (cond, var, bad_unit,\n+      gfc_trans_io_runtime_check (cond, var, LIBERROR_BAD_UNIT,\n \t\t\t       \"Negative unit number in I/O statement\",\n \t\t\t       &se.pre);\n     \n@@ -477,7 +474,7 @@ set_parameter_value (stmtblock_t *block, tree var, enum iofield type,\n       max = gfc_conv_mpz_to_tree (gfc_integer_kinds[i].huge, 4);\n       cond = fold_build2 (GT_EXPR, boolean_type_node, se.expr,\n \t\t\t  fold_convert (TREE_TYPE (se.expr), max));\n-      gfc_trans_io_runtime_check (cond, var, bad_unit,\n+      gfc_trans_io_runtime_check (cond, var, LIBERROR_BAD_UNIT,\n \t\t\t       \"Unit number in I/O statement too large\",\n \t\t\t       &se.pre);\n \n@@ -519,14 +516,10 @@ set_parameter_ref (stmtblock_t *block, stmtblock_t *postblock,\n       addr = convert (TREE_TYPE (p->field), build_fold_addr_expr (se.expr));\n \n       /* If this is for the iostat variable initialize the\n-\t user variable to IOERROR_OK which is zero.  */\n+\t user variable to LIBERROR_OK which is zero.  */\n       if (type == IOPARM_common_iostat)\n-\t{\n-\t  ioerror_codes ok;\n-\t  ok = IOERROR_OK;\n-          gfc_add_modify_expr (block, se.expr,\n-\t\t\t       build_int_cst (TREE_TYPE (se.expr), ok));\n-\t}\n+\tgfc_add_modify_expr (block, se.expr,\n+\t\t\t     build_int_cst (TREE_TYPE (se.expr), LIBERROR_OK));\n     }\n   else\n     {\n@@ -537,14 +530,10 @@ set_parameter_ref (stmtblock_t *block, stmtblock_t *postblock,\n \t\t\t\t    st_parameter_field[type].name);\n \n       /* If this is for the iostat variable, initialize the\n-\t user variable to IOERROR_OK which is zero.  */\n+\t user variable to LIBERROR_OK which is zero.  */\n       if (type == IOPARM_common_iostat)\n-\t{\n-\t  ioerror_codes ok;\n-\t  ok = IOERROR_OK;\n-          gfc_add_modify_expr (block, tmpvar,\n-\t\t\t       build_int_cst (TREE_TYPE (tmpvar), ok));\n-\t}\n+\tgfc_add_modify_expr (block, tmpvar,\n+\t\t\t     build_int_cst (TREE_TYPE (tmpvar), LIBERROR_OK));\n \n       addr = build_fold_addr_expr (tmpvar);\n \t/* After the I/O operation, we set the variable from the temporary.  */"}, {"sha": "7a0e9bf32ac4c53fabed19bf9d4dd8e7d91cf372", "filename": "gcc/fortran/trans-types.h", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d74b97cc7e574d56c7542f40a76b151e7088829b/gcc%2Ffortran%2Ftrans-types.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d74b97cc7e574d56c7542f40a76b151e7088829b/gcc%2Ffortran%2Ftrans-types.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.h?ref=d74b97cc7e574d56c7542f40a76b151e7088829b", "patch": "@@ -24,22 +24,6 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GFC_BACKEND_H\n #define GFC_BACKEND_H\n \n-#define GFC_DTYPE_RANK_MASK 0x07\n-#define GFC_DTYPE_TYPE_SHIFT 3\n-#define GFC_DTYPE_TYPE_MASK 0x38\n-#define GFC_DTYPE_SIZE_SHIFT 6\n-\n-enum\n-{\n-  GFC_DTYPE_UNKNOWN = 0,\n-  GFC_DTYPE_INTEGER,\n-  GFC_DTYPE_LOGICAL,\n-  GFC_DTYPE_REAL,\n-  GFC_DTYPE_COMPLEX,\n-  GFC_DTYPE_DERIVED,\n-  GFC_DTYPE_CHARACTER\n-};\n-\n extern GTY(()) tree gfc_array_index_type;\n extern GTY(()) tree gfc_array_range_type;\n extern GTY(()) tree gfc_character1_type_node;"}, {"sha": "b9fd2dff6983c61a6f4fa2fc4875925c4bce37e3", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d74b97cc7e574d56c7542f40a76b151e7088829b/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d74b97cc7e574d56c7542f40a76b151e7088829b/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=d74b97cc7e574d56c7542f40a76b151e7088829b", "patch": "@@ -473,11 +473,6 @@ gfc_call_malloc (stmtblock_t * block, tree type, tree size)\n   return res;\n }\n \n-/* The status variable of allocate statement is set to ERROR_ALLOCATION \n-   when the allocation wasn't successful. This value needs to be kept in\n-   sync with libgfortran/libgfortran.h.  */\n-#define ERROR_ALLOCATION 5014\n-\n /* Allocate memory, using an optional status argument.\n  \n    This function follows the following pseudo-code:\n@@ -495,7 +490,7 @@ gfc_call_malloc (stmtblock_t * block, tree type, tree size)\n       {\n         if (stat)\n         {\n-          *stat = ERROR_ALLOCATION;\n+          *stat = LIBERROR_ALLOCATION;\n           newmem = NULL;\n         }\n         else\n@@ -508,7 +503,7 @@ gfc_call_malloc (stmtblock_t * block, tree type, tree size)\n         if (newmem == NULL)\n         {\n           if (stat)\n-            *stat = ERROR_ALLOCATION;\n+            *stat = LIBERROR_ALLOCATION;\n           else\n             runtime_error (\"Out of memory\");\n         }\n@@ -558,7 +553,7 @@ gfc_allocate_with_status (stmtblock_t * block, tree size, tree status)\n       gfc_start_block (&set_status_block);\n       gfc_add_modify_expr (&set_status_block,\n \t\t\t   build1 (INDIRECT_REF, status_type, status),\n-\t\t\t   build_int_cst (status_type, ERROR_ALLOCATION));\n+\t\t\t   build_int_cst (status_type, LIBERROR_ALLOCATION));\n       gfc_add_modify_expr (&set_status_block, res,\n \t\t\t   build_int_cst (pvoid_type_node, 0));\n \n@@ -589,7 +584,7 @@ gfc_allocate_with_status (stmtblock_t * block, tree size, tree status)\n \t\t\t  build_int_cst (status_type, 0));\n       tmp2 = fold_build2 (MODIFY_EXPR, status_type,\n \t\t\t  build1 (INDIRECT_REF, status_type, status),\n-\t\t\t  build_int_cst (status_type, ERROR_ALLOCATION));\n+\t\t\t  build_int_cst (status_type, LIBERROR_ALLOCATION));\n       tmp = fold_build3 (COND_EXPR, void_type_node, cond, tmp,\n \t\t\t tmp2);\n     }\n@@ -627,7 +622,7 @@ gfc_allocate_with_status (stmtblock_t * block, tree size, tree status)\n \t{\n \t  free (mem);\n \t  mem = allocate (size, stat);\n-\t  *stat = ERROR_ALLOCATION;\n+\t  *stat = LIBERROR_ALLOCATION;\n \t  return mem;\n \t}\n \telse\n@@ -675,7 +670,7 @@ gfc_allocate_array_with_status (stmtblock_t * block, tree mem, tree size,\n \n       gfc_add_modify_expr (&set_status_block,\n \t\t\t   build1 (INDIRECT_REF, status_type, status),\n-\t\t\t   build_int_cst (status_type, ERROR_ALLOCATION));\n+\t\t\t   build_int_cst (status_type, LIBERROR_ALLOCATION));\n \n       tmp = fold_build2 (EQ_EXPR, boolean_type_node, status,\n \t\t\t build_int_cst (status_type, 0));"}, {"sha": "5c02df9b679ed141880751b3d6c8a609a10eb963", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d74b97cc7e574d56c7542f40a76b151e7088829b/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d74b97cc7e574d56c7542f40a76b151e7088829b/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=d74b97cc7e574d56c7542f40a76b151e7088829b", "patch": "@@ -1,3 +1,38 @@\n+2007-09-03  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n+\n+\tPR fortran/31675\n+\t* libgfortran.h: Include gcc/fortran/libgfortran.h.\n+\tRemove M_PI, GFC_MAX_DIMENSIONS, GFC_DTYPE_*, GFC_NUM_RANK_BITS,\n+\terror_codes, GFC_STD_*, GFC_FPE_* and unit_convert.\n+\t* runtime/environ.c (variable_table): Use GFC_*_UNIT_NUMBER instead\n+\tof hardcoded constants.\n+\t(do_parse, init_unformatted): Use GFC_CONVERT_* macros instead of\n+\tCONVERT_*.\n+\t* runtime/string.c (find_option): Use LIBERROR_BAD_OPTION instead\n+\tof ERROR_BAD_OPTION.\n+\t* runtime/error.c (translate_error, generate_error): Use\n+\tLIBERROR_* macros instead of ERROR_*.\n+\t* io/file_pos.c (formatted_backspace, unformatted_backspace,\n+\tst_backspace, st_rewind, st_flush): Rename macros.\n+\t* io/open.c (convert_opt, edit_modes, new_unit, already_open,\n+\tst_open): Likewise.\n+\t* io/close.c (st_close): Likewise.\n+\t* io/list_read.c (next_char, convert_integer, parse_repeat,\n+\tread_logical, read_integer, read_character, parse_real,\n+\tcheck_type, list_formatted_read_scalar, namelist_read,\n+\tnml_err_ret): Likewise.\n+\t* io/read.c (convert_real, read_l, read_decimal, read_radix,\n+\tread_f): Likewise.\n+\t* io/inquire.c (inquire_via_unit): Likewise.\n+\t* io/unit.c (get_internal_unit): Likewise.\n+\t* io/transfer.c (read_sf, read_block, read_block_direct,\n+\twrite_block, write_buf, unformatted_read, unformatted_write,\n+\tformatted_transfer_scalar, us_read, us_write, data_transfer_init,\n+\tskip_record, next_record_r, write_us_marker, next_record_w_unf,\n+\tnext_record_w, finalize_transfer, st_read, st_write_done):\n+\tLikewise.\n+\t* io/format.c (format_error): Likewise.\n+\n 2007-08-31  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n \n \t* m4/minloc1.m4: Update copyright year and ajust headers order."}, {"sha": "eb66f66507e473849ade916c792ef8cd54173bc1", "filename": "libgfortran/io/close.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d74b97cc7e574d56c7542f40a76b151e7088829b/libgfortran%2Fio%2Fclose.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d74b97cc7e574d56c7542f40a76b151e7088829b/libgfortran%2Fio%2Fclose.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fclose.c?ref=d74b97cc7e574d56c7542f40a76b151e7088829b", "patch": "@@ -73,7 +73,7 @@ st_close (st_parameter_close *clp)\n       if (u->flags.status == STATUS_SCRATCH)\n \t{\n \t  if (status == CLOSE_KEEP)\n-\t    generate_error (&clp->common, ERROR_BAD_OPTION,\n+\t    generate_error (&clp->common, LIBERROR_BAD_OPTION,\n \t\t\t    \"Can't KEEP a scratch file on CLOSE\");\n #if !HAVE_UNLINK_OPEN_FILE\n \t  path = (char *) gfc_alloca (u->file_len + 1);"}, {"sha": "c0412e838796b7c50144530b0d66a587aa9c2029", "filename": "libgfortran/io/file_pos.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d74b97cc7e574d56c7542f40a76b151e7088829b/libgfortran%2Fio%2Ffile_pos.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d74b97cc7e574d56c7542f40a76b151e7088829b/libgfortran%2Fio%2Ffile_pos.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Ffile_pos.c?ref=d74b97cc7e574d56c7542f40a76b151e7088829b", "patch": "@@ -90,7 +90,7 @@ formatted_backspace (st_parameter_filepos *fpp, gfc_unit *u)\n   return;\n \n  io_error:\n-  generate_error (&fpp->common, ERROR_OS, NULL);\n+  generate_error (&fpp->common, LIBERROR_OS, NULL);\n }\n \n \n@@ -122,8 +122,8 @@ unformatted_backspace (st_parameter_filepos *fpp, gfc_unit *u)\n       if (p == NULL || length_read != length)\n \tgoto io_error;\n \n-      /* Only CONVERT_NATIVE and CONVERT_SWAP are valid here.  */\n-      if (u->flags.convert == CONVERT_NATIVE)\n+      /* Only GFC_CONVERT_NATIVE and GFC_CONVERT_SWAP are valid here.  */\n+      if (u->flags.convert == GFC_CONVERT_NATIVE)\n \t{\n \t  switch (length)\n \t    {\n@@ -178,7 +178,7 @@ unformatted_backspace (st_parameter_filepos *fpp, gfc_unit *u)\n   return;\n \n  io_error:\n-  generate_error (&fpp->common, ERROR_OS, NULL);\n+  generate_error (&fpp->common, LIBERROR_OS, NULL);\n }\n \n \n@@ -195,7 +195,7 @@ st_backspace (st_parameter_filepos *fpp)\n   u = find_unit (fpp->common.unit);\n   if (u == NULL)\n     {\n-      generate_error (&fpp->common, ERROR_BAD_UNIT, NULL);\n+      generate_error (&fpp->common, LIBERROR_BAD_UNIT, NULL);\n       goto done;\n     }\n \n@@ -296,7 +296,7 @@ st_rewind (st_parameter_filepos *fpp)\n   if (u != NULL)\n     {\n       if (u->flags.access == ACCESS_DIRECT)\n-\tgenerate_error (&fpp->common, ERROR_BAD_OPTION,\n+\tgenerate_error (&fpp->common, LIBERROR_BAD_OPTION,\n \t\t\t\"Cannot REWIND a file opened for DIRECT access\");\n       else\n \t{\n@@ -312,7 +312,7 @@ st_rewind (st_parameter_filepos *fpp)\n \t  u->last_record = 0;\n \n \t  if (file_position (u->s) != 0 && sseek (u->s, 0) == FAILURE)\n-\t    generate_error (&fpp->common, ERROR_OS, NULL);\n+\t    generate_error (&fpp->common, LIBERROR_OS, NULL);\n \n \t  /* Handle special files like /dev/null differently.  */\n \t  if (!is_special (u->s))\n@@ -359,7 +359,7 @@ st_flush (st_parameter_filepos *fpp)\n     }\n   else\n     /* FLUSH on unconnected unit is illegal: F95 std., 9.3.5. */ \n-    generate_error (&fpp->common, ERROR_BAD_OPTION,\n+    generate_error (&fpp->common, LIBERROR_BAD_OPTION,\n \t\t\t\"Specified UNIT in FLUSH is not connected\");\n \n   library_end ();"}, {"sha": "0f7a2e5bb842696fd6801b64a2b0763811150798", "filename": "libgfortran/io/format.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d74b97cc7e574d56c7542f40a76b151e7088829b/libgfortran%2Fio%2Fformat.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d74b97cc7e574d56c7542f40a76b151e7088829b/libgfortran%2Fio%2Fformat.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fformat.c?ref=d74b97cc7e574d56c7542f40a76b151e7088829b", "patch": "@@ -942,7 +942,7 @@ format_error (st_parameter_dt *dtp, const fnode *f, const char *message)\n   *p++ = '^';\n   *p = '\\0';\n \n-  generate_error (&dtp->common, ERROR_FORMAT, buffer);\n+  generate_error (&dtp->common, LIBERROR_FORMAT, buffer);\n }\n \n "}, {"sha": "2c16a3b922d2b130c92f586b4a9a613c72ef9f19", "filename": "libgfortran/io/inquire.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d74b97cc7e574d56c7542f40a76b151e7088829b/libgfortran%2Fio%2Finquire.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d74b97cc7e574d56c7542f40a76b151e7088829b/libgfortran%2Fio%2Finquire.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Finquire.c?ref=d74b97cc7e574d56c7542f40a76b151e7088829b", "patch": "@@ -302,11 +302,11 @@ inquire_via_unit (st_parameter_inquire *iqp, gfc_unit * u)\n \tswitch (u->flags.convert)\n \t  {\n \t    /*  l8_to_l4_offset is 0 for little-endian, 1 for big-endian.  */\n-\t  case CONVERT_NATIVE:\n+\t  case GFC_CONVERT_NATIVE:\n \t    p = l8_to_l4_offset ? \"BIG_ENDIAN\" : \"LITTLE_ENDIAN\";\n \t    break;\n \n-\t  case CONVERT_SWAP:\n+\t  case GFC_CONVERT_SWAP:\n \t    p = l8_to_l4_offset ? \"LITTLE_ENDIAN\" : \"BIG_ENDIAN\";\n \t    break;\n "}, {"sha": "b97130b77080f1f855cd5416f02c861356d71e07", "filename": "libgfortran/io/list_read.c", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d74b97cc7e574d56c7542f40a76b151e7088829b/libgfortran%2Fio%2Flist_read.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d74b97cc7e574d56c7542f40a76b151e7088829b/libgfortran%2Fio%2Flist_read.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Flist_read.c?ref=d74b97cc7e574d56c7542f40a76b151e7088829b", "patch": "@@ -207,7 +207,7 @@ next_char (st_parameter_dt *dtp)\n \t     check for NULL here is cautionary.  */\n \t  if (p == NULL)\n \t    {\n-\t      generate_error (&dtp->common, ERROR_INTERNAL_UNIT, NULL);\n+\t      generate_error (&dtp->common, LIBERROR_INTERNAL_UNIT, NULL);\n \t      return '\\0';\n \t    }\n \n@@ -228,7 +228,7 @@ next_char (st_parameter_dt *dtp)\n     {\n       if (p == NULL)\n \t{\n-\t  generate_error (&dtp->common, ERROR_OS, NULL);\n+\t  generate_error (&dtp->common, LIBERROR_OS, NULL);\n \t  return '\\0';\n \t}\n       if (length == 0)\n@@ -465,7 +465,7 @@ convert_integer (st_parameter_dt *dtp, int length, int negative)\n \t  sprintf (message, \"Zero repeat count in item %d of list input\",\n \t\t   dtp->u.p.item_count);\n \n-\t  generate_error (&dtp->common, ERROR_READ_VALUE, message);\n+\t  generate_error (&dtp->common, LIBERROR_READ_VALUE, message);\n \t  m = 1;\n \t}\n     }\n@@ -482,7 +482,7 @@ convert_integer (st_parameter_dt *dtp, int length, int negative)\n \t     dtp->u.p.item_count);\n \n   free_saved (dtp);\n-  generate_error (&dtp->common, ERROR_READ_VALUE, message);\n+  generate_error (&dtp->common, LIBERROR_READ_VALUE, message);\n \n   return 1;\n }\n@@ -529,7 +529,7 @@ parse_repeat (st_parameter_dt *dtp)\n \t\t       \"Repeat count overflow in item %d of list input\",\n \t\t       dtp->u.p.item_count);\n \n-\t      generate_error (&dtp->common, ERROR_READ_VALUE, message);\n+\t      generate_error (&dtp->common, LIBERROR_READ_VALUE, message);\n \t      return 1;\n \t    }\n \n@@ -542,7 +542,7 @@ parse_repeat (st_parameter_dt *dtp)\n \t\t       \"Zero repeat count in item %d of list input\",\n \t\t       dtp->u.p.item_count);\n \n-\t      generate_error (&dtp->common, ERROR_READ_VALUE, message);\n+\t      generate_error (&dtp->common, LIBERROR_READ_VALUE, message);\n \t      return 1;\n \t    }\n \n@@ -563,7 +563,7 @@ parse_repeat (st_parameter_dt *dtp)\n   free_saved (dtp);\n   sprintf (message, \"Bad repeat count in item %d of list input\",\n \t   dtp->u.p.item_count);\n-  generate_error (&dtp->common, ERROR_READ_VALUE, message);\n+  generate_error (&dtp->common, LIBERROR_READ_VALUE, message);\n   return 1;\n }\n \n@@ -708,7 +708,7 @@ read_logical (st_parameter_dt *dtp, int length)\n   free_saved (dtp);\n   sprintf (message, \"Bad logical value while reading item %d\",\n \t      dtp->u.p.item_count);\n-  generate_error (&dtp->common, ERROR_READ_VALUE, message);\n+  generate_error (&dtp->common, LIBERROR_READ_VALUE, message);\n   return;\n \n  logical_done:\n@@ -840,7 +840,7 @@ read_integer (st_parameter_dt *dtp, int length)\n   free_saved (dtp);\n   sprintf (message, \"Bad integer for item %d in list input\",\n \t      dtp->u.p.item_count);\n-  generate_error (&dtp->common, ERROR_READ_VALUE, message);\n+  generate_error (&dtp->common, LIBERROR_READ_VALUE, message);\n \n   return;\n \n@@ -1004,7 +1004,7 @@ read_character (st_parameter_dt *dtp, int length __attribute__ ((unused)))\n       free_saved (dtp);\n       sprintf (message, \"Invalid string input in item %d\",\n \t\t  dtp->u.p.item_count);\n-      generate_error (&dtp->common, ERROR_READ_VALUE, message);\n+      generate_error (&dtp->common, LIBERROR_READ_VALUE, message);\n     }\n }\n \n@@ -1123,7 +1123,7 @@ parse_real (st_parameter_dt *dtp, void *buffer, int length)\n   free_saved (dtp);\n   sprintf (message, \"Bad floating point number for item %d\",\n \t      dtp->u.p.item_count);\n-  generate_error (&dtp->common, ERROR_READ_VALUE, message);\n+  generate_error (&dtp->common, LIBERROR_READ_VALUE, message);\n \n   return 1;\n }\n@@ -1206,7 +1206,7 @@ read_complex (st_parameter_dt *dtp, int kind, size_t size)\n   free_saved (dtp);\n   sprintf (message, \"Bad complex value in item %d of list input\",\n \t      dtp->u.p.item_count);\n-  generate_error (&dtp->common, ERROR_READ_VALUE, message);\n+  generate_error (&dtp->common, LIBERROR_READ_VALUE, message);\n }\n \n \n@@ -1421,7 +1421,7 @@ read_real (st_parameter_dt *dtp, int length)\n   free_saved (dtp);\n   sprintf (message, \"Bad real number in item %d of list input\",\n \t      dtp->u.p.item_count);\n-  generate_error (&dtp->common, ERROR_READ_VALUE, message);\n+  generate_error (&dtp->common, LIBERROR_READ_VALUE, message);\n }\n \n \n@@ -1439,7 +1439,7 @@ check_type (st_parameter_dt *dtp, bt type, int len)\n \t\t  type_name (dtp->u.p.saved_type), type_name (type),\n \t\t  dtp->u.p.item_count);\n \n-      generate_error (&dtp->common, ERROR_READ_VALUE, message);\n+      generate_error (&dtp->common, LIBERROR_READ_VALUE, message);\n       return 1;\n     }\n \n@@ -1452,7 +1452,7 @@ check_type (st_parameter_dt *dtp, bt type, int len)\n \t\t  \"Read kind %d %s where kind %d is required for item %d\",\n \t\t  dtp->u.p.saved_length, type_name (dtp->u.p.saved_type), len,\n \t\t  dtp->u.p.item_count);\n-      generate_error (&dtp->common, ERROR_READ_VALUE, message);\n+      generate_error (&dtp->common, LIBERROR_READ_VALUE, message);\n       return 1;\n     }\n \n@@ -1478,7 +1478,7 @@ list_formatted_read_scalar (st_parameter_dt *dtp, bt type, void *p, int kind,\n   dtp->u.p.eof_jump = &eof_jump;\n   if (setjmp (eof_jump))\n     {\n-      generate_error (&dtp->common, ERROR_END, NULL);\n+      generate_error (&dtp->common, LIBERROR_END, NULL);\n       goto cleanup;\n     }\n \n@@ -2550,7 +2550,7 @@ namelist_read (st_parameter_dt *dtp)\n   if (setjmp (eof_jump))\n     {\n       dtp->u.p.eof_jump = NULL;\n-      generate_error (&dtp->common, ERROR_END, NULL);\n+      generate_error (&dtp->common, LIBERROR_END, NULL);\n       return;\n     }\n \n@@ -2634,6 +2634,6 @@ namelist_read (st_parameter_dt *dtp)\n   dtp->u.p.eof_jump = NULL;\n   free_saved (dtp);\n   free_line (dtp);\n-  generate_error (&dtp->common, ERROR_READ_VALUE, nml_err_msg);\n+  generate_error (&dtp->common, LIBERROR_READ_VALUE, nml_err_msg);\n   return;\n }"}, {"sha": "0a409ed4ad388729c80172571a9fd4a035ba32bd", "filename": "libgfortran/io/open.c", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d74b97cc7e574d56c7542f40a76b151e7088829b/libgfortran%2Fio%2Fopen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d74b97cc7e574d56c7542f40a76b151e7088829b/libgfortran%2Fio%2Fopen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fopen.c?ref=d74b97cc7e574d56c7542f40a76b151e7088829b", "patch": "@@ -99,10 +99,10 @@ static const st_option pad_opt[] =\n \n static const st_option convert_opt[] =\n {\n-  { \"native\", CONVERT_NATIVE},\n-  { \"swap\", CONVERT_SWAP},\n-  { \"big_endian\", CONVERT_BIG},\n-  { \"little_endian\", CONVERT_LITTLE},\n+  { \"native\", GFC_CONVERT_NATIVE},\n+  { \"swap\", GFC_CONVERT_SWAP},\n+  { \"big_endian\", GFC_CONVERT_BIG},\n+  { \"little_endian\", GFC_CONVERT_LITTLE},\n   { NULL, 0}\n };\n \n@@ -130,24 +130,24 @@ edit_modes (st_parameter_open *opp, gfc_unit * u, unit_flags * flags)\n \n   if (flags->status != STATUS_UNSPECIFIED && flags->status != STATUS_OLD && \n       u->flags.status != flags->status)\n-    generate_error (&opp->common, ERROR_BAD_OPTION,\n+    generate_error (&opp->common, LIBERROR_BAD_OPTION,\n \t\t    \"Cannot change STATUS parameter in OPEN statement\");\n \n   if (flags->access != ACCESS_UNSPECIFIED && u->flags.access != flags->access)\n-    generate_error (&opp->common, ERROR_BAD_OPTION,\n+    generate_error (&opp->common, LIBERROR_BAD_OPTION,\n \t\t    \"Cannot change ACCESS parameter in OPEN statement\");\n \n   if (flags->form != FORM_UNSPECIFIED && u->flags.form != flags->form)\n-    generate_error (&opp->common, ERROR_BAD_OPTION,\n+    generate_error (&opp->common, LIBERROR_BAD_OPTION,\n \t\t    \"Cannot change FORM parameter in OPEN statement\");\n \n   if ((opp->common.flags & IOPARM_OPEN_HAS_RECL_IN)\n       && opp->recl_in != u->recl)\n-    generate_error (&opp->common, ERROR_BAD_OPTION,\n+    generate_error (&opp->common, LIBERROR_BAD_OPTION,\n \t\t    \"Cannot change RECL parameter in OPEN statement\");\n \n   if (flags->action != ACTION_UNSPECIFIED && u->flags.action != flags->action)\n-    generate_error (&opp->common, ERROR_BAD_OPTION,\n+    generate_error (&opp->common, LIBERROR_BAD_OPTION,\n \t\t    \"Cannot change ACTION parameter in OPEN statement\");\n \n   /* Status must be OLD if present.  */\n@@ -159,24 +159,24 @@ edit_modes (st_parameter_open *opp, gfc_unit * u, unit_flags * flags)\n \tnotify_std (&opp->common, GFC_STD_GNU,\n \t\t    \"OPEN statement must have a STATUS of OLD or UNKNOWN\");\n       else\n-\tgenerate_error (&opp->common, ERROR_BAD_OPTION,\n+\tgenerate_error (&opp->common, LIBERROR_BAD_OPTION,\n \t\t    \"OPEN statement must have a STATUS of OLD or UNKNOWN\");\n     }\n \n   if (u->flags.form == FORM_UNFORMATTED)\n     {\n       if (flags->delim != DELIM_UNSPECIFIED)\n-\tgenerate_error (&opp->common, ERROR_OPTION_CONFLICT,\n+\tgenerate_error (&opp->common, LIBERROR_OPTION_CONFLICT,\n \t\t\t\"DELIM parameter conflicts with UNFORMATTED form in \"\n \t\t\t\"OPEN statement\");\n \n       if (flags->blank != BLANK_UNSPECIFIED)\n-\tgenerate_error (&opp->common, ERROR_OPTION_CONFLICT,\n+\tgenerate_error (&opp->common, LIBERROR_OPTION_CONFLICT,\n \t\t\t\"BLANK parameter conflicts with UNFORMATTED form in \"\n \t\t\t\"OPEN statement\");\n \n       if (flags->pad != PAD_UNSPECIFIED)\n-\tgenerate_error (&opp->common, ERROR_OPTION_CONFLICT,\n+\tgenerate_error (&opp->common, LIBERROR_OPTION_CONFLICT,\n \t\t\t\"PAD parameter conflicts with UNFORMATTED form in \"\n \t\t\t\"OPEN statement\");\n     }\n@@ -221,7 +221,7 @@ edit_modes (st_parameter_open *opp, gfc_unit * u, unit_flags * flags)\n       break;\n \n     seek_error:\n-      generate_error (&opp->common, ERROR_OS, NULL);\n+      generate_error (&opp->common, LIBERROR_OS, NULL);\n       break;\n     }\n \n@@ -256,7 +256,7 @@ new_unit (st_parameter_open *opp, gfc_unit *u, unit_flags * flags)\n     {\n       if (flags->form == FORM_UNFORMATTED)\n \t{\n-\t  generate_error (&opp->common, ERROR_OPTION_CONFLICT,\n+\t  generate_error (&opp->common, LIBERROR_OPTION_CONFLICT,\n \t\t\t  \"DELIM parameter conflicts with UNFORMATTED form in \"\n \t\t\t  \"OPEN statement\");\n \t  goto fail;\n@@ -269,7 +269,7 @@ new_unit (st_parameter_open *opp, gfc_unit *u, unit_flags * flags)\n     {\n       if (flags->form == FORM_UNFORMATTED)\n \t{\n-\t  generate_error (&opp->common, ERROR_OPTION_CONFLICT,\n+\t  generate_error (&opp->common, LIBERROR_OPTION_CONFLICT,\n \t\t\t  \"BLANK parameter conflicts with UNFORMATTED form in \"\n \t\t\t  \"OPEN statement\");\n \t  goto fail;\n@@ -282,7 +282,7 @@ new_unit (st_parameter_open *opp, gfc_unit *u, unit_flags * flags)\n     {\n       if (flags->form == FORM_UNFORMATTED)\n \t{\n-\t  generate_error (&opp->common, ERROR_OPTION_CONFLICT,\n+\t  generate_error (&opp->common, LIBERROR_OPTION_CONFLICT,\n \t\t\t  \"PAD parameter conflicts with UNFORMATTED form in \"\n \t\t\t  \"OPEN statement\");\n \t  goto fail;\n@@ -291,7 +291,7 @@ new_unit (st_parameter_open *opp, gfc_unit *u, unit_flags * flags)\n \n   if (flags->position != POSITION_ASIS && flags->access == ACCESS_DIRECT)\n    {\n-     generate_error (&opp->common, ERROR_OPTION_CONFLICT,\n+     generate_error (&opp->common, LIBERROR_OPTION_CONFLICT,\n                      \"ACCESS parameter conflicts with SEQUENTIAL access in \"\n                      \"OPEN statement\");\n      goto fail;\n@@ -309,14 +309,14 @@ new_unit (st_parameter_open *opp, gfc_unit *u, unit_flags * flags)\n   if (flags->access == ACCESS_DIRECT\n       && (opp->common.flags & IOPARM_OPEN_HAS_RECL_IN) == 0)\n     {\n-      generate_error (&opp->common, ERROR_MISSING_OPTION,\n+      generate_error (&opp->common, LIBERROR_MISSING_OPTION,\n \t\t      \"Missing RECL parameter in OPEN statement\");\n       goto fail;\n     }\n \n   if ((opp->common.flags & IOPARM_OPEN_HAS_RECL_IN) && opp->recl_in <= 0)\n     {\n-      generate_error (&opp->common, ERROR_BAD_OPTION,\n+      generate_error (&opp->common, LIBERROR_BAD_OPTION,\n \t\t      \"RECL parameter is non-positive in OPEN statement\");\n       goto fail;\n     }\n@@ -330,7 +330,7 @@ new_unit (st_parameter_open *opp, gfc_unit *u, unit_flags * flags)\n \t  break;\n \t}\n \n-      generate_error (&opp->common, ERROR_BAD_OPTION,\n+      generate_error (&opp->common, LIBERROR_BAD_OPTION,\n \t\t      \"FILE parameter must not be present in OPEN statement\");\n       goto fail;\n \n@@ -366,7 +366,7 @@ new_unit (st_parameter_open *opp, gfc_unit *u, unit_flags * flags)\n       && (options.stderr_unit < 0 || u2->unit_number != options.stderr_unit))\n     {\n       unlock_unit (u2);\n-      generate_error (&opp->common, ERROR_ALREADY_OPEN, NULL);\n+      generate_error (&opp->common, LIBERROR_ALREADY_OPEN, NULL);\n       goto cleanup;\n     }\n \n@@ -405,7 +405,7 @@ new_unit (st_parameter_open *opp, gfc_unit *u, unit_flags * flags)\n \t  msg = NULL;\n \t}\n \n-      generate_error (&opp->common, ERROR_OS, msg);\n+      generate_error (&opp->common, LIBERROR_OS, msg);\n       goto cleanup;\n     }\n \n@@ -431,7 +431,7 @@ new_unit (st_parameter_open *opp, gfc_unit *u, unit_flags * flags)\n   if (flags->position == POSITION_APPEND)\n     {\n       if (sseek (u->s, file_length (u->s)) == FAILURE)\n-\tgenerate_error (&opp->common, ERROR_OS, NULL);\n+\tgenerate_error (&opp->common, LIBERROR_OS, NULL);\n       u->endfile = AT_ENDFILE;\n     }\n \n@@ -544,7 +544,7 @@ already_open (st_parameter_open *opp, gfc_unit * u, unit_flags * flags)\n       if (sclose (u->s) == FAILURE)\n \t{\n \t  unlock_unit (u);\n-\t  generate_error (&opp->common, ERROR_OS,\n+\t  generate_error (&opp->common, LIBERROR_OS,\n \t\t\t  \"Error closing file in OPEN statement\");\n \t  return;\n \t}\n@@ -624,7 +624,7 @@ st_open (st_parameter_open *opp)\n \n   conv = get_unformatted_convert (opp->common.unit);\n \n-  if (conv == CONVERT_NONE)\n+  if (conv == GFC_CONVERT_NONE)\n     {\n       /* Nothing has been set by environment variable, check the convert tag.  */\n       if (cf & IOPARM_OPEN_HAS_CONVERT)\n@@ -639,16 +639,16 @@ st_open (st_parameter_open *opp)\n      and 1 on big-endian machines.  */\n   switch (conv)\n     {\n-    case CONVERT_NATIVE:\n-    case CONVERT_SWAP:\n+    case GFC_CONVERT_NATIVE:\n+    case GFC_CONVERT_SWAP:\n       break;\n       \n-    case CONVERT_BIG:\n-      conv = l8_to_l4_offset ? CONVERT_NATIVE : CONVERT_SWAP;\n+    case GFC_CONVERT_BIG:\n+      conv = l8_to_l4_offset ? GFC_CONVERT_NATIVE : GFC_CONVERT_SWAP;\n       break;\n       \n-    case CONVERT_LITTLE:\n-      conv = l8_to_l4_offset ? CONVERT_SWAP : CONVERT_NATIVE;\n+    case GFC_CONVERT_LITTLE:\n+      conv = l8_to_l4_offset ? GFC_CONVERT_SWAP : GFC_CONVERT_NATIVE;\n       break;\n       \n     default:\n@@ -659,19 +659,19 @@ st_open (st_parameter_open *opp)\n   flags.convert = conv;\n \n   if (opp->common.unit < 0)\n-    generate_error (&opp->common, ERROR_BAD_OPTION,\n+    generate_error (&opp->common, LIBERROR_BAD_OPTION,\n \t\t    \"Bad unit number in OPEN statement\");\n \n   if (flags.position != POSITION_UNSPECIFIED\n       && flags.access == ACCESS_DIRECT)\n-    generate_error (&opp->common, ERROR_BAD_OPTION,\n+    generate_error (&opp->common, LIBERROR_BAD_OPTION,\n \t\t    \"Cannot use POSITION with direct access files\");\n \n   if (flags.access == ACCESS_APPEND)\n     {\n       if (flags.position != POSITION_UNSPECIFIED\n \t  && flags.position != POSITION_APPEND)\n-\tgenerate_error (&opp->common, ERROR_BAD_OPTION,\n+\tgenerate_error (&opp->common, LIBERROR_BAD_OPTION,\n \t\t\t\"Conflicting ACCESS and POSITION flags in\"\n \t\t\t\" OPEN statement\");\n "}, {"sha": "8baa3576af8b99823a065c4eea6036d9fcfe0a51", "filename": "libgfortran/io/read.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d74b97cc7e574d56c7542f40a76b151e7088829b/libgfortran%2Fio%2Fread.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d74b97cc7e574d56c7542f40a76b151e7088829b/libgfortran%2Fio%2Fread.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fread.c?ref=d74b97cc7e574d56c7542f40a76b151e7088829b", "patch": "@@ -175,7 +175,7 @@ convert_real (st_parameter_dt *dtp, void *dest, const char *buffer, int length)\n \n   if (errno == EINVAL)\n     {\n-      generate_error (&dtp->common, ERROR_READ_VALUE,\n+      generate_error (&dtp->common, LIBERROR_READ_VALUE,\n \t\t      \"Error during floating point read\");\n       return 1;\n     }\n@@ -223,7 +223,7 @@ read_l (st_parameter_dt *dtp, const fnode *f, char *dest, int length)\n       break;\n     default:\n     bad:\n-      generate_error (&dtp->common, ERROR_READ_VALUE,\n+      generate_error (&dtp->common, LIBERROR_READ_VALUE,\n \t\t      \"Bad value on logical read\");\n       break;\n     }\n@@ -393,12 +393,12 @@ read_decimal (st_parameter_dt *dtp, const fnode *f, char *dest, int length)\n   return;\n \n  bad:\n-  generate_error (&dtp->common, ERROR_READ_VALUE,\n+  generate_error (&dtp->common, LIBERROR_READ_VALUE,\n \t\t  \"Bad value during integer read\");\n   return;\n \n  overflow:\n-  generate_error (&dtp->common, ERROR_READ_OVERFLOW,\n+  generate_error (&dtp->common, LIBERROR_READ_OVERFLOW,\n \t\t  \"Value overflowed during integer read\");\n   return;\n }\n@@ -537,12 +537,12 @@ read_radix (st_parameter_dt *dtp, const fnode *f, char *dest, int length,\n   return;\n \n  bad:\n-  generate_error (&dtp->common, ERROR_READ_VALUE,\n+  generate_error (&dtp->common, LIBERROR_READ_VALUE,\n \t\t  \"Bad value during integer read\");\n   return;\n \n  overflow:\n-  generate_error (&dtp->common, ERROR_READ_OVERFLOW,\n+  generate_error (&dtp->common, LIBERROR_READ_OVERFLOW,\n \t\t  \"Value overflowed during integer read\");\n   return;\n }\n@@ -657,7 +657,7 @@ read_f (st_parameter_dt *dtp, const fnode *f, char *dest, int length)\n   goto done;\n \n  bad_float:\n-  generate_error (&dtp->common, ERROR_READ_VALUE,\n+  generate_error (&dtp->common, LIBERROR_READ_VALUE,\n \t\t  \"Bad value during floating point read\");\n   return;\n "}, {"sha": "793f1941d04e9cd8adcbc76de2fd648ccf085805", "filename": "libgfortran/io/transfer.c", "status": "modified", "additions": 78, "deletions": 78, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d74b97cc7e574d56c7542f40a76b151e7088829b/libgfortran%2Fio%2Ftransfer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d74b97cc7e574d56c7542f40a76b151e7088829b/libgfortran%2Fio%2Ftransfer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Ftransfer.c?ref=d74b97cc7e574d56c7542f40a76b151e7088829b", "patch": "@@ -185,7 +185,7 @@ read_sf (st_parameter_dt *dtp, int *length, int no_error)\n \t{\n \t  if (no_error)\n \t    break;\n-\t  generate_error (&dtp->common, ERROR_END, NULL);\n+\t  generate_error (&dtp->common, LIBERROR_END, NULL);\n \t  return NULL;\n \t}\n \n@@ -218,7 +218,7 @@ read_sf (st_parameter_dt *dtp, int *length, int no_error)\n \t    {\n \t      if (no_error)\n \t\tbreak;\n-\t      generate_error (&dtp->common, ERROR_EOR, NULL);\n+\t      generate_error (&dtp->common, LIBERROR_EOR, NULL);\n \t      return NULL;\n \t    }\n \n@@ -275,7 +275,7 @@ read_block (st_parameter_dt *dtp, int *length)\n       if (sseek (dtp->u.p.current_unit->s,\n \t\t dtp->u.p.current_unit->strm_pos - 1) == FAILURE)\n \t{\n-\t  generate_error (&dtp->common, ERROR_END, NULL);\n+\t  generate_error (&dtp->common, LIBERROR_END, NULL);\n \t  return NULL;\n \t}\n     }\n@@ -293,15 +293,15 @@ read_block (st_parameter_dt *dtp, int *length)\n \t      if (dtp->u.p.current_unit->flags.pad == PAD_NO)\n \t\t{\n \t\t  /* Not enough data left.  */\n-\t\t  generate_error (&dtp->common, ERROR_EOR, NULL);\n+\t\t  generate_error (&dtp->common, LIBERROR_EOR, NULL);\n \t\t  return NULL;\n \t\t}\n \t    }\n \n \t  if (dtp->u.p.current_unit->bytes_left == 0)\n \t    {\n \t      dtp->u.p.current_unit->endfile = AT_ENDFILE;\n-\t      generate_error (&dtp->common, ERROR_END, NULL);\n+\t      generate_error (&dtp->common, LIBERROR_END, NULL);\n \t      return NULL;\n \t    }\n \n@@ -332,7 +332,7 @@ read_block (st_parameter_dt *dtp, int *length)\n \t*length = nread;\n       else\n \t{\n-\t  generate_error (&dtp->common, ERROR_EOR, NULL);\n+\t  generate_error (&dtp->common, LIBERROR_EOR, NULL);\n \t  source = NULL;\n \t}\n     }\n@@ -360,15 +360,15 @@ read_block_direct (st_parameter_dt *dtp, void *buf, size_t *nbytes)\n       if (sseek (dtp->u.p.current_unit->s,\n \t\t dtp->u.p.current_unit->strm_pos - 1) == FAILURE)\n \t{\n-\t  generate_error (&dtp->common, ERROR_END, NULL);\n+\t  generate_error (&dtp->common, LIBERROR_END, NULL);\n \t  return;\n \t}\n \n       to_read_record = *nbytes;\n       have_read_record = to_read_record;\n       if (sread (dtp->u.p.current_unit->s, buf, &have_read_record) != 0)\n \t{\n-\t  generate_error (&dtp->common, ERROR_OS, NULL);\n+\t  generate_error (&dtp->common, LIBERROR_OS, NULL);\n \t  return;\n \t}\n \n@@ -378,7 +378,7 @@ read_block_direct (st_parameter_dt *dtp, void *buf, size_t *nbytes)\n \t{\n \t  /* Short read,  e.g. if we hit EOF.  For stream files,\n \t   we have to set the end-of-file condition.  */\n-\t  generate_error (&dtp->common, ERROR_END, NULL);\n+\t  generate_error (&dtp->common, LIBERROR_END, NULL);\n \t  return;\n \t}\n       return;\n@@ -403,7 +403,7 @@ read_block_direct (st_parameter_dt *dtp, void *buf, size_t *nbytes)\n \n       if (sread (dtp->u.p.current_unit->s, buf, &to_read_record) != 0)\n \t{\n-\t  generate_error (&dtp->common, ERROR_OS, NULL);\n+\t  generate_error (&dtp->common, LIBERROR_OS, NULL);\n \t  return;\n \t}\n \n@@ -417,7 +417,7 @@ read_block_direct (st_parameter_dt *dtp, void *buf, size_t *nbytes)\n \n       if (short_record)\n \t{\n-\t  generate_error (&dtp->common, ERROR_SHORT_RECORD, NULL);\n+\t  generate_error (&dtp->common, LIBERROR_SHORT_RECORD, NULL);\n \t  return;\n \t}\n       return;\n@@ -429,7 +429,7 @@ read_block_direct (st_parameter_dt *dtp, void *buf, size_t *nbytes)\n \n   if (dtp->u.p.current_unit->endfile == AT_ENDFILE)\n     {\n-      generate_error (&dtp->common, ERROR_END, NULL);\n+      generate_error (&dtp->common, LIBERROR_END, NULL);\n       return;\n     }\n \n@@ -468,7 +468,7 @@ read_block_direct (st_parameter_dt *dtp, void *buf, size_t *nbytes)\n       if (sread (dtp->u.p.current_unit->s, buf + have_read_record,\n \t\t &have_read_subrecord) != 0)\n \t{\n-\t  generate_error (&dtp->common, ERROR_OS, NULL);\n+\t  generate_error (&dtp->common, LIBERROR_OS, NULL);\n \t  return;\n \t}\n \n@@ -482,7 +482,7 @@ read_block_direct (st_parameter_dt *dtp, void *buf, size_t *nbytes)\n \t     marker would still be present.  */\n \n \t  *nbytes = have_read_record;\n-\t  generate_error (&dtp->common, ERROR_CORRUPT_FILE, NULL);\n+\t  generate_error (&dtp->common, LIBERROR_CORRUPT_FILE, NULL);\n \t  return;\n \t}\n \n@@ -500,7 +500,7 @@ read_block_direct (st_parameter_dt *dtp, void *buf, size_t *nbytes)\n \n \t      dtp->u.p.current_unit->current_record = 0;\n \t      next_record_r_unf (dtp, 0);\n-\t      generate_error (&dtp->common, ERROR_SHORT_RECORD, NULL);\n+\t      generate_error (&dtp->common, LIBERROR_SHORT_RECORD, NULL);\n \t      return;\n \t    }\n \t}\n@@ -514,7 +514,7 @@ read_block_direct (st_parameter_dt *dtp, void *buf, size_t *nbytes)\n   dtp->u.p.current_unit->bytes_left -= have_read_record;\n   if (short_record)\n     {\n-      generate_error (&dtp->common, ERROR_SHORT_RECORD, NULL);\n+      generate_error (&dtp->common, LIBERROR_SHORT_RECORD, NULL);\n       return;\n     }\n   return;\n@@ -536,7 +536,7 @@ write_block (st_parameter_dt *dtp, int length)\n       if (sseek (dtp->u.p.current_unit->s,\n \t\t dtp->u.p.current_unit->strm_pos - 1) == FAILURE)\n \t{\n-\t  generate_error (&dtp->common, ERROR_OS, NULL);\n+\t  generate_error (&dtp->common, LIBERROR_OS, NULL);\n \t  return NULL;\n \t}\n     }\n@@ -552,7 +552,7 @@ write_block (st_parameter_dt *dtp, int length)\n \t    dtp->u.p.current_unit->bytes_left = dtp->u.p.current_unit->recl;\n \t  else\n \t    {\n-\t      generate_error (&dtp->common, ERROR_EOR, NULL);\n+\t      generate_error (&dtp->common, LIBERROR_EOR, NULL);\n \t      return NULL;\n \t    }\n \t}\n@@ -564,12 +564,12 @@ write_block (st_parameter_dt *dtp, int length)\n \n   if (dest == NULL)\n     {\n-      generate_error (&dtp->common, ERROR_END, NULL);\n+      generate_error (&dtp->common, LIBERROR_END, NULL);\n       return NULL;\n     }\n \n   if (is_internal_unit (dtp) && dtp->u.p.current_unit->endfile == AT_ENDFILE)\n-    generate_error (&dtp->common, ERROR_END, NULL);\n+    generate_error (&dtp->common, LIBERROR_END, NULL);\n \n   if ((dtp->common.flags & IOPARM_DT_HAS_SIZE) != 0)\n     dtp->u.p.size_used += (gfc_offset) length;\n@@ -599,13 +599,13 @@ write_buf (st_parameter_dt *dtp, void *buf, size_t nbytes)\n       if (sseek (dtp->u.p.current_unit->s,\n \t\t dtp->u.p.current_unit->strm_pos - 1) == FAILURE)\n \t{\n-\t  generate_error (&dtp->common, ERROR_OS, NULL);\n+\t  generate_error (&dtp->common, LIBERROR_OS, NULL);\n \t  return FAILURE;\n \t}\n \n       if (swrite (dtp->u.p.current_unit->s, buf, &nbytes) != 0)\n \t{\n-\t  generate_error (&dtp->common, ERROR_OS, NULL);\n+\t  generate_error (&dtp->common, LIBERROR_OS, NULL);\n \t  return FAILURE;\n \t}\n \n@@ -620,13 +620,13 @@ write_buf (st_parameter_dt *dtp, void *buf, size_t nbytes)\n     {\n       if (dtp->u.p.current_unit->bytes_left < (gfc_offset) nbytes)\n \t{\n-\t  generate_error (&dtp->common, ERROR_DIRECT_EOR, NULL);\n+\t  generate_error (&dtp->common, LIBERROR_DIRECT_EOR, NULL);\n \t  return FAILURE;\n \t}\n \n       if (swrite (dtp->u.p.current_unit->s, buf, &nbytes) != 0)\n \t{\n-\t  generate_error (&dtp->common, ERROR_OS, NULL);\n+\t  generate_error (&dtp->common, LIBERROR_OS, NULL);\n \t  return FAILURE;\n \t}\n \n@@ -665,7 +665,7 @@ write_buf (st_parameter_dt *dtp, void *buf, size_t nbytes)\n       if (swrite (dtp->u.p.current_unit->s, buf + have_written,\n \t\t  &to_write_subrecord) != 0)\n \t{\n-\t  generate_error (&dtp->common, ERROR_OS, NULL);\n+\t  generate_error (&dtp->common, LIBERROR_OS, NULL);\n \t  return FAILURE;\n \t}\n \n@@ -682,7 +682,7 @@ write_buf (st_parameter_dt *dtp, void *buf, size_t nbytes)\n   dtp->u.p.current_unit->bytes_left -= have_written;\n   if (short_record)\n     {\n-      generate_error (&dtp->common, ERROR_SHORT_RECORD, NULL);\n+      generate_error (&dtp->common, LIBERROR_SHORT_RECORD, NULL);\n       return FAILURE;\n     }\n   return SUCCESS;\n@@ -699,7 +699,7 @@ unformatted_read (st_parameter_dt *dtp, bt type,\n   size_t i, sz;\n \n   /* Currently, character implies size=1.  */\n-  if (dtp->u.p.current_unit->flags.convert == CONVERT_NATIVE\n+  if (dtp->u.p.current_unit->flags.convert == GFC_CONVERT_NATIVE\n       || size == 1 || type == BT_CHARACTER)\n     {\n       sz = size * nelems;\n@@ -741,7 +741,7 @@ unformatted_write (st_parameter_dt *dtp, bt type,\n \t\t   void *source, int kind __attribute__((unused)),\n \t\t   size_t size, size_t nelems)\n {\n-  if (dtp->u.p.current_unit->flags.convert == CONVERT_NATIVE ||\n+  if (dtp->u.p.current_unit->flags.convert == GFC_CONVERT_NATIVE ||\n       size == 1 || type == BT_CHARACTER)\n     {\n       size *= nelems;\n@@ -916,7 +916,7 @@ formatted_transfer_scalar (st_parameter_dt *dtp, bt type, void *p, int len,\n \t{\n \t  /* No data descriptors left.  */\n \t  if (n > 0)\n-\t    generate_error (&dtp->common, ERROR_FORMAT,\n+\t    generate_error (&dtp->common, LIBERROR_FORMAT,\n \t\t\"Insufficient data descriptors in format after reversion\");\n \t  return;\n \t}\n@@ -1564,12 +1564,12 @@ us_read (st_parameter_dt *dtp, int continued)\n \n   if (p == NULL || n != nr)\n     {\n-      generate_error (&dtp->common, ERROR_BAD_US, NULL);\n+      generate_error (&dtp->common, LIBERROR_BAD_US, NULL);\n       return;\n     }\n \n-  /* Only CONVERT_NATIVE and CONVERT_SWAP are valid here.  */\n-  if (dtp->u.p.current_unit->flags.convert == CONVERT_NATIVE)\n+  /* Only GFC_CONVERT_NATIVE and GFC_CONVERT_SWAP are valid here.  */\n+  if (dtp->u.p.current_unit->flags.convert == GFC_CONVERT_NATIVE)\n     {\n       switch (nr)\n \t{\n@@ -1639,7 +1639,7 @@ us_write (st_parameter_dt *dtp, int continued)\n     nbytes = compile_options.record_marker ;\n \n   if (swrite (dtp->u.p.current_unit->s, &dummy, &nbytes) != 0)\n-    generate_error (&dtp->common, ERROR_OS, NULL);\n+    generate_error (&dtp->common, LIBERROR_OS, NULL);\n \n   /* For sequential unformatted, if RECL= was not specified in the OPEN\n      we write until we have more bytes than can fit in the subrecord\n@@ -1721,7 +1721,7 @@ data_transfer_init (st_parameter_dt *dtp, int read_flag)\n      {\n        close_unit (dtp->u.p.current_unit);\n        dtp->u.p.current_unit = NULL;\n-       generate_error (&dtp->common, ERROR_BAD_OPTION,\n+       generate_error (&dtp->common, LIBERROR_BAD_OPTION,\n \t\t       \"Bad unit number in OPEN statement\");\n        return;\n      }\n@@ -1743,23 +1743,23 @@ data_transfer_init (st_parameter_dt *dtp, int read_flag)\n \n      conv = get_unformatted_convert (dtp->common.unit);\n \n-     if (conv == CONVERT_NONE)\n+     if (conv == GFC_CONVERT_NONE)\n        conv = compile_options.convert;\n \n      /* We use l8_to_l4_offset, which is 0 on little-endian machines\n \tand 1 on big-endian machines.  */\n      switch (conv)\n        {\n-       case CONVERT_NATIVE:\n-       case CONVERT_SWAP:\n+       case GFC_CONVERT_NATIVE:\n+       case GFC_CONVERT_SWAP:\n \t break;\n \t \n-       case CONVERT_BIG:\n-\t conv = l8_to_l4_offset ? CONVERT_NATIVE : CONVERT_SWAP;\n+       case GFC_CONVERT_BIG:\n+\t conv = l8_to_l4_offset ? GFC_CONVERT_NATIVE : GFC_CONVERT_SWAP;\n \t break;\n       \n-       case CONVERT_LITTLE:\n-\t conv = l8_to_l4_offset ? CONVERT_SWAP : CONVERT_NATIVE;\n+       case GFC_CONVERT_LITTLE:\n+\t conv = l8_to_l4_offset ? GFC_CONVERT_SWAP : GFC_CONVERT_NATIVE;\n \t break;\n \t \n        default:\n@@ -1782,14 +1782,14 @@ data_transfer_init (st_parameter_dt *dtp, int read_flag)\n \n   if (read_flag && dtp->u.p.current_unit->flags.action == ACTION_WRITE)\n     {\n-      generate_error (&dtp->common, ERROR_BAD_ACTION,\n+      generate_error (&dtp->common, LIBERROR_BAD_ACTION,\n \t\t      \"Cannot read from file opened for WRITE\");\n       return;\n     }\n \n   if (!read_flag && dtp->u.p.current_unit->flags.action == ACTION_READ)\n     {\n-      generate_error (&dtp->common, ERROR_BAD_ACTION,\n+      generate_error (&dtp->common, LIBERROR_BAD_ACTION,\n \t\t      \"Cannot write to file opened for READ\");\n       return;\n     }\n@@ -1805,28 +1805,28 @@ data_transfer_init (st_parameter_dt *dtp, int read_flag)\n       && (cf & (IOPARM_DT_HAS_FORMAT | IOPARM_DT_LIST_FORMAT))\n \t != 0)\n     {\n-      generate_error (&dtp->common, ERROR_OPTION_CONFLICT,\n+      generate_error (&dtp->common, LIBERROR_OPTION_CONFLICT,\n \t\t      \"Format present for UNFORMATTED data transfer\");\n       return;\n     }\n \n   if ((cf & IOPARM_DT_HAS_NAMELIST_NAME) != 0 && dtp->u.p.ionml != NULL)\n      {\n \tif ((cf & IOPARM_DT_HAS_FORMAT) != 0)\n-\t   generate_error (&dtp->common, ERROR_OPTION_CONFLICT,\n+\t   generate_error (&dtp->common, LIBERROR_OPTION_CONFLICT,\n \t\t    \"A format cannot be specified with a namelist\");\n      }\n   else if (dtp->u.p.current_unit->flags.form == FORM_FORMATTED &&\n \t   !(cf & (IOPARM_DT_HAS_FORMAT | IOPARM_DT_LIST_FORMAT)))\n     {\n-      generate_error (&dtp->common, ERROR_OPTION_CONFLICT,\n+      generate_error (&dtp->common, LIBERROR_OPTION_CONFLICT,\n \t\t      \"Missing format for FORMATTED data transfer\");\n     }\n \n   if (is_internal_unit (dtp)\n       && dtp->u.p.current_unit->flags.form == FORM_UNFORMATTED)\n     {\n-      generate_error (&dtp->common, ERROR_OPTION_CONFLICT,\n+      generate_error (&dtp->common, LIBERROR_OPTION_CONFLICT,\n \t\t      \"Internal file cannot be accessed by UNFORMATTED \"\n \t\t      \"data transfer\");\n       return;\n@@ -1837,15 +1837,15 @@ data_transfer_init (st_parameter_dt *dtp, int read_flag)\n   if (dtp->u.p.current_unit->flags.access == ACCESS_DIRECT\n       && (cf & IOPARM_DT_HAS_REC) == 0)\n     {\n-      generate_error (&dtp->common, ERROR_MISSING_OPTION,\n+      generate_error (&dtp->common, LIBERROR_MISSING_OPTION,\n \t\t      \"Direct access data transfer requires record number\");\n       return;\n     }\n \n   if (dtp->u.p.current_unit->flags.access == ACCESS_SEQUENTIAL\n       && (cf & IOPARM_DT_HAS_REC) != 0)\n     {\n-      generate_error (&dtp->common, ERROR_OPTION_CONFLICT,\n+      generate_error (&dtp->common, LIBERROR_OPTION_CONFLICT,\n \t\t      \"Record number not allowed for sequential access data transfer\");\n       return;\n     }\n@@ -1861,22 +1861,22 @@ data_transfer_init (st_parameter_dt *dtp, int read_flag)\n     {\n       if (dtp->u.p.current_unit->flags.access == ACCESS_DIRECT)\n \t{\n-\t  generate_error (&dtp->common, ERROR_OPTION_CONFLICT,\n+\t  generate_error (&dtp->common, LIBERROR_OPTION_CONFLICT,\n \t\t\t  \"ADVANCE specification conflicts with sequential access\");\n \t  return;\n \t}\n \n       if (is_internal_unit (dtp))\n \t{\n-\t  generate_error (&dtp->common, ERROR_OPTION_CONFLICT,\n+\t  generate_error (&dtp->common, LIBERROR_OPTION_CONFLICT,\n \t\t\t  \"ADVANCE specification conflicts with internal file\");\n \t  return;\n \t}\n \n       if ((cf & (IOPARM_DT_HAS_FORMAT | IOPARM_DT_LIST_FORMAT))\n \t  != IOPARM_DT_HAS_FORMAT)\n \t{\n-\t  generate_error (&dtp->common, ERROR_OPTION_CONFLICT,\n+\t  generate_error (&dtp->common, LIBERROR_OPTION_CONFLICT,\n \t\t\t  \"ADVANCE specification requires an explicit format\");\n \t  return;\n \t}\n@@ -1886,15 +1886,15 @@ data_transfer_init (st_parameter_dt *dtp, int read_flag)\n     {\n       if ((cf & IOPARM_EOR) != 0 && dtp->u.p.advance_status != ADVANCE_NO)\n \t{\n-\t  generate_error (&dtp->common, ERROR_MISSING_OPTION,\n+\t  generate_error (&dtp->common, LIBERROR_MISSING_OPTION,\n \t\t\t  \"EOR specification requires an ADVANCE specification \"\n \t\t\t  \"of NO\");\n \t  return;\n \t}\n \n       if ((cf & IOPARM_DT_HAS_SIZE) != 0 && dtp->u.p.advance_status != ADVANCE_NO)\n \t{\n-\t  generate_error (&dtp->common, ERROR_MISSING_OPTION,\n+\t  generate_error (&dtp->common, LIBERROR_MISSING_OPTION,\n \t\t\t  \"SIZE specification requires an ADVANCE specification of NO\");\n \t  return;\n \t}\n@@ -1903,21 +1903,21 @@ data_transfer_init (st_parameter_dt *dtp, int read_flag)\n     {\t\t\t\t/* Write constraints.  */\n       if ((cf & IOPARM_END) != 0)\n \t{\n-\t  generate_error (&dtp->common, ERROR_OPTION_CONFLICT,\n+\t  generate_error (&dtp->common, LIBERROR_OPTION_CONFLICT,\n \t\t\t  \"END specification cannot appear in a write statement\");\n \t  return;\n \t}\n \n       if ((cf & IOPARM_EOR) != 0)\n \t{\n-\t  generate_error (&dtp->common, ERROR_OPTION_CONFLICT,\n+\t  generate_error (&dtp->common, LIBERROR_OPTION_CONFLICT,\n \t\t\t  \"EOR specification cannot appear in a write statement\");\n \t  return;\n \t}\n \n       if ((cf & IOPARM_DT_HAS_SIZE) != 0)\n \t{\n-\t  generate_error (&dtp->common, ERROR_OPTION_CONFLICT,\n+\t  generate_error (&dtp->common, LIBERROR_OPTION_CONFLICT,\n \t\t\t  \"SIZE specification cannot appear in a write statement\");\n \t  return;\n \t}\n@@ -1931,14 +1931,14 @@ data_transfer_init (st_parameter_dt *dtp, int read_flag)\n     {\n       if (dtp->rec <= 0)\n \t{\n-\t  generate_error (&dtp->common, ERROR_BAD_OPTION,\n+\t  generate_error (&dtp->common, LIBERROR_BAD_OPTION,\n \t\t\t  \"Record number must be positive\");\n \t  return;\n \t}\n \n       if (dtp->rec >= dtp->u.p.current_unit->maxrec)\n \t{\n-\t  generate_error (&dtp->common, ERROR_BAD_OPTION,\n+\t  generate_error (&dtp->common, LIBERROR_BAD_OPTION,\n \t\t\t  \"Record number too large\");\n \t  return;\n \t}\n@@ -1956,7 +1956,7 @@ data_transfer_init (st_parameter_dt *dtp, int read_flag)\n       if (dtp->u.p.mode == READING && (dtp->rec -1)\n \t  * dtp->u.p.current_unit->recl >= file_length (dtp->u.p.current_unit->s))\n \t{\n-\t  generate_error (&dtp->common, ERROR_BAD_OPTION,\n+\t  generate_error (&dtp->common, LIBERROR_BAD_OPTION,\n \t\t\t  \"Non-existing record number\");\n \t  return;\n \t}\n@@ -1967,7 +1967,7 @@ data_transfer_init (st_parameter_dt *dtp, int read_flag)\n \t  if (sseek (dtp->u.p.current_unit->s, (gfc_offset) (dtp->rec - 1)\n \t\t     * dtp->u.p.current_unit->recl) == FAILURE)\n \t    {\n-\t      generate_error (&dtp->common, ERROR_OS, NULL);\n+\t      generate_error (&dtp->common, LIBERROR_OS, NULL);\n \t      return;\n \t    }\n \t}\n@@ -2033,7 +2033,7 @@ data_transfer_init (st_parameter_dt *dtp, int read_flag)\n     {\n       if (dtp->u.p.current_unit->read_bad && !is_stream_io (dtp))\n \t{\n-\t  generate_error (&dtp->common, ERROR_BAD_OPTION,\n+\t  generate_error (&dtp->common, LIBERROR_BAD_OPTION,\n \t\t\t  \"Cannot READ after a nonadvancing WRITE\");\n \t  return;\n \t}\n@@ -2135,7 +2135,7 @@ skip_record (st_parameter_dt *dtp, size_t bytes)\n       /* Direct access files do not generate END conditions,\n \t only I/O errors.  */\n       if (sseek (dtp->u.p.current_unit->s, new) == FAILURE)\n-\tgenerate_error (&dtp->common, ERROR_OS, NULL);\n+\tgenerate_error (&dtp->common, LIBERROR_OS, NULL);\n     }\n   else\n     {\t\t\t/* Seek by reading data.  */\n@@ -2148,7 +2148,7 @@ skip_record (st_parameter_dt *dtp, size_t bytes)\n \t  p = salloc_r (dtp->u.p.current_unit->s, &rlength);\n \t  if (p == NULL)\n \t    {\n-\t      generate_error (&dtp->common, ERROR_OS, NULL);\n+\t      generate_error (&dtp->common, LIBERROR_OS, NULL);\n \t      return;\n \t    }\n \n@@ -2231,7 +2231,7 @@ next_record_r (st_parameter_dt *dtp)\n \t      record = record * dtp->u.p.current_unit->recl;\n \t      if (sseek (dtp->u.p.current_unit->s, record) == FAILURE)\n \t\t{\n-\t\t  generate_error (&dtp->common, ERROR_INTERNAL_UNIT, NULL);\n+\t\t  generate_error (&dtp->common, LIBERROR_INTERNAL_UNIT, NULL);\n \t\t  break;\n \t\t}\n \t      dtp->u.p.current_unit->bytes_left = dtp->u.p.current_unit->recl;\n@@ -2252,7 +2252,7 @@ next_record_r (st_parameter_dt *dtp)\n \n \t  if (p == NULL)\n \t    {\n-\t      generate_error (&dtp->common, ERROR_OS, NULL);\n+\t      generate_error (&dtp->common, LIBERROR_OS, NULL);\n \t      break;\n \t    }\n \n@@ -2296,8 +2296,8 @@ write_us_marker (st_parameter_dt *dtp, const gfc_offset buf)\n   else\n     len = compile_options.record_marker;\n \n-  /* Only CONVERT_NATIVE and CONVERT_SWAP are valid here.  */\n-  if (dtp->u.p.current_unit->flags.convert == CONVERT_NATIVE)\n+  /* Only GFC_CONVERT_NATIVE and GFC_CONVERT_SWAP are valid here.  */\n+  if (dtp->u.p.current_unit->flags.convert == GFC_CONVERT_NATIVE)\n     {\n       switch (len)\n \t{\n@@ -2393,7 +2393,7 @@ next_record_w_unf (st_parameter_dt *dtp, int next_subrecord)\n   return;\n \n  io_error:\n-  generate_error (&dtp->common, ERROR_OS, NULL);\n+  generate_error (&dtp->common, LIBERROR_OS, NULL);\n   return;\n \n }\n@@ -2461,7 +2461,7 @@ next_record_w (st_parameter_dt *dtp, int done)\n \n \t      if (sset (dtp->u.p.current_unit->s, ' ', length) == FAILURE)\n \t\t{\n-\t\t  generate_error (&dtp->common, ERROR_END, NULL);\n+\t\t  generate_error (&dtp->common, LIBERROR_END, NULL);\n \t\t  return;\n \t\t}\n \n@@ -2476,7 +2476,7 @@ next_record_w (st_parameter_dt *dtp, int done)\n \n \t      if (sseek (dtp->u.p.current_unit->s, record) == FAILURE)\n \t\t{\n-\t\t  generate_error (&dtp->common, ERROR_INTERNAL_UNIT, NULL);\n+\t\t  generate_error (&dtp->common, LIBERROR_INTERNAL_UNIT, NULL);\n \t\t  return;\n \t\t}\n \n@@ -2505,7 +2505,7 @@ next_record_w (st_parameter_dt *dtp, int done)\n \n \t      if (sset (dtp->u.p.current_unit->s, ' ', length) == FAILURE)\n \t\t{\n-\t\t  generate_error (&dtp->common, ERROR_END, NULL);\n+\t\t  generate_error (&dtp->common, LIBERROR_END, NULL);\n \t\t  return;\n \t\t}\n \t    }\n@@ -2542,7 +2542,7 @@ next_record_w (st_parameter_dt *dtp, int done)\n       break;\n \n     io_error:\n-      generate_error (&dtp->common, ERROR_OS, NULL);\n+      generate_error (&dtp->common, LIBERROR_OS, NULL);\n       break;\n     }\n }\n@@ -2603,7 +2603,7 @@ finalize_transfer (st_parameter_dt *dtp)\n \n   if (dtp->u.p.eor_condition)\n     {\n-      generate_error (&dtp->common, ERROR_EOR, NULL);\n+      generate_error (&dtp->common, LIBERROR_EOR, NULL);\n       return;\n     }\n \n@@ -2626,7 +2626,7 @@ finalize_transfer (st_parameter_dt *dtp)\n   dtp->u.p.eof_jump = &eof_jump;\n   if (setjmp (eof_jump))\n     {\n-      generate_error (&dtp->common, ERROR_END, NULL);\n+      generate_error (&dtp->common, LIBERROR_END, NULL);\n       return;\n     }\n \n@@ -2756,14 +2756,14 @@ st_read (st_parameter_dt *dtp)\n       case AT_ENDFILE:\n \tif (!is_internal_unit (dtp))\n \t  {\n-\t    generate_error (&dtp->common, ERROR_END, NULL);\n+\t    generate_error (&dtp->common, LIBERROR_END, NULL);\n \t    dtp->u.p.current_unit->endfile = AFTER_ENDFILE;\n \t    dtp->u.p.current_unit->current_record = 0;\n \t  }\n \tbreak;\n \n       case AFTER_ENDFILE:\n-\tgenerate_error (&dtp->common, ERROR_ENDFILE, NULL);\n+\tgenerate_error (&dtp->common, LIBERROR_ENDFILE, NULL);\n \tdtp->u.p.current_unit->current_record = 0;\n \tbreak;\n       }\n@@ -2825,7 +2825,7 @@ st_write_done (st_parameter_dt *dtp)\n \t  {\n \t    flush (dtp->u.p.current_unit->s);\n \t    if (struncate (dtp->u.p.current_unit->s) == FAILURE)\n-\t      generate_error (&dtp->common, ERROR_OS, NULL);\n+\t      generate_error (&dtp->common, LIBERROR_OS, NULL);\n \t  }\n \tdtp->u.p.current_unit->endfile = AT_ENDFILE;\n \tbreak;"}, {"sha": "a293baba07744ae35023e34ac1b865b9909dc444", "filename": "libgfortran/io/unit.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d74b97cc7e574d56c7542f40a76b151e7088829b/libgfortran%2Fio%2Funit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d74b97cc7e574d56c7542f40a76b151e7088829b/libgfortran%2Fio%2Funit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Funit.c?ref=d74b97cc7e574d56c7542f40a76b151e7088829b", "patch": "@@ -375,7 +375,7 @@ get_internal_unit (st_parameter_dt *dtp)\n   iunit = get_mem (sizeof (gfc_unit));\n   if (iunit == NULL)\n     {\n-      generate_error (&dtp->common, ERROR_INTERNAL_UNIT, NULL);\n+      generate_error (&dtp->common, LIBERROR_INTERNAL_UNIT, NULL);\n       return NULL;\n     }\n "}, {"sha": "7ce198a1f0ebb52ee09853acc9f123ec77cd3b91", "filename": "libgfortran/libgfortran.h", "status": "modified", "additions": 4, "deletions": 85, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d74b97cc7e574d56c7542f40a76b151e7088829b/libgfortran%2Flibgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d74b97cc7e574d56c7542f40a76b151e7088829b/libgfortran%2Flibgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Flibgfortran.h?ref=d74b97cc7e574d56c7542f40a76b151e7088829b", "patch": "@@ -37,16 +37,14 @@ Boston, MA 02110-1301, USA.  */\n #include <float.h>\n #include <stdarg.h>\n \n-#ifndef M_PI\n-#define M_PI 3.14159265358979323846264338327\n-#endif\n-\n #if HAVE_COMPLEX_H\n # include <complex.h>\n #else\n #define complex __complex__\n #endif\n \n+#include \"../gcc/fortran/libgfortran.h\"\n+\n #include \"config.h\"\n #include \"c99_protos.h\"\n \n@@ -276,9 +274,6 @@ internal_proto(l8_to_l4_offset);\n #define GFC_REAL_16_RADIX FLT_RADIX\n #endif\n \n-#ifndef GFC_MAX_DIMENSIONS\n-#define GFC_MAX_DIMENSIONS 7\n-#endif\n \n typedef struct descriptor_dimension\n {\n@@ -330,25 +325,6 @@ typedef GFC_ARRAY_DESCRIPTOR (GFC_MAX_DIMENSIONS, GFC_LOGICAL_8) gfc_array_l8;\n typedef GFC_ARRAY_DESCRIPTOR (GFC_MAX_DIMENSIONS, GFC_LOGICAL_16) gfc_array_l16;\n #endif\n \n-#define GFC_DTYPE_RANK_MASK 0x07\n-#define GFC_DTYPE_TYPE_SHIFT 3\n-#define GFC_DTYPE_TYPE_MASK 0x38\n-#define GFC_DTYPE_SIZE_SHIFT 6\n-\n-/* added for f03.  --Rickett, 02.28.06 */\n-#define GFC_NUM_RANK_BITS 3\n-\n-enum\n-{\n-  GFC_DTYPE_UNKNOWN = 0,\n-  GFC_DTYPE_INTEGER,\n-  /* TODO: recognize logical types.  */\n-  GFC_DTYPE_LOGICAL,\n-  GFC_DTYPE_REAL,\n-  GFC_DTYPE_COMPLEX,\n-  GFC_DTYPE_DERIVED,\n-  GFC_DTYPE_CHARACTER\n-};\n \n #define GFC_DESCRIPTOR_RANK(desc) ((desc)->dtype & GFC_DTYPE_RANK_MASK)\n #define GFC_DESCRIPTOR_TYPE(desc) (((desc)->dtype & GFC_DTYPE_TYPE_MASK) \\\n@@ -423,60 +399,6 @@ typedef struct\n }\n st_option;\n \n-/* Runtime errors.  The EOR and EOF errors are required to be negative.\n-   These codes must be kept sychronized with their equivalents in\n-   gcc/fortran/gfortran.h .  */\n-\n-typedef enum\n-{\n-  ERROR_FIRST = -3,\t\t/* Marker for the first error.  */\n-  ERROR_EOR = -2,\n-  ERROR_END = -1,\n-  ERROR_OK = 0,\t\t\t/* Indicates success, must be zero.  */\n-  ERROR_OS = 5000,\t\t/* Operating system error, more info in errno.  */\n-  ERROR_OPTION_CONFLICT,\n-  ERROR_BAD_OPTION,\n-  ERROR_MISSING_OPTION,\n-  ERROR_ALREADY_OPEN,\n-  ERROR_BAD_UNIT,\n-  ERROR_FORMAT,\n-  ERROR_BAD_ACTION,\n-  ERROR_ENDFILE,\n-  ERROR_BAD_US,\n-  ERROR_READ_VALUE,\n-  ERROR_READ_OVERFLOW,\n-  ERROR_INTERNAL,\n-  ERROR_INTERNAL_UNIT,\n-  ERROR_ALLOCATION,\t\t/* Keep in sync with value used in\n-\t\t\t\t   gcc/fortran/trans.c\n-\t\t\t\t   (gfc_allocate_array_with_status).  */\n-  ERROR_DIRECT_EOR,\n-  ERROR_SHORT_RECORD,\n-  ERROR_CORRUPT_FILE,\n-  ERROR_LAST\t\t\t/* Not a real error, the last error # + 1.  */\n-}\n-error_codes;\n-\n-\n-/* Flags to specify which standard/extension contains a feature.\n-   Keep them in sync with their counterparts in gcc/fortran/gfortran.h.  */\n-#define GFC_STD_LEGACY          (1<<6) /* Backward compatibility.  */\n-#define GFC_STD_GNU             (1<<5)    /* GNU Fortran extension.  */\n-#define GFC_STD_F2003           (1<<4)    /* New in F2003.  */\n-/* Note that no features were obsoleted nor deleted in F2003.  */\n-#define GFC_STD_F95             (1<<3)    /* New in F95.  */\n-#define GFC_STD_F95_DEL         (1<<2)    /* Deleted in F95.  */\n-#define GFC_STD_F95_OBS         (1<<1)    /* Obsoleted in F95.  */\n-#define GFC_STD_F77             (1<<0)    /* Up to and including F77.  */\n-\n-/* Bitmasks for the various FPE that can be enabled.\n-   Keep them in sync with their counterparts in gcc/fortran/gfortran.h.  */\n-#define GFC_FPE_INVALID    (1<<0)\n-#define GFC_FPE_DENORMAL   (1<<1)\n-#define GFC_FPE_ZERO       (1<<2)\n-#define GFC_FPE_OVERFLOW   (1<<3)\n-#define GFC_FPE_UNDERFLOW  (1<<4)\n-#define GFC_FPE_PRECISION  (1<<5)\n \n /* This is returned by notification_std to know if, given the flags\n    that were given (-std=, -pedantic) we should issue an error, a warning\n@@ -505,18 +427,15 @@ iexport_data_proto(filename);\n #define gfc_alloca(x)  __builtin_alloca(x)\n \n \n-/* Various I/O stuff also used in other parts of the library.  */\n-\n+/* Directory for creating temporary files.  Only used when none of the\n+   following environment variables exist: GFORTRAN_TMPDIR, TMP and TEMP.  */\n #define DEFAULT_TEMPDIR \"/tmp\"\n \n /* The default value of record length for preconnected units is defined\n    here. This value can be overriden by an environment variable.\n    Default value is 1 Gb.  */\n #define DEFAULT_RECL 1073741824\n \n-typedef enum\n-{ CONVERT_NONE=-1, CONVERT_NATIVE, CONVERT_SWAP, CONVERT_BIG, CONVERT_LITTLE }\n-unit_convert;\n \n #define CHARACTER2(name) \\\n               gfc_charlen_type name ## _len; \\"}, {"sha": "62e4cfaf24791ca888f3bdb4e7af908497872ef8", "filename": "libgfortran/runtime/environ.c", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d74b97cc7e574d56c7542f40a76b151e7088829b/libgfortran%2Fruntime%2Fenviron.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d74b97cc7e574d56c7542f40a76b151e7088829b/libgfortran%2Fruntime%2Fenviron.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fruntime%2Fenviron.c?ref=d74b97cc7e574d56c7542f40a76b151e7088829b", "patch": "@@ -460,17 +460,18 @@ show_signal (variable * v)\n \n \n static variable variable_table[] = {\n-  {\"GFORTRAN_STDIN_UNIT\", 5, &options.stdin_unit, init_integer, show_integer,\n+  {\"GFORTRAN_STDIN_UNIT\", GFC_STDIN_UNIT_NUMBER, &options.stdin_unit,\n+   init_integer, show_integer,\n    \"Unit number that will be preconnected to standard input\\n\"\n    \"(No preconnection if negative)\", 0},\n \n-  {\"GFORTRAN_STDOUT_UNIT\", 6, &options.stdout_unit, init_integer,\n-   show_integer,\n+  {\"GFORTRAN_STDOUT_UNIT\", GFC_STDOUT_UNIT_NUMBER, &options.stdout_unit,\n+   init_integer, show_integer,\n    \"Unit number that will be preconnected to standard output\\n\"\n    \"(No preconnection if negative)\", 0},\n \n-  {\"GFORTRAN_STDERR_UNIT\", 0, &options.stderr_unit, init_integer,\n-   show_integer,\n+  {\"GFORTRAN_STDERR_UNIT\", GFC_STDERR_UNIT_NUMBER, &options.stderr_unit,\n+   init_integer, show_integer,\n    \"Unit number that will be preconnected to standard error\\n\"\n    \"(No preconnection if negative)\", 0},\n \n@@ -622,7 +623,7 @@ show_variables (void)\n   st_printf (\"\\nRuntime error codes:\");\n   st_printf (\"\\n--------------------\\n\");\n \n-  for (n = ERROR_FIRST + 1; n < ERROR_LAST; n++)\n+  for (n = LIBERROR_FIRST + 1; n < LIBERROR_LAST; n++)\n     if (n < 0 || n > 9)\n       st_printf (\"%d  %s\\n\", n, translate_error (n));\n     else\n@@ -881,19 +882,19 @@ do_parse (void)\n   switch (tok)\n     {\n     case NATIVE:\n-      endian = CONVERT_NATIVE;\n+      endian = GFC_CONVERT_NATIVE;\n       break;\n \n     case SWAP:\n-      endian = CONVERT_SWAP;\n+      endian = GFC_CONVERT_SWAP;\n       break;\n \n     case BIG:\n-      endian = CONVERT_BIG;\n+      endian = GFC_CONVERT_BIG;\n       break;\n \n     case LITTLE:\n-      endian = CONVERT_LITTLE;\n+      endian = GFC_CONVERT_LITTLE;\n       break;\n \n     case INTEGER:\n@@ -948,25 +949,25 @@ do_parse (void)\n \tcase NATIVE:\n \t  if (next_token () != ':')\n \t    goto error;\n-\t  endian = CONVERT_NATIVE;\n+\t  endian = GFC_CONVERT_NATIVE;\n \t  break;\n \n \tcase SWAP:\n \t  if (next_token () != ':')\n \t    goto error;\n-\t  endian = CONVERT_SWAP;\n+\t  endian = GFC_CONVERT_SWAP;\n \t  break;\n \n \tcase LITTLE:\n \t  if (next_token () != ':')\n \t    goto error;\n-\t  endian = CONVERT_LITTLE;\n+\t  endian = GFC_CONVERT_LITTLE;\n \t  break;\n \n \tcase BIG:\n \t  if (next_token () != ':')\n \t    goto error;\n-\t  endian = CONVERT_BIG;\n+\t  endian = GFC_CONVERT_BIG;\n \t  break;\n \n \tcase INTEGER:\n@@ -1034,15 +1035,15 @@ do_parse (void)\n  end:\n   return 0;\n  error:\n-  def = CONVERT_NONE;\n+  def = GFC_CONVERT_NONE;\n   return -1;\n }\n \n void init_unformatted (variable * v)\n {\n   char *val;\n   val = getenv (v->name);\n-  def = CONVERT_NONE;\n+  def = GFC_CONVERT_NONE;\n   n_elist = 0;\n \n   if (val == NULL)"}, {"sha": "279e26518ea611da26a280edc86ad172c44f0c3f", "filename": "libgfortran/runtime/error.c", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d74b97cc7e574d56c7542f40a76b151e7088829b/libgfortran%2Fruntime%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d74b97cc7e574d56c7542f40a76b151e7088829b/libgfortran%2Fruntime%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fruntime%2Ferror.c?ref=d74b97cc7e574d56c7542f40a76b151e7088829b", "patch": "@@ -310,83 +310,83 @@ translate_error (int code)\n \n   switch (code)\n     {\n-    case ERROR_EOR:\n+    case LIBERROR_EOR:\n       p = \"End of record\";\n       break;\n \n-    case ERROR_END:\n+    case LIBERROR_END:\n       p = \"End of file\";\n       break;\n \n-    case ERROR_OK:\n+    case LIBERROR_OK:\n       p = \"Successful return\";\n       break;\n \n-    case ERROR_OS:\n+    case LIBERROR_OS:\n       p = \"Operating system error\";\n       break;\n \n-    case ERROR_BAD_OPTION:\n+    case LIBERROR_BAD_OPTION:\n       p = \"Bad statement option\";\n       break;\n \n-    case ERROR_MISSING_OPTION:\n+    case LIBERROR_MISSING_OPTION:\n       p = \"Missing statement option\";\n       break;\n \n-    case ERROR_OPTION_CONFLICT:\n+    case LIBERROR_OPTION_CONFLICT:\n       p = \"Conflicting statement options\";\n       break;\n \n-    case ERROR_ALREADY_OPEN:\n+    case LIBERROR_ALREADY_OPEN:\n       p = \"File already opened in another unit\";\n       break;\n \n-    case ERROR_BAD_UNIT:\n+    case LIBERROR_BAD_UNIT:\n       p = \"Unattached unit\";\n       break;\n \n-    case ERROR_FORMAT:\n+    case LIBERROR_FORMAT:\n       p = \"FORMAT error\";\n       break;\n \n-    case ERROR_BAD_ACTION:\n+    case LIBERROR_BAD_ACTION:\n       p = \"Incorrect ACTION specified\";\n       break;\n \n-    case ERROR_ENDFILE:\n+    case LIBERROR_ENDFILE:\n       p = \"Read past ENDFILE record\";\n       break;\n \n-    case ERROR_BAD_US:\n+    case LIBERROR_BAD_US:\n       p = \"Corrupt unformatted sequential file\";\n       break;\n \n-    case ERROR_READ_VALUE:\n+    case LIBERROR_READ_VALUE:\n       p = \"Bad value during read\";\n       break;\n \n-    case ERROR_READ_OVERFLOW:\n+    case LIBERROR_READ_OVERFLOW:\n       p = \"Numeric overflow on read\";\n       break;\n \n-    case ERROR_INTERNAL:\n+    case LIBERROR_INTERNAL:\n       p = \"Internal error in run-time library\";\n       break;\n \n-    case ERROR_INTERNAL_UNIT:\n+    case LIBERROR_INTERNAL_UNIT:\n       p = \"Internal unit I/O error\";\n       break;\n \n-    case ERROR_DIRECT_EOR:\n+    case LIBERROR_DIRECT_EOR:\n       p = \"Write exceeds length of DIRECT access record\";\n       break;\n \n-    case ERROR_SHORT_RECORD:\n+    case LIBERROR_SHORT_RECORD:\n       p = \"I/O past end of record on unformatted file\";\n       break;\n \n-    case ERROR_CORRUPT_FILE:\n+    case LIBERROR_CORRUPT_FILE:\n       p = \"Unformatted file structure has been corrupted\";\n       break;\n \n@@ -412,11 +412,11 @@ generate_error (st_parameter_common *cmp, int family, const char *message)\n {\n   /* Set the error status.  */\n   if ((cmp->flags & IOPARM_HAS_IOSTAT))\n-    *cmp->iostat = (family == ERROR_OS) ? errno : family;\n+    *cmp->iostat = (family == LIBERROR_OS) ? errno : family;\n \n   if (message == NULL)\n     message =\n-      (family == ERROR_OS) ? get_oserror () : translate_error (family);\n+      (family == LIBERROR_OS) ? get_oserror () : translate_error (family);\n \n   if (cmp->flags & IOPARM_HAS_IOMSG)\n     cf_strcpy (cmp->iomsg, cmp->iomsg_len, message);\n@@ -425,13 +425,13 @@ generate_error (st_parameter_common *cmp, int family, const char *message)\n   cmp->flags &= ~IOPARM_LIBRETURN_MASK;\n   switch (family)\n     {\n-    case ERROR_EOR:\n+    case LIBERROR_EOR:\n       cmp->flags |= IOPARM_LIBRETURN_EOR;\n       if ((cmp->flags & IOPARM_EOR))\n \treturn;\n       break;\n \n-    case ERROR_END:\n+    case LIBERROR_END:\n       cmp->flags |= IOPARM_LIBRETURN_END;\n       if ((cmp->flags & IOPARM_END))\n \treturn;"}, {"sha": "ee7bcfb4be8ad23d8b73c574988a9149eeaddc37", "filename": "libgfortran/runtime/string.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d74b97cc7e574d56c7542f40a76b151e7088829b/libgfortran%2Fruntime%2Fstring.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d74b97cc7e574d56c7542f40a76b151e7088829b/libgfortran%2Fruntime%2Fstring.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fruntime%2Fstring.c?ref=d74b97cc7e574d56c7542f40a76b151e7088829b", "patch": "@@ -122,7 +122,7 @@ find_option (st_parameter_common *cmp, const char *s1, gfc_charlen_type s1_len,\n     if (compare0 (s1, s1_len, opts->name))\n       return opts->value;\n \n-  generate_error (cmp, ERROR_BAD_OPTION, error_message);\n+  generate_error (cmp, LIBERROR_BAD_OPTION, error_message);\n \n   return -1;\n }"}]}