{"sha": "2d8d93c783dd43769075fa0474d670f6fb4a85f1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmQ4ZDkzYzc4M2RkNDM3NjkwNzVmYTA0NzRkNjcwZjZmYjRhODVmMQ==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@gmail.com", "date": "2019-01-07T22:54:40Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2019-01-07T22:54:40Z"}, "message": "genattrtab bit-rot, and if_then_else in values\n\nThis patch started off just by adding if_then_else support in\nwrite_attr_value to be able to write a saner expression for powerpc\ntls_gdld_nomark length.  Then I noticed bit-rot in functions used to\ncalculate insn_default_length, insn_min_length, and length_unit_log\n(which are used by the shorten_branches pass).  These functions\ndon't handle a const_int length value and return an \"unknown\" status\nthat isn't used, or in the case of or_attr_value, doesn't need to be\nused.  min_attr_value also attempts to return INT_MAX for the\nunhandled rtl case, but this can get lost in recursive calls.  I fixed\nthat problem by returning INT_MIN instead, and translating that to\nINT_MAX in the only caller of min_attr_value.\n\n\tPR target/88614\n\t* genattrtab.c (max_attr_value, min_attr_value, or_attr_value):\n\tDelete \"unknownp\" parameter.  Adjust callers.  Handle\n\tCONST_INT, PLUS, MINUS, and MULT.\n\t(attr_value_aligned): Renamed from or_attr_value.\n\t(min_attr_value): Return INT_MIN for unhandled rtl case..\n\t(min_fn): ..and translate to INT_MAX here.\n\t(write_length_unit_log): Modify to cope without \"unknown\".\n\t(write_attr_value): Handle IF_THEN_ELSE.\n\nFrom-SVN: r267666", "tree": {"sha": "04317764b127d1d3db9709771cee17d5370e8017", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/04317764b127d1d3db9709771cee17d5370e8017"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2d8d93c783dd43769075fa0474d670f6fb4a85f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d8d93c783dd43769075fa0474d670f6fb4a85f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2d8d93c783dd43769075fa0474d670f6fb4a85f1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d8d93c783dd43769075fa0474d670f6fb4a85f1/comments", "author": {"login": "amodra", "id": 6006325, "node_id": "MDQ6VXNlcjYwMDYzMjU=", "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4", "gravatar_id": "", "url": "https://api.github.com/users/amodra", "html_url": "https://github.com/amodra", "followers_url": "https://api.github.com/users/amodra/followers", "following_url": "https://api.github.com/users/amodra/following{/other_user}", "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}", "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/amodra/subscriptions", "organizations_url": "https://api.github.com/users/amodra/orgs", "repos_url": "https://api.github.com/users/amodra/repos", "events_url": "https://api.github.com/users/amodra/events{/privacy}", "received_events_url": "https://api.github.com/users/amodra/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "65c5b1eb85f8f0f3078f614d549f107ee9a001af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65c5b1eb85f8f0f3078f614d549f107ee9a001af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/65c5b1eb85f8f0f3078f614d549f107ee9a001af"}], "stats": {"total": 200, "additions": 155, "deletions": 45}, "files": [{"sha": "daf98c3b75bb1bdf6599ab2f3b3af186073a8b58", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d8d93c783dd43769075fa0474d670f6fb4a85f1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d8d93c783dd43769075fa0474d670f6fb4a85f1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2d8d93c783dd43769075fa0474d670f6fb4a85f1", "patch": "@@ -1,3 +1,15 @@\n+2019-01-08  Alan Modra  <amodra@gmail.com>\n+\n+\tPR target/88614\n+\t* genattrtab.c (max_attr_value, min_attr_value, or_attr_value):\n+\tDelete \"unknownp\" parameter.  Adjust callers.  Handle\n+\tCONST_INT, PLUS, MINUS, and MULT.\n+\t(attr_value_aligned): Renamed from or_attr_value.\n+\t(min_attr_value): Return INT_MIN for unhandled rtl case..\n+\t(min_fn): ..and translate to INT_MAX here.\n+\t(write_length_unit_log): Modify to cope without \"unknown\".\n+\t(write_attr_value): Handle IF_THEN_ELSE.\n+\n 2019-01-07  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* tree-vect-stmts.c (vectorizable_store): Don't use the dataref_offset"}, {"sha": "1dd4f14267290db7f5e9bd89df562d686369ea5e", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 143, "deletions": 45, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d8d93c783dd43769075fa0474d670f6fb4a85f1/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d8d93c783dd43769075fa0474d670f6fb4a85f1/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=2d8d93c783dd43769075fa0474d670f6fb4a85f1", "patch": "@@ -266,9 +266,9 @@ static int compares_alternatives_p (rtx);\n static void make_internal_attr     (const char *, rtx, int);\n static void insert_insn_ent        (struct attr_value *, struct insn_ent *);\n static void walk_attr_value\t   (rtx);\n-static int max_attr_value\t   (rtx, int*);\n-static int min_attr_value\t   (rtx, int*);\n-static int or_attr_value\t   (rtx, int*);\n+static int max_attr_value\t   (rtx);\n+static int min_attr_value\t   (rtx);\n+static unsigned int attr_value_alignment (rtx);\n static rtx simplify_test_exp\t   (rtx, int, int);\n static rtx simplify_test_exp_in_temp (rtx, int, int);\n static rtx copy_rtx_unchanging\t   (rtx);\n@@ -1550,15 +1550,16 @@ one_fn (rtx exp ATTRIBUTE_UNUSED)\n static rtx\n max_fn (rtx exp)\n {\n-  int unknown;\n-  return make_numeric_value (max_attr_value (exp, &unknown));\n+  return make_numeric_value (max_attr_value (exp));\n }\n \n static rtx\n min_fn (rtx exp)\n {\n-  int unknown;\n-  return make_numeric_value (min_attr_value (exp, &unknown));\n+  int val = min_attr_value (exp);\n+  if (val < 0)\n+    val = INT_MAX;\n+  return make_numeric_value (val);\n }\n \n static void\n@@ -1568,24 +1569,21 @@ write_length_unit_log (FILE *outf)\n   struct attr_value *av;\n   struct insn_ent *ie;\n   unsigned int length_unit_log, length_or;\n-  int unknown = 0;\n \n   if (length_attr)\n     {\n-      length_or = or_attr_value (length_attr->default_val->value, &unknown);\n+      length_or = attr_value_alignment (length_attr->default_val->value);\n       for (av = length_attr->first_value; av; av = av->next)\n \tfor (ie = av->first_insn; ie; ie = ie->next)\n-\t  length_or |= or_attr_value (av->value, &unknown);\n-    }\n+\t  length_or |= attr_value_alignment (av->value);\n \n-  if (length_attr == NULL || unknown)\n-    length_unit_log = 0;\n-  else\n-    {\n       length_or = ~length_or;\n       for (length_unit_log = 0; length_or & 1; length_or >>= 1)\n \tlength_unit_log++;\n     }\n+  else\n+    length_unit_log = 0;\n+\n   fprintf (outf, \"EXPORTED_CONST int length_unit_log = %u;\\n\", length_unit_log);\n }\n \n@@ -3753,11 +3751,12 @@ write_test_expr (FILE *outf, rtx exp, unsigned int attrs_cached, int flags,\n   return attrs_cached;\n }\n \n-/* Given an attribute value, return the maximum CONST_STRING argument\n-   encountered.  Set *UNKNOWNP and return INT_MAX if the value is unknown.  */\n+/* Given an attribute value expression, return the maximum value that\n+   might be evaluated.  Return INT_MAX if the value can't be\n+   calculated by this function.  */\n \n static int\n-max_attr_value (rtx exp, int *unknownp)\n+max_attr_value (rtx exp)\n {\n   int current_max;\n   int i, n;\n@@ -3768,37 +3767,75 @@ max_attr_value (rtx exp, int *unknownp)\n       current_max = atoi (XSTR (exp, 0));\n       break;\n \n+    case CONST_INT:\n+      current_max = INTVAL (exp);\n+      break;\n+\n+    case PLUS:\n+      current_max = max_attr_value (XEXP (exp, 0));\n+      if (current_max != INT_MAX)\n+\t{\n+\t  n = current_max;\n+\t  current_max = max_attr_value (XEXP (exp, 1));\n+\t  if (current_max != INT_MAX)\n+\t    current_max += n;\n+\t}\n+      break;\n+\n+    case MINUS:\n+      current_max = max_attr_value (XEXP (exp, 0));\n+      if (current_max != INT_MAX)\n+\t{\n+\t  n = min_attr_value (XEXP (exp, 1));\n+\t  if (n == INT_MIN)\n+\t    current_max = INT_MAX;\n+\t  else\n+\t    current_max -= n;\n+\t}\n+      break;\n+\n+    case MULT:\n+      current_max = max_attr_value (XEXP (exp, 0));\n+      if (current_max != INT_MAX)\n+\t{\n+\t  n = current_max;\n+\t  current_max = max_attr_value (XEXP (exp, 1));\n+\t  if (current_max != INT_MAX)\n+\t    current_max *= n;\n+\t}\n+      break;\n+\n     case COND:\n-      current_max = max_attr_value (XEXP (exp, 1), unknownp);\n+      current_max = max_attr_value (XEXP (exp, 1));\n       for (i = 0; i < XVECLEN (exp, 0); i += 2)\n \t{\n-\t  n = max_attr_value (XVECEXP (exp, 0, i + 1), unknownp);\n+\t  n = max_attr_value (XVECEXP (exp, 0, i + 1));\n \t  if (n > current_max)\n \t    current_max = n;\n \t}\n       break;\n \n     case IF_THEN_ELSE:\n-      current_max = max_attr_value (XEXP (exp, 1), unknownp);\n-      n = max_attr_value (XEXP (exp, 2), unknownp);\n+      current_max = max_attr_value (XEXP (exp, 1));\n+      n = max_attr_value (XEXP (exp, 2));\n       if (n > current_max)\n \tcurrent_max = n;\n       break;\n \n     default:\n-      *unknownp = 1;\n       current_max = INT_MAX;\n       break;\n     }\n \n   return current_max;\n }\n \n-/* Given an attribute value, return the minimum CONST_STRING argument\n-   encountered.  Set *UNKNOWNP and return 0 if the value is unknown.  */\n+/* Given an attribute value expression, return the minimum value that\n+   might be evaluated.  Return INT_MIN if the value can't be\n+   calculated by this function.  */\n \n static int\n-min_attr_value (rtx exp, int *unknownp)\n+min_attr_value (rtx exp)\n {\n   int current_min;\n   int i, n;\n@@ -3809,40 +3846,77 @@ min_attr_value (rtx exp, int *unknownp)\n       current_min = atoi (XSTR (exp, 0));\n       break;\n \n+    case CONST_INT:\n+      current_min = INTVAL (exp);\n+      break;\n+\n+    case PLUS:\n+      current_min = min_attr_value (XEXP (exp, 0));\n+      if (current_min != INT_MIN)\n+\t{\n+\t  n = current_min;\n+\t  current_min = min_attr_value (XEXP (exp, 1));\n+\t  if (current_min != INT_MIN)\n+\t    current_min += n;\n+\t}\n+      break;\n+\n+    case MINUS:\n+      current_min = min_attr_value (XEXP (exp, 0));\n+      if (current_min != INT_MIN)\n+\t{\n+\t  n = max_attr_value (XEXP (exp, 1));\n+\t  if (n == INT_MAX)\n+\t    current_min = INT_MIN;\n+\t  else\n+\t    current_min -= n;\n+\t}\n+      break;\n+\n+    case MULT:\n+      current_min = min_attr_value (XEXP (exp, 0));\n+      if (current_min != INT_MIN)\n+\t{\n+\t  n = current_min;\n+\t  current_min = min_attr_value (XEXP (exp, 1));\n+\t  if (current_min != INT_MIN)\n+\t    current_min *= n;\n+\t}\n+      break;\n+\n     case COND:\n-      current_min = min_attr_value (XEXP (exp, 1), unknownp);\n+      current_min = min_attr_value (XEXP (exp, 1));\n       for (i = 0; i < XVECLEN (exp, 0); i += 2)\n \t{\n-\t  n = min_attr_value (XVECEXP (exp, 0, i + 1), unknownp);\n+\t  n = min_attr_value (XVECEXP (exp, 0, i + 1));\n \t  if (n < current_min)\n \t    current_min = n;\n \t}\n       break;\n \n     case IF_THEN_ELSE:\n-      current_min = min_attr_value (XEXP (exp, 1), unknownp);\n-      n = min_attr_value (XEXP (exp, 2), unknownp);\n+      current_min = min_attr_value (XEXP (exp, 1));\n+      n = min_attr_value (XEXP (exp, 2));\n       if (n < current_min)\n \tcurrent_min = n;\n       break;\n \n     default:\n-      *unknownp = 1;\n-      current_min = INT_MAX;\n+      current_min = INT_MIN;\n       break;\n     }\n \n   return current_min;\n }\n \n-/* Given an attribute value, return the result of ORing together all\n-   CONST_STRING arguments encountered.  Set *UNKNOWNP and return -1\n-   if the numeric value is not known.  */\n+/* Given an attribute value expression, return the alignment of values.\n+   Return 0 if EXP is known to be zero, and 1 if the value can't be\n+   calculated by this function.  */\n \n-static int\n-or_attr_value (rtx exp, int *unknownp)\n+static unsigned int\n+attr_value_alignment (rtx exp)\n {\n-  int current_or;\n+  unsigned int current_or;\n   int i;\n \n   switch (GET_CODE (exp))\n@@ -3851,24 +3925,38 @@ or_attr_value (rtx exp, int *unknownp)\n       current_or = atoi (XSTR (exp, 0));\n       break;\n \n+    case CONST_INT:\n+      current_or = INTVAL (exp);\n+      break;\n+\n+    case PLUS:\n+    case MINUS:\n+      current_or = attr_value_alignment (XEXP (exp, 0));\n+      current_or |= attr_value_alignment (XEXP (exp, 1));\n+      break;\n+\n+    case MULT:\n+      current_or = attr_value_alignment (XEXP (exp, 0));\n+      current_or *= attr_value_alignment (XEXP (exp, 1));\n+      break;\n+\n     case COND:\n-      current_or = or_attr_value (XEXP (exp, 1), unknownp);\n+      current_or = attr_value_alignment (XEXP (exp, 1));\n       for (i = 0; i < XVECLEN (exp, 0); i += 2)\n-\tcurrent_or |= or_attr_value (XVECEXP (exp, 0, i + 1), unknownp);\n+\tcurrent_or |= attr_value_alignment (XVECEXP (exp, 0, i + 1));\n       break;\n \n     case IF_THEN_ELSE:\n-      current_or = or_attr_value (XEXP (exp, 1), unknownp);\n-      current_or |= or_attr_value (XEXP (exp, 2), unknownp);\n+      current_or = attr_value_alignment (XEXP (exp, 1));\n+      current_or |= attr_value_alignment (XEXP (exp, 2));\n       break;\n \n     default:\n-      *unknownp = 1;\n-      current_or = -1;\n+      current_or = 1;\n       break;\n     }\n \n-  return current_or;\n+  return current_or & -current_or;\n }\n \n /* Scan an attribute value, possibly a conditional, and record what actions\n@@ -4343,6 +4431,16 @@ write_attr_value (FILE *outf, struct attr_desc *attr, rtx value)\n       write_attr_value (outf, attr, XEXP (value, 1));\n       break;\n \n+    case IF_THEN_ELSE:\n+      fprintf (outf, \"(\");\n+      write_test_expr (outf, XEXP (value, 0), 0, 0, false);\n+      fprintf (outf, \" ? \");\n+      write_attr_value (outf, attr, XEXP (value, 1));\n+      fprintf (outf, \" : \");\n+      write_attr_value (outf, attr, XEXP (value, 2));\n+      fprintf (outf, \")\");\n+      break;\n+\n     default:\n       gcc_unreachable ();\n     }"}]}