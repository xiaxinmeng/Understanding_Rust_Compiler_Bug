{"sha": "833366d6c90ddcb12ec0b7d63b6e57fd3b0f5793", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODMzMzY2ZDZjOTBkZGNiMTJlYzBiN2Q2M2I2ZTU3ZmQzYjBmNTc5Mw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-07-29T21:28:42Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-07-29T21:28:42Z"}, "message": "rtlanal.c (parms_set, [...]): Break out from...; handle multiple sets.\n\n\t* rtlanal.c (parms_set, find_first_parameter_load): Break out from...;\n\thandle multiple sets.\n\t* except.c (sjlj_mark_call_sites): .... here.\n\t* gcse.c (insert_insn_end_bb): Use find_first_parameter_load.\n\nFrom-SVN: r44465", "tree": {"sha": "3c01d1ea251b427b8df8b3e9d0756203c265d556", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3c01d1ea251b427b8df8b3e9d0756203c265d556"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/833366d6c90ddcb12ec0b7d63b6e57fd3b0f5793", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/833366d6c90ddcb12ec0b7d63b6e57fd3b0f5793", "html_url": "https://github.com/Rust-GCC/gccrs/commit/833366d6c90ddcb12ec0b7d63b6e57fd3b0f5793", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/833366d6c90ddcb12ec0b7d63b6e57fd3b0f5793/comments", "author": null, "committer": null, "parents": [{"sha": "b5832b43726d2d44b202c7a5669b3e97a2bc60c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5832b43726d2d44b202c7a5669b3e97a2bc60c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b5832b43726d2d44b202c7a5669b3e97a2bc60c2"}], "stats": {"total": 160, "additions": 84, "deletions": 76}, "files": [{"sha": "e332746b013e78e1605cfb7390fcb610a4ddfa74", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/833366d6c90ddcb12ec0b7d63b6e57fd3b0f5793/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/833366d6c90ddcb12ec0b7d63b6e57fd3b0f5793/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=833366d6c90ddcb12ec0b7d63b6e57fd3b0f5793", "patch": "@@ -1,3 +1,10 @@\n+Sun Jul 29 23:26:50 CEST 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* rtlanal.c (parms_set, find_first_parameter_load): Break out from...;\n+\thandle multiple sets.\n+\t* except.c (sjlj_mark_call_sites): .... here.\n+\t* gcse.c (insert_insn_end_bb): Use find_first_parameter_load.\n+\n Sun Jul 29 21:38:45 CEST 2001  Jan Hubicka  <jh@suse.cz>\n \n \tSuggested by Richard Henderson and Richard Kenner:"}, {"sha": "0ed89a00726e6e6072c38a168088f86264363566", "filename": "gcc/except.c", "status": "modified", "additions": 1, "deletions": 45, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/833366d6c90ddcb12ec0b7d63b6e57fd3b0f5793/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/833366d6c90ddcb12ec0b7d63b6e57fd3b0f5793/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=833366d6c90ddcb12ec0b7d63b6e57fd3b0f5793", "patch": "@@ -2083,51 +2083,7 @@ sjlj_mark_call_sites (lp_info)\n       /* Don't separate a call from it's argument loads.  */\n       before = insn;\n       if (GET_CODE (insn) == CALL_INSN)\n-\t{\n-\t  HARD_REG_SET parm_regs;\n-\t  int nparm_regs;\n-\t  \n-\t  /* Since different machines initialize their parameter registers\n-\t     in different orders, assume nothing.  Collect the set of all\n-\t     parameter registers.  */\n-\t  CLEAR_HARD_REG_SET (parm_regs);\n-\t  nparm_regs = 0;\n-\t  for (p = CALL_INSN_FUNCTION_USAGE (insn); p ; p = XEXP (p, 1))\n-\t    if (GET_CODE (XEXP (p, 0)) == USE\n-\t\t&& GET_CODE (XEXP (XEXP (p, 0), 0)) == REG)\n-\t      {\n-\t\tif (REGNO (XEXP (XEXP (p, 0), 0)) >= FIRST_PSEUDO_REGISTER)\n-\t\t  abort ();\n-\n-\t\t/* We only care about registers which can hold function\n-\t\t   arguments.  */\n-\t\tif (! FUNCTION_ARG_REGNO_P (REGNO (XEXP (XEXP (p, 0), 0))))\n-\t\t  continue;\n-\n-\t\tSET_HARD_REG_BIT (parm_regs, REGNO (XEXP (XEXP (p, 0), 0)));\n-\t\tnparm_regs++;\n-\t      }\n-\n-\t  /* Search backward for the first set of a register in this set.  */\n-\t  while (nparm_regs)\n-\t    {\n-\t      before = PREV_INSN (before);\n-\n-\t      /* Given that we've done no other optimizations yet,\n-\t\t the arguments should be immediately available.  */\n-\t      if (GET_CODE (before) == CODE_LABEL)\n-\t\tabort ();\n-\n-\t      p = single_set (before);\n-\t      if (p && GET_CODE (SET_DEST (p)) == REG\n-\t\t  && REGNO (SET_DEST (p)) < FIRST_PSEUDO_REGISTER\n-\t\t  && TEST_HARD_REG_BIT (parm_regs, REGNO (SET_DEST (p))))\n-\t\t{\n-\t\t  CLEAR_HARD_REG_BIT (parm_regs, REGNO (SET_DEST (p)));\n-\t\t  nparm_regs--;\n-\t\t}\n-\t    }\n-\t}\n+         before = find_first_parameter_load (insn, NULL_RTX);\n \n       start_sequence ();\n       emit_move_insn (mem, GEN_INT (this_call_site));"}, {"sha": "70ed27574cf20e86fbacc1496cae7f0093a46d0e", "filename": "gcc/gcse.c", "status": "modified", "additions": 1, "deletions": 31, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/833366d6c90ddcb12ec0b7d63b6e57fd3b0f5793/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/833366d6c90ddcb12ec0b7d63b6e57fd3b0f5793/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=833366d6c90ddcb12ec0b7d63b6e57fd3b0f5793", "patch": "@@ -4649,38 +4649,8 @@ insert_insn_end_bb (expr, bb, pre)\n       /* Since different machines initialize their parameter registers\n \t in different orders, assume nothing.  Collect the set of all\n \t parameter registers.  */\n-      CLEAR_HARD_REG_SET (parm_regs);\n-      nparm_regs = 0;\n-      for (p = CALL_INSN_FUNCTION_USAGE (insn); p ; p = XEXP (p, 1))\n-\tif (GET_CODE (XEXP (p, 0)) == USE\n-\t    && GET_CODE (XEXP (XEXP (p, 0), 0)) == REG)\n-\t  {\n-\t    if (REGNO (XEXP (XEXP (p, 0), 0)) >= FIRST_PSEUDO_REGISTER)\n-\t      abort ();\n-\n-\t    /* We only care about registers which can hold function\n-\t       arguments.  */\n-\t    if (! FUNCTION_ARG_REGNO_P (REGNO (XEXP (XEXP (p, 0), 0))))\n-\t      continue;\n-\n-\t    SET_HARD_REG_BIT (parm_regs, REGNO (XEXP (XEXP (p, 0), 0)));\n-\t    nparm_regs++;\n-\t  }\n+      insn = find_first_parameter_load (insn, bb->head);\n \n-      /* Search backward for the first set of a register in this set.  */\n-      while (nparm_regs && bb->head != insn)\n-\t{\n-\t  insn = PREV_INSN (insn);\n-\t  p = single_set (insn);\n-\t  if (p && GET_CODE (SET_DEST (p)) == REG\n-\t      && REGNO (SET_DEST (p)) < FIRST_PSEUDO_REGISTER\n-\t      && TEST_HARD_REG_BIT (parm_regs, REGNO (SET_DEST (p))))\n-\t    {\n-\t      CLEAR_HARD_REG_BIT (parm_regs, REGNO (SET_DEST (p)));\n-\t      nparm_regs--;\n-\t    }\n-\t}\n-      \n       /* If we found all the parameter loads, then we want to insert\n \t before the first parameter load.\n "}, {"sha": "3a97da305457edcd56dd09a2477776eb3c361b42", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/833366d6c90ddcb12ec0b7d63b6e57fd3b0f5793/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/833366d6c90ddcb12ec0b7d63b6e57fd3b0f5793/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=833366d6c90ddcb12ec0b7d63b6e57fd3b0f5793", "patch": "@@ -1432,6 +1432,7 @@ extern int auto_inc_p\t\t\tPARAMS ((rtx));\n extern void remove_node_from_expr_list\tPARAMS ((rtx, rtx *));\n extern int insns_safe_to_move_p         PARAMS ((rtx, rtx, rtx *));\n extern int loc_mentioned_in_p\t\tPARAMS ((rtx *, rtx));\n+extern rtx find_first_parameter_load\tPARAMS ((rtx, rtx));\n \n /* flow.c */\n "}, {"sha": "9762f9eaa55e4096988c9752f82b6b4ddf9c6380", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/833366d6c90ddcb12ec0b7d63b6e57fd3b0f5793/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/833366d6c90ddcb12ec0b7d63b6e57fd3b0f5793/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=833366d6c90ddcb12ec0b7d63b6e57fd3b0f5793", "patch": "@@ -31,6 +31,7 @@ static void set_of_1\t\tPARAMS ((rtx, rtx, void *));\n static void insn_dependent_p_1\tPARAMS ((rtx, rtx, void *));\n static int computed_jump_p_1\tPARAMS ((rtx));\n static int operand_preference\tPARAMS ((rtx));\n+static void parms_set \t\tPARAMS ((rtx, rtx, void *));\n \n /* Bit flags that specify the machine subtype we are compiling for.\n    Bits are tested using macros TARGET_... defined in the tm.h file\n@@ -2788,3 +2789,76 @@ subreg_regno (x)\n   return ret;\n \n }\n+struct parms_set_data\n+{\n+  int nregs;\n+  HARD_REG_SET regs;\n+};\n+\n+/* Helper function for noticing stores to parameter registers.  */\n+static void\n+parms_set (x, pat, data)\n+\trtx x, pat ATTRIBUTE_UNUSED;\n+\tvoid *data;\n+{\n+  struct parms_set_data *d = data;\n+  if (REG_P (x) && REGNO (x) < FIRST_PSEUDO_REGISTER\n+      && TEST_HARD_REG_BIT (d->regs, REGNO (x)))\n+    {\n+      CLEAR_HARD_REG_BIT (d->regs, REGNO (x));\n+      d->nregs--;\n+    }\n+}\n+\n+/* Look backward for first parameter to be loaded.  \n+   Do not skip BOUNDARY.  */\n+rtx\n+find_first_parameter_load (call_insn, boundary)\n+     rtx call_insn, boundary;\n+{\n+  struct parms_set_data parm;\n+  rtx p, before;\n+\n+  /* Since different machines initialize their parameter registers\n+     in different orders, assume nothing.  Collect the set of all\n+     parameter registers.  */\n+  CLEAR_HARD_REG_SET (parm.regs);\n+  parm.nregs = 0;\n+  for (p = CALL_INSN_FUNCTION_USAGE (call_insn); p; p = XEXP (p, 1))\n+    if (GET_CODE (XEXP (p, 0)) == USE\n+\t&& GET_CODE (XEXP (XEXP (p, 0), 0)) == REG)\n+      {\n+\tif (REGNO (XEXP (XEXP (p, 0), 0)) >= FIRST_PSEUDO_REGISTER)\n+\t  abort ();\n+\n+\t/* We only care about registers which can hold function\n+\t   arguments.  */\n+\tif (!FUNCTION_ARG_REGNO_P (REGNO (XEXP (XEXP (p, 0), 0))))\n+\t  continue;\n+\n+\tSET_HARD_REG_BIT (parm.regs, REGNO (XEXP (XEXP (p, 0), 0)));\n+\tparm.nregs++;\n+      }\n+  before = call_insn;\n+\n+  /* Search backward for the first set of a register in this set.  */\n+  while (parm.nregs && before != boundary)\n+    {\n+      before = PREV_INSN (before);\n+\n+      /* It is possible that some loads got CSEed from one call to\n+         another.  Stop in that case.  */\n+      if (GET_CODE (before) == CALL_INSN)\n+\tbreak;\n+\n+      /* Our caller needs eighter ensure, that we will find all sets\n+         (in case code has not been optimized yet), or take care\n+         for possible labels in a way by setting boundary to preceeding\n+         CODE_LABEL.  */\n+      if (GET_CODE (before) == CODE_LABEL && before != boundary)\n+\tabort ();\n+\n+      note_stores (PATTERN (before), parms_set, &parm);\n+    }\n+  return before;\n+}"}]}