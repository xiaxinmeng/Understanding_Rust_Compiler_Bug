{"sha": "68f61c3d955e3e9bb65200a27f5ea2136b7cedf7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjhmNjFjM2Q5NTVlM2U5YmI2NTIwMGEyN2Y1ZWEyMTM2YjdjZWRmNw==", "commit": {"author": {"name": "Sebastian Pop", "email": "sebastian.pop@amd.com", "date": "2009-01-08T14:14:41Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2009-01-08T14:14:41Z"}, "message": "re PR middle-end/38559 ([graphite] ICE :in build2_stat, at tree.c:3293)\n\n2009-01-07  Sebastian Pop  <sebastian.pop@amd.com>\n\t    Jan Sjodin  <jan.sjodin@amd.com>\n\n\tPR tree-optimization/38559\n\t* testsuite/gcc.dg/graphite/pr38559.c: New.\n\n\t* graphite.c (debug_value, copy_constraint,\n\tswap_constraint_variables, scale_constraint_variable, ): New.\n\t(get_lower_bound, get_upper_bound): Removed.\n\t(graphite_trans_bb_strip_mine): Clean up this code that works\n\tonly for constant number of iterations.  Fully copy upper and\n\tlower bound constraints, not only the constant part of them.\n\t* graphite.h (debug_value): Declared.\n\n\nCo-Authored-By: Jan Sjodin <jan.sjodin@amd.com>\n\nFrom-SVN: r143187", "tree": {"sha": "70c9ed9fc261dabb580d6a88b7247e979cef8458", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/70c9ed9fc261dabb580d6a88b7247e979cef8458"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/68f61c3d955e3e9bb65200a27f5ea2136b7cedf7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68f61c3d955e3e9bb65200a27f5ea2136b7cedf7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/68f61c3d955e3e9bb65200a27f5ea2136b7cedf7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68f61c3d955e3e9bb65200a27f5ea2136b7cedf7/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "82567e3386ed9d11a425f12d822ed1ee6b1c949b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82567e3386ed9d11a425f12d822ed1ee6b1c949b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/82567e3386ed9d11a425f12d822ed1ee6b1c949b"}], "stats": {"total": 230, "additions": 94, "deletions": 136}, "files": [{"sha": "a985b5047e786fb56c7d2ad459fe0314af6490c9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68f61c3d955e3e9bb65200a27f5ea2136b7cedf7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68f61c3d955e3e9bb65200a27f5ea2136b7cedf7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=68f61c3d955e3e9bb65200a27f5ea2136b7cedf7", "patch": "@@ -1,3 +1,15 @@\n+2009-01-08  Sebastian Pop  <sebastian.pop@amd.com>\n+\t    Jan Sjodin  <jan.sjodin@amd.com>\n+\n+\tPR tree-optimization/38559\n+\t* graphite.c (debug_value, copy_constraint,\n+\tswap_constraint_variables, scale_constraint_variable, ): New.\n+\t(get_lower_bound, get_upper_bound): Removed.\n+\t(graphite_trans_bb_strip_mine): Clean up this code that works\n+\tonly for constant number of iterations.  Fully copy upper and\n+\tlower bound constraints, not only the constant part of them.\n+\t* graphite.h (debug_value): Declared.\n+\n 2009-01-08  Ira Rosen  <irar@il.ibm.com>\n \n \tPR tree-optimization/37194"}, {"sha": "c90ba9609037b4376df1eb724e217207400a1fc8", "filename": "gcc/graphite.c", "status": "modified", "additions": 61, "deletions": 136, "changes": 197, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68f61c3d955e3e9bb65200a27f5ea2136b7cedf7/gcc%2Fgraphite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68f61c3d955e3e9bb65200a27f5ea2136b7cedf7/gcc%2Fgraphite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite.c?ref=68f61c3d955e3e9bb65200a27f5ea2136b7cedf7", "patch": "@@ -61,6 +61,14 @@ along with GCC; see the file COPYING3.  If not see\n \n static VEC (scop_p, heap) *current_scops;\n \n+/* Print GMP value V on stderr.  */\n+\n+void\n+debug_value (Value v)\n+{\n+  value_print (stderr, \"%4s\\n\", v);\n+}\n+\n /* Converts a GMP constant V to a tree and returns it.  */\n \n static tree\n@@ -5459,24 +5467,43 @@ get_upper_bound_row (CloogMatrix *domain, int column)\n   return get_first_matching_sign_row_index (domain, column, false);\n }\n \n-/* Get the lower bound of LOOP.  */\n+/* Copies the OLD_ROW constraint from OLD_DOMAIN to the NEW_DOMAIN at\n+   row NEW_ROW.  */\n \n static void\n-get_lower_bound (CloogMatrix *domain, int loop, Value lower_bound_result)\n+copy_constraint (CloogMatrix *old_domain, CloogMatrix *new_domain,\n+\t\t int old_row, int new_row)\n {\n-  int lower_bound_row = get_lower_bound_row (domain, loop);\n-  value_assign (lower_bound_result,\n-\t\tdomain->p[lower_bound_row][const_column_index(domain)]);\n+  int i;\n+\n+  gcc_assert (old_domain->NbColumns == new_domain->NbColumns\n+\t      && old_row < old_domain->NbRows\n+\t      && new_row < new_domain->NbRows);\n+\n+  for (i = 0; i < old_domain->NbColumns; i++)\n+    value_assign (new_domain->p[new_row][i], old_domain->p[old_row][i]);\n }\n \n-/* Get the upper bound of LOOP.  */\n+/* Swap coefficients of variables X and Y on row R.   */\n \n static void\n-get_upper_bound (CloogMatrix *domain, int loop, Value upper_bound_result)\n+swap_constraint_variables (CloogMatrix *domain,\n+\t\t\t   int r, int x, int y)\n {\n-  int upper_bound_row = get_upper_bound_row (domain, loop);\n-  value_assign (upper_bound_result,\n-\t\tdomain->p[upper_bound_row][const_column_index(domain)]);\n+  value_swap (domain->p[r][x], domain->p[r][y]);\n+}\n+\n+/* Scale by X the coefficient C of constraint at row R in DOMAIN.  */\n+\n+static void\n+scale_constraint_variable (CloogMatrix *domain,\n+\t\t\t   int r, int c, int x)\n+{\n+  Value strip_size_value;\n+  value_init (strip_size_value);\n+  value_set_si (strip_size_value, x);\n+  value_multiply (domain->p[r][c], domain->p[r][c], strip_size_value);\n+  value_clear (strip_size_value);\n }\n \n /* Strip mines the loop of BB at the position LOOP_DEPTH with STRIDE.\n@@ -5494,151 +5521,49 @@ graphite_trans_bb_strip_mine (graphite_bb_p gb, int loop_depth, int stride)\n   int col_loop_old = loop_depth + 2; \n   int col_loop_strip = col_loop_old - 1;\n \n-  Value old_lower_bound;\n-  Value old_upper_bound;\n-\n   gcc_assert (loop_depth <= gbb_nb_loops (gb) - 1);\n \n   VEC_safe_insert (loop_p, heap, GBB_LOOPS (gb), loop_depth, NULL);\n \n   GBB_DOMAIN (gb) = new_domain;\n \n-  /*\n-   nrows = 4, ncols = 4\n-  eq    i    j    c\n-   1    1    0    0 \n-   1   -1    0   99 \n-   1    0    1    0 \n-   1    0   -1   99 \n-  */\n- \n-  /* Move domain.  */\n   for (row = 0; row < domain->NbRows; row++)\n     for (col = 0; col < domain->NbColumns; col++)\n       if (col <= loop_depth)\n \tvalue_assign (new_domain->p[row][col], domain->p[row][col]);\n       else\n \tvalue_assign (new_domain->p[row][col + 1], domain->p[row][col]);\n \n-\n-  /*\n-    nrows = 6, ncols = 5\n-           outer inner\n-   eq   i   jj    j    c\n-   1    1    0    0    0 \n-   1   -1    0    0   99 \n-   1    0    0    1    0 \n-   1    0    0   -1   99 \n-   0    0    0    0    0 \n-   0    0    0    0    0 \n-   0    0    0    0    0 \n-   */\n-\n   row = domain->NbRows;\n \n-  /* Add outer loop.  */\n-  value_init (old_lower_bound);\n-  value_init (old_upper_bound);\n-  get_lower_bound (new_domain, col_loop_old, old_lower_bound);\n-  get_upper_bound (new_domain, col_loop_old, old_upper_bound);\n-\n-  /* Set Lower Bound */\n-  value_set_si (new_domain->p[row][0], 1);\n-  value_set_si (new_domain->p[row][col_loop_strip], 1);\n-  value_assign (new_domain->p[row][const_column_index (new_domain)],\n-\t\told_lower_bound);\n-  value_clear (old_lower_bound);\n+  /* Lower bound of the outer stripped loop.  */\n+  copy_constraint (new_domain, new_domain,\n+\t\t   get_lower_bound_row (new_domain, col_loop_old), row);\n+  swap_constraint_variables (new_domain, row, col_loop_old, col_loop_strip);\n   row++;\n \n+  /* Upper bound of the outer stripped loop.  */\n+  copy_constraint (new_domain, new_domain,\n+\t\t   get_upper_bound_row (new_domain, col_loop_old), row);\n+  swap_constraint_variables (new_domain, row, col_loop_old, col_loop_strip);\n+  scale_constraint_variable (new_domain, row, col_loop_strip, stride);\n+  row++;\n \n-  /*\n-    6 5\n-   eq   i   jj    j    c\n-   1    1    0    0    0 \n-   1   -1    0    0   99 \n-   1    0    0    1    0  - \n-   1    0    0   -1   99   | copy old lower bound\n-   1    0    1    0    0 <-\n-   0    0    0    0    0\n-   0    0    0    0    0\n-   */\n-\n-  {\n-    Value new_upper_bound;\n-    Value strip_size_value;\n-\n-    value_init (new_upper_bound);\n-    value_init (strip_size_value);\n-    value_set_si (strip_size_value, (int) stride);\n-\n-    value_pdivision (new_upper_bound, old_upper_bound, strip_size_value);\n-    value_add_int (new_upper_bound, new_upper_bound, 1);\n-\n-    /* Set Upper Bound */\n-    value_set_si (new_domain->p[row][0], 1);\n-    value_set_si (new_domain->p[row][col_loop_strip], -1);\n-    value_assign (new_domain->p[row][const_column_index (new_domain)],\n-\t\t  new_upper_bound);\n-\n-    value_clear (strip_size_value);\n-    value_clear (old_upper_bound);\n-    value_clear (new_upper_bound);\n-    row++;\n-  }\n-  /*\n-    6 5\n-   eq   i   jj    j    c\n-   1    1    0    0    0 \n-   1   -1    0    0   99 \n-   1    0    0    1    0  \n-   1    0    0   -1   99  \n-   1    0    1    0    0 \n-   1    0   -1    0   25  (divide old upper bound with stride) \n-   0    0    0    0    0\n-  */\n-\n-  {\n-    row = get_lower_bound_row (new_domain, col_loop_old);\n-    /* Add local variable to keep linear representation.  */\n-    value_set_si (new_domain->p[row][0], 1);\n-    value_set_si (new_domain->p[row][const_column_index (new_domain)],0);\n-    value_set_si (new_domain->p[row][col_loop_old], 1);\n-    value_set_si (new_domain->p[row][col_loop_strip], -1*((int)stride));\n-  }\n-\n-  /*\n-    6 5\n-   eq   i   jj    j    c\n-   1    1    0    0    0 \n-   1   -1    0    0   99 \n-   1    0    -1   1    0  \n-   1    0    0   -1   99  \n-   1    0    1    0    0 \n-   1    0   -1    0   25  (divide old upper bound with stride) \n-   0    0    0    0    0\n-  */\n-\n-  {\n-    row = new_domain->NbRows-1;\n-    \n-    value_set_si (new_domain->p[row][0], 1);\n-    value_set_si (new_domain->p[row][col_loop_old], -1);\n-    value_set_si (new_domain->p[row][col_loop_strip], stride);\n-    value_set_si (new_domain->p[row][const_column_index (new_domain)],\n-\t\t  stride-1);\n-  }\n+  /* Lower bound of a tile starts at \"stride * outer_iv\".  */\n+  row = get_lower_bound_row (new_domain, col_loop_old);\n+  value_set_si (new_domain->p[row][0], 1);\n+  value_set_si (new_domain->p[row][const_column_index (new_domain)], 0);\n+  value_set_si (new_domain->p[row][col_loop_old], 1);\n+  value_set_si (new_domain->p[row][col_loop_strip], -1 * stride);\n \n-  /*\n-    6 5\n-   eq   i   jj    j    c\n-   1    1    0    0    0     i >= 0\n-   1   -1    0    0   99    99 >= i\n-   1    0    -4   1    0     j >= 4*jj\n-   1    0    0   -1   99    99 >= j\n-   1    0    1    0    0    jj >= 0\n-   1    0   -1    0   25    25 >= jj\n-   0    0    4    -1   3  jj+3 >= j\n-  */\n+  /* Upper bound of a tile stops at \"stride * outer_iv + stride - 1\",\n+     or at the old upper bound that is not modified.  */\n+  row = new_domain->NbRows - 1;\n+  value_set_si (new_domain->p[row][0], 1);\n+  value_set_si (new_domain->p[row][col_loop_old], -1);\n+  value_set_si (new_domain->p[row][col_loop_strip], stride);\n+  value_set_si (new_domain->p[row][const_column_index (new_domain)],\n+\t\tstride - 1);\n \n   cloog_matrix_free (domain);\n "}, {"sha": "a1801966ed168852ab41f45c476959935866c778", "filename": "gcc/graphite.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68f61c3d955e3e9bb65200a27f5ea2136b7cedf7/gcc%2Fgraphite.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68f61c3d955e3e9bb65200a27f5ea2136b7cedf7/gcc%2Fgraphite.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite.h?ref=68f61c3d955e3e9bb65200a27f5ea2136b7cedf7", "patch": "@@ -381,6 +381,7 @@ extern void debug_rename_map (htab_t);\n extern void debug_ivtype_map (htab_t);\n extern void debug_loop_vec (graphite_bb_p);\n extern void debug_oldivs (scop_p);\n+extern void debug_value (Value);\n \n /* Describes the type of an iv stack entry.  */\n typedef enum {"}, {"sha": "c2558741502b77e7152a864f65fa62e8479b0284", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68f61c3d955e3e9bb65200a27f5ea2136b7cedf7/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68f61c3d955e3e9bb65200a27f5ea2136b7cedf7/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=68f61c3d955e3e9bb65200a27f5ea2136b7cedf7", "patch": "@@ -1,3 +1,9 @@\n+2009-01-08  Sebastian Pop  <sebastian.pop@amd.com>\n+\t    Jan Sjodin  <jan.sjodin@amd.com>\n+\n+\tPR tree-optimization/38559\n+\t* testsuite/gcc.dg/graphite/pr38559.c: New.\n+\n 2009-01-08  Ira Rosen  <irar@il.ibm.com>\n \n \tPR tree-optimization/37194"}, {"sha": "1e2ef0a4ff34f6a1f7e04300ce808a788e8225b9", "filename": "gcc/testsuite/gcc.dg/graphite/pr38559.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68f61c3d955e3e9bb65200a27f5ea2136b7cedf7/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr38559.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68f61c3d955e3e9bb65200a27f5ea2136b7cedf7/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr38559.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr38559.c?ref=68f61c3d955e3e9bb65200a27f5ea2136b7cedf7", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-options \"-O2 -floop-block\" } */\n+\n+int test()\n+{\n+  int offset, len;\n+  register char *mid;\n+  register char *midend;\n+  register char *bigend;\n+  long unsigned int curlen;\n+  if (offset + len > curlen) {\n+    while (midend > mid)\n+      *--bigend = *--midend;\n+  }\n+}"}]}