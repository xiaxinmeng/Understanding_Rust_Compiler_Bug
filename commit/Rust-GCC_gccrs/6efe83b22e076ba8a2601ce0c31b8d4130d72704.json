{"sha": "6efe83b22e076ba8a2601ce0c31b8d4130d72704", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmVmZTgzYjIyZTA3NmJhOGEyNjAxY2UwYzMxYjhkNDEzMGQ3MjcwNA==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2013-11-15T21:11:50Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2013-11-15T21:11:50Z"}, "message": "basic-block.h (has_abnormal_or_eh_outgoing_edge): Renamed from has_abnormal_or_outgoing_edge.\n\n\t* basic-block.h (has_abnormal_or_eh_outgoing_edge): Renamed from\n\thas_abnormal_or_outgoing_edge.  Check for EH edges as well.\n\t* gimple-ssa-isolate-paths.c\n\t(find_implicit_erroneous_behaviour): Corresponding changes.\n\tDo not check stmt_ends_bb_p or GIMPLE_RETURN anymore.\n\t(find_explicit_erroneous_behaviour): Likewise.\n\nFrom-SVN: r204861", "tree": {"sha": "94fdd0bc7bfd3fe5085e85d1819ed803b207fc53", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/94fdd0bc7bfd3fe5085e85d1819ed803b207fc53"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6efe83b22e076ba8a2601ce0c31b8d4130d72704", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6efe83b22e076ba8a2601ce0c31b8d4130d72704", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6efe83b22e076ba8a2601ce0c31b8d4130d72704", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6efe83b22e076ba8a2601ce0c31b8d4130d72704/comments", "author": null, "committer": null, "parents": [{"sha": "f0d3309e9b5700f73d88c01193eb701a2f4ef985", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0d3309e9b5700f73d88c01193eb701a2f4ef985", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f0d3309e9b5700f73d88c01193eb701a2f4ef985"}], "stats": {"total": 31, "additions": 16, "deletions": 15}, "files": [{"sha": "3d528ba7e44fc8102b543771a80576522f59533e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6efe83b22e076ba8a2601ce0c31b8d4130d72704/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6efe83b22e076ba8a2601ce0c31b8d4130d72704/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6efe83b22e076ba8a2601ce0c31b8d4130d72704", "patch": "@@ -1,3 +1,12 @@\n+2013-11-15  Jeff Law  <law@redhat.com>\n+\n+\t* basic-block.h (has_abnormal_or_eh_outgoing_edge): Renamed from\n+\thas_abnormal_or_outgoing_edge.  Check for EH edges as well.\n+\t* gimple-ssa-isolate-paths.c\n+\t(find_implicit_erroneous_behaviour): Corresponding changes.\n+\tDo not check stmt_ends_bb_p or GIMPLE_RETURN anymore.\n+\t(find_explicit_erroneous_behaviour): Likewise.\n+\n 2013-11-15  Jeff Law  <law@redhat.com>\n \n \t* ifcvt.c (find_cond_trap): Properly handle case where"}, {"sha": "fd1681209fbbaf3fc449f617443c4c30c65372bc", "filename": "gcc/basic-block.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6efe83b22e076ba8a2601ce0c31b8d4130d72704/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6efe83b22e076ba8a2601ce0c31b8d4130d72704/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=6efe83b22e076ba8a2601ce0c31b8d4130d72704", "patch": "@@ -1012,13 +1012,13 @@ inverse_probability (int prob1)\n /* Return true if BB has at least one abnormal outgoing edge.  */\n \n static inline bool\n-has_abnormal_outgoing_edge_p (basic_block bb)\n+has_abnormal_or_eh_outgoing_edge_p (basic_block bb)\n {\n   edge e;\n   edge_iterator ei;\n \n   FOR_EACH_EDGE (e, ei, bb->succs)\n-    if (e->flags & EDGE_ABNORMAL)\n+    if (e->flags & (EDGE_ABNORMAL | EDGE_EH))\n       return true;\n \n   return false;"}, {"sha": "c42f112da8b3886c4658c08948d3cc0ce5927855", "filename": "gcc/gimple-ssa-isolate-paths.c", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6efe83b22e076ba8a2601ce0c31b8d4130d72704/gcc%2Fgimple-ssa-isolate-paths.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6efe83b22e076ba8a2601ce0c31b8d4130d72704/gcc%2Fgimple-ssa-isolate-paths.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-isolate-paths.c?ref=6efe83b22e076ba8a2601ce0c31b8d4130d72704", "patch": "@@ -224,7 +224,7 @@ find_implicit_erroneous_behaviour (void)\n \t the trap we insert.  We have to preserve abnormal edges out\n \t of the isolated block which in turn means updating PHIs at\n \t the targets of those abnormal outgoing edges.  */\n-      if (has_abnormal_outgoing_edge_p (bb))\n+      if (has_abnormal_or_eh_outgoing_edge_p (bb))\n \tcontinue;\n \n       /* First look for a PHI which sets a pointer to NULL and which\n@@ -268,15 +268,8 @@ find_implicit_erroneous_behaviour (void)\n \t        {\n \t          /* We only care about uses in BB.  Catching cases in\n \t\t     in other blocks would require more complex path\n-\t\t     isolation code. \n-\n-\t\t     If the statement must end a block and is not a\n-\t\t     GIMPLE_RETURN, then additional work would be\n-\t\t     necessary to isolate the path.  Just punt it for\n-\t\t     now.  */\n-\t\t  if (gimple_bb (use_stmt) != bb\n-\t\t      || (stmt_ends_bb_p (use_stmt)\n-\t\t\t  && gimple_code (use_stmt) != GIMPLE_RETURN))\n+\t\t     isolation code.   */\n+\t\t  if (gimple_bb (use_stmt) != bb)\n \t\t    continue;\n \n \t\t  if (infer_nonnull_range (use_stmt, lhs))\n@@ -316,7 +309,7 @@ find_explicit_erroneous_behaviour (void)\n \t the trap we insert.  We have to preserve abnormal edges out\n \t of the isolated block which in turn means updating PHIs at\n \t the targets of those abnormal outgoing edges.  */\n-      if (has_abnormal_outgoing_edge_p (bb))\n+      if (has_abnormal_or_eh_outgoing_edge_p (bb))\n \tcontinue;\n \n       /* Now look at the statements in the block and see if any of\n@@ -329,8 +322,7 @@ find_explicit_erroneous_behaviour (void)\n \t  /* By passing null_pointer_node, we can use infer_nonnull_range\n \t     to detect explicit NULL pointer dereferences and other uses\n \t     where a non-NULL value is required.  */\n-\t  if ((!stmt_ends_bb_p (stmt) || gimple_code (stmt) == GIMPLE_RETURN)\n-\t      && infer_nonnull_range (stmt, null_pointer_node))\n+\t  if (infer_nonnull_range (stmt, null_pointer_node))\n \t    {\n \t      insert_trap_and_remove_trailing_statements (&si,\n \t\t\t\t\t\t\t  null_pointer_node);"}]}