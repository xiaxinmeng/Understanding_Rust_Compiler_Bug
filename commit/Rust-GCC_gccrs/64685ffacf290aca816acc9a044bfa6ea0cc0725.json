{"sha": "64685ffacf290aca816acc9a044bfa6ea0cc0725", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjQ2ODVmZmFjZjI5MGFjYTgxNmFjYzlhMDQ0YmZhNmVhMGNjMDcyNQ==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-05-02T04:47:17Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-05-02T04:47:17Z"}, "message": "Deleted casts to void.\n\n(emdnorm, eifrac, euifrac, mtherr): Replace\nunconditional `pedwarn' by `warning' conditional on `extra_warnings'.\n(toe24, todec): Use ERANGE to flag overflow on (non-IEEE)\nmachines that do not have infinity.\n(etoasc): Check explicitly for overflow of leading decimal digit.\n(asctoeg): Test for, and immediately reject, out-of-bounds\ndecimal exponent inputs.\n(at top level): Include errno.h; reference errno, warning, extra_warnings.\n\nFrom-SVN: r4300", "tree": {"sha": "bcb406f4716372aafcd6510ff43458cc827ff48f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bcb406f4716372aafcd6510ff43458cc827ff48f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/64685ffacf290aca816acc9a044bfa6ea0cc0725", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64685ffacf290aca816acc9a044bfa6ea0cc0725", "html_url": "https://github.com/Rust-GCC/gccrs/commit/64685ffacf290aca816acc9a044bfa6ea0cc0725", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64685ffacf290aca816acc9a044bfa6ea0cc0725/comments", "author": null, "committer": null, "parents": [{"sha": "0a05e9c9a63c0b14f9b341711e2992849d9b0716", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a05e9c9a63c0b14f9b341711e2992849d9b0716", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a05e9c9a63c0b14f9b341711e2992849d9b0716"}], "stats": {"total": 98, "additions": 73, "deletions": 25}, "files": [{"sha": "29cc9f9e8059743ff20dbbf13a6c9d724e85227f", "filename": "gcc/real.c", "status": "modified", "additions": 73, "deletions": 25, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64685ffacf290aca816acc9a044bfa6ea0cc0725/gcc%2Freal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64685ffacf290aca816acc9a044bfa6ea0cc0725/gcc%2Freal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.c?ref=64685ffacf290aca816acc9a044bfa6ea0cc0725", "patch": "@@ -21,10 +21,14 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n \n #include <stdio.h>\n+#include <errno.h>\n #include \"config.h\"\n-\n #include \"tree.h\"\n \n+#ifndef errno\n+extern int errno;\n+#endif\n+\n /* To enable support of XFmode extended real floating point, define\n LONG_DOUBLE_TYPE_SIZE 96 in the tm.h file (m68k.h or i386.h).\n \n@@ -249,7 +253,8 @@ do { EMUSHORT w[4];\t\t\\\n #endif /* not REAL_ARITHMETIC */\n #endif /* no XFmode */\n \n-void pedwarn ();\n+void warning ();\n+extern int extra_warnings;\n int ecmp (), enormlz (), eshift (), eisneg (), eisinf ();\n void eadd (), esub (), emul (), ediv ();\n void eshup1 (), eshup8 (), eshup6 (), eshdn1 (), eshdn8 (), eshdn6 ();\n@@ -1935,7 +1940,8 @@ emdnorm (s, lost, subflg, exp, rcntrl)\n       s[1] = 32767;\n       for (i = 2; i < NI - 1; i++)\n \ts[i] = 0;\n-      pedwarn (\"floating point overflow\");\n+      if (extra_warnings)\n+\twarning (\"floating point overflow\");\n #else\n       s[1] = 32766;\n       s[2] = 0;\n@@ -2321,7 +2327,7 @@ e53toe (e, y)\n   *p++ = *e++;\n   *p++ = *e++;\n #endif\n-  (void) eshift (yy, -5);\n+  eshift (yy, -5);\n   if (denorm)\n     {\t\t\t\t/* if zero exponent, then normalize the significand */\n       if ((k = enormlz (yy)) > NBITS)\n@@ -2434,7 +2440,7 @@ e24toe (e, y)\n   ++e;\n   *p++ = *e++;\n #endif\n-  (void) eshift (yy, -8);\n+  eshift (yy, -8);\n   if (denorm)\n     {\t\t\t\t/* if zero exponent, then normalize the significand */\n       if ((k = enormlz (yy)) > NBITS)\n@@ -2616,12 +2622,12 @@ toe53 (x, y)\n     }\n   if (i == 0)\n     {\n-      (void) eshift (x, 4);\n+      eshift (x, 4);\n     }\n   else\n     {\n       i <<= 4;\n-      (void) eshift (x, 5);\n+      eshift (x, 5);\n     }\n   i |= *p++ & (unsigned EMUSHORT) 0x0f;\t/* *p = xi[M] */\n   *y |= (unsigned EMUSHORT) i;\t/* high order output already has sign bit set */\n@@ -2691,8 +2697,9 @@ toe24 (x, y)\n     *y = 0x8000;\t\t/* output sign bit */\n \n   i = *p++;\n+/* Handle overflow cases. */\n   if (i >= 255)\n-    {\t\t\t\t/* Saturate at largest number less than infinity. */\n+    {\n #ifdef INFINITY\n       *y |= (unsigned EMUSHORT) 0x7f80;\n #ifdef IBMPC\n@@ -2705,7 +2712,7 @@ toe24 (x, y)\n       ++y;\n       *y = 0;\n #endif\n-#else\n+#else  /* no INFINITY */\n       *y |= (unsigned EMUSHORT) 0x7f7f;\n #ifdef IBMPC\n       *(--y) = 0xffff;\n@@ -2717,17 +2724,20 @@ toe24 (x, y)\n       ++y;\n       *y = 0xffff;\n #endif\n+#ifdef ERANGE\n+      errno = ERANGE;\n #endif\n+#endif  /* no INFINITY */\n       return;\n     }\n   if (i == 0)\n     {\n-      (void) eshift (x, 7);\n+      eshift (x, 7);\n     }\n   else\n     {\n       i <<= 7;\n-      (void) eshift (x, 8);\n+      eshift (x, 8);\n     }\n   i |= *p++ & (unsigned EMUSHORT) 0x7f;\t/* *p = xi[M] */\n   *y |= i;\t\t\t/* high order output already has sign bit set */\n@@ -2941,8 +2951,9 @@ eifrac (x, i, frac)\n \t*i = ((unsigned long) 1) << (HOST_BITS_PER_LONG - 1);\n       else\n \t*i = (((unsigned long) 1) << (HOST_BITS_PER_LONG - 1)) - 1;\n-      (void) eshift (xi, k);\n-      pedwarn (\"Overflow on truncation to integer\");\n+      eshift (xi, k);\n+      if (extra_warnings)\n+\twarning (\"overflow on truncation to integer\");\n       goto lab11;\n     }\n \n@@ -2953,15 +2964,15 @@ eifrac (x, i, frac)\n \t ; then complete the shift to get the fraction.\n \t */\n       k -= 16;\n-      (void) eshift (xi, k);\n+      eshift (xi, k);\n \n       *i = (long) (((unsigned long) xi[M] << 16) | xi[M + 1]);\n       eshup6 (xi);\n       goto lab10;\n     }\n \n   /* shift not more than 16 bits */\n-  (void) eshift (xi, k);\n+  eshift (xi, k);\n   *i = (long) xi[M] & 0xffff;\n \n  lab10:\n@@ -3017,8 +3028,9 @@ euifrac (x, i, frac)\n \t ;\tand correct fraction\n \t */\n       *i = ~(0L);\n-      (void) eshift (xi, k);\n-      pedwarn (\"Overflow on truncation to unsigned integer\");\n+      eshift (xi, k);\n+      if (extra_warnings)\n+\twarning (\"overflow on truncation to unsigned integer\");\n       goto lab10;\n     }\n \n@@ -3029,15 +3041,15 @@ euifrac (x, i, frac)\n \t ; then complete the shift to get the fraction.\n \t */\n       k -= 16;\n-      (void) eshift (xi, k);\n+      eshift (xi, k);\n \n       *i = (long) (((unsigned long) xi[M] << 16) | xi[M + 1]);\n       eshup6 (xi);\n       goto lab10;\n     }\n \n   /* shift not more than 16 bits */\n-  (void) eshift (xi, k);\n+  eshift (xi, k);\n   *i = (long) xi[M] & 0xffff;\n \n  lab10:\n@@ -3540,13 +3552,27 @@ etoasc (x, string, ndigs)\n     *s++ = '-';\n   else\n     *s++ = ' ';\n-  *s++ = (char) digit + '0';\n-  *s++ = '.';\n   /* Examine number of digits requested by caller. */\n   if (ndigs < 0)\n     ndigs = 0;\n   if (ndigs > NDEC)\n     ndigs = NDEC;\n+  if (digit == 10)\n+    {\n+      *s++ = '1';\n+      *s++ = '.';\n+      if (ndigs > 0)\n+\t{\n+\t  *s++ = '0';\n+\t  ndigs -= 1;\n+\t}\n+      expon += 1;\n+    }\n+  else\n+    {\n+      *s++ = (char )digit + '0';\n+      *s++ = '.';\n+    }\n   /* Generate digits after the decimal point. */\n   for (k = 0; k <= ndigs; k++)\n     {\n@@ -3809,9 +3835,7 @@ asctoeg (ss, y, oprec)\n       goto daldone;\n     case 'i':\n     case 'I':\n-      ecleaz (yy);\n-      yy[E] = 0x7fff;\t\t/* infinity */\n-      goto aexit;\n+      goto infinite;\n     default:\n     error:\n       mtherr (\"asctoe\", DOMAIN);\n@@ -3840,9 +3864,29 @@ asctoeg (ss, y, oprec)\n     {\n       exp *= 10;\n       exp += *s++ - '0';\n+      if (exp > 4956)\n+\t{\n+\t  if (esign < 0)\n+\t    goto zero;\n+\t  else\n+\t    goto infinite;\n+\t}\n     }\n   if (esign < 0)\n     exp = -exp;\n+  if (exp > 4932)\n+    {\n+ infinite:\n+      ecleaz (yy);\n+      yy[E] = 0x7fff;\t\t/* infinity */\n+      goto aexit;\n+    }\n+  if (exp < -4956)\n+    {\n+ zero:\n+      ecleaz (yy);\n+      goto aexit;\n+    }\n \n  daldone:\n   nexp = exp - nexp;\n@@ -4247,7 +4291,8 @@ mtherr (name, code)\n   if ((code <= 0) || (code >= 6))\n     code = 0;\n   sprintf (errstr, \"\\n%s %s error\\n\", name, ermsg[code]);\n-  pedwarn (errstr);\n+  if (extra_warnings)\n+    warning (errstr);\n   /* Set global error message word */\n   merror = code + 1;\n \n@@ -4429,6 +4474,9 @@ todec (x, y)\n       *y++ = 0xffff;\n       *y++ = 0xffff;\n       *y++ = 0xffff;\n+#ifdef ERANGE\n+      errno = ERANGE;\n+#endif\n       return;\n     }\n   i &= 0377;"}]}