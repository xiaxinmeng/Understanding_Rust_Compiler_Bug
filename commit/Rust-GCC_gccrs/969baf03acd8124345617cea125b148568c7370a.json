{"sha": "969baf03acd8124345617cea125b148568c7370a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTY5YmFmMDNhY2Q4MTI0MzQ1NjE3Y2VhMTI1YjE0ODU2OGM3MzcwYQ==", "commit": {"author": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2020-09-24T18:30:50Z"}, "committer": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2020-09-29T23:03:04Z"}, "message": "c++: Implement -Wrange-loop-construct [PR94695]\n\nThis new warning can be used to prevent expensive copies inside range-based\nfor-loops, for instance:\n\n  struct S { char arr[128]; };\n  void fn () {\n    S arr[5];\n    for (const auto x : arr) {  }\n  }\n\nwhere auto deduces to S and then we copy the big S in every iteration.\nUsing \"const auto &x\" would not incur such a copy.  With this patch the\ncompiler will warn:\n\nq.C:4:19: warning: loop variable 'x' creates a copy from type 'const S' [-Wrange-loop-construct]\n    4 |   for (const auto x : arr) {  }\n      |                   ^\nq.C:4:19: note: use reference type 'const S&' to prevent copying\n    4 |   for (const auto x : arr) {  }\n      |                   ^\n      |                   &\n\nAs per Clang, this warning is suppressed for trivially copyable types\nwhose size does not exceed 64B.  The tricky part of the patch was how\nto figure out if using a reference would have prevented a copy.  To\nthat point, I'm using the new function called ref_conv_binds_directly_p.\n\nThis warning is enabled by -Wall.  Further warnings of similar nature\nshould follow soon.\n\ngcc/c-family/ChangeLog:\n\n\tPR c++/94695\n\t* c.opt (Wrange-loop-construct): New option.\n\ngcc/cp/ChangeLog:\n\n\tPR c++/94695\n\t* call.c (ref_conv_binds_directly_p): New function.\n\t* cp-tree.h (ref_conv_binds_directly_p): Declare.\n\t* parser.c (warn_for_range_copy): New function.\n\t(cp_convert_range_for): Call it.\n\ngcc/ChangeLog:\n\n\tPR c++/94695\n\t* doc/invoke.texi: Document -Wrange-loop-construct.\n\ngcc/testsuite/ChangeLog:\n\n\tPR c++/94695\n\t* g++.dg/warn/Wrange-loop-construct.C: New test.", "tree": {"sha": "0188d91dea5c97f873a1f94023f86f91449ec3a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0188d91dea5c97f873a1f94023f86f91449ec3a9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/969baf03acd8124345617cea125b148568c7370a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/969baf03acd8124345617cea125b148568c7370a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/969baf03acd8124345617cea125b148568c7370a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/969baf03acd8124345617cea125b148568c7370a/comments", "author": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "01852cc865c9c53fa3ba6627c1b7abd2446f48c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01852cc865c9c53fa3ba6627c1b7abd2446f48c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/01852cc865c9c53fa3ba6627c1b7abd2446f48c1"}], "stats": {"total": 323, "additions": 318, "deletions": 5}, "files": [{"sha": "bbf7da896583450fd8c45899350cba4078df3468", "filename": "gcc/c-family/c.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/969baf03acd8124345617cea125b148568c7370a/gcc%2Fc-family%2Fc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/969baf03acd8124345617cea125b148568c7370a/gcc%2Fc-family%2Fc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc.opt?ref=969baf03acd8124345617cea125b148568c7370a", "patch": "@@ -800,6 +800,10 @@ Wpacked-not-aligned\n C ObjC C++ ObjC++ Var(warn_packed_not_aligned) Warning LangEnabledBy(C ObjC C++ ObjC++,Wall)\n Warn when fields in a struct with the packed attribute are misaligned.\n \n+Wrange-loop-construct\n+C++ ObjC++ Var(warn_range_loop_construct) Warning LangEnabledBy(C++ ObjC++,Wall)\n+Warn when a range-based for-loop is creating unnecessary copies.\n+\n Wredundant-tags\n C++ ObjC++ Var(warn_redundant_tags) Warning\n Warn when a class or enumerated type is referenced using a redundant class-key."}, {"sha": "1e5fffe20ae09e16535081f082fe747b208c548b", "filename": "gcc/cp/call.c", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/969baf03acd8124345617cea125b148568c7370a/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/969baf03acd8124345617cea125b148568c7370a/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=969baf03acd8124345617cea125b148568c7370a", "patch": "@@ -8429,6 +8429,28 @@ conv_binds_ref_to_prvalue (conversion *c)\n   return false;\n }\n \n+/* True iff converting EXPR to a reference type TYPE does not involve\n+   creating a temporary.  */\n+\n+bool\n+ref_conv_binds_directly_p (tree type, tree expr)\n+{\n+  gcc_assert (TYPE_REF_P (type));\n+\n+  /* Get the high-water mark for the CONVERSION_OBSTACK.  */\n+  void *p = conversion_obstack_alloc (0);\n+\n+  conversion *conv = implicit_conversion (type, TREE_TYPE (expr), expr,\n+\t\t\t\t\t  /*c_cast_p=*/false,\n+\t\t\t\t\t  LOOKUP_IMPLICIT, tf_none);\n+  bool ret = conv && !conv->bad_p && !conv_binds_ref_to_prvalue (conv);\n+\n+  /* Free all the conversions we allocated.  */\n+  obstack_free (&conversion_obstack, p);\n+\n+  return ret;\n+}\n+\n /* Call the trivial destructor for INSTANCE, which can be either an lvalue of\n    class type or a pointer to class type.  If NO_PTR_DEREF is true and\n    INSTANCE has pointer type, clobber the pointer rather than what it points"}, {"sha": "42d0d76bf2181fc296163636a6b98e0fdabc6fd5", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/969baf03acd8124345617cea125b148568c7370a/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/969baf03acd8124345617cea125b148568c7370a/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=969baf03acd8124345617cea125b148568c7370a", "patch": "@@ -6225,6 +6225,7 @@ extern bool sufficient_parms_p\t\t\t(const_tree);\n extern tree type_decays_to\t\t\t(tree);\n extern tree extract_call_expr\t\t\t(tree);\n extern tree build_trivial_dtor_call\t\t(tree, bool = false);\n+extern bool ref_conv_binds_directly_p\t\t(tree, tree);\n extern tree build_user_type_conversion\t\t(tree, tree, int,\n \t\t\t\t\t\t tsubst_flags_t);\n extern tree build_new_function_call\t\t(tree, vec<tree, va_gc> **,"}, {"sha": "cb4422764eda3b58a6b993f4f4e444443fde3211", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 64, "deletions": 4, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/969baf03acd8124345617cea125b148568c7370a/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/969baf03acd8124345617cea125b148568c7370a/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=969baf03acd8124345617cea125b148568c7370a", "patch": "@@ -12646,6 +12646,64 @@ do_range_for_auto_deduction (tree decl, tree range_expr)\n     }\n }\n \n+/* Warns when the loop variable should be changed to a reference type to\n+   avoid unnecessary copying.  I.e., from\n+\n+     for (const auto x : range)\n+\n+   where range returns a reference, to\n+\n+     for (const auto &x : range)\n+\n+   if this version doesn't make a copy.  DECL is the RANGE_DECL; EXPR is the\n+   *__for_begin expression.\n+   This function is never called when processing_template_decl is on.  */\n+\n+static void\n+warn_for_range_copy (tree decl, tree expr)\n+{\n+  if (!warn_range_loop_construct\n+      || decl == error_mark_node)\n+    return;\n+\n+  location_t loc = DECL_SOURCE_LOCATION (decl);\n+  tree type = TREE_TYPE (decl);\n+\n+  if (from_macro_expansion_at (loc))\n+    return;\n+\n+  if (TYPE_REF_P (type))\n+    {\n+      /* TODO: Implement reference warnings.  */\n+      return;\n+    }\n+  else if (!CP_TYPE_CONST_P (type))\n+    return;\n+\n+  /* Since small trivially copyable types are cheap to copy, we suppress the\n+     warning for them.  64B is a common size of a cache line.  */\n+  if (TREE_CODE (TYPE_SIZE_UNIT (type)) != INTEGER_CST\n+      || (tree_to_uhwi (TYPE_SIZE_UNIT (type)) <= 64\n+\t  && trivially_copyable_p (type)))\n+    return;\n+\n+  tree rtype = cp_build_reference_type (type, /*rval*/false);\n+  /* If we could initialize the reference directly, it wouldn't involve any\n+     copies.  */\n+  if (!ref_conv_binds_directly_p (rtype, expr))\n+    return;\n+\n+  auto_diagnostic_group d;\n+  if (warning_at (loc, OPT_Wrange_loop_construct,\n+\t\t  \"loop variable %qD creates a copy from type %qT\",\n+\t\t  decl, type))\n+    {\n+      gcc_rich_location richloc (loc);\n+      richloc.add_fixit_insert_before (\"&\");\n+      inform (&richloc, \"use reference type to prevent copying\");\n+    }\n+}\n+\n /* Converts a range-based for-statement into a normal\n    for-statement, as per the definition.\n \n@@ -12656,7 +12714,7 @@ do_range_for_auto_deduction (tree decl, tree range_expr)\n \n       {\n \tauto &&__range = RANGE_EXPR;\n-\tfor (auto __begin = BEGIN_EXPR, end = END_EXPR;\n+\tfor (auto __begin = BEGIN_EXPR, __end = END_EXPR;\n \t      __begin != __end;\n \t      ++__begin)\n \t  {\n@@ -12756,14 +12814,16 @@ cp_convert_range_for (tree statement, tree range_decl, tree range_expr,\n     cp_maybe_mangle_decomp (range_decl, decomp_first_name, decomp_cnt);\n \n   /* The declaration is initialized with *__begin inside the loop body.  */\n-  cp_finish_decl (range_decl,\n-\t\t  build_x_indirect_ref (input_location, begin, RO_UNARY_STAR,\n-\t\t\t\t\ttf_warning_or_error),\n+  tree deref_begin = build_x_indirect_ref (input_location, begin, RO_UNARY_STAR,\n+\t\t\t\t\t   tf_warning_or_error);\n+  cp_finish_decl (range_decl, deref_begin,\n \t\t  /*is_constant_init*/false, NULL_TREE,\n \t\t  LOOKUP_ONLYCONVERTING);\n   if (VAR_P (range_decl) && DECL_DECOMPOSITION_P (range_decl))\n     cp_finish_decomp (range_decl, decomp_first_name, decomp_cnt);\n \n+  warn_for_range_copy (range_decl, deref_begin);\n+\n   return statement;\n }\n "}, {"sha": "9a4903306d03b92932bf2d19404a75f7330cbefa", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/969baf03acd8124345617cea125b148568c7370a/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/969baf03acd8124345617cea125b148568c7370a/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=969baf03acd8124345617cea125b148568c7370a", "patch": "@@ -245,7 +245,7 @@ in the following sections.\n -Wmultiple-inheritance  -Wnamespaces  -Wnarrowing @gol\n -Wnoexcept  -Wnoexcept-type  -Wnon-virtual-dtor @gol\n -Wpessimizing-move  -Wno-placement-new  -Wplacement-new=@var{n} @gol\n--Wredundant-move -Wredundant-tags @gol\n+-Wrange-loop-construct -Wredundant-move -Wredundant-tags @gol\n -Wreorder  -Wregister @gol\n -Wstrict-null-sentinel  -Wno-subobject-linkage  -Wtemplates @gol\n -Wno-non-template-friend  -Wold-style-cast @gol\n@@ -3605,6 +3605,24 @@ treats the return value as if it were designated by an rvalue.\n \n This warning is enabled by @option{-Wextra}.\n \n+@item -Wrange-loop-construct @r{(C++ and Objective-C++ only)}\n+@opindex Wrange-loop-construct\n+@opindex Wno-range-loop-construct\n+This warning warns when a C++ range-based for-loop is creating an unnecessary\n+copy.  This can happen when the range declaration is not a reference, but\n+probably should be.  For example:\n+\n+@smallexample\n+struct S @{ char arr[128]; @};\n+void fn () @{\n+  S arr[5];\n+  for (const auto x : arr) @{ @dots{} @}\n+@}\n+@end smallexample\n+\n+It does not warn when the type being copied is a trivially-copyable type whose\n+size is less than 64 bytes.  This warning is enabled by @option{-Wall}.\n+\n @item -Wredundant-tags @r{(C++ and Objective-C++ only)}\n @opindex Wredundant-tags\n @opindex Wno-redundant-tags\n@@ -5274,6 +5292,7 @@ Options} and @ref{Objective-C and Objective-C++ Dialect Options}.\n -Wparentheses  @gol\n -Wpessimizing-move @r{(only for C++)}  @gol\n -Wpointer-sign  @gol\n+-Wrange-loop-construct @r{(only for C++)}  @gol\n -Wreorder   @gol\n -Wrestrict   @gol\n -Wreturn-type  @gol"}, {"sha": "3caf00d412ff169b41b6754600c53249bd1d2ae7", "filename": "gcc/testsuite/g++.dg/warn/Wrange-loop-construct.C", "status": "added", "additions": 207, "deletions": 0, "changes": 207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/969baf03acd8124345617cea125b148568c7370a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWrange-loop-construct.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/969baf03acd8124345617cea125b148568c7370a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWrange-loop-construct.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWrange-loop-construct.C?ref=969baf03acd8124345617cea125b148568c7370a", "patch": "@@ -0,0 +1,207 @@\n+// PR c++/94695\n+// { dg-do compile { target c++11 } }\n+// { dg-options \"-Wrange-loop-construct\" }\n+\n+#include <initializer_list>\n+\n+struct Small {\n+  char arr[64];\n+};\n+\n+struct Big_aggr {\n+  char arr[65];\n+};\n+\n+struct Big_triv_copy {\n+  char arr[65];\n+  Big_triv_copy() { }\n+};\n+\n+struct Big {\n+  char arr[65];\n+  Big () = default;\n+  Big(const Big&);\n+};\n+\n+struct Foo { };\n+struct Bar {\n+  char arr[100];\n+  Bar(Foo);\n+  Bar(int);\n+  operator int();\n+};\n+\n+template<typename T>\n+struct It {\n+  T operator*();\n+  It operator++();\n+  bool operator!=(const It);\n+};\n+\n+template<typename T>\n+struct Cont {\n+  using I = It<T>;\n+  I begin();\n+  I end();\n+};\n+\n+#define TEST\t\t\t\t\t    \\\n+  void fn_macro()\t\t\t\t    \\\n+  {\t\t\t\t\t\t    \\\n+    Cont<Bar &> cont_bar_ref;\t\t\t    \\\n+    for (const Bar x : cont_bar_ref) { (void) x; }  \\\n+  }\n+\n+TEST\n+\n+Cont<Bar &>& foo ();\n+Cont<Bar &> foo2 ();\n+\n+void\n+fn1 ()\n+{\n+  for (const auto x : foo () ) { (void) x; } // { dg-warning \"creates a copy\" }\n+  for (const auto x : foo2 () ) { (void) x; } // { dg-warning \"creates a copy\" }\n+\n+  Small s{};\n+  Small sa[5] = { };\n+  for (const auto x : sa) { (void) x; }\n+  for (const auto x : { s, s, s }) { (void) x; }\n+\n+  Big_aggr b{};\n+  Big_aggr ba[5] = { };\n+  for (const auto x : ba) { (void) x; } // { dg-warning \"creates a copy\" }\n+  for (const auto x : { b, b, b }) { (void) x; } // { dg-warning \"creates a copy\" }\n+\n+  Big_triv_copy bt{};\n+  Big_triv_copy bta[5];\n+  for (const auto x : bta) { (void) x; } // { dg-warning \"creates a copy\" }\n+  for (const auto x : { bt, bt, bt }) { (void) x; } // { dg-warning \"creates a copy\" }\n+\n+  Big b2;\n+  Big ba2[5];\n+  for (const auto x : ba2) { (void) x; } // { dg-warning \"creates a copy\" }\n+  for (const auto x : { b2, b2, b2 }) { (void) x; } // { dg-warning \"creates a copy\" }\n+}\n+\n+void\n+fn2 ()\n+{\n+  Cont<int> cont_int;\n+  for (const auto x : cont_int) { (void) x; }\n+  for (const int x : cont_int) { (void) x; }\n+  for (int x : cont_int) { (void) x; }\n+  for (const auto &x : cont_int) { (void) x; }\n+  for (double x : cont_int) { (void) x; }\n+  for (const double x : cont_int) { (void) x; }\n+  for (const Bar x : cont_int) { (void) x; }\n+  for (Bar x : cont_int) { (void) x; }\n+}\n+\n+void\n+fn3 ()\n+{\n+  Cont<int &> cont_int_ref;\n+  for (const int x : cont_int_ref) { (void) x; }\n+  for (int x : cont_int_ref) { (void) x; }\n+  for (const double x : cont_int_ref) { (void) x; }\n+  for (double x : cont_int_ref) { (void) x; }\n+  for (const Bar x : cont_int_ref) { (void) x; }\n+  for (Bar x : cont_int_ref) { (void) x; }\n+}\n+\n+void\n+fn4 ()\n+{\n+  Cont<Bar> cont_bar;\n+  for (const Bar x : cont_bar) { (void) x; }\n+  for (Bar x : cont_bar) { (void) x; }\n+  for (const int x : cont_bar) { (void) x; }\n+  for (int x : cont_bar) { (void) x; }\n+}\n+\n+void\n+fn5 ()\n+{\n+  Cont<Bar&> cont_bar_ref;\n+  for (const Bar x : cont_bar_ref) { (void) x; } // { dg-warning \"creates a copy\" }\n+  for (Bar x : cont_bar_ref) { (void) x; }\n+  for (const int x : cont_bar_ref) { (void) x; }\n+  for (int x : cont_bar_ref) { (void) x; }\n+}\n+\n+void\n+fn6 ()\n+{\n+  Cont<Foo> cont_foo;\n+  for (const Bar x : cont_foo) { (void) x; }\n+  for (Bar x : cont_foo) { (void) x; }\n+}\n+\n+void\n+fn7 ()\n+{\n+  Cont<Foo &> cont_foo_ref;\n+  for (const Bar x : cont_foo_ref) { (void) x; }\n+  for (Bar x : cont_foo_ref) { (void) x; }\n+}\n+\n+void\n+fn8 ()\n+{\n+  double arr[2];\n+  for (const double x : arr) { (void) x; }\n+  for (double x : arr) { (void) x; }\n+  for (const int x : arr) { (void) x; }\n+  for (int x : arr) { (void) x; }\n+  for (const Bar x : arr) { (void) x; }\n+  for (Bar x : arr) { (void) x; }\n+}\n+\n+void\n+fn9 ()\n+{\n+  Foo foo[2];\n+  for (const Foo x : foo) { (void) x; }\n+  for (Foo x : foo) { (void) x; }\n+  for (const Bar x : foo) { (void) x; }\n+  for (Bar x : foo) { (void) x; }\n+}\n+\n+void\n+fn10 ()\n+{\n+  Bar bar[2] = { 1, 2 };\n+  for (const Bar x : bar) { (void) x; } // { dg-warning \"creates a copy\" }\n+  for (Bar x : bar) { (void) x; }\n+  for (const int x : bar) { (void) x; }\n+  for (int x : bar) { (void) x; }\n+}\n+\n+template<typename T>\n+void\n+fn11 ()\n+{\n+  Cont<Bar> cont_bar;\n+  for (const Bar x : cont_bar) { (void) x; }\n+\n+  Cont<Bar&> cont_bar_ref;\n+  for (const Bar x : cont_bar_ref) { (void) x; } // { dg-warning \"creates a copy\" }\n+\n+  Cont<T> cont_dep;\n+  for (const T x : cont_dep) { (void) x; }\n+}\n+\n+template<typename T>\n+void\n+fn12 ()\n+{\n+  for (const auto x : { T{} }) { (void) x; } // { dg-warning \"creates a copy\" }\n+}\n+\n+void\n+invoke ()\n+{\n+  fn11<int> ();\n+  fn12<Big> ();\n+}"}]}