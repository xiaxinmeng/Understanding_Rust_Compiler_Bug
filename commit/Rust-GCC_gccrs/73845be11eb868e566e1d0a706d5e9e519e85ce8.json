{"sha": "73845be11eb868e566e1d0a706d5e9e519e85ce8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzM4NDViZTExZWI4NjhlNTY2ZTFkMGE3MDZkNWU5ZTUxOWU4NWNlOA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-06-25T20:13:42Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-06-25T20:13:42Z"}, "message": "(__objc_register_instance_methods_to_class): New function.\n\nFrom-SVN: r14307", "tree": {"sha": "b78365d0dfacf0182327e1b8ffc02a96e3446860", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b78365d0dfacf0182327e1b8ffc02a96e3446860"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/73845be11eb868e566e1d0a706d5e9e519e85ce8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73845be11eb868e566e1d0a706d5e9e519e85ce8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/73845be11eb868e566e1d0a706d5e9e519e85ce8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73845be11eb868e566e1d0a706d5e9e519e85ce8/comments", "author": null, "committer": null, "parents": [{"sha": "38692f1f94e9483345a45de94d2a70443e4717e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38692f1f94e9483345a45de94d2a70443e4717e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38692f1f94e9483345a45de94d2a70443e4717e4"}], "stats": {"total": 65, "additions": 65, "deletions": 0}, "files": [{"sha": "b2fdccb520bc8bd383fb73c9368ac747f715dd8f", "filename": "gcc/objc/selector.c", "status": "modified", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73845be11eb868e566e1d0a706d5e9e519e85ce8/gcc%2Fobjc%2Fselector.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73845be11eb868e566e1d0a706d5e9e519e85ce8/gcc%2Fobjc%2Fselector.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fselector.c?ref=73845be11eb868e566e1d0a706d5e9e519e85ce8", "patch": "@@ -88,6 +88,71 @@ register_selectors_from_list (MethodList_t method_list)\n }\n \n \n+/* Register instance methods as class methods for root classes */\n+void __objc_register_instance_methods_to_class(Class class)\n+{\n+  MethodList_t method_list;\n+  MethodList_t class_method_list;\n+  int max_methods_no = 16;\n+  MethodList_t new_list;\n+  Method_t curr_method;\n+\n+  /* Only if a root class. */\n+  if(class->super_class)\n+    return;\n+\n+  /* Allocate a method list to hold the new class methods */\n+  new_list = objc_calloc(sizeof(struct objc_method_list)\n+\t\t\t    + sizeof(struct objc_method[max_methods_no]), 1);\n+  method_list = class->methods;\n+  class_method_list = class->class_pointer->methods;\n+  curr_method = &new_list->method_list[0];\n+\n+  /* Iterate through the method lists for the class */\n+  while (method_list)\n+    {\n+      int i;\n+\n+      /* Iterate through the methods from this method list */\n+      for (i = 0; i < method_list->method_count; i++)\n+\t{\n+\t  Method_t mth = &method_list->method_list[i];\n+\t  if (mth->method_name\n+\t      && !search_for_method_in_list (class_method_list,\n+\t\t\t\t\t      mth->method_name))\n+\t    {\n+\t      /* This instance method isn't a class method. \n+\t\t  Add it into the new_list. */\n+\t      *curr_method = *mth;\n+  \n+\t      /* Reallocate the method list if necessary */\n+\t      if(++new_list->method_count == max_methods_no)\n+\t\tnew_list =\n+\t\t  objc_realloc(new_list, sizeof(struct objc_method_list)\n+\t\t\t\t+ sizeof(struct \n+\t\t\t\t\tobjc_method[max_methods_no += 16]));\n+\t      curr_method = &new_list->method_list[new_list->method_count];\n+\t    }\n+\t}\n+\n+      method_list = method_list->method_next;\n+    }\n+\n+  /* If we created any new class methods\n+     then attach the method list to the class */\n+  if (new_list->method_count)\n+    {\n+      new_list =\n+ \tobjc_realloc(new_list, sizeof(struct objc_method_list)\n+\t\t     + sizeof(struct objc_method[new_list->method_count]));\n+      new_list->method_next = class->class_pointer->methods;\n+      class->class_pointer->methods = new_list;\n+    }\n+\n+    __objc_update_dispatch_table_for_class (class->class_pointer);\n+}\n+\n+\n /* Returns YES iff t1 and t2 have same method types, but we ignore\n    the argframe layout */\n BOOL"}]}