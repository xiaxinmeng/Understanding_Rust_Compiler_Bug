{"sha": "00fa90d975bfacfd91a615fbee24e3e6a100100f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDBmYTkwZDk3NWJmYWNmZDkxYTYxNWZiZWUyNGUzZTZhMTAwMTAwZg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-08-14T08:50:10Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-08-14T08:50:10Z"}, "message": "[AArch64] Rework SVE integer comparisons\n\nThe remaining uses of UNSPEC_MERGE_PTRUE were in integer comparison\npatterns.  These aren't actually merging operations but zeroing ones,\nalthough there's no practical difference when the predicate is a PTRUE.\n\nAll comparisons produced by expand are predicated on a PTRUE,\nalthough we try to pattern-match a compare-and-AND as a predicated\ncomparison during combine.\n\nLike previous patches, this one rearranges things in a way that works\nbetter with the ACLE, where the initial predicate might or might not\nbe a PTRUE.  The new patterns use UNSPEC_PRED_Z to represent zeroing\npredication, with a aarch64_sve_ptrue_flag to record whether the\npredicate is all-true (as for UNSPEC_PTEST).\n\nSee the block comment in the patch for more details.\n\n2019-08-14  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* config/aarch64/aarch64-protos.h (aarch64_sve_same_pred_for_ptest_p):\n\tDeclare.\n\t* config/aarch64/aarch64.c (aarch64_sve_same_pred_for_ptest_p)\n\t(aarch64_sve_emit_int_cmp): New functions.\n\t(aarch64_convert_sve_data_to_pred): Use aarch64_sve_emit_int_cmp.\n\t(aarch64_sve_cmp_operand_p, aarch64_emit_sve_ptrue_op_cc): Delete.\n\t(aarch64_expand_sve_vec_cmp_int): Use aarch64_sve_emit_int_cmp.\n\t* config/aarch64/aarch64.md (UNSPEC_MERGE_PTRUE): Delete.\n\t(UNSPEC_PRED_Z): New unspec.\n\t(set_clobber_cc_nzc): Delete.\n\t* config/aarch64/aarch64-sve.md: Add a block comment about\n\tUNSPEC_PRED_Z.\n\t(*cmp<SVE_INT_CMP:cmp_op><mode>): Rename to...\n\t(@aarch64_pred_cmp<SVE_INT_CMP:cmp_op><mode>): ...this, replacing\n\tthe old pattern with that name.  Use UNSPEC_PRED_Z instead of\n\tUNSPEC_MERGE_PTRUE.\n\t(*cmp<SVE_INT_CMP:cmp_op><mode>_cc): Use UNSPEC_PRED_Z instead of\n\tUNSPEC_MERGE_PTRUE.  Use aarch64_sve_same_pred_for_ptest_p to\n\tcheck for compatible predicates.\n\t(*cmp<cmp_op><SVE_INT_CMP:mode>_ptest): Likewise.\n\t(*cmp<cmp_op><mode>_and): Match a known-ptrue UNSPEC_PRED_Z instead\n\tof UNSPEC_MERGE_PTRUE.  Split into the new form of predicated\n\tcomparisons above.\n\nFrom-SVN: r274429", "tree": {"sha": "04abc2c2a642d405e73a8b28d1145a9ef19b9597", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/04abc2c2a642d405e73a8b28d1145a9ef19b9597"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/00fa90d975bfacfd91a615fbee24e3e6a100100f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00fa90d975bfacfd91a615fbee24e3e6a100100f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/00fa90d975bfacfd91a615fbee24e3e6a100100f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00fa90d975bfacfd91a615fbee24e3e6a100100f/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "052f7399dd78d94d27fc1c3e1696cc7f93063610", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/052f7399dd78d94d27fc1c3e1696cc7f93063610", "html_url": "https://github.com/Rust-GCC/gccrs/commit/052f7399dd78d94d27fc1c3e1696cc7f93063610"}], "stats": {"total": 298, "additions": 179, "deletions": 119}, "files": [{"sha": "9de3d0c5575a1dbec2b8a4372b83b9f4d2eeba0b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00fa90d975bfacfd91a615fbee24e3e6a100100f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00fa90d975bfacfd91a615fbee24e3e6a100100f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=00fa90d975bfacfd91a615fbee24e3e6a100100f", "patch": "@@ -1,3 +1,29 @@\n+2019-08-14  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* config/aarch64/aarch64-protos.h (aarch64_sve_same_pred_for_ptest_p):\n+\tDeclare.\n+\t* config/aarch64/aarch64.c (aarch64_sve_same_pred_for_ptest_p)\n+\t(aarch64_sve_emit_int_cmp): New functions.\n+\t(aarch64_convert_sve_data_to_pred): Use aarch64_sve_emit_int_cmp.\n+\t(aarch64_sve_cmp_operand_p, aarch64_emit_sve_ptrue_op_cc): Delete.\n+\t(aarch64_expand_sve_vec_cmp_int): Use aarch64_sve_emit_int_cmp.\n+\t* config/aarch64/aarch64.md (UNSPEC_MERGE_PTRUE): Delete.\n+\t(UNSPEC_PRED_Z): New unspec.\n+\t(set_clobber_cc_nzc): Delete.\n+\t* config/aarch64/aarch64-sve.md: Add a block comment about\n+\tUNSPEC_PRED_Z.\n+\t(*cmp<SVE_INT_CMP:cmp_op><mode>): Rename to...\n+\t(@aarch64_pred_cmp<SVE_INT_CMP:cmp_op><mode>): ...this, replacing\n+\tthe old pattern with that name.  Use UNSPEC_PRED_Z instead of\n+\tUNSPEC_MERGE_PTRUE.\n+\t(*cmp<SVE_INT_CMP:cmp_op><mode>_cc): Use UNSPEC_PRED_Z instead of\n+\tUNSPEC_MERGE_PTRUE.  Use aarch64_sve_same_pred_for_ptest_p to\n+\tcheck for compatible predicates.\n+\t(*cmp<cmp_op><SVE_INT_CMP:mode>_ptest): Likewise.\n+\t(*cmp<cmp_op><mode>_and): Match a known-ptrue UNSPEC_PRED_Z instead\n+\tof UNSPEC_MERGE_PTRUE.  Split into the new form of predicated\n+\tcomparisons above.\n+\n 2019-08-14  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* config/aarch64/aarch64.md (UNSPEC_PRED_X): New unspec."}, {"sha": "858c4500406873cb1a0c0f619c5854e61c9ab5f6", "filename": "gcc/config/aarch64/aarch64-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00fa90d975bfacfd91a615fbee24e3e6a100100f/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00fa90d975bfacfd91a615fbee24e3e6a100100f/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h?ref=00fa90d975bfacfd91a615fbee24e3e6a100100f", "patch": "@@ -555,6 +555,7 @@ void aarch64_expand_mov_immediate (rtx, rtx);\n rtx aarch64_ptrue_reg (machine_mode);\n rtx aarch64_pfalse_reg (machine_mode);\n bool aarch64_sve_pred_dominates_p (rtx *, rtx);\n+bool aarch64_sve_same_pred_for_ptest_p (rtx *, rtx *);\n void aarch64_emit_sve_pred_move (rtx, rtx, rtx);\n void aarch64_expand_sve_mem_move (rtx, rtx, machine_mode);\n bool aarch64_maybe_expand_sve_subreg_move (rtx, rtx);"}, {"sha": "e95486749b9649c2e9fe6a32d6bd4167422ed9c4", "filename": "gcc/config/aarch64/aarch64-sve.md", "status": "modified", "additions": 103, "deletions": 52, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00fa90d975bfacfd91a615fbee24e3e6a100100f/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00fa90d975bfacfd91a615fbee24e3e6a100100f/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md?ref=00fa90d975bfacfd91a615fbee24e3e6a100100f", "patch": "@@ -24,6 +24,7 @@\n ;; == General notes\n ;; ---- Note on the handling of big-endian SVE\n ;; ---- Description of UNSPEC_PTEST\n+;; ---- Description of UNSPEC_PRED_Z\n ;; ---- Note on predicated integer arithemtic and UNSPEC_PRED_X\n ;; ---- Note on predicated FP arithmetic patterns and GP \"strictness\"\n ;;\n@@ -231,6 +232,52 @@\n ;; - OP is the predicate we want to test, of the same mode as CAST_GP.\n ;;\n ;; -------------------------------------------------------------------------\n+;; ---- Description of UNSPEC_PRED_Z\n+;; -------------------------------------------------------------------------\n+;;\n+;; SVE integer comparisons are predicated and return zero for inactive\n+;; lanes.  Sometimes we use them with predicates that are all-true and\n+;; sometimes we use them with general predicates.\n+;;\n+;; The integer comparisons also set the flags and so build-in the effect\n+;; of a PTEST.  We therefore want to be able to combine integer comparison\n+;; patterns with PTESTs of the result.  One difficulty with doing this is\n+;; that (as noted above) the PTEST is always a .B operation and so can place\n+;; stronger requirements on the governing predicate than the comparison does.\n+;;\n+;; For example, when applying a separate PTEST to the result of a full-vector\n+;; .H comparison, the PTEST must be predicated on a .H PTRUE instead of a\n+;; .B PTRUE.  In constrast, the comparison might be predicated on either\n+;; a .H PTRUE or a .B PTRUE, since the values of odd-indexed predicate\n+;; bits don't matter for .H operations.\n+;;\n+;; We therefore can't rely on a full-vector comparison using the same\n+;; predicate register as a following PTEST.  We instead need to remember\n+;; whether a comparison is known to be a full-vector comparison and use\n+;; this information in addition to a check for equal predicate registers.\n+;; At the same time, it's useful to have a common representation for all\n+;; integer comparisons, so that they can be handled by a single set of\n+;; patterns.\n+;;\n+;; We therefore take a similar approach to UNSPEC_PTEST above and use:\n+;;\n+;;   (unspec:<M:VPRED> [gp ptrue_flag (code:M op0 op1)] UNSPEC_PRED_Z)\n+;;\n+;; where:\n+;;\n+;; - GP is the governing predicate, of mode <M:VPRED>\n+;;\n+;; - PTRUE_FLAG is a CONST_INT (conceptually of mode SI) that has the value\n+;;   SVE_KNOWN_PTRUE if we know that GP is all-true and SVE_MAYBE_NOT_PTRUE\n+;;   otherwise\n+;;\n+;; - CODE is the comparison code\n+;;\n+;; - OP0 and OP1 are the values being compared, of mode M\n+;;\n+;; The \"Z\" in UNSPEC_PRED_Z indicates that inactive lanes are zero.\n+;;\n+;; -------------------------------------------------------------------------\n ;; ---- Note on predicated integer arithemtic and UNSPEC_PRED_X\n ;; -------------------------------------------------------------------------\n ;;\n@@ -3008,115 +3055,119 @@\n   }\n )\n \n-;; Integer comparisons predicated with a PTRUE.\n-(define_insn \"*cmp<cmp_op><mode>\"\n+;; Predicated integer comparisons.\n+(define_insn \"@aarch64_pred_cmp<cmp_op><mode>\"\n   [(set (match_operand:<VPRED> 0 \"register_operand\" \"=Upa, Upa\")\n \t(unspec:<VPRED>\n \t  [(match_operand:<VPRED> 1 \"register_operand\" \"Upl, Upl\")\n+\t   (match_operand:SI 2 \"aarch64_sve_ptrue_flag\")\n \t   (SVE_INT_CMP:<VPRED>\n-\t     (match_operand:SVE_I 2 \"register_operand\" \"w, w\")\n-\t     (match_operand:SVE_I 3 \"aarch64_sve_cmp_<sve_imm_con>_operand\" \"<sve_imm_con>, w\"))]\n-\t  UNSPEC_MERGE_PTRUE))\n+\t     (match_operand:SVE_I 3 \"register_operand\" \"w, w\")\n+\t     (match_operand:SVE_I 4 \"aarch64_sve_cmp_<sve_imm_con>_operand\" \"<sve_imm_con>, w\"))]\n+\t  UNSPEC_PRED_Z))\n    (clobber (reg:CC_NZC CC_REGNUM))]\n   \"TARGET_SVE\"\n   \"@\n-   cmp<cmp_op>\\t%0.<Vetype>, %1/z, %2.<Vetype>, #%3\n-   cmp<cmp_op>\\t%0.<Vetype>, %1/z, %2.<Vetype>, %3.<Vetype>\"\n+   cmp<cmp_op>\\t%0.<Vetype>, %1/z, %3.<Vetype>, #%4\n+   cmp<cmp_op>\\t%0.<Vetype>, %1/z, %3.<Vetype>, %4.<Vetype>\"\n )\n \n-;; Integer comparisons predicated with a PTRUE in which both the flag and\n-;; predicate results are interesting.\n-(define_insn \"*cmp<cmp_op><mode>_cc\"\n+;; Predicated integer comparisons in which both the flag and predicate\n+;; results are interesting.\n+(define_insn_and_rewrite \"*cmp<cmp_op><mode>_cc\"\n   [(set (reg:CC_NZC CC_REGNUM)\n \t(unspec:CC_NZC\n \t  [(match_operand:VNx16BI 1 \"register_operand\" \"Upl, Upl\")\n \t   (match_operand 4)\n \t   (match_operand:SI 5 \"aarch64_sve_ptrue_flag\")\n \t   (unspec:<VPRED>\n-\t     [(match_dup 4)\n+\t     [(match_operand 6)\n+\t      (match_operand:SI 7 \"aarch64_sve_ptrue_flag\")\n \t      (SVE_INT_CMP:<VPRED>\n \t\t(match_operand:SVE_I 2 \"register_operand\" \"w, w\")\n \t\t(match_operand:SVE_I 3 \"aarch64_sve_cmp_<sve_imm_con>_operand\" \"<sve_imm_con>, w\"))]\n-\t     UNSPEC_MERGE_PTRUE)]\n+\t     UNSPEC_PRED_Z)]\n \t  UNSPEC_PTEST))\n    (set (match_operand:<VPRED> 0 \"register_operand\" \"=Upa, Upa\")\n \t(unspec:<VPRED>\n-\t  [(match_dup 4)\n+\t  [(match_dup 6)\n+\t   (match_dup 7)\n \t   (SVE_INT_CMP:<VPRED>\n \t     (match_dup 2)\n \t     (match_dup 3))]\n-\t  UNSPEC_MERGE_PTRUE))]\n-  \"TARGET_SVE\"\n+\t  UNSPEC_PRED_Z))]\n+  \"TARGET_SVE\n+   && aarch64_sve_same_pred_for_ptest_p (&operands[4], &operands[6])\"\n   \"@\n    cmp<cmp_op>\\t%0.<Vetype>, %1/z, %2.<Vetype>, #%3\n    cmp<cmp_op>\\t%0.<Vetype>, %1/z, %2.<Vetype>, %3.<Vetype>\"\n+  \"&& !rtx_equal_p (operands[4], operands[6])\"\n+  {\n+    operands[6] = copy_rtx (operands[4]);\n+    operands[7] = operands[5];\n+  }\n )\n \n-;; Integer comparisons predicated with a PTRUE in which only the flags result\n-;; is interesting.\n-(define_insn \"*cmp<cmp_op><mode>_ptest\"\n+;; Predicated integer comparisons in which only the flags result is\n+;; interesting.\n+(define_insn_and_rewrite \"*cmp<cmp_op><mode>_ptest\"\n   [(set (reg:CC_NZC CC_REGNUM)\n \t(unspec:CC_NZC\n \t  [(match_operand:VNx16BI 1 \"register_operand\" \"Upl, Upl\")\n \t   (match_operand 4)\n \t   (match_operand:SI 5 \"aarch64_sve_ptrue_flag\")\n \t   (unspec:<VPRED>\n-\t     [(match_dup 4)\n+\t     [(match_operand 6)\n+\t      (match_operand:SI 7 \"aarch64_sve_ptrue_flag\")\n \t      (SVE_INT_CMP:<VPRED>\n \t\t(match_operand:SVE_I 2 \"register_operand\" \"w, w\")\n \t\t(match_operand:SVE_I 3 \"aarch64_sve_cmp_<sve_imm_con>_operand\" \"<sve_imm_con>, w\"))]\n-\t     UNSPEC_MERGE_PTRUE)]\n+\t     UNSPEC_PRED_Z)]\n \t  UNSPEC_PTEST))\n    (clobber (match_scratch:<VPRED> 0 \"=Upa, Upa\"))]\n-  \"TARGET_SVE\"\n+  \"TARGET_SVE\n+   && aarch64_sve_same_pred_for_ptest_p (&operands[4], &operands[6])\"\n   \"@\n    cmp<cmp_op>\\t%0.<Vetype>, %1/z, %2.<Vetype>, #%3\n    cmp<cmp_op>\\t%0.<Vetype>, %1/z, %2.<Vetype>, %3.<Vetype>\"\n+  \"&& !rtx_equal_p (operands[4], operands[6])\"\n+  {\n+    operands[6] = copy_rtx (operands[4]);\n+    operands[7] = operands[5];\n+  }\n )\n \n ;; Predicated integer comparisons, formed by combining a PTRUE-predicated\n ;; comparison with an AND.  Split the instruction into its preferred form\n-;; (below) at the earliest opportunity, in order to get rid of the\n-;; redundant operand 1.\n-(define_insn_and_split \"*pred_cmp<cmp_op><mode>_combine\"\n+;; at the earliest opportunity, in order to get rid of the redundant\n+;; operand 4.\n+(define_insn_and_split \"*cmp<cmp_op><mode>_and\"\n   [(set (match_operand:<VPRED> 0 \"register_operand\" \"=Upa, Upa\")\n-       (and:<VPRED>\n-\t (unspec:<VPRED>\n-\t   [(match_operand:<VPRED> 1)\n-\t    (SVE_INT_CMP:<VPRED>\n-\t      (match_operand:SVE_I 2 \"register_operand\" \"w, w\")\n-\t      (match_operand:SVE_I 3 \"aarch64_sve_cmp_<sve_imm_con>_operand\" \"<sve_imm_con>, w\"))]\n-\t   UNSPEC_MERGE_PTRUE)\n-\t (match_operand:<VPRED> 4 \"register_operand\" \"Upl, Upl\")))\n+\t(and:<VPRED>\n+\t  (unspec:<VPRED>\n+\t    [(match_operand 4)\n+\t     (const_int SVE_KNOWN_PTRUE)\n+\t     (SVE_INT_CMP:<VPRED>\n+\t       (match_operand:SVE_I 2 \"register_operand\" \"w, w\")\n+\t       (match_operand:SVE_I 3 \"aarch64_sve_cmp_<sve_imm_con>_operand\" \"<sve_imm_con>, w\"))]\n+\t    UNSPEC_PRED_Z)\n+\t  (match_operand:<VPRED> 1 \"register_operand\" \"Upl, Upl\")))\n    (clobber (reg:CC_NZC CC_REGNUM))]\n   \"TARGET_SVE\"\n   \"#\"\n   \"&& 1\"\n   [(parallel\n      [(set (match_dup 0)\n-\t  (and:<VPRED>\n-\t    (SVE_INT_CMP:<VPRED>\n-\t      (match_dup 2)\n-\t      (match_dup 3))\n-\t    (match_dup 4)))\n+\t   (unspec:<VPRED>\n+\t     [(match_dup 1)\n+\t      (const_int SVE_MAYBE_NOT_PTRUE)\n+\t      (SVE_INT_CMP:<VPRED>\n+\t\t(match_dup 2)\n+\t\t(match_dup 3))]\n+\t     UNSPEC_PRED_Z))\n       (clobber (reg:CC_NZC CC_REGNUM))])]\n )\n \n-;; Predicated integer comparisons.\n-(define_insn \"@aarch64_pred_cmp<cmp_op><mode>\"\n-  [(set (match_operand:<VPRED> 0 \"register_operand\" \"=Upa, Upa\")\n-\t(and:<VPRED>\n-\t  (SVE_INT_CMP:<VPRED>\n-\t    (match_operand:SVE_I 2 \"register_operand\" \"w, w\")\n-\t    (match_operand:SVE_I 3 \"aarch64_sve_cmp_<sve_imm_con>_operand\" \"<sve_imm_con>, w\"))\n-\t  (match_operand:<VPRED> 1 \"register_operand\" \"Upl, Upl\")))\n-   (clobber (reg:CC_NZC CC_REGNUM))]\n-  \"TARGET_SVE\"\n-  \"@\n-   cmp<cmp_op>\\t%0.<Vetype>, %1/z, %2.<Vetype>, #%3\n-   cmp<cmp_op>\\t%0.<Vetype>, %1/z, %2.<Vetype>, %3.<Vetype>\"\n-)\n-\n ;; -------------------------------------------------------------------------\n ;; ---- [INT] While tests\n ;; -------------------------------------------------------------------------"}, {"sha": "40d102b3d192086047e77db307c9c39c92f46f6b", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 48, "deletions": 60, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00fa90d975bfacfd91a615fbee24e3e6a100100f/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00fa90d975bfacfd91a615fbee24e3e6a100100f/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=00fa90d975bfacfd91a615fbee24e3e6a100100f", "patch": "@@ -2783,6 +2783,48 @@ aarch64_sve_pred_dominates_p (rtx *pred1, rtx pred2)\n \t  || rtx_equal_p (pred1[0], pred2));\n }\n \n+/* PRED1[0] is a PTEST predicate and PRED1[1] is an aarch64_sve_ptrue_flag\n+   for it.  PRED2[0] is the predicate for the instruction whose result\n+   is tested by the PTEST and PRED2[1] is again an aarch64_sve_ptrue_flag\n+   for it.  Return true if we can prove that the two predicates are\n+   equivalent for PTEST purposes; that is, if we can replace PRED2[0]\n+   with PRED1[0] without changing behavior.  */\n+\n+bool\n+aarch64_sve_same_pred_for_ptest_p (rtx *pred1, rtx *pred2)\n+{\n+  machine_mode mode = GET_MODE (pred1[0]);\n+  gcc_assert (GET_MODE_CLASS (mode) == MODE_VECTOR_BOOL\n+\t      && mode == GET_MODE (pred2[0])\n+\t      && aarch64_sve_ptrue_flag (pred1[1], SImode)\n+\t      && aarch64_sve_ptrue_flag (pred2[1], SImode));\n+\n+  bool ptrue1_p = (pred1[0] == CONSTM1_RTX (mode)\n+\t\t   || INTVAL (pred1[1]) == SVE_KNOWN_PTRUE);\n+  bool ptrue2_p = (pred2[0] == CONSTM1_RTX (mode)\n+\t\t   || INTVAL (pred2[1]) == SVE_KNOWN_PTRUE);\n+  return (ptrue1_p && ptrue2_p) || rtx_equal_p (pred1[0], pred2[0]);\n+}\n+\n+/* Emit a comparison CMP between OP0 and OP1, both of which have mode\n+   DATA_MODE, and return the result in a predicate of mode PRED_MODE.\n+   Use TARGET as the target register if nonnull and convenient.  */\n+\n+static rtx\n+aarch64_sve_emit_int_cmp (rtx target, machine_mode pred_mode, rtx_code cmp,\n+\t\t\t  machine_mode data_mode, rtx op1, rtx op2)\n+{\n+  insn_code icode = code_for_aarch64_pred_cmp (cmp, data_mode);\n+  expand_operand ops[5];\n+  create_output_operand (&ops[0], target, pred_mode);\n+  create_input_operand (&ops[1], CONSTM1_RTX (pred_mode), pred_mode);\n+  create_integer_operand (&ops[2], SVE_KNOWN_PTRUE);\n+  create_input_operand (&ops[3], op1, data_mode);\n+  create_input_operand (&ops[4], op2, data_mode);\n+  expand_insn (icode, 5, ops);\n+  return ops[0].value;\n+}\n+\n /* Use a comparison to convert integer vector SRC into MODE, which is\n    the corresponding SVE predicate mode.  Use TARGET for the result\n    if it's nonnull and convenient.  */\n@@ -2791,14 +2833,8 @@ static rtx\n aarch64_convert_sve_data_to_pred (rtx target, machine_mode mode, rtx src)\n {\n   machine_mode src_mode = GET_MODE (src);\n-  insn_code icode = code_for_aarch64_pred_cmp (NE, src_mode);\n-  expand_operand ops[4];\n-  create_output_operand (&ops[0], target, mode);\n-  create_input_operand (&ops[1], CONSTM1_RTX (mode), mode);\n-  create_input_operand (&ops[2], src, src_mode);\n-  create_input_operand (&ops[3], CONST0_RTX (src_mode), src_mode);\n-  expand_insn (icode, 4, ops);\n-  return ops[0].value;\n+  return aarch64_sve_emit_int_cmp (target, mode, NE, src_mode,\n+\t\t\t\t   src, CONST0_RTX (src_mode));\n }\n \n /* Return true if we can move VALUE into a register using a single\n@@ -17667,51 +17703,6 @@ aarch64_reverse_mask (machine_mode mode, unsigned int nunits)\n   return force_reg (V16QImode, mask);\n }\n \n-/* Return true if X is a valid second operand for the SVE instruction\n-   that implements integer comparison OP_CODE.  */\n-\n-static bool\n-aarch64_sve_cmp_operand_p (rtx_code op_code, rtx x)\n-{\n-  if (register_operand (x, VOIDmode))\n-    return true;\n-\n-  switch (op_code)\n-    {\n-    case LTU:\n-    case LEU:\n-    case GEU:\n-    case GTU:\n-      return aarch64_sve_cmp_immediate_p (x, false);\n-    case LT:\n-    case LE:\n-    case GE:\n-    case GT:\n-    case NE:\n-    case EQ:\n-      return aarch64_sve_cmp_immediate_p (x, true);\n-    default:\n-      gcc_unreachable ();\n-    }\n-}\n-\n-/* Use predicated SVE instructions to implement the equivalent of:\n-\n-     (set TARGET OP)\n-\n-   given that PTRUE is an all-true predicate of the appropriate mode\n-   and that the instruction clobbers the condition codes.  */\n-\n-static void\n-aarch64_emit_sve_ptrue_op_cc (rtx target, rtx ptrue, rtx op)\n-{\n-  rtx unspec = gen_rtx_UNSPEC (GET_MODE (target),\n-\t\t\t       gen_rtvec (2, ptrue, op),\n-\t\t\t       UNSPEC_MERGE_PTRUE);\n-  rtx_insn *insn = emit_insn (gen_set_clobber_cc_nzc (target, unspec));\n-  set_unique_reg_note (insn, REG_EQUAL, copy_rtx (op));\n-}\n-\n /* Expand an SVE integer comparison using the SVE equivalent of:\n \n      (set TARGET (CODE OP0 OP1)).  */\n@@ -17721,13 +17712,10 @@ aarch64_expand_sve_vec_cmp_int (rtx target, rtx_code code, rtx op0, rtx op1)\n {\n   machine_mode pred_mode = GET_MODE (target);\n   machine_mode data_mode = GET_MODE (op0);\n-\n-  if (!aarch64_sve_cmp_operand_p (code, op1))\n-    op1 = force_reg (data_mode, op1);\n-\n-  rtx ptrue = aarch64_ptrue_reg (pred_mode);\n-  rtx cond = gen_rtx_fmt_ee (code, pred_mode, op0, op1);\n-  aarch64_emit_sve_ptrue_op_cc (target, ptrue, cond);\n+  rtx res = aarch64_sve_emit_int_cmp (target, pred_mode, code, data_mode,\n+\t\t\t\t      op0, op1);\n+  if (!rtx_equal_p (target, res))\n+    emit_move_insn (target, res);\n }\n \n /* Return the UNSPEC_COND_* code for comparison CODE.  */"}, {"sha": "6d9692f563f35b272fc107e652526f5a6195f833", "filename": "gcc/config/aarch64/aarch64.md", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00fa90d975bfacfd91a615fbee24e3e6a100100f/gcc%2Fconfig%2Faarch64%2Faarch64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00fa90d975bfacfd91a615fbee24e3e6a100100f/gcc%2Fconfig%2Faarch64%2Faarch64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.md?ref=00fa90d975bfacfd91a615fbee24e3e6a100100f", "patch": "@@ -219,8 +219,8 @@\n     UNSPEC_LD1RQ\n     UNSPEC_LD1_GATHER\n     UNSPEC_ST1_SCATTER\n-    UNSPEC_MERGE_PTRUE\n     UNSPEC_PRED_X\n+    UNSPEC_PRED_Z\n     UNSPEC_PTEST\n     UNSPEC_UNPACKSHI\n     UNSPEC_UNPACKUHI\n@@ -7155,12 +7155,6 @@\n   [(set_attr \"type\" \"no_insn\")]\n )\n \n-;; Helper for aarch64.c code.\n-(define_expand \"set_clobber_cc_nzc\"\n-  [(parallel [(set (match_operand 0)\n-\t\t   (match_operand 1))\n-\t      (clobber (reg:CC_NZC CC_REGNUM))])])\n-\n ;; Hard speculation barrier.\n (define_insn \"speculation_barrier\"\n   [(unspec_volatile [(const_int 0)] UNSPECV_SPECULATION_BARRIER)]"}]}