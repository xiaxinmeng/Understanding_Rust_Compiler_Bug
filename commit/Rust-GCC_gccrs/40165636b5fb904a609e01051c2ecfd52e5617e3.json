{"sha": "40165636b5fb904a609e01051c2ecfd52e5617e3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDAxNjU2MzZiNWZiOTA0YTYwOWUwMTA1MWMyZWNmZDUyZTU2MTdlMw==", "commit": {"author": {"name": "Rodney Brown", "email": "rbrown64@csc.com.au", "date": "2002-07-02T19:43:03Z"}, "committer": {"name": "Stan Shebs", "email": "shebs@gcc.gnu.org", "date": "2002-07-02T19:43:03Z"}, "message": "encoding.h: Fix formatting.\n\n2002-07-02  Rodney Brown  <rbrown64@csc.com.au>\n\n\t* objc/encoding.h: Fix formatting.\n\t* objc/hash.h: Likewise.\n\t* objc/objc-api.h: Likewise.\n\t* objc/runtime.h: Likewise.\n\t* objc/thr.h: Likewise.\n\t* archive.c: Likewise.\n\t* class.c: Likewise.\n\t* encoding.c: Likewise.\n\t* gc.c: Likewise.\n\t* hash.c: Likewise.\n\t* init.c: Likewise.\n\t* misc.c: Likewise.\n\t* nil_method.c: Likewise.\n\t* objects.c: Likewise.\n\t* sarray.c: Likewise.\n\t* selector.c: Likewise.\n\t* sendmsg.c: Likewise.\n\t* thr-mach.c: Likewise.\n\t* thr.c: Likewise.\n\nFrom-SVN: r55190", "tree": {"sha": "8f207ea088d819aa3e3ed4230231f34c706b6e54", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8f207ea088d819aa3e3ed4230231f34c706b6e54"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/40165636b5fb904a609e01051c2ecfd52e5617e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40165636b5fb904a609e01051c2ecfd52e5617e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/40165636b5fb904a609e01051c2ecfd52e5617e3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40165636b5fb904a609e01051c2ecfd52e5617e3/comments", "author": null, "committer": null, "parents": [{"sha": "52702ae16eb80dc1f6f68af8ededb3dcdee6d6a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52702ae16eb80dc1f6f68af8ededb3dcdee6d6a3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52702ae16eb80dc1f6f68af8ededb3dcdee6d6a3"}], "stats": {"total": 2688, "additions": 1374, "deletions": 1314}, "files": [{"sha": "db5a9386dfe97ff4ec54ce25984fb06b32852a1d", "filename": "libobjc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40165636b5fb904a609e01051c2ecfd52e5617e3/libobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40165636b5fb904a609e01051c2ecfd52e5617e3/libobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2FChangeLog?ref=40165636b5fb904a609e01051c2ecfd52e5617e3", "patch": "@@ -1,3 +1,25 @@\n+2002-07-02  Rodney Brown  <rbrown64@csc.com.au>\n+\n+\t* objc/encoding.h: Fix formatting.\n+\t* objc/hash.h: Likewise.\n+\t* objc/objc-api.h: Likewise.\n+\t* objc/runtime.h: Likewise.\n+\t* objc/thr.h: Likewise.\n+\t* archive.c: Likewise.\n+\t* class.c: Likewise.\n+\t* encoding.c: Likewise.\n+\t* gc.c: Likewise.\n+\t* hash.c: Likewise.\n+\t* init.c: Likewise.\n+\t* misc.c: Likewise.\n+\t* nil_method.c: Likewise.\n+\t* objects.c: Likewise.\n+\t* sarray.c: Likewise.\n+\t* selector.c: Likewise.\n+\t* sendmsg.c: Likewise.\n+\t* thr-mach.c: Likewise.\n+\t* thr.c: Likewise.\n+\n 2002-06-25  DJ Delorie  <dj@redhat.com>\n \n \t* aclocal.m4 (GLIBCPP_CONFIGURE): Split out"}, {"sha": "f98379bc99dbb7d26dba4e577edbf13b7eb45f2e", "filename": "libobjc/archive.c", "status": "modified", "additions": 341, "deletions": 340, "changes": 681, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40165636b5fb904a609e01051c2ecfd52e5617e3/libobjc%2Farchive.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40165636b5fb904a609e01051c2ecfd52e5617e3/libobjc%2Farchive.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Farchive.c?ref=40165636b5fb904a609e01051c2ecfd52e5617e3", "patch": "@@ -1,5 +1,5 @@\n-/* GNU Objective C Runtime archiving\n-   Copyright (C) 1993, 1995, 1996, 1997 Free Software Foundation, Inc.\n+ /* GNU Objective C Runtime archiving\n+   Copyright (C) 1993, 1995, 1996, 1997, 2002 Free Software Foundation, Inc.\n    Contributed by Kresten Krab Thorup\n \n This file is part of GNU CC.\n@@ -30,40 +30,40 @@ Boston, MA 02111-1307, USA.  */\n #include \"encoding.h\"\n #include <stdlib.h>\n \n-extern int fflush(FILE*);\n+extern int fflush (FILE *);\n \n #define ROUND(V, A) \\\n-  ({ typeof(V) __v=(V); typeof(A) __a=(A);  \\\n-     __a*((__v+__a-1)/__a); })\n+  ({ typeof (V) __v = (V); typeof (A) __a = (A);  \\\n+     __a * ((__v + __a - 1)/__a); })\n \n-#define PTR2LONG(P) (((char*)(P))-(char*)0)\n-#define LONG2PTR(L) (((char*)0)+(L))\n+#define PTR2LONG(P) (((char *) (P))-(char *) 0)\n+#define LONG2PTR(L) (((char *) 0) + (L))\n \n /* Declare some functions... */\n \n static int\n-objc_read_class (struct objc_typed_stream* stream, Class* class);\n+objc_read_class (struct objc_typed_stream *stream, Class *class);\n \n-int objc_sizeof_type(const char* type);\n+int objc_sizeof_type (const char *type);\n \n static int\n-objc_write_use_common (struct objc_typed_stream* stream, unsigned long key);\n+objc_write_use_common (struct objc_typed_stream *stream, unsigned long key);\n \n static int\n-objc_write_register_common (struct objc_typed_stream* stream,\n+objc_write_register_common (struct objc_typed_stream *stream,\n \t\t\t    unsigned long key);\n \n static int \n-objc_write_class (struct objc_typed_stream* stream,\n-\t\t\t struct objc_class* class);\n+objc_write_class (struct objc_typed_stream *stream,\n+\t\t\t struct objc_class *class);\n \n-const char* objc_skip_type (const char* type);\n+const char *objc_skip_type (const char *type);\n \n-static void __objc_finish_write_root_object(struct objc_typed_stream*);\n-static void __objc_finish_read_root_object(struct objc_typed_stream*);\n+static void __objc_finish_write_root_object (struct objc_typed_stream *);\n+static void __objc_finish_read_root_object (struct objc_typed_stream *);\n \n static __inline__ int\n-__objc_code_unsigned_char (unsigned char* buf, unsigned char val)\n+__objc_code_unsigned_char (unsigned char *buf, unsigned char val)\n {\n   if ((val&_B_VALUE) == val)\n     {\n@@ -79,16 +79,16 @@ __objc_code_unsigned_char (unsigned char* buf, unsigned char val)\n }\n \n int\n-objc_write_unsigned_char (struct objc_typed_stream* stream,\n+objc_write_unsigned_char (struct objc_typed_stream *stream,\n \t\t\t  unsigned char value)\n {\n-  unsigned char buf[sizeof (unsigned char)+1];\n+  unsigned char buf[sizeof (unsigned char) + 1];\n   int len = __objc_code_unsigned_char (buf, value);\n-  return (*stream->write)(stream->physical, buf, len);\n+  return (*stream->write) (stream->physical, buf, len);\n }\n \n static __inline__ int\n-__objc_code_char (unsigned char* buf, signed char val)\n+__objc_code_char (unsigned char *buf, signed char val)\n {\n   if (val >= 0)\n     return __objc_code_unsigned_char (buf, val);\n@@ -101,15 +101,15 @@ __objc_code_char (unsigned char* buf, signed char val)\n }\n \n int\n-objc_write_char (struct objc_typed_stream* stream, signed char value)\n+objc_write_char (struct objc_typed_stream *stream, signed char value)\n {\n-  unsigned char buf[sizeof (char)+1];\n+  unsigned char buf[sizeof (char) + 1];\n   int len = __objc_code_char (buf, value);\n-  return (*stream->write)(stream->physical, buf, len);\n+  return (*stream->write) (stream->physical, buf, len);\n }\n \n static __inline__ int\n-__objc_code_unsigned_short (unsigned char* buf, unsigned short val)\n+__objc_code_unsigned_short (unsigned char *buf, unsigned short val)\n {\n   if ((val&_B_VALUE) == val)\n     {\n@@ -122,32 +122,32 @@ __objc_code_unsigned_short (unsigned char* buf, unsigned short val)\n \n       buf[0] = _B_NINT;\n \n-      for (c= sizeof(short); c != 0; c -= 1)\n-\tif (((val>>(8*(c-1)))%0x100) != 0)\n+      for (c = sizeof (short); c != 0; c -= 1)\n+\tif (((val >> (8*(c - 1)))%0x100) != 0)\n \t  break;\n \n       buf[0] |= c;\n \n       for (b = 1; c != 0; c--, b++)\n \t{\n-\t  buf[b] = (val >> (8*(c-1)))%0x100;\n+\t  buf[b] = (val >> (8*(c - 1)))%0x100;\n \t}\n \n       return b;\n     }\n }\n \n int\n-objc_write_unsigned_short (struct objc_typed_stream* stream, \n+objc_write_unsigned_short (struct objc_typed_stream *stream, \n \t\t\t   unsigned short value)\n {\n-  unsigned char buf[sizeof (unsigned short)+1];\n+  unsigned char buf[sizeof (unsigned short) + 1];\n   int len = __objc_code_unsigned_short (buf, value);\n-  return (*stream->write)(stream->physical, buf, len);\n+  return (*stream->write) (stream->physical, buf, len);\n }\n       \n static __inline__ int\n-__objc_code_short (unsigned char* buf, short val)\n+__objc_code_short (unsigned char *buf, short val)\n {\n   int sign = (val < 0);\n   int size = __objc_code_unsigned_short (buf, sign ? -val : val);\n@@ -157,16 +157,16 @@ __objc_code_short (unsigned char* buf, short val)\n }\n \n int\n-objc_write_short (struct objc_typed_stream* stream, short value)\n+objc_write_short (struct objc_typed_stream *stream, short value)\n {\n-  unsigned char buf[sizeof (short)+1];\n+  unsigned char buf[sizeof (short) + 1];\n   int len = __objc_code_short (buf, value);\n-  return (*stream->write)(stream->physical, buf, len);\n+  return (*stream->write) (stream->physical, buf, len);\n }\n       \n \n static __inline__ int\n-__objc_code_unsigned_int (unsigned char* buf, unsigned int val)\n+__objc_code_unsigned_int (unsigned char *buf, unsigned int val)\n {\n   if ((val&_B_VALUE) == val)\n     {\n@@ -179,8 +179,8 @@ __objc_code_unsigned_int (unsigned char* buf, unsigned int val)\n \n       buf[0] = _B_NINT;\n \n-      for (c= sizeof(int); c != 0; c -= 1)\n-\tif (((val>>(8*(c-1)))%0x100) != 0)\n+      for (c = sizeof (int); c != 0; c -= 1)\n+\tif (((val >> (8*(c - 1)))%0x100) != 0)\n \t  break;\n \n       buf[0] |= c;\n@@ -195,15 +195,15 @@ __objc_code_unsigned_int (unsigned char* buf, unsigned int val)\n }\n \n int\n-objc_write_unsigned_int (struct objc_typed_stream* stream, unsigned int value)\n+objc_write_unsigned_int (struct objc_typed_stream *stream, unsigned int value)\n {\n-  unsigned char buf[sizeof(unsigned int)+1];\n+  unsigned char buf[sizeof (unsigned int) + 1];\n   int len = __objc_code_unsigned_int (buf, value);\n-  return (*stream->write)(stream->physical, buf, len);\n+  return (*stream->write) (stream->physical, buf, len);\n }\n \n static __inline__ int\n-__objc_code_int (unsigned char* buf, int val)\n+__objc_code_int (unsigned char *buf, int val)\n {\n   int sign = (val < 0);\n   int size = __objc_code_unsigned_int (buf, sign ? -val : val);\n@@ -213,15 +213,15 @@ __objc_code_int (unsigned char* buf, int val)\n }\n \n int\n-objc_write_int (struct objc_typed_stream* stream, int value)\n+objc_write_int (struct objc_typed_stream *stream, int value)\n {\n-  unsigned char buf[sizeof(int)+1];\n+  unsigned char buf[sizeof (int) + 1];\n   int len = __objc_code_int (buf, value);\n-  return (*stream->write)(stream->physical, buf, len);\n+  return (*stream->write) (stream->physical, buf, len);\n }\n \n static __inline__ int\n-__objc_code_unsigned_long (unsigned char* buf, unsigned long val)\n+__objc_code_unsigned_long (unsigned char *buf, unsigned long val)\n {\n   if ((val&_B_VALUE) == val)\n     {\n@@ -234,32 +234,32 @@ __objc_code_unsigned_long (unsigned char* buf, unsigned long val)\n \n       buf[0] = _B_NINT;\n \n-      for (c= sizeof(long); c != 0; c -= 1)\n-\tif (((val>>(8*(c-1)))%0x100) != 0)\n+      for (c = sizeof (long); c != 0; c -= 1)\n+\tif (((val >> (8*(c - 1)))%0x100) != 0)\n \t  break;\n \n       buf[0] |= c;\n \n       for (b = 1; c != 0; c--, b++)\n \t{\n-\t  buf[b] = (val >> (8*(c-1)))%0x100;\n+\t  buf[b] = (val >> (8*(c - 1)))%0x100;\n \t}\n \n       return b;\n     }\n }\n \n int\n-objc_write_unsigned_long (struct objc_typed_stream* stream, \n+objc_write_unsigned_long (struct objc_typed_stream *stream, \n \t\t\t  unsigned long value)\n {\n-  unsigned char buf[sizeof(unsigned long)+1];\n+  unsigned char buf[sizeof (unsigned long) + 1];\n   int len = __objc_code_unsigned_long (buf, value);\n-  return (*stream->write)(stream->physical, buf, len);\n+  return (*stream->write) (stream->physical, buf, len);\n }\n \n static __inline__ int\n-__objc_code_long (unsigned char* buf, long val)\n+__objc_code_long (unsigned char *buf, long val)\n {\n   int sign = (val < 0);\n   int size = __objc_code_unsigned_long (buf, sign ? -val : val);\n@@ -269,19 +269,19 @@ __objc_code_long (unsigned char* buf, long val)\n }\n \n int\n-objc_write_long (struct objc_typed_stream* stream, long value)\n+objc_write_long (struct objc_typed_stream *stream, long value)\n {\n-  unsigned char buf[sizeof(long)+1];\n+  unsigned char buf[sizeof (long) + 1];\n   int len = __objc_code_long (buf, value);\n-  return (*stream->write)(stream->physical, buf, len);\n+  return (*stream->write) (stream->physical, buf, len);\n }\n \n \n int\n-objc_write_string (struct objc_typed_stream* stream,\n-\t\t   const unsigned char* string, unsigned int nbytes)\n+objc_write_string (struct objc_typed_stream *stream,\n+\t\t   const unsigned char *string, unsigned int nbytes)\n {\n-  unsigned char buf[sizeof(unsigned int)+1];\n+  unsigned char buf[sizeof (unsigned int) + 1];\n   int len = __objc_code_unsigned_int (buf, nbytes);\n   \n   if ((buf[0]&_B_CODE) == _B_SINT)\n@@ -290,15 +290,15 @@ objc_write_string (struct objc_typed_stream* stream,\n   else /* _B_NINT */\n     buf[0] = (buf[0]&_B_VALUE)|_B_NSTR;\n \n-  if ((*stream->write)(stream->physical, buf, len) != 0)\n-    return (*stream->write)(stream->physical, string, nbytes);\n+  if ((*stream->write) (stream->physical, buf, len) != 0)\n+    return (*stream->write) (stream->physical, string, nbytes);\n   else\n     return 0;\n }\n \n int\n-objc_write_string_atomic (struct objc_typed_stream* stream,\n-\t\t\t  unsigned char* string, unsigned int nbytes)\n+objc_write_string_atomic (struct objc_typed_stream *stream,\n+\t\t\t  unsigned char *string, unsigned int nbytes)\n {\n   unsigned long key;\n   if ((key = PTR2LONG(hash_value_for_key (stream->stream_table, string))))\n@@ -314,76 +314,76 @@ objc_write_string_atomic (struct objc_typed_stream* stream,\n }\n \n static int\n-objc_write_register_common (struct objc_typed_stream* stream, \n+objc_write_register_common (struct objc_typed_stream *stream, \n \t\t\t    unsigned long key)\n {\n   unsigned char buf[sizeof (unsigned long)+2];\n-  int len = __objc_code_unsigned_long (buf+1, key);\n+  int len = __objc_code_unsigned_long (buf + 1, key);\n   if (len == 1)\n     {\n       buf[0] = _B_RCOMM|0x01;\n       buf[1] &= _B_VALUE;\n-      return (*stream->write)(stream->physical, buf, len+1);\n+      return (*stream->write) (stream->physical, buf, len + 1);\n     }\n   else\n     {\n       buf[1] = (buf[1]&_B_VALUE)|_B_RCOMM;\n-      return (*stream->write)(stream->physical, buf+1, len);\n+      return (*stream->write) (stream->physical, buf + 1, len);\n     }\n }\n \n static int\n-objc_write_use_common (struct objc_typed_stream* stream, unsigned long key)\n+objc_write_use_common (struct objc_typed_stream *stream, unsigned long key)\n {\n   unsigned char buf[sizeof (unsigned long)+2];\n-  int len = __objc_code_unsigned_long (buf+1, key);\n+  int len = __objc_code_unsigned_long (buf + 1, key);\n   if (len == 1)\n     {\n       buf[0] = _B_UCOMM|0x01;\n       buf[1] &= _B_VALUE;\n-      return (*stream->write)(stream->physical, buf, 2);\n+      return (*stream->write) (stream->physical, buf, 2);\n     }\n   else\n     {\n       buf[1] = (buf[1]&_B_VALUE)|_B_UCOMM;\n-      return (*stream->write)(stream->physical, buf+1, len);\n+      return (*stream->write) (stream->physical, buf + 1, len);\n     }\n }\n \n static __inline__ int\n-__objc_write_extension (struct objc_typed_stream* stream, unsigned char code)\n+__objc_write_extension (struct objc_typed_stream *stream, unsigned char code)\n {\n   if (code <= _B_VALUE)\n     {\n       unsigned char buf = code|_B_EXT;\n-      return (*stream->write)(stream->physical, &buf, 1);\n+      return (*stream->write) (stream->physical, &buf, 1);\n     }\n   else \n     {\n-      objc_error(nil, OBJC_ERR_BAD_OPCODE,\n-\t\t \"__objc_write_extension: bad opcode %c\\n\", code);\n+      objc_error (nil, OBJC_ERR_BAD_OPCODE,\n+\t\t  \"__objc_write_extension: bad opcode %c\\n\", code);\n       return -1;\n     }\n }\n \n __inline__ int\n-__objc_write_object (struct objc_typed_stream* stream, id object)\n+__objc_write_object (struct objc_typed_stream *stream, id object)\n {\n   unsigned char buf = '\\0';\n   SEL write_sel = sel_get_any_uid (\"write:\");\n   if (object)\n     {\n       __objc_write_extension (stream, _BX_OBJECT);\n       objc_write_class (stream, object->class_pointer);\n-      (*objc_msg_lookup(object, write_sel))(object, write_sel, stream);\n-      return (*stream->write)(stream->physical, &buf, 1);\n+      (*objc_msg_lookup (object, write_sel)) (object, write_sel, stream);\n+      return (*stream->write) (stream->physical, &buf, 1);\n     }\n   else\n-    return objc_write_use_common(stream, 0);\n+    return objc_write_use_common (stream, 0);\n }\n \n int \n-objc_write_object_reference (struct objc_typed_stream* stream, id object)\n+objc_write_object_reference (struct objc_typed_stream *stream, id object)\n {\n   unsigned long key;\n   if ((key = PTR2LONG(hash_value_for_key (stream->object_table, object))))\n@@ -394,7 +394,7 @@ objc_write_object_reference (struct objc_typed_stream* stream, id object)\n }\n \n int \n-objc_write_root_object (struct objc_typed_stream* stream, id object)\n+objc_write_root_object (struct objc_typed_stream *stream, id object)\n {\n   int len = 0;\n   if (stream->writing_root_p)\n@@ -404,22 +404,22 @@ objc_write_root_object (struct objc_typed_stream* stream, id object)\n     {\n       stream->writing_root_p = 1;\n       __objc_write_extension (stream, _BX_OBJROOT);\n-      if((len = objc_write_object (stream, object)))\n-\t__objc_finish_write_root_object(stream);\n+      if ((len = objc_write_object (stream, object)))\n+\t__objc_finish_write_root_object (stream);\n       stream->writing_root_p = 0;\n     }\n   return len;\n }\n \n int \n-objc_write_object (struct objc_typed_stream* stream, id object)\n+objc_write_object (struct objc_typed_stream *stream, id object)\n {\n   unsigned long key;\n   if ((key = PTR2LONG(hash_value_for_key (stream->object_table, object))))\n     return objc_write_use_common (stream, key);\n \n   else if (object == nil)\n-    return objc_write_use_common(stream, 0);\n+    return objc_write_use_common (stream, 0);\n \n   else\n     {\n@@ -432,26 +432,26 @@ objc_write_object (struct objc_typed_stream* stream, id object)\n }\n \n __inline__ int\n-__objc_write_class (struct objc_typed_stream* stream, struct objc_class* class)\n+__objc_write_class (struct objc_typed_stream *stream, struct objc_class *class)\n {\n   __objc_write_extension (stream, _BX_CLASS);\n-  objc_write_string_atomic(stream, (char*)class->name,\n-\t\t\t   strlen((char*)class->name));\n+  objc_write_string_atomic (stream, (char *) class->name,\n+\t\t\t   strlen ((char *) class->name));\n   return objc_write_unsigned_long (stream, class->version);\n }\n \n \n static int \n-objc_write_class (struct objc_typed_stream* stream,\n-\t\t\t struct objc_class* class)\n+objc_write_class (struct objc_typed_stream *stream,\n+\t\t\t struct objc_class *class)\n {\n   unsigned long key;\n   if ((key = PTR2LONG(hash_value_for_key (stream->stream_table, class))))\n     return objc_write_use_common (stream, key);\n   else\n     {\n       int length;\n-      hash_add (&stream->stream_table, LONG2PTR(key=PTR2LONG(class)), class);\n+      hash_add (&stream->stream_table, LONG2PTR(key = PTR2LONG(class)), class);\n       if ((length = objc_write_register_common (stream, key)))\n \treturn __objc_write_class (stream, class);\n       return length;\n@@ -460,9 +460,9 @@ objc_write_class (struct objc_typed_stream* stream,\n \n \n __inline__ int \n-__objc_write_selector (struct objc_typed_stream* stream, SEL selector)\n+__objc_write_selector (struct objc_typed_stream *stream, SEL selector)\n {\n-  const char* sel_name;\n+  const char *sel_name;\n   __objc_write_extension (stream, _BX_SEL);\n   /* to handle NULL selectors */\n   if ((SEL)0 == selector)\n@@ -472,9 +472,9 @@ __objc_write_selector (struct objc_typed_stream* stream, SEL selector)\n }\n \n int \n-objc_write_selector (struct objc_typed_stream* stream, SEL selector)\n+objc_write_selector (struct objc_typed_stream *stream, SEL selector)\n {\n-  const char* sel_name;\n+  const char *sel_name;\n   unsigned long key;\n \n   /* to handle NULL selectors */\n@@ -488,7 +488,7 @@ objc_write_selector (struct objc_typed_stream* stream, SEL selector)\n     {\n       int length;\n       hash_add (&stream->stream_table, \n-\t\tLONG2PTR(key=PTR2LONG(sel_name)), (char*)sel_name);\n+\t\tLONG2PTR(key = PTR2LONG(sel_name)), (char *) sel_name);\n       if ((length = objc_write_register_common (stream, key)))\n \treturn __objc_write_selector (stream, selector);\n       return length;\n@@ -502,59 +502,59 @@ objc_write_selector (struct objc_typed_stream* stream, SEL selector)\n */\n \n __inline__ int\n-objc_read_char (struct objc_typed_stream* stream, char* val)\n+objc_read_char (struct objc_typed_stream *stream, char *val)\n {\n   unsigned char buf;\n   int len;\n-  len = (*stream->read)(stream->physical, &buf, 1);\n+  len = (*stream->read) (stream->physical, &buf, 1);\n   if (len != 0)\n     {\n       if ((buf & _B_CODE) == _B_SINT)\n \t(*val) = (buf & _B_VALUE);\n \n       else if ((buf & _B_NUMBER) == 1)\n \t{\n-\t  len = (*stream->read)(stream->physical, val, 1);\n+\t  len = (*stream->read) (stream->physical, val, 1);\n \t  if (buf&_B_SIGN)\n-\t    (*val) = -1*(*val);\n+\t    (*val) = -1 * (*val);\n \t}\n \n       else\n-\tobjc_error(nil, OBJC_ERR_BAD_DATA,\n-\t\t   \"expected 8bit signed int, got %dbit int\",\n-\t\t   (int)(buf&_B_NUMBER)*8);\n+\tobjc_error (nil, OBJC_ERR_BAD_DATA,\n+\t\t    \"expected 8bit signed int, got %dbit int\",\n+\t\t    (int) (buf&_B_NUMBER)*8);\n     }\n   return len;\n }\n \n \n __inline__ int\n-objc_read_unsigned_char (struct objc_typed_stream* stream, unsigned char* val)\n+objc_read_unsigned_char (struct objc_typed_stream *stream, unsigned char *val)\n {\n   unsigned char buf;\n   int len;\n-  if ((len = (*stream->read)(stream->physical, &buf, 1)))\n+  if ((len = (*stream->read) (stream->physical, &buf, 1)))\n     {\n       if ((buf & _B_CODE) == _B_SINT)\n \t(*val) = (buf & _B_VALUE);\n \n       else if ((buf & _B_NUMBER) == 1)\n-\tlen = (*stream->read)(stream->physical, val, 1);\n+\tlen = (*stream->read) (stream->physical, val, 1);\n \n       else\n-\tobjc_error(nil, OBJC_ERR_BAD_DATA,\n-\t\t   \"expected 8bit unsigned int, got %dbit int\",\n-\t\t   (int)(buf&_B_NUMBER)*8);\n+\tobjc_error (nil, OBJC_ERR_BAD_DATA,\n+\t\t    \"expected 8bit unsigned int, got %dbit int\",\n+\t\t    (int) (buf&_B_NUMBER)*8);\n     }\n   return len;\n }\n \n __inline__ int\n-objc_read_short (struct objc_typed_stream* stream, short* value)\n+objc_read_short (struct objc_typed_stream *stream, short *value)\n {\n-  unsigned char buf[sizeof(short)+1];\n+  unsigned char buf[sizeof (short) + 1];\n   int len;\n-  if ((len = (*stream->read)(stream->physical, buf, 1)))\n+  if ((len = (*stream->read) (stream->physical, buf, 1)))\n     {\n       if ((buf[0] & _B_CODE) == _B_SINT)\n \t(*value) = (buf[0] & _B_VALUE);\n@@ -564,9 +564,9 @@ objc_read_short (struct objc_typed_stream* stream, short* value)\n \t  int pos = 1;\n \t  int nbytes = buf[0] & _B_NUMBER;\n \t  if (nbytes > (int) sizeof (short))\n-\t    objc_error(nil, OBJC_ERR_BAD_DATA,\n-\t\t       \"expected short, got bigger (%dbits)\", nbytes*8);\n-\t  len = (*stream->read)(stream->physical, buf+1, nbytes);\n+\t    objc_error (nil, OBJC_ERR_BAD_DATA,\n+\t\t        \"expected short, got bigger (%dbits)\", nbytes*8);\n+\t  len = (*stream->read) (stream->physical, buf + 1, nbytes);\n \t  (*value) = 0;\n \t  while (pos <= nbytes)\n \t    (*value) = ((*value)*0x100) + buf[pos++];\n@@ -578,12 +578,12 @@ objc_read_short (struct objc_typed_stream* stream, short* value)\n }\n \n __inline__ int\n-objc_read_unsigned_short (struct objc_typed_stream* stream,\n-\t\t\t  unsigned short* value)\n+objc_read_unsigned_short (struct objc_typed_stream *stream,\n+\t\t\t  unsigned short *value)\n {\n-  unsigned char buf[sizeof(unsigned short)+1];\n+  unsigned char buf[sizeof (unsigned short) + 1];\n   int len;\n-  if ((len = (*stream->read)(stream->physical, buf, 1)))\n+  if ((len = (*stream->read) (stream->physical, buf, 1)))\n     {\n       if ((buf[0] & _B_CODE) == _B_SINT)\n \t(*value) = (buf[0] & _B_VALUE);\n@@ -593,9 +593,9 @@ objc_read_unsigned_short (struct objc_typed_stream* stream,\n \t  int pos = 1;\n \t  int nbytes = buf[0] & _B_NUMBER;\n \t  if (nbytes > (int) sizeof (short))\n-\t    objc_error(nil, OBJC_ERR_BAD_DATA,\n-\t\t       \"expected short, got int or bigger\");\n-\t  len = (*stream->read)(stream->physical, buf+1, nbytes);\n+\t    objc_error (nil, OBJC_ERR_BAD_DATA,\n+\t\t        \"expected short, got int or bigger\");\n+\t  len = (*stream->read) (stream->physical, buf + 1, nbytes);\n \t  (*value) = 0;\n \t  while (pos <= nbytes)\n \t    (*value) = ((*value)*0x100) + buf[pos++];\n@@ -606,11 +606,11 @@ objc_read_unsigned_short (struct objc_typed_stream* stream,\n \n \n __inline__ int\n-objc_read_int (struct objc_typed_stream* stream, int* value)\n+objc_read_int (struct objc_typed_stream *stream, int *value)\n {\n-  unsigned char buf[sizeof(int)+1];\n+  unsigned char buf[sizeof (int) + 1];\n   int len;\n-  if ((len = (*stream->read)(stream->physical, buf, 1)))\n+  if ((len = (*stream->read) (stream->physical, buf, 1)))\n     {\n       if ((buf[0] & _B_CODE) == _B_SINT)\n \t(*value) = (buf[0] & _B_VALUE);\n@@ -620,8 +620,8 @@ objc_read_int (struct objc_typed_stream* stream, int* value)\n \t  int pos = 1;\n \t  int nbytes = buf[0] & _B_NUMBER;\n \t  if (nbytes > (int) sizeof (int))\n-\t    objc_error(nil, OBJC_ERR_BAD_DATA, \"expected int, got bigger\");\n-\t  len = (*stream->read)(stream->physical, buf+1, nbytes);\n+\t    objc_error (nil, OBJC_ERR_BAD_DATA, \"expected int, got bigger\");\n+\t  len = (*stream->read) (stream->physical, buf + 1, nbytes);\n \t  (*value) = 0;\n \t  while (pos <= nbytes)\n \t    (*value) = ((*value)*0x100) + buf[pos++];\n@@ -633,11 +633,11 @@ objc_read_int (struct objc_typed_stream* stream, int* value)\n }\n \n __inline__ int\n-objc_read_long (struct objc_typed_stream* stream, long* value)\n+objc_read_long (struct objc_typed_stream *stream, long *value)\n {\n-  unsigned char buf[sizeof(long)+1];\n+  unsigned char buf[sizeof (long) + 1];\n   int len;\n-  if ((len = (*stream->read)(stream->physical, buf, 1)))\n+  if ((len = (*stream->read) (stream->physical, buf, 1)))\n     {\n       if ((buf[0] & _B_CODE) == _B_SINT)\n \t(*value) = (buf[0] & _B_VALUE);\n@@ -647,8 +647,8 @@ objc_read_long (struct objc_typed_stream* stream, long* value)\n \t  int pos = 1;\n \t  int nbytes = buf[0] & _B_NUMBER;\n \t  if (nbytes > (int) sizeof (long))\n-\t    objc_error(nil, OBJC_ERR_BAD_DATA, \"expected long, got bigger\");\n-\t  len = (*stream->read)(stream->physical, buf+1, nbytes);\n+\t    objc_error (nil, OBJC_ERR_BAD_DATA, \"expected long, got bigger\");\n+\t  len = (*stream->read) (stream->physical, buf + 1, nbytes);\n \t  (*value) = 0;\n \t  while (pos <= nbytes)\n \t    (*value) = ((*value)*0x100) + buf[pos++];\n@@ -660,17 +660,17 @@ objc_read_long (struct objc_typed_stream* stream, long* value)\n }\n \n __inline__ int\n-__objc_read_nbyte_uint (struct objc_typed_stream* stream,\n-\t\t       unsigned int nbytes, unsigned int* val)\n+__objc_read_nbyte_uint (struct objc_typed_stream *stream,\n+\t\t\tunsigned int nbytes, unsigned int *val)\n {\n   int len;\n   unsigned int pos = 0;\n-  unsigned char buf[sizeof(unsigned int)+1];\n+  unsigned char buf[sizeof (unsigned int) + 1];\n \n   if (nbytes > sizeof (int))\n-    objc_error(nil, OBJC_ERR_BAD_DATA, \"expected int, got bigger\");\n+    objc_error (nil, OBJC_ERR_BAD_DATA, \"expected int, got bigger\");\n \n-  len = (*stream->read)(stream->physical, buf, nbytes);\n+  len = (*stream->read) (stream->physical, buf, nbytes);\n   (*val) = 0;\n   while (pos < nbytes)\n     (*val) = ((*val)*0x100) + buf[pos++];\n@@ -679,12 +679,12 @@ __objc_read_nbyte_uint (struct objc_typed_stream* stream,\n   \n \n __inline__ int\n-objc_read_unsigned_int (struct objc_typed_stream* stream,\n-\t\t\tunsigned int* value)\n+objc_read_unsigned_int (struct objc_typed_stream *stream,\n+\t\t\tunsigned int *value)\n {\n-  unsigned char buf[sizeof(unsigned int)+1];\n+  unsigned char buf[sizeof (unsigned int) + 1];\n   int len;\n-  if ((len = (*stream->read)(stream->physical, buf, 1)))\n+  if ((len = (*stream->read) (stream->physical, buf, 1)))\n     {\n       if ((buf[0] & _B_CODE) == _B_SINT)\n \t(*value) = (buf[0] & _B_VALUE);\n@@ -697,17 +697,17 @@ objc_read_unsigned_int (struct objc_typed_stream* stream,\n }\n \n int\n-__objc_read_nbyte_ulong (struct objc_typed_stream* stream,\n-\t\t       unsigned int nbytes, unsigned long* val)\n+__objc_read_nbyte_ulong (struct objc_typed_stream *stream,\n+\t\t       unsigned int nbytes, unsigned long *val)\n {\n   int len;\n   unsigned int pos = 0;\n-  unsigned char buf[sizeof(unsigned long)+1];\n+  unsigned char buf[sizeof (unsigned long) + 1];\n \n   if (nbytes > sizeof (long))\n-    objc_error(nil, OBJC_ERR_BAD_DATA, \"expected long, got bigger\");\n+    objc_error (nil, OBJC_ERR_BAD_DATA, \"expected long, got bigger\");\n \n-  len = (*stream->read)(stream->physical, buf, nbytes);\n+  len = (*stream->read) (stream->physical, buf, nbytes);\n   (*val) = 0;\n   while (pos < nbytes)\n     (*val) = ((*val)*0x100) + buf[pos++];\n@@ -716,12 +716,12 @@ __objc_read_nbyte_ulong (struct objc_typed_stream* stream,\n   \n \n __inline__ int\n-objc_read_unsigned_long (struct objc_typed_stream* stream,\n-\t\t\tunsigned long* value)\n+objc_read_unsigned_long (struct objc_typed_stream *stream,\n+\t\t\t unsigned long *value)\n {\n-  unsigned char buf[sizeof(unsigned long)+1];\n+  unsigned char buf[sizeof (unsigned long) + 1];\n   int len;\n-  if ((len = (*stream->read)(stream->physical, buf, 1)))\n+  if ((len = (*stream->read) (stream->physical, buf, 1)))\n     {\n       if ((buf[0] & _B_CODE) == _B_SINT)\n \t(*value) = (buf[0] & _B_VALUE);\n@@ -734,60 +734,60 @@ objc_read_unsigned_long (struct objc_typed_stream* stream,\n }\n \n __inline__ int\n-objc_read_string (struct objc_typed_stream* stream,\n-\t\t  char** string)\n+objc_read_string (struct objc_typed_stream *stream,\n+\t\t  char **string)\n {\n-  unsigned char buf[sizeof(unsigned int)+1];\n+  unsigned char buf[sizeof (unsigned int) + 1];\n   int len;\n-  if ((len = (*stream->read)(stream->physical, buf, 1)))\n+  if ((len = (*stream->read) (stream->physical, buf, 1)))\n     {\n       unsigned long key = 0;\n \n       if ((buf[0]&_B_CODE) == _B_RCOMM)\t/* register following */\n \t{\n-\t  len = __objc_read_nbyte_ulong(stream, (buf[0] & _B_VALUE), &key);\n-\t  len = (*stream->read)(stream->physical, buf, 1);\n+\t  len = __objc_read_nbyte_ulong (stream, (buf[0] & _B_VALUE), &key);\n+\t  len = (*stream->read) (stream->physical, buf, 1);\n \t}\n \n       switch (buf[0]&_B_CODE) {\n       case _B_SSTR:\n \t{\n \t  int length = buf[0]&_B_VALUE;\n-\t  (*string) = (char*)objc_malloc(length+1);\n+\t  (*string) = (char*)objc_malloc (length + 1);\n \t  if (key)\n \t    hash_add (&stream->stream_table, LONG2PTR(key), *string);\n-\t  len = (*stream->read)(stream->physical, *string, length);\n+\t  len = (*stream->read) (stream->physical, *string, length);\n \t  (*string)[length] = '\\0';\n \t}\n \tbreak;\n \n       case _B_UCOMM:\n \t{\n \t  char *tmp;\n-\t  len = __objc_read_nbyte_ulong(stream, (buf[0] & _B_VALUE), &key);\n+\t  len = __objc_read_nbyte_ulong (stream, (buf[0] & _B_VALUE), &key);\n \t  tmp = hash_value_for_key (stream->stream_table, LONG2PTR (key));\n-\t  *string = objc_malloc (strlen(tmp) + 1);\n+\t  *string = objc_malloc (strlen (tmp) + 1);\n \t  strcpy (*string, tmp);\n \t}\n \tbreak;\n \n       case _B_NSTR:\n \t{\n \t  unsigned int nbytes = buf[0]&_B_VALUE;\n-\t  len = __objc_read_nbyte_uint(stream, nbytes, &nbytes);\n+\t  len = __objc_read_nbyte_uint (stream, nbytes, &nbytes);\n \t  if (len) {\n-\t    (*string) = (char*)objc_malloc(nbytes+1);\n+\t    (*string) = (char*)objc_malloc (nbytes + 1);\n \t    if (key)\n \t      hash_add (&stream->stream_table, LONG2PTR(key), *string);\n-\t    len = (*stream->read)(stream->physical, *string, nbytes);\n+\t    len = (*stream->read) (stream->physical, *string, nbytes);\n \t    (*string)[nbytes] = '\\0';\n \t  }\n \t}\n \tbreak;\n \t\n       default:\n-\tobjc_error(nil, OBJC_ERR_BAD_DATA,\n-\t\t   \"expected string, got opcode %c\\n\", (buf[0]&_B_CODE));\n+\tobjc_error (nil, OBJC_ERR_BAD_DATA,\n+\t\t    \"expected string, got opcode %c\\n\", (buf[0]&_B_CODE));\n       }\n     }\n \n@@ -796,19 +796,19 @@ objc_read_string (struct objc_typed_stream* stream,\n \n \n int\n-objc_read_object (struct objc_typed_stream* stream, id* object)\n+objc_read_object (struct objc_typed_stream *stream, id *object)\n {\n   unsigned char buf[sizeof (unsigned int)];\n   int len;\n-  if ((len = (*stream->read)(stream->physical, buf, 1)))\n+  if ((len = (*stream->read) (stream->physical, buf, 1)))\n     {\n       SEL read_sel = sel_get_any_uid (\"read:\");\n       unsigned long key = 0;\n \n       if ((buf[0]&_B_CODE) == _B_RCOMM)\t/* register common */\n \t{\n-\t  len = __objc_read_nbyte_ulong(stream, (buf[0] & _B_VALUE), &key);\n-\t  len = (*stream->read)(stream->physical, buf, 1);\n+\t  len = __objc_read_nbyte_ulong (stream, (buf[0] & _B_VALUE), &key);\n+\t  len = (*stream->read) (stream->physical, buf, 1);\n \t}\n \n       if (buf[0] == (_B_EXT | _BX_OBJECT))\n@@ -819,156 +819,156 @@ objc_read_object (struct objc_typed_stream* stream, id* object)\n \t  len = objc_read_class (stream, &class);\n \n \t  /* create instance */\n-\t  (*object) = class_create_instance(class);\n+\t  (*object) = class_create_instance (class);\n \n \t  /* register? */\n \t  if (key)\n \t    hash_add (&stream->object_table, LONG2PTR(key), *object);\n \n \t  /* send -read: */\n \t  if (__objc_responds_to (*object, read_sel))\n-\t    (*get_imp(class, read_sel))(*object, read_sel, stream);\n+\t    (*get_imp (class, read_sel)) (*object, read_sel, stream);\n \n \t  /* check null-byte */\n-\t  len = (*stream->read)(stream->physical, buf, 1);\n+\t  len = (*stream->read) (stream->physical, buf, 1);\n \t  if (buf[0] != '\\0')\n-\t    objc_error(nil, OBJC_ERR_BAD_DATA,\n-\t\t       \"expected null-byte, got opcode %c\", buf[0]);\n+\t    objc_error (nil, OBJC_ERR_BAD_DATA,\n+\t\t        \"expected null-byte, got opcode %c\", buf[0]);\n \t}\n \n       else if ((buf[0]&_B_CODE) == _B_UCOMM)\n \t{\n \t  if (key)\n-\t    objc_error(nil, OBJC_ERR_BAD_KEY, \"cannot register use upcode...\");\n-\t  len = __objc_read_nbyte_ulong(stream, (buf[0] & _B_VALUE), &key);\n+\t    objc_error (nil, OBJC_ERR_BAD_KEY, \"cannot register use upcode...\");\n+\t  len = __objc_read_nbyte_ulong (stream, (buf[0] & _B_VALUE), &key);\n \t  (*object) = hash_value_for_key (stream->object_table, LONG2PTR(key));\n \t}\n \n       else if (buf[0] == (_B_EXT | _BX_OBJREF))\t/* a forward reference */\n \t{\n-\t  struct objc_list* other;\n+\t  struct objc_list *other;\n \t  len = objc_read_unsigned_long (stream, &key);\n-\t  other = (struct objc_list*)hash_value_for_key (stream->object_refs, \n-\t\t\t\t\t\t\t LONG2PTR(key));\n+\t  other = (struct objc_list *) hash_value_for_key (stream->object_refs, \n+\t\t\t\t\t\t\t   LONG2PTR(key));\n \t  hash_add (&stream->object_refs, LONG2PTR(key), \n-\t\t    (void*)list_cons(object, other));\n+\t\t    (void *)list_cons (object, other));\n \t}\n \n       else if (buf[0] == (_B_EXT | _BX_OBJROOT)) /* a root object */\n \t{\n \t  if (key)\n-\t    objc_error(nil, OBJC_ERR_BAD_KEY,\n-\t\t       \"cannot register root object...\");\n+\t    objc_error (nil, OBJC_ERR_BAD_KEY,\n+\t\t        \"cannot register root object...\");\n \t  len = objc_read_object (stream, object);\n \t  __objc_finish_read_root_object (stream);\n \t}\n \n       else\n-\tobjc_error(nil, OBJC_ERR_BAD_DATA,\n-\t\t   \"expected object, got opcode %c\", buf[0]);\n+\tobjc_error (nil, OBJC_ERR_BAD_DATA,\n+\t\t    \"expected object, got opcode %c\", buf[0]);\n     }\n   return len;\n }\n \n static int\n-objc_read_class (struct objc_typed_stream* stream, Class* class)\n+objc_read_class (struct objc_typed_stream *stream, Class *class)\n {\n   unsigned char buf[sizeof (unsigned int)];\n   int len;\n-  if ((len = (*stream->read)(stream->physical, buf, 1)))\n+  if ((len = (*stream->read) (stream->physical, buf, 1)))\n     {\n       unsigned long key = 0;\n \n       if ((buf[0]&_B_CODE) == _B_RCOMM)\t/* register following */\n \t{\n-\t  len = __objc_read_nbyte_ulong(stream, (buf[0] & _B_VALUE), &key);\n-\t  len = (*stream->read)(stream->physical, buf, 1);\n+\t  len = __objc_read_nbyte_ulong (stream, (buf[0] & _B_VALUE), &key);\n+\t  len = (*stream->read) (stream->physical, buf, 1);\n \t}\n \n       if (buf[0] == (_B_EXT | _BX_CLASS))\n \t{\n-\t  char* class_name;\n+\t  char *class_name;\n \t  unsigned long version;\n \n \t  /* get class */\n \t  len = objc_read_string (stream, &class_name);\n-\t  (*class) = objc_get_class(class_name);\n-\t  objc_free(class_name);\n+\t  (*class) = objc_get_class (class_name);\n+\t  objc_free (class_name);\n \n \t  /* register */\n \t  if (key)\n \t    hash_add (&stream->stream_table, LONG2PTR(key), *class);\n \n-\t  objc_read_unsigned_long(stream, &version);\n-\t  hash_add (&stream->class_table, (*class)->name, (void*)version);\n+\t  objc_read_unsigned_long (stream, &version);\n+\t  hash_add (&stream->class_table, (*class)->name, (void *)version);\n \t}\n \n       else if ((buf[0]&_B_CODE) == _B_UCOMM)\n \t{\n \t  if (key)\n-\t    objc_error(nil, OBJC_ERR_BAD_KEY, \"cannot register use upcode...\");\n-\t  len = __objc_read_nbyte_ulong(stream, (buf[0] & _B_VALUE), &key);\n-\t  (*class) = hash_value_for_key (stream->stream_table, LONG2PTR(key));\n-\t  if (!*class)\n-\t    objc_error(nil, OBJC_ERR_BAD_CLASS,\n-\t\t       \"cannot find class for key %lu\", key);\n+\t    objc_error (nil, OBJC_ERR_BAD_KEY, \"cannot register use upcode...\");\n+\t  len = __objc_read_nbyte_ulong (stream, (buf[0] & _B_VALUE), &key);\n+\t  *class = hash_value_for_key (stream->stream_table, LONG2PTR(key));\n+\t  if (! *class)\n+\t    objc_error (nil, OBJC_ERR_BAD_CLASS,\n+\t\t        \"cannot find class for key %lu\", key);\n \t}\n \n       else\n-\tobjc_error(nil, OBJC_ERR_BAD_DATA,\n-\t\t   \"expected class, got opcode %c\", buf[0]);\n+\tobjc_error (nil, OBJC_ERR_BAD_DATA,\n+\t\t    \"expected class, got opcode %c\", buf[0]);\n     }\n   return len;\n }\n \n int\n-objc_read_selector (struct objc_typed_stream* stream, SEL* selector)\n+objc_read_selector (struct objc_typed_stream *stream, SEL* selector)\n {\n   unsigned char buf[sizeof (unsigned int)];\n   int len;\n-  if ((len = (*stream->read)(stream->physical, buf, 1)))\n+  if ((len = (*stream->read) (stream->physical, buf, 1)))\n     {\n       unsigned long key = 0;\n \n       if ((buf[0]&_B_CODE) == _B_RCOMM)\t/* register following */\n \t{\n-\t  len = __objc_read_nbyte_ulong(stream, (buf[0] & _B_VALUE), &key);\n-\t  len = (*stream->read)(stream->physical, buf, 1);\n+\t  len = __objc_read_nbyte_ulong (stream, (buf[0] & _B_VALUE), &key);\n+\t  len = (*stream->read) (stream->physical, buf, 1);\n \t}\n \n       if (buf[0] == (_B_EXT|_BX_SEL)) /* selector! */\n \t{\n-\t  char* selector_name;\n+\t  char *selector_name;\n \n \t  /* get selector */\n \t  len = objc_read_string (stream, &selector_name);\n \t  /* To handle NULL selectors */\n-\t  if (0 == strlen(selector_name))\n+\t  if (0 == strlen (selector_name))\n \t    {\n \t      (*selector) = (SEL)0;\n \t      return 0;\n \t    }\n \t  else \n-\t    (*selector) = sel_get_any_uid(selector_name);\n-\t  objc_free(selector_name);\n+\t    (*selector) = sel_get_any_uid (selector_name);\n+\t  objc_free (selector_name);\n \n \t  /* register */\n \t  if (key)\n-\t    hash_add (&stream->stream_table, LONG2PTR(key), (void*)*selector);\n+\t    hash_add (&stream->stream_table, LONG2PTR(key), (void *) *selector);\n \t}\n \n       else if ((buf[0]&_B_CODE) == _B_UCOMM)\n \t{\n \t  if (key)\n-\t    objc_error(nil, OBJC_ERR_BAD_KEY, \"cannot register use upcode...\");\n-\t  len = __objc_read_nbyte_ulong(stream, (buf[0] & _B_VALUE), &key);\n+\t    objc_error (nil, OBJC_ERR_BAD_KEY, \"cannot register use upcode...\");\n+\t  len = __objc_read_nbyte_ulong (stream, (buf[0] & _B_VALUE), &key);\n \t  (*selector) = hash_value_for_key (stream->stream_table, \n \t\t\t\t\t    LONG2PTR(key));\n \t}\n \n       else\n-\tobjc_error(nil, OBJC_ERR_BAD_DATA,\n-\t\t   \"expected selector, got opcode %c\", buf[0]);\n+\tobjc_error (nil, OBJC_ERR_BAD_DATA,\n+\t\t    \"expected selector, got opcode %c\", buf[0]);\n     }\n   return len;\n }\n@@ -983,66 +983,67 @@ objc_read_selector (struct objc_typed_stream* stream, SEL* selector)\n */\n \n int\n-objc_write_type(TypedStream* stream, const char* type, const void* data)\n+objc_write_type (TypedStream *stream, const char *type, const void *data)\n {\n-  switch(*type) {\n+  switch (*type) {\n   case _C_ID:\n-    return objc_write_object (stream, *(id*)data);\n+    return objc_write_object (stream, *(id *) data);\n     break;\n \n   case _C_CLASS:\n-    return objc_write_class (stream, *(Class*)data);\n+    return objc_write_class (stream, *(Class *) data);\n     break;\n \n   case _C_SEL:\n-    return objc_write_selector (stream, *(SEL*)data);\n+    return objc_write_selector (stream, *(SEL *) data);\n     break;\n \n   case _C_CHR:\n-    return objc_write_char(stream, *(signed char*)data);\n+    return objc_write_char (stream, *(signed char *) data);\n     break;\n     \n   case _C_UCHR:\n-    return objc_write_unsigned_char(stream, *(unsigned char*)data);\n+    return objc_write_unsigned_char (stream, *(unsigned char *) data);\n     break;\n \n   case _C_SHT:\n-    return objc_write_short(stream, *(short*)data);\n+    return objc_write_short (stream, *(short *) data);\n     break;\n \n   case _C_USHT:\n-    return objc_write_unsigned_short(stream, *(unsigned short*)data);\n+    return objc_write_unsigned_short (stream, *(unsigned short *) data);\n     break;\n \n   case _C_INT:\n-    return objc_write_int(stream, *(int*)data);\n+    return objc_write_int (stream, *(int *) data);\n     break;\n \n   case _C_UINT:\n-    return objc_write_unsigned_int(stream, *(unsigned int*)data);\n+    return objc_write_unsigned_int (stream, *(unsigned int *) data);\n     break;\n \n   case _C_LNG:\n-    return objc_write_long(stream, *(long*)data);\n+    return objc_write_long (stream, *(long *) data);\n     break;\n \n   case _C_ULNG:\n-    return objc_write_unsigned_long(stream, *(unsigned long*)data);\n+    return objc_write_unsigned_long (stream, *(unsigned long *) data);\n     break;\n \n   case _C_CHARPTR:\n-    return objc_write_string (stream, *(char**)data, strlen(*(char**)data));\n+    return objc_write_string (stream,\n+\t\t\t      *(char **) data, strlen (*(char **) data));\n     break;\n \n   case _C_ATOM:\n-    return objc_write_string_atomic (stream, *(char**)data, \n-\t\t\t\t     strlen(*(char**)data));\n+    return objc_write_string_atomic (stream, *(char **) data, \n+\t\t\t\t     strlen (*(char **) data));\n     break;\n \n   case _C_ARY_B:\n     {\n-      int len = atoi(type+1);\n-      while (isdigit((unsigned char)*++type))\n+      int len = atoi (type + 1);\n+      while (isdigit ((unsigned char) *++type))\n \t;\n       return objc_write_array (stream, type, len, data);\n     }\n@@ -1058,7 +1059,7 @@ objc_write_type(TypedStream* stream, const char* type, const void* data)\n \t{\n \t  align = objc_alignof_type (type);       /* padd to alignment */\n \t  acc_size += ROUND (acc_size, align);\n-\t  objc_write_type (stream, type, ((char*)data)+acc_size);\n+\t  objc_write_type (stream, type, ((char *) data) + acc_size);\n \t  acc_size += objc_sizeof_type (type);   /* add component size */\n \t  type = objc_skip_typespec (type);\t /* skip component */\n \t}\n@@ -1067,8 +1068,8 @@ objc_write_type(TypedStream* stream, const char* type, const void* data)\n \n   default:\n     {\n-      objc_error(nil, OBJC_ERR_BAD_TYPE,\n-\t\t \"objc_write_type: cannot parse typespec: %s\\n\", type);\n+      objc_error (nil, OBJC_ERR_BAD_TYPE,\n+\t\t  \"objc_write_type: cannot parse typespec: %s\\n\", type);\n       return 0;\n     }\n   }\n@@ -1082,10 +1083,10 @@ objc_write_type(TypedStream* stream, const char* type, const void* data)\n */\n \n int\n-objc_read_type(TypedStream* stream, const char* type, void* data)\n+objc_read_type(TypedStream *stream, const char *type, void *data)\n {\n   char c;\n-  switch(c = *type) {\n+  switch (c = *type) {\n   case _C_ID:\n     return objc_read_object (stream, (id*)data);\n     break;\n@@ -1137,8 +1138,8 @@ objc_read_type(TypedStream* stream, const char* type, void* data)\n \n   case _C_ARY_B:\n     {\n-      int len = atoi(type+1);\n-      while (isdigit((unsigned char)*++type))\n+      int len = atoi (type + 1);\n+      while (isdigit ((unsigned char) *++type))\n \t;\n       return objc_read_array (stream, type, len, data);\n     }\n@@ -1163,8 +1164,8 @@ objc_read_type(TypedStream* stream, const char* type, void* data)\n \n   default:\n     {\n-      objc_error(nil, OBJC_ERR_BAD_TYPE,\n-\t\t \"objc_read_type: cannot parse typespec: %s\\n\", type);\n+      objc_error (nil, OBJC_ERR_BAD_TYPE,\n+\t\t  \"objc_read_type: cannot parse typespec: %s\\n\", type);\n       return 0;\n     }\n   }\n@@ -1181,7 +1182,7 @@ objc_read_type(TypedStream* stream, const char* type, void* data)\n */\n \n int \n-objc_write_types (TypedStream* stream, const char* type, ...)\n+objc_write_types (TypedStream *stream, const char *type, ...)\n {\n   va_list args;\n   const char *c;\n@@ -1191,17 +1192,17 @@ objc_write_types (TypedStream* stream, const char* type, ...)\n \n   for (c = type; *c; c = objc_skip_typespec (c))\n     {\n-      switch(*c) {\n+      switch (*c) {\n       case _C_ID:\n \tres = objc_write_object (stream, *va_arg (args, id*));\n \tbreak;\n \n       case _C_CLASS:\n-\tres = objc_write_class (stream, *va_arg(args, Class*));\n+\tres = objc_write_class (stream, *va_arg (args, Class*));\n \tbreak;\n \n       case _C_SEL:\n-\tres = objc_write_selector (stream, *va_arg(args, SEL*));\n+\tres = objc_write_selector (stream, *va_arg (args, SEL*));\n \tbreak;\n \t\n       case _C_CHR:\n@@ -1214,60 +1215,60 @@ objc_write_types (TypedStream* stream, const char* type, ...)\n \tbreak;\n \t\n       case _C_SHT:\n-\tres = objc_write_short (stream, *va_arg(args, short*));\n+\tres = objc_write_short (stream, *va_arg (args, short*));\n \tbreak;\n \n       case _C_USHT:\n \tres = objc_write_unsigned_short (stream,\n-\t\t\t\t\t *va_arg(args, unsigned short*));\n+\t\t\t\t\t *va_arg (args, unsigned short*));\n \tbreak;\n \n       case _C_INT:\n-\tres = objc_write_int(stream, *va_arg(args, int*));\n+\tres = objc_write_int(stream, *va_arg (args, int*));\n \tbreak;\n \t\n       case _C_UINT:\n-\tres = objc_write_unsigned_int(stream, *va_arg(args, unsigned int*));\n+\tres = objc_write_unsigned_int(stream, *va_arg (args, unsigned int*));\n \tbreak;\n \n       case _C_LNG:\n-\tres = objc_write_long(stream, *va_arg(args, long*));\n+\tres = objc_write_long(stream, *va_arg (args, long*));\n \tbreak;\n \t\n       case _C_ULNG:\n-\tres = objc_write_unsigned_long(stream, *va_arg(args, unsigned long*));\n+\tres = objc_write_unsigned_long(stream, *va_arg (args, unsigned long*));\n \tbreak;\n \n       case _C_CHARPTR:\n \t{\n-\t  char** str = va_arg(args, char**);\n-\t  res = objc_write_string (stream, *str, strlen(*str));\n+\t  char **str = va_arg (args, char **);\n+\t  res = objc_write_string (stream, *str, strlen (*str));\n \t}\n \tbreak;\n \n       case _C_ATOM:\n \t{\n-\t  char** str = va_arg(args, char**);\n-\t  res = objc_write_string_atomic (stream, *str, strlen(*str));\n+\t  char **str = va_arg (args, char **);\n+\t  res = objc_write_string_atomic (stream, *str, strlen (*str));\n \t}\n \tbreak;\n \n       case _C_ARY_B:\n \t{\n-\t  int len = atoi(c+1);\n-\t  const char* t = c;\n-\t  while (isdigit((unsigned char)*++t))\n+\t  int len = atoi (c + 1);\n+\t  const char *t = c;\n+\t  while (isdigit ((unsigned char) *++t))\n \t    ;\n-\t  res = objc_write_array (stream, t, len, va_arg(args, void*));\n+\t  res = objc_write_array (stream, t, len, va_arg (args, void *));\n \t  t = objc_skip_typespec (t);\n \t  if (*t != _C_ARY_E)\n-\t    objc_error(nil, OBJC_ERR_BAD_TYPE, \"expected `]', got: %s\", t);\n+\t    objc_error (nil, OBJC_ERR_BAD_TYPE, \"expected `]', got: %s\", t);\n \t}\n \tbreak; \n \t\n       default:\n-\tobjc_error(nil, OBJC_ERR_BAD_TYPE, \n-\t\t   \"objc_write_types: cannot parse typespec: %s\\n\", type);\n+\tobjc_error (nil, OBJC_ERR_BAD_TYPE, \n+\t\t    \"objc_write_types: cannot parse typespec: %s\\n\", type);\n       }\n     }\n   va_end(args);\n@@ -1281,88 +1282,88 @@ objc_write_types (TypedStream* stream, const char* type, ...)\n */\n \n int \n-objc_read_types(TypedStream* stream, const char* type, ...)\n+objc_read_types(TypedStream *stream, const char *type, ...)\n {\n   va_list args;\n   const char *c;\n   int res = 0;\n \n-  va_start(args, type);\n+  va_start (args, type);\n \n   for (c = type; *c; c = objc_skip_typespec(c))\n     {\n-      switch(*c) {\n+      switch (*c) {\n       case _C_ID:\n-\tres = objc_read_object(stream, va_arg(args, id*));\n+\tres = objc_read_object(stream, va_arg (args, id*));\n \tbreak;\n \n       case _C_CLASS:\n-\tres = objc_read_class(stream, va_arg(args, Class*));\n+\tres = objc_read_class(stream, va_arg (args, Class*));\n \tbreak;\n \n       case _C_SEL:\n-\tres = objc_read_selector(stream, va_arg(args, SEL*));\n+\tres = objc_read_selector(stream, va_arg (args, SEL*));\n \tbreak;\n \t\n       case _C_CHR:\n-\tres = objc_read_char(stream, va_arg(args, char*));\n+\tres = objc_read_char(stream, va_arg (args, char*));\n \tbreak;\n \t\n       case _C_UCHR:\n-\tres = objc_read_unsigned_char(stream, va_arg(args, unsigned char*));\n+\tres = objc_read_unsigned_char(stream, va_arg (args, unsigned char*));\n \tbreak;\n \t\n       case _C_SHT:\n-\tres = objc_read_short(stream, va_arg(args, short*));\n+\tres = objc_read_short(stream, va_arg (args, short*));\n \tbreak;\n \n       case _C_USHT:\n-\tres = objc_read_unsigned_short(stream, va_arg(args, unsigned short*));\n+\tres = objc_read_unsigned_short(stream, va_arg (args, unsigned short*));\n \tbreak;\n \n       case _C_INT:\n-\tres = objc_read_int(stream, va_arg(args, int*));\n+\tres = objc_read_int(stream, va_arg (args, int*));\n \tbreak;\n \t\n       case _C_UINT:\n-\tres = objc_read_unsigned_int(stream, va_arg(args, unsigned int*));\n+\tres = objc_read_unsigned_int(stream, va_arg (args, unsigned int*));\n \tbreak;\n \n       case _C_LNG:\n-\tres = objc_read_long(stream, va_arg(args, long*));\n+\tres = objc_read_long(stream, va_arg (args, long*));\n \tbreak;\n \t\n       case _C_ULNG:\n-\tres = objc_read_unsigned_long(stream, va_arg(args, unsigned long*));\n+\tres = objc_read_unsigned_long(stream, va_arg (args, unsigned long*));\n \tbreak;\n \n       case _C_CHARPTR:\n       case _C_ATOM:\n \t{\n-\t  char** str = va_arg(args, char**);\n+\t  char **str = va_arg (args, char **);\n \t  res = objc_read_string (stream, str);\n \t}\n \tbreak;\n \n       case _C_ARY_B:\n \t{\n-\t  int len = atoi(c+1);\n-\t  const char* t = c;\n-\t  while (isdigit((unsigned char)*++t))\n+\t  int len = atoi (c + 1);\n+\t  const char *t = c;\n+\t  while (isdigit ((unsigned char) *++t))\n \t    ;\n-\t  res = objc_read_array (stream, t, len, va_arg(args, void*));\n+\t  res = objc_read_array (stream, t, len, va_arg (args, void *));\n \t  t = objc_skip_typespec (t);\n \t  if (*t != _C_ARY_E)\n-\t    objc_error(nil, OBJC_ERR_BAD_TYPE, \"expected `]', got: %s\", t);\n+\t    objc_error (nil, OBJC_ERR_BAD_TYPE, \"expected `]', got: %s\", t);\n \t}\n \tbreak; \n \t\n       default:\n-\tobjc_error(nil, OBJC_ERR_BAD_TYPE, \n-\t\t   \"objc_read_types: cannot parse typespec: %s\\n\", type);\n+\tobjc_error (nil, OBJC_ERR_BAD_TYPE, \n+\t\t    \"objc_read_types: cannot parse typespec: %s\\n\", type);\n       }\n     }\n-  va_end(args);\n+  va_end (args);\n   return res;\n }\n \n@@ -1372,11 +1373,11 @@ objc_read_types(TypedStream* stream, const char* type, ...)\n */\n \n int\n-objc_write_array (TypedStream* stream, const char* type,\n-\t\t  int count, const void* data)\n+objc_write_array (TypedStream *stream, const char *type,\n+\t\t  int count, const void *data)\n {\n   int off = objc_sizeof_type(type);\n-  const char* where = data;\n+  const char *where = data;\n \n   while (count-- > 0)\n     {\n@@ -1394,11 +1395,11 @@ objc_write_array (TypedStream* stream, const char* type,\n */\n \n int\n-objc_read_array (TypedStream* stream, const char* type,\n-\t\t int count, void* data)\n+objc_read_array (TypedStream *stream, const char *type,\n+\t\t int count, void *data)\n {\n   int off = objc_sizeof_type(type);\n-  char* where = (char*)data;\n+  char *where = (char*)data;\n \n   while (count-- > 0)\n     {\n@@ -1409,48 +1410,48 @@ objc_read_array (TypedStream* stream, const char* type,\n }\n \n static int \n-__objc_fread(FILE* file, char* data, int len)\n+__objc_fread (FILE *file, char *data, int len)\n {\n   return fread(data, len, 1, file);\n }\n \n static int \n-__objc_fwrite(FILE* file, char* data, int len)\n+__objc_fwrite (FILE *file, char *data, int len)\n {\n   return fwrite(data, len, 1, file);\n }\n \n static int\n-__objc_feof(FILE* file)\n+__objc_feof (FILE *file)\n {\n   return feof(file);\n }\n \n static int \n-__objc_no_write(FILE* file __attribute__ ((__unused__)),\n-\t\tconst char *data __attribute__ ((__unused__)),\n-\t\tint len __attribute__ ((__unused__)))\n+__objc_no_write (FILE *file __attribute__ ((__unused__)),\n+\t\t const char *data __attribute__ ((__unused__)),\n+\t\t int len __attribute__ ((__unused__)))\n {\n   objc_error (nil, OBJC_ERR_NO_WRITE, \"TypedStream not open for writing\");\n   return 0;\n }\n \n static int \n-__objc_no_read(FILE* file __attribute__ ((__unused__)),\n-\t       const char *data __attribute__ ((__unused__)),\n-\t       int len __attribute__ ((__unused__)))\n+__objc_no_read (FILE *file __attribute__ ((__unused__)),\n+\t\tconst char *data __attribute__ ((__unused__)),\n+\t\tint len __attribute__ ((__unused__)))\n {\n   objc_error (nil, OBJC_ERR_NO_READ, \"TypedStream not open for reading\");\n   return 0;\n }\n \n static int\n-__objc_read_typed_stream_signature (TypedStream* stream)\n+__objc_read_typed_stream_signature (TypedStream *stream)\n {\n   char buffer[80];\n   int pos = 0;\n   do\n-    (*stream->read)(stream->physical, buffer+pos, 1);\n+    (*stream->read) (stream->physical, buffer+pos, 1);\n   while (buffer[pos++] != '\\0')\n     ;\n   sscanf (buffer, \"GNU TypedStream %d\", &stream->version);\n@@ -1461,24 +1462,24 @@ __objc_read_typed_stream_signature (TypedStream* stream)\n }\n \n static int\n-__objc_write_typed_stream_signature (TypedStream* stream)\n+__objc_write_typed_stream_signature (TypedStream *stream)\n {\n   char buffer[80];\n   sprintf(buffer, \"GNU TypedStream %d\", OBJC_TYPED_STREAM_VERSION);\n   stream->version = OBJC_TYPED_STREAM_VERSION;\n-  (*stream->write)(stream->physical, buffer, strlen(buffer)+1);\n+  (*stream->write) (stream->physical, buffer, strlen (buffer) + 1);\n   return 1;\n }\n \n-static void __objc_finish_write_root_object(struct objc_typed_stream* stream)\n+static void __objc_finish_write_root_object(struct objc_typed_stream *stream)\n {\n   hash_delete (stream->object_table);\n   stream->object_table = hash_new(64,\n \t\t\t\t  (hash_func_type)hash_ptr,\n \t\t\t\t  (compare_func_type)compare_ptrs);\n }\n \n-static void __objc_finish_read_root_object(struct objc_typed_stream* stream)\n+static void __objc_finish_read_root_object(struct objc_typed_stream *stream)\n {\n   node_ptr node;\n   SEL awake_sel = sel_get_any_uid (\"awake\");\n@@ -1490,12 +1491,12 @@ static void __objc_finish_read_root_object(struct objc_typed_stream* stream)\n   for (node = hash_next (stream->object_refs, NULL); node;\n        node = hash_next (stream->object_refs, node))\n     {\n-      struct objc_list* reflist = node->value;\n-      const void* key = node->key;\n+      struct objc_list *reflist = node->value;\n+      const void *key = node->key;\n       id object = hash_value_for_key (stream->object_table, key);\n-      while(reflist)\n+      while (reflist)\n \t{\n-\t  *((id*)reflist->head) = object;\n+\t  *((id*) reflist->head) = object;\n \t  if (hash_value_for_key (free_list,reflist) == NULL)\n \t    hash_add (&free_list,reflist,reflist);\n \n@@ -1523,7 +1524,7 @@ static void __objc_finish_read_root_object(struct objc_typed_stream* stream)\n \t{\n \t  id object = node->value;\n \t  if (__objc_responds_to (object, awake_sel))\n-\t    (*objc_msg_lookup(object, awake_sel))(object, awake_sel);\n+\t    (*objc_msg_lookup (object, awake_sel)) (object, awake_sel);\n \t}\n     }\n \n@@ -1538,38 +1539,38 @@ static void __objc_finish_read_root_object(struct objc_typed_stream* stream)\n ** Open the stream PHYSICAL in MODE\n */\n \n-TypedStream* \n-objc_open_typed_stream (FILE* physical, int mode)\n+TypedStream *\n+objc_open_typed_stream (FILE *physical, int mode)\n {\n-  TypedStream* s = (TypedStream*)objc_malloc(sizeof(TypedStream));\n+  TypedStream *s = (TypedStream *) objc_malloc (sizeof (TypedStream));\n \n   s->mode = mode;\n   s->physical = physical;\n-  s->stream_table = hash_new(64,\n-\t\t\t     (hash_func_type)hash_ptr,\n-\t\t\t     (compare_func_type)compare_ptrs);\n-  s->object_table = hash_new(64,\n-\t\t\t     (hash_func_type)hash_ptr,\n-\t\t\t     (compare_func_type)compare_ptrs);\n-  s->eof = (objc_typed_eof_func)__objc_feof;\n-  s->flush = (objc_typed_flush_func)fflush;\n+  s->stream_table = hash_new (64,\n+\t\t\t      (hash_func_type) hash_ptr,\n+\t\t\t      (compare_func_type) compare_ptrs);\n+  s->object_table = hash_new (64,\n+\t\t\t      (hash_func_type) hash_ptr,\n+\t\t\t      (compare_func_type) compare_ptrs);\n+  s->eof = (objc_typed_eof_func) __objc_feof;\n+  s->flush = (objc_typed_flush_func) fflush;\n   s->writing_root_p = 0;\n   if (mode == OBJC_READONLY)\n     {\n-      s->class_table = hash_new(8, (hash_func_type)hash_string,\n-\t\t\t\t(compare_func_type)compare_strings);\n-      s->object_refs = hash_new(8, (hash_func_type)hash_ptr,\n-\t\t\t\t(compare_func_type)compare_ptrs);\n-      s->read = (objc_typed_read_func)__objc_fread;\n-      s->write = (objc_typed_write_func)__objc_no_write;\n+      s->class_table = hash_new (8, (hash_func_type) hash_string,\n+\t\t\t\t (compare_func_type) compare_strings);\n+      s->object_refs = hash_new (8, (hash_func_type) hash_ptr,\n+\t\t\t\t (compare_func_type) compare_ptrs);\n+      s->read = (objc_typed_read_func) __objc_fread;\n+      s->write = (objc_typed_write_func) __objc_no_write;\n       __objc_read_typed_stream_signature (s);\n     }\n   else if (mode == OBJC_WRITEONLY)\n     {\n       s->class_table = 0;\n       s->object_refs = 0;\n-      s->read = (objc_typed_read_func)__objc_no_read;\n-      s->write = (objc_typed_write_func)__objc_fwrite;\n+      s->read = (objc_typed_read_func) __objc_no_read;\n+      s->write = (objc_typed_write_func) __objc_fwrite;\n       __objc_write_typed_stream_signature (s);\n     }      \n   else\n@@ -1586,10 +1587,10 @@ objc_open_typed_stream (FILE* physical, int mode)\n */\n \n TypedStream*\n-objc_open_typed_stream_for_file (const char* file_name, int mode)\n+objc_open_typed_stream_for_file (const char *file_name, int mode)\n {\n-  FILE* file = NULL;\n-  TypedStream* s;\n+  FILE *file = NULL;\n+  TypedStream *s;\n \n   if (mode == OBJC_READONLY)\n     file = fopen (file_name, \"r\");\n@@ -1613,7 +1614,7 @@ objc_open_typed_stream_for_file (const char* file_name, int mode)\n */\n \n void\n-objc_close_typed_stream (TypedStream* stream)\n+objc_close_typed_stream (TypedStream *stream)\n {\n   if (stream->mode == OBJC_READONLY)\n     {\n@@ -1626,25 +1627,25 @@ objc_close_typed_stream (TypedStream* stream)\n   hash_delete (stream->object_table);\n \n   if (stream->type == (OBJC_MANAGED_STREAM | OBJC_FILE_STREAM))\n-    fclose ((FILE*)stream->physical);\n+    fclose ((FILE *)stream->physical);\n \n   objc_free(stream);\n }\n \n BOOL\n-objc_end_of_typed_stream (TypedStream* stream)\n+objc_end_of_typed_stream (TypedStream *stream)\n {\n-  return (*stream->eof)(stream->physical);\n+  return (*stream->eof) (stream->physical);\n }\n \n void\n-objc_flush_typed_stream (TypedStream* stream)\n+objc_flush_typed_stream (TypedStream *stream)\n {\n-  (*stream->flush)(stream->physical);\n+  (*stream->flush) (stream->physical);\n }\n \n long\n-objc_get_stream_class_version (TypedStream* stream, Class class)\n+objc_get_stream_class_version (TypedStream *stream, Class class)\n {\n   if (stream->class_table)\n     return PTR2LONG(hash_value_for_key (stream->class_table, class->name));"}, {"sha": "1740f38788ee7b29321797d6abd9ed6d03e373d2", "filename": "libobjc/class.c", "status": "modified", "additions": 49, "deletions": 45, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40165636b5fb904a609e01051c2ecfd52e5617e3/libobjc%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40165636b5fb904a609e01051c2ecfd52e5617e3/libobjc%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fclass.c?ref=40165636b5fb904a609e01051c2ecfd52e5617e3", "patch": "@@ -1,5 +1,6 @@\n /* GNU Objective C Runtime class related functions\n-   Copyright (C) 1993, 1995, 1996, 1997, 2001 Free Software Foundation, Inc.\n+   Copyright (C) 1993, 1995, 1996, 1997, 2001, 2002\n+     Free Software Foundation, Inc.\n    Contributed by Kresten Krab Thorup and Dennis Glatting.\n \n    Lock-free class table code designed and written from scratch by\n@@ -166,7 +167,7 @@ static void\n class_table_setup (void)\n {\n   /* Start - nothing in the table.  */\n-  memset (class_table_array, 0, sizeof(class_node_ptr) * CLASS_TABLE_SIZE);\n+  memset (class_table_array, 0, sizeof (class_node_ptr) * CLASS_TABLE_SIZE);\n \n   /* The table writing mutex.  */\n   __class_table_lock = objc_mutex_allocate ();\n@@ -339,7 +340,7 @@ class_table_next (struct class_table_enumerator **e)\n #if 0 /* DEBUGGING FUNCTIONS */\n /* Debugging function - print the class table.  */\n void\n-class_table_print ()\n+class_table_print (void)\n {\n   int i;\n   \n@@ -362,7 +363,7 @@ class_table_print ()\n    function of hash key values.  Useful to evaluate the hash function\n    in real cases.  */\n void\n-class_table_print_histogram ()\n+class_table_print_histogram (void)\n {\n   int i, j;\n   int counter = 0;\n@@ -408,64 +409,66 @@ class_table_print_histogram ()\n /* This is a hook which is called by objc_get_class and\n    objc_lookup_class if the runtime is not able to find the class.  \n    This may e.g. try to load in the class using dynamic loading.  */\n-Class (*_objc_lookup_class)(const char* name) = 0;      /* !T:SAFE */\n+Class (*_objc_lookup_class) (const char *name) = 0;      /* !T:SAFE */\n \n \n /* True when class links has been resolved.  */     \n BOOL __objc_class_links_resolved = NO;                  /* !T:UNUSED */\n \n \n-void __objc_init_class_tables()\n+void\n+__objc_init_class_tables (void)\n {\n   /* Allocate the class hash table.  */\n   \n-  if(__class_table_lock)\n+  if (__class_table_lock)\n     return;\n   \n-  objc_mutex_lock(__objc_runtime_mutex);\n+  objc_mutex_lock (__objc_runtime_mutex);\n   \n   class_table_setup ();\n \n-  objc_mutex_unlock(__objc_runtime_mutex);\n+  objc_mutex_unlock (__objc_runtime_mutex);\n }  \n \n /* This function adds a class to the class hash table, and assigns the\n    class a number, unless it's already known.  */\n void\n-__objc_add_class_to_hash(Class class)\n+__objc_add_class_to_hash (Class class)\n {\n   Class h_class;\n \n-  objc_mutex_lock(__objc_runtime_mutex);\n+  objc_mutex_lock (__objc_runtime_mutex);\n \n   /* Make sure the table is there.  */\n-  assert(__class_table_lock);\n+  assert (__class_table_lock);\n \n   /* Make sure it's not a meta class.  */\n-  assert(CLS_ISCLASS(class));\n+  assert (CLS_ISCLASS (class));\n \n   /* Check to see if the class is already in the hash table.  */\n   h_class = class_table_get_safe (class->name);\n-  if (!h_class)\n+  if (! h_class)\n     {\n       /* The class isn't in the hash table.  Add the class and assign a class\n          number.  */\n       static unsigned int class_number = 1;\n \n-      CLS_SETNUMBER(class, class_number);\n-      CLS_SETNUMBER(class->class_pointer, class_number);\n+      CLS_SETNUMBER (class, class_number);\n+      CLS_SETNUMBER (class->class_pointer, class_number);\n \n       ++class_number;\n       class_table_insert (class->name, class);\n     }\n \n-  objc_mutex_unlock(__objc_runtime_mutex);\n+  objc_mutex_unlock (__objc_runtime_mutex);\n }\n \n /* Get the class object for the class named NAME.  If NAME does not\n    identify a known class, the hook _objc_lookup_class is called.  If\n    this fails, nil is returned.  */\n-Class objc_lookup_class (const char* name)\n+Class\n+objc_lookup_class (const char *name)\n {\n   Class class;\n \n@@ -475,7 +478,7 @@ Class objc_lookup_class (const char* name)\n     return class;\n \n   if (_objc_lookup_class)\n-    return (*_objc_lookup_class)(name);\n+    return (*_objc_lookup_class) (name);\n   else\n     return 0;\n }\n@@ -494,20 +497,20 @@ objc_get_class (const char *name)\n     return class;\n \n   if (_objc_lookup_class)\n-    class = (*_objc_lookup_class)(name);\n+    class = (*_objc_lookup_class) (name);\n \n-  if(class)\n+  if (class)\n     return class;\n   \n-  objc_error(nil, OBJC_ERR_BAD_CLASS, \n-             \"objc runtime: cannot find class %s\\n\", name);\n+  objc_error (nil, OBJC_ERR_BAD_CLASS, \n+              \"objc runtime: cannot find class %s\\n\", name);\n   return 0;\n }\n \n MetaClass\n-objc_get_meta_class(const char *name)\n+objc_get_meta_class (const char *name)\n {\n-  return objc_get_class(name)->class_pointer;\n+  return objc_get_class (name)->class_pointer;\n }\n \n /* This function provides a way to enumerate all the classes in the\n@@ -516,56 +519,57 @@ objc_get_meta_class(const char *name)\n    For example: \n        id class; \n        void *es = NULL;\n-       while ((class = objc_next_class(&es)))\n+       while ((class = objc_next_class (&es)))\n          ... do something with class; \n */\n Class\n-objc_next_class(void **enum_state)\n+objc_next_class (void **enum_state)\n {\n   Class class;\n \n-  objc_mutex_lock(__objc_runtime_mutex);\n+  objc_mutex_lock (__objc_runtime_mutex);\n   \n   /* Make sure the table is there.  */\n-  assert(__class_table_lock);\n+  assert (__class_table_lock);\n \n-  class = class_table_next ((struct class_table_enumerator **)enum_state);\n+  class = class_table_next ((struct class_table_enumerator **) enum_state);\n \n-  objc_mutex_unlock(__objc_runtime_mutex);\n+  objc_mutex_unlock (__objc_runtime_mutex);\n   \n   return class;\n }\n \n /* Resolve super/subclass links for all classes.  The only thing we\n    can be sure of is that the class_pointer for class objects point to\n    the right meta class objects.  */\n-void __objc_resolve_class_links()\n+void\n+__objc_resolve_class_links (void)\n {\n   struct class_table_enumerator *es = NULL;\n   Class object_class = objc_get_class (\"Object\");\n   Class class1;\n \n-  assert(object_class);\n+  assert (object_class);\n \n-  objc_mutex_lock(__objc_runtime_mutex);\n+  objc_mutex_lock (__objc_runtime_mutex);\n \n   /* Assign subclass links.  */\n   while ((class1 = class_table_next (&es)))\n     {\n       /* Make sure we have what we think we have.  */\n-      assert (CLS_ISCLASS(class1));\n-      assert (CLS_ISMETA(class1->class_pointer));\n+      assert (CLS_ISCLASS (class1));\n+      assert (CLS_ISMETA (class1->class_pointer));\n \n       /* The class_pointer of all meta classes point to Object's meta\n          class.  */\n       class1->class_pointer->class_pointer = object_class->class_pointer;\n \n-      if (!(CLS_ISRESOLV(class1)))\n+      if (! CLS_ISRESOLV (class1))\n         {\n-          CLS_SETRESOLV(class1);\n-          CLS_SETRESOLV(class1->class_pointer);\n+          CLS_SETRESOLV (class1);\n+          CLS_SETRESOLV (class1->class_pointer);\n               \n-          if(class1->super_class)\n+          if (class1->super_class)\n             {   \n               Class a_super_class \n                 = objc_get_class ((char *) class1->super_class);\n@@ -607,12 +611,12 @@ void __objc_resolve_class_links()\n            sub_class = sub_class->sibling_class)\n         {\n           sub_class->super_class = class1;\n-          if(CLS_ISCLASS(sub_class))\n+          if (CLS_ISCLASS (sub_class))\n             sub_class->class_pointer->super_class = class1->class_pointer;\n         }\n     }\n \n-  objc_mutex_unlock(__objc_runtime_mutex);\n+  objc_mutex_unlock (__objc_runtime_mutex);\n }\n \n \n@@ -622,7 +626,7 @@ void __objc_resolve_class_links()\n Class\n class_pose_as (Class impostor, Class super_class)\n {\n-  if (!CLS_ISRESOLV (impostor))\n+  if (! CLS_ISRESOLV (impostor))\n     __objc_resolve_class_links ();\n \n   /* Preconditions */\n@@ -685,11 +689,11 @@ class_pose_as (Class impostor, Class super_class)\n      keys of the hashtable is, change all values that are superclass\n      into impostor.  */\n \n-  objc_mutex_lock(__objc_runtime_mutex);\n+  objc_mutex_lock (__objc_runtime_mutex);\n \n   class_table_replace (super_class, impostor);\n \n-  objc_mutex_unlock(__objc_runtime_mutex);\n+  objc_mutex_unlock (__objc_runtime_mutex);\n \n   /* Next, we update the dispatch tables...  */\n   __objc_update_dispatch_table_for_class (CLASSOF (impostor));"}, {"sha": "be4c08b423e24be54ae449ea7346eb9c052ae3a6", "filename": "libobjc/encoding.c", "status": "modified", "additions": 118, "deletions": 97, "changes": 215, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40165636b5fb904a609e01051c2ecfd52e5617e3/libobjc%2Fencoding.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40165636b5fb904a609e01051c2ecfd52e5617e3/libobjc%2Fencoding.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fencoding.c?ref=40165636b5fb904a609e01051c2ecfd52e5617e3", "patch": "@@ -34,18 +34,18 @@ Boston, MA 02111-1307, USA.  */\n \n #undef  MAX\n #define MAX(X, Y)                    \\\n-  ({ typeof(X) __x = (X), __y = (Y); \\\n+  ({ typeof (X) __x = (X), __y = (Y); \\\n      (__x > __y ? __x : __y); })\n \n #undef  MIN\n #define MIN(X, Y)                    \\\n-  ({ typeof(X) __x = (X), __y = (Y); \\\n+  ({ typeof (X) __x = (X), __y = (Y); \\\n      (__x < __y ? __x : __y); })\n \n #undef  ROUND\n #define ROUND(V, A) \\\n-  ({ typeof(V) __v=(V); typeof(A) __a=(A); \\\n-     __a*((__v+__a-1)/__a); })\n+  ({ typeof (V) __v = (V); typeof (A) __a = (A); \\\n+     __a * ((__v+__a - 1)/__a); })\n \n \n /* Various hacks for objc_layout_record. These are used by the target\n@@ -89,7 +89,7 @@ static int __attribute__ ((__unused__)) target_flags = 0;\n */\n \n int\n-objc_sizeof_type (const char* type)\n+objc_sizeof_type (const char *type)\n {\n   /* Skip the variable name if any */\n   if (*type == '\"')\n@@ -98,81 +98,83 @@ objc_sizeof_type (const char* type)\n \t/* do nothing */;\n     }\n \n-  switch(*type) {\n+  switch (*type) {\n   case _C_ID:\n-    return sizeof(id);\n+    return sizeof (id);\n     break;\n \n   case _C_CLASS:\n-    return sizeof(Class);\n+    return sizeof (Class);\n     break;\n \n   case _C_SEL:\n-    return sizeof(SEL);\n+    return sizeof (SEL);\n     break;\n \n   case _C_CHR:\n-    return sizeof(char);\n+    return sizeof (char);\n     break;\n \n   case _C_UCHR:\n-    return sizeof(unsigned char);\n+    return sizeof (unsigned char);\n     break;\n \n   case _C_SHT:\n-    return sizeof(short);\n+    return sizeof (short);\n     break;\n \n   case _C_USHT:\n-    return sizeof(unsigned short);\n+    return sizeof (unsigned short);\n     break;\n \n   case _C_INT:\n-    return sizeof(int);\n+    return sizeof (int);\n     break;\n \n   case _C_UINT:\n-    return sizeof(unsigned int);\n+    return sizeof (unsigned int);\n     break;\n \n   case _C_LNG:\n-    return sizeof(long);\n+    return sizeof (long);\n     break;\n \n   case _C_ULNG:\n-    return sizeof(unsigned long);\n+    return sizeof (unsigned long);\n     break;\n \n   case _C_LNG_LNG:\n-    return sizeof(long long);\n+    return sizeof (long long);\n     break;\n \n   case _C_ULNG_LNG:\n-    return sizeof(unsigned long long);\n+    return sizeof (unsigned long long);\n     break;\n \n   case _C_FLT:\n-    return sizeof(float);\n+    return sizeof (float);\n     break;\n \n   case _C_DBL:\n-    return sizeof(double);\n+    return sizeof (double);\n     break;\n \n   case _C_VOID:\n-    return sizeof(void);\n+    return sizeof (void);\n     break;\n+\n   case _C_PTR:\n   case _C_ATOM:\n   case _C_CHARPTR:\n-    return sizeof(char*);\n+    return sizeof (char *);\n     break;\n \n   case _C_ARY_B:\n     {\n-      int len = atoi(type+1);\n-      while (isdigit((unsigned char)*++type));\n-      return len*objc_aligned_size (type);\n+      int len = atoi (type + 1);\n+      while (isdigit ((unsigned char)*++type))\n+\t;\n+      return len * objc_aligned_size (type);\n     }\n     break;\n \n@@ -183,7 +185,8 @@ objc_sizeof_type (const char* type)\n       int startByte, endByte;\n \n       position = atoi (type + 1);\n-      while (isdigit ((unsigned char)*++type));\n+      while (isdigit ((unsigned char)*++type))\n+\t;\n       size = atoi (type + 1);\n \n       startByte = position / BITS_PER_UNIT;\n@@ -207,7 +210,8 @@ objc_sizeof_type (const char* type)\n   case _C_UNION_B:\n     {\n       int max_size = 0;\n-      while (*type != _C_UNION_E && *type++ != '=') /* do nothing */;\n+      while (*type != _C_UNION_E && *type++ != '=')\n+\t/* do nothing */;\n       while (*type != _C_UNION_E)\n \t{\n \t  /* Skip the variable name if any */\n@@ -224,7 +228,7 @@ objc_sizeof_type (const char* type)\n \n   default:\n     {\n-      objc_error(nil, OBJC_ERR_BAD_TYPE, \"unknown type %s\\n\", type);\n+      objc_error (nil, OBJC_ERR_BAD_TYPE, \"unknown type %s\\n\", type);\n       return 0;\n     }\n   }\n@@ -236,83 +240,84 @@ objc_sizeof_type (const char* type)\n */\n \n int\n-objc_alignof_type(const char* type)\n+objc_alignof_type (const char *type)\n {\n   /* Skip the variable name if any */\n   if (*type == '\"')\n     {\n       for (type++; *type++ != '\"';)\n \t/* do nothing */;\n     }\n-  switch(*type) {\n+  switch (*type) {\n   case _C_ID:\n-    return __alignof__(id);\n+    return __alignof__ (id);\n     break;\n \n   case _C_CLASS:\n-    return __alignof__(Class);\n+    return __alignof__ (Class);\n     break;\n \n   case _C_SEL:\n-    return __alignof__(SEL);\n+    return __alignof__ (SEL);\n     break;\n \n   case _C_CHR:\n-    return __alignof__(char);\n+    return __alignof__ (char);\n     break;\n \n   case _C_UCHR:\n-    return __alignof__(unsigned char);\n+    return __alignof__ (unsigned char);\n     break;\n \n   case _C_SHT:\n-    return __alignof__(short);\n+    return __alignof__ (short);\n     break;\n \n   case _C_USHT:\n-    return __alignof__(unsigned short);\n+    return __alignof__ (unsigned short);\n     break;\n \n   case _C_INT:\n-    return __alignof__(int);\n+    return __alignof__ (int);\n     break;\n \n   case _C_UINT:\n-    return __alignof__(unsigned int);\n+    return __alignof__ (unsigned int);\n     break;\n \n   case _C_LNG:\n-    return __alignof__(long);\n+    return __alignof__ (long);\n     break;\n \n   case _C_ULNG:\n-    return __alignof__(unsigned long);\n+    return __alignof__ (unsigned long);\n     break;\n \n   case _C_LNG_LNG:\n-    return __alignof__(long long);\n+    return __alignof__ (long long);\n     break;\n \n   case _C_ULNG_LNG:\n-    return __alignof__(unsigned long long);\n+    return __alignof__ (unsigned long long);\n     break;\n \n   case _C_FLT:\n-    return __alignof__(float);\n+    return __alignof__ (float);\n     break;\n \n   case _C_DBL:\n-    return __alignof__(double);\n+    return __alignof__ (double);\n     break;\n \n   case _C_PTR:\n   case _C_ATOM:\n   case _C_CHARPTR:\n-    return __alignof__(char*);\n+    return __alignof__ (char *);\n     break;\n \n   case _C_ARY_B:\n-    while (isdigit((unsigned char)*++type)) /* do nothing */;\n+    while (isdigit ((unsigned char)*++type))\n+      /* do nothing */;\n     return objc_alignof_type (type);\n \n   case _C_STRUCT_B:\n@@ -331,7 +336,8 @@ objc_alignof_type(const char* type)\n   case _C_UNION_B:\n     {\n       int maxalign = 0;\n-      while (*type != _C_UNION_E && *type++ != '=') /* do nothing */;\n+      while (*type != _C_UNION_E && *type++ != '=')\n+\t/* do nothing */;\n       while (*type != _C_UNION_E)\n \t{\n \t  /* Skip the variable name if any */\n@@ -348,7 +354,7 @@ objc_alignof_type(const char* type)\n \n   default:\n     {\n-      objc_error(nil, OBJC_ERR_BAD_TYPE, \"unknown type %s\\n\", type);\n+      objc_error (nil, OBJC_ERR_BAD_TYPE, \"unknown type %s\\n\", type);\n       return 0;\n     }\n   }\n@@ -359,7 +365,7 @@ objc_alignof_type(const char* type)\n */\n \n int\n-objc_aligned_size (const char* type)\n+objc_aligned_size (const char *type)\n {\n   int size, align;\n \n@@ -378,11 +384,11 @@ objc_aligned_size (const char* type)\n \n /*\n   The size rounded up to the nearest integral of the wordsize, taken\n-  to be the size of a void*.\n+  to be the size of a void *.\n */\n \n int\n-objc_promoted_size (const char* type)\n+objc_promoted_size (const char *type)\n {\n   int size, wordsize;\n \n@@ -394,7 +400,7 @@ objc_promoted_size (const char* type)\n     }\n \n   size = objc_sizeof_type (type);\n-  wordsize = sizeof (void*);\n+  wordsize = sizeof (void *);\n \n   return ROUND (size, wordsize);\n }\n@@ -404,8 +410,8 @@ objc_promoted_size (const char* type)\n   occurring in method prototype encodings.\n */\n \n-inline const char*\n-objc_skip_type_qualifiers (const char* type)\n+inline const char *\n+objc_skip_type_qualifiers (const char *type)\n {\n   while (*type == _C_CONST\n \t || *type == _C_IN\n@@ -427,8 +433,8 @@ objc_skip_type_qualifiers (const char* type)\n   qualifiers, these are skipped as well.\n */\n \n-const char*\n-objc_skip_typespec (const char* type)\n+const char *\n+objc_skip_typespec (const char *type)\n {\n   /* Skip the variable name if any */\n   if (*type == '\"')\n@@ -449,7 +455,8 @@ objc_skip_typespec (const char* type)\n       return type;\n     else\n       {\n-\twhile (*++type != '\"') /* do nothing */;\n+\twhile (*++type != '\"')\n+\t  /* do nothing */;\n \treturn type + 1;\n       }\n \n@@ -478,34 +485,45 @@ objc_skip_typespec (const char* type)\n   case _C_ARY_B:\n     /* skip digits, typespec and closing ']' */\n \n-    while(isdigit((unsigned char)*++type));\n-    type = objc_skip_typespec(type);\n+    while (isdigit ((unsigned char)*++type))\n+      ;\n+    type = objc_skip_typespec (type);\n     if (*type == _C_ARY_E)\n       return ++type;\n     else\n       {\n-\tobjc_error(nil, OBJC_ERR_BAD_TYPE, \"bad array type %s\\n\", type);\n+\tobjc_error (nil, OBJC_ERR_BAD_TYPE, \"bad array type %s\\n\", type);\n \treturn 0;\n       }\n \n   case _C_BFLD:\n     /* The new encoding of bitfields is: b 'position' 'type' 'size' */\n-    while (isdigit ((unsigned char)*++type));\t/* skip position */\n-    while (isdigit ((unsigned char)*++type));\t/* skip type and size */\n+    while (isdigit ((unsigned char)*++type))\n+      ;\t/* skip position */\n+    while (isdigit ((unsigned char)*++type))\n+      ;\t/* skip type and size */\n     return type;\n \n   case _C_STRUCT_B:\n     /* skip name, and elements until closing '}'  */\n \n-    while (*type != _C_STRUCT_E && *type++ != '=');\n-    while (*type != _C_STRUCT_E) { type = objc_skip_typespec (type); }\n+    while (*type != _C_STRUCT_E && *type++ != '=')\n+      ;\n+    while (*type != _C_STRUCT_E)\n+      {\n+\ttype = objc_skip_typespec (type);\n+      }\n     return ++type;\n \n   case _C_UNION_B:\n     /* skip name, and elements until closing ')'  */\n \n-    while (*type != _C_UNION_E && *type++ != '=');\n-    while (*type != _C_UNION_E) { type = objc_skip_typespec (type); }\n+    while (*type != _C_UNION_E && *type++ != '=')\n+      ;\n+    while (*type != _C_UNION_E)\n+      {\n+\ttype = objc_skip_typespec (type);\n+      }\n     return ++type;\n \n   case _C_PTR:\n@@ -515,7 +533,7 @@ objc_skip_typespec (const char* type)\n \n   default:\n     {\n-      objc_error(nil, OBJC_ERR_BAD_TYPE, \"unknown type %s\\n\", type);\n+      objc_error (nil, OBJC_ERR_BAD_TYPE, \"unknown type %s\\n\", type);\n       return 0;\n     }\n   }\n@@ -525,19 +543,21 @@ objc_skip_typespec (const char* type)\n   Skip an offset as part of a method encoding.  This is prepended by a\n   '+' if the argument is passed in registers.\n */\n-inline const char*\n-objc_skip_offset (const char* type)\n+inline const char *\n+objc_skip_offset (const char *type)\n {\n-  if (*type == '+') type++;\n-  while(isdigit((unsigned char)*++type));\n+  if (*type == '+')\n+    type++;\n+  while (isdigit ((unsigned char) *++type))\n+    ;\n   return type;\n }\n \n /*\n   Skip an argument specification of a method encoding.\n */\n-const char*\n-objc_skip_argspec (const char* type)\n+const char *\n+objc_skip_argspec (const char *type)\n {\n   type = objc_skip_typespec (type);\n   type = objc_skip_offset (type);\n@@ -550,10 +570,10 @@ objc_skip_argspec (const char* type)\n   `_cmd'.\n */\n int\n-method_get_number_of_arguments (struct objc_method* mth)\n+method_get_number_of_arguments (struct objc_method *mth)\n {\n   int i = 0;\n-  const char* type = mth->method_types;\n+  const char *type = mth->method_types;\n   while (*type)\n     {\n       type = objc_skip_argspec (type);\n@@ -569,9 +589,9 @@ method_get_number_of_arguments (struct objc_method* mth)\n */\n \n int\n-method_get_sizeof_arguments (struct objc_method* mth)\n+method_get_sizeof_arguments (struct objc_method *mth)\n {\n-  const char* type = objc_skip_typespec (mth->method_types);\n+  const char *type = objc_skip_typespec (mth->method_types);\n   return atoi (type);\n }\n \n@@ -591,15 +611,14 @@ method_get_sizeof_arguments (struct objc_method* mth)\n \telse\n \t  {\n \t    if ((flags & _F_IN) == _F_IN)\n-              [portal encodeData: *(char**)datum ofType: ++type];\n+              [portal encodeData: *(char **) datum ofType: ++type];\n \t  }\n       }\n   }\n */\n \n-char*\n-method_get_next_argument (arglist_t argframe,\n-\t\t\t  const char **type)\n+char *\n+method_get_next_argument (arglist_t argframe, const char **type)\n {\n   const char *t = objc_skip_argspec (*type);\n \n@@ -621,10 +640,10 @@ method_get_next_argument (arglist_t argframe,\n   is returned in TYPE.  type must be passed to successive calls of\n   method_get_next_argument.\n */\n-char*\n-method_get_first_argument (struct objc_method* m,\n+char *\n+method_get_first_argument (struct objc_method *m,\n \t\t\t   arglist_t argframe,\n-\t\t\t   const char** type)\n+\t\t\t   const char **type)\n {\n   *type = m->method_types;\n   return method_get_next_argument (argframe, type);\n@@ -636,12 +655,12 @@ method_get_first_argument (struct objc_method* m,\n    is returned in the value-result argument TYPE\n */\n \n-char*\n-method_get_nth_argument (struct objc_method* m,\n+char *\n+method_get_nth_argument (struct objc_method *m,\n \t\t\t arglist_t argframe, int arg,\n \t\t\t const char **type)\n {\n-  const char* t = objc_skip_argspec (m->method_types);\n+  const char *t = objc_skip_argspec (m->method_types);\n \n   if (arg > method_get_number_of_arguments (m))\n     return 0;\n@@ -659,7 +678,7 @@ method_get_nth_argument (struct objc_method* m,\n }\n \n unsigned\n-objc_get_type_qualifiers (const char* type)\n+objc_get_type_qualifiers (const char *type)\n {\n   unsigned res = 0;\n   BOOL flag = YES;\n@@ -712,7 +731,7 @@ objc_layout_structure (const char *type,\n \n   if (*type++ != _C_STRUCT_B)\n     {\n-      objc_error(nil, OBJC_ERR_BAD_TYPE,\n+      objc_error (nil, OBJC_ERR_BAD_TYPE,\n                  \"record type expected in objc_layout_structure, got %s\\n\",\n                  type);\n     }\n@@ -760,7 +779,7 @@ objc_layout_structure_next_member (struct objc_struct_layout *layout)\n       else {\n         /* Get the bitfield's type */\n         for (bfld_type = type + 1;\n-             isdigit((unsigned char)*bfld_type);\n+             isdigit ((unsigned char)*bfld_type);\n              bfld_type++)\n           /* do nothing */;\n \n@@ -784,12 +803,14 @@ objc_layout_structure_next_member (struct objc_struct_layout *layout)\n   type = objc_skip_type_qualifiers (layout->type);\n \n   if (*type != _C_BFLD)\n-    desired_align = objc_alignof_type(type) * BITS_PER_UNIT;\n+    desired_align = objc_alignof_type (type) * BITS_PER_UNIT;\n   else\n     {\n       desired_align = 1;\n       /* Skip the bitfield's offset */\n-      for (bfld_type = type + 1; isdigit((unsigned char)*bfld_type); bfld_type++)\n+      for (bfld_type = type + 1;\n+           isdigit ((unsigned char) *bfld_type);\n+           bfld_type++)\n         /* do nothing */;\n \n       bfld_type_size = objc_sizeof_type (bfld_type) * BITS_PER_UNIT;\n@@ -809,7 +830,7 @@ objc_layout_structure_next_member (struct objc_struct_layout *layout)\n      is meaningless.  */\n #ifndef PCC_BITFIELD_TYPE_MATTERS\n   layout->record_align = MAX (layout->record_align, desired_align);\n-#else\n+#else\t/* PCC_BITFIELD_TYPE_MATTERS */\n   if (*type == _C_BFLD)\n     {\n       /* For these machines, a zero-length field does not\n@@ -841,7 +862,7 @@ objc_layout_structure_next_member (struct objc_struct_layout *layout)\n     }\n   else\n     layout->record_align = MAX (layout->record_align, desired_align);\n-#endif\n+#endif\t/* PCC_BITFIELD_TYPE_MATTERS */\n \n   /* Does this field automatically have alignment it needs\n      by virtue of the fields that precede it and the record's\n@@ -875,7 +896,7 @@ void objc_layout_finish_structure (struct objc_struct_layout *layout,\n          in the record type.  Round it up to a multiple of the record's\n          alignment. */\n \n-#if defined(ROUND_TYPE_ALIGN) && !defined(__sparc__)\n+#if defined (ROUND_TYPE_ALIGN) && ! defined (__sparc__)\n       layout->record_align = ROUND_TYPE_ALIGN (layout->original_type,\n                                                1,\n                                                layout->record_align);"}, {"sha": "1010508f64cf669290c3bd59968d410a1419749b", "filename": "libobjc/gc.c", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40165636b5fb904a609e01051c2ecfd52e5617e3/libobjc%2Fgc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40165636b5fb904a609e01051c2ecfd52e5617e3/libobjc%2Fgc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fgc.c?ref=40165636b5fb904a609e01051c2ecfd52e5617e3", "patch": "@@ -1,5 +1,5 @@\n /* Basic data types for Objective C.\n-   Copyright (C) 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 2002 Free Software Foundation, Inc.\n    Contributed by Ovidiu Predescu.\n \n This file is part of GNU CC.\n@@ -58,11 +58,11 @@ typedef GC_signed_word signed_word;\n    The offset is incremented with the size of the type.  */\n \n #define ROUND(V, A) \\\n-  ({ typeof(V) __v=(V); typeof(A) __a=(A); \\\n-     __a*((__v+__a-1)/__a); })\n+  ({ typeof (V) __v = (V); typeof (A) __a = (A); \\\n+     __a * ((__v+__a - 1)/__a); })\n \n #define SET_BIT_FOR_OFFSET(mask, offset) \\\n-  GC_set_bit(mask, offset / sizeof (void*))\n+  GC_set_bit (mask, offset / sizeof (void *))\n \n /* Some prototypes */\n static void\n@@ -74,9 +74,9 @@ __objc_gc_setup_union (GC_bitmap mask, const char *type, int offset);\n static void\n __objc_gc_setup_array (GC_bitmap mask, const char *type, int offset)\n {\n-  int i, len = atoi(type + 1);\n+  int i, len = atoi (type + 1);\n \n-  while (isdigit(*++type))\n+  while (isdigit (*++type))\n     /* do nothing */;\t\t/* skip the size of the array */\n \n   switch (*type) {\n@@ -138,8 +138,8 @@ __objc_gc_setup_struct (GC_bitmap mask, const char *type, int offset)\n       case _C_PTR:\n       case _C_CHARPTR:\n       case _C_ATOM:\n-\tif (!gc_invisible)\n-\t  SET_BIT_FOR_OFFSET(mask, position);\n+\tif (! gc_invisible)\n+\t  SET_BIT_FOR_OFFSET (mask, position);\n \tbreak;\n \n       case _C_ARY_B:\n@@ -178,11 +178,11 @@ __objc_gc_setup_union (GC_bitmap mask, const char *type, int offset)\n   size = objc_sizeof_type (type);\n   align = objc_alignof_type (type);\n \n-  offset = ROUND(offset, align);\n-  for (i = 0; i < size; i += sizeof (void*))\n+  offset = ROUND (offset, align);\n+  for (i = 0; i < size; i += sizeof (void *))\n     {\n-      SET_BIT_FOR_OFFSET(mask, offset);\n-      offset += sizeof (void*);\n+      SET_BIT_FOR_OFFSET (mask, offset);\n+      offset += sizeof (void *);\n     }\n }\n \n@@ -223,8 +223,8 @@ __objc_gc_type_description_from_type (GC_bitmap mask, const char *type)\n       case _C_SEL:\n       case _C_PTR:\n       case _C_CHARPTR:\n-        if (!gc_invisible)\n-          SET_BIT_FOR_OFFSET(mask, offset);\n+        if (! gc_invisible)\n+          SET_BIT_FOR_OFFSET (mask, offset);\n \tbreak;\n \n       case _C_ARY_B:\n@@ -254,9 +254,9 @@ __objc_class_structure_encoding (Class class, char **type, int *size,\n                                  int *current)\n {\n   int i, ivar_count;\n-  struct objc_ivar_list* ivars;\n+  struct objc_ivar_list *ivars;\n \n-  if (!class)\n+  if (! class)\n     {\n       strcat (*type, \"{\");\n       *current++;\n@@ -267,7 +267,7 @@ __objc_class_structure_encoding (Class class, char **type, int *size,\n   __objc_class_structure_encoding (class->super_class, type, size, current);\n \n   ivars = class->ivars;\n-  if (!ivars)\n+  if (! ivars)\n     return;\n \n   ivar_count = ivars->ivar_count;\n@@ -282,7 +282,7 @@ __objc_class_structure_encoding (Class class, char **type, int *size,\n         {\n           /* Increase the size of the encoding string so that it\n              contains this ivar's type. */\n-          *size = ROUND(*current + len + 1, 10);\n+          *size = ROUND (*current + len + 1, 10);\n           *type = objc_realloc (*type, *size);\n         }\n       strcat (*type + *current, ivar_type);\n@@ -302,7 +302,7 @@ __objc_generate_gc_type_description (Class class)\n   int type_size = 10, current;\n   char *class_structure_type;\n \n-  if (!CLS_ISCLASS(class))\n+  if (! CLS_ISCLASS (class))\n     return;\n \n   /* We have to create a mask in which each bit counts for a pointer member.\n@@ -311,9 +311,9 @@ __objc_generate_gc_type_description (Class class)\n \n   /* The number of bits in the mask is the size of an instance in bytes divided\n      by the size of a pointer. */\n-  bits_no = (ROUND(class_get_instance_size (class), sizeof(void*))\n-             / sizeof (void*));\n-  size = ROUND(bits_no, BITS_PER_WORD) / BITS_PER_WORD;\n+  bits_no = (ROUND (class_get_instance_size (class), sizeof (void *))\n+             / sizeof (void *));\n+  size = ROUND (bits_no, BITS_PER_WORD) / BITS_PER_WORD;\n   mask = objc_atomic_malloc (size * sizeof (int));\n   memset (mask, 0, size * sizeof (int));\n \n@@ -342,7 +342,7 @@ __objc_generate_gc_type_description (Class class)\n   puts (\"\");\n #endif\n \n-  class->gc_object_type = (void*)GC_make_descriptor (mask, bits_no);\n+  class->gc_object_type = (void *) GC_make_descriptor (mask, bits_no);\n }\n \n \n@@ -370,17 +370,17 @@ __objc_ivar_pointer (const char *type)\n    This operation only makes sense on instance variables that are\n    pointers.  */\n void\n-class_ivar_set_gcinvisible (Class class, const char* ivarname,\n+class_ivar_set_gcinvisible (Class class, const char *ivarname,\n                             BOOL gc_invisible)\n {\n   int i, ivar_count;\n-  struct objc_ivar_list* ivars;\n+  struct objc_ivar_list *ivars;\n \n-  if (!class || !ivarname)\n+  if (! class || ! ivarname)\n     return;\n \n   ivars = class->ivars;\n-  if (!ivars)\n+  if (! ivars)\n     return;\n \n   ivar_count = ivars->ivar_count;\n@@ -390,7 +390,7 @@ class_ivar_set_gcinvisible (Class class, const char* ivarname,\n       struct objc_ivar *ivar = &(ivars->ivar_list[i]);\n       const char *type;\n \n-      if (!ivar->ivar_name || strcmp (ivar->ivar_name, ivarname))\n+      if (! ivar->ivar_name || strcmp (ivar->ivar_name, ivarname))\n \tcontinue;\n \n       assert (ivar->ivar_type);\n@@ -407,7 +407,7 @@ class_ivar_set_gcinvisible (Class class, const char* ivarname,\n \t{\n \t  char *new_type;\n \n-\t  if (gc_invisible || !__objc_ivar_pointer (type))\n+\t  if (gc_invisible || ! __objc_ivar_pointer (type))\n \t    return;\t/* The type of the variable already matches the\n \t\t\t   requested gc_invisible type */\n \n@@ -422,7 +422,7 @@ class_ivar_set_gcinvisible (Class class, const char* ivarname,\n \t{\n \t  char *new_type;\n \n-\t  if (!gc_invisible || !__objc_ivar_pointer (type))\n+\t  if (! gc_invisible || ! __objc_ivar_pointer (type))\n \t    return;\t/* The type of the variable already matches the\n \t\t\t   requested gc_invisible type */\n \n@@ -451,7 +451,7 @@ __objc_generate_gc_type_description (Class class __attribute__ ((__unused__)))\n }\n \n void class_ivar_set_gcinvisible (Class class __attribute__ ((__unused__)),\n-\t\t\t\t const char* ivarname __attribute__ ((__unused__)),\n+\t\t\t\t const char *ivarname __attribute__ ((__unused__)),\n \t\t\t\t BOOL gc_invisible __attribute__ ((__unused__)))\n {\n }"}, {"sha": "2f58b2c54729889c4183e08b7e179850991545bd", "filename": "libobjc/hash.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40165636b5fb904a609e01051c2ecfd52e5617e3/libobjc%2Fhash.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40165636b5fb904a609e01051c2ecfd52e5617e3/libobjc%2Fhash.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fhash.c?ref=40165636b5fb904a609e01051c2ecfd52e5617e3", "patch": "@@ -47,7 +47,7 @@ hash_new (unsigned int size, hash_func_type hash_func,\n \n   /* Pass me a value greater than 0 and a power of 2.  */\n   assert (size);\n-  assert (!(size & (size - 1)));\n+  assert (! (size & (size - 1)));\n \n   /* Allocate the cache structure.  calloc insures\n      its initialization for default values.  */\n@@ -196,7 +196,7 @@ hash_remove (cache_ptr cache, const void *key)\n         objc_free(node);\n       } else\n         prev = node, node = node->next;\n-    } while (!removed && node);\n+    } while (! removed && node);\n     assert (removed);\n   }\n \n@@ -210,7 +210,7 @@ hash_next (cache_ptr cache, node_ptr node)\n {\n   /* If the scan is being started then reset the last node\n      visitied pointer and bucket index.  */\n-  if (!node)\n+  if (! node)\n     cache->last_bucket  = 0;\n \n   /* If there is a node visited last then check for another\n@@ -258,7 +258,7 @@ hash_value_for_key (cache_ptr cache, const void *key)\n               break;\n       } else\n         node = node->next;\n-    } while (!retval && node);\n+    } while (! retval && node);\n \n   return retval;\n }"}, {"sha": "098e253649ff9dc6b016432658de1e27552acb87", "filename": "libobjc/init.c", "status": "modified", "additions": 195, "deletions": 177, "changes": 372, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40165636b5fb904a609e01051c2ecfd52e5617e3/libobjc%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40165636b5fb904a609e01051c2ecfd52e5617e3/libobjc%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Finit.c?ref=40165636b5fb904a609e01051c2ecfd52e5617e3", "patch": "@@ -1,5 +1,5 @@\n /* GNU Objective C Runtime initialization \n-   Copyright (C) 1993, 1995, 1996, 1997 Free Software Foundation, Inc.\n+   Copyright (C) 1993, 1995, 1996, 1997, 2002 Free Software Foundation, Inc.\n    Contributed by Kresten Krab Thorup\n    +load support contributed by Ovidiu Predescu <ovidiu@net-community.com>\n \n@@ -27,87 +27,89 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n #include \"runtime.h\"\n \n /* The version number of this runtime.  This must match the number \n-   defined in gcc (objc-act.c) */\n+   defined in gcc (objc-act.c).  */\n #define OBJC_VERSION 8\n #define PROTOCOL_VERSION 2\n \n-/* This list contains all modules currently loaded into the runtime */\n-static struct objc_list* __objc_module_list = 0; \t/* !T:MUTEX */\n+/* This list contains all modules currently loaded into the runtime.  */\n+static struct objc_list *__objc_module_list = 0; \t/* !T:MUTEX */\n \n-/* This list contains all proto_list's not yet assigned class links */\n-static struct objc_list* unclaimed_proto_list = 0; \t/* !T:MUTEX */\n+/* This list contains all proto_list's not yet assigned class links.  */\n+static struct objc_list *unclaimed_proto_list = 0; \t/* !T:MUTEX */\n \n /* List of unresolved static instances.  */\n static struct objc_list *uninitialized_statics = 0; \t/* !T:MUTEX */\n \n-/* Global runtime \"write\" mutex. */\n+/* Global runtime \"write\" mutex.  */\n objc_mutex_t __objc_runtime_mutex = 0;\n \n-/* Number of threads that are alive. */\n+/* Number of threads that are alive.  */\n int __objc_runtime_threads_alive = 1;\t\t\t/* !T:MUTEX */\n \n-/* Check compiler vs runtime version */\n+/* Check compiler vs runtime version.  */\n static void init_check_module_version (Module_t);\n \n-/* Assign isa links to protos */\n-static void __objc_init_protocols (struct objc_protocol_list* protos);\n+/* Assign isa links to protos.  */\n+static void __objc_init_protocols (struct objc_protocol_list *protos);\n \n-/* Add protocol to class */\n-static void __objc_class_add_protocols (Class, struct objc_protocol_list*);\n+/* Add protocol to class.  */\n+static void __objc_class_add_protocols (Class, struct objc_protocol_list *);\n \n-/* This is a hook which is called by __objc_exec_class every time a class\n-   or a category is loaded into the runtime.  This may e.g. help a\n-   dynamic loader determine the classes that have been loaded when\n-   an object file is dynamically linked in */\n-void (*_objc_load_callback)(Class class, Category* category); /* !T:SAFE */\n+/* This is a hook which is called by __objc_exec_class every time a\n+   class or a category is loaded into the runtime.  This may e.g. help\n+   a dynamic loader determine the classes that have been loaded when\n+   an object file is dynamically linked in.  */\n+void (*_objc_load_callback) (Class class, Category *category); /* !T:SAFE */\n \n-/* Is all categories/classes resolved? */\n+/* Is all categories/classes resolved?  */\n BOOL __objc_dangling_categories = NO;           /* !T:UNUSED */\n \n extern SEL\n __sel_register_typed_name (const char *name, const char *types, \n \t\t\t   struct objc_selector *orig, BOOL is_const);\n \n-/* Sends +load to all classes and categories in certain situations. */\n+/* Sends +load to all classes and categories in certain situations.  */\n static void objc_send_load (void);\n \n /* Inserts all the classes defined in module in a tree of classes that\n-   resembles the class hierarchy. This tree is traversed in preorder and the\n-   classes in its nodes receive the +load message if these methods were not\n-   executed before. The algorithm ensures that when the +load method of a class\n-   is executed all the superclasses have been already received the +load\n-   message. */\n+   resembles the class hierarchy. This tree is traversed in preorder\n+   and the classes in its nodes receive the +load message if these\n+   methods were not executed before. The algorithm ensures that when\n+   the +load method of a class is executed all the superclasses have\n+   been already received the +load message.  */\n static void __objc_create_classes_tree (Module_t module);\n \n static void __objc_call_callback (Module_t module);\n \n /* A special version that works only before the classes are completely\n-   installed in the runtime. */\n+   installed in the runtime.  */\n static BOOL class_is_subclass_of_class (Class class, Class superclass);\n \n typedef struct objc_class_tree {\n   Class class;\n   struct objc_list *subclasses; /* `head' is pointer to an objc_class_tree */\n } objc_class_tree;\n \n-/* This is a linked list of objc_class_tree trees. The head of these trees\n-   are root classes (their super class is Nil). These different trees\n-   represent different class hierarchies. */\n+/* This is a linked list of objc_class_tree trees. The head of these\n+   trees are root classes (their super class is Nil). These different\n+   trees represent different class hierarchies.  */\n static struct objc_list *__objc_class_tree_list = NULL;\n \n-/* Keeps the +load methods who have been already executed. This hash should\n-   not be destroyed during the execution of the program. */\n+/* Keeps the +load methods who have been already executed. This hash\n+   should not be destroyed during the execution of the program.  */\n static cache_ptr __objc_load_methods = NULL;\n \n-/* Creates a tree of classes whose topmost class is directly inherited from\n-   `upper' and the bottom class in this tree is `bottom_class'. The classes\n-   in this tree are super classes of `bottom_class'. `subclasses' member\n-   of each tree node point to the next subclass tree node. */\n+/* Creates a tree of classes whose topmost class is directly inherited\n+   from `upper' and the bottom class in this tree is\n+   `bottom_class'. The classes in this tree are super classes of\n+   `bottom_class'. `subclasses' member of each tree node point to the\n+   next subclass tree node.  */\n+\n static objc_class_tree *\n create_tree_of_subclasses_inherited_from (Class bottom_class, Class upper)\n {\n   Class superclass = bottom_class->super_class ?\n-\t\t\tobjc_lookup_class ((char*)bottom_class->super_class)\n+\t\t\tobjc_lookup_class ((char *) bottom_class->super_class)\n \t\t      : Nil;\n \t\t\t\t\t\n   objc_class_tree *tree, *prev;\n@@ -126,19 +128,21 @@ create_tree_of_subclasses_inherited_from (Class bottom_class, Class upper)\n       tree->class = superclass;\n       tree->subclasses = list_cons (prev, tree->subclasses);\n       superclass = (superclass->super_class ?\n-\t\t\tobjc_lookup_class ((char*)superclass->super_class)\n+\t\t\tobjc_lookup_class ((char *) superclass->super_class)\n \t\t      : Nil);\n       prev = tree;\n     }\n \n   return tree;\n }\n \n-/* Insert the `class' into the proper place in the `tree' class hierarchy. This\n-   function returns a new tree if the class has been successfully inserted into\n-   the tree or NULL if the class is not part of the classes hierarchy described\n-   by `tree'. This function is private to objc_tree_insert_class(), you should\n-   not call it directly. */\n+/* Insert the `class' into the proper place in the `tree' class\n+   hierarchy. This function returns a new tree if the class has been\n+   successfully inserted into the tree or NULL if the class is not\n+   part of the classes hierarchy described by `tree'. This function is\n+   private to objc_tree_insert_class (), you should not call it\n+   directly.  */\n+\n static objc_class_tree *\n __objc_tree_insert_class (objc_class_tree *tree, Class class)\n {\n@@ -154,21 +158,21 @@ __objc_tree_insert_class (objc_class_tree *tree, Class class)\n       return tree;\n     }\n   else if ((class->super_class ?\n-\t\t    objc_lookup_class ((char*)class->super_class)\n+\t\t    objc_lookup_class ((char *) class->super_class)\n \t\t  : Nil)\n \t    == tree->class)\n     {\n       /* If class is a direct subclass of tree->class then add class to the\n \t list of subclasses. First check to see if it wasn't already\n-\t inserted. */\n+\t inserted.  */\n       struct objc_list *list = tree->subclasses;\n       objc_class_tree *node;\n \n       while (list)\n \t{\n \t  /* Class has been already inserted; do nothing just return\n-\t     the tree. */\n-\t  if (((objc_class_tree*)list->head)->class == class)\n+\t     the tree.  */\n+\t  if (((objc_class_tree *) list->head)->class == class)\n \t    {\n \t      DEBUG_PRINTF (\"2. class %s was previously inserted\\n\",\n \t\t\t    class->name);\n@@ -186,45 +190,47 @@ __objc_tree_insert_class (objc_class_tree *tree, Class class)\n     }\n   else\n     {\n-      /* The class is not a direct subclass of tree->class. Search for class's\n-         superclasses in the list of subclasses. */\n+      /* The class is not a direct subclass of tree->class. Search for\n+         class's superclasses in the list of subclasses.  */\n       struct objc_list *subclasses = tree->subclasses;\n \n-      /* Precondition: the class must be a subclass of tree->class; otherwise\n-         return NULL to indicate our caller that it must take the next tree. */\n-      if (!class_is_subclass_of_class (class, tree->class))\n+      /* Precondition: the class must be a subclass of tree->class;\n+         otherwise return NULL to indicate our caller that it must\n+         take the next tree.  */\n+      if (! class_is_subclass_of_class (class, tree->class))\n \treturn NULL;\n \n       for (; subclasses != NULL; subclasses = subclasses->tail)\n \t{\n-\t  Class aClass = ((objc_class_tree*)(subclasses->head))->class;\n+\t  Class aClass = ((objc_class_tree *) (subclasses->head))->class;\n \n \t  if (class_is_subclass_of_class (class, aClass))\n \t    {\n-\t      /* If we found one of class's superclasses we insert the class\n-\t         into its subtree and return the original tree since nothing\n-\t\t has been changed. */\n+\t      /* If we found one of class's superclasses we insert the\n+\t         class into its subtree and return the original tree\n+\t         since nothing has been changed.  */\n \t      subclasses->head\n \t\t  = __objc_tree_insert_class (subclasses->head, class);\n  \t      DEBUG_PRINTF (\"4. class %s inserted\\n\", class->name);\n \t      return tree;\n \t    }\n \t}\n \n-      /* We haven't found a subclass of `class' in the `subclasses' list.\n-         Create a new tree of classes whose topmost class is a direct subclass\n-\t of tree->class. */\n+      /* We haven't found a subclass of `class' in the `subclasses'\n+         list.  Create a new tree of classes whose topmost class is a\n+         direct subclass of tree->class.  */\n       {\n \tobjc_class_tree *new_tree\n-\t    = create_tree_of_subclasses_inherited_from (class, tree->class);\n+\t  = create_tree_of_subclasses_inherited_from (class, tree->class);\n \ttree->subclasses = list_cons (new_tree, tree->subclasses);\n  \tDEBUG_PRINTF (\"5. class %s inserted\\n\", class->name);\n \treturn tree;\n       }\n     }\n }\n \n-/* This function inserts `class' in the right tree hierarchy classes. */\n+/* This function inserts `class' in the right tree hierarchy classes.  */\n+\n static void\n objc_tree_insert_class (Class class)\n {\n@@ -244,20 +250,21 @@ objc_tree_insert_class (Class class)\n \tlist_node = list_node->tail;\n     }\n \n-  /* If the list was finished but the class hasn't been inserted, insert it\n-     here. */\n-  if (!list_node)\n+  /* If the list was finished but the class hasn't been inserted,\n+     insert it here.  */\n+  if (! list_node)\n     {\n       __objc_class_tree_list = list_cons (NULL, __objc_class_tree_list);\n       __objc_class_tree_list->head = __objc_tree_insert_class (NULL, class);\n     }\n }\n \n-/* Traverse tree in preorder. Used to send +load. */\n+/* Traverse tree in preorder. Used to send +load.  */\n+\n static void\n objc_preorder_traverse (objc_class_tree *tree,\n \t\t\tint level,\n-\t\t\tvoid (*function)(objc_class_tree*, int))\n+\t\t\tvoid (*function) (objc_class_tree *, int))\n {\n   struct objc_list *node;\n \n@@ -266,11 +273,12 @@ objc_preorder_traverse (objc_class_tree *tree,\n     objc_preorder_traverse (node->head, level + 1, function);\n }\n \n-/* Traverse tree in postorder. Used to destroy a tree. */\n+/* Traverse tree in postorder. Used to destroy a tree.  */\n+\n static void\n objc_postorder_traverse (objc_class_tree *tree,\n-\t\t\tint level,\n-\t\t\tvoid (*function)(objc_class_tree*, int))\n+\t\t\t int level,\n+\t\t\t void (*function) (objc_class_tree *, int))\n {\n   struct objc_list *node;\n \n@@ -279,7 +287,8 @@ objc_postorder_traverse (objc_class_tree *tree,\n   (*function) (tree, level);\n }\n \n-/* Used to print a tree class hierarchy. */\n+/* Used to print a tree class hierarchy.  */\n+\n #ifdef DEBUG\n static void\n __objc_tree_print (objc_class_tree *tree, int level)\n@@ -292,35 +301,37 @@ __objc_tree_print (objc_class_tree *tree, int level)\n }\n #endif\n \n-/* Walks on a linked list of methods in the reverse order and executes all\n-   the methods corresponding to `op' selector. Walking in the reverse order\n-   assures the +load of class is executed first and then +load of categories\n-   because of the way in which categories are added to the class methods. */\n+/* Walks on a linked list of methods in the reverse order and executes\n+   all the methods corresponding to `op' selector. Walking in the\n+   reverse order assures the +load of class is executed first and then\n+   +load of categories because of the way in which categories are\n+   added to the class methods.  */\n+\n static void\n __objc_send_message_in_list (MethodList_t method_list, Class class, SEL op)\n {\n   int i;\n \n-  if (!method_list)\n+  if (! method_list)\n     return;\n \n   /* First execute the `op' message in the following method lists */\n   __objc_send_message_in_list (method_list->method_next, class, op);\n \n-  /* Search the method list. */\n+  /* Search the method list.  */\n   for (i = 0; i < method_list->method_count; i++)\n     {\n       Method_t mth = &method_list->method_list[i];\n \n       if (mth->method_name && sel_eq (mth->method_name, op)\n-\t  && !hash_is_key_in_hash (__objc_load_methods, mth->method_imp))\n+\t  && ! hash_is_key_in_hash (__objc_load_methods, mth->method_imp))\n \t{\n \t  /* Add this method into the +load hash table */\n \t  hash_add (&__objc_load_methods, mth->method_imp, mth->method_imp);\n \n \t  DEBUG_PRINTF (\"sending +load in class: %s\\n\", class->name);\n \n-\t  /* The method was found and wasn't previously executed. */\n+\t  /* The method was found and wasn't previously executed.  */\n \t  (*mth->method_imp) ((id)class, mth->method_name);\n \n \t  break;\n@@ -336,7 +347,7 @@ __objc_send_load (objc_class_tree *tree,\n   Class class = tree->class;\n   MethodList_t method_list = class->class_pointer->methods;\n \n-  if (!load_sel)\n+  if (! load_sel)\n     load_sel = sel_register_name (\"load\");\n \n   __objc_send_message_in_list (method_list, class, load_sel);\n@@ -349,8 +360,9 @@ __objc_destroy_class_tree_node (objc_class_tree *tree,\n   objc_free (tree);\n }\n \n-/* This is used to check if the relationship between two classes before the\n-   runtime completely installs the classes. */\n+/* This is used to check if the relationship between two classes\n+   before the runtime completely installs the classes.  */\n+\n static BOOL\n class_is_subclass_of_class (Class class, Class superclass)\n {\n@@ -359,19 +371,19 @@ class_is_subclass_of_class (Class class, Class superclass)\n       if (class == superclass)\n \treturn YES;\n       class = (class->super_class ?\n-\t\t  objc_lookup_class ((char*)class->super_class)\n+\t\t  objc_lookup_class ((char *) class->super_class)\n \t\t: Nil);\n     }\n \n   return NO;\n }\n \n-/* This list contains all the classes in the runtime system for whom their\n-   superclasses are not yet know to the runtime. */\n-static struct objc_list* unresolved_classes = 0;\n+/* This list contains all the classes in the runtime system for whom\n+   their superclasses are not yet known to the runtime.  */\n+static struct objc_list *unresolved_classes = 0;\n \n-/* Extern function used to reference the Object and NXConstantString classes.\n- */\n+/* Extern function used to reference the Object and NXConstantString\n+   classes.  */\n \n extern void __objc_force_linking (void);\n \n@@ -382,15 +394,16 @@ __objc_force_linking (void)\n   __objc_linking ();\n }\n \n-/* Run through the statics list, removing modules as soon as all its statics\n-   have been initialized.  */\n+/* Run through the statics list, removing modules as soon as all its\n+   statics have been initialized.  */\n+\n static void\n objc_init_statics (void)\n {\n   struct objc_list **cell = &uninitialized_statics;\n   struct objc_static_instances **statics_in_module;\n \n-  objc_mutex_lock(__objc_runtime_mutex);\n+  objc_mutex_lock (__objc_runtime_mutex);\n \n   while (*cell)\n     {\n@@ -402,7 +415,7 @@ objc_init_statics (void)\n \t  struct objc_static_instances *statics = *statics_in_module;\n \t  Class class = objc_lookup_class (statics->class_name);\n \n-\t  if (!class)\n+\t  if (! class)\n \t    module_initialized = 0;\n \t  /* Actually, the static's class_pointer will be NULL when we\n              haven't been here before.  However, the comparison is to be\n@@ -432,19 +445,19 @@ objc_init_statics (void)\n \t  /* Remove this module from the uninitialized list.  */\n \t  struct objc_list *this = *cell;\n \t  *cell = this->tail;\n-\t  objc_free(this);\n+\t  objc_free (this);\n \t}\n       else\n \tcell = &(*cell)->tail;\n     }\n \n-  objc_mutex_unlock(__objc_runtime_mutex);\n+  objc_mutex_unlock (__objc_runtime_mutex);\n } /* objc_init_statics */\n \n /* This function is called by constructor functions generated for each\n-   module compiled.  (_GLOBAL_$I$...) The purpose of this function is to\n-   gather the module pointers so that they may be processed by the\n-   initialization routines as soon as possible */\n+   module compiled.  (_GLOBAL_$I$...) The purpose of this function is\n+   to gather the module pointers so that they may be processed by the\n+   initialization routines as soon as possible.  */\n \n void\n __objc_exec_class (Module_t module)\n@@ -453,7 +466,7 @@ __objc_exec_class (Module_t module)\n      indicate that some global data structures need to be built.  */\n   static BOOL previous_constructors = 0;\n \n-  static struct objc_list* unclaimed_categories = 0;\n+  static struct objc_list *unclaimed_categories = 0;\n \n   /* The symbol table (defined in objc-api.h) generated by gcc */\n   Symtab_t symtab = module->symtab;\n@@ -463,7 +476,7 @@ __objc_exec_class (Module_t module)\n     = symtab->defs[symtab->cls_def_cnt + symtab->cat_def_cnt];\n \n   /* Entry used to traverse hash lists */\n-  struct objc_list** cell;\n+  struct objc_list **cell;\n \n   /* The table of selector references for this module */\n   SEL selectors = symtab->refs; \n@@ -474,41 +487,41 @@ __objc_exec_class (Module_t module)\n   DEBUG_PRINTF (\"received module: %s\\n\", module->name);\n \n   /* check gcc version */\n-  init_check_module_version(module);\n+  init_check_module_version (module);\n \n   /* On the first call of this routine, initialize some data structures.  */\n-  if (!previous_constructors)\n+  if (! previous_constructors)\n     {\n \t/* Initialize thread-safe system */\n-      __objc_init_thread_system();\n+      __objc_init_thread_system ();\n       __objc_runtime_threads_alive = 1;\n-      __objc_runtime_mutex = objc_mutex_allocate();\n+      __objc_runtime_mutex = objc_mutex_allocate ();\n \n-      __objc_init_selector_tables();\n-      __objc_init_class_tables();\n-      __objc_init_dispatch_tables();\n+      __objc_init_selector_tables ();\n+      __objc_init_class_tables ();\n+      __objc_init_dispatch_tables ();\n       __objc_class_tree_list = list_cons (NULL, __objc_class_tree_list);\n       __objc_load_methods\n \t  = hash_new (128, (hash_func_type)hash_ptr, compare_ptrs);\n       previous_constructors = 1;\n     }\n \n   /* Save the module pointer for later processing. (not currently used) */\n-  objc_mutex_lock(__objc_runtime_mutex);\n-  __objc_module_list = list_cons(module, __objc_module_list);\n+  objc_mutex_lock (__objc_runtime_mutex);\n+  __objc_module_list = list_cons (module, __objc_module_list);\n \n   /* Replace referenced selectors from names to SEL's.  */\n   if (selectors)\n     {\n       for (i = 0; selectors[i].sel_id; ++i)\n \t{\n \t  const char *name, *type;\n-\t  name = (char*)selectors[i].sel_id;\n-\t  type = (char*)selectors[i].sel_types;\n+\t  name = (char *) selectors[i].sel_id;\n+\t  type = (char *) selectors[i].sel_types;\n \t  /* Constructors are constant static data so we can safely store\n \t     pointers to them in the runtime structures. is_const == YES */\n \t  __sel_register_typed_name (name, type, \n-\t\t\t\t     (struct objc_selector*)&(selectors[i]),\n+\t\t\t\t     (struct objc_selector *) &(selectors[i]),\n \t\t\t\t     YES);\n \t}\n     }\n@@ -518,15 +531,15 @@ __objc_exec_class (Module_t module)\n   for (i = 0; i < symtab->cls_def_cnt; ++i)\n     {\n       Class class = (Class) symtab->defs[i];\n-      const char* superclass = (char*)class->super_class;\n+      const char *superclass = (char *) class->super_class;\n \n       /* Make sure we have what we think.  */\n-      assert (CLS_ISCLASS(class));\n-      assert (CLS_ISMETA(class->class_pointer));\n+      assert (CLS_ISCLASS (class));\n+      assert (CLS_ISMETA (class->class_pointer));\n       DEBUG_PRINTF (\"phase 1, processing class: %s\\n\", class->name);\n \n       /* Initialize the subclass list to be NULL.\n-\t In some cases it isn't and this crashes the program. */\n+\t In some cases it isn't and this crashes the program.  */\n       class->subclass_list = NULL;\n \n       /* Store the class in the class table and assign class numbers.  */\n@@ -537,19 +550,19 @@ __objc_exec_class (Module_t module)\n       __objc_register_selectors_from_class ((Class) class->class_pointer);\n \n       /* Install the fake dispatch tables */\n-      __objc_install_premature_dtable(class);\n-      __objc_install_premature_dtable(class->class_pointer);\n+      __objc_install_premature_dtable (class);\n+      __objc_install_premature_dtable (class->class_pointer);\n \n       /* Register the instance methods as class methods, this is\n-\t only done for root classes. */\n-      __objc_register_instance_methods_to_class(class);\n+\t only done for root classes.  */\n+      __objc_register_instance_methods_to_class (class);\n \n       if (class->protocols)\n \t__objc_init_protocols (class->protocols);\n \n       /* Check to see if the superclass is known in this point. If it's not\n-\t add the class to the unresolved_classes list. */\n-      if (superclass && !objc_lookup_class (superclass))\n+\t add the class to the unresolved_classes list.  */\n+      if (superclass && ! objc_lookup_class (superclass))\n \tunresolved_classes = list_cons (class, unresolved_classes);\n    }\n \n@@ -583,14 +596,14 @@ __objc_exec_class (Module_t module)\n \t    }\n \n           /* Register the instance methods as class methods, this is\n-             only done for root classes. */\n-          __objc_register_instance_methods_to_class(class);\n+             only done for root classes.  */\n+          __objc_register_instance_methods_to_class (class);\n \t}\n       else\n \t{\n \t  /* The object to which the category methods belong can't be found.\n \t     Save the information.  */\n-\t  unclaimed_categories = list_cons(category, unclaimed_categories);\n+\t  unclaimed_categories = list_cons (category, unclaimed_categories);\n \t}\n     }\n \n@@ -627,39 +640,41 @@ __objc_exec_class (Module_t module)\n \t    }\n \n           /* Register the instance methods as class methods, this is\n-             only done for root classes. */\n-          __objc_register_instance_methods_to_class(class);\n+             only done for root classes.  */\n+          __objc_register_instance_methods_to_class (class);\n \t}\n       else\n \tcell = &(*cell)->tail;\n     }\n   \n   if (unclaimed_proto_list && objc_lookup_class (\"Protocol\"))\n     {\n-      list_mapcar (unclaimed_proto_list,(void(*)(void*))__objc_init_protocols);\n+      list_mapcar (unclaimed_proto_list,\n+\t\t   (void (*) (void *))__objc_init_protocols);\n       list_free (unclaimed_proto_list);\n       unclaimed_proto_list = 0;\n     }\n \n   objc_send_load ();\n \n-  objc_mutex_unlock(__objc_runtime_mutex);\n+  objc_mutex_unlock (__objc_runtime_mutex);\n }\n \n-static void objc_send_load (void)\n+static void\n+objc_send_load (void)\n {\n-  if (!__objc_module_list)\n+  if (! __objc_module_list)\n     return;\n  \n   /* Try to find out if all the classes loaded so far also have their\n-     superclasses known to the runtime. We suppose that the objects that are\n-     allocated in the +load method are in general of a class declared in the\n-     same module. */\n+     superclasses known to the runtime. We suppose that the objects\n+     that are allocated in the +load method are in general of a class\n+     declared in the same module.  */\n   if (unresolved_classes)\n     {\n       Class class = unresolved_classes->head;\n \n-      while (objc_lookup_class ((char*)class->super_class))\n+      while (objc_lookup_class ((char *) class->super_class))\n \t{\n \t  list_remove_head (&unresolved_classes);\n \t  if (unresolved_classes)\n@@ -668,25 +683,25 @@ static void objc_send_load (void)\n \t    break;\n \t}\n \n-      /*\n-       * If we still have classes for whom we don't have yet their super\n-       * classes known to the runtime we don't send the +load messages.\n-       */\n+      /* If we still have classes for whom we don't have yet their\n+         super classes known to the runtime we don't send the +load\n+         messages.  */\n       if (unresolved_classes)\n \treturn;\n     }\n \n-  /* Special check to allow creating and sending messages to constant strings\n-     in +load methods. If these classes are not yet known, even if all the\n-     other classes are known, delay sending of +load. */\n-  if (!objc_lookup_class (\"NXConstantString\") ||\n-      !objc_lookup_class (\"Object\"))\n+  /* Special check to allow creating and sending messages to constant\n+     strings in +load methods. If these classes are not yet known,\n+     even if all the other classes are known, delay sending of +load.  */\n+  if (! objc_lookup_class (\"NXConstantString\") ||\n+      ! objc_lookup_class (\"Object\"))\n     return;\n \n-  /* Iterate over all modules in the __objc_module_list and call on them the\n-     __objc_create_classes_tree function. This function creates a tree of\n-     classes that resembles the class hierarchy. */\n-  list_mapcar (__objc_module_list, (void(*)(void*))__objc_create_classes_tree);\n+  /* Iterate over all modules in the __objc_module_list and call on\n+     them the __objc_create_classes_tree function. This function\n+     creates a tree of classes that resembles the class hierarchy.  */\n+  list_mapcar (__objc_module_list,\n+\t       (void (*) (void *)) __objc_create_classes_tree);\n \n   while (__objc_class_tree_list)\n     {\n@@ -701,7 +716,7 @@ static void objc_send_load (void)\n       list_remove_head (&__objc_class_tree_list);\n     }\n \n-  list_mapcar (__objc_module_list, (void(*)(void*))__objc_call_callback);\n+  list_mapcar (__objc_module_list, (void (*) (void *)) __objc_call_callback);\n   list_free (__objc_module_list);\n   __objc_module_list = NULL;\n }\n@@ -714,8 +729,8 @@ __objc_create_classes_tree (Module_t module)\n   Symtab_t symtab = module->symtab;\n   int i;\n \n-  /* Iterate thru classes defined in this module and insert them in the classes\n-     tree hierarchy. */\n+  /* Iterate thru classes defined in this module and insert them in\n+     the classes tree hierarchy.  */\n   for (i = 0; i < symtab->cls_def_cnt; i++)\n     {\n       Class class = (Class) symtab->defs[i];\n@@ -727,82 +742,84 @@ __objc_create_classes_tree (Module_t module)\n static void\n __objc_call_callback (Module_t module)\n {\n-  /* The runtime mutex is locked in this point */\n+  /* The runtime mutex is locked in this point.  */\n \n   Symtab_t symtab = module->symtab;\n   int i;\n \n-  /* Iterate thru classes defined in this module and call the callback for\n-     each one. */\n+  /* Iterate thru classes defined in this module and call the callback\n+     for each one.  */\n   for (i = 0; i < symtab->cls_def_cnt; i++)\n     {\n       Class class = (Class) symtab->defs[i];\n \n-      /* Call the _objc_load_callback for this class. */\n+      /* Call the _objc_load_callback for this class.  */\n       if (_objc_load_callback)\n-\t_objc_load_callback(class, 0);\n+\t_objc_load_callback (class, 0);\n     }\n \n-  /* Call the _objc_load_callback for categories. Don't register the instance\n-     methods as class methods for categories to root classes since they were\n-     already added in the class. */\n+  /* Call the _objc_load_callback for categories. Don't register the\n+     instance methods as class methods for categories to root classes\n+     since they were already added in the class.  */\n   for (i = 0; i < symtab->cat_def_cnt; i++)\n     {\n       Category_t category = symtab->defs[i + symtab->cls_def_cnt];\n       Class class = objc_lookup_class (category->class_name);\n       \n       if (_objc_load_callback)\n-\t_objc_load_callback(class, category);\n+\t_objc_load_callback (class, category);\n     }\n }\n \n-/* Sanity check the version of gcc used to compile `module'*/\n-static void init_check_module_version(Module_t module)\n+/* Sanity check the version of gcc used to compile `module'.  */\n+\n+static void\n+init_check_module_version (Module_t module)\n {\n   if ((module->version != OBJC_VERSION) || (module->size != sizeof (Module)))\n     {\n       int code;\n \n-      if(module->version > OBJC_VERSION)\n+      if (module->version > OBJC_VERSION)\n \tcode = OBJC_ERR_OBJC_VERSION;\n       else if (module->version < OBJC_VERSION)\n \tcode = OBJC_ERR_GCC_VERSION;\n       else\n \tcode = OBJC_ERR_MODULE_SIZE;\n \n-      objc_error(nil, code, \"Module %s version %d doesn't match runtime %d\\n\",\n-\t       module->name, (int)module->version, OBJC_VERSION);\n+      objc_error (nil, code, \"Module %s version %d doesn't match runtime %d\\n\",\n+\t\t  module->name, (int)module->version, OBJC_VERSION);\n     }\n }\n \n static void\n-__objc_init_protocols (struct objc_protocol_list* protos)\n+__objc_init_protocols (struct objc_protocol_list *protos)\n {\n   size_t i;\n   static Class proto_class = 0;\n \n   if (! protos)\n     return;\n \n-  objc_mutex_lock(__objc_runtime_mutex);\n+  objc_mutex_lock (__objc_runtime_mutex);\n \n-  if (!proto_class)\n-    proto_class = objc_lookup_class(\"Protocol\");\n+  if (! proto_class)\n+    proto_class = objc_lookup_class (\"Protocol\");\n \n-  if (!proto_class)\n+  if (! proto_class)\n     {\n       unclaimed_proto_list = list_cons (protos, unclaimed_proto_list);\n-      objc_mutex_unlock(__objc_runtime_mutex);\n+      objc_mutex_unlock (__objc_runtime_mutex);\n       return;\n     }\n \n #if 0\n   assert (protos->next == 0);\t/* only single ones allowed */\n #endif\n \n-  for(i = 0; i < protos->count; i++)\n+  for (i = 0; i < protos->count; i++)\n     {\n-      struct objc_protocol* aProto = protos->list[i];\n+      struct objc_protocol *aProto = protos->list[i];\n       if (((size_t)aProto->class_pointer) == PROTOCOL_VERSION)\n \t{\n \t  /* assign class pointer */\n@@ -813,24 +830,25 @@ __objc_init_protocols (struct objc_protocol_list* protos)\n \t}\n       else if (protos->list[i]->class_pointer != proto_class)\n \t{\n-\t  objc_error(nil, OBJC_ERR_PROTOCOL_VERSION,\n+\t  objc_error (nil, OBJC_ERR_PROTOCOL_VERSION,\n \t\t     \"Version %d doesn't match runtime protocol version %d\\n\",\n-\t\t     (int)((char*)protos->list[i]->class_pointer-(char*)0),\n+\t\t     (int) ((char *) protos->list[i]->class_pointer\n+\t\t\t    - (char *) 0),\n \t\t     PROTOCOL_VERSION);\n \t}\n     }\n \n-  objc_mutex_unlock(__objc_runtime_mutex);\n+  objc_mutex_unlock (__objc_runtime_mutex);\n }\n \n-static void __objc_class_add_protocols (Class class,\n-\t\t\t\t\tstruct objc_protocol_list* protos)\n+static void\n+__objc_class_add_protocols (Class class, struct objc_protocol_list *protos)\n {\n-  /* Well... */\n+  /* Well...  */\n   if (! protos)\n     return;\n \n-  /* Add it... */\n+  /* Add it...  */\n   protos->next = class->protocols;\n   class->protocols = protos;\n }"}, {"sha": "9572d3f00507fdfaf9a241e7578595e5d7f2eeec", "filename": "libobjc/misc.c", "status": "modified", "additions": 54, "deletions": 49, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40165636b5fb904a609e01051c2ecfd52e5617e3/libobjc%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40165636b5fb904a609e01051c2ecfd52e5617e3/libobjc%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fmisc.c?ref=40165636b5fb904a609e01051c2ecfd52e5617e3", "patch": "@@ -1,5 +1,6 @@\n /* GNU Objective C Runtime Miscellaneous \n-   Copyright (C) 1993, 1994, 1995, 1996, 1997 Free Software Foundation, Inc.\n+   Copyright (C) 1993, 1994, 1995, 1996, 1997, 2002\n+   Free Software Foundation, Inc.\n    Contributed by Kresten Krab Thorup\n \n This file is part of GNU CC.\n@@ -37,25 +38,25 @@ static objc_error_handler _objc_error_handler = NULL;\n \n /* Trigger an objc error */\n void\n-objc_error(id object, int code, const char* fmt, ...)\n+objc_error (id object, int code, const char *fmt, ...)\n {\n   va_list ap;\n \n-  va_start(ap, fmt);\n-  objc_verror(object, code, fmt, ap);\n-  va_end(ap);\n+  va_start (ap, fmt);\n+  objc_verror (object, code, fmt, ap);\n+  va_end (ap);\n }\n \n /* Trigger an objc error */\n void\n-objc_verror(id object, int code, const char* fmt, va_list ap)\n+objc_verror (id object, int code, const char *fmt, va_list ap)\n {\n   BOOL result = NO;\n \n   /* Call the error handler if its there\n      Otherwise print to stderr */\n   if (_objc_error_handler)\n-    result = (*_objc_error_handler)(object, code, fmt, ap);\n+    result = (*_objc_error_handler) (object, code, fmt, ap);\n   else\n     vfprintf (stderr, fmt, ap);\n \n@@ -64,12 +65,12 @@ objc_verror(id object, int code, const char* fmt, va_list ap)\n   if (result)\n     return;\n   else\n-    abort();\n+    abort ();\n }\n \n /* Set the error handler */\n objc_error_handler\n-objc_set_error_handler(objc_error_handler func)\n+objc_set_error_handler (objc_error_handler func)\n {\n   objc_error_handler temp = _objc_error_handler;\n   _objc_error_handler = func;\n@@ -84,54 +85,54 @@ objc_set_error_handler(objc_error_handler func)\n */\n \n void *\n-objc_malloc(size_t size)\n+objc_malloc (size_t size)\n {\n-  void* res = (void*) (*_objc_malloc)(size);\n-  if(!res)\n-    objc_error(nil, OBJC_ERR_MEMORY, \"Virtual memory exhausted\\n\");\n+  void *res = (void *) (*_objc_malloc) (size);\n+  if (! res)\n+    objc_error (nil, OBJC_ERR_MEMORY, \"Virtual memory exhausted\\n\");\n   return res;\n }\n \n void *\n-objc_atomic_malloc(size_t size)\n+objc_atomic_malloc (size_t size)\n {\n-  void* res = (void*) (*_objc_atomic_malloc)(size);\n-  if(!res)\n-    objc_error(nil, OBJC_ERR_MEMORY, \"Virtual memory exhausted\\n\");\n+  void *res = (void *) (*_objc_atomic_malloc) (size);\n+  if (! res)\n+    objc_error (nil, OBJC_ERR_MEMORY, \"Virtual memory exhausted\\n\");\n   return res;\n }\n \n void *\n-objc_valloc(size_t size)\n+objc_valloc (size_t size)\n {\n-  void* res = (void*) (*_objc_valloc)(size);\n-  if(!res)\n-    objc_error(nil, OBJC_ERR_MEMORY, \"Virtual memory exhausted\\n\");\n+  void *res = (void *) (*_objc_valloc) (size);\n+  if (! res)\n+    objc_error (nil, OBJC_ERR_MEMORY, \"Virtual memory exhausted\\n\");\n   return res;\n }\n \n void *\n-objc_realloc(void *mem, size_t size)\n+objc_realloc (void *mem, size_t size)\n {\n-  void* res = (void*) (*_objc_realloc)(mem, size);\n-  if(!res)\n-    objc_error(nil, OBJC_ERR_MEMORY, \"Virtual memory exhausted\\n\");\n+  void *res = (void *) (*_objc_realloc) (mem, size);\n+  if (! res)\n+    objc_error (nil, OBJC_ERR_MEMORY, \"Virtual memory exhausted\\n\");\n   return res;\n }\n \n void *\n-objc_calloc(size_t nelem, size_t size)\n+objc_calloc (size_t nelem, size_t size)\n {\n-  void* res = (void*) (*_objc_calloc)(nelem, size);\n-  if(!res)\n-    objc_error(nil, OBJC_ERR_MEMORY, \"Virtual memory exhausted\\n\");\n+  void *res = (void *) (*_objc_calloc) (nelem, size);\n+  if (! res)\n+    objc_error (nil, OBJC_ERR_MEMORY, \"Virtual memory exhausted\\n\");\n   return res;\n }\n \n void\n-objc_free(void *mem)\n+objc_free (void *mem)\n {\n-  (*_objc_free)(mem);\n+  (*_objc_free) (mem);\n }\n \n /*\n@@ -148,33 +149,37 @@ objc_free(void *mem)\n #if OBJC_WITH_GC\n #include <gc.h>\n \n-static void *GC_calloc (size_t nelem, size_t size)\n+static void *\n+GC_calloc (size_t nelem, size_t size)\n {\n-  void* p = GC_malloc (nelem * size);\n-  if (!p)\n+  void *p = GC_malloc (nelem * size);\n+  if (! p)\n     objc_error (nil, OBJC_ERR_MEMORY, \"Virtual memory exhausted!\\n\");\n \n   memset (p, 0, nelem * size);\n   return p;\n }\n \n-static void noFree (void* p) {}\n+static void\n+noFree (void *p)\n+{\n+}\n \n-void *(*_objc_malloc)(size_t) = GC_malloc;\n-void *(*_objc_atomic_malloc)(size_t) = GC_malloc_atomic;\n-void *(*_objc_valloc)(size_t) = GC_malloc;\n-void *(*_objc_realloc)(void *, size_t) = GC_realloc;\n-void *(*_objc_calloc)(size_t, size_t) = GC_calloc;\n-void (*_objc_free)(void *) = noFree;\n+void *(*_objc_malloc) (size_t) = GC_malloc;\n+void *(*_objc_atomic_malloc) (size_t) = GC_malloc_atomic;\n+void *(*_objc_valloc) (size_t) = GC_malloc;\n+void *(*_objc_realloc) (void *, size_t) = GC_realloc;\n+void *(*_objc_calloc) (size_t, size_t) = GC_calloc;\n+void (*_objc_free) (void *) = noFree;\n \n-#else\n+#else\t/* !OBJC_WITH_GC */\n \n-void *(*_objc_malloc)(size_t) = malloc;\n-void *(*_objc_atomic_malloc)(size_t) = malloc;\n-void *(*_objc_valloc)(size_t) = malloc;\n-void *(*_objc_realloc)(void *, size_t) = realloc;\n-void *(*_objc_calloc)(size_t, size_t) = calloc;\n-void (*_objc_free)(void *) = free;\n+void *(*_objc_malloc) (size_t) = malloc;\n+void *(*_objc_atomic_malloc) (size_t) = malloc;\n+void *(*_objc_valloc) (size_t) = malloc;\n+void *(*_objc_realloc) (void *, size_t) = realloc;\n+void *(*_objc_calloc) (size_t, size_t) = calloc;\n+void (*_objc_free) (void *) = free;\n \n \n-#endif\n+#endif\t/* !OBJC_WITH_GC */"}, {"sha": "800b0e3bf53f2befde459e5b894253ac37357a92", "filename": "libobjc/nil_method.c", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40165636b5fb904a609e01051c2ecfd52e5617e3/libobjc%2Fnil_method.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40165636b5fb904a609e01051c2ecfd52e5617e3/libobjc%2Fnil_method.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fnil_method.c?ref=40165636b5fb904a609e01051c2ecfd52e5617e3", "patch": "@@ -1,5 +1,5 @@\n /* GNU Objective C Runtime nil receiver function\n-   Copyright (C) 1993, 1995, 1996 Free Software Foundation, Inc.\n+   Copyright (C) 1993, 1995, 1996, 2002 Free Software Foundation, Inc.\n    Contributed by Kresten Krab Thorup\n \n This file is part of GNU CC.\n@@ -30,11 +30,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"runtime.h\"\n \n id\n-nil_method(id receiver, SEL op __attribute__ ((__unused__)), ...)\n+nil_method (id receiver, SEL op __attribute__ ((__unused__)), ...)\n {\n   return receiver;\n }\n-\n-\n-\n-"}, {"sha": "36a3d892137deeefab1584b1eb30743ae8f238ec", "filename": "libobjc/objc/encoding.h", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40165636b5fb904a609e01051c2ecfd52e5617e3/libobjc%2Fobjc%2Fencoding.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40165636b5fb904a609e01051c2ecfd52e5617e3/libobjc%2Fobjc%2Fencoding.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fobjc%2Fencoding.h?ref=40165636b5fb904a609e01051c2ecfd52e5617e3", "patch": "@@ -1,5 +1,5 @@\n /* Encoding of types for Objective C.\n-   Copyright (C) 1993, 1997 Free Software Foundation, Inc.\n+   Copyright (C) 1993, 1997, 2002 Free Software Foundation, Inc.\n \n Author: Kresten Krab Thorup\n \n@@ -50,30 +50,30 @@ Boston, MA 02111-1307, USA.  */\n #define _F_ONEWAY\t0x10\n #define _F_GCINVISIBLE\t0x20\n \n-int objc_aligned_size (const char* type);\n-int objc_sizeof_type (const char* type);\n-int objc_alignof_type (const char* type);\n-int objc_aligned_size (const char* type);\n-int objc_promoted_size (const char* type);\n+int objc_aligned_size (const char *type);\n+int objc_sizeof_type (const char *type);\n+int objc_alignof_type (const char *type);\n+int objc_aligned_size (const char *type);\n+int objc_promoted_size (const char *type);\n \n-const char* objc_skip_type_qualifiers (const char* type);\n-const char* objc_skip_typespec (const char* type);\n-const char* objc_skip_offset (const char* type);\n-const char* objc_skip_argspec (const char* type);\n-int method_get_number_of_arguments (struct objc_method*);\n-int method_get_sizeof_arguments (struct objc_method*);\n+const char *objc_skip_type_qualifiers (const char *type);\n+const char *objc_skip_typespec (const char *type);\n+const char *objc_skip_offset (const char *type);\n+const char *objc_skip_argspec (const char *type);\n+int method_get_number_of_arguments (struct objc_method *);\n+int method_get_sizeof_arguments (struct objc_method *);\n \n-char* method_get_first_argument (struct objc_method*,\n+char *method_get_first_argument (struct objc_method *,\n \t\t\t\t arglist_t argframe, \n-\t\t\t\t const char** type);\n-char* method_get_next_argument (arglist_t argframe, \n+\t\t\t\t const char **type);\n+char *method_get_next_argument (arglist_t argframe, \n \t\t\t\tconst char **type);\n-char* method_get_nth_argument (struct objc_method* m, \n+char *method_get_nth_argument (struct objc_method *m, \n \t\t\t       arglist_t argframe,\n \t\t\t       int arg, \n \t\t\t       const char **type);\n \n-unsigned objc_get_type_qualifiers (const char* type);\n+unsigned objc_get_type_qualifiers (const char *type);\n \n \n struct objc_struct_layout "}, {"sha": "e695012aa4376fa42d387d8dbac5813aaccc9884", "filename": "libobjc/objc/hash.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40165636b5fb904a609e01051c2ecfd52e5617e3/libobjc%2Fobjc%2Fhash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40165636b5fb904a609e01051c2ecfd52e5617e3/libobjc%2Fobjc%2Fhash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fobjc%2Fhash.h?ref=40165636b5fb904a609e01051c2ecfd52e5617e3", "patch": "@@ -60,7 +60,7 @@ typedef struct cache_node\n  * typedef.  Therefore, to remove compiler warnings the functions passed to\n  * hash_new will have to be casted to this type. \n  */\n-typedef unsigned int (*hash_func_type)(void *, const void *);\n+typedef unsigned int (*hash_func_type) (void *, const void *);\n \n /*\n  * This data type is the function that compares two hash keys and returns an\n@@ -69,7 +69,7 @@ typedef unsigned int (*hash_func_type)(void *, const void *);\n  * second. \n  */\n \n-typedef int (*compare_func_type)(const void *, const void *);\n+typedef int (*compare_func_type) (const void *, const void *);\n \n \n /*\n@@ -174,8 +174,8 @@ hash_string (cache_ptr cache, const void *key)\n   unsigned int ctr = 0;\n         \n         \n-  while (*(char*)key) {\n-    ret ^= *(char*)key++ << ctr;\n+  while (*(char *) key) {\n+    ret ^= *(char *) key++ << ctr;\n     ctr = (ctr + 1) % sizeof (void *);\n   }\n \n@@ -187,7 +187,7 @@ hash_string (cache_ptr cache, const void *key)\n static inline int \n compare_ptrs (const void *k1, const void *k2)\n {\n-  return !(k1 - k2);\n+  return ! (k1 - k2);\n }\n \n \n@@ -200,7 +200,7 @@ compare_strings (const void *k1, const void *k2)\n   else if (k1 == 0 || k2 == 0)\n     return 0;\n   else\n-    return !strcmp (k1, k2);\n+    return ! strcmp (k1, k2);\n }\n \n "}, {"sha": "48ad0befa0df3d831639c81e1320df1b4f5b6248", "filename": "libobjc/objc/thr.h", "status": "modified", "additions": 43, "deletions": 43, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40165636b5fb904a609e01051c2ecfd52e5617e3/libobjc%2Fobjc%2Fthr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40165636b5fb904a609e01051c2ecfd52e5617e3/libobjc%2Fobjc%2Fthr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fobjc%2Fthr.h?ref=40165636b5fb904a609e01051c2ecfd52e5617e3", "patch": "@@ -1,5 +1,5 @@\n /* Thread and mutex controls for Objective C.\n-   Copyright (C) 1996, 1997 Free Software Foundation, Inc.\n+   Copyright (C) 1996, 1997, 2002 Free Software Foundation, Inc.\n    Contributed by Galen C. Hunt (gchunt@cs.rochester.edu)\n \n This file is part of GNU CC.\n@@ -74,30 +74,30 @@ struct objc_condition\n typedef struct objc_condition *objc_condition_t;\n \n /* Frontend mutex functions */\n-objc_mutex_t objc_mutex_allocate(void);\n-int objc_mutex_deallocate(objc_mutex_t mutex);\n-int objc_mutex_lock(objc_mutex_t mutex);\n-int objc_mutex_unlock(objc_mutex_t mutex);\n-int objc_mutex_trylock(objc_mutex_t mutex);\n+objc_mutex_t objc_mutex_allocate (void);\n+int objc_mutex_deallocate (objc_mutex_t mutex);\n+int objc_mutex_lock (objc_mutex_t mutex);\n+int objc_mutex_unlock (objc_mutex_t mutex);\n+int objc_mutex_trylock (objc_mutex_t mutex);\n \n /* Frontend condition mutex functions */\n-objc_condition_t objc_condition_allocate(void);\n-int objc_condition_deallocate(objc_condition_t condition);\n-int objc_condition_wait(objc_condition_t condition, objc_mutex_t mutex);\n-int objc_condition_signal(objc_condition_t condition);\n-int objc_condition_broadcast(objc_condition_t condition);\n+objc_condition_t objc_condition_allocate (void);\n+int objc_condition_deallocate (objc_condition_t condition);\n+int objc_condition_wait (objc_condition_t condition, objc_mutex_t mutex);\n+int objc_condition_signal (objc_condition_t condition);\n+int objc_condition_broadcast (objc_condition_t condition);\n \n /* Frontend thread functions */\n-objc_thread_t objc_thread_detach(SEL selector, id object, id argument);\n-void objc_thread_yield(void);\n-int objc_thread_exit(void);\n-int objc_thread_set_priority(int priority);\n-int objc_thread_get_priority(void);\n-void * objc_thread_get_data(void);\n-int objc_thread_set_data(void *value);\n-objc_thread_t objc_thread_id(void);\n-void objc_thread_add(void);\n-void objc_thread_remove(void);\n+objc_thread_t objc_thread_detach (SEL selector, id object, id argument);\n+void objc_thread_yield (void);\n+int objc_thread_exit (void);\n+int objc_thread_set_priority (int priority);\n+int objc_thread_get_priority (void);\n+void * objc_thread_get_data (void);\n+int objc_thread_set_data (void *value);\n+objc_thread_t objc_thread_id (void);\n+void objc_thread_add (void);\n+void objc_thread_remove (void);\n \n /*\n   Use this to set the hook function that will be called when the \n@@ -111,35 +111,35 @@ void objc_thread_remove(void);\n   it can be informed; for example, the GNUstep Base Library sets it \n   so it can implement the NSBecomingMultiThreaded notification.\n   */\n-typedef void (*objc_thread_callback)(void);\n-objc_thread_callback objc_set_thread_callback(objc_thread_callback func);\n+typedef void (*objc_thread_callback) (void);\n+objc_thread_callback objc_set_thread_callback (objc_thread_callback func);\n \n /* Backend initialization functions */\n-int __objc_init_thread_system(void);\n-int __objc_fini_thread_system(void);\n+int __objc_init_thread_system (void);\n+int __objc_fini_thread_system (void);\n \n /* Backend mutex functions */\n-int __objc_mutex_allocate(objc_mutex_t mutex);\n-int __objc_mutex_deallocate(objc_mutex_t mutex);\n-int __objc_mutex_lock(objc_mutex_t mutex);\n-int __objc_mutex_trylock(objc_mutex_t mutex);\n-int __objc_mutex_unlock(objc_mutex_t mutex);\n+int __objc_mutex_allocate (objc_mutex_t mutex);\n+int __objc_mutex_deallocate (objc_mutex_t mutex);\n+int __objc_mutex_lock (objc_mutex_t mutex);\n+int __objc_mutex_trylock (objc_mutex_t mutex);\n+int __objc_mutex_unlock (objc_mutex_t mutex);\n \n /* Backend condition mutex functions */\n-int __objc_condition_allocate(objc_condition_t condition);\n-int __objc_condition_deallocate(objc_condition_t condition);\n-int __objc_condition_wait(objc_condition_t condition, objc_mutex_t mutex);\n-int __objc_condition_broadcast(objc_condition_t condition);\n-int __objc_condition_signal(objc_condition_t condition);\n+int __objc_condition_allocate (objc_condition_t condition);\n+int __objc_condition_deallocate (objc_condition_t condition);\n+int __objc_condition_wait (objc_condition_t condition, objc_mutex_t mutex);\n+int __objc_condition_broadcast (objc_condition_t condition);\n+int __objc_condition_signal (objc_condition_t condition);\n \n /* Backend thread functions */\n-objc_thread_t __objc_thread_detach(void (*func)(void *arg), void *arg);\n-int __objc_thread_set_priority(int priority);\n-int __objc_thread_get_priority(void);\n-void __objc_thread_yield(void);\n-int __objc_thread_exit(void);\n-objc_thread_t __objc_thread_id(void);\n-int __objc_thread_set_data(void *value);\n-void * __objc_thread_get_data(void);\n+objc_thread_t __objc_thread_detach (void (*func) (void *arg), void *arg);\n+int __objc_thread_set_priority (int priority);\n+int __objc_thread_get_priority (void);\n+void __objc_thread_yield (void);\n+int __objc_thread_exit (void);\n+objc_thread_t __objc_thread_id (void);\n+int __objc_thread_set_data (void *value);\n+void * __objc_thread_get_data (void);\n \n #endif /* not __thread_INCLUDE_GNU */"}, {"sha": "6858fed201317cc32aecc684647389c0c4abf447", "filename": "libobjc/objects.c", "status": "modified", "additions": 27, "deletions": 29, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40165636b5fb904a609e01051c2ecfd52e5617e3/libobjc%2Fobjects.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40165636b5fb904a609e01051c2ecfd52e5617e3/libobjc%2Fobjects.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fobjects.c?ref=40165636b5fb904a609e01051c2ecfd52e5617e3", "patch": "@@ -32,29 +32,29 @@ Boston, MA 02111-1307, USA.  */\n # include <gc.h>\n #endif\n \n-id __objc_object_alloc(Class);\n-id __objc_object_dispose(id);\n-id __objc_object_copy(id);\n+id __objc_object_alloc (Class);\n+id __objc_object_dispose (id);\n+id __objc_object_copy (id);\n \n-id (*_objc_object_alloc)(Class)   = __objc_object_alloc;   /* !T:SINGLE */ \n-id (*_objc_object_dispose)(id)    = __objc_object_dispose; /* !T:SINGLE */\n-id (*_objc_object_copy)(id)       = __objc_object_copy;    /* !T:SINGLE */\n+id (*_objc_object_alloc) (Class)   = __objc_object_alloc;   /* !T:SINGLE */ \n+id (*_objc_object_dispose) (id)    = __objc_object_dispose; /* !T:SINGLE */\n+id (*_objc_object_copy) (id)       = __objc_object_copy;    /* !T:SINGLE */\n \n id\n-class_create_instance(Class class)\n+class_create_instance (Class class)\n {\n   id new = nil;\n \n #if OBJC_WITH_GC\n-  if (CLS_ISCLASS(class))\n-    new = (id)GC_malloc_explicitly_typed (class->instance_size,\n-\t\t\t\t\t  class->gc_object_type);\n+  if (CLS_ISCLASS (class))\n+    new = (id) GC_malloc_explicitly_typed (class->instance_size,\n+\t\t\t\t\t   class->gc_object_type);\n #else\n-  if (CLS_ISCLASS(class))\n-    new = (*_objc_object_alloc)(class);\n+  if (CLS_ISCLASS (class))\n+    new = (*_objc_object_alloc) (class);\n #endif\n \n-  if (new!=nil)\n+  if (new != nil)\n     {\n       memset (new, 0, class->instance_size);\n       new->class_pointer = class;\n@@ -63,43 +63,41 @@ class_create_instance(Class class)\n }\n \n id\n-object_copy(id object)\n+object_copy (id object)\n {\n-  if ((object!=nil)&&CLS_ISCLASS(object->class_pointer))\n-    return (*_objc_object_copy)(object);\n+  if ((object != nil) && CLS_ISCLASS (object->class_pointer))\n+    return (*_objc_object_copy) (object);\n   else\n     return nil;\n }\n \n id\n-object_dispose(id object)\n+object_dispose (id object)\n {\n-  if ((object!=nil)&&CLS_ISCLASS(object->class_pointer))\n+  if ((object != nil) && CLS_ISCLASS (object->class_pointer))\n     {\n       if (_objc_object_dispose)\n-        (*_objc_object_dispose)(object);\n+        (*_objc_object_dispose) (object);\n       else\n-        objc_free(object);\n+        objc_free (object);\n     }\n   return nil;\n }\n \n-id __objc_object_alloc(Class class)\n+id __objc_object_alloc (Class class)\n {\n-  return (id)objc_malloc(class->instance_size);\n+  return (id) objc_malloc (class->instance_size);\n }\n \n-id __objc_object_dispose(id object) \n+id __objc_object_dispose (id object) \n {\n-  objc_free(object);\n+  objc_free (object);\n   return 0;\n }\n \n-id __objc_object_copy(id object)\n+id __objc_object_copy (id object)\n {\n-  id copy = class_create_instance(object->class_pointer);\n-  memcpy(copy, object, object->class_pointer->instance_size);\n+  id copy = class_create_instance (object->class_pointer);\n+  memcpy (copy, object, object->class_pointer->instance_size);\n   return copy;\n }\n-\n-"}, {"sha": "e78e36d01f186798a84355842e847ecdd34f142c", "filename": "libobjc/sarray.c", "status": "modified", "additions": 121, "deletions": 124, "changes": 245, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40165636b5fb904a609e01051c2ecfd52e5617e3/libobjc%2Fsarray.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40165636b5fb904a609e01051c2ecfd52e5617e3/libobjc%2Fsarray.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fsarray.c?ref=40165636b5fb904a609e01051c2ecfd52e5617e3", "patch": "@@ -1,5 +1,5 @@\n /* Sparse Arrays for Objective C dispatch tables\n-   Copyright (C) 1993, 1995, 1996 Free Software Foundation, Inc.\n+   Copyright (C) 1993, 1995, 1996, 2002 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -34,70 +34,70 @@ int nindices = 0;\t\t\t\t\t/* !T:MUTEX */\n int narrays = 0;\t\t\t\t\t/* !T:MUTEX */\n int idxsize = 0;\t\t\t\t\t/* !T:MUTEX */\n \n-static void *\tfirst_free_data = NULL;\t\t\t/* !T:MUTEX */\n+static void *first_free_data = NULL;\t\t\t/* !T:MUTEX */\n \n #ifdef OBJC_SPARSE2\n-const char* __objc_sparse2_id = \"2 level sparse indices\";\n+const char *__objc_sparse2_id = \"2 level sparse indices\";\n #endif\n \n #ifdef OBJC_SPARSE3\n-const char* __objc_sparse3_id = \"3 level sparse indices\";\n+const char *__objc_sparse3_id = \"3 level sparse indices\";\n #endif\n \n /* This function removes any structures left over from free operations\n    that were not safe in a multi-threaded environment. */\n void\n-sarray_remove_garbage(void)\n+sarray_remove_garbage (void)\n {\n   void **vp;\n   void *np;\n   \n-  objc_mutex_lock(__objc_runtime_mutex);\n+  objc_mutex_lock (__objc_runtime_mutex);\n \n   vp = first_free_data;\n   first_free_data = NULL;\n \n   while (vp) {\n     np = *vp;\n-    objc_free(vp);\n+    objc_free (vp);\n     vp = np;\n   }\n   \n-  objc_mutex_unlock(__objc_runtime_mutex);\n+  objc_mutex_unlock (__objc_runtime_mutex);\n }\n \n /* Free a block of dynamically allocated memory.  If we are in multi-threaded\n    mode, it is ok to free it.  If not, we add it to the garbage heap to be\n    freed later. */\n \n static void\n-sarray_free_garbage(void *vp)\n+sarray_free_garbage (void *vp)\n {\n-  objc_mutex_lock(__objc_runtime_mutex);\n+  objc_mutex_lock (__objc_runtime_mutex);\n   \n   if (__objc_runtime_threads_alive == 1) {\n-    objc_free(vp);\n+    objc_free (vp);\n     if (first_free_data)\n-      sarray_remove_garbage();\n+      sarray_remove_garbage ();\n   }\n   else {\n     *(void **)vp = first_free_data;\n     first_free_data = vp;\n   }\n       \n-  objc_mutex_unlock(__objc_runtime_mutex);\n+  objc_mutex_unlock (__objc_runtime_mutex);\n }\n \n /* sarray_at_put : copies data in such a way as to be thread reader safe. */\n void\n-sarray_at_put(struct sarray* array, sidx index, void* element)\n+sarray_at_put (struct sarray *array, sidx index, void *element)\n {\n #ifdef OBJC_SPARSE3\n-  struct sindex** the_index;\n-  struct sindex*  new_index;\n+  struct sindex **the_index;\n+  struct sindex *new_index;\n #endif\n-  struct sbucket** the_bucket;\n-  struct sbucket*  new_bucket;\n+  struct sbucket **the_bucket;\n+  struct sbucket *new_bucket;\n #ifdef OBJC_SPARSE3\n   size_t ioffset;\n #endif\n@@ -122,7 +122,7 @@ sarray_at_put(struct sarray* array, sidx index, void* element)\n #endif\n #endif /* not PRECOMPUTE_SELECTORS */\n \n-  assert(soffset_decode(index) < array->capacity); /* Range check */\n+  assert (soffset_decode (index) < array->capacity); /* Range check */\n \n #ifdef OBJC_SPARSE3\n   the_index = &(array->indices[ioffset]);\n@@ -141,8 +141,8 @@ sarray_at_put(struct sarray* array, sidx index, void* element)\n   if ((*the_index) == array->empty_index) {\n \n     /* The index was previously empty, allocate a new */\n-    new_index = (struct sindex*)objc_malloc(sizeof(struct sindex));\n-    memcpy(new_index, array->empty_index, sizeof(struct sindex));\n+    new_index = (struct sindex *) objc_malloc (sizeof (struct sindex));\n+    memcpy (new_index, array->empty_index, sizeof (struct sindex));\n     new_index->version.version = array->version.version;\n     *the_index = new_index;                     /* Prepared for install. */\n     the_bucket = &((*the_index)->buckets[boffset]);\n@@ -151,9 +151,9 @@ sarray_at_put(struct sarray* array, sidx index, void* element)\n   } else if ((*the_index)->version.version != array->version.version) {\n \n     /* This index must be lazy copied */\n-    struct sindex* old_index = *the_index;\n-    new_index = (struct sindex*)objc_malloc(sizeof(struct sindex));\n-    memcpy( new_index, old_index, sizeof(struct sindex));\n+    struct sindex *old_index = *the_index;\n+    new_index = (struct sindex *) objc_malloc (sizeof (struct sindex));\n+    memcpy (new_index, old_index, sizeof (struct sindex));\n     new_index->version.version = array->version.version;\n     *the_index = new_index;                     /* Prepared for install. */\n     the_bucket = &((*the_index)->buckets[boffset]);\n@@ -169,9 +169,9 @@ sarray_at_put(struct sarray* array, sidx index, void* element)\n \n     /* The bucket was previously empty (or something like that), */\n     /* allocate a new.  This is the effect of `lazy' allocation */  \n-    new_bucket = (struct sbucket*)objc_malloc(sizeof(struct sbucket));\n-    memcpy((void *) new_bucket, (const void*)array->empty_bucket, \n-\t   sizeof(struct sbucket));\n+    new_bucket = (struct sbucket *) objc_malloc (sizeof (struct sbucket));\n+    memcpy ((void *) new_bucket, (const void *) array->empty_bucket, \n+\t    sizeof (struct sbucket));\n     new_bucket->version.version = array->version.version;\n     *the_bucket = new_bucket;                   /* Prepared for install. */\n     \n@@ -180,9 +180,9 @@ sarray_at_put(struct sarray* array, sidx index, void* element)\n   } else if ((*the_bucket)->version.version != array->version.version) {\n \n     /* Perform lazy copy. */\n-    struct sbucket* old_bucket = *the_bucket;\n-    new_bucket = (struct sbucket*)objc_malloc(sizeof(struct sbucket));\n-    memcpy( new_bucket, old_bucket, sizeof(struct sbucket));\n+    struct sbucket *old_bucket = *the_bucket;\n+    new_bucket = (struct sbucket *) objc_malloc (sizeof (struct sbucket));\n+    memcpy (new_bucket, old_bucket, sizeof (struct sbucket));\n     new_bucket->version.version = array->version.version;\n     *the_bucket = new_bucket;                   /* Prepared for install. */\n     \n@@ -193,39 +193,39 @@ sarray_at_put(struct sarray* array, sidx index, void* element)\n }\n \n void\n-sarray_at_put_safe(struct sarray* array, sidx index, void* element)\n+sarray_at_put_safe (struct sarray *array, sidx index, void *element)\n {\n-  if(soffset_decode(index) >= array->capacity)\n-    sarray_realloc(array, soffset_decode(index)+1);\n-  sarray_at_put(array, index, element);\n+  if (soffset_decode (index) >= array->capacity)\n+    sarray_realloc (array, soffset_decode (index) + 1);\n+  sarray_at_put (array, index, element);\n }\n \n-struct sarray* \n-sarray_new (int size, void* default_element)\n+struct sarray *\n+sarray_new (int size, void *default_element)\n {\n-  struct sarray* arr;\n+  struct sarray *arr;\n #ifdef OBJC_SPARSE3\n-  size_t num_indices = ((size-1)/(INDEX_CAPACITY))+1;\n-  struct sindex ** new_indices;\n+  size_t num_indices = ((size - 1)/(INDEX_CAPACITY)) + 1;\n+  struct sindex **new_indices;\n #else /* OBJC_SPARSE2 */\n-  size_t num_indices = ((size-1)/BUCKET_SIZE)+1;\n-  struct sbucket ** new_buckets;\n+  size_t num_indices = ((size - 1)/BUCKET_SIZE) + 1;\n+  struct sbucket **new_buckets;\n #endif\n   size_t counter;\n \n-  assert(size > 0);\n+  assert (size > 0);\n \n   /* Allocate core array */\n-  arr = (struct sarray*) objc_malloc(sizeof(struct sarray));\n+  arr = (struct sarray *) objc_malloc (sizeof (struct sarray));\n   arr->version.version = 0;\n   \n   /* Initialize members */\n #ifdef OBJC_SPARSE3\n   arr->capacity = num_indices*INDEX_CAPACITY;\n-  new_indices = (struct sindex**) \n-    objc_malloc(sizeof(struct sindex*)*num_indices);\n+  new_indices = (struct sindex **) \n+    objc_malloc (sizeof (struct sindex *) * num_indices);\n \n-  arr->empty_index = (struct sindex*) objc_malloc(sizeof(struct sindex));\n+  arr->empty_index = (struct sindex *) objc_malloc (sizeof (struct sindex));\n   arr->empty_index->version.version = 0;\n   \n   narrays  += 1;\n@@ -234,35 +234,35 @@ sarray_new (int size, void* default_element)\n \n #else /* OBJC_SPARSE2 */\n   arr->capacity = num_indices*BUCKET_SIZE;\n-  new_buckets = (struct sbucket**) \n-    objc_malloc(sizeof(struct sbucket*)*num_indices);\n+  new_buckets = (struct sbucket **) \n+    objc_malloc (sizeof (struct sbucket *) * num_indices);\n   \n   narrays  += 1;\n   idxsize  += num_indices;\n \n #endif\n \n-  arr->empty_bucket = (struct sbucket*) objc_malloc(sizeof(struct sbucket));\n+  arr->empty_bucket = (struct sbucket *) objc_malloc (sizeof (struct sbucket));\n   arr->empty_bucket->version.version = 0;\n   \n   nbuckets += 1;\n \n   arr->ref_count = 1;\n-  arr->is_copy_of = (struct sarray*)0;\n+  arr->is_copy_of = (struct sarray *) 0;\n   \n-  for (counter=0; counter<BUCKET_SIZE; counter++)\n+  for (counter = 0; counter < BUCKET_SIZE; counter++)\n     arr->empty_bucket->elems[counter] = default_element;\n \n #ifdef OBJC_SPARSE3\n-  for (counter=0; counter<INDEX_SIZE; counter++)\n+  for (counter = 0; counter < INDEX_SIZE; counter++)\n     arr->empty_index->buckets[counter] = arr->empty_bucket;\n \n-  for (counter=0; counter<num_indices; counter++)\n+  for (counter = 0; counter < num_indices; counter++)\n     new_indices[counter] = arr->empty_index;\n \n #else /* OBJC_SPARSE2 */\n \n-  for (counter=0; counter<num_indices; counter++)\n+  for (counter = 0; counter < num_indices; counter++)\n     new_buckets[counter] = arr->empty_bucket;\n \n #endif\n@@ -282,48 +282,48 @@ sarray_new (int size, void* default_element)\n    any concurrent readers notice the update. */\n \n void \n-sarray_realloc(struct sarray* array, int newsize)\n+sarray_realloc (struct sarray *array, int newsize)\n {\n #ifdef OBJC_SPARSE3\n-  size_t old_max_index = (array->capacity-1)/INDEX_CAPACITY;\n-  size_t new_max_index = ((newsize-1)/INDEX_CAPACITY);\n-  size_t rounded_size = (new_max_index+1)*INDEX_CAPACITY;\n+  size_t old_max_index = (array->capacity - 1)/INDEX_CAPACITY;\n+  size_t new_max_index = ((newsize - 1)/INDEX_CAPACITY);\n+  size_t rounded_size = (new_max_index + 1) * INDEX_CAPACITY;\n \n-  struct sindex ** new_indices;\n-  struct sindex ** old_indices;\n+  struct sindex **new_indices;\n+  struct sindex **old_indices;\n   \n #else /* OBJC_SPARSE2 */\n-  size_t old_max_index = (array->capacity-1)/BUCKET_SIZE;\n-  size_t new_max_index = ((newsize-1)/BUCKET_SIZE);\n-  size_t rounded_size = (new_max_index+1)*BUCKET_SIZE;\n+  size_t old_max_index = (array->capacity - 1)/BUCKET_SIZE;\n+  size_t new_max_index = ((newsize - 1)/BUCKET_SIZE);\n+  size_t rounded_size = (new_max_index + 1) * BUCKET_SIZE;\n \n-  struct sbucket ** new_buckets;\n-  struct sbucket ** old_buckets;\n+  struct sbucket **new_buckets;\n+  struct sbucket **old_buckets;\n   \n #endif\n \n   size_t counter;\n \n-  assert(newsize > 0);\n+  assert (newsize > 0);\n \n   /* The size is the same, just ignore the request */\n-  if(rounded_size <= array->capacity)\n+  if (rounded_size <= array->capacity)\n     return;\n \n-  assert(array->ref_count == 1);\t/* stop if lazy copied... */\n+  assert (array->ref_count == 1);\t/* stop if lazy copied... */\n \n   /* We are asked to extend the array -- allocate new bucket table, */\n   /* and insert empty_bucket in newly allocated places. */\n-  if(rounded_size > array->capacity) \n+  if (rounded_size > array->capacity) \n     {\n \n #ifdef OBJC_SPARSE3\n       new_max_index += 4;\n-      rounded_size = (new_max_index+1)*INDEX_CAPACITY;\n+      rounded_size = (new_max_index + 1) * INDEX_CAPACITY;\n       \n #else /* OBJC_SPARSE2 */\n       new_max_index += 4;\n-      rounded_size = (new_max_index+1)*BUCKET_SIZE;\n+      rounded_size = (new_max_index + 1) * BUCKET_SIZE;\n #endif\n       \n       /* update capacity */\n@@ -332,16 +332,16 @@ sarray_realloc(struct sarray* array, int newsize)\n #ifdef OBJC_SPARSE3\n       /* alloc to force re-read by any concurrent readers. */\n       old_indices = array->indices;\n-      new_indices = (struct sindex**)\n-\tobjc_malloc((new_max_index+1)*sizeof(struct sindex*));\n+      new_indices = (struct sindex **)\n+\tobjc_malloc ((new_max_index + 1) * sizeof (struct sindex *));\n #else /* OBJC_SPARSE2 */\n       old_buckets = array->buckets;\n-      new_buckets = (struct sbucket**)\n-\tobjc_malloc((new_max_index+1)*sizeof(struct sbucket*));\n+      new_buckets = (struct sbucket **)\n+\tobjc_malloc ((new_max_index + 1) * sizeof (struct sbucket *));\n #endif\n \n       /* copy buckets below old_max_index (they are still valid) */\n-      for(counter = 0; counter <= old_max_index; counter++ ) {\n+      for (counter = 0; counter <= old_max_index; counter++ ) {\n #ifdef OBJC_SPARSE3\n \tnew_indices[counter] = old_indices[counter];\n #else /* OBJC_SPARSE2 */\n@@ -351,11 +351,11 @@ sarray_realloc(struct sarray* array, int newsize)\n \n #ifdef OBJC_SPARSE3\n       /* reset entries above old_max_index to empty_bucket */\n-      for(counter = old_max_index+1; counter <= new_max_index; counter++)\n+      for (counter = old_max_index + 1; counter <= new_max_index; counter++)\n \tnew_indices[counter] = array->empty_index;\n #else /* OBJC_SPARSE2 */\n       /* reset entries above old_max_index to empty_bucket */\n-      for(counter = old_max_index+1; counter <= new_max_index; counter++)\n+      for (counter = old_max_index + 1; counter <= new_max_index; counter++)\n \tnew_buckets[counter] = array->empty_bucket;\n #endif\n       \n@@ -368,9 +368,9 @@ sarray_realloc(struct sarray* array, int newsize)\n \n #ifdef OBJC_SPARSE3\n       /* free the old indices */\n-      sarray_free_garbage(old_indices);\n+      sarray_free_garbage (old_indices);\n #else /* OBJC_SPARSE2 */\n-      sarray_free_garbage(old_buckets);\n+      sarray_free_garbage (old_buckets);\n #endif\n       \n       idxsize += (new_max_index-old_max_index);\n@@ -382,20 +382,19 @@ sarray_realloc(struct sarray* array, int newsize)\n /* Free a sparse array allocated with sarray_new */\n \n void \n-sarray_free(struct sarray* array)\n-{\n+sarray_free (struct sarray *array) {\n #ifdef OBJC_SPARSE3\n-  size_t old_max_index = (array->capacity-1)/INDEX_CAPACITY;\n-  struct sindex ** old_indices;\n+  size_t old_max_index = (array->capacity - 1)/INDEX_CAPACITY;\n+  struct sindex **old_indices;\n #else\n-  size_t old_max_index = (array->capacity-1)/BUCKET_SIZE;\n-  struct sbucket ** old_buckets;\n+  size_t old_max_index = (array->capacity - 1)/BUCKET_SIZE;\n+  struct sbucket **old_buckets;\n #endif\n   size_t counter = 0;\n \n-  assert(array->ref_count != 0);\t/* Freed multiple times!!! */\n+  assert (array->ref_count != 0);\t/* Freed multiple times!!! */\n \n-  if(--(array->ref_count) != 0)\t/* There exists copies of me */\n+  if (--(array->ref_count) != 0)\t/* There exists copies of me */\n     return;\n \n #ifdef OBJC_SPARSE3\n@@ -404,87 +403,87 @@ sarray_free(struct sarray* array)\n   old_buckets = array->buckets;\n #endif\n   \n-  if((array->is_copy_of) && ((array->is_copy_of->ref_count - 1) == 0))\n-    sarray_free(array->is_copy_of);\n+  if ((array->is_copy_of) && ((array->is_copy_of->ref_count - 1) == 0))\n+    sarray_free (array->is_copy_of);\n \n   /* Free all entries that do not point to empty_bucket */\n-  for(counter = 0; counter <= old_max_index; counter++ ) {\n+  for (counter = 0; counter <= old_max_index; counter++ ) {\n #ifdef OBJC_SPARSE3\n-    struct sindex* idx = old_indices[counter];\n-    if((idx != array->empty_index) &&\n+    struct sindex *idx = old_indices[counter];\n+    if ((idx != array->empty_index) &&\n        (idx->version.version == array->version.version)) {\n       int c2; \n-      for(c2=0; c2<INDEX_SIZE; c2++) {\n-\tstruct sbucket* bkt = idx->buckets[c2];\n-\tif((bkt != array->empty_bucket) &&\n+      for (c2 = 0; c2 < INDEX_SIZE; c2++) {\n+\tstruct sbucket *bkt = idx->buckets[c2];\n+\tif ((bkt != array->empty_bucket) &&\n \t   (bkt->version.version == array->version.version))\n \t  {\n-\t    sarray_free_garbage(bkt);\n+\t    sarray_free_garbage (bkt);\n \t    nbuckets -= 1;\n \t  }\n       }\n-      sarray_free_garbage(idx);\n+      sarray_free_garbage (idx);\n       nindices -= 1;\n     }\n #else /* OBJC_SPARSE2 */\n-    struct sbucket* bkt = array->buckets[counter];\n+    struct sbucket *bkt = array->buckets[counter];\n     if ((bkt != array->empty_bucket) &&\n \t(bkt->version.version == array->version.version))\n       {\n-\tsarray_free_garbage(bkt);\n+\tsarray_free_garbage (bkt);\n \tnbuckets -= 1;\n       }\n #endif\n   }\n \t\n #ifdef OBJC_SPARSE3  \n   /* free empty_index */\n-  if(array->empty_index->version.version == array->version.version) {\n-    sarray_free_garbage(array->empty_index);\n+  if (array->empty_index->version.version == array->version.version) {\n+    sarray_free_garbage (array->empty_index);\n     nindices -= 1;\n   }\n #endif\n \n   /* free empty_bucket */\n-  if(array->empty_bucket->version.version == array->version.version) {\n-    sarray_free_garbage(array->empty_bucket);\n+  if (array->empty_bucket->version.version == array->version.version) {\n+    sarray_free_garbage (array->empty_bucket);\n     nbuckets -= 1;\n   }\n-  idxsize -= (old_max_index+1);\n+  idxsize -= (old_max_index + 1);\n   narrays -= 1;\n \n #ifdef OBJC_SPARSE3\n   /* free bucket table */\n-  sarray_free_garbage(array->indices);\n+  sarray_free_garbage (array->indices);\n \n #else\n   /* free bucket table */\n-  sarray_free_garbage(array->buckets);\n+  sarray_free_garbage (array->buckets);\n \n #endif\n   \n   /* free array */\n-  sarray_free_garbage(array);\n+  sarray_free_garbage (array);\n }\n \n /* This is a lazy copy.  Only the core of the structure is actually */\n /* copied.   */\n \n-struct sarray* \n-sarray_lazy_copy(struct sarray* oarr)\n+struct sarray *\n+sarray_lazy_copy (struct sarray *oarr)\n {\n-  struct sarray* arr;\n+  struct sarray *arr;\n \n #ifdef OBJC_SPARSE3\n-  size_t num_indices = ((oarr->capacity-1)/INDEX_CAPACITY)+1;\n-  struct sindex ** new_indices;\n+  size_t num_indices = ((oarr->capacity - 1)/INDEX_CAPACITY) + 1;\n+  struct sindex **new_indices;\n #else /* OBJC_SPARSE2 */\n-  size_t num_indices = ((oarr->capacity-1)/BUCKET_SIZE)+1;\n-  struct sbucket ** new_buckets;\n+  size_t num_indices = ((oarr->capacity - 1)/BUCKET_SIZE) + 1;\n+  struct sbucket **new_buckets;\n #endif\n \n   /* Allocate core array */\n-  arr = (struct sarray*) objc_malloc(sizeof(struct sarray)); /* !!! */\n+  arr = (struct sarray *) objc_malloc (sizeof (struct sarray)); /* !!! */\n   arr->version.version = oarr->version.version + 1;\n #ifdef OBJC_SPARSE3\n   arr->empty_index = oarr->empty_index;\n@@ -497,17 +496,15 @@ sarray_lazy_copy(struct sarray* oarr)\n   \n #ifdef OBJC_SPARSE3\n   /* Copy bucket table */\n-  new_indices = (struct sindex**) \n-    objc_malloc(sizeof(struct sindex*)*num_indices);\n-  memcpy( new_indices,oarr->indices, \n-\tsizeof(struct sindex*)*num_indices);\n+  new_indices = (struct sindex **) \n+    objc_malloc (sizeof (struct sindex *) * num_indices);\n+  memcpy (new_indices, oarr->indices, sizeof (struct sindex *) * num_indices);\n   arr->indices = new_indices;\n #else \n   /* Copy bucket table */\n-  new_buckets = (struct sbucket**) \n-    objc_malloc(sizeof(struct sbucket*)*num_indices);\n-  memcpy( new_buckets,oarr->buckets, \n-\tsizeof(struct sbucket*)*num_indices);\n+  new_buckets = (struct sbucket **) \n+    objc_malloc (sizeof (struct sbucket *) * num_indices);\n+  memcpy (new_buckets, oarr->buckets, sizeof (struct sbucket *) * num_indices);\n   arr->buckets = new_buckets;\n #endif\n "}, {"sha": "5f5a26bc9af00db55337ccba9cc38b9d96bca55b", "filename": "libobjc/selector.c", "status": "modified", "additions": 71, "deletions": 74, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40165636b5fb904a609e01051c2ecfd52e5617e3/libobjc%2Fselector.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40165636b5fb904a609e01051c2ecfd52e5617e3/libobjc%2Fselector.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fselector.c?ref=40165636b5fb904a609e01051c2ecfd52e5617e3", "patch": "@@ -31,16 +31,16 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n #define SELECTOR_HASH_SIZE 128\n \n /* Tables mapping selector names to uid and opposite */\n-static struct sarray* __objc_selector_array = 0; /* uid -> sel  !T:MUTEX */\n-static struct sarray* __objc_selector_names = 0; /* uid -> name !T:MUTEX */\n+static struct sarray *__objc_selector_array = 0; /* uid -> sel  !T:MUTEX */\n+static struct sarray *__objc_selector_names = 0; /* uid -> name !T:MUTEX */\n static cache_ptr      __objc_selector_hash  = 0; /* name -> uid !T:MUTEX */\n \n-static void register_selectors_from_list(MethodList_t);\n+static void register_selectors_from_list (MethodList_t);\n \n /* Number of selectors stored in each of the above tables */\n unsigned int __objc_selector_max_index = 0;     /* !T:MUTEX */\n \n-void __objc_init_selector_tables()\n+void __objc_init_selector_tables ()\n {\n   __objc_selector_array = sarray_new (SELECTOR_HASH_SIZE, 0);\n   __objc_selector_names = sarray_new (SELECTOR_HASH_SIZE, 0);\n@@ -81,15 +81,15 @@ register_selectors_from_list (MethodList_t method_list)\n     {\n       Method_t method = &method_list->method_list[i];\n       method->method_name \n-\t= sel_register_typed_name ((const char*)method->method_name, \n-\t\t\t\t     method->method_types);\n+\t= sel_register_typed_name ((const char *) method->method_name, \n+\t\t\t\t   method->method_types);\n       i += 1;\n     }\n }\n \n \n /* Register instance methods as class methods for root classes */\n-void __objc_register_instance_methods_to_class(Class class)\n+void __objc_register_instance_methods_to_class (Class class)\n {\n   MethodList_t method_list;\n   MethodList_t class_method_list;\n@@ -98,12 +98,12 @@ void __objc_register_instance_methods_to_class(Class class)\n   Method_t curr_method;\n \n   /* Only if a root class. */\n-  if(class->super_class)\n+  if (class->super_class)\n     return;\n \n   /* Allocate a method list to hold the new class methods */\n-  new_list = objc_calloc(sizeof(struct objc_method_list)\n-\t\t\t    + sizeof(struct objc_method[max_methods_no]), 1);\n+  new_list = objc_calloc (sizeof (struct objc_method_list)\n+\t\t\t    + sizeof (struct objc_method[max_methods_no]), 1);\n   method_list = class->methods;\n   class_method_list = class->class_pointer->methods;\n   curr_method = &new_list->method_list[0];\n@@ -118,18 +118,18 @@ void __objc_register_instance_methods_to_class(Class class)\n \t{\n \t  Method_t mth = &method_list->method_list[i];\n \t  if (mth->method_name\n-\t      && !search_for_method_in_list (class_method_list,\n+\t      && ! search_for_method_in_list (class_method_list,\n \t\t\t\t\t      mth->method_name))\n \t    {\n \t      /* This instance method isn't a class method. \n \t\t  Add it into the new_list. */\n \t      *curr_method = *mth;\n   \n \t      /* Reallocate the method list if necessary */\n-\t      if(++new_list->method_count == max_methods_no)\n+\t      if (++new_list->method_count == max_methods_no)\n \t\tnew_list =\n-\t\t  objc_realloc(new_list, sizeof(struct objc_method_list)\n-\t\t\t\t+ sizeof(struct \n+\t\t  objc_realloc (new_list, sizeof (struct objc_method_list)\n+\t\t\t\t+ sizeof (struct \n \t\t\t\t\tobjc_method[max_methods_no += 16]));\n \t      curr_method = &new_list->method_list[new_list->method_count];\n \t    }\n@@ -143,8 +143,8 @@ void __objc_register_instance_methods_to_class(Class class)\n   if (new_list->method_count)\n     {\n       new_list =\n- \tobjc_realloc(new_list, sizeof(struct objc_method_list)\n-\t\t     + sizeof(struct objc_method[new_list->method_count]));\n+ \tobjc_realloc (new_list, sizeof (struct objc_method_list)\n+\t\t     + sizeof (struct objc_method[new_list->method_count]));\n       new_list->method_next = class->class_pointer->methods;\n       class->class_pointer->methods = new_list;\n     }\n@@ -156,21 +156,21 @@ void __objc_register_instance_methods_to_class(Class class)\n /* Returns YES iff t1 and t2 have same method types, but we ignore\n    the argframe layout */\n BOOL\n-sel_types_match (const char* t1, const char* t2)\n+sel_types_match (const char *t1, const char *t2)\n {\n-  if (!t1 || !t2)\n+  if (! t1 || ! t2)\n     return NO;\n   while (*t1 && *t2)\n     {\n       if (*t1 == '+') t1++;\n       if (*t2 == '+') t2++;\n-      while (isdigit((unsigned char)*t1)) t1++;\n-      while (isdigit((unsigned char)*t2)) t2++;\n+      while (isdigit ((unsigned char) *t1)) t1++;\n+      while (isdigit ((unsigned char) *t2)) t2++;\n       /* xxx Remove these next two lines when qualifiers are put in\n \t all selectors, not just Protocol selectors. */\n-      t1 = objc_skip_type_qualifiers(t1);\n-      t2 = objc_skip_type_qualifiers(t2);\n-      if (!*t1 && !*t2)\n+      t1 = objc_skip_type_qualifiers (t1);\n+      t2 = objc_skip_type_qualifiers (t2);\n+      if (! *t1 && ! *t2)\n \treturn YES;\n       if (*t1 != *t2)\n \treturn NO;\n@@ -187,35 +187,35 @@ sel_get_typed_uid (const char *name, const char *types)\n   struct objc_list *l;\n   sidx i;\n \n-  objc_mutex_lock(__objc_runtime_mutex);\n+  objc_mutex_lock (__objc_runtime_mutex);\n \n   i = (sidx) hash_value_for_key (__objc_selector_hash, name);\n   if (i == 0)\n     {\n-      objc_mutex_unlock(__objc_runtime_mutex);\n+      objc_mutex_unlock (__objc_runtime_mutex);\n       return 0;\n     }\n \n-  for (l = (struct objc_list*)sarray_get_safe (__objc_selector_array, i);\n+  for (l = (struct objc_list *) sarray_get_safe (__objc_selector_array, i);\n        l; l = l->tail)\n     {\n-      SEL s = (SEL)l->head;\n+      SEL s = (SEL) l->head;\n       if (types == 0 || s->sel_types == 0)\n \t{\n \t  if (s->sel_types == types)\n \t    {\n-\t      objc_mutex_unlock(__objc_runtime_mutex);\n+\t      objc_mutex_unlock (__objc_runtime_mutex);\n \t      return s;\n \t    }\n \t}\n       else if (sel_types_match (s->sel_types, types))\n \t{\n-\t  objc_mutex_unlock(__objc_runtime_mutex);\n+\t  objc_mutex_unlock (__objc_runtime_mutex);\n \t  return s;\n \t}\n     }\n \n-  objc_mutex_unlock(__objc_runtime_mutex);\n+  objc_mutex_unlock (__objc_runtime_mutex);\n   return 0;\n }\n \n@@ -227,27 +227,27 @@ sel_get_any_typed_uid (const char *name)\n   sidx i;\n   SEL s = NULL;\n \n-  objc_mutex_lock(__objc_runtime_mutex);\n+  objc_mutex_lock (__objc_runtime_mutex);\n \n   i = (sidx) hash_value_for_key (__objc_selector_hash, name);\n   if (i == 0)\n     {\n-      objc_mutex_unlock(__objc_runtime_mutex);\n+      objc_mutex_unlock (__objc_runtime_mutex);\n       return 0;\n     }\n \n-  for (l = (struct objc_list*)sarray_get_safe (__objc_selector_array, i);\n+  for (l = (struct objc_list *) sarray_get_safe (__objc_selector_array, i);\n        l; l = l->tail)\n     {\n       s = (SEL) l->head;\n       if (s->sel_types)\n \t{\n-\t    objc_mutex_unlock(__objc_runtime_mutex);\n+\t    objc_mutex_unlock (__objc_runtime_mutex);\n \t    return s;\n \t}\n     }\n \n-  objc_mutex_unlock(__objc_runtime_mutex);\n+  objc_mutex_unlock (__objc_runtime_mutex);\n   return s;\n }\n \n@@ -258,22 +258,22 @@ sel_get_any_uid (const char *name)\n   struct objc_list *l;\n   sidx i;\n \n-  objc_mutex_lock(__objc_runtime_mutex);\n+  objc_mutex_lock (__objc_runtime_mutex);\n \n   i = (sidx) hash_value_for_key (__objc_selector_hash, name);\n   if (soffset_decode (i) == 0)\n     {\n-      objc_mutex_unlock(__objc_runtime_mutex);\n+      objc_mutex_unlock (__objc_runtime_mutex);\n       return 0;\n     }\n \n-  l = (struct objc_list*)sarray_get_safe (__objc_selector_array, i);\n-  objc_mutex_unlock(__objc_runtime_mutex);\n+  l = (struct objc_list *) sarray_get_safe (__objc_selector_array, i);\n+  objc_mutex_unlock (__objc_runtime_mutex);\n \n   if (l == 0)\n     return 0;\n \n-  return (SEL)l->head;\n+  return (SEL) l->head;\n }\n \n /* return selector representing name */\n@@ -285,18 +285,17 @@ sel_get_uid (const char *name)\n \n /* Get name of selector.  If selector is unknown, the empty string \"\" \n    is returned */ \n-const char*\n-sel_get_name (SEL selector)\n+const char *sel_get_name (SEL selector)\n {\n   const char *ret;\n \n-  objc_mutex_lock(__objc_runtime_mutex);\n-  if ((soffset_decode((sidx)selector->sel_id) > 0)\n-      && (soffset_decode((sidx)selector->sel_id) <= __objc_selector_max_index))\n+  objc_mutex_lock (__objc_runtime_mutex);\n+  if ((soffset_decode ((sidx)selector->sel_id) > 0)\n+      && (soffset_decode ((sidx)selector->sel_id) <= __objc_selector_max_index))\n     ret = sarray_get_safe (__objc_selector_names, (sidx) selector->sel_id);\n   else\n     ret = 0;\n-  objc_mutex_unlock(__objc_runtime_mutex);\n+  objc_mutex_unlock (__objc_runtime_mutex);\n   return ret;\n }\n \n@@ -308,8 +307,7 @@ sel_is_mapped (SEL selector)\n }\n \n \n-const char*\n-sel_get_type (SEL selector)\n+const char *sel_get_type (SEL selector)\n {\n   if (selector)\n     return selector->sel_types;\n@@ -318,7 +316,7 @@ sel_get_type (SEL selector)\n }\n \n /* The uninstalled dispatch table */\n-extern struct sarray* __objc_uninstalled_dtable;\n+extern struct sarray *__objc_uninstalled_dtable;\n \n /* Store the passed selector name in the selector record and return its\n    selector value (value returned by sel_get_uid).\n@@ -331,35 +329,35 @@ SEL\n __sel_register_typed_name (const char *name, const char *types, \n \t\t\t   struct objc_selector *orig, BOOL is_const)\n {\n-  struct objc_selector* j;\n+  struct objc_selector *j;\n   sidx i;\n   struct objc_list *l;\n \n   i = (sidx) hash_value_for_key (__objc_selector_hash, name);\n   if (soffset_decode (i) != 0)\n     {\n-      for (l = (struct objc_list*)sarray_get_safe (__objc_selector_array, i);\n+      for (l = (struct objc_list *) sarray_get_safe (__objc_selector_array, i);\n \t   l; l = l->tail)\n \t{\n-\t  SEL s = (SEL)l->head;\n+\t  SEL s = (SEL) l->head;\n \t  if (types == 0 || s->sel_types == 0)\n \t    {\n \t      if (s->sel_types == types)\n \t\t{\n \t\t  if (orig)\n \t\t    {\n-\t\t      orig->sel_id = (void*)i;\n+\t\t      orig->sel_id = (void *) i;\n \t\t      return orig;\n \t\t    }\n \t\t  else\n \t\t    return s;\n \t\t}\n \t    }\n-\t  else if (!strcmp (s->sel_types, types))\n+\t  else if (! strcmp (s->sel_types, types))\n \t    {\n \t      if (orig)\n \t\t{\n-\t\t  orig->sel_id = (void*)i;\n+\t\t  orig->sel_id = (void *) i;\n \t\t  return orig;\n \t\t}\n \t      else\n@@ -371,32 +369,32 @@ __sel_register_typed_name (const char *name, const char *types,\n       else\n \tj = objc_malloc (sizeof (struct objc_selector));\n \n-      j->sel_id = (void*)i;\n+      j->sel_id = (void *) i;\n       /* Can we use the pointer or must copy types?  Don't copy if NULL */\n       if ((is_const) || (types == 0))\n-\tj->sel_types = (const char*)types;\n+\tj->sel_types = (const char *) types;\n       else {\n-\tj->sel_types = (char *) objc_malloc(strlen(types)+1);\n-\tstrcpy((char *)j->sel_types, types);\n+\tj->sel_types = (char *) objc_malloc (strlen (types) + 1);\n+\tstrcpy ((char *) j->sel_types, types);\n       }\n-      l = (struct objc_list*)sarray_get_safe (__objc_selector_array, i);\n+      l = (struct objc_list *) sarray_get_safe (__objc_selector_array, i);\n     }\n   else\n     {\n       __objc_selector_max_index += 1;\n-      i = soffset_encode(__objc_selector_max_index);\n+      i = soffset_encode (__objc_selector_max_index);\n       if (orig)\n \tj = orig;\n       else\n \tj = objc_malloc (sizeof (struct objc_selector));\n \t\n-      j->sel_id = (void*)i;\n+      j->sel_id = (void *) i;\n       /* Can we use the pointer or must copy types?  Don't copy if NULL */\n       if ((is_const) || (types == 0))\n-\tj->sel_types = (const char*)types;\n+\tj->sel_types = (const char *) types;\n       else {\n-\tj->sel_types = (char *) objc_malloc(strlen(types)+1);\n-\tstrcpy((char *)j->sel_types, types);\n+\tj->sel_types = (char *) objc_malloc (strlen (types) + 1);\n+\tstrcpy ((char *) j->sel_types, types);\n       }\n       l = 0;\n     }\n@@ -412,18 +410,18 @@ __sel_register_typed_name (const char *name, const char *types,\n     if ((is_const) || (name == 0))\n       new_name = name;\n     else {\n-      new_name = (char *) objc_malloc(strlen(name)+1);\n-      strcpy((char *)new_name, name);\n+      new_name = (char *) objc_malloc (strlen (name) + 1);\n+      strcpy ((char *) new_name, name);\n     }\n \n-    l = list_cons ((void*)j, l);\n+    l = list_cons ((void *) j, l);\n     sarray_at_put_safe (__objc_selector_names, i, (void *) new_name);\n     sarray_at_put_safe (__objc_selector_array, i, (void *) l);\n     if (is_new)\n       hash_add (&__objc_selector_hash, (void *) new_name, (void *) i);\n   }\n \n-  sarray_realloc(__objc_uninstalled_dtable, __objc_selector_max_index+1);\n+  sarray_realloc (__objc_uninstalled_dtable, __objc_selector_max_index + 1);\n \n   return (SEL) j;\n }\n@@ -433,11 +431,11 @@ sel_register_name (const char *name)\n {\n   SEL ret;\n     \n-  objc_mutex_lock(__objc_runtime_mutex);\n+  objc_mutex_lock (__objc_runtime_mutex);\n   /* Assume that name is not constant static memory and needs to be\n      copied before put into a runtime structure.  is_const == NO */\n   ret = __sel_register_typed_name (name, 0, 0, NO);\n-  objc_mutex_unlock(__objc_runtime_mutex);\n+  objc_mutex_unlock (__objc_runtime_mutex);\n   \n   return ret;\n }\n@@ -447,12 +445,11 @@ sel_register_typed_name (const char *name, const char *type)\n {\n   SEL ret;\n     \n-  objc_mutex_lock(__objc_runtime_mutex);\n+  objc_mutex_lock (__objc_runtime_mutex);\n   /* Assume that name and type are not constant static memory and need to\n      be copied before put into a runtime structure.  is_const == NO */\n   ret = __sel_register_typed_name (name, type, 0, NO);\n-  objc_mutex_unlock(__objc_runtime_mutex);\n+  objc_mutex_unlock (__objc_runtime_mutex);\n   \n   return ret;\n }\n-"}, {"sha": "06fc9ba193e07c37f6b4f652057a0d2fd316f391", "filename": "libobjc/sendmsg.c", "status": "modified", "additions": 125, "deletions": 125, "changes": 250, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40165636b5fb904a609e01051c2ecfd52e5617e3/libobjc%2Fsendmsg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40165636b5fb904a609e01051c2ecfd52e5617e3/libobjc%2Fsendmsg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fsendmsg.c?ref=40165636b5fb904a609e01051c2ecfd52e5617e3", "patch": "@@ -1,6 +1,6 @@\n /* GNU Objective C Runtime message lookup \n    Copyright (C) 1993, 1995, 1996, 1997, 1998,\n-   2001 Free Software Foundation, Inc.\n+   2001, 2002 Free Software Foundation, Inc.\n    Contributed by Kresten Krab Thorup\n \n This file is part of GNU CC.\n@@ -37,104 +37,104 @@ Boston, MA 02111-1307, USA.  */\n #define gen_rtx_REG(args...) 1\n #define rtx int\n \n-#if !defined(STRUCT_VALUE) || STRUCT_VALUE == 0\n+#if ! defined (STRUCT_VALUE) || STRUCT_VALUE == 0\n #define INVISIBLE_STRUCT_RETURN 1\n #else\n #define INVISIBLE_STRUCT_RETURN 0\n #endif\n \n /* The uninstalled dispatch table */\n-struct sarray* __objc_uninstalled_dtable = 0;   /* !T:MUTEX */\n+struct sarray *__objc_uninstalled_dtable = 0;   /* !T:MUTEX */\n \n /* Hook for method forwarding. If it is set, is invoked to return a\n    function that performs the real forwarding. Otherwise the libgcc\n    based functions (__builtin_apply and friends) are used. */\n-IMP (*__objc_msg_forward)(SEL) = NULL;\n+IMP (*__objc_msg_forward) (SEL) = NULL;\n \n /* Send +initialize to class */\n-static void __objc_send_initialize(Class);\n+static void __objc_send_initialize (Class);\n \n static void __objc_install_dispatch_table_for_class (Class);\n \n /* Forward declare some functions */\n-static void __objc_init_install_dtable(id, SEL);\n+static void __objc_init_install_dtable (id, SEL);\n \n /* Various forwarding functions that are used based upon the\n    return type for the selector.\n    __objc_block_forward for structures.\n    __objc_double_forward for floats/doubles.\n    __objc_word_forward for pointers or types that fit in registers.\n    */\n-static double __objc_double_forward(id, SEL, ...);\n-static id __objc_word_forward(id, SEL, ...);\n+static double __objc_double_forward (id, SEL, ...);\n+static id __objc_word_forward (id, SEL, ...);\n typedef struct { id many[8]; } __big;\n #if INVISIBLE_STRUCT_RETURN \n static __big \n #else\n static id\n #endif\n-__objc_block_forward(id, SEL, ...);\n+__objc_block_forward (id, SEL, ...);\n static Method_t search_for_method_in_hierarchy (Class class, SEL sel);\n-Method_t search_for_method_in_list(MethodList_t list, SEL op);\n-id nil_method(id, SEL, ...);\n-\n-/* Given a selector, return the proper forwarding implementation.  */\n-__inline__ \n-IMP \n-__objc_get_forward_imp (SEL sel) \n-{ \n+Method_t search_for_method_in_list (MethodList_t list, SEL op);\n+id nil_method (id, SEL, ...);\n+\n+/* Given a selector, return the proper forwarding implementation. */\n+__inline__\n+IMP\n+__objc_get_forward_imp (SEL sel)\n+{\n   /* If a custom forwarding hook was registered, try getting a forwarding\n    * function from it.  */\n-  if (__objc_msg_forward) \n-    { \n-      IMP result; \n+  if (__objc_msg_forward)\n+    {\n+      IMP result;\n       if ((result = __objc_msg_forward (sel)) != NULL) \n-        return result; \n-    } \n+        return result;\n+    }\n \n   /* In all other cases, use the default forwarding functions built using\n    * __builtin_apply and friends.  */\n-  { \n-    const char *t = sel->sel_types; \n- \n-    if (t && (*t == '[' || *t == '(' || *t == '{') \n-#ifdef OBJC_MAX_STRUCT_BY_VALUE \n-        && objc_sizeof_type(t) > OBJC_MAX_STRUCT_BY_VALUE \n-#endif \n-        ) \n-      return (IMP)__objc_block_forward; \n-    else if (t && (*t == 'f' || *t == 'd')) \n-      return (IMP)__objc_double_forward; \n-    else \n-      return (IMP)__objc_word_forward; \n-  } \n-} \n+    {\n+      const char *t = sel->sel_types;\n+\n+      if (t && (*t == '[' || *t == '(' || *t == '{')\n+#ifdef OBJC_MAX_STRUCT_BY_VALUE\n+          && objc_sizeof_type (t) > OBJC_MAX_STRUCT_BY_VALUE\n+#endif\n+          )\n+        return (IMP)__objc_block_forward;\n+      else if (t && (*t == 'f' || *t == 'd'))\n+        return (IMP)__objc_double_forward;\n+      else\n+        return (IMP)__objc_word_forward;\n+    }\n+}\n \n /* Given a class and selector, return the selector's implementation.  */\n __inline__\n IMP\n get_imp (Class class, SEL sel)\n {\n-  void* res = sarray_get_safe (class->dtable, (size_t) sel->sel_id);\n+  void *res = sarray_get_safe (class->dtable, (size_t) sel->sel_id);\n   if (res == 0)\n     {\n       /* Not a valid method */\n-      if(class->dtable == __objc_uninstalled_dtable)\n+      if (class->dtable == __objc_uninstalled_dtable)\n \t{\n \t  /* The dispatch table needs to be installed. */\n-\t  objc_mutex_lock(__objc_runtime_mutex);\n+\t  objc_mutex_lock (__objc_runtime_mutex);\n \t  __objc_install_dispatch_table_for_class (class);\n-\t  objc_mutex_unlock(__objc_runtime_mutex);\n+\t  objc_mutex_unlock (__objc_runtime_mutex);\n \t  /* Call ourselves with the installed dispatch table\n \t     and get the real method */\n-\t  res = get_imp(class, sel);\n+\t  res = get_imp (class, sel);\n \t}\n       else\n \t{\n \t  /* The dispatch table has been installed so the\n \t     method just doesn't exist for the class.\n \t     Return the forwarding implementation. */\n-\t  res = __objc_get_forward_imp(sel);\n+\t  res = __objc_get_forward_imp (sel);\n \t}\n     }\n   return res;\n@@ -147,14 +147,14 @@ __inline__\n BOOL\n __objc_responds_to (id object, SEL sel)\n {\n-  void* res;\n+  void *res;\n \n   /* Install dispatch table if need be */\n   if (object->class_pointer->dtable == __objc_uninstalled_dtable)\n     {\n-      objc_mutex_lock(__objc_runtime_mutex);\n+      objc_mutex_lock (__objc_runtime_mutex);\n       __objc_install_dispatch_table_for_class (object->class_pointer);\n-      objc_mutex_unlock(__objc_runtime_mutex);\n+      objc_mutex_unlock (__objc_runtime_mutex);\n     }\n \n   /* Get the method from the dispatch table */\n@@ -167,31 +167,31 @@ __objc_responds_to (id object, SEL sel)\n    needs to be installed or it doesn't exist and forwarding is attempted. */\n __inline__\n IMP\n-objc_msg_lookup(id receiver, SEL op)\n+objc_msg_lookup (id receiver, SEL op)\n {\n   IMP result;\n-  if(receiver)\n+  if (receiver)\n     {\n       result = sarray_get_safe (receiver->class_pointer->dtable, \n \t\t\t\t(sidx)op->sel_id);\n       if (result == 0)\n \t{\n \t  /* Not a valid method */\n-\t  if(receiver->class_pointer->dtable == __objc_uninstalled_dtable)\n+\t  if (receiver->class_pointer->dtable == __objc_uninstalled_dtable)\n \t    {\n \t      /* The dispatch table needs to be installed.\n \t\t This happens on the very first method call to the class. */\n-\t      __objc_init_install_dtable(receiver, op);\n+\t      __objc_init_install_dtable (receiver, op);\n \n \t      /* Get real method for this in newly installed dtable */\n-\t      result = get_imp(receiver->class_pointer, op);\n+\t      result = get_imp (receiver->class_pointer, op);\n \t    }\n \t  else\n \t    {\n \t      /* The dispatch table has been installed so the\n \t\t method just doesn't exist for the class.\n \t\t Attempt to forward the method. */\n-\t      result = __objc_get_forward_imp(op);\n+\t      result = __objc_get_forward_imp (op);\n \t    }\n \t}\n       return result;\n@@ -209,93 +209,92 @@ objc_msg_lookup_super (Super_t super, SEL sel)\n     return nil_method;\n }\n \n-int method_get_sizeof_arguments (Method*);\n+int method_get_sizeof_arguments (Method *);\n \n retval_t\n-objc_msg_sendv(id object, SEL op, arglist_t arg_frame)\n+objc_msg_sendv (id object, SEL op, arglist_t arg_frame)\n {\n-  Method* m = class_get_instance_method(object->class_pointer, op);\n+  Method *m = class_get_instance_method (object->class_pointer, op);\n   const char *type;\n-  *((id*)method_get_first_argument (m, arg_frame, &type)) = object;\n-  *((SEL*)method_get_next_argument (arg_frame, &type)) = op;\n-  return __builtin_apply((apply_t)m->method_imp, \n-\t\t\t arg_frame,\n-\t\t\t method_get_sizeof_arguments (m));\n+  *((id *) method_get_first_argument (m, arg_frame, &type)) = object;\n+  *((SEL *) method_get_next_argument (arg_frame, &type)) = op;\n+  return __builtin_apply ((apply_t) m->method_imp, \n+\t\t\t  arg_frame,\n+\t\t\t  method_get_sizeof_arguments (m));\n }\n \n void\n-__objc_init_dispatch_tables()\n+__objc_init_dispatch_tables ()\n {\n-  __objc_uninstalled_dtable\n-    = sarray_new(200, 0);\n+  __objc_uninstalled_dtable = sarray_new (200, 0);\n }\n \n /* This function is called by objc_msg_lookup when the\n    dispatch table needs to be installed; thus it is called once\n    for each class, namely when the very first message is sent to it. */\n static void\n-__objc_init_install_dtable(id receiver, SEL op __attribute__ ((__unused__)))\n+__objc_init_install_dtable (id receiver, SEL op __attribute__ ((__unused__)))\n {\n   /* This may happen, if the programmer has taken the address of a \n      method before the dtable was initialized... too bad for him! */\n-  if(receiver->class_pointer->dtable != __objc_uninstalled_dtable)\n+  if (receiver->class_pointer->dtable != __objc_uninstalled_dtable)\n     return;\n \n-  objc_mutex_lock(__objc_runtime_mutex);\n+  objc_mutex_lock (__objc_runtime_mutex);\n \n-  if(CLS_ISCLASS(receiver->class_pointer))\n+  if (CLS_ISCLASS (receiver->class_pointer))\n     {\n       /* receiver is an ordinary object */\n-      assert(CLS_ISCLASS(receiver->class_pointer));\n+      assert (CLS_ISCLASS (receiver->class_pointer));\n \n       /* install instance methods table */\n       __objc_install_dispatch_table_for_class (receiver->class_pointer);\n \n       /* call +initialize -- this will in turn install the factory \n \t dispatch table if not already done :-) */\n-      __objc_send_initialize(receiver->class_pointer);\n+      __objc_send_initialize (receiver->class_pointer);\n     }\n   else\n     {\n       /* receiver is a class object */\n-      assert(CLS_ISCLASS((Class)receiver));\n-      assert(CLS_ISMETA(receiver->class_pointer));\n+      assert (CLS_ISCLASS ((Class)receiver));\n+      assert (CLS_ISMETA (receiver->class_pointer));\n \n       /* Install real dtable for factory methods */\n       __objc_install_dispatch_table_for_class (receiver->class_pointer);\n \n-      __objc_send_initialize((Class)receiver);\n+      __objc_send_initialize ((Class)receiver);\n     }\n-  objc_mutex_unlock(__objc_runtime_mutex);\n+  objc_mutex_unlock (__objc_runtime_mutex);\n }\n \n /* Install dummy table for class which causes the first message to\n    that class (or instances hereof) to be initialized properly */\n void\n-__objc_install_premature_dtable(Class class)\n+__objc_install_premature_dtable (Class class)\n {\n-  assert(__objc_uninstalled_dtable);\n+  assert (__objc_uninstalled_dtable);\n   class->dtable = __objc_uninstalled_dtable;\n }   \n \n /* Send +initialize to class if not already done */\n static void\n-__objc_send_initialize(Class class)\n+__objc_send_initialize (Class class)\n {\n   /* This *must* be a class object */\n-  assert(CLS_ISCLASS(class));\n-  assert(!CLS_ISMETA(class));\n+  assert (CLS_ISCLASS (class));\n+  assert (! CLS_ISMETA (class));\n \n-  if (!CLS_ISINITIALIZED(class))\n+  if (! CLS_ISINITIALIZED (class))\n     {\n-      CLS_SETINITIALIZED(class);\n-      CLS_SETINITIALIZED(class->class_pointer);\n+      CLS_SETINITIALIZED (class);\n+      CLS_SETINITIALIZED (class->class_pointer);\n \n       /* Create the garbage collector type memory description */\n       __objc_generate_gc_type_description (class);\n \n-      if(class->super_class)\n-\t__objc_send_initialize(class->super_class);\n+      if (class->super_class)\n+\t__objc_send_initialize (class->super_class);\n \n       {\n \tSEL \t     op = sel_register_name (\"initialize\");\n@@ -306,7 +305,7 @@ __objc_send_initialize(Class class)\n \t  int i;\n           Method_t method;\n \n-          for (i = 0; i< method_list->method_count; i++) {\n+          for (i = 0; i < method_list->method_count; i++) {\n \t    method = &(method_list->method_list[i]);\n             if (method->method_name\n                 && method->method_name->sel_id == op->sel_id) {\n@@ -322,7 +321,7 @@ __objc_send_initialize(Class class)\n \n \t}\n \tif (imp)\n-\t    (*imp)((id)class, op);\n+\t    (*imp) ((id) class, op);\n \t\t\n       }\n     }\n@@ -339,7 +338,7 @@ __objc_install_methods_in_dtable (Class class, MethodList_t method_list)\n {\n   int i;\n \n-  if (!method_list)\n+  if (! method_list)\n     return;\n \n   if (method_list->method_next)\n@@ -362,8 +361,8 @@ __objc_install_dispatch_table_for_class (Class class)\n \n   /* If the class has not yet had its class links resolved, we must \n      re-compute all class links */\n-  if(!CLS_ISRESOLV(class))\n-    __objc_resolve_class_links();\n+  if (! CLS_ISRESOLV (class))\n+    __objc_resolve_class_links ();\n \n   super = class->super_class;\n \n@@ -373,9 +372,9 @@ __objc_install_dispatch_table_for_class (Class class)\n   /* Allocate dtable if necessary */\n   if (super == 0)\n     {\n-      objc_mutex_lock(__objc_runtime_mutex);\n+      objc_mutex_lock (__objc_runtime_mutex);\n       class->dtable = sarray_new (__objc_selector_max_index, 0);\n-      objc_mutex_unlock(__objc_runtime_mutex);\n+      objc_mutex_unlock (__objc_runtime_mutex);\n     }\n   else\n     class->dtable = sarray_lazy_copy (super->dtable);\n@@ -393,7 +392,7 @@ __objc_update_dispatch_table_for_class (Class class)\n   if (class->dtable == __objc_uninstalled_dtable) \n     return;\n \n-  objc_mutex_lock(__objc_runtime_mutex);\n+  objc_mutex_lock (__objc_runtime_mutex);\n \n   arr = class->dtable;\n   __objc_install_premature_dtable (class); /* someone might require it... */\n@@ -406,7 +405,7 @@ __objc_update_dispatch_table_for_class (Class class)\n     for (next = class->subclass_list; next; next = next->sibling_class)\n       __objc_update_dispatch_table_for_class (next);\n \n-  objc_mutex_unlock(__objc_runtime_mutex);\n+  objc_mutex_unlock (__objc_runtime_mutex);\n }\n \n \n@@ -423,7 +422,7 @@ class_add_method_list (Class class, MethodList_t list)\n   int i;\n \n   /* Passing of a linked list is not allowed.  Do multiple calls.  */\n-  assert (!list->method_next);\n+  assert (! list->method_next);\n \n   /* Check for duplicates.  */\n   for (i = 0; i < list->method_count; ++i)\n@@ -434,7 +433,7 @@ class_add_method_list (Class class, MethodList_t list)\n \t{\n \t  /* This is where selector names are transmogrified to SEL's */\n \t  method->method_name = \n-\t    sel_register_typed_name ((const char*)method->method_name,\n+\t    sel_register_typed_name ((const char *) method->method_name,\n \t\t\t\t     method->method_types);\n \t}\n     }\n@@ -448,15 +447,15 @@ class_add_method_list (Class class, MethodList_t list)\n }\n \n Method_t\n-class_get_instance_method(Class class, SEL op)\n+class_get_instance_method (Class class, SEL op)\n {\n-  return search_for_method_in_hierarchy(class, op);\n+  return search_for_method_in_hierarchy (class, op);\n }\n \n Method_t\n-class_get_class_method(MetaClass class, SEL op)\n+class_get_class_method (MetaClass class, SEL op)\n {\n-  return search_for_method_in_hierarchy(class, op);\n+  return search_for_method_in_hierarchy (class, op);\n }\n \n \n@@ -580,13 +579,13 @@ __objc_forward (id object, SEL sel, arglist_t args)\n   SEL err_sel;\n \n   /* first try if the object understands forward:: */\n-  if (!frwd_sel)\n-    frwd_sel = sel_get_any_uid(\"forward::\");\n+  if (! frwd_sel)\n+    frwd_sel = sel_get_any_uid (\"forward::\");\n \n   if (__objc_responds_to (object, frwd_sel))\n     {\n-      imp = get_imp(object->class_pointer, frwd_sel);\n-      return (*imp)(object, frwd_sel, sel, args);\n+      imp = get_imp (object->class_pointer, frwd_sel);\n+      return (*imp) (object, frwd_sel, sel, args);\n     }\n \n   /* If the object recognizes the doesNotRecognize: method then we're going\n@@ -601,11 +600,11 @@ __objc_forward (id object, SEL sel, arglist_t args)\n   /* The object doesn't recognize the method.  Check for responding to\n      error:.  If it does then sent it. */\n   {\n-    char msg[256 + strlen ((const char*)sel_get_name (sel))\n-             + strlen ((const char*)object->class_pointer->name)];\n+    char msg[256 + strlen ((const char *) sel_get_name (sel))\n+             + strlen ((const char *) object->class_pointer->name)];\n \n     sprintf (msg, \"(%s) %s does not recognize %s\",\n-\t     (CLS_ISMETA(object->class_pointer)\n+\t     (CLS_ISMETA (object->class_pointer)\n \t      ? \"class\"\n \t      : \"instance\" ),\n              object->class_pointer->name, sel_get_name (sel));\n@@ -626,40 +625,41 @@ __objc_forward (id object, SEL sel, arglist_t args)\n }\n \n void\n-__objc_print_dtable_stats()\n+__objc_print_dtable_stats ()\n {\n   int total = 0;\n \n-  objc_mutex_lock(__objc_runtime_mutex);\n+  objc_mutex_lock (__objc_runtime_mutex);\n \n #ifdef OBJC_SPARSE2\n-  printf(\"memory usage: (%s)\\n\", \"2-level sparse arrays\");\n+  printf (\"memory usage: (%s)\\n\", \"2-level sparse arrays\");\n #else\n-  printf(\"memory usage: (%s)\\n\", \"3-level sparse arrays\");\n+  printf (\"memory usage: (%s)\\n\", \"3-level sparse arrays\");\n #endif\n \n-  printf(\"arrays: %d = %ld bytes\\n\", narrays, \n-\t (long)narrays*sizeof(struct sarray));\n-  total += narrays*sizeof(struct sarray);\n-  printf(\"buckets: %d = %ld bytes\\n\", nbuckets, \n-\t (long)nbuckets*sizeof(struct sbucket));\n-  total += nbuckets*sizeof(struct sbucket);\n-\n-  printf(\"idxtables: %d = %ld bytes\\n\", idxsize, (long)idxsize*sizeof(void*));\n-  total += idxsize*sizeof(void*);\n-  printf(\"-----------------------------------\\n\");\n-  printf(\"total: %d bytes\\n\", total);\n-  printf(\"===================================\\n\");\n-\n-  objc_mutex_unlock(__objc_runtime_mutex);\n+  printf (\"arrays: %d = %ld bytes\\n\", narrays, \n+\t  (long) narrays * sizeof (struct sarray));\n+  total += narrays * sizeof (struct sarray);\n+  printf (\"buckets: %d = %ld bytes\\n\", nbuckets, \n+\t  (long) nbuckets * sizeof (struct sbucket));\n+  total += nbuckets * sizeof (struct sbucket);\n+\n+  printf (\"idxtables: %d = %ld bytes\\n\",\n+\t  idxsize, (long) idxsize * sizeof (void *));\n+  total += idxsize * sizeof (void *);\n+  printf (\"-----------------------------------\\n\");\n+  printf (\"total: %d bytes\\n\", total);\n+  printf (\"===================================\\n\");\n+\n+  objc_mutex_unlock (__objc_runtime_mutex);\n }\n \n /* Returns the uninstalled dispatch table indicator.\n  If a class' dispatch table points to __objc_uninstalled_dtable\n  then that means it needs its dispatch table to be installed. */\n __inline__\n-struct sarray* \n-objc_get_uninstalled_dtable()\n+struct sarray *\n+objc_get_uninstalled_dtable ()\n {\n   return __objc_uninstalled_dtable;\n }"}, {"sha": "e95460746d1114fc8ee24cf9b7b61c8b99897f81", "filename": "libobjc/thr-mach.c", "status": "modified", "additions": 59, "deletions": 58, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40165636b5fb904a609e01051c2ecfd52e5617e3/libobjc%2Fthr-mach.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40165636b5fb904a609e01051c2ecfd52e5617e3/libobjc%2Fthr-mach.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fthr-mach.c?ref=40165636b5fb904a609e01051c2ecfd52e5617e3", "patch": "@@ -1,5 +1,5 @@\n /* GNU Objective C Runtime Thread Implementation\n-   Copyright (C) 1996, 1997 Free Software Foundation, Inc.\n+   Copyright (C) 1996, 1997, 2002 Free Software Foundation, Inc.\n    Contributed by Galen C. Hunt (gchunt@cs.rochester.edu)\n    Modified for Mach threads by Bill Bumgarner <bbum@friday.com>\n    Condition functions added by Mircea Oancea <mircea@first.elcom.pub.ro>\n@@ -37,7 +37,8 @@ Boston, MA 02111-1307, USA.  */\n   maximum priority downward only-- cannot be raised without superuser\n   privileges.  Once lowered, it cannot be raised.\n   */\n-static int __mach_get_max_thread_priority(cthread_t t, int *base)\n+static int\n+__mach_get_max_thread_priority (cthread_t t, int *base)\n {\n   thread_t threadP;\n   kern_return_t error;\n@@ -47,10 +48,10 @@ static int __mach_get_max_thread_priority(cthread_t t, int *base)\n   if (t == NULL)\n     return -1;\n \n-  threadP  = cthread_thread(t); \t/* get thread underlying */\n+  threadP  = cthread_thread (t); \t/* get thread underlying */\n \n-  error=thread_info(threadP, THREAD_SCHED_INFO, \n-\t\t    (thread_info_t)&info, &info_count);\n+  error = thread_info (threadP, THREAD_SCHED_INFO, \n+\t\t       (thread_info_t) &info, &info_count);\n \n   if (error != KERN_SUCCESS)\n     return -1;\n@@ -65,14 +66,14 @@ static int __mach_get_max_thread_priority(cthread_t t, int *base)\n \n /* Initialize the threads subsystem. */\n int\n-__objc_init_thread_system(void)\n+__objc_init_thread_system (void)\n {\n   return 0;\n }\n \n /* Close the threads subsystem. */\n int\n-__objc_close_thread_system(void)\n+__objc_close_thread_system (void)\n {\n   return 0;\n }\n@@ -81,19 +82,19 @@ __objc_close_thread_system(void)\n \n /* Create a new thread of execution. */\n objc_thread_t\n-__objc_thread_detach(void (*func)(void *arg), void *arg)\n+__objc_thread_detach (void (*func) (void *arg), void *arg)\n {\n   objc_thread_t thread_id;\n   cthread_t new_thread_handle;\n \n   /* create thread */\n-  new_thread_handle = cthread_fork((cthread_fn_t)func, arg);\n+  new_thread_handle = cthread_fork ((cthread_fn_t) func, arg);\n \n-  if(new_thread_handle)\n+  if (new_thread_handle)\n     {\n       /* this is not terribly portable */\n-      thread_id = *(objc_thread_t *)&new_thread_handle; \n-      cthread_detach(new_thread_handle);\n+      thread_id = *(objc_thread_t *) &new_thread_handle; \n+      cthread_detach (new_thread_handle);\n     }\n   else\n     thread_id = NULL;\n@@ -103,11 +104,11 @@ __objc_thread_detach(void (*func)(void *arg), void *arg)\n \n /* Set the current thread's priority. */\n int\n-__objc_thread_set_priority(int priority)\n+__objc_thread_set_priority (int priority)\n {\n-  objc_thread_t *t = objc_thread_id();\n+  objc_thread_t *t = objc_thread_id ();\n   cthread_t cT = (cthread_t) t; \n-  int maxPriority = __mach_get_max_thread_priority(cT, NULL);\n+  int maxPriority = __mach_get_max_thread_priority (cT, NULL);\n   int sys_priority = 0;\n \n   if (maxPriority == -1)\n@@ -132,27 +133,27 @@ __objc_thread_set_priority(int priority)\n     return -1;\n \n   /* Change the priority */\n-  if (cthread_priority(cT, sys_priority, 0) == KERN_SUCCESS)\n+  if (cthread_priority (cT, sys_priority, 0) == KERN_SUCCESS)\n     return 0;\n   else\n     return -1;\n }\n \n /* Return the current thread's priority. */\n int\n-__objc_thread_get_priority(void)\n+__objc_thread_get_priority (void)\n {\n-  objc_thread_t *t = objc_thread_id();\n-  cthread_t cT = (cthread_t) t; /* see objc_thread_id() */\n+  objc_thread_t *t = objc_thread_id ();\n+  cthread_t cT = (cthread_t) t; /* see objc_thread_id () */\n   int basePriority;\n   int maxPriority;\n   int sys_priority = 0;\n \n   int interactiveT, backgroundT, lowT; /* thresholds */\n \n-  maxPriority = __mach_get_max_thread_priority(cT, &basePriority);\n+  maxPriority = __mach_get_max_thread_priority (cT, &basePriority);\n \n-  if(maxPriority == -1)\n+  if (maxPriority == -1)\n     return -1;\n \n   if (basePriority > ( (maxPriority * 2) / 3))\n@@ -166,60 +167,60 @@ __objc_thread_get_priority(void)\n \n /* Yield our process time to another thread. */\n void\n-__objc_thread_yield(void)\n+__objc_thread_yield (void)\n {\n-  cthread_yield();\n+  cthread_yield ();\n }\n \n /* Terminate the current thread. */\n int\n-__objc_thread_exit(void)\n+__objc_thread_exit (void)\n {\n   /* exit the thread */\n-  cthread_exit(&__objc_thread_exit_status);\n+  cthread_exit (&__objc_thread_exit_status);\n \n   /* Failed if we reached here */\n   return -1;\n }\n \n /* Returns an integer value which uniquely describes a thread. */\n objc_thread_t\n-__objc_thread_id(void)\n+__objc_thread_id (void)\n {\n-  cthread_t self = cthread_self();\n+  cthread_t self = cthread_self ();\n \n-  return *(objc_thread_t *)&self;\n+  return *(objc_thread_t *) &self;\n }\n \n /* Sets the thread's local storage pointer. */\n int\n-__objc_thread_set_data(void *value)\n+__objc_thread_set_data (void *value)\n {\n-  cthread_set_data(cthread_self(), (any_t) value);\n+  cthread_set_data (cthread_self (), (any_t) value);\n   return 0;\n }\n \n /* Returns the thread's local storage pointer. */\n void *\n-__objc_thread_get_data(void)\n+__objc_thread_get_data (void)\n {\n-  return (void *) cthread_data(cthread_self());\n+  return (void *) cthread_data (cthread_self ());\n }\n \n /* Backend mutex functions */\n \n /* Allocate a mutex. */\n int\n-__objc_mutex_allocate(objc_mutex_t mutex)\n+__objc_mutex_allocate (objc_mutex_t mutex)\n {\n   int err = 0;\n-  mutex->backend = objc_malloc(sizeof(struct mutex));\n+  mutex->backend = objc_malloc (sizeof (struct mutex));\n \n-  err = mutex_init((mutex_t)(mutex->backend));\n+  err = mutex_init ((mutex_t) (mutex->backend));\n \n   if (err != 0)\n     {\n-      objc_free(mutex->backend);\n+      objc_free (mutex->backend);\n       return -1;\n     }\n   else\n@@ -228,84 +229,84 @@ __objc_mutex_allocate(objc_mutex_t mutex)\n \n /* Deallocate a mutex. */\n int\n-__objc_mutex_deallocate(objc_mutex_t mutex)\n+__objc_mutex_deallocate (objc_mutex_t mutex)\n {\n-  mutex_clear((mutex_t)(mutex->backend));\n+  mutex_clear ((mutex_t) (mutex->backend));\n \n-  objc_free(mutex->backend);\n+  objc_free (mutex->backend);\n   mutex->backend = NULL;\n   return 0;\n }\n \n /* Grab a lock on a mutex. */\n int\n-__objc_mutex_lock(objc_mutex_t mutex)\n+__objc_mutex_lock (objc_mutex_t mutex)\n {\n-  mutex_lock((mutex_t)(mutex->backend));\n+  mutex_lock ((mutex_t) (mutex->backend));\n   return 0;\n }\n \n /* Try to grab a lock on a mutex. */\n int\n-__objc_mutex_trylock(objc_mutex_t mutex)\n+__objc_mutex_trylock (objc_mutex_t mutex)\n {\n-  if (mutex_try_lock((mutex_t)(mutex->backend)) == 0)\n+  if (mutex_try_lock ((mutex_t) (mutex->backend)) == 0)\n     return -1;\n   else\n     return 0;\n }\n \n /* Unlock the mutex */\n int\n-__objc_mutex_unlock(objc_mutex_t mutex)\n+__objc_mutex_unlock (objc_mutex_t mutex)\n {\n-  mutex_unlock((mutex_t)(mutex->backend));\n+  mutex_unlock ((mutex_t) (mutex->backend));\n   return 0;\n }\n \n /* Backend condition mutex functions */\n \n /* Allocate a condition. */\n int\n-__objc_condition_allocate(objc_condition_t condition)\n+__objc_condition_allocate (objc_condition_t condition)\n {\n-  condition->backend = objc_malloc(sizeof(struct condition));\n-  condition_init((condition_t)(condition->backend));\n+  condition->backend = objc_malloc (sizeof (struct condition));\n+  condition_init ((condition_t) (condition->backend));\n   return 0;\n }\n \n /* Deallocate a condition. */\n int\n-__objc_condition_deallocate(objc_condition_t condition)\n+__objc_condition_deallocate (objc_condition_t condition)\n {\n-  condition_clear((condition_t)(condition->backend));\n-  objc_free(condition->backend);\n+  condition_clear ((condition_t) (condition->backend));\n+  objc_free (condition->backend);\n   condition->backend = NULL;\n   return 0;\n }\n \n /* Wait on the condition */\n int\n-__objc_condition_wait(objc_condition_t condition, objc_mutex_t mutex)\n+__objc_condition_wait (objc_condition_t condition, objc_mutex_t mutex)\n {\n-  condition_wait((condition_t)(condition->backend),\n-\t\t (mutex_t)(mutex->backend));\n+  condition_wait ((condition_t) (condition->backend),\n+\t\t  (mutex_t) (mutex->backend));\n   return 0;\n }\n \n /* Wake up all threads waiting on this condition. */\n int\n-__objc_condition_broadcast(objc_condition_t condition)\n+__objc_condition_broadcast (objc_condition_t condition)\n {\n-  condition_broadcast((condition_t)(condition->backend));\n+  condition_broadcast ((condition_t) (condition->backend));\n   return 0;\n }\n \n /* Wake up one thread waiting on this condition. */\n int\n-__objc_condition_signal(objc_condition_t condition)\n+__objc_condition_signal (objc_condition_t condition)\n {\n-  condition_signal((condition_t)(condition->backend));\n+  condition_signal ((condition_t) (condition->backend));\n   return 0;\n }\n "}, {"sha": "bc94473ce6840c4c1407f162153a20622c3d2762", "filename": "libobjc/thr.c", "status": "modified", "additions": 89, "deletions": 89, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40165636b5fb904a609e01051c2ecfd52e5617e3/libobjc%2Fthr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40165636b5fb904a609e01051c2ecfd52e5617e3/libobjc%2Fthr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fthr.c?ref=40165636b5fb904a609e01051c2ecfd52e5617e3", "patch": "@@ -48,7 +48,7 @@ objc_thread_callback _objc_became_multi_threaded = NULL;\n   it can be informed; for example, the GNUstep Base Library sets it \n   so it can implement the NSBecomingMultiThreaded notification.\n   */\n-objc_thread_callback objc_set_thread_callback(objc_thread_callback func)\n+objc_thread_callback objc_set_thread_callback (objc_thread_callback func)\n {\n   objc_thread_callback temp = _objc_became_multi_threaded;\n   _objc_became_multi_threaded = func;\n@@ -76,44 +76,44 @@ struct __objc_thread_start_state\n };\n \n static volatile void\n-__objc_thread_detach_function(struct __objc_thread_start_state *istate)\n+__objc_thread_detach_function (struct __objc_thread_start_state *istate)\n {\n   /* Valid state? */\n   if (istate) {\n-    id (*imp)(id,SEL,id);\n+    id (*imp) (id, SEL, id);\n     SEL selector = istate->selector;\n     id object   = istate->object;\n     id argument = istate->argument;\n \n     /* Don't need anymore so free it */\n-    objc_free(istate);\n+    objc_free (istate);\n \n     /* Clear out the thread local storage */\n-    objc_thread_set_data(NULL);\n+    objc_thread_set_data (NULL);\n \n     /* Check to see if we just became multi threaded */\n-    if (!__objc_is_multi_threaded)\n+    if (! __objc_is_multi_threaded)\n       {\n \t__objc_is_multi_threaded = 1;\n \n \t/* Call the hook function */\n \tif (_objc_became_multi_threaded != NULL)\n-\t  (*_objc_became_multi_threaded)();\n+\t  (*_objc_became_multi_threaded) ();\n       }\n \n     /* Call the method */\n-    if ((imp = (id(*)(id, SEL, id))objc_msg_lookup(object, selector)))\n-\t(*imp)(object, selector, argument);\n+    if ((imp = (id (*) (id, SEL, id))objc_msg_lookup (object, selector)))\n+\t(*imp) (object, selector, argument);\n     else\n-      objc_error(object, OBJC_ERR_UNIMPLEMENTED,\n-\t\t \"objc_thread_detach called with bad selector.\\n\");\n+      objc_error (object, OBJC_ERR_UNIMPLEMENTED,\n+\t\t  \"objc_thread_detach called with bad selector.\\n\");\n   }\n   else\n-    objc_error(nil, OBJC_ERR_BAD_STATE,\n-\t       \"objc_thread_detach called with NULL state.\\n\");\n+    objc_error (nil, OBJC_ERR_BAD_STATE,\n+\t        \"objc_thread_detach called with NULL state.\\n\");\n \n   /* Exit the thread */\n-  objc_thread_exit();\n+  objc_thread_exit ();\n }\n \n /*\n@@ -131,14 +131,14 @@ __objc_thread_detach_function(struct __objc_thread_start_state *istate)\n   takes a single argument.\n   */\n objc_thread_t\n-objc_thread_detach(SEL selector, id object, id argument)\n+objc_thread_detach (SEL selector, id object, id argument)\n {\n   struct __objc_thread_start_state *istate;\n   objc_thread_t        thread_id = NULL;\n \n   /* Allocate the state structure */\n-  if (!(istate = (struct __objc_thread_start_state *)\n-\tobjc_malloc(sizeof(*istate))))\n+  if (! (istate = (struct __objc_thread_start_state *)\n+\t objc_malloc (sizeof (*istate))))\n     return NULL;\n \n   /* Initialize the state structure */\n@@ -147,39 +147,39 @@ objc_thread_detach(SEL selector, id object, id argument)\n   istate->argument = argument;\n \n   /* lock access */\n-  objc_mutex_lock(__objc_runtime_mutex);\n+  objc_mutex_lock (__objc_runtime_mutex);\n \n   /* Call the backend to spawn the thread */\n-  if ((thread_id = __objc_thread_detach((void *)__objc_thread_detach_function,\n-\t\t\t\t\tistate)) == NULL)\n+  if ((thread_id = __objc_thread_detach ((void *)__objc_thread_detach_function,\n+\t\t\t\t\t istate)) == NULL)\n     {\n       /* failed! */\n-      objc_mutex_unlock(__objc_runtime_mutex);\n-      objc_free(istate);\n+      objc_mutex_unlock (__objc_runtime_mutex);\n+      objc_free (istate);\n       return NULL;\n     }\n \n   /* Increment our thread counter */\n   __objc_runtime_threads_alive++;\n-  objc_mutex_unlock(__objc_runtime_mutex);\n+  objc_mutex_unlock (__objc_runtime_mutex);\n \n   return thread_id;\n }\n \n /* Set the current thread's priority. */\n int\n-objc_thread_set_priority(int priority)\n+objc_thread_set_priority (int priority)\n {\n   /* Call the backend */\n-  return __objc_thread_set_priority(priority);\n+  return __objc_thread_set_priority (priority);\n }\n \n /* Return the current thread's priority. */\n int\n-objc_thread_get_priority(void)\n+objc_thread_get_priority (void)\n {\n   /* Call the backend */\n-  return __objc_thread_get_priority();\n+  return __objc_thread_get_priority ();\n }\n \n /*\n@@ -188,58 +188,58 @@ objc_thread_get_priority(void)\n   make progress even on a lazy uniprocessor system.\n   */\n void\n-objc_thread_yield(void)\n+objc_thread_yield (void)\n {\n   /* Call the backend */\n-  __objc_thread_yield();\n+  __objc_thread_yield ();\n }\n \n /*\n   Terminate the current tread.  Doesn't return.\n   Actually, if it failed returns -1.\n   */\n int\n-objc_thread_exit(void)\n+objc_thread_exit (void)\n {\n   /* Decrement our counter of the number of threads alive */\n-  objc_mutex_lock(__objc_runtime_mutex);\n+  objc_mutex_lock (__objc_runtime_mutex);\n   __objc_runtime_threads_alive--;\n-  objc_mutex_unlock(__objc_runtime_mutex);\n+  objc_mutex_unlock (__objc_runtime_mutex);\n \n   /* Call the backend to terminate the thread */\n-  return __objc_thread_exit();\n+  return __objc_thread_exit ();\n }\n \n /*\n   Returns an integer value which uniquely describes a thread.  Must not be\n   NULL which is reserved as a marker for \"no thread\".\n   */\n objc_thread_t\n-objc_thread_id(void)\n+objc_thread_id (void)\n {\n   /* Call the backend */\n-  return __objc_thread_id();\n+  return __objc_thread_id ();\n }\n \n /*\n   Sets the thread's local storage pointer. \n   Returns 0 if successful or -1 if failed.\n   */\n int\n-objc_thread_set_data(void *value)\n+objc_thread_set_data (void *value)\n {\n   /* Call the backend */\n-  return __objc_thread_set_data(value);\n+  return __objc_thread_set_data (value);\n }\n \n /*\n   Returns the thread's local storage pointer.  Returns NULL on failure.\n   */\n void *\n-objc_thread_get_data(void)\n+objc_thread_get_data (void)\n {\n   /* Call the backend */\n-  return __objc_thread_get_data();\n+  return __objc_thread_get_data ();\n }\n \n /* Frontend mutex functions */\n@@ -249,19 +249,19 @@ objc_thread_get_data(void)\n   allocation failed for any reason.\n   */\n objc_mutex_t\n-objc_mutex_allocate(void)\n+objc_mutex_allocate (void)\n {\n   objc_mutex_t mutex;\n \n   /* Allocate the mutex structure */\n-  if (!(mutex = (objc_mutex_t)objc_malloc(sizeof(struct objc_mutex))))\n+  if (! (mutex = (objc_mutex_t)objc_malloc (sizeof (struct objc_mutex))))\n     return NULL;\n \n   /* Call backend to create the mutex */\n-  if (__objc_mutex_allocate(mutex))\n+  if (__objc_mutex_allocate (mutex))\n     {\n       /* failed! */\n-      objc_free(mutex);\n+      objc_free (mutex);\n       return NULL;\n     }\n \n@@ -279,23 +279,23 @@ objc_mutex_allocate(void)\n   Returns the number of locks on the thread.  (1 for deallocate).\n   */\n int\n-objc_mutex_deallocate(objc_mutex_t mutex)\n+objc_mutex_deallocate (objc_mutex_t mutex)\n {\n   int depth;\n \n   /* Valid mutex? */\n-  if (!mutex)\n+  if (! mutex)\n     return -1;\n \n   /* Acquire lock on mutex */\n-  depth = objc_mutex_lock(mutex);\n+  depth = objc_mutex_lock (mutex);\n \n   /* Call backend to destroy mutex */\n-  if (__objc_mutex_deallocate(mutex))\n+  if (__objc_mutex_deallocate (mutex))\n     return -1;\n \n   /* Free the mutex structure */\n-  objc_free(mutex);\n+  objc_free (mutex);\n \n   /* Return last depth */\n   return depth;\n@@ -308,22 +308,22 @@ objc_mutex_deallocate(objc_mutex_t mutex)\n   Returns the lock count on the mutex held by this thread.\n   */\n int\n-objc_mutex_lock(objc_mutex_t mutex)\n+objc_mutex_lock (objc_mutex_t mutex)\n {\n   objc_thread_t thread_id;\n   int status;\n \n   /* Valid mutex? */\n-  if (!mutex)\n+  if (! mutex)\n     return -1;\n \n   /* If we already own the lock then increment depth */\n-  thread_id = __objc_thread_id();\n+  thread_id = __objc_thread_id ();\n   if (mutex->owner == thread_id)\n     return ++mutex->depth;\n \n   /* Call the backend to lock the mutex */\n-  status = __objc_mutex_lock(mutex);\n+  status = __objc_mutex_lock (mutex);\n \n   /* Failed? */\n   if (status)\n@@ -340,22 +340,22 @@ objc_mutex_lock(objc_mutex_t mutex)\n   thread has a lock on the mutex returns -1.\n   */\n int\n-objc_mutex_trylock(objc_mutex_t mutex)\n+objc_mutex_trylock (objc_mutex_t mutex)\n {\n   objc_thread_t thread_id;\n   int status;\n \n   /* Valid mutex? */\n-  if (!mutex)\n+  if (! mutex)\n     return -1;\n \n   /* If we already own the lock then increment depth */ \n-  thread_id = __objc_thread_id();\n+  thread_id = __objc_thread_id ();\n   if (mutex->owner == thread_id)\n     return ++mutex->depth;\n     \n   /* Call the backend to try to lock the mutex */\n-  status = __objc_mutex_trylock(mutex);\n+  status = __objc_mutex_trylock (mutex);\n \n   /* Failed? */\n   if (status)\n@@ -375,17 +375,17 @@ objc_mutex_trylock(objc_mutex_t mutex)\n   doesn't hold in which case return -1 and the mutex is unaffected.\n   */\n int\n-objc_mutex_unlock(objc_mutex_t mutex)\n+objc_mutex_unlock (objc_mutex_t mutex)\n {\n   objc_thread_t thread_id;\n   int status;\n \n   /* Valid mutex? */\n-  if (!mutex)\n+  if (! mutex)\n     return -1;\n \n   /* If another thread owns the lock then abort */\n-  thread_id = __objc_thread_id();\n+  thread_id = __objc_thread_id ();\n   if (mutex->owner != thread_id)\n     return -1;\n \n@@ -398,7 +398,7 @@ objc_mutex_unlock(objc_mutex_t mutex)\n   mutex->owner = NULL;\n \n   /* Have the backend unlock the mutex */\n-  status = __objc_mutex_unlock(mutex);\n+  status = __objc_mutex_unlock (mutex);\n \n   /* Failed? */\n   if (status)\n@@ -414,20 +414,20 @@ objc_mutex_unlock(objc_mutex_t mutex)\n   if the allocation failed for any reason.\n   */\n objc_condition_t \n-objc_condition_allocate(void)\n+objc_condition_allocate (void)\n {\n   objc_condition_t condition;\n     \n   /* Allocate the condition mutex structure */\n-  if (!(condition = \n-\t(objc_condition_t)objc_malloc(sizeof(struct objc_condition))))\n+  if (! (condition = \n+\t (objc_condition_t) objc_malloc (sizeof (struct objc_condition))))\n     return NULL;\n \n   /* Call the backend to create the condition mutex */\n-  if (__objc_condition_allocate(condition))\n+  if (__objc_condition_allocate (condition))\n     {\n       /* failed! */\n-      objc_free(condition);\n+      objc_free (condition);\n       return NULL;\n     }\n \n@@ -443,41 +443,41 @@ objc_condition_allocate(void)\n   waiting but just wake them up.\n   */\n int\n-objc_condition_deallocate(objc_condition_t condition)\n+objc_condition_deallocate (objc_condition_t condition)\n {\n   /* Broadcast the condition */\n-  if (objc_condition_broadcast(condition))\n+  if (objc_condition_broadcast (condition))\n     return -1;\n \n   /* Call the backend to destroy */\n-  if (__objc_condition_deallocate(condition))\n+  if (__objc_condition_deallocate (condition))\n     return -1;\n \n   /* Free the condition mutex structure */\n-  objc_free(condition);\n+  objc_free (condition);\n \n   return 0;\n }\n \n /*\n-  Wait on the condition unlocking the mutex until objc_condition_signal()\n-  or objc_condition_broadcast() are called for the same condition. The\n+  Wait on the condition unlocking the mutex until objc_condition_signal ()\n+  or objc_condition_broadcast () are called for the same condition. The\n   given mutex *must* have the depth set to 1 so that it can be unlocked\n   here, so that someone else can lock it and signal/broadcast the condition.\n   The mutex is used to lock access to the shared data that make up the\n   \"condition\" predicate.\n   */\n int\n-objc_condition_wait(objc_condition_t condition, objc_mutex_t mutex)\n+objc_condition_wait (objc_condition_t condition, objc_mutex_t mutex)\n {\n   objc_thread_t thread_id;\n \n   /* Valid arguments? */\n-  if (!mutex || !condition)\n+  if (! mutex || ! condition)\n     return -1;\n \n   /* Make sure we are owner of mutex */\n-  thread_id = __objc_thread_id();\n+  thread_id = __objc_thread_id ();\n   if (mutex->owner != thread_id)\n     return -1;\n \n@@ -490,7 +490,7 @@ objc_condition_wait(objc_condition_t condition, objc_mutex_t mutex)\n   mutex->owner = (objc_thread_t)NULL;\n \n   /* Call the backend to wait */\n-  __objc_condition_wait(condition, mutex);\n+  __objc_condition_wait (condition, mutex);\n \n   /* Make ourselves owner of the mutex */\n   mutex->owner = thread_id;\n@@ -506,13 +506,13 @@ objc_condition_wait(objc_condition_t condition, objc_mutex_t mutex)\n   right away after this call.\n   */\n int\n-objc_condition_broadcast(objc_condition_t condition)\n+objc_condition_broadcast (objc_condition_t condition)\n {\n   /* Valid condition mutex? */\n-  if (!condition)\n+  if (! condition)\n     return -1;\n \n-  return __objc_condition_broadcast(condition);\n+  return __objc_condition_broadcast (condition);\n }\n \n /*\n@@ -522,42 +522,42 @@ objc_condition_broadcast(objc_condition_t condition)\n   right away after this call.\n   */\n int\n-objc_condition_signal(objc_condition_t condition)\n+objc_condition_signal (objc_condition_t condition)\n {\n   /* Valid condition mutex? */\n-  if (!condition)\n+  if (! condition)\n     return -1;\n \n-  return __objc_condition_signal(condition);\n+  return __objc_condition_signal (condition);\n }\n \n /* Make the objc thread system aware that a thread which is managed\n    (started, stopped) by external code could access objc facilities\n    from now on.  This is used when you are interfacing with some\n    external non-objc-based environment/system - you must call\n-   objc_thread_add() before an alien thread makes any calls to\n+   objc_thread_add () before an alien thread makes any calls to\n    Objective-C.  Do not cause the _objc_became_multi_threaded hook to\n    be executed. */\n void \n-objc_thread_add(void)\n+objc_thread_add (void)\n {\n-  objc_mutex_lock(__objc_runtime_mutex);\n+  objc_mutex_lock (__objc_runtime_mutex);\n   __objc_is_multi_threaded = 1;\n   __objc_runtime_threads_alive++;\n-  objc_mutex_unlock(__objc_runtime_mutex);  \n+  objc_mutex_unlock (__objc_runtime_mutex);  \n }\n \n /* Make the objc thread system aware that a thread managed (started,\n    stopped) by some external code will no longer access objc and thus\n    can be forgotten by the objc thread system.  Call\n-   objc_thread_remove() when your alien thread is done with making\n+   objc_thread_remove () when your alien thread is done with making\n    calls to Objective-C. */\n void\n-objc_thread_remove(void)\n+objc_thread_remove (void)\n {\n-  objc_mutex_lock(__objc_runtime_mutex);\n+  objc_mutex_lock (__objc_runtime_mutex);\n   __objc_runtime_threads_alive--;\n-  objc_mutex_unlock(__objc_runtime_mutex);  \n+  objc_mutex_unlock (__objc_runtime_mutex);  \n }\n \n /* End of File */"}]}