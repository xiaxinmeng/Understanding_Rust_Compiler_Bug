{"sha": "b320edc0c29c838b0090c3c9be14187d132f73f2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjMyMGVkYzBjMjljODM4YjAwOTBjM2M5YmUxNDE4N2QxMzJmNzNmMg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-08-23T09:52:06Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-08-23T09:54:03Z"}, "message": "bswap: Recognize (int) __builtin_bswap64 (arg) idioms or __builtin_bswap?? (arg) & mask [PR86723]\n\nThe following patch recognizes in the bswap pass (only there for now,\nhaven't done it for store merging pass yet) code sequences that can\nbe handled by (int32) __builtin_bswap64 (arg), i.e. where we have\n0x05060708 n->n with 64-bit non-memory argument (if it is memory, we\ncan just load the 32-bit at 4 bytes into the address and n->n would\nbe 0x01020304; and only 64 -> 32 bit, because 64 -> 16 bit or 32 -> 16 bit\nwould mean only two bytes in the result and probably not worth it),\nand furthermore the case where we have in the 0x0102030405060708 etc.\nnumbers some bytes 0 (i.e. known to contain zeros rather than source bytes),\nas long as we have at least two original bytes in the right\npositions (and no unknown bytes).  This can be handled by\n__builtin_bswap64 (arg) & 0xff0000ffffff00ffULL etc.\nThe latter change is the reason why counting the bswap messages doesn't work\ntoo well in optimize-bswap* tests anymore, while the pass iterates from end\nof basic block towards start, it will often match both the bswap at the end\nand some of the earlier bswaps with some masks (not a problem generally,\nwe'll just DCE it away whenever possible).  The pass right now doesn't\nhandle __builtin_bswap* calls in the pattern matching (which is the reason\nwhy it operates backwards), but it uses FOR_EACH_BB_FN (bb, fun) order\nof handling blocks and matched sequences can span multiple blocks, so I was\nworried about cases like:\nvoid bar (unsigned long long);\nunsigned long long\nfoo (unsigned long long value, int x)\n{\n  unsigned long long tmp = (((value & 0x00000000000000ffull) << 56)\n          | ((value & 0x000000000000ff00ull) << 40)\n          | ((value & 0x00000000ff000000ull) << 8));\n  if (x)\n    bar (tmp);\n  return (tmp\n          | ((value & 0x000000ff00000000ull) >> 8)\n          | ((value & 0x0000ff0000000000ull) >> 24)\n          | ((value & 0x0000000000ff0000ull) << 24)\n          | ((value & 0x00ff000000000000ull) >> 40)\n          | ((value & 0xff00000000000000ull) >> 56));\n}\nbut it seems we handle even that fine, while bb2 ending in GIMPLE_COND\nis processed first, we recognize there a __builtin_bswap64 (value) & mask1,\nin the last bb we recognize tmp | (__builtin_bswap64 (value) & mask2) and\nPRE optimizes that into t = __builtin_bswap64 (value); tmp = t & mask1;\nin the first bb and return t; in the last one.\n\n2021-08-23  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR tree-optimization/86723\n\t* gimple-ssa-store-merging.c (find_bswap_or_nop_finalize): Add\n\tcast64_to_32 argument, set *cast64_to_32 to false, unless n is\n\tnon-memory permutation of 64-bit src which only has bytes of\n\t0 or [5..8] and n->range is 4.\n\t(find_bswap_or_nop): Add cast64_to_32 and mask arguments, adjust\n\tfind_bswap_or_nop_finalize caller, support bswap with some bytes\n\tzeroed, as long as at least two bytes are not zeroed.\n\t(bswap_replace): Add mask argument and handle masking of bswap\n\tresult.\n\t(maybe_optimize_vector_constructor): Adjust find_bswap_or_nop\n\tcaller, punt if cast64_to_32 or mask is not all ones.\n\t(pass_optimize_bswap::execute): Adjust find_bswap_or_nop_finalize\n\tcaller, for now punt if cast64_to_32.\n\n\t* gcc.dg/pr86723.c: New test.\n\t* gcc.target/i386/pr86723.c: New test.\n\t* gcc.dg/optimize-bswapdi-1.c: Use -fdump-tree-optimized instead of\n\t-fdump-tree-bswap and scan for number of __builtin_bswap64 calls.\n\t* gcc.dg/optimize-bswapdi-2.c: Likewise.\n\t* gcc.dg/optimize-bswapsi-1.c: Use -fdump-tree-optimized instead of\n\t-fdump-tree-bswap and scan for number of __builtin_bswap32 calls.\n\t* gcc.dg/optimize-bswapsi-5.c: Likewise.\n\t* gcc.dg/optimize-bswapsi-3.c: Likewise.  Expect one __builtin_bswap32\n\tcall instead of zero.", "tree": {"sha": "08f8bb2ca31927f8d1b0d15f415ea6083c9673c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/08f8bb2ca31927f8d1b0d15f415ea6083c9673c9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b320edc0c29c838b0090c3c9be14187d132f73f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b320edc0c29c838b0090c3c9be14187d132f73f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b320edc0c29c838b0090c3c9be14187d132f73f2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b320edc0c29c838b0090c3c9be14187d132f73f2/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ad665deeafd31238b537139385e1e80b40c10e0c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad665deeafd31238b537139385e1e80b40c10e0c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad665deeafd31238b537139385e1e80b40c10e0c"}], "stats": {"total": 235, "additions": 208, "deletions": 27}, "files": [{"sha": "781c02d4ddb03e074761418f7aab5eb0d98afd94", "filename": "gcc/gimple-ssa-store-merging.c", "status": "modified", "additions": 83, "deletions": 17, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b320edc0c29c838b0090c3c9be14187d132f73f2/gcc%2Fgimple-ssa-store-merging.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b320edc0c29c838b0090c3c9be14187d132f73f2/gcc%2Fgimple-ssa-store-merging.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-store-merging.c?ref=b320edc0c29c838b0090c3c9be14187d132f73f2", "patch": "@@ -792,7 +792,7 @@ find_bswap_or_nop_1 (gimple *stmt, struct symbolic_number *n, int limit)\n \n void\n find_bswap_or_nop_finalize (struct symbolic_number *n, uint64_t *cmpxchg,\n-\t\t\t    uint64_t *cmpnop)\n+\t\t\t    uint64_t *cmpnop, bool *cast64_to_32)\n {\n   unsigned rsize;\n   uint64_t tmpn, mask;\n@@ -802,6 +802,7 @@ find_bswap_or_nop_finalize (struct symbolic_number *n, uint64_t *cmpxchg,\n      according to the size of the symbolic number before using it.  */\n   *cmpxchg = CMPXCHG;\n   *cmpnop = CMPNOP;\n+  *cast64_to_32 = false;\n \n   /* Find real size of result (highest non-zero byte).  */\n   if (n->base_addr)\n@@ -814,7 +815,27 @@ find_bswap_or_nop_finalize (struct symbolic_number *n, uint64_t *cmpxchg,\n   if (n->range < (int) sizeof (int64_t))\n     {\n       mask = ((uint64_t) 1 << (n->range * BITS_PER_MARKER)) - 1;\n-      *cmpxchg >>= (64 / BITS_PER_MARKER - n->range) * BITS_PER_MARKER;\n+      if (n->base_addr == NULL\n+\t  && n->range == 4\n+\t  && int_size_in_bytes (TREE_TYPE (n->src)) == 8)\n+\t{\n+\t  /* If all bytes in n->n are either 0 or in [5..8] range, this\n+\t     might be a candidate for (unsigned) __builtin_bswap64 (src).\n+\t     It is not worth it for (unsigned short) __builtin_bswap64 (src)\n+\t     or (unsigned short) __builtin_bswap32 (src).  */\n+\t  *cast64_to_32 = true;\n+\t  for (tmpn = n->n; tmpn; tmpn >>= BITS_PER_MARKER)\n+\t    if ((tmpn & MARKER_MASK)\n+\t\t&& ((tmpn & MARKER_MASK) <= 4 || (tmpn & MARKER_MASK) > 8))\n+\t      {\n+\t\t*cast64_to_32 = false;\n+\t\tbreak;\n+\t      }\n+\t}\n+      if (*cast64_to_32)\n+\t*cmpxchg &= mask;\n+      else\n+\t*cmpxchg >>= (64 / BITS_PER_MARKER - n->range) * BITS_PER_MARKER;\n       *cmpnop &= mask;\n     }\n \n@@ -837,6 +858,8 @@ find_bswap_or_nop_finalize (struct symbolic_number *n, uint64_t *cmpxchg,\n       n->range = rsize;\n     }\n \n+  if (*cast64_to_32)\n+    n->range = 8;\n   n->range *= BITS_PER_UNIT;\n }\n \n@@ -849,7 +872,8 @@ find_bswap_or_nop_finalize (struct symbolic_number *n, uint64_t *cmpxchg,\n    expression.  */\n \n gimple *\n-find_bswap_or_nop (gimple *stmt, struct symbolic_number *n, bool *bswap)\n+find_bswap_or_nop (gimple *stmt, struct symbolic_number *n, bool *bswap,\n+\t\t   bool *cast64_to_32, uint64_t *mask)\n {\n   tree type_size = TYPE_SIZE_UNIT (TREE_TYPE (gimple_get_lhs (stmt)));\n   if (!tree_fits_uhwi_p (type_size))\n@@ -929,17 +953,30 @@ find_bswap_or_nop (gimple *stmt, struct symbolic_number *n, bool *bswap)\n     }\n \n   uint64_t cmpxchg, cmpnop;\n-  find_bswap_or_nop_finalize (n, &cmpxchg, &cmpnop);\n+  find_bswap_or_nop_finalize (n, &cmpxchg, &cmpnop, cast64_to_32);\n \n   /* A complete byte swap should make the symbolic number to start with\n      the largest digit in the highest order byte. Unchanged symbolic\n      number indicates a read with same endianness as target architecture.  */\n+  *mask = ~(uint64_t) 0;\n   if (n->n == cmpnop)\n     *bswap = false;\n   else if (n->n == cmpxchg)\n     *bswap = true;\n   else\n-    return NULL;\n+    {\n+      int set = 0;\n+      for (uint64_t msk = MARKER_MASK; msk; msk <<= BITS_PER_MARKER)\n+\tif ((n->n & msk) == 0)\n+\t  *mask &= ~msk;\n+\telse if ((n->n & msk) == (cmpxchg & msk))\n+\t  set++;\n+\telse\n+\t  return NULL;\n+      if (set < 2)\n+\treturn NULL;\n+      *bswap = true;\n+    }\n \n   /* Useless bit manipulation performed by code.  */\n   if (!n->base_addr && n->n == cmpnop && n->n_ops == 1)\n@@ -1024,10 +1061,10 @@ bswap_view_convert (gimple_stmt_iterator *gsi, tree type, tree val)\n tree\n bswap_replace (gimple_stmt_iterator gsi, gimple *ins_stmt, tree fndecl,\n \t       tree bswap_type, tree load_type, struct symbolic_number *n,\n-\t       bool bswap)\n+\t       bool bswap, uint64_t mask)\n {\n   tree src, tmp, tgt = NULL_TREE;\n-  gimple *bswap_stmt;\n+  gimple *bswap_stmt, *mask_stmt = NULL;\n   tree_code conv_code = NOP_EXPR;\n \n   gimple *cur_stmt = gsi_stmt (gsi);\n@@ -1247,6 +1284,15 @@ bswap_replace (gimple_stmt_iterator gsi, gimple *ins_stmt, tree fndecl,\n     tgt = make_ssa_name (bswap_type);\n   tmp = tgt;\n \n+  if (mask != ~(uint64_t) 0)\n+    {\n+      tree m = build_int_cst (bswap_type, mask);\n+      tmp = make_temp_ssa_name (bswap_type, NULL, \"bswapdst\");\n+      gimple_set_lhs (bswap_stmt, tmp);\n+      mask_stmt = gimple_build_assign (tgt, BIT_AND_EXPR, tmp, m);\n+      tmp = tgt;\n+    }\n+\n   /* Convert the result if necessary.  */\n   if (!useless_type_conversion_p (TREE_TYPE (tgt), bswap_type))\n     {\n@@ -1260,7 +1306,7 @@ bswap_replace (gimple_stmt_iterator gsi, gimple *ins_stmt, tree fndecl,\n       gsi_insert_after (&gsi, convert_stmt, GSI_SAME_STMT);\n     }\n \n-  gimple_set_lhs (bswap_stmt, tmp);\n+  gimple_set_lhs (mask_stmt ? mask_stmt : bswap_stmt, tmp);\n \n   if (dump_file)\n     {\n@@ -1277,11 +1323,17 @@ bswap_replace (gimple_stmt_iterator gsi, gimple *ins_stmt, tree fndecl,\n \n   if (cur_stmt)\n     {\n+      if (mask_stmt)\n+\tgsi_insert_after (&gsi, mask_stmt, GSI_SAME_STMT);\n       gsi_insert_after (&gsi, bswap_stmt, GSI_SAME_STMT);\n       gsi_remove (&gsi, true);\n     }\n   else\n-    gsi_insert_before (&gsi, bswap_stmt, GSI_SAME_STMT);\n+    {\n+      gsi_insert_before (&gsi, bswap_stmt, GSI_SAME_STMT);\n+      if (mask_stmt)\n+\tgsi_insert_before (&gsi, mask_stmt, GSI_SAME_STMT);\n+    }\n   return tgt;\n }\n \n@@ -1341,8 +1393,14 @@ maybe_optimize_vector_constructor (gimple *cur_stmt)\n       return false;\n     }\n \n-  gimple *ins_stmt = find_bswap_or_nop (cur_stmt, &n, &bswap);\n-  if (!ins_stmt || n.range != (unsigned HOST_WIDE_INT) sz)\n+  bool cast64_to_32;\n+  uint64_t mask;\n+  gimple *ins_stmt = find_bswap_or_nop (cur_stmt, &n, &bswap,\n+\t\t\t\t\t&cast64_to_32, &mask);\n+  if (!ins_stmt\n+      || n.range != (unsigned HOST_WIDE_INT) sz\n+      || cast64_to_32\n+      || mask != ~(uint64_t) 0)\n     return false;\n \n   if (bswap && !fndecl && n.range != 16)\n@@ -1351,7 +1409,7 @@ maybe_optimize_vector_constructor (gimple *cur_stmt)\n   memset (&nop_stats, 0, sizeof (nop_stats));\n   memset (&bswap_stats, 0, sizeof (bswap_stats));\n   return bswap_replace (gsi_for_stmt (cur_stmt), ins_stmt, fndecl,\n-\t\t\tbswap_type, load_type, &n, bswap) != NULL_TREE;\n+\t\t\tbswap_type, load_type, &n, bswap, mask) != NULL_TREE;\n }\n \n /* Find manual byte swap implementations as well as load in a given\n@@ -1405,7 +1463,8 @@ pass_optimize_bswap::execute (function *fun)\n \t  tree fndecl = NULL_TREE, bswap_type = NULL_TREE, load_type;\n \t  enum tree_code code;\n \t  struct symbolic_number n;\n-\t  bool bswap;\n+\t  bool bswap, cast64_to_32;\n+\t  uint64_t mask;\n \n \t  /* This gsi_prev (&gsi) is not part of the for loop because cur_stmt\n \t     might be moved to a different basic block by bswap_replace and gsi\n@@ -1442,7 +1501,8 @@ pass_optimize_bswap::execute (function *fun)\n \t      continue;\n \t    }\n \n-\t  ins_stmt = find_bswap_or_nop (cur_stmt, &n, &bswap);\n+\t  ins_stmt = find_bswap_or_nop (cur_stmt, &n, &bswap,\n+\t\t\t\t\t&cast64_to_32, &mask);\n \n \t  if (!ins_stmt)\n \t    continue;\n@@ -1479,7 +1539,7 @@ pass_optimize_bswap::execute (function *fun)\n \t    continue;\n \n \t  if (bswap_replace (gsi_for_stmt (cur_stmt), ins_stmt, fndecl,\n-\t\t\t     bswap_type, load_type, &n, bswap))\n+\t\t\t     bswap_type, load_type, &n, bswap, mask))\n \t    changed = true;\n \t}\n     }\n@@ -2820,14 +2880,19 @@ imm_store_chain_info::try_coalesce_bswap (merged_store_group *merged_store,\n     }\n \n   uint64_t cmpxchg, cmpnop;\n-  find_bswap_or_nop_finalize (&n, &cmpxchg, &cmpnop);\n+  bool cast64_to_32;\n+  find_bswap_or_nop_finalize (&n, &cmpxchg, &cmpnop, &cast64_to_32);\n \n   /* A complete byte swap should make the symbolic number to start with\n      the largest digit in the highest order byte.  Unchanged symbolic\n      number indicates a read with same endianness as target architecture.  */\n   if (n.n != cmpnop && n.n != cmpxchg)\n     return false;\n \n+  /* For now.  */\n+  if (cast64_to_32)\n+    return false;\n+\n   if (n.base_addr == NULL_TREE && !is_gimple_val (n.src))\n     return false;\n \n@@ -4161,7 +4226,8 @@ imm_store_chain_info::output_merged_store (merged_store_group *group)\n \t    n->vuse = gimple_vuse (ins_stmt);\n \t}\n       bswap_res = bswap_replace (gsi_start (seq), ins_stmt, fndecl,\n-\t\t\t\t bswap_type, load_type, n, bswap);\n+\t\t\t\t bswap_type, load_type, n, bswap,\n+\t\t\t\t ~(uint64_t) 0);\n       gcc_assert (bswap_res);\n     }\n "}, {"sha": "56a2071b5ec12b3bc3c9c9b37e506d140c233def", "filename": "gcc/testsuite/gcc.dg/optimize-bswapdi-1.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b320edc0c29c838b0090c3c9be14187d132f73f2/gcc%2Ftestsuite%2Fgcc.dg%2Foptimize-bswapdi-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b320edc0c29c838b0090c3c9be14187d132f73f2/gcc%2Ftestsuite%2Fgcc.dg%2Foptimize-bswapdi-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Foptimize-bswapdi-1.c?ref=b320edc0c29c838b0090c3c9be14187d132f73f2", "patch": "@@ -1,7 +1,7 @@\n /* { dg-do compile } */\n /* { dg-require-effective-target bswap } */\n /* { dg-require-effective-target stdint_types } */\n-/* { dg-options \"-O2 -fdump-tree-bswap\" } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n /* { dg-additional-options \"-mzarch\" { target s390*-*-* } } */\n \n #include <stdint.h>\n@@ -58,4 +58,4 @@ swap64_c (uint64_t x)\n }\n \n \n-/* { dg-final { scan-tree-dump-times \"64 bit bswap implementation found at\" 3 \"bswap\" } } */\n+/* { dg-final { scan-tree-dump-times \"= __builtin_bswap64 \\\\\\(\" 3 \"optimized\" } } */"}, {"sha": "c6d96049e107f20c4906c40f896f2d8d5dcc6db9", "filename": "gcc/testsuite/gcc.dg/optimize-bswapdi-2.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b320edc0c29c838b0090c3c9be14187d132f73f2/gcc%2Ftestsuite%2Fgcc.dg%2Foptimize-bswapdi-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b320edc0c29c838b0090c3c9be14187d132f73f2/gcc%2Ftestsuite%2Fgcc.dg%2Foptimize-bswapdi-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Foptimize-bswapdi-2.c?ref=b320edc0c29c838b0090c3c9be14187d132f73f2", "patch": "@@ -1,7 +1,7 @@\n /* { dg-do compile } */\n /* { dg-require-effective-target bswap } */\n /* { dg-require-effective-target stdint_types } */\n-/* { dg-options \"-O2 -fdump-tree-bswap\" } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n /* { dg-additional-options \"-mzarch\" { target s390*-*-* } } */\n \n #include <stdint.h>\n@@ -23,4 +23,4 @@ swap64_c (uint64_t x)\n }\n \n \n-/* { dg-final { scan-tree-dump-times \"64 bit bswap implementation found at\" 1 \"bswap\" } } */\n+/* { dg-final { scan-tree-dump-times \"= __builtin_bswap64 \\\\\\(\" 1 \"optimized\" } } */"}, {"sha": "2d24f43e5e6df3154296c3c60348a701377e711b", "filename": "gcc/testsuite/gcc.dg/optimize-bswapsi-1.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b320edc0c29c838b0090c3c9be14187d132f73f2/gcc%2Ftestsuite%2Fgcc.dg%2Foptimize-bswapsi-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b320edc0c29c838b0090c3c9be14187d132f73f2/gcc%2Ftestsuite%2Fgcc.dg%2Foptimize-bswapsi-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Foptimize-bswapsi-1.c?ref=b320edc0c29c838b0090c3c9be14187d132f73f2", "patch": "@@ -1,7 +1,7 @@\n /* { dg-do compile } */\n /* { dg-require-effective-target bswap } */\n /* { dg-require-effective-target stdint_types } */\n-/* { dg-options \"-O2 -fdump-tree-bswap\" } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n /* { dg-additional-options \"-march=z900\" { target s390*-*-* } } */\n \n #include <stdint.h>\n@@ -89,4 +89,4 @@ swap32_f (unsigned in)\n   return in;\n }\n \n-/* { dg-final { scan-tree-dump-times \"32 bit bswap implementation found at\" 6 \"bswap\" } } */\n+/* { dg-final { scan-tree-dump-times \"= __builtin_bswap32 \\\\\\(\" 6 \"optimized\" } } */"}, {"sha": "7cd1b406a87109d4c1a4a747970f53471965fac9", "filename": "gcc/testsuite/gcc.dg/optimize-bswapsi-3.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b320edc0c29c838b0090c3c9be14187d132f73f2/gcc%2Ftestsuite%2Fgcc.dg%2Foptimize-bswapsi-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b320edc0c29c838b0090c3c9be14187d132f73f2/gcc%2Ftestsuite%2Fgcc.dg%2Foptimize-bswapsi-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Foptimize-bswapsi-3.c?ref=b320edc0c29c838b0090c3c9be14187d132f73f2", "patch": "@@ -1,7 +1,7 @@\n /* { dg-do compile } */\n /* { dg-require-effective-target bswap } */\n /* { dg-require-effective-target stdint_types } */\n-/* { dg-options \"-O2 -fdump-tree-bswap\" } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n /* { dg-additional-options \"-march=z900\" { target s390-*-* } } */\n \n typedef int SItype __attribute__ ((mode (SI)));\n@@ -20,4 +20,4 @@ swap32 (SItype in)\n \t | (((in >> 24) & 0xFF) << 0);\n }\n \n-/* { dg-final { scan-tree-dump-not \"32 bit bswap implementation found at\" \"bswap\" } } */\n+/* { dg-final { scan-tree-dump-times \"= __builtin_bswap32 \\\\\\(\" 1 \"optimized\" } } */"}, {"sha": "91a5284fa8114a273894f17b9627375107c0054b", "filename": "gcc/testsuite/gcc.dg/optimize-bswapsi-5.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b320edc0c29c838b0090c3c9be14187d132f73f2/gcc%2Ftestsuite%2Fgcc.dg%2Foptimize-bswapsi-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b320edc0c29c838b0090c3c9be14187d132f73f2/gcc%2Ftestsuite%2Fgcc.dg%2Foptimize-bswapsi-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Foptimize-bswapsi-5.c?ref=b320edc0c29c838b0090c3c9be14187d132f73f2", "patch": "@@ -1,6 +1,6 @@\n /* { dg-do compile } */\n /* { dg-require-effective-target bswap } */\n-/* { dg-options \"-O2 -fdump-tree-bswap -fno-inline-functions\" } */\n+/* { dg-options \"-O2 -fdump-tree-optimized -fno-inline-functions\" } */\n /* { dg-additional-options \"-march=z900\" { target s390-*-* } } */\n \n struct L { unsigned int l[2]; };\n@@ -28,4 +28,4 @@ bar (double a, struct L *p)\n   foo (a, p);\n }\n \n-/* { dg-final { scan-tree-dump-times \"32 bit bswap implementation found at\" 2 \"bswap\" } } */\n+/* { dg-final { scan-tree-dump-times \"= __builtin_bswap32 \\\\\\(\" 2 \"optimized\" } } */"}, {"sha": "e3fd6b9d4a1b2328dd3c9be5a140310fd4082cd4", "filename": "gcc/testsuite/gcc.dg/pr86723.c", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b320edc0c29c838b0090c3c9be14187d132f73f2/gcc%2Ftestsuite%2Fgcc.dg%2Fpr86723.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b320edc0c29c838b0090c3c9be14187d132f73f2/gcc%2Ftestsuite%2Fgcc.dg%2Fpr86723.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr86723.c?ref=b320edc0c29c838b0090c3c9be14187d132f73f2", "patch": "@@ -0,0 +1,63 @@\n+/* PR tree-optimization/86723 */\n+/* { dg-do run { target { ilp32 || lp64 } } } */\n+/* { dg-options \"-O2\" } */\n+\n+__attribute__((noipa)) int\n+foo (unsigned long long value)\n+{\n+  return (((value & 0x00000000000000ffull) << 56)\n+\t  | ((value & 0x000000000000ff00ull) << 40)\n+\t  | ((value & 0x0000000000ff0000ull) << 24)\n+\t  | ((value & 0x00000000ff000000ull) << 8)\n+\t  | ((value & 0x000000ff00000000ull) >> 8)\n+\t  | ((value & 0x0000ff0000000000ull) >> 24)\n+\t  | ((value & 0x00ff000000000000ull) >> 40)\n+\t  | ((value & 0xff00000000000000ull) >> 56));\n+}\n+\n+__attribute__((noipa)) int\n+bar (unsigned long long value)\n+{\n+  return (((value & 0x000000ff00000000ull) >> 8)\n+\t  | ((value & 0x0000ff0000000000ull) >> 24)\n+\t  | ((value & 0x00ff000000000000ull) >> 40)\n+\t  | ((value & 0xff00000000000000ull) >> 56));\n+}\n+\n+__attribute__((noipa)) unsigned long long\n+baz (unsigned long long value)\n+{\n+  return (((value & 0x00000000000000ffull) << 56)\n+\t  | ((value & 0x000000000000ff00ull) << 40)\n+\t  | ((value & 0x00000000ff000000ull) << 8)\n+\t  | ((value & 0x000000ff00000000ull) >> 8)\n+\t  | ((value & 0x0000ff0000000000ull) >> 24)\n+\t  | ((value & 0xff00000000000000ull) >> 56));\n+}\n+\n+__attribute__((noipa)) unsigned int\n+qux (unsigned int value)\n+{\n+  return (((value & 0x000000ff) << 24)\n+\t  | ((value & 0x00ff0000) >> 8)\n+\t  | ((value & 0xff000000) >> 24));\n+}\n+\n+__attribute__((noipa)) unsigned int\n+corge (unsigned int value)\n+{\n+  return (((value & 0x000000ff) << 24)\n+\t  | ((value & 0xff000000) >> 24));\n+}\n+\n+int\n+main ()\n+{\n+  if (foo (0x0102030405060708ull) != 0x04030201\n+      || bar (0x0102030405060708ull) != 0x04030201\n+      || baz (0x0102030405060708ull) != 0x0807000504030001ull\n+      || qux (0x01020304) != 0x04000201\n+      || corge (0x01020304) != 0x04000001)\n+    __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "b61d750c01a3a5cfeecd20c67f9c97effecd6f65", "filename": "gcc/testsuite/gcc.target/i386/pr86723.c", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b320edc0c29c838b0090c3c9be14187d132f73f2/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr86723.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b320edc0c29c838b0090c3c9be14187d132f73f2/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr86723.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr86723.c?ref=b320edc0c29c838b0090c3c9be14187d132f73f2", "patch": "@@ -0,0 +1,52 @@\n+/* PR tree-optimization/86723 */\n+/* { dg-do compile { target lp64 } } */\n+/* { dg-options \"-O2\" } */\n+/* { dg-final { scan-assembler-times \"\\tbswap\\t\" 5 } } */\n+\n+int\n+foo (unsigned long long value)\n+{\n+  return (((value & 0x00000000000000ffull) << 56)\n+\t  | ((value & 0x000000000000ff00ull) << 40)\n+\t  | ((value & 0x0000000000ff0000ull) << 24)\n+\t  | ((value & 0x00000000ff000000ull) << 8)\n+\t  | ((value & 0x000000ff00000000ull) >> 8)\n+\t  | ((value & 0x0000ff0000000000ull) >> 24)\n+\t  | ((value & 0x00ff000000000000ull) >> 40)\n+\t  | ((value & 0xff00000000000000ull) >> 56));\n+}\n+\n+int\n+bar (unsigned long long value)\n+{\n+  return (((value & 0x000000ff00000000ull) >> 8)\n+\t  | ((value & 0x0000ff0000000000ull) >> 24)\n+\t  | ((value & 0x00ff000000000000ull) >> 40)\n+\t  | ((value & 0xff00000000000000ull) >> 56));\n+}\n+\n+unsigned long long\n+baz (unsigned long long value)\n+{\n+  return (((value & 0x00000000000000ffull) << 56)\n+\t  | ((value & 0x000000000000ff00ull) << 40)\n+\t  | ((value & 0x00000000ff000000ull) << 8)\n+\t  | ((value & 0x000000ff00000000ull) >> 8)\n+\t  | ((value & 0x0000ff0000000000ull) >> 24)\n+\t  | ((value & 0xff00000000000000ull) >> 56));\n+}\n+\n+unsigned int\n+qux (unsigned int value)\n+{\n+  return (((value & 0x000000ff) << 24)\n+\t  | ((value & 0x00ff0000) >> 8)\n+\t  | ((value & 0xff000000) >> 24));\n+}\n+\n+unsigned int\n+corge (unsigned int value)\n+{\n+  return (((value & 0x000000ff) << 24)\n+\t  | ((value & 0xff000000) >> 24));\n+}"}]}