{"sha": "38bf819a5f995ae4621496df2324d68b9e24900f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzhiZjgxOWE1Zjk5NWFlNDYyMTQ5NmRmMjMyNGQ2OGI5ZTI0OTAwZg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2015-01-16T22:58:53Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2015-01-16T22:58:53Z"}, "message": "compiler, reflect, runtime: Use static chain for closures.\n\nChange from using __go_set_closure to passing the closure\nvalue in the static chain field.  Uses new backend support for\nsetting the closure chain in a call from C via\n__builtin_call_with_static_chain.  Uses new support in libffi\nfor Go closures.\n\nThe old architecture specific support for reflect.MakeFunc is\nremoved, replaced by the libffi support.\n\nAll work done by Richard Henderson.\n\n\t* go-gcc.cc (Gcc_backend::call_expression): Add chain_expr argument.\n\t(Gcc_backend::static_chain_variable): New method.\n\nFrom-SVN: r219776", "tree": {"sha": "c90d2bfba44756e26640c50ad1389375693ef832", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c90d2bfba44756e26640c50ad1389375693ef832"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/38bf819a5f995ae4621496df2324d68b9e24900f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38bf819a5f995ae4621496df2324d68b9e24900f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38bf819a5f995ae4621496df2324d68b9e24900f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38bf819a5f995ae4621496df2324d68b9e24900f/comments", "author": null, "committer": null, "parents": [{"sha": "21cb351825d45c42e9e5148715a2fd2051cf4ed1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21cb351825d45c42e9e5148715a2fd2051cf4ed1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/21cb351825d45c42e9e5148715a2fd2051cf4ed1"}], "stats": {"total": 2554, "additions": 174, "deletions": 2380}, "files": [{"sha": "a2d236c18338b47e67c886081b13125ee9021fc2", "filename": "gcc/go/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38bf819a5f995ae4621496df2324d68b9e24900f/gcc%2Fgo%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38bf819a5f995ae4621496df2324d68b9e24900f/gcc%2Fgo%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2FChangeLog?ref=38bf819a5f995ae4621496df2324d68b9e24900f", "patch": "@@ -1,3 +1,8 @@\n+2015-01-16  Richard Henderson  <rth@redhat.com>\n+\n+\t* go-gcc.cc (Gcc_backend::call_expression): Add chain_expr argument.\n+\t(Gcc_backend::static_chain_variable): New method.\n+\n 2015-01-09  Ian Lance Taylor  <iant@google.com>\n \n \t* config-lang.in (lang_dirs): Define."}, {"sha": "1ce1ff2f79b5accec36aaeb2a36737a478ee73d6", "filename": "gcc/go/go-gcc.cc", "status": "modified", "additions": 42, "deletions": 2, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38bf819a5f995ae4621496df2324d68b9e24900f/gcc%2Fgo%2Fgo-gcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38bf819a5f995ae4621496df2324d68b9e24900f/gcc%2Fgo%2Fgo-gcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgo-gcc.cc?ref=38bf819a5f995ae4621496df2324d68b9e24900f", "patch": "@@ -322,7 +322,7 @@ class Gcc_backend : public Backend\n \n   Bexpression*\n   call_expression(Bexpression* fn, const std::vector<Bexpression*>& args,\n-                  Location);\n+                  Bexpression* static_chain, Location);\n \n   // Statements.\n \n@@ -402,6 +402,9 @@ class Gcc_backend : public Backend\n   parameter_variable(Bfunction*, const std::string&, Btype*, bool,\n \t\t     Location);\n \n+  Bvariable*\n+  static_chain_variable(Bfunction*, const std::string&, Btype*, Location);\n+\n   Bvariable*\n   temporary_variable(Bfunction*, Bblock*, Btype*, Bexpression*, bool,\n \t\t     Location, Bstatement**);\n@@ -1808,7 +1811,7 @@ Gcc_backend::array_index_expression(Bexpression* array, Bexpression* index,\n Bexpression*\n Gcc_backend::call_expression(Bexpression* fn_expr,\n                              const std::vector<Bexpression*>& fn_args,\n-                             Location location)\n+                             Bexpression* chain_expr, Location location)\n {\n   tree fn = fn_expr->get_tree();\n   if (fn == error_mark_node || TREE_TYPE(fn) == error_mark_node)\n@@ -1868,6 +1871,9 @@ Gcc_backend::call_expression(Bexpression* fn_expr,\n                            excess_type != NULL_TREE ? excess_type : rettype,\n                            fn, nargs, args);\n \n+  if (chain_expr)\n+    CALL_EXPR_STATIC_CHAIN (ret) = chain_expr->get_tree();\n+\n   if (excess_type != NULL_TREE)\n     {\n       // Calling convert here can undo our excess precision change.\n@@ -2489,6 +2495,40 @@ Gcc_backend::parameter_variable(Bfunction* function, const std::string& name,\n   return new Bvariable(decl);\n }\n \n+// Make a static chain variable.\n+\n+Bvariable*\n+Gcc_backend::static_chain_variable(Bfunction* function, const std::string& name,\n+\t\t\t\t   Btype* btype, Location location)\n+{\n+  tree type_tree = btype->get_tree();\n+  if (type_tree == error_mark_node)\n+    return this->error_variable();\n+  tree decl = build_decl(location.gcc_location(), PARM_DECL,\n+\t\t\t get_identifier_from_string(name), type_tree);\n+  tree fndecl = function->get_tree();\n+  DECL_CONTEXT(decl) = fndecl;\n+  DECL_ARG_TYPE(decl) = type_tree;\n+  TREE_USED(decl) = 1;\n+  DECL_ARTIFICIAL(decl) = 1;\n+  DECL_IGNORED_P(decl) = 1;\n+  TREE_READONLY(decl) = 1;\n+\n+  struct function *f = DECL_STRUCT_FUNCTION(fndecl);\n+  if (f == NULL)\n+    {\n+      push_struct_function(fndecl);\n+      pop_cfun();\n+      f = DECL_STRUCT_FUNCTION(fndecl);\n+    }\n+  gcc_assert(f->static_chain_decl == NULL);\n+  f->static_chain_decl = decl;\n+  DECL_STATIC_CHAIN(fndecl) = 1;\n+\n+  go_preserve_from_gc(decl);\n+  return new Bvariable(decl);\n+}\n+\n // Make a temporary variable.\n \n Bvariable*"}, {"sha": "31ed8dff0a6fae3bae3c54b03f48a2bf1580cad6", "filename": "gcc/go/gofrontend/backend.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38bf819a5f995ae4621496df2324d68b9e24900f/gcc%2Fgo%2Fgofrontend%2Fbackend.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38bf819a5f995ae4621496df2324d68b9e24900f/gcc%2Fgo%2Fgofrontend%2Fbackend.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fbackend.h?ref=38bf819a5f995ae4621496df2324d68b9e24900f", "patch": "@@ -375,7 +375,7 @@ class Backend\n   // Create an expression for a call to FN with ARGS.\n   virtual Bexpression*\n   call_expression(Bexpression* fn, const std::vector<Bexpression*>& args,\n-                  Location) = 0;\n+\t\t  Bexpression* static_chain, Location) = 0;\n \n   // Statements.\n \n@@ -529,6 +529,11 @@ class Backend\n \t\t     Btype* type, bool is_address_taken,\n \t\t     Location location) = 0;\n \n+  // Create a static chain parameter.  This is the closure parameter.\n+  virtual Bvariable*\n+  static_chain_variable(Bfunction* function, const std::string& name,\n+\t\t        Btype* type, Location location) = 0;\n+\n   // Create a temporary variable.  A temporary variable has no name,\n   // just a type.  We pass in FUNCTION and BLOCK in case they are\n   // needed.  If INIT is not NULL, the variable should be initialized"}, {"sha": "ee8af849f50892c29884d8bac707f9360e0817b0", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38bf819a5f995ae4621496df2324d68b9e24900f/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38bf819a5f995ae4621496df2324d68b9e24900f/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=38bf819a5f995ae4621496df2324d68b9e24900f", "patch": "@@ -6321,6 +6321,7 @@ Bound_method_expression::create_thunk(Gogo* gogo, const Method* method,\n \n   Variable* cvar = new Variable(closure_type, NULL, false, false, false, loc);\n   cvar->set_is_used();\n+  cvar->set_is_closure();\n   Named_object* cp = Named_object::make_variable(\"$closure\", NULL, cvar);\n   new_no->func_value()->set_closure_var(cp);\n \n@@ -9328,19 +9329,11 @@ Call_expression::do_get_backend(Translate_context* context)\n       fn_args[0] = first_arg->get_backend(context);\n     }\n \n-  if (!has_closure_arg)\n-    go_assert(closure == NULL);\n+  Bexpression* bclosure = NULL;\n+  if (has_closure_arg)\n+    bclosure = closure->get_backend(context);\n   else\n-    {\n-      // Pass the closure argument by calling the function function\n-      // __go_set_closure.  In the order_evaluations pass we have\n-      // ensured that if any parameters contain call expressions, they\n-      // will have been moved out to temporary variables.\n-      go_assert(closure != NULL);\n-      Expression* set_closure =\n-          Runtime::make_call(Runtime::SET_CLOSURE, location, 1, closure);\n-      fn = Expression::make_compound(set_closure, fn, location);\n-    }\n+    go_assert(closure == NULL);\n \n   Bexpression* bfn = fn->get_backend(context);\n \n@@ -9356,7 +9349,8 @@ Call_expression::do_get_backend(Translate_context* context)\n       bfn = gogo->backend()->convert_expression(bft, bfn, location);\n     }\n \n-  Bexpression* call = gogo->backend()->call_expression(bfn, fn_args, location);\n+  Bexpression* call = gogo->backend()->call_expression(bfn, fn_args,\n+\t\t\t\t\t\t       bclosure, location);\n \n   if (this->results_ != NULL)\n     {\n@@ -11132,6 +11126,7 @@ Interface_field_reference_expression::create_thunk(Gogo* gogo,\n \n   Variable* cvar = new Variable(closure_type, NULL, false, false, false, loc);\n   cvar->set_is_used();\n+  cvar->set_is_closure();\n   Named_object* cp = Named_object::make_variable(\"$closure\", NULL, cvar);\n   new_no->func_value()->set_closure_var(cp);\n "}, {"sha": "7bc54fcd658be09a1ba1e7b2e4f9935ebb989fad", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38bf819a5f995ae4621496df2324d68b9e24900f/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38bf819a5f995ae4621496df2324d68b9e24900f/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=38bf819a5f995ae4621496df2324d68b9e24900f", "patch": "@@ -698,7 +698,8 @@ Gogo::init_imports(std::vector<Bstatement*>& init_stmts)\n       Bexpression* pfunc_code =\n           this->backend()->function_code_expression(pfunc, unknown_loc);\n       Bexpression* pfunc_call =\n-          this->backend()->call_expression(pfunc_code, empty_args, unknown_loc);\n+\tthis->backend()->call_expression(pfunc_code, empty_args,\n+\t\t\t\t\t NULL, unknown_loc);\n       init_stmts.push_back(this->backend()->expression_statement(pfunc_call));\n     }\n }\n@@ -1413,7 +1414,7 @@ Gogo::write_globals()\n           this->backend()->function_code_expression(initfn, func_loc);\n       Bexpression* call = this->backend()->call_expression(func_code,\n                                                            empty_args,\n-                                                           func_loc);\n+\t\t\t\t\t\t\t   NULL, func_loc);\n       init_stmts.push_back(this->backend()->expression_statement(call));\n     }\n \n@@ -3915,6 +3916,7 @@ Build_recover_thunks::function(Named_object* orig_no)\n       Variable* orig_closure_var = orig_closure_no->var_value();\n       Variable* new_var = new Variable(orig_closure_var->type(), NULL, false,\n \t\t\t\t       false, false, location);\n+      new_var->set_is_closure();\n       snprintf(buf, sizeof buf, \"closure.%u\", count);\n       ++count;\n       Named_object* new_closure_no = Named_object::make_variable(buf, NULL,\n@@ -4518,6 +4520,7 @@ Function::closure_var()\n       Variable* var = new Variable(Type::make_pointer_type(struct_type),\n \t\t\t\t   NULL, false, false, false, loc);\n       var->set_is_used();\n+      var->set_is_closure();\n       this->closure_var_ = Named_object::make_variable(\"$closure\", NULL, var);\n       // Note that the new variable is not in any binding contour.\n     }\n@@ -5188,18 +5191,12 @@ Function::build(Gogo* gogo, Named_object* named_function)\n       return;\n     }\n \n-  // If we need a closure variable, fetch it by calling a runtime\n-  // function.  The caller will have called __go_set_closure before\n-  // the function call.\n+  // If we need a closure variable, make sure to create it.\n+  // It gets installed in the function as a side effect of creation.\n   if (this->closure_var_ != NULL)\n     {\n-      Bvariable* closure_bvar =\n-\tthis->closure_var_->get_backend_variable(gogo, named_function);\n-      vars.push_back(closure_bvar);\n-\n-      Expression* closure =\n-          Runtime::make_call(Runtime::GET_CLOSURE, this->location_, 0);\n-      var_inits.push_back(closure->get_backend(&context));\n+      go_assert(this->closure_var_->var_value()->is_closure());\n+      this->closure_var_->get_backend_variable(gogo, named_function);\n     }\n \n   if (this->block_ != NULL)\n@@ -5733,7 +5730,8 @@ Variable::Variable(Type* type, Expression* init, bool is_global,\n \t\t   Location location)\n   : type_(type), init_(init), preinit_(NULL), location_(location),\n     backend_(NULL), is_global_(is_global), is_parameter_(is_parameter),\n-    is_receiver_(is_receiver), is_varargs_parameter_(false), is_used_(false),\n+    is_closure_(false), is_receiver_(is_receiver),\n+    is_varargs_parameter_(false), is_used_(false),\n     is_address_taken_(false), is_non_escaping_address_taken_(false),\n     seen_(false), init_is_lowered_(false), init_is_flattened_(false),\n     type_from_init_tuple_(false), type_from_range_index_(false),\n@@ -6287,7 +6285,10 @@ Variable::get_backend_variable(Gogo* gogo, Named_object* function,\n \t      Bfunction* bfunction = function->func_value()->get_decl();\n \t      bool is_address_taken = (this->is_non_escaping_address_taken_\n \t\t\t\t       && !this->is_in_heap());\n-\t      if (is_parameter)\n+\t      if (this->is_closure())\n+\t\tbvar = backend->static_chain_variable(bfunction, n, btype,\n+\t\t\t\t\t\t      this->location_);\n+\t      else if (is_parameter)\n \t\tbvar = backend->parameter_variable(bfunction, n, btype,\n \t\t\t\t\t\t   is_address_taken,\n \t\t\t\t\t\t   this->location_);"}, {"sha": "8a1663703aac4661e8810efc3767d557d51b3a3f", "filename": "gcc/go/gofrontend/gogo.h", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38bf819a5f995ae4621496df2324d68b9e24900f/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38bf819a5f995ae4621496df2324d68b9e24900f/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.h?ref=38bf819a5f995ae4621496df2324d68b9e24900f", "patch": "@@ -1364,6 +1364,18 @@ class Variable\n   is_parameter() const\n   { return this->is_parameter_; }\n \n+  // Return whether this is a closure (static chain) parameter.\n+  bool\n+  is_closure() const\n+  { return this->is_closure_; }\n+\n+  // Change this parameter to be a closure.\n+  void\n+  set_is_closure()\n+  {\n+    this->is_closure_ = true;\n+  }\n+\n   // Return whether this is the receiver parameter of a method.\n   bool\n   is_receiver() const\n@@ -1585,6 +1597,8 @@ class Variable\n   bool is_global_ : 1;\n   // Whether this is a function parameter.\n   bool is_parameter_ : 1;\n+  // Whether this is a closure parameter.\n+  bool is_closure_ : 1;\n   // Whether this is the receiver parameter of a method.\n   bool is_receiver_ : 1;\n   // Whether this is the varargs parameter of a function."}, {"sha": "43025dd7b61c90d5bbc218d6b94cefca75fbe959", "filename": "gcc/go/gofrontend/runtime.def", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38bf819a5f995ae4621496df2324d68b9e24900f/gcc%2Fgo%2Fgofrontend%2Fruntime.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38bf819a5f995ae4621496df2324d68b9e24900f/gcc%2Fgo%2Fgofrontend%2Fruntime.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fruntime.def?ref=38bf819a5f995ae4621496df2324d68b9e24900f", "patch": "@@ -230,12 +230,6 @@ DEF_GO_RUNTIME(NEW_NOPOINTERS, \"__go_new_nopointers\", P2(TYPE, UINTPTR), R1(POIN\n // Start a new goroutine.\n DEF_GO_RUNTIME(GO, \"__go_go\", P2(FUNC_PTR, POINTER), R0())\n \n-// Get the function closure.\n-DEF_GO_RUNTIME(GET_CLOSURE, \"__go_get_closure\", P0(), R1(POINTER))\n-\n-// Set the function closure.\n-DEF_GO_RUNTIME(SET_CLOSURE, \"__go_set_closure\", P1(POINTER), R0())\n-\n // Defer a function.\n DEF_GO_RUNTIME(DEFER, \"__go_defer\", P3(BOOLPTR, FUNC_PTR, POINTER), R0())\n "}, {"sha": "727662d5f1dc65bd1ebea2065eac5f2c17826e1b", "filename": "libgo/Makefile.am", "status": "modified", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38bf819a5f995ae4621496df2324d68b9e24900f/libgo%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38bf819a5f995ae4621496df2324d68b9e24900f/libgo%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.am?ref=38bf819a5f995ae4621496df2324d68b9e24900f", "patch": "@@ -938,44 +938,10 @@ go_path_files = \\\n \tgo/path/match.go \\\n \tgo/path/path.go\n \n-if LIBGO_IS_X86_64\n-go_reflect_makefunc_file = \\\n-\tgo/reflect/makefuncgo_amd64.go\n-go_reflect_makefunc_s_file = \\\n-\tgo/reflect/makefunc_amd64.S\n-else\n-if LIBGO_IS_386\n-go_reflect_makefunc_file = \\\n-\tgo/reflect/makefuncgo_386.go\n-go_reflect_makefunc_s_file = \\\n-\tgo/reflect/makefunc_386.S\n-else\n-if LIBGO_IS_S390\n-go_reflect_makefunc_file = \\\n-\tgo/reflect/makefuncgo_s390.go\n-go_reflect_makefunc_s_file = \\\n-\tgo/reflect/makefunc_s390.c\n-else\n-if LIBGO_IS_S390X\n-go_reflect_makefunc_file = \\\n-\tgo/reflect/makefuncgo_s390x.go \\\n-\tgo/reflect/makefuncgo_s390.go\n-go_reflect_makefunc_s_file = \\\n-\tgo/reflect/makefunc_s390.c\n-else\n-go_reflect_makefunc_file =\n-go_reflect_makefunc_s_file = \\\n-\tgo/reflect/makefunc_dummy.c\n-endif\n-endif\n-endif\n-endif\n-\n go_reflect_files = \\\n \tgo/reflect/deepequal.go \\\n \tgo/reflect/makefunc.go \\\n \tgo/reflect/makefunc_ffi.go \\\n-\t$(go_reflect_makefunc_file) \\\n \tgo/reflect/type.go \\\n \tgo/reflect/value.go\n go_reflect_makefunc_c_file = \\\n@@ -1897,7 +1863,6 @@ libgo_go_objs = \\\n \tos.lo \\\n \tpath.lo \\\n \treflect-go.lo \\\n-\treflect/makefunc.lo \\\n \treflect/makefunc_ffi_c.lo \\\n \tregexp.lo \\\n \truntime-go.lo \\\n@@ -2316,9 +2281,6 @@ reflect-go.lo: $(go_reflect_files)\n \t$(BUILDPACKAGE)\n reflect/check: $(CHECK_DEPS)\n \t@$(CHECK)\n-reflect/makefunc.lo: $(go_reflect_makefunc_s_file)\n-\t@$(MKDIR_P) reflect\n-\t$(LTCOMPILE) -c -o $@ $<\n reflect/makefunc_ffi_c.lo: $(go_reflect_makefunc_c_file)\n \t@$(MKDIR_P) reflect\n \t$(LTCOMPILE) -c -o $@ $<"}, {"sha": "7c8fc320d93b0319cf378086ffa71f3334411cb5", "filename": "libgo/Makefile.in", "status": "modified", "additions": 5, "deletions": 39, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38bf819a5f995ae4621496df2324d68b9e24900f/libgo%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38bf819a5f995ae4621496df2324d68b9e24900f/libgo%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.in?ref=38bf819a5f995ae4621496df2324d68b9e24900f", "patch": "@@ -141,11 +141,11 @@ am__DEPENDENCIES_1 =\n am__DEPENDENCIES_2 = bufio.lo bytes.lo bytes/index.lo crypto.lo \\\n \tencoding.lo errors.lo expvar.lo flag.lo fmt.lo hash.lo html.lo \\\n \timage.lo io.lo log.lo math.lo mime.lo net.lo os.lo path.lo \\\n-\treflect-go.lo reflect/makefunc.lo reflect/makefunc_ffi_c.lo \\\n-\tregexp.lo runtime-go.lo sort.lo strconv.lo strings.lo \\\n-\tstrings/index.lo sync.lo syscall.lo syscall/errno.lo \\\n-\tsyscall/signame.lo syscall/wait.lo testing.lo time-go.lo \\\n-\tunicode.lo archive/tar.lo archive/zip.lo compress/bzip2.lo \\\n+\treflect-go.lo reflect/makefunc_ffi_c.lo regexp.lo \\\n+\truntime-go.lo sort.lo strconv.lo strings.lo strings/index.lo \\\n+\tsync.lo syscall.lo syscall/errno.lo syscall/signame.lo \\\n+\tsyscall/wait.lo testing.lo time-go.lo unicode.lo \\\n+\tarchive/tar.lo archive/zip.lo compress/bzip2.lo \\\n \tcompress/flate.lo compress/gzip.lo compress/lzw.lo \\\n \tcompress/zlib.lo container/heap.lo container/list.lo \\\n \tcontainer/ring.lo crypto/aes.lo crypto/cipher.lo crypto/des.lo \\\n@@ -1125,40 +1125,10 @@ go_path_files = \\\n \tgo/path/match.go \\\n \tgo/path/path.go\n \n-@LIBGO_IS_386_FALSE@@LIBGO_IS_S390X_FALSE@@LIBGO_IS_S390_FALSE@@LIBGO_IS_X86_64_FALSE@go_reflect_makefunc_file = \n-@LIBGO_IS_386_FALSE@@LIBGO_IS_S390X_TRUE@@LIBGO_IS_S390_FALSE@@LIBGO_IS_X86_64_FALSE@go_reflect_makefunc_file = \\\n-@LIBGO_IS_386_FALSE@@LIBGO_IS_S390X_TRUE@@LIBGO_IS_S390_FALSE@@LIBGO_IS_X86_64_FALSE@\tgo/reflect/makefuncgo_s390x.go \\\n-@LIBGO_IS_386_FALSE@@LIBGO_IS_S390X_TRUE@@LIBGO_IS_S390_FALSE@@LIBGO_IS_X86_64_FALSE@\tgo/reflect/makefuncgo_s390.go\n-\n-@LIBGO_IS_386_FALSE@@LIBGO_IS_S390_TRUE@@LIBGO_IS_X86_64_FALSE@go_reflect_makefunc_file = \\\n-@LIBGO_IS_386_FALSE@@LIBGO_IS_S390_TRUE@@LIBGO_IS_X86_64_FALSE@\tgo/reflect/makefuncgo_s390.go\n-\n-@LIBGO_IS_386_TRUE@@LIBGO_IS_X86_64_FALSE@go_reflect_makefunc_file = \\\n-@LIBGO_IS_386_TRUE@@LIBGO_IS_X86_64_FALSE@\tgo/reflect/makefuncgo_386.go\n-\n-@LIBGO_IS_X86_64_TRUE@go_reflect_makefunc_file = \\\n-@LIBGO_IS_X86_64_TRUE@\tgo/reflect/makefuncgo_amd64.go\n-\n-@LIBGO_IS_386_FALSE@@LIBGO_IS_S390X_FALSE@@LIBGO_IS_S390_FALSE@@LIBGO_IS_X86_64_FALSE@go_reflect_makefunc_s_file = \\\n-@LIBGO_IS_386_FALSE@@LIBGO_IS_S390X_FALSE@@LIBGO_IS_S390_FALSE@@LIBGO_IS_X86_64_FALSE@\tgo/reflect/makefunc_dummy.c\n-\n-@LIBGO_IS_386_FALSE@@LIBGO_IS_S390X_TRUE@@LIBGO_IS_S390_FALSE@@LIBGO_IS_X86_64_FALSE@go_reflect_makefunc_s_file = \\\n-@LIBGO_IS_386_FALSE@@LIBGO_IS_S390X_TRUE@@LIBGO_IS_S390_FALSE@@LIBGO_IS_X86_64_FALSE@\tgo/reflect/makefunc_s390.c\n-\n-@LIBGO_IS_386_FALSE@@LIBGO_IS_S390_TRUE@@LIBGO_IS_X86_64_FALSE@go_reflect_makefunc_s_file = \\\n-@LIBGO_IS_386_FALSE@@LIBGO_IS_S390_TRUE@@LIBGO_IS_X86_64_FALSE@\tgo/reflect/makefunc_s390.c\n-\n-@LIBGO_IS_386_TRUE@@LIBGO_IS_X86_64_FALSE@go_reflect_makefunc_s_file = \\\n-@LIBGO_IS_386_TRUE@@LIBGO_IS_X86_64_FALSE@\tgo/reflect/makefunc_386.S\n-\n-@LIBGO_IS_X86_64_TRUE@go_reflect_makefunc_s_file = \\\n-@LIBGO_IS_X86_64_TRUE@\tgo/reflect/makefunc_amd64.S\n-\n go_reflect_files = \\\n \tgo/reflect/deepequal.go \\\n \tgo/reflect/makefunc.go \\\n \tgo/reflect/makefunc_ffi.go \\\n-\t$(go_reflect_makefunc_file) \\\n \tgo/reflect/type.go \\\n \tgo/reflect/value.go\n \n@@ -1963,7 +1933,6 @@ libgo_go_objs = \\\n \tos.lo \\\n \tpath.lo \\\n \treflect-go.lo \\\n-\treflect/makefunc.lo \\\n \treflect/makefunc_ffi_c.lo \\\n \tregexp.lo \\\n \truntime-go.lo \\\n@@ -4657,9 +4626,6 @@ reflect-go.lo: $(go_reflect_files)\n \t$(BUILDPACKAGE)\n reflect/check: $(CHECK_DEPS)\n \t@$(CHECK)\n-reflect/makefunc.lo: $(go_reflect_makefunc_s_file)\n-\t@$(MKDIR_P) reflect\n-\t$(LTCOMPILE) -c -o $@ $<\n reflect/makefunc_ffi_c.lo: $(go_reflect_makefunc_c_file)\n \t@$(MKDIR_P) reflect\n \t$(LTCOMPILE) -c -o $@ $<"}, {"sha": "71aadfbceec784540b030d5a1b1164c2ea846ce3", "filename": "libgo/go/reflect/makefunc.go", "status": "modified", "additions": 11, "deletions": 50, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38bf819a5f995ae4621496df2324d68b9e24900f/libgo%2Fgo%2Freflect%2Fmakefunc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38bf819a5f995ae4621496df2324d68b9e24900f/libgo%2Fgo%2Freflect%2Fmakefunc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fmakefunc.go?ref=38bf819a5f995ae4621496df2324d68b9e24900f", "patch": "@@ -7,25 +7,24 @@\n package reflect\n \n import (\n-\t\"runtime\"\n \t\"unsafe\"\n )\n \n // makeFuncImpl is the closure value implementing the function\n // returned by MakeFunc.\n type makeFuncImpl struct {\n-\tcode uintptr\n-\ttyp  *funcType\n-\tfn   func([]Value) []Value\n+\t// These first three words are layed out like ffi_go_closure.\n+\tcode    uintptr\n+\tffi_cif unsafe.Pointer\n+\tffi_fun func(unsafe.Pointer, unsafe.Pointer)\n+\n+\ttyp *funcType\n+\tfn  func([]Value) []Value\n \n \t// For gccgo we use the same entry point for functions and for\n \t// method values.\n \tmethod int\n \trcvr   Value\n-\n-\t// When using FFI, hold onto the FFI closure for the garbage\n-\t// collector.\n-\tffi *ffiData\n }\n \n // MakeFunc returns a new function of the given Type\n@@ -58,37 +57,17 @@ func MakeFunc(typ Type, fn func(args []Value) (results []Value)) Value {\n \tt := typ.common()\n \tftyp := (*funcType)(unsafe.Pointer(t))\n \n-\tvar code uintptr\n-\tvar ffi *ffiData\n-\tswitch runtime.GOARCH {\n-\tcase \"amd64\", \"386\", \"s390\", \"s390x\":\n-\t\t// Indirect Go func value (dummy) to obtain actual\n-\t\t// code address. (A Go func value is a pointer to a C\n-\t\t// function pointer. http://golang.org/s/go11func.)\n-\t\tdummy := makeFuncStub\n-\t\tcode = **(**uintptr)(unsafe.Pointer(&dummy))\n-\tdefault:\n-\t\tcode, ffi = makeFuncFFI(ftyp, fn)\n-\t}\n-\n \timpl := &makeFuncImpl{\n-\t\tcode:   code,\n \t\ttyp:    ftyp,\n \t\tfn:     fn,\n \t\tmethod: -1,\n-\t\tffi:    ffi,\n \t}\n \n+\tmakeFuncFFI(ftyp, impl)\n+\n \treturn Value{t, unsafe.Pointer(&impl), flag(Func) | flagIndir}\n }\n \n-// makeFuncStub is an assembly function that is the code half of\n-// the function returned from MakeFunc. It expects a *callReflectFunc\n-// as its context register, and its job is to invoke callReflect(ctxt, frame)\n-// where ctxt is the context register and frame is a pointer to the first\n-// word in the passed-in argument frame.\n-func makeFuncStub()\n-\n // makeMethodValue converts v from the rcvr+method index representation\n // of a method value to an actual method func value, which is\n // basically the receiver value with a special bit set, into a true\n@@ -123,16 +102,7 @@ func makeMethodValue(op string, v Value) Value {\n \t\trcvr:   rcvr,\n \t}\n \n-\tswitch runtime.GOARCH {\n-\tcase \"amd64\", \"386\":\n-\t\t// Indirect Go func value (dummy) to obtain actual\n-\t\t// code address. (A Go func value is a pointer to a C\n-\t\t// function pointer. http://golang.org/s/go11func.)\n-\t\tdummy := makeFuncStub\n-\t\tfv.code = **(**uintptr)(unsafe.Pointer(&dummy))\n-\tdefault:\n-\t\tfv.code, fv.ffi = makeFuncFFI(ftyp, fv.call)\n-\t}\n+\tmakeFuncFFI(ftyp, fv)\n \n \treturn Value{ft, unsafe.Pointer(&fv), v.flag&flagRO | flag(Func) | flagIndir}\n }\n@@ -158,16 +128,7 @@ func makeValueMethod(v Value) Value {\n \t\trcvr:   v,\n \t}\n \n-\tswitch runtime.GOARCH {\n-\tcase \"amd64\", \"386\", \"s390\", \"s390x\":\n-\t\t// Indirect Go func value (dummy) to obtain actual\n-\t\t// code address. (A Go func value is a pointer to a C\n-\t\t// function pointer. http://golang.org/s/go11func.)\n-\t\tdummy := makeFuncStub\n-\t\timpl.code = **(**uintptr)(unsafe.Pointer(&dummy))\n-\tdefault:\n-\t\timpl.code, impl.ffi = makeFuncFFI(ftyp, impl.call)\n-\t}\n+\tmakeFuncFFI(ftyp, impl)\n \n \treturn Value{t, unsafe.Pointer(&impl), v.flag&flagRO | flag(Func) | flagIndir}\n }"}, {"sha": "0e2e7646532447d9d3f8b2c0bf7a3aa679a8df5b", "filename": "libgo/go/reflect/makefunc_386.S", "status": "removed", "additions": 0, "deletions": 230, "changes": 230, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21cb351825d45c42e9e5148715a2fd2051cf4ed1/libgo%2Fgo%2Freflect%2Fmakefunc_386.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21cb351825d45c42e9e5148715a2fd2051cf4ed1/libgo%2Fgo%2Freflect%2Fmakefunc_386.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fmakefunc_386.S?ref=21cb351825d45c42e9e5148715a2fd2051cf4ed1", "patch": "@@ -1,230 +0,0 @@\n-/* Copyright 2013 The Go Authors. All rights reserved.\n-   Use of this source code is governed by a BSD-style\n-   license that can be found in the LICENSE file.\n-\n-   MakeFunc 386 assembly code.  */\n-\n-#include \"config.h\"\n-\n-\t.globl reflect.makeFuncStub\n-\n-#ifdef __ELF__\n-\t.type reflect.makeFuncStub,@function\n-#endif\n-\n-reflect.makeFuncStub:\n-.LFB1:\n-\n-\t/* Go does not provide any equivalent to the regparm function\n-\t   attribute, so on Go we do not need to worry about passing\n-\t   parameters in registers.  We just pass a pointer to the\n-\t   arguments on the stack.\n-\t\n-\t   We do need to pick up the return values, though, so we pass\n-\t   a pointer to a struct that looks like this.\n-\t   struct {\n-\t     esp uint32\t\t// 0x0\n-\t     eax uint32\t\t// 0x4\n-\t     st0 float64\t// 0x8\n-\t     sr  bool\t\t// 0x10\n-\t     sf  bool\t\t// 0x11\n-\t   }\n-\t   The sr field is set by the function to a non-zero value if\n-\t   the function takes a struct hidden pointer that must be\n-\t   popped off the stack.  */\n-\n-\tpushl\t%ebp\n-.LCFI0:\n-\tmovl\t%esp, %ebp\n-.LCFI1:\n-\tpushl\t%ebx\t\t/* In case this is PIC.  */\n-\tsubl\t$36, %esp\t/* Enough for args and to align stack.  */\n-.LCFI2:\n-\n-#ifdef __PIC__\n-\tcall\t__x86.get_pc_thunk.bx\n-\taddl\t$_GLOBAL_OFFSET_TABLE_, %ebx\n-#endif\n-\n-\tleal\t8(%ebp), %eax\t/* Set esp field in struct.  */\n-\tmovl\t%eax, -24(%ebp)\n-\n-\t/* For MakeFunc functions that call recover.  */\n-\tmovl\t4(%ebp), %eax\n-\tmovl\t%eax, (%esp)\n-#ifdef __PIC__\n-\tcall\t__go_makefunc_can_recover@PLT\n-#else\n-\tcall\t__go_makefunc_can_recover\n-#endif\n-\n-#ifdef __PIC__\n-\tcall\t__go_get_closure@PLT\n-#else\n-\tcall\t__go_get_closure\n-#endif\n-\n-\tmovl\t%eax, 4(%esp)\n-\n-\tleal\t-24(%ebp), %eax\n-\tmovl\t%eax, (%esp)\n-\n-#ifdef __PIC__\n-\tcall\treflect.MakeFuncStubGo@PLT\n-#else\n-\tcall\treflect.MakeFuncStubGo\n-#endif\n-\n-\t/* MakeFunc functions can no longer call recover.  */\n-#ifdef __PIC__\n-\tcall __go_makefunc_returning@PLT\n-#else\n-\tcall __go_makefunc_returning\n-#endif\n-\n-\t/* Set return registers.  */\n-\n-\tmovl\t-20(%ebp), %eax\n-\n-\tcmpb\t$0, -7(%ebp)\n-\tje\t2f\n-\n-\tfldl\t-16(%ebp)\n-\n-#ifdef __SSE2__\n-\t/* In case we are compiling with -msseregparm.  This won't work\n-\t   correctly if only SSE1 is supported, but that seems unlikely.  */\n-\tmovsd\t-16(%ebp), %xmm0\n-#endif\n-\n-2:\n-\tmovb\t-8(%ebp), %dl\n-\n-\taddl\t$36, %esp\n-\tpopl\t%ebx\n-.LCFI3:\n-\tpopl\t%ebp\n-.LCFI4:\n-\n-\ttestb\t%dl,%dl\n-\tjne\t1f\n-\tret\n-1:\n-\tret\t$4\n-.LFE1:\n-#ifdef __ELF__\n-\t.size\treflect.makeFuncStub, . - reflect.makeFuncStub\n-#endif\n-\n-#ifdef __PIC__\n-#ifdef HAVE_AS_COMDAT_GAS\n-\t.section\t.text.__x86.get_pc_thunk.bx,\"axG\",@progbits,__x86.get_pc_thunk.bx,comdat\n-#else\n-\t/* Sun as needs a different syntax.  */\n-\t.section\t.text.__x86.get_pc_thunk.bx%__x86.get_pc_thunk.bx,\"ax\",@progbits\n-\t.group\t\t__x86.get_pc_thunk.bx,.text.__x86.get_pc_thunk.bx%__x86.get_pc_thunk.bx,#comdat\n-#endif\n-\t.globl\t__x86.get_pc_thunk.bx\n-\t.hidden\t__x86.get_pc_thunk.bx\n-#ifdef __ELF__\n-\t.type\t__x86.get_pc_thunk.bx, @function\n-#endif\n-__x86.get_pc_thunk.bx:\n-.LFB2:\n-\tmovl\t(%esp), %ebx\n-\tret\n-.LFE2:\n-#ifdef __ELF__\n-\t.size\t__x86.get_pc_thunk.bx, . - __x86.get_pc_thunk.bx\n-#endif\n-#endif\n-\n-#ifdef __ELF__\n-#if defined __PIC__\n-# if defined __sun__ && defined __svr4__\n-/* 32-bit Solaris 2/x86 uses datarel encoding for PIC.  GNU ld before 2.22\n-   doesn't correctly sort .eh_frame_hdr with mixed encodings, so match this.  */\n-#  define FDE_ENCODING\t\t0x30\t/* datarel */\n-#  define FDE_ENCODE(X)\t\tX@GOTOFF\n-# else\n-#  define FDE_ENCODING\t\t0x1b\t/* pcrel sdata4 */\n-#  if defined HAVE_AS_X86_PCREL\n-#   define FDE_ENCODE(X)\tX-.\n-#  else\n-#   define FDE_ENCODE(X)\tX@rel\n-#  endif\n-# endif\n-#else\n-# define FDE_ENCODING\t\t0\t/* absolute */\n-# define FDE_ENCODE(X)\t\tX\n-#endif\n-\n-\t.section\t.eh_frame,EH_FRAME_FLAGS,@progbits\n-.Lframe1:\n-\t.long\t.LECIE1-.LSCIE1\t/* Length of Common Information Entry */\n-.LSCIE1:\n-\t.long\t0x0\t/* CIE Identifier Tag */\n-\t.byte\t0x1\t/* CIE Version */\n-\t.ascii \"zR\\0\"\t/* CIE Augmentation */\n-\t.byte\t0x1\t/* .uleb128 0x1; CIE Code Alignment Factor */\n-\t.byte\t0x7c\t/* .sleb128 -4; CIE Data Alignment Factor */\n-\t.byte\t0x8\t/* CIE RA Column */\n-\t.byte\t0x1\t/* .uleb128 0x1; Augmentation size */\n-\t.byte\tFDE_ENCODING\n-\t.byte\t0xc\t/* DW_CFA_def_cfa */\n-\t.byte\t0x4\t/* .uleb128 0x4 */\n-\t.byte\t0x4\t/* .uleb128 0x4 */\n-\t.byte\t0x88\t/* DW_CFA_offset, column 0x8 */\n-\t.byte\t0x1\t/* .uleb128 0x1 */\n-\t.align 4\n-.LECIE1:\n-.LSFDE1:\n-\t.long\t.LEFDE1-.LASFDE1\t/* FDE Length */\n-.LASFDE1:\n-\t.long\t.LASFDE1-.Lframe1\t/* FDE CIE offset */\n-\t.long\tFDE_ENCODE(.LFB1)\t/* FDE initial location */\n-\t.long\t.LFE1-.LFB1\t\t/* FDE address range */\n-\t.byte\t0x0\t/* .uleb128 0x0; Augmentation size */\n-\t.byte\t0x4\t/* DW_CFA_advance_loc4 */\n-\t.long\t.LCFI0-.LFB1\n-\t.byte\t0xe\t/* DW_CFA_def_cfa_offset */\n-\t.byte\t0x8\t/* .uleb128 0x8 */\n-\t.byte\t0x85\t/* DW_CFA_offset, column 0x5 */\n-\t.byte\t0x2\t/* .uleb128 0x2 */\n-\t.byte\t0x4\t/* DW_CFA_advance_loc4 */\n-\t.long\t.LCFI1-.LCFI0\n-\t.byte\t0xd\t/* DW_CFA_def_cfa_register */\n-\t.byte\t0x5\t/* .uleb128 0x5 */\n-\t.byte\t0x4\t/* DW_CFA_advance_loc4 */\n-\t.long\t.LCFI2-.LCFI1\n-\t.byte\t0x83\t/* .DW_CFA_offset, column 0x3 */\n-\t.byte\t0x3\t/* .uleb128 0x3 */\n-\t.byte\t0x4\t/* DW_CFA_advance_loc4 */\n-\t.long\t.LCFI3-.LCFI2\n-\t.byte\t0xc3\t/* DW_CFA_restore, column 0x3 */\n-\t.byte\t0x4\t/* DW_CFA_advance_loc4 */\n-\t.long\t.LCFI4-.LCFI3\n-\t.byte\t0xc5\t/* DW_CFA_restore, column 0x5 */\n-\t.byte\t0xc\t/* DW_CFA_def_cfa */\n-\t.byte\t0x4\t/* .uleb128 0x4 */\n-\t.byte\t0x4\t/* .uleb128 0x4 */\n-\t.align 4\n-.LEFDE1:\n-#ifdef __PIC__\n-.LSFDE2:\n-\t.long\t.LEFDE2-.LASFDE2\t/* FDE Length */\n-.LASFDE2:\n-\t.long\t.LASFDE2-.Lframe1\t/* FDE CIE offset */\n-\t.long\tFDE_ENCODE(.LFB2)\t/* FDE initial location */\n-\t.long\t.LFE2-.LFB2\t\t/* FDE address range */\n-\t.byte\t0x0\t/* .uleb128 0x0; Augmentation size */\n-\t.align 4\n-.LEFDE2:\n-#endif /* __PIC__ */\n-#endif /* __ELF__ */\n-\n-#if defined(__ELF__) && defined(__linux__)\n-\t.section\t.note.GNU-stack,\"\",@progbits\n-\t.section\t.note.GNU-split-stack,\"\",@progbits\n-\t.section\t.note.GNU-no-split-stack,\"\",@progbits\n-#endif"}, {"sha": "88302eee1b22641c018577fbc6febc9a282decd3", "filename": "libgo/go/reflect/makefunc_amd64.S", "status": "removed", "additions": 0, "deletions": 177, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21cb351825d45c42e9e5148715a2fd2051cf4ed1/libgo%2Fgo%2Freflect%2Fmakefunc_amd64.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21cb351825d45c42e9e5148715a2fd2051cf4ed1/libgo%2Fgo%2Freflect%2Fmakefunc_amd64.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fmakefunc_amd64.S?ref=21cb351825d45c42e9e5148715a2fd2051cf4ed1", "patch": "@@ -1,177 +0,0 @@\n-# Copyright 2013 The Go Authors. All rights reserved.\n-# Use of this source code is governed by a BSD-style\n-# license that can be found in the LICENSE file.\n-\n-# MakeFunc amd64 assembly code.\n-\n-#include \"config.h\"\n-\n-\t.global\treflect.makeFuncStub\n-\n-#ifdef __ELF__\n-\t.type\treflect.makeFuncStub,@function\n-#endif\n-\n-reflect.makeFuncStub:\n-.LFB1:\n-\n-\t# Store all the parameter registers in a struct that looks\n-\t# like:\n-\t# struct {\n-\t#   rax uint64\t\t// 0x0\n-\t#   rdi uint64\t\t// 0x8\n-\t#   rsi uint64\t\t// 0x10\n-\t#   rdx uint64\t\t// 0x18\n-\t#   rcx uint64\t\t// 0x20\n-\t#   r8 uint64\t\t// 0x28\n-\t#   r9 uint64\t\t// 0x30\n-\t#   rsp uint64\t\t// 0x38 Pointer to arguments on stack.\n-\t#   xmm0 [2]uint64\t// 0x40\n-\t#   xmm1 [2]uint64\t// 0x50\n-\t#   xmm2 [2]uint64\t// 0x60\n-\t#   xmm3 [2]uint64\t// 0x70\n-\t#   xmm4 [2]uint64\t// 0x80\n-\t#   xmm5 [2]uint64\t// 0x90\n-\t#   xmm6 [2]uint64\t// 0xa0\n-\t#   xmm7 [2]uint64\t// 0xb0\n-\t# };\n-\n-\tpushq\t%rbp\n-.LCFI0:\n-\tmovq\t%rsp, %rbp\n-.LCFI1:\n-\n-\tsubq\t$0xc0, %rsp\t\t# Space for struct on stack.\n-\n-\tmovq\t%rax, 0x0(%rsp)\n-\tmovq\t%rdi, 0x8(%rsp)\n-\tmovq\t%rsi, 0x10(%rsp)\n-\tmovq\t%rdx, 0x18(%rsp)\n-\tmovq\t%rcx, 0x20(%rsp)\n-\tmovq\t%r8, 0x28(%rsp)\n-\tmovq\t%r9, 0x30(%rsp)\n-\tleaq\t16(%rbp), %rax\n-\tmovq\t%rax, 0x38(%rsp)\n-\tmovdqa\t%xmm0, 0x40(%rsp)\n-\tmovdqa\t%xmm1, 0x50(%rsp)\n-\tmovdqa\t%xmm2, 0x60(%rsp)\n-\tmovdqa\t%xmm3, 0x70(%rsp)\n-\tmovdqa\t%xmm4, 0x80(%rsp)\n-\tmovdqa\t%xmm5, 0x90(%rsp)\n-\tmovdqa\t%xmm6, 0xa0(%rsp)\n-\tmovdqa\t%xmm7, 0xb0(%rsp)\n-\n-\t/* For MakeFunc functions that call recover.  */\n-\tmovq\t8(%rbp), %rdi\n-#ifdef __PIC__\n-\tcall\t__go_makefunc_can_recover@PLT\n-#else\n-\tcall\t__go_makefunc_can_recover\n-#endif\n-\n-\t# Get function type.\n-#ifdef __PIC__\n-\tcall\t__go_get_closure@PLT\n-#else\n-\tcall\t__go_get_closure\n-#endif\n-\tmovq\t%rax, %rsi\n-\n-\tmovq\t%rsp, %rdi\n-\n-#ifdef __PIC__\n-\tcall\treflect.MakeFuncStubGo@PLT\n-#else\n-\tcall\treflect.MakeFuncStubGo\n-#endif\n-\n-\t/* MakeFunc functions can no longer call recover.  */\n-#ifdef __PIC__\n-\tcall __go_makefunc_returning@PLT\n-#else\n-\tcall __go_makefunc_returning\n-#endif\n-\n-\t# The structure will be updated with any return values.  Load\n-\t# all possible return registers before returning to the caller.\n-\n-\tmovq\t0x0(%rsp), %rax\n-\tmovq\t0x18(%rsp), %rdx\n-\tmovq\t0x8(%rsp), %rdi\n-\tmovq\t0x10(%rsp), %rsi\n-\tmovdqa\t0x40(%rsp), %xmm0\n-\tmovdqa\t0x50(%rsp), %xmm1\n-\n-\t# long double values are returned on the floating point stack,\n-\t# but we don't worry about that since Go doesn't have a long\n-\t# double type.\n-\n-\tleave\n-.LCFI2:\n-\n-\tret\n-.LFE1:\n-\n-#ifdef __ELF__\n-\t.size\treflect.makeFuncStub, . - reflect.makeFuncStub\n-#endif\n-\n-#ifdef __ELF__\n-#ifdef HAVE_AS_X86_64_UNWIND_SECTION_TYPE\n-\t.section\t.eh_frame,\"a\",@unwind\n-#else\n-\t.section\t.eh_frame,\"a\",@progbits\n-#endif\n-.Lframe1:\n-\t.long\t.LECIE1-.LSCIE1\t/* Length of Common Information Entry */\n-.LSCIE1:\n-\t.long\t0x0\t\t/* CIE Identifier Tag */\n-\t.byte\t0x1\t\t/* CIE Version */\n-\t.ascii \"zR\\0\"\t\t/* CIE Augmentation */\n-\t.uleb128 1\t\t/* CIE Code Alignment Factor */\n-\t.sleb128 -8\t\t/* CIE Data Alignment Factor */\n-\t.byte\t0x10\t\t/* CIE RA Column */\n-\t.uleb128 1\t\t/* Augmentation size */\n-\t.byte\t0x1b\t\t/* FDE Encoding (pcrel sdata4) */\n-\t.byte\t0xc\t\t/* DW_CFA_def_cfa, %rsp offset 8 */\n-\t.uleb128 7\n-\t.uleb128 8\n-\t.byte\t0x80+16\t\t/* DW_CFA_offset, %rip offset 1*-8 */\n-\t.uleb128 1\n-\t.align 8\n-.LECIE1:\n-.LSFDE1:\n-\t.long\t.LEFDE1-.LASFDE1\t/* FDE Length */\n-.LASFDE1:\n-\t.long\t.LASFDE1-.Lframe1\t/* FDE CIE offset */\n-#if HAVE_AS_X86_PCREL\n-\t.long\t.LFB1-.\t\t\t/* FDE initial location */\n-#else\n-\t.long\t.LFB1@rel\n-#endif\n-\t.long\t.LFE1-.LFB1\t\t/* FDE address range */\n-\t.uleb128 0x0\t\t\t/* Augmentation size */\n-\t.byte\t0x4\t\t\t/* DW_CFA_advance_loc4 */\n-\t.long\t.LCFI0-.LFB1\n-\t.byte\t0xe\t\t\t/* DW_CFA_def_cfa_offset */\n-\t.uleb128 16\n-\t.byte\t0x86\t\t\t/* DW_CFA_offset, column 0x6 */\n-\t.uleb128 2\n-\t.byte\t0x4\t\t\t/* DW_CFA_advance_loc4 */\n-\t.long\t.LCFI1-.LCFI0\n-\t.byte\t0xd\t\t\t/* DW_CFA_def_cfa_register */\n-\t.uleb128 6\n-\t.byte\t0x2\t\t\t/* DW_CFA_advance_loc1 */\n-\t.byte\t.LCFI2-.LCFI1\n-\t.byte\t0xc\t\t\t/* DW_CFA_def_cfa */\n-\t.uleb128 7\n-\t.uleb128 8\n-\t.align 8\n-.LEFDE1:\n-#endif /* __ELF__ */\n-\n-#if defined(__ELF__) && defined(__linux__)\n-\t.section\t.note.GNU-stack,\"\",@progbits\n-\t.section\t.note.GNU-split-stack,\"\",@progbits\n-\t.section\t.note.GNU-no-split-stack,\"\",@progbits\n-#endif"}, {"sha": "8eff0c1dfacd0dac7dd1c607abf1f3be7da1adbe", "filename": "libgo/go/reflect/makefunc_dummy.c", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21cb351825d45c42e9e5148715a2fd2051cf4ed1/libgo%2Fgo%2Freflect%2Fmakefunc_dummy.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21cb351825d45c42e9e5148715a2fd2051cf4ed1/libgo%2Fgo%2Freflect%2Fmakefunc_dummy.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fmakefunc_dummy.c?ref=21cb351825d45c42e9e5148715a2fd2051cf4ed1", "patch": "@@ -1,15 +0,0 @@\n-// Copyright 2013 The Go Authors.  All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-#include \"runtime.h\"\n-\n-/* Dummy function for processors that implement MakeFunc using FFI\n-   rather than having builtin support.  */\n-\n-void makeFuncStub (void) __asm__ (\"reflect.makeFuncStub\");\n-\n-void makeFuncStub (void)\n-{\n-  runtime_throw (\"impossible call to makeFuncStub\");\n-}"}, {"sha": "6b61f23112732b88996f911ea29b9e73ba1a8771", "filename": "libgo/go/reflect/makefunc_ffi.go", "status": "modified", "additions": 21, "deletions": 46, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38bf819a5f995ae4621496df2324d68b9e24900f/libgo%2Fgo%2Freflect%2Fmakefunc_ffi.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38bf819a5f995ae4621496df2324d68b9e24900f/libgo%2Fgo%2Freflect%2Fmakefunc_ffi.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fmakefunc_ffi.go?ref=38bf819a5f995ae4621496df2324d68b9e24900f", "patch": "@@ -5,52 +5,27 @@\n package reflect\n \n import (\n-\t\"runtime\"\n \t\"unsafe\"\n )\n \n-// The ffi function, written in C, allocates an FFI closure.  It\n-// returns the code and data pointers.  When the code pointer is\n-// called, it will call callback.  CIF is an FFI data structure\n-// allocated as part of the closure, and is returned to ensure that\n-// the GC retains it.\n-func ffi(ftyp *funcType, callback func(unsafe.Pointer, unsafe.Pointer)) (code uintptr, data uintptr, cif unsafe.Pointer)\n-\n-// The ffiFree function, written in C, releases the FFI closure.\n-func ffiFree(uintptr)\n-\n-// An ffiData holds the information needed to preserve an FFI closure\n-// for the garbage collector.\n-type ffiData struct {\n-\tcode     uintptr\n-\tdata     uintptr\n-\tcif      unsafe.Pointer\n-\tcallback func(unsafe.Pointer, unsafe.Pointer)\n-}\n-\n-// The makeFuncFFI function uses libffi closures to implement\n-// reflect.MakeFunc.  This is used for processors for which we don't\n-// have more efficient support.\n-func makeFuncFFI(ftyp *funcType, fn func(args []Value) (results []Value)) (uintptr, *ffiData) {\n-\tcallback := func(params, results unsafe.Pointer) {\n-\t\tffiCall(ftyp, fn, params, results)\n-\t}\n-\n-\tcode, data, cif := ffi(ftyp, callback)\n-\n-\tc := &ffiData{code: code, data: data, cif: cif, callback: callback}\n-\n-\truntime.SetFinalizer(c,\n-\t\tfunc(p *ffiData) {\n-\t\t\tffiFree(p.data)\n-\t\t})\n-\n-\treturn code, c\n-}\n-\n-// ffiCall takes pointers to the parameters, calls the function, and\n-// stores the results back into memory.\n-func ffiCall(ftyp *funcType, fn func([]Value) []Value, params unsafe.Pointer, results unsafe.Pointer) {\n+// The makeFuncFFI function, written in C, fills in an FFI closure.\n+// It arranges for ffiCall to be invoked directly from FFI.\n+func makeFuncFFI(ftyp *funcType, impl *makeFuncImpl)\n+\n+// FFICallbackGo implements the Go side of the libffi callback.\n+// It is exported so that C code can call it.\n+//\n+// The call chain arriving here looks like\n+//   some_go_caller\n+//   ->some_ffi_internals\n+//     ->ffi_callback (in C)\n+//       ->FFICallbackGo\n+//\n+// The ffi_callback handles __go_makefunc_can_recover, and\n+// then passes off the data as received from ffi here.\n+\n+func FFICallbackGo(results unsafe.Pointer, params unsafe.Pointer, impl *makeFuncImpl) {\n+\tftyp := impl.typ\n \tin := make([]Value, 0, len(ftyp.in))\n \tap := params\n \tfor _, rt := range ftyp.in {\n@@ -61,18 +36,18 @@ func ffiCall(ftyp *funcType, fn func([]Value) []Value, params unsafe.Pointer, re\n \t\tap = (unsafe.Pointer)(uintptr(ap) + ptrSize)\n \t}\n \n-\tout := fn(in)\n+\tout := impl.call(in)\n \n \toff := uintptr(0)\n \tfor i, typ := range ftyp.out {\n \t\tv := out[i]\n \t\tif v.typ != typ {\n-\t\t\tpanic(\"reflect: function created by MakeFunc using \" + funcName(fn) +\n+\t\t\tpanic(\"reflect: function created by MakeFunc using \" + funcName(impl.fn) +\n \t\t\t\t\" returned wrong type: have \" +\n \t\t\t\tout[i].typ.String() + \" for \" + typ.String())\n \t\t}\n \t\tif v.flag&flagRO != 0 {\n-\t\t\tpanic(\"reflect: function created by MakeFunc using \" + funcName(fn) +\n+\t\t\tpanic(\"reflect: function created by MakeFunc using \" + funcName(impl.fn) +\n \t\t\t\t\" returned value obtained from unexported field\")\n \t\t}\n "}, {"sha": "727ae8180ad1ea72a8dd632d576a7fe82f9c738a", "filename": "libgo/go/reflect/makefunc_ffi_c.c", "status": "modified", "additions": 16, "deletions": 52, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38bf819a5f995ae4621496df2324d68b9e24900f/libgo%2Fgo%2Freflect%2Fmakefunc_ffi_c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38bf819a5f995ae4621496df2324d68b9e24900f/libgo%2Fgo%2Freflect%2Fmakefunc_ffi_c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fmakefunc_ffi_c.c?ref=38bf819a5f995ae4621496df2324d68b9e24900f", "patch": "@@ -10,44 +10,36 @@\n \n #include \"go-ffi.h\"\n \n-#if FFI_CLOSURES\n+#if FFI_GO_CLOSURES\n #define USE_LIBFFI_CLOSURES\n #endif\n \n #endif /* defined(USE_LIBFFI) */\n \n /* Declare C functions with the names used to call from Go.  */\n \n-struct ffi_ret {\n-  void *code;\n-  void *data;\n-  void *cif;\n-};\n-\n-struct ffi_ret ffi(const struct __go_func_type *ftyp, FuncVal *callback)\n-  __asm__ (GOSYM_PREFIX \"reflect.ffi\");\n-\n-void ffiFree(void *data)\n-  __asm__ (GOSYM_PREFIX \"reflect.ffiFree\");\n+void makeFuncFFI(const struct __go_func_type *ftyp, ffi_go_closure *impl)\n+  __asm__ (GOSYM_PREFIX \"reflect.makeFuncFFI\");\n \n #ifdef USE_LIBFFI_CLOSURES\n \n-/* The function that we pass to ffi_prep_closure_loc.  This calls the\n-   Go callback function (passed in user_data) with the pointer to the\n-   arguments and the results area.  */\n+/* The function that we pass to ffi_prep_closure_loc.  This calls the Go\n+   function ffiCall with the pointer to the arguments, the results area,\n+   and the closure structure.  */\n+\n+void FFICallbackGo(void *result, void **args, ffi_go_closure *closure)\n+  __asm__ (GOSYM_PREFIX \"reflect.FFICallbackGo\");\n \n static void ffi_callback (ffi_cif *, void *, void **, void *)\n   __asm__ (\"reflect.ffi_callback\");\n \n static void\n ffi_callback (ffi_cif* cif __attribute__ ((unused)), void *results,\n-\t      void **args, void *user_data)\n+\t      void **args, void *closure)\n {\n   Location locs[8];\n   int n;\n   int i;\n-  FuncVal *fv;\n-  void (*f) (void *, void *);\n \n   /* This function is called from some series of FFI closure functions\n      called by a Go function.  We want to see whether the caller of\n@@ -69,57 +61,29 @@ ffi_callback (ffi_cif* cif __attribute__ ((unused)), void *results,\n   if (i < n)\n     __go_makefunc_ffi_can_recover (locs + i, n - i);\n \n-  fv = (FuncVal *) user_data;\n-  __go_set_closure (fv);\n-  f = (void *) fv->fn;\n-  f (args, results);\n+  FFICallbackGo(results, args, closure);\n \n   if (i < n)\n     __go_makefunc_returning ();\n }\n \n /* Allocate an FFI closure and arrange to call ffi_callback.  */\n \n-struct ffi_ret\n-ffi (const struct __go_func_type *ftyp, FuncVal *callback)\n+void\n+makeFuncFFI(const struct __go_func_type *ftyp, ffi_go_closure *impl)\n {\n   ffi_cif *cif;\n-  void *code;\n-  void *data;\n-  struct ffi_ret ret;\n \n   cif = (ffi_cif *) __go_alloc (sizeof (ffi_cif));\n   __go_func_to_cif (ftyp, 0, 0, cif);\n-  data = ffi_closure_alloc (sizeof (ffi_closure), &code);\n-  if (data == NULL)\n-    runtime_panicstring (\"ffi_closure_alloc failed\");\n-  if (ffi_prep_closure_loc (data, cif, ffi_callback, callback, code)\n-      != FFI_OK)\n-    runtime_panicstring (\"ffi_prep_closure_loc failed\");\n-  ret.code = code;\n-  ret.data = data;\n-  ret.cif = cif;\n-  return ret;\n-}\n-\n-/* Free the FFI closure.  */\n \n-void\n-ffiFree (void *data)\n-{\n-  ffi_closure_free (data);\n+  ffi_prep_go_closure(impl, cif, ffi_callback);\n }\n \n #else /* !defined(USE_LIBFFI_CLOSURES) */\n \n-struct ffi_ret\n-ffi(const struct __go_func_type *ftyp, FuncVal *callback)\n-{\n-  runtime_panicstring (\"libgo built without FFI does not support \"\n-\t\t       \"reflect.MakeFunc\");\n-}\n-\n-void ffiFree(void *data)\n+void\n+makeFuncFFI(const struct __go_func_type *ftyp, ffi_go_closure *impl)\n {\n   runtime_panicstring (\"libgo built without FFI does not support \"\n \t\t       \"reflect.MakeFunc\");"}, {"sha": "78a960ca2f671d1f1c3c54db2abaf767101eb8be", "filename": "libgo/go/reflect/makefunc_s390.c", "status": "removed", "additions": 0, "deletions": 86, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21cb351825d45c42e9e5148715a2fd2051cf4ed1/libgo%2Fgo%2Freflect%2Fmakefunc_s390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21cb351825d45c42e9e5148715a2fd2051cf4ed1/libgo%2Fgo%2Freflect%2Fmakefunc_s390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fmakefunc_s390.c?ref=21cb351825d45c42e9e5148715a2fd2051cf4ed1", "patch": "@@ -1,86 +0,0 @@\n-// Copyright 2014 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-#include \"runtime.h\"\n-#include \"go-panic.h\"\n-\n-#ifdef __s390x__\n-#  define S390_GO_USE_64_BIT_ABI 1\n-#  define S390_GO_S390X_ARGS , double f4, double f6\n-#  define S390_GO_S390X_FIELDS double f4; double f6;\n-   extern void S390xMakeFuncStubGo(void *, void *)\n-\tasm (\"reflect.S390xMakeFuncStubGo\");\n-#  define S390_GO_MakeFuncStubGo(r, c) S390xMakeFuncStubGo((r), (c))\n-#else\n-#  define S390_GO_USE_64_BIT_ABI 0\n-#  define S390_GO_S390X_ARGS\n-#  define S390_GO_S390X_FIELDS\n-   extern void S390MakeFuncStubGo(void *, void *)\n-\tasm (\"reflect.S390MakeFuncStubGo\");\n-#  define S390_GO_MakeFuncStubGo(r, c) S390MakeFuncStubGo((r), (c))\n-   /* Needed to make the unused 64 bit abi conditional code compile.  */\n-#  define f4 f0\n-#  define f6 f2\n-#endif\n-\n-/* Structure to store all registers used for parameter passing.  */\n-typedef struct\n-{\n-\tlong r2;\n-\tlong r3;\n-\tlong r4;\n-\tlong r5;\n-\tlong r6;\n-\t/* Pointer to non-register arguments on the stack.  */\n-\tlong stack_args;\n-\tdouble f0;\n-\tdouble f2;\n-\tS390_GO_S390X_FIELDS\n-} s390Regs;\n-\n-void\n-makeFuncStub(long r2, long r3, long r4, long r5, long r6,\n-\tunsigned long stack_args, double f0, double f2\n-\tS390_GO_S390X_ARGS)\n-\tasm (\"reflect.makeFuncStub\");\n-\n-void\n-makeFuncStub(long r2, long r3, long r4, long r5, long r6,\n-\tunsigned long stack_args, double f0, double f2\n-\tS390_GO_S390X_ARGS)\n-{\n-\ts390Regs regs;\n-\tvoid *closure;\n-\n-\t/* Store the registers in a structure that is passed on to the Go stub\n-\t   function.  */\n-\tregs.r2 = r2;\n-\tregs.r3 = r3;\n-\tregs.r4 = r4;\n-\tregs.r5 = r5;\n-\tregs.r6 = r6;\n-\tregs.stack_args = (long)&stack_args;\n-\tregs.f0 = f0;\n-\tregs.f2 = f2;\n-\tif (S390_GO_USE_64_BIT_ABI) {\n-\t\tregs.f4 = f4;\n-\t\tregs.f6 = f6;\n-\t}\n-\t/* For MakeFunc functions that call recover.  */\n-\t__go_makefunc_can_recover(__builtin_return_address(0));\n-\t/* Call the Go stub function.  */\n-\tclosure = __go_get_closure();\n-\tS390_GO_MakeFuncStubGo(&regs, closure);\n-\t/* MakeFunc functions can no longer call recover.  */\n-\t__go_makefunc_returning();\n-\t/* Restore all possible return registers.  */\n-\tif (S390_GO_USE_64_BIT_ABI) {\n-\t\tasm volatile (\"lg\\t%%r2,0(%0)\" : : \"a\" (&regs.r2) : \"r2\" );\n-\t\tasm volatile (\"ld\\t%%f0,0(%0)\" : : \"a\" (&regs.f0) : \"f0\" );\n-\t} else {\n-\t\tasm volatile (\"l\\t%%r2,0(%0)\" : : \"a\" (&regs.r2) : \"r2\" );\n-\t\tasm volatile (\"l\\t%%r3,0(%0)\" : : \"a\" (&regs.r3) : \"r3\" );\n-\t\tasm volatile (\"ld\\t%%f0,0(%0)\" : : \"a\" (&regs.f0) : \"f0\" );\n-\t}\n-}"}, {"sha": "c20f0ac3b3ebb933ca9e98bb21e0ab8a3a2ee2fb", "filename": "libgo/go/reflect/makefuncgo_386.go", "status": "removed", "additions": 0, "deletions": 139, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21cb351825d45c42e9e5148715a2fd2051cf4ed1/libgo%2Fgo%2Freflect%2Fmakefuncgo_386.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21cb351825d45c42e9e5148715a2fd2051cf4ed1/libgo%2Fgo%2Freflect%2Fmakefuncgo_386.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fmakefuncgo_386.go?ref=21cb351825d45c42e9e5148715a2fd2051cf4ed1", "patch": "@@ -1,139 +0,0 @@\n-// Copyright 2013 The Go Authors.  All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// MakeFunc 386 implementation.\n-\n-package reflect\n-\n-import \"unsafe\"\n-\n-// The assembler stub will pass a pointer to this structure.  We\n-// assume that no parameters are passed in registers--that is, we do\n-// not support the -mregparm option.  On return we will set the\n-// registers that might hold result values.\n-type i386Regs struct {\n-\tesp uint32\n-\teax uint32  // Value to return in %eax.\n-\tst0 float64 // Value to return in %st(0).\n-\tsr  bool    // Set to true if hidden struct pointer.\n-\tsf  bool    // Set to true if returning float\n-}\n-\n-// MakeFuncStubGo implements the 386 calling convention for MakeFunc.\n-// This should not be called.  It is exported so that assembly code\n-// can call it.\n-\n-func MakeFuncStubGo(regs *i386Regs, c *makeFuncImpl) {\n-\tftyp := c.typ\n-\n-\t// See if the result requires a struct.  If it does, the first\n-\t// parameter is a pointer to the struct.\n-\tretStruct := false\n-\tretEmpty := false\n-\tswitch len(ftyp.out) {\n-\tcase 0:\n-\t\tretEmpty = true\n-\tcase 1:\n-\t\tif ftyp.out[0].size == 0 {\n-\t\t\tretEmpty = true\n-\t\t} else {\n-\t\t\tswitch ftyp.out[0].Kind() {\n-\t\t\tcase Complex64, Complex128, Array, Interface, Slice, String, Struct:\n-\t\t\t\tretStruct = true\n-\t\t\t}\n-\t\t}\n-\tdefault:\n-\t\tsize := uintptr(0)\n-\t\tfor _, typ := range ftyp.out {\n-\t\t\tsize += typ.size\n-\t\t}\n-\t\tif size == 0 {\n-\t\t\tretEmpty = true\n-\t\t} else {\n-\t\t\tretStruct = true\n-\t\t}\n-\t}\n-\n-\tin := make([]Value, 0, len(ftyp.in))\n-\tap := uintptr(regs.esp)\n-\n-\tregs.sr = false\n-\tregs.sf = false\n-\tvar retPtr unsafe.Pointer\n-\tif retStruct {\n-\t\tretPtr = *(*unsafe.Pointer)(unsafe.Pointer(ap))\n-\t\tap += ptrSize\n-\t\tregs.sr = true\n-\t}\n-\n-\tfor _, rt := range ftyp.in {\n-\t\tap = align(ap, ptrSize)\n-\n-\t\t// We have to copy the argument onto the heap in case\n-\t\t// the function hangs on the reflect.Value we pass it.\n-\t\tp := unsafe_New(rt)\n-\t\tmemmove(p, unsafe.Pointer(ap), rt.size)\n-\n-\t\tv := Value{rt, p, flag(rt.Kind()) | flagIndir}\n-\t\tin = append(in, v)\n-\t\tap += rt.size\n-\t}\n-\n-\t// Call the real function.\n-\n-\tout := c.call(in)\n-\n-\tif len(out) != len(ftyp.out) {\n-\t\tpanic(\"reflect: wrong return count from function created by MakeFunc\")\n-\t}\n-\n-\tfor i, typ := range ftyp.out {\n-\t\tv := out[i]\n-\t\tif v.typ != typ {\n-\t\t\tpanic(\"reflect: function created by MakeFunc using \" + funcName(c.fn) +\n-\t\t\t\t\" returned wrong type: have \" +\n-\t\t\t\tout[i].typ.String() + \" for \" + typ.String())\n-\t\t}\n-\t\tif v.flag&flagRO != 0 {\n-\t\t\tpanic(\"reflect: function created by MakeFunc using \" + funcName(c.fn) +\n-\t\t\t\t\" returned value obtained from unexported field\")\n-\t\t}\n-\t}\n-\n-\tif retEmpty {\n-\t\treturn\n-\t}\n-\n-\tif retStruct {\n-\t\toff := uintptr(0)\n-\t\tfor i, typ := range ftyp.out {\n-\t\t\tv := out[i]\n-\t\t\toff = align(off, uintptr(typ.fieldAlign))\n-\t\t\taddr := unsafe.Pointer(uintptr(retPtr) + off)\n-\t\t\tif v.flag&flagIndir == 0 && (v.kind() == Ptr || v.kind() == UnsafePointer) {\n-\t\t\t\t*(*unsafe.Pointer)(addr) = v.ptr\n-\t\t\t} else {\n-\t\t\t\tmemmove(addr, v.ptr, typ.size)\n-\t\t\t}\n-\t\t\toff += typ.size\n-\t\t}\n-\t\tregs.eax = uint32(uintptr(retPtr))\n-\t\treturn\n-\t}\n-\n-\tif len(ftyp.out) != 1 {\n-\t\tpanic(\"inconsistency\")\n-\t}\n-\n-\tv := out[0]\n-\tswitch v.Kind() {\n-\tcase Ptr, UnsafePointer, Chan, Func, Map:\n-\t\tregs.eax = uint32(uintptr(v.pointer()))\n-\tcase Float32, Float64:\n-\t\tregs.st0 = v.Float()\n-\t\tregs.sf = true\n-\tdefault:\n-\t\tmemmove(unsafe.Pointer(&regs.eax), v.ptr, v.typ.size)\n-\t}\n-}"}, {"sha": "a236aa26795b33e7a2d3255c3224687516a96530", "filename": "libgo/go/reflect/makefuncgo_amd64.go", "status": "removed", "additions": 0, "deletions": 496, "changes": 496, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21cb351825d45c42e9e5148715a2fd2051cf4ed1/libgo%2Fgo%2Freflect%2Fmakefuncgo_amd64.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21cb351825d45c42e9e5148715a2fd2051cf4ed1/libgo%2Fgo%2Freflect%2Fmakefuncgo_amd64.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fmakefuncgo_amd64.go?ref=21cb351825d45c42e9e5148715a2fd2051cf4ed1", "patch": "@@ -1,496 +0,0 @@\n-// Copyright 2013 The Go Authors.  All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// MakeFunc amd64 implementation.\n-\n-package reflect\n-\n-import \"unsafe\"\n-\n-// The assembler stub will pass a pointer to this structure.\n-// This will come in holding all the registers that might hold\n-// function parameters.  On return we will set the registers that\n-// might hold result values.\n-type amd64Regs struct {\n-\trax  uint64\n-\trdi  uint64\n-\trsi  uint64\n-\trdx  uint64\n-\trcx  uint64\n-\tr8   uint64\n-\tr9   uint64\n-\trsp  uint64\n-\txmm0 [2]uint64\n-\txmm1 [2]uint64\n-\txmm2 [2]uint64\n-\txmm3 [2]uint64\n-\txmm4 [2]uint64\n-\txmm5 [2]uint64\n-\txmm6 [2]uint64\n-\txmm7 [2]uint64\n-}\n-\n-// Argument classifications.  The amd64 ELF ABI uses several more, but\n-// these are the only ones that arise for Go types.\n-type amd64Class int\n-\n-const (\n-\tamd64Integer amd64Class = iota\n-\tamd64SSE\n-\tamd64NoClass\n-\tamd64Memory\n-)\n-\n-// amd64Classify returns the one or two register classes needed to\n-// pass the value of type.  Go types never need more than two\n-// registers.  amd64Memory means the value is stored in memory.\n-// amd64NoClass means the register is not used.\n-func amd64Classify(typ *rtype) (amd64Class, amd64Class) {\n-\tswitch typ.Kind() {\n-\tdefault:\n-\t\tpanic(\"internal error--unknown kind in amd64Classify\")\n-\n-\tcase Bool, Int, Int8, Int16, Int32, Int64,\n-\t\tUint, Uint8, Uint16, Uint32, Uint64,\n-\t\tUintptr, Chan, Func, Map, Ptr, UnsafePointer:\n-\n-\t\treturn amd64Integer, amd64NoClass\n-\n-\tcase Float32, Float64, Complex64:\n-\t\treturn amd64SSE, amd64NoClass\n-\n-\tcase Complex128:\n-\t\treturn amd64SSE, amd64SSE\n-\n-\tcase Array:\n-\t\tif typ.size == 0 {\n-\t\t\treturn amd64NoClass, amd64NoClass\n-\t\t} else if typ.size > 16 {\n-\t\t\treturn amd64Memory, amd64NoClass\n-\t\t}\n-\t\tatyp := (*arrayType)(unsafe.Pointer(typ))\n-\t\teclass1, eclass2 := amd64Classify(atyp.elem)\n-\t\tif eclass1 == amd64Memory {\n-\t\t\treturn amd64Memory, amd64NoClass\n-\t\t}\n-\t\tif eclass2 == amd64NoClass && typ.size > 8 {\n-\t\t\teclass2 = eclass1\n-\t\t}\n-\t\treturn eclass1, eclass2\n-\n-\tcase Interface:\n-\t\treturn amd64Integer, amd64Integer\n-\n-\tcase Slice:\n-\t\treturn amd64Memory, amd64NoClass\n-\n-\tcase String:\n-\t\treturn amd64Integer, amd64Integer\n-\n-\tcase Struct:\n-\t\tif typ.size == 0 {\n-\t\t\treturn amd64NoClass, amd64NoClass\n-\t\t} else if typ.size > 16 {\n-\t\t\treturn amd64Memory, amd64NoClass\n-\t\t}\n-\t\tvar first, second amd64Class\n-\t\tf := amd64NoClass\n-\t\tonFirst := true\n-\t\tstyp := (*structType)(unsafe.Pointer(typ))\n-\t\tfor _, field := range styp.fields {\n-\t\t\tif onFirst && field.offset >= 8 {\n-\t\t\t\tfirst = f\n-\t\t\t\tf = amd64NoClass\n-\t\t\t\tonFirst = false\n-\t\t\t}\n-\t\t\tfclass1, fclass2 := amd64Classify(field.typ)\n-\t\t\tf = amd64MergeClasses(f, fclass1)\n-\t\t\tif fclass2 != amd64NoClass {\n-\t\t\t\tif !onFirst {\n-\t\t\t\t\tpanic(\"amd64Classify inconsistent\")\n-\t\t\t\t}\n-\t\t\t\tfirst = f\n-\t\t\t\tf = fclass2\n-\t\t\t\tonFirst = false\n-\t\t\t}\n-\t\t}\n-\t\tif onFirst {\n-\t\t\tfirst = f\n-\t\t\tsecond = amd64NoClass\n-\t\t} else {\n-\t\t\tsecond = f\n-\t\t}\n-\t\tif first == amd64Memory || second == amd64Memory {\n-\t\t\treturn amd64Memory, amd64NoClass\n-\t\t}\n-\t\treturn first, second\n-\t}\n-}\n-\n-// amd64MergeClasses merges two register classes as described in the\n-// amd64 ELF ABI.\n-func amd64MergeClasses(c1, c2 amd64Class) amd64Class {\n-\tswitch {\n-\tcase c1 == c2:\n-\t\treturn c1\n-\tcase c1 == amd64NoClass:\n-\t\treturn c2\n-\tcase c2 == amd64NoClass:\n-\t\treturn c1\n-\tcase c1 == amd64Memory || c2 == amd64Memory:\n-\t\treturn amd64Memory\n-\tcase c1 == amd64Integer || c2 == amd64Integer:\n-\t\treturn amd64Integer\n-\tdefault:\n-\t\treturn amd64SSE\n-\t}\n-}\n-\n-// MakeFuncStubGo implements the amd64 calling convention for\n-// MakeFunc.  This should not be called.  It is exported so that\n-// assembly code can call it.\n-\n-func MakeFuncStubGo(regs *amd64Regs, c *makeFuncImpl) {\n-\tftyp := c.typ\n-\n-\t// See if the result requires a struct.  If it does, the first\n-\t// parameter is a pointer to the struct.\n-\tvar ret1, ret2 amd64Class\n-\tswitch len(ftyp.out) {\n-\tcase 0:\n-\t\tret1, ret2 = amd64NoClass, amd64NoClass\n-\tcase 1:\n-\t\tret1, ret2 = amd64Classify(ftyp.out[0])\n-\tdefault:\n-\t\toff := uintptr(0)\n-\t\tf := amd64NoClass\n-\t\tonFirst := true\n-\t\tfor _, rt := range ftyp.out {\n-\t\t\toff = align(off, uintptr(rt.fieldAlign))\n-\n-\t\t\tif onFirst && off >= 8 {\n-\t\t\t\tret1 = f\n-\t\t\t\tf = amd64NoClass\n-\t\t\t\tonFirst = false\n-\t\t\t}\n-\n-\t\t\toff += rt.size\n-\t\t\tif off > 16 {\n-\t\t\t\tbreak\n-\t\t\t}\n-\n-\t\t\tfclass1, fclass2 := amd64Classify(rt)\n-\t\t\tf = amd64MergeClasses(f, fclass1)\n-\t\t\tif fclass2 != amd64NoClass {\n-\t\t\t\tif !onFirst {\n-\t\t\t\t\tpanic(\"amd64Classify inconsistent\")\n-\t\t\t\t}\n-\t\t\t\tret1 = f\n-\t\t\t\tf = fclass2\n-\t\t\t\tonFirst = false\n-\t\t\t}\n-\t\t}\n-\t\tif off > 16 {\n-\t\t\tret1, ret2 = amd64Memory, amd64NoClass\n-\t\t} else {\n-\t\t\tif onFirst {\n-\t\t\t\tret1, ret2 = f, amd64NoClass\n-\t\t\t} else {\n-\t\t\t\tret2 = f\n-\t\t\t}\n-\t\t}\n-\t\tif ret1 == amd64Memory || ret2 == amd64Memory {\n-\t\t\tret1, ret2 = amd64Memory, amd64NoClass\n-\t\t}\n-\t}\n-\n-\tin := make([]Value, 0, len(ftyp.in))\n-\tintreg := 0\n-\tssereg := 0\n-\tap := uintptr(regs.rsp)\n-\n-\tmaxIntregs := 6 // When we support Windows, this would be 4.\n-\tmaxSSEregs := 8\n-\n-\tif ret1 == amd64Memory {\n-\t\t// We are returning a value in memory, which means\n-\t\t// that the first argument is a hidden parameter\n-\t\t// pointing to that return area.\n-\t\tintreg++\n-\t}\n-\n-argloop:\n-\tfor _, rt := range ftyp.in {\n-\t\tc1, c2 := amd64Classify(rt)\n-\n-\t\tfl := flag(rt.Kind())\n-\t\tif c2 == amd64NoClass {\n-\n-\t\t\t// Argument is passed in a single register or\n-\t\t\t// in memory.\n-\n-\t\t\tswitch c1 {\n-\t\t\tcase amd64NoClass:\n-\t\t\t\tv := Value{rt, nil, fl | flagIndir}\n-\t\t\t\tin = append(in, v)\n-\t\t\t\tcontinue argloop\n-\t\t\tcase amd64Integer:\n-\t\t\t\tif intreg < maxIntregs {\n-\t\t\t\t\treg := amd64IntregVal(regs, intreg)\n-\t\t\t\t\tiw := unsafe.Pointer(reg)\n-\t\t\t\t\tif k := rt.Kind(); k != Ptr && k != UnsafePointer {\n-\t\t\t\t\t\tiw = unsafe.Pointer(&reg)\n-\t\t\t\t\t\tfl |= flagIndir\n-\t\t\t\t\t}\n-\t\t\t\t\tv := Value{rt, iw, fl}\n-\t\t\t\t\tin = append(in, v)\n-\t\t\t\t\tintreg++\n-\t\t\t\t\tcontinue argloop\n-\t\t\t\t}\n-\t\t\tcase amd64SSE:\n-\t\t\t\tif ssereg < maxSSEregs {\n-\t\t\t\t\treg := amd64SSEregVal(regs, ssereg)\n-\t\t\t\t\tv := Value{rt, unsafe.Pointer(&reg), fl | flagIndir}\n-\t\t\t\t\tin = append(in, v)\n-\t\t\t\t\tssereg++\n-\t\t\t\t\tcontinue argloop\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tin, ap = amd64Memarg(in, ap, rt)\n-\t\t\tcontinue argloop\n-\t\t}\n-\n-\t\t// Argument is passed in two registers.\n-\n-\t\tnintregs := 0\n-\t\tnsseregs := 0\n-\t\tswitch c1 {\n-\t\tcase amd64Integer:\n-\t\t\tnintregs++\n-\t\tcase amd64SSE:\n-\t\t\tnsseregs++\n-\t\tdefault:\n-\t\t\tpanic(\"inconsistent\")\n-\t\t}\n-\t\tswitch c2 {\n-\t\tcase amd64Integer:\n-\t\t\tnintregs++\n-\t\tcase amd64SSE:\n-\t\t\tnsseregs++\n-\t\tdefault:\n-\t\t\tpanic(\"inconsistent\")\n-\t\t}\n-\n-\t\t// If the whole argument does not fit in registers, it\n-\t\t// is passed in memory.\n-\n-\t\tif intreg+nintregs > maxIntregs || ssereg+nsseregs > maxSSEregs {\n-\t\t\tin, ap = amd64Memarg(in, ap, rt)\n-\t\t\tcontinue argloop\n-\t\t}\n-\n-\t\tvar word1, word2 uintptr\n-\t\tswitch c1 {\n-\t\tcase amd64Integer:\n-\t\t\tword1 = amd64IntregVal(regs, intreg)\n-\t\t\tintreg++\n-\t\tcase amd64SSE:\n-\t\t\tword1 = amd64SSEregVal(regs, ssereg)\n-\t\t\tssereg++\n-\t\t}\n-\t\tswitch c2 {\n-\t\tcase amd64Integer:\n-\t\t\tword2 = amd64IntregVal(regs, intreg)\n-\t\t\tintreg++\n-\t\tcase amd64SSE:\n-\t\t\tword2 = amd64SSEregVal(regs, ssereg)\n-\t\t\tssereg++\n-\t\t}\n-\n-\t\tp := unsafe_New(rt)\n-\t\t*(*uintptr)(p) = word1\n-\t\t*(*uintptr)(unsafe.Pointer(uintptr(p) + ptrSize)) = word2\n-\t\tv := Value{rt, p, fl | flagIndir}\n-\t\tin = append(in, v)\n-\t}\n-\n-\t// All the real arguments have been found and turned into\n-\t// Value's.  Call the real function.\n-\n-\tout := c.call(in)\n-\n-\tif len(out) != len(ftyp.out) {\n-\t\tpanic(\"reflect: wrong return count from function created by MakeFunc\")\n-\t}\n-\n-\tfor i, typ := range ftyp.out {\n-\t\tv := out[i]\n-\t\tif v.typ != typ {\n-\t\t\tpanic(\"reflect: function created by MakeFunc using \" + funcName(c.fn) +\n-\t\t\t\t\" returned wrong type: have \" +\n-\t\t\t\tout[i].typ.String() + \" for \" + typ.String())\n-\t\t}\n-\t\tif v.flag&flagRO != 0 {\n-\t\t\tpanic(\"reflect: function created by MakeFunc using \" + funcName(c.fn) +\n-\t\t\t\t\" returned value obtained from unexported field\")\n-\t\t}\n-\t}\n-\n-\tif ret1 == amd64NoClass {\n-\t\treturn\n-\t}\n-\n-\tif ret1 == amd64Memory {\n-\t\t// The address of the memory area was passed as a\n-\t\t// hidden parameter in %rdi.\n-\t\tptr := unsafe.Pointer(uintptr(regs.rdi))\n-\t\toff := uintptr(0)\n-\t\tfor i, typ := range ftyp.out {\n-\t\t\tv := out[i]\n-\t\t\toff = align(off, uintptr(typ.fieldAlign))\n-\t\t\taddr := unsafe.Pointer(uintptr(ptr) + off)\n-\t\t\tif v.flag&flagIndir == 0 && (v.kind() == Ptr || v.kind() == UnsafePointer) {\n-\t\t\t\t*(*unsafe.Pointer)(addr) = v.ptr\n-\t\t\t} else {\n-\t\t\t\tmemmove(addr, v.ptr, typ.size)\n-\t\t\t}\n-\t\t\toff += typ.size\n-\t\t}\n-\t\treturn\n-\t}\n-\n-\tif len(out) == 1 && ret2 == amd64NoClass {\n-\t\tv := out[0]\n-\t\tvar w unsafe.Pointer\n-\t\tswitch v.Kind() {\n-\t\tcase Ptr, UnsafePointer, Chan, Func, Map:\n-\t\t\tw = v.pointer()\n-\t\tdefault:\n-\t\t\tmemmove(unsafe.Pointer(&w), v.ptr, v.typ.size)\n-\t\t}\n-\t\tswitch ret1 {\n-\t\tcase amd64Integer:\n-\t\t\tregs.rax = uint64(uintptr(w))\n-\t\tcase amd64SSE:\n-\t\t\tregs.xmm0[0] = uint64(uintptr(w))\n-\t\t\tregs.xmm0[1] = 0\n-\t\tdefault:\n-\t\t\tpanic(\"inconsistency\")\n-\t\t}\n-\t\treturn\n-\t}\n-\n-\tvar buf [2]unsafe.Pointer\n-\tptr := unsafe.Pointer(&buf[0])\n-\toff := uintptr(0)\n-\tfor i, typ := range ftyp.out {\n-\t\tv := out[i]\n-\t\toff = align(off, uintptr(typ.fieldAlign))\n-\t\taddr := unsafe.Pointer(uintptr(ptr) + off)\n-\t\tif v.flag&flagIndir == 0 && (v.kind() == Ptr || v.kind() == UnsafePointer) {\n-\t\t\t*(*unsafe.Pointer)(addr) = v.ptr\n-\t\t} else {\n-\t\t\tmemmove(addr, v.ptr, typ.size)\n-\t\t}\n-\t\toff += uintptr(typ.size)\n-\t}\n-\n-\tswitch ret1 {\n-\tcase amd64Integer:\n-\t\tregs.rax = *(*uint64)(unsafe.Pointer(&buf[0]))\n-\tcase amd64SSE:\n-\t\tregs.xmm0[0] = *(*uint64)(unsafe.Pointer(&buf[0]))\n-\t\tregs.xmm0[1] = 0\n-\tdefault:\n-\t\tpanic(\"inconsistency\")\n-\t}\n-\n-\tswitch ret2 {\n-\tcase amd64Integer:\n-\t\treg := *(*uint64)(unsafe.Pointer(&buf[1]))\n-\t\tif ret1 == amd64Integer {\n-\t\t\tregs.rdx = reg\n-\t\t} else {\n-\t\t\tregs.rax = reg\n-\t\t}\n-\tcase amd64SSE:\n-\t\treg := *(*uint64)(unsafe.Pointer(&buf[1]))\n-\t\tif ret1 == amd64Integer {\n-\t\t\tregs.xmm0[0] = reg\n-\t\t\tregs.xmm0[1] = 0\n-\t\t} else {\n-\t\t\tregs.xmm1[0] = reg\n-\t\t\tregs.xmm1[1] = 0\n-\t\t}\n-\tcase amd64NoClass:\n-\tdefault:\n-\t\tpanic(\"inconsistency\")\n-\t}\n-}\n-\n-// The amd64Memarg function adds an argument passed in memory.\n-func amd64Memarg(in []Value, ap uintptr, rt *rtype) ([]Value, uintptr) {\n-\tap = align(ap, ptrSize)\n-\tap = align(ap, uintptr(rt.align))\n-\n-\t// We have to copy the argument onto the heap in case the\n-\t// function hangs onto the reflect.Value we pass it.\n-\tp := unsafe_New(rt)\n-\tmemmove(p, unsafe.Pointer(ap), rt.size)\n-\n-\tv := Value{rt, p, flag(rt.Kind()) | flagIndir}\n-\tin = append(in, v)\n-\tap += rt.size\n-\treturn in, ap\n-}\n-\n-// The amd64IntregVal function returns the value of integer register i.\n-func amd64IntregVal(regs *amd64Regs, i int) uintptr {\n-\tvar r uint64\n-\tswitch i {\n-\tcase 0:\n-\t\tr = regs.rdi\n-\tcase 1:\n-\t\tr = regs.rsi\n-\tcase 2:\n-\t\tr = regs.rdx\n-\tcase 3:\n-\t\tr = regs.rcx\n-\tcase 4:\n-\t\tr = regs.r8\n-\tcase 5:\n-\t\tr = regs.r9\n-\tdefault:\n-\t\tpanic(\"amd64IntregVal: bad index\")\n-\t}\n-\treturn uintptr(r)\n-}\n-\n-// The amd64SSEregVal function returns the value of SSE register i.\n-// Note that although SSE registers can hold two uinptr's, for the\n-// types we use in Go we only ever use the least significant one.  The\n-// most significant one would only be used for 128 bit types.\n-func amd64SSEregVal(regs *amd64Regs, i int) uintptr {\n-\tvar r uint64\n-\tswitch i {\n-\tcase 0:\n-\t\tr = regs.xmm0[0]\n-\tcase 1:\n-\t\tr = regs.xmm1[0]\n-\tcase 2:\n-\t\tr = regs.xmm2[0]\n-\tcase 3:\n-\t\tr = regs.xmm3[0]\n-\tcase 4:\n-\t\tr = regs.xmm4[0]\n-\tcase 5:\n-\t\tr = regs.xmm5[0]\n-\tcase 6:\n-\t\tr = regs.xmm6[0]\n-\tcase 7:\n-\t\tr = regs.xmm7[0]\n-\t}\n-\treturn uintptr(r)\n-}"}, {"sha": "47daa77f6bb7f2349a8ae4b0cec9c34ec2c44d0e", "filename": "libgo/go/reflect/makefuncgo_s390.go", "status": "removed", "additions": 0, "deletions": 454, "changes": 454, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21cb351825d45c42e9e5148715a2fd2051cf4ed1/libgo%2Fgo%2Freflect%2Fmakefuncgo_s390.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21cb351825d45c42e9e5148715a2fd2051cf4ed1/libgo%2Fgo%2Freflect%2Fmakefuncgo_s390.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fmakefuncgo_s390.go?ref=21cb351825d45c42e9e5148715a2fd2051cf4ed1", "patch": "@@ -1,454 +0,0 @@\n-// Copyright 2014 The Go Authors.  All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// MakeFunc s390 implementation.\n-\n-package reflect\n-\n-import \"unsafe\"\n-\n-// Convenience types and constants.\n-const s390_arch_stack_slot_align uintptr = 4\n-const s390_num_gr = 5\n-const s390_num_fr = 2\n-\n-type s390_arch_gr_t uint32\n-type s390_arch_fr_t uint64\n-\n-// The assembler stub will pass a pointer to this structure.\n-// This will come in holding all the registers that might hold\n-// function parameters.  On return we will set the registers that\n-// might hold result values.\n-type s390_regs struct {\n-\tr2         s390_arch_gr_t\n-\tr3         s390_arch_gr_t\n-\tr4         s390_arch_gr_t\n-\tr5         s390_arch_gr_t\n-\tr6         s390_arch_gr_t\n-\tstack_args s390_arch_gr_t\n-\tf0         s390_arch_fr_t\n-\tf2         s390_arch_fr_t\n-}\n-\n-// Argument classifications that arise for Go types.\n-type s390_arg_t int\n-\n-const (\n-\ts390_general_reg s390_arg_t = iota\n-\ts390_general_reg_pair\n-\ts390_float_reg\n-\t// Argument passed as a pointer to an in-memory value.\n-\ts390_mem_ptr\n-\ts390_empty\n-)\n-\n-// s390ClassifyParameter returns the register class needed to\n-// pass the value of type TYP.  s390_empty means the register is\n-// not used.  The second and third return values are the offset of\n-// an rtype parameter passed in a register (second) or stack slot\n-// (third).\n-func s390ClassifyParameter(typ *rtype) (s390_arg_t, uintptr, uintptr) {\n-\toffset := s390_arch_stack_slot_align - typ.Size()\n-\tif typ.Size() > s390_arch_stack_slot_align {\n-\t\toffset = 0\n-\t}\n-\tswitch typ.Kind() {\n-\tdefault:\n-\t\tpanic(\"internal error--unknown kind in s390ClassifyParameter\")\n-\tcase Bool, Int, Int8, Int16, Int32, Uint, Uint8, Uint16, Uint32:\n-\t\treturn s390_general_reg, offset, offset\n-\tcase Int64, Uint64:\n-\t\treturn s390_general_reg_pair, 0, 0\n-\tcase Uintptr, Chan, Func, Map, Ptr, UnsafePointer:\n-\t\treturn s390_general_reg, 0, 0\n-\tcase Float32, Float64:\n-\t\treturn s390_float_reg, 0, offset\n-\tcase Complex64, Complex128:\n-\t\t// Complex numbers are passed by reference.\n-\t\treturn s390_mem_ptr, 0, 0\n-\tcase Array, Struct:\n-\t\tvar ityp *rtype\n-\t\tvar length int\n-\n-\t\tif typ.Size() == 0 {\n-\t\t\treturn s390_empty, 0, 0\n-\t\t}\n-\t\tswitch typ.Size() {\n-\t\tdefault:\n-\t\t\t// Pointer to memory.\n-\t\t\treturn s390_mem_ptr, 0, 0\n-\t\tcase 1, 2:\n-\t\t\t// Pass in an integer register.\n-\t\t\treturn s390_general_reg, offset, offset\n-\n-\t\tcase 4, 8:\n-\t\t\t// See below.\n-\t\t}\n-\t\tif typ.Kind() == Array {\n-\t\t\tatyp := (*arrayType)(unsafe.Pointer(typ))\n-\t\t\tlength = atyp.Len()\n-\t\t\tityp = atyp.elem\n-\t\t} else {\n-\t\t\tstyp := (*structType)(unsafe.Pointer(typ))\n-\t\t\tlength = len(styp.fields)\n-\t\t\tityp = styp.fields[0].typ\n-\t\t}\n-\t\tif length == 1 {\n-\t\t\tclass, off_reg, off_slot := s390ClassifyParameter(ityp)\n-\t\t\tif class == s390_float_reg {\n-\t\t\t\t// The array (stored in a structure) or struct\n-\t\t\t\t// is \"equivalent to a floating point type\" as\n-\t\t\t\t// defined in the S390 Abi.  Note that this\n-\t\t\t\t// can only be the case in the case 4 of the\n-\t\t\t\t// switch above.\n-\t\t\t\treturn s390_float_reg, off_reg, off_slot\n-\t\t\t}\n-\t\t}\n-\t\tswitch typ.Size() {\n-\t\tcase 4:\n-\t\t\treturn s390_general_reg, offset, offset\n-\t\tcase 8:\n-\t\t\treturn s390_general_reg_pair, 0, 0\n-\t\tdefault:\n-\t\t\treturn s390_general_reg, 0, 0\n-\t\t}\n-\tcase Interface, String:\n-\t\t// Structure of size 8.\n-\t\treturn s390_general_reg_pair, 0, 0\n-\n-\tcase Slice:\n-\t\treturn s390_mem_ptr, 0, 0\n-\t}\n-}\n-\n-// s390ClassifyReturn returns the register classes needed to\n-// return the value of type TYP.  s390_empty means the register is\n-// not used.  The second value is the offset of an rtype return\n-// parameter if stored in a register.\n-func s390ClassifyReturn(typ *rtype) (s390_arg_t, uintptr) {\n-\toffset := s390_arch_stack_slot_align - typ.Size()\n-\tif typ.Size() > s390_arch_stack_slot_align {\n-\t\toffset = 0\n-\t}\n-\tswitch typ.Kind() {\n-\tdefault:\n-\t\tpanic(\"internal error--unknown kind in s390ClassifyReturn\")\n-\tcase Bool, Int, Int8, Int16, Int32,\n-\t\tUint, Uint8, Uint16, Uint32, Uintptr:\n-\n-\t\treturn s390_general_reg, offset\n-\tcase Int64, Uint64:\n-\t\treturn s390_general_reg_pair, 0\n-\tcase Chan, Func, Map, Ptr, UnsafePointer:\n-\t\treturn s390_general_reg, 0\n-\tcase Float32, Float64:\n-\t\treturn s390_float_reg, 0\n-\tcase Complex64, Complex128:\n-\t\treturn s390_mem_ptr, 0\n-\tcase Interface, Slice, String:\n-\t\treturn s390_mem_ptr, 0\n-\tcase Array, Struct:\n-\t\tif typ.size == 0 {\n-\t\t\treturn s390_empty, 0\n-\t\t}\n-\t\t// No optimization is done for returned structures and arrays.\n-\t\treturn s390_mem_ptr, 0\n-\t}\n-}\n-\n-// Given a value of type *rtype left aligned in an unsafe.Pointer,\n-// reload the value so that it can be stored in a general or\n-// floating point register.  For general registers the value is\n-// sign extend and right aligned.\n-func s390ReloadForRegister(typ *rtype, w uintptr, offset uintptr) uintptr {\n-\tvar do_sign_extend bool = false\n-\tvar gr s390_arch_gr_t\n-\n-\tswitch typ.Kind() {\n-\tcase Int, Int8, Int16, Int32:\n-\t\tdo_sign_extend = true\n-\tdefault:\n-\t\t// Handle all other cases in the next switch.\n-\t}\n-\tswitch typ.size {\n-\tcase 1:\n-\t\tif do_sign_extend == true {\n-\t\t\tse := int32(*(*int8)(unsafe.Pointer(&w)))\n-\t\t\tgr = *(*s390_arch_gr_t)(unsafe.Pointer(&se))\n-\t\t} else {\n-\t\t\te := int32(*(*uint8)(unsafe.Pointer(&w)))\n-\t\t\tgr = *(*s390_arch_gr_t)(unsafe.Pointer(&e))\n-\t\t}\n-\tcase 2:\n-\t\tif do_sign_extend == true {\n-\t\t\tse := int32(*(*int16)(unsafe.Pointer(&w)))\n-\t\t\tgr = *(*s390_arch_gr_t)(unsafe.Pointer(&se))\n-\t\t} else {\n-\t\t\te := int32(*(*uint16)(unsafe.Pointer(&w)))\n-\t\t\tgr = *(*s390_arch_gr_t)(unsafe.Pointer(&e))\n-\t\t}\n-\tdefault:\n-\t\tpanic(\"reflect: bad size in s390ReloadForRegister\")\n-\t}\n-\n-\treturn *(*uintptr)(unsafe.Pointer(&gr))\n-}\n-\n-// MakeFuncStubGo implements the s390 calling convention for\n-// MakeFunc.  This should not be called.  It is exported so that\n-// assembly code can call it.\n-func S390MakeFuncStubGo(regs *s390_regs, c *makeFuncImpl) {\n-\tftyp := c.typ\n-\tgr := 0\n-\tfr := 0\n-\tap := uintptr(regs.stack_args)\n-\n-\t// See if the result requires a struct.  If it does, the first\n-\t// parameter is a pointer to the struct.\n-\tvar ret_class s390_arg_t\n-\tvar ret_off_reg uintptr\n-\tvar ret_type *rtype\n-\n-\tswitch len(ftyp.out) {\n-\tcase 0:\n-\t\tret_type = nil\n-\t\tret_class, ret_off_reg = s390_empty, 0\n-\tcase 1:\n-\t\tret_type = ftyp.out[0]\n-\t\tret_class, ret_off_reg = s390ClassifyReturn(ret_type)\n-\tdefault:\n-\t\tret_type = nil\n-\t\tret_class, ret_off_reg = s390_mem_ptr, 0\n-\t}\n-\tin := make([]Value, 0, len(ftyp.in))\n-\tif ret_class == s390_mem_ptr {\n-\t\t// We are returning a value in memory, which means\n-\t\t// that the first argument is a hidden parameter\n-\t\t// pointing to that return area.\n-\t\tgr++\n-\t}\n-\n-argloop:\n-\tfor _, rt := range ftyp.in {\n-\t\tclass, off_reg, off_slot := s390ClassifyParameter(rt)\n-\t\tfl := flag(rt.Kind())\n-\t\tswitch class {\n-\t\tcase s390_empty:\n-\t\t\tv := Value{rt, nil, fl | flagIndir}\n-\t\t\tin = append(in, v)\n-\t\t\tcontinue argloop\n-\t\tcase s390_general_reg:\n-\t\t\t// Values stored in a general register are right\n-\t\t\t// aligned.\n-\t\t\tif gr < s390_num_gr {\n-\t\t\t\tval := s390_general_reg_val(regs, gr)\n-\t\t\t\tiw := unsafe.Pointer(&val)\n-\t\t\t\tk := rt.Kind()\n-\t\t\t\tif k != Ptr && k != UnsafePointer {\n-\t\t\t\t\tix := uintptr(unsafe.Pointer(&val))\n-\t\t\t\t\tix += off_reg\n-\t\t\t\t\tiw = unsafe.Pointer(ix)\n-\t\t\t\t\tfl |= flagIndir\n-\t\t\t\t}\n-\t\t\t\tv := Value{rt, iw, fl}\n-\t\t\t\tin = append(in, v)\n-\t\t\t\tgr++\n-\t\t\t} else {\n-\t\t\t\tin, ap = s390_add_stackreg(\n-\t\t\t\t\tin, ap, rt, off_slot)\n-\t\t\t}\n-\t\t\tcontinue argloop\n-\t\tcase s390_general_reg_pair:\n-\t\t\t// 64-bit integers and structs are passed in a register\n-\t\t\t// pair.\n-\t\t\tif gr+1 < s390_num_gr {\n-\t\t\t\tval := uint64(s390_general_reg_val(regs, gr))<<32 + uint64(s390_general_reg_val(regs, gr+1))\n-\t\t\t\tiw := unsafe.Pointer(&val)\n-\t\t\t\tv := Value{rt, iw, fl | flagIndir}\n-\t\t\t\tin = append(in, v)\n-\t\t\t\tgr += 2\n-\t\t\t} else {\n-\t\t\t\tin, ap = s390_add_stackreg(in, ap, rt, off_slot)\n-\t\t\t\tgr = s390_num_gr\n-\t\t\t}\n-\t\t\tcontinue argloop\n-\t\tcase s390_float_reg:\n-\t\t\t// In a register, floats are left aligned, but in a\n-\t\t\t// stack slot they are right aligned.\n-\t\t\tif fr < s390_num_fr {\n-\t\t\t\tval := s390_float_reg_val(regs, fr)\n-\t\t\t\tix := uintptr(unsafe.Pointer(&val))\n-\t\t\t\tv := Value{\n-\t\t\t\t\trt, unsafe.Pointer(unsafe.Pointer(ix)),\n-\t\t\t\t\tfl | flagIndir,\n-\t\t\t\t}\n-\t\t\t\tin = append(in, v)\n-\t\t\t\tfr++\n-\t\t\t} else {\n-\t\t\t\tin, ap = s390_add_stackreg(\n-\t\t\t\t\tin, ap, rt, off_slot)\n-\t\t\t}\n-\t\t\tcontinue argloop\n-\t\tcase s390_mem_ptr:\n-\t\t\tif gr < s390_num_gr {\n-\t\t\t\t// Register holding a pointer to memory.\n-\t\t\t\tval := s390_general_reg_val(regs, gr)\n-\t\t\t\tv := Value{\n-\t\t\t\t\trt, unsafe.Pointer(uintptr(val)),\n-\t\t\t\t\tfl | flagIndir}\n-\t\t\t\tin = append(in, v)\n-\t\t\t\tgr++\n-\t\t\t} else {\n-\t\t\t\t// Stack slot holding a pointer to memory.\n-\t\t\t\tin, ap = s390_add_memarg(in, ap, rt)\n-\t\t\t}\n-\t\t\tcontinue argloop\n-\t\t}\n-\t\tpanic(\"reflect: argtype not handled in MakeFunc:argloop\")\n-\t}\n-\n-\t// All the real arguments have been found and turned into\n-\t// Values.  Call the real function.\n-\n-\tout := c.call(in)\n-\n-\tif len(out) != len(ftyp.out) {\n-\t\tpanic(\"reflect: wrong return count from function created by MakeFunc\")\n-\t}\n-\n-\tfor i, typ := range ftyp.out {\n-\t\tv := out[i]\n-\t\tif v.typ != typ {\n-\t\t\tpanic(\n-\t\t\t\t\"reflect: function created by MakeFunc using \" +\n-\t\t\t\t\tfuncName(c.fn) + \" returned wrong type: have \" +\n-\t\t\t\t\tout[i].typ.String() + \" for \" + typ.String())\n-\t\t}\n-\t\tif v.flag&flagRO != 0 {\n-\t\t\tpanic(\n-\t\t\t\t\"reflect: function created by MakeFunc using \" +\n-\t\t\t\t\tfuncName(c.fn) + \" returned value obtained \" +\n-\t\t\t\t\t\"from unexported field\")\n-\t\t}\n-\t}\n-\n-\tswitch ret_class {\n-\tcase s390_general_reg, s390_float_reg, s390_general_reg_pair:\n-\t\t// Single return value in a general or floating point register.\n-\t\tv := out[0]\n-\t\tvar w uintptr\n-\t\tswitch v.Kind() {\n-\t\tcase Ptr, UnsafePointer, Chan, Func, Map:\n-\t\t\tw = uintptr(v.pointer())\n-\t\tdefault:\n-\t\t\tmemmove(unsafe.Pointer(&w), v.ptr, v.typ.size)\n-\t\t\tif ret_off_reg != 0 {\n-\t\t\t\tw = s390ReloadForRegister(\n-\t\t\t\t\tret_type, w, ret_off_reg)\n-\t\t\t}\n-\t\t}\n-\t\tif ret_class == s390_float_reg {\n-\t\t\tregs.f0 = s390_arch_fr_t(uintptr(w))\n-\t\t} else if ret_class == s390_general_reg {\n-\t\t\tregs.r2 = s390_arch_gr_t(uintptr(w))\n-\t\t} else {\n-\t\t\tregs.r2 = s390_arch_gr_t(uintptr(w) >> 32)\n-\t\t\tregs.r3 = s390_arch_gr_t(uintptr(w) & 0xffffffff)\n-\t\t}\n-\n-\tcase s390_mem_ptr:\n-\t\t// The address of the memory area was passed as a hidden\n-\t\t// parameter in %r2.  Multiple return values are always returned\n-\t\t// in an in-memory structure.\n-\t\tptr := unsafe.Pointer(uintptr(regs.r2))\n-\t\toff := uintptr(0)\n-\t\tfor i, typ := range ftyp.out {\n-\t\t\tv := out[i]\n-\t\t\toff = align(off, uintptr(typ.fieldAlign))\n-\t\t\taddr := unsafe.Pointer(uintptr(ptr) + off)\n-\t\t\tif v.flag&flagIndir == 0 && (v.kind() == Ptr || v.kind() == UnsafePointer) {\n-\t\t\t\t*(*unsafe.Pointer)(addr) = v.ptr\n-\t\t\t} else {\n-\t\t\t\tmemmove(addr, v.ptr, typ.size)\n-\t\t\t}\n-\t\t\toff += typ.size\n-\t\t}\n-\n-\tcase s390_empty:\n-\t}\n-\n-\treturn\n-}\n-\n-// The s390_add_stackreg function adds an argument passed on the\n-// stack that could be passed in a register.\n-func s390_add_stackreg(in []Value, ap uintptr, rt *rtype, offset uintptr) ([]Value, uintptr) {\n-\t// If we're not already at the beginning of a stack slot, round up to\n-\t// the beginning of the next one.\n-\tap = align(ap, s390_arch_stack_slot_align)\n-\t// If offset is > 0, the data is right aligned on the stack slot.\n-\tap += offset\n-\n-\t// We have to copy the argument onto the heap in case the\n-\t// function hangs onto the reflect.Value we pass it.\n-\tp := unsafe_New(rt)\n-\tmemmove(p, unsafe.Pointer(ap), rt.size)\n-\n-\tv := Value{rt, p, flag(rt.Kind()) | flagIndir}\n-\tin = append(in, v)\n-\tap += rt.size\n-\tap = align(ap, s390_arch_stack_slot_align)\n-\n-\treturn in, ap\n-}\n-\n-// The s390_add_memarg function adds an argument passed in memory.\n-func s390_add_memarg(in []Value, ap uintptr, rt *rtype) ([]Value, uintptr) {\n-\t// If we're not already at the beginning of a stack slot,\n-\t// round up to the beginning of the next one.\n-\tap = align(ap, s390_arch_stack_slot_align)\n-\n-\t// We have to copy the argument onto the heap in case the\n-\t// function hangs onto the reflect.Value we pass it.\n-\tp := unsafe_New(rt)\n-\tmemmove(p, *(*unsafe.Pointer)(unsafe.Pointer(ap)), rt.size)\n-\n-\tv := Value{rt, p, flag(rt.Kind()) | flagIndir}\n-\tin = append(in, v)\n-\tap += s390_arch_stack_slot_align\n-\n-\treturn in, ap\n-}\n-\n-// The s390_general_reg_val function returns the value of integer register GR.\n-func s390_general_reg_val(regs *s390_regs, gr int) s390_arch_gr_t {\n-\tswitch gr {\n-\tcase 0:\n-\t\treturn regs.r2\n-\tcase 1:\n-\t\treturn regs.r3\n-\tcase 2:\n-\t\treturn regs.r4\n-\tcase 3:\n-\t\treturn regs.r5\n-\tcase 4:\n-\t\treturn regs.r6\n-\tdefault:\n-\t\tpanic(\"s390_general_reg_val: bad integer register\")\n-\t}\n-}\n-\n-// The s390_float_reg_val function returns the value of float register FR.\n-func s390_float_reg_val(regs *s390_regs, fr int) uintptr {\n-\tvar r s390_arch_fr_t\n-\tswitch fr {\n-\tcase 0:\n-\t\tr = regs.f0\n-\tcase 1:\n-\t\tr = regs.f2\n-\tdefault:\n-\t\tpanic(\"s390_float_reg_val: bad floating point register\")\n-\t}\n-\treturn uintptr(r)\n-}"}, {"sha": "6e510156b34f41bb7332112208b3bcb635283d87", "filename": "libgo/go/reflect/makefuncgo_s390x.go", "status": "removed", "additions": 0, "deletions": 436, "changes": 436, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21cb351825d45c42e9e5148715a2fd2051cf4ed1/libgo%2Fgo%2Freflect%2Fmakefuncgo_s390x.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21cb351825d45c42e9e5148715a2fd2051cf4ed1/libgo%2Fgo%2Freflect%2Fmakefuncgo_s390x.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fmakefuncgo_s390x.go?ref=21cb351825d45c42e9e5148715a2fd2051cf4ed1", "patch": "@@ -1,436 +0,0 @@\n-// Copyright 2014 The Go Authors.  All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// MakeFunc s390x implementation.\n-\n-package reflect\n-\n-import \"unsafe\"\n-\n-// Convenience types and constants.\n-const s390x_arch_stack_slot_align uintptr = 8\n-const s390x_num_gr = 5\n-const s390x_num_fr = 4\n-\n-type s390x_arch_gr_t uint64\n-type s390x_arch_fr_t uint64\n-\n-// The assembler stub will pass a pointer to this structure.\n-// This will come in holding all the registers that might hold\n-// function parameters.  On return we will set the registers that\n-// might hold result values.\n-type s390x_regs struct {\n-\tr2         s390x_arch_gr_t\n-\tr3         s390x_arch_gr_t\n-\tr4         s390x_arch_gr_t\n-\tr5         s390x_arch_gr_t\n-\tr6         s390x_arch_gr_t\n-\tstack_args s390x_arch_gr_t\n-\tf0         s390x_arch_fr_t\n-\tf2         s390x_arch_fr_t\n-\tf4         s390x_arch_fr_t\n-\tf6         s390x_arch_fr_t\n-}\n-\n-// Argument classifications that arise for Go types.\n-type s390x_arg_t int\n-\n-const (\n-\ts390x_general_reg s390x_arg_t = iota\n-\ts390x_float_reg\n-\t// Argument passed as a pointer to an in-memory value.\n-\ts390x_mem_ptr\n-\ts390x_empty\n-)\n-\n-// s390xClassifyParameter returns the register class needed to\n-// pass the value of type TYP.  s390x_empty means the register is\n-// not used.  The second and third return values are the offset of\n-// an rtype parameter passed in a register (second) or stack slot\n-// (third).\n-func s390xClassifyParameter(typ *rtype) (s390x_arg_t, uintptr, uintptr) {\n-\toffset := s390x_arch_stack_slot_align - typ.Size()\n-\tswitch typ.Kind() {\n-\tdefault:\n-\t\tpanic(\"internal error--unknown kind in s390xClassifyParameter\")\n-\tcase Bool, Int, Int8, Int16, Int32, Uint, Uint8, Uint16, Uint32:\n-\t\treturn s390x_general_reg, offset, offset\n-\tcase Int64, Uint64, Uintptr, Chan, Func, Map, Ptr, UnsafePointer:\n-\t\treturn s390x_general_reg, 0, 0\n-\tcase Float32, Float64:\n-\t\treturn s390x_float_reg, 0, offset\n-\tcase Complex64, Complex128:\n-\t\t// Complex numbers are passed by reference.\n-\t\treturn s390x_mem_ptr, 0, 0\n-\tcase Array, Struct:\n-\t\tvar ityp *rtype\n-\t\tvar length int\n-\n-\t\tif typ.Size() == 0 {\n-\t\t\treturn s390x_empty, 0, 0\n-\t\t}\n-\t\tswitch typ.Size() {\n-\t\tdefault:\n-\t\t\t// Pointer to memory.\n-\t\t\treturn s390x_mem_ptr, 0, 0\n-\t\tcase 1, 2:\n-\t\t\t// Pass in an integer register.\n-\t\t\treturn s390x_general_reg, offset, offset\n-\n-\t\tcase 4, 8:\n-\t\t\t// See below.\n-\t\t}\n-\t\tif typ.Kind() == Array {\n-\t\t\tatyp := (*arrayType)(unsafe.Pointer(typ))\n-\t\t\tlength = atyp.Len()\n-\t\t\tityp = atyp.elem\n-\t\t} else {\n-\t\t\tstyp := (*structType)(unsafe.Pointer(typ))\n-\t\t\tlength = len(styp.fields)\n-\t\t\tityp = styp.fields[0].typ\n-\t\t}\n-\t\tif length == 1 {\n-\t\t\tclass, off_reg, off_slot := s390xClassifyParameter(ityp)\n-\t\t\tif class == s390x_float_reg {\n-\t\t\t\t// The array (stored in a structure) or struct\n-\t\t\t\t// is \"equivalent to a floating point type\" as\n-\t\t\t\t// defined in the S390x Abi.  Note that this\n-\t\t\t\t// can only be the case in the cases 4 and 8 of\n-\t\t\t\t// the switch above.\n-\t\t\t\treturn s390x_float_reg, off_reg, off_slot\n-\t\t\t}\n-\t\t}\n-\t\t// Otherwise pass in an integer register.\n-\t\tswitch typ.Size() {\n-\t\tcase 4, 8:\n-\t\t\treturn s390x_general_reg, offset, offset\n-\t\tdefault:\n-\t\t\treturn s390x_general_reg, 0, 0\n-\t\t}\n-\tcase Interface, Slice, String:\n-\t\treturn s390x_mem_ptr, 0, 0\n-\t}\n-}\n-\n-// s390xClassifyReturn returns the register classes needed to\n-// return the value of type TYP.  s390_empty means the register is\n-// not used.  The second value is the offset of an rtype return\n-// parameter if stored in a register.\n-func s390xClassifyReturn(typ *rtype) (s390x_arg_t, uintptr) {\n-\toffset := s390x_arch_stack_slot_align - typ.Size()\n-\tswitch typ.Kind() {\n-\tdefault:\n-\t\tpanic(\"internal error--unknown kind in s390xClassifyReturn\")\n-\tcase Bool, Int, Int8, Int16, Int32, Int64,\n-\t\tUint, Uint8, Uint16, Uint32, Uint64, Uintptr:\n-\n-\t\treturn s390x_general_reg, offset\n-\tcase Chan, Func, Map, Ptr, UnsafePointer:\n-\t\treturn s390x_general_reg, 0\n-\tcase Float32, Float64:\n-\t\treturn s390x_float_reg, 0\n-\tcase Complex64, Complex128:\n-\t\treturn s390x_mem_ptr, 0\n-\tcase Interface, Slice, String:\n-\t\treturn s390x_mem_ptr, 0\n-\tcase Array, Struct:\n-\t\tif typ.size == 0 {\n-\t\t\treturn s390x_empty, 0\n-\t\t}\n-\t\t// No optimization is done for returned structures and arrays.\n-\t\treturn s390x_mem_ptr, 0\n-\t}\n-}\n-\n-// Given a value of type *rtype left aligned in an unsafe.Pointer,\n-// reload the value so that it can be stored in a general or\n-// floating point register.  For general registers the value is\n-// sign extend and right aligned.\n-func s390xReloadForRegister(typ *rtype, w uintptr, offset uintptr) uintptr {\n-\tvar do_sign_extend bool = false\n-\tvar gr s390x_arch_gr_t\n-\n-\tswitch typ.Kind() {\n-\tcase Int, Int8, Int16, Int32, Int64:\n-\t\tdo_sign_extend = true\n-\tdefault:\n-\t\t// Handle all other cases in the next switch.\n-\t}\n-\tswitch typ.size {\n-\tcase 1:\n-\t\tif do_sign_extend == true {\n-\t\t\tse := int64(*(*int8)(unsafe.Pointer(&w)))\n-\t\t\tgr = *(*s390x_arch_gr_t)(unsafe.Pointer(&se))\n-\t\t} else {\n-\t\t\te := int64(*(*uint8)(unsafe.Pointer(&w)))\n-\t\t\tgr = *(*s390x_arch_gr_t)(unsafe.Pointer(&e))\n-\t\t}\n-\tcase 2:\n-\t\tif do_sign_extend == true {\n-\t\t\tse := int64(*(*int16)(unsafe.Pointer(&w)))\n-\t\t\tgr = *(*s390x_arch_gr_t)(unsafe.Pointer(&se))\n-\t\t} else {\n-\t\t\te := int64(*(*uint16)(unsafe.Pointer(&w)))\n-\t\t\tgr = *(*s390x_arch_gr_t)(unsafe.Pointer(&e))\n-\t\t}\n-\tcase 4:\n-\t\tif do_sign_extend == true {\n-\t\t\tse := int64(*(*int32)(unsafe.Pointer(&w)))\n-\t\t\tgr = *(*s390x_arch_gr_t)(unsafe.Pointer(&se))\n-\t\t} else {\n-\t\t\te := int64(*(*uint32)(unsafe.Pointer(&w)))\n-\t\t\tgr = *(*s390x_arch_gr_t)(unsafe.Pointer(&e))\n-\t\t}\n-\tdefault:\n-\t\tpanic(\"reflect: bad size in s390xReloadForRegister\")\n-\t}\n-\n-\treturn *(*uintptr)(unsafe.Pointer(&gr))\n-}\n-\n-// MakeFuncStubGo implements the s390x calling convention for\n-// MakeFunc.  This should not be called.  It is exported so that\n-// assembly code can call it.\n-func S390xMakeFuncStubGo(regs *s390x_regs, c *makeFuncImpl) {\n-\tftyp := c.typ\n-\tgr := 0\n-\tfr := 0\n-\tap := uintptr(regs.stack_args)\n-\n-\t// See if the result requires a struct.  If it does, the first\n-\t// parameter is a pointer to the struct.\n-\tvar ret_class s390x_arg_t\n-\tvar ret_off_reg uintptr\n-\tvar ret_type *rtype\n-\n-\tswitch len(ftyp.out) {\n-\tcase 0:\n-\t\tret_type = nil\n-\t\tret_class, ret_off_reg = s390x_empty, 0\n-\tcase 1:\n-\t\tret_type = ftyp.out[0]\n-\t\tret_class, ret_off_reg = s390xClassifyReturn(ret_type)\n-\tdefault:\n-\t\tret_type = nil\n-\t\tret_class, ret_off_reg = s390x_mem_ptr, 0\n-\t}\n-\tin := make([]Value, 0, len(ftyp.in))\n-\tif ret_class == s390x_mem_ptr {\n-\t\t// We are returning a value in memory, which means\n-\t\t// that the first argument is a hidden parameter\n-\t\t// pointing to that return area.\n-\t\tgr++\n-\t}\n-\n-argloop:\n-\tfor _, rt := range ftyp.in {\n-\t\tclass, off_reg, off_slot := s390xClassifyParameter(rt)\n-\t\tfl := flag(rt.Kind())\n-\t\tswitch class {\n-\t\tcase s390x_empty:\n-\t\t\tv := Value{rt, nil, fl | flagIndir}\n-\t\t\tin = append(in, v)\n-\t\t\tcontinue argloop\n-\t\tcase s390x_general_reg:\n-\t\t\t// Values stored in a general register are right\n-\t\t\t// aligned.\n-\t\t\tif gr < s390x_num_gr {\n-\t\t\t\tval := s390x_general_reg_val(regs, gr)\n-\t\t\t\tiw := unsafe.Pointer(val)\n-\t\t\t\tk := rt.Kind()\n-\t\t\t\tif k != Ptr && k != UnsafePointer {\n-\t\t\t\t\tix := uintptr(unsafe.Pointer(&val))\n-\t\t\t\t\tix += off_reg\n-\t\t\t\t\tiw = unsafe.Pointer(ix)\n-\t\t\t\t\tfl |= flagIndir\n-\t\t\t\t}\n-\t\t\t\tv := Value{rt, iw, fl}\n-\t\t\t\tin = append(in, v)\n-\t\t\t\tgr++\n-\t\t\t} else {\n-\t\t\t\tin, ap = s390x_add_stackreg(\n-\t\t\t\t\tin, ap, rt, off_slot)\n-\t\t\t}\n-\t\t\tcontinue argloop\n-\t\tcase s390x_float_reg:\n-\t\t\t// In a register, floats are left aligned, but in a\n-\t\t\t// stack slot they are right aligned.\n-\t\t\tif fr < s390x_num_fr {\n-\t\t\t\tval := s390x_float_reg_val(regs, fr)\n-\t\t\t\tix := uintptr(unsafe.Pointer(&val))\n-\t\t\t\tv := Value{\n-\t\t\t\t\trt, unsafe.Pointer(unsafe.Pointer(ix)),\n-\t\t\t\t\tfl | flagIndir,\n-\t\t\t\t}\n-\t\t\t\tin = append(in, v)\n-\t\t\t\tfr++\n-\t\t\t} else {\n-\t\t\t\tin, ap = s390x_add_stackreg(\n-\t\t\t\t\tin, ap, rt, off_slot)\n-\t\t\t}\n-\t\t\tcontinue argloop\n-\t\tcase s390x_mem_ptr:\n-\t\t\tif gr < s390x_num_gr {\n-\t\t\t\t// Register holding a pointer to memory.\n-\t\t\t\tval := s390x_general_reg_val(regs, gr)\n-\t\t\t\tv := Value{\n-\t\t\t\t\trt, unsafe.Pointer(val), fl | flagIndir}\n-\t\t\t\tin = append(in, v)\n-\t\t\t\tgr++\n-\t\t\t} else {\n-\t\t\t\t// Stack slot holding a pointer to memory.\n-\t\t\t\tin, ap = s390x_add_memarg(in, ap, rt)\n-\t\t\t}\n-\t\t\tcontinue argloop\n-\t\t}\n-\t\tpanic(\"reflect: argtype not handled in MakeFunc:argloop\")\n-\t}\n-\n-\t// All the real arguments have been found and turned into\n-\t// Values.  Call the real function.\n-\n-\tout := c.call(in)\n-\n-\tif len(out) != len(ftyp.out) {\n-\t\tpanic(\"reflect: wrong return count from function created by MakeFunc\")\n-\t}\n-\n-\tfor i, typ := range ftyp.out {\n-\t\tv := out[i]\n-\t\tif v.typ != typ {\n-\t\t\tpanic(\n-\t\t\t\t\"reflect: function created by MakeFunc using \" +\n-\t\t\t\t\tfuncName(c.fn) + \" returned wrong type: have \" +\n-\t\t\t\t\tout[i].typ.String() + \" for \" + typ.String())\n-\t\t}\n-\t\tif v.flag&flagRO != 0 {\n-\t\t\tpanic(\n-\t\t\t\t\"reflect: function created by MakeFunc using \" +\n-\t\t\t\t\tfuncName(c.fn) + \" returned value obtained \" +\n-\t\t\t\t\t\"from unexported field\")\n-\t\t}\n-\t}\n-\n-\tswitch ret_class {\n-\tcase s390x_general_reg, s390x_float_reg:\n-\t\t// Single return value in a general or floating point register.\n-\t\tv := out[0]\n-\t\tvar w uintptr\n-\t\tswitch v.Kind() {\n-\t\tcase Ptr, UnsafePointer, Chan, Func, Map:\n-\t\t\tw = uintptr(v.pointer())\n-\t\tdefault:\n-\t\t\tmemmove(unsafe.Pointer(&w), v.ptr, v.typ.size)\n-\t\t\tif ret_off_reg != 0 {\n-\t\t\t\tw = s390xReloadForRegister(\n-\t\t\t\t\tret_type, w, ret_off_reg)\n-\t\t\t}\n-\t\t}\n-\t\tif ret_class == s390x_float_reg {\n-\t\t\tregs.f0 = s390x_arch_fr_t(w)\n-\t\t} else {\n-\t\t\tregs.r2 = s390x_arch_gr_t(w)\n-\t\t}\n-\n-\tcase s390x_mem_ptr:\n-\t\t// The address of the memory area was passed as a hidden\n-\t\t// parameter in %r2.  Multiple return values are always returned\n-\t\t// in an in-memory structure.\n-\t\tptr := unsafe.Pointer(uintptr(regs.r2))\n-\t\toff := uintptr(0)\n-\t\tfor i, typ := range ftyp.out {\n-\t\t\tv := out[i]\n-\t\t\toff = align(off, uintptr(typ.fieldAlign))\n-\t\t\taddr := unsafe.Pointer(uintptr(ptr) + off)\n-\t\t\tif v.flag&flagIndir == 0 && (v.kind() == Ptr || v.kind() == UnsafePointer) {\n-\t\t\t\t*(*unsafe.Pointer)(addr) = v.ptr\n-\t\t\t} else {\n-\t\t\t\tmemmove(addr, v.ptr, typ.size)\n-\t\t\t}\n-\t\t\toff += typ.size\n-\t\t}\n-\n-\tcase s390x_empty:\n-\t}\n-\n-\treturn\n-}\n-\n-// The s390x_add_stackreg function adds an argument passed on the\n-// stack that could be passed in a register.\n-func s390x_add_stackreg(in []Value, ap uintptr, rt *rtype, offset uintptr) ([]Value, uintptr) {\n-\t// If we're not already at the beginning of a stack slot, round up to\n-\t// the beginning of the next one.\n-\tap = align(ap, s390x_arch_stack_slot_align)\n-\t// If offset is > 0, the data is right aligned on the stack slot.\n-\tap += offset\n-\n-\t// We have to copy the argument onto the heap in case the\n-\t// function hangs onto the reflect.Value we pass it.\n-\tp := unsafe_New(rt)\n-\tmemmove(p, unsafe.Pointer(ap), rt.size)\n-\n-\tv := Value{rt, p, flag(rt.Kind()) | flagIndir}\n-\tin = append(in, v)\n-\tap += rt.size\n-\tap = align(ap, s390x_arch_stack_slot_align)\n-\n-\treturn in, ap\n-}\n-\n-// The s390x_add_memarg function adds an argument passed in memory.\n-func s390x_add_memarg(in []Value, ap uintptr, rt *rtype) ([]Value, uintptr) {\n-\t// If we're not already at the beginning of a stack slot,\n-\t// round up to the beginning of the next one.\n-\tap = align(ap, s390x_arch_stack_slot_align)\n-\n-\t// We have to copy the argument onto the heap in case the\n-\t// function hangs onto the reflect.Value we pass it.\n-\tp := unsafe_New(rt)\n-\tmemmove(p, *(*unsafe.Pointer)(unsafe.Pointer(ap)), rt.size)\n-\n-\tv := Value{rt, p, flag(rt.Kind()) | flagIndir}\n-\tin = append(in, v)\n-\tap += s390x_arch_stack_slot_align\n-\n-\treturn in, ap\n-}\n-\n-// The s390x_general_reg_val function returns the value of integer register GR.\n-func s390x_general_reg_val(regs *s390x_regs, gr int) uintptr {\n-\tvar r s390x_arch_gr_t\n-\tswitch gr {\n-\tcase 0:\n-\t\tr = regs.r2\n-\tcase 1:\n-\t\tr = regs.r3\n-\tcase 2:\n-\t\tr = regs.r4\n-\tcase 3:\n-\t\tr = regs.r5\n-\tcase 4:\n-\t\tr = regs.r6\n-\tdefault:\n-\t\tpanic(\"s390x_general_reg_val: bad integer register\")\n-\t}\n-\treturn uintptr(r)\n-}\n-\n-// The s390x_float_reg_val function returns the value of float register FR.\n-func s390x_float_reg_val(regs *s390x_regs, fr int) uintptr {\n-\tvar r s390x_arch_fr_t\n-\tswitch fr {\n-\tcase 0:\n-\t\tr = regs.f0\n-\tcase 1:\n-\t\tr = regs.f2\n-\tcase 2:\n-\t\tr = regs.f4\n-\tcase 3:\n-\t\tr = regs.f6\n-\tdefault:\n-\t\tpanic(\"s390x_float_reg_val: bad floating point register\")\n-\t}\n-\treturn uintptr(r)\n-}"}, {"sha": "7cc4f7f8bfd817e98af37d71b158390c96a21171", "filename": "libgo/go/reflect/value.go", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38bf819a5f995ae4621496df2324d68b9e24900f/libgo%2Fgo%2Freflect%2Fvalue.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38bf819a5f995ae4621496df2324d68b9e24900f/libgo%2Fgo%2Freflect%2Fvalue.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fvalue.go?ref=38bf819a5f995ae4621496df2324d68b9e24900f", "patch": "@@ -308,9 +308,6 @@ func (v Value) CallSlice(in []Value) []Value {\n \n var callGC bool // for testing; see TestCallMethodJump\n \n-var makeFuncStubFn = makeFuncStub\n-var makeFuncStubCode = **(**uintptr)(unsafe.Pointer(&makeFuncStubFn))\n-\n func (v Value) call(op string, in []Value) []Value {\n \t// Get function pointer, type.\n \tt := v.typ\n@@ -388,17 +385,6 @@ func (v Value) call(op string, in []Value) []Value {\n \t}\n \tnout := t.NumOut()\n \n-\t// If target is makeFuncStub, short circuit the unpack onto stack /\n-\t// pack back into []Value for the args and return values.  Just do the\n-\t// call directly.\n-\t// We need to do this here because otherwise we have a situation where\n-\t// reflect.callXX calls makeFuncStub, neither of which knows the\n-\t// layout of the args.  That's bad for precise gc & stack copying.\n-\tx := (*makeFuncImpl)(fn)\n-\tif x.code == makeFuncStubCode {\n-\t\treturn x.call(in)\n-\t}\n-\n \tif v.flag&flagMethod != 0 {\n \t\tnin++\n \t}\n@@ -1120,16 +1106,6 @@ func (v Value) Pointer() uintptr {\n \tcase Chan, Map, Ptr, UnsafePointer:\n \t\treturn uintptr(v.pointer())\n \tcase Func:\n-\t\tif v.flag&flagMethod != 0 {\n-\t\t\t// As the doc comment says, the returned pointer is an\n-\t\t\t// underlying code pointer but not necessarily enough to\n-\t\t\t// identify a single function uniquely. All method expressions\n-\t\t\t// created via reflect have the same underlying code pointer,\n-\t\t\t// so their Pointers are equal. The function used here must\n-\t\t\t// match the one used in makeMethodValue.\n-\t\t\tf := makeFuncStub\n-\t\t\treturn **(**uintptr)(unsafe.Pointer(&f))\n-\t\t}\n \t\tp := v.pointer()\n \t\t// Non-nil func value points at data block.\n \t\t// First word of data block is actual code."}, {"sha": "89da23dab1b264ff42aad0a905a77535d70ec579", "filename": "libgo/runtime/go-ffi.c", "status": "modified", "additions": 24, "deletions": 15, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38bf819a5f995ae4621496df2324d68b9e24900f/libgo%2Fruntime%2Fgo-ffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38bf819a5f995ae4621496df2324d68b9e24900f/libgo%2Fruntime%2Fgo-ffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-ffi.c?ref=38bf819a5f995ae4621496df2324d68b9e24900f", "patch": "@@ -30,8 +30,6 @@ static ffi_type *go_struct_to_ffi (const struct __go_struct_type *)\n   __attribute__ ((no_split_stack));\n static ffi_type *go_string_to_ffi (void) __attribute__ ((no_split_stack));\n static ffi_type *go_interface_to_ffi (void) __attribute__ ((no_split_stack));\n-static ffi_type *go_complex_to_ffi (ffi_type *)\n-  __attribute__ ((no_split_stack, unused));\n static ffi_type *go_type_to_ffi (const struct __go_type_descriptor *)\n   __attribute__ ((no_split_stack));\n static ffi_type *go_func_return_ffi (const struct __go_func_type *)\n@@ -155,7 +153,15 @@ go_interface_to_ffi (void)\n   return ret;\n }\n \n-/* Return an ffi_type for a Go complex type.  */\n+\n+#ifndef FFI_TARGET_HAS_COMPLEX_TYPE\n+/* If libffi hasn't been updated for this target to support complex,\n+   pretend complex is a structure.  Warning: This does not work for\n+   all ABIs.  Eventually libffi should be updated for all targets\n+   and this should go away.  */\n+\n+static ffi_type *go_complex_to_ffi (ffi_type *)\n+  __attribute__ ((no_split_stack));\n \n static ffi_type *\n go_complex_to_ffi (ffi_type *float_type)\n@@ -170,6 +176,7 @@ go_complex_to_ffi (ffi_type *float_type)\n   ret->elements[2] = NULL;\n   return ret;\n }\n+#endif\n \n /* Return an ffi_type for a type described by a\n    __go_type_descriptor.  */\n@@ -194,23 +201,25 @@ go_type_to_ffi (const struct __go_type_descriptor *descriptor)\n \treturn &ffi_type_double;\n       abort ();\n     case GO_COMPLEX64:\n-#ifdef __alpha__\n-      runtime_throw(\"the libffi library does not support Complex64 type with \"\n-\t\t    \"reflect.Call or runtime.SetFinalizer\");\n-#else\n       if (sizeof (float) == 4)\n-\treturn go_complex_to_ffi (&ffi_type_float);\n-      abort ();\n+\t{\n+#ifdef FFI_TARGET_HAS_COMPLEX_TYPE\n+\t  return &ffi_type_complex_float;\n+#else\n+\t  return go_complex_to_ffi (&ffi_type_float);\n #endif\n+\t}\n+      abort ();\n     case GO_COMPLEX128:\n-#ifdef __alpha__\n-      runtime_throw(\"the libffi library does not support Complex128 type with \"\n-\t\t    \"reflect.Call or runtime.SetFinalizer\");\n-#else\n       if (sizeof (double) == 8)\n-\treturn go_complex_to_ffi (&ffi_type_double);\n-      abort ();\n+\t{\n+#ifdef FFI_TARGET_HAS_COMPLEX_TYPE\n+\t  return &ffi_type_complex_double;\n+#else\n+\t  return go_complex_to_ffi (&ffi_type_double);\n #endif\n+\t}\n+      abort ();\n     case GO_INT16:\n       return &ffi_type_sint16;\n     case GO_INT32:"}, {"sha": "29e814a793f6e8fb0c898b073009db80a8605f7b", "filename": "libgo/runtime/go-reflect-call.c", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38bf819a5f995ae4621496df2324d68b9e24900f/libgo%2Fruntime%2Fgo-reflect-call.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38bf819a5f995ae4621496df2324d68b9e24900f/libgo%2Fruntime%2Fgo-reflect-call.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-reflect-call.c?ref=38bf819a5f995ae4621496df2324d68b9e24900f", "patch": "@@ -12,11 +12,10 @@\n #include \"go-alloc.h\"\n #include \"go-assert.h\"\n #include \"go-type.h\"\n-\n-#ifdef USE_LIBFFI\n-\n #include \"go-ffi.h\"\n \n+#if defined(USE_LIBFFI) && FFI_GO_CLOSURES\n+\n /* The functions in this file are only called from reflect_call.  As\n    reflect_call calls a libffi function, which will be compiled\n    without -fsplit-stack, it will always run with a large stack.  */\n@@ -202,11 +201,7 @@ go_set_results (const struct __go_func_type *func, unsigned char *call_result,\n \n    If IS_METHOD is true this is a call to a method expression.  The\n    first argument is the receiver.  It is described in FUNC_TYPE, but\n-   regardless of FUNC_TYPE, it is passed as a pointer.\n-\n-   If neither IS_INTERFACE nor IS_METHOD is true then we are calling a\n-   function indirectly, and we must pass a closure pointer via\n-   __go_set_closure.  The pointer to pass is simply FUNC_VAL.  */\n+   regardless of FUNC_TYPE, it is passed as a pointer.  */\n \n void\n reflect_call (const struct __go_func_type *func_type, FuncVal *func_val,\n@@ -221,9 +216,7 @@ reflect_call (const struct __go_func_type *func_type, FuncVal *func_val,\n \n   call_result = (unsigned char *) malloc (go_results_size (func_type));\n \n-  if (!is_interface && !is_method)\n-    __go_set_closure (func_val);\n-  ffi_call (&cif, func_val->fn, call_result, params);\n+  ffi_call_go (&cif, func_val->fn, call_result, params, func_val);\n \n   /* Some day we may need to free result values if RESULTS is\n      NULL.  */"}, {"sha": "43323e2587495778593d979d16c2e0d7826ea27e", "filename": "libgo/runtime/malloc.goc", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38bf819a5f995ae4621496df2324d68b9e24900f/libgo%2Fruntime%2Fmalloc.goc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38bf819a5f995ae4621496df2324d68b9e24900f/libgo%2Fruntime%2Fmalloc.goc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmalloc.goc?ref=38bf819a5f995ae4621496df2324d68b9e24900f", "patch": "@@ -84,7 +84,6 @@ runtime_mallocgc(uintptr size, uintptr typ, uint32 flag)\n \tMLink *v, *next;\n \tbyte *tiny;\n \tbool incallback;\n-\tvoid *closure;\n \n \tif(size == 0) {\n \t\t// All 0-length allocations use this pointer.\n@@ -96,10 +95,6 @@ runtime_mallocgc(uintptr size, uintptr typ, uint32 flag)\n \tm = runtime_m();\n \tg = runtime_g();\n \n-\t// We should not be called in between __go_set_closure and the\n-\t// actual function call, but cope with it if we are.\n-\tclosure = g->closure;\n-\n \tincallback = false;\n \tif(m->mcache == nil && g->ncgo > 0) {\n \t\t// For gccgo this case can occur when a cgo or SWIG function\n@@ -180,7 +175,6 @@ runtime_mallocgc(uintptr size, uintptr typ, uint32 flag)\n \t\t\t\t\tm->locks--;\n \t\t\t\t\tif(incallback)\n \t\t\t\t\t\truntime_entersyscall();\n-\t\t\t\t\tg->closure = closure;\n \t\t\t\t\treturn v;\n \t\t\t\t}\n \t\t\t}\n@@ -267,8 +261,6 @@ runtime_mallocgc(uintptr size, uintptr typ, uint32 flag)\n \tif(incallback)\n \t\truntime_entersyscall();\n \n-\tg->closure = closure;\n-\n \treturn v;\n }\n "}, {"sha": "662dd875762706b067fbc3571fba05e4a042ab0a", "filename": "libgo/runtime/mgc0.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38bf819a5f995ae4621496df2324d68b9e24900f/libgo%2Fruntime%2Fmgc0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38bf819a5f995ae4621496df2324d68b9e24900f/libgo%2Fruntime%2Fmgc0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmgc0.c?ref=38bf819a5f995ae4621496df2324d68b9e24900f", "patch": "@@ -133,8 +133,8 @@ clearpools(void)\n \n \t// clear sync.Pool's\n \tif(poolcleanup != nil) {\n-\t\t__go_set_closure(poolcleanup);\n-\t\tpoolcleanup->fn();\n+\t\t__builtin_call_with_static_chain(poolcleanup->fn(),\n+\t\t\t\t\t\t poolcleanup);\n \t}\n \n \tfor(pp=runtime_allp; (p=*pp) != nil; pp++) {"}, {"sha": "c4f27fb6bbbccd7d19c5c86ed98ffe5fa65eebea", "filename": "libgo/runtime/proc.c", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38bf819a5f995ae4621496df2324d68b9e24900f/libgo%2Fruntime%2Fproc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38bf819a5f995ae4621496df2324d68b9e24900f/libgo%2Fruntime%2Fproc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fproc.c?ref=38bf819a5f995ae4621496df2324d68b9e24900f", "patch": "@@ -3310,26 +3310,6 @@ runtime_proc_scan(struct Workbuf** wbufp, void (*enqueue1)(struct Workbuf**, Obj\n \tenqueue1(wbufp, (Obj){(byte*)&runtime_sched, sizeof runtime_sched, 0});\n }\n \n-// When a function calls a closure, it passes the closure value to\n-// __go_set_closure immediately before the function call.  When a\n-// function uses a closure, it calls __go_get_closure immediately on\n-// function entry.  This is a hack, but it will work on any system.\n-// It would be better to use the static chain register when there is\n-// one.  It is also worth considering expanding these functions\n-// directly in the compiler.\n-\n-void\n-__go_set_closure(void* v)\n-{\n-\tg->closure = v;\n-}\n-\n-void *\n-__go_get_closure(void)\n-{\n-\treturn g->closure;\n-}\n-\n // Return whether we are waiting for a GC.  This gc toolchain uses\n // preemption instead.\n bool"}, {"sha": "515ae58ff85bf02e022ffb51cbef35d6e9937620", "filename": "libgo/runtime/runtime.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38bf819a5f995ae4621496df2324d68b9e24900f/libgo%2Fruntime%2Fruntime.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38bf819a5f995ae4621496df2324d68b9e24900f/libgo%2Fruntime%2Fruntime.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fruntime.h?ref=38bf819a5f995ae4621496df2324d68b9e24900f", "patch": "@@ -195,7 +195,6 @@ struct\tLocation\n \n struct\tG\n {\n-\tvoid*\tclosure;\t// Closure value.\n \tDefer*\tdefer;\n \tPanic*\tpanic;\n \tvoid*\texception;\t// current exception being thrown\n@@ -833,9 +832,6 @@ int32 getproccount(void);\n \n #define PREFETCH(p) __builtin_prefetch(p)\n \n-void\t__go_set_closure(void*);\n-void*\t__go_get_closure(void);\n-\n bool\truntime_gcwaiting(void);\n void\truntime_badsignal(int);\n Defer*\truntime_newdefer(void);"}, {"sha": "b77ad3333d3ee58b6151a286a88511e5f47d95a7", "filename": "libgo/runtime/time.goc", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38bf819a5f995ae4621496df2324d68b9e24900f/libgo%2Fruntime%2Ftime.goc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38bf819a5f995ae4621496df2324d68b9e24900f/libgo%2Fruntime%2Ftime.goc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Ftime.goc?ref=38bf819a5f995ae4621496df2324d68b9e24900f", "patch": "@@ -237,8 +237,7 @@ timerproc(void* dummy __attribute__ ((unused)))\n \t\t\targ = t->arg;\n \t\t\tseq = t->seq;\n \t\t\truntime_unlock(&timers);\n-\t\t\t__go_set_closure(fv);\n-\t\t\tf(arg, seq);\n+\t\t\t__builtin_call_with_static_chain(f(arg, seq), fv);\n \n \t\t\t// clear f and arg to avoid leak while sleeping for next timer\n \t\t\tf = nil;"}]}