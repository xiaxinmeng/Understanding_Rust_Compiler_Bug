{"sha": "e84bf0ef66aa72228299dd92d342c4de3a37c55c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTg0YmYwZWY2NmFhNzIyMjgyOTlkZDkyZDM0MmM0ZGUzYTM3YzU1Yw==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2018-08-29T17:17:08Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2018-08-29T17:17:08Z"}, "message": "re PR middle-end/86714 (tree-ssa-forwprop.c confused by too long initializer)\n\n\tPR tree-optimization/86714\n\tPR tree-optimization/86711\n\t* builtins.c (c_strlen): Add arguments to call to string_constant.\n\t* expr.c (string_constant): Add argument.  Detect missing nul\n\tterminator and outermost declaration it's missing in.\n\t* expr.h (string_constant): Add argument.\n\t* fold-const.c (read_from_constant_string): Add arguments to call to\n\tstring_constant.\n\t(c_getstr): Likewise.\n\t* tree-ssa-forwprop.c (simplify_builtin_call): Likewise.\n\tto string_constant.\n\t* tree-ssa-strlen.c (get_stridx): Likewise.\n\n\tPR tree-optimization/86714\n\tPR tree-optimization/86711\n\t* gcc.c-torture/execute/memchr-1.c: New test.\n\t* gcc.c-torture/execute/pr86714.c: New test.\n\t* gcc.c-torture/execute/widechar-3.c: New test.\n\t* gcc.dg/strlenopt-58.c: New test.\n\nCo-Authored-By: Bernd Edlinger <bernd.edlinger@hotmail.de>\nCo-Authored-By: Jeff Law <law@redhat.com>\n\nFrom-SVN: r263963", "tree": {"sha": "fa06d2fdd65f07a2e2f5dc933d8166e57ae93a5e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fa06d2fdd65f07a2e2f5dc933d8166e57ae93a5e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e84bf0ef66aa72228299dd92d342c4de3a37c55c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e84bf0ef66aa72228299dd92d342c4de3a37c55c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e84bf0ef66aa72228299dd92d342c4de3a37c55c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e84bf0ef66aa72228299dd92d342c4de3a37c55c/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b9a0baa9f941537de5ea2c431830a8da33692d88", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9a0baa9f941537de5ea2c431830a8da33692d88", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9a0baa9f941537de5ea2c431830a8da33692d88"}], "stats": {"total": 367, "additions": 355, "deletions": 12}, "files": [{"sha": "3cf10ca500e588ce239ce9e3f10041ead0fc0af0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e84bf0ef66aa72228299dd92d342c4de3a37c55c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e84bf0ef66aa72228299dd92d342c4de3a37c55c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e84bf0ef66aa72228299dd92d342c4de3a37c55c", "patch": "@@ -1,3 +1,19 @@\n+2018-08-29  Martin Sebor  <msebor@redhat.com>\n+\t    Jeff Law  <law@redhat.com>\n+\n+\tPR tree-optimization/86714\n+\tPR tree-optimization/86711\n+\t* builtins.c (c_strlen): Add arguments to call to string_constant.\n+\t* expr.c (string_constant): Add argument.  Detect missing nul\n+\tterminator and outermost declaration it's missing in.\n+\t* expr.h (string_constant): Add argument.\n+\t* fold-const.c (read_from_constant_string): Add arguments to call to\n+\tstring_constant.\n+\t(c_getstr): Likewise.\n+\t* tree-ssa-forwprop.c (simplify_builtin_call): Likewise.\n+\tto string_constant.\n+\t* tree-ssa-strlen.c (get_stridx): Likewise.\n+\n 2018-08-29  Jan Hubicka  <jh@suse.cz>\n \n \t* tree-streamer-in.c (lto_input_ts_function_decl_tree_pointers):"}, {"sha": "c9de1e6f1f34a422eadd5f8d537296d78bba91ee", "filename": "gcc/builtins.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e84bf0ef66aa72228299dd92d342c4de3a37c55c/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e84bf0ef66aa72228299dd92d342c4de3a37c55c/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=e84bf0ef66aa72228299dd92d342c4de3a37c55c", "patch": "@@ -589,7 +589,7 @@ c_strlen (tree src, int only_value, unsigned eltsize)\n   /* Offset from the beginning of the string in bytes.  */\n   tree byteoff;\n   tree memsize;\n-  src = string_constant (src, &byteoff, &memsize);\n+  src = string_constant (src, &byteoff, &memsize, NULL);\n   if (src == 0)\n     return NULL_TREE;\n "}, {"sha": "cd5cf12fca6cf8d110177382f73684c293b73d21", "filename": "gcc/expr.c", "status": "modified", "additions": 25, "deletions": 6, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e84bf0ef66aa72228299dd92d342c4de3a37c55c/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e84bf0ef66aa72228299dd92d342c4de3a37c55c/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=e84bf0ef66aa72228299dd92d342c4de3a37c55c", "patch": "@@ -11303,12 +11303,15 @@ is_aligning_offset (const_tree offset, const_tree exp)\n /* Return the tree node if an ARG corresponds to a string constant or zero\n    if it doesn't.  If we return nonzero, set *PTR_OFFSET to the (possibly\n    non-constant) offset in bytes within the string that ARG is accessing.\n+   If NONSTR is non-null, consider valid even sequences of characters that\n+   aren't nul-terminated strings.  In that case, if ARG refers to such\n+   a sequence set *NONSTR to its declaration and clear it otherwise.\n    The type of the offset is sizetype.  If MEM_SIZE is non-zero the storage\n    size of the memory is returned.  If MEM_SIZE is zero, the string is\n    only returned when it is properly zero terminated.  */\n \n tree\n-string_constant (tree arg, tree *ptr_offset, tree *mem_size)\n+string_constant (tree arg, tree *ptr_offset, tree *mem_size, tree *nonstr)\n {\n   tree array;\n   STRIP_NOPS (arg);\n@@ -11362,7 +11365,7 @@ string_constant (tree arg, tree *ptr_offset, tree *mem_size)\n \treturn NULL_TREE;\n \n       tree offset;\n-      if (tree str = string_constant (arg0, &offset, mem_size))\n+      if (tree str = string_constant (arg0, &offset, mem_size, nonstr))\n \t{\n \t  /* Avoid pointers to arrays (see bug 86622).  */\n \t  if (POINTER_TYPE_P (TREE_TYPE (arg))\n@@ -11404,6 +11407,9 @@ string_constant (tree arg, tree *ptr_offset, tree *mem_size)\n       *ptr_offset = fold_convert (sizetype, offset);\n       if (mem_size)\n \t*mem_size = TYPE_SIZE_UNIT (TREE_TYPE (array));\n+      /* This is not strictly correct.  FIXME in follow-up patch.  */\n+      if (nonstr)\n+\t*nonstr = NULL_TREE;\n       return array;\n     }\n \n@@ -11450,22 +11456,35 @@ string_constant (tree arg, tree *ptr_offset, tree *mem_size)\n   if (!array_size || TREE_CODE (array_size) != INTEGER_CST)\n     return NULL_TREE;\n \n-  /* Avoid returning a string that doesn't fit in the array\n-     it is stored in, like\n+  /* Avoid returning an array that is unterminated because it lacks\n+     a terminating nul, like\n      const char a[4] = \"abcde\";\n-     but do handle those that fit even if they have excess\n+     but do handle those that are strings even if they have excess\n      initializers, such as in\n      const char a[4] = \"abc\\000\\000\";\n      The excess elements contribute to TREE_STRING_LENGTH()\n      but not to strlen().  */\n   unsigned HOST_WIDE_INT charsize\n     = tree_to_uhwi (TYPE_SIZE_UNIT (TREE_TYPE (TREE_TYPE (init))));\n+  /* Compute the lower bound number of elements (not bytes) in the array\n+     that the string is used to initialize.  The actual size of the array\n+     may be greater if the string is shorter, but the the important\n+     data point is whether the literal, inlcuding the terminating nul,\n+     fits the array.  */\n+  unsigned HOST_WIDE_INT array_elts\n+    = tree_to_uhwi (TYPE_SIZE_UNIT (TREE_TYPE (init))) / charsize;\n+\n+  /* Compute the string length in (wide) characters.  */\n   unsigned HOST_WIDE_INT length = TREE_STRING_LENGTH (init);\n   length = string_length (TREE_STRING_POINTER (init), charsize,\n \t\t\t  length / charsize);\n   if (mem_size)\n     *mem_size = TYPE_SIZE_UNIT (TREE_TYPE (init));\n-  else if (compare_tree_int (array_size, length + 1) < 0)\n+  if (nonstr)\n+    *nonstr = array_elts > length ? NULL_TREE : array;\n+\n+  if ((!mem_size && !nonstr)\n+      && array_elts <= length)\n     return NULL_TREE;\n \n   *ptr_offset = offset;"}, {"sha": "4177de8060b6ddfd0a8e80cb3388576dfdc112ef", "filename": "gcc/expr.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e84bf0ef66aa72228299dd92d342c4de3a37c55c/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e84bf0ef66aa72228299dd92d342c4de3a37c55c/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=e84bf0ef66aa72228299dd92d342c4de3a37c55c", "patch": "@@ -288,7 +288,7 @@ expand_normal (tree exp)\n \n /* Return the tree node and offset if a given argument corresponds to\n    a string constant.  */\n-extern tree string_constant (tree, tree *, tree * = NULL);\n+extern tree string_constant (tree, tree *, tree *, tree *);\n \n /* Two different ways of generating switch statements.  */\n extern int try_casesi (tree, tree, tree, tree, rtx, rtx, rtx, profile_probability);"}, {"sha": "bdd24c5969b9075f86a0a9efe965a324b23993c0", "filename": "gcc/fold-const.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e84bf0ef66aa72228299dd92d342c4de3a37c55c/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e84bf0ef66aa72228299dd92d342c4de3a37c55c/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=e84bf0ef66aa72228299dd92d342c4de3a37c55c", "patch": "@@ -13779,7 +13779,7 @@ fold_read_from_constant_string (tree exp)\n       location_t loc = EXPR_LOCATION (exp);\n \n       if (TREE_CODE (exp) == INDIRECT_REF)\n-\tstring = string_constant (exp1, &index);\n+\tstring = string_constant (exp1, &index, NULL, NULL);\n       else\n \t{\n \t  tree low_bound = array_ref_low_bound (exp);\n@@ -14592,7 +14592,7 @@ c_getstr (tree src, unsigned HOST_WIDE_INT *strlen /* = NULL */,\n   if (strlen)\n     *strlen = 0;\n \n-  src = string_constant (src, &offset_node);\n+  src = string_constant (src, &offset_node, NULL, NULL);\n   if (src == 0)\n     return NULL;\n "}, {"sha": "20119739b158d9630ba88584bcbb6e56cf7f4d0b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e84bf0ef66aa72228299dd92d342c4de3a37c55c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e84bf0ef66aa72228299dd92d342c4de3a37c55c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e84bf0ef66aa72228299dd92d342c4de3a37c55c", "patch": "@@ -1,3 +1,13 @@\n+2018-08-29  Martin Sebor  <msebor@redhat.com>\n+\t    Bernd Edlinger  <bernd.edlinger@hotmail.de>\n+\n+\tPR tree-optimization/86714\n+\tPR tree-optimization/86711\n+\t* gcc.c-torture/execute/memchr-1.c: New test.\n+\t* gcc.c-torture/execute/pr86714.c: New test.\n+\t* gcc.c-torture/execute/widechar-3.c: New test.\n+\t* gcc.dg/strlenopt-58.c: New test.\n+\n 2018-08-29  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/87132"}, {"sha": "ec37632299251cb842beb1fcd27b0d6664b5142c", "filename": "gcc/testsuite/gcc.c-torture/execute/memchr-1.c", "status": "added", "additions": 153, "deletions": 0, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e84bf0ef66aa72228299dd92d342c4de3a37c55c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fmemchr-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e84bf0ef66aa72228299dd92d342c4de3a37c55c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fmemchr-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fmemchr-1.c?ref=e84bf0ef66aa72228299dd92d342c4de3a37c55c", "patch": "@@ -0,0 +1,153 @@\n+/* PR tree-optimization/86711 - wrong folding of memchr\n+\n+   Verify that memchr() of arrays initialized with string literals\n+   where the nul doesn't fit in the array doesn't find the nul.  */\n+typedef __SIZE_TYPE__  size_t;\n+typedef __WCHAR_TYPE__ wchar_t;\n+\n+extern void* memchr (const void*, int, size_t);\n+\n+#define A(expr)\t\t\t\t\t\t\t\\\n+  ((expr)\t\t\t\t\t\t\t\\\n+   ? (void)0\t\t\t\t\t\t\t\\\n+   : (__builtin_printf (\"assertion failed on line %i: %s\\n\",\t\\\n+\t\t\t__LINE__, #expr),\t\t\t\\\n+      __builtin_abort ()))\n+\n+static const char c = '1';\n+static const char s1[1] = \"1\";\n+static const char s4[4] = \"1234\";\n+\n+static const char s4_2[2][4] = { \"1234\", \"5678\" };\n+static const char s5_3[3][5] = { \"12345\", \"6789\", \"01234\" };\n+\n+volatile int v0 = 0;\n+volatile int v1 = 1;\n+volatile int v2 = 2;\n+volatile int v3 = 3;\n+volatile int v4 = 3;\n+\n+void test_narrow (void)\n+{\n+  int i0 = 0;\n+  int i1 = i0 + 1;\n+  int i2 = i1 + 1;\n+  int i3 = i2 + 1;\n+  int i4 = i3 + 1;\n+\n+  A (memchr (\"\" + 1, 0, 0) == 0);\n+\n+  A (memchr (&c, 0, sizeof c) == 0);\n+  A (memchr (&c + 1, 0, sizeof c - 1) == 0);\n+  A (memchr (&c + i1, 0, sizeof c - i1) == 0);\n+  A (memchr (&c + v1, 0, sizeof c - v1) == 0);\n+\n+  A (memchr (s1, 0, sizeof s1) == 0);\n+  A (memchr (s1 + 1, 0, sizeof s1 - 1) == 0);\n+  A (memchr (s1 + i1, 0, sizeof s1 - i1) == 0);\n+  A (memchr (s1 + v1, 0, sizeof s1 - v1) == 0);\n+\n+  A (memchr (&s1, 0, sizeof s1) == 0);\n+  A (memchr (&s1 + 1, 0, sizeof s1 - 1) == 0);\n+  A (memchr (&s1 + i1, 0, sizeof s1 - i1) == 0);\n+  A (memchr (&s1 + v1, 0, sizeof s1 - v1) == 0);\n+\n+  A (memchr (&s1[0], 0, sizeof s1) == 0);\n+  A (memchr (&s1[0] + 1, 0, sizeof s1 - 1) == 0);\n+  A (memchr (&s1[0] + i1, 0, sizeof s1 - i1) == 0);\n+  A (memchr (&s1[0] + v1, 0, sizeof s1 - v1) == 0);\n+\n+  A (memchr (&s1[i0], 0, sizeof s1) == 0);\n+  A (memchr (&s1[i0] + 1, 0, sizeof s1 - 1) == 0);\n+  A (memchr (&s1[i0] + i1, 0, sizeof s1 - i1) == 0);\n+  A (memchr (&s1[i0] + v1, 0, sizeof s1 - v1) == 0);\n+\n+  A (memchr (&s1[v0], 0, sizeof s1) == 0);\n+  A (memchr (&s1[v0] + 1, 0, sizeof s1 - 1) == 0);\n+  A (memchr (&s1[v0] + i1, 0, sizeof s1 - i1) == 0);\n+  A (memchr (&s1[v0] + v1, 0, sizeof s1 - v1) == 0);\n+\n+\n+  A (memchr (s4 + i0, 0, sizeof s4 - i0) == 0);\n+  A (memchr (s4 + i1, 0, sizeof s4 - i1) == 0);\n+  A (memchr (s4 + i2, 0, sizeof s4 - i2) == 0);\n+  A (memchr (s4 + i3, 0, sizeof s4 - i3) == 0);\n+  A (memchr (s4 + i4, 0, sizeof s4 - i4) == 0);\n+\n+  A (memchr (s4 + v0, 0, sizeof s4 - v0) == 0);\n+  A (memchr (s4 + v1, 0, sizeof s4 - v1) == 0);\n+  A (memchr (s4 + v2, 0, sizeof s4 - v2) == 0);\n+  A (memchr (s4 + v3, 0, sizeof s4 - v3) == 0);\n+  A (memchr (s4 + v4, 0, sizeof s4 - v4) == 0);\n+\n+\n+  A (memchr (s4_2, 0, sizeof s4_2) == 0);\n+\n+  A (memchr (s4_2[0], 0, sizeof s4_2[0]) == 0);\n+  A (memchr (s4_2[1], 0, sizeof s4_2[1]) == 0);\n+\n+  A (memchr (s4_2[0] + 1, 0, sizeof s4_2[0] - 1) == 0);\n+  A (memchr (s4_2[1] + 2, 0, sizeof s4_2[1] - 2) == 0);\n+  A (memchr (s4_2[1] + 3, 0, sizeof s4_2[1] - 3) == 0);\n+\n+  A (memchr (s4_2[v0], 0, sizeof s4_2[v0]) == 0);\n+  A (memchr (s4_2[v0] + 1, 0, sizeof s4_2[v0] - 1) == 0);\n+\n+\n+  /* The following calls must find the nul.  */\n+  A (memchr (\"\", 0, 1) != 0);\n+  A (memchr (s5_3, 0, sizeof s5_3) == &s5_3[1][4]);\n+\n+  A (memchr (&s5_3[0][0] + i0, 0, sizeof s5_3 - i0) == &s5_3[1][4]);\n+  A (memchr (&s5_3[0][0] + i1, 0, sizeof s5_3 - i1) == &s5_3[1][4]);\n+  A (memchr (&s5_3[0][0] + i2, 0, sizeof s5_3 - i2) == &s5_3[1][4]);\n+  A (memchr (&s5_3[0][0] + i4, 0, sizeof s5_3 - i4) == &s5_3[1][4]);\n+\n+  A (memchr (&s5_3[1][i0], 0, sizeof s5_3[1] - i0) == &s5_3[1][4]);\n+}\n+\n+static const wchar_t wc = L'1';\n+static const wchar_t ws1[] = L\"1\";\n+static const wchar_t ws4[] = L\"\\x00123456\\x12005678\\x12340078\\x12345600\";\n+\n+void test_wide (void)\n+{\n+  int i0 = 0;\n+  int i1 = i0 + 1;\n+  int i2 = i1 + 1;\n+  int i3 = i2 + 1;\n+  int i4 = i3 + 1;\n+\n+  A (memchr (L\"\" + 1, 0, 0) == 0);\n+  A (memchr (&wc + 1, 0, 0) == 0);\n+  A (memchr (L\"\\x12345678\", 0, sizeof (wchar_t)) == 0);\n+\n+  const size_t nb = sizeof ws4;\n+  const size_t nwb = sizeof (wchar_t);\n+\n+  const char *pws1 = (const char*)ws1;\n+  const char *pws4 = (const char*)ws4;\n+\n+#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__\n+  A (memchr (ws1, 0, sizeof ws1) == pws1 + 1);\n+\n+  A (memchr (&ws4[0], 0, nb) == pws4 + 3);\n+  A (memchr (&ws4[1], 0, nb - 1 * nwb) == pws4 + 1 * nwb + 2);\n+  A (memchr (&ws4[2], 0, nb - 2 * nwb) == pws4 + 2 * nwb + 1);\n+  A (memchr (&ws4[3], 0, nb - 3 * nwb) == pws4 + 3 * nwb + 0);\n+#else\n+  A (memchr (ws1, 0, sizeof ws1) == pws1 + 0);\n+\n+  A (memchr (&ws4[0], 0, nb) == pws4 + 0);\n+  A (memchr (&ws4[1], 0, nb - 1 * nwb) == pws4 + 1 * nwb + 0);\n+  A (memchr (&ws4[2], 0, nb - 2 * nwb) == pws4 + 2 * nwb + 1);\n+  A (memchr (&ws4[3], 0, nb - 3 * nwb) == pws4 + 3 * nwb + 2);\n+#endif\n+}\n+\n+\n+int main ()\n+{\n+  test_narrow ();\n+  test_wide ();\n+}"}, {"sha": "3ad68522e71dbdcc167a985e8e28341a5dfad2f0", "filename": "gcc/testsuite/gcc.c-torture/execute/pr86714.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e84bf0ef66aa72228299dd92d342c4de3a37c55c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr86714.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e84bf0ef66aa72228299dd92d342c4de3a37c55c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr86714.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr86714.c?ref=e84bf0ef66aa72228299dd92d342c4de3a37c55c", "patch": "@@ -0,0 +1,26 @@\n+/* PR tree-optimization/86714 - tree-ssa-forwprop.c confused by too\n+   long initializer\n+\n+   The excessively long initializer for a[0] is undefined but this\n+   test verifies that the excess elements are not considered a part\n+   of the value of the array as a matter of QoI.  */\n+\n+const char a[2][3] = { \"1234\", \"xyz\" };\n+char b[6];\n+\n+void *pb = b;\n+\n+int main ()\n+{\n+   __builtin_memcpy (b, a, 4);\n+   __builtin_memset (b + 4, 'a', 2);\n+\n+   if (b[0] != '1' || b[1] != '2' || b[2] != '3'\n+       || b[3] != 'x' || b[4] != 'a' || b[5] != 'a')\n+     __builtin_abort ();\n+\n+   if (__builtin_memcmp (pb, \"123xaa\", 6))\n+     __builtin_abort ();\n+\n+   return 0;\n+}"}, {"sha": "0810c7dd5f4bb33ca747d68d9b7eaadd6bf06d74", "filename": "gcc/testsuite/gcc.c-torture/execute/widechar-3.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e84bf0ef66aa72228299dd92d342c4de3a37c55c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fwidechar-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e84bf0ef66aa72228299dd92d342c4de3a37c55c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fwidechar-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fwidechar-3.c?ref=e84bf0ef66aa72228299dd92d342c4de3a37c55c", "patch": "@@ -0,0 +1,26 @@\n+extern void abort (void);\n+extern void exit (int);\n+\n+static int f(char *x)\n+{\n+   return __builtin_strlen(x);\n+}\n+\n+int foo ()\n+{\n+   return f((char*)&L\"abcdef\"[0]);\n+}\n+\n+\n+int\n+main()\n+{\n+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__\n+  if (foo () != 0)\n+    abort ();\n+#elif __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__\n+  if (foo () != 1)\n+    abort ();\n+#endif\n+  exit (0);\n+}"}, {"sha": "e0e80680936183e876e055e6d0d0b17e0fba8311", "filename": "gcc/testsuite/gcc.dg/strlenopt-58.c", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e84bf0ef66aa72228299dd92d342c4de3a37c55c/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-58.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e84bf0ef66aa72228299dd92d342c4de3a37c55c/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-58.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-58.c?ref=e84bf0ef66aa72228299dd92d342c4de3a37c55c", "patch": "@@ -0,0 +1,93 @@\n+/* PR tree-optimization/86711 - wrong folding of memchr\n+\n+   Verify that calls to memchr() with constant arrays initialized\n+   with wide string literals are folded.\n+\n+   { dg-do compile }\n+   { dg-options \"-O1 -Wall -fdump-tree-optimized\" } */\n+\n+#include \"strlenopt.h\"\n+\n+typedef __WCHAR_TYPE__ wchar_t;\n+\n+extern void* memchr (const void*, int, size_t);\n+\n+#define CONCAT(x, y) x ## y\n+#define CAT(x, y) CONCAT (x, y)\n+#define FAILNAME(name) CAT (call_ ## name ##_on_line_, __LINE__)\n+\n+#define FAIL(name) do {\t\t\t\t\\\n+    extern void FAILNAME (name) (void);\t\t\\\n+    FAILNAME (name)();\t\t\t\t\\\n+  } while (0)\n+\n+/* Macro to emit a call to funcation named\n+   call_in_true_branch_not_eliminated_on_line_NNN()\n+   for each call that's expected to be eliminated.  The dg-final\n+   scan-tree-dump-time directive at the bottom of the test verifies\n+   that no such call appears in output.  */\n+#define ELIM(expr)\t\t\t\t\t\t\t\\\n+  if (!(expr)) FAIL (in_true_branch_not_eliminated); else (void)0\n+\n+#define T(s, n) ELIM (strlen (s) == n)\n+\n+\n+static const wchar_t wc = L'1';\n+static const wchar_t ws1[] = L\"1\";\n+static const wchar_t wsx[] = L\"\\x12345678\";\n+static const wchar_t ws4[] = L\"\\x00123456\\x12005678\\x12340078\\x12345600\";\n+\n+void test_wide (void)\n+{\n+  int i0 = 0;\n+  int i1 = i0 + 1;\n+  int i2 = i1 + 1;\n+  int i3 = i2 + 1;\n+  int i4 = i3 + 1;\n+\n+  ELIM (memchr (L\"\" + 1, 0, 0) == 0);\n+  ELIM (memchr (&wc + 1, 0, 0) == 0);\n+  ELIM (memchr (L\"\\x12345678\", 0, sizeof (wchar_t)) == 0);\n+\n+  const size_t nb = sizeof ws4;\n+  const size_t nwb = sizeof (wchar_t);\n+\n+  const char *pws1 = (const char*)ws1;\n+  const char *pws4 = (const char*)ws4;\n+  const char *pwsx = (const char*)wsx;\n+\n+#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__\n+  ELIM (memchr (ws1, 0, sizeof ws1) == pws1 + 1);\n+  ELIM (memchr (wsx, 0, sizeof wsx) == pwsx + sizeof *wsx);\n+\n+  ELIM (memchr (&ws4[0], 0, nb) == pws4 + 3);\n+  ELIM (memchr (&ws4[1], 0, nb - 1 * nwb) == pws4 + 1 * nwb + 2);\n+  ELIM (memchr (&ws4[2], 0, nb - 2 * nwb) == pws4 + 2 * nwb + 1);\n+  ELIM (memchr (&ws4[3], 0, nb - 3 * nwb) == pws4 + 3 * nwb + 0);\n+  ELIM (memchr (&ws4[4], 0, nb - 4 * nwb) == pws4 + 4 * nwb + 0);\n+\n+  ELIM (memchr (&ws4[i0], 0, nb) == pws4 + 3);\n+  ELIM (memchr (&ws4[i1], 0, nb - 1 * nwb) == pws4 + 1 * nwb + 2);\n+  ELIM (memchr (&ws4[i2], 0, nb - 2 * nwb) == pws4 + 2 * nwb + 1);\n+  ELIM (memchr (&ws4[i3], 0, nb - 3 * nwb) == pws4 + 3 * nwb + 0);\n+  ELIM (memchr (&ws4[i4], 0, nb - 4 * nwb) == pws4 + 4 * nwb + 0);\n+#else\n+  ELIM (memchr (ws1, 0, sizeof ws1) == pws1 + 0);\n+  ELIM (memchr (wsx, 0, sizeof wsx) == pwsx + sizeof *wsx);\n+\n+  ELIM (memchr (&ws4[0], 0, nb) == pws4 + 0);\n+  ELIM (memchr (&ws4[1], 0, nb - 1 * nwb) == pws4 + 1 * nwb + 1);\n+  ELIM (memchr (&ws4[2], 0, nb - 2 * nwb) == pws4 + 2 * nwb + 2);\n+  ELIM (memchr (&ws4[3], 0, nb - 3 * nwb) == pws4 + 3 * nwb + 3);\n+  ELIM (memchr (&ws4[4], 0, nb - 4 * nwb) == pws4 + 4 * nwb + 0);\n+\n+  ELIM (memchr (&ws4[i0], 0, nb) == pws4 + 0);\n+  ELIM (memchr (&ws4[i1], 0, nb - 1 * nwb) == pws4 + 1 * nwb + 1);\n+  ELIM (memchr (&ws4[i2], 0, nb - 2 * nwb) == pws4 + 2 * nwb + 2);\n+  ELIM (memchr (&ws4[i3], 0, nb - 3 * nwb) == pws4 + 3 * nwb + 3);\n+  ELIM (memchr (&ws4[i4], 0, nb - 4 * nwb) == pws4 + 4 * nwb + 0);\n+#endif\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"memchr\" 0 \"optimized\" } }\n+   { dg-final { scan-tree-dump-times \"call_in_true_branch_not_eliminated\" 0 \"optimized\" } } */"}, {"sha": "67133983cc31bcc74ca3e21cb37832e198367c42", "filename": "gcc/tree-ssa-forwprop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e84bf0ef66aa72228299dd92d342c4de3a37c55c/gcc%2Ftree-ssa-forwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e84bf0ef66aa72228299dd92d342c4de3a37c55c/gcc%2Ftree-ssa-forwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-forwprop.c?ref=e84bf0ef66aa72228299dd92d342c4de3a37c55c", "patch": "@@ -1290,7 +1290,7 @@ simplify_builtin_call (gimple_stmt_iterator *gsi_p, tree callee2)\n \t      lhs1 = gimple_call_lhs (stmt1);\n \t      if (!tree_fits_uhwi_p (len1))\n \t\tbreak;\n-\t      str1 = string_constant (src1, &off1);\n+\t      str1 = string_constant (src1, &off1, NULL, NULL);\n \t      if (str1 == NULL_TREE)\n \t\tbreak;\n \t      if (!tree_fits_uhwi_p (off1)"}, {"sha": "d625b940c1fd151096b45f130533ef7503a8c3e0", "filename": "gcc/tree-ssa-strlen.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e84bf0ef66aa72228299dd92d342c4de3a37c55c/gcc%2Ftree-ssa-strlen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e84bf0ef66aa72228299dd92d342c4de3a37c55c/gcc%2Ftree-ssa-strlen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-strlen.c?ref=e84bf0ef66aa72228299dd92d342c4de3a37c55c", "patch": "@@ -336,7 +336,7 @@ get_stridx (tree exp)\n \treturn idx;\n     }\n \n-  s = string_constant (exp, &o);\n+  s = string_constant (exp, &o, NULL, NULL);\n   if (s != NULL_TREE\n       && (o == NULL_TREE || tree_fits_shwi_p (o))\n       && TREE_STRING_LENGTH (s) > 0)"}]}