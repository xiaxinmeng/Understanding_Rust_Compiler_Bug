{"sha": "86397868159ba8c7ba20d56fdf49f551a512a1f1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODYzOTc4NjgxNTliYThjN2JhMjBkNTZmZGY0OWY1NTFhNTEyYTFmMQ==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2002-05-13T20:10:37Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2002-05-13T20:10:37Z"}, "message": "re PR libgcj/6389 (System.getProperty(\"\") should always throw an IllegalArgumentException)\n\n\tFixes PR libgcj/6389:\n\t* Makefile.in: Rebuilt.\n\t* Makefile.am (nat_source_files): Added natTimeZone.cc.\n\t* java/util/natTimeZone.cc: New file.\n\t* java/util/TimeZone.java (getDefaultTimeZoneId): New method.\n\t* java/lang/System.java: Merged with Classpath.\n\t* java/lang/Runtime.java: Merged with Classpath.\n\t* java/lang/natSystem.cc (setErr0): Renamed from setErr; don't run\n\tsecurity check.\n\t(setIn0): Renamed from setIn; don't run security check.\n\t(setOut0): Renamed from setOut; don't run security check.\n\t(file_encoding, getpwuid_adaptor, getSystemTimeZone,\n\tinit_properties): Moved to natRuntime.cc.\n\tMoved many includes to natRuntime.cc.\n\t(isWordsBigEndian): New method.\n\t* java/lang/natRuntime.cc: Include Long.h, also other includes\n\tpreviously in natSystem.cc.\n\t(maxMemory): New function.\n\t(exitInternal): Renamed from `_exit'.\n\t(exit): Removed.\n\t(init): Don't set finalize_on_exit.\n\t(exitInternal): Use `finalizeOnExit'.\n\t(file_encoding, getpwuid_adaptor): New functions from\n\tnatSystem.cc.\n\t(insertSystemProperties): New method, renamed from\n\tSystem::init_properties.  Don't set user.timezone.\n\t(_load): Don't call checkLink.\n\t(execInternal): New method.\n\t(availableProcessors): Likewise.\n\t(nativeGetLibname): Likewise.\n\nFrom-SVN: r53429", "tree": {"sha": "8d55a2017b3cd999dc25fd24a3e201558e07756e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8d55a2017b3cd999dc25fd24a3e201558e07756e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/86397868159ba8c7ba20d56fdf49f551a512a1f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86397868159ba8c7ba20d56fdf49f551a512a1f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86397868159ba8c7ba20d56fdf49f551a512a1f1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86397868159ba8c7ba20d56fdf49f551a512a1f1/comments", "author": null, "committer": null, "parents": [{"sha": "16133d00586de86b5d77c3b5f5833c6485ca697c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16133d00586de86b5d77c3b5f5833c6485ca697c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16133d00586de86b5d77c3b5f5833c6485ca697c"}], "stats": {"total": 2548, "additions": 1852, "deletions": 696}, "files": [{"sha": "25233a17b54a13de019b92df092b9ce849be4d4a", "filename": "libjava/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86397868159ba8c7ba20d56fdf49f551a512a1f1/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86397868159ba8c7ba20d56fdf49f551a512a1f1/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=86397868159ba8c7ba20d56fdf49f551a512a1f1", "patch": "@@ -1,3 +1,36 @@\n+2002-05-13  Tom Tromey  <tromey@redhat.com>\n+\n+\tFixes PR libgcj/6389:\n+\t* Makefile.in: Rebuilt.\n+\t* Makefile.am (nat_source_files): Added natTimeZone.cc.\n+\t* java/util/natTimeZone.cc: New file.\n+\t* java/util/TimeZone.java (getDefaultTimeZoneId): New method.\n+\t* java/lang/System.java: Merged with Classpath.\n+\t* java/lang/Runtime.java: Merged with Classpath.\n+\t* java/lang/natSystem.cc (setErr0): Renamed from setErr; don't run\n+\tsecurity check.\n+\t(setIn0): Renamed from setIn; don't run security check.\n+\t(setOut0): Renamed from setOut; don't run security check.\n+\t(file_encoding, getpwuid_adaptor, getSystemTimeZone,\n+\tinit_properties): Moved to natRuntime.cc.\n+\tMoved many includes to natRuntime.cc.\n+\t(isWordsBigEndian): New method.\n+\t* java/lang/natRuntime.cc: Include Long.h, also other includes\n+\tpreviously in natSystem.cc.\n+\t(maxMemory): New function.\n+\t(exitInternal): Renamed from `_exit'.\n+\t(exit): Removed.\n+\t(init): Don't set finalize_on_exit.\n+\t(exitInternal): Use `finalizeOnExit'.\n+\t(file_encoding, getpwuid_adaptor): New functions from\n+\tnatSystem.cc.\n+\t(insertSystemProperties): New method, renamed from\n+\tSystem::init_properties.  Don't set user.timezone.\n+\t(_load): Don't call checkLink.\n+\t(execInternal): New method.\n+\t(availableProcessors): Likewise.\n+\t(nativeGetLibname): Likewise.\n+\n 2002-05-11  Mark Wielaard  <mark@klomp.org>\n \n \t* gnu/java/text/SentenceBreakIterator.java (next): Skip all java white"}, {"sha": "53ff7519ce51ae775a642d2dac4be6794cf6460f", "filename": "libjava/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86397868159ba8c7ba20d56fdf49f551a512a1f1/libjava%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86397868159ba8c7ba20d56fdf49f551a512a1f1/libjava%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.am?ref=86397868159ba8c7ba20d56fdf49f551a512a1f1", "patch": "@@ -1783,6 +1783,7 @@ java/net/natInetAddress.cc \\\n java/net/natPlainDatagramSocketImpl.cc \\\n java/net/natPlainSocketImpl.cc \\\n java/text/natCollator.cc \\\n+java/util/natTimeZone.cc \\\n java/util/zip/natDeflater.cc \\\n java/util/zip/natInflater.cc\n "}, {"sha": "71fab9917c799ee3b065ae65b8d7749c2f4076ff", "filename": "libjava/Makefile.in", "status": "modified", "additions": 38, "deletions": 22, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86397868159ba8c7ba20d56fdf49f551a512a1f1/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86397868159ba8c7ba20d56fdf49f551a512a1f1/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=86397868159ba8c7ba20d56fdf49f551a512a1f1", "patch": "@@ -129,13 +129,19 @@ mkinstalldirs = @mkinstalldirs@\n tool_include_dir = @tool_include_dir@\n \n AUTOMAKE_OPTIONS = foreign\n-@TESTSUBDIR_TRUE@SUBDIRS = @TESTSUBDIR_TRUE@$(DIRLTDL) testsuite gcj include\n-@TESTSUBDIR_FALSE@SUBDIRS = @TESTSUBDIR_FALSE@$(DIRLTDL) gcj include\n-@USE_LIBDIR_TRUE@toolexeclibdir = @USE_LIBDIR_TRUE@$(libdir)$(MULTISUBDIR)\n-@USE_LIBDIR_FALSE@toolexeclibdir = @USE_LIBDIR_FALSE@$(toolexecdir)/lib$(MULTISUBDIR)\n-@USE_LIBDIR_FALSE@toolexecdir = @USE_LIBDIR_FALSE@$(exec_prefix)/$(target_alias)\n-@XLIB_AWT_TRUE@cond_x_ltlibrary = @XLIB_AWT_TRUE@libgcjx.la\n-@XLIB_AWT_FALSE@cond_x_ltlibrary = \n+@TESTSUBDIR_TRUE@SUBDIRS = \\\n+@TESTSUBDIR_TRUE@$(DIRLTDL) testsuite gcj include\n+@TESTSUBDIR_FALSE@SUBDIRS = \\\n+@TESTSUBDIR_FALSE@$(DIRLTDL) gcj include\n+@USE_LIBDIR_TRUE@toolexeclibdir = \\\n+@USE_LIBDIR_TRUE@$(libdir)$(MULTISUBDIR)\n+@USE_LIBDIR_FALSE@toolexeclibdir = \\\n+@USE_LIBDIR_FALSE@$(toolexecdir)/lib$(MULTISUBDIR)\n+@USE_LIBDIR_FALSE@toolexecdir = \\\n+@USE_LIBDIR_FALSE@$(exec_prefix)/$(target_alias)\n+@XLIB_AWT_TRUE@cond_x_ltlibrary = \\\n+@XLIB_AWT_TRUE@libgcjx.la\n+@XLIB_AWT_FALSE@cond_x_ltlibrary = \\\n \n toolexeclib_LTLIBRARIES = libgcj.la $(cond_x_ltlibrary)\n toolexeclib_DATA = libgcj.spec\n@@ -145,14 +151,20 @@ jar_DATA = libgcj-@gcc_version@.jar\n \n secdir = $(libdir)/security\n \n-@NATIVE_TRUE@bin_PROGRAMS = @NATIVE_TRUE@jv-convert gij rmic rmiregistry\n+@NATIVE_TRUE@bin_PROGRAMS = \\\n+@NATIVE_TRUE@jv-convert gij rmic rmiregistry\n \n bin_SCRIPTS = addr2name.awk\n-@CANADIAN_TRUE@@NULL_TARGET_TRUE@ZIP = @CANADIAN_TRUE@@NULL_TARGET_TRUE@$(MULTIBUILDTOP)../$(COMPPATH)/fastjar/jar$(EXEEXT)\n-@CANADIAN_TRUE@@NULL_TARGET_FALSE@ZIP = @CANADIAN_TRUE@@NULL_TARGET_FALSE@jar\n-@CANADIAN_FALSE@ZIP = @CANADIAN_FALSE@$(MULTIBUILDTOP)../$(COMPPATH)/fastjar/jar$(EXEEXT)\n-@CANADIAN_TRUE@GCJH = @CANADIAN_TRUE@gcjh\n-@CANADIAN_FALSE@GCJH = @CANADIAN_FALSE@$(MULTIBUILDTOP)../$(COMPPATH)/gcc/gcjh$(EXEEXT)\n+@CANADIAN_TRUE@@NULL_TARGET_TRUE@ZIP = \\\n+@CANADIAN_TRUE@@NULL_TARGET_TRUE@$(MULTIBUILDTOP)../$(COMPPATH)/fastjar/jar$(EXEEXT)\n+@CANADIAN_TRUE@@NULL_TARGET_FALSE@ZIP = \\\n+@CANADIAN_TRUE@@NULL_TARGET_FALSE@jar\n+@CANADIAN_FALSE@ZIP = \\\n+@CANADIAN_FALSE@$(MULTIBUILDTOP)../$(COMPPATH)/fastjar/jar$(EXEEXT)\n+@CANADIAN_TRUE@GCJH = \\\n+@CANADIAN_TRUE@gcjh\n+@CANADIAN_FALSE@GCJH = \\\n+@CANADIAN_FALSE@$(MULTIBUILDTOP)../$(COMPPATH)/gcc/gcjh$(EXEEXT)\n \n GCJ_WITH_FLAGS = $(GCJ) --encoding=UTF-8\n \n@@ -173,8 +185,10 @@ AM_CXXFLAGS = -fno-rtti -fnon-call-exceptions \\\n \t@LIBGCJ_CXXFLAGS@ @X_CFLAGS@ $(WARNINGS) -D_GNU_SOURCE \\\n \t-DPREFIX=\"\\\"$(prefix)\\\"\"\n \n-@USING_GCC_TRUE@AM_CFLAGS = @USING_GCC_TRUE@@LIBGCJ_CFLAGS@ $(WARNINGS)\n-@USING_GCC_FALSE@AM_CFLAGS = @USING_GCC_FALSE@@LIBGCJ_CFLAGS@\n+@USING_GCC_TRUE@AM_CFLAGS = \\\n+@USING_GCC_TRUE@@LIBGCJ_CFLAGS@ $(WARNINGS)\n+@USING_GCC_FALSE@AM_CFLAGS = \\\n+@USING_GCC_FALSE@@LIBGCJ_CFLAGS@\n \n JCFLAGS = -g\n JC1FLAGS = @LIBGCJ_JAVAFLAGS@ $(GCJFLAGS)\n@@ -257,7 +271,8 @@ extra_headers = java/lang/Object.h java/lang/Class.h\n \n NM = nm\n \n-@NATIVE_TRUE@@MAINTAINER_MODE_TRUE@noinst_PROGRAMS = @NATIVE_TRUE@@MAINTAINER_MODE_TRUE@gen-from-JIS\n+@NATIVE_TRUE@@MAINTAINER_MODE_TRUE@noinst_PROGRAMS = \\\n+@NATIVE_TRUE@@MAINTAINER_MODE_TRUE@gen-from-JIS\n \n CONVERT_DIR = gnu/gcj/convert\n \n@@ -1544,6 +1559,7 @@ java/net/natInetAddress.cc \\\n java/net/natPlainDatagramSocketImpl.cc \\\n java/net/natPlainSocketImpl.cc \\\n java/text/natCollator.cc \\\n+java/util/natTimeZone.cc \\\n java/util/zip/natDeflater.cc \\\n java/util/zip/natInflater.cc\n \n@@ -1694,8 +1710,8 @@ java/lang/ref/natReference.lo java/lang/reflect/natArray.lo \\\n java/lang/reflect/natConstructor.lo java/lang/reflect/natField.lo \\\n java/lang/reflect/natMethod.lo java/net/natInetAddress.lo \\\n java/net/natPlainDatagramSocketImpl.lo java/net/natPlainSocketImpl.lo \\\n-java/text/natCollator.lo java/util/zip/natDeflater.lo \\\n-java/util/zip/natInflater.lo\n+java/text/natCollator.lo java/util/natTimeZone.lo \\\n+java/util/zip/natDeflater.lo java/util/zip/natInflater.lo\n libgcjx_la_OBJECTS =  gnu/gcj/xlib/natClip.lo \\\n gnu/gcj/xlib/natColormap.lo gnu/gcj/xlib/natDisplay.lo \\\n gnu/gcj/xlib/natDrawable.lo gnu/gcj/xlib/natFont.lo \\\n@@ -1739,7 +1755,7 @@ libgcj-test.spec.in libgcj.spec.in\n \n DISTFILES = $(DIST_COMMON) $(SOURCES) $(HEADERS) $(TEXINFOS) $(EXTRA_DIST)\n \n-TAR = gtar\n+TAR = tar\n GZIP_ENV = --best\n DIST_SUBDIRS =  @DIRLTDL@ testsuite gcj include @DIRLTDL@ gcj include\n DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n@@ -2548,8 +2564,8 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/java/util/jar/JarException.P .deps/java/util/jar/JarFile.P \\\n .deps/java/util/jar/JarInputStream.P \\\n .deps/java/util/jar/JarOutputStream.P .deps/java/util/jar/Manifest.P \\\n-.deps/java/util/zip/Adler32.P .deps/java/util/zip/CRC32.P \\\n-.deps/java/util/zip/CheckedInputStream.P \\\n+.deps/java/util/natTimeZone.P .deps/java/util/zip/Adler32.P \\\n+.deps/java/util/zip/CRC32.P .deps/java/util/zip/CheckedInputStream.P \\\n .deps/java/util/zip/CheckedOutputStream.P \\\n .deps/java/util/zip/Checksum.P \\\n .deps/java/util/zip/DataFormatException.P \\\n@@ -3040,7 +3056,7 @@ distdir: $(DISTFILES)\n \t@for file in $(DISTFILES); do \\\n \t  d=$(srcdir); \\\n \t  if test -d $$d/$$file; then \\\n-\t    cp -pr $$d/$$file $(distdir)/$$file; \\\n+\t    cp -pr $$/$$file $(distdir)/$$file; \\\n \t  else \\\n \t    test -f $(distdir)/$$file \\\n \t    || ln $$d/$$file $(distdir)/$$file 2> /dev/null \\"}, {"sha": "65f73a337befedd75b6fbbd06c4bf50ebd144777", "filename": "libjava/java/lang/Runtime.java", "status": "modified", "additions": 725, "deletions": 87, "changes": 812, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86397868159ba8c7ba20d56fdf49f551a512a1f1/libjava%2Fjava%2Flang%2FRuntime.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86397868159ba8c7ba20d56fdf49f551a512a1f1/libjava%2Fjava%2Flang%2FRuntime.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FRuntime.java?ref=86397868159ba8c7ba20d56fdf49f551a512a1f1", "patch": "@@ -1,147 +1,785 @@\n-// Runtime.java - Runtime class.\n+/* Runtime.java -- access to the VM process\n+   Copyright (C) 1998, 2002 Free Software Foundation\n \n-/* Copyright (C) 1998, 1999, 2000, 2001  Free Software Foundation\n+This file is part of GNU Classpath.\n \n-   This file is part of libgcj.\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n \n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n \n package java.lang;\n \n-import java.io.IOException;\n+import java.io.File;\n import java.io.InputStream;\n+import java.io.IOException;\n import java.io.OutputStream;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Properties;\n+import java.util.Set;\n import java.util.StringTokenizer;\n \n /**\n- * @author Tom Tromey <tromey@cygnus.com>\n- * @date August 27, 1998 \n+ * Runtime represents the Virtual Machine.\n+ *\n+ * @author John Keiser\n+ * @author Eric Blake <ebb9@email.byu.edu>\n+ * @status still missing 1.4 functionality\n  */\n-\n-/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n- * \"The Java Language Specification\", ISBN 0-201-63451-1\n- * plus online API docs for JDK 1.2 beta from http://www.javasoft.com.\n- * Status:  All 1.1 methods exist.  exec() is not fully implemented.\n- */\n-\n+// No idea why this class isn't final, since you can't build a subclass!\n public class Runtime\n {\n-  public Process exec (String prog) throws IOException\n+  /**\n+   * The library path, to search when loading libraries. We can also safely use\n+   * this as a lock for synchronization.\n+   */\n+  private final String[] libpath;\n+\n+  /**\n+   * The current security manager. This is located here instead of in\n+   * Runtime, to avoid security problems, as well as bootstrap issues.\n+   * Make sure to access it in a thread-safe manner; it is package visible\n+   * to avoid overhead in java.lang.\n+   */\n+  static SecurityManager securityManager;\n+\n+  /**\n+   * The default properties defined by the system. This is likewise located\n+   * here instead of in Runtime, to avoid bootstrap issues; it is package\n+   * visible to avoid overhead in java.lang. Note that System will add a\n+   * few more properties to this collection, but that after that, it is\n+   * treated as read-only.\n+   *\n+   * No matter what class you start initialization with, it defers to the\n+   * superclass, therefore Object.<clinit> will be the first Java code\n+   * executed. From there, the bootstrap sequence, up to the point that\n+   * native libraries are loaded (as of March 24, when I traced this\n+   * manually) is as follows:\n+   *\n+   * Object.<clinit> uses a String literal, possibly triggering initialization\n+   *  String.<clinit> calls WeakHashMap.<init>, triggering initialization\n+   *   AbstractMap, WeakHashMap, WeakHashMap$1 have no dependencies\n+   *  String.<clinit> calls CaseInsensitiveComparator.<init>, triggering\n+   *      initialization\n+   *   CaseInsensitiveComparator has no dependencies\n+   * Object.<clinit> calls System.loadLibrary, triggering initialization\n+   *  System.<clinit> calls System.loadLibrary\n+   *  System.loadLibrary calls Runtime.getRuntime, triggering initialization\n+   *   Runtime.<clinit> calls Properties.<init>, triggering initialization\n+   *    Dictionary, Hashtable, and Properties have no dependencies\n+   *   Runtime.<clinit> calls insertSystemProperties; the VM must make sure\n+   *      that there are not any harmful dependencies\n+   *   Runtime.<clinit> calls Runtime.<init>\n+   *    Runtime.<init> calls StringTokenizer.<init>, triggering initialization\n+   *     StringTokenizer has no dependencies\n+   *  System.loadLibrary calls Runtime.loadLibrary\n+   *   Runtime.loadLibrary should be able to load the library, although it\n+   *       will probably set off another string of initializations from\n+   *       ClassLoader first\n+   */\n+  static Properties defaultProperties = new Properties();\n+  static\n   {\n-    return exec (prog, null);\n+    insertSystemProperties(defaultProperties);\n   }\n \n-  public Process exec (String prog, String[] envp) throws IOException\n+  /**\n+   * The thread that started the exit sequence. Access to this field must\n+   * be thread-safe; lock on libpath to avoid deadlock with user code.\n+   * <code>runFinalization()</code> may want to look at this to see if ALL\n+   * finalizers should be run, because the virtual machine is about to halt.\n+   */\n+  private Thread exitSequence;\n+\n+  /**\n+   * All shutdown hooks. This is initialized lazily, and set to null once all\n+   * shutdown hooks have run. Access to this field must be thread-safe; lock\n+   * on libpath to avoid deadlock with user code.\n+   */\n+  private Set shutdownHooks;\n+\n+  /** True if we should finalize on exit.  */\n+  private boolean finalizeOnExit;\n+\n+  /**\n+   * The one and only runtime instance. This must appear after the default\n+   * properties have been initialized by the VM.\n+   */\n+  private static final Runtime current = new Runtime();\n+\n+  /**\n+   * Not instantiable by a user, this should only create one instance.\n+   */\n+  private Runtime()\n   {\n-    StringTokenizer st = new StringTokenizer(prog);\n-    String[] a = new String[st.countTokens ()];\n-    for (int i = 0; i < a.length; i++)\n-      a[i] = st.nextToken ();\n-    return exec (a, envp);\n+    if (current != null)\n+      throw new InternalError(\"Attempt to recreate Runtime\");\n+\n+    // We don't use libpath in the libgcj implementation.  We still\n+    // set it to something to allow the various synchronizations to\n+    // work.\n+    libpath = new String[0];\n+\n+    init ();\n   }\n \n-  public Process exec (String[] progarray) throws IOException\n+  /**\n+   * Get the current Runtime object for this JVM. This is necessary to access\n+   * the many instance methods of this class.\n+   *\n+   * @return the current Runtime object\n+   */\n+  public static Runtime getRuntime()\n   {\n-    return exec (progarray, null);\n+    return current;\n   }\n \n-  public Process exec (String[] progarray, String[] envp) throws IOException\n+  /**\n+   * Exit the Java runtime. This method will either throw a SecurityException\n+   * or it will never return. The status code is returned to the system; often\n+   * a non-zero status code indicates an abnormal exit. Of course, there is a\n+   * security check, <code>checkExit(status)</code>.\n+   *\n+   * <p>First, all shutdown hooks are run, in unspecified order, and\n+   * concurrently. Next, if finalization on exit has been enabled, all pending\n+   * finalizers are run. Finally, the system calls <code>halt</code>.\n+   *\n+   * <p>If this is run a second time after shutdown has already started, there\n+   * are two actions. If shutdown hooks are still executing, it blocks\n+   * indefinitely. Otherwise, if the status is nonzero it halts immediately;\n+   * if it is zero, it blocks indefinitely. This is typically called by\n+   * <code>System.exit</code>.\n+   *\n+   * @param status the status to exit with\n+   * @throws SecurityException if permission is denied\n+   * @see #addShutdownHook(Thread)\n+   * @see #runFinalizersOnExit(boolean)\n+   * @see #runFinalization()\n+   * @see #halt(int)\n+   */\n+  public void exit(int status)\n   {\n-    SecurityManager s = System.getSecurityManager();\n-    if (s != null)\n-      s.checkExec(progarray[0]);\n-    return new ConcreteProcess (progarray, envp);\n+    SecurityManager sm = securityManager; // Be thread-safe!\n+    if (sm != null)\n+      sm.checkExit(status);\n+    boolean first = false;\n+    synchronized (libpath) // Synch on libpath, not this, to avoid deadlock.\n+      {\n+        if (exitSequence == null)\n+          {\n+            first = true;\n+            exitSequence = Thread.currentThread();\n+            if (shutdownHooks != null)\n+              {\n+                Iterator i = shutdownHooks.iterator();\n+                while (i.hasNext()) // Start all shutdown hooks.\n+                  try\n+                    {\n+                      ((Thread) i.next()).start();\n+                    }\n+                  catch (IllegalThreadStateException e)\n+                    {\n+                      i.remove();\n+                    }\n+              }\n+          }\n+      }\n+    if (first)\n+      {\n+        if (shutdownHooks != null)\n+          {\n+            // Check progress of all shutdown hooks. As a hook completes,\n+            // remove it from the set. If a hook calls exit, it removes\n+            // itself from the set, then waits indefinitely on the\n+            // exitSequence thread. Once the set is empty, set it to null to\n+            // signal all finalizer threads that halt may be called.\n+            while (! shutdownHooks.isEmpty())\n+              {\n+                Thread[] hooks;\n+                synchronized (libpath)\n+                  {\n+                    hooks = new Thread[shutdownHooks.size()];\n+                    shutdownHooks.toArray(hooks);\n+                  }\n+                for (int i = hooks.length; --i >= 0; )\n+                  if (! hooks[i].isAlive())\n+                    synchronized (libpath)\n+                      {\n+                        shutdownHooks.remove(hooks[i]);\n+                      }\n+                try\n+                  {\n+                    exitSequence.sleep(1); // Give other threads a chance.\n+                  }\n+                catch (InterruptedException e)\n+                  {\n+                    // Ignore, the next loop just starts sooner.\n+                  }\n+              }\n+            synchronized (libpath)\n+              {\n+                shutdownHooks = null;\n+              }\n+          }\n+        // XXX Right now, it is the VM that knows whether runFinalizersOnExit\n+        // is true; so the VM must look at exitSequence to decide whether\n+        // this should be run on every object.\n+        runFinalization();\n+      }\n+    else\n+      synchronized (libpath)\n+        {\n+          if (shutdownHooks != null)\n+            {\n+              shutdownHooks.remove(Thread.currentThread());\n+              status = 0; // Change status to enter indefinite wait.\n+            }\n+        }\n+    \n+    if (first || status > 0)\n+      halt(status);\n+    while (true)\n+      try\n+        {\n+          exitSequence.join();\n+        }\n+      catch (InterruptedException e)\n+        {\n+          // Ignore, we've suspended indefinitely to let all shutdown\n+          // hooks complete, and to let any non-zero exits through, because\n+          // this is a duplicate call to exit(0).\n+        }\n   }\n \n-  private final static void checkExit (int status)\n+  /**\n+   * Register a new shutdown hook. This is invoked when the program exits\n+   * normally (because all non-daemon threads ended, or because\n+   * <code>System.exit</code> was invoked), or when the user terminates\n+   * the virtual machine (such as by typing ^C, or logging off). There is\n+   * a security check to add hooks,\n+   * <code>RuntimePermission(\"shutdownHooks\")<code>.\n+   *\n+   * <p>The hook must be an initialized, but unstarted Thread. The threads\n+   * are run concurrently, and started in an arbitrary order; and user\n+   * threads or daemons may still be running. Once shutdown hooks have\n+   * started, they must all complete, or else you must use <code>halt</code>,\n+   * to actually finish the shutdown sequence. Attempts to modify hooks\n+   * after shutdown has started result in IllegalStateExceptions.\n+   *\n+   * <p>It is imperative that you code shutdown hooks defensively, as you\n+   * do not want to deadlock, and have no idea what other hooks will be\n+   * running concurrently. It is also a good idea to finish quickly, as the\n+   * virtual machine really wants to shut down!\n+   *\n+   * <p>There are no guarantees that such hooks will run, as there are ways\n+   * to forcibly kill a process. But in such a drastic case, shutdown hooks\n+   * would do little for you in the first place.\n+   *\n+   * @param hook an initialized, unstarted Thread\n+   * @throws IllegalArgumentException if the hook is already registered or run\n+   * @throws IllegalStateException if the virtual machine is already in\n+   *         the shutdown sequence\n+   * @throws SecurityException if permission is denied\n+   * @since 1.3\n+   * @see #removeShutdownHook(Thread)\n+   * @see #exit(int)\n+   * @see #halt(int)\n+   */\n+  public void addShutdownHook(Thread hook)\n   {\n-    SecurityManager s = System.getSecurityManager();\n-    if (s != null)\n-      s.checkExit(status);\n+    SecurityManager sm = securityManager; // Be thread-safe!\n+    if (sm != null)\n+      sm.checkPermission(new RuntimePermission(\"shutdownHooks\"));\n+    if (hook.isAlive() || hook.getThreadGroup() == null)\n+      throw new IllegalArgumentException();\n+    synchronized (libpath)\n+      {\n+        if (exitSequence != null)\n+          throw new IllegalStateException();\n+        if (shutdownHooks == null)\n+          shutdownHooks = new HashSet(); // Lazy initialization.\n+        if (! shutdownHooks.add(hook))\n+          throw new IllegalArgumentException();\n+      }\n   }\n \n-  public native void exit (int status);\n-  \n-  // Shutdown the runtime without a SecurityManager check. libgcj uses this \n-  // exit function internally.\n-  final native void _exit (int status);\n+  /**\n+   * De-register a shutdown hook. As when you registered it, there is a\n+   * security check to remove hooks,\n+   * <code>RuntimePermission(\"shutdownHooks\")<code>.\n+   *\n+   * @param hook the hook to remove\n+   * @return true if the hook was successfully removed, false if it was not\n+   *         registered in the first place\n+   * @throws IllegalStateException if the virtual machine is already in\n+   *         the shutdown sequence\n+   * @throws SecurityException if permission is denied\n+   * @since 1.3\n+   * @see #addShutdownHook(Thread)\n+   * @see #exit(int)\n+   * @see #halt(int)\n+   */\n+  public boolean removeShutdownHook(Thread hook)\n+  {\n+    SecurityManager sm = securityManager; // Be thread-safe!\n+    if (sm != null)\n+      sm.checkPermission(new RuntimePermission(\"shutdownHooks\"));\n+    synchronized (libpath)\n+      {\n+        if (exitSequence != null)\n+          throw new IllegalStateException();\n+        if (shutdownHooks != null)\n+          return shutdownHooks.remove(hook);\n+      }\n+    return false;\n+  }\n \n-  public native long freeMemory ();\n-  public native void gc ();\n+  /**\n+   * Forcibly terminate the virtual machine. This call never returns. It is\n+   * much more severe than <code>exit</code>, as it bypasses all shutdown\n+   * hooks and initializers. Use caution in calling this! Of course, there is\n+   * a security check, <code>checkExit(status)</code>.\n+   *\n+   * @param status the status to exit with\n+   * @throws SecurityException if permission is denied\n+   * @since 1.3\n+   * @see #exit(int)\n+   * @see #addShutdownHook(Thread)\n+   */\n+  public void halt(int status)\n+  {\n+    SecurityManager sm = securityManager; // Be thread-safe!\n+    if (sm != null)\n+      sm.checkExit(status);\n+    exitInternal(status);\n+  }\n \n-  // Deprecated in 1.1.  We implement what the JCL book says.\n-  public InputStream getLocalizedInputStream (InputStream in)\n+  /**\n+   * Tell the VM to run the finalize() method on every single Object before\n+   * it exits.  Note that the JVM may still exit abnormally and not perform\n+   * this, so you still don't have a guarantee. And besides that, this is\n+   * inherently unsafe in multi-threaded code, as it may result in deadlock\n+   * as multiple threads compete to manipulate objects. This value defaults to\n+   * <code>false</code>. There is a security check, <code>checkExit(0)</code>.\n+   *\n+   * @param finalizeOnExit whether to finalize all Objects on exit\n+   * @throws SecurityException if permission is denied\n+   * @see #exit(int)\n+   * @see #gc()\n+   * @since 1.1\n+   * @deprecated never rely on finalizers to do a clean, thread-safe,\n+   *             mop-up from your code\n+   */\n+  public static void runFinalizersOnExit(boolean finalizeOnExit)\n   {\n-    return in;\n+    SecurityManager sm = securityManager; // Be thread-safe!\n+    if (sm != null)\n+      sm.checkExit(0);\n+    current.finalizeOnExit = finalizeOnExit;\n   }\n \n-  // Deprecated in 1.1.  We implement what the JCL book says.\n-  public OutputStream getLocalizedOutputStream (OutputStream out)\n+  /**\n+   * Create a new subprocess with the specified command line. Calls\n+   * <code>exec(cmdline, null, null)<code>. A security check is performed,\n+   * <code>checkExec</code>.\n+   *\n+   * @param cmdline the command to call\n+   * @return the Process object\n+   * @throws SecurityException if permission is denied\n+   * @throws IOException if an I/O error occurs\n+   * @throws NullPointerException if cmdline is null\n+   * @throws IndexOutOfBoundsException if cmdline is \"\"\n+   */\n+  public Process exec(String cmdline) throws IOException\n   {\n-    return out;\n+    return exec(cmdline, null, null);\n   }\n \n-  public static Runtime getRuntime ()\n+  /**\n+   * Create a new subprocess with the specified command line and environment.\n+   * If the environment is null, the process inherits the environment of\n+   * this process. Calls <code>exec(cmdline, env, null)</code>. A security\n+   * check is performed, <code>checkExec</code>.\n+   *\n+   * @param cmdline the command to call\n+   * @param env the environment to use, in the format name=value\n+   * @return the Process object\n+   * @throws SecurityException if permission is denied\n+   * @throws IOException if an I/O error occurs\n+   * @throws NullPointerException if cmdline is null, or env has null entries\n+   * @throws IndexOutOfBoundsException if cmdline is \"\"\n+   */\n+  public Process exec(String cmdline, String[] env) throws IOException\n   {\n-    return self;\n+    return exec(cmdline, env, null);\n   }\n \n-  private final void checkLink (String lib)\n+  /**\n+   * Create a new subprocess with the specified command line, environment, and\n+   * working directory. If the environment is null, the process inherits the\n+   * environment of this process. If the directory is null, the process uses\n+   * the current working directory. This splits cmdline into an array, using\n+   * the default StringTokenizer, then calls\n+   * <code>exec(cmdArray, env, dir)</code>. A security check is performed,\n+   * <code>checkExec</code>.\n+   *\n+   * @param cmdline the command to call\n+   * @param env the environment to use, in the format name=value\n+   * @param dir the working directory to use\n+   * @return the Process object\n+   * @throws SecurityException if permission is denied\n+   * @throws IOException if an I/O error occurs\n+   * @throws NullPointerException if cmdline is null, or env has null entries\n+   * @throws IndexOutOfBoundsException if cmdline is \"\"\n+   * @since 1.3\n+   */\n+  public Process exec(String cmdline, String[] env, File dir)\n+    throws IOException\n   {\n-    if (lib == null)\n-      throw new NullPointerException ();\n-    SecurityManager s = System.getSecurityManager();\n-    if (s != null)\n-      s.checkLink(lib);\n+    StringTokenizer t = new StringTokenizer(cmdline);\n+    String[] cmd = new String[t.countTokens()];\n+    for (int i = 0; i < cmd.length; i++)\n+      cmd[i] = t.nextToken();\n+    return exec(cmd, env, dir);\n   }\n \n-  private native void _load (String pathname, boolean do_search);\n+  /**\n+   * Create a new subprocess with the specified command line, already\n+   * tokenized. Calls <code>exec(cmd, null, null)</code>. A security check\n+   * is performed, <code>checkExec</code>.\n+   *\n+   * @param cmd the command to call\n+   * @return the Process object\n+   * @throws SecurityException if permission is denied\n+   * @throws IOException if an I/O error occurs\n+   * @throws NullPointerException if cmd is null, or has null entries\n+   * @throws IndexOutOfBoundsException if cmd is length 0\n+   */\n+  public Process exec(String[] cmd) throws IOException\n+  {\n+    return exec(cmd, null, null);\n+  }\n \n-  public void load (String pathname)\n+  /**\n+   * Create a new subprocess with the specified command line, already\n+   * tokenized, and specified environment. If the environment is null, the\n+   * process inherits the environment of this process. Calls\n+   * <code>exec(cmd, env, null)</code>. A security check is performed,\n+   * <code>checkExec</code>.\n+   *\n+   * @param cmd the command to call\n+   * @param env the environment to use, in the format name=value\n+   * @return the Process object\n+   * @throws SecurityException if permission is denied\n+   * @throws IOException if an I/O error occurs\n+   * @throws NullPointerException if cmd is null, or cmd or env has null\n+   *         entries\n+   * @throws IndexOutOfBoundsException if cmd is length 0\n+   */\n+  public Process exec(String[] cmd, String[] env) throws IOException\n   {\n-    _load (pathname, false);\n+    return exec(cmd, env, null);\n   }\n \n-  public void loadLibrary (String libname)\n+  /**\n+   * Create a new subprocess with the specified command line, already\n+   * tokenized, and the specified environment and working directory. If the\n+   * environment is null, the process inherits the environment of this\n+   * process. If the directory is null, the process uses the current working\n+   * directory. A security check is performed, <code>checkExec</code>.\n+   *\n+   * @param cmd the command to call\n+   * @param env the environment to use, in the format name=value\n+   * @param dir the working directory to use\n+   * @return the Process object\n+   * @throws SecurityException if permission is denied\n+   * @throws IOException if an I/O error occurs\n+   * @throws NullPointerException if cmd is null, or cmd or env has null\n+   *         entries\n+   * @throws IndexOutOfBoundsException if cmd is length 0\n+   * @since 1.3\n+   * @XXX Ignores dir, for now\n+   */\n+  public Process exec(String[] cmd, String[] env, File dir)\n+    throws IOException\n   {\n-    _load (libname, true);\n+    SecurityManager sm = securityManager; // Be thread-safe!\n+    if (sm != null)\n+      sm.checkExec(cmd[0]);\n+    if (env == null)\n+      env = new String[0];\n+    //XXX Should be:    return execInternal(cmd, env, dir);\n+    return execInternal(cmd, env);\n   }\n \n-  // This is a helper function for the ClassLoader which can load\n-  // compiled libraries.  Returns true if library (which is just the\n-  // base name -- path searching is done by this function) was loaded,\n-  // false otherwise.\n-  native boolean loadLibraryInternal (String libname);\n+  /**\n+   * Returns the number of available processors currently available to the\n+   * virtual machine. This number may change over time; so a multi-processor\n+   * program want to poll this to determine maximal resource usage.\n+   *\n+   * @return the number of processors available, at least 1\n+   */\n+  public native int availableProcessors();\n+\n+  /**\n+   * Find out how much memory is still free for allocating Objects on the heap.\n+   *\n+   * @return the number of bytes of free memory for more Objects\n+   */\n+  public native long freeMemory();\n+\n+  /**\n+   * Find out how much memory total is available on the heap for allocating\n+   * Objects.\n+   *\n+   * @return the total number of bytes of memory for Objects\n+   */\n+  public native long totalMemory();\n+\n+  /**\n+   * Returns the maximum amount of memory the virtual machine can attempt to\n+   * use. This may be <code>Long.MAX_VALUE</code> if there is no inherent\n+   * limit (or if you really do have a 8 exabyte memory!).\n+   *\n+   * @return the maximum number of bytes the virtual machine will attempt\n+   *         to allocate\n+   */\n+  public native long maxMemory();\n \n-  public native void runFinalization ();\n+  /**\n+   * Run the garbage collector. This method is more of a suggestion than\n+   * anything. All this method guarantees is that the garbage collector will\n+   * have \"done its best\" by the time it returns. Notice that garbage\n+   * collection takes place even without calling this method.\n+   */\n+  public native void gc();\n \n-  // This method is static in JDK 1.1, but isn't listed as static in\n-  // the books.  It is marked as static in the 1.2 docs.\n-  public static void runFinalizersOnExit (boolean run)\n+  /**\n+   * Run finalization on all Objects that are waiting to be finalized. Again,\n+   * a suggestion, though a stronger one than {@link #gc()}. This calls the\n+   * <code>finalize</code> method of all objects waiting to be collected.\n+   *\n+   * @see #finalize()\n+   */\n+  public native void runFinalization();\n+\n+  /**\n+   * Tell the VM to trace every bytecode instruction that executes (print out\n+   * a trace of it).  No guarantees are made as to where it will be printed,\n+   * and the VM is allowed to ignore this request.\n+   *\n+   * @param on whether to turn instruction tracing on\n+   */\n+  public native void traceInstructions(boolean on);\n+\n+  /**\n+   * Tell the VM to trace every method call that executes (print out a trace\n+   * of it).  No guarantees are made as to where it will be printed, and the\n+   * VM is allowed to ignore this request.\n+   *\n+   * @param on whether to turn method tracing on\n+   */\n+  public native void traceMethodCalls(boolean on);\n+\n+  /**\n+   * Load a native library using the system-dependent filename. This is similar\n+   * to loadLibrary, except the only name mangling done is inserting \"_g\"\n+   * before the final \".so\" if the VM was invoked by the name \"java_g\". There\n+   * may be a security check, of <code>checkLink</code>.\n+   *\n+   * @param filename the file to load\n+   * @throws SecurityException if permission is denied\n+   * @throws UnsatisfiedLinkError if the library is not found\n+   */\n+  public void load(String filename)\n   {\n-    // The status we pass to the security check is unspecified.\n-    checkExit (0);\n-    self.finalize_on_exit = run;\n+    SecurityManager sm = securityManager; // Be thread-safe!\n+    if (sm != null)\n+      sm.checkLink(filename);\n+    _load(filename, false);\n   }\n \n-  public native long totalMemory ();\n-  public native void traceInstructions (boolean on);\n-  public native void traceMethodCalls (boolean on);\n+  /**\n+   * Load a native library using a system-independent \"short name\" for the\n+   * library.  It will be transformed to a correct filename in a\n+   * system-dependent manner (for example, in Windows, \"mylib\" will be turned\n+   * into \"mylib.dll\").  This is done as follows: if the context that called\n+   * load has a ClassLoader cl, then <code>cl.findLibrary(libpath)</code> is\n+   * used to convert the name. If that result was null, or there was no class\n+   * loader, this searches each directory of the system property\n+   * <code>java.library.path</code> for a file named\n+   * <code>System.mapLibraryName(libname)</code>. There may be a security\n+   * check, of <code>checkLink</code>.\n+   *\n+   * @param filename the file to load\n+   * @throws SecurityException if permission is denied\n+   * @throws UnsatisfiedLinkError if the library is not found\n+   * @see System#mapLibraryName(String)\n+   * @see ClassLoader#findLibrary(String)\n+   */\n+  public void loadLibrary(String libname)\n+  {\n+    // This is different from the Classpath implementation, but I\n+    // believe it is more correct.\n+    SecurityManager sm = securityManager; // Be thread-safe!\n+    if (sm != null)\n+      sm.checkLink(libname);\n+    _load(libname, false);\n+  }\n \n-  // A helper for the constructor.\n-  private final native void init ();\n+  /**\n+   * Return a localized version of this InputStream, meaning all characters\n+   * are localized before they come out the other end.\n+   *\n+   * @param in the stream to localize\n+   * @return the localized stream\n+   * @deprecated <code>InputStreamReader</code> is the preferred way to read\n+   *             local encodings\n+   */\n+  public InputStream getLocalizedInputStream(InputStream in)\n+  {\n+    return in;\n+  }\n \n-  // The sole constructor.\n-  private Runtime ()\n+  /**\n+   * Return a localized version of this OutputStream, meaning all characters\n+   * are localized before they are sent to the other end.\n+   *\n+   * @param out the stream to localize\n+   * @return the localized stream\n+   * @deprecated <code>OutputStreamWriter</code> is the preferred way to write\n+   *             local encodings\n+   */\n+  public OutputStream getLocalizedOutputStream(OutputStream out)\n   {\n-    init ();\n+    return out;\n   }\n \n-  // Private data.\n-  private static Runtime self = new Runtime ();\n-  // FIXME: for now this can't be static.  If it is, our compiler will\n-  // mark it as local, and it will be inaccessible to natRuntime.cc.\n-  private boolean finalize_on_exit;\n-}\n+  /**\n+   * Native method that actually shuts down the virtual machine.\n+   *\n+   * @param status the status to end the process with\n+   */\n+  native void exitInternal(int status);\n+\n+  /**\n+   * Load a file. If it has already been loaded, do nothing. The name has\n+   * already been mapped to a true filename.\n+   *\n+   * @param filename the file to load\n+   * @param do_search True if we should search the load path for the file\n+   */\n+  native void _load(String filename, boolean do_search);\n+\n+  /**\n+   *This is a helper function for the ClassLoader which can load\n+   * compiled libraries.  Returns true if library (which is just the\n+   * base name -- path searching is done by this function) was loaded,\n+   * false otherwise.\n+   */\n+  native boolean loadLibraryInternal(String libname);\n+\n+  /**\n+   * A helper for the constructor which does some internal native\n+   * initialization.\n+   */\n+  private native void init ();\n+\n+  /**\n+   * Map a system-independent \"short name\" to the full file name, and append\n+   * it to the path.\n+   * XXX This method is being replaced by System.mapLibraryName.\n+   *\n+   * @param pathname the path\n+   * @param libname the short version of the library name\n+   * @return the full filename\n+   */\n+  static native String nativeGetLibname(String pathname, String libname);\n+\n+  /**\n+   * Execute a process. The command line has already been tokenized, and\n+   * the environment should contain name=value mappings. If directory is null,\n+   * use the current working directory; otherwise start the process in that\n+   * directory.\n+   * XXX Add directory support.\n+   *\n+   * @param cmd the non-null command tokens\n+   * @param env the non-null environment setup\n+   * @param dir the directory to use, may be null\n+   * @return the newly created process\n+   * @throws NullPointerException if cmd or env have null elements\n+   */\n+  //  native Process execInternal(String[] cmd, String[] env, File dir);\n+  native Process execInternal(String[] cmd, String[] env);\n+\n+  /**\n+   * Get the system properties. This is done here, instead of in System,\n+   * because of the bootstrap sequence. Note that the native code should\n+   * not try to use the Java I/O classes yet, as they rely on the properties\n+   * already existing. The only safe method to use to insert these default\n+   * system properties is {@link Properties#setProperty(String, String)}.\n+   *\n+   * <p>These properties MUST include:\n+   * <dl>\n+   * <dt>java.version         <dd>Java version number\n+   * <dt>java.vendor          <dd>Java vendor specific string\n+   * <dt>java.vendor.url      <dd>Java vendor URL\n+   * <dt>java.home            <dd>Java installation directory\n+   * <dt>java.vm.specification.version <dd>VM Spec version\n+   * <dt>java.vm.specification.vendor  <dd>VM Spec vendor\n+   * <dt>java.vm.specification.name    <dd>VM Spec name\n+   * <dt>java.vm.version      <dd>VM implementation version\n+   * <dt>java.vm.vendor       <dd>VM implementation vendor\n+   * <dt>java.vm.name         <dd>VM implementation name\n+   * <dt>java.specification.version    <dd>Java Runtime Environment version\n+   * <dt>java.specification.vendor     <dd>Java Runtime Environment vendor\n+   * <dt>java.specification.name       <dd>Java Runtime Environment name\n+   * <dt>java.class.version   <dd>Java class version number\n+   * <dt>java.class.path      <dd>Java classpath\n+   * <dt>java.library.path    <dd>Path for finding Java libraries\n+   * <dt>java.io.tmpdir       <dd>Default temp file path\n+   * <dt>java.compiler        <dd>Name of JIT to use\n+   * <dt>java.ext.dirs        <dd>Java extension path\n+   * <dt>os.name              <dd>Operating System Name\n+   * <dt>os.arch              <dd>Operating System Architecture\n+   * <dt>os.version           <dd>Operating System Version\n+   * <dt>file.separator       <dd>File separator (\"/\" on Unix)\n+   * <dt>path.separator       <dd>Path separator (\":\" on Unix)\n+   * <dt>line.separator       <dd>Line separator (\"\\n\" on Unix)\n+   * <dt>user.name            <dd>User account name\n+   * <dt>user.home            <dd>User home directory\n+   * <dt>user.dir             <dd>User's current working directory\n+   * </dl>\n+   *\n+   * @param p the Properties object to insert the system properties into\n+   */\n+  static native void insertSystemProperties(Properties p);\n+} // class Runtime"}, {"sha": "edc818fb1810b25c19eebaf919dd5f5c42039db7", "filename": "libjava/java/lang/System.java", "status": "modified", "additions": 501, "deletions": 190, "changes": 691, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86397868159ba8c7ba20d56fdf49f551a512a1f1/libjava%2Fjava%2Flang%2FSystem.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86397868159ba8c7ba20d56fdf49f551a512a1f1/libjava%2Fjava%2Flang%2FSystem.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FSystem.java?ref=86397868159ba8c7ba20d56fdf49f551a512a1f1", "patch": "@@ -1,252 +1,563 @@\n-// System.java - System-specific info.\n+/* System.java -- useful methods to interface with the system\n+   Copyright (C) 1998, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n \n-/* Copyright (C) 1998, 1999, 2000, 2001  Free Software Foundation\n-\n-   This file is part of libgcj.\n-\n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n \n package java.lang;\n \n-import java.io.FileDescriptor;\n-import java.io.FileInputStream;\n-import java.io.FileOutputStream;\n-import java.io.FilterInputStream;\n-import java.io.InputStream;\n-import java.io.PrintStream;\n-import java.io.BufferedInputStream;\n-import java.io.BufferedOutputStream;\n+import java.io.*;\n import java.util.Properties;\n import java.util.PropertyPermission;\n-import java.util.TimeZone;\n+import gnu.classpath.Configuration;\n \n /**\n- * @author Tom Tromey <tromey@cygnus.com>\n- * @date August 27, 1998 \n- */\n-\n-/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n- * \"The Java Language Specification\", ISBN 0-201-63451-1\n- * plus online API docs for JDK 1.2 beta from http://www.javasoft.com.\n- * Status: 1.1.  Some 1.2 methods missing.  Properties code not fully\n- * implemented.\n+ * System represents system-wide resources; things that represent the\n+ * general environment.  As such, all methods are static.\n+ *\n+ * @author John Keiser\n+ * @author Eric Blake <ebb9@email.byu.edu>\n+ * @since 1.0\n+ * @status still missing 1.4 functionality\n  */\n-\n public final class System\n {\n-  public static native void arraycopy (Object src, int srcOffset,\n-\t\t\t\t       Object dst, int dstOffset,\n-\t\t\t\t       int count);\n-\n-  public static native long currentTimeMillis ();\n-\n-  // FIXME: When merging with Classpath, remember to remove the call to\n-  // getDefaultTimeZoneId from java.util.Timezone.\n-  private static native String getSystemTimeZone ();\n-\n-  // Get the System Timezone as reported by the OS.  It should be in\n-  // the form PST8PDT so we'll need to parse it and check that it's valid.\n-  // The result is used to set the user.timezone property in init_properties.\n-  // FIXME: Using the code from Classpath for generating the System\n-  // Timezone IMO is suboptimal because it ignores whether the rules for\n-  // DST match up.\n-  private static String getDefaultTimeZoneId ()\n-  {\n-    String sysTimeZoneId = getSystemTimeZone ();\n-\n-    // Check if this is a valid timezone.  Make sure the IDs match\n-    // since getTimeZone returns GMT if no match is found.\n-    TimeZone tz = TimeZone.getTimeZone (sysTimeZoneId);\n-    if (tz.getID ().equals (sysTimeZoneId))\n-      return sysTimeZoneId;\n-\n-    // Check if the base part of sysTimeZoneId is a valid timezone that\n-    // matches with daylight usage and rawOffset.  Make sure the IDs match\n-    // since getTimeZone returns GMT if no match is found.\n-    // First find start of GMT offset info and any Daylight zone name.\n-    int startGMToffset = 0;\n-    int sysTimeZoneIdLength = sysTimeZoneId.length();\n-    for (int i = 0; i < sysTimeZoneIdLength && startGMToffset == 0; i++)\n-      {\n-        if (Character.isDigit (sysTimeZoneId.charAt (i)))\n-\t  startGMToffset = i;\n-      }\n-\n-    int startDaylightZoneName = 0;\n-    boolean usesDaylight = false;\n-    for (int i = sysTimeZoneIdLength - 1;\n-         i >= 0 && !Character.isDigit (sysTimeZoneId.charAt (i)); --i)\n-      {\n-        startDaylightZoneName = i;\n-      }\n-    if (startDaylightZoneName > 0)\n-      usesDaylight = true;\n-\n-    int GMToffset = Integer.parseInt (startDaylightZoneName == 0 ?\n-      sysTimeZoneId.substring (startGMToffset) :\n-      sysTimeZoneId.substring (startGMToffset, startDaylightZoneName));\n-\n-    // Offset could be in hours or seconds.  Convert to millis.\n-    if (GMToffset < 24)\n-      GMToffset *= 60 * 60;\n-    GMToffset *= -1000;\n-\n-    String tzBasename = sysTimeZoneId.substring (0, startGMToffset);\n-    tz = TimeZone.getTimeZone (tzBasename);\n-    if (tz.getID ().equals (tzBasename) && tz.getRawOffset () == GMToffset)\n-      {\n-        boolean tzUsesDaylight = tz.useDaylightTime ();\n-        if (usesDaylight && tzUsesDaylight || !usesDaylight && !tzUsesDaylight)\n-          return tzBasename;\n-      }\n-  \n-    // If no match, see if a valid timezone has the same attributes as this\n-    // and then use it instead.\n-    String[] IDs = TimeZone.getAvailableIDs (GMToffset);\n-    for (int i = 0; i < IDs.length; ++i)\n-      {\n-\t// FIXME: The daylight savings rules may not match the rules\n-\t// for the desired zone.\n-        boolean IDusesDaylight =\n-\t  TimeZone.getTimeZone (IDs[i]).useDaylightTime ();\n-        if (usesDaylight && IDusesDaylight || !usesDaylight && !IDusesDaylight)\n-\t  return IDs[i];\n-      }\n-\n-    // If all else fails, return null.\n-    return null;\n-  }\n-\n-  public static void exit (int status)\n+  // WARNING: System is a CORE class in the bootstrap cycle. See the comments\n+  // in vm/reference/java/lang/Runtime for implications of this fact.\n+\n+  /**\n+   * Add to the default properties. The field is stored in Runtime, because\n+   * of the bootstrap sequence; but this adds several useful properties to\n+   * the defaults. Once the default is stabilized, it should not be modified;\n+   * instead it is passed as a parent properties for fast setup of the\n+   * defaults when calling <code>setProperties(null)</code>.\n+   */\n+  static\n   {\n-    Runtime.getRuntime().exit(status);\n+    // Note that this loadLibrary() takes precedence over the one in Object,\n+    // since Object.<clinit> is waiting for System.<clinit> to complete\n+    // first; but loading a library twice is harmless.\n+    if (Configuration.INIT_LOAD_LIBRARY)\n+      loadLibrary(\"javalang\");\n+\n+    Properties defaultProperties = Runtime.defaultProperties;\n+    defaultProperties.put(\"gnu.cpu.endian\",\n+                          isWordsBigEndian() ? \"big\" : \"little\");\n+\n+    // XXX FIXME - Temp hack for old systems that set the wrong property\n+    if (defaultProperties.get(\"java.io.tmpdir\") == null)\n+      defaultProperties.put(\"java.io.tmpdir\",\n+                            defaultProperties.get(\"java.tmpdir\"));\n   }\n-\n-  public static void gc ()\n+    \n+  /**\n+   * Stores the current system properties. This can be modified by\n+   * {@link #setProperties(Properties)}, but will never be null, because\n+   * setProperties(null) sucks in the default properties.\n+   */\n+  private static Properties properties\n+    = new Properties(Runtime.defaultProperties);\n+\n+  /**\n+   * The standard InputStream. This is assigned at startup and starts its\n+   * life perfectly valid. Although it is marked final, you can change it\n+   * using {@link #setIn(InputStream)} through some hefty VM magic.\n+   *\n+   * <p>This corresponds to the C stdin and C++ cin variables, which\n+   * typically input from the keyboard, but may be used to pipe input from\n+   * other processes or files.  That should all be transparent to you,\n+   * however.\n+   */\n+  public static final InputStream in\n+    = new BufferedInputStream (new FileInputStream(FileDescriptor.in));\n+  /**\n+   * The standard output PrintStream.  This is assigned at startup and\n+   * starts its life perfectly valid. Although it is marked final, you can\n+   * change it using {@link #setOut(PrintStream)} through some hefty VM magic.\n+   *\n+   * <p>This corresponds to the C stdout and C++ cout variables, which\n+   * typically output normal messages to the screen, but may be used to pipe\n+   * output to other processes or files.  That should all be transparent to\n+   * you, however.\n+   */\n+  public static final PrintStream out\n+    = new PrintStream(new BufferedOutputStream (new FileOutputStream(FileDescriptor.out)), true);\n+  /**\n+   * The standard output PrintStream.  This is assigned at startup and\n+   * starts its life perfectly valid. Although it is marked final, you can\n+   * change it using {@link #setOut(PrintStream)} through some hefty VM magic.\n+   *\n+   * <p>This corresponds to the C stderr and C++ cerr variables, which\n+   * typically output error messages to the screen, but may be used to pipe\n+   * output to other processes or files.  That should all be transparent to\n+   * you, however.\n+   */\n+  public static final PrintStream err\n+    = new PrintStream(new BufferedOutputStream (new FileOutputStream(FileDescriptor.err)), true);\n+\n+  /**\n+   * This class is uninstantiable.\n+   */\n+  private System()\n   {\n-    Runtime.getRuntime().gc();\n   }\n \n-  // Marked deprecated in 1.1.  We implement what the JCL book says.\n-  public static String getenv (String name)\n+  /**\n+   * Set {@link #in} to a new InputStream. This uses some VM magic to change\n+   * a \"final\" variable, so naturally there is a security check,\n+   * <code>RuntimePermission(\"setIO\")</code>.\n+   *\n+   * @param in the new InputStream\n+   * @throws SecurityException if permission is denied\n+   * @since 1.1\n+   */\n+  public static void setIn(InputStream in)\n   {\n-    throw new Error ();\n+    SecurityManager sm = Runtime.securityManager; // Be thread-safe.\n+    if (sm != null)\n+      sm.checkPermission(new RuntimePermission(\"setIO\"));\n+    setIn0(in);\n   }\n \n-  private static native void init_properties ();\n-\n-  public static Properties getProperties ()\n+  /**\n+   * Set {@link #out} to a new PrintStream. This uses some VM magic to change\n+   * a \"final\" variable, so naturally there is a security check,\n+   * <code>RuntimePermission(\"setIO\")</code>.\n+   *\n+   * @param out the new PrintStream\n+   * @throws SecurityException if permission is denied\n+   * @since 1.1\n+   */\n+  public static void setOut(PrintStream out)\n   {\n-    if (secman != null)\n-      secman.checkPropertiesAccess();\n-    if (properties == null)\n-      init_properties ();\n-    return properties;\n+    SecurityManager sm = Runtime.securityManager; // Be thread-safe.\n+    if (sm != null)\n+      sm.checkPermission(new RuntimePermission(\"setIO\"));\n+    setOut0(out);\n   }\n \n-  public static String getProperty (String property)\n+  /**\n+   * Set {@link #err} to a new PrintStream. This uses some VM magic to change\n+   * a \"final\" variable, so naturally there is a security check,\n+   * <code>RuntimePermission(\"setIO\")</code>.\n+   *\n+   * @param err the new PrintStream\n+   * @throws SecurityException if permission is denied\n+   * @since 1.1\n+   */\n+  public static void setErr(PrintStream err)\n   {\n-    if (secman != null)\n-      secman.checkPropertyAccess(property);\n-    if (properties == null)\n-      init_properties ();\n-    return properties.getProperty(property);\n+    SecurityManager sm = Runtime.securityManager; // Be thread-safe.\n+    if (sm != null)\n+      sm.checkPermission(new RuntimePermission(\"setIO\"));\n+    setErr0(err);\n   }\n \n-  public static String getProperty (String property, String defval)\n+  /**\n+   * Set the current SecurityManager. If a security manager already exists,\n+   * then <code>RuntimePermission(\"setSecurityManager\")</code> is checked\n+   * first. Since this permission is denied by the default security manager,\n+   * setting the security manager is often an irreversible action.\n+   *\n+   * <STRONG>Spec Note:</STRONG> Don't ask me, I didn't write it.  It looks\n+   * pretty vulnerable; whoever gets to the gate first gets to set the policy.\n+   * There is probably some way to set the original security manager as a\n+   * command line argument to the VM, but I don't know it.\n+   *\n+   * @param sm the new SecurityManager\n+   * @throws SecurityException if permission is denied\n+   */\n+  public synchronized static void setSecurityManager(SecurityManager sm)\n   {\n-    if (secman != null)\n-      secman.checkPropertyAccess(property);\n-    if (properties == null)\n-      init_properties ();\n-    return properties.getProperty(property, defval);\n+    // Implementation note: the field lives in Runtime because of bootstrap\n+    // initialization issues. This method is synchronized so that no other\n+    // thread changes it to null before this thread makes the change.\n+    if (Runtime.securityManager != null)\n+      Runtime.securityManager.checkPermission\n+        (new RuntimePermission(\"setSecurityManager\"));\n+    Runtime.securityManager = sm;\n   }\n \n-  public static SecurityManager getSecurityManager ()\n+  /**\n+   * Get the current SecurityManager. If the SecurityManager has not been\n+   * set yet, then this method returns null.\n+   *\n+   * @return the current SecurityManager, or null\n+   */\n+  public static SecurityManager getSecurityManager()\n   {\n-    return secman;\n+    // Implementation note: the field lives in Runtime because of bootstrap\n+    // initialization issues.\n+    return Runtime.securityManager;\n   }\n \n-  public static native int identityHashCode (Object obj);\n-\n-  public static void load (String pathname)\n+  /**\n+   * Get the current time, measured in the number of milliseconds from the\n+   * beginning of Jan. 1, 1970. This is gathered from the system clock, with\n+   * any attendant incorrectness (it may be timezone dependent).\n+   *\n+   * @return the current time\n+   * @see java.util.Date\n+   */\n+  public static native long currentTimeMillis();\n+\n+  /**\n+   * Copy one array onto another from <code>src[srcStart]</code> ...\n+   * <code>src[srcStart+len-1]</code> to <code>dest[destStart]</code> ...\n+   * <code>dest[destStart+len-1]</code>. First, the arguments are validated:\n+   * neither array may be null, they must be of compatible types, and the\n+   * start and length must fit within both arrays. Then the copying starts,\n+   * and proceeds through increasing slots.  If src and dest are the same\n+   * array, this will appear to copy the data to a temporary location first.\n+   * An ArrayStoreException in the middle of copying will leave earlier\n+   * elements copied, but later elements unchanged.\n+   *\n+   * @param src the array to copy elements from\n+   * @param srcStart the starting position in src\n+   * @param dest the array to copy elements to\n+   * @param destStart the starting position in dest\n+   * @param len the number of elements to copy\n+   * @throws NullPointerException if src or dest is null\n+   * @throws ArrayStoreException if src or dest is not an array, if they are\n+   *         not compatible array types, or if an incompatible runtime type\n+   *         is stored in dest\n+   * @throws IndexOutOfBoundsException if len is negative, or if the start or\n+   *         end copy position in either array is out of bounds\n+   */\n+  public static native void arraycopy(Object src, int srcStart,\n+\t\t\t\t      Object dest, int destStart, int len);\n+\n+  /**\n+   * Get a hash code computed by the VM for the Object. This hash code will\n+   * be the same as Object's hashCode() method.  It is usually some\n+   * convolution of the pointer to the Object internal to the VM.  It\n+   * follows standard hash code rules, in that it will remain the same for a\n+   * given Object for the lifetime of that Object.\n+   *\n+   * @param o the Object to get the hash code for\n+   * @return the VM-dependent hash code for this Object\n+   * @since 1.1\n+   */\n+  public static native int identityHashCode(Object o);\n+\n+  /**\n+   * Get all the system properties at once. A security check may be performed,\n+   * <code>checkPropertiesAccess</code>. Note that a security manager may\n+   * allow getting a single property, but not the entire group.\n+   *\n+   * <p>The required properties include:\n+   * <dl>\n+   * <dt>java.version         <dd>Java version number\n+   * <dt>java.vendor          <dd>Java vendor specific string\n+   * <dt>java.vendor.url      <dd>Java vendor URL\n+   * <dt>java.home            <dd>Java installation directory\n+   * <dt>java.vm.specification.version <dd>VM Spec version\n+   * <dt>java.vm.specification.vendor  <dd>VM Spec vendor\n+   * <dt>java.vm.specification.name    <dd>VM Spec name\n+   * <dt>java.vm.version      <dd>VM implementation version\n+   * <dt>java.vm.vendor       <dd>VM implementation vendor\n+   * <dt>java.vm.name         <dd>VM implementation name\n+   * <dt>java.specification.version    <dd>Java Runtime Environment version\n+   * <dt>java.specification.vendor     <dd>Java Runtime Environment vendor\n+   * <dt>java.specification.name       <dd>Java Runtime Environment name\n+   * <dt>java.class.version   <dd>Java class version number\n+   * <dt>java.class.path      <dd>Java classpath\n+   * <dt>java.library.path    <dd>Path for finding Java libraries\n+   * <dt>java.io.tmpdir       <dd>Default temp file path\n+   * <dt>java.compiler        <dd>Name of JIT to use\n+   * <dt>java.ext.dirs        <dd>Java extension path\n+   * <dt>os.name              <dd>Operating System Name\n+   * <dt>os.arch              <dd>Operating System Architecture\n+   * <dt>os.version           <dd>Operating System Version\n+   * <dt>file.separator       <dd>File separator (\"/\" on Unix)\n+   * <dt>path.separator       <dd>Path separator (\":\" on Unix)\n+   * <dt>line.separator       <dd>Line separator (\"\\n\" on Unix)\n+   * <dt>user.name            <dd>User account name\n+   * <dt>user.home            <dd>User home directory\n+   * <dt>user.dir             <dd>User's current working directory\n+   * </dl>\n+   *\n+   * In addition, gnu defines several other properties, where ? stands for\n+   * each character in '0' through '9':\n+   * <dl>\n+   * <dt> gnu.cpu.endian      <dd>big or little\n+   * <dt> gnu.java.io.encoding_scheme_alias.ISO-8859-?   <dd>8859_?\n+   * <dt> gnu.java.io.encoding_scheme_alias.iso-8859-?   <dd>8859_?\n+   * <dt> gnu.java.io.encoding_scheme_alias.iso8859_?    <dd>8859_?\n+   * <dt> gnu.java.io.encoding_scheme_alias.iso-latin-_? <dd>8859_?\n+   * <dt> gnu.java.io.encoding_scheme_alias.latin?       <dd>8859_?\n+   * <dt> gnu.java.io.encoding_scheme_alias.UTF-8        <dd>UTF8\n+   * <dt> gnu.java.io.encoding_scheme_alias.utf-8        <dd>UTF8\n+   * </dl>\n+   *\n+   * @return the system properties, will never be null\n+   * @throws SecurityException if permission is denied\n+   */\n+  public static Properties getProperties()\n   {\n-    Runtime.getRuntime().load(pathname);\n+    SecurityManager sm = Runtime.securityManager; // Be thread-safe.\n+    if (sm != null)\n+      sm.checkPropertiesAccess();\n+    return properties;\n   }\n \n-  public static void loadLibrary (String libname)\n+  /**\n+   * Set all the system properties at once. A security check may be performed,\n+   * <code>checkPropertiesAccess</code>. Note that a security manager may\n+   * allow setting a single property, but not the entire group. An argument\n+   * of null resets the properties to the startup default.\n+   *\n+   * @param properties the new set of system properties\n+   * @throws SecurityException if permission is denied\n+   */\n+  public static void setProperties(Properties properties)\n   {\n-    Runtime.getRuntime().loadLibrary(libname);\n+    SecurityManager sm = Runtime.securityManager; // Be thread-safe.\n+    if (sm != null)\n+      sm.checkPropertiesAccess();\n+    if (properties == null)\n+      properties = new Properties(Runtime.defaultProperties);\n+    System.properties = properties;\n   }\n \n-  public static void runFinalization ()\n+  /**\n+   * Get a single system property by name. A security check may be performed,\n+   * <code>checkPropertyAccess(key)</code>.\n+   *\n+   * @param key the name of the system property to get\n+   * @return the property, or null if not found\n+   * @throws SecurityException if permission is denied\n+   * @throws NullPointerException if key is null\n+   * @throws IllegalArgumentException if key is \"\"\n+   */\n+  public static String getProperty(String key)\n   {\n-    Runtime.getRuntime().runFinalization();\n+    SecurityManager sm = Runtime.securityManager; // Be thread-safe.\n+    if (sm != null)\n+      sm.checkPropertyAccess(key);\n+    else if (key.length() == 0)\n+      throw new IllegalArgumentException(\"key can't be empty\");\n+    return properties.getProperty(key);\n   }\n \n-  // Marked as deprecated in 1.2.\n-  public static void runFinalizersOnExit (boolean run)\n+  /**\n+   * Get a single system property by name. A security check may be performed,\n+   * <code>checkPropertyAccess(key)</code>.\n+   *\n+   * @param key the name of the system property to get\n+   * @param def the default\n+   * @return the property, or def if not found\n+   * @throws SecurityException if permission is denied\n+   * @throws NullPointerException if key is null\n+   * @throws IllegalArgumentException if key is \"\"\n+   */\n+  public static String getProperty(String key, String def)\n   {\n-    Runtime.getRuntime().runFinalizersOnExit(run);\n+    SecurityManager sm = Runtime.securityManager; // Be thread-safe.\n+    if (sm != null)\n+      sm.checkPropertyAccess(key);\n+    return properties.getProperty(key, def);\n   }\n \n-  private static void checkSetIO ()\n+  /**\n+   * Set a single system property by name. A security check may be performed,\n+   * <code>checkPropertyAccess(key, \"write\")</code>.\n+   *\n+   * @param key the name of the system property to set\n+   * @param value the new value\n+   * @return the previous value, or null\n+   * @throws SecurityException if permission is denied\n+   * @throws NullPointerException if key is null\n+   * @throws IllegalArgumentException if key is \"\"\n+   * @since 1.2\n+   */\n+  public static String setProperty(String key, String value)\n   {\n-    // In 1.1, we are supposed to call checkExec, but the argument is\n-    // not specified.  In 1.2, we are supposed to use checkPermission,\n-    // which doesn't exist in 1.1.\n-    if (secman != null)\n-      secman.checkExec(\"\");\n+    SecurityManager sm = Runtime.securityManager; // Be thread-safe.\n+    if (sm != null)\n+      sm.checkPermission(new PropertyPermission(key, \"write\"));\n+    return (String) properties.setProperty(key, value);\n   }\n \n-  public static native void setErr (PrintStream newErr);\n-  public static native void setIn (InputStream newIn);\n-  public static native void setOut (PrintStream newOut);\n-\n-  public static void setProperties (Properties props)\n+  /**\n+   * This used to get an environment variable, but following Sun's lead,\n+   * it now throws an Error. Use <code>getProperty</code> instead.\n+   *\n+   * @param name the name of the environment variable\n+   * @return this does not return\n+   * @throws Error this is not supported\n+   * @deprecated use {@link #getProperty(String)}; getenv is not supported\n+   */\n+  public static String getenv(String name)\n   {\n-    if (secman != null)\n-      secman.checkPropertiesAccess();\n-    synchronized (System.class)\n-    {\n-      properties = props;\n-    }\n+    throw new Error(\"getenv no longer supported, use properties instead: \"\n+                    + name);\n   }\n \n-  public static String setProperty (String key, String value)\n+  /**\n+   * Terminate the Virtual Machine. This just calls\n+   * <code>Runtime.getRuntime().exit(status)</code>, and never returns.\n+   * Obviously, a security check is in order, <code>checkExit</code>.\n+   *\n+   * @param status the exit status; by convention non-zero is abnormal\n+   * @throws SecurityException if permission is denied\n+   * @see Runtime#exit(int)\n+   */\n+  public static void exit(int status)\n   {\n-    if (secman != null)\n-      secman.checkPermission (new PropertyPermission (key, \"write\"));\n-    if (properties == null)\n-      init_properties ();\n-    return (String) properties.setProperty (key, value);\n+    Runtime.getRuntime().exit(status);\n   }\n \n-  // TODO 1.2.\n-  // public static String mapLibraryName (String libname);\n+  /**\n+   * Calls the garbage collector. This is only a hint, and it is up to the\n+   * implementation what this hint suggests, but it usually causes a\n+   * best-effort attempt to reclaim unused memory from discarded objects.\n+   * This calls <code>Runtime.getRuntime().gc()</code>.\n+   *\n+   * @see Runtime#gc()\n+   */\n+  public static void gc()\n+  {\n+    Runtime.getRuntime().gc();\n+  }\n \n-  public static void setSecurityManager (SecurityManager s)\n+  /**\n+   * Runs object finalization on pending objects. This is only a hint, and\n+   * it is up to the implementation what this hint suggests, but it usually\n+   * causes a best-effort attempt to run finalizers on all objects ready\n+   * to be reclaimed. This calls\n+   * <code>Runtime.getRuntime().runFinalization()</code>.\n+   *\n+   * @see Runtime#runFinalization()\n+   */\n+  public static void runFinalization()\n   {\n-    if (secman != null)\n-      secman.checkPermission(new RuntimePermission(\"setSecurityManager\"));\n-    secman = s;\n+    Runtime.getRuntime().runFinalization();\n   }\n \n-  // Public data.\n-  public static final InputStream in = new BufferedInputStream (new FileInputStream (FileDescriptor.in));\n+  /**\n+   * Tell the Runtime whether to run finalization before exiting the\n+   * JVM.  This is inherently unsafe in multi-threaded applications,\n+   * since it can force initialization on objects which are still in use\n+   * by live threads, leading to deadlock; therefore this is disabled by\n+   * default. There may be a security check, <code>checkExit(0)</code>. This\n+   * calls <code>Runtime.getRuntime().runFinalizersOnExit()</code>.\n+   *\n+   * @param finalizeOnExit whether to run finalizers on exit\n+   * @throws SecurityException if permission is denied\n+   * @see Runtime#runFinalizersOnExit()\n+   * @since 1.1\n+   * @deprecated never rely on finalizers to do a clean, thread-safe,\n+   *             mop-up from your code\n+   */\n+  public static void runFinalizersOnExit(boolean finalizeOnExit)\n+  {\n+    Runtime.getRuntime().runFinalizersOnExit(finalizeOnExit);\n+  }\n \n-  public static final PrintStream out = new PrintStream (new BufferedOutputStream (new FileOutputStream (FileDescriptor.out)), true);\n+  /**\n+   * Load a code file using its explicit system-dependent filename. A security\n+   * check may be performed, <code>checkLink</code>. This just calls\n+   * <code>Runtime.getRuntime().load(filename)</code>.\n+   *\n+   * @param filename the code file to load\n+   * @throws SecurityException if permission is denied\n+   * @throws UnsatisfiedLinkError if the file cannot be loaded\n+   * @see Runtime#load(String)\n+   */\n+  public static void load(String filename)\n+  {\n+    Runtime.getRuntime().load(filename);\n+  }\n \n-  public static final PrintStream err = new PrintStream (new BufferedOutputStream (new FileOutputStream (FileDescriptor.err)), true);\n+  /**\n+   * Load a library using its explicit system-dependent filename. A security\n+   * check may be performed, <code>checkLink</code>. This just calls\n+   * <code>Runtime.getRuntime().load(filename)</code>.\n+   *\n+   * @param libname the library file to load\n+   * @throws SecurityException if permission is denied\n+   * @throws UnsatisfiedLinkError if the file cannot be loaded\n+   * @see Runtime#load(String)\n+   */\n+  public static void loadLibrary(String libname)\n+  {\n+    Runtime.getRuntime().loadLibrary(libname);\n+  }\n \n-  // Don't allow System objects to be made.\n-  private System ()\n+  /**\n+   * Convert a library name to its platform-specific variant.\n+   *\n+   * @param libname the library name, as used in <code>loadLibrary</code>\n+   * @return the platform-specific mangling of the name\n+   * @since 1.2\n+   */\n+  public static String mapLibraryName(String libname)\n   {\n+    // XXX Fix this!!!!\n+    return Runtime.nativeGetLibname(\"\", libname);\n   }\n \n-  // Private data.\n-  private static SecurityManager secman = null;\n-  private static Properties properties = null;\n-}\n+  /**\n+   * Detect big-endian systems.\n+   *\n+   * @return true if the system is big-endian.\n+   */\n+  static native boolean isWordsBigEndian();\n+\n+  /**\n+   * Set {@link #in} to a new InputStream.\n+   *\n+   * @param in the new InputStream\n+   * @see #setIn(InputStream)\n+   */\n+  private static native void setIn0(InputStream in);\n+\n+  /**\n+   * Set {@link #out} to a new PrintStream.\n+   *\n+   * @param out the new PrintStream\n+   * @see #setOut(PrintStream)\n+   */\n+  private static native void setOut0(PrintStream out);\n+\n+  /**\n+   * Set {@link #err} to a new PrintStream.\n+   *\n+   * @param err the new PrintStream\n+   * @see #setErr(PrintStream)\n+   */\n+  private static native void setErr0(PrintStream err);\n+} // class System"}, {"sha": "0783d5b7419ad65e9710f8a6d3c03583ccd77f2d", "filename": "libjava/java/lang/natRuntime.cc", "status": "modified", "additions": 365, "deletions": 10, "changes": 375, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86397868159ba8c7ba20d56fdf49f551a512a1f1/libjava%2Fjava%2Flang%2FnatRuntime.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86397868159ba8c7ba20d56fdf49f551a512a1f1/libjava%2Fjava%2Flang%2FnatRuntime.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatRuntime.cc?ref=86397868159ba8c7ba20d56fdf49f551a512a1f1", "patch": "@@ -14,14 +14,53 @@ details.  */\n \n #include <gcj/cni.h>\n #include <jvm.h>\n+#include <java-props.h>\n+#include <java/lang/Long.h>\n #include <java/lang/Runtime.h>\n #include <java/lang/UnknownError.h>\n #include <java/lang/UnsatisfiedLinkError.h>\n #include <gnu/gcj/runtime/FileDeleter.h>\n #include <gnu/gcj/runtime/FinalizerThread.h>\n+#include <java/util/Properties.h>\n+#include <java/util/TimeZone.h>\n+#include <java/lang/StringBuffer.h>\n+#include <java/lang/Process.h>\n+#include <java/lang/ConcreteProcess.h>\n \n #include <jni.h>\n \n+#include \"platform.h\"\n+\n+#ifdef HAVE_PWD_H\n+#include <pwd.h>\n+#endif\n+#include <errno.h>\n+\n+#ifdef HAVE_UNAME\n+#include <sys/utsname.h>\n+#endif\n+\n+#ifdef HAVE_LOCALE_H\n+#include <locale.h>\n+#endif\n+\n+#ifdef HAVE_LANGINFO_H\n+#include <langinfo.h>\n+#endif\n+\n+#if TIME_WITH_SYS_TIME\n+# include <sys/time.h>\n+# include <time.h>\n+#else\n+# if HAVE_SYS_TIME_H\n+#  include <sys/time.h>\n+# else\n+#  include <time.h>\n+# endif\n+#endif\n+\n+\f\n+\n #ifdef USE_LTDL\n #include <ltdl.h>\n \n@@ -83,21 +122,16 @@ _Jv_FindSymbolInExecutable (const char *symname)\n \n #endif /* USE_LTDL */\n \n-void\n-java::lang::Runtime::exit (jint status)\n-{\n-  checkExit (status);\n-  _exit (status);\n-}\n+\f\n \n void\n-java::lang::Runtime::_exit (jint status)\n+java::lang::Runtime::exitInternal (jint status)\n {\n   // Make status right for Unix.  This is perhaps strange.\n   if (status < 0 || status > 255)\n     status = 255;\n \n-  if (finalize_on_exit)\n+  if (finalizeOnExit)\n     _Jv_RunAllFinalizers ();\n \n   // Delete all files registered with File.deleteOnExit()\n@@ -122,7 +156,6 @@ void\n java::lang::Runtime::_load (jstring path, jboolean do_search)\n {\n   JvSynchronize sync (this);\n-  checkLink (path);\n   using namespace java::lang;\n #ifdef USE_LTDL\n   jint len = _Jv_GetStringUTFLength (path);\n@@ -205,7 +238,6 @@ java::lang::Runtime::loadLibraryInternal (jstring lib)\n void\n java::lang::Runtime::init (void)\n {\n-  finalize_on_exit = false;\n #ifdef USE_LTDL\n   lt_dlinit ();\n   lt_dlhandle self = lt_dlopen (NULL);\n@@ -226,6 +258,14 @@ java::lang::Runtime::totalMemory (void)\n   return _Jv_GCTotalMemory ();\n }\n \n+jlong\n+java::lang::Runtime::maxMemory (void)\n+{\n+  // We don't have a maximum.  FIXME: we might if we ask the GC for\n+  // one.\n+  return Long::MAX_VALUE;\n+}\n+\n void\n java::lang::Runtime::traceInstructions (jboolean)\n {\n@@ -237,3 +277,318 @@ java::lang::Runtime::traceMethodCalls (jboolean)\n {\n   // Do nothing.\n }\n+\n+#if ! defined (DEFAULT_FILE_ENCODING) && defined (HAVE_ICONV) \\\n+    && defined (HAVE_NL_LANGINFO)\n+\n+static char *\n+file_encoding ()\n+{\n+  setlocale (LC_CTYPE, \"\");\n+  char *e = nl_langinfo (CODESET);\n+  if (e == NULL || *e == '\\0')\n+    e = \"8859_1\";\n+  return e;\n+}\n+\n+#define DEFAULT_FILE_ENCODING file_encoding ()\n+\n+#endif\n+\n+#ifndef DEFAULT_FILE_ENCODING\n+#define DEFAULT_FILE_ENCODING \"8859_1\"\n+#endif\n+\n+static char *default_file_encoding = DEFAULT_FILE_ENCODING;\n+\n+#if HAVE_GETPWUID_R\n+/* Use overload resolution to find out the signature of getpwuid_r.  */\n+\n+  /* This is Posix getpwuid_r.  */\n+template <typename T_uid, typename T_passwd, typename T_buf, typename T_len>\n+static inline int\n+getpwuid_adaptor(int (*getpwuid_r)(T_uid user_id, T_passwd *pwd_r,\n+\t\t\t\t   T_buf *buf_r, T_len len_r,\n+\t\t\t\t   T_passwd **pwd_entry_ptr),\n+\t\t uid_t user_id, struct passwd *pwd_r,\n+\t\t char *buf_r, size_t len_r, struct passwd **pwd_entry)\n+{\n+  return getpwuid_r (user_id, pwd_r, buf_r, len_r, pwd_entry);\n+}\n+\n+/* This is used on HPUX 10.20 */\n+template <typename T_uid, typename T_passwd, typename T_buf, typename T_len>\n+static inline int\n+getpwuid_adaptor(int (*getpwuid_r)(T_uid user_id, T_passwd *pwd_r,\n+\t\t\t\t   T_buf *buf_r, T_len len_r),\n+\t\t uid_t user_id, struct passwd *pwd_r,\n+\t\t char *buf_r, size_t len_r, struct passwd **pwd_entry)\n+{\n+  return getpwuid_r (user_id, pwd_r, buf_r, len_r);\n+}\n+\n+/* This is used on IRIX 5.2.  */\n+template <typename T_uid, typename T_passwd, typename T_buf, typename T_len>\n+static inline int\n+getpwuid_adaptor(T_passwd * (*getpwuid_r)(T_uid user_id, T_passwd *pwd_r,\n+\t\t\t\t\t  T_buf *buf_r, T_len len_r),\n+\t\t uid_t user_id, struct passwd *pwd_r,\n+\t\t char *buf_r, size_t len_r, struct passwd **pwd_entry)\n+{\n+  *pwd_entry = getpwuid_r (user_id, pwd_r, buf_r, len_r);\n+  return (*pwd_entry == NULL) ? errno : 0;\n+}\n+#endif\n+\n+void\n+java::lang::Runtime::insertSystemProperties (java::util::Properties *newprops)\n+{\n+  // A convenience define.\n+#define SET(Prop,Val) \\\n+\tnewprops->put(JvNewStringLatin1 (Prop), JvNewStringLatin1 (Val))\n+\n+  // A mixture of the Java Product Versioning Specification\n+  // (introduced in 1.2), and earlier versioning properties.\n+  SET (\"java.version\", GCJVERSION);\n+  SET (\"java.vendor\", \"Free Software Foundation, Inc.\");\n+  SET (\"java.vendor.url\", \"http://gcc.gnu.org/java/\");\n+  SET (\"java.class.version\", \"46.0\");\n+  SET (\"java.vm.specification.version\", \"1.0\");\n+  SET (\"java.vm.specification.name\", \"Java(tm) Virtual Machine Specification\");\n+  SET (\"java.vm.specification.vendor\", \"Sun Microsystems Inc.\");\n+  SET (\"java.vm.version\", __VERSION__);\n+  SET (\"java.vm.vendor\", \"Free Software Foundation, Inc.\");\n+  SET (\"java.vm.name\", \"GNU libgcj\");\n+  SET (\"java.specification.version\", \"1.3\");\n+  SET (\"java.specification.name\", \"Java(tm) Platform API Specification\");\n+  SET (\"java.specification.vendor\", \"Sun Microsystems Inc.\");\n+\n+  char value[100];\n+#define NAME \"GNU libgcj \"\n+  strcpy (value, NAME);\n+  strncpy (value + sizeof (NAME) - 1, __VERSION__,\n+\t   sizeof(value) - sizeof(NAME));\n+  value[sizeof (value) - 1] = '\\0';\n+  jstring version = JvNewStringLatin1 (value);\n+  newprops->put (JvNewStringLatin1 (\"java.fullversion\"), version);\n+  newprops->put (JvNewStringLatin1 (\"java.vm.info\"), version);\n+\n+  // This definition is rather arbitrary: we choose $(prefix).  In\n+  // part we do this because most people specify only --prefix and\n+  // nothing else when installing gcj.  Plus, people are free to\n+  // redefine `java.home' with `-D' if necessary.\n+  SET (\"java.home\", PREFIX);\n+  \n+  SET (\"file.encoding\", default_file_encoding);\n+\n+#ifdef HAVE_UNAME\n+  struct utsname u;\n+  if (! uname (&u))\n+    {\n+      SET (\"os.name\", u.sysname);\n+      SET (\"os.arch\", u.machine);\n+      SET (\"os.version\", u.release);\n+    }\n+  else\n+    {\n+      SET (\"os.name\", \"unknown\");\n+      SET (\"os.arch\", \"unknown\");\n+      SET (\"os.version\", \"unknown\");\n+    }\n+#endif /* HAVE_UNAME */\n+\n+#ifndef NO_GETUID\n+#ifdef HAVE_PWD_H\n+  uid_t user_id = getuid ();\n+  struct passwd *pwd_entry;\n+\n+#ifdef HAVE_GETPWUID_R\n+  struct passwd pwd_r;\n+  size_t len_r = 200;\n+  char *buf_r = (char *) _Jv_AllocBytes (len_r);\n+\n+  while (buf_r != NULL)\n+    {\n+      int r = getpwuid_adaptor (getpwuid_r, user_id, &pwd_r,\n+\t\t\t\tbuf_r, len_r, &pwd_entry);\n+      if (r == 0)\n+\tbreak;\n+      else if (r != ERANGE)\n+\t{\n+\t  pwd_entry = NULL;\n+\t  break;\n+\t}\n+      len_r *= 2;\n+      buf_r = (char *) _Jv_AllocBytes (len_r);\n+    }\n+#else\n+  pwd_entry = getpwuid (user_id);\n+#endif /* HAVE_GETPWUID_R */\n+\n+  if (pwd_entry != NULL)\n+    {\n+      SET (\"user.name\", pwd_entry->pw_name);\n+      SET (\"user.home\", pwd_entry->pw_dir);\n+    }\n+#endif /* HAVE_PWD_H */\n+#endif /* NO_GETUID */\n+\n+#ifdef HAVE_GETCWD\n+#ifdef HAVE_UNISTD_H\n+  /* Use getcwd to set \"user.dir\". */\n+  int buflen = 250;\n+  char *buffer = (char *) malloc (buflen);\n+  while (buffer != NULL)\n+    {\n+      if (getcwd (buffer, buflen) != NULL)\n+\t{\n+\t  SET (\"user.dir\", buffer);\n+\t  break;\n+\t}\n+      if (errno != ERANGE)\n+\tbreak;\n+      buflen = 2 * buflen;\n+      buffer = (char *) realloc (buffer, buflen);\n+    }\n+  if (buffer != NULL)\n+    free (buffer);\n+#endif /* HAVE_UNISTD_H */\n+#endif /* HAVE_GETCWD */\n+\n+  // Set user locale properties based on setlocale()\n+#if defined (HAVE_SETLOCALE) && defined (HAVE_LC_MESSAGES)\n+  // We let the user choose the locale.  However, since Java differs\n+  // from POSIX, we arbitrarily pick LC_MESSAGES as determining the\n+  // Java locale.  We can't use LC_ALL because it might return a full\n+  // list of all the settings.  If we don't have LC_MESSAGES then we\n+  // just default to `en_US'.\n+  setlocale (LC_ALL, \"\");\n+  char *locale = setlocale (LC_MESSAGES, \"\");\n+  if (locale && strlen (locale) >= 2)\n+    {\n+      char buf[3];\n+      buf[2] = '\\0';\n+      // copy the first two chars to user.language\n+      strncpy (buf, locale, 2);\n+      SET (\"user.language\", buf);\n+      // if the next char is a '_', copy the two after that to user.region\n+      locale += 2;\n+      if (locale[0] == '_')\n+        {\n+\t  locale++;\n+\t  strncpy (buf, locale, 2);\n+\t  SET (\"user.region\", buf);\n+        }\n+    }\n+  else\n+#endif /* HAVE_SETLOCALE and HAVE_LC_MESSAGES */\n+    {\n+      SET (\"user.language\", \"en\");\n+      SET (\"user.region\", \"US\");\n+    }  \n+\n+  // Set some properties according to whatever was compiled in with\n+  // `-D'.\n+  for (int i = 0; _Jv_Compiler_Properties[i]; ++i)\n+    {\n+      const char *s, *p;\n+      // Find the `='.\n+      for (s = p = _Jv_Compiler_Properties[i]; *s && *s != '='; ++s)\n+\t;\n+      jstring name = JvNewStringLatin1 (p, s - p);\n+      jstring val = JvNewStringLatin1 (*s == '=' ? s + 1 : s);\n+      newprops->put (name, val);\n+    }\n+\n+  // Set the system properties from the user's environment.\n+#ifndef DISABLE_GETENV_PROPERTIES\n+  if (_Jv_Environment_Properties)\n+    {\n+      size_t i = 0;\n+\n+      while (_Jv_Environment_Properties[i].key)\n+\t{\n+\t  SET (_Jv_Environment_Properties[i].key, \n+\t       _Jv_Environment_Properties[i].value);\n+\t  i++;\n+\t}\n+    }\n+#endif\n+\n+  if (_Jv_Jar_Class_Path)\n+    newprops->put(JvNewStringLatin1 (\"java.class.path\"),\n+\t\t  JvNewStringLatin1 (_Jv_Jar_Class_Path));\n+  else\n+    {\n+      // FIXME: find libgcj.zip and append its path?\n+      char *classpath = ::getenv(\"CLASSPATH\");\n+      jstring cp = newprops->getProperty (JvNewStringLatin1(\"java.class.path\"));\n+      java::lang::StringBuffer *sb = new java::lang::StringBuffer ();\n+      \n+      if (classpath)\n+\t{\n+\t  sb->append (JvNewStringLatin1 (classpath));\n+#ifdef WIN32\n+\t  sb->append ((jchar) ';');\n+#else\n+\t  sb->append ((jchar) ':');\n+#endif\n+\t}\n+      if (cp != NULL)\n+\tsb->append (cp);\n+      else\n+\tsb->append ((jchar) '.');\n+      \n+      newprops->put(JvNewStringLatin1 (\"java.class.path\"),\n+\t\t      sb->toString ());\n+    }\n+\n+  // Allow platform specific settings and overrides.\n+  _Jv_platform_initProperties (newprops);\n+}\n+\n+java::lang::Process *\n+java::lang::Runtime::execInternal (jstringArray cmd,\n+\t\t\t\t   jstringArray env)\n+{\n+  return new java::lang::ConcreteProcess (cmd, env);\n+}\n+\n+jint\n+java::lang::Runtime::availableProcessors (void)\n+{\n+  // FIXME: find the real value.\n+  return 1;\n+}\n+\n+jstring\n+java::lang::Runtime::nativeGetLibname (jstring pathname, jstring libname)\n+{\n+  java::lang::StringBuffer *sb = new java::lang::StringBuffer ();\n+  sb->append(pathname);\n+  if (pathname->length() > 0)\n+    {\n+      // FIXME: use platform function here.\n+#ifdef WIN32\n+      sb->append ((jchar) '\\\\');\n+#else\n+      sb->append ((jchar) '/');\n+#endif\n+    }\n+\n+  // FIXME: use platform function here.\n+#ifndef WIN32\n+  sb->append (JvNewStringLatin1 (\"lib\"));\n+#endif\n+\n+  sb->append(libname);\n+\n+  // FIXME: use platform function here.\n+#ifdef WIN32\n+  sb->append (JvNewStringLatin1 (\"dll\"));\n+else\n+  sb->append (JvNewStringLatin1 (\"so\"));\n+#endif\n+\n+  return sb->toString();\n+}"}, {"sha": "ffa3f1a5053dbdc26f3eaeb75cfe623bdc9a6519", "filename": "libjava/java/lang/natSystem.cc", "status": "modified", "additions": 15, "deletions": 384, "changes": 399, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86397868159ba8c7ba20d56fdf49f551a512a1f1/libjava%2Fjava%2Flang%2FnatSystem.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86397868159ba8c7ba20d56fdf49f551a512a1f1/libjava%2Fjava%2Flang%2FnatSystem.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatSystem.cc?ref=86397868159ba8c7ba20d56fdf49f551a512a1f1", "patch": "@@ -14,73 +14,35 @@ details.  */\n #include <string.h>\n #include <stdlib.h>\n \n-#include \"platform.h\"\n-\n-#ifdef HAVE_PWD_H\n-#include <pwd.h>\n-#endif\n-#include <errno.h>\n-\n-#ifdef HAVE_UNAME\n-#include <sys/utsname.h>\n-#endif\n-\n-#ifdef HAVE_LOCALE_H\n-#include <locale.h>\n-#endif\n-\n-#ifdef HAVE_LANGINFO_H\n-#include <langinfo.h>\n-#endif\n-\n-#if TIME_WITH_SYS_TIME\n-# include <sys/time.h>\n-# include <time.h>\n-#else\n-# if HAVE_SYS_TIME_H\n-#  include <sys/time.h>\n-# else\n-#  include <time.h>\n-# endif\n-#endif\n-\n #include <gcj/cni.h>\n #include <jvm.h>\n-#include <java-props.h>\n #include <java/lang/System.h>\n #include <java/lang/Class.h>\n #include <java/lang/ArrayStoreException.h>\n #include <java/lang/ArrayIndexOutOfBoundsException.h>\n #include <java/lang/NullPointerException.h>\n-#include <java/lang/StringBuffer.h>\n-#include <java/util/Properties.h>\n-#include <java/util/TimeZone.h>\n #include <java/io/PrintStream.h>\n #include <java/io/InputStream.h>\n \n+#include \"platform.h\"\n+\n \f\n \n void\n-java::lang::System::setErr (java::io::PrintStream *newErr)\n+java::lang::System::setErr0 (java::io::PrintStream *newErr)\n {\n-  checkSetIO ();\n-  // This violates `final' semantics.  Oh well.\n   err = newErr;\n }\n \n void\n-java::lang::System::setIn (java::io::InputStream *newIn)\n+java::lang::System::setIn0 (java::io::InputStream *newIn)\n {\n-  checkSetIO ();\n-  // This violates `final' semantics.  Oh well.\n   in = newIn;\n }\n \n void\n-java::lang::System::setOut (java::io::PrintStream *newOut)\n+java::lang::System::setOut0 (java::io::PrintStream *newOut)\n {\n-  checkSetIO ();\n-  // This violates `final' semantics.  Oh well.\n   out = newOut;\n }\n \n@@ -167,346 +129,15 @@ java::lang::System::identityHashCode (jobject obj)\n   return _Jv_HashCode (obj);\n }\n \n-#if ! defined (DEFAULT_FILE_ENCODING) && defined (HAVE_ICONV) \\\n-    && defined (HAVE_NL_LANGINFO)\n-\n-static char *\n-file_encoding ()\n-{\n-  setlocale (LC_CTYPE, \"\");\n-  char *e = nl_langinfo (CODESET);\n-  if (e == NULL || *e == '\\0')\n-    e = \"8859_1\";\n-  return e;\n-}\n-\n-#define DEFAULT_FILE_ENCODING file_encoding ()\n-\n-#endif\n-\n-#ifndef DEFAULT_FILE_ENCODING\n-#define DEFAULT_FILE_ENCODING \"8859_1\"\n-#endif\n-\n-static char *default_file_encoding = DEFAULT_FILE_ENCODING;\n-\n-#if HAVE_GETPWUID_R\n-/* Use overload resolution to find out the signature of getpwuid_r.  */\n-\n-  /* This is Posix getpwuid_r.  */\n-template <typename T_uid, typename T_passwd, typename T_buf, typename T_len>\n-static inline int\n-getpwuid_adaptor(int (*getpwuid_r)(T_uid user_id, T_passwd *pwd_r,\n-\t\t\t\t   T_buf *buf_r, T_len len_r,\n-\t\t\t\t   T_passwd **pwd_entry_ptr),\n-\t\t uid_t user_id, struct passwd *pwd_r,\n-\t\t char *buf_r, size_t len_r, struct passwd **pwd_entry)\n-{\n-  return getpwuid_r (user_id, pwd_r, buf_r, len_r, pwd_entry);\n-}\n-\n-/* This is used on HPUX 10.20 */\n-template <typename T_uid, typename T_passwd, typename T_buf, typename T_len>\n-static inline int\n-getpwuid_adaptor(int (*getpwuid_r)(T_uid user_id, T_passwd *pwd_r,\n-\t\t\t\t   T_buf *buf_r, T_len len_r),\n-\t\t uid_t user_id, struct passwd *pwd_r,\n-\t\t char *buf_r, size_t len_r, struct passwd **pwd_entry)\n-{\n-  return getpwuid_r (user_id, pwd_r, buf_r, len_r);\n-}\n-\n-/* This is used on IRIX 5.2.  */\n-template <typename T_uid, typename T_passwd, typename T_buf, typename T_len>\n-static inline int\n-getpwuid_adaptor(T_passwd * (*getpwuid_r)(T_uid user_id, T_passwd *pwd_r,\n-\t\t\t\t\t  T_buf *buf_r, T_len len_r),\n-\t\t uid_t user_id, struct passwd *pwd_r,\n-\t\t char *buf_r, size_t len_r, struct passwd **pwd_entry)\n-{\n-  *pwd_entry = getpwuid_r (user_id, pwd_r, buf_r, len_r);\n-  return (*pwd_entry == NULL) ? errno : 0;\n-}\n-#endif\n-\n-/*\n- * This method returns a time zone string that is used by init_properties\n- * to set the default timezone property 'user.timezone'.  That value is\n- * used by default as a key into the timezone table used by the\n- * java::util::TimeZone class.\n- */\n-jstring\n-java::lang::System::getSystemTimeZone (void)\n-{\n-  struct tm *tim;\n-  time_t current_time;\n-  long tzoffset;\n-  const char *tz1, *tz2;\n-  char *tzid;\n-\n-  current_time = time(0);\n-\n-  mktime(tim = localtime(&current_time));\n-#ifdef STRUCT_TM_HAS_GMTOFF\n-  // tm_gmtoff is secs EAST of UTC.\n-  tzoffset = -(tim->tm_gmtoff) + tim->tm_isdst * 3600L;\n-#elif HAVE_UNDERSCORE_TIMEZONE\n-  tzoffset = _timezone;\n-#elif HAVE_TIMEZONE\n-  // timezone is secs WEST of UTC.\n-  tzoffset = timezone;\t\n-#else\n-  // FIXME: there must be another global if neither tm_gmtoff nor timezone\n-  // is available, esp. if tzname is valid.\n-  // Richard Earnshaw <rearnsha@arm.com> has suggested using difftime to\n-  // calculate between gmtime and localtime (and accounting for possible\n-  // daylight savings time) as an alternative.\n-  tzoffset = 0L;\n-#endif\n-\n-#ifdef HAVE_TM_ZONE\n-  tz1 = tim->tm_zone;\n-  tz2 = \"\";\n-#elif defined (HAVE_TZNAME)\n-  tz1 = tzname[0];\n-  tz2 = strcmp (tzname[0], tzname[1]) ? tzname[1] : \"\";\n-#else\n-  // Some targets have no concept of timezones.\n-  tz1 = \"???\";\n-  tz2 = tz1;\n-#endif\n-\n-  if ((tzoffset % 3600) == 0)\n-    tzoffset = tzoffset / 3600;\n-\n-  tzid = (char*) _Jv_Malloc (strlen(tz1) + strlen(tz2) + 6);\n-  sprintf(tzid, \"%s%ld%s\", tz1, tzoffset, tz2);\n-  jstring retval = JvNewStringUTF (tzid);\n-  _Jv_Free (tzid);\n-\n-  return retval;\n-}\n-\n-void\n-java::lang::System::init_properties (void)\n+jboolean\n+java::lang::System::isWordsBigEndian (void)\n {\n-  JvSynchronize sync (&java::lang::System::class$);\n-  \n-  if (properties != NULL)\n-    return;\n-\n-  java::util::Properties* newprops = new java::util::Properties ();\n-  \n-  // A convenience define.\n-#define SET(Prop,Val) \\\n-\tnewprops->put(JvNewStringLatin1 (Prop), JvNewStringLatin1 (Val))\n-\n-  // A mixture of the Java Product Versioning Specification\n-  // (introduced in 1.2), and earlier versioning properties.\n-  SET (\"java.version\", GCJVERSION);\n-  SET (\"java.vendor\", \"Free Software Foundation, Inc.\");\n-  SET (\"java.vendor.url\", \"http://gcc.gnu.org/java/\");\n-  SET (\"java.class.version\", \"46.0\");\n-  SET (\"java.vm.specification.version\", \"1.0\");\n-  SET (\"java.vm.specification.name\", \"Java(tm) Virtual Machine Specification\");\n-  SET (\"java.vm.specification.vendor\", \"Sun Microsystems Inc.\");\n-  SET (\"java.vm.version\", __VERSION__);\n-  SET (\"java.vm.vendor\", \"Free Software Foundation, Inc.\");\n-  SET (\"java.vm.name\", \"GNU libgcj\");\n-  SET (\"java.specification.version\", \"1.3\");\n-  SET (\"java.specification.name\", \"Java(tm) Platform API Specification\");\n-  SET (\"java.specification.vendor\", \"Sun Microsystems Inc.\");\n-\n-  char value[100];\n-#define NAME \"GNU libgcj \"\n-  strcpy (value, NAME);\n-  strncpy (value + sizeof (NAME) - 1, __VERSION__,\n-\t   sizeof(value) - sizeof(NAME));\n-  value[sizeof (value) - 1] = '\\0';\n-  jstring version = JvNewStringLatin1 (value);\n-  newprops->put (JvNewStringLatin1 (\"java.fullversion\"), version);\n-  newprops->put (JvNewStringLatin1 (\"java.vm.info\"), version);\n-\n-  // This definition is rather arbitrary: we choose $(prefix).  In\n-  // part we do this because most people specify only --prefix and\n-  // nothing else when installing gcj.  Plus, people are free to\n-  // redefine `java.home' with `-D' if necessary.\n-  SET (\"java.home\", PREFIX);\n-  \n-  SET (\"file.encoding\", default_file_encoding);\n-\n-#ifdef HAVE_UNAME\n-  struct utsname u;\n-  if (! uname (&u))\n-    {\n-      SET (\"os.name\", u.sysname);\n-      SET (\"os.arch\", u.machine);\n-      SET (\"os.version\", u.release);\n-    }\n-  else\n-    {\n-      SET (\"os.name\", \"unknown\");\n-      SET (\"os.arch\", \"unknown\");\n-      SET (\"os.version\", \"unknown\");\n-    }\n-#endif /* HAVE_UNAME */\n-\n-#ifndef NO_GETUID\n-#ifdef HAVE_PWD_H\n-  uid_t user_id = getuid ();\n-  struct passwd *pwd_entry;\n-\n-#ifdef HAVE_GETPWUID_R\n-  struct passwd pwd_r;\n-  size_t len_r = 200;\n-  char *buf_r = (char *) _Jv_AllocBytes (len_r);\n-\n-  while (buf_r != NULL)\n-    {\n-      int r = getpwuid_adaptor (getpwuid_r, user_id, &pwd_r,\n-\t\t\t\tbuf_r, len_r, &pwd_entry);\n-      if (r == 0)\n-\tbreak;\n-      else if (r != ERANGE)\n-\t{\n-\t  pwd_entry = NULL;\n-\t  break;\n-\t}\n-      len_r *= 2;\n-      buf_r = (char *) _Jv_AllocBytes (len_r);\n-    }\n-#else\n-  pwd_entry = getpwuid (user_id);\n-#endif /* HAVE_GETPWUID_R */\n-\n-  if (pwd_entry != NULL)\n-    {\n-      SET (\"user.name\", pwd_entry->pw_name);\n-      SET (\"user.home\", pwd_entry->pw_dir);\n-    }\n-#endif /* HAVE_PWD_H */\n-#endif /* NO_GETUID */\n-\n-#ifdef HAVE_GETCWD\n-#ifdef HAVE_UNISTD_H\n-  /* Use getcwd to set \"user.dir\". */\n-  int buflen = 250;\n-  char *buffer = (char *) malloc (buflen);\n-  while (buffer != NULL)\n-    {\n-      if (getcwd (buffer, buflen) != NULL)\n-\t{\n-\t  SET (\"user.dir\", buffer);\n-\t  break;\n-\t}\n-      if (errno != ERANGE)\n-\tbreak;\n-      buflen = 2 * buflen;\n-      buffer = (char *) realloc (buffer, buflen);\n-    }\n-  if (buffer != NULL)\n-    free (buffer);\n-#endif /* HAVE_UNISTD_H */\n-#endif /* HAVE_GETCWD */\n-\n-  // Set user locale properties based on setlocale()\n-#if defined (HAVE_SETLOCALE) && defined (HAVE_LC_MESSAGES)\n-  // We let the user choose the locale.  However, since Java differs\n-  // from POSIX, we arbitrarily pick LC_MESSAGES as determining the\n-  // Java locale.  We can't use LC_ALL because it might return a full\n-  // list of all the settings.  If we don't have LC_MESSAGES then we\n-  // just default to `en_US'.\n-  setlocale (LC_ALL, \"\");\n-  char *locale = setlocale (LC_MESSAGES, \"\");\n-  if (locale && strlen (locale) >= 2)\n-    {\n-      char buf[3];\n-      buf[2] = '\\0';\n-      // copy the first two chars to user.language\n-      strncpy (buf, locale, 2);\n-      SET (\"user.language\", buf);\n-      // if the next char is a '_', copy the two after that to user.region\n-      locale += 2;\n-      if (locale[0] == '_')\n-        {\n-\t  locale++;\n-\t  strncpy (buf, locale, 2);\n-\t  SET (\"user.region\", buf);\n-        }\n-    }\n-  else\n-#endif /* HAVE_SETLOCALE and HAVE_LC_MESSAGES */\n-    {\n-      SET (\"user.language\", \"en\");\n-      SET (\"user.region\", \"US\");\n-    }  \n-\n-  // Set the \"user.timezone\" property.\n-  jstring timezone = getDefaultTimeZoneId ();\n-  if (timezone != NULL)\n-    newprops->put (JvNewStringLatin1 (\"user.timezone\"), timezone);\n-\n-  // Set some properties according to whatever was compiled in with\n-  // `-D'.\n-  for (int i = 0; _Jv_Compiler_Properties[i]; ++i)\n-    {\n-      const char *s, *p;\n-      // Find the `='.\n-      for (s = p = _Jv_Compiler_Properties[i]; *s && *s != '='; ++s)\n-\t;\n-      jstring name = JvNewStringLatin1 (p, s - p);\n-      jstring val = JvNewStringLatin1 (*s == '=' ? s + 1 : s);\n-      newprops->put (name, val);\n-    }\n-\n-  // Set the system properties from the user's environment.\n-#ifndef DISABLE_GETENV_PROPERTIES\n-  if (_Jv_Environment_Properties)\n-    {\n-      size_t i = 0;\n-\n-      while (_Jv_Environment_Properties[i].key)\n-\t{\n-\t  SET (_Jv_Environment_Properties[i].key, \n-\t       _Jv_Environment_Properties[i].value);\n-\t  i++;\n-\t}\n-    }\n-#endif\n-\n-  if (_Jv_Jar_Class_Path)\n-    newprops->put(JvNewStringLatin1 (\"java.class.path\"),\n-\t\t  JvNewStringLatin1 (_Jv_Jar_Class_Path));\n-  else\n-    {\n-      // FIXME: find libgcj.zip and append its path?\n-      char *classpath = ::getenv(\"CLASSPATH\");\n-      jstring cp = newprops->getProperty (JvNewStringLatin1(\"java.class.path\"));\n-      java::lang::StringBuffer *sb = new java::lang::StringBuffer ();\n-      \n-      if (classpath)\n-\t{\n-\t  sb->append (JvNewStringLatin1 (classpath));\n-#ifdef WIN32\n-\t  sb->append ((jchar) ';');\n-#else\n-\t  sb->append ((jchar) ':');\n-#endif\n-\t}\n-      if (cp != NULL)\n-\tsb->append (cp);\n-      else\n-\tsb->append ((jchar) '.');\n-      \n-      newprops->put(JvNewStringLatin1 (\"java.class.path\"),\n-\t\t      sb->toString ());\n-    }\n-\n-  // Allow platform specific settings and overrides.\n-  _Jv_platform_initProperties (newprops);\n-\n-  // Finally, set the field. This ensures that concurrent getProperty() \n-  // calls will return initialized values without requiring them to be \n-  // synchronized in the common case.\n-  properties = newprops;\n+  union\n+  {\n+    long lval;\n+    char cval;\n+  } u;\n+\n+  u.lval = 1;\n+  return u.cval == 0;\n }"}, {"sha": "eba22363d185da8ee83f6282f56621bba503d563", "filename": "libjava/java/util/TimeZone.java", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86397868159ba8c7ba20d56fdf49f551a512a1f1/libjava%2Fjava%2Futil%2FTimeZone.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86397868159ba8c7ba20d56fdf49f551a512a1f1/libjava%2Fjava%2Futil%2FTimeZone.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FTimeZone.java?ref=86397868159ba8c7ba20d56fdf49f551a512a1f1", "patch": "@@ -1,5 +1,5 @@\n /* java.util.TimeZone\n-   Copyright (C) 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -38,6 +38,7 @@\n \n package java.util;\n import java.text.DateFormatSymbols;\n+import gnu.classpath.Configuration;\n \n /**\n  * This class represents a time zone offset and handles daylight savings.\n@@ -753,16 +754,32 @@ public abstract class TimeZone implements java.io.Serializable, Cloneable\n   /* Look up default timezone */\n   static\n   {\n-    // System.loadLibrary(\"javautil\");\n-\n+    if (Configuration.INIT_LOAD_LIBRARY)\n+      {\n+\tSystem.loadLibrary(\"javautil\");\n+      }\n     String tzid = System.getProperty(\"user.timezone\");\n \n+    if (tzid == null)\n+      tzid = getDefaultTimeZoneId();\n+\n     if (tzid == null)\n       tzid = \"GMT\";\n \n     defaultZone = getTimeZone(tzid);\n   }\n \n+  /* This method returns us a time zone id string which is in the\n+     form <standard zone name><GMT offset><daylight time zone name>.\n+     The GMT offset is in seconds, except where it is evenly divisible\n+     by 3600, then it is in hours.  If the zone does not observe\n+     daylight time, then the daylight zone name is omitted.  Examples:\n+     in Chicago, the timezone would be CST6CDT.  In Indianapolis \n+     (which does not have Daylight Savings Time) the string would\n+     be EST5\n+   */\n+  private static native String getDefaultTimeZoneId();\n+\n   /**\n    * Gets the time zone offset, for current date, modified in case of \n    * daylight savings.  This is the offset to add to UTC to get the local"}, {"sha": "007f689209f02ada8627cd2b4581ae124b952e5c", "filename": "libjava/java/util/natTimeZone.cc", "status": "added", "additions": 154, "deletions": 0, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86397868159ba8c7ba20d56fdf49f551a512a1f1/libjava%2Fjava%2Futil%2FnatTimeZone.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86397868159ba8c7ba20d56fdf49f551a512a1f1/libjava%2Fjava%2Futil%2FnatTimeZone.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FnatTimeZone.cc?ref=86397868159ba8c7ba20d56fdf49f551a512a1f1", "patch": "@@ -0,0 +1,154 @@\n+// natTimeZone.cc -- Native side of TimeZone class.\n+\n+/* Copyright (C) 1998, 1999, 2000, 2001, 2002  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+#include <config.h>\n+\n+#include <gcj/cni.h>\n+#include <jvm.h>\n+\n+#include <java/util/TimeZone.h>\n+#include <java/lang/Character.h>\n+#include <java/lang/Integer.h>\n+\n+/*\n+ * This method returns a time zone string that is used by init_properties\n+ * to set the default timezone property 'user.timezone'.  That value is\n+ * used by default as a key into the timezone table used by the\n+ * java::util::TimeZone class.\n+ */\n+static jstring\n+getSystemTimeZone (void)\n+{\n+  struct tm *tim;\n+  time_t current_time;\n+  long tzoffset;\n+  const char *tz1, *tz2;\n+  char *tzid;\n+\n+  current_time = time(0);\n+\n+  mktime(tim = localtime(&current_time));\n+#ifdef STRUCT_TM_HAS_GMTOFF\n+  // tm_gmtoff is secs EAST of UTC.\n+  tzoffset = -(tim->tm_gmtoff) + tim->tm_isdst * 3600L;\n+#elif HAVE_UNDERSCORE_TIMEZONE\n+  tzoffset = _timezone;\n+#elif HAVE_TIMEZONE\n+  // timezone is secs WEST of UTC.\n+  tzoffset = timezone;\t\n+#else\n+  // FIXME: there must be another global if neither tm_gmtoff nor timezone\n+  // is available, esp. if tzname is valid.\n+  // Richard Earnshaw <rearnsha@arm.com> has suggested using difftime to\n+  // calculate between gmtime and localtime (and accounting for possible\n+  // daylight savings time) as an alternative.\n+  tzoffset = 0L;\n+#endif\n+\n+#ifdef HAVE_TM_ZONE\n+  tz1 = tim->tm_zone;\n+  tz2 = \"\";\n+#elif defined (HAVE_TZNAME)\n+  tz1 = tzname[0];\n+  tz2 = strcmp (tzname[0], tzname[1]) ? tzname[1] : \"\";\n+#else\n+  // Some targets have no concept of timezones.\n+  tz1 = \"???\";\n+  tz2 = tz1;\n+#endif\n+\n+  if ((tzoffset % 3600) == 0)\n+    tzoffset = tzoffset / 3600;\n+\n+  tzid = (char*) _Jv_Malloc (strlen(tz1) + strlen(tz2) + 6);\n+  sprintf(tzid, \"%s%ld%s\", tz1, tzoffset, tz2);\n+  jstring retval = JvNewStringUTF (tzid);\n+  _Jv_Free (tzid);\n+\n+  return retval;\n+}\n+\n+// Get the System Timezone as reported by the OS.  It should be in\n+// the form PST8PDT so we'll need to parse it and check that it's valid.\n+// FIXME: Using the code from Classpath for generating the System\n+// Timezone IMO is suboptimal because it ignores whether the rules for\n+// DST match up.\n+jstring\n+java::util::TimeZone::getDefaultTimeZoneId ()\n+{\n+  jstring sysTimeZoneId = getSystemTimeZone ();\n+\n+  using namespace java::lang;\n+\n+  // Check if this is a valid timezone.  Make sure the IDs match\n+  // since getTimeZone returns GMT if no match is found.\n+  TimeZone *tz = TimeZone::getTimeZone (sysTimeZoneId);\n+  if (tz->getID ()->equals (sysTimeZoneId))\n+    return sysTimeZoneId;\n+\n+  // Check if the base part of sysTimeZoneId is a valid timezone that\n+  // matches with daylight usage and rawOffset.  Make sure the IDs match\n+  // since getTimeZone returns GMT if no match is found.\n+  // First find start of GMT offset info and any Daylight zone name.\n+  int startGMToffset = 0;\n+  int sysTimeZoneIdLength = sysTimeZoneId->length();\n+  for (int i = 0; i < sysTimeZoneIdLength && startGMToffset == 0; i++)\n+    {\n+      if (Character::isDigit (sysTimeZoneId->charAt (i)))\n+\tstartGMToffset = i;\n+    }\n+\n+  int startDaylightZoneName = 0;\n+  jboolean usesDaylight = false;\n+  for (int i = sysTimeZoneIdLength - 1;\n+       i >= 0 && !Character::isDigit (sysTimeZoneId->charAt (i)); --i)\n+    {\n+      startDaylightZoneName = i;\n+    }\n+  if (startDaylightZoneName > 0)\n+    usesDaylight = true;\n+\n+  int GMToffset\n+    = Integer::parseInt (startDaylightZoneName == 0 ?\n+\t\t\t sysTimeZoneId->substring (startGMToffset) :\n+\t\t\t sysTimeZoneId->substring (startGMToffset,\n+\t\t\t\t\t\t   startDaylightZoneName));\n+\n+  // Offset could be in hours or seconds.  Convert to millis.\n+  if (GMToffset < 24)\n+    GMToffset *= 60 * 60;\n+  GMToffset *= -1000;\n+\n+  jstring tzBasename = sysTimeZoneId->substring (0, startGMToffset);\n+  tz = TimeZone::getTimeZone (tzBasename);\n+  if (tz->getID ()->equals (tzBasename) && tz->getRawOffset () == GMToffset)\n+    {\n+      jboolean tzUsesDaylight = tz->useDaylightTime ();\n+      if (usesDaylight && tzUsesDaylight || !usesDaylight && !tzUsesDaylight)\n+\treturn tzBasename;\n+    }\n+\n+  // If no match, see if a valid timezone has the same attributes as this\n+  // and then use it instead.\n+  jstringArray IDs = TimeZone::getAvailableIDs (GMToffset);\n+  jstring *elts = elements (IDs);\n+  for (int i = 0; i < IDs->length; ++i)\n+    {\n+      // FIXME: The daylight savings rules may not match the rules\n+      // for the desired zone.\n+      jboolean IDusesDaylight =\n+\tTimeZone::getTimeZone (elts[i])->useDaylightTime ();\n+      if (usesDaylight && IDusesDaylight || !usesDaylight && !IDusesDaylight)\n+\treturn elts[i];\n+    }\n+\n+  // If all else fails, return null.\n+  return NULL;\n+}"}]}