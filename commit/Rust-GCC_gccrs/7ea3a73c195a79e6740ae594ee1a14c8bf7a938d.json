{"sha": "7ea3a73c195a79e6740ae594ee1a14c8bf7a938d", "node_id": "C_kwDOANBUbNoAKDdlYTNhNzNjMTk1YTc5ZTY3NDBhZTU5NGVlMWExNGM4YmY3YTkzOGQ", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2022-03-31T15:22:34Z"}, "committer": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2022-03-31T15:24:22Z"}, "message": "ipa: Careful processing ANCESTOR jump functions and NULL pointers (PR 103083)\n\nIPA_JF_ANCESTOR jump functions are constructed also when the formal\nparameter of the caller is first checked whether it is NULL and left\nas it is if it is NULL, to accommodate C++ casts to an ancestor class.\n\nThe jump function type was invented for devirtualization and IPA-CP\npropagation of tree constants is also careful to apply it only to\nexisting DECLs(*) but as PR 103083 shows, the part propagating \"known\nbits\" was not careful about this, which can lead to miscompilations.\n\nThis patch introduces a flag to the ancestor jump functions which\ntells whether a NULL-check was elided when creating it and makes the\nbits propagation behave accordingly, masking any bits otherwise would\nbe known to be one.  This should safely preserve alignment info, which\nis the primary ifnormation that we keep in bits for pointers.\n\n(*) There still may remain problems when a DECL resides on address\nzero (with -fno-delete-null-pointer-checks ...I hope it cannot happen\notherwise).  I am looking into that now but I think it will be easier\nfor everyone if I do so in a follow-up patch.\n\ngcc/ChangeLog:\n\n2022-02-11  Martin Jambor  <mjambor@suse.cz>\n\n\tPR ipa/103083\n\t* ipa-prop.h (ipa_ancestor_jf_data): New flag keep_null;\n\t(ipa_get_jf_ancestor_keep_null): New function.\n\t* ipa-prop.cc (ipa_set_ancestor_jf): Initialize keep_null field of the\n\tancestor function.\n\t(compute_complex_assign_jump_func): Pass false to keep_null\n\tparameter of ipa_set_ancestor_jf.\n\t(compute_complex_ancestor_jump_func): Pass true to keep_null\n\tparameter of ipa_set_ancestor_jf.\n\t(update_jump_functions_after_inlining): Carry over keep_null from the\n\toriginal ancestor jump-function or merge them.\n\t(ipa_write_jump_function): Stream keep_null flag.\n\t(ipa_read_jump_function): Likewise.\n\t(ipa_print_node_jump_functions_for_edge): Print the new flag.\n\t* ipa-cp.cc (class ipcp_bits_lattice): Make various getters const.  New\n\tmember function known_nonzero_p.\n\t(ipcp_bits_lattice::known_nonzero_p): New.\n\t(ipcp_bits_lattice::meet_with_1): New parameter drop_all_ones,\n\tobserve it.\n\t(ipcp_bits_lattice::meet_with): Likewise.\n\t(propagate_bits_across_jump_function): Simplify.  Pass true in\n\tdrop_all_ones when it is necessary.\n\t(propagate_aggs_across_jump_function): Take care of keep_null\n\tflag.\n\t(ipa_get_jf_ancestor_result): Propagate NULL accross keep_null\n\tjump functions.\n\ngcc/testsuite/ChangeLog:\n\n2021-11-25  Martin Jambor  <mjambor@suse.cz>\n\n\t* gcc.dg/ipa/pr103083-1.c: New test.\n\t* gcc.dg/ipa/pr103083-2.c: Likewise.", "tree": {"sha": "43e8eda303cb45ddcbd1c4baa7e0681d222e32d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/43e8eda303cb45ddcbd1c4baa7e0681d222e32d0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7ea3a73c195a79e6740ae594ee1a14c8bf7a938d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEE5elVTFt/d09Vsoczv2PBvD+kNUAFAmJFx6YACgkQv2PBvD+k\nNUCM+g/+NhSNIAUvYgujIi6lz0kYYvYc8BVHSPQDhQas7+U0e+PXXG9ubu4PqzNI\n0MSqQL4Y1NxmXQuLPu3qqb3ESZTupZWmByDYVTG2KgBr8N0shqsnPqqIR+wwWAjK\nVcRo7Wks9hFiSCEtqh7XRg4pCiG1K548aNRXrL4tkfX5jX3w8xiwrFQ/PqcAnQuR\nJ6ZIeeB1zCR+9LRlmMBG0Jgf9UrLe8fhoUoG9ZPVqKWKkfXZcHV1XjFwhA/wG9if\nOprx4xTpAcpNg61h3p6x3QDmkD0yPtiE/r2o4D1Z5A1u2PJTSL1rWqmdy9l64Lio\n6x4alKBMi7YioAw0ByIMNA19bhom45uFby1PZLfBi2Z2M4BfvFxfzsHNo8Hgqdym\nYZfpx/JYz/GKk/vqxl2yTa+yv17OhwwCEOW1gvnpG9QfG97QlnV5cOjDrsBAnhmA\ncWUvv6h+YQetBKZzZU9LE40pgh5mKWX5e3Ynnr4qGQjKckbLiWeUmM/uBsAFOazN\np3IJxtxim5BNk78h61+5hM+e0aC+l2S44tKd3A5MooM45ToryQvlNhZmboU+rlTN\ntJhKGh33yDPwtIum3xb/cNHrMvRmlAOuRtAGbmZDhxS1yuGfdJMJCJ8YQq09ErPq\nQ08lCjhFtiDKLrM21xUa3HrCnGco9iCJ7UJzm+9JQNad3Hf11c0=\n=lZe7\n-----END PGP SIGNATURE-----", "payload": "tree 43e8eda303cb45ddcbd1c4baa7e0681d222e32d0\nparent 7f016919fc8a042b83812ae5f34946ef23b7adb3\nauthor Martin Jambor <mjambor@suse.cz> 1648740154 +0200\ncommitter Martin Jambor <mjambor@suse.cz> 1648740262 +0200\n\nipa: Careful processing ANCESTOR jump functions and NULL pointers (PR 103083)\n\nIPA_JF_ANCESTOR jump functions are constructed also when the formal\nparameter of the caller is first checked whether it is NULL and left\nas it is if it is NULL, to accommodate C++ casts to an ancestor class.\n\nThe jump function type was invented for devirtualization and IPA-CP\npropagation of tree constants is also careful to apply it only to\nexisting DECLs(*) but as PR 103083 shows, the part propagating \"known\nbits\" was not careful about this, which can lead to miscompilations.\n\nThis patch introduces a flag to the ancestor jump functions which\ntells whether a NULL-check was elided when creating it and makes the\nbits propagation behave accordingly, masking any bits otherwise would\nbe known to be one.  This should safely preserve alignment info, which\nis the primary ifnormation that we keep in bits for pointers.\n\n(*) There still may remain problems when a DECL resides on address\nzero (with -fno-delete-null-pointer-checks ...I hope it cannot happen\notherwise).  I am looking into that now but I think it will be easier\nfor everyone if I do so in a follow-up patch.\n\ngcc/ChangeLog:\n\n2022-02-11  Martin Jambor  <mjambor@suse.cz>\n\n\tPR ipa/103083\n\t* ipa-prop.h (ipa_ancestor_jf_data): New flag keep_null;\n\t(ipa_get_jf_ancestor_keep_null): New function.\n\t* ipa-prop.cc (ipa_set_ancestor_jf): Initialize keep_null field of the\n\tancestor function.\n\t(compute_complex_assign_jump_func): Pass false to keep_null\n\tparameter of ipa_set_ancestor_jf.\n\t(compute_complex_ancestor_jump_func): Pass true to keep_null\n\tparameter of ipa_set_ancestor_jf.\n\t(update_jump_functions_after_inlining): Carry over keep_null from the\n\toriginal ancestor jump-function or merge them.\n\t(ipa_write_jump_function): Stream keep_null flag.\n\t(ipa_read_jump_function): Likewise.\n\t(ipa_print_node_jump_functions_for_edge): Print the new flag.\n\t* ipa-cp.cc (class ipcp_bits_lattice): Make various getters const.  New\n\tmember function known_nonzero_p.\n\t(ipcp_bits_lattice::known_nonzero_p): New.\n\t(ipcp_bits_lattice::meet_with_1): New parameter drop_all_ones,\n\tobserve it.\n\t(ipcp_bits_lattice::meet_with): Likewise.\n\t(propagate_bits_across_jump_function): Simplify.  Pass true in\n\tdrop_all_ones when it is necessary.\n\t(propagate_aggs_across_jump_function): Take care of keep_null\n\tflag.\n\t(ipa_get_jf_ancestor_result): Propagate NULL accross keep_null\n\tjump functions.\n\ngcc/testsuite/ChangeLog:\n\n2021-11-25  Martin Jambor  <mjambor@suse.cz>\n\n\t* gcc.dg/ipa/pr103083-1.c: New test.\n\t* gcc.dg/ipa/pr103083-2.c: Likewise.\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ea3a73c195a79e6740ae594ee1a14c8bf7a938d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ea3a73c195a79e6740ae594ee1a14c8bf7a938d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ea3a73c195a79e6740ae594ee1a14c8bf7a938d/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7f016919fc8a042b83812ae5f34946ef23b7adb3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f016919fc8a042b83812ae5f34946ef23b7adb3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f016919fc8a042b83812ae5f34946ef23b7adb3"}], "stats": {"total": 166, "additions": 137, "deletions": 29}, "files": [{"sha": "dc3f0e94b1789a3e42d4b8a82e3a7d3e3fc7c58c", "filename": "gcc/ipa-cp.cc", "status": "modified", "additions": 51, "deletions": 24, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ea3a73c195a79e6740ae594ee1a14c8bf7a938d/gcc%2Fipa-cp.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ea3a73c195a79e6740ae594ee1a14c8bf7a938d/gcc%2Fipa-cp.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.cc?ref=7ea3a73c195a79e6740ae594ee1a14c8bf7a938d", "patch": "@@ -306,17 +306,18 @@ struct ipcp_agg_lattice : public ipcp_lattice<tree>\n class ipcp_bits_lattice\n {\n public:\n-  bool bottom_p () { return m_lattice_val == IPA_BITS_VARYING; }\n-  bool top_p () { return m_lattice_val == IPA_BITS_UNDEFINED; }\n-  bool constant_p () { return m_lattice_val == IPA_BITS_CONSTANT; }\n+  bool bottom_p () const { return m_lattice_val == IPA_BITS_VARYING; }\n+  bool top_p () const { return m_lattice_val == IPA_BITS_UNDEFINED; }\n+  bool constant_p () const { return m_lattice_val == IPA_BITS_CONSTANT; }\n   bool set_to_bottom ();\n   bool set_to_constant (widest_int, widest_int);\n+  bool known_nonzero_p () const;\n \n-  widest_int get_value () { return m_value; }\n-  widest_int get_mask () { return m_mask; }\n+  widest_int get_value () const { return m_value; }\n+  widest_int get_mask () const { return m_mask; }\n \n   bool meet_with (ipcp_bits_lattice& other, unsigned, signop,\n-\t\t  enum tree_code, tree);\n+\t\t  enum tree_code, tree, bool);\n \n   bool meet_with (widest_int, widest_int, unsigned);\n \n@@ -330,7 +331,7 @@ class ipcp_bits_lattice\n      value is known to be constant.  */\n   widest_int m_value, m_mask;\n \n-  bool meet_with_1 (widest_int, widest_int, unsigned);\n+  bool meet_with_1 (widest_int, widest_int, unsigned, bool);\n   void get_value_and_mask (tree, widest_int *, widest_int *);\n };\n \n@@ -1081,6 +1082,16 @@ ipcp_bits_lattice::set_to_constant (widest_int value, widest_int mask)\n   return true;\n }\n \n+/* Return true if any of the known bits are non-zero.  */\n+\n+bool\n+ipcp_bits_lattice::known_nonzero_p () const\n+{\n+  if (!constant_p ())\n+    return false;\n+  return wi::ne_p (wi::bit_and (wi::bit_not (m_mask), m_value), 0);\n+}\n+\n /* Convert operand to value, mask form.  */\n \n void\n@@ -1103,16 +1114,19 @@ ipcp_bits_lattice::get_value_and_mask (tree operand, widest_int *valuep, widest_\n /* Meet operation, similar to ccp_lattice_meet, we xor values\n    if this->value, value have different values at same bit positions, we want\n    to drop that bit to varying. Return true if mask is changed.\n-   This function assumes that the lattice value is in CONSTANT state  */\n+   This function assumes that the lattice value is in CONSTANT state.  If\n+   DROP_ALL_ONES, mask out any known bits with value one afterwards.  */\n \n bool\n ipcp_bits_lattice::meet_with_1 (widest_int value, widest_int mask,\n-\t\t\t\tunsigned precision)\n+\t\t\t\tunsigned precision, bool drop_all_ones)\n {\n   gcc_assert (constant_p ());\n \n   widest_int old_mask = m_mask;\n   m_mask = (m_mask | mask) | (m_value ^ value);\n+  if (drop_all_ones)\n+    m_mask |= m_value;\n   m_value &= ~m_mask;\n \n   if (wi::sext (m_mask, precision) == -1)\n@@ -1138,16 +1152,18 @@ ipcp_bits_lattice::meet_with (widest_int value, widest_int mask,\n       return set_to_constant (value, mask);\n     }\n \n-  return meet_with_1 (value, mask, precision);\n+  return meet_with_1 (value, mask, precision, false);\n }\n \n /* Meet bits lattice with the result of bit_value_binop (other, operand)\n    if code is binary operation or bit_value_unop (other) if code is unary op.\n-   In the case when code is nop_expr, no adjustment is required. */\n+   In the case when code is nop_expr, no adjustment is required.  If\n+   DROP_ALL_ONES, mask out any known bits with value one afterwards.  */\n \n bool\n ipcp_bits_lattice::meet_with (ipcp_bits_lattice& other, unsigned precision,\n-\t\t\t      signop sgn, enum tree_code code, tree operand)\n+\t\t\t      signop sgn, enum tree_code code, tree operand,\n+\t\t\t      bool drop_all_ones)\n {\n   if (other.bottom_p ())\n     return set_to_bottom ();\n@@ -1186,12 +1202,18 @@ ipcp_bits_lattice::meet_with (ipcp_bits_lattice& other, unsigned precision,\n \n   if (top_p ())\n     {\n+      if (drop_all_ones)\n+\t{\n+\t  adjusted_mask |= adjusted_value;\n+\t  adjusted_value &= ~adjusted_mask;\n+\t}\n       if (wi::sext (adjusted_mask, precision) == -1)\n \treturn set_to_bottom ();\n       return set_to_constant (adjusted_value, adjusted_mask);\n     }\n   else\n-    return meet_with_1 (adjusted_value, adjusted_mask, precision);\n+    return meet_with_1 (adjusted_value, adjusted_mask, precision,\n+\t\t\tdrop_all_ones);\n }\n \n /* Mark bot aggregate and scalar lattices as containing an unknown variable,\n@@ -1477,6 +1499,9 @@ ipa_get_jf_ancestor_result (struct ipa_jump_func *jfunc, tree input)\n \t\t     fold_build2 (MEM_REF, TREE_TYPE (TREE_TYPE (input)), input,\n \t\t\t\t  build_int_cst (ptr_type_node, byte_offset)));\n     }\n+  else if (ipa_get_jf_ancestor_keep_null (jfunc)\n+\t   && zerop (input))\n+    return input;\n   else\n     return NULL_TREE;\n }\n@@ -2373,6 +2398,7 @@ propagate_bits_across_jump_function (cgraph_edge *cs, int idx,\n       tree operand = NULL_TREE;\n       enum tree_code code;\n       unsigned src_idx;\n+      bool keep_null = false;\n \n       if (jfunc->type == IPA_JF_PASS_THROUGH)\n \t{\n@@ -2385,7 +2411,9 @@ propagate_bits_across_jump_function (cgraph_edge *cs, int idx,\n \t{\n \t  code = POINTER_PLUS_EXPR;\n \t  src_idx = ipa_get_jf_ancestor_formal_id (jfunc);\n-\t  unsigned HOST_WIDE_INT offset = ipa_get_jf_ancestor_offset (jfunc) / BITS_PER_UNIT;\n+\t  unsigned HOST_WIDE_INT offset\n+\t    = ipa_get_jf_ancestor_offset (jfunc) / BITS_PER_UNIT;\n+\t  keep_null = (ipa_get_jf_ancestor_keep_null (jfunc) || !offset);\n \t  operand = build_int_cstu (size_type_node, offset);\n \t}\n \n@@ -2402,18 +2430,17 @@ propagate_bits_across_jump_function (cgraph_edge *cs, int idx,\n \t result of x & 0xff == 0xff, which gets computed during ccp1 pass\n \t and we store it in jump function during analysis stage.  */\n \n-      if (src_lats->bits_lattice.bottom_p ()\n-\t  && jfunc->bits)\n-\treturn dest_lattice->meet_with (jfunc->bits->value, jfunc->bits->mask,\n-\t\t\t\t\tprecision);\n-      else\n-\treturn dest_lattice->meet_with (src_lats->bits_lattice, precision, sgn,\n-\t\t\t\t\tcode, operand);\n+      if (!src_lats->bits_lattice.bottom_p ())\n+\t{\n+\t  bool drop_all_ones\n+\t    = keep_null && !src_lats->bits_lattice.known_nonzero_p ();\n+\n+\t  return dest_lattice->meet_with (src_lats->bits_lattice, precision,\n+\t\t\t\t\t  sgn, code, operand, drop_all_ones);\n+\t}\n     }\n \n-  else if (jfunc->type == IPA_JF_ANCESTOR)\n-    return dest_lattice->set_to_bottom ();\n-  else if (jfunc->bits)\n+  if (jfunc->bits)\n     return dest_lattice->meet_with (jfunc->bits->value, jfunc->bits->mask,\n \t\t\t\t    precision);\n   else"}, {"sha": "0e5966332eb3f171ac750665094f6162099c0b1a", "filename": "gcc/ipa-prop.cc", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ea3a73c195a79e6740ae594ee1a14c8bf7a938d/gcc%2Fipa-prop.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ea3a73c195a79e6740ae594ee1a14c8bf7a938d/gcc%2Fipa-prop.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.cc?ref=7ea3a73c195a79e6740ae594ee1a14c8bf7a938d", "patch": "@@ -357,6 +357,8 @@ ipa_print_node_jump_functions_for_edge (FILE *f, struct cgraph_edge *cs)\n \t\t   jump_func->value.ancestor.offset);\n \t  if (jump_func->value.ancestor.agg_preserved)\n \t    fprintf (f, \", agg_preserved\");\n+\t  if (jump_func->value.ancestor.keep_null)\n+\t    fprintf (f, \", keep_null\");\n \t  fprintf (f, \"\\n\");\n \t}\n \n@@ -601,12 +603,13 @@ ipa_set_jf_arith_pass_through (struct ipa_jump_func *jfunc, int formal_id,\n \n static void\n ipa_set_ancestor_jf (struct ipa_jump_func *jfunc, HOST_WIDE_INT offset,\n-\t\t     int formal_id, bool agg_preserved)\n+\t\t     int formal_id, bool agg_preserved, bool keep_null)\n {\n   jfunc->type = IPA_JF_ANCESTOR;\n   jfunc->value.ancestor.formal_id = formal_id;\n   jfunc->value.ancestor.offset = offset;\n   jfunc->value.ancestor.agg_preserved = agg_preserved;\n+  jfunc->value.ancestor.keep_null = keep_null;\n }\n \n /* Get IPA BB information about the given BB.  FBI is the context of analyzis\n@@ -1438,7 +1441,8 @@ compute_complex_assign_jump_func (struct ipa_func_body_info *fbi,\n   index = ipa_get_param_decl_index (info, SSA_NAME_VAR (ssa));\n   if (index >= 0 && param_type && POINTER_TYPE_P (param_type))\n     ipa_set_ancestor_jf (jfunc, offset,  index,\n-\t\t\t parm_ref_data_pass_through_p (fbi, index, call, ssa));\n+\t\t\t parm_ref_data_pass_through_p (fbi, index, call, ssa),\n+\t\t\t false);\n }\n \n /* Extract the base, offset and MEM_REF expression from a statement ASSIGN if\n@@ -1564,7 +1568,8 @@ compute_complex_ancestor_jump_func (struct ipa_func_body_info *fbi,\n     }\n \n   ipa_set_ancestor_jf (jfunc, offset, index,\n-\t\t       parm_ref_data_pass_through_p (fbi, index, call, parm));\n+\t\t       parm_ref_data_pass_through_p (fbi, index, call, parm),\n+\t\t       true);\n }\n \n /* Inspect the given TYPE and return true iff it has the same structure (the\n@@ -3250,6 +3255,7 @@ update_jump_functions_after_inlining (struct cgraph_edge *cs,\n \t      dst->value.ancestor.offset += src->value.ancestor.offset;\n \t      dst->value.ancestor.agg_preserved &=\n \t\tsrc->value.ancestor.agg_preserved;\n+\t      dst->value.ancestor.keep_null |= src->value.ancestor.keep_null;\n \t    }\n \t  else\n \t    ipa_set_jf_unknown (dst);\n@@ -3327,7 +3333,8 @@ update_jump_functions_after_inlining (struct cgraph_edge *cs,\n \t\t    ipa_set_ancestor_jf (dst,\n \t\t\t\t\t ipa_get_jf_ancestor_offset (src),\n \t\t\t\t\t ipa_get_jf_ancestor_formal_id (src),\n-\t\t\t\t\t agg_p);\n+\t\t\t\t\t agg_p,\n+\t\t\t\t\t ipa_get_jf_ancestor_keep_null (src));\n \t\t    break;\n \t\t  }\n \t\tdefault:\n@@ -4760,6 +4767,7 @@ ipa_write_jump_function (struct output_block *ob,\n       streamer_write_uhwi (ob, jump_func->value.ancestor.formal_id);\n       bp = bitpack_create (ob->main_stream);\n       bp_pack_value (&bp, jump_func->value.ancestor.agg_preserved, 1);\n+      bp_pack_value (&bp, jump_func->value.ancestor.keep_null, 1);\n       streamer_write_bitpack (&bp);\n       break;\n     default:\n@@ -4885,7 +4893,9 @@ ipa_read_jump_function (class lto_input_block *ib,\n \tint formal_id = streamer_read_uhwi (ib);\n \tstruct bitpack_d bp = streamer_read_bitpack (ib);\n \tbool agg_preserved = bp_unpack_value (&bp, 1);\n-\tipa_set_ancestor_jf (jump_func, offset, formal_id, agg_preserved);\n+\tbool keep_null = bp_unpack_value (&bp, 1);\n+\tipa_set_ancestor_jf (jump_func, offset, formal_id, agg_preserved,\n+\t\t\t     keep_null);\n \tbreak;\n       }\n     default:"}, {"sha": "b22dfb5315ccdb89cc5c112fca78284a81548697", "filename": "gcc/ipa-prop.h", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ea3a73c195a79e6740ae594ee1a14c8bf7a938d/gcc%2Fipa-prop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ea3a73c195a79e6740ae594ee1a14c8bf7a938d/gcc%2Fipa-prop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.h?ref=7ea3a73c195a79e6740ae594ee1a14c8bf7a938d", "patch": "@@ -143,6 +143,8 @@ struct GTY(()) ipa_ancestor_jf_data\n   int formal_id;\n   /* Flag with the same meaning like agg_preserve in ipa_pass_through_data.  */\n   unsigned agg_preserved : 1;\n+  /* When set, the operation should not have any effect on NULL pointers.  */\n+  unsigned keep_null : 1;\n };\n \n /* A jump function for an aggregate part at a given offset, which describes how\n@@ -438,6 +440,17 @@ ipa_get_jf_ancestor_type_preserved (struct ipa_jump_func *jfunc)\n   return jfunc->value.ancestor.agg_preserved;\n }\n \n+/* Return if jfunc represents an operation whether we first check the formal\n+   parameter for non-NULLness unless it does not matter because the offset is\n+   zero anyway.  */\n+\n+static inline bool\n+ipa_get_jf_ancestor_keep_null (struct ipa_jump_func *jfunc)\n+{\n+  gcc_checking_assert (jfunc->type == IPA_JF_ANCESTOR);\n+  return jfunc->value.ancestor.keep_null;\n+}\n+\n /* Class for allocating a bundle of various potentially known properties about\n    actual arguments of a particular call on stack for the usual case and on\n    heap only if there are unusually many arguments.  The data is deallocated"}, {"sha": "e2fbb45d3cc171999ede5906cfbd99b012c0678f", "filename": "gcc/testsuite/gcc.dg/ipa/pr103083-1.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ea3a73c195a79e6740ae594ee1a14c8bf7a938d/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpr103083-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ea3a73c195a79e6740ae594ee1a14c8bf7a938d/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpr103083-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpr103083-1.c?ref=7ea3a73c195a79e6740ae594ee1a14c8bf7a938d", "patch": "@@ -0,0 +1,28 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -Wno-pointer-to-int-cast\" } */\n+\n+struct b {int b;};\n+struct a {int a; struct b b;};\n+\n+long i;\n+\n+__attribute__ ((noinline))\n+static void test2 (struct b *b)\n+{\n+  if (((int)b)&4)\n+    __builtin_abort ();\n+}\n+\n+__attribute__ ((noinline))\n+static void\n+test (struct a *a)\n+{\n+  test2(a? &a->b : 0);\n+}\n+\n+int\n+main()\n+{\n+  test(0);\n+  return 0;\n+}"}, {"sha": "ae1b905af8149fc54e32a153359e539f23de59af", "filename": "gcc/testsuite/gcc.dg/ipa/pr103083-2.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ea3a73c195a79e6740ae594ee1a14c8bf7a938d/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpr103083-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ea3a73c195a79e6740ae594ee1a14c8bf7a938d/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpr103083-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpr103083-2.c?ref=7ea3a73c195a79e6740ae594ee1a14c8bf7a938d", "patch": "@@ -0,0 +1,30 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fno-ipa-bit-cp -fdump-tree-optimized\" } */\n+\n+struct b {int b;};\n+struct a {int a; struct b b;};\n+\n+void remove_any_mention (void);\n+\n+__attribute__ ((noinline))\n+static void test2 (struct b *b)\n+{\n+  if (b)\n+    remove_any_mention ();\n+}\n+\n+__attribute__ ((noinline))\n+static void\n+test (struct a *a)\n+{\n+  test2(a? &a->b : 0);\n+}\n+\n+int\n+foo()\n+{\n+  test(0);\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"remove_any_mention\" \"optimized\" } } */"}]}