{"sha": "3ac01fdeef1976c9150d3efa1b5c2915f210a78f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2FjMDFmZGVlZjE5NzZjOTE1MGQzZWZhMWI1YzI5MTVmMjEwYTc4Zg==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2005-07-27T13:26:55Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2005-07-27T13:26:55Z"}, "message": "re PR tree-optimization/22325 (missed optimization in loop)\n\n\tPR tree-optimization/22325\n\t* tree-flow.h (compute_phi_arg_on_exit, force_expr_to_var_cost):\n\tDeclare.\n\t* tree-scalar-evolution.c (scev_const_prop): Add generic final\n\tvalue replacement.\n\t* tree-ssa-loop-ivopts.c (force_expr_to_var_cost): Split from ...\n\t(force_var_cost): ... this function.\n\t(compute_phi_arg_on_exit): Export.\n\nFrom-SVN: r102426", "tree": {"sha": "6e79a38332103beceb652d9c10b349aa8b01cb3c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6e79a38332103beceb652d9c10b349aa8b01cb3c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3ac01fdeef1976c9150d3efa1b5c2915f210a78f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ac01fdeef1976c9150d3efa1b5c2915f210a78f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ac01fdeef1976c9150d3efa1b5c2915f210a78f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ac01fdeef1976c9150d3efa1b5c2915f210a78f/comments", "author": null, "committer": null, "parents": [{"sha": "77fcaf4b701894705944491ea1aa46b68ac271a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77fcaf4b701894705944491ea1aa46b68ac271a3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/77fcaf4b701894705944491ea1aa46b68ac271a3"}], "stats": {"total": 113, "additions": 94, "deletions": 19}, "files": [{"sha": "13c7a178992a6b7b69b68b5dffe49bd8246b1ddf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ac01fdeef1976c9150d3efa1b5c2915f210a78f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ac01fdeef1976c9150d3efa1b5c2915f210a78f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3ac01fdeef1976c9150d3efa1b5c2915f210a78f", "patch": "@@ -1,3 +1,14 @@\n+2005-07-27  Zdenek Dvorak  <dvorakz@suse.cz>\n+\n+\tPR tree-optimization/22325\n+\t* tree-flow.h (compute_phi_arg_on_exit, force_expr_to_var_cost):\n+\tDeclare.\n+\t* tree-scalar-evolution.c (scev_const_prop): Add generic final\n+\tvalue replacement.\n+\t* tree-ssa-loop-ivopts.c (force_expr_to_var_cost): Split from ...\n+\t(force_var_cost): ... this function.\n+\t(compute_phi_arg_on_exit): Export.\n+\n 2005-07-27  Zdenek Dvorak  <dvorakz@suse.cz>\n \n \tPR tree-optimization/20773"}, {"sha": "bfbceba9f27b08c7b3d5fcac6738c784a108b964", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ac01fdeef1976c9150d3efa1b5c2915f210a78f/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ac01fdeef1976c9150d3efa1b5c2915f210a78f/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=3ac01fdeef1976c9150d3efa1b5c2915f210a78f", "patch": "@@ -738,6 +738,8 @@ bool for_each_index (tree *, bool (*) (tree, tree *, void *), void *);\n void create_iv (tree, tree, tree, struct loop *, block_stmt_iterator *, bool,\n \t\ttree *, tree *);\n void split_loop_exit_edge (edge);\n+void compute_phi_arg_on_exit (edge, tree, tree);\n+unsigned force_expr_to_var_cost (tree);\n basic_block bsi_insert_on_edge_immediate_loop (edge, tree);\n void standard_iv_increment_position (struct loop *, block_stmt_iterator *,\n \t\t\t\t     bool *);"}, {"sha": "52a2d1a612c714ccc475d7a4e626911d21742529", "filename": "gcc/tree-scalar-evolution.c", "status": "modified", "additions": 57, "deletions": 4, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ac01fdeef1976c9150d3efa1b5c2915f210a78f/gcc%2Ftree-scalar-evolution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ac01fdeef1976c9150d3efa1b5c2915f210a78f/gcc%2Ftree-scalar-evolution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.c?ref=3ac01fdeef1976c9150d3efa1b5c2915f210a78f", "patch": "@@ -2608,8 +2608,8 @@ scev_finalize (void)\n }\n \n /* Replace ssa names for that scev can prove they are constant by the\n-   appropriate constants.  Most importantly, this takes care of final\n-   value replacement.\n+   appropriate constants.  Also perform final value replacement in loops,\n+   in case the replacement expressions are cheap.\n    \n    We only consider SSA names defined by phi nodes; rest is left to the\n    ordinary constant propagation pass.  */\n@@ -2618,9 +2618,10 @@ void\n scev_const_prop (void)\n {\n   basic_block bb;\n-  tree name, phi, type, ev;\n-  struct loop *loop;\n+  tree name, phi, next_phi, type, ev;\n+  struct loop *loop, *ex_loop;\n   bitmap ssa_names_to_remove = NULL;\n+  unsigned i;\n \n   if (!current_loops)\n     return;\n@@ -2675,4 +2676,56 @@ scev_const_prop (void)\n       BITMAP_FREE (ssa_names_to_remove);\n       scev_reset ();\n     }\n+\n+  /* Now the regular final value replacement.  */\n+  for (i = current_loops->num - 1; i > 0; i--)\n+    {\n+      edge exit;\n+      tree def, stmts;\n+\n+      loop = current_loops->parray[i];\n+      if (!loop)\n+\tcontinue;\n+\n+      /* If we do not know exact number of iterations of the loop, we cannot\n+\t replace the final value.  */\n+      exit = loop->single_exit;\n+      if (!exit\n+\t  || number_of_iterations_in_loop (loop) == chrec_dont_know)\n+\tcontinue;\n+      ex_loop = exit->dest->loop_father;\n+\n+      for (phi = phi_nodes (exit->dest); phi; phi = next_phi)\n+\t{\n+\t  next_phi = PHI_CHAIN (phi);\n+\t  def = PHI_ARG_DEF_FROM_EDGE (phi, exit);\n+\t  if (!is_gimple_reg (def)\n+\t      || expr_invariant_in_loop_p (loop, def))\n+\t    continue;\n+\n+\t  if (!POINTER_TYPE_P (TREE_TYPE (def))\n+\t      && !INTEGRAL_TYPE_P (TREE_TYPE (def)))\n+\t    continue;\n+\n+\t  def = analyze_scalar_evolution_in_loop (ex_loop, ex_loop, def);\n+\t  if (!tree_does_not_contain_chrecs (def)\n+\t      || chrec_contains_symbols_defined_in_loop (def, loop->num))\n+\t    continue;\n+\n+\t  /* If computing the expression is expensive, let it remain in\n+\t     loop.  TODO -- we should take the cost of computing the expression\n+\t     in loop into account.  */\n+\t  if (force_expr_to_var_cost (def) >= target_spill_cost)\n+\t    continue;\n+\n+\t  if (is_gimple_val (def))\n+\t    stmts = NULL_TREE;\n+\t  else\n+\t    def = force_gimple_operand (def, &stmts, true,\n+\t\t\t\t\tSSA_NAME_VAR (PHI_RESULT (phi)));\n+\t  SET_USE (PHI_ARG_DEF_PTR_FROM_EDGE (phi, exit), def);\n+\t  if (stmts)\n+\t    compute_phi_arg_on_exit (exit, stmts, def);\n+\t}\n+    }\n }"}, {"sha": "e5a8d85504d4dda56e7f6a75f2883c05368222af", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 24, "deletions": 15, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ac01fdeef1976c9150d3efa1b5c2915f210a78f/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ac01fdeef1976c9150d3efa1b5c2915f210a78f/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=3ac01fdeef1976c9150d3efa1b5c2915f210a78f", "patch": "@@ -3415,12 +3415,11 @@ get_address_cost (bool symbol_present, bool var_present,\n \n   return cost + acost;\n }\n-/* Estimates cost of forcing EXPR into a variable.  DEPENDS_ON is a set of the\n-   invariants the computation depends on.  */\n \n-static unsigned\n-force_var_cost (struct ivopts_data *data,\n-\t\ttree expr, bitmap *depends_on)\n+/* Estimates cost of forcing expression EXPR into a variable.  */\n+\n+unsigned\n+force_expr_to_var_cost (tree expr)\n {\n   static bool costs_initialized = false;\n   static unsigned integer_cost;\n@@ -3452,7 +3451,7 @@ force_var_cost (struct ivopts_data *data,\n \t\t\t\t    build_int_cst_type (type, 2000))) + 1;\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \t{\n-\t  fprintf (dump_file, \"force_var_cost:\\n\");\n+\t  fprintf (dump_file, \"force_expr_to_var_cost:\\n\");\n \t  fprintf (dump_file, \"  integer %d\\n\", (int) integer_cost);\n \t  fprintf (dump_file, \"  symbol %d\\n\", (int) symbol_cost);\n \t  fprintf (dump_file, \"  address %d\\n\", (int) address_cost);\n@@ -3465,12 +3464,6 @@ force_var_cost (struct ivopts_data *data,\n \n   STRIP_NOPS (expr);\n \n-  if (depends_on)\n-    {\n-      fd_ivopts_data = data;\n-      walk_tree (&expr, find_depends, depends_on, NULL);\n-    }\n-\n   if (SSA_VAR_P (expr))\n     return 0;\n \n@@ -3505,12 +3498,12 @@ force_var_cost (struct ivopts_data *data,\n       if (is_gimple_val (op0))\n \tcost0 = 0;\n       else\n-\tcost0 = force_var_cost (data, op0, NULL);\n+\tcost0 = force_expr_to_var_cost (op0);\n \n       if (is_gimple_val (op1))\n \tcost1 = 0;\n       else\n-\tcost1 = force_var_cost (data, op1, NULL);\n+\tcost1 = force_expr_to_var_cost (op1);\n \n       break;\n \n@@ -3550,6 +3543,22 @@ force_var_cost (struct ivopts_data *data,\n   return cost < target_spill_cost ? cost : target_spill_cost;\n }\n \n+/* Estimates cost of forcing EXPR into a variable.  DEPENDS_ON is a set of the\n+   invariants the computation depends on.  */\n+\n+static unsigned\n+force_var_cost (struct ivopts_data *data,\n+\t\ttree expr, bitmap *depends_on)\n+{\n+  if (depends_on)\n+    {\n+      fd_ivopts_data = data;\n+      walk_tree (&expr, find_depends, depends_on, NULL);\n+    }\n+\n+  return force_expr_to_var_cost (expr);\n+}\n+\n /* Estimates cost of expressing address ADDR  as var + symbol + offset.  The\n    value of offset is added to OFFSET, SYMBOL_PRESENT and VAR_PRESENT are set\n    to false if the corresponding part is missing.  DEPENDS_ON is a set of the\n@@ -5600,7 +5609,7 @@ protect_loop_closed_ssa_form (edge exit, tree stmt)\n    so that they are emitted on the correct place, and so that the loop closed\n    ssa form is preserved.  */\n \n-static void\n+void\n compute_phi_arg_on_exit (edge exit, tree stmts, tree op)\n {\n   tree_stmt_iterator tsi;"}]}