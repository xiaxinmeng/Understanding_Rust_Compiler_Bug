{"sha": "1141ed3f71c8a82067dbbbed6ec87c607bfd0be9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTE0MWVkM2Y3MWM4YTgyMDY3ZGJiYmVkNmVjODdjNjA3YmZkMGJlOQ==", "commit": {"author": {"name": "Balaji V. Iyer", "email": "balaji.v.iyer@intel.com", "date": "2013-06-28T20:04:36Z"}, "committer": {"name": "Balaji V. Iyer", "email": "bviyer@gcc.gnu.org", "date": "2013-06-28T20:04:36Z"}, "message": "Implemented Jason Merrill's suggestions on Array Notation C++.\n\ngcc/ChangeLog\n2013-06-28  Balaji V. Iyer  <balaji.v.iyer@intel.com>\n\n        * builtins.def: Fixed the function type of CILKPLUS_BUILTIN.\n\ngcc/c/ChangeLog\n2013-06-28  Balaji V. Iyer  <balaji.v.iyer@intel.com>\n\n        * c-parser.c (c_parser_array_notation): Removed rejection of array\n        notations in an array of function pointers.\n\ngcc/c-family/ChangeLog\n2013-06-28  Balaji V. Iyer  <balaji.v.iyer@intel.com>\n\n        * array-notation-common.c (length_mismatch_in_expr_p): Collapsed two\n        if-statements and compared the trees directly using tree_int_cst_equal.\n        (find_rank): Checked for array notations in function name to handle\n        array notations in function pointers.\n        (extract_array_notation_exprs): Likewise.\n        (replace_array_notations): Likewise.\n        (cilkplus_extract_an_triplets): Replaced safe_push with\n        safe_grow_cleared.  Also removed an unnecessary check to see if the\n        node is of type ARRAY_NOTATION_REF.\n        (fix_sec_implicit_args): Removed an unnecessary check for ADDR_EXPR.\n        Also switched two if-statements to remove an unnecessary comparison.\n\n\ngcc/cp/ChangeLog\n2013-06-28  Balaji V. Iyer  <balaji.v.iyer@intel.com>\n\n        * parser.c (cp_parser_array_notation): Removed rejection array notation\n        of type function pointers. Added handling of array expressions when\n        Cilk Plus is enabled.  Took out type-checking.\n        (cp_parser_postfix_open_square_expression): Moved normal array expr.\n        parsing into cp_parser_array_notation when cilkplus is enabled.\n        (cp_parser_compound_statement): Removed expansion of array notations.\n        (cp_parser_ctor_initializer_opt_and_function_body): Likewise.\n        (cp_parser_function_definition_after_declarator): Likewise.\n        (cp_parser_selection_statement): Removed error reporting.\n        (cp_parser_iteration_statement): Likewise.\n        (cp_parser_direct_declarator): Removed error checking/reporting if\n        array notations are used in the declarator.\n        * pt.c (instantiate_decl): Likewise.\n        (type_unification_real): Removed a check for ARRAY_NOTATION_REF.\n        (cxx_eval_constant_expression): Removed ARRAY_NOTATION_REF case.\n        (potential_constant_expression_1): Returned false for ARRAY_NOTATION_REF\n        case.\n        * cp-gimplify.c (cp_genericize): Added expansion of array notation\n        expressions here.\n        * cp-array-notation.c (make_triplet_val_inv): Removed loc and cry \n        parameters.  Replaced build_decls with get_temp_regvar with type as\n        ptrdiff.\n        (create_array_refs): Made the type-casting to ptrdiff_type.\n        (replace_invariant_var): Added a check for void return type before \n\tcreating new var.  Replaced build_decl and build_min_nt_loc with\n        get_temp_regvar.\n        (expand_an_in_modify_expr): Ditto.  Replaced body of redundant else with\n        gcc_unreachable.  Removed few unwanted checks.  Made induction variable\n        type as ptrdiff_type.  Removed loc and complain arguments passed into\n        make_triplet_val_inv.  Replaced all modify expression's code from NOP\n        EXPR to INIT EXPR.  Replaced all forceful appending into stmt. list\n        with the non-forceful one.  Replaced some integer conversion and\n        equality-checking to using tree_int_cst_equal.\n        (expand_sec_reduce_builtin): All changes mentioned in above function\n        expand_an_in_modify_expr.  Made the new variable type of\n        SEC_REDUCE_ANY/ALL_{NON}ZERO intrinsic functions as bool.\n        (expand_array_notation_exprs): Removed SWITCH_EXPR case.  Moved all\n        the error reporting from parser to this function.  Removed unwanted\n        statements and checks from SWITCH_STMT, WHILE_STMT, and DO_STMT cases.\n        (cilkplus_an_triplet_types_ok_p): Removed rejection of array notation\n        in function pointers.\n        (cp_expand_cond_array_notations): Added a new if statements to check\n        if condition has a zero rank.  If so, then just return.\n        (expand_return_expr): Added a check for return expressions with a rank.\n        Replaced get_tmp_regvar with a create_temporary_var.\n        (build_array_notation_ref): Simplified and removed unwanted if-stmts.\n        Moved common code outside if-statements.  Moved type-checking from\n        parser to here.\n        * semantics.c (finish_return_stmt): Removed a check for return exprs.\n        with a rank.\n        * call.c (convert_like_real): Removed a check for array notation\n        expression in a function.\n        (build_over_call): Likewise.\n        (magic_varargs_p): Added a check for builtin array notation function.\n        Made this function non-static and removed its prototype.\n        * cp-tree.h (magic_varargs_p): New prototype.\n        * typeck.c (cp_build_function_call_vec): Removed automatic setting of\n        nargs to the param->length when builtin reduction function is used.\n        (convert_arguments): Replaced check for a constant_p function with\n        margic_varargs_p function call.\n        (cp_build_binary_op): Removed calling of the function\n        find_correct_array_notation_type.\n        (cp_build_addr_expr_1): Removed an unwanted if-statement.\n        (convert_for_assignment): Removed automatic return of rhs when array\n        notation builtin function is used.\n\ngcc/testsuite/ChangeLog\n2013-06-28  Balaji V. Iyer  <balaji.v.iyer@intel.com>\n\n        * c-c++-common/cilk-plus/AN/decl-ptr-colon.c (main): Made this testcase\n        c specific.\n        * c-c++-common/cilk-plus/AN/decl-ptr-colon.c (main): Changed dg-error\n        strings to match the fixed error messages.\n        * c-c++-common/cilk-plus/AN/misc.c (main): Likewise.\n        * c-c++-common/cilk-plus/AN/rank_mismatch.c (main): Added a new error\n        message check.\n\nFrom-SVN: r200554", "tree": {"sha": "b185d91a0ad09f83a8b64c2047d429fd12c60efe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b185d91a0ad09f83a8b64c2047d429fd12c60efe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1141ed3f71c8a82067dbbbed6ec87c607bfd0be9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1141ed3f71c8a82067dbbbed6ec87c607bfd0be9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1141ed3f71c8a82067dbbbed6ec87c607bfd0be9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1141ed3f71c8a82067dbbbed6ec87c607bfd0be9/comments", "author": null, "committer": null, "parents": [{"sha": "e32e4c4a8826f872814b58deba660f6bb31e7b21", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e32e4c4a8826f872814b58deba660f6bb31e7b21", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e32e4c4a8826f872814b58deba660f6bb31e7b21"}], "stats": {"total": 1369, "additions": 563, "deletions": 806}, "files": [{"sha": "0ac6e1b3d261b452015df25216e1b2e665dced97", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1141ed3f71c8a82067dbbbed6ec87c607bfd0be9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1141ed3f71c8a82067dbbbed6ec87c607bfd0be9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1141ed3f71c8a82067dbbbed6ec87c607bfd0be9", "patch": "@@ -1,3 +1,7 @@\n+2013-06-28  Balaji V. Iyer  <balaji.v.iyer@intel.com>\n+\n+\t* builtins.def: Fixed the function type of CILKPLUS_BUILTIN.\n+\t\n 2013-06-28  Vladimir Makarov  <vmakarov@redhat.com>\n \n \t* lra-constraints.c (need_for_split_p): Check call used hard regs"}, {"sha": "9b55b1f7a96537b790f9330a5d78ee59e3b65068", "filename": "gcc/builtins.def", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1141ed3f71c8a82067dbbbed6ec87c607bfd0be9/gcc%2Fbuiltins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1141ed3f71c8a82067dbbbed6ec87c607bfd0be9/gcc%2Fbuiltins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.def?ref=1141ed3f71c8a82067dbbbed6ec87c607bfd0be9", "patch": "@@ -158,9 +158,9 @@ along with GCC; see the file COPYING3.  If not see\n \t       (flag_asan || flag_tsan))\n \n #undef DEF_CILKPLUS_BUILTIN\n-#define DEF_CILKPLUS_BUILTIN(ENUM, NAME, TYPE, ATTRS) \\\n-  DEF_BUILTIN (ENUM, NAME, BUILT_IN_NORMAL, TYPE, TYPE, \\\n-  \t       false, false, true, ATTRS, false, flag_enable_cilkplus)\n+#define DEF_CILKPLUS_BUILTIN(ENUM, NAME, TYPE, ATTRS)  \\\n+  DEF_BUILTIN (ENUM, NAME, BUILT_IN_NORMAL, BT_FN_INT_VAR, BT_LAST, \\\n+  \t       false, false, false, ATTRS, false, flag_enable_cilkplus) \n \n /* Define an attribute list for math functions that are normally\n    \"impure\" because some of them may write into global memory for"}, {"sha": "5e17009ee87ab6c9b9eb1c3d894de39aef72269d", "filename": "gcc/c-family/array-notation-common.c", "status": "modified", "additions": 46, "deletions": 47, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1141ed3f71c8a82067dbbbed6ec87c607bfd0be9/gcc%2Fc-family%2Farray-notation-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1141ed3f71c8a82067dbbbed6ec87c607bfd0be9/gcc%2Fc-family%2Farray-notation-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Farray-notation-common.c?ref=1141ed3f71c8a82067dbbbed6ec87c607bfd0be9", "patch": "@@ -101,15 +101,11 @@ length_mismatch_in_expr_p (location_t loc, vec<vec<an_parts> >list)\n \t      /* If length is a INTEGER, and list[ii][jj] is an integer then\n \t\t check if they are equal.  If they are not equal then return\n \t\t true.  */\n-\t      if (TREE_CODE (list[ii][jj].length) == INTEGER_CST)\n-\t\t{\n-\t\t  l_node = int_cst_value (list[ii][jj].length);\n-\t\t  l_length = int_cst_value (length);\n-\t\t  if (absu_hwi (l_length) != absu_hwi (l_node))\n-\t\t    {\n-\t\t      error_at (loc, \"length mismatch in expression\");\n-\t\t      return true;\n-\t\t    }\n+\t      if (TREE_CODE (list[ii][jj].length) == INTEGER_CST\n+\t\t  && !tree_int_cst_equal (list[ii][jj].length, length))\n+\t\t{ \n+\t\t  error_at (loc, \"length mismatch in expression\"); \n+\t\t  return true;\n \t\t}\n \t    }\n \t  else\n@@ -271,6 +267,8 @@ find_rank (location_t loc, tree orig_expr, tree expr, bool ignore_builtin_fn,\n \t\t/* If it is a built-in function, then we know it returns a \n \t\t   scalar.  */\n \t\treturn true;\n+\t  if (!find_rank (loc, orig_expr, func_name, ignore_builtin_fn, rank))\n+\t    return false;\n \t  FOR_EACH_CALL_EXPR_ARG (arg, iter, expr)\n \t    {\n \t      if (!find_rank (loc, orig_expr, arg, ignore_builtin_fn, rank))\n@@ -358,6 +356,9 @@ extract_array_notation_exprs (tree node, bool ignore_builtin_fn,\n \t  vec_safe_push (*array_list, node);\n \t  return;\n \t}\n+      /* This will extract array notations in function pointers.  */\n+      extract_array_notation_exprs (CALL_EXPR_FN (node), ignore_builtin_fn,\n+\t\t\t\t    array_list);\n       FOR_EACH_CALL_EXPR_ARG (arg, iter, node)\n \textract_array_notation_exprs (arg, ignore_builtin_fn, array_list);\n     } \n@@ -433,6 +434,9 @@ replace_array_notations (tree *orig, bool ignore_builtin_fn,\n \t      }\n \t  return;\n \t}\n+      /* Fixes array notations in array notations in function pointers.  */\n+      replace_array_notations (&CALL_EXPR_FN (*orig), ignore_builtin_fn, list,\n+\t\t\t       array_operand);\n       ii = 0;\n       FOR_EACH_CALL_EXPR_ARG (arg, iter, *orig)\n \t{\n@@ -575,53 +579,49 @@ cilkplus_extract_an_triplets (vec<tree, va_gc> *list, size_t size, size_t rank,\n \t\t\t      vec<vec<struct cilkplus_an_parts> > *node)\n {\n   vec<vec<tree> > array_exprs = vNULL;\n-  struct cilkplus_an_parts init = { NULL_TREE, NULL_TREE, NULL_TREE, NULL_TREE,\n-\t\t\t\t    false };\n+\n   node->safe_grow_cleared (size);\n   array_exprs.safe_grow_cleared (size);\n-  for (size_t ii = 0; ii < size; ii++)\n-    for (size_t jj = 0; jj < rank; jj++)\n+\n+  if (rank > 0)\n+    for (size_t ii = 0; ii < size; ii++)\n       {\n-\t(*node)[ii].safe_push (init);\n-\tarray_exprs[ii].safe_push (NULL_TREE);\n+\t(*node)[ii].safe_grow_cleared (rank);\n+\tarray_exprs[ii].safe_grow_cleared (rank);\n       }\n-\n   for (size_t ii = 0; ii < size; ii++)\n     {\n       size_t jj = 0;\n       tree ii_tree = (*list)[ii];\n       while (ii_tree)\n-\tif (TREE_CODE (ii_tree) == ARRAY_NOTATION_REF)\n-\t  {\n-\t    array_exprs[ii][jj] = ii_tree;\n-\t    jj++;\n-\t    ii_tree = ARRAY_NOTATION_ARRAY (ii_tree);\n-\t  }\n-\telse if (TREE_CODE (ii_tree) == ARRAY_REF)\n-\t  ii_tree = TREE_OPERAND (ii_tree, 0);\n-\telse if (TREE_CODE (ii_tree) == VAR_DECL\n-\t\t || TREE_CODE (ii_tree) == CALL_EXPR\n-\t\t || TREE_CODE (ii_tree) == PARM_DECL)\n-\t  break;\n-\telse\n-\t  gcc_unreachable ();\t\n+\t{\n+\t  if (TREE_CODE (ii_tree) == ARRAY_NOTATION_REF)\n+\t    {\n+\t      array_exprs[ii][jj] = ii_tree;\n+\t      jj++;\n+\t      ii_tree = ARRAY_NOTATION_ARRAY (ii_tree);\n+\t    }\n+\t  else if (TREE_CODE (ii_tree) == ARRAY_REF)\n+\t    ii_tree = TREE_OPERAND (ii_tree, 0);\n+\t  else\n+\t    break;\n+\t}\n     }\n     for (size_t ii = 0; ii < size; ii++)\n       if (TREE_CODE ((*list)[ii]) == ARRAY_NOTATION_REF)\n \tfor (size_t jj = 0; jj < rank; jj++)\n-\t  if (TREE_CODE (array_exprs[ii][jj]) == ARRAY_NOTATION_REF)\n-\t    {\n-\t      tree ii_tree = array_exprs[ii][jj];\n-\t      (*node)[ii][jj].is_vector = true;\n-\t      (*node)[ii][jj].value = ARRAY_NOTATION_ARRAY (ii_tree);\n-\t      (*node)[ii][jj].start = ARRAY_NOTATION_START (ii_tree);\n-\t      (*node)[ii][jj].length =\n-\t\tfold_build1 (CONVERT_EXPR, integer_type_node,\n-\t\t\t     ARRAY_NOTATION_LENGTH (ii_tree));\n-\t      (*node)[ii][jj].stride =\n-\t\tfold_build1 (CONVERT_EXPR, integer_type_node,\n-\t\t\t     ARRAY_NOTATION_STRIDE (ii_tree));\n-\t    }\n+\t  {\n+\t    tree ii_tree = array_exprs[ii][jj];\n+\t    (*node)[ii][jj].is_vector = true;\n+\t    (*node)[ii][jj].value = ARRAY_NOTATION_ARRAY (ii_tree);\n+\t    (*node)[ii][jj].start = ARRAY_NOTATION_START (ii_tree);\n+\t    (*node)[ii][jj].length =\n+\t      fold_build1 (CONVERT_EXPR, integer_type_node,\n+\t\t\t   ARRAY_NOTATION_LENGTH (ii_tree));\n+\t    (*node)[ii][jj].stride =\n+\t      fold_build1 (CONVERT_EXPR, integer_type_node,\n+\t\t\t   ARRAY_NOTATION_STRIDE (ii_tree));\n+\t  }\n }\n \n /* Replaces all the __sec_implicit_arg functions in LIST with the induction\n@@ -637,16 +637,15 @@ fix_sec_implicit_args (location_t loc, vec <tree, va_gc> *list,\n   vec <tree, va_gc> *array_operand = NULL;\n   for (size_t ii = 0; ii < vec_safe_length (list); ii++)\n     if (TREE_CODE ((*list)[ii]) == CALL_EXPR\n-\t&& TREE_CODE (CALL_EXPR_FN ((*list)[ii])) == ADDR_EXPR\n \t&& is_sec_implicit_index_fn (CALL_EXPR_FN ((*list)[ii])))\n       {\n \tint idx = extract_sec_implicit_index_arg (loc, (*list)[ii]);\n-\tif (idx < (int) rank && idx >= 0)\n-\t  vec_safe_push (array_operand, an_loop_info[idx].var);\n-\telse if (idx == -1)\n+\tif (idx < 0)\n \t  /* In this case, the returning function would have emitted an\n \t     error thus it is not necessary to do so again.  */\n \t  return NULL;\n+\telse if (idx < (int) rank)\n+\t  vec_safe_push (array_operand, an_loop_info[idx].var);\n \telse\n \t  {\n \t    error_at (loc, \"__sec_implicit_index argument %d must be \""}, {"sha": "71a1db12faf79154279d0d8bf952f8aff7b37691", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1141ed3f71c8a82067dbbbed6ec87c607bfd0be9/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1141ed3f71c8a82067dbbbed6ec87c607bfd0be9/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=1141ed3f71c8a82067dbbbed6ec87c607bfd0be9", "patch": "@@ -1,3 +1,8 @@\n+2013-06-28  Balaji V. Iyer  <balaji.v.iyer@intel.com>\n+\n+\t* c-parser.c (c_parser_array_notation): Removed rejection of array\n+\tnotations in an array of function pointers.\n+\n 2013-06-21  Balaji V. Iyer  <balaji.v.iyer@intel.com>\n \n \t* c-array-notation.c (make_triplet_val_inv): New function."}, {"sha": "c7846cedccb24b6c4b8dec5046a488a95206f787", "filename": "gcc/c/c-parser.c", "status": "modified", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1141ed3f71c8a82067dbbbed6ec87c607bfd0be9/gcc%2Fc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1141ed3f71c8a82067dbbbed6ec87c607bfd0be9/gcc%2Fc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.c?ref=1141ed3f71c8a82067dbbbed6ec87c607bfd0be9", "patch": "@@ -11053,24 +11053,6 @@ c_parser_array_notation (location_t loc, c_parser *parser, tree initial_index,\n \t      c_parser_skip_until_found (parser, CPP_CLOSE_SQUARE, NULL);\n \t      return error_mark_node;\n \t    }\n-\t  if (TREE_CODE (array_type) == ARRAY_TYPE)\n-\t    {\n-\t      tree subtype = TREE_TYPE (array_type);\n-\t      while (subtype && TREE_CODE (subtype) == POINTER_TYPE)\n-\t\t{\n-\t\t  /* Now this could be a function pointer.  Find them and\n-\t\t     give out an error.  */\n-\t\t  subtype = TREE_TYPE (subtype);\n-\t\t  if (subtype && TREE_CODE (subtype) == FUNCTION_TYPE)\n-\t\t    {\n-\t\t      error_at (loc, \"array notations cannot be used with \"\n-\t\t\t\t\"function pointer arrays\");\n-\t\t      c_parser_skip_until_found (parser, CPP_CLOSE_SQUARE,\n-\t\t\t\t\t\t NULL);\n-\t\t      return error_mark_node;\n-\t\t    }\n-\t\t}\n-\t    }\n \t  array_type_domain = TYPE_DOMAIN (array_type);\n \n \t  if (!array_type_domain)\n@@ -11114,27 +11096,6 @@ c_parser_array_notation (location_t loc, c_parser *parser, tree initial_index,\n \t      c_parser_skip_until_found (parser, CPP_CLOSE_SQUARE, NULL);\n \t      return error_mark_node;\n \t    }\n-\t  if (TREE_CODE (array_type) == ARRAY_TYPE\n-\t      || TREE_CODE (array_type) == POINTER_TYPE)\n-\t    {\n-\t      tree subtype = TREE_TYPE (array_type);\n-\t      while (subtype\n-\t\t     && (TREE_CODE (subtype) == POINTER_TYPE\n-\t\t\t || TREE_CODE (subtype) == ARRAY_TYPE))\n-\t\t{\n-\t\t  /* Now this could be a function pointer.  Find them and\n-\t\t     give out an error.  */\n-\t\t  subtype = TREE_TYPE (subtype);\n-\t\t  if (subtype && TREE_CODE (subtype) == FUNCTION_TYPE)\n-\t\t    {\n-\t\t      error_at (loc, \"array notations cannot be used with \"\n-\t\t\t\t\"function pointer arrays\");\n-\t\t      c_parser_skip_until_found (parser, CPP_CLOSE_SQUARE,\n-\t\t\t\t\t\t NULL);\n-\t\t      return error_mark_node;\n-\t\t    }\n-\t\t}\n-\t    }\n \t  c_parser_consume_token (parser); /* consume the ':' */\n \t  end_index = c_parser_expression (parser).value;\n \t  if (!end_index || end_index == error_mark_node)"}, {"sha": "cffed313ce4692aa5f67912d74c1a6b0abfcd6d6", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1141ed3f71c8a82067dbbbed6ec87c607bfd0be9/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1141ed3f71c8a82067dbbbed6ec87c607bfd0be9/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=1141ed3f71c8a82067dbbbed6ec87c607bfd0be9", "patch": "@@ -1,3 +1,71 @@\n+2013-06-28  Balaji V. Iyer  <balaji.v.iyer@intel.com>\n+\n+\t* parser.c (cp_parser_array_notation): Removed rejection array notation\n+\tof type function pointers. Added handling of array expressions when\n+\tCilk Plus is enabled.  Took out type-checking.\n+\t(cp_parser_postfix_open_square_expression): Moved normal array expr.\n+\tparsing into cp_parser_array_notation when cilkplus is enabled.\n+\t(cp_parser_compound_statement): Removed expansion of array notations.\n+\t(cp_parser_ctor_initializer_opt_and_function_body): Likewise.\n+\t(cp_parser_function_definition_after_declarator): Likewise.\n+\t(cp_parser_selection_statement): Removed error reporting.\n+\t(cp_parser_iteration_statement): Likewise.\n+\t(cp_parser_direct_declarator): Removed error checking/reporting if\n+\tarray notations are used in the declarator.\n+\t* pt.c (instantiate_decl): Likewise.\n+\t(type_unification_real): Removed a check for ARRAY_NOTATION_REF.\n+\t(cxx_eval_constant_expression): Removed ARRAY_NOTATION_REF case.\n+\t(potential_constant_expression_1): Returned false for\n+\tARRAY_NOTATION_REF case.\n+\t* cp-gimplify.c (cp_genericize): Added expansion of array notation\n+\texpressions here.\n+\t* cp-array-notation.c (make_triplet_val_inv): Removed loc and cry \n+\tparameters.  Replaced build_decls with get_temp_regvar with type as\n+\tptrdiff.\n+\t(create_array_refs): Made the type-casting to ptrdiff_type.\n+\t(replace_invariant_var): Added a check for void return type before \n+\tcreating new var.  Replaced build_decl and build_min_nt_loc with\n+\tget_temp_regvar.\n+\t(expand_an_in_modify_expr): Ditto.  Replaced body of redundant else \n+\twith gcc_unreachable.  Removed few unwanted checks.  Made induction \n+\tvariable type as ptrdiff_type.  Removed loc and complain arguments \n+\tpassed into make_triplet_val_inv.  Replaced all modify expression's \n+\tcode from NOP EXPR to INIT EXPR.  Replaced all forceful appending \n+\tinto stmt. list with the non-forceful one.  Replaced some integer \n+\tconversion and equality-checking to using tree_int_cst_equal.\n+\t(expand_sec_reduce_builtin): All changes mentioned in above function\n+\texpand_an_in_modify_expr.  Made the new variable type of\n+\tSEC_REDUCE_ANY/ALL_{NON}ZERO intrinsic functions as bool.\n+\t(expand_array_notation_exprs): Removed SWITCH_EXPR case.  Moved all\n+\tthe error reporting from parser to this function.  Removed unwanted\n+\tstatements and checks from SWITCH_STMT, WHILE_STMT, and DO_STMT cases.\n+\t(cilkplus_an_triplet_types_ok_p): Removed rejection of array notation\n+\tin function pointers.\n+\t(cp_expand_cond_array_notations): Added a new if statements to check\n+\tif condition has a zero rank.  If so, then just return.\n+\t(expand_return_expr): Added a check for return expressions with a rank.\n+\tReplaced get_tmp_regvar with a create_temporary_var.\n+\t(build_array_notation_ref): Simplified and removed unwanted if-stmts.\n+\tMoved common code outside if-statements.  Moved type-checking from\n+\tparser to here.\n+\t* semantics.c (finish_return_stmt): Removed a check for return exprs.\n+\twith a rank.\n+\t* call.c (convert_like_real): Removed a check for array notation\n+\texpression in a function.\n+\t(build_over_call): Likewise.\n+\t(magic_varargs_p): Added a check for builtin array notation function.\n+\tMade this function non-static and removed its prototype.\n+\t* cp-tree.h (magic_varargs_p): New prototype.\n+\t* typeck.c (cp_build_function_call_vec): Removed automatic setting of\n+\tnargs to the param->length when builtin reduction function is used.\n+\t(convert_arguments): Replaced check for a constant_p function with\n+\tmargic_varargs_p function call.\n+\t(cp_build_binary_op): Removed calling of the function\n+\tfind_correct_array_notation_type.\n+\t(cp_build_addr_expr_1): Removed an unwanted if-statement.\n+\t(convert_for_assignment): Removed automatic return of rhs when array\n+\tnotation builtin function is used.\n+\n 2013-06-28  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/57682"}, {"sha": "425ef9bcd95d8fc17d1b6d36f23d04e3abf50eed", "filename": "gcc/cp/call.c", "status": "modified", "additions": 13, "deletions": 26, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1141ed3f71c8a82067dbbbed6ec87c607bfd0be9/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1141ed3f71c8a82067dbbbed6ec87c607bfd0be9/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=1141ed3f71c8a82067dbbbed6ec87c607bfd0be9", "patch": "@@ -216,7 +216,6 @@ static void add_candidates (tree, tree, const vec<tree, va_gc> *, tree, tree,\n \t\t\t    bool, tree, tree, int, struct z_candidate **,\n \t\t\t    tsubst_flags_t);\n static conversion *merge_conversion_sequences (conversion *, conversion *);\n-static bool magic_varargs_p (tree);\n static tree build_temp (tree, tree, int, diagnostic_t *, tsubst_flags_t);\n \n /* Returns nonzero iff the destructor name specified in NAME matches BASETYPE.\n@@ -5857,16 +5856,9 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n \t  else if (t->kind == ck_identity)\n \t    break;\n \t}\n-\n-      if (flag_enable_cilkplus\n-\t  && (contains_array_notation_expr (expr)\n-\t      || contains_array_notation_expr (fn)))\n-\t/* If we are using array notations, we fix them up at a later stage\n-\t   and we will do these checks then.  */\n-\t;\n-      else if (permerror (loc, \"invalid conversion from %qT to %qT\",\n-\t\t\t  TREE_TYPE (expr), totype)\n-\t       && fn)\n+       if (permerror (loc, \"invalid conversion from %qT to %qT\",\n+                    TREE_TYPE (expr), totype)\n+\t   && fn)\n \tinform (DECL_SOURCE_LOCATION (fn),\n \t\t\"initializing argument %P of %qD\", argnum, fn);\n \n@@ -6515,9 +6507,12 @@ convert_for_arg_passing (tree type, tree val, tsubst_flags_t complain)\n    which no conversions at all should be done.  This is true for some\n    builtins which don't act like normal functions.  */\n \n-static bool\n+bool\n magic_varargs_p (tree fn)\n {\n+  if (flag_enable_cilkplus && is_cilkplus_reduce_builtin (fn) != BUILT_IN_NONE)\n+    return true;\n+\n   if (DECL_BUILT_IN (fn))\n     switch (DECL_FUNCTION_CODE (fn))\n       {\n@@ -6895,21 +6890,13 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n \t\t       \"  (you can disable this with -fno-deduce-init-list)\");\n \t    }\n \t}\n+      val = convert_like_with_context (conv, arg, fn, i - is_method,\n+\t\t\t\t       conversion_warning\n+\t\t\t\t       ? complain\n+\t\t\t\t       : complain & (~tf_warning));\n \n-      /* If the function call is builtin array notation function then no need\n-\t to do any type conversion.  */\n-      if (flag_enable_cilkplus\n-\t  && is_cilkplus_reduce_builtin (fn) != BUILT_IN_NONE)\n-\tval = arg;\n-      else\n-\t{\n-\t  val = convert_like_with_context (conv, arg, fn, i - is_method,\n-\t\t\t\t\t   conversion_warning\n-\t\t\t\t\t   ? complain\n-\t\t\t\t\t   : complain & (~tf_warning));\n-\n-\t  val = convert_for_arg_passing (type, val, complain);\n-\t}\n+      val = convert_for_arg_passing (type, val, complain);\n+\t\n       if (val == error_mark_node)\n         return error_mark_node;\n       else"}, {"sha": "d279ddd9c72a6326298217e7f15be62f21a4e4de", "filename": "gcc/cp/cp-array-notation.c", "status": "modified", "additions": 255, "deletions": 327, "changes": 582, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1141ed3f71c8a82067dbbbed6ec87c607bfd0be9/gcc%2Fcp%2Fcp-array-notation.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1141ed3f71c8a82067dbbbed6ec87c607bfd0be9/gcc%2Fcp%2Fcp-array-notation.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-array-notation.c?ref=1141ed3f71c8a82067dbbbed6ec87c607bfd0be9", "patch": "@@ -59,7 +59,6 @@\n #include \"diagnostic.h\"\n #include \"tree-iterator.h\"\n #include \"vec.h\"\n-#include \"gimple.h\"\n \n /* Creates a FOR_STMT with INIT, COND, INCR and BODY as the initializer,\n    condition, increment expression and the loop-body, respectively.  */\n@@ -82,17 +81,12 @@ create_an_loop (tree init, tree cond, tree incr, tree body)\n    a variable to make it loop invariant for array notations.  */\n \n static inline void\n-make_triplet_val_inv (location_t loc, tree *value, tsubst_flags_t cry)\n+make_triplet_val_inv (tree *value)\n {\n-  tree var;\n   if (TREE_CODE (*value) != INTEGER_CST\n       && TREE_CODE (*value) != PARM_DECL\n       && TREE_CODE (*value) != VAR_DECL)\n-    {\n-      var = build_decl (loc, VAR_DECL, NULL_TREE, integer_type_node);\n-      finish_expr_stmt (build_x_modify_expr (loc, var, NOP_EXPR, *value, cry));\n-      *value = var;\n-    }\n+    *value = get_temp_regvar (ptrdiff_type_node, *value);\n }\n \n /* Returns a vector of size RANK that contains an ARRAY_REF.  This vector is\n@@ -112,47 +106,22 @@ create_array_refs (location_t loc, vec<vec<an_parts> > an_info,\n {\n   tree ind_mult, ind_incr;\n   vec<tree, va_gc> *array_operand = NULL;\n+\n   for (size_t ii = 0; ii < size; ii++)\n     if (an_info[ii][0].is_vector)\n       {\n \ttree array_opr = an_info[ii][rank - 1].value;\n \tfor (int s_jj = rank -1; s_jj >= 0; s_jj--)\n \t  {\n-\t    tree str = NULL_TREE, v = NULL_TREE, st = NULL_TREE;\n-\t    tree start = an_info[ii][s_jj].start;\n-\t    tree stride = an_info[ii][s_jj].stride;\n-\t    tree var = an_loop_info[s_jj].var;\n-\n-\t    /* If stride and start are of same type and the induction var\n-\t       is not, convert induction variable to stride's type.  */\n-\t    if (TREE_TYPE (start) == TREE_TYPE (stride)\n-\t\t&& TREE_TYPE (stride) != TREE_TYPE (var))\n-\t      {\n-\t\tst = start;\n-\t\tstr = stride;\n-\t\tv = build_c_cast (loc, TREE_TYPE (str), var);\n-\t      }\n-\t    else if (TREE_TYPE (start) != TREE_TYPE (stride))\n-\t      {\n-\t\t/* If we reach here, then the stride and start are of\n-\t\t   different types, and so it doesn't really matter what\n-\t\t   the induction variable type is, convert everything to \n-\t\t   integer.  The reason why we pick an integer\n-\t\t   instead of something like size_t is because the stride\n-\t\t   and length can be + or -.  */\n-\t\tst = build_c_cast (loc, integer_type_node, start);\n-\t\tstr = build_c_cast (loc, integer_type_node, stride);\n-\t\tv = build_c_cast (loc, integer_type_node, var);\n-\t      }\n-\t    else\n-\t      {\n-\t\tst = start;\n-\t\tstr = stride;\n-\t\tv = var;\n-\t      }\n-\n-\t    ind_mult = build2 (MULT_EXPR, TREE_TYPE (v), v, str);\n-\t    ind_incr = build2 (PLUS_EXPR, TREE_TYPE (v), st, ind_mult);\n+\t    tree start = cp_fold_convert (ptrdiff_type_node, \n+\t\t\t\t\t  an_info[ii][s_jj].start);\n+\t    tree stride = cp_fold_convert (ptrdiff_type_node, \n+\t\t\t\t\t   an_info[ii][s_jj].stride);\n+\t    tree var = cp_fold_convert (ptrdiff_type_node, \n+\t\t\t\t\tan_loop_info[s_jj].var);\n+\n+\t    ind_mult = build2 (MULT_EXPR, TREE_TYPE (var), var, stride);\n+\t    ind_incr = build2 (PLUS_EXPR, TREE_TYPE (var), start, ind_mult);\n \t    /* Array [ start_index + (induction_var * stride)]  */\n \t    array_opr = grok_array_decl\t(loc, array_opr, ind_incr, false);\n \t  }\n@@ -192,7 +161,7 @@ replace_invariant_exprs (tree *node)\n {\n   size_t ix = 0;\n   tree node_list = NULL_TREE;\n-  tree t = NULL_TREE, new_var = NULL_TREE, new_node; \n+  tree t = NULL_TREE, new_var = NULL_TREE;\n   struct inv_list data;\n \n   data.list_values = NULL;\n@@ -204,17 +173,18 @@ replace_invariant_exprs (tree *node)\n     {\n       node_list = push_stmt_list ();\n       for (ix = 0; vec_safe_iterate (data.list_values, ix, &t); ix++)\n-\t{\n-\t  if (processing_template_decl || !TREE_TYPE (t))\n-\t    new_var = build_min_nt_loc (EXPR_LOCATION (t), VAR_DECL, NULL_TREE,\n-\t\t\t\t       \tNULL_TREE);\n-\t  else\n-\t    new_var = build_decl (EXPR_LOCATION (t), VAR_DECL, NULL_TREE,\n-\t\t\t\t  TREE_TYPE (t));\n-\t  gcc_assert (new_var != NULL_TREE && new_var != error_mark_node);\n-\t  new_node = build_x_modify_expr (EXPR_LOCATION (t), new_var, NOP_EXPR,\n-\t\t\t\t\t  t, tf_warning_or_error);\n-\t  finish_expr_stmt (new_node);\n+\t{ \n+\t  /* Sometimes, when comma_expr has a function call in it, it will\n+\t     typecast it to void.  Find_inv_trees finds those nodes and so\n+\t     if it void type, then don't bother creating a new var to hold \n+\t     the return value.   */\n+\t  if (VOID_TYPE_P (TREE_TYPE (t)))\n+\t    {\n+\t      finish_expr_stmt (t);\n+\t      new_var = void_zero_node;\n+\t    }\n+\t  else \n+\t    new_var = get_temp_regvar (TREE_TYPE (t), t); \n \t  vec_safe_push (data.replacement, new_var);\n \t}\n       cp_walk_tree (node, replace_inv_trees, (void *) &data, NULL);\n@@ -235,7 +205,6 @@ expand_sec_reduce_builtin (tree an_builtin_fn, tree *new_var)\n   tree new_var_type = NULL_TREE, func_parm, new_yes_expr, new_no_expr;\n   tree array_ind_value = NULL_TREE, new_no_ind, new_yes_ind, new_no_list;\n   tree new_yes_list, new_cond_expr, new_expr = NULL_TREE; \n-  tree new_var_init = NULL_TREE, new_exp_init = NULL_TREE;\n   vec<tree, va_gc> *array_list = NULL, *array_operand = NULL;\n   size_t list_size = 0, rank = 0, ii = 0;\n   tree  body, an_init, loop_with_init = alloc_stmt_list ();\n@@ -305,7 +274,7 @@ expand_sec_reduce_builtin (tree an_builtin_fn, tree *new_var)\n     case BUILT_IN_CILKPLUS_SEC_REDUCE_ANY_ZERO:\n     case BUILT_IN_CILKPLUS_SEC_REDUCE_ANY_NONZERO:\n     case BUILT_IN_CILKPLUS_SEC_REDUCE_ALL_NONZERO:\n-      new_var_type = integer_type_node;\n+      new_var_type = boolean_type_node;\n       break;\n     case BUILT_IN_CILKPLUS_SEC_REDUCE_MAX_IND:\n     case BUILT_IN_CILKPLUS_SEC_REDUCE_MIN_IND:\n@@ -334,24 +303,30 @@ expand_sec_reduce_builtin (tree an_builtin_fn, tree *new_var)\n     if (TREE_CODE ((*array_list)[ii]) == ARRAY_NOTATION_REF)\n       {\n \ttree anode = (*array_list)[ii];\n-\tmake_triplet_val_inv (location, &ARRAY_NOTATION_START (anode),\n-\t\t\t      tf_warning_or_error);\n-\tmake_triplet_val_inv (location, &ARRAY_NOTATION_LENGTH (anode),\n-\t\t\t      tf_warning_or_error);\n-\tmake_triplet_val_inv (location, &ARRAY_NOTATION_STRIDE (anode),\n-\t\t\t      tf_warning_or_error);\n+\tmake_triplet_val_inv (&ARRAY_NOTATION_START (anode));\n+\tmake_triplet_val_inv (&ARRAY_NOTATION_LENGTH (anode));\n+\tmake_triplet_val_inv (&ARRAY_NOTATION_STRIDE (anode));\n       }\n   cilkplus_extract_an_triplets (array_list, list_size, rank, &an_info);\n   for (ii = 0; ii < rank; ii++)\n     {\n-      an_loop_info[ii].var = build_decl (location, VAR_DECL, NULL_TREE,\n-\t\t\t\t  TREE_TYPE (an_info[0][ii].start));\n-      an_loop_info[ii].ind_init = build_x_modify_expr\n-\t(location, an_loop_info[ii].var, NOP_EXPR, \n-\t build_zero_cst (TREE_TYPE (an_loop_info[ii].var)),\n-\t tf_warning_or_error);\n+      tree typ = ptrdiff_type_node;\n+\n+      /* In this place, we are using get_temp_regvar instead of \n+\t create_temporary_var if an_type is SEC_REDUCE_MAX/MIN_IND because\n+\t the array_ind_value depends on this value being initalized to 0.  */\n+      if (an_type == BUILT_IN_CILKPLUS_SEC_REDUCE_MAX_IND\n+\t  || an_type == BUILT_IN_CILKPLUS_SEC_REDUCE_MIN_IND) \n+\tan_loop_info[ii].var = get_temp_regvar (typ, build_zero_cst (typ));\n+      else\n+\t{\n+\t  an_loop_info[ii].var = create_temporary_var (typ);\n+\t  add_decl_expr (an_loop_info[ii].var);\n+\t}\n+      an_loop_info[ii].ind_init = \n+\tbuild_x_modify_expr (location, an_loop_info[ii].var, INIT_EXPR,\n+\t\t\t     build_zero_cst (typ), tf_warning_or_error);\n     }\n-  \n   array_operand = create_array_refs (location, an_info, an_loop_info,\n \t\t\t\t      list_size, rank);\n   replace_array_notations (&func_parm, true, array_list, array_operand);\n@@ -360,26 +335,9 @@ expand_sec_reduce_builtin (tree an_builtin_fn, tree *new_var)\n     TREE_TYPE (func_parm) = TREE_TYPE ((*array_list)[0]);\n   \n   create_cmp_incr (location, &an_loop_info, rank, an_info, tf_warning_or_error);\n-  if (an_type != BUILT_IN_CILKPLUS_SEC_REDUCE_MUTATING)\n-    {\n-      if (processing_template_decl)\n-\t*new_var = build_decl (location, VAR_DECL, NULL_TREE, new_var_type);\n-      else\n-\t*new_var = create_tmp_var (new_var_type, NULL);\n-    }\n-  else\n-    /* We do not require a new variable for mutating.  The \"identity value\"\n-       itself is the variable.  */\n-    *new_var = NULL_TREE;\n-  \n   if (an_type == BUILT_IN_CILKPLUS_SEC_REDUCE_MAX_IND\n-      || an_type == BUILT_IN_CILKPLUS_SEC_REDUCE_MIN_IND)\n-    {\n-      array_ind_value = create_tmp_var (TREE_TYPE (func_parm), NULL);\n-      gcc_assert (array_ind_value && (array_ind_value != error_mark_node));\n-      DECL_INITIAL (array_ind_value) = NULL_TREE;\n-      pushdecl (array_ind_value);\n-    }\n+      || an_type == BUILT_IN_CILKPLUS_SEC_REDUCE_MIN_IND) \n+    array_ind_value = get_temp_regvar (TREE_TYPE (func_parm), func_parm);\n \n   array_op0 = (*array_operand)[0];\n   switch (an_type)\n@@ -394,35 +352,36 @@ expand_sec_reduce_builtin (tree an_builtin_fn, tree *new_var)\n       break;\n     case BUILT_IN_CILKPLUS_SEC_REDUCE_ANY_ZERO:\n     case BUILT_IN_CILKPLUS_SEC_REDUCE_ANY_NONZERO:\n-      code = (an_type == BUILT_IN_CILKPLUS_SEC_REDUCE_ANY_ZERO) ? EQ_EXPR\n-\t: NE_EXPR;\n+      code = ((an_type == BUILT_IN_CILKPLUS_SEC_REDUCE_ANY_ZERO) ? EQ_EXPR\n+\t: NE_EXPR);\n       init = build_zero_cst (new_var_type);\n       cond_init = build_one_cst (new_var_type);\n       comp_node = build_zero_cst (TREE_TYPE (func_parm));\n       break;\n     case BUILT_IN_CILKPLUS_SEC_REDUCE_ALL_ZERO:\n     case BUILT_IN_CILKPLUS_SEC_REDUCE_ALL_NONZERO:\n-      code = (an_type == BUILT_IN_CILKPLUS_SEC_REDUCE_ALL_ZERO) ? NE_EXPR\n-\t: EQ_EXPR;\n+      code = ((an_type == BUILT_IN_CILKPLUS_SEC_REDUCE_ALL_ZERO) ? NE_EXPR\n+\t: EQ_EXPR);\n       init = build_one_cst (new_var_type);\n       cond_init = build_zero_cst (new_var_type);\n       comp_node = build_zero_cst (TREE_TYPE (func_parm));\n       break;\n     case BUILT_IN_CILKPLUS_SEC_REDUCE_MAX:\n       code = MAX_EXPR;\n-      init = TYPE_MIN_VALUE (new_var_type) ? TYPE_MIN_VALUE (new_var_type)\n-\t: func_parm;\n+      init = (TYPE_MIN_VALUE (new_var_type) ? TYPE_MIN_VALUE (new_var_type)\n+\t: func_parm);\n       break;\n     case BUILT_IN_CILKPLUS_SEC_REDUCE_MIN:\n       code = MIN_EXPR;\n-      init = TYPE_MAX_VALUE (new_var_type) ? TYPE_MAX_VALUE (new_var_type)\n-\t: func_parm;\n+      init = (TYPE_MAX_VALUE (new_var_type) ? TYPE_MAX_VALUE (new_var_type)\n+\t: func_parm);\n       break;\n     case BUILT_IN_CILKPLUS_SEC_REDUCE_MIN_IND:\n     case BUILT_IN_CILKPLUS_SEC_REDUCE_MAX_IND:\n-      code = an_type == BUILT_IN_CILKPLUS_SEC_REDUCE_MAX_IND ? LE_EXPR\n-\t: GE_EXPR;\n+      code = (an_type == BUILT_IN_CILKPLUS_SEC_REDUCE_MAX_IND ? LE_EXPR\n+\t: GE_EXPR);\n       init = an_loop_info[0].var;\n+      break;\n     case BUILT_IN_CILKPLUS_SEC_REDUCE:\n       init = identity_value;\n       break;\n@@ -433,9 +392,11 @@ expand_sec_reduce_builtin (tree an_builtin_fn, tree *new_var)\n       gcc_unreachable ();\n     }\n \n-  if (init)\n-    new_var_init = build_x_modify_expr (location, *new_var, NOP_EXPR, init,\n-\t\t\t\t\ttf_warning_or_error);\n+  if (an_type != BUILT_IN_CILKPLUS_SEC_REDUCE_MUTATING)\n+    *new_var = get_temp_regvar (new_var_type, init);\n+  else\n+    *new_var = NULL_TREE;\n+\n   switch (an_type)\n     {\n     case BUILT_IN_CILKPLUS_SEC_REDUCE_ADD:\n@@ -470,8 +431,6 @@ expand_sec_reduce_builtin (tree an_builtin_fn, tree *new_var)\n       break;\n     case BUILT_IN_CILKPLUS_SEC_REDUCE_MAX_IND:\n     case BUILT_IN_CILKPLUS_SEC_REDUCE_MIN_IND:\n-      new_exp_init = build_x_modify_expr (location, array_ind_value, NOP_EXPR,\n-\t\t\t\t\t  func_parm, tf_warning_or_error);\n       new_yes_expr = build_x_modify_expr (location, array_ind_value, NOP_EXPR,\n \t\t\t\t\t  func_parm, tf_warning_or_error);\n       new_no_expr = build_x_modify_expr (location, array_ind_value, NOP_EXPR,\n@@ -521,21 +480,8 @@ expand_sec_reduce_builtin (tree an_builtin_fn, tree *new_var)\n     default:\n       gcc_unreachable ();\n     }\n-  \n-  /* The reason we are putting initial variable twice is because the\n-     new exp init below depends on this value being initialized.  */\n-  for (ii = 0; ii < rank; ii++)\n-    finish_expr_stmt (an_loop_info[ii].ind_init);\n- \n-  if (an_type != BUILT_IN_CILKPLUS_SEC_REDUCE_MUTATING)\n-    finish_expr_stmt (new_var_init);\n-\n-  if (an_type == BUILT_IN_CILKPLUS_SEC_REDUCE_MAX_IND\n-      || an_type == BUILT_IN_CILKPLUS_SEC_REDUCE_MIN_IND)\n-    finish_expr_stmt (new_exp_init);\n-\n   an_init = pop_stmt_list (an_init);\n-  append_to_statement_list_force (an_init, &loop_with_init);\n+  append_to_statement_list (an_init, &loop_with_init);\n   body = new_expr;\n \n   for (ii = 0; ii < rank; ii++)\n@@ -545,7 +491,7 @@ expand_sec_reduce_builtin (tree an_builtin_fn, tree *new_var)\n \t\t      an_loop_info[ii].incr, body);\n       body = pop_stmt_list (new_loop);\n     }\n-  append_to_statement_list_force (body, &loop_with_init);\n+  append_to_statement_list (body, &loop_with_init);\n \n   an_info.release ();\n   an_loop_info.release ();\n@@ -634,10 +580,7 @@ expand_an_in_modify_expr (location_t location, tree lhs,\n \t  return an_init;\n \t}\n       else\n-\t{\n-\t  pop_stmt_list (an_init);\n-\t  return NULL_TREE;\n-\t}\n+\tgcc_unreachable ();\n     }\n \n   /* If for some reason location is not set, then find if LHS or RHS has\n@@ -659,8 +602,6 @@ expand_an_in_modify_expr (location_t location, tree lhs,\n     \n   if (lhs_rank == 0 && rhs_rank != 0)\n     {\n-      if (location == UNKNOWN_LOCATION && EXPR_HAS_LOCATION (rhs))\n-\tlocation = EXPR_LOCATION (rhs);\n       error_at (location, \"%qD cannot be scalar when %qD is not\", lhs, rhs);\n       return error_mark_node;\n     }\n@@ -675,17 +616,17 @@ expand_an_in_modify_expr (location_t location, tree lhs,\n   for (ii = 0; ii < lhs_list_size; ii++)\n     {\n       tree anode = (*lhs_list)[ii];\n-      make_triplet_val_inv (location, &ARRAY_NOTATION_START (anode), complain);\n-      make_triplet_val_inv (location, &ARRAY_NOTATION_LENGTH (anode), complain);\n-      make_triplet_val_inv (location, &ARRAY_NOTATION_STRIDE (anode), complain);\n+      make_triplet_val_inv (&ARRAY_NOTATION_START (anode));\n+      make_triplet_val_inv (&ARRAY_NOTATION_LENGTH (anode));\n+      make_triplet_val_inv (&ARRAY_NOTATION_STRIDE (anode));\n     }\n   for (ii = 0; ii < rhs_list_size; ii++)\n     if ((*rhs_list)[ii] && TREE_CODE ((*rhs_list)[ii]) == ARRAY_NOTATION_REF)\n       {\n \ttree aa = (*rhs_list)[ii];\n-\tmake_triplet_val_inv (location, &ARRAY_NOTATION_START (aa), complain);\n-\tmake_triplet_val_inv (location, &ARRAY_NOTATION_LENGTH (aa), complain);\n-\tmake_triplet_val_inv (location, &ARRAY_NOTATION_STRIDE (aa), complain);\n+\tmake_triplet_val_inv (&ARRAY_NOTATION_START (aa));\n+\tmake_triplet_val_inv (&ARRAY_NOTATION_LENGTH (aa));\n+\tmake_triplet_val_inv (&ARRAY_NOTATION_STRIDE (aa));\n       }\n   lhs_an_loop_info.safe_grow_cleared (lhs_rank);\n   \n@@ -705,31 +646,29 @@ expand_an_in_modify_expr (location_t location, tree lhs,\n       pop_stmt_list (an_init);\n       return error_mark_node;\n     }\n-  tree rhs_len = (rhs_list_size > 0 && rhs_rank > 0) ?\n-    rhs_an_info[0][0].length : NULL_TREE;\n-  tree lhs_len = (lhs_list_size > 0 && lhs_rank > 0) ?\n-    lhs_an_info[0][0].length : NULL_TREE;\n+  tree rhs_len = ((rhs_list_size > 0 && rhs_rank > 0) ?\n+    rhs_an_info[0][0].length : NULL_TREE);\n+  tree lhs_len = ((lhs_list_size > 0 && lhs_rank > 0) ?\n+    lhs_an_info[0][0].length : NULL_TREE);\n   if (lhs_list_size > 0 && rhs_list_size > 0 && lhs_rank > 0 && rhs_rank > 0\n       && TREE_CODE (lhs_len) == INTEGER_CST && rhs_len\n-      && TREE_CODE (rhs_len) == INTEGER_CST)\n-    {\n-      HOST_WIDE_INT l_length = int_cst_value (lhs_len);\n-      HOST_WIDE_INT r_length = int_cst_value (rhs_len);\n-      if (absu_hwi (l_length) != absu_hwi (r_length))\n-\t{\n-\t  error_at (location, \"length mismatch between LHS and RHS\");\n-\t  pop_stmt_list (an_init);\n-\t  return error_mark_node;\n-\t}\n+      && TREE_CODE (rhs_len) == INTEGER_CST \n+      && !tree_int_cst_equal (rhs_len, lhs_len))\n+    { \n+      error_at (location, \"length mismatch between LHS and RHS\"); \n+      pop_stmt_list (an_init); \n+      return error_mark_node;\n     }\n-   for (ii = 0; ii < lhs_rank; ii++)\n-    if (lhs_an_info[0][ii].start && TREE_TYPE (lhs_an_info[0][ii].start))\n-      lhs_an_loop_info[ii].var =\n-\tbuild_decl (location, VAR_DECL, NULL_TREE,\n-\t\t    TREE_TYPE (lhs_an_info[0][ii].start));\n-    else\n-      lhs_an_loop_info[ii].var = build_decl (location, VAR_DECL, NULL_TREE,\n-\t\t\t\t\t     integer_type_node);\n+   for (ii = 0; ii < lhs_rank; ii++) \n+     {\n+       tree typ = ptrdiff_type_node; \n+       lhs_an_loop_info[ii].var = create_temporary_var (typ);\n+       add_decl_expr (lhs_an_loop_info[ii].var);\n+       lhs_an_loop_info[ii].ind_init = build_x_modify_expr \n+\t (location, lhs_an_loop_info[ii].var, INIT_EXPR, build_zero_cst (typ), \n+\t  complain);\n+     }\n+   \n    if (rhs_list_size > 0)\n      {\n        rhs_array_operand = fix_sec_implicit_args (location, rhs_list,\n@@ -743,24 +682,15 @@ expand_an_in_modify_expr (location_t location, tree lhs,\n   rhs_list = NULL;\n   extract_array_notation_exprs (rhs, true, &rhs_list);\n   rhs_list_size = vec_safe_length (rhs_list);    \n-  \n-  for (ii = 0; ii < lhs_rank; ii++)\n-    if (lhs_an_info[0][ii].is_vector)\n-      {\n-\tlhs_an_loop_info[ii].ind_init = build_x_modify_expr\n-\t  (location, lhs_an_loop_info[ii].var, NOP_EXPR,\n-\t   build_zero_cst (TREE_TYPE (lhs_an_loop_info[ii].var)), complain);\n-      }\n+\n   for (ii = 0; ii < rhs_rank; ii++)\n     {\n-      /* When we have a polynomial, we assume that the indices are of type\n-\t integer.  */\n-      rhs_an_loop_info[ii].var =\n-\tbuild_decl (location, VAR_DECL, NULL_TREE,\n-\t\t    TREE_TYPE (rhs_an_info[0][ii].start));\n+      tree typ = ptrdiff_type_node;\n+      rhs_an_loop_info[ii].var = create_temporary_var (typ);\n+      add_decl_expr (rhs_an_loop_info[ii].var);\n       rhs_an_loop_info[ii].ind_init = build_x_modify_expr\n-\t(location, rhs_an_loop_info[ii].var, NOP_EXPR, \n-\t build_zero_cst (TREE_TYPE (rhs_an_loop_info[ii].var)), complain);\n+\t(location, rhs_an_loop_info[ii].var, INIT_EXPR, build_zero_cst (typ), \n+\t complain);\n     }\n \n   if (lhs_rank)\n@@ -809,12 +739,12 @@ expand_an_in_modify_expr (location_t location, tree lhs,\n     else if (ii < lhs_rank && ii >= rhs_rank)\n       cond_expr[ii] = lhs_an_loop_info[ii].cmp;\n     else\n-      /* No need to compare ii < rhs_rank && ii >= lhs_rank because valid Array\n-\t notation expression cannot RHS's rank cannot be greater than LHS.  */\n+      /* No need to compare ii < rhs_rank && ii >= lhs_rank because in a valid \n+\t Array notation expression, rank of RHS cannot be greater than LHS.  */\n       gcc_unreachable ();\n   \n   an_init = pop_stmt_list (an_init);\n-  append_to_statement_list_force (an_init, &loop_with_init);\n+  append_to_statement_list (an_init, &loop_with_init);\n   body = array_expr;\n   for (ii = 0; ii < MAX (lhs_rank, rhs_rank); ii++)\n     {\n@@ -824,17 +754,13 @@ expand_an_in_modify_expr (location_t location, tree lhs,\n \n       if (lhs_rank)\n \t{\n-\t  append_to_statement_list_force (lhs_an_loop_info[ii].ind_init,\n-\t\t\t\t\t  &init_list);\n-\t  append_to_statement_list_force (lhs_an_loop_info[ii].incr,\n-\t\t\t\t\t  &incr_list);\n+\t  append_to_statement_list (lhs_an_loop_info[ii].ind_init, &init_list);\n+\t  append_to_statement_list (lhs_an_loop_info[ii].incr, &incr_list);\n \t}\n       if (rhs_rank)\n \t{\n-\t  append_to_statement_list_force (rhs_an_loop_info[ii].ind_init,\n-\t\t\t\t\t  &init_list);\n-\t  append_to_statement_list_force (rhs_an_loop_info[ii].incr,\n-\t\t\t\t\t  &incr_list);\n+\t  append_to_statement_list (rhs_an_loop_info[ii].ind_init, &init_list);\n+\t  append_to_statement_list (rhs_an_loop_info[ii].incr, &incr_list);\n \t}\n       create_an_loop (init_list, cond_expr[ii], incr_list, body);\n       body = pop_stmt_list (new_loop);\n@@ -867,7 +793,6 @@ cp_expand_cond_array_notations (tree orig_stmt)\n   tree an_init, body, stmt = NULL_TREE;\n   tree builtin_loop, new_var = NULL_TREE;\n   tree loop_with_init = alloc_stmt_list ();\n-  tsubst_flags_t complain = tf_warning_or_error;\n   location_t location = UNKNOWN_LOCATION;\n   vec<vec<an_parts> > an_info = vNULL;\n   vec<an_loop_parts> an_loop_info = vNULL;\n@@ -884,13 +809,17 @@ cp_expand_cond_array_notations (tree orig_stmt)\n \t  || find_rank (EXPR_LOCATION (no_expr), no_expr, no_expr, true,\n \t\t\t&no_rank))\n \treturn error_mark_node;\n-      if (cond_rank != 0 && cond_rank != yes_rank && yes_rank != 0)\n+      /* If the condition has a zero rank, then handle array notations in body\n+\t seperately.  */\n+      if (cond_rank == 0)\n+\treturn orig_stmt;\n+      if (cond_rank != yes_rank && yes_rank != 0)\n \t{\n \t  error_at (EXPR_LOCATION (yes_expr), \"rank mismatch with controlling\"\n \t\t    \" expression of parent if-statement\");\n \t  return error_mark_node;\n \t}\n-      else if (cond_rank != 0 && cond_rank != no_rank && no_rank != 0)\n+      else if (cond_rank != no_rank && no_rank != 0)\n \t{\n \t  error_at (EXPR_LOCATION (no_expr), \"rank mismatch with controlling \"\n \t\t    \"expression of parent if-statement\");\n@@ -911,13 +840,17 @@ cp_expand_cond_array_notations (tree orig_stmt)\n \t      && !find_rank (EXPR_LOCATION (no_expr), no_expr, no_expr, true,\n \t\t\t     &no_rank)))\n \treturn error_mark_node;\n-      if (cond_rank != 0 && cond_rank != yes_rank && yes_rank != 0)\n+\n+      /* Same reasoning as for COND_EXPR.  */\n+      if (cond_rank == 0)\n+\treturn orig_stmt;\n+      else if (cond_rank != yes_rank && yes_rank != 0)\n \t{\n \t  error_at (EXPR_LOCATION (yes_expr), \"rank mismatch with controlling\"\n \t\t    \" expression of parent if-statement\");\n \t  return error_mark_node;\n \t}\n-      else if (cond_rank != 0 && cond_rank != no_rank && no_rank != 0)\n+      else if (cond_rank != no_rank && no_rank != 0)\n \t{\n \t  error_at (EXPR_LOCATION (no_expr), \"rank mismatch with controlling \"\n \t\t    \"expression of parent if-statement\");\n@@ -949,11 +882,11 @@ cp_expand_cond_array_notations (tree orig_stmt)\n \t      vec_safe_push (new_var_list, new_var);\n \t      replace_array_notations (&orig_stmt, false, sub_list,\n \t\t\t\t       new_var_list);\n-\t      append_to_statement_list_force (builtin_loop, &stmt);\n+\t      append_to_statement_list (builtin_loop, &stmt);\n \t    }\n \t}\n     }\n-  append_to_statement_list_force (orig_stmt, &stmt);\n+  append_to_statement_list (orig_stmt, &stmt);\n   rank = 0;\n   array_list = NULL;\n   if (!find_rank (EXPR_LOCATION (stmt), stmt, stmt, true, &rank))\n@@ -977,37 +910,28 @@ cp_expand_cond_array_notations (tree orig_stmt)\n   for (ii = 0; ii < list_size; ii++)\n     {\n       tree anode = (*array_list)[ii];\n-      make_triplet_val_inv (location, &ARRAY_NOTATION_START (anode), complain);\n-      make_triplet_val_inv (location, &ARRAY_NOTATION_LENGTH (anode), complain);\n-      make_triplet_val_inv (location, &ARRAY_NOTATION_STRIDE (anode), complain);\n+      make_triplet_val_inv (&ARRAY_NOTATION_START (anode));\n+      make_triplet_val_inv (&ARRAY_NOTATION_LENGTH (anode));\n+      make_triplet_val_inv (&ARRAY_NOTATION_STRIDE (anode));\n     }\n   cilkplus_extract_an_triplets (array_list, list_size, rank, &an_info);\n-  for (ii = 0; ii < rank; ii++)\n-      if (TREE_TYPE (an_info[0][ii].start)\n-\t  && TREE_CODE (TREE_TYPE (an_info[0][ii].start)) != TEMPLATE_TYPE_PARM)\n-\t{\n-\t  an_loop_info[ii].var = build_decl (location, VAR_DECL, NULL_TREE,\n-\t\t\t\t\t     TREE_TYPE (an_info[0][ii].start));\n-\t  an_loop_info[ii].ind_init = build_x_modify_expr\n-\t    (location, an_loop_info[ii].var, NOP_EXPR,\n-\t     build_zero_cst (TREE_TYPE (an_loop_info[ii].var)),\n-\t     tf_warning_or_error);\n-\t}\n-      else\n-\t{\n-\t  an_loop_info[ii].var = build_min_nt_loc (location, VAR_DECL,\n-\t\t\t\t\t\t   NULL_TREE, NULL_TREE);\n-\t  an_loop_info[ii].ind_init =\n-\t    build_x_modify_expr (location, an_loop_info[ii].var, NOP_EXPR,\n-\t\t\t\t integer_zero_node, tf_warning_or_error);\n-\t}\n+\n+  for (ii = 0; ii < rank; ii++) \n+    {\n+      tree typ = ptrdiff_type_node;\n+      an_loop_info[ii].var = create_temporary_var (typ);\n+      add_decl_expr (an_loop_info[ii].var);\n+      an_loop_info[ii].ind_init =\n+\tbuild_x_modify_expr (location, an_loop_info[ii].var, INIT_EXPR,\n+\t\t\t     build_zero_cst (typ), tf_warning_or_error);\n+    }\n   array_operand = create_array_refs (location, an_info, an_loop_info,\n \t\t\t\t     list_size, rank);\n   replace_array_notations (&stmt, true, array_list, array_operand);\n   create_cmp_incr (location, &an_loop_info, rank, an_info, tf_warning_or_error);\n   \n   an_init = pop_stmt_list (an_init);\n-  append_to_statement_list_force (an_init, &loop_with_init);\n+  append_to_statement_list (an_init, &loop_with_init);\n   body = stmt;\n \n   for (ii = 0; ii < rank; ii++)\n@@ -1017,7 +941,7 @@ cp_expand_cond_array_notations (tree orig_stmt)\n \t\t      an_loop_info[ii].incr, body);\n       body = pop_stmt_list (new_loop);\n     }\n-  append_to_statement_list_force (body, &loop_with_init);\n+  append_to_statement_list (body, &loop_with_init);\n \n   an_info.release ();\n   an_loop_info.release ();\n@@ -1062,14 +986,14 @@ expand_unary_array_notation_exprs (tree orig_stmt)\n \t  {\n \t    vec<tree, va_gc> *sub_list = NULL, *new_var_list = NULL;\n \t    stmt = alloc_stmt_list ();\n-\t    append_to_statement_list_force (builtin_loop, &stmt);\n+\t    append_to_statement_list (builtin_loop, &stmt);\n \t    vec_safe_push (sub_list, list_node);\n \t    vec_safe_push (new_var_list, new_var);\n \t    replace_array_notations (&orig_stmt, false, sub_list, new_var_list);\n \t  }\t\n       }\n   if (stmt != NULL_TREE)\n-    append_to_statement_list_force (finish_expr_stmt (orig_stmt), &stmt);\n+    append_to_statement_list (finish_expr_stmt (orig_stmt), &stmt);\n   else\n     stmt = orig_stmt;\n   rank = 0;\n@@ -1089,22 +1013,19 @@ expand_unary_array_notation_exprs (tree orig_stmt)\n   for (ii = 0; ii < list_size; ii++)\n     {\n       tree array_node = (*array_list)[ii];\n-      make_triplet_val_inv (location, &ARRAY_NOTATION_START (array_node),\n-\t\t\t    tf_warning_or_error);\n-      make_triplet_val_inv (location, &ARRAY_NOTATION_LENGTH (array_node),\n-\t\t\t    tf_warning_or_error);\n-      make_triplet_val_inv (location, &ARRAY_NOTATION_STRIDE (array_node),\n-\t\t\t    tf_warning_or_error);\n+      make_triplet_val_inv (&ARRAY_NOTATION_START (array_node));\n+      make_triplet_val_inv (&ARRAY_NOTATION_LENGTH (array_node));\n+      make_triplet_val_inv (&ARRAY_NOTATION_STRIDE (array_node));\n     }\n   cilkplus_extract_an_triplets (array_list, list_size, rank, &an_info);\n   \n   for (ii = 0; ii < rank; ii++)\n     {\n-      an_loop_info[ii].var = build_decl (location, VAR_DECL, NULL_TREE,\n-\t\t\t\t  TREE_TYPE (an_info[0][ii].start));\n+      tree typ = ptrdiff_type_node;\n+      an_loop_info[ii].var = create_temporary_var (typ);\n+      add_decl_expr (an_loop_info[ii].var);\n       an_loop_info[ii].ind_init = build_x_modify_expr\n-\t(location, an_loop_info[ii].var, NOP_EXPR, \n-\t build_zero_cst (TREE_TYPE (an_loop_info[ii].var)),\n+\t(location, an_loop_info[ii].var, INIT_EXPR, build_zero_cst (typ), \n \t tf_warning_or_error);\n     }\n   array_operand = create_array_refs (location, an_info, an_loop_info,\n@@ -1113,7 +1034,7 @@ expand_unary_array_notation_exprs (tree orig_stmt)\n   create_cmp_incr (location, &an_loop_info, rank, an_info, tf_warning_or_error);\n   \n   an_init = pop_stmt_list (an_init);\n-  append_to_statement_list_force (an_init, &loop_with_init);\n+  append_to_statement_list (an_init, &loop_with_init);\n   body = stmt;\n   \n   for (ii = 0; ii < rank; ii++)\n@@ -1123,7 +1044,7 @@ expand_unary_array_notation_exprs (tree orig_stmt)\n \t\t      an_loop_info[ii].incr, body);\n       body = pop_stmt_list (new_loop);\n     }\n-  append_to_statement_list_force (body, &loop_with_init);\n+  append_to_statement_list (body, &loop_with_init);\n \n   an_info.release ();\n   an_loop_info.release ();\n@@ -1139,21 +1060,35 @@ static tree\n expand_return_expr (tree expr)\n {\n   tree new_mod_list, new_var, new_mod, retval_expr;\n-\n+  size_t rank  = 0;\n+  location_t loc = EXPR_LOCATION (expr);\n   if (TREE_CODE (expr) != RETURN_EXPR)\n     return expr;\n+      \n+  if (!find_rank (loc, expr, expr, false, &rank))\n+    return error_mark_node;\n \n-  location_t loc = EXPR_LOCATION (expr);\n-  new_mod_list = alloc_stmt_list ();\n+  /* If the return expression contains array notations, then flag it as\n+     error.  */\n+  if (rank >= 1)\n+    {\n+      error_at (loc, \"array notation expression cannot be used as a return \"\n+\t\t\"value\");\n+      return error_mark_node;\n+    }\n+  \n+  new_mod_list = push_stmt_list ();\n   retval_expr = TREE_OPERAND (expr, 0);\n-  new_var = build_decl (loc, VAR_DECL, NULL_TREE, TREE_TYPE (retval_expr));\n+  new_var = create_temporary_var (TREE_TYPE (retval_expr));\n+  add_decl_expr (new_var);\n   new_mod = expand_an_in_modify_expr (loc, new_var, NOP_EXPR,\n-\t\t\t\t\t TREE_OPERAND (retval_expr, 1),\n-\t\t\t\t\t tf_warning_or_error);\n+\t\t\t\t      TREE_OPERAND (retval_expr, 1),\n+\t\t\t\t      tf_warning_or_error);\n   TREE_OPERAND (retval_expr, 1) = new_var;\n   TREE_OPERAND (expr, 0) = retval_expr;\n-  append_to_statement_list_force (new_mod, &new_mod_list);\n-  append_to_statement_list_force (expr, &new_mod_list);\n+  add_stmt (new_mod);\n+  add_stmt (expr);\n+  new_mod_list = pop_stmt_list (new_mod_list);\n   return new_mod_list;\n }\n \n@@ -1290,19 +1225,21 @@ expand_array_notation_exprs (tree t)\n       else\n \tt = expand_array_notation_exprs (t);\n       return t;\n-\n-    case SWITCH_EXPR:\n-      t = cp_expand_cond_array_notations (t);\n-      if (TREE_CODE (t) == SWITCH_EXPR)\n-\tSWITCH_BODY (t) = expand_array_notation_exprs (SWITCH_BODY (t));\n-      else\n-\tt = expand_array_notation_exprs (t);\n-      return t;\n-    case FOR_STMT:      \n+    case FOR_STMT:\n+      if (contains_array_notation_expr (FOR_COND (t)))\n+\t{\n+\t  error_at (EXPR_LOCATION (FOR_COND (t)),\n+\t\t    \"array notation cannot be used in a condition for \"\n+\t\t    \"a for-loop\");\n+\t  return error_mark_node;\n+\t}\n       /* FIXME: Add a check for CILK_FOR_STMT here when we add Cilk tasking \n \t keywords.  */\n       if (TREE_CODE (t) == FOR_STMT)\n-\tFOR_BODY (t) = expand_array_notation_exprs (FOR_BODY (t));\n+\t{ \n+\t  FOR_BODY (t) = expand_array_notation_exprs (FOR_BODY (t));\n+\t  FOR_EXPR (t) = expand_array_notation_exprs (FOR_EXPR (t));\n+\t}\n       else\n \tt = expand_array_notation_exprs (t);\n       return t;\n@@ -1322,44 +1259,39 @@ expand_array_notation_exprs (tree t)\n \tt = expand_array_notation_exprs (t);\n       return t;\n     case SWITCH_STMT:\n-      t = cp_expand_cond_array_notations (t);\n-      /* If the above function added some extra instructions above the original\n-\t switch statement, then we can't assume it is still SWITCH_STMT so we\n-\t have to check again.  */\n-      if (TREE_CODE (t) == SWITCH_STMT)\n+      if (contains_array_notation_expr (SWITCH_STMT_COND (t)))\n \t{\n-\t  if (SWITCH_STMT_BODY (t))\n-\t    SWITCH_STMT_BODY (t) =\n-\t      expand_array_notation_exprs (SWITCH_STMT_BODY (t));\n+\t  error_at (EXPR_LOCATION (SWITCH_STMT_COND (t)),\n+\t\t    \"array notation cannot be used as a condition for \"\n+\t\t    \"switch statement\");\n+\t  return error_mark_node;\n \t}\n-      else\n-\tt = expand_array_notation_exprs (t);\n+      if (SWITCH_STMT_BODY (t))\n+\tSWITCH_STMT_BODY (t) =\n+\t  expand_array_notation_exprs (SWITCH_STMT_BODY (t));\n       return t;\n     case WHILE_STMT:\n-      t = cp_expand_cond_array_notations (t);\n-      /* If the above function added some extra instructions above the original\n-\t while statement, then we can't assume it is still WHILE_STMTso we\n-\t have to check again.  */\n-      if (TREE_CODE (t) == WHILE_STMT)\n+      if (contains_array_notation_expr (WHILE_COND (t)))\n \t{\n-\t  if (WHILE_BODY (t))\n-\t    WHILE_BODY (t) = expand_array_notation_exprs (WHILE_BODY (t));\n+\t  if (EXPR_LOCATION (WHILE_COND (t)) != UNKNOWN_LOCATION)\n+\t    loc = EXPR_LOCATION (WHILE_COND (t));\n+\t  error_at (loc, \"array notation cannot be used as a condition for \"\n+\t\t    \"while statement\");\n+\t  return error_mark_node;\n \t}\n-      else\n-\tt = expand_array_notation_exprs (t);\n+      if (WHILE_BODY (t))\n+\tWHILE_BODY (t) = expand_array_notation_exprs (WHILE_BODY (t));\n       return t;\n     case DO_STMT:\n-      t = cp_expand_cond_array_notations (t);\n-      /* If the above function added some extra instructions above the original\n-\t do-while statement, then we can't assume it is still DO_STMT so we\n-\t have to check again.  */\n-      if (TREE_CODE (t) == DO_STMT)\n-\t{      \n-\t  if (DO_BODY (t))\n-\t    DO_BODY (t) = expand_array_notation_exprs (DO_BODY (t));\n+      if (contains_array_notation_expr (DO_COND (t)))\n+\t{\n+\t  error_at (EXPR_LOCATION (DO_COND (t)),\n+\t\t    \"array notation cannot be used as a condition for a \"\n+\t\t    \"do-while statement\");\n+\t  return error_mark_node;\n \t}\n-      else\n-\tt = expand_array_notation_exprs (t);\n+      if (DO_BODY (t))\n+\tDO_BODY (t) = expand_array_notation_exprs (DO_BODY (t));\n       return t;\n     default:\n       if (is_expr)\n@@ -1380,59 +1312,66 @@ expand_array_notation_exprs (tree t)\n   return t;\n }\n \n-/* Given the base of an array (ARRAY), the START_INDEX, the number of elements\n-   to be accessed (LENGTH) and the STRIDE, construct an ARRAY_NOTATION_REF tree\n-   of type TYPE and return it.  Restrictions on START_INDEX, LENGTH and STRIDE \n-   are the same as that of index field passed into ARRAY_REF.  The only\n-   additional restriction is that, unlike index in ARRAY_REF, stride, length\n-   and start_index cannot contain array notations.  */\n+/* Given the base of an array (ARRAY), the START (start_index), the number of \n+   elements to be accessed (LENGTH) and the STRIDE, construct an \n+   ARRAY_NOTATION_REF tree of type TYPE and return it.  Restrictions on START, \n+   LENGTH and STRIDE are the same as that of index field passed into ARRAY_REF. \n+   The only additional restriction is that, unlike index in ARRAY_REF, stride, \n+   length and start_index cannot contain array notations.  */\n \n tree\n-build_array_notation_ref (location_t loc, tree array, tree start_index,\n-\t\t\t  tree length, tree stride, tree type)\n+build_array_notation_ref (location_t loc, tree array, tree start, tree length, \n+\t\t\t  tree stride, tree type)\n {\n   tree array_ntn_expr = NULL_TREE;\n-  \n-  /* When dealing with templates, do the type checking at a later time.  */\n-  if (processing_template_decl || !type)\n+\n+  /* If we enter the then-case of the if-statement below, we have hit a case \n+     like this: ARRAY [:].  */\n+  if (!start && !length)\n     {\n-      if (!type && TREE_TYPE (array))\n-\ttype = TREE_TYPE (array);\n-      array_ntn_expr = build_min_nt_loc (loc, ARRAY_NOTATION_REF, array,\n-\t\t\t\t\t start_index, length, stride, type,\n-\t\t\t\t\t NULL_TREE);\n-      TREE_TYPE (array_ntn_expr) = type;\n+      if (TREE_CODE (type) != ARRAY_TYPE)\n+\t{\n+\t  error_at (loc, \"start-index and length fields necessary for \"\n+\t\t    \"using array notation in pointers or records\");\n+\t  return error_mark_node;\n+\t}\n+      tree domain = TYPE_DOMAIN (type);\n+      if (!domain)\n+\t{\n+\t  error_at (loc, \"start-index and length fields necessary for \"\n+\t\t    \"using array notation with array of unknown bound\");\n+\t  return error_mark_node;\n+\t}\n+      start = cp_fold_convert (ptrdiff_type_node, TYPE_MINVAL (domain));\n+      length = size_binop (PLUS_EXPR, TYPE_MAXVAL (domain), size_one_node);\n+      length = cp_fold_convert (ptrdiff_type_node, length);\n     }\n-  if (!stride)\n-    {\n-      if (TREE_CONSTANT (start_index) && TREE_CONSTANT (length)\n-\t  && TREE_CODE (start_index) != VAR_DECL\n-\t  && TREE_CODE (length) != VAR_DECL\n-\t  && tree_int_cst_lt (length, start_index))\n-\tstride = build_int_cst (TREE_TYPE (start_index), -1);\n-      else\n-\tstride = build_int_cst (TREE_TYPE (start_index), 1);\n+    \n+  if (!stride) \n+    stride = build_one_cst (ptrdiff_type_node);\n+  \n+  /* When dealing with templates, triplet type-checking will be done in pt.c \n+     after type substitution.  */\n+  if (processing_template_decl \n+      && (type_dependent_expression_p (array) \n+\t  || type_dependent_expression_p (length) \n+\t  || type_dependent_expression_p (start) \n+\t  || type_dependent_expression_p (stride))) \n+    array_ntn_expr = build_min_nt_loc (loc, ARRAY_NOTATION_REF, array, start, \n+\t\t\t\t       length, stride, NULL_TREE);\n+  else \n+    { \n+      if (!cilkplus_an_triplet_types_ok_p (loc, start, length, stride, type))\n+\treturn error_mark_node;\n+      array_ntn_expr = build4 (ARRAY_NOTATION_REF, NULL_TREE, array, start, \n+\t\t\t       length, stride);\n     }\n+  if (TREE_CODE (type) == ARRAY_TYPE || TREE_CODE (type) == POINTER_TYPE)\n+    TREE_TYPE (array_ntn_expr) = TREE_TYPE (type);\n+  else\n+    gcc_unreachable ();\n \n-  if (!cilkplus_an_triplet_types_ok_p (loc, start_index, length, stride, type))\n-    return error_mark_node;\n-\n-  if (!processing_template_decl)\n-    {\n-      array_ntn_expr = build4 (ARRAY_NOTATION_REF, NULL_TREE, NULL_TREE,\n-\t\t\t       NULL_TREE, NULL_TREE, NULL_TREE);\n-      ARRAY_NOTATION_ARRAY (array_ntn_expr) = array;\n-      ARRAY_NOTATION_START (array_ntn_expr) = start_index;\n-      ARRAY_NOTATION_LENGTH (array_ntn_expr) = length;\n-      ARRAY_NOTATION_STRIDE (array_ntn_expr) = stride;\n-      if (type && (TREE_CODE (type) == ARRAY_TYPE\n-\t\t   || TREE_CODE (type) == POINTER_TYPE))\n-\tTREE_TYPE (array_ntn_expr) = TREE_TYPE (type);\n-      else\n-\tTREE_TYPE (array_ntn_expr) = type;\n-    }\n   SET_EXPR_LOCATION (array_ntn_expr, loc);\n-\n   return array_ntn_expr;\n }\n \n@@ -1462,20 +1401,9 @@ cilkplus_an_triplet_types_ok_p (location_t loc, tree start_index, tree length,\n     }\n   if (!TREE_CODE (type) == FUNCTION_TYPE)\n     {\n-      error_at (loc, \"array notations cannot be used with function type\");\n+      error_at (loc, \"array notation cannot be used with function type\");\n       return false;\n     }\n-  while (type && (TREE_CODE (type) == POINTER_TYPE\n-\t\t  || TREE_CODE (type) == ARRAY_TYPE))\n-    {\n-      type = TREE_TYPE (type);\n-      if (type && TREE_CODE (type) == FUNCTION_TYPE)\n-\t{\n-\t  error_at (loc, \"array notations cannot be used with function pointer\"\n-\t\t    \" arrays\");\n-\t  return false;\n-\t}\n-    }\n   if (!find_rank (loc, start_index, start_index, false, &start_rank)\n       || !find_rank (loc, length, length, false, &length_rank)\n       || !find_rank (loc, stride, stride, false, &stride_rank))"}, {"sha": "590d8577fdca9923575de7f5c537502b5cf9d5bb", "filename": "gcc/cp/cp-gimplify.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1141ed3f71c8a82067dbbbed6ec87c607bfd0be9/gcc%2Fcp%2Fcp-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1141ed3f71c8a82067dbbbed6ec87c607bfd0be9/gcc%2Fcp%2Fcp-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.c?ref=1141ed3f71c8a82067dbbbed6ec87c607bfd0be9", "patch": "@@ -1207,6 +1207,12 @@ cp_genericize (tree fndecl)\n   if (DECL_CLONED_FUNCTION_P (fndecl))\n     return;\n \n+  /* Expand all the array notations here.  */\n+  if (flag_enable_cilkplus \n+      && contains_array_notation_expr (DECL_SAVED_TREE (fndecl)))\n+    DECL_SAVED_TREE (fndecl) = \n+      expand_array_notation_exprs (DECL_SAVED_TREE (fndecl));\n+\n   /* We do want to see every occurrence of the parms, so we can't just use\n      walk_tree's hash functionality.  */\n   cp_genericize_tree (&DECL_SAVED_TREE (fndecl));"}, {"sha": "d3dd494124268169865a6d6ec62f60e17c893f8e", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1141ed3f71c8a82067dbbbed6ec87c607bfd0be9/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1141ed3f71c8a82067dbbbed6ec87c607bfd0be9/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=1141ed3f71c8a82067dbbbed6ec87c607bfd0be9", "patch": "@@ -4974,6 +4974,7 @@ extern bool pragma_java_exceptions;\n \n /* in call.c */\n extern bool check_dtor_name\t\t\t(tree, tree);\n+bool magic_varargs_p                            (tree);\n \n extern tree build_conditional_expr\t\t(location_t, tree, tree, tree, \n                                                  tsubst_flags_t);"}, {"sha": "281e163b7df0a7f389944bc261c3a01dcdfac86e", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 122, "deletions": 285, "changes": 407, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1141ed3f71c8a82067dbbbed6ec87c607bfd0be9/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1141ed3f71c8a82067dbbbed6ec87c607bfd0be9/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=1141ed3f71c8a82067dbbbed6ec87c607bfd0be9", "patch": "@@ -6062,167 +6062,89 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n   return error_mark_node;\n }\n \n-/* This function parses Cilk Plus array notations.  The starting index is\n-   passed in INIT_INDEX and the array name is passed in ARRAY_VALUE.  If the\n-   INIT_INDEX is NULL, then we have special case were the entire array is\n-   accessed (e.g. A[:]).  The return value of this function is a tree node\n-   called VALUE_TREE of type ARRAY_NOTATION_REF.  If some error occurred it\n-   returns error_mark_node.  */\n+/* This function parses Cilk Plus array notations.  If a normal array expr. is\n+   parsed then the array index is passed back to the caller through *INIT_INDEX \n+   and the function returns a NULL_TREE.  If array notation expr. is parsed, \n+   then *INIT_INDEX is ignored by the caller and the function returns \n+   a tree of type ARRAY_NOTATION_REF.  If some error occurred it returns \n+   error_mark_node.  */\n \n static tree\n-cp_parser_array_notation (location_t loc, cp_parser *parser, tree init_index,\n+cp_parser_array_notation (location_t loc, cp_parser *parser, tree *init_index,\n \t\t\t  tree array_value)\n {\n   cp_token *token = NULL;\n-  tree start_index = NULL_TREE, length_index = NULL_TREE, stride = NULL_TREE;\n-  tree value_tree, type, array_type, array_type_domain;\n-  double_int x; \n-  bool saved_colon_corrects_to_scope_p = parser->colon_corrects_to_scope_p;\n-\n+  tree length_index, stride = NULL_TREE, value_tree, array_type;\n   if (!array_value || array_value == error_mark_node)\n     {\n       cp_parser_skip_to_end_of_statement (parser);\n       return error_mark_node;\n     }\n+\n+  array_type = TREE_TYPE (array_value);\n   \n-  if (processing_template_decl)\n-    {\n-      array_type = TREE_TYPE (array_value);\n-      type = TREE_TYPE (array_type);\n-    }\n-  else\n-    {\n-      array_type = TREE_TYPE (array_value);\n-      gcc_assert (array_type);\n-      type = array_type;\n-    }\n+  bool saved_colon_corrects = parser->colon_corrects_to_scope_p;\n+  parser->colon_corrects_to_scope_p = false;\n   token = cp_lexer_peek_token (parser->lexer);\n+  \n   if (!token)\n     {\n       cp_parser_error (parser, \"expected %<:%> or numeral\");\n       return error_mark_node;\n     }\n   else if (token->type == CPP_COLON)\n     {\n-      if (!init_index)\n+      /* Consume the ':'.  */\n+      cp_lexer_consume_token (parser->lexer);\n+      \n+      /* If we are here, then we have a case like this A[:].  */\n+      if (cp_lexer_peek_token (parser->lexer)->type != CPP_CLOSE_SQUARE)\n \t{\n-\t  /* If we are here, then we have a case like this A[:].  */\n-\t  cp_lexer_consume_token (parser->lexer);\n-\n-\t  if (cp_lexer_peek_token (parser->lexer)->type != CPP_CLOSE_SQUARE)\n-\t    {\n-\t      cp_parser_error (parser, \"expected %<]%>\");\n-\t      cp_parser_skip_to_end_of_statement (parser);\n-\t      return error_mark_node;\n-\t    }\n-\t  if (TREE_CODE (array_type) == RECORD_TYPE\n-\t      || TREE_CODE (array_type) == POINTER_TYPE)\n-\t    {\n-\t      error_at (loc, \"start-index and length fields necessary for \"\n-\t\t\t\"using array notations in pointers or records\");\n-\t      cp_parser_skip_to_end_of_statement (parser);\n-\t      return error_mark_node;\n-\t    }\n-\t  if (TREE_CODE (array_type) == ARRAY_TYPE)\n-\t    {\n-\t      tree subtype = TREE_TYPE (array_type);\n-\t      while (subtype && TREE_CODE (subtype) == POINTER_TYPE)\n-\t\t{\n-\t\t  /* This could be a function ptr.  If so, then emit error.  */\n-\t\t  subtype = TREE_TYPE (subtype);\n-\t\t  if (subtype && TREE_CODE (subtype) == FUNCTION_TYPE)\n-\t\t    {\n-\t\t      error_at (loc, \"array notations cannot be used with\"\n-\t\t\t\t\" function pointer arrays\");\n-\t\t      cp_parser_skip_to_end_of_statement (parser);\n-\t\t      return error_mark_node;\n-\t\t    }\n-\t\t}\n-\t    }\n-\t  array_type_domain = TYPE_DOMAIN (array_type);\n-\t  if (!array_type_domain)\n-\t    {\n-\t      error_at (loc, \"start-index and length fields necessary for \"\n-\t\t\t\"using array notations in dimensionless arrays\");\n-\t      cp_parser_skip_to_end_of_statement (parser);\n-\t      return error_mark_node;\n-\t    }\n-\t  start_index = TYPE_MINVAL (array_type_domain);\n-\t  start_index = fold_build1 (CONVERT_EXPR, ptrdiff_type_node,\n-\t\t\t\t     start_index);\n-\t  x = TREE_INT_CST (TYPE_MAXVAL (array_type_domain));\n-\t  x.low++;\n-\t  length_index = double_int_to_tree (integer_type_node, x);\n-\t  length_index = fold_build1 (CONVERT_EXPR, ptrdiff_type_node,\n-\t\t\t\t      length_index);\n-\t  stride = build_int_cst (integer_type_node, 1);\n-\t  stride = fold_build1 (CONVERT_EXPR, ptrdiff_type_node, stride);\n-\t}\n-      else if (init_index != error_mark_node)\n-\t{\n-\t  /* If we hare here, then there are 2 possibilities:\n-\t     1. Array [ EXPR : EXPR ]\n-\t     2. Array [ EXPR : EXPR : EXPR ]\n-\t  */\n-\t  start_index = init_index;\n-\t  cp_lexer_consume_token (parser->lexer);\n+\t  cp_parser_error (parser, \"expected %<]%>\");\n+\t  cp_parser_skip_to_end_of_statement (parser);\n+\t  return error_mark_node;\n+\t}\n+      *init_index = NULL_TREE;\n+      stride = NULL_TREE;\n+      length_index = NULL_TREE;\n+    }\n+  else\n+    {\n+      /* If we are here, then there are three valid possibilities:\n+\t 1. ARRAY [ EXP ]\n+\t 2. ARRAY [ EXP : EXP ]\n+\t 3. ARRAY [ EXP : EXP : EXP ]  */\n \n-\t  saved_colon_corrects_to_scope_p = parser->colon_corrects_to_scope_p;\n-\t   /* The ':' is used in array notation.  Thus compiler cannot do scope \n-\t      correction automatically.  */\n-\t  parser->colon_corrects_to_scope_p = false;\n-\t  length_index = cp_parser_expression (parser, false, NULL);\n-\t  parser->colon_corrects_to_scope_p = saved_colon_corrects_to_scope_p;\n-\t  if (!length_index || length_index == error_mark_node)\n-\t    cp_parser_skip_to_end_of_statement (parser);\n-\t \n-\t  if (cp_lexer_peek_token (parser->lexer)->type == CPP_COLON)\n-\t    {\n-\t      cp_lexer_consume_token (parser->lexer);\n-\t      saved_colon_corrects_to_scope_p = \n-\t\tparser->colon_corrects_to_scope_p;\n-\t      /* Disable correcting single colon correcting to scope.  */\n-\t      parser->colon_corrects_to_scope_p = false;\n-\t      stride = cp_parser_expression (parser, false, NULL);\n-\t      parser->colon_corrects_to_scope_p = \n-\t\tsaved_colon_corrects_to_scope_p;\n-\t      if (!stride || stride == error_mark_node)\n-\t\t{\n-\t\t  cp_parser_skip_to_end_of_statement (parser);\n-\t\t  if (cp_lexer_peek_token (parser->lexer)->type\n-\t\t      == CPP_CLOSE_SQUARE)\n-\t\t    cp_lexer_consume_token (parser->lexer);\n-\t\t}\n-\t    }\n-\t  else\n-\t    stride = build_one_cst (integer_type_node);\n+      *init_index = cp_parser_expression (parser, false, NULL);\t\n+      if (cp_lexer_peek_token (parser->lexer)->type != CPP_COLON)\n+\t{  \n+\t  /* This indicates that we have a normal array expression.  */\n+\t  parser->colon_corrects_to_scope_p = saved_colon_corrects;\n+\t  return NULL_TREE;\n \t}\n-      else\n+      \n+      /* Consume the ':'.  */\n+      cp_lexer_consume_token (parser->lexer);\n+      length_index = cp_parser_expression (parser, false, NULL);\n+      if (cp_lexer_peek_token (parser->lexer)->type == CPP_COLON)\n \t{\n-\t  cp_parser_skip_to_end_of_statement (parser);\n-\t  return error_mark_node;\n+\t  cp_lexer_consume_token (parser->lexer);\n+\t  stride = cp_parser_expression (parser, false, NULL);\n \t}\n     }\n-  \n-  if (start_index == error_mark_node || length_index == error_mark_node\n-      || stride == error_mark_node || !start_index || !length_index\n-      || !stride)\n+  parser->colon_corrects_to_scope_p = saved_colon_corrects;\n+\n+  if (*init_index == error_mark_node || length_index == error_mark_node\n+      || stride == error_mark_node)\n     {\n       if (cp_lexer_peek_token (parser->lexer)->type == CPP_CLOSE_SQUARE)\n \tcp_lexer_consume_token (parser->lexer);\n       return error_mark_node;\n     }\n   cp_parser_require (parser, CPP_CLOSE_SQUARE, RT_CLOSE_SQUARE);\n-  \n-  /* We fold all 3 of the values to make things easier when we transform\n-     them later.  */\n-  start_index = fold (start_index);\n-  length_index = fold (length_index);\n-  stride = fold (stride);\n-\n-  value_tree = build_array_notation_ref (input_location, array_value,\n-\t\t\t\t\t start_index, length_index, stride,\n-\t\t\t\t\t type);\n+\n+  value_tree = build_array_notation_ref (loc, array_value, *init_index, \n+\t\t\t\t\t length_index, stride, array_type);\n   return value_tree;\n }\n \n@@ -6241,84 +6163,68 @@ cp_parser_postfix_open_square_expression (cp_parser *parser,\n \t\t\t\t\t  bool for_offsetof,\n \t\t\t\t\t  bool decltype_p)\n {\n-  tree index;\n+  tree index = NULL_TREE;\n   location_t loc = cp_lexer_peek_token (parser->lexer)->location;\n \n   /* Consume the `[' token.  */\n   cp_lexer_consume_token (parser->lexer);\n \n-  if (flag_enable_cilkplus\n-      && cp_lexer_peek_token (parser->lexer)->type == CPP_COLON)\n-    /* If we are here, then we have something like this:\n-       ARRAY[:]\n-    */\n-    postfix_expression = cp_parser_array_notation (loc, parser, NULL_TREE,\n-\t\t\t\t\t\t   postfix_expression);\n+  /* Parse the index expression.  */\n+  /* ??? For offsetof, there is a question of what to allow here.  If\n+     offsetof is not being used in an integral constant expression context,\n+     then we *could* get the right answer by computing the value at runtime.\n+     If we are in an integral constant expression context, then we might\n+     could accept any constant expression; hard to say without analysis.\n+     Rather than open the barn door too wide right away, allow only integer\n+     constant expressions here.  */\n+  if (for_offsetof)\n+    index = cp_parser_constant_expression (parser, false, NULL);\n   else\n     {\n-      /* Here are have these options:\n-\t 1. ARRAY[EXPR]               -- This is the normal array call.\n-\t 2. ARRAY[EXPR : EXPR]        -- Array notation expr with default stride\n-\t of 1.\n-\t 3. ARRAY[EXPR : EXPR : EXPR] -- Array Notation with userdefined stride.\n-\t 4. Array[Braced List]        -- This is handled by braced list.\n-      */\n-      \n-      /* Parse the index expression.  */\n-      /* ??? For offsetof, there is a question of what to allow here.  If\n-\t offsetof is not being used in an integral constant expression context,\n-\t then we *could* get the right answer by computing the value at runtime.\n-\t If we are in an integral constant expression context, then we might\n-\t could accept any constant expression; hard to say without analysis.\n-\t Rather than open the barn door too wide right away, allow only integer\n-\t constant expressions here.  */\n-      if (for_offsetof)\n-\tindex = cp_parser_constant_expression (parser, false, NULL);\n-      else\n+      if (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_BRACE))\n \t{\n-\t  bool saved_colon_corrects_to_scope_p = \n-\t    parser->colon_corrects_to_scope_p;\n-\t  if (flag_enable_cilkplus)\n-\t    parser->colon_corrects_to_scope_p = false;\n-\t  if (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_BRACE))\n+\t  bool expr_nonconst_p;\n+\t  maybe_warn_cpp0x (CPP0X_INITIALIZER_LISTS);\n+\t  index = cp_parser_braced_list (parser, &expr_nonconst_p);\n+\t  if (flag_enable_cilkplus\n+\t      && cp_lexer_peek_token (parser->lexer)->type == CPP_COLON)\n \t    {\n-\t      bool expr_nonconst_p;\n-\t      maybe_warn_cpp0x (CPP0X_INITIALIZER_LISTS);\n-\t      index = cp_parser_braced_list (parser, &expr_nonconst_p);\n-\t      if (flag_enable_cilkplus\n-\t\t  && cp_lexer_peek_token (parser->lexer)->type == CPP_COLON)\n-\t\t{\n-\t\t  error_at (cp_lexer_peek_token (parser->lexer)->location,\n-\t\t\t    \"braced list index is not allowed with array \"\n-\t\t\t    \"notations\");\n-\t\t  index = error_mark_node;\n-\t\t}\n+\t      error_at (cp_lexer_peek_token (parser->lexer)->location,\n+\t\t\t\"braced list index is not allowed with array \"\n+\t\t\t\"notation\");\n+\t      cp_parser_skip_to_end_of_statement (parser);\n+\t      return error_mark_node;\n \t    }\n-\t  else\n-\t    index = cp_parser_expression (parser, /*cast_p=*/false, NULL);\n-\t  parser->colon_corrects_to_scope_p = saved_colon_corrects_to_scope_p;\n \t}\n-      if (flag_enable_cilkplus\n-\t  && cp_lexer_peek_token (parser->lexer)->type == CPP_COLON)\n-\tpostfix_expression = cp_parser_array_notation (loc, parser, index,\n-\t\t\t\t\t\t       postfix_expression);\n-      else\n+      else if (flag_enable_cilkplus)\n \t{\n-  \t  /* Look for the closing `]'.  */\n-\t  cp_parser_require (parser, CPP_CLOSE_SQUARE, RT_CLOSE_SQUARE);\n-\n-\t  /* Build the ARRAY_REF.  */\n-\t  postfix_expression = grok_array_decl (loc, postfix_expression,\n-\t\t\t\t\t\tindex, decltype_p);\n-\n-\t  /* When not doing offsetof, array references are not permitted in\n-\t     constant-expressions.  */\n-\t  if (!for_offsetof\n-\t      && (cp_parser_non_integral_constant_expression (parser,\n-\t\t\t\t\t\t\t      NIC_ARRAY_REF)))\n-\t    postfix_expression = error_mark_node;\n+\t  /* Here are have these two options:\n+\t     ARRAY[EXP : EXP]        - Array notation expr with default\n+\t     stride of 1.\n+\t     ARRAY[EXP : EXP : EXP] - Array Notation with user-defined\n+\t     stride.  */\n+\t  tree an_exp = cp_parser_array_notation (loc, parser, &index, \n+\t\t\t\t\t\t  postfix_expression);\n+\t  if (an_exp)\n+\t    return an_exp;\n \t}\n+      else\n+\tindex = cp_parser_expression (parser, /*cast_p=*/false, NULL);\n     }\n+\n+  /* Look for the closing `]'.  */\n+  cp_parser_require (parser, CPP_CLOSE_SQUARE, RT_CLOSE_SQUARE);\n+\n+  /* Build the ARRAY_REF.  */\n+  postfix_expression = grok_array_decl (loc, postfix_expression,\n+\t\t\t\t\tindex, decltype_p);\n+\n+  /* When not doing offsetof, array references are not permitted in\n+     constant-expressions.  */\n+  if (!for_offsetof\n+      && (cp_parser_non_integral_constant_expression (parser, NIC_ARRAY_REF)))\n+    postfix_expression = error_mark_node;\n+\n   return postfix_expression;\n }\n \n@@ -9553,8 +9459,6 @@ cp_parser_compound_statement (cp_parser *parser, tree in_statement_expr,\n   /* Consume the `}'.  */\n   cp_parser_require (parser, CPP_CLOSE_BRACE, RT_CLOSE_BRACE);\n \n-  if (flag_enable_cilkplus && contains_array_notation_expr (compound_stmt))\n-    compound_stmt = expand_array_notation_exprs (compound_stmt);\n   return compound_stmt;\n }\n \n@@ -9747,14 +9651,6 @@ cp_parser_selection_statement (cp_parser* parser, bool *if_p)\n \n \t    /* Now we're all done with the switch-statement.  */\n \t    finish_switch_stmt (statement);\n-\t    if (flag_enable_cilkplus\n-\t\t&& contains_array_notation_expr (condition))\n-\t      {\n-\t\terror_at (EXPR_LOCATION (condition),\n-\t\t\t  \"array notations cannot be used as a condition for \"\n-\t\t\t  \"switch statement\");\n-\t\tstatement = error_mark_node;\n-\t      }      \n \t  }\n \n \treturn statement;\n@@ -10312,12 +10208,6 @@ cp_parser_iteration_statement (cp_parser* parser)\n \tparser->in_statement = in_statement;\n \t/* We're done with the while-statement.  */\n \tfinish_while_stmt (statement);\n-\tif (flag_enable_cilkplus && contains_array_notation_expr (condition))\n-\t  {\n-\t    error_at (EXPR_LOCATION (condition), \"array notations cannot be \"\n-\t\t      \"used as a condition for while statement\");\n-\t    statement = error_mark_node;\n-\t  }\n       }\n       break;\n \n@@ -10344,15 +10234,6 @@ cp_parser_iteration_statement (cp_parser* parser)\n \tcp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n \t/* Look for the `;'.  */\n \tcp_parser_require (parser, CPP_SEMICOLON, RT_SEMICOLON);\n-\tif (flag_enable_cilkplus\n-\t    && contains_array_notation_expr (DO_COND (statement)))\n-\t  {\n-\t    error_at (EXPR_LOCATION (DO_COND (statement)),\n-\t\t      \"array notations cannot be used as a condition for a \"\n-\t\t      \"do-while statement\");\n-\t    statement = error_mark_node;\n-\t  }\n-\n       }\n       break;\n \n@@ -10371,17 +10252,8 @@ cp_parser_iteration_statement (cp_parser* parser)\n \tcp_parser_already_scoped_statement (parser);\n \tparser->in_statement = in_statement;\n \n-\tif (flag_enable_cilkplus\n-\t    && contains_array_notation_expr (FOR_COND (statement)))\n-\t  {\n-\t    error_at (EXPR_LOCATION (FOR_COND (statement)),\n-\t\t      \"array notations cannot be used in a condition for a \"\n-\t\t      \"for-loop\");\n-\t    statement = error_mark_node;\n-\t  }\n-\telse\n-\t  /* We're done with the for-statement.  */\n-\t  finish_for_stmt (statement);\n+\t/* We're done with the for-statement.  */\n+\tfinish_for_stmt (statement);\n       }\n       break;\n \n@@ -16954,54 +16826,30 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t  if (token->type != CPP_CLOSE_SQUARE)\n \t    {\n \t      bool non_constant_p;\n-\n-\t      if (flag_enable_cilkplus\n-\t\t  && cp_lexer_next_token_is (parser->lexer, CPP_COLON))\n+\t      bounds\n+\t\t= cp_parser_constant_expression (parser,\n+\t\t\t\t\t\t /*allow_non_constant=*/true,\n+\t\t\t\t\t\t &non_constant_p);\n+\t      if (!non_constant_p)\n+\t\t/* OK */;\n+\t      else if (error_operand_p (bounds))\n+\t\t/* Already gave an error.  */;\n+\t      else if (!parser->in_function_body\n+\t\t       || current_binding_level->kind == sk_function_parms)\n \t\t{\n+\t\t  /* Normally, the array bound must be an integral constant\n+\t\t     expression.  However, as an extension, we allow VLAs\n+\t\t     in function scopes as long as they aren't part of a\n+\t\t     parameter declaration.  */\n+\t\t  cp_parser_error (parser,\n+\t\t\t\t   \"array bound is not an integer constant\");\n \t\t  bounds = error_mark_node;\n-\t\t  error_at (cp_lexer_peek_token (parser->lexer)->location,\n-\t\t\t    \"array notations cannot be used in declaration\");\n-\t\t  cp_lexer_consume_token (parser->lexer);\n \t\t}\n-\t      else\n+\t      else if (processing_template_decl)\n \t\t{\n-\t\t  bounds\n-\t\t    = cp_parser_constant_expression (parser,\n-\t\t\t\t\t\t     /*allow_non_constant=*/true,\n-\t\t\t\t\t\t     &non_constant_p);\n-\t\t  if (!non_constant_p)\n-\t\t    /* OK */;\n-\t\t  else if (error_operand_p (bounds))\n-\t\t    /* Already gave an error.  */;\n-\t\t  else if (!parser->in_function_body\n-\t\t\t   || current_binding_level->kind == sk_function_parms)\n-\t\t    {\n-\t\t      /* Normally, the array bound must be an integral constant\n-\t\t\t expression.  However, as an extension, we allow VLAs\n-\t\t\t in function scopes as long as they aren't part of a\n-\t\t\t parameter declaration.  */\n-\t\t      cp_parser_error (parser,\n-\t\t\t\t       \"array bound is not an integer constant\");\n-\t\t      bounds = error_mark_node;\n-\t\t    }\n-\t\t  else if (processing_template_decl)\n-\t\t    {\n-\t\t      /* Remember this wasn't a constant-expression.  */\n-\t\t      bounds = build_nop (TREE_TYPE (bounds), bounds);\n-\t\t      TREE_SIDE_EFFECTS (bounds) = 1;\n-\t\t    }\n-\t\t  if (flag_enable_cilkplus\n-\t\t      && cp_lexer_next_token_is (parser->lexer, CPP_COLON))\n-\t\t    {\n-\t\t      location_t loc =\n-\t\t\tcp_lexer_peek_token (parser->lexer)->location;\n-\t\t      while (cp_lexer_next_token_is_not (parser->lexer,\n-\t\t\t\t\t\t\t CPP_CLOSE_SQUARE))\n-\t\t\tcp_lexer_consume_token (parser->lexer);\n-\t\t      error_at (loc, \"array notations cannot be used in \"\n-\t\t\t \t\"declaration\");\n-\t\t      bounds = error_mark_node; \n-\t\t    }\n+\t\t  /* Remember this wasn't a constant-expression.  */\n+\t\t  bounds = build_nop (TREE_TYPE (bounds), bounds);\n+\t\t  TREE_SIDE_EFFECTS (bounds) = 1;\n \t\t}\n \t    }\n \t  else\n@@ -18372,11 +18220,6 @@ cp_parser_ctor_initializer_opt_and_function_body (cp_parser *parser,\n   cp_parser_function_body (parser, in_function_try_block);\n   if (check_body_p)\n     check_constexpr_ctor_body (last, list);\n-\n-  /* Transform all array notations to the equivalent array refs and loop.  */\n-  if (flag_enable_cilkplus && contains_array_notation_expr (body))\n-    body = expand_array_notation_exprs (body);\n-  \n   /* Finish the function body.  */\n   finish_function_body (body);\n \n@@ -22356,12 +22199,6 @@ cp_parser_function_definition_after_declarator (cp_parser* parser,\n \n   finish_lambda_scope ();\n \n-  /* Expand all array notation expressions here.  */\n-  if (flag_enable_cilkplus && current_function_decl\n-      && contains_array_notation_expr (DECL_SAVED_TREE (current_function_decl)))\n-    DECL_SAVED_TREE (current_function_decl) =\n-      expand_array_notation_exprs (DECL_SAVED_TREE (current_function_decl));\n-  \n   /* Finish the function.  */\n   fn = finish_function ((ctor_initializer_p ? 1 : 0) |\n \t\t\t(inline_p ? 2 : 0));"}, {"sha": "3847a1d615451ba3d554a1323e7fa067c2df74ff", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1141ed3f71c8a82067dbbbed6ec87c607bfd0be9/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1141ed3f71c8a82067dbbbed6ec87c607bfd0be9/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=1141ed3f71c8a82067dbbbed6ec87c607bfd0be9", "patch": "@@ -13762,9 +13762,6 @@ tsubst_copy_and_build (tree t,\n \tstart_index = RECUR (ARRAY_NOTATION_START (t));\n \tlength = RECUR (ARRAY_NOTATION_LENGTH (t));\n \tstride = RECUR (ARRAY_NOTATION_STRIDE (t));\n-\tif (!cilkplus_an_triplet_types_ok_p (loc, start_index, length, stride,\n-\t\t\t\t\t     TREE_TYPE (op1)))\n-\t  RETURN (error_mark_node);\n \tRETURN (build_array_notation_ref (EXPR_LOCATION (t), op1, start_index,\n \t\t\t\t\t  length, stride, TREE_TYPE (op1)));\n       }\n@@ -15747,9 +15744,6 @@ type_unification_real (tree tparms,\n       arg = args[ia];\n       ++ia;\n \n-      if (flag_enable_cilkplus && TREE_CODE (arg) == ARRAY_NOTATION_REF)\n-\treturn 1;\n-\n       if (unify_one_argument (tparms, targs, parm, arg, subr, strict,\n \t\t\t      flags, explain_p))\n \treturn 1;\n@@ -19170,11 +19164,6 @@ instantiate_decl (tree d, int defer_ok,\n       pointer_map_destroy (local_specializations);\n       local_specializations = saved_local_specializations;\n \n-      /* We expand all the array notation expressions here.  */\n-      if (flag_enable_cilkplus\n-\t  && contains_array_notation_expr (DECL_SAVED_TREE (d)))\n-\tDECL_SAVED_TREE (d) = expand_array_notation_exprs (DECL_SAVED_TREE (d));\n-      \n       /* Finish the function.  */\n       d = finish_function (0);\n       expand_or_defer_fn (d);"}, {"sha": "f8217546b6ba4d167aa588228dac572caa245b05", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 3, "deletions": 18, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1141ed3f71c8a82067dbbbed6ec87c607bfd0be9/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1141ed3f71c8a82067dbbbed6ec87c607bfd0be9/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=1141ed3f71c8a82067dbbbed6ec87c607bfd0be9", "patch": "@@ -779,22 +779,6 @@ finish_return_stmt (tree expr)\n   tree r;\n   bool no_warning;\n \n-  if (flag_enable_cilkplus && contains_array_notation_expr (expr))\n-    {\n-      size_t rank = 0;\n-      \n-      if (!find_rank (input_location, expr, expr, false, &rank))\n-\treturn error_mark_node;\n-\n-      /* If the return expression contains array notations, then flag it as\n-\t error.  */\n-      if (rank >= 1)\n-\t{\n-\t  error_at (input_location, \"array notation expression cannot be \"\n-\t\t    \"used as a return value\");\n-\t  return error_mark_node;\n-\t}\n-    }\n   expr = check_return_expr (expr, &no_warning);\n \n   if (flag_openmp && !check_omp_return ())\n@@ -8089,7 +8073,6 @@ cxx_eval_constant_expression (const constexpr_call *call, tree t,\n \t\t\t\t       non_constant_p, overflow_p);\n       break;\n \n-    case ARRAY_NOTATION_REF:\n     case ARRAY_REF:\n       r = cxx_eval_array_reference (call, t, allow_non_constant, addr,\n \t\t\t\t    non_constant_p, overflow_p);\n@@ -8901,7 +8884,6 @@ potential_constant_expression_1 (tree t, bool want_rval, tsubst_flags_t flags)\n       want_rval = true;\n       /* Fall through.  */\n     case ARRAY_REF:\n-    case ARRAY_NOTATION_REF:\n     case ARRAY_RANGE_REF:\n     case MEMBER_REF:\n     case DOTSTAR_EXPR:\n@@ -8912,6 +8894,9 @@ potential_constant_expression_1 (tree t, bool want_rval, tsubst_flags_t flags)\n \t  return false;\n       return true;\n \n+    case ARRAY_NOTATION_REF:\n+      return false;\n+\n     case FMA_EXPR:\n     case VEC_PERM_EXPR:\n      for (i = 0; i < 3; ++i)"}, {"sha": "462abdd5039dffe0fce401c3a012dede3e434287", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 3, "deletions": 29, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1141ed3f71c8a82067dbbbed6ec87c607bfd0be9/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1141ed3f71c8a82067dbbbed6ec87c607bfd0be9/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=1141ed3f71c8a82067dbbbed6ec87c607bfd0be9", "patch": "@@ -3493,10 +3493,6 @@ cp_build_function_call_vec (tree function, vec<tree, va_gc> **params,\n       params = &allocated;\n     }\n \n-  if (flag_enable_cilkplus\n-      && is_cilkplus_reduce_builtin (fndecl) != BUILT_IN_NONE)\n-    nargs = (*params)->length ();\n-  else\n     nargs = convert_arguments (parm_types, params, fndecl, LOOKUP_NORMAL,\n \t\t\t       complain);\n   if (nargs < 0)\n@@ -3660,8 +3656,7 @@ convert_arguments (tree typelist, vec<tree, va_gc> **values, tree fndecl,\n \t}\n       else\n \t{\n-\t  if (fndecl && DECL_BUILT_IN (fndecl)\n-\t      && DECL_FUNCTION_CODE (fndecl) == BUILT_IN_CONSTANT_P)\n+\t  if (fndecl && magic_varargs_p (fndecl))\n \t    /* Don't do ellipsis conversion for __built_in_constant_p\n \t       as this will result in spurious errors for non-trivial\n \t       types.  */\n@@ -3956,15 +3951,8 @@ cp_build_binary_op (location_t location,\n \t}\n     }\n \n-  if (flag_enable_cilkplus && contains_array_notation_expr (op0))\n-    type0 = find_correct_array_notation_type (op0);\n-  else\n-    type0 = TREE_TYPE (op0);\n-\n-  if (flag_enable_cilkplus && contains_array_notation_expr (op1))\n-    type1 = find_correct_array_notation_type (op1);\n-  else\n-    type1 = TREE_TYPE (op1);\n+  type0 = TREE_TYPE (op0); \n+  type1 = TREE_TYPE (op1);\n \n   /* The expression codes of the data types of the arguments tell us\n      whether the arguments are integers, floating, pointers, etc.  */\n@@ -5182,13 +5170,6 @@ cp_build_addr_expr_1 (tree arg, bool strict_lvalue, tsubst_flags_t complain)\n \n   gcc_assert (!identifier_p (arg) || !IDENTIFIER_OPNAME_P (arg));\n \n-  if (flag_enable_cilkplus && TREE_CODE (arg) == ARRAY_NOTATION_REF)\n-    {\n-      val = build_address (arg);\n-      if (TREE_CODE (arg) == OFFSET_REF)\n-\tPTRMEM_OK_P (val) = PTRMEM_OK_P (arg);\n-      return val;\n-    }\n   if (TREE_CODE (arg) == COMPONENT_REF && type_unknown_p (arg)\n       && !really_overloaded_fn (TREE_OPERAND (arg, 1)))\n     {\n@@ -7867,13 +7848,6 @@ convert_for_assignment (tree type, tree rhs,\n   tree rhstype;\n   enum tree_code coder;\n \n-  /* If we are dealing with built-in array notation function then we don't need\n-     to convert them.  They will be broken up into modify exprs in future,\n-     during which all these checks will be done.  */\n-  if (flag_enable_cilkplus\n-      && is_cilkplus_reduce_builtin (fndecl) != BUILT_IN_NONE)\n-    return rhs;\n-  \n   /* Strip NON_LVALUE_EXPRs since we aren't using as an lvalue.  */\n   if (TREE_CODE (rhs) == NON_LVALUE_EXPR)\n     rhs = TREE_OPERAND (rhs, 0);"}, {"sha": "b9a61801a275b6c0b6404b09a45f50eb771351bb", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1141ed3f71c8a82067dbbbed6ec87c607bfd0be9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1141ed3f71c8a82067dbbbed6ec87c607bfd0be9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1141ed3f71c8a82067dbbbed6ec87c607bfd0be9", "patch": "@@ -1,3 +1,13 @@\n+2013-06-28  Balaji V. Iyer  <balaji.v.iyer@intel.com>\n+\n+\t* c-c++-common/cilk-plus/AN/decl-ptr-colon.c (main): Made this testcase\n+\tc specific.\n+\t* c-c++-common/cilk-plus/AN/decl-ptr-colon.c (main): Changed dg-error\n+\tstrings to match the fixed error messages.\n+\t* c-c++-common/cilk-plus/AN/misc.c (main): Likewise.\n+\t* c-c++-common/cilk-plus/AN/rank_mismatch.c (main): Added a new error\n+\tmessage check.\n+\n 2013-06-28  Michael Meissner  <meissner@linux.vnet.ibm.com>\n \n \tPR target/57744"}, {"sha": "4b54f4d06f729cc0a28d27d1d8a6f97cb65644a6", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/decl-ptr-colon.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1141ed3f71c8a82067dbbbed6ec87c607bfd0be9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fdecl-ptr-colon.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1141ed3f71c8a82067dbbbed6ec87c607bfd0be9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fdecl-ptr-colon.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fdecl-ptr-colon.c?ref=1141ed3f71c8a82067dbbbed6ec87c607bfd0be9", "patch": "@@ -1,3 +1,4 @@\n+/* { dg-do compile { target c } } */\n /* { dg-options \"-fcilkplus\" } */\n \n int main(void)"}, {"sha": "690e89a27d78587650b168ebc4bc22ffb3893820", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/dimensionless-arrays.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1141ed3f71c8a82067dbbbed6ec87c607bfd0be9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fdimensionless-arrays.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1141ed3f71c8a82067dbbbed6ec87c607bfd0be9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fdimensionless-arrays.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fdimensionless-arrays.c?ref=1141ed3f71c8a82067dbbbed6ec87c607bfd0be9", "patch": "@@ -5,6 +5,6 @@ extern int *b;\n \n void foo()\n {\n-  a[:] = 5;\t// { dg-error \"start-index and length fields necessary for using array notations in dimensionless arrays\" }\n-  b[:] = 5;    // { dg-error \"start-index and length fields necessary for using array notations in pointers\" }\n+  a[:] = 5;\t// { dg-error \"start-index and length fields necessary for using array notation\" }\n+  b[:] = 5;    // { dg-error \"start-index and length fields necessary for using\" }\n }"}, {"sha": "fa6d9003a00a6c337e33acb065ba5ff8c0cdf60a", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/fn_ptr.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1141ed3f71c8a82067dbbbed6ec87c607bfd0be9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Ffn_ptr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1141ed3f71c8a82067dbbbed6ec87c607bfd0be9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Ffn_ptr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Ffn_ptr.c?ref=1141ed3f71c8a82067dbbbed6ec87c607bfd0be9", "patch": "@@ -1,3 +1,4 @@\n+/* { dg-do compile } */\n /* { dg-options \"-fcilkplus\" } */\n \n typedef int (*foo)(int);\n@@ -10,11 +11,11 @@ int main(void)\n   foo ***func_array_ptr;\n   int argc = 5;\n \n-  array[:] =  func_array[:](10); /* { dg-error \"array notations cannot be used with function pointer arrays\" } */\n-  func_array[0:5](10); /* { dg-error \"array notations cannot be used with function pointer arrays\" } */\n-  func_array2[0:5][:](10); /* { dg-error \"array notations cannot be used with function pointer arrays\" } */\n-  array2[0:5][:] = func_array2[0:5][:](10); /* { dg-error \"array notations cannot be used with function pointer arrays\" } */\n-  func_array_ptr[0:5][0:4][0:argc:2](argc); /* { dg-error \"array notations cannot be used with function pointer arrays\" } */\n+  array[:] =  func_array[:](10); \n+  func_array[0:5](10); \n+  func_array2[0:5][:](10);\n+  array2[0:5][:] = func_array2[0:5][:](10);\n+  func_array_ptr[0:5][0:4][0:argc:2](argc); \n \n   return 0;\n }"}, {"sha": "814786b9961b2ad9d969e0e5053babc5a88b7260", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/misc.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1141ed3f71c8a82067dbbbed6ec87c607bfd0be9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1141ed3f71c8a82067dbbbed6ec87c607bfd0be9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fmisc.c?ref=1141ed3f71c8a82067dbbbed6ec87c607bfd0be9", "patch": "@@ -6,7 +6,7 @@ int main (void)\n   int array[10], array2[10][10];\n   int x, ii, jj ;\n \n-  switch (array[:]) {  /* { dg-error \"array notations cannot be used as a condition for switch statement\" } */\n+  switch (array[:]) {  /* { dg-error \"cannot be used as a condition for switch statement\" } */\n   case 1:\n     x = 5;\n     break;\n@@ -17,7 +17,7 @@ int main (void)\n     x = 9;\n   }\n \n-  switch (array2[:][:]) { /* { dg-error \"array notations cannot be used as a condition for switch statement\" } */\n+  switch (array2[:][:]) { /* { dg-error \"cannot be used as a condition for switch statement\" } */\n   case 1:\n     x = 5;\n     break;\n@@ -28,7 +28,7 @@ int main (void)\n     x = 9;\n   }\n \n-  switch (array[:] + x) { /* { dg-error \"array notations cannot be used as a condition for switch statement\" } */\n+  switch (array[:] + x) { /* { dg-error \"cannot be used as a condition for switch statement\" } */\n   case 1:\n     x = 5;\n     break;\n@@ -39,7 +39,7 @@ int main (void)\n     x = 9;\n   }\n   \n-  switch (array2[:][1:x:4] + x) { /* { dg-error \"array notations cannot be used as a condition for switch statement\" } */\n+  switch (array2[:][1:x:4] + x) { /* { dg-error \"cannot be used as a condition for switch statement\" } */\n   case 1:\n     x = 5;\n     break;\n@@ -50,36 +50,36 @@ int main (void)\n     x = 9;\n   }\n \n-  for (ii = 0; ii < array[:]; ii++) /* { dg-error \"array notations cannot be used in a condition for a for-loop\" } */\n+  for (ii = 0; ii < array[:]; ii++) /* { dg-error \"cannot be used in a condition for a for-loop\" } */\n     {\n       x = 2;\n     }\n \n-  for (ii = 0; ii < array2[:][:]; ii++) /* { dg-error \"array notations cannot be used in a condition for a for-loop\" } */\n+  for (ii = 0; ii < array2[:][:]; ii++) /* { dg-error \"cannot be used in a condition for a for-loop\" } */\n     {\n       x = 3;\n     }\n \n-  for (; array2[:][:] < 2;) /* { dg-error \"array notations cannot be used in a condition for a for-loop\" } */\n+  for (; array2[:][:] < 2;) /* { dg-error \"cannot be used in a condition for a for-loop\" } */\n     x = 4;\n \n \n-  while (array2[:][:]) /* { dg-error \"array notations cannot be used as a condition for while statement\" } */\n+  while (array2[:][:]) /* { dg-error \"cannot be used as a condition for while statement\" } */\n     x = 3;\n \n-  while (array[1:1:1]) /* { dg-error \"array notations cannot be used as a condition for while statement\" } */\n+  while (array[1:1:1]) /* { dg-error \"cannot be used as a condition for while statement\" } */\n     x = 1;\n \n-  while (ii != array2[1:x:3][1:2:1]) /* { dg-error \"array notations cannot be used as a condition for while statement\"  } */\n+  while (ii != array2[1:x:3][1:2:1]) /* { dg-error \"cannot be used as a condition for while statement\"  } */\n     x = 2;\n \n-  do { /* { dg-error \"array notations cannot be used as a condition for a do-while statement\" \"\" { target c } } */\n+  do { /* { dg-error \"cannot be used as a condition for a do-while statement\" \"\" { target c } } */\n     x = 3;\n-  } while (ii != array2[:][:]); /* { dg-error \"array notations cannot be used as a condition for a do-while statement\" \"\" { target c++ } } */\n+  } while (ii != array2[:][:]); /* { dg-error \"cannot be used as a condition for a do-while statement\" \"\" { target c++ } } */\n \n-  do {  /* { dg-error \"array notations cannot be used as a condition for a do-while statement\" \"\" { target c } } */\n+  do {  /* { dg-error \"cannot be used as a condition for a do-while statement\" \"\" { target c } } */\n     x = 2;\n-  } while (ii != (x + array2[:][1:x:2]) + 2); /* { dg-error \"array notations cannot be used as a condition for a do-while statement\" \"\" { target c++ } } */\n+  } while (ii != (x + array2[:][1:x:2]) + 2); /* { dg-error \"cannot be used as a condition for a do-while statement\" \"\" { target c++ } } */\n   \n   do { \n     x += 3;"}, {"sha": "eb3c1f1d68567cb90463ee75d8a78eae4b24d852", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/rank_mismatch.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1141ed3f71c8a82067dbbbed6ec87c607bfd0be9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Frank_mismatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1141ed3f71c8a82067dbbbed6ec87c607bfd0be9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Frank_mismatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Frank_mismatch.c?ref=1141ed3f71c8a82067dbbbed6ec87c607bfd0be9", "patch": "@@ -10,6 +10,7 @@ int main (void)\n   int array[10][10], array2[10];\n \n   array[:][:] = array[:]; /* { dg-error \"rank mismatch between\" } */\n+  /* { dg-error \"invalid conversion\" \"\" { target c++ } 12 } */\n \n   x = array2[:]; /* { dg-error \"cannot be scalar when\" } */\n "}]}