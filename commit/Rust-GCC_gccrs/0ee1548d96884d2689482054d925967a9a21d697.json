{"sha": "0ee1548d96884d2689482054d925967a9a21d697", "node_id": "C_kwDOANBUbNoAKDBlZTE1NDhkOTY4ODRkMjY4OTQ4MjA1NGQ5MjU5NjdhOWEyMWQ2OTc", "commit": {"author": {"name": "Kewen Lin", "email": "linkw@linux.ibm.com", "date": "2022-09-13T09:13:10Z"}, "committer": {"name": "Kewen Lin", "email": "linkw@linux.ibm.com", "date": "2022-09-13T10:39:04Z"}, "message": "rs6000: Suggest unroll factor for loop vectorization\n\nCommit r12-6679-g7ca1582ca60dc8 made vectorizer accept one\nunroll factor to be applied to vectorization factor when\nvectorizing the main loop, it would be suggested by target\nwhen doing costing.\n\nThis patch introduces function determine_suggested_unroll_factor\nfor rs6000 port, to make it be able to suggest the unroll factor\nfor a given loop being vectorized.  Referring to aarch64 port\nand basing on the analysis on SPEC2017 performance evaluation\nresults, it mainly considers these aspects:\n  1) unroll option and pragma which can disable unrolling for the\n     given loop;\n  2) simple hardware resource model with issued non memory access\n     vector insn per cycle;\n  3) aggressive heuristics when iteration count is unknown:\n     - reduction case to break cross iteration dependency;\n     - emulated gather load;\n  4) estimated iteration count when iteration count is unknown;\n\nWith this patch, SPEC2017 performance evaluation results on\nPower8/9/10 are listed below (speedup pct.):\n\n  * Power10\n    - O2: all are neutral (excluding some noises);\n    - Ofast: 510.parest_r +6.67%, the others are neutral\n             (use ... for the followings);\n    - Ofast + unroll: 510.parest_r +5.91%, ...\n    - Ofast + LTO + PGO: 510.parest_r +3.00%, ...\n    - Ofast + cheap vect cost: 510.parest_r +6.23%, ...\n    - Ofast + very-cheap vect cost: all are neutral;\n\n  * Power9\n    - Ofast: 510.parest_r +8.73%, 538.imagick_r +11.18%\n             (likely noise), 500.perlbench_r +1.84%, ...\n\n  * Power8\n    - Ofast: 510.parest_r +5.43%, ...;\n\nThis patch also introduces one documented parameter\nrs6000-vect-unroll-limit= similar to what aarch64 proposes,\nby evaluating on P8/P9/P10, the default value 4 is slightly\nbetter than the other choices like 2 and 8.\n\nIt also parameterizes two other values as undocumented\nparameters for future tweaking.  One parameter is\nrs6000-vect-unroll-issue, it's to simply model hardware\nresource for non memory access vector instructions to avoid\nexcessive unrolling, initially I tried to use the value in\nthe hook rs6000_issue_rate, but the evaluation showed it's\nbad, so I evaluated different values 2/4/6/8 on P8/P9/P10 at\nOfast, the results showed the default value 4 is good enough\non these different architectures.  For a record, choice 8\ncould make 510.parest_r's gain become smaller or gone on\nP8/P9/P10; choice 6 could make 503.bwaves_r degrade by more\nthan 1% on P8/P10; and choice 2 could make 538.imagick_r\ndegrade by 3.8%.  The other parameter is\nrs6000-vect-unroll-reduc-threshold.  It's mainly inspired by\n510.parest_r and tweaked as it, evaluating with different\nvalues 0/1/2/3 for the threshold, it showed value 1 is the\nbest choice.  For a record, choice 0 could make 525.x264_r\ndegrade by 2% and 527.cam4_r degrade by 2.95% on P10,\n548.exchange2_r degrade by 1.41% and 527.cam4_r degrade by\n2.54% on P8; choice 2 and bigger values could make\n510.parest_r's gain become smaller.\n\ngcc/ChangeLog:\n\n\t* config/rs6000/rs6000.cc (class rs6000_cost_data): Add new members\n\tm_nstores, m_reduc_factor, m_gather_load and member function\n\tdetermine_suggested_unroll_factor.\n\t(rs6000_cost_data::update_target_cost_per_stmt): Update for m_nstores,\n\tm_reduc_factor and m_gather_load.\n\t(rs6000_cost_data::determine_suggested_unroll_factor): New function.\n\t(rs6000_cost_data::finish_cost): Use determine_suggested_unroll_factor.\n\t* config/rs6000/rs6000.opt (rs6000-vect-unroll-limit): New parameter.\n\t(rs6000-vect-unroll-issue): Likewise.\n\t(rs6000-vect-unroll-reduc-threshold): Likewise.\n\t* doc/invoke.texi (rs6000-vect-unroll-limit): Document new parameter.", "tree": {"sha": "beafe3ac792e2ae39b4788765ab215d09c4b3d0c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/beafe3ac792e2ae39b4788765ab215d09c4b3d0c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0ee1548d96884d2689482054d925967a9a21d697", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ee1548d96884d2689482054d925967a9a21d697", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ee1548d96884d2689482054d925967a9a21d697", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ee1548d96884d2689482054d925967a9a21d697/comments", "author": {"login": "jedilyn", "id": 38515402, "node_id": "MDQ6VXNlcjM4NTE1NDAy", "avatar_url": "https://avatars.githubusercontent.com/u/38515402?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jedilyn", "html_url": "https://github.com/jedilyn", "followers_url": "https://api.github.com/users/jedilyn/followers", "following_url": "https://api.github.com/users/jedilyn/following{/other_user}", "gists_url": "https://api.github.com/users/jedilyn/gists{/gist_id}", "starred_url": "https://api.github.com/users/jedilyn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jedilyn/subscriptions", "organizations_url": "https://api.github.com/users/jedilyn/orgs", "repos_url": "https://api.github.com/users/jedilyn/repos", "events_url": "https://api.github.com/users/jedilyn/events{/privacy}", "received_events_url": "https://api.github.com/users/jedilyn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jedilyn", "id": 38515402, "node_id": "MDQ6VXNlcjM4NTE1NDAy", "avatar_url": "https://avatars.githubusercontent.com/u/38515402?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jedilyn", "html_url": "https://github.com/jedilyn", "followers_url": "https://api.github.com/users/jedilyn/followers", "following_url": "https://api.github.com/users/jedilyn/following{/other_user}", "gists_url": "https://api.github.com/users/jedilyn/gists{/gist_id}", "starred_url": "https://api.github.com/users/jedilyn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jedilyn/subscriptions", "organizations_url": "https://api.github.com/users/jedilyn/orgs", "repos_url": "https://api.github.com/users/jedilyn/repos", "events_url": "https://api.github.com/users/jedilyn/events{/privacy}", "received_events_url": "https://api.github.com/users/jedilyn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2c867232df70d3de304714906b4198ecb262eb32", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c867232df70d3de304714906b4198ecb262eb32", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c867232df70d3de304714906b4198ecb262eb32"}], "stats": {"total": 150, "additions": 147, "deletions": 3}, "files": [{"sha": "fcca062a870942ec229bd40e8a08f44b2f7a6889", "filename": "gcc/config/rs6000/rs6000.cc", "status": "modified", "additions": 122, "deletions": 3, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ee1548d96884d2689482054d925967a9a21d697/gcc%2Fconfig%2Frs6000%2Frs6000.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ee1548d96884d2689482054d925967a9a21d697/gcc%2Fconfig%2Frs6000%2Frs6000.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.cc?ref=0ee1548d96884d2689482054d925967a9a21d697", "patch": "@@ -5141,16 +5141,23 @@ class rs6000_cost_data : public vector_costs\n \t\t\t\t    vect_cost_model_location, unsigned int);\n   void density_test (loop_vec_info);\n   void adjust_vect_cost_per_loop (loop_vec_info);\n+  unsigned int determine_suggested_unroll_factor (loop_vec_info);\n \n   /* Total number of vectorized stmts (loop only).  */\n   unsigned m_nstmts = 0;\n   /* Total number of loads (loop only).  */\n   unsigned m_nloads = 0;\n+  /* Total number of stores (loop only).  */\n+  unsigned m_nstores = 0;\n+  /* Reduction factor for suggesting unroll factor (loop only).  */\n+  unsigned m_reduc_factor = 0;\n   /* Possible extra penalized cost on vector construction (loop only).  */\n   unsigned m_extra_ctor_cost = 0;\n   /* For each vectorized loop, this var holds TRUE iff a non-memory vector\n      instruction is needed by the vectorization.  */\n   bool m_vect_nonmem = false;\n+  /* If this loop gets vectorized with emulated gather load.  */\n+  bool m_gather_load = false;\n };\n \n /* Test for likely overcommitment of vector hardware resources.  If a\n@@ -5301,9 +5308,34 @@ rs6000_cost_data::update_target_cost_per_stmt (vect_cost_for_stmt kind,\n     {\n       m_nstmts += orig_count;\n \n-      if (kind == scalar_load || kind == vector_load\n-\t  || kind == unaligned_load || kind == vector_gather_load)\n-\tm_nloads += orig_count;\n+      if (kind == scalar_load\n+\t  || kind == vector_load\n+\t  || kind == unaligned_load\n+\t  || kind == vector_gather_load)\n+\t{\n+\t  m_nloads += orig_count;\n+\t  if (stmt_info && STMT_VINFO_GATHER_SCATTER_P (stmt_info))\n+\t    m_gather_load = true;\n+\t}\n+      else if (kind == scalar_store\n+\t       || kind == vector_store\n+\t       || kind == unaligned_store\n+\t       || kind == vector_scatter_store)\n+\tm_nstores += orig_count;\n+      else if ((kind == scalar_stmt\n+\t\t|| kind == vector_stmt\n+\t\t|| kind == vec_to_scalar)\n+\t       && stmt_info\n+\t       && vect_is_reduction (stmt_info))\n+\t{\n+\t  /* Loop body contains normal int or fp operations and epilogue\n+\t     contains vector reduction.  For simplicity, we assume int\n+\t     operation takes one cycle and fp operation takes one more.  */\n+\t  tree lhs = gimple_get_lhs (stmt_info->stmt);\n+\t  bool is_float = FLOAT_TYPE_P (TREE_TYPE (lhs));\n+\t  unsigned int basic_cost = is_float ? 2 : 1;\n+\t  m_reduc_factor = MAX (basic_cost * orig_count, m_reduc_factor);\n+\t}\n \n       /* Power processors do not currently have instructions for strided\n \t and elementwise loads, and instead we must generate multiple\n@@ -5395,6 +5427,90 @@ rs6000_cost_data::adjust_vect_cost_per_loop (loop_vec_info loop_vinfo)\n     }\n }\n \n+/* Determine suggested unroll factor by considering some below factors:\n+\n+    - unroll option/pragma which can disable unrolling for this loop;\n+    - simple hardware resource model for non memory vector insns;\n+    - aggressive heuristics when iteration count is unknown:\n+      - reduction case to break cross iteration dependency;\n+      - emulated gather load;\n+    - estimated iteration count when iteration count is unknown;\n+*/\n+\n+\n+unsigned int\n+rs6000_cost_data::determine_suggested_unroll_factor (loop_vec_info loop_vinfo)\n+{\n+  class loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n+\n+  /* Don't unroll if it's specified explicitly not to be unrolled.  */\n+  if (loop->unroll == 1\n+      || (OPTION_SET_P (flag_unroll_loops) && !flag_unroll_loops)\n+      || (OPTION_SET_P (flag_unroll_all_loops) && !flag_unroll_all_loops))\n+    return 1;\n+\n+  unsigned int nstmts_nonldst = m_nstmts - m_nloads - m_nstores;\n+  /* Don't unroll if no vector instructions excepting for memory access.  */\n+  if (nstmts_nonldst == 0)\n+    return 1;\n+\n+  /* Consider breaking cross iteration dependency for reduction.  */\n+  unsigned int reduc_factor = m_reduc_factor > 1 ? m_reduc_factor : 1;\n+\n+  /* Use this simple hardware resource model that how many non ld/st\n+     vector instructions can be issued per cycle.  */\n+  unsigned int issue_width = rs6000_vect_unroll_issue;\n+  unsigned int uf = CEIL (reduc_factor * issue_width, nstmts_nonldst);\n+  uf = MIN ((unsigned int) rs6000_vect_unroll_limit, uf);\n+  /* Make sure it is power of 2.  */\n+  uf = 1 << ceil_log2 (uf);\n+\n+  /* If the iteration count is known, the costing would be exact enough,\n+     don't worry it could be worse.  */\n+  if (LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo))\n+    return uf;\n+\n+  /* Inspired by SPEC2017 parest_r, we want to aggressively unroll the\n+     loop if either condition is satisfied:\n+       - reduction factor exceeds the threshold;\n+       - emulated gather load adopted.  */\n+  if (reduc_factor > (unsigned int) rs6000_vect_unroll_reduc_threshold\n+      || m_gather_load)\n+    return uf;\n+\n+  /* Check if we can conclude it's good to unroll from the estimated\n+     iteration count.  */\n+  HOST_WIDE_INT est_niter = get_estimated_loop_iterations_int (loop);\n+  unsigned int vf = vect_vf_for_cost (loop_vinfo);\n+  unsigned int unrolled_vf = vf * uf;\n+  if (est_niter == -1 || est_niter < unrolled_vf)\n+    /* When the estimated iteration of this loop is unknown, it's possible\n+       that we are able to vectorize this loop with the original VF but fail\n+       to vectorize it with the unrolled VF any more if the actual iteration\n+       count is in between.  */\n+    return 1;\n+  else\n+    {\n+      unsigned int epil_niter_unr = est_niter % unrolled_vf;\n+      unsigned int epil_niter = est_niter % vf;\n+      /* Even if we have partial vector support, it can be still inefficent\n+\t to calculate the length when the iteration count is unknown, so\n+\t only expect it's good to unroll when the epilogue iteration count\n+\t is not bigger than VF (only one time length calculation).  */\n+      if (LOOP_VINFO_CAN_USE_PARTIAL_VECTORS_P (loop_vinfo)\n+\t  && epil_niter_unr <= vf)\n+\treturn uf;\n+      /* Without partial vector support, conservatively unroll this when\n+\t the epilogue iteration count is less than the original one\n+\t (epilogue execution time wouldn't be longer than before).  */\n+      else if (!LOOP_VINFO_CAN_USE_PARTIAL_VECTORS_P (loop_vinfo)\n+\t       && epil_niter_unr <= epil_niter)\n+\treturn uf;\n+    }\n+\n+  return 1;\n+}\n+\n void\n rs6000_cost_data::finish_cost (const vector_costs *scalar_costs)\n {\n@@ -5411,6 +5527,9 @@ rs6000_cost_data::finish_cost (const vector_costs *scalar_costs)\n \t  && LOOP_VINFO_VECT_FACTOR (loop_vinfo) == 2\n \t  && LOOP_REQUIRES_VERSIONING (loop_vinfo))\n \tm_costs[vect_body] += 10000;\n+\n+      m_suggested_unroll_factor\n+\t= determine_suggested_unroll_factor (loop_vinfo);\n     }\n \n   vector_costs::finish_cost (scalar_costs);"}, {"sha": "b63a5d443af686fe4edcf5e82595eb0a473dc924", "filename": "gcc/config/rs6000/rs6000.opt", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ee1548d96884d2689482054d925967a9a21d697/gcc%2Fconfig%2Frs6000%2Frs6000.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ee1548d96884d2689482054d925967a9a21d697/gcc%2Fconfig%2Frs6000%2Frs6000.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.opt?ref=0ee1548d96884d2689482054d925967a9a21d697", "patch": "@@ -620,6 +620,14 @@ mieee128-constant\n Target Var(TARGET_IEEE128_CONSTANT) Init(1) Save\n Generate (do not generate) code that uses the LXVKQ instruction.\n \n+; Documented parameters\n+\n+-param=rs6000-vect-unroll-limit=\n+Target Joined UInteger Var(rs6000_vect_unroll_limit) Init(4) IntegerRange(1, 64) Param\n+Used to limit unroll factor which indicates how much the autovectorizer may\n+unroll a loop.  The default value is 4.\n+\n+; Undocumented parameters\n -param=rs6000-density-pct-threshold=\n Target Undocumented Joined UInteger Var(rs6000_density_pct_threshold) Init(85) IntegerRange(0, 100) Param\n When costing for loop vectorization, we probably need to penalize the loop body\n@@ -657,3 +665,13 @@ Like parameter rs6000-density-load-pct-threshold, we also check if the total\n number of load statements exceeds the threshold specified by this parameter,\n and penalize only if it's satisfied.  The default value is 20.\n \n+-param=rs6000-vect-unroll-issue=\n+Target Undocumented Joined UInteger Var(rs6000_vect_unroll_issue) Init(4) IntegerRange(1, 128) Param\n+Indicate how many non memory access vector instructions can be issued per\n+cycle, it's used in unroll factor determination for autovectorizer.  The\n+default value is 4.\n+\n+-param=rs6000-vect-unroll-reduc-threshold=\n+Target Undocumented Joined UInteger Var(rs6000_vect_unroll_reduc_threshold) Init(1) Param\n+When reduction factor computed for a loop exceeds the threshold specified by\n+this parameter, prefer to unroll this loop.  The default value is 1."}, {"sha": "aa5655764a0360959f9c1061749d2cc9ebd23489", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ee1548d96884d2689482054d925967a9a21d697/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ee1548d96884d2689482054d925967a9a21d697/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=0ee1548d96884d2689482054d925967a9a21d697", "patch": "@@ -29882,6 +29882,13 @@ Generate (do not generate) code that will run in privileged state.\n @opindex no-block-ops-unaligned-vsx\n Generate (do not generate) unaligned vsx loads and stores for\n inline expansion of @code{memcpy} and @code{memmove}.\n+\n+@item --param rs6000-vect-unroll-limit=\n+The vectorizer will check with target information to determine whether it\n+would be beneficial to unroll the main vectorized loop and by how much.  This\n+parameter sets the upper bound of how much the vectorizer will unroll the main\n+loop.  The default value is four.\n+\n @end table\n \n @node RX Options"}]}