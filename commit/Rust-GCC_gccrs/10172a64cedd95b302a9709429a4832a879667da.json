{"sha": "10172a64cedd95b302a9709429a4832a879667da", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTAxNzJhNjRjZWRkOTViMzAyYTk3MDk0MjlhNDgzMmE4Nzk2NjdkYQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2020-01-02T21:55:32Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2020-01-02T21:55:32Z"}, "message": "compiler, runtime, reflect: generate hash functions only for map keys\n    \n    Right now we generate hash functions for all types, just in case they\n    are used as map keys. That's a lot of wasted effort and binary size\n    for types which will never be used as a map key. Instead, generate\n    hash functions only for types that we know are map keys.\n    \n    Just doing that is a bit too simple, since maps with an interface type\n    as a key might have to hash any concrete key type that implements that\n    interface. So for that case, implement hashing of such types at\n    runtime (instead of with generated code). It will be slower, but only\n    for maps with interface types as keys, and maybe only a bit slower as\n    the aeshash time probably dominates the dispatch time.\n    \n    Reorg where we keep the equals and hash functions. Move the hash function\n    from the key type to the map type, saving a field in every non-map type.\n    That leaves only one function in the alg structure, so get rid of that and\n    just keep the equal function in the type descriptor itself.\n    \n    While we're here, reorganize the rtype struct to more closely match\n    the gc version.\n    \n    This is the gofrontend version of https://golang.org/cl/191198.\n    \n    Reviewed-on: https://go-review.googlesource.com/c/gofrontend/+/212843\n\nFrom-SVN: r279848", "tree": {"sha": "736b88eb69baa715a8ac1dbfb4b059eece8a049f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/736b88eb69baa715a8ac1dbfb4b059eece8a049f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/10172a64cedd95b302a9709429a4832a879667da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10172a64cedd95b302a9709429a4832a879667da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10172a64cedd95b302a9709429a4832a879667da", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10172a64cedd95b302a9709429a4832a879667da/comments", "author": null, "committer": null, "parents": [{"sha": "9279b5ba4538da8041f074db3f5fcd9e8ecff93e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9279b5ba4538da8041f074db3f5fcd9e8ecff93e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9279b5ba4538da8041f074db3f5fcd9e8ecff93e"}], "stats": {"total": 806, "additions": 421, "deletions": 385}, "files": [{"sha": "ea09abe42428d1ac8029d172ad3d0c879127c413", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10172a64cedd95b302a9709429a4832a879667da/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10172a64cedd95b302a9709429a4832a879667da/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=10172a64cedd95b302a9709429a4832a879667da", "patch": "@@ -1,4 +1,4 @@\n-b5c950fb98042fe434edca0c2403234692f25cd4\n+9163fa28b89222cd851c0d24bd6a1384d1379c55\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "b50d8a26f2d8dea28d79967b29b53ade645ce1a4", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10172a64cedd95b302a9709429a4832a879667da/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10172a64cedd95b302a9709429a4832a879667da/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=10172a64cedd95b302a9709429a4832a879667da", "patch": "@@ -2722,15 +2722,15 @@ Gogo::clear_file_scope()\n // parse tree is lowered.\n \n void\n-Gogo::queue_hash_function(Type* type, Named_type* name, int64_t size,\n+Gogo::queue_hash_function(Type* type, int64_t size,\n \t\t\t  const std::string& hash_name,\n \t\t\t  Function_type* hash_fntype)\n {\n   go_assert(!this->specific_type_functions_are_written_);\n   go_assert(!this->in_global_scope());\n   Specific_type_function::Specific_type_function_kind kind =\n     Specific_type_function::SPECIFIC_HASH;\n-  Specific_type_function* tsf = new Specific_type_function(type, name, size,\n+  Specific_type_function* tsf = new Specific_type_function(type, NULL, size,\n \t\t\t\t\t\t\t   kind, hash_name,\n \t\t\t\t\t\t\t   hash_fntype);\n   this->specific_type_functions_.push_back(tsf);\n@@ -2783,10 +2783,7 @@ Specific_type_functions::type(Type* t)\n \tif (nt->is_alias())\n \t  return TRAVERSE_CONTINUE;\n \tif (t->needs_specific_type_functions(this->gogo_))\n-\t  {\n-\t    t->equal_function(this->gogo_, nt, NULL);\n-\t    t->hash_function(this->gogo_, nt, NULL);\n-\t  }\n+\t  t->equal_function(this->gogo_, nt, NULL);\n \n \t// If this is a struct type, we don't want to make functions\n \t// for the unnamed struct.\n@@ -2820,10 +2817,15 @@ Specific_type_functions::type(Type* t)\n     case Type::TYPE_STRUCT:\n     case Type::TYPE_ARRAY:\n       if (t->needs_specific_type_functions(this->gogo_))\n-\t{\n-\t  t->equal_function(this->gogo_, NULL, NULL);\n-\t  t->hash_function(this->gogo_, NULL, NULL);\n-\t}\n+\tt->equal_function(this->gogo_, NULL, NULL);\n+      break;\n+\n+    case Type::TYPE_MAP:\n+      {\n+\tType* key_type = t->map_type()->key_type();\n+\tif (key_type->needs_specific_type_functions(this->gogo_))\n+\t  key_type->hash_function(this->gogo_, NULL);\n+      }\n       break;\n \n     default:\n@@ -2846,8 +2848,8 @@ Gogo::write_specific_type_functions()\n       Specific_type_function* tsf = this->specific_type_functions_.back();\n       this->specific_type_functions_.pop_back();\n       if (tsf->kind == Specific_type_function::SPECIFIC_HASH)\n-\ttsf->type->write_hash_function(this, tsf->name, tsf->size,\n-\t\t\t\t       tsf->fnname, tsf->fntype);\n+\ttsf->type->write_hash_function(this, tsf->size, tsf->fnname,\n+\t\t\t\t       tsf->fntype);\n       else\n \ttsf->type->write_equal_function(this, tsf->name, tsf->size,\n \t\t\t\t\ttsf->fnname, tsf->fntype);"}, {"sha": "27d7b4cf2f866d9a84b3c81003d06090d112182a", "filename": "gcc/go/gofrontend/gogo.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10172a64cedd95b302a9709429a4832a879667da/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10172a64cedd95b302a9709429a4832a879667da/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.h?ref=10172a64cedd95b302a9709429a4832a879667da", "patch": "@@ -602,8 +602,7 @@ class Gogo\n   // is used when a type-specific hash function is needed when not at\n   // top level.\n   void\n-  queue_hash_function(Type* type, Named_type* name, int64_t size,\n-\t\t      const std::string& hash_name,\n+  queue_hash_function(Type* type, int64_t size, const std::string& hash_name,\n \t\t      Function_type* hash_fntype);\n \n   // Queue up a type-specific equal function to be written out.  This\n@@ -879,7 +878,7 @@ class Gogo\n \n   // Return the name of the hash function for TYPE.\n   std::string\n-  hash_function_name(const Type*, const Named_type*);\n+  hash_function_name(const Type*);\n \n   // Return the name of the equal function for TYPE.\n   std::string"}, {"sha": "f4ad181515b835ce7a8ac6bf49be5e7f22f376b1", "filename": "gcc/go/gofrontend/names.cc", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10172a64cedd95b302a9709429a4832a879667da/gcc%2Fgo%2Fgofrontend%2Fnames.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10172a64cedd95b302a9709429a4832a879667da/gcc%2Fgo%2Fgofrontend%2Fnames.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fnames.cc?ref=10172a64cedd95b302a9709429a4832a879667da", "patch": "@@ -287,16 +287,12 @@ Gogo::stub_method_name(const Package* package, const std::string& mname)\n   return ret;\n }\n \n-// Return the name of the hash function for TYPE.  If NAME is not NULL\n-// it is the name of the type.\n+// Return the name of the hash function for TYPE.\n \n std::string\n-Gogo::hash_function_name(const Type* type, const Named_type* name)\n+Gogo::hash_function_name(const Type* type)\n {\n-  const Type* rtype = type;\n-  if (name != NULL)\n-    rtype = name;\n-  std::string tname = rtype->mangled_name(this);\n+  std::string tname = type->mangled_name(this);\n   return tname + \"..hash\";\n }\n "}, {"sha": "27d53df2c356510193a8d97f7ed77493548cbacc", "filename": "gcc/go/gofrontend/types.cc", "status": "modified", "additions": 81, "deletions": 128, "changes": 209, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10172a64cedd95b302a9709429a4832a879667da/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10172a64cedd95b302a9709429a4832a879667da/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc?ref=10172a64cedd95b302a9709429a4832a879667da", "patch": "@@ -1540,6 +1540,11 @@ Type::convert_builtin_named_types(Gogo* gogo)\n     }\n }\n \n+// Values to store in the tflag field of a type descriptor.  This must\n+// match the definitions in libgo/go/runtime/type.go.\n+\n+const int TFLAG_REGULAR_MEMORY = 1 << 3;\n+\n // Return the type of a type descriptor.  We should really tie this to\n // runtime.Type rather than copying it.  This must match the struct \"_type\"\n // declared in libgo/go/runtime/type.go.\n@@ -1566,21 +1571,11 @@ Type::make_type_descriptor_type()\n       Type* void_type = Type::make_void_type();\n       Type* unsafe_pointer_type = Type::make_pointer_type(void_type);\n \n-      Typed_identifier_list *params = new Typed_identifier_list();\n-      params->push_back(Typed_identifier(\"key\", unsafe_pointer_type, bloc));\n-      params->push_back(Typed_identifier(\"seed\", uintptr_type, bloc));\n-\n-      Typed_identifier_list* results = new Typed_identifier_list();\n-      results->push_back(Typed_identifier(\"\", uintptr_type, bloc));\n-\n-      Type* hash_fntype = Type::make_function_type(NULL, params, results,\n-\t\t\t\t\t\t   bloc);\n-\n-      params = new Typed_identifier_list();\n+      Typed_identifier_list* params = new Typed_identifier_list();\n       params->push_back(Typed_identifier(\"key1\", unsafe_pointer_type, bloc));\n       params->push_back(Typed_identifier(\"key2\", unsafe_pointer_type, bloc));\n \n-      results = new Typed_identifier_list();\n+      Typed_identifier_list* results = new Typed_identifier_list();\n       results->push_back(Typed_identifier(\"\", Type::lookup_bool_type(), bloc));\n \n       Type* equal_fntype = Type::make_function_type(NULL, params, results,\n@@ -1624,11 +1619,11 @@ Type::make_type_descriptor_type()\n \t\t\t\t       \"size\", uintptr_type,\n \t\t\t\t       \"ptrdata\", uintptr_type,\n \t\t\t\t       \"hash\", uint32_type,\n-\t\t\t\t       \"kind\", uint8_type,\n+\t\t\t\t       \"tflag\", uint8_type,\n \t\t\t\t       \"align\", uint8_type,\n \t\t\t\t       \"fieldAlign\", uint8_type,\n-\t\t\t\t       \"hashfn\", hash_fntype,\n-\t\t\t\t       \"equalfn\", equal_fntype,\n+\t\t\t\t       \"kind\", uint8_type,\n+\t\t\t\t       \"equal\", equal_fntype,\n \t\t\t\t       \"gcdata\", pointer_uint8_type,\n \t\t\t\t       \"string\", pointer_string_type,\n \t\t\t\t       \"\", pointer_uncommon_type,\n@@ -1741,18 +1736,13 @@ Type::needs_specific_type_functions(Gogo* gogo)\n }\n \n // Return the runtime function that computes the hash of this type.\n-// If NAME is not NULL it is the name of this type.  HASH_FNTYPE is\n-// the type of the hash function function, for convenience; it may be\n-// NULL.  This returns NULL if the type is not comparable.\n+// HASH_FNTYPE is the type of the hash function function, for\n+// convenience; it may be NULL.  This returns NULL if the type is not\n+// comparable.\n \n Named_object*\n-Type::hash_function(Gogo* gogo, Named_type* name, Function_type* hash_fntype)\n+Type::hash_function(Gogo* gogo, Function_type* hash_fntype)\n {\n-  // If the unaliased type is not a named type, then the type does not\n-  // have a name after all.\n-  if (name != NULL)\n-    name = name->unalias()->named_type();\n-\n   if (!this->is_comparable())\n     return NULL;\n \n@@ -1803,7 +1793,7 @@ Type::hash_function(Gogo* gogo, Named_type* name, Function_type* hash_fntype)\n \t  // We don't have a built-in function for a type of this\n \t  // size.  Build a function to use that calls the generic\n \t  // hash functions for identity, passing the size.\n-\t  return this->build_hash_function(gogo, name, size, hash_fntype);\n+\t  return this->build_hash_function(gogo, size, hash_fntype);\n \t}\n     }\n   else\n@@ -1861,7 +1851,7 @@ Type::hash_function(Gogo* gogo, Named_type* name, Function_type* hash_fntype)\n \t  // This is a struct which can not be compared using a simple\n \t  // identity function.  We need to build a function to\n \t  // compute the hash.\n-\t  return this->build_hash_function(gogo, name, -1, hash_fntype);\n+\t  return this->build_hash_function(gogo, -1, hash_fntype);\n \n \tcase Type::TYPE_ARRAY:\n \t  if (this->is_slice_type())\n@@ -1875,7 +1865,7 @@ Type::hash_function(Gogo* gogo, Named_type* name, Function_type* hash_fntype)\n \t      // This is an array which can not be compared using a\n \t      // simple identity function.  We need to build a\n \t      // function to compute the hash.\n-\t      return this->build_hash_function(gogo, name, -1, hash_fntype);\n+\t      return this->build_hash_function(gogo, -1, hash_fntype);\n \t    }\n \t  break;\n \n@@ -1895,7 +1885,6 @@ Type::hash_function(Gogo* gogo, Named_type* name, Function_type* hash_fntype)\n \t}\n     }\n \n-\n   Location bloc = Linemap::predeclared_location();\n   Named_object *hash_fn = Named_object::make_function_declaration(hash_fnname,\n \t\t\t\t\t\t\t\t  NULL,\n@@ -1913,12 +1902,20 @@ Type::Type_function Type::type_hash_functions_table;\n // this is a struct or array type that cannot use an identity\n // comparison.  Otherwise, it is a type that uses an identity\n // comparison but is not one of the standard supported sizes.\n+//\n+// Unlike an equality function, hash functions are not in type\n+// descriptors, so we can't assume that a named type has defined a\n+// hash function in the package that defines the type.  So hash\n+// functions are always defined locally.  FIXME: It would be better to\n+// define hash functions with comdat linkage so that duplicate hash\n+// functions can be coalesced at link time.\n \n Named_object*\n-Type::build_hash_function(Gogo* gogo, Named_type* name, int64_t size,\n-\t\t\t  Function_type* hash_fntype)\n+Type::build_hash_function(Gogo* gogo, int64_t size, Function_type* hash_fntype)\n {\n-  std::pair<Type*, Named_object*> val(name != NULL ? name : this, NULL);\n+  Type* type = this->base();\n+\n+  std::pair<Type*, Named_object*> val(type, NULL);\n   std::pair<Type_function::iterator, bool> ins =\n     Type::type_hash_functions_table.insert(val);\n   if (!ins.second)\n@@ -1927,38 +1924,27 @@ Type::build_hash_function(Gogo* gogo, Named_type* name, int64_t size,\n       return ins.first->second;\n     }\n \n-  std::string hash_name = gogo->hash_function_name(this, name);\n+  std::string hash_name = gogo->hash_function_name(type);\n \n   Location bloc = Linemap::predeclared_location();\n \n-  const Package* package = NULL;\n-  bool is_defined_elsewhere =\n-    this->type_descriptor_defined_elsewhere(name, &package);\n-\n-  Named_object* hash_fn;\n-  if (is_defined_elsewhere)\n-    hash_fn = Named_object::make_function_declaration(hash_name, package,\n-\t\t\t\t\t\t      hash_fntype, bloc);\n-  else\n-    hash_fn = gogo->declare_package_function(hash_name, hash_fntype, bloc);\n+  Named_object* hash_fn = gogo->declare_package_function(hash_name,\n+\t\t\t\t\t\t\t hash_fntype, bloc);\n \n   ins.first->second = hash_fn;\n \n-  if (!is_defined_elsewhere)\n-    {\n-      if (gogo->in_global_scope())\n-\tthis->write_hash_function(gogo, name, size, hash_name, hash_fntype);\n-      else\n-\tgogo->queue_hash_function(this, name, size, hash_name, hash_fntype);\n-    }\n+  if (gogo->in_global_scope())\n+    type->write_hash_function(gogo, size, hash_name, hash_fntype);\n+  else\n+    gogo->queue_hash_function(type, size, hash_name, hash_fntype);\n \n   return hash_fn;\n }\n \n // Write the hash function for a type that needs it written specially.\n \n void\n-Type::write_hash_function(Gogo* gogo, Named_type* name, int64_t size,\n+Type::write_hash_function(Gogo* gogo, int64_t size,\n \t\t\t  const std::string& hash_name,\n \t\t\t  Function_type* hash_fntype)\n {\n@@ -1979,12 +1965,10 @@ Type::write_hash_function(Gogo* gogo, Named_type* name, int64_t size,\n \n   if (size != -1)\n     this->write_identity_hash(gogo, size);\n-  else if (name != NULL && name->real_type()->named_type() != NULL)\n-    this->write_named_hash(gogo, name, hash_fntype);\n   else if (this->struct_type() != NULL)\n-    this->struct_type()->write_hash_function(gogo, name, hash_fntype);\n+    this->struct_type()->write_hash_function(gogo, hash_fntype);\n   else if (this->array_type() != NULL)\n-    this->array_type()->write_hash_function(gogo, name, hash_fntype);\n+    this->array_type()->write_hash_function(gogo, hash_fntype);\n   else\n     go_unreachable();\n \n@@ -2052,54 +2036,6 @@ Type::write_identity_hash(Gogo* gogo, int64_t size)\n   gogo->add_statement(s);\n }\n \n-// Write a hash function that simply calls the hash function for a\n-// named type.  This is used when one named type is defined as\n-// another.  This ensures that this case works when the other named\n-// type is defined in another package and relies on calling hash\n-// functions defined only in that package.\n-\n-void\n-Type::write_named_hash(Gogo* gogo, Named_type* name,\n-\t\t       Function_type* hash_fntype)\n-{\n-  Location bloc = Linemap::predeclared_location();\n-\n-  Named_type* base_type = name->real_type()->named_type();\n-  while (base_type->is_alias())\n-    {\n-      base_type = base_type->real_type()->named_type();\n-      go_assert(base_type != NULL);\n-    }\n-  go_assert(base_type != NULL);\n-\n-  // The pointer to the type we are going to hash.  This is an\n-  // unsafe.Pointer.\n-  Named_object* key_arg = gogo->lookup(\"key\", NULL);\n-  go_assert(key_arg != NULL);\n-\n-  // The seed argument to the hash function.\n-  Named_object* seed_arg = gogo->lookup(\"seed\", NULL);\n-  go_assert(seed_arg != NULL);\n-\n-  Named_object* hash_fn = name->real_type()->hash_function(gogo, base_type,\n-\t\t\t\t\t\t\t   hash_fntype);\n-\n-  // Call the hash function for the base type.\n-  Expression* key_ref = Expression::make_var_reference(key_arg, bloc);\n-  Expression* seed_ref = Expression::make_var_reference(seed_arg, bloc);\n-  Expression_list* args = new Expression_list();\n-  args->push_back(key_ref);\n-  args->push_back(seed_ref);\n-  Expression* func = Expression::make_func_reference(hash_fn, NULL, bloc);\n-  Expression* call = Expression::make_call(func, args, false, bloc);\n-\n-  // Return the hash of the base type.\n-  Expression_list* vals = new Expression_list();\n-  vals->push_back(call);\n-  Statement* s = Statement::make_return_statement(vals, bloc);\n-  gogo->add_statement(s);\n-}\n-\n // Return the runtime function that compares whether two values of\n // this type are equal.  If NAME is not NULL it is the name of this\n // type.  EQUAL_FNTYPE is the type of the equality function, for\n@@ -2572,9 +2508,11 @@ Type::type_descriptor_constructor(Gogo* gogo, int runtime_type_kind,\n   vals->push_back(Expression::make_integer_ul(h, p->type(), bloc));\n \n   ++p;\n-  go_assert(p->is_field_name(\"kind\"));\n-  vals->push_back(Expression::make_integer_ul(runtime_type_kind, p->type(),\n-\t\t\t\t\t      bloc));\n+  go_assert(p->is_field_name(\"tflag\"));\n+  unsigned long tflag = 0;\n+  if (this->compare_is_identity(gogo))\n+    tflag |= TFLAG_REGULAR_MEMORY;\n+  vals->push_back(Expression::make_integer_ul(tflag, p->type(), bloc));\n \n   ++p;\n   go_assert(p->is_field_name(\"align\"));\n@@ -2587,18 +2525,12 @@ Type::type_descriptor_constructor(Gogo* gogo, int runtime_type_kind,\n   vals->push_back(Expression::make_type_info(this, type_info));\n \n   ++p;\n-  go_assert(p->is_field_name(\"hashfn\"));\n-  Function_type* hash_fntype = p->type()->function_type();\n-  Named_object* hash_fn = this->hash_function(gogo, name, hash_fntype);\n-  if (hash_fn == NULL)\n-    vals->push_back(Expression::make_cast(hash_fntype,\n-\t\t\t\t\t  Expression::make_nil(bloc),\n-\t\t\t\t\t  bloc));\n-  else\n-    vals->push_back(Expression::make_func_reference(hash_fn, NULL, bloc));\n+  go_assert(p->is_field_name(\"kind\"));\n+  vals->push_back(Expression::make_integer_ul(runtime_type_kind, p->type(),\n+\t\t\t\t\t      bloc));\n \n   ++p;\n-  go_assert(p->is_field_name(\"equalfn\"));\n+  go_assert(p->is_field_name(\"equal\"));\n   Function_type* equal_fntype = p->type()->function_type();\n   Named_object* equal_fn = this->equal_function(gogo, name, equal_fntype);\n   if (equal_fn == NULL)\n@@ -6603,8 +6535,7 @@ Struct_type::do_type_descriptor(Gogo* gogo, Named_type* name)\n // function.\n \n void\n-Struct_type::write_hash_function(Gogo* gogo, Named_type*,\n-\t\t\t\t Function_type* hash_fntype)\n+Struct_type::write_hash_function(Gogo* gogo, Function_type* hash_fntype)\n {\n   Location bloc = Linemap::predeclared_location();\n \n@@ -6650,8 +6581,7 @@ Struct_type::write_hash_function(Gogo* gogo, Named_type*,\n       subkey = Expression::make_cast(key_arg_type, subkey, bloc);\n \n       // Get the hash function to use for the type of this field.\n-      Named_object* hash_fn =\n-\tpf->type()->hash_function(gogo, pf->type()->named_type(), hash_fntype);\n+      Named_object* hash_fn = pf->type()->hash_function(gogo, hash_fntype);\n \n       // Call the hash function for the field, passing retval as the seed.\n       ref = Expression::make_temporary_reference(retval, bloc);\n@@ -7447,8 +7377,7 @@ Array_type::do_hash_for_method(Gogo* gogo, int flags) const\n // function.\n \n void\n-Array_type::write_hash_function(Gogo* gogo, Named_type* name,\n-\t\t\t\tFunction_type* hash_fntype)\n+Array_type::write_hash_function(Gogo* gogo, Function_type* hash_fntype)\n {\n   Location bloc = Linemap::predeclared_location();\n \n@@ -7485,9 +7414,7 @@ Array_type::write_hash_function(Gogo* gogo, Named_type* name,\n \n   Expression* iref = Expression::make_temporary_reference(index, bloc);\n   Expression* aref = Expression::make_var_reference(key_arg, bloc);\n-  Type* pt = Type::make_pointer_type(name != NULL\n-\t\t\t\t     ? static_cast<Type*>(name)\n-\t\t\t\t     : static_cast<Type*>(this));\n+  Type* pt = Type::make_pointer_type(static_cast<Type*>(this));\n   aref = Expression::make_cast(pt, aref, bloc);\n   For_range_statement* for_range = Statement::make_for_range_statement(iref,\n \t\t\t\t\t\t\t\t       NULL,\n@@ -7497,9 +7424,8 @@ Array_type::write_hash_function(Gogo* gogo, Named_type* name,\n   gogo->start_block(bloc);\n \n   // Get the hash function for the element type.\n-  Named_object* hash_fn =\n-    this->element_type_->hash_function(gogo, this->element_type_->named_type(),\n-\t\t\t\t       hash_fntype);\n+  Named_object* hash_fn = this->element_type_->hash_function(gogo,\n+\t\t\t\t\t\t\t     hash_fntype);\n \n   // Get a pointer to this element in the loop.\n   Expression* subkey = Expression::make_temporary_reference(key, bloc);\n@@ -8291,13 +8217,28 @@ Map_type::make_map_type_descriptor_type()\n       Type* uint8_type = Type::lookup_integer_type(\"uint8\");\n       Type* uint16_type = Type::lookup_integer_type(\"uint16\");\n       Type* uint32_type = Type::lookup_integer_type(\"uint32\");\n+      Type* uintptr_type = Type::lookup_integer_type(\"uintptr\");\n+      Type* void_type = Type::make_void_type();\n+      Type* unsafe_pointer_type = Type::make_pointer_type(void_type);\n+\n+      Location bloc = Linemap::predeclared_location();\n+      Typed_identifier_list *params = new Typed_identifier_list();\n+      params->push_back(Typed_identifier(\"key\", unsafe_pointer_type, bloc));\n+      params->push_back(Typed_identifier(\"seed\", uintptr_type, bloc));\n+\n+      Typed_identifier_list* results = new Typed_identifier_list();\n+      results->push_back(Typed_identifier(\"\", uintptr_type, bloc));\n+\n+      Type* hasher_fntype = Type::make_function_type(NULL, params, results,\n+\t\t\t\t\t\t     bloc);\n \n       Struct_type* sf =\n-\tType::make_builtin_struct_type(8,\n+\tType::make_builtin_struct_type(9,\n \t\t\t\t       \"\", tdt,\n \t\t\t\t       \"key\", ptdt,\n \t\t\t\t       \"elem\", ptdt,\n \t\t\t\t       \"bucket\", ptdt,\n+\t\t\t\t       \"hasher\", hasher_fntype,\n \t\t\t\t       \"keysize\", uint8_type,\n \t\t\t\t       \"valuesize\", uint8_type,\n \t\t\t\t       \"bucketsize\", uint16_type,\n@@ -8379,6 +8320,18 @@ Map_type::do_type_descriptor(Gogo* gogo, Named_type* name)\n   go_assert(p->is_field_name(\"bucket\"));\n   vals->push_back(Expression::make_type_descriptor(bucket_type, bloc));\n \n+  ++p;\n+  go_assert(p->is_field_name(\"hasher\"));\n+  Function_type* hasher_fntype = p->type()->function_type();\n+  Named_object* hasher_fn = this->key_type_->hash_function(gogo,\n+\t\t\t\t\t\t\t   hasher_fntype);\n+  if (hasher_fn == NULL)\n+    vals->push_back(Expression::make_cast(hasher_fntype,\n+\t\t\t\t\t  Expression::make_nil(bloc),\n+\t\t\t\t\t  bloc));\n+  else\n+    vals->push_back(Expression::make_func_reference(hasher_fn, NULL, bloc));\n+\n   ++p;\n   go_assert(p->is_field_name(\"keysize\"));\n   if (keysize > Map_type::max_key_size)"}, {"sha": "ef81589682f8dcd64c3a2ddfbf106fc429b3ce54", "filename": "gcc/go/gofrontend/types.h", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10172a64cedd95b302a9709429a4832a879667da/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10172a64cedd95b302a9709429a4832a879667da/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.h?ref=10172a64cedd95b302a9709429a4832a879667da", "patch": "@@ -1061,7 +1061,7 @@ class Type\n   // Get the hash function for a type.  Returns NULL if the type is\n   // not comparable.\n   Named_object*\n-  hash_function(Gogo*, Named_type* name, Function_type* hash_fntype);\n+  hash_function(Gogo*, Function_type* hash_fntype);\n \n   // Write the equal function for a type.\n   void\n@@ -1071,8 +1071,7 @@ class Type\n \n   // Write the hash function for a type.\n   void\n-  write_hash_function(Gogo*, Named_type*, int64_t size,\n-\t\t      const std::string& hash_name,\n+  write_hash_function(Gogo*, int64_t size, const std::string& hash_name,\n \t\t      Function_type* hash_fntype);\n \n   // Return the alignment required by the memequalN function.\n@@ -1284,8 +1283,7 @@ class Type\n \n   // Build the hash function for a type that needs specific functions.\n   Named_object*\n-  build_hash_function(Gogo*, Named_type*, int64_t size,\n-\t\t      Function_type* hash_fntype);\n+  build_hash_function(Gogo*, int64_t size, Function_type* hash_fntype);\n \n   // Build the equal function for a type that needs specific functions.\n   Named_object*\n@@ -1298,9 +1296,6 @@ class Type\n   void\n   write_identity_equal(Gogo*, int64_t size);\n \n-  void\n-  write_named_hash(Gogo*, Named_type*, Function_type* hash_fntype);\n-\n   void\n   write_named_equal(Gogo*, Named_type*);\n \n@@ -2628,7 +2623,7 @@ class Struct_type : public Type\n \n   // Write the hash function for this type.\n   void\n-  write_hash_function(Gogo*, Named_type*, Function_type*);\n+  write_hash_function(Gogo*, Function_type*);\n \n   // Write the equality function for this type.\n   void\n@@ -2815,7 +2810,7 @@ class Array_type : public Type\n \n   // Write the hash function for this type.\n   void\n-  write_hash_function(Gogo*, Named_type*, Function_type*);\n+  write_hash_function(Gogo*, Function_type*);\n \n   // Write the equality function for this type.\n   void"}, {"sha": "35cf1a4fefe457ed3f48e961695e372243cb200e", "filename": "libgo/go/internal/reflectlite/type.go", "status": "modified", "additions": 10, "deletions": 30, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10172a64cedd95b302a9709429a4832a879667da/libgo%2Fgo%2Finternal%2Freflectlite%2Ftype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10172a64cedd95b302a9709429a4832a879667da/libgo%2Fgo%2Finternal%2Freflectlite%2Ftype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Finternal%2Freflectlite%2Ftype.go?ref=10172a64cedd95b302a9709429a4832a879667da", "patch": "@@ -110,33 +110,14 @@ const (\n // available in the memory directly following the rtype value.\n //\n // tflag values must be kept in sync with copies in:\n-//\tcmd/compile/internal/gc/reflect.go\n-//\tcmd/link/internal/ld/decodesym.go\n+//\tgo/types.cc\n //\truntime/type.go\n type tflag uint8\n \n const (\n-\t// tflagUncommon means that there is a pointer, *uncommonType,\n-\t// just beyond the outer type structure.\n-\t//\n-\t// For example, if t.Kind() == Struct and t.tflag&tflagUncommon != 0,\n-\t// then t has uncommonType data and it can be accessed as:\n-\t//\n-\t//\ttype tUncommon struct {\n-\t//\t\tstructType\n-\t//\t\tu uncommonType\n-\t//\t}\n-\t//\tu := &(*tUncommon)(unsafe.Pointer(t)).u\n-\ttflagUncommon tflag = 1 << 0\n-\n-\t// tflagExtraStar means the name in the str field has an\n-\t// extraneous '*' prefix. This is because for most types T in\n-\t// a program, the type *T also exists and reusing the str data\n-\t// saves binary size.\n-\ttflagExtraStar tflag = 1 << 1\n-\n-\t// tflagNamed means the type has a name.\n-\ttflagNamed tflag = 1 << 2\n+\t// tflagRegularMemory means that equal and hash functions can treat\n+\t// this type as a single region of t.size bytes.\n+\ttflagRegularMemory tflag = 1 << 3\n )\n \n // rtype is the common implementation of most values.\n@@ -147,16 +128,15 @@ type rtype struct {\n \tsize       uintptr\n \tptrdata    uintptr // number of bytes in the type that can contain pointers\n \thash       uint32  // hash of type; avoids computation in hash tables\n-\tkind       uint8   // enumeration for C\n+\ttflag      tflag   // extra type information flags\n \talign      uint8   // alignment of variable with this type\n \tfieldAlign uint8   // alignment of struct field with this type\n-\t_          uint8   // unused/padding\n-\n-\thashfn  func(unsafe.Pointer, uintptr) uintptr     // hash function\n-\tequalfn func(unsafe.Pointer, unsafe.Pointer) bool // equality function\n-\n+\tkind       uint8   // enumeration for C\n+\t// function for comparing objects of this type\n+\t// (ptr to object A, ptr to object B) -> ==?\n+\tequal         func(unsafe.Pointer, unsafe.Pointer) bool\n \tgcdata        *byte   // garbage collection data\n-\tstring        *string // string form; unnecessary  but undeniably useful\n+\tstring        *string // string form; unnecessary but undeniably useful\n \t*uncommonType         // (relatively) uncommon fields\n \tptrToThis     *rtype  // type for pointer to this type, may be zero\n }"}, {"sha": "41ed383fc8e233e2a16e6dd6061c496e3e762334", "filename": "libgo/go/reflect/type.go", "status": "modified", "additions": 53, "deletions": 88, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10172a64cedd95b302a9709429a4832a879667da/libgo%2Fgo%2Freflect%2Ftype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10172a64cedd95b302a9709429a4832a879667da/libgo%2Fgo%2Freflect%2Ftype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Ftype.go?ref=10172a64cedd95b302a9709429a4832a879667da", "patch": "@@ -261,6 +261,20 @@ const (\n \tUnsafePointer\n )\n \n+// tflag is used by an rtype to signal what extra type information is\n+// available in the memory directly following the rtype value.\n+//\n+// tflag values must be kept in sync with copies in:\n+//\tgo/types.cc\n+//\truntime/type.go\n+type tflag uint8\n+\n+const (\n+\t// tflagRegularMemory means that equal and hash functions can treat\n+\t// this type as a single region of t.size bytes.\n+\ttflagRegularMemory tflag = 1 << 3\n+)\n+\n // rtype is the common implementation of most values.\n // It is embedded in other struct types.\n //\n@@ -269,16 +283,15 @@ type rtype struct {\n \tsize       uintptr\n \tptrdata    uintptr // size of memory prefix holding all pointers\n \thash       uint32  // hash of type; avoids computation in hash tables\n-\tkind       uint8   // enumeration for C\n-\talign      int8    // alignment of variable with this type\n+\ttflag      tflag   // extra type information flags\n+\talign      uint8   // alignment of variable with this type\n \tfieldAlign uint8   // alignment of struct field with this type\n-\t_          uint8   // unused/padding\n-\n-\thashfn  func(unsafe.Pointer, uintptr) uintptr     // hash function\n-\tequalfn func(unsafe.Pointer, unsafe.Pointer) bool // equality function\n-\n+\tkind       uint8   // enumeration for C\n+\t// function for comparing objects of this type\n+\t// (ptr to object A, ptr to object B) -> ==?\n+\tequal         func(unsafe.Pointer, unsafe.Pointer) bool\n \tgcdata        *byte   // garbage collection data\n-\tstring        *string // string form; unnecessary  but undeniably useful\n+\tstring        *string // string form; unnecessary but undeniably useful\n \t*uncommonType         // (relatively) uncommon fields\n \tptrToThis     *rtype  // type for pointer to this type, if used in binary or has methods\n }\n@@ -350,9 +363,11 @@ type interfaceType struct {\n // mapType represents a map type.\n type mapType struct {\n \trtype\n-\tkey        *rtype // map key type\n-\telem       *rtype // map element (value) type\n-\tbucket     *rtype // internal bucket structure\n+\tkey    *rtype // map key type\n+\telem   *rtype // map element (value) type\n+\tbucket *rtype // internal bucket structure\n+\t// function for hashing keys (ptr to key, seed) -> hash\n+\thasher     func(unsafe.Pointer, uintptr) uintptr\n \tkeysize    uint8  // size of key slot\n \tvaluesize  uint8  // size of value slot\n \tbucketsize uint16 // size of bucket\n@@ -1178,31 +1193,7 @@ func (t *rtype) ConvertibleTo(u Type) bool {\n }\n \n func (t *rtype) Comparable() bool {\n-\tswitch t.Kind() {\n-\tcase Bool, Int, Int8, Int16, Int32, Int64,\n-\t\tUint, Uint8, Uint16, Uint32, Uint64, Uintptr,\n-\t\tFloat32, Float64, Complex64, Complex128,\n-\t\tChan, Interface, Ptr, String, UnsafePointer:\n-\t\treturn true\n-\n-\tcase Func, Map, Slice:\n-\t\treturn false\n-\n-\tcase Array:\n-\t\treturn (*arrayType)(unsafe.Pointer(t)).elem.Comparable()\n-\n-\tcase Struct:\n-\t\ttt := (*structType)(unsafe.Pointer(t))\n-\t\tfor i := range tt.fields {\n-\t\t\tif !tt.fields[i].typ.Comparable() {\n-\t\t\t\treturn false\n-\t\t\t}\n-\t\t}\n-\t\treturn true\n-\n-\tdefault:\n-\t\tpanic(\"reflect: impossible\")\n-\t}\n+\treturn t.equal != nil\n }\n \n // implements reports whether the type V implements the interface type T.\n@@ -1457,6 +1448,7 @@ func ChanOf(dir ChanDir, t Type) Type {\n \tvar ichan interface{} = (chan unsafe.Pointer)(nil)\n \tprototype := *(**chanType)(unsafe.Pointer(&ichan))\n \tch := *prototype\n+\tch.tflag = tflagRegularMemory\n \tch.dir = uintptr(dir)\n \tch.string = &s\n \n@@ -1481,8 +1473,6 @@ func ChanOf(dir ChanDir, t Type) Type {\n \treturn ti.(Type)\n }\n \n-func ismapkey(*rtype) bool // implemented in runtime\n-\n // MapOf returns the map type with the given key and element types.\n // For example, if k represents int and e represents string,\n // MapOf(k, e) represents map[int]string.\n@@ -1493,7 +1483,7 @@ func MapOf(key, elem Type) Type {\n \tktyp := key.(*rtype)\n \tetyp := elem.(*rtype)\n \n-\tif !ismapkey(ktyp) {\n+\tif ktyp.equal == nil {\n \t\tpanic(\"reflect.MapOf: invalid key type \" + ktyp.String())\n \t}\n \n@@ -1530,6 +1520,9 @@ func MapOf(key, elem Type) Type {\n \tmt.ptrToThis = nil\n \n \tmt.bucket = bucketOf(ktyp, etyp)\n+\tmt.hasher = func(p unsafe.Pointer, seed uintptr) uintptr {\n+\t\treturn typehash(ktyp, p, seed)\n+\t}\n \tmt.flags = 0\n \tif ktyp.size > maxKeySize {\n \t\tmt.keysize = uint8(ptrSize)\n@@ -1851,7 +1844,7 @@ func bucketOf(ktyp, etyp *rtype) *rtype {\n \t}\n \n \tb := &rtype{\n-\t\talign:      int8(maxAlign),\n+\t\talign:      uint8(maxAlign),\n \t\tfieldAlign: uint8(maxAlign),\n \t\tsize:       size,\n \t\tkind:       uint8(Struct),\n@@ -1949,9 +1942,8 @@ func StructOf(fields []StructField) Type {\n \tvar (\n \t\thash       = uint32(12)\n \t\tsize       uintptr\n-\t\ttypalign   int8\n+\t\ttypalign   uint8\n \t\tcomparable = true\n-\t\thashable   = true\n \n \t\tfs   = make([]structField, len(fields))\n \t\trepr = make([]byte, 0, 64)\n@@ -2036,12 +2028,11 @@ func StructOf(fields []StructField) Type {\n \t\t\trepr = append(repr, ';')\n \t\t}\n \n-\t\tcomparable = comparable && (ft.equalfn != nil)\n-\t\thashable = hashable && (ft.hashfn != nil)\n+\t\tcomparable = comparable && (ft.equal != nil)\n \n \t\toffset := align(size, uintptr(ft.fieldAlign))\n-\t\tif int8(ft.fieldAlign) > typalign {\n-\t\t\ttypalign = int8(ft.fieldAlign)\n+\t\tif ft.fieldAlign > typalign {\n+\t\t\ttypalign = ft.fieldAlign\n \t\t}\n \t\tsize = offset + ft.size\n \t\tf.offsetEmbed |= offset << 1\n@@ -2118,11 +2109,12 @@ func StructOf(fields []StructField) Type {\n \t}\n \n \ttyp.string = &str\n+\ttyp.tflag = 0 // TODO: set tflagRegularMemory\n \ttyp.hash = hash\n \ttyp.size = size\n \ttyp.ptrdata = typeptrdata(typ.common())\n \ttyp.align = typalign\n-\ttyp.fieldAlign = uint8(typalign)\n+\ttyp.fieldAlign = typalign\n \n \tif hasGCProg {\n \t\tlastPtrField := 0\n@@ -2189,32 +2181,18 @@ func StructOf(fields []StructField) Type {\n \t}\n \ttyp.ptrdata = typeptrdata(typ.common())\n \n-\tif hashable {\n-\t\ttyp.hashfn = func(p unsafe.Pointer, seed uintptr) uintptr {\n-\t\t\to := seed\n-\t\t\tfor _, ft := range typ.fields {\n-\t\t\t\tpi := add(p, ft.offset(), \"&x.field safe\")\n-\t\t\t\to = ft.typ.hashfn(pi, o)\n-\t\t\t}\n-\t\t\treturn o\n-\t\t}\n-\t} else {\n-\t\ttyp.hashfn = nil\n-\t}\n-\n+\ttyp.equal = nil\n \tif comparable {\n-\t\ttyp.equalfn = func(p, q unsafe.Pointer) bool {\n+\t\ttyp.equal = func(p, q unsafe.Pointer) bool {\n \t\t\tfor _, ft := range typ.fields {\n \t\t\t\tpi := add(p, ft.offset(), \"&x.field safe\")\n \t\t\t\tqi := add(q, ft.offset(), \"&x.field safe\")\n-\t\t\t\tif !ft.typ.equalfn(pi, qi) {\n+\t\t\t\tif !ft.typ.equal(pi, qi) {\n \t\t\t\t\treturn false\n \t\t\t\t}\n \t\t\t}\n \t\t\treturn true\n \t\t}\n-\t} else {\n-\t\ttyp.equalfn = nil\n \t}\n \n \tswitch {\n@@ -2322,6 +2300,7 @@ func ArrayOf(count int, elem Type) Type {\n \tvar iarray interface{} = [1]unsafe.Pointer{}\n \tprototype := *(**arrayType)(unsafe.Pointer(&iarray))\n \tarray := *prototype\n+\tarray.tflag = typ.tflag & tflagRegularMemory\n \tarray.string = &s\n \n \t// gccgo uses a different hash.\n@@ -2427,21 +2406,12 @@ func ArrayOf(count int, elem Type) Type {\n \t\tarray.ptrdata = array.size // overestimate but ok; must match program\n \t}\n \n-\tswitch {\n-\tcase count == 1 && !ifaceIndir(typ):\n-\t\t// array of 1 direct iface type can be direct\n-\t\tarray.kind |= kindDirectIface\n-\tdefault:\n-\t\tarray.kind &^= kindDirectIface\n-\t}\n-\n+\tetyp := typ.common()\n \tesize := typ.size\n \n-\tif typ.equalfn == nil {\n-\t\tarray.equalfn = nil\n-\t} else {\n-\t\teequal := typ.equalfn\n-\t\tarray.equalfn = func(p, q unsafe.Pointer) bool {\n+\tarray.equal = nil\n+\tif eequal := etyp.equal; eequal != nil {\n+\t\tarray.equal = func(p, q unsafe.Pointer) bool {\n \t\t\tfor i := 0; i < count; i++ {\n \t\t\t\tpi := arrayAt(p, i, esize, \"i < count\")\n \t\t\t\tqi := arrayAt(q, i, esize, \"i < count\")\n@@ -2453,17 +2423,12 @@ func ArrayOf(count int, elem Type) Type {\n \t\t}\n \t}\n \n-\tif typ.hashfn == nil {\n-\t\tarray.hashfn = nil\n-\t} else {\n-\t\tehash := typ.hashfn\n-\t\tarray.hashfn = func(ptr unsafe.Pointer, seed uintptr) uintptr {\n-\t\t\to := seed\n-\t\t\tfor i := 0; i < count; i++ {\n-\t\t\t\to = ehash(arrayAt(ptr, i, esize, \"i < count\"), o)\n-\t\t\t}\n-\t\t\treturn o\n-\t\t}\n+\tswitch {\n+\tcase count == 1 && !ifaceIndir(typ):\n+\t\t// array of 1 direct iface type can be direct\n+\t\tarray.kind |= kindDirectIface\n+\tdefault:\n+\t\tarray.kind &^= kindDirectIface\n \t}\n \n \tti, _ := lookupCache.LoadOrStore(ckey, &array.rtype)"}, {"sha": "15a502465f78cab1391c7763bfb0c5a41fd5b339", "filename": "libgo/go/reflect/value.go", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10172a64cedd95b302a9709429a4832a879667da/libgo%2Fgo%2Freflect%2Fvalue.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10172a64cedd95b302a9709429a4832a879667da/libgo%2Fgo%2Freflect%2Fvalue.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fvalue.go?ref=10172a64cedd95b302a9709429a4832a879667da", "patch": "@@ -2543,6 +2543,9 @@ func typedmemmove(t *rtype, dst, src unsafe.Pointer)\n //go:noescape\n func typedslicecopy(elemType *rtype, dst, src sliceHeader) int\n \n+//go:noescape\n+func typehash(t *rtype, p unsafe.Pointer, h uintptr) uintptr\n+\n // Dummy annotation marking that the value x escapes,\n // for use in cases where the reflect code is so clever that\n // the compiler cannot follow."}, {"sha": "e802fdd7024a13c0e49c5a7ac400f57f1f155bd9", "filename": "libgo/go/runtime/alg.go", "status": "modified", "additions": 76, "deletions": 13, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10172a64cedd95b302a9709429a4832a879667da/libgo%2Fgo%2Fruntime%2Falg.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10172a64cedd95b302a9709429a4832a879667da/libgo%2Fgo%2Fruntime%2Falg.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Falg.go?ref=10172a64cedd95b302a9709429a4832a879667da", "patch": "@@ -69,6 +69,9 @@ func memhash128(p unsafe.Pointer, h uintptr) uintptr {\n \treturn memhash(p, h, 16)\n }\n \n+// runtime variable to check if the processor we're running on\n+// actually supports the instructions used by the AES-based\n+// hash implementation.\n var useAeshash bool\n \n // in C code\n@@ -134,14 +137,17 @@ func interhash(p unsafe.Pointer, h uintptr) uintptr {\n \t\treturn h\n \t}\n \tt := *(**_type)(tab)\n-\tfn := t.hashfn\n-\tif fn == nil {\n+\tif t.equal == nil {\n+\t\t// Check hashability here. We could do this check inside\n+\t\t// typehash, but we want to report the topmost type in\n+\t\t// the error text (e.g. in a struct with a field of slice type\n+\t\t// we want to report the struct, not the slice).\n \t\tpanic(errorString(\"hash of unhashable type \" + t.string()))\n \t}\n \tif isDirectIface(t) {\n-\t\treturn c1 * fn(unsafe.Pointer(&a.data), h^c0)\n+\t\treturn c1 * typehash(t, unsafe.Pointer(&a.data), h^c0)\n \t} else {\n-\t\treturn c1 * fn(a.data, h^c0)\n+\t\treturn c1 * typehash(t, a.data, h^c0)\n \t}\n }\n \n@@ -151,17 +157,74 @@ func nilinterhash(p unsafe.Pointer, h uintptr) uintptr {\n \tif t == nil {\n \t\treturn h\n \t}\n-\tfn := t.hashfn\n-\tif fn == nil {\n+\tif t.equal == nil {\n+\t\t// See comment in interhash above.\n \t\tpanic(errorString(\"hash of unhashable type \" + t.string()))\n \t}\n \tif isDirectIface(t) {\n-\t\treturn c1 * fn(unsafe.Pointer(&a.data), h^c0)\n+\t\treturn c1 * typehash(t, unsafe.Pointer(&a.data), h^c0)\n \t} else {\n-\t\treturn c1 * fn(a.data, h^c0)\n+\t\treturn c1 * typehash(t, a.data, h^c0)\n+\t}\n+}\n+\n+// typehash computes the hash of the object of type t at address p.\n+// h is the seed.\n+// This function is seldom used. Most maps use for hashing either\n+// fixed functions (e.g. f32hash) or compiler-generated functions\n+// (e.g. for a type like struct { x, y string }). This implementation\n+// is slower but more general and is used for hashing interface types\n+// (called from interhash or nilinterhash, above) or for hashing in\n+// maps generated by reflect.MapOf (reflect_typehash, below).\n+func typehash(t *_type, p unsafe.Pointer, h uintptr) uintptr {\n+\tif t.tflag&tflagRegularMemory != 0 {\n+\t\treturn memhash(p, h, t.size)\n+\t}\n+\tswitch t.kind & kindMask {\n+\tcase kindFloat32:\n+\t\treturn f32hash(p, h)\n+\tcase kindFloat64:\n+\t\treturn f64hash(p, h)\n+\tcase kindComplex64:\n+\t\treturn c64hash(p, h)\n+\tcase kindComplex128:\n+\t\treturn c128hash(p, h)\n+\tcase kindString:\n+\t\treturn strhash(p, h)\n+\tcase kindInterface:\n+\t\ti := (*interfacetype)(unsafe.Pointer(t))\n+\t\tif len(i.methods) == 0 {\n+\t\t\treturn nilinterhash(p, h)\n+\t\t}\n+\t\treturn interhash(p, h)\n+\tcase kindArray:\n+\t\ta := (*arraytype)(unsafe.Pointer(t))\n+\t\tfor i := uintptr(0); i < a.len; i++ {\n+\t\t\th = typehash(a.elem, add(p, i*a.elem.size), h)\n+\t\t}\n+\t\treturn h\n+\tcase kindStruct:\n+\t\ts := (*structtype)(unsafe.Pointer(t))\n+\t\tfor _, f := range s.fields {\n+\t\t\t// TODO: maybe we could hash several contiguous fields all at once.\n+\t\t\tif f.name != nil && *f.name == \"_\" {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\th = typehash(f.typ, add(p, f.offset()), h)\n+\t\t}\n+\t\treturn h\n+\tdefault:\n+\t\t// Should never happen, as typehash should only be called\n+\t\t// with comparable types.\n+\t\tpanic(errorString(\"hash of unhashable type \" + t.string()))\n \t}\n }\n \n+//go:linkname reflect_typehash reflect.typehash\n+func reflect_typehash(t *_type, p unsafe.Pointer, h uintptr) uintptr {\n+\treturn typehash(t, p, h)\n+}\n+\n func memequal0(p, q unsafe.Pointer) bool {\n \treturn true\n }\n@@ -209,7 +272,7 @@ func efaceeq(x, y eface) bool {\n \tif t == nil {\n \t\treturn true\n \t}\n-\teq := t.equalfn\n+\teq := t.equal\n \tif eq == nil {\n \t\tpanic(errorString(\"comparing uncomparable type \" + t.string()))\n \t}\n@@ -230,7 +293,7 @@ func ifaceeq(x, y iface) bool {\n \tif t != *(**_type)(y.tab) {\n \t\treturn false\n \t}\n-\teq := t.equalfn\n+\teq := t.equal\n \tif eq == nil {\n \t\tpanic(errorString(\"comparing uncomparable type \" + t.string()))\n \t}\n@@ -251,7 +314,7 @@ func ifacevaleq(x iface, t *_type, p unsafe.Pointer) bool {\n \tif xt != t {\n \t\treturn false\n \t}\n-\teq := t.equalfn\n+\teq := t.equal\n \tif eq == nil {\n \t\tpanic(errorString(\"comparing uncomparable type \" + t.string()))\n \t}\n@@ -272,7 +335,7 @@ func ifaceefaceeq(x iface, y eface) bool {\n \tif xt != y._type {\n \t\treturn false\n \t}\n-\teq := xt.equalfn\n+\teq := xt.equal\n \tif eq == nil {\n \t\tpanic(errorString(\"comparing uncomparable type \" + xt.string()))\n \t}\n@@ -289,7 +352,7 @@ func efacevaleq(x eface, t *_type, p unsafe.Pointer) bool {\n \tif x._type != t {\n \t\treturn false\n \t}\n-\teq := t.equalfn\n+\teq := t.equal\n \tif eq == nil {\n \t\tpanic(errorString(\"comparing uncomparable type \" + t.string()))\n \t}"}, {"sha": "36729087ce6210184798765c2b7bbde0ce167422", "filename": "libgo/go/runtime/map.go", "status": "modified", "additions": 21, "deletions": 42, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10172a64cedd95b302a9709429a4832a879667da/libgo%2Fgo%2Fruntime%2Fmap.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10172a64cedd95b302a9709429a4832a879667da/libgo%2Fgo%2Fruntime%2Fmap.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmap.go?ref=10172a64cedd95b302a9709429a4832a879667da", "patch": "@@ -421,18 +421,16 @@ func mapaccess1(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer {\n \tif msanenabled && h != nil {\n \t\tmsanread(key, t.key.size)\n \t}\n-\thashfn := t.key.hashfn\n-\tequalfn := t.key.equalfn\n \tif h == nil || h.count == 0 {\n \t\tif t.hashMightPanic() {\n-\t\t\thashfn(key, 0) // see issue 23734\n+\t\t\tt.hasher(key, 0) // see issue 23734\n \t\t}\n \t\treturn unsafe.Pointer(&zeroVal[0])\n \t}\n \tif h.flags&hashWriting != 0 {\n \t\tthrow(\"concurrent map read and map write\")\n \t}\n-\thash := hashfn(key, uintptr(h.hash0))\n+\thash := t.hasher(key, uintptr(h.hash0))\n \tm := bucketMask(h.B)\n \tb := (*bmap)(add(h.buckets, (hash&m)*uintptr(t.bucketsize)))\n \tif c := h.oldbuckets; c != nil {\n@@ -459,7 +457,7 @@ bucketloop:\n \t\t\tif t.indirectkey() {\n \t\t\t\tk = *((*unsafe.Pointer)(k))\n \t\t\t}\n-\t\t\tif equalfn(key, k) {\n+\t\t\tif t.key.equal(key, k) {\n \t\t\t\te := add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.elemsize))\n \t\t\t\tif t.indirectelem() {\n \t\t\t\t\te = *((*unsafe.Pointer)(e))\n@@ -486,18 +484,16 @@ func mapaccess2(t *maptype, h *hmap, key unsafe.Pointer) (unsafe.Pointer, bool)\n \tif msanenabled && h != nil {\n \t\tmsanread(key, t.key.size)\n \t}\n-\thashfn := t.key.hashfn\n-\tequalfn := t.key.equalfn\n \tif h == nil || h.count == 0 {\n \t\tif t.hashMightPanic() {\n-\t\t\thashfn(key, 0) // see issue 23734\n+\t\t\tt.hasher(key, 0) // see issue 23734\n \t\t}\n \t\treturn unsafe.Pointer(&zeroVal[0]), false\n \t}\n \tif h.flags&hashWriting != 0 {\n \t\tthrow(\"concurrent map read and map write\")\n \t}\n-\thash := hashfn(key, uintptr(h.hash0))\n+\thash := t.hasher(key, uintptr(h.hash0))\n \tm := bucketMask(h.B)\n \tb := (*bmap)(unsafe.Pointer(uintptr(h.buckets) + (hash&m)*uintptr(t.bucketsize)))\n \tif c := h.oldbuckets; c != nil {\n@@ -524,7 +520,7 @@ bucketloop:\n \t\t\tif t.indirectkey() {\n \t\t\t\tk = *((*unsafe.Pointer)(k))\n \t\t\t}\n-\t\t\tif equalfn(key, k) {\n+\t\t\tif t.key.equal(key, k) {\n \t\t\t\te := add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.elemsize))\n \t\t\t\tif t.indirectelem() {\n \t\t\t\t\te = *((*unsafe.Pointer)(e))\n@@ -546,9 +542,7 @@ func mapaccessK(t *maptype, h *hmap, key unsafe.Pointer) (unsafe.Pointer, unsafe\n \tif h == nil || h.count == 0 {\n \t\treturn nil, nil\n \t}\n-\thashfn := t.key.hashfn\n-\tequalfn := t.key.equalfn\n-\thash := hashfn(key, uintptr(h.hash0))\n+\thash := t.hasher(key, uintptr(h.hash0))\n \tm := bucketMask(h.B)\n \tb := (*bmap)(unsafe.Pointer(uintptr(h.buckets) + (hash&m)*uintptr(t.bucketsize)))\n \tif c := h.oldbuckets; c != nil {\n@@ -575,7 +569,7 @@ bucketloop:\n \t\t\tif t.indirectkey() {\n \t\t\t\tk = *((*unsafe.Pointer)(k))\n \t\t\t}\n-\t\t\tif equalfn(key, k) {\n+\t\t\tif t.key.equal(key, k) {\n \t\t\t\te := add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.elemsize))\n \t\t\t\tif t.indirectelem() {\n \t\t\t\t\te = *((*unsafe.Pointer)(e))\n@@ -625,11 +619,9 @@ func mapassign(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer {\n \tif h.flags&hashWriting != 0 {\n \t\tthrow(\"concurrent map writes\")\n \t}\n-\thashfn := t.key.hashfn\n-\tequalfn := t.key.equalfn\n-\thash := hashfn(key, uintptr(h.hash0))\n+\thash := t.hasher(key, uintptr(h.hash0))\n \n-\t// Set hashWriting after calling alg.hash, since alg.hash may panic,\n+\t// Set hashWriting after calling t.hasher, since t.hasher may panic,\n \t// in which case we have not actually done a write.\n \th.flags ^= hashWriting\n \n@@ -666,7 +658,7 @@ bucketloop:\n \t\t\tif t.indirectkey() {\n \t\t\t\tk = *((*unsafe.Pointer)(k))\n \t\t\t}\n-\t\t\tif !equalfn(key, k) {\n+\t\t\tif !t.key.equal(key, k) {\n \t\t\t\tcontinue\n \t\t\t}\n \t\t\t// already have a mapping for key. Update it.\n@@ -735,21 +727,19 @@ func mapdelete(t *maptype, h *hmap, key unsafe.Pointer) {\n \tif msanenabled && h != nil {\n \t\tmsanread(key, t.key.size)\n \t}\n-\thashfn := t.key.hashfn\n-\tequalfn := t.key.equalfn\n \tif h == nil || h.count == 0 {\n \t\tif t.hashMightPanic() {\n-\t\t\thashfn(key, 0) // see issue 23734\n+\t\t\tt.hasher(key, 0) // see issue 23734\n \t\t}\n \t\treturn\n \t}\n \tif h.flags&hashWriting != 0 {\n \t\tthrow(\"concurrent map writes\")\n \t}\n \n-\thash := hashfn(key, uintptr(h.hash0))\n+\thash := t.hasher(key, uintptr(h.hash0))\n \n-\t// Set hashWriting after calling alg.hash, since alg.hash may panic,\n+\t// Set hashWriting after calling t.hasher, since t.hasher may panic,\n \t// in which case we have not actually done a write (delete).\n \th.flags ^= hashWriting\n \n@@ -774,7 +764,7 @@ search:\n \t\t\tif t.indirectkey() {\n \t\t\t\tk2 = *((*unsafe.Pointer)(k2))\n \t\t\t}\n-\t\t\tif !equalfn(key, k2) {\n+\t\t\tif !t.key.equal(key, k2) {\n \t\t\t\tcontinue\n \t\t\t}\n \t\t\t// Only clear key if there are pointers in it.\n@@ -925,8 +915,6 @@ func mapiternext(it *hiter) {\n \tb := it.bptr\n \ti := it.i\n \tcheckBucket := it.checkBucket\n-\thashfn := t.key.hashfn\n-\tequalfn := t.key.equalfn\n \n next:\n \tif b == nil {\n@@ -980,10 +968,10 @@ next:\n \t\t\t// through the oldbucket, skipping any keys that will go\n \t\t\t// to the other new bucket (each oldbucket expands to two\n \t\t\t// buckets during a grow).\n-\t\t\tif t.reflexivekey() || equalfn(k, k) {\n+\t\t\tif t.reflexivekey() || t.key.equal(k, k) {\n \t\t\t\t// If the item in the oldbucket is not destined for\n \t\t\t\t// the current new bucket in the iteration, skip it.\n-\t\t\t\thash := hashfn(k, uintptr(h.hash0))\n+\t\t\t\thash := t.hasher(k, uintptr(h.hash0))\n \t\t\t\tif hash&bucketMask(it.B) != checkBucket {\n \t\t\t\t\tcontinue\n \t\t\t\t}\n@@ -1001,7 +989,7 @@ next:\n \t\t\t}\n \t\t}\n \t\tif (b.tophash[offi] != evacuatedX && b.tophash[offi] != evacuatedY) ||\n-\t\t\t!(t.reflexivekey() || equalfn(k, k)) {\n+\t\t\t!(t.reflexivekey() || t.key.equal(k, k)) {\n \t\t\t// This is the golden data, we can return it.\n \t\t\t// OR\n \t\t\t// key!=key, so the entry can't be deleted or updated, so we can just return it.\n@@ -1238,8 +1226,8 @@ func evacuate(t *maptype, h *hmap, oldbucket uintptr) {\n \t\t\t\tif !h.sameSizeGrow() {\n \t\t\t\t\t// Compute hash to make our evacuation decision (whether we need\n \t\t\t\t\t// to send this key/elem to bucket x or bucket y).\n-\t\t\t\t\thash := t.key.hashfn(k2, uintptr(h.hash0))\n-\t\t\t\t\tif h.flags&iterator != 0 && !t.reflexivekey() && !t.key.equalfn(k2, k2) {\n+\t\t\t\t\thash := t.hasher(k2, uintptr(h.hash0))\n+\t\t\t\t\tif h.flags&iterator != 0 && !t.reflexivekey() && !t.key.equal(k2, k2) {\n \t\t\t\t\t\t// If key != key (NaNs), then the hash could be (and probably\n \t\t\t\t\t\t// will be) entirely different from the old hash. Moreover,\n \t\t\t\t\t\t// it isn't reproducible. Reproducibility is required in the\n@@ -1333,16 +1321,12 @@ func advanceEvacuationMark(h *hmap, t *maptype, newbit uintptr) {\n \t}\n }\n \n-func ismapkey(t *_type) bool {\n-\treturn t.hashfn != nil\n-}\n-\n // Reflect stubs. Called from ../reflect/asm_*.s\n \n //go:linkname reflect_makemap reflect.makemap\n func reflect_makemap(t *maptype, cap int) *hmap {\n \t// Check invariants and reflects math.\n-\tif !ismapkey(t.key) {\n+\tif t.key.equal == nil {\n \t\tthrow(\"runtime.reflect_makemap: unsupported map key type\")\n \t}\n \tif t.key.size > maxKeySize && (!t.indirectkey() || t.keysize != uint8(sys.PtrSize)) ||\n@@ -1445,10 +1429,5 @@ func reflectlite_maplen(h *hmap) int {\n \treturn h.count\n }\n \n-//go:linkname reflect_ismapkey reflect.ismapkey\n-func reflect_ismapkey(t *_type) bool {\n-\treturn ismapkey(t)\n-}\n-\n const maxZero = 1024 // must match value in cmd/compile/internal/gc/walk.go\n var zeroVal [maxZero]byte"}, {"sha": "cf04ead11561e29af86afbab80f59503b68ecedf", "filename": "libgo/go/runtime/map_benchmark_test.go", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10172a64cedd95b302a9709429a4832a879667da/libgo%2Fgo%2Fruntime%2Fmap_benchmark_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10172a64cedd95b302a9709429a4832a879667da/libgo%2Fgo%2Fruntime%2Fmap_benchmark_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmap_benchmark_test.go?ref=10172a64cedd95b302a9709429a4832a879667da", "patch": "@@ -483,3 +483,33 @@ func BenchmarkMapStringConversion(b *testing.B) {\n \t\t})\n \t}\n }\n+\n+var BoolSink bool\n+\n+func BenchmarkMapInterfaceString(b *testing.B) {\n+\tm := map[interface{}]bool{}\n+\n+\tfor i := 0; i < 100; i++ {\n+\t\tm[fmt.Sprintf(\"%d\", i)] = true\n+\t}\n+\n+\tkey := (interface{})(\"A\")\n+\tb.ResetTimer()\n+\tfor i := 0; i < b.N; i++ {\n+\t\tBoolSink = m[key]\n+\t}\n+}\n+func BenchmarkMapInterfacePtr(b *testing.B) {\n+\tm := map[interface{}]bool{}\n+\n+\tfor i := 0; i < 100; i++ {\n+\t\ti := i\n+\t\tm[&i] = true\n+\t}\n+\n+\tkey := new(int)\n+\tb.ResetTimer()\n+\tfor i := 0; i < b.N; i++ {\n+\t\tBoolSink = m[key]\n+\t}\n+}"}, {"sha": "fdc7f0ee10ae1381662530c04ee92050e5b0fd11", "filename": "libgo/go/runtime/map_fast32.go", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10172a64cedd95b302a9709429a4832a879667da/libgo%2Fgo%2Fruntime%2Fmap_fast32.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10172a64cedd95b302a9709429a4832a879667da/libgo%2Fgo%2Fruntime%2Fmap_fast32.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmap_fast32.go?ref=10172a64cedd95b302a9709429a4832a879667da", "patch": "@@ -33,7 +33,7 @@ func mapaccess1_fast32(t *maptype, h *hmap, key uint32) unsafe.Pointer {\n \t\t// One-bucket table. No need to hash.\n \t\tb = (*bmap)(h.buckets)\n \t} else {\n-\t\thash := t.key.hashfn(noescape(unsafe.Pointer(&key)), uintptr(h.hash0))\n+\t\thash := t.hasher(noescape(unsafe.Pointer(&key)), uintptr(h.hash0))\n \t\tm := bucketMask(h.B)\n \t\tb = (*bmap)(add(h.buckets, (hash&m)*uintptr(t.bucketsize)))\n \t\tif c := h.oldbuckets; c != nil {\n@@ -73,7 +73,7 @@ func mapaccess2_fast32(t *maptype, h *hmap, key uint32) (unsafe.Pointer, bool) {\n \t\t// One-bucket table. No need to hash.\n \t\tb = (*bmap)(h.buckets)\n \t} else {\n-\t\thash := t.key.hashfn(noescape(unsafe.Pointer(&key)), uintptr(h.hash0))\n+\t\thash := t.hasher(noescape(unsafe.Pointer(&key)), uintptr(h.hash0))\n \t\tm := bucketMask(h.B)\n \t\tb = (*bmap)(add(h.buckets, (hash&m)*uintptr(t.bucketsize)))\n \t\tif c := h.oldbuckets; c != nil {\n@@ -108,9 +108,9 @@ func mapassign_fast32(t *maptype, h *hmap, key uint32) unsafe.Pointer {\n \tif h.flags&hashWriting != 0 {\n \t\tthrow(\"concurrent map writes\")\n \t}\n-\thash := t.key.hashfn(noescape(unsafe.Pointer(&key)), uintptr(h.hash0))\n+\thash := t.hasher(noescape(unsafe.Pointer(&key)), uintptr(h.hash0))\n \n-\t// Set hashWriting after calling alg.hash for consistency with mapassign.\n+\t// Set hashWriting after calling t.hasher for consistency with mapassign.\n \th.flags ^= hashWriting\n \n \tif h.buckets == nil {\n@@ -198,9 +198,9 @@ func mapassign_fast32ptr(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer\n \tif h.flags&hashWriting != 0 {\n \t\tthrow(\"concurrent map writes\")\n \t}\n-\thash := t.key.hashfn(noescape(unsafe.Pointer(&key)), uintptr(h.hash0))\n+\thash := t.hasher(noescape(unsafe.Pointer(&key)), uintptr(h.hash0))\n \n-\t// Set hashWriting after calling alg.hash for consistency with mapassign.\n+\t// Set hashWriting after calling t.hasher for consistency with mapassign.\n \th.flags ^= hashWriting\n \n \tif h.buckets == nil {\n@@ -289,9 +289,9 @@ func mapdelete_fast32(t *maptype, h *hmap, key uint32) {\n \t\tthrow(\"concurrent map writes\")\n \t}\n \n-\thash := t.key.hashfn(noescape(unsafe.Pointer(&key)), uintptr(h.hash0))\n+\thash := t.hasher(noescape(unsafe.Pointer(&key)), uintptr(h.hash0))\n \n-\t// Set hashWriting after calling alg.hash for consistency with mapdelete\n+\t// Set hashWriting after calling t.hasher for consistency with mapdelete\n \th.flags ^= hashWriting\n \n \tbucket := hash & bucketMask(h.B)\n@@ -408,7 +408,7 @@ func evacuate_fast32(t *maptype, h *hmap, oldbucket uintptr) {\n \t\t\t\tif !h.sameSizeGrow() {\n \t\t\t\t\t// Compute hash to make our evacuation decision (whether we need\n \t\t\t\t\t// to send this key/elem to bucket x or bucket y).\n-\t\t\t\t\thash := t.key.hashfn(k, uintptr(h.hash0))\n+\t\t\t\t\thash := t.hasher(k, uintptr(h.hash0))\n \t\t\t\t\tif hash&newbit != 0 {\n \t\t\t\t\t\tuseY = 1\n \t\t\t\t\t}"}, {"sha": "26c60aeb0fc22412d479e1e20d61958860a002f9", "filename": "libgo/go/runtime/map_fast64.go", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10172a64cedd95b302a9709429a4832a879667da/libgo%2Fgo%2Fruntime%2Fmap_fast64.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10172a64cedd95b302a9709429a4832a879667da/libgo%2Fgo%2Fruntime%2Fmap_fast64.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmap_fast64.go?ref=10172a64cedd95b302a9709429a4832a879667da", "patch": "@@ -33,7 +33,7 @@ func mapaccess1_fast64(t *maptype, h *hmap, key uint64) unsafe.Pointer {\n \t\t// One-bucket table. No need to hash.\n \t\tb = (*bmap)(h.buckets)\n \t} else {\n-\t\thash := t.key.hashfn(noescape(unsafe.Pointer(&key)), uintptr(h.hash0))\n+\t\thash := t.hasher(noescape(unsafe.Pointer(&key)), uintptr(h.hash0))\n \t\tm := bucketMask(h.B)\n \t\tb = (*bmap)(add(h.buckets, (hash&m)*uintptr(t.bucketsize)))\n \t\tif c := h.oldbuckets; c != nil {\n@@ -73,7 +73,7 @@ func mapaccess2_fast64(t *maptype, h *hmap, key uint64) (unsafe.Pointer, bool) {\n \t\t// One-bucket table. No need to hash.\n \t\tb = (*bmap)(h.buckets)\n \t} else {\n-\t\thash := t.key.hashfn(noescape(unsafe.Pointer(&key)), uintptr(h.hash0))\n+\t\thash := t.hasher(noescape(unsafe.Pointer(&key)), uintptr(h.hash0))\n \t\tm := bucketMask(h.B)\n \t\tb = (*bmap)(add(h.buckets, (hash&m)*uintptr(t.bucketsize)))\n \t\tif c := h.oldbuckets; c != nil {\n@@ -108,9 +108,9 @@ func mapassign_fast64(t *maptype, h *hmap, key uint64) unsafe.Pointer {\n \tif h.flags&hashWriting != 0 {\n \t\tthrow(\"concurrent map writes\")\n \t}\n-\thash := t.key.hashfn(noescape(unsafe.Pointer(&key)), uintptr(h.hash0))\n+\thash := t.hasher(noescape(unsafe.Pointer(&key)), uintptr(h.hash0))\n \n-\t// Set hashWriting after calling alg.hash for consistency with mapassign.\n+\t// Set hashWriting after calling t.hasher for consistency with mapassign.\n \th.flags ^= hashWriting\n \n \tif h.buckets == nil {\n@@ -198,9 +198,9 @@ func mapassign_fast64ptr(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer\n \tif h.flags&hashWriting != 0 {\n \t\tthrow(\"concurrent map writes\")\n \t}\n-\thash := t.key.hashfn(noescape(unsafe.Pointer(&key)), uintptr(h.hash0))\n+\thash := t.hasher(noescape(unsafe.Pointer(&key)), uintptr(h.hash0))\n \n-\t// Set hashWriting after calling alg.hash for consistency with mapassign.\n+\t// Set hashWriting after calling t.hasher for consistency with mapassign.\n \th.flags ^= hashWriting\n \n \tif h.buckets == nil {\n@@ -289,9 +289,9 @@ func mapdelete_fast64(t *maptype, h *hmap, key uint64) {\n \t\tthrow(\"concurrent map writes\")\n \t}\n \n-\thash := t.key.hashfn(noescape(unsafe.Pointer(&key)), uintptr(h.hash0))\n+\thash := t.hasher(noescape(unsafe.Pointer(&key)), uintptr(h.hash0))\n \n-\t// Set hashWriting after calling alg.hash for consistency with mapdelete\n+\t// Set hashWriting after calling t.hasher for consistency with mapdelete\n \th.flags ^= hashWriting\n \n \tbucket := hash & bucketMask(h.B)\n@@ -408,7 +408,7 @@ func evacuate_fast64(t *maptype, h *hmap, oldbucket uintptr) {\n \t\t\t\tif !h.sameSizeGrow() {\n \t\t\t\t\t// Compute hash to make our evacuation decision (whether we need\n \t\t\t\t\t// to send this key/elem to bucket x or bucket y).\n-\t\t\t\t\thash := t.key.hashfn(k, uintptr(h.hash0))\n+\t\t\t\t\thash := t.hasher(k, uintptr(h.hash0))\n \t\t\t\t\tif hash&newbit != 0 {\n \t\t\t\t\t\tuseY = 1\n \t\t\t\t\t}"}, {"sha": "1775214ff48b16ed31ce9d36aaf79e3db3a6d6d1", "filename": "libgo/go/runtime/map_faststr.go", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10172a64cedd95b302a9709429a4832a879667da/libgo%2Fgo%2Fruntime%2Fmap_faststr.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10172a64cedd95b302a9709429a4832a879667da/libgo%2Fgo%2Fruntime%2Fmap_faststr.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmap_faststr.go?ref=10172a64cedd95b302a9709429a4832a879667da", "patch": "@@ -83,7 +83,7 @@ func mapaccess1_faststr(t *maptype, h *hmap, ky string) unsafe.Pointer {\n \t\treturn unsafe.Pointer(&zeroVal[0])\n \t}\n dohash:\n-\thash := t.key.hashfn(noescape(unsafe.Pointer(&ky)), uintptr(h.hash0))\n+\thash := t.hasher(noescape(unsafe.Pointer(&ky)), uintptr(h.hash0))\n \tm := bucketMask(h.B)\n \tb := (*bmap)(add(h.buckets, (hash&m)*uintptr(t.bucketsize)))\n \tif c := h.oldbuckets; c != nil {\n@@ -178,7 +178,7 @@ func mapaccess2_faststr(t *maptype, h *hmap, ky string) (unsafe.Pointer, bool) {\n \t\treturn unsafe.Pointer(&zeroVal[0]), false\n \t}\n dohash:\n-\thash := t.key.hashfn(noescape(unsafe.Pointer(&ky)), uintptr(h.hash0))\n+\thash := t.hasher(noescape(unsafe.Pointer(&ky)), uintptr(h.hash0))\n \tm := bucketMask(h.B)\n \tb := (*bmap)(add(h.buckets, (hash&m)*uintptr(t.bucketsize)))\n \tif c := h.oldbuckets; c != nil {\n@@ -218,9 +218,9 @@ func mapassign_faststr(t *maptype, h *hmap, s string) unsafe.Pointer {\n \t\tthrow(\"concurrent map writes\")\n \t}\n \tkey := stringStructOf(&s)\n-\thash := t.key.hashfn(noescape(unsafe.Pointer(&s)), uintptr(h.hash0))\n+\thash := t.hasher(noescape(unsafe.Pointer(&s)), uintptr(h.hash0))\n \n-\t// Set hashWriting after calling alg.hash for consistency with mapassign.\n+\t// Set hashWriting after calling t.hasher for consistency with mapassign.\n \th.flags ^= hashWriting\n \n \tif h.buckets == nil {\n@@ -314,9 +314,9 @@ func mapdelete_faststr(t *maptype, h *hmap, ky string) {\n \t}\n \n \tkey := stringStructOf(&ky)\n-\thash := t.key.hashfn(noescape(unsafe.Pointer(&ky)), uintptr(h.hash0))\n+\thash := t.hasher(noescape(unsafe.Pointer(&ky)), uintptr(h.hash0))\n \n-\t// Set hashWriting after calling alg.hash for consistency with mapdelete\n+\t// Set hashWriting after calling t.hasher for consistency with mapdelete\n \th.flags ^= hashWriting\n \n \tbucket := hash & bucketMask(h.B)\n@@ -436,7 +436,7 @@ func evacuate_faststr(t *maptype, h *hmap, oldbucket uintptr) {\n \t\t\t\tif !h.sameSizeGrow() {\n \t\t\t\t\t// Compute hash to make our evacuation decision (whether we need\n \t\t\t\t\t// to send this key/elem to bucket x or bucket y).\n-\t\t\t\t\thash := t.key.hashfn(k, uintptr(h.hash0))\n+\t\t\t\t\thash := t.hasher(k, uintptr(h.hash0))\n \t\t\t\t\tif hash&newbit != 0 {\n \t\t\t\t\t\tuseY = 1\n \t\t\t\t\t}"}, {"sha": "b13d269acf572f15db6ed57a7e700319369046de", "filename": "libgo/go/runtime/map_test.go", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10172a64cedd95b302a9709429a4832a879667da/libgo%2Fgo%2Fruntime%2Fmap_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10172a64cedd95b302a9709429a4832a879667da/libgo%2Fgo%2Fruntime%2Fmap_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmap_test.go?ref=10172a64cedd95b302a9709429a4832a879667da", "patch": "@@ -1172,3 +1172,64 @@ func TestMapTombstones(t *testing.T) {\n \t}\n \truntime.MapTombstoneCheck(m)\n }\n+\n+type canString int\n+\n+func (c canString) String() string {\n+\treturn fmt.Sprintf(\"%d\", int(c))\n+}\n+\n+func TestMapInterfaceKey(t *testing.T) {\n+\t// Test all the special cases in runtime.typehash.\n+\ttype GrabBag struct {\n+\t\tf32  float32\n+\t\tf64  float64\n+\t\tc64  complex64\n+\t\tc128 complex128\n+\t\ts    string\n+\t\ti0   interface{}\n+\t\ti1   interface {\n+\t\t\tString() string\n+\t\t}\n+\t\ta [4]string\n+\t}\n+\n+\tm := map[interface{}]bool{}\n+\t// Put a bunch of data in m, so that a bad hash is likely to\n+\t// lead to a bad bucket, which will lead to a missed lookup.\n+\tfor i := 0; i < 1000; i++ {\n+\t\tm[i] = true\n+\t}\n+\tm[GrabBag{f32: 1.0}] = true\n+\tif !m[GrabBag{f32: 1.0}] {\n+\t\tpanic(\"f32 not found\")\n+\t}\n+\tm[GrabBag{f64: 1.0}] = true\n+\tif !m[GrabBag{f64: 1.0}] {\n+\t\tpanic(\"f64 not found\")\n+\t}\n+\tm[GrabBag{c64: 1.0i}] = true\n+\tif !m[GrabBag{c64: 1.0i}] {\n+\t\tpanic(\"c64 not found\")\n+\t}\n+\tm[GrabBag{c128: 1.0i}] = true\n+\tif !m[GrabBag{c128: 1.0i}] {\n+\t\tpanic(\"c128 not found\")\n+\t}\n+\tm[GrabBag{s: \"foo\"}] = true\n+\tif !m[GrabBag{s: \"foo\"}] {\n+\t\tpanic(\"string not found\")\n+\t}\n+\tm[GrabBag{i0: \"foo\"}] = true\n+\tif !m[GrabBag{i0: \"foo\"}] {\n+\t\tpanic(\"interface{} not found\")\n+\t}\n+\tm[GrabBag{i1: canString(5)}] = true\n+\tif !m[GrabBag{i1: canString(5)}] {\n+\t\tpanic(\"interface{String() string} not found\")\n+\t}\n+\tm[GrabBag{a: [4]string{\"foo\", \"bar\", \"baz\", \"bop\"}}] = true\n+\tif !m[GrabBag{a: [4]string{\"foo\", \"bar\", \"baz\", \"bop\"}}] {\n+\t\tpanic(\"array not found\")\n+\t}\n+}"}, {"sha": "94abbb8e9f89cf8d07b2afd8b64b3254248d0987", "filename": "libgo/go/runtime/type.go", "status": "modified", "additions": 27, "deletions": 11, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10172a64cedd95b302a9709429a4832a879667da/libgo%2Fgo%2Fruntime%2Ftype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10172a64cedd95b302a9709429a4832a879667da/libgo%2Fgo%2Fruntime%2Ftype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Ftype.go?ref=10172a64cedd95b302a9709429a4832a879667da", "patch": "@@ -12,18 +12,32 @@ import (\n \t\"unsafe\"\n )\n \n+// tflag is documented in reflect/type.go.\n+//\n+// tflag values must be kept in sync with copies in:\n+//\tgo/types.cc\n+//\treflect/type.go\n+//      internal/reflectlite/type.go\n+type tflag uint8\n+\n+const (\n+\ttflagRegularMemory tflag = 1 << 3 // equal and hash can treat values of this type as a single region of t.size bytes\n+)\n+\n type _type struct {\n \tsize       uintptr\n \tptrdata    uintptr\n \thash       uint32\n-\tkind       uint8\n-\talign      int8\n+\ttflag      tflag\n+\talign      uint8\n \tfieldAlign uint8\n-\t_          uint8\n-\n-\thashfn  func(unsafe.Pointer, uintptr) uintptr\n-\tequalfn func(unsafe.Pointer, unsafe.Pointer) bool\n-\n+\tkind       uint8\n+\t// function for comparing objects of this type\n+\t// (ptr to object A, ptr to object B) -> ==?\n+\tequal func(unsafe.Pointer, unsafe.Pointer) bool\n+\t// gcdata stores the GC type data for the garbage collector.\n+\t// If the KindGCProg bit is set in kind, gcdata is a GC program.\n+\t// Otherwise it is a ptrmask bitmap. See mbitmap.go for details.\n \tgcdata  *byte\n \t_string *string\n \t*uncommontype\n@@ -74,10 +88,12 @@ type interfacetype struct {\n }\n \n type maptype struct {\n-\ttyp        _type\n-\tkey        *_type\n-\telem       *_type\n-\tbucket     *_type // internal type representing a hash bucket\n+\ttyp    _type\n+\tkey    *_type\n+\telem   *_type\n+\tbucket *_type // internal type representing a hash bucket\n+\t// function for hashing keys (ptr to key, seed) -> hash\n+\thasher     func(unsafe.Pointer, uintptr) uintptr\n \tkeysize    uint8  // size of key slot\n \telemsize   uint8  // size of elem slot\n \tbucketsize uint16 // size of bucket"}, {"sha": "364878ebcfee923594887474d73bbe36927e3db6", "filename": "libgo/runtime/go-unsafe-pointer.c", "status": "modified", "additions": 9, "deletions": 15, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10172a64cedd95b302a9709429a4832a879667da/libgo%2Fruntime%2Fgo-unsafe-pointer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10172a64cedd95b302a9709429a4832a879667da/libgo%2Fruntime%2Fgo-unsafe-pointer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-unsafe-pointer.c?ref=10172a64cedd95b302a9709429a4832a879667da", "patch": "@@ -36,8 +36,6 @@ static const String reflection_string =\n \n const byte unsafe_Pointer_gc[] = { 1 };\n \n-extern const FuncVal runtime_pointerhash_descriptor\n-  __asm__ (GOSYM_PREFIX \"runtime.pointerhash..f\");\n extern const FuncVal runtime_pointerequal_descriptor\n   __asm__ (GOSYM_PREFIX \"runtime.pointerequal..f\");\n \n@@ -49,17 +47,15 @@ const struct _type unsafe_Pointer =\n   sizeof (void *),\n   /* hash */\n   78501163U,\n-  /* kind */\n-  kindUnsafePointer | kindDirectIface,\n+  /* tflag */\n+  tflagRegularMemory,\n   /* align */\n   __alignof (void *),\n   /* fieldAlign */\n   offsetof (struct field_align, p) - 1,\n-  /* _ */\n-  0,\n-  /* hashfn */\n-  &runtime_pointerhash_descriptor,\n-  /* equalfn */\n+  /* kind */\n+  kindUnsafePointer | kindDirectIface,\n+  /* equal */\n   &runtime_pointerequal_descriptor,\n   /* gcdata */\n   unsafe_Pointer_gc,\n@@ -101,16 +97,14 @@ const struct ptrtype pointer_unsafe_Pointer =\n     sizeof (void *),\n     /* hash */\n     1256018616U,\n-    /* kind */\n-    kindPtr | kindDirectIface,\n+    /* tflag */\n+    tflagRegularMemory,\n     /* align */\n     __alignof (void *),\n     /* fieldAlign */\n     offsetof (struct field_align, p) - 1,\n-    /* _ */\n-    0,\n-    /*_hashfn */\n-    &runtime_pointerhash_descriptor,\n+    /* kind */\n+    kindPtr | kindDirectIface,\n     /* equalfn */\n     &runtime_pointerequal_descriptor,\n     /* gcdata */"}]}