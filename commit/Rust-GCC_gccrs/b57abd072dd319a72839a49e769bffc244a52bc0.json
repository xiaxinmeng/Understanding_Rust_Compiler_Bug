{"sha": "b57abd072dd319a72839a49e769bffc244a52bc0", "node_id": "C_kwDOANBUbNoAKGI1N2FiZDA3MmRkMzE5YTcyODM5YTQ5ZTc2OWJmZmMyNDRhNTJiYzA", "commit": {"author": {"name": "Julian Brown", "email": "julian@codesourcery.com", "date": "2021-07-30T16:15:18Z"}, "committer": {"name": "Julian Brown", "email": "julian@codesourcery.com", "date": "2022-09-14T12:14:19Z"}, "message": "OpenMP 5.0: Clause ordering for OpenMP 5.0 (topological sorting by base pointer)\n\nThis patch reimplements the omp_target_reorder_clauses function in\nanticipation of supporting \"deeper\" struct mappings (that is, with\nseveral structure dereference operators, or similar).\n\nThe idea is that in place of the (possibly quadratic) algorithm in\nomp_target_reorder_clauses that greedily moves clauses containing\naddresses that are subexpressions of other addresses before those other\naddresses, we employ a topological sort algorithm to calculate a proper\norder for map clauses. This should run in linear time, and hopefully\nhandles degenerate cases where multiple \"levels\" of indirect accesses\nare present on a given directive.\n\nThe new method also takes care to keep clause groups together, addressing\nthe concerns raised in:\n\n  https://gcc.gnu.org/pipermail/gcc-patches/2021-May/570501.html\n\nTo figure out if some given clause depends on a base pointer in another\nclause, we strip off the outer layers of the address expression, and check\n(via a tree_operand_hash hash table we have built) if the result is a\n\"base pointer\" as defined in OpenMP 5.0 (1.2.6 Data Terminology). There\nare some subtleties involved, however:\n\n - We must treat MEM_REF with zero offset the same as INDIRECT_REF.\n   This should probably be fixed in the front ends instead so we always\n   use a canonical form (probably INDIRECT_REF). The following patch\n   shows one instance of the problem, but there may be others:\n\n   https://gcc.gnu.org/pipermail/gcc-patches/2021-May/571382.html\n\n - Mapping a whole struct implies mapping each of that struct's\n   elements, which may be base pointers. Because those base pointers\n   aren't necessarily explicitly referenced in the directive in question,\n   we treat the whole-struct mapping as a dependency instead.\n\n2022-09-13  Julian Brown  <julian@codesourcery.com>\n\ngcc/\n\t* gimplify.cc (is_or_contains_p, omp_target_reorder_clauses): Delete\n\tfunctions.\n\t(omp_tsort_mark): Add enum.\n\t(omp_mapping_group): Add struct.\n\t(debug_mapping_group, omp_get_base_pointer, omp_get_attachment,\n\tomp_group_last, omp_gather_mapping_groups, omp_group_base,\n\tomp_index_mapping_groups, omp_containing_struct,\n\tomp_tsort_mapping_groups_1, omp_tsort_mapping_groups,\n\tomp_segregate_mapping_groups, omp_reorder_mapping_groups): New\n\tfunctions.\n\t(gimplify_scan_omp_clauses): Call above functions instead of\n\tomp_target_reorder_clauses, unless we've seen an error.\n\t* omp-low.cc (scan_sharing_clauses): Avoid strict test if we haven't\n\tsorted mapping groups.\n\ngcc/testsuite/\n\t* g++.dg/gomp/target-lambda-1.C: Adjust expected output.\n\t* g++.dg/gomp/target-this-3.C: Likewise.\n\t* g++.dg/gomp/target-this-4.C: Likewise.", "tree": {"sha": "52dd783f42c76665e95ebe11ccbc51d2557ba3fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/52dd783f42c76665e95ebe11ccbc51d2557ba3fa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b57abd072dd319a72839a49e769bffc244a52bc0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b57abd072dd319a72839a49e769bffc244a52bc0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b57abd072dd319a72839a49e769bffc244a52bc0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b57abd072dd319a72839a49e769bffc244a52bc0/comments", "author": {"login": "jtb20", "id": 6094880, "node_id": "MDQ6VXNlcjYwOTQ4ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/6094880?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jtb20", "html_url": "https://github.com/jtb20", "followers_url": "https://api.github.com/users/jtb20/followers", "following_url": "https://api.github.com/users/jtb20/following{/other_user}", "gists_url": "https://api.github.com/users/jtb20/gists{/gist_id}", "starred_url": "https://api.github.com/users/jtb20/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jtb20/subscriptions", "organizations_url": "https://api.github.com/users/jtb20/orgs", "repos_url": "https://api.github.com/users/jtb20/repos", "events_url": "https://api.github.com/users/jtb20/events{/privacy}", "received_events_url": "https://api.github.com/users/jtb20/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jtb20", "id": 6094880, "node_id": "MDQ6VXNlcjYwOTQ4ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/6094880?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jtb20", "html_url": "https://github.com/jtb20", "followers_url": "https://api.github.com/users/jtb20/followers", "following_url": "https://api.github.com/users/jtb20/following{/other_user}", "gists_url": "https://api.github.com/users/jtb20/gists{/gist_id}", "starred_url": "https://api.github.com/users/jtb20/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jtb20/subscriptions", "organizations_url": "https://api.github.com/users/jtb20/orgs", "repos_url": "https://api.github.com/users/jtb20/repos", "events_url": "https://api.github.com/users/jtb20/events{/privacy}", "received_events_url": "https://api.github.com/users/jtb20/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2aa5f8808d1d83c58ced64c89c14bdd237135795", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2aa5f8808d1d83c58ced64c89c14bdd237135795", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2aa5f8808d1d83c58ced64c89c14bdd237135795"}], "stats": {"total": 941, "additions": 748, "deletions": 193}, "files": [{"sha": "2a81258d64a230bef25d64444d2dd0223434d4bf", "filename": "gcc/gimplify.cc", "status": "modified", "additions": 735, "deletions": 184, "changes": 919, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b57abd072dd319a72839a49e769bffc244a52bc0/gcc%2Fgimplify.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b57abd072dd319a72839a49e769bffc244a52bc0/gcc%2Fgimplify.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.cc?ref=b57abd072dd319a72839a49e769bffc244a52bc0", "patch": "@@ -8942,207 +8942,740 @@ extract_base_bit_offset (tree base, tree *base_ref, poly_int64 *bitposp,\n   return base;\n }\n \n-/* Returns true if EXPR is or contains (as a sub-component) BASE_PTR.  */\n+/* Used for topological sorting of mapping groups.  UNVISITED means we haven't\n+   started processing the group yet.  The TEMPORARY mark is used when we first\n+   encounter a group on a depth-first traversal, and the PERMANENT mark is used\n+   when we have processed all the group's children (i.e. all the base pointers\n+   referred to by the group's mapping nodes, recursively).  */\n+\n+enum omp_tsort_mark {\n+  UNVISITED,\n+  TEMPORARY,\n+  PERMANENT\n+};\n \n-static bool\n-is_or_contains_p (tree expr, tree base_ptr)\n+/* A group of OMP_CLAUSE_MAP nodes that correspond to a single \"map\"\n+   clause.  */\n+\n+struct omp_mapping_group {\n+  tree *grp_start;\n+  tree grp_end;\n+  omp_tsort_mark mark;\n+  struct omp_mapping_group *sibling;\n+  struct omp_mapping_group *next;\n+};\n+\n+DEBUG_FUNCTION void\n+debug_mapping_group (omp_mapping_group *grp)\n {\n-  if ((TREE_CODE (expr) == INDIRECT_REF && TREE_CODE (base_ptr) == MEM_REF)\n-      || (TREE_CODE (expr) == MEM_REF && TREE_CODE (base_ptr) == INDIRECT_REF))\n-    return operand_equal_p (TREE_OPERAND (expr, 0),\n-\t\t\t    TREE_OPERAND (base_ptr, 0));\n-  while (!operand_equal_p (expr, base_ptr))\n-    {\n-      if (TREE_CODE (base_ptr) == COMPOUND_EXPR)\n-\tbase_ptr = TREE_OPERAND (base_ptr, 1);\n-      if (TREE_CODE (base_ptr) == COMPONENT_REF\n-\t  || TREE_CODE (base_ptr) == POINTER_PLUS_EXPR\n-\t  || TREE_CODE (base_ptr) == SAVE_EXPR)\n-\tbase_ptr = TREE_OPERAND (base_ptr, 0);\n-      else\n-\tbreak;\n+  tree tmp = OMP_CLAUSE_CHAIN (grp->grp_end);\n+  OMP_CLAUSE_CHAIN (grp->grp_end) = NULL;\n+  debug_generic_expr (*grp->grp_start);\n+  OMP_CLAUSE_CHAIN (grp->grp_end) = tmp;\n+}\n+\n+/* Return the OpenMP \"base pointer\" of an expression EXPR, or NULL if there\n+   isn't one.  */\n+\n+static tree\n+omp_get_base_pointer (tree expr)\n+{\n+  while (TREE_CODE (expr) == ARRAY_REF\n+\t || TREE_CODE (expr) == COMPONENT_REF)\n+    expr = TREE_OPERAND (expr, 0);\n+\n+  if (TREE_CODE (expr) == INDIRECT_REF\n+      || (TREE_CODE (expr) == MEM_REF\n+\t  && integer_zerop (TREE_OPERAND (expr, 1))))\n+    {\n+      expr = TREE_OPERAND (expr, 0);\n+      while (TREE_CODE (expr) == COMPOUND_EXPR)\n+\texpr = TREE_OPERAND (expr, 1);\n+      if (TREE_CODE (expr) == POINTER_PLUS_EXPR)\n+\texpr = TREE_OPERAND (expr, 0);\n+      if (TREE_CODE (expr) == SAVE_EXPR)\n+\texpr = TREE_OPERAND (expr, 0);\n+      STRIP_NOPS (expr);\n+      return expr;\n     }\n-  return operand_equal_p (expr, base_ptr);\n+\n+  return NULL_TREE;\n }\n \n-/* Implement OpenMP 5.x map ordering rules for target directives. There are\n-   several rules, and with some level of ambiguity, hopefully we can at least\n-   collect the complexity here in one place.  */\n+/* An attach or detach operation depends directly on the address being\n+   attached/detached.  Return that address, or none if there are no\n+   attachments/detachments.  */\n \n-static void\n-omp_target_reorder_clauses (tree *list_p)\n+static tree\n+omp_get_attachment (omp_mapping_group *grp)\n {\n-  /* Collect refs to alloc/release/delete maps.  */\n-  auto_vec<tree, 32> ard;\n-  tree *cp = list_p;\n-  while (*cp != NULL_TREE)\n-    if (OMP_CLAUSE_CODE (*cp) == OMP_CLAUSE_MAP\n-\t&& (OMP_CLAUSE_MAP_KIND (*cp) == GOMP_MAP_ALLOC\n-\t    || OMP_CLAUSE_MAP_KIND (*cp) == GOMP_MAP_RELEASE\n-\t    || OMP_CLAUSE_MAP_KIND (*cp) == GOMP_MAP_DELETE))\n-      {\n-\t/* Unlink cp and push to ard.  */\n-\ttree c = *cp;\n-\ttree nc = OMP_CLAUSE_CHAIN (c);\n-\t*cp = nc;\n-\tard.safe_push (c);\n-\n-\t/* Any associated pointer type maps should also move along.  */\n-\twhile (*cp != NULL_TREE\n-\t       && OMP_CLAUSE_CODE (*cp) == OMP_CLAUSE_MAP\n-\t       && (OMP_CLAUSE_MAP_KIND (*cp) == GOMP_MAP_FIRSTPRIVATE_REFERENCE\n-\t\t   || OMP_CLAUSE_MAP_KIND (*cp) == GOMP_MAP_FIRSTPRIVATE_POINTER\n-\t\t   || OMP_CLAUSE_MAP_KIND (*cp) == GOMP_MAP_ATTACH_DETACH\n-\t\t   || OMP_CLAUSE_MAP_KIND (*cp) == GOMP_MAP_POINTER\n-\t\t   || OMP_CLAUSE_MAP_KIND (*cp) == GOMP_MAP_ALWAYS_POINTER\n-\t\t   || OMP_CLAUSE_MAP_KIND (*cp) == GOMP_MAP_TO_PSET))\n+  tree node = *grp->grp_start;\n+\n+  switch (OMP_CLAUSE_MAP_KIND (node))\n+    {\n+    case GOMP_MAP_TO:\n+    case GOMP_MAP_FROM:\n+    case GOMP_MAP_TOFROM:\n+    case GOMP_MAP_ALWAYS_FROM:\n+    case GOMP_MAP_ALWAYS_TO:\n+    case GOMP_MAP_ALWAYS_TOFROM:\n+    case GOMP_MAP_FORCE_FROM:\n+    case GOMP_MAP_FORCE_TO:\n+    case GOMP_MAP_FORCE_TOFROM:\n+    case GOMP_MAP_FORCE_PRESENT:\n+    case GOMP_MAP_ALLOC:\n+    case GOMP_MAP_RELEASE:\n+    case GOMP_MAP_DELETE:\n+    case GOMP_MAP_FORCE_ALLOC:\n+      if (node == grp->grp_end)\n+\treturn NULL_TREE;\n+\n+      node = OMP_CLAUSE_CHAIN (node);\n+      if (node && OMP_CLAUSE_MAP_KIND (node) == GOMP_MAP_TO_PSET)\n+\t{\n+\t  gcc_assert (node != grp->grp_end);\n+\t  node = OMP_CLAUSE_CHAIN (node);\n+\t}\n+      if (node)\n+\tswitch (OMP_CLAUSE_MAP_KIND (node))\n \t  {\n-\t    c = *cp;\n-\t    nc = OMP_CLAUSE_CHAIN (c);\n-\t    *cp = nc;\n-\t    ard.safe_push (c);\n+\t  case GOMP_MAP_POINTER:\n+\t  case GOMP_MAP_ALWAYS_POINTER:\n+\t  case GOMP_MAP_FIRSTPRIVATE_POINTER:\n+\t  case GOMP_MAP_FIRSTPRIVATE_REFERENCE:\n+\t  case GOMP_MAP_POINTER_TO_ZERO_LENGTH_ARRAY_SECTION:\n+\t    return NULL_TREE;\n+\n+\t  case GOMP_MAP_ATTACH_DETACH:\n+\t  case GOMP_MAP_ATTACH_ZERO_LENGTH_ARRAY_SECTION:\n+\t    return OMP_CLAUSE_DECL (node);\n+\n+\t  default:\n+\t    internal_error (\"unexpected mapping node\");\n \t  }\n-      }\n-    else\n-      cp = &OMP_CLAUSE_CHAIN (*cp);\n+      return error_mark_node;\n+\n+    case GOMP_MAP_TO_PSET:\n+      gcc_assert (node != grp->grp_end);\n+      node = OMP_CLAUSE_CHAIN (node);\n+      if (OMP_CLAUSE_MAP_KIND (node) == GOMP_MAP_ATTACH\n+\t  || OMP_CLAUSE_MAP_KIND (node) == GOMP_MAP_DETACH)\n+\treturn OMP_CLAUSE_DECL (node);\n+      else\n+\tinternal_error (\"unexpected mapping node\");\n+      return error_mark_node;\n+\n+    case GOMP_MAP_ATTACH:\n+    case GOMP_MAP_DETACH:\n+      node = OMP_CLAUSE_CHAIN (node);\n+      if (!node || *grp->grp_start == grp->grp_end)\n+\treturn OMP_CLAUSE_DECL (*grp->grp_start);\n+      if (OMP_CLAUSE_MAP_KIND (node) == GOMP_MAP_FIRSTPRIVATE_POINTER\n+\t  || OMP_CLAUSE_MAP_KIND (node) == GOMP_MAP_FIRSTPRIVATE_REFERENCE)\n+\treturn OMP_CLAUSE_DECL (*grp->grp_start);\n+      else\n+\tinternal_error (\"unexpected mapping node\");\n+      return error_mark_node;\n+\n+    case GOMP_MAP_STRUCT:\n+    case GOMP_MAP_FORCE_DEVICEPTR:\n+    case GOMP_MAP_DEVICE_RESIDENT:\n+    case GOMP_MAP_LINK:\n+    case GOMP_MAP_IF_PRESENT:\n+    case GOMP_MAP_FIRSTPRIVATE:\n+    case GOMP_MAP_FIRSTPRIVATE_INT:\n+    case GOMP_MAP_USE_DEVICE_PTR:\n+    case GOMP_MAP_ATTACH_ZERO_LENGTH_ARRAY_SECTION:\n+      return NULL_TREE;\n+\n+    default:\n+      internal_error (\"unexpected mapping node\");\n+    }\n+\n+  return error_mark_node;\n+}\n+\n+/* Given a pointer START_P to the start of a group of related (e.g. pointer)\n+   mappings, return the chain pointer to the end of that group in the list.  */\n+\n+static tree *\n+omp_group_last (tree *start_p)\n+{\n+  tree c = *start_p, nc, *grp_last_p = start_p;\n+\n+  gcc_assert (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_MAP);\n+\n+  nc = OMP_CLAUSE_CHAIN (c);\n+\n+  if (!nc || OMP_CLAUSE_CODE (nc) != OMP_CLAUSE_MAP)\n+    return grp_last_p;\n \n-  /* Link alloc/release/delete maps to the end of list.  */\n-  for (unsigned int i = 0; i < ard.length (); i++)\n+  switch (OMP_CLAUSE_MAP_KIND (c))\n     {\n-      *cp = ard[i];\n-      cp = &OMP_CLAUSE_CHAIN (ard[i]);\n+    default:\n+      while (nc\n+\t     && OMP_CLAUSE_CODE (nc) == OMP_CLAUSE_MAP\n+\t     && (OMP_CLAUSE_MAP_KIND (nc) == GOMP_MAP_FIRSTPRIVATE_REFERENCE\n+\t\t || OMP_CLAUSE_MAP_KIND (nc) == GOMP_MAP_FIRSTPRIVATE_POINTER\n+\t\t || OMP_CLAUSE_MAP_KIND (nc) == GOMP_MAP_ATTACH_DETACH\n+\t\t || OMP_CLAUSE_MAP_KIND (nc) == GOMP_MAP_POINTER\n+\t\t || (OMP_CLAUSE_MAP_KIND (nc)\n+\t\t     == GOMP_MAP_POINTER_TO_ZERO_LENGTH_ARRAY_SECTION)\n+\t\t || (OMP_CLAUSE_MAP_KIND (nc)\n+\t\t     == GOMP_MAP_ATTACH_ZERO_LENGTH_ARRAY_SECTION)\n+\t\t || OMP_CLAUSE_MAP_KIND (nc) == GOMP_MAP_ALWAYS_POINTER\n+\t\t || OMP_CLAUSE_MAP_KIND (nc) == GOMP_MAP_TO_PSET))\n+\t{\n+\t  grp_last_p = &OMP_CLAUSE_CHAIN (c);\n+\t  c = nc;\n+\t  tree nc2 = OMP_CLAUSE_CHAIN (nc);\n+\t  if (nc2\n+\t      && OMP_CLAUSE_CODE (nc2) == OMP_CLAUSE_MAP\n+\t      && (OMP_CLAUSE_MAP_KIND (nc)\n+\t\t  == GOMP_MAP_POINTER_TO_ZERO_LENGTH_ARRAY_SECTION)\n+\t      && OMP_CLAUSE_MAP_KIND (nc2) == GOMP_MAP_ATTACH)\n+\t    {\n+\t      grp_last_p = &OMP_CLAUSE_CHAIN (nc);\n+\t      c = nc2;\n+\t      nc2 = OMP_CLAUSE_CHAIN (nc2);\n+\t    }\n+\t   nc = nc2;\n+\t}\n+      break;\n+\n+    case GOMP_MAP_ATTACH:\n+    case GOMP_MAP_DETACH:\n+      /* This is a weird artifact of how directives are parsed: bare attach or\n+\t detach clauses get a subsequent (meaningless) FIRSTPRIVATE_POINTER or\n+\t FIRSTPRIVATE_REFERENCE node.  FIXME.  */\n+      if (nc\n+\t  && OMP_CLAUSE_CODE (nc) == OMP_CLAUSE_MAP\n+\t  && (OMP_CLAUSE_MAP_KIND (nc) == GOMP_MAP_FIRSTPRIVATE_REFERENCE\n+\t      || OMP_CLAUSE_MAP_KIND (nc) == GOMP_MAP_FIRSTPRIVATE_POINTER))\n+\tgrp_last_p = &OMP_CLAUSE_CHAIN (c);\n+      break;\n+\n+    case GOMP_MAP_TO_PSET:\n+      if (OMP_CLAUSE_CODE (nc) == OMP_CLAUSE_MAP\n+\t  && (OMP_CLAUSE_MAP_KIND (nc) == GOMP_MAP_ATTACH\n+\t      || OMP_CLAUSE_MAP_KIND (nc) == GOMP_MAP_DETACH))\n+\tgrp_last_p = &OMP_CLAUSE_CHAIN (c);\n+      break;\n     }\n-  *cp = NULL_TREE;\n \n-  /* OpenMP 5.0 requires that pointer variables are mapped before\n-     its use as a base-pointer.  */\n-  auto_vec<tree *, 32> atf;\n+  return grp_last_p;\n+}\n+\n+/* Walk through LIST_P, and return a list of groups of mappings found (e.g.\n+   OMP_CLAUSE_MAP with GOMP_MAP_{TO/FROM/TOFROM} followed by one or two\n+   associated GOMP_MAP_POINTER mappings).  Return a vector of omp_mapping_group\n+   if we have more than one such group, else return NULL.  */\n+\n+static vec<omp_mapping_group> *\n+omp_gather_mapping_groups (tree *list_p)\n+{\n+  vec<omp_mapping_group> *groups = new vec<omp_mapping_group> ();\n+\n   for (tree *cp = list_p; *cp; cp = &OMP_CLAUSE_CHAIN (*cp))\n-    if (OMP_CLAUSE_CODE (*cp) == OMP_CLAUSE_MAP)\n-      {\n-\t/* Collect alloc, to, from, to/from clause tree pointers.  */\n-\tgomp_map_kind k = OMP_CLAUSE_MAP_KIND (*cp);\n-\tif (k == GOMP_MAP_ALLOC\n-\t    || k == GOMP_MAP_TO\n-\t    || k == GOMP_MAP_FROM\n-\t    || k == GOMP_MAP_TOFROM\n-\t    || k == GOMP_MAP_ALWAYS_TO\n-\t    || k == GOMP_MAP_ALWAYS_FROM\n-\t    || k == GOMP_MAP_ALWAYS_TOFROM)\n-\t  atf.safe_push (cp);\n-      }\n+    {\n+      if (OMP_CLAUSE_CODE (*cp) != OMP_CLAUSE_MAP)\n+\tcontinue;\n \n-  for (unsigned int i = 0; i < atf.length (); i++)\n-    if (atf[i])\n-      {\n-\ttree *cp = atf[i];\n-\ttree decl = OMP_CLAUSE_DECL (*cp);\n-\tif (TREE_CODE (decl) == INDIRECT_REF || TREE_CODE (decl) == MEM_REF)\n-\t  {\n-\t    tree base_ptr = TREE_OPERAND (decl, 0);\n-\t    STRIP_TYPE_NOPS (base_ptr);\n-\t    for (unsigned int j = i + 1; j < atf.length (); j++)\n-\t      if (atf[j])\n-\t\t{\n-\t\t  tree *cp2 = atf[j];\n-\t\t  tree decl2 = OMP_CLAUSE_DECL (*cp2);\n+      tree *grp_last_p = omp_group_last (cp);\n+      omp_mapping_group grp;\n \n-\t\t  decl2 = OMP_CLAUSE_DECL (*cp2);\n-\t\t  if (is_or_contains_p (decl2, base_ptr))\n-\t\t    {\n-\t\t      /* Move *cp2 to before *cp.  */\n-\t\t      tree c = *cp2;\n-\t\t      *cp2 = OMP_CLAUSE_CHAIN (c);\n-\t\t      OMP_CLAUSE_CHAIN (c) = *cp;\n-\t\t      *cp = c;\n-\n-\t\t      if (*cp2 != NULL_TREE\n-\t\t\t  && OMP_CLAUSE_CODE (*cp2) == OMP_CLAUSE_MAP\n-\t\t\t  && OMP_CLAUSE_MAP_KIND (*cp2) == GOMP_MAP_ALWAYS_POINTER)\n-\t\t\t{\n-\t\t\t  tree c2 = *cp2;\n-\t\t\t  *cp2 = OMP_CLAUSE_CHAIN (c2);\n-\t\t\t  OMP_CLAUSE_CHAIN (c2) = OMP_CLAUSE_CHAIN (c);\n-\t\t\t  OMP_CLAUSE_CHAIN (c) = c2;\n-\t\t\t}\n+      grp.grp_start = cp;\n+      grp.grp_end = *grp_last_p;\n+      grp.mark = UNVISITED;\n+      grp.sibling = NULL;\n+      grp.next = NULL;\n+      groups->safe_push (grp);\n \n-\t\t      atf[j] = NULL;\n-\t\t  }\n-\t\t}\n+      cp = grp_last_p;\n+    }\n+\n+  if (groups->length () > 0)\n+    return groups;\n+  else\n+    {\n+      delete groups;\n+      return NULL;\n+    }\n+}\n+\n+/* A pointer mapping group GRP may define a block of memory starting at some\n+   base address, and maybe also define a firstprivate pointer or firstprivate\n+   reference that points to that block.  The return value is a node containing\n+   the former, and the *FIRSTPRIVATE pointer is set if we have the latter.\n+   If we define several base pointers, i.e. for a GOMP_MAP_STRUCT mapping,\n+   return the number of consecutive chained nodes in CHAINED.  */\n+\n+static tree\n+omp_group_base (omp_mapping_group *grp, unsigned int *chained,\n+\t\ttree *firstprivate)\n+{\n+  tree node = *grp->grp_start;\n+\n+  *firstprivate = NULL_TREE;\n+  *chained = 1;\n+\n+  switch (OMP_CLAUSE_MAP_KIND (node))\n+    {\n+    case GOMP_MAP_TO:\n+    case GOMP_MAP_FROM:\n+    case GOMP_MAP_TOFROM:\n+    case GOMP_MAP_ALWAYS_FROM:\n+    case GOMP_MAP_ALWAYS_TO:\n+    case GOMP_MAP_ALWAYS_TOFROM:\n+    case GOMP_MAP_FORCE_FROM:\n+    case GOMP_MAP_FORCE_TO:\n+    case GOMP_MAP_FORCE_TOFROM:\n+    case GOMP_MAP_FORCE_PRESENT:\n+    case GOMP_MAP_ALLOC:\n+    case GOMP_MAP_RELEASE:\n+    case GOMP_MAP_DELETE:\n+    case GOMP_MAP_FORCE_ALLOC:\n+      if (node == grp->grp_end)\n+\treturn node;\n+\n+      node = OMP_CLAUSE_CHAIN (node);\n+      if (node && OMP_CLAUSE_MAP_KIND (node) == GOMP_MAP_TO_PSET)\n+\t{\n+\t  gcc_assert (node != grp->grp_end);\n+\t  node = OMP_CLAUSE_CHAIN (node);\n+\t}\n+      if (node)\n+\tswitch (OMP_CLAUSE_MAP_KIND (node))\n+\t  {\n+\t  case GOMP_MAP_POINTER:\n+\t  case GOMP_MAP_FIRSTPRIVATE_POINTER:\n+\t  case GOMP_MAP_FIRSTPRIVATE_REFERENCE:\n+\t  case GOMP_MAP_POINTER_TO_ZERO_LENGTH_ARRAY_SECTION:\n+\t    *firstprivate = OMP_CLAUSE_DECL (node);\n+\t    return *grp->grp_start;\n+\n+\t  case GOMP_MAP_ALWAYS_POINTER:\n+\t  case GOMP_MAP_ATTACH_DETACH:\n+\t  case GOMP_MAP_ATTACH_ZERO_LENGTH_ARRAY_SECTION:\n+\t    return *grp->grp_start;\n+\n+\t  default:\n+\t    internal_error (\"unexpected mapping node\");\n \t  }\n-      }\n+      else\n+\tinternal_error (\"unexpected mapping node\");\n+      return error_mark_node;\n+\n+    case GOMP_MAP_TO_PSET:\n+      gcc_assert (node != grp->grp_end);\n+      node = OMP_CLAUSE_CHAIN (node);\n+      if (OMP_CLAUSE_MAP_KIND (node) == GOMP_MAP_ATTACH\n+\t  || OMP_CLAUSE_MAP_KIND (node) == GOMP_MAP_DETACH)\n+\treturn NULL_TREE;\n+      else\n+\tinternal_error (\"unexpected mapping node\");\n+      return error_mark_node;\n \n-  /* For attach_detach map clauses, if there is another map that maps the\n-     attached/detached pointer, make sure that map is ordered before the\n-     attach_detach.  */\n-  atf.truncate (0);\n-  for (tree *cp = list_p; *cp; cp = &OMP_CLAUSE_CHAIN (*cp))\n-    if (OMP_CLAUSE_CODE (*cp) == OMP_CLAUSE_MAP)\n-      {\n-\t/* Collect alloc, to, from, to/from clauses, and\n-\t   always_pointer/attach_detach clauses.  */\n-\tgomp_map_kind k = OMP_CLAUSE_MAP_KIND (*cp);\n-\tif (k == GOMP_MAP_ALLOC\n-\t    || k == GOMP_MAP_TO\n-\t    || k == GOMP_MAP_FROM\n-\t    || k == GOMP_MAP_TOFROM\n-\t    || k == GOMP_MAP_ALWAYS_TO\n-\t    || k == GOMP_MAP_ALWAYS_FROM\n-\t    || k == GOMP_MAP_ALWAYS_TOFROM\n-\t    || k == GOMP_MAP_ATTACH_DETACH\n-\t    || k == GOMP_MAP_ALWAYS_POINTER)\n-\t  atf.safe_push (cp);\n-      }\n+    case GOMP_MAP_ATTACH:\n+    case GOMP_MAP_DETACH:\n+      node = OMP_CLAUSE_CHAIN (node);\n+      if (!node || *grp->grp_start == grp->grp_end)\n+\treturn NULL_TREE;\n+      if (OMP_CLAUSE_MAP_KIND (node) == GOMP_MAP_FIRSTPRIVATE_POINTER\n+\t  || OMP_CLAUSE_MAP_KIND (node) == GOMP_MAP_FIRSTPRIVATE_REFERENCE)\n+\t{\n+\t  /* We're mapping the base pointer itself in a bare attach or detach\n+\t     node.  This is a side effect of how parsing works, and the mapping\n+\t     will be removed anyway (at least for enter/exit data directives).\n+\t     We should ignore the mapping here.  FIXME.  */\n+\t  return NULL_TREE;\n+\t}\n+      else\n+\tinternal_error (\"unexpected mapping node\");\n+      return error_mark_node;\n+\n+    case GOMP_MAP_FORCE_DEVICEPTR:\n+    case GOMP_MAP_DEVICE_RESIDENT:\n+    case GOMP_MAP_LINK:\n+    case GOMP_MAP_IF_PRESENT:\n+    case GOMP_MAP_FIRSTPRIVATE:\n+    case GOMP_MAP_FIRSTPRIVATE_INT:\n+    case GOMP_MAP_USE_DEVICE_PTR:\n+    case GOMP_MAP_ATTACH_ZERO_LENGTH_ARRAY_SECTION:\n+      return NULL_TREE;\n \n-  for (unsigned int i = 0; i < atf.length (); i++)\n-    if (atf[i])\n-      {\n-\ttree *cp = atf[i];\n-\ttree ptr = OMP_CLAUSE_DECL (*cp);\n-\tSTRIP_TYPE_NOPS (ptr);\n-\tif (OMP_CLAUSE_MAP_KIND (*cp) == GOMP_MAP_ATTACH_DETACH)\n-\t  for (unsigned int j = i + 1; j < atf.length (); j++)\n+    case GOMP_MAP_FIRSTPRIVATE_POINTER:\n+    case GOMP_MAP_FIRSTPRIVATE_REFERENCE:\n+    case GOMP_MAP_POINTER:\n+    case GOMP_MAP_ALWAYS_POINTER:\n+    case GOMP_MAP_POINTER_TO_ZERO_LENGTH_ARRAY_SECTION:\n+      /* These shouldn't appear by themselves.  */\n+      if (!seen_error ())\n+\tinternal_error (\"unexpected pointer mapping node\");\n+      return error_mark_node;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  return error_mark_node;\n+}\n+\n+/* Given a vector of omp_mapping_groups, build a hash table so we can look up\n+   nodes by tree_operand_hash.  */\n+\n+static hash_map<tree_operand_hash, omp_mapping_group *> *\n+omp_index_mapping_groups (vec<omp_mapping_group> *groups)\n+{\n+  hash_map<tree_operand_hash, omp_mapping_group *> *grpmap\n+    = new hash_map<tree_operand_hash, omp_mapping_group *>;\n+\n+  omp_mapping_group *grp;\n+  unsigned int i;\n+\n+  FOR_EACH_VEC_ELT (*groups, i, grp)\n+    {\n+      tree fpp;\n+      unsigned int chained;\n+      tree node = omp_group_base (grp, &chained, &fpp);\n+\n+      if (node == error_mark_node || (!node && !fpp))\n+\tcontinue;\n+\n+      for (unsigned j = 0;\n+\t   node && j < chained;\n+\t   node = OMP_CLAUSE_CHAIN (node), j++)\n+\t{\n+\t  tree decl = OMP_CLAUSE_DECL (node);\n+\n+\t  /* Sometimes we see zero-offset MEM_REF instead of INDIRECT_REF,\n+\t     meaning node-hash lookups don't work.  This is a workaround for\n+\t     that, but ideally we should just create the INDIRECT_REF at\n+\t     source instead.  FIXME.  */\n+\t  if (TREE_CODE (decl) == MEM_REF\n+\t      && integer_zerop (TREE_OPERAND (decl, 1)))\n+\t    decl = build1 (INDIRECT_REF, TREE_TYPE (decl),\n+\t\t\t   TREE_OPERAND (decl, 0));\n+\n+\t  omp_mapping_group **prev = grpmap->get (decl);\n+\n+\t  if (prev && *prev == grp)\n+\t    /* Empty.  */;\n+\t  else if (prev)\n \t    {\n-\t      tree *cp2 = atf[j];\n-\t      tree decl2 = OMP_CLAUSE_DECL (*cp2);\n-\t      if (OMP_CLAUSE_MAP_KIND (*cp2) != GOMP_MAP_ATTACH_DETACH\n-\t\t  && OMP_CLAUSE_MAP_KIND (*cp2) != GOMP_MAP_ALWAYS_POINTER\n-\t\t  && is_or_contains_p (decl2, ptr))\n-\t\t{\n-\t\t  /* Move *cp2 to before *cp.  */\n-\t\t  tree c = *cp2;\n-\t\t  *cp2 = OMP_CLAUSE_CHAIN (c);\n-\t\t  OMP_CLAUSE_CHAIN (c) = *cp;\n-\t\t  *cp = c;\n-\t\t  atf[j] = NULL;\n-\n-\t\t  /* If decl2 is of the form '*decl2_opnd0', and followed by an\n-\t\t     ALWAYS_POINTER or ATTACH_DETACH of 'decl2_opnd0', move the\n-\t\t     pointer operation along with *cp2. This can happen for C++\n-\t\t     reference sequences.  */\n-\t\t  if (j + 1 < atf.length ()\n-\t\t      && (TREE_CODE (decl2) == INDIRECT_REF\n-\t\t\t  || TREE_CODE (decl2) == MEM_REF))\n-\t\t    {\n-\t\t      tree *cp3 = atf[j + 1];\n-\t\t      tree decl3 = OMP_CLAUSE_DECL (*cp3);\n-\t\t      tree decl2_opnd0 = TREE_OPERAND (decl2, 0);\n-\t\t      if ((OMP_CLAUSE_MAP_KIND (*cp3) == GOMP_MAP_ALWAYS_POINTER\n-\t\t\t   || OMP_CLAUSE_MAP_KIND (*cp3) == GOMP_MAP_ATTACH_DETACH)\n-\t\t\t  && operand_equal_p (decl3, decl2_opnd0))\n-\t\t\t{\n-\t\t\t  /* Also move *cp3 to before *cp.  */\n-\t\t\t  c = *cp3;\n-\t\t\t  *cp2 = OMP_CLAUSE_CHAIN (c);\n-\t\t\t  OMP_CLAUSE_CHAIN (c) = *cp;\n-\t\t\t  *cp = c;\n-\t\t\t  atf[j + 1] = NULL;\n-\t\t\t  j += 1;\n-\t\t\t}\n-\t\t    }\n-\t\t}\n+\t      /* Mapping the same thing twice is normally diagnosed as an error,\n+\t\t but can happen under some circumstances, e.g. in pr99928-16.c,\n+\t\t the directive:\n+\n+\t\t #pragma omp target simd reduction(+:a[:3]) \\\n+\t\t\t\t\t map(always, tofrom: a[:6])\n+\t\t ...\n+\n+\t\t will result in two \"a[0]\" mappings (of different sizes).  */\n+\n+\t      grp->sibling = (*prev)->sibling;\n+\t      (*prev)->sibling = grp;\n \t    }\n-      }\n+\t  else\n+\t    grpmap->put (decl, grp);\n+\t}\n+\n+      if (!fpp)\n+\tcontinue;\n+\n+      omp_mapping_group **prev = grpmap->get (fpp);\n+      if (prev)\n+\t{\n+\t  grp->sibling = (*prev)->sibling;\n+\t  (*prev)->sibling = grp;\n+\t}\n+      else\n+\tgrpmap->put (fpp, grp);\n+    }\n+  return grpmap;\n+}\n+\n+/* Find the immediately-containing struct for a component ref (etc.)\n+   expression EXPR.  */\n+\n+static tree\n+omp_containing_struct (tree expr)\n+{\n+  tree expr0 = expr;\n+\n+  STRIP_NOPS (expr);\n+\n+  /* Note: don't strip NOPs unless we're also stripping off array refs or a\n+     component ref.  */\n+  if (TREE_CODE (expr) != ARRAY_REF && TREE_CODE (expr) != COMPONENT_REF)\n+    return expr0;\n+\n+  while (TREE_CODE (expr) == ARRAY_REF)\n+    expr = TREE_OPERAND (expr, 0);\n+\n+  if (TREE_CODE (expr) == COMPONENT_REF)\n+    expr = TREE_OPERAND (expr, 0);\n+\n+  return expr;\n+}\n+\n+/* Helper function for omp_tsort_mapping_groups.  Returns TRUE on success, or\n+   FALSE on error.  */\n+\n+static bool\n+omp_tsort_mapping_groups_1 (omp_mapping_group ***outlist,\n+\t\t\t    vec<omp_mapping_group> *groups,\n+\t\t\t    hash_map<tree_operand_hash, omp_mapping_group *>\n+\t\t\t      *grpmap,\n+\t\t\t    omp_mapping_group *grp)\n+{\n+  if (grp->mark == PERMANENT)\n+    return true;\n+  if (grp->mark == TEMPORARY)\n+    {\n+      fprintf (stderr, \"when processing group:\\n\");\n+      debug_mapping_group (grp);\n+      internal_error (\"base pointer cycle detected\");\n+      return false;\n+    }\n+  grp->mark = TEMPORARY;\n+\n+  tree attaches_to = omp_get_attachment (grp);\n+\n+  if (attaches_to)\n+    {\n+      omp_mapping_group **basep = grpmap->get (attaches_to);\n+\n+      if (basep)\n+\t{\n+\t  gcc_assert (*basep != grp);\n+\t  for (omp_mapping_group *w = *basep; w; w = w->sibling)\n+\t    if (!omp_tsort_mapping_groups_1 (outlist, groups, grpmap, w))\n+\t      return false;\n+\t}\n+    }\n+\n+  tree decl = OMP_CLAUSE_DECL (*grp->grp_start);\n+\n+  while (decl)\n+    {\n+      tree base = omp_get_base_pointer (decl);\n+\n+      if (!base)\n+\tbreak;\n+\n+      omp_mapping_group **innerp = grpmap->get (base);\n+\n+      /* We should treat whole-structure mappings as if all (pointer, in this\n+\t case) members are mapped as individual list items.  Check if we have\n+\t such a whole-structure mapping, if we don't have an explicit reference\n+\t to the pointer member itself.  */\n+      if (!innerp && TREE_CODE (base) == COMPONENT_REF)\n+\t{\n+\t  base = omp_containing_struct (base);\n+\t  innerp = grpmap->get (base);\n+\n+\t  if (!innerp\n+\t      && TREE_CODE (base) == MEM_REF\n+\t      && integer_zerop (TREE_OPERAND (base, 1)))\n+\t    {\n+\t      tree ind = TREE_OPERAND (base, 0);\n+\t      ind = build1 (INDIRECT_REF, TREE_TYPE (base), ind);\n+\t      innerp = grpmap->get (ind);\n+\t    }\n+\t}\n+\n+      if (innerp && *innerp != grp)\n+\t{\n+\t  for (omp_mapping_group *w = *innerp; w; w = w->sibling)\n+\t    if (!omp_tsort_mapping_groups_1 (outlist, groups, grpmap, w))\n+\t      return false;\n+\t  break;\n+\t}\n+\n+      decl = base;\n+    }\n+\n+  grp->mark = PERMANENT;\n+\n+  /* Emit grp to output list.  */\n+\n+  **outlist = grp;\n+  *outlist = &grp->next;\n+\n+  return true;\n+}\n+\n+/* Topologically sort GROUPS, so that OMP 5.0-defined base pointers come\n+   before mappings that use those pointers.  This is an implementation of the\n+   depth-first search algorithm, described e.g. at:\n+\n+     https://en.wikipedia.org/wiki/Topological_sorting\n+*/\n+\n+static omp_mapping_group *\n+omp_tsort_mapping_groups (vec<omp_mapping_group> *groups,\n+\t\t\t  hash_map<tree_operand_hash, omp_mapping_group *>\n+\t\t\t    *grpmap)\n+{\n+  omp_mapping_group *grp, *outlist = NULL, **cursor;\n+  unsigned int i;\n+\n+  cursor = &outlist;\n+\n+  FOR_EACH_VEC_ELT (*groups, i, grp)\n+    {\n+      if (grp->mark != PERMANENT)\n+\tif (!omp_tsort_mapping_groups_1 (&cursor, groups, grpmap, grp))\n+\t  return NULL;\n+    }\n+\n+  return outlist;\n+}\n+\n+/* Split INLIST into two parts, moving groups corresponding to\n+   ALLOC/RELEASE/DELETE mappings to one list, and other mappings to another.\n+   The former list is then appended to the latter.  Each sub-list retains the\n+   order of the original list.  */\n+\n+static omp_mapping_group *\n+omp_segregate_mapping_groups (omp_mapping_group *inlist)\n+{\n+  omp_mapping_group *ard_groups = NULL, *tf_groups = NULL;\n+  omp_mapping_group **ard_tail = &ard_groups, **tf_tail = &tf_groups;\n+\n+  for (omp_mapping_group *w = inlist; w;)\n+    {\n+      tree c = *w->grp_start;\n+      omp_mapping_group *next = w->next;\n+\n+      gcc_assert (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_MAP);\n+\n+      switch (OMP_CLAUSE_MAP_KIND (c))\n+\t{\n+\tcase GOMP_MAP_ALLOC:\n+\tcase GOMP_MAP_RELEASE:\n+\tcase GOMP_MAP_DELETE:\n+\t  *ard_tail = w;\n+\t  w->next = NULL;\n+\t  ard_tail = &w->next;\n+\t  break;\n+\n+\tdefault:\n+\t  *tf_tail = w;\n+\t  w->next = NULL;\n+\t  tf_tail = &w->next;\n+\t}\n+\n+      w = next;\n+    }\n+\n+  /* Now splice the lists together...  */\n+  *tf_tail = ard_groups;\n+\n+  return tf_groups;\n+}\n+\n+/* Given a list LIST_P containing groups of mappings given by GROUPS, reorder\n+   those groups based on the output list of omp_tsort_mapping_groups --\n+   singly-linked, threaded through each element's NEXT pointer starting at\n+   HEAD.  Each list element appears exactly once in that linked list.\n+\n+   Each element of GROUPS may correspond to one or several mapping nodes.\n+   Node groups are kept together, and in the reordered list, the positions of\n+   the original groups are reused for the positions of the reordered list.\n+   Hence if we have e.g.\n+\n+     {to ptr ptr} firstprivate {tofrom ptr} ...\n+      ^             ^           ^\n+      first group  non-\"map\"    second group\n+\n+   and say the second group contains a base pointer for the first so must be\n+   moved before it, the resulting list will contain:\n+\n+     {tofrom ptr} firstprivate {to ptr ptr} ...\n+      ^ prev. second group      ^ prev. first group\n+*/\n+\n+static tree *\n+omp_reorder_mapping_groups (vec<omp_mapping_group> *groups,\n+\t\t\t    omp_mapping_group *head,\n+\t\t\t    tree *list_p)\n+{\n+  omp_mapping_group *grp;\n+  unsigned int i;\n+  unsigned numgroups = groups->length ();\n+  auto_vec<tree> old_heads (numgroups);\n+  auto_vec<tree *> old_headps (numgroups);\n+  auto_vec<tree> new_heads (numgroups);\n+  auto_vec<tree> old_succs (numgroups);\n+  bool map_at_start = (list_p == (*groups)[0].grp_start);\n+\n+  tree *new_grp_tail = NULL;\n+\n+  /* Stash the start & end nodes of each mapping group before we start\n+     modifying the list.  */\n+  FOR_EACH_VEC_ELT (*groups, i, grp)\n+    {\n+      old_headps.quick_push (grp->grp_start);\n+      old_heads.quick_push (*grp->grp_start);\n+      old_succs.quick_push (OMP_CLAUSE_CHAIN (grp->grp_end));\n+    }\n+\n+  /* And similarly, the heads of the groups in the order we want to rearrange\n+     the list to.  */\n+  for (omp_mapping_group *w = head; w; w = w->next)\n+    new_heads.quick_push (*w->grp_start);\n+\n+  FOR_EACH_VEC_ELT (*groups, i, grp)\n+    {\n+      gcc_assert (head);\n+\n+      if (new_grp_tail && old_succs[i - 1] == old_heads[i])\n+\t{\n+\t  /* a {b c d} {e f g} h i j   (original)\n+\t     -->\n+\t     a {k l m} {e f g} h i j   (inserted new group on last iter)\n+\t     -->\n+\t     a {k l m} {n o p} h i j   (this time, chain last group to new one)\n+\t\t      ^new_grp_tail\n+\t  */\n+\t  *new_grp_tail = new_heads[i];\n+\t}\n+      else if (new_grp_tail)\n+\t{\n+\t  /* a {b c d} e {f g h} i j k   (original)\n+\t     -->\n+\t     a {l m n} e {f g h} i j k   (gap after last iter's group)\n+\t     -->\n+\t     a {l m n} e {o p q} h i j   (chain last group to old successor)\n+\t\t      ^new_grp_tail\n+\t   */\n+\t  *new_grp_tail = old_succs[i - 1];\n+\t  *old_headps[i] = new_heads[i];\n+\t}\n+      else\n+\t{\n+\t  /* The first inserted group -- point to new group, and leave end\n+\t     open.\n+\t     a {b c d} e f\n+\t     -->\n+\t     a {g h i...\n+\t  */\n+\t  *grp->grp_start = new_heads[i];\n+\t}\n+\n+      new_grp_tail = &OMP_CLAUSE_CHAIN (head->grp_end);\n+\n+      head = head->next;\n+    }\n+\n+  if (new_grp_tail)\n+    *new_grp_tail = old_succs[numgroups - 1];\n+\n+  gcc_assert (!head);\n+\n+  return map_at_start ? (*groups)[0].grp_start : list_p;\n }\n \n /* DECL is supposed to have lastprivate semantics in the outer contexts\n@@ -9267,11 +9800,29 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \tbreak;\n       }\n \n-  if (code == OMP_TARGET\n-      || code == OMP_TARGET_DATA\n-      || code == OMP_TARGET_ENTER_DATA\n-      || code == OMP_TARGET_EXIT_DATA)\n-    omp_target_reorder_clauses (list_p);\n+  /* Topological sorting may fail if we have duplicate nodes, which\n+     we should have detected and shown an error for already.  Skip\n+     sorting in that case.  */\n+  if (!seen_error ()\n+      && (code == OMP_TARGET\n+\t  || code == OMP_TARGET_DATA\n+\t  || code == OMP_TARGET_ENTER_DATA\n+\t  || code == OMP_TARGET_EXIT_DATA))\n+    {\n+      vec<omp_mapping_group> *groups;\n+      groups = omp_gather_mapping_groups (list_p);\n+      if (groups)\n+\t{\n+\t  hash_map<tree_operand_hash, omp_mapping_group *> *grpmap;\n+\t  grpmap = omp_index_mapping_groups (groups);\n+\t  omp_mapping_group *outlist\n+\t    = omp_tsort_mapping_groups (groups, grpmap);\n+\t  outlist = omp_segregate_mapping_groups (outlist);\n+\t  list_p = omp_reorder_mapping_groups (groups, outlist, list_p);\n+\t  delete grpmap;\n+\t  delete groups;\n+\t}\n+    }\n \n   while ((c = *list_p) != NULL)\n     {"}, {"sha": "d89d16de88c39acca5272e54343cffa44f7c1d46", "filename": "gcc/omp-low.cc", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b57abd072dd319a72839a49e769bffc244a52bc0/gcc%2Fomp-low.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b57abd072dd319a72839a49e769bffc244a52bc0/gcc%2Fomp-low.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.cc?ref=b57abd072dd319a72839a49e769bffc244a52bc0", "patch": "@@ -1599,8 +1599,11 @@ scan_sharing_clauses (tree clauses, omp_context *ctx)\n \t    {\n \t      /* If this is an offloaded region, an attach operation should\n \t\t only exist when the pointer variable is mapped in a prior\n-\t\t clause.  */\n-\t      if (is_gimple_omp_offloaded (ctx->stmt))\n+\t\t clause.\n+\t\t If we had an error, we may not have attempted to sort clauses\n+\t\t properly, so avoid the test.  */\n+\t      if (is_gimple_omp_offloaded (ctx->stmt)\n+\t\t  && !seen_error ())\n \t\tgcc_assert\n \t\t  (maybe_lookup_decl (decl, ctx)\n \t\t   || (is_global_var (maybe_lookup_decl_in_outer_ctx (decl, ctx))"}, {"sha": "279dab1d8e8be12decc0753a809a40a8b1f480cd", "filename": "gcc/testsuite/g++.dg/gomp/target-lambda-1.C", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b57abd072dd319a72839a49e769bffc244a52bc0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftarget-lambda-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b57abd072dd319a72839a49e769bffc244a52bc0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftarget-lambda-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftarget-lambda-1.C?ref=b57abd072dd319a72839a49e769bffc244a52bc0", "patch": "@@ -87,8 +87,9 @@ int main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump {#pragma omp target num_teams.* firstprivate\\(b\\) map\\(alloc:MEM.* \\[len: 0\\]\\) map\\(firstprivate:iptr \\[pointer assign, bias: 0\\]\\) map\\(alloc:MEM.* \\[len: 0\\]\\) map\\(firstprivate:this \\[pointer assign, bias: 0\\]\\) map\\(to:\\*__closure \\[len: [0-9]+\\]\\) map\\(firstprivate:__closure \\[pointer assign, bias: 0\\]\\) map\\(tofrom:\\*_[0-9]+ \\[len: [0-9]+\\]\\) map\\(always_pointer:__closure->__this \\[pointer assign, bias: 0\\]\\) map\\(attach_zero_length_array_section:__closure->__iptr \\[bias: 0\\]\\) map\\(attach_zero_length_array_section:_[0-9]+->ptr \\[bias: 0\\]\\) map\\(from:mapped \\[len: [0-9]+\\]\\) map\\(alloc:\\*_[0-9]+ \\[len: 0\\]\\) map\\(alloc:\\*_[0-9]+ \\[len: 0\\]\\)} \"gimple\" } } */\n+/* { dg-final { scan-tree-dump {#pragma omp target num_teams.* firstprivate\\(b\\) map\\(alloc:MEM.* \\[len: 0\\]\\) map\\(firstprivate:iptr \\[pointer assign, bias: 0\\]\\) map\\(alloc:MEM.* \\[len: 0\\]\\) map\\(firstprivate:this \\[pointer assign, bias: 0\\]\\) map\\(to:\\*__closure \\[len: [0-9]+\\]\\) map\\(firstprivate:__closure \\[pointer assign, bias: 0\\]\\) map\\(tofrom:\\*_[0-9]+ \\[len: [0-9]+\\]\\) map\\(always_pointer:__closure->__this \\[pointer assign, bias: 0\\]\\) map\\(from:mapped \\[len: [0-9]+\\]\\) map\\(alloc:\\*_[0-9]+ \\[len: 0\\]\\) map\\(attach_zero_length_array_section:__closure->__iptr \\[bias: 0\\]\\) map\\(alloc:\\*_[0-9]+ \\[len: 0\\]\\) map\\(attach_zero_length_array_section:_[0-9]+->ptr \\[bias: 0\\]\\) \n+} \"gimple\" } } */\n \n-/* { dg-final { scan-tree-dump {#pragma omp target num_teams.* firstprivate\\(end\\) firstprivate\\(begin\\) map\\(to:loop \\[len: [0-9]+\\]\\) map\\(attach_zero_length_array_section:loop\\.__data1 \\[bias: 0\\]\\) map\\(alloc:\\*_[0-9]+ \\[len: 0\\]\\)} \"gimple\" } } */\n+/* { dg-final { scan-tree-dump {#pragma omp target num_teams.* firstprivate\\(end\\) firstprivate\\(begin\\) map\\(to:loop \\[len: [0-9]+\\]\\) map\\(alloc:\\*_[0-9]+ \\[len: 0\\]\\) map\\(attach_zero_length_array_section:loop\\.__data1 \\[bias: 0\\]\\)} \"gimple\" } } */\n \n-/* { dg-final { scan-tree-dump {#pragma omp target num_teams.* firstprivate\\(end\\) firstprivate\\(begin\\) map\\(to:loop \\[len: [0-9]+\\]\\) map\\(attach_zero_length_array_section:loop\\.__data2 \\[bias: 0\\]\\) map\\(alloc:\\*_[0-9]+ \\[len: 0\\]\\)} \"gimple\" } } */\n+/* { dg-final { scan-tree-dump {#pragma omp target num_teams.* firstprivate\\(end\\) firstprivate\\(begin\\) map\\(to:loop \\[len: [0-9]+\\]\\) map\\(alloc:\\*_[0-9]+ \\[len: 0\\]\\) map\\(attach_zero_length_array_section:loop\\.__data2 \\[bias: 0\\]\\)} \"gimple\" } } */"}, {"sha": "bc2cc0b297dcb07317a39c09ec7831c717b10cf1", "filename": "gcc/testsuite/g++.dg/gomp/target-this-3.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b57abd072dd319a72839a49e769bffc244a52bc0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftarget-this-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b57abd072dd319a72839a49e769bffc244a52bc0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftarget-this-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftarget-this-3.C?ref=b57abd072dd319a72839a49e769bffc244a52bc0", "patch": "@@ -100,6 +100,6 @@ int main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump {#pragma omp target num_teams.* map\\(alloc:MEM.* \\[len: 0\\]\\) map\\(firstprivate:this \\[pointer assign, bias: 0\\]\\) firstprivate\\(n\\) map\\(tofrom:\\*this \\[len: [0-9]+\\]\\) map\\(firstprivate:this \\[pointer assign, bias: 0\\]\\) map\\(alloc:\\*_[0-9]+ \\[pointer assign, zero-length array section, bias: 0\\]\\) map\\(attach:this->refptr \\[bias: 0\\]\\) map\\(from:mapped \\[len: [0-9]+\\]\\)} \"gimple\" } } */\n+/* { dg-final { scan-tree-dump {#pragma omp target num_teams.* firstprivate\\(n\\) map\\(tofrom:\\*this \\[len: [0-9]+\\]\\) map\\(firstprivate:this \\[pointer assign, bias: 0\\]\\) map\\(from:mapped \\[len: [0-9]+\\]\\) map\\(alloc:\\*_[0-9+] \\[len: 0\\]\\) map\\(alloc:\\*_[0-9]+ \\[pointer assign, zero-length array section, bias: 0\\]\\) map\\(attach:this->refptr \\[bias: 0\\]\\)} \"gimple\" } } */\n \n-/* { dg-final { scan-tree-dump {#pragma omp target num_teams.* map\\(alloc:MEM.* \\[len: 0\\]\\) map\\(firstprivate:this \\[pointer assign, bias: 0\\]\\) firstprivate\\(n\\) map\\(tofrom:\\*this \\[len: [0-9]+\\]\\) map\\(firstprivate:this \\[pointer assign, bias: 0\\]\\) map\\(attach_zero_length_array_section:this->ptr \\[bias: 0\\]\\) map\\(from:mapped \\[len: [0-9]+\\]\\) map\\(alloc:\\*_[0-9]+ \\[len: 0\\]\\)} \"gimple\" } } */\n+/* { dg-final { scan-tree-dump {#pragma omp target num_teams.* firstprivate\\(n\\) map\\(tofrom:\\*this \\[len: [0-9]+\\]\\) map\\(firstprivate:this \\[pointer assign, bias: 0\\]\\) map\\(from:mapped \\[len: [0-9]+\\]\\) map\\(alloc:\\*_[0-9]+ \\[len: 0\\]\\) map\\(attach_zero_length_array_section:this->ptr \\[bias: 0\\]\\)} \"gimple\" } } */"}, {"sha": "9ade3cc0b2b12e9a02820862ef2ce9d5f9c2c351", "filename": "gcc/testsuite/g++.dg/gomp/target-this-4.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b57abd072dd319a72839a49e769bffc244a52bc0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftarget-this-4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b57abd072dd319a72839a49e769bffc244a52bc0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftarget-this-4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftarget-this-4.C?ref=b57abd072dd319a72839a49e769bffc244a52bc0", "patch": "@@ -102,6 +102,6 @@ int main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump {#pragma omp target num_teams.* firstprivate\\(n\\) map\\(alloc:MEM.* \\[len: 0\\]\\) map\\(firstprivate:this \\[pointer assign, bias: 0\\]\\) map\\(to:\\*__closure \\[len: [0-9]+\\]\\) map\\(firstprivate:__closure \\[pointer assign, bias: 0\\]\\) map\\(tofrom:\\*_[0-9]+ \\[len: [0-9]+\\]\\) map\\(always_pointer:__closure->__this \\[pointer assign, bias: 0\\]\\) map\\(attach_zero_length_array_section:_[0-9]+->ptr \\[bias: 0\\]\\) map\\(from:mapped \\[len: [0-9]+\\]\\) map\\(alloc:\\*_[0-9]+ \\[len: 0\\]\\)} \"gimple\" } } */\n+/* { dg-final { scan-tree-dump {#pragma omp target num_teams.* firstprivate\\(n\\) map\\(alloc:MEM.* \\[len: 0\\]\\) map\\(firstprivate:this \\[pointer assign, bias: 0\\]\\) map\\(to:\\*__closure \\[len: [0-9]+\\]\\) map\\(firstprivate:__closure \\[pointer assign, bias: 0\\]\\) map\\(tofrom:\\*_[0-9]+ \\[len: [0-9]+\\]\\) map\\(always_pointer:__closure->__this \\[pointer assign, bias: 0\\]\\) map\\(from:mapped \\[len: 1\\]\\) map\\(alloc:\\*_[0-9]+ \\[len: 0\\]\\) map\\(attach_zero_length_array_section:_[0-9]+->ptr \\[bias: 0\\]\\)} \"gimple\" } } */\n \n-/* { dg-final { scan-tree-dump {#pragma omp target num_teams.* firstprivate\\(n\\) map\\(alloc:MEM.* \\[len: 0\\]\\) map\\(firstprivate:this \\[pointer assign, bias: 0\\]\\) map\\(to:\\*__closure \\[len: [0-9]+\\]\\) map\\(firstprivate:__closure \\[pointer assign, bias: 0\\]\\) map\\(tofrom:\\*_[0-9]+ \\[len: [0-9]+\\]\\) map\\(always_pointer:__closure->__this \\[pointer assign, bias: 0\\]\\) map\\(alloc:\\*_[0-9]+ \\[pointer assign, zero-length array section, bias: 0\\]\\) map\\(attach:_[0-9]+->refptr \\[bias: 0\\]\\) map\\(from:mapped \\[len: [0-9]+\\]\\) map\\(alloc:\\*_[0-9]+ \\[len: 0\\]\\)} \"gimple\" } } */\n+/* { dg-final { scan-tree-dump {#pragma omp target num_teams.* firstprivate\\(n\\) map\\(alloc:MEM.* \\[len: 0\\]\\) map\\(firstprivate:this \\[pointer assign, bias: 0\\]\\) map\\(to:\\*__closure \\[len: [0-9]+\\]\\) map\\(firstprivate:__closure \\[pointer assign, bias: 0\\]\\) map\\(tofrom:\\*_[0-9]+ \\[len: [0-9]+\\]\\) map\\(always_pointer:__closure->__this \\[pointer assign, bias: 0\\]\\) map\\(from:mapped \\[len: [0-9]+\\]\\) map\\(alloc:\\*_[0-9]+ \\[len: 0\\]\\) map\\(alloc:\\*_[0-9]+ \\[pointer assign, zero-length array section, bias: 0\\]\\) map\\(attach:_[0-9]+->refptr \\[bias: 0\\]\\)} \"gimple\" } } */"}]}