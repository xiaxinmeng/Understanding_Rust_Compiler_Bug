{"sha": "6fac31b418c9bbceaaab53ef8e4be166609bda4a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmZhYzMxYjQxOGM5YmJjZWFhYWI1M2VmOGU0YmUxNjY2MDliZGE0YQ==", "commit": {"author": {"name": "Pat Haugen", "email": "pthaugen@us.ibm.com", "date": "2012-05-24T20:28:31Z"}, "committer": {"name": "Pat Haugen", "email": "pthaugen@gcc.gnu.org", "date": "2012-05-24T20:28:31Z"}, "message": "rs6000.c (rs6000_option_override_internal): Change rs6000_sched_costly_dep default to true_store_to_load_dep_costly.\n\n\t* config/rs6000/rs6000.c (rs6000_option_override_internal): Change\n\trs6000_sched_costly_dep default to true_store_to_load_dep_costly.\n\t(adjacent_mem_locations): Move some code to and call...\n\t(get_memref_parts): ...new function.\n\t(mem_locations_overlap): New function.\n\t(rs6000_adjust_priority): Adjust calls to is_load_insn/is_store_insn.\n\t(is_mem_ref): Rename to...\n\t(find_mem_ref): ...this. Return MEM rtx.\n\t(get_store_dest): Remove function.\n\t(is_load_insn1, is_load_insn, is_store_insn1, is_store_insn): Add\n\tnew parameter and adjust calls.\n\t(rs6000_is_costly_dependence): Update calls for extra arg. Make sure\n\tmem refs overlap for true_store_to_load_dep_costly.\n\t(rs6000_sched_reorder2): Update calls for extra arg. Adjust args\n\tpassed to adjacent_mem_locations.\n\t(is_costly_group): Walk resolved dependency list.\n\t(force_new_group): Emit group ending nop for Power6/Power7.\n\t* config/rs6000/rs6000.md (UNSPEC_GRP_END_NOP): New enum value.\n\t(group_ending_nop): New define_insn.\n\n\t* gcc.target/powerpc/lhs-1.c: New.\n\t* gcc.target/powerpc/lhs-2.c: New.\n\t* gcc.target/powerpc/lhs-3.c: New.\n\nFrom-SVN: r187847", "tree": {"sha": "0edf8b30773e1336118e8883a755f2b1991ad2c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0edf8b30773e1336118e8883a755f2b1991ad2c5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6fac31b418c9bbceaaab53ef8e4be166609bda4a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6fac31b418c9bbceaaab53ef8e4be166609bda4a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6fac31b418c9bbceaaab53ef8e4be166609bda4a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6fac31b418c9bbceaaab53ef8e4be166609bda4a/comments", "author": null, "committer": null, "parents": [{"sha": "44813fe0436d2ad3ef79fcaee52b78f0bddc23e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44813fe0436d2ad3ef79fcaee52b78f0bddc23e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/44813fe0436d2ad3ef79fcaee52b78f0bddc23e3"}], "stats": {"total": 327, "additions": 226, "deletions": 101}, "files": [{"sha": "d810212dffec15378fe9df62c9bf9c1ed0eb249d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fac31b418c9bbceaaab53ef8e4be166609bda4a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fac31b418c9bbceaaab53ef8e4be166609bda4a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6fac31b418c9bbceaaab53ef8e4be166609bda4a", "patch": "@@ -1,3 +1,25 @@\n+2012-05-24  Pat Haugen <pthaugen@us.ibm.com>\n+\n+\t* config/rs6000/rs6000.c (rs6000_option_override_internal): Change\n+\trs6000_sched_costly_dep default to true_store_to_load_dep_costly.\n+\t(adjacent_mem_locations): Move some code to and call...\n+\t(get_memref_parts): ...new function.\n+\t(mem_locations_overlap): New function.\n+\t(rs6000_adjust_priority): Adjust calls to is_load_insn/is_store_insn.\n+\t(is_mem_ref): Rename to...\n+\t(find_mem_ref): ...this. Return MEM rtx.\n+\t(get_store_dest): Remove function.\n+\t(is_load_insn1, is_load_insn, is_store_insn1, is_store_insn): Add\n+\tnew parameter and adjust calls.\n+\t(rs6000_is_costly_dependence): Update calls for extra arg. Make sure\n+\tmem refs overlap for true_store_to_load_dep_costly.\n+\t(rs6000_sched_reorder2): Update calls for extra arg. Adjust args\n+\tpassed to adjacent_mem_locations.\n+\t(is_costly_group): Walk resolved dependency list.\n+\t(force_new_group): Emit group ending nop for Power6/Power7.\n+\t* config/rs6000/rs6000.md (UNSPEC_GRP_END_NOP): New enum value.\n+\t(group_ending_nop): New define_insn.\n+\n 2012-05-24  Dodji Seketeli  <dodji@redhat.com>\n \n \tMake unwound macro expansion trace less redundant"}, {"sha": "d7cb49db2d8e895a67f86dd32496969b81d38a41", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 124, "deletions": 101, "changes": 225, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fac31b418c9bbceaaab53ef8e4be166609bda4a/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fac31b418c9bbceaaab53ef8e4be166609bda4a/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=6fac31b418c9bbceaaab53ef8e4be166609bda4a", "patch": "@@ -936,9 +936,8 @@ static int rs6000_debug_adjust_cost (rtx, rtx, rtx, int);\n static bool is_microcoded_insn (rtx);\n static bool is_nonpipeline_insn (rtx);\n static bool is_cracked_insn (rtx);\n-static bool is_load_insn (rtx);\n-static rtx get_store_dest (rtx pat);\n-static bool is_store_insn (rtx);\n+static bool is_load_insn (rtx, rtx *);\n+static bool is_store_insn (rtx, rtx *);\n static bool set_to_load_agen (rtx,rtx);\n static bool insn_terminates_group_p (rtx , enum group_termination);\n static bool insn_must_be_first_in_group (rtx);\n@@ -2831,7 +2830,7 @@ rs6000_option_override_internal (bool global_init_p)\n \n   /* Handle -msched-costly-dep option.  */\n   rs6000_sched_costly_dep\n-    = (rs6000_sched_groups ? store_to_load_dep_costly : no_dep_costly);\n+    = (rs6000_sched_groups ? true_store_to_load_dep_costly : no_dep_costly);\n \n   if (rs6000_sched_costly_dep_str)\n     {\n@@ -22786,49 +22785,78 @@ set_to_load_agen (rtx out_insn, rtx in_insn)\n   return false;\n }\n \n-/* The function returns true if the target storage location of\n-   out_insn is adjacent to the target storage location of in_insn */\n-/* Return 1 if memory locations are adjacent.  */\n+/* Try to determine base/offset/size parts of the given MEM.\n+   Return true if successful, false if all the values couldn't\n+   be determined.\n+\n+   This function only looks for REG or REG+CONST address forms.\n+   REG+REG address form will return false. */\n \n static bool\n-adjacent_mem_locations (rtx insn1, rtx insn2)\n+get_memref_parts (rtx mem, rtx *base, HOST_WIDE_INT *offset,\n+\t\t  HOST_WIDE_INT *size)\n {\n+  rtx addr_rtx;\n+  if MEM_SIZE_KNOWN_P (mem)\n+    *size = MEM_SIZE (mem);\n+  else\n+    return false;\n \n-  rtx a = get_store_dest (PATTERN (insn1));\n-  rtx b = get_store_dest (PATTERN (insn2));\n+  if (GET_CODE (XEXP (mem, 0)) == PRE_MODIFY)\n+    addr_rtx = XEXP (XEXP (mem, 0), 1);\n+  else\n+    addr_rtx = (XEXP (mem, 0));\n \n-  if ((GET_CODE (XEXP (a, 0)) == REG\n-       || (GET_CODE (XEXP (a, 0)) == PLUS\n-\t   && GET_CODE (XEXP (XEXP (a, 0), 1)) == CONST_INT))\n-      && (GET_CODE (XEXP (b, 0)) == REG\n-\t  || (GET_CODE (XEXP (b, 0)) == PLUS\n-\t      && GET_CODE (XEXP (XEXP (b, 0), 1)) == CONST_INT)))\n+  if (GET_CODE (addr_rtx) == REG)\n+    {\n+      *base = addr_rtx;\n+      *offset = 0;\n+    }\n+  else if (GET_CODE (addr_rtx) == PLUS\n+\t   && CONST_INT_P (XEXP (addr_rtx, 1)))\n     {\n-      HOST_WIDE_INT val0 = 0, val1 = 0, val_diff;\n-      rtx reg0, reg1;\n+      *base = XEXP (addr_rtx, 0);\n+      *offset = INTVAL (XEXP (addr_rtx, 1));\n+    }\n+  else\n+    return false;\n \n-      if (GET_CODE (XEXP (a, 0)) == PLUS)\n-        {\n-\t  reg0 = XEXP (XEXP (a, 0), 0);\n-\t  val0 = INTVAL (XEXP (XEXP (a, 0), 1));\n-        }\n-      else\n-\treg0 = XEXP (a, 0);\n+  return true;\n+}\n \n-      if (GET_CODE (XEXP (b, 0)) == PLUS)\n-        {\n-\t  reg1 = XEXP (XEXP (b, 0), 0);\n-\t  val1 = INTVAL (XEXP (XEXP (b, 0), 1));\n-        }\n-      else\n-\treg1 = XEXP (b, 0);\n+/* The function returns true if the target storage location of\n+   mem1 is adjacent to the target storage location of mem2 */\n+/* Return 1 if memory locations are adjacent.  */\n \n-      val_diff = val1 - val0;\n+static bool\n+adjacent_mem_locations (rtx mem1, rtx mem2)\n+{\n+  rtx reg1, reg2;\n+  HOST_WIDE_INT off1, size1, off2, size2;\n \n-      return ((REGNO (reg0) == REGNO (reg1))\n-\t      && ((MEM_SIZE_KNOWN_P (a) && val_diff == MEM_SIZE (a))\n-\t\t  || (MEM_SIZE_KNOWN_P (b) && val_diff == -MEM_SIZE (b))));\n-    }\n+  if (get_memref_parts (mem1, &reg1, &off1, &size1)\n+      && get_memref_parts (mem2, &reg2, &off2, &size2))\n+    return ((REGNO (reg1) == REGNO (reg2))\n+\t    && ((off1 + size1 == off2)\n+\t\t|| (off2 + size2 == off1)));\n+\n+  return false;\n+}\n+\n+/* This function returns true if it can be determined that the two MEM\n+   locations overlap by at least 1 byte based on base reg/offset/size. */\n+\n+static bool\n+mem_locations_overlap (rtx mem1, rtx mem2)\n+{\n+  rtx reg1, reg2;\n+  HOST_WIDE_INT off1, size1, off2, size2;\n+\n+  if (get_memref_parts (mem1, &reg1, &off1, &size1)\n+      && get_memref_parts (mem2, &reg2, &off2, &size2))\n+    return ((REGNO (reg1) == REGNO (reg2))\n+\t    && (((off1 <= off2) && (off1 + size1 > off2))\n+\t\t|| ((off2 <= off1) && (off2 + size2 > off1))));\n \n   return false;\n }\n@@ -22842,6 +22870,7 @@ adjacent_mem_locations (rtx insn1, rtx insn2)\n static int\n rs6000_adjust_priority (rtx insn ATTRIBUTE_UNUSED, int priority)\n {\n+  rtx load_mem, str_mem;\n   /* On machines (like the 750) which have asymmetric integer units,\n      where one integer unit can do multiply and divides and the other\n      can't, reduce the priority of multiply/divide so it is scheduled\n@@ -22893,8 +22922,8 @@ rs6000_adjust_priority (rtx insn ATTRIBUTE_UNUSED, int priority)\n     }\n \n   if (rs6000_cpu == PROCESSOR_POWER6\n-      && ((load_store_pendulum == -2 && is_load_insn (insn))\n-          || (load_store_pendulum == 2 && is_store_insn (insn))))\n+      && ((load_store_pendulum == -2 && is_load_insn (insn, &load_mem))\n+          || (load_store_pendulum == 2 && is_store_insn (insn, &str_mem))))\n     /* Attach highest priority to insn if the scheduler has just issued two\n        stores and this instruction is a load, or two loads and this instruction\n        is a store. Power6 wants loads and stores scheduled alternately\n@@ -23019,54 +23048,63 @@ rs6000_use_sched_lookahead_guard (rtx insn)\n   return 1;\n }\n \n-/* Determine is PAT refers to memory.  */\n+/* Determine if PAT refers to memory. If so, set MEM_REF to the MEM rtx\n+   and return true.  */\n \n static bool\n-is_mem_ref (rtx pat)\n+find_mem_ref (rtx pat, rtx *mem_ref)\n {\n   const char * fmt;\n   int i, j;\n-  bool ret = false;\n \n   /* stack_tie does not produce any real memory traffic.  */\n   if (tie_operand (pat, VOIDmode))\n     return false;\n \n   if (GET_CODE (pat) == MEM)\n-    return true;\n+    {\n+      *mem_ref = pat;\n+      return true;\n+    }\n \n   /* Recursively process the pattern.  */\n   fmt = GET_RTX_FORMAT (GET_CODE (pat));\n \n-  for (i = GET_RTX_LENGTH (GET_CODE (pat)) - 1; i >= 0 && !ret; i--)\n+  for (i = GET_RTX_LENGTH (GET_CODE (pat)) - 1; i >= 0; i--)\n     {\n       if (fmt[i] == 'e')\n-\tret |= is_mem_ref (XEXP (pat, i));\n+\t{\n+\t  if (find_mem_ref (XEXP (pat, i), mem_ref))\n+\t    return true;\n+\t}\n       else if (fmt[i] == 'E')\n \tfor (j = XVECLEN (pat, i) - 1; j >= 0; j--)\n-\t  ret |= is_mem_ref (XVECEXP (pat, i, j));\n+\t  {\n+\t    if (find_mem_ref (XVECEXP (pat, i, j), mem_ref))\n+\t      return true;\n+\t  }\n     }\n \n-  return ret;\n+  return false;\n }\n \n /* Determine if PAT is a PATTERN of a load insn.  */\n \n static bool\n-is_load_insn1 (rtx pat)\n+is_load_insn1 (rtx pat, rtx *load_mem)\n {\n   if (!pat || pat == NULL_RTX)\n     return false;\n \n   if (GET_CODE (pat) == SET)\n-    return is_mem_ref (SET_SRC (pat));\n+    return find_mem_ref (SET_SRC (pat), load_mem);\n \n   if (GET_CODE (pat) == PARALLEL)\n     {\n       int i;\n \n       for (i = 0; i < XVECLEN (pat, 0); i++)\n-\tif (is_load_insn1 (XVECEXP (pat, 0, i)))\n+\tif (is_load_insn1 (XVECEXP (pat, 0, i), load_mem))\n \t  return true;\n     }\n \n@@ -23076,34 +23114,34 @@ is_load_insn1 (rtx pat)\n /* Determine if INSN loads from memory.  */\n \n static bool\n-is_load_insn (rtx insn)\n+is_load_insn (rtx insn, rtx *load_mem)\n {\n   if (!insn || !INSN_P (insn))\n     return false;\n \n   if (GET_CODE (insn) == CALL_INSN)\n     return false;\n \n-  return is_load_insn1 (PATTERN (insn));\n+  return is_load_insn1 (PATTERN (insn), load_mem);\n }\n \n /* Determine if PAT is a PATTERN of a store insn.  */\n \n static bool\n-is_store_insn1 (rtx pat)\n+is_store_insn1 (rtx pat, rtx *str_mem)\n {\n   if (!pat || pat == NULL_RTX)\n     return false;\n \n   if (GET_CODE (pat) == SET)\n-    return is_mem_ref (SET_DEST (pat));\n+    return find_mem_ref (SET_DEST (pat), str_mem);\n \n   if (GET_CODE (pat) == PARALLEL)\n     {\n       int i;\n \n       for (i = 0; i < XVECLEN (pat, 0); i++)\n-\tif (is_store_insn1 (XVECEXP (pat, 0, i)))\n+\tif (is_store_insn1 (XVECEXP (pat, 0, i), str_mem))\n \t  return true;\n     }\n \n@@ -23113,38 +23151,12 @@ is_store_insn1 (rtx pat)\n /* Determine if INSN stores to memory.  */\n \n static bool\n-is_store_insn (rtx insn)\n+is_store_insn (rtx insn, rtx *str_mem)\n {\n   if (!insn || !INSN_P (insn))\n     return false;\n \n-  return is_store_insn1 (PATTERN (insn));\n-}\n-\n-/* Return the dest of a store insn.  */\n-\n-static rtx\n-get_store_dest (rtx pat)\n-{\n-  gcc_assert (is_store_insn1 (pat));\n-\n-  if (GET_CODE (pat) == SET)\n-    return SET_DEST (pat);\n-  else if (GET_CODE (pat) == PARALLEL)\n-    {\n-      int i;\n-\n-      for (i = 0; i < XVECLEN (pat, 0); i++)\n-\t{\n-\t  rtx inner_pat = XVECEXP (pat, 0, i);\n-\t  if (GET_CODE (inner_pat) == SET\n-\t      && is_mem_ref (SET_DEST (inner_pat)))\n-\t    return inner_pat;\n-\t}\n-    }\n-  /* We shouldn't get here, because we should have either a simple\n-     store insn or a store with update which are covered above.  */\n-  gcc_unreachable();\n+  return is_store_insn1 (PATTERN (insn), str_mem);\n }\n \n /* Returns whether the dependence between INSN and NEXT is considered\n@@ -23155,6 +23167,7 @@ rs6000_is_costly_dependence (dep_t dep, int cost, int distance)\n {\n   rtx insn;\n   rtx next;\n+  rtx load_mem, str_mem;\n \n   /* If the flag is not enabled - no dependence is considered costly;\n      allow all dependent insns in the same group.\n@@ -23172,15 +23185,16 @@ rs6000_is_costly_dependence (dep_t dep, int cost, int distance)\n   next = DEP_CON (dep);\n \n   if (rs6000_sched_costly_dep == store_to_load_dep_costly\n-      && is_load_insn (next)\n-      && is_store_insn (insn))\n+      && is_load_insn (next, &load_mem)\n+      && is_store_insn (insn, &str_mem))\n     /* Prevent load after store in the same group.  */\n     return true;\n \n   if (rs6000_sched_costly_dep == true_store_to_load_dep_costly\n-      && is_load_insn (next)\n-      && is_store_insn (insn)\n-      && DEP_TYPE (dep) == REG_DEP_TRUE)\n+      && is_load_insn (next, &load_mem)\n+      && is_store_insn (insn, &str_mem)\n+      && DEP_TYPE (dep) == REG_DEP_TRUE\n+      && mem_locations_overlap(str_mem, load_mem))\n      /* Prevent load after store in the same group if it is a true\n \tdependence.  */\n      return true;\n@@ -23307,12 +23321,12 @@ rs6000_sched_reorder2 (FILE *dump, int sched_verbose, rtx *ready,\n     {\n       int pos;\n       int i;\n-      rtx tmp;\n+      rtx tmp, load_mem, str_mem;\n \n-      if (is_store_insn (last_scheduled_insn))\n+      if (is_store_insn (last_scheduled_insn, &str_mem))\n         /* Issuing a store, swing the load_store_pendulum to the left */\n         load_store_pendulum--;\n-      else if (is_load_insn (last_scheduled_insn))\n+      else if (is_load_insn (last_scheduled_insn, &load_mem))\n         /* Issuing a load, swing the load_store_pendulum to the right */\n         load_store_pendulum++;\n       else\n@@ -23331,7 +23345,7 @@ rs6000_sched_reorder2 (FILE *dump, int sched_verbose, rtx *ready,\n \n           while (pos >= 0)\n             {\n-              if (is_load_insn (ready[pos]))\n+              if (is_load_insn (ready[pos], &load_mem))\n                 {\n                   /* Found a load.  Move it to the head of the ready list,\n                      and adjust it's priority so that it is more likely to\n@@ -23357,7 +23371,7 @@ rs6000_sched_reorder2 (FILE *dump, int sched_verbose, rtx *ready,\n \n           while (pos >= 0)\n             {\n-              if (is_load_insn (ready[pos])\n+              if (is_load_insn (ready[pos], &load_mem)\n                   && !sel_sched_p ()\n \t\t  && INSN_PRIORITY_KNOWN (ready[pos]))\n                 {\n@@ -23384,15 +23398,16 @@ rs6000_sched_reorder2 (FILE *dump, int sched_verbose, rtx *ready,\n \n           while (pos >= 0)\n             {\n-              if (is_store_insn (ready[pos]))\n+              if (is_store_insn (ready[pos], &str_mem))\n                 {\n+\t\t  rtx str_mem2;\n                   /* Maintain the index of the first store found on the\n                      list */\n                   if (first_store_pos == -1)\n                     first_store_pos = pos;\n \n-                  if (is_store_insn (last_scheduled_insn)\n-                      && adjacent_mem_locations (last_scheduled_insn,ready[pos]))\n+                  if (is_store_insn (last_scheduled_insn, &str_mem2)\n+                      && adjacent_mem_locations (str_mem, str_mem2))\n                     {\n                       /* Found an adjacent store.  Move it to the head of the\n                          ready list, and adjust it's priority so that it is\n@@ -23436,7 +23451,7 @@ rs6000_sched_reorder2 (FILE *dump, int sched_verbose, rtx *ready,\n \n           while (pos >= 0)\n             {\n-              if (is_store_insn (ready[pos])\n+              if (is_store_insn (ready[pos], &str_mem)\n                   && !sel_sched_p ()\n \t\t  && INSN_PRIORITY_KNOWN (ready[pos]))\n                 {\n@@ -23720,7 +23735,7 @@ is_costly_group (rtx *group_insns, rtx next_insn)\n       if (!insn)\n \tcontinue;\n \n-      FOR_EACH_DEP (insn, SD_LIST_FORW, sd_it, dep)\n+      FOR_EACH_DEP (insn, SD_LIST_RES_FORW, sd_it, dep)\n \t{\n \t  rtx next = DEP_CON (dep);\n \n@@ -23784,12 +23799,20 @@ force_new_group (int sched_verbose, FILE *dump, rtx *group_insns,\n       if (can_issue_more && !is_branch_slot_insn (next_insn))\n \tcan_issue_more--;\n \n-      while (can_issue_more > 0)\n+      /* Power6 and Power7 have special group ending nop. */\n+      if (rs6000_cpu_attr == CPU_POWER6 || rs6000_cpu_attr == CPU_POWER7)\n \t{\n-\t  nop = gen_nop ();\n+\t  nop = gen_group_ending_nop ();\n \t  emit_insn_before (nop, next_insn);\n-\t  can_issue_more--;\n+\t  can_issue_more = 0;\n \t}\n+      else\n+\twhile (can_issue_more > 0)\n+\t  {\n+\t    nop = gen_nop ();\n+\t    emit_insn_before (nop, next_insn);\n+\t    can_issue_more--;\n+\t  }\n \n       *group_end = true;\n       return 0;"}, {"sha": "26b2720cac84aae207390703c6493e4ec645caaf", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fac31b418c9bbceaaab53ef8e4be166609bda4a/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fac31b418c9bbceaaab53ef8e4be166609bda4a/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=6fac31b418c9bbceaaab53ef8e4be166609bda4a", "patch": "@@ -126,6 +126,7 @@\n    UNSPEC_LFIWAX\n    UNSPEC_LFIWZX\n    UNSPEC_FCTIWUZ\n+   UNSPEC_GRP_END_NOP\n   ])\n \n ;;\n@@ -15594,6 +15595,16 @@\n   [(const_int 0)]\n   \"\"\n   \"{cror 0,0,0|nop}\")\n+\n+(define_insn \"group_ending_nop\"\n+  [(unspec [(const_int 0)] UNSPEC_GRP_END_NOP)]\n+  \"\"\n+  \"*\n+{\n+  if (rs6000_cpu_attr == CPU_POWER6)\n+    return \\\"ori 1,1,0\\\";\n+  return \\\"ori 2,2,0\\\";\n+}\")\n \f\n ;; Define the subtract-one-and-jump insns, starting with the template\n ;; so loop.c knows what to generate."}, {"sha": "fc3ac5c639cd6b59644ad50c1d10e567eaaa2450", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fac31b418c9bbceaaab53ef8e4be166609bda4a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fac31b418c9bbceaaab53ef8e4be166609bda4a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6fac31b418c9bbceaaab53ef8e4be166609bda4a", "patch": "@@ -1,3 +1,8 @@\n+2012-05-24  Pat Haugen <pthaugen@us.ibm.com>\n+\t* gcc.target/powerpc/lhs-1.c: New.\n+\t* gcc.target/powerpc/lhs-2.c: New.\n+\t* gcc.target/powerpc/lhs-3.c: New.\n+\n 2012-05-24  Dodji Seketeli  <dodji@redhat.com>\n \n \tMake unwound macro expansion trace less redundant"}, {"sha": "3b606e685a9c33bf4530b6f197631fccdf111d5a", "filename": "gcc/testsuite/gcc.target/powerpc/lhs-1.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fac31b418c9bbceaaab53ef8e4be166609bda4a/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Flhs-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fac31b418c9bbceaaab53ef8e4be166609bda4a/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Flhs-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Flhs-1.c?ref=6fac31b418c9bbceaaab53ef8e4be166609bda4a", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-options \"-O2 -mcpu=power5\" } */\n+/* { dg-final { scan-assembler-times \"nop\" 3 } } */\n+\n+/* Test generation of nops in load hit store situation.  */\n+\n+typedef union {\n+  double val;\n+  struct {\n+    unsigned int w1;\n+    unsigned int w2;\n+  };\n+} words;\n+\n+unsigned int f (double d)\n+{\n+  words u;\n+  u.val = d;\n+  return u.w2;\n+}\n+"}, {"sha": "748011f8d54d6b7997832099324dd34ae06401b9", "filename": "gcc/testsuite/gcc.target/powerpc/lhs-2.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fac31b418c9bbceaaab53ef8e4be166609bda4a/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Flhs-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fac31b418c9bbceaaab53ef8e4be166609bda4a/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Flhs-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Flhs-2.c?ref=6fac31b418c9bbceaaab53ef8e4be166609bda4a", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-options \"-O2 -mcpu=power6 -msched-groups\" } */\n+/* { dg-final { scan-assembler \"ori 1,1,0\" } } */\n+\n+/* Test generation of group ending nop in load hit store situation.  */\n+typedef union {\n+  double val;\n+  struct {\n+    unsigned int w1;\n+    unsigned int w2;\n+  };\n+} words;\n+\n+unsigned int f (double d)\n+{\n+  words u;\n+  u.val = d;\n+  return u.w2;\n+}\n+"}, {"sha": "31677ed667a973d3bc7443dcdf6951a681ead6e5", "filename": "gcc/testsuite/gcc.target/powerpc/lhs-3.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6fac31b418c9bbceaaab53ef8e4be166609bda4a/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Flhs-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6fac31b418c9bbceaaab53ef8e4be166609bda4a/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Flhs-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Flhs-3.c?ref=6fac31b418c9bbceaaab53ef8e4be166609bda4a", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-options \"-O2 -mcpu=power7\" } */\n+/* { dg-final { scan-assembler \"ori 2,2,0\" } } */\n+\n+/* Test generation of group ending nop in load hit store situation.  */\n+typedef union {\n+  double val;\n+  struct {\n+    unsigned int w1;\n+    unsigned int w2;\n+  };\n+} words;\n+\n+unsigned int f (double d)\n+{\n+  words u;\n+  u.val = d;\n+  return u.w2;\n+}\n+"}]}