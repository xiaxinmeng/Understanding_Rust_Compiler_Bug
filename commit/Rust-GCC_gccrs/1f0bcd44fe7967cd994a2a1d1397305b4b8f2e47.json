{"sha": "1f0bcd44fe7967cd994a2a1d1397305b4b8f2e47", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWYwYmNkNDRmZTc5NjdjZDk5NGEyYTFkMTM5NzMwNWI0YjhmMmU0Nw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-04-25T10:46:54Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-04-25T10:46:54Z"}, "message": "sem_util.adb (New_Copy_Tree): Put back the declarations of the hash tables at library level.\n\n2017-04-25  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* sem_util.adb (New_Copy_Tree): Put back the declarations of the\n\thash tables at library level.  Reinstate the NCT_Hash_Tables_Used\n\tvariable and set it to True whenever the main hash table is\n\tpopulated.  Short- circuit the Assoc function if it is false\n\tand add associated guards.\n\nFrom-SVN: r247181", "tree": {"sha": "d01a103f4c88276b34bddae9c806c035a89bc50b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d01a103f4c88276b34bddae9c806c035a89bc50b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1f0bcd44fe7967cd994a2a1d1397305b4b8f2e47", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f0bcd44fe7967cd994a2a1d1397305b4b8f2e47", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f0bcd44fe7967cd994a2a1d1397305b4b8f2e47", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f0bcd44fe7967cd994a2a1d1397305b4b8f2e47/comments", "author": null, "committer": null, "parents": [{"sha": "62e45e3e7035eb7c668be8ec9988c57e2d4337f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62e45e3e7035eb7c668be8ec9988c57e2d4337f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/62e45e3e7035eb7c668be8ec9988c57e2d4337f9"}], "stats": {"total": 459, "additions": 275, "deletions": 184}, "files": [{"sha": "9e8581879dd49f5be83f97f0258befe1816e9ef8", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f0bcd44fe7967cd994a2a1d1397305b4b8f2e47/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f0bcd44fe7967cd994a2a1d1397305b4b8f2e47/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=1f0bcd44fe7967cd994a2a1d1397305b4b8f2e47", "patch": "@@ -1,3 +1,46 @@\n+2017-04-25  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* sem_util.adb (New_Copy_Tree): Put back the declarations of the\n+\thash tables at library level.  Reinstate the NCT_Hash_Tables_Used\n+\tvariable and set it to True whenever the main hash table is\n+\tpopulated.  Short- circuit the Assoc function if it is false\n+\tand add associated guards.\n+\n+2017-04-25  Olivier Hainque  <hainque@adacore.com>\n+\n+\t* bindgen.adb (Gen_Elab_Calls): Also update counter of lone\n+\tspecs without elaboration code that have an elaboration counter\n+\tnevertheless, e.g.  when compiled with -fpreserve-control-flow.\n+\t* sem_ch10.adb (Analyze_Compilation_Unit):\n+\tSet_Elaboration_Entity_Required when requested to preserve\n+\tcontrol flow, to ensure the unit elaboration is materialized at\n+\tbind time, resulting in the inclusion of the unit object file\n+\tin the executable closure at link time.\n+\n+2017-04-25  Pierre-Marie de Rodat  <derodat@adacore.com>\n+\n+\t* exp_dbug.adb: In Debug_Renaming_Declaration,\n+\twhen dealing with indexed component, accept to produce a renaming\n+\tsymbol when the index is an IN parameter or when it is a name\n+\tdefined in an outer scope.\n+\n+2017-04-25  Yannick Moy  <moy@adacore.com>\n+\n+\t* errout.adb (Error_Msg): Adapt continuation\n+\tmessage in instantiations and inlined bodies for info messages.\n+\n+2017-04-25  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* fname.adb (Has_Internal_Extension): Add pragma Inline.\n+\tUse direct 4-character slice comparisons.\n+\t(Has_Prefix): Add\n+\tpragma Inline.\t(Has_Suffix): Delete.\n+\t(Is_Internal_File_Name):\n+\tTest Is_Predefined_File_Name first.\n+\t(Is_Predefined_File_Name):\n+\tUse direct slice comparisons as much as possible and limit all\n+\tcomparisons to at most 8 characters.\n+\n 2017-04-25  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* checks.adb (Insert_Valid_Check): Code cleanup."}, {"sha": "8ada7c1ae3930fda0bf6d4e9e7e16c51a58fe351", "filename": "gcc/ada/bindgen.adb", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f0bcd44fe7967cd994a2a1d1397305b4b8f2e47/gcc%2Fada%2Fbindgen.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f0bcd44fe7967cd994a2a1d1397305b4b8f2e47/gcc%2Fada%2Fbindgen.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindgen.adb?ref=1f0bcd44fe7967cd994a2a1d1397305b4b8f2e47", "patch": "@@ -1117,9 +1117,13 @@ package body Bindgen is\n             then\n                --  In the case of a body with a separate spec, where the\n                --  separate spec has an elaboration entity defined, this is\n-               --  where we increment the elaboration entity if one exists\n+               --  where we increment the elaboration entity if one exists.\n \n-               if U.Utype = Is_Body\n+               --  Likewise for lone specs with an elaboration entity defined\n+               --  despite No_Elaboration_Code, e.g. when requested to\n+               --  preserve control flow.\n+\n+               if (U.Utype = Is_Body or else U.Utype = Is_Spec_Only)\n                  and then Units.Table (Unum_Spec).Set_Elab_Entity\n                  and then not CodePeer_Mode\n                then"}, {"sha": "d2c41fcb4abf97402b0a8474a8a67c216b7480e7", "filename": "gcc/ada/errout.adb", "status": "modified", "additions": 22, "deletions": 4, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f0bcd44fe7967cd994a2a1d1397305b4b8f2e47/gcc%2Fada%2Ferrout.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f0bcd44fe7967cd994a2a1d1397305b4b8f2e47/gcc%2Fada%2Ferrout.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ferrout.adb?ref=1f0bcd44fe7967cd994a2a1d1397305b4b8f2e47", "patch": "@@ -423,9 +423,14 @@ package body Errout is\n \n       --  or\n \n-      --     warning: in instantiation at\n+      --     warning: in instantiation at ...\n       --     warning: original warning message\n \n+      --  or\n+\n+      --     info: in instantiation at ...\n+      --     info: original info message\n+\n       --  All these messages are posted at the location of the top level\n       --  instantiation. If there are nested instantiations, then the\n       --  instantiation error message can be repeated, pointing to each\n@@ -440,9 +445,14 @@ package body Errout is\n \n       --  or\n \n-      --     warning: in inlined body at\n+      --     warning: in inlined body at ...\n       --     warning: original warning message\n \n+      --  or\n+\n+      --     info: in inlined body at ...\n+      --     info: original info message\n+\n       --  OK, here we have an instantiation error, and we need to generate the\n       --  error on the instantiation, rather than on the template.\n \n@@ -494,7 +504,11 @@ package body Errout is\n                --  Case of inlined body\n \n                if Inlined_Body (X) then\n-                  if Is_Warning_Msg or Is_Style_Msg then\n+                  if Is_Info_Msg then\n+                     Error_Msg_Internal\n+                       (\"info: in inlined body #\",\n+                        Actual_Error_Loc, Flag_Location, Msg_Cont_Status);\n+                  elsif Is_Warning_Msg or Is_Style_Msg then\n                      Error_Msg_Internal\n                        (Warn_Insertion & \"in inlined body #\",\n                         Actual_Error_Loc, Flag_Location, Msg_Cont_Status);\n@@ -507,7 +521,11 @@ package body Errout is\n                --  Case of generic instantiation\n \n                else\n-                  if Is_Warning_Msg or else Is_Style_Msg then\n+                  if Is_Info_Msg then\n+                     Error_Msg_Internal\n+                       (\"info: in instantiation #\",\n+                        Actual_Error_Loc, Flag_Location, Msg_Cont_Status);\n+                  elsif Is_Warning_Msg or else Is_Style_Msg then\n                      Error_Msg_Internal\n                        (Warn_Insertion & \"in instantiation #\",\n                         Actual_Error_Loc, Flag_Location, Msg_Cont_Status);"}, {"sha": "d2cad8893dc065b14c10edb3f9681e749bd6575b", "filename": "gcc/ada/exp_dbug.adb", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f0bcd44fe7967cd994a2a1d1397305b4b8f2e47/gcc%2Fada%2Fexp_dbug.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f0bcd44fe7967cd994a2a1d1397305b4b8f2e47/gcc%2Fada%2Fexp_dbug.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_dbug.adb?ref=1f0bcd44fe7967cd994a2a1d1397305b4b8f2e47", "patch": "@@ -331,6 +331,9 @@ package body Exp_Dbug is\n       --  output in one of these two forms. The result is prepended to the\n       --  name stored in Name_Buffer.\n \n+      function Scope_Contains (Sc : Node_Id; Ent : Entity_Id) return Boolean;\n+      --  Return whether Ent belong to the Sc scope\n+\n       ----------------------------\n       -- Enable_If_Packed_Array --\n       ----------------------------\n@@ -354,8 +357,9 @@ package body Exp_Dbug is\n             Prepend_Uint_To_Buffer (Expr_Value (N));\n \n          elsif Nkind (N) = N_Identifier\n-           and then Scope (Entity (N)) = Scope (Ent)\n-           and then Ekind (Entity (N)) = E_Constant\n+           and then Scope_Contains (Scope (Entity (N)), Ent)\n+           and then (Ekind (Entity (N)) = E_Constant\n+                     or else Ekind (Entity (N)) = E_In_Parameter)\n          then\n             Prepend_String_To_Buffer (Get_Name_String (Chars (Entity (N))));\n \n@@ -367,6 +371,23 @@ package body Exp_Dbug is\n          return True;\n       end Output_Subscript;\n \n+      --------------------\n+      -- Scope_Contains --\n+      --------------------\n+\n+      function Scope_Contains (Sc : Node_Id; Ent : Entity_Id) return Boolean\n+      is\n+         Cur : Node_Id := Scope (Ent);\n+      begin\n+         while Present (Cur) loop\n+            if Cur = Sc then\n+               return True;\n+            end if;\n+            Cur := Scope (Cur);\n+         end loop;\n+         return False;\n+      end Scope_Contains;\n+\n    --  Start of processing for Debug_Renaming_Declaration\n \n    begin"}, {"sha": "5acd813d1d7983798eb22ebe18aa29c9ed681f4d", "filename": "gcc/ada/fname.adb", "status": "modified", "additions": 61, "deletions": 76, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f0bcd44fe7967cd994a2a1d1397305b4b8f2e47/gcc%2Fada%2Ffname.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f0bcd44fe7967cd994a2a1d1397305b4b8f2e47/gcc%2Fada%2Ffname.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffname.adb?ref=1f0bcd44fe7967cd994a2a1d1397305b4b8f2e47", "patch": "@@ -58,62 +58,47 @@ package body Fname is\n      Table_Name           => \"Fname_Dummy_Table\");\n \n    function Has_Internal_Extension (Fname : String) return Boolean;\n+   pragma Inline (Has_Internal_Extension);\n    --  True if the extension is appropriate for an internal/predefined\n    --  unit. That means \".ads\" or \".adb\" for source files, and \".ali\" for\n    --  ALI files.\n \n    function Has_Prefix (X, Prefix : String) return Boolean;\n+   pragma Inline (Has_Prefix);\n    --  True if Prefix is at the beginning of X. For example,\n    --  Has_Prefix(\"a-filename.ads\", Prefix => \"a-\") is True.\n \n-   function Has_Suffix (X, Suffix : String) return Boolean;\n-   --  True if Suffix is at the end of X\n-\n    ----------------------------\n    -- Has_Internal_Extension --\n    ----------------------------\n \n    function Has_Internal_Extension (Fname : String) return Boolean is\n    begin\n-      return\n-        Has_Suffix (Fname, Suffix => \".ads\")\n-          or else Has_Suffix (Fname, Suffix => \".adb\")\n-          or else Has_Suffix (Fname, Suffix => \".ali\");\n-   end Has_Internal_Extension;\n-\n-   ----------------\n-   -- Has_Prefix --\n-   ----------------\n-\n-   function Has_Prefix (X, Prefix : String) return Boolean is\n-   begin\n-      if X'Length >= Prefix'Length then\n+      if Fname'Length >= 4 then\n          declare\n-            Slice : String renames\n-                      X (X'First .. X'First + Prefix'Length - 1);\n+            S : String renames Fname (Fname'Last - 3 .. Fname'Last);\n          begin\n-            return Slice = Prefix;\n+            return S = \".ads\" or else S = \".adb\" or else S = \".ali\";\n          end;\n       end if;\n       return False;\n-   end Has_Prefix;\n+   end Has_Internal_Extension;\n \n    ----------------\n-   -- Has_Suffix --\n+   -- Has_Prefix --\n    ----------------\n \n-   function Has_Suffix (X, Suffix : String) return Boolean is\n+   function Has_Prefix (X, Prefix : String) return Boolean is\n    begin\n-      if X'Length >= Suffix'Length then\n+      if X'Length >= Prefix'Length then\n          declare\n-            Slice : String renames\n-                      X (X'Last - Suffix'Length + 1 .. X'Last);\n+            S : String renames X (X'First .. X'First + Prefix'Length - 1);\n          begin\n-            return Slice = Suffix;\n+            return S = Prefix;\n          end;\n       end if;\n       return False;\n-   end Has_Suffix;\n+   end Has_Prefix;\n \n    ---------------------------\n    -- Is_Internal_File_Name --\n@@ -124,17 +109,18 @@ package body Fname is\n       Renamings_Included : Boolean := True) return Boolean\n    is\n    begin\n+      if Is_Predefined_File_Name (Fname, Renamings_Included) then\n+         return True;\n+      end if;\n+\n       --  Check for internal extensions first, so we don't think (e.g.)\n       --  \"gnat.adc\" is internal.\n \n       if not Has_Internal_Extension (Fname) then\n          return False;\n       end if;\n \n-      return\n-        Is_Predefined_File_Name (Fname, Renamings_Included)\n-          or else Has_Prefix (Fname, Prefix => \"g-\")\n-          or else Has_Prefix (Fname, Prefix => \"gnat.\");\n+      return Has_Prefix (Fname, \"g-\") or else Has_Prefix (Fname, \"gnat.\");\n    end Is_Internal_File_Name;\n \n    function Is_Internal_File_Name\n@@ -156,16 +142,38 @@ package body Fname is\n      (Fname              : String;\n       Renamings_Included : Boolean := True) return Boolean\n    is\n+      subtype Str8 is String (1 .. 8);\n+\n+      Renaming_Names : constant array (1 .. 8) of Str8 :=\n+        (\"calendar\",       -- Calendar\n+         \"machcode\",       -- Machine_Code\n+         \"unchconv\",       -- Unchecked_Conversion\n+         \"unchdeal\",       -- Unchecked_Deallocation\n+         \"directio\",       -- Direct_IO\n+         \"ioexcept\",       -- IO_Exceptions\n+         \"sequenio\",       -- Sequential_IO\n+         \"text_io.\");      -- Text_IO\n+\n+      --  Note: the implementation is optimized to perform uniform comparisons\n+      --  on string slices whose length is known at compile time and at most 8\n+      --  characters; the remaining calls to Has_Prefix must be inlined so as\n+      --  to expose the compile-time known length.\n+\n    begin\n       if not Has_Internal_Extension (Fname) then\n          return False;\n       end if;\n \n-      if Has_Prefix (Fname, \"a-\")\n-        or else Has_Prefix (Fname, \"i-\")\n-        or else Has_Prefix (Fname, \"s-\")\n-      then\n-         return True;\n+      --  Definitely predefined if prefix is a- i- or s-\n+\n+      if Fname'Length >= 2 then\n+         declare\n+            S : String renames Fname (Fname'First .. Fname'First + 1);\n+         begin\n+            if S = \"a-\" or else S = \"i-\" or else S = \"s-\" then\n+               return True;\n+            end if;\n+         end;\n       end if;\n \n       --  Definitely false if longer than 12 characters (8.3)\n@@ -176,53 +184,30 @@ package body Fname is\n \n       --  We include the \".\" in the prefixes below, so we don't match (e.g.)\n       --  adamant.ads. So the first line matches \"ada.ads\", \"ada.adb\", and\n-      --  \"ada.ali\".\n+      --  \"ada.ali\". But that's not necessary if they have 8 characters.\n \n-      if Has_Prefix (Fname, Prefix => \"ada.\")              --  Ada\n-        or else Has_Prefix (Fname, Prefix => \"interfac.\")  --  Interfaces\n-        or else Has_Prefix (Fname, Prefix => \"system.\")    --  System\n+      if Has_Prefix (Fname, \"ada.\")             --  Ada\n+        or else Has_Prefix (Fname, \"interfac\")  --  Interfaces\n+        or else Has_Prefix (Fname, \"system.\")   --  System\n       then\n          return True;\n       end if;\n \n-      if not Renamings_Included then\n-         return False;\n-      end if;\n-\n-      --  The following are the predefined renamings\n-\n-      return\n-         --  Calendar\n-\n-        Has_Prefix (Fname, Prefix => \"calendar.\")\n-\n-         --  Machine_Code\n-\n-          or else Has_Prefix (Fname, Prefix => \"machcode.\")\n-\n-         --  Unchecked_Conversion\n-\n-          or else Has_Prefix (Fname, Prefix => \"unchconv.\")\n-\n-         --  Unchecked_Deallocation\n+      --  If instructed and the name has 8+ characters, check for renamings\n \n-          or else Has_Prefix (Fname, Prefix => \"unchdeal.\")\n-\n-         --  Direct_IO\n-\n-          or else Has_Prefix (Fname, Prefix => \"directio.\")\n-\n-         --  IO_Exceptions\n-\n-          or else Has_Prefix (Fname, Prefix => \"ioexcept.\")\n-\n-         --  Sequential_IO\n-\n-          or else Has_Prefix (Fname, Prefix => \"sequenio.\")\n-\n-         --  Text_IO\n+      if Renamings_Included and then Fname'Length >= 8 then\n+         declare\n+            S : String renames Fname (Fname'First .. Fname'First + 7);\n+         begin\n+            for J in Renaming_Names'Range loop\n+               if S = Renaming_Names (J) then\n+                  return True;\n+               end if;\n+            end loop;\n+         end;\n+      end if;\n \n-          or else Has_Prefix (Fname, Prefix => \"text_io.\");\n+      return False;\n    end Is_Predefined_File_Name;\n \n    function Is_Predefined_File_Name"}, {"sha": "31bf27f4a326f16ae2a25d43a1f6518bf24b2450", "filename": "gcc/ada/sem_ch10.adb", "status": "modified", "additions": 20, "deletions": 14, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f0bcd44fe7967cd994a2a1d1397305b4b8f2e47/gcc%2Fada%2Fsem_ch10.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f0bcd44fe7967cd994a2a1d1397305b4b8f2e47/gcc%2Fada%2Fsem_ch10.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch10.adb?ref=1f0bcd44fe7967cd994a2a1d1397305b4b8f2e47", "patch": "@@ -1204,32 +1204,38 @@ package body Sem_Ch10 is\n             --  where the elaboration routine might otherwise be called more\n             --  than once.\n \n-            --  Case of units which do not require elaboration checks\n+            --  They are also needed to ensure explicit visibility from the\n+            --  binder generated code of all the units involved in a partition\n+            --  when control-flow preservation is requested.\n \n-            if\n-              --  Pure units do not need checks\n+            --  Case of units which do not require an elaboration entity\n \n-              Is_Pure (Spec_Id)\n+            if not Opt.Suppress_Control_Flow_Optimizations\n+              and then\n+              ( --  Pure units do not need checks\n+\n+                Is_Pure (Spec_Id)\n \n-              --  Preelaborated units do not need checks\n+                --  Preelaborated units do not need checks\n \n-              or else Is_Preelaborated (Spec_Id)\n+                or else Is_Preelaborated (Spec_Id)\n \n-              --  No checks needed if pragma Elaborate_Body present\n+                --  No checks needed if pragma Elaborate_Body present\n \n-              or else Has_Pragma_Elaborate_Body (Spec_Id)\n+                or else Has_Pragma_Elaborate_Body (Spec_Id)\n \n-              --  No checks needed if unit does not require a body\n+                --  No checks needed if unit does not require a body\n \n-              or else not Unit_Requires_Body (Spec_Id)\n+                or else not Unit_Requires_Body (Spec_Id)\n \n-              --  No checks needed for predefined files\n+                --  No checks needed for predefined files\n \n-              or else Is_Predefined_File_Name (Unit_File_Name (Unum))\n+                or else Is_Predefined_File_Name (Unit_File_Name (Unum))\n \n-              --  No checks required if no separate spec\n+                --  No checks required if no separate spec\n \n-              or else Acts_As_Spec (N)\n+                or else Acts_As_Spec (N)\n+              )\n             then\n                --  This is a case where we only need the entity for\n                --  checking to prevent multiple elaboration checks."}, {"sha": "69ba0cb3017815baba1bf8b30505bb6dff9de182", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 100, "deletions": 86, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f0bcd44fe7967cd994a2a1d1397305b4b8f2e47/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f0bcd44fe7967cd994a2a1d1397305b4b8f2e47/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=1f0bcd44fe7967cd994a2a1d1397305b4b8f2e47", "patch": "@@ -16488,6 +16488,73 @@ package body Sem_Util is\n       end if;\n    end New_Copy_List_Tree;\n \n+   --------------------------------------------------\n+   -- New_Copy_Tree Auxiliary Data and Subprograms --\n+   --------------------------------------------------\n+\n+   use Atree.Unchecked_Access;\n+   use Atree_Private_Part;\n+\n+   --  Our approach here requires a two pass traversal of the tree. The\n+   --  first pass visits all nodes that eventually will be copied looking\n+   --  for defining Itypes. If any defining Itypes are found, then they are\n+   --  copied, and an entry is added to the replacement map. In the second\n+   --  phase, the tree is copied, using the replacement map to replace any\n+   --  Itype references within the copied tree.\n+\n+   --  The following hash tables are used to speed up access to the map. They\n+   --  are declared at library level to avoid elaborating them for every call\n+   --  to New_Copy_Tree. This can save up to 2% of the entire compilation time\n+   --  spent in the front end.\n+\n+   subtype NCT_Header_Num is Int range 0 .. 511;\n+   --  Defines range of headers in hash tables (512 headers)\n+\n+   function New_Copy_Hash (E : Entity_Id) return NCT_Header_Num;\n+   --  Hash function used for hash operations\n+\n+   -------------------\n+   -- New_Copy_Hash --\n+   -------------------\n+\n+   function New_Copy_Hash (E : Entity_Id) return NCT_Header_Num is\n+   begin\n+      return Nat (E) mod (NCT_Header_Num'Last + 1);\n+   end New_Copy_Hash;\n+\n+   ---------------\n+   -- NCT_Assoc --\n+   ---------------\n+\n+   --  The hash table NCT_Assoc associates old entities in the table with their\n+   --  corresponding new entities (i.e. the pairs of entries presented in the\n+   --  original Map argument are Key-Element pairs).\n+\n+   package NCT_Assoc is new Simple_HTable (\n+     Header_Num => NCT_Header_Num,\n+     Element    => Entity_Id,\n+     No_Element => Empty,\n+     Key        => Entity_Id,\n+     Hash       => New_Copy_Hash,\n+     Equal      => Types.\"=\");\n+\n+   ---------------------\n+   -- NCT_Itype_Assoc --\n+   ---------------------\n+\n+   --  The hash table NCT_Itype_Assoc contains entries only for those old\n+   --  nodes which have a non-empty Associated_Node_For_Itype set. The key\n+   --  is the associated node, and the element is the new node itself (NOT\n+   --  the associated node for the new node).\n+\n+   package NCT_Itype_Assoc is new Simple_HTable (\n+     Header_Num => NCT_Header_Num,\n+     Element    => Entity_Id,\n+     No_Element => Empty,\n+     Key        => Entity_Id,\n+     Hash       => New_Copy_Hash,\n+     Equal      => Types.\"=\");\n+\n    -------------------\n    -- New_Copy_Tree --\n    -------------------\n@@ -16509,63 +16576,10 @@ package body Sem_Util is\n       --  variables for declarations located in blocks or subprograms defined\n       --  in Expression_With_Action nodes.\n \n-      ------------------------------------\n-      -- Auxiliary Data and Subprograms --\n-      ------------------------------------\n-\n-      use Atree.Unchecked_Access;\n-      use Atree_Private_Part;\n-\n-      --  Our approach here requires a two pass traversal of the tree. The\n-      --  first pass visits all nodes that eventually will be copied looking\n-      --  for defining Itypes. If any defining Itypes are found, then they are\n-      --  copied, and an entry is added to the replacement map. In the second\n-      --  phase, the tree is copied, using the replacement map to replace any\n-      --  Itype references within the copied tree.\n-\n-      --  The following hash tables are used if the Map supplied has more than\n-      --  hash threshold entries to speed up access to the map. If there are\n-      --  fewer entries, then the map is searched sequentially (because setting\n-      --  up a hash table for only a few entries takes more time than it saves.\n-\n-      subtype NCT_Header_Num is Int range 0 .. 511;\n-      --  Defines range of headers in hash tables (512 headers)\n-\n-      function New_Copy_Hash (E : Entity_Id) return NCT_Header_Num;\n-      --  Hash function used for hash operations\n-\n-      ---------------\n-      -- NCT_Assoc --\n-      ---------------\n-\n-      --  The hash table NCT_Assoc associates old entities in the table with\n-      --  their corresponding new entities (i.e. the pairs of entries presented\n-      --  in the original Map argument are Key-Element pairs).\n-\n-      package NCT_Assoc is new Simple_HTable (\n-        Header_Num => NCT_Header_Num,\n-        Element    => Entity_Id,\n-        No_Element => Empty,\n-        Key        => Entity_Id,\n-        Hash       => New_Copy_Hash,\n-        Equal      => Types.\"=\");\n-\n-      ---------------------\n-      -- NCT_Itype_Assoc --\n-      ---------------------\n-\n-      --  The hash table NCT_Itype_Assoc contains entries only for those old\n-      --  nodes which have a non-empty Associated_Node_For_Itype set. The key\n-      --  is the associated node, and the element is the new node itself (NOT\n-      --  the associated node for the new node).\n-\n-      package NCT_Itype_Assoc is new Simple_HTable (\n-        Header_Num => NCT_Header_Num,\n-        Element    => Entity_Id,\n-        No_Element => Empty,\n-        Key        => Entity_Id,\n-        Hash       => New_Copy_Hash,\n-        Equal      => Types.\"=\");\n+      NCT_Hash_Tables_Used : Boolean := False;\n+      --  Set to True if hash tables are in use. It is intended to speed up the\n+      --  common case, which is no hash tables in use. This can save up to 8%\n+      --  of the entire compilation time spent in the front end.\n \n       function Assoc (N : Node_Or_Entity_Id) return Node_Id;\n       --  Called during second phase to map entities into their corresponding\n@@ -16627,7 +16641,7 @@ package body Sem_Util is\n          Ent : Entity_Id;\n \n       begin\n-         if Nkind (N) not in N_Entity then\n+         if Nkind (N) not in N_Entity or else not NCT_Hash_Tables_Used then\n             return N;\n \n          else\n@@ -16681,6 +16695,8 @@ package body Sem_Util is\n \n             Next_Elmt (Elmt);\n          end loop;\n+\n+         NCT_Hash_Tables_Used := True;\n       end Build_NCT_Hash_Tables;\n \n       ---------------------------------\n@@ -17041,14 +17057,6 @@ package body Sem_Util is\n \n          return False;\n       end In_Map;\n-      -------------------\n-      -- New_Copy_Hash --\n-      -------------------\n-\n-      function New_Copy_Hash (E : Entity_Id) return NCT_Header_Num is\n-      begin\n-         return Nat (E) mod (NCT_Header_Num'Last + 1);\n-      end New_Copy_Hash;\n \n       -----------------\n       -- Visit_Elist --\n@@ -17099,6 +17107,7 @@ package body Sem_Util is\n          --  Add new association to map\n \n          NCT_Assoc.Set (Old_Entity, New_E);\n+         NCT_Hash_Tables_Used := True;\n \n          --  Visit descendants that eventually get copied\n \n@@ -17228,6 +17237,7 @@ package body Sem_Util is\n          --  Add new association to map\n \n          NCT_Assoc.Set (Old_Itype, New_Itype);\n+         NCT_Hash_Tables_Used := True;\n \n          --  If a record subtype is simply copied, the entity list will be\n          --  shared. Thus cloned_Subtype must be set to indicate the sharing.\n@@ -17354,37 +17364,41 @@ package body Sem_Util is\n       --  Now the second phase of the copy can start. First we process all the\n       --  mapped entities, copying their descendants.\n \n-      declare\n-         Old_E : Entity_Id := Empty;\n-         New_E : Entity_Id;\n+      if NCT_Hash_Tables_Used then\n+         declare\n+            Old_E : Entity_Id := Empty;\n+            New_E : Entity_Id;\n \n-      begin\n-         NCT_Assoc.Get_First (Old_E, New_E);\n-         while Present (New_E) loop\n+         begin\n+            NCT_Assoc.Get_First (Old_E, New_E);\n+            while Present (New_E) loop\n \n-            --  Skip entities that were not created in the first phase (that\n-            --  is, old entities specified by the caller in the set of mappings\n-            --  to be applied to the tree).\n+               --  Skip entities that were not created in the first phase\n+               --  (that is, old entities specified by the caller in the\n+               --  set of mappings to be applied to the tree).\n \n-            if Is_Itype (New_E)\n-              or else No (Map)\n-              or else not In_Map (Old_E)\n-            then\n-               Copy_Entity_With_Replacement (New_E);\n-            end if;\n+               if Is_Itype (New_E)\n+                 or else No (Map)\n+                 or else not In_Map (Old_E)\n+               then\n+                  Copy_Entity_With_Replacement (New_E);\n+               end if;\n \n-            NCT_Assoc.Get_Next (Old_E, New_E);\n-         end loop;\n-      end;\n+               NCT_Assoc.Get_Next (Old_E, New_E);\n+            end loop;\n+         end;\n+      end if;\n \n       --  Now we can copy the actual tree\n \n       declare\n          Result : constant Node_Id := Copy_Node_With_Replacement (Source);\n \n       begin\n-         NCT_Assoc.Reset;\n-         NCT_Itype_Assoc.Reset;\n+         if NCT_Hash_Tables_Used then\n+            NCT_Assoc.Reset;\n+            NCT_Itype_Assoc.Reset;\n+         end if;\n \n          return Result;\n       end;"}]}