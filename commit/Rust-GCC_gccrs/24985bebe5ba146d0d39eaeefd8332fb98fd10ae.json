{"sha": "24985bebe5ba146d0d39eaeefd8332fb98fd10ae", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjQ5ODViZWJlNWJhMTQ2ZDBkMzllYWVlZmQ4MzMyZmI5OGZkMTBhZQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2002-11-15T04:53:19Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2002-11-15T04:53:19Z"}, "message": "* gthr-single.h: Fix formatting.\n\nFrom-SVN: r59116", "tree": {"sha": "fee3140af8440a29dcba629b80060a2f55a1400d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fee3140af8440a29dcba629b80060a2f55a1400d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/24985bebe5ba146d0d39eaeefd8332fb98fd10ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24985bebe5ba146d0d39eaeefd8332fb98fd10ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/24985bebe5ba146d0d39eaeefd8332fb98fd10ae", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24985bebe5ba146d0d39eaeefd8332fb98fd10ae/comments", "author": null, "committer": null, "parents": [{"sha": "8b54424daea907a05a05cf5b3cd90f328fabecd9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b54424daea907a05a05cf5b3cd90f328fabecd9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b54424daea907a05a05cf5b3cd90f328fabecd9"}], "stats": {"total": 50, "additions": 27, "deletions": 23}, "files": [{"sha": "774a7c094557c793e4010abf30e07f34e0326243", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24985bebe5ba146d0d39eaeefd8332fb98fd10ae/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24985bebe5ba146d0d39eaeefd8332fb98fd10ae/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=24985bebe5ba146d0d39eaeefd8332fb98fd10ae", "patch": "@@ -1,3 +1,7 @@\n+2002-11-14  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* gthr-single.h: Fix formatting.\n+\n 2002-11-14  Zack Weinberg  <zack@codesourcery.com>\n \n \t* tree.c (tree_vec_elt_check_failed): New function."}, {"sha": "0bb4682615dbe8b6ca835411b0d959e263ae70ca", "filename": "gcc/gthr-single.h", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24985bebe5ba146d0d39eaeefd8332fb98fd10ae/gcc%2Fgthr-single.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24985bebe5ba146d0d39eaeefd8332fb98fd10ae/gcc%2Fgthr-single.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgthr-single.h?ref=24985bebe5ba146d0d39eaeefd8332fb98fd10ae", "patch": "@@ -50,15 +50,15 @@ static void *thread_local_storage = NULL;\n \n /* Initialize the threads subsystem.  */\n static inline int\n-__gthread_objc_init_thread_system(void)\n+__gthread_objc_init_thread_system (void)\n {\n   /* No thread support available */\n   return -1;\n }\n \n /* Close the threads subsystem.  */\n static inline int\n-__gthread_objc_close_thread_system(void)\n+__gthread_objc_close_thread_system (void)\n {\n   /* No thread support available */\n   return -1;\n@@ -68,63 +68,63 @@ __gthread_objc_close_thread_system(void)\n \n /* Create a new thread of execution.  */\n static inline objc_thread_t\n-__gthread_objc_thread_detach(void (* func)(void *), void * UNUSED(arg))\n+__gthread_objc_thread_detach (void (* func)(void *), void * UNUSED(arg))\n {\n   /* No thread support available */\n   return NULL;\n }\n \n /* Set the current thread's priority.  */\n static inline int\n-__gthread_objc_thread_set_priority(int UNUSED(priority))\n+__gthread_objc_thread_set_priority (int UNUSED(priority))\n {\n   /* No thread support available */\n   return -1;\n }\n \n /* Return the current thread's priority.  */\n static inline int\n-__gthread_objc_thread_get_priority(void)\n+__gthread_objc_thread_get_priority (void)\n {\n   return OBJC_THREAD_INTERACTIVE_PRIORITY;\n }\n \n /* Yield our process time to another thread.  */\n static inline void\n-__gthread_objc_thread_yield(void)\n+__gthread_objc_thread_yield (void)\n {\n   return;\n }\n \n /* Terminate the current thread.  */\n static inline int\n-__gthread_objc_thread_exit(void)\n+__gthread_objc_thread_exit (void)\n {\n   /* No thread support available */\n   /* Should we really exit the program */\n-  /* exit(&__objc_thread_exit_status); */\n+  /* exit (&__objc_thread_exit_status); */\n   return -1;\n }\n \n /* Returns an integer value which uniquely describes a thread.  */\n static inline objc_thread_t\n-__gthread_objc_thread_id(void)\n+__gthread_objc_thread_id (void)\n {\n   /* No thread support, use 1.  */\n-  return (objc_thread_t)1;\n+  return (objc_thread_t) 1;\n }\n \n /* Sets the thread's local storage pointer.  */\n static inline int\n-__gthread_objc_thread_set_data(void *value)\n+__gthread_objc_thread_set_data (void *value)\n {\n   thread_local_storage = value;\n   return 0;\n }\n \n /* Returns the thread's local storage pointer.  */\n static inline void *\n-__gthread_objc_thread_get_data(void)\n+__gthread_objc_thread_get_data (void)\n {\n   return thread_local_storage;\n }\n@@ -133,37 +133,37 @@ __gthread_objc_thread_get_data(void)\n \n /* Allocate a mutex.  */\n static inline int\n-__gthread_objc_mutex_allocate(objc_mutex_t UNUSED(mutex))\n+__gthread_objc_mutex_allocate (objc_mutex_t UNUSED(mutex))\n {\n   return 0;\n }\n \n /* Deallocate a mutex.  */\n static inline int\n-__gthread_objc_mutex_deallocate(objc_mutex_t UNUSED(mutex))\n+__gthread_objc_mutex_deallocate (objc_mutex_t UNUSED(mutex))\n {\n   return 0;\n }\n \n /* Grab a lock on a mutex.  */\n static inline int\n-__gthread_objc_mutex_lock(objc_mutex_t UNUSED(mutex))\n+__gthread_objc_mutex_lock (objc_mutex_t UNUSED(mutex))\n {\n   /* There can only be one thread, so we always get the lock */\n   return 0;\n }\n \n /* Try to grab a lock on a mutex.  */\n static inline int\n-__gthread_objc_mutex_trylock(objc_mutex_t UNUSED(mutex))\n+__gthread_objc_mutex_trylock (objc_mutex_t UNUSED(mutex))\n {\n   /* There can only be one thread, so we always get the lock */\n   return 0;\n }\n \n /* Unlock the mutex */\n static inline int\n-__gthread_objc_mutex_unlock(objc_mutex_t UNUSED(mutex))\n+__gthread_objc_mutex_unlock (objc_mutex_t UNUSED(mutex))\n {\n   return 0;\n }\n@@ -172,36 +172,36 @@ __gthread_objc_mutex_unlock(objc_mutex_t UNUSED(mutex))\n \n /* Allocate a condition.  */\n static inline int\n-__gthread_objc_condition_allocate(objc_condition_t UNUSED(condition))\n+__gthread_objc_condition_allocate (objc_condition_t UNUSED(condition))\n {\n   return 0;\n }\n \n /* Deallocate a condition.  */\n static inline int\n-__gthread_objc_condition_deallocate(objc_condition_t UNUSED(condition))\n+__gthread_objc_condition_deallocate (objc_condition_t UNUSED(condition))\n {\n   return 0;\n }\n \n /* Wait on the condition */\n static inline int\n-__gthread_objc_condition_wait(objc_condition_t UNUSED(condition),\n-\t\t\t      objc_mutex_t UNUSED(mutex))\n+__gthread_objc_condition_wait (objc_condition_t UNUSED(condition),\n+\t\t\t       objc_mutex_t UNUSED(mutex))\n {\n   return 0;\n }\n \n /* Wake up all threads waiting on this condition.  */\n static inline int\n-__gthread_objc_condition_broadcast(objc_condition_t UNUSED(condition))\n+__gthread_objc_condition_broadcast (objc_condition_t UNUSED(condition))\n {\n   return 0;\n }\n \n /* Wake up one thread waiting on this condition.  */\n static inline int\n-__gthread_objc_condition_signal(objc_condition_t UNUSED(condition))\n+__gthread_objc_condition_signal (objc_condition_t UNUSED(condition))\n {\n   return 0;\n }"}]}