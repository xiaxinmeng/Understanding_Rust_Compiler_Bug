{"sha": "c13e8210479fd194128fed8742d8a491b686a404", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzEzZTgyMTA0NzlmZDE5NDEyOGZlZDg3NDJkOGE0OTFiNjg2YTQwNA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2000-03-31T08:57:54Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-03-31T08:57:54Z"}, "message": "Makefile.in (emit-rtl.o): Depend on HASHTAB_H.\n\n\t* Makefile.in (emit-rtl.o): Depend on HASHTAB_H.\n\t* alias.c (reg_known_value): Add comments.\n\t(init_alias_analysis): Likewise.\n\t* cse.c (exp_equiv_p): CONST_INTs are equal iff they have the same\n\taddress.\n\t(cse_basic_block): Fix typo in comment.\n\t* emit-rtl.c: Include hashtab.h.\n\t(const_int_htab): New variable.\n\t(const_int_htab_hash): New function.\n\t(const_int_htab_eq): Likewise.\n\t(rtx_htab_mark_1): Likewise.\n\t(rtx_htab_mark): Likewise.\n\t(gen_rtx_CONST_INT): Cache all CONST_INTs.\n\t(unshare_all_rtx): Fix formatting.\n\t(init_emit_once): Initialize const_int_htab.\n\t* rtl.c (rtx_equal_p): CONST_INTs are equal iff they have the same\n\taddress.\n\t* rtl.texi: Document the fact that all CONST_INTs with the same\n\tvalue are shared.\n\nFrom-SVN: r32844", "tree": {"sha": "af3dfff0cabf48c3e9e50b45078202db74413026", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/af3dfff0cabf48c3e9e50b45078202db74413026"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c13e8210479fd194128fed8742d8a491b686a404", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c13e8210479fd194128fed8742d8a491b686a404", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c13e8210479fd194128fed8742d8a491b686a404", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c13e8210479fd194128fed8742d8a491b686a404/comments", "author": null, "committer": null, "parents": [{"sha": "cca8e0ff228daba37afc9279721c1fa04faa0269", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cca8e0ff228daba37afc9279721c1fa04faa0269", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cca8e0ff228daba37afc9279721c1fa04faa0269"}], "stats": {"total": 169, "additions": 137, "deletions": 32}, "files": [{"sha": "0088fd1a0f7526e4f2eacd7da5f280c0e5f9e810", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c13e8210479fd194128fed8742d8a491b686a404/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c13e8210479fd194128fed8742d8a491b686a404/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c13e8210479fd194128fed8742d8a491b686a404", "patch": "@@ -1,3 +1,25 @@\n+2000-03-30  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* Makefile.in (emit-rtl.o): Depend on HASHTAB_H.\n+\t* alias.c (reg_known_value): Add comments.\n+\t(init_alias_analysis): Likewise.\n+\t* cse.c (exp_equiv_p): CONST_INTs are equal iff they have the same\n+\taddress.\n+\t(cse_basic_block): Fix typo in comment.\n+\t* emit-rtl.c: Include hashtab.h.\n+\t(const_int_htab): New variable.\n+\t(const_int_htab_hash): New function.\n+\t(const_int_htab_eq): Likewise.\n+\t(rtx_htab_mark_1): Likewise.\n+\t(rtx_htab_mark): Likewise.\n+\t(gen_rtx_CONST_INT): Cache all CONST_INTs.\n+\t(unshare_all_rtx): Fix formatting.\n+\t(init_emit_once): Initialize const_int_htab.\n+\t* rtl.c (rtx_equal_p): CONST_INTs are equal iff they have the same\n+\taddress.\n+\t* rtl.texi: Document the fact that all CONST_INTs with the same\n+\tvalue are shared.\n+\n 2000-03-30  Richard Henderson  <rth@cygnus.com>\n \n \t* alpha.h (FUNCTION_BOUNDARY): Reduce to 128 bits."}, {"sha": "ee53e28ac2fe1ca815b4834b647ec1e5ca325aa8", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c13e8210479fd194128fed8742d8a491b686a404/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c13e8210479fd194128fed8742d8a491b686a404/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=c13e8210479fd194128fed8742d8a491b686a404", "patch": "@@ -1546,7 +1546,8 @@ xcoffout.o : xcoffout.c $(CONFIG_H) system.h $(TREE_H) $(RTL_H) xcoffout.h \\\n    flags.h toplev.h output.h dbxout.h ggc.h\n emit-rtl.o : emit-rtl.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) flags.h \\\n    function.h $(REGS_H) insn-config.h $(RECOG_H) real.h ggc.h \\\n-   $(EXPR_H) $(srcdir)/../include/obstack.h hard-reg-set.h bitmap.h toplev.h\n+   $(EXPR_H) $(srcdir)/../include/obstack.h hard-reg-set.h bitmap.h toplev.h \\\n+   $(HASHTAB_H)\n real.o : real.c $(CONFIG_H) system.h $(TREE_H) toplev.h\n integrate.o : integrate.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) flags.h \\\n    $(INTEGRATE_H) insn-flags.h insn-config.h $(EXPR_H) real.h $(REGS_H) \\"}, {"sha": "d413ec250ee6dbeefc5d0710b63401d4040e2971", "filename": "gcc/alias.c", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c13e8210479fd194128fed8742d8a491b686a404/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c13e8210479fd194128fed8742d8a491b686a404/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=c13e8210479fd194128fed8742d8a491b686a404", "patch": "@@ -153,8 +153,10 @@ static unsigned int reg_base_value_size; /* size of reg_base_value array */\n    after reload.  */\n static rtx *alias_invariant;\n \n-/* Vector indexed by N giving the initial (unchanging) value known\n-   for pseudo-register N.  */\n+/* Vector indexed by N giving the initial (unchanging) value known for\n+   pseudo-register N.  This array is initialized in\n+   init_alias_analysis, and does not change until end_alias_analysis\n+   is called.  */\n rtx *reg_known_value;\n \n /* Indicates number of valid entries in reg_known_value.  */\n@@ -1570,6 +1572,9 @@ init_alias_once ()\n   alias_sets = splay_tree_new (splay_tree_compare_ints, 0, 0);\n }\n \n+/* Initialize the aliasing machinery.  Initialize the REG_KNOWN_VALUE\n+   array.  */\n+\n void\n init_alias_analysis ()\n {"}, {"sha": "c936a15db16bd21d8fe8d43ea1be39a1fbc1303e", "filename": "gcc/cse.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c13e8210479fd194128fed8742d8a491b686a404/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c13e8210479fd194128fed8742d8a491b686a404/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=c13e8210479fd194128fed8742d8a491b686a404", "patch": "@@ -2367,10 +2367,8 @@ exp_equiv_p (x, y, validate, equal_values)\n     {\n     case PC:\n     case CC0:\n-      return x == y;\n-\n     case CONST_INT:\n-      return INTVAL (x) == INTVAL (y);\n+      return x == y;\n \n     case LABEL_REF:\n       return XEXP (x, 0) == XEXP (y, 0);\n@@ -6898,7 +6896,7 @@ cse_basic_block (from, to, next_branch, around_loop)\n \n       /* If we have processed 1,000 insns, flush the hash table to\n \t avoid extreme quadratic behavior.  We must not include NOTEs\n-\t in the count since there may be more or them when generating\n+\t in the count since there may be more of them when generating\n \t debugging information.  If we clear the table at different\n \t times, code generated with -g -O might be different than code\n \t generated with -O but not -g."}, {"sha": "246805c78a05e25050dd1694ddce440de001570f", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 76, "deletions": 5, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c13e8210479fd194128fed8742d8a491b686a404/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c13e8210479fd194128fed8742d8a491b686a404/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=c13e8210479fd194128fed8742d8a491b686a404", "patch": "@@ -46,6 +46,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"expr.h\"\n #include \"regs.h\"\n #include \"hard-reg-set.h\"\n+#include \"hashtab.h\"\n #include \"insn-config.h\"\n #include \"recog.h\"\n #include \"real.h\"\n@@ -137,6 +138,11 @@ rtx return_address_pointer_rtx;\t/* (REG:Pmode RETURN_ADDRESS_POINTER_REGNUM) */\n \n rtx const_int_rtx[MAX_SAVED_CONST_INT * 2 + 1];\n \n+/* A hash table storing CONST_INTs whose absolute value is greater\n+   than MAX_SAVED_CONST_INT.  */\n+\n+static htab_t const_int_htab;\n+\n /* start_sequence and gen_sequence can make a lot of rtx expressions which are\n    shortly thrown away.  We use two mechanisms to prevent this waste:\n \n@@ -172,16 +178,67 @@ static rtx make_call_insn_raw\t\tPARAMS ((rtx));\n static rtx find_line_note\t\tPARAMS ((rtx));\n static void mark_sequence_stack         PARAMS ((struct sequence_stack *));\n static void unshare_all_rtl_1\t\tPARAMS ((rtx));\n+static hashval_t const_int_htab_hash    PARAMS ((const void *));\n+static int const_int_htab_eq            PARAMS ((const void *,\n+\t\t\t\t\t\t const void *));\n+static int rtx_htab_mark_1              PARAMS ((void **, void *));\n+static void rtx_htab_mark               PARAMS ((void *));\n+\n \f\n+/* Returns a hash code for X (which is a really a CONST_INT).  */\n+\n+static hashval_t\n+const_int_htab_hash (x)\n+     const void *x;\n+{\n+  return (hashval_t) INTVAL ((rtx) x);\n+}\n+\n+/* Returns non-zero if the value represented by X (which is really a\n+   CONST_INT) is the same as that given by Y (which is really a\n+   HOST_WIDE_INT *).  */\n+\n+static int\n+const_int_htab_eq (x, y)\n+     const void *x;\n+     const void *y;\n+{\n+  return (INTVAL ((rtx) x) == *((HOST_WIDE_INT *) y));\n+}\n+\n+/* Mark the hash-table element X (which is really a pointer to an\n+   rtx).  */\n+\n+static int\n+rtx_htab_mark_1 (x, data)\n+     void **x;\n+     void *data ATTRIBUTE_UNUSED;\n+{\n+  ggc_mark_rtx (*x);\n+  return 1;\n+}\n+\n+/* Mark all the elements of HTAB (which is really an htab_t full of\n+   rtxs).  */\n+\n+static void\n+rtx_htab_mark (htab)\n+     void *htab;\n+{\n+  htab_traverse (*((htab_t *) htab), rtx_htab_mark_1, NULL);\n+}\n+\n /* There are some RTL codes that require special attention; the generation\n    functions do the raw handling.  If you add to this list, modify\n    special_rtx in gengenrtl.c as well.  */\n \n rtx\n gen_rtx_CONST_INT (mode, arg)\n-     enum machine_mode mode;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n      HOST_WIDE_INT arg;\n {\n+  void **slot;\n+\n   if (arg >= - MAX_SAVED_CONST_INT && arg <= MAX_SAVED_CONST_INT)\n     return const_int_rtx[arg + MAX_SAVED_CONST_INT];\n \n@@ -190,7 +247,15 @@ gen_rtx_CONST_INT (mode, arg)\n     return const_true_rtx;\n #endif\n \n-  return gen_rtx_raw_CONST_INT (mode, arg);\n+  /* Look up the CONST_INT in the hash table.  */\n+  slot = htab_find_slot_with_hash (const_int_htab, \n+\t\t\t\t   &arg,\n+\t\t\t\t   (hashval_t) arg,\n+\t\t\t\t   /*insert=*/1);\n+  if (!*slot)\n+    *slot = gen_rtx_raw_CONST_INT (VOIDmode, arg);\n+\n+  return (rtx) *slot;\n }\n \n /* CONST_DOUBLEs needs special handling because its length is known\n@@ -1627,9 +1692,7 @@ unshare_all_rtl (fndecl, insn)\n \n   /* Make sure that virtual parameters are not shared.  */\n   for (decl = DECL_ARGUMENTS (fndecl); decl; decl = TREE_CHAIN (decl))\n-    {\n-      copy_rtx_if_shared (DECL_RTL (decl));\n-    }\n+    copy_rtx_if_shared (DECL_RTL (decl));\n \n   /* Unshare just about everything else.  */\n   unshare_all_rtl_1 (insn);\n@@ -4083,6 +4146,14 @@ init_emit_once (line_numbers)\n   ggc_add_rtx_root (&static_chain_rtx, 1);\n   ggc_add_rtx_root (&static_chain_incoming_rtx, 1);\n   ggc_add_rtx_root (&return_address_pointer_rtx, 1);\n+\n+  /* Initialize the CONST_INT hash table.  */\n+  const_int_htab = htab_create (37, \n+\t\t\t\tconst_int_htab_hash, \n+\t\t\t\tconst_int_htab_eq, \n+\t\t\t\tNULL);\n+  ggc_add_root (&const_int_htab, 1, sizeof (const_int_htab), \n+\t\trtx_htab_mark);\n }\n \f\n /* Query and clear/ restore no_line_numbers.  This is used by the"}, {"sha": "bfe3806c06d471c8b769e8bcc869f3306da2ab61", "filename": "gcc/rtl.c", "status": "modified", "additions": 26, "deletions": 16, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c13e8210479fd194128fed8742d8a491b686a404/gcc%2Frtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c13e8210479fd194128fed8742d8a491b686a404/gcc%2Frtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.c?ref=c13e8210479fd194128fed8742d8a491b686a404", "patch": "@@ -613,22 +613,32 @@ rtx_equal_p (x, y)\n   if (GET_MODE (x) != GET_MODE (y))\n     return 0;\n \n-  /* REG, LABEL_REF, and SYMBOL_REF can be compared nonrecursively.  */\n-\n-  if (code == REG)\n-    /* Until rtl generation is complete, don't consider a reference to the\n-       return register of the current function the same as the return from a\n-       called function.  This eases the job of function integration.  Once the\n-       distinction is no longer needed, they can be considered equivalent.  */\n-    return (REGNO (x) == REGNO (y)\n-\t    && (! rtx_equal_function_value_matters\n-\t\t|| REG_FUNCTION_VALUE_P (x) == REG_FUNCTION_VALUE_P (y)));\n-  else if (code == LABEL_REF)\n-    return XEXP (x, 0) == XEXP (y, 0);\n-  else if (code == SYMBOL_REF)\n-    return XSTR (x, 0) == XSTR (y, 0);\n-  else if (code == SCRATCH || code == CONST_DOUBLE)\n-    return 0;\n+  /* Some RTL can be compared nonrecursively.  */\n+  switch (code)\n+    {\n+    case REG:\n+      /* Until rtl generation is complete, don't consider a reference to the\n+\t return register of the current function the same as the return from a\n+\t called function.  This eases the job of function integration.  Once the\n+\t distinction is no longer needed, they can be considered equivalent.  */\n+      return (REGNO (x) == REGNO (y)\n+\t      && (! rtx_equal_function_value_matters\n+\t\t  || REG_FUNCTION_VALUE_P (x) == REG_FUNCTION_VALUE_P (y)));\n+\n+    case LABEL_REF:\n+      return XEXP (x, 0) == XEXP (y, 0);\n+\n+    case SYMBOL_REF:\n+      return XSTR (x, 0) == XSTR (y, 0);\n+\n+    case SCRATCH:\n+    case CONST_DOUBLE:\n+    case CONST_INT:\n+      return 0;\n+\n+    default:\n+      break;\n+    }\n \n   /* Compare the elements.  If any pair of corresponding elements\n      fail to match, return 0 for the whole things.  */"}, {"sha": "55208ae62637d5c9bcf071ef2ae1ffdfac476ca0", "filename": "gcc/rtl.texi", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c13e8210479fd194128fed8742d8a491b686a404/gcc%2Frtl.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c13e8210479fd194128fed8742d8a491b686a404/gcc%2Frtl.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.texi?ref=c13e8210479fd194128fed8742d8a491b686a404", "patch": "@@ -1,4 +1,4 @@\n-@c Copyright (C) 1988, 89, 92, 94, 97, 1998, 1999 Free Software Foundation, Inc.\n+@c Copyright (C) 1988, 89, 92, 94, 97, 1998, 1999, 2000 Free Software Foundation, Inc.\n @c This is part of the GCC manual.\n @c For copying conditions, see the file gcc.texi.\n \n@@ -2917,9 +2917,7 @@ referring to it.\n \n @cindex @code{const_int}, RTL sharing\n @item\n-There is only one @code{const_int} expression with value 0, only\n-one with value 1, and only one with value @minus{}1.\n-Some other integer values are also stored uniquely.\n+All @code{const_int} expressions with equal values are shared.\n \n @cindex @code{pc}, RTL sharing\n @item"}]}