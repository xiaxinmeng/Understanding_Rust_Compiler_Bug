{"sha": "d8191d862796c31fb7ce32eb5f3456f5ff0438ff", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDgxOTFkODYyNzk2YzMxZmI3Y2UzMmViNWYzNDU2ZjVmZjA0MzhmZg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-06-08T23:11:30Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-06-08T23:11:30Z"}, "message": "(verify_addresses): New function.\n\n(find_splittable_givs): Use verify_addresses instead of memory_address_p.\n\nFrom-SVN: r9909", "tree": {"sha": "b773e149d84084c161187c85670771f101889186", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b773e149d84084c161187c85670771f101889186"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d8191d862796c31fb7ce32eb5f3456f5ff0438ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8191d862796c31fb7ce32eb5f3456f5ff0438ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d8191d862796c31fb7ce32eb5f3456f5ff0438ff", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8191d862796c31fb7ce32eb5f3456f5ff0438ff/comments", "author": null, "committer": null, "parents": [{"sha": "82580166a8cdede4c36af50d5958e6e81eafb94a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82580166a8cdede4c36af50d5958e6e81eafb94a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/82580166a8cdede4c36af50d5958e6e81eafb94a"}], "stats": {"total": 48, "additions": 32, "deletions": 16}, "files": [{"sha": "aaef56358523fa8d41366226e3e0dcc285927b3e", "filename": "gcc/unroll.c", "status": "modified", "additions": 32, "deletions": 16, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8191d862796c31fb7ce32eb5f3456f5ff0438ff/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8191d862796c31fb7ce32eb5f3456f5ff0438ff/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=d8191d862796c31fb7ce32eb5f3456f5ff0438ff", "patch": "@@ -2480,6 +2480,33 @@ find_splittable_regs (unroll_type, loop_start, loop_end, end_insert_before,\n   return result;\n }\n \n+/* Return 1 if the first and last unrolled copy of the address giv V is valid\n+   for the instruction that is using it.  Do not make any changes to that\n+   instruction.  */\n+\n+static int\n+verify_addresses (v, giv_inc, unroll_number)\n+     struct induction *v;\n+     rtx giv_inc;\n+     int unroll_number;\n+{\n+  int ret = 1;\n+  rtx orig_addr = *v->location;\n+  rtx last_addr = plus_constant (v->dest_reg,\n+\t\t\t\t INTVAL (giv_inc) * (unroll_number - 1));\n+\n+  /* First check to see if either address would fail.  */\n+  if (! validate_change (v->insn, v->location, v->dest_reg, 0)\n+      || ! validate_change (v->insn, v->location, last_addr, 0))\n+    ret = 0;\n+\n+  /* Now put things back the way they were before.  This will always\n+   succeed.  */\n+  validate_change (v->insn, v->location, orig_addr, 0);\n+\n+  return ret;\n+}\n+\n /* For every giv based on the biv BL, check to determine whether it is\n    splittable.  This is a subroutine to find_splittable_regs ().\n \n@@ -2711,11 +2738,7 @@ find_splittable_givs (bl, unroll_type, loop_start, loop_end, increment,\n \t\t\t Try to validate both the first and the last\n \t\t\t address resulting from loop unrolling, if\n \t\t\t one fails, then can't do const elim here.  */\n-\t\t      if (memory_address_p (v->mem_mode, v->dest_reg)\n-\t\t\t  && memory_address_p (v->mem_mode,\n-\t\t\t\t       plus_constant (v->dest_reg,\n-\t\t\t\t\t\t      INTVAL (giv_inc)\n-\t\t\t\t\t\t      * (unroll_number - 1))))\n+\t\t      if (! verify_addresses (v, giv_inc, unroll_number))\n \t\t\t{\n \t\t\t  /* Save the negative of the eliminated const, so\n \t\t\t     that we can calculate the dest_reg's increment\n@@ -2736,13 +2759,10 @@ find_splittable_givs (bl, unroll_type, loop_start, loop_end, increment,\n \t\t  \n \t\t  /* If the address hasn't been checked for validity yet, do so\n \t\t     now, and fail completely if either the first or the last\n-\t\t     unrolled copy of the address is not a valid address.  */\n+\t\t     unrolled copy of the address is not a valid address\n+\t\t     for the instruction that uses it.  */\n \t\t  if (v->dest_reg == tem\n-\t\t      && (! memory_address_p (v->mem_mode, v->dest_reg)\n-\t\t\t  || ! memory_address_p (v->mem_mode,\n-\t\t\t\t plus_constant (v->dest_reg,\n-\t\t\t\t\t\tINTVAL (giv_inc)\n-\t\t\t\t\t\t* (unroll_number -1)))))\n+\t\t      && ! verify_addresses (v, giv_inc, unroll_number))\n \t\t    {\n \t\t      if (loop_dump_stream)\n \t\t\tfprintf (loop_dump_stream,\n@@ -2788,11 +2808,7 @@ find_splittable_givs (bl, unroll_type, loop_start, loop_end, increment,\n \t\t  \n \t\t  /* Check the resulting address for validity, and fail\n \t\t     if the resulting address would be invalid.  */\n-\t\t  if (! memory_address_p (v->mem_mode, v->dest_reg)\n-\t\t      || ! memory_address_p (v->mem_mode,\n-\t\t\t\t     plus_constant (v->dest_reg,\n-\t\t\t\t\t\t    INTVAL (giv_inc) *\n-\t\t\t\t\t\t    (unroll_number -1))))\n+\t\t  if (! verify_addresses (v, giv_inc, unroll_number))\n \t\t    {\n \t\t      if (loop_dump_stream)\n \t\t\tfprintf (loop_dump_stream,"}]}