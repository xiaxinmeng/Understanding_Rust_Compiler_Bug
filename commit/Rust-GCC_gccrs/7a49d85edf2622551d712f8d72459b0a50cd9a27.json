{"sha": "7a49d85edf2622551d712f8d72459b0a50cd9a27", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2E0OWQ4NWVkZjI2MjI1NTFkNzEyZjhkNzI0NTliMGE1MGNkOWEyNw==", "commit": {"author": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2012-07-23T16:04:23Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2012-07-23T16:04:23Z"}, "message": "re PR target/53961 (internal compiler error: in memory_address_length, at config/i386/i386.c:23341)\n\n\tPR target/53961\n\t* config/i386/i386.md (*lea): Add asserts to detect invalid addresses.\n\t* config/i386/i386.c (ix86_print_operand_address): Ditto.\n\t(ix86_decompose_address): Allow (zero_extend:DI (subreg:SI (...)))\n\taddresses.  Prevent zero extensions of CONST_INT operands.\n\nFrom-SVN: r189787", "tree": {"sha": "c9149de5c2bddc5d5d95c88d44595c0c603cc26f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c9149de5c2bddc5d5d95c88d44595c0c603cc26f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7a49d85edf2622551d712f8d72459b0a50cd9a27", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a49d85edf2622551d712f8d72459b0a50cd9a27", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a49d85edf2622551d712f8d72459b0a50cd9a27", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a49d85edf2622551d712f8d72459b0a50cd9a27/comments", "author": null, "committer": null, "parents": [{"sha": "3c2c4f22022ec41b2a9819244e961e5a267cbd8b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c2c4f22022ec41b2a9819244e961e5a267cbd8b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c2c4f22022ec41b2a9819244e961e5a267cbd8b"}], "stats": {"total": 75, "additions": 56, "deletions": 19}, "files": [{"sha": "a34897f013600829656e9533114653462e981a59", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a49d85edf2622551d712f8d72459b0a50cd9a27/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a49d85edf2622551d712f8d72459b0a50cd9a27/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7a49d85edf2622551d712f8d72459b0a50cd9a27", "patch": "@@ -1,3 +1,11 @@\n+2012-07-23  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\tPR target/53961\n+\t* config/i386/i386.md (*lea): Add asserts to detect invalid addresses.\n+\t* config/i386/i386.c (ix86_print_operand_address): Ditto.\n+\t(ix86_decompose_address): Allow (zero_extend:DI (subreg:SI (...)))\n+\taddresses.  Prevent zero extensions of CONST_INT operands.\n+\n 2012-07-22  Steven Bosscher  <steven@gcc.gnu.org>\n \n \t* sbitmap.h (struct int_list): Remove.\n@@ -50,7 +58,7 @@\n \n 2012-07-22  Steven Bosscher <steven@gcc.gnu.org>\n \n-\t* opts.c (common_handle_option): Do not set \n+\t* opts.c (common_handle_option): Do not set\n \tflag_value_profile_transformations for -fprofile-generate.\n \t* profile.c (instrument_values): Use COUNTER_FOR_HIST_TYPE.\n \t(BB_TO_GCOV_INDEX): Remove."}, {"sha": "13e0fdc1135213cad58454dd703857cfc8ca6fb2", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 36, "deletions": 16, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a49d85edf2622551d712f8d72459b0a50cd9a27/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a49d85edf2622551d712f8d72459b0a50cd9a27/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=7a49d85edf2622551d712f8d72459b0a50cd9a27", "patch": "@@ -11576,22 +11576,17 @@ ix86_decompose_address (rtx addr, struct ix86_address *out)\n   int retval = 1;\n   enum ix86_address_seg seg = SEG_DEFAULT;\n \n-  /* Allow SImode subregs of DImode addresses,\n-     they will be emitted with addr32 prefix.  */\n-  if (TARGET_64BIT && GET_MODE (addr) == SImode)\n-    {\n-      if (GET_CODE (addr) == SUBREG\n-\t  && GET_MODE (XEXP (addr, 0)) == DImode)\n-\taddr = SUBREG_REG (addr);\n-    }\n-\n   /* Allow zero-extended SImode addresses,\n      they will be emitted with addr32 prefix.  */\n-  else if (TARGET_64BIT && GET_MODE (addr) == DImode)\n+  if (TARGET_64BIT && GET_MODE (addr) == DImode)\n     {\n       if (GET_CODE (addr) == ZERO_EXTEND\n \t  && GET_MODE (XEXP (addr, 0)) == SImode)\n-\taddr = XEXP (addr, 0);\n+\t{\n+\t  addr = XEXP (addr, 0);\n+\t  if (CONST_INT_P (addr))\n+\t    return 0;\n+\t}\t      \n       else if (GET_CODE (addr) == AND\n \t       && const_32bit_mask (XEXP (addr, 1), DImode))\n \t{\n@@ -11600,14 +11595,31 @@ ix86_decompose_address (rtx addr, struct ix86_address *out)\n \t  /* Adjust SUBREGs.  */\n \t  if (GET_CODE (addr) == SUBREG\n \t      && GET_MODE (SUBREG_REG (addr)) == SImode)\n-\t    addr = SUBREG_REG (addr);\n+\t    {\n+\t      addr = SUBREG_REG (addr);\n+\t      if (CONST_INT_P (addr))\n+\t\treturn 0;\n+\t    }\n \t  else if (GET_MODE (addr) == DImode)\n \t    addr = gen_rtx_SUBREG (SImode, addr, 0);\n \t  else if (GET_MODE (addr) != VOIDmode)\n \t    return 0;\n \t}\n     }\n \n+  /* Allow SImode subregs of DImode addresses,\n+     they will be emitted with addr32 prefix.  */\n+  if (TARGET_64BIT && GET_MODE (addr) == SImode)\n+    {\n+      if (GET_CODE (addr) == SUBREG\n+\t  && GET_MODE (SUBREG_REG (addr)) == DImode)\n+\t{\n+\t  addr = SUBREG_REG (addr);\n+\t  if (CONST_INT_P (addr))\n+\t    return 0;\n+\t}\n+    }\n+\n   if (REG_P (addr))\n     base = addr;\n   else if (GET_CODE (addr) == SUBREG)\n@@ -14765,11 +14777,19 @@ ix86_print_operand_address (FILE *file, rtx addr)\n   else\n     {\n       /* Print SImode register names to force addr32 prefix.  */\n-      if (TARGET_64BIT\n-\t  && (GET_CODE (addr) == SUBREG\n-\t      || GET_CODE (addr) == ZERO_EXTEND\n-\t      || GET_CODE (addr) == AND))\n+      if (GET_CODE (addr) == SUBREG)\n+\t{\n+\t  gcc_assert (TARGET_64BIT);\n+\t  gcc_assert (GET_MODE (addr) == SImode);\n+\t  gcc_assert (GET_MODE (SUBREG_REG (addr)) == DImode);\n+\t  gcc_assert (!code);\n+\t  code = 'l';\n+\t}\n+      else if (GET_CODE (addr) == ZERO_EXTEND\n+\t       || GET_CODE (addr) == AND)\n \t{\n+\t  gcc_assert (TARGET_64BIT);\n+\t  gcc_assert (GET_MODE (addr) == DImode);\n \t  gcc_assert (!code);\n \t  code = 'l';\n \t}"}, {"sha": "114ad134468d75c7aa433e230d368254d2cf3109", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a49d85edf2622551d712f8d72459b0a50cd9a27/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a49d85edf2622551d712f8d72459b0a50cd9a27/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=7a49d85edf2622551d712f8d72459b0a50cd9a27", "patch": "@@ -5458,10 +5458,19 @@\n   rtx addr = operands[1];\n \n   if (GET_CODE (addr) == SUBREG)\n-    return \"lea{l}\\t{%E1, %0|%0, %E1}\";\n+    {\n+      gcc_assert (TARGET_64BIT);\n+      gcc_assert (<MODE>mode == SImode);\n+      gcc_assert (GET_MODE (SUBREG_REG (addr)) == DImode);\n+      return \"lea{l}\\t{%E1, %0|%0, %E1}\";\n+    }\n   else if (GET_CODE (addr) == ZERO_EXTEND\n \t   || GET_CODE (addr) == AND)\n-    return \"lea{l}\\t{%E1, %k0|%k0, %E1}\";\n+    {\n+      gcc_assert (TARGET_64BIT);\n+      gcc_assert (<MODE>mode == DImode);\n+      return \"lea{l}\\t{%E1, %k0|%k0, %E1}\";\n+    }\n   else \n     return \"lea{<imodesuffix>}\\t{%E1, %0|%0, %E1}\";\n }"}]}