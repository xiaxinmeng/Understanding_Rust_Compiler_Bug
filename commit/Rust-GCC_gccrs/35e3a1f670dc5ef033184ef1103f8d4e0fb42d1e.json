{"sha": "35e3a1f670dc5ef033184ef1103f8d4e0fb42d1e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzVlM2ExZjY3MGRjNWVmMDMzMTg0ZWYxMTAzZjhkNGUwZmI0MmQxZQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2020-12-08T22:53:43Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2021-04-28T09:38:09Z"}, "message": "[Ada] Eliminate early roundoff error for Long_Long_Float on x86\n\ngcc/ada/\n\n\t* libgnat/s-valrea.adb (Fast2Sum): New function.\n\t(Integer_to_Real): Use it in an iterated addition with exact\n\terror handling for the case where an extra digit is needed.\n\tMove local variable now only used in the exponentiation case.", "tree": {"sha": "0904778406591716d134528a8f56410b660f3df3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0904778406591716d134528a8f56410b660f3df3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/35e3a1f670dc5ef033184ef1103f8d4e0fb42d1e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35e3a1f670dc5ef033184ef1103f8d4e0fb42d1e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/35e3a1f670dc5ef033184ef1103f8d4e0fb42d1e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35e3a1f670dc5ef033184ef1103f8d4e0fb42d1e/comments", "author": null, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9d5f3b7a694ceb774330d45894b38e34bb90f86a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d5f3b7a694ceb774330d45894b38e34bb90f86a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9d5f3b7a694ceb774330d45894b38e34bb90f86a"}], "stats": {"total": 100, "additions": 84, "deletions": 16}, "files": [{"sha": "99dd25d616c5d19d276a05c1c2f711e81d39e6d7", "filename": "gcc/ada/libgnat/s-valrea.adb", "status": "modified", "additions": 84, "deletions": 16, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35e3a1f670dc5ef033184ef1103f8d4e0fb42d1e/gcc%2Fada%2Flibgnat%2Fs-valrea.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35e3a1f670dc5ef033184ef1103f8d4e0fb42d1e/gcc%2Fada%2Flibgnat%2Fs-valrea.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-valrea.adb?ref=35e3a1f670dc5ef033184ef1103f8d4e0fb42d1e", "patch": "@@ -46,7 +46,7 @@ package body System.Val_Real is\n    --  If the mantissa of the floating-point type is almost as large as the\n    --  unsigned type, we do not have enough space for an extra digit in the\n    --  unsigned type so we handle the extra digit separately, at the cost of\n-   --  a potential roundoff error.\n+   --  a bit more work in Integer_to_Real.\n \n    Precision_Limit : constant Uns :=\n      (if Need_Extra then 2**Num'Machine_Mantissa - 1 else 2**Uns'Size - 1);\n@@ -76,6 +76,10 @@ package body System.Val_Real is\n       7  => 5836,  8 => 5461,  9 => 5168, 10 => 4932, 11 => 4736,\n       12 => 4570, 13 => 4427, 14 => 4303, 15 => 4193, 16 => 4095);\n \n+   function Fast2Sum (A, B : Num; Err : in out Num) return Num;\n+   --  This is the classical Fast2Sum function assuming round to nearest,\n+   --  with the error accumulated into Err.\n+\n    function Integer_to_Real\n      (Str   : String;\n       Val   : Uns;\n@@ -85,6 +89,25 @@ package body System.Val_Real is\n       Minus : Boolean) return Num;\n    --  Convert the real value from integer to real representation\n \n+   --------------\n+   -- Fast2Sum --\n+   --------------\n+\n+   function Fast2Sum (A, B : Num; Err : in out Num) return Num is\n+      S, Z : Num;\n+\n+   begin\n+      pragma Assert (abs (A) >= abs (B));\n+\n+      S := A + B;\n+      Z := S - A;\n+      Z := B - Z;\n+\n+      Err := Err + Z;\n+\n+      return S;\n+   end Fast2Sum;\n+\n    ---------------------\n    -- Integer_to_Real --\n    ---------------------\n@@ -110,8 +133,6 @@ package body System.Val_Real is\n                   else  raise Program_Error);\n       --  Maximum exponent of the base that can fit in Num\n \n-      B : constant Num := Num (Base);\n-\n       R_Val : Num;\n       S     : Integer := Scale;\n \n@@ -129,12 +150,53 @@ package body System.Val_Real is\n \n       R_Val := Num (Val);\n \n-      --  Take into account the extra digit, if need be. In this case, the\n-      --  three operands are exact, so using an FMA would be ideal.\n+      --  Take into account the extra digit, i.e. do the two computations\n+\n+      --    (1)  R_Val := R_Val * Num (B) + Num (Extra)\n+      --    (2)  S := S - 1\n+\n+      --  In the first, the three operands are exact, so using an FMA would\n+      --  be ideal, but we are most likely running on the x87 FPU, hence we\n+      --  may not have one. That is why we turn the multiplication into an\n+      --  iterated addition with exact error handling, so that we can do a\n+      --  single rounding at the end.\n \n       if Need_Extra and then Extra > 0 then\n-         R_Val := R_Val * B + Num (Extra);\n-         S := S - 1;\n+         declare\n+            B : Unsigned := Base;\n+\n+            Acc : Num := 0.0;\n+            Err : Num := 0.0;\n+            Fac : Num := R_Val;\n+\n+         begin\n+            loop\n+               --  If B is odd, add one factor. Note that the accumulator is\n+               --  never larger than the factor at this point (it is in fact\n+               --  never larger than the factor minus the initial value).\n+\n+               if B rem 2 /= 0 then\n+                  Acc := (if Acc = 0.0 then Fac else Fast2Sum (Fac, Acc, Err));\n+                  exit when B = 1;\n+               end if;\n+\n+               --  Now B is (morally) even, halve it and double the factor,\n+               --  which is always an exact operation.\n+\n+               B := B / 2;\n+               Fac := Fac * 2.0;\n+            end loop;\n+\n+            --  Add Extra to the error, which are both small integers\n+\n+            Err := Err + Num (Extra);\n+\n+            --  Acc + Err is the exact result before rounding\n+\n+            R_Val := Acc + Err;\n+\n+            S := S - 1;\n+         end;\n       end if;\n \n       --  Compute the final value\n@@ -207,17 +269,23 @@ package body System.Val_Real is\n             --  an artificial underflow.\n \n             when others =>\n-               if S > 0 then\n-                  R_Val := R_Val * B ** S;\n+               declare\n+                  B : constant Num := Num (Base);\n \n-               else\n-                  if S < -Maxexp then\n-                     R_Val := R_Val / B ** Maxexp;\n-                     S := S + Maxexp;\n-                  end if;\n+               begin\n \n-                  R_Val := R_Val / B ** (-S);\n-               end if;\n+                  if S > 0 then\n+                     R_Val := R_Val * B ** S;\n+\n+                  else\n+                     if S < -Maxexp then\n+                        R_Val := R_Val / B ** Maxexp;\n+                        S := S + Maxexp;\n+                     end if;\n+\n+                     R_Val := R_Val / B ** (-S);\n+                  end if;\n+               end;\n          end case;\n       end if;\n "}]}