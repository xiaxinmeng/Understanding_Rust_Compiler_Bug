{"sha": "f7685b6677db3979392d7a063d4660b84c461c42", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Zjc2ODViNjY3N2RiMzk3OTM5MmQ3YTA2M2Q0NjYwYjg0YzQ2MWM0Mg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2013-12-12T17:55:44Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2013-12-12T17:55:44Z"}, "message": "re PR middle-end/59470 (libstdc++ miscompilation after r205709)\n\n\tPR middle-end/59470\n\t* g++.dg/opt/pr59470.C: New test.\n\nFrom-SVN: r205934", "tree": {"sha": "608448db26b64345422f7f113d9c8bcfd21a3d2a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/608448db26b64345422f7f113d9c8bcfd21a3d2a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f7685b6677db3979392d7a063d4660b84c461c42", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7685b6677db3979392d7a063d4660b84c461c42", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f7685b6677db3979392d7a063d4660b84c461c42", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7685b6677db3979392d7a063d4660b84c461c42/comments", "author": null, "committer": null, "parents": [{"sha": "ea56ff71a467ff839650a749544255cf6d48ec6f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea56ff71a467ff839650a749544255cf6d48ec6f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea56ff71a467ff839650a749544255cf6d48ec6f"}], "stats": {"total": 195, "additions": 194, "deletions": 1}, "files": [{"sha": "d8e75467d8c226bfc33dabfd3f15404f9d98c897", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7685b6677db3979392d7a063d4660b84c461c42/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7685b6677db3979392d7a063d4660b84c461c42/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f7685b6677db3979392d7a063d4660b84c461c42", "patch": "@@ -1,3 +1,8 @@\n+2013-12-12  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR middle-end/59470\n+\t* g++.dg/opt/pr59470.C: New test.\n+\n 2013-12-12  Max Ostapenko  <m.ostapenko@partner.samsung.com>\n \n \t* c-c++-common/tsan/free_race2.c: New file.\n@@ -6,7 +11,7 @@\n \t* c-c++-common/tsan/race_on_mutex2.c: Likewise.\n \t* c-c++-common/tsan/simple_race.c: Likewise.\n \t* c-c++-common/tsan/simple_stack.c: Likewise.\n-\t* g++.dg/tsan/aligned_vs_unaligned_race.C: Likewise. Test applies only on x86_64-linux targets. \n+\t* g++.dg/tsan/aligned_vs_unaligned_race.C: Likewise.\n \t* g++.dg/tsan/atomic_free.C: Likewise.\n \t* g++.dg/tsan/atomic_free2.C: Likewise.\n \t* g++.dg/tsan/benign_race.C: Likewise."}, {"sha": "4698ab717d225b2f645f14425afb9e00375ab153", "filename": "gcc/testsuite/g++.dg/opt/pr59470.C", "status": "added", "additions": 188, "deletions": 0, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7685b6677db3979392d7a063d4660b84c461c42/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr59470.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7685b6677db3979392d7a063d4660b84c461c42/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr59470.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr59470.C?ref=f7685b6677db3979392d7a063d4660b84c461c42", "patch": "@@ -0,0 +1,188 @@\n+// PR middle-end/59470\n+// { dg-do run }\n+// { dg-options \"-O2 -fstack-protector\" }\n+// { dg-additional-options \"-fPIC\" { target fpic } }\n+// { dg-require-effective-target fstack_protector }\n+\n+struct A\n+{\n+  int a1;\n+  A () throw () : a1 (0) {}\n+};\n+\n+struct B\n+{\n+  unsigned int b1 () throw ();\n+};\n+\n+__attribute__((noinline, noclone)) unsigned int\n+B::b1 () throw ()\n+{\n+  asm volatile (\"\" : : : \"memory\");\n+  return 0;\n+}\n+\n+struct C\n+{\n+  const A **c1;\n+  void c2 (const A *, unsigned int);\n+};\n+\n+__attribute__((noinline, noclone)) void\n+C::c2 (const A *, unsigned int)\n+{\n+  asm volatile (\"\" : : : \"memory\");\n+}\n+\n+struct D\n+{\n+  C *d1;\n+};\n+\n+struct E\n+{\n+  int e1;\n+  int e2;\n+  D e3;\n+};\n+\n+struct F\n+{\n+  virtual int f1 (const char * s, int n);\n+};\n+\n+struct G\n+{\n+  F *g1;\n+  bool g2;\n+  G & g3 (const char * ws, int len)\n+  {\n+    if (__builtin_expect (!g2, true)\n+\t&& __builtin_expect (this->g1->f1 (ws, len) != len, false))\n+      g2 = true;\n+    return *this;\n+  }\n+};\n+\n+struct H : public A\n+{\n+  const char *h1;\n+  unsigned int h2;\n+  bool h3;\n+  const char *h4;\n+  char h5;\n+  char h6;\n+  char h7[31];\n+  bool h8;\n+  H () : h1 (0), h2 (0), h4 (0), h5 (0), h6 (0), h8 (false) {}\n+  void h9 (const D &) __attribute__((noinline, noclone));\n+};\n+\n+void\n+H::h9 (const D &)\n+{\n+  h3 = true;\n+  __builtin_memset (h7, 0, sizeof (h7));\n+  asm volatile (\"\" : : : \"memory\");\n+};\n+\n+B b;\n+\n+inline const H *\n+foo (const D &x)\n+{\n+  const unsigned int i = b.b1 ();\n+  const A **j = x.d1->c1;\n+  if (!j[i])\n+    {\n+      H *k = 0;\n+      try\n+\t{\n+\t  k = new H;\n+\t  k->h9 (x);\n+\t}\n+      catch (...)\n+\t{\n+\t}\n+      x.d1->c2 (k, i);\n+    }\n+    return static_cast <const H *>(j[i]);\n+}\n+\n+__attribute__((noinline, noclone)) int\n+bar (char *x, unsigned long v, const char *y, int z, bool w)\n+{\n+  asm volatile (\"\" : : \"r\" (x), \"r\" (v), \"r\" (y) : \"memory\");\n+  asm volatile (\"\" : : \"r\" (z), \"r\" (w) : \"memory\");\n+  return 8;\n+}\n+\n+__attribute__((noinline, noclone)) void\n+baz (void *z, const char *g, unsigned int h, char s, E &e, char *n, char *c, int &l)\n+{\n+  asm volatile (\"\" : : \"r\" (z), \"r\" (g), \"r\" (h) : \"memory\");\n+  asm volatile (\"\" : : \"r\" (s), \"r\" (&e), \"r\" (n) : \"memory\");\n+  asm volatile (\"\" : : \"r\" (c), \"r\" (&l) : \"memory\");\n+  if (n == c)\n+    __builtin_abort ();\n+  int i = 0;\n+  asm (\"\" : \"+r\" (i));\n+  if (i == 0)\n+    __builtin_exit (0);\n+}\n+\n+__attribute__((noinline, noclone)) G\n+test (void *z, G s, E &x, char, long v)\n+{\n+  const D &d = x.e3;\n+  const H *h = foo (d);\n+  const char *q = h->h7;\n+  const int f = x.e2;\n+  const int i = 5 * sizeof (long);\n+  char *c = static_cast <char *>(__builtin_alloca (i));\n+  const int b = f & 74;\n+  const bool e = (b != 64 && b != 8);\n+  const unsigned long u = ((v > 0 || !e) ? (unsigned long) v : -(unsigned long) v);\n+  int l = bar (c + i, u, q, f, e);\n+  c += i - l;\n+  if (h->h3)\n+    {\n+      char *c2 = static_cast <char *>(__builtin_alloca ((l + 1) * 2));\n+      baz (z, h->h1, h->h2, h->h6, x, c2 + 2, c, l);\n+      c = c2 + 2;\n+    }\n+  if (__builtin_expect (e, true))\n+    {\n+    }\n+  else if ((f & 4096) && v)\n+    {\n+      {\n+\tconst bool m = f & 176;\n+\t*--c = q[m];\n+\t*--c = q[1];\n+      }\n+    }\n+  const int w = x.e1;\n+  if (w > l)\n+    {\n+      char * c3 = static_cast <char *>(__builtin_alloca (w));\n+      c = c3;\n+    }\n+  return s.g3 (c, l);\n+}\n+\n+int\n+main ()\n+{\n+  H h;\n+  const A *j[1];\n+  C c;\n+  G g;\n+  E e;\n+  h.h9 (e.e3);\n+  j[0] = &h;\n+  c.c1 = j;\n+  e.e3.d1 = &c;\n+  test (0, g, e, 0, 0);\n+  __builtin_abort ();\n+}"}]}