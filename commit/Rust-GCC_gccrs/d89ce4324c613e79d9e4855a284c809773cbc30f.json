{"sha": "d89ce4324c613e79d9e4855a284c809773cbc30f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDg5Y2U0MzI0YzYxM2U3OWQ5ZTQ4NTVhMjg0YzgwOTc3M2NiYzMwZg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2016-10-12T13:53:46Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2016-10-12T13:53:46Z"}, "message": "[multiple changes]\n\n2016-10-12  Ed Schonberg  <schonberg@adacore.com>\n\n\t* lib-writ.adb (Write_ALI): Removal of unused file entries from\n\tdependency list must be performed before the list is sorted,\n\tso that the dependency number of other files is properly set-up\n\tfor use in tools that relate entity information to the unit in\n\twhich they are declared.\n\n2016-10-12  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_aggr.adb (Initialize_Ctrl_Array_Component):\n\tCreate a copy of the initialization expression to avoid sharing\n\tit between multiple components.\n\n2016-10-12  Yannick Moy  <moy@adacore.com>\n\n\t* einfo.adb, einfo.ads (Has_Partial_Visible_Refinement): New flag\n\tin abtract states.\n\t(Has_Non_Null_Visible_Refinement): Return true for patial refinement.\n\t(Partial_Refinement_Constituents): New function returns the full or\n\tpartial refinement constituents depending on scope.\n\t* sem_ch3.adb (Analyze_Declarations): Remove partial visible\n\trefinements when exiting the scope of a package spec or body\n\tand those partial refinements are not in scope afterwards.\n\t* sem_ch7.adb, sem_ch7.ads (Install_Partial_Declarations): Mark\n\tabstract states of parent units with partial refinement so that\n\tit is visible.\n\t* sem_prag.adb (Analyze_Part_Of_In_Decl_Part): Mark enclosing\n\tabstract state if any as having partial refinement in that scope.\n\t(Analyze_Refined_Global_In_Decl_Part): Check constituent usage\n\tbased on full or partial refinement depending on scope.\n\n2016-10-12  Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_ch4.adb (Expand_N_Type_Conversion): If the target type\n\thas an invariant aspect, insert invariant call at the proper\n\tplace in the code rather than rewriting the expression as an\n\texpression with actions, to prevent spurious semantic errors on\n\tthe rewritten conversion when it is the object in a renaming.\n\nFrom-SVN: r241048", "tree": {"sha": "6ad2ca58ff5864ec425cb212773f1f9daf273009", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6ad2ca58ff5864ec425cb212773f1f9daf273009"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d89ce4324c613e79d9e4855a284c809773cbc30f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d89ce4324c613e79d9e4855a284c809773cbc30f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d89ce4324c613e79d9e4855a284c809773cbc30f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d89ce4324c613e79d9e4855a284c809773cbc30f/comments", "author": null, "committer": null, "parents": [{"sha": "432b6d957261f946836f2a4d1cbcef3eace17571", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/432b6d957261f946836f2a4d1cbcef3eace17571", "html_url": "https://github.com/Rust-GCC/gccrs/commit/432b6d957261f946836f2a4d1cbcef3eace17571"}], "stats": {"total": 316, "additions": 243, "deletions": 73}, "files": [{"sha": "db7b6c82b55e80c611bef8dd020be4418c97dcd5", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d89ce4324c613e79d9e4855a284c809773cbc30f/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d89ce4324c613e79d9e4855a284c809773cbc30f/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=d89ce4324c613e79d9e4855a284c809773cbc30f", "patch": "@@ -1,3 +1,43 @@\n+2016-10-12  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* lib-writ.adb (Write_ALI): Removal of unused file entries from\n+\tdependency list must be performed before the list is sorted,\n+\tso that the dependency number of other files is properly set-up\n+\tfor use in tools that relate entity information to the unit in\n+\twhich they are declared.\n+\n+2016-10-12  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_aggr.adb (Initialize_Ctrl_Array_Component):\n+\tCreate a copy of the initialization expression to avoid sharing\n+\tit between multiple components.\n+\n+2016-10-12  Yannick Moy  <moy@adacore.com>\n+\n+\t* einfo.adb, einfo.ads (Has_Partial_Visible_Refinement): New flag\n+\tin abtract states.\n+\t(Has_Non_Null_Visible_Refinement): Return true for patial refinement.\n+\t(Partial_Refinement_Constituents): New function returns the full or\n+\tpartial refinement constituents depending on scope.\n+\t* sem_ch3.adb (Analyze_Declarations): Remove partial visible\n+\trefinements when exiting the scope of a package spec or body\n+\tand those partial refinements are not in scope afterwards.\n+\t* sem_ch7.adb, sem_ch7.ads (Install_Partial_Declarations): Mark\n+\tabstract states of parent units with partial refinement so that\n+\tit is visible.\n+\t* sem_prag.adb (Analyze_Part_Of_In_Decl_Part): Mark enclosing\n+\tabstract state if any as having partial refinement in that scope.\n+\t(Analyze_Refined_Global_In_Decl_Part): Check constituent usage\n+\tbased on full or partial refinement depending on scope.\n+\n+2016-10-12  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* exp_ch4.adb (Expand_N_Type_Conversion): If the target type\n+\thas an invariant aspect, insert invariant call at the proper\n+\tplace in the code rather than rewriting the expression as an\n+\texpression with actions, to prevent spurious semantic errors on\n+\tthe rewritten conversion when it is the object in a renaming.\n+\n 2016-10-12  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* exp_ch5.adb, sem_ch3.adb, exp_ch9.adb, a-tags.adb, sem_prag.adb,"}, {"sha": "dedc8a3312c3c6643b9f577b3554b9ae5ac7bbaa", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 42, "deletions": 6, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d89ce4324c613e79d9e4855a284c809773cbc30f/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d89ce4324c613e79d9e4855a284c809773cbc30f/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=d89ce4324c613e79d9e4855a284c809773cbc30f", "patch": "@@ -610,8 +610,8 @@ package body Einfo is\n    --    Is_Actual_Subtype               Flag293\n    --    Has_Pragma_Unused               Flag294\n    --    Is_Ignored_Transient            Flag295\n+   --    Has_Partial_Visible_Refinement  Flag296\n \n-   --    (unused)                        Flag296\n    --    (unused)                        Flag297\n    --    (unused)                        Flag298\n    --    (unused)                        Flag299\n@@ -1682,6 +1682,12 @@ package body Einfo is\n       return Flag232 (Id);\n    end Has_Own_Invariants;\n \n+   function Has_Partial_Visible_Refinement (Id : E) return B is\n+   begin\n+      pragma Assert (Ekind (Id) = E_Abstract_State);\n+      return Flag296 (Id);\n+   end Has_Partial_Visible_Refinement;\n+\n    function Has_Per_Object_Constraint (Id : E) return B is\n    begin\n       return Flag154 (Id);\n@@ -4698,6 +4704,12 @@ package body Einfo is\n       Set_Flag232 (Id, V);\n    end Set_Has_Own_Invariants;\n \n+   procedure Set_Has_Partial_Visible_Refinement (Id : E; V : B := True) is\n+   begin\n+      pragma Assert (Ekind (Id) = E_Abstract_State);\n+      Set_Flag296 (Id, V);\n+   end Set_Has_Partial_Visible_Refinement;\n+\n    procedure Set_Has_Per_Object_Constraint (Id : E; V : B := True) is\n    begin\n       Set_Flag154 (Id, V);\n@@ -7485,13 +7497,14 @@ package body Einfo is\n       pragma Assert (Ekind (Id) = E_Abstract_State);\n       Constits := Refinement_Constituents (Id);\n \n-      --  For a refinement to be non-null, the first constituent must be\n-      --  anything other than null.\n+      --  A partial refinement is always non-null. For a full refinement to be\n+      --  non-null, the first constituent must be anything other than null.\n \n       return\n-        Has_Visible_Refinement (Id)\n-          and then Present (Constits)\n-          and then Nkind (Node (First_Elmt (Constits))) /= N_Null;\n+        Has_Partial_Visible_Refinement (Id)\n+          or else (Has_Visible_Refinement (Id)\n+                    and then Present (Constits)\n+                    and then Nkind (Node (First_Elmt (Constits))) /= N_Null);\n    end Has_Non_Null_Visible_Refinement;\n \n    -----------------------------\n@@ -8370,6 +8383,29 @@ package body Einfo is\n       return Empty;\n    end Partial_Invariant_Procedure;\n \n+   -------------------------------------\n+   -- Partial_Refinement_Constituents --\n+   -------------------------------------\n+\n+   function Partial_Refinement_Constituents (Id : E) return L is\n+      Constits : Elist_Id;\n+\n+   begin\n+      --  \"Refinement\" is a concept applicable only to abstract states\n+\n+      pragma Assert (Ekind (Id) = E_Abstract_State);\n+      Constits := Refinement_Constituents (Id);\n+\n+      --  A refinement may be partially visible when objects declared in the\n+      --  private part of a package are subject to a Part_Of indicator.\n+\n+      if No (Constits) then\n+         Constits := Part_Of_Constituents (Id);\n+      end if;\n+\n+      return Constits;\n+   end Partial_Refinement_Constituents;\n+\n    ------------------------\n    -- Predicate_Function --\n    ------------------------"}, {"sha": "405d97815affef87244a48d2ffbe95fd643c724f", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d89ce4324c613e79d9e4855a284c809773cbc30f/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d89ce4324c613e79d9e4855a284c809773cbc30f/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=d89ce4324c613e79d9e4855a284c809773cbc30f", "patch": "@@ -1812,6 +1812,14 @@ package Einfo is\n --       one invariant of its own. The flag is also set on the full view of a\n --       private extension or a private type for completeness.\n \n+--    Has_Partial_Visible_Refinement (Flag296)\n+--       Defined in E_Abstract_State entities. Set when a state has at least\n+--       one refinement constituent subject to indicator Part_Of, and analysis\n+--       is in the region between the declaration of the first constituent for\n+--       this abstract state (in the private part of the package) and the end\n+--       of the package spec or body with visibility over this private part\n+--       (which includes the package itself and its child packages).\n+\n --    Has_Per_Object_Constraint (Flag154)\n --       Defined in E_Component entities. Set if the subtype of the component\n --       has a per object constraint. Per object constraints result from the\n@@ -3780,6 +3788,11 @@ package Einfo is\n --       Note: the reason this is marked as a synthesized attribute is that the\n --       way this is stored is as an element of the Subprograms_For_Type field.\n \n+--    Partial_Refinement_Constituents (synthesized)\n+--       Present in abstract state entities. Contains the constituents that\n+--       refine the state in its private part, in other words, all the hidden\n+--       states that indicate this abstract state in a Part_Of aspect/pragma.\n+\n --    Partial_View_Has_Unknown_Discr (Flag280)\n --       Present in all types. Set to Indicate that the partial view of a type\n --       has unknown discriminants. A default initialization of an object of\n@@ -5619,13 +5632,15 @@ package Einfo is\n    --    Non_Limited_View                    (Node19)\n    --    Encapsulating_State                 (Node32)\n    --    From_Limited_With                   (Flag159)\n+   --    Has_Partial_Visible_Refinement      (Flag296)\n    --    Has_Visible_Refinement              (Flag263)\n    --    Has_Non_Limited_View                (synth)\n    --    Has_Non_Null_Visible_Refinement     (synth)\n    --    Has_Null_Visible_Refinement         (synth)\n    --    Is_External_State                   (synth)\n    --    Is_Null_State                       (synth)\n    --    Is_Synchronized_State               (synth)\n+   --    Partial_Refinement_Constituents     (synth)\n \n    --  E_Access_Protected_Subprogram_Type\n    --    Equivalent_Type                     (Node18)\n@@ -6977,6 +6992,7 @@ package Einfo is\n    function Has_Object_Size_Clause              (Id : E) return B;\n    function Has_Out_Or_In_Out_Parameter         (Id : E) return B;\n    function Has_Own_Invariants                  (Id : E) return B;\n+   function Has_Partial_Visible_Refinement      (Id : E) return B;\n    function Has_Per_Object_Constraint           (Id : E) return B;\n    function Has_Pragma_Controlled               (Id : E) return B;\n    function Has_Pragma_Elaborate_Body           (Id : E) return B;\n@@ -7412,6 +7428,7 @@ package Einfo is\n    function Number_Entries                      (Id : E) return Nat;\n    function Number_Formals                      (Id : E) return Pos;\n    function Parameter_Mode                      (Id : E) return Formal_Kind;\n+   function Partial_Refinement_Constituents     (Id : E) return L;\n    function Primitive_Operations                (Id : E) return L;\n    function Root_Type                           (Id : E) return E;\n    function Safe_Emax_Value                     (Id : E) return U;\n@@ -7652,6 +7669,7 @@ package Einfo is\n    procedure Set_Has_Object_Size_Clause          (Id : E; V : B := True);\n    procedure Set_Has_Out_Or_In_Out_Parameter     (Id : E; V : B := True);\n    procedure Set_Has_Own_Invariants              (Id : E; V : B := True);\n+   procedure Set_Has_Partial_Visible_Refinement  (Id : E; V : B := True);\n    procedure Set_Has_Per_Object_Constraint       (Id : E; V : B := True);\n    procedure Set_Has_Pragma_Controlled           (Id : E; V : B := True);\n    procedure Set_Has_Pragma_Elaborate_Body       (Id : E; V : B := True);\n@@ -8444,6 +8462,7 @@ package Einfo is\n    pragma Inline (Has_Object_Size_Clause);\n    pragma Inline (Has_Out_Or_In_Out_Parameter);\n    pragma Inline (Has_Own_Invariants);\n+   pragma Inline (Has_Partial_Visible_Refinement);\n    pragma Inline (Has_Per_Object_Constraint);\n    pragma Inline (Has_Pragma_Controlled);\n    pragma Inline (Has_Pragma_Elaborate_Body);\n@@ -8959,6 +8978,7 @@ package Einfo is\n    pragma Inline (Set_Has_Object_Size_Clause);\n    pragma Inline (Set_Has_Out_Or_In_Out_Parameter);\n    pragma Inline (Set_Has_Own_Invariants);\n+   pragma Inline (Set_Has_Partial_Visible_Refinement);\n    pragma Inline (Set_Has_Per_Object_Constraint);\n    pragma Inline (Set_Has_Pragma_Controlled);\n    pragma Inline (Set_Has_Pragma_Elaborate_Body);"}, {"sha": "e83b07affdd16921ba5c483216dc8162af9d9cc2", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d89ce4324c613e79d9e4855a284c809773cbc30f/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d89ce4324c613e79d9e4855a284c809773cbc30f/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=d89ce4324c613e79d9e4855a284c809773cbc30f", "patch": "@@ -1277,6 +1277,7 @@ package body Exp_Aggr is\n          is\n             Act_Aggr   : Node_Id;\n             Act_Stmts  : List_Id;\n+            Expr       : Node_Id;\n             Fin_Call   : Node_Id;\n             Hook_Clear : Node_Id;\n \n@@ -1285,20 +1286,29 @@ package body Exp_Aggr is\n             --  in-place expansion.\n \n          begin\n+            --  Duplicate the initialization expression in case the context is\n+            --  a multi choice list or an \"others\" choice which plugs various\n+            --  holes in the aggregate. As a result the expression is no longer\n+            --  shared between the various components and is reevaluated for\n+            --  each such component.\n+\n+            Expr := New_Copy_Tree (Init_Expr);\n+            Set_Parent (Expr, Parent (Init_Expr));\n+\n             --  Perform a preliminary analysis and resolution to determine what\n             --  the initialization expression denotes. An unanalyzed function\n             --  call may appear as an identifier or an indexed component.\n \n-            if Nkind_In (Init_Expr, N_Function_Call,\n-                                    N_Identifier,\n-                                    N_Indexed_Component)\n-              and then not Analyzed (Init_Expr)\n+            if Nkind_In (Expr, N_Function_Call,\n+                               N_Identifier,\n+                               N_Indexed_Component)\n+              and then not Analyzed (Expr)\n             then\n-               Preanalyze_And_Resolve (Init_Expr, Comp_Typ);\n+               Preanalyze_And_Resolve (Expr, Comp_Typ);\n             end if;\n \n             In_Place_Expansion :=\n-              Nkind (Init_Expr) = N_Function_Call\n+              Nkind (Expr) = N_Function_Call\n                 and then not Is_Limited_Type (Comp_Typ);\n \n             --  The initialization expression is a controlled function call.\n@@ -1315,7 +1325,7 @@ package body Exp_Aggr is\n                --  generation of a transient scope, which leads to out-of-order\n                --  adjustment and finalization.\n \n-               Set_No_Side_Effect_Removal (Init_Expr);\n+               Set_No_Side_Effect_Removal (Expr);\n \n                --  When the transient component initialization is related to a\n                --  range or an \"others\", keep all generated statements within\n@@ -1341,7 +1351,7 @@ package body Exp_Aggr is\n                Process_Transient_Component\n                  (Loc        => Loc,\n                   Comp_Typ   => Comp_Typ,\n-                  Init_Expr  => Init_Expr,\n+                  Init_Expr  => Expr,\n                   Fin_Call   => Fin_Call,\n                   Hook_Clear => Hook_Clear,\n                   Aggr       => Act_Aggr,\n@@ -1356,7 +1366,7 @@ package body Exp_Aggr is\n             Initialize_Array_Component\n               (Arr_Comp  => Arr_Comp,\n                Comp_Typ  => Comp_Typ,\n-               Init_Expr => Init_Expr,\n+               Init_Expr => Expr,\n                Stmts     => Stmts);\n \n             --  At this point the array element is fully initialized. Complete"}, {"sha": "905467b8a6b28123e1e8f943360a29c3d1ec5a7d", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d89ce4324c613e79d9e4855a284c809773cbc30f/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d89ce4324c613e79d9e4855a284c809773cbc30f/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=d89ce4324c613e79d9e4855a284c809773cbc30f", "patch": "@@ -10577,15 +10577,16 @@ package body Exp_Ch4 is\n       end if;\n \n       --  Check for case of converting to a type that has an invariant\n-      --  associated with it. This required an invariant check. We convert\n+      --  associated with it. This requires an invariant check. We insert\n+      --  a call:\n \n-      --    typ (expr)\n+      --        invariant_check (typ (expr))\n \n-      --  into\n-\n-      --    do invariant_check (typ (expr)) in typ (expr);\n-\n-      --  using Duplicate_Subexpr to avoid multiple side effects\n+      --  in the code, after removing side effects from the expression.\n+      --  This is clearer than replacing the conversion into an expression\n+      --  with actions, because the context may impose additional actions\n+      --  (tag checks, membership tests, etc.) that conflict with this\n+      --  rewriting (used previously).\n \n       --  Note: the Comes_From_Source check, and then the resetting of this\n       --  flag prevents what would otherwise be an infinite recursion.\n@@ -10595,12 +10596,8 @@ package body Exp_Ch4 is\n         and then Comes_From_Source (N)\n       then\n          Set_Comes_From_Source (N, False);\n-         Rewrite (N,\n-           Make_Expression_With_Actions (Loc,\n-             Actions    => New_List (\n-               Make_Invariant_Call (Duplicate_Subexpr (N))),\n-             Expression => Duplicate_Subexpr_No_Checks (N)));\n-         Analyze_And_Resolve (N, Target_Type);\n+         Remove_Side_Effects (N);\n+         Insert_Action (N, Make_Invariant_Call (Duplicate_Subexpr (N)));\n          goto Done;\n       end if;\n "}, {"sha": "0cd615fd50458780883f0917771c313ff5c51509", "filename": "gcc/ada/lib-writ.adb", "status": "modified", "additions": 21, "deletions": 31, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d89ce4324c613e79d9e4855a284c809773cbc30f/gcc%2Fada%2Flib-writ.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d89ce4324c613e79d9e4855a284c809773cbc30f/gcc%2Fada%2Flib-writ.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-writ.adb?ref=d89ce4324c613e79d9e4855a284c809773cbc30f", "patch": "@@ -990,8 +990,27 @@ package body Lib.Writ is\n          if Cunit_Entity (Unum) = Empty\n            or else not From_Limited_With (Cunit_Entity (Unum))\n          then\n-            Num_Sdep := Num_Sdep + 1;\n-            Sdep_Table (Num_Sdep) := Unum;\n+            --  Units that are not analyzed need not appear in the dependency\n+            --  list. These units are either units appearing in limited_with\n+            --  clauses of other units, or units loaded for inlining that end\n+            --  up not inlined by a later decision of the inlining code, to\n+            --  prevent circularities. We want to exclude these files from the\n+            --  list of dependencies, so that the dependency number of other\n+            --  is correctly set, as that number is used by cross-reference\n+            --  tools to relate entity information to the unit in which they\n+            --  are declared.\n+\n+            if Present (Cunit_Entity (Unum))\n+              and then Ekind (Cunit_Entity (Unum)) = E_Void\n+              and then Nkind (Unit (Cunit (Unum))) /= N_Subunit\n+              and then Serious_Errors_Detected = 0\n+            then\n+               null;\n+\n+            else\n+               Num_Sdep := Num_Sdep + 1;\n+               Sdep_Table (Num_Sdep) := Unum;\n+            end if;\n          end if;\n       end loop;\n \n@@ -1433,32 +1452,6 @@ package body Lib.Writ is\n             Units.Table (Unum).Dependency_Num := J;\n             Sind := Units.Table (Unum).Source_Index;\n \n-            --  The dependency table also contains units that appear in the\n-            --  context of a unit loaded through a limited_with clause. These\n-            --  units are never analyzed, and thus the main unit does not\n-            --  really have a dependency on them. Subunits are always compiled\n-            --  in the context of the parent, and their file table entries are\n-            --  not properly decorated, they are recognized syntactically.\n-\n-            --  This optimization is disabled when inline is active, because\n-            --  inline may propose some bodies for inlining, and decide later\n-            --  that they may lead to circularities, in which case they are\n-            --  also left unanalyzed in the file table. There is no simple way\n-            --  to distinguish between the two kinds of unanalyzed entries,\n-            --  so simplest is to skip this step.\n-\n-            --  Actually, this optimization is always disabled, because it\n-            --  breaks gnatfind.\n-\n-            if False -- ???\n-              and then Present (Cunit_Entity (Unum))\n-              and then Ekind (Cunit_Entity (Unum)) = E_Void\n-              and then Nkind (Unit (Cunit (Unum))) /= N_Subunit\n-              and then not Inline_Active\n-            then\n-               goto Next_Unit;\n-            end if;\n-\n             Write_Info_Initiate ('D');\n             Write_Info_Char (' ');\n \n@@ -1534,9 +1527,6 @@ package body Lib.Writ is\n             end if;\n \n             Write_Info_EOL;\n-\n-         <<Next_Unit>>\n-            null;\n          end loop;\n       end;\n "}, {"sha": "a97d0172100896b1ae492ed2137b355f1d0bb2ad", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 40, "deletions": 1, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d89ce4324c613e79d9e4855a284c809773cbc30f/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d89ce4324c613e79d9e4855a284c809773cbc30f/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=d89ce4324c613e79d9e4855a284c809773cbc30f", "patch": "@@ -2178,10 +2178,17 @@ package body Sem_Ch3 is\n       --  case, add a proper spec if the body lacks one. The spec is inserted\n       --  before Body_Decl and immediately analyzed.\n \n+      procedure Remove_Partial_Visible_Refinements (Spec_Id : Entity_Id);\n+      --  Spec_Id is the entity of a package that may define abstract states,\n+      --  and in the case of a child unit, whose ancestors may define abstract\n+      --  states. If the states have partial visible refinement, remove the\n+      --  partial visibility of each constituent at the end of the package\n+      --  spec and body declarations.\n+\n       procedure Remove_Visible_Refinements (Spec_Id : Entity_Id);\n       --  Spec_Id is the entity of a package that may define abstract states.\n       --  If the states have visible refinement, remove the visibility of each\n-      --  constituent at the end of the package body declarations.\n+      --  constituent at the end of the package body declaration.\n \n       -----------------\n       -- Adjust_Decl --\n@@ -2335,6 +2342,29 @@ package body Sem_Ch3 is\n          Insert_Before_And_Analyze (Body_Decl, Decl);\n       end Handle_Late_Controlled_Primitive;\n \n+      ----------------------------------------\n+      -- Remove_Partial_Visible_Refinements --\n+      ----------------------------------------\n+\n+      procedure Remove_Partial_Visible_Refinements (Spec_Id : Entity_Id) is\n+         State_Elmt : Elmt_Id;\n+      begin\n+         if Present (Abstract_States (Spec_Id)) then\n+            State_Elmt := First_Elmt (Abstract_States (Spec_Id));\n+            while Present (State_Elmt) loop\n+               Set_Has_Partial_Visible_Refinement (Node (State_Elmt), False);\n+               Next_Elmt (State_Elmt);\n+            end loop;\n+         end if;\n+\n+         --  For a child unit, also hide the partial state refinement from\n+         --  ancestor packages.\n+\n+         if Is_Child_Unit (Spec_Id) then\n+            Remove_Partial_Visible_Refinements (Scope (Spec_Id));\n+         end if;\n+      end Remove_Partial_Visible_Refinements;\n+\n       --------------------------------\n       -- Remove_Visible_Refinements --\n       --------------------------------\n@@ -2576,6 +2606,15 @@ package body Sem_Ch3 is\n             --  restore the original state conditions.\n \n             Remove_Visible_Refinements (Corresponding_Spec (Context));\n+            Remove_Partial_Visible_Refinements (Corresponding_Spec (Context));\n+\n+         elsif Nkind (Context) = N_Package_Declaration then\n+\n+            --  Partial state refinements are visible up to the end of the\n+            --  package spec declarations. Hide the partial state refinements\n+            --  from visibility to restore the original state conditions.\n+\n+            Remove_Partial_Visible_Refinements (Corresponding_Spec (Context));\n          end if;\n \n          --  Verify that all abstract states found in any package declared in"}, {"sha": "55ec81e1f51189aecca7590da8c6066ee0e6e35a", "filename": "gcc/ada/sem_ch7.adb", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d89ce4324c613e79d9e4855a284c809773cbc30f/gcc%2Fada%2Fsem_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d89ce4324c613e79d9e4855a284c809773cbc30f/gcc%2Fada%2Fsem_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch7.adb?ref=d89ce4324c613e79d9e4855a284c809773cbc30f", "patch": "@@ -2275,6 +2275,34 @@ package body Sem_Ch7 is\n          Next_Entity (Id);\n       end loop;\n \n+      --  An abstract state is partially refined when it has at least one\n+      --  Part_Of constituent. Since these constituents are being installed\n+      --  into visibility, update the partial refinement status of any state\n+      --  defined in the associated package, subject to at least one Part_Of\n+      --  constituent.\n+\n+      if Ekind_In (P, E_Generic_Package, E_Package) then\n+         declare\n+            States     : constant Elist_Id := Abstract_States (P);\n+            State_Elmt : Elmt_Id;\n+            State_Id   : Entity_Id;\n+\n+         begin\n+            if Present (States) then\n+               State_Elmt := First_Elmt (States);\n+               while Present (State_Elmt) loop\n+                  State_Id := Node (State_Elmt);\n+\n+                  if Present (Part_Of_Constituents (State_Id)) then\n+                     Set_Has_Partial_Visible_Refinement (State_Id);\n+                  end if;\n+\n+                  Next_Elmt (State_Elmt);\n+               end loop;\n+            end if;\n+         end;\n+      end if;\n+\n       --  Indicate that the private part is currently visible, so it can be\n       --  properly reset on exit.\n "}, {"sha": "4e645adf7fb4226f1997c072a37a1a53215026fe", "filename": "gcc/ada/sem_ch7.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d89ce4324c613e79d9e4855a284c809773cbc30f/gcc%2Fada%2Fsem_ch7.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d89ce4324c613e79d9e4855a284c809773cbc30f/gcc%2Fada%2Fsem_ch7.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch7.ads?ref=d89ce4324c613e79d9e4855a284c809773cbc30f", "patch": "@@ -46,10 +46,10 @@ package Sem_Ch7 is\n    --  On entrance to a package body, make declarations in package spec\n    --  immediately visible.\n    --\n-   --  When compiling the body of a package,  both routines are called in\n+   --  When compiling the body of a package, both routines are called in\n    --  succession. When compiling the body of a child package, the call\n    --  to Install_Private_Declaration is immediate for private children,\n-   --  but is deferred until the compilation of the  private part of the\n+   --  but is deferred until the compilation of the private part of the\n    --  child for public child packages.\n \n    function Unit_Requires_Body"}, {"sha": "9b9fe82985d891ed491ad12238dd4af7776b525b", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 21, "deletions": 11, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d89ce4324c613e79d9e4855a284c809773cbc30f/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d89ce4324c613e79d9e4855a284c809773cbc30f/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=d89ce4324c613e79d9e4855a284c809773cbc30f", "patch": "@@ -3410,6 +3410,13 @@ package body Sem_Prag is\n \n          Append_Elmt (Var_Id, Constits);\n          Set_Encapsulating_State (Var_Id, Encap_Id);\n+\n+         --  A Part_Of constituent partially refines an abstract state. This\n+         --  property does not apply to protected or task units.\n+\n+         if Ekind (Encap_Id) = E_Abstract_State then\n+            Set_Has_Partial_Visible_Refinement (Encap_Id);\n+         end if;\n       end if;\n \n       --  Emit a clarification message when the encapsulator is undefined,\n@@ -18717,7 +18724,7 @@ package body Sem_Prag is\n \n             Add_Contract_Item (N, Item_Id);\n \n-            --  A variable may act as consituent of a single concurrent type\n+            --  A variable may act as constituent of a single concurrent type\n             --  which in turn could be declared after the variable. Due to this\n             --  discrepancy, the full analysis of indicator Part_Of is delayed\n             --  until the end of the enclosing declarative region (see routine\n@@ -24051,7 +24058,7 @@ package body Sem_Prag is\n \n          procedure Check_Constituent_Usage (State_Id : Entity_Id) is\n             Constits     : constant Elist_Id :=\n-                             Refinement_Constituents (State_Id);\n+                             Partial_Refinement_Constituents (State_Id);\n             Constit_Elmt : Elmt_Id;\n             Constit_Id   : Entity_Id;\n             Posted       : Boolean := False;\n@@ -24614,7 +24621,7 @@ package body Sem_Prag is\n \n          procedure Check_Constituent_Usage (State_Id : Entity_Id) is\n             Constits      : constant Elist_Id :=\n-                              Refinement_Constituents (State_Id);\n+                              Partial_Refinement_Constituents (State_Id);\n             Constit_Elmt  : Elmt_Id;\n             Constit_Id    : Entity_Id;\n             Has_Missing   : Boolean := False;\n@@ -24753,7 +24760,7 @@ package body Sem_Prag is\n \n          procedure Check_Constituent_Usage (State_Id : Entity_Id) is\n             Constits     : constant Elist_Id :=\n-                             Refinement_Constituents (State_Id);\n+                             Partial_Refinement_Constituents (State_Id);\n             Constit_Elmt : Elmt_Id;\n             Constit_Id   : Entity_Id;\n             In_Seen      : Boolean := False;\n@@ -24853,7 +24860,7 @@ package body Sem_Prag is\n \n          procedure Check_Constituent_Usage (State_Id : Entity_Id) is\n             Constits     : constant Elist_Id :=\n-                             Refinement_Constituents (State_Id);\n+                             Partial_Refinement_Constituents (State_Id);\n             Constit_Elmt : Elmt_Id;\n             Constit_Id   : Entity_Id;\n             Posted       : Boolean := False;\n@@ -24952,7 +24959,7 @@ package body Sem_Prag is\n \n          procedure Check_Constituent_Usage (State_Id : Entity_Id) is\n             Constits      : constant Elist_Id :=\n-                              Refinement_Constituents (State_Id);\n+                              Partial_Refinement_Constituents (State_Id);\n             Constit_Elmt  : Elmt_Id;\n             Constit_Id    : Entity_Id;\n             Proof_In_Seen : Boolean := False;\n@@ -25083,7 +25090,10 @@ package body Sem_Prag is\n \n             if Ekind_In (Item_Id, E_Abstract_State, E_Constant, E_Variable)\n              and then Present (Encapsulating_State (Item_Id))\n-             and then Has_Visible_Refinement (Encapsulating_State (Item_Id))\n+             and then\n+               (Has_Visible_Refinement (Encapsulating_State (Item_Id))\n+                  or else\n+                Has_Partial_Visible_Refinement (Encapsulating_State (Item_Id)))\n              and then Contains (States, Encapsulating_State (Item_Id))\n             then\n                if Global_Mode = Name_Input then\n@@ -25438,10 +25448,10 @@ package body Sem_Prag is\n       --  Non-instance case\n \n       else\n-         --  The corresponding Global pragma must mention at least one state\n-         --  witha visible refinement at the point Refined_Global is processed.\n-         --  States with null refinements need Refined_Global pragma\n-         --  (SPARK RM 7.2.4(2)).\n+         --  The corresponding Global pragma must mention at least one\n+         --  state with a visible refinement at the point Refined_Global\n+         --  is processed. States with null refinements need Refined_Global\n+         --  pragma (SPARK RM 7.2.4(2)).\n \n          if not Has_In_State\n            and then not Has_In_Out_State"}]}