{"sha": "5ec105cd718cc7a894cbfcd14f69863878ea8ab0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWVjMTA1Y2Q3MThjYzdhODk0Y2JmY2QxNGY2OTg2Mzg3OGVhOGFiMA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1998-03-05T02:42:22Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1998-03-05T02:42:22Z"}, "message": "reload.c (find_reloads): Always force (subreg (mem)) to be reloaded if WORD_REGISTER_OPERATIONS.\n\n* reload.c (find_reloads): Always force (subreg (mem)) to be\nreloaded if WORD_REGISTER_OPERATIONS.\n\nFrom-SVN: r18416", "tree": {"sha": "486ebb0478e653083409bdc4b857feeee65c7081", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/486ebb0478e653083409bdc4b857feeee65c7081"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5ec105cd718cc7a894cbfcd14f69863878ea8ab0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ec105cd718cc7a894cbfcd14f69863878ea8ab0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ec105cd718cc7a894cbfcd14f69863878ea8ab0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ec105cd718cc7a894cbfcd14f69863878ea8ab0/comments", "author": null, "committer": null, "parents": [{"sha": "ebb7b10b6d44ed8fcbc8318534bac98bc29643ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebb7b10b6d44ed8fcbc8318534bac98bc29643ef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ebb7b10b6d44ed8fcbc8318534bac98bc29643ef"}], "stats": {"total": 21, "additions": 19, "deletions": 2}, "files": [{"sha": "f5bb3fc1e3a129e784f0f441f7e6e9b752e6eb00", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ec105cd718cc7a894cbfcd14f69863878ea8ab0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ec105cd718cc7a894cbfcd14f69863878ea8ab0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5ec105cd718cc7a894cbfcd14f69863878ea8ab0", "patch": "@@ -1,3 +1,8 @@\n+Thu Mar  5 02:41:27 1998  Richard Henderson  <rth@cygnus.com>\n+\n+\t* reload.c (find_reloads): Always force (subreg (mem)) to be\n+\treloaded if WORD_REGISTER_OPERATIONS.\n+\n Thu Mar  5 02:14:44 1998  Richard Henderson  <rth@cygnus.com>\n \n \t* haifa-sched.c (free_list): Rename from free_pnd_lst."}, {"sha": "4187b120775fb1f913259ba8038d496a6aefdb75", "filename": "gcc/reload.c", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ec105cd718cc7a894cbfcd14f69863878ea8ab0/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ec105cd718cc7a894cbfcd14f69863878ea8ab0/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=5ec105cd718cc7a894cbfcd14f69863878ea8ab0", "patch": "@@ -2753,10 +2753,20 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t\t     register access.  If the data is, in fact, in memory we\n \t\t     must always load using the size assumed to be in the\n \t\t     register and let the insn do the different-sized \n-\t\t     accesses.  */\n+\t\t     accesses.\n+\n+\t\t     This is doubly true if WORD_REGISTER_OPERATIONS.  In \n+\t\t     this case eliminate_regs has left non-paradoxical\n+\t\t     subregs for push_reloads to see.  Make sure it does\n+\t\t     by forcing the reload.\n+\n+\t\t     ??? When is it right at this stage to have a subreg\n+\t\t     of a mem that is _not_ to be handled specialy?  IMO\n+\t\t     those should have been reduced to just a mem.  */\n \t\t  || ((GET_CODE (operand) == MEM\n \t\t       || (GET_CODE (operand)== REG\n \t\t\t   && REGNO (operand) >= FIRST_PSEUDO_REGISTER))\n+#ifndef WORD_REGISTER_OPERATIONS\n \t\t      && (((GET_MODE_BITSIZE (GET_MODE (operand))\n \t\t\t    < BIGGEST_ALIGNMENT)\n \t\t\t   && (GET_MODE_SIZE (operand_mode[i])\n@@ -2771,7 +2781,9 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t\t\t      && INTEGRAL_MODE_P (GET_MODE (operand))\n \t\t\t      && LOAD_EXTEND_OP (GET_MODE (operand)) != NIL)\n #endif\n-\t\t\t  ))\n+\t\t\t  )\n+#endif\n+\t\t      )\n \t\t  /* Subreg of a hard reg which can't handle the subreg's mode\n \t\t     or which would handle that mode in the wrong number of\n \t\t     registers for subregging to work.  */"}]}