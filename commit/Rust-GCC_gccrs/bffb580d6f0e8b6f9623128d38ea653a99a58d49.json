{"sha": "bffb580d6f0e8b6f9623128d38ea653a99a58d49", "node_id": "C_kwDOANBUbNoAKGJmZmI1ODBkNmYwZThiNmY5NjIzMTI4ZDM4ZWE2NTNhOTlhNThkNDk", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2021-09-30T04:48:48Z"}, "committer": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2021-09-30T18:47:11Z"}, "message": "compiler: avoid calling Expression::type before lowering\n\nThis is a minor cleanup to ensure that the various Expression::do_type\nmethods don't have to worry about the possibility that the Expression\nhas not been lowered.\n\nReviewed-on: https://go-review.googlesource.com/c/gofrontend/+/353140", "tree": {"sha": "d75deb578bcab16b1eb5d627105a89dde9ba1a80", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d75deb578bcab16b1eb5d627105a89dde9ba1a80"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bffb580d6f0e8b6f9623128d38ea653a99a58d49", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bffb580d6f0e8b6f9623128d38ea653a99a58d49", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bffb580d6f0e8b6f9623128d38ea653a99a58d49", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bffb580d6f0e8b6f9623128d38ea653a99a58d49/comments", "author": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b19bbfb1482505367dd19ae4ab1ea19e36802b6a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b19bbfb1482505367dd19ae4ab1ea19e36802b6a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b19bbfb1482505367dd19ae4ab1ea19e36802b6a"}], "stats": {"total": 92, "additions": 69, "deletions": 23}, "files": [{"sha": "7eea97765c3487f1cbfdd33b6d47d23648174f78", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bffb580d6f0e8b6f9623128d38ea653a99a58d49/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bffb580d6f0e8b6f9623128d38ea653a99a58d49/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=bffb580d6f0e8b6f9623128d38ea653a99a58d49", "patch": "@@ -1,4 +1,4 @@\n-e3bfc0889237a5bb8aa7ae30e1cff14f90a5f941\n+bbc1effb1a8a757a38011074f1d4477fae3936f5\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "93483544e46f31c42f2f57a96a869afe54816db0", "filename": "gcc/go/gofrontend/expressions.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bffb580d6f0e8b6f9623128d38ea653a99a58d49/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bffb580d6f0e8b6f9623128d38ea653a99a58d49/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.h?ref=bffb580d6f0e8b6f9623128d38ea653a99a58d49", "patch": "@@ -999,7 +999,9 @@ class Expression\n   determine_type_no_context();\n \n   // Return the current type of the expression.  This may be changed\n-  // by determine_type.\n+  // by determine_type.  This should not be called before the lowering\n+  // pass, unless the is_type_expression method returns true (i.e.,\n+  // this is an EXPRESSION_TYPE).\n   Type*\n   type()\n   { return this->do_type(); }"}, {"sha": "c6ce6230c58bb94a3783f3444d143006550f46f2", "filename": "gcc/go/gofrontend/types.cc", "status": "modified", "additions": 56, "deletions": 17, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bffb580d6f0e8b6f9623128d38ea653a99a58d49/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bffb580d6f0e8b6f9623128d38ea653a99a58d49/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc?ref=bffb580d6f0e8b6f9623128d38ea653a99a58d49", "patch": "@@ -11789,8 +11789,9 @@ Type::build_stub_methods(Gogo* gogo, const Type* type, const Methods* methods,\n \t{\n \t  stub = gogo->start_function(stub_name, stub_type, false,\n \t\t\t\t      fntype->location());\n-\t  Type::build_one_stub_method(gogo, m, buf, stub_params,\n-\t\t\t\t      fntype->is_varargs(), location);\n+\t  Type::build_one_stub_method(gogo, m, buf, receiver_type, stub_params,\n+\t\t\t\t      fntype->is_varargs(), stub_results,\n+\t\t\t\t      location);\n \t  gogo->finish_function(fntype->location());\n \n \t  if (type->named_type() == NULL && stub->is_function())\n@@ -11810,16 +11811,20 @@ Type::build_stub_methods(Gogo* gogo, const Type* type, const Methods* methods,\n void\n Type::build_one_stub_method(Gogo* gogo, Method* method,\n \t\t\t    const char* receiver_name,\n+\t\t\t    const Type* receiver_type,\n \t\t\t    const Typed_identifier_list* params,\n \t\t\t    bool is_varargs,\n+\t\t\t    const Typed_identifier_list* results,\n \t\t\t    Location location)\n {\n   Named_object* receiver_object = gogo->lookup(receiver_name, NULL);\n   go_assert(receiver_object != NULL);\n \n   Expression* expr = Expression::make_var_reference(receiver_object, location);\n-  expr = Type::apply_field_indexes(expr, method->field_indexes(), location);\n-  if (expr->type()->points_to() == NULL)\n+  const Type* expr_type = receiver_type;\n+  expr = Type::apply_field_indexes(expr, method->field_indexes(), location,\n+\t\t\t\t   &expr_type);\n+  if (expr_type->points_to() == NULL)\n     expr = Expression::make_unary(OPERATOR_AND, expr, location);\n \n   Expression_list* arguments;\n@@ -11844,8 +11849,7 @@ Type::build_one_stub_method(Gogo* gogo, Method* method,\n   go_assert(func != NULL);\n   Call_expression* call = Expression::make_call(func, arguments, is_varargs,\n \t\t\t\t\t\tlocation);\n-\n-  gogo->add_statement(Statement::make_return_from_call(call, location));\n+  Type::add_return_from_results(gogo, call, results, location);\n }\n \n // Build direct interface stub methods for TYPE as needed.  METHODS\n@@ -11954,8 +11958,9 @@ Type::build_direct_iface_stub_methods(Gogo* gogo, const Type* type,\n         {\n           stub = gogo->start_function(stub_name, stub_type, false,\n                                       fntype->location());\n-          Type::build_one_iface_stub_method(gogo, m, buf, stub_params,\n-                                            fntype->is_varargs(), loc);\n+\t  Type::build_one_iface_stub_method(gogo, m, buf, stub_params,\n+\t\t\t\t\t    fntype->is_varargs(), stub_results,\n+\t\t\t\t\t    loc);\n           gogo->finish_function(fntype->location());\n \n           if (type->named_type() == NULL && stub->is_function())\n@@ -11982,7 +11987,9 @@ void\n Type::build_one_iface_stub_method(Gogo* gogo, Method* method,\n                                   const char* receiver_name,\n                                   const Typed_identifier_list* params,\n-                                  bool is_varargs, Location loc)\n+\t\t\t\t  bool is_varargs,\n+\t\t\t\t  const Typed_identifier_list* results,\n+\t\t\t\t  Location loc)\n {\n   Named_object* receiver_object = gogo->lookup(receiver_name, NULL);\n   go_assert(receiver_object != NULL);\n@@ -12014,31 +12021,63 @@ Type::build_one_iface_stub_method(Gogo* gogo, Method* method,\n   go_assert(func != NULL);\n   Call_expression* call = Expression::make_call(func, arguments, is_varargs,\n                                                 loc);\n+  Type::add_return_from_results(gogo, call, results, loc);\n+}\n \n-  gogo->add_statement(Statement::make_return_from_call(call, loc));\n+// Build and add a return statement from a call expression and a list\n+// of result parameters.  All we need to know is the number of\n+// results.\n+\n+void\n+Type::add_return_from_results(Gogo* gogo, Call_expression* call,\n+\t\t\t\tconst Typed_identifier_list* results,\n+\t\t\t\tLocation loc)\n+{\n+  Statement* s;\n+  if (results == NULL || results->empty())\n+    s = Statement::make_statement(call, true);\n+  else\n+    {\n+      Expression_list* vals = new Expression_list();\n+      size_t rc = results->size();\n+      if (rc == 1)\n+\tvals->push_back(call);\n+      else\n+\t{\n+\t  for (size_t i = 0; i < rc; ++i)\n+\t    vals->push_back(Expression::make_call_result(call, i));\n+\t}\n+      s = Statement::make_return_statement(vals, loc);\n+    }\n+\n+  gogo->add_statement(s);\n }\n \n // Apply FIELD_INDEXES to EXPR.  The field indexes have to be applied\n-// in reverse order.\n+// in reverse order.  *PEXPR_TYPE maintains the type of EXPR; we use\n+// this to avoid calling EXPR->type() before the lowering pass.\n \n Expression*\n Type::apply_field_indexes(Expression* expr,\n \t\t\t  const Method::Field_indexes* field_indexes,\n-\t\t\t  Location location)\n+\t\t\t  Location location,\n+\t\t\t  const Type** pexpr_type)\n {\n   if (field_indexes == NULL)\n     return expr;\n-  expr = Type::apply_field_indexes(expr, field_indexes->next, location);\n-  Struct_type* stype = expr->type()->deref()->struct_type();\n+  expr = Type::apply_field_indexes(expr, field_indexes->next, location,\n+\t\t\t\t   pexpr_type);\n+  const Type* expr_type = *pexpr_type;\n+  const Struct_type* stype = expr_type->deref()->struct_type();\n   go_assert(stype != NULL\n \t     && field_indexes->field_index < stype->field_count());\n-  if (expr->type()->struct_type() == NULL)\n+  if (expr_type->struct_type() == NULL)\n     {\n-      go_assert(expr->type()->points_to() != NULL);\n+      go_assert(expr_type->points_to()->struct_type() == stype);\n       expr = Expression::make_dereference(expr, Expression::NIL_CHECK_DEFAULT,\n                                           location);\n-      go_assert(expr->type()->struct_type() == stype);\n     }\n+  *pexpr_type = stype->field(field_indexes->field_index)->type();\n   return Expression::make_field_reference(expr, field_indexes->field_index,\n \t\t\t\t\t  location);\n }"}, {"sha": "a33453afc84de9a1eeacab8e46daf5863966222a", "filename": "gcc/go/gofrontend/types.h", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bffb580d6f0e8b6f9623128d38ea653a99a58d49/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bffb580d6f0e8b6f9623128d38ea653a99a58d49/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.h?ref=bffb580d6f0e8b6f9623128d38ea653a99a58d49", "patch": "@@ -1355,21 +1355,26 @@ class Type\n \n   static void\n   build_one_stub_method(Gogo*, Method*, const char* receiver_name,\n+\t\t\tconst Type* receiver_type,\n \t\t\tconst Typed_identifier_list*, bool is_varargs,\n-\t\t\tLocation);\n+\t\t\tconst Typed_identifier_list*, Location);\n \n   // Build direct interface stub methods for a type.\n   static void\n   build_direct_iface_stub_methods(Gogo*, const Type*, Methods*, Location);\n \n   static void\n   build_one_iface_stub_method(Gogo*, Method*, const char*,\n-                              const Typed_identifier_list*,\n-                              bool, Location);\n+                              const Typed_identifier_list*, bool,\n+\t\t\t      const Typed_identifier_list*, Location);\n+\n+  static void\n+  add_return_from_results(Gogo*, Call_expression*,\n+\t\t\t  const Typed_identifier_list*, Location);\n \n   static Expression*\n   apply_field_indexes(Expression*, const Method::Field_indexes*,\n-\t\t      Location);\n+\t\t      Location, const Type**);\n \n   // Look for a field or method named NAME in TYPE.\n   static bool"}]}