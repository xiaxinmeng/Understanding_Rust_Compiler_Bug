{"sha": "340ef734b8072d2b58f946bb69170f2e535813d7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzQwZWY3MzRiODA3MmQyYjU4Zjk0NmJiNjkxNzBmMmU1MzU4MTNkNw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2012-11-23T16:02:09Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2012-11-23T16:02:09Z"}, "message": "i386-c.c (ix86_target_macros_internal): Update handling of core chips.\n\n\n\t* i386-c.c (ix86_target_macros_internal): Update handling of core\n\tchips.\n\t* i386.c (DUMMY_STRINGOP_ALGS): Update\n\t(*_cost): Update.\n\t(core_cost): Copy from generic64_cost; fix stringop descriptors.\n\t(m_CORE2_32, m_CORE2_64, m_COREI7_32, m_COREI7_64, m_CORE2I7_32,\n\tm_CORE2I7_64): Remove.\n\t(m_CORE2, m_COREI7, m_CORE2I7): Update.\n\t(initial_ix86_tune_features): Update.\n\t(processor_target): Update.\n\t(ix86_option_override_internal): Update.\n\t(ix86_option_override_internal): Remove PROCESSOR_CORE2_64,\n\tPROCESSOR_COREI7_64 special cases.\n\t(decide_alg): Add noalign parameter; set it.\n\t(ix86_expand_movmem, ix86_expand_setmem): Update noalign handling.\n\t(ix86_issue_rate): Update.\n\t(ia32_multipass_dfa_lookahead): Update.\n\t(ix86_sched_init_global): Update.\n\t(get_builtin_code_for_version): Update.\n\t* i386.h (stringop_strategy): Add noalign flag.\n\t(TARGET_CORE2_32, TARGET_CORE2_64, TARGET_COREI7_32, TARGET_COREI7_64):\n\tRemove.\n\t(TARGET_CORE2, TARGET_COREI7): New.\n\t(enum processor_type): Remove PROCESSOR_CORE2_32, PROCESSOR_CORE2_64,\n\tPROCESSOR_COREI7_32, PROCESSOR_COREI7_64; add PROCESSOR_CORE2,\n\tPROCESSOR_COREI7.\n\nFrom-SVN: r193761", "tree": {"sha": "ac19f5f945dc63511ec646c41e86a9a728967010", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ac19f5f945dc63511ec646c41e86a9a728967010"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/340ef734b8072d2b58f946bb69170f2e535813d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/340ef734b8072d2b58f946bb69170f2e535813d7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/340ef734b8072d2b58f946bb69170f2e535813d7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/340ef734b8072d2b58f946bb69170f2e535813d7/comments", "author": null, "committer": null, "parents": [{"sha": "ee88e690a27cfbe3cbb2216e50dec455754bc9a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee88e690a27cfbe3cbb2216e50dec455754bc9a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ee88e690a27cfbe3cbb2216e50dec455754bc9a2"}], "stats": {"total": 418, "additions": 265, "deletions": 153}, "files": [{"sha": "46760a06e4a3df3dfb40c73541ae857357797d01", "filename": "gcc/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/340ef734b8072d2b58f946bb69170f2e535813d7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/340ef734b8072d2b58f946bb69170f2e535813d7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=340ef734b8072d2b58f946bb69170f2e535813d7", "patch": "@@ -1,3 +1,32 @@\n+2012-11-23  Jan Hubicka  <jh@suse.cz>\n+\n+\t* i386-c.c (ix86_target_macros_internal): Update handling of core\n+\tchips.\n+\t* i386.c (DUMMY_STRINGOP_ALGS): Update\n+\t(*_cost): Update.\n+\t(core_cost): Copy from generic64_cost; fix stringop descriptors.\n+\t(m_CORE2_32, m_CORE2_64, m_COREI7_32, m_COREI7_64, m_CORE2I7_32,\n+\tm_CORE2I7_64): Remove.\n+\t(m_CORE2, m_COREI7, m_CORE2I7): Update.\n+\t(initial_ix86_tune_features): Update.\n+\t(processor_target): Update.\n+\t(ix86_option_override_internal): Update.\n+\t(ix86_option_override_internal): Remove PROCESSOR_CORE2_64,\n+\tPROCESSOR_COREI7_64 special cases.\n+\t(decide_alg): Add noalign parameter; set it.\n+\t(ix86_expand_movmem, ix86_expand_setmem): Update noalign handling.\n+\t(ix86_issue_rate): Update.\n+\t(ia32_multipass_dfa_lookahead): Update.\n+\t(ix86_sched_init_global): Update.\n+\t(get_builtin_code_for_version): Update.\n+\t* i386.h (stringop_strategy): Add noalign flag.\n+\t(TARGET_CORE2_32, TARGET_CORE2_64, TARGET_COREI7_32, TARGET_COREI7_64):\n+\tRemove.\n+\t(TARGET_CORE2, TARGET_COREI7): New.\n+\t(enum processor_type): Remove PROCESSOR_CORE2_32, PROCESSOR_CORE2_64,\n+\tPROCESSOR_COREI7_32, PROCESSOR_COREI7_64; add PROCESSOR_CORE2,\n+\tPROCESSOR_COREI7.\n+\n 2012-11-23  Eric Botcazou  <ebotcazou@adacore.com>\n \n \tPR rtl-optimization/55388"}, {"sha": "22e5e9b45e30edf8690ac80999572c16caf293d7", "filename": "gcc/config/i386/i386-c.c", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/340ef734b8072d2b58f946bb69170f2e535813d7/gcc%2Fconfig%2Fi386%2Fi386-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/340ef734b8072d2b58f946bb69170f2e535813d7/gcc%2Fconfig%2Fi386%2Fi386-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-c.c?ref=340ef734b8072d2b58f946bb69170f2e535813d7", "patch": "@@ -134,13 +134,11 @@ ix86_target_macros_internal (HOST_WIDE_INT isa_flag,\n       def_or_undef (parse_in, \"__nocona\");\n       def_or_undef (parse_in, \"__nocona__\");\n       break;\n-    case PROCESSOR_CORE2_32:\n-    case PROCESSOR_CORE2_64:\n+    case PROCESSOR_CORE2:\n       def_or_undef (parse_in, \"__core2\");\n       def_or_undef (parse_in, \"__core2__\");\n       break;\n-    case PROCESSOR_COREI7_32:\n-    case PROCESSOR_COREI7_64:\n+    case PROCESSOR_COREI7:\n       def_or_undef (parse_in, \"__corei7\");\n       def_or_undef (parse_in, \"__corei7__\");\n       break;\n@@ -228,12 +226,10 @@ ix86_target_macros_internal (HOST_WIDE_INT isa_flag,\n     case PROCESSOR_NOCONA:\n       def_or_undef (parse_in, \"__tune_nocona__\");\n       break;\n-    case PROCESSOR_CORE2_32:\n-    case PROCESSOR_CORE2_64:\n+    case PROCESSOR_CORE2:\n       def_or_undef (parse_in, \"__tune_core2__\");\n       break;\n-    case PROCESSOR_COREI7_32:\n-    case PROCESSOR_COREI7_64:\n+    case PROCESSOR_COREI7:\n       def_or_undef (parse_in, \"__tune_corei7__\");\n       break;\n     case PROCESSOR_ATOM:"}, {"sha": "eeb5ac8a8811b86f646205057774ff8c745c274c", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 224, "deletions": 135, "changes": 359, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/340ef734b8072d2b58f946bb69170f2e535813d7/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/340ef734b8072d2b58f946bb69170f2e535813d7/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=340ef734b8072d2b58f946bb69170f2e535813d7", "patch": "@@ -83,7 +83,7 @@ static rtx legitimize_dllimport_symbol (rtx, bool);\n /* We assume COSTS_N_INSNS is defined as (N)*4 and an addition is 2 bytes.  */\n #define COSTS_N_BYTES(N) ((N) * 2)\n \n-#define DUMMY_STRINGOP_ALGS {libcall, {{-1, libcall}}}\n+#define DUMMY_STRINGOP_ALGS {libcall, {{-1, libcall, false}}}\n \n const\n struct processor_costs ix86_size_cost = {/* costs for tuning for size */\n@@ -138,10 +138,10 @@ struct processor_costs ix86_size_cost = {/* costs for tuning for size */\n   COSTS_N_BYTES (2),\t\t\t/* cost of FABS instruction.  */\n   COSTS_N_BYTES (2),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_BYTES (2),\t\t\t/* cost of FSQRT instruction.  */\n-  {{rep_prefix_1_byte, {{-1, rep_prefix_1_byte}}},\n-   {rep_prefix_1_byte, {{-1, rep_prefix_1_byte}}}},\n-  {{rep_prefix_1_byte, {{-1, rep_prefix_1_byte}}},\n-   {rep_prefix_1_byte, {{-1, rep_prefix_1_byte}}}},\n+  {{rep_prefix_1_byte, {{-1, rep_prefix_1_byte, false}}},\n+   {rep_prefix_1_byte, {{-1, rep_prefix_1_byte, false}}}},\n+  {{rep_prefix_1_byte, {{-1, rep_prefix_1_byte, false}}},\n+   {rep_prefix_1_byte, {{-1, rep_prefix_1_byte, false}}}},\n   1,\t\t\t\t\t/* scalar_stmt_cost.  */\n   1,\t\t\t\t\t/* scalar load_cost.  */\n   1,\t\t\t\t\t/* scalar_store_cost.  */\n@@ -209,9 +209,9 @@ struct processor_costs i386_cost = {\t/* 386 specific costs */\n   COSTS_N_INSNS (22),\t\t\t/* cost of FABS instruction.  */\n   COSTS_N_INSNS (24),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (122),\t\t\t/* cost of FSQRT instruction.  */\n-  {{rep_prefix_1_byte, {{-1, rep_prefix_1_byte}}},\n+  {{rep_prefix_1_byte, {{-1, rep_prefix_1_byte, false}}},\n    DUMMY_STRINGOP_ALGS},\n-  {{rep_prefix_1_byte, {{-1, rep_prefix_1_byte}}},\n+  {{rep_prefix_1_byte, {{-1, rep_prefix_1_byte, false}}},\n    DUMMY_STRINGOP_ALGS},\n   1,\t\t\t\t\t/* scalar_stmt_cost.  */\n   1,\t\t\t\t\t/* scalar load_cost.  */\n@@ -281,9 +281,9 @@ struct processor_costs i486_cost = {\t/* 486 specific costs */\n   COSTS_N_INSNS (3),\t\t\t/* cost of FABS instruction.  */\n   COSTS_N_INSNS (3),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (83),\t\t\t/* cost of FSQRT instruction.  */\n-  {{rep_prefix_4_byte, {{-1, rep_prefix_4_byte}}},\n+  {{rep_prefix_4_byte, {{-1, rep_prefix_4_byte, false}}},\n    DUMMY_STRINGOP_ALGS},\n-  {{rep_prefix_4_byte, {{-1, rep_prefix_4_byte}}},\n+  {{rep_prefix_4_byte, {{-1, rep_prefix_4_byte, false}}},\n    DUMMY_STRINGOP_ALGS},\n   1,\t\t\t\t\t/* scalar_stmt_cost.  */\n   1,\t\t\t\t\t/* scalar load_cost.  */\n@@ -351,9 +351,9 @@ struct processor_costs pentium_cost = {\n   COSTS_N_INSNS (1),\t\t\t/* cost of FABS instruction.  */\n   COSTS_N_INSNS (1),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (70),\t\t\t/* cost of FSQRT instruction.  */\n-  {{libcall, {{256, rep_prefix_4_byte}, {-1, libcall}}},\n+  {{libcall, {{256, rep_prefix_4_byte, false}, {-1, libcall, false}}},\n    DUMMY_STRINGOP_ALGS},\n-  {{libcall, {{-1, rep_prefix_4_byte}}},\n+  {{libcall, {{-1, rep_prefix_4_byte, false}}},\n    DUMMY_STRINGOP_ALGS},\n   1,\t\t\t\t\t/* scalar_stmt_cost.  */\n   1,\t\t\t\t\t/* scalar load_cost.  */\n@@ -426,11 +426,13 @@ struct processor_costs pentiumpro_cost = {\n      noticeable win, for bigger blocks either rep movsl or rep movsb is\n      way to go.  Rep movsb has apparently more expensive startup time in CPU,\n      but after 4K the difference is down in the noise.  */\n-  {{rep_prefix_4_byte, {{128, loop}, {1024, unrolled_loop},\n-\t\t\t{8192, rep_prefix_4_byte}, {-1, rep_prefix_1_byte}}},\n+  {{rep_prefix_4_byte, {{128, loop, false}, {1024, unrolled_loop, false},\n+\t\t\t{8192, rep_prefix_4_byte, false},\n+\t\t        {-1, rep_prefix_1_byte, false}}},\n    DUMMY_STRINGOP_ALGS},\n-  {{rep_prefix_4_byte, {{1024, unrolled_loop},\n-  \t\t\t{8192, rep_prefix_4_byte}, {-1, libcall}}},\n+  {{rep_prefix_4_byte, {{1024, unrolled_loop, false},\n+  \t\t\t{8192, rep_prefix_4_byte, false},\n+\t\t\t{-1, libcall, false}}},\n    DUMMY_STRINGOP_ALGS},\n   1,\t\t\t\t\t/* scalar_stmt_cost.  */\n   1,\t\t\t\t\t/* scalar load_cost.  */\n@@ -499,9 +501,9 @@ struct processor_costs geode_cost = {\n   COSTS_N_INSNS (1),\t\t\t/* cost of FABS instruction.  */\n   COSTS_N_INSNS (1),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (54),\t\t\t/* cost of FSQRT instruction.  */\n-  {{libcall, {{256, rep_prefix_4_byte}, {-1, libcall}}},\n+  {{libcall, {{256, rep_prefix_4_byte, false}, {-1, libcall, false}}},\n    DUMMY_STRINGOP_ALGS},\n-  {{libcall, {{256, rep_prefix_4_byte}, {-1, libcall}}},\n+  {{libcall, {{256, rep_prefix_4_byte, false}, {-1, libcall, false}}},\n    DUMMY_STRINGOP_ALGS},\n   1,\t\t\t\t\t/* scalar_stmt_cost.  */\n   1,\t\t\t\t\t/* scalar load_cost.  */\n@@ -572,9 +574,9 @@ struct processor_costs k6_cost = {\n   COSTS_N_INSNS (2),\t\t\t/* cost of FABS instruction.  */\n   COSTS_N_INSNS (2),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (56),\t\t\t/* cost of FSQRT instruction.  */\n-  {{libcall, {{256, rep_prefix_4_byte}, {-1, libcall}}},\n+  {{libcall, {{256, rep_prefix_4_byte, false}, {-1, libcall, false}}},\n    DUMMY_STRINGOP_ALGS},\n-  {{libcall, {{256, rep_prefix_4_byte}, {-1, libcall}}},\n+  {{libcall, {{256, rep_prefix_4_byte, false}, {-1, libcall, false}}},\n    DUMMY_STRINGOP_ALGS},\n   1,\t\t\t\t\t/* scalar_stmt_cost.  */\n   1,\t\t\t\t\t/* scalar load_cost.  */\n@@ -645,9 +647,9 @@ struct processor_costs athlon_cost = {\n   /* For some reason, Athlon deals better with REP prefix (relative to loops)\n      compared to K8. Alignment becomes important after 8 bytes for memcpy and\n      128 bytes for memset.  */\n-  {{libcall, {{2048, rep_prefix_4_byte}, {-1, libcall}}},\n+  {{libcall, {{2048, rep_prefix_4_byte, false}, {-1, libcall, false}}},\n    DUMMY_STRINGOP_ALGS},\n-  {{libcall, {{2048, rep_prefix_4_byte}, {-1, libcall}}},\n+  {{libcall, {{2048, rep_prefix_4_byte, false}, {-1, libcall, false}}},\n    DUMMY_STRINGOP_ALGS},\n   1,\t\t\t\t\t/* scalar_stmt_cost.  */\n   1,\t\t\t\t\t/* scalar load_cost.  */\n@@ -723,11 +725,14 @@ struct processor_costs k8_cost = {\n   /* K8 has optimized REP instruction for medium sized blocks, but for very\n      small blocks it is better to use loop. For large blocks, libcall can\n      do nontemporary accesses and beat inline considerably.  */\n-  {{libcall, {{6, loop}, {14, unrolled_loop}, {-1, rep_prefix_4_byte}}},\n-   {libcall, {{16, loop}, {8192, rep_prefix_8_byte}, {-1, libcall}}}},\n-  {{libcall, {{8, loop}, {24, unrolled_loop},\n-\t      {2048, rep_prefix_4_byte}, {-1, libcall}}},\n-   {libcall, {{48, unrolled_loop}, {8192, rep_prefix_8_byte}, {-1, libcall}}}},\n+  {{libcall, {{6, loop, false}, {14, unrolled_loop, false},\n+\t      {-1, rep_prefix_4_byte, false}}},\n+   {libcall, {{16, loop, false}, {8192, rep_prefix_8_byte, false},\n+\t      {-1, libcall, false}}}},\n+  {{libcall, {{8, loop, false}, {24, unrolled_loop, false},\n+\t      {2048, rep_prefix_4_byte, false}, {-1, libcall, false}}},\n+   {libcall, {{48, unrolled_loop, false},\n+\t      {8192, rep_prefix_8_byte, false}, {-1, libcall, false}}}},\n   4,\t\t\t\t\t/* scalar_stmt_cost.  */\n   2,\t\t\t\t\t/* scalar load_cost.  */\n   2,\t\t\t\t\t/* scalar_store_cost.  */\n@@ -810,11 +815,14 @@ struct processor_costs amdfam10_cost = {\n   /* AMDFAM10 has optimized REP instruction for medium sized blocks, but for\n      very small blocks it is better to use loop. For large blocks, libcall can\n      do nontemporary accesses and beat inline considerably.  */\n-  {{libcall, {{6, loop}, {14, unrolled_loop}, {-1, rep_prefix_4_byte}}},\n-   {libcall, {{16, loop}, {8192, rep_prefix_8_byte}, {-1, libcall}}}},\n-  {{libcall, {{8, loop}, {24, unrolled_loop},\n-\t      {2048, rep_prefix_4_byte}, {-1, libcall}}},\n-   {libcall, {{48, unrolled_loop}, {8192, rep_prefix_8_byte}, {-1, libcall}}}},\n+  {{libcall, {{6, loop, false}, {14, unrolled_loop, false},\n+\t      {-1, rep_prefix_4_byte, false}}},\n+   {libcall, {{16, loop, false}, {8192, rep_prefix_8_byte, false},\n+\t      {-1, libcall, false}}}},\n+  {{libcall, {{8, loop, false}, {24, unrolled_loop, false},\n+\t      {2048, rep_prefix_4_byte, false}, {-1, libcall, false}}},\n+   {libcall, {{48, unrolled_loop, false}, {8192, rep_prefix_8_byte, false},\n+\t      {-1, libcall, false}}}},\n   4,\t\t\t\t\t/* scalar_stmt_cost.  */\n   2,\t\t\t\t\t/* scalar load_cost.  */\n   2,\t\t\t\t\t/* scalar_store_cost.  */\n@@ -897,11 +905,14 @@ struct processor_costs bdver1_cost = {\n   /*  BDVER1 has optimized REP instruction for medium sized blocks, but for\n       very small blocks it is better to use loop. For large blocks, libcall\n       can do nontemporary accesses and beat inline considerably.  */\n-  {{libcall, {{6, loop}, {14, unrolled_loop}, {-1, rep_prefix_4_byte}}},\n-   {libcall, {{16, loop}, {8192, rep_prefix_8_byte}, {-1, libcall}}}},\n-  {{libcall, {{8, loop}, {24, unrolled_loop},\n-\t      {2048, rep_prefix_4_byte}, {-1, libcall}}},\n-   {libcall, {{48, unrolled_loop}, {8192, rep_prefix_8_byte}, {-1, libcall}}}},\n+  {{libcall, {{6, loop, false}, {14, unrolled_loop, false},\n+\t      {-1, rep_prefix_4_byte, false}}},\n+   {libcall, {{16, loop, false}, {8192, rep_prefix_8_byte, false},\n+\t      {-1, libcall, false}}}},\n+  {{libcall, {{8, loop, false}, {24, unrolled_loop, false},\n+\t      {2048, rep_prefix_4_byte, false}, {-1, libcall, false}}},\n+   {libcall, {{48, unrolled_loop, false}, {8192, rep_prefix_8_byte, false},\n+\t      {-1, libcall, false}}}},\n   6,\t\t\t\t\t/* scalar_stmt_cost.  */\n   4,\t\t\t\t\t/* scalar load_cost.  */\n   4,\t\t\t\t\t/* scalar_store_cost.  */\n@@ -984,11 +995,14 @@ struct processor_costs bdver2_cost = {\n   /*  BDVER2 has optimized REP instruction for medium sized blocks, but for\n       very small blocks it is better to use loop. For large blocks, libcall\n       can do nontemporary accesses and beat inline considerably.  */\n-  {{libcall, {{6, loop}, {14, unrolled_loop}, {-1, rep_prefix_4_byte}}},\n-   {libcall, {{16, loop}, {8192, rep_prefix_8_byte}, {-1, libcall}}}},\n-  {{libcall, {{8, loop}, {24, unrolled_loop},\n-\t      {2048, rep_prefix_4_byte}, {-1, libcall}}},\n-   {libcall, {{48, unrolled_loop}, {8192, rep_prefix_8_byte}, {-1, libcall}}}},\n+  {{libcall, {{6, loop, false}, {14, unrolled_loop, false},\n+\t      {-1, rep_prefix_4_byte, false}}},\n+   {libcall, {{16, loop, false}, {8192, rep_prefix_8_byte, false},\n+\t      {-1, libcall, false}}}},\n+  {{libcall, {{8, loop, false}, {24, unrolled_loop, false},\n+\t      {2048, rep_prefix_4_byte, false}, {-1, libcall, false}}},\n+   {libcall, {{48, unrolled_loop, false}, {8192, rep_prefix_8_byte, false},\n+\t      {-1, libcall, false}}}},\n   6,\t\t\t\t\t/* scalar_stmt_cost.  */\n   4,\t\t\t\t\t/* scalar load_cost.  */\n   4,\t\t\t\t\t/* scalar_store_cost.  */\n@@ -1063,11 +1077,14 @@ struct processor_costs bdver3_cost = {\n   /*  BDVER3 has optimized REP instruction for medium sized blocks, but for\n       very small blocks it is better to use loop. For large blocks, libcall\n       can do nontemporary accesses and beat inline considerably.  */\n-  {{libcall, {{6, loop}, {14, unrolled_loop}, {-1, rep_prefix_4_byte}}},\n-   {libcall, {{16, loop}, {8192, rep_prefix_8_byte}, {-1, libcall}}}},\n-  {{libcall, {{8, loop}, {24, unrolled_loop},\n-\t      {2048, rep_prefix_4_byte}, {-1, libcall}}},\n-   {libcall, {{48, unrolled_loop}, {8192, rep_prefix_8_byte}, {-1, libcall}}}},\n+  {{libcall, {{6, loop, false}, {14, unrolled_loop, false},\n+\t      {-1, rep_prefix_4_byte, false}}},\n+   {libcall, {{16, loop, false}, {8192, rep_prefix_8_byte, false},\n+\t      {-1, libcall, false}}}},\n+  {{libcall, {{8, loop, false}, {24, unrolled_loop, false},\n+\t      {2048, rep_prefix_4_byte, false}, {-1, libcall, false}}},\n+   {libcall, {{48, unrolled_loop, false}, {8192, rep_prefix_8_byte, false},\n+\t      {-1, libcall, false}}}},\n   6,\t\t\t\t\t/* scalar_stmt_cost.  */\n   4,\t\t\t\t\t/* scalar load_cost.  */\n   4,\t\t\t\t\t/* scalar_store_cost.  */\n@@ -1145,11 +1162,14 @@ struct processor_costs btver1_cost = {\n   /* BTVER1 has optimized REP instruction for medium sized blocks, but for\n      very small blocks it is better to use loop. For large blocks, libcall can\n      do nontemporary accesses and beat inline considerably.  */\n-  {{libcall, {{6, loop}, {14, unrolled_loop}, {-1, rep_prefix_4_byte}}},\n-   {libcall, {{16, loop}, {8192, rep_prefix_8_byte}, {-1, libcall}}}},\n-  {{libcall, {{8, loop}, {24, unrolled_loop},\n-\t      {2048, rep_prefix_4_byte}, {-1, libcall}}},\n-   {libcall, {{48, unrolled_loop}, {8192, rep_prefix_8_byte}, {-1, libcall}}}},\n+  {{libcall, {{6, loop, false}, {14, unrolled_loop, false},\n+\t      {-1, rep_prefix_4_byte, false}}},\n+   {libcall, {{16, loop, false}, {8192, rep_prefix_8_byte, false},\n+\t      {-1, libcall, false}}}},\n+  {{libcall, {{8, loop, false}, {24, unrolled_loop, false},\n+\t      {2048, rep_prefix_4_byte, false}, {-1, libcall, false}}},\n+   {libcall, {{48, unrolled_loop, false}, {8192, rep_prefix_8_byte, false},\n+\t      {-1, libcall, false}}}},\n   4,\t\t\t\t\t/* scalar_stmt_cost.  */\n   2,\t\t\t\t\t/* scalar load_cost.  */\n   2,\t\t\t\t\t/* scalar_store_cost.  */\n@@ -1224,11 +1244,14 @@ struct processor_costs btver2_cost = {\n   COSTS_N_INSNS (2),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (35),\t\t\t/* cost of FSQRT instruction.  */\n \n-  {{libcall, {{6, loop}, {14, unrolled_loop}, {-1, rep_prefix_4_byte}}},\n-   {libcall, {{16, loop}, {8192, rep_prefix_8_byte}, {-1, libcall}}}},\n-  {{libcall, {{8, loop}, {24, unrolled_loop},\n-\t      {2048, rep_prefix_4_byte}, {-1, libcall}}},\n-   {libcall, {{48, unrolled_loop}, {8192, rep_prefix_8_byte}, {-1, libcall}}}},\n+  {{libcall, {{6, loop, false}, {14, unrolled_loop, false},\n+\t      {-1, rep_prefix_4_byte, false}}},\n+   {libcall, {{16, loop, false}, {8192, rep_prefix_8_byte, false},\n+\t      {-1, libcall, false}}}},\n+  {{libcall, {{8, loop, false}, {24, unrolled_loop, false},\n+\t      {2048, rep_prefix_4_byte, false}, {-1, libcall, false}}},\n+   {libcall, {{48, unrolled_loop, false}, {8192, rep_prefix_8_byte, false},\n+\t      {-1, libcall, false}}}},\n   4,\t\t\t\t\t/* scalar_stmt_cost.  */\n   2,\t\t\t\t\t/* scalar load_cost.  */\n   2,\t\t\t\t\t/* scalar_store_cost.  */\n@@ -1295,10 +1318,10 @@ struct processor_costs pentium4_cost = {\n   COSTS_N_INSNS (2),\t\t\t/* cost of FABS instruction.  */\n   COSTS_N_INSNS (2),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (43),\t\t\t/* cost of FSQRT instruction.  */\n-  {{libcall, {{12, loop_1_byte}, {-1, rep_prefix_4_byte}}},\n+  {{libcall, {{12, loop_1_byte, false}, {-1, rep_prefix_4_byte, false}}},\n    DUMMY_STRINGOP_ALGS},\n-  {{libcall, {{6, loop_1_byte}, {48, loop}, {20480, rep_prefix_4_byte},\n-   {-1, libcall}}},\n+  {{libcall, {{6, loop_1_byte, false}, {48, loop, false},\n+\t      {20480, rep_prefix_4_byte, false}, {-1, libcall, false}}},\n    DUMMY_STRINGOP_ALGS},\n   1,\t\t\t\t\t/* scalar_stmt_cost.  */\n   1,\t\t\t\t\t/* scalar load_cost.  */\n@@ -1366,13 +1389,13 @@ struct processor_costs nocona_cost = {\n   COSTS_N_INSNS (3),\t\t\t/* cost of FABS instruction.  */\n   COSTS_N_INSNS (3),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (44),\t\t\t/* cost of FSQRT instruction.  */\n-  {{libcall, {{12, loop_1_byte}, {-1, rep_prefix_4_byte}}},\n-   {libcall, {{32, loop}, {20000, rep_prefix_8_byte},\n-\t      {100000, unrolled_loop}, {-1, libcall}}}},\n-  {{libcall, {{6, loop_1_byte}, {48, loop}, {20480, rep_prefix_4_byte},\n-   {-1, libcall}}},\n-   {libcall, {{24, loop}, {64, unrolled_loop},\n-\t      {8192, rep_prefix_8_byte}, {-1, libcall}}}},\n+  {{libcall, {{12, loop_1_byte, false}, {-1, rep_prefix_4_byte, false}}},\n+   {libcall, {{32, loop, false}, {20000, rep_prefix_8_byte, false},\n+\t      {100000, unrolled_loop, false}, {-1, libcall, false}}}},\n+  {{libcall, {{6, loop_1_byte, false}, {48, loop, false},\n+\t      {20480, rep_prefix_4_byte, false}, {-1, libcall, false}}},\n+   {libcall, {{24, loop, false}, {64, unrolled_loop, false},\n+\t      {8192, rep_prefix_8_byte, false}, {-1, libcall, false}}}},\n   1,\t\t\t\t\t/* scalar_stmt_cost.  */\n   1,\t\t\t\t\t/* scalar load_cost.  */\n   1,\t\t\t\t\t/* scalar_store_cost.  */\n@@ -1439,13 +1462,13 @@ struct processor_costs atom_cost = {\n   COSTS_N_INSNS (8),\t\t\t/* cost of FABS instruction.  */\n   COSTS_N_INSNS (8),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (40),\t\t\t/* cost of FSQRT instruction.  */\n-  {{libcall, {{11, loop}, {-1, rep_prefix_4_byte}}},\n-   {libcall, {{32, loop}, {64, rep_prefix_4_byte},\n-\t  {8192, rep_prefix_8_byte}, {-1, libcall}}}},\n-  {{libcall, {{8, loop}, {15, unrolled_loop},\n-\t  {2048, rep_prefix_4_byte}, {-1, libcall}}},\n-   {libcall, {{24, loop}, {32, unrolled_loop},\n-\t  {8192, rep_prefix_8_byte}, {-1, libcall}}}},\n+  {{libcall, {{11, loop, false}, {-1, rep_prefix_4_byte, false}}},\n+   {libcall, {{32, loop, false}, {64, rep_prefix_4_byte, false},\n+\t  {8192, rep_prefix_8_byte, false}, {-1, libcall, false}}}},\n+  {{libcall, {{8, loop, false}, {15, unrolled_loop, false},\n+\t  {2048, rep_prefix_4_byte, false}, {-1, libcall, false}}},\n+   {libcall, {{24, loop, false}, {32, unrolled_loop, false},\n+\t  {8192, rep_prefix_8_byte, false}, {-1, libcall, false}}}},\n   1,\t\t\t\t\t/* scalar_stmt_cost.  */\n   1,\t\t\t\t\t/* scalar load_cost.  */\n   1,\t\t\t\t\t/* scalar_store_cost.  */\n@@ -1520,9 +1543,92 @@ struct processor_costs generic64_cost = {\n   COSTS_N_INSNS (8),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (40),\t\t\t/* cost of FSQRT instruction.  */\n   {DUMMY_STRINGOP_ALGS,\n-   {libcall, {{32, loop}, {8192, rep_prefix_8_byte}, {-1, libcall}}}},\n+   {libcall, {{32, loop, false}, {8192, rep_prefix_8_byte, false},\n+\t      {-1, libcall, false}}}},\n   {DUMMY_STRINGOP_ALGS,\n-   {libcall, {{32, loop}, {8192, rep_prefix_8_byte}, {-1, libcall}}}},\n+   {libcall, {{32, loop, false}, {8192, rep_prefix_8_byte, false},\n+\t      {-1, libcall, false}}}},\n+  1,\t\t\t\t\t/* scalar_stmt_cost.  */\n+  1,\t\t\t\t\t/* scalar load_cost.  */\n+  1,\t\t\t\t\t/* scalar_store_cost.  */\n+  1,\t\t\t\t\t/* vec_stmt_cost.  */\n+  1,\t\t\t\t\t/* vec_to_scalar_cost.  */\n+  1,\t\t\t\t\t/* scalar_to_vec_cost.  */\n+  1,\t\t\t\t\t/* vec_align_load_cost.  */\n+  2,\t\t\t\t\t/* vec_unalign_load_cost.  */\n+  1,\t\t\t\t\t/* vec_store_cost.  */\n+  3,\t\t\t\t\t/* cond_taken_branch_cost.  */\n+  1,\t\t\t\t\t/* cond_not_taken_branch_cost.  */\n+};\n+\n+/* core_cost should produce code tuned for Core familly of CPUs.  */\n+static const\n+struct processor_costs core_cost = {\n+  COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction */\n+  /* On all chips taken into consideration lea is 2 cycles and more.  With\n+     this cost however our current implementation of synth_mult results in\n+     use of unnecessary temporary registers causing regression on several\n+     SPECfp benchmarks.  */\n+  COSTS_N_INSNS (1) + 1,\t\t/* cost of a lea instruction */\n+  COSTS_N_INSNS (1),\t\t\t/* variable shift costs */\n+  COSTS_N_INSNS (1),\t\t\t/* constant shift costs */\n+  {COSTS_N_INSNS (3),\t\t\t/* cost of starting multiply for QI */\n+   COSTS_N_INSNS (4),\t\t\t/*\t\t\t\t HI */\n+   COSTS_N_INSNS (3),\t\t\t/*\t\t\t\t SI */\n+   COSTS_N_INSNS (4),\t\t\t/*\t\t\t\t DI */\n+   COSTS_N_INSNS (2)},\t\t\t/*\t\t\t      other */\n+  0,\t\t\t\t\t/* cost of multiply per each bit set */\n+  {COSTS_N_INSNS (18),\t\t\t/* cost of a divide/mod for QI */\n+   COSTS_N_INSNS (26),\t\t\t/*\t\t\t    HI */\n+   COSTS_N_INSNS (42),\t\t\t/*\t\t\t    SI */\n+   COSTS_N_INSNS (74),\t\t\t/*\t\t\t    DI */\n+   COSTS_N_INSNS (74)},\t\t\t/*\t\t\t    other */\n+  COSTS_N_INSNS (1),\t\t\t/* cost of movsx */\n+  COSTS_N_INSNS (1),\t\t\t/* cost of movzx */\n+  8,\t\t\t\t\t/* \"large\" insn */\n+  17,\t\t\t\t\t/* MOVE_RATIO */\n+  4,\t\t\t\t     /* cost for loading QImode using movzbl */\n+  {4, 4, 4},\t\t\t\t/* cost of loading integer registers\n+\t\t\t\t\t   in QImode, HImode and SImode.\n+\t\t\t\t\t   Relative to reg-reg move (2).  */\n+  {4, 4, 4},\t\t\t\t/* cost of storing integer registers */\n+  4,\t\t\t\t\t/* cost of reg,reg fld/fst */\n+  {12, 12, 12},\t\t\t\t/* cost of loading fp registers\n+\t\t\t\t\t   in SFmode, DFmode and XFmode */\n+  {6, 6, 8},\t\t\t\t/* cost of storing fp registers\n+\t\t\t\t\t   in SFmode, DFmode and XFmode */\n+  2,\t\t\t\t\t/* cost of moving MMX register */\n+  {8, 8},\t\t\t\t/* cost of loading MMX registers\n+\t\t\t\t\t   in SImode and DImode */\n+  {8, 8},\t\t\t\t/* cost of storing MMX registers\n+\t\t\t\t\t   in SImode and DImode */\n+  2,\t\t\t\t\t/* cost of moving SSE register */\n+  {8, 8, 8},\t\t\t\t/* cost of loading SSE registers\n+\t\t\t\t\t   in SImode, DImode and TImode */\n+  {8, 8, 8},\t\t\t\t/* cost of storing SSE registers\n+\t\t\t\t\t   in SImode, DImode and TImode */\n+  5,\t\t\t\t\t/* MMX or SSE register to integer */\n+  64,\t\t\t\t\t/* size of l1 cache.  */\n+  512,\t\t\t\t\t/* size of l2 cache.  */\n+  64,\t\t\t\t\t/* size of prefetch block */\n+  6,\t\t\t\t\t/* number of parallel prefetches */\n+  /* FIXME perhaps more appropriate value is 5.  */\n+  3,\t\t\t\t\t/* Branch cost */\n+  COSTS_N_INSNS (8),\t\t\t/* cost of FADD and FSUB insns.  */\n+  COSTS_N_INSNS (8),\t\t\t/* cost of FMUL instruction.  */\n+  COSTS_N_INSNS (20),\t\t\t/* cost of FDIV instruction.  */\n+  COSTS_N_INSNS (8),\t\t\t/* cost of FABS instruction.  */\n+  COSTS_N_INSNS (8),\t\t\t/* cost of FCHS instruction.  */\n+  COSTS_N_INSNS (40),\t\t\t/* cost of FSQRT instruction.  */\n+  {{libcall, {{1024, rep_prefix_4_byte, true}, {-1, libcall, false}}},\n+   {libcall, {{24, loop, true}, {128, rep_prefix_8_byte, true},\n+              {-1, libcall, false}}}},\n+  {{libcall, {{6, loop_1_byte, true},\n+              {24, loop, true},\n+              {8192, rep_prefix_4_byte, true},\n+              {-1, libcall, false}}},\n+   {libcall, {{24, loop, true}, {512, rep_prefix_8_byte, true},\n+              {-1, libcall, false}}}},\n   1,\t\t\t\t\t/* scalar_stmt_cost.  */\n   1,\t\t\t\t\t/* scalar load_cost.  */\n   1,\t\t\t\t\t/* scalar_store_cost.  */\n@@ -1591,9 +1697,11 @@ struct processor_costs generic32_cost = {\n   COSTS_N_INSNS (8),\t\t\t/* cost of FABS instruction.  */\n   COSTS_N_INSNS (8),\t\t\t/* cost of FCHS instruction.  */\n   COSTS_N_INSNS (40),\t\t\t/* cost of FSQRT instruction.  */\n-  {{libcall, {{32, loop}, {8192, rep_prefix_4_byte}, {-1, libcall}}},\n+  {{libcall, {{32, loop, false}, {8192, rep_prefix_4_byte, false},\n+\t      {-1, libcall, false}}},\n    DUMMY_STRINGOP_ALGS},\n-  {{libcall, {{32, loop}, {8192, rep_prefix_4_byte}, {-1, libcall}}},\n+  {{libcall, {{32, loop, false}, {8192, rep_prefix_4_byte, false},\n+\t      {-1, libcall, false}}},\n    DUMMY_STRINGOP_ALGS},\n   1,\t\t\t\t\t/* scalar_stmt_cost.  */\n   1,\t\t\t\t\t/* scalar load_cost.  */\n@@ -1622,14 +1730,9 @@ const struct processor_costs *ix86_cost = &pentium_cost;\n #define m_PENT4 (1<<PROCESSOR_PENTIUM4)\n #define m_NOCONA (1<<PROCESSOR_NOCONA)\n #define m_P4_NOCONA (m_PENT4 | m_NOCONA)\n-#define m_CORE2_32 (1<<PROCESSOR_CORE2_32)\n-#define m_CORE2_64 (1<<PROCESSOR_CORE2_64)\n-#define m_COREI7_32 (1<<PROCESSOR_COREI7_32)\n-#define m_COREI7_64 (1<<PROCESSOR_COREI7_64)\n-#define m_COREI7 (m_COREI7_32 | m_COREI7_64)\n-#define m_CORE2I7_32 (m_CORE2_32 | m_COREI7_32)\n-#define m_CORE2I7_64 (m_CORE2_64 | m_COREI7_64)\n-#define m_CORE2I7 (m_CORE2I7_32 | m_CORE2I7_64)\n+#define m_CORE2 (1<<PROCESSOR_CORE2)\n+#define m_COREI7 (1<<PROCESSOR_COREI7)\n+#define m_CORE2I7 (m_CORE2 | m_COREI7)\n #define m_ATOM (1<<PROCESSOR_ATOM)\n \n #define m_GEODE (1<<PROCESSOR_GEODE)\n@@ -1665,7 +1768,7 @@ static unsigned int initial_ix86_tune_features[X86_TUNE_LAST] = {\n      negatively, so enabling for Generic64 seems like good code size\n      tradeoff.  We can't enable it for 32bit generic because it does not\n      work well with PPro base chips.  */\n-  m_386 | m_CORE2I7_64 | m_K6_GEODE | m_AMD_MULTIPLE | m_GENERIC64,\n+  m_386 | m_CORE2I7 | m_K6_GEODE | m_AMD_MULTIPLE | m_GENERIC64,\n \n   /* X86_TUNE_PUSH_MEMORY */\n   m_386 | m_P4_NOCONA | m_CORE2I7 | m_K6_GEODE | m_AMD_MULTIPLE | m_GENERIC,\n@@ -1856,19 +1959,19 @@ static unsigned int initial_ix86_tune_features[X86_TUNE_LAST] = {\n   m_PPRO | m_P4_NOCONA | m_CORE2I7 | m_ATOM | m_K6_GEODE | m_ATHLON_K8 | m_GENERIC,\n \n   /* X86_TUNE_AVOID_VECTOR_DECODE */\n-  m_CORE2I7_64 | m_K8 | m_GENERIC64,\n+  m_CORE2I7 | m_K8 | m_GENERIC64,\n \n   /* X86_TUNE_PROMOTE_HIMODE_IMUL: Modern CPUs have same latency for HImode\n      and SImode multiply, but 386 and 486 do HImode multiply faster.  */\n   ~(m_386 | m_486),\n \n   /* X86_TUNE_SLOW_IMUL_IMM32_MEM: Imul of 32-bit constant and memory is\n      vector path on AMD machines.  */\n-  m_CORE2I7_64 | m_K8 | m_AMDFAM10 | m_BDVER | m_BTVER | m_GENERIC64,\n+  m_CORE2I7 | m_K8 | m_AMDFAM10 | m_BDVER | m_BTVER | m_GENERIC64,\n \n   /* X86_TUNE_SLOW_IMUL_IMM8: Imul of 8-bit constant is vector path on AMD\n      machines.  */\n-  m_CORE2I7_64 | m_K8 | m_AMDFAM10 | m_BDVER | m_BTVER | m_GENERIC64,\n+  m_CORE2I7 | m_K8 | m_AMDFAM10 | m_BDVER | m_BTVER | m_GENERIC64,\n \n   /* X86_TUNE_MOVE_M1_VIA_OR: On pentiums, it is faster to load -1 via OR\n      than a MOV.  */\n@@ -2329,14 +2432,10 @@ static const struct ptt processor_target_table[PROCESSOR_max] =\n   {&pentium4_cost, 0, 0, 0, 0, 0},\n   {&k8_cost, 16, 7, 16, 7, 16},\n   {&nocona_cost, 0, 0, 0, 0, 0},\n-  /* Core 2 32-bit.  */\n-  {&generic32_cost, 16, 10, 16, 10, 16},\n-  /* Core 2 64-bit.  */\n-  {&generic64_cost, 16, 10, 16, 10, 16},\n-  /* Core i7 32-bit.  */\n-  {&generic32_cost, 16, 10, 16, 10, 16},\n-  /* Core i7 64-bit.  */\n-  {&generic64_cost, 16, 10, 16, 10, 16},\n+  /* Core 2  */\n+  {&core_cost, 16, 10, 16, 10, 16},\n+  /* Core i7  */\n+  {&core_cost, 16, 10, 16, 10, 16},\n   {&generic32_cost, 16, 7, 16, 7, 16},\n   {&generic64_cost, 16, 10, 16, 10, 16},\n   {&amdfam10_cost, 32, 24, 32, 7, 32},\n@@ -2799,23 +2898,23 @@ ix86_option_override_internal (bool main_args_p)\n       {\"nocona\", PROCESSOR_NOCONA, CPU_NONE,\n \tPTA_64BIT | PTA_MMX | PTA_SSE | PTA_SSE2 | PTA_SSE3\n \t| PTA_CX16 | PTA_NO_SAHF | PTA_FXSR},\n-      {\"core2\", PROCESSOR_CORE2_64, CPU_CORE2,\n+      {\"core2\", PROCESSOR_CORE2, CPU_CORE2,\n \tPTA_64BIT | PTA_MMX | PTA_SSE | PTA_SSE2 | PTA_SSE3\n \t| PTA_SSSE3 | PTA_CX16 | PTA_FXSR},\n-      {\"corei7\", PROCESSOR_COREI7_64, CPU_COREI7,\n+      {\"corei7\", PROCESSOR_COREI7, CPU_COREI7,\n \tPTA_64BIT | PTA_MMX | PTA_SSE | PTA_SSE2 | PTA_SSE3\n \t| PTA_SSSE3 | PTA_SSE4_1 | PTA_SSE4_2 | PTA_CX16 | PTA_FXSR},\n-      {\"corei7-avx\", PROCESSOR_COREI7_64, CPU_COREI7,\n+      {\"corei7-avx\", PROCESSOR_COREI7, CPU_COREI7,\n \tPTA_64BIT | PTA_MMX | PTA_SSE | PTA_SSE2 | PTA_SSE3\n \t| PTA_SSSE3 | PTA_SSE4_1 | PTA_SSE4_2 | PTA_AVX\n \t| PTA_CX16 | PTA_POPCNT | PTA_AES | PTA_PCLMUL\n \t| PTA_FXSR | PTA_XSAVE | PTA_XSAVEOPT},\n-      {\"core-avx-i\", PROCESSOR_COREI7_64, CPU_COREI7,\n+      {\"core-avx-i\", PROCESSOR_COREI7, CPU_COREI7,\n \tPTA_64BIT | PTA_MMX | PTA_SSE | PTA_SSE2 | PTA_SSE3\n \t| PTA_SSSE3 | PTA_SSE4_1 | PTA_SSE4_2 | PTA_AVX\n \t| PTA_CX16 | PTA_POPCNT | PTA_AES | PTA_PCLMUL | PTA_FSGSBASE\n \t| PTA_RDRND | PTA_F16C | PTA_FXSR | PTA_XSAVE | PTA_XSAVEOPT},\n-      {\"core-avx2\", PROCESSOR_COREI7_64, CPU_COREI7,\n+      {\"core-avx2\", PROCESSOR_COREI7, CPU_COREI7,\n \tPTA_64BIT | PTA_MMX | PTA_SSE | PTA_SSE2 | PTA_SSE3\n \t| PTA_SSSE3 | PTA_SSE4_1 | PTA_SSE4_2 | PTA_AVX | PTA_AVX2\n \t| PTA_CX16 | PTA_POPCNT | PTA_AES | PTA_PCLMUL | PTA_FSGSBASE\n@@ -3327,14 +3426,6 @@ ix86_option_override_internal (bool main_args_p)\n \t\tix86_schedule = CPU_PENTIUMPRO;\n \t\tbreak;\n \n-\t      case PROCESSOR_CORE2_64:\n-\t\tix86_tune = PROCESSOR_CORE2_32;\n-\t\tbreak;\n-\n-\t      case PROCESSOR_COREI7_64:\n-\t\tix86_tune = PROCESSOR_COREI7_32;\n-\t\tbreak;\n-\n \t      default:\n \t\tbreak;\n \t      }\n@@ -22282,7 +22373,7 @@ expand_constant_setmem_prologue (rtx dst, rtx destreg, rtx value,\n /* Given COUNT and EXPECTED_SIZE, decide on codegen of string operation.  */\n static enum stringop_alg\n decide_alg (HOST_WIDE_INT count, HOST_WIDE_INT expected_size, bool memset,\n-\t    int *dynamic_check)\n+\t    int *dynamic_check, bool *noalign)\n {\n   const struct stringop_algs * algs;\n   bool optimize_for_speed;\n@@ -22293,6 +22384,7 @@ decide_alg (HOST_WIDE_INT count, HOST_WIDE_INT expected_size, bool memset,\n   bool rep_prefix_usable = !(fixed_regs[CX_REG] || fixed_regs[DI_REG]\n                              || (memset\n \t\t\t\t ? fixed_regs[AX_REG] : fixed_regs[SI_REG]));\n+  *noalign = false;\n \n #define ALG_USABLE_P(alg) (rep_prefix_usable\t\t\t\\\n \t\t\t   || (alg != rep_prefix_1_byte\t\t\\\n@@ -22360,7 +22452,10 @@ decide_alg (HOST_WIDE_INT count, HOST_WIDE_INT expected_size, bool memset,\n \t\t  break;\n \t\t}\n \t      else if (ALG_USABLE_P (candidate))\n-\t\treturn candidate;\n+\t\t{\n+\t\t  *noalign = algs->size[i].noalign;\n+\t\t  return candidate;\n+\t\t}\n \t    }\n \t}\n       gcc_assert (TARGET_INLINE_ALL_STRINGOPS || !rep_prefix_usable);\n@@ -22401,7 +22496,7 @@ decide_alg (HOST_WIDE_INT count, HOST_WIDE_INT expected_size, bool memset,\n         }\n       if (max == -1)\n \tmax = 4096;\n-      alg = decide_alg (count, max / 2, memset, dynamic_check);\n+      alg = decide_alg (count, max / 2, memset, dynamic_check, noalign);\n       gcc_assert (*dynamic_check == -1);\n       gcc_assert (alg != libcall);\n       if (TARGET_INLINE_STRINGOPS_DYNAMICALLY)\n@@ -22515,6 +22610,7 @@ ix86_expand_movmem (rtx dst, rtx src, rtx count_exp, rtx align_exp,\n   enum stringop_alg alg;\n   int dynamic_check;\n   bool need_zero_guard = false;\n+  bool noalign;\n \n   if (CONST_INT_P (align_exp))\n     align = INTVAL (align_exp);\n@@ -22539,10 +22635,10 @@ ix86_expand_movmem (rtx dst, rtx src, rtx count_exp, rtx align_exp,\n   /* Step 0: Decide on preferred algorithm, desired alignment and\n      size of chunks to be copied by main loop.  */\n \n-  alg = decide_alg (count, expected_size, false, &dynamic_check);\n+  alg = decide_alg (count, expected_size, false, &dynamic_check, &noalign);\n   desired_align = decide_alignment (align, alg, expected_size);\n \n-  if (!TARGET_ALIGN_STRINGOPS)\n+  if (!TARGET_ALIGN_STRINGOPS || noalign)\n     align = desired_align;\n \n   if (alg == libcall)\n@@ -22910,6 +23006,7 @@ ix86_expand_setmem (rtx dst, rtx count_exp, rtx val_exp, rtx align_exp,\n   bool force_loopy_epilogue = false;\n   int dynamic_check;\n   bool need_zero_guard = false;\n+  bool noalign;\n \n   if (CONST_INT_P (align_exp))\n     align = INTVAL (align_exp);\n@@ -22929,10 +23026,10 @@ ix86_expand_setmem (rtx dst, rtx count_exp, rtx val_exp, rtx align_exp,\n   /* Step 0: Decide on preferred algorithm, desired alignment and\n      size of chunks to be copied by main loop.  */\n \n-  alg = decide_alg (count, expected_size, true, &dynamic_check);\n+  alg = decide_alg (count, expected_size, true, &dynamic_check, &noalign);\n   desired_align = decide_alignment (align, alg, expected_size);\n \n-  if (!TARGET_ALIGN_STRINGOPS)\n+  if (!TARGET_ALIGN_STRINGOPS || noalign)\n     align = desired_align;\n \n   if (alg == libcall)\n@@ -23935,10 +24032,8 @@ ix86_issue_rate (void)\n \n     case PROCESSOR_PENTIUMPRO:\n     case PROCESSOR_PENTIUM4:\n-    case PROCESSOR_CORE2_32:\n-    case PROCESSOR_CORE2_64:\n-    case PROCESSOR_COREI7_32:\n-    case PROCESSOR_COREI7_64:\n+    case PROCESSOR_CORE2:\n+    case PROCESSOR_COREI7:\n     case PROCESSOR_ATHLON:\n     case PROCESSOR_K8:\n     case PROCESSOR_AMDFAM10:\n@@ -24193,10 +24288,8 @@ ia32_multipass_dfa_lookahead (void)\n     case PROCESSOR_K6:\n       return 1;\n \n-    case PROCESSOR_CORE2_32:\n-    case PROCESSOR_CORE2_64:\n-    case PROCESSOR_COREI7_32:\n-    case PROCESSOR_COREI7_64:\n+    case PROCESSOR_CORE2:\n+    case PROCESSOR_COREI7:\n     case PROCESSOR_ATOM:\n       /* Generally, we want haifa-sched:max_issue() to look ahead as far\n \t as many instructions can be executed on a cycle, i.e.,\n@@ -24739,10 +24832,8 @@ ix86_sched_init_global (FILE *dump ATTRIBUTE_UNUSED,\n      they are actually used.  */\n   switch (ix86_tune)\n     {\n-    case PROCESSOR_CORE2_32:\n-    case PROCESSOR_CORE2_64:\n-    case PROCESSOR_COREI7_32:\n-    case PROCESSOR_COREI7_64:\n+    case PROCESSOR_CORE2:\n+    case PROCESSOR_COREI7:\n       /* Do not perform multipass scheduling for pre-reload schedule\n          to save compile time.  */\n       if (reload_completed)\n@@ -28572,13 +28663,11 @@ get_builtin_code_for_version (tree decl, tree *predicate_list)\n \t{\n \t  switch (new_target->arch)\n \t    {\n-\t    case PROCESSOR_CORE2_32:\n-\t    case PROCESSOR_CORE2_64:\n+\t    case PROCESSOR_CORE2:\n \t      arg_str = \"core2\";\n \t      priority = P_PROC_SSSE3;\n \t      break;\n-\t    case PROCESSOR_COREI7_32:\n-\t    case PROCESSOR_COREI7_64:\n+\t    case PROCESSOR_COREI7:\n \t      arg_str = \"corei7\";\n \t      priority = P_PROC_SSE4_2;\n \t      break;\n@@ -32868,7 +32957,7 @@ avx_vpermilp_parallel (rtx par, enum machine_mode mode)\n {\n   unsigned i, nelt = GET_MODE_NUNITS (mode);\n   unsigned mask = 0;\n-  unsigned char ipar[8];\n+  unsigned char ipar[8] = {};  /* Silence -Wuninitialized warning.  */\n \n   if (XVECLEN (par, 0) != (int) nelt)\n     return 0;\n@@ -32943,7 +33032,7 @@ avx_vperm2f128_parallel (rtx par, enum machine_mode mode)\n {\n   unsigned i, nelt = GET_MODE_NUNITS (mode), nelt2 = nelt / 2;\n   unsigned mask = 0;\n-  unsigned char ipar[8];\n+  unsigned char ipar[8] = {};  /* Silence -Wuninitialized warning.  */\n \n   if (XVECLEN (par, 0) != (int) nelt)\n     return 0;"}, {"sha": "443d92eadceb7293f1f750c9070f7a9f1b256724", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/340ef734b8072d2b58f946bb69170f2e535813d7/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/340ef734b8072d2b58f946bb69170f2e535813d7/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=340ef734b8072d2b58f946bb69170f2e535813d7", "patch": "@@ -101,6 +101,9 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n    known at compile time or estimated via feedback, the SIZE array\n    is walked in order until MAX is greater then the estimate (or -1\n    means infinity).  Corresponding ALG is used then.\n+   When NOALIGN is true the code guaranting the alignment of the memory\n+   block is skipped.\n+\n    For example initializer:\n     {{256, loop}, {-1, rep_prefix_4_byte}}\n    will use loop for blocks smaller or equal to 256 bytes, rep prefix will\n@@ -111,6 +114,7 @@ struct stringop_algs\n   const struct stringop_strategy {\n     const int max;\n     const enum stringop_alg alg;\n+    int noalign;\n   } size [MAX_STRINGOP_ALGS];\n };\n \n@@ -242,12 +246,8 @@ extern const struct processor_costs ix86_size_cost;\n #define TARGET_K8 (ix86_tune == PROCESSOR_K8)\n #define TARGET_ATHLON_K8 (TARGET_K8 || TARGET_ATHLON)\n #define TARGET_NOCONA (ix86_tune == PROCESSOR_NOCONA)\n-#define TARGET_CORE2_32 (ix86_tune == PROCESSOR_CORE2_32)\n-#define TARGET_CORE2_64 (ix86_tune == PROCESSOR_CORE2_64)\n-#define TARGET_CORE2 (TARGET_CORE2_32 || TARGET_CORE2_64)\n-#define TARGET_COREI7_32 (ix86_tune == PROCESSOR_COREI7_32)\n-#define TARGET_COREI7_64 (ix86_tune == PROCESSOR_COREI7_64)\n-#define TARGET_COREI7 (TARGET_COREI7_32 || TARGET_COREI7_64)\n+#define TARGET_CORE2 (ix86_tune == PROCESSOR_CORE2)\n+#define TARGET_COREI7 (ix86_tune == PROCESSOR_COREI7)\n #define TARGET_GENERIC32 (ix86_tune == PROCESSOR_GENERIC32)\n #define TARGET_GENERIC64 (ix86_tune == PROCESSOR_GENERIC64)\n #define TARGET_GENERIC (TARGET_GENERIC32 || TARGET_GENERIC64)\n@@ -2092,10 +2092,8 @@ enum processor_type\n   PROCESSOR_PENTIUM4,\n   PROCESSOR_K8,\n   PROCESSOR_NOCONA,\n-  PROCESSOR_CORE2_32,\n-  PROCESSOR_CORE2_64,\n-  PROCESSOR_COREI7_32,\n-  PROCESSOR_COREI7_64,\n+  PROCESSOR_CORE2,\n+  PROCESSOR_COREI7,\n   PROCESSOR_GENERIC32,\n   PROCESSOR_GENERIC64,\n   PROCESSOR_AMDFAM10,"}]}