{"sha": "07cdae91c9e7e8cc31ac231105bdd694bd24d3e7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDdjZGFlOTFjOWU3ZThjYzMxYWMyMzExMDViZGQ2OTRiZDI0ZDNlNw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2002-04-15T20:19:23Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2002-04-15T20:19:23Z"}, "message": "MAINTAINERS: Remove chill maintainers.\n\n\t* MAINTAINERS: Remove chill maintainers.\n\t* Makefile.in (CHILLFLAGS): Remove.\n\t(CHILL_LIB): Remove.\n\t(TARGET_CONFIGDIRS): Remove libchill.\n\t(CHILL_FOR_TARGET): Remove.\n\t(BASE_FLAGS_TO_PASS): Don't pass CHILLFLAGS, CHILL_FOR_TARGET, or\n\tCHILL_LIB.\n\t(CONFIGURE_TARGET_MODULES): Remove configure-target-libchill.\n\t(CHECK_TARGET_MODULES): Likewise.\n\t(INSTALL_TARGET_MODULES): Likewise.\n\t(CLEAN_TARGET_MODULES): Likewise.\n\t(configure-target-libchill): Remove.\n\t(all-target-libchill): Remove.\n\t* configure.in (target_libs): Remove target-libchill.\n\tDo not compute CHILL_FOR_TARGET.\n\t* libchill: Remove directory.\n\n\tRemove Chill front end.\n\t* gcc.c (default_compilers): Remove Chill entries.\n\t* ch: Remove directory.\n\t* doc/frontends.texi: Remove information about Chill.\n\t* doc/sourcebuild.texi: Likewise.\n\t* doc/standards.texi: Likewise.\n\n\t* testsuite/lib/chill.exp: Remove.\n\n\t* g77.texi: Remove Chill reference.\n\n\t* gcc_release (build_tarfiles): Do not build Chill tarfiles.\n\t(CHILL_DIRS): Remove.\n\nFrom-SVN: r52327", "tree": {"sha": "86c25b946563991003f1f4c063d07c387679496e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/86c25b946563991003f1f4c063d07c387679496e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/07cdae91c9e7e8cc31ac231105bdd694bd24d3e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07cdae91c9e7e8cc31ac231105bdd694bd24d3e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07cdae91c9e7e8cc31ac231105bdd694bd24d3e7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07cdae91c9e7e8cc31ac231105bdd694bd24d3e7/comments", "author": null, "committer": null, "parents": [{"sha": "41823c5eb7d4504b6a4a396ca0d64573238fbbcf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41823c5eb7d4504b6a4a396ca0d64573238fbbcf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/41823c5eb7d4504b6a4a396ca0d64573238fbbcf"}], "stats": {"total": 57128, "additions": 48, "deletions": 57080}, "files": [{"sha": "68e77bf26e4848078bb1460525c5b305daf7bfd4", "filename": "ChangeLog", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07cdae91c9e7e8cc31ac231105bdd694bd24d3e7/ChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07cdae91c9e7e8cc31ac231105bdd694bd24d3e7/ChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/ChangeLog?ref=07cdae91c9e7e8cc31ac231105bdd694bd24d3e7", "patch": "@@ -1,4 +1,22 @@\n-\n+2002-04-15  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* MAINTAINERS: Remove chill maintainers.\n+\t* Makefile.in (CHILLFLAGS): Remove.\n+\t(CHILL_LIB): Remove.\n+\t(TARGET_CONFIGDIRS): Remove libchill.\n+\t(CHILL_FOR_TARGET): Remove.\n+\t(BASE_FLAGS_TO_PASS): Don't pass CHILLFLAGS, CHILL_FOR_TARGET, or\n+\tCHILL_LIB.\n+\t(CONFIGURE_TARGET_MODULES): Remove configure-target-libchill.\n+\t(CHECK_TARGET_MODULES): Likewise.\n+\t(INSTALL_TARGET_MODULES): Likewise.\n+\t(CLEAN_TARGET_MODULES): Likewise.\n+\t(configure-target-libchill): Remove.\n+\t(all-target-libchill): Remove.\n+\t* configure.in (target_libs): Remove target-libchill.\n+\tDo not compute CHILL_FOR_TARGET.\n+\t* libchill: Remove directory.\n+\t\n 2002-04-11  DJ Delorie  <dj@redhat.com>\n \n \t* Makefile.in, configure.in: Sync with binutils, entries"}, {"sha": "b18976130d55fbf4bac2d354192cb0512981c697", "filename": "MAINTAINERS", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07cdae91c9e7e8cc31ac231105bdd694bd24d3e7/MAINTAINERS", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07cdae91c9e7e8cc31ac231105bdd694bd24d3e7/MAINTAINERS", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/MAINTAINERS?ref=07cdae91c9e7e8cc31ac231105bdd694bd24d3e7", "patch": "@@ -77,8 +77,6 @@ fortran\t\t\tRichard Henderson\trth@redhat.com\n fortran\t\t\tToon Moene\t\ttoon@moene.indiv.nluug.nl\n c++\t\t\tJason Merrill\t\tjason@redhat.com\n c++                     Mark Mitchell\t\tmark@codesourcery.com\n-chill\t\t\tDave Brolley\t\tbrolley@redhat.com\n-chill\t\t\tPer Bothner\t\tper@bothner.com\n cpplib\t\t\tDave Brolley\t\tbrolley@redhat.com\n cpplib\t\t\tPer Bothner\t\tper@bothner.com\n cpplib\t\t\tZack Weinberg\t\tzack@codesourcery.com"}, {"sha": "94f0a35f669c980f96291f93f5bcaa20a558625f", "filename": "Makefile.in", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07cdae91c9e7e8cc31ac231105bdd694bd24d3e7/Makefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07cdae91c9e7e8cc31ac231105bdd694bd24d3e7/Makefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/Makefile.in?ref=07cdae91c9e7e8cc31ac231105bdd694bd24d3e7", "patch": "@@ -100,8 +100,6 @@ LIBCFLAGS_FOR_TARGET = $(CFLAGS_FOR_TARGET)\n PICFLAG = \n PICFLAG_FOR_TARGET = \n \n-CHILLFLAGS = $(CFLAGS)\n-CHILL_LIB = -lchill\n CXX = c++\n \n # Use -O2 to stress test the compiler.\n@@ -178,7 +176,7 @@ OTHERS =\n \n # This is set by the configure script to the list of directories which\n # should be built using the target tools.\n-TARGET_CONFIGDIRS = libiberty libgloss $(SPECIAL_LIBS) newlib librx winsup opcodes bsp libstub cygmon libf2c libchill libobjc\n+TARGET_CONFIGDIRS = libiberty libgloss $(SPECIAL_LIBS) newlib librx winsup opcodes bsp libstub cygmon libf2c libobjc\n \n # Target libraries are put under this directory:\n # Changed by configure to $(target_alias) if cross.\n@@ -235,7 +233,6 @@ INSTALL_TARGET_CROSS = installdirs \\\n # Should be substed by configure.in\n FLAGS_FOR_TARGET =\n CC_FOR_TARGET =\n-CHILL_FOR_TARGET =\n CXX_FOR_TARGET =\n CXX_FOR_TARGET_FOR_RECURSIVE_MAKE =\n GCJ_FOR_TARGET =\n@@ -359,9 +356,6 @@ BASE_FLAGS_TO_PASS = \\\n \t\"CC_FOR_TARGET=$(CC_FOR_TARGET)\" \\\n \t\"CFLAGS=$(CFLAGS)\" \\\n \t\"CFLAGS_FOR_TARGET=$(CFLAGS_FOR_TARGET)\" \\\n-\t\"CHILLFLAGS=$(CHILLFLAGS)\" \\\n-\t\"CHILL_FOR_TARGET=$(CHILL_FOR_TARGET)\" \\\n-\t\"CHILL_LIB=$(CHILL_LIB)\" \\\n \t\"GCJ_FOR_TARGET=$(GCJ_FOR_TARGET)\" \\\n \t\"CXX_FOR_BUILD=$(CXX_FOR_BUILD)\" \\\n \t\"CXXFLAGS=$(CXXFLAGS)\" \\\n@@ -789,7 +783,6 @@ ALL_TARGET_MODULES = \\\n \tall-target-librx \\\n \tall-target-newlib \\\n \tall-target-libf2c \\\n-\tall-target-libchill \\\n \tall-target-libobjc \\\n \tall-target-libtermcap \\\n \tall-target-winsup \\\n@@ -813,7 +806,6 @@ CONFIGURE_TARGET_MODULES = \\\n \tconfigure-target-librx \\\n \tconfigure-target-newlib \\\n \tconfigure-target-libf2c \\\n-\tconfigure-target-libchill \\\n \tconfigure-target-libobjc \\\n \tconfigure-target-libtermcap \\\n \tconfigure-target-winsup \\\n@@ -836,7 +828,6 @@ CHECK_TARGET_MODULES = \\\n \tcheck-target-libstdc++-v3 \\\n \tcheck-target-newlib \\\n \tcheck-target-libf2c \\\n-\tcheck-target-libchill \\\n \tcheck-target-libobjc \\\n \tcheck-target-winsup \\\n \tcheck-target-libiberty \\\n@@ -853,7 +844,6 @@ INSTALL_TARGET_MODULES = \\\n \tinstall-target-libstdc++-v3 \\\n \tinstall-target-newlib \\\n \tinstall-target-libf2c \\\n-\tinstall-target-libchill \\\n \tinstall-target-libobjc \\\n \tinstall-target-libtermcap \\\n \tinstall-target-winsup \\\n@@ -942,7 +932,6 @@ CLEAN_TARGET_MODULES = \\\n \tclean-target-librx \\\n \tclean-target-newlib \\\n \tclean-target-libf2c \\\n-\tclean-target-libchill \\\n \tclean-target-libobjc \\\n \tclean-target-winsup \\\n \tclean-target-libgloss \\\n@@ -1787,8 +1776,6 @@ all-target-libstub: configure-target-libstub\n all-libtool:\n configure-target-libf2c: $(ALL_GCC_C)\n all-target-libf2c: configure-target-libf2c all-target-libiberty\n-configure-target-libchill: $(ALL_GCC_C)\n-all-target-libchill: configure-target-libchill all-target-libiberty\n configure-target-libobjc: $(ALL_GCC_C)\n all-target-libobjc: configure-target-libobjc all-target-libiberty\n all-m4: all-libiberty all-texinfo"}, {"sha": "9d71f6efbcab5429ef0700a7177a1e50abc1d01e", "filename": "configure.in", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07cdae91c9e7e8cc31ac231105bdd694bd24d3e7/configure.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07cdae91c9e7e8cc31ac231105bdd694bd24d3e7/configure.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/configure.in?ref=07cdae91c9e7e8cc31ac231105bdd694bd24d3e7", "patch": "@@ -73,7 +73,6 @@ target_libs=\"target-libiberty \\\n \t\ttarget-librx \\\n \t\t${libstdcxx_version} \\\n \t\ttarget-libf2c \\\n-\t\ttarget-libchill \\\n \t\t${libgcj}\n \t\ttarget-libobjc\"\n \n@@ -1526,20 +1525,6 @@ case $CC_FOR_TARGET in\n *) CC_FOR_TARGET=$CC_FOR_TARGET' $(FLAGS_FOR_TARGET)' ;;\n esac\n \n-if test \"x${CHILL_FOR_TARGET+set}\" = xset; then\n-  :\n-elif test -d ${topsrcdir}/gcc; then\n-  CHILL_FOR_TARGET='$$r/gcc/xgcc -B$$r/gcc/ -L$$r/gcc/ch/runtime/'\n-elif test \"$host\" = \"$target\"; then\n-  CHILL_FOR_TARGET='$(CC)'\n-else\n-  CHILL_FOR_TARGET=`echo gcc | sed -e 's/x/x/' ${program_transform_name}`\n-fi\n-case $CHILL_FOR_TARGET in\n-*' $(FLAGS_FOR_TARGET)') ;;\n-*) CHILL_FOR_TARGET=$CHILL_FOR_TARGET' $(FLAGS_FOR_TARGET)' ;;\n-esac\n-\n if test \"x${GCJ_FOR_TARGET+set}\" = xset; then\n   :\n elif test -d ${topsrcdir}/gcc; then\n@@ -1586,7 +1571,6 @@ s:^TARGET_CONFIGDIRS[ \t]*=.*$:TARGET_CONFIGDIRS = ${target_configdirs}:\n s%^TARGET_CONFIGARGS[ \t]*=.*$%TARGET_CONFIGARGS = ${targargs}%\n s%^FLAGS_FOR_TARGET[ \t]*=.*$%FLAGS_FOR_TARGET = ${FLAGS_FOR_TARGET}%\n s%^CC_FOR_TARGET[ \t]*=.*$%CC_FOR_TARGET = ${CC_FOR_TARGET}%\n-s%^CHILL_FOR_TARGET[ \t]*=.*$%CHILL_FOR_TARGET = ${CHILL_FOR_TARGET}%\n s%^GCJ_FOR_TARGET[      ]*=.*$%GCJ_FOR_TARGET = ${GCJ_FOR_TARGET}%\n s%^CXX_FOR_TARGET[ \t]*=.*$%CXX_FOR_TARGET = ${qCXX_FOR_TARGET}%\n s%^CXX_FOR_TARGET_FOR_RECURSIVE_MAKE[ \t]*=.*$%CXX_FOR_TARGET_FOR_RECURSIVE_MAKE = ${qqCXX_FOR_TARGET}%"}, {"sha": "772c2b0245ca55c22644d590a746cc03f1d9abf3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07cdae91c9e7e8cc31ac231105bdd694bd24d3e7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07cdae91c9e7e8cc31ac231105bdd694bd24d3e7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=07cdae91c9e7e8cc31ac231105bdd694bd24d3e7", "patch": "@@ -1,3 +1,12 @@\n+2002-04-15  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tRemove Chill front end.\n+\t* gcc.c (default_compilers): Remove Chill entries.\n+\t* ch: Remove directory.\n+\t* doc/frontends.texi: Remove information about Chill.\n+\t* doc/sourcebuild.texi: Likewise.\n+\t* doc/standards.texi: Likewise.\n+\n 2002-04-15  Douglas B Rupp  <rupp@gnat.com>\n \n \t* config/alpha/vms.h (INCLUDE_DEFAULTS): Add /gnu/lib/gcc-lib/include."}, {"sha": "5dafdbb353f7c70f435edf21df44d0e33000bf36", "filename": "gcc/ch/ChangeLog", "status": "removed", "additions": 0, "deletions": 12347, "changes": 12347, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41823c5eb7d4504b6a4a396ca0d64573238fbbcf/gcc%2Fch%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41823c5eb7d4504b6a4a396ca0d64573238fbbcf/gcc%2Fch%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2FChangeLog?ref=41823c5eb7d4504b6a4a396ca0d64573238fbbcf"}, {"sha": "a45d9cd00adbf8d14561ce81ddefab9fec816b35", "filename": "gcc/ch/Make-lang.in", "status": "removed", "additions": 0, "deletions": 184, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41823c5eb7d4504b6a4a396ca0d64573238fbbcf/gcc%2Fch%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41823c5eb7d4504b6a4a396ca0d64573238fbbcf/gcc%2Fch%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2FMake-lang.in?ref=41823c5eb7d4504b6a4a396ca0d64573238fbbcf", "patch": "@@ -1,184 +0,0 @@\n-# Top level Makefile fragment for GNU CHILL.\n-#   Copyright (C) 1994, 1998, 2000 Free Software Foundation, Inc.\n-\n-#This file is part of GNU CC.\n-\n-#GNU CC is free software; you can redistribute it and/or modify\n-#it under the terms of the GNU General Public License as published by\n-#the Free Software Foundation; either version 2, or (at your option)\n-#any later version.\n-\n-#GNU CC is distributed in the hope that it will be useful,\n-#but WITHOUT ANY WARRANTY; without even the implied warranty of\n-#MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-#GNU General Public License for more details.\n-\n-#You should have received a copy of the GNU General Public License\n-#along with GNU CC; see the file COPYING.  If not, write to\n-#the Free Software Foundation, 59 Temple Place - Suite 330,\n-#Boston, MA 02111-1307, USA.  */\n-\n-# This file provides the language dependent support in the main Makefile.\n-# Each language makefile fragment must provide the following targets:\n-#\n-# foo.all.build, foo.all.cross, foo.start.encap, foo.rest.encap,\n-# foo.info, foo.dvi,\n-# foo.install-normal, foo.install-common, foo.install-info, foo.install-man,\n-# foo.uninstall,\n-# foo.mostlyclean, foo.clean, foo.distclean, foo.extraclean,\n-# foo.maintainer-clean, foo.stage1, foo.stage2, foo.stage3, foo.stage4\n-#\n-# where `foo' is the name of the language.\n-#\n-# It should also provide rules for:\n-#\n-# - making any compiler driver (eg: g++)\n-# - the compiler proper (eg: cc1plus)\n-# - define the names for selecting the language in LANGUAGES.\n-#\f\n-# define version of GNUCHILL compiler. Note: maybe we have to change the\n-# mechanism\n-GNUCHILL_VERSION = 1.5.2\n-\n-# Actual names to use when installing a native compiler.\n-# (Cygnus configure overrides these when using -program-transform-name).\n-CHILL_INSTALL_NAME = chill\n-\n-# Actual names to use when installing a cross-compiler.\n-# (Cygnus configure overrides these when using -program-transform-name).\n-CHILL_CROSS_NAME = $(target_alias)-chill\n-\n-CHILL_SRCS = $(srcdir)/ch/actions.c $(srcdir)/ch/convert.c \\\n- $(srcdir)/ch/decl.c $(srcdir)/ch/except.c $(srcdir)/ch/expr.c \\\n- $(srcdir)/ch/grant.c $(srcdir)/ch/inout.c $(srcdir)/ch/lang.c \\\n- $(srcdir)/ch/lex.c $(srcdir)/ch/loop.c \\\n- $(srcdir)/ch/parse.c $(srcdir)/ch/satisfy.c \\\n- $(srcdir)/ch/tasking.c $(srcdir)/ch/timing.c $(srcdir)/ch/tree.c \\\n- $(srcdir)/ch/typeck.c\n-\n-# Extra flags to pass to recursive makes.\n-CHILL_FLAGS_TO_PASS = \\\n-\t\"CHILLFLAGS=$(CHILLFLAGS)\" \\\n-\t\"CHILL_FOR_TARGET=$(CHILL_FOR_TARGET)\" \\\n-\t\"CHILL_LIB=$(CHILL_LIB)\" \\\n-\t\"GNUCHILL_VERSION=$(GNUCHILL_VERSION)\"\n-#\f\n-# Define the names for selecting languages in LANGUAGES.\n-CHILL: chill cc1chill$(exeext)\n-\n-# handle startfile in chill script and build script to install\n-chill: $(srcdir)/ch/chill.in Makefile\n-\tthisdir=`pwd` ; \\\n-\tsed -e \"s:startfile=chillrt0:startfile=$${thisdir}/ch/runtime/chillrt0.o:\" \\\n-\t    -e \"s:libpath=chillrt:libpath=-L$${thisdir}/ch/runtime/:\" \\\n-\t    -e \"s:whatgcc=gcc:whatgcc=\\\"$${thisdir}/xgcc$(exeext) -B$${thisdir}/\\\":\" \\\n-\t    -e \"s:gnuchill_version=unknown:gnuchill_version=$(GNUCHILL_VERSION):\" \\\n-\t    -e \"s:gnuchill_script_flags=:gnuchill_script_flags=\\\"$(GNUCHILL_SCRIPT_FLAGS)\\\":\" $(srcdir)/ch/chill.in > chill ; \\\n-\tchmod a+x chill ; \\\n-\tif [ -f ../gcc-cross$(exeext) ]; then \\\n-\t  whatgcc=$(GCC_CROSS_NAME) ; \\\n-\telse \\\n-\t  whatgcc=$(GCC_INSTALL_NAME) ; \\\n-\tfi; \\\n-\tsed -e \"s:startfile=chillrt0:startfile=$(libsubdir)/chillrt0.o:\" \\\n-\t    -e \"s:whatgcc=gcc:whatgcc=$(bindir)/$${whatgcc}:\" \\\n-\t    -e \"s:gnuchill_version=unknown:gnuchill_version=$(GNUCHILL_VERSION):\" \\\n-\t    -e \"s:libpath=chillrt:libpath=:\" \\\n-\t    -e \"s:gnuchill_script_flags=:gnuchill_script_flags=\\\"$(GNUCHILL_SCRIPT_FLAGS)\\\":\" $(srcdir)/ch/chill.in > chill.install ; \\\n-\tchmod a+x chill.install\n-\n-# Don't depend on cc1chill$(exeext), because chill-cross is always built for cross,\n-# and thus a cc1chill$(exeext) dependence would force cc1chill$(exeext) to always be built.\n-# Note that gcc-cross and g++-cross do not have cc1 or cc1plus dependencies.\n-chill-cross: $(srcdir)/ch/chill.in\n-\ttouch $@\n-\n-cc1chill$(exeext): $(P) $(CHILL_SRCS) $(LIBDEPS) $(BACKEND) \\\n-\tinsn-config.h insn-flags.h insn-attr.h insn-codes.h \\\n-\tattribs.o c-typeck.o c-aux-info.o c-common.o \\\n-        ggc-callbacks.o\n-\tcd ch; $(MAKE) $(LANG_FLAGS_TO_PASS) $(CHILL_FLAGS_TO_PASS) ../cc1chill$(exeext)\n-\n-#\f\n-# Build hooks:\n-\n-CHILL.all.build: chill\n-CHILL.all.cross: chill-cross\n-CHILL.start.encap: chill\n-CHILL.rest.encap:\n-CHILL.dvi: ch/chill.dvi\n-CHILL.generated-manpages:\n-\n-CHILL.info: $(srcdir)/ch/chill.info\n-\n-$(srcdir)/ch/chill.info: $(srcdir)/ch/chill.texi\n-\tcd $(srcdir)/ch && $(MAKEINFO) -o chill.info chill.texi\n-\n-ch/chill.dvi: $(srcdir)/ch/chill.texi\n-\ts=`cd $(srcdir); pwd`; export s; \\\n-\tcd ch && $(TEXI2DVI) $$s/ch/chill.texi\n-\n-#\f\n-# Install hooks:\n-# cc1chill is installed elsewhere as part of $(COMPILERS).\n-\n-CHILL.install-normal:\n-\n-# Install the driver program\n-CHILL.install-common: installdirs\n-\t-if [ -f cc1chill$(exeext) ] ; then \\\n-\t  if [ -f chill.install ] ; then \\\n-\t    if [ -f gcc-cross$(exeext) ]; then \\\n-\t      rm -f $(bindir)/$(CHILL_CROSS_NAME); \\\n-\t      $(INSTALL_SCRIPT) chill.install $(bindir)/$(CHILL_CROSS_NAME); \\\n-\t      chmod a+x $(bindir)/$(CHILL_CROSS_NAME); \\\n-\t    else \\\n-\t      rm -f $(bindir)/$(CHILL_INSTALL_NAME); \\\n-\t      $(INSTALL_SCRIPT) chill.install $(bindir)/$(CHILL_INSTALL_NAME); \\\n-\t      chmod a+x $(bindir)/$(CHILL_INSTALL_NAME); \\\n-\t    fi ; \\\n-\t  fi ; \\\n-\tfi\n-\n-# Don't delete $(infodir)/ch.info* unless there's actually new\n-# docs to install (in case LANGUAGES didn't contain chill earlier).\n-CHILL.install-info: installdirs\n-\t-cd $(srcdir)/ch; for i in chill.info*; do \\\n-\t  rm -f $(infodir)/chill.info*; \\\n-\t  realfile=`echo $$i | sed -e 's|.*/\\([^/]*\\)$$|\\1|'`; \\\n-\t  $(INSTALL_DATA) $$i $(infodir)/$$realfile; \\\n-\tdone\n-\n-CHILL.install-man:\n-\n-CHILL.uninstall:\n-\t-rm -rf $(bindir)/$(CHILL_INSTALL_NAME)\n-\t-rm -rf $(bindir)/$(CHILL_CROSS_NAME)\n-#\f\n-# Clean hooks:\n-# A lot of the ancillary files are deleted by the main makefile.\n-# We just have to delete files specific to us.\n-\n-CHILL.mostlyclean:\n-\t-rm -f chill.install ch/*.o ch/ch-version.c\n-CHILL.clean:\n-CHILL.distclean:\n-\t-rm -f ch/config.status ch/Makefile\n-CHILL.extraclean:\n-CHILL.maintainer-clean:\n-\t-rm -f ch/TAGS\n-\t-rm -f $(srcdir)/ch/chill.info* ch/chill.dvi ch/chill.??s ch/chill.*aux\n-# Delete locally created file.\n-\t-rm -f ch/hash.h\n-#\f\n-# Stage hooks:\n-# The main makefile has already created stage?/ch.\n-\n-CHILL.stage1: stage1-start\n-\t-mv ch/*.o stage1/ch\n-CHILL.stage2: stage2-start\n-\t-mv ch/*.o stage2/ch\n-CHILL.stage3: stage3-start\n-\t-mv ch/*.o stage3/ch\n-CHILL.stage4: stage4-start\n-\t-mv ch/*.o stage4/ch"}, {"sha": "76aa268013ddec83956fa7d46f997549449dc9ab", "filename": "gcc/ch/Makefile.in", "status": "removed", "additions": 0, "deletions": 324, "changes": 324, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41823c5eb7d4504b6a4a396ca0d64573238fbbcf/gcc%2Fch%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41823c5eb7d4504b6a4a396ca0d64573238fbbcf/gcc%2Fch%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2FMakefile.in?ref=41823c5eb7d4504b6a4a396ca0d64573238fbbcf", "patch": "@@ -1,324 +0,0 @@\n-# Makefile for GNU CHILL compiler.\n-#   Copyright (C) 1987, 1988, 1990, 1991, 1992, 1993, 1994, 1998,\n-#   1999, 2000, 2001 Free Software Foundation, Inc.\n-\n-#This file is part of GNU CC.\n-\n-#GNU CC is free software; you can redistribute it and/or modify\n-#it under the terms of the GNU General Public License as published by\n-#the Free Software Foundation; either version 2, or (at your option)\n-#any later version.\n-\n-#GNU CC is distributed in the hope that it will be useful,\n-#but WITHOUT ANY WARRANTY; without even the implied warranty of\n-#MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-#GNU General Public License for more details.\n-\n-#You should have received a copy of the GNU General Public License\n-#along with GNU CC; see the file COPYING.  If not, write to\n-#the Free Software Foundation, 59 Temple Place - Suite 330,\n-#Boston, MA 02111-1307, USA.  */\n-\n-# The makefile built from this file lives in the language subdirectory.\n-# It's purpose is to provide support for:\n-#\n-# 1) recursion where necessary, and only then (building .o's), and\n-# 2) building and debugging cc1 from the language subdirectory, and\n-# 3) nothing else.\n-#\n-# The parent makefile handles all other chores, with help from the\n-# language makefile fragment, of course.\n-#\n-# The targets for external use are:\n-# all, TAGS, ???mostlyclean, ???clean.\n-\n-# Suppress smart makes who think they know how to automake Yacc files\n-.y.c:\n-\n-\n-# Variables that exist for you to override.\n-# See below for how to change them for certain systems.\n-\n-# Various ways of specifying flags for compilations:  \n-# CFLAGS is for the user to override to, e.g., do a bootstrap with -O2.\n-# BOOT_CFLAGS is the value of CFLAGS to pass\n-# to the stage2 and stage3 compilations\n-# XCFLAGS is used for most compilations but not when using the GCC just built.\n-XCFLAGS =\n-CFLAGS = -g\n-BOOT_CFLAGS = -O $(CFLAGS)\n-# These exists to be overridden by the x-* and t-* files, respectively.\n-X_CFLAGS =\n-T_CFLAGS =\n-\n-X_CPPFLAGS =\n-T_CPPFLAGS =\n-\n-CC = @CC@\n-AR = ar\n-AR_FLAGS = rc\n-SHELL = /bin/sh\n-MAKEINFO = makeinfo\n-TEXI2DVI = texi2dvi\n-\n-# Define this as & to perform parallel make on a Sequent.\n-# Note that this has some bugs, and it seems currently necessary \n-# to compile all the gen* files first by hand to avoid erroneous results.\n-P =\n-\n-# This is used instead of ALL_CFLAGS when compiling with GCC_FOR_TARGET.\n-# It omits XCFLAGS, and specifies -B./.\n-# It also specifies -B$(tooldir)/ to find as and ld for a cross compiler.\n-GCC_CFLAGS=$(INTERNAL_CFLAGS) $(X_CFLAGS) $(T_CFLAGS) $(CFLAGS)\n-\n-# Tools to use when building a cross-compiler.\n-# These are used because `configure' appends `cross-make'\n-# to the makefile when making a cross-compiler.\n-\n-# We don't use cross-make.  Instead we use the tools\n-# from the build tree, if they are available.\n-# program_transform_name and objdir are set by configure.in.\n-program_transform_name =\n-objdir = .\n-\n-target=@target@\n-xmake_file=@dep_host_xmake_file@\n-tmake_file=@dep_tmake_file@\n-#version=`sed -e 's/.*\\\"\\([^ \\\"]*\\)[ \\\"].*/\\1/' < $(srcdir)/version.c`\n-#mainversion=`sed -e 's/.*\\\"\\([0-9]*\\.[0-9]*\\).*/\\1/' < $(srcdir)/version.c`\n-\n-# Directory where sources are, from where we are.\n-srcdir = @srcdir@\n-VPATH = @srcdir@\n-\n-# Directory where texinfo.tex lives\n-# texidir = $(srcdir)/../../texinfo\n-\n-# Top build directory, relative to here.\n-top_builddir = ..\n-\n-# Internationalization library.\n-INTLLIBS = @INTLLIBS@\n-\n-# Additional system libraries to link with.\n-CLIB=\n-\n-# End of variables for you to override.\n-\n-# Definition of `all' is here so that new rules inserted by sed\n-# do not specify the default target.\n-all: all.indirect\n-\n-# This tells GNU Make version 3 not to put all variables in the environment.\n-.NOEXPORT:\n-\n-# sed inserts variable overrides after the following line.\n-####target overrides\n-@target_overrides@\n-\n-####host overrides\n-@host_overrides@\n-#\f\n-# Now figure out from those variables how to compile and link.\n-\n-all.indirect: Makefile ../chill ../cc1chill$(exeext)\n-\n-# IN_GCC distinguishes between code compiled into GCC itself and other\n-# programs built during a bootstrap.\n-# autoconf inserts -DCROSS_COMPILE if we are building a cross compiler.\n-INTERNAL_CFLAGS = -DIN_GCC @CROSS@\n-\n-# This is the variable actually used when we compile.\n-ALL_CFLAGS = $(INTERNAL_CFLAGS) $(X_CFLAGS) $(T_CFLAGS) $(CFLAGS) $(XCFLAGS)\n-\n-# Likewise.\n-ALL_CPPFLAGS = $(CPPFLAGS) $(X_CPPFLAGS) $(T_CPPFLAGS)\n-\n-# This is where we get libiberty.a from.\n-LIBIBERTY = ../../libiberty/libiberty.a\n-\n-# How to link with both our special library facilities\n-# and the system's installed libraries.\n-LIBS = $(LIBIBERTY) $(CLIB) $(INTLLIBS)\n-LIBDEPS = $(INTLLIBS) $(LIBIBERTY)\n-\n-# Specify the directories to be searched for header files.\n-# Both . and srcdir are used, in that order,\n-# so that tm.h and config.h will be found in the compilation\n-# subdirectory rather than in the source directory.\n-INCLUDES = -I. -I.. -I$(srcdir) -I$(srcdir)/.. -I$(srcdir)/../config -I$(srcdir)/../../include\n-\n-# Flags to pass to recursive makes.\n-# ??? $(CC) may need some work to handle stage[123].\n-# ??? The choices here will need some experimenting with.\n-FLAGS_TO_PASS = \\\n-\t\"AR_FLAGS=$(AR_FLAGS)\" \\\n-\t\"AR_FOR_TARGET=$(AR_FOR_TARGET)\" \\\n-\t\"BISON=$(BISON)\" \\\n-\t\"BISONFLAGS=$(BISONFLAGS)\" \\\n-\t\"CC=$(CC)\" \\\n-\t\"CFLAGS=$(CFLAGS)\" \\\n-\t\"GCC_FOR_TARGET=$(CC_FOR_TARGET)\" \\\n-\t\"LDFLAGS=$(LDFLAGS)\" \\\n-\t\"LEX=$(LEX)\" \\\n-\t\"LEXFLAGS=$(LEXFLAGS)\" \\\n-\t\"MAKEINFO=$(MAKEINFO)\" \\\n-\t\"MAKEINFOFLAGS=$(MAKEINFOFLAGS)\" \\\n-\t\"RANLIB_FOR_TARGET=$(RANLIB_FOR_TARGET)\" \\\n-\t\"RANLIB_TEST_FOR_TARGET=$(RANLIB_TEST_FOR_TARGET)\" \\\n-\t\"SHELL=$(SHELL)\" \\\n-\t\"exec_prefix=$(exec_prefix)\" \\\n-\t\"prefix=$(prefix)\" \\\n-\t\"tooldir=$(tooldir)\" \\\n-\t\"bindir=$(bindir)\" \\\n-\t\"libsubdir=$(libsubdir)\"\n-\n-# Always use -I$(srcdir)/config when compiling.\n-.c.o:\n-\t$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $<\n-\n-# This tells GNU make version 3 not to export all the variables\n-# defined in this file into the environment.\n-.NOEXPORT:\n-#\f\n-# Lists of files for various purposes.\n-\n-# Language-specific object files for CHILL\n-\n-CHILL_OBJS = parse.o actions.o except.o grant.o lang.o \\\n-   tree.o lex.o decl.o typeck.o convert.o expr.o loop.o \\\n-   tasking.o timing.o inout.o satisfy.o ch-version.o \\\n-   ../ggc-callbacks.o\n-\n-BACKEND = ../toplev.o ../libbackend.a\n-\n-../cc1chill$(exeext): $(P) $(CHILL_OBJS) $(BACKEND) $(LIBDEPS)\n-\t$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o $@ $(CHILL_OBJS) \\\n-\t      $(BACKEND) $(LIBS)\n-\n-# This executable is used in the CHILL regression \n-# test script\n-utils/printf : $(srcdir)/utils/printf.c\n-\t$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o $@ $<\n-\n-#\n-# This is the top-level trigger for a CHILL regression test.\n-# It also builds those tools needed for CHILL regression testing.\n-#\n-check: ../cc1chill$(exeext) utils/printf\n-\tcd ..; $(MAKE) $(FLAGS_TO_PASS) xgcc gcov cpp cc1 ld\n-\t$(srcdir)/regression.sh -d -p\n-\n-clean-tests:\n-\tcd testsuite/execute;  $(MAKE) clean\n-\tcd testsuite/execute/oe;  $(MAKE) clean\n-\tcd testsuite/compile/elektra;  $(MAKE) clean\n-\tcd testsuite/compile/votrics;  $(MAKE) clean\n-\tcd testsuite/compile;  $(MAKE) clean\n-\tcd testsuite/noncompile;  $(MAKE) clean\n-\tcd testsuite/examples;  $(MAKE) clean\n-\n-mostlyclean:\n-\ttest -d testsuite && $(MAKE) clean-tests\n-\trm -f *.o\n-\n-clean:  mostlyclean\n-\n-#\f\n-Makefile: $(srcdir)/Makefile.in $(srcdir)/../configure\n-\tcd ..; $(SHELL) config.status\n-\n-native: config.status ../cc1chill$(exeext) ../chill\n-#\f\n-# Compiling object files from source files.\n-\n-# Note that dependencies on obstack.h are not written\n-# because that file is not part of GCC.\n-\n-# CHILL language specific files.\n-\n-EXPR_H = $(srcdir)/../expr.h ../insn-codes.h\n-RTL_H = $(srcdir)/../rtl.h $(srcdir)/../rtl.def \\\n-\t$(srcdir)/../machmode.h $(srcdir)/../machmode.def\n-TREE_H = $(srcdir)/../tree.h $(srcdir)/../real.h $(srcdir)/../tree.def \\\n-\t$(srcdir)/../machmode.h $(srcdir)/../machmode.def\n-CHILL_TREE_H = $(TREE_H) ch-tree.h ch-tree.def\n-\n-# hash.h really depends on $(srcdir)/gperf.\n-# But this would screw things for people that don't have gperf,\n-# if gperf got touched, say.\n-# Thus you have to remove hash.h to force it to be re-made.\n-# Note: CHILL requires two sets of keywords, one all uppercase and\n-# one all lowercase.  The hash table ends up with both sets in it.\n-$(srcdir)/hash.h:\n-\tsed -e '1,/^%%/d' < $(srcdir)/gperf | \\\n-\t  sed '/^[^a-zA-Z]/d' | tr \"[a-z]\" \"[A-Z]\" > gperf.tmp2\n-\tcat $(srcdir)/gperf gperf.tmp2 > gperf.tmp\n-\tgperf -L C -F ', 0, 0, 0' -D -E -S1 -p -j1 -i 1 -g -o -t -k'*' \\\n-\t  gperf.tmp > $(srcdir)/hash.h || ( \\\n-\techo \"Please update your 'gperf' from ftp://ftp.gnu.org/pub/gnu/gperf/\" >&2 ; \\\n-\texit 1 )\n-\t$(RM) gperf.tmp gperf.tmp2\n-\n-actions.o : actions.c $(CONFIG_H) $(CHILL_TREE_H) actions.h $(RTL_H)\t\\\n-\tlex.h $(srcdir)/../flags.h $(srcdir)/../input.h\t\t\t\\\n-\t$(EXPR_H) $(srcdir)/../system.h $(srcdir)/../toplev.h diagnostic.h\n-convert.o : convert.c $(CONFIG_H) $(CHILL_TREE_H) $(srcdir)/../flags.h \\\n-\t$(srcdir)/../tree.h $(srcdir)/../system.h $(srcdir)/../toplev.h \\\n-\t$(srcdir)/../convert.h\n-decl.o : decl.c $(CONFIG_H) $(CHILL_TREE_H) $(srcdir)/../flags.h lex.h \\\n-\t$(srcdir)/../system.h $(srcdir)/../toplev.h diagnostic.h\n-except.o : except.c $(CONFIG_H) $(srcdir)/../tree.h $(RTL_H) $(CHILL_TREE_H) \\\n-\t$(srcdir)/../system.h $(srcdir)/../toplev.h\n-expr.o : expr.c $(CONFIG_H) $(RTL_H) $(CHILL_TREE_H) $(srcdir)/../flags.h \\\n-\t$(EXPR_H) $(srcdir)/../tree.h lex.h $(srcdir)/../system.h \\\n-\t$(srcdir)/../toplev.h\n-grant.o: grant.c $(CONFIG_H) $(CHILL_TREE_H) $(RTL_H) $(srcdir)/../flags.h \\\n-\t$(srcdir)/../input.h lex.h actions.h $(srcdir)/../system.h \\\n-\t$(srcdir)/../toplev.h $(srcdir)/../output.h\n-inout.o : inout.c $(CONFIG_H) $(CHILL_TREE_H) $(srcdir)/../flags.h \\\n-\t$(srcdir)/../input.h $(srcdir)/../system.h $(srcdir)/../toplev.h\n-lang.o : lang.c $(CONFIG_H) $(CHILL_TREE_H) $(srcdir)/../input.h lex.h \\\n-\t$(srcdir)/../system.h $(srcdir)/../toplev.h $(EXPR_H) $(RTL_H) \\\n-\t$(srcdir)/../diagnostic.h\n-lex.o : lex.c $(CONFIG_H) $(CHILL_TREE_H) $(RTL_H) $(srcdir)/../flags.h \\\n-\t$(srcdir)/../input.h $(srcdir)/parse.h $(srcdir)/../system.h\t\\\n-\t$(srcdir)/../toplev.h lex.h hash.h\n-loop.o : loop.c $(CONFIG_H) $(RTL_H) $(CHILL_TREE_H) lex.h \\\n-\t$(srcdir)/../flags.h $(srcdir)/../input.h \\\n-\t$(srcdir)/../tree.h $(srcdir)/../system.h $(srcdir)/../toplev.h\n-parse.o : parse.c $(CONFIG_H) $(CHILL_TREE_H) parse.h \\\n-\tlex.h actions.h tasking.h $(srcdir)/../system.h $(srcdir)/../toplev.h\n-satisfy.o : satisfy.c $(CONFIG_H) $(CHILL_TREE_H) $(srcdir)/../tree.h \\\n-\t$(srcdir)/../flags.h lex.h $(srcdir)/../system.h $(srcdir)/../toplev.h\n-timing.o : timing.c $(CONFIG_H) $(CHILL_TREE_H) $(RTL_H) $(srcdir)/../flags.h \\\n-\t$(srcdir)/../input.h lex.h $(srcdir)/../system.h $(srcdir)/../toplev.h\n-\n-tasking.o : tasking.c $(CONFIG_H) $(CHILL_TREE_H) $(RTL_H) \\\n-\t$(srcdir)/../flags.h $(srcdir)/../input.h \\\n-\tlex.h $(srcdir)/../system.h $(srcdir)/../toplev.h\n-tree.o : tree.c $(CONFIG_H) $(CHILL_TREE_H) $(srcdir)/../system.h \\\n-\t$(srcdir)/../toplev.h\n-typeck.o : typeck.c $(CONFIG_H) $(CHILL_TREE_H) ../insn-codes.h \\\n-\t$(srcdir)/../expr.h ../insn-codes.h $(srcdir)/../flags.h lex.h \\\n-\t$(srcdir)/../system.h $(srcdir)/../toplev.h $(srcdir)/../output.h\n-ch-version.o : ch-version.c\n-ch-version.c : Makefile\n-\techo 'const char * const gnuchill_version = \"$(GNUCHILL_VERSION)\";' > $@\n-\n-## This is ugly, but I don't want GNU make to put these variables in\n-## the environment.  Older makes will see this as a set of targets\n-## with no dependencies and no actions.\n-unexport CHILLFLAGS CHILL_LIB CHILL_FOR_TARGET :\n-\n-#\f\n-# These exist for maintenance purposes.\n-\n-# Update the tags table.\n-TAGS: force\n-\tcd $(srcdir);\t\t\t\t\t\t\t\\\n-\tetags *.y *.h *.c *.l ../*.h ../*.c;\t\t\t\t\\\n-\n-.PHONY: TAGS\n-\n-force:"}, {"sha": "ef83544660405140f6300356107fc4545923d7cf", "filename": "gcc/ch/README", "status": "removed", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41823c5eb7d4504b6a4a396ca0d64573238fbbcf/gcc%2Fch%2FREADME", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41823c5eb7d4504b6a4a396ca0d64573238fbbcf/gcc%2Fch%2FREADME", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2FREADME?ref=41823c5eb7d4504b6a4a396ca0d64573238fbbcf", "patch": "@@ -1,43 +0,0 @@\n-This directory contains the GNU front-end for the Chill language,\n-contributed by Cygnus Solutions.\n-\n-Chill is the \"CCITT High-Level Language\", where CCITT is the old\n-name for what is now ITU, the International Telecommunications Union.\n-It is is language in the Modula2 family, and targets many of the\n-same applications as Ada (especially large embedded systems).\n-Chill was never used much in the United States, but is still\n-being used in Europe, Brazil, Korea, and other places.\n-\n-Chill has been standardized by a series of reports/standards.\n-The GNU implementation mostly follows the 1988 version of\n-the language, with some backwards compatibility options for\n-the 1984 version, and some other extensions.  However, it\n-does not implement all of the features of any standard.\n-The most recent standard is Z.200 (11/93), available from\n-http://www.itu.int/itudoc/itu-t/rec/z.html.\n-\n-The GNU Chill implementation is not being actively developed.\n-Cygnus has one customer we are maintaining Chill for,\n-but we are not planning on putting major work into Chill.\n-This Net release is for educational purposes (as an example\n-of a different Gcc front-end), and for those who find it useful.\n-It is an unsupported hacker release.  Bug reports without\n-patches are likely to get ignored.  Questions may get answered or\n-ignored depending on our mood!  If you want to try your luck,\n-you can send a note to David Brolley <brolley@cygnus.com> or\n-Per Bothner <bothner@cygnus.com>.\n-\n-One known problem is that we only support native builds of GNU Chill.\n-If you need a cross-compiler, you will find various problems,\n-including the directory structure, and the setjmp-based exception\n-handling mechanism.\n-\n-The Chill run-time system is in the runtime sub-directory.\n-Notice rts.c contains a poor main's implementation of Chill\n-\"processes\" (threads).  It is not added to libchill.a.\n-We only use it for testing.  (Our customer uses a different\n-implementation for production work.)\n-\n-The GNU Chill implementation was primarily written by\n-Per Bothner, along with Bill Cox, Wilfried Moser, Michael\n-Tiemann, and David Brolley."}, {"sha": "b8b06eb0ca44bcbd2a83cbf2e357fea08855a4d2", "filename": "gcc/ch/actions.c", "status": "removed", "additions": 0, "deletions": 1837, "changes": 1837, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41823c5eb7d4504b6a4a396ca0d64573238fbbcf/gcc%2Fch%2Factions.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41823c5eb7d4504b6a4a396ca0d64573238fbbcf/gcc%2Fch%2Factions.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Factions.c?ref=41823c5eb7d4504b6a4a396ca0d64573238fbbcf", "patch": "@@ -1,1837 +0,0 @@\n-/* Implement actions for CHILL.\n-   Copyright (C) 1992, 1993, 1994, 1998, 1999, 2000\n-   Free Software Foundation, Inc.\n-   Authors: Per Bothner, Bill Cox, Michael Tiemann, Michael North\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"tree.h\"\n-#include \"rtl.h\"\n-#include \"expr.h\"\n-#include \"ch-tree.h\"\n-#include \"lex.h\"\n-#include \"flags.h\"\n-#include \"actions.h\"\n-#include \"obstack.h\"\n-#include \"assert.h\"\n-#include \"toplev.h\"\n-#include \"diagnostic.h\"\n-\n-static int id_cmp PARAMS ((tree *, tree *));\n-static void warn_unhandled PARAMS ((const char *));\n-static tree adjust_return_value PARAMS ((tree, const char *));\n-static tree update_else_range_for_int_const PARAMS ((tree, tree));\n-static tree update_else_range_for_range PARAMS ((tree, tree, tree));\n-static tree update_else_range_for_range_expr PARAMS ((tree, tree));\n-static tree update_else_range_for_type PARAMS ((tree, tree));\n-static tree compute_else_range PARAMS ((tree, tree, int));\n-static tree check_case_value PARAMS ((tree, tree));\n-static void chill_handle_case_label_range PARAMS ((tree, tree, tree));\n-static tree chill_handle_multi_case_label_range PARAMS ((tree, tree, tree));\n-static tree chill_handle_multi_case_else_label PARAMS ((tree));\n-static tree chill_handle_multi_case_label PARAMS ((tree, tree));\n-static tree chill_handle_multi_case_label_list PARAMS ((tree, tree));\n-static void print_missing_cases PARAMS ((tree, const unsigned char *, long));\n-\n-#define obstack_chunk_alloc xmalloc\n-#define obstack_chunk_free free\n-\n-/* reserved tag definitions */\n-\n-#define TYPE_ID                 \"id\"\n-#define TAG_OBJECT              \"chill_object\"\n-#define TAG_CLASS               \"chill_class\"\n-\n-extern int flag_short_enums;\n-extern int current_nesting_level;\n-\n-extern struct obstack *expression_obstack, permanent_obstack;\n-extern struct obstack *current_obstack, *saveable_obstack;\n-\n-/* This flag is checked throughout the non-CHILL-specific\n-   in the front end. */\n-tree chill_integer_type_node;\n-tree chill_unsigned_type_node;\n-\n-/* Never used.  Referenced from c-typeck.c, which we use. */\n-int current_function_returns_value = 0;\n-int current_function_returns_null = 0;\n-\n-/* data imported from toplev.c  */\n-\n-extern char *dump_base_name;\n-\n-/* set from command line parameter, to exit after \n-   grant file written, generating no code. */\n-int grant_only_flag = 0;\n-\f\n-const char *\n-lang_identify ()\n-{\n-  return \"chill\";\n-}\n-\n-\n-void\n-init_chill ()\n-{\n-}\n-\n-void\n-print_lang_statistics ()\n-{\n-}\n-\n-\n-void\n-lang_finish ()\n-{\n-#if 0\n-    extern int errorcount, sorrycount;\n-\n-    /* this should be the last action in compiling a module.\n-       If there are other actions to be performed at lang_finish\n-       please insert before this */\n-\n-    /* FIXME: in case of a syntax error, this leaves the grant file incomplete */\n-    /* for the moment we print a warning in case of errors and \n-       continue granting */\n-    if ((errorcount || sorrycount) && grant_count)\n-      {\n-\twarning (\"%d errors, %d sorries, do granting\", errorcount, sorrycount);\n-\terrorcount = sorrycount = 0;\n-      }\n-#endif\n-}\n-\n-void\n-chill_check_decl (decl)\n-     tree decl;\n-{\n-  tree type = TREE_TYPE (decl);\n-  static int alreadyWarned = 0;\n-\n-  if (TREE_CODE (type) == RECORD_TYPE) /* && TREE_STATIC_TEMPLATE (type)) */\n-    {\n-      if (!alreadyWarned)\n-        {\n-          error (\"GNU compiler does not support statically allocated objects\");          \n-          alreadyWarned = 1;\n-        }\n-      error_with_decl (decl, \"`%s' cannot be statically allocated\");\n-    }\n-}\n-\f\n-/* Comparison function for sorting identifiers in RAISES lists.\n-   Note that because IDENTIFIER_NODEs are unique, we can sort\n-   them by address, saving an indirection.  */\n-static int\n-id_cmp (p1, p2)\n-     tree *p1, *p2;\n-{\n-  long diff = (long)TREE_VALUE (*p1) - (long)TREE_VALUE (*p2);\n-\n-  return (diff < 0) ? -1 : (diff > 0);\n-}\n-\n-/* Build the FUNCTION_TYPE or METHOD_TYPE which may raise exceptions\n-   listed in RAISES.  */\n-tree\n-build_exception_variant (type, raises)\n-     tree type, raises;\n-{\n-  int i;\n-  tree v = TYPE_MAIN_VARIANT (type);\n-  tree t, t2;\n-  int constp    = TYPE_READONLY (type);\n-  int volatilep = TYPE_VOLATILE (type);\n-\n-  if (!raises)\n-    return build_type_variant (v, constp, volatilep);\n-\n-  if (TREE_CHAIN (raises))\n-    { /* Sort the list */\n-      tree *a = (tree *)alloca ((list_length (raises)+1) * sizeof (tree));\n-      for (i = 0, t = raises; t; t = TREE_CHAIN (t), i++)\n-\ta[i] = t;\n-      /* NULL terminator for list.  */\n-      a[i] = NULL_TREE;\n-      qsort (a, i, sizeof (tree),\n-\t     (int (*) PARAMS ((const void*, const void*))) id_cmp);\n-      while (i--)\n-\tTREE_CHAIN (a[i]) = a[i+1];\n-      raises = a[0];\n-    }\n-\n-  for (v = TYPE_NEXT_VARIANT (v); v; v = TYPE_NEXT_VARIANT (v))\n-    {\n-      if (TYPE_READONLY (v) != constp\n-\t  || TYPE_VOLATILE (v) != volatilep)\n-\tcontinue;\n-\n-      t = raises;\n-      t2 = TYPE_RAISES_EXCEPTIONS (v);\n-      while (t && t2)\n-\t{\n-\t  if (TREE_TYPE (t) == TREE_TYPE (t2))\n-\t    {\n-\t      t = TREE_CHAIN (t);\n-\t      t2 = TREE_CHAIN (t2);\n-\t    }\n-\t  else break;\n-\t}\n-      if (t || t2)\n-\tcontinue;\n-      /* List of exceptions raised matches previously found list.\n-\n-         @@ Nice to free up storage used in consing up the\n-\t @@ list of exceptions raised.  */\n-      return v;\n-    }\n-\n-  /* Need to build a new variant.  */\n-  if (TREE_PERMANENT (type))\n-    {\n-      push_obstacks_nochange ();\n-      end_temporary_allocation ();\n-      v = copy_node (type);\n-      pop_obstacks ();\n-    }\n-  else\n-    v = copy_node (type);\n-\n-  TYPE_NEXT_VARIANT (v) = TYPE_NEXT_VARIANT (type);\n-  TYPE_NEXT_VARIANT (type) = v;\n-  if (raises && ! TREE_PERMANENT (raises))\n-    {\n-      push_obstacks_nochange ();\n-      end_temporary_allocation ();\n-      raises = copy_list (raises);\n-      pop_obstacks ();\n-    }\n-  TYPE_RAISES_EXCEPTIONS (v) = raises;\n-  return v;\n-}\n-#if 0\n-\f\n-tree\n-build_rts_call (name, type, args)\n-     const char *name;\n-     tree type, args;\n-{\n-  tree decl = lookup_name (get_identifier (name));\n-  tree converted_args = NULL_TREE;\n-  tree result, length = NULL_TREE;\n-\n-  assert (decl != NULL_TREE);\n-  while (args)\n-    {\n-      tree arg = TREE_VALUE (args);\n-      if (TREE_CODE (TREE_TYPE (arg)) == SET_TYPE\n-\t  || TREE_CODE (TREE_TYPE (arg)) == ARRAY_TYPE)\n-\t{\n-\t  length = size_in_bytes (TREE_TYPE (arg));\n-\t  arg = build_chill_addr_expr (arg, (char *)0);\n-\t}\n-      converted_args = tree_cons (NULL_TREE, arg, converted_args);\n-      args = TREE_CHAIN (args);\n-    }\n-  if (length != NULL_TREE)\n-    converted_args = tree_cons (NULL_TREE, length, converted_args);\n-  converted_args = nreverse (converted_args);\n-  result = build_chill_function_call (decl, converted_args);\n-  if (TREE_CODE (type) == SET_TYPE || TREE_CODE (type) == ARRAY_TYPE)\n-    result = build1 (INDIRECT_REF, type, result);\n-  else\n-    result = convert (type, result);\n-  return result;\n-}\n-#endif\n-\n-/*\n- * queue name of unhandled exception\n- * to avoid multiple unhandled warnings\n- * in one compilation module\n- */\n-\n-struct already_type\n-{\n-  struct already_type *next;\n-  char *name;\n-};\n-\n-static struct already_type *already_warned = 0;\n-\n-static void\n-warn_unhandled (ex)\n-     const char *ex;\n-{\n-  struct already_type *p = already_warned;\n-\n-  while (p)\n-    {\n-      if (!strcmp (p->name, ex))\n-\treturn;\n-      p = p->next;\n-    }\n-  \n-  /* not yet warned */\n-  p = (struct already_type *)xmalloc (sizeof (struct already_type));\n-  p->next = already_warned;\n-  p->name = xstrdup (ex);\n-  already_warned = p;\n-  pedwarn (\"causing unhandled exception `%s' (this is flaged only once)\", ex);\n-}\n-\n-/*\n- * build a call to the following function:\n- *   void   __cause_ex1 (char* ex, const char *file, \n- *                       const unsigned lineno);\n- * if the exception is handled or\n- *   void __unhandled_ex (char *ex, char *file, unsigned lineno)\n- * if the exception is not handled.\n- */\n-tree\n-build_cause_exception (exp_name, warn_if_unhandled)\n-     tree exp_name;\n-     int warn_if_unhandled;\n-{\n-  /* We don't use build_rts_call() here, because the string (array of char)\n-     would be followed by its length in the parameter list built by\n-     build_rts_call, and the runtime routine doesn't want a length parameter.*/\n-  tree exp_decl = build_chill_exception_decl (IDENTIFIER_POINTER (exp_name));\n-  tree function, fname, lineno, result;\n-  int handled = is_handled (exp_name);\n-\n-  switch (handled)\n-    {\n-    case 0:\n-      /* no handler */\n-      if (warn_if_unhandled)\n-\twarn_unhandled (IDENTIFIER_POINTER (exp_name));\n-      function = lookup_name (get_identifier (\"__unhandled_ex\"));\n-      fname = force_addr_of (get_chill_filename ());\n-      lineno = get_chill_linenumber ();\n-      break;\n-    case 1:\n-      /* local handler */\n-      function = lookup_name (get_identifier (\"__cause_ex1\"));\n-      fname = force_addr_of (get_chill_filename ());\n-      lineno = get_chill_linenumber ();\n-      break;\n-    case 2:\n-      /* function may propagate this exception */\n-      function = lookup_name (get_identifier (\"__cause_ex1\"));\n-      fname = lookup_name (get_identifier (CALLER_FILE));\n-      if (fname == NULL_TREE)\n-\tfname = error_mark_node;\n-      lineno = lookup_name (get_identifier (CALLER_LINE));\n-      if (lineno == NULL_TREE)\n-\tlineno = error_mark_node;\n-      break;\n-    default:\n-      abort();\n-    }\n-  result =\n-    build_chill_function_call (function,\n-      tree_cons (NULL_TREE, build_chill_addr_expr (exp_decl, (char *)0),\n-\ttree_cons (NULL_TREE,  fname,\n-\t  tree_cons (NULL_TREE, lineno, NULL_TREE))));\n-  return result;\n-}\n-\n-void\n-expand_cause_exception (exp_name)\n-     tree exp_name;\n-{\n-  expand_expr_stmt (build_cause_exception (exp_name, 1));\n-}\n-\n-/* If CONDITION is true, raise EXCEPTION (an IDENTIFIER_NODE);\n-   otherwise return EXPR. */\n-\n-tree\n-check_expression (expr, condition, exception)\n-     tree expr, condition, exception;\n-{\n-  if (integer_zerop (condition))\n-    return expr;\n-  else\n-    return build (COMPOUND_EXPR, TREE_TYPE (expr),\n-\t\t  fold (build (TRUTH_ANDIF_EXPR, boolean_type_node,\n-\t\t\t       condition, build_cause_exception (exception, 0))),\n-\t\t  expr);\n-}\n-\n-/* Return an expression for VALUE < LO_LIMIT || VALUE > HI_LIMIT,\n-   somewhat optimized and with some warnings suppressed.\n-   If LO_LIMIT or HI_LIMIT is NULL_TREE, assume that (sub-)test passes.  */\n-\n-tree\n-test_range (value, lo_limit, hi_limit)\n-     tree value, lo_limit, hi_limit;\n-{\n-  if (lo_limit || hi_limit)\n-    {\n-      int old_inhibit_warnings = inhibit_warnings;\n-      tree lo_check, hi_check, check;\n-\n-      /* This is a hack so that `shorten_compare' doesn't warn the\n-\t user about useless range checks that are too much work to\n-\t optimize away here.  */\n-      inhibit_warnings = 1;\n-\n-      lo_check = lo_limit ? \n-\tfold (build_compare_discrete_expr (LT_EXPR, value, lo_limit)) :\n-\t  boolean_false_node;   /* fake passing the check */\n-\n-      hi_check = hi_limit ? \n-\tfold (build_compare_discrete_expr (GT_EXPR, value, hi_limit)) :\n-\t  boolean_false_node;   /* fake passing the check */\n-\n-      if (lo_check == boolean_false_node)\n-\tcheck = hi_check;\n-      else if (hi_check == boolean_false_node)\n-\tcheck = lo_check;\n-      else\n-\tcheck = fold (build (TRUTH_ORIF_EXPR, boolean_type_node,\n-\t\t\t     lo_check, hi_check));\n-\n-      inhibit_warnings = old_inhibit_warnings;\n-      return check;\n-    }\n-  else\n-    return boolean_false_node;\n-}\n-\n-/* Return EXPR, except if range_checking is on, return an expression\n-   that also checks that value >= low_limit && value <= hi_limit.\n-   If LO_LIMIT or HI_LIMIT is NULL_TREE, assume that test passes.  */\n-\n-tree\n-check_range (expr, value, lo_limit, hi_limit)\n-     tree expr, value, lo_limit, hi_limit;\n-{\n-  tree check = test_range (value, lo_limit, hi_limit);\n-  if (!integer_zerop (check))\n-    {\n-      if (current_function_decl == NULL_TREE)\n-\t{\n-\t  if (TREE_CODE (check) == INTEGER_CST)\n-\t    error (\"range failure (not inside function)\");\n-\t  else\n-\t    warning (\"possible range failure (not inside function)\");\n-\t}\n-      else\n-\t{\n-\t  if (TREE_CODE (check) == INTEGER_CST)\n-\t    warning (\"expression will always cause RANGEFAIL\");\n-\t  if (range_checking)\n-\t    expr = check_expression (expr, check,\n-\t\t\t\t     ridpointers[(int) RID_RANGEFAIL]);\n-\t}\n-    }\n-  return expr;\n-}\n-\n-/* Same as EXPR, except raise EMPTY if EXPR is NULL. */\n-\n-tree\n-check_non_null (expr)\n-     tree expr;\n-{\n-  if (empty_checking)\n-    {\n-      expr = save_if_needed (expr);\n-      return check_expression (expr,\n-\t\t\t       build_compare_expr (EQ_EXPR,\n-\t\t\t\t\t\t   expr, null_pointer_node),\n-\t\t\t       ridpointers[(int) RID_EMPTY]);\n-    }\n-  return expr;\n-}\n-\f\n-/*  There are four conditions to generate a runtime check:\n-    1) assigning a longer INT to a shorter (signs irrelevant)\n-    2) assigning a signed to an unsigned\n-    3) assigning an unsigned to a signed of the same size.\n-    4) TYPE is a discrete subrange  */\n-\n-tree\n-chill_convert_for_assignment (type, expr, place)\n-     tree type, expr;\n-     const char *place; /* location description for error messages */\n-{\n-  tree ttype = type;\n-  tree etype = TREE_TYPE (expr);\n-  tree result;\n-\n-  if (type == NULL_TREE || TREE_CODE (type) == ERROR_MARK)\n-    return error_mark_node;\n-  if (expr == NULL_TREE || TREE_CODE (expr) == ERROR_MARK)\n-    return expr;\n-  if (TREE_CODE (expr) == TYPE_DECL)\n-    {\n-      error (\"right hand side of assignment is a mode\");\n-      return error_mark_node;\n-    }\n-\n-  if (! CH_COMPATIBLE (expr, type))\n-    {\n-      error (\"incompatible modes in %s\", place);\n-      return error_mark_node;\n-    }\n-\n-  if (TREE_CODE (type) == REFERENCE_TYPE)\n-    ttype = TREE_TYPE (ttype);\n-  if (etype && TREE_CODE (etype) == REFERENCE_TYPE)\n-    etype = TREE_TYPE (etype);\n-\n-  if (etype\n-      && (CH_STRING_TYPE_P (ttype)\n-\t  || (chill_varying_type_p (ttype)\n-\t      && CH_STRING_TYPE_P (CH_VARYING_ARRAY_TYPE (ttype))))\n-      && (CH_STRING_TYPE_P (etype)\n-\t  || (chill_varying_type_p (etype)\n-\t      && CH_STRING_TYPE_P (CH_VARYING_ARRAY_TYPE (etype)))))\n-    {\n-      tree cond;\n-      if (range_checking)\n-\texpr = save_if_needed (expr);\n-      cond = string_assignment_condition (ttype, expr);\n-      if (TREE_CODE (cond) == INTEGER_CST)\n-\t{\n-\t  if (integer_zerop (cond))\n-\t    {\n-\t      error (\"bad string length in %s\", place);\n-\t      return error_mark_node;\n-\t    }\n-\t  /* Otherwise, the condition is always true, so no runtime test. */\n-\t}\n-      else if (range_checking)\n-\texpr = check_expression (expr,\n-\t\t\t\t invert_truthvalue (cond),\n-\t\t\t\t ridpointers[(int) RID_RANGEFAIL]);\n-    }\n-\n-  if (range_checking \n-      && discrete_type_p (ttype) \n-      && etype != NULL_TREE\n-      && discrete_type_p (etype))\n-    {\n-      int cond1 = tree_int_cst_lt (TYPE_SIZE (ttype),\n-\t\t\t\t   TYPE_SIZE (etype));\n-      int cond2 = TREE_UNSIGNED (ttype) \n-\t          && (! TREE_UNSIGNED (etype));\n-      int cond3 = (! TREE_UNSIGNED (type))\n-\t          && TREE_UNSIGNED (etype) \n-\t\t  && tree_int_cst_equal (TYPE_SIZE (ttype),\n-\t\t\t\t\t TYPE_SIZE (etype));\n-      int cond4 = TREE_TYPE (ttype) \n-\t          && discrete_type_p (TREE_TYPE (ttype));\n-\n-      if (cond1 || cond2 || cond3 || cond4)\n-\t{\n-\t  tree type_min = TYPE_MIN_VALUE (ttype);\n-\t  tree type_max = TYPE_MAX_VALUE (ttype);\n-\n-\t  expr = save_if_needed (expr);\n-\t  if (expr && type_min && type_max)\n-\t    expr = check_range (expr, expr, type_min, type_max);\n-\t}\n-    }\n-  result = convert (type, expr);\n-\n-  /* If the type is a array of PACK bits and the expression is an array\n-     constructor, then build a CONSTRUCTOR for a bitstring.  Bitstrings are\n-     zero based, so decrement the value of each CONSTRUCTOR element by the\n-     amount of the lower bound of the array.  */\n-  if (TREE_CODE (type) == ARRAY_TYPE && TYPE_PACKED (type)\n-      && TREE_CODE (result) == CONSTRUCTOR)\n-    {\n-      tree domain_min = TYPE_MIN_VALUE (TYPE_DOMAIN (type));\n-      tree new_list = NULL_TREE;\n-      unsigned HOST_WIDE_INT index;\n-      tree element;\n-\n-      for (element = TREE_OPERAND (result, 1);\n-\t   element != NULL_TREE;\n-\t   element = TREE_CHAIN (element))\n-\t{\n-\t  if (!tree_int_cst_equal (TREE_VALUE (element), integer_zero_node))\n-\t    {\n-\t      tree purpose = TREE_PURPOSE (element);\n-\t      switch (TREE_CODE (purpose))\n-\t\t{\n-\t\tcase INTEGER_CST:\n-\t\t  new_list\n-\t\t    = tree_cons (NULL_TREE,\n-\t\t\t\t fold (build (MINUS_EXPR, TREE_TYPE (purpose),\n-\t\t\t\t\t      purpose, domain_min)),\n-\t\t\t\t new_list);\n-\t\t  break;\n-\t\tcase RANGE_EXPR:\n-\t\t  for (index = TREE_INT_CST_LOW (TREE_OPERAND (purpose, 0));\n-\t\t       index <= TREE_INT_CST_LOW (TREE_OPERAND (purpose, 1));\n-\t\t       index++)\n-\t\t    new_list = tree_cons (NULL_TREE,\n-\t\t\t\t\t  fold (build (MINUS_EXPR,\n-\t\t\t\t\t\t       integer_type_node,\n-\t\t\t\t\t\t       build_int_2 (index, 0),\n-\t\t\t\t\t\t       domain_min)),\n-\t\t\t\t\t  new_list);\n-\t\t  break;\n-\t\tdefault:\n-\t\t  abort ();\n-\t\t}\n-\t    }\n-\t}\n-      result = copy_node (result);\n-      TREE_OPERAND (result, 1) = nreverse (new_list);\n-      TREE_TYPE (result) = build_bitstring_type (TYPE_SIZE (type));\n-    }\n-\n-  return result;\n-}\n-\f\n-/* Check that EXPR has valid type for a RETURN or RESULT expression,\n-   converting to the right type.  ACTION is \"RESULT\" or \"RETURN\". */\n-\n-static tree\n-adjust_return_value (expr, action)\n-     tree expr;\n-     const char *action;\n-{\n-  tree type = TREE_TYPE (TREE_TYPE (current_function_decl));\n-\n-  if (TREE_CODE (type) == REFERENCE_TYPE)\n-    {\n-      if (CH_LOCATION_P (expr))\n-\t{\n-\t  if (! CH_READ_COMPATIBLE (TREE_TYPE (type), \n-\t\t\t\t    TREE_TYPE (expr)))\n-\t    {\n-\t      error (\"mode mismatch in %s expression\", action);\n-\t      return error_mark_node;\n-\t    }\n-\t  return convert (type, expr);\n-\t}\n-      else\n-\t{\n-\t  error (\"%s expression must be referable\", action);\n-\t  return error_mark_node;\n-\t}\n-    }\n-  else if (! CH_COMPATIBLE (expr, type))\n-    {\n-      error (\"mode mismatch in %s expression\", action);\n-      return error_mark_node;\n-    }\n-  return convert (type, expr);\n-}\n-\f\n-void\n-chill_expand_result (expr, result_or_return)\n-     tree expr;\n-     int result_or_return;\n-{\n-  tree type;\n-  const char *action_name = result_or_return ? \"RESULT\" : \"RETURN\";\n-  \n-  if (pass == 1)\n-    return;\n-\n-  if (expr == NULL_TREE || TREE_CODE (expr) == ERROR_MARK)\n-    return;\n-\n-  CH_FUNCTION_SETS_RESULT (current_function_decl) = 1;\n-\n-  if (chill_at_module_level || global_bindings_p ())\n-    error (\"%s not allowed outside a PROC\", action_name);\n-\n-  result_never_set = 0;\n-\n-  if (chill_result_decl == NULL_TREE)\n-    {\n-      error (\"%s action in PROC with no declared RESULTS\", action_name);\n-      return;\n-    }\n-  type = TREE_TYPE (chill_result_decl);\n-\n-  if (TREE_CODE (type) == ERROR_MARK)\n-    return;\n-\n-  expr = adjust_return_value (expr, action_name);\n-\n-  expand_expr_stmt (build_chill_modify_expr (chill_result_decl, expr));\n-}\n-\f\n-/*\n- * error if EXPR not NULL and procedure doesn't\n- * have a return type; \n- * warning if EXPR NULL,\n- * procedure *has* a return type, and a previous\n- * RESULT actions hasn't saved a return value.\n- */\n-void\n-chill_expand_return (expr, implicit)\n-     tree expr;\n-     int implicit; /* 1 if an implicit return at end of function. */\n-{\n-  tree valtype;\n-\n-  if (expr != NULL_TREE && TREE_CODE (expr) == ERROR_MARK)\n-    return;\n-  if (chill_at_module_level || global_bindings_p ())\n-    {\n-      error (\"RETURN not allowed outside PROC\");\n-      return;\n-    }\n-\n-  if (pass == 1)\n-    return;\n-\n-  result_never_set = 0;\n-\n-  valtype = TREE_TYPE (TREE_TYPE (current_function_decl));\n-  if (TREE_CODE (valtype) == VOID_TYPE)\n-    {\n-      if (expr != NULL_TREE)\n-\terror (\"RETURN with a value, in PROC returning void\");\n-      expand_null_return ();\n-    }\n-  else if (TREE_CODE (valtype) != ERROR_MARK)\n-    {\n-      if (expr == NULL_TREE)\n-\t{\n-\t  if (!CH_FUNCTION_SETS_RESULT (current_function_decl)\n-\t      && !implicit)\n-\t    warning (\"RETURN with no value and no RESULT action in procedure\");\n-\t  expr = chill_result_decl;\n-\t}\n-      else\n-\texpr = adjust_return_value (expr, \"RETURN\");\n-      expr = build (MODIFY_EXPR, valtype,\n-\t\t    DECL_RESULT (current_function_decl),\n-\t\t    expr);\n-      TREE_SIDE_EFFECTS (expr) = 1;\n-      expand_return (expr);\n-    }\n-}\n-\n-void\n-lookup_and_expand_goto (name)\n-     tree name;\n-{\n-  if (name == NULL_TREE ||  TREE_CODE (name) == ERROR_MARK)\n-    return;\n-  if (!ignoring)\n-    {\n-      tree decl = lookup_name (name);\n-      if (decl == NULL || TREE_CODE (decl) != LABEL_DECL)\n-\terror (\"no label named `%s'\", IDENTIFIER_POINTER (name));\n-      else if (DECL_CONTEXT (decl) != current_function_decl)\n-\terror (\"cannot GOTO label `%s' outside current function\",\n-\t       IDENTIFIER_POINTER (name));\n-      else\n-\t{\n-\t  TREE_USED (decl) = 1;\n-\t  expand_goto_except_cleanup (DECL_ACTION_NESTING_LEVEL (decl));\n-\t  expand_goto (decl);\n-\t}\n-    }\n-}\n-\n-void\n-lookup_and_handle_exit (name)\n-     tree name;\n-{\n-  if (name == NULL_TREE ||  TREE_CODE (name) == ERROR_MARK)\n-    return;\n-  if (!ignoring)\n-    {\n-      tree label = munge_exit_label (name);\n-      tree decl = lookup_name (label);\n-      if (decl == NULL || TREE_CODE (decl) != LABEL_DECL)\n-\terror (\"no EXITable label named `%s'\", IDENTIFIER_POINTER (name));\n-      else if (DECL_CONTEXT (decl) != current_function_decl)\n-\terror (\"cannot EXIT label `%s' outside current function\",\n-\t       IDENTIFIER_POINTER (name));\n-      else\n-\t{\n-\t  TREE_USED (decl) = 1;\n-\t  expand_goto_except_cleanup (DECL_ACTION_NESTING_LEVEL (decl));\n-\t  expand_goto (decl);\n-\t}\n-    }\n-}\n-\f\n-/* ELSE-range handling: The else-range is a chain of trees which collectively\n-   represent the ranges to be tested for the (ELSE) case label. Each element in\n-   the chain represents a range to be tested. The boundaries of the range are\n-   represented by INTEGER_CST trees in the PURPOSE and VALUE fields. */\n-\n-/* This function updates the else-range by removing the given integer constant. */\n-static tree\n-update_else_range_for_int_const (else_range, label)\n-     tree else_range, label;\n-{\n-  int  lowval = 0, highval = 0;\n-  int  label_value = TREE_INT_CST_LOW (label);\n-  tree this_range, prev_range, new_range;\n-\n-  /* First, find the range element containing the integer, if it exists. */\n-  prev_range = NULL_TREE;\n-  for (this_range = else_range ;\n-       this_range != NULL_TREE;\n-       this_range = TREE_CHAIN (this_range))\n-    {\n-      lowval  = TREE_INT_CST_LOW (TREE_PURPOSE (this_range));\n-      highval = TREE_INT_CST_LOW (TREE_VALUE (this_range));\n-      if (label_value >= lowval && label_value <= highval)\n-\tbreak;\n-      prev_range = this_range;\n-    }\n-\n-  /* If a range element containing the integer was found, then update the range. */\n-  if (this_range != NULL_TREE)\n-    {\n-      tree next = TREE_CHAIN (this_range);\n-      if (label_value == lowval)\n-\t{\n-\t  /* The integer is the lower bound of the range element. If it is also the\n-\t     upper bound, then remove this range element, otherwise update it. */\n-\t  if (label_value == highval)\n-\t    {\n-\t      if (prev_range == NULL_TREE)\n-\t\telse_range = next;\n-\t      else\n-\t\tTREE_CHAIN (prev_range) = next;\n-\t    }\n-\t  else\n-\t    TREE_PURPOSE (this_range) = build_int_2 (label_value + 1, 0);\n-\t}\n-      else if (label_value == highval)\n-\t{\n-\t  /* The integer is the upper bound of the range element, so ajust it. */\n-\t  TREE_VALUE (this_range) = build_int_2 (label_value - 1, 0);\n-\t}\n-      else\n-\t{\n-\t  /* The integer is in the middle of the range element, so split it. */\n-\t  new_range = tree_cons (\n-            build_int_2 (label_value + 1, 0), TREE_VALUE (this_range), next);\n-\t  TREE_VALUE (this_range) = build_int_2 (label_value - 1, 0);\n-\t  TREE_CHAIN (this_range) = new_range;\n-\t}\n-    }\n-  return else_range;\n-}\n-\n-/* Update the else-range to remove a range of values/ */\n-static tree\n-update_else_range_for_range (else_range, low_target, high_target)\n-     tree else_range, low_target, high_target;\n-{\n-  tree this_range, prev_range, new_range, next_range;\n-  int  low_range_val = 0, high_range_val = 0;\n-  int  low_target_val  = TREE_INT_CST_LOW (low_target);\n-  int  high_target_val = TREE_INT_CST_LOW (high_target);\n-\n-  /* find the first else-range element which overlaps the target range. */\n-  prev_range = NULL_TREE;\n-  for (this_range = else_range ;\n-       this_range != NULL_TREE;\n-       this_range = TREE_CHAIN (this_range))\n-    {\n-      low_range_val  = TREE_INT_CST_LOW (TREE_PURPOSE (this_range));\n-      high_range_val = TREE_INT_CST_LOW (TREE_VALUE (this_range));\n-      if ((low_target_val >= low_range_val && low_target_val <= high_range_val)\n-\t  || (high_target_val >= low_range_val && high_target_val <= high_range_val))\n-\tbreak;\n-      prev_range = this_range;\n-    }\n-  if (this_range == NULL_TREE)\n-    return else_range;\n-\n-  /* This first else-range element might be truncated at the top or completely\n-     contain the target range. */\n-  if (low_range_val < low_target_val)\n-    {\n-      next_range = TREE_CHAIN (this_range);\n-      if (high_range_val > high_target_val)\n-\t{\n-\t  new_range = tree_cons (\n-            build_int_2 (high_target_val + 1, 0), TREE_VALUE (this_range), next_range);\n-\t  TREE_VALUE (this_range) = build_int_2 (low_target_val - 1, 0);\n-\t  TREE_CHAIN (this_range) = new_range;\n-\t  return else_range;\n-\t}\n-\n-      TREE_VALUE (this_range) = build_int_2 (low_target_val - 1, 0);\n-      if (next_range == NULL_TREE)\n-\treturn else_range;\n-\n-      prev_range = this_range;\n-      this_range = next_range;\n-      high_range_val = TREE_INT_CST_LOW (TREE_VALUE (this_range));\n-    }\n-\n-  /* There may then follow zero or more else-range elements which are completely\n-     contained in the target range. */\n-  while (high_range_val <= high_target_val)\n-    {\n-      this_range = TREE_CHAIN (this_range);\n-      if (prev_range == NULL_TREE)\n-\telse_range = this_range;\n-      else\n-\tTREE_CHAIN (prev_range) = this_range;\n-\n-      if (this_range == NULL_TREE)\n-\treturn else_range;\n-      high_range_val = TREE_INT_CST_LOW (TREE_VALUE (this_range));\n-    }\n-\n-  /* Finally, there may be a else-range element which is truncated at the bottom. */\n-  low_range_val = TREE_INT_CST_LOW (TREE_PURPOSE (this_range));\n-  if (low_range_val <= high_target_val)\n-    TREE_PURPOSE (this_range) = build_int_2 (high_target_val + 1, 0);\n-\n-  return else_range;\n-}\n-\n-static tree\n-update_else_range_for_range_expr (else_range, label)\n-     tree else_range, label;\n-{\n-  if (TREE_OPERAND (label, 0) == NULL_TREE)\n-    {\n-      if (TREE_OPERAND (label, 1) == NULL_TREE)\n-\telse_range = NULL_TREE; /* (*) -- matches everything */\n-    }\n-  else\n-    else_range = update_else_range_for_range (\n-      else_range, TREE_OPERAND (label, 0), TREE_OPERAND (label, 1));\n-\n-  return else_range;\n-}\n-\n-static tree\n-update_else_range_for_type (else_range, label)\n-     tree else_range, label;\n-{\n-  tree type = TREE_TYPE (label);\n-  else_range = update_else_range_for_range (\n-    else_range, TYPE_MIN_VALUE (type), TYPE_MAX_VALUE (type));\n-  return else_range;\n-}\n-\n-static tree\n-compute_else_range (selector, alternatives, selector_no)\n-     tree selector, alternatives;\n-     int selector_no;\n-{\n-  /* Start with an else-range that spans the entire range of the selector type. */\n-  tree type = TREE_TYPE (TREE_VALUE (selector));\n-  tree range = tree_cons (TYPE_MIN_VALUE (type), TYPE_MAX_VALUE (type), NULL_TREE);\n-\n-  /* Now remove the values represented by each case lebel specified for that\n-     selector. The remaining range is the else-range. */\n-  for ( ; alternatives != NULL_TREE; alternatives = TREE_CHAIN (alternatives))\n-    {\n-      tree label;\n-      tree label_list = TREE_PURPOSE (alternatives);\n-      int  this_selector;\n-      for (this_selector = 0; this_selector < selector_no ; ++this_selector)\n-\tlabel_list = TREE_CHAIN (label_list);\n-\n-      for (label = TREE_VALUE (label_list);\n-\t   label != NULL_TREE;\n-\t   label = TREE_CHAIN (label))\n-\t{\n-\t  tree label_value = TREE_VALUE (label);\n-\t  if (TREE_CODE (label_value) == INTEGER_CST)\n-\t    range = update_else_range_for_int_const (range, label_value);\n-\t  else if (TREE_CODE (label_value) == RANGE_EXPR)\n-\t    range = update_else_range_for_range_expr (range, label_value);\n-\t  else if (TREE_CODE (label_value) == TYPE_DECL)\n-\t    range = update_else_range_for_type (range, label_value);\n-\n-\t  if (range == NULL_TREE)\n-\t    break;\n-\t}\n-    }\n-\n-  return range;\n-}\n-\n-void\n-compute_else_ranges (selectors, alternatives)\n-     tree selectors, alternatives;\n-{\n-  tree selector;\n-  int selector_no = 0;\n-\n-  for (selector = selectors; selector != NULL_TREE; selector = TREE_CHAIN (selector))\n-    {\n-      if (ELSE_LABEL_SPECIFIED (selector))\n-\tTREE_PURPOSE (selector) =\n-\t  compute_else_range (selector, alternatives, selector_no);\n-      selector_no++;\n-    }\n-}\n-\n-static tree\n-check_case_value (label_value, selector)\n-     tree label_value, selector;\n-{\n-  if (TREE_CODE (label_value) == ERROR_MARK)\n-    return label_value;\n-  if (TREE_CODE (selector) == ERROR_MARK)\n-    return selector;    \n-\n-  /* Z.200 (6.4 Case action) says:  \"The class of any discrete expression\n-     in the case selector list must be compatible with the corresponding\n-     (by position) class of the resulting list of classes of the case label\n-     list occurrences ...\".  We don't actually construct the resulting\n-     list of classes, but this test should be more-or-less equivalent.\n-     I think... */\n-  if (!CH_COMPATIBLE_CLASSES (selector, label_value))\n-    {\n-      error (\"case selector not compatible with label\");\n-      return error_mark_node;\n-    }\n-\n-  /* Strip NON_LVALUE_EXPRs since we aren't using as an lvalue.  */\n-  STRIP_TYPE_NOPS (label_value);\n-\n-  if (TREE_CODE (label_value) != INTEGER_CST)\n-    {\n-      error (\"case label does not reduce to an integer constant\");\n-      return error_mark_node;\n-    }\n-\n-  constant_expression_warning (label_value);\n-  return label_value;\n-}\n-\n-void\n-chill_handle_case_default ()\n-{\n-  tree duplicate;\n-  register tree label = build_decl (LABEL_DECL, NULL_TREE, \n-\t\t\t\t    NULL_TREE);\n-  int success = pushcase (NULL_TREE, 0, label, &duplicate);\n-\n-  if (success == 1)\n-    error (\"ELSE label not within a CASE statement\");\n-#if 0\n-  else if (success == 2)\n-    {\n-      error (\"multiple default labels found in a CASE statement\"); \n-      error_with_decl (duplicate, \"this is the first ELSE label\");\n-    }\n-#endif\n-}\n-\f\n-/* Handle cases label such as (I:J):  or (modename): */\n-\n-static void\n-chill_handle_case_label_range (min_value, max_value, selector)\n-     tree min_value, max_value, selector;\n-{\n-  register tree label = build_decl (LABEL_DECL, NULL_TREE, NULL_TREE);\n-  min_value = check_case_value (min_value, selector);\n-  max_value = check_case_value (max_value, selector);\n-  if (TREE_CODE (min_value) != ERROR_MARK\n-      && TREE_CODE (max_value) != ERROR_MARK)\n-    {\n-      tree duplicate;\n-      int success = pushcase_range (min_value, max_value,\n-\t\t\t\t    convert, label, &duplicate);\n-      if (success == 1)\n-\terror (\"label found outside of CASE statement\");\n-      else if (success == 2)\n-\t{\n-\t  error (\"duplicate CASE value\");\n-\t  error_with_decl (duplicate, \"this is the first entry for that value\");\n-\t}\n-      else if (success == 3)\n-\terror (\"CASE value out of range\");\n-      else if (success == 4)\n-\terror (\"empty range\");\n-      else if (success == 5)\n-\terror (\"label within scope of cleanup or variable array\");\n-    }\n-}\n-\n-void\n-chill_handle_case_label (label_value, selector)\n-     tree label_value, selector;\n-{\n-  if (label_value == NULL_TREE \n-      || TREE_CODE (label_value) == ERROR_MARK)\n-    return;\n-  if (TREE_CODE (label_value) == RANGE_EXPR)\n-    {\n-      if (TREE_OPERAND (label_value, 0) == NULL_TREE)\n-\tchill_handle_case_default ();  /* i.e. (ELSE): or (*): */\n-      else\n-\tchill_handle_case_label_range (TREE_OPERAND (label_value, 0),\n-\t\t\t\t       TREE_OPERAND (label_value, 1),\n-\t\t\t\t       selector);\n-    }\n-  else if (TREE_CODE (label_value) == TYPE_DECL)\n-    {\n-      tree type = TREE_TYPE (label_value);\n-      if (! discrete_type_p (type))\n-\terror (\"mode in label is not discrete\");\n-      else\n-\tchill_handle_case_label_range (TYPE_MIN_VALUE (type),\n-\t\t\t\t       TYPE_MAX_VALUE (type),\n-\t\t\t\t       selector);\n-    }\n-  else\n-    {\n-      register tree label = build_decl (LABEL_DECL, NULL_TREE, NULL_TREE);\n-\n-      label_value = check_case_value (label_value, selector);\n-\n-      if (TREE_CODE (label_value) != ERROR_MARK)\n-\t{\n-\t  tree duplicate;\n-\t  int success = pushcase (label_value, convert, label, &duplicate);\n-\t  if (success == 1)\n-\t    error (\"label not within a CASE statement\");\n-\t  else if (success == 2)\n-\t    {\n-\t      error (\"duplicate case value\");\n-\t      error_with_decl (duplicate, \n-\t\t\t       \"this is the first entry for that value\");\n-\t    }\n-\t  else if (success == 3)\n-\t    error (\"CASE value out of range\");\n-\t  else if (success == 4)\n-\t    error (\"empty range\");\n-\t  else if (success == 5)\n-\t    error (\"label within scope of cleanup or variable array\");\n-        }\n-    }\n-}\n-\n-int\n-chill_handle_single_dimension_case_label (\n-  selector, label_spec, expand_exit_needed, caseaction_flag\n-)\n-  tree selector, label_spec;\n-  int *expand_exit_needed, *caseaction_flag;\n-{\n-  tree labels, one_label;\n-  int  no_completeness_check = 0;\n-\n-  if (*expand_exit_needed || *caseaction_flag == 1)\n-    {\n-      expand_exit_something ();\n-      *expand_exit_needed = 0;\n-    }\n-\n-  for (labels = label_spec; labels != NULL_TREE; labels = TREE_CHAIN (labels))\n-    for (one_label = TREE_VALUE (labels); one_label != NULL_TREE;\n-         one_label = TREE_CHAIN (one_label))\n-      {\n-        if (TREE_VALUE (one_label) == case_else_node)\n-          no_completeness_check = 1;\n-\n-        chill_handle_case_label (TREE_VALUE (one_label), selector);\n-      }\n-\n-  *caseaction_flag = 1;\n-\n-  return no_completeness_check;\n-}\n-\n-static tree\n-chill_handle_multi_case_label_range (low, high, selector)\n-  tree low, high, selector;\n-{\n-  tree low_expr, high_expr, and_expr;\n-  tree selector_type;\n-  int  low_target_val, high_target_val;\n-  int  low_type_val, high_type_val;\n-\n-  /* we can eliminate some tests is the low and/or high value in the given range\n-     are outside the range of the selector type. */\n-  low_target_val  = TREE_INT_CST_LOW (low);\n-  high_target_val = TREE_INT_CST_LOW (high);\n-  selector_type   = TREE_TYPE (selector);\n-  low_type_val    = TREE_INT_CST_LOW (TYPE_MIN_VALUE (selector_type));\n-  high_type_val   = TREE_INT_CST_LOW (TYPE_MAX_VALUE (selector_type));\n-\n-  if (low_target_val > high_type_val || high_target_val < low_type_val)\n-    return boolean_false_node; /* selector never in range */\n-\n-  if (low_type_val >= low_target_val)\n-    {\n-      if (high_type_val <= high_target_val)\n-\treturn boolean_true_node; /* always in the range */\n-      return build_compare_expr (LE_EXPR, selector, high);\n-    }\n-\n-  if (high_type_val <= high_target_val)\n-    return build_compare_expr (GE_EXPR, selector, low);\n-\n-  /* The target range in completely within the range of the selector, but we\n-     might be able to save a test if the upper bound is the same as the lower\n-     bound. */\n-  if (low_target_val == high_target_val)\n-    return build_compare_expr (EQ_EXPR, selector, low);\n-\n-  /* No optimizations possible. Just generate tests against the upper and lower\n-     bound of the target */\n-  low_expr  = build_compare_expr (GE_EXPR, selector, low);\n-  high_expr = build_compare_expr (LE_EXPR, selector, high);\n-  and_expr  = build_chill_binary_op (TRUTH_ANDIF_EXPR, low_expr, high_expr);\n-\n-  return and_expr;\n-}\n-\n-static tree\n-chill_handle_multi_case_else_label (selector)\n-     tree selector;\n-{\n-  tree else_range, selector_value, selector_type;\n-  tree low, high, larg;\n-\n-  else_range = TREE_PURPOSE (selector);\n-  if (else_range == NULL_TREE)\n-    return boolean_false_node; /* no values in ELSE range */\n-\n-  /* Test each of the ranges in the else-range chain */\n-  selector_value = TREE_VALUE (selector);\n-  selector_type  = TREE_TYPE (selector_value);\n-  low  = convert (selector_type, TREE_PURPOSE (else_range));\n-  high = convert (selector_type, TREE_VALUE (else_range));\n-  larg = chill_handle_multi_case_label_range (low, high, selector_value);\n-\n-  for (else_range = TREE_CHAIN (else_range);\n-       else_range != NULL_TREE;\n-       else_range = TREE_CHAIN (else_range))\n-    {\n-      tree rarg;\n-      low  = convert (selector_type, TREE_PURPOSE (else_range));\n-      high = convert (selector_type, TREE_VALUE (else_range));\n-      rarg = chill_handle_multi_case_label_range (low, high, selector_value);\n-      larg = build_chill_binary_op (TRUTH_ORIF_EXPR, larg, rarg);\n-    }\n-\n-  return larg;\n-}\n-\n-static tree\n-chill_handle_multi_case_label (selector, label)\n-  tree selector, label;\n-{\n-  tree expr = NULL_TREE;\n-\n-  if (label == NULL_TREE || TREE_CODE (label) == ERROR_MARK)\n-    return NULL_TREE;\n-\n-  if (TREE_CODE (label) == INTEGER_CST)\n-    {\n-      int  target_val = TREE_INT_CST_LOW (label);\n-      tree selector_type = TREE_TYPE (TREE_VALUE (selector));\n-      int  low_type_val  = TREE_INT_CST_LOW (TYPE_MIN_VALUE (selector_type));\n-      int  high_type_val = TREE_INT_CST_LOW (TYPE_MAX_VALUE (selector_type));\n-      if (target_val < low_type_val || target_val > high_type_val)\n-\texpr = boolean_false_node;\n-      else\n-\texpr = build_compare_expr (EQ_EXPR, TREE_VALUE (selector), label);\n-    }\n-  else if (TREE_CODE (label) == RANGE_EXPR)\n-    {\n-      if (TREE_OPERAND (label, 0) == NULL_TREE)\n-\t{\n-\t  if (TREE_OPERAND (label, 1) == NULL_TREE)\n-\t    expr = boolean_true_node; /* (*) -- matches everything */\n-\t  else\n-\t    expr = chill_handle_multi_case_else_label (selector);\n-\t}\n-      else\n-\t{\n-\t  tree low = TREE_OPERAND (label, 0);\n-\t  tree high = TREE_OPERAND (label, 1);\n-\t  if (TREE_CODE (low) != INTEGER_CST)\n-\t    {\n-\t      error (\"lower bound of range must be a discrete literal expression\");\n-\t      expr = error_mark_node;\n-\t    }\n-\t  if (TREE_CODE (high) != INTEGER_CST)\n-\t    {\n-\t      error (\"upper bound of range must be a discrete literal expression\");\n-\t      expr = error_mark_node;\n-\t    }\n-\t  if (expr != error_mark_node)\n-\t    {\n-\t      expr = chill_handle_multi_case_label_range (\n-                       low, high, TREE_VALUE (selector));\n-\t    }\n-\t}\n-    }\n-  else if (TREE_CODE (label) == TYPE_DECL)\n-    {\n-      tree type = TREE_TYPE (label);\n-      if (! discrete_type_p (type))\n-\t{\n-\t  error (\"mode in label is not discrete\");\n-\t  expr = error_mark_node;\n-\t}\n-      else\n-\texpr = chill_handle_multi_case_label_range (\n-\t\t TYPE_MIN_VALUE (type), TYPE_MAX_VALUE (type), TREE_VALUE (selector));\n-    }\n-  else\n-    {\n-      error (\"CASE label is not valid\");\n-      expr = error_mark_node;\n-    }\n-\n-  return expr;\n-}\n-\n-static tree\n-chill_handle_multi_case_label_list (selector, labels)\n-  tree selector, labels;\n-{\n-  tree one_label, larg, rarg;\n-\n-  one_label = TREE_VALUE (labels);\n-  larg = chill_handle_multi_case_label (selector, TREE_VALUE (one_label));\n-\n-  for (one_label = TREE_CHAIN (one_label);\n-       one_label != NULL_TREE;\n-       one_label = TREE_CHAIN (one_label))\n-    {\n-      rarg = chill_handle_multi_case_label (selector, TREE_VALUE (one_label));\n-      larg = build_chill_binary_op (TRUTH_ORIF_EXPR, larg, rarg);\n-    }\n-\n-  return larg;\n-}\n-\n-tree\n-build_multi_case_selector_expression (selector_list, label_spec)\n-  tree selector_list, label_spec;\n-{\n-  tree labels, selector, larg, rarg;\n-\n-  labels   = label_spec;\n-  selector = selector_list;\n-  larg = chill_handle_multi_case_label_list(selector, labels);\n-\n-  for (labels = TREE_CHAIN (labels), selector = TREE_CHAIN (selector);\n-       labels != NULL_TREE && selector != NULL_TREE;\n-       labels = TREE_CHAIN (labels), selector = TREE_CHAIN (selector))\n-    {\n-      rarg = chill_handle_multi_case_label_list(selector, labels);\n-      larg = build_chill_binary_op (TRUTH_ANDIF_EXPR, larg, rarg);\n-    }\n-\n-  if (labels != NULL_TREE || selector != NULL_TREE)\n-    error (\"number of CASE selectors does not match the number of CASE label lists\");\n-\n-  return larg;\n-}\n-\n-#define BITARRAY_TEST(ARRAY, INDEX) \\\n-  ((ARRAY)[(unsigned)(INDEX) / HOST_BITS_PER_CHAR]\\\n-\t\t\t  & (1 << ((unsigned)(INDEX) % HOST_BITS_PER_CHAR)))\n-#define BITARRAY_SET(ARRAY, INDEX) \\\n-  ((ARRAY)[(unsigned)(INDEX) / HOST_BITS_PER_CHAR]\\\n-\t\t\t  |= 1 << ((unsigned)(INDEX) % HOST_BITS_PER_CHAR))\n-\n-/* CASES_SEEN is a set (bitarray) of length COUNT.\n-   For each element that is zero, print an error message,\n-   assume the element have the given TYPE. */\n-\n-static void\n-print_missing_cases (type, cases_seen, count)\n-     tree type;\n-     const unsigned char *cases_seen;\n-     long count;\n-{\n-  long i;\n-  for (i = 0;  i < count; i++)\n-    {\n-      if (BITARRAY_TEST(cases_seen, i) == 0)\n-\t{\n-\t  char buf[20];\n-\t  long x = i;\n-\t  long j;\n-\t  tree t = type;\n-\t  const char *err_val_name = \"???\";\n-\t  if (TYPE_MIN_VALUE (t)\n-\t      && TREE_CODE (TYPE_MIN_VALUE (t)) == INTEGER_CST)\n-\t    x += TREE_INT_CST_LOW (TYPE_MIN_VALUE (t));\n-\t  while (TREE_TYPE (t) != NULL_TREE)\n-\t    t = TREE_TYPE (t);\n-\t  switch (TREE_CODE (t))\n-\t    {\n-\t      tree v;\n-\t    case BOOLEAN_TYPE:\n-\t      err_val_name = x ? \"TRUE\" : \"FALSE\";\n-\t      break;\n-\t    case CHAR_TYPE:\n-\t      {\n-\t\tchar *bufptr;\n-\t\tif ((x >= ' ' && x < 127) && x != '\\'' && x != '^')\n-\t\t  sprintf (buf, \"'%c'\", (char)x);\n-\t\telse\n-\t\t  sprintf (buf, \"'^(%ld)'\", x);\n-\t\tbufptr = buf;\n-\t\tj = i;\n-\t\twhile (j < count && !BITARRAY_TEST(cases_seen, j))\n-\t\t  j++;\n-\t\tif (j > i + 1)\n-\t\t  {\n-\t\t    long y = x+j-i-1;\n-\t\t    bufptr += strlen (bufptr);\n-\t\t    if ((y >= ' ' && y < 127) && y != '\\'' && y != '^')\n-\t\t      sprintf (bufptr, \"%s:'%c'\", buf, (char)y);\n-\t\t    else\n-\t\t      sprintf (bufptr, \"%s:'^(%ld)'\", buf, y);\n-\t\t    i = j - 1;      \n-\t\t  }\n-\t\terr_val_name = bufptr;\n-\t      }\n-\t      break;\n-\t    case ENUMERAL_TYPE:\n-\t      for (v = TYPE_VALUES (t);  v && x;  v = TREE_CHAIN (v))\n-\t\tx--;\n-\t      if (v)\n-\t\terr_val_name = IDENTIFIER_POINTER (TREE_PURPOSE (v));\n-\t      break;\n-\t    default:\n-\t      j = i;\n-\t      while (j < count && !BITARRAY_TEST(cases_seen, j))\n-\t\tj++;\n-\t      if (j == i + 1)\n-\t\tsprintf (buf, \"%ld\", x);\n-\t      else\n-\t\tsprintf (buf, \"%ld:%ld\", x, x+j-i-1);\n-\t      i = j - 1;      \n-\t      err_val_name = buf;\n-\t      break;\n-\t    }\n-\t  error (\"incomplete CASE - %s not handled\", err_val_name);\n-\t}\n-    }\n-}\n-\n-void\n-check_missing_cases (type)\n-     tree type;\n-{\n-  int is_sparse;\n-  /* For each possible selector value. a one iff it has been matched\n-     by a case value alternative. */\n-  unsigned char *cases_seen;\n-  /* The number of possible selector values. */\n-  HOST_WIDE_INT size = all_cases_count (type, &is_sparse);\n-  HOST_WIDE_INT bytes_needed\n-    = (size + HOST_BITS_PER_CHAR) / HOST_BITS_PER_CHAR;\n-\n-  if (size == -1)\n-    warning (\"CASE selector with variable range\");\n-  else if (size < 0 || size > 600000\n-\t   /* We deliberately use malloc here - not xmalloc. */\n-\t   || (cases_seen = (char*) malloc (bytes_needed)) == NULL)\n-    warning (\"too many cases to do CASE completeness testing\");\n-  else\n-    {\n-      memset (cases_seen, 0, bytes_needed);\n-      mark_seen_cases (type, cases_seen, size, is_sparse);\n-      print_missing_cases (type, cases_seen, size);\n-      free (cases_seen);\n-    }\n-}\n-\n-/*\n- * We build an expression tree here because, in many contexts,\n- * we don't know the type of result that's desired.  By the\n- * time we get to expanding the tree, we do know.\n- */\n-tree\n-build_chill_case_expr (exprlist, casealtlist_expr,\n-\t\t       optelsecase_expr)\n-     tree exprlist, casealtlist_expr, optelsecase_expr;\n-{\n-  return build (CASE_EXPR, NULL_TREE, exprlist,\n-\t\toptelsecase_expr ?\n-\t\t  tree_cons (NULL_TREE,\n-\t\t\t     optelsecase_expr,\n-\t\t\t     casealtlist_expr) :\n-\t\t  casealtlist_expr);\n-}\n-\n-/* This function transforms the selector_list and alternatives into a COND_EXPR. */\n-tree\n-build_chill_multi_dimension_case_expr (selector_list, alternatives, else_expr)\n-  tree selector_list, alternatives, else_expr;\n-{\n-  tree expr;\n-\n-  selector_list = check_case_selector_list (selector_list);\n-\n-  if (alternatives == NULL_TREE)\n-    return NULL_TREE;\n-\n-  alternatives = nreverse (alternatives);\n-  /* alternatives represents the CASE label specifications and resulting values in\n-     the reverse order in which they appeared.\n-     If there is an ELSE expression, then use it. If there is no\n-     ELSE expression, make the last alternative (which is the first in the list)\n-     into the ELSE expression. This is safe because, if the CASE is complete\n-     (as required), then the last condition need not be checked anyway. */\n-  if (else_expr != NULL_TREE)\n-    expr = else_expr;\n-  else\n-    {\n-      expr = TREE_VALUE (alternatives);\n-      alternatives = TREE_CHAIN (alternatives);\n-    }\n-\n-  for ( ; alternatives != NULL_TREE; alternatives = TREE_CHAIN (alternatives))\n-    { \n-      tree value  = TREE_VALUE (alternatives);\n-      tree labels = TREE_PURPOSE (alternatives);\n-      tree cond   = build_multi_case_selector_expression(selector_list, labels);\n-      expr = build_nt (COND_EXPR, cond, value, expr);\n-    }\n-\n-  return expr;\n-}\n-\n-\f\n-/* This is called with the assumption that RHS has been stabilized.  \n-   It has one purpose:  to iterate through the CHILL list of LHS's */\n-void\n-expand_assignment_action (loclist, modifycode, rhs)\n-     tree loclist;\n-     enum chill_tree_code modifycode;\n-     tree rhs;\n-{\n-  if (loclist == NULL_TREE || TREE_CODE (loclist) == ERROR_MARK\n-      || rhs == NULL_TREE  || TREE_CODE (rhs) == ERROR_MARK)\n-    return;\n-\n-  if (TREE_CHAIN (loclist) != NULL_TREE)\n-    { /* Multiple assignment */\n-      tree target;\n-      if (TREE_TYPE (rhs) != NULL_TREE)\n-\trhs = save_expr (rhs);\n-      else if (TREE_CODE (rhs) == CONSTRUCTOR)\n-\terror (\"type of tuple cannot be implicit in multiple assignent\");\n-      else if (TREE_CODE (rhs) == CASE_EXPR || TREE_CODE (rhs) == COND_EXPR)\n-\terror (\"conditional expression cannot be used in multiple assignent\");\n-      else\n-\terror (\"internal error - unknown type in multiple assignment\");\n-\n-      if (modifycode != NOP_EXPR)\n-\t{\n-\t  error (\"no operator allowed in multiple assignment,\");\n-\t  modifycode = NOP_EXPR;\n-\t}\n-\n-      for (target = TREE_CHAIN (loclist); target; target = TREE_CHAIN (target))\n-\t{\n-\t  if (!CH_EQUIVALENT (TREE_TYPE (TREE_VALUE (target)),\n-\t\t\t      TREE_TYPE (TREE_VALUE (loclist))))\n-\t    {\n-\t      error\n-\t\t(\"location modes in multiple assignment are not equivalent\");\n-\t      break;\n-\t    }\n-\t}\n-    }\n-  for ( ; loclist != NULL_TREE; loclist = TREE_CHAIN (loclist))\n-    chill_expand_assignment (TREE_VALUE (loclist), modifycode, rhs);\n-}\n-\n-void\n-chill_expand_assignment (lhs, modifycode, rhs)\n-     tree lhs;\n-     enum chill_tree_code modifycode;\n-     tree rhs;\n-{\n-  tree loc;\n-\n-  while (TREE_CODE (lhs) == COMPOUND_EXPR)\n-    {\n-      expand_expr (TREE_OPERAND (lhs, 0), const0_rtx, VOIDmode, 0);\n-      emit_queue ();\n-      lhs = TREE_OPERAND (lhs, 1);\n-    }\n-\n-  if (TREE_CODE (lhs) == ERROR_MARK)\n-    return;\n-\n-  /* errors for assignment to BUFFER, EVENT locations.\n-     what about SIGNALs? FIXME: Need similar test in\n-     build_chill_function_call. */\n-  if (TREE_CODE (lhs) == IDENTIFIER_NODE)\n-    {\n-      tree decl = lookup_name (lhs);\n-      if (decl)\n-\t{\n-\t  tree type = TREE_TYPE (decl);\n-\t  if (CH_IS_BUFFER_MODE (type) || CH_IS_EVENT_MODE (type))\n-\t    {\n-\t      error (\"you may not assign a value to a BUFFER or EVENT location\");\n-\t      return;\n-\t    }\n-\t}\n-    }\n-\n-  if (TYPE_READONLY_PROPERTY (TREE_TYPE (lhs)) || TREE_READONLY (lhs))\n-    {\n-      error (\"can't assign value to READonly location\");\n-      return;\n-    }\n-  if (CH_TYPE_NONVALUE_P (TREE_TYPE (lhs)))\n-    {\n-      error (\"cannot assign to location with non-value property\");\n-      return;\n-    }\n-\n-  if (TREE_CODE (TREE_TYPE (lhs)) == REFERENCE_TYPE)\n-    lhs = convert_from_reference (lhs);\n-\n-  /* check for lhs is a location */\n-  loc = lhs;\n-  while (1)\n-    {\n-      if (TREE_CODE (loc) == SLICE_EXPR)\n-\tloc = TREE_OPERAND (loc, 0);\n-      else if (TREE_CODE (loc) == SET_IN_EXPR)\n-\tloc = TREE_OPERAND (loc, 1);\n-      else\n-\tbreak;\n-    }\n-  if (! CH_LOCATION_P (loc))\n-    {\n-      error (\"lefthand side of assignment is not a location\");\n-      return;\n-    }\n-\n-  /* If a binary op has been requested, combine the old LHS value with\n-     the RHS producing the value we should actually store into the LHS. */\n-\n-  if (modifycode != NOP_EXPR)\n-    {\n-      lhs = stabilize_reference (lhs);\n-      /* This is to handle border-line cases such\n-\t as: LHS OR := [I].  This seems to be permitted\n-\t by the letter of Z.200, though it violates\n-\t its spirit, since LHS:=LHS OR [I] is\n-\t *not* legal. */\n-      if (TREE_TYPE (rhs) == NULL_TREE)\n-\trhs = convert (TREE_TYPE (lhs), rhs);\n-      rhs = build_chill_binary_op (modifycode, lhs, rhs);\n-    }\n-\n-  rhs = chill_convert_for_assignment (TREE_TYPE (lhs), rhs, \"assignment\");\n-\n-  /* handle the LENGTH (vary_array) := expr action */\n-  loc = lhs;\n-  if (TREE_CODE (loc) == NOP_EXPR)\n-    loc = TREE_OPERAND (loc, 0);\n-  if (TREE_CODE (loc) == COMPONENT_REF\n-      && chill_varying_type_p (TREE_TYPE (TREE_OPERAND (loc, 0)))\n-      && DECL_NAME (TREE_OPERAND (loc, 1)) == var_length_id)\n-    {\n-      expand_varying_length_assignment (TREE_OPERAND (loc, 0), rhs);\n-    }\n-  else if (TREE_CODE (lhs) == SLICE_EXPR)\n-    {\n-      tree func = lookup_name (get_identifier (\"__pscpy\"));\n-      tree dst = TREE_OPERAND (lhs, 0);\n-      tree dst_offset = TREE_OPERAND (lhs, 1);\n-      tree length = TREE_OPERAND (lhs, 2);\n-      tree src, src_offset;\n-      if (TREE_CODE (rhs) == SLICE_EXPR)\n-\t{\n-\t  src = TREE_OPERAND (rhs, 0);\n-\t  /* Should check that the TREE_OPERAND (src, 0) is\n-\t     the same as length and powerserlen (src).  FIXME */\n-\t  src_offset = TREE_OPERAND (rhs, 1);\n-\t}\n-      else\n-\t{\n-\t  src = rhs;\n-\t  src_offset = integer_zero_node;\n-\t}\n-      expand_expr_stmt (build_chill_function_call (func,\n-\ttree_cons (NULL_TREE, force_addr_of (dst),\n-\t  tree_cons (NULL_TREE, powersetlen (dst),\n-\t    tree_cons (NULL_TREE, convert (long_unsigned_type_node, dst_offset),\n-\t      tree_cons (NULL_TREE, force_addr_of (src),\n-\t\ttree_cons (NULL_TREE, powersetlen (src),\n-\t\t  tree_cons (NULL_TREE, convert (long_unsigned_type_node, src_offset),\n-\t\t    tree_cons (NULL_TREE, convert (long_unsigned_type_node, length),\n-\t\t       NULL_TREE)))))))));\n-    }\n-\n-  else if (TREE_CODE (lhs) == SET_IN_EXPR)\n-    {\n-      tree from_pos = save_expr (TREE_OPERAND (lhs, 0));\n-      tree set = TREE_OPERAND (lhs, 1);\n-      tree domain = TYPE_DOMAIN (TREE_TYPE (set));\n-      tree set_length\n-\t= fold (build (PLUS_EXPR, integer_type_node,\n-\t\t       fold (build (MINUS_EXPR, integer_type_node,\n-\t\t\t\t    TYPE_MAX_VALUE (domain),\n-\t\t\t\t    TYPE_MIN_VALUE (domain))),\n-\t\t       integer_one_node));\n-      tree filename = force_addr_of (get_chill_filename());\n-      \n-      if (TREE_CODE (TREE_TYPE (lhs)) != BOOLEAN_TYPE)\n-\tsorry(\"bitstring slice\");\n-      expand_expr_stmt (\n-\tbuild_chill_function_call (lookup_name (\n-\t  get_identifier (\"__setbitpowerset\")),\n-\t      tree_cons (NULL_TREE, build_chill_addr_expr (set, \"powerset\"),\n-\t\t  tree_cons (NULL_TREE, set_length,\n-\t\t    tree_cons (NULL_TREE, TYPE_MIN_VALUE (domain),\n-\t\t      tree_cons (NULL_TREE, convert (long_integer_type_node, from_pos),\n-\t\t\ttree_cons (NULL_TREE, rhs,\n-\t\t\t  tree_cons (NULL_TREE, filename,\n-\t\t\t    tree_cons (NULL_TREE, get_chill_linenumber(),\n-  \t\t\t      NULL_TREE)))))))));\n-    }\n-\n-  /* Handle arrays of packed bitfields. Currently, this is limited to bitfields\n-     which are 1 bit wide, so use the powerset runtime function. */\n-  else if (TREE_CODE (lhs) == PACKED_ARRAY_REF)\n-    {\n-      tree from_pos = save_expr (TREE_OPERAND (lhs, 1));\n-      tree array = TREE_OPERAND (lhs, 0);\n-      tree domain = TYPE_DOMAIN (TREE_TYPE (array));\n-      tree array_length = powersetlen (array);\n-      tree filename = force_addr_of (get_chill_filename());\n-      expand_expr_stmt (\n-\tbuild_chill_function_call (lookup_name (\n-\t  get_identifier (\"__setbitpowerset\")),\n-            tree_cons (NULL_TREE, build_chill_addr_expr (array, \"packed bitfield array\"),\n-\t\ttree_cons (NULL_TREE, convert (long_unsigned_type_node, array_length),\n-\t\t  tree_cons (NULL_TREE, convert (long_integer_type_node,\n-\t\t\t\t\t\t TYPE_MIN_VALUE (domain)),\n-\t\t    tree_cons (NULL_TREE, convert (long_integer_type_node, from_pos),\n-\t\t      tree_cons (NULL_TREE, build1 (CONVERT_EXPR, boolean_type_node, rhs),\n-\t\t\ttree_cons (NULL_TREE, filename,\n-\t\t\t  tree_cons (NULL_TREE, get_chill_linenumber(),\n-  \t\t\t    NULL_TREE)))))))));\n-    }\n-\n-  /* The following is probably superseded by the\n-     above code for SET_IN_EXPR. FIXME! */\n-  else if (TREE_CODE (lhs) == BIT_FIELD_REF)\n-    {\n-      tree set = TREE_OPERAND (lhs, 0);\n-      tree numbits = TREE_OPERAND (lhs, 1);\n-      tree from_pos = save_expr (TREE_OPERAND (lhs, 2));\n-      tree domain = TYPE_DOMAIN (TREE_TYPE (set));\n-      tree set_length\n-\t= fold (build (PLUS_EXPR, integer_type_node,\n-\t\t       fold (build (MINUS_EXPR, integer_type_node,\n-\t\t\t\t    TYPE_MAX_VALUE (domain),\n-\t\t\t\t    TYPE_MIN_VALUE (domain))),\n-\t\t       integer_one_node));\n-      tree filename = force_addr_of (get_chill_filename());\n-      tree to_pos;\n-\n-      switch (TREE_CODE (TREE_TYPE (rhs)))\n-\t{\n-\tcase SET_TYPE:\n-\t  to_pos = fold (build (MINUS_EXPR, integer_type_node,\n-\t\t\t\tfold (build (PLUS_EXPR, integer_type_node,\n-\t\t\t\t\t     from_pos, numbits)),\n-\t\t\t\tinteger_one_node));\n-\t  break;\n-\tcase BOOLEAN_TYPE:\n-\t  to_pos = from_pos;\n-\t  break;\n-\tdefault:\n-\t  abort ();\n-\t}\n-      \n-      if (TREE_CODE (TREE_TYPE (lhs)) != BOOLEAN_TYPE)\n-\tsorry(\"bitstring slice\");\n-      expand_expr_stmt (\n-\t  build_chill_function_call( lookup_name (\n-\t      get_identifier (\"__setbitpowerset\")),\n-\t\ttree_cons (NULL_TREE, build_chill_addr_expr (set, \"powerset\"),\n-\t\t  tree_cons (NULL_TREE, set_length,\n-\t\t    tree_cons (NULL_TREE, TYPE_MIN_VALUE (domain),\n-\t\t      tree_cons (NULL_TREE, from_pos,\n-\t\t\ttree_cons (NULL_TREE, rhs,\n-\t\t\t  tree_cons (NULL_TREE, filename,\n-\t\t\t    tree_cons (NULL_TREE, get_chill_linenumber(),\n-\t  \t\t      NULL_TREE)))))))));\n-    }\n-\n-  else\n-    expand_expr_stmt (build_chill_modify_expr (lhs, rhs));\n-}\n-\f\n-/* Also assumes that rhs has been stabilized */\n-void\n-expand_varying_length_assignment (lhs, rhs)\n-     tree lhs, rhs;\n-{\n-  tree base_array, min_domain_val;\n-\n-  pedwarn (\"LENGTH on left-hand-side is non-portable\");\n-      \n-  if (! CH_LOCATION_P (lhs))\n-    {\n-      error (\"can only set LENGTH of array location\");\n-      return;\n-    }\n-\n-  /* cause a RANGE exception if rhs would cause a 'hole' in the array. */\n-  rhs = valid_array_index_p (lhs, rhs, \"new array length too large\", 1);\n-\n-  base_array     = CH_VARYING_ARRAY_TYPE (TREE_TYPE (lhs));\n-  min_domain_val = TYPE_MIN_VALUE (TYPE_DOMAIN (base_array));\n-\n-  lhs = build_component_ref (lhs, var_length_id);\n-  rhs = fold (build (MINUS_EXPR, TREE_TYPE (rhs), rhs, min_domain_val));\n-\n-  expand_expr_stmt (build_chill_modify_expr (lhs, rhs));\n-}\n-\f\n-void\n-push_action ()\n-{\n-  push_handler ();\n-  if (ignoring)\n-    return;\n-  emit_line_note (input_filename, lineno);\n-}"}, {"sha": "acffa4bfd06b52505311bdfc9b2630baa03daaf2", "filename": "gcc/ch/actions.h", "status": "removed", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41823c5eb7d4504b6a4a396ca0d64573238fbbcf/gcc%2Fch%2Factions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41823c5eb7d4504b6a4a396ca0d64573238fbbcf/gcc%2Fch%2Factions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Factions.h?ref=41823c5eb7d4504b6a4a396ca0d64573238fbbcf", "patch": "@@ -1,34 +0,0 @@\n-/* Declarations for ch-actions.c.\n-   Copyright (C) 1992, 1993, 1994, 1998, 2000 Free Software Foundation, Inc.\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-/* used by compile_file */\n-\n-void init_chill PARAMS ((void));\n-\n-extern int grant_count;\n-\n-extern void push_handler PARAMS ((void));\n-extern void pop_handler PARAMS ((int));\n-extern void push_action PARAMS ((void));\n-\n-extern int  chill_handle_single_dimension_case_label PARAMS ((tree, tree, int *, int *));\n-extern tree build_chill_multi_dimension_case_expr    PARAMS ((tree, tree, tree));\n-extern tree build_multi_case_selector_expression     PARAMS ((tree, tree));\n-extern void compute_else_ranges                      PARAMS ((tree, tree));"}, {"sha": "08e8e4f05618ac4eea24969068c46d876dfa7d1e", "filename": "gcc/ch/ch-tree.def", "status": "removed", "additions": 0, "deletions": 114, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41823c5eb7d4504b6a4a396ca0d64573238fbbcf/gcc%2Fch%2Fch-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41823c5eb7d4504b6a4a396ca0d64573238fbbcf/gcc%2Fch%2Fch-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fch-tree.def?ref=41823c5eb7d4504b6a4a396ca0d64573238fbbcf", "patch": "@@ -1,114 +0,0 @@\n-/* This file contains the definitions and documentation for the\n-   additional tree codes used in the CHILL front end (see tree.def\n-   for the standard codes).\n-   Copyright (C) 1992, 1993 Free Software Foundation, Inc.\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-\n-/* \n- * CHILL types.\n- */\n-DEFTREECODE (GRANT_TYPE, \"grant_type\", 't', 0)\n-DEFTREECODE (SEIZE_TYPE, \"seize_type\", 't', 0)\n-/* \n- * CHILL decls.\n- */\n-DEFTREECODE (KEYWORD_DECL, \"keyword_decl\", 'd', 0)\n-DEFTREECODE (INSTANCE_METHOD_DECL, \"instance_method_decl\", 'd', 0)\n-DEFTREECODE (CLASS_METHOD_DECL, \"class_method_decl\", 'd', 0)\n-\n-/* A 'SEIZE (OLD->NEW)!POSTFIX' or 'GRANT (OLD->NEW)!POSTFIX' is\n-   represented as an ALIAS_DECL where DECL_OLD_PREFIX, DECL_NEW_PREFIX,\n-   and DECL_POSTFIX points to OLD, NEW, and POSTFIX, respectively.\n-   These are IDENTIFIER_NODEs, or NULL if empty.\n-   DECL_NAME is NEW!POSTFIX.  After binding, DECL_ABSTRACT_ORIGIN\n-   (if not an error_mark) points to a decl whose DECL_NAME is OLD!POSTFIX.\n-   and which this name is linked to.\n-   For SEIZE, DECL_SEIZEFILE names the most recent use_seize_file directive.\n-   For GRANT, DECL_SEIZEFILE names the seizefile doing the granting. */\n-DEFTREECODE (ALIAS_DECL, \"alias_decl\", 'd', 0)\n-\n-/* A variable, which is BASED on a pointer variable in DECL_ABSTRACT_ORIGIN. */\n-DEFTREECODE (BASED_DECL, \"based_decl\", 'd', 0)\n-\n-/* A pseudo-variable declared by a DO WITH. */\n-DEFTREECODE (WITH_DECL, \"with_decl\", 'd', 0)\n-\n-/*\n- * CHILL exprs.\n- */\n-DEFTREECODE (CONCAT_EXPR, \"concat_expr\", '2', 2)\n-\n-/* A slice (sub-array or sub-string) of operand 0, where\n-   operand 1 is the start of the slice, and operand 2 is its length.\n-   Currently, only used for bitstring sclices. */\n-DEFTREECODE (SLICE_EXPR, \"slice_expr\", 'e', 3)\n-\n-/* Later, SET_IN_EXPR might be replaced by BIT_FIELD_REF or IN_EXPR. */\n-DEFTREECODE (SET_IN_EXPR, \"set_in_expr\", '2', 2)\n-\n-/* A CASE_EXPR EX implements Chill CASE expression.\n-   TREE_OPERAND (EX, 0) is a TREE_LIST representing the <case selector list>,\n-   with one node for each expression.  (Only one is supported by the\n-   current implementation.)\n-   TREE_OPERAND (EX, 1) is also a TREE_LIST, with one node for each\n-   <value case alternative>.   The TREE_VALUE of these node is the\n-   <sub expression> (case element body); the TREE_PURPOSE contains\n-   the <case label specification>.  (The TREE_PURPOSE for the\n-   optional ELSE (default) branch is NULL_TREE.)  Each <case label\n-   specification> is also represented as a list with one TREE_LIST\n-   node for each <case label list> (though only length==1 is currently\n-   supported).  And finally: each <case label list> is again a list\n-   with one TREE_LIST node for each <case label>. */\n-DEFTREECODE (CASE_EXPR, \"case_expr\", 'e', 2)\n-\n-/* Powerset and static bit array operations.\n-   Operands have same mode as result.  */\n-DEFTREECODE (SET_NOT_EXPR,  \"set_not_expr\",  '1', 1)\n-DEFTREECODE (SET_IOR_EXPR,  \"set_ior_expr\",  '2', 2)\n-DEFTREECODE (SET_XOR_EXPR,  \"set_xor_expr\",  '2', 2)\n-DEFTREECODE (SET_AND_EXPR,  \"set_and_expr\",  '2', 2)\n-DEFTREECODE (SET_DIFF_EXPR, \"set_diff_expr\", '2', 2)\n-DEFTREECODE (PAREN_EXPR,  \"paren_expr\",  '1', 1)\n-\n-DEFTREECODE (STRING_EQ_EXPR, \"string_eq_expr\", '2', 2)\n-DEFTREECODE (STRING_LT_EXPR, \"string_lt_expr\", '2', 2)\n-\n-/* Used to represent a string repetition expression, until\n-   we have a type for it;  a SET_TYPE replicator needs a\n-   TYPE_DOMAIN even if it represents the empty set */\n-DEFTREECODE (REPLICATE_EXPR, \"replicate_expr\", 'e', 2)\n-\n-/* An undefined value.  Used for the Chill operator '*',\n-   and sometimes for padding. */\n-DEFTREECODE (UNDEFINED_EXPR, \"undefined_expr\", 'e', 0)\n-\n-/* Used to represent a process instance */\n-DEFTREECODE (INSTANCE_TYPE, \"instance_type\", 't', 0)\n-\n-/* Used to represent a reference to an array of bitfields. Currently restricted\n-   to fields which are 1 bit wide.  */\n-DEFTREECODE (PACKED_ARRAY_REF, \"packed_array_ref\", 'r', 2)\n-\n-/* ALSO NOTE:  LANG_TYPE is used for two things during pass 1;\n-   such a node is converted to some other type node during satisfy.\n-   If CH_NOVELTY_FLAG is set, then this node is a logical copy of\n-   its TREE_TYPE, but with a different novelty.\n-   If TYPE_READONLY is set, then the node stands for 'READ M'\n-   where M is the TREE_TYPE.  */"}, {"sha": "4b26e006c954fba7ebb32eccd23e75b50bb277d7", "filename": "gcc/ch/ch-tree.h", "status": "removed", "additions": 0, "deletions": 1148, "changes": 1148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41823c5eb7d4504b6a4a396ca0d64573238fbbcf/gcc%2Fch%2Fch-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41823c5eb7d4504b6a4a396ca0d64573238fbbcf/gcc%2Fch%2Fch-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fch-tree.h?ref=41823c5eb7d4504b6a4a396ca0d64573238fbbcf", "patch": "@@ -1,1148 +0,0 @@\n-/* Definitions for CHILL parsing and type checking.\n-   Copyright (C) 1992, 1993, 1994, 1998,\n-   1999, 2000, 2001 Free Software Foundation, Inc.\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-#ifndef GCC_CH_TREE_H\n-#define GCC_CH_TREE_H\n-\n-/* Usage of TREE_LANG_FLAG_?:\n-   1: TUPLE_NAMED_FIELD\n-   \"  TYPE_FIELDS_READONLY (in ARRAY_TYPE, RECORD_TYPE or UNION_TYPE)\n-   \"  C_DECLARED_LABEL_FLAG\n-   \"  C_TYPE_VARIABLE_SIZE\n-   2: C_TYPE_FIELDS_VOLATILE (in RECORD_TYPE or UNION_TYPE)\n-   \"  ELSE_LABEL_SPECIFIED (in CASE selector expression)\n-   3: UNSATISFIED_FLAG\n-   4: CH_USE_SEIZEFILE_RESTRICTED\n-   \"  CH_ALREADY_GRANTED\n-   5: CH_DERIVED_FLAG   (in EXPR or DECL)\n-*/\n-\n-/* Usage of TYPE_LANG_FLAG_?:\n-   0: CH_TYPE_NONVALUE_P\n-   1: C_TYPE_VARIABLE_SIZE\n-   2: CH_IS_ACCESS_MODE  \n-   3: CH_IS_BUFFER_MODE\n-   4: CH_IS_EVENT_MODE\n-   5: CH_ENUM_IS_NUMBERED\n-   6: CH_IS_TEXT_MODE\n-*/\n-\n-/* Language-dependent contents of an identifier.  */\n-\n-struct lang_identifier\n-{\n-  /* These match the fields in c-tree.h. */\n-  struct tree_identifier ignore;\n-  tree outer_value, local_value, implicit_decl;\n-  tree error_locus, limbo_value;\n-\n-  /* These are Chill-specific. */\n-  tree forbid;\n-  tree signal_dest;\n-  int  signal_data;\n-};\n-\n-/* Macros for access to language-specific slots in an identifier.  */\n-\n-/* The outer_value is a chain of decls (normally a single decl),\n-   that have been granted into the scope surrounding all modules. */\n-#define IDENTIFIER_OUTER_VALUE(NODE)\t\\\n-  (((struct lang_identifier *)(NODE))->outer_value)\n-#define IDENTIFIER_LOCAL_VALUE(NODE)\t\\\n-  (((struct lang_identifier *)(NODE))->local_value)\n-#define IDENTIFIER_IMPLICIT_DECL(NODE)\t\\\n-  (((struct lang_identifier *)(NODE))->implicit_decl)\n-#define IDENTIFIER_ERROR_LOCUS(NODE)\t\\\n-  (((struct lang_identifier *)(NODE))->error_locus)\n-#define IDENTIFIER_FORBID(NODE)         \\\n-  (((struct lang_identifier *)(NODE))->forbid)\n-\n-/* The nesting level increates by one for every nested 'group'.\n-   Predefined declarations have level -1; the global scope is level 0.\n- */\n-#define DECL_NESTING_LEVEL(DECL) \\\n-   ((DECL)->decl.vindex ? TREE_INT_CST_HIGH((DECL)->decl.vindex) : -1)\n-\n-/* Nesting of things that can have an ON-unit attached. */\n-extern int action_nesting_level;\n-\n-/* The DECL_NAME of a FIELD_DECL that represents the ELSE part of a variant. */\n-#define ELSE_VARIANT_NAME ridpointers[(int) RID_ELSE]\n-\n-/* For a LABEL_DECL:  action_nesting_level of its target. */\n-#define DECL_ACTION_NESTING_LEVEL(NODE) ((NODE)->decl.u2.i)\n-\n-#define DECL_OLD_PREFIX(DECL) ((DECL)->decl.initial)\n-#define DECL_NEW_PREFIX(DECL) ((DECL)->decl.result)\n-#define DECL_POSTFIX(DECL) ((DECL)->decl.arguments)\n-extern tree ALL_POSTFIX;\n-#define DECL_SEIZEFILE(DECL) ((DECL)->decl.size)\n-#define DECL_POSTFIX_ALL(DECL) (DECL_POSTFIX(DECL) == ALL_POSTFIX)\n-#define DECL_OLD_NAME(DECL) decl_old_name(DECL)\n-/* For a siezefile name this means restricted usage of this file.\n-   In this case, the USE_SEIZE_FILE directive will not be copied\n-   into the grant file */\n-#define CH_USE_SEIZEFILE_RESTRICTED(NODE) TREE_LANG_FLAG_4(NODE)\n-extern tree decl_old_name PARAMS ((tree));\n-\n-/* for selective granting, mark as already granted */\n-#define CH_ALREADY_GRANTED(NODE) TREE_LANG_FLAG_4(NODE)\n-\n-/* to store the receiving process of that signal\n-   at definition time */\n-#define IDENTIFIER_SIGNAL_DEST(NODE)\t\\\n-  (((struct lang_identifier *)(NODE))->signal_dest)\n-\n-/* indicates a signal with no data */\n-#define IDENTIFIER_SIGNAL_DATA(NODE)\t\\\n-  (((struct lang_identifier *)(NODE))->signal_data)\n-\n-/* In identifiers, C uses the following fields in a special way:\n-   TREE_PUBLIC        to record that there was a previous local extern decl.\n-   TREE_USED          to record that such a decl was used.\n-   TREE_ADDRESSABLE   to record that the address of such a decl was used.  */\n-\n-/* Nonzero means reject anything that Z.200 Recommendation forbids.  */\n-extern int pedantic;\n-\n-/* the prototypical CHILL INSTANCE type */\n-extern tree instance_type_node;\n-\n-/* Non-zero if type or expr depends on non-resolved identifier. */\n-#define UNSATISFIED(expr) \\\n-  (UNSATISFIED_FLAG (expr) || TREE_CODE (expr) == IDENTIFIER_NODE)\n-#define UNSATISFIED_FLAG(expr) TREE_LANG_FLAG_3 (expr)\n-\n-/* Non-zero in a TREE_LIST if part of a labelled structure tuple. */\n-#define TUPLE_NAMED_FIELD(LIST) TREE_LANG_FLAG_1(LIST)\n-\n-/* In an ARRAY_TYPE, RECORD_TYPE or UNION_TYPE, nonzero if any component\n-   is read-only.  */\n-#define TYPE_FIELDS_READONLY(type) TREE_LANG_FLAG_1 (type)\n-\n-/* True if TYPE has the \"read-only property.\" */\n-#define TYPE_READONLY_PROPERTY(TYPE) \\\n-  (TYPE_READONLY (TYPE) || TYPE_FIELDS_READONLY (TYPE))\n-\n-/* In a RECORD_TYPE or UNION_TYPE, nonzero if any component is volatile.  */\n-#define C_TYPE_FIELDS_VOLATILE(type) TREE_LANG_FLAG_2 (type)\n-\n-/* In a CASE selector expression, nonzero if any alternative specifies (ELSE) for\n-   that selector. */\n-#define ELSE_LABEL_SPECIFIED(expr) TREE_LANG_FLAG_2 (expr)\n-\n-/* CH_CHARS_TYPE_P(TYPE) is true iff TYPE is a character string type.\n-\n-   There is no essential difference between a string and a (one-dimensional)\n-   character array, at least for non-varying types.  I don't know where\n-   the Chill designers got the idea that it was useful to make a distinction.\n-   (I suspect packing might be involved, but on a byte-adressable machine\n-   we don't care.)  Since we want the same code to be generated for\n-   char arrays as for char strings, we use the same representation for\n-   both.  But we still need to distinguish them for the sake a Chill\n-   type checking.  We do that using TYPE_STRING_FLAG. */\n-\n-#define MARK_AS_STRING_TYPE(TYPE) (TYPE_STRING_FLAG (TYPE) = 1)\n-\n-#define CH_CHARS_TYPE_P(type) \\\n-  (TREE_CODE (type) == ARRAY_TYPE && TREE_CODE(TREE_TYPE(type)) == CHAR_TYPE \\\n-   && TYPE_STRING_FLAG (type))\n-\n-/* True if TYPE is CHARS(1). */\n-#define CH_CHARS_ONE_P(TYPE) (CH_CHARS_TYPE_P(TYPE) \\\n-   && integer_zerop (TYPE_MAX_VALUE (TYPE_DOMAIN (TYPE))))\n-\n-/* True if TYPE is a bitstring (BOOLS or BIT) type.\n-   The TYPE_STRING_FLAG is used to distinguish a bitstring from a powerset. */\n-\n-#define CH_BOOLS_TYPE_P(type) \\\n-  (TREE_CODE (type) == SET_TYPE && TYPE_STRING_FLAG (type))\n-\n-/* True if TYPE is BOOLS(1). */\n-#define CH_BOOLS_ONE_P(TYPE) (CH_BOOLS_TYPE_P(TYPE) \\\n-   && integer_zerop (TYPE_MAX_VALUE (TYPE_DOMAIN (TYPE))))\n-\n-/* Value is nonzero if TYPE is a CHILL string type.\n-   See CH_CHARS_TYPE_P and CH_BOOLS_TYPE_P above. */\n-\n-#define CH_STRING_TYPE_P(type) \\\n- ((TREE_CODE (type) == ARRAY_TYPE || TREE_CODE (type) == SET_TYPE) \\\n-  && TYPE_STRING_FLAG (type))\n-\n-/* In a RECORD_TYPE, a sorted array of the fields of the type.  */\n-struct lang_type_record\n-{\n-  int  len;\n-  tree tasking_code_decl;\n-  tree elts[1];\n-};\n-\n-struct lang_type\n-{\n-  union\n-    {\n-      struct lang_type_record rec;\n-    } foo;\n-};\n-\n-struct lang_decl\n-{\n-  union\n-    {\n-      tree stuff;\n-    } foo;\n-};\n-/* A tasking type's corresponding tasking_code_variable has its\n-   decl pointer in here. */\n-#define DECL_TASKING_CODE_DECL(DECL) (DECL_LANG_SPECIFIC(DECL))\n-\n-/* A pointer to an as-yet undefined type.  */\n-extern tree unknown_type_node;\n-\n-/* The CHILL type INT (either integer_type_node or \n-   short_integer_type_node). */\n-extern tree chill_integer_type_node;\n-extern tree chill_unsigned_type_node;\n-\n-/* Nonzero for FIELD_DECL node means that this FIELD_DECL is\n-   a member of a union construct.  */\n-#define TREE_UNION_ELEM(NODE) ((NODE)->decl.regdecl_flag) /* overloaded! */\n-\n-/* Mark which labels are explicitly declared.\n-   These may be shadowed, and may be referenced from nested functions.  */\n-#define C_DECLARED_LABEL_FLAG(label) TREE_LANG_FLAG_1 (label)\n-\n-/* Record whether a type was written with nonconstant size.\n-   Note that TYPE_SIZE may have simplified to a constant.  */\n-#define C_TYPE_VARIABLE_SIZE(type) TYPE_LANG_FLAG_1 (type)\n-\n-#define DECL_WEAK_NAME(DECL) DECL_LANG_FLAG_0(DECL)\n-\n-/* These are for FUNCTION_DECLs.  */\n-#define CH_DECL_GENERAL(DECL) DECL_LANG_FLAG_1(DECL)\n-#define CH_DECL_SIMPLE(DECL) DECL_LANG_FLAG_2(DECL)\n-#define CH_DECL_RECURSIVE(DECL) DECL_LANG_FLAG_3(DECL)\n-#define CH_FUNCTION_SETS_RESULT(DECL) DECL_LANG_FLAG_6(DECL)\n-\n-/* For a CONST_DECL, indicates that it was implicitly declared\n-   in a SET mode declaration, and it should not be explicitly granted. */\n-#define CH_DECL_ENUM(DECL)  DECL_LANG_FLAG_3(DECL)\n-\n-/* in a FIELD_DECL use DECL_LANG_FLAG_4 to mark FORBID in a grant-statement */\n-#define CH_DECL_FORBID(DECL) DECL_LANG_FLAG_4(DECL)\n-\n-/* in an ALIAS_DECL use DECL_LANG_FLAG_4 to mark decl was granted */\n-#define CH_DECL_GRANTED(DECL) DECL_LANG_FLAG_4(DECL)\n-\n-/* (in a non-FIELD_DECL) note that this decl was hidden by push_module(). */\n-#define DECL_HIDDEN_BY_MODULE(decl) DECL_LANG_FLAG_4 (decl)\n-\n-/* Record in each node resulting from a binary operator\n-   what operator was specified for it.  */\n-#define C_EXP_ORIGINAL_CODE(exp) ((enum tree_code) TREE_COMPLEXITY (exp))\n-\n-/* Store a value in that field.  */\n-#define C_SET_EXP_ORIGINAL_CODE(exp, code) \\\n-  (TREE_COMPLEXITY (exp) = (int)(code))\n-\n-/* Record whether a typedef for type `int' was actually `signed int'.  */\n-#define C_TYPEDEF_EXPLICITLY_SIGNED(exp) DECL_LANG_FLAG_1 ((exp))\n-\n-/* For FUNCTION_TYPE, a hidden list of types of arguments.  The same as\n-   TYPE_ARG_TYPES for functions with prototypes, but created for functions\n-   without prototypes.  */\n-#define TYPE_ACTUAL_ARG_TYPES(NODE) TYPE_NONCOPIED_PARTS (NODE)\n-\n-/* For FUNCTION_TYPE or METHOD_TYPE, a list of the\n-   (names of) exceptions that this type can raise.  */\n-#define TYPE_RAISES_EXCEPTIONS(NODE) ((NODE)->type.minval)\n-\n-/* For UNION_TYPE, the list of tag fields that distinguishes the members.  */\n-#define TYPE_TAGFIELDS(NODE) ((NODE)->type.minval)\n-\n-/* For RECORD_TYPE, the tag values that select it.  */\n-#define TYPE_TAG_VALUES(NODE) TYPE_BINFO(NODE)\n-\n-/* For VAR_DECL, TYPE_DECL, FUNCTION_DECL, indicates that\n-   the DECL was read from a seizefile but not seized */\n-#define CH_DECL_NOTDECLARED(DECL) DECL_LANG_FLAG_5(DECL)\n-\n-/* For FUNCTION_DECL's, mark as PROCESSEs. */\n-#define CH_DECL_PROCESS(DECL) DECL_LANG_FLAG_7(DECL)\n-\n-/* For TYPE_DECL's, mark as SIGNALs. */\n-#define CH_DECL_SIGNAL(DECL) DECL_LANG_FLAG_7(DECL)\n-\f\n-/* Macros using terminology of the CHILL Blue Book. */\n-\n-/* A class is either Null, All, M-value, M-derived, or M-reference,\n-   where M is some mode (type). */\n-\n-enum ch_class_kind {\n-  CH_ALL_CLASS, CH_NULL_CLASS,\n-  CH_VALUE_CLASS, CH_DERIVED_CLASS, CH_REFERENCE_CLASS\n-};\n-\n-typedef struct ch_class {\n-  enum ch_class_kind kind;\n-  tree mode;  /* The 'M' in M-value, M-derived, or M-reference. */\n-} ch_class;\n-\n-struct mode_chain;  /* Forward reference */\n-\n-#define CH_IS_REFERENCE_MODE(MODE) (TREE_CODE (MODE) == POINTER_TYPE)\n-#define CH_IS_BOUND_REFERENCE_MODE(MODE) \\\n-  (TREE_CODE (MODE) == POINTER_TYPE && TREE_TYPE(MODE) != void_type_node)\n-#define CH_IS_PROCEDURE_MODE(MODE) (TREE_CODE (MODE) == FUNCTION_TYPE)\n-#define CH_IS_INSTANCE_MODE(MODE)  (CH_SIMILAR (MODE, instance_type_node))\n-#define CH_IS_BUFFER_MODE(MODE)    (TYPE_LANG_FLAG_3(MODE))\n-#define CH_IS_EVENT_MODE(MODE)     (TYPE_LANG_FLAG_4(MODE))\n-/* This is TRUE if the set is numbered, which makes pred/succ\n-   unusable */\n-#define CH_ENUM_IS_NUMBERED(MODE)  (TYPE_LANG_FLAG_5(MODE))\n-\n-/* for ACCESS, and TEXT mode */\n-#define CH_IS_ACCESS_MODE(MODE)        (TYPE_LANG_FLAG_2(MODE))\n-#define CH_IS_TEXT_MODE(MODE)          (TYPE_LANG_FLAG_6(MODE))\n-#define CH_IS_ASSOCIATION_MODE(MODE)   (CH_SIMILAR (MODE, association_type_node))\n-#define CH_IS_USAGE_MODE(MODE)         (CH_SIMILAR (MODE, usage_type_node))\n-#define CH_IS_WHERE_MODE(MODE)         (CH_SIMILAR (MODE, where_type_node))\n-\n-/* for RECORD or ARRAY type */\n-#define CH_TYPE_NONVALUE_P(MODE)       (TYPE_LANG_FLAG_0(MODE))\n-\n-/* CH_NOVELTY is the novelty of a mode:  NULL_TREE means the novelty is nil;\n-   otherwise a TYPE_DECL matching the defining occurrence of a newmode. */\n-#define CH_NOVELTY(MODE)           TYPE_CONTEXT(MODE)\n-\n-/* Set the novelty of MODE to NOVELTY (which is assumed to be non-nil). */\n-#define SET_CH_NOVELTY(MODE, NOVELTY) (CH_NOVELTY (MODE) = (NOVELTY))\n-#define SET_CH_NOVELTY_NONNIL(MODE, NOVELTY) (CH_NOVELTY (MODE) = (NOVELTY))\n-\n-/* CH_DERIVED_FLAG is true the class of EXPR is X-derived for some X. */\n-#define CH_DERIVED_FLAG(EXPR) TREE_LANG_FLAG_5(EXPR)\n-\n-#define CH_HAS_REFERENCING_PROPERTY(MODE) \\\n-  (TREE_CODE (MODE) == POINTER_TYPE) /* incomplete FIXME! */\n-\n-/* CH_COMPATIBLE(EXPR, MODE) is true if the class of EXPR is\n-   \"compatible\" with the type MODE. */\n-#define CH_COMPATIBLE(EXPR, MODE)           chill_compatible(EXPR, MODE)\n-#define CH_COMPATIBLE_CLASSES(EXPR1, EXPR2) chill_compatible_classes(EXPR1, EXPR2)\n-#define CH_STATIC_MODE(MODE)                  1 /* for now */\n-#define CH_SIMILAR(MODE1, MODE2)              chill_similar(MODE1, MODE2, 0)\n-#define CH_ROOT_MODE(MODE) chill_root_mode(MODE)\n-#define CH_RESULTING_CLASS(C1, C2) chill_resulting_class(C1, C2)\n-#define CH_ROOT_RESULTING_CLASS(E1, E2) \\\n-  CH_RESULTING_CLASS (chill_expr_class(E1), chill_expr_class(E2))\n-#define CH_RESULTING_MODE(MODE1, MODE2) chill_resulting_mode(MODE1, MODE2)\n-#define CH_V_EQUIVALENT(MODE1, MODE2) (CH_SIMILAR(MODE1, MODE2) \\\n-   && CH_NOVELTY(MODE1) == CH_NOVELTY(MODE2))\n-#define CH_EQUIVALENT(MODE1, MODE2) \\\n-  (!integer_zerop (chill_equivalent (MODE1, MODE2, 0)))\n-#define CH_RESTRICTABLE_TO(MODE1, MODE2)  \\\n-    CH_EQUIVALENT(MODE1, MODE2) /* && some more stuff FIXME! */\n-\n-/* pass an OFFSET_TYPE or REFERENCE_TYPE's underlying type to SCALAR_P */\n-#define CH_READ_COMPATIBLE(modeM, modeN) chill_read_compatible(modeM, modeN)\n-\n-#define SCALAR_P(TYPE) (TYPE != NULL_TREE \\\n-\t\t\t&& (TREE_CODE (TYPE) == INTEGER_TYPE \\\n-\t\t\t    || TREE_CODE (TYPE) == REAL_TYPE \\\n-\t\t\t    || TREE_CODE (TYPE) == ENUMERAL_TYPE \\\n-\t\t\t    || TREE_CODE (TYPE) == BOOLEAN_TYPE \\\n-\t\t\t    || TREE_CODE (TYPE) == CHAR_TYPE \\\n-\t\t\t    || TREE_CODE (TYPE) == POINTER_TYPE \\\n-\t\t\t    || TREE_CODE (TYPE) == INSTANCE_TYPE))\n-#define CH_REFERABLE(EXPR) chill_referable(EXPR)\n-#define CH_LOCATION_P(EXPR) chill_location (EXPR)\n-\f\n-/* Standard named or nameless data types of the C compiler.  */\n-\n-/* Nonzero means `$' can be in an identifier.  */\n-\n-extern int dollars_in_ident;\n-\n-/* Nonzero means allow type mismatches in conditional expressions;\n-   just make their values `void'.   */\n-\n-extern int flag_cond_mismatch;\n-\n-/* Nonzero means don't recognize the keyword `asm'.  */\n-\n-extern int flag_no_asm;\n-\n-/* Nonzero means warn about implicit declarations.  */\n-\n-extern int warn_implicit;\n-\n-/* Nonzero means give string constants the type `const char *'\n-   to get extra warnings from them.  These warnings will be too numerous\n-   to be useful, except in thoroughly ANSIfied programs.  */\n-\n-extern int warn_write_strings;\n-\n-/* Nonzero means warn about sizeof (function) or addition/subtraction\n-   of function pointers.  */\n-\n-extern int warn_pointer_arith;\n-\n-/* Nonzero means warn for all old-style non-prototype function decls.  */\n-\n-extern int warn_strict_prototypes;\n-\n-/* Nonzero means warn about multiple (redundant) decls for the same single\n-   variable or function.  */\n-\n-extern int warn_redundant_decls;\n-\n-/* Nonzero means warn about extern declarations of objects not at\n-   file-scope level and about *all* declarations of functions (whether\n-   extern or static) not at file-scope level.  Note that we exclude\n-   implicit function declarations.  To get warnings about those, use\n-   -Wimplicit.  */\n-\n-extern int warn_nested_externs;\n-\n-/* Nonzero means warn about pointer casts that can drop a type qualifier\n-   from the pointer target type.  */\n-\n-extern int warn_cast_qual;\n-\n-/* Warn about *printf or *scanf format/argument anomalies. */\n-\n-extern int warn_format;\n-\n-/* Warn about a subscript that has type char.  */\n-\n-extern int warn_char_subscripts;\n-\n-/* Warn if a type conversion is done that might have confusing results.  */\n-\n-extern int warn_conversion;\n-\n-/* Warn if switch labels aren't complete, or are duplicated */\n-\n-extern int warn_switch;\n-\n-/* Nonzero means warn about suggesting putting in ()'s.  */\n-\n-extern int warn_parentheses;\n-\n-/* Nonzero means we are reading code that came from a system header file.  */\n-extern int system_header_p;\n-\n-/* One means range checking is on; <= 0 off; -1 permanently off. */\n-extern int range_checking;\n-\n-/* 0 means empty checking is off, else it is on */\n-extern int empty_checking;\n-\n-/* 1 means -fruntime-checking specified (default), o means -fno-runtime-checking */\n-extern int runtime_checking_flag;\n-\n-/* Type node for boolean types.  */\n-\n-extern tree boolean_type_node;\n-extern tree signed_boolean_type_node;\n-\n-extern tree string_one_type_node;\n-extern tree bitstring_one_type_node, bit_zero_node, bit_one_node;\n-\n-/* a VOID_TYPE node, packaged in a TREE_LIST.  */\n-\n-extern tree void_list_node;\n-\n-/* Chill language-specific tree codes.  */\n-#define DEFTREECODE(SYM, NAME, TYPE, LENGTH) SYM,\n-enum chill_tree_code {\n-  __DUMMY = LAST_AND_UNUSED_TREE_CODE,\n-#include \"ch-tree.def\"\n-  LAST_CHILL_TREE_CODE\n-};\n-#undef DEFTREECODE\n-\n-enum chill_built_in_function\n-{\n-  DUMMY_FIRST_CHILL_BUILT_IN = END_BUILTINS,\n-\n-  BUILT_IN_CH_ABS,\n-  BUILT_IN_ABSTIME,\n-  BUILT_IN_ADDR,\n-  BUILT_IN_ALLOCATE,\n-  BUILT_IN_ALLOCATE_GLOBAL_MEMORY,\n-  BUILT_IN_ALLOCATE_MEMORY,\n-  BUILT_IN_ARCCOS,\n-  BUILT_IN_ARCSIN,\n-  BUILT_IN_ARCTAN,\n-  BUILT_IN_ASSOCIATE,\n-  BUILT_IN_CARD,\n-  BUILT_IN_CONNECT,\n-  BUILT_IN_COPY_NUMBER,\n-  BUILT_IN_CH_COS,\n-  BUILT_IN_CREATE,\n-  BUILT_IN_DAYS,\n-  BUILT_IN_CH_DELETE,\n-  BUILT_IN_DESCR,\n-  BUILT_IN_DISCONNECT,\n-  BUILT_IN_DISSOCIATE,\n-  BUILT_IN_EOLN,\n-  BUILT_IN_EXP,\n-  BUILT_IN_EXPIRED,\n-  BUILT_IN_EXISTING,\n-  BUILT_IN_GEN_CODE,\n-  BUILT_IN_GEN_INST,\n-  BUILT_IN_GEN_PTYPE,\n-  BUILT_IN_GETASSOCIATION,\n-  BUILT_IN_GETSTACK,\n-  BUILT_IN_GETTEXTACCESS,\n-  BUILT_IN_GETTEXTINDEX,\n-  BUILT_IN_GETTEXTRECORD,\n-  BUILT_IN_GETUSAGE,\n-  BUILT_IN_HOURS,\n-  BUILT_IN_INDEXABLE,\n-  BUILT_IN_INTTIME,\n-  BUILT_IN_ISASSOCIATED,\n-  BUILT_IN_LENGTH,\n-  BUILT_IN_LOG,\n-  BUILT_IN_LOWER,\n-  BUILT_IN_LN,\n-  BUILT_IN_MAX,\n-  BUILT_IN_MILLISECS,\n-  BUILT_IN_MIN,\n-  BUILT_IN_MINUTES,\n-  BUILT_IN_MODIFY,\n-  BUILT_IN_NUM,\n-  BUILT_IN_OUTOFFILE,\n-  BUILT_IN_PRED,\n-  BUILT_IN_PROC_TYPE,\n-  BUILT_IN_QUEUE_LENGTH,\n-  BUILT_IN_READABLE,\n-  BUILT_IN_READRECORD,\n-  BUILT_IN_READTEXT,\n-  BUILT_IN_RETURN_MEMORY,\n-  BUILT_IN_SECS,\n-  BUILT_IN_SETTEXTACCESS,\n-  BUILT_IN_SETTEXTINDEX,\n-  BUILT_IN_SETTEXTRECORD,\n-  BUILT_IN_SEQUENCIBLE,\n-  BUILT_IN_SIZE,\n-  BUILT_IN_SQRT,\n-  BUILT_IN_SUCC,\n-  BUILT_IN_CH_SIN,\n-  BUILT_IN_TAN,\n-  BUILT_IN_TRUNC,\n-  BUILT_IN_TERMINATE,\n-  BUILT_IN_UPPER,\n-  BUILT_IN_VARIABLE,\n-  BUILT_IN_WAIT,\n-  BUILT_IN_WRITEABLE,\n-  BUILT_IN_WRITERECORD,\n-  BUILT_IN_WRITETEXT,\n-};\n-\f\n-/* name of additional (compiler generated) arguments for\n-   functions which may propagate exceptions. */\n-#define CALLER_FILE \"__CALLER_FILE__\"\n-#define CALLER_LINE \"__CALLER_LINE__\"\n-\n-/* field-name strings for the fields of the structure which\n-   represents a CHILL VARYING array.  The angle brackets assure\n-   that no user-defined structure can match this one.\n-   This field holds, at runtime, the current length of the\n-   array, in UNITS, not including the length itself. It's an\n-   integer_type_node */\n-#define VAR_LENGTH \"__var_length\"\n-\n-/* This field is statically allocated to the user-defined\n-   size, but contains valid array entries starting from the\n-   first allocated space, proceeding for VAR_LENGTH bytes.\n-   There are no holes in the data;  the user isn't allowed\n-   to store beyond the first available entry. */\n-\n-#define VAR_DATA \"__var_data\"\n-\n-/* This field is the name of the array, encapsulated in the CHILL\n-   structure used to represent an array type parameter. */\n-/*#define ARRAY_DATA \"__array_data\"*/\n-\n-/* The CHILL INSTANCE type is composed of two CHILL integer\n-   fields, the process_type (set by the user with the \n-   process_type compiler directive, and the proc_copy field,\n-   which is set by the start_process call's first parameter. */\n-#define INS_PTYPE \"__proc_type\"\n-#define INS_COPY  \"__proc_copy\"\n-\n-/* This is the actual array type inside the VARYING struct */\n-#define CH_VARYING_ARRAY_TYPE(TYPE) TREE_TYPE (TREE_CHAIN (TYPE_FIELDS (TYPE)))\n-\n-/* Identifiers which hold the VAR_LENGTH and VAR_DATA strings.  */\n-extern tree var_length_id;\n-extern tree var_data_id;\n-\n-/* A RANGE_EXPR representing an ELSE in a case label. */\n-extern tree case_else_node;\n-\n-#if 0   /* changed to function */\n-/* return non-zero if type is a compiler-generated VARYING array record */\n-#define CH_VARYING_TYPE_P(type) (TREE_CODE (type) == RECORD_TYPE && \\\n-                           DECL_NAME (TYPE_FIELDS (type)) == \\\n-                                      get_identifier (VAR_LENGTH) && \\\n-                           DECL_NAME (TREE_CHAIN (TYPE_FIELDS (type))) == \\\n-                                      get_identifier (VAR_DATA) && \\\n-                   TREE_CHAIN (CH_VARYING_ARRAY_TYPE (type)) == NULL_TREE)\n-\n-#endif\n-\n-/* in c-aux-info.c */\n-extern void gen_aux_info_record                 PARAMS ((tree, int, int, int));\n-\n-/* in c-common.c */\n-extern tree combine_strings                     PARAMS ((tree));\n-extern void constant_expression_warning         PARAMS ((tree));\n-extern void decl_attributes                     PARAMS ((tree, tree));\n-extern void declare_function_name               PARAMS ((void));\n-#ifdef BUFSIZ\n-extern char *get_directive_line                 PARAMS ((FILE *));\n-#endif\n-extern tree shorten_compare                     PARAMS ((tree *, tree *, tree *, enum tree_code *));\n-\n-/* in c-decl.c */\n-extern tree wchar_type_node, signed_wchar_type_node, unsigned_wchar_type_node;\n-extern tree default_function_type;\n-extern tree double_ftype_double, double_ftype_double_double;\n-extern tree int_ftype_int, long_ftype_long;\n-extern tree void_ftype_ptr_ptr_int, int_ftype_ptr_ptr_int;\n-extern tree void_ftype_ptr_int_int, string_ftype_ptr_ptr;\n-extern tree int_ftype_string_string, int_ftype_cptr_cptr_sizet;\n-/* Nodes for boolean constants TRUE and FALSE */\n-extern tree boolean_true_node, boolean_false_node;\n-\n-extern tree global_function_decl;\n-\n-/* in except.c */\n-extern void except_init_pass_2                  PARAMS ((void));\n-extern void push_handler\t\t\tPARAMS ((void));\n-extern void pop_handler\t\t\t\tPARAMS ((int));\n-\n-/* in ch-loop.c */\n-extern int flag_local_loop_counter;\n-extern void push_loop_block                     PARAMS ((void));\n-extern void pop_loop_block                      PARAMS ((void));\n-extern void build_loop_start                    PARAMS ((tree));\n-extern void top_loop_end_check\t\t\tPARAMS ((tree));\n-extern void build_loop_end                      PARAMS ((void));\n-extern void build_loop_iterator                 PARAMS ((tree, tree, tree, tree, int, int, int));\n-extern void begin_loop_scope                    PARAMS ((void));\n-extern void end_loop_scope                      PARAMS ((tree));\n-extern void nonvalue_begin_loop_scope           PARAMS ((void));\n-extern void nonvalue_end_loop_scope             PARAMS ((void));\n-\n-extern tree build_enumerator                    PARAMS ((tree, tree));\n-extern tree c_build_type_variant                PARAMS ((tree, int, int));\n-extern int  c_decode_option                     PARAMS ((int, char **));\n-extern void c_mark_varargs                      PARAMS ((void));\n-extern void clear_parm_order                    PARAMS ((void));\n-extern int  complete_array_type                 PARAMS ((tree, tree, int));\n-extern void declare_parm_level                  PARAMS ((int));\n-extern tree define_label                        PARAMS ((const char *, int, tree));\n-extern void delete_block                        PARAMS ((tree));\n-extern void finish_decl                         PARAMS ((tree));\n-extern tree finish_enum                         PARAMS ((tree, tree));\n-extern void finish_function                     PARAMS ((int));\n-extern tree finish_struct                       PARAMS ((tree, tree));\n-extern tree get_parm_decls                      PARAMS ((void));\n-extern tree get_parm_info                       PARAMS ((int));\n-extern tree getdecls                            PARAMS ((void));\n-extern tree gettags                             PARAMS ((void));\n-extern int  global_bindings_p                   PARAMS ((void));\n-extern tree grokfield                           PARAMS ((char *, int, tree, tree, tree));\n-extern tree groktypename                        PARAMS ((tree));\n-extern tree groktypename_in_parm_context        PARAMS ((tree));\n-extern tree implicitly_declare                  PARAMS ((tree));\n-extern void init_decl_processing                PARAMS ((void));\n-extern void insert_block                        PARAMS ((tree));\n-extern void keep_next_level                     PARAMS ((void));\n-extern int  kept_level_p                        PARAMS ((void));\n-extern tree lookup_label                        PARAMS ((tree));\n-extern tree lookup_name                         PARAMS ((tree));\n-extern tree maybe_build_cleanup                 PARAMS ((tree));\n-extern void parmlist_tags_warning               PARAMS ((void));\n-extern void pending_xref_error                  PARAMS ((void));\n-extern void pop_chill_function_context          PARAMS ((void));\n-extern tree poplevel                            PARAMS ((int, int, int));\n-#ifdef BUFSIZ\n-extern void print_lang_decl                     PARAMS ((FILE *,tree, int));\n-extern void print_lang_identifier               PARAMS ((FILE *,tree, int));\n-extern void print_lang_type                     PARAMS ((FILE *,tree, int));\n-#endif\n-extern void push_chill_function_context         PARAMS ((void));\n-extern void push_parm_decl                      PARAMS ((tree));\n-extern tree pushdecl                            PARAMS ((tree));\n-extern tree pushdecl_top_level                  PARAMS ((tree));\n-extern void pushlevel                           PARAMS ((int));\n-extern void set_block                           PARAMS ((tree));\n-extern tree shadow_label                        PARAMS ((tree));\n-extern void shadow_record_fields                PARAMS ((tree));\n-extern void shadow_tag                          PARAMS ((tree));\n-extern void shadow_tag_warned                   PARAMS ((tree, int));\n-extern tree start_enum                          PARAMS ((tree));\n-extern int  start_function                      PARAMS ((tree, tree, int));\n-extern tree start_decl                          PARAMS ((tree, tree, int));\n-extern tree start_struct                        PARAMS ((enum tree_code, tree));\n-extern void store_parm_decls                    PARAMS ((void));\n-extern tree xref_tag                            PARAMS ((enum tree_code, tree));\n-\n-/* in c-typeck.c */\n-extern tree build_array_ref                     PARAMS ((tree, tree));\n-extern tree build_c_cast                        PARAMS ((tree, tree));\n-extern tree build_chill_modify_expr             PARAMS ((tree, tree));\n-extern tree build_chill_component_ref           PARAMS ((tree, tree));\n-extern tree build_component_ref                 PARAMS ((tree, tree));\n-extern tree build_compound_expr                 PARAMS ((tree));\n-extern tree build_conditional_expr              PARAMS ((tree, tree, tree));\n-extern tree build_function_call                 PARAMS ((tree, tree));\n-extern tree build_indirect_ref                  PARAMS ((tree, char *));\n-extern tree build_modify_expr                   PARAMS ((tree, enum tree_code, tree));\n-extern tree build_unary_op                      PARAMS ((enum tree_code, tree, int));\n-extern tree c_alignof                           PARAMS ((tree));\n-extern tree c_alignof_expr                      PARAMS ((tree));\n-extern void c_expand_asm_operands               PARAMS ((tree, tree, tree, tree, int, char *, int));\n-extern tree c_sizeof                            PARAMS ((tree));\n-extern void c_expand_return                     PARAMS ((tree));\n-extern tree c_expand_start_case                 PARAMS ((tree));\n-extern tree common_type                         PARAMS ((tree, tree));\n-extern tree copy_novelty                        PARAMS ((tree, tree));\n-extern tree default_conversion                  PARAMS ((tree));\n-extern void finish_init                         PARAMS ((void));\n-extern tree parser_build_binary_op              PARAMS ((enum tree_code, tree, tree));\n-extern tree pop_init_level                      PARAMS ((int));\n-extern void process_init_default                PARAMS ((tree));\n-extern void process_init_element                PARAMS ((tree));\n-extern void push_init_level                     PARAMS ((int));\n-extern void really_start_incremental_init       PARAMS ((tree));\n-extern void set_init_index                      PARAMS ((tree, tree));\n-extern void set_init_label                      PARAMS ((tree));\n-extern void start_init                          PARAMS ((tree, tree, int));\n-extern void store_init_value                    PARAMS ((tree, tree));\n-extern tree valid_array_index_p                 PARAMS ((tree, tree, const char *, int));\n-\n-/* in ch/actions.c */\n-extern int grant_only_flag;\n-extern void allocate_lang_decl                  PARAMS ((tree));\n-extern tree build_chill_abs                     PARAMS ((tree));\n-extern tree build_chill_array_ref_1             PARAMS ((tree, tree));\n-extern tree build_chill_array_ref               PARAMS ((tree, tree));\n-extern tree build_chill_bin_type                PARAMS ((tree));\n-extern tree build_chill_binary_op               PARAMS ((enum chill_tree_code, tree, tree));\n-extern tree build_chill_card                    PARAMS ((tree));\n-extern tree build_chill_case_expr               PARAMS ((tree, tree, tree)); \n-extern tree build_cause_exception               PARAMS ((tree, int));\n-extern tree build_chill_exception_decl          PARAMS ((const char *));\n-extern tree build_chill_function_call           PARAMS ((tree, tree));\n-extern tree build_chill_length                  PARAMS ((tree));\n-extern tree build_chill_indirect_ref            PARAMS ((tree, tree, int));\n-extern tree build_chill_lower                   PARAMS ((tree));\n-extern tree build_chill_max                     PARAMS ((tree));\n-extern tree build_chill_min                     PARAMS ((tree));\n-extern tree build_chill_num                     PARAMS ((tree));\n-extern tree build_chill_repetition_op           PARAMS ((tree, tree));\n-extern tree build_chill_sizeof                  PARAMS ((tree));\n-extern tree build_chill_slice\t\t        PARAMS ((tree, tree, tree));\n-extern tree build_chill_slice_with_range        PARAMS ((tree, tree, tree));\n-extern tree build_chill_slice_with_length       PARAMS ((tree, tree, tree));\n-extern tree build_chill_struct_type             PARAMS ((tree));\n-extern tree build_chill_unary_op                PARAMS ((enum chill_tree_code, tree));\n-extern tree build_chill_upper                   PARAMS ((tree));\n-extern tree build_exception_variant             PARAMS ((tree, tree));\n-extern tree build_generalized_call              PARAMS ((tree, tree));\n-extern tree build_lang_decl                     PARAMS ((enum chill_tree_code, tree, tree));\n-extern tree build_rts_call                      PARAMS ((const char *, tree, tree));\n-extern tree build_varying_struct                PARAMS ((tree));\n-extern void chill_check_decl                    PARAMS ((tree));\n-extern tree chill_convert_for_assignment        PARAMS ((tree, tree, const char *));\n-extern void chill_expand_return                 PARAMS ((tree, int));\n-extern void chill_expand_result                 PARAMS ((tree, int));\n-extern void chill_handle_case_default           PARAMS ((void));\n-extern void chill_handle_case_label\t\tPARAMS ((tree, tree));\n-extern int  chill_varying_string_type_p         PARAMS ((tree));\n-extern int  chill_varying_type_p                PARAMS ((tree));\n-extern int  ch_singleton_set                    PARAMS ((tree));\n-extern tree check_expression                    PARAMS ((tree, tree, tree));\n-extern void check_missing_cases                 PARAMS ((tree));\n-extern tree check_non_null                      PARAMS ((tree));\n-extern tree check_range                         PARAMS ((tree, tree, tree,tree));\n-extern void cond_type_range_exception           PARAMS ((tree));\n-extern void expand_cause_exception              PARAMS ((tree));\n-extern tree finish_chill_binary_op              PARAMS ((tree));\n-extern tree finish_chill_unary_op               PARAMS ((tree));\n-extern tree high_domain_value                   PARAMS ((tree));\n-extern tree low_domain_value                    PARAMS ((tree));\n-extern tree maybe_array_ref\t\t\tPARAMS ((tree, tree));\n-extern void maybe_chill_check_decl              PARAMS ((tree));\n-extern tree powersetlen                         PARAMS ((tree));\n-extern tree test_range                          PARAMS ((tree, tree, tree));\n-/* in ch/convert.c */\n-extern tree build_array_type_for_scalar         PARAMS ((tree));\n-extern tree convert                             PARAMS ((tree, tree));\n-extern tree convert_from_reference              PARAMS ((tree));\n-extern tree convert_to_class                    PARAMS ((ch_class, tree));\n-extern const char *display_int_cst\t\tPARAMS ((tree));\n-\n-/* in ch/decl.c */\n-extern tree build_enumerator\t\t        PARAMS ((tree, tree));\n-extern tree chill_munge_params                  PARAMS ((tree, tree, tree));\n-extern tree build_chill_function_type           PARAMS ((tree, tree, tree, tree));\n-extern tree decl_temp1                          PARAMS ((tree, tree, int, tree, int, int));\n-extern void do_based_decls                      PARAMS ((tree, tree, tree));\n-extern void do_chill_outparms                   PARAMS ((void));\n-extern tree do_decl                             PARAMS ((tree, tree, int, int, tree, int));\n-extern void do_decls                            PARAMS ((tree, tree, int, int, tree, int));\n-extern void expand_chill_outparms               PARAMS ((void));\n-extern void find_granted_decls\t\t        PARAMS ((void));\n-extern void finish_chill_function               PARAMS ((void));\n-extern tree finish_enum\t\t                PARAMS ((tree, tree));\n-extern void fixup_chill_parms                   PARAMS ((tree));\n-extern void finish_outer_function               PARAMS ((void));\n-extern unsigned get_type_precision              PARAMS ((tree, tree));\n-extern tree grok_chill_fixedfields              PARAMS ((tree, tree, tree));\n-extern tree grok_chill_variantdefs              PARAMS ((tree, tree, tree));\n-extern void layout_enum                         PARAMS ((tree));\n-/* extern tree lookup_remembered_decl PARAMS ((HOST_WIDE_INT, tree)); */\n-extern void lookup_and_expand_goto\t\tPARAMS ((tree));\n-extern tree lookup_tag_fields\t\t        PARAMS ((tree, tree));\n-extern void lookup_and_handle_exit              PARAMS ((tree));\n-extern tree massage_param_node\t\t\tPARAMS ((tree, tree));\n-extern void pop_module                          PARAMS ((void));\n-extern void print_mode                          PARAMS ((tree));\n-extern tree push_extern_function                PARAMS ((tree, tree, tree, tree, int));\n-extern void push_extern_process                 PARAMS ((tree, tree, tree, int));\n-extern void push_extern_signal                  PARAMS ((tree, tree, tree));\n-extern void push_granted                        PARAMS ((tree, tree));\n-extern tree push_modedef                        PARAMS ((tree, tree, int));\n-extern tree push_module                         PARAMS ((tree, int));\n-extern void push_parms                          PARAMS ((tree, tree, tree));\n-extern void push_syndecl                        PARAMS ((tree, tree, tree));\n-extern int result_never_set;\n-extern void save_expr_under_name                PARAMS ((tree, tree));\n-extern tree set_module_name                     PARAMS ((tree));\n-extern int  start_chill_function                PARAMS ((tree, tree, tree, tree, tree));\n-extern void start_outer_function\t        PARAMS ((void));\n-extern void switch_to_pass_2 \t                PARAMS ((void));\n-\n-/* in ch/except.c */\n-extern void chill_check_no_handlers             PARAMS ((void));\n-extern void chill_finish_on                     PARAMS ((void));\n-extern void chill_handle_on_labels              PARAMS ((tree));\n-extern void chill_reraise_exceptions            PARAMS ((tree));\n-extern void chill_start_default_handler         PARAMS ((void));\n-extern void chill_start_on                      PARAMS ((void));\n-extern void expand_goto_except_cleanup          PARAMS ((int));\n-extern int is_handled\t\t\t\tPARAMS ((tree));\n-\n-/* in ch/expr.c */\n-extern tree build_chill_addr_expr               PARAMS ((tree, const char *));\n-extern tree build_chill_arrow_expr              PARAMS ((tree, int));\n-extern tree build_component_ref\t\t        PARAMS ((tree, tree));\n-extern tree build_chill_compound_expr           PARAMS ((tree));\n-extern tree build_chill_descr                   PARAMS ((tree));\n-extern void build_chill_descr_type              PARAMS ((void));\n-extern void build_chill_inttime_type            PARAMS ((void));\n-extern tree build_compare_expr\t\t\tPARAMS ((enum tree_code,\n-\t\t\t\t\t\t       tree, tree));\n-extern tree build_compare_discrete_expr\t\tPARAMS ((enum tree_code,\n-\t\t\t\t\t\t       tree, tree));\n-extern tree check_case_selector                 PARAMS ((tree));\n-extern tree check_case_selector_list            PARAMS ((tree));\n-extern tree check_have_mode                     PARAMS ((tree, const char *));\n-extern void init_chill_expand                   PARAMS ((void));\n-extern void chill_expand_assignment             PARAMS ((tree, enum chill_tree_code, tree));\n-extern void expand_assignment_action            PARAMS ((tree, enum chill_tree_code, tree));\n-extern int compare_int_csts\t\t\tPARAMS ((enum chill_tree_code,\n-\t\t\t\t\t\t       tree, tree));\n-extern void expand_varying_length_assignment    PARAMS ((tree, tree));\n-extern tree force_addr_of\t\t\tPARAMS ((tree));\n-extern tree resolve_component_ref               PARAMS ((tree));\n-extern tree truthvalue_conversion               PARAMS ((tree));\n-extern tree varying_to_slice\t\t        PARAMS ((tree));\n-\n-/* in ch/grant.c */\n-extern void chill_finish_compile                PARAMS ((void));\n-extern void chill_seize                         PARAMS ((tree, tree, tree));\n-extern void start_outer_function\t        PARAMS ((void));\n-extern void finish_chill_seize                  PARAMS ((tree));\n-extern void chill_grant                         PARAMS ((tree,tree, tree, tree));\n-extern void set_default_grant_file              PARAMS ((void));\n-extern void set_identifier_size                 PARAMS ((int));\n-extern void write_grant_file                    PARAMS ((void));\n-extern void write_spec_module                   PARAMS ((tree, tree));\n-\n-/* in ch/lang.c */\n-extern tree string_index_type_dummy;\n-extern int  flag_old_strings;\n-extern void GNU_xref_begin                      PARAMS ((void));\n-extern void GNU_xref_end                        PARAMS ((void));\n-extern tree build_chill_array_type              PARAMS ((tree, tree, int, tree));\n-extern tree build_chill_struct_type             PARAMS ((tree));\n-extern tree build_chill_pointer_type            PARAMS ((tree));\n-extern tree build_chill_range_type              PARAMS ((tree, tree, tree));\n-extern tree build_chill_reference_type          PARAMS ((tree));\n-extern tree build_simple_array_type             PARAMS ((tree, tree, tree));\n-extern tree const_expr                          PARAMS ((tree));\n-extern tree get_identifier3\t\t\tPARAMS ((const char *, const char *, const char *));\n-extern tree layout_chill_array_type             PARAMS ((tree));\n-extern tree layout_chill_range_type             PARAMS ((tree, int));\n-extern tree layout_chill_pointer_type           PARAMS ((tree));\n-extern tree layout_chill_struct_type            PARAMS ((tree));\n-extern tree layout_chill_variants               PARAMS ((tree));\n-extern tree layout_powerset_type                PARAMS ((tree));\n-extern tree lookup_interface                    PARAMS ((tree));\n-extern tree maybe_building_objc_message_expr    PARAMS ((void));\n-extern void maybe_objc_check_decl               PARAMS ((tree));\n-extern int  maybe_objc_comptypes                PARAMS ((tree, tree));\n-extern int  recognize_objc_keyword              PARAMS ((void));\n-\n-/* in ch/lex.l */\n-extern tree use_seizefile_name;\n-extern tree current_seizefile_name;\n-extern tree build_chill_string                  PARAMS ((int, const char *));\n-extern int  check_newline                       PARAMS ((void));\n-extern tree get_chill_filename                  PARAMS ((void)); \n-extern tree get_chill_linenumber                PARAMS ((void));       \n-extern void register_seize_path                 PARAMS ((const char *));\n-extern void reinit_parse_for_function           PARAMS ((void));\n-extern void mark_use_seizefile_written          PARAMS ((tree));\n-\n-/* in ch/loop.c */\n-extern void begin_chill_loop                    PARAMS ((tree, tree));\n-extern tree build_chill_iterator                PARAMS ((tree, tree, tree, int, int, int));\n-extern void end_chill_loop                      PARAMS ((void));\n-extern tree get_unique_identifier               PARAMS ((const char *));\n-\n-/* in ch/inout.c */\n-extern tree access_recordmode                   PARAMS ((tree));\n-extern void invalidate_access_recordmode        PARAMS ((tree));\n-extern tree access_indexmode                    PARAMS ((tree));\n-extern tree access_dynamic                      PARAMS ((tree));\n-extern tree association_init_value;\n-extern tree association_type_node;\n-extern tree build_access_mode                   PARAMS ((tree, tree, int));\n-extern tree build_chill_associate               PARAMS ((tree, tree, tree));\n-extern tree build_chill_connect                 PARAMS ((tree, tree, tree, tree));\n-extern tree build_chill_create                  PARAMS ((tree));\n-extern tree build_chill_delete                  PARAMS ((tree));\n-extern tree build_chill_disconnect              PARAMS ((tree));\n-extern tree build_chill_dissociate              PARAMS ((tree));\n-extern tree build_chill_eoln                    PARAMS ((tree)); \n-extern tree build_chill_existing                PARAMS ((tree));\n-extern tree build_chill_gettextaccess           PARAMS ((tree)); \n-extern tree build_chill_getassociation          PARAMS ((tree)); \n-extern tree build_chill_gettextindex            PARAMS ((tree)); \n-extern tree build_chill_gettextrecord           PARAMS ((tree)); \n-extern tree build_chill_getusage                PARAMS ((tree)); \n-extern tree build_chill_indexable               PARAMS ((tree)); \n-extern tree build_chill_isassociated            PARAMS ((tree)); \n-extern tree build_chill_modify                  PARAMS ((tree, tree));\n-extern tree build_chill_outoffile               PARAMS ((tree)); \n-extern tree build_chill_readable                PARAMS ((tree));\n-extern tree build_chill_readrecord              PARAMS ((tree, tree));\n-extern tree build_chill_readtext                PARAMS ((tree, tree));\n-extern tree build_chill_sequencible             PARAMS ((tree)); \n-extern tree build_chill_settextaccess           PARAMS ((tree, tree));\n-extern tree build_chill_settextindex            PARAMS ((tree, tree));\n-extern tree build_chill_settextrecord           PARAMS ((tree, tree));\n-extern tree build_chill_variable                PARAMS ((tree)); \n-extern tree build_chill_writeable               PARAMS ((tree));\n-extern tree build_chill_writerecord             PARAMS ((tree, tree));\n-extern tree build_chill_writetext               PARAMS ((tree, tree));\n-extern void build_enum_tables                   PARAMS ((void));\n-extern tree build_text_mode                     PARAMS ((tree, tree, int));\n-extern tree check_text_length                   PARAMS ((tree));\n-extern void init_access_location                PARAMS ((tree, tree));\n-extern void init_text_location                  PARAMS ((tree, tree));\n-extern void inout_init                          PARAMS ((void));\n-extern tree text_dynamic                        PARAMS ((tree));\n-extern tree text_indexmode                      PARAMS ((tree));\n-extern tree text_length                         PARAMS ((tree));\n-extern tree usage_type_node;\n-extern tree where_type_node;\n-\n-/* in ch/parse.c */\n-extern tree get_type_of                         PARAMS ((tree));\n-extern void set_yydebug                         PARAMS ((int));\n-extern void yyerror                             PARAMS ((char *));\n-extern int  pass;\n-extern int ignoring;\n-extern int seen_action;\n-extern int build_constructor;\n-extern void possibly_define_exit_label          PARAMS ((tree));\n-extern void to_global_binding_level             PARAMS ((void));\n-\n-/* in ch/satisfy.c */\n-extern tree satisfy_decl \t                PARAMS ((tree, int));\n-\n-/* in ch/tasking.c */\n-extern void add_taskstuff_to_list               PARAMS ((tree, const char *, tree, tree, tree));\n-extern void process_buffer_decls                PARAMS ((tree, tree, int));\n-extern tree buffer_element_mode                 PARAMS ((tree));\n-extern void invalidate_buffer_element_mode      PARAMS ((tree));\n-extern tree build_buffer_descriptor             PARAMS ((tree, tree, tree));\n-extern tree build_buffer_type                   PARAMS ((tree, tree));\n-extern void build_delay_action                  PARAMS ((tree, tree));\n-extern tree build_delay_case_start              PARAMS ((tree, tree));\n-extern void build_delay_case_end                PARAMS ((tree));\n-extern void build_delay_case_label              PARAMS ((tree, int));\n-extern tree build_event_type                    PARAMS ((tree));\n-extern void build_receive_case_end              PARAMS ((tree, tree));\n-extern int  build_receive_case_if_generated     PARAMS ((void));\n-extern tree build_receive_case_label            PARAMS ((tree, tree));\n-extern tree build_receive_case_start            PARAMS ((tree));\n-extern void expand_continue_event               PARAMS ((tree));\n-extern void expand_send_buffer                  PARAMS ((tree, tree, tree, tree, tree));\n-extern void expand_send_signal                  PARAMS ((tree, tree, tree, tree, tree));\n-extern void build_start_process                 PARAMS ((tree, tree, tree, tree));\n-extern tree build_copy_number                   PARAMS ((tree));\n-extern tree build_gen_code                      PARAMS ((tree));\n-extern tree build_gen_inst                      PARAMS ((tree, tree));\n-extern tree build_gen_ptype                     PARAMS ((tree));\n-extern void build_instance_type                 PARAMS ((void));\n-extern tree build_process_header                PARAMS ((tree, tree));\n-extern void build_process_wrapper               PARAMS ((tree, tree));\n-extern tree build_proc_type                     PARAMS ((tree));\n-extern tree build_queue_length                  PARAMS ((tree));\n-extern tree build_signal_descriptor             PARAMS ((tree, tree));\n-extern tree build_signal_struct_type            PARAMS ((tree, tree, tree));\n-extern tree build_tasking_struct                PARAMS ((void));\n-extern tree chill_taskingcode_type_node;\n-extern tree check_queue_size                    PARAMS ((tree));\n-extern tree generate_tasking_code_variable      PARAMS ((tree, tree *, int));\n-extern tree get_signal_type_name                PARAMS ((tree));\n-extern tree get_struct_type_name                PARAMS ((tree));\n-extern tree get_tasking_code_name               PARAMS ((tree));\n-extern tree make_process_struct                 PARAMS ((tree, tree));\n-extern tree make_signal_struct                  PARAMS ((tree));\n-extern tree max_queue_size                      PARAMS ((tree));\n-extern void tasking_init                        PARAMS ((void));\n-extern void tasking_registry                    PARAMS ((void));\n-extern void tasking_setup                       PARAMS ((void));\n-\n-/* in ch/timing.c */\n-extern tree abs_timing_type_node;\n-extern tree after_stack;\n-extern void build_after_end                     PARAMS ((void));\n-extern void build_after_start                   PARAMS ((tree, int));\n-extern void build_after_timeout_start           PARAMS ((void));\n-extern void build_at_action                     PARAMS ((tree));\n-extern void build_cycle_end                     PARAMS ((tree));\n-extern tree build_cycle_start                   PARAMS ((tree));\n-extern tree build_timeout_preface               PARAMS ((void));\n-extern void build_timesupervised_call           PARAMS ((tree, tree));\n-extern tree duration_timing_type_node;\n-extern void timing_init                         PARAMS ((void));\n-\n-/* in ch/tree.c */\n-extern tree build_alias_decl\t\t\tPARAMS ((tree, tree, tree));\n-extern tree build_bitstring_type                PARAMS ((tree));\n-extern tree build_powerset_type                 PARAMS ((tree));\n-extern tree build_string_type                   PARAMS ((tree, tree));\n-extern tree decl_check_rename\t\t\tPARAMS ((tree, tree));\n-extern tree discrete_count                      PARAMS ((tree));\n-extern int  list_length                         PARAMS ((tree));\n-extern tree munge_exit_label\t\t\tPARAMS ((tree));\n-extern tree save_if_needed\t\t\tPARAMS ((tree));\n-\n-/* in ch/typeck.c */\n-extern tree build_array_from_set                PARAMS ((tree));\n-extern tree build_chill_array_ref               PARAMS ((tree, tree));\n-extern tree build_chill_bitref                  PARAMS ((tree, tree));\n-extern tree build_chill_cast                    PARAMS ((tree, tree));\n-extern tree chill_equivalent\t                PARAMS ((tree, tree, struct mode_chain*));\n-extern tree build_init_struct                   PARAMS ((void));\n-extern tree build_readonly_type                 PARAMS ((tree));\n-extern int  chill_compatible                    PARAMS ((tree, tree));\n-extern int  chill_compatible_classes            PARAMS ((tree, tree));\n-extern ch_class chill_expr_class                PARAMS ((tree));\n-extern tree chill_give_type_to_expr             PARAMS ((tree, tree));\n-extern tree chill_expand_tuple                  PARAMS ((tree, tree));\n-extern ch_class chill_expr_class                PARAMS ((tree));\n-extern int  chill_location                      PARAMS ((tree));\n-extern tree chill_max_vary_array_index\t\tPARAMS ((tree));\n-extern int  chill_read_compatible               PARAMS ((tree, tree));\n-extern int  chill_referable                     PARAMS ((tree));\n-extern tree chill_root_mode\t                PARAMS ((tree));\n-extern ch_class chill_resulting_class           PARAMS ((ch_class, ch_class));\n-extern tree chill_resulting_mode                PARAMS ((tree, tree));\n-extern int  chill_similar\t                PARAMS ((tree, tree, struct mode_chain*));\n-extern int  discrete_type_p\t\t\tPARAMS ((tree));\n-extern tree convert_to_discrete                 PARAMS ((tree));\n-extern tree smash_dummy_type                    PARAMS ((tree));\n-extern tree string_assignment_condition         PARAMS ((tree, tree));\n-extern tree type_for_mode                       PARAMS ((enum machine_mode, int));\n-extern tree type_for_size                       PARAMS ((unsigned, int));\n-extern int  valid_array_index                   PARAMS ((tree, tree));\n-extern void validate_varying_array_ref          PARAMS ((tree, tree));\n-\n-/* in toplev.c */\n-extern void announce_function                   PARAMS ((tree));\n-extern int  floor_log2_wide                     PARAMS ((unsigned HOST_WIDE_INT));\n-extern void rest_of_compilation                 PARAMS ((tree));\n-\n-/* in varasm.c */\n-extern void make_function_rtl                   PARAMS ((tree));\n-\n-/* in ???? */\n-extern void init_iterators                      PARAMS ((void));\n-extern int  mark_addressable\t\t\tPARAMS ((tree));\n-extern tree chill_result_decl;\n-\n-#ifndef SET_WORD_SIZE\n-#define SET_WORD_SIZE BITS_PER_WORD\n-#endif\n-\n-struct module\n-{\n-  struct module *next_module;  /* Next module, in order of their beginning. */\n-  struct module *prev_module;  /* The surrounding module, if any. */\n-  tree name;\n-  tree prefix_name; /* Usually same as name, expect for nested modules.\n-\t\t       Used to generate DECL_ASSEMBLER_NAMEs. */\t       \n-  /* procedure_seen indicates a procedure or process was declared.\n-     After this, no SEIZE, DCL, SYN, NEWMODE, SYNMODE statement is allowed */\n-  int procedure_seen;\n-  int is_spec_module;\n-\n-  /* The value of current_nesting_level inside the module. */\n-  int nesting_level;\n-\n-  /* A chain contain one ALIAS_DECL for each 'GRANT foo->bar'.\n-     The DECL_NAME is get_identifier(\"bar\"), and the DECL_INITIAL\n-     is get_identifier(\"bar\").  Only used in pass 1. */\n-  tree granted_decls;\n-};\n-\n-extern struct module *current_module;\n-\n-/* fold a tree to constant as much as possible */\n-extern tree deep_fold PARAMS ((tree));\n-\n-extern const char * const gnuchill_version;\n-\n-#endif /* ! GCC_CH_TREE_H */"}, {"sha": "62b73d5f961b660a3145b06c9d8fb33ef7a7c281", "filename": "gcc/ch/chill.in", "status": "removed", "additions": 0, "deletions": 130, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41823c5eb7d4504b6a4a396ca0d64573238fbbcf/gcc%2Fch%2Fchill.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41823c5eb7d4504b6a4a396ca0d64573238fbbcf/gcc%2Fch%2Fchill.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fchill.in?ref=41823c5eb7d4504b6a4a396ca0d64573238fbbcf", "patch": "@@ -1,130 +0,0 @@\n-#!/bin/sh\n-# Compile GNU Chill programs.\n-: || exec /bin/sh -f $0 $argv:q\n-\n-# The compiler name might be different when doing cross-compilation\n-# (this should be configured)\n-gcc_name=gcc\n-whatgcc=gcc\n-speclang=-xnone\n-startfile=chillrt0\n-gnuchill_script_flags=\n-gnuchill_version=unknown\n-extraflags=\n-\n-# replace the command name by the name of the new command\n-progname=`basename $0`\n-case \"$0\" in\n-  */*)\n-    gcc=`echo $0 | sed -e \"s;/[^/]*$;;\"`/$gcc_name\n-    ;;\n-  *)\n-    gcc=$gcc_name\n-    ;;\n-esac\n-\n-# $first is yes for first arg, no afterwards.\n-first=yes\n-# If next arg is the argument of an option, $quote is non-empty.\n-# More precisely, it is the option that wants an argument.\n-quote=\n-# $library is made empty to disable use of libchill.\n-library=\"-lchill\"\n-libpath=chillrt\n-numargs=$#\n-\n-for arg\n-do\n-  if [ $first = yes ]\n-  then\n-    # Need some 1st arg to `set' which does not begin with `-'.\n-    # We get rid of it after the loop ends.\n-    set gcc\n-    first=no\n-  fi\n-  # If you have to ask what this does, you should not edit this file. :-)\n-  # The ``S'' at the start is so that echo -nostdinc does not eat the\n-  # -nostdinc.\n-  arg=`echo \"S$arg\" | sed \"s/^S//; s/'/'\\\\\\\\\\\\\\\\''/g\"`\n-  if [ x$quote != x ]\n-  then\n-    quote=\n-  else\n-    quote=\n-    case $arg in\n-      -nostdlib)\n-\t# Inhibit linking with -lchill.\n-\tlibrary=\n-\tlibpath=\n-\tstartfile=\n-\t;;\n-      -B*)\n-\tgcc=`echo $arg | sed -e \"s/^-B//\"`$gcc_name\n-\t;;\n-      -[bBVDUoeTuIYmLiA] | -Tdata | -Xlinker)\n-\t# these switches take following word as argument,\n-\t# so don't treat it as a file name.\n-\tquote=$arg\n-\t;;\n-      -[cSEM] | -MM)\n-\t# Don't specify libraries if we won't link,\n-\t# since that would cause a warning.\n-\tlibrary=\n-\tlibpath=\n-\tstartfile=\n-\t;;\n-      -x*)\n-\tspeclang=$arg\n-\t;;\n-      -v)\n-\t# catch `chill -v'\n-\tif [ $numargs = 1 ] ; then\n-\t  library=\n-\t  libpath=\n-\t  startfile=\n-\tfi\n-\techo \"GNUCHILL version $gnuchill_version\"\n-\t;;\n-      -fgrant-only | -fchill-grant-only)\n-        #inhibit production of an object file\n-        extraflags=\"-S -o /dev/null\"\n-\tlibrary=\n-\tlibpath=\n-\tstartfile=\n-        ;;\n-      -*)\n-\t# Pass other options through; they don't need -x and aren't inputs.\n-\t;;\n-      *)\n-\t# If file ends in .i, put options around it.\n-\t# But not if a specified -x option is currently active.\n-\tcase \"$speclang $arg\" in -xnone\\ *.[i])\n-\t  set \"$@\" -xchill \"'$arg'\" -xnone\n-\t  continue\n-\tesac\n-\t;;\n-    esac\n-  fi\n-  set \"$@\" \"'$arg'\"\n-done\n-\n-# Get rid of that initial 1st arg\n-if [ $first = no ]; then\n-  shift\n-else\n-  echo \"$0: No input files specified.\"\n-  exit 1\n-fi\n-\n-if [ x$quote != x ]\n-then\n-  echo \"$0: argument to \\`$quote' missing\"\n-  exit 1\n-fi\n-\n-# The '-ansi' flag prevents cpp from changing this:\n-#  NEWMODE x = SET (sun, mon, thu, wed, thu, fri, sat);\n-#to this:\n-#  NEWMODE x = SET (1, mon, thu, wed, thu, fri, sat);\n-#which is a CHILL syntax error.\n-eval $whatgcc -ansi $gnuchill_script_flags $startfile \"$@\" $libpath $library $extraflags"}, {"sha": "692afde89f2d0e264dbaebeab453dfd7665066dd", "filename": "gcc/ch/chill.texi", "status": "removed", "additions": 0, "deletions": 1228, "changes": 1228, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41823c5eb7d4504b6a4a396ca0d64573238fbbcf/gcc%2Fch%2Fchill.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41823c5eb7d4504b6a4a396ca0d64573238fbbcf/gcc%2Fch%2Fchill.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fchill.texi?ref=41823c5eb7d4504b6a4a396ca0d64573238fbbcf", "patch": "@@ -1,1228 +0,0 @@\n-@\\input texinfo @c -*-texinfo-*-\n-@setfilename chill.info\n-@settitle Guide to GNU Chill\n-\n-\n-@ifinfo\n-@format\n-START-INFO-DIR-ENTRY\n-* Chill: (chill).               Chill compiler\n-END-INFO-DIR-ENTRY\n-@end format\n-@end ifinfo\n-\n-@titlepage\n-@title GNU Chill\n-@author William Cox, Per Bothner, Wilfried Moser\n-@end titlepage\n-@contents\n-\n-@node Top\n-@top\n-\n-@menu\n-* Options::               Compiler options\n-* Missing::               Unimplemented parts of the Chill language\n-* Enhancements::          GNU-specific enhancements to the Chill language\n-* Conversions::           Value and location conversions\n-* Separate compilation::  Separate compilation\n-* Differences::           Differences between GNUCHILL and Z.200/1988\n-* Directives::            Implemented Compiler Directives\n-* References::            Language definition references\n-@end menu\n-\n-@node Options\n-@chapter Compiler options\n-\n-Invoking the compiler:\n-\n-The @sc{gnu} CHILL compiler supports several new command line options, and\n-brings a new use to another:\n-\n-@table @code\n-@item -lang-chill\n-This option instructs gcc that the following file is a CHILL source file,\n-even though its extension is not the default `.ch'.\n-\n-@item -flocal-loop-counter\n-The CHILL compiler makes a separate reach, or scope,\n-for each DO FOR loop.  If @code{-flocal-loop-counter} is\n-specified, the loop counter of value enumeration and location\n-enumeration is automatically declared inside that reach.\n-This is the default behavior, required by Z.200.\n-\n-@item -fno-local-loop-counter\n-When this option is specified, the above automatic declaration\n-is not performed, and the user must declare all loop counters \n-explicitly.\n-\n-@item -fignore-case\n-When this option is specified, the compiler ignores case. All \n-identifiers are converted to lower case. This enables the usage\n-of C runtime libraries.\n-\n-@item -fno-ignore-case\n-Ignoring the case of identifiers is turned off.\n-\n-@item -fruntime-checking\n-The CHILL compiler normally generates code to check \n-the validity of expressions assigned to variables or\n-expressions passed as parameters to procedures and processes,\n-if those expressions cannot be checked at compile time.\n-This is the default behavior, required by Z.200.\n-This option allows you to re-enable the default behavior\n-after disabling it with the @code{-fno-runtime-checking}\n-option.\n-\n-@item -fno-runtime-checking\n-The CHILL compiler normally generates code to check \n-the validity of expressions assigned to variables, or\n-expressions passed as parameters to procedures and processes.\n-This option allows you to disable that code generation.\n-This might be done to reduce the size of a program's\n-generated code, or to increase its speed of execution.\n-Compile time range-checking is still performed.\n-\n-@item -fgrant-only\n-@itemx -fchill-grant-only\n-This option causes the compiler to stop successfully\n-after creating the grant file specified by the source\n-file (see modular programming in CHILL).  No code is\n-generated, and many categories of errors are not reported.\n-\n-@item -fold-string\n-Implement the semantics of Chill 1984 with respect to strings:\n-String indexing yields a slice of length one;  CHAR is similar\n-to CHAR(1) (or CHARS(1)); and BOOL is similar to BIT(1) (or BOOLS(1)).\n-\n-@item -fno-old-string\n-Don't implement 1984 Chill string semantics.  This is the default.\n-\n-@item -I@var{seize_path}\n-This directive adds the specified seize path to the compiler's\n-list of paths to search for seize files.  When processing a \n-USE_SEIZE_FILE directive, the compiler normally searches for\n-the specified seize file only in the current directory.  When\n-one or more seize paths are specified, the compiler also \n-searches in those directories, in the order of their\n-specification on the command line, for the seize file.\n-\n-@item -c\n-This C-related switch, which normally prevents gcc from \n-attempting to link, is *not* yet implemented by the @code{chill} command,\n-but you can use the @code{gcc} command with this flag.\n-@end table\n-\n-@node Missing\n-@chapter Implemented and missing parts of the Chill language\n-\n-The numbers in parentheses are Z.200(1988) section numbers.\n-\n-@itemize @bullet\n-@item The FORBID keyword in a GRANT statement is currently ignored.\n-\n-@item A CASE action or expression allows only a single expression\n-in a case selector list (5.3.2, 6.4).\n-\n-@item ROW modes are not implemented (3.6.3, 3.13.4).\n-\n-@item Due to the absence of ROW modes, DYNAMIC has no meaning in\n-connection with access and text modes.\n-\n-@item Array and structure layout (PACK, POS, NOPACK, \n-STEP keywords) is ignored (3.12.6).\n-\n-@item Bit-string slices are not implemented.\n-\n-@item The support for synchronization modes and concurrent execution\n-is slightly non-standard.\n-\n-@item Exception handling is implemented, but exceptions are not\n-generated in all of the required situations.\n-\n-@item Dynamic modes are not implemented (though string slices should work).\n-\n-@item Reach-bound initializations are not implemented (4.1.2).\n-\n-@end itemize\n-\n-@node Enhancements\n-@chapter GNU-specific enhancements to the Chill language\n-\n-@itemize @bullet\n-@item Grantfiles.  See @xref{Separate compilation}.\n-@item Precisions.  Multiple integer and real precisions are supported,\n-as well as signed and unsigned variants of the integer modes.\n-@item DESCR built-in. The new built-in function \n-DESCR ( <descriptor argument> ) returns a pointer to \n-STRUCT( addr PTR, length ULONG ) where <descriptor argument> can be\n-anything the compiler can handle but at least a location of any mode\n-(except synchronizing modes) and any character string or powerset value.\n-(A temporary location within the current stack frame may be allocated\n-if an expression is used.)\n-\n-CHILL does not permit the writing of procedures with parameters of\n-any type. Yet some interfaces---in particular those to system \n-calls---require\n-the handling of a wide range of modes, e.g. any string mode, any structure\n-mode, or any powerset mode. This could be handled by specifying two\n-parameters (PTR, INT for the length) but this is error-prone (no guarantee\n-the same location is used after in ADDR and LENGTH), and it will not be\n-possible for expressions.\n-\n-Caveats: This feature permits the programmer to obtain the address of\n-a literal (if the compiler takes this shortcut---see 1st example below).\n-If hardware features protect constant parts of the program, erronous\n-abuse will be detected.\n-\n-    Examples:\n-       OFFER_HANDLER( descr(\"dbs\"), ->dbs);\n-\n-       SYNMODE m_els = SET( ela, elb, elc );\n-       SYNMODE m_elsel = POWERSET m_els;\n-       DCL user_buf STRUCT( a mx, b my, c mz);\n-       DCL select POWERSET m_elsel;\n-\n-       select := m_elsel[LOWER(m_els) : UPPER(m_els)];\n-\n-       GET_RECORD( relation, recno, descr(user_buf), descr(select) );\n-\n-       PUT_RECORD( relation, recno, descr(user_buf.b), descr(m_elsel[elb]) );\n-\n-@item LENGTH built-in on left-hand-side.       The LENGTH built-in may be\n-used on the left-hand-side of an assignment, where its argument is a VARYING\n-character string.\n-@end itemize\n-\n-@node Conversions\n-@chapter Value and location conversions\n-\n-Value and location conversions are highly dependent on the target machine.\n-They are also very loosely specified in the 1988 standard.\n-(The 1992 standard seems an improvement.)\n-\n-The GNU Chill compiler interprets @code{@var{mode}(@var{exp})} as follows:\n-\n-@itemize @bullet\n-@item\n-If @var{exp} is a referable location,\n-and the size of (the mode of) @var{exp} is the same as the size of @var{mode},\n-a location conversion is used.\n-It is implemented exactly as:  @code{(@var{refmode}(-> @var{exp}))->},\n-where @var{refmode} is a synmode for @code{REF @var{mode}}.\n-\n-The programmer is responsible for making sure that alignment\n-restrictions on machine addresses are not violated.\n-\n-If both @var{mode} and the mode of @var{exp} are discrete modes,\n-alignment should not be a problem, and we get the same conversion\n-as a standard value conversion.\n-\n-@item\n-If @var{exp} is a constant,\n-and the size of (the mode of) @var{exp} is the same as the size of @var{mode},\n-then a value conversion is performed.  This conversion is done\n-at compile time, and it has not been implemented for all types.\n-Specifically, converting to or from a floating-point type is not implemented.\n-\n-@item\n-If both @var{mode} and the mode of @var{exp} are discrete modes,\n-then a value conversion is performed, as described in Z.200.\n-\n-@item\n-If both @var{mode} and the mode of @var{exp} are reference modes,\n-then a value conversion is allowed.\n-The same is true is one mode is a reference mode, and the other\n-is an integral mode of the same size.\n-\n-@end itemize\n-\n-@node Separate compilation\n-@chapter Separate compilation\n-\n-The GNU CHILL compiler supports modular programming.  It\n-allows the user to control the visibility of variables\n-and modes, outside of a MODULE, by the use of GRANT\n-and SEIZE directives.  Any location or mode may be made\n-visible to another MODULE by GRANTing it in the MODULE\n-where it is defined, and SEIZEing it in another MODULE\n-which needs to refer to it.\n-\n-When variables are GRANTed in one or more modules of a\n-CHILL source file, the compiler outputs a grant file,\n-with the original source file name as the base name,\n-and the extension `.grt'.  All of the variables and modes\n-defined in the source file are written to the grant file,\n-together with any use_seize_file directives, and the\n-GRANT directives.  A grant file is created for every such\n-source file, except if an identical grant file already \n-exists.  This prevents unnecessary makefile activity.\n-\n-The referencing source file must:\n-\n-@enumerate\n-@item specify the grant file in a use_seize_file directive, and\n-@item SEIZE each variable or mode definition that it needs.\n-@end enumerate\n-\n-An attempt to SEIZE a variable or mode which is not\n-GRANTed in some seize file is an error.\n-\n-An attempt to refer to a variable which is defined in\n-some seize file, but not explicitly granted, is an\n-error.\n-\n-An attempt to GRANT a variable or mode which is not\n-defined in the current MODULE is an error.\n-\n-Note that the GNU CHILL compiler will *not* write out a\n-grant file if:\n-\n-@itemize @bullet\n-@item there are no GRANT directives in the source file, or\n-@item the entire grant file already exists, and is\n-     identical to the file which the compiler has just built.\n-(This latter ``feature'' may be removed at some point.)\n-@end itemize\n-\n-Otherwise, a grant file is an automatic, unsuppressable\n-result of a successful CHILL compilation.\n-\n-A future release will also support using remote spec modules\n-in a similar (but more Blue Book-conforming) manner.\n-\n-@node Differences\n-@chapter Differences to Z.200/1988\n-\n-This chapter lists the differences and extensions between GNUCHILL \n-and the CCITT recommendation Z.200 in its 1988 version (reffered to\n-as Z.200/1988).\n-\n-@itemize @bullet\n-\n-@item 2.2 Vocabulary@*\n-The definition of @i{<simple name string>} is changed to:\n-\n-@example\n-@i{<simple name string> ::=}\n-@example\n-@i{@{<letter> | _ @} @{ <letter> | <digit | _ @}}\n-@end example\n-@end example\n-\n-@item 2.6 Compiler Directives@*\n-Only one directive is allowed between the compiler directive delimiters\n-`<>' and `<>' or the end-of-line, i.e.\n-@example\n-<> USE_SEIZE_FILE \"foo.grt\" <>\n-<> ALL_STATIC_OFF\n-@end example\n-\n-@item 3.3 Modes and Classes@*\n-The syntax of @i{<mode>} is changed to:\n-\n-@example\n-@i{<mode> ::=}\n-@example\n-  [@b{READ}] @i{<non-composite-mode>}\n-| [@b{READ}] @i{composite-mode>}\n-@end example\n-\n-@i{<non-composite-mode> ::=}\n-@example\n-  @i{<discrete mode>}\n-| @i{<real modes>}\n-| @i{<powerset modes>}\n-| @i{<reference mode>}\n-| @i{<procedure mode>}\n-| @i{<instance mode>}\n-| @i{<synchronization mode>}\n-| @i{<timing mode>}\n-@end example\n-@end example\n-\n-@item 3.4 Discrete Modes@*\n-The list of discrete modes is enhanced by the following modes:\n-\n-@example\n-BYTE         8-bit signed integer\n-UBYTE        8-bit unsigned integer\n-UINT         16-bit unsigned integer\n-LONG         32-bit signed integer\n-ULONG        32-bit unsigned integer\n-@end example\n-\n-@strong{Please note} that INT is implemented as 16-bit signed integer.\n-\n-@item 3.4.6 Range Modes@*\n-The mode BIN(n) is not implemented. Using INT(0 : 2 ** n - 1) instead of\n-BIN(n) makes this mode unneccessary.\n-\n-@item 3.X Real Modes@*\n-Note: This is an extension to Z.200/1988, however, it is defined in\n-Z.200/1992.\n-\n-@b{syntax:}\n-\n-@example\n-@i{<real mode> ::=}\n-@example\n-@i{<floating point mode>}\n-@end example\n-@end example\n-\n-@b{semantics:}\n-\n-@example\n-A real mode specifies a set of numerical values which approximate a\n-contiguous range of real numbers.\n-@end example\n-\n-@item 3.X.1 Floating point modes@*\n-\n-@b{syntax:}\n-\n-@example\n-@i{<floating point mode> ::=}\n-@example\n-@i{<floating point mode name}\n-@end example\n-@end example\n-\n-@b{predefined names:}\n-\n-The names @i{REAL} and @i{LONG_REAL} are predefined as @b{floating\n-point mode} names.\n-\n-@b{semantics:}\n-\n-A floating point mode defines a set of numeric approximations to a \n-range of real values, together with their minimum relative accuracy, \n-between implementation defined bounds, over which the usual ordering \n-and arithmetic operations are defined. This set contains only the \n-values which can be represented by the implementation.\n-\n-@b{examples:}\n-\n-@example\n-@i{REAL}\n-@i{LONG_REAL}\n-@end example\n-\n-@item 3.6 Reference Modes@*\n-Row modes are not implemeted at all.\n-\n-@item 3.7 Procedure Mode@*\n-The syntax for procedure modes is changed to:\n-\n-@example\n-@i{<procedure mode> ::=}\n-@example\n-  @b{PROC} @i{([<parameter list>]) [ <result spec> ]}\n-  @i{[}@b{EXCEPTIONS}@i{(<exception list>)] [}@b{RECURSIVE}@i{]}\n-| @i{<procedure mode name>}\n-@end example\n-\n-@i{<parameter list> ::=}\n-@example\n-@i{<parameter spec> @{, <parameter spec> @} *}\n-@end example\n-\n-@i{<parameter spec> ::=}\n-@example\n-@i{<mode> [ <parameter attribute> ]}\n-@end example\n-\n-@i{<parameter attribute> ::=}\n-@example\n-@b{IN} | @b{OUT} | @b{INOUT} | @b{LOC}\n-@end example\n-\n-@i{<result spec> ::=}\n-@example\n-@b{RETURNS} @i{( <mode> [}@b{LOC}@i{])}\n-@end example\n-\n-@i{<exception list> ::=}\n-@example\n-@i{<exception name> @{, <exception name> @} *}\n-@end example\n-@end example\n-\n-\n-@item 3.10 Input-Output Modes@*\n-Due to the absence of row modes, DYNAMIC has no meaning in an access\n-or text mode definition.\n-\n-\n-@item 3.12.2 String Modes@*\n-As @i{<string modes>} were defined differently in Z.200/1984, the syntax\n-of @i{<string mode>} is changed to:\n-\n-@example\n-@i{<string mode> ::=}\n-@example\n-  @i{<string type> ( <string length> ) [} @b{VARYING} @i{]}\n-| @i{<parametrized string mode>}\n-| @i{<string mode name>}\n-@end example\n-\n-@i{<parameterized string mode> ::=}\n-@example\n-  @i{<origin string mode name> ( <string length> )}\n-| @i{<parameterized string mode name>}\n-@end example\n-\n-@i{<origin string mode name> ::=}\n-@example\n-@i{<string mode name>}\n-@end example\n-\n-@i{string type}\n-@example\n-  @b{BOOLS}\n-| @b{BIT}\n-| @b{CHARS}\n-| @b{CHAR}\n-@end example\n-\n-@i{<string length> ::=}\n-@example\n-@i{<integer literal expression>}\n-@end example\n-@end example\n-\n-@b{VARYING} is not implemented for @i{<string type>} @b{BIT}\n-and @b{BOOL}.\n-\n-@item 3.11.1 Duration Modes@*\n-The predefined mode @i{DURATION} is implemented as a NEWMODE ULONG and\n-holds the duration value in miliseconds. This gives a maximum duration\n-of\n-\n-@example\n-MILLISECS (UPPER (ULONG)),\n-SECS (4294967),\n-MINUTES (71582),\n-HOURS (1193), and\n-DAYS (49).\n-@end example\n-\n-@item 3.11.2 Absolute Time Modes@*\n-The predefined mode @i{TIME} is implemented as a NEWMODE ULONG and\n-holds the absolute time in seconds since Jan. 1st, 1970. This is\n-equivalent to the mode `time_t' defined on different systems.\n-\n-@item 3.12.4 Structure Modes@*\n-Variant fields are allowed, but the CASE-construct may define only one\n-tag field (one dimensional CASE). OF course, several variant fields may\n-be specified in one STRUCT mode. The tag field will (both at compile-\n-and runtime) not be interpreted in any way, however, it must be\n-interpreted by a debugger. As a consequence, there are no parameterized \n-STRUCT modes.\n-\n-@item 3.12.5 Layout description for array and structure modes@*\n-STEP and POS is not implemeted at all, therefore the syntax of\n-@i{<element layout} and @i{field layout} is changed to:\n-\n-@example\n-@i{<element layout> ::=}\n-@example\n-@b{PACK} | @b{NOPACK}\n-@end example\n-\n-@i{<field layout> ::=}\n-@example\n-@b{PACK} | @b{NOPACK}\n-@end example\n-@end example\n-\n-@item 3.13.4 Dynamic parameterised structure modes@*\n-Dynamic parameterised structure modes are not implemented.\n-\n-@item 4.1.2 Location declaration@*\n-The keyword STATIC is allowed, but has no effect at module level, because\n-all locations declared there are assumed to be `static' by default. Each\n-granted location will become `public'. A `static' declaration inside a\n-block, procedure, etc. places the variable in the data section instead of\n-the stack section.\n-\n-@item 4.1.4 Based decleration@*\n-The based declaration was taken from Z.200/1984 and has the following\n-syntax:\n-\n-@b{syntax:}\n-\n-@example\n-@i{<based declaration> ::=}\n-@example\n-@i{<defining occerrence list> <mode>} @b{BASED}\n-@i{( <free reference location name> )}\n-@end example\n-@end example\n-\n-@b{semantics:}\n-\n-A based declaration with @i{<free reference location name>} specifies\n-as many access names as are defining occerrences in the @i{defining\n-occurrence list}. Names declared in a base declaration serve as an\n-alternative way accessing a location by dereferencing a reference \n-value. This reference value is contained in the location specified by \n-the @i{free reference location name}. This dereferencing operation is \n-made each time and only when an access is made via a declared @b{based} \n-name.\n-\n-@b{static properties:}\n-\n-A defining occurrence in a @i{based declaration} with @i{free reference\n-location name} defines a @b{based} name. The mode attached to a\n-@b{based} name is the @i{mode} specified in the @i{based declaration}. A\n-@b{based} name is @b{referable}.\n-\n-@item 4.2.2 Access names@*\n-The syntax of access names is changed to:\n-\n-@example\n-@i{<access name> ::=}\n-@example\n-  @i{<location name>}\n-| @i{<loc-identity name>}\n-| @i{<based name>}\n-| @i{<location enumeration name>}\n-| @i{<location do-with name>}\n-@end example\n-@end example\n-\n-The semantics, static properties and dynamic conditions remain\n-unchanged except that they are enhanced by @i{base name}.\n-\n-@item 5.2.4.1 Literals General@*\n-The syntax of @i{<literal>} is change to:\n-\n-@example\n-@i{<literal> ::=}\n-@example\n-  @i{<integer literal>}\n-| @i{<boolean literal>}\n-| @i{<charater literal>}\n-| @i{<set literal>}\n-| @i{<emptiness literal>}\n-| @i{<character string literal>}\n-| @i{<bit string literal>}\n-| @i{<floating point literal>}\n-@end example\n-@end example\n-\n-Note: The @i{<floating point literal>} is an extension to Z.200/1988 and\n-will be described later on.\n-\n-@item 5.2.4.2 Integer literals@*\n-The @i{<decimal integer literal>} is changed to:\n-\n-@example\n-@i{<decimal integer literal> ::=}\n-@example\n-  @i{@{ D | d @} ' @{ <digit> | _ @} +}\n-| @i{<digit> @{ <digit> | _ @} *}\n-@end example\n-@end example\n-\n-@item 5.2.4.4 Character literals@*\n-A character literal, e.g. 'M', may serve as a charater string literal of\n-length 1.\n-\n-@item 5.2.4.7 Character string literals@*\n-The syntax of a character string literal is:\n-\n-@example\n-@i{<character string literal> ::=}\n-@example\n-  @i{'@{ <non-reserved character> | <single quote> |}\n-  @i{<control sequence> @} * '}\n-| @i{'@{ <non-reserved character> | <double quote> |}\n-  @i{<control sequence> @} * '}\n-@end example\n-\n-@i{<single quote> ::=}\n-@example\n-@i{''}\n-@end example\n-\n-@i{<double quote> ::=}\n-@example\n-@i{\"\"}\n-@end example\n-@end example\n-\n-A character string litaral of length 1, enclosed in apostrophes\n-(e.g. 'M') may also serve as a charater literal.\n-\n-@item 5.2.4.9 Floating point literal@*\n-Note: This is an extension to Z.200/1988 ans was taken from Z.200/1992.\n-\n-@b{syntax:}\n-\n-@example\n-@i{<floating point literal> ::=}\n-@example\n-  @i{<unsigned floating point literal>}\n-| @i{<signed floating point literal>}\n-@end example\n-\n-@i{<unsigned floating point literal> ::=}\n-@example\n-  @i{<digit sequence> . [ <digit sequence> ] [ <exponent> ]}\n-| @i{[ <digit sequence> ] . <digit sequence> [ <exponent> ]}\n-@end example\n-\n-@i{<signed floating point literal> ::=}\n-@example\n-@i{- <unsigned floating point literal>}\n-@end example\n-\n-@i{<digit sequence> ::=}\n-@example\n-@i{<digit> @{ <digit> | _ @} *}\n-@end example\n-\n-@i{<exponent> ::=}\n-@example\n-  @i{[ E | D | e | d ] <digit sequence>}\n-| @i{[ E | D | e | d ] - <digit sequence>}\n-@end example\n-@end example\n-\n-@item 5.2.14 Start Expression@*\n-The START expression is not implemented.\n-\n-@item 5.3 Values and Expressions@*\n-The undefined value, denoted by `*', is not implemented.\n-\n-@item 5.3.8 Operand-5@*\n-The @i{<string repetition operator>} is defined as:\n-\n-@example\n-@i{<string repetition operator> ::=}\n-@example\n-@i{(<integer expression>)}\n-@end example\n-@end example\n-\n-@item 6.4 Case Action@*\n-There may be only one case selector specified. The optional range list\n-must not be specified.\n-\n-@item 6.5 Do Action@*\n-A Do-Action without control part is not implemented. Grouping of\n-statements can be achieved via BEGIN and END. A location enumeration is not\n-allowed for BIT strings, only for (varying) CHAR strings and ARRAYs.\n-\n-The expression list in a DO WITH must consist of locations only.\n-\n-@item 6.13 Start Action@*\n-The syntax of the START action is changed to:\n-\n-@example\n-@i{<start action> ::=}\n-@example\n-@b{START} @i{<process name> (<copy number> [, <actual parameter list>])}\n-@i{[} @b{SET} @i{<instance location> ]}\n-@end example\n-\n-@i{<copy number> ::=}\n-@example\n-@i{<integer expression>}\n-@end example\n-@end example\n-\n-@item 6.16 Delay Action@*\n-The optional PRIORITY specification need not be a constant.\n-\n-@item 6.17 Delay Case Action@*\n-The optional SET branch and the, also optional, PRIORITY branch must be\n-separated by `;'.\n-\n-@item 6.18 Send Action@*\n-The send action must define a destination instance (via the TO branch),\n-since undirected signals are not supported. The optional PRIORITY\n-specification need not be a constant. Additional to the data\n-transported by the signal, there will be a user defined argument.\n-\n-The syntax of the @i{<send signal action>} is therefore:\n-\n-@example\n-@i{<send signal action> ::=}\n-@example\n-@b{SEND} @i{<signal name> [ ( <value> @{, <value> @} * ) ]}\n-@i{[} @b{WITH} @i{<expression> ]}\n-@b{TO} @i{<instance primitive value> [ <priority> ]}\n-@end example\n-@end example\n-\n-The default priority can be specified by the compiler directive\n-SEND_SIGNAL_DEFAULT_PRIORITY. If this also is omitted, the default\n-priority is 0.\n-\n-@item 6.20.3 CHILL value built-in calls@*\n-The CHILL value buit-in calls are enhanced by some calls, and other calls\n-will have different arguments as described in Z.200/1988. Any call not\n-mentioned here is the same as described in Z.200/1988.\n-\n-@b{syntax:}\n-\n-@example\n-@i{CHILL value built-in routine call> ::=}\n-@example\n-  @i{ADDR (<location>)}\n-| @i{PRED (<pred succ argument>)}\n-| @i{SUCC (<pred succ argument>)}\n-| @i{ABS (<numeric expression>)}\n-| @i{LENGTH (<length argument>)}\n-| @i{SIN (<floating point expression>)}\n-| @i{COS (<floating point expression>)}\n-| @i{TAN (<floating point expression>)}\n-| @i{ARCSIN (<floating point expression>)}\n-| @i{ARCCOS (<floating point expression>)}\n-| @i{ARCTAN (<floating point expression>)}\n-| @i{EXP (<floating point expression>)}\n-| @i{LN (<floating point expression>)}\n-| @i{LOG (<floating point expression>)}\n-| @i{SQRT (<floating point expression>)}\n-| @i{QUEUE_LENGTH (<buffer location> | <event location>)}\n-| @i{GEN_INST (<integer expression> | <process name> ,}\n-               @i{<integer expression>)}\n-| @i{COPY_NUMBER (<instance expression>)}\n-| @i{GEN_PTYE (<process name>)}\n-| @i{PROC_TYPE (<instance expression>)}\n-| @i{GEN_CODE (<process name> | <signal name>)}\n-| @i{DESCR (<location>)}\n-@end example\n-\n-@i{<pred succ argument> ::=}\n-@example\n-  @i{<discrete expression>}\n-| @i{<bound reference expression>}\n-@end example\n-\n-@i{<numeric expression> ::=}\n-@example\n-  @i{<integer expression>}\n-| @i{floating point expression>}\n-@end example\n-\n-@i{<length argument> ::=}\n-@example\n-  @i{<string location>}\n-| @i{<string expression>}\n-| @i{<string mode name>}\n-| @i{<event location>}\n-| @i{<event mode name>}\n-| @i{<buffer location>}\n-| @i{<buffer mode name>}\n-| @i{<text location>}\n-| @i{<text mode name>}\n-@end example\n-@end example\n-\n-@b{semantics:}\n-\n-@i{ADDR} is derived syntax for -> @i{<location>}.\n-\n-@i{PRED} and @i{SUCC} delivers respectively, in case of a @i{discrete\n-expression}, the next lower or higher discrete value of their argument,\n-in case of @i{bound reference expression} these built-in calls deliver a\n-pointer to the previous or next element.\n-\n-@i{ABS} is defined on numeric values, i.e. integer values and floating\n-point values, delivering the corresponding absolute value.\n-\n-@i{LENGTH} is defined on\n-\n-@itemize @bullet\n-\n-@item string and text locations and string expressions, delivering the\n-length of them;\n-\n-@item event locations, delivering the @b{event length} of the mode of the\n-location;\n-\n-@item buffer locations, delivering the @b{buffer length} of the mode of\n-the location;\n-\n-@item string mode names, delivering the @b{string length} of the mode;\n-\n-@item text mode names, delivering the @b{text length} of the mode;\n-\n-@item buffer mode names, delivering the @b{buffer length} of the mode;\n-\n-@item event mode names, delivering the @b{event length} of the mode;\n-\n-@item Additionally, @i{LENGTH} also may be used on the left hand\n-side of an assignment to set a new length of a @i{varying character\n-string location}. However, to avoid undefined elements in the varying\n-string, the new length may only be less or equal to the current length.\n-Otherwise a @b{RANGEFAIL} exception will be generated.\n-@end itemize\n-\n-@i{SIN} delivers the sine of its argument (interpreted in radians).\n-\n-@i{COS} delivers the cosine of its argument (interpreted in radians).\n-\n-@i{TAN} delivers the tangent of its argument (interpreted in radians).\n-\n-@i{ARCSIN} delivers the sin -1 function of its argument.\n-\n-@i{ARCCOS} delivers the cos -1 function of its argument.\n-\n-@i{ARCTAN} delivers the tan -1 function of its argument.\n-\n-@i{EXP} delivers the exponential function, where x is the argument.\n-\n-@i{LN} delivers the natural logarithm of its argument.\n-\n-@i{LOG} delivers the base 10 logarithm of its argument.\n-\n-@i{SQRT} delivers the sqare root of its argument.\n-\n-@i{QUEUE_LENGTH} delivers either the number of sending delayed processes\n-plus the number of messages in a buffer queue (if the argument is a\n-@i{buffer location}), or the number of delayed processes (if the\n-argument specifies an @i{event location}) as @i{integer expression}.\n-\n-@i{GEN_INST} delivers an @i{instance expression} constructed from the\n-arguments. Both arguments must have the @i{&INT}-derived class.\n-\n-@i{COPY_NUMBER} delivers as @i{&INT}-derived class the copy number of an\n-@i{instance location}.\n-\n-@i{GEN_PTYPE} delivers as @i{&INT}-derived class the associated number\n-of the @i{process name}.\n-\n-@i{PROC_TYPE} delivers as @i{&INT}-derived class the process type of an\n-@i{instance expression}.\n-\n-@i{GEN_CODE} delivers as @i{&INT}-derived class the associated number of\n-the @i{process name} or @i{signal name}.\n-\n-@i{DESCR} delivers a @i{free reference expression} pointing to a\n-structure with the following layout describing the @i{location} argument.\n-\n-@example\n-SYNMODE __tmp_descr = STRUCT (p PTR, l ULONG);\n-@end example\n-\n-\n-@item 7.4.2 Associating an outside world object@*\n-The syntax of the associate built-in routine call is defined as:\n-\n-@example\n-@i{<associate built-in routine call> ::=}\n-@example\n-@i{ASSOCIATE ( <association location>, <string expression>,} [@i{, <string expression>} ] @i{)}\n-@end example\n-@end example\n-\n-The ASSOCIATE call has two parameters besides the association location:\n-a pathname and an optional mode string.\n-\n-The value of the first string expression must be a pathname according to\n-the rules of the underlying operating system. (Note that a relative pathname \n-implies a name relative to the working directory of the process.)\n-\n-The mode string may contain the value \"VARIABLE\", which requests\n-an external representation of records consisting of an UINT record\n-length followed by as many bytes of data as indicated by the length field.\n-Such a file with variable records is not indexable.\n-\n-A file with variable records can be written using any record mode. If the \n-record mode is CHARS(n) VARYING, the record length is equal to the actual \n-length of the value written.  (Different record may have differing lengths.)\n-With all other record modes, all records written using the same access mode\n-will have the same length, but will still be prefixed with the length field.\n-(Note that by re-connecting with different access modes, the external\n-representation may ultimately contain records with differing lengths.)\n-\n-A file with variable records can only be read by using a record mode of\n-CHARS(n) VARYING.\n-\n-\n-@item 7.4.2 Accessing association attributes@*\n-The value of the READABLE and WRITEABLE attributes is determined using \n-the file status call provided by the operating system.  The result will\n-depend on the device being accessed, or on the file mode.\n-\n-The INDEXABLE attribute has the value false for files with variable records,\n-and for files associated with devices not supporting random positioning\n-(character devices, FIFO special files, etc.).\n-\n-The variable attribute is true for files associated with the mode sting\n-\"VARIABLE\", and false otherwise.\n-\n-\n-@item 7.4.5 Modifying association attributes@*\n-The syntax of the MODIFY built-in routine call is defined as:\n-\n-@example\n-@i{<modify built-in call> ::=}\n-@example\n-@i{MODIFY ( <association location>, <string expression> )}\n-@end example\n-@end example\n-\n-At present, MODIFY accepts a character string containing a pathname\n-in addition to the association location, which will cause a renaming \n-of the associated file.\n-\n-\n-@item 7.4.9 Data transfer operations@*\n-READRECORD will fail (causing READFAIL) if the number of bytes from the\n-current position in the file to the end of the file is greater than zero\n-but less than the size of the record mode, and no data will be transferred.\n-(If the number of bytes is zero, no error occurs and OUTOFFILE will\n-return TRUE.)\n-\n-The number of bytes transferred by READRECORD and WRITERECORD is equal to\n-the size of the record mode of the access location. Note that the\n-internal representation of this mode may vary depending on the\n-record mode being packed or not.\n-\n-\n-@item 7.5 Text Input Output@*\n-Sequential text files will be represented so as to be compatible\n-with the standard representation of texts on the underlying operating\n-system, where control characters are used to delimit text records on files\n-as well as to control the movement of a cursor or printing head on a device.\n-\n-For indexed text files, records of a uniform length (i.e. the size of the\n-text record, including the length field) are written.  All i/o codes cause \n-an i/o transfer without any carriage control  characters being added to the\n-record, which will be expanded with spaces.\n-\n-An indexed text file is therefore not compatible with the standard\n-text representation of the underlying operating system. \n-\n-\n-\n-@item 7.5.3 Text transfer operations@*\n-The syntax of @i{<text argument>} is changed to:\n-\n-@example\n-@i{<text argument> ::=}\n-@example\n-  @i{<text location>}\n-| @i{<predefined text location>}\n-| @i{<varying string location>}\n-@end example\n-\n-@i{<predefined text location> ::=}\n-@example\n-  STDIN\n-| STDOUT\n-| STDERR\n-@end example\n-@end example\n-\n-NOTE: The identifiers STDIN, STDOUT, and STDERR are predefined.\n-Association and connection with files or devices is done according to\n-operating system rules.\n-\n-The effect of using READTEXT or WRITETEXT with a character string location\n-as a text argument (i.e. the first parameter) where the same location also\n-appears in the i/o list is undefined.\n-\n-The current implementation of formatting assumes run-to-completion semantics\n-of CHILL tasks within an image.\n-\n-\n-\n-@item 7.5.5 Conversion@*\n-Due to the implementation of @i{<floating point modes>} the syntax\n-is changed to:\n-\n-@example\n-@i{<conversion clause> ::=}\n-@example\n-@i{<conversion code> @{ <conversion qualifier @} *}\n-@i{[ <clause width> ]}\n-@end example\n-\n-@i{<conversion code> ::=}\n-@example\n-@i{B} | @i{O} | @i{H} | @i{C} | @i{F}\n-@end example\n-\n-@i{<conversion qualifier> ::=}\n-@example\n-@i{L} | @i{E} | @i{P<character>}\n-@end example\n-\n-@i{<clause width> ::=}\n-@example\n-  @i{@{ <digit> @} +} | @i{V}\n-| @i{<real clause width>}\n-@end example\n-\n-@i{<real clause width> ::=}\n-@example\n-@i{@{ @{ <digit> + | V @} : @{ @{ <digit> @} + | V @}}\n-@end example\n-@end example\n-\n-Note: The @i{<real clause width>} is only valid for @i{<conversion\n-code>} `C' or `F'.\n-\n-\n-@item 7.5.7 I/O control@*\n-To achieve compatibility of text files written with CHILL i/o with\n-the standard representation of text on the underlying operating system\n-the interpretation of the i/o control clause of the format \n-deviates from Z.200. The following table shows the i/o codes together\n-with the control characters written before and after the text record, \n-to achieve the indicated function:\n-@table @samp\n-@item /\n-Write next record (record, line feed)\n-\n-@item +\n-Write record on next page (form feed, record, line feed)\n-\n-@item -\n-Write record on current line (record, carriage return)\n-\n-@item ?\n-Write record as a prompt (carriage return, record)\n-\n-@item !\n-Emit record (record).\n-\n-@item =\n-Force new page for the next line: The control character written before\n-the next record will be form feed, irrespective of the i/o control used for\n-transferring the record.\n-@end table\n-\n-When reading a text file containing control characters other than line feed,\n-these characters have to be reckoned with by the format used to read the\n-text records.\n-\n-\n-\n-\n-@item 11.2.2 Regionality@*\n-Regionality is not implemented at all, so there is no difference in the\n-generated code when REGION is substituted by MODULE in a GNUCHILL\n-compilation unit.\n-\n-@item 11.5 Signal definition statement@*\n-The @i{<signal definition statement>} may only occur at module level.\n-\n-@item 12.3 Case Selection@*\n-The syntax of @i{<case label specification>} is changed to:\n-\n-@example\n-@i{<case label specification> ::=}\n-@example\n-@i{( <case label> @{, <case label> @} * )}\n-@end example\n-\n-@i{<case label> ::=}\n-@example\n-  @i{<discrete literal expression>}\n-| @i{<literal range>}\n-| @i{<discrete mode name>}\n-| @b{ELSE}\n-@end example\n-@end example\n-\n-@end itemize\n-\n-@node Directives\n-@chapter Compiler Directives\n-\n-@itemize @bullet\n-\n-@item ALL_STATIC_ON, ALL_STATIC_OFF@*\n-These directives control where procedure local variables are\n-allocated. ALL_STATIC_ON turns allocation of procedure local variables\n-in the data space ON, regardless of the keyword STATIC being used or not.\n-ALL_STATIC_OFF places procedure local variables in the stack space.\n-The default is ALL_STATIC_OFF.\n-\n-@item RANGE_ON, RANGE_OFF@*\n-Turns generation of rangecheck code ON and OFF.\n-\n-@item USE_SEIZE_FILE <character string literal>@*\n-Specify the filename (as a character string literal) where \n-subsequent SEIZE statements are related to. This directive \n-and the subsequent SEIZEs are written\n-to a possibly generated grant file for this module.\n-\n-@example\n-<> USE_SEIZE_FILE \"foo.grt\" <>\n-SEIZE bar;\n-@end example\n-\n-@item USE_SEIZE_FILE_RESTRICTED \"filename\"@*\n-Same as USE_SEIZE_FILE. The difference is that this directive\n-and subsequent SEIZEs are *not* written to a possibly generated\n-grant file. \n-\n-@item PROCESS_TYPE = <integer expression>@*\n-Set start value for all PROCESS delclarations. This value automatically\n-gets incremented after each PROCESS declaration and may be changed with\n-a new PROCESS_TYPE compiler directive.\n-\n-@item SIGNAL_CODE = <integer expression>@*\n-Set start value for all SIGNAL definitions. This value automatically\n-gets incremented after each SIGNAL definition and may be changed with a\n-new SIGNAL_CODE compiler directive.\n-\n-@item SEND_SIGNAL_DEFAULT_PRIORITY = <integer expression>@*\n-Set default priority for send signal action.\n-\n-@item SEND_BUFFER_DEFAULT_PRIORITY = <integer expression>@*\n-Set default priority for send buffer action.\n-\n-Note: Every <integer expression> in the above mentioned compiler\n-directives may also be specified by a SYNONYM of an integer type.\n-\n-@example\n-SYN first_signal_code = 10;\n-<> SIGNAL_CODE = first_signal_code <>\n-SIGNAL s1;\n-@end example\n-\n-@end itemize\n-\n-@node References\n-@chapter Language Definition References\n-\n-@itemize @bullet\n-@item\tCCITT High Level Language (CHILL) Recommendation Z.200\n-\tISO/IEC 9496, Geneva 1989                ISBN 92-61-03801-8\n-\n-@item\tAn Analytic Description of CHILL, the CCITT high-level\n-\tlanguage, Branquart, Louis & Wodon, Springer-Verlag 1981\n-                                                 ISBN 3-540-11196-4\n-\n-@item\tCHILL User's Manual\n-\tCCITT, Geneva 1986                       ISBN 92-61-02601-X\n-\n-@item\tIntroduction to CHILL\n-\tCCITT, Geneva 1983                       ISBN 92-61-017771-1\n-\n-@item\tCHILL CCITT High Level Language\n-\tProceedings of the 5th CHILL Conference\n-\tNorth-Holland, 1991                      ISBN 0 444 88904 3\n-\n-@item\tIntroduction to the CHILL programming Language\n-\tTELEBRAS, Campinas, Brazil 1990\n-\n-@end itemize\n-\n-Z.200 is mostly a language-lawyer's document, but more readable\n-than most.  The User's Guide is more readable by far, but doesn't\n-cover the whole language.  Our copies of these documents came through\n-Global Engineering Documents, in Irvine, CA, USA. (714)261-1455.\n-\n-@bye"}, {"sha": "6f57b179acaf982d5dd285ba5a33a66f4485a0ba", "filename": "gcc/ch/config-lang.in", "status": "removed", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41823c5eb7d4504b6a4a396ca0d64573238fbbcf/gcc%2Fch%2Fconfig-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41823c5eb7d4504b6a4a396ca0d64573238fbbcf/gcc%2Fch%2Fconfig-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fconfig-lang.in?ref=41823c5eb7d4504b6a4a396ca0d64573238fbbcf", "patch": "@@ -1,38 +0,0 @@\n-# Top level configure fragment for GNU CHILL.\n-#   Copyright (C) 1994, 2000, 2001 Free Software Foundation, Inc.\n-\n-#This file is part of GNU CC.\n-\n-#GNU CC is free software; you can redistribute it and/or modify\n-#it under the terms of the GNU General Public License as published by\n-#the Free Software Foundation; either version 2, or (at your option)\n-#any later version.\n-\n-#GNU CC is distributed in the hope that it will be useful,\n-#but WITHOUT ANY WARRANTY; without even the implied warranty of\n-#MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-#GNU General Public License for more details.\n-\n-#You should have received a copy of the GNU General Public License\n-#along with GNU CC; see the file COPYING.  If not, write to\n-#the Free Software Foundation, 59 Temple Place - Suite 330,\n-#Boston, MA 02111-1307, USA.  */\n-\n-# Configure looks for the existence of this file to auto-config each language.\n-# We define several parameters used by configure:\n-#\n-# language\t- name of language as it would appear in $(LANGUAGES)\n-# compilers\t- value to add to $(COMPILERS)\n-# stagestuff\t- files to add to $(STAGESTUFF)\n-\n-language=\"CHILL\"\n-\n-compilers=\"cc1chill\\$(exeext)\"\n-\n-stagestuff=\"chill chill-cross\\$(exeext) cc1chill\\$(exeext)\"\n-\n-outputs=ch/Makefile\n-\n-target_libs=target-libchill\n-\n-build_by_default=no"}, {"sha": "3a4a8be0119a3eb1203014ae1d7cfdeb67447b3a", "filename": "gcc/ch/convert.c", "status": "removed", "additions": 0, "deletions": 1247, "changes": 1247, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41823c5eb7d4504b6a4a396ca0d64573238fbbcf/gcc%2Fch%2Fconvert.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41823c5eb7d4504b6a4a396ca0d64573238fbbcf/gcc%2Fch%2Fconvert.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fconvert.c?ref=41823c5eb7d4504b6a4a396ca0d64573238fbbcf", "patch": "@@ -1,1247 +0,0 @@\n-/* Language-level data type conversion for GNU CHILL.\n-   Copyright (C) 1992, 1993, 1994, 1998, 1999, 2000, 2001\n-   Free Software Foundation, Inc.\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-\n-/* This file contains the functions for converting CHILL expressions\n-   to different data types.  The only entry point is `convert'.\n-   Every language front end must have a `convert' function\n-   but what kind of conversions it does will depend on the language.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"tree.h\"\n-#include \"ch-tree.h\"\n-#include \"flags.h\"\n-#include \"convert.h\"\n-#include \"lex.h\"\n-#include \"toplev.h\"\n-#include \"output.h\"\n-\n-extern tree bit_one_node, bit_zero_node;\n-extern tree string_one_type_node;\n-extern tree bitstring_one_type_node;\n-\n-static tree convert_to_reference\tPARAMS ((tree, tree));\n-static tree convert_to_boolean\t\tPARAMS ((tree, tree));\n-static tree convert_to_char\t\tPARAMS ((tree, tree));\n-#if 0\n-static tree base_type_size_in_bytes\tPARAMS ((tree));\n-#endif\n-static tree remove_tree_element\t\tPARAMS ((tree, tree *));\n-static tree check_ps_range\t\tPARAMS ((tree, tree, tree));\n-static tree digest_powerset_tuple\tPARAMS ((tree, tree));\n-static tree digest_structure_tuple\tPARAMS ((tree, tree));\n-static tree digest_array_tuple\t\tPARAMS ((tree, tree, int));\n-static tree convert1\t\t\tPARAMS ((tree, tree));\n-\f\n-static tree\n-convert_to_reference (reftype, expr)\n-     tree reftype, expr;\n-{\n-  while (TREE_CODE (expr) == NOP_EXPR)  /* RETYPE_EXPR */\n-    expr = TREE_OPERAND (expr, 0);\n-\n-  if (! CH_LOCATION_P (expr))\n-    error(\"internal error: trying to make loc-identity with non-location\");\n-  else\n-    {\n-      mark_addressable (expr);\n-      return fold (build1 (ADDR_EXPR, reftype, expr));\n-    }\n-\n-  return error_mark_node;\n-}\n-\n-tree\n-convert_from_reference (expr)\n-     tree expr;\n-{\n-  tree e = build1 (INDIRECT_REF, TREE_TYPE (TREE_TYPE (expr)), expr);\n-  TREE_READONLY (e) = TREE_READONLY (expr);\n-  return e;\n-}\n-\n-/* Convert EXPR to a boolean type.  */\n-\n-static tree\n-convert_to_boolean (type, expr)\n-     tree type, expr;\n-{\n-  register tree intype = TREE_TYPE (expr);\n-  \n-  if (integer_zerop (expr))\n-    return boolean_false_node;\n-  if (integer_onep (expr))\n-    return boolean_true_node;\n-\n-  /* Convert a singleton bitstring to a Boolean.\n-     Needed if flag_old_strings. */\n-  if (CH_BOOLS_ONE_P (intype))\n-    {\n-      if (TREE_CODE (expr) == CONSTRUCTOR)\n-\t{\n-\t  tree valuelist = TREE_OPERAND (expr, 1);\n-\t  if (valuelist == NULL_TREE)\n-\t    return boolean_false_node;\n-\t  if (TREE_CHAIN (valuelist) == NULL_TREE\n-\t      && TREE_PURPOSE (valuelist) == NULL_TREE\n-\t      && integer_zerop (TREE_VALUE (valuelist)))\n-\t    return boolean_true_node;\n-\t}\n-      return build_chill_bitref (expr,\n-\t\t\t\t build_tree_list (NULL_TREE,\n-\t\t\t\t\t\t  integer_zero_node));\n-    }\n-\n-  if (INTEGRAL_TYPE_P (intype))\n-    return build1 (CONVERT_EXPR, type, expr);\n-\n-  error (\"cannot convert to a boolean mode\");\n-  return boolean_false_node;\n-}\n-\n-/* Convert EXPR to a char type.  */\n-\n-static tree\n-convert_to_char (type, expr)\n-     tree type, expr;\n-{\n-  register tree intype = TREE_TYPE (expr);\n-  register enum chill_tree_code form = TREE_CODE (intype);\n-  \n-  if (form == CHAR_TYPE)\n-    return build1 (NOP_EXPR, type, expr);\n-\n-  /* Convert a singleton string to a char.\n-     Needed if flag_old_strings. */\n-  if (CH_CHARS_ONE_P (intype))\n-    {\n-      if (TREE_CODE (expr) == STRING_CST)\n-\t{\n-\t  expr = build_int_2 ((unsigned char)TREE_STRING_POINTER(expr)[0], 0);\n-\t  TREE_TYPE (expr) = char_type_node;\n-\t  return expr;\n-\t}\n-      else\n-\treturn build (ARRAY_REF, char_type_node, expr, integer_zero_node);\n-\n-    }\n-\n-  /* For now, assume it will always fit */\n-  if (form == INTEGER_TYPE)\n-    return build1 (CONVERT_EXPR, type, expr);\n-\n-  error (\"cannot convert to a char mode\");\n-\n-  {\n-    register tree tem = build_int_2 (0, 0);\n-    TREE_TYPE (tem) = type;\n-    return tem;\n-  }\n-}\n-\f\n-#if 0\n-static tree\n-base_type_size_in_bytes (type)\n-     tree type;\n-{\n-  if (type == NULL_TREE\n-      || TREE_CODE (type) == ERROR_MARK\n-      || TREE_CODE (type) != ARRAY_TYPE)\n-    return error_mark_node;\n-  return size_in_bytes (TREE_TYPE (type));\n-}\n-#endif\n-\n-/*\n- * build a singleton array type, of TYPE objects.\n- */\n-tree\n-build_array_type_for_scalar (type)\n-     tree type;\n-{\n-  /* KLUDGE */\n-  if (type == char_type_node)\n-    return build_string_type (type, integer_one_node);\n-\n-  if (type == NULL_TREE || TREE_CODE (type) == ERROR_MARK)\n-    return error_mark_node;\n-\n-  return build_chill_array_type\n-    (type,\n-     tree_cons (NULL_TREE,\n-\t\tbuild_chill_range_type (NULL_TREE,\n-\t\t\t\t\tinteger_zero_node, integer_zero_node),\n-\t\tNULL_TREE),\n-     0, NULL_TREE);\n-\n-}\n-\f\n-#if 0\n-static tree\n-unreferenced_type_of (type)\n-     tree type;\n-{\n-  if (type == NULL_TREE || TREE_CODE (type) == ERROR_MARK)\n-    return error_mark_node;\n-  while (TREE_CODE (type) == REFERENCE_TYPE)\n-    type = TREE_TYPE (type);\n-  return type;\n-}\n-#endif\n-\n-\n-/* Remove from *LISTP the first TREE_LIST node whose TREE_PURPOSE == KEY.\n-   Return the TREE_LIST node, or NULL_TREE on failure. */\n-\n-static tree\n-remove_tree_element (key, listp)\n-     tree *listp;\n-     tree key;\n-{\n-  tree node = *listp;\n-  for ( ; node; listp = &TREE_CHAIN (node), node = *listp)\n-    {\n-      if (TREE_PURPOSE (node) == key)\n-\t{\n-\t  *listp = TREE_CHAIN (node);\n-\t  TREE_CHAIN (node) = NULL_TREE;\n-\t  return node;\n-\t}\n-    }\n-  return NULL_TREE;\n-}\n-\n-/* This is quite the same as check_range in actions.c, but with\n-   different error message. */\n-\n-static tree\n-check_ps_range (value, lo_limit, hi_limit)\n-     tree value;\n-     tree lo_limit;\n-     tree hi_limit;\n-{\n-  tree check = test_range (value, lo_limit, hi_limit);\n-\n-  if (!integer_zerop (check))\n-    {\n-      if (TREE_CODE (check) == INTEGER_CST)\n-\t{\n-\t  error (\"powerset tuple element out of range\");\n-\t  return error_mark_node;\n-\t}\n-      else\n-\tvalue = check_expression (value, check,\n-\t\t\t\t  ridpointers[(int) RID_RANGEFAIL]);\n-    }\n-  return value;\n-}\n-\n-static tree\n-digest_powerset_tuple (type, inits)\n-     tree type;\n-     tree inits;\n-{\n-  tree list;\n-  tree result;\n-  tree domain = TYPE_DOMAIN (type);\n-  int i = 0;\n-  int is_erroneous = 0, is_constant = 1, is_simple = 1;\n-  if (domain == NULL_TREE || TREE_CODE (domain) == ERROR_MARK)\n-    return error_mark_node;\n-  for (list = TREE_OPERAND (inits, 1);  list; list = TREE_CHAIN (list), i++)\n-    {\n-      tree val = TREE_VALUE (list);\n-      if (TREE_CODE (val) == ERROR_MARK)\n-\t{\n-\t  is_erroneous = 1;\n-\t  continue;\n-\t}\n-      if (!TREE_CONSTANT (val))\n-\tis_constant = 0;\n-      else if (!initializer_constant_valid_p (val, TREE_TYPE (val)))\n-\tis_simple = 0;\n-      if (! CH_COMPATIBLE (val, domain))\n-\t{\n-\t  error (\"incompatible member of powerset tuple (at position #%d)\", i);\n-\t  is_erroneous = 1;\n-\t  continue;\n-\t}\n-      /* check range of value */\n-      val = check_ps_range (val, TYPE_MIN_VALUE (domain),\n-\t\t\t    TYPE_MAX_VALUE (domain));\n-      if (TREE_CODE (val) == ERROR_MARK)\n-\t{\n-\t  is_erroneous = 1;\n-\t  continue;\n-\t}\n-\n-      /* Updating the list in place is in principle questionable,\n-\t but I can't think how it could hurt. */\n-      TREE_VALUE (list) = convert (domain, val);\n-\n-      val = TREE_PURPOSE (list);\n-      if (val == NULL_TREE)\n-\tcontinue;\n-\n-      if (TREE_CODE (val) == ERROR_MARK)\n-\t{\n-\t  is_erroneous = 1;\n-\t  continue;\n-\t}\n-      if (! CH_COMPATIBLE (val, domain))\n-\t{\n-\t  error (\"incompatible member of powerset tuple (at position #%d)\", i);\n-\t  is_erroneous = 1;\n-\t  continue;\n-\t}\n-      val = check_ps_range (val, TYPE_MIN_VALUE (domain),\n-\t\t\t    TYPE_MAX_VALUE (domain));\n-      if (TREE_CODE (val) == ERROR_MARK)\n-\t{\n-\t  is_erroneous = 1;\n-\t  continue;\n-\t}\n-      TREE_PURPOSE (list) = convert (domain, val);\n-      if (!TREE_CONSTANT (val))\n-\tis_constant = 0;\n-      else if (!initializer_constant_valid_p (val, TREE_TYPE (val)))\n-\tis_simple = 0;\n-    }\n-  result = build (CONSTRUCTOR, type, NULL_TREE, TREE_OPERAND (inits, 1));\n-  if (is_erroneous)\n-    return error_mark_node;\n-  if (is_constant)\n-    TREE_CONSTANT (result) = 1;\n-  if (is_constant && is_simple)\n-    TREE_STATIC (result) = 1;\n-  return result;\n-}\n-\n-static tree\n-digest_structure_tuple (type, inits)\n-     tree type;\n-     tree inits;\n-{\n-  tree elements = CONSTRUCTOR_ELTS (inits);\n-  tree values = NULL_TREE;\n-  int is_constant = 1;\n-  int is_simple = 1;\n-  int is_erroneous = 0;\n-  tree field;\n-  int labelled_elements = 0;\n-  int unlabelled_elements = 0;\n-  for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n-    {\n-      if (TREE_CODE (TREE_TYPE (field)) != UNION_TYPE)\n-\t{ /* Regular fixed field. */\n-\t  tree value = remove_tree_element (DECL_NAME (field), &elements);\n-\n-\t  if (value)\n-\t    labelled_elements++;\n-\t  else if (elements && TREE_PURPOSE (elements) == NULL_TREE)\n-\t    {\n-\t      value = elements;\n-\t      elements = TREE_CHAIN (elements);\n-\t      unlabelled_elements++;\n-\t    }\n-\n-\t  if (value)\n-\t    {\n-\t      tree val;\n-\t      char msg[120];\n-\t      sprintf (msg, \"initializer for field `%.80s'\",\n-\t\t       IDENTIFIER_POINTER (DECL_NAME (field)));\n-\t      val = chill_convert_for_assignment (TREE_TYPE (field),\n-\t\t\t\t\t\t  TREE_VALUE (value), msg);\n-\t      if (TREE_CODE (val) == ERROR_MARK)\n-\t\t  is_erroneous = 1;\n-\t      else\n-\t\t{\n-\t\t  TREE_VALUE (value) = val;\n-\t\t  TREE_CHAIN (value) = values;\n-\t\t  TREE_PURPOSE (value) = field;\n-\t\t  values = value;\t\n-\t\t  if (TREE_CODE (val) == ERROR_MARK)\n-\t\t    is_erroneous = 1;\n-\t\t  else if (!TREE_CONSTANT (val))\n-\t\t    is_constant = 0;\n-\t\t  else if (!initializer_constant_valid_p (val,\n-\t\t\t\t\t\t\t  TREE_TYPE (val)))\n-\t\t    is_simple = 0;\n-\t\t}\n-\t    }\n-\t  else\n-\t    {\n-\t      pedwarn (\"no initializer value for fixed field `%s'\",\n-\t\t       IDENTIFIER_POINTER (DECL_NAME (field)));\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  tree variant;\n-\t  tree selected_variant = NULL_TREE;\n-\t  tree variant_values = NULL_TREE;\n-\n-\t  /* In a tagged variant structure mode, try to figure out\n-\t     (from the fixed fields), which is the selected variant. */\n-\t  if (TYPE_TAGFIELDS (TREE_TYPE (field)))\n-\t    {\n-\t      for (variant = TYPE_FIELDS (TREE_TYPE (field));\n-\t\t   variant; variant = TREE_CHAIN (variant))\n-\t\t{\n-\t\t  tree tag_labels = TYPE_TAG_VALUES (TREE_TYPE (variant));\n-\t\t  tree tag_fields = TYPE_TAGFIELDS (TREE_TYPE (field));\n-\t\t  if (DECL_NAME (variant) == ELSE_VARIANT_NAME)\n-\t\t    {\n-\t\t      selected_variant = variant;\n-\t\t      break;\n-\t\t    }\n-\t\t  for (; tag_labels && tag_fields;\n-\t\t       tag_labels = TREE_CHAIN (tag_labels),\n-\t\t       tag_fields = TREE_CHAIN (tag_fields))\n-\t\t    {\n-\t\t      tree tag_value = values;\n-\t\t      int found = 0;\n-\t\t      tree tag_decl = TREE_VALUE (tag_fields);\n-\t\t      tree tag_value_set = TREE_VALUE (tag_labels);\n-\t\t      for ( ; tag_value; tag_value = TREE_CHAIN (tag_value))\n-\t\t\t{\n-\t\t\t  if (TREE_PURPOSE (tag_value) == tag_decl)\n-\t\t\t    {\n-\t\t\t      tag_value = TREE_VALUE (tag_value);\n-\t\t\t      break;\n-\t\t\t    }\n-\t\t\t}\n-\t\t      if (!tag_value || TREE_CODE (tag_value) != INTEGER_CST)\n-\t\t\t{\n-\t\t\t  pedwarn (\"non-constant value for tag field `%s'\",\n-\t\t\t\t   IDENTIFIER_POINTER (DECL_NAME (tag_decl)));\n-\t\t\t  goto get_values;\n-\t\t\t}\n-\n-\t\t      /* Check if the value of the tag (as given in a\n-\t\t\t previous field) matches the case label list. */\n-\t\t      for (; tag_value_set;\n-\t\t\t   tag_value_set = TREE_CHAIN (tag_value_set))\n-\t\t\t{\n-\t\t\t  if (tree_int_cst_equal (TREE_VALUE (tag_value_set),\n-\t\t\t\t\t\t  tag_value))\n-\t\t\t    {\n-\t\t\t      found = 1;\n-\t\t\t      break;\n-\t\t\t    }\n-\t\t\t}\n-\t\t      if (!found)\n-\t\t\tbreak;\n-\t\t    }\n-\t\t  if (!tag_fields)\n-\t\t    {\n-\t\t      selected_variant = variant;\n-\t\t      break;\n-\t\t    }\n-\t\t}\n-\t    }\n-\tget_values:\n-\t  for (variant = TYPE_FIELDS (TREE_TYPE (field));\n-\t       variant; variant = TREE_CHAIN (variant))\n-\t    {\n-\t      tree vfield0 = TYPE_FIELDS (TREE_TYPE (variant)); \n-\t      tree vfield;\n-\t      for (vfield = vfield0; vfield;  vfield = TREE_CHAIN (vfield))\n-\t\t{\n-\t\t  tree value = remove_tree_element (DECL_NAME (vfield),\n-\t\t\t\t\t\t    &elements);\n-\n-\t\t  if (value)\n-\t\t    labelled_elements++;\n-\t\t  else if (variant == selected_variant\n-\t\t\t   && elements && TREE_PURPOSE (elements) == NULL_TREE)\n-\t\t    {\n-\t\t      value = elements;\n-\t\t      elements = TREE_CHAIN (elements);\n-\t\t      unlabelled_elements++;\n-\t\t    }\n-\n-\t\t  if (value)\n-\t\t    {\n-\t\t      if (selected_variant && selected_variant != variant)\n-\t\t\t{\n-\t\t\t  error (\"field `%s' in wrong variant\",\n-\t\t\t\t IDENTIFIER_POINTER (DECL_NAME (vfield)));\n-\t\t\t  is_erroneous = 1;\n-\t\t\t}\n-\t\t      else\n-\t\t\t{\n-\t\t\t  if (!selected_variant && vfield != vfield0)\n-\t\t\t    pedwarn (\"missing variant fields (at least `%s')\",\n-\t\t\t\t     IDENTIFIER_POINTER (DECL_NAME (vfield0)));\n-\t\t\t  selected_variant = variant;\n-\t\t\t  if (CH_COMPATIBLE (TREE_VALUE (value),\n-\t\t\t\t\t     TREE_TYPE (vfield)))\n-\t\t\t    {\n-\t\t\t      tree val = convert (TREE_TYPE (vfield),\n-\t\t\t\t\t\t  TREE_VALUE (value));\n-\t\t\t      TREE_PURPOSE (value) = vfield;\n-\t\t\t      TREE_VALUE (value) = val;\n-\t\t\t      TREE_CHAIN (value) = variant_values;\n-\t\t\t      variant_values = value;\n-\t\t\t      if (TREE_CODE (val) == ERROR_MARK)\n-\t\t\t\tis_erroneous = 1;\n-\t\t\t      else if (!TREE_CONSTANT (val))\n-\t\t\t\tis_constant = 0;\n-\t\t\t      else if (!initializer_constant_valid_p\n-\t\t\t\t       (val, TREE_TYPE (val)))\n-\t\t\t\tis_simple = 0;\n-\t\t\t    }\n-\t\t\t  else\n-\t\t\t    {\n-\t\t\t      is_erroneous = 1;\n-\t\t\t      error (\"bad initializer for field `%s'\",\n-\t\t\t\t     IDENTIFIER_POINTER (DECL_NAME (vfield)));\n-\t\t\t    }\n-\t\t\t}\n-\t\t    }\n-\t\t  else if (variant == selected_variant)\n-\t\t    {\n-\t\t      pedwarn (\"no initializer value for variant field `%s'\",\n-\t\t\t       IDENTIFIER_POINTER (DECL_NAME (field)));\n-\t\t    }\n-\t\t}\n-\t    }\n-\t  if (selected_variant == NULL_TREE)\n-\t    pedwarn (\"no selected variant\");\n-\t  else\n-\t    {\n-\t      variant_values = build (CONSTRUCTOR,\n-\t\t\t\t      TREE_TYPE (selected_variant),\n-\t\t\t\t      NULL_TREE, nreverse (variant_values));\n-\t      variant_values\n-\t\t= build (CONSTRUCTOR, TREE_TYPE (field), NULL_TREE,\n-\t\t\t build_tree_list (selected_variant, variant_values));\n-\t      values = tree_cons (field, variant_values, values);\n-\t    }\n-\t}\n-    }\n-\n-  if (labelled_elements && unlabelled_elements)\n-    pedwarn (\"mixture of labelled and unlabelled tuple elements\");\n-\n-  /* Check for unused initializer elements. */\n-  unlabelled_elements = 0;\n-  for ( ; elements != NULL_TREE; elements = TREE_CHAIN (elements))\n-    {\n-      if (TREE_PURPOSE (elements) == NULL_TREE)\n-\tunlabelled_elements++;\n-      else\n-\t{\n-\t  if (IDENTIFIER_POINTER (TREE_PURPOSE (elements)) == 0)\n-\t    error (\"probably not a structure tuple\");\n-\t  else\n-\t    error (\"excess initializer for field `%s'\",\n-\t\t   IDENTIFIER_POINTER (TREE_PURPOSE (elements)));\n-\t  is_erroneous = 1;\n-\t}\n-    }\n-  if (unlabelled_elements)\n-    {\n-      error (\"excess unnamed initializers\");\n-      is_erroneous = 1;\n-    }\n-\n-  CONSTRUCTOR_ELTS (inits) = nreverse (values);\n-  TREE_TYPE (inits) = type;\n-  if (is_erroneous)\n-    return error_mark_node;\n-  if (is_constant)\n-    TREE_CONSTANT (inits) = 1;\n-  if (is_constant && is_simple)\n-    TREE_STATIC (inits) = 1;\n-  return inits;\n-}\n-\n-/* Return a Chill representation of the INTEGER_CST VAL.\n-   The result may be in a static buffer, */\n-\n-const char *\n-display_int_cst (val)\n-     tree val;\n-{\n-  static char buffer[50];\n-  HOST_WIDE_INT x;\n-  tree fields;\n-  if (TREE_CODE (val) != INTEGER_CST)\n-    return \"<not a constant>\";\n-\n-  x = TREE_INT_CST_LOW (val);\n-\n-  switch (TREE_CODE (TREE_TYPE (val)))\n-    {\n-    case BOOLEAN_TYPE:\n-      if (x == 0)\n-\treturn \"FALSE\";\n-      if (x == 1)\n-\treturn \"TRUE\";\n-      goto int_case;\n-    case CHAR_TYPE:\n-      if (x == '^')\n-\tstrcpy (buffer, \"'^^'\");\n-      else if (x == '\\n')\n-\tstrcpy (buffer, \"'^J'\");\n-      else if (x < ' ' || x > '~')\n-\tsprintf (buffer, \"'^(%u)'\", (unsigned int) x);\n-      else\n-\tsprintf (buffer, \"'%c'\", (char) x);\n-      return buffer;\n-    case ENUMERAL_TYPE:\n-      for (fields = TYPE_VALUES (TREE_TYPE (val)); fields != NULL_TREE;\n-\t   fields = TREE_CHAIN (fields))\n-\t{\n-\t  if (tree_int_cst_equal (TREE_VALUE (fields), val))\n-\t    return IDENTIFIER_POINTER (TREE_PURPOSE (fields));\n-\t}\n-      goto int_case;\n-    case POINTER_TYPE:\n-      if (x == 0)\n-\treturn \"NULL\";\n-      goto int_case;\n-    int_case:\n-    default:\n-      /* This code is derived from print-tree.c:print_code_brief. */\n-      if (TREE_INT_CST_HIGH (val) == 0)\n-\tsprintf (buffer,\n-#if HOST_BITS_PER_WIDE_INT == HOST_BITS_PER_INT\n-\t\t \"%1u\",\n-#else\n-\t\t \"%1lu\",\n-#endif\n-\t\t x);\n-      else if (TREE_INT_CST_HIGH (val) == -1 && TREE_INT_CST_LOW (val) != 0)\n-\tsprintf (buffer,\n-#if HOST_BITS_PER_WIDE_INT == HOST_BITS_PER_INT\n-\t\t \"-%1u\",\n-#else\n-\t\t \"-%1lu\",\n-#endif\n-\t\t -x);\n-      else\n-\tsprintf (buffer,\n-#if HOST_BITS_PER_WIDE_INT == 64\n-#if HOST_BITS_PER_WIDE_INT != HOST_BITS_PER_INT\n-\t\t \"H'%lx%016lx\",\n-#else\n-\t\t \"H'%x%016x\",\n-#endif\n-#else\n-#if HOST_BITS_PER_WIDE_INT != HOST_BITS_PER_INT\n-\t\t \"H'%lx%08lx\",\n-#else\n-\t\t \"H'%x%08x\",\n-#endif\n-#endif\n-\t\t TREE_INT_CST_HIGH (val), TREE_INT_CST_LOW (val));\n-      return buffer;\n-    }\n-}\n-\n-static tree\n-digest_array_tuple (type, init, allow_missing_elements)\n-     tree type;\n-     tree init;\n-     int allow_missing_elements;\n-{\n-  tree element = CONSTRUCTOR_ELTS (init);\n-  int is_constant = 1;\n-  int is_simple = 1;\n-  tree element_type = TREE_TYPE (type);\n-  tree default_value = NULL_TREE;\n-  tree element_list = NULL_TREE;\n-  tree domain_min;\n-  tree domain_max;\n-  tree *ptr = &element_list;\n-  int errors = 0;\n-  int labelled_elements = 0;\n-  int unlabelled_elements = 0;\n-  tree first, last = NULL_TREE;\n-\n-  if (type == NULL_TREE || TREE_CODE (type) == ERROR_MARK)\n-    return error_mark_node;\n-\n-  domain_min = TYPE_MIN_VALUE (TYPE_DOMAIN (type));\n-  domain_max = TYPE_MAX_VALUE (TYPE_DOMAIN (type));\n-\n-  if (domain_min == NULL || TREE_CODE (domain_min) != INTEGER_CST)\n-    {\n-      error (\"non-constant start index for tuple\");\n-      return error_mark_node;\n-    }\n-  if (TREE_CODE (domain_max) != INTEGER_CST)\n-    is_constant = 0;\n-\n-  if (TREE_CODE (type) != ARRAY_TYPE)\n-    abort ();  \n-\n-  for ( ; element != NULL_TREE; element = TREE_CHAIN (element))\n-    {\n-      tree purpose = TREE_PURPOSE (element);\n-      tree value   = TREE_VALUE (element);\n-\n-      if (purpose == NULL_TREE)\n-\t{\n-\t  if (last == NULL_TREE)\n-\t    first = domain_min;\n-\t  else\n-\t    {\n-\t      HOST_WIDE_INT new_lo, new_hi;\n-\t      add_double (TREE_INT_CST_LOW (last), TREE_INT_CST_HIGH (last),\n-\t\t\t  1, 0,\n-\t\t\t  &new_lo, &new_hi);\n-\t      first = build_int_2 (new_lo, new_hi);\n-\t      TREE_TYPE (first) = TYPE_DOMAIN (type);\n-\t    }\n-\t  last = first;\n-\t  unlabelled_elements++;\n-\t}\n-      else\n-\t{\n-\t  labelled_elements++;\n-\t  if (TREE_CODE (purpose) == INTEGER_CST)\n-\t    first = last = purpose;\n-\t  else if (TREE_CODE (purpose) == TYPE_DECL\n-\t\t   && discrete_type_p (TREE_TYPE (purpose)))\n-\t    {\n-\t      first = TYPE_MIN_VALUE (TREE_TYPE (purpose));\n-\t      last = TYPE_MAX_VALUE (TREE_TYPE (purpose));\n-\t    }\n-\t  else if (TREE_CODE (purpose) != RANGE_EXPR)\n-\t    {\n-\t      error (\"invalid array tuple label\");\n-\t      errors++;\n-\t      continue;\n-\t    }\n-\t  else if (TREE_OPERAND (purpose, 0) == NULL_TREE)\n-\t    first = last = NULL_TREE;  /* Default value. */\n-\t  else\n-\t    {\n-\t      first = TREE_OPERAND (purpose, 0);\n-\t      last = TREE_OPERAND (purpose, 1);\n-\t    }\n-\t  if ((first != NULL && TREE_CODE (first) != INTEGER_CST)\n-\t      || (last != NULL && TREE_CODE (last) != INTEGER_CST))\n-\t    {\n-\t      error (\"non-constant array tuple index range\");\n-\t      errors++;\n-\t    }\n-\t}\n-\n-      if (! CH_COMPATIBLE (value, element_type))\n-\t{\n-\t  const char *err_val_name =\n-\t    first ? display_int_cst (first) : \"(default)\";\n-\t  error (\"incompatible array tuple element %s\", err_val_name);\n-\t  value = error_mark_node;\n-\t}\n-      else\n-\tvalue = convert (element_type, value);\n-      if (TREE_CODE (value) == ERROR_MARK)\n-\terrors++;\n-      else if (!TREE_CONSTANT (value))\n-\tis_constant = 0;\n-      else if (!initializer_constant_valid_p (value, TREE_TYPE (value)))\n-\tis_simple = 0;\n-\n-      if (first == NULL_TREE)\n-\t{\n-\t  if (default_value != NULL)\n-\t    {\n-\t      error (\"multiple (*) or (ELSE) array tuple labels\");\n-\t      errors++;\n-\t    }\n-\t  default_value = value;\n-\t  continue;\n-\t}\n-\n-      if (first != last && tree_int_cst_lt (last, first))\n-\t{\n-\t  error (\"empty range in array tuple\");\n-\t  errors++;\n-\t  continue;\n-\t}\n-\n-      ptr = &element_list;\n-\n-#define MAYBE_RANGE_OP(PURPOSE, OPNO) \\\n-  (TREE_CODE (PURPOSE) == RANGE_EXPR ? TREE_OPERAND (PURPOSE, OPNO): PURPOSE)\n-#define CONSTRUCTOR_ELT_LO(ELT) MAYBE_RANGE_OP (TREE_PURPOSE (ELT), 0)\n-#define CONSTRUCTOR_ELT_HI(ELT) MAYBE_RANGE_OP (TREE_PURPOSE (ELT), 1)\n-      while (*ptr && tree_int_cst_lt (last,\n-\t\t\t\t      CONSTRUCTOR_ELT_LO (*ptr)))\n-\tptr = &TREE_CHAIN (*ptr);\n-      if (*ptr && ! tree_int_cst_lt (CONSTRUCTOR_ELT_HI (*ptr), first))\n-\t{\n-\t  const char *err_val_name = display_int_cst (first);\n-\t  error (\"array tuple has duplicate index %s\", err_val_name);\n-\t  errors++;\n-\t  continue;\n-\t}\n-      if ((ptr == &element_list && tree_int_cst_lt (domain_max, last))\n-\t|| (*ptr == NULL_TREE && tree_int_cst_lt (first, domain_min)))\n-\t{\n-\t  if (purpose)\n-\t    error (\"array tuple index out of range\");\n-\t  else if (errors == 0)\n-\t    error (\"too many array tuple values\");\n-\t  errors++;\n-\t  continue;\n-\t}\n-      if (! tree_int_cst_lt (first, last))\n-\tpurpose = first;\n-      else if (purpose == NULL_TREE || TREE_CODE (purpose) != RANGE_EXPR)\n-\tpurpose = build_nt (RANGE_EXPR, first, last);\n-      *ptr = tree_cons (purpose, value, *ptr);\n-    }\n-\n-  element_list = nreverse (element_list);\n-\n-  /* For each missing element, set it to the default value,\n-     if there is one.  Otherwise, emit an error.  */\n-\n-  if (errors == 0\n-      && (!allow_missing_elements || default_value != NULL_TREE))\n-    {\n-      /* Iterate over each *gap* between specified elements/ranges. */\n-      tree prev_elt;\n-      if (element_list &&\n-\t  tree_int_cst_equal (CONSTRUCTOR_ELT_LO (element_list), domain_min))\n-\t{\n-\t  ptr = &TREE_CHAIN (element_list);\n-\t  prev_elt = element_list;\n-\t}\n-      else\n-\t{\n-\t  prev_elt = NULL_TREE;\n-\t  ptr = &element_list;\n-\t}\n-      for (;;)\n-\t{\n-\t  tree first, last;\n-\t  /* Calculate the first element of the gap. */\n-\t  if (prev_elt == NULL_TREE)\n-\t    first = domain_min;\n-\t  else\n-\t    {\n-\t      first = CONSTRUCTOR_ELT_HI (prev_elt);\n-\t      if (tree_int_cst_equal (first, domain_max))\n-\t\tbreak; /* We're done.  Avoid overflow below. */\n-\t      first = copy_node (first);\n-\t      add_double (TREE_INT_CST_LOW (first), TREE_INT_CST_HIGH (first),\n-\t\t\t  1, 0,\n-\t\t\t  &TREE_INT_CST_LOW (first),\n-\t\t\t  &TREE_INT_CST_HIGH (first));\n-\t    }\n-\t  /* Calculate the last element of the gap. */\n-\t  if (*ptr)\n-\t    last = fold (build (MINUS_EXPR, integer_type_node,\n-\t\t\t\tCONSTRUCTOR_ELT_LO (*ptr),\n-\t\t\t\tinteger_one_node));\n-\t  else\n-\t    last = domain_max;\n-\n-\t  if (TREE_CODE (last) == INTEGER_CST && tree_int_cst_lt (last, first))\n-\t    ; /* Empty \"gap\" - no missing elements. */\n-\t  else if (default_value)\n-\t    {\n-\t      tree purpose;\n-\t      if (tree_int_cst_equal (first, last))\n-\t\tpurpose = first;\n-\t      else\n-\t\tpurpose = build_nt (RANGE_EXPR, first, last);\n-\t      *ptr = tree_cons (purpose, default_value, *ptr);\n-\t    }\n-\t  else\n-\t    {\n-\t      const char *err_val_name = display_int_cst (first);\n-\t      if (TREE_CODE (last) != INTEGER_CST)\n-\t\terror (\"dynamic array tuple without (*) or (ELSE)\");\n-\t      else if (tree_int_cst_equal (first, last))\n-\t\terror (\"missing array tuple element %s\", err_val_name);\n-\t      else\n-\t\t{\n-\t\t  char *first_name = (char *)\n-\t\t    xmalloc (strlen (err_val_name) + 1);\n-\t\t  strcpy (first_name, err_val_name);\n-\t\t  err_val_name = display_int_cst (last);\n-\t\t  error (\"missing array tuple elements %s : %s\",\n-\t\t\t first_name, err_val_name);\n-\t\t  free (first_name);\n-\t\t}\n-\t      errors++;\n-\t    }\n-\t  if (*ptr == NULL_TREE)\n-\t    break;\n-\t  prev_elt = *ptr;\n-\t  ptr = &TREE_CHAIN (*ptr);\n-\t}\n-    }\n-  if (errors)\n-    return error_mark_node;\n-\n-  element = build (CONSTRUCTOR, type, NULL_TREE, element_list);\n-  TREE_CONSTANT (element) = is_constant;\n-  if (is_constant && is_simple)\n-    TREE_STATIC (element) = 1;\n-  if (labelled_elements && unlabelled_elements)\n-    pedwarn (\"mixture of labelled and unlabelled tuple elements\");\n-  return element;\n-}\n-\f\n-/* This function is needed because no-op CHILL conversions are not fully\n-   understood by the initialization machinery.  This function should only\n-   be called when a conversion truly is a no-op.  */\n-\n-static tree\n-convert1 (type, expr)\n-     tree type, expr;\n-{\n-  int was_constant = TREE_CONSTANT (expr);\n-  STRIP_NOPS (expr);\n-  was_constant |= TREE_CONSTANT (expr);\n-  expr = copy_node (expr);\n-  TREE_TYPE (expr) = type;\n-  if (TREE_CONSTANT (expr) != was_constant) abort ();\n-  TREE_CONSTANT (expr) = was_constant;\n-  return expr;\n-}\n-\n-/* Create an expression whose value is that of EXPR,\n-   converted to type TYPE.  The TREE_TYPE of the value\n-   is always TYPE.  This function implements all reasonable\n-   conversions; callers should filter out those that are\n-   not permitted by the language being compiled.\n-\n-   In CHILL, we assume that the type is Compatible with the\n-   Class of expr, and generally complain otherwise.\n-   However, convert is more general (e.g. allows enum<->int\n-   conversion), so there should probably be at least two routines.\n-   Maybe add something like convert_for_assignment.  FIXME. */\n-\n-tree\n-convert (type, expr)\n-     tree type, expr;\n-{\n-  register tree e = expr;\n-  register enum chill_tree_code code;\n-  int type_varying;\n-\n-  if (e == NULL_TREE || TREE_CODE (e) == ERROR_MARK)\n-    return error_mark_node;\n-\n-  if (type == NULL_TREE || TREE_CODE (type) == ERROR_MARK)\n-    return error_mark_node;\n-\n-  code = TREE_CODE (type);\n-\n-  if (type == TREE_TYPE (e))\n-    return e;\n-\n-  if (TREE_TYPE (e) != NULL_TREE\n-      && TREE_CODE (TREE_TYPE (e)) == REFERENCE_TYPE)\n-    e = convert_from_reference (e);\n-\n-  /* Support for converting *to* a reference type is limited;\n-     it is only here as a convenience for loc-identity declarations,\n-     and loc parameters. */\n-  if (code == REFERENCE_TYPE)\n-    return convert_to_reference (type, e);\n-\n-  /* if expression was untyped because of its context (an if_expr or case_expr\n-     in a tuple, perhaps) just apply the type */\n-  if (TREE_TYPE (e) && TREE_CODE (TREE_TYPE (e)) == ERROR_MARK)\n-    {\n-      TREE_TYPE (e) = type;\n-      return e;\n-    }\n-\n-  /* Turn a NULL keyword into [0, 0] for an instance */\n-  if (CH_IS_INSTANCE_MODE (type) && expr == null_pointer_node)\n-    {\n-      tree field0 = TYPE_FIELDS (type);\n-      tree field1 = TREE_CHAIN (field0);\n-      e = build (CONSTRUCTOR, type, NULL_TREE,\n-\t\t tree_cons (field0, integer_zero_node,\n-\t\t\t    tree_cons (field1, integer_zero_node,\n-\t\t\t\t       NULL_TREE)));\n-      TREE_CONSTANT (e) = 1;\n-      TREE_STATIC (e) = 1;\n-      return e;\n-    }\n-\n-  /* Turn a pointer into a function pointer for a procmode */\n-  if (TREE_CODE (type) == POINTER_TYPE\n-      && TREE_CODE (TREE_TYPE (type)) == FUNCTION_TYPE\n-      && expr == null_pointer_node)\n-    return convert1 (type, expr);\n-\n-  /* turn function_decl expression into a pointer to \n-     that function */\n-  if (TREE_CODE (expr) == FUNCTION_DECL\n-      && TREE_CODE (type) == POINTER_TYPE\n-      && TREE_CODE (TREE_TYPE (type)) == FUNCTION_TYPE)\n-    {\n-      e = build1 (ADDR_EXPR, type, expr);\n-      TREE_CONSTANT (e) = 1;\n-      return e;\n-    }\n-\n-  if (TREE_TYPE (e) && TREE_CODE (TREE_TYPE (e)) == RECORD_TYPE)\n-    e = varying_to_slice (e);\n-  type_varying   = chill_varying_type_p (type);\n-\n-  /* Convert a char to a singleton string.\n-     Needed for compatibility with 1984 version of Z.200. */\n-  if (TREE_TYPE (e) && TREE_CODE (TREE_TYPE (e)) == CHAR_TYPE\n-      && (CH_CHARS_ONE_P (type) || type_varying))\n-    {\n-      if (TREE_CODE (e) == INTEGER_CST)\n-\t{\n-\t  char ch = TREE_INT_CST_LOW (e);\n-\t  e = build_chill_string (1, &ch);\n-\t}\n-      else\n-\te = build (CONSTRUCTOR, string_one_type_node, NULL_TREE,\n-\t\t   tree_cons (NULL_TREE, e, NULL_TREE));\n-    }\n-\n-  /* Convert a Boolean to a singleton bitstring.\n-     Needed for compatibility with 1984 version of Z.200. */\n-  if (TREE_TYPE (e) && TREE_CODE (TREE_TYPE (e)) == BOOLEAN_TYPE\n-      && (CH_BOOLS_ONE_P (type) || type_varying))\n-    {\n-      if (TREE_CODE (e) == INTEGER_CST)\n-\te = integer_zerop (e) ? bit_zero_node : bit_one_node;\n-      else\n-\te = build (COND_EXPR, bitstring_one_type_node,\n-\t\t   e, bit_one_node, bit_zero_node);\n-    }\n-\n-  if (type_varying)\n-    {\n-      tree nentries;\n-      tree field0 = TYPE_FIELDS (type);\n-      tree field1 = TREE_CHAIN (field0);\n-      tree orig_e = e;\n-      tree target_array_type = TREE_TYPE (field1);\n-      tree needed_padding;\n-      tree padding_max_size = 0;\n-      int orig_e_constant = TREE_CONSTANT (orig_e);\n-      if (TREE_TYPE (e) != NULL_TREE\n-\t  && TREE_CODE (TREE_TYPE (e)) == ARRAY_TYPE)\n-\t{\n-\t  /* Note that array_type_nelts returns 1 less than the size. */\n-\t  nentries = array_type_nelts (TREE_TYPE (e));\n-\t  needed_padding = fold (build (MINUS_EXPR, integer_type_node,\n-\t\t\t\t\tarray_type_nelts (target_array_type),\n-\t\t\t\t\tnentries));\n-\t  if (TREE_CODE (needed_padding) != INTEGER_CST)\n-\t    {\n-\t      padding_max_size = size_in_bytes (TREE_TYPE (e));\n-\t      if (TREE_CODE (padding_max_size) != INTEGER_CST)\n-\t\tpadding_max_size = TYPE_ARRAY_MAX_SIZE (TREE_TYPE (e));\n-\t    }\n-\t  nentries = fold (build (PLUS_EXPR, integer_type_node,\n-\t\t\t\t  nentries, integer_one_node));\n-\t}\n-      else if (TREE_CODE (e) == CONSTRUCTOR)\n-\t{\n-\t  HOST_WIDE_INT init_cnt = 0;\n-\t  tree chaser = CONSTRUCTOR_ELTS (e);\n-\t  for ( ; chaser; chaser = TREE_CHAIN (chaser))\n-\t    init_cnt++;               /* count initializer elements */\n-\t  nentries = build_int_2 (init_cnt, 0);\n-\t  needed_padding = integer_zero_node;\n-\t  if (TREE_TYPE (e) == NULL_TREE)\n-\t    e = digest_array_tuple (TREE_TYPE (field1), e, 1);\n-\t  orig_e_constant = TREE_CONSTANT (e);\n-\t}\n-      else\n-\t{\n-\t  error (\"initializer is not an array or string mode\");\n-\t  return error_mark_node;\n-\t}\n-      /* FIXME check that nentries will fit in type; */\n-      if (!integer_zerop (needed_padding))\n-\t{\n-\t  tree padding, padding_type, padding_range;\n-\t  if (TREE_CODE (needed_padding) == INTEGER_CST\n-\t      && (long)TREE_INT_CST_LOW (needed_padding) < 0)\n-\t    {\n-\t      error (\"destination is too small\");\n-\t      return error_mark_node;\n-\t    }\n-\t  padding_range = build_chill_range_type (NULL_TREE, integer_one_node,\n-\t\t\t\t\t\t  needed_padding);\n-\t  padding_type\n-\t    = build_simple_array_type (TREE_TYPE (target_array_type),\n-\t\t\t\t       padding_range, NULL_TREE);\n-\t  TYPE_ARRAY_MAX_SIZE (padding_type) = padding_max_size;\n-\t  if (CH_CHARS_TYPE_P (target_array_type))\n-\t    MARK_AS_STRING_TYPE (padding_type);\n-\t  padding = build (UNDEFINED_EXPR, padding_type);\n-\t  if (TREE_CONSTANT (e))\n-\t    e = build_chill_binary_op (CONCAT_EXPR, e, padding);\n-\t  else\n-\t    e = build (CONCAT_EXPR, target_array_type, e, padding);\n-\t}\n-      e = convert (TREE_TYPE (field1), e);\n-      /* We build this constructor by hand (rather than going through\n-\t digest_structure_tuple), to avoid some type-checking problem.\n-\t E.g. type may have non-null novelty, but its field1 will\n-\t have non-novelty. */\n-      e = build (CONSTRUCTOR, type, NULL_TREE,\n-\t\t    tree_cons (field0, nentries,\n-\t\t\t       build_tree_list (field1, e)));\n-      /* following was wrong, cause orig_e never will be TREE_CONSTANT. e\n-\t may become constant after digest_array_tuple. */\n-      if (TREE_CONSTANT (nentries) && orig_e_constant) /* TREE_CONSTANT (orig_e)) */\n-\t{\n-\t  TREE_CONSTANT (e) = 1;\n-\t  if (TREE_STATIC (nentries) && TREE_STATIC (orig_e))\n-\t    TREE_STATIC (e) = 1;\n-\t}\n-    }\n-  if (TREE_TYPE (e) == NULL_TREE)\n-    {\n-      if (TREE_CODE (e) == CONSTRUCTOR)\n-\t{\n-\t  if (TREE_CODE (type) == SET_TYPE)\n-\t    return digest_powerset_tuple (type, e);\n-\t  else if (TREE_CODE (type) == RECORD_TYPE)\n-\t    return digest_structure_tuple (type, e);\n-\t  else if (TREE_CODE (type) == ARRAY_TYPE)\n-\t    return digest_array_tuple (type, e, 0);\n-\t  else\n-\t    abort ();\n-\t}\n-      else if (TREE_CODE (e) == COND_EXPR)\n-\te = build (COND_EXPR, type,\n-\t\t   TREE_OPERAND (e, 0),\n-\t\t   convert (type, TREE_OPERAND (e, 1)),\n-\t\t   convert (type, TREE_OPERAND (e, 2)));\n-      else if (TREE_CODE (e) == CASE_EXPR)\n-\tTREE_TYPE (e) = type;\n-      else\n-\t{\n-\t  error (\"internal error:  unknown type of expression\");\n-\t  return error_mark_node;\n-\t}\n-    }\n-\n-  if (TYPE_MAIN_VARIANT (type) == TYPE_MAIN_VARIANT (TREE_TYPE (e))\n-      || (CH_NOVELTY (type) != NULL_TREE\n-\t  && CH_NOVELTY (type) == CH_NOVELTY (TREE_TYPE (e))))\n-    return convert1 (type, e);\n-\n-  if (TREE_CODE (TREE_TYPE (e)) == VOID_TYPE)\n-    {\n-      error (\"void value not ignored as it ought to be\");\n-      return error_mark_node;\n-    }\n-  if (code == VOID_TYPE)\n-    return build1 (CONVERT_EXPR, type, e);\n-\n-  if (code == SET_TYPE)\n-    return convert1 (type, e);\n-\n-  if (code == INTEGER_TYPE || code == ENUMERAL_TYPE)\n-    {\n-      if (flag_old_strings)\n-\t{\n-\t  if (CH_CHARS_ONE_P (TREE_TYPE (e)))\n-\t    e = convert_to_char (char_type_node, e);\n-\t  else if (CH_BOOLS_ONE_P (TREE_TYPE (e)))\n-\t    e = convert_to_boolean (boolean_type_node, e);\n-\t}\n-      return fold (convert_to_integer (type, e));\n-    }\n-  if (code == POINTER_TYPE)\n-    return fold (convert_to_pointer (type, e));\n-  if (code == REAL_TYPE)\n-    return fold (convert_to_real (type, e));\n-  if (code == BOOLEAN_TYPE)\n-    return fold (convert_to_boolean (type, e));\n-  if (code == CHAR_TYPE)\n-    return fold (convert_to_char (type, e));\n-\n-  if (code == ARRAY_TYPE && TYPE_MODE (type) != TYPE_MODE (TREE_TYPE (e)))\n-    {\n-      /* The mode of the expression is different from that of the type.\n-\t Earlier checks should have tested against different lengths.\n-\t But even if the lengths are the same, it is possible that one\n-\t type is a static type (and hence could be say SImode), while the\n-\t other type is dynamic type (and hence is BLKmode).\n-\t This causes problems when emitting instructions.  */\n-      tree ee = build1 (INDIRECT_REF, type,\n-\t\t\tbuild1 (NOP_EXPR, build_pointer_type (type),\n-\t\t\t\tbuild1 (ADDR_EXPR,\n-\t\t\t\t\tbuild_pointer_type (TREE_TYPE (e)),\n-\t\t\t\t\te)));\n-      TREE_READONLY (ee) = TYPE_READONLY (type);\n-      return ee;\n-    }\n-\n-  /* The default! */\n-  return convert1 (type, e);\n-}\n-\n-/* Return an expression whose value is EXPR, but whose class is CLASS. */\n-\n-tree\n-convert_to_class (class, expr)\n-     struct ch_class class;\n-     tree expr;\n-{\n-  switch (class.kind)\n-    {\n-    case CH_NULL_CLASS:\n-    case CH_ALL_CLASS:\n-      return expr;\n-    case CH_DERIVED_CLASS:\n-      if (TREE_TYPE (expr) != class.mode)\n-\texpr = convert (class.mode, expr);\n-      if (!CH_DERIVED_FLAG (expr))\n-\t{\n-\t  expr = copy_node (expr);\n-\t  CH_DERIVED_FLAG (expr) = 1;\n-\t}\n-      return expr;\n-    case CH_VALUE_CLASS:\n-    case CH_REFERENCE_CLASS:\n-      if (TREE_TYPE (expr) != class.mode)\n-\texpr = convert (class.mode, expr);\n-      if (CH_DERIVED_FLAG (expr))\n-\t{\n-\t  expr = copy_node (expr);\n-\t  CH_DERIVED_FLAG (expr) = 0;\n-\t}\n-      return expr;\n-    }\n-  return expr;\n-}"}, {"sha": "01ca9e6c6bd97dd771f4c9c8776820d69875896c", "filename": "gcc/ch/decl.c", "status": "removed", "additions": 0, "deletions": 4936, "changes": 4936, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41823c5eb7d4504b6a4a396ca0d64573238fbbcf/gcc%2Fch%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41823c5eb7d4504b6a4a396ca0d64573238fbbcf/gcc%2Fch%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fdecl.c?ref=41823c5eb7d4504b6a4a396ca0d64573238fbbcf"}, {"sha": "1c8ef242231e172e977fba90db0ac41a422463ab", "filename": "gcc/ch/except.c", "status": "removed", "additions": 0, "deletions": 707, "changes": 707, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41823c5eb7d4504b6a4a396ca0d64573238fbbcf/gcc%2Fch%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41823c5eb7d4504b6a4a396ca0d64573238fbbcf/gcc%2Fch%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fexcept.c?ref=41823c5eb7d4504b6a4a396ca0d64573238fbbcf", "patch": "@@ -1,707 +0,0 @@\n-/* Exception support for GNU CHILL.\n-   WARNING:  Only works for native (needs setjmp.h)!  FIXME!\n-   Copyright (C) 1992, 1993, 1994, 1998, 1999, 2000, 2001\n-   Free Software Foundation, Inc.\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-\n-/* On Suns this can get you to the right definition if you\n-   set the right value for TARGET.  */\n-#include <setjmp.h>\n-#ifdef sequent\n-/* Can you believe they forgot this?  */\n-#ifndef _JBLEN\n-#define _JBLEN 11\n-#endif\n-#endif\n-\n-#ifndef _JBLEN\n-#define _JBLEN (sizeof(jmp_buf)/sizeof(int))\n-#define _JBLEN_2 _JBLEN+20\n-#else\n-/* if we use i.e. posix threads, this buffer must be longer */\n-#define _JBLEN_2 _JBLEN+20\n-#endif\n-\n-/* On Linux setjmp is __setjmp FIXME: what is for CROSS */\n-#ifndef SETJMP_LIBRARY_NAME\n-#ifdef __linux__\n-#define SETJMP_LIBRARY_NAME \"__setjmp\"\n-#else\n-#define SETJMP_LIBRARY_NAME \"setjmp\"\n-#endif\n-#endif\n-\n-#include \"tree.h\"\n-#include \"ch-tree.h\"\n-#include \"rtl.h\"\n-#include \"toplev.h\"\n-\n-extern int  expand_exit_needed;\n-\n-static tree link_handler_decl;\n-static tree handler_link_pointer_type;\n-static tree unlink_handler_decl;\n-static int exceptions_initialized = 0;\n-static void emit_setup_handler PARAMS ((void));\n-static void initialize_exceptions PARAMS ((void));\n-static tree start_handler_array PARAMS ((void));\n-static void finish_handler_array PARAMS ((void));\n-static tree char_pointer_type_for_handler;\n-\n-/* If this is 1, operations to push and pop on the __exceptionStack\n-   are inline.  The default is is to use a function call, to\n-   allow for a per-thread exception stack. */\n-static int inline_exception_stack_ops = 0;\n-\n-struct handler_state\n-{\n-  struct handler_state *next;\n-\n-  /* Starts at 0, then incremented for every <on-alternative>. */\n-  int prev_on_alternative;\n-\n-  /* If > 0: handler number for ELSE handler. */\n-  int else_handler;\n-\n-  int action_number;\n-\n-  char do_pushlevel;\n-\n-  tree on_alt_list;\n-  tree setjmp_expr;\n-\n-  /* A decl for the static handler array (used to map exception name to int).*/\n-  tree handler_array_decl;\n-\n-  rtx end_label;\n-\n-  /* Used to pass a tree from emit_setup_handler to chill_start_on. */\n-  tree handler_ref;\n-\n-  tree unlink_cleanup;\n-\n-  tree function;\n-\n-  /* flag to indicate that we are currently compiling this handler.\n-     is_handled will need this to determine an unhandled exception */\n-  int compiling;\n-};\n-\n-/* This is incremented by one each time we start an action which\n-   might have an ON-handler.  It is reset between passes. */\n-static int action_number = 0;\n-\n-int action_nesting_level = 0;\n-\n-/* The global_handler_list is constructed in pass 1.  It is not sorted.\n-   It contains one element for each action that actually had an ON-handler.\n-   An element's ACTION_NUMBER matches the action_number\n-   of that action.  The global_handler_list is eaten up during pass 2. */\n-#define ACTION_NUMBER(HANDLER) ((HANDLER)->action_number)\n-struct handler_state *global_handler_list = NULL;\n-\n-/* This is a stack of handlers, one for each nested ON-handler. */\n-static struct handler_state *current_handler = NULL;\n-\n-static struct handler_state *free_handlers = NULL; /* freelist */\n-\n-static tree handler_element_type;\n-static tree handler_link_type;\n-static tree BISJ;\n-static tree jbuf_ident, prev_ident, handlers_ident;\n-static tree exception_stack_decl = 0;\n-\n-/* Chain of cleanups associated with exception handlers.\n-   The TREE_PURPOSE is an INTEGER_CST whose value is the\n-   DECL_ACTION_NESTING_LEVEL (when the handled actions was entered).\n-   The TREE_VALUE is an expression to expand when we exit that action. */\n-\n-static tree cleanup_chain = NULL_TREE;\n-\f\n-#if 0\n-/* Merge the current sequence onto the tail of the previous one. */\n-\n-void\n-pop_sequence ()\n-{\n-  rtx sequence_first = get_insns ();\n-\n-  end_sequence ();\n-  emit_insns (sequence_first);\n-  \n-}\n-#endif\n-\n-/* Things we need to do at the beginning of pass 2. */\n-\n-void\n-except_init_pass_2 ()\n-{\n-  /* First sort the global_handler_list on ACTION_NUMBER.\n-     This will already be in close to reverse order (the exception being\n-     nested ON-handlers), so insertion sort should essentially linear. */\n-\n-  register struct handler_state *old_list = global_handler_list;\n-\n-  /* First add a dummy final element. */\n-  if (free_handlers)\n-    global_handler_list = free_handlers;\n-  else\n-    global_handler_list\n-      = (struct handler_state*) permalloc (sizeof (struct handler_state));\n-  /* Make the final dummy \"larger\" than any other element. */\n-  ACTION_NUMBER (global_handler_list) = action_number + 1;\n-  /* Now move all the elements in old_list over to global_handler_list. */\n-  while (old_list != NULL)\n-    {\n-      register struct handler_state **ptr = &global_handler_list;\n-      /* Unlink from old_list. */\n-      register struct handler_state *current = old_list;\n-      old_list = old_list->next;\n-\n-      while (ACTION_NUMBER (current) > ACTION_NUMBER (*ptr))\n-\tptr = &(*ptr)->next;\n-      /* Link into proper place in global_handler_list (new list). */\n-      current->next = *ptr;\n-      *ptr = current;\n-    }\n-     \n-  /* Don't forget to reset action_number. */\n-  action_number = 0;\n-}\n-\n-/* This function is called at the beginning of an action that might be\n-   followed by an ON-handler.  Chill syntax doesn't let us know if\n-   we actually have an ON-handler until we see the ON, so we save\n-   away during pass 1 that information for use during pass 2. */\n-\n-void\n-push_handler ()\n-{\n-  register struct handler_state *hstate;\n-\n-  action_number++;\n-  action_nesting_level++;\n-\n-  if (pass == 1)\n-    {\n-      if (free_handlers)\n-\t{\n-\t  hstate = free_handlers;\n-\t  free_handlers = hstate->next;\n-\t}\n-      else\n-\t{\n-\t  hstate =\n-\t    (struct handler_state*) permalloc (sizeof (struct handler_state));\n-\t}\n-\n-      hstate->next = current_handler;\n-      current_handler = hstate;\n-      hstate->prev_on_alternative = 0;\n-      hstate->else_handler = 0;\n-      hstate->on_alt_list = NULL_TREE;\n-      hstate->compiling = 0;\n-\n-      ACTION_NUMBER (hstate) = action_number;\n-      return;\n-    }\n-\n-  if (ACTION_NUMBER (global_handler_list) != action_number)\n-    return;\n-\n-  /* OK.  This action actually has an ON-handler.\n-     Pop it from global_handler_list, and use it. */\n-\n-  hstate = global_handler_list;\n-  global_handler_list = hstate->next;\n-\n-  /* Since this is pass 2, let's generate prologue code for that. */\n-\n-  hstate->next = current_handler;\n-  current_handler = hstate;\n-\n-  hstate->prev_on_alternative = 0;\n-  hstate->function = current_function_decl;\n-\n-  emit_setup_handler ();\n-}\n-\n-static tree\n-start_handler_array ()\n-{\n-  tree handler_array_type, decl;\n-\n-  push_obstacks_nochange ();\n-  end_temporary_allocation ();\n-  handler_array_type = build_array_type (handler_element_type, NULL_TREE);\n-  decl = build_lang_decl (VAR_DECL,\n-\t\t\t  get_unique_identifier (\"handler_table\"),\n-\t\t\t  handler_array_type);\n-\n-/*  TREE_TYPE (decl) = handler_array_type;*/\n-  TREE_READONLY (decl) = 1;\n-  TREE_STATIC (decl) = 1;\n-  DECL_INITIAL (decl) = error_mark_node;\n-  \n-  pushdecl (decl);\n-  make_decl_rtl (decl, NULL_PTR, 0);\n-  current_handler->handler_array_decl = decl;\n-  return decl;\n-}\n-\n-static void\n-finish_handler_array ()\n-{\n-  tree decl = current_handler->handler_array_decl;\n-  tree t;\n-  tree handler_array_init = NULL_TREE;\n-  int handlers_count = 1;\n-  int nelts;\n-\n-  /* Build the table mapping exceptions to handler(-number)s.\n-     This is done in reverse order. */\n-  \n-  /* First push the end of the list.  This is either the ELSE\n-     handler (current_handler->else_handler>0) or NULL handler to indicate\n-     the end of the list (if current_handler->else-handler == 0).\n-     The following works either way. */\n-  handler_array_init = build_tree_list\n-    (NULL_TREE, chill_expand_tuple\n-     (handler_element_type,\n-      build_nt (CONSTRUCTOR, NULL_TREE,\n-\t\ttree_cons (NULL_TREE,\n-\t\t\t   null_pointer_node,\n-\t\t\t   build_tree_list (NULL_TREE,\n-\t\t\t\t\t    build_int_2 (current_handler->else_handler,\n-\t\t\t\t\t\t\t     0))))));\n-  \n-  for (t = current_handler->on_alt_list; t != NULL_TREE; t = TREE_CHAIN (t))\n-    { tree handler_number = TREE_PURPOSE(t);\n-      tree elist = TREE_VALUE (t);\n-      for ( ; elist != NULL_TREE; elist = TREE_CHAIN (elist))\n-\t{\n-\t  tree ex_decl =\n-\t    build_chill_exception_decl (IDENTIFIER_POINTER(TREE_VALUE(elist)));\n-\t  tree ex_addr = build1 (ADDR_EXPR,\n-\t\t\t\t char_pointer_type_for_handler,\n-\t\t\t\t ex_decl);\n-\t  tree el = build_nt (CONSTRUCTOR, NULL_TREE,\n-\t\t\t      tree_cons (NULL_TREE,\n-\t\t\t\t\t ex_addr,\n-\t\t\t\t\t build_tree_list (NULL_TREE,\n-\t\t\t\t\t\t\t  handler_number)));\n-\t  mark_addressable (ex_decl);\n-\t  TREE_CONSTANT (ex_addr) = 1;\n-\t  handler_array_init =\n-\t    tree_cons (NULL_TREE,\n-\t\t       chill_expand_tuple (handler_element_type, el),\n-\t\t       handler_array_init);\n-\t  handlers_count++;\n-\t}\n-    }\n-\n-#if 1\n-  nelts = list_length (handler_array_init);\n-  TYPE_DOMAIN (TREE_TYPE (decl))\n-    = build_index_type (build_int_2 (nelts - 1, - (nelts == 0)));\n-  layout_type (TREE_TYPE (decl));\n-  DECL_INITIAL (decl)\n-    = convert (TREE_TYPE (decl),\n-\t       build_nt (CONSTRUCTOR, NULL_TREE, handler_array_init));\n-\n-  /* Pop back to the obstack that is current for this binding level.\n-     This is because MAXINDEX, rtl, etc. to be made below\n-     must go in the permanent obstack.  But don't discard the\n-     temporary data yet.  */\n-  pop_obstacks ();\n-  layout_decl (decl, 0);\n-  /* To prevent make_decl_rtl (called indiectly by rest_of_decl_compilation)\n-     throwing the existing RTL (which has already been used). */\n-  PUT_MODE (DECL_RTL (decl), DECL_MODE (decl));\n-  rest_of_decl_compilation (decl, (char*)0, 0, 0);\n-  expand_decl_init (decl);\n-#else\n-  /* To prevent make_decl_rtl (called indirectly by finish_decl)\n-     altering the existing RTL. */\n-  GET_MODE (DECL_RTL (current_handler->handler_array_decl)) =\n-    DECL_MODE (current_handler->handler_array_decl);\n-\n-  finish_decl (current_handler->handler_array_decl,\n-\t       build_nt (CONSTRUCTOR, NULL_TREE, handler_array_init),\n-\t       NULL_TREE);\n-#endif\n-}\n-\n-\n-void\n-pop_handler (used)\n-     int used;\n-{\n-  action_nesting_level--;\n-  if (pass == 1)\n-    {\n-      struct handler_state *old = current_handler;\n-\n-      if (old == NULL)\n-\tabort ();\n-      current_handler = old->next;\n-\n-      if (used)\n-\t{ /* Push unto global_handler_list. */\n-\t  old->next = global_handler_list;\n-\t  global_handler_list = old;\n-\t}\n-      else\n-\t{\n-\t  /* Push onto free_handlers free list. */\n-\t  old->next = free_handlers;\n-\t  free_handlers = old;\n-\t}\n-    }\n-  else if (used)\n-    {\n-      current_handler = current_handler->next;\n-    }\n-}\n-\n-/* Emit code before an action that has an ON-handler. */\n-\n-static void\n-emit_setup_handler ()\n-{\n-  tree handler_decl, handler_addr, t;\n-\n-  /* Field references. */\n-  tree jbuf_ref, handlers_ref,prev_ref;\n-  if (!exceptions_initialized)\n-    {\n-      /* We temporarily reset the maximum_field_alignment to zero so the\n-\t compiler's exception data structures can be compatible with the\n-\t run-time system, even when we're compiling with -fpack. */\n-      unsigned int save_maximum_field_alignment = maximum_field_alignment;\n-      maximum_field_alignment = 0;\n-      push_obstacks_nochange ();\n-      end_temporary_allocation ();\n-      initialize_exceptions ();\n-      pop_obstacks ();\n-      maximum_field_alignment = save_maximum_field_alignment;\n-    }\n-\n-  push_momentary ();\n-\n-  handler_decl = build_lang_decl (VAR_DECL,\n-\t\t\t\t  get_unique_identifier (\"handler\"),\n-\t\t\t\t  handler_link_type);\n-  push_obstacks_nochange ();\n-  pushdecl(handler_decl);\n-  expand_decl (handler_decl);\n-  finish_decl (handler_decl);\n-\n-  jbuf_ref = build_component_ref (handler_decl, jbuf_ident);\n-  jbuf_ref = build_chill_arrow_expr (jbuf_ref, 1);\n-  handlers_ref = build_component_ref (handler_decl, handlers_ident);\n-  prev_ref = build_component_ref (handler_decl, prev_ident);\n-\n-  /* Emit code to link in handler in __exceptionStack chain. */\n-  mark_addressable (handler_decl);\n-  handler_addr = build1 (ADDR_EXPR, handler_link_pointer_type, handler_decl);\n-  if (inline_exception_stack_ops)\n-    {\n-      expand_expr_stmt (build_chill_modify_expr (prev_ref,\n-\t\t\t\t\t\t exception_stack_decl));\n-      expand_expr_stmt (build_chill_modify_expr (exception_stack_decl,\n-\t\t\t\t\t\t handler_addr));\n-      current_handler->handler_ref = prev_ref;\n-    }\n-  else\n-    {\n-      expand_expr_stmt (build_chill_function_call (link_handler_decl,\n-\t\t\t\t\t     build_tree_list (NULL_TREE,\n-\t\t\t\t\t\t\t      handler_addr)));\n-      current_handler->handler_ref = handler_addr;\n-    }\n-\n-  /* Expand:  handler->__handlers = { <<array mapping names to ints } */\n-  t =  build1 (NOP_EXPR, build_pointer_type (handler_element_type),\n-\t       build_chill_arrow_expr (start_handler_array (), 1));\n-  expand_expr_stmt (build_chill_modify_expr (handlers_ref, t));\n-\n-  /* Emit code to unlink handler. */\n-  if (inline_exception_stack_ops)\n-    current_handler->unlink_cleanup\n-      = build_chill_modify_expr (exception_stack_decl,\n-\t\t\t\t current_handler->handler_ref);\n-  else\n-    current_handler->unlink_cleanup\n-      = build_chill_function_call (unlink_handler_decl,\n-\t\t\t\t   build_tree_list(NULL_TREE,\n-\t\t\t\t\t       current_handler->handler_ref));\n-  cleanup_chain = tree_cons (build_int_2 (action_nesting_level, 0),\n-\t\t\t     current_handler->unlink_cleanup,\n-\t\t\t     cleanup_chain);\n-\n-  /* Emit code for setjmp. */\n-  \n-  current_handler->setjmp_expr =\n-    build_chill_function_call (BISJ, build_tree_list (NULL_TREE, jbuf_ref));\n-  expand_start_case (1, current_handler->setjmp_expr,\n-\t\t     integer_type_node, \"on handler\");\n-\n-  chill_handle_case_label (integer_zero_node, current_handler->setjmp_expr);\n-}\n-\n-/* Start emitting code for: <actions> ON <handlers> END.\n-   Assume we've parsed <actions>, and the setup needed for it. */\n-\n-void\n-chill_start_on ()\n-{\n-  expand_expr_stmt (current_handler->unlink_cleanup);\n-\n-  /* Emit code to jump past the handlers. */\n-  current_handler->end_label = gen_label_rtx ();\n-  current_handler->compiling = 1;\n-  emit_jump (current_handler->end_label);\n-}\n-\n-void\n-chill_finish_on ()\n-{\n-  expand_end_case (current_handler->setjmp_expr);\n-  \n-  finish_handler_array ();\n-\n-  emit_label (current_handler->end_label);\n-\n-  pop_momentary ();\n-\n-  cleanup_chain = TREE_CHAIN (cleanup_chain);\n-}\n-\n-void\n-chill_handle_on_labels (labels)\n-     tree labels;\n-{\n-  unsigned int alternative = ++current_handler->prev_on_alternative;\n-  if (pass == 1)\n-    {\n-      tree handler_number = build_int_2 (alternative, 0);\n-      current_handler->on_alt_list =\n-\ttree_cons (handler_number, labels, current_handler->on_alt_list);\n-    }\n-  else\n-    {\n-      /* Find handler_number saved in pass 1. */\n-      tree tmp;\n-\n-      for (tmp = current_handler->on_alt_list;\n-\t   compare_tree_int (TREE_PURPOSE (tmp), alternative) != 0;\n-\t   tmp = TREE_CHAIN (tmp))\n-\t;\n-\n-      if (expand_exit_needed)\n-\texpand_exit_something (), expand_exit_needed = 0;\n-      chill_handle_case_label (TREE_PURPOSE (tmp),\n-\t\t\t       current_handler->setjmp_expr);\n-    }\n-}\n-\n-void\n-chill_start_default_handler ()\n-{\n-  current_handler->else_handler = ++current_handler->prev_on_alternative;\n-  if (!ignoring)\n-    {\n-      chill_handle_case_default ();\n-    }\n-}\n-\n-void\n-chill_check_no_handlers ()\n-{\n-  if (current_handler != NULL)\n-    abort ();\n-}\n-\n-static void\n-initialize_exceptions ()\n-{\n-  tree jmp_buf_type = build_array_type (integer_type_node,\n-\t\t\t\t\tbuild_index_type (build_int_2 (_JBLEN_2-1, 0)));\n-  tree setjmp_fndecl, link_ftype;\n-  tree parmtypes\n-    = tree_cons (NULL_TREE, build_pointer_type (jmp_buf_type), void_list_node);\n-\n-  setjmp_fndecl = builtin_function (\"setjmp\",\n-\t\t\t\t    build_function_type (integer_type_node,\n-\t\t\t\t\t\t\t parmtypes),\n-\t\t\t\t    0, NOT_BUILT_IN,\n-\t\t\t\t    SETJMP_LIBRARY_NAME);\n-  BISJ = build1 (ADDR_EXPR, build_pointer_type (TREE_TYPE (setjmp_fndecl)),\n-\t\t setjmp_fndecl);\n- \n-  char_pointer_type_for_handler\n-    = build_pointer_type (build_type_variant (char_type_node, 1, 0));\n-  handler_element_type =\n-    build_chill_struct_type (chainon\n-\t\t\t     (build_decl (FIELD_DECL,\n-\t\t\t\t\t  get_identifier(\"__exceptid\"),\n-\t\t\t\t\t  char_pointer_type_for_handler),\n-\t\t\t      build_decl (FIELD_DECL,\n-\t\t\t\t\t  get_identifier(\"__handlerno\"),\n-\t\t\t\t\t  integer_type_node)));\n-\n-  jbuf_ident = get_identifier(\"__jbuf\");\n-  prev_ident = get_identifier(\"__prev\");\n-  handlers_ident = get_identifier(\"__handlers\");\n-\n-  handler_link_type =\n-    build_chill_struct_type\n-      (chainon\n-       (build_decl (FIELD_DECL, prev_ident, ptr_type_node),\n-\tchainon\n-\t(build_decl (FIELD_DECL, handlers_ident,\n-\t\t     build_pointer_type (handler_element_type)),\n-\t build_decl (FIELD_DECL, jbuf_ident, jmp_buf_type))));\n-\n-  handler_link_pointer_type = build_pointer_type (handler_link_type);\n-\n-  if (inline_exception_stack_ops)\n-    {\n-      exception_stack_decl =\n-\tbuild_lang_decl (VAR_DECL,\n-\t\t\t get_identifier(\"__exceptionStack\"),\n-\t\t\t handler_link_pointer_type);\n-      TREE_STATIC (exception_stack_decl) = 1;\n-      TREE_PUBLIC (exception_stack_decl) = 1;\n-      DECL_EXTERNAL (exception_stack_decl) = 1;\n-      push_obstacks_nochange ();\n-      pushdecl(exception_stack_decl);\n-      make_decl_rtl (exception_stack_decl, NULL_PTR, 1);\n-      finish_decl (exception_stack_decl);\n-    }\n-\n-  link_ftype = build_function_type (void_type_node,\n-\t\t\t\t    tree_cons (NULL_TREE,\n-\t\t\t\t\t       handler_link_pointer_type,\n-\t\t\t\t\t       void_list_node));\n-  link_handler_decl = builtin_function (\"__ch_link_handler\", link_ftype,\n-\t\t\t\t\t0, NOT_BUILT_IN, NULL_PTR);\n-  unlink_handler_decl = builtin_function (\"__ch_unlink_handler\", link_ftype,\n-\t\t\t\t\t  0, NOT_BUILT_IN, NULL_PTR);\n-\n-  exceptions_initialized = 1;\n-}\n-\n-/* Do the cleanup(s) needed for a GOTO label.\n-   We only need to do the last of the cleanups. */\n-\n-void\n-expand_goto_except_cleanup (label_level)\n-     int label_level;\n-{\n-  tree list = cleanup_chain;\n-  tree last = NULL_TREE;\n-  for ( ; list != NULL_TREE; list = TREE_CHAIN (list))\n-    {\n-      if (compare_tree_int (TREE_PURPOSE (list), label_level) > 0)\n-\tlast = list;\n-      else\n-\tbreak;\n-    }\n-  if (last)\n-    expand_expr_stmt (TREE_VALUE (last));\n-}\n-\n-/* Returns true if there is a valid handler for EXCEPT_NAME\n-   in the current static scope.\n-   0 ... no handler found\n-   1 ... local handler available\n-   2 ... function may propagate this exception\n-*/\n-\n-int\n-is_handled (except_name)\n-     tree except_name;\n-{\n-  tree t;\n-  struct handler_state *h = current_handler;\n-\n-  /* if we are are currently compiling this handler\n-     we have to start at the next level */\n-  if (h && h->compiling)\n-    h = h->next;\n-  while (h != NULL)\n-    {\n-      if (h->function != current_function_decl)\n-\tbreak;\n-      if (h->else_handler > 0)\n-\treturn 1;\n-      for (t = h->on_alt_list; t != NULL_TREE; t = TREE_CHAIN (t))\n-\t{\n-\t  if (value_member (except_name, TREE_VALUE (t)))\n-\t    return 1;\n-\t}\n-      h = h->next;\n-    }\n-\n-  t = TYPE_RAISES_EXCEPTIONS (TREE_TYPE (current_function_decl));\n-\n-  if (value_member (except_name, t))\n-    return 2;\n-  return 0;\n-}\n-\n-/* function generates code to reraise exceptions\n-   for PROC's propagating exceptions. */\n-\n-void\n-chill_reraise_exceptions (exceptions)\n-     tree exceptions;\n-{\n-  tree wrk;\n-\n-  if (exceptions == NULL_TREE)\n-    return; /* just in case */\n-\n-  if (pass == 1)\n-    {\n-      for (wrk = exceptions; wrk != NULL_TREE; wrk = TREE_CHAIN (wrk))\n-\tchill_handle_on_labels (build_tree_list (NULL_TREE, TREE_VALUE (wrk)));\n-    }\n-  else /* pass == 2 */\n-    {\n-      chill_start_on ();\n-      expand_exit_needed = 0;\n-\n-      for (wrk = exceptions; wrk != NULL_TREE; wrk = TREE_CHAIN (wrk))\n-\t{\n-\t  chill_handle_on_labels (TREE_VALUE (wrk));\n-\t  /* do a CAUSE exception */\n-\t  expand_expr_stmt (build_cause_exception (TREE_VALUE (wrk), 0));\n-\t  expand_exit_needed = 1;\n-\t}\n-      chill_finish_on ();\n-    }\n-  pop_handler (1);\n-}"}, {"sha": "da92ab9614bb70af3d2327db0bcc247f7499e9da", "filename": "gcc/ch/expr.c", "status": "removed", "additions": 0, "deletions": 4512, "changes": 4512, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41823c5eb7d4504b6a4a396ca0d64573238fbbcf/gcc%2Fch%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41823c5eb7d4504b6a4a396ca0d64573238fbbcf/gcc%2Fch%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fexpr.c?ref=41823c5eb7d4504b6a4a396ca0d64573238fbbcf"}, {"sha": "c6edb6803b06de4077e304d1c22310f259e8545f", "filename": "gcc/ch/gperf", "status": "removed", "additions": 0, "deletions": 166, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41823c5eb7d4504b6a4a396ca0d64573238fbbcf/gcc%2Fch%2Fgperf", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41823c5eb7d4504b6a4a396ca0d64573238fbbcf/gcc%2Fch%2Fgperf", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fgperf?ref=41823c5eb7d4504b6a4a396ca0d64573238fbbcf", "patch": "@@ -1,166 +0,0 @@\n-struct resword {\n-  const char  *name;\n-  short        token;\n-  enum rid     rid;\n-  enum toktype { RESERVED, DIRECTIVE, PREDEF } flags;\n-};\n-extern tree ridpointers [];\n-#ifdef __GNUC__\n-__inline\n-#endif\n-static unsigned int hash\tPARAMS ((const char *, unsigned int));\n-#ifdef __GNUC__\n-__inline\n-#endif\n-struct resword *in_word_set\tPARAMS ((const char *, unsigned int));\n-%%\n-access,\t\t\tACCESS,\t\t\tNORID,\tRESERVED\n-after,\t\t\tAFTER,\t\t\tNORID,\tRESERVED\n-all,\t\t\tALL,\t\t\tNORID,\tRESERVED\n-all_static_off,\t\tALL_STATIC_OFF,\t\tNORID,  DIRECTIVE\n-all_static_on,\t\tALL_STATIC_ON,\t\tNORID,\tDIRECTIVE\n-and,\t\t\tAND,\t\t\tNORID,\tRESERVED\n-andif,\t\t\tANDIF,\t\t\tNORID,\tRESERVED\n-array,\t\t\tARRAY,\t\t\tNORID,\tRESERVED\n-asm,\t\t\tASM_KEYWORD,\t\tNORID,\tRESERVED\n-assert,\t\t\tASSERT,\t\t\tNORID,\tRESERVED\n-at,\t\t\tAT,\t\t\tNORID,\tRESERVED\n-based,\t\t\tBASED,\t\t\tNORID,\tRESERVED\n-begin,\t\t\tBEGINTOKEN,\t\tNORID,\tRESERVED\n-bin,\t\t\tBIN,\t\t\tNORID,\tRESERVED\n-bit,\t\t\tBOOLS,\t\t\tRID_BOOLS,\tPREDEF\n-body,\t\t\tBODY,\t\t\tNORID,\tRESERVED\n-bools,\t\t\tBOOLS,\t\t\tRID_BOOLS,\tRESERVED\n-buffer,\t\t\tBUFFER,\t\t\tNORID,\tRESERVED\n-buffer_code,\t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE\n-by,\t\t\tBY,\t\t\tNORID,\tRESERVED\n-call,\t\t\tCALL,\t\t\tNORID,\tRESERVED\n-case,\t\t\tCASE,\t\t\tNORID,\tRESERVED\n-cause,\t\t\tCAUSE,\t\t\tNORID,\tRESERVED\n-ccitt_os,\t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE\n-chars,\t\t\tCHARS,\t\t\tNORID,\tRESERVED\n-context,\t\tCONTEXT,\t\tNORID,\tRESERVED\n-continue,\t\tCONTINUE,\t\tNORID,\tRESERVED\n-cycle,\t\t\tCYCLE,\t\t\tNORID,\tRESERVED\n-dcl,\t\t\tDCL,\t\t\tNORID,\tRESERVED\n-debug_lines,\t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE\n-debug_symbols,\t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE\n-debug_types,\t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE\n-delay,\t\t\tDELAY,\t\t\tNORID,\tRESERVED\n-do,\t\t\tDO,\t\t\tNORID,\tRESERVED\n-down,\t\t\tDOWN,\t\t\tNORID,\tRESERVED\n-dynamic,\t\tDYNAMIC,\t\tRID_DYNAMIC,\tRESERVED\n-else,\t\t\tELSE,\t\t\tNORID,\tRESERVED\n-elsif,\t\t\tELSIF,\t\t\tNORID,\tRESERVED\n-empty_off,\t\tEMPTY_OFF,\t\tNORID,\tDIRECTIVE\n-empty_on,\t\tEMPTY_ON,\t\tNORID,\tDIRECTIVE\n-end,\t\t\tEND,\t\t\tNORID,\tRESERVED\n-esac,\t\t\tESAC,\t\t\tNORID,\tRESERVED\n-even,\t\t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE\n-event,\t\t\tEVENT,\t\t\tNORID,\tRESERVED\n-event_code,\t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE\n-ever,\t\t\tEVER,\t\t\tNORID,\tRESERVED\n-exceptions,\t\tEXCEPTIONS,\t\tNORID,\tRESERVED\n-exit,\t\t\tEXIT,\t\t\tNORID,\tRESERVED\n-extra_const_seg,\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE\n-far,\t\t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE\n-fi,\t\t\tFI,\t\t\tNORID,\tRESERVED\n-for,\t\t\tFOR,\t\t\tNORID,\tRESERVED\n-forbid,\t\t\tFORBID,\t\t\tNORID,\tRESERVED\n-general,\t\tGENERAL,\t\tNORID,\tRESERVED\n-generate_all_set_names,\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE\n-generate_set_names,\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE\n-goto,\t\t\tGOTO,\t\t\tNORID,\tRESERVED\n-grant,\t\t\tGRANT,\t\t\tNORID,\tRESERVED\n-grant_file_size,\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE\n-if,\t\t\tIF,\t\t\tNORID,\tRESERVED\n-in,\t\t\tIN,\t\t\tRID_IN,\tRESERVED\n-init,\t\t\tINIT,\t\t\tNORID,\tRESERVED\n-inline,\t\t\tINLINE,\t\t\tRID_INLINE,\tRESERVED\n-inout,\t\t\tPARAMATTR,\t\tRID_INOUT,\tRESERVED\n-large,\t\t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE\n-list,\t\t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE\n-loc,\t\t\tLOC,\t\t\tNORID,\tRESERVED\n-make_publics_for_discrete_syns,\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE\n-medium,\t\t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE\n-mod,\t\t\tMOD,\t\t\tNORID,\tRESERVED\n-module,\t\t\tMODULE,\t\t\tNORID,\tRESERVED\n-multiple_const_segs,\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE\n-multiple_data_segs,\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE\n-newmode,\t\tNEWMODE,\t\tNORID,\tRESERVED\n-nolist,\t\t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE\n-no_overlap_check,\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE\n-nonref,\t\t\tNONREF,\t\t\tNORID,\tRESERVED\n-nopack,\t\t\tNOPACK,\t\t\tNORID,\tRESERVED\n-not,\t\t\tNOT,\t\t\tNORID,\tRESERVED\n-od,\t\t\tOD,\t\t\tNORID,\tRESERVED\n-of,\t\t\tOF,\t\t\tNORID,\tRESERVED\n-on,\t\t\tON,\t\t\tNORID,\tRESERVED\n-only_for_simulation,\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE\n-only_for_target,\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE\n-optimize,\t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE\n-optimize_runtime,\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE\n-optimization_window,\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE\n-or,\t\t\tOR,\t\t\tNORID,\tRESERVED\n-orif,\t\t\tORIF,\t\t\tNORID,\tRESERVED\n-out,\t\t\tPARAMATTR,\t\tRID_OUT,\tRESERVED\n-pack,\t\t\tPACK,\t\t\tNORID,\tRESERVED\n-page,\t\t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE\n-pos,\t\t\tPOS,\t\t\tNORID,\tRESERVED\n-powerset,\t\tPOWERSET,\t\tNORID,\tRESERVED\n-prefixed,\t\tPREFIXED,\t\tNORID,\tRESERVED\n-print_o_code,\t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE\n-print_symbol_table,\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE\n-priority,\t\tPRIORITY,\t\tNORID,\tRESERVED\n-proc,\t\t\tPROC,\t\t\tNORID,\tRESERVED\n-process,\t\tPROCESS,\t\tNORID,\tRESERVED\n-process_type,\t\tPROCESS_TYPE_TOKEN,\tNORID,\tDIRECTIVE\n-range,\t\t\tRANGE,\t\t\tNORID,\tRESERVED\n-range_off,\t\tRANGE_OFF,\t\tNORID,\tDIRECTIVE\n-range_on,\t\tRANGE_ON,\t\tNORID,\tDIRECTIVE\n-read,\t\t\tREAD,\t\t\tRID_READ,\tRESERVED\n-receive,\t\tRECEIVE,\t\tNORID,\tRESERVED\n-recursive,\t\tRECURSIVE,\t\tNORID,\tRESERVED\n-reentrant,\t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE\n-reentrant_all,\t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE\n-ref,\t\t\tREF,\t\t\tNORID,\tRESERVED\n-region,\t\t\tREGION,\t\t\tNORID,\tRESERVED\n-rem,\t\t\tREM,\t\t\tNORID,\tRESERVED\n-remote,\t\t\tREMOTE,\t\t\tNORID,\tRESERVED\n-result,\t\t\tRESULT,\t\t\tNORID,\tRESERVED\n-return,\t\t\tRETURN,\t\t\tNORID,\tRESERVED\n-returns,\t\tRETURNS,\t\tNORID,\tRESERVED\n-row,\t\t\tROW,\t\t\tNORID,\tRESERVED\n-seize,\t\t\tSEIZE,\t\t\tNORID,\tRESERVED\n-send,\t\t\tSEND,\t\t\tNORID,\tRESERVED\n-send_buffer_default_priority,\tSEND_BUFFER_DEFAULT_PRIORITY,\tNORID,\tDIRECTIVE\n-send_signal_default_priority,\tSEND_SIGNAL_DEFAULT_PRIORITY,\tNORID,\tDIRECTIVE\n-set,\t\t\tSET,\t\t\tNORID,\tRESERVED\n-short_pred_succ,\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE\n-signal,\t\t\tSIGNAL,\t\t\tNORID,\tRESERVED\n-signal_code,\t\tSIGNAL_CODE,\t\tNORID,\tDIRECTIVE\n-signal_max_length,\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE\n-simple,\t\t\tSIMPLE,\t\t\tNORID,\tRESERVED\n-small,\t\t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE\n-spec,\t\t\tSPEC,\t\t\tNORID,\tRESERVED\n-start,\t\t\tSTART,\t\t\tNORID,\tRESERVED\n-state_routine,\t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE\n-static,\t\t\tSTATIC,\t\t\tNORID,\tRESERVED\n-step,\t\t\tSTEP,\t\t\tNORID,\tRESERVED\n-stop,\t\t\tSTOP,\t\t\tNORID,\tRESERVED\n-struct,\t\t\tSTRUCT,\t\t\tNORID,\tRESERVED\n-support_causing_address,\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE\n-syn,\t\t\tSYN,\t\t\tNORID,\tRESERVED\n-synmode,\t\tSYNMODE,\t\tNORID,\tRESERVED\n-text,\t\t\tTEXT,\t\t\tNORID,\tRESERVED\n-then,\t\t\tTHEN,\t\t\tNORID,\tRESERVED\n-this,\t\t\tTHIS,\t\t\tNORID,\tRESERVED\n-timeout,\t\tTIMEOUT,\t\tNORID,\tRESERVED\n-to,\t\t\tTO,\t\t\tNORID,\tRESERVED\n-up,\t\t\tUP,\t\t\tNORID,\tRESERVED\n-use_seize_file,\t\tUSE_SEIZE_FILE,\t\tNORID,\tDIRECTIVE\n-use_seize_file_restricted,\tUSE_SEIZE_FILE_RESTRICTED,\tNORID,\tDIRECTIVE\n-varying,\t\tVARYING,\t\tNORID,\tRESERVED\n-while,\t\t\tWHILE,\t\t\tNORID,\tRESERVED\n-with,\t\t\tWITH,\t\t\tNORID,\tRESERVED\n-xor,\t\t\tXOR,\t\t\tNORID,\tRESERVED"}, {"sha": "48973e0851c42902d2608ce256242877276960c6", "filename": "gcc/ch/grant.c", "status": "removed", "additions": 0, "deletions": 3056, "changes": 3056, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41823c5eb7d4504b6a4a396ca0d64573238fbbcf/gcc%2Fch%2Fgrant.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41823c5eb7d4504b6a4a396ca0d64573238fbbcf/gcc%2Fch%2Fgrant.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fgrant.c?ref=41823c5eb7d4504b6a4a396ca0d64573238fbbcf"}, {"sha": "4d7c02ab7b09d14044cab8bfa9604bfffbb310de", "filename": "gcc/ch/hash.h", "status": "removed", "additions": 0, "deletions": 1370, "changes": 1370, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41823c5eb7d4504b6a4a396ca0d64573238fbbcf/gcc%2Fch%2Fhash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41823c5eb7d4504b6a4a396ca0d64573238fbbcf/gcc%2Fch%2Fhash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fhash.h?ref=41823c5eb7d4504b6a4a396ca0d64573238fbbcf", "patch": "@@ -1,1370 +0,0 @@\n-/* C code produced by gperf version 2.7.1 (19981006 egcs) */\n-/* Command-line: gperf -L C -F , 0, 0, 0 -D -E -S1 -p -j1 -i 1 -g -o -t -k* gperf.tmp  */\n-struct resword {\n-  const char  *name;\n-  short        token;\n-  enum rid     rid;\n-  enum toktype { RESERVED, DIRECTIVE, PREDEF } flags;\n-};\n-extern tree ridpointers [];\n-#ifdef __GNUC__\n-__inline\n-#endif\n-static unsigned int hash\tPARAMS ((const char *, unsigned int));\n-#ifdef __GNUC__\n-__inline\n-#endif\n-struct resword *in_word_set\tPARAMS ((const char *, unsigned int));\n-/* maximum key range = 2815, duplicates = 6 */\n-\n-#ifdef __GNUC__\n-__inline\n-#endif\n-static unsigned int\n-hash (str, len)\n-     register const char *str;\n-     register unsigned int len;\n-{\n-  static unsigned short asso_values[] =\n-    {\n-      2822, 2822, 2822, 2822, 2822, 2822, 2822, 2822, 2822, 2822,\n-      2822, 2822, 2822, 2822, 2822, 2822, 2822, 2822, 2822, 2822,\n-      2822, 2822, 2822, 2822, 2822, 2822, 2822, 2822, 2822, 2822,\n-      2822, 2822, 2822, 2822, 2822, 2822, 2822, 2822, 2822, 2822,\n-      2822, 2822, 2822, 2822, 2822, 2822, 2822, 2822, 2822, 2822,\n-      2822, 2822, 2822, 2822, 2822, 2822, 2822, 2822, 2822, 2822,\n-      2822, 2822, 2822, 2822, 2822,    4,   61,   80,   12,  350,\n-        91,   39,    3,    2, 2822,    4,  129,  155,   64,   46,\n-        65, 2822,   96,   13,    1,  135,    7,    2,    8,  124,\n-         7, 2822, 2822, 2822, 2822,    1, 2822,   94,   40,  127,\n-        21,    1,   81,    1,    1,    7, 2822,    3,   23,   74,\n-       255,  203,   70, 2822,  218,    1,   88,  124,    1,    6,\n-        10,   56,   40, 2822, 2822, 2822, 2822, 2822, 2822, 2822,\n-      2822, 2822, 2822, 2822, 2822, 2822, 2822, 2822, 2822, 2822,\n-      2822, 2822, 2822, 2822, 2822, 2822, 2822, 2822, 2822, 2822,\n-      2822, 2822, 2822, 2822, 2822, 2822, 2822, 2822, 2822, 2822,\n-      2822, 2822, 2822, 2822, 2822, 2822, 2822, 2822, 2822, 2822,\n-      2822, 2822, 2822, 2822, 2822, 2822, 2822, 2822, 2822, 2822,\n-      2822, 2822, 2822, 2822, 2822, 2822, 2822, 2822, 2822, 2822,\n-      2822, 2822, 2822, 2822, 2822, 2822, 2822, 2822, 2822, 2822,\n-      2822, 2822, 2822, 2822, 2822, 2822, 2822, 2822, 2822, 2822,\n-      2822, 2822, 2822, 2822, 2822, 2822, 2822, 2822, 2822, 2822,\n-      2822, 2822, 2822, 2822, 2822, 2822, 2822, 2822, 2822, 2822,\n-      2822, 2822, 2822, 2822, 2822, 2822, 2822, 2822, 2822, 2822,\n-      2822, 2822, 2822, 2822, 2822, 2822, 2822, 2822, 2822, 2822,\n-      2822, 2822, 2822, 2822, 2822, 2822\n-    };\n-  register int hval = len;\n-\n-  switch (hval)\n-    {\n-      default:\n-      case 30:\n-        hval += asso_values[(unsigned char)str[29]];\n-      case 29:\n-        hval += asso_values[(unsigned char)str[28]];\n-      case 28:\n-        hval += asso_values[(unsigned char)str[27]];\n-      case 27:\n-        hval += asso_values[(unsigned char)str[26]];\n-      case 26:\n-        hval += asso_values[(unsigned char)str[25]];\n-      case 25:\n-        hval += asso_values[(unsigned char)str[24]];\n-      case 24:\n-        hval += asso_values[(unsigned char)str[23]];\n-      case 23:\n-        hval += asso_values[(unsigned char)str[22]];\n-      case 22:\n-        hval += asso_values[(unsigned char)str[21]];\n-      case 21:\n-        hval += asso_values[(unsigned char)str[20]];\n-      case 20:\n-        hval += asso_values[(unsigned char)str[19]];\n-      case 19:\n-        hval += asso_values[(unsigned char)str[18]];\n-      case 18:\n-        hval += asso_values[(unsigned char)str[17]];\n-      case 17:\n-        hval += asso_values[(unsigned char)str[16]];\n-      case 16:\n-        hval += asso_values[(unsigned char)str[15]];\n-      case 15:\n-        hval += asso_values[(unsigned char)str[14]];\n-      case 14:\n-        hval += asso_values[(unsigned char)str[13]];\n-      case 13:\n-        hval += asso_values[(unsigned char)str[12]];\n-      case 12:\n-        hval += asso_values[(unsigned char)str[11]];\n-      case 11:\n-        hval += asso_values[(unsigned char)str[10]];\n-      case 10:\n-        hval += asso_values[(unsigned char)str[9]];\n-      case 9:\n-        hval += asso_values[(unsigned char)str[8]];\n-      case 8:\n-        hval += asso_values[(unsigned char)str[7]];\n-      case 7:\n-        hval += asso_values[(unsigned char)str[6]];\n-      case 6:\n-        hval += asso_values[(unsigned char)str[5]];\n-      case 5:\n-        hval += asso_values[(unsigned char)str[4]];\n-      case 4:\n-        hval += asso_values[(unsigned char)str[3]];\n-      case 3:\n-        hval += asso_values[(unsigned char)str[2]];\n-      case 2:\n-        hval += asso_values[(unsigned char)str[1]];\n-      case 1:\n-        hval += asso_values[(unsigned char)str[0]];\n-        break;\n-    }\n-  return hval;\n-}\n-\n-#ifdef __GNUC__\n-__inline\n-#endif\n-struct resword *\n-in_word_set (str, len)\n-     register const char *str;\n-     register unsigned int len;\n-{\n-  enum\n-    {\n-      TOTAL_KEYWORDS = 300,\n-      MIN_WORD_LENGTH = 2,\n-      MAX_WORD_LENGTH = 30,\n-      MIN_HASH_VALUE = 7,\n-      MAX_HASH_VALUE = 2821\n-    };\n-\n-  static struct resword wordlist[] =\n-    {\n-      {\"AT\",\t\t\tAT,\t\t\tNORID,\tRESERVED},\n-      {\"WITH\",\t\t\tWITH,\t\t\tNORID,\tRESERVED},\n-      {\"THIS\",\t\t\tTHIS,\t\t\tNORID,\tRESERVED},\n-      {\"else\",\t\t\tELSE,\t\t\tNORID,\tRESERVED},\n-      {\"while\",\t\t\tWHILE,\t\t\tNORID,\tRESERVED},\n-      {\"TO\",\t\t\tTO,\t\t\tNORID,\tRESERVED},\n-      {\"seize\",\t\t\tSEIZE,\t\t\tNORID,\tRESERVED},\n-      {\"DO\",\t\t\tDO,\t\t\tNORID,\tRESERVED},\n-      {\"OD\",\t\t\tOD,\t\t\tNORID,\tRESERVED},\n-      {\"BIT\",\t\t\tBOOLS,\t\t\tRID_BOOLS,\tPREDEF},\n-      {\"IN\",\t\t\tIN,\t\t\tRID_IN,\tRESERVED},\n-      {\"INIT\",\t\t\tINIT,\t\t\tNORID,\tRESERVED},\n-      {\"AND\",\t\t\tAND,\t\t\tNORID,\tRESERVED},\n-      {\"fi\",\t\t\tFI,\t\t\tNORID,\tRESERVED},\n-      {\"if\",\t\t\tIF,\t\t\tNORID,\tRESERVED},\n-      {\"set\",\t\t\tSET,\t\t\tNORID,\tRESERVED},\n-      {\"FI\",\t\t\tFI,\t\t\tNORID,\tRESERVED},\n-      {\"IF\",\t\t\tIF,\t\t\tNORID,\tRESERVED},\n-      {\"by\",\t\t\tBY,\t\t\tNORID,\tRESERVED},\n-      {\"this\",\t\t\tTHIS,\t\t\tNORID,\tRESERVED},\n-      {\"with\",\t\t\tWITH,\t\t\tNORID,\tRESERVED},\n-      {\"STATIC\",\t\t\tSTATIC,\t\t\tNORID,\tRESERVED},\n-      {\"exit\",\t\t\tEXIT,\t\t\tNORID,\tRESERVED},\n-      {\"ON\",\t\t\tON,\t\t\tNORID,\tRESERVED},\n-      {\"NOT\",\t\t\tNOT,\t\t\tNORID,\tRESERVED},\n-      {\"elsif\",\t\t\tELSIF,\t\t\tNORID,\tRESERVED},\n-      {\"START\",\t\t\tSTART,\t\t\tNORID,\tRESERVED},\n-      {\"list\",\t\t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n-      {\"POS\",\t\t\tPOS,\t\t\tNORID,\tRESERVED},\n-      {\"DOWN\",\t\t\tDOWN,\t\t\tNORID,\tRESERVED},\n-      {\"STOP\",\t\t\tSTOP,\t\t\tNORID,\tRESERVED},\n-      {\"BIN\",\t\t\tBIN,\t\t\tNORID,\tRESERVED},\n-      {\"GOTO\",\t\t\tGOTO,\t\t\tNORID,\tRESERVED},\n-      {\"bit\",\t\t\tBOOLS,\t\t\tRID_BOOLS,\tPREDEF},\n-      {\"OF\",\t\t\tOF,\t\t\tNORID,\tRESERVED},\n-      {\"all\",\t\t\tALL,\t\t\tNORID,\tRESERVED},\n-      {\"OR\",\t\t\tOR,\t\t\tNORID,\tRESERVED},\n-      {\"ROW\",\t\t\tROW,\t\t\tNORID,\tRESERVED},\n-      {\"LIST\",\t\t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n-      {\"XOR\",\t\t\tXOR,\t\t\tNORID,\tRESERVED},\n-      {\"PACK\",\t\t\tPACK,\t\t\tNORID,\tRESERVED},\n-      {\"based\",\t\t\tBASED,\t\t\tNORID,\tRESERVED},\n-      {\"step\",\t\t\tSTEP,\t\t\tNORID,\tRESERVED},\n-      {\"page\",\t\t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n-      {\"asm\",\t\t\tASM_KEYWORD,\t\tNORID,\tRESERVED},\n-      {\"dcl\",\t\t\tDCL,\t\t\tNORID,\tRESERVED},\n-      {\"ASM\",\t\t\tASM_KEYWORD,\t\tNORID,\tRESERVED},\n-      {\"ANDIF\",\t\t\tANDIF,\t\t\tNORID,\tRESERVED},\n-      {\"simple\",\t\t\tSIMPLE,\t\t\tNORID,\tRESERVED},\n-      {\"at\",\t\t\tAT,\t\t\tNORID,\tRESERVED},\n-      {\"OUT\",\t\t\tPARAMATTR,\t\tRID_OUT,\tRESERVED},\n-      {\"BY\",\t\t\tBY,\t\t\tNORID,\tRESERVED},\n-      {\"text\",\t\t\tTEXT,\t\t\tNORID,\tRESERVED},\n-      {\"FAR\",\t\t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n-      {\"up\",\t\t\tUP,\t\t\tNORID,\tRESERVED},\n-      {\"delay\",\t\t\tDELAY,\t\t\tNORID,\tRESERVED},\n-      {\"CHARS\",\t\t\tCHARS,\t\t\tNORID,\tRESERVED},\n-      {\"UP\",\t\t\tUP,\t\t\tNORID,\tRESERVED},\n-      {\"spec\",\t\t\tSPEC,\t\t\tNORID,\tRESERVED},\n-      {\"SYN\",\t\t\tSYN,\t\t\tNORID,\tRESERVED},\n-      {\"GRANT\",\t\t\tGRANT,\t\t\tNORID,\tRESERVED},\n-      {\"MOD\",\t\t\tMOD,\t\t\tNORID,\tRESERVED},\n-      {\"small\",\t\t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n-      {\"DCL\",\t\t\tDCL,\t\t\tNORID,\tRESERVED},\n-      {\"ever\",\t\t\tEVER,\t\t\tNORID,\tRESERVED},\n-      {\"do\",\t\t\tDO,\t\t\tNORID,\tRESERVED},\n-      {\"od\",\t\t\tOD,\t\t\tNORID,\tRESERVED},\n-      {\"case\",\t\t\tCASE,\t\t\tNORID,\tRESERVED},\n-      {\"esac\",\t\t\tESAC,\t\t\tNORID,\tRESERVED},\n-      {\"CCITT_OS\",\t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n-      {\"FOR\",\t\t\tFOR,\t\t\tNORID,\tRESERVED},\n-      {\"ORIF\",\t\t\tORIF,\t\t\tNORID,\tRESERVED},\n-      {\"BODY\",\t\t\tBODY,\t\t\tNORID,\tRESERVED},\n-      {\"INOUT\",\t\t\tPARAMATTR,\t\tRID_INOUT,\tRESERVED},\n-      {\"SIGNAL\",\t\t\tSIGNAL,\t\t\tNORID,\tRESERVED},\n-      {\"LOC\",\t\t\tLOC,\t\t\tNORID,\tRESERVED},\n-      {\"NOLIST\",\t\t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n-      {\"even\",\t\t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n-      {\"in\",\t\t\tIN,\t\t\tRID_IN,\tRESERVED},\n-      {\"ALL\",\t\t\tALL,\t\t\tNORID,\tRESERVED},\n-      {\"NOPACK\",\t\t\tNOPACK,\t\t\tNORID,\tRESERVED},\n-      {\"call\",\t\t\tCALL,\t\t\tNORID,\tRESERVED},\n-      {\"pos\",\t\t\tPOS,\t\t\tNORID,\tRESERVED},\n-      {\"end\",\t\t\tEND,\t\t\tNORID,\tRESERVED},\n-      {\"send\",\t\t\tSEND,\t\t\tNORID,\tRESERVED},\n-      {\"of\",\t\t\tOF,\t\t\tNORID,\tRESERVED},\n-      {\"PROC\",\t\t\tPROC,\t\t\tNORID,\tRESERVED},\n-      {\"to\",\t\t\tTO,\t\t\tNORID,\tRESERVED},\n-      {\"rem\",\t\t\tREM,\t\t\tNORID,\tRESERVED},\n-      {\"pack\",\t\t\tPACK,\t\t\tNORID,\tRESERVED},\n-      {\"BOOLS\",\t\t\tBOOLS,\t\t\tRID_BOOLS,\tRESERVED},\n-      {\"mod\",\t\t\tMOD,\t\t\tNORID,\tRESERVED},\n-      {\"ref\",\t\t\tREF,\t\t\tNORID,\tRESERVED},\n-      {\"use_seize_file\",\t\tUSE_SEIZE_FILE,\t\tNORID,\tDIRECTIVE},\n-      {\"bin\",\t\t\tBIN,\t\t\tNORID,\tRESERVED},\n-      {\"medium\",\t\t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n-      {\"begin\",\t\t\tBEGINTOKEN,\t\tNORID,\tRESERVED},\n-      {\"FORBID\",\t\t\tFORBID,\t\t\tNORID,\tRESERVED},\n-      {\"syn\",\t\t\tSYN,\t\t\tNORID,\tRESERVED},\n-      {\"body\",\t\t\tBODY,\t\t\tNORID,\tRESERVED},\n-      {\"ARRAY\",\t\t\tARRAY,\t\t\tNORID,\tRESERVED},\n-      {\"STRUCT\",\t\t\tSTRUCT,\t\t\tNORID,\tRESERVED},\n-      {\"read\",\t\t\tREAD,\t\t\tRID_READ,\tRESERVED},\n-      {\"cycle\",\t\t\tCYCLE,\t\t\tNORID,\tRESERVED},\n-      {\"large\",\t\t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n-      {\"VARYING\",\t\tVARYING,\t\tNORID,\tRESERVED},\n-      {\"CALL\",\t\t\tCALL,\t\t\tNORID,\tRESERVED},\n-      {\"then\",\t\t\tTHEN,\t\t\tNORID,\tRESERVED},\n-      {\"event\",\t\t\tEVENT,\t\t\tNORID,\tRESERVED},\n-      {\"cause\",\t\t\tCAUSE,\t\t\tNORID,\tRESERVED},\n-      {\"loc\",\t\t\tLOC,\t\t\tNORID,\tRESERVED},\n-      {\"access\",\t\t\tACCESS,\t\t\tNORID,\tRESERVED},\n-      {\"init\",\t\t\tINIT,\t\t\tNORID,\tRESERVED},\n-      {\"receive\",\t\tRECEIVE,\t\tNORID,\tRESERVED},\n-      {\"TEXT\",\t\t\tTEXT,\t\t\tNORID,\tRESERVED},\n-      {\"EXIT\",\t\t\tEXIT,\t\t\tNORID,\tRESERVED},\n-      {\"stop\",\t\t\tSTOP,\t\t\tNORID,\tRESERVED},\n-      {\"SET\",\t\t\tSET,\t\t\tNORID,\tRESERVED},\n-      {\"and\",\t\t\tAND,\t\t\tNORID,\tRESERVED},\n-      {\"signal\",\t\t\tSIGNAL,\t\t\tNORID,\tRESERVED},\n-      {\"far\",\t\t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n-      {\"assert\",\t\t\tASSERT,\t\t\tNORID,\tRESERVED},\n-      {\"static\",\t\t\tSTATIC,\t\t\tNORID,\tRESERVED},\n-      {\"debug_types\",\t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n-      {\"prefixed\",\t\tPREFIXED,\t\tNORID,\tRESERVED},\n-      {\"out\",\t\t\tPARAMATTR,\t\tRID_OUT,\tRESERVED},\n-      {\"THEN\",\t\t\tTHEN,\t\t\tNORID,\tRESERVED},\n-      {\"or\",\t\t\tOR,\t\t\tNORID,\tRESERVED},\n-      {\"END\",\t\t\tEND,\t\t\tNORID,\tRESERVED},\n-      {\"row\",\t\t\tROW,\t\t\tNORID,\tRESERVED},\n-      {\"STEP\",\t\t\tSTEP,\t\t\tNORID,\tRESERVED},\n-      {\"xor\",\t\t\tXOR,\t\t\tNORID,\tRESERVED},\n-      {\"SMALL\",\t\t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n-      {\"PRIORITY\",\t\tPRIORITY,\t\tNORID,\tRESERVED},\n-      {\"SEND\",\t\t\tSEND,\t\t\tNORID,\tRESERVED},\n-      {\"BASED\",\t\t\tBASED,\t\t\tNORID,\tRESERVED},\n-      {\"chars\",\t\t\tCHARS,\t\t\tNORID,\tRESERVED},\n-      {\"DYNAMIC\",\t\tDYNAMIC,\t\tRID_DYNAMIC,\tRESERVED},\n-      {\"CASE\",\t\t\tCASE,\t\t\tNORID,\tRESERVED},\n-      {\"ESAC\",\t\t\tESAC,\t\t\tNORID,\tRESERVED},\n-      {\"module\",\t\t\tMODULE,\t\t\tNORID,\tRESERVED},\n-      {\"on\",\t\t\tON,\t\t\tNORID,\tRESERVED},\n-      {\"result\",\t\t\tRESULT,\t\t\tNORID,\tRESERVED},\n-      {\"PAGE\",\t\t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n-      {\"andif\",\t\t\tANDIF,\t\t\tNORID,\tRESERVED},\n-      {\"READ\",\t\t\tREAD,\t\t\tRID_READ,\tRESERVED},\n-      {\"bools\",\t\t\tBOOLS,\t\t\tRID_BOOLS,\tRESERVED},\n-      {\"ASSERT\",\t\t\tASSERT,\t\t\tNORID,\tRESERVED},\n-      {\"debug_lines\",\t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n-      {\"after\",\t\t\tAFTER,\t\t\tNORID,\tRESERVED},\n-      {\"ALL_STATIC_ON\",\t\tALL_STATIC_ON,\t\tNORID,\tDIRECTIVE},\n-      {\"down\",\t\t\tDOWN,\t\t\tNORID,\tRESERVED},\n-      {\"WHILE\",\t\t\tWHILE,\t\t\tNORID,\tRESERVED},\n-      {\"start\",\t\t\tSTART,\t\t\tNORID,\tRESERVED},\n-      {\"optimize\",\t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n-      {\"goto\",\t\t\tGOTO,\t\t\tNORID,\tRESERVED},\n-      {\"for\",\t\t\tFOR,\t\t\tNORID,\tRESERVED},\n-      {\"SPEC\",\t\t\tSPEC,\t\t\tNORID,\tRESERVED},\n-      {\"orif\",\t\t\tORIF,\t\t\tNORID,\tRESERVED},\n-      {\"BEGIN\",\t\t\tBEGINTOKEN,\t\tNORID,\tRESERVED},\n-      {\"REF\",\t\t\tREF,\t\t\tNORID,\tRESERVED},\n-      {\"OPTIMIZATION_WINDOW\",\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n-      {\"ACCESS\",\t\t\tACCESS,\t\t\tNORID,\tRESERVED},\n-      {\"AFTER\",\t\t\tAFTER,\t\t\tNORID,\tRESERVED},\n-      {\"not\",\t\t\tNOT,\t\t\tNORID,\tRESERVED},\n-      {\"buffer\",\t\t\tBUFFER,\t\t\tNORID,\tRESERVED},\n-      {\"inline\",\t\t\tINLINE,\t\t\tRID_INLINE,\tRESERVED},\n-      {\"CONTEXT\",\t\tCONTEXT,\t\tNORID,\tRESERVED},\n-      {\"RANGE\",\t\t\tRANGE,\t\t\tNORID,\tRESERVED},\n-      {\"newmode\",\t\tNEWMODE,\t\tNORID,\tRESERVED},\n-      {\"range\",\t\t\tRANGE,\t\t\tNORID,\tRESERVED},\n-      {\"forbid\",\t\t\tFORBID,\t\t\tNORID,\tRESERVED},\n-      {\"nolist\",\t\t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n-      {\"CAUSE\",\t\t\tCAUSE,\t\t\tNORID,\tRESERVED},\n-      {\"ELSIF\",\t\t\tELSIF,\t\t\tNORID,\tRESERVED},\n-      {\"remote\",\t\t\tREMOTE,\t\t\tNORID,\tRESERVED},\n-      {\"timeout\",\t\tTIMEOUT,\t\tNORID,\tRESERVED},\n-      {\"powerset\",\t\tPOWERSET,\t\tNORID,\tRESERVED},\n-      {\"debug_symbols\",\t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n-      {\"general\",\t\tGENERAL,\t\tNORID,\tRESERVED},\n-      {\"REGION\",\t\t\tREGION,\t\t\tNORID,\tRESERVED},\n-      {\"REM\",\t\t\tREM,\t\t\tNORID,\tRESERVED},\n-      {\"ALL_STATIC_OFF\",\t\tALL_STATIC_OFF,\t\tNORID,  DIRECTIVE},\n-      {\"INLINE\",\t\t\tINLINE,\t\t\tRID_INLINE,\tRESERVED},\n-      {\"synmode\",\t\tSYNMODE,\t\tNORID,\tRESERVED},\n-      {\"proc\",\t\t\tPROC,\t\t\tNORID,\tRESERVED},\n-      {\"LARGE\",\t\t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n-      {\"DELAY\",\t\t\tDELAY,\t\t\tNORID,\tRESERVED},\n-      {\"process\",\t\tPROCESS,\t\tNORID,\tRESERVED},\n-      {\"OPTIMIZE\",\t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n-      {\"varying\",\t\tVARYING,\t\tNORID,\tRESERVED},\n-      {\"dynamic\",\t\tDYNAMIC,\t\tRID_DYNAMIC,\tRESERVED},\n-      {\"ccitt_os\",\t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n-      {\"struct\",\t\t\tSTRUCT,\t\t\tNORID,\tRESERVED},\n-      {\"grant\",\t\t\tGRANT,\t\t\tNORID,\tRESERVED},\n-      {\"empty_off\",\t\tEMPTY_OFF,\t\tNORID,\tDIRECTIVE},\n-      {\"PROCESS\",\t\tPROCESS,\t\tNORID,\tRESERVED},\n-      {\"RANGE_ON\",\t\tRANGE_ON,\t\tNORID,\tDIRECTIVE},\n-      {\"inout\",\t\t\tPARAMATTR,\t\tRID_INOUT,\tRESERVED},\n-      {\"array\",\t\t\tARRAY,\t\t\tNORID,\tRESERVED},\n-      {\"region\",\t\t\tREGION,\t\t\tNORID,\tRESERVED},\n-      {\"TIMEOUT\",\t\tTIMEOUT,\t\tNORID,\tRESERVED},\n-      {\"recursive\",\t\tRECURSIVE,\t\tNORID,\tRESERVED},\n-      {\"event_code\",\t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n-      {\"NONREF\",\t\t\tNONREF,\t\t\tNORID,\tRESERVED},\n-      {\"SIMPLE\",\t\t\tSIMPLE,\t\t\tNORID,\tRESERVED},\n-      {\"SEIZE\",\t\t\tSEIZE,\t\t\tNORID,\tRESERVED},\n-      {\"RESULT\",\t\t\tRESULT,\t\t\tNORID,\tRESERVED},\n-      {\"multiple_data_segs\",\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n-      {\"signal_code\",\t\tSIGNAL_CODE,\t\tNORID,\tDIRECTIVE},\n-      {\"RETURN\",\t\t\tRETURN,\t\t\tNORID,\tRESERVED},\n-      {\"CONTINUE\",\t\tCONTINUE,\t\tNORID,\tRESERVED},\n-      {\"SIGNAL_CODE\",\t\tSIGNAL_CODE,\t\tNORID,\tDIRECTIVE},\n-      {\"empty_on\",\t\tEMPTY_ON,\t\tNORID,\tDIRECTIVE},\n-      {\"nopack\",\t\t\tNOPACK,\t\t\tNORID,\tRESERVED},\n-      {\"RETURNS\",\t\tRETURNS,\t\tNORID,\tRESERVED},\n-      {\"CYCLE\",\t\t\tCYCLE,\t\t\tNORID,\tRESERVED},\n-      {\"SYNMODE\",\t\tSYNMODE,\t\tNORID,\tRESERVED},\n-      {\"exceptions\",\t\tEXCEPTIONS,\t\tNORID,\tRESERVED},\n-      {\"EVEN\",\t\t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n-      {\"PRINT_O_CODE\",\t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n-      {\"EVENT\",\t\t\tEVENT,\t\t\tNORID,\tRESERVED},\n-      {\"context\",\t\tCONTEXT,\t\tNORID,\tRESERVED},\n-      {\"RANGE_OFF\",\t\tRANGE_OFF,\t\tNORID,\tDIRECTIVE},\n-      {\"EVER\",\t\t\tEVER,\t\t\tNORID,\tRESERVED},\n-      {\"EMPTY_ON\",\t\tEMPTY_ON,\t\tNORID,\tDIRECTIVE},\n-      {\"MEDIUM\",\t\t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n-      {\"BUFFER\",\t\t\tBUFFER,\t\t\tNORID,\tRESERVED},\n-      {\"MODULE\",\t\t\tMODULE,\t\t\tNORID,\tRESERVED},\n-      {\"grant_file_size\",\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n-      {\"ELSE\",\t\t\tELSE,\t\t\tNORID,\tRESERVED},\n-      {\"process_type\",\t\tPROCESS_TYPE_TOKEN,\tNORID,\tDIRECTIVE},\n-      {\"priority\",\t\tPRIORITY,\t\tNORID,\tRESERVED},\n-      {\"buffer_code\",\t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n-      {\"return\",\t\t\tRETURN,\t\t\tNORID,\tRESERVED},\n-      {\"returns\",\t\tRETURNS,\t\tNORID,\tRESERVED},\n-      {\"all_static_off\",\t\tALL_STATIC_OFF,\t\tNORID,  DIRECTIVE},\n-      {\"POWERSET\",\t\tPOWERSET,\t\tNORID,\tRESERVED},\n-      {\"EMPTY_OFF\",\t\tEMPTY_OFF,\t\tNORID,\tDIRECTIVE},\n-      {\"range_off\",\t\tRANGE_OFF,\t\tNORID,\tDIRECTIVE},\n-      {\"signal_max_length\",\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n-      {\"PREFIXED\",\t\tPREFIXED,\t\tNORID,\tRESERVED},\n-      {\"NEWMODE\",\t\tNEWMODE,\t\tNORID,\tRESERVED},\n-      {\"EXCEPTIONS\",\t\tEXCEPTIONS,\t\tNORID,\tRESERVED},\n-      {\"REMOTE\",\t\t\tREMOTE,\t\t\tNORID,\tRESERVED},\n-      {\"SHORT_PRED_SUCC\",\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n-      {\"all_static_on\",\t\tALL_STATIC_ON,\t\tNORID,\tDIRECTIVE},\n-      {\"nonref\",\t\t\tNONREF,\t\t\tNORID,\tRESERVED},\n-      {\"SIGNAL_MAX_LENGTH\",\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n-      {\"REENTRANT\",\t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n-      {\"range_on\",\t\tRANGE_ON,\t\tNORID,\tDIRECTIVE},\n-      {\"GENERAL\",\t\tGENERAL,\t\tNORID,\tRESERVED},\n-      {\"continue\",\t\tCONTINUE,\t\tNORID,\tRESERVED},\n-      {\"STATE_ROUTINE\",\t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n-      {\"EXTRA_CONST_SEG\",\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n-      {\"use_seize_file_restricted\",\tUSE_SEIZE_FILE_RESTRICTED,\tNORID,\tDIRECTIVE},\n-      {\"ONLY_FOR_TARGET\",\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n-      {\"extra_const_seg\",\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n-      {\"multiple_const_segs\",\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n-      {\"RECURSIVE\",\t\tRECURSIVE,\t\tNORID,\tRESERVED},\n-      {\"DEBUG_SYMBOLS\",\t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n-      {\"DEBUG_TYPES\",\t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n-      {\"GRANT_FILE_SIZE\",\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n-      {\"DEBUG_LINES\",\t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n-      {\"ONLY_FOR_SIMULATION\",\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n-      {\"state_routine\",\t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n-      {\"generate_set_names\",\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n-      {\"print_o_code\",\t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n-      {\"PROCESS_TYPE\",\t\tPROCESS_TYPE_TOKEN,\tNORID,\tDIRECTIVE},\n-      {\"short_pred_succ\",\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n-      {\"reentrant\",\t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n-      {\"RECEIVE\",\t\tRECEIVE,\t\tNORID,\tRESERVED},\n-      {\"EVENT_CODE\",\t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n-      {\"optimize_runtime\",\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n-      {\"SUPPORT_CAUSING_ADDRESS\",\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n-      {\"print_symbol_table\",\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n-      {\"REENTRANT_ALL\",\t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n-      {\"PRINT_SYMBOL_TABLE\",\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n-      {\"BUFFER_CODE\",\t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n-      {\"generate_all_set_names\",\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n-      {\"NO_OVERLAP_CHECK\",\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n-      {\"no_overlap_check\",\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n-      {\"reentrant_all\",\t\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n-      {\"MULTIPLE_DATA_SEGS\",\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n-      {\"OPTIMIZE_RUNTIME\",\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n-      {\"only_for_target\",\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n-      {\"MULTIPLE_CONST_SEGS\",\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n-      {\"optimization_window\",\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n-      {\"support_causing_address\",\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n-      {\"USE_SEIZE_FILE\",\t\tUSE_SEIZE_FILE,\t\tNORID,\tDIRECTIVE},\n-      {\"SEND_SIGNAL_DEFAULT_PRIORITY\",\tSEND_SIGNAL_DEFAULT_PRIORITY,\tNORID,\tDIRECTIVE},\n-      {\"make_publics_for_discrete_syns\",\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n-      {\"only_for_simulation\",\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n-      {\"send_signal_default_priority\",\tSEND_SIGNAL_DEFAULT_PRIORITY,\tNORID,\tDIRECTIVE},\n-      {\"send_buffer_default_priority\",\tSEND_BUFFER_DEFAULT_PRIORITY,\tNORID,\tDIRECTIVE},\n-      {\"GENERATE_SET_NAMES\",\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n-      {\"MAKE_PUBLICS_FOR_DISCRETE_SYNS\",\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n-      {\"SEND_BUFFER_DEFAULT_PRIORITY\",\tSEND_BUFFER_DEFAULT_PRIORITY,\tNORID,\tDIRECTIVE},\n-      {\"GENERATE_ALL_SET_NAMES\",\tIGNORED_DIRECTIVE,\tNORID,\tDIRECTIVE},\n-      {\"USE_SEIZE_FILE_RESTRICTED\",\tUSE_SEIZE_FILE_RESTRICTED,\tNORID,\tDIRECTIVE}\n-    };\n-\n-  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)\n-    {\n-      register int key = hash (str, len);\n-\n-      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)\n-        {\n-          register struct resword *wordptr;\n-          register struct resword *wordendptr;\n-          register struct resword *resword;\n-\n-          switch (key - 7)\n-            {\n-              case 0:\n-                resword = &wordlist[0];\n-                goto compare;\n-              case 5:\n-                resword = &wordlist[1];\n-                goto compare;\n-              case 16:\n-                resword = &wordlist[2];\n-                goto compare;\n-              case 23:\n-                resword = &wordlist[3];\n-                goto compare;\n-              case 36:\n-                resword = &wordlist[4];\n-                goto compare;\n-              case 42:\n-                resword = &wordlist[5];\n-                goto compare;\n-              case 48:\n-                resword = &wordlist[6];\n-                goto compare;\n-              case 53:\n-                wordptr = &wordlist[7];\n-                wordendptr = wordptr + 2;\n-                goto multicompare;\n-              case 60:\n-                resword = &wordlist[9];\n-                goto compare;\n-              case 61:\n-                resword = &wordlist[10];\n-                goto compare;\n-              case 66:\n-                resword = &wordlist[11];\n-                goto compare;\n-              case 76:\n-                resword = &wordlist[12];\n-                goto compare;\n-              case 83:\n-                wordptr = &wordlist[13];\n-                wordendptr = wordptr + 2;\n-                goto multicompare;\n-              case 86:\n-                resword = &wordlist[15];\n-                goto compare;\n-              case 88:\n-                wordptr = &wordlist[16];\n-                wordendptr = wordptr + 2;\n-                goto multicompare;\n-              case 91:\n-                resword = &wordlist[18];\n-                goto compare;\n-              case 94:\n-                resword = &wordlist[19];\n-                goto compare;\n-              case 99:\n-                resword = &wordlist[20];\n-                goto compare;\n-              case 100:\n-                resword = &wordlist[21];\n-                goto compare;\n-              case 103:\n-                resword = &wordlist[22];\n-                goto compare;\n-              case 105:\n-                resword = &wordlist[23];\n-                goto compare;\n-              case 107:\n-                resword = &wordlist[24];\n-                goto compare;\n-              case 111:\n-                resword = &wordlist[25];\n-                goto compare;\n-              case 113:\n-                resword = &wordlist[26];\n-                goto compare;\n-              case 116:\n-                resword = &wordlist[27];\n-                goto compare;\n-              case 120:\n-                resword = &wordlist[28];\n-                goto compare;\n-              case 121:\n-                resword = &wordlist[29];\n-                goto compare;\n-              case 122:\n-                resword = &wordlist[30];\n-                goto compare;\n-              case 123:\n-                resword = &wordlist[31];\n-                goto compare;\n-              case 129:\n-                resword = &wordlist[32];\n-                goto compare;\n-              case 131:\n-                resword = &wordlist[33];\n-                goto compare;\n-              case 132:\n-                resword = &wordlist[34];\n-                goto compare;\n-              case 136:\n-                resword = &wordlist[35];\n-                goto compare;\n-              case 137:\n-                resword = &wordlist[36];\n-                goto compare;\n-              case 140:\n-                resword = &wordlist[37];\n-                goto compare;\n-              case 142:\n-                resword = &wordlist[38];\n-                goto compare;\n-              case 146:\n-                resword = &wordlist[39];\n-                goto compare;\n-              case 150:\n-                resword = &wordlist[40];\n-                goto compare;\n-              case 155:\n-                resword = &wordlist[41];\n-                goto compare;\n-              case 157:\n-                resword = &wordlist[42];\n-                goto compare;\n-              case 163:\n-                resword = &wordlist[43];\n-                goto compare;\n-              case 165:\n-                resword = &wordlist[44];\n-                goto compare;\n-              case 167:\n-                resword = &wordlist[45];\n-                goto compare;\n-              case 168:\n-                resword = &wordlist[46];\n-                goto compare;\n-              case 171:\n-                resword = &wordlist[47];\n-                goto compare;\n-              case 175:\n-                resword = &wordlist[48];\n-                goto compare;\n-              case 177:\n-                resword = &wordlist[49];\n-                goto compare;\n-              case 178:\n-                resword = &wordlist[50];\n-                goto compare;\n-              case 180:\n-                resword = &wordlist[51];\n-                goto compare;\n-              case 184:\n-                resword = &wordlist[52];\n-                goto compare;\n-              case 187:\n-                resword = &wordlist[53];\n-                goto compare;\n-              case 189:\n-                resword = &wordlist[54];\n-                goto compare;\n-              case 193:\n-                resword = &wordlist[55];\n-                goto compare;\n-              case 194:\n-                resword = &wordlist[56];\n-                goto compare;\n-              case 195:\n-                resword = &wordlist[57];\n-                goto compare;\n-              case 196:\n-                resword = &wordlist[58];\n-                goto compare;\n-              case 197:\n-                resword = &wordlist[59];\n-                goto compare;\n-              case 202:\n-                resword = &wordlist[60];\n-                goto compare;\n-              case 209:\n-                resword = &wordlist[61];\n-                goto compare;\n-              case 213:\n-                resword = &wordlist[62];\n-                goto compare;\n-              case 217:\n-                resword = &wordlist[63];\n-                goto compare;\n-              case 218:\n-                resword = &wordlist[64];\n-                goto compare;\n-              case 219:\n-                wordptr = &wordlist[65];\n-                wordendptr = wordptr + 2;\n-                goto multicompare;\n-              case 220:\n-                wordptr = &wordlist[67];\n-                wordendptr = wordptr + 2;\n-                goto multicompare;\n-              case 225:\n-                resword = &wordlist[69];\n-                goto compare;\n-              case 229:\n-                resword = &wordlist[70];\n-                goto compare;\n-              case 232:\n-                resword = &wordlist[71];\n-                goto compare;\n-              case 240:\n-                resword = &wordlist[72];\n-                goto compare;\n-              case 246:\n-                resword = &wordlist[73];\n-                goto compare;\n-              case 250:\n-                resword = &wordlist[74];\n-                goto compare;\n-              case 251:\n-                resword = &wordlist[75];\n-                goto compare;\n-              case 254:\n-                resword = &wordlist[76];\n-                goto compare;\n-              case 255:\n-                resword = &wordlist[77];\n-                goto compare;\n-              case 257:\n-                resword = &wordlist[78];\n-                goto compare;\n-              case 258:\n-                resword = &wordlist[79];\n-                goto compare;\n-              case 262:\n-                resword = &wordlist[80];\n-                goto compare;\n-              case 264:\n-                resword = &wordlist[81];\n-                goto compare;\n-              case 270:\n-                resword = &wordlist[82];\n-                goto compare;\n-              case 273:\n-                resword = &wordlist[83];\n-                goto compare;\n-              case 275:\n-                resword = &wordlist[84];\n-                goto compare;\n-              case 279:\n-                resword = &wordlist[85];\n-                goto compare;\n-              case 284:\n-                resword = &wordlist[86];\n-                goto compare;\n-              case 286:\n-                resword = &wordlist[87];\n-                goto compare;\n-              case 289:\n-                resword = &wordlist[88];\n-                goto compare;\n-              case 291:\n-                resword = &wordlist[89];\n-                goto compare;\n-              case 293:\n-                resword = &wordlist[90];\n-                goto compare;\n-              case 294:\n-                resword = &wordlist[91];\n-                goto compare;\n-              case 296:\n-                resword = &wordlist[92];\n-                goto compare;\n-              case 297:\n-                resword = &wordlist[93];\n-                goto compare;\n-              case 298:\n-                resword = &wordlist[94];\n-                goto compare;\n-              case 300:\n-                resword = &wordlist[95];\n-                goto compare;\n-              case 302:\n-                resword = &wordlist[96];\n-                goto compare;\n-              case 307:\n-                resword = &wordlist[97];\n-                goto compare;\n-              case 308:\n-                resword = &wordlist[98];\n-                goto compare;\n-              case 317:\n-                resword = &wordlist[99];\n-                goto compare;\n-              case 322:\n-                resword = &wordlist[100];\n-                goto compare;\n-              case 325:\n-                resword = &wordlist[101];\n-                goto compare;\n-              case 331:\n-                resword = &wordlist[102];\n-                goto compare;\n-              case 332:\n-                resword = &wordlist[103];\n-                goto compare;\n-              case 335:\n-                resword = &wordlist[104];\n-                goto compare;\n-              case 336:\n-                resword = &wordlist[105];\n-                goto compare;\n-              case 339:\n-                resword = &wordlist[106];\n-                goto compare;\n-              case 342:\n-                resword = &wordlist[107];\n-                goto compare;\n-              case 344:\n-                resword = &wordlist[108];\n-                goto compare;\n-              case 345:\n-                resword = &wordlist[109];\n-                goto compare;\n-              case 349:\n-                resword = &wordlist[110];\n-                goto compare;\n-              case 350:\n-                resword = &wordlist[111];\n-                goto compare;\n-              case 354:\n-                resword = &wordlist[112];\n-                goto compare;\n-              case 356:\n-                resword = &wordlist[113];\n-                goto compare;\n-              case 357:\n-                resword = &wordlist[114];\n-                goto compare;\n-              case 358:\n-                resword = &wordlist[115];\n-                goto compare;\n-              case 359:\n-                resword = &wordlist[116];\n-                goto compare;\n-              case 360:\n-                resword = &wordlist[117];\n-                goto compare;\n-              case 366:\n-                resword = &wordlist[118];\n-                goto compare;\n-              case 380:\n-                resword = &wordlist[119];\n-                goto compare;\n-              case 389:\n-                resword = &wordlist[120];\n-                goto compare;\n-              case 402:\n-                resword = &wordlist[121];\n-                goto compare;\n-              case 404:\n-                resword = &wordlist[122];\n-                goto compare;\n-              case 408:\n-                resword = &wordlist[123];\n-                goto compare;\n-              case 410:\n-                resword = &wordlist[124];\n-                goto compare;\n-              case 411:\n-                resword = &wordlist[125];\n-                goto compare;\n-              case 415:\n-                resword = &wordlist[126];\n-                goto compare;\n-              case 416:\n-                resword = &wordlist[127];\n-                goto compare;\n-              case 422:\n-                resword = &wordlist[128];\n-                goto compare;\n-              case 423:\n-                resword = &wordlist[129];\n-                goto compare;\n-              case 426:\n-                resword = &wordlist[130];\n-                goto compare;\n-              case 427:\n-                resword = &wordlist[131];\n-                goto compare;\n-              case 428:\n-                resword = &wordlist[132];\n-                goto compare;\n-              case 433:\n-                resword = &wordlist[133];\n-                goto compare;\n-              case 436:\n-                resword = &wordlist[134];\n-                goto compare;\n-              case 438:\n-                resword = &wordlist[135];\n-                goto compare;\n-              case 439:\n-                resword = &wordlist[136];\n-                goto compare;\n-              case 441:\n-                resword = &wordlist[137];\n-                goto compare;\n-              case 444:\n-                wordptr = &wordlist[138];\n-                wordendptr = wordptr + 2;\n-                goto multicompare;\n-              case 445:\n-                resword = &wordlist[140];\n-                goto compare;\n-              case 453:\n-                resword = &wordlist[141];\n-                goto compare;\n-              case 454:\n-                resword = &wordlist[142];\n-                goto compare;\n-              case 455:\n-                resword = &wordlist[143];\n-                goto compare;\n-              case 456:\n-                resword = &wordlist[144];\n-                goto compare;\n-              case 459:\n-                resword = &wordlist[145];\n-                goto compare;\n-              case 468:\n-                resword = &wordlist[146];\n-                goto compare;\n-              case 476:\n-                resword = &wordlist[147];\n-                goto compare;\n-              case 479:\n-                resword = &wordlist[148];\n-                goto compare;\n-              case 480:\n-                resword = &wordlist[149];\n-                goto compare;\n-              case 481:\n-                resword = &wordlist[150];\n-                goto compare;\n-              case 482:\n-                resword = &wordlist[151];\n-                goto compare;\n-              case 484:\n-                resword = &wordlist[152];\n-                goto compare;\n-              case 487:\n-                resword = &wordlist[153];\n-                goto compare;\n-              case 491:\n-                resword = &wordlist[154];\n-                goto compare;\n-              case 492:\n-                resword = &wordlist[155];\n-                goto compare;\n-              case 498:\n-                resword = &wordlist[156];\n-                goto compare;\n-              case 505:\n-                resword = &wordlist[157];\n-                goto compare;\n-              case 506:\n-                resword = &wordlist[158];\n-                goto compare;\n-              case 514:\n-                resword = &wordlist[159];\n-                goto compare;\n-              case 533:\n-                resword = &wordlist[160];\n-                goto compare;\n-              case 536:\n-                resword = &wordlist[161];\n-                goto compare;\n-              case 539:\n-                resword = &wordlist[162];\n-                goto compare;\n-              case 540:\n-                resword = &wordlist[163];\n-                goto compare;\n-              case 542:\n-                resword = &wordlist[164];\n-                goto compare;\n-              case 544:\n-                resword = &wordlist[165];\n-                goto compare;\n-              case 547:\n-                resword = &wordlist[166];\n-                goto compare;\n-              case 550:\n-                resword = &wordlist[167];\n-                goto compare;\n-              case 551:\n-                resword = &wordlist[168];\n-                goto compare;\n-              case 561:\n-                resword = &wordlist[169];\n-                goto compare;\n-              case 567:\n-                resword = &wordlist[170];\n-                goto compare;\n-              case 569:\n-                resword = &wordlist[171];\n-                goto compare;\n-              case 576:\n-                resword = &wordlist[172];\n-                goto compare;\n-              case 580:\n-                resword = &wordlist[173];\n-                goto compare;\n-              case 583:\n-                resword = &wordlist[174];\n-                goto compare;\n-              case 584:\n-                resword = &wordlist[175];\n-                goto compare;\n-              case 585:\n-                resword = &wordlist[176];\n-                goto compare;\n-              case 589:\n-                resword = &wordlist[177];\n-                goto compare;\n-              case 592:\n-                resword = &wordlist[178];\n-                goto compare;\n-              case 593:\n-                resword = &wordlist[179];\n-                goto compare;\n-              case 596:\n-                resword = &wordlist[180];\n-                goto compare;\n-              case 597:\n-                resword = &wordlist[181];\n-                goto compare;\n-              case 600:\n-                resword = &wordlist[182];\n-                goto compare;\n-              case 610:\n-                resword = &wordlist[183];\n-                goto compare;\n-              case 611:\n-                resword = &wordlist[184];\n-                goto compare;\n-              case 615:\n-                resword = &wordlist[185];\n-                goto compare;\n-              case 616:\n-                resword = &wordlist[186];\n-                goto compare;\n-              case 617:\n-                resword = &wordlist[187];\n-                goto compare;\n-              case 621:\n-                resword = &wordlist[188];\n-                goto compare;\n-              case 629:\n-                resword = &wordlist[189];\n-                goto compare;\n-              case 632:\n-                resword = &wordlist[190];\n-                goto compare;\n-              case 634:\n-                resword = &wordlist[191];\n-                goto compare;\n-              case 643:\n-                resword = &wordlist[192];\n-                goto compare;\n-              case 645:\n-                resword = &wordlist[193];\n-                goto compare;\n-              case 654:\n-                resword = &wordlist[194];\n-                goto compare;\n-              case 657:\n-                resword = &wordlist[195];\n-                goto compare;\n-              case 663:\n-                resword = &wordlist[196];\n-                goto compare;\n-              case 665:\n-                resword = &wordlist[197];\n-                goto compare;\n-              case 675:\n-                resword = &wordlist[198];\n-                goto compare;\n-              case 678:\n-                resword = &wordlist[199];\n-                goto compare;\n-              case 684:\n-                resword = &wordlist[200];\n-                goto compare;\n-              case 690:\n-                resword = &wordlist[201];\n-                goto compare;\n-              case 700:\n-                resword = &wordlist[202];\n-                goto compare;\n-              case 702:\n-                resword = &wordlist[203];\n-                goto compare;\n-              case 710:\n-                resword = &wordlist[204];\n-                goto compare;\n-              case 713:\n-                resword = &wordlist[205];\n-                goto compare;\n-              case 720:\n-                resword = &wordlist[206];\n-                goto compare;\n-              case 723:\n-                resword = &wordlist[207];\n-                goto compare;\n-              case 724:\n-                resword = &wordlist[208];\n-                goto compare;\n-              case 738:\n-                resword = &wordlist[209];\n-                goto compare;\n-              case 741:\n-                resword = &wordlist[210];\n-                goto compare;\n-              case 743:\n-                resword = &wordlist[211];\n-                goto compare;\n-              case 744:\n-                resword = &wordlist[212];\n-                goto compare;\n-              case 749:\n-                resword = &wordlist[213];\n-                goto compare;\n-              case 751:\n-                resword = &wordlist[214];\n-                goto compare;\n-              case 755:\n-                resword = &wordlist[215];\n-                goto compare;\n-              case 761:\n-                resword = &wordlist[216];\n-                goto compare;\n-              case 764:\n-                resword = &wordlist[217];\n-                goto compare;\n-              case 766:\n-                resword = &wordlist[218];\n-                goto compare;\n-              case 768:\n-                resword = &wordlist[219];\n-                goto compare;\n-              case 769:\n-                resword = &wordlist[220];\n-                goto compare;\n-              case 770:\n-                resword = &wordlist[221];\n-                goto compare;\n-              case 772:\n-                resword = &wordlist[222];\n-                goto compare;\n-              case 784:\n-                resword = &wordlist[223];\n-                goto compare;\n-              case 800:\n-                resword = &wordlist[224];\n-                goto compare;\n-              case 807:\n-                resword = &wordlist[225];\n-                goto compare;\n-              case 808:\n-                resword = &wordlist[226];\n-                goto compare;\n-              case 823:\n-                resword = &wordlist[227];\n-                goto compare;\n-              case 826:\n-                resword = &wordlist[228];\n-                goto compare;\n-              case 827:\n-                resword = &wordlist[229];\n-                goto compare;\n-              case 839:\n-                resword = &wordlist[230];\n-                goto compare;\n-              case 842:\n-                resword = &wordlist[231];\n-                goto compare;\n-              case 868:\n-                resword = &wordlist[232];\n-                goto compare;\n-              case 902:\n-                resword = &wordlist[233];\n-                goto compare;\n-              case 903:\n-                resword = &wordlist[234];\n-                goto compare;\n-              case 905:\n-                resword = &wordlist[235];\n-                goto compare;\n-              case 919:\n-                resword = &wordlist[236];\n-                goto compare;\n-              case 924:\n-                resword = &wordlist[237];\n-                goto compare;\n-              case 926:\n-                resword = &wordlist[238];\n-                goto compare;\n-              case 937:\n-                resword = &wordlist[239];\n-                goto compare;\n-              case 940:\n-                resword = &wordlist[240];\n-                goto compare;\n-              case 975:\n-                resword = &wordlist[241];\n-                goto compare;\n-              case 979:\n-                resword = &wordlist[242];\n-                goto compare;\n-              case 982:\n-                resword = &wordlist[243];\n-                goto compare;\n-              case 997:\n-                resword = &wordlist[244];\n-                goto compare;\n-              case 1000:\n-                resword = &wordlist[245];\n-                goto compare;\n-              case 1011:\n-                resword = &wordlist[246];\n-                goto compare;\n-              case 1012:\n-                resword = &wordlist[247];\n-                goto compare;\n-              case 1016:\n-                resword = &wordlist[248];\n-                goto compare;\n-              case 1028:\n-                resword = &wordlist[249];\n-                goto compare;\n-              case 1029:\n-                resword = &wordlist[250];\n-                goto compare;\n-              case 1032:\n-                resword = &wordlist[251];\n-                goto compare;\n-              case 1061:\n-                resword = &wordlist[252];\n-                goto compare;\n-              case 1070:\n-                resword = &wordlist[253];\n-                goto compare;\n-              case 1075:\n-                resword = &wordlist[254];\n-                goto compare;\n-              case 1079:\n-                resword = &wordlist[255];\n-                goto compare;\n-              case 1097:\n-                resword = &wordlist[256];\n-                goto compare;\n-              case 1098:\n-                resword = &wordlist[257];\n-                goto compare;\n-              case 1102:\n-                resword = &wordlist[258];\n-                goto compare;\n-              case 1131:\n-                resword = &wordlist[259];\n-                goto compare;\n-              case 1145:\n-                resword = &wordlist[260];\n-                goto compare;\n-              case 1155:\n-                resword = &wordlist[261];\n-                goto compare;\n-              case 1158:\n-                resword = &wordlist[262];\n-                goto compare;\n-              case 1160:\n-                resword = &wordlist[263];\n-                goto compare;\n-              case 1161:\n-                resword = &wordlist[264];\n-                goto compare;\n-              case 1175:\n-                resword = &wordlist[265];\n-                goto compare;\n-              case 1187:\n-                resword = &wordlist[266];\n-                goto compare;\n-              case 1200:\n-                resword = &wordlist[267];\n-                goto compare;\n-              case 1209:\n-                resword = &wordlist[268];\n-                goto compare;\n-              case 1210:\n-                resword = &wordlist[269];\n-                goto compare;\n-              case 1220:\n-                resword = &wordlist[270];\n-                goto compare;\n-              case 1235:\n-                resword = &wordlist[271];\n-                goto compare;\n-              case 1264:\n-                resword = &wordlist[272];\n-                goto compare;\n-              case 1267:\n-                resword = &wordlist[273];\n-                goto compare;\n-              case 1276:\n-                resword = &wordlist[274];\n-                goto compare;\n-              case 1294:\n-                resword = &wordlist[275];\n-                goto compare;\n-              case 1295:\n-                resword = &wordlist[276];\n-                goto compare;\n-              case 1314:\n-                resword = &wordlist[277];\n-                goto compare;\n-              case 1317:\n-                resword = &wordlist[278];\n-                goto compare;\n-              case 1332:\n-                resword = &wordlist[279];\n-                goto compare;\n-              case 1335:\n-                resword = &wordlist[280];\n-                goto compare;\n-              case 1338:\n-                resword = &wordlist[281];\n-                goto compare;\n-              case 1365:\n-                resword = &wordlist[282];\n-                goto compare;\n-              case 1415:\n-                resword = &wordlist[283];\n-                goto compare;\n-              case 1441:\n-                resword = &wordlist[284];\n-                goto compare;\n-              case 1539:\n-                resword = &wordlist[285];\n-                goto compare;\n-              case 1599:\n-                resword = &wordlist[286];\n-                goto compare;\n-              case 1647:\n-                resword = &wordlist[287];\n-                goto compare;\n-              case 1758:\n-                resword = &wordlist[288];\n-                goto compare;\n-              case 1801:\n-                resword = &wordlist[289];\n-                goto compare;\n-              case 1868:\n-                resword = &wordlist[290];\n-                goto compare;\n-              case 1870:\n-                resword = &wordlist[291];\n-                goto compare;\n-              case 1929:\n-                resword = &wordlist[292];\n-                goto compare;\n-              case 1982:\n-                resword = &wordlist[293];\n-                goto compare;\n-              case 2146:\n-                resword = &wordlist[294];\n-                goto compare;\n-              case 2217:\n-                resword = &wordlist[295];\n-                goto compare;\n-              case 2376:\n-                resword = &wordlist[296];\n-                goto compare;\n-              case 2441:\n-                resword = &wordlist[297];\n-                goto compare;\n-              case 2484:\n-                resword = &wordlist[298];\n-                goto compare;\n-              case 2814:\n-                resword = &wordlist[299];\n-                goto compare;\n-            }\n-          return 0;\n-        multicompare:\n-          while (wordptr < wordendptr)\n-            {\n-              register const char *s = wordptr->name;\n-\n-              if (*str == *s && !strcmp (str + 1, s + 1))\n-                return wordptr;\n-              wordptr++;\n-            }\n-          return 0;\n-        compare:\n-          {\n-            register const char *s = resword->name;\n-\n-            if (*str == *s && !strcmp (str + 1, s + 1))\n-              return resword;\n-          }\n-        }\n-    }\n-  return 0;\n-}"}, {"sha": "6049ff45927296b5164429bfed3c905ee3a7a82d", "filename": "gcc/ch/inout.c", "status": "removed", "additions": 0, "deletions": 4691, "changes": 4691, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41823c5eb7d4504b6a4a396ca0d64573238fbbcf/gcc%2Fch%2Finout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41823c5eb7d4504b6a4a396ca0d64573238fbbcf/gcc%2Fch%2Finout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Finout.c?ref=41823c5eb7d4504b6a4a396ca0d64573238fbbcf"}, {"sha": "69797cbd49190da8db21fbec921eced0873a610d", "filename": "gcc/ch/lang-options.h", "status": "removed", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41823c5eb7d4504b6a4a396ca0d64573238fbbcf/gcc%2Fch%2Flang-options.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41823c5eb7d4504b6a4a396ca0d64573238fbbcf/gcc%2Fch%2Flang-options.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Flang-options.h?ref=41823c5eb7d4504b6a4a396ca0d64573238fbbcf", "patch": "@@ -1,40 +0,0 @@\n-/* Definitions for switches for GNU CHILL.\n-   Copyright (C) 1995, 1998 Free Software Foundation, Inc.\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-/* This is the contribution to the `documented_lang_options' array in\n-   toplev.c for CHILL.  */\n-\n-DEFINE_LANG_NAME (\"Chill\")\n-     \n-  { \"-lang-chill\", \"\" },\n-  { \"-flocal-loop-counter\", \"\" },\n-  { \"-fno-local-loop-counter\", \"Do not make separate scopes for every 'for' loop\"},\n-  { \"-fgrant-only\", \"Stop after successfully generating a grant file\" },\n-  { \"-fchill-grant-only\", \"\" },\n-  { \"-fold-strings\", \"Implement the 1984 Chill string semantics\" },\n-  { \"-fno-old-strings\", \"\" },\n-  { \"-fignore-case\", \"convert all idenitifers to lower case\" },\n-  { \"-fno-ignore-case\", \"\" },\n-  { \"-fpack\", \"Pack structures into available space\"},\n-  { \"-fno-pack\", \"\" },\n-  { \"-fspecial_UC\", \"Make special words be in uppercase\" },\n-  { \"-fspecial_LC\", \"\" },\n-  { \"-fruntime-checking\", \"\" },\n-  { \"-fno-runtime-checking\", \"Disable runtime checking of parameters\" },"}, {"sha": "1ed4bac14cb9f75bf8de5f0db6e58f2198189434", "filename": "gcc/ch/lang-specs.h", "status": "removed", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41823c5eb7d4504b6a4a396ca0d64573238fbbcf/gcc%2Fch%2Flang-specs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41823c5eb7d4504b6a4a396ca0d64573238fbbcf/gcc%2Fch%2Flang-specs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Flang-specs.h?ref=41823c5eb7d4504b6a4a396ca0d64573238fbbcf", "patch": "@@ -1,30 +0,0 @@\n-/* Definitions for specs for GNU CHILL.\n-   Copyright (C) 1995, 1998, 1999 Free Software Foundation, Inc..\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-/* This is the contribution to the `default_compilers' array in gcc.c for\n-   CHILL.  */\n-\n-  {\".ch\",  \"@chill\"},\n-  {\".chi\", \"@chill\"},\n-  {\"@chill\",\n-     \"tradcpp0 -lang-chill %{!no-gcc:-D__GNUCHILL__=%v1} %(cpp_options)\\\n-\t      %{!M:%{!MM:%{!E:%{!pipe:%g.i} |\\n\\\n-      cc1chill %{!pipe:%g.i} %(cc1_options)\\\n-      %{!fsyntax-only:%(invoke_as)}}}}\\n\"},"}, {"sha": "5c943fe60809861c62ffd08dfc15daf9efb91fca", "filename": "gcc/ch/lang.c", "status": "removed", "additions": 0, "deletions": 308, "changes": 308, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41823c5eb7d4504b6a4a396ca0d64573238fbbcf/gcc%2Fch%2Flang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41823c5eb7d4504b6a4a396ca0d64573238fbbcf/gcc%2Fch%2Flang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Flang.c?ref=41823c5eb7d4504b6a4a396ca0d64573238fbbcf", "patch": "@@ -1,308 +0,0 @@\n-/* Language-specific hook definitions for CHILL front end.\n-   Copyright (C) 1992, 1993, 1994, 1998, 1999, 2000, 2001\n-   Free Software Foundation, Inc.\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"tree.h\"\n-#include \"ch-tree.h\"\n-#include \"lex.h\"\n-#include \"input.h\"\n-#include \"toplev.h\"\n-#include \"rtl.h\"\n-#include \"expr.h\"\n-#include \"diagnostic.h\"\n-\n-/* Type node for boolean types.  */\n-\n-tree boolean_type_node;\n-\n-/* True if STRING(INDEX) yields a CHARS(1) (or BOOLS(1)) rather than\n-   a CHAR (or BOOL).  Also, makes CHARS(1) similar for CHAR,\n-   and BOOLS(1) similar to BOOL.  This is for compatibility\n-   for the 1984 version of Z.200.*/\n-int flag_old_strings = 0;\n-\n-/* This is set non-zero to force user input tokens to lower case.\n-   This is non-standard.  See Z.200, page 8. */\n-int ignore_case = 1;\n-\n-/* True if reserved and predefined words ('special' words in the Z.200\n-   terminology) are in uppercase.  Obviously, this had better not be \n-   true if we're ignoring input case. */\n-int special_UC = 0;\n-\n-/* The actual name of the input file, regardless of any #line directives */\n-const char* chill_real_input_filename;\n-extern FILE* finput;\n-\n-static int deep_const_expr\t\t\tPARAMS ((tree));\n-static void chill_print_error_function          PARAMS ((diagnostic_context *,\n-                                                         const char *));\n-\f\n-/* Return 1 if the expression tree given has all\n-   constant nodes as its leaves,otherwise. */\n-\n-static int\n-deep_const_expr (exp)\n-     tree exp;\n-{\n-  enum chill_tree_code code;\n-  int length;\n-  int i;\n-\n-  if (exp == NULL_TREE)\n-    return 0;\n-\n-  code = TREE_CODE (exp);\n-  length = first_rtl_op (TREE_CODE (exp));\n-\n-  /* constant leaf?  return TRUE */\n-  if (TREE_CODE_CLASS (code) == 'c')\n-    return 1;\n-\n-  /* Recursively check next level down.  */\n-  for (i = 0; i < length; i++)\n-    if (! deep_const_expr (TREE_OPERAND (exp, i)))\n-      return 0;\n-  return 1;      \n-}\n-\n-\n-tree\n-const_expr (exp)\n-     tree exp;\n-{\n-  if (TREE_CODE (exp) == INTEGER_CST)\n-    return exp;\n-  if (TREE_CODE (exp) == CONST_DECL)\n-    return const_expr (DECL_INITIAL (exp));\n-  if (TREE_CODE_CLASS (TREE_CODE (exp)) == 'd'\n-      && DECL_INITIAL (exp) != NULL_TREE\n-      && TREE_READONLY (exp))\n-    return DECL_INITIAL (exp);\n-  if (deep_const_expr (exp))\n-    return exp;\n-  if (TREE_CODE (exp) != ERROR_MARK)\n-    error (\"non-constant expression\");\n-  return error_mark_node;\n-}\n-\n-/* Each of the functions defined here\n-   is an alternative to a function in objc-actions.c.  */\n-   \n-/* Used by c-lex.c, but only for objc.  */\n-tree\n-lookup_interface (arg)\n-     tree arg ATTRIBUTE_UNUSED;\n-{\n-  return 0;\n-}\n-\n-int\n-maybe_objc_comptypes (lhs, rhs)\n-     tree lhs ATTRIBUTE_UNUSED, rhs ATTRIBUTE_UNUSED;\n-{\n-  return -1;\n-}\n-\n-tree\n-maybe_building_objc_message_expr ()\n-{\n-  return 0;\n-}\n-\n-int\n-recognize_objc_keyword ()\n-{\n-  return 0;\n-}\n-\n-void\n-lang_init_options ()\n-{\n-}\n-\n-/* used by print-tree.c */\n-\n-void\n-lang_print_xnode (file, node, indent)\n-     FILE *file ATTRIBUTE_UNUSED;\n-     tree node ATTRIBUTE_UNUSED;\n-     int indent ATTRIBUTE_UNUSED;\n-{\n-}\n-\f\n-/*\n- * process chill-specific compiler command-line options\n- * do not complain if the option is not recognised\n- */\n-int\n-lang_decode_option (argc, argv)\n-     int argc;\n-     char **argv;\n-{\n-  char *p = argv[0];\n-  static int explicit_ignore_case = 0;\n-  if (!strcmp(p, \"-lang-chill\"))\n-    ; /* do nothing */\n-  else if (!strcmp (p, \"-fruntime-checking\"))\n-    {\n-      range_checking = 1;\n-      empty_checking = 1;\n-    }\n-  else if (!strcmp (p, \"-fno-runtime-checking\"))\n-    {\n-      range_checking = 0;\n-      empty_checking = 0;\n-      runtime_checking_flag = 0;\n-    }\n-  else if (!strcmp (p, \"-flocal-loop-counter\"))\n-    flag_local_loop_counter = 1;\n-  else if (!strcmp (p, \"-fno-local-loop-counter\"))\n-    flag_local_loop_counter = 0;\n-  else if (!strcmp (p, \"-fold-strings\"))\n-    flag_old_strings = 1;\n-  else if (!strcmp (p, \"-fno-old-strings\"))\n-    flag_old_strings = 0;\n-  else if (!strcmp (p, \"-fignore-case\"))\n-    {\n-      explicit_ignore_case = 1;\n-      if (special_UC)\n-\t{\n-\t  error (\"ignoring case upon input and\");\n-\t  error (\"making special words uppercase wouldn't work\");\n-\t}\n-      else\n-\tignore_case = 1;\n-    }\n-  else if (!strcmp (p, \"-fno-ignore-case\"))\n-    ignore_case = 0;\n-  else if (!strcmp (p, \"-fspecial_UC\"))\n-    {\n-      if (explicit_ignore_case)\n-\t{\n-\t  error (\"making special words uppercase and\");\n-\t  error (\" ignoring case upon input wouldn't work\");\n-\t}\n-      else\n-\tspecial_UC = 1, ignore_case = 0;\n-    }\n-  else if (!strcmp (p, \"-fspecial_LC\"))\n-    special_UC = 0;\n-  else if (!strcmp (p, \"-fpack\"))\n-    maximum_field_alignment = BITS_PER_UNIT;\n-  else if (!strcmp (p, \"-fno-pack\"))\n-    maximum_field_alignment = 0;\n-  else if (!strcmp (p, \"-fchill-grant-only\"))\n-    grant_only_flag = 1;\n-  else if (!strcmp (p, \"-fgrant-only\"))\n-    grant_only_flag = 1;\n-  /* user has specified a seize-file path */\n-  else if (p[0] == '-' && p[1] == 'I')\n-    register_seize_path (&p[2]);\n-  if (!strcmp(p, \"-itu\"))        /* Force Z.200 semantics */\n-    {\n-      pedantic = 1;   /* FIXME: new flag name? */\n-      flag_local_loop_counter = 1;      \n-    }\n-  else\n-    return c_decode_option (argc, argv);\n-\n-  return 1;\n-}\n-\n-static void\n-chill_print_error_function (context, file)\n-     diagnostic_context *buffer __attribute__((__unused__));\n-     const char *file;\n-{\n-  static tree last_error_function = NULL_TREE;\n-  static struct module *last_error_module = NULL;\n-\n-  if (last_error_function == current_function_decl\n-      && last_error_module == current_module)\n-    return;\n-\n-  last_error_function = current_function_decl;\n-  last_error_module = current_module;\n-\n-  if (file)\n-    fprintf (stderr, \"%s: \", file);\n-\n-  if (current_function_decl == global_function_decl\n-      || current_function_decl == NULL_TREE)\n-    {\n-      if (current_module == NULL)\n-\tfprintf (stderr, \"At top level:\\n\");\n-      else\n-\tfprintf (stderr, \"In module %s:\\n\",\n-\t\t IDENTIFIER_POINTER (current_module->name));\n-    }\n-  else\n-    {\n-      const char *kind = \"function\";\n-      const char *name = (*decl_printable_name) (current_function_decl, 2);\n-      fprintf (stderr, \"In %s `%s':\\n\", kind, name);\n-    }\n-}\n-\n-/* Print an error message for invalid use of an incomplete type.\n-   VALUE is the expression that was used (or 0 if that isn't known)\n-   and TYPE is the type that was invalid.  */\n-\n-void\n-incomplete_type_error (value, type)\n-     tree value ATTRIBUTE_UNUSED;\n-     tree type ATTRIBUTE_UNUSED;\n-{\n-  error (\"internal error - use of undefined type\");\n-}\n-\n-/* Return the typed-based alias set for T, which may be an expression\n-   or a type.  Return -1 if we don't do anything special.  */\n-\n-HOST_WIDE_INT\n-lang_get_alias_set (t)\n-     tree t ATTRIBUTE_UNUSED;\n-{\n-  /* ??? Need to figure out what the rules are.  Certainly we'd need\n-     to handle union-like things, and probably variant records. \n-     Until then, turn off type-based aliasing completely.  */\n-  return 0;\n-}\n-\n-void\n-lang_init ()\n-{\n-  chill_real_input_filename = input_filename;\n-\n-  /* the beginning of the file is a new line; check for # */\n-  /* With luck, we discover the real source file's name from that\n-     and put it in input_filename.  */\n-\n-  ungetc (check_newline (), finput);\n-\n-  /* set default grant file */\n-  set_default_grant_file ();\n-\n-  print_error_function = chill_print_error_function;\n-}"}, {"sha": "8b05f52ec29f6e125f1b04e69f671ee9ef2dfb55", "filename": "gcc/ch/lex.c", "status": "removed", "additions": 0, "deletions": 2229, "changes": 2229, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41823c5eb7d4504b6a4a396ca0d64573238fbbcf/gcc%2Fch%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41823c5eb7d4504b6a4a396ca0d64573238fbbcf/gcc%2Fch%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Flex.c?ref=41823c5eb7d4504b6a4a396ca0d64573238fbbcf", "patch": "@@ -1,2229 +0,0 @@\n-/* Lexical analyzer for GNU CHILL. -*- C -*-\n-   Copyright (C) 1992, 1993, 1994, 1998, 1999, 2000, 2001\n-   Free Software Foundation, Inc.\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-\t General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\f\n-#include \"config.h\"\n-#include \"system.h\"\n-#include <sys/stat.h>\n-\n-#include \"tree.h\"\n-#include \"input.h\"\n-\n-#include \"lex.h\"\n-#include \"ch-tree.h\"\n-#include \"flags.h\"\n-#include \"parse.h\"\n-#include \"obstack.h\"\n-#include \"toplev.h\"\n-#include \"tm_p.h\"\n-\n-#ifdef MULTIBYTE_CHARS\n-#include <locale.h>\n-#endif\n-\n-/* include the keyword recognizers */\n-#include \"hash.h\"\n-\n-FILE* finput;\n-\n-#if 0\n-static int\tlast_token = 0;\n-/* Sun's C compiler warns about the safer sequence \n-   do { .. } while 0 \n-   when there's a 'return' inside the braces, so don't use it */\n-#define RETURN_TOKEN(X) { last_token = X; return (X); }\n-#endif\n-\n-/* This is set non-zero to force incoming tokens to lowercase. */\n-extern int ignore_case;\n-\n-extern int module_number;\n-extern int serious_errors;\n-\n-/* This is non-zero to recognize only uppercase special words. */\n-extern int special_UC;\n-\n-extern struct obstack permanent_obstack;\n-extern struct obstack temporary_obstack;\n-\n-/* forward declarations */\n-static void close_input_file         PARAMS ((const char *));\n-static tree convert_bitstring        PARAMS ((char *));\n-static tree convert_integer          PARAMS ((char *));\n-static void maybe_downcase           PARAMS ((char *));\n-static int  maybe_number             PARAMS ((const char *));\n-static tree equal_number             PARAMS ((void));\n-static void handle_use_seizefile_directive PARAMS ((int));\n-static int  handle_name\t\t     PARAMS ((tree));\n-static char *readstring              PARAMS ((int, int *));\n-static void read_directive\t     PARAMS ((void));\n-static tree read_identifier\t     PARAMS ((int));\n-static tree read_number              PARAMS ((int));\n-static void skip_c_comment           PARAMS ((void));\n-static void skip_line_comment        PARAMS ((void));\n-static int  skip_whitespace          PARAMS ((void));\n-static tree string_or_char           PARAMS ((int, const char *));\n-static void ch_lex_init              PARAMS ((void));\n-static void skip_directive           PARAMS ((void));\n-static int same_file                 PARAMS ((const char *, const char *));\n-static int getlc                     PARAMS ((FILE *));\n-\n-/* next variables are public, because ch-actions uses them */\n-\n-/* the default grantfile name, set by lang_init */\n-tree default_grant_file = 0;\n-\n-/* These tasking-related variables are NULL at the start of each \n-   compiler pass, and are set to an expression tree if and when\n-   a compiler directive is parsed containing an expression.\n-   The NULL state is significant;  it means 'no user-specified\n-   signal_code (or whatever) has been parsed'. */\n-\n-/* process type, set by <> PROCESS_TYPE = number <> */\n-tree process_type = NULL_TREE;\n-\n-/* send buffer default priority,\n-   set by <> SEND_BUFFER_DEFAULT_PRIORITY = number <> */\n-tree send_buffer_prio = NULL_TREE;\n-\n-/* send signal default priority,\n-   set by <> SEND_SIGNAL_DEFAULT_PRIORITY = number <> */\n-tree send_signal_prio = NULL_TREE;\n-\n-/* signal code, set by <> SIGNAL_CODE = number <> */\n-tree signal_code = NULL_TREE;\n-\n-/* flag for range checking */\n-int range_checking = 1;\n-\n-/* flag for NULL pointer checking */\n-int empty_checking = 1;\n-\n-/* flag to indicate making all procedure local variables\n-   to be STATIC */\n-int all_static_flag = 0;\n-\n-/* flag to indicate -fruntime-checking command line option.\n-   Needed for initializing range_checking and empty_checking\n-   before pass 2 */\n-int runtime_checking_flag = 1;\n-\n-/* The elements of `ridpointers' are identifier nodes\n-   for the reserved type names and storage classes.\n-   It is indexed by a RID_... value.  */\n-tree ridpointers[(int) RID_MAX];\n-\n-/* Nonzero tells yylex to ignore \\ in string constants.  */\n-static int ignore_escape_flag = 0;\n-\n-static int maxtoken;\t\t/* Current nominal length of token buffer.  */\n-char *token_buffer;\t/* Pointer to token buffer.\n-\t\t\t   Actual allocated length is maxtoken + 2.\n-\t\t\t   This is not static because objc-parse.y uses it.  */\n-\n-/* implement yylineno handling for flex */\n-#define yylineno lineno\n-\n-static int inside_c_comment = 0;\n-\n-static int saw_eol = 0; /* 1 if we've just seen a '\\n' */\n-static int saw_eof = 0; /* 1 if we've just seen an EOF */\n-\n-typedef struct string_list\n-  {\n-    struct string_list *next;\n-    char               *str;\n-  } STRING_LIST;\n-\n-/* list of paths specified on the compiler command line by -L options. */\n-static STRING_LIST *seize_path_list = (STRING_LIST *)0;\n-\n-/* List of seize file names.  Each TREE_VALUE is an identifier\n-   (file name) from a <>USE_SEIZE_FILE<> directive.\n-   The TREE_PURPOSE is non-NULL if a USE_SEIZE_FILE directive has been\n-   written to the grant file. */\n-static tree files_to_seize     = NULL_TREE;\n-/* Last node on files_to_seize list. */\n-static tree last_file_to_seize = NULL_TREE;\n-/* Pointer into files_to_seize list:  Next unparsed file to read. */\n-static tree next_file_to_seize = NULL_TREE;\n-\n-/* The most recent use_seize_file directive. */\n-tree use_seizefile_name = NULL_TREE;\n-\n-/* If non-NULL, the name of the seizefile we're currently processing. */\n-tree current_seizefile_name = NULL_TREE;\n-\f\n-/* called to reset for pass 2 */\n-static void\n-ch_lex_init ()\n-{\n-  current_seizefile_name = NULL_TREE;\n-\n-  lineno = 0;\n-\n-  saw_eol = 0;\n-  saw_eof = 0;\n-  /* Initialize these compiler-directive variables. */\n-  process_type     = NULL_TREE;\n-  send_buffer_prio = NULL_TREE;\n-  send_signal_prio = NULL_TREE;\n-  signal_code      = NULL_TREE;\n-  all_static_flag  = 0;\n-  /* reinitialize rnage checking and empty checking */\n-  range_checking = runtime_checking_flag;\n-  empty_checking = runtime_checking_flag;\n-}\n-\n-\n-const char *\n-init_parse (filename)\n-     const char *filename;\n-{\n-  int lowercase_standard_names = ignore_case || ! special_UC;\n-\n-  /* Open input file.  */\n-  if (filename == 0 || !strcmp (filename, \"-\"))\n-    {\n-      finput = stdin;\n-      filename = \"stdin\";\n-    }\n-  else\n-    finput = fopen (filename, \"r\");\n-\n-  if (finput == 0)\n-    fatal_io_error (\"can't open %s\", filename);\n-\n-#ifdef IO_BUFFER_SIZE\n-  setvbuf (finput, (char *) xmalloc (IO_BUFFER_SIZE), _IOFBF, IO_BUFFER_SIZE);\n-#endif\n-\n-  /* Make identifier nodes long enough for the language-specific slots.  */\n-  set_identifier_size (sizeof (struct lang_identifier));\n-\n-  /* Start it at 0, because check_newline is called at the very beginning\n-     and will increment it to 1.  */\n-  lineno = 0;\n-\n-  /* Initialize these compiler-directive variables. */\n-  process_type     = NULL_TREE;\n-  send_buffer_prio = NULL_TREE;\n-  send_signal_prio = NULL_TREE;\n-  signal_code      = NULL_TREE;\n-\n-  maxtoken         = 40;\n-  token_buffer     = xmalloc ((unsigned)(maxtoken + 2));\n-\n-  init_chill_expand ();\n-\n-#define ENTER_STANDARD_NAME(RID, LOWER, UPPER) \\\n-  ridpointers[(int) RID] = \\\n-    get_identifier (lowercase_standard_names ? LOWER : UPPER)\n-\n-  ENTER_STANDARD_NAME (RID_ALL,\t\t\"all\",\t\t\"ALL\");\n-  ENTER_STANDARD_NAME (RID_ASSERTFAIL,\t\"assertfail\",\t\"ASSERTFAIL\");\n-  ENTER_STANDARD_NAME (RID_ASSOCIATION,\t\"association\",\t\"ASSOCIATION\");\n-  ENTER_STANDARD_NAME (RID_BIN,         \"bin\",          \"BIN\");\n-  ENTER_STANDARD_NAME (RID_BOOL,\t\"bool\",\t\t\"BOOL\");\n-  ENTER_STANDARD_NAME (RID_BOOLS,\t\"bools\",\t\"BOOLS\");\n-  ENTER_STANDARD_NAME (RID_BYTE,\t\"byte\",\t\t\"BYTE\");\n-  ENTER_STANDARD_NAME (RID_CHAR,\t\"char\",\t\t\"CHAR\");\n-  ENTER_STANDARD_NAME (RID_DOUBLE,\t\"double\",\t\"DOUBLE\");\n-  ENTER_STANDARD_NAME (RID_DURATION,    \"duration\",     \"DURATION\");\n-  ENTER_STANDARD_NAME (RID_DYNAMIC,\t\"dynamic\",\t\"DYNAMIC\");\n-  ENTER_STANDARD_NAME (RID_ELSE,\t\"else\",\t\t\"ELSE\");\n-  ENTER_STANDARD_NAME (RID_EMPTY,\t\"empty\",\t\"EMPTY\");\n-  ENTER_STANDARD_NAME (RID_FALSE,\t\"false\",\t\"FALSE\");\n-  ENTER_STANDARD_NAME (RID_FLOAT,\t\"float\",\t\"FLOAT\");\n-  ENTER_STANDARD_NAME (RID_GENERAL,\t\"general\",\t\"GENERAL\");\n-  ENTER_STANDARD_NAME (RID_IN,\t\t\"in\",\t\t\"IN\");\n-  ENTER_STANDARD_NAME (RID_INLINE,\t\"inline\",\t\"INLINE\");\n-  ENTER_STANDARD_NAME (RID_INOUT,\t\"inout\",\t\"INOUT\");\n-  ENTER_STANDARD_NAME (RID_INSTANCE,\t\"instance\",\t\"INSTANCE\");\n-  ENTER_STANDARD_NAME (RID_INT,\t\t\"int\",\t\t\"INT\");\n-  ENTER_STANDARD_NAME (RID_LOC,\t\t\"loc\",\t\t\"LOC\");\n-  ENTER_STANDARD_NAME (RID_LONG,\t\"long\",\t\t\"LONG\");\n-  ENTER_STANDARD_NAME (RID_LONG_REAL,\t\"long_real\",\t\"LONG_REAL\");\n-  ENTER_STANDARD_NAME (RID_NULL,\t\"null\",\t\t\"NULL\");\n-  ENTER_STANDARD_NAME (RID_OUT,\t\t\"out\",\t\t\"OUT\");\n-  ENTER_STANDARD_NAME (RID_OVERFLOW,\t\"overflow\",\t\"OVERFLOW\");\n-  ENTER_STANDARD_NAME (RID_PTR,\t\t\"ptr\",\t\t\"PTR\");\n-  ENTER_STANDARD_NAME (RID_READ,\t\"read\",\t\t\"READ\");\n-  ENTER_STANDARD_NAME (RID_REAL,\t\"real\",\t\t\"REAL\");\n-  ENTER_STANDARD_NAME (RID_RANGE,\t\"range\",\t\"RANGE\");\n-  ENTER_STANDARD_NAME (RID_RANGEFAIL,\t\"rangefail\",\t\"RANGEFAIL\");\n-  ENTER_STANDARD_NAME (RID_RECURSIVE,\t\"recursive\",\t\"RECURSIVE\");\n-  ENTER_STANDARD_NAME (RID_SHORT,\t\"short\",\t\"SHORT\");\n-  ENTER_STANDARD_NAME (RID_SIMPLE,\t\"simple\",\t\"SIMPLE\");\n-  ENTER_STANDARD_NAME (RID_TIME,        \"time\",         \"TIME\");\n-  ENTER_STANDARD_NAME (RID_TRUE,\t\"true\",\t\t\"TRUE\");\n-  ENTER_STANDARD_NAME (RID_UBYTE,\t\"ubyte\",\t\"UBYTE\");\n-  ENTER_STANDARD_NAME (RID_UINT,\t\"uint\",\t\t\"UINT\");\n-  ENTER_STANDARD_NAME (RID_ULONG,\t\"ulong\",\t\"ULONG\");\n-  ENTER_STANDARD_NAME (RID_UNSIGNED,\t\"unsigned\",\t\"UNSIGNED\");\n-  ENTER_STANDARD_NAME (RID_USHORT,\t\"ushort\",\t\"USHORT\");\n-  ENTER_STANDARD_NAME (RID_VOID,\t\"void\",\t\t\"VOID\");\n-\n-  return filename;\n-}\n-\n-void\n-finish_parse ()\n-{\n-  if (finput != NULL)\n-    fclose (finput);\n-}\n-\f\n-static int yywrap PARAMS ((void));\n-static int yy_refill PARAMS ((void));\n-\n-#define YY_PUTBACK_SIZE 5\n-#define YY_BUF_SIZE 1000\n-\n-static char yy_buffer[YY_PUTBACK_SIZE + YY_BUF_SIZE];\n-static char *yy_cur = yy_buffer + YY_PUTBACK_SIZE;\n-static char *yy_lim = yy_buffer + YY_PUTBACK_SIZE;\n-\n-static int\n-yy_refill ()\n-{\n-  char *buf = yy_buffer + YY_PUTBACK_SIZE;\n-  int c, result;\n-  bcopy (yy_cur - YY_PUTBACK_SIZE, yy_buffer, YY_PUTBACK_SIZE);\n-  yy_cur = buf;\n-\n- retry:\n-  if (saw_eof)\n-    {\n-      if (yywrap ())\n-\treturn EOF;\n-      saw_eof = 0;\n-      goto retry;\n-    }\n-\n-  result = 0;\n-  while (saw_eol)\n-    {\n-      c = check_newline ();\n-      if (c == EOF)\n-        {\n-\t  saw_eof = 1;\n-\t  goto retry;\n-\t}\n-      else if (c != '\\n')\n-\t{\n-\t  saw_eol = 0;\n-\t  buf[result++] = c;\n-\t}\n-    }\n-  \n-  while (result < YY_BUF_SIZE)\n-    {\n-      c = getc(finput);\n-      if (c == EOF)\n-        {\n-\t  saw_eof = 1;\n-\t  break;\n-\t}\n-      buf[result++] = c;\n-      \n-      /* Because we might switch input files on a compiler directive\n-\t (that end with '>', don't read past a '>', just in case. */\n-      if (c == '>')\n-\tbreak;\n-      \n-      if (c == '\\n')\n-\t{\n-#ifdef YYDEBUG\n-\t  extern int yydebug;\n-\t  if (yydebug)\n-            fprintf (stderr, \"-------------------------- finished Line %d\\n\",\n-\t\t     yylineno);\n-#endif\n-\t  saw_eol = 1;\n-\t  break;\n-\t}\n-    }\n-\n-  yy_lim = yy_cur + result;\n-\n-  return yy_lim > yy_cur ? *yy_cur++ : EOF;\n-}\n-\n-#define input() (yy_cur < yy_lim ? *yy_cur++ : yy_refill ())\n-\n-#define unput(c) (*--yy_cur = (c))\n-\f\n-\n-int starting_pass_2 = 0;\n-\n-int\n-yylex ()\n-{\n-  int nextc;\n-  int len;\n-  char* tmp;\n-  int base;\n-  int ch;\n- retry:\n-  ch = input ();\n-  if (starting_pass_2)\n-    {\n-      starting_pass_2 = 0;\n-      unput (ch);\n-      return END_PASS_1;\n-    }\n-  switch (ch)\n-    {\n-    case ' ': case '\\t': case '\\n': case '\\f': case '\\b': case '\\v': case '\\r':\n-      goto retry;\n-    case '[':\n-      return LPC;\n-    case ']':\n-      return RPC;\n-    case '{':\n-      return LC;\n-    case '}':\n-      return RC;\n-    case '(':\n-      nextc = input ();\n-      if (nextc == ':')\n-\treturn LPC;\n-      unput (nextc);\n-      return LPRN;\n-    case ')':\n-      return RPRN;\n-    case ':':\n-      nextc = input ();\n-      if (nextc == ')')\n-\treturn RPC;\n-      else if (nextc == '=')\n-\treturn ASGN;\n-      unput (nextc);\n-      return COLON;\n-    case ',':\n-      return COMMA;\n-    case ';':\n-      return SC;\n-    case '+':\n-      return PLUS;\n-    case '-':\n-      nextc = input ();\n-      if (nextc == '>')\n-\treturn ARROW;\n-      if (nextc == '-')\n-\t{\n-\t  skip_line_comment ();\n-\t  goto retry;\n-\t}\n-      unput (nextc);\n-      return SUB;\n-    case '*':\n-      return MUL;\n-    case '=':\n-      return EQL;\n-    case '/':\n-      nextc = input ();\n-      if (nextc == '/')\n-\treturn CONCAT;\n-      else if (nextc == '=')\n-\treturn NE;\n-      else if (nextc == '*')\n-\t{\n-\t  skip_c_comment ();\n-\t  goto retry;\n-\t}\n-      unput (nextc);\n-      return DIV;\n-    case '<':\n-      nextc = input ();\n-      if (nextc == '=')\n-\treturn LTE;\n-      if (nextc == '>')\n-\t{\n-\t  read_directive ();\n-\t  goto retry;\n-\t}\n-      unput (nextc);\n-      return LT;\n-    case '>':\n-      nextc = input ();\n-      if (nextc == '=')\n-\treturn GTE;\n-      unput (nextc);\n-      return GT;\n-\n-    case 'D': case 'd':\n-      base = 10;\n-      goto maybe_digits;\n-    case 'B': case 'b':\n-      base = 2;\n-      goto maybe_digits;\n-    case 'H': case 'h':\n-      base = 16;\n-      goto maybe_digits;\n-    case 'O': case 'o':\n-      base = 8;\n-      goto maybe_digits;\n-    case 'C': case 'c':\n-      nextc = input ();\n-      if (nextc == '\\'')\n-\t{\n-\t  int byte_val = 0;\n-\t  char *start;\n-\t  int len = 0;  /* Number of hex digits seen. */\n-\t  for (;;)\n-\t    {\n-\t      ch = input ();\n-\t      if (ch == '\\'')\n-\t\tbreak;\n-\t      if (ch == '_')\n-\t\tcontinue;\n-\t      if (!ISXDIGIT (ch))           /* error on non-hex digit */\n-\t\t{\n-\t\t  if (pass == 1)\n-\t\t    error (\"invalid C'xx' \");\n-\t\t  break;\n-\t\t}\n-\t      if (ch >= 'a')\n-\t\tch -= ' ';\n-\t      ch -= '0';\n-\t      if (ch > 9)\n-\t\tch -= 7;\n-\t      byte_val *= 16;\n-\t      byte_val += (int)ch;\n-\n-\t      if (len & 1) /* collected two digits, save byte */\n-\t\tobstack_1grow (&temporary_obstack, (char) byte_val);\n-\t      len++;\n-\t    }\n-\t  start = obstack_finish (&temporary_obstack);\n-\t  yylval.ttype = string_or_char (len >> 1, start);\n-\t  obstack_free (&temporary_obstack, start);\n-\t  return len == 2 ? SINGLECHAR : STRING;\n-\t}\n-      unput (nextc);\n-      goto letter;\n-\n-    maybe_digits:\n-      nextc = input ();\n-      if (nextc == '\\'')\n-\t{\n-\t  char *start;\n-\t  obstack_1grow (&temporary_obstack, ch);\n-\t  obstack_1grow (&temporary_obstack, nextc);\n-\t  for (;;)\n-\t    {\n-\t      ch = input ();\n-\t      if (ISALNUM (ch))\n-\t\tobstack_1grow (&temporary_obstack, ch);\n-\t      else if (ch != '_')\n-\t\tbreak;\n-\t    }\n-\t  obstack_1grow (&temporary_obstack, '\\0');\n-\t  start = obstack_finish (&temporary_obstack);\n-\t  if (ch != '\\'')\n-\t    {\n-\t      unput (ch);\n-\t      yylval.ttype = convert_integer (start); /* Pass base? */\n-\t      return NUMBER;\n-\t    }\n-\t  else\n-\t    {\n-\t      yylval.ttype = convert_bitstring (start);\n-\t      return BITSTRING;\n-\t    }\n-\t}\n-      unput (nextc);\n-      goto letter;\n-\n-    case 'A':                                   case 'E':\n-    case 'F':  case 'G':             case 'I':  case 'J':\n-    case 'K':  case 'L':  case 'M':  case 'N':\n-    case 'P':  case 'Q':  case 'R':  case 'S':  case 'T':\n-    case 'U':  case 'V':  case 'W':  case 'X':  case 'Y':\n-    case 'Z':\n-    case 'a':                                   case 'e':\n-    case 'f':  case 'g':             case 'i':  case 'j':\n-    case 'k':  case 'l':  case 'm':  case 'n':\n-    case 'p':  case 'q':  case 'r':  case 's':  case 't':\n-    case 'u':  case 'v':  case 'w':  case 'x':  case 'y':\n-    case 'z':\n-    case '_':\n-    letter:\n-      return handle_name (read_identifier (ch));\n-    case '\\'':\n-      tmp = readstring ('\\'', &len);\n-      yylval.ttype = string_or_char (len, tmp);\n-      free (tmp);\n-      return len == 1 ? SINGLECHAR : STRING;\n-    case '\\\"':\n-      tmp = readstring ('\\\"', &len);\n-      yylval.ttype = build_chill_string (len, tmp);\n-      free (tmp);\n-      return STRING;\n-    case '.':\n-      nextc = input ();\n-      unput (nextc);\n-      if (ISDIGIT (nextc)) /* || nextc == '_')  we don't start numbers with '_' */\n-\tgoto number;\n-      return DOT;\n-    case '0': case '1': case '2': case '3': case '4':\n-    case '5': case '6': case '7': case '8': case '9':\n-    number:\n-      yylval.ttype = read_number (ch);\n-      return TREE_CODE (yylval.ttype) == REAL_CST ? FLOATING : NUMBER;\n-    default:\n-      return ch;\n-    }\n-}\n-\n-static void\n-close_input_file (fn)\n-  const char *fn;\n-{\n-  if (finput == NULL)\n-    abort ();\n-\n-  if (finput != stdin && fclose (finput) == EOF)\n-    {\n-      error (\"can't close %s\", fn);\n-      abort ();\n-    }\n-  finput = NULL;\n-}\n-\n-/* Return an identifier, starting with FIRST and then reading\n-   more characters using input().  Return an IDENTIFIER_NODE. */\n-\n-static tree\n-read_identifier (first)\n-     int first; /* First letter of identifier */\n-{\n-  tree id;\n-  char *start;\n-  for (;;)\n-    {\n-      obstack_1grow (&temporary_obstack, first);\n-      first = input ();\n-      if (first == EOF)\n-\tbreak;\n-      if (! ISALNUM (first) && first != '_')\n-\t{\n-\t  unput (first);\n-\t  break;\n-\t}\n-    }\n-  obstack_1grow (&temporary_obstack, '\\0');\n-  start = obstack_finish (&temporary_obstack);\n-  maybe_downcase (start);\n-  id = get_identifier (start);\n-  obstack_free (&temporary_obstack, start);\n-  return id;\n-}\n-\n-/* Given an identifier ID, check to see if it is a reserved name,\n-   and return the appropriate token type. */\n-\n-static int\n-handle_name (id)\n-     tree id;\n-{\n-  struct resword *tp;\n-  tp = in_word_set (IDENTIFIER_POINTER (id), IDENTIFIER_LENGTH (id));\n-  if (tp != NULL\n-      && special_UC == ISUPPER ((unsigned char) tp->name[0])\n-      && (tp->flags == RESERVED || tp->flags == PREDEF))\n-    {\n-      if (tp->rid != NORID)\n-\tyylval.ttype = ridpointers[tp->rid];\n-      else if (tp->token == THIS)\n-\tyylval.ttype = lookup_name (get_identifier (\"__whoami\"));\n-      return tp->token;\n-    }\n-  yylval.ttype = id;\n-  return NAME;\n-}\n-\n-static tree\n-read_number (ch)\n-     int ch; /* Initial character */\n-{\n-  tree num;\n-  char *start;\n-  int is_float = 0;\n-  for (;;)\n-    {\n-      if (ch != '_')\n-\tobstack_1grow (&temporary_obstack, ch);\n-      ch = input ();\n-      if (! ISDIGIT (ch) && ch != '_')\n-\tbreak;\n-    }\n-  if (ch == '.')\n-    {\n-      do\n-\t{\n-\t  if (ch != '_')\n-\t    obstack_1grow (&temporary_obstack, ch);\n-\t  ch = input ();\n-\t} while (ISDIGIT (ch) || ch == '_');\n-      is_float++;\n-    }\n-  if (ch == 'd' || ch == 'D' || ch == 'e' || ch == 'E')\n-    {\n-      /* Convert exponent indication [eEdD] to 'e'. */\n-      obstack_1grow (&temporary_obstack, 'e');\n-      ch = input ();\n-      if (ch == '+' || ch == '-')\n-\t{\n-\t  obstack_1grow (&temporary_obstack, ch);\n-\t  ch = input ();\n-\t}\n-      if (ISDIGIT (ch) || ch == '_')\n-\t{\n-\t  do\n-\t    {\n-\t      if (ch != '_')\n-\t\tobstack_1grow (&temporary_obstack, ch);\n-\t      ch = input ();\n-\t    } while (ISDIGIT (ch) || ch == '_');\n-\t}\n-      else\n-\t{\n-\t  error (\"malformed exponent part of floating-point literal\");\n-\t}\n-      is_float++;\n-    }\n-  if (ch != EOF)\n-    unput (ch);\n-  obstack_1grow (&temporary_obstack, '\\0');\n-  start = obstack_finish (&temporary_obstack);\n-  if (is_float)\n-    {\n-      REAL_VALUE_TYPE value;\n-      tree  type = double_type_node;\n-      errno = 0;\n-      value = REAL_VALUE_ATOF (start, TYPE_MODE (type));\n-      obstack_free (&temporary_obstack, start);\n-      if (TARGET_FLOAT_FORMAT != IEEE_FLOAT_FORMAT\n-\t  && REAL_VALUE_ISINF (value) && pedantic)\n-\tpedwarn (\"real number exceeds range of REAL\");\n-      num = build_real (type, value);\n-    }\n-  else\n-    num = convert_integer (start);\n-  CH_DERIVED_FLAG (num) = 1;\n-  return num;\n-}\n-\n-/* Skip to the end of a compiler directive. */\n-\n-static void\n-skip_directive ()\n-{\n-  int ch = input ();\n-  for (;;)\n-    {\n-      if (ch == EOF)\n-\t{\n-\t  error (\"end-of-file in '<>' directive\");\n-\t  break;\n-\t}\n-      if (ch == '\\n')\n-\tbreak;\n-      if (ch == '<')\n-\t{\n-\t  ch = input ();\n-\t  if (ch == '>')\n-\t    break;\n-\t}\n-      ch = input ();\n-    }\n-  starting_pass_2 = 0;\n-}\n-\n-/* Read a compiler directive.  (\"<>{WS}\" have already been read. ) */\n-static void\n-read_directive ()\n-{\n-  struct resword *tp;\n-  tree id;\n-  int ch = skip_whitespace();\n-  if (ISALPHA (ch) || ch == '_')\n-    id = read_identifier (ch);\n-  else if (ch == EOF)\n-    {\n-      error (\"end-of-file in '<>' directive\"); \n-      to_global_binding_level (); \n-      return;\n-    }\n-  else\n-    {\n-      warning (\"unrecognized compiler directive\");\n-      skip_directive ();\n-      return;\n-    }\n-  tp = in_word_set (IDENTIFIER_POINTER (id), IDENTIFIER_LENGTH (id));\n-  if (tp == NULL || special_UC != ISUPPER ((unsigned char) tp->name[0]))\n-    {\n-      if (pass == 1)\n-\twarning (\"unrecognized compiler directive `%s'\",\n-\t\t IDENTIFIER_POINTER (id));\n-    }\n-  else\n-    switch (tp->token)\n-      {\n-      case ALL_STATIC_OFF:\n-\tall_static_flag = 0;\n-\tbreak;\n-      case ALL_STATIC_ON:\n-\tall_static_flag = 1;\n-\tbreak;\n-      case EMPTY_OFF:\n-\tempty_checking = 0;\n-\tbreak;\n-      case EMPTY_ON:\n-\tempty_checking = 1;\n-\tbreak;\n-      case IGNORED_DIRECTIVE:\n-\tbreak;\n-      case PROCESS_TYPE_TOKEN:\n-\tprocess_type = equal_number ();\n-\tbreak;\n-      case RANGE_OFF:\n-\trange_checking = 0;\n-\tbreak;\n-      case RANGE_ON:\n-\trange_checking = 1;\n-\tbreak;\n-      case SEND_SIGNAL_DEFAULT_PRIORITY: \n-\tsend_signal_prio = equal_number ();\n-\tbreak;\n-      case SEND_BUFFER_DEFAULT_PRIORITY:\n-\tsend_buffer_prio = equal_number ();\n-\tbreak;\n-      case SIGNAL_CODE:\n-\tsignal_code = equal_number ();\n-\tbreak;\n-      case USE_SEIZE_FILE:\n-\thandle_use_seizefile_directive (0);\n-\tbreak;\n-      case USE_SEIZE_FILE_RESTRICTED:\n-\thandle_use_seizefile_directive (1);\n-\tbreak;\n-      default:\n-\tif (pass == 1)\n-\t  warning (\"unrecognized compiler directive `%s'\", \n-\t\t   IDENTIFIER_POINTER (id));\n-\tbreak;\n-      }\n-  skip_directive ();\n-}\n-\n-\f\n-tree\n-build_chill_string (len, str)\n-    int   len;\n-    const char  *str;\n-{\n-  tree t;\n-\n-  push_obstacks (&permanent_obstack, &permanent_obstack);\n-  t = build_string (len, str);\n-  TREE_TYPE (t) = build_string_type (char_type_node, \n-\t\t\t\t     build_int_2 (len, 0));\n-  CH_DERIVED_FLAG (t) = 1;\n-  pop_obstacks ();\n-  return t;\n-}\n-\n-\n-static tree\n-string_or_char (len, str)\n-     int   len;\n-     const char *str;\n-{\n-  tree result;\n-  \n-  push_obstacks (&permanent_obstack, &permanent_obstack);\n-  if (len == 1)\n-    {\n-      result = build_int_2 ((unsigned char)str[0], 0);\n-      CH_DERIVED_FLAG (result) = 1;\n-      TREE_TYPE (result) = char_type_node;\n-    }\n-  else\n-    result = build_chill_string (len, str);\n-  pop_obstacks ();\n-  return result;\n-}\n-\n-\n-static void\n-maybe_downcase (str)\n-    char        *str;\n-{\n-  if (! ignore_case)\n-    return;\n-  while (*str)\n-    {\n-      *str = TOLOWER (*str);\n-      str++;\n-    }\n-}\n-\n-\n-static int\n-maybe_number (s)\n-  const char *s;\n-{\n-  char\tfc;\n-  \n-  /* check for decimal number */\n-  if (*s >= '0' && *s <= '9')\n-    {\n-      while (*s)\n-\t{\n-\t  if (*s >= '0' && *s <= '9')\n-\t    s++;\n-\t  else\n-\t    return 0;\n-\t}\n-      return 1;\n-    }\n-  \n-  fc = *s;\n-  if (s[1] != '\\'')\n-    return 0;\n-  s += 2;\n-  while (*s)\n-    {\n-      switch (fc)\n-\t{\n-\tcase 'd':\n-\tcase 'D':\n-\t  if (*s < '0' || *s > '9')\n-\t    return 0;\n-\t  break;\n-\tcase 'h':\n-\tcase 'H':\n-\t  if (!ISXDIGIT ((unsigned char) *s))\n-\t    return 0;\n-\t  break;\n-\tcase 'b':\n-\tcase 'B':\n-\t  if (*s < '0' || *s > '1')\n-\t    return 0;\n-\t  break;\n-\tcase 'o':\n-\tcase 'O':\n-\t  if (*s < '0' || *s > '7')\n-\t    return 0;\n-\t  break;\n-\tdefault:\n-\t  return 0;\n-\t}\n-      s++;\n-    }\n-  return 1;\n-}\n-\f\n-static char *\n-readstring (terminator, len)\n-     char terminator;\n-     int *len;\n-{\n-  int      c;\n-  unsigned allocated = 1024;\n-  char    *tmp = xmalloc (allocated);\n-  unsigned i = 0;\n-  \n-  for (;;)\n-    {\n-      c = input ();\n-      if (c == terminator)\n-\t{\n-\t  if ((c = input ()) != terminator)\n-\t    {\n-\t      unput (c);\n-\t      break;\n-\t    }\n-\t  else\n-\t    c = terminator;\n-\t}\n-      if (c == '\\n' || c == EOF)\n-\t  goto unterminated;\n-      if (c == '^')\n-\t{\n-\t  c = input();\n-\t  if (c == EOF || c == '\\n')\n-\t    goto unterminated;\n-\t  if (c == '^')\n-\t    goto storeit;\n-\t  if (c == '(')\n-\t    {\n-\t      int cc, count = 0;\n-\t      int base = 10;\n-\t      int next_apos = 0;\n-\t      int check_base = 1;\n-\t      c = 0;\n-\t      while (1)\n-\t\t{\n-\t\t  cc = input ();\n-\t\t  if (cc == terminator)\n-\t\t    {\n-\t\t      if (!(terminator == '\\'' && next_apos))\n-\t\t\t{\n-\t\t\t  error (\"unterminated control sequence\");\n-\t\t\t  serious_errors++;\n-\t\t\t  goto done;\n-\t\t\t}\n-\t\t    }\n-\t\t  if (cc == EOF || cc == '\\n')\n-\t\t    {\n-\t\t      c = cc;\n-\t\t      goto unterminated;\n-\t\t    }\n-\t\t  if (next_apos)\n-\t\t    {\n-\t\t      next_apos = 0;\n-\t\t      if (cc != '\\'')\n-\t\t\t{\n-\t\t\t  error (\"invalid integer literal in control sequence\");\n-\t\t\t  serious_errors++;\n-\t\t\t  goto done;\n-\t\t\t}\n-\t\t      continue;\n-\t\t    }\n-\t\t  if (cc == ' ' || cc == '\\t')\n-\t\t    continue;\n-\t\t  if (cc == ')')\n-\t\t    {\n-\t\t      if ((c < 0 || c > 255) && (pass == 1))\n-\t\t\terror (\"control sequence overflow\");\n-\t\t      if (! count && pass == 1)\n-\t\t\terror (\"invalid control sequence\");\n-\t\t      break;\n-\t\t    }\n-\t\t  else if (cc == ',')\n-\t\t    {\n-\t\t      if ((c < 0 || c > 255) && (pass == 1))\n-\t\t\terror (\"control sequence overflow\");\n-\t\t      if (! count && pass == 1)\n-\t\t\terror (\"invalid control sequence\");\n-\t\t      tmp[i++] = c;\n-\t\t      if (i == allocated)\n-\t\t\t{\n-\t\t\t  allocated += 1024;\n-\t\t\t  tmp = xrealloc (tmp, allocated);\n-\t\t\t}\n-\t\t      c = count = 0;\n-\t\t      base = 10;\n-\t\t      check_base = 1;\n-\t\t      continue;\n-\t\t    }\n-\t\t  else if (cc == '_')\n-\t\t    {\n-\t\t      if (! count && pass == 1)\n-\t\t\terror (\"invalid integer literal in control sequence\");\n-\t\t      continue;\n-\t\t    }\n-\t\t  if (check_base)\n-\t\t    {\n-\t\t      if (cc == 'D' || cc == 'd')\n-\t\t\t{\n-\t\t\t  base = 10;\n-\t\t\t  next_apos = 1;\n-\t\t\t}\n-\t\t      else if (cc == 'H' || cc == 'h')\n-\t\t\t{\n-\t\t\t  base = 16;\n-\t\t\t  next_apos = 1;\n-\t\t\t}\n-\t\t      else if (cc == 'O' || cc == 'o')\n-\t\t\t{\n-\t\t\t  base = 8;\n-\t\t\t  next_apos = 1;\n-\t\t\t}\n-\t\t      else if (cc == 'B' || cc == 'b')\n-\t\t\t{\n-\t\t\t  base = 2;\n-\t\t\t  next_apos = 1;\n-\t\t\t}\n-\t\t      check_base = 0;\n-\t\t      if (next_apos)\n-\t\t\tcontinue;\n-\t\t    }\n-\t\t  if (base == 2)\n-\t\t    {\n-\t\t      if (cc < '0' || cc > '1')\n-\t\t\tcc = -1;\n-\t\t      else\n-\t\t\tcc -= '0';\n-\t\t    }\n-\t\t  else if (base == 8)\n-\t\t    {\n-\t\t      if (cc < '0' || cc > '8')\n-\t\t\tcc = -1;\n-\t\t      else\n-\t\t\tcc -= '0';\n-\t\t    }\n-\t\t  else if (base == 10)\n-\t\t    {\n-\t\t      if (! ISDIGIT (cc))\n-\t\t\tcc = -1;\n-\t\t      else\n-\t\t\tcc -= '0';\n-\t\t    }\n-\t\t  else if (base == 16)\n-\t\t    {\n-\t\t      if (!ISXDIGIT (cc))\n-\t\t\tcc = -1;\n-\t\t      else\n-\t\t\t{\n-\t\t\t  if (cc >= 'a')\n-\t\t\t    cc -= ' ';\n-\t\t\t  cc -= '0';\n-\t\t\t  if (cc > 9)\n-\t\t\t    cc -= 7;\n-\t\t\t}\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      error (\"invalid base in read control sequence\");\n-\t\t      abort ();\n-\t\t    }\n-\t\t  if (cc == -1)\n-\t\t    {\n-\t\t      /* error in control sequence */\n-\t\t      if (pass == 1)\n-\t\t\terror (\"invalid digit in control sequence\");\n-\t\t      cc = 0;\n-\t\t    }\n-\t\t  c = (c * base) + cc;\n-\t\t  count++;\n-\t\t}\n-\t    }\n-\t  else\n-\t    c ^= 64;\n-\t}\n-    storeit:\n-      tmp[i++] = c;\n-      if (i == allocated)\n-\t{\n-\t  allocated += 1024;\n-\t  tmp = xrealloc (tmp, allocated);\n-\t}\n-    }\n- done:\n-  tmp [*len = i] = '\\0';\n-  return tmp;\n-\n-unterminated:\n-  if (c == '\\n')\n-    unput ('\\n');\n-  *len = 1;\n-  if (pass == 1)\n-    error (\"unterminated string literal\");  \n-  to_global_binding_level ();\n-  tmp[0] = '\\0';\n-  return tmp;\n-}\n-\f\n-/* Convert an integer INTCHARS into an INTEGER_CST.\n-   INTCHARS is on the temporary_obstack, and is popped by this function. */\n-\n-static tree\n-convert_integer (intchars)\n-     char *intchars;\n-{\n-#ifdef YYDEBUG\n-  extern int yydebug;\n-#endif\n-  char *p = intchars;\n-  char         *oldp = p;\n-  int\t\tbase = 10, tmp;\n-  int           valid_chars = 0;\n-  int\t\toverflow = 0;\n-  tree\t\ttype;\n-  HOST_WIDE_INT val_lo = 0, val_hi = 0;\n-  tree\t\tval;\n-  \n-  /* determine the base */\n-  switch (*p)\n-    {\n-    case 'd':\n-    case 'D':\n-      p += 2;\n-      break;\n-    case 'o':\n-    case 'O':\n-      p += 2;\n-      base = 8;\n-      break;\n-    case 'h':\n-    case 'H':\n-      p += 2;\n-      base = 16;\n-      break;\n-    case 'b':\n-    case 'B':\n-      p += 2;\n-      base = 2;\n-      break;\n-    default:\n-      if (!ISDIGIT (*p))   /* this test is for equal_number () */\n-\t{\n-\t  obstack_free (&temporary_obstack, intchars);\n-\t  return 0;\n-\t}\n-      break;\n-    }\n-  \n-  while (*p)\n-    {\n-      tmp = *p++;\n-      if ((tmp == '\\'') || (tmp == '_'))\n-\tcontinue;\n-      if (tmp < '0')\n-\tgoto bad_char;\n-      if (tmp >= 'a')      /* uppercase the char */\n-\ttmp -= ' ';\n-      switch (base)        /* validate the characters */\n-\t{\n-\tcase 2:\n-\t  if (tmp > '1')\n-\t    goto bad_char;\n-\t  break;\n-\tcase 8:\n-\t  if (tmp > '7')\n-\t    goto bad_char;\n-\t  break;\n-\tcase 10:\n-\t  if (tmp > '9')\n-\t    goto bad_char;\n-\t  break;\n-\tcase 16:\n-\t  if (tmp > 'F')\n-\t    goto bad_char;\n-\t  if (tmp > '9' && tmp < 'A')\n-\t    goto bad_char;\n-\t  break;\n-\tdefault:\n-\t  abort ();\n-\t}\n-      tmp -= '0';\n-      if (tmp > 9)\n-\ttmp -= 7;\n-      if (mul_double (val_lo, val_hi, base, 0, &val_lo, &val_hi))\n-\toverflow++;\n-      add_double (val_lo, val_hi, tmp, 0, &val_lo, &val_hi);\n-      if (val_hi < 0)\n-\toverflow++;\n-      valid_chars++;\n-    }\n- bad_char:\n-  obstack_free (&temporary_obstack, intchars);\n-  if (!valid_chars)\n-    {\n-      if (pass == 2)\n-\terror (\"invalid number format `%s'\", oldp);\n-      return 0;\n-    }\n-  val = build_int_2 (val_lo, val_hi);\n-  /* We set the type to long long (or long long unsigned) so that\n-     constant fold of literals is less likely to overflow.  */\n-  if (int_fits_type_p (val, long_long_integer_type_node))\n-    type = long_long_integer_type_node;\n-  else\n-    {\n-      if (! int_fits_type_p (val, long_long_unsigned_type_node))\n-\toverflow++;\n-      type = long_long_unsigned_type_node;\n-    }\n-  TREE_TYPE (val) = type;\n-  CH_DERIVED_FLAG (val) = 1;\n-  \n-  if (overflow)\n-    error (\"integer literal too big\");\n-\n-  return val;\n-}\n-\f\n-/* Convert a bitstring literal on the temporary_obstack to\n-   a bitstring CONSTRUCTOR.  Free the literal from the obstack. */\n-\n-static tree\n-convert_bitstring (p)\n-     char *p;\n-{\n-#ifdef YYDEBUG\n-  extern int yydebug;\n-#endif\n-  int bl = 0, valid_chars = 0, bits_per_char = 0, c, k;\n-  tree initlist = NULL_TREE;\n-  tree val;\n-  \n-  /* Move p to stack so we can re-use temporary_obstack for result. */\n-  char *oldp = (char*) alloca (strlen (p) + 1);\n-  strcpy (oldp, p);\n-  obstack_free (&temporary_obstack, p);\n-  p = oldp;\n-  \n-  switch (*p)\n-    {\n-    case 'h':\n-    case 'H':\n-      bits_per_char = 4;\n-      break;\n-    case 'o':\n-    case 'O':\n-      bits_per_char = 3;\n-      break;\n-    case 'b':\n-    case 'B':\n-      bits_per_char = 1;\n-      break;\n-    }\n-  p += 2;\n-\n-  while (*p)\n-    {\n-      c = *p++;\n-      if (c == '_' || c == '\\'')\n-\tcontinue;\n-      if (c >= 'a')\n-\tc -= ' ';\n-      c -= '0';\n-      if (c > 9)\n-\tc -= 7;\n-      valid_chars++;\n-      \n-      for (k = BYTES_BIG_ENDIAN ? bits_per_char - 1 : 0;\n-\t   BYTES_BIG_ENDIAN ? k >= 0 : k < bits_per_char;\n-\t   bl++, BYTES_BIG_ENDIAN ? k-- : k++)\n-\t{\n-\t  if (c & (1 << k))\n-\t    initlist = tree_cons (NULL_TREE, build_int_2 (bl, 0), initlist);\n-        }\n-    }\n-#if 0\n-  /* as long as BOOLS(0) is valid it must tbe possible to\n-     specify an empty bitstring */\n-  if (!valid_chars)\n-    {\n-      if (pass == 2)\n-\terror (\"invalid number format `%s'\", oldp);\n-      return 0;\n-    }\n-#endif\n-  val = build (CONSTRUCTOR,\n-\t       build_bitstring_type (size_int (bl)),\n-\t       NULL_TREE, nreverse (initlist));\n-  TREE_CONSTANT (val) = 1;\n-  CH_DERIVED_FLAG (val) = 1;\n-  return val;\n-}\n-\f\n-/* Check if two filenames name the same file.\n-   This is done by stat'ing both files and comparing their inodes.\n-\n-   Note: we have to take care of seize_path_list. Therefore do it the same\n-   way as in yywrap. FIXME: This probably can be done better. */\n-\n-static int\n-same_file (filename1, filename2)\n-     const char *filename1;\n-     const char *filename2;\n-{\n-  struct stat s[2];\n-  const char *fn_input[2];\n-  int         i, stat_status;\n-  \n-  if (grant_only_flag)\n-    /* do nothing in this case */\n-    return 0;\n-\n-  /* if filenames are equal -- return 1, cause there is no need\n-     to search in the include list in this case */\n-  if (strcmp (filename1, filename2) == 0)\n-    return 1;\n-  \n-  fn_input[0] = filename1;\n-  fn_input[1] = filename2;\n-\n-  for (i = 0; i < 2; i++)\n-    {\n-      stat_status = stat (fn_input[i], &s[i]);\n-      if (stat_status < 0\n-\t  && strchr (fn_input[i], '/') == 0)\n-        {\n-\t  STRING_LIST *plp;\n-\t  char *path;\n-\t  \n-\t  for (plp = seize_path_list; plp != 0; plp = plp->next)\n-\t    {\n-\t      path = (char *) xmalloc (strlen (fn_input[i])\n-\t\t\t\t       + strlen (plp->str) + 2);\n-\t      sprintf (path, \"%s/%s\", plp->str, fn_input[i]);\n-\t      stat_status = stat (path, &s[i]);\n-\t      free (path);\n-\t      if (stat_status >= 0)\n-\t        break;\n-  \t    }\n-        }\n-\n-      if (stat_status < 0)\n-\tfatal_io_error (\"can't find %s\", fn_input[i]);\n-  }\n-  return s[0].st_ino == s[1].st_ino && s[0].st_dev == s[1].st_dev;\n-}\n-\n-/*\n- * Note that simply appending included file names to a list in this\n- * way completely eliminates the need for nested files, and the\n- * associated book-keeping, since the EOF processing in the lexer\n- * will simply process the files one at a time, in the order that the\n- * USE_SEIZE_FILE directives were scanned.\n- */\n-static void\n-handle_use_seizefile_directive (restricted)\n-    int restricted;\n-{\n-  tree seen;\n-  int   len;\n-  int   c = skip_whitespace ();\n-  char *use_seizefile_str = readstring (c, &len);\n-\n-  if (pass > 1)\n-    return;\n-\n-  if (c != '\\'' && c != '\\\"')\n-    {\n-      error (\"USE_SEIZE_FILE directive must be followed by string\");\n-      return;\n-    }\n-\n-  use_seizefile_name = get_identifier (use_seizefile_str);\n-  CH_USE_SEIZEFILE_RESTRICTED (use_seizefile_name) = restricted;\n-  \n-  if (!grant_only_flag)\n-    {\n-      /* If file foo.ch contains a <> use_seize_file \"bar.grt\" <>,\n-\t and file bar.ch contains a <> use_seize_file \"foo.grt\" <>,\n-\t then if we're compiling foo.ch, we will indirectly be\n-\t asked to seize foo.grt.  Don't. */\n-      extern char *grant_file_name;\n-      if (strcmp (use_seizefile_str, grant_file_name) == 0)\n-\treturn;\n-\n-      /* Check if the file is already on the list. */\n-      for (seen = files_to_seize; seen != NULL_TREE; seen = TREE_CHAIN (seen))\n-\tif (same_file (IDENTIFIER_POINTER (TREE_VALUE (seen)),\n-\t\t       use_seizefile_str))\n-\t  return;  /* Previously seen; nothing to do. */\n-    }\n-\n-  /* Haven't been asked to seize this file yet, so add\n-     its name to the list. */\n-  {\n-    tree pl = perm_tree_cons (0, use_seizefile_name, NULL_TREE);\n-    if (files_to_seize == NULL_TREE)\n-      files_to_seize = pl;\n-    else\n-      TREE_CHAIN (last_file_to_seize) = pl;\n-    if (next_file_to_seize == NULL_TREE)\n-      next_file_to_seize = pl;\n-    last_file_to_seize = pl;\n-  }\n-}\n-\n-\n-/*\n- * get input, convert to lower case for comparison\n- */\n-static int\n-getlc (file)\n-     FILE *file;\n-{\n-  register int c;\n-\n-  c = getc (file);  \n-  if (ignore_case)\n-    c = TOLOWER (c);\n-  return c;\n-}\n-\f\n-#if defined HANDLE_PRAGMA\n-/* Local versions of these macros, that can be passed as function pointers.  */\n-static int\n-pragma_getc ()\n-{\n-  return getc (finput);\n-}\n-\n-static void\n-pragma_ungetc (arg)\n-     int arg;\n-{\n-  ungetc (arg, finput);\n-}\n-#endif /* HANDLE_PRAGMA */\n-\n-#ifdef HANDLE_GENERIC_PRAGMAS\n-/* Handle a generic #pragma directive.\n-   BUFFER contains the text we read after `#pragma'.  Processes the entire input\n-   line and return non-zero iff the pragma was successfully processed.  */\n-\n-static int\n-handle_generic_pragma (buffer)\n-     char * buffer;\n-{\n-  register int c;\n-\n-  for (;;)\n-    {\n-      char * buff;\n-      \n-      handle_pragma_token (buffer, NULL);\n-\n-      c = getc (finput);\n-\n-      while (c == ' ' || c == '\\t')\n-\tc = getc (finput);\n-      ungetc (c, finput);\n-      \n-      if (c == '\\n' || c == EOF)\n-\treturn handle_pragma_token (NULL, NULL);\n-\n-      /* Read the next word of the pragma into the buffer.  */\n-      buff = buffer;\n-      do\n-\t{\n-\t  * buff ++ = c;\n-\t  c = getc (finput);\n-\t}\n-      while (c != EOF && ! ISSPACE (c) && buff < buffer + 128);\n-        /* XXX shared knowledge about size of buffer.  */\n-\n-      ungetc (c, finput);\n-      \n-      * -- buff = 0;\n-    }\n-}\n-#endif /* HANDLE_GENERIC_PRAGMAS */\n-\f\n-/* At the beginning of a line, increment the line number and process\n-   any #-directive on this line.  If the line is a #-directive, read\n-   the entire line and return a newline.  Otherwise, return the line's\n-   first non-whitespace character.\n-\n-   (Each language front end has a check_newline() function that is called\n-   from lang_init() for that language.  One of the things this function\n-   must do is read the first line of the input file, and if it is a #line\n-   directive, extract the filename from it and use it to initialize\n-   main_input_filename.  Proper generation of debugging information in\n-   the normal \"front end calls cpp then calls cc1XXXX environment\" depends\n-   upon this being done.) */\n-\n-int\n-check_newline ()\n-{\n-  register int c;\n-\n-  lineno++;\n-\n-  /* Read first nonwhite char on the line.  */\n-\n-  c = getc (finput);\n-\n-  while (c == ' ' || c == '\\t')\n-    c = getc (finput);\n-\n-  if (c != '#' || inside_c_comment)\n-    {\n-      /* If not #, return it so caller will use it.  */\n-      return c;\n-    }\n-\n-  /* Read first nonwhite char after the `#'.  */\n-\n-  c = getc (finput);\n-  while (c == ' ' || c == '\\t')\n-    c = getc (finput);\n-\n-  /* If a letter follows, then if the word here is `line', skip\n-     it and ignore it; otherwise, ignore the line, with an error\n-     if the word isn't `pragma', `ident', `define', or `undef'.  */\n-\n-  if (ignore_case)\n-    c = TOLOWER (c);\n-\n-  if (c >= 'a' && c <= 'z')\n-    {\n-      if (c == 'p')\n-\t{\n-\t  if (getlc (finput) == 'r'\n-\t      && getlc (finput) == 'a'\n-\t      && getlc (finput) == 'g'\n-\t      && getlc (finput) == 'm'\n-\t      && getlc (finput) == 'a'\n-\t      && (c = getlc (finput), ISSPACE (c)))\n-\t    {\n-#ifdef HANDLE_PRAGMA\n-\t      static char buffer [128];\n-\t      char * buff = buffer;\n-\n-\t      /* Read the pragma name into a buffer.  */\n-\t      while (c = getlc (finput), ISSPACE (c))\n-\t\tcontinue;\n-\t      \n-\t      do\n-\t\t{\n-\t\t  * buff ++ = c;\n-\t\t  c = getlc (finput);\n-\t\t}\n-\t      while (c != EOF && ! ISSPACE (c) && c != '\\n'\n-\t\t     && buff < buffer + 128);\n-\n-\t      pragma_ungetc (c);\n-\t\t\n-\t      * -- buff = 0;\n-\t      \n-\t      if (HANDLE_PRAGMA (pragma_getc, pragma_ungetc, buffer))\n-\t\tgoto skipline;\n-#endif /* HANDLE_PRAGMA */\n-\t      \n-#ifdef HANDLE_GENERIC_PRAGMAS\n-\t      if (handle_generic_pragma (buffer))\n-\t\tgoto skipline;\n-#endif /* HANDLE_GENERIC_PRAGMAS */\n-\t      \n-\t      goto skipline;\n-\t    }\n-\t}\n-\n-      else if (c == 'd')\n-\t{\n-\t  if (getlc (finput) == 'e'\n-\t      && getlc (finput) == 'f'\n-\t      && getlc (finput) == 'i'\n-\t      && getlc (finput) == 'n'\n-\t      && getlc (finput) == 'e'\n-\t      && (c = getlc (finput), ISSPACE (c)))\n-\t    {\n-#if 0 /*def DWARF_DEBUGGING_INFO*/\n-\t      if (c != '\\n'\n-\t\t  && (debug_info_level == DINFO_LEVEL_VERBOSE)\n-\t\t  && (write_symbols == DWARF_DEBUG))\n-\t        dwarfout_define (lineno, get_directive_line (finput));\n-#endif /* DWARF_DEBUGGING_INFO */\n-\t      goto skipline;\n-\t    }\n-\t}\n-      else if (c == 'u')\n-\t{\n-\t  if (getlc (finput) == 'n'\n-\t      && getlc (finput) == 'd'\n-\t      && getlc (finput) == 'e'\n-\t      && getlc (finput) == 'f'\n-\t      && (c = getlc (finput), ISSPACE (c)))\n-\t    {\n-#if 0 /*def DWARF_DEBUGGING_INFO*/\n-\t      if (c != '\\n'\n-\t\t  && (debug_info_level == DINFO_LEVEL_VERBOSE)\n-\t\t  && (write_symbols == DWARF_DEBUG))\n-\t        dwarfout_undef (lineno, get_directive_line (finput));\n-#endif /* DWARF_DEBUGGING_INFO */\n-\t      goto skipline;\n-\t    }\n-\t}\n-      else if (c == 'l')\n-\t{\n-\t  if (getlc (finput) == 'i'\n-\t      && getlc (finput) == 'n'\n-\t      && getlc (finput) == 'e'\n-\t      && ((c = getlc (finput)) == ' ' || c == '\\t'))\n-\t    goto linenum;\n-\t}\n-#if 0\n-      else if (c == 'i')\n-\t{\n-\t  if (getlc (finput) == 'd'\n-\t      && getlc (finput) == 'e'\n-\t      && getlc (finput) == 'n'\n-\t      && getlc (finput) == 't'\n-\t      && ((c = getlc (finput)) == ' ' || c == '\\t'))\n-\t    {\n-\t      /* #ident.  The pedantic warning is now in cpp.  */\n-\n-\t      /* Here we have just seen `#ident '.\n-\t\t A string constant should follow.  */\n-\n-\t      while (c == ' ' || c == '\\t')\n-\t\tc = getlc (finput);\n-\n-\t      /* If no argument, ignore the line.  */\n-\t      if (c == '\\n')\n-\t\treturn c;\n-\n-\t      ungetc (c, finput);\n-\t      token = yylex ();\n-\t      if (token != STRING\n-\t\t  || TREE_CODE (yylval.ttype) != STRING_CST)\n-\t\t{\n-\t\t  error (\"invalid #ident\");\n-\t\t  goto skipline;\n-\t\t}\n-\n-\t      if (!flag_no_ident)\n-\t\t{\n-#ifdef ASM_OUTPUT_IDENT\n-\t\t  extern FILE *asm_out_file;\n-\t\t  ASM_OUTPUT_IDENT (asm_out_file, TREE_STRING_POINTER (yylval.ttype));\n-#endif\n-\t\t}\n-\n-\t      /* Skip the rest of this line.  */\n-\t      goto skipline;\n-\t    }\n-\t}\n-#endif\n-\n-      error (\"undefined or invalid # directive\");\n-      goto skipline;\n-    }\n-\n-linenum:\n-  /* Here we have either `#line' or `# <nonletter>'.\n-     In either case, it should be a line number; a digit should follow.  */\n-\n-  while (c == ' ' || c == '\\t')\n-    c = getlc (finput);\n-\n-  /* If the # is the only nonwhite char on the line,\n-     just ignore it.  Check the new newline.  */\n-  if (c == '\\n')\n-    return c;\n-\n-  /* Something follows the #; read a token.  */\n-\n-  if (ISDIGIT(c))\n-    {\n-      int old_lineno = lineno;\n-      int used_up = 0;\n-      int l = 0;\n-      extern struct obstack permanent_obstack;\n-\n-      do\n-\t{\n-\t  l = l * 10 + (c - '0'); /* FIXME Not portable */\n-\t  c = getlc(finput);\n-\t} while (ISDIGIT(c));\n-      /* subtract one, because it is the following line that\n-\t gets the specified number */\n-\n-      l--;\n-\n-      /* Is this the last nonwhite stuff on the line?  */\n-      c = getlc (finput);\n-      while (c == ' ' || c == '\\t')\n-\tc = getlc (finput);\n-      if (c == '\\n')\n-\t{\n-\t  /* No more: store the line number and check following line.  */\n-\t  lineno = l;\n-\t  return c;\n-\t}\n-\n-      /* More follows: it must be a string constant (filename).  */\n-\n-      /* Read the string constant, but don't treat \\ as special.  */\n-      ignore_escape_flag = 1;\n-      ignore_escape_flag = 0;\n-\n-      if (c != '\\\"')\n-\t{\n-\t  error (\"invalid #line\");\n-\t  goto skipline;\n-\t}\n-\n-      for (;;)\n-\t{\n-\t  c = getc (finput);\n-\t  if (c == EOF || c == '\\n')\n-\t    {\n-\t      error (\"invalid #line\");\n-\t      return c;\n-\t    }\n-\t  if (c == '\\\"')\n-\t    {\n-\t      obstack_1grow(&permanent_obstack, 0);\n-\t      input_filename = obstack_finish (&permanent_obstack);\n-\t      break;\n-\t    }\n-\t  obstack_1grow(&permanent_obstack, c);\n-\t}\n-\n-      lineno = l;\n-\n-      /* Each change of file name\n-\t reinitializes whether we are now in a system header.  */\n-      in_system_header = 0;\n-\n-      if (main_input_filename == 0)\n-\tmain_input_filename = input_filename;\n-\n-      /* Is this the last nonwhite stuff on the line?  */\n-      c = getlc (finput);\n-      while (c == ' ' || c == '\\t')\n-\tc = getlc (finput);\n-      if (c == '\\n')\n-\treturn c;\n-\n-      used_up = 0;\n-\n-      /* `1' after file name means entering new file.\n-\t `2' after file name means just left a file.  */\n-\n-      if (ISDIGIT (c))\n-\t{\n-\t  if (c == '1')\n-\t    {\n-\t      /* Pushing to a new file.  */\n-\t      struct file_stack *p\n-\t\t= (struct file_stack *) xmalloc (sizeof (struct file_stack));\n-\t      input_file_stack->line = old_lineno;\n-\t      p->next = input_file_stack;\n-\t      p->name = input_filename;\n-\t      input_file_stack = p;\n-\t      input_file_stack_tick++;\n-#ifdef DWARF_DEBUGGING_INFO\n-\t      if (debug_info_level == DINFO_LEVEL_VERBOSE\n-\t\t  && write_symbols == DWARF_DEBUG)\n-\t\tdwarfout_start_new_source_file (input_filename);\n-#endif /* DWARF_DEBUGGING_INFO */\n-\n-\t      used_up = 1;\n-\t    }\n-\t  else if (c == '2')\n-\t    {\n-\t      /* Popping out of a file.  */\n-\t      if (input_file_stack->next)\n-\t\t{\n-\t\t  struct file_stack *p = input_file_stack;\n-\t\t  input_file_stack = p->next;\n-\t\t  free (p);\n-\t\t  input_file_stack_tick++;\n-#ifdef DWARF_DEBUGGING_INFO\n-\t\t  if (debug_info_level == DINFO_LEVEL_VERBOSE\n-\t\t      && write_symbols == DWARF_DEBUG)\n-\t\t    dwarfout_resume_previous_source_file (input_file_stack->line);\n-#endif /* DWARF_DEBUGGING_INFO */\n-\t\t}\n-\t      else\n-\t\terror (\"#-lines for entering and leaving files don't match\");\n-\n-\t      used_up = 1;\n-\t    }\n-\t}\n-\n-      /* If we have handled a `1' or a `2',\n-\t see if there is another number to read.  */\n-      if (used_up)\n-\t{\n-\t  /* Is this the last nonwhite stuff on the line?  */\n-\t  c = getlc (finput);\n-\t  while (c == ' ' || c == '\\t')\n-\t    c = getlc (finput);\n-\t  if (c == '\\n')\n-\t    return c;\n-\t  used_up = 0;\n-\t}\n-\n-      /* `3' after file name means this is a system header file.  */\n-\n-      if (c == '3')\n-\tin_system_header = 1;\n-    }\n-  else\n-    error (\"invalid #-line\");\n-\n-  /* skip the rest of this line.  */\n- skipline:\n-  while (c != '\\n' && c != EOF)\n-    c = getc (finput);\n-  return c;\n-}\n-\n-\n-tree\n-get_chill_filename ()\n-{\n-  return (build_chill_string (\n-            strlen (input_filename) + 1,  /* +1 to get a zero terminated string */\n-\t      input_filename));\n-}\n-\n-tree\n-get_chill_linenumber ()\n-{\n-  return build_int_2 ((HOST_WIDE_INT)lineno, 0);\n-}\n-\n-\n-/* Assuming '/' and '*' have been read, skip until we've\n-   read the terminating '*' and '/'. */\n-\n-static void\n-skip_c_comment ()\n-{\n-  int c = input();\n-  int start_line = lineno;\n-\n-  inside_c_comment++;\n-  for (;;)\n-    if (c == EOF)\n-      {\n-\terror_with_file_and_line (input_filename, start_line,\n-\t\t\t\t  \"unterminated comment\");\n-\tbreak;\n-      }\n-    else if (c != '*')\n-      c = input();\n-    else if ((c = input ()) == '/')\n-      break;\n-  inside_c_comment--;\n-}\n-\n-\n-/* Assuming \"--\" has been read, skip until '\\n'. */\n-\n-static void\n-skip_line_comment ()\n-{\n-  for (;;)\n-    {\n-      int c = input ();\n-\n-      if (c == EOF)\n-\treturn;\n-      if (c == '\\n')\n-\tbreak;\n-    }\n-  unput ('\\n');\n-}\n-\n-\n-static int\n-skip_whitespace ()\n-{\n-  for (;;)\n-    {\n-      int c = input ();\n-\n-      if (c == EOF)\n-\treturn c;\n-      if (c == ' ' || c == '\\t' || c == '\\r' || c == '\\n' || c == '\\v')\n-\tcontinue;\n-      if (c == '/')\n-\t{\n-\t  c = input ();\n-\t  if (c == '*')\n-\t    {\n-\t      skip_c_comment ();\n-\t      continue;\n-\t    }\n-\t  else\n-\t    {\n-\t      unput (c);\n-\t      return '/';\n-\t    }\n-\t}\n-      if (c == '-')\n-\t{\n-\t  c = input ();\n-\t  if (c == '-')\n-\t    {\n-\t      skip_line_comment ();\n-\t      continue;\n-\t    }\n-\t  else\n-\t    {\n-\t      unput (c);\n-\t      return '-';\n-\t    }\n-\t}\n-      return c;\n-    }\n-}\n-\f\n-/*\n- * avoid recursive calls to yylex to parse the ' = digits' or\n- * ' = SYNvalue' which are supposed to follow certain compiler\n- * directives.  Read the input stream, and return the value parsed.\n- */\n-         /* FIXME: overflow check in here */\n-         /* FIXME: check for EOF around here */\n-static tree\n-equal_number ()\n-{\n-  int      c, result;\n-  char    *tokenbuf;\n-  char    *cursor;\n-  tree     retval = integer_zero_node;\n-  \n-  c = skip_whitespace();\n-  if ((char)c != '=')\n-    {\n-      if (pass == 2)\n-\terror (\"missing `=' in compiler directive\");\n-      return integer_zero_node;\n-    }\n-  c = skip_whitespace();\n-\n-  /* collect token into tokenbuf for later analysis */\n-  while (TRUE)\n-    {\n-      if (ISSPACE (c) || c == '<')\n-\tbreak;\n-      obstack_1grow (&temporary_obstack, c);\n-      c = input ();\n-    }\n-  unput (c);             /* put uninteresting char back */\n-  obstack_1grow (&temporary_obstack, '\\0');        /* terminate token */\n-  tokenbuf = obstack_finish (&temporary_obstack);\n-  maybe_downcase (tokenbuf);\n-\n-  if (*tokenbuf == '-')\n-    /* will fail in the next test */\n-    result = BITSTRING;\n-  else if (maybe_number (tokenbuf))\n-    {\n-      if (pass == 1)\n-\treturn integer_zero_node;\n-      push_obstacks_nochange ();\n-      end_temporary_allocation ();\n-      yylval.ttype = convert_integer (tokenbuf);\n-      tokenbuf = 0;  /* Was freed by convert_integer. */\n-      result = yylval.ttype ? NUMBER : 0;\n-      pop_obstacks ();\n-    }\n-  else\n-    result = 0;\n-  \n-  if (result  == NUMBER)\n-    {\n-      retval = yylval.ttype;\n-    }\n-  else if (result == BITSTRING)\n-    {\n-      if (pass == 1)\n-        error (\"invalid value follows `=' in compiler directive\");\n-      goto finish;\n-    }\n-  else /* not a number */\n-    {\n-      cursor = tokenbuf;\n-      c = *cursor;\n-      if (!ISALPHA (c) && c != '_')\n-\t{\n-\t  if (pass == 1)\n-\t    error (\"invalid value follows `=' in compiler directive\");\n-\t  goto finish;\n-\t}\n-\n-      for (cursor = &tokenbuf[1]; *cursor != '\\0'; cursor++)\n-\tif (ISALPHA ((unsigned char) *cursor) || *cursor == '_' ||\n-\t    ISDIGIT (*cursor))\n-\t  continue;\n-\telse\n-\t  {\n-\t    if (pass == 1)\n-\t      error (\"invalid `%c' character in name\", *cursor);\n-\t    goto finish;\n-\t  }\n-      if (pass == 1)\n-\tgoto finish;\n-      else\n-\t{\n-\t  tree value = lookup_name (get_identifier (tokenbuf));\n-\t  if (value == NULL_TREE\n-\t      || TREE_CODE (value) != CONST_DECL\n-\t      || TREE_CODE (DECL_INITIAL (value)) != INTEGER_CST)\n-\t    {\n-\t      if (pass == 2)\n-\t\terror (\"`%s' not integer constant synonym \",\n-\t\t       tokenbuf);\n-\t      goto finish;\n-\t    }\n-\t  obstack_free (&temporary_obstack, tokenbuf);\n-\t  tokenbuf = 0;\n-\t  push_obstacks_nochange ();\n-\t  end_temporary_allocation ();\n-\t  retval = convert (chill_taskingcode_type_node, DECL_INITIAL (value));\n-\t  pop_obstacks ();\n-\t}\n-    }\n-\n-  /* check the value */\n-  if (TREE_CODE (retval) != INTEGER_CST)\n-    {\n-      if (pass == 2)\n-\terror (\"invalid value follows `=' in compiler directive\");\n-    }\n-  else if (TREE_INT_CST_HIGH (retval) != 0 ||\n-\t   TREE_INT_CST_LOW (retval) > TREE_INT_CST_LOW (TYPE_MAX_VALUE (chill_unsigned_type_node)))\n-    {\n-      if (pass == 2)\n-\terror (\"value out of range in compiler directive\");\n-    }\n- finish:\n-  if (tokenbuf)\n-    obstack_free (&temporary_obstack, tokenbuf);\n-  return retval;\n-}\n-\f\n-/*\n- * add a possible grant-file path to the list\n- */\n-void\n-register_seize_path (path)\n-     const char *path;\n-{\n-  int          pathlen = strlen (path);\n-  char        *new_path = (char *)xmalloc (pathlen + 1);\n-  STRING_LIST *pl     = (STRING_LIST *)xmalloc (sizeof (STRING_LIST));\n-    \n-  /* strip off trailing slash if any */\n-  if (path[pathlen - 1] == '/')\n-    pathlen--;\n-\n-  memcpy (new_path, path, pathlen);\n-  pl->str  = new_path;\n-  pl->next = seize_path_list;\n-  seize_path_list = pl;\n-}\n-\n-\n-/* Used by decode_decl to indicate that a <> use_seize_file NAME <>\n-   directive has been written to the grantfile. */\n-\n-void\n-mark_use_seizefile_written (name)\n-     tree name;\n-{\n-  tree node;\n-\n-  for (node = files_to_seize;  node != NULL_TREE; node = TREE_CHAIN (node))\n-    if (TREE_VALUE (node) == name)\n-      {\n-\tTREE_PURPOSE (node) = integer_one_node;\n-\tbreak;\n-      }\n-}\n-\n-\n-static int\n-yywrap ()\n-{\n-  extern char *chill_real_input_filename;\n-\n-  close_input_file (input_filename);\n-\n-  use_seizefile_name = NULL_TREE;\n-\n-  if (next_file_to_seize && !grant_only_flag)\n-    {\n-      FILE *grt_in = NULL;\n-      const char *seizefile_name_chars\n-\t= IDENTIFIER_POINTER (TREE_VALUE (next_file_to_seize));\n-\n-      /* find a seize file, open it.  If it's not at the path the\n-       * user gave us, and that path contains no slashes, look on\n-       * the seize_file paths, specified by the '-I' options.\n-       */     \n-      grt_in = fopen (seizefile_name_chars, \"r\");\n-      if (grt_in == NULL \n-\t  && strchr (seizefile_name_chars, '/') == NULL)\n-\t{\n-\t  STRING_LIST *plp;\n-\t  char      *path;\n-\n-\t  for (plp = seize_path_list; plp != NULL; plp = plp->next)\n-\t    {\n-\t      path = (char *)xmalloc (strlen (seizefile_name_chars)\n-\t\t\t\t      + strlen (plp->str) + 2);\n-\n-\t      sprintf (path, \"%s/%s\", plp->str, seizefile_name_chars);\n-\t      grt_in = fopen (path, \"r\");\n-\t      if (grt_in == NULL)\n-\t\tfree (path);\n-\t      else\n-\t\t{\n-\t\t  seizefile_name_chars = path;\n-\t\t  break;\n-\t\t}\n-\t    }\n-\t}\n-\n-      if (grt_in == NULL)\n-\tfatal_io_error (\"can't open %s\", seizefile_name_chars);\n-\n-      finput = grt_in;\n-      input_filename = seizefile_name_chars;\n-\n-      lineno = 0;\n-      current_seizefile_name = TREE_VALUE (next_file_to_seize);\n-\n-      next_file_to_seize = TREE_CHAIN (next_file_to_seize);\n-\n-      saw_eof = 0;\n-      return 0;\n-    }\n-\n-  if (pass == 1)\n-    {\n-      next_file_to_seize = files_to_seize;\n-      current_seizefile_name = NULL_TREE;\n-\n-      if (strcmp (main_input_filename, \"stdin\"))\n-\tfinput = fopen (chill_real_input_filename, \"r\");\n-      else\n-\tfinput = stdin;\n-      if (finput == NULL)\n-\t{\n-\t  error (\"can't reopen %s\", chill_real_input_filename);\n-\t  return 1;\n-\t}\n-      input_filename = main_input_filename;\n-      ch_lex_init ();\n-      lineno = 0;\n-      /* Read a line directive if there is one.  */\n-      ungetc (check_newline (), finput);\n-      starting_pass_2 = 1;\n-      saw_eof = 0;\n-      if (module_number == 0)\n-\twarning (\"no modules seen\");\n-      return 0;\n-    }\n-  return 1;\n-}"}, {"sha": "4bf748c7da6f69bdf07f6951aa17b2c55e5ce7d9", "filename": "gcc/ch/lex.h", "status": "removed", "additions": 0, "deletions": 98, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41823c5eb7d4504b6a4a396ca0d64573238fbbcf/gcc%2Fch%2Flex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41823c5eb7d4504b6a4a396ca0d64573238fbbcf/gcc%2Fch%2Flex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Flex.h?ref=41823c5eb7d4504b6a4a396ca0d64573238fbbcf", "patch": "@@ -1,98 +0,0 @@\n-/* Define constants for communication with the CHILL parser.\n-   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1999, 2000\n-   Free Software Foundation, Inc.\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-\n-\n-enum rid\n-{\n-  RID_UNUSED,  /* keep this one first, please */\n-  RID_ALL,\n-  RID_ASSERTFAIL,\n-  RID_ASSOCIATION,\n-  RID_BIN,\n-  RID_BIT,\n-  RID_BOOL,\n-  RID_BOOLS,\n-  RID_BYTE,\n-  RID_CHAR,\n-  RID_CHARS,\n-  RID_DOUBLE,\n-  RID_DURATION,\n-  RID_DYNAMIC,\n-  RID_ELSE,\n-  RID_EMPTY,\n-  RID_FALSE,\n-  RID_FLOAT,\n-  RID_GENERAL,\n-  RID_IN,\n-  RID_INLINE,\n-  RID_INOUT,\n-  RID_INSTANCE,\n-  RID_INT,\n-  RID_LOC,\n-  RID_LONG,\n-  RID_LONG_REAL,\n-  RID_NULL,\n-  RID_OUT,\n-  RID_OVERFLOW,\n-  RID_PTR,\n-  RID_RANGE,\n-  RID_RANGEFAIL,\n-  RID_READ,\n-  RID_REAL,\n-  RID_RECURSIVE,\n-  RID_SHORT,\n-  RID_SIMPLE,\n-  RID_TIME,\n-  RID_TRUE,\n-  RID_UBYTE,\n-  RID_UINT,\n-  RID_ULONG,\n-  RID_UNSIGNED,\n-  RID_USHORT,\n-  RID_VOID,\n-  RID_MAX /* Last element */\n-};\n-\n-#define NORID RID_UNUSED\n-\n-#define RID_FIRST_MODIFIER RID_UNSIGNED\n-\n-/* The elements of `ridpointers' are identifier nodes\n-   for the reserved type names and storage classes.\n-   It is indexed by a RID_... value.  */\n-extern tree ridpointers[(int) RID_MAX];\n-\n-extern char *token_buffer;\t/* Pointer to token buffer.  */\n-\n-extern tree make_pointer_declarator PARAMS ((tree, tree));\n-extern void reinit_parse_for_function PARAMS ((void));\n-extern int yylex PARAMS ((void));\n-\n-extern tree default_grant_file;\n-extern tree current_grant_file;\n-\n-extern tree current_seize_file;\n-\n-extern int chill_at_module_level;\n-extern tree chill_initializer_name;\n-\n-extern void prepare_paren_colon PARAMS ((void));"}, {"sha": "393349b18fcbaad90b4093b1c09c018b8ceb3be2", "filename": "gcc/ch/loop.c", "status": "removed", "additions": 0, "deletions": 1234, "changes": 1234, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41823c5eb7d4504b6a4a396ca0d64573238fbbcf/gcc%2Fch%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41823c5eb7d4504b6a4a396ca0d64573238fbbcf/gcc%2Fch%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Floop.c?ref=41823c5eb7d4504b6a4a396ca0d64573238fbbcf", "patch": "@@ -1,1234 +0,0 @@\n-/* Implement looping actions for CHILL.\n-   Copyright (C) 1992, 1993, 1994, 1998, 1999, 2000\n-   Free Software Foundation, Inc.\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"tree.h\"\n-#include \"ch-tree.h\"\n-#include \"lex.h\"\n-#include \"flags.h\"\n-#include \"actions.h\"\n-#include \"input.h\"\n-#include \"obstack.h\"\n-#include \"assert.h\"\n-#include \"rtl.h\"\n-#include \"toplev.h\"\n-\n-/* if the user codes '-flocal-loop-counter' on the command line,\n-   ch-actions.c (lang_decode_option) will set this flag. */\n-int flag_local_loop_counter = 1;\n-\n-/* forward declarations */\n-static int  declare_temps            PARAMS ((void));\n-static int  initialize_iter_var      PARAMS ((void));\n-static void maybe_skip_loop          PARAMS ((void));\n-static int  bottom_loop_end_check    PARAMS ((void));\n-static int  increment_temps          PARAMS ((void));\n-static tree build_temporary_variable PARAMS ((const char *, tree));\n-static tree maybe_make_for_temp      PARAMS ((tree, const char *, tree));\n-#if 0\n-static tree chill_unsigned_type      PARAMS ((tree));\n-#endif\n-\f\n-/* In terms of the parameters passed to build_loop_iterator,\n- *   there are several types of loops.  They are encoded by\n- *   the ITER_TYPE enumeration.\n- *\n- *   1) DO FOR EVER; ... OD\n- *      indicated by a NULL_TREE start_exp, step_exp and end_exp,\n- *      condition == NULL, in_flag = 0, and ever_flag == 1 in the\n- *      first ITERATOR.\n- *\n- *   2) DO WHILE cond; ... OD\n- *      indicated by NULL_TREE start_exp, step_exp and end_exp, \n- *      in_flag = 0, and condition != NULL.\n- *\n- *   3) DO; ... OD\n- *      indicated by NULL_TREEs in start_exp, step_exp and end_exp,\n- *      condition != NULL, in_flag == 0 and ever_flag == 0.  This\n- *      is not really a loop, but a compound statement.\n- *\n- *   4) DO FOR user_var := start_exp \n- *         [DOWN] TO end_exp BY step_exp; ... DO\n- *      indicated by non-NULL_TREE start_exp, step_exp and end_exp.\n- *\n- *   5) DO FOR user_var [DOWN] IN discrete_mode; ... OD\n- *      indicated by in_flag == 1.  start_exp is a non-NULL_TREE \n- *      discrete mode, with an optional down_flag.\n- *\n- *   6) DO FOR user_var [DOWN] IN powerset_expr; ... OD\n- *      indicated by in_flag == 1.  start_exp is a non-NULL_TREE \n- *      powerset mode, with an optional down_flag.\n- *\n- *   7) DO FOR user_var [DOWN] IN location; ... OD\n- *      indicated by in_flag == 1.  start_exp is a non-NULL_TREE \n- *      location mode, with an optional down_flag.\n- */\n-typedef enum \n-{\n-   DO_FOREVER,\n-   DO_OD,\n-   DO_STEP,\n-   DO_POWERSET,\n-   DO_LOC,\n-   DO_LOC_VARYING \n-} ITER_TYPE;\n-\n-\n-typedef struct iterator \n-{\n-/* These variables only have meaning in the first ITERATOR structure. */\n-  ITER_TYPE itype;                  /* type of this iterator */\n-  int  error_flag;                  /* TRUE if no loop was started due to \n-\t\t\t\t       user error */\n-  int  down_flag;                   /* TRUE if DOWN was coded */\n-\n-/* These variables have meaning in every ITERATOR structure. */\n-  tree user_var;                    /* user's explicit iteration variable */\n-  tree start_exp;                   /* user's start expression\n-                                       or IN expression of a FOR .. IN*/\n-  tree step_exp;                    /* user's step expression */\n-  tree end_exp;                     /* user's end expression */\n-  tree start_temp;                  /* temp holding evaluated start_exp */\n-  tree end_temp;                    /* temp holding evaluated end_exp */\n-  tree step_temp;                   /* temp holding evaluated step_exp */\n-  tree powerset_temp;               /* temp holding user's initial powerset expression */\n-  tree loc_ptr_temp;                /* temp holding count for LOC enumeration ptr */\n-  tree iter_var;                    /* hidden variable for the loop */\n-  tree iter_type;                   /* hidden variable's type */\n-  tree stepin_type;                 /* saved type for a DO FOR IN loop */\n-  tree base_type;                   /* LOC enumeration base type */\n-  struct iterator *next;            /* ptr to next iterator for this loop */\n-} ITERATOR;\n-\n-/*\n- * There's an entry like this for each nested DO loop.\n- * The list is maintained by push_loop_block\n- * and pop_loop_block.\n- */\n-typedef struct loop {\n-  struct loop *nxt_level;   /* pointer to enclosing loop */\n-  ITERATOR    *iter_list;   /* iterators for the current loop */\n-} LOOP;\n-\n-static LOOP *loopstack = (LOOP *)0;\n-\f\n-/*\n-\n-Here is a CHILL DO FOR statement:\n-\n-DO FOR user_var := start_exp BY step_exp [DOWN] TO end_exp \n-   WHILE condition;\n-\n-For this loop to be 'safe', like a Pascal FOR loop, the start,\n-end, and increment expressions are computed once, before the\n-assignment to the iteration variable and saved in temporaries,\n-before the first assignment of the iteration variable, so the\n-following works:\n-\n-          FOR i := (i+1) TO (i+10) DO\n-\n-To prevent changes to the start/end/step expressions from\n-effecting the loop's termination, and to make the loop end-check\n-as simple as possible, we evaluate the step expression into\n-a temporary and compute a hidden iteration count before entering \n-the loop's body.  User code cannot effect the counter, and the\n-end-loop check simply decrements the counter and checks for zero.\n-\n-The whole phrase FOR iter := ... TO end_exp can be repeated\n-multiple times, with different user-iteration variables.  This\n-is discussed later.\n-\n-The loop counter calculations need careful design since a loop\n-from MININT TO MAXINT must work, in the precision of integers.\n-\n-Here's how it works, in C:\n-\n-        0) The DO ... OD loop is simply a block with \n-           its own scope.  \n-\n-\t1) The DO FOR EVER is simply implemented:\n-\n-\t   loop_top:\n-\t\t.\n-\t\t. body of loop\n-\t\t.\n-\t\tgoto loop_top\n-\t   end_loop:\n-\n-\t2) The DO WHILE is also simple:\n-\n-\n-\t   loop_top:\n-\t\tif (!condition) goto end_loop\n-\t\t.\n-\t\t. body of loop\n-\t\t.\n-\t\tgoto loop_top\n-\t   end_loop:\n-\n-\n-\t3) The DO FOR [while condition] loop (no DOWN)\n-\n-\tpush a new scope,\n-\tdecl iter_var\n-\n-\t\tstep_temp = step_exp\n-                start_temp = start_exp\n-                end_temp = end_exp\n-\t\tif (end_exp < start_exp) goto end_loop\n-                // following line is all unsigned arithmetic\n-\t\titer_var = (end_exp - start_exp) / step_exp\n-                user_var = start_temp\n-\t   loop_top:\n-\t\tif (!condition) goto end_loop\n-\t\t.\n-\t\t. body of loop\n-\t\t.\n-\t\tif (iter_var == 0) goto end_loop\n-                iter_var--\n-                user_var += step_temp\n-\t\tgoto loop_top\n-\tend_loop:\n-\tpop scope\n-\n-\t4) The for [while condition] loop (with DOWN)\n-\n-\tpush a new scope,\n-        decl iter\n-\t\tstep_temp = step_exp\n-                start_temp = start_exp\n-                end_temp = end_exp\n-\t\tif (end_exp > start_exp) goto end_loop\n-                // following line is all unsigned arithmetic\n-\t\titer_var = (start_exp - end_exp) / step_exp\n-                user_var = start_temp\n-\t   loop_top:\n-\t\tif (!condition) goto end_loop\n-\t\t.\n-\t\t. body of loop\n-\t\t.\n-\t\tif (iter_var == 0) goto end_loop\n-                iter_var--\n-\t\tuser_var -= step_temp\n-\t\tgoto loop_top\n-\t    end_loop:\n-\tpop scope\n-\n-\n-        5) The range loop, which iterates over a mode's possible\n-           values, works just like the above step loops, but with\n-           the start and end values taken from the mode's lower\n-           and upper domain values.\n-\f\n-\n-\t6) The FOR IN loop, where a location enumeration is\n-           specified (see spec on page 81 of Z.200, bottom\n-           of page 186):\n-\n-\tpush a new scope,\n-        decl iter_var as an unsigned integer\n-             loc_ptr_temp as pointer to a composite base type\n-        \n-               if array is varying\n-                   iter_var = array's length field\n-               else\n-                   iter_var = sizeof array / sizeof base_type\n-\t       loc_ptr_temp = &of highest or lowest indexable entry\n-\t   loop_top:\n-\t\tif (!condition) goto end_loop\n-\t\t.\n-\t\t. body of loop\n-\t\t.\n-                iter_var--\n-                if (iter_var == 0) goto end_loop               \n-\t\tloc_ptr_temp +/-= sizeof array base_type\n-\t\tgoto loop_top\n-\t   end_loop:\n-\tpop scope\n-\n-\t7) The DO FOR (DOWN) IN powerset_exp\n-\n-\tpush a new scope,\n-\tdecl iterator as basetype of powerset\n-\n-\t        powerset_temp := save_expr (start_exp)\n-\t\titer_var := DOWN ? length  : 0\n-\t   loop_top:\n-\t        if (DOWN)\n-\t\t  iter_var := __ffsetclrpowerset (powerset_temp, length,\n-\t\t\t\t\t\t  iter_var);\n-\t        else\n-\t\t  iter_var := __ffsetclrpowerset (powrset_temp, iter_var, 0);\n-\t\tif (iter_var < 0) goto end_loop;\n-\t\tuser_var = iter_var + min_value;\n-\t\tif (!condition) goto end_loop\n-\t\tif (!DOWN) iter_var +:= 1;\n-\t\t.\n-\t\t. body of loop\n-\t\t.\n-\t\tgoto loop_top\n-\t   end_loop:\n-\tpop scope\n-\f\n-\n-So, here's the general DO FOR schema, as implemented here:\n-\n-        expand_start_loop   -- start the loop's control scope\n-        -- start scope for synthesized loop variables\n-        declare_temps       -- create, initialize temporary variables\n-        maybe_skip_loop     -- skip loop if end conditions unsatisfiable\n-        initialize_iter_var -- initialize the iteration counter\n-                            -- initialize user's loop variable\n-        expand_start_loop   -- generate top-of-loop label\n-        top_loop_end_check  -- generate while code and/or\n-                               powerset find-a-bit function call\n-        .\n-        .\n-        .  user's loop body code\n-        .\n-        .\n-        bottom_loop_end_check  -- exit if counter has become zero\n-        increment_temps     -- update temps for next iteration\n-        expand_end_loop     -- generate jump back to top of loop\n-        expand_end_cond     -- generate label for end of conditional\n-        -- end of scope for synthesized loop variables\n-        free_iterators      -- free up iterator space\n-\n-When there are two or more iterator phrases, each of the\n-above loop steps must act upon all iterators.  For example,\n-the 'increment_temps' step must increment all temporaries\n-(associated with all iterators).\n-\n- NOTE: Z.200, section 10.1 says that a block is ...\n-       \"the actions statement list in a do action, including any\n-       loop counter and while control\".  This means that an exp-\n-       ression in a WHILE control can include references to the\n-       loop counters created for the loop's exclusive use.  \n-       Example:\n-\n-             DCL a (1:10) INT;\n-             DCL j INT;\n-             DO FOR j IN a WHILE j > 0;\n-             ...\n-             OD;\n-       The 'j' referenced in the while is the loc-identity 'j'\n-       created inside the loop's scope, and NOT the 'j' declared\n-       before the loop.\n-*/\n-\f\n-/*\n- * The following routines are called directly by the\n- * CHILL parser.\n- */\n-void\n-push_loop_block ()\n-{\n-  LOOP *temp = (LOOP *)xmalloc (sizeof (LOOP));\n-\n-  /* push a new loop onto the stack */\n-  temp->nxt_level = loopstack;\n-  temp->iter_list = (ITERATOR *)0;\n-  loopstack = temp;\n-}\n-\n-void\n-pop_loop_block ()\n-{\n-  LOOP *do_temp = loopstack;\n-  ITERATOR  *ip;\n-\n-  /* pop loop block off the list */\n-  loopstack = do_temp->nxt_level;\n-\n-  /* free the loop's iterator blocks */\n-  ip = do_temp->iter_list;\n-  while (ip != NULL)\n-    {\n-      ITERATOR *temp = ip->next;\n-      free (ip);\n-      ip = temp;\n-    }\n-  free (do_temp);\n-}\n-\f\n-void\n-begin_loop_scope ()\n-{\n-  pushlevel (1);\n-\n-  if (pass >= 2)\n-    {\n-      declare_temps ();\n-\n-      clear_last_expr ();\n-      push_momentary ();\n-      expand_start_bindings (0);\n-    }\n-\n-  push_handler ();\n-\n-}\n-\n-\n-void\n-end_loop_scope (opt_label)\n-     tree opt_label;\n-{\n-  if (opt_label)\n-    possibly_define_exit_label (opt_label);\n-\n-  if (pass == 2)\n-    {\n-      expand_end_bindings (getdecls (), kept_level_p (), 0);\n-      pop_momentary ();\n-    }\n-  poplevel (kept_level_p (), 1, 0);\n-}\n-\f\n-\n-/* we need the above 2 functions somehow modified for initialising\n-   of non-value arrays */\n-\n-void\n-nonvalue_begin_loop_scope ()\n-{\n-  pushlevel (0); /* this happens only in pass 2 */\n-\n-  declare_temps ();\n-\n-  clear_last_expr ();\n-  push_momentary ();\n-  expand_start_bindings (0);\n-}\n-\n-void\n-nonvalue_end_loop_scope ()\n-{\n-  expand_end_bindings (getdecls (), kept_level_p (), 0);\n-  pop_momentary ();\n-  poplevel (kept_level_p (), 1, 0);\n-}\n-\f\n-/* The iterator structure records all aspects of a \n- * 'FOR i := start [DOWN] TO end' clause or\n- * 'FOR i IN modename' or 'FOR i IN powerset' clause.\n- * It's saved on the iter_list of the current LOOP.\n- */\n-void\n-build_loop_iterator (user_var, start_exp, step_exp, end_exp, \n-\t\t     down_flag, in_flag, ever_flag)\n-     tree user_var, start_exp, step_exp, end_exp;\n-     int  down_flag, in_flag, ever_flag;\n-{\n-  ITERATOR *ip = (ITERATOR *)xmalloc (sizeof (ITERATOR));\n-\n-  /* chain this iterator onto the current loop */\n-  if (loopstack->iter_list == NULL)\n-    loopstack->iter_list = ip;\n-  else\n-    {\n-      ITERATOR *temp = loopstack->iter_list;\n-      while (temp->next != NULL)\n-\ttemp = temp->next;\n-      temp->next = ip;\n-    }\n-\n-  ip->user_var      = user_var;\n-  ip->start_exp     = start_exp;\n-  ip->step_exp      = step_exp;\n-  ip->end_exp       = end_exp;\n-  ip->start_temp    = NULL_TREE;\n-  ip->end_temp      = NULL_TREE;\n-  ip->step_temp     = NULL_TREE;\n-  ip->down_flag     = down_flag;\n-  ip->powerset_temp = NULL_TREE;\n-  ip->iter_var      = NULL_TREE;\n-  ip->iter_type     = NULL_TREE;\n-  ip->stepin_type   = NULL_TREE;\n-  ip->loc_ptr_temp  = NULL_TREE;\n-  ip->error_flag    = 1;          /* assume error will be found */\n-  ip->next          = (ITERATOR *)0;\n-\n-  if (ever_flag)\n-    ip->itype = DO_FOREVER;\n-  else if (in_flag && start_exp != NULL_TREE)\n-    {\n-      if (TREE_CODE (start_exp) == ERROR_MARK)\n-\treturn;\n-      if (TREE_TYPE (start_exp) == NULL_TREE)\n-\t{\n-\t  if (TREE_CODE (start_exp) == CONSTRUCTOR)\n-\t    error (\"modeless tuple not allowed in this context\");\n-\t  else\n-\t    error (\"IN expression does not have a mode\");\n-\t  return;\n-\t}\n-      if (TREE_CODE (TREE_TYPE (start_exp)) == SET_TYPE)\n-\t{\n-\t  if (CH_BOOLS_TYPE_P (TREE_TYPE (start_exp)))\n-\t    {\n-\t      sorry (\"location enumeration for BOOLS\");\n-\t      return;\n-\t    }\n-\t  ip->itype = DO_POWERSET;\n-\t}\n-      else if (discrete_type_p (TREE_TYPE (ip->start_exp)))\n-\t{\n-\t  /* range enumeration */\n-\t  tree type = TREE_TYPE (ip->start_exp);\n-\t  /* save the original type for later use in determine to do a\n-\t     rangecheck or not */\n-\t  ip->stepin_type = type;\n-\t  ip->itype = DO_STEP;\n-\t  if (ip->down_flag)\n-\t    {\n-\t      ip->start_exp = build_chill_upper (type);\n-\t      ip->end_exp = build_chill_lower (type);\n-\t    }\n-\t  else\n-\t    {\n-\t      ip->start_exp = build_chill_lower (type);\n-\t      ip->end_exp = build_chill_upper (type);\n-\t    }\n-\t}\n-      else if (TREE_CODE (TREE_TYPE (ip->start_exp)) == ARRAY_TYPE)\n-\t{\n-\t  if (TYPE_PACKED (TREE_TYPE (ip->start_exp)))\n-\t    {\n-\t      sorry (\"location enumeration for bit-packed arrays\");\n-\t      return;\n-\t    }\n-\t  ip->itype = DO_LOC;\n-\t}\n-      else if (chill_varying_type_p (TREE_TYPE (ip->start_exp)))\n-\tip->itype = DO_LOC_VARYING;\n-      else\n-\t{\n-\t  error (\"loop's IN expression is not a composite object\");\n-\t  return;\n-\t}\n-    }\n-  else\n-    ip->itype = DO_STEP;\n-  if (ip->itype == DO_STEP)\n-    {\n-      struct ch_class class;\n-\n-      if (ip->step_exp == NULL_TREE)\n-\tip->step_exp = integer_one_node;\n-\n-      if (! discrete_type_p (TREE_TYPE (ip->start_exp)))\n-\t{\n-\t  error (\"start expr must have discrete mode\");\n-\t  return;\n-\t}\n-      if (TREE_CODE (TREE_TYPE (ip->start_exp)) == ENUMERAL_TYPE\n-\t  && CH_ENUM_IS_NUMBERED (TREE_TYPE (ip->start_exp)))\n-\t{\n-\t  error (\"DO FOR start expression is a numbered SET\");\n-\t  return;\n-\t}\n-      if (TREE_CODE (ip->end_exp) == ERROR_MARK)\n-\treturn;\n-      if (TREE_CODE (TREE_TYPE (ip->end_exp)) == ENUMERAL_TYPE\n-\t  && CH_ENUM_IS_NUMBERED (TREE_TYPE (ip->end_exp)))\n-\t{\n-\t  error (\"TO expression is a numbered SET\");\n-\t  return;\n-\t}\n-      if (! discrete_type_p (TREE_TYPE (ip->end_exp)))\n-\t{\n-\t  error (\"TO expr must have discrete mode\");\n-\t  return;\n-\t}\n-      if (! CH_COMPATIBLE_CLASSES (ip->start_exp, ip->end_exp))\n-\t{\n-\t  error (\"start expr and TO expr must be compatible\");\n-\t  return;\n-\t}\n-      if (step_exp != NULL_TREE)\n-\t{\n-\t  if (TREE_CODE (step_exp) == ERROR_MARK)\n-\t    return;\n-\t  if (! discrete_type_p (TREE_TYPE (step_exp)))\n-\t    {\n-\t      error (\"BY expr must have discrete mode\");\n-\t      return;\n-\t    }\n-\t  if (! CH_COMPATIBLE_CLASSES (ip->start_exp, step_exp))\n-\t    {\n-\t      error (\"start expr and BY expr must be compatible\");\n-\t      return;\n-\t    }\n-\t}\n-\n-      if (! flag_local_loop_counter)\n-\t{\n-\t  /* In this case, it's a previously-declared VAR_DECL node. */\n-\t  tree id_node = ip->user_var;\n-\t  if (TREE_CODE (ip->user_var) == IDENTIFIER_NODE)\n-\t    ip->user_var = lookup_name (ip->user_var);\n-\n-\t  /* Chill 1984 allows the name to be a defining occurrence,\n-\t     but does not require it. */\n-\t  if (ip->user_var == NULL_TREE)\n-\t    {\n-\t      warning (\"loop identifier undeclared\");\n-\t      ip->user_var = id_node;\n-\t      /* We declare a local name below. */\n-\t    }\n-\t  else\n-\t    {\n-\t      if (TREE_CODE (TREE_TYPE (ip->user_var)) == REFERENCE_TYPE)\n-\t\tip->user_var = convert_from_reference (ip->user_var);\n-\n-\t      if (! CH_COMPATIBLE_CLASSES (ip->start_exp, ip->user_var))\n-\t\t{\n-\t\t  error (\"loop variable incompatible with start expression\");\n-\t\t  return;\n-\t\t}\n-\t      class = chill_expr_class (ip->user_var);\n-\t    }\n-\t}\n-      /* Otherwise, declare a new name. */\n-      if (TREE_CODE (ip->user_var) == IDENTIFIER_NODE)\n-\t{\n-\t  class = CH_RESULTING_CLASS (chill_expr_class (ip->start_exp),\n-\t\t\t\t      chill_expr_class (ip->end_exp));\n-\t  if (step_exp)\n-\t    class = CH_RESULTING_CLASS (class, chill_expr_class (step_exp));\n-\n-\t  /* Integer literals noramally have type 'long long'\n-\t     (see convert_integer in lex.c).  That is usually overkill. */\n-\t  if (class.kind == CH_DERIVED_CLASS\n-\t      && class.mode == long_long_integer_type_node\n-\t      && int_fits_type_p (ip->start_exp, integer_type_node)\n-\t      && int_fits_type_p (ip->end_exp, integer_type_node))\n-\t    class.mode = integer_type_node;\n-\t}\n-\n-      if (TREE_CODE (ip->start_exp) == INTEGER_CST\n-\t  && TREE_CODE (ip->end_exp) == INTEGER_CST\n-\t  && compare_int_csts (ip->down_flag ? LT_EXPR : GT_EXPR,\n-\t\t\t       ip->start_exp, ip->end_exp))\n-\twarning (\"body of DO FOR will never execute\");\n-\n-      ip->start_exp = convert_to_class (class, ip->start_exp);\n-      ip->end_exp   = convert_to_class (class, ip->end_exp);\n-      ip->step_exp = convert_to_class (class, ip->step_exp);\n-\n-      if (TREE_CODE (ip->step_exp) != INTEGER_CST)\n-\t{\n-\t  /* generate runtime check for negative BY expr */\n-\t  ip->step_exp = \n-\t    check_range (ip->step_exp, ip->step_exp,\n-\t\t\t integer_zero_node, NULL_TREE);\n-\t}\n-      else if (compare_int_csts (LE_EXPR, ip->step_exp, integer_zero_node))\n-\t{\n-\t  error (\"BY expression is negative or zero\");\n-\t  return;\n-\t}\n-    }\n-\n-  ip->error_flag = 0;           /* no errors! */\n-}\n-\f\n-void\n-build_loop_start (start_label)\n-     tree start_label;\n-{\n-  ITERATOR *firstp = loopstack->iter_list;\n-  \n-  if (firstp->error_flag)\n-    return;\n-\n-  maybe_skip_loop ();\n-\n-  if (initialize_iter_var ())\n-    return;\n-\n-  /* use the label as an 'exit' label, \n-     'goto' needs another sort of label */\n-  expand_start_loop (start_label != NULL_TREE);\n-}\n-\f\n-/*\n- * Called after the last action of the loop body\n- * has been parsed.\n- */\n-void\n-build_loop_end ()\n-{\n-  ITERATOR *ip = loopstack->iter_list;\n-\n-  emit_line_note (input_filename, lineno);\n-\n-  if (ip->error_flag)\n-    return;\n-\n-  if (bottom_loop_end_check ())\n-    return;\n-\n-  if (increment_temps ())\n-    return;\n-\n-  expand_end_loop ();\n-\n-  for (; ip != NULL; ip = ip->next)\n-    {\n-      switch (ip->itype)\n-\t{\n-\tcase DO_LOC_VARYING:\n-\tcase DO_STEP:\n-\t  expand_end_cond ();\n-\t  break;\n-\tdefault:\n-\t  break;\n-\t}\n-    }\n-}\n-\f\n-/*\n- * Reserve space for any loop-control temporaries, initialize them\n- */\n-static int\n-declare_temps ()\n-{\n-  ITERATOR *firstp = loopstack->iter_list, *ip;\n-  tree start_ptr;\n-\n-  for (ip = firstp; ip != NULL; ip = ip->next)\n-    {\n-      switch (ip->itype)\n-\t{\n-\tcase DO_FOREVER:\n-\t  break;\n-\tcase DO_STEP:\n-\t  ip->iter_type\n-\t    = type_for_size (TYPE_PRECISION (TREE_TYPE (ip->start_exp)), 1);\n-\n-\t  /* create, initialize temporaries if expressions aren't constant */\n-\t  ip->start_temp = maybe_make_for_temp (ip->start_exp, \"for_start\",\n-\t\t\t\t\t\tTREE_TYPE (ip->start_exp));\n-\t  ip->end_temp = maybe_make_for_temp (ip->end_exp, \"for_end\",\n-\t\t\t\t\t      TREE_TYPE (ip->end_exp));\n-\t  /* this is just the step-expression */\n-\t  ip->step_temp    = maybe_make_for_temp (ip->step_exp, \"for_step\",\n-\t\t\t\t\t\t  TREE_TYPE (ip->step_exp));\n-\t  if (TREE_CODE (ip->user_var) == IDENTIFIER_NODE)\n-\t    {\n-\t      /* (re-)declare the user's iteration variable in the \n-\t\t loop's scope. */\n-\t      tree id_node = ip->user_var;\n-\t      ip->user_var = \n-\t\tdecl_temp1 (id_node, TREE_TYPE (ip->start_exp), 0, NULL_TREE,\n-\t\t\t    0, 0);\n-\t      CH_DERIVED_FLAG (ip->user_var) = CH_DERIVED_FLAG (ip->start_exp);\n-\t      pushdecl (ip->user_var);\n-\t    }\n-\t  ip->iter_var = \n-\t    decl_temp1 (get_unique_identifier (\"iter_var\"),\n-\t\t\tip->iter_type, 0, NULL_TREE, 0, 0);\n-\t  break;\n-\n-\tcase DO_POWERSET:\n-\t  /* the user's powerset-expression */\n-\t  ip->powerset_temp = save_expr (ip->start_exp);\n-\t  mark_addressable (ip->powerset_temp);\n-\n-\t  ip->iter_type = integer_type_node;\n-\t  ip->iter_var = decl_temp1 (get_unique_identifier (\"iter_var\"),\n-\t\t\t\t     ip->iter_type, 0,\n-\t\t\t\t     !ip->down_flag ? integer_zero_node\n-\t\t\t\t     : powersetlen (ip->powerset_temp),\n-\t\t\t\t     0, 0);\n-\n-\t  if (flag_local_loop_counter)\n-\t    {\n-\t      /* declare the user's iteration variable in the loop's scope. */\n-\t      /* in this case, it's just an IDENTIFIER_NODE */\n-\t      ip->user_var = \n-\t\tdecl_temp1 (ip->user_var,\n-\t\t\t    TYPE_DOMAIN (TREE_TYPE (ip->start_exp)),\n-\t\t\t    0, NULL_TREE, 0, 0);\n-\t      pushdecl (ip->user_var);\n-\t    }\n-\t  else\n-\t    {\n-\t      /* in this case, it's a previously-declared VAR_DECL node */\n-\t      ip->user_var = lookup_name (ip->user_var);\n-\t    }\n-\t  break;\n-\n-\tcase DO_LOC:\n-\tcase DO_LOC_VARYING:\n-\t  ip->iter_type = chill_unsigned_type_node;\n-\t  /* create the counter temp */\n-\t  ip->iter_var = \n-\t    build_temporary_variable (\"iter_var\", ip->iter_type);\n-\n-\t  if (!CH_LOCATION_P (ip->start_exp))\n-\t    ip->start_exp\n-\t      = decl_temp1 (get_unique_identifier (\"iter_loc\"),\n-\t\t\t    TREE_TYPE (ip->start_exp), 0,\n-\t\t\t    ip->start_exp, 0, 0);\n-\n-\t  if (ip->itype == DO_LOC)\n-\t    {\n-\t      tree array_type = TREE_TYPE (ip->start_exp);\n-\t      tree ptr_type;\n-\t      tree temp;\n-\t      \n-\t      /* FIXME: check for array type in ip->start_exp */\n-\n-\t      /* create pointer temporary */\n-\t      ip->base_type = TREE_TYPE (array_type);\n-\t      ptr_type = build_pointer_type (ip->base_type);\n-\t      ip->loc_ptr_temp =\n-\t\tbuild_temporary_variable (\"loc_ptr_tmp\", ptr_type);\n-\t      \n-\t      /* declare the user's iteration variable in \n-\t\t the loop's scope, as an expression, to be\n-\t\t passed to build_component_ref later */\n-\t      save_expr_under_name (ip->user_var, \n-\t\tbuild1 (INDIRECT_REF, ip->base_type, \n-\t\t\tip->loc_ptr_temp));\n-\t      \n-\t      /* FIXME: see stor_layout */\n-\t      ip->step_temp = size_in_bytes (ip->base_type);\n-\t      \n-\t      temp = TYPE_DOMAIN (array_type);\n-\n-\t      /* pointer to first array entry to look at */\n-\t      start_ptr = build1 (ADDR_EXPR, ptr_type, ip->start_exp);\n-\t      mark_addressable (ip->start_exp);\n-\t      ip->start_temp = ip->down_flag ? \n-\t\tfold (build (PLUS_EXPR, ptr_type, \n-\t\t\t     start_ptr,\n-\t\t  fold (build (MULT_EXPR, integer_type_node, ip->step_temp,\n-\t\t    fold (build (MINUS_EXPR, integer_type_node,\n-\t\t\t\t TYPE_MAX_VALUE (temp),\n-\t\t\t\t TYPE_MIN_VALUE (temp)))))))\n-\t\t  : start_ptr;\n-\t    }\n-\t  else\n-\t    {\n-\t      tree array_length =\n-\t\tconvert (integer_type_node,\n-\t\t  build_component_ref (ip->start_exp, var_length_id));\n-\t      tree array_type = TREE_TYPE (TREE_CHAIN (\n-\t\t\tTYPE_FIELDS (TREE_TYPE (ip->start_exp))));\n-\t      tree array_data_ptr = \n-\t\tbuild_component_ref (ip->start_exp, var_data_id);\n-\t      tree ptr_type;\n-\t      \n-\t      if (TREE_CODE (TREE_TYPE (array_type)) == BOOLEAN_TYPE)\n-\t\t{\n-\t\t  error (\"can't iterate through array of BOOL\");\n-\t\t  firstp->error_flag = 1;\n-\t\t  return firstp->error_flag;\n-\t\t}\n-\t      \n-\t      /* create pointer temporary */\n-\t      ip->base_type = TREE_TYPE (array_type);\n-\t      ptr_type = build_pointer_type (ip->base_type);\n-\t      ip->loc_ptr_temp = \n-\t\tbuild_temporary_variable (\"loc_ptr_temp\", ptr_type);\n-\t\t\t\t\t\t\t   \n-\t      \n-\t      /* declare the user's iteration variable in \n-\t\t the loop's scope, as an expression, to be\n-\t\t passed to build_component_ref later */\n-\t      save_expr_under_name (ip->user_var, \n-\t\tbuild1 (INDIRECT_REF, ip->base_type, \n-\t\t\tip->loc_ptr_temp));\n-\t      \n-\t      /* FIXME: see stor_layout */\n-\t      ip->step_temp = size_in_bytes (ip->base_type);\n-\t      \n-\t      /* pointer to first array entry to look at */\n-\t      start_ptr = build1 (ADDR_EXPR, ptr_type, array_data_ptr);\n-\t      mark_addressable (array_data_ptr);\n-\t      ip->start_temp = ip->down_flag ? \n-\t\tfold (build (PLUS_EXPR, ptr_type, \n-                  start_ptr,\n-\t\t    fold (build (MULT_EXPR, integer_type_node, ip->step_temp,\n-\t\t      fold (build (MINUS_EXPR, integer_type_node,\n-\t\t\t\t   array_length,\n-\t\t\t\t   integer_one_node))))))\n-\t\t  : start_ptr;\n-\t    }\n-\tdefault:\n-\t  ;\n-\t}\n-    }\n-  return firstp->error_flag;\n-}\n-\f\n-/*\n- * Initialize the hidden iteration-control variables,\n- * and the user's explicit loop variable.\n- */\n-static int\n-initialize_iter_var ()\n-{\n-  ITERATOR *firstp = loopstack->iter_list, *ip;\n-\n-  for (ip = firstp; ip != NULL; ip = ip->next)\n-    {\n-     switch (ip->itype)\n-\t{\n-\ttree array_type, array_length; \n-\tcase DO_FOREVER:\n-\t  break;\n-\tcase DO_STEP:\n-\t  {\n-\t    tree count;\n-\t    count = build (MINUS_EXPR, ip->iter_type,\n-\t\t\t   convert (ip->iter_type,\n-\t\t\t\t    ip->down_flag ? ip->start_temp : ip->end_temp),\n-\t\t\t   convert (ip->iter_type,\n-\t\t\t\t    ip->down_flag ? ip->end_temp   : ip->start_temp));\n-\t    count = fold (build (TRUNC_DIV_EXPR, ip->iter_type, \n-\t\t\t\t fold (count),\n-\t\t\t\t ip->step_temp));\n-\t    /* The count in this case is actually one less than the\n-\t       number of iterations, to avoid overflow problems\n-\t       if we iterate *all* the values of iter_type. */\n-\t    /* initialize the loop's hidden counter variable */\n-\t    expand_expr_stmt (\n-\t      build_chill_modify_expr (ip->iter_var, count));\n-\n-\t    /* initialize user's variable */\n-\t    expand_expr_stmt (\n-\t      build_chill_modify_expr (ip->user_var, ip->start_temp));\n-\t  }\n-\t  break;\n-\tcase DO_POWERSET:\n-\t  break;\n-\tcase DO_LOC:\n-\t  array_type = TREE_TYPE (ip->start_exp);\n-\t  array_length = fold (build (TRUNC_DIV_EXPR, integer_type_node,\n-\t\t\t\t      size_in_bytes (array_type),\n-\t\t\t\t      size_in_bytes (TREE_TYPE (array_type))));\n-\t  goto do_loc_common;\n-\n-\tcase DO_LOC_VARYING:\n-\t  array_length\n-\t    = convert (integer_type_node,\n-\t\t       build_component_ref (ip->start_exp, var_length_id));\n-\n-\tdo_loc_common:\n-\t  expand_expr_stmt (build_chill_modify_expr (ip->iter_var,\n-\t\t\t\t\t\t     array_length));\n-\t  expand_expr_stmt (\n-\t    build_chill_modify_expr (ip->loc_ptr_temp, \n-\t\t\t\t     ip->start_temp));\n-\t  break;\n-\n-\tdefault:\n-\t  ;\n-\t}\n-    }\n-  return firstp->error_flag;\n-}\n-\f\n-/* Generate code to skip the whole loop, if start expression not\n- * <= end expression (or >= for DOWN loops).  This comparison must\n- * *NOT* be done in unsigned mode, or it will fail.\n- *  Also, skip processing an empty VARYING array. \n- */\n-static void\n-maybe_skip_loop ()\n-{\n-  ITERATOR *firstp = loopstack->iter_list, *ip;\n-\n-  for (ip = firstp; ip != NULL; ip = ip->next)\n-    {\n-      switch (ip->itype)\n-\t{\n-\tcase DO_STEP:\n-\t  expand_start_cond (\n-\t    build_compare_discrete_expr (ip->down_flag ? GE_EXPR : LE_EXPR, \n-\t\t   ip->start_temp, ip->end_temp), 0);\n-\t  break;\n-    \n-\tcase DO_LOC_VARYING:\n-\t  { tree array_length =\n-\t      convert (integer_type_node,\n-\t        build_component_ref (ip->start_exp, var_length_id));\n-\t    expand_start_cond (\n-\t      build (NE_EXPR, TREE_TYPE (array_length),\n-\t\t     array_length, integer_zero_node), 0);\n-\t    break;\n-\t  }\n-\tdefault:\n-\t  break;\n-\t}\n-    }\n-}  \n-\f\n-/*\n- * Check at the top of the loop for a termination\n- */\n-void\n-top_loop_end_check (condition)\n-     tree condition;\n-{\n-  ITERATOR *ip;\n-\n-  for (ip = loopstack->iter_list; ip != NULL; ip = ip->next)\n-    {\n-      switch (ip->itype)\n-\t{\n-\tcase DO_FOREVER:\n-\tcase DO_STEP:\n-\t  break;\n-\tcase DO_POWERSET:\n-\t  {\n-\t    tree temp1;\n-\t    const char *func_name;\n-\t    tree user_type = TREE_TYPE (ip->user_var);\n-\n-\t    if (ip->down_flag)\n-\t      func_name = \"__flsetclrpowerset\";\n-\t    else\n-\t      func_name = \"__ffsetclrpowerset\";\n-\t    \n-\t    temp1 = lookup_name (get_identifier (func_name));\n-\t    if (ip->down_flag)\n-\t      temp1 = build_chill_function_call (temp1,\n-\t        tree_cons (NULL_TREE, force_addr_of (ip->powerset_temp),\n-\t\t  tree_cons (NULL_TREE, ip->iter_var,\n-\t\t    tree_cons (NULL_TREE, integer_zero_node, NULL_TREE))));\n-\t    else\n-\t      temp1 = build_chill_function_call (temp1,\n-\t        tree_cons (NULL_TREE, force_addr_of (ip->powerset_temp),\n-\t\t  tree_cons (NULL_TREE, powersetlen (ip->powerset_temp),\n-\t\t    tree_cons (NULL_TREE, ip->iter_var, NULL_TREE))));\n-\t    expand_assignment (ip->iter_var, temp1, 0, 0);\n-\t    expand_exit_loop_if_false (0, build (GE_EXPR, boolean_type_node,\n-\t\t\t\t\t\t ip->iter_var,\n-\t\t\t\t\t\t integer_zero_node));\n-\t    temp1 = TYPE_MIN_VALUE\n-\t      (TYPE_DOMAIN (TREE_TYPE (ip->powerset_temp)));\n-\t    expand_assignment (ip->user_var,\n-\t\t\t       build (PLUS_EXPR, user_type,\n-\t\t\t\t      convert (user_type, ip->iter_var),\n-\t\t\t\t      convert (user_type, temp1)),\n-\t\t\t       0, 0);\n-\t  }\n-\t  break;\n-\tcase DO_LOC:\n-\tcase DO_LOC_VARYING:\n-\t  break;\n-\tdefault:\n-\t  ;\n-\t}\n-    }\n-  emit_line_note (input_filename, lineno); \n-\n-  /* now, exit the loop if the condition isn't TRUE. */\n-  if (condition)\n-    expand_exit_loop_if_false (0, truthvalue_conversion (condition));\n-}\n-\f\n-/*\n- * Check generated temporaries for loop's end\n- */\n-static int\n-bottom_loop_end_check ()\n-{\n-  ITERATOR *firstp = loopstack->iter_list, *ip;\n-\n-  emit_line_note (input_filename, lineno);\n-\n-  /* now, generate code to check each loop counter for termination */\n-  for (ip = firstp; ip != NULL; ip = ip->next)\n-    {\n-      switch (ip->itype)\n-\t{\n-\tcase DO_FOREVER:\n-\t  break;\n-\tcase DO_STEP:\n-\t  /* exit if it's zero */\n-\t  expand_exit_loop_if_false (0,\n-\t    build (NE_EXPR, boolean_type_node, \n-\t\t   ip->iter_var,\n-\t\t   integer_zero_node));\n-\t  /* decrement iteration counter by one */\n-\t  chill_expand_assignment (ip->iter_var, MINUS_EXPR, integer_one_node);\n-\t  break;\n-\tcase DO_LOC:\n-\tcase DO_LOC_VARYING:\n-\t  /* decrement iteration counter by one */\n-\t  chill_expand_assignment (ip->iter_var, MINUS_EXPR, integer_one_node);\n-\t  /* exit if it's zero */\n-\t  expand_exit_loop_if_false (0,\n-\t    build (NE_EXPR, boolean_type_node, \n-\t\t   ip->iter_var,\n-\t\t   integer_zero_node));\n-\t  break;\n-\tcase DO_POWERSET:\n-\t  break;\n-\tdefault:\n-\t  ;\n-\t}\n-    }\n-\n-  return firstp->error_flag;\n-}\n-\f\n-/*\n- * increment the loop-control variables.\n- */\n-static int\n-increment_temps ()\n-{\n-  ITERATOR *firstp = loopstack->iter_list, *ip;\n-\n-  for (ip  = firstp; ip != NULL; ip = ip->next)\n-    {\n-      switch (ip->itype)\n-\t{\n-\tcase DO_FOREVER:\n-\t  break;\n-\tcase DO_STEP:\n-\t  {\n-\t    tree delta =\n-\t      fold (build (ip->down_flag ? MINUS_EXPR : PLUS_EXPR,\n-\t\t\t   TREE_TYPE (ip->user_var), ip->user_var,\n-\t\t\t   ip->step_temp));\n- \t    expand_expr_stmt (\n-\t      build_chill_modify_expr (ip->user_var, delta));\n-\t  }\n-\t  break;\n-\tcase DO_LOC:\n-\tcase DO_LOC_VARYING:\n-\t  /* This statement uses the C semantics, so that \n-\t     the pointer is actually incremented by the \n-\t     length of the object pointed to. */\n-\t  {\n-\t    enum tree_code op = ip->down_flag ? MINUS_EXPR : PLUS_EXPR;\n-\t    tree el_type = TREE_TYPE (TREE_TYPE (ip->loc_ptr_temp));\n-\t    chill_expand_assignment (ip->loc_ptr_temp, NOP_EXPR,\n-\t\t\t\t     build (op,\n-\t\t\t\t\t    TREE_TYPE (ip->loc_ptr_temp),\n-\t\t\t\t\t    ip->loc_ptr_temp,\n-\t\t\t\t\t    size_in_bytes (el_type)));\n-\t  }\n-\t  break;\n-\tcase DO_POWERSET:\n-\t  if (!ip->down_flag)\n-\t    expand_assignment (ip->iter_var,\n-\t\t\t       build (PLUS_EXPR, ip->iter_type,\n-\t\t\t\t      ip->iter_var,\n-\t\t\t\t      integer_one_node),\n-\t\t\t       0, 0);\n-\t  break;\n-\tdefault:\n-\t  ;\n-\t}\n-    }\n-  return firstp->error_flag;\n-}\n-\f\n-/*\n- * Generate a (temporary) unique identifier_node of\n- * the form \"__tmp_%s_%d\"\n- */\n-tree\n-get_unique_identifier (lead)\n-     const char *lead;\n-{\n-  char idbuf [256];\n-  static int idcount = 0;\n-\n-  sprintf (idbuf, \"__tmp_%s_%d\", lead ? lead : \"\", idcount++);\n-  return get_identifier (idbuf);\n-}\n-\f\n-/*\n- * build a temporary variable, given its NAME and TYPE.\n- * The name will have a number appended to assure uniqueness.\n- * return its DECL node.\n- */\n-static tree\n-build_temporary_variable (name, type)\n-     const char *name;\n-     tree type;\n-{\n-  return decl_temp1 (get_unique_identifier (name), type, 0, NULL_TREE, 0, 0);\n-}\n-\n-\n-/*\n- * If the given expression isn't a constant, build a temp for it\n- * and evaluate the expression into the temp.  Return the tree\n- * representing either the original constant expression or the\n- * temp which now contains the expression's value. \n- */\n-static tree\n-maybe_make_for_temp (exp, temp_name, exp_type)\n-     tree exp;\n-     const char *temp_name;\n-     tree exp_type;\n-{\n-  tree result = exp;\n-\n-  if (exp != NULL_TREE)\n-    {\n-      /* if exp isn't constant, create a temporary for its value */\n-      if (TREE_CONSTANT (exp))\n-\t{\n-          /* FIXME: assure that TREE_TYPE (result) == ip->exp_type */\n-\t  result = convert (exp_type, exp);\n-\t}\n-      else {\n-\t/* build temp, assign the value */\n-\tresult = decl_temp1 (get_unique_identifier (temp_name), exp_type, 0,\n-\t\t\t     exp, 0, 0);\n-      }\n-    }\n-  return result;\n-}\n-\n-#if 0\n-/*\n- * Adapt the C unsigned_type function to CHILL - we need to\n- * account for any CHILL-specific integer types here.  So far,\n- * the 16-bit integer type is the only one.\n- */\n-static tree\n-chill_unsigned_type (type)\n-     tree type;\n-{\n-  extern tree chill_unsigned_type_node;\n-  tree type1 = TYPE_MAIN_VARIANT (type);\n-\n-  if (type1 == chill_integer_type_node)\n-    return chill_unsigned_type_node;\n-  else\n-    return unsigned_type (type);\n-}\n-#endif"}, {"sha": "2a7a4600fad775c8d37b66aab34d61143de995bf", "filename": "gcc/ch/nloop.c", "status": "removed", "additions": 0, "deletions": 1246, "changes": 1246, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41823c5eb7d4504b6a4a396ca0d64573238fbbcf/gcc%2Fch%2Fnloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41823c5eb7d4504b6a4a396ca0d64573238fbbcf/gcc%2Fch%2Fnloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fnloop.c?ref=41823c5eb7d4504b6a4a396ca0d64573238fbbcf", "patch": "@@ -1,1246 +0,0 @@\n-/* Implement looping actions for CHILL.\n-   Copyright (C) 1992, 1993, 1994, 2000\n-   Free Software Foundation, Inc.\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-#include <stdio.h>\n-#include <limits.h>\n-#include \"config.h\"\n-#include \"tree.h\"\n-#include \"ch-tree.h\"\n-#include \"lex.h\"\n-#include \"flags.h\"\n-#include \"actions.h\"\n-#include \"input.h\"\n-#include \"obstack.h\"\n-#include \"assert.h\"\n-#include \"rtl.h\"\n-\n-/* if the user codes '-flocal-loop-counter' on the command line,\n-   ch-actions.c (lang_decode_option) will set this flag. */\n-int flag_local_loop_counter = 0;\n-\n-extern tree chill_truthvalue_conversion PARAMS ((tree));\n-extern rtx  emit_line_note              PARAMS ((char *, int)); \n-extern void error                       PARAMS ((char *, ...));\n-extern rtx  expand_assignment           PARAMS ((tree, tree, int, int));\n-extern void save_expr_under_name        PARAMS ((tree, tree));\n-extern void stamp_nesting_label         PARAMS ((tree));\n-extern int  int_fits_type_p             PARAMS ((tree, tree));\n-extern void warning                     PARAMS ((char *, ...));\n-\n-/* forward declarations */\n-static int  classify_loop            PARAMS ((void));\n-static int  declare_temps            PARAMS ((void));\n-static int  initialize_iter_var      PARAMS ((void));\n-static int  maybe_skip_loop          PARAMS ((void));\n-static int  top_loop_end_check       PARAMS ((void));\n-static int  bottom_loop_end_check    PARAMS ((void));\n-static int  increment_temps          PARAMS ((void));\n-static tree build_temporary_variable PARAMS ((char *, tree));\n-static tree maybe_make_for_temp      PARAMS ((tree, char *, tree));\n-static tree chill_unsigned_type      PARAMS ((tree));\n-\f\n-/* In terms of the parameters passed to build_loop_iterator,\n- *   there are several types of loops.  They are encoded by\n- *   the ITER_TYPE enumeration.\n- *\n- *   1) DO FOR EVER; ... OD\n- *      indicated by a NULL_TREE start_exp, step_exp and end_exp,\n- *      condition == NULL, in_flag = 0, and ever_flag == 1 in the\n- *      first ITERATOR.\n- *\n- *   2) DO WHILE cond; ... OD\n- *      indicated by NULL_TREE start_exp, step_exp and end_exp, \n- *      in_flag = 0, and condition != NULL.\n- *\n- *   3) DO; ... OD\n- *      indicated by NULL_TREEs in start_exp, step_exp and end_exp,\n- *      condition != NULL, in_flag == 0 and ever_flag == 0.  This\n- *      is not really a loop, but a compound statement.\n- *\n- *   4) DO FOR user_var := start_exp \n- *         [DOWN] TO end_exp BY step_exp; ... DO\n- *      indicated by non-NULL_TREE start_exp, step_exp and end_exp.\n- *\n- *   5) DO FOR user_var [DOWN] IN discrete_mode; ... OD\n- *      indicated by in_flag == 1.  start_exp is a non-NULL_TREE \n- *      discrete mode, with an optional down_flag.\n- *\n- *   6) DO FOR user_var [DOWN] IN powerset_expr; ... OD\n- *      indicated by in_flag == 1.  start_exp is a non-NULL_TREE \n- *      powerset mode, with an optional down_flag.\n- *\n- *   7) DO FOR user_var [DOWN] IN location; ... OD\n- *      indicated by in_flag == 1.  start_exp is a non-NULL_TREE \n- *      location mode, with an optional down_flag.\n- */\n-typedef enum \n-{\n-   DO_UNUSED,\n-   DO_FOREVER,\n-   DO_WHILE,\n-   DO_OD,\n-   DO_STEP,\n-   DO_RANGE,\n-   DO_POWERSET,\n-   DO_LOC,\n-   DO_LOC_VARYING \n-} ITER_TYPE;\n-\n-\n-typedef struct iterator \n-{\n-/* These variables only have meaning in the first ITERATOR structure. */\n-  ITER_TYPE itype;                  /* type of this iterator */\n-  int  error_flag;                  /* TRUE if no loop was started due to \n-\t\t\t\t       user error */\n-  tree condition;                   /* WHILE condition expression */\n-  int  down_flag;                   /* TRUE if DOWN was coded */\n-\n-/* These variables have meaning in every ITERATOR structure. */\n-  tree user_var;                    /* user's explicit iteration variable */\n-  tree start_exp;                   /* user's start expression\n-                                       or IN expression of a FOR .. IN*/\n-  tree step_exp;                    /* user's step expression */\n-  tree end_exp;                     /* user's end expression */\n-  tree start_temp;                  /* temp holding evaluated start_exp */\n-  tree end_temp;                    /* temp holding evaluated end_exp */\n-  tree step_temp;                   /* temp holding evaluated step_exp */\n-  tree powerset_temp;               /* temp holding user's initial powerset expression */\n-  tree loc_ptr_temp;                /* temp holding count for LOC enumeration ptr */\n-  tree iter_var;                    /* hidden variable for the loop */\n-  tree iter_type;                   /* hidden variable's type */\n-  tree base_type;                   /* LOC enumeration base type */\n-  struct iterator *next;            /* ptr to next iterator for this loop */\n-} ITERATOR;\n-\n-/*\n- * There's an entry like this for each nested DO loop.\n- * The list is maintained by push_loop_block\n- * and pop_loop_block.\n- */\n-typedef struct loop {\n-  struct loop *nxt_level;   /* pointer to enclosing loop */\n-  ITERATOR    *iter_list;   /* iterators for the current loop */\n-} LOOP;\n-\n-static LOOP *loop_stack = (LOOP *)0;\n-\f\n-/*\n-\n-Here is a CHILL DO FOR statement:\n-\n-DO FOR user_var := start_exp BY step_exp [DOWN] TO end_exp \n-   WHILE condition;\n-\n-For this loop to be 'safe', like a Pascal FOR loop, the start,\n-end, and increment expressions are computed once, before the\n-assignment to the iteration variable and saved in temporaries,\n-before the first assignment of the iteration variable, so the\n-following works:\n-\n-          FOR i := (i+1) TO (i+10) DO\n-\n-To prevent changes to the start/end/step expressions from\n-effecting the loop's termination, and to make the loop end-check\n-as simple as possible, we evaluate the step expression into\n-a temporary and compute a hidden iteration count before entering \n-the loop's body.  User code cannot effect the counter, and the\n-end-loop check simply decrements the counter and checks for zero.\n-\n-The whole phrase FOR iter := ... TO end_exp can be repeated\n-multiple times, with different user-iteration variables.  This\n-is discussed later.\n-\n-The loop counter calculations need careful design since a loop\n-from MININT TO MAXINT must work, in the precision of integers.\n-\n-Here's how it works, in C:\n-\n-        0) The DO ... OD loop is simply a block with \n-           its own scope.  \n-\n-\t1) The DO FOR EVER is simply implemented:\n-\n-\t   loop_top:\n-\t\t.\n-\t\t. body of loop\n-\t\t.\n-\t\tgoto loop_top\n-\t   end_loop:\n-\n-\t2) The DO WHILE is also simple:\n-\n-\n-\t   loop_top:\n-\t\tif (!condition) goto end_loop\n-\t\t.\n-\t\t. body of loop\n-\t\t.\n-\t\tgoto loop_top\n-\t   end_loop:\n-\n-\n-\t3) The DO FOR [while condition] loop (no DOWN)\n-\n-\tpush a new scope,\n-\tdecl iter_var\n-\n-\t\tstep_temp = step_exp\n-                start_temp = start_exp\n-                end_temp = end_exp\n-\t\tif (end_exp < start_exp) goto end_loop\n-                // following line is all unsigned arithmetic\n-\t\titer_var = (end_exp - start_exp + step_exp) / step_exp\n-                user_var = start_temp\n-\t   loop_top:\n-\t\tif (!condition) goto end_loop\n-\t\t.\n-\t\t. body of loop\n-\t\t.\n-                iter_var--\n-\t\tif (iter_var == 0) goto end_loop\n-                user_var += step_temp\n-\t\tgoto loop_top\n-\tend_loop:\n-\tpop scope\n-\n-\t4) The proposed CHILL for [while condition] loop (with DOWN)\n-\n-\tpush a new scope,\n-        decl iter\n-\t\tstep_temp = step_exp\n-                start_temp = start_exp\n-                end_temp = end_exp\n-\t\tif (end_exp > start_exp) goto end_loop\n-                // following line is all unsigned arithmetic\n-\t\titer_var = (start_exp - end_exp + step_exp) / step_exp\n-                user_var = start_temp\n-\t   loop_top:\n-\t\tif (!condition) goto end_loop\n-\t\t.\n-\t\t. body of loop\n-\t\t.\n-                iter_var--\n-\t\tif (iter_var == 0) goto end_loop\n-\t\tuser_var -= step_temp\n-\t\tgoto loop_top\n-\t    end_loop:\n-\tpop scope\n-\n-\n-        5) The range loop, which iterates over a mode's possible\n-           values, works just like the above step loops, but with\n-           the start and end values taken from the mode's lower\n-           and upper domain values.\n-\f\n-\n-\t6) The FOR IN loop, where a location enumeration is\n-           specified (see spec on page 81 of Z.200, bottom\n-           of page 186):\n-\n-\tpush a new scope,\n-        decl iter_var as an unsigned integer\n-             loc_ptr_temp as pointer to a composite base type\n-        \n-               if array is varying\n-                   iter_var = array's length field\n-               else\n-                   iter_var = sizeof array / sizeof base_type\n-\t       loc_ptr_temp = &of highest or lowest indexable entry\n-\t   loop_top:\n-\t\tif (!condition) goto end_loop\n-\t\t.\n-\t\t. body of loop\n-\t\t.\n-                iter_var--\n-                if (iter_var == 0) goto end_loop               \n-\t\tloc_ptr_temp +/-= sizeof array base_type\n-\t\tgoto loop_top\n-\t   end_loop:\n-\tpop scope\n-\n-\t7) The DO FOR (DOWN) IN powerset_exp\n-\n-\tpush a new scope,\n-        decl powerset_temp\n-\tdecl iterator as basetype of powerset\n-\n-\t        powerset_temp := start_exp\n-\t   loop_top:\n-\t        // if DOWN\n-                if (__flsetclrpowerset () == 0) goto end_loop;\n-                // not DOWN\n-                if (__ffsetclrpowerset () == 0) goto end_loop;\n-\t\tif (!condition) goto end_loop\n-\t\t.\n-\t\t. body of loop\n-\t\t.\n-\t\tgoto loop_top\n-\t   end_loop:\n-\tpop scope\n-\f\n-\n-So, here's the general DO FOR schema, as implemented here:\n-\n-        classify_loop       -- what type of loop have we?\n-                            -- build_iterator does some of this, also\n-        expand_start_loop   -- start the loop's control scope\n-        -- start scope for synthesized loop variables\n-        declare_temps       -- create, initialize temporary variables\n-        maybe_skip_loop     -- skip loop if end conditions unsatisfiable\n-        initialize_iter_var -- initialize the iteration counter\n-                            -- initialize user's loop variable\n-        expand_start_loop   -- generate top-of-loop label\n-        top_loop_end_check  -- generate while code and/or\n-                               powerset find-a-bit function call\n-        .\n-        .\n-        .  user's loop body code\n-        .\n-        .\n-        bottom_loop_end_check  -- exit if counter has become zero\n-        increment_temps     -- update temps for next iteration\n-        expand_end_loop     -- generate jump back to top of loop\n-        expand_end_cond     -- generate label for end of conditional\n-        -- end of scope for synthesized loop variables\n-        free_iterators      -- free up iterator space\n-\n-When there are two or more iterator phrases, each of the\n-above loop steps must act upon all iterators.  For example,\n-the 'increment_temps' step must increment all temporaries\n-(associated with all iterators).\n-\n- NOTE: Z.200, section 10.1 says that a block is ...\n-       \"the actions statement list in a do action, including any\n-       loop counter and while control\".  This means that an exp-\n-       ression in a WHILE control can include references to the\n-       loop counters created for the loop's exclusive use.  \n-       Example:\n-\n-             DCL a (1:10) INT;\n-             DCL j INT;\n-             DO FOR j IN a WHILE j > 0;\n-             ...\n-             OD;\n-       The 'j' referenced in the while is the loc-identity 'j'\n-       created inside the loop's scope, and NOT the 'j' declared\n-       before the loop.\n-*/\n-\f\n-/*\n- * The following routines are called directly by the\n- * CHILL parser.\n- */\n-void\n-push_loop_block ()\n-{\n-  LOOP *temp = (LOOP *)xmalloc (sizeof (LOOP));\n-\n-  /* push a new loop onto the stack */\n-  temp->nxt_level = loop_stack;\n-  temp->iter_list = (ITERATOR *)0;\n-  loop_stack = temp;\n-}\n-\n-void\n-pop_loop_block ()\n-{\n-  LOOP *do_temp = loop_stack;\n-  ITERATOR  *ip;\n-\n-  /* pop loop block off the list */\n-  loop_stack = do_temp->nxt_level;\n-\n-  /* free the loop's iterator blocks */\n-  ip = do_temp->iter_list;\n-  while (ip != NULL)\n-    {\n-      ITERATOR *temp = ip->next;\n-      free (ip);\n-      ip = temp;\n-    }\n-  free (do_temp);\n-}\n-\f\n-void\n-begin_loop_scope ()\n-{\n-  ITERATOR *firstp = loop_stack->iter_list;\n-\n-  if (pass < 2)\n-    return;\n-\n-  /*\n-   * We need to classify the loop and declare its temporaries\n-   * here, so as to define them before the WHILE condition\n-   * (if any) is parsed.  The WHILE expression may refer to\n-   * a temporary.\n-   */\n-  if (classify_loop ())\n-    return;\n-\n-  if (firstp->itype != DO_OD)\n-    declare_temps ();\n-  \n-  clear_last_expr ();\n-  push_momentary ();\n-  expand_start_bindings (0);\n-}\n-\n-\n-void\n-end_loop_scope (opt_label)\n-     tree opt_label;\n-{\n-  if (opt_label)\n-    possibly_define_exit_label (opt_label);\n-  poplevel (0, 0, 0);\n-\n-  if (pass < 2)\n-    return;\n-\n-  expand_end_bindings (getdecls (), kept_level_p (), 0);\n-  pop_momentary ();\n-}\n-\f\n-/* The iterator structure records all aspects of a \n- * 'FOR i := start [DOWN] TO end' clause or\n- * 'FOR i IN modename' or 'FOR i IN powerset' clause.\n- * It's saved on the iter_list of the current LOOP.\n- */\n-void\n-build_loop_iterator (user_var, start_exp, step_exp, end_exp, \n-\t\t     down_flag, in_flag, ever_flag)\n-     tree user_var, start_exp, step_exp, end_exp;\n-     int  down_flag, in_flag, ever_flag;\n-{\n-  ITERATOR *ip = (ITERATOR *)xmalloc (sizeof (ITERATOR));\n-\n-  /* chain this iterator onto the current loop */\n-  if (loop_stack->iter_list == NULL)\n-    loop_stack->iter_list = ip;\n-  else\n-    {\n-      ITERATOR *temp = loop_stack->iter_list;\n-      while (temp->next != NULL)\n-\ttemp = temp->next;\n-      temp->next = ip;\n-    }\n-\n-  ip->itype         = DO_UNUSED;\n-  ip->user_var      = user_var;\n-  ip->start_exp     = start_exp;\n-  ip->step_exp      = step_exp;\n-  ip->end_exp       = end_exp;\n-  ip->condition     = NULL_TREE;\n-  ip->start_temp    = NULL_TREE;\n-  ip->end_temp      = NULL_TREE;\n-  ip->step_temp     = NULL_TREE;\n-  ip->down_flag     = down_flag;\n-  ip->powerset_temp = NULL_TREE;\n-  ip->iter_var      = NULL_TREE;\n-  ip->iter_type     = NULL_TREE;\n-  ip->loc_ptr_temp  = NULL_TREE;\n-  ip->error_flag    = 1;          /* assume error will be found */\n-  ip->next          = (ITERATOR *)0;\n-\n-  if (ever_flag)\n-    ip->itype = DO_FOREVER;\n-  else if (in_flag && start_exp != NULL_TREE)\n-    {\n-      if (TREE_CODE (start_exp) == ERROR_MARK)\n-\treturn;\n-      if (TREE_CODE (TREE_TYPE (start_exp)) == SET_TYPE)\n-\tip->itype = DO_POWERSET;\n-      else if (discrete_type_p (TREE_TYPE (ip->start_exp)))\n-\tip->itype = DO_RANGE;\n-      else if (TREE_CODE (TREE_TYPE (ip->start_exp)) == ARRAY_TYPE)\n-\tip->itype = DO_LOC;\n-      else if (chill_varying_type_p (TREE_TYPE (ip->start_exp)))\n-\tip->itype = DO_LOC_VARYING;\n-      else\n-\t{\n-\t  error (\"loop's IN expression is not a composite object\");\n-\t  return;\n-\t}\n-    }\n-  else if (start_exp == NULL_TREE && end_exp == NULL_TREE\n-\t   && step_exp == NULL_TREE && !down_flag)\n-    ip->itype = DO_OD;\n-  else\n-    {\n-      /* FIXME: Move this to the lexer? */\n-#define CST_FITS_INT(NODE) (TREE_CODE(NODE) == INTEGER_CST &&\\\n-            int_fits_type_p (NODE, integer_type_node))\n-\n-      tree max_prec_type = integer_type_node;\n-\n-      if (! discrete_type_p (TREE_TYPE (ip->start_exp)))\n-\t{\n-\t  error (\"start expr must have discrete mode\");\n-\t  return;\n-\t}\n-      if (TREE_CODE (TREE_TYPE (ip->start_exp)) == ENUMERAL_TYPE\n-\t  && CH_ENUM_IS_NUMBERED (TREE_TYPE (ip->start_exp)))\n-\t{\n-\t  error (\"DO FOR start expression is a numbered SET\");\n-\t  return;\n-\t}\n-      if (TREE_CODE (TREE_TYPE (ip->end_exp)) == ENUMERAL_TYPE\n-\t  && CH_ENUM_IS_NUMBERED (TREE_TYPE (ip->end_exp)))\n-\t{\n-\t  error (\"TO expression is a numbered SET\");\n-\t  return;\n-\t}\n-      /* Convert all three expressions to a common precision,\n-\t which is the largest precision they exhibit, but\n-         INTEGER_CST nodes are built in the lexer as\n-\t long_integer_type nodes.  We'll treat convert them to\n-\t integer_type_nodes if possible, for faster loop times. */\n-\n-      if (TYPE_PRECISION (max_prec_type) <\n-\t    TYPE_PRECISION (TREE_TYPE (ip->start_exp))\n-\t  && !CST_FITS_INT (ip->start_exp))\n-\tmax_prec_type = TREE_TYPE (ip->start_exp);\n-      if (! discrete_type_p (TREE_TYPE (ip->end_exp)))\n-\t{\n-\t  error (\"TO expr must have discrete mode\");\n-\t  return;\n-\t}\n-      if (! CH_COMPATIBLE (ip->start_exp, \n-\t\t\t   TREE_TYPE (ip->end_exp)))\n-\t{\n-\t  error (\"start expr and TO expr must be compatible\");\n-\t  return;\n-\t}\n-      if (TYPE_PRECISION (max_prec_type) <\n-\t    TYPE_PRECISION (TREE_TYPE (ip->end_exp))\n-\t  && !CST_FITS_INT (ip->end_exp))\n-\tmax_prec_type = TREE_TYPE (ip->end_exp);\n-      if (ip->step_exp != NULL_TREE)\n-\t{\n-\t  /* assure that default 'BY 1' gets a useful type */\n-\t  if (ip->step_exp == integer_one_node)\n-\t    ip->step_exp = convert (TREE_TYPE (ip->start_exp),\n-\t\t\t\t    ip->step_exp);\n-\t  if (! discrete_type_p (TREE_TYPE (ip->step_exp)))\n-\t    {\n-\t      error (\"BY expr must have discrete mode\");\n-\t      return;\n-\t    }\n-\t  if (! CH_COMPATIBLE (ip->start_exp,\n-\t\t  TREE_TYPE (ip->step_exp)))\n-\t    {\n-\t      error (\"start expr and BY expr must be compatible\");\n-\t      return;\n-\t    }\n-\t  if (TYPE_PRECISION (max_prec_type) <\n-\t\tTYPE_PRECISION (TREE_TYPE (ip->step_exp))\n-\t      && !CST_FITS_INT (ip->step_exp))\n-\t    max_prec_type = TREE_TYPE (ip->step_exp);\n-\t}\n-      if (TREE_CODE (ip->start_exp) == INTEGER_CST\n-\t  && TREE_CODE (ip->end_exp) == INTEGER_CST\n-\t  && compare_int_csts (ip->down_flag ? LT_EXPR : GT_EXPR,\n-\t\t\t       ip->start_exp, ip->end_exp))\n-\twarning (\"body of DO FOR will never execute\");\n-\n-      ip->start_exp = \n-\tconvert (max_prec_type, ip->start_exp);\n-      ip->end_exp   = \n-\tconvert (max_prec_type, ip->end_exp);\n-\n-      if (ip->step_exp != NULL_TREE)\n-\t{\n-\t  ip->step_exp =\n-\t    convert (max_prec_type, ip->step_exp);\n-\n-\t  if (TREE_CODE (ip->step_exp) != INTEGER_CST)\n-\t    {\n-\t      /* generate runtime check for negative BY expr */\n-\t      ip->step_exp = \n-\t\tcheck_range (ip->step_exp, ip->step_exp,\n-\t\t\t     integer_zero_node, NULL_TREE);\n-\t    }\n-\t  else if (compare_int_csts (LE_EXPR, ip->step_exp, integer_zero_node))\n-\t    {\n-\t      error (\"BY expression is negative or zero\");\n-\t      return;\n-\t    }\n-\t}\n-      ip->itype = DO_STEP;\n-    }\n-\n-  ip->error_flag = 0;           /* no errors! */\n-}\n-\f\n-void\n-build_loop_start (while_control, start_label)\n-     tree while_control, start_label;\n-{\n-  ITERATOR *firstp = loop_stack->iter_list;\n-  \n-  firstp->condition = while_control;\n-\n-  if (firstp->error_flag)\n-    return;\n-\n-  /* We didn't know at begin_loop_scope time about the condition;\n-     adjust iterator type now. */\n-  if (firstp->itype == DO_OD && firstp->condition)\n-    firstp->itype = DO_WHILE;\n-\n-  if (initialize_iter_var ())\n-    return;\n-  \n-  if (maybe_skip_loop ())\n-    return;\n-\n-  /* use the label as an 'exit' label, \n-     'goto' needs another sort of label */\n-  expand_start_loop (start_label != NULL_TREE);\n-  \n-  if (top_loop_end_check ())\n-    return;\n-  emit_line_note (input_filename, lineno); \n-}\n-\f\n-/*\n- * Called after the last action of the loop body\n- * has been parsed.\n- */\n-void\n-build_loop_end ()\n-{\n-  ITERATOR *ip = loop_stack->iter_list;\n-\n-  emit_line_note (input_filename, lineno);\n-\n-  if (ip->error_flag)\n-    return;\n-\n-  if (bottom_loop_end_check ())\n-    return;\n-\n-  if (increment_temps ())\n-    return;\n-\n-  if (ip->itype != DO_OD)\n-    {\n-      expand_end_loop ();\n-\n-      for (; ip != NULL; ip = ip->next)\n-\t{\n-\t  switch (ip->itype)\n-\t    {\n-\t    case DO_LOC_VARYING:\n-\t    case DO_STEP:\n-\t      expand_end_cond ();\n-\t      break;\n-\t    default:\n-\t      break;\n-\t    }\n-\t}\n-    }\n-}\n-\f\n-/*\n- * The rest of the routines in this file are called from\n- * the above three routines.\n- */\n-static int\n-classify_loop ()\n-{\n-  ITERATOR *firstp = loop_stack->iter_list, *ip;\n-\n-  firstp->error_flag = 0;\n-  if (firstp->itype == DO_UNUSED || firstp->itype == DO_OD)\n-    {\n-      /* if we have just DO .. OD, do nothing - this is just a \n-         BEGIN .. END without creating a new scope, and no looping  */\n-      if (firstp->condition != NULL_TREE)\n-\tfirstp->itype = DO_WHILE;\n-      else\n-\tfirstp->itype = DO_OD;\n-    }\n-  \n-  /* Issue a warning if the any loop counter is mentioned more \n-     than once in the iterator list. */\n-  for (ip = firstp; ip != NULL; ip = ip->next)\n-    {\n-      switch (ip->itype)\n-\t{\n-\tcase DO_FOREVER:\n-\tcase DO_WHILE:\n-\t  break;\n-\tcase DO_STEP:\n-\tcase DO_RANGE:\n-\tcase DO_POWERSET:\n-\tcase DO_LOC:\n-\tcase DO_LOC_VARYING:\n-\t  /* FIXME: check for name uniqueness */\n-\t  break;\n-\tdefault:\n-\t  ;\n-\t}\n-    }\n-  return firstp->error_flag;\n-}\n-\f\n-/*\n- * Reserve space for any loop-control temporaries, initialize them\n- */\n-static int\n-declare_temps ()\n-{\n-  ITERATOR *firstp = loop_stack->iter_list, *ip;\n-  tree start_ptr;\n-\n-  for (ip = firstp; ip != NULL; ip = ip->next)\n-    {\n-      switch (ip->itype)\n-\t{\n-\tcase DO_FOREVER:\n-\tcase DO_WHILE:\n-\t  break;\n-\tcase DO_STEP:\n-\t  ip->iter_type = chill_unsigned_type (TREE_TYPE (ip->start_exp));\n-\n-\t  /* create, initialize temporaries if expressions aren't constant */\n-\t  ip->start_temp = maybe_make_for_temp (ip->start_exp, \"for_start\",\n-\t\t\t\t\t\tip->iter_type);\n-\t  ip->end_temp = maybe_make_for_temp (ip->end_exp, \"for_end\",\n-\t\t\t\t\t      ip->iter_type);\n-\t  /* this is just the step-expression */\n-\t  ip->step_temp    = maybe_make_for_temp (ip->step_exp, \"for_step\",\n-\t\t\t\t\t\t  ip->iter_type);\n-\t  goto do_step_range;\n-\t  \n-\tcase DO_RANGE:\n-\t  ip->iter_type = chill_unsigned_type_node;\n-\t  \n-\t  ip->start_temp =\n-\t    (ip->down_flag ? build_chill_upper : build_chill_lower)(TREE_TYPE (ip->start_exp));\n-\t  ip->end_temp =\n-\t    (ip->down_flag ? build_chill_lower : build_chill_upper)(TREE_TYPE (ip->start_exp));\n-\t  \n-\t  ip->step_temp = integer_one_node;\n-\t  \n-\tdo_step_range:\n-\t  if (flag_local_loop_counter)\n-\t    {\n-\t      /* (re-)declare the user's iteration variable in the \n-\t\t loop's scope. */\n-\t      tree id_node = ip->user_var;\n-\t      IDENTIFIER_LOCAL_VALUE (id_node) = ip->user_var = \n-\t\tdecl_temp1 (id_node, ip->iter_type, 0, NULL_TREE,\n-\t\t\t    0, 0);\n-\t    }\n-\t  else\n-\t    {\n-\t      /* in this case, it's a previously-declared \n-\t\t VAR_DECL node, checked in build_loop_iterator. */\n-\t      if (TREE_CODE (ip->user_var) == IDENTIFIER_NODE)\n-\t\tip->user_var = lookup_name (ip->user_var);\n-\t      if (ip->user_var == NULL_TREE)\n-\t\t{\n-\t\t  error (\"loop identifier undeclared\");\n-\t\t  ip->error_flag = 1;\n-\t\t  return 1;\n-\t\t}\n-\t    }\n-\t  ip->iter_var = \n-\t    decl_temp1 (get_unique_identifier (\"iter_var\"),\n-\t\t\tip->iter_type, 0, NULL_TREE, 0, 0);\n-\t  break;\n-\n-\tcase DO_POWERSET:\n-\t  ip->iter_type = chill_unsigned_type (\n-\t\t\t    TYPE_DOMAIN (TREE_TYPE (ip->start_exp)));\n-\t  if (flag_local_loop_counter)\n-\t    {\n-\t      /* declare the user's iteration variable in the loop's scope. */\n-\t      /* in this case, it's just an IDENTIFIER_NODE */\n-\t      ip->user_var = \n-\t\tdecl_temp1 (ip->user_var, ip->iter_type, 0, NULL_TREE, 0, 0);\n-\t    }\n-\t  else\n-\t    {\n-\t      /* in this case, it's a previously-declared VAR_DECL node */\n-\t      ip->user_var = lookup_name (ip->user_var);\n-\t    }\n-\t  /* the user's powerset-expression, evaluated and saved in a temp */\n-\t  ip->powerset_temp = maybe_make_for_temp (ip->start_exp, \"for_set\",\n-\t\t\t\t\t\t TREE_TYPE (ip->start_exp));\n-\t  mark_addressable (ip->powerset_temp);\n-\t  break;\n-\n-\tcase DO_LOC:\n-\tcase DO_LOC_VARYING:\n-\t  ip->iter_type = chill_unsigned_type_node;\n-\t  /* create the counter temp */\n-\t  ip->iter_var = \n-\t    build_temporary_variable (\"iter_var\", ip->iter_type);\n-\n-\t  if (!CH_LOCATION_P (ip->start_exp))\n-\t    ip->start_exp\n-\t      = decl_temp1 (get_unique_identifier (\"iter_loc\"),\n-\t\t\t    TREE_TYPE (ip->start_exp), 0,\n-\t\t\t    ip->start_exp, 0, 0);\n-\n-\t  if (ip->itype == DO_LOC)\n-\t    {\n-\t      tree array_type = TREE_TYPE (ip->start_exp);\n-\t      tree ptr_type;\n-\t      tree temp;\n-\t      \n-\t      if (TREE_CODE (TREE_TYPE (array_type)) == BOOLEAN_TYPE)\n-\t\t{\n-\t\t  error (\"can't iterate through array of BOOL\");\n-\t\t  ip->error_flag = 1;\n-\t\t  return ip->error_flag;\n-\t\t}\n-\t      \n-\t      /* FIXME: check for array type in ip->start_exp */\n-\n-\t      /* create pointer temporary */\n-\t      ip->base_type = TREE_TYPE (array_type);\n-\t      ptr_type = build_pointer_type (ip->base_type);\n-\t      ip->loc_ptr_temp =\n-\t\tbuild_temporary_variable (\"loc_ptr_tmp\", ptr_type);\n-\t      \n-\t      /* declare the user's iteration variable in \n-\t\t the loop's scope, as an expression, to be\n-\t\t passed to build_component_ref later */\n-\t      save_expr_under_name (ip->user_var, \n-\t\tbuild1 (INDIRECT_REF, ip->base_type, \n-\t\t\tip->loc_ptr_temp));\n-\t      \n-\t      /* FIXME: see stor_layout */\n-\t      ip->step_temp = size_in_bytes (ip->base_type);\n-\t      \n-\t      temp = TYPE_DOMAIN (array_type);\n-\n-\t      /* pointer to first array entry to look at */\n-\t      start_ptr = build1 (ADDR_EXPR, ptr_type, ip->start_exp);\n-\t      mark_addressable (ip->start_exp);\n-\t      ip->start_temp = ip->down_flag ? \n-\t\tfold (build (PLUS_EXPR, ptr_type, \n-\t\t\t     start_ptr,\n-\t\t  fold (build (MULT_EXPR, integer_type_node, ip->step_temp,\n-\t\t    fold (build (MINUS_EXPR, integer_type_node,\n-\t\t\t\t TYPE_MAX_VALUE (temp),\n-\t\t\t\t TYPE_MIN_VALUE (temp)))))))\n-\t\t  : start_ptr;\n-\t    }\n-\t  else\n-\t    {\n-\t      tree array_length =\n-\t\tconvert (integer_type_node,\n-\t\t  build_component_ref (ip->start_exp, var_length_id));\n-\t      tree array_type = TREE_TYPE (TREE_CHAIN (\n-\t\t\tTYPE_FIELDS (TREE_TYPE (ip->start_exp))));\n-\t      tree array_data_ptr = \n-\t\tbuild_component_ref (ip->start_exp, var_data_id);\n-\t      tree ptr_type;\n-\t      \n-\t      if (TREE_CODE (TREE_TYPE (array_type)) == BOOLEAN_TYPE)\n-\t\t{\n-\t\t  error (\"Can't iterate through array of BOOL\");\n-\t\t  firstp->error_flag = 1;\n-\t\t  return firstp->error_flag;\n-\t\t}\n-\t      \n-\t      /* create pointer temporary */\n-\t      ip->base_type = TREE_TYPE (array_type);\n-\t      ptr_type = build_pointer_type (ip->base_type);\n-\t      ip->loc_ptr_temp = \n-\t\tbuild_temporary_variable (\"loc_ptr_temp\", ptr_type);\n-\t\t\t\t\t\t\t   \n-\t      \n-\t      /* declare the user's iteration variable in \n-\t\t the loop's scope, as an expression, to be\n-\t\t passed to build_component_ref later */\n-\t      save_expr_under_name (ip->user_var, \n-\t\tbuild1 (INDIRECT_REF, ip->base_type, \n-\t\t\tip->loc_ptr_temp));\n-\t      \n-\t      /* FIXME: see stor_layout */\n-\t      ip->step_temp = size_in_bytes (ip->base_type);\n-\t      \n-\t      /* pointer to first array entry to look at */\n-\t      start_ptr = build1 (ADDR_EXPR, ptr_type, array_data_ptr);\n-\t      mark_addressable (array_data_ptr);\n-\t      ip->start_temp = ip->down_flag ? \n-\t\tfold (build (PLUS_EXPR, ptr_type, \n-                  start_ptr,\n-\t\t    fold (build (MULT_EXPR, integer_type_node, ip->step_temp,\n-\t\t      fold (build (MINUS_EXPR, integer_type_node,\n-\t\t\t\t   array_length,\n-\t\t\t\t   integer_one_node))))))\n-\t\t  : start_ptr;\n-\t    }\n-\tdefault:\n-\t  ;\n-\t}\n-    }\n-  return firstp->error_flag;\n-}\n-\f\n-/*\n- * Initialize the hidden iteration-control variables,\n- * and the user's explicit loop variable.\n- */\n-static int\n-initialize_iter_var ()\n-{\n-  ITERATOR *firstp = loop_stack->iter_list, *ip;\n-\n-  for (ip = firstp; ip != NULL; ip = ip->next)\n-    {\n-      switch (ip->itype)\n-\t{\n-\tcase DO_FOREVER:\n-\tcase DO_WHILE:\n-\t  break;\n-\tcase DO_STEP:\n-\tcase DO_RANGE:\n-\t  {\n-\t    tree count =\n-\t      fold (build (PLUS_EXPR, ip->iter_type, integer_one_node,\n-\t\t  fold (build (TRUNC_DIV_EXPR, ip->iter_type, \n-\t\t    convert (ip->iter_type,\n-\t              fold (build (MINUS_EXPR, ip->iter_type,\n-\t\t\tip->down_flag ? ip->start_temp : ip->end_temp,\n-\t\t\tip->down_flag ? ip->end_temp   : ip->start_temp))),\n-\t\t\t       ip->step_temp))));\n-\t    /* initialize the loop's hidden counter variable */\n-\t    expand_expr_stmt (\n-\t      build_chill_modify_expr (ip->iter_var, count));\n-\n-\t    /* initialize user's variable */\n-\t    expand_expr_stmt (\n-\t      build_chill_modify_expr (ip->user_var, ip->start_temp));\n-\t  }\n-\t  break;\n-\tcase DO_POWERSET:\n-\t  break;\n-\tcase DO_LOC:\n-\t  {\n-\t    tree array_type = TREE_TYPE (ip->start_exp);\n-\t    tree array_length =\n-\t      fold (build (TRUNC_DIV_EXPR, integer_type_node,\n-\t\t\t   size_in_bytes (array_type),\n-\t\t\t   size_in_bytes (TREE_TYPE (array_type))));\n-\n-\t    expand_expr_stmt (\n-\t      build_chill_modify_expr (ip->iter_var, array_length));\n-\t    goto do_loc_common;\n-\t  }\n-\n-\tcase DO_LOC_VARYING:\n-\t  expand_expr_stmt (\n-\t    build_chill_modify_expr (ip->iter_var,\n-\t      convert (integer_type_node,\n-\t\tbuild_component_ref (ip->start_exp, var_length_id))));\n-\n-\tdo_loc_common:\n-\t  expand_expr_stmt (\n-\t    build_chill_modify_expr (ip->loc_ptr_temp, \n-\t\t\t\t     ip->start_temp));\n-\t  break;\n-\n-\tdefault:\n-\t  ;\n-\t}\n-    }\n-  return firstp->error_flag;\n-}\n-\f\n-/* Generate code to skip the whole loop, if start expression not\n- * <= end expression (or >= for DOWN loops).  This comparison must\n- * *NOT* be done in unsigned mode, or it will fail.\n- *  Also, skip processing an empty VARYING array. \n- */\n-static int\n-maybe_skip_loop ()\n-{\n-  ITERATOR *firstp = loop_stack->iter_list, *ip;\n-\n-  for (ip = firstp; ip != NULL; ip = ip->next)\n-    {\n-      switch (ip->itype)\n-\t{\n-\tcase DO_STEP:\n-\t  expand_start_cond (\n-\t    build (ip->down_flag ? GE_EXPR : LE_EXPR, \n-\t\t   TREE_TYPE (ip->start_exp),\n-\t\t   ip->start_exp, ip->end_exp), 0);\n-\t  break;\n-    \n-\tcase DO_LOC_VARYING:\n-\t  { tree array_length =\n-\t      convert (integer_type_node,\n-\t        build_component_ref (ip->start_exp, var_length_id));\n-\t    expand_start_cond (\n-\t      build (NE_EXPR, TREE_TYPE (array_length),\n-\t\t     array_length, integer_zero_node), 0);\n-\t    break;\n-\t  }\n-\tdefault:\n-\t  break;\n-\t}\n-    }\n-  return 0;\n-}  \n-\f\n-/*\n- * Check at the top of the loop for a termination\n- */\n-static int\n-top_loop_end_check ()\n-{\n-  ITERATOR *firstp = loop_stack->iter_list, *ip;\n-\n-  /* now, exit the loop if the condition isn't TRUE. */\n-  if (firstp->condition)\n-    {\n-      expand_exit_loop_if_false (0,\n-\tchill_truthvalue_conversion (firstp->condition));\n-    }\n-\n-  for (ip = firstp; ip != NULL; ip = ip->next)\n-    {\n-      switch (ip->itype)\n-\t{\n-\tcase DO_FOREVER:\n-\tcase DO_WHILE:\n-\tcase DO_STEP:\n-\tcase DO_RANGE:\n-\t  break;\n-\tcase DO_POWERSET:\n-\t  {\n-\t    tree temp1;\n-\t    char *func_name;\n-\n-\t    if (ip->down_flag)\n-\t      func_name = \"__flsetclrpowerset\";\n-\t    else\n-\t      func_name = \"__ffsetclrpowerset\";\n-\t    \n-\t    temp1 = TYPE_MIN_VALUE\n-\t      (TYPE_DOMAIN (TREE_TYPE (ip->powerset_temp)));\n-\t    expand_exit_loop_if_false (0,\n-\t      build_chill_function_call (lookup_name (get_identifier (func_name)),\n-\t        tree_cons (NULL_TREE, force_addr_of (ip->powerset_temp),\n-                  tree_cons (NULL_TREE, powersetlen (ip->powerset_temp),\n-\t            tree_cons (NULL_TREE, force_addr_of (ip->user_var),\n-                      tree_cons (NULL_TREE, size_in_bytes (TREE_TYPE (ip->user_var)),\n-\t\t        tree_cons (NULL_TREE,\n-\t\t\t\t   convert (long_integer_type_node, temp1),\n-\t\t\t\t   NULL_TREE)))))));\n-\t  }\n-\t  break;\n-\tcase DO_LOC:\n-\tcase DO_LOC_VARYING:\n-\t  break;\n-\tdefault:\n-\t  ;\n-\t}\n-    }\n-  return firstp->error_flag;\n-}\n-\f\n-/*\n- * Check generated temporaries for loop's end\n- */\n-static int\n-bottom_loop_end_check ()\n-{\n-  ITERATOR *firstp = loop_stack->iter_list, *ip;\n-\n-  emit_line_note (input_filename, lineno);\n-\n-  /* now, generate code to check each loop counter for termination */\n-  for (ip = firstp; ip != NULL; ip = ip->next)\n-    {\n-      switch (ip->itype)\n-\t{\n-\tcase DO_FOREVER:\n-\tcase DO_WHILE:\n-\t  break;\n-\tcase DO_STEP:\n-\tcase DO_RANGE:\n-\tcase DO_LOC:\n-\tcase DO_LOC_VARYING:\n-\t  /* decrement iteration counter by one */\n-\t  chill_expand_assignment (ip->iter_var, MINUS_EXPR, integer_one_node);\n-\t  /* exit if it's zero */\n-\t  expand_exit_loop_if_false (0,\n-\t    build (NE_EXPR, boolean_type_node, \n-\t\t   ip->iter_var,\n-\t\t   integer_zero_node));\n-\t  break;\n-\tcase DO_POWERSET:\n-\t  break;\n-\tdefault:\n-\t  ;\n-\t}\n-    }\n-\n-  return firstp->error_flag;\n-}\n-\f\n-/*\n- * increment the loop-control variables.\n- */\n-static int\n-increment_temps ()\n-{\n-  ITERATOR *firstp = loop_stack->iter_list, *ip;\n-\n-  for (ip  = firstp; ip != NULL; ip = ip->next)\n-    {\n-      switch (ip->itype)\n-\t{\n-\tcase DO_FOREVER:\n-\tcase DO_WHILE:\n-\t  break;\n-\tcase DO_STEP:\n-\tcase DO_RANGE:\n-\t  {\n-\t    tree delta =\n-\t      fold (build (ip->down_flag ? MINUS_EXPR : PLUS_EXPR,\n-\t\t\t   TREE_TYPE (ip->user_var), ip->user_var,\n-\t\t\t   ip->step_temp));\n- \t    expand_expr_stmt (\n-\t      build_chill_modify_expr (ip->user_var, delta));\n-\t  }\n-\t  break;\n-\tcase DO_LOC:\n-\tcase DO_LOC_VARYING:\n-\t  /* This statement uses the C semantics, so that \n-\t     the pointer is actually incremented by the \n-\t     length of the object pointed to. */\n-#if 1\n-\t  expand_expr_stmt (\n-\t    build_modify_expr (ip->loc_ptr_temp, \n-\t\t\t       ip->down_flag ? MINUS_EXPR : PLUS_EXPR,\n-\t\t\t       integer_one_node));\n-#else\n-\t  {\n-\t    enum tree_code op = ip->down_flag ? MINUS_EXPR : PLUS_EXPR;\n-\t    tree el_type = TREE_TYPE (TREE_TYPE (ip->loc_ptr_temp));\n-\t    chill_expand_assignment (ip->loc_ptr_temp, NOP_EXPR,\n-\t\t\t\t     build (op,\n-\t\t\t\t\t    TREE_TYPE (ip->loc_ptr_temp),\n-\t\t\t\t\t    ip->loc_ptr_temp,\n-\t\t\t\t\t    size_in_bytes (el_type)));\n-\t  }\n-#endif\n-\t  break;\n-\tcase DO_POWERSET:\n-\t  break;\n-\tdefault:\n-\t  ;\n-\t}\n-    }\n-  return firstp->error_flag;\n-}\n-\f\n-/*\n- * Generate a (temporary) unique identifier_node of\n- * the form \"__tmp_%s_%d\"\n- */\n-tree\n-get_unique_identifier (lead)\n-     char *lead;\n-{\n-  char idbuf [256];\n-  static int idcount = 0;\n-\n-  sprintf (idbuf, \"__tmp_%s_%d\", lead ? lead : \"\", idcount++);\n-  return get_identifier (idbuf);\n-}\n-\f\n-/*\n- * build a temporary variable, given its NAME and TYPE.\n- * The name will have a number appended to assure uniqueness.\n- * return its DECL node.\n- */\n-static tree\n-build_temporary_variable (name, type)\n-     char *name;\n-     tree type;\n-{\n-  return decl_temp1 (get_unique_identifier (name), type, 0, NULL_TREE, 0, 0);\n-}\n-\n-\n-/*\n- * If the given expression isn't a constant, build a temp for it\n- * and evaluate the expression into the temp.  Return the tree\n- * representing either the original constant expression or the\n- * temp which now contains the expression's value. \n- */\n-static tree\n-maybe_make_for_temp (exp, temp_name, exp_type)\n-     tree exp;\n-     char *temp_name;\n-     tree exp_type;\n-{\n-  tree result = exp;\n-\n-  if (exp != NULL_TREE)\n-    {\n-      /* if exp isn't constant, create a temporary for its value */\n-      if (TREE_CONSTANT (exp))\n-\t{\n-          /* FIXME: assure that TREE_TYPE (result) == ip->exp_type */\n-\t  result = convert (exp_type, exp);\n-\t}\n-      else {\n-\t/* build temp, assign the value */\n-\tresult = decl_temp1 (get_unique_identifier (temp_name), exp_type, 0,\n-\t\t\t     exp, 0, 0);\n-      }\n-    }\n-  return result;\n-}\n-\n-\n-/*\n- * Adapt the C unsigned_type function to CHILL - we need to\n- * account for any CHILL-specific integer types here.  So far,\n- * the 16-bit integer type is the only one.\n- */\n-static tree\n-chill_unsigned_type (type)\n-     tree type;\n-{\n-  extern tree chill_unsigned_type_node;\n-  tree type1 = TYPE_MAIN_VARIANT (type);\n-\n-  if (type1 == chill_integer_type_node)\n-    return chill_unsigned_type_node;\n-  else\n-    return unsigned_type (type);\n-}"}, {"sha": "f8e0e5481dfbc1e92c037f77762b6f6eec0b35c2", "filename": "gcc/ch/parse.c", "status": "removed", "additions": 0, "deletions": 4332, "changes": 4332, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41823c5eb7d4504b6a4a396ca0d64573238fbbcf/gcc%2Fch%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41823c5eb7d4504b6a4a396ca0d64573238fbbcf/gcc%2Fch%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fparse.c?ref=41823c5eb7d4504b6a4a396ca0d64573238fbbcf"}, {"sha": "142b33b3be618a2d49050bb7dfb2bd6d72a8b1e5", "filename": "gcc/ch/parse.h", "status": "removed", "additions": 0, "deletions": 70, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41823c5eb7d4504b6a4a396ca0d64573238fbbcf/gcc%2Fch%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41823c5eb7d4504b6a4a396ca0d64573238fbbcf/gcc%2Fch%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fparse.h?ref=41823c5eb7d4504b6a4a396ca0d64573238fbbcf", "patch": "@@ -1,70 +0,0 @@\n-typedef union {\n-  long itype;\n-  tree ttype;\n-  enum tree_code code;\n-  char *filename;\n-  int lineno;\n-} YYSTYPE;\n-extern YYSTYPE yylval;\n-\n-/* DELAY is defined in the standard headers on some platforms like\n-   SunOS 4.1.4.  */\n-#ifdef DELAY\n-#undef DELAY\n-#endif\n-\n-enum terminal\n-{\n-  /*EOF = 0,*/\n-  last_char_nonterminal = 256,\n-  /* Please keep these in alphabetic order, for easier reference and updating.\n-   */\n-  ABSOLUTE, ACCESS, AFTER, ALL, ALLOCATE, AND, ANDIF, ARRAY, \n-  ARROW, ASGN, ASM_KEYWORD, ASSERT, ASSOCIATION, AT,\n-  BASED, BEGINTOKEN, BIN, BIT, BITSTRING, BODY, BOOLS, BUFFER,\n-  BUFFERNAME, BUFFER_CODE, BY,\n-  CALL, CASE, CAUSE, CDDEL, CHAR, CHARS, COLON, COMMA, CONCAT, CONST,\n-  CONTINUE, CYCLE,\n-  DCL, DELAY, DIV, DO, DOT, DOWN, DYNAMIC, \n-  ELSE, ELSIF, END, ENTRY, EQL, ESAC, EVENT, EVENT_CODE, EVER,\n-  EXCEPTIONS, EXIT,\n-  EXPR, /* an expression that has been pushed back */\n-  FI, FLOATING, FOR, FORBID,\n-  GENERAL, GOTO, GRANT, GT, GTE,\n-  HEADEREL,\n-  IF, IGNORED_DIRECTIVE, IN, INIT, INOUT, INLINE,\n-  LC, LOC, LPC, LPRN, LT, LTE,\n-  MOD, MODULE, MUL, \n-  NAME, NE, NEW, NEWMODE, NONREF, NOPACK, NOT, NUMBER,\n-  OD, OF, ON, OR, ORIF,\n-  PACK, PARAMATTR, PERVASIVE, PLUS, POS, POWERSET,\n-  PREFIXED, PRIORITY, PROC, PROCESS,\n-  RANGE, RC, READ, READTEXT, RECEIVE, RECURSIVE, REF, REGION, REM,\n-  RESULT, RETURN, RETURNS, ROUND, ROW, RPC, RPRN, RPRN_COLON,\n-  SAME, SC, SEIZE, SEND, SET, SHARED, SIGNAL, SIGNALNAME, SIMPLE,\n-  SINGLECHAR, SPEC, START, STATIC, STEP, STOP, STREAM, STRING, \n-  STRUCT, SUB, SYN, SYNMODE,\n-  TERMINATE, TEXT, THEN, THIS, TIMEOUT, TO, TRUNC, TYPENAME, \n-  UP, USAGE,\n-  VARYING, \n-  WHERE, WHILE, WITH,\n-  XOR,\n-\n-/* These tokens only used within ch-lex.l to process compiler directives */\n-  ALL_STATIC_OFF, ALL_STATIC_ON, EMPTY_OFF, EMPTY_ON,\n-  GRANT_FILE_SIZE, PROCESS_TYPE_TOKEN, RANGE_OFF, RANGE_ON,\n-  SEND_BUFFER_DEFAULT_PRIORITY, SEND_SIGNAL_DEFAULT_PRIORITY,\n-  SIGNAL_CODE, SIGNAL_MAX_LENGTH, USE_SEIZE_FILE, USE_SEIZE_FILE_RESTRICTED,\n-  USE_GRANT_FILE, \n-\n-  /* These tokens are recognized, and reported as errors, by the lexer. */\n-  CONTEXT, REMOTE,\n-\n-/* This token is passed back to the parser when an the main \n-   input file (not a seize file) has  reached end-of-file. */\n-  END_PASS_1,\n-\n-  EMPTY, UMINUS,\n-\n-  dummy_last_terminal\n-};"}, {"sha": "00d90f894c33db54ca0202e1e29e4bae95b2f9f5", "filename": "gcc/ch/satisfy.c", "status": "removed", "additions": 0, "deletions": 629, "changes": 629, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41823c5eb7d4504b6a4a396ca0d64573238fbbcf/gcc%2Fch%2Fsatisfy.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41823c5eb7d4504b6a4a396ca0d64573238fbbcf/gcc%2Fch%2Fsatisfy.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fsatisfy.c?ref=41823c5eb7d4504b6a4a396ca0d64573238fbbcf", "patch": "@@ -1,629 +0,0 @@\n-/* Name-satisfaction for GNU Chill compiler.\n-   Copyright (C) 1993, 1998, 1999, 2000 Free Software Foundation, Inc.\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"tree.h\"\n-#include \"flags.h\"\n-#include \"ch-tree.h\"\n-#include \"lex.h\"\n-#include \"toplev.h\"\n-\n-#define SATISFY(ARG) ((ARG) = satisfy(ARG, chain))\n-\n-struct decl_chain\n-{\n-  struct decl_chain *prev;\n-  /* DECL can be a decl, or a POINTER_TYPE or a REFERENCE_TYPE. */\n-  tree decl;\n-};\n-\n-/* forward declarations */\n-static tree satisfy\t\tPARAMS ((tree, struct decl_chain *));\n-static void cycle_error_print\tPARAMS ((struct decl_chain *, tree));\n-static tree safe_satisfy_decl\tPARAMS ((tree, struct decl_chain *));\n-static void satisfy_list\tPARAMS ((tree, struct decl_chain *));\n-static void satisfy_list_values\tPARAMS ((tree, struct decl_chain *));\n-\n-static struct decl_chain dummy_chain;\n-#define LOOKUP_ONLY (chain==&dummy_chain)\n-\n-/* Recursive helper routine to logically reverse the chain. */\n-static void\n-cycle_error_print (chain, decl)\n-     struct decl_chain *chain;\n-     tree decl;\n-{\n-  if (chain->decl != decl)\n-    {\n-      cycle_error_print (chain->prev, decl);\n-      if (TREE_CODE_CLASS (TREE_CODE (chain->decl)) == 'd')\n-\terror_with_decl (chain->decl, \"  `%s', which depends on ...\");\n-    }\n-}\n-\n-static tree\n-safe_satisfy_decl (decl, prev_chain)\n-     tree decl;\n-     struct decl_chain *prev_chain;\n-{\n-  struct decl_chain new_link;\n-  struct decl_chain *link;\n-  struct decl_chain *chain = prev_chain;\n-  const char *save_filename = input_filename;\n-  int save_lineno = lineno;\n-  tree result = decl;\n-  \n-  if (decl == NULL_TREE)\n-    return decl;\n-\n-  if (!LOOKUP_ONLY)\n-    {\n-      int pointer_type_breaks_cycle = 0;\n-      /* Look for a cycle.\n-\t We could do this test more efficiently by setting a flag.  FIXME */\n-      for (link = prev_chain; link != NULL; link = link->prev)\n-\t{\n-\t  if (TREE_CODE_CLASS (TREE_CODE (link->decl)) != 'd')\n-\t    pointer_type_breaks_cycle = 1;\n-\t  if (link->decl == decl)\n-\t    {\n-\t      if (!pointer_type_breaks_cycle)\n-\t\t{\n-\t\t  error_with_decl (decl, \"cycle: `%s' depends on ...\");\n-\t\t  cycle_error_print (prev_chain, decl);\n-\t\t  error_with_decl (decl, \"  `%s'\");\n-\t\t  return error_mark_node;\n-\t\t}\n-\t      /* There is a cycle, but it includes a pointer type,\n-\t\t so we're OK.  However, we still have to continue\n-\t\t the satisfy (for example in case this is a TYPE_DECL\n-\t\t that points to a LANG_DECL).  The cycle-check for\n-\t\t POINTER_TYPE/REFERENCE_TYPE should stop the recursion. */\n-\t      break;\n-\t    }\n-\t}\n-\n-      new_link.decl = decl;\n-      new_link.prev = prev_chain;\n-      chain = &new_link;\n-    }\n-\n-  input_filename = DECL_SOURCE_FILE (decl);\n-  lineno = DECL_SOURCE_LINE (decl);\n-\n-  switch ((enum chill_tree_code)TREE_CODE (decl))\n-    {\n-    case ALIAS_DECL:\n-      if (!LOOKUP_ONLY && !DECL_POSTFIX_ALL(decl))\n-\tresult = safe_satisfy_decl (DECL_ABSTRACT_ORIGIN (decl), chain);\n-      break;\n-    case BASED_DECL:\n-      SATISFY (TREE_TYPE (decl));\n-      SATISFY (DECL_ABSTRACT_ORIGIN (decl));\n-      break;\n-    case CONST_DECL:\n-      SATISFY (TREE_TYPE (decl));\n-      SATISFY (DECL_INITIAL (decl));\n-      if (!LOOKUP_ONLY)\n-\t{\n-\t  if (DECL_SIZE (decl) == 0)\n-\t    {\n-\t      tree init_expr = DECL_INITIAL (decl);\n-\t      tree init_type;\n-\t      tree specified_mode = TREE_TYPE (decl);\n-\n-\t      if (init_expr == NULL_TREE\n-\t\t  || TREE_CODE (init_expr) == ERROR_MARK)\n-\t\tgoto bad_const;\n-\t      init_type = TREE_TYPE (init_expr);\n-\t      if (specified_mode == NULL_TREE)\n-\t\t{\n-\t\t  if (init_type == NULL_TREE)\n-\t\t    {\n-\t\t      check_have_mode (init_expr, \"SYN without mode\");\n-\t\t      goto bad_const;\n-\t\t    }\n-\t\t  TREE_TYPE (decl) = init_type;\n-\t\t  CH_DERIVED_FLAG (decl) = CH_DERIVED_FLAG (init_expr);\n-\t\t}\n-\t      else if (CH_IS_ASSOCIATION_MODE (specified_mode) ||\n-\t\t       CH_IS_ACCESS_MODE (specified_mode) || CH_IS_TEXT_MODE (specified_mode) ||\n-\t\t       CH_IS_BUFFER_MODE (specified_mode) || CH_IS_EVENT_MODE (specified_mode))\n-\t\t{\n-\t\t  error (\"SYN of this mode not allowed\");\n-\t\t  goto bad_const;\n-\t\t}\n-\t      else if (!CH_COMPATIBLE (init_expr, specified_mode))\n-\t\t{\n-\t\t  error (\"mode of SYN incompatible with value\");\n-\t\t  goto bad_const;\n-\t\t} \n-\t      else if (discrete_type_p (specified_mode)\n-\t\t       && TREE_CODE (init_expr) == INTEGER_CST\n-\t\t       && (compare_int_csts (LT_EXPR, init_expr,\n-\t\t\t\t\t     TYPE_MIN_VALUE (specified_mode))\n-\t\t\t   || compare_int_csts (GT_EXPR, init_expr,\n-\t\t\t\t\t\tTYPE_MAX_VALUE(specified_mode))\n-\t\t\t   ))\n-\t\t{\n-\t\t  error (\"SYN value outside range of its mode\");\n-\t\t  /* set an always-valid initial value to prevent \n-\t\t     other errors. */\n-\t\t  DECL_INITIAL (decl) = TYPE_MIN_VALUE (specified_mode);\n-\t\t}\n-\t      else if (CH_STRING_TYPE_P (specified_mode) \n-\t\t       && (init_type && CH_STRING_TYPE_P (init_type))\n-\t\t       && integer_zerop (string_assignment_condition (specified_mode, init_expr)))\n-\t\t{\n-\t\t  error (\"INIT string too large for mode\");\n-\t\t  DECL_INITIAL (decl) = error_mark_node;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  struct ch_class class;\n-\t\t  class.mode = TREE_TYPE (decl);\n-\t\t  class.kind = CH_VALUE_CLASS;\n-\t\t  DECL_INITIAL (decl)\n-\t\t    = convert_to_class (class, DECL_INITIAL (decl));\n-\t\t}\n-\t      /* DECL_SIZE is set to prevent re-doing this stuff. */\n-\t      DECL_SIZE (decl) = TYPE_SIZE (TREE_TYPE (decl));\n-\t      DECL_SIZE_UNIT (decl) = TYPE_SIZE_UNIT (TREE_TYPE (decl));\n-\n-\t      if (! TREE_CONSTANT (DECL_INITIAL (decl))\n-\t\t  && TREE_CODE (DECL_INITIAL (decl)) != ERROR_MARK)\n-\t\t{\n-\t\t  error_with_decl (decl,\n-\t\t\t\t   \"value of %s is not a valid constant\");\n-\t\t  DECL_INITIAL (decl) = error_mark_node;\n-\t\t}\n-\t    }\n-\t  result = DECL_INITIAL (decl);\n-\t}\n-      break;\n-    bad_const:\n-      DECL_INITIAL (decl) = error_mark_node;\n-      TREE_TYPE (decl) = error_mark_node;\n-      return error_mark_node;\n-    case FUNCTION_DECL:\n-      SATISFY (TREE_TYPE (decl));\n-      if (CH_DECL_PROCESS (decl))\n-\tsafe_satisfy_decl ((tree) DECL_TASKING_CODE_DECL (decl), prev_chain);\n-      break;\n-    case PARM_DECL:\n-      SATISFY (TREE_TYPE (decl));\n-      break;\n-    /* RESULT_DECL doesn't need to be satisfied;  \n-       it's only built internally in pass 2 */\n-    case TYPE_DECL:\n-      SATISFY (TREE_TYPE (decl));\n-      if (CH_DECL_SIGNAL (decl))\n-\tsafe_satisfy_decl ((tree) DECL_TASKING_CODE_DECL (decl), prev_chain);\n-      if (!LOOKUP_ONLY)\n-\t{\n-\t  if (TYPE_NAME (TREE_TYPE (decl)) == NULL_TREE)\n-\t    TYPE_NAME (TREE_TYPE (decl)) = decl;\n-\t  layout_decl (decl, 0);\n-\t  if (CH_DECL_SIGNAL (decl) && CH_TYPE_NONVALUE_P (TREE_TYPE (decl)))\n-\t    error (\"mode with non-value property in signal definition\");\n-\t  result = TREE_TYPE (decl);\n-\t}\n-      break;\n-    case VAR_DECL:\n-      SATISFY (TREE_TYPE (decl));\n-      if (!LOOKUP_ONLY)\n-\t{\n-\t  layout_decl (decl, 0);\n-\t  if (TREE_READONLY (TREE_TYPE (decl)))\n-\t    TREE_READONLY (decl) = 1;\n-\t}\n-      break;\n-    default:\n-      ;\n-    }\n-\n-  /* Now set the DECL_RTL, if needed. */\n-  if (!LOOKUP_ONLY && DECL_RTL (decl) == 0\n-      && (TREE_CODE (decl) == VAR_DECL || TREE_CODE (decl) == FUNCTION_DECL\n-\t  || TREE_CODE (decl) == CONST_DECL))\n-    {\n-      if (TREE_CODE (decl) == FUNCTION_DECL && decl_function_context (decl))\n-\tmake_function_rtl (decl);\n-      else if (!TREE_STATIC (decl) && !DECL_EXTERNAL (decl))\n-\texpand_decl (decl);\n-      else\n-\t{ char * asm_name;\n-\t  if (current_module == 0 || TREE_PUBLIC (decl)\n-\t      || current_function_decl)\n-\t    asm_name = NULL;\n-\t  else\n-\t    {\n-\t      asm_name = (char*)\n-\t\talloca (IDENTIFIER_LENGTH (current_module->prefix_name)\n-\t\t\t+ IDENTIFIER_LENGTH (DECL_NAME (decl)) + 3);\n-\t      sprintf (asm_name, \"%s__%s\",\n-\t\t       IDENTIFIER_POINTER (current_module->prefix_name),\n-\t\t       IDENTIFIER_POINTER (DECL_NAME (decl)));\n-\t    }\n-\t  make_decl_rtl (decl, asm_name, TREE_PUBLIC (decl));\n-\t}\n-    }\n-\n-  input_filename = save_filename;\n-  lineno = save_lineno;\n-\n-  return result;\n-}\n-\n-tree\n-satisfy_decl (decl, lookup_only)\n-     tree decl;\n-     int lookup_only;\n-{\n-  return safe_satisfy_decl (decl, lookup_only ? &dummy_chain : NULL);\n-}\n-\n-static void\n-satisfy_list (exp, chain)\n-     register tree exp;\n-     struct decl_chain *chain;\n-{\n-  for (; exp != NULL_TREE; exp = TREE_CHAIN (exp))\n-    {\n-      SATISFY (TREE_VALUE (exp));\n-      SATISFY (TREE_PURPOSE (exp));\n-    }\n-}\n-\n-static void\n-satisfy_list_values (exp, chain)\n-     register tree exp;\n-     struct decl_chain *chain;\n-{\n-  for (; exp != NULL_TREE; exp = TREE_CHAIN (exp))\n-    {\n-      SATISFY (TREE_VALUE (exp));\n-    }\n-}\n-\n-static tree\n-satisfy (exp, chain)\n-     tree exp;\n-     struct decl_chain *chain;\n-{\n-  int arg_length;\n-  int i;\n-  tree decl;\n-\n-  if (exp == NULL_TREE)\n-    return NULL_TREE;\n-\n-#if 0\n-  if (!UNSATISFIED (exp))\n-    return exp;\n-#endif\n-\n-  switch (TREE_CODE_CLASS (TREE_CODE (exp)))\n-    {\n-    case 'd':\n-      if (!LOOKUP_ONLY)\n-\treturn safe_satisfy_decl (exp, chain);\n-      break;\n-    case 'r':\n-    case 's':\n-    case '<':\n-    case 'e':\n-      switch ((enum chill_tree_code)TREE_CODE (exp))\n-\t{\n-\tcase REPLICATE_EXPR:\n-\t  goto binary_op;\n-\tcase TRUTH_NOT_EXPR:\n-\t  goto unary_op;\n-\tcase COMPONENT_REF:\n-\t  SATISFY (TREE_OPERAND (exp, 0));\n-\t  if (!LOOKUP_ONLY && TREE_TYPE (exp) == NULL_TREE)\n-\t    return resolve_component_ref (exp);\n-\t  return exp;\n-\tcase CALL_EXPR:\n-\t  SATISFY (TREE_OPERAND (exp, 0));\n-\t  SATISFY (TREE_OPERAND (exp, 1));\n-\t  if (!LOOKUP_ONLY && TREE_TYPE (exp) == NULL_TREE)\n-\t    return build_generalized_call (TREE_OPERAND (exp, 0),\n-\t\t\t\t\t   TREE_OPERAND (exp, 1));\n-\t  return exp;\n-\tcase CONSTRUCTOR:\n-\t  { tree link = TREE_OPERAND (exp, 1);\n-\t    int expand_needed = TREE_TYPE (exp)\n-\t      && TREE_CODE_CLASS (TREE_CODE (TREE_TYPE (exp))) != 't';\n-\t    for (; link != NULL_TREE; link = TREE_CHAIN (link))\n-\t      {\n-\t\tSATISFY (TREE_VALUE (link));\n-\t\tif (!TUPLE_NAMED_FIELD (link))\n-\t\t  SATISFY (TREE_PURPOSE (link));\n-\t      }\n-\t    SATISFY (TREE_TYPE (exp));\n-\t    if (expand_needed && !LOOKUP_ONLY)\n-\t      {\n-\t\ttree type = TREE_TYPE (exp);\n-\t\tTREE_TYPE (exp) = NULL_TREE; /* To force expansion. */\n-\t\treturn chill_expand_tuple (type, exp);\n-\t      }\n-\t    return exp;\n-\t  }\n-\tdefault:\n-\t  ;\n-\t}\n-\n-      arg_length = TREE_CODE_LENGTH (TREE_CODE (exp));\n-      for (i = 0; i < arg_length; i++)\n-\tSATISFY (TREE_OPERAND (exp, i));\n-      return exp;\n-    case '1':\n-    unary_op:\n-      SATISFY (TREE_OPERAND (exp, 0));\n-      if ((enum chill_tree_code)TREE_CODE (exp) == PAREN_EXPR)\n-\treturn TREE_OPERAND (exp, 0);\n-      if (!LOOKUP_ONLY)\n-\treturn finish_chill_unary_op (exp);\n-      break;\n-    case '2':\n-    binary_op:\n-      SATISFY (TREE_OPERAND (exp, 0));\n-      SATISFY (TREE_OPERAND (exp, 1));\n-      if (!LOOKUP_ONLY && TREE_CODE (exp) != RANGE_EXPR)\n-\treturn finish_chill_binary_op (exp);\n-      break;\n-    case 'x':\n-      switch ((enum chill_tree_code)TREE_CODE (exp))\n-\t{\n-\tcase IDENTIFIER_NODE:\n-\t  decl = lookup_name (exp);\n-\t  if (decl == NULL)\n-\t    {\n-\t      if (LOOKUP_ONLY)\n-\t\treturn exp;\n-\t      error (\"undeclared identifier `%s'\", IDENTIFIER_POINTER (exp));\n-\t      return error_mark_node;\n-\t    }\n-\t  if (LOOKUP_ONLY)\n-\t    return decl;\n-\t  return safe_satisfy_decl (decl, chain);\n-\tcase TREE_LIST:\n-\t  satisfy_list (exp, chain);\n-\t  break;\n-\tdefault:\n-\t  ;\n-\t}\n-      break;\n-    case 't':\n-      /* If TYPE_SIZE is non-NULL, exp and its subfields has already been\n-\t satified and laid out.  The exception is pointer and reference types,\n-\t which we layout before we lay out their TREE_TYPE. */\n-      if (TYPE_SIZE (exp) && TREE_CODE (exp) != POINTER_TYPE\n-\t  && TREE_CODE (exp) != REFERENCE_TYPE)\n-\treturn exp;\n-      if (TYPE_MAIN_VARIANT (exp) != exp)\n-\tSATISFY (TYPE_MAIN_VARIANT (exp));\n-      switch ((enum chill_tree_code)TREE_CODE (exp))\n-\t{\n-\tcase LANG_TYPE:\n-\t  {\n-\t    tree d = TYPE_DOMAIN (exp);\n-\t    tree t = satisfy (TREE_TYPE (exp), chain);\n-\t    SATISFY (d);\n-\t    /* It is possible that one of the above satisfy calls recursively\n-\t       caused exp to be satisfied, in which case we're done. */\n-\t    if (TREE_CODE (exp) != LANG_TYPE)\n-\t      return exp;\n-\t    TREE_TYPE (exp) = t;\n-\t    TYPE_DOMAIN (exp) = d;\n-\t    if (!LOOKUP_ONLY)\n-\t      exp = smash_dummy_type (exp);\n-\t  }\n-\t  break;\n-\tcase ARRAY_TYPE:\n-\t  SATISFY (TREE_TYPE (exp));\n-\t  SATISFY (TYPE_DOMAIN (exp));\n-\t  SATISFY (TYPE_ATTRIBUTES (exp));\n-\t  if (!LOOKUP_ONLY)\n-\t    CH_TYPE_NONVALUE_P (exp) = CH_TYPE_NONVALUE_P (TREE_TYPE (exp));\n-\t  if (!TYPE_SIZE (exp)  && !LOOKUP_ONLY)\n-\t    exp = layout_chill_array_type (exp);\n-\t  break;\n-\tcase FUNCTION_TYPE:\n-\t  SATISFY (TREE_TYPE (exp));\n-\t  if (TREE_CODE_CLASS (TREE_CODE (TREE_TYPE (exp))) != 't'\n-\t      && !LOOKUP_ONLY && TREE_CODE (TREE_TYPE (exp)) != ERROR_MARK)\n-\t    {\n-\t      error (\"RETURNS spec with invalid mode\");\n-\t      TREE_TYPE (exp) = error_mark_node;\n-\t    }\n-\t  satisfy_list_values (TYPE_ARG_TYPES (exp), chain);\n-\t  if (!TYPE_SIZE (exp)  && !LOOKUP_ONLY)\n-\t    layout_type (exp);\n-\t  break;\n-\tcase ENUMERAL_TYPE:\n-\t  if (TYPE_SIZE (exp) == NULL_TREE && !LOOKUP_ONLY)\n-\t    { tree pair;\n-\t      /* FIXME:  Should this use satisfy_decl? */\n-\t      for (pair = TYPE_VALUES (exp); pair; pair = TREE_CHAIN (pair))\n-\t\tSATISFY (DECL_INITIAL (TREE_VALUE (pair)));\n-\t      layout_enum (exp);\n-\t    }\n-\t  break;\n-\tcase INTEGER_TYPE:\n-\t  SATISFY (TYPE_MIN_VALUE (exp));\n-\t  SATISFY (TYPE_MAX_VALUE (exp));\n-\t  if (TREE_TYPE (exp) != NULL_TREE)\n-\t    { /* A range type */\n-\t      if (TREE_TYPE (exp) != ridpointers[(int) RID_RANGE]\n-\t\t  && TREE_TYPE (exp) != ridpointers[(int) RID_BIN]\n-\t\t  && TREE_TYPE (exp) != string_index_type_dummy)\n-\t\tSATISFY (TREE_TYPE (exp));\n-\t      if (!TYPE_SIZE (exp)  && !LOOKUP_ONLY)\n-\t\texp = layout_chill_range_type (exp, 1);\n-\t    }\n-\t  break;\n-\tcase POINTER_TYPE:\n-\tcase REFERENCE_TYPE:\n-\t  if (LOOKUP_ONLY)\n-\t    SATISFY (TREE_TYPE (exp));\n-\t  else\n-\t    {\n-\t      struct decl_chain *link;\n-\t      int already_seen = 0;\n-\t      for (link = chain; ; link = link->prev)\n-\t\t{\n-\t\t  if (link == NULL)\n-\t\t    {\t\n-\t\t      struct decl_chain new_link;\n-\t\t      new_link.decl = exp;\n-\t\t      new_link.prev = chain;\n-\t\t      TREE_TYPE (exp) = satisfy (TREE_TYPE (exp), &new_link);\n-\t\t      break;\n-\t\t    }\n-\t\t  else if (link->decl == exp)\n-\t\t    {\n-\t\t      already_seen = 1;\n-\t\t      break;\n-\t\t    }\n-\t\t}\n-\t      if (!TYPE_SIZE (exp))\n-\t\t{\n-\t\t  layout_type (exp);\n-\t\t  if (TREE_CODE (exp) == REFERENCE_TYPE)\n-\t\t    CH_NOVELTY (exp) = CH_NOVELTY (TREE_TYPE (exp));\n-\t\t  if (! already_seen)\n-\t\t    {\n-\t\t      tree valtype = TREE_TYPE (exp);\n-\t\t      if (TREE_CODE_CLASS (TREE_CODE (valtype)) != 't')\n-\t\t\t{\n-\t\t\t  if (TREE_CODE (valtype) != ERROR_MARK)\n-\t\t\t    error (\"operand to REF is not a mode\");\n-\t\t\t  TREE_TYPE (exp) = error_mark_node;\n-\t\t\t  return error_mark_node;\n-\t\t\t}\n-\t\t      else if (TREE_CODE (exp) == POINTER_TYPE\n-\t\t\t       && TYPE_POINTER_TO (valtype) == NULL)\n-\t\t\tTYPE_POINTER_TO (valtype) = exp;\n-\t\t    }\n-\t\t}\n-\t    }\n-\t  break;\n-\tcase RECORD_TYPE:\n-\t  {\n-\t    /* FIXME: detected errors in here will be printed as\n-\t       often as this sequence runs. Find another way or\n-\t       place to print the errors. */\n-\t    /* if we have an ACCESS or TEXT mode we have to set\n-\t       maximum_field_alignment to 0 to fit with runtime\n-\t       system, even when we compile with -fpack. */\n-\t    unsigned int save_maximum_field_alignment = maximum_field_alignment;\n-\n-\t    if (CH_IS_ACCESS_MODE (exp) || CH_IS_TEXT_MODE (exp))\n-\t      maximum_field_alignment = 0;\n-\n-\t    for (decl = TYPE_FIELDS (exp); decl; decl = TREE_CHAIN (decl))\n-\t      {\n-\t\tSATISFY (TREE_TYPE (decl));\n-\t\tif (!LOOKUP_ONLY)\n-\t\t  {\n-\t\t    /* if we have a UNION_TYPE here (variant structure), check for\n-\t\t       non-value mode in it. This is not allowed (Z.200/pg. 33) */\n-\t\t    if (TREE_CODE (TREE_TYPE (decl)) == UNION_TYPE &&\n-\t\t\tCH_TYPE_NONVALUE_P (TREE_TYPE (decl)))\n-\t\t      {\n-\t\t\terror (\"field with non-value mode in variant structure not allowed\");\n-\t\t\tTREE_TYPE (decl) = error_mark_node;\n-\t\t      }\n-\t\t    /* RECORD_TYPE gets the non-value property if one of the\n-\t\t       fields has the non-value property */\n-\t\t    CH_TYPE_NONVALUE_P (exp) |= CH_TYPE_NONVALUE_P (TREE_TYPE (decl));\n-\t\t  }\n-\t\tif (TREE_CODE (decl) == CONST_DECL)\n-\t\t  {\n-\t\t    SATISFY (DECL_INITIAL (decl));\n-\t\t    if (!LOOKUP_ONLY)\n-\t\t      {\n-\t\t\tif (CH_IS_BUFFER_MODE (exp) || CH_IS_EVENT_MODE (exp))\n-\t\t\t  DECL_INITIAL (decl)\n-\t\t\t    = check_queue_size (DECL_INITIAL (decl));\n-\t\t\telse if (CH_IS_TEXT_MODE (exp) &&\n-\t\t\t\t DECL_NAME (decl) == get_identifier (\"__textlength\"))\n-\t\t\t  DECL_INITIAL (decl)\n-\t\t\t    = check_text_length (DECL_INITIAL (decl));\n-\t\t      }\n-\t\t  }\n-\t\telse if (TREE_CODE (decl) == FIELD_DECL)\n-\t\t  {\n-\t\t    SATISFY (DECL_INITIAL (decl));\n-\t\t  }\n-\t      }\n-\t    satisfy_list (TYPE_TAG_VALUES (exp), chain);\n-\t    if (!TYPE_SIZE (exp)  && !LOOKUP_ONLY)\n-\t      exp = layout_chill_struct_type (exp);\n-\t    maximum_field_alignment = save_maximum_field_alignment;\n-\n-\t    /* perform some checks on nonvalue modes, they are record_mode's */\n-\t    if (!LOOKUP_ONLY)\n-\t      {\n-\t\tif (CH_IS_BUFFER_MODE (exp))\n-\t\t  {\n-\t\t    tree elemmode = buffer_element_mode (exp);\n-\t\t    if (elemmode != NULL_TREE && CH_TYPE_NONVALUE_P (elemmode))\n-\t\t      {\n-\t\t\terror (\"buffer element mode must not have non-value property\");\n-\t\t\tinvalidate_buffer_element_mode (exp);\n-\t\t      }\n-\t\t  }\n-\t\telse if (CH_IS_ACCESS_MODE (exp))\n-\t\t  {\n-\t\t    tree recordmode = access_recordmode (exp);\n-\t\t    if (recordmode != NULL_TREE && CH_TYPE_NONVALUE_P (recordmode))\n-\t\t      {\n-\t\t\terror (\"recordmode must not have the non-value property\");\n-\t\t\tinvalidate_access_recordmode (exp);\n-\t\t      }\n-\t\t  }\n-\t      }\n-\t  }\n-\t  break;\n-\tcase SET_TYPE:\n-\t  SATISFY (TYPE_DOMAIN (exp));\n-\t  if (!TYPE_SIZE (exp)  && !LOOKUP_ONLY)\n-\t    exp = layout_powerset_type (exp);\n-\t  break;\n-\tcase UNION_TYPE:\n-\t  for (decl = TYPE_FIELDS (exp); decl; decl = TREE_CHAIN (decl))\n-\t    {\n-\t      SATISFY (TREE_TYPE (decl));\n-\t      if (!LOOKUP_ONLY)\n-\t\tCH_TYPE_NONVALUE_P (exp) |= CH_TYPE_NONVALUE_P (TREE_TYPE (decl));\n-\t    }\n-\t  if (!TYPE_SIZE (exp)  && !LOOKUP_ONLY)\n-\t    exp = layout_chill_variants (exp);\n-\t  break;\n-\tdefault:\n-\t  ;\n-\t}\n-    }\n-  return exp;\n-}"}, {"sha": "d1b7905cbad5a194cae5f5826d72bbad3cf8cd0b", "filename": "gcc/ch/tasking.c", "status": "removed", "additions": 0, "deletions": 3431, "changes": 3431, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41823c5eb7d4504b6a4a396ca0d64573238fbbcf/gcc%2Fch%2Ftasking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41823c5eb7d4504b6a4a396ca0d64573238fbbcf/gcc%2Fch%2Ftasking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Ftasking.c?ref=41823c5eb7d4504b6a4a396ca0d64573238fbbcf"}, {"sha": "2a899fdfedb41cc50a7ece4b271a5bdc4082d6bc", "filename": "gcc/ch/tasking.h", "status": "removed", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41823c5eb7d4504b6a4a396ca0d64573238fbbcf/gcc%2Fch%2Ftasking.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41823c5eb7d4504b6a4a396ca0d64573238fbbcf/gcc%2Fch%2Ftasking.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Ftasking.h?ref=41823c5eb7d4504b6a4a396ca0d64573238fbbcf", "patch": "@@ -1,27 +0,0 @@\n-/* Implement process-related declarations for CHILL.\n-   Copyright (C) 1992, 1993, 1994 Free Software Foundation, Inc.\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-#ifndef GCC_TASKING_H\n-#define GCC_TASKING_H\n-\n-/* list of this module's process, buffer, etc. decls */\n-extern tree tasking_list;\n-\n-#endif /* ! GCC_TASKING_H */"}, {"sha": "432ded24ce2eb35eabca910cc306958081dc54b4", "filename": "gcc/ch/timing.c", "status": "removed", "additions": 0, "deletions": 491, "changes": 491, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41823c5eb7d4504b6a4a396ca0d64573238fbbcf/gcc%2Fch%2Ftiming.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41823c5eb7d4504b6a4a396ca0d64573238fbbcf/gcc%2Fch%2Ftiming.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Ftiming.c?ref=41823c5eb7d4504b6a4a396ca0d64573238fbbcf", "patch": "@@ -1,491 +0,0 @@\n-/* Implement timing-related actions for CHILL.\n-   Copyright (C) 1992, 1993, 1994, 1998, 2000, 2001\n-   Free Software Foundation, Inc.\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"tree.h\"\n-#include \"rtl.h\"\n-#include \"ch-tree.h\"\n-#include \"flags.h\"\n-#include \"input.h\"\n-#include \"obstack.h\"\n-#include \"lex.h\"\n-#include \"toplev.h\"\n-\n-/* set non-zero if input text is forced to lowercase */\n-extern int ignore_case;\n-\n-/* set non-zero if special words are to be entered in uppercase */\n-extern int special_UC;\n-\n-/* timing modes */\n-tree abs_timing_type_node;\n-tree duration_timing_type_node;\n-\n-/* rts time type */\n-static tree rtstime_type_node = NULL_TREE;\n-\n-/* the stack for AFTER primval [ DELAY ] IN \n-   and has following layout\n-\n-   TREE_VALUE (TREE_VALUE (after_stack)) = current time or NULL_TREE (if DELAY specified)\n-   TREE_PURPOSE (TREE_VALUE (after_stack)) = the duration location\n-   TREE_VALUE (TREE_PURPOSE (after_stack)) = label at TIMEOUT\n-   TREE_PURPOSE (TREE_PURPOSE (after_stack)) = label at the end of AFTER action\n-*/\n-tree after_stack = NULL_TREE;\n-\n-/* in pass 1 we need a separate list for the labels */\n-static tree after_stack_pass_1 = NULL_TREE;\n-static tree after_help;\n-\n-void\n-timing_init ()\n-{\n-  tree ptr_ftype_durt_ptr_int;\n-  tree int_ftype_abst_ptr_int;\n-  tree void_ftype_ptr;\n-  tree long_ftype_int_int_int_int_int_int_int_ptr_int;\n-  tree void_ftype_abstime_ptr;\n-  tree int_ftype_ptr_durt_ptr;\n-  tree void_ftype_durt_ptr;\n-  tree void_ftype_ptr_durt_ptr_int;\n-  tree temp;\n-  tree endlink;\n-  tree ulong_type;\n-  \n-  ulong_type = TREE_TYPE (lookup_name (\n-\t\t          get_identifier ((ignore_case || ! special_UC ) ?\n-\t\t\t\t\t  \"ulong\" : \"ULONG\")));\n-\n-  /* build modes for TIME and DURATION */\n-  duration_timing_type_node = make_unsigned_type (LONG_TYPE_SIZE);\n-  temp = pushdecl (build_decl (TYPE_DECL, ridpointers[(int)RID_DURATION],\n-\t\t\t       duration_timing_type_node));\n-  SET_CH_NOVELTY_NONNIL (duration_timing_type_node, temp);\n-  abs_timing_type_node = make_unsigned_type (LONG_TYPE_SIZE);\n-  temp = pushdecl (build_decl (TYPE_DECL, ridpointers[(int)RID_TIME],\n-\t\t\t       abs_timing_type_node));\n-  SET_CH_NOVELTY_NONNIL (abs_timing_type_node, temp);\n-\n-  /* the mode of time the runtimesystem returns */\n-  if (rtstime_type_node == NULL_TREE)\n-  {\n-      tree decl1, decl2, result;\n-\n-      decl1 = build_decl (FIELD_DECL,\n-\t\t\t  get_identifier (\"secs\"),\n-\t\t\t  ulong_type);\n-      DECL_INITIAL (decl1) = NULL_TREE;\n-      decl2 = build_decl (FIELD_DECL,\n-\t\t\t  get_identifier (\"nsecs\"),\n-\t\t\t  ulong_type);\n-      DECL_INITIAL (decl2) = NULL_TREE;\n-      TREE_CHAIN (decl2) = NULL_TREE;\n-      TREE_CHAIN (decl1) = decl2;\n-      \n-      result = build_chill_struct_type (decl1);\n-      pushdecl (temp = build_decl (TYPE_DECL,\n-\tget_identifier (\"__tmp_rtstime\"), result));\n-      DECL_SOURCE_LINE (temp) = 0;\n-      satisfy_decl (temp, 0);\n-      rtstime_type_node = TREE_TYPE (temp);\n-  }\n-  \n-  endlink = void_list_node;\n-  \n-  ptr_ftype_durt_ptr_int\n-    = build_function_type (ptr_type_node,\n-         tree_cons (NULL_TREE, duration_timing_type_node,\n-             tree_cons (NULL_TREE, ptr_type_node,\n-                 tree_cons (NULL_TREE, integer_type_node,\n-                     endlink))));\n-\n-  int_ftype_abst_ptr_int\n-    = build_function_type (integer_type_node,\n-         tree_cons (NULL_TREE, abs_timing_type_node,\n-             tree_cons (NULL_TREE, ptr_type_node,\n-                 tree_cons (NULL_TREE, integer_type_node,\n-                     endlink))));\n-\n-  void_ftype_ptr\n-     = build_function_type (void_type_node,\n-\t   tree_cons (NULL_TREE, ptr_type_node,\n-\t       endlink));\n-\n-  long_ftype_int_int_int_int_int_int_int_ptr_int\n-    = build_function_type (abs_timing_type_node,\n-\t tree_cons (NULL_TREE, integer_type_node,\n-\t    tree_cons (NULL_TREE, integer_type_node,\n-\t       tree_cons (NULL_TREE, integer_type_node,\n-\t          tree_cons (NULL_TREE, integer_type_node,\n-\t             tree_cons (NULL_TREE, integer_type_node,\n-\t                tree_cons (NULL_TREE, integer_type_node,\n-\t                   tree_cons (NULL_TREE, integer_type_node,\n-\t                      tree_cons (NULL_TREE, ptr_type_node,\n-\t                         tree_cons (NULL_TREE, integer_type_node,\n-\t\t\t            endlink))))))))));\n-\n-  void_ftype_abstime_ptr\n-    = build_function_type (void_type_node,\n-          tree_cons (NULL_TREE, abs_timing_type_node,\n-              tree_cons (NULL_TREE, ptr_type_node,\n-                  endlink)));\n-\n-  int_ftype_ptr_durt_ptr\n-    = build_function_type (integer_type_node,\n-          tree_cons (NULL_TREE, ptr_type_node,\n-              tree_cons (NULL_TREE, duration_timing_type_node,\n-                  tree_cons (NULL_TREE, ptr_type_node,\n-                      endlink))));\n-\n-  void_ftype_durt_ptr\n-    = build_function_type (void_type_node,\n-          tree_cons (NULL_TREE, duration_timing_type_node,\n-              tree_cons (NULL_TREE, ptr_type_node,\n-                  endlink)));\n-\n-  void_ftype_ptr_durt_ptr_int\n-    = build_function_type (void_type_node,\n-        tree_cons (NULL_TREE, ptr_type_node,\n-          tree_cons (NULL_TREE, duration_timing_type_node,\n-            tree_cons (NULL_TREE, ptr_type_node,\n-              tree_cons (NULL_TREE, integer_type_node,\n-                endlink)))));\n-\n-  builtin_function (\"_abstime\", long_ftype_int_int_int_int_int_int_int_ptr_int,\n-\t\t    0, NOT_BUILT_IN, NULL_PTR);\n-  builtin_function (\"__check_cycle\", void_ftype_ptr_durt_ptr_int,\n-\t\t    0, NOT_BUILT_IN, NULL_PTR);\n-  builtin_function (\"__convert_duration_rtstime\", void_ftype_durt_ptr,\n-\t\t    0, NOT_BUILT_IN, NULL_PTR);\n-  builtin_function (\"__define_timeout\", ptr_ftype_durt_ptr_int,\n-\t\t    0, NOT_BUILT_IN, NULL_PTR);\n-  builtin_function (\"_inttime\", void_ftype_abstime_ptr,\n-\t\t    0, NOT_BUILT_IN, NULL_PTR);\n-  builtin_function (\"__remaintime\", int_ftype_ptr_durt_ptr,\n-\t\t    0, NOT_BUILT_IN, NULL_PTR);\n-  builtin_function (\"__rtstime\", void_ftype_ptr,\n-\t\t    0, NOT_BUILT_IN, NULL_PTR);\n-  builtin_function (\"__wait_until\", int_ftype_abst_ptr_int,\n-\t\t    0, NOT_BUILT_IN, NULL_PTR);\n-}\n-\n-/*\n- *\n- * build AT action\n- *\n- * AT primval IN\n- *  ok-actionlist\n- * TIMEOUT\n- *  to-actionlist\n- * END;\n- *\n- * gets translated to\n- *\n- * if (__wait_until (primval) == 0)\n- *   ok-actionlist\n- * else\n- *   to-action-list\n- *\n- */\n-\n-void\n-build_at_action (t)\n-     tree t;\n-{\n-  tree abstime, expr, filename, fcall;\n-  \n-  if (t == NULL_TREE || TREE_CODE (t) == ERROR_MARK)\n-    abstime = convert (abs_timing_type_node, build_int_2 (0, 0));\n-  else\n-    abstime = t;\n-  \n-  if (TREE_TYPE (abstime) != abs_timing_type_node)\n-    {\n-      error (\"absolute time value must be of mode TIME\");\n-      abstime = convert (abs_timing_type_node, build_int_2 (0, 0));\n-    }\n-  filename = force_addr_of (get_chill_filename ());\n-  fcall = build_chill_function_call (\n-\t    lookup_name (get_identifier (\"__wait_until\")),\n-\t      tree_cons (NULL_TREE, abstime,\n-\t\ttree_cons (NULL_TREE, filename,\n-\t\t  tree_cons (NULL_TREE, get_chill_linenumber (), NULL_TREE))));\n-  expr = build (EQ_EXPR, integer_type_node, fcall, integer_zero_node);\n-  expand_start_cond (expr, 0);\n-  emit_line_note (input_filename, lineno);\n-}\n-\n-/* \n- *\n- * build CYCLE action\n- *\n- * CYCLE primval IN\n- *  actionlist\n- * END;\n- *\n- * gets translated to\n- *\n- * {\n- *    RtsTime  now; \n- *  label:\n- *    __rtstime (&now); \n- *     actionlist\n- *    __check_cycle (&now, primval, filename, lineno); \n- *    goto label;\n- *  }\n- *\n- */\n-\n-tree\n-build_cycle_start (t)\n-    tree t;\n-{\n-  tree purpose = build_tree_list (NULL_TREE, NULL_TREE);\n-  tree toid = build_tree_list (purpose, NULL_TREE);\n-\n-  /* define the label. Note: define_label needs to be called in\n-     pass 1 and pass 2. */\n-  TREE_VALUE (toid) = define_label (input_filename, lineno,\n-\t\t\t\t    get_unique_identifier (\"CYCLE_label\"));\n-  if (! ignoring)\n-    {\n-      tree duration_value, now_location;\n-      \n-      if (t == NULL_TREE || TREE_CODE (t) == ERROR_MARK)\n-\tduration_value = convert (duration_timing_type_node, build_int_2 (0,0));\n-      else\n-\tduration_value = t;\n-      \n-      if (TREE_TYPE (duration_value) != duration_timing_type_node)\n-\t{\n-\t  error (\"duration primitive value must be of mode DURATION\");\n-\t  duration_value = convert (duration_timing_type_node, build_int_2 (0,0));\n-\t}\n-      TREE_PURPOSE (TREE_PURPOSE (toid)) = duration_value;\n-      /* define the variable */\n-      now_location = decl_temp1 (get_unique_identifier (\"CYCLE_var\"),\n-\t\t\t\t rtstime_type_node, 0,\n-\t\t\t\t NULL_TREE, 0, 0);\n-      TREE_VALUE (TREE_PURPOSE (toid)) = force_addr_of (now_location);\n-      \n-      /* build the call to __rtstime */\n-      expand_expr_stmt (\n-        build_chill_function_call (lookup_name (get_identifier (\"__rtstime\")),\n-          build_tree_list (NULL_TREE, TREE_VALUE (TREE_PURPOSE (toid)))));\n-    }\n-\n-  return toid;\n-}\n-\n-void\n-build_cycle_end (toid)\n-     tree toid;\n-{\n-  tree filename, linenumber;\n-  \n-  /* here we call __check_cycle and then jump to beginning of this\n-     action */\n-  filename = force_addr_of (get_chill_filename ());\n-  linenumber = get_chill_linenumber ();\n-  expand_expr_stmt (\n-    build_chill_function_call (\n-      lookup_name (get_identifier (\"__check_cycle\")),\n-\ttree_cons (NULL_TREE, TREE_VALUE (TREE_PURPOSE (toid)),\n-          tree_cons (NULL_TREE, TREE_PURPOSE (TREE_PURPOSE (toid)),\n-\t    tree_cons (NULL_TREE, filename,\n-\t      tree_cons (NULL_TREE, linenumber, NULL_TREE))))));\n-  expand_goto (TREE_VALUE (toid));\n-}\n-\n-/*\n- *\n- * build AFTER ACTION\n- *\n- * AFTER primval [ DELAY ] IN\n- *  action-list\n- * TIMEOUT\n- *  to-action-list\n- * END\n- *\n- * gets translated to\n- *\n- * {\n- *   struct chill_time __now; \n- *   duration dur = primval; \n- *   if (! delay_spceified)\n- *     __rts_time (&__now); \n- *     .\n- *     .\n- *    goto end-label;\n- *   to-label:\n- *     .\n- *     .\n- *   end-label:\n- * }\n- *\n- */\n-\n-void\n-build_after_start (duration, delay_flag)\n-    tree duration;\n-    int  delay_flag;\n-{\n-  tree value, purpose;\n-  \n-  if (! ignoring)\n-    {\n-      value = tree_cons (NULL_TREE, NULL_TREE, NULL_TREE);\n-      purpose = after_stack_pass_1;\n-      after_stack_pass_1 = TREE_CHAIN (after_stack_pass_1);\n-      after_stack = tree_cons (purpose, value, after_stack);\n-      \n-      if (TREE_TYPE (duration) != duration_timing_type_node)\n-        {\n-\t  error (\"duration primitive value must be of mode DURATION\");\n-\t  duration = convert (duration_timing_type_node, build_int_2 (0,0));\n-        }\n-      TREE_PURPOSE (value) = decl_temp1 (get_identifier (\"AFTER_duration\"),\n-\t\t\t\t\t duration_timing_type_node, 0,\n-\t\t\t\t\t duration, 0, 0);\n-      \n-      if (! delay_flag)\n-        {\n-\t  /* in this case we have to get the current time */\n-\t  TREE_VALUE (value) = decl_temp1 (get_unique_identifier (\"AFTER_now\"),\n-\t\t\t\t\t   rtstime_type_node, 0,\n-\t\t\t\t\t   NULL_TREE, 0, 0);\n-\t  /* build the function call to initialize the variable */\n-\t  expand_expr_stmt (\n-            build_chill_function_call (lookup_name (get_identifier (\"__rtstime\")),\n-              build_tree_list (NULL_TREE, force_addr_of (TREE_VALUE (value)))));\n-        }\n-    }\n-  else\n-    {\n-      /* in pass 1 we just save the labels */\n-      after_help = tree_cons (NULL_TREE, NULL_TREE, after_help);\n-      after_stack_pass_1 = chainon (after_stack_pass_1, after_help);\n-    }\n-}\n-\n-void\n-build_after_timeout_start ()\n-{\n-  tree label_name;\n-  \n-  if (! ignoring)\n-    {\n-      /* jump to the end of AFTER action */\n-      lookup_and_expand_goto (TREE_PURPOSE (TREE_PURPOSE (after_stack)));\n-      label_name = TREE_VALUE (TREE_PURPOSE (after_stack));\n-      /* mark we are in TIMEOUT part of AFTER action */\n-      TREE_VALUE (TREE_PURPOSE (after_stack)) = NULL_TREE;\n-    }\n-  else\n-    {\n-      label_name = get_unique_identifier (\"AFTER_tolabel\");\n-      TREE_VALUE (after_help) = label_name;\n-    }\n-  define_label (input_filename, lineno, label_name);\n-}\n-\n-void\n-build_after_end ()\n-{\n-  tree label_name;\n-    \n-  /* define the end label */\n-  if (! ignoring)\n-    {\n-      label_name = TREE_PURPOSE (TREE_PURPOSE (after_stack));\n-      after_stack = TREE_CHAIN (after_stack);\n-    }\n-  else\n-    {\n-      label_name = get_unique_identifier (\"AFTER_endlabel\");\n-      TREE_PURPOSE (after_help) = label_name;\n-      after_help = TREE_CHAIN (after_help);\n-    }\n-  define_label (input_filename, lineno, label_name);\n-}\n-\n-tree\n-build_timeout_preface ()\n-{\n-  tree timeout_value = null_pointer_node;\n-  \n-  if (after_stack != NULL_TREE &&\n-      TREE_VALUE (TREE_PURPOSE (after_stack)) != NULL_TREE)\n-    {\n-      tree to_loc;\n-      \n-      to_loc = decl_temp1 (get_unique_identifier (\"TOloc\"),\n-\t\t\t   rtstime_type_node, 0, NULL_TREE, 0, 0);\n-      timeout_value = force_addr_of (to_loc);\n-\n-      if (TREE_VALUE (TREE_VALUE (after_stack)) == NULL_TREE)\n-        {\n-\t  /* DELAY specified -- just call __convert_duration_rtstime for\n-\t     given duration value */\n-\t  expand_expr_stmt (\n-            build_chill_function_call (\n-              lookup_name (get_identifier (\"__convert_duration_rtstime\")),\n-                tree_cons (NULL_TREE, TREE_PURPOSE (TREE_VALUE (after_stack)),\n-                  tree_cons (NULL_TREE, timeout_value, NULL_TREE))));\n-        }\n-      else\n-        {\n-\t  /* delay not specified -- call __remaintime which returns the \n-\t     remaining time of duration in rtstime format and check the \n-\t     result */\n-\t  tree fcall = \n-            build_chill_function_call (\n-              lookup_name (get_identifier (\"__remaintime\")),\n-                tree_cons (NULL_TREE, force_addr_of (TREE_VALUE (TREE_VALUE (after_stack))),\n-\t\t  tree_cons (NULL_TREE, TREE_PURPOSE (TREE_VALUE (after_stack)),\n-                    tree_cons (NULL_TREE, timeout_value, NULL_TREE))));\n-\t  tree expr = build (NE_EXPR, integer_type_node,\n-\t\t\t     fcall, integer_zero_node);\n-\t  expand_start_cond (expr, 0);\n-\t  lookup_and_expand_goto (TREE_VALUE (TREE_PURPOSE (after_stack)));\n-\t  expand_end_cond ();\n-        }\n-    }\n-  return timeout_value;\n-}\n-\n-void\n-build_timesupervised_call (fcall, to_loc)\n-    tree fcall;\n-    tree to_loc;\n-{\n-  if (to_loc == null_pointer_node)\n-    expand_expr_stmt (fcall);\n-  else\n-    {\n-      tree expr = build (NE_EXPR, integer_type_node, fcall, integer_zero_node);\n-      expand_start_cond (expr, 0);\n-      lookup_and_expand_goto (TREE_VALUE (TREE_PURPOSE (after_stack)));\n-      expand_end_cond ();\n-    }\n-}"}, {"sha": "e9fa6504af34cd2f00ebd85b6329c2ef3a2b477b", "filename": "gcc/ch/tree.c", "status": "removed", "additions": 0, "deletions": 294, "changes": 294, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41823c5eb7d4504b6a4a396ca0d64573238fbbcf/gcc%2Fch%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41823c5eb7d4504b6a4a396ca0d64573238fbbcf/gcc%2Fch%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Ftree.c?ref=41823c5eb7d4504b6a4a396ca0d64573238fbbcf", "patch": "@@ -1,294 +0,0 @@\n-/* Language-dependent node constructors for parse phase of GNU compiler.\n-   Copyright (C) 1992, 1993, 1994, 1998, 1999, 2000\n-   Free Software Foundation, Inc.\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"obstack.h\"\n-#include \"tree.h\"\n-#include \"ch-tree.h\"\n-#include \"toplev.h\"\n-\n-extern struct obstack permanent_obstack;\n-/* This is special sentinel used to communicate from build_string_type\n-   to layout_chill_range_type for the index range of a string. */\n-tree string_index_type_dummy;\n-\n-static tree make_powerset_type\t\t\t\tPARAMS ((tree));\n-\f\n-/* Build a chill string type.\n-   For a character string, ELT_TYPE==char_type_node; \n-   for a bit-string, ELT_TYPE==boolean_type_node. */\n-\n-tree\n-build_string_type (elt_type, length)\n-     tree elt_type;\n-     tree length;\n-{\n-  register tree t;\n-\n-  if (TREE_CODE (elt_type) == ERROR_MARK || TREE_CODE (length) == ERROR_MARK)\n-    return error_mark_node;\n-\n-  /* Allocate the array after the pointer type,\n-     in case we free it in type_hash_canon.  */\n-\n-  if (pass > 0 && TREE_CODE (length) == INTEGER_CST\n-      && ! tree_int_cst_equal (length, integer_zero_node)\n-      && compare_int_csts (LT_EXPR, TYPE_MAX_VALUE (chill_unsigned_type_node),\n-\t\t\t   length))\n-    {\n-      error (\"string length > UPPER (UINT)\");\n-      length = integer_one_node;\n-    }\n-\n-  /* Subtract 1 from length to get max index value.\n-     Note we cannot use size_binop for pass 1 expressions. */\n-  if (TREE_CODE (length) == INTEGER_CST || pass != 1)\n-    length = size_binop (MINUS_EXPR, length, size_one_node);\n-  else\n-    length = build (MINUS_EXPR, sizetype, length, size_one_node);\n-\n-  t = make_node (elt_type == boolean_type_node ? SET_TYPE : ARRAY_TYPE);\n-  TREE_TYPE (t) = elt_type;\n-\n-  MARK_AS_STRING_TYPE (t);\n-\n-  TYPE_DOMAIN (t) = build_chill_range_type (string_index_type_dummy,\n-\t\t\t\t\t    integer_zero_node, length);\n-  if (pass == 1 && TREE_CODE (length) == INTEGER_CST)\n-    TYPE_DOMAIN (t) = layout_chill_range_type (TYPE_DOMAIN (t), 0);\n-\n-  if (pass != 1\n-      || (TREE_CODE (length) == INTEGER_CST && TYPE_SIZE (elt_type)))\n-    {\n-      if (TREE_CODE (t) == SET_TYPE)\n-\tt = layout_powerset_type (t);\n-      else\n-\tt = layout_chill_array_type (t);\n-    }\n-  return t;\n-}\n-\f\n-static tree\n-make_powerset_type (domain)\n-     tree domain;\n-{\n-  tree t = make_node (SET_TYPE);\n-\n-  TREE_TYPE (t) = boolean_type_node;\n-  TYPE_DOMAIN (t) = domain;\n-  \n-  return t;\n-}\n-\n-/* Used to layout both bitstring and powerset types. */\n-\n-tree\n-layout_powerset_type (type)\n-     tree type;\n-{\n-  tree domain = TYPE_DOMAIN (type);\n-\n-  if (! discrete_type_p (domain))\n-    {\n-      error (\"can only build a powerset from a discrete mode\");\n-      return error_mark_node;\n-    }\n-\n-  if (TREE_CODE (TYPE_MAX_VALUE (domain)) == ERROR_MARK ||\n-      TREE_CODE (TYPE_MIN_VALUE (domain)) == ERROR_MARK)\n-    return error_mark_node;\n-\n-  if (TREE_CODE (TYPE_MAX_VALUE (domain)) != INTEGER_CST\n-      || TREE_CODE (TYPE_MIN_VALUE (domain)) != INTEGER_CST)\n-    {\n-      if (CH_BOOLS_TYPE_P (type))\n-\terror (\"non-constant bitstring size invalid\");\n-      else\n-\terror (\"non-constant powerset size invalid\");\n-      return error_mark_node;\n-    }\n-\n-  if (TYPE_SIZE (type) == 0)\n-    layout_type (type);\n-  return type;\n-}\n-\n-/* Build a SET_TYPE node whose elements are from the set of values\n-   in TYPE.  TYPE must be a discrete mode; we check for that here. */\n-tree\n-build_powerset_type (type)\n-     tree type;\n-{\n-  tree t = make_powerset_type (type);\n-  if (pass != 1)\n-    t = layout_powerset_type (t);\n-  return t;\n-}\n-\n-tree\n-build_bitstring_type (size_in_bits)\n-     tree size_in_bits;\n-{\n-  return build_string_type (boolean_type_node, size_in_bits);\n-}\n-\n-/* Return get_identifier (the concatenations of part1, part2, and part3). */\n-\n-tree\n-get_identifier3 (part1, part2, part3)\n-     const char *part1, *part2, *part3;\n-{\n-  char *buf = (char*)\n-    alloca (strlen(part1) + strlen(part2) + strlen(part3) + 1);\n-  sprintf (buf, \"%s%s%s\", part1, part2, part3);\n-  return get_identifier (buf);\n-}\n-\n-/* Build an ALIAS_DECL for the prefix renamed clause:\n-   (OLD_PREFIX -> NEW_PREFIX) ! POSTFIX. */\n-\n-tree\n-build_alias_decl (old_prefix, new_prefix, postfix)\n-     tree old_prefix, new_prefix, postfix;\n-{\n-  tree decl = make_node (ALIAS_DECL);\n-\n-  const char *postfix_pointer = IDENTIFIER_POINTER (postfix);\n-  int postfix_length = IDENTIFIER_LENGTH (postfix);\n-  int old_length = old_prefix ? IDENTIFIER_LENGTH(old_prefix) : 0;\n-  int new_length = new_prefix ? IDENTIFIER_LENGTH(new_prefix) : 0;\n-\n-  char *buf = (char*) alloca (old_length + new_length + postfix_length + 3);\n-\n-  /* Convert (OP->NP)!P!ALL to (OP!P->NP!P)!ALL */\n-  if (postfix_length > 1 && postfix_pointer[postfix_length-1] == '*')\n-    {\n-      int chopped_length = postfix_length - 2; /* Without final \"!*\" */\n-      if (old_prefix)\n-\tsprintf (buf, \"%s!%.*s\", IDENTIFIER_POINTER (old_prefix),\n-\t\t chopped_length, postfix_pointer);\n-      else\n-\tsprintf (buf, \"%.*s\", chopped_length, postfix_pointer);\n-      old_prefix = get_identifier (buf);\n-      if (new_prefix)\n-\tsprintf (buf, \"%s!%.*s\", IDENTIFIER_POINTER (new_prefix),\n-\t\t chopped_length, postfix_pointer);\n-      else\n-\tsprintf (buf, \"%.*s\", chopped_length, postfix_pointer);\n-      new_prefix = get_identifier (buf);\n-      postfix = ALL_POSTFIX;\n-    }\n-\n-  DECL_OLD_PREFIX (decl) = old_prefix;\n-  DECL_NEW_PREFIX (decl) = new_prefix;\n-  DECL_POSTFIX (decl) = postfix;\n-\n-  if (DECL_POSTFIX_ALL (decl))\n-    DECL_NAME (decl) = NULL_TREE;\n-  else if (new_prefix == NULL_TREE)\n-    DECL_NAME (decl) = postfix;\n-  else\n-    DECL_NAME (decl) = get_identifier3 (IDENTIFIER_POINTER (new_prefix),\n-\t\t\t\t\t\"!\", IDENTIFIER_POINTER (postfix));\n-\n-  return decl;\n-}\n-\n-/* Return the \"old name string\" of an ALIAS_DECL. */\n-\n-tree\n-decl_old_name (decl)\n-     tree decl;\n-{\n-  \n-  if (DECL_OLD_PREFIX (decl) == NULL_TREE)\n-    return DECL_POSTFIX (decl);\n-  return get_identifier3 (IDENTIFIER_POINTER (DECL_OLD_PREFIX (decl)),\n-\t\t\t  \"!\", IDENTIFIER_POINTER (DECL_POSTFIX (decl)));\n-}\n-\n-/* See if OLD_NAME (an identifier) matches the OLD_PREFIX!POSTFIX\n-   of ALIAS.  If so, return the corresponding NEW_NEW!POSTFIX. */\n-\n-tree\n-decl_check_rename (alias, old_name)\n-     tree alias, old_name;\n-{\n-  const char *old_pointer = IDENTIFIER_POINTER (old_name);\n-  int old_len = IDENTIFIER_LENGTH (old_name);\n-  if (DECL_OLD_PREFIX (alias))\n-    {\n-      int old_prefix_len = IDENTIFIER_LENGTH (DECL_OLD_PREFIX (alias));\n-      if (old_prefix_len >= old_len\n-\t  || old_pointer[old_prefix_len] != '!'\n-\t  || strncmp (old_pointer, IDENTIFIER_POINTER (DECL_OLD_PREFIX (alias)), old_prefix_len) != 0)\n-\treturn NULL_TREE;\n-\n-      /* Skip the old prefix. */\n-      old_pointer += old_prefix_len + 1; /* Also skip the '!', */\n-    }\n-  if (DECL_POSTFIX_ALL (alias)\n-      || strcmp (IDENTIFIER_POINTER (DECL_POSTFIX (alias)), old_pointer) == 0)\n-    {\n-      if (DECL_NEW_PREFIX (alias))\n-\treturn get_identifier3 (IDENTIFIER_POINTER (DECL_NEW_PREFIX (alias)),\n-\t\t\t\t\"!\", old_pointer);\n-      else if (old_pointer == IDENTIFIER_POINTER (old_name))\n-\treturn old_name;\n-      else\n-\treturn get_identifier (old_pointer);\n-    }\n-  else\n-    return NULL_TREE;\n-}\n-\n-/* 'EXIT foo' is treated like 'GOTO EXIT!foo'.\n-    This function converts LABEL into a labal name for EXIT. */\n-\n-tree\n-munge_exit_label (label)\n-     tree label;\n-{\n-  return get_identifier3 (\"EXIT\", \"!\", IDENTIFIER_POINTER (label));\n-}\n-\n-/* Make SAVE_EXPRs as needed, but don't turn a location into a non-location. */\n-\n-tree\n-save_if_needed (exp)\n-tree exp;\n-{\n-  return CH_REFERABLE (exp) ? stabilize_reference (exp) : save_expr (exp);\n-}\n-\n-/* Return the number of elements in T, which must be a discrete type. */\n-tree\n-discrete_count (t)\n-     tree t;\n-{\n-  tree hi = convert (sizetype, TYPE_MAX_VALUE (t));\n-\n-  if (TYPE_MIN_VALUE (t))\n-    hi = size_binop (MINUS_EXPR, hi, convert (sizetype, TYPE_MIN_VALUE (t)));\n-\n-  return size_binop (PLUS_EXPR, hi, integer_one_node);\n-}"}, {"sha": "84ee56ebd395fd2aad04ebd2cb17b81df7b12589", "filename": "gcc/ch/typeck.c", "status": "removed", "additions": 0, "deletions": 3822, "changes": 3822, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41823c5eb7d4504b6a4a396ca0d64573238fbbcf/gcc%2Fch%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41823c5eb7d4504b6a4a396ca0d64573238fbbcf/gcc%2Fch%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Ftypeck.c?ref=41823c5eb7d4504b6a4a396ca0d64573238fbbcf"}, {"sha": "3534bc95d5b85d8e54f71f0212dfd13af838729c", "filename": "gcc/ch/xtypeck.c", "status": "removed", "additions": 0, "deletions": 272, "changes": 272, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41823c5eb7d4504b6a4a396ca0d64573238fbbcf/gcc%2Fch%2Fxtypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41823c5eb7d4504b6a4a396ca0d64573238fbbcf/gcc%2Fch%2Fxtypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Fxtypeck.c?ref=41823c5eb7d4504b6a4a396ca0d64573238fbbcf", "patch": "@@ -1,272 +0,0 @@\n-/* Copyright (C) 1992, 1993, 1994, 1998 Free Software Foundation, Inc.\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-\n-#if 0\n-tree\n-build_component_ref (datum, field_name)\n-  tree datum, field_name;\n-{\n-  return build_chill_component_ref (datum, field_name);\n-}\n-\n-/* Mark EXP saying that we need to be able to take the\n-   address of it; it should not be allocated in a register.\n-   Value is 1 if successful.  */\n-\n-int\n-mark_addressable (exp)\n-     tree exp;\n-{\n-  register tree x = exp;\n-  while (1)\n-    switch (TREE_CODE (x))\n-      {\n-      case ADDR_EXPR:\n-      case COMPONENT_REF:\n-      case ARRAY_REF:\n-      case REALPART_EXPR:\n-      case IMAGPART_EXPR:\n-\tx = TREE_OPERAND (x, 0);\n-\tbreak;\n-\n-      case CONSTRUCTOR:\n-\tTREE_ADDRESSABLE (x) = 1;\n-\treturn 1;\n-\n-      case VAR_DECL:\n-      case CONST_DECL:\n-      case PARM_DECL:\n-      case RESULT_DECL:\n-\tif (DECL_REGISTER (x) && !TREE_ADDRESSABLE (x)\n-\t    && DECL_NONLOCAL (x))\n-\t  {\n-\t    if (TREE_PUBLIC (x))\n-\t      {\n-\t\terror (\"global register variable `%s' used in nested function\",\n-\t\t       IDENTIFIER_POINTER (DECL_NAME (x)));\n-\t\treturn 0;\n-\t      }\n-\t    pedwarn (\"register variable `%s' used in nested function\",\n-\t\t     IDENTIFIER_POINTER (DECL_NAME (x)));\n-\t  }\n-\telse if (DECL_REGISTER (x) && !TREE_ADDRESSABLE (x))\n-\t  {\n-\t    if (TREE_PUBLIC (x))\n-\t      {\n-\t\terror (\"address of global register variable `%s' requested\",\n-\t\t       IDENTIFIER_POINTER (DECL_NAME (x)));\n-\t\treturn 0;\n-\t      }\n-\n-\t    /* If we are making this addressable due to its having\n-\t       volatile components, give a different error message.  Also\n-\t       handle the case of an unnamed parameter by not trying\n-\t       to give the name.  */\n-\n-\t    else if (C_TYPE_FIELDS_VOLATILE (TREE_TYPE (x)))\n-\t      {\n-\t\terror (\"cannot put object with volatile field into register\");\n-\t\treturn 0;\n-\t      }\n-\n-\t    pedwarn (\"address of register variable `%s' requested\",\n-\t\t     IDENTIFIER_POINTER (DECL_NAME (x)));\n-\t  }\n-\tput_var_into_stack (x);\n-\n-\t/* drops in */\n-      case FUNCTION_DECL:\n-\tTREE_ADDRESSABLE (x) = 1;\n-#if 0  /* poplevel deals with this now.  */\n-\tif (DECL_CONTEXT (x) == 0)\n-\t  TREE_ADDRESSABLE (DECL_ASSEMBLER_NAME (x)) = 1;\n-#endif\n-\n-      default:\n-\treturn 1;\n-    }\n-}\n-\n-/* Return an unsigned type the same as TYPE in other respects.  */\n-\n-tree\n-unsigned_type (type)\n-     tree type;\n-{\n-  tree type1 = TYPE_MAIN_VARIANT (type);\n-  if (type1 == signed_char_type_node || type1 == char_type_node)\n-    return unsigned_char_type_node;\n-  if (type1 == integer_type_node)\n-    return unsigned_type_node;\n-  if (type1 == short_integer_type_node)\n-    return short_unsigned_type_node;\n-  if (type1 == long_integer_type_node)\n-    return long_unsigned_type_node;\n-  if (type1 == long_long_integer_type_node)\n-    return long_long_unsigned_type_node;\n-  return type;\n-}\n-\n-/* Return a signed type the same as TYPE in other respects.  */\n-\n-tree\n-signed_type (type)\n-     tree type;\n-{\n-  tree type1 = TYPE_MAIN_VARIANT (type);\n-  if (type1 == unsigned_char_type_node || type1 == char_type_node)\n-    return signed_char_type_node;\n-  if (type1 == unsigned_type_node)\n-    return integer_type_node;\n-  if (type1 == short_unsigned_type_node)\n-    return short_integer_type_node;\n-  if (type1 == long_unsigned_type_node)\n-    return long_integer_type_node;\n-  if (type1 == long_long_unsigned_type_node)\n-    return long_long_integer_type_node;\n-  return type;\n-}\n-\n-/* Return a type the same as TYPE except unsigned or\n-   signed according to UNSIGNEDP.  */\n-\n-tree\n-signed_or_unsigned_type (unsignedp, type)\n-     int unsignedp;\n-     tree type;\n-{\n-  if (! INTEGRAL_TYPE_P (type))\n-    return type;\n-  if (TYPE_PRECISION (type) == TYPE_PRECISION (signed_char_type_node))\n-    return unsignedp ? unsigned_char_type_node : signed_char_type_node;\n-  if (TYPE_PRECISION (type) == TYPE_PRECISION (integer_type_node)) \n-    return unsignedp ? unsigned_type_node : integer_type_node;\n-  if (TYPE_PRECISION (type) == TYPE_PRECISION (short_integer_type_node)) \n-    return unsignedp ? short_unsigned_type_node : short_integer_type_node;\n-  if (TYPE_PRECISION (type) == TYPE_PRECISION (long_integer_type_node)) \n-    return unsignedp ? long_unsigned_type_node : long_integer_type_node;\n-  if (TYPE_PRECISION (type) == TYPE_PRECISION (long_long_integer_type_node)) \n-    return (unsignedp ? long_long_unsigned_type_node\n-\t    : long_long_integer_type_node);\n-  return type;\n-}\n-\n-extern tree intHI_type_node;\n-extern tree intSI_type_node;\n-extern tree intDI_type_node;\n-\n-extern tree unsigned_intHI_type_node;\n-extern tree unsigned_intSI_type_node;\n-extern tree unsigned_intDI_type_node;\n-\n-/* Return an integer type with BITS bits of precision,\n-   that is unsigned if UNSIGNEDP is nonzero, otherwise signed.  */\n-\n-tree\n-type_for_size (bits, unsignedp)\n-     unsigned bits;\n-     int unsignedp;\n-{\n-  if (bits == TYPE_PRECISION (signed_char_type_node))\n-    return unsignedp ? unsigned_char_type_node : signed_char_type_node;\n-\n-  if (bits == TYPE_PRECISION (short_integer_type_node))\n-    return unsignedp ? short_unsigned_type_node : short_integer_type_node;\n-\n-  if (bits == TYPE_PRECISION (integer_type_node))\n-    return unsignedp ? unsigned_type_node : integer_type_node;\n-\n-  if (bits == TYPE_PRECISION (long_integer_type_node))\n-    return unsignedp ? long_unsigned_type_node : long_integer_type_node;\n-\n-  if (bits == TYPE_PRECISION (long_long_integer_type_node))\n-    return (unsignedp ? long_long_unsigned_type_node\n-\t    : long_long_integer_type_node);\n-\n-  if (bits <= TYPE_PRECISION (intHI_type_node))\n-    return unsignedp ? unsigned_intHI_type_node : intHI_type_node;\n-\n-  if (bits <= TYPE_PRECISION (intSI_type_node))\n-    return unsignedp ? unsigned_intSI_type_node : intSI_type_node;\n-\n-  if (bits <= TYPE_PRECISION (intDI_type_node))\n-    return unsignedp ? unsigned_intDI_type_node : intDI_type_node;\n-\n-  return 0;\n-}\n-\n-/* Return a data type that has machine mode MODE.\n-   If the mode is an integer,\n-   then UNSIGNEDP selects between signed and unsigned types.  */\n-\n-tree\n-type_for_mode (mode, unsignedp)\n-     enum machine_mode mode;\n-     int unsignedp;\n-{\n-  if (mode == TYPE_MODE (signed_char_type_node))\n-    return unsignedp ? unsigned_char_type_node : signed_char_type_node;\n-\n-  if (mode == TYPE_MODE (short_integer_type_node))\n-    return unsignedp ? short_unsigned_type_node : short_integer_type_node;\n-\n-  if (mode == TYPE_MODE (integer_type_node))\n-    return unsignedp ? unsigned_type_node : integer_type_node;\n-\n-  if (mode == TYPE_MODE (long_integer_type_node))\n-    return unsignedp ? long_unsigned_type_node : long_integer_type_node;\n-\n-  if (mode == TYPE_MODE (long_long_integer_type_node))\n-    return unsignedp ? long_long_unsigned_type_node : long_long_integer_type_node;\n-\n-  if (mode == TYPE_MODE (intHI_type_node))\n-    return unsignedp ? unsigned_intHI_type_node : intHI_type_node;\n-\n-  if (mode == TYPE_MODE (intSI_type_node))\n-    return unsignedp ? unsigned_intSI_type_node : intSI_type_node;\n-\n-  if (mode == TYPE_MODE (intDI_type_node))\n-    return unsignedp ? unsigned_intDI_type_node : intDI_type_node;\n-\n-  if (mode == TYPE_MODE (float_type_node))\n-    return float_type_node;\n-\n-  if (mode == TYPE_MODE (double_type_node))\n-    return double_type_node;\n-\n-  if (mode == TYPE_MODE (long_double_type_node))\n-    return long_double_type_node;\n-\n-  if (mode == TYPE_MODE (build_pointer_type (char_type_node)))\n-    return build_pointer_type (char_type_node);\n-\n-  if (mode == TYPE_MODE (build_pointer_type (integer_type_node)))\n-    return build_pointer_type (integer_type_node);\n-\n-  return 0;\n-}\n-\n-tree\n-truthvalue_conversion (expr)\n-     tree expr;\n-{\n-  return chill_truthvalue_conversion (expr);\n-}\n-#endif"}, {"sha": "a5efb63b1fdf630df26265210ac4d7a8a8bab0e6", "filename": "gcc/doc/frontends.texi", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07cdae91c9e7e8cc31ac231105bdd694bd24d3e7/gcc%2Fdoc%2Ffrontends.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07cdae91c9e7e8cc31ac231105bdd694bd24d3e7/gcc%2Fdoc%2Ffrontends.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ffrontends.texi?ref=07cdae91c9e7e8cc31ac231105bdd694bd24d3e7", "patch": "@@ -4,17 +4,16 @@\n @c For copying conditions, see the file gcc.texi.\n \n @node G++ and GCC\n-@chapter Compile C, C++, Objective-C, Ada, CHILL, Fortran, or Java\n+@chapter Compile C, C++, Objective-C, Ada, Fortran, or Java\n \n @cindex Objective-C\n @cindex Fortran\n @cindex Java\n-@cindex CHILL\n @cindex Ada\n-Several versions of the compiler (C, C++, Objective-C, Ada, CHILL,\n+Several versions of the compiler (C, C++, Objective-C, Ada, \n Fortran, and Java) are integrated; this is why we use the name\n ``GNU Compiler Collection''.  GCC can compile programs written in any of these\n-languages.  The Ada, CHILL, Fortran, and Java compilers are described in\n+languages.  The Ada, Fortran, and Java compilers are described in\n separate manuals.\n \n @cindex GCC"}, {"sha": "9a14e446da9fa267f2d849898df1873362d98cdd", "filename": "gcc/doc/sourcebuild.texi", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07cdae91c9e7e8cc31ac231105bdd694bd24d3e7/gcc%2Fdoc%2Fsourcebuild.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07cdae91c9e7e8cc31ac231105bdd694bd24d3e7/gcc%2Fdoc%2Fsourcebuild.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fsourcebuild.texi?ref=07cdae91c9e7e8cc31ac231105bdd694bd24d3e7", "patch": "@@ -50,9 +50,6 @@ language front ends, and test suites.  @xref{gcc Directory, , The\n @item include\n Headers for the @code{libiberty} library.\n \n-@item libchill\n-The CHILL runtime library.\n-\n @item libf2c\n The Fortran runtime library.\n "}, {"sha": "78ba0725ee128572304a5eeab1afc10200fbe697", "filename": "gcc/doc/standards.texi", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07cdae91c9e7e8cc31ac231105bdd694bd24d3e7/gcc%2Fdoc%2Fstandards.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07cdae91c9e7e8cc31ac231105bdd694bd24d3e7/gcc%2Fdoc%2Fstandards.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fstandards.texi?ref=07cdae91c9e7e8cc31ac231105bdd694bd24d3e7", "patch": "@@ -1,4 +1,4 @@\n-@c Copyright (C) 2000, 2001 Free Software Foundation, Inc.\n+@c Copyright (C) 2000, 2001, 2002 Free Software Foundation, Inc.\n @c This is part of the GCC manual.\n @c For copying conditions, see the file gcc.texi.\n \n@@ -171,9 +171,6 @@ information as well.\n GNAT Reference Manual}, for information on standard\n conformance and compatibility of the Ada compiler.\n \n-@xref{References,,Language Definition References, chill, GNU Chill},\n-for details of the CHILL standard.\n-\n @xref{Language,,The GNU Fortran Language, g77, Using and Porting GNU\n Fortran}, for details of the Fortran language supported by GCC@.\n "}, {"sha": "0e42bcc50c8b156b6d636372fe0cc85425a97777", "filename": "gcc/f/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07cdae91c9e7e8cc31ac231105bdd694bd24d3e7/gcc%2Ff%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07cdae91c9e7e8cc31ac231105bdd694bd24d3e7/gcc%2Ff%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2FChangeLog?ref=07cdae91c9e7e8cc31ac231105bdd694bd24d3e7", "patch": "@@ -1,3 +1,7 @@\n+Mon Apr 15 10:59:14 2002  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* g77.texi: Remove Chill reference.\n+\n 2002-04-13  Toon Moene  <toon@moene.indiv.nluug.nl>\n \n \t* news.texi: Deprecate frontend version number;"}, {"sha": "be56ba9c349beeb6e034dd34cba77c729d2b9ed1", "filename": "gcc/f/g77.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07cdae91c9e7e8cc31ac231105bdd694bd24d3e7/gcc%2Ff%2Fg77.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07cdae91c9e7e8cc31ac231105bdd694bd24d3e7/gcc%2Ff%2Fg77.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fg77.texi?ref=07cdae91c9e7e8cc31ac231105bdd694bd24d3e7", "patch": "@@ -841,7 +841,7 @@ files and accepts Fortran-specific command-line options, plus some\n command-line options that are designed to cater to Fortran users\n but apply to other languages as well.\n \n-@xref{G++ and GCC,,Compile C; C++; Objective-C; Ada; CHILL; Fortran;\n+@xref{G++ and GCC,,Compile C; C++; Objective-C; Ada; Fortran;\n or Java,gcc,Using the GNU Compiler Collection (GCC)},\n for information on the way different languages are handled\n by the GNU CC compiler (@command{gcc})."}, {"sha": "8fa6bb5979ec1135defe1ca2f998a9c2ab47563e", "filename": "gcc/gcc.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07cdae91c9e7e8cc31ac231105bdd694bd24d3e7/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07cdae91c9e7e8cc31ac231105bdd694bd24d3e7/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=07cdae91c9e7e8cc31ac231105bdd694bd24d3e7", "patch": "@@ -825,7 +825,6 @@ static const struct compiler default_compilers[] =\n   {\".F\", \"#Fortran\", 0}, {\".FOR\", \"#Fortran\", 0}, {\".FPP\", \"#Fortran\", 0},\n   {\".r\", \"#Ratfor\", 0},\n   {\".p\", \"#Pascal\", 0}, {\".pas\", \"#Pascal\", 0},\n-  {\".ch\", \"#Chill\", 0}, {\".chi\", \"#Chill\", 0},\n   {\".java\", \"#Java\", 0}, {\".class\", \"#Java\", 0},\n   {\".zip\", \"#Java\", 0}, {\".jar\", \"#Java\", 0},\n   /* Next come the entries for C.  */"}, {"sha": "4fa62b357ba3d7276a27bb94437a373bc59d12e8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07cdae91c9e7e8cc31ac231105bdd694bd24d3e7/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07cdae91c9e7e8cc31ac231105bdd694bd24d3e7/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=07cdae91c9e7e8cc31ac231105bdd694bd24d3e7", "patch": "@@ -1,3 +1,7 @@\n+2002-04-15  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* testsuite/lib/chill.exp: Remove.\n+\n 2002-04-14  Jakub Jelinek  <jakub@redhat.com>\n \n \t* g++.dg/other/big-struct.C: New test."}, {"sha": "586e5c8cffdc5f32a238caa4f90c22353e16dc37", "filename": "gcc/testsuite/lib/chill.exp", "status": "removed", "additions": 0, "deletions": 365, "changes": 365, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41823c5eb7d4504b6a4a396ca0d64573238fbbcf/gcc%2Ftestsuite%2Flib%2Fchill.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41823c5eb7d4504b6a4a396ca0d64573238fbbcf/gcc%2Ftestsuite%2Flib%2Fchill.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Fchill.exp?ref=41823c5eb7d4504b6a4a396ca0d64573238fbbcf", "patch": "@@ -1,365 +0,0 @@\n-#\n-# Expect script for Chill Regression Tests\n-#   Copyright (C) 1993, 1996, 1997 Free Software Foundation\n-#\n-# This file is free software; you can redistribute it and/or modify\n-# it under the terms of the GNU General Public License as published by\n-# the Free Software Foundation; either version 2 of the License, or\n-# (at your option) any later version.\n-#\n-# This program is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-# GNU General Public License for more details.\n-#\n-# You should have received a copy of the GNU General Public License\n-# along with this program; if not, write to the Free Software\n-# Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n-#\n-# Written by Jeffrey Wheat (cassidy@cygnus.com)\n-#\n-\n-#\n-# chill support library procedures and testsuite specific instructions\n-#\n-\n-#\n-# default_chill_version \n-# \textract and print the version number of the chill compiler\n-#\texits if compiler does not exist\n-#\n-proc default_chill_version { } {\n-    global GCC_UNDER_TEST\n-    \n-    # ignore any arguments after the command \n-    set compiler [lindex $GCC_UNDER_TEST 0]\n-    \n-    # verify that the compiler exists\n-    if {[which $compiler] != 0} then {\n-        set tmp [ exec $compiler -v ]\n-        regexp \"version.*$\" $tmp version\n-\t\n-        if [info exists version] then {\n-            clone_output \"[which $compiler] $version\\n\"\n-        }\n-    } else {\n-        warning \"$compiler does not exist\"\n-\texit -1\n-    }\n-}\n-\n-#\n-# chill_compile\n-#\tcompile the specified file\n-#\n-#\treturns values:\n-#\t\treturn 0 on success\n-#\t\treturn 1 on failure with $result containing compiler output\n-#\t\texit with -1 if compiler doesn't exist\n-#\n-#\tverbosity output:\n-#\t\t1 - indicate compile in progress\n-#\t\t2 - indicate compile, target name\n-#\t\t3 - indicate compile, target name, exec command, and result\n-#\n-proc chill_compile { src obj } {\n-    global GCC_UNDER_TEST\n-    global CFLAGS\n-    \n-    global errno\n-    global result\n-    global verbose\n-\n-    global subdir\n-    global tmpdir\n-   \n-    set errno 0 \n-    set cflags $CFLAGS\n-    set dumpfile [file rootname $obj].cmp    ;# name of file to dump stderr in\n-\n-    # verify that the compiler exists\n-    if { [which $GCC_UNDER_TEST] == 0 } then {\n-\twarning \"$GCC_UNDER_TEST does not exist\"\n-\texit -1\n-    }\n-    \n-    if { $verbose == 1 } then {\n-\tsend_user \"Compiling... \"\n-    } else {\n-\tverbose \" -  CMPL: Compiling [file tail $src]\" 2\n-    }\n-   \n-    # if object type is a grt file, then only build a grant file\n-    if [string match \"*.grt\" $obj] then {\n-\tset cflags [concat $cflags -fgrant-only]\n-    }\n-\n-    # build command line\n-    set commandline \"$GCC_UNDER_TEST $cflags -I$subdir -c $src\"\n-\n-    # write command line to logfile\n-    send_log \"\\n### EXEC: $commandline\\n\"\n-    \n-    # tell us whats going on if verbose \n-    verbose \"### EXEC: $commandline\" 3\n-    \n-    # exec the compiler with the appropriate flags\n-    set errno [catch \"exec $commandline\" result]\n-\n-    # dump compiler's stderr output into $dumpfile - this is a gross hack\n-    set dumpfile [open $dumpfile w+]; puts $dumpfile $result; close $dumpfile\n-\n-    # log any compiler output unless its null\n-    if ![string match \"\" $result] then { send_log \"\\n$result\\n\" }\n-    unset cflags\n-    return\n-}\n-\n-#\n-# chill_link\n-#\tlink the specified files\n-#\n-#\treturns values:\n-#\t\treturn 0 on success\n-#\t\treturn 1 on failure with $result containing compiler output\n-#\t\texit with -1 if compiler doesn't exist\n-#\n-#\tverbosity output:\n-#\t\t1 - indicate linking in progress\n-#\t\t2 - indicate linking, target name\n-#\t\t3 - indicate linking, target name, exec command, and result\n-#\n-proc chill_link { target } {\n-    global GCC_UNDER_TEST\n-    global CFLAGS\n-    \n-    global errno \n-    global result\n-    global verbose\n-    global tmptarget\n-    \n-    global crt0\n-    global libs\n-    global objs\n-    \n-    set errno 0\n-    \n-    # verify that the compiler exists\n-    if { [which $GCC_UNDER_TEST] == 0 } then {\n-\twarning \"$GCC_UNDER_TEST does not exist\"\n-\texit -1\n-    }\n-    \n-    if { $verbose == 1 } then {\n-\tsend_user \"Linking... \"\n-    } else {\n-\tverbose \" -  LINK: Linking [file tail $target]\" 2\n-    }\n-    \n-    # verify that the object exists\n-    if ![file exists $target.o] then {\n-\tset errno 1\n-\tset result \"file $target.o doesn't exist\"\n-\treturn\n-    }\n-    \n-    # build command line\n-    set commandline \"$GCC_UNDER_TEST $CFLAGS -o $target $target.o $objs $crt0 $libs\"\n-\n-    # write command line to logfile\n-    send_log \"\\n### EXEC: $commandline\\n\"\n-    \n-    # tell us whats going on if we are verbose\t\n-    verbose \"### EXEC: $commandline\" 3\n-    \n-    # link the objects, sending any linker output to $result\n-    set errno [catch \"exec $commandline > $tmptarget.lnk\" result]\n- \n-    # log any linker output unless its null\n-    if ![string match \"\" $result] then { send_log \"\\n$result\\n\" }\n-    return\n-}\n-\n-#\n-# default_chill_start\n-#\n-proc default_chill_start { } {\n-    global srcdir\n-    global subdir\n-    global tmpdir\n-    global verbose\n-  \n-    if { $verbose > 1 } then { send_user \"Configuring testsuite... \" }\n-\n-    # tmpdir is obtained from $objdir/site.exp. if not, set it to /tmp\n-    if ![info exists tmpdir] then { set tmpdir /tmp }\n-\n-    # save and convert $srcdir to an absolute pathname, stomp on the old value\n-    # stomp on $subdir and set to the absolute path to the subdirectory\n-    global osrcdir; set osrcdir $srcdir; set srcdir [cd $srcdir; pwd]\n-    global osubdir; set osubdir $subdir; set subdir $srcdir/$subdir\n-\n-    # cd the temporary directory, $tmpdir\n-    cd $tmpdir; verbose \"### PWD: [pwd]\" 5\n-\n-    # copy init files to the tmpdir\n-    foreach initfile [glob -nocomplain $subdir/*.init] {\n-\tset targfile $tmpdir/[file tail [file rootname $initfile]]\n-\tverbose \"### EXEC: cp $initfile $targfile\" 5\n-\tif [catch \"exec cp $initfile $targfile\"] then {\n-\t    send_user \"\\nConfigure failed.\\n\"\n-\t    exit -1\n-\t}\n-    }\n-    if { $verbose > 1 } then { send_user \"Configuring finished.\\n\" }\n-}\n-    \n-#\n-# default_chill_exit\n-#\n-#\n-proc default_chill_exit { } {\n-    global srcdir\n-    global objdir\n-    global tmpdir\n-    global osrcdir\n-    global osubdir\n-    \n-    # reset directory variables\n-    set srcdir $osrcdir; set subdir $osubdir\n-\n-    # remove all generated targets and objects\t\n-    verbose \"### EXEC: rm -f $tmpdir/*\" 3\n-    catch \"exec rm -f $tmpdir/*\" result\n-\n-    # change back to the main object directory\n-    cd $objdir\n-    verbose \"### SANITY: [pwd]\" 5\n-}\n-\n-#\n-# chill_diff\n-#\tcompare two files line-by-line\n-#\n-#\treturns values:\n-#\t\treturn 0 on success\n-#\t\treturn 1 if different\n-#\t\treturn -1 if output file doesn't exist\n-#\n-#\tverbosity output:\n-#\t\t1 - indicate diffing in progress\n-#\t\t2 - indicate diffing, target names\n-#\t\t3 - indicate diffing, target names, and result\n-#\n-proc chill_diff { file_1 file_2 } {\n-    global errno\n-    global result\n-    global target\n-    global tmptarget\n-\n-    global verbose\n-    \n-    set eof -1\n-    set errno 0\n-    set differences 0\n-    \n-    if { $verbose == 1 } then {\n-\tsend_user \"Diffing... \"\n-    } else {\n-\tverbose \" -  DIFF: Diffing [file tail $file_1] [file tail $file_2]\" 2\n-    }\n-    \n-    # write command line to logfile\n-    send_log \"### EXEC: diff $file_1 $file_2\\n\"\n-    \n-    # tell us whats going on if we are verbose\t\n-    verbose \"### EXEC: diff $file_1 $file_2\" 3\n-    \n-    # verify file exists and open it\n-    if [file exists $file_1] then {\n-\tset file_a [open $file_1 r]\n-    } else {\n-\tset errno -1; set result \"$file_1 doesn't exist\"\n-\treturn\n-    }\n-    \n-    # verify file exists and is not zero length, and then open it\n-    if [file exists $file_2] then {\n-        if [file size $file_2]!=0 then {\n-\t    set file_b [open $file_2 r]\n-        } else {\n-\t    set errno -1; set result \"$file_2 is zero bytes\"; return\n-        }\n-    } else {\n-\tset errno -1; set result \"$file_2 doesn't exist\"; return\n-    }\n-    \n-    # spoof the diff routine\n-    lappend list_a $target\n-\n-    while { [gets $file_a line] != $eof } {\n-\tif [regexp \"^#.*$\" $line] then {\n-\t    continue\n-\t} else {\n-\t    lappend list_a $line\n-\t}\n-    }\n-    close $file_a\n-\n-    # spoof the diff routine\n-    lappend list_b $target\n-\n-    while { [gets $file_b line] != $eof } {\n-\tif [regexp \"^#.*$\" $line] then {\n-\t    continue\n-\t} else {\n-\t    # use [file tail $line] to strip off pathname\n-\t    lappend list_b [file tail $line]\n-\t}\n-    }\n-    close $file_b\n-    \n-    for { set i 0 } { $i < [llength $list_a] } { incr i } {\n-\tset line_a [lindex $list_a $i]\n-\tset line_b [lindex $list_b $i]\n-\t\n-\tif [string compare $line_a $line_b] then {\n-\t    set errno 1\n-\t    set count [expr $i+1]\n-\t    set linenum [format %dc%d $count $count]\n-\t    verbose \"$linenum\" 3\t    \n-\t    verbose \"< $line_a\" 3\n-\t    verbose \"---\" 3\n-\t    verbose \"> $line_b\" 3\n-\t    \n-\t    send_log \"$file_1: < $count: $line_a\\n\"\n-\t    send_log \"$file_2: > $count: $line_b\\n\"\n-\t    set result \"differences found\"\n-\t}\n-    }\n-    return\n-}\n-\n-#\n-# chill_fail\n-#\ta wrapper around the framework fail proc\n-#\n-proc chill_fail { target result } {\n-    global verbose\n-\n-    if { $verbose == 1 } then { send_user \"\\n\" }\n-    fail $target\n-    verbose \"--------------------------------------------------\" 3\n-    verbose \"### RESULT: $result\" 3\n-}\n-\n-#\n-# chill_pass\n-#       a wrapper around the framework fail proc\n-#\n-proc chill_pass { target } {\n-    global verbose\n-\n-    if { $verbose == 1 } then { send_user \"\\n\" }\n-    pass $target\n-}"}, {"sha": "2d1299b985b31345bc1cd5d0dc4121b223e53b4a", "filename": "maintainer-scripts/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07cdae91c9e7e8cc31ac231105bdd694bd24d3e7/maintainer-scripts%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07cdae91c9e7e8cc31ac231105bdd694bd24d3e7/maintainer-scripts%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/maintainer-scripts%2FChangeLog?ref=07cdae91c9e7e8cc31ac231105bdd694bd24d3e7", "patch": "@@ -1,3 +1,8 @@\n+2002-04-15  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* gcc_release (build_tarfiles): Do not build Chill tarfiles.\n+\t(CHILL_DIRS): Remove.\n+\n 2002-03-10  Joseph S. Myers  <jsm28@cam.ac.uk>\n \n \t* gcc_release: Build diffs for ada and chill.  Make \"bzip2\" a new"}, {"sha": "67bc794ec63e5e51bf66236c35e01b3c472f1daf", "filename": "maintainer-scripts/gcc_release", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07cdae91c9e7e8cc31ac231105bdd694bd24d3e7/maintainer-scripts%2Fgcc_release", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07cdae91c9e7e8cc31ac231105bdd694bd24d3e7/maintainer-scripts%2Fgcc_release", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/maintainer-scripts%2Fgcc_release?ref=07cdae91c9e7e8cc31ac231105bdd694bd24d3e7", "patch": "@@ -268,7 +268,6 @@ build_tarfiles() {\n \n   # Now, build one for each of the languages.\n   build_tarfile gcc-ada-${RELEASE} ${ADA_DIRS}\n-  build_tarfile gcc-chill-${RELEASE} ${CHILL_DIRS}\n   build_tarfile gcc-g++-${RELEASE} ${CPLUSPLUS_DIRS}\n   build_tarfile gcc-g77-${RELEASE} ${FORTRAN_DIRS}\n   build_tarfile gcc-java-${RELEASE} ${JAVA_DIRS}\n@@ -277,7 +276,7 @@ build_tarfiles() {\n    \n   # The core is everything else.\n   EXCLUDES=\"\"\n-  for x in ${ADA_DIRS} ${CHILL_DIRS} ${CPLUSPLUS_DIRS} ${FORTRAN_DIRS} \\\n+  for x in ${ADA_DIRS} ${CPLUSPLUS_DIRS} ${FORTRAN_DIRS} \\\n \t   ${JAVA_DIRS} ${OBJECTIVEC_DIRS} ${TESTSUITE_DIRS}; do\n     EXCLUDES=\"${EXCLUDES} --exclude $x\"\n   done\n@@ -410,7 +409,6 @@ SOURCE_DIRECTORY=\"\"\n # The directories that should be part of the various language-specific\n # tar files.  These are all relative to the top of the source tree.\n ADA_DIRS=\"gcc/ada\"\n-CHILL_DIRS=\"gcc/ch libchill\"\n CPLUSPLUS_DIRS=\"gcc/cp libstdc++-v3\"\n FORTRAN_DIRS=\"gcc/f libf2c\"\n JAVA_DIRS=\"gcc/java libjava libffi fastjar zlib boehm-gc\"\n@@ -540,7 +538,6 @@ SOURCE_DIRECTORY=\"${WORKING_DIRECTORY}/gcc-${RELEASE}\"\n # Recompute the names of all the language-specific directories,\n # relative to the WORKING_DIRECTORY.\n ADA_DIRS=`adjust_dirs ${ADA_DIRS}`\n-CHILL_DIRS=`adjust_dirs ${CHILL_DIRS}`\n CPLUSPLUS_DIRS=`adjust_dirs ${CPLUSPLUS_DIRS}`\n FORTRAN_DIRS=`adjust_dirs ${FORTRAN_DIRS}`\n JAVA_DIRS=`adjust_dirs ${JAVA_DIRS}`"}]}