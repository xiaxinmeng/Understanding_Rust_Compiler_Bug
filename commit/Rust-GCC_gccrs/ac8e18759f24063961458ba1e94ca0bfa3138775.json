{"sha": "ac8e18759f24063961458ba1e94ca0bfa3138775", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWM4ZTE4NzU5ZjI0MDYzOTYxNDU4YmExZTk0Y2EwYmZhMzEzODc3NQ==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2011-05-26T13:01:48Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2011-05-26T13:01:48Z"}, "message": "re PR tree-optimization/48702 (optimization regression with gcc-4.6 on x86_64-unknown-linux-gnu)\n\n2011-05-26  Richard Guenther  <rguenther@suse.de>\n\n\tPR tree-optimization/48702\n\t* tree-ssa-address.c (create_mem_ref_raw): Create MEM_REFs\n\tonly when we know the base address is within bounds.\n\t* tree-ssa-alias.c (indirect_ref_may_alias_decl_p): Do not\n\tassume the base address of TARGET_MEM_REFs is in bounds.\n\n\t* gcc.dg/torture/pr48702.c: New testcase.\n\nFrom-SVN: r174282", "tree": {"sha": "6ba8d1096dc8083667067ab711fce8126259c02e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6ba8d1096dc8083667067ab711fce8126259c02e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ac8e18759f24063961458ba1e94ca0bfa3138775", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac8e18759f24063961458ba1e94ca0bfa3138775", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac8e18759f24063961458ba1e94ca0bfa3138775", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac8e18759f24063961458ba1e94ca0bfa3138775/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7e32e6521aa6f699ddc1a00af5f38ceae120cb17", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e32e6521aa6f699ddc1a00af5f38ceae120cb17", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e32e6521aa6f699ddc1a00af5f38ceae120cb17"}], "stats": {"total": 76, "additions": 70, "deletions": 6}, "files": [{"sha": "ed1dda3f56de4064a10af4ce6f055310f410ac69", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac8e18759f24063961458ba1e94ca0bfa3138775/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac8e18759f24063961458ba1e94ca0bfa3138775/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ac8e18759f24063961458ba1e94ca0bfa3138775", "patch": "@@ -1,3 +1,11 @@\n+2011-05-26  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/48702\n+\t* tree-ssa-address.c (create_mem_ref_raw): Create MEM_REFs\n+\tonly when we know the base address is within bounds.\n+\t* tree-ssa-alias.c (indirect_ref_may_alias_decl_p): Do not\n+\tassume the base address of TARGET_MEM_REFs is in bounds.\n+\n 2011-05-26  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \tPR target/49099"}, {"sha": "089406dec33889d7d28d6e6515c6231b9df93dca", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac8e18759f24063961458ba1e94ca0bfa3138775/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac8e18759f24063961458ba1e94ca0bfa3138775/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ac8e18759f24063961458ba1e94ca0bfa3138775", "patch": "@@ -1,3 +1,8 @@\n+2011-05-26  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/48702\n+\t* gcc.dg/torture/pr48702.c: New testcase.\n+\n 2011-05-26  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \tPR gcov-profile/48845"}, {"sha": "1ec371da8e485685631133cbe294ca5c964c72ee", "filename": "gcc/testsuite/gcc.dg/torture/pr48702.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac8e18759f24063961458ba1e94ca0bfa3138775/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr48702.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac8e18759f24063961458ba1e94ca0bfa3138775/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr48702.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr48702.c?ref=ac8e18759f24063961458ba1e94ca0bfa3138775", "patch": "@@ -0,0 +1,47 @@\n+/* { dg-do run } */\n+\n+extern void abort (void);\n+\n+#define LEN 4\n+\n+static inline void unpack(int  array[LEN])\n+{\n+  int ii, val;\n+  val = 1;\n+  for (ii = 0; ii < LEN; ii++) {\n+      array[ii] = val % 2;\n+      val = val / 2;\n+  }\n+}\n+\n+static inline int  pack(int  array[LEN])\n+{\n+  int ans, ii;\n+  ans = 0;\n+  for (ii = LEN-1; ii >= 0; ii--) {\n+      ans = 2 * ans + array[ii];\n+  }\n+  return ans;\n+}\n+\n+int __attribute__((noinline))\n+foo()\n+{\n+  int temp, ans;\n+  int array[LEN];\n+  unpack(array);\n+  temp = array[0];\n+  array[0] = array[2];\n+  array[2] = temp;\n+  ans = pack(array);\n+  return ans;\n+}\n+\n+int main(void)\n+{\n+  int val;\n+  val = foo();\n+  if (val != 4)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "2e6eabc8ccbfa27a8fdf7b21b9224612de6d2668", "filename": "gcc/tree-ssa-address.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac8e18759f24063961458ba1e94ca0bfa3138775/gcc%2Ftree-ssa-address.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac8e18759f24063961458ba1e94ca0bfa3138775/gcc%2Ftree-ssa-address.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-address.c?ref=ac8e18759f24063961458ba1e94ca0bfa3138775", "patch": "@@ -361,8 +361,11 @@ create_mem_ref_raw (tree type, tree alias_ptr_type, struct mem_address *addr,\n       index2 = addr->base;\n     }\n \n-  /* If possible use a plain MEM_REF instead of a TARGET_MEM_REF.  */\n-  if (alias_ptr_type\n+  /* If possible use a plain MEM_REF instead of a TARGET_MEM_REF.\n+     ???  As IVOPTs does not follow restrictions to where the base\n+     pointer may point to create a MEM_REF only if we know that\n+     base is valid.  */\n+  if (TREE_CODE (base) == ADDR_EXPR\n       && (!index2 || integer_zerop (index2))\n       && (!addr->index || integer_zerop (addr->index)))\n     return fold_build2 (MEM_REF, type, base, addr->offset);"}, {"sha": "02b3ca07e07b548e4c2e686b1fe4b71efb15d8ff", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac8e18759f24063961458ba1e94ca0bfa3138775/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac8e18759f24063961458ba1e94ca0bfa3138775/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=ac8e18759f24063961458ba1e94ca0bfa3138775", "patch": "@@ -745,11 +745,12 @@ indirect_ref_may_alias_decl_p (tree ref1 ATTRIBUTE_UNUSED, tree base1,\n      the pointer access is beyond the extent of the variable access.\n      (the pointer base cannot validly point to an offset less than zero\n      of the variable).\n-     They also cannot alias if the pointer may not point to the decl.  */\n-  if ((TREE_CODE (base1) != TARGET_MEM_REF\n-       || (!TMR_INDEX (base1) && !TMR_INDEX2 (base1)))\n+     ???  IVOPTs creates bases that do not honor this restriction,\n+     so do not apply this optimization for TARGET_MEM_REFs.  */\n+  if (TREE_CODE (base1) != TARGET_MEM_REF\n       && !ranges_overlap_p (MAX (0, offset1p), -1, offset2p, max_size2))\n     return false;\n+  /* They also cannot alias if the pointer may not point to the decl.  */\n   if (!ptr_deref_may_alias_decl_p (ptr1, base2))\n     return false;\n \n@@ -799,7 +800,7 @@ indirect_ref_may_alias_decl_p (tree ref1 ATTRIBUTE_UNUSED, tree base1,\n   if (!ref2)\n     return true;\n \n-  /* If the decl is accressed via a MEM_REF, reconstruct the base\n+  /* If the decl is accessed via a MEM_REF, reconstruct the base\n      we can use for TBAA and an appropriately adjusted offset.  */\n   dbase2 = ref2;\n   while (handled_component_p (dbase2))"}]}