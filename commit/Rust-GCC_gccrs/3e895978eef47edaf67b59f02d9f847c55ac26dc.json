{"sha": "3e895978eef47edaf67b59f02d9f847c55ac26dc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2U4OTU5NzhlZWY0N2VkYWY2N2I1OWYwMmQ5Zjg0N2M1NWFjMjZkYw==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2003-01-22T20:51:55Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2003-01-22T20:51:55Z"}, "message": "gcj.texi (Input and output files): Mention non-class entries.\n\n\t* gcj.texi (Input and output files): Mention non-class entries.\n\t* decl.c (java_init_decl_processing): Call\n\tinit_resource_processing.\n\t* java-tree.h (compile_resource_data, write_resource_constructor,\n\tcompile_resource_file, init_resource_processing): Declare.\n\t* config-lang.in (gtfiles): Added resource.c.\n\t* Make-lang.in (gt-java-resource.h): New target.\n\t(JAVA_OBJS): Added resource.o.\n\t(java/resource.o): New target.\n\t* resource.c: New file.\n\t* class.c (compile_resource_file): Moved to resource.c.\n\t(registerResource_libfunc): Likewise.\n\t(utf8_decl_list): Mark with GTY; now static.\n\t* jcf-parse.c (classify_zip_file): New function.\n\t(parse_zip_file_entries): Use it; compile .properties files.\n\t(process_zip_dir): Use classify_zip_file and compute_class_name.\n\tDon't write class name into zip directory.\n\t(java_parse_file): Call write_resource_constructor.\n\t(compute_class_name): New function.\n\t* jcf-io.c (read_zip_member): Reindented.\n\nFrom-SVN: r61614", "tree": {"sha": "b7d7c4804e0025ba42eee223253a8402fbee444d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b7d7c4804e0025ba42eee223253a8402fbee444d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3e895978eef47edaf67b59f02d9f847c55ac26dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e895978eef47edaf67b59f02d9f847c55ac26dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3e895978eef47edaf67b59f02d9f847c55ac26dc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e895978eef47edaf67b59f02d9f847c55ac26dc/comments", "author": null, "committer": null, "parents": [{"sha": "7e657a61177515aa1836f3f168c7765096f74610", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e657a61177515aa1836f3f168c7765096f74610", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e657a61177515aa1836f3f168c7765096f74610"}], "stats": {"total": 637, "additions": 434, "deletions": 203}, "files": [{"sha": "bdb9917d6cb73fdcf777e007ea153b7a8f7432ec", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e895978eef47edaf67b59f02d9f847c55ac26dc/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e895978eef47edaf67b59f02d9f847c55ac26dc/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=3e895978eef47edaf67b59f02d9f847c55ac26dc", "patch": "@@ -1,3 +1,26 @@\n+2003-01-22  Tom Tromey  <tromey@redhat.com>\n+\n+\t* gcj.texi (Input and output files): Mention non-class entries.\n+\t* decl.c (java_init_decl_processing): Call\n+\tinit_resource_processing.\n+\t* java-tree.h (compile_resource_data, write_resource_constructor,\n+\tcompile_resource_file, init_resource_processing): Declare.\n+\t* config-lang.in (gtfiles): Added resource.c.\n+\t* Make-lang.in (gt-java-resource.h): New target.\n+\t(JAVA_OBJS): Added resource.o.\n+\t(java/resource.o): New target.\n+\t* resource.c: New file.\n+\t* class.c (compile_resource_file): Moved to resource.c.\n+\t(registerResource_libfunc): Likewise.\n+\t(utf8_decl_list): Mark with GTY; now static.\n+\t* jcf-parse.c (classify_zip_file): New function.\n+\t(parse_zip_file_entries): Use it; compile .properties files.\n+\t(process_zip_dir): Use classify_zip_file and compute_class_name.\n+\tDon't write class name into zip directory.\n+\t(java_parse_file): Call write_resource_constructor.\n+\t(compute_class_name): New function.\n+\t* jcf-io.c (read_zip_member): Reindented.\n+\n 2003-01-21  Tom Tromey  <tromey@redhat.com>\n \n \t* class.c (supers_all_compiled): New function."}, {"sha": "fc930232051bbbc69b84d3866defbc74c7e70740", "filename": "gcc/java/Make-lang.in", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e895978eef47edaf67b59f02d9f847c55ac26dc/gcc%2Fjava%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e895978eef47edaf67b59f02d9f847c55ac26dc/gcc%2Fjava%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FMake-lang.in?ref=3e895978eef47edaf67b59f02d9f847c55ac26dc", "patch": "@@ -102,13 +102,13 @@ $(srcdir)/java/keyword.h: $(srcdir)/java/keyword.gperf\n gt-java-class.h gt-java-constants.h gt-java-decl.h : s-gtype ; @true\n gt-java-expr.h gt-java-jcf-parse.h gt-java-jcf-write.h : s-gtype ; @true\n gt-java-lang.h gt-java-mangle.h gt-java-parse.h : s-gtype ; @true\n-gt-java-builtins.h gtype-java.h : s-gtype ; @true\n+gt-java-builtins.h gtype-java.h gt-java-resource.h : s-gtype ; @true\n \n # Executables built by this Makefile:\n JAVA_OBJS = java/parse.o java/class.o java/decl.o java/expr.o \\\n   java/constants.o java/lang.o java/typeck.o java/except.o java/verify.o \\\n   java/zextract.o java/jcf-io.o java/jcf-parse.o java/mangle.o \\\n-  java/mangle_name.o java/builtins.o \\\n+  java/mangle_name.o java/builtins.o java/resource.o \\\n   java/jcf-write.o java/buffer.o java/check-init.o java/jcf-depend.o \\\n   java/jcf-path.o java/xref.o java/boehm.o java/java-tree-inline.o mkdeps.o\n \n@@ -324,6 +324,9 @@ java/mangle_name.o: java/mangle_name.c $(CONFIG_H) java/jcf.h $(JAVA_TREE_H) \\\n   $(SYSTEM_H) coretypes.h $(TM_H) toplev.h $(GGC_H)\n java/parse-scan.o: $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) toplev.h \\\n   $(JAVA_LEX_C) java/parse.h java/lex.h\n+java/resource.o: java/resource.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n+  $(JAVA_TREE_H) $(RTL_H) java/jcf.h java/parse.h toplev.h output.h $(GGC_H) \\\n+  $(TARGET_H) function.h gt-java-resource.h\n java/typeck.o: java/typeck.c $(CONFIG_H) $(JAVA_TREE_H) java/jcf.h \\\n   java/convert.h toplev.h $(SYSTEM_H) coretypes.h $(TM_H) $(GGC_H) real.h\n java/verify.o: java/verify.c $(CONFIG_H) $(JAVA_TREE_H) java/jcf.h \\"}, {"sha": "d0953cce4ed2024784f3001fe35cb285ffdcdb79", "filename": "gcc/java/class.c", "status": "modified", "additions": 1, "deletions": 108, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e895978eef47edaf67b59f02d9f847c55ac26dc/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e895978eef47edaf67b59f02d9f847c55ac26dc/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=3e895978eef47edaf67b59f02d9f847c55ac26dc", "patch": "@@ -61,7 +61,6 @@ static int assume_compiled (const char *);\n static tree build_method_symbols_entry (tree);\n \n static GTY(()) rtx registerClass_libfunc;\n-static GTY(()) rtx registerResource_libfunc;\n \n struct obstack temporary_obstack;\n \n@@ -742,111 +741,7 @@ hashUtf8String (const char *str, int len)\n   return hash;\n }\n \n-/* Generate a byte array representing the contents of FILENAME.  The\n-   array is assigned a unique local symbol.  The array represents a\n-   compiled Java resource, which is accessed by the runtime using\n-   NAME.  */\n-void\n-compile_resource_file (char *name, const char *filename)\n-{\n-  struct stat stat_buf;\n-  int fd;\n-  char *buffer;\n-  char buf[60];\n-  tree rtype, field = NULL_TREE, data_type, rinit, data, decl;\n-  static int Jr_count = 0;\n-\n-  fd = open (filename, O_RDONLY | O_BINARY);\n-  if (fd < 0)\n-    {\n-      perror (\"Failed to read resource file\");\n-      return;\n-    }\n-  if (fstat (fd, &stat_buf) != 0\n-      || ! S_ISREG (stat_buf.st_mode))\n-    {\n-      perror (\"Could not figure length of resource file\");\n-      return;\n-    }\n-  buffer = xmalloc (strlen (name) + stat_buf.st_size);\n-  strcpy (buffer, name);\n-  read (fd, buffer + strlen (name), stat_buf.st_size);\n-  close (fd);\n-  data_type = build_prim_array_type (unsigned_byte_type_node,\n-\t\t\t\t     strlen (name) + stat_buf.st_size);\n-  rtype = make_node (RECORD_TYPE);\n-  PUSH_FIELD (rtype, field, \"name_length\", unsigned_int_type_node);\n-  PUSH_FIELD (rtype, field, \"resource_length\", unsigned_int_type_node);\n-  PUSH_FIELD (rtype, field, \"data\", data_type);\n-  FINISH_RECORD (rtype);\n-  START_RECORD_CONSTRUCTOR (rinit, rtype);\n-  PUSH_FIELD_VALUE (rinit, \"name_length\", \n-\t\t    build_int_2 (strlen (name), 0));\n-  PUSH_FIELD_VALUE (rinit, \"resource_length\", \n-\t\t    build_int_2 (stat_buf.st_size, 0));\n-  data = build_string (strlen(name) + stat_buf.st_size, buffer);\n-  TREE_TYPE (data) = data_type;\n-  PUSH_FIELD_VALUE (rinit, \"data\", data);\n-  FINISH_RECORD_CONSTRUCTOR (rinit);\n-  TREE_CONSTANT (rinit) = 1;\n-\n-  /* Generate a unique-enough identifier.  */\n-  sprintf(buf, \"_Jr%d\", ++Jr_count);\n-\n-  decl = build_decl (VAR_DECL, get_identifier (buf), rtype);\n-  TREE_STATIC (decl) = 1;\n-  DECL_ARTIFICIAL (decl) = 1;\n-  DECL_IGNORED_P (decl) = 1;\n-  TREE_READONLY (decl) = 1;\n-  TREE_THIS_VOLATILE (decl) = 0;\n-  DECL_INITIAL (decl) = rinit;\n-  layout_decl (decl, 0);\n-  pushdecl (decl);\n-  rest_of_decl_compilation (decl, (char*) 0, global_bindings_p (), 0);\n-  make_decl_rtl (decl, (char*) 0);\n-  assemble_variable (decl, 1, 0, 0);\n-\n-  {\n-    tree init_name = get_file_function_name ('I');\n-    tree init_type = build_function_type (void_type_node, end_params_node);\n-    tree init_decl;\n-    \n-    init_decl = build_decl (FUNCTION_DECL, init_name, init_type);\n-    SET_DECL_ASSEMBLER_NAME (init_decl, init_name);\n-    TREE_STATIC (init_decl) = 1;\n-    current_function_decl = init_decl;\n-    DECL_RESULT (init_decl) = build_decl (RESULT_DECL, \n-\t\t\t\t\t  NULL_TREE, void_type_node);\n-\n-    /* It can be a static function as long as collect2 does not have\n-       to scan the object file to find its ctor/dtor routine.  */\n-    TREE_PUBLIC (init_decl) = ! targetm.have_ctors_dtors;\n-\n-    pushlevel (0);\n-    make_decl_rtl (init_decl, NULL);\n-    init_function_start (init_decl, input_filename, 0);\n-    expand_function_start (init_decl, 0);\n-    \n-    emit_library_call (registerResource_libfunc, 0, VOIDmode, 1,\n-\t\t       gen_rtx (SYMBOL_REF, Pmode, buf), \n-\t\t       Pmode);\n-    \n-    expand_function_end (input_filename, 0, 0);\n-    poplevel (1, 0, 1);\n-    { \n-      /* Force generation, even with -O3 or deeper. Gross hack. FIXME */\n-      int saved_flag = flag_inline_functions;\n-      flag_inline_functions = 0;\t\n-      rest_of_compilation (init_decl);\n-      flag_inline_functions = saved_flag;\n-    }\n-    current_function_decl = NULL_TREE;\n-    (* targetm.asm_out.constructor) (XEXP (DECL_RTL (init_decl), 0),\n-\t\t\t\t     DEFAULT_INIT_PRIORITY);\n-  }     \n-}\n-\n-tree utf8_decl_list = NULL_TREE;\n+static GTY(()) tree utf8_decl_list = NULL_TREE;\n \n tree\n build_utf8_ref (tree name)\n@@ -2209,8 +2104,6 @@ void\n init_class_processing (void)\n {\n   registerClass_libfunc = gen_rtx_SYMBOL_REF (Pmode, \"_Jv_RegisterClass\");\n-  registerResource_libfunc = \n-    gen_rtx_SYMBOL_REF (Pmode, \"_Jv_RegisterResource\");\n   fields_ident = get_identifier (\"fields\");\n   info_ident = get_identifier (\"info\");\n   gcc_obstack_init (&temporary_obstack);"}, {"sha": "41c5f915a71e11eada1da4c0fc3ca4966f7f8560", "filename": "gcc/java/config-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e895978eef47edaf67b59f02d9f847c55ac26dc/gcc%2Fjava%2Fconfig-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e895978eef47edaf67b59f02d9f847c55ac26dc/gcc%2Fjava%2Fconfig-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fconfig-lang.in?ref=3e895978eef47edaf67b59f02d9f847c55ac26dc", "patch": "@@ -36,7 +36,7 @@ compilers=\"jc1\\$(exeext) jvgenmain\\$(exeext)\"\n \n stagestuff=\"jc1\\$(exeext) gcj\\$(exeext) jvgenmain\\$(exeext) gcjh\\$(exeext) jv-scan\\$(exeext) jcf-dump\\$(exeext)\"\n \n-gtfiles=\"\\$(srcdir)/java/java-tree.h \\$(srcdir)/java/jcf.h \\$(srcdir)/java/lex.h \\$(srcdir)/java/parse.h \\$(srcdir)/java/builtins.c \\$(srcdir)/java/class.c \\$(srcdir)/java/constants.c \\$(srcdir)/java/decl.c \\$(srcdir)/java/expr.c \\$(srcdir)/java/jcf-parse.c \\$(srcdir)/java/jcf-write.c \\$(srcdir)/java/lang.c \\$(srcdir)/java/mangle.c \\$(srcdir)/java/parse.y\"\n+gtfiles=\"\\$(srcdir)/java/java-tree.h \\$(srcdir)/java/jcf.h \\$(srcdir)/java/lex.h \\$(srcdir)/java/parse.h \\$(srcdir)/java/builtins.c \\$(srcdir)/java/class.c \\$(srcdir)/java/constants.c \\$(srcdir)/java/decl.c \\$(srcdir)/java/expr.c \\$(srcdir)/java/jcf-parse.c \\$(srcdir)/java/jcf-write.c \\$(srcdir)/java/lang.c \\$(srcdir)/java/mangle.c \\$(srcdir)/java/parse.y \\$(srcdir)/java/resource.c\"\n \n target_libs=${libgcj_saved}\n lang_dirs=\"zlib fastjar\""}, {"sha": "218d4baae925cc676425cd6c2800edd0d4bb161c", "filename": "gcc/java/decl.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e895978eef47edaf67b59f02d9f847c55ac26dc/gcc%2Fjava%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e895978eef47edaf67b59f02d9f847c55ac26dc/gcc%2Fjava%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fdecl.c?ref=3e895978eef47edaf67b59f02d9f847c55ac26dc", "patch": "@@ -397,6 +397,7 @@ java_init_decl_processing (void)\n   tree t;\n \n   init_class_processing ();\n+  init_resource_processing ();\n \n   current_function_decl = NULL;\n   current_binding_level = NULL_BINDING_LEVEL;"}, {"sha": "dcfefb7df230b7f1a25c46f57d697d6fd3d40fae", "filename": "gcc/java/except.c", "status": "modified", "additions": 29, "deletions": 4, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e895978eef47edaf67b59f02d9f847c55ac26dc/gcc%2Fjava%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e895978eef47edaf67b59f02d9f847c55ac26dc/gcc%2Fjava%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexcept.c?ref=3e895978eef47edaf67b59f02d9f847c55ac26dc", "patch": "@@ -324,10 +324,35 @@ prepare_eh_table_type (tree type)\n   else if (is_compiled_class (type))\n     exp = build_class_ref (type);\n   else\n-    exp = fold (build \n-\t\t(PLUS_EXPR, ptr_type_node,\n-\t\t build_utf8_ref (DECL_NAME (TYPE_NAME (type))),\n-\t\t size_one_node));\n+    {\n+      tree ctype = make_node (RECORD_TYPE);\n+      tree field = NULL_TREE;\n+      tree cinit, decl;\n+      tree utf8_ref = build_utf8_ref (DECL_NAME (TYPE_NAME (type)));\n+      char buf[64];\n+      sprintf (buf, \"%s_ref\", \n+\t       IDENTIFIER_POINTER (DECL_NAME (TREE_OPERAND (utf8_ref, 0))));\n+      PUSH_FIELD (ctype, field, \"dummy\", ptr_type_node);\n+      PUSH_FIELD (ctype, field, \"utf8\",  utf8const_ptr_type);\n+      FINISH_RECORD (ctype);\n+      START_RECORD_CONSTRUCTOR (cinit, ctype);\n+      PUSH_FIELD_VALUE (cinit, \"dummy\", integer_minus_one_node);\n+      PUSH_FIELD_VALUE (cinit, \"utf8\", utf8_ref);\n+      FINISH_RECORD_CONSTRUCTOR (cinit);\n+      TREE_CONSTANT (cinit) = 1;\n+      decl = build_decl (VAR_DECL, get_identifier (buf), utf8const_type);\n+      TREE_STATIC (decl) = 1;\n+      DECL_ARTIFICIAL (decl) = 1;\n+      DECL_IGNORED_P (decl) = 1;\n+      TREE_READONLY (decl) = 1;\n+      TREE_THIS_VOLATILE (decl) = 0;\n+      DECL_INITIAL (decl) = cinit;\n+      layout_decl (decl, 0);\n+      pushdecl (decl);\n+      rest_of_decl_compilation (decl, (char*) 0, global_bindings_p (), 0);\n+      make_decl_rtl (decl, (char*) 0);\n+      exp = build1 (ADDR_EXPR, utf8const_ptr_type, decl);\n+    }\n   return exp;\n }\n "}, {"sha": "f9518d7bd64433e2c2205db418e1930d49394e28", "filename": "gcc/java/gcj.texi", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e895978eef47edaf67b59f02d9f847c55ac26dc/gcc%2Fjava%2Fgcj.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e895978eef47edaf67b59f02d9f847c55ac26dc/gcc%2Fjava%2Fgcj.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fgcj.texi?ref=3e895978eef47edaf67b59f02d9f847c55ac26dc", "patch": "@@ -182,7 +182,10 @@ Java bytecode files.\n @item @var{file}.zip\n @itemx @var{file}.jar\n An archive containing one or more @code{.class} files, all of\n-which are compiled.  The archive may be compressed.\n+which are compiled.  The archive may be compressed.  Files in\n+an archive which don't end with @samp{.class} are treated as\n+resource files; they are copmiled into the resulting object file\n+as @samp{core:} URLs.\n @item @@@var{file}\n A file containing a whitespace-separated list of input file names.\n (Currently, these must all be @code{.java} source files, but that"}, {"sha": "ccedb9a2e6d460b1aba1593ab50162bdf3acd6c8", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e895978eef47edaf67b59f02d9f847c55ac26dc/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e895978eef47edaf67b59f02d9f847c55ac26dc/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=3e895978eef47edaf67b59f02d9f847c55ac26dc", "patch": "@@ -1299,6 +1299,13 @@ struct rtx_def * java_expand_expr (tree, rtx, enum machine_mode, int);\n extern void java_inlining_merge_static_initializers (tree, void *);\n extern void java_inlining_map_static_initializers (tree, void *);\n \n+extern void compile_resource_data PARAMS ((char *name, const char *buffer,\n+\t\t\t\t\t   int length));\n+extern void write_resource_constructor PARAMS ((void));\n+extern void compile_resource_file PARAMS ((char *name, const char *filename));\n+extern void init_resource_processing PARAMS ((void));\n+\n+\n #define DECL_FINAL(DECL) DECL_LANG_FLAG_3 (DECL)\n \n /* Access flags etc for a method (a FUNCTION_DECL): */"}, {"sha": "5d6ef25d8ba7456d97a68600569286514fde989c", "filename": "gcc/java/jcf-io.c", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e895978eef47edaf67b59f02d9f847c55ac26dc/gcc%2Fjava%2Fjcf-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e895978eef47edaf67b59f02d9f847c55ac26dc/gcc%2Fjava%2Fjcf-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-io.c?ref=3e895978eef47edaf67b59f02d9f847c55ac26dc", "patch": "@@ -186,48 +186,48 @@ open_in_zip (JCF *jcf, const char *zipfile, const char *zipmember,\n int\n read_zip_member (JCF *jcf,  ZipDirectory *zipd, ZipFile *zipf)\n {\n-\t  jcf->filbuf = jcf_unexpected_eof;\n-\t  jcf->zipd = (void *)zipd;\n+  jcf->filbuf = jcf_unexpected_eof;\n+  jcf->zipd = (void *)zipd;\n \n-\t  if (zipd->compression_method == Z_NO_COMPRESSION)\n-\t    {\n-\t      jcf->buffer = ALLOC (zipd->size);\n-\t      jcf->buffer_end = jcf->buffer + zipd->size;\n-\t      jcf->read_ptr = jcf->buffer;\n-\t      jcf->read_end = jcf->buffer_end;\n-\t      if (lseek (zipf->fd, zipd->filestart, 0) < 0\n-\t\t  || read (zipf->fd, jcf->buffer, zipd->size) != (long) zipd->size)\n-\t        return -2;\n-\t    }\n-\t  else\n-\t    {\n-\t      char *buffer;\n-\t      z_stream d_stream; /* decompression stream */\n-\t      d_stream.zalloc = (alloc_func) 0;\n-\t      d_stream.zfree = (free_func) 0;\n-\t      d_stream.opaque = (voidpf) 0;\n-\n-\t      jcf->buffer = ALLOC (zipd->uncompressed_size);\n-\t      d_stream.next_out = jcf->buffer;\n-\t      d_stream.avail_out = zipd->uncompressed_size;\n-\t      jcf->buffer_end = jcf->buffer + zipd->uncompressed_size;\n-\t      jcf->read_ptr = jcf->buffer;\n-\t      jcf->read_end = jcf->buffer_end;\n-\t      buffer = ALLOC (zipd->size);\n-\t      d_stream.next_in = buffer;\n-\t      d_stream.avail_in = zipd->size;\n-\t      if (lseek (zipf->fd, zipd->filestart, 0) < 0\n-\t\t  || read (zipf->fd, buffer, zipd->size) != (long) zipd->size)\n-\t\treturn -2;\n-\t      /* Handle NO_HEADER using undocumented zlib feature.\n-                 This is a very common hack.  */\n-\t      inflateInit2 (&d_stream, -MAX_WBITS);\n-\t      inflate (&d_stream, Z_NO_FLUSH);\n-\t      inflateEnd (&d_stream);\n-\t      FREE (buffer);\n-\t    }\n+  if (zipd->compression_method == Z_NO_COMPRESSION)\n+    {\n+      jcf->buffer = ALLOC (zipd->size);\n+      jcf->buffer_end = jcf->buffer + zipd->size;\n+      jcf->read_ptr = jcf->buffer;\n+      jcf->read_end = jcf->buffer_end;\n+      if (lseek (zipf->fd, zipd->filestart, 0) < 0\n+\t  || read (zipf->fd, jcf->buffer, zipd->size) != (long) zipd->size)\n+\treturn -2;\n+    }\n+  else\n+    {\n+      char *buffer;\n+      z_stream d_stream; /* decompression stream */\n+      d_stream.zalloc = (alloc_func) 0;\n+      d_stream.zfree = (free_func) 0;\n+      d_stream.opaque = (voidpf) 0;\n+\n+      jcf->buffer = ALLOC (zipd->uncompressed_size);\n+      d_stream.next_out = jcf->buffer;\n+      d_stream.avail_out = zipd->uncompressed_size;\n+      jcf->buffer_end = jcf->buffer + zipd->uncompressed_size;\n+      jcf->read_ptr = jcf->buffer;\n+      jcf->read_end = jcf->buffer_end;\n+      buffer = ALLOC (zipd->size);\n+      d_stream.next_in = buffer;\n+      d_stream.avail_in = zipd->size;\n+      if (lseek (zipf->fd, zipd->filestart, 0) < 0\n+\t  || read (zipf->fd, buffer, zipd->size) != (long) zipd->size)\n+\treturn -2;\n+      /* Handle NO_HEADER using undocumented zlib feature.\n+\t This is a very common hack.  */\n+      inflateInit2 (&d_stream, -MAX_WBITS);\n+      inflate (&d_stream, Z_NO_FLUSH);\n+      inflateEnd (&d_stream);\n+      FREE (buffer);\n+    }\n \n-\t  return 0;\n+  return 0;\n }\n \n const char *"}, {"sha": "a29da453a8b8213ea90200accf7830ff14b97263", "filename": "gcc/java/jcf-parse.c", "status": "modified", "additions": 124, "deletions": 47, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e895978eef47edaf67b59f02d9f847c55ac26dc/gcc%2Fjava%2Fjcf-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e895978eef47edaf67b59f02d9f847c55ac26dc/gcc%2Fjava%2Fjcf-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-parse.c?ref=3e895978eef47edaf67b59f02d9f847c55ac26dc", "patch": "@@ -94,6 +94,8 @@ static struct ZipFile *localToFile;\n /* Declarations of some functions used here.  */\n static void handle_innerclass_attribute (int count, JCF *);\n static tree give_name_to_class (JCF *jcf, int index);\n+static char *compute_class_name (struct ZipDirectory *zdir);\n+static int classify_zip_file (struct ZipDirectory *zdir);\n static void parse_zip_file_entries (void);\n static void process_zip_dir (FILE *);\n static void parse_source_file_1 (tree, FILE *);\n@@ -1012,7 +1014,7 @@ java_parse_file (int set_yydebug ATTRIBUTE_UNUSED)\n       finput = fopen (IDENTIFIER_POINTER (name), \"rb\");\n       if (finput == NULL)\n \tfatal_io_error (\"can't open %s\", IDENTIFIER_POINTER (name));\n-      \n+\n #ifdef IO_BUFFER_SIZE\n       setvbuf (finput, xmalloc (IO_BUFFER_SIZE),\n \t       _IOFBF, IO_BUFFER_SIZE);\n@@ -1047,7 +1049,7 @@ java_parse_file (int set_yydebug ATTRIBUTE_UNUSED)\n \t  if (open_in_zip (main_jcf, input_filename, NULL, 0) <  0)\n \t    fatal_error (\"bad zip/jar file %s\", IDENTIFIER_POINTER (name));\n \t  localToFile = SeenZipFiles;\n-\t  /* Register all the class defined there.  */\n+\t  /* Register all the classes defined there.  */\n \t  process_zip_dir (main_jcf->read_state);\n \t  parse_zip_file_entries ();\n \t  /*\n@@ -1100,6 +1102,51 @@ java_parse_file (int set_yydebug ATTRIBUTE_UNUSED)\n       if (flag_indirect_dispatch)\n \temit_offset_symbol_table ();\n     }\n+\n+  write_resource_constructor ();\n+}\n+\n+/* Return the name of the class corresponding to the name of the file\n+   in this zip entry.  The result is newly allocated using ALLOC.  */\n+static char *\n+compute_class_name (struct ZipDirectory *zdir)\n+{\n+  char *class_name_in_zip_dir = ZIPDIR_FILENAME (zdir);\n+  char *class_name;\n+  int j;\n+\n+  class_name = ALLOC (zdir->filename_length + 1 - 6);\n+  strncpy (class_name, class_name_in_zip_dir, zdir->filename_length - 6);\n+  class_name [zdir->filename_length - 6] = '\\0';\n+  for (j = 0; class_name[j]; ++j)\n+    class_name[j] = class_name[j] == '/' ? '.' : class_name[j];\n+  return class_name;\n+}\n+\n+/* Return 0 if we should skip this entry, 1 if it is a .class file, 2\n+   if it is a property file of some sort.  */\n+static int\n+classify_zip_file (struct ZipDirectory *zdir)\n+{\n+  char *class_name_in_zip_dir = ZIPDIR_FILENAME (zdir);\n+\n+  if (zdir->filename_length > 6\n+      && !strncmp (&class_name_in_zip_dir[zdir->filename_length - 6],\n+\t\t   \".class\", 6))\n+    return 1;\n+\n+  /* For now we drop the manifest and other information.  Maybe it\n+     would make more sense to compile it in?  */\n+  if (zdir->filename_length > 8\n+      && !strncmp (class_name_in_zip_dir, \"META-INF/\", 9))\n+    return 0;\n+\n+  /* Drop directory entries.  */\n+  if (zdir->filename_length > 0\n+      && class_name_in_zip_dir[zdir->filename_length - 1] == '/')\n+    return 0;\n+\n+  return 2;\n }\n \n /* Process all class entries found in the zip file.  */\n@@ -1113,35 +1160,80 @@ parse_zip_file_entries (void)\n        i < localToFile->count; i++, zdir = ZIPDIR_NEXT (zdir))\n     {\n       tree class;\n-      \n-      /* We don't need to consider those files.  */\n-      if (!zdir->size || !zdir->filename_offset)\n-\tcontinue;\n-\n-      class = lookup_class (get_identifier (ZIPDIR_FILENAME (zdir)));\n-      current_jcf = TYPE_JCF (class);\n-      current_class = class;\n \n-      if ( !CLASS_LOADED_P (class))\n+      switch (classify_zip_file (zdir))\n \t{\n-\t  if (! CLASS_PARSED_P (class))\n-\t    {\n-\t      read_zip_member(current_jcf, zdir, localToFile);\n-\t      jcf_parse (current_jcf);\n-\t    }\n-\t  layout_class (current_class);\n-\t  load_inner_classes (current_class);\n-\t}\n+\tcase 0:\n+\t  continue;\n \n-      if (TYPE_SIZE (current_class) != error_mark_node)\n-\t{\n-\t  input_filename = current_jcf->filename;\n-\t  parse_class_file ();\n-\t  FREE (current_jcf->buffer); /* No longer necessary */\n-\t  /* Note: there is a way to free this buffer right after a\n-\t     class seen in a zip file has been parsed. The idea is the\n-\t     set its jcf in such a way that buffer will be reallocated\n-\t     the time the code for the class will be generated. FIXME. */\n+\tcase 1:\n+\t  {\n+\t    char *class_name = compute_class_name (zdir);\n+\t    class = lookup_class (get_identifier (class_name));\n+\t    FREE (class_name);\n+\t    current_jcf = TYPE_JCF (class);\n+\t    current_class = class;\n+\n+\t    if (! CLASS_LOADED_P (class))\n+\t      {\n+\t\tif (! CLASS_PARSED_P (class))\n+\t\t  {\n+\t\t    read_zip_member (current_jcf, zdir, localToFile);\n+\t\t    jcf_parse (current_jcf);\n+\t\t  }\n+\t\tlayout_class (current_class);\n+\t\tload_inner_classes (current_class);\n+\t      }\n+\n+\t    if (TYPE_SIZE (current_class) != error_mark_node)\n+\t      {\n+\t\tinput_filename = current_jcf->filename;\n+\t\tparse_class_file ();\n+\t\tFREE (current_jcf->buffer); /* No longer necessary */\n+\t\t/* Note: there is a way to free this buffer right after a\n+\t\t   class seen in a zip file has been parsed. The idea is the\n+\t\t   set its jcf in such a way that buffer will be reallocated\n+\t\t   the time the code for the class will be generated. FIXME. */\n+\t      }\n+\t  }\n+\t  break;\n+\n+\tcase 2:\n+\t  {\n+\t    char *file_name, *class_name_in_zip_dir, *buffer;\n+\t    JCF *jcf;\n+\t    file_name = ALLOC (zdir->filename_length + 1);\n+\t    class_name_in_zip_dir = ZIPDIR_FILENAME (zdir);\n+\t    strncpy (file_name, class_name_in_zip_dir, zdir->filename_length);\n+\t    file_name[zdir->filename_length] = '\\0';\n+\t    jcf = ALLOC (sizeof (JCF));\n+\t    JCF_ZERO (jcf);\n+\t    jcf->read_state  = finput;\n+\t    jcf->filbuf      = jcf_filbuf_from_stdio;\n+\t    jcf->java_source = 0;\n+\t    jcf->classname   = NULL;\n+\t    jcf->filename    = file_name;\n+\t    jcf->zipd        = zdir;\n+\n+\t    if (read_zip_member (jcf, zdir, localToFile) < 0)\n+\t      fatal_error (\"error while reading %s from zip file\", file_name);\n+\n+\t    buffer = ALLOC (zdir->filename_length + 1 +\n+\t\t\t    (jcf->buffer_end - jcf->buffer));\n+\t    strcpy (buffer, file_name);\n+\t    memcpy (buffer + zdir->filename_length + 1,\n+\t\t    jcf->buffer, jcf->buffer_end - jcf->buffer);\n+\n+\t    compile_resource_data (file_name, buffer,\n+\t\t\t\t   jcf->buffer_end - jcf->buffer);\n+\t    JCF_FINISH (jcf);\n+\t    FREE (jcf);\n+\t    FREE (buffer);\n+\t  }\n+\t  break;\n+\n+\tdefault:\n+\t  abort ();\n \t}\n     }\n }\n@@ -1165,33 +1257,18 @@ process_zip_dir (FILE *finput)\n \n       class_name_in_zip_dir = ZIPDIR_FILENAME (zdir);\n \n-      /* We choose to not to process entries with a zero size or entries\n-\t not bearing the .class extension.  */\n-      if (!zdir->size || !zdir->filename_offset ||\n-\t  strncmp (&class_name_in_zip_dir[zdir->filename_length-6], \n-\t\t   \".class\", 6))\n-\t{\n-\t  /* So it will be skipped in parse_zip_file_entries  */\n-\t  zdir->size = 0;  \n-\t  continue;\n-\t}\n+      /* Here we skip non-class files; we handle them later.  */\n+      if (classify_zip_file (zdir) != 1)\n+\tcontinue;\n \n-      class_name = ALLOC (zdir->filename_length+1-6);\n+      class_name = compute_class_name (zdir);\n       file_name  = ALLOC (zdir->filename_length+1);\n       jcf = ggc_alloc (sizeof (JCF));\n       JCF_ZERO (jcf);\n \n-      strncpy (class_name, class_name_in_zip_dir, zdir->filename_length-6);\n-      class_name [zdir->filename_length-6] = '\\0';\n       strncpy (file_name, class_name_in_zip_dir, zdir->filename_length);\n       file_name [zdir->filename_length] = '\\0';\n \n-      for (j=0; class_name[j]; j++)\n-        class_name [j] = (class_name [j] == '/' ? '.' : class_name [j]);\n-\n-      /* Yes, we write back the true class name into the zip directory.  */\n-      strcpy (class_name_in_zip_dir, class_name);\n-      zdir->filename_length = j;\n       class = lookup_class (get_identifier (class_name));\n \n       jcf->read_state  = finput;"}, {"sha": "3362cc8932244dc5ca6a9014f08232d7acaa13b7", "filename": "gcc/java/resource.c", "status": "added", "additions": 199, "deletions": 0, "changes": 199, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e895978eef47edaf67b59f02d9f847c55ac26dc/gcc%2Fjava%2Fresource.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e895978eef47edaf67b59f02d9f847c55ac26dc/gcc%2Fjava%2Fresource.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fresource.c?ref=3e895978eef47edaf67b59f02d9f847c55ac26dc", "patch": "@@ -0,0 +1,199 @@\n+/* Functions related to building resource files.\n+   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003\n+   Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.\n+\n+Java and all Java-based marks are trademarks or registered trademarks\n+of Sun Microsystems, Inc. in the United States and other countries.\n+The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"tree.h\"\n+#include \"rtl.h\"\n+#include \"flags.h\"\n+#include \"java-tree.h\"\n+#include \"jcf.h\"\n+#include \"obstack.h\"\n+#include \"toplev.h\"\n+#include \"output.h\"\n+#include \"parse.h\"\n+#include \"function.h\"\n+#include \"ggc.h\"\n+#include \"stdio.h\"\n+#include \"target.h\"\n+\n+/* DOS brain-damage */\n+#ifndef O_BINARY\n+#define O_BINARY 0 /* MS-DOS brain-damage */\n+#endif\n+\n+/* A list of all the resources files.  */\n+static GTY(()) tree resources = NULL;\n+\n+/* Function used to register resources.  */\n+static GTY(()) rtx registerResource_libfunc;\n+\n+/* Count of all the resources compiled in this invocation.  */\n+static int Jr_count = 0;\n+\n+void\n+compile_resource_data (name, buffer, length)\n+     char *name;\n+     const char *buffer;\n+     int length;\n+{\n+  tree rtype, field = NULL_TREE, data_type, rinit, data, decl;\n+  char buf[60];\n+\n+  data_type = build_prim_array_type (unsigned_byte_type_node,\n+\t\t\t\t     strlen (name) + length);\n+  rtype = make_node (RECORD_TYPE);\n+  PUSH_FIELD (rtype, field, \"name_length\", unsigned_int_type_node);\n+  PUSH_FIELD (rtype, field, \"resource_length\", unsigned_int_type_node);\n+  PUSH_FIELD (rtype, field, \"data\", data_type);\n+  FINISH_RECORD (rtype);\n+  START_RECORD_CONSTRUCTOR (rinit, rtype);\n+  PUSH_FIELD_VALUE (rinit, \"name_length\", \n+\t\t    build_int_2 (strlen (name), 0));\n+  PUSH_FIELD_VALUE (rinit, \"resource_length\", \n+\t\t    build_int_2 (length, 0));\n+  data = build_string (strlen(name) + length, buffer);\n+  TREE_TYPE (data) = data_type;\n+  PUSH_FIELD_VALUE (rinit, \"data\", data);\n+  FINISH_RECORD_CONSTRUCTOR (rinit);\n+  TREE_CONSTANT (rinit) = 1;\n+\n+  /* Generate a unique-enough identifier.  */\n+  sprintf (buf, \"_Jr%d\", ++Jr_count);\n+\n+  decl = build_decl (VAR_DECL, get_identifier (buf), rtype);\n+  TREE_STATIC (decl) = 1;\n+  DECL_ARTIFICIAL (decl) = 1;\n+  DECL_IGNORED_P (decl) = 1;\n+  TREE_READONLY (decl) = 1;\n+  TREE_THIS_VOLATILE (decl) = 0;\n+  DECL_INITIAL (decl) = rinit;\n+  layout_decl (decl, 0);\n+  pushdecl (decl);\n+  rest_of_decl_compilation (decl, (char*) 0, global_bindings_p (), 0);\n+  make_decl_rtl (decl, (char*) 0);\n+  assemble_variable (decl, 1, 0, 0);\n+\n+  resources = tree_cons (NULL_TREE, decl, resources);\n+}\n+\n+void\n+write_resource_constructor ()\n+{\n+  tree init_name, init_type, init_decl;\n+  tree iter;\n+\n+  /* Only do work if required.  */\n+  if (resources == NULL_TREE)\n+    return;\n+\n+  init_name = get_file_function_name ('I');\n+  init_type = build_function_type (void_type_node, end_params_node);\n+\n+  init_decl = build_decl (FUNCTION_DECL, init_name, init_type);\n+  SET_DECL_ASSEMBLER_NAME (init_decl, init_name);\n+  TREE_STATIC (init_decl) = 1;\n+  current_function_decl = init_decl;\n+  DECL_RESULT (init_decl) = build_decl (RESULT_DECL, \n+\t\t\t\t\tNULL_TREE, void_type_node);\n+\n+  /* It can be a static function as long as collect2 does not have\n+     to scan the object file to find its ctor/dtor routine.  */\n+  TREE_PUBLIC (init_decl) = ! targetm.have_ctors_dtors;\n+\n+  pushlevel (0);\n+  make_decl_rtl (init_decl, NULL);\n+  init_function_start (init_decl, input_filename, 0);\n+  expand_function_start (init_decl, 0);\n+\n+  /* Write out entries in the same order in which they were defined.  */\n+  for (iter = nreverse (resources); iter != NULL_TREE;\n+       iter = TREE_CHAIN (iter))\n+    {\n+      char *name = IDENTIFIER_POINTER (DECL_NAME (TREE_VALUE (iter)));\n+      emit_library_call (registerResource_libfunc, 0, VOIDmode, 1,\n+\t\t\t gen_rtx (SYMBOL_REF, Pmode, name),\n+\t\t\t Pmode);\n+    }\n+\n+  expand_function_end (input_filename, 0, 0);\n+  poplevel (1, 0, 1);\n+  { \n+    /* Force generation, even with -O3 or deeper.  Gross hack.\n+       FIXME.  */\n+    int saved_flag = flag_inline_functions;\n+    flag_inline_functions = 0;\t\n+    rest_of_compilation (init_decl);\n+    flag_inline_functions = saved_flag;\n+  }\n+  current_function_decl = NULL_TREE;\n+  (* targetm.asm_out.constructor) (XEXP (DECL_RTL (init_decl), 0),\n+\t\t\t\t   DEFAULT_INIT_PRIORITY);\n+}\n+\n+/* Generate a byte array representing the contents of FILENAME.  The\n+   array is assigned a unique local symbol.  The array represents a\n+   compiled Java resource, which is accessed by the runtime using\n+   NAME.  */\n+void\n+compile_resource_file (name, filename)\n+     char *name;\n+     const char *filename;\n+{\n+  struct stat stat_buf;\n+  int fd;\n+  char *buffer;\n+\n+  fd = open (filename, O_RDONLY | O_BINARY);\n+  if (fd < 0)\n+    {\n+      perror (\"Failed to read resource file\");\n+      return;\n+    }\n+  if (fstat (fd, &stat_buf) != 0\n+      || ! S_ISREG (stat_buf.st_mode))\n+    {\n+      perror (\"Could not figure length of resource file\");\n+      return;\n+    }\n+  buffer = xmalloc (strlen (name) + stat_buf.st_size);\n+  strcpy (buffer, name);\n+  read (fd, buffer + strlen (name), stat_buf.st_size);\n+  close (fd);\n+\n+  compile_resource_data (name, buffer, stat_buf.st_size);\n+  write_resource_constructor ();\n+}\n+\n+void\n+init_resource_processing ()\n+{\n+  registerResource_libfunc =\n+    gen_rtx_SYMBOL_REF (Pmode, \"_Jv_RegisterResource\");\n+}\n+\n+#include \"gt-java-resource.h\""}]}