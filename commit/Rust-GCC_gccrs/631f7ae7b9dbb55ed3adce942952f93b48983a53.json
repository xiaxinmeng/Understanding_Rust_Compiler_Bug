{"sha": "631f7ae7b9dbb55ed3adce942952f93b48983a53", "node_id": "C_kwDOANBUbNoAKDYzMWY3YWU3YjlkYmI1NWVkM2FkY2U5NDI5NTJmOTNiNDg5ODNhNTM", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-01-29T15:00:30Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-01-29T15:00:30Z"}, "message": "Merge #894\n\n894: Update name-resolution to build up canonical-path with the crate-name r=philberty a=philberty\n\nThe name resolver there are two types of canonical-path object.\r\n    \r\n1. The relative canonical path to a type for name resolution\r\n2. The full canonical-path including the crate-name (this-was-missing)\r\n    \r\nThe lack of the crate-name being present in the canonical-path meant the\r\nsymbol mangling system was required to append it where appropriate but this\r\nwas going to be too messy to handle all cases. Such as module blocks\r\ncontaining impl blocks requires a ```prefix::<impl crate::path>::item``` and\r\nsimilarly for trait impl blocks.\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>", "tree": {"sha": "f5fc89773ab1941593f3f2230908919063679c68", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f5fc89773ab1941593f3f2230908919063679c68"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/631f7ae7b9dbb55ed3adce942952f93b48983a53", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJh9VaOCRBK7hj4Ov3rIwAAHq8IAIWoZUhzrOrQ5g3rVAC75mQP\nqGNybQa62nJKT8mzKbWD5drh5ZAs8aWECDO6sf8v7I8VS+DWBIcdfy+6A/6hUJI2\nUAyUyfViyzMJgF87JYJBQ/rVXVgwXzqWBD0NXLAmM7n8mOZes94CCGiQ5Qs4Xwe5\nCxsWxqc1EL7bHx8FVESWRcM1jTwvyiO6ljeLeQ1R8zyazF6rlUKAPGT6Em0qBmeb\ndP+XddhgtdMiA4t6tNZmQc14GtWTd9ZoLv5dapjwD0VHAWoNWkehE2Qk8m5r5wA9\nkm9V4uWU+tHgxg3/SqlBGoY6pCFJVNRTeE32WRz6Zp1qbLYUQsS9b8Tj67vZ/dc=\n=7Fv9\n-----END PGP SIGNATURE-----\n", "payload": "tree f5fc89773ab1941593f3f2230908919063679c68\nparent bc7f518ac6f5c05f1c6edd7a1601f32753bab47d\nparent 2fbf9cb25e930e2df86d05e0f7f707e69bae2b1f\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1643468430 +0000\ncommitter GitHub <noreply@github.com> 1643468430 +0000\n\nMerge #894\n\n894: Update name-resolution to build up canonical-path with the crate-name r=philberty a=philberty\n\nThe name resolver there are two types of canonical-path object.\r\n    \r\n1. The relative canonical path to a type for name resolution\r\n2. The full canonical-path including the crate-name (this-was-missing)\r\n    \r\nThe lack of the crate-name being present in the canonical-path meant the\r\nsymbol mangling system was required to append it where appropriate but this\r\nwas going to be too messy to handle all cases. Such as module blocks\r\ncontaining impl blocks requires a ```prefix::<impl crate::path>::item``` and\r\nsimilarly for trait impl blocks.\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/631f7ae7b9dbb55ed3adce942952f93b48983a53", "html_url": "https://github.com/Rust-GCC/gccrs/commit/631f7ae7b9dbb55ed3adce942952f93b48983a53", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/631f7ae7b9dbb55ed3adce942952f93b48983a53/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bc7f518ac6f5c05f1c6edd7a1601f32753bab47d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc7f518ac6f5c05f1c6edd7a1601f32753bab47d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc7f518ac6f5c05f1c6edd7a1601f32753bab47d"}, {"sha": "2fbf9cb25e930e2df86d05e0f7f707e69bae2b1f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2fbf9cb25e930e2df86d05e0f7f707e69bae2b1f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2fbf9cb25e930e2df86d05e0f7f707e69bae2b1f"}], "stats": {"total": 1102, "additions": 833, "deletions": 269}, "files": [{"sha": "46f88b314dcd2c00d57c8e138650c72ac4fdc0d0", "filename": "gcc/rust/backend/rust-compile-context.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/631f7ae7b9dbb55ed3adce942952f93b48983a53/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/631f7ae7b9dbb55ed3adce942952f93b48983a53/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-context.h?ref=631f7ae7b9dbb55ed3adce942952f93b48983a53", "patch": "@@ -304,7 +304,7 @@ class Context\n   std::string mangle_item (const TyTy::BaseType *ty,\n \t\t\t   const Resolver::CanonicalPath &path) const\n   {\n-    return mangler.mangle_item (ty, path, mappings->get_current_crate_name ());\n+    return mangler.mangle_item (ty, path);\n   }\n \n private:"}, {"sha": "eaf781464648e17c18df4d4fb5be1eb36885bbaa", "filename": "gcc/rust/backend/rust-mangle.cc", "status": "modified", "additions": 52, "deletions": 27, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/631f7ae7b9dbb55ed3adce942952f93b48983a53/gcc%2Frust%2Fbackend%2Frust-mangle.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/631f7ae7b9dbb55ed3adce942952f93b48983a53/gcc%2Frust%2Fbackend%2Frust-mangle.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-mangle.cc?ref=631f7ae7b9dbb55ed3adce942952f93b48983a53", "patch": "@@ -9,6 +9,9 @@ static const std::string kMangledSymbolDelim = \"E\";\n static const std::string kMangledGenericDelim = \"$C$\";\n static const std::string kMangledSubstBegin = \"$LT$\";\n static const std::string kMangledSubstEnd = \"$GT$\";\n+static const std::string kMangledSpace = \"$u20$\";\n+static const std::string kMangledRef = \"$RF$\";\n+static const std::string kQualPathBegin = \"_\" + kMangledSubstBegin;\n \n namespace Rust {\n namespace Compile {\n@@ -22,17 +25,35 @@ legacy_mangle_name (const std::string &name)\n   //  <&T as core::fmt::Debug>::fmt:\n   //  _ZN42_$LT$$RF$T$u20$as$u20$core..fmt..Debug$GT$3fmt17h6dac924c0051eef7E\n   // replace all white space with $ and & with RF\n-\n+  //\n+  // <example::Bar as example::A>::fooA:\n+  // _ZN43_$LT$example..Bar$u20$as$u20$example..A$GT$4fooA17hfc615fa76c7db7a0E:\n+  //\n+  // example::Foo<T>::new:\n+  // _ZN7example12Foo$LT$T$GT$3new17h9a2aacb7fd783515E:\n   std::string buffer;\n-  for (const auto &c : name)\n+  for (size_t i = 0; i < name.size (); i++)\n     {\n       std::string m;\n+      char c = name.at (i);\n+\n       if (c == ' ')\n-\tm = \"$\";\n+\tm = kMangledSpace;\n       else if (c == '&')\n-\tm = \"RF\";\n-      else if (c == '<' || c == '>')\n-\tm = \"..\";\n+\tm = kMangledRef;\n+      else if (i == 0 && c == '<')\n+\tm = kQualPathBegin;\n+      else if (c == '<')\n+\tm = kMangledSubstBegin;\n+      else if (c == '>')\n+\tm = kMangledSubstEnd;\n+      else if (c == ':')\n+\t{\n+\t  rust_assert (i + 1 < name.size ());\n+\t  rust_assert (name.at (i + 1) == ':');\n+\t  i++;\n+\t  m = \"..\";\n+\t}\n       else\n \tm.push_back (c);\n \n@@ -46,10 +67,11 @@ static std::string\n legacy_mangle_canonical_path (const Resolver::CanonicalPath &path)\n {\n   std::string buffer;\n-  path.iterate_segs ([&] (const Resolver::CanonicalPath &p) -> bool {\n-    buffer += legacy_mangle_name (p.get ());\n-    return true;\n-  });\n+  for (size_t i = 0; i < path.size (); i++)\n+    {\n+      auto &seg = path.get_seg_at (i);\n+      buffer += legacy_mangle_name (seg.second);\n+    }\n   return buffer;\n }\n \n@@ -150,7 +172,8 @@ v0_simple_type_prefix (const TyTy::BaseType *ty)\n // Add an underscore-terminated base62 integer to the mangling string.\n // This corresponds to the `<base-62-number>` grammar in the v0 mangling RFC:\n //  - 0 is encoded as \"_\"\n-//  - any other value is encoded as itself minus one in base 62, followed by \"_\"\n+//  - any other value is encoded as itself minus one in base 62, followed by\n+//  \"_\"\n static void\n v0_add_integer_62 (std::string &mangled, uint64_t x)\n {\n@@ -188,11 +211,11 @@ v0_add_identifier (std::string &mangled, const std::string &identifier)\n {\n   // FIXME: gccrs cannot handle unicode identifiers yet, so we never have to\n   // create mangling for unicode values for now. However, this is handled\n-  // by the v0 mangling scheme. The grammar for unicode identifier is contained\n-  // in <undisambiguated-identifier>, right under the <identifier> one. If the\n-  // identifier contains unicode values, then an extra \"u\" needs to be added\n-  // to the mangling string and `punycode` must be used to encode the\n-  // characters.\n+  // by the v0 mangling scheme. The grammar for unicode identifier is\n+  // contained in <undisambiguated-identifier>, right under the <identifier>\n+  // one. If the identifier contains unicode values, then an extra \"u\" needs\n+  // to be added to the mangling string and `punycode` must be used to encode\n+  // the characters.\n \n   mangled += std::to_string (identifier.size ());\n \n@@ -217,22 +240,25 @@ v0_type_prefix (const TyTy::BaseType *ty)\n \n static std::string\n legacy_mangle_item (const TyTy::BaseType *ty,\n-\t\t    const Resolver::CanonicalPath &path,\n-\t\t    const std::string &crate_name)\n+\t\t    const Resolver::CanonicalPath &path)\n {\n   const std::string hash = legacy_hash (ty->as_string ());\n   const std::string hash_sig = legacy_mangle_name (hash);\n \n-  return kMangledSymbolPrefix + legacy_mangle_name (crate_name)\n-\t + legacy_mangle_canonical_path (path) + hash_sig + kMangledSymbolDelim;\n+  return kMangledSymbolPrefix + legacy_mangle_canonical_path (path) + hash_sig\n+\t + kMangledSymbolDelim;\n }\n \n static std::string\n-v0_mangle_item (const TyTy::BaseType *ty, const Resolver::CanonicalPath &path,\n-\t\tconst std::string &crate_name)\n+v0_mangle_item (const TyTy::BaseType *ty, const Resolver::CanonicalPath &path)\n {\n-  std::string mangled;\n+  // we can get this from the canonical_path\n+  auto mappings = Analysis::Mappings::get ();\n+  std::string crate_name;\n+  bool ok = mappings->get_crate_name (path.get_crate_num (), crate_name);\n+  rust_assert (ok);\n \n+  std::string mangled;\n   // FIXME: Add real algorithm once all pieces are implemented\n   auto ty_prefix = v0_type_prefix (ty);\n   v0_add_identifier (mangled, crate_name);\n@@ -243,15 +269,14 @@ v0_mangle_item (const TyTy::BaseType *ty, const Resolver::CanonicalPath &path,\n \n std::string\n Mangler::mangle_item (const TyTy::BaseType *ty,\n-\t\t      const Resolver::CanonicalPath &path,\n-\t\t      const std::string &crate_name) const\n+\t\t      const Resolver::CanonicalPath &path) const\n {\n   switch (version)\n     {\n     case Mangler::MangleVersion::LEGACY:\n-      return legacy_mangle_item (ty, path, crate_name);\n+      return legacy_mangle_item (ty, path);\n     case Mangler::MangleVersion::V0:\n-      return v0_mangle_item (ty, path, crate_name);\n+      return v0_mangle_item (ty, path);\n     default:\n       gcc_unreachable ();\n     }"}, {"sha": "03e1dc622a1eed7d73226b67e3d9b2cff8a25572", "filename": "gcc/rust/backend/rust-mangle.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/631f7ae7b9dbb55ed3adce942952f93b48983a53/gcc%2Frust%2Fbackend%2Frust-mangle.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/631f7ae7b9dbb55ed3adce942952f93b48983a53/gcc%2Frust%2Fbackend%2Frust-mangle.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-mangle.h?ref=631f7ae7b9dbb55ed3adce942952f93b48983a53", "patch": "@@ -34,8 +34,7 @@ class Mangler\n \n   // this needs to support Legacy and V0 see github #429 or #305\n   std::string mangle_item (const TyTy::BaseType *ty,\n-\t\t\t   const Resolver::CanonicalPath &path,\n-\t\t\t   const std::string &crate_name) const;\n+\t\t\t   const Resolver::CanonicalPath &path) const;\n \n   static void set_mangling (int frust_mangling_value)\n   {"}, {"sha": "6ee5f3de929f9db894c56dd10a3c7c32ce1ae79b", "filename": "gcc/rust/resolve/rust-ast-resolve-base.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/631f7ae7b9dbb55ed3adce942952f93b48983a53/gcc%2Frust%2Fresolve%2Frust-ast-resolve-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/631f7ae7b9dbb55ed3adce942952f93b48983a53/gcc%2Frust%2Fresolve%2Frust-ast-resolve-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-base.h?ref=631f7ae7b9dbb55ed3adce942952f93b48983a53", "patch": "@@ -201,13 +201,14 @@ class ResolverBase : public AST::ASTVisitor\n \n protected:\n   ResolverBase (NodeId parent)\n-    : resolver (Resolver::get ()), resolved_node (UNKNOWN_NODEID),\n-      parent (parent), locus (Location ())\n+    : resolver (Resolver::get ()), mappings (Analysis::Mappings::get ()),\n+      resolved_node (UNKNOWN_NODEID), parent (parent), locus (Location ())\n   {}\n \n   bool resolved () const { return resolved_node != UNKNOWN_NODEID; }\n \n   Resolver *resolver;\n+  Analysis::Mappings *mappings;\n   NodeId resolved_node;\n   NodeId parent;\n   Location locus;"}, {"sha": "b7b86467bbad173271384f3f2a847632815f55c4", "filename": "gcc/rust/resolve/rust-ast-resolve-expr.h", "status": "modified", "additions": 66, "deletions": 53, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/631f7ae7b9dbb55ed3adce942952f93b48983a53/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/631f7ae7b9dbb55ed3adce942952f93b48983a53/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h?ref=631f7ae7b9dbb55ed3adce942952f93b48983a53", "patch": "@@ -63,15 +63,16 @@ class ResolveExpr : public ResolverBase\n   using Rust::Resolver::ResolverBase::visit;\n \n public:\n-  static void go (AST::Expr *expr, NodeId parent)\n+  static void go (AST::Expr *expr, NodeId parent, const CanonicalPath &prefix,\n+\t\t  const CanonicalPath &canonical_prefix)\n   {\n-    ResolveExpr resolver (parent);\n+    ResolveExpr resolver (parent, prefix, canonical_prefix);\n     expr->accept_vis (resolver);\n   };\n \n   void visit (AST::TupleIndexExpr &expr) override\n   {\n-    ResolveExpr::go (expr.get_tuple_expr ().get (), expr.get_node_id ());\n+    resolve_expr (expr.get_tuple_expr ().get (), expr.get_node_id ());\n   }\n \n   void visit (AST::TupleExpr &expr) override\n@@ -80,7 +81,7 @@ class ResolveExpr : public ResolverBase\n       return;\n \n     for (auto &elem : expr.get_tuple_elems ())\n-      ResolveExpr::go (elem.get (), expr.get_node_id ());\n+      resolve_expr (elem.get (), expr.get_node_id ());\n   }\n \n   void visit (AST::PathInExpression &expr) override\n@@ -96,20 +97,20 @@ class ResolveExpr : public ResolverBase\n   void visit (AST::ReturnExpr &expr) override\n   {\n     if (expr.has_returned_expr ())\n-      ResolveExpr::go (expr.get_returned_expr ().get (), expr.get_node_id ());\n+      resolve_expr (expr.get_returned_expr ().get (), expr.get_node_id ());\n   }\n \n   void visit (AST::CallExpr &expr) override\n   {\n-    ResolveExpr::go (expr.get_function_expr ().get (), expr.get_node_id ());\n+    resolve_expr (expr.get_function_expr ().get (), expr.get_node_id ());\n     auto const &in_params = expr.get_params ();\n     for (auto &param : in_params)\n-      ResolveExpr::go (param.get (), expr.get_node_id ());\n+      resolve_expr (param.get (), expr.get_node_id ());\n   }\n \n   void visit (AST::MethodCallExpr &expr) override\n   {\n-    ResolveExpr::go (expr.get_receiver_expr ().get (), expr.get_node_id ());\n+    resolve_expr (expr.get_receiver_expr ().get (), expr.get_node_id ());\n \n     if (expr.get_method_name ().has_generic_args ())\n       {\n@@ -119,13 +120,13 @@ class ResolveExpr : public ResolverBase\n \n     auto const &in_params = expr.get_params ();\n     for (auto &param : in_params)\n-      ResolveExpr::go (param.get (), expr.get_node_id ());\n+      resolve_expr (param.get (), expr.get_node_id ());\n   }\n \n   void visit (AST::AssignmentExpr &expr) override\n   {\n-    ResolveExpr::go (expr.get_left_expr ().get (), expr.get_node_id ());\n-    ResolveExpr::go (expr.get_right_expr ().get (), expr.get_node_id ());\n+    resolve_expr (expr.get_left_expr ().get (), expr.get_node_id ());\n+    resolve_expr (expr.get_right_expr ().get (), expr.get_node_id ());\n \n     // need to verify the assignee\n     VerifyAsignee::go (expr.get_left_expr ().get (), expr.get_node_id ());\n@@ -160,60 +161,60 @@ class ResolveExpr : public ResolverBase\n \n   void visit (AST::ArithmeticOrLogicalExpr &expr) override\n   {\n-    ResolveExpr::go (expr.get_left_expr ().get (), expr.get_node_id ());\n-    ResolveExpr::go (expr.get_right_expr ().get (), expr.get_node_id ());\n+    resolve_expr (expr.get_left_expr ().get (), expr.get_node_id ());\n+    resolve_expr (expr.get_right_expr ().get (), expr.get_node_id ());\n   }\n \n   void visit (AST::CompoundAssignmentExpr &expr) override\n   {\n-    ResolveExpr::go (expr.get_left_expr ().get (), expr.get_node_id ());\n-    ResolveExpr::go (expr.get_right_expr ().get (), expr.get_node_id ());\n+    resolve_expr (expr.get_left_expr ().get (), expr.get_node_id ());\n+    resolve_expr (expr.get_right_expr ().get (), expr.get_node_id ());\n \n     // need to verify the assignee\n     VerifyAsignee::go (expr.get_left_expr ().get (), expr.get_node_id ());\n   }\n \n   void visit (AST::ComparisonExpr &expr) override\n   {\n-    ResolveExpr::go (expr.get_left_expr ().get (), expr.get_node_id ());\n-    ResolveExpr::go (expr.get_right_expr ().get (), expr.get_node_id ());\n+    resolve_expr (expr.get_left_expr ().get (), expr.get_node_id ());\n+    resolve_expr (expr.get_right_expr ().get (), expr.get_node_id ());\n   }\n \n   void visit (AST::LazyBooleanExpr &expr) override\n   {\n-    ResolveExpr::go (expr.get_left_expr ().get (), expr.get_node_id ());\n-    ResolveExpr::go (expr.get_right_expr ().get (), expr.get_node_id ());\n+    resolve_expr (expr.get_left_expr ().get (), expr.get_node_id ());\n+    resolve_expr (expr.get_right_expr ().get (), expr.get_node_id ());\n   }\n \n   void visit (AST::NegationExpr &expr) override\n   {\n-    ResolveExpr::go (expr.get_negated_expr ().get (), expr.get_node_id ());\n+    resolve_expr (expr.get_negated_expr ().get (), expr.get_node_id ());\n   }\n \n   void visit (AST::TypeCastExpr &expr) override\n   {\n     ResolveType::go (expr.get_type_to_cast_to ().get (), expr.get_node_id ());\n-    ResolveExpr::go (expr.get_casted_expr ().get (), expr.get_node_id ());\n+    resolve_expr (expr.get_casted_expr ().get (), expr.get_node_id ());\n   }\n \n   void visit (AST::IfExpr &expr) override\n   {\n-    ResolveExpr::go (expr.get_condition_expr ().get (), expr.get_node_id ());\n-    ResolveExpr::go (expr.get_if_block ().get (), expr.get_node_id ());\n+    resolve_expr (expr.get_condition_expr ().get (), expr.get_node_id ());\n+    resolve_expr (expr.get_if_block ().get (), expr.get_node_id ());\n   }\n \n   void visit (AST::IfExprConseqElse &expr) override\n   {\n-    ResolveExpr::go (expr.get_condition_expr ().get (), expr.get_node_id ());\n-    ResolveExpr::go (expr.get_if_block ().get (), expr.get_node_id ());\n-    ResolveExpr::go (expr.get_else_block ().get (), expr.get_node_id ());\n+    resolve_expr (expr.get_condition_expr ().get (), expr.get_node_id ());\n+    resolve_expr (expr.get_if_block ().get (), expr.get_node_id ());\n+    resolve_expr (expr.get_else_block ().get (), expr.get_node_id ());\n   }\n \n   void visit (AST::IfExprConseqIf &expr) override\n   {\n-    ResolveExpr::go (expr.get_condition_expr ().get (), expr.get_node_id ());\n-    ResolveExpr::go (expr.get_if_block ().get (), expr.get_node_id ());\n-    ResolveExpr::go (expr.get_conseq_if_expr ().get (), expr.get_node_id ());\n+    resolve_expr (expr.get_condition_expr ().get (), expr.get_node_id ());\n+    resolve_expr (expr.get_if_block ().get (), expr.get_node_id ());\n+    resolve_expr (expr.get_conseq_if_expr ().get (), expr.get_node_id ());\n   }\n \n   void visit (AST::BlockExpr &expr) override;\n@@ -226,7 +227,7 @@ class ResolveExpr : public ResolverBase\n   void visit (AST::ArrayElemsValues &elems) override\n   {\n     for (auto &elem : elems.get_values ())\n-      ResolveExpr::go (elem.get (), elems.get_node_id ());\n+      resolve_expr (elem.get (), elems.get_node_id ());\n   }\n \n   void visit (AST::ArrayExpr &expr) override\n@@ -236,52 +237,51 @@ class ResolveExpr : public ResolverBase\n \n   void visit (AST::ArrayIndexExpr &expr) override\n   {\n-    ResolveExpr::go (expr.get_array_expr ().get (), expr.get_node_id ());\n-    ResolveExpr::go (expr.get_index_expr ().get (), expr.get_node_id ());\n+    resolve_expr (expr.get_array_expr ().get (), expr.get_node_id ());\n+    resolve_expr (expr.get_index_expr ().get (), expr.get_node_id ());\n   }\n \n   void visit (AST::ArrayElemsCopied &elems) override\n   {\n-    ResolveExpr::go (elems.get_num_copies ().get (), elems.get_node_id ());\n-    ResolveExpr::go (elems.get_elem_to_copy ().get (), elems.get_node_id ());\n+    resolve_expr (elems.get_num_copies ().get (), elems.get_node_id ());\n+    resolve_expr (elems.get_elem_to_copy ().get (), elems.get_node_id ());\n   }\n \n   // this this an empty struct constructor like 'S {}'\n   void visit (AST::StructExprStruct &struct_expr) override\n   {\n-    ResolveExpr::go (&struct_expr.get_struct_name (),\n-\t\t     struct_expr.get_node_id ());\n+    resolve_expr (&struct_expr.get_struct_name (), struct_expr.get_node_id ());\n   }\n \n   // this this a struct constructor with fields\n   void visit (AST::StructExprStructFields &struct_expr) override\n   {\n-    ResolveExpr::go (&struct_expr.get_struct_name (),\n-\t\t     struct_expr.get_node_id ());\n+    resolve_expr (&struct_expr.get_struct_name (), struct_expr.get_node_id ());\n \n     if (struct_expr.has_struct_base ())\n       {\n \tAST::StructBase &base = struct_expr.get_struct_base ();\n-\tResolveExpr::go (base.get_base_struct ().get (),\n-\t\t\t struct_expr.get_node_id ());\n+\tresolve_expr (base.get_base_struct ().get (),\n+\t\t      struct_expr.get_node_id ());\n       }\n \n     auto const &struct_fields = struct_expr.get_fields ();\n     for (auto &struct_field : struct_fields)\n       {\n \tResolveStructExprField::go (struct_field.get (),\n-\t\t\t\t    struct_expr.get_node_id ());\n+\t\t\t\t    struct_expr.get_node_id (), prefix,\n+\t\t\t\t    canonical_prefix);\n       }\n   }\n \n   void visit (AST::GroupedExpr &expr) override\n   {\n-    ResolveExpr::go (expr.get_expr_in_parens ().get (), expr.get_node_id ());\n+    resolve_expr (expr.get_expr_in_parens ().get (), expr.get_node_id ());\n   }\n \n   void visit (AST::FieldAccessExpr &expr) override\n   {\n-    ResolveExpr::go (expr.get_receiver_expr ().get (), expr.get_node_id ());\n+    resolve_expr (expr.get_receiver_expr ().get (), expr.get_node_id ());\n   }\n \n   void visit (AST::LoopExpr &expr) override\n@@ -311,7 +311,7 @@ class ResolveExpr : public ResolverBase\n \t\t\t\t\t Definition{label_lifetime_node_id,\n \t\t\t\t\t\t    label.get_node_id ()});\n       }\n-    ResolveExpr::go (expr.get_loop_block ().get (), expr.get_node_id ());\n+    resolve_expr (expr.get_loop_block ().get (), expr.get_node_id ());\n   }\n \n   void visit (AST::BreakExpr &expr) override\n@@ -340,7 +340,7 @@ class ResolveExpr : public ResolverBase\n       }\n \n     if (expr.has_break_expr ())\n-      ResolveExpr::go (expr.get_break_expr ().get (), expr.get_node_id ());\n+      resolve_expr (expr.get_break_expr ().get (), expr.get_node_id ());\n   }\n \n   void visit (AST::WhileLoopExpr &expr) override\n@@ -370,8 +370,8 @@ class ResolveExpr : public ResolverBase\n \t\t\t\t\t Definition{label_lifetime_node_id,\n \t\t\t\t\t\t    label.get_node_id ()});\n       }\n-    ResolveExpr::go (expr.get_predicate_expr ().get (), expr.get_node_id ());\n-    ResolveExpr::go (expr.get_loop_block ().get (), expr.get_node_id ());\n+    resolve_expr (expr.get_predicate_expr ().get (), expr.get_node_id ());\n+    resolve_expr (expr.get_loop_block ().get (), expr.get_node_id ());\n   }\n \n   void visit (AST::ContinueExpr &expr) override\n@@ -402,17 +402,17 @@ class ResolveExpr : public ResolverBase\n \n   void visit (AST::BorrowExpr &expr) override\n   {\n-    ResolveExpr::go (expr.get_borrowed_expr ().get (), expr.get_node_id ());\n+    resolve_expr (expr.get_borrowed_expr ().get (), expr.get_node_id ());\n   }\n \n   void visit (AST::DereferenceExpr &expr) override\n   {\n-    ResolveExpr::go (expr.get_dereferenced_expr ().get (), expr.get_node_id ());\n+    resolve_expr (expr.get_dereferenced_expr ().get (), expr.get_node_id ());\n   }\n \n   void visit (AST::MatchExpr &expr) override\n   {\n-    ResolveExpr::go (expr.get_scrutinee_expr ().get (), expr.get_node_id ());\n+    resolve_expr (expr.get_scrutinee_expr ().get (), expr.get_node_id ());\n     for (auto &match_case : expr.get_match_cases ())\n       {\n \t// each arm is in its own scope\n@@ -427,7 +427,7 @@ class ResolveExpr : public ResolverBase\n \t// resolve\n \tAST::MatchArm &arm = match_case.get_arm ();\n \tif (arm.has_match_arm_guard ())\n-\t  ResolveExpr::go (arm.get_guard_expr ().get (), expr.get_node_id ());\n+\t  resolve_expr (arm.get_guard_expr ().get (), expr.get_node_id ());\n \n \t// insert any possible new patterns\n \tfor (auto &pattern : arm.get_patterns ())\n@@ -436,7 +436,7 @@ class ResolveExpr : public ResolverBase\n \t  }\n \n \t// resolve the body\n-\tResolveExpr::go (match_case.get_expr ().get (), expr.get_node_id ());\n+\tresolve_expr (match_case.get_expr ().get (), expr.get_node_id ());\n \n \t// done\n \tresolver->get_name_scope ().pop ();\n@@ -445,8 +445,21 @@ class ResolveExpr : public ResolverBase\n       }\n   }\n \n+protected:\n+  void resolve_expr (AST::Expr *e, NodeId parent)\n+  {\n+    ResolveExpr::go (e, parent, prefix, canonical_prefix);\n+  }\n+\n private:\n-  ResolveExpr (NodeId parent) : ResolverBase (parent) {}\n+  ResolveExpr (NodeId parent, const CanonicalPath &prefix,\n+\t       const CanonicalPath &canonical_prefix)\n+    : ResolverBase (parent), prefix (prefix),\n+      canonical_prefix (canonical_prefix)\n+  {}\n+\n+  const CanonicalPath &prefix;\n+  const CanonicalPath &canonical_prefix;\n };\n \n } // namespace Resolver"}, {"sha": "074855eae2eb063653aab0dd41b25289203be808", "filename": "gcc/rust/resolve/rust-ast-resolve-implitem.h", "status": "modified", "additions": 58, "deletions": 28, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/631f7ae7b9dbb55ed3adce942952f93b48983a53/gcc%2Frust%2Fresolve%2Frust-ast-resolve-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/631f7ae7b9dbb55ed3adce942952f93b48983a53/gcc%2Frust%2Fresolve%2Frust-ast-resolve-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-implitem.h?ref=631f7ae7b9dbb55ed3adce942952f93b48983a53", "patch": "@@ -45,8 +45,10 @@ class ResolveToplevelImplItem : public ResolverBase\n \n   void visit (AST::TypeAlias &type) override\n   {\n-    auto path = prefix.append (\n-      CanonicalPath::new_seg (type.get_node_id (), type.get_new_type_name ()));\n+    auto decl\n+      = CanonicalPath::new_seg (type.get_node_id (), type.get_new_type_name ());\n+    auto path = prefix.append (decl);\n+\n     resolver->get_type_scope ().insert (\n       path, type.get_node_id (), type.get_locus (), false,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n@@ -58,8 +60,9 @@ class ResolveToplevelImplItem : public ResolverBase\n \n   void visit (AST::ConstantItem &constant) override\n   {\n-    auto path\n-      = prefix.append (ResolveConstantItemToCanonicalPath::resolve (constant));\n+    auto decl = ResolveConstantItemToCanonicalPath::resolve (constant);\n+    auto path = prefix.append (decl);\n+\n     resolver->get_name_scope ().insert (\n       path, constant.get_node_id (), constant.get_locus (), false,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n@@ -74,8 +77,9 @@ class ResolveToplevelImplItem : public ResolverBase\n \n   void visit (AST::Function &function) override\n   {\n-    auto path\n-      = prefix.append (ResolveFunctionItemToCanonicalPath::resolve (function));\n+    auto decl = ResolveFunctionItemToCanonicalPath::resolve (function);\n+    auto path = prefix.append (decl);\n+\n     resolver->get_name_scope ().insert (\n       path, function.get_node_id (), function.get_locus (), false,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n@@ -90,8 +94,9 @@ class ResolveToplevelImplItem : public ResolverBase\n \n   void visit (AST::Method &method) override\n   {\n-    auto path\n-      = prefix.append (ResolveMethodItemToCanonicalPath::resolve (method));\n+    auto decl = ResolveMethodItemToCanonicalPath::resolve (method);\n+    auto path = prefix.append (decl);\n+\n     resolver->get_name_scope ().insert (\n       path, method.get_node_id (), method.get_locus (), false,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n@@ -119,17 +124,19 @@ class ResolveTopLevelTraitItems : public ResolverBase\n   using Rust::Resolver::ResolverBase::visit;\n \n public:\n-  static void go (AST::TraitItem *item,\n-\t\t  const CanonicalPath &prefix = CanonicalPath::create_empty ())\n+  static void go (AST::TraitItem *item, const CanonicalPath &prefix,\n+\t\t  const CanonicalPath &canonical_prefix)\n   {\n-    ResolveTopLevelTraitItems resolver (prefix);\n+    ResolveTopLevelTraitItems resolver (prefix, canonical_prefix);\n     item->accept_vis (resolver);\n   };\n \n   void visit (AST::TraitItemFunc &function) override\n   {\n-    auto path = prefix.append (\n-      ResolveTraitItemFunctionToCanonicalPath::resolve (function));\n+    auto decl = ResolveTraitItemFunctionToCanonicalPath::resolve (function);\n+    auto path = prefix.append (decl);\n+    auto cpath = canonical_prefix.append (decl);\n+\n     resolver->get_name_scope ().insert (\n       path, function.get_node_id (), function.get_locus (), false,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n@@ -140,12 +147,17 @@ class ResolveTopLevelTraitItems : public ResolverBase\n     resolver->insert_new_definition (function.get_node_id (),\n \t\t\t\t     Definition{function.get_node_id (),\n \t\t\t\t\t\tfunction.get_node_id ()});\n+\n+    mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t     function.get_node_id (), cpath);\n   }\n \n   void visit (AST::TraitItemMethod &method) override\n   {\n-    auto path\n-      = prefix.append (ResolveTraitItemMethodToCanonicalPath::resolve (method));\n+    auto decl = ResolveTraitItemMethodToCanonicalPath::resolve (method);\n+    auto path = prefix.append (decl);\n+    auto cpath = canonical_prefix.append (decl);\n+\n     resolver->get_name_scope ().insert (\n       path, method.get_node_id (), method.get_locus (), false,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n@@ -156,12 +168,17 @@ class ResolveTopLevelTraitItems : public ResolverBase\n     resolver->insert_new_definition (method.get_node_id (),\n \t\t\t\t     Definition{method.get_node_id (),\n \t\t\t\t\t\tmethod.get_node_id ()});\n+\n+    mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t     method.get_node_id (), cpath);\n   }\n \n   void visit (AST::TraitItemConst &constant) override\n   {\n-    auto path = prefix.append (\n-      ResolveTraitItemConstToCanonicalPath::resolve (constant));\n+    auto decl = ResolveTraitItemConstToCanonicalPath::resolve (constant);\n+    auto path = prefix.append (decl);\n+    auto cpath = canonical_prefix.append (decl);\n+\n     resolver->get_name_scope ().insert (\n       path, constant.get_node_id (), constant.get_locus (), false,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n@@ -172,46 +189,57 @@ class ResolveTopLevelTraitItems : public ResolverBase\n     resolver->insert_new_definition (constant.get_node_id (),\n \t\t\t\t     Definition{constant.get_node_id (),\n \t\t\t\t\t\tconstant.get_node_id ()});\n+\n+    mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t     constant.get_node_id (), cpath);\n   }\n \n   void visit (AST::TraitItemType &type) override\n   {\n-    auto path\n-      = prefix.append (ResolveTraitItemTypeToCanonicalPath::resolve (type));\n+    auto decl = ResolveTraitItemTypeToCanonicalPath::resolve (type);\n+    auto path = prefix.append (decl);\n+    auto cpath = canonical_prefix.append (decl);\n+\n     resolver->get_type_scope ().insert (\n       path, type.get_node_id (), type.get_locus (), false,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n \tRichLocation r (type.get_locus ());\n \tr.add_range (locus);\n \trust_error_at (r, \"redefined multiple times\");\n       });\n+\n+    mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t     type.get_node_id (), cpath);\n   }\n \n private:\n-  ResolveTopLevelTraitItems (const CanonicalPath &prefix)\n-    : ResolverBase (UNKNOWN_NODEID), prefix (prefix)\n+  ResolveTopLevelTraitItems (const CanonicalPath &prefix,\n+\t\t\t     const CanonicalPath &canonical_prefix)\n+    : ResolverBase (UNKNOWN_NODEID), prefix (prefix),\n+      canonical_prefix (canonical_prefix)\n   {}\n \n   const CanonicalPath &prefix;\n+  const CanonicalPath &canonical_prefix;\n };\n \n class ResolveToplevelExternItem : public ResolverBase\n {\n   using Rust::Resolver::ResolverBase::visit;\n \n public:\n-  static void go (AST::ExternalItem *item,\n-\t\t  const CanonicalPath &prefix = CanonicalPath::create_empty ())\n+  static void go (AST::ExternalItem *item, const CanonicalPath &prefix)\n   {\n     ResolveToplevelExternItem resolver (prefix);\n     item->accept_vis (resolver);\n   };\n \n   void visit (AST::ExternalFunctionItem &function) override\n   {\n-    auto path\n-      = prefix.append (CanonicalPath::new_seg (function.get_node_id (),\n-\t\t\t\t\t       function.get_identifier ()));\n+    auto decl = CanonicalPath::new_seg (function.get_node_id (),\n+\t\t\t\t\tfunction.get_identifier ());\n+    auto path = prefix.append (decl);\n+\n     resolver->get_name_scope ().insert (\n       path, function.get_node_id (), function.get_locus (), false,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n@@ -226,8 +254,10 @@ class ResolveToplevelExternItem : public ResolverBase\n \n   void visit (AST::ExternalStaticItem &item) override\n   {\n-    auto path = prefix.append (\n-      CanonicalPath::new_seg (item.get_node_id (), item.get_identifier ()));\n+    auto decl\n+      = CanonicalPath::new_seg (item.get_node_id (), item.get_identifier ());\n+    auto path = prefix.append (decl);\n+\n     resolver->get_name_scope ().insert (\n       path, item.get_node_id (), item.get_locus (), false,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {"}, {"sha": "e428880ea792e2cbbe03efd171f2b367724d3ab1", "filename": "gcc/rust/resolve/rust-ast-resolve-item.h", "status": "modified", "additions": 254, "deletions": 33, "changes": 287, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/631f7ae7b9dbb55ed3adce942952f93b48983a53/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/631f7ae7b9dbb55ed3adce942952f93b48983a53/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h?ref=631f7ae7b9dbb55ed3adce942952f93b48983a53", "patch": "@@ -35,20 +35,33 @@ class ResolveTraitItems : public ResolverBase\n   using Rust::Resolver::ResolverBase::visit;\n \n public:\n-  static void go (AST::TraitItem *item)\n+  static void go (AST::TraitItem *item, const CanonicalPath &prefix,\n+\t\t  const CanonicalPath &canonical_prefix)\n   {\n-    ResolveTraitItems resolver;\n+    ResolveTraitItems resolver (prefix, canonical_prefix);\n     item->accept_vis (resolver);\n   };\n \n   void visit (AST::TraitItemType &type) override\n   {\n+    auto decl = ResolveTraitItemTypeToCanonicalPath::resolve (type);\n+    auto path = prefix.append (decl);\n+    auto cpath = canonical_prefix.append (decl);\n+    mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t     type.get_node_id (), cpath);\n+\n     for (auto &bound : type.get_type_param_bounds ())\n       ResolveTypeBound::go (bound.get (), type.get_node_id ());\n   }\n \n   void visit (AST::TraitItemFunc &func) override\n   {\n+    auto decl = ResolveTraitItemFunctionToCanonicalPath::resolve (func);\n+    auto path = prefix.append (decl);\n+    auto cpath = canonical_prefix.append (decl);\n+    mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t     func.get_node_id (), cpath);\n+\n     NodeId scope_node_id = func.get_node_id ();\n     resolver->get_name_scope ().push (scope_node_id);\n     resolver->get_type_scope ().push (scope_node_id);\n@@ -86,7 +99,8 @@ class ResolveTraitItems : public ResolverBase\n \n     // trait items have an optional body\n     if (func.has_definition ())\n-      ResolveExpr::go (func.get_definition ().get (), func.get_node_id ());\n+      ResolveExpr::go (func.get_definition ().get (), func.get_node_id (), path,\n+\t\t       cpath);\n \n     resolver->get_name_scope ().pop ();\n     resolver->get_type_scope ().pop ();\n@@ -95,6 +109,12 @@ class ResolveTraitItems : public ResolverBase\n \n   void visit (AST::TraitItemMethod &func) override\n   {\n+    auto decl = ResolveTraitItemMethodToCanonicalPath::resolve (func);\n+    auto path = prefix.append (decl);\n+    auto cpath = canonical_prefix.append (decl);\n+    mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t     func.get_node_id (), cpath);\n+\n     NodeId scope_node_id = func.get_node_id ();\n     resolver->get_name_scope ().push (scope_node_id);\n     resolver->get_type_scope ().push (scope_node_id);\n@@ -152,7 +172,8 @@ class ResolveTraitItems : public ResolverBase\n \n     // trait items have an optional body\n     if (func.has_definition ())\n-      ResolveExpr::go (func.get_definition ().get (), func.get_node_id ());\n+      ResolveExpr::go (func.get_definition ().get (), func.get_node_id (), path,\n+\t\t       cpath);\n \n     resolver->get_name_scope ().pop ();\n     resolver->get_type_scope ().pop ();\n@@ -161,10 +182,17 @@ class ResolveTraitItems : public ResolverBase\n \n   void visit (AST::TraitItemConst &constant) override\n   {\n+    auto decl = ResolveTraitItemConstToCanonicalPath::resolve (constant);\n+    auto path = prefix.append (decl);\n+    auto cpath = canonical_prefix.append (decl);\n+    mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t     constant.get_node_id (), cpath);\n+\n     ResolveType::go (constant.get_type ().get (), constant.get_node_id ());\n \n     if (constant.has_expr ())\n-      ResolveExpr::go (constant.get_expr ().get (), constant.get_node_id ());\n+      ResolveExpr::go (constant.get_expr ().get (), constant.get_node_id (),\n+\t\t       path, cpath);\n \n     // the mutability checker needs to verify for immutable decls the number\n     // of assignments are <1. This marks an implicit assignment\n@@ -174,22 +202,37 @@ class ResolveTraitItems : public ResolverBase\n   }\n \n private:\n-  ResolveTraitItems () : ResolverBase (UNKNOWN_NODEID) {}\n+  ResolveTraitItems (const CanonicalPath &prefix,\n+\t\t     const CanonicalPath &canonical_prefix)\n+    : ResolverBase (UNKNOWN_NODEID), prefix (prefix),\n+      canonical_prefix (canonical_prefix)\n+  {}\n+\n+  const CanonicalPath &prefix;\n+  const CanonicalPath &canonical_prefix;\n };\n \n class ResolveItem : public ResolverBase\n {\n public:\n   using Rust::Resolver::ResolverBase::visit;\n \n-  static void go (AST::Item *item)\n+  static void go (AST::Item *item, const CanonicalPath &prefix,\n+\t\t  const CanonicalPath &canonical_prefix)\n   {\n-    ResolveItem resolver;\n+    ResolveItem resolver (prefix, canonical_prefix);\n     item->accept_vis (resolver);\n   };\n \n   void visit (AST::TypeAlias &alias) override\n   {\n+    auto talias = CanonicalPath::new_seg (alias.get_node_id (),\n+\t\t\t\t\t  alias.get_new_type_name ());\n+    auto path = prefix.append (talias);\n+    auto cpath = canonical_prefix.append (talias);\n+    mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t     alias.get_node_id (), cpath);\n+\n     NodeId scope_node_id = alias.get_node_id ();\n     resolver->get_type_scope ().push (scope_node_id);\n \n@@ -209,6 +252,13 @@ class ResolveItem : public ResolverBase\n \n   void visit (AST::Module &module) override\n   {\n+    auto mod\n+      = CanonicalPath::new_seg (module.get_node_id (), module.get_name ());\n+    auto path = prefix.append (mod);\n+    auto cpath = canonical_prefix.append (mod);\n+    mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t     module.get_node_id (), cpath);\n+\n     NodeId scope_node_id = module.get_node_id ();\n     resolver->get_name_scope ().push (scope_node_id);\n     resolver->get_type_scope ().push (scope_node_id);\n@@ -218,10 +268,10 @@ class ResolveItem : public ResolverBase\n     resolver->push_new_label_rib (resolver->get_type_scope ().peek ());\n \n     for (auto &item : module.get_items ())\n-      ResolveTopLevel::go (item.get ());\n+      ResolveTopLevel::go (item.get (), CanonicalPath::create_empty (), cpath);\n \n     for (auto &item : module.get_items ())\n-      ResolveItem::go (item.get ());\n+      ResolveItem::go (item.get (), path, cpath);\n \n     resolver->get_name_scope ().pop ();\n     resolver->get_type_scope ().pop ();\n@@ -230,6 +280,13 @@ class ResolveItem : public ResolverBase\n \n   void visit (AST::TupleStruct &struct_decl) override\n   {\n+    auto decl = CanonicalPath::new_seg (struct_decl.get_node_id (),\n+\t\t\t\t\tstruct_decl.get_identifier ());\n+    auto path = prefix.append (decl);\n+    auto cpath = canonical_prefix.append (decl);\n+    mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t     struct_decl.get_node_id (), cpath);\n+\n     NodeId scope_node_id = struct_decl.get_node_id ();\n     resolver->get_type_scope ().push (scope_node_id);\n \n@@ -254,6 +311,13 @@ class ResolveItem : public ResolverBase\n \n   void visit (AST::Enum &enum_decl) override\n   {\n+    auto decl = CanonicalPath::new_seg (enum_decl.get_node_id (),\n+\t\t\t\t\tenum_decl.get_identifier ());\n+    auto path = prefix.append (decl);\n+    auto cpath = canonical_prefix.append (decl);\n+    mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t     enum_decl.get_node_id (), cpath);\n+\n     NodeId scope_node_id = enum_decl.get_node_id ();\n     resolver->get_type_scope ().push (scope_node_id);\n \n@@ -270,7 +334,7 @@ class ResolveItem : public ResolverBase\n \n     /* The actual fields are inside the variants.  */\n     for (auto &variant : enum_decl.get_variants ())\n-      ResolveItem::go (variant.get ());\n+      ResolveItem::go (variant.get (), path, cpath);\n \n     resolver->get_type_scope ().pop ();\n   }\n@@ -279,20 +343,50 @@ class ResolveItem : public ResolverBase\n \n   void visit (AST::EnumItemTuple &item) override\n   {\n+    auto decl\n+      = CanonicalPath::new_seg (item.get_node_id (), item.get_identifier ());\n+    auto path = prefix.append (decl);\n+    auto cpath = canonical_prefix.append (decl);\n+    mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t     item.get_node_id (), cpath);\n+\n     for (auto &field : item.get_tuple_fields ())\n       ResolveType::go (field.get_field_type ().get (), item.get_node_id ());\n   }\n \n   void visit (AST::EnumItemStruct &item) override\n   {\n+    auto decl\n+      = CanonicalPath::new_seg (item.get_node_id (), item.get_identifier ());\n+    auto path = prefix.append (decl);\n+    auto cpath = canonical_prefix.append (decl);\n+    mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t     item.get_node_id (), cpath);\n+\n     for (auto &field : item.get_struct_fields ())\n       ResolveType::go (field.get_field_type ().get (), item.get_node_id ());\n   }\n \n-  /* EnumItemDiscriminant doesn't need to be handled, no fields.  */\n+  void visit (AST::EnumItemDiscriminant &item) override\n+  {\n+    auto decl\n+      = CanonicalPath::new_seg (item.get_node_id (), item.get_identifier ());\n+    auto path = prefix.append (decl);\n+    auto cpath = canonical_prefix.append (decl);\n+\n+    mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t     item.get_node_id (), cpath);\n+  }\n \n   void visit (AST::StructStruct &struct_decl) override\n   {\n+    auto decl = CanonicalPath::new_seg (struct_decl.get_node_id (),\n+\t\t\t\t\tstruct_decl.get_identifier ());\n+    auto path = prefix.append (decl);\n+    auto cpath = canonical_prefix.append (decl);\n+    mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t     struct_decl.get_node_id (), cpath);\n+\n     NodeId scope_node_id = struct_decl.get_node_id ();\n     resolver->get_type_scope ().push (scope_node_id);\n \n@@ -317,6 +411,13 @@ class ResolveItem : public ResolverBase\n \n   void visit (AST::Union &union_decl) override\n   {\n+    auto decl = CanonicalPath::new_seg (union_decl.get_node_id (),\n+\t\t\t\t\tunion_decl.get_identifier ());\n+    auto path = prefix.append (decl);\n+    auto cpath = canonical_prefix.append (decl);\n+    mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t     union_decl.get_node_id (), cpath);\n+\n     NodeId scope_node_id = union_decl.get_node_id ();\n     resolver->get_type_scope ().push (scope_node_id);\n \n@@ -340,8 +441,15 @@ class ResolveItem : public ResolverBase\n \n   void visit (AST::StaticItem &var) override\n   {\n+    auto decl\n+      = CanonicalPath::new_seg (var.get_node_id (), var.get_identifier ());\n+    auto path = prefix.append (decl);\n+    auto cpath = canonical_prefix.append (decl);\n+    mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t     var.get_node_id (), cpath);\n+\n     ResolveType::go (var.get_type ().get (), var.get_node_id ());\n-    ResolveExpr::go (var.get_expr ().get (), var.get_node_id ());\n+    ResolveExpr::go (var.get_expr ().get (), var.get_node_id (), path, cpath);\n \n     // the mutability checker needs to verify for immutable decls the number\n     // of assignments are <1. This marks an implicit assignment\n@@ -350,8 +458,15 @@ class ResolveItem : public ResolverBase\n \n   void visit (AST::ConstantItem &constant) override\n   {\n+    auto decl = ResolveConstantItemToCanonicalPath::resolve (constant);\n+    auto path = prefix.append (decl);\n+    auto cpath = canonical_prefix.append (decl);\n+    mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t     constant.get_node_id (), cpath);\n+\n     ResolveType::go (constant.get_type ().get (), constant.get_node_id ());\n-    ResolveExpr::go (constant.get_expr ().get (), constant.get_node_id ());\n+    ResolveExpr::go (constant.get_expr ().get (), constant.get_node_id (), path,\n+\t\t     cpath);\n \n     // the mutability checker needs to verify for immutable decls the number\n     // of assignments are <1. This marks an implicit assignment\n@@ -365,6 +480,12 @@ class ResolveItem : public ResolverBase\n     if (function.is_marked_for_strip ())\n       return;\n \n+    auto decl = ResolveFunctionItemToCanonicalPath::resolve (function);\n+    auto path = prefix.append (decl);\n+    auto cpath = canonical_prefix.append (decl);\n+    mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t     function.get_node_id (), cpath);\n+\n     NodeId scope_node_id = function.get_node_id ();\n     resolver->get_name_scope ().push (scope_node_id);\n     resolver->get_type_scope ().push (scope_node_id);\n@@ -402,8 +523,8 @@ class ResolveItem : public ResolverBase\n       }\n \n     // resolve the function body\n-    ResolveExpr::go (function.get_definition ().get (),\n-\t\t     function.get_node_id ());\n+    ResolveExpr::go (function.get_definition ().get (), function.get_node_id (),\n+\t\t     path, cpath);\n \n     resolver->get_name_scope ().pop ();\n     resolver->get_type_scope ().pop ();\n@@ -430,17 +551,47 @@ class ResolveItem : public ResolverBase\n     if (impl_block.has_where_clause ())\n       ResolveWhereClause::Resolve (impl_block.get_where_clause ());\n \n+    // FIXME this needs to be protected behind nominal type-checks see:\n+    // rustc --explain E0118\n+\n+    CanonicalPath self_cpath = CanonicalPath::create_empty ();\n     bool canonicalize_type_with_generics = false;\n-    NodeId resolved_node = ResolveType::go (impl_block.get_type ().get (),\n-\t\t\t\t\t    impl_block.get_node_id (),\n-\t\t\t\t\t    canonicalize_type_with_generics);\n+    NodeId resolved_node\n+      = ResolveType::go (impl_block.get_type ().get (),\n+\t\t\t impl_block.get_node_id (),\n+\t\t\t canonicalize_type_with_generics, &self_cpath);\n     if (resolved_node == UNKNOWN_NODEID)\n       {\n \tresolver->get_type_scope ().pop ();\n \tresolver->get_name_scope ().pop ();\n \treturn;\n       }\n \n+    // Setup paths\n+    bool canonicalize_type_args = !impl_block.has_generics ();\n+    bool type_resolve_generic_args = false;\n+\n+    CanonicalPath impl_type\n+      = ResolveTypeToCanonicalPath::resolve (*impl_block.get_type ().get (),\n+\t\t\t\t\t     canonicalize_type_args,\n+\t\t\t\t\t     type_resolve_generic_args);\n+    CanonicalPath impl_prefix = prefix.append (impl_type);\n+\n+    // see https://godbolt.org/z/a3vMbsT6W\n+    CanonicalPath cpath = CanonicalPath::create_empty ();\n+    if (canonical_prefix.size () > 1)\n+      {\n+\tstd::string seg_buf = \"<impl \" + self_cpath.get () + \">\";\n+\tCanonicalPath seg\n+\t  = CanonicalPath::new_seg (impl_block.get_node_id (), seg_buf);\n+\tcpath = canonical_prefix.append (seg);\n+      }\n+    else\n+      {\n+\tcpath = canonical_prefix.append (self_cpath);\n+      }\n+    // done setup paths\n+\n     auto Self\n       = CanonicalPath::get_big_self (impl_block.get_type ()->get_node_id ());\n \n@@ -450,7 +601,7 @@ class ResolveItem : public ResolverBase\n \n     for (auto &impl_item : impl_block.get_impl_items ())\n       {\n-\tresolve_impl_item (impl_item.get ());\n+\tresolve_impl_item (impl_item.get (), impl_prefix, cpath);\n       }\n \n     resolver->get_type_scope ().peek ()->clear_name (\n@@ -462,6 +613,12 @@ class ResolveItem : public ResolverBase\n \n   void visit (AST::Method &method) override\n   {\n+    auto decl = ResolveMethodItemToCanonicalPath::resolve (method);\n+    auto path = prefix.append (decl);\n+    auto cpath = canonical_prefix.append (decl);\n+    mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t     method.get_node_id (), cpath);\n+\n     NodeId scope_node_id = method.get_node_id ();\n     resolver->get_name_scope ().push (scope_node_id);\n     resolver->get_type_scope ().push (scope_node_id);\n@@ -522,7 +679,8 @@ class ResolveItem : public ResolverBase\n       ResolveWhereClause::Resolve (method.get_where_clause ());\n \n     // resolve the function body\n-    ResolveExpr::go (method.get_definition ().get (), method.get_node_id ());\n+    ResolveExpr::go (method.get_definition ().get (), method.get_node_id (),\n+\t\t     path, cpath);\n \n     resolver->get_name_scope ().pop ();\n     resolver->get_type_scope ().pop ();\n@@ -549,29 +707,72 @@ class ResolveItem : public ResolverBase\n     if (impl_block.has_where_clause ())\n       ResolveWhereClause::Resolve (impl_block.get_where_clause ());\n \n+    CanonicalPath canonical_trait_type = CanonicalPath::create_empty ();\n     bool canonicalize_type_with_generics = false;\n     NodeId trait_resolved_node\n       = ResolveType::go (&impl_block.get_trait_path (),\n \t\t\t impl_block.get_node_id (),\n-\t\t\t canonicalize_type_with_generics);\n+\t\t\t canonicalize_type_with_generics,\n+\t\t\t &canonical_trait_type);\n     if (trait_resolved_node == UNKNOWN_NODEID)\n       {\n \tresolver->get_type_scope ().pop ();\n \tresolver->get_name_scope ().pop ();\n \treturn;\n       }\n \n+    CanonicalPath canonical_impl_type = CanonicalPath::create_empty ();\n     NodeId type_resolved_node\n       = ResolveType::go (impl_block.get_type ().get (),\n \t\t\t impl_block.get_node_id (),\n-\t\t\t canonicalize_type_with_generics);\n+\t\t\t canonicalize_type_with_generics, &canonical_impl_type);\n     if (type_resolved_node == UNKNOWN_NODEID)\n       {\n \tresolver->get_type_scope ().pop ();\n \tresolver->get_name_scope ().pop ();\n \treturn;\n       }\n \n+    // setup paths\n+    bool canonicalize_type_args = !impl_block.has_generics ();\n+    bool type_resolve_generic_args = false;\n+\n+    CanonicalPath impl_type_seg\n+      = ResolveTypeToCanonicalPath::resolve (*impl_block.get_type ().get (),\n+\t\t\t\t\t     canonicalize_type_args,\n+\t\t\t\t\t     type_resolve_generic_args);\n+    CanonicalPath trait_type_seg\n+      = ResolveTypeToCanonicalPath::resolve (impl_block.get_trait_path (),\n+\t\t\t\t\t     canonicalize_type_args,\n+\t\t\t\t\t     type_resolve_generic_args);\n+\n+    CanonicalPath projection\n+      = TraitImplProjection::resolve (impl_block.get_node_id (), trait_type_seg,\n+\t\t\t\t      impl_type_seg);\n+    CanonicalPath impl_prefix = prefix.append (projection);\n+\n+    // setup canonical-path\n+    CanonicalPath canonical_projection\n+      = TraitImplProjection::resolve (impl_block.get_node_id (),\n+\t\t\t\t      canonical_trait_type,\n+\t\t\t\t      canonical_impl_type);\n+    CanonicalPath cpath = CanonicalPath::create_empty ();\n+    if (canonical_prefix.size () > 1)\n+      {\n+\tstd::string projection_str = canonical_projection.get ();\n+\tstd::string seg_buf\n+\t  = \"<impl \" + projection_str.substr (1, projection_str.size () - 2)\n+\t    + \">\";\n+\tCanonicalPath seg\n+\t  = CanonicalPath::new_seg (impl_block.get_node_id (), seg_buf);\n+\tcpath = canonical_prefix.append (seg);\n+      }\n+    else\n+      {\n+\tcpath = canonical_prefix.append (canonical_projection);\n+      }\n+    // DONE setup canonical-path\n+\n     auto Self\n       = CanonicalPath::get_big_self (impl_block.get_type ()->get_node_id ());\n \n@@ -581,7 +782,7 @@ class ResolveItem : public ResolverBase\n \n     for (auto &impl_item : impl_block.get_impl_items ())\n       {\n-\tresolve_impl_item (impl_item.get ());\n+\tresolve_impl_item (impl_item.get (), impl_prefix, cpath);\n       }\n \n     resolver->get_type_scope ().peek ()->clear_name (\n@@ -625,9 +826,14 @@ class ResolveItem : public ResolverBase\n     if (trait.has_where_clause ())\n       ResolveWhereClause::Resolve (trait.get_where_clause ());\n \n+    // resolve the paths\n+    CanonicalPath path = CanonicalPath::create_empty ();\n+    CanonicalPath cpath = CanonicalPath::create_empty ();\n+    //\n+\n     for (auto &item : trait.get_trait_items ())\n       {\n-\tResolveTraitItems::go (item.get ());\n+\tResolveTraitItems::go (item.get (), path, cpath);\n       }\n \n     resolver->get_type_scope ().pop ();\n@@ -643,27 +849,39 @@ class ResolveItem : public ResolverBase\n   }\n \n protected:\n-  void resolve_impl_item (AST::TraitImplItem *item);\n-  void resolve_impl_item (AST::InherentImplItem *item);\n+  void resolve_impl_item (AST::TraitImplItem *item, const CanonicalPath &prefix,\n+\t\t\t  const CanonicalPath &canonical_prefix);\n+  void resolve_impl_item (AST::InherentImplItem *item,\n+\t\t\t  const CanonicalPath &prefix,\n+\t\t\t  const CanonicalPath &canonical_prefix);\n   void resolve_extern_item (AST::ExternalItem *item);\n \n-  ResolveItem () : ResolverBase (UNKNOWN_NODEID) {}\n+  ResolveItem (const CanonicalPath &prefix,\n+\t       const CanonicalPath &canonical_prefix)\n+    : ResolverBase (UNKNOWN_NODEID), prefix (prefix),\n+      canonical_prefix (canonical_prefix)\n+  {}\n+\n+  const CanonicalPath &prefix;\n+  const CanonicalPath &canonical_prefix;\n };\n \n class ResolveImplItems : public ResolveItem\n {\n   using Rust::Resolver::ResolveItem::visit;\n \n public:\n-  static void go (AST::InherentImplItem *item)\n+  static void go (AST::InherentImplItem *item, const CanonicalPath &prefix,\n+\t\t  const CanonicalPath &canonical_prefix)\n   {\n-    ResolveImplItems resolver;\n+    ResolveImplItems resolver (prefix, canonical_prefix);\n     item->accept_vis (resolver);\n   };\n \n-  static void go (AST::TraitImplItem *item)\n+  static void go (AST::TraitImplItem *item, const CanonicalPath &prefix,\n+\t\t  const CanonicalPath &canonical_prefix)\n   {\n-    ResolveImplItems resolver;\n+    ResolveImplItems resolver (prefix, canonical_prefix);\n     item->accept_vis (resolver);\n   };\n \n@@ -677,7 +895,10 @@ class ResolveImplItems : public ResolveItem\n   }\n \n private:\n-  ResolveImplItems () : ResolveItem () {}\n+  ResolveImplItems (const CanonicalPath &prefix,\n+\t\t    const CanonicalPath &canonical_prefix)\n+    : ResolveItem (prefix, canonical_prefix)\n+  {}\n };\n \n class ResolveExternItem : public ResolverBase"}, {"sha": "0c7c8f37a3a5283ab223fc7fbf983bdecacd7ce5", "filename": "gcc/rust/resolve/rust-ast-resolve-pattern.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/631f7ae7b9dbb55ed3adce942952f93b48983a53/gcc%2Frust%2Fresolve%2Frust-ast-resolve-pattern.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/631f7ae7b9dbb55ed3adce942952f93b48983a53/gcc%2Frust%2Fresolve%2Frust-ast-resolve-pattern.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-pattern.cc?ref=631f7ae7b9dbb55ed3adce942952f93b48983a53", "patch": "@@ -25,13 +25,13 @@ namespace Resolver {\n void\n PatternDeclaration::visit (AST::PathInExpression &pattern)\n {\n-  ResolveExpr::go (&pattern, parent);\n+  ResolvePath::go (&pattern, parent);\n }\n \n void\n PatternDeclaration::visit (AST::TupleStructPattern &pattern)\n {\n-  ResolveExpr::go (&pattern.get_path (), parent);\n+  ResolvePath::go (&pattern.get_path (), parent);\n \n   std::unique_ptr<AST::TupleStructItems> &items = pattern.get_items ();\n   switch (items->get_item_type ())\n@@ -59,7 +59,7 @@ PatternDeclaration::visit (AST::TupleStructPattern &pattern)\n void\n PatternDeclaration::visit (AST::StructPattern &pattern)\n {\n-  ResolveExpr::go (&pattern.get_path (), parent);\n+  ResolvePath::go (&pattern.get_path (), parent);\n \n   auto &struct_pattern_elems = pattern.get_struct_pattern_elems ();\n   for (auto &field : struct_pattern_elems.get_struct_pattern_fields ())"}, {"sha": "308de146f996bd3e31f29327a0f5b7e5894555ee", "filename": "gcc/rust/resolve/rust-ast-resolve-stmt.h", "status": "modified", "additions": 85, "deletions": 25, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/631f7ae7b9dbb55ed3adce942952f93b48983a53/gcc%2Frust%2Fresolve%2Frust-ast-resolve-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/631f7ae7b9dbb55ed3adce942952f93b48983a53/gcc%2Frust%2Fresolve%2Frust-ast-resolve-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-stmt.h?ref=631f7ae7b9dbb55ed3adce942952f93b48983a53", "patch": "@@ -33,27 +33,34 @@ class ResolveStmt : public ResolverBase\n   using Rust::Resolver::ResolverBase::visit;\n \n public:\n-  static void go (AST::Stmt *stmt, NodeId parent,\n-\t\t  const CanonicalPath &enum_prefix\n-\t\t  = CanonicalPath::create_empty ())\n+  static void go (AST::Stmt *stmt, NodeId parent, const CanonicalPath &prefix,\n+\t\t  const CanonicalPath &canonical_prefix,\n+\t\t  const CanonicalPath &enum_prefix)\n   {\n-    ResolveStmt resolver (parent, enum_prefix);\n+    ResolveStmt resolver (parent, prefix, canonical_prefix, enum_prefix);\n     stmt->accept_vis (resolver);\n   };\n \n   void visit (AST::ExprStmtWithBlock &stmt) override\n   {\n-    ResolveExpr::go (stmt.get_expr ().get (), stmt.get_node_id ());\n+    ResolveExpr::go (stmt.get_expr ().get (), stmt.get_node_id (), prefix,\n+\t\t     canonical_prefix);\n   }\n \n   void visit (AST::ExprStmtWithoutBlock &stmt) override\n   {\n-    ResolveExpr::go (stmt.get_expr ().get (), stmt.get_node_id ());\n+    ResolveExpr::go (stmt.get_expr ().get (), stmt.get_node_id (), prefix,\n+\t\t     canonical_prefix);\n   }\n \n   void visit (AST::ConstantItem &constant) override\n   {\n-    auto path = ResolveConstantItemToCanonicalPath::resolve (constant);\n+    auto decl = ResolveConstantItemToCanonicalPath::resolve (constant);\n+    auto path = decl; // this ensures we have the correct relative resolution\n+    auto cpath = canonical_prefix.append (decl);\n+    mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t     constant.get_node_id (), cpath);\n+\n     resolver->get_name_scope ().insert (\n       path, constant.get_node_id (), constant.get_locus (), false,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n@@ -66,7 +73,8 @@ class ResolveStmt : public ResolverBase\n \t\t\t\t\t\tconstant.get_node_id ()});\n \n     ResolveType::go (constant.get_type ().get (), constant.get_node_id ());\n-    ResolveExpr::go (constant.get_expr ().get (), constant.get_node_id ());\n+    ResolveExpr::go (constant.get_expr ().get (), constant.get_node_id (),\n+\t\t     prefix, canonical_prefix);\n \n     // the mutability checker needs to verify for immutable decls the number\n     // of assignments are <1. This marks an implicit assignment\n@@ -79,7 +87,8 @@ class ResolveStmt : public ResolverBase\n   {\n     if (stmt.has_init_expr ())\n       {\n-\tResolveExpr::go (stmt.get_init_expr ().get (), stmt.get_node_id ());\n+\tResolveExpr::go (stmt.get_init_expr ().get (), stmt.get_node_id (),\n+\t\t\t prefix, canonical_prefix);\n \n \t// mark the assignment\n \tresolver->mark_assignment_to_decl (\n@@ -93,8 +102,13 @@ class ResolveStmt : public ResolverBase\n \n   void visit (AST::TupleStruct &struct_decl) override\n   {\n-    auto path = CanonicalPath::new_seg (struct_decl.get_node_id (),\n+    auto decl = CanonicalPath::new_seg (struct_decl.get_node_id (),\n \t\t\t\t\tstruct_decl.get_identifier ());\n+    auto path = decl; // this ensures we have the correct relative resolution\n+    auto cpath = canonical_prefix.append (decl);\n+    mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t     struct_decl.get_node_id (), cpath);\n+\n     resolver->get_type_scope ().insert (\n       path, struct_decl.get_node_id (), struct_decl.get_locus (), false,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n@@ -124,10 +138,15 @@ class ResolveStmt : public ResolverBase\n \n   void visit (AST::Enum &enum_decl) override\n   {\n-    auto enum_path = CanonicalPath::new_seg (enum_decl.get_node_id (),\n-\t\t\t\t\t     enum_decl.get_identifier ());\n+    auto decl = CanonicalPath::new_seg (enum_decl.get_node_id (),\n+\t\t\t\t\tenum_decl.get_identifier ());\n+    auto path = decl; // this ensures we have the correct relative resolution\n+    auto cpath = canonical_prefix.append (decl);\n+    mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t     enum_decl.get_node_id (), cpath);\n+\n     resolver->get_type_scope ().insert (\n-      enum_path, enum_decl.get_node_id (), enum_decl.get_locus (), false,\n+      path, enum_decl.get_node_id (), enum_decl.get_locus (), false,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n \tRichLocation r (enum_decl.get_locus ());\n \tr.add_range (locus);\n@@ -146,15 +165,20 @@ class ResolveStmt : public ResolverBase\n       }\n \n     for (auto &variant : enum_decl.get_variants ())\n-      ResolveStmt::go (variant.get (), parent, enum_path);\n+      ResolveStmt::go (variant.get (), parent, path, canonical_prefix, path);\n \n     resolver->get_type_scope ().pop ();\n   }\n \n   void visit (AST::EnumItem &item) override\n   {\n-    auto path = enum_prefix.append (\n+    auto decl = enum_prefix.append (\n       CanonicalPath::new_seg (item.get_node_id (), item.get_identifier ()));\n+    auto path = decl; // this ensures we have the correct relative resolution\n+    auto cpath = canonical_prefix.append (decl);\n+    mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t     item.get_node_id (), cpath);\n+\n     resolver->get_type_scope ().insert (\n       path, item.get_node_id (), item.get_locus (), false,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n@@ -168,8 +192,13 @@ class ResolveStmt : public ResolverBase\n \n   void visit (AST::EnumItemTuple &item) override\n   {\n-    auto path = enum_prefix.append (\n+    auto decl = enum_prefix.append (\n       CanonicalPath::new_seg (item.get_node_id (), item.get_identifier ()));\n+    auto path = decl; // this ensures we have the correct relative resolution\n+    auto cpath = canonical_prefix.append (decl);\n+    mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t     item.get_node_id (), cpath);\n+\n     resolver->get_type_scope ().insert (\n       path, item.get_node_id (), item.get_locus (), false,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n@@ -184,8 +213,13 @@ class ResolveStmt : public ResolverBase\n \n   void visit (AST::EnumItemStruct &item) override\n   {\n-    auto path = enum_prefix.append (\n+    auto decl = enum_prefix.append (\n       CanonicalPath::new_seg (item.get_node_id (), item.get_identifier ()));\n+    auto path = decl; // this ensures we have the correct relative resolution\n+    auto cpath = canonical_prefix.append (decl);\n+    mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t     item.get_node_id (), cpath);\n+\n     resolver->get_type_scope ().insert (\n       path, item.get_node_id (), item.get_locus (), false,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n@@ -200,8 +234,13 @@ class ResolveStmt : public ResolverBase\n \n   void visit (AST::EnumItemDiscriminant &item) override\n   {\n-    auto path = enum_prefix.append (\n+    auto decl = enum_prefix.append (\n       CanonicalPath::new_seg (item.get_node_id (), item.get_identifier ()));\n+    auto path = decl; // this ensures we have the correct relative resolution\n+    auto cpath = canonical_prefix.append (decl);\n+    mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t     item.get_node_id (), cpath);\n+\n     resolver->get_type_scope ().insert (\n       path, item.get_node_id (), item.get_locus (), false,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n@@ -215,8 +254,13 @@ class ResolveStmt : public ResolverBase\n \n   void visit (AST::StructStruct &struct_decl) override\n   {\n-    auto path = CanonicalPath::new_seg (struct_decl.get_node_id (),\n+    auto decl = CanonicalPath::new_seg (struct_decl.get_node_id (),\n \t\t\t\t\tstruct_decl.get_identifier ());\n+    auto path = decl; // this ensures we have the correct relative resolution\n+    auto cpath = canonical_prefix.append (decl);\n+    mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t     struct_decl.get_node_id (), cpath);\n+\n     resolver->get_type_scope ().insert (\n       path, struct_decl.get_node_id (), struct_decl.get_locus (), false,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n@@ -246,8 +290,13 @@ class ResolveStmt : public ResolverBase\n \n   void visit (AST::Union &union_decl) override\n   {\n-    auto path = CanonicalPath::new_seg (union_decl.get_node_id (),\n+    auto decl = CanonicalPath::new_seg (union_decl.get_node_id (),\n \t\t\t\t\tunion_decl.get_identifier ());\n+    auto path = decl; // this ensures we have the correct relative resolution\n+    auto cpath = canonical_prefix.append (decl);\n+    mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t     union_decl.get_node_id (), cpath);\n+\n     resolver->get_type_scope ().insert (\n       path, union_decl.get_node_id (), union_decl.get_locus (), false,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n@@ -276,7 +325,12 @@ class ResolveStmt : public ResolverBase\n \n   void visit (AST::Function &function) override\n   {\n-    auto path = ResolveFunctionItemToCanonicalPath::resolve (function);\n+    auto decl = ResolveFunctionItemToCanonicalPath::resolve (function);\n+    auto path = decl; // this ensures we have the correct relative resolution\n+    auto cpath = canonical_prefix.append (decl);\n+    mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t     function.get_node_id (), cpath);\n+\n     resolver->get_name_scope ().insert (\n       path, function.get_node_id (), function.get_locus (), false,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n@@ -321,19 +375,25 @@ class ResolveStmt : public ResolverBase\n       }\n \n     // resolve the function body\n-    ResolveExpr::go (function.get_definition ().get (),\n-\t\t     function.get_node_id ());\n+    ResolveExpr::go (function.get_definition ().get (), function.get_node_id (),\n+\t\t     path, cpath);\n \n     resolver->get_name_scope ().pop ();\n     resolver->get_type_scope ().pop ();\n     resolver->get_label_scope ().pop ();\n   }\n \n private:\n-  ResolveStmt (NodeId parent, const CanonicalPath &enum_prefix)\n-    : ResolverBase (parent), enum_prefix (enum_prefix)\n+  ResolveStmt (NodeId parent, const CanonicalPath &prefix,\n+\t       const CanonicalPath &canonical_prefix,\n+\t       const CanonicalPath &enum_prefix)\n+    : ResolverBase (parent), prefix (prefix),\n+      canonical_prefix (canonical_prefix), enum_prefix (enum_prefix)\n   {}\n \n+  const CanonicalPath &prefix;\n+  const CanonicalPath &canonical_prefix;\n+\n   /* item declaration statements are not given a canonical path, but enum items\n    * (variants) do inherit the enum path/identifier name.  */\n   const CanonicalPath &enum_prefix;"}, {"sha": "b2c30a95dbc26d7a90d2523f04c2c3fd7520c237", "filename": "gcc/rust/resolve/rust-ast-resolve-struct-expr-field.h", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/631f7ae7b9dbb55ed3adce942952f93b48983a53/gcc%2Frust%2Fresolve%2Frust-ast-resolve-struct-expr-field.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/631f7ae7b9dbb55ed3adce942952f93b48983a53/gcc%2Frust%2Fresolve%2Frust-ast-resolve-struct-expr-field.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-struct-expr-field.h?ref=631f7ae7b9dbb55ed3adce942952f93b48983a53", "patch": "@@ -32,9 +32,11 @@ class ResolveStructExprField : public ResolverBase\n   using Rust::Resolver::ResolverBase::visit;\n \n public:\n-  static void go (AST::StructExprField *field, NodeId parent)\n+  static void go (AST::StructExprField *field, NodeId parent,\n+\t\t  const CanonicalPath &prefix,\n+\t\t  const CanonicalPath &canonical_prefix)\n   {\n-    ResolveStructExprField resolver (parent);\n+    ResolveStructExprField resolver (parent, prefix, canonical_prefix);\n     field->accept_vis (resolver);\n   }\n \n@@ -47,7 +49,14 @@ class ResolveStructExprField : public ResolverBase\n   void visit (AST::StructExprFieldIdentifier &field) override;\n \n private:\n-  ResolveStructExprField (NodeId parent) : ResolverBase (parent) {}\n+  ResolveStructExprField (NodeId parent, const CanonicalPath &prefix,\n+\t\t\t  const CanonicalPath &canonical_prefix)\n+    : ResolverBase (parent), prefix (prefix),\n+      canonical_prefix (canonical_prefix)\n+  {}\n+\n+  const CanonicalPath &prefix;\n+  const CanonicalPath &canonical_prefix;\n };\n \n } // namespace Resolver"}, {"sha": "56962f617240ceb02d65b78f9f347d19541435e8", "filename": "gcc/rust/resolve/rust-ast-resolve-toplevel.h", "status": "modified", "additions": 126, "deletions": 41, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/631f7ae7b9dbb55ed3adce942952f93b48983a53/gcc%2Frust%2Fresolve%2Frust-ast-resolve-toplevel.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/631f7ae7b9dbb55ed3adce942952f93b48983a53/gcc%2Frust%2Fresolve%2Frust-ast-resolve-toplevel.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-toplevel.h?ref=631f7ae7b9dbb55ed3adce942952f93b48983a53", "patch": "@@ -33,17 +33,20 @@ class ResolveTopLevel : public ResolverBase\n   using Rust::Resolver::ResolverBase::visit;\n \n public:\n-  static void go (AST::Item *item,\n-\t\t  const CanonicalPath &prefix = CanonicalPath::create_empty ())\n+  static void go (AST::Item *item, const CanonicalPath &prefix,\n+\t\t  const CanonicalPath &canonical_prefix)\n   {\n-    ResolveTopLevel resolver (prefix);\n+    ResolveTopLevel resolver (prefix, canonical_prefix);\n     item->accept_vis (resolver);\n   };\n \n   void visit (AST::Module &module) override\n   {\n-    auto path = prefix.append (\n-      CanonicalPath::new_seg (module.get_node_id (), module.get_name ()));\n+    auto mod\n+      = CanonicalPath::new_seg (module.get_node_id (), module.get_name ());\n+    auto path = prefix.append (mod);\n+    auto cpath = canonical_prefix.append (mod);\n+\n     resolver->get_name_scope ().insert (\n       path, module.get_node_id (), module.get_locus (), false,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n@@ -57,42 +60,57 @@ class ResolveTopLevel : public ResolverBase\n \t\t\t\t\t\tmodule.get_node_id ()});\n \n     for (auto &item : module.get_items ())\n-      ResolveTopLevel::go (item.get (), path);\n+      ResolveTopLevel::go (item.get (), path, cpath);\n+\n+    mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t     module.get_node_id (), cpath);\n   }\n \n   void visit (AST::TypeAlias &alias) override\n   {\n-    auto path\n-      = prefix.append (CanonicalPath::new_seg (alias.get_node_id (),\n-\t\t\t\t\t       alias.get_new_type_name ()));\n+    auto talias = CanonicalPath::new_seg (alias.get_node_id (),\n+\t\t\t\t\t  alias.get_new_type_name ());\n+    auto path = prefix.append (talias);\n+    auto cpath = canonical_prefix.append (talias);\n+\n     resolver->get_type_scope ().insert (\n       path, alias.get_node_id (), alias.get_locus (), false,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n \tRichLocation r (alias.get_locus ());\n \tr.add_range (locus);\n \trust_error_at (r, \"redefined multiple times\");\n       });\n+\n+    mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t     alias.get_node_id (), cpath);\n   }\n \n   void visit (AST::TupleStruct &struct_decl) override\n   {\n-    auto path\n-      = prefix.append (CanonicalPath::new_seg (struct_decl.get_node_id (),\n-\t\t\t\t\t       struct_decl.get_identifier ()));\n+    auto decl = CanonicalPath::new_seg (struct_decl.get_node_id (),\n+\t\t\t\t\tstruct_decl.get_identifier ());\n+    auto path = prefix.append (decl);\n+    auto cpath = canonical_prefix.append (decl);\n+\n     resolver->get_type_scope ().insert (\n       path, struct_decl.get_node_id (), struct_decl.get_locus (), false,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n \tRichLocation r (struct_decl.get_locus ());\n \tr.add_range (locus);\n \trust_error_at (r, \"redefined multiple times\");\n       });\n+\n+    mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t     struct_decl.get_node_id (), cpath);\n   }\n \n   void visit (AST::Enum &enum_decl) override\n   {\n-    auto path\n-      = prefix.append (CanonicalPath::new_seg (enum_decl.get_node_id (),\n-\t\t\t\t\t       enum_decl.get_identifier ()));\n+    auto decl = CanonicalPath::new_seg (enum_decl.get_node_id (),\n+\t\t\t\t\tenum_decl.get_identifier ());\n+    auto path = prefix.append (decl);\n+    auto cpath = canonical_prefix.append (decl);\n+\n     resolver->get_type_scope ().insert (\n       path, enum_decl.get_node_id (), enum_decl.get_locus (), false,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n@@ -102,93 +120,133 @@ class ResolveTopLevel : public ResolverBase\n       });\n \n     for (auto &variant : enum_decl.get_variants ())\n-      ResolveTopLevel::go (variant.get (), path);\n+      ResolveTopLevel::go (variant.get (), path, cpath);\n+\n+    mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t     enum_decl.get_node_id (), cpath);\n   }\n \n   void visit (AST::EnumItem &item) override\n   {\n-    auto path = prefix.append (\n-      CanonicalPath::new_seg (item.get_node_id (), item.get_identifier ()));\n+    auto decl\n+      = CanonicalPath::new_seg (item.get_node_id (), item.get_identifier ());\n+    auto path = prefix.append (decl);\n+    auto cpath = canonical_prefix.append (decl);\n+\n     resolver->get_type_scope ().insert (\n       path, item.get_node_id (), item.get_locus (), false,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n \tRichLocation r (item.get_locus ());\n \tr.add_range (locus);\n \trust_error_at (r, \"redefined multiple times\");\n       });\n+\n+    mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t     item.get_node_id (), cpath);\n   }\n \n   void visit (AST::EnumItemTuple &item) override\n   {\n-    auto path = prefix.append (\n-      CanonicalPath::new_seg (item.get_node_id (), item.get_identifier ()));\n+    auto decl\n+      = CanonicalPath::new_seg (item.get_node_id (), item.get_identifier ());\n+    auto path = prefix.append (decl);\n+    auto cpath = canonical_prefix.append (decl);\n+\n     resolver->get_type_scope ().insert (\n       path, item.get_node_id (), item.get_locus (), false,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n \tRichLocation r (item.get_locus ());\n \tr.add_range (locus);\n \trust_error_at (r, \"redefined multiple times\");\n       });\n+\n+    mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t     item.get_node_id (), cpath);\n   }\n \n   void visit (AST::EnumItemStruct &item) override\n   {\n-    auto path = prefix.append (\n-      CanonicalPath::new_seg (item.get_node_id (), item.get_identifier ()));\n+    auto decl\n+      = CanonicalPath::new_seg (item.get_node_id (), item.get_identifier ());\n+    auto path = prefix.append (decl);\n+    auto cpath = canonical_prefix.append (decl);\n+\n     resolver->get_type_scope ().insert (\n       path, item.get_node_id (), item.get_locus (), false,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n \tRichLocation r (item.get_locus ());\n \tr.add_range (locus);\n \trust_error_at (r, \"redefined multiple times\");\n       });\n+\n+    mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t     item.get_node_id (), cpath);\n   }\n \n   void visit (AST::EnumItemDiscriminant &item) override\n   {\n-    auto path = prefix.append (\n-      CanonicalPath::new_seg (item.get_node_id (), item.get_identifier ()));\n+    auto decl\n+      = CanonicalPath::new_seg (item.get_node_id (), item.get_identifier ());\n+    auto path = prefix.append (decl);\n+    auto cpath = canonical_prefix.append (decl);\n+\n     resolver->get_type_scope ().insert (\n       path, item.get_node_id (), item.get_locus (), false,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n \tRichLocation r (item.get_locus ());\n \tr.add_range (locus);\n \trust_error_at (r, \"redefined multiple times\");\n       });\n+\n+    mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t     item.get_node_id (), cpath);\n   }\n \n   void visit (AST::StructStruct &struct_decl) override\n   {\n-    auto path\n-      = prefix.append (CanonicalPath::new_seg (struct_decl.get_node_id (),\n-\t\t\t\t\t       struct_decl.get_identifier ()));\n+    auto decl = CanonicalPath::new_seg (struct_decl.get_node_id (),\n+\t\t\t\t\tstruct_decl.get_identifier ());\n+    auto path = prefix.append (decl);\n+    auto cpath = canonical_prefix.append (decl);\n+\n     resolver->get_type_scope ().insert (\n       path, struct_decl.get_node_id (), struct_decl.get_locus (), false,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n \tRichLocation r (struct_decl.get_locus ());\n \tr.add_range (locus);\n \trust_error_at (r, \"redefined multiple times\");\n       });\n+\n+    mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t     struct_decl.get_node_id (), cpath);\n   }\n \n   void visit (AST::Union &union_decl) override\n   {\n-    auto path\n-      = prefix.append (CanonicalPath::new_seg (union_decl.get_node_id (),\n-\t\t\t\t\t       union_decl.get_identifier ()));\n+    auto decl = CanonicalPath::new_seg (union_decl.get_node_id (),\n+\t\t\t\t\tunion_decl.get_identifier ());\n+    auto path = prefix.append (decl);\n+    auto cpath = canonical_prefix.append (decl);\n+\n     resolver->get_type_scope ().insert (\n       path, union_decl.get_node_id (), union_decl.get_locus (), false,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n \tRichLocation r (union_decl.get_locus ());\n \tr.add_range (locus);\n \trust_error_at (r, \"redefined multiple times\");\n       });\n+\n+    mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t     union_decl.get_node_id (), cpath);\n   }\n \n   void visit (AST::StaticItem &var) override\n   {\n-    auto path = prefix.append (\n-      CanonicalPath::new_seg (var.get_node_id (), var.get_identifier ()));\n+    auto decl\n+      = CanonicalPath::new_seg (var.get_node_id (), var.get_identifier ());\n+    auto path = prefix.append (decl);\n+    auto cpath = canonical_prefix.append (decl);\n+\n     resolver->get_name_scope ().insert (\n       path, var.get_node_id (), var.get_locus (), false,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n@@ -200,12 +258,17 @@ class ResolveTopLevel : public ResolverBase\n \t\t\t\t     Definition{var.get_node_id (),\n \t\t\t\t\t\tvar.get_node_id ()});\n     resolver->mark_decl_mutability (var.get_node_id (), var.is_mutable ());\n+\n+    mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t     var.get_node_id (), cpath);\n   }\n \n   void visit (AST::ConstantItem &constant) override\n   {\n-    auto path\n-      = prefix.append (ResolveConstantItemToCanonicalPath::resolve (constant));\n+    auto decl = ResolveConstantItemToCanonicalPath::resolve (constant);\n+    auto path = prefix.append (decl);\n+    auto cpath = canonical_prefix.append (decl);\n+\n     resolver->get_name_scope ().insert (\n       path, constant.get_node_id (), constant.get_locus (), false,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n@@ -216,15 +279,20 @@ class ResolveTopLevel : public ResolverBase\n     resolver->insert_new_definition (constant.get_node_id (),\n \t\t\t\t     Definition{constant.get_node_id (),\n \t\t\t\t\t\tconstant.get_node_id ()});\n+\n+    mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t     constant.get_node_id (), cpath);\n   }\n \n   void visit (AST::Function &function) override\n   {\n     if (function.is_marked_for_strip ())\n       return;\n \n-    auto path\n-      = prefix.append (ResolveFunctionItemToCanonicalPath::resolve (function));\n+    auto decl = ResolveFunctionItemToCanonicalPath::resolve (function);\n+    auto path = prefix.append (decl);\n+    auto cpath = canonical_prefix.append (decl);\n+\n     resolver->get_name_scope ().insert (\n       path, function.get_node_id (), function.get_locus (), false,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n@@ -243,12 +311,16 @@ class ResolveTopLevel : public ResolverBase\n \tresolver->insert_resolved_name (function.get_node_id (),\n \t\t\t\t\tfunction.get_node_id ());\n       }\n+\n+    mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t     function.get_node_id (), cpath);\n   }\n \n   void visit (AST::InherentImpl &impl_block) override\n   {\n     bool canonicalize_type_args = !impl_block.has_generics ();\n     bool type_resolve_generic_args = false;\n+\n     CanonicalPath impl_type\n       = ResolveTypeToCanonicalPath::resolve (*impl_block.get_type ().get (),\n \t\t\t\t\t     canonicalize_type_args,\n@@ -257,6 +329,8 @@ class ResolveTopLevel : public ResolverBase\n \n     for (auto &impl_item : impl_block.get_impl_items ())\n       ResolveToplevelImplItem::go (impl_item.get (), impl_prefix);\n+\n+    // we cannot resolve canonical paths here until later on\n   }\n \n   void visit (AST::TraitImpl &impl_block) override\n@@ -293,12 +367,17 @@ class ResolveTopLevel : public ResolverBase\n \n     for (auto &impl_item : impl_block.get_impl_items ())\n       ResolveToplevelImplItem::go (impl_item.get (), impl_prefix);\n+\n+    // we cannot resolve canonical paths here until later on\n   }\n \n   void visit (AST::Trait &trait) override\n   {\n-    CanonicalPath path = prefix.append (\n-      CanonicalPath::new_seg (trait.get_node_id (), trait.get_identifier ()));\n+    auto decl\n+      = CanonicalPath::new_seg (trait.get_node_id (), trait.get_identifier ());\n+    auto path = prefix.append (decl);\n+    auto cpath = canonical_prefix.append (decl);\n+\n     resolver->get_type_scope ().insert (\n       path, trait.get_node_id (), trait.get_locus (), false,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n@@ -308,7 +387,10 @@ class ResolveTopLevel : public ResolverBase\n       });\n \n     for (auto &item : trait.get_trait_items ())\n-      ResolveTopLevelTraitItems::go (item.get (), path);\n+      ResolveTopLevelTraitItems::go (item.get (), path, cpath);\n+\n+    mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t     trait.get_node_id (), cpath);\n   }\n \n   void visit (AST::ExternBlock &extern_block) override\n@@ -320,11 +402,14 @@ class ResolveTopLevel : public ResolverBase\n   }\n \n private:\n-  ResolveTopLevel (const CanonicalPath &prefix)\n-    : ResolverBase (UNKNOWN_NODEID), prefix (prefix)\n+  ResolveTopLevel (const CanonicalPath &prefix,\n+\t\t   const CanonicalPath &canonical_prefix)\n+    : ResolverBase (UNKNOWN_NODEID), prefix (prefix),\n+      canonical_prefix (canonical_prefix)\n   {}\n \n   const CanonicalPath &prefix;\n+  const CanonicalPath &canonical_prefix;\n };\n \n } // namespace Resolver"}, {"sha": "f7bdc9efb4ed4a8b9fb08721f3931b8d31f69f9a", "filename": "gcc/rust/resolve/rust-ast-resolve-type.h", "status": "modified", "additions": 66, "deletions": 16, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/631f7ae7b9dbb55ed3adce942952f93b48983a53/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/631f7ae7b9dbb55ed3adce942952f93b48983a53/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h?ref=631f7ae7b9dbb55ed3adce942952f93b48983a53", "patch": "@@ -250,9 +250,11 @@ class ResolveType : public ResolverBase\n \n public:\n   static NodeId go (AST::Type *type, NodeId parent,\n-\t\t    bool canonicalize_type_with_generics = false)\n+\t\t    bool canonicalize_type_with_generics = false,\n+\t\t    CanonicalPath *canonical_path = nullptr)\n   {\n-    ResolveType resolver (parent, canonicalize_type_with_generics);\n+    ResolveType resolver (parent, canonicalize_type_with_generics,\n+\t\t\t  canonical_path);\n     type->accept_vis (resolver);\n     if (!resolver.ok)\n       rust_error_at (type->get_locus (), \"unresolved type\");\n@@ -285,35 +287,52 @@ class ResolveType : public ResolverBase\n \n   void visit (AST::TypePath &path) override\n   {\n-    auto canonical_path\n+    auto rel_canonical_path\n       = ResolveTypeToCanonicalPath::resolve (path,\n \t\t\t\t\t     canonicalize_type_with_generics,\n \t\t\t\t\t     true);\n-    if (canonical_path.is_empty ())\n+    if (rel_canonical_path.is_empty ())\n       {\n \trust_error_at (path.get_locus (),\n \t\t       \"Failed to resolve canonical path for TypePath\");\n \treturn;\n       }\n \n-    ok = !canonical_path.is_empty ();\n+    ok = !rel_canonical_path.is_empty ();\n \n     // lets try and resolve in one go else leave it up to the type resolver to\n     // figure outer\n \n-    if (resolver->get_type_scope ().lookup (canonical_path, &resolved_node))\n+    if (resolver->get_type_scope ().lookup (rel_canonical_path, &resolved_node))\n       {\n \tresolver->insert_resolved_type (path.get_node_id (), resolved_node);\n \tresolver->insert_new_definition (path.get_node_id (),\n \t\t\t\t\t Definition{path.get_node_id (),\n \t\t\t\t\t\t    parent});\n+\n+\tif (canonical_path != nullptr)\n+\t  {\n+\t    const CanonicalPath *cpath = nullptr;\n+\t    bool ok\n+\t      = mappings->lookup_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t\t\t resolved_node, &cpath);\n+\t    if (!ok)\n+\t      {\n+\t\t*canonical_path = rel_canonical_path;\n+\t      }\n+\t    else\n+\t      {\n+\t\t*canonical_path = *cpath;\n+\t      }\n+\t  }\n+\n \treturn;\n       }\n \n     // lets resolve as many segments as we can and leave it up to the type\n     // resolver otherwise\n     size_t nprocessed = 0;\n-    canonical_path.iterate ([&] (const CanonicalPath &seg) -> bool {\n+    rel_canonical_path.iterate ([&] (const CanonicalPath &seg) -> bool {\n       resolved_node = UNKNOWN_NODEID;\n \n       if (!resolver->get_type_scope ().lookup (seg, &resolved_node))\n@@ -336,12 +355,22 @@ class ResolveType : public ResolverBase\n     // its ok if this fails since the type resolver sometimes will need to\n     // investigate the bounds of a type for the associated type for example see:\n     // https://github.com/Rust-GCC/gccrs/issues/746\n-    if (nprocessed == canonical_path.size ())\n+    if (nprocessed == rel_canonical_path.size ())\n       {\n \tresolver->insert_resolved_type (path.get_node_id (), resolved_node);\n \tresolver->insert_new_definition (path.get_node_id (),\n \t\t\t\t\t Definition{path.get_node_id (),\n \t\t\t\t\t\t    parent});\n+\n+\tif (canonical_path != nullptr)\n+\t  {\n+\t    const CanonicalPath *cpath = nullptr;\n+\t    bool ok\n+\t      = mappings->lookup_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t\t\t resolved_node, &cpath);\n+\t    rust_assert (ok);\n+\t    *canonical_path = *cpath;\n+\t  }\n       }\n   }\n \n@@ -356,28 +385,44 @@ class ResolveType : public ResolverBase\n   void visit (AST::ReferenceType &type) override\n   {\n     type.get_type_referenced ()->accept_vis (*this);\n+\n+    if (canonical_path != nullptr && canonical_path->size () > 0)\n+      {\n+\tstd::string seg = canonical_path->get ();\n+\t*canonical_path\n+\t  = CanonicalPath::new_seg (type.get_node_id (), \"&\" + seg);\n+      }\n   }\n \n   void visit (AST::InferredType &type) override { ok = true; }\n \n   void visit (AST::RawPointerType &type) override\n   {\n     type.get_type_pointed_to ()->accept_vis (*this);\n+\n+    if (canonical_path != nullptr && canonical_path->size () > 0)\n+      {\n+\tstd::string seg = canonical_path->get ();\n+\t*canonical_path\n+\t  = CanonicalPath::new_seg (type.get_node_id (), \"*\" + seg);\n+      }\n   }\n \n   void visit (AST::TraitObjectTypeOneBound &type) override;\n \n   void visit (AST::TraitObjectType &type) override;\n \n private:\n-  ResolveType (NodeId parent, bool canonicalize_type_with_generics)\n+  ResolveType (NodeId parent, bool canonicalize_type_with_generics,\n+\t       CanonicalPath *canonical_path)\n     : ResolverBase (parent),\n       canonicalize_type_with_generics (canonicalize_type_with_generics),\n-      ok (false)\n+      ok (false), canonical_path (canonical_path)\n   {}\n \n   bool canonicalize_type_with_generics;\n   bool ok;\n+  CanonicalPath *canonical_path;\n };\n \n class ResolveTypeBound : public ResolverBase\n@@ -453,16 +498,18 @@ class ResolveGenericParam : public ResolverBase\n \t  }\n       }\n \n-    // for now lets focus on handling the basics: like struct<T> { a:T, ....}\n+    auto seg = CanonicalPath::new_seg (param.get_node_id (),\n+\t\t\t\t       param.get_type_representation ());\n     resolver->get_type_scope ().insert (\n-      CanonicalPath::new_seg (param.get_node_id (),\n-\t\t\t      param.get_type_representation ()),\n-      param.get_node_id (), param.get_locus (), false,\n+      seg, param.get_node_id (), param.get_locus (), false,\n       [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n \trust_error_at (param.get_locus (),\n \t\t       \"generic param redefined multiple times\");\n \trust_error_at (locus, \"was defined here\");\n       });\n+\n+    mappings->insert_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t     param.get_node_id (), seg);\n   }\n \n private:\n@@ -483,7 +530,10 @@ class ResolveWhereClause : public ResolverBase\n       clause->accept_vis (r);\n   }\n \n-  void visit (AST::LifetimeWhereClauseItem &) override {}\n+  void visit (AST::LifetimeWhereClauseItem &) override\n+  {\n+    // nothing to do\n+  }\n \n   void visit (AST::TypeBoundWhereClauseItem &item) override\n   {\n@@ -499,7 +549,7 @@ class ResolveWhereClause : public ResolverBase\n \n private:\n   ResolveWhereClause (NodeId parent) : ResolverBase (parent) {}\n-}; // namespace Resolver\n+};\n \n } // namespace Resolver\n } // namespace Rust"}, {"sha": "96524d254ff074fd1c23425bee8f637bcee7508c", "filename": "gcc/rust/resolve/rust-ast-resolve.cc", "status": "modified", "additions": 43, "deletions": 14, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/631f7ae7b9dbb55ed3adce942952f93b48983a53/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/631f7ae7b9dbb55ed3adce942952f93b48983a53/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc?ref=631f7ae7b9dbb55ed3adce942952f93b48983a53", "patch": "@@ -313,6 +313,13 @@ NameResolution::Resolve (AST::Crate &crate)\n void\n NameResolution::go (AST::Crate &crate)\n {\n+  // lookup current crate name\n+  CrateNum cnum = mappings->get_current_crate ();\n+  std::string crate_name;\n+  bool ok = mappings->get_crate_name (cnum, crate_name);\n+  rust_assert (ok);\n+\n+  // setup the ribs\n   NodeId scope_node_id = crate.get_node_id ();\n   resolver->get_name_scope ().push (scope_node_id);\n   resolver->get_type_scope ().push (scope_node_id);\n@@ -321,16 +328,25 @@ NameResolution::go (AST::Crate &crate)\n   resolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n   resolver->push_new_label_rib (resolver->get_type_scope ().peek ());\n \n-  // first gather the top-level namespace names then we drill down\n+  // get the root segment\n+  CanonicalPath crate_prefix\n+    = CanonicalPath::new_seg (scope_node_id, crate_name);\n+  crate_prefix.set_crate_num (cnum);\n+\n+  // first gather the top-level namespace names then we drill down so this\n+  // allows for resolving forward declarations since an impl block might have\n+  // a Self type Foo which is defined after the impl block for example.\n   for (auto it = crate.items.begin (); it != crate.items.end (); it++)\n-    ResolveTopLevel::go (it->get ());\n+    ResolveTopLevel::go (it->get (), CanonicalPath::create_empty (),\n+\t\t\t crate_prefix);\n \n+  // FIXME remove this\n   if (saw_errors ())\n     return;\n \n   // next we can drill down into the items and their scopes\n   for (auto it = crate.items.begin (); it != crate.items.end (); it++)\n-    ResolveItem::go (it->get ());\n+    ResolveItem::go (it->get (), CanonicalPath::create_empty (), crate_prefix);\n }\n \n // rust-ast-resolve-expr.h\n@@ -349,17 +365,19 @@ ResolveExpr::visit (AST::BlockExpr &expr)\n   for (auto &s : expr.get_statements ())\n     {\n       if (s->is_item ())\n-\tResolveStmt::go (s.get (), s->get_node_id ());\n+\tResolveStmt::go (s.get (), s->get_node_id (), prefix, canonical_prefix,\n+\t\t\t CanonicalPath::create_empty ());\n     }\n \n   for (auto &s : expr.get_statements ())\n     {\n       if (!s->is_item ())\n-\tResolveStmt::go (s.get (), s->get_node_id ());\n+\tResolveStmt::go (s.get (), s->get_node_id (), prefix, canonical_prefix,\n+\t\t\t CanonicalPath::create_empty ());\n     }\n \n   if (expr.has_tail_expr ())\n-    ResolveExpr::go (expr.get_tail_expr ().get (), expr.get_node_id ());\n+    resolve_expr (expr.get_tail_expr ().get (), expr.get_node_id ());\n \n   resolver->get_name_scope ().pop ();\n   resolver->get_type_scope ().pop ();\n@@ -371,13 +389,15 @@ ResolveExpr::visit (AST::BlockExpr &expr)\n void\n ResolveStructExprField::visit (AST::StructExprFieldIdentifierValue &field)\n {\n-  ResolveExpr::go (field.get_value ().get (), field.get_node_id ());\n+  ResolveExpr::go (field.get_value ().get (), field.get_node_id (), prefix,\n+\t\t   canonical_prefix);\n }\n \n void\n ResolveStructExprField::visit (AST::StructExprFieldIndexValue &field)\n {\n-  ResolveExpr::go (field.get_value ().get (), field.get_node_id ());\n+  ResolveExpr::go (field.get_value ().get (), field.get_node_id (), prefix,\n+\t\t   canonical_prefix);\n }\n \n void\n@@ -386,7 +406,7 @@ ResolveStructExprField::visit (AST::StructExprFieldIdentifier &field)\n   AST::IdentifierExpr expr (field.get_field_name (), {}, field.get_locus ());\n   expr.set_node_id (field.get_node_id ());\n \n-  ResolveExpr::go (&expr, field.get_node_id ());\n+  ResolveExpr::go (&expr, field.get_node_id (), prefix, canonical_prefix);\n }\n \n // rust-ast-resolve-type.h\n@@ -746,7 +766,12 @@ void\n ResolveType::visit (AST::ArrayType &type)\n {\n   type.get_elem_type ()->accept_vis (*this);\n-  ResolveExpr::go (type.get_size_expr ().get (), type.get_node_id ());\n+  // FIXME\n+  // the capacity expr can contain block-expr with functions but these should be\n+  // folded via constexpr code\n+  ResolveExpr::go (type.get_size_expr ().get (), type.get_node_id (),\n+\t\t   CanonicalPath::create_empty (),\n+\t\t   CanonicalPath::create_empty ());\n }\n \n void\n@@ -771,15 +796,19 @@ ResolveType::visit (AST::TraitObjectType &type)\n // rust-ast-resolve-item.h\n \n void\n-ResolveItem::resolve_impl_item (AST::TraitImplItem *item)\n+ResolveItem::resolve_impl_item (AST::TraitImplItem *item,\n+\t\t\t\tconst CanonicalPath &prefix,\n+\t\t\t\tconst CanonicalPath &canonical_prefix)\n {\n-  ResolveImplItems::go (item);\n+  ResolveImplItems::go (item, prefix, canonical_prefix);\n }\n \n void\n-ResolveItem::resolve_impl_item (AST::InherentImplItem *item)\n+ResolveItem::resolve_impl_item (AST::InherentImplItem *item,\n+\t\t\t\tconst CanonicalPath &prefix,\n+\t\t\t\tconst CanonicalPath &canonical_prefix)\n {\n-  ResolveImplItems::go (item);\n+  ResolveImplItems::go (item, prefix, canonical_prefix);\n }\n \n void"}, {"sha": "199b0f98bd895b15c4f6f5d3bc583f7714c2114a", "filename": "gcc/rust/resolve/rust-name-resolver.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/631f7ae7b9dbb55ed3adce942952f93b48983a53/gcc%2Frust%2Fresolve%2Frust-name-resolver.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/631f7ae7b9dbb55ed3adce942952f93b48983a53/gcc%2Frust%2Fresolve%2Frust-name-resolver.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-name-resolver.h?ref=631f7ae7b9dbb55ed3adce942952f93b48983a53", "patch": "@@ -39,6 +39,7 @@ class Rib\n \n   ~Rib () {}\n \n+  // this takes the relative paths of items within a compilation unit for lookup\n   void insert_name (\n     const CanonicalPath &path, NodeId id, Location locus, bool shadow,\n     std::function<void (const CanonicalPath &, NodeId, Location)> dup_cb)\n@@ -60,7 +61,6 @@ class Rib\n     reverse_path_mappings.insert (std::pair<NodeId, CanonicalPath> (id, path));\n     decls_within_rib.insert (std::pair<NodeId, Location> (id, locus));\n     references[id] = {};\n-    mappings->insert_canonical_path (mappings->get_current_crate (), id, path);\n   }\n \n   bool lookup_name (const CanonicalPath &ident, NodeId *id)"}, {"sha": "83f35ffd727217828ce1364b4e5e30ff9a0f65b4", "filename": "gcc/rust/rust-session-manager.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/631f7ae7b9dbb55ed3adce942952f93b48983a53/gcc%2Frust%2Frust-session-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/631f7ae7b9dbb55ed3adce942952f93b48983a53/gcc%2Frust%2Frust-session-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-session-manager.cc?ref=631f7ae7b9dbb55ed3adce942952f93b48983a53", "patch": "@@ -69,7 +69,7 @@ const char *kHIRDumpFile = \"gccrs.hir.dump\";\n const char *kHIRTypeResolutionDumpFile = \"gccrs.type-resolution.dump\";\n const char *kTargetOptionsDumpFile = \"gccrs.target-options.dump\";\n \n-const std::string kDefaultCrateName = \"TestCrate\";\n+const std::string kDefaultCrateName = \"example\";\n \n // Implicitly enable a target_feature (and recursively enable dependencies).\n void"}, {"sha": "9b340750bbaf67a4b97ade7a69072cf7356db396", "filename": "gcc/rust/util/rust-canonical-path.h", "status": "modified", "additions": 28, "deletions": 8, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/631f7ae7b9dbb55ed3adce942952f93b48983a53/gcc%2Frust%2Futil%2Frust-canonical-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/631f7ae7b9dbb55ed3adce942952f93b48983a53/gcc%2Frust%2Futil%2Frust-canonical-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-canonical-path.h?ref=631f7ae7b9dbb55ed3adce942952f93b48983a53", "patch": "@@ -57,7 +57,8 @@ class CanonicalPath\n   static CanonicalPath new_seg (NodeId id, const std::string &path)\n   {\n     rust_assert (!path.empty ());\n-    return CanonicalPath ({std::pair<NodeId, std::string> (id, path)});\n+    return CanonicalPath ({std::pair<NodeId, std::string> (id, path)},\n+\t\t\t  UNKNOWN_CREATENUM);\n   }\n \n   std::string get () const\n@@ -77,21 +78,24 @@ class CanonicalPath\n     return CanonicalPath::new_seg (id, \"Self\");\n   }\n \n-  static CanonicalPath create_empty () { return CanonicalPath ({}); }\n+  static CanonicalPath create_empty ()\n+  {\n+    return CanonicalPath ({}, UNKNOWN_CREATENUM);\n+  }\n \n   bool is_empty () const { return segs.size () == 0; }\n \n   CanonicalPath append (const CanonicalPath &other) const\n   {\n     rust_assert (!other.is_empty ());\n     if (is_empty ())\n-      return CanonicalPath (other.segs);\n+      return CanonicalPath (other.segs, crate_num);\n \n     std::vector<std::pair<NodeId, std::string>> copy (segs);\n     for (auto &s : other.segs)\n       copy.push_back (s);\n \n-    return CanonicalPath (copy);\n+    return CanonicalPath (copy, crate_num);\n   }\n \n   // if we have the path A::B::C this will give a callback for each segment\n@@ -110,7 +114,7 @@ class CanonicalPath\n     for (auto &seg : segs)\n       {\n \tbuf.push_back (seg);\n-\tif (!cb (CanonicalPath (buf)))\n+\tif (!cb (CanonicalPath (buf, crate_num)))\n \t  return;\n       }\n   }\n@@ -131,7 +135,7 @@ class CanonicalPath\n       {\n \tstd::vector<std::pair<NodeId, std::string>> buf;\n \tbuf.push_back ({seg.first, seg.second});\n-\tif (!cb (CanonicalPath (buf)))\n+\tif (!cb (CanonicalPath (buf, crate_num)))\n \t  return;\n       }\n   }\n@@ -144,21 +148,37 @@ class CanonicalPath\n     return segs.back ().first;\n   }\n \n+  const std::pair<NodeId, std::string> &get_seg_at (size_t index) const\n+  {\n+    rust_assert (index < size ());\n+    return segs.at (index);\n+  }\n+\n   bool is_equal (const CanonicalPath &b) const\n   {\n     return get ().compare (b.get ()) == 0;\n   }\n \n+  void set_crate_num (CrateNum n) { crate_num = n; }\n+\n+  CrateNum get_crate_num () const\n+  {\n+    rust_assert (crate_num != UNKNOWN_CREATENUM);\n+    return crate_num;\n+  }\n+\n   bool operator== (const CanonicalPath &b) const { return is_equal (b); }\n \n   bool operator< (const CanonicalPath &b) const { return get () < b.get (); }\n \n private:\n-  explicit CanonicalPath (std::vector<std::pair<NodeId, std::string>> path)\n-    : segs (path)\n+  explicit CanonicalPath (std::vector<std::pair<NodeId, std::string>> path,\n+\t\t\t  CrateNum crate_num)\n+    : segs (path), crate_num (crate_num)\n   {}\n \n   std::vector<std::pair<NodeId, std::string>> segs;\n+  CrateNum crate_num;\n };\n \n } // namespace Resolver"}, {"sha": "af547ef59a1c53e9f2aa1628739b41b0a48925c7", "filename": "gcc/testsuite/rust/compile/canonical_paths1.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/631f7ae7b9dbb55ed3adce942952f93b48983a53/gcc%2Ftestsuite%2Frust%2Fcompile%2Fcanonical_paths1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/631f7ae7b9dbb55ed3adce942952f93b48983a53/gcc%2Ftestsuite%2Frust%2Fcompile%2Fcanonical_paths1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fcanonical_paths1.rs?ref=631f7ae7b9dbb55ed3adce942952f93b48983a53", "patch": "@@ -0,0 +1,25 @@\n+// { dg-additional-options \"-w -fdump-tree-gimple\" }\n+struct Foo(i32);\n+\n+trait TR {\n+    fn test(&self) -> i32;\n+}\n+\n+mod A {\n+    impl ::Foo {\n+        pub fn test(self) {}\n+        // { dg-final { scan-tree-dump-times {example::A::<impl example::Foo>::test} 2 gimple } }\n+    }\n+\n+    impl ::TR for ::Foo {\n+        fn test(&self) -> i32 {\n+            // { dg-final { scan-tree-dump-times {example::A::<impl example::Foo as example::TR>::test} 1 gimple } }\n+            self.0\n+        }\n+    }\n+}\n+\n+pub fn test() {\n+    let a = Foo(123);\n+    a.test();\n+}"}, {"sha": "2ace8c064d8ba1585707249895912d6cf3eba525", "filename": "gcc/testsuite/rust/compile/torture/mod3.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/631f7ae7b9dbb55ed3adce942952f93b48983a53/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fmod3.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/631f7ae7b9dbb55ed3adce942952f93b48983a53/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fmod3.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fmod3.rs?ref=631f7ae7b9dbb55ed3adce942952f93b48983a53", "patch": "@@ -1,25 +1,22 @@\n+// { dg-additional-options \"-w\" }\n mod A {\n-    pub mod B {  // { dg-warning \"unused name\" }\n-        pub mod C { // { dg-warning \"unused name\" }\n+    pub mod B {\n+        pub mod C {\n             pub struct Foo {\n                 pub f: i32,\n             }\n             impl Foo {\n-                pub fn new() -> Self {  // { dg-warning \"unused name\" }\n-                    Foo {\n-                        f: 23i32,\n-                    }\n+                pub fn new() -> Self {\n+                    Foo { f: 23i32 }\n                 }\n             }\n         }\n     }\n }\n \n-fn main() ->i32 {\n+fn main() -> i32 {\n     let a = A::B::C::Foo::new();\n-    let b = A::B::C::Foo {\n-        f: -23i32,\n-    };\n+    let b = A::B::C::Foo { f: -23i32 };\n \n     a.f - b.f\n }"}, {"sha": "7ef577acd09a36e24916b89d14238324d6dd5396", "filename": "gcc/testsuite/rust/compile/traits9.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/631f7ae7b9dbb55ed3adce942952f93b48983a53/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftraits9.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/631f7ae7b9dbb55ed3adce942952f93b48983a53/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftraits9.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftraits9.rs?ref=631f7ae7b9dbb55ed3adce942952f93b48983a53", "patch": "@@ -8,6 +8,6 @@ fn main() {\n     a = Foo(123);\n \n     let b: &dyn Bar = &a;\n-    // { dg-error \"bounds not satisfied for Foo .Bar. is not satisfied\" \"\" { target *-*-* } .-1 }\n+    // { dg-error \"bounds not satisfied for Foo .example::Bar. is not satisfied\" \"\" { target *-*-* } .-1 }\n     // { dg-error \"expected\" \"\" { target *-*-* } .-2 }\n }"}]}