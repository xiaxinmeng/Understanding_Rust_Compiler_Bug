{"sha": "6f1a6c5bb40d87b2ebfc6e1f98f96c5a72d9b080", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmYxYTZjNWJiNDBkODdiMmViZmM2ZTFmOThmOTZjNWE3MmQ5YjA4MA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2002-01-12T07:38:50Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2002-01-12T07:38:50Z"}, "message": "mmintrin.h: New file.\n\n        * config/i386/mmintrin.h: New file.\n        * config/i386/xmmintrin.h: New file.\n        * config.gcc (i?86-*-*): Add extra_headers.\n        * simplify-rtx.c (simplify_unary_operation): Handle saturating\n        truncation codes.\n        (simplify_binary_operation): Handle saturating arithmetic codes.\n        * config/i386/i386.c (ix86_expand_sse_comi): Return the full result,\n        not the lowpart subreg.\n        (ix86_expand_builtin): Return a TImode dummy register instead of 0\n        on error.\n        * config/i386/i386.md (mmx_clrdi): Override memory attribute.\n\n        * gcc.dg/i386-mmx-1.c, gcc.dg/i386-mmx-2.c: New.\n        * gcc.dg/i386-sse-1.c, gcc.dg/i386-sse-2.c, gcc.dg/i386-sse-1.c: New.\nCVs: ----------------------------------------------------------------------\n\nFrom-SVN: r48793", "tree": {"sha": "6e49502e0e9256ec42a5a6d46cd5051705961257", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6e49502e0e9256ec42a5a6d46cd5051705961257"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6f1a6c5bb40d87b2ebfc6e1f98f96c5a72d9b080", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f1a6c5bb40d87b2ebfc6e1f98f96c5a72d9b080", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f1a6c5bb40d87b2ebfc6e1f98f96c5a72d9b080", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f1a6c5bb40d87b2ebfc6e1f98f96c5a72d9b080/comments", "author": null, "committer": null, "parents": [{"sha": "cdb574d383b485bbee692ab4763fb1ac4be5e34d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cdb574d383b485bbee692ab4763fb1ac4be5e34d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cdb574d383b485bbee692ab4763fb1ac4be5e34d"}], "stats": {"total": 1726, "additions": 1722, "deletions": 4}, "files": [{"sha": "d5e4eb9c5f48c2f7c85b9287fdd62d7ef201f36b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f1a6c5bb40d87b2ebfc6e1f98f96c5a72d9b080/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f1a6c5bb40d87b2ebfc6e1f98f96c5a72d9b080/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6f1a6c5bb40d87b2ebfc6e1f98f96c5a72d9b080", "patch": "@@ -1,3 +1,17 @@\n+2002-01-11  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/i386/mmintrin.h: New file.\n+\t* config/i386/xmmintrin.h: New file.\n+\t* config.gcc (i?86-*-*): Add extra_headers.\n+\t* simplify-rtx.c (simplify_unary_operation): Handle saturating\n+\ttruncation codes.\n+\t(simplify_binary_operation): Handle saturating arithmetic codes.\n+\t* config/i386/i386.c (ix86_expand_sse_comi): Return the full result,\n+\tnot the lowpart subreg.\n+\t(ix86_expand_builtin): Return a TImode dummy register instead of 0\n+\ton error.\n+\t* config/i386/i386.md (mmx_clrdi): Override memory attribute.\n+\n 2002-01-12  Michael Hayes  <m.hayes@elec.canterbury.ac.nz>\n \n \t* conflict.c (conflict_graph_compute): Free regsets when finished."}, {"sha": "e87e7595ff61ba93278b872cb31b6ed7299605c5", "filename": "gcc/config.gcc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f1a6c5bb40d87b2ebfc6e1f98f96c5a72d9b080/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f1a6c5bb40d87b2ebfc6e1f98f96c5a72d9b080/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=6f1a6c5bb40d87b2ebfc6e1f98f96c5a72d9b080", "patch": "@@ -231,6 +231,7 @@ c*-convex-*)\n \t;;\n i[34567]86-*-*)\n \tcpu_type=i386\n+\textra_headers=\"mmintrin.h xmmintrin.h\"\n \t;;\n x86_64-*-*)\n \tcpu_type=i386"}, {"sha": "8eebf5f0e4150d460293a86a2e1f0a83a8d391ec", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f1a6c5bb40d87b2ebfc6e1f98f96c5a72d9b080/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f1a6c5bb40d87b2ebfc6e1f98f96c5a72d9b080/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=6f1a6c5bb40d87b2ebfc6e1f98f96c5a72d9b080", "patch": "@@ -11546,7 +11546,7 @@ ix86_expand_sse_comi (d, arglist, target)\n \t\t\t\t\t  gen_rtx_REG (CCmode, FLAGS_REG),\n \t\t\t\t\t  const0_rtx)));\n \n-  return target;\n+  return SUBREG_REG (target);\n }\n \n /* Expand an expression EXP that calls a built-in function,\n@@ -11612,7 +11612,7 @@ ix86_expand_builtin (exp, target, subtarget, mode, ignore)\n \t{\n \t  /* @@@ better error message */\n \t  error (\"selector must be an immediate\");\n-\t  return const0_rtx;\n+\t  return gen_reg_rtx (tmode);\n \t}\n       if (target == 0\n \t  || GET_MODE (target) != tmode\n@@ -11813,7 +11813,7 @@ ix86_expand_builtin (exp, target, subtarget, mode, ignore)\n \t{\n \t  /* @@@ better error message */\n \t  error (\"mask must be an immediate\");\n-\t  return const0_rtx;\n+\t  return gen_reg_rtx (tmode);\n \t}\n       if (target == 0\n \t  || GET_MODE (target) != tmode"}, {"sha": "4673c2b2191f02d5cad89384519833f584bc62ac", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f1a6c5bb40d87b2ebfc6e1f98f96c5a72d9b080/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f1a6c5bb40d87b2ebfc6e1f98f96c5a72d9b080/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=6f1a6c5bb40d87b2ebfc6e1f98f96c5a72d9b080", "patch": "@@ -18947,7 +18947,8 @@\n         (unspec:DI [(const_int 0)] 45))]\n   \"TARGET_MMX\"\n   \"pxor\\t{%0, %0|%0, %0}\"\n-  [(set_attr \"type\" \"mmx\")])\n+  [(set_attr \"type\" \"mmx\")\n+   (set_attr \"memory\" \"none\")])\n \n (define_insn \"mmx_anddi3\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=y\")"}, {"sha": "41dc4be6d6e78c7a67b5edf4bfeeea4483ecf60b", "filename": "gcc/config/i386/mmintrin.h", "status": "added", "additions": 542, "deletions": 0, "changes": 542, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f1a6c5bb40d87b2ebfc6e1f98f96c5a72d9b080/gcc%2Fconfig%2Fi386%2Fmmintrin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f1a6c5bb40d87b2ebfc6e1f98f96c5a72d9b080/gcc%2Fconfig%2Fi386%2Fmmintrin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fmmintrin.h?ref=6f1a6c5bb40d87b2ebfc6e1f98f96c5a72d9b080", "patch": "@@ -0,0 +1,542 @@\n+/* Copyright (C) 2002 Free Software Foundation, Inc.\n+\n+   This file is part of GNU CC.\n+\n+   GNU CC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 2, or (at your option)\n+   any later version.\n+\n+   GNU CC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GNU CC; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330,\n+   Boston, MA 02111-1307, USA.  */\n+\n+/* As a special exception, if you include this header file into source\n+   files compiled by GCC, this header file does not by itself cause\n+   the resulting executable to be covered by the GNU General Public\n+   License.  This exception does not however invalidate any other\n+   reasons why the executable file might be covered by the GNU General\n+   Public License.  */\n+\n+/* Implemented from the specification included in the Intel C++ Compiler\n+   User Guide and Reference, version 5.0.  */\n+\n+#ifndef _MMINTRIN_H_INCLUDED\n+#define _MMINTRIN_H_INCLUDED\n+\n+/* The data type intended for user use.  */\n+typedef unsigned long long __m64;\n+\n+/* Internal data types for implementing the intrinsics.  */\n+typedef int __v2si __attribute__ ((__mode__ (__V2SI__)));\n+typedef int __v4hi __attribute__ ((__mode__ (__V4HI__)));\n+typedef int __v8qi __attribute__ ((__mode__ (__V8QI__)));\n+\n+/* Empty the multimedia state.  */\n+static __inline void\n+_mm_empty (void)\n+{\n+  __builtin_ia32_emms ();\n+}\n+\n+/* Convert I to a __m64 object.  The integer is zero-extended to 64-bits.  */\n+static __inline __m64 \n+_mm_cvtsi32_si64 (int __i)\n+{\n+  return (unsigned int) __i;\n+}\n+\n+/* Convert the lower 32 bits of the __m64 object into an integer.  */\n+static __inline int\n+_mm_cvtsi64_si32 (__m64 __i)\n+{\n+  return __i;\n+}\n+\n+/* Pack the four 16-bit values from M1 into the lower four 8-bit values of\n+   the result, and the four 16-bit values from M2 into the upper four 8-bit\n+   values of the result, all with signed saturation.  */\n+static __inline __m64\n+_mm_packs_pi16 (__m64 __m1, __m64 __m2)\n+{\n+  return (__m64) __builtin_ia32_packsswb ((__v4hi)__m1, (__v4hi)__m2);\n+}\n+\n+/* Pack the two 32-bit values from M1 in to the lower two 16-bit values of\n+   the result, and the two 32-bit values from M2 into the upper two 16-bit\n+   values of the result, all with signed saturation.  */\n+static __inline __m64\n+_mm_packs_pi32 (__m64 __m1, __m64 __m2)\n+{\n+  return (__m64) __builtin_ia32_packssdw ((__v2si)__m1, (__v2si)__m2);\n+}\n+\n+/* Pack the four 16-bit values from M1 into the lower four 8-bit values of\n+   the result, and the four 16-bit values from M2 into the upper four 8-bit\n+   values of the result, all with unsigned saturation.  */\n+static __inline __m64\n+_mm_packs_pu16 (__m64 __m1, __m64 __m2)\n+{\n+  return (__m64) __builtin_ia32_packuswb ((__v4hi)__m1, (__v4hi)__m2);\n+}\n+\n+/* Interleave the four 8-bit values from the high half of M1 with the four\n+   8-bit values from the high half of M2.  */\n+static __inline __m64\n+_mm_unpackhi_pi8 (__m64 __m1, __m64 __m2)\n+{\n+  return (__m64) __builtin_ia32_punpckhbw ((__v8qi)__m1, (__v8qi)__m2);\n+}\n+\n+/* Interleave the two 16-bit values from the high half of M1 with the two\n+   16-bit values from the high half of M2.  */\n+static __inline __m64\n+_mm_unpackhi_pi16 (__m64 __m1, __m64 __m2)\n+{\n+  return (__m64) __builtin_ia32_punpckhwd ((__v4hi)__m1, (__v4hi)__m2);\n+}\n+\n+/* Interleave the 32-bit value from the high half of M1 with the 32-bit\n+   value from the high half of M2.  */\n+static __inline __m64\n+_mm_unpackhi_pi32 (__m64 __m1, __m64 __m2)\n+{\n+  return (__m64) __builtin_ia32_punpckhdq ((__v2si)__m1, (__v2si)__m2);\n+}\n+\n+/* Interleave the four 8-bit values from the low half of M1 with the four\n+   8-bit values from the low half of M2.  */\n+static __inline __m64\n+_mm_unpacklo_pi8 (__m64 __m1, __m64 __m2)\n+{\n+  return (__m64) __builtin_ia32_punpcklbw ((__v8qi)__m1, (__v8qi)__m2);\n+}\n+\n+/* Interleave the two 16-bit values from the low half of M1 with the two\n+   16-bit values from the low half of M2.  */\n+static __inline __m64\n+_mm_unpacklo_pi16 (__m64 __m1, __m64 __m2)\n+{\n+  return (__m64) __builtin_ia32_punpcklwd ((__v4hi)__m1, (__v4hi)__m2);\n+}\n+\n+/* Interleave the 32-bit value from the low half of M1 with the 32-bit\n+   value from the low half of M2.  */\n+static __inline __m64\n+_mm_unpacklo_pi32 (__m64 __m1, __m64 __m2)\n+{\n+  return (__m64) __builtin_ia32_punpckldq ((__v2si)__m1, (__v2si)__m2);\n+}\n+\n+/* Add the 8-bit values in M1 to the 8-bit values in M2.  */\n+static __inline __m64\n+_mm_add_pi8 (__m64 __m1, __m64 __m2)\n+{\n+  return (__m64) __builtin_ia32_paddb ((__v8qi)__m1, (__v8qi)__m2);\n+}\n+\n+/* Add the 16-bit values in M1 to the 16-bit values in M2.  */\n+static __inline __m64\n+_mm_add_pi16 (__m64 __m1, __m64 __m2)\n+{\n+  return (__m64) __builtin_ia32_paddw ((__v4hi)__m1, (__v4hi)__m2);\n+}\n+\n+/* Add the 32-bit values in M1 to the 32-bit values in M2.  */\n+static __inline __m64\n+_mm_add_pi32 (__m64 __m1, __m64 __m2)\n+{\n+  return (__m64) __builtin_ia32_paddd ((__v2si)__m1, (__v2si)__m2);\n+}\n+\n+/* Add the 8-bit values in M1 to the 8-bit values in M2 using signed\n+   saturated arithmetic.  */\n+static __inline __m64\n+_mm_adds_pi8 (__m64 __m1, __m64 __m2)\n+{\n+  return (__m64) __builtin_ia32_paddsb ((__v8qi)__m1, (__v8qi)__m2);\n+}\n+\n+/* Add the 16-bit values in M1 to the 16-bit values in M2 using signed\n+   saturated arithmetic.  */\n+static __inline __m64\n+_mm_adds_pi16 (__m64 __m1, __m64 __m2)\n+{\n+  return (__m64) __builtin_ia32_paddsw ((__v4hi)__m1, (__v4hi)__m2);\n+}\n+\n+/* Add the 8-bit values in M1 to the 8-bit values in M2 using unsigned\n+   saturated arithmetic.  */\n+static __inline __m64\n+_mm_adds_pu8 (__m64 __m1, __m64 __m2)\n+{\n+  return (__m64) __builtin_ia32_paddusb ((__v8qi)__m1, (__v8qi)__m2);\n+}\n+\n+/* Add the 16-bit values in M1 to the 16-bit values in M2 using unsigned\n+   saturated arithmetic.  */\n+static __inline __m64\n+_mm_adds_pu16 (__m64 __m1, __m64 __m2)\n+{\n+  return (__m64) __builtin_ia32_paddusw ((__v4hi)__m1, (__v4hi)__m2);\n+}\n+\n+/* Subtract the 8-bit values in M2 from the 8-bit values in M1.  */\n+static __inline __m64\n+_mm_sub_pi8 (__m64 __m1, __m64 __m2)\n+{\n+  return (__m64) __builtin_ia32_psubb ((__v8qi)__m1, (__v8qi)__m2);\n+}\n+\n+/* Subtract the 16-bit values in M2 from the 16-bit values in M1.  */\n+static __inline __m64\n+_mm_sub_pi16 (__m64 __m1, __m64 __m2)\n+{\n+  return (__m64) __builtin_ia32_psubw ((__v4hi)__m1, (__v4hi)__m2);\n+}\n+\n+/* Subtract the 32-bit values in M2 from the 32-bit values in M1.  */\n+static __inline __m64\n+_mm_sub_pi32 (__m64 __m1, __m64 __m2)\n+{\n+  return (__m64) __builtin_ia32_psubd ((__v2si)__m1, (__v2si)__m2);\n+}\n+\n+/* Subtract the 8-bit values in M2 from the 8-bit values in M1 using signed\n+   saturating arithmetic.  */\n+static __inline __m64\n+_mm_subs_pi8 (__m64 __m1, __m64 __m2)\n+{\n+  return (__m64) __builtin_ia32_psubsb ((__v8qi)__m1, (__v8qi)__m2);\n+}\n+\n+/* Subtract the 16-bit values in M2 from the 16-bit values in M1 using\n+   signed saturating arithmetic.  */\n+static __inline __m64\n+_mm_subs_pi16 (__m64 __m1, __m64 __m2)\n+{\n+  return (__m64) __builtin_ia32_psubsw ((__v4hi)__m1, (__v4hi)__m2);\n+}\n+\n+/* Subtract the 8-bit values in M2 from the 8-bit values in M1 using\n+   unsigned saturating arithmetic.  */\n+static __inline __m64\n+_mm_subs_pu8 (__m64 __m1, __m64 __m2)\n+{\n+  return (__m64) __builtin_ia32_psubusb ((__v8qi)__m1, (__v8qi)__m2);\n+}\n+\n+/* Subtract the 16-bit values in M2 from the 16-bit values in M1 using\n+   unsigned saturating arithmetic.  */\n+static __inline __m64\n+_mm_subs_pu16 (__m64 __m1, __m64 __m2)\n+{\n+  return (__m64) __builtin_ia32_psubusw ((__v4hi)__m1, (__v4hi)__m2);\n+}\n+\n+/* Multiply four 16-bit values in M1 by four 16-bit values in M2 producing\n+   four 32-bit intermediate results, which are then summed by pairs to\n+   produce two 32-bit results.  */\n+static __inline __m64\n+_mm_madd_pi16 (__m64 __m1, __m64 __m2)\n+{\n+  return (__m64) __builtin_ia32_pmaddwd ((__v4hi)__m1, (__v4hi)__m2);\n+}\n+\n+/* Multiply four signed 16-bit values in M1 by four signed 16-bit values in\n+   M2 and produce the high 16 bits of the 32-bit results.  */\n+static __inline __m64\n+_mm_mulhi_pi16 (__m64 __m1, __m64 __m2)\n+{\n+  return (__m64) __builtin_ia32_pmulhw ((__v4hi)__m1, (__v4hi)__m2);\n+}\n+\n+/* Multiply four 16-bit values in M1 by four 16-bit values in M2 and produce\n+   the low 16 bits of the results.  */\n+static __inline __m64\n+_mm_mullo_pi16 (__m64 __m1, __m64 __m2)\n+{\n+  return (__m64) __builtin_ia32_pmullw ((__v4hi)__m1, (__v4hi)__m2);\n+}\n+\n+/* Shift four 16-bit values in M left by COUNT.  */\n+static __inline __m64\n+_mm_sll_pi16 (__m64 __m, __m64 __count)\n+{\n+  return (__m64) __builtin_ia32_psllw ((__v4hi)__m, __count);\n+}\n+\n+static __inline __m64\n+_mm_slli_pi16 (__m64 __m, int __count)\n+{\n+  return (__m64) __builtin_ia32_psllw ((__v4hi)__m, __count);\n+}\n+\n+/* Shift two 32-bit values in M left by COUNT.  */\n+static __inline __m64\n+_mm_sll_pi32 (__m64 __m, __m64 __count)\n+{\n+  return (__m64) __builtin_ia32_pslld ((__v2si)__m, __count);\n+}\n+\n+static __inline __m64\n+_mm_slli_pi32 (__m64 __m, int __count)\n+{\n+  return (__m64) __builtin_ia32_pslld ((__v2si)__m, __count);\n+}\n+\n+/* Shift the 64-bit value in M left by COUNT.  */\n+static __inline __m64\n+_mm_sll_pi64 (__m64 __m, __m64 __count)\n+{\n+  return (__m64) __builtin_ia32_psllq (__m, __count);\n+}\n+\n+static __inline __m64\n+_mm_slli_pi64 (__m64 __m, int __count)\n+{\n+  return (__m64) __builtin_ia32_psllq (__m, __count);\n+}\n+\n+/* Shift four 16-bit values in M right by COUNT; shift in the sign bit.  */\n+static __inline __m64\n+_mm_sra_pi16 (__m64 __m, __m64 __count)\n+{\n+  return (__m64) __builtin_ia32_psraw ((__v4hi)__m, __count);\n+}\n+\n+static __inline __m64\n+_mm_srai_pi16 (__m64 __m, int __count)\n+{\n+  return (__m64) __builtin_ia32_psraw ((__v4hi)__m, __count);\n+}\n+\n+/* Shift two 32-bit values in M right by COUNT; shift in the sign bit.  */\n+static __inline __m64\n+_mm_sra_pi32 (__m64 __m, __m64 __count)\n+{\n+  return (__m64) __builtin_ia32_psrad ((__v2si)__m, __count);\n+}\n+\n+static __inline __m64\n+_mm_srai_pi32 (__m64 __m, int __count)\n+{\n+  return (__m64) __builtin_ia32_psrad ((__v2si)__m, __count);\n+}\n+\n+/* Shift four 16-bit values in M right by COUNT; shift in zeros.  */\n+static __inline __m64\n+_mm_srl_pi16 (__m64 __m, __m64 __count)\n+{\n+  return (__m64) __builtin_ia32_psrlw ((__v4hi)__m, __count);\n+}\n+\n+static __inline __m64\n+_mm_srli_pi16 (__m64 __m, int __count)\n+{\n+  return (__m64) __builtin_ia32_psrlw ((__v4hi)__m, __count);\n+}\n+\n+/* Shift two 32-bit values in M right by COUNT; shift in zeros.  */\n+static __inline __m64\n+_mm_srl_pi32 (__m64 __m, __m64 __count)\n+{\n+  return (__m64) __builtin_ia32_psrld ((__v2si)__m, __count);\n+}\n+\n+static __inline __m64\n+_mm_srli_pi32 (__m64 __m, int __count)\n+{\n+  return (__m64) __builtin_ia32_psrld ((__v2si)__m, __count);\n+}\n+\n+/* Shift the 64-bit value in M left by COUNT; shift in zeros.  */\n+static __inline __m64\n+_mm_srl_pi64 (__m64 __m, __m64 __count)\n+{\n+  return (__m64) __builtin_ia32_psrlq (__m, __count);\n+}\n+\n+static __inline __m64\n+_mm_srli_pi64 (__m64 __m, int __count)\n+{\n+  return (__m64) __builtin_ia32_psrlq (__m, __count);\n+}\n+\n+/* Bit-wise AND the 64-bit values in M1 and M2.  */\n+static __inline __m64\n+_mm_and_si64 (__m64 __m1, __m64 __m2)\n+{\n+  return __builtin_ia32_pand (__m1, __m2);\n+}\n+\n+/* Bit-wise complement the 64-bit value in M1 and bit-wise AND it with the\n+   64-bit value in M2.  */\n+static __inline __m64\n+_mm_andnot_si64 (__m64 __m1, __m64 __m2)\n+{\n+  return __builtin_ia32_pandn (__m1, __m2);\n+}\n+\n+/* Bit-wise inclusive OR the 64-bit values in M1 and M2.  */\n+static __inline __m64\n+_mm_or_si64 (__m64 __m1, __m64 __m2)\n+{\n+  return __builtin_ia32_por (__m1, __m2);\n+}\n+\n+/* Bit-wise exclusive OR the 64-bit values in M1 and M2.  */\n+static __inline __m64\n+_mm_xor_si64 (__m64 __m1, __m64 __m2)\n+{\n+  return __builtin_ia32_pxor (__m1, __m2);\n+}\n+\n+/* Compare eight 8-bit values.  The result of the comparison is 0xFF if the\n+   test is true and zero if false.  */\n+static __inline __m64\n+_mm_cmpeq_pi8 (__m64 __m1, __m64 __m2)\n+{\n+  return (__m64) __builtin_ia32_pcmpeqb ((__v8qi)__m1, (__v8qi)__m2);\n+}\n+\n+static __inline __m64\n+_mm_cmpgt_pi8 (__m64 __m1, __m64 __m2)\n+{\n+  return (__m64) __builtin_ia32_pcmpgtb ((__v8qi)__m1, (__v8qi)__m2);\n+}\n+\n+/* Compare four 16-bit values.  The result of the comparison is 0xFFFF if\n+   the test is true and zero if false.  */\n+static __inline __m64\n+_mm_cmpeq_pi16 (__m64 __m1, __m64 __m2)\n+{\n+  return (__m64) __builtin_ia32_pcmpeqw ((__v4hi)__m1, (__v4hi)__m2);\n+}\n+\n+static __inline __m64\n+_mm_cmpgt_pi16 (__m64 __m1, __m64 __m2)\n+{\n+  return (__m64) __builtin_ia32_pcmpgtw ((__v4hi)__m1, (__v4hi)__m2);\n+}\n+\n+/* Compare two 32-bit values.  The result of the comparison is 0xFFFFFFFF if\n+   the test is true and zero if false.  */\n+static __inline __m64\n+_mm_cmpeq_pi32 (__m64 __m1, __m64 __m2)\n+{\n+  return (__m64) __builtin_ia32_pcmpeqd ((__v2si)__m1, (__v2si)__m2);\n+}\n+\n+static __inline __m64\n+_mm_cmpgt_pi32 (__m64 __m1, __m64 __m2)\n+{\n+  return (__m64) __builtin_ia32_pcmpgtd ((__v2si)__m1, (__v2si)__m2);\n+}\n+\n+/* Creates a 64-bit zero.  */\n+static __inline __m64\n+_mm_setzero_si64 (void)\n+{\n+  return __builtin_ia32_mmx_zero ();\n+}\n+\n+/* Creates a vector of two 32-bit values; I0 is least significant.  */\n+static __inline __m64\n+_mm_set_pi32 (int __i1, int __i0)\n+{\n+  union {\n+    __m64 __q;\n+    struct {\n+      unsigned int __i0;\n+      unsigned int __i1;\n+    } __s;\n+  } __u;\n+\n+  __u.__s.__i0 = __i0;\n+  __u.__s.__i1 = __i1;\n+\n+  return __u.__q;\n+}\n+\n+/* Creates a vector of four 16-bit values; W0 is least significant.  */\n+static __inline __m64\n+_mm_set_pi16 (short __w3, short __w2, short __w1, short __w0)\n+{\n+  unsigned int __i1 = (unsigned short)__w3 << 16 | (unsigned short)__w2;\n+  unsigned int __i0 = (unsigned short)__w1 << 16 | (unsigned short)__w0;\n+  return _mm_set_pi32 (__i1, __i0);\n+\t\t       \n+}\n+\n+/* Creates a vector of eight 8-bit values; B0 is least significant.  */\n+static __inline __m64\n+_mm_set_pi8 (char __b7, char __b6, char __b5, char __b4,\n+\t     char __b3, char __b2, char __b1, char __b0)\n+{\n+  unsigned int __i1, __i0;\n+\n+  __i1 = (unsigned char)__b7;\n+  __i1 = __i1 << 8 | (unsigned char)__b6;\n+  __i1 = __i1 << 8 | (unsigned char)__b5;\n+  __i1 = __i1 << 8 | (unsigned char)__b4;\n+\n+  __i0 = (unsigned char)__b3;\n+  __i0 = __i0 << 8 | (unsigned char)__b2;\n+  __i0 = __i0 << 8 | (unsigned char)__b1;\n+  __i0 = __i0 << 8 | (unsigned char)__b0;\n+\n+  return _mm_set_pi32 (__i1, __i0);\n+}\n+\n+/* Similar, but with the arguments in reverse order.  */\n+static __inline __m64\n+_mm_setr_pi32 (int __i0, int __i1)\n+{\n+  return _mm_set_pi32 (__i1, __i0);\n+}\n+\n+static __inline __m64\n+_mm_setr_pi16 (short __w0, short __w1, short __w2, short __w3)\n+{\n+  return _mm_set_pi16 (__w3, __w2, __w1, __w0);\n+}\n+\n+static __inline __m64\n+_mm_setr_pi8 (char __b0, char __b1, char __b2, char __b3,\n+\t      char __b4, char __b5, char __b6, char __b7)\n+{\n+  return _mm_set_pi8 (__b7, __b6, __b5, __b4, __b3, __b2, __b1, __b0);\n+}\n+\n+/* Creates a vector of two 32-bit values, both elements containing I.  */\n+static __inline __m64\n+_mm_set1_pi32 (int __i)\n+{\n+  return _mm_set_pi32 (__i, __i);\n+}\n+\n+/* Creates a vector of four 16-bit values, all elements containing W.  */\n+static __inline __m64\n+_mm_set1_pi16 (short __w)\n+{\n+  unsigned int __i = (unsigned short)__w << 16 | (unsigned short)__w;\n+  return _mm_set1_pi32 (__i);\n+}\n+\n+/* Creates a vector of four 16-bit values, all elements containing B.  */\n+static __inline __m64\n+_mm_set1_pi8 (char __b)\n+{\n+  unsigned int __w = (unsigned char)__b << 8 | (unsigned char)__b;\n+  unsigned int __i = __w << 16 | __w;\n+  return _mm_set1_pi32 (__i);\n+}\n+\n+#endif /* _MMINTRIN_H_INCLUDED */"}, {"sha": "c515064900b24c636d0566303854bd7173a52d64", "filename": "gcc/config/i386/xmmintrin.h", "status": "added", "additions": 1061, "deletions": 0, "changes": 1061, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f1a6c5bb40d87b2ebfc6e1f98f96c5a72d9b080/gcc%2Fconfig%2Fi386%2Fxmmintrin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f1a6c5bb40d87b2ebfc6e1f98f96c5a72d9b080/gcc%2Fconfig%2Fi386%2Fxmmintrin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fxmmintrin.h?ref=6f1a6c5bb40d87b2ebfc6e1f98f96c5a72d9b080", "patch": "@@ -0,0 +1,1061 @@\n+/* Copyright (C) 2002 Free Software Foundation, Inc.\n+\n+   This file is part of GNU CC.\n+\n+   GNU CC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 2, or (at your option)\n+   any later version.\n+\n+   GNU CC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GNU CC; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330,\n+   Boston, MA 02111-1307, USA.  */\n+\n+/* As a special exception, if you include this header file into source\n+   files compiled by GCC, this header file does not by itself cause\n+   the resulting executable to be covered by the GNU General Public\n+   License.  This exception does not however invalidate any other\n+   reasons why the executable file might be covered by the GNU General\n+   Public License.  */\n+\n+/* Implemented from the specification included in the Intel C++ Compiler\n+   User Guide and Reference, version 5.0.  */\n+\n+#ifndef _XMMINTRIN_H_INCLUDED\n+#define _XMMINTRIN_H_INCLUDED\n+\n+/* We need type definitions from the MMX header file.  */\n+#include <mmintrin.h>\n+\n+/* The data type indended for user use.  */\n+typedef int __m128 __attribute__ ((mode (TI)));\n+\n+/* Internal data types for implementing the instrinsics.  */\n+typedef int __v4sf __attribute__ ((mode (V4SF)));\n+typedef int __v4si __attribute__ ((mode (V4SI)));\n+\n+/* Create a selector for use with the SHUFPS instruction.  */\n+#define _MM_SHUFFLE(fp3,fp2,fp1,fp0) \\\n+ (((fp3) << 6) | ((fp2) << 4) | ((fp1) << 2) | (fp0))\n+\n+/* Constants for use with _mm_prefetch.  */\n+enum _mm_hint\n+{\n+  _MM_HINT_T0 = 3,\n+  _MM_HINT_T1 = 2,\n+  _MM_HINT_T2 = 1,\n+  _MM_HINT_NTA = 0\n+};\n+\n+/* Bits in the MXCSR.  */\n+#define _MM_EXCEPT_MASK       0x003f\n+#define _MM_EXCEPT_INVALID    0x0001\n+#define _MM_EXCEPT_DENORM     0x0002\n+#define _MM_EXCEPT_DIV_ZERO   0x0004\n+#define _MM_EXCEPT_OVERFLOW   0x0008\n+#define _MM_EXCEPT_UNDERFLOW  0x0010\n+#define _MM_EXCEPT_INEXACT    0x0020\n+\n+#define _MM_MASK_MASK         0x1f80\n+#define _MM_MASK_INVALID      0x0080\n+#define _MM_MASK_DENORM       0x0100\n+#define _MM_MASK_DIV_ZERO     0x0200\n+#define _MM_MASK_OVERFLOW     0x0400\n+#define _MM_MASK_UNDERFLOW    0x0800\n+#define _MM_MASK_INEXACT      0x1000\n+\n+#define _MM_ROUND_MASK        0x6000\n+#define _MM_ROUND_NEAREST     0x0000\n+#define _MM_ROUND_DOWN        0x2000\n+#define _MM_ROUND_UP          0x4000\n+#define _MM_ROUND_TOWARD_ZERO 0x6000\n+\n+#define _MM_FLUSH_ZERO_MASK   0x8000\n+#define _MM_FLUSH_ZERO_ON     0x8000\n+#define _MM_FLUSH_ZERO_OFF    0x0000\n+\n+/* Perform the respective operation on the lower SPFP (single-precision\n+   floating-point) values of A and B; the upper three SPFP values are\n+   passed through from A.  */\n+\n+static __inline __m128\n+_mm_add_ss (__m128 __A, __m128 __B)\n+{\n+  return (__m128) __builtin_ia32_addss ((__v4sf)__A, (__v4sf)__B);\n+}\n+\n+static __inline __m128\n+_mm_sub_ss (__m128 __A, __m128 __B)\n+{\n+  return (__m128) __builtin_ia32_subss ((__v4sf)__A, (__v4sf)__B);\n+}\n+\n+static __inline __m128\n+_mm_mul_ss (__m128 __A, __m128 __B)\n+{\n+  return (__m128) __builtin_ia32_mulss ((__v4sf)__A, (__v4sf)__B);\n+}\n+\n+static __inline __m128\n+_mm_div_ss (__m128 __A, __m128 __B)\n+{\n+  return (__m128) __builtin_ia32_divss ((__v4sf)__A, (__v4sf)__B);\n+}\n+\n+static __inline __m128\n+_mm_sqrt_ss (__m128 __A)\n+{\n+  return (__m128) __builtin_ia32_sqrtss ((__v4sf)__A);\n+}\n+\n+static __inline __m128\n+_mm_rcp_ss (__m128 __A)\n+{\n+  return (__m128) __builtin_ia32_rcpss ((__v4sf)__A);\n+}\n+\n+static __inline __m128\n+_mm_rsqrt_ss (__m128 __A)\n+{\n+  return (__m128) __builtin_ia32_rsqrtss ((__v4sf)__A);\n+}\n+\n+static __inline __m128\n+_mm_min_ss (__m128 __A, __m128 __B)\n+{\n+  return (__m128) __builtin_ia32_minss ((__v4sf)__A, (__v4sf)__B);\n+}\n+\n+static __inline __m128\n+_mm_max_ss (__m128 __A, __m128 __B)\n+{\n+  return (__m128) __builtin_ia32_maxss ((__v4sf)__A, (__v4sf)__B);\n+}\n+\n+/* Perform the respective operation on the four SPFP values in A and B.  */\n+\n+static __inline __m128\n+_mm_add_ps (__m128 __A, __m128 __B)\n+{\n+  return (__m128) __builtin_ia32_addps ((__v4sf)__A, (__v4sf)__B);\n+}\n+\n+static __inline __m128\n+_mm_sub_ps (__m128 __A, __m128 __B)\n+{\n+  return (__m128) __builtin_ia32_subps ((__v4sf)__A, (__v4sf)__B);\n+}\n+\n+static __inline __m128\n+_mm_mul_ps (__m128 __A, __m128 __B)\n+{\n+  return (__m128) __builtin_ia32_mulps ((__v4sf)__A, (__v4sf)__B);\n+}\n+\n+static __inline __m128\n+_mm_div_ps (__m128 __A, __m128 __B)\n+{\n+  return (__m128) __builtin_ia32_divps ((__v4sf)__A, (__v4sf)__B);\n+}\n+\n+static __inline __m128\n+_mm_sqrt_ps (__m128 __A)\n+{\n+  return (__m128) __builtin_ia32_sqrtps ((__v4sf)__A);\n+}\n+\n+static __inline __m128\n+_mm_rcp_ps (__m128 __A)\n+{\n+  return (__m128) __builtin_ia32_rcpps ((__v4sf)__A);\n+}\n+\n+static __inline __m128\n+_mm_rsqrt_ps (__m128 __A)\n+{\n+  return (__m128) __builtin_ia32_rsqrtps ((__v4sf)__A);\n+}\n+\n+static __inline __m128\n+_mm_min_ps (__m128 __A, __m128 __B)\n+{\n+  return (__m128) __builtin_ia32_minps ((__v4sf)__A, (__v4sf)__B);\n+}\n+\n+static __inline __m128\n+_mm_max_ps (__m128 __A, __m128 __B)\n+{\n+  return (__m128) __builtin_ia32_maxps ((__v4sf)__A, (__v4sf)__B);\n+}\n+\n+/* Perform logical bit-wise operations on 128-bit values.  */\n+\n+static __inline __m128\n+_mm_and_ps (__m128 __A, __m128 __B)\n+{\n+  return __builtin_ia32_andps (__A, __B);\n+}\n+\n+static __inline __m128\n+_mm_andnot_ps (__m128 __A, __m128 __B)\n+{\n+  return __builtin_ia32_andnps (__A, __B);\n+}\n+\n+static __inline __m128\n+_mm_or_ps (__m128 __A, __m128 __B)\n+{\n+  return __builtin_ia32_orps (__A, __B);\n+}\n+\n+static __inline __m128\n+_mm_xor_ps (__m128 __A, __m128 __B)\n+{\n+  return __builtin_ia32_xorps (__A, __B);\n+}\n+\n+/* Perform a comparison on the lower SPFP values of A and B.  If the\n+   comparison is true, place a mask of all ones in the result, otherwise a\n+   mask of zeros.  The upper three SPFP values are passed through from A.  */\n+\n+static __inline __m128\n+_mm_cmpeq_ss (__m128 __A, __m128 __B)\n+{\n+  return (__m128) __builtin_ia32_cmpeqss ((__v4sf)__A, (__v4sf)__B);\n+}\n+\n+static __inline __m128\n+_mm_cmplt_ss (__m128 __A, __m128 __B)\n+{\n+  return (__m128) __builtin_ia32_cmpltss ((__v4sf)__A, (__v4sf)__B);\n+}\n+\n+static __inline __m128\n+_mm_cmple_ss (__m128 __A, __m128 __B)\n+{\n+  return (__m128) __builtin_ia32_cmpless ((__v4sf)__A, (__v4sf)__B);\n+}\n+\n+static __inline __m128\n+_mm_cmpgt_ss (__m128 __A, __m128 __B)\n+{\n+  return (__m128) __builtin_ia32_cmpgtss ((__v4sf)__A, (__v4sf)__B);\n+}\n+\n+static __inline __m128\n+_mm_cmpge_ss (__m128 __A, __m128 __B)\n+{\n+  return (__m128) __builtin_ia32_cmpgess ((__v4sf)__A, (__v4sf)__B);\n+}\n+\n+static __inline __m128\n+_mm_cmpneq_ss (__m128 __A, __m128 __B)\n+{\n+  return (__m128) __builtin_ia32_cmpneqss ((__v4sf)__A, (__v4sf)__B);\n+}\n+\n+static __inline __m128\n+_mm_cmpnlt_ss (__m128 __A, __m128 __B)\n+{\n+  return (__m128) __builtin_ia32_cmpnltss ((__v4sf)__A, (__v4sf)__B);\n+}\n+\n+static __inline __m128\n+_mm_cmpnle_ss (__m128 __A, __m128 __B)\n+{\n+  return (__m128) __builtin_ia32_cmpnless ((__v4sf)__A, (__v4sf)__B);\n+}\n+\n+static __inline __m128\n+_mm_cmpngt_ss (__m128 __A, __m128 __B)\n+{\n+  return (__m128) __builtin_ia32_cmpngtss ((__v4sf)__A, (__v4sf)__B);\n+}\n+\n+static __inline __m128\n+_mm_cmpnge_ss (__m128 __A, __m128 __B)\n+{\n+  return (__m128) __builtin_ia32_cmpngess ((__v4sf)__A, (__v4sf)__B);\n+}\n+\n+static __inline __m128\n+_mm_cmpord_ss (__m128 __A, __m128 __B)\n+{\n+  return (__m128) __builtin_ia32_cmpordss ((__v4sf)__A, (__v4sf)__B);\n+}\n+\n+static __inline __m128\n+_mm_cmpunord_ss (__m128 __A, __m128 __B)\n+{\n+  return (__m128) __builtin_ia32_cmpunordss ((__v4sf)__A, (__v4sf)__B);\n+}\n+\n+/* Perform a comparison on the four SPFP values of A and B.  For each\n+   element, if the comparison is true, place a mask of all ones in the\n+   result, otherwise a mask of zeros.  */\n+\n+static __inline __m128\n+_mm_cmpeq_ps (__m128 __A, __m128 __B)\n+{\n+  return (__m128) __builtin_ia32_cmpeqps ((__v4sf)__A, (__v4sf)__B);\n+}\n+\n+static __inline __m128\n+_mm_cmplt_ps (__m128 __A, __m128 __B)\n+{\n+  return (__m128) __builtin_ia32_cmpltps ((__v4sf)__A, (__v4sf)__B);\n+}\n+\n+static __inline __m128\n+_mm_cmple_ps (__m128 __A, __m128 __B)\n+{\n+  return (__m128) __builtin_ia32_cmpleps ((__v4sf)__A, (__v4sf)__B);\n+}\n+\n+static __inline __m128\n+_mm_cmpgt_ps (__m128 __A, __m128 __B)\n+{\n+  return (__m128) __builtin_ia32_cmpgtps ((__v4sf)__A, (__v4sf)__B);\n+}\n+\n+static __inline __m128\n+_mm_cmpge_ps (__m128 __A, __m128 __B)\n+{\n+  return (__m128) __builtin_ia32_cmpgeps ((__v4sf)__A, (__v4sf)__B);\n+}\n+\n+static __inline __m128\n+_mm_cmpneq_ps (__m128 __A, __m128 __B)\n+{\n+  return (__m128) __builtin_ia32_cmpneqps ((__v4sf)__A, (__v4sf)__B);\n+}\n+\n+static __inline __m128\n+_mm_cmpnlt_ps (__m128 __A, __m128 __B)\n+{\n+  return (__m128) __builtin_ia32_cmpnltps ((__v4sf)__A, (__v4sf)__B);\n+}\n+\n+static __inline __m128\n+_mm_cmpnle_ps (__m128 __A, __m128 __B)\n+{\n+  return (__m128) __builtin_ia32_cmpnleps ((__v4sf)__A, (__v4sf)__B);\n+}\n+\n+static __inline __m128\n+_mm_cmpngt_ps (__m128 __A, __m128 __B)\n+{\n+  return (__m128) __builtin_ia32_cmpngtps ((__v4sf)__A, (__v4sf)__B);\n+}\n+\n+static __inline __m128\n+_mm_cmpnge_ps (__m128 __A, __m128 __B)\n+{\n+  return (__m128) __builtin_ia32_cmpngeps ((__v4sf)__A, (__v4sf)__B);\n+}\n+\n+static __inline __m128\n+_mm_cmpord_ps (__m128 __A, __m128 __B)\n+{\n+  return (__m128) __builtin_ia32_cmpordps ((__v4sf)__A, (__v4sf)__B);\n+}\n+\n+static __inline __m128\n+_mm_cmpunord_ps (__m128 __A, __m128 __B)\n+{\n+  return (__m128) __builtin_ia32_cmpunordps ((__v4sf)__A, (__v4sf)__B);\n+}\n+\n+/* Compare the lower SPFP values of A and B and return 1 if true\n+   and 0 if false.  */\n+\n+static __inline int\n+_mm_comieq_ss (__m128 __A, __m128 __B)\n+{\n+  return __builtin_ia32_comieq ((__v4sf)__A, (__v4sf)__B);\n+}\n+\n+static __inline int\n+_mm_comilt_ss (__m128 __A, __m128 __B)\n+{\n+  return __builtin_ia32_comilt ((__v4sf)__A, (__v4sf)__B);\n+}\n+\n+static __inline int\n+_mm_comile_ss (__m128 __A, __m128 __B)\n+{\n+  return __builtin_ia32_comile ((__v4sf)__A, (__v4sf)__B);\n+}\n+\n+static __inline int\n+_mm_comigt_ss (__m128 __A, __m128 __B)\n+{\n+  return __builtin_ia32_comigt ((__v4sf)__A, (__v4sf)__B);\n+}\n+\n+static __inline int\n+_mm_comige_ss (__m128 __A, __m128 __B)\n+{\n+  return __builtin_ia32_comige ((__v4sf)__A, (__v4sf)__B);\n+}\n+\n+static __inline int\n+_mm_comineq_ss (__m128 __A, __m128 __B)\n+{\n+  return __builtin_ia32_comineq ((__v4sf)__A, (__v4sf)__B);\n+}\n+\n+static __inline int\n+_mm_ucomieq_ss (__m128 __A, __m128 __B)\n+{\n+  return __builtin_ia32_ucomieq ((__v4sf)__A, (__v4sf)__B);\n+}\n+\n+static __inline int\n+_mm_ucomilt_ss (__m128 __A, __m128 __B)\n+{\n+  return __builtin_ia32_ucomilt ((__v4sf)__A, (__v4sf)__B);\n+}\n+\n+static __inline int\n+_mm_ucomile_ss (__m128 __A, __m128 __B)\n+{\n+  return __builtin_ia32_ucomile ((__v4sf)__A, (__v4sf)__B);\n+}\n+\n+static __inline int\n+_mm_ucomigt_ss (__m128 __A, __m128 __B)\n+{\n+  return __builtin_ia32_ucomigt ((__v4sf)__A, (__v4sf)__B);\n+}\n+\n+static __inline int\n+_mm_ucomige_ss (__m128 __A, __m128 __B)\n+{\n+  return __builtin_ia32_ucomige ((__v4sf)__A, (__v4sf)__B);\n+}\n+\n+static __inline int\n+_mm_ucomineq_ss (__m128 __A, __m128 __B)\n+{\n+  return __builtin_ia32_ucomineq ((__v4sf)__A, (__v4sf)__B);\n+}\n+\n+/* Convert the lower SPFP value to a 32-bit integer according to the current\n+   rounding mode.  */\n+static __inline int\n+_mm_cvtss_si32 (__m128 __A)\n+{\n+  return __builtin_ia32_cvtss2si ((__v4sf) __A);\n+}\n+\n+/* Convert the two lower SPFP values to 32-bit integers according to the\n+   current rounding mode.  Return the integers in packed form.  */\n+static __inline __m64\n+_mm_cvtps_pi32 (__m128 __A)\n+{\n+  return (__m64) __builtin_ia32_cvtps2pi ((__v4sf) __A);\n+}\n+\n+/* Truncate the lower SPFP value to a 32-bit integer.  */\n+static __inline int\n+_mm_cvttss_si32 (__m128 __A)\n+{\n+  return __builtin_ia32_cvttss2si ((__v4sf) __A);\n+}\n+\n+/* Truncate the two lower SPFP values to 32-bit integers.  Return the\n+   integers in packed form.  */\n+static __inline __m64\n+_mm_cvttps_pi32 (__m128 __A)\n+{\n+  return (__m64) __builtin_ia32_cvttps2pi ((__v4sf) __A);\n+}\n+\n+/* Convert B to a SPFP value and insert it as element zero in A.  */\n+static __inline __m128\n+_mm_cvtsi32_ss (__m128 __A, int __B)\n+{\n+  return (__m128) __builtin_ia32_cvtsi2ss ((__v4sf) __A, __B);\n+}\n+\n+/* Convert the two 32-bit values in B to SPFP form and insert them\n+   as the two lower elements in A.  */\n+static __inline __m128\n+_mm_cvtpi32_ps (__m128 __A, __m64 __B)\n+{\n+  return (__m128) __builtin_ia32_cvtpi2ps ((__v4sf) __A, (__v2si)__B);\n+}\n+\n+/* Convert the four signed 16-bit values in A to SPFP form.  */\n+static __inline __m128\n+_mm_cvtpi16_ps (__m64 __A)\n+{\n+  __v4hi __sign;\n+  __v2si __hisi, __losi;\n+  __v4sf __r;\n+\n+  /* This comparison against zero gives us a mask that can be used to\n+     fill in the missing sign bits in the unpack operations below, so\n+     that we get signed values after unpacking.  */\n+  __sign = (__v4hi) __builtin_ia32_mmx_zero ();\n+  __sign = __builtin_ia32_pcmpgtw (__sign, (__v4hi)__A);\n+\n+  /* Convert the four words to doublewords.  */\n+  __hisi = (__v2si) __builtin_ia32_punpckhwd ((__v4hi)__A, __sign);\n+  __losi = (__v2si) __builtin_ia32_punpcklwd ((__v4hi)__A, __sign);\n+\n+  /* Convert the doublewords to floating point two at a time.  */\n+  __r = (__v4sf) __builtin_ia32_setzerops ();\n+  __r = __builtin_ia32_cvtpi2ps (__r, __hisi);\n+  __r = __builtin_ia32_movlhps (__r, __r);\n+  __r = __builtin_ia32_cvtpi2ps (__r, __losi);\n+\n+  return (__m128) __r;\n+}\n+\n+/* Convert the four unsigned 16-bit values in A to SPFP form.  */\n+static __inline __m128\n+_mm_cvtpu16_ps (__m64 __A)\n+{\n+  __v4hi __zero = (__v4hi) __builtin_ia32_mmx_zero ();\n+  __v2si __hisi, __losi;\n+  __v4sf __r;\n+\n+  /* Convert the four words to doublewords.  */\n+  __hisi = (__v2si) __builtin_ia32_punpckhwd ((__v4hi)__A, __zero);\n+  __losi = (__v2si) __builtin_ia32_punpcklwd ((__v4hi)__A, __zero);\n+\n+  /* Convert the doublewords to floating point two at a time.  */\n+  __r = (__v4sf) __builtin_ia32_setzerops ();\n+  __r = __builtin_ia32_cvtpi2ps (__r, __hisi);\n+  __r = __builtin_ia32_movlhps (__r, __r);\n+  __r = __builtin_ia32_cvtpi2ps (__r, __losi);\n+\n+  return (__m128) __r;\n+}\n+\n+/* Convert the low four signed 8-bit values in A to SPFP form.  */\n+static __inline __m128\n+_mm_cvtpi8_ps (__m64 __A)\n+{\n+  __v8qi __sign;\n+\n+  /* This comparison against zero gives us a mask that can be used to\n+     fill in the missing sign bits in the unpack operations below, so\n+     that we get signed values after unpacking.  */\n+  __sign = (__v8qi) __builtin_ia32_mmx_zero ();\n+  __sign = __builtin_ia32_pcmpgtb (__sign, (__v8qi)__A);\n+\n+  /* Convert the four low bytes to words.  */\n+  __A = (__m64) __builtin_ia32_punpcklbw ((__v8qi)__A, __sign);\n+\n+  return _mm_cvtpi16_ps(__A);\n+}\n+\n+/* Convert the low four unsigned 8-bit values in A to SPFP form.  */\n+static __inline __m128\n+_mm_cvtpu8_ps(__m64 __A)\n+{\n+  __v8qi __zero = (__v8qi) __builtin_ia32_mmx_zero ();\n+  __A = (__m64) __builtin_ia32_punpcklbw ((__v8qi)__A, __zero);\n+  return _mm_cvtpu16_ps(__A);\n+}\n+\n+/* Convert the four signed 32-bit values in A and B to SPFP form.  */\n+static __inline __m128\n+_mm_cvtpi32x2_ps(__m64 __A, __m64 __B)\n+{\n+  __v4sf __zero = (__v4sf) __builtin_ia32_setzerops ();\n+  __v4sf __sfa = __builtin_ia32_cvtpi2ps (__zero, (__v2si)__A);\n+  __v4sf __sfb = __builtin_ia32_cvtpi2ps (__zero, (__v2si)__B);\n+  return (__m128) __builtin_ia32_movlhps (__sfa, __sfb);\n+}\n+\n+/* Convert the four SPFP values in A to four signed 16-bit integers.  */\n+static __inline __m64\n+_mm_cvtps_pi16(__m128 __A)\n+{\n+  __v4sf __hisf = (__v4sf)__A;\n+  __v4sf __losf = __builtin_ia32_movhlps (__hisf, __hisf);\n+  __v2si __hisi = __builtin_ia32_cvtps2pi (__hisf);\n+  __v2si __losi = __builtin_ia32_cvtps2pi (__losf);\n+  return (__m64) __builtin_ia32_packssdw (__losi, __hisi);\n+}\n+\n+/* Convert the four SPFP values in A to four signed 8-bit integers.  */\n+static __inline __m64\n+_mm_cvtps_pi8(__m128 __A)\n+{\n+  __v4hi __tmp = (__v4hi) _mm_cvtps_pi16 (__A);\n+  __v4hi __zero = (__v4hi) __builtin_ia32_mmx_zero ();\n+  return (__m64) __builtin_ia32_packsswb (__tmp, __zero);\n+}\n+\n+/* Selects four specific SPFP values from A and B based on MASK.  */\n+#if 0\n+static __inline __m128\n+_mm_shuffle_ps (__m128 __A, __m128 __B, int __mask)\n+{\n+  return (__m128) __builtin_ia32_shufps ((__v4sf)__A, (__v4sf)__B, __mask);\n+}\n+#else\n+#define _mm_shuffle_ps(A, B, MASK) \\\n+ ((__m128) __builtin_ia32_shufps ((__v4sf)(A), (__v4sf)(B), (MASK)))\n+#endif\n+\n+\n+/* Selects and interleaves the upper two SPFP values from A and B.  */\n+static __inline __m128\n+_mm_unpackhi_ps (__m128 __A, __m128 __B)\n+{\n+  return (__m128) __builtin_ia32_unpckhps ((__v4sf)__A, (__v4sf)__B);\n+}\n+\n+/* Selects and interleaves the lower two SPFP values from A and B.  */\n+static __inline __m128\n+_mm_unpacklo_ps (__m128 __A, __m128 __B)\n+{\n+  return (__m128) __builtin_ia32_unpcklps ((__v4sf)__A, (__v4sf)__B);\n+}\n+\n+/* Sets the upper two SPFP values with 64-bits of data loaded from P;\n+   the lower two values are passed through from A.  */\n+static __inline __m128\n+_mm_loadh_pi (__m128 __A, __m64 *__P)\n+{\n+  return (__m128) __builtin_ia32_loadhps ((__v4sf)__A, (__v2si *)__P);\n+}\n+\n+/* Stores the upper two SPFP values of A into P.  */\n+static __inline void\n+_mm_storeh_pi (__m64 *__P, __m128 __A)\n+{\n+  __builtin_ia32_storehps ((__v2si *)__P, (__v4sf)__A);\n+}\n+\n+/* Moves the upper two values of B into the lower two values of A.  */\n+static __inline __m128\n+_mm_movehl_ps (__m128 __A, __m128 __B)\n+{\n+  return (__m128) __builtin_ia32_movhlps ((__v4sf)__A, (__v4sf)__B);\n+}\n+\n+/* Moves the lower two values of B into the upper two values of A.  */\n+static __inline __m128\n+_mm_movelh_ps (__m128 __A, __m128 __B)\n+{\n+  return (__m128) __builtin_ia32_movlhps ((__v4sf)__A, (__v4sf)__B);\n+}\n+\n+/* Sets the lower two SPFP values with 64-bits of data loaded from P;\n+   the upper two values are passed through from A.  */\n+static __inline __m128\n+_mm_loadl_pi (__m128 __A, __m64 *__P)\n+{\n+  return (__m128) __builtin_ia32_loadlps ((__v4sf)__A, (__v2si *)__P);\n+}\n+\n+/* Stores the lower two SPFP values of A into P.  */\n+static __inline void\n+_mm_storel_pi (__m64 *__P, __m128 __A)\n+{\n+  __builtin_ia32_storelps ((__v2si *)__P, (__v4sf)__A);\n+}\n+\n+/* Creates a 4-bit mask from the most significant bits of the SPFP values.  */\n+static __inline int\n+_mm_movemask_ps (__m128 __A)\n+{\n+  return __builtin_ia32_movmskps ((__v4sf)__A);\n+}\n+\n+/* Return the contents of the control register.  */\n+static __inline unsigned int\n+_mm_getcsr (void)\n+{\n+  return __builtin_ia32_getmxcsr ();\n+}\n+\n+/* Read exception bits from the control register.  */\n+static __inline unsigned int\n+_MM_GET_EXCEPTION_STATE (void)\n+{\n+  return _mm_getcsr() & _MM_EXCEPT_MASK;\n+}\n+\n+static __inline unsigned int\n+_MM_GET_EXCEPTION_MASK (void)\n+{\n+  return _mm_getcsr() & _MM_MASK_MASK;\n+}\n+\n+static __inline unsigned int\n+_MM_GET_ROUNDING_MODE (void)\n+{\n+  return _mm_getcsr() & _MM_ROUND_MASK;\n+}\n+\n+static __inline unsigned int\n+_MM_GET_FLUSH_ZERO_MODE (void)\n+{\n+  return _mm_getcsr() & _MM_FLUSH_ZERO_MASK;\n+}\n+\n+/* Set the control register to I.  */\n+static __inline void\n+_mm_setcsr (unsigned int __I)\n+{\n+  __builtin_ia32_setmxcsr (__I);\n+}\n+\n+/* Set exception bits in the control register.  */\n+static __inline void\n+_MM_SET_EXCEPTION_STATE(unsigned int __mask)\n+{\n+  _mm_setcsr((_mm_getcsr() & ~_MM_EXCEPT_MASK) | __mask);\n+}\n+\n+static __inline void\n+_MM_SET_EXCEPTION_MASK (unsigned int __mask)\n+{\n+  _mm_setcsr((_mm_getcsr() & ~_MM_MASK_MASK) | __mask);\n+}\n+\n+static __inline void\n+_MM_SET_ROUNDING_MODE (unsigned int __mode)\n+{\n+  _mm_setcsr((_mm_getcsr() & ~_MM_ROUND_MASK) | __mode);\n+}\n+\n+static __inline void\n+_MM_SET_FLUSH_ZERO_MODE (unsigned int __mode)\n+{\n+  _mm_setcsr((_mm_getcsr() & ~_MM_FLUSH_ZERO_MASK) | __mode);\n+}\n+\n+/* Create a vector with element 0 as *P and the rest zero.  */\n+static __inline __m128\n+_mm_load_ss (float *__P)\n+{\n+  return (__m128) __builtin_ia32_loadss (__P);\n+}\n+\n+/* Create a vector with all four elements equal to *P.  */\n+static __inline __m128\n+_mm_load1_ps (float *__P)\n+{\n+  __v4sf __tmp = __builtin_ia32_loadss (__P);\n+  return (__m128) __builtin_ia32_shufps (__tmp, __tmp, _MM_SHUFFLE (0,0,0,0));\n+}\n+\n+static __inline __m128\n+_mm_load_ps1 (float *__P)\n+{\n+  return _mm_load1_ps (__P);\n+}\n+\n+/* Load four SPFP values from P.  The address must be 16-byte aligned.  */\n+static __inline __m128\n+_mm_load_ps (float *__P)\n+{\n+  return (__m128) __builtin_ia32_loadaps (__P);\n+}\n+\n+/* Load four SPFP values from P.  The address need not be 16-byte aligned.  */\n+static __inline __m128\n+_mm_loadu_ps (float *__P)\n+{\n+  return (__m128) __builtin_ia32_loadups (__P);\n+}\n+\n+/* Load four SPFP values in reverse order.  The address must be aligned.  */\n+static __inline __m128\n+_mm_loadr_ps (float *__P)\n+{\n+  __v4sf __tmp = __builtin_ia32_loadaps (__P);\n+  return (__m128) __builtin_ia32_shufps (__tmp, __tmp, _MM_SHUFFLE (0,1,2,3));\n+}\n+\n+/* Create a vector with element 0 as F and the rest zero.  */\n+static __inline __m128\n+_mm_set_ss (float __F)\n+{\n+  return (__m128) __builtin_ia32_loadss (&__F);\n+}\n+\n+/* Create a vector with all four elements equal to F.  */\n+static __inline __m128\n+_mm_set1_ps (float __F)\n+{\n+  __v4sf __tmp = __builtin_ia32_loadss (&__F);\n+  return (__m128) __builtin_ia32_shufps (__tmp, __tmp, _MM_SHUFFLE (0,0,0,0));\n+}\n+\n+static __inline __m128\n+_mm_set_ps1 (float __F)\n+{\n+  return _mm_set1_ps (__F);\n+}\n+\n+/* Create the vector [Z Y X W].  */\n+static __inline __m128\n+_mm_set_ps (float __Z, float __Y, float __X, float __W)\n+{\n+  union {\n+    float __a[4];\n+    __m128 __v;\n+  } __u;\n+\n+  __u.__a[0] = __W;\n+  __u.__a[1] = __X;\n+  __u.__a[2] = __Y;\n+  __u.__a[3] = __Z;\n+\n+  return __u.__v;\n+}\n+\n+/* Create the vector [W X Y Z].  */\n+static __inline __m128\n+_mm_setr_ps (float __Z, float __Y, float __X, float __W)\n+{\n+  return _mm_set_ps (__W, __X, __Y, __Z);\n+}\n+\n+/* Create a vector of zeros.  */\n+static __inline __m128\n+_mm_setzero_ps (void)\n+{\n+  return (__m128) __builtin_ia32_setzerops ();\n+}\n+\n+/* Stores the lower SPFP value.  */\n+static __inline void\n+_mm_store_ss (float *__P, __m128 __A)\n+{\n+  __builtin_ia32_storess (__P, (__v4sf)__A);\n+}\n+\n+/* Store the lower SPFP value across four words.  */\n+static __inline void\n+_mm_store1_ps (float *__P, __m128 __A)\n+{\n+  __v4sf __va = (__v4sf)__A;\n+  __v4sf __tmp = __builtin_ia32_shufps (__va, __va, _MM_SHUFFLE (0,0,0,0));\n+  __builtin_ia32_storeaps (__P, __tmp);\n+}\n+\n+static __inline void\n+_mm_store_ps1 (float *__P, __m128 __A)\n+{\n+  _mm_store1_ps (__P, __A);\n+}\n+\n+/* Store four SPFP values.  The address must be 16-byte aligned.  */\n+static __inline void\n+_mm_store_ps (float *__P, __m128 __A)\n+{\n+  __builtin_ia32_storeaps (__P, (__v4sf)__A);\n+}\n+\n+/* Store four SPFP values.  The address need not be 16-byte aligned.  */\n+static __inline void\n+_mm_storeu_ps (float *__P, __m128 __A)\n+{\n+  __builtin_ia32_storeups (__P, (__v4sf)__A);\n+}\n+\n+/* Store four SPFP values in reverse order.  The addres must be aligned.  */\n+static __inline void\n+_mm_storer_ps (float *__P, __m128 __A)\n+{\n+  __v4sf __va = (__v4sf)__A;\n+  __v4sf __tmp = __builtin_ia32_shufps (__va, __va, _MM_SHUFFLE (0,1,2,3));\n+  __builtin_ia32_storeaps (__P, __tmp);\n+}\n+\n+/* Sets the low SPFP value of A from the low value of B.  */\n+static __inline __m128\n+_mm_move_ss (__m128 __A, __m128 __B)\n+{\n+  return (__m128) __builtin_ia32_movss ((__v4sf)__A, (__v4sf)__B);\n+}\n+\n+/* Extracts one of the four words of A.  The selector N must be immediate.  */\n+#if 0\n+static __inline int\n+_mm_extract_pi16 (__m64 __A, int __N)\n+{\n+  return __builtin_ia32_pextrw ((__v4hi)__A, __N);\n+}\n+#else\n+#define _mm_extract_pi16(A, N) \\\n+  __builtin_ia32_pextrw ((__v4hi)(A), (N))\n+#endif\n+\n+/* Inserts word D into one of four words of A.  The selector N must be\n+   immediate.  */\n+#if 0\n+static __inline __m64\n+_mm_insert_pi16 (__m64 __A, int __D, int __N)\n+{\n+  return (__m64)__builtin_ia32_pinsrw ((__v4hi)__A, __D, __N);\n+}\n+#else\n+#define _mm_insert_pi16(A, D, N) \\\n+  ((__m64) __builtin_ia32_pinsrw ((__v4hi)(A), (D), (N)))\n+#endif\n+\n+/* Compute the element-wise maximum of signed 16-bit values.  */\n+static __inline __m64\n+_mm_max_pi16 (__m64 __A, __m64 __B)\n+{\n+  return (__m64) __builtin_ia32_pmaxsw ((__v4hi)__A, (__v4hi)__B);\n+}\n+\n+/* Compute the element-wise maximum of unsigned 8-bit values.  */\n+static __inline __m64\n+_mm_max_pu8 (__m64 __A, __m64 __B)\n+{\n+  return (__m64) __builtin_ia32_pmaxub ((__v8qi)__A, (__v8qi)__B);\n+}\n+\n+/* Compute the element-wise minimum of signed 16-bit values.  */\n+static __inline __m64\n+_mm_min_pi16 (__m64 __A, __m64 __B)\n+{\n+  return (__m64) __builtin_ia32_pminsw ((__v4hi)__A, (__v4hi)__B);\n+}\n+\n+/* Compute the element-wise minimum of unsigned 8-bit values.  */\n+static __inline __m64\n+_mm_min_pu8 (__m64 __A, __m64 __B)\n+{\n+  return (__m64) __builtin_ia32_pminub ((__v8qi)__A, (__v8qi)__B);\n+}\n+\n+/* Create an 8-bit mask of the signs of 8-bit values.  */\n+static __inline int\n+_mm_movemask_pi8 (__m64 __A)\n+{\n+  return __builtin_ia32_pmovmskb ((__v8qi)__A);\n+}\n+\n+/* Multiply four unsigned 16-bit values in A by four unsigned 16-bit values\n+   in B and produce the high 16 bits of the 32-bit results.  */\n+static __inline __m64\n+_mm_mulhi_pu16 (__m64 __A, __m64 __B)\n+{\n+  return (__m64) __builtin_ia32_pmulhuw ((__v4hi)__A, (__v4hi)__B);\n+}\n+\n+/* Return a combination of the four 16-bit values in A.  The selector\n+   must be an immediate.  */\n+#if 0\n+static __inline __m64\n+_mm_shuffle_pi16 (__m64 __A, int __N)\n+{\n+  return (__m64) __builtin_ia32_pshufw ((__v4hi)__A, __N);\n+}\n+#else\n+#define _mm_shuffle_pi16(A, N) \\\n+  ((__m64) __builtin_ia32_pshufw ((__v4hi)(A), (N)))\n+#endif\n+\n+/* Conditionally store byte elements of A into P.  The high bit of each\n+   byte in the selector N determines whether the corresponding byte from\n+   A is stored.  */\n+static __inline void\n+_mm_maskmove_si64 (__m64 __A, __m64 __N, char *__P)\n+{\n+  __builtin_ia32_maskmovq ((__v8qi)__A, (__v8qi)__N, __P);\n+}\n+\n+/* Compute the rounded averages of the unsigned 8-bit values in A and B.  */\n+static __inline __m64\n+_mm_avg_pu8 (__m64 __A, __m64 __B)\n+{\n+  return (__m64) __builtin_ia32_pavgb ((__v8qi)__A, (__v8qi)__B);\n+}\n+\n+/* Compute the rounded averages of the unsigned 16-bit values in A and B.  */\n+static __inline __m64\n+_mm_avg_pu16 (__m64 __A, __m64 __B)\n+{\n+  return (__m64) __builtin_ia32_pavgw ((__v4hi)__A, (__v4hi)__B);\n+}\n+\n+/* Compute the sum of the absolute differences of the unsigned 8-bit\n+   values in A and B.  Return the value in the lower 16-bit word; the\n+   upper words are cleared.  */\n+static __inline __m64\n+_mm_sad_pu8 (__m64 __A, __m64 __B)\n+{\n+  return (__m64) __builtin_ia32_psadbw ((__v8qi)__A, (__v8qi)__B);\n+}\n+\n+/* Loads one cache line from address P to a location \"closer\" to the\n+   processor.  The selector I specifies the type of prefetch operation.  */\n+#if 0\n+static __inline void\n+_mm_prefetch (void *__P, enum _mm_hint __I)\n+{\n+  __builtin_prefetch (__P, 0, __I);\n+}\n+#else\n+#define _mm_prefetch(P, I) \\\n+  __builtin_prefetch ((P), 0, (I))\n+#endif\n+\n+/* Stores the data in A to the address P without polluting the caches.  */\n+static __inline void\n+_mm_stream_pi (__m64 *__P, __m64 __A)\n+{\n+  __builtin_ia32_movntq (__P, __A);\n+}\n+\n+/* Likewise.  The address must be 16-byte aligned.  */\n+static __inline void\n+_mm_stream_ps (float *__P, __m128 __A)\n+{\n+  __builtin_ia32_movntps (__P, (__v4sf)__A);\n+}\n+\n+/* Guarantees that every preceeding store is globally visible before\n+   any subsequent store.  */\n+static __inline void\n+_mm_sfence (void)\n+{\n+  __builtin_ia32_sfence ();\n+}\n+\n+/* The execution of the next instruction is delayed by an implementation\n+   specific amount of time.  The instruction does not modify the\n+   architectural state.  */\n+static __inline void\n+_mm_pause (void)\n+{\n+  __asm__ __volatile__ (\"rep; nop\" : : );\n+}\n+\n+/* Transpose the 4x4 matrix composed of row[0-3].  */\n+#define _MM_TRANSPOSE4_PS(row0, row1, row2, row3)\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  __v4sf __r0 = (row0), __r1 = (row1), __r2 = (row2), __r3 = (row3);\t\\\n+  __v4sf __t0 = __builtin_ia32_shufps (__r0, __r1, 0x44);\t\t\\\n+  __v4sf __t1 = __builtin_ia32_shufps (__r0, __r1, 0xEE);\t\t\\\n+  __v4sf __t2 = __builtin_ia32_shufps (__r2, __r3, 0x44);\t\t\\\n+  __v4sf __t3 = __builtin_ia32_shufps (__r2, __r3, 0xEE);\t\t\\\n+  (row0) = __builtin_ia32_shufps (__t0, __t1, 0x88);\t\t\t\\\n+  (row1) = __builtin_ia32_shufps (__t0, __t1, 0xDD);\t\t\t\\\n+  (row2) = __builtin_ia32_shufps (__t2, __t3, 0x88);\t\t\t\\\n+  (row3) = __builtin_ia32_shufps (__t2, __t3, 0xDD);\t\t\t\\\n+} while (0)\n+\n+#endif /* _XMMINTRIN_H_INCLUDED */"}, {"sha": "2db3ec0f7be88c7108a0503fd1687b42ad37479d", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f1a6c5bb40d87b2ebfc6e1f98f96c5a72d9b080/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f1a6c5bb40d87b2ebfc6e1f98f96c5a72d9b080/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=6f1a6c5bb40d87b2ebfc6e1f98f96c5a72d9b080", "patch": "@@ -572,6 +572,8 @@ simplify_unary_operation (code, mode, op, op_mode)\n \tcase SQRT:\n \tcase FLOAT_EXTEND:\n \tcase FLOAT_TRUNCATE:\n+\tcase SS_TRUNCATE:\n+\tcase US_TRUNCATE:\n \t  return 0;\n \n \tdefault:\n@@ -1524,6 +1526,13 @@ simplify_binary_operation (code, mode, op0, op1)\n \t    return op0;\n \t  break;\n \n+\tcase SS_PLUS:\n+\tcase US_PLUS:\n+\tcase SS_MINUS:\n+\tcase US_MINUS:\n+\t  /* ??? There are simplifications that can be done.  */\n+\t  return 0;\n+\n \tdefault:\n \t  abort ();\n \t}"}, {"sha": "54665164da08c6e25fbc40eb638165cf81f1a863", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f1a6c5bb40d87b2ebfc6e1f98f96c5a72d9b080/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f1a6c5bb40d87b2ebfc6e1f98f96c5a72d9b080/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6f1a6c5bb40d87b2ebfc6e1f98f96c5a72d9b080", "patch": "@@ -1,3 +1,8 @@\n+2002-01-11  Richard Henderson  <rth@redhat.com>\n+\n+\t* gcc.dg/i386-mmx-1.c, gcc.dg/i386-mmx-2.c: New.\n+\t* gcc.dg/i386-sse-1.c, gcc.dg/i386-sse-2.c, gcc.dg/i386-sse-1.c: New.\n+\n Fri Jan 11 12:13:30 2002  Nicola Pero  <n.pero@mi.flashnet.it>\n \n \t* objc.dg/special/unclaimed-category-1.m: Include objc/objc-api.h."}, {"sha": "138c9e96beb4261b6f2db4eabdb5f76a9fd7cf62", "filename": "gcc/testsuite/gcc.dg/i386-mmx-1.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f1a6c5bb40d87b2ebfc6e1f98f96c5a72d9b080/gcc%2Ftestsuite%2Fgcc.dg%2Fi386-mmx-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f1a6c5bb40d87b2ebfc6e1f98f96c5a72d9b080/gcc%2Ftestsuite%2Fgcc.dg%2Fi386-mmx-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fi386-mmx-1.c?ref=6f1a6c5bb40d87b2ebfc6e1f98f96c5a72d9b080", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile { target i?86-*-* } } */\n+/* { dg-options \"-O2 -mmmx\" } */\n+\n+/* Test that the intrinsics compile with optimization.  All of them are\n+   defined as inline functions in mmintrin.h that reference the proper\n+   builtin functions.  Defining away \"static\" and \"__inline\" results in\n+   all of them being compiled as proper functions.  */\n+\n+#define static\n+#define __inline\n+\n+#include <mmintrin.h>"}, {"sha": "dc6d9613c6395c2cac98d56307eebdf47a39eb6d", "filename": "gcc/testsuite/gcc.dg/i386-mmx-2.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f1a6c5bb40d87b2ebfc6e1f98f96c5a72d9b080/gcc%2Ftestsuite%2Fgcc.dg%2Fi386-mmx-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f1a6c5bb40d87b2ebfc6e1f98f96c5a72d9b080/gcc%2Ftestsuite%2Fgcc.dg%2Fi386-mmx-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fi386-mmx-2.c?ref=6f1a6c5bb40d87b2ebfc6e1f98f96c5a72d9b080", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile { target i?86-*-* } } */\n+/* { dg-options \"-O0 -mmmx\" } */\n+\n+/* Test that the intrinsics compile without optimization.  All of them are\n+   defined as inline functions in mmintrin.h that reference the proper\n+   builtin functions.  Defining away \"static\" and \"__inline\" results in\n+   all of them being compiled as proper functions.  */\n+\n+#define static\n+#define __inline\n+\n+#include <mmintrin.h>"}, {"sha": "a41a2697dbb44eab029a97fed4560e02d6d69da8", "filename": "gcc/testsuite/gcc.dg/i386-sse-1.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f1a6c5bb40d87b2ebfc6e1f98f96c5a72d9b080/gcc%2Ftestsuite%2Fgcc.dg%2Fi386-sse-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f1a6c5bb40d87b2ebfc6e1f98f96c5a72d9b080/gcc%2Ftestsuite%2Fgcc.dg%2Fi386-sse-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fi386-sse-1.c?ref=6f1a6c5bb40d87b2ebfc6e1f98f96c5a72d9b080", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile { target i?86-*-* } } */\n+/* { dg-options \"-O2 -msse\" } */\n+\n+/* Test that the intrinsics compile with optimization.  All of them are\n+   defined as inline functions in mmintrin.h that reference the proper\n+   builtin functions.  Defining away \"static\" and \"__inline\" results in\n+   all of them being compiled as proper functions.  */\n+\n+#define static\n+#define __inline\n+\n+#include <xmmintrin.h>"}, {"sha": "7dbf72b7cbb91ecf123a875b6b05e521c42d86af", "filename": "gcc/testsuite/gcc.dg/i386-sse-2.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f1a6c5bb40d87b2ebfc6e1f98f96c5a72d9b080/gcc%2Ftestsuite%2Fgcc.dg%2Fi386-sse-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f1a6c5bb40d87b2ebfc6e1f98f96c5a72d9b080/gcc%2Ftestsuite%2Fgcc.dg%2Fi386-sse-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fi386-sse-2.c?ref=6f1a6c5bb40d87b2ebfc6e1f98f96c5a72d9b080", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile { target i?86-*-* } } */\n+/* { dg-options \"-O0 -msse\" } */\n+\n+/* Test that the intrinsics compile without optimization.  All of them are\n+   defined as inline functions in mmintrin.h that reference the proper\n+   builtin functions.  Defining away \"static\" and \"__inline\" results in\n+   all of them being compiled as proper functions.  */\n+\n+#define static\n+#define __inline\n+\n+#include <xmmintrin.h>"}, {"sha": "c5c0599bc14e6f7a3f46618728f220399a0c58d1", "filename": "gcc/testsuite/gcc.dg/i386-sse-3.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f1a6c5bb40d87b2ebfc6e1f98f96c5a72d9b080/gcc%2Ftestsuite%2Fgcc.dg%2Fi386-sse-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f1a6c5bb40d87b2ebfc6e1f98f96c5a72d9b080/gcc%2Ftestsuite%2Fgcc.dg%2Fi386-sse-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fi386-sse-3.c?ref=6f1a6c5bb40d87b2ebfc6e1f98f96c5a72d9b080", "patch": "@@ -0,0 +1,37 @@\n+/* { dg-do compile { target i?86-*-* } } */\n+/* { dg-options \"-O2 -msse\" } */\n+\n+/* Test that the intrinsics compile with optimization.  These were not\n+   tested in i386-sse-[12].c because these builtins require immediate\n+   operands.  */\n+\n+#include <xmmintrin.h>\n+\n+__m128\n+test_shuf (void)\n+{\n+  __m128 a = _mm_set1_ps (1.0);\n+  __m128 b = _mm_set1_ps (2.0);\n+  return _mm_shuffle_ps (a, b, _MM_SHUFFLE (0,1,2,3));\n+}\n+\n+__m64\n+test_ins_ext (__m64 a)\n+{\n+  return _mm_insert_pi16 (a, _mm_extract_pi16 (a, 0), 3);\n+}\n+\n+__m64\n+test_shuf2 (__m64 a)\n+{\n+  return _mm_shuffle_pi16 (a, 0xA5);\n+}\n+\n+void\n+test_prefetch (char *p)\n+{\n+  _mm_prefetch (p, _MM_HINT_T0);\n+  _mm_prefetch (p+4, _MM_HINT_T1);\n+  _mm_prefetch (p+8, _MM_HINT_T2);\n+  _mm_prefetch (p+12, _MM_HINT_NTA);\n+}"}]}