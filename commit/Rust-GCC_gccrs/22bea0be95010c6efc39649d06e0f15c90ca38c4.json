{"sha": "22bea0be95010c6efc39649d06e0f15c90ca38c4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjJiZWEwYmU5NTAxMGM2ZWZjMzk2NDlkMDZlMGYxNWM5MGNhMzhjNA==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2015-11-25T22:22:37Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2015-11-25T22:22:37Z"}, "message": "lto-symtab.c: Include alias.h\n\n\t* lto-symtab.c: Include alias.h\n\t(warn_type_compatibility_p): Replace types_compatible_p checks by\n\tTBAA and size checks; set bit 2 if locations are TBAA incompatible.\n\t(lto_symtab_merge): Compare DECL sizes.\n\t(lto_symtab_merge_decls_2): Warn about TBAA in compatibility.\n\t* gfortran.dg/lto/bind_c-6_0.f90: New testcase.\n\t* gfortran.dg/lto/bind_c-6_1.c: New testcase.\n\nFrom-SVN: r230911", "tree": {"sha": "b128369d416f1bc592a1609dd628ce3d44c5432f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b128369d416f1bc592a1609dd628ce3d44c5432f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/22bea0be95010c6efc39649d06e0f15c90ca38c4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22bea0be95010c6efc39649d06e0f15c90ca38c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/22bea0be95010c6efc39649d06e0f15c90ca38c4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22bea0be95010c6efc39649d06e0f15c90ca38c4/comments", "author": null, "committer": null, "parents": [{"sha": "c74f743ae4537e887a0b71411422b7984c2edde1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c74f743ae4537e887a0b71411422b7984c2edde1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c74f743ae4537e887a0b71411422b7984c2edde1"}], "stats": {"total": 240, "additions": 170, "deletions": 70}, "files": [{"sha": "4aae7401fe29967767cd9918c0baf0f933a0242e", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22bea0be95010c6efc39649d06e0f15c90ca38c4/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22bea0be95010c6efc39649d06e0f15c90ca38c4/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=22bea0be95010c6efc39649d06e0f15c90ca38c4", "patch": "@@ -1,3 +1,11 @@\n+2015-11-24  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* lto-symtab.c: Include alias.h\n+\t(warn_type_compatibility_p): Replace types_compatible_p checks by\n+\tTBAA and size checks; set bit 2 if locations are TBAA incompatible.\n+\t(lto_symtab_merge): Compare DECL sizes.\n+\t(lto_symtab_merge_decls_2): Warn about TBAA in compatibility.\n+\n 2015-11-24  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* lto.c (iterative_hash_canonical_type): Recruse for all types"}, {"sha": "235df67e2ce34f5069f1c86fb3a7c7816d1aeaff", "filename": "gcc/lto/lto-symtab.c", "status": "modified", "additions": 109, "deletions": 70, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22bea0be95010c6efc39649d06e0f15c90ca38c4/gcc%2Flto%2Flto-symtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22bea0be95010c6efc39649d06e0f15c90ca38c4/gcc%2Flto%2Flto-symtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-symtab.c?ref=22bea0be95010c6efc39649d06e0f15c90ca38c4", "patch": "@@ -30,6 +30,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"lto-streamer.h\"\n #include \"ipa-utils.h\"\n #include \"builtins.h\"\n+#include \"alias.h\"\n \n /* Replace the cgraph node NODE with PREVAILING_NODE in the cgraph, merging\n    all edges and removing the old node.  */\n@@ -179,39 +180,52 @@ lto_varpool_replace_node (varpool_node *vnode,\n \n /* Return non-zero if we want to output waring about T1 and T2.\n    Return value is a bitmask of reasons of violation:\n-   Bit 0 indicates that types are not compatible of memory layout.\n-   Bit 1 indicates that types are not compatible because of C++ ODR rule.  */\n+   Bit 0 indicates that types are not compatible.\n+   Bit 1 indicates that types are not compatible because of C++ ODR rule.\n+   If COMMON_OR_EXTERN is true, do not warn on size mismatches of arrays.\n+   Bit 2 indicates that types are not ODR compatible\n+\n+   The interoperability rules are language specific.  At present we do only\n+   full checking for C++ ODR rule and for other languages we do basic check\n+   that data structures are of same size and TBAA compatible.  Our TBAA\n+   implementation should be coarse enough so all valid type transitions\n+   across different languages are allowed.\n+\n+   In partiucular we thus allow almost arbitrary type changes with\n+   -fno-strict-aliasing which may be tough of as a feature rather than bug\n+   as it allows to implement dodgy tricks in the language runtimes.\n+\n+   Naturally this code can be strenghtened significantly if we could track\n+   down the language of origin.  */\n \n static int\n-warn_type_compatibility_p (tree prevailing_type, tree type)\n+warn_type_compatibility_p (tree prevailing_type, tree type,\n+\t\t\t   bool common_or_extern)\n {\n   int lev = 0;\n+  bool odr_p = odr_or_derived_type_p (prevailing_type)\n+\t       && odr_or_derived_type_p (type);\n \n-  /* Get complete type.\n-     ???  We might want to emit a warning here if type qualification\n-     differences were spotted.  Do not do this unconditionally though.  */\n-  type = TYPE_MAIN_VARIANT (type);\n-  prevailing_type = TYPE_MAIN_VARIANT (prevailing_type);\n   if (prevailing_type == type)\n     return 0;\n \n-  bool odr_p = odr_or_derived_type_p (prevailing_type)\n-\t       && odr_or_derived_type_p (type);\n   /* C++ provide a robust way to check for type compatibility via the ODR\n      rule.  */\n   if (odr_p && !odr_types_equivalent_p (prevailing_type, type))\n-    lev = 2;\n+    lev |= 2;\n \n   /* Function types needs special care, because types_compatible_p never\n      thinks prototype is compatible to non-prototype.  */\n-  if ((TREE_CODE (type) == FUNCTION_TYPE || TREE_CODE (type) == METHOD_TYPE)\n-      && TREE_CODE (type) == TREE_CODE (prevailing_type))\n+  if (TREE_CODE (type) == FUNCTION_TYPE || TREE_CODE (type) == METHOD_TYPE)\n     {\n+      if (TREE_CODE (type) != TREE_CODE (prevailing_type))\n+\tlev |= 1;\n       lev |= warn_type_compatibility_p (TREE_TYPE (prevailing_type),\n-\t\t\t\t        TREE_TYPE (type));\n-      if (TREE_CODE (type) == METHOD_TYPE)\n+\t\t\t\t        TREE_TYPE (type), false);\n+      if (TREE_CODE (type) == METHOD_TYPE\n+\t  && TREE_CODE (prevailing_type) == METHOD_TYPE)\n \tlev |= warn_type_compatibility_p (TYPE_METHOD_BASETYPE (prevailing_type),\n-\t\t\t\t\t  TYPE_METHOD_BASETYPE (type));\n+\t\t\t\t\t  TYPE_METHOD_BASETYPE (type), false);\n       if (prototype_p (prevailing_type) && prototype_p (type)\n \t  && TYPE_ARG_TYPES (prevailing_type) != TYPE_ARG_TYPES (type))\n \t{\n@@ -222,62 +236,54 @@ warn_type_compatibility_p (tree prevailing_type, tree type)\n \t       parm1 = TREE_CHAIN (parm1),\n \t       parm2 = TREE_CHAIN (parm2))\n \t    lev |= warn_type_compatibility_p (TREE_VALUE (parm1),\n-\t\t\t\t\t      TREE_VALUE (parm2));\n+\t\t\t\t\t      TREE_VALUE (parm2), false);\n \t  if (parm1 || parm2)\n-\t    lev = odr_p ? 3 : 1;\n+\t    lev |= odr_p ? 3 : 1;\n \t}\n       if (comp_type_attributes (prevailing_type, type) == 0)\n-\tlev = odr_p ? 3 : 1;\n+\tlev |= 1;\n       return lev;\n     }\n-  /* Sharing a global symbol is a strong hint that two types are\n-     compatible.  We could use this information to complete\n-     incomplete pointed-to types more aggressively here, ignoring\n-     mismatches in both field and tag names.  It's difficult though\n-     to guarantee that this does not have side-effects on merging\n-     more compatible types from other translation units though.  */\n-\n-  /* We can tolerate differences in type qualification, the\n-     qualification of the prevailing definition will prevail.\n-     ???  In principle we might want to only warn for structurally\n-     incompatible types here, but unless we have protective measures\n-     for TBAA in place that would hide useful information.  */\n+\n+  /* Get complete type.  */\n   prevailing_type = TYPE_MAIN_VARIANT (prevailing_type);\n   type = TYPE_MAIN_VARIANT (type);\n \n-  if (!types_compatible_p (prevailing_type, type))\n+  /* We can not use types_compatible_p because we permit some changes\n+     across types.  For example unsigned size_t and \"signed size_t\" may be\n+     compatible when merging C and Fortran types.  */\n+  if (COMPLETE_TYPE_P (prevailing_type)\n+      && COMPLETE_TYPE_P (type)\n+      /* While global declarations are never variadic, we can recurse here\n+\t for function parameter types.  */\n+      && TREE_CODE (TYPE_SIZE (type)) == INTEGER_CST\n+      && TREE_CODE (TYPE_SIZE (prevailing_type)) == INTEGER_CST\n+      && !tree_int_cst_equal (TYPE_SIZE (type), TYPE_SIZE (prevailing_type)))\n     {\n-      if (TREE_CODE (prevailing_type) == FUNCTION_TYPE\n-\t  || TREE_CODE (type) == METHOD_TYPE)\n-\treturn 1 | lev;\n-      if (COMPLETE_TYPE_P (type) && COMPLETE_TYPE_P (prevailing_type))\n-\treturn 1 | lev;\n-\n-      /* If type is incomplete then avoid warnings in the cases\n-\t that TBAA handles just fine.  */\n-\n-      if (TREE_CODE (prevailing_type) != TREE_CODE (type))\n-\treturn 1 | lev;\n-\n-      if (TREE_CODE (prevailing_type) == ARRAY_TYPE)\n-\t{\n-\t  tree tem1 = TREE_TYPE (prevailing_type);\n-\t  tree tem2 = TREE_TYPE (type);\n-\t  while (TREE_CODE (tem1) == ARRAY_TYPE\n-\t\t && TREE_CODE (tem2) == ARRAY_TYPE)\n-\t    {\n-\t      tem1 = TREE_TYPE (tem1);\n-\t      tem2 = TREE_TYPE (tem2);\n-\t    }\n-\n-\t  if (TREE_CODE (tem1) != TREE_CODE (tem2))\n-\t    return 1 | lev;\n-\n-\t  if (!types_compatible_p (tem1, tem2))\n-\t    return 1 | lev;\n-\t}\n+       /* As a special case do not warn about merging\n+\t  int a[];\n+\t  and\n+\t  int a[]={1,2,3};\n+\t  here the first declaration is COMMON or EXTERN\n+\t  and sizeof(a) == sizeof (int).  */\n+       if (!common_or_extern\n+\t   || TREE_CODE (type) != ARRAY_TYPE\n+\t   || TYPE_SIZE (type) != TYPE_SIZE (TREE_TYPE (type)))\n+       lev |= 1;\n+    }\n \n-      /* Fallthru.  Compatible enough.  */\n+  /* Verify TBAA compatibility.  Take care of alias set 0 and the fact that\n+     we make ptr_type_node to TBAA compatible with every other type.  */\n+  if (type_with_alias_set_p (type) && type_with_alias_set_p (prevailing_type))\n+    {\n+      alias_set_type set1 = get_alias_set (type);\n+      alias_set_type set2 = get_alias_set (prevailing_type);\n+\n+      if (set1 && set2 && set1 != set2 \n+          && (!POINTER_TYPE_P (type) || !POINTER_TYPE_P (prevailing_type)\n+\t      || (set1 != TYPE_ALIAS_SET (ptr_type_node)\n+\t\t  && set2 != TYPE_ALIAS_SET (ptr_type_node))))\n+        lev |= 5;\n     }\n \n   return lev;\n@@ -312,14 +318,17 @@ lto_symtab_merge (symtab_node *prevailing, symtab_node *entry)\n       DECL_POSSIBLY_INLINED (decl) |= DECL_POSSIBLY_INLINED (prevailing_decl);\n \n       if (warn_type_compatibility_p (TREE_TYPE (prevailing_decl),\n-\t\t\t             TREE_TYPE (decl)))\n+\t\t\t             TREE_TYPE (decl),\n+\t\t\t\t     DECL_COMMON (decl)\n+\t\t\t\t     || DECL_EXTERNAL (decl)))\n \treturn false;\n \n       return true;\n     }\n \n   if (warn_type_compatibility_p (TREE_TYPE (prevailing_decl),\n-\t\t\t\t TREE_TYPE (decl)))\n+\t\t\t\t TREE_TYPE (decl),\n+\t\t\t\t DECL_COMMON (decl) || DECL_EXTERNAL (decl)))\n     return false;\n \n   /* There is no point in comparing too many details of the decls here.\n@@ -334,6 +343,20 @@ lto_symtab_merge (symtab_node *prevailing, symtab_node *entry)\n       && DECL_ALIGN (prevailing_decl) < DECL_ALIGN (decl))\n     return false;\n \n+  if (DECL_SIZE (decl) && DECL_SIZE (prevailing_decl)\n+      && !tree_int_cst_equal (DECL_SIZE (decl), DECL_SIZE (prevailing_decl))\n+      /* As a special case do not warn about merging\n+\t int a[];\n+\t and\n+\t int a[]={1,2,3};\n+\t here the first declaration is COMMON\n+\t and sizeof(a) == sizeof (int).  */\n+      && ((!DECL_COMMON (decl) && !DECL_EXTERNAL (decl))\n+\t  || TREE_CODE (TREE_TYPE (decl)) != ARRAY_TYPE\n+\t  || TYPE_SIZE (TREE_TYPE (decl))\n+\t     != TYPE_SIZE (TREE_TYPE (TREE_TYPE (decl)))))\n+    return false;\n+\n   return true;\n }\n \n@@ -491,6 +514,7 @@ lto_symtab_merge_decls_2 (symtab_node *first, bool diagnosed_p)\n   vec<tree> mismatches = vNULL;\n   unsigned i;\n   tree decl;\n+  bool tbaa_p = false;\n \n   /* Nothing to do for a single entry.  */\n   prevailing = first;\n@@ -514,11 +538,12 @@ lto_symtab_merge_decls_2 (symtab_node *first, bool diagnosed_p)\n   FOR_EACH_VEC_ELT (mismatches, i, decl)\n     {\n       int level = warn_type_compatibility_p (TREE_TYPE (prevailing->decl),\n-\t\t\t\t\t     TREE_TYPE (decl));\n+\t\t\t\t\t     TREE_TYPE (decl),\n+\t\t\t\t\t     DECL_COMDAT (decl));\n       if (level)\n \t{\n \t  bool diag = false;\n-\t  if (level > 1)\n+\t  if (level & 2)\n \t    diag = warning_at (DECL_SOURCE_LOCATION (decl),\n \t\t\t       OPT_Wodr,\n \t\t\t       \"%qD violates the C++ One Definition Rule \",\n@@ -529,10 +554,15 @@ lto_symtab_merge_decls_2 (symtab_node *first, bool diagnosed_p)\n \t\t\t       \"type of %qD does not match original \"\n \t\t\t       \"declaration\", decl);\n \t  if (diag)\n-\t    warn_types_mismatch (TREE_TYPE (prevailing->decl),\n-\t\t\t\t TREE_TYPE (decl),\n-\t\t\t\t DECL_SOURCE_LOCATION (prevailing->decl),\n-\t\t\t\t DECL_SOURCE_LOCATION (decl));\n+\t    {\n+\t      warn_types_mismatch (TREE_TYPE (prevailing->decl),\n+\t\t\t\t   TREE_TYPE (decl),\n+\t\t\t\t   DECL_SOURCE_LOCATION (prevailing->decl),\n+\t\t\t\t   DECL_SOURCE_LOCATION (decl));\n+\t      if ((level & 4)\n+\t\t  && !TREE_READONLY (prevailing->decl))\n+\t\ttbaa_p = true;\n+\t    }\n \t  diagnosed_p |= diag;\n \t}\n       else if ((DECL_USER_ALIGN (prevailing->decl)\n@@ -544,10 +574,19 @@ lto_symtab_merge_decls_2 (symtab_node *first, bool diagnosed_p)\n \t\t\t\t     \"alignment of %qD is bigger than \"\n \t\t\t\t     \"original declaration\", decl);\n \t}\n+      else\n+\tdiagnosed_p |= warning_at (DECL_SOURCE_LOCATION (decl),\n+\t\t\t\t   OPT_Wlto_type_mismatch,\n+\t\t\t\t   \"size of %qD differ from the size of \"\n+\t\t\t\t   \"original declaration\", decl);\n     }\n   if (diagnosed_p)\n     inform (DECL_SOURCE_LOCATION (prevailing->decl),\n \t    \"%qD was previously declared here\", prevailing->decl);\n+  if (tbaa_p)\n+    inform (DECL_SOURCE_LOCATION (prevailing->decl),\n+\t    \"code may be misoptimized unless \"\n+\t    \"-fno-strict-aliasing is used\");\n \n   mismatches.release ();\n }"}, {"sha": "0e40a0f41a0689387e5ba71c4236f69ec898b82a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22bea0be95010c6efc39649d06e0f15c90ca38c4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22bea0be95010c6efc39649d06e0f15c90ca38c4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=22bea0be95010c6efc39649d06e0f15c90ca38c4", "patch": "@@ -1,3 +1,9 @@\n+2015-11-23  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* gfortran.dg/lto/bind_c-6_0.f90: New testcase.\n+\t* gfortran.dg/lto/bind_c-6_1.c: New testcase.\n+\t* g++.dg/lto/20100603-1_0.C: Add -Wno-lto-type-mismatch.\n+\n 2015-11-25  Tom de Vries  <tom@codesourcery.com>\n \n \t* g++.dg/tree-ssa/copyprop-1.C: Update after adding new dce1."}, {"sha": "e2613036d81fa0e60898db685c05bcd0058ee0da", "filename": "gcc/testsuite/g++.dg/lto/20100603-1_0.C", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22bea0be95010c6efc39649d06e0f15c90ca38c4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20100603-1_0.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22bea0be95010c6efc39649d06e0f15c90ca38c4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20100603-1_0.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2F20100603-1_0.C?ref=22bea0be95010c6efc39649d06e0f15c90ca38c4", "patch": "@@ -1,4 +1,5 @@\n /* { dg-lto-do link } */\n+/* { dg-extra-ld-options \"-Wno-lto-type-mismatch\" } */\n \n extern \"C\" {\n     typedef struct {} CvImage;"}, {"sha": "95b789f767fa6b8a184eff0e9cbc16af35f3ca7c", "filename": "gcc/testsuite/gfortran.dg/lto/bind_c-6_0.f90", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22bea0be95010c6efc39649d06e0f15c90ca38c4/gcc%2Ftestsuite%2Fgfortran.dg%2Flto%2Fbind_c-6_0.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22bea0be95010c6efc39649d06e0f15c90ca38c4/gcc%2Ftestsuite%2Fgfortran.dg%2Flto%2Fbind_c-6_0.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Flto%2Fbind_c-6_0.f90?ref=22bea0be95010c6efc39649d06e0f15c90ca38c4", "patch": "@@ -0,0 +1,17 @@\n+! { dg-lto-do run }\n+! { dg-lto-options {{ -O3 -flto }} }\n+! This testcase will abort if C_FUNPTR is not interoperable with both int *\n+! and float *\n+module lto_type_merge_test\n+  use, intrinsic :: iso_c_binding\n+  implicit none\n+\n+  integer(c_size_t), bind(c, name=\"myVar\") :: myVar\n+  integer(c_size_t), bind(c, name=\"myVar2\") :: myVar2\n+\n+contains\n+  subroutine types_test() bind(c)\n+    myVar = myVar2\n+  end subroutine types_test\n+end module lto_type_merge_test\n+"}, {"sha": "0684bd0dfb47ab9d8c0d06fb581b89e4d3d0d462", "filename": "gcc/testsuite/gfortran.dg/lto/bind_c-6_1.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22bea0be95010c6efc39649d06e0f15c90ca38c4/gcc%2Ftestsuite%2Fgfortran.dg%2Flto%2Fbind_c-6_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22bea0be95010c6efc39649d06e0f15c90ca38c4/gcc%2Ftestsuite%2Fgfortran.dg%2Flto%2Fbind_c-6_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Flto%2Fbind_c-6_1.c?ref=22bea0be95010c6efc39649d06e0f15c90ca38c4", "patch": "@@ -0,0 +1,29 @@\n+#include <stdlib.h>\n+/* declared in the fortran module */\n+extern size_t myVar, myVar2;\n+void types_test(void);\n+\n+\n+extern void abort(void);\n+\n+int main(int argc, char **argv)\n+{\n+   size_t *myptr, *myptr2;\n+   asm(\"\":\"=r\"(myptr):\"0\"(&myVar));\n+   asm(\"\":\"=r\"(myptr2):\"0\"(&myVar2));\n+   *myptr = 1;\n+   *myptr2 = 2;\n+   types_test();\n+   if (*myptr != 2)\n+\tabort ();\n+   if (*myptr2 != 2)\n+\tabort ();\n+   *myptr2 = 3;\n+   types_test();\n+   if (*myptr != 3)\n+\tabort ();\n+   if (*myptr2 != 3)\n+\tabort ();\n+   return 0;\n+}\n+"}]}