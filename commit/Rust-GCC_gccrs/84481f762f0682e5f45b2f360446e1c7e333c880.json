{"sha": "84481f762f0682e5f45b2f360446e1c7e333c880", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODQ0ODFmNzYyZjA2ODJlNWY0NWIyZjM2MDQ0NmUxYzdlMzMzYzg4MA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2001-10-02T13:46:42Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2001-10-02T13:46:42Z"}, "message": "New Language: Ada\n\nFrom-SVN: r45952", "tree": {"sha": "ec92b635579926dc15738c43b5de10e402669757", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ec92b635579926dc15738c43b5de10e402669757"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/84481f762f0682e5f45b2f360446e1c7e333c880", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84481f762f0682e5f45b2f360446e1c7e333c880", "html_url": "https://github.com/Rust-GCC/gccrs/commit/84481f762f0682e5f45b2f360446e1c7e333c880", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84481f762f0682e5f45b2f360446e1c7e333c880/comments", "author": null, "committer": null, "parents": [{"sha": "62a040818aae81ad8558ebbe3c8973a16e7c250f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62a040818aae81ad8558ebbe3c8973a16e7c250f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/62a040818aae81ad8558ebbe3c8973a16e7c250f"}], "stats": {"total": 68905, "additions": 68905, "deletions": 0}, "files": [{"sha": "c212f5067148e24224930a7012555f43cda0493d", "filename": "gcc/ada/51osinte.adb", "status": "added", "additions": 177, "deletions": 0, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F51osinte.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F51osinte.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F51osinte.adb?ref=84481f762f0682e5f45b2f360446e1c7e333c880", "patch": "@@ -0,0 +1,177 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS               --\n+--                                                                          --\n+--                   S Y S T E M . O S _ I N T E R F A C E                  --\n+--                                                                          --\n+--                                  B o d y                                 --\n+--                                                                          --\n+--                              $Revision: 1.4 $\n+--                                                                          --\n+--           Copyright (C) 1999-2001 Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNARL is free software; you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion. GNARL is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNARL; see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNARL was developed by the GNARL team at Florida State University. It is --\n+-- now maintained by Ada Core Technologies Inc. in cooperation with Florida --\n+-- State University (http://www.gnat.com).                                  --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is a UnixWare (Native) version of this package\n+\n+pragma Polling (Off);\n+--  Turn off polling, we do not want ATC polling to take place during\n+--  tasking operations. It causes infinite loops and other problems.\n+\n+with Interfaces.C;\n+\n+package body System.OS_Interface is\n+\n+   use Interfaces.C;\n+\n+   -----------------\n+   -- To_Duration --\n+   -----------------\n+\n+   function To_Duration (TS : timespec) return Duration is\n+   begin\n+      return Duration (TS.tv_sec) + Duration (TS.tv_nsec) / 10#1#E9;\n+   end To_Duration;\n+\n+   function To_Duration (TV : struct_timeval) return Duration is\n+   begin\n+      return Duration (TV.tv_sec) + Duration (TV.tv_usec) / 10#1#E6;\n+   end To_Duration;\n+\n+   -----------------\n+   -- To_Timespec --\n+   -----------------\n+\n+   function To_Timespec (D : Duration) return timespec is\n+      S : time_t;\n+      F : Duration;\n+\n+   begin\n+      S := time_t (Long_Long_Integer (D));\n+      F := D - Duration (S);\n+\n+      --  If F has negative value due to a round-up, adjust for positive F\n+      --  value.\n+\n+      if F < 0.0 then\n+         S := S - 1;\n+         F := F + 1.0;\n+      end if;\n+\n+      return timespec' (tv_sec => S,\n+        tv_nsec => long (Long_Long_Integer (F * 10#1#E9)));\n+   end To_Timespec;\n+\n+   ----------------\n+   -- To_Timeval --\n+   ----------------\n+\n+   function To_Timeval (D : Duration) return struct_timeval is\n+      S : long;\n+      F : Duration;\n+\n+   begin\n+      S := long (Long_Long_Integer (D));\n+      F := D - Duration (S);\n+\n+      --  If F has negative value due to a round-up, adjust for positive F\n+      --  value.\n+\n+      if F < 0.0 then\n+         S := S - 1;\n+         F := F + 1.0;\n+      end if;\n+\n+      return struct_timeval' (tv_sec => S,\n+        tv_usec => long (Long_Long_Integer (F * 10#1#E6)));\n+   end To_Timeval;\n+\n+   -------------------\n+   -- clock_gettime --\n+   -------------------\n+\n+   function clock_gettime\n+     (clock_id : clockid_t;\n+      tp       : access timespec) return int\n+   is\n+      Result : int;\n+      tv     : aliased struct_timeval;\n+\n+      function gettimeofday\n+        (tv : access struct_timeval;\n+         tz : System.Address := System.Null_Address) return int;\n+      pragma Import (C, gettimeofday, \"gettimeofday\");\n+\n+   begin\n+      Result := gettimeofday (tv'Unchecked_Access);\n+      tp.all := To_Timespec (To_Duration (tv));\n+      return Result;\n+   end clock_gettime;\n+\n+   ---------------------------\n+   --  POSIX.1c  Section 3  --\n+   ---------------------------\n+\n+   function sigwait (set : access sigset_t; sig : access Signal) return int is\n+      Result : int;\n+\n+      function sigwait (set : access sigset_t) return int;\n+      pragma Import (C, sigwait, \"sigwait\");\n+\n+   begin\n+      Result := sigwait (set);\n+\n+      if Result < 0 then\n+         sig.all := 0;\n+         return errno;\n+      end if;\n+\n+      sig.all := Signal (Result);\n+      return 0;\n+   end sigwait;\n+\n+   function pthread_kill (thread : pthread_t; sig : Signal) return int is\n+      function pthread_kill_base\n+        (thread : access pthread_t; sig : access Signal) return int;\n+      pragma Import (C, pthread_kill_base, \"pthread_kill\");\n+\n+      thr   : aliased pthread_t := thread;\n+      signo : aliased Signal := sig;\n+\n+   begin\n+      return pthread_kill_base (thr'Unchecked_Access, signo'Unchecked_Access);\n+   end pthread_kill;\n+\n+   function Get_Stack_Base (thread : pthread_t) return Address is\n+   begin\n+      return Null_Address;\n+   end Get_Stack_Base;\n+\n+   procedure pthread_init is\n+   begin\n+      null;\n+   end pthread_init;\n+\n+end System.OS_Interface;"}, {"sha": "80b2b95fe13c80288513a6e8b5203b298418511f", "filename": "gcc/ada/51osinte.ads", "status": "added", "additions": 597, "deletions": 0, "changes": 597, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F51osinte.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F51osinte.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F51osinte.ads?ref=84481f762f0682e5f45b2f360446e1c7e333c880", "patch": "@@ -0,0 +1,597 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS               --\n+--                                                                          --\n+--                   S Y S T E M . O S _ I N T E R F A C E                  --\n+--                                                                          --\n+--                                  S p e c                                 --\n+--                                                                          --\n+--                             $Revision: 1.10 $\n+--                                                                          --\n+--          Copyright (C) 1999-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNARL is free software; you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion. GNARL is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNARL; see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNARL was developed by the GNARL team at Florida State University. It is --\n+-- now maintained by Ada Core Technologies Inc. in cooperation with Florida --\n+-- State University (http://www.gnat.com).                                  --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is a UnixWare (Native THREADS) version of this package.\n+\n+--  This package encapsulates all direct interfaces to OS services\n+--  that are needed by children of System.\n+\n+--  PLEASE DO NOT add any with-clauses to this package\n+--  or remove the pragma Elaborate_Body.\n+--  It is designed to be a bottom-level (leaf) package.\n+\n+with Interfaces.C;\n+package System.OS_Interface is\n+   pragma Preelaborate;\n+\n+   pragma Linker_Options (\"-lthread\");\n+\n+   subtype int            is Interfaces.C.int;\n+   subtype char           is Interfaces.C.char;\n+   subtype short          is Interfaces.C.short;\n+   subtype long           is Interfaces.C.long;\n+   subtype unsigned       is Interfaces.C.unsigned;\n+   subtype unsigned_short is Interfaces.C.unsigned_short;\n+   subtype unsigned_long  is Interfaces.C.unsigned_long;\n+   subtype unsigned_char  is Interfaces.C.unsigned_char;\n+   subtype plain_char     is Interfaces.C.plain_char;\n+   subtype size_t         is Interfaces.C.size_t;\n+\n+   -----------\n+   -- Errno --\n+   -----------\n+\n+   function errno return int;\n+   pragma Import (C, errno, \"__get_errno\");\n+\n+   EAGAIN    : constant := 11;\n+   EINTR     : constant := 4;\n+   EINVAL    : constant := 22;\n+   ENOMEM    : constant := 12;\n+   ETIMEDOUT : constant := 145;\n+\n+   -------------\n+   -- Signals --\n+   -------------\n+\n+   Max_Interrupt : constant := 34;\n+   type Signal is new int range 0 .. Max_Interrupt;\n+   for Signal'Size use int'Size;\n+\n+   SIGHUP      : constant := 1; --  hangup\n+   SIGINT      : constant := 2; --  interrupt (rubout)\n+   SIGQUIT     : constant := 3; --  quit (ASCD FS)\n+   SIGILL      : constant := 4; --  illegal instruction (not reset)\n+   SIGTRAP     : constant := 5; --  trace trap (not reset)\n+   SIGIOT      : constant := 6; --  IOT instruction\n+   SIGABRT     : constant := 6; --  used by abort, replace SIGIOT in the future\n+   SIGEMT      : constant := 7; --  EMT instruction\n+   SIGFPE      : constant := 8; --  floating point exception\n+   SIGKILL     : constant := 9; --  kill (cannot be caught or ignored)\n+   SIGBUS      : constant := 10; --  bus error\n+   SIGSEGV     : constant := 11; --  segmentation violation\n+   SIGSYS      : constant := 12; --  bad argument to system call\n+   SIGPIPE     : constant := 13; --  write on a pipe with no one to read it\n+   SIGALRM     : constant := 14; --  alarm clock\n+   SIGTERM     : constant := 15; --  software termination signal from kill\n+   SIGUSR1     : constant := 16; --  user defined signal 1\n+   SIGUSR2     : constant := 17; --  user defined signal 2\n+   SIGCLD      : constant := 18; --  alias for SIGCHLD\n+   SIGCHLD     : constant := 18; --  child status change\n+   SIGPWR      : constant := 19; --  power-fail restart\n+   SIGWINCH    : constant := 20; --  window size change\n+   SIGURG      : constant := 21; --  urgent condition on IO channel\n+   SIGPOLL     : constant := 22; --  pollable event occurred\n+   SIGIO       : constant := 22; --  I/O possible (Solaris SIGPOLL alias)\n+   SIGSTOP     : constant := 23; --  stop (cannot be caught or ignored)\n+   SIGTSTP     : constant := 24; --  user stop requested from tty\n+   SIGCONT     : constant := 25; --  stopped process has been continued\n+   SIGTTIN     : constant := 26; --  background tty read attempted\n+   SIGTTOU     : constant := 27; --  background tty write attempted\n+   SIGVTALRM   : constant := 28; --  virtual timer expired\n+   SIGPROF     : constant := 29; --  profiling timer expired\n+   SIGXCPU     : constant := 30; --  CPU time limit exceeded\n+   SIGXFSZ     : constant := 31; --  filesize limit exceeded\n+   SIGWAITING  : constant := 32; --  all LWPs blocked interruptibly notific.\n+   SIGLWP      : constant := 33; --  signal reserved for thread lib impl.\n+   SIGAIO      : constant := 34; --  Asynchronous I/O signal\n+\n+   SIGADAABORT : constant := SIGABRT;\n+   --  Change this if you want to use another signal for task abort.\n+   --  SIGTERM might be a good one.\n+\n+   type Signal_Set is array (Natural range <>) of Signal;\n+\n+   Unmasked    : constant Signal_Set :=\n+     (SIGTRAP, SIGLWP, SIGWAITING, SIGTTIN, SIGTTOU, SIGTSTP, SIGPROF);\n+   Reserved    : constant Signal_Set := (SIGABRT, SIGKILL, SIGSTOP);\n+\n+   type sigset_t is private;\n+\n+   function sigaddset (set : access sigset_t; sig : Signal) return int;\n+   pragma Import (C, sigaddset, \"sigaddset\");\n+\n+   function sigdelset (set : access sigset_t; sig : Signal) return int;\n+   pragma Import (C, sigdelset, \"sigdelset\");\n+\n+   function sigfillset (set : access sigset_t) return int;\n+   pragma Import (C, sigfillset, \"sigfillset\");\n+\n+   function sigismember (set : access sigset_t; sig : Signal) return int;\n+   pragma Import (C, sigismember, \"sigismember\");\n+\n+   function sigemptyset (set : access sigset_t) return int;\n+   pragma Import (C, sigemptyset, \"sigemptyset\");\n+\n+   type struct_sigaction is record\n+      sa_flags   : int;\n+      sa_handler : System.Address;\n+      sa_mask    : sigset_t;\n+      sa_resv1   : int;\n+      sa_resv2   : int;\n+   end record;\n+   pragma Convention (C, struct_sigaction);\n+   type struct_sigaction_ptr is access all struct_sigaction;\n+\n+   SIG_BLOCK   : constant := 1;\n+   SIG_UNBLOCK : constant := 2;\n+   SIG_SETMASK : constant := 3;\n+\n+   SIG_DFL : constant := 0;\n+   SIG_IGN : constant := 1;\n+   --  SIG_ERR : constant := -1;\n+   --  not used\n+\n+   function sigaction\n+     (sig  : Signal;\n+      act  : struct_sigaction_ptr;\n+      oact : struct_sigaction_ptr) return int;\n+   pragma Import (C, sigaction, \"sigaction\");\n+\n+   ----------\n+   -- Time --\n+   ----------\n+\n+   Time_Slice_Supported : constant Boolean := False;\n+   --  Indicates wether time slicing is supported\n+\n+   type timespec is private;\n+\n+   type clockid_t is private;\n+\n+   CLOCK_REALTIME : constant clockid_t;\n+\n+   function clock_gettime\n+     (clock_id : clockid_t;\n+      tp       : access timespec) return int;\n+   --  UnixWare threads don't have clock_gettime\n+   --  We instead use gettimeofday()\n+\n+   function To_Duration (TS : timespec) return Duration;\n+   pragma Inline (To_Duration);\n+\n+   function To_Timespec (D : Duration) return timespec;\n+   pragma Inline (To_Timespec);\n+\n+   type struct_timezone is record\n+      tz_minuteswest : int;\n+      tz_dsttime     : int;\n+   end record;\n+   pragma Convention (C, struct_timezone);\n+   type struct_timezone_ptr is access all struct_timezone;\n+\n+   type struct_timeval is private;\n+   --  This is needed on systems that do not have clock_gettime()\n+   --  but do have gettimeofday().\n+\n+   function To_Duration (TV : struct_timeval) return Duration;\n+   pragma Inline (To_Duration);\n+\n+   function To_Timeval (D : Duration) return struct_timeval;\n+   pragma Inline (To_Timeval);\n+\n+   -------------------------\n+   -- Priority Scheduling --\n+   -------------------------\n+\n+   SCHED_FIFO  : constant := 2;\n+   SCHED_RR    : constant := 3;\n+   SCHED_OTHER : constant := 1;\n+\n+   -------------\n+   -- Process --\n+   -------------\n+\n+   type pid_t is private;\n+\n+   function kill (pid : pid_t; sig : Signal) return int;\n+   pragma Import (C, kill, \"kill\");\n+\n+   function getpid return pid_t;\n+   pragma Import (C, getpid, \"getpid\");\n+\n+   ---------\n+   -- LWP --\n+   ---------\n+\n+   function lwp_self return System.Address;\n+   pragma Import (C, lwp_self, \"_lwp_self\");\n+\n+   -------------\n+   -- Threads --\n+   -------------\n+\n+   type Thread_Body is access\n+     function (arg : System.Address) return System.Address;\n+   type pthread_t           is private;\n+   subtype Thread_Id        is pthread_t;\n+\n+   type pthread_mutex_t     is limited private;\n+   type pthread_cond_t      is limited private;\n+   type pthread_attr_t      is limited private;\n+   type pthread_mutexattr_t is limited private;\n+   type pthread_condattr_t  is limited private;\n+   type pthread_key_t       is private;\n+\n+   PTHREAD_CREATE_DETACHED : constant := 0;\n+\n+   -----------\n+   -- Stack --\n+   -----------\n+\n+   Stack_Base_Available : constant Boolean := False;\n+   --  Indicates wether the stack base is available on this target.\n+\n+   function Get_Stack_Base (thread : pthread_t) return Address;\n+   pragma Inline (Get_Stack_Base);\n+   --  returns the stack base of the specified thread.\n+   --  Only call this function when Stack_Base_Available is True.\n+\n+   function Get_Page_Size return size_t;\n+   function Get_Page_Size return Address;\n+   pragma Import (C, Get_Page_Size, \"getpagesize\");\n+   --  returns the size of a page, or 0 if this is not relevant on this\n+   --  target\n+\n+   PROT_NONE  : constant := 0;\n+   PROT_READ  : constant := 1;\n+   PROT_WRITE : constant := 2;\n+   PROT_EXEC  : constant := 4;\n+   PROT_USER  : constant := 8;\n+   PROT_ALL   : constant := PROT_READ + PROT_WRITE + PROT_EXEC + PROT_USER;\n+\n+   PROT_ON    : constant := PROT_READ;\n+   PROT_OFF   : constant := PROT_ALL;\n+\n+   function mprotect (addr : Address; len : size_t; prot : int) return int;\n+   pragma Import (C, mprotect);\n+\n+   -------------------------\n+   -- POSIX.1c  Section 3 --\n+   -------------------------\n+\n+   function sigwait (set : access sigset_t; sig : access Signal) return int;\n+   pragma Inline (sigwait);\n+   --  UnixWare provides a non standard sigwait\n+\n+   function pthread_kill (thread : pthread_t; sig : Signal) return int;\n+   pragma Inline (pthread_kill);\n+   --  UnixWare provides a non standard pthread_kill\n+\n+   type sigset_t_ptr is access all sigset_t;\n+\n+   function pthread_sigmask\n+     (how  : int;\n+      set  : sigset_t_ptr;\n+      oset : sigset_t_ptr) return int;\n+   pragma Import (C, pthread_sigmask, \"pthread_sigmask\");\n+\n+   --------------------------\n+   -- POSIX.1c  Section 11 --\n+   --------------------------\n+\n+   function pthread_mutexattr_init\n+     (attr : access pthread_mutexattr_t) return int;\n+   pragma Import (C, pthread_mutexattr_init, \"pthread_mutexattr_init\");\n+\n+   function pthread_mutexattr_destroy\n+     (attr : access pthread_mutexattr_t) return int;\n+   pragma Import (C, pthread_mutexattr_destroy, \"pthread_mutexattr_destroy\");\n+\n+   function pthread_mutex_init\n+     (mutex : access pthread_mutex_t;\n+      attr  : access pthread_mutexattr_t) return int;\n+   pragma Import (C, pthread_mutex_init, \"pthread_mutex_init\");\n+\n+   function pthread_mutex_destroy (mutex : access pthread_mutex_t) return int;\n+   pragma Import (C, pthread_mutex_destroy, \"pthread_mutex_destroy\");\n+\n+   function pthread_mutex_lock (mutex : access pthread_mutex_t) return int;\n+   pragma Import (C, pthread_mutex_lock, \"pthread_mutex_lock\");\n+\n+   function pthread_mutex_unlock (mutex : access pthread_mutex_t) return int;\n+   pragma Import (C, pthread_mutex_unlock, \"pthread_mutex_unlock\");\n+\n+   function pthread_condattr_init\n+     (attr : access pthread_condattr_t) return int;\n+   pragma Import (C, pthread_condattr_init, \"pthread_condattr_init\");\n+\n+   function pthread_condattr_destroy\n+     (attr : access pthread_condattr_t) return int;\n+   pragma Import (C, pthread_condattr_destroy, \"pthread_condattr_destroy\");\n+\n+   function pthread_cond_init\n+     (cond : access pthread_cond_t;\n+      attr : access pthread_condattr_t) return int;\n+   pragma Import (C, pthread_cond_init, \"pthread_cond_init\");\n+\n+   function pthread_cond_destroy (cond : access pthread_cond_t) return int;\n+   pragma Import (C, pthread_cond_destroy, \"pthread_cond_destroy\");\n+\n+   function pthread_cond_signal (cond : access pthread_cond_t) return int;\n+   pragma Import (C, pthread_cond_signal, \"pthread_cond_signal\");\n+\n+   function pthread_cond_wait\n+     (cond  : access pthread_cond_t;\n+      mutex : access pthread_mutex_t) return int;\n+   pragma Import (C, pthread_cond_wait, \"pthread_cond_wait\");\n+\n+   function pthread_cond_timedwait\n+     (cond    : access pthread_cond_t;\n+      mutex   : access pthread_mutex_t;\n+      abstime : access timespec) return int;\n+   pragma Import (C, pthread_cond_timedwait, \"pthread_cond_timedwait\");\n+\n+   Relative_Timed_Wait : constant Boolean := False;\n+   --  pthread_cond_timedwait requires an absolute delay time\n+\n+   --------------------------\n+   -- POSIX.1c  Section 13 --\n+   --------------------------\n+\n+   PTHREAD_PRIO_NONE    : constant := 1;\n+   PTHREAD_PRIO_INHERIT : constant := 2;\n+   PTHREAD_PRIO_PROTECT : constant := 3;\n+\n+   function pthread_mutexattr_setprotocol\n+     (attr     : access pthread_mutexattr_t;\n+      protocol : int) return int;\n+   pragma Import (C, pthread_mutexattr_setprotocol);\n+\n+   function pthread_mutexattr_setprioceiling\n+     (attr     : access pthread_mutexattr_t;\n+      prioceiling : int) return int;\n+   pragma Import (C, pthread_mutexattr_setprioceiling);\n+\n+   type sched_union is record\n+      sched_fifo    : int;\n+      sched_fcfs    : int;\n+      sched_other   : int;\n+      sched_ts      : int;\n+      policy_params : long;\n+   end record;\n+\n+   type struct_sched_param is record\n+      sched_priority    : int;\n+      sched_other_stuff : sched_union;\n+   end record;\n+\n+   function pthread_setschedparam\n+     (thread : pthread_t;\n+      policy : int;\n+      param  : access struct_sched_param) return int;\n+   pragma Import (C, pthread_setschedparam, \"pthread_setschedparam\");\n+\n+   function pthread_attr_setscope\n+     (attr            : access pthread_attr_t;\n+      contentionscope : int) return int;\n+   pragma Import (C, pthread_attr_setscope, \"pthread_attr_setscope\");\n+\n+   function pthread_attr_setinheritsched\n+     (attr            : access pthread_attr_t;\n+      inheritsched : int) return int;\n+   pragma Import (C, pthread_attr_setinheritsched);\n+\n+   function pthread_attr_setschedpolicy\n+     (attr   : access pthread_attr_t;\n+      policy : int) return int;\n+   pragma Import (C, pthread_attr_setschedpolicy);\n+\n+   function sched_yield return int;\n+   pragma Import (C, sched_yield, \"sched_yield\");\n+\n+   ---------------------------\n+   -- P1003.1c - Section 16 --\n+   ---------------------------\n+\n+   function pthread_attr_init (attributes : access pthread_attr_t) return int;\n+   pragma Import (C, pthread_attr_init, \"pthread_attr_init\");\n+\n+   function pthread_attr_destroy\n+     (attributes : access pthread_attr_t) return int;\n+   pragma Import (C, pthread_attr_destroy, \"pthread_attr_destroy\");\n+\n+   function pthread_attr_setdetachstate\n+     (attr        : access pthread_attr_t;\n+      detachstate : int) return int;\n+   pragma Import (C, pthread_attr_setdetachstate);\n+\n+   function pthread_attr_setstacksize\n+     (attr      : access pthread_attr_t;\n+      stacksize : size_t) return int;\n+   pragma Import (C, pthread_attr_setstacksize);\n+\n+   function pthread_create\n+     (thread        : access pthread_t;\n+      attributes    : access pthread_attr_t;\n+      start_routine : Thread_Body;\n+      arg           : System.Address) return int;\n+   pragma Import (C, pthread_create, \"pthread_create\");\n+\n+   procedure pthread_exit (status : System.Address);\n+   pragma Import (C, pthread_exit, \"pthread_exit\");\n+\n+   function pthread_self return pthread_t;\n+   pragma Import (C, pthread_self, \"pthread_self\");\n+\n+   --------------------------\n+   -- POSIX.1c  Section 17 --\n+   --------------------------\n+\n+   function pthread_setspecific\n+     (key   : pthread_key_t;\n+      value : System.Address) return int;\n+   pragma Import (C, pthread_setspecific, \"pthread_setspecific\");\n+\n+   function pthread_getspecific (key : pthread_key_t) return System.Address;\n+   pragma Import (C, pthread_getspecific, \"pthread_getspecific\");\n+\n+   type destructor_pointer is access procedure (arg : System.Address);\n+\n+   function pthread_key_create\n+     (key        : access pthread_key_t;\n+      destructor : destructor_pointer) return int;\n+   pragma Import (C, pthread_key_create, \"pthread_key_create\");\n+\n+   procedure pthread_init;\n+   --  This is a dummy procedure to share some GNULLI files\n+\n+private\n+\n+   type sigbit_array is array (1 .. 4) of unsigned;\n+   type sigset_t is record\n+      sa_sigbits : sigbit_array;\n+   end record;\n+   pragma Convention (C_Pass_By_Copy, sigset_t);\n+\n+   type pid_t is new unsigned;\n+\n+   type time_t is new long;\n+\n+   type timespec is record\n+      tv_sec       : time_t;\n+      tv_nsec      : long;\n+   end record;\n+   pragma Convention (C, timespec);\n+\n+   type clockid_t is new int;\n+   CLOCK_REALTIME : constant clockid_t := 0;\n+\n+   type struct_timeval is record\n+      tv_sec       : long;\n+      tv_usec      : long;\n+   end record;\n+   pragma Convention (C, struct_timeval);\n+\n+   type pthread_attr_t is record\n+      pt_attr_status          : int;\n+      pt_attr_stacksize       : size_t;\n+      pt_attr_stackaddr       : System.Address;\n+      pt_attr_detachstate     : int;\n+      pt_attr_contentionscope : int;\n+      pt_attr_inheritsched    : int;\n+      pt_attr_schedpolicy     : int;\n+      pt_attr_sched_param     : struct_sched_param;\n+      pt_attr_tlflags         : int;\n+   end record;\n+   pragma Convention (C, pthread_attr_t);\n+\n+   type pthread_condattr_t is record\n+      pt_condattr_status  : int;\n+      pt_condattr_pshared : int;\n+   end record;\n+   pragma Convention (C, pthread_condattr_t);\n+\n+   type pthread_mutexattr_t is record\n+      pt_mutexattr_status  : int;\n+      pt_mutexattr_pshared : int;\n+      pt_mutexattr_type    : int;\n+   end record;\n+   pragma Convention (C, pthread_mutexattr_t);\n+\n+   type thread_t is new long;\n+   type pthread_t is new thread_t;\n+\n+   type thrq_elt_t;\n+   type thrq_elt_t_ptr is access all thrq_elt_t;\n+\n+   type thrq_elt_t is record\n+      thrq_next : thrq_elt_t_ptr;\n+      thrq_prev : thrq_elt_t_ptr;\n+   end record;\n+   pragma Convention (C, thrq_elt_t);\n+\n+   type lwp_mutex_t is record\n+      wanted : char;\n+      lock   : unsigned_char;\n+   end record;\n+   pragma Convention (C, lwp_mutex_t);\n+   pragma Volatile (lwp_mutex_t);\n+\n+   type mutex_t is record\n+      m_lmutex    : lwp_mutex_t;\n+      m_sync_lock : lwp_mutex_t;\n+      m_type      : int;\n+      m_sleepq    : thrq_elt_t;\n+      filler1     : int;\n+      filler2     : int;\n+   end record;\n+   pragma Convention (C, mutex_t);\n+   pragma Volatile (mutex_t);\n+\n+   type pthread_mutex_t is record\n+      pt_mutex_mutex : mutex_t;\n+      pt_mutex_pid   : pid_t;\n+      pt_mutex_owner : thread_t;\n+      pt_mutex_depth : int;\n+      pt_mutex_attr  : pthread_mutexattr_t;\n+   end record;\n+   pragma Convention (C, pthread_mutex_t);\n+\n+   type lwp_cond_t is record\n+      wanted : char;\n+   end record;\n+   pragma Convention (C, lwp_cond_t);\n+   pragma Volatile (lwp_cond_t);\n+\n+   type cond_t is record\n+      c_lcond     : lwp_cond_t;\n+      c_sync_lock : lwp_mutex_t;\n+      c_type      : int;\n+      c_syncq     : thrq_elt_t;\n+   end record;\n+   pragma Convention (C, cond_t);\n+   pragma Volatile (cond_t);\n+\n+   type pthread_cond_t is record\n+      pt_cond_cond : cond_t;\n+      pt_cond_attr : pthread_condattr_t;\n+   end record;\n+   pragma Convention (C, pthread_cond_t);\n+\n+   type pthread_key_t is new unsigned;\n+\n+end System.OS_Interface;"}, {"sha": "19014f3fe1c073aad7ef1a01f33ea4094c12beef", "filename": "gcc/ada/52osinte.adb", "status": "added", "additions": 594, "deletions": 0, "changes": 594, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F52osinte.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F52osinte.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F52osinte.adb?ref=84481f762f0682e5f45b2f360446e1c7e333c880", "patch": "@@ -0,0 +1,594 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS               --\n+--                                                                          --\n+--                   S Y S T E M . O S _ I N T E R F A C E                  --\n+--                                                                          --\n+--                                  B o d y                                 --\n+--                                                                          --\n+--                              $Revision: 1.8 $\n+--                                                                          --\n+--           Copyright (C) 1999-2000 Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNARL is free software; you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion. GNARL is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNARL; see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNARL was developed by the GNARL team at Florida State University. It is --\n+-- now maintained by Ada Core Technologies Inc. in cooperation with Florida --\n+-- State University (http://www.gnat.com).                                  --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is a LynxOS (Native) version of this package\n+\n+pragma Polling (Off);\n+--  Turn off polling, we do not want ATC polling to take place during\n+--  tasking operations. It causes infinite loops and other problems.\n+\n+with Interfaces.C;\n+\n+package body System.OS_Interface is\n+\n+   use Interfaces.C;\n+\n+   -------------------\n+   -- clock_gettime --\n+   -------------------\n+\n+   function clock_gettime\n+     (clock_id : clockid_t;\n+      tp       : access timespec)\n+      return  int\n+   is\n+      function clock_gettime_base\n+        (clock_id : clockid_t;\n+         tp       : access timespec)\n+         return  int;\n+      pragma Import (C, clock_gettime_base, \"clock_gettime\");\n+\n+   begin\n+      if clock_gettime_base (clock_id, tp) /= 0 then\n+         return errno;\n+      end if;\n+\n+      return 0;\n+   end clock_gettime;\n+\n+   -----------------\n+   -- To_Duration --\n+   -----------------\n+\n+   function To_Duration (TS : timespec) return Duration is\n+   begin\n+      return Duration (TS.tv_sec) + Duration (TS.tv_nsec) / 10#1#E9;\n+   end To_Duration;\n+\n+   function To_Duration (TV : struct_timeval) return Duration is\n+   begin\n+      return Duration (TV.tv_sec) + Duration (TV.tv_usec) / 10#1#E6;\n+   end To_Duration;\n+\n+   -----------------\n+   -- To_Timespec --\n+   -----------------\n+\n+   function To_Timespec (D : Duration) return timespec is\n+      S : time_t;\n+      F : Duration;\n+\n+   begin\n+      S := time_t (Long_Long_Integer (D));\n+      F := D - Duration (S);\n+\n+      --  If F has negative value due to a round-up, adjust for positive F\n+      --  value.\n+\n+      if F < 0.0 then\n+         S := S - 1;\n+         F := F + 1.0;\n+      end if;\n+\n+      return timespec' (tv_sec => S,\n+        tv_nsec => long (Long_Long_Integer (F * 10#1#E9)));\n+   end To_Timespec;\n+\n+   ----------------\n+   -- To_Timeval --\n+   ----------------\n+\n+   function To_Timeval (D : Duration) return struct_timeval is\n+      S : time_t;\n+      F : Duration;\n+\n+   begin\n+      S := time_t (Long_Long_Integer (D));\n+      F := D - Duration (S);\n+\n+      --  If F has negative value due to a round-up, adjust for positive F\n+      --  value.\n+\n+      if F < 0.0 then\n+         S := S - 1;\n+         F := F + 1.0;\n+      end if;\n+\n+      return struct_timeval' (tv_sec => S,\n+        tv_usec => time_t (Long_Long_Integer (F * 10#1#E6)));\n+   end To_Timeval;\n+\n+   -------------------------\n+   -- POSIX.1c  Section 3 --\n+   -------------------------\n+\n+   function sigwait\n+     (set :  access sigset_t;\n+      sig :  access Signal)\n+      return int\n+   is\n+      function sigwait_base\n+        (set   : access sigset_t;\n+         value : System.Address)\n+        return Signal;\n+      pragma Import (C, sigwait_base, \"sigwait\");\n+\n+   begin\n+      sig.all := sigwait_base (set, Null_Address);\n+\n+      if sig.all = -1 then\n+         return errno;\n+      end if;\n+\n+      return 0;\n+   end sigwait;\n+\n+   --------------------------\n+   -- POSIX.1c  Section 11 --\n+   --------------------------\n+\n+   --  For all the following functions, LynxOS threads has the POSIX Draft 4\n+   --  begavior; it sets errno but the standard Posix requires it to be\n+   --  returned.\n+\n+   function pthread_mutexattr_init\n+     (attr : access pthread_mutexattr_t)\n+      return int\n+   is\n+      function pthread_mutexattr_create\n+        (attr : access pthread_mutexattr_t)\n+         return int;\n+      pragma Import (C, pthread_mutexattr_create, \"pthread_mutexattr_create\");\n+\n+   begin\n+      if pthread_mutexattr_create (attr) /= 0 then\n+         return errno;\n+      end if;\n+\n+      return 0;\n+   end pthread_mutexattr_init;\n+\n+   function pthread_mutexattr_destroy\n+     (attr : access pthread_mutexattr_t)\n+      return int\n+   is\n+      function pthread_mutexattr_delete\n+        (attr : access pthread_mutexattr_t)\n+         return int;\n+      pragma Import (C, pthread_mutexattr_delete, \"pthread_mutexattr_delete\");\n+\n+   begin\n+      if pthread_mutexattr_delete (attr) /= 0 then\n+         return errno;\n+      end if;\n+\n+      return 0;\n+   end pthread_mutexattr_destroy;\n+\n+   function pthread_mutex_init\n+     (mutex : access pthread_mutex_t;\n+      attr  : access pthread_mutexattr_t)\n+      return  int\n+   is\n+      function pthread_mutex_init_base\n+        (mutex : access pthread_mutex_t;\n+         attr  : pthread_mutexattr_t)\n+         return  int;\n+      pragma Import (C, pthread_mutex_init_base, \"pthread_mutex_init\");\n+\n+   begin\n+      if pthread_mutex_init_base (mutex, attr.all) /= 0 then\n+         return errno;\n+      end if;\n+\n+      return 0;\n+   end pthread_mutex_init;\n+\n+   function pthread_mutex_destroy\n+     (mutex : access pthread_mutex_t)\n+      return  int\n+   is\n+      function pthread_mutex_destroy_base\n+        (mutex : access pthread_mutex_t)\n+         return  int;\n+      pragma Import (C, pthread_mutex_destroy_base, \"pthread_mutex_destroy\");\n+\n+   begin\n+      if pthread_mutex_destroy_base (mutex) /= 0 then\n+         return errno;\n+      end if;\n+\n+      return 0;\n+   end pthread_mutex_destroy;\n+\n+   function pthread_mutex_lock\n+     (mutex : access pthread_mutex_t)\n+      return  int\n+   is\n+      function pthread_mutex_lock_base\n+        (mutex : access pthread_mutex_t)\n+         return  int;\n+      pragma Import (C, pthread_mutex_lock_base, \"pthread_mutex_lock\");\n+\n+   begin\n+      if pthread_mutex_lock_base (mutex) /= 0 then\n+         return errno;\n+      end if;\n+\n+      return 0;\n+   end pthread_mutex_lock;\n+\n+   function pthread_mutex_unlock\n+     (mutex : access pthread_mutex_t)\n+      return  int\n+   is\n+      function pthread_mutex_unlock_base\n+        (mutex : access pthread_mutex_t)\n+         return  int;\n+      pragma Import (C, pthread_mutex_unlock_base, \"pthread_mutex_unlock\");\n+\n+   begin\n+      if pthread_mutex_unlock_base (mutex) /= 0 then\n+         return errno;\n+      end if;\n+\n+      return 0;\n+   end pthread_mutex_unlock;\n+\n+   function pthread_condattr_init\n+     (attr : access pthread_condattr_t)\n+      return int\n+   is\n+      function pthread_condattr_create\n+        (attr : access pthread_condattr_t)\n+         return int;\n+      pragma Import (C, pthread_condattr_create, \"pthread_condattr_create\");\n+\n+   begin\n+      if pthread_condattr_create (attr) /= 0 then\n+         return errno;\n+      end if;\n+\n+      return 0;\n+   end pthread_condattr_init;\n+\n+   function pthread_condattr_destroy\n+     (attr : access pthread_condattr_t)\n+      return int\n+   is\n+      function pthread_condattr_delete\n+        (attr : access pthread_condattr_t)\n+         return int;\n+      pragma Import (C, pthread_condattr_delete, \"pthread_condattr_delete\");\n+\n+   begin\n+      if pthread_condattr_delete (attr) /= 0 then\n+         return errno;\n+      end if;\n+\n+      return 0;\n+   end pthread_condattr_destroy;\n+\n+   function pthread_cond_init\n+     (cond : access pthread_cond_t;\n+      attr : access pthread_condattr_t)\n+      return int\n+   is\n+      function pthread_cond_init_base\n+        (cond : access pthread_cond_t;\n+         attr : pthread_condattr_t)\n+         return int;\n+      pragma Import (C, pthread_cond_init_base, \"pthread_cond_init\");\n+\n+   begin\n+      if pthread_cond_init_base (cond, attr.all) /= 0 then\n+         return errno;\n+      end if;\n+\n+      return 0;\n+   end pthread_cond_init;\n+\n+   function pthread_cond_destroy\n+     (cond : access pthread_cond_t)\n+      return int\n+   is\n+      function pthread_cond_destroy_base\n+        (cond : access pthread_cond_t)\n+         return int;\n+      pragma Import (C, pthread_cond_destroy_base, \"pthread_cond_destroy\");\n+\n+   begin\n+      if pthread_cond_destroy_base (cond) /= 0 then\n+         return errno;\n+      end if;\n+\n+      return 0;\n+   end pthread_cond_destroy;\n+\n+   function pthread_cond_signal\n+     (cond : access pthread_cond_t)\n+      return int\n+   is\n+      function pthread_cond_signal_base\n+        (cond : access pthread_cond_t)\n+         return int;\n+      pragma Import (C, pthread_cond_signal_base, \"pthread_cond_signal\");\n+\n+   begin\n+      if pthread_cond_signal_base (cond) /= 0 then\n+         return errno;\n+      end if;\n+\n+      return 0;\n+   end pthread_cond_signal;\n+\n+   function pthread_cond_wait\n+     (cond  : access pthread_cond_t;\n+      mutex : access pthread_mutex_t)\n+      return  int\n+   is\n+      function pthread_cond_wait_base\n+        (cond  : access pthread_cond_t;\n+         mutex : access pthread_mutex_t)\n+         return  int;\n+      pragma Import (C, pthread_cond_wait_base, \"pthread_cond_wait\");\n+\n+   begin\n+      if pthread_cond_wait_base (cond, mutex) /= 0 then\n+         return errno;\n+      end if;\n+\n+      return 0;\n+   end pthread_cond_wait;\n+\n+   function pthread_cond_timedwait\n+     (cond    : access pthread_cond_t;\n+      mutex   : access pthread_mutex_t;\n+      reltime : access timespec) return int\n+   is\n+      function pthread_cond_timedwait_base\n+        (cond    : access pthread_cond_t;\n+         mutex   : access pthread_mutex_t;\n+         reltime : access timespec) return int;\n+      pragma Import (C, pthread_cond_timedwait_base, \"pthread_cond_timedwait\");\n+\n+   begin\n+      if pthread_cond_timedwait_base (cond, mutex, reltime) /= 0 then\n+         if errno = EAGAIN then\n+            return ETIMEDOUT;\n+         end if;\n+\n+         return errno;\n+      end if;\n+\n+      return 0;\n+   end pthread_cond_timedwait;\n+\n+   --------------------------\n+   -- POSIX.1c  Section 13 --\n+   --------------------------\n+\n+   function pthread_setschedparam\n+     (thread : pthread_t;\n+      policy : int;\n+      param  : access struct_sched_param)\n+      return   int\n+   is\n+      function pthread_setscheduler\n+        (thread : pthread_t;\n+         policy : int;\n+         prio   : int)\n+         return   int;\n+      pragma Import (C, pthread_setscheduler, \"pthread_setscheduler\");\n+\n+   begin\n+      if pthread_setscheduler (thread, policy, param.sched_priority) = -1 then\n+         return errno;\n+      end if;\n+\n+      return 0;\n+   end pthread_setschedparam;\n+\n+   function pthread_mutexattr_setprotocol\n+     (attr     : access pthread_mutexattr_t;\n+      protocol : int)\n+      return     int\n+   is\n+   begin\n+      return 0;\n+   end pthread_mutexattr_setprotocol;\n+\n+   function pthread_mutexattr_setprioceiling\n+     (attr        : access pthread_mutexattr_t;\n+      prioceiling : int)\n+      return        int\n+   is\n+   begin\n+      return 0;\n+   end pthread_mutexattr_setprioceiling;\n+\n+   function pthread_attr_setscope\n+     (attr            : access pthread_attr_t;\n+      contentionscope : int)\n+      return            int\n+   is\n+   begin\n+      return 0;\n+   end pthread_attr_setscope;\n+\n+   function sched_yield return int is\n+      procedure pthread_yield;\n+      pragma Import (C, pthread_yield, \"pthread_yield\");\n+\n+   begin\n+      pthread_yield;\n+      return 0;\n+   end sched_yield;\n+\n+   -----------------------------\n+   --  P1003.1c - Section 16  --\n+   -----------------------------\n+\n+   function pthread_attr_setdetachstate\n+     (attr        : access pthread_attr_t;\n+      detachstate : int)\n+      return        int\n+   is\n+   begin\n+      return 0;\n+   end pthread_attr_setdetachstate;\n+\n+   function pthread_create\n+     (thread        : access pthread_t;\n+      attributes    : access pthread_attr_t;\n+      start_routine : Thread_Body;\n+      arg           : System.Address)\n+      return          int\n+   is\n+      --  The LynxOS pthread_create doesn't seems to work.\n+      --  Workaround : We're using st_new instead.\n+      --\n+      --   function pthread_create_base\n+      --     (thread        : access pthread_t;\n+      --      attributes    : pthread_attr_t;\n+      --      start_routine : Thread_Body;\n+      --      arg           : System.Address)\n+      --      return          int;\n+      --   pragma Import (C, pthread_create_base, \"pthread_create\");\n+\n+      St : aliased st_t := attributes.st;\n+\n+      function st_new\n+        (start_routine : Thread_Body;\n+         arg           : System.Address;\n+         attributes    : access st_t;\n+         thread        : access pthread_t)\n+         return          int;\n+      pragma Import (C, st_new, \"st_new\");\n+\n+   begin\n+      --  Following code would be used if above commented function worked\n+\n+      --   if pthread_create_base\n+      --        (thread, attributes.all, start_routine, arg) /= 0 then\n+\n+      if st_new (start_routine, arg, St'Access, thread) /= 0 then\n+         return errno;\n+      end if;\n+\n+      return 0;\n+   end pthread_create;\n+\n+   function pthread_detach (thread : pthread_t) return int is\n+      aliased_thread : aliased pthread_t := thread;\n+\n+      function pthread_detach_base (thread : access pthread_t) return int;\n+      pragma Import (C, pthread_detach_base, \"pthread_detach\");\n+\n+   begin\n+      if pthread_detach_base (aliased_thread'Access) /= 0 then\n+         return errno;\n+      end if;\n+\n+      return 0;\n+   end pthread_detach;\n+\n+   --------------------------\n+   -- POSIX.1c  Section 17 --\n+   --------------------------\n+\n+   function pthread_setspecific\n+     (key   : pthread_key_t;\n+      value : System.Address)\n+      return  int\n+   is\n+      function pthread_setspecific_base\n+        (key   : pthread_key_t;\n+         value : System.Address)\n+         return  int;\n+      pragma Import (C, pthread_setspecific_base, \"pthread_setspecific\");\n+\n+   begin\n+      if pthread_setspecific_base (key, value) /= 0 then\n+         return errno;\n+      end if;\n+\n+      return 0;\n+   end pthread_setspecific;\n+\n+   function pthread_getspecific (key : pthread_key_t) return System.Address is\n+      procedure pthread_getspecific_base\n+        (key   : pthread_key_t;\n+         value : access System.Address);\n+      pragma Import (C, pthread_getspecific_base, \"pthread_getspecific\");\n+\n+      value : aliased System.Address := System.Null_Address;\n+\n+   begin\n+      pthread_getspecific_base (key, value'Unchecked_Access);\n+      return value;\n+   end pthread_getspecific;\n+\n+   function Get_Stack_Base (thread : pthread_t) return Address is\n+   begin\n+      return Null_Address;\n+   end Get_Stack_Base;\n+\n+   function pthread_key_create\n+     (key        : access pthread_key_t;\n+      destructor : destructor_pointer)\n+      return       int\n+   is\n+      function pthread_keycreate\n+        (key        : access pthread_key_t;\n+         destructor : destructor_pointer)\n+         return       int;\n+      pragma Import (C, pthread_keycreate, \"pthread_keycreate\");\n+\n+   begin\n+      if pthread_keycreate (key, destructor) /= 0 then\n+         return errno;\n+      end if;\n+\n+      return 0;\n+   end pthread_key_create;\n+\n+   procedure pthread_init is\n+   begin\n+      null;\n+   end pthread_init;\n+\n+end System.OS_Interface;"}, {"sha": "5986e55cf380eb30ea942ce380b5bfa2b4a7f4a1", "filename": "gcc/ada/52osinte.ads", "status": "added", "additions": 556, "deletions": 0, "changes": 556, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F52osinte.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F52osinte.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F52osinte.ads?ref=84481f762f0682e5f45b2f360446e1c7e333c880", "patch": "@@ -0,0 +1,556 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS               --\n+--                                                                          --\n+--                   S Y S T E M . O S _ I N T E R F A C E                  --\n+--                                                                          --\n+--                                  S p e c                                 --\n+--                                                                          --\n+--                             $Revision: 1.14 $\n+--                                                                          --\n+--          Copyright (C) 1999-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNARL is free software; you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion. GNARL is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNARL; see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNARL was developed by the GNARL team at Florida State University. It is --\n+-- now maintained by Ada Core Technologies Inc. in cooperation with Florida --\n+-- State University (http://www.gnat.com).                                  --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is a LynxOS (Native) version of this package.\n+\n+--  This package encapsulates all direct interfaces to OS services\n+--  that are needed by children of System.\n+\n+--  PLEASE DO NOT add any with-clauses to this package\n+--  or remove the pragma Elaborate_Body.\n+--  It is designed to be a bottom-level (leaf) package.\n+\n+with Interfaces.C;\n+package System.OS_Interface is\n+   pragma Preelaborate;\n+\n+   pragma Linker_Options (\"-mthreads\");\n+\n+   subtype int            is Interfaces.C.int;\n+   subtype char           is Interfaces.C.char;\n+   subtype short          is Interfaces.C.short;\n+   subtype long           is Interfaces.C.long;\n+   subtype unsigned       is Interfaces.C.unsigned;\n+   subtype unsigned_short is Interfaces.C.unsigned_short;\n+   subtype unsigned_long  is Interfaces.C.unsigned_long;\n+   subtype unsigned_char  is Interfaces.C.unsigned_char;\n+   subtype plain_char     is Interfaces.C.plain_char;\n+   subtype size_t         is Interfaces.C.size_t;\n+\n+   -----------\n+   -- Errno --\n+   -----------\n+\n+   function errno return int;\n+   pragma Import (C, errno, \"__get_errno\");\n+\n+   EAGAIN    : constant := 11;\n+   EINTR     : constant := 4;\n+   EINVAL    : constant := 22;\n+   ENOMEM    : constant := 12;\n+   ETIMEDOUT : constant := 60;\n+\n+   -------------\n+   -- Signals --\n+   -------------\n+\n+   Max_Interrupt : constant := 63;\n+   type Signal is new int range 0 .. Max_Interrupt;\n+   for Signal'Size use int'Size;\n+\n+   SIGHUP      : constant := 1; --  hangup\n+   SIGINT      : constant := 2; --  interrupt (rubout)\n+   SIGQUIT     : constant := 3; --  quit (ASCD FS)\n+   SIGILL      : constant := 4; --  illegal instruction (not reset)\n+   SIGTRAP     : constant := 5; --  trace trap (not reset)\n+   SIGBRK      : constant := 6; --  break\n+   SIGIOT      : constant := 6; --  IOT instruction\n+   SIGABRT     : constant := 6; --  used by abort, replace SIGIOT in the future\n+   SIGCORE     : constant := 7; --  kill with core dump\n+   SIGEMT      : constant := 7; --  EMT instruction\n+   SIGFPE      : constant := 8; --  floating point exception\n+   SIGKILL     : constant := 9; --  kill (cannot be caught or ignored)\n+   SIGBUS      : constant := 10; --  bus error\n+   SIGSEGV     : constant := 11; --  segmentation violation\n+   SIGSYS      : constant := 12; --  bad argument to system call\n+   SIGPIPE     : constant := 13; --  write on a pipe with no one to read it\n+   SIGALRM     : constant := 14; --  alarm clock\n+   SIGTERM     : constant := 15; --  software termination signal from kill\n+   SIGURG      : constant := 16; --  urgent condition on IO channel\n+   SIGSTOP     : constant := 17; --  stop (cannot be caught or ignored)\n+   SIGTSTP     : constant := 18; --  user stop requested from tty\n+   SIGCONT     : constant := 19; --  stopped process has been continued\n+   SIGCLD      : constant := 20; --  alias for SIGCHLD\n+   SIGCHLD     : constant := 20; --  child status change\n+   SIGTTIN     : constant := 21; --  background tty read attempted\n+   SIGTTOU     : constant := 22; --  background tty write attempted\n+   SIGIO       : constant := 23; --  I/O possible (Solaris SIGPOLL alias)\n+   SIGPOLL     : constant := 23; --  pollable event occurred\n+   SIGXCPU     : constant := 24; --  CPU time limit exceeded\n+   SIGXFSZ     : constant := 25; --  filesize limit exceeded\n+   SIGVTALRM   : constant := 26; --  virtual timer expired\n+   SIGPROF     : constant := 27; --  profiling timer expired\n+   SIGWINCH    : constant := 28; --  window size change\n+   SIGLOST     : constant := 29; --  SUN 4.1 compatibility\n+   SIGUSR1     : constant := 30; --  user defined signal 1\n+   SIGUSR2     : constant := 31; --  user defined signal 2\n+   SIGPRIO     : constant := 32; --  sent to a process with its priority or\n+                                 --  group is changed\n+\n+   SIGADAABORT : constant := SIGABRT;\n+   --  Change this if you want to use another signal for task abort.\n+   --  SIGTERM might be a good one.\n+\n+   type Signal_Set is array (Natural range <>) of Signal;\n+\n+   Unmasked    : constant Signal_Set :=\n+     (SIGTRAP, SIGTTIN, SIGTTOU, SIGTSTP, SIGPROF);\n+   Reserved    : constant Signal_Set := (SIGABRT, SIGKILL, SIGSTOP, SIGPRIO);\n+\n+   type sigset_t is private;\n+\n+   function sigaddset (set : access sigset_t; sig : Signal) return int;\n+   pragma Import (C, sigaddset, \"sigaddset\");\n+\n+   function sigdelset (set : access sigset_t; sig : Signal) return int;\n+   pragma Import (C, sigdelset, \"sigdelset\");\n+\n+   function sigfillset (set : access sigset_t) return int;\n+   pragma Import (C, sigfillset, \"sigfillset\");\n+\n+   function sigismember (set : access sigset_t; sig : Signal) return int;\n+   pragma Import (C, sigismember, \"sigismember\");\n+\n+   function sigemptyset (set : access sigset_t) return int;\n+   pragma Import (C, sigemptyset, \"sigemptyset\");\n+\n+   type struct_sigaction is record\n+      sa_handler : System.Address;\n+      sa_mask    : sigset_t;\n+      sa_flags   : int;\n+   end record;\n+   pragma Convention (C, struct_sigaction);\n+   type struct_sigaction_ptr is access all struct_sigaction;\n+\n+   SIG_BLOCK   : constant := 0;\n+   SIG_UNBLOCK : constant := 1;\n+   SIG_SETMASK : constant := 2;\n+\n+   SIG_DFL : constant := 0;\n+   SIG_IGN : constant := 1;\n+\n+   function sigaction\n+     (sig  : Signal;\n+      act  : struct_sigaction_ptr;\n+      oact : struct_sigaction_ptr) return int;\n+   pragma Import (C, sigaction, \"sigaction\");\n+\n+   ----------\n+   -- Time --\n+   ----------\n+\n+   Time_Slice_Supported : constant Boolean := True;\n+   --  Indicates wether time slicing is supported\n+\n+   type timespec is private;\n+\n+   type clockid_t is private;\n+\n+   CLOCK_REALTIME : constant clockid_t;\n+\n+   function clock_gettime\n+     (clock_id : clockid_t;\n+      tp       : access timespec) return int;\n+   pragma Inline (clock_gettime);\n+   --  LynxOS has non standard clock_gettime\n+\n+   function To_Duration (TS : timespec) return Duration;\n+   pragma Inline (To_Duration);\n+\n+   function To_Timespec (D : Duration) return timespec;\n+   pragma Inline (To_Timespec);\n+\n+   type struct_timezone is record\n+      tz_minuteswest : int;\n+      tz_dsttime     : int;\n+   end record;\n+   pragma Convention (C, struct_timezone);\n+   type struct_timezone_ptr is access all struct_timezone;\n+\n+   type struct_timeval is private;\n+   --  This is needed on systems that do not have clock_gettime()\n+   --  but do have gettimeofday().\n+\n+   function To_Duration (TV : struct_timeval) return Duration;\n+   pragma Inline (To_Duration);\n+\n+   function To_Timeval (D : Duration) return struct_timeval;\n+   pragma Inline (To_Timeval);\n+\n+   -------------------------\n+   -- Priority Scheduling --\n+   -------------------------\n+\n+   SCHED_FIFO  : constant := 16#00200000#;\n+   SCHED_RR    : constant := 16#00100000#;\n+   SCHED_OTHER : constant := 16#00400000#;\n+\n+   -------------\n+   -- Process --\n+   -------------\n+\n+   type pid_t is private;\n+\n+   function kill (pid : pid_t; sig : Signal) return int;\n+   pragma Import (C, kill, \"kill\");\n+\n+   function getpid return pid_t;\n+   pragma Import (C, getpid, \"getpid\");\n+\n+   ---------\n+   -- LWP --\n+   ---------\n+\n+   function lwp_self return System.Address;\n+   --  lwp_self does not exist on this thread library, revert to pthread_self\n+   --  which is the closest approximation (with getpid). This function is\n+   --  needed to share 7staprop.adb across POSIX-like targets.\n+   pragma Import (C, lwp_self, \"pthread_self\");\n+\n+   -------------\n+   -- Threads --\n+   -------------\n+\n+   type Thread_Body is access\n+     function (arg : System.Address) return System.Address;\n+   type pthread_t           is private;\n+   subtype Thread_Id        is pthread_t;\n+\n+   type pthread_mutex_t     is limited private;\n+   type pthread_cond_t      is limited private;\n+   type st_t                is limited private;\n+   type pthread_attr_t      is limited private;\n+   type pthread_mutexattr_t is limited private;\n+   type pthread_condattr_t  is limited private;\n+   type pthread_key_t       is private;\n+\n+   PTHREAD_CREATE_DETACHED : constant := 0;\n+\n+   -----------\n+   -- Stack --\n+   -----------\n+\n+   Stack_Base_Available : constant Boolean := False;\n+   --  Indicates wether the stack base is available on this target.\n+\n+   function Get_Stack_Base (thread : pthread_t) return Address;\n+   pragma Inline (Get_Stack_Base);\n+   --  returns the stack base of the specified thread.\n+   --  Only call this function when Stack_Base_Available is True.\n+\n+   function Get_Page_Size return size_t;\n+   function Get_Page_Size return Address;\n+   pragma Import (C, Get_Page_Size, \"getpagesize\");\n+   --  returns the size of a page, or 0 if this is not relevant on this\n+   --  target\n+\n+   PROT_NONE  : constant := 0;\n+   PROT_READ  : constant := 1;\n+   PROT_WRITE : constant := 2;\n+   PROT_EXEC  : constant := 4;\n+   PROT_USER  : constant := 8;\n+   PROT_ALL   : constant := PROT_READ + PROT_WRITE + PROT_EXEC + PROT_USER;\n+\n+   PROT_ON    : constant := PROT_READ;\n+   PROT_OFF   : constant := PROT_ALL;\n+\n+   function mprotect (addr : Address; len : size_t; prot : int) return int;\n+   pragma Import (C, mprotect);\n+\n+   -------------------------\n+   -- POSIX.1c  Section 3 --\n+   -------------------------\n+\n+   function sigwait\n+     (set : access sigset_t;\n+      sig : access Signal) return int;\n+   pragma Inline (sigwait);\n+   --  LynxOS has non standard sigwait\n+\n+   function pthread_kill (thread : pthread_t; sig : Signal) return int;\n+   pragma Import (C, pthread_kill, \"pthread_kill\");\n+\n+   type sigset_t_ptr is access all sigset_t;\n+\n+   function pthread_sigmask\n+     (how  : int;\n+      set  : sigset_t_ptr;\n+      oset : sigset_t_ptr) return int;\n+   pragma Import (C, pthread_sigmask, \"sigprocmask\");\n+\n+   --------------------------\n+   -- POSIX.1c  Section 11 --\n+   --------------------------\n+\n+   function pthread_mutexattr_init\n+     (attr : access pthread_mutexattr_t) return int;\n+   pragma Inline (pthread_mutexattr_init);\n+   --  LynxOS has a nonstandard pthread_mutexattr_init\n+\n+   function pthread_mutexattr_destroy\n+     (attr : access pthread_mutexattr_t) return int;\n+   pragma Inline (pthread_mutexattr_destroy);\n+   --  Lynxos has a nonstandard pthread_mutexattr_destroy\n+\n+   function pthread_mutex_init\n+     (mutex : access pthread_mutex_t;\n+      attr  : access pthread_mutexattr_t) return int;\n+   pragma Inline (pthread_mutex_init);\n+   --  LynxOS has a nonstandard pthread_mutex_init\n+\n+   function pthread_mutex_destroy (mutex : access pthread_mutex_t) return int;\n+   pragma Inline (pthread_mutex_destroy);\n+   --  LynxOS has a nonstandard pthread_mutex_destroy\n+\n+   function pthread_mutex_lock (mutex : access pthread_mutex_t) return int;\n+   pragma Inline (pthread_mutex_lock);\n+   --  LynxOS has a nonstandard pthread_mutex_lock\n+\n+   function pthread_mutex_unlock (mutex : access pthread_mutex_t) return int;\n+   pragma Inline (pthread_mutex_unlock);\n+   --  LynxOS has a nonstandard pthread_mutex_unlock\n+\n+   function pthread_condattr_init\n+     (attr : access pthread_condattr_t) return int;\n+   pragma Inline (pthread_condattr_init);\n+   --  LynxOS has a nonstandard pthread_condattr_init\n+\n+   function pthread_condattr_destroy\n+     (attr : access pthread_condattr_t) return int;\n+   pragma Inline (pthread_condattr_destroy);\n+   --  LynxOS has a nonstandard pthread_condattr_destroy\n+\n+   function pthread_cond_init\n+     (cond : access pthread_cond_t;\n+      attr : access pthread_condattr_t) return int;\n+   pragma Inline (pthread_cond_init);\n+   --  LynxOS has a non standard pthread_cond_init\n+\n+   function pthread_cond_destroy (cond : access pthread_cond_t) return int;\n+   pragma Inline (pthread_cond_destroy);\n+   --  LynxOS has a nonstandard pthread_cond_destroy\n+\n+   function pthread_cond_signal (cond : access pthread_cond_t) return int;\n+   pragma Inline (pthread_cond_signal);\n+   --  LynxOS has a nonstandard pthread_cond_signal\n+\n+   function pthread_cond_wait\n+     (cond  : access pthread_cond_t;\n+      mutex : access pthread_mutex_t) return int;\n+   pragma Inline (pthread_cond_wait);\n+   --  LynxOS has a nonstandard pthread_cond_wait\n+\n+   function pthread_cond_timedwait\n+     (cond    : access pthread_cond_t;\n+      mutex   : access pthread_mutex_t;\n+      reltime : access timespec) return int;\n+   pragma Inline (pthread_cond_timedwait);\n+   --  LynxOS has a nonstandard pthrad_cond_timedwait\n+\n+   Relative_Timed_Wait : constant Boolean := True;\n+   --  pthread_cond_timedwait requires a relative delay time\n+\n+   --------------------------\n+   -- POSIX.1c  Section 13 --\n+   --------------------------\n+\n+   PTHREAD_PRIO_NONE    : constant := 0;\n+   PTHREAD_PRIO_INHERIT : constant := 0;\n+   PTHREAD_PRIO_PROTECT : constant := 0;\n+\n+   type struct_sched_param is record\n+      sched_priority : int;  --  scheduling priority\n+   end record;\n+\n+   function pthread_setschedparam\n+     (thread : pthread_t;\n+      policy : int;\n+      param  : access struct_sched_param) return int;\n+   pragma Inline (pthread_setschedparam);\n+   --  LynxOS doesn't have pthread_setschedparam.\n+   --  Instead, use pthread_setscheduler\n+\n+   function pthread_mutexattr_setprotocol\n+     (attr     : access pthread_mutexattr_t;\n+      protocol : int) return int;\n+   pragma Inline (pthread_mutexattr_setprotocol);\n+   --  LynxOS doesn't have pthread_mutexattr_setprotocol\n+\n+   function pthread_mutexattr_setprioceiling\n+     (attr     : access pthread_mutexattr_t;\n+      prioceiling : int) return int;\n+   pragma Inline (pthread_mutexattr_setprioceiling);\n+   --  LynxOS doesn't have pthread_mutexattr_setprioceiling\n+\n+   function pthread_attr_setscope\n+     (attr            : access pthread_attr_t;\n+      contentionscope : int) return int;\n+   --  LynxOS doesn't have pthread_attr_setscope: all threads have system scope\n+   pragma Inline (pthread_attr_setscope);\n+\n+   function pthread_attr_setschedpolicy\n+     (attr   : access pthread_attr_t;\n+      policy : int) return int;\n+   pragma Import (C, pthread_attr_setschedpolicy, \"pthread_attr_setsched\");\n+\n+   function sched_yield return int;\n+   --   pragma Import (C, sched_yield, \"sched_yield\");\n+   pragma Inline (sched_yield);\n+\n+   ---------------------------\n+   -- P1003.1c - Section 16 --\n+   ---------------------------\n+\n+   function pthread_attr_init (attributes : access pthread_attr_t) return int;\n+   pragma Import (C, pthread_attr_init, \"pthread_attr_create\");\n+\n+   function pthread_attr_destroy\n+     (attributes : access pthread_attr_t) return int;\n+   pragma Import (C, pthread_attr_destroy, \"pthread_attr_delete\");\n+\n+   function pthread_attr_setdetachstate\n+     (attr        : access pthread_attr_t;\n+      detachstate : int) return int;\n+   pragma Inline (pthread_attr_setdetachstate);\n+   --  LynxOS doesn't have pthread_attr_setdetachstate\n+\n+   function pthread_attr_setstacksize\n+     (attr      : access pthread_attr_t;\n+      stacksize : size_t) return int;\n+   pragma Import (C, pthread_attr_setstacksize, \"pthread_attr_setstacksize\");\n+\n+   function pthread_create\n+     (thread        : access pthread_t;\n+      attributes    : access pthread_attr_t;\n+      start_routine : Thread_Body;\n+      arg           : System.Address) return int;\n+   pragma Inline (pthread_create);\n+   --  LynxOS has a non standard pthread_create\n+\n+   procedure pthread_exit (status : System.Address);\n+   pragma Import (C, pthread_exit, \"pthread_exit\");\n+\n+   function pthread_self return pthread_t;\n+   pragma Import (C, pthread_self, \"pthread_self\");\n+\n+   --------------------------\n+   -- POSIX.1c  Section 17 --\n+   --------------------------\n+\n+   function pthread_setspecific\n+     (key   : pthread_key_t;\n+      value : System.Address) return int;\n+   pragma Inline (pthread_setspecific);\n+   --  LynxOS has a non standard pthread_setspecific\n+\n+   function pthread_getspecific (key : pthread_key_t) return System.Address;\n+   pragma Inline (pthread_getspecific);\n+   --  LynxOS has a non standard pthread_getspecific\n+\n+   type destructor_pointer is access procedure (arg : System.Address);\n+\n+   function pthread_key_create\n+     (key        : access pthread_key_t;\n+      destructor : destructor_pointer) return int;\n+   pragma Inline (pthread_key_create);\n+   --  LynxOS has a non standard pthread_keycreate\n+\n+   procedure pthread_init;\n+   --  This is a dummy procedure to share some GNULLI files\n+\n+private\n+\n+   type sigbit_array is array (1 .. 2) of long;\n+   type sigset_t is record\n+      sa_sigbits : sigbit_array;\n+   end record;\n+   pragma Convention (C_Pass_By_Copy, sigset_t);\n+\n+   type pid_t is new long;\n+\n+   type time_t is new long;\n+\n+   type timespec is record\n+      tv_sec  : time_t;\n+      tv_nsec : long;\n+   end record;\n+   pragma Convention (C, timespec);\n+\n+   type clockid_t is new unsigned_char;\n+   CLOCK_REALTIME : constant clockid_t := 0;\n+\n+   type struct_timeval is record\n+      tv_sec  : time_t;\n+      tv_usec : time_t;\n+   end record;\n+   pragma Convention (C, struct_timeval);\n+\n+   type st_t is record\n+      stksize      : int;\n+      prio         : int;\n+      inheritsched : int;\n+      state        : int;\n+      sched        : int;\n+   end record;\n+   pragma Convention (C, st_t);\n+\n+   type pthread_attr_t is record\n+      st                 : st_t;\n+      pthread_attr_scope : int;  --  ignored\n+   end record;\n+   pragma Convention (C, pthread_attr_t);\n+\n+   type pthread_condattr_t is new int;\n+\n+   type pthread_mutexattr_t is new int;\n+\n+   type tid_t is new short;\n+   type pthread_t is new tid_t;\n+\n+   type synch_ptr is access all pthread_mutex_t;\n+   type pthread_mutex_t is record\n+      w_count   : int;\n+      mut_owner : int;\n+      id        : unsigned;\n+      next      : synch_ptr;\n+   end record;\n+   pragma Convention (C, pthread_mutex_t);\n+\n+   type pthread_cond_t is new pthread_mutex_t;\n+\n+   type pthread_key_t is new int;\n+\n+end System.OS_Interface;"}, {"sha": "0ba9d6a5e6cfefbb01bcf2a18e736a6136f04f0f", "filename": "gcc/ada/52system.ads", "status": "added", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F52system.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F52system.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F52system.ads?ref=84481f762f0682e5f45b2f360446e1c7e333c880", "patch": "@@ -0,0 +1,151 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                        GNAT RUN-TIME COMPONENTS                          --\n+--                                                                          --\n+--                               S Y S T E M                                --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                         (LynxOS PPC/x86 Version)\n+--                                                                          --\n+--                            $Revision: 1.4 $\n+--                                                                          --\n+--          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+package System is\n+pragma Pure (System);\n+--  Note that we take advantage of the implementation permission to\n+--  make this unit Pure instead of Preelaborable, see RM 13.7(36)\n+\n+   type Name is (SYSTEM_NAME_GNAT);\n+   System_Name : constant Name := SYSTEM_NAME_GNAT;\n+\n+   --  System-Dependent Named Numbers\n+\n+   Min_Int               : constant := Long_Long_Integer'First;\n+   Max_Int               : constant := Long_Long_Integer'Last;\n+\n+   Max_Binary_Modulus    : constant := 2 ** Long_Long_Integer'Size;\n+   Max_Nonbinary_Modulus : constant := Integer'Last;\n+\n+   Max_Base_Digits       : constant := Long_Long_Float'Digits;\n+   Max_Digits            : constant := Long_Long_Float'Digits;\n+\n+   Max_Mantissa          : constant := 63;\n+   Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);\n+\n+   Tick                  : constant := Standard'Tick;\n+\n+   --  Storage-related Declarations\n+\n+   type Address is private;\n+   Null_Address : constant Address;\n+\n+   Storage_Unit : constant := Standard'Storage_Unit;\n+   Word_Size    : constant := Standard'Word_Size;\n+   Memory_Size  : constant := 2 ** Standard'Address_Size;\n+\n+   --  Address comparison\n+\n+   function \"<\"  (Left, Right : Address) return Boolean;\n+   function \"<=\" (Left, Right : Address) return Boolean;\n+   function \">\"  (Left, Right : Address) return Boolean;\n+   function \">=\" (Left, Right : Address) return Boolean;\n+   function \"=\"  (Left, Right : Address) return Boolean;\n+\n+   pragma Import (Intrinsic, \"<\");\n+   pragma Import (Intrinsic, \"<=\");\n+   pragma Import (Intrinsic, \">\");\n+   pragma Import (Intrinsic, \">=\");\n+   pragma Import (Intrinsic, \"=\");\n+\n+   --  Other System-Dependent Declarations\n+\n+   type Bit_Order is (High_Order_First, Low_Order_First);\n+   Default_Bit_Order : constant Bit_Order :=\n+                         Bit_Order'Val (Standard'Default_Bit_Order);\n+\n+   --  Priority-related Declarations (RM D.1)\n+\n+   Max_Priority : constant Positive := 30;\n+\n+   Max_Interrupt_Priority : constant Positive := 31;\n+\n+   subtype Any_Priority is Integer\n+     range 0 .. Standard'Max_Interrupt_Priority;\n+\n+   subtype Priority is Any_Priority\n+     range 0 .. Standard'Max_Priority;\n+\n+   --  Functional notation is needed in the following to avoid visibility\n+   --  problems when this package is compiled through rtsfind in the middle\n+   --  of another compilation.\n+\n+   subtype Interrupt_Priority is Any_Priority\n+     range\n+       Standard.\"+\" (Standard'Max_Priority,  1) ..\n+         Standard'Max_Interrupt_Priority;\n+\n+   Default_Priority : constant Priority :=\n+     Standard.\"/\" (Standard.\"+\" (Priority'First, Priority'Last), 2);\n+\n+private\n+\n+   type Address is mod Memory_Size;\n+   Null_Address : constant Address := 0;\n+\n+   --------------------------------------\n+   -- System Implementation Parameters --\n+   --------------------------------------\n+\n+   --  These parameters provide information about the target that is used\n+   --  by the compiler. They are in the private part of System, where they\n+   --  can be accessed using the special circuitry in the Targparm unit\n+   --  whose source should be consulted for more detailed descriptions\n+   --  of the individual switch values.\n+\n+   AAMP                      : constant Boolean := False;\n+   Command_Line_Args         : constant Boolean := True;\n+   Denorm                    : constant Boolean := True;\n+   Frontend_Layout           : constant Boolean := False;\n+   Functions_Return_By_DSP   : constant Boolean := False;\n+   Long_Shifts_Inlined       : constant Boolean := True;\n+   High_Integrity_Mode       : constant Boolean := False;\n+   Machine_Overflows         : constant Boolean := False;\n+   Machine_Rounds            : constant Boolean := True;\n+   OpenVMS                   : constant Boolean := False;\n+   Signed_Zeros              : constant Boolean := True;\n+   Stack_Check_Default       : constant Boolean := False;\n+   Stack_Check_Probes        : constant Boolean := False;\n+   Use_Ada_Main_Program_Name : constant Boolean := False;\n+   ZCX_By_Default            : constant Boolean := False;\n+   GCC_ZCX_Support           : constant Boolean := False;\n+   Front_End_ZCX_Support     : constant Boolean := False;\n+\n+end System;"}, {"sha": "2b7c6d9d2ae0977775d77bced6c5dfc6d32c4676", "filename": "gcc/ada/53osinte.ads", "status": "added", "additions": 543, "deletions": 0, "changes": 543, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F53osinte.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F53osinte.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F53osinte.ads?ref=84481f762f0682e5f45b2f360446e1c7e333c880", "patch": "@@ -0,0 +1,543 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS               --\n+--                                                                          --\n+--                   S Y S T E M . O S _ I N T E R F A C E                  --\n+--                                                                          --\n+--                                  S p e c                                 --\n+--                                                                          --\n+--                             $Revision: 1.10 $\n+--                                                                          --\n+--          Copyright (C) 1999-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNARL is free software; you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion. GNARL is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNARL; see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNARL was developed by the GNARL team at Florida State University. It is --\n+-- now maintained by Ada Core Technologies Inc. in cooperation with Florida --\n+-- State University (http://www.gnat.com).                                  --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is a HPUX 11.0 (Native THREADS) version of this package.\n+\n+--  This package encapsulates all direct interfaces to OS services\n+--  that are needed by children of System.\n+\n+--  PLEASE DO NOT add any with-clauses to this package\n+--  or remove the pragma Elaborate_Body.\n+--  It is designed to be a bottom-level (leaf) package.\n+\n+with Interfaces.C;\n+package System.OS_Interface is\n+   pragma Preelaborate;\n+\n+   pragma Linker_Options (\"-lpthread\");\n+\n+   subtype int            is Interfaces.C.int;\n+   subtype short          is Interfaces.C.short;\n+   subtype long           is Interfaces.C.long;\n+   subtype unsigned       is Interfaces.C.unsigned;\n+   subtype unsigned_short is Interfaces.C.unsigned_short;\n+   subtype unsigned_long  is Interfaces.C.unsigned_long;\n+   subtype unsigned_char  is Interfaces.C.unsigned_char;\n+   subtype plain_char     is Interfaces.C.plain_char;\n+   subtype size_t         is Interfaces.C.size_t;\n+\n+   -----------\n+   -- Errno --\n+   -----------\n+\n+   function errno return int;\n+   pragma Import (C, errno, \"__get_errno\");\n+\n+   EAGAIN    : constant := 11;\n+   EINTR     : constant := 4;\n+   EINVAL    : constant := 22;\n+   ENOMEM    : constant := 12;\n+   ETIMEDOUT : constant := 238;\n+\n+   -------------\n+   -- Signals --\n+   -------------\n+\n+   Max_Interrupt : constant := 44;\n+   type Signal is new int range 0 .. Max_Interrupt;\n+   for Signal'Size use int'Size;\n+\n+   SIGHUP     : constant := 1; --  hangup\n+   SIGINT     : constant := 2; --  interrupt (rubout)\n+   SIGQUIT    : constant := 3; --  quit (ASCD FS)\n+   SIGILL     : constant := 4; --  illegal instruction (not reset)\n+   SIGTRAP    : constant := 5; --  trace trap (not reset)\n+   SIGIOT     : constant := 6; --  IOT instruction\n+   SIGABRT    : constant := 6; --  used by abort, replace SIGIOT in the  future\n+   SIGEMT     : constant := 7; --  EMT instruction\n+   SIGFPE     : constant := 8; --  floating point exception\n+   SIGKILL    : constant := 9; --  kill (cannot be caught or ignored)\n+   SIGBUS     : constant := 10; --  bus error\n+   SIGSEGV    : constant := 11; --  segmentation violation\n+   SIGSYS     : constant := 12; --  bad argument to system call\n+   SIGPIPE    : constant := 13; --  write on a pipe with no one to read it\n+   SIGALRM    : constant := 14; --  alarm clock\n+   SIGTERM    : constant := 15; --  software termination signal from kill\n+   SIGUSR1    : constant := 16; --  user defined signal 1\n+   SIGUSR2    : constant := 17; --  user defined signal 2\n+   SIGCLD     : constant := 18; --  alias for SIGCHLD\n+   SIGCHLD    : constant := 18; --  child status change\n+   SIGPWR     : constant := 19; --  power-fail restart\n+   SIGVTALRM  : constant := 20; --  virtual timer alarm\n+   SIGPROF    : constant := 21; --  profiling timer alarm\n+   SIGIO      : constant := 22; --  asynchronous I/O\n+   SIGPOLL    : constant := 22; --  pollable event occurred\n+   SIGWINCH   : constant := 23; --  window size change\n+   SIGSTOP    : constant := 24; --  stop (cannot be caught or ignored)\n+   SIGTSTP    : constant := 25; --  user stop requested from tty\n+   SIGCONT    : constant := 26; --  stopped process has been continued\n+   SIGTTIN    : constant := 27; --  background tty read attempted\n+   SIGTTOU    : constant := 28; --  background tty write attempted\n+   SIGURG     : constant := 29; --  urgent condition on IO channel\n+   SIGLOST    : constant := 30; --  remote lock lost  (NFS)\n+   SIGDIL     : constant := 32; --  DIL signal\n+   SIGXCPU    : constant := 33; --  CPU time limit exceeded (setrlimit)\n+   SIGXFSZ    : constant := 34; --  file size limit exceeded (setrlimit)\n+   SIGCANCEL  : constant := 35; --  used for pthread cancellation.\n+   SIGGFAULT  : constant := 36; --  Graphics framebuffer fault\n+\n+   SIGADAABORT : constant := SIGABRT;\n+   --  Note: on other targets, we usually use SIGABRT, but on HPUX, it\n+   --  appears that SIGABRT can't be used in sigwait(), so we use SIGTERM.\n+\n+   type Signal_Set is array (Natural range <>) of Signal;\n+\n+   Unmasked    : constant Signal_Set :=\n+     (SIGABRT, SIGPIPE, SIGBUS, SIGTRAP, SIGTTIN, SIGTTOU, SIGTSTP, SIGPROF,\n+      SIGALRM, SIGVTALRM, SIGIO, SIGCHLD);\n+\n+   Reserved    : constant Signal_Set := (SIGKILL, SIGSTOP);\n+\n+   type sigset_t is private;\n+\n+   function sigaddset (set : access sigset_t; sig : Signal) return int;\n+   pragma Import (C, sigaddset, \"sigaddset\");\n+\n+   function sigdelset (set : access sigset_t; sig : Signal) return int;\n+   pragma Import (C, sigdelset, \"sigdelset\");\n+\n+   function sigfillset (set : access sigset_t) return int;\n+   pragma Import (C, sigfillset, \"sigfillset\");\n+\n+   function sigismember (set : access sigset_t; sig : Signal) return int;\n+   pragma Import (C, sigismember, \"sigismember\");\n+\n+   function sigemptyset (set : access sigset_t) return int;\n+   pragma Import (C, sigemptyset, \"sigemptyset\");\n+\n+   type struct_sigaction is record\n+      sa_handler : System.Address;\n+      sa_mask    : sigset_t;\n+      sa_flags   : int;\n+   end record;\n+   pragma Convention (C, struct_sigaction);\n+   type struct_sigaction_ptr is access all struct_sigaction;\n+\n+   SIG_BLOCK   : constant := 0;\n+   SIG_UNBLOCK : constant := 1;\n+   SIG_SETMASK : constant := 2;\n+\n+   SIG_DFL : constant := 0;\n+   SIG_IGN : constant := 1;\n+\n+   function sigaction\n+     (sig  : Signal;\n+      act  : struct_sigaction_ptr;\n+      oact : struct_sigaction_ptr) return int;\n+   pragma Import (C, sigaction, \"sigaction\");\n+\n+   ----------\n+   -- Time --\n+   ----------\n+\n+   Time_Slice_Supported : constant Boolean := True;\n+   --  Indicates wether time slicing is supported\n+\n+   type timespec is private;\n+\n+   type clockid_t is private;\n+\n+   CLOCK_REALTIME : constant clockid_t;\n+\n+   function clock_gettime\n+     (clock_id : clockid_t;\n+      tp       : access timespec) return int;\n+   pragma Import (C, clock_gettime, \"clock_gettime\");\n+\n+   function To_Duration (TS : timespec) return Duration;\n+   pragma Inline (To_Duration);\n+\n+   function To_Timespec (D : Duration) return timespec;\n+   pragma Inline (To_Timespec);\n+\n+   type struct_timezone is record\n+      tz_minuteswest : int;\n+      tz_dsttime     : int;\n+   end record;\n+   pragma Convention (C, struct_timezone);\n+   type struct_timezone_ptr is access all struct_timezone;\n+\n+   type struct_timeval is private;\n+   --  This is needed on systems that do not have clock_gettime()\n+   --  but do have gettimeofday().\n+\n+   function To_Duration (TV : struct_timeval) return Duration;\n+   pragma Inline (To_Duration);\n+\n+   function To_Timeval (D : Duration) return struct_timeval;\n+   pragma Inline (To_Timeval);\n+\n+   -------------------------\n+   -- Priority Scheduling --\n+   -------------------------\n+\n+   SCHED_FIFO  : constant := 0;\n+   SCHED_RR    : constant := 1;\n+   SCHED_OTHER : constant := 2;\n+\n+   -------------\n+   -- Process --\n+   -------------\n+\n+   type pid_t is private;\n+\n+   function kill (pid : pid_t; sig : Signal) return int;\n+   pragma Import (C, kill, \"kill\");\n+\n+   function getpid return pid_t;\n+   pragma Import (C, getpid, \"getpid\");\n+\n+   ---------\n+   -- LWP --\n+   ---------\n+\n+   function lwp_self return System.Address;\n+   pragma Import (C, lwp_self, \"_lwp_self\");\n+\n+   -------------\n+   -- Threads --\n+   -------------\n+\n+   type Thread_Body is access\n+     function (arg : System.Address) return System.Address;\n+   type pthread_t           is private;\n+   subtype Thread_Id        is pthread_t;\n+\n+   type pthread_mutex_t     is limited private;\n+   type pthread_cond_t      is limited private;\n+   type pthread_attr_t      is limited private;\n+   type pthread_mutexattr_t is limited private;\n+   type pthread_condattr_t  is limited private;\n+   type pthread_key_t       is private;\n+\n+   PTHREAD_CREATE_DETACHED : constant := 16#de#;\n+\n+   -----------\n+   -- Stack --\n+   -----------\n+\n+   Stack_Base_Available : constant Boolean := False;\n+   --  Indicates wether the stack base is available on this target.\n+\n+   function Get_Stack_Base (thread : pthread_t) return Address;\n+   pragma Inline (Get_Stack_Base);\n+   --  returns the stack base of the specified thread.\n+   --  Only call this function when Stack_Base_Available is True.\n+\n+   function Get_Page_Size return size_t;\n+   function Get_Page_Size return Address;\n+   pragma Import (C, Get_Page_Size, \"getpagesize\");\n+   --  returns the size of a page, or 0 if this is not relevant on this\n+   --  target\n+\n+   PROT_NONE  : constant := 0;\n+   PROT_READ  : constant := 1;\n+   PROT_WRITE : constant := 2;\n+   PROT_EXEC  : constant := 4;\n+   PROT_ALL   : constant := PROT_READ + PROT_WRITE + PROT_EXEC;\n+\n+   PROT_ON    : constant := PROT_READ;\n+   PROT_OFF   : constant := PROT_ALL;\n+\n+   function mprotect (addr : Address; len : size_t; prot : int) return int;\n+   pragma Import (C, mprotect);\n+\n+   ---------------------------------------\n+   -- Nonstandard Thread Initialization --\n+   ---------------------------------------\n+\n+   procedure pthread_init;\n+   pragma Inline (pthread_init);\n+   --  This is a dummy procedure to share some GNULLI files\n+\n+   -------------------------\n+   -- POSIX.1c  Section 3 --\n+   -------------------------\n+\n+   function sigwait\n+     (set : access sigset_t;\n+      sig : access Signal) return int;\n+   pragma Import (C, sigwait, \"sigwait\");\n+\n+   function pthread_kill\n+     (thread : pthread_t;\n+      sig    : Signal) return int;\n+   pragma Import (C, pthread_kill, \"pthread_kill\");\n+\n+   type sigset_t_ptr is access all sigset_t;\n+\n+   function pthread_sigmask\n+     (how  : int;\n+      set  : sigset_t_ptr;\n+      oset : sigset_t_ptr) return int;\n+   pragma Import (C, pthread_sigmask, \"pthread_sigmask\");\n+\n+   --------------------------\n+   -- POSIX.1c  Section 11 --\n+   --------------------------\n+\n+   function pthread_mutexattr_init\n+     (attr : access pthread_mutexattr_t) return int;\n+   pragma Import (C, pthread_mutexattr_init, \"pthread_mutexattr_init\");\n+\n+   function pthread_mutexattr_destroy\n+     (attr : access pthread_mutexattr_t) return int;\n+   pragma Import (C, pthread_mutexattr_destroy, \"pthread_mutexattr_destroy\");\n+\n+   function pthread_mutex_init\n+     (mutex : access pthread_mutex_t;\n+      attr  : access pthread_mutexattr_t) return int;\n+   pragma Import (C, pthread_mutex_init, \"pthread_mutex_init\");\n+\n+   function pthread_mutex_destroy (mutex : access pthread_mutex_t) return int;\n+   pragma Import (C, pthread_mutex_destroy, \"pthread_mutex_destroy\");\n+\n+   function pthread_mutex_lock (mutex : access pthread_mutex_t) return int;\n+   pragma Import (C, pthread_mutex_lock, \"pthread_mutex_lock\");\n+\n+   function pthread_mutex_unlock (mutex : access pthread_mutex_t) return int;\n+   pragma Import (C, pthread_mutex_unlock, \"pthread_mutex_unlock\");\n+\n+   function pthread_condattr_init\n+     (attr : access pthread_condattr_t) return int;\n+   pragma Import (C, pthread_condattr_init, \"pthread_condattr_init\");\n+\n+   function pthread_condattr_destroy\n+     (attr : access pthread_condattr_t) return int;\n+   pragma Import (C, pthread_condattr_destroy, \"pthread_condattr_destroy\");\n+\n+   function pthread_cond_init\n+     (cond : access pthread_cond_t;\n+      attr : access pthread_condattr_t) return int;\n+   pragma Import (C, pthread_cond_init, \"pthread_cond_init\");\n+\n+   function pthread_cond_destroy (cond : access pthread_cond_t) return int;\n+   pragma Import (C, pthread_cond_destroy, \"pthread_cond_destroy\");\n+\n+   function pthread_cond_signal (cond : access pthread_cond_t) return int;\n+   pragma Import (C, pthread_cond_signal, \"pthread_cond_signal\");\n+\n+   function pthread_cond_wait\n+     (cond  : access pthread_cond_t;\n+      mutex : access pthread_mutex_t) return int;\n+   pragma Import (C, pthread_cond_wait, \"pthread_cond_wait\");\n+\n+   function pthread_cond_timedwait\n+     (cond    : access pthread_cond_t;\n+      mutex   : access pthread_mutex_t;\n+      abstime : access timespec) return int;\n+   pragma Import (C, pthread_cond_timedwait, \"pthread_cond_timedwait\");\n+\n+   Relative_Timed_Wait : constant Boolean := False;\n+   --  pthread_cond_timedwait requires an absolute delay time\n+\n+   ----------------------------\n+   --  POSIX.1c  Section 13  --\n+   ----------------------------\n+\n+   PTHREAD_PRIO_NONE    : constant := 16#100#;\n+   PTHREAD_PRIO_PROTECT : constant := 16#200#;\n+   PTHREAD_PRIO_INHERIT : constant := 16#400#;\n+\n+   function pthread_mutexattr_setprotocol\n+     (attr     : access pthread_mutexattr_t;\n+      protocol : int) return int;\n+   pragma Import (C, pthread_mutexattr_setprotocol);\n+\n+   function pthread_mutexattr_setprioceiling\n+     (attr     : access pthread_mutexattr_t;\n+      prioceiling : int) return int;\n+   pragma Import (C, pthread_mutexattr_setprioceiling);\n+\n+   type Array_7_Int is array (0 .. 6) of int;\n+   type struct_sched_param is record\n+      sched_priority : int;\n+      sched_reserved : Array_7_Int;\n+   end record;\n+\n+   function pthread_setschedparam\n+     (thread : pthread_t;\n+      policy : int;\n+      param  : access struct_sched_param)\n+     return int;\n+   pragma Import (C, pthread_setschedparam, \"pthread_setschedparam\");\n+\n+   function pthread_attr_setscope\n+     (attr            : access pthread_attr_t;\n+      contentionscope : int) return int;\n+   pragma Import (C, pthread_attr_setscope, \"pthread_attr_setscope\");\n+\n+   function pthread_attr_setinheritsched\n+     (attr         : access pthread_attr_t;\n+      inheritsched : int) return int;\n+   pragma Import (C, pthread_attr_setinheritsched);\n+\n+   function pthread_attr_setschedpolicy\n+     (attr   : access pthread_attr_t;\n+      policy : int) return int;\n+   pragma Import (C, pthread_attr_setschedpolicy);\n+\n+   function sched_yield return int;\n+   pragma Import (C, sched_yield, \"sched_yield\");\n+\n+   ---------------------------\n+   -- P1003.1c - Section 16 --\n+   ---------------------------\n+\n+   function pthread_attr_init\n+     (attributes : access pthread_attr_t) return int;\n+   pragma Import (C, pthread_attr_init, \"__pthread_attr_init_system\");\n+\n+   function pthread_attr_destroy\n+     (attributes : access pthread_attr_t) return int;\n+   pragma Import (C, pthread_attr_destroy, \"pthread_attr_destroy\");\n+\n+   function pthread_attr_setdetachstate\n+     (attr        : access pthread_attr_t;\n+      detachstate : int) return int;\n+   pragma Import (C, pthread_attr_setdetachstate);\n+\n+   function pthread_attr_setstacksize\n+     (attr      : access pthread_attr_t;\n+      stacksize : size_t) return int;\n+   pragma Import (C, pthread_attr_setstacksize, \"pthread_attr_setstacksize\");\n+\n+   function pthread_create\n+     (thread        : access pthread_t;\n+      attributes    : access pthread_attr_t;\n+      start_routine : Thread_Body;\n+      arg           : System.Address) return int;\n+   pragma Import (C, pthread_create, \"__pthread_create_system\");\n+\n+   procedure pthread_exit (status : System.Address);\n+   pragma Import (C, pthread_exit, \"pthread_exit\");\n+\n+   function pthread_self return pthread_t;\n+   pragma Import (C, pthread_self, \"pthread_self\");\n+\n+   --------------------------\n+   -- POSIX.1c  Section 17 --\n+   --------------------------\n+\n+   function pthread_setspecific\n+     (key   : pthread_key_t;\n+      value : System.Address) return int;\n+   pragma Import (C, pthread_setspecific, \"pthread_setspecific\");\n+\n+   function pthread_getspecific (key : pthread_key_t) return System.Address;\n+   pragma Import (C, pthread_getspecific, \"pthread_getspecific\");\n+\n+   type destructor_pointer is access procedure (arg : System.Address);\n+\n+   function pthread_key_create\n+     (key        : access pthread_key_t;\n+      destructor : destructor_pointer) return int;\n+   pragma Import (C, pthread_key_create, \"pthread_key_create\");\n+\n+private\n+\n+   type unsigned_int_array_8 is array (0 .. 7) of unsigned;\n+   type sigset_t is record\n+      sigset : unsigned_int_array_8;\n+   end record;\n+   pragma Convention (C_Pass_By_Copy, sigset_t);\n+\n+   type pid_t is new int;\n+\n+   type time_t is new long;\n+\n+   type timespec is record\n+      tv_sec  : time_t;\n+      tv_nsec : long;\n+   end record;\n+   pragma Convention (C, timespec);\n+\n+   type clockid_t is new int;\n+   CLOCK_REALTIME : constant clockid_t := 1;\n+\n+   type struct_timeval is record\n+      tv_sec  : time_t;\n+      tv_usec : time_t;\n+   end record;\n+   pragma Convention (C, struct_timeval);\n+\n+   type pthread_attr_t is new int;\n+   type pthread_condattr_t is new int;\n+   type pthread_mutexattr_t is new int;\n+   type pthread_t is new int;\n+\n+   type short_array is array (Natural range <>) of short;\n+   type int_array is array (Natural range <>) of int;\n+\n+   type pthread_mutex_t is record\n+      m_short  : short_array (0 .. 1);\n+      m_int    : int;\n+      m_int1   : int_array (0 .. 3);\n+      m_pad    : int;  --  needed for 32 bit ABI, but *not* for 64 bit\n+      m_ptr    : System.Address;\n+      m_int2   : int_array (0 .. 1);\n+      m_int3   : int_array (0 .. 3);\n+      m_short2 : short_array (0 .. 1);\n+      m_int4   : int_array (0 .. 4);\n+      m_int5   : int_array (0 .. 1);\n+   end record;\n+   pragma Convention (C, pthread_mutex_t);\n+\n+   type pthread_cond_t is record\n+      c_short : short_array (0 .. 1);\n+      c_int   : int;\n+      c_int1  : int_array (0 .. 3);\n+      m_pad   : int;  --  needed for 32 bit ABI, but *not* for 64 bit\n+      m_ptr   : System.Address;\n+      c_int2  : int_array (0 .. 1);\n+      c_int3  : int_array (0 .. 1);\n+      c_int4  : int_array (0 .. 1);\n+   end record;\n+   pragma Convention (C, pthread_cond_t);\n+\n+   type pthread_key_t is new int;\n+\n+end System.OS_Interface;"}, {"sha": "7737c064ac742a201f11f18dfb7a79a770d9536d", "filename": "gcc/ada/54osinte.ads", "status": "added", "additions": 534, "deletions": 0, "changes": 534, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F54osinte.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F54osinte.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F54osinte.ads?ref=84481f762f0682e5f45b2f360446e1c7e333c880", "patch": "@@ -0,0 +1,534 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS               --\n+--                                                                          --\n+--                   S Y S T E M . O S _ I N T E R F A C E                  --\n+--                                                                          --\n+--                                  S p e c                                 --\n+--                                                                          --\n+--                             $Revision: 1.6 $\n+--                                                                          --\n+--            Copyright (C) 2000-2001 Ada Core Technologies, Inc.           --\n+--                                                                          --\n+-- GNARL is free software; you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion. GNARL is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNARL; see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNARL was developed by the GNARL team at Florida State University. It is --\n+-- now maintained by Ada Core Technologies Inc. in cooperation with Florida --\n+-- State University (http://www.gnat.com).                                  --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is a Solaris (POSIX Threads) version of this package.\n+\n+--  This package encapsulates all direct interfaces to OS services\n+--  that are needed by children of System.\n+\n+--  PLEASE DO NOT add any with-clauses to this package\n+--  or remove the pragma Elaborate_Body.\n+--  It is designed to be a bottom-level (leaf) package.\n+\n+with Interfaces.C;\n+package System.OS_Interface is\n+   pragma Preelaborate;\n+\n+   pragma Linker_Options (\"-lposix4\");\n+   pragma Linker_Options (\"-lpthread\");\n+\n+   subtype int            is Interfaces.C.int;\n+   subtype short          is Interfaces.C.short;\n+   subtype long           is Interfaces.C.long;\n+   subtype unsigned       is Interfaces.C.unsigned;\n+   subtype unsigned_short is Interfaces.C.unsigned_short;\n+   subtype unsigned_long  is Interfaces.C.unsigned_long;\n+   subtype unsigned_char  is Interfaces.C.unsigned_char;\n+   subtype plain_char     is Interfaces.C.plain_char;\n+   subtype size_t         is Interfaces.C.size_t;\n+\n+   -----------\n+   -- Errno --\n+   -----------\n+\n+   function errno return int;\n+   pragma Import (C, errno, \"__get_errno\");\n+\n+   EAGAIN    : constant := 11;\n+   EINTR     : constant := 4;\n+   EINVAL    : constant := 22;\n+   ENOMEM    : constant := 12;\n+   ETIMEDOUT : constant := 145;\n+\n+   -------------\n+   -- Signals --\n+   -------------\n+\n+   Max_Interrupt : constant := 45;\n+   type Signal is new int range 0 .. Max_Interrupt;\n+   for Signal'Size use int'Size;\n+\n+   SIGHUP      : constant := 1; --  hangup\n+   SIGINT      : constant := 2; --  interrupt (rubout)\n+   SIGQUIT     : constant := 3; --  quit (ASCD FS)\n+   SIGILL      : constant := 4; --  illegal instruction (not reset)\n+   SIGTRAP     : constant := 5; --  trace trap (not reset)\n+   SIGIOT      : constant := 6; --  IOT instruction\n+   SIGABRT     : constant := 6; --  used by abort, replace SIGIOT in the future\n+   SIGEMT      : constant := 7; --  EMT instruction\n+   SIGFPE      : constant := 8; --  floating point exception\n+   SIGKILL     : constant := 9; --  kill (cannot be caught or ignored)\n+   SIGBUS      : constant := 10; --  bus error\n+   SIGSEGV     : constant := 11; --  segmentation violation\n+   SIGSYS      : constant := 12; --  bad argument to system call\n+   SIGPIPE     : constant := 13; --  write on a pipe with no one to read it\n+   SIGALRM     : constant := 14; --  alarm clock\n+   SIGTERM     : constant := 15; --  software termination signal from kill\n+   SIGUSR1     : constant := 16; --  user defined signal 1\n+   SIGUSR2     : constant := 17; --  user defined signal 2\n+   SIGCLD      : constant := 18; --  alias for SIGCHLD\n+   SIGCHLD     : constant := 18; --  child status change\n+   SIGPWR      : constant := 19; --  power-fail restart\n+   SIGWINCH    : constant := 20; --  window size change\n+   SIGURG      : constant := 21; --  urgent condition on IO channel\n+   SIGPOLL     : constant := 22; --  pollable event occurred\n+   SIGIO       : constant := 22; --  I/O possible (Solaris SIGPOLL alias)\n+   SIGSTOP     : constant := 23; --  stop (cannot be caught or ignored)\n+   SIGTSTP     : constant := 24; --  user stop requested from tty\n+   SIGCONT     : constant := 25; --  stopped process has been continued\n+   SIGTTIN     : constant := 26; --  background tty read attempted\n+   SIGTTOU     : constant := 27; --  background tty write attempted\n+   SIGVTALRM   : constant := 28; --  virtual timer expired\n+   SIGPROF     : constant := 29; --  profiling timer expired\n+   SIGXCPU     : constant := 30; --  CPU time limit exceeded\n+   SIGXFSZ     : constant := 31; --  filesize limit exceeded\n+   SIGWAITING  : constant := 32; --  process's lwps blocked (Solaris)\n+   SIGLWP      : constant := 33; --  used by thread library (Solaris)\n+   SIGFREEZE   : constant := 34; --  used by CPR (Solaris)\n+   SIGTHAW     : constant := 35; --  used by CPR (Solaris)\n+   SIGCANCEL   : constant := 36; --  thread cancellation signal (libthread)\n+\n+   SIGADAABORT : constant := SIGABRT;\n+\n+   type Signal_Set is array (Natural range <>) of Signal;\n+\n+   Unmasked    : constant Signal_Set := (SIGTRAP, SIGLWP, SIGPROF);\n+\n+   --  Following signals should not be disturbed.\n+   --  See c-posix-signals.c in FLORIST\n+\n+   Reserved    : constant Signal_Set :=\n+     (SIGKILL, SIGSTOP, SIGWAITING, SIGCANCEL);\n+\n+   type sigset_t is private;\n+\n+   function sigaddset (set : access sigset_t; sig : Signal) return int;\n+   pragma Import (C, sigaddset, \"sigaddset\");\n+\n+   function sigdelset (set : access sigset_t; sig : Signal) return int;\n+   pragma Import (C, sigdelset, \"sigdelset\");\n+\n+   function sigfillset (set : access sigset_t) return int;\n+   pragma Import (C, sigfillset, \"sigfillset\");\n+\n+   function sigismember (set : access sigset_t; sig : Signal) return int;\n+   pragma Import (C, sigismember, \"sigismember\");\n+\n+   function sigemptyset (set : access sigset_t) return int;\n+   pragma Import (C, sigemptyset, \"sigemptyset\");\n+\n+   type struct_sigaction is record\n+      sa_flags   : int;\n+      sa_handler : System.Address;\n+      sa_mask    : sigset_t;\n+      sa_resv1   : int;\n+      sa_resv2   : int;\n+   end record;\n+   pragma Convention (C, struct_sigaction);\n+   type struct_sigaction_ptr is access all struct_sigaction;\n+\n+   SIG_BLOCK   : constant := 1;\n+   SIG_UNBLOCK : constant := 2;\n+   SIG_SETMASK : constant := 3;\n+\n+   SIG_DFL : constant := 0;\n+   SIG_IGN : constant := 1;\n+\n+   function sigaction\n+     (sig  : Signal;\n+      act  : struct_sigaction_ptr;\n+      oact : struct_sigaction_ptr) return int;\n+   pragma Import (C, sigaction, \"sigaction\");\n+\n+   ----------\n+   -- Time --\n+   ----------\n+\n+   Time_Slice_Supported : constant Boolean := True;\n+   --  Indicates wether time slicing is supported\n+\n+   type timespec is private;\n+\n+   type clockid_t is private;\n+\n+   CLOCK_REALTIME : constant clockid_t;\n+\n+   function clock_gettime\n+     (clock_id : clockid_t;\n+      tp       : access timespec) return int;\n+   pragma Import (C, clock_gettime, \"clock_gettime\");\n+\n+   function To_Duration (TS : timespec) return Duration;\n+   pragma Inline (To_Duration);\n+\n+   function To_Timespec (D : Duration) return timespec;\n+   pragma Inline (To_Timespec);\n+\n+   type struct_timeval is private;\n+\n+   function To_Duration (TV : struct_timeval) return Duration;\n+   pragma Inline (To_Duration);\n+\n+   function To_Timeval (D : Duration) return struct_timeval;\n+   pragma Inline (To_Timeval);\n+\n+   -------------------------\n+   -- Priority Scheduling --\n+   -------------------------\n+\n+   SCHED_FIFO  : constant := 1;\n+   SCHED_RR    : constant := 2;\n+   SCHED_OTHER : constant := 0;\n+\n+   -------------\n+   -- Process --\n+   -------------\n+\n+   type pid_t is private;\n+\n+   function kill (pid : pid_t; sig : Signal) return int;\n+   pragma Import (C, kill, \"kill\");\n+\n+   function getpid return pid_t;\n+   pragma Import (C, getpid, \"getpid\");\n+\n+   ---------\n+   -- LWP --\n+   ---------\n+\n+   function lwp_self return System.Address;\n+   pragma Import (C, lwp_self, \"_lwp_self\");\n+\n+   -------------\n+   -- Threads --\n+   -------------\n+\n+   type Thread_Body is access\n+     function (arg : System.Address) return System.Address;\n+   type pthread_t           is private;\n+   subtype Thread_Id        is pthread_t;\n+\n+   type pthread_mutex_t     is limited private;\n+   type pthread_cond_t      is limited private;\n+   type pthread_attr_t      is limited private;\n+   type pthread_mutexattr_t is limited private;\n+   type pthread_condattr_t  is limited private;\n+   type pthread_key_t       is private;\n+\n+   PTHREAD_CREATE_DETACHED : constant := 16#40#;\n+\n+   -----------\n+   -- Stack --\n+   -----------\n+\n+   Stack_Base_Available : constant Boolean := False;\n+   --  Indicates wether the stack base is available on this target.\n+\n+   function Get_Stack_Base (thread : pthread_t) return Address;\n+   pragma Inline (Get_Stack_Base);\n+   --  returns the stack base of the specified thread.\n+   --  Only call this function when Stack_Base_Available is True.\n+\n+   function Get_Page_Size return size_t;\n+   function Get_Page_Size return Address;\n+   pragma Import (C, Get_Page_Size, \"getpagesize\");\n+   --  returns the size of a page, or 0 if this is not relevant on this\n+   --  target\n+\n+   PROT_NONE  : constant := 0;\n+   PROT_READ  : constant := 1;\n+   PROT_WRITE : constant := 2;\n+   PROT_EXEC  : constant := 4;\n+   PROT_ALL   : constant := PROT_READ + PROT_WRITE + PROT_EXEC;\n+\n+   PROT_ON    : constant := PROT_READ;\n+   PROT_OFF   : constant := PROT_ALL;\n+\n+   function mprotect (addr : Address; len : size_t; prot : int) return int;\n+   pragma Import (C, mprotect);\n+\n+   ---------------------------------------\n+   -- Nonstandard Thread Initialization --\n+   ---------------------------------------\n+\n+   procedure pthread_init;\n+   --  This is a dummy procedure to share some GNULLI files\n+\n+   -------------------------\n+   -- POSIX.1c  Section 3 --\n+   -------------------------\n+\n+   function sigwait\n+     (set : access sigset_t;\n+      sig : access Signal) return int;\n+   pragma Import (C, sigwait, \"sigwait\");\n+\n+   function pthread_kill\n+     (thread : pthread_t;\n+      sig    : Signal) return int;\n+   pragma Import (C, pthread_kill, \"pthread_kill\");\n+\n+   type sigset_t_ptr is access all sigset_t;\n+\n+   function pthread_sigmask\n+     (how  : int;\n+      set  : sigset_t_ptr;\n+      oset : sigset_t_ptr) return int;\n+   pragma Import (C, pthread_sigmask, \"pthread_sigmask\");\n+\n+   --------------------------\n+   -- POSIX.1c  Section 11 --\n+   --------------------------\n+\n+   function pthread_mutexattr_init\n+     (attr : access pthread_mutexattr_t) return int;\n+   pragma Import (C, pthread_mutexattr_init, \"pthread_mutexattr_init\");\n+\n+   function pthread_mutexattr_destroy\n+     (attr : access pthread_mutexattr_t) return int;\n+   pragma Import (C, pthread_mutexattr_destroy, \"pthread_mutexattr_destroy\");\n+\n+   function pthread_mutex_init\n+     (mutex : access pthread_mutex_t;\n+      attr  : access pthread_mutexattr_t) return int;\n+   pragma Import (C, pthread_mutex_init, \"pthread_mutex_init\");\n+\n+   function pthread_mutex_destroy (mutex : access pthread_mutex_t) return int;\n+   pragma Import (C, pthread_mutex_destroy, \"pthread_mutex_destroy\");\n+\n+   function pthread_mutex_lock (mutex : access pthread_mutex_t) return int;\n+   pragma Import (C, pthread_mutex_lock, \"pthread_mutex_lock\");\n+\n+   function pthread_mutex_unlock (mutex : access pthread_mutex_t) return int;\n+   pragma Import (C, pthread_mutex_unlock, \"pthread_mutex_unlock\");\n+\n+   function pthread_condattr_init\n+     (attr : access pthread_condattr_t) return int;\n+   pragma Import (C, pthread_condattr_init, \"pthread_condattr_init\");\n+\n+   function pthread_condattr_destroy\n+     (attr : access pthread_condattr_t) return int;\n+   pragma Import (C, pthread_condattr_destroy, \"pthread_condattr_destroy\");\n+\n+   function pthread_cond_init\n+     (cond : access pthread_cond_t;\n+      attr : access pthread_condattr_t) return int;\n+   pragma Import (C, pthread_cond_init, \"pthread_cond_init\");\n+\n+   function pthread_cond_destroy (cond : access pthread_cond_t) return int;\n+   pragma Import (C, pthread_cond_destroy, \"pthread_cond_destroy\");\n+\n+   function pthread_cond_signal (cond : access pthread_cond_t) return int;\n+   pragma Import (C, pthread_cond_signal, \"pthread_cond_signal\");\n+\n+   function pthread_cond_wait\n+     (cond  : access pthread_cond_t;\n+      mutex : access pthread_mutex_t) return int;\n+   pragma Import (C, pthread_cond_wait, \"pthread_cond_wait\");\n+\n+   function pthread_cond_timedwait\n+     (cond    : access pthread_cond_t;\n+      mutex   : access pthread_mutex_t;\n+      abstime : access timespec) return int;\n+   pragma Import (C, pthread_cond_timedwait, \"pthread_cond_timedwait\");\n+\n+   Relative_Timed_Wait : constant Boolean := False;\n+   --  pthread_cond_timedwait requires an absolute delay time\n+\n+   --------------------------\n+   -- POSIX.1c  Section 13 --\n+   --------------------------\n+\n+   PTHREAD_PRIO_NONE    : constant := 0;\n+   PTHREAD_PRIO_INHERIT : constant := 16#10#;\n+   PTHREAD_PRIO_PROTECT : constant := 16#20#;\n+\n+   function pthread_mutexattr_setprotocol\n+     (attr     : access pthread_mutexattr_t;\n+      protocol : int) return int;\n+   pragma Import (C, pthread_mutexattr_setprotocol);\n+\n+   function pthread_mutexattr_setprioceiling\n+     (attr        : access pthread_mutexattr_t;\n+      prioceiling : int) return int;\n+   pragma Import (C, pthread_mutexattr_setprioceiling);\n+\n+   type Array_8_Int is array (0 .. 7) of int;\n+   type struct_sched_param is record\n+      sched_priority : int;\n+      sched_pad      : Array_8_Int;\n+   end record;\n+\n+   function pthread_setschedparam\n+     (thread : pthread_t;\n+      policy : int;\n+      param  : access struct_sched_param) return int;\n+   pragma Import (C, pthread_setschedparam, \"pthread_setschedparam\");\n+\n+   function pthread_attr_setscope\n+     (attr            : access pthread_attr_t;\n+      contentionscope : int) return int;\n+   pragma Import (C, pthread_attr_setscope, \"pthread_attr_setscope\");\n+\n+   function pthread_attr_setinheritsched\n+     (attr         : access pthread_attr_t;\n+      inheritsched : int) return int;\n+   pragma Import (C, pthread_attr_setinheritsched);\n+\n+   function pthread_attr_setschedpolicy\n+     (attr   : access pthread_attr_t;\n+      policy : int) return int;\n+   pragma Import (C, pthread_attr_setschedpolicy);\n+\n+   function sched_yield return int;\n+   pragma Import (C, sched_yield, \"sched_yield\");\n+\n+   ---------------------------\n+   -- P1003.1c - Section 16 --\n+   ---------------------------\n+\n+   function pthread_attr_init (attributes : access pthread_attr_t) return int;\n+   pragma Import (C, pthread_attr_init, \"pthread_attr_init\");\n+\n+   function pthread_attr_destroy\n+     (attributes : access pthread_attr_t) return int;\n+   pragma Import (C, pthread_attr_destroy, \"pthread_attr_destroy\");\n+\n+   function pthread_attr_setdetachstate\n+     (attr        : access pthread_attr_t;\n+      detachstate : int) return int;\n+   pragma Import (C, pthread_attr_setdetachstate);\n+\n+   function pthread_attr_setstacksize\n+     (attr      : access pthread_attr_t;\n+      stacksize : size_t) return int;\n+   pragma Import (C, pthread_attr_setstacksize);\n+\n+   function pthread_create\n+     (thread        : access pthread_t;\n+      attributes    : access pthread_attr_t;\n+      start_routine : Thread_Body;\n+      arg           : System.Address) return int;\n+   pragma Import (C, pthread_create, \"pthread_create\");\n+\n+   procedure pthread_exit (status : System.Address);\n+   pragma Import (C, pthread_exit, \"pthread_exit\");\n+\n+   function pthread_self return pthread_t;\n+   pragma Import (C, pthread_self, \"pthread_self\");\n+\n+   --------------------------\n+   -- POSIX.1c  Section 17 --\n+   --------------------------\n+\n+   function pthread_setspecific\n+     (key   : pthread_key_t;\n+      value : System.Address) return int;\n+   pragma Import (C, pthread_setspecific, \"pthread_setspecific\");\n+\n+   function pthread_getspecific (key : pthread_key_t) return System.Address;\n+   pragma Import (C, pthread_getspecific, \"pthread_getspecific\");\n+\n+   type destructor_pointer is access procedure (arg : System.Address);\n+\n+   function pthread_key_create\n+     (key        : access pthread_key_t;\n+      destructor : destructor_pointer) return int;\n+   pragma Import (C, pthread_key_create, \"pthread_key_create\");\n+\n+private\n+\n+   type array_type_1 is array (Integer range 0 .. 3) of unsigned_long;\n+   type sigset_t is record\n+      X_X_sigbits  : array_type_1;\n+   end record;\n+   pragma Convention (C, sigset_t);\n+\n+   type pid_t is new long;\n+\n+   type time_t is new long;\n+\n+   type timespec is record\n+      tv_sec  : time_t;\n+      tv_nsec : long;\n+   end record;\n+   pragma Convention (C, timespec);\n+\n+   type clockid_t is new int;\n+   CLOCK_REALTIME : constant clockid_t := 0;\n+\n+   type struct_timeval is record\n+      tv_sec  : time_t;\n+      tv_usec : time_t;\n+   end record;\n+   pragma Convention (C, struct_timeval);\n+\n+   type pthread_attr_t is record\n+      pthread_attrp : System.Address;\n+   end record;\n+   pragma Convention (C, pthread_attr_t);\n+\n+   type pthread_condattr_t is record\n+      pthread_condattrp : System.Address;\n+   end record;\n+   pragma Convention (C, pthread_condattr_t);\n+\n+   type pthread_mutexattr_t is record\n+      pthread_mutexattrp : System.Address;\n+   end record;\n+   pragma Convention (C, pthread_mutexattr_t);\n+\n+   type pthread_t is new unsigned;\n+\n+   type uint64_t is mod 2 ** 64;\n+\n+   type pthread_mutex_t is record\n+      pthread_mutex_flags   : uint64_t;\n+      pthread_mutex_owner64 : uint64_t;\n+      pthread_mutex_data    : uint64_t;\n+   end record;\n+   pragma Convention (C, pthread_mutex_t);\n+   type pthread_mutex_t_ptr is access pthread_mutex_t;\n+\n+   type pthread_cond_t is record\n+      pthread_cond_flags : uint64_t;\n+      pthread_cond_data  : uint64_t;\n+   end record;\n+   pragma Convention (C, pthread_cond_t);\n+\n+   type pthread_key_t is new unsigned;\n+\n+end System.OS_Interface;"}, {"sha": "5eac869a0523bc7a67de2067ec4731ba5c36a39d", "filename": "gcc/ada/5amastop.adb", "status": "added", "additions": 174, "deletions": 0, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5amastop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5amastop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5amastop.adb?ref=84481f762f0682e5f45b2f360446e1c7e333c880", "patch": "@@ -0,0 +1,174 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                     SYSTEM.MACHINE_STATE_OPERATIONS                      --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                         (Version for Alpha/Dec Unix)                     --\n+--                                                                          --\n+--                            $Revision: 1.5 $\n+--                                                                          --\n+--           Copyright (C) 1999-2001 Ada Core Technologies, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This version of System.Machine_State_Operations is for use on\n+--  Alpha systems running DEC Unix.\n+\n+with System.Memory;\n+\n+package body System.Machine_State_Operations is\n+\n+   use System.Exceptions;\n+\n+   pragma Linker_Options (\"-lexc\");\n+   --  Needed for definitions of exc_capture_context and exc_virtual_unwind\n+\n+   ----------------------------\n+   -- Allocate_Machine_State --\n+   ----------------------------\n+\n+   function Allocate_Machine_State return Machine_State is\n+      use System.Storage_Elements;\n+\n+      function c_machine_state_length return Storage_Offset;\n+      pragma Import (C, c_machine_state_length, \"__gnat_machine_state_length\");\n+\n+   begin\n+      return Machine_State\n+        (Memory.Alloc (Memory.size_t (c_machine_state_length)));\n+   end Allocate_Machine_State;\n+\n+   -------------------\n+   -- Enter_Handler --\n+   -------------------\n+\n+   procedure Enter_Handler (M : Machine_State; Handler : Handler_Loc) is\n+      procedure c_enter_handler (M : Machine_State; Handler : Handler_Loc);\n+      pragma Import (C, c_enter_handler, \"__gnat_enter_handler\");\n+\n+   begin\n+      c_enter_handler (M, Handler);\n+   end Enter_Handler;\n+\n+   ----------------\n+   -- Fetch_Code --\n+   ----------------\n+\n+   function Fetch_Code (Loc : Code_Loc) return Code_Loc is\n+   begin\n+      return Loc;\n+   end Fetch_Code;\n+\n+   ------------------------\n+   -- Free_Machine_State --\n+   ------------------------\n+\n+   procedure Free_Machine_State (M : in out Machine_State) is\n+      procedure Gnat_Free (M : in Machine_State);\n+      pragma Import (C, Gnat_Free, \"__gnat_free\");\n+\n+   begin\n+      Gnat_Free (M);\n+      M := Machine_State (Null_Address);\n+   end Free_Machine_State;\n+\n+   ------------------\n+   -- Get_Code_Loc --\n+   ------------------\n+\n+   function Get_Code_Loc (M : Machine_State) return Code_Loc is\n+      Asm_Call_Size : constant := 4;\n+\n+      function c_get_code_loc (M : Machine_State) return Code_Loc;\n+      pragma Import (C, c_get_code_loc, \"__gnat_get_code_loc\");\n+\n+      --  Code_Loc returned by c_get_code_loc is the return point but here we\n+      --  want Get_Code_Loc to return the call point. Under DEC Unix a call\n+      --  asm instruction takes 4 bytes. So we must remove this value from\n+      --  c_get_code_loc to have the call point.\n+\n+   begin\n+      return c_get_code_loc (M) - Asm_Call_Size;\n+   end Get_Code_Loc;\n+\n+   --------------------------\n+   -- Machine_State_Length --\n+   --------------------------\n+\n+   function Machine_State_Length\n+     return System.Storage_Elements.Storage_Offset\n+   is\n+      use System.Storage_Elements;\n+\n+      function c_machine_state_length return Storage_Offset;\n+      pragma Import (C, c_machine_state_length, \"__gnat_machine_state_length\");\n+\n+   begin\n+      return c_machine_state_length;\n+   end Machine_State_Length;\n+\n+   ---------------\n+   -- Pop_Frame --\n+   ---------------\n+\n+   procedure Pop_Frame\n+     (M    : Machine_State;\n+      Info : Subprogram_Info_Type)\n+   is\n+      procedure exc_virtual_unwind\n+        (Fcn  : System.Address;\n+         M    : Machine_State);\n+      pragma Import (C, exc_virtual_unwind, \"exc_virtual_unwind\");\n+\n+   begin\n+      exc_virtual_unwind (System.Null_Address, M);\n+   end Pop_Frame;\n+\n+   -----------------------\n+   -- Set_Machine_State --\n+   -----------------------\n+\n+   procedure Set_Machine_State (M : Machine_State) is\n+      procedure c_capture_context (M : Machine_State);\n+      pragma Import (C, c_capture_context, \"exc_capture_context\");\n+\n+   begin\n+      c_capture_context (M);\n+      Pop_Frame (M, System.Null_Address);\n+   end Set_Machine_State;\n+\n+   ------------------------------\n+   -- Set_Signal_Machine_State --\n+   ------------------------------\n+\n+   procedure Set_Signal_Machine_State\n+     (M       : Machine_State;\n+      Context : System.Address) is\n+   begin\n+      null;\n+   end Set_Signal_Machine_State;\n+\n+end System.Machine_State_Operations;"}, {"sha": "4637b6a6f55135efdccd46cd944ffdd132c957de", "filename": "gcc/ada/5aosinte.adb", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5aosinte.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5aosinte.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5aosinte.adb?ref=84481f762f0682e5f45b2f360446e1c7e333c880", "patch": "@@ -0,0 +1,116 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS               --\n+--                                                                          --\n+--                   S Y S T E M . O S _ I N T E R F A C E                  --\n+--                                                                          --\n+--                                  B o d y                                 --\n+--                                                                          --\n+--                             $Revision: 1.15 $\n+--                                                                          --\n+--              Copyright (C) 1991-2001 Florida State University            --\n+--                                                                          --\n+-- GNARL is free software; you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion. GNARL is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNARL; see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNARL was developed by the GNARL team at Florida State University. It is --\n+-- now maintained by Ada Core Technologies Inc. in cooperation with Florida --\n+-- State University (http://www.gnat.com).                                  --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is the DEC Unix and IRIX version of this package.\n+\n+--  This package encapsulates all direct interfaces to OS services\n+--  that are needed by children of System.\n+\n+pragma Polling (Off);\n+--  Turn off polling, we do not want ATC polling to take place during\n+--  tasking operations. It causes infinite loops and other problems.\n+\n+with Interfaces.C; use Interfaces.C;\n+package body System.OS_Interface is\n+\n+   ------------------\n+   -- pthread_init --\n+   ------------------\n+\n+   procedure pthread_init is\n+   begin\n+      null;\n+   end pthread_init;\n+\n+   -----------------\n+   -- To_Duration --\n+   -----------------\n+\n+   function To_Duration (TS : timespec) return Duration is\n+   begin\n+      return Duration (TS.tv_sec) + Duration (TS.tv_nsec) / 10#1#E9;\n+   end To_Duration;\n+\n+   function To_Duration (TV : struct_timeval) return Duration is\n+   begin\n+      return Duration (TV.tv_sec) + Duration (TV.tv_usec) / 10#1#E6;\n+   end To_Duration;\n+\n+   -----------------\n+   -- To_Timespec --\n+   -----------------\n+\n+   function To_Timespec (D : Duration) return timespec is\n+      S : time_t;\n+      F : Duration;\n+\n+   begin\n+      S := time_t (Long_Long_Integer (D));\n+      F := D - Duration (S);\n+\n+      --  If F has negative value due to a round-up, adjust for positive F\n+      --  value.\n+\n+      if F < 0.0 then\n+         S := S - 1;\n+         F := F + 1.0;\n+      end if;\n+\n+      return timespec' (tv_sec => S,\n+        tv_nsec => long (Long_Long_Integer (F * 10#1#E9)));\n+   end To_Timespec;\n+\n+   function To_Timeval (D : Duration) return struct_timeval is\n+      S : time_t;\n+      F : Duration;\n+\n+   begin\n+      S := time_t (Long_Long_Integer (D));\n+      F := D - Duration (S);\n+\n+      --  If F has negative value due to a round-up, adjust for positive F\n+      --  value.\n+\n+      if F < 0.0 then\n+         S := S - 1;\n+         F := F + 1.0;\n+      end if;\n+\n+      return struct_timeval' (tv_sec => S,\n+        tv_usec => time_t (Long_Long_Integer (F * 10#1#E6)));\n+   end To_Timeval;\n+\n+end System.OS_Interface;"}, {"sha": "8a1ee3b4a392ca461c051d37492b8be695991396", "filename": "gcc/ada/5aosinte.ads", "status": "added", "additions": 535, "deletions": 0, "changes": 535, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5aosinte.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5aosinte.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5aosinte.ads?ref=84481f762f0682e5f45b2f360446e1c7e333c880", "patch": "@@ -0,0 +1,535 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS               --\n+--                                                                          --\n+--                   S Y S T E M . O S _ I N T E R F A C E                  --\n+--                                                                          --\n+--                                  S p e c                                 --\n+--                                                                          --\n+--                             $Revision: 1.23 $\n+--                                                                          --\n+--           Copyright (C) 1998-2001 Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNARL is free software; you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion. GNARL is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNARL; see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNARL was developed by the GNARL team at Florida State University. It is --\n+-- now maintained by Ada Core Technologies Inc. in cooperation with Florida --\n+-- State University (http://www.gnat.com).                                  --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is the DEC Unix 4.0/5.1 version of this package.\n+\n+--  This package encapsulates all direct interfaces to OS services\n+--  that are needed by children of System.\n+\n+--  PLEASE DO NOT add any with-clauses to this package\n+--  It is designed to be a bottom-level (leaf) package.\n+\n+with Interfaces.C;\n+package System.OS_Interface is\n+   pragma Preelaborate;\n+\n+   pragma Linker_Options (\"-lpthread\");\n+   pragma Linker_Options (\"-lmach\");\n+   pragma Linker_Options (\"-lexc\");\n+   pragma Linker_Options (\"-lrt\");\n+\n+   subtype int            is Interfaces.C.int;\n+   subtype short          is Interfaces.C.short;\n+   subtype long           is Interfaces.C.long;\n+   subtype unsigned       is Interfaces.C.unsigned;\n+   subtype unsigned_short is Interfaces.C.unsigned_short;\n+   subtype unsigned_long  is Interfaces.C.unsigned_long;\n+   subtype unsigned_char  is Interfaces.C.unsigned_char;\n+   subtype plain_char     is Interfaces.C.plain_char;\n+   subtype size_t         is Interfaces.C.size_t;\n+   subtype char_array     is Interfaces.C.char_array;\n+\n+   -----------\n+   -- Errno --\n+   -----------\n+\n+   function errno return int;\n+   pragma Import (C, errno, \"_Geterrno\");\n+\n+   EAGAIN    : constant := 35;\n+   EINTR     : constant := 4;\n+   EINVAL    : constant := 22;\n+   ENOMEM    : constant := 12;\n+   ETIMEDOUT : constant := 60;\n+\n+   -------------\n+   -- Signals --\n+   -------------\n+\n+   Max_Interrupt : constant := 48;\n+   type Signal is new int range 0 .. Max_Interrupt;\n+   for Signal'Size use int'Size;\n+\n+   SIGHUP     : constant := 1; --  hangup\n+   SIGINT     : constant := 2; --  interrupt (rubout)\n+   SIGQUIT    : constant := 3; --  quit (ASCD FS)\n+   SIGILL     : constant := 4; --  illegal instruction (not reset)\n+   SIGTRAP    : constant := 5; --  trace trap (not reset)\n+   SIGABRT    : constant := 6; --  used by abort, replace SIGIOT in the  future\n+   SIGIOT     : constant := 6; --  abort (terminate) process\n+   SIGLOST    : constant := 6; --  old BSD signal ??\n+   SIGEMT     : constant := 7; --  EMT instruction\n+   SIGFPE     : constant := 8; --  floating point exception\n+   SIGKILL    : constant := 9; --  kill (cannot be caught or ignored)\n+   SIGBUS     : constant := 10; --  bus error\n+   SIGSEGV    : constant := 11; --  segmentation violation\n+   SIGSYS     : constant := 12; --  bad argument to system call\n+   SIGPIPE    : constant := 13; --  write on a pipe with no one to read it\n+   SIGALRM    : constant := 14; --  alarm clock\n+   SIGTERM    : constant := 15; --  software termination signal from kill\n+   SIGURG     : constant := 16; --  urgent condition on IO channel\n+   SIGIOINT   : constant := 16; --  printer to backend error signal\n+   SIGSTOP    : constant := 17; --  stop (cannot be caught or ignored)\n+   SIGTSTP    : constant := 18; --  user stop requested from tty\n+   SIGCONT    : constant := 19; --  stopped process has been continued\n+   SIGCHLD    : constant := 20; --  child status change\n+   SIGTTIN    : constant := 21; --  background tty read attempted\n+   SIGTTOU    : constant := 22; --  background tty write attempted\n+   SIGPOLL    : constant := 23; --  I/O possible, or completed\n+   SIGIO      : constant := 23; --  STREAMS version of SIGPOLL\n+   SIGAIO     : constant := 23; --  base lan i/o\n+   SIGPTY     : constant := 23; --  pty i/o\n+   SIGXCPU    : constant := 24; --  CPU time limit exceeded\n+   SIGXFSZ    : constant := 25; --  filesize limit exceeded\n+   SIGVTALRM  : constant := 26; --  virtual timer expired\n+   SIGPROF    : constant := 27; --  profiling timer expired\n+   SIGWINCH   : constant := 28; --  window size change\n+   SIGINFO    : constant := 29; --  information request\n+   SIGPWR     : constant := 29; --  Power Fail/Restart -- SVID3/SVR4\n+   SIGUSR1    : constant := 30; --  user defined signal 1\n+   SIGUSR2    : constant := 31; --  user defined signal 2\n+   SIGRESV    : constant := 32; --  reserved by Digital for future use\n+\n+   SIGADAABORT : constant := SIGABRT;\n+\n+   type Signal_Set is array (Natural range <>) of Signal;\n+\n+   Unmasked    : constant Signal_Set := (0 .. 0 => SIGTRAP);\n+   Reserved    : constant Signal_Set := (SIGALRM, SIGABRT, SIGKILL, SIGSTOP);\n+\n+   type sigset_t is private;\n+\n+   function sigaddset (set : access sigset_t; sig : Signal) return int;\n+   pragma Import (C, sigaddset);\n+\n+   function sigdelset (set : access sigset_t; sig : Signal) return int;\n+   pragma Import (C, sigdelset);\n+\n+   function sigfillset (set : access sigset_t) return int;\n+   pragma Import (C, sigfillset);\n+\n+   function sigismember (set : access sigset_t; sig : Signal) return int;\n+   pragma Import (C, sigismember);\n+\n+   function sigemptyset (set : access sigset_t) return int;\n+   pragma Import (C, sigemptyset);\n+\n+   type union_type_3 is new String (1 .. 116);\n+   type siginfo_t is record\n+      si_signo     : int;\n+      si_errno     : int;\n+      si_code      : int;\n+      X_data       : union_type_3;\n+   end record;\n+   for siginfo_t'Size use 8 * 128;\n+   pragma Convention (C, siginfo_t);\n+\n+   type struct_sigaction is record\n+      sa_handler : System.Address;\n+      sa_mask    : sigset_t;\n+      sa_flags   : int;\n+      sa_signo   : int;\n+   end record;\n+   pragma Convention (C, struct_sigaction);\n+   type struct_sigaction_ptr is access all struct_sigaction;\n+\n+   SIG_BLOCK   : constant := 1;\n+   SIG_UNBLOCK : constant := 2;\n+   SIG_SETMASK : constant := 3;\n+\n+   SIG_DFL : constant := 0;\n+   SIG_IGN : constant := 1;\n+\n+   SA_NODEFER : constant := 8;\n+   SA_SIGINFO : constant := 16#40#;\n+\n+   function sigaction\n+     (sig  : Signal;\n+      act  : struct_sigaction_ptr;\n+      oact : struct_sigaction_ptr) return int;\n+   pragma Import (C, sigaction);\n+\n+   ----------\n+   -- Time --\n+   ----------\n+\n+   type timespec is private;\n+\n+   function nanosleep (rqtp, rmtp : access timespec)  return int;\n+   pragma Import (C, nanosleep);\n+\n+   type clockid_t is private;\n+\n+   CLOCK_REALTIME : constant clockid_t;\n+\n+   function clock_gettime\n+     (clock_id : clockid_t;\n+      tp       : access timespec) return int;\n+   pragma Import (C, clock_gettime);\n+\n+   function To_Duration (TS : timespec) return Duration;\n+   pragma Inline (To_Duration);\n+\n+   function To_Timespec (D : Duration) return timespec;\n+   pragma Inline (To_Timespec);\n+\n+   type struct_timezone is record\n+      tz_minuteswest : int;\n+      tz_dsttime     : int;\n+   end record;\n+   pragma Convention (C, struct_timezone);\n+   type struct_timeval is private;\n+   --  This is needed on systems that do not have clock_gettime()\n+   --  but do have gettimeofday().\n+\n+   function To_Duration (TV : struct_timeval) return Duration;\n+   pragma Inline (To_Duration);\n+\n+   function To_Timeval (D : Duration) return struct_timeval;\n+   pragma Inline (To_Timeval);\n+\n+   -------------------------\n+   -- Priority Scheduling --\n+   -------------------------\n+\n+   SCHED_FIFO  : constant := 1;\n+   SCHED_RR    : constant := 2;\n+   SCHED_OTHER : constant := 3;\n+   SCHED_LFI   : constant := 5;\n+\n+   -------------\n+   -- Process --\n+   -------------\n+\n+   type pid_t is private;\n+\n+   function kill (pid : pid_t; sig : Signal) return int;\n+   pragma Import (C, kill);\n+\n+   function getpid return pid_t;\n+   pragma Import (C, getpid);\n+\n+   BIND_NO_INHERIT  : constant := 1;\n+\n+   function bind_to_cpu\n+     (pid       : pid_t;\n+      cpu_mask  : unsigned_long;\n+      flag      : unsigned_long := BIND_NO_INHERIT) return int;\n+   pragma Import (C, bind_to_cpu);\n+\n+   -------------\n+   -- Threads --\n+   -------------\n+\n+   type Thread_Body is access\n+     function (arg : System.Address) return System.Address;\n+   type pthread_t           is private;\n+   subtype Thread_Id        is pthread_t;\n+\n+   type pthread_mutex_t     is limited private;\n+   type pthread_cond_t      is limited private;\n+   type pthread_attr_t      is limited private;\n+   type pthread_mutexattr_t is limited private;\n+   type pthread_condattr_t  is limited private;\n+   type pthread_key_t       is private;\n+\n+   PTHREAD_CREATE_DETACHED : constant := 1;\n+\n+   PTHREAD_SCOPE_PROCESS : constant := 0;\n+   PTHREAD_SCOPE_SYSTEM  : constant := 1;\n+\n+   PTHREAD_EXPLICIT_SCHED : constant := 1;\n+\n+   ---------------------------------------\n+   -- Nonstandard Thread Initialization --\n+   ---------------------------------------\n+\n+   procedure pthread_init;\n+   pragma Inline (pthread_init);\n+   --  This is a dummy procedure to share some GNULLI files\n+\n+   ---------------------------\n+   --  POSIX.1c  Section 3  --\n+   ---------------------------\n+\n+   function sigwait\n+     (set : access sigset_t;\n+      sig : access Signal) return int;\n+   pragma Import (C, sigwait, \"__sigwaitd10\");\n+\n+   function pthread_kill\n+     (thread : pthread_t;\n+      sig    : Signal) return int;\n+   pragma Import (C, pthread_kill);\n+\n+   type sigset_t_ptr is access all sigset_t;\n+\n+   function pthread_sigmask\n+     (how  : int;\n+      set  : sigset_t_ptr;\n+      oset : sigset_t_ptr) return int;\n+   pragma Import (C, pthread_sigmask);\n+\n+   ----------------------------\n+   --  POSIX.1c  Section 11  --\n+   ----------------------------\n+\n+   function pthread_mutexattr_init (attr : access pthread_mutexattr_t)\n+     return int;\n+   pragma Import (C, pthread_mutexattr_init);\n+\n+   function pthread_mutexattr_destroy\n+     (attr : access pthread_mutexattr_t) return int;\n+   pragma Import (C, pthread_mutexattr_destroy);\n+\n+   function pthread_mutex_init\n+     (mutex : access pthread_mutex_t;\n+      attr  : access pthread_mutexattr_t) return int;\n+   pragma Import (C, pthread_mutex_init, \"__pthread_mutex_init\");\n+\n+   function pthread_mutex_destroy (mutex : access pthread_mutex_t) return int;\n+   pragma Import (C, pthread_mutex_destroy, \"__pthread_mutex_destroy\");\n+\n+   function pthread_mutex_lock (mutex : access pthread_mutex_t) return int;\n+   pragma Import (C, pthread_mutex_lock, \"__pthread_mutex_lock\");\n+\n+   function pthread_mutex_unlock (mutex : access pthread_mutex_t) return int;\n+   pragma Import (C, pthread_mutex_unlock, \"__pthread_mutex_unlock\");\n+\n+   function pthread_condattr_init\n+     (attr : access pthread_condattr_t) return int;\n+   pragma Import (C, pthread_condattr_init);\n+\n+   function pthread_condattr_destroy\n+     (attr : access pthread_condattr_t) return int;\n+   pragma Import (C, pthread_condattr_destroy);\n+\n+   function pthread_cond_init\n+     (cond : access pthread_cond_t;\n+      attr : access pthread_condattr_t) return int;\n+   pragma Import (C, pthread_cond_init, \"__pthread_cond_init\");\n+\n+   function pthread_cond_destroy (cond : access pthread_cond_t) return int;\n+   pragma Import (C, pthread_cond_destroy, \"__pthread_cond_destroy\");\n+\n+   function pthread_cond_signal (cond : access pthread_cond_t) return int;\n+   pragma Import (C, pthread_cond_signal, \"__pthread_cond_signal\");\n+\n+   function pthread_cond_wait\n+     (cond  : access pthread_cond_t;\n+      mutex : access pthread_mutex_t) return  int;\n+   pragma Import (C, pthread_cond_wait, \"__pthread_cond_wait\");\n+\n+   function pthread_cond_timedwait\n+     (cond    : access pthread_cond_t;\n+      mutex   : access pthread_mutex_t;\n+      abstime : access timespec) return int;\n+   pragma Import (C, pthread_cond_timedwait, \"__pthread_cond_timedwait\");\n+\n+   ----------------------------\n+   --  POSIX.1c  Section 13  --\n+   ----------------------------\n+\n+   function pthread_mutexattr_setprotocol\n+     (attr     : access pthread_mutexattr_t;\n+      protocol : int) return int;\n+   pragma Import (C, pthread_mutexattr_setprotocol);\n+\n+   function pthread_mutexattr_setprioceiling\n+     (attr     : access pthread_mutexattr_t;\n+      prioceiling : int) return int;\n+   pragma Import (C, pthread_mutexattr_setprioceiling);\n+\n+   type struct_sched_param is record\n+      sched_priority : int;  --  scheduling priority\n+   end record;\n+\n+   function pthread_setschedparam\n+     (thread : pthread_t;\n+      policy : int;\n+      param  : access struct_sched_param) return int;\n+   pragma Import (C, pthread_setschedparam);\n+\n+   function pthread_attr_setscope\n+     (attr            : access pthread_attr_t;\n+      contentionscope : int) return int;\n+   pragma Import (C, pthread_attr_setscope);\n+\n+   function pthread_attr_setinheritsched\n+     (attr            : access pthread_attr_t;\n+      inheritsched    : int) return int;\n+   pragma Import (C, pthread_attr_setinheritsched,\n+     \"__pthread_attr_setinheritsched\");\n+\n+   function pthread_attr_setschedpolicy\n+     (attr : access pthread_attr_t; policy : int) return int;\n+   pragma Import (C, pthread_attr_setschedpolicy);\n+\n+   function pthread_attr_setschedparam\n+     (attr        : access pthread_attr_t;\n+      sched_param : access struct_sched_param) return int;\n+   pragma Import (C, pthread_attr_setschedparam);\n+\n+   function sched_yield return int;\n+   pragma Import (C, sched_yield);\n+\n+   ---------------------------\n+   -- P1003.1c - Section 16 --\n+   ---------------------------\n+\n+   function pthread_attr_init (attributes : access pthread_attr_t)\n+     return int;\n+   pragma Import (C, pthread_attr_init);\n+\n+   function pthread_attr_destroy (attributes : access pthread_attr_t)\n+     return int;\n+   pragma Import (C, pthread_attr_destroy);\n+\n+   function pthread_attr_setdetachstate\n+     (attr        : access pthread_attr_t;\n+      detachstate : int) return int;\n+   pragma Import (C, pthread_attr_setdetachstate);\n+\n+   function pthread_attr_setstacksize\n+     (attr      : access pthread_attr_t;\n+      stacksize : size_t) return int;\n+   pragma Import (C, pthread_attr_setstacksize, \"__pthread_attr_setstacksize\");\n+\n+   function pthread_create\n+     (thread        : access pthread_t;\n+      attributes    : access pthread_attr_t;\n+      start_routine : Thread_Body;\n+      arg           : System.Address) return int;\n+   pragma Import (C, pthread_create, \"__pthread_create\");\n+\n+   procedure pthread_exit (status : System.Address);\n+   pragma Import (C, pthread_exit, \"__pthread_exit\");\n+\n+   function pthread_self return pthread_t;\n+   pragma Import (C, pthread_self, \"__pthread_self\");\n+\n+   --------------------------\n+   -- POSIX.1c  Section 17 --\n+   --------------------------\n+\n+   function pthread_setspecific\n+     (key : pthread_key_t; value : System.Address) return int;\n+   pragma Import (C, pthread_setspecific, \"__pthread_setspecific\");\n+\n+   function pthread_getspecific (key : pthread_key_t) return System.Address;\n+   pragma Import (C, pthread_getspecific, \"__pthread_getspecific\");\n+\n+   type destructor_pointer is access procedure (arg : System.Address);\n+\n+   function pthread_key_create\n+     (key        : access pthread_key_t;\n+      destructor : destructor_pointer) return int;\n+   pragma Import (C, pthread_key_create);\n+\n+private\n+\n+   type sigset_t is new unsigned_long;\n+\n+   type pid_t is new int;\n+\n+   type time_t is new int;\n+\n+   type timespec is record\n+      tv_sec  : time_t;\n+      tv_nsec : long;\n+   end record;\n+   pragma Convention (C, timespec);\n+\n+   type clockid_t is new int;\n+   CLOCK_REALTIME : constant clockid_t := 1;\n+\n+   type struct_timeval is record\n+      tv_sec  : time_t;\n+      tv_usec : time_t;\n+   end record;\n+   pragma Convention (C, struct_timeval);\n+\n+   type unsigned_long_array is array (Natural range <>) of unsigned_long;\n+\n+   type pthread_t is new System.Address;\n+\n+   type pthread_cond_t is record\n+      state     : unsigned;\n+      valid     : unsigned;\n+      name      : System.Address;\n+      arg       : unsigned;\n+      reserved1 : unsigned;\n+      sequence  : unsigned_long;\n+      block     : System.Address;\n+   end record;\n+   pragma Convention (C, pthread_cond_t);\n+\n+   type pthread_attr_t is record\n+      valid    : long;\n+      name     : System.Address;\n+      arg      : unsigned_long;\n+      reserved : unsigned_long_array (0 .. 18);\n+   end record;\n+   pragma Convention (C, pthread_attr_t);\n+\n+   type pthread_mutex_t is record\n+      lock     : unsigned;\n+      valid    : unsigned;\n+      name     : System.Address;\n+      arg      : unsigned;\n+      depth    : unsigned;\n+      sequence : unsigned_long;\n+      owner    : unsigned_long;\n+      block    : System.Address;\n+   end record;\n+   for pthread_mutex_t'Size use 8 * 48;\n+   pragma Convention (C, pthread_mutex_t);\n+\n+   type pthread_mutexattr_t is record\n+      valid    : long;\n+      reserved : unsigned_long_array (0 .. 14);\n+   end record;\n+   pragma Convention (C, pthread_mutexattr_t);\n+\n+   type pthread_condattr_t is record\n+      valid    : long;\n+      reserved : unsigned_long_array (0 .. 12);\n+   end record;\n+   pragma Convention (C, pthread_condattr_t);\n+\n+   type pthread_key_t is new unsigned;\n+\n+end System.OS_Interface;"}, {"sha": "f777d2b916b50a3640490877f89f60bba74a8e76", "filename": "gcc/ada/5asystem.ads", "status": "added", "additions": 229, "deletions": 0, "changes": 229, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5asystem.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5asystem.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5asystem.ads?ref=84481f762f0682e5f45b2f360446e1c7e333c880", "patch": "@@ -0,0 +1,229 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                        GNAT RUN-TIME COMPONENTS                          --\n+--                                                                          --\n+--                               S Y S T E M                                --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                           (DEC Unix Version)                             --\n+--                                                                          --\n+--                            $Revision: 1.20 $\n+--                                                                          --\n+--          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+package System is\n+pragma Pure (System);\n+--  Note that we take advantage of the implementation permission to\n+--  make this unit Pure instead of Preelaborable, see RM 13.7(36)\n+\n+   type Name is (SYSTEM_NAME_GNAT);\n+   System_Name : constant Name := SYSTEM_NAME_GNAT;\n+\n+   --  System-Dependent Named Numbers\n+\n+   Min_Int               : constant := Long_Long_Integer'First;\n+   Max_Int               : constant := Long_Long_Integer'Last;\n+\n+   Max_Binary_Modulus    : constant := 2 ** Long_Long_Integer'Size;\n+   Max_Nonbinary_Modulus : constant := Integer'Last;\n+\n+   Max_Base_Digits       : constant := Long_Long_Float'Digits;\n+   Max_Digits            : constant := Long_Long_Float'Digits;\n+\n+   Max_Mantissa          : constant := 63;\n+   Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);\n+\n+   Tick                  : constant := Standard'Tick;\n+\n+   --  Storage-related Declarations\n+\n+   type Address is private;\n+   Null_Address : constant Address;\n+\n+   Storage_Unit : constant := Standard'Storage_Unit;\n+   Word_Size    : constant := Standard'Word_Size;\n+   Memory_Size  : constant := 2 ** Standard'Address_Size;\n+\n+   --  Address comparison\n+\n+   function \"<\"  (Left, Right : Address) return Boolean;\n+   function \"<=\" (Left, Right : Address) return Boolean;\n+   function \">\"  (Left, Right : Address) return Boolean;\n+   function \">=\" (Left, Right : Address) return Boolean;\n+   function \"=\"  (Left, Right : Address) return Boolean;\n+\n+   pragma Import (Intrinsic, \"<\");\n+   pragma Import (Intrinsic, \"<=\");\n+   pragma Import (Intrinsic, \">\");\n+   pragma Import (Intrinsic, \">=\");\n+   pragma Import (Intrinsic, \"=\");\n+\n+   --  Other System-Dependent Declarations\n+\n+   type Bit_Order is (High_Order_First, Low_Order_First);\n+   Default_Bit_Order : constant Bit_Order := Low_Order_First;\n+\n+   --  Priority-related Declarations (RM D.1)\n+\n+   Max_Priority : constant Positive := 30;\n+\n+   Max_Interrupt_Priority : constant Positive := 31;\n+\n+   subtype Any_Priority is Integer\n+     range 0 .. Standard'Max_Interrupt_Priority;\n+\n+   subtype Priority is Any_Priority\n+     range 0 .. Standard'Max_Priority;\n+\n+   --  Functional notation is needed in the following to avoid visibility\n+   --  problems when this package is compiled through rtsfind in the middle\n+   --  of another compilation.\n+\n+   subtype Interrupt_Priority is Any_Priority\n+     range\n+       Standard.\"+\" (Standard'Max_Priority,  1) ..\n+         Standard'Max_Interrupt_Priority;\n+\n+   Default_Priority : constant Priority :=\n+     Standard.\"/\" (Standard.\"+\" (Priority'First, Priority'Last), 2);\n+\n+private\n+\n+   type Address is mod Memory_Size;\n+   Null_Address : constant Address := 0;\n+\n+   --------------------------------------\n+   -- System Implementation Parameters --\n+   --------------------------------------\n+\n+   --  These parameters provide information about the target that is used\n+   --  by the compiler. They are in the private part of System, where they\n+   --  can be accessed using the special circuitry in the Targparm unit\n+   --  whose source should be consulted for more detailed descriptions\n+   --  of the individual switch values.\n+\n+   AAMP                      : constant Boolean := False;\n+   Command_Line_Args         : constant Boolean := True;\n+   Denorm                    : constant Boolean := False;\n+   Frontend_Layout           : constant Boolean := False;\n+   Functions_Return_By_DSP   : constant Boolean := True;\n+   Long_Shifts_Inlined       : constant Boolean := True;\n+   High_Integrity_Mode       : constant Boolean := False;\n+   Machine_Overflows         : constant Boolean := False;\n+   Machine_Rounds            : constant Boolean := True;\n+   OpenVMS                   : constant Boolean := False;\n+   Signed_Zeros              : constant Boolean := True;\n+   Stack_Check_Default       : constant Boolean := True;\n+   Stack_Check_Probes        : constant Boolean := True;\n+   Use_Ada_Main_Program_Name : constant Boolean := False;\n+   ZCX_By_Default            : constant Boolean := True;\n+   GCC_ZCX_Support           : constant Boolean := False;\n+   Front_End_ZCX_Support     : constant Boolean := True;\n+\n+   --  Note: Denorm is False because denormals are only handled properly\n+   --  if the -mieee switch is set, and we do not require this usage.\n+\n+   ---------------------------\n+   -- Underlying Priorities --\n+   ---------------------------\n+\n+   --  Important note: this section of the file must come AFTER the\n+   --  definition of the system implementation parameters to ensure\n+   --  that the value of these parameters is available for analysis\n+   --  of the declarations here (using Rtsfind at compile time).\n+\n+   --  The underlying priorities table provides a generalized mechanism\n+   --  for mapping from Ada priorities to system priorities. In some\n+   --  cases a 1-1 mapping is not the convenient or optimal choice.\n+\n+   --  For Dec Unix 4.0d, we use a default 1-to-1 mapping that provides\n+   --  the full range of 64 priorities available from the operating system.\n+\n+   --  On DU prior to 4.0d, less than 64 priorities are available so there\n+   --  are two possibilities:\n+\n+   --    Limit your range of priorities to the range provided by the\n+   --    OS (e.g 16 .. 32 on 4.0b)\n+\n+   --    Replace the standard table as described below\n+\n+   --  To replace the default values of the Underlying_Priorities mapping,\n+   --  copy this source file into your build directory, edit the file to\n+   --  reflect your desired behavior, and recompile with the command:\n+\n+   --     $ gcc -c -O3 -gnatpgn system.ads\n+\n+   --  then recompile the run-time parts that depend on this package:\n+\n+   --     $ gnatmake -a -gnatn -O3 <your application>\n+\n+   --  then force rebuilding your application if you need different options:\n+\n+   --     $ gnatmake -f <your options> <your application>\n+\n+   type Priorities_Mapping is array (Any_Priority) of Integer;\n+   pragma Suppress_Initialization (Priorities_Mapping);\n+   --  Suppress initialization in case gnat.adc specifies Normalize_Scalars\n+\n+   Underlying_Priorities : constant Priorities_Mapping :=\n+     (Priority'First     => 16,\n+      1  => 17,\n+      2  => 18,\n+      3  => 18,\n+      4  => 18,\n+      5  => 18,\n+      6  => 19,\n+      7  => 19,\n+      8  => 19,\n+      9  => 20,\n+      10 => 20,\n+      11 => 21,\n+      12 => 21,\n+      13 => 22,\n+      14 => 23,\n+      Default_Priority   => 24,\n+      16 => 25,\n+      17 => 25,\n+      18 => 25,\n+      19 => 26,\n+      20 => 26,\n+      21 => 26,\n+      22 => 27,\n+      23 => 27,\n+      24 => 27,\n+      25 => 28,\n+      26 => 28,\n+      27 => 29,\n+      28 => 29,\n+      29 => 30,\n+      Priority'Last      => 30,\n+      Interrupt_Priority => 31);\n+\n+end System;"}, {"sha": "ac19d7b78b4bb612f3b59d4680bf55ba0cb66c36", "filename": "gcc/ada/5ataprop.adb", "status": "added", "additions": 997, "deletions": 0, "changes": 997, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5ataprop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5ataprop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5ataprop.adb?ref=84481f762f0682e5f45b2f360446e1c7e333c880", "patch": "@@ -0,0 +1,997 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS               --\n+--                                                                          --\n+--     S Y S T E M . T A S K _ P R I M I T I V E S . O P E R A T I O N S    --\n+--                                                                          --\n+--                                  B o d y                                 --\n+--                                                                          --\n+--                             $Revision: 1.60 $\n+--                                                                          --\n+--             Copyright (C) 1991-2001, Florida State University            --\n+--                                                                          --\n+-- GNARL is free software; you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion. GNARL is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNARL; see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNARL was developed by the GNARL team at Florida State University. It is --\n+-- now maintained by Ada Core Technologies Inc. in cooperation with Florida --\n+-- State University (http://www.gnat.com).                                  --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is a DEC Unix 4.0d version of this package\n+\n+--  This package contains all the GNULL primitives that interface directly\n+--  with the underlying OS.\n+\n+pragma Polling (Off);\n+--  Turn off polling, we do not want ATC polling to take place during\n+--  tasking operations. It causes infinite loops and other problems.\n+\n+with System.Tasking.Debug;\n+--  used for Known_Tasks\n+\n+with System.Task_Info;\n+--  used for Task_Info_Type\n+\n+with Interfaces;\n+--  used for Shift_Left\n+\n+with Interfaces.C;\n+--  used for int\n+--           size_t\n+\n+with System.Interrupt_Management;\n+--  used for Keep_Unmasked\n+--           Abort_Task_Interrupt\n+--           Interrupt_ID\n+\n+with System.Interrupt_Management.Operations;\n+--  used for Set_Interrupt_Mask\n+--           All_Tasks_Mask\n+pragma Elaborate_All (System.Interrupt_Management.Operations);\n+\n+with System.Parameters;\n+--  used for Size_Type\n+\n+with System.Tasking;\n+--  used for Ada_Task_Control_Block\n+--           Task_ID\n+--           ATCB components and types\n+\n+with System.Soft_Links;\n+--  used for Defer/Undefer_Abort\n+\n+--  Note that we do not use System.Tasking.Initialization directly since\n+--  this is a higher level package that we shouldn't depend on. For example\n+--  when using the restricted run time, it is replaced by\n+--  System.Tasking.Restricted.Initialization\n+\n+with System.OS_Primitives;\n+--  used for Delay_Modes\n+\n+with Unchecked_Conversion;\n+with Unchecked_Deallocation;\n+\n+package body System.Task_Primitives.Operations is\n+\n+   use System.Tasking.Debug;\n+   use System.Tasking;\n+   use Interfaces.C;\n+   use System.OS_Interface;\n+   use System.Parameters;\n+   use System.OS_Primitives;\n+\n+   package SSL renames System.Soft_Links;\n+\n+   -----------------\n+   -- Local Data  --\n+   -----------------\n+\n+   --  The followings are logically constants, but need to be initialized\n+   --  at run time.\n+\n+   All_Tasks_L : aliased System.Task_Primitives.RTS_Lock;\n+   --  See comments on locking rules in System.Tasking (spec).\n+\n+   Environment_Task_ID : Task_ID;\n+   --  A variable to hold Task_ID for the environment task.\n+\n+   Unblocked_Signal_Mask : aliased sigset_t;\n+   --  The set of signals that should unblocked in all tasks\n+\n+   Time_Slice_Val : Integer;\n+   pragma Import (C, Time_Slice_Val, \"__gl_time_slice_val\");\n+\n+   Locking_Policy : Character;\n+   pragma Import (C, Locking_Policy, \"__gl_locking_policy\");\n+\n+   Dispatching_Policy : Character;\n+   pragma Import (C, Dispatching_Policy, \"__gl_task_dispatching_policy\");\n+\n+   FIFO_Within_Priorities : constant Boolean := Dispatching_Policy = 'F';\n+   --  Indicates whether FIFO_Within_Priorities is set.\n+\n+   Curpid : pid_t;\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   procedure Abort_Handler (Sig : Signal);\n+\n+   function To_Task_ID is new Unchecked_Conversion (System.Address, Task_ID);\n+\n+   function To_Address is new Unchecked_Conversion (Task_ID, System.Address);\n+\n+   --------------------\n+   -- Local Packages --\n+   --------------------\n+\n+   package Specific is\n+\n+      procedure Initialize (Environment_Task : Task_ID);\n+      pragma Inline (Initialize);\n+      --  Initialize various data needed by this package.\n+\n+      procedure Set (Self_Id : Task_ID);\n+      pragma Inline (Set);\n+      --  Set the self id for the current task.\n+\n+      function Self return Task_ID;\n+      pragma Inline (Self);\n+      --  Return a pointer to the Ada Task Control Block of the calling task.\n+\n+   end Specific;\n+\n+   package body Specific is separate;\n+   --  The body of this package is target specific.\n+\n+   -------------------\n+   -- Abort_Handler --\n+   -------------------\n+\n+   procedure Abort_Handler (Sig : Signal) is\n+      T       : constant Task_ID := Self;\n+      Result  : Interfaces.C.int;\n+      Old_Set : aliased sigset_t;\n+\n+   begin\n+      if T.Deferral_Level = 0\n+        and then T.Pending_ATC_Level < T.ATC_Nesting_Level and then\n+        not T.Aborting\n+      then\n+         T.Aborting := True;\n+\n+         --  Make sure signals used for RTS internal purpose are unmasked\n+\n+         Result := pthread_sigmask (SIG_UNBLOCK,\n+           Unblocked_Signal_Mask'Unchecked_Access, Old_Set'Unchecked_Access);\n+         pragma Assert (Result = 0);\n+\n+         raise Standard'Abort_Signal;\n+      end if;\n+   end Abort_Handler;\n+\n+   ------------------\n+   -- Stack_Guard  --\n+   ------------------\n+\n+   --  The underlying thread system sets a guard page at the\n+   --  bottom of a thread stack, so nothing is needed.\n+\n+   procedure Stack_Guard (T : ST.Task_ID; On : Boolean) is\n+   begin\n+      null;\n+   end Stack_Guard;\n+\n+   --------------------\n+   -- Get_Thread_Id  --\n+   --------------------\n+\n+   function Get_Thread_Id (T : ST.Task_ID) return OSI.Thread_Id is\n+   begin\n+      return T.Common.LL.Thread;\n+   end Get_Thread_Id;\n+\n+   ----------\n+   -- Self --\n+   ----------\n+\n+   function Self return Task_ID renames Specific.Self;\n+\n+   ---------------------\n+   -- Initialize_Lock --\n+   ---------------------\n+\n+   --  Note: mutexes and cond_variables needed per-task basis are\n+   --        initialized in Intialize_TCB and the Storage_Error is\n+   --        handled. Other mutexes (such as All_Tasks_Lock, Memory_Lock...)\n+   --        used in RTS is initialized before any status change of RTS.\n+   --        Therefore rasing Storage_Error in the following routines\n+   --        should be able to be handled safely.\n+\n+   procedure Initialize_Lock\n+     (Prio : System.Any_Priority;\n+      L    : access Lock)\n+   is\n+      Attributes : aliased pthread_mutexattr_t;\n+      Result     : Interfaces.C.int;\n+\n+   begin\n+      Result := pthread_mutexattr_init (Attributes'Access);\n+      pragma Assert (Result = 0 or else Result = ENOMEM);\n+\n+      if Result = ENOMEM then\n+         raise Storage_Error;\n+      end if;\n+\n+      if Locking_Policy = 'C' then\n+         L.Ceiling := Interfaces.C.int (Prio);\n+      end if;\n+\n+      Result := pthread_mutex_init (L.L'Access, Attributes'Access);\n+      pragma Assert (Result = 0 or else Result = ENOMEM);\n+\n+      if Result = ENOMEM then\n+         Result := pthread_mutexattr_destroy (Attributes'Access);\n+         raise Storage_Error;\n+      end if;\n+\n+      Result := pthread_mutexattr_destroy (Attributes'Access);\n+      pragma Assert (Result = 0);\n+   end Initialize_Lock;\n+\n+   procedure Initialize_Lock (L : access RTS_Lock; Level : Lock_Level) is\n+      Attributes : aliased pthread_mutexattr_t;\n+      Result     : Interfaces.C.int;\n+\n+   begin\n+      Result := pthread_mutexattr_init (Attributes'Access);\n+      pragma Assert (Result = 0 or else Result = ENOMEM);\n+\n+      if Result = ENOMEM then\n+         raise Storage_Error;\n+      end if;\n+\n+      Result := pthread_mutex_init (L, Attributes'Access);\n+      pragma Assert (Result = 0 or else Result = ENOMEM);\n+\n+      if Result = ENOMEM then\n+         Result := pthread_mutexattr_destroy (Attributes'Access);\n+         raise Storage_Error;\n+      end if;\n+\n+      Result := pthread_mutexattr_destroy (Attributes'Access);\n+      pragma Assert (Result = 0);\n+   end Initialize_Lock;\n+\n+   -------------------\n+   -- Finalize_Lock --\n+   -------------------\n+\n+   procedure Finalize_Lock (L : access Lock) is\n+      Result : Interfaces.C.int;\n+   begin\n+      Result := pthread_mutex_destroy (L.L'Access);\n+      pragma Assert (Result = 0);\n+   end Finalize_Lock;\n+\n+   procedure Finalize_Lock (L : access RTS_Lock) is\n+      Result : Interfaces.C.int;\n+   begin\n+      Result := pthread_mutex_destroy (L);\n+      pragma Assert (Result = 0);\n+   end Finalize_Lock;\n+\n+   ----------------\n+   -- Write_Lock --\n+   ----------------\n+\n+   procedure Write_Lock (L : access Lock; Ceiling_Violation : out Boolean) is\n+      Result         : Interfaces.C.int;\n+      Self_ID        : Task_ID;\n+      All_Tasks_Link : Task_ID;\n+      Current_Prio   : System.Any_Priority;\n+\n+   begin\n+      --  Perform ceiling checks only when this is the locking policy in use.\n+\n+      if Locking_Policy = 'C' then\n+         Self_ID := Self;\n+         All_Tasks_Link := Self_ID.Common.All_Tasks_Link;\n+         Current_Prio := Get_Priority (Self_ID);\n+\n+         --  if there is no other task, no need to check priorities\n+         if All_Tasks_Link /= Null_Task and then\n+            L.Ceiling < Interfaces.C.int (Current_Prio) then\n+            Ceiling_Violation := True;\n+            return;\n+         end if;\n+      end if;\n+\n+      Result := pthread_mutex_lock (L.L'Access);\n+\n+      pragma Assert (Result = 0);\n+\n+      Ceiling_Violation := False;\n+   end Write_Lock;\n+\n+   procedure Write_Lock (L : access RTS_Lock) is\n+      Result : Interfaces.C.int;\n+   begin\n+      Result := pthread_mutex_lock (L);\n+      pragma Assert (Result = 0);\n+   end Write_Lock;\n+\n+   procedure Write_Lock (T : Task_ID) is\n+      Result : Interfaces.C.int;\n+   begin\n+      Result := pthread_mutex_lock (T.Common.LL.L'Access);\n+      pragma Assert (Result = 0);\n+   end Write_Lock;\n+\n+   ---------------\n+   -- Read_Lock --\n+   ---------------\n+\n+   procedure Read_Lock (L : access Lock; Ceiling_Violation : out Boolean) is\n+   begin\n+      Write_Lock (L, Ceiling_Violation);\n+   end Read_Lock;\n+\n+   ------------\n+   -- Unlock --\n+   ------------\n+\n+   procedure Unlock (L : access Lock) is\n+      Result : Interfaces.C.int;\n+   begin\n+      Result := pthread_mutex_unlock (L.L'Access);\n+      pragma Assert (Result = 0);\n+   end Unlock;\n+\n+   procedure Unlock (L : access RTS_Lock) is\n+      Result : Interfaces.C.int;\n+   begin\n+      Result := pthread_mutex_unlock (L);\n+      pragma Assert (Result = 0);\n+   end Unlock;\n+\n+   procedure Unlock (T : Task_ID) is\n+      Result : Interfaces.C.int;\n+   begin\n+      Result := pthread_mutex_unlock (T.Common.LL.L'Access);\n+      pragma Assert (Result = 0);\n+   end Unlock;\n+\n+   -----------\n+   -- Sleep --\n+   -----------\n+\n+   procedure Sleep\n+     (Self_ID : Task_ID;\n+      Reason  : System.Tasking.Task_States)\n+   is\n+      Result : Interfaces.C.int;\n+   begin\n+      pragma Assert (Self_ID = Self);\n+      Result := pthread_cond_wait\n+        (Self_ID.Common.LL.CV'Access, Self_ID.Common.LL.L'Access);\n+\n+      --  EINTR is not considered a failure.\n+\n+      pragma Assert (Result = 0 or else Result = EINTR);\n+   end Sleep;\n+\n+   -----------------\n+   -- Timed_Sleep --\n+   -----------------\n+\n+   --  This is for use within the run-time system, so abort is\n+   --  assumed to be already deferred, and the caller should be\n+   --  holding its own ATCB lock.\n+\n+   procedure Timed_Sleep\n+     (Self_ID  : Task_ID;\n+      Time     : Duration;\n+      Mode     : ST.Delay_Modes;\n+      Reason   : System.Tasking.Task_States;\n+      Timedout : out Boolean;\n+      Yielded  : out Boolean)\n+   is\n+      Check_Time : constant Duration := Monotonic_Clock;\n+      Abs_Time   : Duration;\n+      Request    : aliased timespec;\n+      Result     : Interfaces.C.int;\n+\n+   begin\n+      Timedout := True;\n+      Yielded := False;\n+\n+      if Mode = Relative then\n+         Abs_Time := Duration'Min (Time, Max_Sensible_Delay) + Check_Time;\n+      else\n+         Abs_Time := Duration'Min (Check_Time + Max_Sensible_Delay, Time);\n+      end if;\n+\n+      if Abs_Time > Check_Time then\n+         Request := To_Timespec (Abs_Time);\n+\n+         loop\n+            exit when Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level\n+              or else Self_ID.Pending_Priority_Change;\n+\n+            Result := pthread_cond_timedwait (Self_ID.Common.LL.CV'Access,\n+              Self_ID.Common.LL.L'Access, Request'Access);\n+\n+            exit when Abs_Time <= Monotonic_Clock;\n+\n+            if Result = 0 or Result = EINTR then\n+               --  somebody may have called Wakeup for us\n+               Timedout := False;\n+               exit;\n+            end if;\n+\n+            pragma Assert (Result = ETIMEDOUT);\n+         end loop;\n+      end if;\n+   end Timed_Sleep;\n+\n+   -----------------\n+   -- Timed_Delay --\n+   -----------------\n+\n+   --  This is for use in implementing delay statements, so\n+   --  we assume the caller is abort-deferred but is holding\n+   --  no locks.\n+\n+   procedure Timed_Delay\n+     (Self_ID  : Task_ID;\n+      Time     : Duration;\n+      Mode     : ST.Delay_Modes)\n+   is\n+      Check_Time : constant Duration := Monotonic_Clock;\n+      Abs_Time   : Duration;\n+      Request    : aliased timespec;\n+      Result     : Interfaces.C.int;\n+\n+   begin\n+      --  Only the little window between deferring abort and\n+      --  locking Self_ID is the reason we need to\n+      --  check for pending abort and priority change below! :(\n+\n+      SSL.Abort_Defer.all;\n+      Write_Lock (Self_ID);\n+\n+      if Mode = Relative then\n+         Abs_Time := Time + Check_Time;\n+      else\n+         Abs_Time := Duration'Min (Check_Time + Max_Sensible_Delay, Time);\n+      end if;\n+\n+      if Abs_Time > Check_Time then\n+         Request := To_Timespec (Abs_Time);\n+         Self_ID.Common.State := Delay_Sleep;\n+\n+         loop\n+            if Self_ID.Pending_Priority_Change then\n+               Self_ID.Pending_Priority_Change := False;\n+               Self_ID.Common.Base_Priority := Self_ID.New_Base_Priority;\n+               Set_Priority (Self_ID, Self_ID.Common.Base_Priority);\n+            end if;\n+\n+            exit when Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level;\n+\n+            Result := pthread_cond_timedwait (Self_ID.Common.LL.CV'Access,\n+              Self_ID.Common.LL.L'Access, Request'Access);\n+\n+            exit when Abs_Time <= Monotonic_Clock;\n+\n+            pragma Assert (Result = 0 or else\n+              Result = ETIMEDOUT or else\n+              Result = EINTR);\n+         end loop;\n+\n+         Self_ID.Common.State := Runnable;\n+      end if;\n+\n+      Unlock (Self_ID);\n+      Yield;\n+      SSL.Abort_Undefer.all;\n+   end Timed_Delay;\n+\n+   ---------------------\n+   -- Monotonic_Clock --\n+   ---------------------\n+\n+   function Monotonic_Clock return Duration is\n+      TS     : aliased timespec;\n+      Result : Interfaces.C.int;\n+\n+   begin\n+      Result := clock_gettime (CLOCK_REALTIME, TS'Unchecked_Access);\n+      pragma Assert (Result = 0);\n+      return To_Duration (TS);\n+   end Monotonic_Clock;\n+\n+   -------------------\n+   -- RT_Resolution --\n+   -------------------\n+\n+   function RT_Resolution return Duration is\n+   begin\n+      return 1.0 / 1024.0; --  Clock on DEC Alpha ticks at 1024 Hz\n+   end RT_Resolution;\n+\n+   ------------\n+   -- Wakeup --\n+   ------------\n+\n+   procedure Wakeup (T : Task_ID; Reason : System.Tasking.Task_States) is\n+      Result : Interfaces.C.int;\n+   begin\n+      Result := pthread_cond_signal (T.Common.LL.CV'Access);\n+      pragma Assert (Result = 0);\n+   end Wakeup;\n+\n+   -----------\n+   -- Yield --\n+   -----------\n+\n+   procedure Yield (Do_Yield : Boolean := True) is\n+      Result : Interfaces.C.int;\n+   begin\n+      if Do_Yield then\n+         Result := sched_yield;\n+      end if;\n+   end Yield;\n+\n+   ------------------\n+   -- Set_Priority --\n+   ------------------\n+\n+   procedure Set_Priority\n+     (T : Task_ID;\n+      Prio : System.Any_Priority;\n+      Loss_Of_Inheritance : Boolean := False)\n+   is\n+      Result : Interfaces.C.int;\n+      Param  : aliased struct_sched_param;\n+\n+   begin\n+      T.Common.Current_Priority := Prio;\n+      Param.sched_priority  := Interfaces.C.int (Underlying_Priorities (Prio));\n+\n+      if Time_Slice_Val > 0 then\n+         Result := pthread_setschedparam\n+           (T.Common.LL.Thread, SCHED_RR, Param'Access);\n+\n+      elsif FIFO_Within_Priorities or else Time_Slice_Val = 0 then\n+         Result := pthread_setschedparam\n+           (T.Common.LL.Thread, SCHED_FIFO, Param'Access);\n+\n+      else\n+         Result := pthread_setschedparam\n+           (T.Common.LL.Thread, SCHED_OTHER, Param'Access);\n+      end if;\n+\n+      pragma Assert (Result = 0);\n+   end Set_Priority;\n+\n+   ------------------\n+   -- Get_Priority --\n+   ------------------\n+\n+   function Get_Priority (T : Task_ID) return System.Any_Priority is\n+   begin\n+      return T.Common.Current_Priority;\n+   end Get_Priority;\n+\n+   ----------------\n+   -- Enter_Task --\n+   ----------------\n+\n+   procedure Enter_Task (Self_ID : Task_ID) is\n+   begin\n+      Self_ID.Common.LL.Thread := pthread_self;\n+      Specific.Set (Self_ID);\n+\n+      Lock_All_Tasks_List;\n+\n+      for J in Known_Tasks'Range loop\n+         if Known_Tasks (J) = null then\n+            Known_Tasks (J) := Self_ID;\n+            Self_ID.Known_Tasks_Index := J;\n+            exit;\n+         end if;\n+      end loop;\n+\n+      Unlock_All_Tasks_List;\n+   end Enter_Task;\n+\n+   --------------\n+   -- New_ATCB --\n+   --------------\n+\n+   function New_ATCB (Entry_Num : Task_Entry_Index) return Task_ID is\n+   begin\n+      return new Ada_Task_Control_Block (Entry_Num);\n+   end New_ATCB;\n+\n+   --------------------\n+   -- Initialize_TCB --\n+   --------------------\n+\n+   procedure Initialize_TCB (Self_ID : Task_ID; Succeeded : out Boolean) is\n+      Mutex_Attr : aliased pthread_mutexattr_t;\n+      Result     : Interfaces.C.int;\n+      Cond_Attr  : aliased pthread_condattr_t;\n+\n+   begin\n+      Result := pthread_mutexattr_init (Mutex_Attr'Access);\n+      pragma Assert (Result = 0 or else Result = ENOMEM);\n+\n+      if Result /= 0 then\n+         Succeeded := False;\n+         return;\n+      end if;\n+\n+      Result := pthread_mutex_init (Self_ID.Common.LL.L'Access,\n+        Mutex_Attr'Access);\n+      pragma Assert (Result = 0 or else Result = ENOMEM);\n+\n+      if Result /= 0 then\n+         Succeeded := False;\n+         return;\n+      end if;\n+\n+      Result := pthread_mutexattr_destroy (Mutex_Attr'Access);\n+      pragma Assert (Result = 0);\n+\n+      Result := pthread_condattr_init (Cond_Attr'Access);\n+      pragma Assert (Result = 0 or else Result = ENOMEM);\n+\n+      if Result /= 0 then\n+         Result := pthread_mutex_destroy (Self_ID.Common.LL.L'Access);\n+         pragma Assert (Result = 0);\n+         Succeeded := False;\n+         return;\n+      end if;\n+\n+      Result := pthread_cond_init (Self_ID.Common.LL.CV'Access,\n+        Cond_Attr'Access);\n+      pragma Assert (Result = 0 or else Result = ENOMEM);\n+\n+      if Result = 0 then\n+         Succeeded := True;\n+      else\n+         Result := pthread_mutex_destroy (Self_ID.Common.LL.L'Access);\n+         pragma Assert (Result = 0);\n+         Succeeded := False;\n+      end if;\n+\n+      Result := pthread_condattr_destroy (Cond_Attr'Access);\n+      pragma Assert (Result = 0);\n+   end Initialize_TCB;\n+\n+   -----------------\n+   -- Create_Task --\n+   -----------------\n+\n+   procedure Create_Task\n+     (T          : Task_ID;\n+      Wrapper    : System.Address;\n+      Stack_Size : System.Parameters.Size_Type;\n+      Priority   : System.Any_Priority;\n+      Succeeded  : out Boolean)\n+   is\n+      Attributes          : aliased pthread_attr_t;\n+      Adjusted_Stack_Size : Interfaces.C.size_t;\n+      Result              : Interfaces.C.int;\n+      Param               : aliased System.OS_Interface.struct_sched_param;\n+\n+      function Thread_Body_Access is new\n+        Unchecked_Conversion (System.Address, Thread_Body);\n+\n+      use System.Task_Info;\n+\n+   begin\n+      if Stack_Size = Unspecified_Size then\n+         Adjusted_Stack_Size := Interfaces.C.size_t (Default_Stack_Size);\n+\n+      elsif Stack_Size < Minimum_Stack_Size then\n+         Adjusted_Stack_Size := Interfaces.C.size_t (Minimum_Stack_Size);\n+\n+      else\n+         Adjusted_Stack_Size := Interfaces.C.size_t (Stack_Size);\n+      end if;\n+\n+      Result := pthread_attr_init (Attributes'Access);\n+      pragma Assert (Result = 0 or else Result = ENOMEM);\n+\n+      if Result /= 0 then\n+         Succeeded := False;\n+         return;\n+      end if;\n+\n+      Result := pthread_attr_setdetachstate\n+        (Attributes'Access, PTHREAD_CREATE_DETACHED);\n+      pragma Assert (Result = 0);\n+\n+      Result := pthread_attr_setstacksize\n+        (Attributes'Access, Adjusted_Stack_Size);\n+      pragma Assert (Result = 0);\n+\n+      --  Set the scheduling parameters explicitely, since this is the only\n+      --  way to force the OS to take the scope attribute into account\n+\n+      Result := pthread_attr_setinheritsched\n+        (Attributes'Access, PTHREAD_EXPLICIT_SCHED);\n+      pragma Assert (Result = 0);\n+\n+      Param.sched_priority :=\n+        Interfaces.C.int (Underlying_Priorities (Priority));\n+      Result := pthread_attr_setschedparam\n+        (Attributes'Access, Param'Access);\n+      pragma Assert (Result = 0);\n+\n+      if Time_Slice_Val > 0 then\n+         Result := pthread_attr_setschedpolicy\n+           (Attributes'Access, System.OS_Interface.SCHED_RR);\n+\n+      elsif FIFO_Within_Priorities or else Time_Slice_Val = 0 then\n+         Result := pthread_attr_setschedpolicy\n+           (Attributes'Access, System.OS_Interface.SCHED_FIFO);\n+\n+      else\n+         Result := pthread_attr_setschedpolicy\n+           (Attributes'Access, System.OS_Interface.SCHED_OTHER);\n+      end if;\n+\n+      pragma Assert (Result = 0);\n+\n+      T.Common.Current_Priority := Priority;\n+\n+      if T.Common.Task_Info /= null then\n+         case T.Common.Task_Info.Contention_Scope is\n+            when System.Task_Info.Process_Scope =>\n+               Result := pthread_attr_setscope\n+                  (Attributes'Access, PTHREAD_SCOPE_PROCESS);\n+\n+            when System.Task_Info.System_Scope =>\n+               Result := pthread_attr_setscope\n+                  (Attributes'Access, PTHREAD_SCOPE_SYSTEM);\n+\n+            when System.Task_Info.Default_Scope =>\n+               Result := 0;\n+         end case;\n+\n+         pragma Assert (Result = 0);\n+      end if;\n+\n+      --  Since the initial signal mask of a thread is inherited from the\n+      --  creator, and the Environment task has all its signals masked, we\n+      --  do not need to manipulate caller's signal mask at this point.\n+      --  All tasks in RTS will have All_Tasks_Mask initially.\n+\n+      Result := pthread_create\n+        (T.Common.LL.Thread'Access,\n+         Attributes'Access,\n+         Thread_Body_Access (Wrapper),\n+         To_Address (T));\n+      pragma Assert (Result = 0 or else Result = EAGAIN);\n+\n+      Succeeded := Result = 0;\n+\n+      Result := pthread_attr_destroy (Attributes'Access);\n+      pragma Assert (Result = 0);\n+\n+      if T.Common.Task_Info /= null then\n+         if T.Common.Task_Info.Bind_To_Cpu_Number = 0 then\n+            Result := bind_to_cpu (Curpid, 0);\n+         elsif T.Common.Task_Info.Bind_To_Cpu_Number > 0 then\n+            Result := bind_to_cpu\n+              (Curpid,\n+               Interfaces.C.unsigned_long (\n+                 Interfaces.Shift_Left\n+                   (Interfaces.Unsigned_64'(1),\n+                    T.Common.Task_Info.Bind_To_Cpu_Number - 1)));\n+            pragma Assert (Result = 0);\n+         end if;\n+      end if;\n+   end Create_Task;\n+\n+   ------------------\n+   -- Finalize_TCB --\n+   ------------------\n+\n+   procedure Finalize_TCB (T : Task_ID) is\n+      Result : Interfaces.C.int;\n+      Tmp    : Task_ID := T;\n+\n+      procedure Free is new\n+        Unchecked_Deallocation (Ada_Task_Control_Block, Task_ID);\n+\n+   begin\n+      Result := pthread_mutex_destroy (T.Common.LL.L'Access);\n+      pragma Assert (Result = 0);\n+      Result := pthread_cond_destroy (T.Common.LL.CV'Access);\n+      pragma Assert (Result = 0);\n+      if T.Known_Tasks_Index /= -1 then\n+         Known_Tasks (T.Known_Tasks_Index) := null;\n+      end if;\n+      Free (Tmp);\n+   end Finalize_TCB;\n+\n+   ---------------\n+   -- Exit_Task --\n+   ---------------\n+\n+   procedure Exit_Task is\n+   begin\n+      pthread_exit (System.Null_Address);\n+   end Exit_Task;\n+\n+   ----------------\n+   -- Abort_Task --\n+   ----------------\n+\n+   procedure Abort_Task (T : Task_ID) is\n+      Result : Interfaces.C.int;\n+\n+   begin\n+      Result := pthread_kill (T.Common.LL.Thread,\n+        Signal (System.Interrupt_Management.Abort_Task_Interrupt));\n+      pragma Assert (Result = 0);\n+   end Abort_Task;\n+\n+   ----------------\n+   -- Check_Exit --\n+   ----------------\n+\n+   --  Dummy versions. The only currently working versions is for solaris\n+   --  (native).\n+\n+   function Check_Exit (Self_ID : ST.Task_ID) return Boolean is\n+   begin\n+      return True;\n+   end Check_Exit;\n+\n+   --------------------\n+   -- Check_No_Locks --\n+   --------------------\n+\n+   function Check_No_Locks (Self_ID : ST.Task_ID) return Boolean is\n+   begin\n+      return True;\n+   end Check_No_Locks;\n+\n+   ----------------------\n+   -- Environment_Task --\n+   ----------------------\n+\n+   function Environment_Task return Task_ID is\n+   begin\n+      return Environment_Task_ID;\n+   end Environment_Task;\n+\n+   -------------------------\n+   -- Lock_All_Tasks_List --\n+   -------------------------\n+\n+   procedure Lock_All_Tasks_List is\n+   begin\n+      Write_Lock (All_Tasks_L'Access);\n+   end Lock_All_Tasks_List;\n+\n+   ---------------------------\n+   -- Unlock_All_Tasks_List --\n+   ---------------------------\n+\n+   procedure Unlock_All_Tasks_List is\n+   begin\n+      Unlock (All_Tasks_L'Access);\n+   end Unlock_All_Tasks_List;\n+\n+   ------------------\n+   -- Suspend_Task --\n+   ------------------\n+\n+   function Suspend_Task\n+     (T           : ST.Task_ID;\n+      Thread_Self : Thread_Id) return Boolean is\n+   begin\n+      return False;\n+   end Suspend_Task;\n+\n+   -----------------\n+   -- Resume_Task --\n+   -----------------\n+\n+   function Resume_Task\n+     (T           : ST.Task_ID;\n+      Thread_Self : Thread_Id) return Boolean is\n+   begin\n+      return False;\n+   end Resume_Task;\n+\n+   ----------------\n+   -- Initialize --\n+   ----------------\n+\n+   procedure Initialize (Environment_Task : Task_ID) is\n+      act       : aliased struct_sigaction;\n+      old_act   : aliased struct_sigaction;\n+      Tmp_Set   : aliased sigset_t;\n+      Result    : Interfaces.C.int;\n+\n+   begin\n+      Environment_Task_ID := Environment_Task;\n+\n+      Initialize_Lock (All_Tasks_L'Access, All_Tasks_Level);\n+      --  Initialize the lock used to synchronize chain of all ATCBs.\n+\n+      Specific.Initialize (Environment_Task);\n+\n+      Enter_Task (Environment_Task);\n+\n+      --  Install the abort-signal handler\n+\n+      act.sa_flags := 0;\n+      act.sa_handler := Abort_Handler'Address;\n+\n+      Result := sigemptyset (Tmp_Set'Access);\n+      pragma Assert (Result = 0);\n+      act.sa_mask := Tmp_Set;\n+\n+      Result :=\n+        sigaction\n+          (Signal (System.Interrupt_Management.Abort_Task_Interrupt),\n+           act'Unchecked_Access,\n+           old_act'Unchecked_Access);\n+      pragma Assert (Result = 0);\n+   end Initialize;\n+\n+begin\n+   declare\n+      Result : Interfaces.C.int;\n+\n+   begin\n+      --  Mask Environment task for all signals. The original mask of the\n+      --  Environment task will be recovered by Interrupt_Server task\n+      --  during the elaboration of s-interr.adb.\n+\n+      System.Interrupt_Management.Operations.Set_Interrupt_Mask\n+        (System.Interrupt_Management.Operations.All_Tasks_Mask'Access);\n+\n+      --  Prepare the set of signals that should unblocked in all tasks\n+\n+      Result := sigemptyset (Unblocked_Signal_Mask'Access);\n+      pragma Assert (Result = 0);\n+\n+      for J in Interrupt_Management.Interrupt_ID loop\n+         if System.Interrupt_Management.Keep_Unmasked (J) then\n+            Result := sigaddset (Unblocked_Signal_Mask'Access, Signal (J));\n+            pragma Assert (Result = 0);\n+         end if;\n+      end loop;\n+   end;\n+\n+   Curpid := getpid;\n+end System.Task_Primitives.Operations;"}, {"sha": "4ddf7a97e11d3171e29dc314694d889ebb628e82", "filename": "gcc/ada/5atasinf.ads", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5atasinf.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5atasinf.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5atasinf.ads?ref=84481f762f0682e5f45b2f360446e1c7e333c880", "patch": "@@ -0,0 +1,117 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                     S Y S T E M . T A S K _ I N F O                      --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                           (Compiler Interface)                           --\n+--                                                                          --\n+--                            $Revision: 1.5 $\n+--                                                                          --\n+--         Copyright (C) 1998-2000 Free Software Foundation, Inc.           --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is a DEC Unix 4.0d version of this package.\n+\n+--  This package contains the definitions and routines associated with the\n+--  implementation of the Task_Info pragma.\n+\n+--  Note: the compiler generates direct calls to this interface, via Rtsfind.\n+--  Any changes to this interface may require corresponding compiler changes.\n+\n+with Unchecked_Deallocation;\n+package System.Task_Info is\n+pragma Elaborate_Body;\n+--  To ensure that a body is allowed\n+\n+   -----------------------------------------\n+   -- Implementation of Task_Info Feature --\n+   -----------------------------------------\n+\n+   --  The Task_Info pragma:\n+\n+   --    pragma Task_Info (EXPRESSION);\n+\n+   --  allows the specification on a task by task basis of a value of type\n+   --  System.Task_Info.Task_Info_Type to be passed to a task when it is\n+   --  created. The specification of this type, and the effect on the task\n+   --  that is created is target dependent.\n+\n+   --  The Task_Info pragma appears within a task definition (compare the\n+   --  definition and implementation of pragma Priority). If no such pragma\n+   --  appears, then the value Task_Info_Unspecified is passed. If a pragma\n+   --  is present, then it supplies an alternative value. If the argument of\n+   --  the pragma is a discriminant reference, then the value can be set on\n+   --  a task by task basis by supplying the appropriate discriminant value.\n+\n+   --  Note that this means that the type used for Task_Info_Type must be\n+   --  suitable for use as a discriminant (i.e. a scalar or access type).\n+\n+   ------------------\n+   -- Declarations --\n+   ------------------\n+\n+   type Scope_Type is\n+     (Process_Scope,\n+      --  Contend only with threads in same process\n+\n+      System_Scope,\n+      --  Contend with all threads on same CPU\n+\n+      Default_Scope);\n+\n+   type Thread_Attributes is record\n+      Bind_To_Cpu_Number : Integer;\n+      --   -1: Do nothing\n+      --    0: Unbind\n+      --  1-N: Bind all unbound threads to this CPU\n+\n+      Contention_Scope   : Scope_Type;\n+   end record;\n+\n+   type Task_Info_Type is access all Thread_Attributes;\n+   --  Type used for passing information to task create call, using the\n+   --  Task_Info pragma. This type may be specialized for individual\n+   --  implementations, but it must be a type that can be used as a\n+   --  discriminant (i.e. a scalar or access type).\n+\n+   type Task_Image_Type is access String;\n+   --  Used to generate a meaningful identifier for tasks that are variables\n+   --  and components of variables.\n+\n+   procedure Free_Task_Image is new\n+     Unchecked_Deallocation (String, Task_Image_Type);\n+\n+   Unspecified_Thread_Attribute : aliased Thread_Attributes :=\n+     Thread_Attributes'(-1, Default_Scope);\n+\n+   Unspecified_Task_Info : constant Task_Info_Type :=\n+     Unspecified_Thread_Attribute'Access;\n+   --  Value passed to task in the absence of a Task_Info pragma\n+   --  Don't call new here because the tasking run time has not been\n+   --  elaborated yet, so calling Task_Lock is unsafe.\n+\n+end System.Task_Info;"}, {"sha": "13d637974f4c74141b04277ddabee397e1e14430", "filename": "gcc/ada/5ataspri.ads", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5ataspri.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5ataspri.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5ataspri.ads?ref=84481f762f0682e5f45b2f360446e1c7e333c880", "patch": "@@ -0,0 +1,96 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS               --\n+--                                                                          --\n+--                 S Y S T E M . T A S K _ P R I M I T I V E S              --\n+--                                                                          --\n+--                                  S p e c                                 --\n+--                                                                          --\n+--                             $Revision: 1.8 $\n+--                                                                          --\n+--          Copyright (C) 1991-2000 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNARL is free software; you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion. GNARL is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNARL; see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNARL was developed by the GNARL team at Florida State University. It is --\n+-- now maintained by Ada Core Technologies Inc. in cooperation with Florida --\n+-- State University (http://www.gnat.com).                                  --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is the DEC Unix 4.0 version of this package.\n+\n+--  This package provides low-level support for most tasking features.\n+\n+pragma Polling (Off);\n+--  Turn off polling, we do not want ATC polling to take place during\n+--  tasking operations. It causes infinite loops and other problems.\n+\n+with Interfaces.C;\n+--  used for int\n+--           size_t\n+\n+with System.OS_Interface;\n+--  used for pthread_mutex_t\n+--           pthread_cond_t\n+--           pthread_t\n+\n+package System.Task_Primitives is\n+\n+   type Lock is limited private;\n+   --  Should be used for implementation of protected objects.\n+\n+   type RTS_Lock is limited private;\n+   --  Should be used inside the runtime system.\n+   --  The difference between Lock and the RTS_Lock is that the later\n+   --  one serves only as a semaphore so that do not check for\n+   --  ceiling violations.\n+\n+   type Task_Body_Access is access procedure;\n+   --  Pointer to the task body's entry point (or possibly a wrapper\n+   --  declared local to the GNARL).\n+\n+   type Private_Data is limited private;\n+   --  Any information that the GNULLI needs maintained on a per-task\n+   --  basis.  A component of this type is guaranteed to be included\n+   --  in the Ada_Task_Control_Block.\n+\n+private\n+\n+   type Lock is record\n+      L          : aliased System.OS_Interface.pthread_mutex_t;\n+      Ceiling    : Interfaces.C.int;\n+   end record;\n+\n+   type RTS_Lock is new System.OS_Interface.pthread_mutex_t;\n+   type Private_Data is record\n+      Thread      : aliased System.OS_Interface.pthread_t;\n+      pragma Atomic (Thread);\n+      --  Thread field may be updated by two different threads of control.\n+      --  (See, Enter_Task and Create_Task in s-taprop.adb).\n+      --  They put the same value (thr_self value). We do not want to\n+      --  use lock on those operations and the only thing we have to\n+      --  make sure is that they are updated in atomic fashion.\n+\n+      CV          : aliased System.OS_Interface.pthread_cond_t;\n+      L           : aliased RTS_Lock;\n+      --  protection for all components is lock L\n+   end record;\n+\n+end System.Task_Primitives;"}, {"sha": "ada9ee92dcbd20daaa2c425c5a7a07ff1b95c5d8", "filename": "gcc/ada/5atpopsp.adb", "status": "added", "additions": 279, "deletions": 0, "changes": 279, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5atpopsp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5atpopsp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5atpopsp.adb?ref=84481f762f0682e5f45b2f360446e1c7e333c880", "patch": "@@ -0,0 +1,279 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS               --\n+--                                                                          --\n+--    S Y S T E M . T A S K _ P R I M I T I V E S . O P E R A T I O N S .   --\n+--                              S P E C I F I C                             --\n+--                                                                          --\n+--                                  B o d y                                 --\n+--                                                                          --\n+--                             $Revision: 1.13 $\n+--                                                                          --\n+--            Copyright (C) 1991-2001, Florida State University             --\n+--                                                                          --\n+-- GNARL is free software; you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion. GNARL is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNARL; see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNARL was developed by the GNARL team at Florida State University. It is --\n+-- now maintained by Ada Core Technologies Inc. in cooperation with Florida --\n+-- State University (http://www.gnat.com).                                  --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is a POSIX version of this package where foreign threads are\n+--  recognized.\n+--  Currently, DEC Unix, SCO UnixWare, Solaris pthread, HPUX pthread and RTEMS\n+--  use this version.\n+\n+with System.Soft_Links;\n+--  used to initialize TSD for a C thread, in function Self\n+\n+separate (System.Task_Primitives.Operations)\n+package body Specific is\n+\n+   ------------------\n+   --  Local Data  --\n+   ------------------\n+\n+   --  The followings are logically constants, but need to be initialized\n+   --  at run time.\n+\n+   ATCB_Key : aliased pthread_key_t;\n+   --  Key used to find the Ada Task_ID associated with a thread\n+\n+   --  The following are used to allow the Self function to\n+   --  automatically generate ATCB's for C threads that happen to call\n+   --  Ada procedure, which in turn happen to call the Ada runtime system.\n+\n+   type Fake_ATCB;\n+   type Fake_ATCB_Ptr is access Fake_ATCB;\n+   type Fake_ATCB is record\n+      Stack_Base : Interfaces.C.unsigned := 0;\n+      --  A value of zero indicates the node is not in use.\n+      Next : Fake_ATCB_Ptr;\n+      Real_ATCB : aliased Ada_Task_Control_Block (0);\n+   end record;\n+\n+   Fake_ATCB_List : Fake_ATCB_Ptr;\n+   --  A linear linked list.\n+   --  The list is protected by All_Tasks_L;\n+   --  Nodes are added to this list from the front.\n+   --  Once a node is added to this list, it is never removed.\n+\n+   Fake_Task_Elaborated : aliased Boolean := True;\n+   --  Used to identified fake tasks (i.e., non-Ada Threads).\n+\n+   Next_Fake_ATCB : Fake_ATCB_Ptr;\n+   --  Used to allocate one Fake_ATCB in advance. See comment in New_Fake_ATCB\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   ---------------------------------\n+   --  Support for New_Fake_ATCB  --\n+   ---------------------------------\n+\n+   function New_Fake_ATCB return Task_ID;\n+   --  Allocate and Initialize a new ATCB. This code can safely be called from\n+   --  a foreign thread, as it doesn't access implicitely or explicitely\n+   --  \"self\" before having initialized the new ATCB.\n+\n+   -------------------\n+   -- New_Fake_ATCB --\n+   -------------------\n+\n+   function New_Fake_ATCB return Task_ID is\n+      Self_ID   : Task_ID;\n+      P, Q      : Fake_ATCB_Ptr;\n+      Succeeded : Boolean;\n+      Result    : Interfaces.C.int;\n+\n+   begin\n+      --  This section is ticklish.\n+      --  We dare not call anything that might require an ATCB, until\n+      --  we have the new ATCB in place.\n+\n+      Write_Lock (All_Tasks_L'Access);\n+      Q := null;\n+      P := Fake_ATCB_List;\n+\n+      while P /= null loop\n+         if P.Stack_Base = 0 then\n+            Q := P;\n+         end if;\n+\n+         P := P.Next;\n+      end loop;\n+\n+      if Q = null then\n+\n+         --  Create a new ATCB with zero entries.\n+\n+         Self_ID := Next_Fake_ATCB.Real_ATCB'Access;\n+         Next_Fake_ATCB.Stack_Base := 1;\n+         Next_Fake_ATCB.Next := Fake_ATCB_List;\n+         Fake_ATCB_List := Next_Fake_ATCB;\n+         Next_Fake_ATCB := null;\n+\n+      else\n+         --  Reuse an existing fake ATCB.\n+\n+         Self_ID := Q.Real_ATCB'Access;\n+         Q.Stack_Base := 1;\n+      end if;\n+\n+      --  Record this as the Task_ID for the current thread.\n+\n+      Self_ID.Common.LL.Thread := pthread_self;\n+      Result := pthread_setspecific (ATCB_Key, To_Address (Self_ID));\n+      pragma Assert (Result = 0);\n+\n+      --  Do the standard initializations\n+\n+      System.Tasking.Initialize_ATCB\n+        (Self_ID, null, Null_Address, Null_Task, Fake_Task_Elaborated'Access,\n+         System.Priority'First, Task_Info.Unspecified_Task_Info, 0, Self_ID,\n+         Succeeded);\n+      pragma Assert (Succeeded);\n+\n+      --  Finally, it is safe to use an allocator in this thread.\n+\n+      if Next_Fake_ATCB = null then\n+         Next_Fake_ATCB := new Fake_ATCB;\n+      end if;\n+\n+      Self_ID.Master_of_Task := 0;\n+      Self_ID.Master_Within := Self_ID.Master_of_Task + 1;\n+\n+      for L in Self_ID.Entry_Calls'Range loop\n+         Self_ID.Entry_Calls (L).Self := Self_ID;\n+         Self_ID.Entry_Calls (L).Level := L;\n+      end loop;\n+\n+      Self_ID.Common.State := Runnable;\n+      Self_ID.Awake_Count := 1;\n+\n+      --  Since this is not an ordinary Ada task, we will start out undeferred\n+\n+      Self_ID.Deferral_Level := 0;\n+\n+      System.Soft_Links.Create_TSD (Self_ID.Common.Compiler_Data);\n+\n+      --  ????\n+      --  The following call is commented out to avoid dependence on\n+      --  the System.Tasking.Initialization package.\n+      --  It seems that if we want Ada.Task_Attributes to work correctly\n+      --  for C threads we will need to raise the visibility of this soft\n+      --  link to System.Soft_Links.\n+      --  We are putting that off until this new functionality is otherwise\n+      --  stable.\n+      --  System.Tasking.Initialization.Initialize_Attributes_Link.all (T);\n+\n+      for J in Known_Tasks'Range loop\n+         if Known_Tasks (J) = null then\n+            Known_Tasks (J) := Self_ID;\n+            Self_ID.Known_Tasks_Index := J;\n+            exit;\n+         end if;\n+      end loop;\n+\n+      --  Must not unlock until Next_ATCB is again allocated.\n+\n+      Unlock (All_Tasks_L'Access);\n+      return Self_ID;\n+   end New_Fake_ATCB;\n+\n+   ----------------\n+   -- Initialize --\n+   ----------------\n+\n+   procedure Initialize (Environment_Task : Task_ID) is\n+      Result : Interfaces.C.int;\n+\n+   begin\n+      Result := pthread_key_create (ATCB_Key'Access, null);\n+      pragma Assert (Result = 0);\n+      Result := pthread_setspecific (ATCB_Key, To_Address (Environment_Task));\n+      pragma Assert (Result = 0);\n+\n+      --  Create a free ATCB for use on the Fake_ATCB_List.\n+\n+      Next_Fake_ATCB := new Fake_ATCB;\n+   end Initialize;\n+\n+   ---------\n+   -- Set --\n+   ---------\n+\n+   procedure Set (Self_Id : Task_ID) is\n+      Result  : Interfaces.C.int;\n+\n+   begin\n+      Result := pthread_setspecific (ATCB_Key, To_Address (Self_Id));\n+      pragma Assert (Result = 0);\n+   end Set;\n+\n+   ----------\n+   -- Self --\n+   ----------\n+\n+   --  To make Ada tasks and C threads interoperate better, we have\n+   --  added some functionality to Self.  Suppose a C main program\n+   --  (with threads) calls an Ada procedure and the Ada procedure\n+   --  calls the tasking runtime system.  Eventually, a call will be\n+   --  made to self.  Since the call is not coming from an Ada task,\n+   --  there will be no corresponding ATCB.\n+\n+   --  (The entire Ada run-time system may not have been elaborated,\n+   --  either, but that is a different problem, that we will need to\n+   --  solve another way.)\n+\n+   --  What we do in Self is to catch references that do not come\n+   --  from recognized Ada tasks, and create an ATCB for the calling\n+   --  thread.\n+\n+   --  The new ATCB will be \"detached\" from the normal Ada task\n+   --  master hierarchy, much like the existing implicitly created\n+   --  signal-server tasks.\n+\n+   --  We will also use such points to poll for disappearance of the\n+   --  threads associated with any implicit ATCBs that we created\n+   --  earlier, and take the opportunity to recover them.\n+\n+   --  A nasty problem here is the limitations of the compilation\n+   --  order dependency, and in particular the GNARL/GNULLI layering.\n+   --  To initialize an ATCB we need to assume System.Tasking has\n+   --  been elaborated.\n+\n+   function Self return Task_ID is\n+      Result : System.Address;\n+\n+   begin\n+      Result := pthread_getspecific (ATCB_Key);\n+\n+      --  If the key value is Null, then it is a non-Ada task.\n+\n+      if Result = System.Null_Address then\n+         return New_Fake_ATCB;\n+      end if;\n+\n+      return To_Task_ID (Result);\n+   end Self;\n+\n+end Specific;"}, {"sha": "eb8612ebe44e14d1525fedf56305bb57228800eb", "filename": "gcc/ada/5avxwork.ads", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5avxwork.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5avxwork.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5avxwork.ads?ref=84481f762f0682e5f45b2f360446e1c7e333c880", "patch": "@@ -0,0 +1,110 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                 GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS              --\n+--                                                                          --\n+--                        S Y S T E M . V X W O R K S                       --\n+--                                                                          --\n+--                                   S p e c                                --\n+--                                                                          --\n+--                             $Revision: 1.3 $                             --\n+--                                                                          --\n+--            Copyright (C) 1998-2001 Free Software Foundation              --\n+--                                                                          --\n+-- GNARL is free software; you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion. GNARL is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNARL; see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNARL was developed by the GNARL team at Florida State University. It is --\n+-- now maintained by Ada Core Technologies Inc. in cooperation with Florida --\n+-- State University (http://www.gnat.com).                                  --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is the Alpha VxWorks version of this package.\n+\n+with Interfaces.C;\n+\n+package System.VxWorks is\n+   pragma Preelaborate (System.VxWorks);\n+\n+   package IC renames Interfaces.C;\n+\n+   --  Define enough of a Wind Task Control Block in order to\n+   --  obtain the inherited priority.  When porting this to\n+   --  different versions of VxWorks (this is based on 5.3[.1]),\n+   --  be sure to look at the definition for WIND_TCB located\n+   --  in $WIND_BASE/target/h/taskLib.h\n+\n+   type Wind_Fill_1 is array (0 .. 16#77#) of IC.unsigned_char;\n+   type Wind_Fill_2 is array (16#80# .. 16#1c7#) of IC.unsigned_char;\n+   type Wind_Fill_3 is array (16#1d8# .. 16#777#) of IC.unsigned_char;\n+\n+   type Wind_TCB is record\n+      Fill_1          : Wind_Fill_1;  -- 0x00 - 0x77\n+      Priority        : IC.int;  -- 0x78 - 0x7b, current (inherited) priority\n+      Normal_Priority : IC.int;  -- 0x7c - 0x7f, base priority\n+      Fill_2          : Wind_Fill_2;  -- 0x80 - 0x1c7\n+      spare1          : Address;  -- 0x1c8 - 0x1cb\n+      spare2          : Address;  -- 0x1cc - 0x1cf\n+      spare3          : Address;  -- 0x1d0 - 0x1d3\n+      spare4          : Address;  -- 0x1d4 - 0x1d7\n+\n+      --  Fill_3 is much smaller on the board runtime, but the larger size\n+      --  below keeps this record compatible with vxsim.\n+\n+      Fill_3          : Wind_Fill_3;     -- 0x1d8 - 0x777\n+   end record;\n+   type Wind_TCB_Ptr is access Wind_TCB;\n+\n+\n+   --  Floating point context record.  Alpha version\n+\n+   FP_NUM_DREGS : constant := 32;\n+   type Fpx_Array is array (1 .. FP_NUM_DREGS) of IC.double;\n+\n+   type FP_CONTEXT is record\n+      fpx :   Fpx_Array;\n+      fpcsr : IC.long;\n+   end record;\n+   pragma Convention (C, FP_CONTEXT);\n+\n+   --  Number of entries in hardware interrupt vector table.  Value of\n+   --  0 disables hardware interrupt handling until it can be tested\n+   Num_HW_Interrupts : constant := 0;\n+\n+   --  VxWorks 5.3 and 5.4 version\n+   type TASK_DESC is record\n+      td_id           : IC.int;   --  task id\n+      td_name         : Address;  --  name of task\n+      td_priority     : IC.int;   --  task priority\n+      td_status       : IC.int;   --  task status\n+      td_options      : IC.int;   --  task option bits (see below)\n+      td_entry        : Address;  --  original entry point of task\n+      td_sp           : Address;  --  saved stack pointer\n+      td_pStackBase   : Address;  --  the bottom of the stack\n+      td_pStackLimit  : Address;  --  the effective end of the stack\n+      td_pStackEnd    : Address;  --  the actual end of the stack\n+      td_stackSize    : IC.int;   --  size of stack in bytes\n+      td_stackCurrent : IC.int;   --  current stack usage in bytes\n+      td_stackHigh    : IC.int;   --  maximum stack usage in bytes\n+      td_stackMargin  : IC.int;   --  current stack margin in bytes\n+      td_errorStatus  : IC.int;   --  most recent task error status\n+      td_delay        : IC.int;   --  delay/timeout ticks\n+   end record;\n+   pragma Convention (C, TASK_DESC);\n+\n+end System.VxWorks;"}, {"sha": "79062bb407b949d63c88e3af77b8e52e5b8ba6dd", "filename": "gcc/ada/5bosinte.adb", "status": "added", "additions": 155, "deletions": 0, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5bosinte.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5bosinte.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5bosinte.adb?ref=84481f762f0682e5f45b2f360446e1c7e333c880", "patch": "@@ -0,0 +1,155 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS               --\n+--                                                                          --\n+--                   S Y S T E M . O S _ I N T E R F A C E                  --\n+--                                                                          --\n+--                                  B o d y                                 --\n+--                                                                          --\n+--                              $Revision: 1.8 $\n+--                                                                          --\n+--             Copyright (C) 1997-2001, Florida State University            --\n+--                                                                          --\n+-- GNARL is free software; you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion. GNARL is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNARL; see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNARL was developed by the GNARL team at Florida State University. It is --\n+-- now maintained by Ada Core Technologies Inc. in cooperation with Florida --\n+-- State University (http://www.gnat.com).                                  --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is a AIX (Native) version of this package\n+\n+pragma Polling (Off);\n+--  Turn off polling, we do not want ATC polling to take place during\n+--  tasking operations. It causes infinite loops and other problems.\n+\n+with Interfaces.C;\n+\n+package body System.OS_Interface is\n+\n+   use Interfaces.C;\n+\n+   -----------------\n+   -- To_Duration --\n+   -----------------\n+\n+   function To_Duration (TS : timespec) return Duration is\n+   begin\n+      return Duration (TS.tv_sec) + Duration (TS.tv_nsec) / 10#1#E9;\n+   end To_Duration;\n+\n+   function To_Duration (TV : struct_timeval) return Duration is\n+   begin\n+      return Duration (TV.tv_sec) + Duration (TV.tv_usec) / 10#1#E6;\n+   end To_Duration;\n+\n+   -----------------\n+   -- To_Timespec --\n+   -----------------\n+\n+   function To_Timespec (D : Duration) return timespec is\n+      S : time_t;\n+      F : Duration;\n+\n+   begin\n+      S := time_t (Long_Long_Integer (D));\n+      F := D - Duration (S);\n+\n+      --  If F has negative value due to a round-up, adjust for positive F\n+      --  value.\n+\n+      if F < 0.0 then\n+         S := S - 1;\n+         F := F + 1.0;\n+      end if;\n+\n+      return timespec' (tv_sec => S,\n+        tv_nsec => long (Long_Long_Integer (F * 10#1#E9)));\n+   end To_Timespec;\n+\n+   ----------------\n+   -- To_Timeval --\n+   ----------------\n+\n+   function To_Timeval (D : Duration) return struct_timeval is\n+      S : long;\n+      F : Duration;\n+\n+   begin\n+      S := long (Long_Long_Integer (D));\n+      F := D - Duration (S);\n+\n+      --  If F has negative value due to a round-up, adjust for positive F\n+      --  value.\n+\n+      if F < 0.0 then\n+         S := S - 1;\n+         F := F + 1.0;\n+      end if;\n+\n+      return struct_timeval' (tv_sec => S,\n+        tv_usec => long (Long_Long_Integer (F * 10#1#E6)));\n+   end To_Timeval;\n+\n+   -------------------\n+   -- clock_gettime --\n+   -------------------\n+\n+   function clock_gettime\n+     (clock_id : clockid_t;\n+      tp       : access timespec)\n+      return int\n+   is\n+      Result : int;\n+      tv     : aliased struct_timeval;\n+\n+      function gettimeofday\n+        (tv : access struct_timeval;\n+         tz : System.Address := System.Null_Address) return int;\n+      pragma Import (C, gettimeofday, \"gettimeofday\");\n+\n+   begin\n+      Result := gettimeofday (tv'Unchecked_Access);\n+      tp.all := To_Timespec (To_Duration (tv));\n+      return Result;\n+   end clock_gettime;\n+\n+   -----------------\n+   -- sched_yield --\n+   -----------------\n+\n+   --  AIX Thread does not have sched_yield;\n+\n+   function sched_yield return int is\n+\n+      procedure pthread_yield;\n+      pragma Import (C, pthread_yield, \"pthread_yield\");\n+\n+   begin\n+      pthread_yield;\n+      return 0;\n+   end sched_yield;\n+\n+   function Get_Stack_Base (thread : pthread_t) return Address is\n+   begin\n+      return Null_Address;\n+   end Get_Stack_Base;\n+\n+end System.OS_Interface;"}, {"sha": "febce55b836cd98c0e2e0f6e861cb176a8f2561e", "filename": "gcc/ada/5bosinte.ads", "status": "added", "additions": 582, "deletions": 0, "changes": 582, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5bosinte.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5bosinte.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5bosinte.ads?ref=84481f762f0682e5f45b2f360446e1c7e333c880", "patch": "@@ -0,0 +1,582 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS               --\n+--                                                                          --\n+--                   S Y S T E M . O S _ I N T E R F A C E                  --\n+--                                                                          --\n+--                                  S p e c                                 --\n+--                                                                          --\n+--                             $Revision: 1.26 $\n+--                                                                          --\n+--          Copyright (C) 1997-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNARL is free software; you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion. GNARL is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNARL; see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNARL was developed by the GNARL team at Florida State University. It is --\n+-- now maintained by Ada Core Technologies Inc. in cooperation with Florida --\n+-- State University (http://www.gnat.com).                                  --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is a AIX (Native THREADS) version of this package.\n+\n+--  This package encapsulates all direct interfaces to OS services\n+--  that are needed by children of System.\n+\n+--  PLEASE DO NOT add any with-clauses to this package\n+--  or remove the pragma Elaborate_Body.\n+--  It is designed to be a bottom-level (leaf) package.\n+\n+with Interfaces.C;\n+package System.OS_Interface is\n+   pragma Preelaborate;\n+\n+   pragma Linker_Options (\"-lpthreads\");\n+   pragma Linker_Options (\"-lc_r\");\n+\n+   subtype int            is Interfaces.C.int;\n+   subtype short          is Interfaces.C.short;\n+   subtype long           is Interfaces.C.long;\n+   subtype unsigned       is Interfaces.C.unsigned;\n+   subtype unsigned_short is Interfaces.C.unsigned_short;\n+   subtype unsigned_long  is Interfaces.C.unsigned_long;\n+   subtype unsigned_char  is Interfaces.C.unsigned_char;\n+   subtype plain_char     is Interfaces.C.plain_char;\n+   subtype size_t         is Interfaces.C.size_t;\n+\n+   -----------\n+   -- Errno --\n+   -----------\n+\n+   function errno return int;\n+   pragma Import (C, errno, \"__get_errno\");\n+\n+   EAGAIN    : constant := 11;\n+   EINTR     : constant := 4;\n+   EINVAL    : constant := 22;\n+   ENOMEM    : constant := 12;\n+   ETIMEDOUT : constant := 78;\n+\n+   -------------\n+   -- Signals --\n+   -------------\n+\n+   Max_Interrupt : constant := 63;\n+   type Signal is new int range 0 .. Max_Interrupt;\n+   for Signal'Size use int'Size;\n+\n+   SIGHUP      : constant := 1; --  hangup\n+   SIGINT      : constant := 2; --  interrupt (rubout)\n+   SIGQUIT     : constant := 3; --  quit (ASCD FS)\n+   SIGILL      : constant := 4; --  illegal instruction (not reset)\n+   SIGTRAP     : constant := 5; --  trace trap (not reset)\n+   SIGIOT      : constant := 6; --  IOT instruction\n+   SIGABRT     : constant := 6; --  used by abort, replace SIGIOT in the future\n+   SIGEMT      : constant := 7; --  EMT instruction\n+   SIGFPE      : constant := 8; --  floating point exception\n+   SIGKILL     : constant := 9; --  kill (cannot be caught or ignored)\n+   SIGBUS      : constant := 10; --  bus error\n+   SIGSEGV     : constant := 11; --  segmentation violation\n+   SIGSYS      : constant := 12; --  bad argument to system call\n+   SIGPIPE     : constant := 13; --  write on a pipe with no one to read it\n+   SIGALRM     : constant := 14; --  alarm clock\n+   SIGTERM     : constant := 15; --  software termination signal from kill\n+   SIGUSR1     : constant := 30; --  user defined signal 1\n+   SIGUSR2     : constant := 31; --  user defined signal 2\n+   SIGCLD      : constant := 20; --  alias for SIGCHLD\n+   SIGCHLD     : constant := 20; --  child status change\n+   SIGPWR      : constant := 29; --  power-fail restart\n+   SIGWINCH    : constant := 28; --  window size change\n+   SIGURG      : constant := 16; --  urgent condition on IO channel\n+   SIGPOLL     : constant := 23; --  pollable event occurred\n+   SIGIO       : constant := 23; --  I/O possible (Solaris SIGPOLL alias)\n+   SIGSTOP     : constant := 17; --  stop (cannot be caught or ignored)\n+   SIGTSTP     : constant := 18; --  user stop requested from tty\n+   SIGCONT     : constant := 19; --  stopped process has been continued\n+   SIGTTIN     : constant := 21; --  background tty read attempted\n+   SIGTTOU     : constant := 22; --  background tty write attempted\n+   SIGVTALRM   : constant := 34; --  virtual timer expired\n+   SIGPROF     : constant := 32; --  profiling timer expired\n+   SIGXCPU     : constant := 24; --  CPU time limit exceeded\n+   SIGXFSZ     : constant := 25; --  filesize limit exceeded\n+   SIGWAITING  : constant := 39; --  m:n scheduling\n+\n+   --  the following signals are AIX specific\n+   SIGMSG      : constant := 27; -- input data is in the ring buffer\n+   SIGDANGER   : constant := 33; -- system crash imminent\n+   SIGMIGRATE  : constant := 35; -- migrate process\n+   SIGPRE      : constant := 36; -- programming exception\n+   SIGVIRT     : constant := 37; -- AIX virtual time alarm\n+   SIGALRM1    : constant := 38; -- m:n condition variables\n+   SIGKAP      : constant := 60; -- keep alive poll from native keyboard\n+   SIGGRANT    : constant := SIGKAP; -- monitor mode granted\n+   SIGRETRACT  : constant := 61; -- monitor mode should be relinguished\n+   SIGSOUND    : constant := 62; -- sound control has completed\n+   SIGSAK      : constant := 63; -- secure attention key\n+\n+   SIGADAABORT : constant := SIGTERM;\n+   --  Note: on other targets, we usually use SIGABRT, but on AiX, it\n+   --  appears that SIGABRT can't be used in sigwait(), so we use SIGTERM.\n+\n+   type Signal_Set is array (Natural range <>) of Signal;\n+\n+   Unmasked    : constant Signal_Set :=\n+     (SIGTRAP, SIGTTIN, SIGTTOU, SIGTSTP, SIGPROF);\n+   Reserved    : constant Signal_Set := (SIGABRT, SIGKILL, SIGSTOP);\n+\n+   type sigset_t is private;\n+\n+   function sigaddset (set : access sigset_t; sig : Signal) return int;\n+   pragma Import (C, sigaddset, \"sigaddset\");\n+\n+   function sigdelset (set : access sigset_t; sig : Signal) return int;\n+   pragma Import (C, sigdelset, \"sigdelset\");\n+\n+   function sigfillset (set : access sigset_t) return int;\n+   pragma Import (C, sigfillset, \"sigfillset\");\n+\n+   function sigismember (set : access sigset_t; sig : Signal) return int;\n+   pragma Import (C, sigismember, \"sigismember\");\n+\n+   function sigemptyset (set : access sigset_t) return int;\n+   pragma Import (C, sigemptyset, \"sigemptyset\");\n+\n+   type struct_sigaction is record\n+      sa_handler : System.Address;\n+      sa_mask    : sigset_t;\n+      sa_flags   : int;\n+   end record;\n+   pragma Convention (C, struct_sigaction);\n+   type struct_sigaction_ptr is access all struct_sigaction;\n+\n+\n+   SIG_BLOCK   : constant := 0;\n+   SIG_UNBLOCK : constant := 1;\n+   SIG_SETMASK : constant := 2;\n+\n+   SIG_DFL : constant := 0;\n+   SIG_IGN : constant := 1;\n+\n+   function sigaction\n+     (sig  : Signal;\n+      act  : struct_sigaction_ptr;\n+      oact : struct_sigaction_ptr) return int;\n+   pragma Import (C, sigaction, \"sigaction\");\n+\n+   ----------\n+   -- Time --\n+   ----------\n+\n+   Time_Slice_Supported : constant Boolean := False;\n+   --  Indicates wether time slicing is supported\n+\n+   type timespec is private;\n+\n+   type clockid_t is private;\n+\n+   CLOCK_REALTIME : constant clockid_t;\n+\n+   function clock_gettime\n+     (clock_id : clockid_t;\n+      tp       : access timespec) return int;\n+   --  AiX threads don't have clock_gettime\n+   --  We instead use gettimeofday()\n+\n+   function To_Duration (TS : timespec) return Duration;\n+   pragma Inline (To_Duration);\n+\n+   function To_Timespec (D : Duration) return timespec;\n+   pragma Inline (To_Timespec);\n+\n+   type struct_timezone is record\n+      tz_minuteswest : int;\n+      tz_dsttime     : int;\n+   end record;\n+   pragma Convention (C, struct_timezone);\n+   type struct_timezone_ptr is access all struct_timezone;\n+\n+   type struct_timeval is private;\n+   --  This is needed on systems that do not have clock_gettime()\n+   --  but do have gettimeofday().\n+\n+   function To_Duration (TV : struct_timeval) return Duration;\n+   pragma Inline (To_Duration);\n+\n+   function To_Timeval (D : Duration) return struct_timeval;\n+   pragma Inline (To_Timeval);\n+\n+   -------------------------\n+   -- Priority Scheduling --\n+   -------------------------\n+\n+   SCHED_FIFO  : constant := 1;\n+   SCHED_RR    : constant := 2;\n+   SCHED_OTHER : constant := 0;\n+\n+   -------------\n+   -- Process --\n+   -------------\n+\n+   type pid_t is private;\n+\n+   function kill (pid : pid_t; sig : Signal) return int;\n+   pragma Import (C, kill, \"kill\");\n+\n+   function getpid return pid_t;\n+   pragma Import (C, getpid, \"getpid\");\n+\n+   ---------\n+   -- LWP --\n+   ---------\n+\n+   function lwp_self return System.Address;\n+   pragma Import (C, lwp_self, \"thread_self\");\n+\n+   -------------\n+   -- Threads --\n+   -------------\n+\n+   type Thread_Body is access\n+     function (arg : System.Address) return System.Address;\n+   type pthread_t           is private;\n+   subtype Thread_Id        is pthread_t;\n+\n+   type pthread_mutex_t     is limited private;\n+   type pthread_cond_t      is limited private;\n+   type pthread_attr_t      is limited private;\n+   type pthread_mutexattr_t is limited private;\n+   type pthread_condattr_t  is limited private;\n+   type pthread_key_t       is private;\n+\n+   PTHREAD_CREATE_DETACHED : constant := 1;\n+\n+   -----------\n+   -- Stack --\n+   -----------\n+\n+   Stack_Base_Available : constant Boolean := False;\n+   --  Indicates wether the stack base is available on this target.\n+\n+   function Get_Stack_Base (thread : pthread_t) return Address;\n+   pragma Inline (Get_Stack_Base);\n+   --  returns the stack base of the specified thread.\n+   --  Only call this function when Stack_Base_Available is True.\n+\n+   function Get_Page_Size return size_t;\n+   function Get_Page_Size return Address;\n+   pragma Import (C, Get_Page_Size, \"getpagesize\");\n+   --  returns the size of a page, or 0 if this is not relevant on this\n+   --  target\n+\n+   PROT_NONE  : constant := 0;\n+   PROT_READ  : constant := 1;\n+   PROT_WRITE : constant := 2;\n+   PROT_EXEC  : constant := 4;\n+   PROT_ALL   : constant := PROT_READ + PROT_WRITE + PROT_EXEC;\n+\n+   PROT_ON    : constant := PROT_READ;\n+   PROT_OFF   : constant := PROT_ALL;\n+\n+   function mprotect (addr : Address; len : size_t; prot : int) return int;\n+   pragma Import (C, mprotect);\n+\n+   ---------------------------------------\n+   -- Nonstandard Thread Initialization --\n+   ---------------------------------------\n+\n+   --  Though not documented, pthread_init *must* be called before any other\n+   --  pthread call\n+\n+   procedure pthread_init;\n+   pragma Import (C, pthread_init, \"pthread_init\");\n+\n+   -------------------------\n+   -- POSIX.1c  Section 3 --\n+   -------------------------\n+\n+   function sigwait\n+     (set : access sigset_t;\n+      sig : access Signal) return int;\n+   pragma Import (C, sigwait, \"sigwait\");\n+\n+   function pthread_kill\n+     (thread : pthread_t;\n+      sig    : Signal) return int;\n+   pragma Import (C, pthread_kill, \"pthread_kill\");\n+\n+   type sigset_t_ptr is access all sigset_t;\n+\n+   function pthread_sigmask\n+     (how  : int;\n+      set  : sigset_t_ptr;\n+      oset : sigset_t_ptr) return int;\n+   pragma Import (C, pthread_sigmask, \"sigthreadmask\");\n+\n+   --------------------------\n+   -- POSIX.1c  Section 11 --\n+   --------------------------\n+\n+   function pthread_mutexattr_init\n+     (attr : access pthread_mutexattr_t) return int;\n+   pragma Import (C, pthread_mutexattr_init, \"pthread_mutexattr_init\");\n+\n+   function pthread_mutexattr_destroy\n+     (attr : access pthread_mutexattr_t) return int;\n+   pragma Import (C, pthread_mutexattr_destroy, \"pthread_mutexattr_destroy\");\n+\n+   function pthread_mutex_init\n+     (mutex : access pthread_mutex_t;\n+      attr  : access pthread_mutexattr_t) return int;\n+   pragma Import (C, pthread_mutex_init, \"pthread_mutex_init\");\n+\n+   function pthread_mutex_destroy (mutex : access pthread_mutex_t) return int;\n+   pragma Import (C, pthread_mutex_destroy, \"pthread_mutex_destroy\");\n+\n+   function pthread_mutex_lock (mutex : access pthread_mutex_t) return int;\n+   pragma Import (C, pthread_mutex_lock, \"pthread_mutex_lock\");\n+\n+   function pthread_mutex_unlock (mutex : access pthread_mutex_t) return int;\n+   pragma Import (C, pthread_mutex_unlock, \"pthread_mutex_unlock\");\n+\n+   function pthread_condattr_init\n+     (attr : access pthread_condattr_t) return int;\n+   pragma Import (C, pthread_condattr_init, \"pthread_condattr_init\");\n+\n+   function pthread_condattr_destroy\n+     (attr : access pthread_condattr_t) return int;\n+   pragma Import (C, pthread_condattr_destroy, \"pthread_condattr_destroy\");\n+\n+   function pthread_cond_init\n+     (cond : access pthread_cond_t;\n+      attr : access pthread_condattr_t) return int;\n+   pragma Import (C, pthread_cond_init, \"pthread_cond_init\");\n+\n+   function pthread_cond_destroy (cond : access pthread_cond_t) return int;\n+   pragma Import (C, pthread_cond_destroy, \"pthread_cond_destroy\");\n+\n+   function pthread_cond_signal (cond : access pthread_cond_t) return int;\n+   pragma Import (C, pthread_cond_signal, \"pthread_cond_signal\");\n+\n+   function pthread_cond_wait\n+     (cond  : access pthread_cond_t;\n+      mutex : access pthread_mutex_t) return int;\n+   pragma Import (C, pthread_cond_wait, \"pthread_cond_wait\");\n+\n+   function pthread_cond_timedwait\n+     (cond    : access pthread_cond_t;\n+      mutex   : access pthread_mutex_t;\n+      abstime : access timespec) return int;\n+   pragma Import (C, pthread_cond_timedwait, \"pthread_cond_timedwait\");\n+\n+   Relative_Timed_Wait : constant Boolean := False;\n+   --  pthread_cond_timedwait requires an absolute delay time\n+\n+   ----------------------------\n+   --  POSIX.1c  Section 13  --\n+   ----------------------------\n+\n+   PTHREAD_PRIO_NONE    : constant := 0;\n+   PTHREAD_PRIO_PROTECT : constant := 0;\n+   PTHREAD_PRIO_INHERIT : constant := 0;\n+\n+   function pthread_mutexattr_setprotocol\n+     (attr     : access pthread_mutexattr_t;\n+      protocol : int) return int;\n+   pragma Import (C, pthread_mutexattr_setprotocol);\n+\n+   function pthread_mutexattr_setprioceiling\n+     (attr        : access pthread_mutexattr_t;\n+      prioceiling : int) return int;\n+   pragma Import (C, pthread_mutexattr_setprioceiling);\n+\n+   type Array_5_Int is array (0 .. 5) of int;\n+   type struct_sched_param is record\n+      sched_priority : int;\n+      sched_policy   : int;\n+      sched_reserved : Array_5_Int;\n+   end record;\n+\n+   function pthread_setschedparam\n+     (thread : pthread_t;\n+      policy : int;\n+      param  : access struct_sched_param) return int;\n+   pragma Import (C, pthread_setschedparam, \"pthread_setschedparam\");\n+\n+   function pthread_attr_setscope\n+     (attr            : access pthread_attr_t;\n+      contentionscope : int) return int;\n+   pragma Import (C, pthread_attr_setscope, \"pthread_attr_setscope\");\n+\n+   function pthread_attr_setinheritsched\n+     (attr            : access pthread_attr_t;\n+      inheritsched : int) return int;\n+   pragma Import (C, pthread_attr_setinheritsched);\n+\n+   function pthread_attr_setschedpolicy\n+     (attr   : access pthread_attr_t;\n+      policy : int) return int;\n+   pragma Import (C, pthread_attr_setschedpolicy);\n+\n+   function pthread_attr_setschedparam\n+     (attr        : access pthread_attr_t;\n+      sched_param : int) return int;\n+   pragma Import (C, pthread_attr_setschedparam);\n+\n+   function sched_yield return int;\n+   --  AiX have a nonstandard sched_yield.\n+\n+   ---------------------------\n+   -- P1003.1c - Section 16 --\n+   ---------------------------\n+\n+   function pthread_attr_init (attributes : access pthread_attr_t) return int;\n+   pragma Import (C, pthread_attr_init, \"pthread_attr_init\");\n+\n+   function pthread_attr_destroy\n+     (attributes : access pthread_attr_t) return int;\n+   pragma Import (C, pthread_attr_destroy, \"pthread_attr_destroy\");\n+\n+   function pthread_attr_setdetachstate\n+     (attr        : access pthread_attr_t;\n+      detachstate : int) return int;\n+   pragma Import (C, pthread_attr_setdetachstate);\n+\n+   function pthread_attr_setstacksize\n+     (attr      : access pthread_attr_t;\n+      stacksize : size_t) return int;\n+   pragma Import (C, pthread_attr_setstacksize);\n+\n+   function pthread_create\n+     (thread        : access pthread_t;\n+      attributes    : access pthread_attr_t;\n+      start_routine : Thread_Body;\n+      arg           : System.Address)\n+     return int;\n+   pragma Import (C, pthread_create, \"pthread_create\");\n+\n+   procedure pthread_exit (status : System.Address);\n+   pragma Import (C, pthread_exit, \"pthread_exit\");\n+\n+   function pthread_self return pthread_t;\n+   pragma Import (C, pthread_self, \"pthread_self\");\n+\n+   --------------------------\n+   -- POSIX.1c  Section 17 --\n+   --------------------------\n+\n+   function pthread_setspecific\n+     (key   : pthread_key_t;\n+      value : System.Address) return int;\n+   pragma Import (C, pthread_setspecific, \"pthread_setspecific\");\n+\n+   function pthread_getspecific (key : pthread_key_t) return System.Address;\n+   pragma Import (C, pthread_getspecific, \"pthread_getspecific\");\n+\n+   type destructor_pointer is access\n+      procedure (arg : System.Address);\n+\n+   function pthread_key_create\n+     (key        : access pthread_key_t;\n+      destructor : destructor_pointer) return int;\n+   pragma Import (C, pthread_key_create, \"pthread_key_create\");\n+\n+private\n+\n+   type sigset_t is record\n+      losigs : unsigned_long;\n+      hisigs : unsigned_long;\n+   end record;\n+   pragma Convention (C_Pass_By_Copy, sigset_t);\n+\n+   type pid_t is new int;\n+\n+   type time_t is new long;\n+\n+   type timespec is record\n+      tv_sec  : time_t;\n+      tv_nsec : long;\n+   end record;\n+   pragma Convention (C, timespec);\n+\n+   type clockid_t is new int;\n+   CLOCK_REALTIME : constant clockid_t := 0;\n+\n+   type struct_timeval is record\n+      tv_sec  : long;\n+      tv_usec : long;\n+   end record;\n+   pragma Convention (C, struct_timeval);\n+\n+   type pthread_attr_t is new System.Address;\n+   pragma Convention (C, pthread_attr_t);\n+   --  typedef struct __pt_attr        *pthread_attr_t;\n+\n+   type pthread_condattr_t is new System.Address;\n+   pragma Convention (C, pthread_condattr_t);\n+   --  typedef struct __pt_attr        *pthread_condattr_t;\n+\n+   type pthread_mutexattr_t is new System.Address;\n+   pragma Convention (C, pthread_mutexattr_t);\n+   --  typedef struct __pt_attr        *pthread_mutexattr_t;\n+\n+   type pthread_t is new System.Address;\n+   pragma Convention (C, pthread_t);\n+   --  typedef void    *pthread_t;\n+\n+   type ptq_queue;\n+   type ptq_queue_ptr is access all ptq_queue;\n+\n+   type ptq_queue is record\n+      ptq_next : ptq_queue_ptr;\n+      ptq_prev : ptq_queue_ptr;\n+   end record;\n+\n+   type Array_3_Int is array (0 .. 3) of int;\n+   type pthread_mutex_t is record\n+        link        : ptq_queue;\n+        ptmtx_lock  : int;\n+        ptmtx_flags : long;\n+        protocol    : int;\n+        prioceiling : int;\n+        ptmtx_owner : pthread_t;\n+        mtx_id      : int;\n+        attr        : pthread_attr_t;\n+        mtx_kind    : int;\n+        lock_cpt    : int;\n+        reserved    : Array_3_Int;\n+   end record;\n+   pragma Convention (C, pthread_mutex_t);\n+   type pthread_mutex_t_ptr is access pthread_mutex_t;\n+\n+   type pthread_cond_t is record\n+      link         : ptq_queue;\n+      ptcv_lock    : int;\n+      ptcv_flags   : long;\n+      ptcv_waiters : ptq_queue;\n+      cv_id        : int;\n+      attr         : pthread_attr_t;\n+      mutex        : pthread_mutex_t_ptr;\n+      cptwait      : int;\n+      reserved     : int;\n+   end record;\n+   pragma Convention (C, pthread_cond_t);\n+\n+   type pthread_key_t is new unsigned;\n+\n+end System.OS_Interface;"}, {"sha": "677db87fd40871c325428317666a2c410d77c23a", "filename": "gcc/ada/5bsystem.ads", "status": "added", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5bsystem.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5bsystem.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5bsystem.ads?ref=84481f762f0682e5f45b2f360446e1c7e333c880", "patch": "@@ -0,0 +1,151 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                        GNAT RUN-TIME COMPONENTS                          --\n+--                                                                          --\n+--                               S Y S T E M                                --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                            (AIX/PPC Version)\n+--                                                                          --\n+--                            $Revision: 1.4 $\n+--                                                                          --\n+--          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+package System is\n+pragma Pure (System);\n+--  Note that we take advantage of the implementation permission to\n+--  make this unit Pure instead of Preelaborable, see RM 13.7(36)\n+\n+   type Name is (SYSTEM_NAME_GNAT);\n+   System_Name : constant Name := SYSTEM_NAME_GNAT;\n+\n+   --  System-Dependent Named Numbers\n+\n+   Min_Int               : constant := Long_Long_Integer'First;\n+   Max_Int               : constant := Long_Long_Integer'Last;\n+\n+   Max_Binary_Modulus    : constant := 2 ** Long_Long_Integer'Size;\n+   Max_Nonbinary_Modulus : constant := Integer'Last;\n+\n+   Max_Base_Digits       : constant := Long_Long_Float'Digits;\n+   Max_Digits            : constant := Long_Long_Float'Digits;\n+\n+   Max_Mantissa          : constant := 63;\n+   Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);\n+\n+   Tick                  : constant := Standard'Tick;\n+\n+   --  Storage-related Declarations\n+\n+   type Address is private;\n+   Null_Address : constant Address;\n+\n+   Storage_Unit : constant := Standard'Storage_Unit;\n+   Word_Size    : constant := Standard'Word_Size;\n+   Memory_Size  : constant := 2 ** Standard'Address_Size;\n+\n+   --  Address comparison\n+\n+   function \"<\"  (Left, Right : Address) return Boolean;\n+   function \"<=\" (Left, Right : Address) return Boolean;\n+   function \">\"  (Left, Right : Address) return Boolean;\n+   function \">=\" (Left, Right : Address) return Boolean;\n+   function \"=\"  (Left, Right : Address) return Boolean;\n+\n+   pragma Import (Intrinsic, \"<\");\n+   pragma Import (Intrinsic, \"<=\");\n+   pragma Import (Intrinsic, \">\");\n+   pragma Import (Intrinsic, \">=\");\n+   pragma Import (Intrinsic, \"=\");\n+\n+   --  Other System-Dependent Declarations\n+\n+   type Bit_Order is (High_Order_First, Low_Order_First);\n+   Default_Bit_Order : constant Bit_Order :=\n+                         Bit_Order'Val (Standard'Default_Bit_Order);\n+\n+   --  Priority-related Declarations (RM D.1)\n+\n+   Max_Priority : constant Positive := 30;\n+\n+   Max_Interrupt_Priority : constant Positive := 31;\n+\n+   subtype Any_Priority is Integer\n+     range 0 .. Standard'Max_Interrupt_Priority;\n+\n+   subtype Priority is Any_Priority\n+     range 0 .. Standard'Max_Priority;\n+\n+   --  Functional notation is needed in the following to avoid visibility\n+   --  problems when this package is compiled through rtsfind in the middle\n+   --  of another compilation.\n+\n+   subtype Interrupt_Priority is Any_Priority\n+     range\n+       Standard.\"+\" (Standard'Max_Priority,  1) ..\n+         Standard'Max_Interrupt_Priority;\n+\n+   Default_Priority : constant Priority :=\n+     Standard.\"/\" (Standard.\"+\" (Priority'First, Priority'Last), 2);\n+\n+private\n+\n+   type Address is mod Memory_Size;\n+   Null_Address : constant Address := 0;\n+\n+   --------------------------------------\n+   -- System Implementation Parameters --\n+   --------------------------------------\n+\n+   --  These parameters provide information about the target that is used\n+   --  by the compiler. They are in the private part of System, where they\n+   --  can be accessed using the special circuitry in the Targparm unit\n+   --  whose source should be consulted for more detailed descriptions\n+   --  of the individual switch values.\n+\n+   AAMP                      : constant Boolean := False;\n+   Command_Line_Args         : constant Boolean := True;\n+   Denorm                    : constant Boolean := True;\n+   Frontend_Layout           : constant Boolean := False;\n+   Functions_Return_By_DSP   : constant Boolean := False;\n+   Long_Shifts_Inlined       : constant Boolean := True;\n+   High_Integrity_Mode       : constant Boolean := False;\n+   Machine_Overflows         : constant Boolean := False;\n+   Machine_Rounds            : constant Boolean := True;\n+   OpenVMS                   : constant Boolean := False;\n+   Signed_Zeros              : constant Boolean := True;\n+   Stack_Check_Default       : constant Boolean := False;\n+   Stack_Check_Probes        : constant Boolean := False;\n+   Use_Ada_Main_Program_Name : constant Boolean := False;\n+   ZCX_By_Default            : constant Boolean := False;\n+   GCC_ZCX_Support           : constant Boolean := False;\n+   Front_End_ZCX_Support     : constant Boolean := False;\n+\n+end System;"}, {"sha": "5c57e2c47af33d3f3373755c29c62d63399d132d", "filename": "gcc/ada/5cosinte.ads", "status": "added", "additions": 584, "deletions": 0, "changes": 584, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5cosinte.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5cosinte.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5cosinte.ads?ref=84481f762f0682e5f45b2f360446e1c7e333c880", "patch": "@@ -0,0 +1,584 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS               --\n+--                                                                          --\n+--                   S Y S T E M . O S _ I N T E R F A C E                  --\n+--                                                                          --\n+--                                  S p e c                                 --\n+--                                                                          --\n+--                             $Revision: 1.18 $\n+--                                                                          --\n+--          Copyright (C) 1998-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNARL is free software; you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion. GNARL is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNARL; see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNARL was developed by the GNARL team at Florida State University. It is --\n+-- now maintained by Ada Core Technologies Inc. in cooperation with Florida --\n+-- State University (http://www.gnat.com).                                  --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is a AIX (FSU THREADS) version of this package.\n+\n+--  This package encapsulates all direct interfaces to OS services\n+--  that are needed by children of System.\n+\n+--  PLEASE DO NOT add any with-clauses to this package\n+--  or remove the pragma Elaborate_Body.\n+--  It is designed to be a bottom-level (leaf) package.\n+\n+with Interfaces.C;\n+package System.OS_Interface is\n+   pragma Preelaborate;\n+   --  pragma Elaborate_Body;\n+\n+   pragma Linker_Options (\"-lgthreads\");\n+   pragma Linker_Options (\"-lmalloc\");\n+\n+   subtype int            is Interfaces.C.int;\n+   subtype short          is Interfaces.C.short;\n+   subtype long           is Interfaces.C.long;\n+   subtype unsigned       is Interfaces.C.unsigned;\n+   subtype unsigned_short is Interfaces.C.unsigned_short;\n+   subtype unsigned_long  is Interfaces.C.unsigned_long;\n+   subtype unsigned_char  is Interfaces.C.unsigned_char;\n+   subtype plain_char     is Interfaces.C.plain_char;\n+   subtype size_t         is Interfaces.C.size_t;\n+\n+   -----------\n+   -- Errno --\n+   -----------\n+\n+   function errno return int;\n+   pragma Import (C, errno, \"__get_errno\");\n+\n+   EAGAIN    : constant := 11;\n+   EINTR     : constant := 4;\n+   EINVAL    : constant := 22;\n+   ENOMEM    : constant := 12;\n+   ETIMEDOUT : constant := 78;\n+\n+   -------------\n+   -- Signals --\n+   -------------\n+\n+   Max_Interrupt : constant := 63;\n+   type Signal is new int range 0 .. Max_Interrupt;\n+   for Signal'Size use int'Size;\n+\n+   SIGHUP      : constant := 1; --  hangup\n+   SIGINT      : constant := 2; --  interrupt (rubout)\n+   SIGQUIT     : constant := 3; --  quit (ASCD FS)\n+   SIGILL      : constant := 4; --  illegal instruction (not reset)\n+   SIGTRAP     : constant := 5; --  trace trap (not reset)\n+   SIGIOT      : constant := 6; --  IOT instruction\n+   SIGABRT     : constant := 6; --  used by abort, replace SIGIOT in the future\n+   SIGEMT      : constant := 7; --  EMT instruction\n+   SIGFPE      : constant := 8; --  floating point exception\n+   SIGKILL     : constant := 9; --  kill (cannot be caught or ignored)\n+   SIGBUS      : constant := 10; --  bus error\n+   SIGSEGV     : constant := 11; --  segmentation violation\n+   SIGSYS      : constant := 12; --  bad argument to system call\n+   SIGPIPE     : constant := 13; --  write on a pipe with no one to read it\n+   SIGALRM     : constant := 14; --  alarm clock\n+   SIGTERM     : constant := 15; --  software termination signal from kill\n+   SIGUSR1     : constant := 30; --  user defined signal 1\n+   SIGUSR2     : constant := 31; --  user defined signal 2\n+   SIGCLD      : constant := 20; --  alias for SIGCHLD\n+   SIGCHLD     : constant := 20; --  child status change\n+   SIGPWR      : constant := 29; --  power-fail restart\n+   SIGWINCH    : constant := 28; --  window size change\n+   SIGURG      : constant := 16; --  urgent condition on IO channel\n+   SIGPOLL     : constant := 23; --  pollable event occurred\n+   SIGIO       : constant := 23; --  I/O possible (Solaris SIGPOLL alias)\n+   SIGSTOP     : constant := 17; --  stop (cannot be caught or ignored)\n+   SIGTSTP     : constant := 18; --  user stop requested from tty\n+   SIGCONT     : constant := 19; --  stopped process has been continued\n+   SIGTTIN     : constant := 21; --  background tty read attempted\n+   SIGTTOU     : constant := 22; --  background tty write attempted\n+   SIGVTALRM   : constant := 34; --  virtual timer expired\n+   SIGPROF     : constant := 32; --  profiling timer expired\n+   SIGXCPU     : constant := 24; --  CPU time limit exceeded\n+   SIGXFSZ     : constant := 25; --  filesize limit exceeded\n+   SIGWAITING  : constant := 39; --  m:n scheduling\n+\n+   --  the following signals are AIX specific\n+   SIGMSG      : constant := 27; -- input data is in the ring buffer\n+   SIGDANGER   : constant := 33; -- system crash imminent\n+   SIGMIGRATE  : constant := 35; -- migrate process\n+   SIGPRE      : constant := 36; -- programming exception\n+   SIGVIRT     : constant := 37; -- AIX virtual time alarm\n+   SIGALRM1    : constant := 38; -- m:n condition variables\n+   SIGKAP      : constant := 60; -- keep alive poll from native keyboard\n+   SIGGRANT    : constant := SIGKAP; -- monitor mode granted\n+   SIGRETRACT  : constant := 61; -- monitor mode should be relinguished\n+   SIGSOUND    : constant := 62; -- sound control has completed\n+   SIGSAK      : constant := 63; -- secure attention key\n+\n+   SIGADAABORT : constant := SIGABRT;\n+\n+   type Signal_Set is array (Natural range <>) of Signal;\n+\n+   Unmasked    : constant Signal_Set :=\n+     (SIGTRAP, SIGTTIN, SIGTTOU, SIGTSTP, SIGPROF);\n+   Reserved    : constant Signal_Set :=\n+     (SIGKILL, SIGSTOP, SIGALRM, SIGWAITING);\n+\n+   type sigset_t is private;\n+\n+   function sigaddset (set : access sigset_t; sig : Signal) return int;\n+   pragma Import (C, sigaddset, \"sigaddset\");\n+\n+   function sigdelset (set : access sigset_t; sig : Signal) return int;\n+   pragma Import (C, sigdelset, \"sigdelset\");\n+\n+   function sigfillset (set : access sigset_t) return int;\n+   pragma Import (C, sigfillset, \"sigfillset\");\n+\n+   function sigismember (set : access sigset_t; sig : Signal) return int;\n+   pragma Import (C, sigismember, \"sigismember\");\n+\n+   function sigemptyset (set : access sigset_t) return int;\n+   pragma Import (C, sigemptyset, \"sigemptyset\");\n+\n+   type struct_sigaction is record\n+      sa_handler : System.Address;\n+      sa_mask    : sigset_t;\n+      sa_flags   : int;\n+   end record;\n+   pragma Convention (C, struct_sigaction);\n+   type struct_sigaction_ptr is access all struct_sigaction;\n+\n+   SIG_BLOCK   : constant := 0;\n+   SIG_UNBLOCK : constant := 1;\n+   SIG_SETMASK : constant := 2;\n+\n+   SIG_DFL : constant := 0;\n+   SIG_IGN : constant := 1;\n+\n+   function sigaction\n+     (sig  : Signal;\n+      act  : struct_sigaction_ptr;\n+      oact : struct_sigaction_ptr) return int;\n+   pragma Import (C, sigaction, \"_internal_sigaction\");\n+\n+   ----------\n+   -- Time --\n+   ----------\n+\n+   Time_Slice_Supported : constant Boolean := True;\n+   --  Indicates wether time slicing is supported (i.e FSU threads have been\n+   --  compiled with DEF_RR)\n+\n+   type timespec is private;\n+\n+   type clockid_t is private;\n+\n+   CLOCK_REALTIME : constant clockid_t;\n+\n+   function clock_gettime\n+     (clock_id : clockid_t;\n+      tp       : access timespec) return int;\n+   pragma Import (C, clock_gettime, \"clock_gettime\");\n+\n+   function To_Duration (TS : timespec) return Duration;\n+   pragma Inline (To_Duration);\n+\n+   function To_Timespec (D : Duration) return timespec;\n+   pragma Inline (To_Timespec);\n+\n+   type struct_timeval is private;\n+\n+   function To_Duration (TV : struct_timeval) return Duration;\n+   pragma Inline (To_Duration);\n+\n+   function To_Timeval (D : Duration) return struct_timeval;\n+   pragma Inline (To_Timeval);\n+\n+   -------------------------\n+   -- Priority Scheduling --\n+   -------------------------\n+\n+   SCHED_FIFO  : constant := 0;\n+   SCHED_RR    : constant := 1;\n+   SCHED_OTHER : constant := 2;\n+\n+   -------------\n+   -- Process --\n+   -------------\n+\n+   type pid_t is private;\n+\n+   function kill (pid : pid_t; sig : Signal) return int;\n+   pragma Import (C, kill, \"kill\");\n+\n+   function getpid return pid_t;\n+   pragma Import (C, getpid, \"getpid\");\n+\n+   ---------\n+   -- LWP --\n+   ---------\n+\n+   function lwp_self return System.Address;\n+   --  lwp_self does not exist on this thread library, revert to pthread_self\n+   --  which is the closest approximation (with getpid). This function is\n+   --  needed to share 7staprop.adb across POSIX-like targets.\n+   pragma Import (C, lwp_self, \"pthread_self\");\n+\n+   -------------\n+   -- Threads --\n+   -------------\n+\n+   type Thread_Body is access\n+     function (arg : System.Address) return System.Address;\n+   type pthread_t           is private;\n+   subtype Thread_Id        is pthread_t;\n+\n+   type pthread_mutex_t     is limited private;\n+   type pthread_cond_t      is limited private;\n+   type pthread_attr_t      is limited private;\n+   type pthread_mutexattr_t is limited private;\n+   type pthread_condattr_t  is limited private;\n+   type pthread_key_t       is private;\n+\n+   PTHREAD_CREATE_DETACHED : constant := 1;\n+\n+   -----------\n+   -- Stack --\n+   -----------\n+\n+   Stack_Base_Available : constant Boolean := True;\n+   --  Indicates wether the stack base is available on this target.\n+   --  This allows us to share s-osinte.adb between all the FSU run time.\n+   --  Note that this value can only be true if pthread_t has a complete\n+   --  definition that corresponds exactly to the C header files.\n+\n+   function Get_Stack_Base (thread : pthread_t) return Address;\n+   pragma Inline (Get_Stack_Base);\n+   --  returns the stack base of the specified thread.\n+   --  Only call this function when Stack_Base_Available is True.\n+\n+   function Get_Page_Size return size_t;\n+   function Get_Page_Size return Address;\n+   pragma Import (C, Get_Page_Size, \"getpagesize\");\n+   --  returns the size of a page, or 0 if this is not relevant on this\n+   --  target\n+\n+   PROT_NONE  : constant := 0;\n+   PROT_READ  : constant := 1;\n+   PROT_WRITE : constant := 2;\n+   PROT_EXEC  : constant := 4;\n+   PROT_ALL   : constant := PROT_READ + PROT_WRITE + PROT_EXEC;\n+\n+   PROT_ON    : constant := PROT_READ;\n+   PROT_OFF   : constant := PROT_ALL;\n+\n+   function mprotect (addr : Address; len : size_t; prot : int) return int;\n+   pragma Import (C, mprotect);\n+\n+   ---------------------------------------\n+   -- Nonstandard Thread Initialization --\n+   ---------------------------------------\n+\n+   procedure pthread_init;\n+   --  FSU_THREADS requires pthread_init, which is nonstandard\n+   --  and this should be invoked during the elaboration of s-taprop.adb\n+   pragma Import (C, pthread_init, \"pthread_init\");\n+\n+   -------------------------\n+   -- POSIX.1c  Section 3 --\n+   -------------------------\n+\n+   function sigwait\n+     (set : access sigset_t;\n+      sig : access Signal) return int;\n+   --  FSU_THREADS has a nonstandard sigwait\n+\n+   function pthread_kill\n+     (thread : pthread_t;\n+      sig    : Signal) return int;\n+   pragma Import (C, pthread_kill, \"pthread_kill\");\n+\n+   --  FSU threads does not have pthread_sigmask. Instead, it redefines\n+   --  sigprocmask and then uses a special syscall API to call the system\n+   --  version. Doing syscalls on AiX is very difficult, so we rename the\n+   --  pthread version instead.\n+\n+   type sigset_t_ptr is access all sigset_t;\n+\n+   function pthread_sigmask\n+     (how  : int;\n+      set  : sigset_t_ptr;\n+      oset : sigset_t_ptr) return int;\n+   pragma Import (C, pthread_sigmask, \"_internal_sigprocmask\");\n+\n+   --------------------------\n+   -- POSIX.1c  Section 11 --\n+   --------------------------\n+\n+   function pthread_mutexattr_init\n+     (attr : access pthread_mutexattr_t) return int;\n+   pragma Import (C, pthread_mutexattr_init, \"pthread_mutexattr_init\");\n+\n+   function pthread_mutexattr_destroy\n+     (attr : access pthread_mutexattr_t) return int;\n+   pragma Import (C, pthread_mutexattr_destroy, \"pthread_mutexattr_destroy\");\n+\n+   function pthread_mutex_init\n+     (mutex : access pthread_mutex_t;\n+      attr  : access pthread_mutexattr_t) return int;\n+   pragma Import (C, pthread_mutex_init, \"pthread_mutex_init\");\n+\n+   function pthread_mutex_destroy (mutex : access pthread_mutex_t) return int;\n+   pragma Import (C, pthread_mutex_destroy, \"pthread_mutex_destroy\");\n+\n+   function pthread_mutex_lock (mutex : access pthread_mutex_t) return int;\n+   --  FSU_THREADS has nonstandard pthread_mutex_lock\n+\n+   function pthread_mutex_unlock (mutex : access pthread_mutex_t) return int;\n+   --  FSU_THREADS has nonstandard pthread_mutex_lock\n+\n+   function pthread_condattr_init\n+     (attr : access pthread_condattr_t) return int;\n+   pragma Import (C, pthread_condattr_init, \"pthread_condattr_init\");\n+\n+   function pthread_condattr_destroy\n+     (attr : access pthread_condattr_t) return int;\n+   pragma Import (C, pthread_condattr_destroy, \"pthread_condattr_destroy\");\n+\n+   function pthread_cond_init\n+     (cond : access pthread_cond_t;\n+      attr : access pthread_condattr_t) return int;\n+   pragma Import (C, pthread_cond_init, \"pthread_cond_init\");\n+\n+   function pthread_cond_destroy (cond : access pthread_cond_t) return int;\n+   pragma Import (C, pthread_cond_destroy, \"pthread_cond_destroy\");\n+\n+   function pthread_cond_signal (cond : access pthread_cond_t) return int;\n+   pragma Import (C, pthread_cond_signal, \"pthread_cond_signal\");\n+\n+   function pthread_cond_wait\n+     (cond  : access pthread_cond_t;\n+      mutex : access pthread_mutex_t) return int;\n+   --  FSU_THREADS has a nonstandard pthread_cond_wait\n+\n+   function pthread_cond_timedwait\n+     (cond    : access pthread_cond_t;\n+      mutex   : access pthread_mutex_t;\n+      abstime : access timespec) return int;\n+   --  FSU_THREADS has a nonstandard pthread_cond_timedwait\n+\n+   Relative_Timed_Wait : constant Boolean := False;\n+   --  pthread_cond_timedwait requires an absolute delay time\n+\n+   --------------------------\n+   -- POSIX.1c  Section 13 --\n+   --------------------------\n+\n+   PTHREAD_PRIO_NONE    : constant := 0;\n+   PTHREAD_PRIO_PROTECT : constant := 2;\n+   PTHREAD_PRIO_INHERIT : constant := 1;\n+\n+   function pthread_mutexattr_setprotocol\n+     (attr     : access pthread_mutexattr_t;\n+      protocol : int) return int;\n+   pragma Import (C, pthread_mutexattr_setprotocol);\n+\n+   function pthread_mutexattr_setprioceiling\n+     (attr        : access pthread_mutexattr_t;\n+      prioceiling : int) return int;\n+   pragma Import\n+     (C, pthread_mutexattr_setprioceiling,\n+         \"pthread_mutexattr_setprio_ceiling\");\n+\n+   type struct_sched_param is record\n+      sched_priority : int;  --  scheduling priority\n+   end record;\n+\n+   function pthread_setschedparam\n+     (thread : pthread_t;\n+      policy : int;\n+      param  : access struct_sched_param) return int;\n+   --  FSU_THREADS does not have pthread_setschedparam\n+\n+   function pthread_attr_setscope\n+     (attr            : access pthread_attr_t;\n+      contentionscope : int) return int;\n+   pragma Import (C, pthread_attr_setscope, \"pthread_attr_setscope\");\n+\n+   function pthread_attr_setinheritsched\n+     (attr         : access pthread_attr_t;\n+      inheritsched : int) return int;\n+   pragma Import (C, pthread_attr_setinheritsched);\n+\n+   function pthread_attr_setschedpolicy\n+     (attr   : access pthread_attr_t;\n+      policy : int) return int;\n+   pragma Import (C, pthread_attr_setschedpolicy, \"pthread_attr_setsched\");\n+\n+   function sched_yield return int;\n+   --  FSU_THREADS does not have sched_yield;\n+\n+   ---------------------------\n+   -- P1003.1c - Section 16 --\n+   ---------------------------\n+\n+   function pthread_attr_init (attributes : access pthread_attr_t) return int;\n+   pragma Import (C, pthread_attr_init, \"pthread_attr_init\");\n+\n+   function pthread_attr_destroy\n+     (attributes : access pthread_attr_t) return int;\n+   pragma Import (C, pthread_attr_destroy, \"pthread_attr_destroy\");\n+\n+   function pthread_attr_setdetachstate\n+     (attr        : access pthread_attr_t;\n+      detachstate : int) return int;\n+   --  FSU_THREADS has a nonstandard pthread_attr_setdetachstate\n+\n+   function pthread_attr_setstacksize\n+     (attr      : access pthread_attr_t;\n+      stacksize : size_t) return int;\n+   pragma Import (C, pthread_attr_setstacksize);\n+\n+   function pthread_create\n+     (thread        : access pthread_t;\n+      attributes    : access pthread_attr_t;\n+      start_routine : Thread_Body;\n+      arg           : System.Address) return int;\n+   pragma Import (C, pthread_create, \"pthread_create\");\n+\n+   procedure pthread_exit (status : System.Address);\n+   pragma Import (C, pthread_exit, \"pthread_exit\");\n+\n+   function pthread_self return pthread_t;\n+   pragma Import (C, pthread_self, \"pthread_self\");\n+\n+   --------------------------\n+   -- POSIX.1c  Section 17 --\n+   --------------------------\n+\n+   function pthread_setspecific\n+     (key   : pthread_key_t;\n+      value : System.Address) return int;\n+   pragma Import (C, pthread_setspecific, \"pthread_setspecific\");\n+\n+   function pthread_getspecific (key : pthread_key_t) return System.Address;\n+   --  FSU_THREADS has a nonstandard pthread_getspecific\n+\n+   type destructor_pointer is access procedure (arg : System.Address);\n+\n+   function pthread_key_create\n+     (key        : access pthread_key_t;\n+      destructor : destructor_pointer) return int;\n+   pragma Import (C, pthread_key_create, \"pthread_key_create\");\n+\n+private\n+\n+   type sigset_t is record\n+      losigs : unsigned_long;\n+      hisigs : unsigned_long;\n+   end record;\n+   pragma Convention (C_Pass_By_Copy, sigset_t);\n+\n+   type pid_t is new int;\n+\n+   type time_t is new long;\n+\n+   type timespec is record\n+      tv_sec  : time_t;\n+      tv_nsec : long;\n+   end record;\n+   pragma Convention (C, timespec);\n+\n+   type clockid_t is new int;\n+   CLOCK_REALTIME : constant clockid_t := 0;\n+\n+   type struct_timeval is record\n+      tv_sec  : long;\n+      tv_usec : long;\n+   end record;\n+   pragma Convention (C, struct_timeval);\n+\n+   type pthread_attr_t is record\n+      flags           : int;\n+      stacksize       : int;\n+      contentionscope : int;\n+      inheritsched    : int;\n+      detachstate     : int;\n+      sched           : int;\n+      prio            : int;\n+      starttime       : timespec;\n+      deadline        : timespec;\n+      period          : timespec;\n+   end record;\n+   pragma Convention (C_Pass_By_Copy, pthread_attr_t);\n+\n+   type pthread_condattr_t is record\n+      flags : int;\n+   end record;\n+   pragma Convention (C, pthread_condattr_t);\n+\n+   type pthread_mutexattr_t is record\n+      flags        : int;\n+      prio_ceiling : int;\n+      protocol     : int;\n+   end record;\n+   pragma Convention (C, pthread_mutexattr_t);\n+\n+   type sigjmp_buf is array (Integer range 0 .. 63) of int;\n+\n+   type pthread_t_struct is record\n+      context    : sigjmp_buf;\n+      pbody      : sigjmp_buf;\n+      errno      : int;\n+      ret        : int;\n+      stack_base : System.Address;\n+   end record;\n+   pragma Convention (C, pthread_t_struct);\n+\n+   type pthread_t is access all pthread_t_struct;\n+\n+   type queue_t is record\n+      head : System.Address;\n+      tail : System.Address;\n+   end record;\n+   pragma Convention (C, queue_t);\n+\n+   type pthread_mutex_t is record\n+      queue        : queue_t;\n+      lock         : plain_char;\n+      owner        : System.Address;\n+      flags        : int;\n+      prio_ceiling : int;\n+      protocol     : int;\n+      prev_max_ceiling_prio  : int;\n+   end record;\n+   pragma Convention (C, pthread_mutex_t);\n+\n+   type pthread_cond_t is record\n+      queue   : queue_t;\n+      flags   : int;\n+      waiters : int;\n+      mutex   : System.Address;\n+   end record;\n+   pragma Convention (C, pthread_cond_t);\n+\n+   type pthread_key_t is new int;\n+\n+end System.OS_Interface;"}, {"sha": "a1d86b607d9a99a022d4435ddad36744373a4208", "filename": "gcc/ada/5dosinte.ads", "status": "added", "additions": 539, "deletions": 0, "changes": 539, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5dosinte.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5dosinte.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5dosinte.ads?ref=84481f762f0682e5f45b2f360446e1c7e333c880", "patch": "@@ -0,0 +1,539 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS               --\n+--                                                                          --\n+--                   S Y S T E M . O S _ I N T E R F A C E                  --\n+--                                                                          --\n+--                                  S p e c                                 --\n+--                                                                          --\n+--                             $Revision: 1.18 $\n+--                                                                          --\n+--          Copyright (C) 1992-2001, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNARL is free software; you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion. GNARL is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNARL; see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNARL was developed by the GNARL team at Florida State University. It is --\n+-- now maintained by Ada Core Technologies Inc. in cooperation with Florida --\n+-- State University (http://www.gnat.com).                                  --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is a DOS/DJGPPv2 (FSU THREAD) version of this package.\n+\n+--  This package encapsulates all direct interfaces to OS services\n+--  that are needed by children of System.\n+\n+--  PLEASE DO NOT add any with-clauses to this package\n+--  or remove the pragma Elaborate_Body.\n+--  It is designed to be a bottom-level (leaf) package.\n+\n+with Interfaces.C;\n+package System.OS_Interface is\n+   pragma Preelaborate;\n+\n+   --\n+   --  A short name for libgthreads.a to keep Mike Feldman happy.\n+   --\n+   pragma Linker_Options (\"-lgthre\");\n+\n+   subtype int            is Interfaces.C.int;\n+   subtype short          is Interfaces.C.short;\n+   subtype long           is Interfaces.C.long;\n+   subtype unsigned       is Interfaces.C.unsigned;\n+   subtype unsigned_short is Interfaces.C.unsigned_short;\n+   subtype unsigned_long  is Interfaces.C.unsigned_long;\n+   subtype unsigned_char  is Interfaces.C.unsigned_char;\n+   subtype plain_char     is Interfaces.C.plain_char;\n+   subtype size_t         is Interfaces.C.size_t;\n+\n+   -----------\n+   -- Errno --\n+   -----------\n+\n+   function errno return int;\n+   pragma Import (C, errno, \"__get_errno\");\n+\n+   EAGAIN : constant := 5;\n+   EINTR  : constant := 13;\n+   EINVAL : constant := 14;\n+   ENOMEM : constant := 25;\n+\n+   -------------\n+   -- Signals --\n+   -------------\n+\n+   Max_Interrupt : constant := 319;\n+   type Signal is new int range 0 .. Max_Interrupt;\n+\n+   SIGHUP  : constant := 294; --  hangup\n+   SIGINT  : constant := 295; --  interrupt (rubout)\n+   SIGQUIT : constant := 298; --  quit (ASCD FS)\n+   SIGILL  : constant := 290; --  illegal instruction (not reset)\n+   SIGABRT : constant := 288; --  used by abort\n+   SIGFPE  : constant := 289; --  floating point exception\n+   SIGKILL : constant := 296; --  kill (cannot be caught or ignored)\n+   SIGSEGV : constant := 291; --  segmentation violation\n+   SIGPIPE : constant := 297; --  write on a pipe with no one to read it\n+   SIGALRM : constant := 293; --  alarm clock\n+   SIGTERM : constant := 292; --  software termination signal from kill\n+   SIGUSR1 : constant := 299; --  user defined signal 1\n+   SIGUSR2 : constant := 300; --  user defined signal 2\n+   SIGBUS  : constant := 0;\n+\n+   SIGADAABORT : constant := SIGABRT;\n+\n+   type Signal_Set is array (Natural range <>) of Signal;\n+\n+   Unmasked : constant Signal_Set := (SIGTRAP, SIGALRM);\n+   Reserved : constant Signal_Set := (0 .. 0 => SIGSTOP);\n+\n+   type sigset_t is private;\n+\n+   function sigaddset (set : access sigset_t; sig : Signal) return int;\n+   pragma Import (C, sigaddset, \"sigaddset\");\n+\n+   function sigdelset (set : access sigset_t; sig : Signal) return int;\n+   pragma Import (C, sigdelset, \"sigdelset\");\n+\n+   function sigfillset (set : access sigset_t) return int;\n+   pragma Import (C, sigfillset, \"sigfillset\");\n+\n+   function sigismember (set : access sigset_t; sig : Signal) return int;\n+   pragma Import (C, sigismember, \"sigismember\");\n+\n+   function sigemptyset (set : access sigset_t) return int;\n+   pragma Import (C, sigemptyset, \"sigemptyset\");\n+\n+   type struct_sigaction is record\n+      sa_flags   : int;\n+      sa_handler : System.Address;\n+      sa_mask    : sigset_t;\n+   end record;\n+   pragma Convention (C, struct_sigaction);\n+   type struct_sigaction_ptr is access all struct_sigaction;\n+\n+   SIG_BLOCK   : constant := 1;\n+   SIG_UNBLOCK : constant := 3;\n+   SIG_SETMASK : constant := 2;\n+\n+   SIG_DFL : constant := 0;\n+   SIG_IGN : constant := -1;\n+\n+   function sigaction\n+     (sig  : Signal;\n+      act  : struct_sigaction_ptr;\n+      oact : struct_sigaction_ptr) return int;\n+   pragma Import (C, sigaction, \"sigaction\");\n+\n+   ----------\n+   -- Time --\n+   ----------\n+\n+   Time_Slice_Supported : constant Boolean := False;\n+   --  Indicates wether time slicing is supported (i.e FSU threads have been\n+   --  compiled with DEF_RR)\n+\n+   type timespec is private;\n+\n+   function nanosleep (rqtp, rmtp : access timespec) return int;\n+   --  FSU_THREADS has nonstandard nanosleep\n+   type clockid_t is private;\n+\n+   CLOCK_REALTIME : constant clockid_t;\n+\n+   function clock_gettime\n+     (clock_id : clockid_t;\n+      tp       : access timespec) return int;\n+   pragma Import (C, clock_gettime, \"clock_gettime\");\n+\n+   function To_Duration (TS : timespec) return Duration;\n+   pragma Inline (To_Duration);\n+\n+   function To_Timespec (D : Duration) return timespec;\n+   pragma Inline (To_Timespec);\n+\n+   type struct_timeval is private;\n+\n+   function To_Duration (TV : struct_timeval) return Duration;\n+   pragma Inline (To_Duration);\n+\n+   function To_Timeval (D : Duration) return struct_timeval;\n+   pragma Inline (To_Timeval);\n+\n+   -------------------------\n+   -- Priority Scheduling --\n+   -------------------------\n+\n+   SCHED_FIFO  : constant := 0;\n+   SCHED_RR    : constant := 1;\n+   SCHED_OTHER : constant := 2;\n+\n+   -------------\n+   -- Process --\n+   -------------\n+\n+   type pid_t is private;\n+\n+   function kill (pid : pid_t; sig : Signal) return int;\n+   pragma Import (C, kill, \"kill\");\n+\n+   function getpid return pid_t;\n+   pragma Import (C, getpid, \"getpid\");\n+\n+   ---------\n+   -- LWP --\n+   ---------\n+\n+   function lwp_self return System.Address;\n+   --  lwp_self does not exist on this thread library, revert to pthread_self\n+   --  which is the closest approximation (with getpid). This function is\n+   --  needed to share 7staprop.adb across POSIX-like targets.\n+   pragma Import (C, lwp_self, \"pthread_self\");\n+\n+   -------------\n+   -- Threads --\n+   -------------\n+\n+   type Thread_Body is access\n+     function (arg : System.Address) return System.Address;\n+\n+   type pthread_t           is private;\n+   subtype Thread_Id        is pthread_t;\n+\n+   type pthread_mutex_t     is limited private;\n+   type pthread_cond_t      is limited private;\n+   type pthread_attr_t      is limited private;\n+   type pthread_mutexattr_t is limited private;\n+   type pthread_condattr_t  is limited private;\n+   type pthread_key_t       is private;\n+\n+   PTHREAD_CREATE_DETACHED : constant := 1;\n+\n+   -----------\n+   -- Stack --\n+   -----------\n+\n+   Stack_Base_Available : constant Boolean := False;\n+   --  Indicates wether the stack base is available on this target.\n+   --  This allows us to share s-osinte.adb between all the FSU run time.\n+   --  Note that this value can only be true if pthread_t has a complete\n+   --  definition that corresponds exactly to the C header files.\n+\n+   function Get_Stack_Base (thread : pthread_t) return Address;\n+   pragma Inline (Get_Stack_Base);\n+   --  returns the stack base of the specified thread.\n+   --  Only call this function when Stack_Base_Available is True.\n+\n+   function Get_Page_Size return size_t;\n+   function Get_Page_Size return Address;\n+   pragma Import (C, Get_Page_Size, \"getpagesize\");\n+   --  returns the size of a page, or 0 if this is not relevant on this\n+   --  target\n+\n+   PROT_NONE  : constant := 0;\n+   PROT_READ  : constant := 1;\n+   PROT_WRITE : constant := 2;\n+   PROT_EXEC  : constant := 4;\n+   PROT_ALL   : constant := PROT_READ + PROT_WRITE + PROT_EXEC;\n+\n+   PROT_ON    : constant := PROT_NONE;\n+   PROT_OFF   : constant := PROT_ALL;\n+\n+   function mprotect\n+     (addr : Address; len : size_t; prot : int) return int;\n+   pragma Import (C, mprotect);\n+\n+   ---------------------------------------\n+   -- Nonstandard Thread Initialization --\n+   ---------------------------------------\n+\n+   procedure pthread_init;\n+   --  FSU_THREADS requires pthread_init, which is nonstandard\n+   --  and this should be invoked during the elaboration of s-taprop.adb\n+   pragma Import (C, pthread_init, \"pthread_init\");\n+\n+   -------------------------\n+   -- POSIX.1c  Section 3 --\n+   -------------------------\n+\n+   function sigwait (set : access sigset_t; sig : access Signal) return int;\n+   --  FSU_THREADS has a nonstandard sigwait\n+\n+   function pthread_kill (thread : pthread_t; sig : Signal) return int;\n+   pragma Import (C, pthread_kill, \"pthread_kill\");\n+\n+   type sigset_t_ptr is access all sigset_t;\n+\n+   function pthread_sigmask\n+     (how  : int;\n+      set  : sigset_t_ptr;\n+      oset : sigset_t_ptr) return int;\n+   pragma Import (C, pthread_sigmask, \"sigprocmask\");\n+\n+   --------------------------\n+   -- POSIX.1c  Section 11 --\n+   --------------------------\n+\n+   function pthread_mutexattr_init\n+     (attr : access pthread_mutexattr_t) return int;\n+   pragma Import (C, pthread_mutexattr_init, \"pthread_mutexattr_init\");\n+\n+   function pthread_mutexattr_destroy\n+     (attr : access pthread_mutexattr_t) return int;\n+   pragma Import (C, pthread_mutexattr_destroy, \"pthread_mutexattr_destroy\");\n+\n+   function pthread_mutex_init\n+     (mutex : access pthread_mutex_t;\n+      attr  : access pthread_mutexattr_t) return int;\n+   pragma Import (C, pthread_mutex_init, \"pthread_mutex_init\");\n+\n+   function pthread_mutex_destroy (mutex : access pthread_mutex_t) return int;\n+   pragma Import (C, pthread_mutex_destroy, \"pthread_mutex_destroy\");\n+\n+   function pthread_mutex_lock (mutex : access pthread_mutex_t) return int;\n+   --  FSU_THREADS has nonstandard pthread_mutex_lock\n+\n+   function pthread_mutex_unlock (mutex : access pthread_mutex_t) return int;\n+   --  FSU_THREADS has nonstandard pthread_mutex_lock\n+\n+   function pthread_condattr_init\n+     (attr : access pthread_condattr_t) return int;\n+   pragma Import (C, pthread_condattr_init, \"pthread_condattr_init\");\n+\n+   function pthread_condattr_destroy\n+     (attr : access pthread_condattr_t) return int;\n+   pragma Import (C, pthread_condattr_destroy, \"pthread_condattr_destroy\");\n+\n+   function pthread_cond_init\n+     (cond : access pthread_cond_t;\n+      attr : access pthread_condattr_t) return int;\n+   pragma Import (C, pthread_cond_init, \"pthread_cond_init\");\n+\n+   function pthread_cond_destroy (cond : access pthread_cond_t) return int;\n+   pragma Import (C, pthread_cond_destroy, \"pthread_cond_destroy\");\n+\n+   function pthread_cond_signal (cond : access pthread_cond_t) return int;\n+   pragma Import (C, pthread_cond_signal, \"pthread_cond_signal\");\n+\n+   function pthread_cond_wait\n+     (cond  : access pthread_cond_t;\n+      mutex : access pthread_mutex_t) return int;\n+   --  FSU_THREADS has a nonstandard pthread_cond_wait\n+\n+   function pthread_cond_timedwait\n+     (cond    : access pthread_cond_t;\n+      mutex   : access pthread_mutex_t;\n+      abstime : access timespec) return int;\n+   --  FSU_THREADS has a nonstandard pthread_cond_timedwait\n+\n+   Relative_Timed_Wait : constant Boolean := False;\n+   --  pthread_cond_timedwait requires an absolute delay time\n+\n+   --------------------------\n+   -- POSIX.1c  Section 13 --\n+   --------------------------\n+\n+   PTHREAD_PRIO_NONE    : constant := 0;\n+   PTHREAD_PRIO_PROTECT : constant := 2;\n+   PTHREAD_PRIO_INHERIT : constant := 1;\n+\n+   function pthread_mutexattr_setprotocol\n+     (attr     : access pthread_mutexattr_t;\n+      protocol : int) return int;\n+   pragma Import (C, pthread_mutexattr_setprotocol);\n+\n+   function pthread_mutexattr_setprioceiling\n+     (attr     : access pthread_mutexattr_t;\n+      prioceiling : int) return int;\n+   pragma Import (C, pthread_mutexattr_setprioceiling);\n+\n+   type struct_sched_param is record\n+      sched_priority : int;  --  scheduling priority\n+   end record;\n+\n+   function pthread_setschedparam\n+     (thread : pthread_t;\n+      policy : int;\n+      param  : access struct_sched_param) return int;\n+   --  FSU_THREADS does not have pthread_setschedparam\n+\n+   function pthread_attr_setscope\n+     (attr            : access pthread_attr_t;\n+      contentionscope : int) return int;\n+   pragma Import (C, pthread_attr_setscope, \"pthread_attr_setscope\");\n+\n+   function pthread_attr_setinheritsched\n+     (attr            : access pthread_attr_t;\n+      inheritsched : int) return int;\n+   pragma Import (C, pthread_attr_setinheritsched);\n+\n+   function pthread_attr_setschedpolicy\n+     (attr   : access pthread_attr_t;\n+      policy : int) return int;\n+   pragma Import (C, pthread_attr_setschedpolicy, \"pthread_attr_setsched\");\n+\n+   function sched_yield return int;\n+   --  FSU_THREADS does not have sched_yield;\n+\n+   ---------------------------\n+   -- P1003.1c - Section 16 --\n+   ---------------------------\n+\n+   function pthread_attr_init (attributes : access pthread_attr_t) return int;\n+   pragma Import (C, pthread_attr_init);\n+\n+   function pthread_attr_destroy\n+     (attributes : access pthread_attr_t) return int;\n+   pragma Import (C, pthread_attr_destroy);\n+\n+   function pthread_attr_setdetachstate\n+     (attr        : access pthread_attr_t;\n+      detachstate : int) return int;\n+   --  FSU_THREADS has a nonstandard pthread_attr_setdetachstate\n+\n+   function pthread_attr_setstacksize\n+     (attr      : access pthread_attr_t;\n+      stacksize : size_t) return int;\n+   pragma Import (C, pthread_attr_setstacksize);\n+\n+   function pthread_create\n+     (thread        : access pthread_t;\n+      attributes    : access pthread_attr_t;\n+      start_routine : Thread_Body;\n+      arg           : System.Address) return int;\n+   pragma Import (C, pthread_create);\n+\n+   procedure pthread_exit (status : System.Address);\n+   pragma Import (C, pthread_exit, \"pthread_exit\");\n+\n+   function pthread_self return pthread_t;\n+   pragma Import (C, pthread_self, \"pthread_self\");\n+\n+   --------------------------\n+   -- POSIX.1c  Section 17 --\n+   --------------------------\n+\n+   function pthread_setspecific\n+     (key   : pthread_key_t;\n+      value : System.Address) return  int;\n+   pragma Import (C, pthread_setspecific, \"pthread_setspecific\");\n+\n+   function pthread_getspecific (key : pthread_key_t) return System.Address;\n+   --  FSU_THREADS has a nonstandard pthread_getspecific\n+\n+   type destructor_pointer is access procedure (arg : System.Address);\n+\n+   function pthread_key_create\n+     (key        : access pthread_key_t;\n+      destructor : destructor_pointer) return int;\n+   pragma Import (C, pthread_key_create, \"pthread_key_create\");\n+\n+private\n+\n+   type bits_arr_t is array (Integer range 1 .. 10) of long;\n+   type sigset_t is record\n+      bits : bits_arr_t;\n+   end record;\n+\n+   type pid_t is new int;\n+\n+   type time_t is new long;\n+\n+   type timespec is record\n+      tv_sec  : time_t;\n+      tv_nsec : long;\n+   end record;\n+   pragma Convention (C, timespec);\n+\n+   type clockid_t is new int;\n+   CLOCK_REALTIME : constant clockid_t := 0;\n+\n+   type struct_timeval is record\n+      tv_sec  : long;\n+      tv_usec : long;\n+   end record;\n+   pragma Convention (C, struct_timeval);\n+\n+   type pthread_attr_t is record\n+      flags           : int;\n+      stacksize       : int;\n+      contentionscope : int;\n+      inheritsched    : int;\n+      detachstate     : int;\n+      sched           : int;\n+      prio            : int;\n+      starttime       : timespec;\n+      deadline        : timespec;\n+      period          : timespec;\n+   end record;\n+   pragma Convention (C, pthread_attr_t);\n+\n+   type pthread_condattr_t is record\n+      flags : int;\n+   end record;\n+   pragma Convention (C, pthread_condattr_t);\n+\n+   type pthread_mutexattr_t is record\n+      flags        : int;\n+      prio_ceiling : int;\n+      protocol     : int;\n+   end record;\n+   pragma Convention (C, pthread_mutexattr_t);\n+\n+   type sigjmp_buf is array (Integer range 0 .. 43) of int;\n+\n+   type pthread_t_struct is record\n+      context    : sigjmp_buf;\n+      pbody      : sigjmp_buf;\n+      errno      : int;\n+      ret        : int;\n+      stack_base : System.Address;\n+   end record;\n+   pragma Convention (C, pthread_t_struct);\n+\n+   type pthread_t is access all pthread_t_struct;\n+\n+   type queue_t is record\n+      head : System.Address;\n+      tail : System.Address;\n+   end record;\n+   pragma Convention (C, queue_t);\n+\n+   type pthread_mutex_t is record\n+      queue        : queue_t;\n+      lock         : plain_char;\n+      owner        : System.Address;\n+      flags        : int;\n+      prio_ceiling : int;\n+      protocol     : int;\n+      prev_max_ceiling_prio  : int;\n+   end record;\n+   pragma Convention (C, pthread_mutex_t);\n+\n+   type pthread_cond_t is record\n+      queue   : queue_t;\n+      flags   : int;\n+      waiters : int;\n+      mutex   : System.Address;\n+   end record;\n+   pragma Convention (C, pthread_cond_t);\n+\n+   type pthread_key_t is new int;\n+\n+end System.OS_Interface;"}, {"sha": "052776374d8a5afb2698945bf0392f5881bc2a3d", "filename": "gcc/ada/5esystem.ads", "status": "added", "additions": 150, "deletions": 0, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5esystem.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5esystem.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5esystem.ads?ref=84481f762f0682e5f45b2f360446e1c7e333c880", "patch": "@@ -0,0 +1,150 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                        GNAT RUN-TIME COMPONENTS                          --\n+--                                                                          --\n+--                               S Y S T E M                                --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                          (X86 Solaris Version)                           --\n+--                                                                          --\n+--                            $Revision: 1.10 $\n+--                                                                          --\n+--          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+package System is\n+pragma Pure (System);\n+--  Note that we take advantage of the implementation permission to\n+--  make this unit Pure instead of Preelaborable, see RM 13.7(36)\n+\n+   type Name is (SYSTEM_NAME_GNAT);\n+   System_Name : constant Name := SYSTEM_NAME_GNAT;\n+\n+   --  System-Dependent Named Numbers\n+\n+   Min_Int               : constant := Long_Long_Integer'First;\n+   Max_Int               : constant := Long_Long_Integer'Last;\n+\n+   Max_Binary_Modulus    : constant := 2 ** Long_Long_Integer'Size;\n+   Max_Nonbinary_Modulus : constant := Integer'Last;\n+\n+   Max_Base_Digits       : constant := Long_Long_Float'Digits;\n+   Max_Digits            : constant := Long_Long_Float'Digits;\n+\n+   Max_Mantissa          : constant := 63;\n+   Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);\n+\n+   Tick                  : constant := Standard'Tick;\n+\n+   --  Storage-related Declarations\n+\n+   type Address is private;\n+   Null_Address : constant Address;\n+\n+   Storage_Unit : constant := Standard'Storage_Unit;\n+   Word_Size    : constant := Standard'Word_Size;\n+   Memory_Size  : constant := 2 ** Standard'Address_Size;\n+\n+   --  Address comparison\n+\n+   function \"<\"  (Left, Right : Address) return Boolean;\n+   function \"<=\" (Left, Right : Address) return Boolean;\n+   function \">\"  (Left, Right : Address) return Boolean;\n+   function \">=\" (Left, Right : Address) return Boolean;\n+   function \"=\"  (Left, Right : Address) return Boolean;\n+\n+   pragma Import (Intrinsic, \"<\");\n+   pragma Import (Intrinsic, \"<=\");\n+   pragma Import (Intrinsic, \">\");\n+   pragma Import (Intrinsic, \">=\");\n+   pragma Import (Intrinsic, \"=\");\n+\n+   --  Other System-Dependent Declarations\n+\n+   type Bit_Order is (High_Order_First, Low_Order_First);\n+   Default_Bit_Order : constant Bit_Order := Low_Order_First;\n+\n+   --  Priority-related Declarations (RM D.1)\n+\n+   Max_Priority : constant Positive := 30;\n+\n+   Max_Interrupt_Priority : constant Positive := 31;\n+\n+   subtype Any_Priority is Integer\n+     range 0 .. Standard'Max_Interrupt_Priority;\n+\n+   subtype Priority is Any_Priority\n+     range 0 .. Standard'Max_Priority;\n+\n+   --  Functional notation is needed in the following to avoid visibility\n+   --  problems when this package is compiled through rtsfind in the middle\n+   --  of another compilation.\n+\n+   subtype Interrupt_Priority is Any_Priority\n+     range\n+       Standard.\"+\" (Standard'Max_Priority,  1) ..\n+         Standard'Max_Interrupt_Priority;\n+\n+   Default_Priority : constant Priority :=\n+     Standard.\"/\" (Standard.\"+\" (Priority'First, Priority'Last), 2);\n+\n+private\n+\n+   type Address is mod Memory_Size;\n+   Null_Address : constant Address := 0;\n+\n+   --------------------------------------\n+   -- System Implementation Parameters --\n+   --------------------------------------\n+\n+   --  These parameters provide information about the target that is used\n+   --  by the compiler. They are in the private part of System, where they\n+   --  can be accessed using the special circuitry in the Targparm unit\n+   --  whose source should be consulted for more detailed descriptions\n+   --  of the individual switch values.\n+\n+   AAMP                      : constant Boolean := False;\n+   Command_Line_Args         : constant Boolean := True;\n+   Denorm                    : constant Boolean := True;\n+   Frontend_Layout           : constant Boolean := False;\n+   Functions_Return_By_DSP   : constant Boolean := False;\n+   Long_Shifts_Inlined       : constant Boolean := True;\n+   High_Integrity_Mode       : constant Boolean := False;\n+   Machine_Overflows         : constant Boolean := False;\n+   Machine_Rounds            : constant Boolean := True;\n+   OpenVMS                   : constant Boolean := False;\n+   Signed_Zeros              : constant Boolean := True;\n+   Stack_Check_Default       : constant Boolean := False;\n+   Stack_Check_Probes        : constant Boolean := True;\n+   Use_Ada_Main_Program_Name : constant Boolean := False;\n+   ZCX_By_Default            : constant Boolean := False;\n+   GCC_ZCX_Support           : constant Boolean := False;\n+   Front_End_ZCX_Support     : constant Boolean := False;\n+\n+end System;"}, {"sha": "a5c1cf34a3c2fadb40ff0f82f193c2630091498b", "filename": "gcc/ada/5etpopse.adb", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5etpopse.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5etpopse.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5etpopse.adb?ref=84481f762f0682e5f45b2f360446e1c7e333c880", "patch": "@@ -0,0 +1,53 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS               --\n+--                                                                          --\n+--                   SYSTEM.TASK_PRIMITIVES.OPERATIONS.SELF                 --\n+--                                                                          --\n+--                                  B o d y                                 --\n+--                                                                          --\n+--                             $Revision: 1.1 $                             --\n+--                                                                          --\n+--            Copyright (C) 1991-1998, Florida State University             --\n+--                                                                          --\n+-- GNARL is free software; you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion. GNARL is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNARL; see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNARL was developed by the GNARL team at Florida State University. It is --\n+-- now maintained by Ada Core Technologies Inc. in cooperation with Florida --\n+-- State University (http://www.gnat.com).                                  --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is a Solaris/X86 (native) version of this package.\n+\n+separate (System.Task_Primitives.Operations)\n+\n+----------\n+-- Self --\n+----------\n+\n+function Self return Task_ID is\n+   Temp   : aliased System.Address;\n+   Result : Interfaces.C.int;\n+\n+begin\n+   Result := thr_getspecific (ATCB_Key, Temp'Unchecked_Access);\n+   pragma Assert (Result = 0);\n+   return To_Task_ID (Temp);\n+end Self;"}, {"sha": "919562dfc5ac30097d1238c954d493d8bbd93097", "filename": "gcc/ada/5fintman.adb", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5fintman.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5fintman.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5fintman.adb?ref=84481f762f0682e5f45b2f360446e1c7e333c880", "patch": "@@ -0,0 +1,104 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS               --\n+--                                                                          --\n+--           S Y S T E M . I N T E R R U P T _ M A N A G E M E N T          --\n+--                                                                          --\n+--                                  B o d y                                 --\n+--                                                                          --\n+--                             $Revision: 1.5 $\n+--                                                                          --\n+--            Copyright (C) 1991-2001, Florida State University             --\n+--                                                                          --\n+-- GNARL is free software; you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion. GNARL is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNARL; see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNARL was developed by the GNARL team at Florida State University. It is --\n+-- now maintained by Ada Core Technologies Inc. in cooperation with Florida --\n+-- State University (http://www.gnat.com).                                  --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is a SGI Pthread version of this package.\n+\n+--  PLEASE DO NOT add any dependences on other packages.\n+--  This package is designed to work with or without tasking support.\n+\n+--  Make a careful study of all signals available under the OS,\n+--  to see which need to be reserved, kept always unmasked,\n+--  or kept always unmasked.\n+--  Be on the lookout for special signals that\n+--  may be used by the thread library.\n+\n+with Interfaces.C;\n+--  used for int\n+\n+with System.OS_Interface;\n+--  used for various Constants, Signal and types\n+\n+package body System.Interrupt_Management is\n+\n+   use System.OS_Interface;\n+\n+   type Interrupt_List is array (Interrupt_ID range <>) of Interrupt_ID;\n+   Exception_Interrupts : constant Interrupt_List :=\n+     (SIGTSTP, SIGILL, SIGTRAP, SIGEMT, SIGFPE, SIGBUS, SIGSTOP, SIGKILL,\n+      SIGSEGV, SIGSYS, SIGXCPU, SIGXFSZ, SIGPROF, SIGPTINTR, SIGPTRESCHED,\n+      SIGABRT, SIGPIPE);\n+\n+   ---------------------------\n+   -- Initialize_Interrupts --\n+   ---------------------------\n+\n+   --  Nothing needs to be done on this platform.\n+\n+   procedure Initialize_Interrupts is\n+   begin\n+      null;\n+   end Initialize_Interrupts;\n+\n+   Unreserve_All_Interrupts : Interfaces.C.int;\n+   pragma Import\n+     (C, Unreserve_All_Interrupts, \"__gl_unreserve_all_interrupts\");\n+\n+   use type Interfaces.C.int;\n+\n+begin\n+   Abort_Task_Interrupt := SIGABRT;\n+   --  Change this if you want to use another signal for task abort.\n+   --  SIGTERM might be a good one.\n+\n+   for I in Exception_Interrupts'Range loop\n+      Keep_Unmasked (Exception_Interrupts (I)) := True;\n+   end loop;\n+\n+   --  By keeping SIGINT unmasked, allow the user to do a Ctrl-C, but in the\n+   --  same time, disable the ability of handling this signal via\n+   --  Ada.Interrupts.\n+   --  The pragma Unreserve_All_Interrupts let the user the ability to\n+   --  change this behavior.\n+\n+   if Unreserve_All_Interrupts = 0 then\n+      Keep_Unmasked (SIGINT) := True;\n+   end if;\n+\n+   Keep_Unmasked (Abort_Task_Interrupt) := True;\n+\n+   Reserve := Keep_Unmasked or Keep_Masked;\n+   Reserve (0) := True;\n+end System.Interrupt_Management;"}, {"sha": "6e5973d9e21e3a901253215b34ec807258404d67", "filename": "gcc/ada/5fosinte.ads", "status": "added", "additions": 524, "deletions": 0, "changes": 524, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5fosinte.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5fosinte.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5fosinte.ads?ref=84481f762f0682e5f45b2f360446e1c7e333c880", "patch": "@@ -0,0 +1,524 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS               --\n+--                                                                          --\n+--                   S Y S T E M . O S _ I N T E R F A C E                  --\n+--                                                                          --\n+--                                  S p e c                                 --\n+--                                                                          --\n+--                             $Revision: 1.13 $\n+--                                                                          --\n+--          Copyright (C) 1998-2001, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNARL is free software; you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion. GNARL is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNARL; see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNARL was developed by the GNARL team at Florida State University. It is --\n+-- now maintained by Ada Core Technologies Inc. in cooperation with Florida --\n+-- State University (http://www.gnat.com).                                  --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is the SGI Pthreads version of this package.\n+\n+--  This package encapsulates all direct interfaces to OS services\n+--  that are needed by children of System.\n+\n+--  PLEASE DO NOT add any with-clauses to this package\n+--  or remove the pragma Elaborate_Body.\n+--  It is designed to be a bottom-level (leaf) package.\n+\n+with Interfaces.C;\n+package System.OS_Interface is\n+\n+   pragma Preelaborate;\n+\n+   pragma Linker_Options (\"-lpthread\");\n+\n+   subtype int            is Interfaces.C.int;\n+   subtype short          is Interfaces.C.short;\n+   subtype long           is Interfaces.C.long;\n+   subtype unsigned       is Interfaces.C.unsigned;\n+   subtype unsigned_short is Interfaces.C.unsigned_short;\n+   subtype unsigned_long  is Interfaces.C.unsigned_long;\n+   subtype unsigned_char  is Interfaces.C.unsigned_char;\n+   subtype plain_char     is Interfaces.C.plain_char;\n+   subtype size_t         is Interfaces.C.size_t;\n+\n+   -----------\n+   -- Errno --\n+   -----------\n+\n+   function errno return int;\n+   pragma Import (C, errno, \"__get_errno\");\n+\n+   EINTR     : constant := 4;   --  interrupted system call\n+   EAGAIN    : constant := 11;  --  No more processes\n+   ENOMEM    : constant := 12;  --  Not enough core\n+   EINVAL    : constant := 22;  --  Invalid argument\n+   ETIMEDOUT : constant := 145; --  Connection timed out\n+\n+   -------------\n+   -- Signals --\n+   -------------\n+\n+   Max_Interrupt : constant := 64;\n+   type Signal is new int range 0 .. Max_Interrupt;\n+   for Signal'Size use int'Size;\n+\n+   SIGHUP     : constant := 1; --  hangup\n+   SIGINT     : constant := 2; --  interrupt (rubout)\n+   SIGQUIT    : constant := 3; --  quit (ASCD FS)\n+   SIGILL     : constant := 4; --  illegal instruction (not reset)\n+   SIGTRAP    : constant := 5; --  trace trap (not reset)\n+   SIGIOT     : constant := 6; --  IOT instruction\n+   SIGABRT    : constant := 6; --  used by abort, replace SIGIOT in the\n+   --                              future\n+   SIGEMT     : constant := 7; --  EMT instruction\n+   SIGFPE     : constant := 8; --  floating point exception\n+   SIGKILL    : constant := 9; --  kill (cannot be caught or ignored)\n+   SIGBUS     : constant := 10; --  bus error\n+   SIGSEGV    : constant := 11; --  segmentation violation\n+   SIGSYS     : constant := 12; --  bad argument to system call\n+   SIGPIPE    : constant := 13; --  write on a pipe with no one to read it\n+   SIGALRM    : constant := 14; --  alarm clock\n+   SIGTERM    : constant := 15; --  software termination signal from kill\n+   SIGUSR1    : constant := 16; --  user defined signal 1\n+   SIGUSR2    : constant := 17; --  user defined signal 2\n+   SIGCLD     : constant := 18; --  alias for SIGCHLD\n+   SIGCHLD    : constant := 18; --  child status change\n+   SIGPWR     : constant := 19; --  power-fail restart\n+   SIGWINCH   : constant := 20; --  window size change\n+   SIGURG     : constant := 21; --  urgent condition on IO channel\n+   SIGPOLL    : constant := 22; --  pollable event occurred\n+   SIGIO      : constant := 22; --  I/O possible (Solaris SIGPOLL alias)\n+   SIGSTOP    : constant := 23; --  stop (cannot be caught or ignored)\n+   SIGTSTP    : constant := 24; --  user stop requested from tty\n+   SIGCONT    : constant := 25; --  stopped process has been continued\n+   SIGTTIN    : constant := 26; --  background tty read attempted\n+   SIGTTOU    : constant := 27; --  background tty write attempted\n+   SIGVTALRM  : constant := 28; --  virtual timer expired\n+   SIGPROF    : constant := 29; --  profiling timer expired\n+   SIGXCPU    : constant := 30; --  CPU time limit exceeded\n+   SIGXFSZ    : constant := 31; --  filesize limit exceeded\n+   SIGK32     : constant := 32; --  reserved for kernel (IRIX)\n+   SIGCKPT    : constant := 33; --  Checkpoint warning\n+   SIGRESTART : constant := 34; --  Restart warning\n+   SIGUME     : constant := 35; --  Uncorrectable memory error\n+   --  Signals defined for Posix 1003.1c.\n+   SIGPTINTR    : constant := 47;\n+   SIGPTRESCHED : constant := 48;\n+   --  Posix 1003.1b signals\n+   SIGRTMIN   : constant := 49; --  Posix 1003.1b signals\n+   SIGRTMAX   : constant := 64; --  Posix 1003.1b signals\n+\n+   type sigset_t is private;\n+   type sigset_t_ptr is access all sigset_t;\n+\n+   function sigaddset (set : access sigset_t; sig : Signal) return int;\n+   pragma Import (C, sigaddset, \"sigaddset\");\n+\n+   function sigdelset (set : access sigset_t; sig : Signal) return int;\n+   pragma Import (C, sigdelset, \"sigdelset\");\n+\n+   function sigfillset (set : access sigset_t) return int;\n+   pragma Import (C, sigfillset, \"sigfillset\");\n+\n+   function sigismember (set : access sigset_t; sig : Signal) return int;\n+   pragma Import (C, sigismember, \"sigismember\");\n+\n+   function sigemptyset (set : access sigset_t) return int;\n+   pragma Import (C, sigemptyset, \"sigemptyset\");\n+\n+   type array_type_2 is array (Integer range 0 .. 1) of int;\n+   type struct_sigaction is record\n+      sa_flags     : int;\n+      sa_handler   : System.Address;\n+      sa_mask      : sigset_t;\n+      sa_resv      : array_type_2;\n+   end record;\n+   pragma Convention (C, struct_sigaction);\n+\n+   type struct_sigaction_ptr is access all struct_sigaction;\n+\n+   SIG_BLOCK   : constant := 1;\n+   SIG_UNBLOCK : constant := 2;\n+   SIG_SETMASK : constant := 3;\n+\n+   SIG_DFL : constant := 0;\n+   SIG_IGN : constant := 1;\n+\n+   function sigaction\n+     (sig  : Signal;\n+      act  : struct_sigaction_ptr;\n+      oact : struct_sigaction_ptr := null) return int;\n+   pragma Import (C, sigaction, \"sigaction\");\n+\n+   ----------\n+   -- Time --\n+   ----------\n+\n+   type timespec is private;\n+   type timespec_ptr is access all timespec;\n+\n+   type clockid_t is private;\n+\n+   CLOCK_REALTIME  : constant clockid_t;\n+   CLOCK_SGI_FAST  : constant clockid_t;\n+   CLOCK_SGI_CYCLE : constant clockid_t;\n+\n+   SGI_CYCLECNTR_SIZE : constant := 165;\n+\n+   function syssgi (request : Interfaces.C.int) return Interfaces.C.ptrdiff_t;\n+   pragma Import (C, syssgi, \"syssgi\");\n+\n+   function clock_gettime\n+     (clock_id : clockid_t;\n+      tp       : access timespec) return int;\n+   pragma Import (C, clock_gettime, \"clock_gettime\");\n+\n+   function clock_getres\n+     (clock_id : clockid_t;\n+      tp       : access timespec) return int;\n+   pragma Import (C, clock_getres, \"clock_getres\");\n+\n+   function To_Duration (TS : timespec) return Duration;\n+   pragma Inline (To_Duration);\n+\n+   function To_Timespec (D : Duration) return timespec;\n+   pragma Inline (To_Timespec);\n+\n+   type struct_timeval is private;\n+\n+   function To_Duration (TV : struct_timeval) return Duration;\n+   pragma Inline (To_Duration);\n+\n+   function To_Timeval (D : Duration) return struct_timeval;\n+   pragma Inline (To_Timeval);\n+\n+   -------------------------\n+   -- Priority Scheduling --\n+   -------------------------\n+\n+   SCHED_FIFO  : constant := 1;\n+   SCHED_RR    : constant := 2;\n+   SCHED_TS    : constant := 3;\n+   SCHED_OTHER : constant := 3;\n+   SCHED_NP    : constant := 4;\n+\n+   function sched_get_priority_min (Policy : int) return int;\n+   pragma Import (C, sched_get_priority_min, \"sched_get_priority_min\");\n+\n+   function sched_get_priority_max (Policy : int) return int;\n+   pragma Import (C, sched_get_priority_max, \"sched_get_priority_max\");\n+\n+   -------------\n+   -- Process --\n+   -------------\n+\n+   type pid_t is private;\n+\n+   function kill (pid : pid_t; sig : Signal) return int;\n+   pragma Import (C, kill, \"kill\");\n+\n+   function getpid return pid_t;\n+   pragma Import (C, getpid, \"getpid\");\n+\n+   -------------\n+   -- Threads --\n+   -------------\n+\n+   type Thread_Body is access\n+     function (arg : System.Address) return System.Address;\n+   type pthread_t           is private;\n+   subtype Thread_Id        is pthread_t;\n+\n+   type pthread_mutex_t     is limited private;\n+   type pthread_cond_t      is limited private;\n+   type pthread_attr_t      is limited private;\n+   type pthread_mutexattr_t is limited private;\n+   type pthread_condattr_t  is limited private;\n+   type pthread_key_t       is private;\n+\n+   PTHREAD_CREATE_DETACHED : constant := 1;\n+\n+   ---------------------------------------\n+   -- Nonstandard Thread Initialization --\n+   ---------------------------------------\n+\n+   procedure pthread_init;\n+   pragma Inline (pthread_init);\n+   --  This is a dummy procedure to share some GNULLI files\n+\n+   -------------------------\n+   -- POSIX.1c  Section 3 --\n+   -------------------------\n+\n+   function sigwait\n+     (set : access sigset_t;\n+      sig : access Signal) return int;\n+   pragma Import (C, sigwait, \"sigwait\");\n+\n+   function pthread_kill\n+     (thread : pthread_t;\n+      sig    : Signal) return int;\n+   pragma Import (C, pthread_kill, \"pthread_kill\");\n+\n+   function pthread_sigmask\n+     (how  : int;\n+      set  : sigset_t_ptr;\n+      oset : sigset_t_ptr) return int;\n+   pragma Import (C, pthread_sigmask, \"pthread_sigmask\");\n+\n+   --------------------------\n+   -- POSIX.1c  Section 11 --\n+   --------------------------\n+\n+   function pthread_mutexattr_init\n+     (attr : access pthread_mutexattr_t) return int;\n+   pragma Import (C, pthread_mutexattr_init, \"pthread_mutexattr_init\");\n+\n+   function pthread_mutexattr_destroy\n+     (attr : access pthread_mutexattr_t) return int;\n+   pragma Import (C, pthread_mutexattr_destroy, \"pthread_mutexattr_destroy\");\n+\n+   function pthread_mutex_init\n+     (mutex : access pthread_mutex_t;\n+      attr  : access pthread_mutexattr_t) return int;\n+   pragma Import (C, pthread_mutex_init, \"pthread_mutex_init\");\n+\n+   function pthread_mutex_destroy (mutex : access pthread_mutex_t) return int;\n+   pragma Import (C, pthread_mutex_destroy, \"pthread_mutex_destroy\");\n+\n+   function pthread_mutex_lock (mutex : access pthread_mutex_t) return int;\n+   pragma Import (C, pthread_mutex_lock, \"pthread_mutex_lock\");\n+\n+   function pthread_mutex_unlock (mutex : access pthread_mutex_t) return int;\n+   pragma Import (C, pthread_mutex_unlock, \"pthread_mutex_unlock\");\n+\n+   function pthread_condattr_init\n+     (attr : access pthread_condattr_t) return int;\n+   pragma Import (C, pthread_condattr_init, \"pthread_condattr_init\");\n+\n+   function pthread_condattr_destroy\n+     (attr : access pthread_condattr_t) return int;\n+   pragma Import (C, pthread_condattr_destroy, \"pthread_condattr_destroy\");\n+\n+   function pthread_cond_init\n+     (cond : access pthread_cond_t;\n+      attr : access pthread_condattr_t) return int;\n+   pragma Import (C, pthread_cond_init, \"pthread_cond_init\");\n+\n+   function pthread_cond_destroy (cond : access pthread_cond_t) return int;\n+   pragma Import (C, pthread_cond_destroy, \"pthread_cond_destroy\");\n+\n+   function pthread_cond_signal (cond : access pthread_cond_t) return int;\n+   pragma Import (C, pthread_cond_signal, \"pthread_cond_signal\");\n+\n+   function pthread_cond_wait\n+     (cond  : access pthread_cond_t;\n+      mutex : access pthread_mutex_t) return int;\n+   pragma Import (C, pthread_cond_wait, \"pthread_cond_wait\");\n+\n+   function pthread_cond_timedwait\n+     (cond    : access pthread_cond_t;\n+      mutex   : access pthread_mutex_t;\n+      abstime : access timespec) return int;\n+   pragma Import (C, pthread_cond_timedwait, \"pthread_cond_timedwait\");\n+\n+   --------------------------\n+   -- POSIX.1c  Section 13 --\n+   --------------------------\n+\n+   PTHREAD_PRIO_NONE    : constant := 0;\n+   PTHREAD_PRIO_PROTECT : constant := 2;\n+   PTHREAD_PRIO_INHERIT : constant := 1;\n+\n+   function pthread_mutexattr_setprotocol\n+     (attr     : access pthread_mutexattr_t;\n+      protocol : int) return int;\n+   pragma Import (C, pthread_mutexattr_setprotocol);\n+\n+   function pthread_mutexattr_setprioceiling\n+     (attr     : access pthread_mutexattr_t;\n+      prioceiling : int) return int;\n+   pragma Import (C, pthread_mutexattr_setprioceiling);\n+\n+   type struct_sched_param is record\n+      sched_priority : int;\n+   end record;\n+   pragma Convention (C, struct_sched_param);\n+\n+   function pthread_setschedparam\n+     (thread : pthread_t;\n+      policy : int;\n+      param  : access struct_sched_param)\n+     return int;\n+   pragma Import (C, pthread_setschedparam, \"pthread_setschedparam\");\n+\n+   function pthread_attr_setscope\n+     (attr            : access pthread_attr_t;\n+      contentionscope : int) return int;\n+   pragma Import (C, pthread_attr_setscope, \"pthread_attr_setscope\");\n+\n+   function pthread_attr_setinheritsched\n+     (attr         : access pthread_attr_t;\n+      inheritsched : int) return int;\n+   pragma Import\n+     (C, pthread_attr_setinheritsched, \"pthread_attr_setinheritsched\");\n+\n+   function pthread_attr_setschedpolicy\n+     (attr   : access pthread_attr_t;\n+      policy : int) return int;\n+   pragma Import (C, pthread_attr_setschedpolicy);\n+\n+   function pthread_attr_setschedparam\n+     (attr        : access pthread_attr_t;\n+      sched_param : access struct_sched_param)\n+     return int;\n+   pragma Import (C, pthread_attr_setschedparam, \"pthread_attr_setschedparam\");\n+\n+   function sched_yield return int;\n+   pragma Import (C, sched_yield, \"sched_yield\");\n+\n+   ---------------------------\n+   -- P1003.1c - Section 16 --\n+   ---------------------------\n+\n+   function pthread_attr_init (attributes : access pthread_attr_t) return int;\n+   pragma Import (C, pthread_attr_init, \"pthread_attr_init\");\n+\n+   function pthread_attr_destroy\n+     (attributes : access pthread_attr_t) return int;\n+   pragma Import (C, pthread_attr_destroy, \"pthread_attr_destroy\");\n+\n+   function pthread_attr_setdetachstate\n+     (attr        : access pthread_attr_t;\n+      detachstate : int) return int;\n+   pragma Import (C, pthread_attr_setdetachstate);\n+\n+   function pthread_attr_setstacksize\n+     (attr      : access pthread_attr_t;\n+      stacksize : size_t) return int;\n+   pragma Import (C, pthread_attr_setstacksize, \"pthread_attr_setstacksize\");\n+\n+   function pthread_create\n+     (thread        : access pthread_t;\n+      attributes    : access pthread_attr_t;\n+      start_routine : Thread_Body;\n+      arg           : System.Address) return int;\n+   pragma Import (C, pthread_create, \"pthread_create\");\n+\n+   procedure pthread_exit (status : System.Address);\n+   pragma Import (C, pthread_exit, \"pthread_exit\");\n+\n+   function pthread_self return pthread_t;\n+   pragma Import (C, pthread_self, \"pthread_self\");\n+\n+   --------------------------\n+   -- POSIX.1c  Section 17 --\n+   --------------------------\n+\n+   function pthread_setspecific\n+     (key   : pthread_key_t;\n+      value : System.Address) return int;\n+   pragma Import (C, pthread_setspecific, \"pthread_setspecific\");\n+\n+   function pthread_getspecific (key : pthread_key_t) return System.Address;\n+   pragma Import (C, pthread_getspecific, \"pthread_getspecific\");\n+\n+   type destructor_pointer is access procedure (arg : System.Address);\n+\n+   function pthread_key_create\n+     (key        : access pthread_key_t;\n+      destructor : destructor_pointer) return int;\n+   pragma Import (C, pthread_key_create, \"pthread_key_create\");\n+\n+   ---------------------------------------------------------------\n+   --  Non portable SGI 6.5 additions to the pthread interface  --\n+   --  must be executed from within the context of a system     --\n+   --  scope task                                               --\n+   ---------------------------------------------------------------\n+\n+   function pthread_setrunon_np (cpu : int) return int;\n+   pragma Import (C, pthread_setrunon_np, \"pthread_setrunon_np\");\n+\n+private\n+\n+   type array_type_1 is array (Integer range 0 .. 3) of unsigned;\n+   type sigset_t is record\n+      X_X_sigbits : array_type_1;\n+   end record;\n+   pragma Convention (C, sigset_t);\n+\n+   type pid_t is new long;\n+\n+   type time_t is new long;\n+\n+   type timespec is record\n+      tv_sec  : time_t;\n+      tv_nsec : long;\n+   end record;\n+   pragma Convention (C, timespec);\n+\n+   type clockid_t is new int;\n+   CLOCK_REALTIME  : constant clockid_t := 1;\n+   CLOCK_SGI_CYCLE : constant clockid_t := 2;\n+   CLOCK_SGI_FAST  : constant clockid_t := 3;\n+\n+   type struct_timeval is record\n+      tv_sec  : time_t;\n+      tv_usec : time_t;\n+   end record;\n+   pragma Convention (C, struct_timeval);\n+\n+   type array_type_9 is array (Integer range 0 .. 4) of long;\n+   type pthread_attr_t is record\n+      X_X_D : array_type_9;\n+   end record;\n+   pragma Convention (C, pthread_attr_t);\n+\n+   type array_type_8 is array (Integer range 0 .. 1) of long;\n+   type pthread_condattr_t is record\n+      X_X_D : array_type_8;\n+   end record;\n+   pragma Convention (C, pthread_condattr_t);\n+\n+   type array_type_7 is array (Integer range 0 .. 1) of long;\n+   type pthread_mutexattr_t is record\n+      X_X_D : array_type_7;\n+   end record;\n+   pragma Convention (C, pthread_mutexattr_t);\n+\n+   type pthread_t is new unsigned;\n+\n+   type array_type_10 is array (Integer range 0 .. 7) of long;\n+   type pthread_mutex_t is record\n+      X_X_D : array_type_10;\n+   end record;\n+   pragma Convention (C, pthread_mutex_t);\n+\n+   type array_type_11 is array (Integer range 0 .. 7) of long;\n+   type pthread_cond_t is record\n+      X_X_D : array_type_11;\n+   end record;\n+   pragma Convention (C, pthread_cond_t);\n+\n+   type pthread_key_t is new int;\n+\n+end System.OS_Interface;"}, {"sha": "dca9f664a588872507d21778eb3941ecf3863cf1", "filename": "gcc/ada/5fsystem.ads", "status": "added", "additions": 153, "deletions": 0, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5fsystem.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5fsystem.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5fsystem.ads?ref=84481f762f0682e5f45b2f360446e1c7e333c880", "patch": "@@ -0,0 +1,153 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                        GNAT RUN-TIME COMPONENTS                          --\n+--                                                                          --\n+--                               S Y S T E M                                --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                           (SGI Irix, o32 ABI)                            --\n+--                                                                          --\n+--                            $Revision: 1.13 $\n+--                                                                          --\n+--          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+package System is\n+pragma Pure (System);\n+--  Note that we take advantage of the implementation permission to\n+--  make this unit Pure instead of Preelaborable, see RM 13.7(36)\n+\n+   type Name is (SYSTEM_NAME_GNAT);\n+   System_Name : constant Name := SYSTEM_NAME_GNAT;\n+\n+   --  System-Dependent Named Numbers\n+\n+   Min_Int               : constant := Long_Long_Integer'First;\n+   Max_Int               : constant := Long_Long_Integer'Last;\n+\n+   Max_Binary_Modulus    : constant := 2 ** Long_Long_Integer'Size;\n+   Max_Nonbinary_Modulus : constant := Integer'Last;\n+\n+   Max_Base_Digits       : constant := Long_Long_Float'Digits;\n+   Max_Digits            : constant := Long_Long_Float'Digits;\n+\n+   Max_Mantissa          : constant := 63;\n+   Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);\n+\n+   Tick                  : constant := Standard'Tick;\n+\n+   --  Storage-related Declarations\n+\n+   type Address is private;\n+   Null_Address : constant Address;\n+\n+   Storage_Unit : constant := Standard'Storage_Unit;\n+   Word_Size    : constant := Standard'Word_Size;\n+   Memory_Size  : constant := 2 ** Standard'Address_Size;\n+\n+   --  Address comparison\n+\n+   function \"<\"  (Left, Right : Address) return Boolean;\n+   function \"<=\" (Left, Right : Address) return Boolean;\n+   function \">\"  (Left, Right : Address) return Boolean;\n+   function \">=\" (Left, Right : Address) return Boolean;\n+   function \"=\"  (Left, Right : Address) return Boolean;\n+\n+   pragma Import (Intrinsic, \"<\");\n+   pragma Import (Intrinsic, \"<=\");\n+   pragma Import (Intrinsic, \">\");\n+   pragma Import (Intrinsic, \">=\");\n+   pragma Import (Intrinsic, \"=\");\n+\n+   --  Other System-Dependent Declarations\n+\n+   type Bit_Order is (High_Order_First, Low_Order_First);\n+   Default_Bit_Order : constant Bit_Order := High_Order_First;\n+\n+   --  Priority-related Declarations (RM D.1)\n+\n+   Max_Priority : constant Positive := 30;\n+\n+   Max_Interrupt_Priority : constant Positive := 31;\n+\n+   subtype Any_Priority is Integer\n+     range 0 .. Standard'Max_Interrupt_Priority;\n+\n+   subtype Priority is Any_Priority\n+     range 0 .. Standard'Max_Priority;\n+\n+   --  Functional notation is needed in the following to avoid visibility\n+   --  problems when this package is compiled through rtsfind in the middle\n+   --  of another compilation.\n+\n+   subtype Interrupt_Priority is Any_Priority\n+     range\n+       Standard.\"+\" (Standard'Max_Priority,  1) ..\n+         Standard'Max_Interrupt_Priority;\n+\n+   Default_Priority : constant Priority :=\n+     Standard.\"/\" (Standard.\"+\" (Priority'First, Priority'Last), 2);\n+\n+private\n+\n+   type Address is mod Memory_Size;\n+   Null_Address : constant Address := 0;\n+\n+   --------------------------------------\n+   -- System Implementation Parameters --\n+   --------------------------------------\n+\n+   --  These parameters provide information about the target that is used\n+   --  by the compiler. They are in the private part of System, where they\n+   --  can be accessed using the special circuitry in the Targparm unit\n+   --  whose source should be consulted for more detailed descriptions\n+   --  of the individual switch values.\n+\n+   AAMP                      : constant Boolean := False;\n+   Command_Line_Args         : constant Boolean := True;\n+   Denorm                    : constant Boolean := False;\n+   Frontend_Layout           : constant Boolean := False;\n+   Functions_Return_By_DSP   : constant Boolean := True;\n+   Long_Shifts_Inlined       : constant Boolean := True;\n+   High_Integrity_Mode       : constant Boolean := False;\n+   Machine_Overflows         : constant Boolean := False;\n+   Machine_Rounds            : constant Boolean := True;\n+   OpenVMS                   : constant Boolean := False;\n+   Signed_Zeros              : constant Boolean := True;\n+   Stack_Check_Default       : constant Boolean := False;\n+   Stack_Check_Probes        : constant Boolean := True;\n+   Use_Ada_Main_Program_Name : constant Boolean := False;\n+   ZCX_By_Default            : constant Boolean := True;\n+   GCC_ZCX_Support           : constant Boolean := False;\n+   Front_End_ZCX_Support     : constant Boolean := True;\n+\n+   --  Note: Denorm is False because denormals are not supported on the\n+   --  R10000, and we want the code to be valid for this processor.\n+\n+end System;"}, {"sha": "c9213f2b0fc28ff8056b3dbc1cb8b3148020118d", "filename": "gcc/ada/5ftaprop.adb", "status": "added", "additions": 998, "deletions": 0, "changes": 998, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5ftaprop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5ftaprop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5ftaprop.adb?ref=84481f762f0682e5f45b2f360446e1c7e333c880", "patch": "@@ -0,0 +1,998 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS               --\n+--                                                                          --\n+--     S Y S T E M . T A S K _ P R I M I T I V E S . O P E R A T I O N S    --\n+--                                                                          --\n+--                                  B o d y                                 --\n+--                                                                          --\n+--                             $Revision: 1.26 $\n+--                                                                          --\n+--            Copyright (C) 1991-2001, Florida State University             --\n+--                                                                          --\n+-- GNARL is free software; you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion. GNARL is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNARL; see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNARL was developed by the GNARL team at Florida State University. It is --\n+-- now maintained by Ada Core Technologies Inc. in cooperation with Florida --\n+-- State University (http://www.gnat.com).                                  --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is a IRIX (pthread library) version of this package.\n+\n+--  This package contains all the GNULL primitives that interface directly\n+--  with the underlying OS.\n+\n+pragma Polling (Off);\n+--  Turn off polling, we do not want ATC polling to take place during\n+--  tasking operations. It causes infinite loops and other problems.\n+\n+with Interfaces.C;\n+--  used for int\n+--           size_t\n+\n+with System.Task_Info;\n+\n+with System.Tasking.Debug;\n+--  used for Known_Tasks\n+\n+with System.IO;\n+--  used for Put_Line\n+\n+with System.Interrupt_Management;\n+--  used for Keep_Unmasked\n+--           Abort_Task_Interrupt\n+--           Interrupt_ID\n+\n+with System.Interrupt_Management.Operations;\n+--  used for Set_Interrupt_Mask\n+--           All_Tasks_Mask\n+pragma Elaborate_All (System.Interrupt_Management.Operations);\n+\n+with System.Parameters;\n+--  used for Size_Type\n+\n+with System.Tasking;\n+--  used for Ada_Task_Control_Block\n+--           Task_ID\n+\n+with System.Soft_Links;\n+--  used for Defer/Undefer_Abort\n+\n+--  Note that we do not use System.Tasking.Initialization directly since\n+--  this is a higher level package that we shouldn't depend on. For example\n+--  when using the restricted run time, it is replaced by\n+--  System.Tasking.Restricted.Initialization\n+\n+with System.Program_Info;\n+--  used for Default_Task_Stack\n+--           Default_Time_Slice\n+--           Stack_Guard_Pages\n+--           Pthread_Sched_Signal\n+--           Pthread_Arena_Size\n+\n+with System.OS_Interface;\n+--  used for various type, constant, and operations\n+\n+with System.OS_Primitives;\n+--  used for Delay_Modes\n+\n+with Unchecked_Conversion;\n+with Unchecked_Deallocation;\n+\n+package body System.Task_Primitives.Operations is\n+\n+   use System.Tasking;\n+   use System.Tasking.Debug;\n+   use Interfaces.C;\n+   use System.OS_Interface;\n+   use System.OS_Primitives;\n+   use System.Parameters;\n+\n+   package SSL renames System.Soft_Links;\n+\n+   ------------------\n+   --  Local Data  --\n+   ------------------\n+\n+   --  The followings are logically constants, but need to be initialized\n+   --  at run time.\n+\n+   ATCB_Key : aliased pthread_key_t;\n+   --  Key used to find the Ada Task_ID associated with a thread\n+\n+   All_Tasks_L : aliased System.Task_Primitives.RTS_Lock;\n+   --  See comments on locking rules in System.Locking_Rules (spec).\n+\n+   Environment_Task_ID : Task_ID;\n+   --  A variable to hold Task_ID for the environment task.\n+\n+   Locking_Policy : Character;\n+   pragma Import (C, Locking_Policy, \"__gl_locking_policy\");\n+\n+   Real_Time_Clock_Id : constant clockid_t := CLOCK_REALTIME;\n+\n+   Unblocked_Signal_Mask : aliased sigset_t;\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   function To_Task_ID is new Unchecked_Conversion (System.Address, Task_ID);\n+\n+   function To_Address is new Unchecked_Conversion (Task_ID, System.Address);\n+\n+   procedure Abort_Handler (Sig : Signal);\n+\n+   -------------------\n+   -- Abort_Handler --\n+   -------------------\n+\n+   procedure Abort_Handler (Sig : Signal) is\n+      T       : Task_ID := Self;\n+      Result  : Interfaces.C.int;\n+      Old_Set : aliased sigset_t;\n+\n+   begin\n+      if T.Deferral_Level = 0\n+        and then T.Pending_ATC_Level < T.ATC_Nesting_Level\n+      then\n+         --  Make sure signals used for RTS internal purpose are unmasked\n+\n+         Result := pthread_sigmask\n+           (SIG_UNBLOCK,\n+            Unblocked_Signal_Mask'Unchecked_Access,\n+            Old_Set'Unchecked_Access);\n+         pragma Assert (Result = 0);\n+\n+         raise Standard'Abort_Signal;\n+      end if;\n+   end Abort_Handler;\n+\n+   -----------------\n+   -- Stack_Guard --\n+   -----------------\n+\n+   --  The underlying thread system sets a guard page at the\n+   --  bottom of a thread stack, so nothing is needed.\n+\n+   procedure Stack_Guard (T : ST.Task_ID; On : Boolean) is\n+   begin\n+      null;\n+   end Stack_Guard;\n+\n+   -------------------\n+   -- Get_Thread_Id --\n+   -------------------\n+\n+   function Get_Thread_Id (T : ST.Task_ID) return OSI.Thread_Id is\n+   begin\n+      return T.Common.LL.Thread;\n+   end Get_Thread_Id;\n+\n+   ----------\n+   -- Self --\n+   ----------\n+\n+   function Self return Task_ID is\n+      Result : System.Address;\n+\n+   begin\n+      Result := pthread_getspecific (ATCB_Key);\n+      pragma Assert (Result /= System.Null_Address);\n+\n+      return To_Task_ID (Result);\n+   end Self;\n+\n+   ---------------------\n+   -- Initialize_Lock --\n+   ---------------------\n+\n+   --  Note: mutexes and cond_variables needed per-task basis are\n+   --        initialized in Intialize_TCB and the Storage_Error is\n+   --        handled. Other mutexes (such as All_Tasks_Lock, Memory_Lock...)\n+   --        used in RTS is initialized before any status change of RTS.\n+   --        Therefore rasing Storage_Error in the following routines\n+   --        should be able to be handled safely.\n+\n+   procedure Initialize_Lock\n+     (Prio : System.Any_Priority;\n+      L    : access Lock)\n+   is\n+      Attributes : aliased pthread_mutexattr_t;\n+      Result     : Interfaces.C.int;\n+\n+   begin\n+      Result := pthread_mutexattr_init (Attributes'Access);\n+      pragma Assert (Result = 0 or else Result = ENOMEM);\n+\n+      if Result = ENOMEM then\n+         raise Storage_Error;\n+      end if;\n+\n+      if Locking_Policy = 'C' then\n+         Result := pthread_mutexattr_setprotocol\n+           (Attributes'Access, PTHREAD_PRIO_PROTECT);\n+         pragma Assert (Result = 0);\n+\n+         Result := pthread_mutexattr_setprioceiling\n+            (Attributes'Access, Interfaces.C.int (Prio));\n+         pragma Assert (Result = 0);\n+      end if;\n+\n+      Result := pthread_mutex_init (L, Attributes'Access);\n+      pragma Assert (Result = 0 or else Result = ENOMEM);\n+\n+      if Result = ENOMEM then\n+         Result := pthread_mutexattr_destroy (Attributes'Access);\n+         raise Storage_Error;\n+      end if;\n+\n+      Result := pthread_mutexattr_destroy (Attributes'Access);\n+      pragma Assert (Result = 0);\n+   end Initialize_Lock;\n+\n+   procedure Initialize_Lock (L : access RTS_Lock; Level : Lock_Level) is\n+      Attributes : aliased pthread_mutexattr_t;\n+      Result : Interfaces.C.int;\n+\n+   begin\n+      Result := pthread_mutexattr_init (Attributes'Access);\n+      pragma Assert (Result = 0 or else Result = ENOMEM);\n+\n+      if Result = ENOMEM then\n+         raise Storage_Error;\n+      end if;\n+\n+      if Locking_Policy = 'C' then\n+         Result := pthread_mutexattr_setprotocol\n+           (Attributes'Access, PTHREAD_PRIO_PROTECT);\n+         pragma Assert (Result = 0);\n+\n+         Result := pthread_mutexattr_setprioceiling\n+            (Attributes'Access, Interfaces.C.int (System.Any_Priority'Last));\n+         pragma Assert (Result = 0);\n+      end if;\n+\n+      Result := pthread_mutex_init (L, Attributes'Access);\n+\n+      pragma Assert (Result = 0 or else Result = ENOMEM);\n+\n+      if Result = ENOMEM then\n+         Result := pthread_mutexattr_destroy (Attributes'Access);\n+         raise Storage_Error;\n+      end if;\n+\n+      Result := pthread_mutexattr_destroy (Attributes'Access);\n+   end Initialize_Lock;\n+\n+   -------------------\n+   -- Finalize_Lock --\n+   -------------------\n+\n+   procedure Finalize_Lock (L : access Lock) is\n+      Result : Interfaces.C.int;\n+\n+   begin\n+      Result := pthread_mutex_destroy (L);\n+      pragma Assert (Result = 0);\n+   end Finalize_Lock;\n+\n+   procedure Finalize_Lock (L : access RTS_Lock) is\n+      Result : Interfaces.C.int;\n+\n+   begin\n+      Result := pthread_mutex_destroy (L);\n+      pragma Assert (Result = 0);\n+   end Finalize_Lock;\n+\n+   ----------------\n+   -- Write_Lock --\n+   ----------------\n+\n+   procedure Write_Lock (L : access Lock; Ceiling_Violation : out Boolean) is\n+      Result : Interfaces.C.int;\n+\n+   begin\n+      Result := pthread_mutex_lock (L);\n+      Ceiling_Violation := Result = EINVAL;\n+\n+      --  assumes the cause of EINVAL is a priority ceiling violation\n+\n+      pragma Assert (Result = 0 or else Result = EINVAL);\n+   end Write_Lock;\n+\n+   procedure Write_Lock (L : access RTS_Lock) is\n+      Result : Interfaces.C.int;\n+\n+   begin\n+      Result := pthread_mutex_lock (L);\n+      pragma Assert (Result = 0);\n+   end Write_Lock;\n+\n+   procedure Write_Lock (T : Task_ID) is\n+      Result : Interfaces.C.int;\n+\n+   begin\n+      Result := pthread_mutex_lock (T.Common.LL.L'Access);\n+      pragma Assert (Result = 0);\n+   end Write_Lock;\n+\n+   ---------------\n+   -- Read_Lock --\n+   ---------------\n+\n+   procedure Read_Lock (L : access Lock; Ceiling_Violation : out Boolean) is\n+   begin\n+      Write_Lock (L, Ceiling_Violation);\n+   end Read_Lock;\n+\n+   ------------\n+   -- Unlock --\n+   ------------\n+\n+   procedure Unlock (L : access Lock) is\n+      Result : Interfaces.C.int;\n+\n+   begin\n+      Result := pthread_mutex_unlock (L);\n+      pragma Assert (Result = 0);\n+   end Unlock;\n+\n+   procedure Unlock (L : access RTS_Lock) is\n+      Result : Interfaces.C.int;\n+\n+   begin\n+      Result := pthread_mutex_unlock (L);\n+      pragma Assert (Result = 0);\n+   end Unlock;\n+\n+   procedure Unlock (T : Task_ID) is\n+      Result : Interfaces.C.int;\n+\n+   begin\n+      Result := pthread_mutex_unlock (T.Common.LL.L'Access);\n+      pragma Assert (Result = 0);\n+   end Unlock;\n+\n+   -----------\n+   -- Sleep --\n+   -----------\n+\n+   procedure Sleep\n+     (Self_ID : ST.Task_ID;\n+      Reason  : System.Tasking.Task_States)\n+   is\n+      Result : Interfaces.C.int;\n+   begin\n+      pragma Assert (Self_ID = Self);\n+      Result := pthread_cond_wait (Self_ID.Common.LL.CV'Access,\n+        Self_ID.Common.LL.L'Access);\n+\n+      --  EINTR is not considered a failure.\n+\n+      pragma Assert (Result = 0 or else Result = EINTR);\n+   end Sleep;\n+\n+   -----------------\n+   -- Timed_Sleep --\n+   -----------------\n+\n+   procedure Timed_Sleep\n+     (Self_ID  : Task_ID;\n+      Time     : Duration;\n+      Mode     : ST.Delay_Modes;\n+      Reason   : Task_States;\n+      Timedout : out Boolean;\n+      Yielded  : out Boolean)\n+   is\n+      Check_Time : constant Duration := Monotonic_Clock;\n+      Abs_Time   : Duration;\n+      Request    : aliased timespec;\n+      Result     : Interfaces.C.int;\n+\n+   begin\n+      Timedout := True;\n+      Yielded  := False;\n+\n+      if Mode = Relative then\n+         Abs_Time := Duration'Min (Time, Max_Sensible_Delay) + Check_Time;\n+      else\n+         Abs_Time := Duration'Min (Check_Time + Max_Sensible_Delay, Time);\n+      end if;\n+\n+      if Abs_Time > Check_Time then\n+         Request := To_Timespec (Abs_Time);\n+\n+         loop\n+            exit when Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level\n+              or else Self_ID.Pending_Priority_Change;\n+\n+            Result := pthread_cond_timedwait (Self_ID.Common.LL.CV'Access,\n+              Self_ID.Common.LL.L'Access, Request'Access);\n+\n+            exit when Abs_Time <= Monotonic_Clock;\n+\n+            if Result = 0 or else errno = EINTR then\n+               Timedout := False;\n+               exit;\n+            end if;\n+         end loop;\n+      end if;\n+   end Timed_Sleep;\n+\n+   -----------------\n+   -- Timed_Delay --\n+   -----------------\n+\n+   --  This is for use in implementing delay statements, so\n+   --  we assume the caller is abort-deferred but is holding\n+   --  no locks.\n+\n+   procedure Timed_Delay\n+     (Self_ID : Task_ID;\n+      Time    : Duration;\n+      Mode    : ST.Delay_Modes)\n+   is\n+      Check_Time : constant Duration := Monotonic_Clock;\n+      Abs_Time   : Duration;\n+      Request    : aliased timespec;\n+      Result     : Interfaces.C.int;\n+\n+   begin\n+      --  Only the little window between deferring abort and\n+      --  locking Self_ID is the reason we need to\n+      --  check for pending abort and priority change below! :(\n+\n+      SSL.Abort_Defer.all;\n+      Write_Lock (Self_ID);\n+\n+      if Mode = Relative then\n+         Abs_Time := Time + Check_Time;\n+      else\n+         Abs_Time := Duration'Min (Check_Time + Max_Sensible_Delay, Time);\n+      end if;\n+\n+      if Abs_Time > Check_Time then\n+         Request := To_Timespec (Abs_Time);\n+         Self_ID.Common.State := Delay_Sleep;\n+\n+         loop\n+            if Self_ID.Pending_Priority_Change then\n+               Self_ID.Pending_Priority_Change := False;\n+               Self_ID.Common.Base_Priority := Self_ID.New_Base_Priority;\n+               Set_Priority (Self_ID, Self_ID.Common.Base_Priority);\n+            end if;\n+\n+            exit when Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level;\n+\n+            Result := pthread_cond_timedwait (Self_ID.Common.LL.CV'Access,\n+              Self_ID.Common.LL.L'Access, Request'Access);\n+            exit when Abs_Time <= Monotonic_Clock;\n+\n+            pragma Assert (Result = 0\n+              or else Result = ETIMEDOUT\n+              or else Result = EINTR);\n+         end loop;\n+\n+         Self_ID.Common.State := Runnable;\n+      end if;\n+\n+      Unlock (Self_ID);\n+      Yield;\n+      SSL.Abort_Undefer.all;\n+   end Timed_Delay;\n+\n+   ---------------------\n+   -- Monotonic_Clock --\n+   ---------------------\n+\n+   function Monotonic_Clock return Duration is\n+      TS     : aliased timespec;\n+      Result : Interfaces.C.int;\n+\n+   begin\n+      Result := clock_gettime (Real_Time_Clock_Id, TS'Unchecked_Access);\n+      pragma Assert (Result = 0);\n+      return To_Duration (TS);\n+   end Monotonic_Clock;\n+\n+   -------------------\n+   -- RT_Resolution --\n+   -------------------\n+\n+   function RT_Resolution return Duration is\n+   begin\n+      --  The clock_getres (Real_Time_Clock_Id) function appears to return\n+      --  the interrupt resolution of the realtime clock and not the actual\n+      --  resolution of reading the clock. Even though this last value is\n+      --  only guaranteed to be 100 Hz, at least the Origin 200 appears to\n+      --  have a microsecond resolution or better.\n+      --  ??? We should figure out a method to return the right value on\n+      --  all SGI hardware.\n+\n+      return 0.000_001; --  Assume microsecond resolution of clock\n+   end RT_Resolution;\n+\n+   ------------\n+   -- Wakeup --\n+   ------------\n+\n+   procedure Wakeup (T : ST.Task_ID; Reason : System.Tasking.Task_States) is\n+      Result : Interfaces.C.int;\n+   begin\n+      Result := pthread_cond_signal (T.Common.LL.CV'Access);\n+      pragma Assert (Result = 0);\n+   end Wakeup;\n+\n+   -----------\n+   -- Yield --\n+   -----------\n+\n+   procedure Yield (Do_Yield : Boolean := True) is\n+      Result : Interfaces.C.int;\n+   begin\n+      if Do_Yield then\n+         Result := sched_yield;\n+      end if;\n+   end Yield;\n+\n+   ------------------\n+   -- Set_Priority --\n+   ------------------\n+\n+   procedure Set_Priority\n+     (T                   : Task_ID;\n+      Prio                : System.Any_Priority;\n+      Loss_Of_Inheritance : Boolean := False)\n+   is\n+      Result       : Interfaces.C.int;\n+      Param        : aliased struct_sched_param;\n+      Sched_Policy : Interfaces.C.int;\n+\n+      use type System.Task_Info.Task_Info_Type;\n+\n+      function To_Int is new Unchecked_Conversion\n+        (System.Task_Info.Thread_Scheduling_Policy, Interfaces.C.int);\n+\n+   begin\n+      T.Common.Current_Priority := Prio;\n+      Param.sched_priority := Interfaces.C.int (Prio);\n+\n+      if T.Common.Task_Info /= null then\n+         Sched_Policy := To_Int (T.Common.Task_Info.Policy);\n+      else\n+         Sched_Policy := SCHED_FIFO;\n+      end if;\n+\n+      Result := pthread_setschedparam (T.Common.LL.Thread, Sched_Policy,\n+        Param'Access);\n+      pragma Assert (Result = 0);\n+   end Set_Priority;\n+\n+   ------------------\n+   -- Get_Priority --\n+   ------------------\n+\n+   function Get_Priority (T : Task_ID) return System.Any_Priority is\n+   begin\n+      return T.Common.Current_Priority;\n+   end Get_Priority;\n+\n+   ----------------\n+   -- Enter_Task --\n+   ----------------\n+\n+   procedure Enter_Task (Self_ID : Task_ID) is\n+      Result : Interfaces.C.int;\n+\n+      function To_Int is new Unchecked_Conversion\n+        (System.Task_Info.CPU_Number, Interfaces.C.int);\n+\n+      use System.Task_Info;\n+\n+   begin\n+      Self_ID.Common.LL.Thread := pthread_self;\n+      Result := pthread_setspecific (ATCB_Key, To_Address (Self_ID));\n+      pragma Assert (Result = 0);\n+\n+      if Self_ID.Common.Task_Info /= null\n+        and then Self_ID.Common.Task_Info.Scope = PTHREAD_SCOPE_SYSTEM\n+        and then Self_ID.Common.Task_Info.Runon_CPU /= ANY_CPU\n+      then\n+         Result := pthread_setrunon_np\n+           (To_Int (Self_ID.Common.Task_Info.Runon_CPU));\n+         pragma Assert (Result = 0);\n+      end if;\n+\n+      Lock_All_Tasks_List;\n+\n+      for J in Known_Tasks'Range loop\n+         if Known_Tasks (J) = null then\n+            Known_Tasks (J) := Self_ID;\n+            Self_ID.Known_Tasks_Index := J;\n+            exit;\n+         end if;\n+      end loop;\n+\n+      Unlock_All_Tasks_List;\n+   end Enter_Task;\n+\n+   --------------\n+   -- New_ATCB --\n+   --------------\n+\n+   function New_ATCB (Entry_Num : Task_Entry_Index) return Task_ID is\n+   begin\n+      return new Ada_Task_Control_Block (Entry_Num);\n+   end New_ATCB;\n+\n+   --------------------\n+   -- Initialize_TCB --\n+   --------------------\n+\n+   procedure Initialize_TCB (Self_ID : Task_ID; Succeeded : out Boolean) is\n+      Result    : Interfaces.C.int;\n+      Cond_Attr : aliased pthread_condattr_t;\n+\n+   begin\n+      Initialize_Lock (Self_ID.Common.LL.L'Access, All_Tasks_Level);\n+\n+      Result := pthread_condattr_init (Cond_Attr'Access);\n+      pragma Assert (Result = 0 or else Result = ENOMEM);\n+\n+      if Result /= 0 then\n+         Result := pthread_mutex_destroy (Self_ID.Common.LL.L'Access);\n+         pragma Assert (Result = 0);\n+\n+         Succeeded := False;\n+         return;\n+      end if;\n+\n+      Result := pthread_cond_init (Self_ID.Common.LL.CV'Access,\n+        Cond_Attr'Access);\n+      pragma Assert (Result = 0 or else Result = ENOMEM);\n+\n+      if Result = 0 then\n+         Succeeded := True;\n+      else\n+         Result := pthread_mutex_destroy (Self_ID.Common.LL.L'Access);\n+         pragma Assert (Result = 0);\n+         Succeeded := False;\n+      end if;\n+\n+      Result := pthread_condattr_destroy (Cond_Attr'Access);\n+      pragma Assert (Result = 0);\n+   end Initialize_TCB;\n+\n+   -----------------\n+   -- Create_Task --\n+   -----------------\n+\n+   procedure Create_Task\n+     (T          : Task_ID;\n+      Wrapper    : System.Address;\n+      Stack_Size : System.Parameters.Size_Type;\n+      Priority   : System.Any_Priority;\n+      Succeeded  : out Boolean)\n+   is\n+      use System.Task_Info;\n+\n+      Attributes          : aliased pthread_attr_t;\n+      Sched_Param         : aliased struct_sched_param;\n+      Adjusted_Stack_Size : Interfaces.C.size_t;\n+      Result              : Interfaces.C.int;\n+\n+      function Thread_Body_Access is new\n+        Unchecked_Conversion (System.Address, Thread_Body);\n+\n+      function To_Int is new Unchecked_Conversion\n+        (System.Task_Info.Thread_Scheduling_Scope, Interfaces.C.int);\n+      function To_Int is new Unchecked_Conversion\n+        (System.Task_Info.Thread_Scheduling_Inheritance, Interfaces.C.int);\n+      function To_Int is new Unchecked_Conversion\n+        (System.Task_Info.Thread_Scheduling_Policy, Interfaces.C.int);\n+\n+   begin\n+      if Stack_Size = System.Parameters.Unspecified_Size then\n+         Adjusted_Stack_Size :=\n+           Interfaces.C.size_t (System.Program_Info.Default_Task_Stack);\n+\n+      elsif Stack_Size < Size_Type (Minimum_Stack_Size) then\n+         Adjusted_Stack_Size :=\n+           Interfaces.C.size_t (Minimum_Stack_Size);\n+\n+      else\n+         Adjusted_Stack_Size := Interfaces.C.size_t (Stack_Size);\n+      end if;\n+\n+      Result := pthread_attr_init (Attributes'Access);\n+      pragma Assert (Result = 0 or else Result = ENOMEM);\n+\n+      if Result /= 0 then\n+         Succeeded := False;\n+         return;\n+      end if;\n+\n+      Result := pthread_attr_setdetachstate\n+        (Attributes'Access, PTHREAD_CREATE_DETACHED);\n+      pragma Assert (Result = 0);\n+\n+      Result := pthread_attr_setstacksize\n+        (Attributes'Access, Interfaces.C.size_t (Adjusted_Stack_Size));\n+      pragma Assert (Result = 0);\n+\n+      if T.Common.Task_Info /= null then\n+         Result := pthread_attr_setscope\n+           (Attributes'Access, To_Int (T.Common.Task_Info.Scope));\n+         pragma Assert (Result = 0);\n+\n+         Result := pthread_attr_setinheritsched\n+           (Attributes'Access, To_Int (T.Common.Task_Info.Inheritance));\n+         pragma Assert (Result = 0);\n+\n+         Result := pthread_attr_setschedpolicy\n+           (Attributes'Access, To_Int (T.Common.Task_Info.Policy));\n+         pragma Assert (Result = 0);\n+\n+         Sched_Param.sched_priority :=\n+           Interfaces.C.int (T.Common.Task_Info.Priority);\n+\n+         Result := pthread_attr_setschedparam\n+           (Attributes'Access, Sched_Param'Access);\n+         pragma Assert (Result = 0);\n+      end if;\n+\n+      --  Since the initial signal mask of a thread is inherited from the\n+      --  creator, and the Environment task has all its signals masked, we\n+      --  do not need to manipulate caller's signal mask at this point.\n+      --  All tasks in RTS will have All_Tasks_Mask initially.\n+\n+      Result := pthread_create\n+        (T.Common.LL.Thread'Access,\n+         Attributes'Access,\n+         Thread_Body_Access (Wrapper),\n+         To_Address (T));\n+\n+      if Result /= 0\n+        and then T.Common.Task_Info /= null\n+        and then T.Common.Task_Info.Scope = PTHREAD_SCOPE_SYSTEM\n+      then\n+         --  The pthread_create call may have failed because we\n+         --  asked for a system scope pthread and none were\n+         --  available (probably because the program was not executed\n+         --  by the superuser). Let's try for a process scope pthread\n+         --  instead of raising Tasking_Error.\n+\n+         System.IO.Put_Line\n+           (\"Request for PTHREAD_SCOPE_SYSTEM in Task_Info pragma for task\");\n+         System.IO.Put (\"\"\"\");\n+         System.IO.Put (T.Common.Task_Image.all);\n+         System.IO.Put_Line (\"\"\" could not be honored. \");\n+         System.IO.Put_Line (\"Scope changed to PTHREAD_SCOPE_PROCESS\");\n+\n+         T.Common.Task_Info.Scope := PTHREAD_SCOPE_PROCESS;\n+         Result := pthread_attr_setscope\n+           (Attributes'Access, To_Int (T.Common.Task_Info.Scope));\n+         pragma Assert (Result = 0);\n+\n+         Result := pthread_create\n+           (T.Common.LL.Thread'Access,\n+            Attributes'Access,\n+            Thread_Body_Access (Wrapper),\n+            To_Address (T));\n+      end if;\n+\n+      pragma Assert (Result = 0 or else Result = EAGAIN);\n+\n+      Succeeded := Result = 0;\n+\n+      Set_Priority (T, Priority);\n+\n+      Result := pthread_attr_destroy (Attributes'Access);\n+      pragma Assert (Result = 0);\n+   end Create_Task;\n+\n+   ------------------\n+   -- Finalize_TCB --\n+   ------------------\n+\n+   procedure Finalize_TCB (T : Task_ID) is\n+      Result : Interfaces.C.int;\n+      Tmp    : Task_ID := T;\n+\n+      procedure Free is new\n+        Unchecked_Deallocation (Ada_Task_Control_Block, Task_ID);\n+\n+   begin\n+      Result := pthread_mutex_destroy (T.Common.LL.L'Access);\n+      pragma Assert (Result = 0);\n+\n+      Result := pthread_cond_destroy (T.Common.LL.CV'Access);\n+      pragma Assert (Result = 0);\n+\n+      if T.Known_Tasks_Index /= -1 then\n+         Known_Tasks (T.Known_Tasks_Index) := null;\n+      end if;\n+\n+      Free (Tmp);\n+   end Finalize_TCB;\n+\n+   ---------------\n+   -- Exit_Task --\n+   ---------------\n+\n+   procedure Exit_Task is\n+   begin\n+      pthread_exit (System.Null_Address);\n+   end Exit_Task;\n+\n+   ----------------\n+   -- Abort_Task --\n+   ----------------\n+\n+   procedure Abort_Task (T : Task_ID) is\n+      Result : Interfaces.C.int;\n+   begin\n+      Result := pthread_kill (T.Common.LL.Thread,\n+        Signal (System.Interrupt_Management.Abort_Task_Interrupt));\n+      pragma Assert (Result = 0);\n+   end Abort_Task;\n+\n+   ----------------\n+   -- Check_Exit --\n+   ----------------\n+\n+   --  Dummy versions. The only currently working versions is for solaris\n+   --  (native).\n+\n+   function Check_Exit (Self_ID : ST.Task_ID) return Boolean is\n+   begin\n+      return True;\n+   end Check_Exit;\n+\n+   --------------------\n+   -- Check_No_Locks --\n+   --------------------\n+\n+   function Check_No_Locks (Self_ID : ST.Task_ID) return Boolean is\n+   begin\n+      return True;\n+   end Check_No_Locks;\n+\n+   ----------------------\n+   -- Environment_Task --\n+   ----------------------\n+\n+   function Environment_Task return Task_ID is\n+   begin\n+      return Environment_Task_ID;\n+   end Environment_Task;\n+\n+   -------------------------\n+   -- Lock_All_Tasks_List --\n+   -------------------------\n+\n+   procedure Lock_All_Tasks_List is\n+   begin\n+      Write_Lock (All_Tasks_L'Access);\n+   end Lock_All_Tasks_List;\n+\n+   ---------------------------\n+   -- Unlock_All_Tasks_List --\n+   ---------------------------\n+\n+   procedure Unlock_All_Tasks_List is\n+   begin\n+      Unlock (All_Tasks_L'Access);\n+   end Unlock_All_Tasks_List;\n+\n+   ------------------\n+   -- Suspend_Task --\n+   ------------------\n+\n+   function Suspend_Task\n+     (T           : ST.Task_ID;\n+      Thread_Self : Thread_Id) return Boolean is\n+   begin\n+      return False;\n+   end Suspend_Task;\n+\n+   -----------------\n+   -- Resume_Task --\n+   -----------------\n+\n+   function Resume_Task\n+     (T           : ST.Task_ID;\n+      Thread_Self : Thread_Id) return Boolean is\n+   begin\n+      return False;\n+   end Resume_Task;\n+\n+   ----------------\n+   -- Initialize --\n+   ----------------\n+\n+   procedure Initialize (Environment_Task : Task_ID) is\n+      act     : aliased struct_sigaction;\n+      old_act : aliased struct_sigaction;\n+      Tmp_Set : aliased sigset_t;\n+      Result  : Interfaces.C.int;\n+\n+   begin\n+      Environment_Task_ID := Environment_Task;\n+\n+      --  Initialize the lock used to synchronize chain of all ATCBs.\n+      Initialize_Lock (All_Tasks_L'Access, All_Tasks_Level);\n+\n+      Enter_Task (Environment_Task);\n+\n+      --  Install the abort-signal handler\n+\n+      act.sa_flags := 0;\n+      act.sa_handler := Abort_Handler'Address;\n+\n+      Result := sigemptyset (Tmp_Set'Access);\n+      pragma Assert (Result = 0);\n+      act.sa_mask := Tmp_Set;\n+\n+      Result :=\n+        sigaction (\n+          Signal (System.Interrupt_Management.Abort_Task_Interrupt),\n+          act'Unchecked_Access,\n+          old_act'Unchecked_Access);\n+      pragma Assert (Result = 0);\n+   end Initialize;\n+\n+begin\n+   declare\n+      Result : Interfaces.C.int;\n+   begin\n+      --  Mask Environment task for all signals. The original mask of the\n+      --  Environment task will be recovered by Interrupt_Server task\n+      --  during the elaboration of s-interr.adb.\n+\n+      System.Interrupt_Management.Operations.Set_Interrupt_Mask\n+        (System.Interrupt_Management.Operations.All_Tasks_Mask'Access);\n+\n+      --  Prepare the set of signals that should unblocked in all tasks\n+\n+      Result := sigemptyset (Unblocked_Signal_Mask'Access);\n+      pragma Assert (Result = 0);\n+\n+      for J in Interrupt_Management.Interrupt_ID loop\n+         if System.Interrupt_Management.Keep_Unmasked (J) then\n+            Result := sigaddset (Unblocked_Signal_Mask'Access, Signal (J));\n+            pragma Assert (Result = 0);\n+         end if;\n+      end loop;\n+\n+      Result := pthread_key_create (ATCB_Key'Access, null);\n+      pragma Assert (Result = 0);\n+\n+      --  Pick the highest resolution Clock for Clock_Realtime\n+      --  ??? This code currently doesn't work (see c94007[ab] for example)\n+      --\n+      --  if syssgi (SGI_CYCLECNTR_SIZE) = 64 then\n+      --     Real_Time_Clock_Id := CLOCK_SGI_CYCLE;\n+      --  else\n+      --     Real_Time_Clock_Id := CLOCK_REALTIME;\n+      --  end if;\n+   end;\n+end System.Task_Primitives.Operations;"}, {"sha": "8faecacb6a6ff8d229de67e48464f320a110d6ff", "filename": "gcc/ada/5ftasinf.ads", "status": "added", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5ftasinf.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5ftasinf.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5ftasinf.ads?ref=84481f762f0682e5f45b2f360446e1c7e333c880", "patch": "@@ -0,0 +1,142 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                     S Y S T E M . T A S K _ I N F O                      --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                           (Compiler Interface)                           --\n+--                                                                          --\n+--                            $Revision: 1.4 $\n+--                                                                          --\n+--          Copyright (C) 1992-2000 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package contains the definitions and routines associated with the\n+--  implementation of the Task_Info pragma. It is specialized appropriately\n+--  for targets that make use of this pragma.\n+\n+--  Note: the compiler generates direct calls to this interface, via Rtsfind.\n+--  Any changes to this interface may require corresponding compiler changes.\n+\n+with Interfaces.C;\n+with System.OS_Interface;\n+with Unchecked_Deallocation;\n+\n+package System.Task_Info is\n+pragma Elaborate_Body;\n+--  To ensure that a body is allowed\n+\n+   package OSI renames System.OS_Interface;\n+\n+   -----------------------------------------\n+   -- Implementation of Task_Info Feature --\n+   -----------------------------------------\n+\n+   --  Pragma Task_Info allows an application to set the underlying\n+   --  pthread scheduling attributes for a specific task.\n+\n+   ------------------\n+   -- Declarations --\n+   ------------------\n+\n+   type Thread_Scheduling_Scope is\n+     (PTHREAD_SCOPE_PROCESS, PTHREAD_SCOPE_SYSTEM);\n+\n+   for Thread_Scheduling_Scope'Size use Interfaces.C.int'Size;\n+\n+   type Thread_Scheduling_Inheritance is\n+      (PTHREAD_EXPLICIT_SCHED, PTHREAD_INHERIT_SCHED);\n+\n+   for Thread_Scheduling_Inheritance'Size use Interfaces.C.int'Size;\n+\n+   type Thread_Scheduling_Policy is\n+      (SCHED_FIFO,   --  The first-in-first-out real-time policy\n+       SCHED_RR,     --  The round-robin real-time scheduling policy\n+       SCHED_TS);    --  The timeshare earnings based scheduling policy\n+\n+   for Thread_Scheduling_Policy'Size use Interfaces.C.int'Size;\n+   for Thread_Scheduling_Policy use\n+      (SCHED_FIFO => 1,\n+       SCHED_RR   => 2,\n+       SCHED_TS   => 3);\n+\n+   function SCHED_OTHER return Thread_Scheduling_Policy renames SCHED_TS;\n+\n+   No_Specified_Priority : constant := -1;\n+\n+   subtype Thread_Scheduling_Priority is Integer range\n+     No_Specified_Priority .. 255;\n+\n+   function Min (Policy : Interfaces.C.int) return Interfaces.C.int\n+     renames OSI.sched_get_priority_min;\n+\n+   function Max (Policy : Interfaces.C.int) return Interfaces.C.int\n+     renames OSI.sched_get_priority_max;\n+\n+   subtype FIFO_Priority is Thread_Scheduling_Priority range\n+      Thread_Scheduling_Priority (Min (OSI.SCHED_FIFO)) ..\n+      Thread_Scheduling_Priority (Max (OSI.SCHED_FIFO));\n+\n+   subtype RR_Priority is Thread_Scheduling_Priority range\n+      Thread_Scheduling_Priority (Min (OSI.SCHED_RR)) ..\n+      Thread_Scheduling_Priority (Max (OSI.SCHED_RR));\n+\n+   subtype TS_Priority is Thread_Scheduling_Priority range\n+      Thread_Scheduling_Priority (Min (OSI.SCHED_TS)) ..\n+      Thread_Scheduling_Priority (Max (OSI.SCHED_TS));\n+\n+   subtype OTHER_Priority is Thread_Scheduling_Priority range\n+      Thread_Scheduling_Priority (Min (OSI.SCHED_OTHER)) ..\n+      Thread_Scheduling_Priority (Max (OSI.SCHED_OTHER));\n+\n+   subtype CPU_Number is Integer range -1 .. Integer'Last;\n+   ANY_CPU : constant CPU_Number := CPU_Number'First;\n+\n+   type Thread_Attributes is record\n+      Scope       : Thread_Scheduling_Scope       := PTHREAD_SCOPE_PROCESS;\n+      Inheritance : Thread_Scheduling_Inheritance := PTHREAD_EXPLICIT_SCHED;\n+      Policy      : Thread_Scheduling_Policy      := SCHED_RR;\n+      Priority    : Thread_Scheduling_Priority    := No_Specified_Priority;\n+      Runon_CPU   : CPU_Number                    := ANY_CPU;\n+   end record;\n+\n+   Default_Thread_Attributes : constant Thread_Attributes :=\n+     (PTHREAD_SCOPE_PROCESS, PTHREAD_EXPLICIT_SCHED, SCHED_RR,\n+       No_Specified_Priority, ANY_CPU);\n+\n+   type Task_Info_Type is access all Thread_Attributes;\n+\n+   type Task_Image_Type is access String;\n+   --  Used to generate a meaningful identifier for tasks that are variables\n+   --  and components of variables.\n+\n+   procedure Free_Task_Image is new\n+     Unchecked_Deallocation (String, Task_Image_Type);\n+\n+   Unspecified_Task_Info : constant Task_Info_Type := null;\n+   --  Value passed to task in the absence of a Task_Info pragma\n+\n+end System.Task_Info;"}, {"sha": "c4db14c98a769fc951ca12dc361a99236481f9dd", "filename": "gcc/ada/5ginterr.adb", "status": "added", "additions": 666, "deletions": 0, "changes": 666, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5ginterr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5ginterr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5ginterr.adb?ref=84481f762f0682e5f45b2f360446e1c7e333c880", "patch": "@@ -0,0 +1,666 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS               --\n+--                                                                          --\n+--                     S Y S T E M . I N T E R R U P T S                    --\n+--                                                                          --\n+--                                  B o d y                                 --\n+--                                                                          --\n+--                             $Revision: 1.13 $\n+--                                                                          --\n+--              Copyright (C) 1998-1999 Free Software Fundation             --\n+--                                                                          --\n+-- GNARL is free software; you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion. GNARL is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNARL; see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNARL was developed by the GNARL team at Florida State University. It is --\n+-- now maintained by Ada Core Technologies Inc. in cooperation with Florida --\n+-- State University (http://www.gnat.com).                                  --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is the IRIX & NT version of this package.\n+\n+with Ada.Task_Identification;\n+--  used for Task_Id\n+\n+with Ada.Exceptions;\n+--  used for Raise_Exception\n+\n+with System.OS_Interface;\n+--  used for intr_attach\n+\n+with System.Storage_Elements;\n+--  used for To_Address\n+--           To_Integer\n+\n+with System.Task_Primitives.Operations;\n+--  used for Self\n+--           Sleep\n+--           Wakeup\n+--           Write_Lock\n+--           Unlock\n+\n+with System.Tasking.Utilities;\n+--  used for Make_Independent\n+\n+with System.Tasking.Rendezvous;\n+--  used for Call_Simple\n+\n+with System.Tasking.Initialization;\n+--  used for Defer_Abort\n+--           Undefer_Abort\n+\n+with System.Interrupt_Management;\n+\n+with Interfaces.C;\n+--  used for int\n+\n+with Unchecked_Conversion;\n+\n+package body System.Interrupts is\n+\n+   use Tasking;\n+   use Ada.Exceptions;\n+   use System.OS_Interface;\n+   use Interfaces.C;\n+\n+   package STPO renames System.Task_Primitives.Operations;\n+   package IMNG renames System.Interrupt_Management;\n+\n+   subtype int is Interfaces.C.int;\n+\n+   function To_System is new Unchecked_Conversion\n+     (Ada.Task_Identification.Task_Id, Task_ID);\n+\n+   type Handler_Kind is (Unknown, Task_Entry, Protected_Procedure);\n+\n+   type Handler_Desc is record\n+      Kind   : Handler_Kind := Unknown;\n+      T      : Task_ID;\n+      E      : Task_Entry_Index;\n+      H      : Parameterless_Handler;\n+      Static : Boolean := False;\n+   end record;\n+\n+   task type Server_Task (Interrupt : Interrupt_ID) is\n+      pragma Interrupt_Priority (System.Interrupt_Priority'Last);\n+   end Server_Task;\n+\n+   type Server_Task_Access is access Server_Task;\n+\n+   Attached_Interrupts : array (Interrupt_ID) of Boolean;\n+   Handlers            : array (Interrupt_ID) of Task_ID;\n+   Descriptors         : array (Interrupt_ID) of Handler_Desc;\n+   Interrupt_Count     : array (Interrupt_ID) of Integer := (others => 0);\n+\n+   pragma Volatile_Components (Interrupt_Count);\n+\n+   procedure Attach_Handler\n+     (New_Handler : Parameterless_Handler;\n+      Interrupt   : Interrupt_ID;\n+      Static      : Boolean;\n+      Restoration : Boolean);\n+   --  This internal procedure is needed to finalize protected objects\n+   --  that contain interrupt handlers.\n+\n+   procedure Signal_Handler (Sig : Interrupt_ID);\n+   --  This procedure is used to handle all the signals.\n+\n+   --  Type and Head, Tail of the list containing Registered Interrupt\n+   --  Handlers. These definitions are used to register the handlers\n+   --  specified by the pragma Interrupt_Handler.\n+\n+   --\n+   --  Handler Registration:\n+   --\n+\n+   type Registered_Handler;\n+   type R_Link is access all Registered_Handler;\n+\n+   type Registered_Handler is record\n+      H    : System.Address := System.Null_Address;\n+      Next : R_Link := null;\n+   end record;\n+\n+   Registered_Handlers : R_Link := null;\n+\n+   function Is_Registered (Handler : Parameterless_Handler) return Boolean;\n+   --  See if the Handler has been \"pragma\"ed using Interrupt_Handler.\n+   --  Always consider a null handler as registered.\n+\n+   type Handler_Ptr is access procedure (Sig : Interrupt_ID);\n+\n+   function TISR is new Unchecked_Conversion (Handler_Ptr, isr_address);\n+\n+   procedure Signal_Handler (Sig : Interrupt_ID) is\n+      Handler : Task_ID renames Handlers (Sig);\n+   begin\n+      if Intr_Attach_Reset and then\n+        intr_attach (int (Sig), TISR (Signal_Handler'Access)) = FUNC_ERR\n+      then\n+         raise Program_Error;\n+      end if;\n+\n+      if Handler /= null then\n+         Interrupt_Count (Sig) := Interrupt_Count (Sig) + 1;\n+         STPO.Wakeup (Handler, Interrupt_Server_Idle_Sleep);\n+      end if;\n+   end Signal_Handler;\n+\n+   -----------------\n+   -- Is_Reserved --\n+   -----------------\n+\n+   function Is_Reserved (Interrupt : Interrupt_ID) return Boolean is\n+   begin\n+      return IMNG.Reserve (IMNG.Interrupt_ID (Interrupt));\n+   end Is_Reserved;\n+\n+   -----------------------\n+   -- Is_Entry_Attached --\n+   -----------------------\n+\n+   function Is_Entry_Attached (Interrupt : Interrupt_ID) return Boolean is\n+   begin\n+      if Is_Reserved (Interrupt) then\n+         Raise_Exception (Program_Error'Identity, \"Interrupt\" &\n+           Interrupt_ID'Image (Interrupt) & \" is reserved\");\n+      end if;\n+\n+      return Descriptors (Interrupt).T /= Null_Task;\n+   end Is_Entry_Attached;\n+\n+   -------------------------\n+   -- Is_Handler_Attached --\n+   -------------------------\n+\n+   function Is_Handler_Attached (Interrupt : Interrupt_ID) return Boolean is\n+   begin\n+      if Is_Reserved (Interrupt) then\n+         Raise_Exception (Program_Error'Identity, \"Interrupt\" &\n+           Interrupt_ID'Image (Interrupt) & \" is reserved\");\n+      end if;\n+\n+      return Descriptors (Interrupt).Kind /= Unknown;\n+   end Is_Handler_Attached;\n+\n+   ----------------\n+   -- Is_Ignored --\n+   ----------------\n+\n+   function Is_Ignored (Interrupt : Interrupt_ID) return Boolean is\n+   begin\n+      raise Program_Error;\n+      return False;\n+   end Is_Ignored;\n+\n+   ------------------\n+   -- Unblocked_By --\n+   ------------------\n+\n+   function Unblocked_By (Interrupt : Interrupt_ID) return Task_ID is\n+   begin\n+      raise Program_Error;\n+      return Null_Task;\n+   end Unblocked_By;\n+\n+   ----------------------\n+   -- Ignore_Interrupt --\n+   ----------------------\n+\n+   procedure Ignore_Interrupt (Interrupt : Interrupt_ID) is\n+   begin\n+      raise Program_Error;\n+   end Ignore_Interrupt;\n+\n+   ------------------------\n+   -- Unignore_Interrupt --\n+   ------------------------\n+\n+   procedure Unignore_Interrupt (Interrupt : Interrupt_ID) is\n+   begin\n+      raise Program_Error;\n+   end Unignore_Interrupt;\n+\n+   -------------------------------------\n+   -- Has_Interrupt_Or_Attach_Handler --\n+   -------------------------------------\n+\n+   function Has_Interrupt_Or_Attach_Handler\n+     (Object : access Dynamic_Interrupt_Protection) return Boolean is\n+   begin\n+      return True;\n+   end Has_Interrupt_Or_Attach_Handler;\n+\n+   ----------------\n+   --  Finalize  --\n+   ----------------\n+\n+   procedure Finalize (Object : in out Static_Interrupt_Protection) is\n+   begin\n+      --  ??? loop to be executed only when we're not doing library level\n+      --  finalization, since in this case all interrupt tasks are gone.\n+\n+      for N in reverse Object.Previous_Handlers'Range loop\n+         Attach_Handler\n+           (New_Handler => Object.Previous_Handlers (N).Handler,\n+            Interrupt   => Object.Previous_Handlers (N).Interrupt,\n+            Static      => Object.Previous_Handlers (N).Static,\n+            Restoration => True);\n+      end loop;\n+\n+      Tasking.Protected_Objects.Entries.Finalize\n+        (Tasking.Protected_Objects.Entries.Protection_Entries (Object));\n+   end Finalize;\n+\n+   -------------------------------------\n+   -- Has_Interrupt_Or_Attach_Handler --\n+   -------------------------------------\n+\n+   function Has_Interrupt_Or_Attach_Handler\n+     (Object : access Static_Interrupt_Protection)\n+      return   Boolean\n+   is\n+   begin\n+      return True;\n+   end Has_Interrupt_Or_Attach_Handler;\n+\n+   ----------------------\n+   -- Install_Handlers --\n+   ----------------------\n+\n+   procedure Install_Handlers\n+     (Object       : access Static_Interrupt_Protection;\n+      New_Handlers : in New_Handler_Array)\n+   is\n+   begin\n+      for N in New_Handlers'Range loop\n+\n+         --  We need a lock around this ???\n+\n+         Object.Previous_Handlers (N).Interrupt := New_Handlers (N).Interrupt;\n+         Object.Previous_Handlers (N).Static    := Descriptors\n+           (New_Handlers (N).Interrupt).Static;\n+\n+         --  We call Exchange_Handler and not directly Interrupt_Manager.\n+         --  Exchange_Handler so we get the Is_Reserved check.\n+\n+         Exchange_Handler\n+           (Old_Handler => Object.Previous_Handlers (N).Handler,\n+            New_Handler => New_Handlers (N).Handler,\n+            Interrupt   => New_Handlers (N).Interrupt,\n+            Static      => True);\n+      end loop;\n+   end Install_Handlers;\n+\n+   ---------------------\n+   -- Current_Handler --\n+   ---------------------\n+\n+   function Current_Handler (Interrupt : Interrupt_ID)\n+     return Parameterless_Handler is\n+   begin\n+      if Is_Reserved (Interrupt) then\n+         raise Program_Error;\n+      end if;\n+\n+      if Descriptors (Interrupt).Kind = Protected_Procedure then\n+         return Descriptors (Interrupt).H;\n+      else\n+         return null;\n+      end if;\n+   end Current_Handler;\n+\n+   --------------------\n+   -- Attach_Handler --\n+   --------------------\n+\n+   procedure Attach_Handler\n+     (New_Handler : Parameterless_Handler;\n+      Interrupt   : Interrupt_ID;\n+      Static      : Boolean := False) is\n+   begin\n+      Attach_Handler (New_Handler, Interrupt, Static, False);\n+   end Attach_Handler;\n+\n+   procedure Attach_Handler\n+     (New_Handler : Parameterless_Handler;\n+      Interrupt   : Interrupt_ID;\n+      Static      : Boolean;\n+      Restoration : Boolean)\n+   is\n+      New_Task : Server_Task_Access;\n+\n+   begin\n+      if Is_Reserved (Interrupt) then\n+         raise Program_Error;\n+      end if;\n+\n+      if not Restoration and then not Static\n+\n+         --  Tries to overwrite a static Interrupt Handler with a\n+         --  dynamic Handler\n+\n+        and then (Descriptors (Interrupt).Static\n+\n+                     --  The new handler is not specified as an\n+                     --  Interrupt Handler by a pragma.\n+\n+                     or else not Is_Registered (New_Handler))\n+      then\n+         Raise_Exception (Program_Error'Identity,\n+           \"Trying to overwrite a static Interrupt Handler with a \" &\n+           \"dynamic Handler\");\n+      end if;\n+\n+      if Handlers (Interrupt) = null then\n+         New_Task := new Server_Task (Interrupt);\n+         Handlers (Interrupt) := To_System (New_Task.all'Identity);\n+      end if;\n+\n+      if intr_attach (int (Interrupt),\n+        TISR (Signal_Handler'Access)) = FUNC_ERR\n+      then\n+         raise Program_Error;\n+      end if;\n+\n+      if New_Handler = null then\n+\n+         --  The null handler means we are detaching the handler.\n+\n+         Attached_Interrupts (Interrupt) := False;\n+         Descriptors (Interrupt) :=\n+           (Kind => Unknown, T => null, E => 0, H => null, Static => False);\n+\n+      else\n+         Descriptors (Interrupt).Kind := Protected_Procedure;\n+         Descriptors (Interrupt).H := New_Handler;\n+         Descriptors (Interrupt).Static := Static;\n+         Attached_Interrupts (Interrupt) := True;\n+      end if;\n+   end Attach_Handler;\n+\n+   ----------------------\n+   -- Exchange_Handler --\n+   ----------------------\n+\n+   procedure Exchange_Handler\n+     (Old_Handler : out Parameterless_Handler;\n+      New_Handler : Parameterless_Handler;\n+      Interrupt   : Interrupt_ID;\n+      Static      : Boolean := False) is\n+   begin\n+      if Is_Reserved (Interrupt) then\n+         raise Program_Error;\n+      end if;\n+\n+      if Descriptors (Interrupt).Kind = Task_Entry then\n+\n+         --  In case we have an Interrupt Entry already installed.\n+         --  raise a program error. (propagate it to the caller).\n+\n+         Raise_Exception (Program_Error'Identity,\n+           \"An interrupt is already installed\");\n+      end if;\n+\n+      Old_Handler := Current_Handler (Interrupt);\n+      Attach_Handler (New_Handler, Interrupt, Static);\n+   end Exchange_Handler;\n+\n+   --------------------\n+   -- Detach_Handler --\n+   --------------------\n+\n+   procedure Detach_Handler\n+     (Interrupt : Interrupt_ID;\n+      Static    : Boolean := False) is\n+   begin\n+      if Is_Reserved (Interrupt) then\n+         raise Program_Error;\n+      end if;\n+\n+      if Descriptors (Interrupt).Kind = Task_Entry then\n+         Raise_Exception (Program_Error'Identity,\n+           \"Trying to detach an Interrupt Entry\");\n+      end if;\n+\n+      if not Static and then Descriptors (Interrupt).Static then\n+         Raise_Exception (Program_Error'Identity,\n+           \"Trying to detach a static Interrupt Handler\");\n+      end if;\n+\n+      Attached_Interrupts (Interrupt) := False;\n+      Descriptors (Interrupt) :=\n+        (Kind => Unknown, T => null, E => 0, H => null, Static => False);\n+\n+      if intr_attach (int (Interrupt), null) = FUNC_ERR then\n+         raise Program_Error;\n+      end if;\n+   end Detach_Handler;\n+\n+   ---------------\n+   -- Reference --\n+   ---------------\n+\n+   function Reference (Interrupt : Interrupt_ID) return System.Address is\n+      Signal : System.Address :=\n+        System.Storage_Elements.To_Address\n+          (System.Storage_Elements.Integer_Address (Interrupt));\n+\n+   begin\n+      if Is_Reserved (Interrupt) then\n+      --  Only usable Interrupts can be used for binding it to an Entry.\n+         raise Program_Error;\n+      end if;\n+\n+      return Signal;\n+   end Reference;\n+\n+   --------------------------------\n+   -- Register_Interrupt_Handler --\n+   --------------------------------\n+\n+   procedure Register_Interrupt_Handler (Handler_Addr : System.Address) is\n+   begin\n+      Registered_Handlers :=\n+       new Registered_Handler'(H => Handler_Addr, Next => Registered_Handlers);\n+   end Register_Interrupt_Handler;\n+\n+   -------------------\n+   -- Is_Registered --\n+   -------------------\n+\n+   --  See if the Handler has been \"pragma\"ed using Interrupt_Handler.\n+   --  Always consider a null handler as registered.\n+\n+   function Is_Registered (Handler : Parameterless_Handler) return Boolean is\n+      Ptr : R_Link := Registered_Handlers;\n+\n+      type Fat_Ptr is record\n+         Object_Addr  : System.Address;\n+         Handler_Addr : System.Address;\n+      end record;\n+\n+      function To_Fat_Ptr is new Unchecked_Conversion\n+        (Parameterless_Handler, Fat_Ptr);\n+\n+      Fat : Fat_Ptr;\n+\n+   begin\n+      if Handler = null then\n+         return True;\n+      end if;\n+\n+      Fat := To_Fat_Ptr (Handler);\n+\n+      while Ptr /= null loop\n+\n+         if Ptr.H = Fat.Handler_Addr then\n+            return True;\n+         end if;\n+\n+         Ptr := Ptr.Next;\n+      end loop;\n+\n+      return False;\n+   end Is_Registered;\n+\n+   -----------------------------\n+   -- Bind_Interrupt_To_Entry --\n+   -----------------------------\n+\n+   procedure Bind_Interrupt_To_Entry\n+     (T       : Task_ID;\n+      E       : Task_Entry_Index;\n+      Int_Ref : System.Address)\n+   is\n+      Interrupt   : constant Interrupt_ID :=\n+        Interrupt_ID (Storage_Elements.To_Integer (Int_Ref));\n+\n+      New_Task : Server_Task_Access;\n+\n+   begin\n+      if Is_Reserved (Interrupt) then\n+         raise Program_Error;\n+      end if;\n+\n+      if Descriptors (Interrupt).Kind /= Unknown then\n+         Raise_Exception (Program_Error'Identity,\n+           \"A binding for this interrupt is already present\");\n+      end if;\n+\n+      if Handlers (Interrupt) = null then\n+         New_Task := new Server_Task (Interrupt);\n+         Handlers (Interrupt) := To_System (New_Task.all'Identity);\n+      end if;\n+\n+      if intr_attach (int (Interrupt),\n+        TISR (Signal_Handler'Access)) = FUNC_ERR\n+      then\n+         raise Program_Error;\n+      end if;\n+\n+      Descriptors (Interrupt).Kind := Task_Entry;\n+      Descriptors (Interrupt).T := T;\n+      Descriptors (Interrupt).E := E;\n+\n+      --  Indicate the attachment of Interrupt Entry in ATCB.\n+      --  This is need so that when an Interrupt Entry task terminates\n+      --  the binding can be cleaned. The call to unbinding must be\n+      --  make by the task before it terminates.\n+\n+      T.Interrupt_Entry := True;\n+\n+      Attached_Interrupts (Interrupt) := True;\n+   end Bind_Interrupt_To_Entry;\n+\n+   ------------------------------\n+   -- Detach_Interrupt_Entries --\n+   ------------------------------\n+\n+   procedure Detach_Interrupt_Entries (T : Task_ID) is\n+   begin\n+      for I in Interrupt_ID loop\n+         if not Is_Reserved (I) then\n+            if Descriptors (I).Kind = Task_Entry and then\n+              Descriptors (I).T = T then\n+               Attached_Interrupts (I) := False;\n+               Descriptors (I).Kind := Unknown;\n+\n+               if intr_attach (int (I), null) = FUNC_ERR then\n+                  raise Program_Error;\n+               end if;\n+            end if;\n+         end if;\n+      end loop;\n+\n+      --  Indicate in ATCB that no Interrupt Entries are attached.\n+\n+      T.Interrupt_Entry := True;\n+   end Detach_Interrupt_Entries;\n+\n+   ---------------------\n+   -- Block_Interrupt --\n+   ---------------------\n+\n+   procedure Block_Interrupt (Interrupt : Interrupt_ID) is\n+   begin\n+      raise Program_Error;\n+   end Block_Interrupt;\n+\n+   -----------------------\n+   -- Unblock_Interrupt --\n+   -----------------------\n+\n+   procedure Unblock_Interrupt (Interrupt : Interrupt_ID) is\n+   begin\n+      raise Program_Error;\n+   end Unblock_Interrupt;\n+\n+   ----------------\n+   -- Is_Blocked --\n+   ----------------\n+\n+   function Is_Blocked (Interrupt : Interrupt_ID) return Boolean is\n+   begin\n+      raise Program_Error;\n+      return False;\n+   end Is_Blocked;\n+\n+   task body Server_Task is\n+      Desc    : Handler_Desc renames Descriptors (Interrupt);\n+      Self_Id : Task_ID := STPO.Self;\n+      Temp    : Parameterless_Handler;\n+\n+   begin\n+      Utilities.Make_Independent;\n+\n+      loop\n+         while Interrupt_Count (Interrupt) > 0 loop\n+            Interrupt_Count (Interrupt) := Interrupt_Count (Interrupt) - 1;\n+            begin\n+               case Desc.Kind is\n+                  when Unknown =>\n+                     null;\n+                  when Task_Entry =>\n+                     Rendezvous.Call_Simple (Desc.T, Desc.E, Null_Address);\n+                  when Protected_Procedure =>\n+                     Temp := Desc.H;\n+                     Temp.all;\n+               end case;\n+            exception\n+               when others => null;\n+            end;\n+         end loop;\n+\n+         Initialization.Defer_Abort (Self_Id);\n+         STPO.Write_Lock (Self_Id);\n+         Self_Id.Common.State := Interrupt_Server_Idle_Sleep;\n+         STPO.Sleep (Self_Id, Interrupt_Server_Idle_Sleep);\n+         Self_Id.Common.State := Runnable;\n+         STPO.Unlock (Self_Id);\n+         Initialization.Undefer_Abort (Self_Id);\n+\n+         --  Undefer abort here to allow a window for this task\n+         --  to be aborted  at the time of system shutdown.\n+\n+      end loop;\n+   end Server_Task;\n+\n+end System.Interrupts;"}, {"sha": "ad3ef44169f30b4050e450958a05160040c34cee", "filename": "gcc/ada/5gintman.adb", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5gintman.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5gintman.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5gintman.adb?ref=84481f762f0682e5f45b2f360446e1c7e333c880", "patch": "@@ -0,0 +1,115 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                 GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS              --\n+--                                                                          --\n+--           S Y S T E M . I N T E R R U P T _ M A N A G E M E N T          --\n+--                                                                          --\n+--                                  B o d y                                 --\n+--                                                                          --\n+--                             $Revision: 1.6 $                             --\n+--                                                                          --\n+--            Copyright (C) 1997-1998, Florida State University             --\n+--                                                                          --\n+-- GNARL is free software; you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion. GNARL is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNARL; see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNARL was developed by the GNARL team at Florida State University. It is --\n+-- now maintained by Ada Core Technologies Inc. in cooperation with Florida --\n+-- State University (http://www.gnat.com).                                  --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is an Irix (old pthread library) version of this package.\n+\n+--  PLEASE DO NOT add any dependences on other packages.\n+--  This package is designed to work with or without tasking support.\n+\n+--  Make a careful study of all signals available under the OS,\n+--  to see which need to be reserved, kept always unmasked,\n+--  or kept always unmasked.\n+--  Be on the lookout for special signals that\n+--  may be used by the thread library.\n+\n+with System.OS_Interface;\n+--  used for various Constants, Signal and types\n+\n+package body System.Interrupt_Management is\n+\n+   use System.OS_Interface;\n+\n+   type Interrupt_List is array (Interrupt_ID range <>) of Interrupt_ID;\n+\n+   Exception_Interrupts : constant Interrupt_List :=\n+     (SIGILL,\n+      SIGABRT,\n+      SIGFPE,\n+      SIGSEGV,\n+      SIGBUS);\n+\n+   Reserved_Interrupts : constant Interrupt_List :=\n+     (0,\n+      SIGTRAP,\n+      SIGKILL,\n+      SIGSYS,\n+      SIGALRM,\n+      SIGSTOP,\n+      SIGPTINTR,\n+      SIGPTRESCHED);\n+\n+   Abort_Signal : constant := 48;\n+   --\n+   --  Serious MOJO:  The SGI pthreads library only supports the\n+   --                 unnamed signal number 48 for pthread_kill!\n+   --\n+\n+   ----------------------\n+   -- Notify_Exception --\n+   ----------------------\n+\n+   --  This function identifies the Ada exception to be raised using the\n+   --  information when the system received a synchronous signal.\n+   --  Since this function is machine and OS dependent, different code has to\n+   --  be provided for different target.\n+   --  On SGI, the signal handling is done is a-init.c, even when tasking is\n+   --  involved.\n+\n+   ---------------------------\n+   -- Initialize_Interrupts --\n+   ---------------------------\n+\n+   --  Nothing needs to be done on this platform.\n+\n+   procedure Initialize_Interrupts is\n+   begin\n+      null;\n+   end Initialize_Interrupts;\n+\n+begin\n+   Abort_Task_Interrupt := Abort_Signal;\n+\n+   for I in Reserved_Interrupts'Range loop\n+      Keep_Unmasked (Reserved_Interrupts (I)) := True;\n+      Reserve (Reserved_Interrupts (I)) := True;\n+   end loop;\n+\n+   for I in Exception_Interrupts'Range loop\n+      Keep_Unmasked (Exception_Interrupts (I)) := True;\n+      Reserve (Reserved_Interrupts (I)) := True;\n+   end loop;\n+\n+end System.Interrupt_Management;"}, {"sha": "9dd0bad83b446e2686e1adcff70869a952ddc3b9", "filename": "gcc/ada/5gmastop.adb", "status": "added", "additions": 420, "deletions": 0, "changes": 420, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5gmastop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5gmastop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5gmastop.adb?ref=84481f762f0682e5f45b2f360446e1c7e333c880", "patch": "@@ -0,0 +1,420 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                     SYSTEM.MACHINE_STATE_OPERATIONS                      --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                         (Version for IRIX/MIPS)                          --\n+--                                                                          --\n+--                            $Revision: 1.7 $\n+--                                                                          --\n+--          Copyright (C) 1999-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This version of Ada.Exceptions.Machine_State_Operations is for use on\n+--  SGI Irix systems. By means of compile time conditional calculations, it\n+--  can handle both n32/n64 and o32 modes.\n+\n+with System.Machine_Code; use System.Machine_Code;\n+with System.Memory;\n+with System.Soft_Links; use System.Soft_Links;\n+with Unchecked_Conversion;\n+\n+package body System.Machine_State_Operations is\n+\n+   use System.Storage_Elements;\n+   use System.Exceptions;\n+\n+   --  The exc_unwind function in libexc operats on a Sigcontext\n+\n+   --  Type sigcontext_t is defined in /usr/include/sys/signal.h.\n+   --  We define an equivalent Ada type here. From the comments in\n+   --  signal.h:\n+\n+   --    sigcontext is not part of the ABI - so this version is used to\n+   --    handle 32 and 64 bit applications - it is a constant size regardless\n+   --    of compilation mode, and always returns 64 bit register values\n+\n+   type Uns32 is mod 2 ** 32;\n+   type Uns64 is mod 2 ** 64;\n+\n+   type Uns32_Ptr is access all Uns32;\n+   type Uns64_Array is array (Integer range <>) of Uns64;\n+\n+   type Reg_Array is array (0 .. 31) of Uns64;\n+\n+   type Sigcontext is\n+      record\n+         SC_Regmask           : Uns32;          --  0\n+         SC_Status            : Uns32;          --  4\n+         SC_PC                : Uns64;          --  8\n+         SC_Regs              : Reg_Array;      --  16\n+         SC_Fpregs            : Reg_Array;      --  272\n+         SC_Ownedfp           : Uns32;          --  528\n+         SC_Fpc_Csr           : Uns32;          --  532\n+         SC_Fpc_Eir           : Uns32;          --  536\n+         SC_Ssflags           : Uns32;          --  540\n+         SC_Mdhi              : Uns64;          --  544\n+         SC_Mdlo              : Uns64;          --  552\n+         SC_Cause             : Uns64;          --  560\n+         SC_Badvaddr          : Uns64;          --  568\n+         SC_Triggersave       : Uns64;          --  576\n+         SC_Sigset            : Uns64;          --  584\n+         SC_Fp_Rounded_Result : Uns64;          --  592\n+         SC_Pancake           : Uns64_Array (0 .. 5);\n+         SC_Pad               : Uns64_Array (0 .. 26);\n+      end record;\n+\n+   type Sigcontext_Ptr is access all Sigcontext;\n+\n+   SC_Regs_Pos   : constant String := \"16\";\n+   SC_Fpregs_Pos : constant String := \"272\";\n+   --  Byte offset of the Integer and Floating Point register save areas\n+   --  within the Sigcontext.\n+\n+   function To_Sigcontext_Ptr is\n+     new Unchecked_Conversion (Machine_State, Sigcontext_Ptr);\n+\n+   type Addr_Int is mod 2 ** Long_Integer'Size;\n+   --  An unsigned integer type whose size is the same as System.Address.\n+   --  We rely on the fact that Long_Integer'Size = System.Address'Size in\n+   --  all ABIs.  Type Addr_Int can be converted to Uns64.\n+\n+   function To_Code_Loc is new Unchecked_Conversion (Addr_Int, Code_Loc);\n+   function To_Addr_Int is new Unchecked_Conversion (System.Address, Addr_Int);\n+   function To_Uns32_Ptr is new Unchecked_Conversion (Addr_Int, Uns32_Ptr);\n+\n+   --------------------------------\n+   -- ABI-Dependant Declarations --\n+   --------------------------------\n+\n+   o32 : constant Natural := Boolean'Pos (System.Word_Size = 32);\n+   n32 : constant Natural := Boolean'Pos (System.Word_Size = 64);\n+   --  Flags to indicate which ABI is in effect for this compilation. For the\n+   --  purposes of this unit, the n32 and n64 ABI's are identical.\n+\n+   LSC : constant Character := Character'Val (o32 * Character'Pos ('w') +\n+                                              n32 * Character'Pos ('d'));\n+   --  This is 'w' for o32, and 'd' for n32/n64, used for constructing the\n+   --  load/store instructions used to save/restore machine instructions.\n+\n+   Roff : constant Character := Character'Val (o32 * Character'Pos ('4') +\n+                                               n32 * Character'Pos (' '));\n+   --  Offset from first byte of a __uint64 register save location where\n+   --  the register value is stored.  For n32/64 we store the entire 64\n+   --  bit register into the uint64.  For o32, only 32 bits are stored\n+   --  at an offset of 4 bytes.\n+\n+   procedure Update_GP (Scp : Sigcontext_Ptr);\n+\n+   ---------------\n+   -- Update_GP --\n+   ---------------\n+\n+   procedure Update_GP (Scp : Sigcontext_Ptr) is\n+\n+      type F_op  is mod 2 ** 6;\n+      type F_reg is mod 2 ** 5;\n+      type F_imm is new Short_Integer;\n+\n+      type I_Type is record\n+         op    : F_op;\n+         rs    : F_reg;\n+         rt    : F_reg;\n+         imm   : F_imm;\n+      end record;\n+\n+      pragma Pack (I_Type);\n+      for I_Type'Size use 32;\n+\n+      type I_Type_Ptr is access all I_Type;\n+\n+      LW : constant F_op := 2#100011#;\n+      Reg_GP : constant := 28;\n+\n+      type Address_Int is mod 2 ** Standard'Address_Size;\n+      function To_I_Type_Ptr is new\n+        Unchecked_Conversion (Address_Int, I_Type_Ptr);\n+\n+      Ret_Ins : I_Type_Ptr := To_I_Type_Ptr (Address_Int (Scp.SC_PC));\n+      GP_Ptr  : Uns32_Ptr;\n+\n+   begin\n+      if Ret_Ins.op = LW and then Ret_Ins.rt = Reg_GP then\n+         GP_Ptr := To_Uns32_Ptr\n+           (Addr_Int (Scp.SC_Regs (Integer (Ret_Ins.rs)))\n+            + Addr_Int (Ret_Ins.imm));\n+         Scp.SC_Regs (Reg_GP) := Uns64 (GP_Ptr.all);\n+      end if;\n+   end Update_GP;\n+\n+   ----------------------------\n+   -- Allocate_Machine_State --\n+   ----------------------------\n+\n+   function Allocate_Machine_State return Machine_State is\n+   begin\n+      return Machine_State\n+        (Memory.Alloc (Sigcontext'Max_Size_In_Storage_Elements));\n+   end Allocate_Machine_State;\n+\n+   -------------------\n+   -- Enter_Handler --\n+   -------------------\n+\n+   procedure Enter_Handler (M : Machine_State; Handler : Handler_Loc) is\n+\n+      LOADI : constant String (1 .. 2) := 'l' & LSC;\n+      --  This is \"lw\" in o32 mode, and \"ld\" in n32/n64 mode\n+\n+      LOADF : constant String (1 .. 4) := 'l' & LSC & \"c1\";\n+      --  This is \"lwc1\" in o32 mode and \"ldc1\" in n32/n64 mode\n+\n+   begin\n+      --  Restore integer registers from machine state. Note that we know\n+      --  that $4 points to M, and $5 points to Handler, since this is\n+      --  the standard calling sequence\n+\n+      Asm (LOADI & \" $16,  16*8+\" & Roff & \"+\" & SC_Regs_Pos & \"($4)\");\n+      Asm (LOADI & \" $17,  17*8+\" & Roff & \"+\" & SC_Regs_Pos & \"($4)\");\n+      Asm (LOADI & \" $18,  18*8+\" & Roff & \"+\" & SC_Regs_Pos & \"($4)\");\n+      Asm (LOADI & \" $19,  19*8+\" & Roff & \"+\" & SC_Regs_Pos & \"($4)\");\n+      Asm (LOADI & \" $20,  20*8+\" & Roff & \"+\" & SC_Regs_Pos & \"($4)\");\n+      Asm (LOADI & \" $21,  21*8+\" & Roff & \"+\" & SC_Regs_Pos & \"($4)\");\n+      Asm (LOADI & \" $22,  22*8+\" & Roff & \"+\" & SC_Regs_Pos & \"($4)\");\n+      Asm (LOADI & \" $23,  23*8+\" & Roff & \"+\" & SC_Regs_Pos & \"($4)\");\n+      Asm (LOADI & \" $24,  24*8+\" & Roff & \"+\" & SC_Regs_Pos & \"($4)\");\n+      Asm (LOADI & \" $25,  25*8+\" & Roff & \"+\" & SC_Regs_Pos & \"($4)\");\n+      Asm (LOADI & \" $26,  26*8+\" & Roff & \"+\" & SC_Regs_Pos & \"($4)\");\n+      Asm (LOADI & \" $27,  27*8+\" & Roff & \"+\" & SC_Regs_Pos & \"($4)\");\n+      Asm (LOADI & \" $28,  28*8+\" & Roff & \"+\" & SC_Regs_Pos & \"($4)\");\n+      Asm (LOADI & \" $29,  29*8+\" & Roff & \"+\" & SC_Regs_Pos & \"($4)\");\n+      Asm (LOADI & \" $30,  30*8+\" & Roff & \"+\" & SC_Regs_Pos & \"($4)\");\n+      Asm (LOADI & \" $31,  31*8+\" & Roff & \"+\" & SC_Regs_Pos & \"($4)\");\n+\n+      --  Restore floating-point registers from machine state\n+\n+      Asm (LOADF & \" $f16, 16*8+\" & Roff & \"+\" & SC_Fpregs_Pos & \"($4)\");\n+      Asm (LOADF & \" $f17, 17*8+\" & Roff & \"+\" & SC_Fpregs_Pos & \"($4)\");\n+      Asm (LOADF & \" $f18, 18*8+\" & Roff & \"+\" & SC_Fpregs_Pos & \"($4)\");\n+      Asm (LOADF & \" $f19, 19*8+\" & Roff & \"+\" & SC_Fpregs_Pos & \"($4)\");\n+      Asm (LOADF & \" $f20, 20*8+\" & Roff & \"+\" & SC_Fpregs_Pos & \"($4)\");\n+      Asm (LOADF & \" $f21, 21*8+\" & Roff & \"+\" & SC_Fpregs_Pos & \"($4)\");\n+      Asm (LOADF & \" $f22, 22*8+\" & Roff & \"+\" & SC_Fpregs_Pos & \"($4)\");\n+      Asm (LOADF & \" $f23, 23*8+\" & Roff & \"+\" & SC_Fpregs_Pos & \"($4)\");\n+      Asm (LOADF & \" $f24, 24*8+\" & Roff & \"+\" & SC_Fpregs_Pos & \"($4)\");\n+      Asm (LOADF & \" $f25, 25*8+\" & Roff & \"+\" & SC_Fpregs_Pos & \"($4)\");\n+      Asm (LOADF & \" $f26, 26*8+\" & Roff & \"+\" & SC_Fpregs_Pos & \"($4)\");\n+      Asm (LOADF & \" $f27, 27*8+\" & Roff & \"+\" & SC_Fpregs_Pos & \"($4)\");\n+      Asm (LOADF & \" $f28, 28*8+\" & Roff & \"+\" & SC_Fpregs_Pos & \"($4)\");\n+      Asm (LOADF & \" $f29, 29*8+\" & Roff & \"+\" & SC_Fpregs_Pos & \"($4)\");\n+      Asm (LOADF & \" $f30, 30*8+\" & Roff & \"+\" & SC_Fpregs_Pos & \"($4)\");\n+      Asm (LOADF & \" $f31, 31*8+\" & Roff & \"+\" & SC_Fpregs_Pos & \"($4)\");\n+\n+      --  Jump directly to the handler\n+\n+      Asm (\"jr  $5\");\n+   end Enter_Handler;\n+\n+   ----------------\n+   -- Fetch_Code --\n+   ----------------\n+\n+   function Fetch_Code (Loc : Code_Loc) return Code_Loc is\n+   begin\n+      return Loc;\n+   end Fetch_Code;\n+\n+   ------------------------\n+   -- Free_Machine_State --\n+   ------------------------\n+\n+   procedure Free_Machine_State (M : in out Machine_State) is\n+      procedure Gnat_Free (M : in Machine_State);\n+      pragma Import (C, Gnat_Free, \"__gnat_free\");\n+\n+   begin\n+      Gnat_Free (M);\n+      M := Machine_State (Null_Address);\n+   end Free_Machine_State;\n+\n+   ------------------\n+   -- Get_Code_Loc --\n+   ------------------\n+\n+   function Get_Code_Loc (M : Machine_State) return Code_Loc is\n+      SC : constant Sigcontext_Ptr := To_Sigcontext_Ptr (M);\n+   begin\n+      return To_Code_Loc (Addr_Int (SC.SC_PC));\n+   end Get_Code_Loc;\n+\n+   --------------------------\n+   -- Machine_State_Length --\n+   --------------------------\n+\n+   function Machine_State_Length return Storage_Offset is\n+   begin\n+      return Sigcontext'Max_Size_In_Storage_Elements;\n+   end Machine_State_Length;\n+\n+   ---------------\n+   -- Pop_Frame --\n+   ---------------\n+\n+   procedure Pop_Frame\n+     (M    : Machine_State;\n+      Info : Subprogram_Info_Type)\n+   is\n+      Scp : Sigcontext_Ptr := To_Sigcontext_Ptr (M);\n+\n+      procedure Exc_Unwind (Scp : Sigcontext_Ptr; Fde : Long_Integer := 0);\n+      pragma Import (C, Exc_Unwind, \"exc_unwind\");\n+      pragma Linker_Options (\"-lexc\");\n+\n+   begin\n+      --  exc_unwind is apparently not thread-safe under IRIX, so protect it\n+      --  against race conditions within the GNAT run time.\n+      --  ??? Note that we might want to use a fine grained lock here since\n+      --  Lock_Task is used in many other places.\n+\n+      Lock_Task.all;\n+      Exc_Unwind (Scp);\n+      Unlock_Task.all;\n+\n+      if Scp.SC_PC = 0 or else Scp.SC_PC = 1 then\n+\n+         --  A return value of 0 or 1 means exc_unwind couldn't find a parent\n+         --  frame. Propagate_Exception expects a zero return address to\n+         --  indicate TOS.\n+\n+         Scp.SC_PC := 0;\n+\n+      else\n+\n+         --  Set the GP to restore to the caller value (not callee value)\n+         --  This is done only in o32 mode. In n32/n64 mode, GP is a normal\n+         --  callee save register\n+\n+         if o32 = 1 then\n+            Update_GP (Scp);\n+         end if;\n+\n+         --  Adjust the return address to the call site, not the\n+         --  instruction following the branch delay slot.  This may\n+         --  be necessary if the last instruction of a pragma No_Return\n+         --  subprogram is a call. The first instruction following the\n+         --  delay slot may be the start of another subprogram. We back\n+         --  off the address by 8, which points safely into the middle\n+         --  of the generated subprogram code, avoiding end effects.\n+\n+         Scp.SC_PC := Scp.SC_PC - 8;\n+      end if;\n+   end Pop_Frame;\n+\n+   -----------------------\n+   -- Set_Machine_State --\n+   -----------------------\n+\n+   procedure Set_Machine_State (M : Machine_State) is\n+\n+      STOREI : constant String (1 .. 2) := 's' & LSC;\n+      --  This is \"sw\" in o32 mode, and \"sd\" in n32 mode\n+\n+      STOREF : constant String (1 .. 4) := 's' & LSC & \"c1\";\n+      --  This is \"swc1\" in o32 mode and \"sdc1\" in n32 mode\n+\n+      Scp : Sigcontext_Ptr;\n+\n+   begin\n+      --  Save the integer registers. Note that we know that $4 points\n+      --  to M, since that is where the first parameter is passed.\n+      --  Restore integer registers from machine state. Note that we know\n+      --  that $4 points to M since this is the standard calling sequence\n+\n+      <<Past_Prolog>>\n+\n+      Asm (STOREI & \" $16,  16*8+\" & Roff & \"+\" & SC_Regs_Pos & \"($4)\");\n+      Asm (STOREI & \" $17,  17*8+\" & Roff & \"+\" & SC_Regs_Pos & \"($4)\");\n+      Asm (STOREI & \" $18,  18*8+\" & Roff & \"+\" & SC_Regs_Pos & \"($4)\");\n+      Asm (STOREI & \" $19,  19*8+\" & Roff & \"+\" & SC_Regs_Pos & \"($4)\");\n+      Asm (STOREI & \" $20,  20*8+\" & Roff & \"+\" & SC_Regs_Pos & \"($4)\");\n+      Asm (STOREI & \" $21,  21*8+\" & Roff & \"+\" & SC_Regs_Pos & \"($4)\");\n+      Asm (STOREI & \" $22,  22*8+\" & Roff & \"+\" & SC_Regs_Pos & \"($4)\");\n+      Asm (STOREI & \" $23,  23*8+\" & Roff & \"+\" & SC_Regs_Pos & \"($4)\");\n+      Asm (STOREI & \" $24,  24*8+\" & Roff & \"+\" & SC_Regs_Pos & \"($4)\");\n+      Asm (STOREI & \" $25,  25*8+\" & Roff & \"+\" & SC_Regs_Pos & \"($4)\");\n+      Asm (STOREI & \" $26,  26*8+\" & Roff & \"+\" & SC_Regs_Pos & \"($4)\");\n+      Asm (STOREI & \" $27,  27*8+\" & Roff & \"+\" & SC_Regs_Pos & \"($4)\");\n+      Asm (STOREI & \" $28,  28*8+\" & Roff & \"+\" & SC_Regs_Pos & \"($4)\");\n+      Asm (STOREI & \" $29,  29*8+\" & Roff & \"+\" & SC_Regs_Pos & \"($4)\");\n+      Asm (STOREI & \" $30,  30*8+\" & Roff & \"+\" & SC_Regs_Pos & \"($4)\");\n+      Asm (STOREI & \" $31,  31*8+\" & Roff & \"+\" & SC_Regs_Pos & \"($4)\");\n+\n+      --  Restore floating-point registers from machine state\n+\n+      Asm (STOREF & \" $f16, 16*8+\" & Roff & \"+\" & SC_Fpregs_Pos & \"($4)\");\n+      Asm (STOREF & \" $f17, 17*8+\" & Roff & \"+\" & SC_Fpregs_Pos & \"($4)\");\n+      Asm (STOREF & \" $f18, 18*8+\" & Roff & \"+\" & SC_Fpregs_Pos & \"($4)\");\n+      Asm (STOREF & \" $f19, 19*8+\" & Roff & \"+\" & SC_Fpregs_Pos & \"($4)\");\n+      Asm (STOREF & \" $f20, 20*8+\" & Roff & \"+\" & SC_Fpregs_Pos & \"($4)\");\n+      Asm (STOREF & \" $f21, 21*8+\" & Roff & \"+\" & SC_Fpregs_Pos & \"($4)\");\n+      Asm (STOREF & \" $f22, 22*8+\" & Roff & \"+\" & SC_Fpregs_Pos & \"($4)\");\n+      Asm (STOREF & \" $f23, 23*8+\" & Roff & \"+\" & SC_Fpregs_Pos & \"($4)\");\n+      Asm (STOREF & \" $f24, 24*8+\" & Roff & \"+\" & SC_Fpregs_Pos & \"($4)\");\n+      Asm (STOREF & \" $f25, 25*8+\" & Roff & \"+\" & SC_Fpregs_Pos & \"($4)\");\n+      Asm (STOREF & \" $f26, 26*8+\" & Roff & \"+\" & SC_Fpregs_Pos & \"($4)\");\n+      Asm (STOREF & \" $f27, 27*8+\" & Roff & \"+\" & SC_Fpregs_Pos & \"($4)\");\n+      Asm (STOREF & \" $f28, 28*8+\" & Roff & \"+\" & SC_Fpregs_Pos & \"($4)\");\n+      Asm (STOREF & \" $f29, 29*8+\" & Roff & \"+\" & SC_Fpregs_Pos & \"($4)\");\n+      Asm (STOREF & \" $f30, 30*8+\" & Roff & \"+\" & SC_Fpregs_Pos & \"($4)\");\n+      Asm (STOREF & \" $f31, 31*8+\" & Roff & \"+\" & SC_Fpregs_Pos & \"($4)\");\n+\n+      --  Set the PC value for the context to a location after the\n+      --  prolog has been executed.\n+\n+      Scp := To_Sigcontext_Ptr (M);\n+      Scp.SC_PC := Uns64 (To_Addr_Int (Past_Prolog'Address));\n+\n+      --  We saved the state *inside* this routine, but what we want is\n+      --  the state at the call site. So we need to do one pop operation.\n+      --  This pop operation will properly set the PC value in the machine\n+      --  state, so there is no need to save PC in the above code.\n+\n+      Pop_Frame (M, Set_Machine_State'Address);\n+   end Set_Machine_State;\n+\n+   ------------------------------\n+   -- Set_Signal_Machine_State --\n+   ------------------------------\n+\n+   procedure Set_Signal_Machine_State\n+     (M       : Machine_State;\n+      Context : System.Address) is\n+   begin\n+      null;\n+   end Set_Signal_Machine_State;\n+\n+end System.Machine_State_Operations;"}, {"sha": "7b9c0cc04eabed0265676d6aef2d667fa69dcdd1", "filename": "gcc/ada/5gosinte.ads", "status": "added", "additions": 698, "deletions": 0, "changes": 698, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5gosinte.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5gosinte.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5gosinte.ads?ref=84481f762f0682e5f45b2f360446e1c7e333c880", "patch": "@@ -0,0 +1,698 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                 GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS              --\n+--                                                                          --\n+--                   S Y S T E M . O S _ I N T E R F A C E                  --\n+--                                                                          --\n+--                                  S p e c                                 --\n+--                                                                          --\n+--                             $Revision: 1.20 $\n+--                                                                          --\n+--          Copyright (C) 1997-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNARL is free software; you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion. GNARL is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNARL; see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNARL was developed by the GNARL team at Florida State University. It is --\n+-- now maintained by Ada Core Technologies Inc. in cooperation with Florida --\n+-- State University (http://www.gnat.com).                                  --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is an Irix (old pthread library) version of this package.\n+\n+--  This package encapsulates all direct interfaces to OS services\n+--  that are needed by children of System.\n+\n+--  PLEASE DO NOT add any with-clauses to this package\n+--  or remove the pragma Elaborate_Body.\n+--  It is designed to be a bottom-level (leaf) package.\n+\n+with Interfaces;\n+with Interfaces.C;\n+with Interfaces.C.Strings;\n+\n+package System.OS_Interface is\n+\n+   pragma Preelaborate;\n+\n+   pragma Linker_Options (\"-lathread\");\n+\n+   subtype int            is Interfaces.C.int;\n+   subtype short          is Interfaces.C.short;\n+   subtype long           is Interfaces.C.long;\n+   subtype unsigned       is Interfaces.C.unsigned;\n+   subtype unsigned_short is Interfaces.C.unsigned_short;\n+   subtype unsigned_long  is Interfaces.C.unsigned_long;\n+   subtype unsigned_char  is Interfaces.C.unsigned_char;\n+   subtype plain_char     is Interfaces.C.plain_char;\n+   subtype size_t         is Interfaces.C.size_t;\n+   subtype chars_ptr      is Interfaces.C.Strings.chars_ptr;\n+\n+   -----------\n+   -- Errno --\n+   -----------\n+\n+   function errno return int;\n+   pragma Import (C, errno, \"__get_errno\");\n+\n+   EINTR     : constant := 4;   --  interrupted system call\n+   EAGAIN    : constant := 11;  --  No more processes\n+   ENOMEM    : constant := 12;  --  Not enough core\n+   EINVAL    : constant := 22;  --  Invalid argument\n+   ETIMEDOUT : constant := 145; --  Connection timed out\n+\n+   -------------\n+   -- Signals --\n+   -------------\n+\n+   Max_Interrupt : constant := 64;\n+   type Signal is new int range 0 .. Max_Interrupt;\n+   for Signal'Size use int'Size;\n+\n+   SIGHUP     : constant := 1; --  hangup\n+   SIGINT     : constant := 2; --  interrupt (rubout)\n+   SIGQUIT    : constant := 3; --  quit (ASCD FS)\n+   SIGILL     : constant := 4; --  illegal instruction (not reset)\n+   SIGTRAP    : constant := 5; --  trace trap (not reset)\n+   SIGIOT     : constant := 6; --  IOT instruction\n+   SIGABRT    : constant := 6; --  used by abort, replace SIGIOT in the\n+   --                              future\n+   SIGEMT     : constant := 7; --  EMT instruction\n+   SIGFPE     : constant := 8; --  floating point exception\n+   SIGKILL    : constant := 9; --  kill (cannot be caught or ignored)\n+   SIGBUS     : constant := 10; --  bus error\n+   SIGSEGV    : constant := 11; --  segmentation violation\n+   SIGSYS     : constant := 12; --  bad argument to system call\n+   SIGPIPE    : constant := 13; --  write on a pipe with no one to read it\n+   SIGALRM    : constant := 14; --  alarm clock\n+   SIGTERM    : constant := 15; --  software termination signal from kill\n+   SIGUSR1    : constant := 16; --  user defined signal 1\n+   SIGUSR2    : constant := 17; --  user defined signal 2\n+   SIGCLD     : constant := 18; --  alias for SIGCHLD\n+   SIGCHLD    : constant := 18; --  child status change\n+   SIGPWR     : constant := 19; --  power-fail restart\n+   SIGWINCH   : constant := 20; --  window size change\n+   SIGURG     : constant := 21; --  urgent condition on IO channel\n+   SIGPOLL    : constant := 22; --  pollable event occurred\n+   SIGIO      : constant := 22; --  I/O possible (Solaris SIGPOLL alias)\n+   SIGSTOP    : constant := 23; --  stop (cannot be caught or ignored)\n+   SIGTSTP    : constant := 24; --  user stop requested from tty\n+   SIGCONT    : constant := 25; --  stopped process has been continued\n+   SIGTTIN    : constant := 26; --  background tty read attempted\n+   SIGTTOU    : constant := 27; --  background tty write attempted\n+   SIGVTALRM  : constant := 28; --  virtual timer expired\n+   SIGPROF    : constant := 29; --  profiling timer expired\n+   SIGXCPU    : constant := 30; --  CPU time limit exceeded\n+   SIGXFSZ    : constant := 31; --  filesize limit exceeded\n+   SIGK32     : constant := 32; --  reserved for kernel (IRIX)\n+   SIGCKPT    : constant := 33; --  Checkpoint warning\n+   SIGRESTART : constant := 34; --  Restart warning\n+   SIGUME     : constant := 35; --  Uncorrectable memory error\n+   --  Signals defined for Posix 1003.1c.\n+   SIGPTINTR    : constant := 47;\n+   SIGPTRESCHED : constant := 48;\n+   --  Posix 1003.1b signals\n+   SIGRTMIN   : constant := 49; --  Posix 1003.1b signals\n+   SIGRTMAX   : constant := 64; --  Posix 1003.1b signals\n+\n+   type sigset_t is private;\n+   type sigset_t_ptr is access all sigset_t;\n+\n+   function sigaddset (set : access sigset_t; sig : Signal) return int;\n+   pragma Import (C, sigaddset, \"sigaddset\");\n+\n+   function sigdelset (set : access sigset_t; sig : Signal) return int;\n+   pragma Import (C, sigdelset, \"sigdelset\");\n+\n+   function sigfillset (set : access sigset_t) return int;\n+   pragma Import (C, sigfillset, \"sigfillset\");\n+\n+   function sigismember (set : access sigset_t; sig : Signal) return int;\n+   pragma Import (C, sigismember, \"sigismember\");\n+\n+   function sigemptyset (set : access sigset_t) return int;\n+   pragma Import (C, sigemptyset, \"sigemptyset\");\n+\n+   type siginfo_t is record\n+      si_signo     : int;\n+      si_code      : int;\n+      si_errno     : int;\n+      bit_field_substitute_1 : String (1 .. 116);\n+   end record;\n+   pragma Convention (C, siginfo_t);\n+\n+   type array_type_2 is array (Integer range 0 .. 1) of int;\n+   type struct_sigaction is record\n+      sa_flags     : int;\n+      sa_handler   : System.Address;\n+      sa_mask      : sigset_t;\n+      sa_resv      : array_type_2;\n+   end record;\n+   pragma Convention (C, struct_sigaction);\n+   type struct_sigaction_ptr is access all struct_sigaction;\n+\n+   SIG_BLOCK   : constant := 1;\n+   SIG_UNBLOCK : constant := 2;\n+   SIG_SETMASK : constant := 3;\n+\n+   SIG_DFL : constant := 0;\n+   SIG_IGN : constant := 1;\n+\n+   function sigaction\n+     (sig  : Signal;\n+      act  : struct_sigaction_ptr;\n+      oact : struct_sigaction_ptr := null) return int;\n+   pragma Import (C, sigaction, \"sigaction\");\n+\n+   ----------\n+   -- Time --\n+   ----------\n+\n+   type time_t is new int;\n+\n+   type timespec is record\n+      tv_sec  : time_t;\n+      tv_nsec : long;\n+   end record;\n+   pragma Convention (C, timespec);\n+   type timespec_ptr is access all timespec;\n+\n+   function To_Duration (TS : timespec) return Duration;\n+   pragma Inline (To_Duration);\n+\n+   function To_Timespec (D : Duration) return timespec;\n+   pragma Inline (To_Timespec);\n+\n+   type timer_t is new Integer;\n+   type clockid_t is private;\n+\n+   CLOCK_REALTIME  : constant clockid_t;\n+   CLOCK_SGI_FAST  : constant clockid_t;\n+   CLOCK_SGI_CYCLE : constant clockid_t;\n+\n+   SGI_CYCLECNTR_SIZE : constant := 165;\n+   function syssgi (request : Interfaces.C.int) return Interfaces.C.ptrdiff_t;\n+\n+   pragma Import (C, syssgi, \"syssgi\");\n+\n+   function clock_gettime\n+     (clock_id : clockid_t;\n+      tp       : access timespec) return int;\n+   pragma Import (C, clock_gettime, \"clock_gettime\");\n+\n+   function clock_getres\n+     (clock_id : clockid_t; tp : access timespec) return int;\n+   pragma Import (C, clock_getres, \"clock_getres\");\n+\n+   type struct_timeval is record\n+      tv_sec  : time_t;\n+      tv_usec : time_t;\n+   end record;\n+   pragma Convention (C, struct_timeval);\n+\n+   function To_Duration (TV : struct_timeval) return Duration;\n+   pragma Inline (To_Duration);\n+\n+   function To_Timeval (D : Duration) return struct_timeval;\n+   pragma Inline (To_Timeval);\n+\n+   function gettimeofday\n+     (tv : access struct_timeval;\n+      tz : System.Address := System.Null_Address) return int;\n+   pragma Import (C, gettimeofday, \"gettimeofday\");\n+\n+   -------------------------\n+   -- Priority Scheduling --\n+   -------------------------\n+\n+   SCHED_FIFO  : constant := 0;\n+   SCHED_RR    : constant := 0;\n+   SCHED_OTHER : constant := 0;\n+\n+   -------------\n+   -- Process --\n+   -------------\n+\n+   type pid_t is private;\n+\n+   function kill (pid : pid_t; sig : Signal) return int;\n+   pragma Import (C, kill, \"kill\");\n+\n+   function getpid return pid_t;\n+   pragma Import (C, getpid, \"getpid\");\n+\n+   ---------------------------------------\n+   -- Nonstandard Thread Initialization --\n+   ---------------------------------------\n+\n+   procedure pthread_init;\n+   pragma Inline (pthread_init);\n+   --  This is a dummy procedure to share some GNULLI files\n+\n+   -------------\n+   -- Threads --\n+   -------------\n+\n+   type Thread_Body is access\n+     function (arg : System.Address) return System.Address;\n+\n+   type pthread_t           is private; --   thread identifier\n+   subtype Thread_Id        is pthread_t;\n+\n+   type pthread_mutex_t     is private; --   mutex identifier\n+   type pthread_cond_t      is private; --   cond identifier\n+   type pthread_attr_t      is private; --   pthread attributes\n+   type pthread_mutexattr_t is private; --   mutex attributes\n+   type pthread_condattr_t  is private; --   mutex attributes\n+   type sem_t               is private; --   semaphore identifier\n+   type pthread_key_t       is private; --   per thread key\n+\n+   subtype pthread_once_t   is int;     --   dynamic package initialization\n+   subtype resource_t       is long;    --   sproc. resource info.\n+   type start_addr is access function (arg : Address) return Address;\n+   type sproc_start_addr is access function (arg : Address) return int;\n+   type callout_addr is\n+     access function (arg : Address; arg1 : Address) return Address;\n+\n+   --  SGI specific types\n+\n+   subtype sproc_t      is Address; --   sproc identifier\n+   subtype sproc_attr_t is Address; --   sproc attributes\n+\n+   subtype spcb_p is Address;\n+   subtype ptcb_p is Address;\n+\n+   --  Pthread Error Types\n+\n+   FUNC_OK  : constant := 0;\n+   FUNC_ERR : constant := -1;\n+\n+   --  pthread run-time initialization data structure\n+\n+   type pthread_init_struct is record\n+      conf_initsize       : int; --  shared area size\n+      max_sproc_count     : int; --  maximum number of sprocs\n+      sproc_stack_size    : size_t;  --  sproc stack size\n+      os_default_priority : int; --  default IRIX pri for main process\n+      os_sched_signal     : int; --  default OS scheduling signal\n+      guard_pages         : int; --  number of guard pages per stack\n+      init_sproc_count    : int; --  initial number of sprocs\n+   end record;\n+\n+   --\n+   --  Pthread Attribute Initialize / Destroy\n+   --\n+\n+   function pthread_attr_init (attr : access pthread_attr_t) return int;\n+   pragma Import (C, pthread_attr_init, \"pthread_attr_init\");\n+\n+   function pthread_attr_destroy (attr : access pthread_attr_t) return int;\n+   pragma Import (C, pthread_attr_destroy, \"pthread_attr_destroy\");\n+\n+   --\n+   --  Thread Attributes\n+   --\n+\n+   function pthread_attr_setstacksize\n+     (attr : access pthread_attr_t; stacksize : size_t) return int;\n+   pragma Import (C, pthread_attr_setstacksize, \"pthread_attr_setstacksize\");\n+\n+   function pthread_attr_setdetachstate\n+     (attr : access pthread_attr_t; detachstate : int) return int;\n+   pragma Import (C, pthread_attr_setdetachstate);\n+\n+   function pthread_attr_setname\n+     (attr : access pthread_attr_t; name : chars_ptr) return int;\n+   pragma Import (C, pthread_attr_setname, \"pthread_attr_setname\");\n+\n+   --\n+   --  Thread Scheduling Attributes\n+   --\n+\n+   function pthread_attr_setscope\n+     (attr : access pthread_attr_t; contentionscope : int) return int;\n+   pragma Import (C, pthread_attr_setscope, \"pthread_attr_setscope\");\n+\n+   function pthread_attr_setinheritsched\n+     (attr : access pthread_attr_t; inherit : int) return int;\n+   pragma Import\n+     (C, pthread_attr_setinheritsched, \"pthread_attr_setinheritsched\");\n+\n+   function pthread_attr_setsched\n+     (attr : access pthread_attr_t; scheduler : int) return int;\n+   pragma Import (C, pthread_attr_setsched, \"pthread_attr_setsched\");\n+\n+   function  pthread_attr_setprio\n+     (attr : access pthread_attr_t; priority : int) return int;\n+   pragma Import (C, pthread_attr_setprio, \"pthread_attr_setprio\");\n+\n+   --\n+   --  SGI Extensions to Thread Attributes\n+   --\n+\n+   --  Bound to sproc attribute values\n+\n+   PTHREAD_BOUND     : constant := 1;\n+   PTHREAD_NOT_BOUND : constant := 0;\n+\n+   function pthread_attr_setresources\n+     (attr : access pthread_attr_t; resources : resource_t) return int;\n+   pragma Import (C, pthread_attr_setresources, \"pthread_attr_setresources\");\n+\n+   function pthread_attr_set_boundtosproc\n+     (attr : access pthread_attr_t; bound_to_sproc : int) return int;\n+   pragma Import\n+     (C, pthread_attr_set_boundtosproc, \"pthread_attr_set_boundtosproc\");\n+\n+   function pthread_attr_set_bsproc\n+     (attr : access pthread_attr_t; bsproc : spcb_p) return int;\n+   pragma Import (C, pthread_attr_set_bsproc, \"pthread_attr_set_bsproc\");\n+\n+   function pthread_attr_set_tslice\n+     (attr        : access pthread_attr_t;\n+      ts_interval : access struct_timeval) return int;\n+   pragma Import (C, pthread_attr_set_tslice, \"pthread_attr_set_tslice\");\n+\n+   --\n+   --  Thread Creation & Management\n+   --\n+\n+   function pthread_create\n+     (thread        : access pthread_t;\n+      attr          : access pthread_attr_t;\n+      start_routine : start_addr;\n+      arg           : Address) return int;\n+   pragma Import (C, pthread_create, \"pthread_create\");\n+\n+   procedure pthread_exit (status : Address);\n+   pragma Import (C, pthread_exit, \"pthread_exit\");\n+\n+   procedure pthread_yield (arg : Address := System.Null_Address);\n+   pragma Import (C, pthread_yield, \"pthread_yield\");\n+\n+   function pthread_self return pthread_t;\n+   pragma Import (C, pthread_self, \"pthread_self\");\n+\n+   function pthread_kill (thread : pthread_t; sig : int) return int;\n+   pragma Import (C, pthread_kill, \"pthread_kill\");\n+\n+   --\n+   --  SGI Extensions to POSIX thread operations\n+   --\n+\n+   function pthread_setprio (thread : pthread_t; priority : int) return int;\n+   pragma Import (C, pthread_setprio, \"pthread_setprio\");\n+\n+   function pthread_suspend (thread : pthread_t) return int;\n+   pragma Import (C, pthread_suspend, \"pthread_suspend\");\n+\n+   function pthread_resume (thread : pthread_t) return int;\n+   pragma Import (C, pthread_resume, \"pthread_resume\");\n+\n+   function pthread_get_current_ada_tcb return Address;\n+   pragma Import (C, pthread_get_current_ada_tcb);\n+\n+   function pthread_set_ada_tcb\n+     (thread : pthread_t; data : Address) return int;\n+   pragma Import (C, pthread_set_ada_tcb, \"pthread_set_ada_tcb\");\n+\n+   --  Mutex Initialization / Destruction\n+\n+   function pthread_mutexattr_init\n+     (attr : access pthread_mutexattr_t) return int;\n+   pragma Import (C, pthread_mutexattr_init, \"pthread_mutexattr_init\");\n+\n+   function pthread_mutexattr_destroy\n+     (attr : access pthread_mutexattr_t) return int;\n+   pragma Import (C, pthread_mutexattr_destroy, \"pthread_mutexattr_destroy\");\n+\n+   function pthread_mutexattr_setqueueorder\n+     (attr : access pthread_mutexattr_t; order : int) return int;\n+   pragma Import (C, pthread_mutexattr_setqueueorder);\n+\n+   function pthread_mutexattr_setceilingprio\n+     (attr : access pthread_mutexattr_t; priority : int) return int;\n+   pragma Import (C, pthread_mutexattr_setceilingprio);\n+\n+   --  Mutex Attributes\n+\n+   --  Threads queueing order\n+\n+   MUTEX_PRIORITY         : constant := 0; --   wait in priority order\n+   MUTEX_FIFO             : constant := 1; --   first-in-first-out\n+   MUTEX_PRIORITY_INHERIT : constant := 2; --   priority inhertance mutex\n+   MUTEX_PRIORITY_CEILING : constant := 3; --   priority ceiling mutex\n+\n+   --  Mutex debugging options\n+\n+   MUTEX_NO_DEBUG  : constant := 0; --   no debugging on mutex\n+   MUTEX_DEBUG     : constant := 1; --   debugging is on\n+\n+   --  Mutex spin on lock operations\n+\n+   MUTEX_NO_SPIN   : constant := 0;  --   no spin, try once only\n+   MUTEX_SPIN_ONLY : constant := -1; --   spin forever\n+   --  cnt > 0, limited spin\n+   --  Mutex sharing attributes\n+\n+   MUTEX_SHARED    : constant := 0; --   shared between processes\n+   MUTEX_NOTSHARED : constant := 1; --   not shared between processes\n+\n+   --  Mutex Operations\n+\n+   function pthread_mutex_init\n+     (mutex : access pthread_mutex_t;\n+      attr  : access pthread_mutexattr_t) return int;\n+   pragma Import (C, pthread_mutex_init, \"pthread_mutex_init\");\n+\n+   function pthread_mutex_destroy\n+     (mutex : access pthread_mutex_t) return int;\n+   pragma Import (C, pthread_mutex_destroy, \"pthread_mutex_destroy\");\n+\n+   function pthread_mutex_lock\n+     (mutex : access pthread_mutex_t) return int;\n+   pragma Import (C, pthread_mutex_lock, \"pthread_mutex_lock\");\n+\n+   function pthread_mutex_unlock\n+     (mutex : access pthread_mutex_t) return int;\n+   pragma Import (C, pthread_mutex_unlock, \"pthread_mutex_unlock\");\n+\n+   --  Condition Initialization / Destruction\n+\n+   function pthread_condattr_init\n+     (attr : access pthread_condattr_t) return int;\n+   pragma Import (C, pthread_condattr_init, \"pthread_condattr_init\");\n+\n+   function pthread_condattr_destroy\n+     (attr : access pthread_condattr_t) return int;\n+   pragma Import (C, pthread_condattr_destroy, \"pthread_condattr_destroy\");\n+\n+   --  Condition Attributes\n+\n+   COND_PRIORITY  : constant := 0; --   wait in priority order\n+   COND_FIFO      : constant := 1; --   first-in-first-out\n+\n+   --  Condition debugging options\n+\n+   COND_NO_DEBUG  : constant := 0; --   no debugging on mutex\n+   COND_DEBUG     : constant := 1; --   debugging is on\n+\n+   --  Condition sharing attributes\n+\n+   COND_SHARED    : constant := 0; --   shared between processes\n+   COND_NOTSHARED : constant := 1; --   not shared between processes\n+\n+   --  Condition Operations\n+\n+   function pthread_cond_init\n+     (cond : access pthread_cond_t;\n+      attr : access pthread_condattr_t) return int;\n+   pragma Import (C, pthread_cond_init, \"pthread_cond_init\");\n+\n+   function pthread_cond_destroy\n+     (cond : access pthread_cond_t) return int;\n+   pragma Import (C, pthread_cond_destroy, \"pthread_cond_destroy\");\n+\n+   function pthread_cond_signal (cond : access pthread_cond_t) return int;\n+   pragma Import (C, pthread_cond_signal, \"pthread_cond_signal\");\n+\n+   function pthread_cond_wait\n+     (cond  : access pthread_cond_t;\n+      mutex : access pthread_mutex_t) return int;\n+   pragma Import (C, pthread_cond_wait, \"pthread_cond_wait\");\n+\n+   function pthread_cond_timedwait\n+     (cond    : access pthread_cond_t;\n+      mutex   : access pthread_mutex_t;\n+      abstime : access struct_timeval) return int;\n+   pragma Import (C, pthread_cond_timedwait, \"pthread_cond_timedwait\");\n+\n+   --  Thread-Specific Data\n+\n+   type foo_h_proc_1 is access procedure (value : Address);\n+\n+   function pthread_key_create\n+     (key : access pthread_key_t; destructor : foo_h_proc_1) return int;\n+   pragma Import (C, pthread_key_create, \"pthread_key_create\");\n+\n+   function pthread_setspecific\n+     (key : pthread_key_t; value : Address) return int;\n+   pragma Import (C, pthread_setspecific, \"pthread_setspecific\");\n+\n+   function pthread_getspecific\n+     (key : pthread_key_t; value : access Address) return int;\n+   pragma Import (C, pthread_getspecific, \"pthread_getspecific\");\n+\n+   type foo_h_proc_2 is access procedure;\n+\n+   function pthread_exec_begin (init : access pthread_init_struct) return int;\n+   pragma Import (C, pthread_exec_begin, \"pthread_exec_begin\");\n+\n+   function sproc_create\n+     (sproc_id      : access sproc_t;\n+      attr          : access sproc_attr_t;\n+      start_routine : sproc_start_addr;\n+      arg           : Address) return int;\n+   pragma Import (C, sproc_create, \"sproc_create\");\n+\n+   function sproc_self return sproc_t;\n+   pragma Import (C, sproc_self, \"sproc_self\");\n+\n+   --  if equal fast TRUE is returned - common case\n+   --  if not equal thread resource must NOT be null in order to compare bits\n+\n+   --\n+   --  Sproc attribute initialize / destroy\n+   --\n+\n+   function sproc_attr_init (attr : access sproc_attr_t) return int;\n+   pragma Import (C, sproc_attr_init, \"sproc_attr_init\");\n+\n+   function sproc_attr_destroy (attr : access sproc_attr_t) return int;\n+   pragma Import (C, sproc_attr_destroy, \"sproc_attr_destroy\");\n+\n+   function sproc_attr_setresources\n+     (attr : access sproc_attr_t; resources : resource_t) return int;\n+   pragma Import (C, sproc_attr_setresources, \"sproc_attr_setresources\");\n+\n+   function sproc_attr_getresources\n+     (attr      : access sproc_attr_t;\n+      resources : access resource_t) return int;\n+   pragma Import (C, sproc_attr_getresources, \"sproc_attr_getresources\");\n+\n+   function sproc_attr_setcpu\n+     (attr : access sproc_attr_t; cpu_num : int) return int;\n+   pragma Import (C, sproc_attr_setcpu, \"sproc_attr_setcpu\");\n+\n+   function sproc_attr_getcpu\n+     (attr : access sproc_attr_t; cpu_num : access int) return int;\n+   pragma Import (C, sproc_attr_getcpu, \"sproc_attr_getcpu\");\n+\n+   function sproc_attr_setresident\n+     (attr : access sproc_attr_t; resident : int) return int;\n+   pragma Import (C, sproc_attr_setresident, \"sproc_attr_setresident\");\n+\n+   function sproc_attr_getresident\n+     (attr : access sproc_attr_t; resident : access int) return int;\n+   pragma Import (C, sproc_attr_getresident, \"sproc_attr_getresident\");\n+\n+   function sproc_attr_setname\n+     (attr : access sproc_attr_t; name : chars_ptr) return int;\n+   pragma Import (C, sproc_attr_setname, \"sproc_attr_setname\");\n+\n+   function sproc_attr_getname\n+     (attr : access sproc_attr_t; name : chars_ptr) return int;\n+   pragma Import (C, sproc_attr_getname, \"sproc_attr_getname\");\n+\n+   function sproc_attr_setstacksize\n+     (attr : access sproc_attr_t; stacksize : size_t) return int;\n+   pragma Import (C, sproc_attr_setstacksize, \"sproc_attr_setstacksize\");\n+\n+   function sproc_attr_getstacksize\n+     (attr : access sproc_attr_t; stacksize : access size_t) return int;\n+   pragma Import (C, sproc_attr_getstacksize, \"sproc_attr_getstacksize\");\n+\n+   function sproc_attr_setprio\n+     (attr : access sproc_attr_t; priority : int) return int;\n+   pragma Import (C, sproc_attr_setprio, \"sproc_attr_setprio\");\n+\n+   function sproc_attr_getprio\n+     (attr : access sproc_attr_t; priority : access int) return int;\n+   pragma Import (C, sproc_attr_getprio, \"sproc_attr_getprio\");\n+\n+   function sproc_attr_setbthread\n+     (attr : access sproc_attr_t; bthread : ptcb_p) return int;\n+   pragma Import (C, sproc_attr_setbthread, \"sproc_attr_setbthread\");\n+\n+   function sproc_attr_getbthread\n+     (attr : access sproc_attr_t; bthread : access ptcb_p) return int;\n+   pragma Import (C, sproc_attr_getbthread, \"sproc_attr_getbthread\");\n+\n+   SPROC_NO_RESOURCES : constant := 0;\n+   SPROC_ANY_CPU      : constant := -1;\n+   SPROC_MY_PRIORITY  : constant := -1;\n+   SPROC_SWAPPED      : constant := 0;\n+   SPROC_RESIDENT     : constant := 1;\n+\n+   type isr_address is access procedure;\n+\n+   function intr_attach (sig : int; isr : isr_address) return int;\n+   pragma Import (C, intr_attach, \"intr_attach\");\n+\n+   Intr_Attach_Reset : constant Boolean := False;\n+   --  True if intr_attach is reset after an interrupt handler is called\n+\n+   function intr_exchange\n+     (sig  : int;\n+      isr  : isr_address;\n+      oisr : access isr_address) return int;\n+   pragma Import (C, intr_exchange, \"intr_exchange\");\n+\n+   function intr_current_isr\n+     (sig  : int;\n+      oisr : access isr_address)\n+     return int;\n+   pragma Import (C, intr_current_isr, \"intr_current_isr\");\n+\n+private\n+\n+   type clockid_t is new int;\n+\n+   CLOCK_REALTIME  : constant clockid_t := 1;\n+   CLOCK_SGI_CYCLE : constant clockid_t := 2;\n+   CLOCK_SGI_FAST  : constant clockid_t := 3;\n+\n+   type pthread_t           is new Address; --   thread identifier\n+   type pthread_mutex_t     is new Address; --   mutex identifier\n+   type pthread_cond_t      is new Address; --   cond identifier\n+   type pthread_attr_t      is new Address; --   pthread attributes\n+   type pthread_mutexattr_t is new Address; --   mutex attributes\n+   type pthread_condattr_t  is new Address; --   mutex attributes\n+   type sem_t               is new Address; --   semaphore identifier\n+   type pthread_key_t       is new Address; --   per thread key\n+\n+   type sigbits_t is array (Integer range 0 .. 3) of unsigned;\n+   type sigset_t is record\n+      sigbits : sigbits_t;\n+   end record;\n+   pragma Convention (C, sigset_t);\n+\n+   type pid_t is new long;\n+\n+end System.OS_Interface;"}, {"sha": "2f821a1c67e769534e878eebb531e40bae531593", "filename": "gcc/ada/5gproinf.adb", "status": "added", "additions": 223, "deletions": 0, "changes": 223, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5gproinf.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5gproinf.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5gproinf.adb?ref=84481f762f0682e5f45b2f360446e1c7e333c880", "patch": "@@ -0,0 +1,223 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                 S Y S T E M . P R O G R A M  _  I N F O                  --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.7 $\n+--                                                                          --\n+--          Copyright (C) 1997-1999 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is an Irix (old pthread library) version of this package.\n+\n+--  This package   contains the parameters  used by   the run-time system at\n+--  program startup.  These parameters are  isolated in this package body to\n+--  facilitate replacement by the end user.\n+--\n+--  To replace the default values, copy this source file into your build\n+--  directory, edit the file to reflect your desired behavior, and recompile\n+--  with the command:\n+--\n+--     % gcc -c -O2 -gnatpg s-proinf.adb\n+--\n+--  then relink your application as usual.\n+--\n+\n+with GNAT.OS_Lib;\n+\n+package body System.Program_Info is\n+\n+   Kbytes : constant := 1024;\n+\n+   Default_Initial_Sproc_Count  : constant := 0;\n+   Default_Max_Sproc_Count      : constant := 128;\n+   Default_Sproc_Stack_Size     : constant := 16#4000#;\n+   Default_Stack_Guard_Pages    : constant := 1;\n+   Default_Default_Time_Slice   : constant := 0.0;\n+   Default_Default_Task_Stack   : constant := 12 * Kbytes;\n+   Default_Pthread_Sched_Signal : constant := 35;\n+   Default_Pthread_Arena_Size   : constant := 16#40000#;\n+   Default_Os_Default_Priority  : constant := 0;\n+\n+   -------------------------\n+   -- Initial_Sproc_Count --\n+   -------------------------\n+\n+   function Initial_Sproc_Count return Integer is\n+\n+      function sysmp (P1 : Integer) return Integer;\n+      pragma Import (C, sysmp, \"sysmp\", \"sysmp\");\n+\n+      MP_NPROCS : constant := 1; --   # processor in complex\n+\n+      Pthread_Sproc_Count : constant GNAT.OS_Lib.String_Access :=\n+        GNAT.OS_Lib.Getenv (\"PTHREAD_SPROC_COUNT\");\n+\n+   begin\n+      if Pthread_Sproc_Count.all'Length = 0 then\n+         return Default_Initial_Sproc_Count;\n+\n+      elsif Pthread_Sproc_Count.all = \"AUTO\" then\n+         return sysmp (MP_NPROCS);\n+\n+      else\n+         return Integer'Value (Pthread_Sproc_Count.all);\n+      end if;\n+   exception\n+      when others =>\n+         return Default_Initial_Sproc_Count;\n+   end Initial_Sproc_Count;\n+\n+   ---------------------\n+   -- Max_Sproc_Count --\n+   ---------------------\n+\n+   function Max_Sproc_Count return Integer is\n+      Pthread_Max_Sproc_Count : constant GNAT.OS_Lib.String_Access :=\n+        GNAT.OS_Lib.Getenv (\"PTHREAD_MAX_SPROC_COUNT\");\n+\n+   begin\n+      if Pthread_Max_Sproc_Count.all'Length = 0 then\n+         return Default_Max_Sproc_Count;\n+      else\n+         return Integer'Value (Pthread_Max_Sproc_Count.all);\n+      end if;\n+   exception\n+      when others =>\n+         return Default_Max_Sproc_Count;\n+   end Max_Sproc_Count;\n+\n+   ----------------------\n+   -- Sproc_Stack_Size --\n+   ----------------------\n+\n+   function Sproc_Stack_Size return Integer is\n+   begin\n+      return Default_Sproc_Stack_Size;\n+   end Sproc_Stack_Size;\n+\n+   ------------------------\n+   -- Default_Time_Slice --\n+   ------------------------\n+\n+   function Default_Time_Slice return Duration is\n+      Pthread_Time_Slice_Sec : constant GNAT.OS_Lib.String_Access :=\n+        GNAT.OS_Lib.Getenv (\"PTHREAD_TIME_SLICE_SEC\");\n+      Pthread_Time_Slice_Usec : constant GNAT.OS_Lib.String_Access :=\n+        GNAT.OS_Lib.Getenv (\"PTHREAD_TIME_SLICE_USEC\");\n+\n+      Val_Sec, Val_Usec : Integer := 0;\n+\n+   begin\n+      if Pthread_Time_Slice_Sec.all'Length /= 0 or\n+        Pthread_Time_Slice_Usec.all'Length /= 0\n+      then\n+         if Pthread_Time_Slice_Sec.all'Length /= 0 then\n+            Val_Sec := Integer'Value (Pthread_Time_Slice_Sec.all);\n+         end if;\n+\n+         if Pthread_Time_Slice_Usec.all'Length /= 0 then\n+            Val_Usec := Integer'Value (Pthread_Time_Slice_Usec.all);\n+         end if;\n+\n+         return Duration (Val_Sec) + Duration (Val_Usec) / 1000.0;\n+      else\n+         return Default_Default_Time_Slice;\n+      end if;\n+\n+   exception\n+      when others =>\n+         return Default_Default_Time_Slice;\n+   end Default_Time_Slice;\n+\n+   ------------------------\n+   -- Default_Task_Stack --\n+   ------------------------\n+\n+   function Default_Task_Stack return Integer is\n+   begin\n+      return Default_Default_Task_Stack;\n+   end Default_Task_Stack;\n+\n+   -----------------------\n+   -- Stack_Guard_Pages --\n+   -----------------------\n+\n+   function Stack_Guard_Pages return Integer is\n+      Pthread_Stack_Guard_Pages : constant GNAT.OS_Lib.String_Access :=\n+        GNAT.OS_Lib.Getenv (\"PTHREAD_STACK_GUARD_PAGES\");\n+\n+   begin\n+      if Pthread_Stack_Guard_Pages.all'Length /= 0 then\n+         return Integer'Value (Pthread_Stack_Guard_Pages.all);\n+      else\n+         return Default_Stack_Guard_Pages;\n+      end if;\n+   exception\n+      when others =>\n+         return Default_Stack_Guard_Pages;\n+   end Stack_Guard_Pages;\n+\n+   --------------------------\n+   -- Pthread_Sched_Signal --\n+   --------------------------\n+\n+   function Pthread_Sched_Signal return Integer is\n+   begin\n+      return Default_Pthread_Sched_Signal;\n+   end Pthread_Sched_Signal;\n+\n+   ------------------------\n+   -- Pthread_Arena_Size --\n+   ------------------------\n+\n+   function Pthread_Arena_Size  return Integer is\n+      Pthread_Arena_Size : constant GNAT.OS_Lib.String_Access :=\n+        GNAT.OS_Lib.Getenv (\"PTHREAD_ARENA_SIZE\");\n+\n+   begin\n+      if Pthread_Arena_Size.all'Length = 0 then\n+         return Default_Pthread_Arena_Size;\n+      else\n+         return Integer'Value (Pthread_Arena_Size.all);\n+      end if;\n+   exception\n+      when others =>\n+         return Default_Pthread_Arena_Size;\n+   end Pthread_Arena_Size;\n+\n+   -------------------------\n+   -- Os_Default_Priority --\n+   -------------------------\n+\n+   function Os_Default_Priority return Integer is\n+   begin\n+      return Default_Os_Default_Priority;\n+   end Os_Default_Priority;\n+\n+end System.Program_Info;"}, {"sha": "070e0b2ad061a4efbea27921b152ae88ea4b8126", "filename": "gcc/ada/5gproinf.ads", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5gproinf.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5gproinf.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5gproinf.ads?ref=84481f762f0682e5f45b2f360446e1c7e333c880", "patch": "@@ -0,0 +1,97 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                 S Y S T E M . P R O G R A M  _  I N F O                  --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.1 $                              --\n+--                                                                          --\n+--               Copyright (C) 1997 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+--  This package contains the definitions and routines used as parameters\n+--  to the run-time system at program startup for the SGI implementation.\n+\n+package System.Program_Info is\n+\n+   function Initial_Sproc_Count return Integer;\n+   --\n+   --  The number of sproc created at program startup for scheduling\n+   --  threads.\n+   --\n+\n+   function Max_Sproc_Count     return Integer;\n+   --\n+   --  The maximum number of sprocs that can be created by the program\n+   --  for servicing threads.  This limit includes both the pre-created\n+   --  sprocs and those explicitly created under program control.\n+   --\n+\n+   function Sproc_Stack_Size    return Integer;\n+   --\n+   --  The size, in bytes, of the sproc's initial stack.\n+   --\n+\n+   function Default_Time_Slice  return Duration;\n+   --\n+   --  The default time quanta for round-robin scheduling of threads of\n+   --  equal priority.  This default value can be overridden on a per-task\n+   --  basis by specifying an alternate value via the implementation-defined\n+   --  Task_Info pragma. See s-tasinf.ads for more information.\n+   --\n+\n+   function Default_Task_Stack  return Integer;\n+   --\n+   --  The default stack size for each created thread.  This default value\n+   --  can be overriden on a per-task basis by the language-defined\n+   --  Storage_Size pragma.\n+   --\n+\n+   function Stack_Guard_Pages   return Integer;\n+   --\n+   --  The number of non-writable, guard pages to append to the bottom of\n+   --  each thread's stack.\n+   --\n+\n+   function Pthread_Sched_Signal return Integer;\n+   --\n+   --  The signal used by the Pthreads library to affect scheduling actions\n+   --  in remote sprocs.\n+   --\n+\n+   function Pthread_Arena_Size  return Integer;\n+   --\n+   --  The size of the shared arena from which pthread locks are allocated.\n+   --  See the usinit(3p) man page for more information on shared arenas.\n+   --\n+\n+   function Os_Default_Priority return Integer;\n+   --\n+   --  The default Irix Non-Degrading priority for each sproc created to\n+   --  service threads.\n+   --\n+\n+end System.Program_Info;"}, {"sha": "e97781786ae129429af43cd6322b505e2673c2d6", "filename": "gcc/ada/5gsystem.ads", "status": "added", "additions": 153, "deletions": 0, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5gsystem.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5gsystem.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5gsystem.ads?ref=84481f762f0682e5f45b2f360446e1c7e333c880", "patch": "@@ -0,0 +1,153 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                        GNAT RUN-TIME COMPONENTS                          --\n+--                                                                          --\n+--                               S Y S T E M                                --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                           (SGI Irix, n32 ABI)                            --\n+--                                                                          --\n+--                            $Revision: 1.19 $\n+--                                                                          --\n+--          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+package System is\n+pragma Pure (System);\n+--  Note that we take advantage of the implementation permission to\n+--  make this unit Pure instead of Preelaborable, see RM 13.7(36)\n+\n+   type Name is (SYSTEM_NAME_GNAT);\n+   System_Name : constant Name := SYSTEM_NAME_GNAT;\n+\n+   --  System-Dependent Named Numbers\n+\n+   Min_Int               : constant := Long_Long_Integer'First;\n+   Max_Int               : constant := Long_Long_Integer'Last;\n+\n+   Max_Binary_Modulus    : constant := 2 ** Long_Long_Integer'Size;\n+   Max_Nonbinary_Modulus : constant := Integer'Last;\n+\n+   Max_Base_Digits       : constant := Long_Long_Float'Digits;\n+   Max_Digits            : constant := Long_Long_Float'Digits;\n+\n+   Max_Mantissa          : constant := 63;\n+   Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);\n+\n+   Tick                  : constant := Standard'Tick;\n+\n+   --  Storage-related Declarations\n+\n+   type Address is private;\n+   Null_Address : constant Address;\n+\n+   Storage_Unit : constant := Standard'Storage_Unit;\n+   Word_Size    : constant := Standard'Word_Size;\n+   Memory_Size  : constant := 2 ** Standard'Address_Size;\n+\n+   --  Address comparison\n+\n+   function \"<\"  (Left, Right : Address) return Boolean;\n+   function \"<=\" (Left, Right : Address) return Boolean;\n+   function \">\"  (Left, Right : Address) return Boolean;\n+   function \">=\" (Left, Right : Address) return Boolean;\n+   function \"=\"  (Left, Right : Address) return Boolean;\n+\n+   pragma Import (Intrinsic, \"<\");\n+   pragma Import (Intrinsic, \"<=\");\n+   pragma Import (Intrinsic, \">\");\n+   pragma Import (Intrinsic, \">=\");\n+   pragma Import (Intrinsic, \"=\");\n+\n+   --  Other System-Dependent Declarations\n+\n+   type Bit_Order is (High_Order_First, Low_Order_First);\n+   Default_Bit_Order : constant Bit_Order := High_Order_First;\n+\n+   --  Priority-related Declarations (RM D.1)\n+\n+   Max_Priority : constant Positive := 30;\n+\n+   Max_Interrupt_Priority : constant Positive := 31;\n+\n+   subtype Any_Priority is Integer\n+     range 0 .. Standard'Max_Interrupt_Priority;\n+\n+   subtype Priority is Any_Priority\n+     range 0 .. Standard'Max_Priority;\n+\n+   --  Functional notation is needed in the following to avoid visibility\n+   --  problems when this package is compiled through rtsfind in the middle\n+   --  of another compilation.\n+\n+   subtype Interrupt_Priority is Any_Priority\n+     range\n+       Standard.\"+\" (Standard'Max_Priority,  1) ..\n+         Standard'Max_Interrupt_Priority;\n+\n+   Default_Priority : constant Priority :=\n+     Standard.\"/\" (Standard.\"+\" (Priority'First, Priority'Last), 2);\n+\n+private\n+\n+   type Address is mod Memory_Size;\n+   Null_Address : constant Address := 0;\n+\n+   --------------------------------------\n+   -- System Implementation Parameters --\n+   --------------------------------------\n+\n+   --  These parameters provide information about the target that is used\n+   --  by the compiler. They are in the private part of System, where they\n+   --  can be accessed using the special circuitry in the Targparm unit\n+   --  whose source should be consulted for more detailed descriptions\n+   --  of the individual switch values.\n+\n+   AAMP                      : constant Boolean := False;\n+   Command_Line_Args         : constant Boolean := True;\n+   Denorm                    : constant Boolean := False;\n+   Frontend_Layout           : constant Boolean := False;\n+   Functions_Return_By_DSP   : constant Boolean := True;\n+   Long_Shifts_Inlined       : constant Boolean := True;\n+   High_Integrity_Mode       : constant Boolean := False;\n+   Machine_Overflows         : constant Boolean := False;\n+   Machine_Rounds            : constant Boolean := True;\n+   OpenVMS                   : constant Boolean := False;\n+   Signed_Zeros              : constant Boolean := True;\n+   Stack_Check_Default       : constant Boolean := False;\n+   Stack_Check_Probes        : constant Boolean := True;\n+   Use_Ada_Main_Program_Name : constant Boolean := False;\n+   ZCX_By_Default            : constant Boolean := True;\n+   GCC_ZCX_Support           : constant Boolean := False;\n+   Front_End_ZCX_Support     : constant Boolean := True;\n+\n+   --  Note: Denorm is False because denormals are not supported on the\n+   --  R10000, and we want the code to be valid for this processor.\n+\n+end System;"}, {"sha": "0ec29dfb2c3d99e513c58610d45e5713ae1ad831", "filename": "gcc/ada/5gtaprop.adb", "status": "added", "additions": 968, "deletions": 0, "changes": 968, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5gtaprop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5gtaprop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5gtaprop.adb?ref=84481f762f0682e5f45b2f360446e1c7e333c880", "patch": "@@ -0,0 +1,968 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                 GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS              --\n+--                                                                          --\n+--     S Y S T E M . T A S K _ P R I M I T I V E S . O P E R A T I O N S    --\n+--                                                                          --\n+--                                  B o d y                                 --\n+--                                                                          --\n+--                             $Revision: 1.37 $\n+--                                                                          --\n+--              Copyright (C) 1991-2001, Florida State University           --\n+--                                                                          --\n+-- GNARL is free software; you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion. GNARL is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNARL; see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNARL was developed by the GNARL team at Florida State University. It is --\n+-- now maintained by Ada Core Technologies Inc. in cooperation with Florida --\n+-- State University (http://www.gnat.com).                                  --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is an Irix (old athread library) version of this package\n+\n+--  This package contains all the GNULL primitives that interface directly\n+--  with the underlying OS.\n+\n+pragma Polling (Off);\n+--  Turn off polling, we do not want ATC polling to take place during\n+--  tasking operations. It causes infinite loops and other problems.\n+\n+with Interfaces.C;\n+--  used for int\n+--           size_t\n+\n+with System.Tasking.Debug;\n+--  used for Known_Tasks\n+\n+with System.Task_Info;\n+\n+with System.Interrupt_Management;\n+--  used for Keep_Unmasked\n+--           Abort_Task_Interrupt\n+--           Interrupt_ID\n+\n+with System.Parameters;\n+--  used for Size_Type\n+\n+with System.Tasking;\n+--  used for Ada_Task_Control_Block\n+--           Task_ID\n+\n+with System.Program_Info;\n+--  used for Default_Task_Stack\n+--           Default_Time_Slice\n+--           Stack_Guard_Pages\n+--           Pthread_Sched_Signal\n+--           Pthread_Arena_Size\n+\n+with System.Soft_Links;\n+--  used for Defer/Undefer_Abort\n+\n+--  Note that we do not use System.Tasking.Initialization directly since\n+--  this is a higher level package that we shouldn't depend on. For example\n+--  when using the restricted run time, it is replaced by\n+--  System.Tasking.Restricted.Initialization\n+\n+with System.OS_Primitives;\n+--  used for Delay_Modes\n+\n+with System.Storage_Elements;\n+--  used for To_Address\n+\n+with Unchecked_Conversion;\n+with Unchecked_Deallocation;\n+\n+package body System.Task_Primitives.Operations is\n+\n+   use System.Tasking.Debug;\n+   use System.Tasking;\n+   use Interfaces.C;\n+   use System.OS_Interface;\n+   use System.Parameters;\n+   use System.OS_Primitives;\n+\n+   package SSL renames System.Soft_Links;\n+\n+   ------------------\n+   --  Local Data  --\n+   ------------------\n+\n+   --  The followings are logically constants, but need to be initialized\n+   --  at run time.\n+\n+   All_Tasks_L : aliased System.Task_Primitives.RTS_Lock;\n+   --  See comments on locking rules in System.Tasking (spec).\n+\n+   Environment_Task_ID : Task_ID;\n+   --  A variable to hold Task_ID for the environment task.\n+\n+   Locking_Policy : Character;\n+   pragma Import (C, Locking_Policy, \"__gl_locking_policy\",\n+                  \"__gl_locking_policy\");\n+\n+   Clock_Address : constant System.Address :=\n+     System.Storage_Elements.To_Address (16#200F90#);\n+\n+   RT_Clock_Id : clockid_t;\n+   for RT_Clock_Id'Address use Clock_Address;\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   procedure Initialize_Athread_Library;\n+\n+   function To_Task_ID is new Unchecked_Conversion (System.Address, Task_ID);\n+\n+   function To_Address is new Unchecked_Conversion (Task_ID, System.Address);\n+\n+   -------------------\n+   --  Stack_Guard  --\n+   -------------------\n+\n+   --  The underlying thread system sets a guard page at the\n+   --  bottom of a thread stack, so nothing is needed.\n+   --  ??? Check the comment above\n+\n+   procedure Stack_Guard (T : ST.Task_ID; On : Boolean) is\n+   begin\n+      null;\n+   end Stack_Guard;\n+\n+   --------------------\n+   -- Get_Thread_Id  --\n+   --------------------\n+\n+   function Get_Thread_Id (T : ST.Task_ID) return OSI.Thread_Id is\n+   begin\n+      return T.Common.LL.Thread;\n+   end Get_Thread_Id;\n+\n+   ----------\n+   -- Self --\n+   ----------\n+\n+   function Self return Task_ID is\n+   begin\n+      return To_Task_ID (pthread_get_current_ada_tcb);\n+   end Self;\n+\n+   ---------------------\n+   -- Initialize_Lock --\n+   ---------------------\n+\n+   --  Note: mutexes and cond_variables needed per-task basis are\n+   --        initialized in Intialize_TCB and the Storage_Error is\n+   --        handled. Other mutexes (such as All_Tasks_Lock, Memory_Lock...)\n+   --        used in RTS is initialized before any status change of RTS.\n+   --        Therefore rasing Storage_Error in the following routines\n+   --        should be able to be handled safely.\n+\n+   procedure Initialize_Lock\n+     (Prio : System.Any_Priority;\n+      L    : access Lock)\n+   is\n+      Attributes : aliased pthread_mutexattr_t;\n+      Result     : Interfaces.C.int;\n+\n+   begin\n+      Result := pthread_mutexattr_init (Attributes'Access);\n+\n+      if Result = FUNC_ERR then\n+         raise Storage_Error;\n+      end if;\n+\n+      if Locking_Policy = 'C' then\n+\n+         Result := pthread_mutexattr_setqueueorder\n+           (Attributes'Access, MUTEX_PRIORITY_CEILING);\n+\n+         pragma Assert (Result /= FUNC_ERR);\n+\n+         Result := pthread_mutexattr_setceilingprio\n+            (Attributes'Access, Interfaces.C.int (Prio));\n+\n+         pragma Assert (Result /= FUNC_ERR);\n+      end if;\n+\n+      Result := pthread_mutex_init (L, Attributes'Access);\n+\n+      if Result = FUNC_ERR then\n+         Result := pthread_mutexattr_destroy (Attributes'Access);\n+         raise Storage_Error;\n+      end if;\n+\n+      Result := pthread_mutexattr_destroy (Attributes'Access);\n+   end Initialize_Lock;\n+\n+   procedure Initialize_Lock (L : access RTS_Lock; Level : Lock_Level) is\n+      Attributes : aliased pthread_mutexattr_t;\n+      Result : Interfaces.C.int;\n+   begin\n+      Result := pthread_mutexattr_init (Attributes'Access);\n+\n+      if Result = FUNC_ERR then\n+         raise Storage_Error;\n+      end if;\n+\n+      if Locking_Policy = 'C' then\n+         Result := pthread_mutexattr_setqueueorder\n+           (Attributes'Access, MUTEX_PRIORITY_CEILING);\n+         pragma Assert (Result /= FUNC_ERR);\n+\n+         Result := pthread_mutexattr_setceilingprio\n+            (Attributes'Access, Interfaces.C.int (System.Any_Priority'Last));\n+         pragma Assert (Result /= FUNC_ERR);\n+      end if;\n+\n+      Result := pthread_mutex_init (L, Attributes'Access);\n+\n+      if Result = FUNC_ERR then\n+         Result := pthread_mutexattr_destroy (Attributes'Access);\n+         raise Storage_Error;\n+      end if;\n+\n+      Result := pthread_mutexattr_destroy (Attributes'Access);\n+   end Initialize_Lock;\n+\n+   -------------------\n+   -- Finalize_Lock --\n+   -------------------\n+\n+   procedure Finalize_Lock (L : access Lock) is\n+      Result : Interfaces.C.int;\n+\n+   begin\n+      Result := pthread_mutex_destroy (L);\n+      pragma Assert (Result = 0);\n+   end Finalize_Lock;\n+\n+   procedure Finalize_Lock (L : access RTS_Lock) is\n+      Result : Interfaces.C.int;\n+\n+   begin\n+      Result := pthread_mutex_destroy (L);\n+      pragma Assert (Result = 0);\n+   end Finalize_Lock;\n+\n+   ----------------\n+   -- Write_Lock --\n+   ----------------\n+\n+   procedure Write_Lock (L : access Lock; Ceiling_Violation : out Boolean) is\n+      Result : Interfaces.C.int;\n+\n+   begin\n+      Result := pthread_mutex_lock (L);\n+\n+      Ceiling_Violation := Result = FUNC_ERR and then errno = EINVAL;\n+      pragma Assert (Result /= FUNC_ERR);\n+   end Write_Lock;\n+\n+   procedure Write_Lock (L : access RTS_Lock) is\n+      Result : Interfaces.C.int;\n+\n+   begin\n+      Result := pthread_mutex_lock (L);\n+      pragma Assert (Result = 0);\n+   end Write_Lock;\n+\n+   procedure Write_Lock (T : Task_ID) is\n+      Result : Interfaces.C.int;\n+\n+   begin\n+      Result := pthread_mutex_lock (T.Common.LL.L'Access);\n+      pragma Assert (Result = 0);\n+   end Write_Lock;\n+\n+   ---------------\n+   -- Read_Lock --\n+   ---------------\n+\n+   procedure Read_Lock (L : access Lock; Ceiling_Violation : out Boolean) is\n+   begin\n+      Write_Lock (L, Ceiling_Violation);\n+   end Read_Lock;\n+\n+   ------------\n+   -- Unlock --\n+   ------------\n+\n+   procedure Unlock (L : access Lock) is\n+      Result : Interfaces.C.int;\n+\n+   begin\n+      Result := pthread_mutex_unlock (L);\n+      pragma Assert (Result = 0);\n+   end Unlock;\n+\n+   procedure Unlock (L : access RTS_Lock) is\n+      Result : Interfaces.C.int;\n+\n+   begin\n+      Result := pthread_mutex_unlock (L);\n+      pragma Assert (Result = 0);\n+   end Unlock;\n+\n+   procedure Unlock (T : Task_ID) is\n+      Result : Interfaces.C.int;\n+\n+   begin\n+      Result := pthread_mutex_unlock (T.Common.LL.L'Access);\n+      pragma Assert (Result = 0);\n+   end Unlock;\n+\n+   -------------\n+   --  Sleep  --\n+   -------------\n+\n+   procedure Sleep\n+     (Self_ID  : ST.Task_ID;\n+      Reason   : System.Tasking.Task_States) is\n+\n+      Result : Interfaces.C.int;\n+\n+   begin\n+      pragma Assert (Self_ID = Self);\n+      Result := pthread_cond_wait (Self_ID.Common.LL.CV'Access,\n+        Self_ID.Common.LL.L'Access);\n+      --  EINTR is not considered a failure.\n+      pragma Assert (Result = 0 or else Result = EINTR);\n+   end Sleep;\n+\n+   --  Note that we are relying heaviliy here on the GNAT feature\n+   --  that Calendar.Time, System.Real_Time.Time, Duration, and\n+   --  System.Real_Time.Time_Span are all represented in the same\n+   --  way, i.e., as a 64-bit count of nanoseconds.\n+   --  This allows us to always pass the timeout value as a Duration.\n+\n+   --  ?????  .........\n+   --  We are taking liberties here with the semantics of the delays.\n+   --  That is, we make no distinction between delays on the Calendar clock\n+   --  and delays on the Real_Time clock.  That is technically incorrect, if\n+   --  the Calendar clock happens to be reset or adjusted.\n+   --  To solve this defect will require modification to the compiler\n+   --  interface, so that it can pass through more information, to tell\n+   --  us here which clock to use!\n+\n+   --  cond_timedwait will return if any of the following happens:\n+   --  1) some other task did cond_signal on this condition variable\n+   --     In this case, the return value is 0\n+   --  2) the call just returned, for no good reason\n+   --     This is called a \"spurious wakeup\".\n+   --     In this case, the return value may also be 0.\n+   --  3) the time delay expires\n+   --     In this case, the return value is ETIME\n+   --  4) this task received a signal, which was handled by some\n+   --     handler procedure, and now the thread is resuming execution\n+   --     UNIX calls this an \"interrupted\" system call.\n+   --     In this case, the return value is EINTR\n+\n+   --  If the cond_timedwait returns 0 or EINTR, it is still\n+   --  possible that the time has actually expired, and by chance\n+   --  a signal or cond_signal occurred at around the same time.\n+\n+   --  We have also observed that on some OS's the value ETIME\n+   --  will be returned, but the clock will show that the full delay\n+   --  has not yet expired.\n+\n+   --  For these reasons, we need to check the clock after return\n+   --  from cond_timedwait.  If the time has expired, we will set\n+   --  Timedout = True.\n+\n+   --  This check might be omitted for systems on which the\n+   --  cond_timedwait() never returns early or wakes up spuriously.\n+\n+   --  Annex D requires that completion of a delay cause the task\n+   --  to go to the end of its priority queue, regardless of whether\n+   --  the task actually was suspended by the delay.  Since\n+   --  cond_timedwait does not do this on Solaris, we add a call\n+   --  to thr_yield at the end.  We might do this at the beginning,\n+   --  instead, but then the round-robin effect would not be the\n+   --  same; the delayed task would be ahead of other tasks of the\n+   --  same priority that awoke while it was sleeping.\n+\n+   --  For Timed_Sleep, we are expecting possible cond_signals\n+   --  to indicate other events (e.g., completion of a RV or\n+   --  completion of the abortable part of an async. select),\n+   --  we want to always return if interrupted. The caller will\n+   --  be responsible for checking the task state to see whether\n+   --  the wakeup was spurious, and to go back to sleep again\n+   --  in that case.  We don't need to check for pending abort\n+   --  or priority change on the way in our out; that is the\n+   --  caller's responsibility.\n+\n+   --  For Timed_Delay, we are not expecting any cond_signals or\n+   --  other interruptions, except for priority changes and aborts.\n+   --  Therefore, we don't want to return unless the delay has\n+   --  actually expired, or the call has been aborted.  In this\n+   --  case, since we want to implement the entire delay statement\n+   --  semantics, we do need to check for pending abort and priority\n+   --  changes.  We can quietly handle priority changes inside the\n+   --  procedure, since there is no entry-queue reordering involved.\n+\n+   -----------------\n+   -- Timed_Sleep --\n+   -----------------\n+\n+   --  This is for use within the run-time system, so abort is\n+   --  assumed to be already deferred, and the caller should be\n+   --  holding its own ATCB lock.\n+   --  Yielded should be False unles we know for certain that the\n+   --  operation resulted in the calling task going to the end of\n+   --  the dispatching queue for its priority.\n+   --  ?????\n+   --  This version presumes the worst, so Yielded is always False.\n+   --  On some targets, if cond_timedwait always yields, we could\n+   --  set Yielded to True just before the cond_timedwait call.\n+\n+   procedure Timed_Sleep\n+     (Self_ID  : Task_ID;\n+      Time     : Duration;\n+      Mode     : ST.Delay_Modes;\n+      Reason   : System.Tasking.Task_States;\n+      Timedout : out Boolean;\n+      Yielded  : out Boolean)\n+   is\n+      Check_Time : constant Duration := Monotonic_Clock;\n+      Abs_Time   : Duration;\n+      Request    : aliased struct_timeval;\n+      Result     : Interfaces.C.int;\n+   begin\n+      Timedout := True;\n+      Yielded := False;\n+\n+      if Mode = Relative then\n+         Abs_Time := Duration'Min (Time, Max_Sensible_Delay) + Check_Time;\n+      else\n+         Abs_Time := Duration'Min (Check_Time + Max_Sensible_Delay, Time);\n+      end if;\n+\n+      if Abs_Time > Check_Time then\n+         Request := To_Timeval (Abs_Time);\n+\n+         loop\n+            exit when Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level\n+              or else Self_ID.Pending_Priority_Change;\n+\n+            Result := pthread_cond_timedwait (Self_ID.Common.LL.CV'Access,\n+              Self_ID.Common.LL.L'Access, Request'Access);\n+\n+            exit when Abs_Time <= Monotonic_Clock;\n+\n+            if Result = 0 or Result = EINTR then\n+               --  somebody may have called Wakeup for us\n+               Timedout := False;\n+               exit;\n+            end if;\n+\n+            pragma Assert (Result = ETIMEDOUT\n+              or else (Result = -1 and then errno = EAGAIN));\n+         end loop;\n+      end if;\n+   end Timed_Sleep;\n+\n+   -----------------\n+   -- Timed_Delay --\n+   -----------------\n+\n+   --  This is for use in implementing delay statements, so\n+   --  we assume the caller is abort-deferred but is holding\n+   --  no locks.\n+\n+   procedure Timed_Delay\n+     (Self_ID  : Task_ID;\n+      Time     : Duration;\n+      Mode     : ST.Delay_Modes)\n+   is\n+      Check_Time : constant Duration := Monotonic_Clock;\n+      Abs_Time   : Duration;\n+      Request    : aliased struct_timeval;\n+      Result     : Interfaces.C.int;\n+   begin\n+\n+      --  Only the little window between deferring abort and\n+      --  locking Self_ID is the reason we need to\n+      --  check for pending abort and priority change below! :(\n+\n+      SSL.Abort_Defer.all;\n+      Write_Lock (Self_ID);\n+\n+      if Mode = Relative then\n+         Abs_Time := Time + Check_Time;\n+      else\n+         Abs_Time := Duration'Min (Check_Time + Max_Sensible_Delay, Time);\n+      end if;\n+\n+      if Abs_Time > Check_Time then\n+         Request := To_Timeval (Abs_Time);\n+         Self_ID.Common.State := Delay_Sleep;\n+\n+         loop\n+            if Self_ID.Pending_Priority_Change then\n+               Self_ID.Pending_Priority_Change := False;\n+               Self_ID.Common.Base_Priority := Self_ID.New_Base_Priority;\n+               Set_Priority (Self_ID, Self_ID.Common.Base_Priority);\n+            end if;\n+\n+            exit when Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level;\n+\n+            Result := pthread_cond_timedwait (Self_ID.Common.LL.CV'Access,\n+              Self_ID.Common.LL.L'Access, Request'Access);\n+\n+            exit when Abs_Time <= Monotonic_Clock;\n+\n+            pragma Assert (Result = 0 or else\n+              Result = ETIMEDOUT or else\n+              (Result = -1 and then errno = EAGAIN) or else\n+              Result = EINTR);\n+         end loop;\n+\n+         Self_ID.Common.State := Runnable;\n+      end if;\n+\n+      Unlock (Self_ID);\n+      pthread_yield;\n+      SSL.Abort_Undefer.all;\n+   end Timed_Delay;\n+\n+   ---------------------\n+   -- Monotonic_Clock --\n+   ---------------------\n+\n+   function Monotonic_Clock return Duration is\n+      type timeval is record\n+         tv_sec  : Integer;\n+         tv_usec : Integer;\n+      end record;\n+      pragma Convention (C, timeval);\n+\n+      tv : aliased timeval;\n+\n+      procedure gettimeofday (tp : access timeval);\n+      pragma Import (C, gettimeofday, \"gettimeofday\", \"gettimeofday\");\n+\n+   begin\n+      gettimeofday (tv'Access);\n+      return Duration (tv.tv_sec) + Duration (tv.tv_usec) / 1_000_000.0;\n+   end Monotonic_Clock;\n+\n+   -------------------\n+   -- RT_Resolution --\n+   -------------------\n+\n+   function RT_Resolution return Duration is\n+   begin\n+      return 10#1.0#E-6;\n+   end RT_Resolution;\n+\n+   ------------\n+   -- Wakeup --\n+   ------------\n+\n+   procedure Wakeup\n+     (T : ST.Task_ID;\n+      Reason : System.Tasking.Task_States) is\n+\n+      Result : Interfaces.C.int;\n+\n+   begin\n+      Result := pthread_cond_signal (T.Common.LL.CV'Access);\n+      pragma Assert (Result = 0);\n+   end Wakeup;\n+\n+   -----------\n+   -- Yield --\n+   -----------\n+\n+   procedure Yield (Do_Yield : Boolean := True) is\n+   begin\n+      if Do_Yield then\n+         pthread_yield;\n+      end if;\n+   end Yield;\n+\n+   ------------------\n+   -- Set_Priority --\n+   ------------------\n+\n+   procedure Set_Priority\n+     (T : Task_ID;\n+      Prio : System.Any_Priority;\n+      Loss_Of_Inheritance : Boolean := False)\n+   is\n+      Result : Interfaces.C.int;\n+\n+   begin\n+      T.Common.Current_Priority := Prio;\n+      Result := pthread_setprio (T.Common.LL.Thread, Interfaces.C.int (Prio));\n+      pragma Assert (Result /= FUNC_ERR);\n+\n+   end Set_Priority;\n+\n+   ------------------\n+   -- Get_Priority --\n+   ------------------\n+\n+   function Get_Priority (T : Task_ID) return System.Any_Priority is\n+   begin\n+      return T.Common.Current_Priority;\n+   end Get_Priority;\n+\n+   ----------------\n+   -- Enter_Task --\n+   ----------------\n+\n+   procedure Enter_Task (Self_ID : Task_ID) is\n+      Result : Interfaces.C.int;\n+\n+   begin\n+\n+      Self_ID.Common.LL.Thread := pthread_self;\n+      Self_ID.Common.LL.LWP := sproc_self;\n+\n+      Result :=\n+        pthread_set_ada_tcb (Self_ID.Common.LL.Thread, To_Address (Self_ID));\n+\n+      pragma Assert (Result = 0);\n+\n+      Lock_All_Tasks_List;\n+\n+      for I in Known_Tasks'Range loop\n+         if Known_Tasks (I) = null then\n+            Known_Tasks (I) := Self_ID;\n+            Self_ID.Known_Tasks_Index := I;\n+            exit;\n+         end if;\n+      end loop;\n+\n+      Unlock_All_Tasks_List;\n+   end Enter_Task;\n+\n+   --------------\n+   -- New_ATCB --\n+   --------------\n+\n+   function New_ATCB (Entry_Num : Task_Entry_Index) return Task_ID is\n+   begin\n+      return new Ada_Task_Control_Block (Entry_Num);\n+   end New_ATCB;\n+\n+   ----------------------\n+   --  Initialize_TCB  --\n+   ----------------------\n+\n+   procedure Initialize_TCB (Self_ID : Task_ID; Succeeded : out Boolean) is\n+      Result : Interfaces.C.int;\n+      Cond_Attr : aliased pthread_condattr_t;\n+\n+   begin\n+      Initialize_Lock (Self_ID.Common.LL.L'Access, ATCB_Level);\n+\n+      Result := pthread_condattr_init (Cond_Attr'Access);\n+      pragma Assert (Result = 0 or else Result = ENOMEM);\n+\n+      if Result /= 0 then\n+         Result := pthread_mutex_destroy (Self_ID.Common.LL.L'Access);\n+         pragma Assert (Result = 0);\n+         Succeeded := False;\n+         return;\n+      end if;\n+\n+      Result := pthread_cond_init (Self_ID.Common.LL.CV'Access,\n+        Cond_Attr'Access);\n+      pragma Assert (Result = 0 or else Result = ENOMEM);\n+\n+      if Result = 0 then\n+         Succeeded := True;\n+      else\n+         Result := pthread_mutex_destroy (Self_ID.Common.LL.L'Access);\n+         pragma Assert (Result = 0);\n+         Succeeded := False;\n+      end if;\n+\n+      Result := pthread_condattr_destroy (Cond_Attr'Access);\n+      pragma Assert (Result = 0);\n+   end Initialize_TCB;\n+\n+   -----------------\n+   -- Create_Task --\n+   -----------------\n+\n+   procedure Create_Task\n+     (T          : Task_ID;\n+      Wrapper    : System.Address;\n+      Stack_Size : System.Parameters.Size_Type;\n+      Priority   : System.Any_Priority;\n+      Succeeded  : out Boolean)\n+   is\n+      Attributes          : aliased pthread_attr_t;\n+      Adjusted_Stack_Size : Interfaces.C.size_t;\n+      Result              : Interfaces.C.int;\n+\n+      function Thread_Body_Access is new\n+        Unchecked_Conversion (System.Address, start_addr);\n+\n+      function To_Resource_T is new Unchecked_Conversion\n+        (System.Task_Info.Resource_Vector_T, System.OS_Interface.resource_t);\n+\n+      use System.Task_Info;\n+   begin\n+      if Stack_Size = Unspecified_Size then\n+         Adjusted_Stack_Size :=\n+           Interfaces.C.size_t (System.Program_Info.Default_Task_Stack);\n+\n+      elsif Stack_Size < Minimum_Stack_Size then\n+         Adjusted_Stack_Size := Interfaces.C.size_t (Minimum_Stack_Size);\n+\n+      else\n+         Adjusted_Stack_Size := Interfaces.C.size_t (Stack_Size);\n+      end if;\n+\n+      Result := pthread_attr_init (Attributes'Access);\n+      pragma Assert (Result = 0 or else Result = ENOMEM);\n+\n+      if Result /= 0 then\n+         Succeeded := False;\n+         return;\n+      end if;\n+\n+      Result := pthread_attr_setdetachstate (Attributes'Access, 1);\n+      pragma Assert (Result = 0);\n+\n+      Result := pthread_attr_setstacksize\n+        (Attributes'Access, Adjusted_Stack_Size);\n+      pragma Assert (Result = 0);\n+\n+      if T.Common.Task_Info /= null then\n+         Result := pthread_attr_setresources\n+           (Attributes'Access,\n+            To_Resource_T (T.Common.Task_Info.Thread_Resources));\n+         pragma Assert (Result /= FUNC_ERR);\n+\n+         if T.Common.Task_Info.Thread_Timeslice /= 0.0 then\n+            declare\n+               use System.OS_Interface;\n+\n+               Tv : aliased struct_timeval := To_Timeval\n+                 (T.Common.Task_Info.Thread_Timeslice);\n+            begin\n+               Result := pthread_attr_set_tslice\n+                 (Attributes'Access, Tv'Access);\n+            end;\n+         end if;\n+\n+         if T.Common.Task_Info.Bound_To_Sproc then\n+            Result := pthread_attr_set_boundtosproc\n+              (Attributes'Access, PTHREAD_BOUND);\n+            Result := pthread_attr_set_bsproc\n+              (Attributes'Access, T.Common.Task_Info.Sproc);\n+         end if;\n+\n+      end if;\n+\n+      --  Since the initial signal mask of a thread is inherited from the\n+      --  creator, and the Environment task has all its signals masked, we\n+      --  do not need to manipulate caller's signal mask at this point.\n+      --  All tasks in RTS will have All_Tasks_Mask initially.\n+\n+      Result := pthread_create\n+        (T.Common.LL.Thread'Access,\n+         Attributes'Access,\n+         Thread_Body_Access (Wrapper),\n+         To_Address (T));\n+      pragma Assert (Result = 0 or else Result = EAGAIN);\n+\n+      Succeeded := Result = 0;\n+\n+      Set_Priority (T, Priority);\n+\n+      Result := pthread_attr_destroy (Attributes'Access);\n+      pragma Assert (Result /= FUNC_ERR);\n+   end Create_Task;\n+\n+   ------------------\n+   -- Finalize_TCB --\n+   ------------------\n+\n+   procedure Finalize_TCB (T : Task_ID) is\n+      procedure Free is new\n+        Unchecked_Deallocation (Ada_Task_Control_Block, Task_ID);\n+\n+      Result : Interfaces.C.int;\n+      Tmp    : Task_ID := T;\n+\n+   begin\n+      Result := pthread_mutex_destroy (T.Common.LL.L'Access);\n+      pragma Assert (Result = 0);\n+      Result := pthread_cond_destroy (T.Common.LL.CV'Access);\n+      pragma Assert (Result = 0);\n+\n+      if T.Known_Tasks_Index /= -1 then\n+         Known_Tasks (T.Known_Tasks_Index) := null;\n+      end if;\n+\n+      Free (Tmp);\n+   end Finalize_TCB;\n+\n+   ---------------\n+   -- Exit_Task --\n+   ---------------\n+\n+   procedure Exit_Task is\n+   begin\n+      pthread_exit (System.Null_Address);\n+   end Exit_Task;\n+\n+   ----------------\n+   -- Abort_Task --\n+   ----------------\n+\n+   procedure Abort_Task (T : Task_ID) is\n+      Result : Interfaces.C.int;\n+\n+   begin\n+      Result := pthread_kill (T.Common.LL.Thread,\n+        Interfaces.C.int (System.Interrupt_Management.Abort_Task_Interrupt));\n+      pragma Assert (Result = 0);\n+   end Abort_Task;\n+\n+   ----------------\n+   -- Check_Exit --\n+   ----------------\n+\n+   --  Dummy versions.  The only currently working versions is for solaris\n+   --  (native).\n+\n+   function Check_Exit (Self_ID : ST.Task_ID) return Boolean is\n+   begin\n+      return True;\n+   end Check_Exit;\n+\n+   --------------------\n+   -- Check_No_Locks --\n+   --------------------\n+\n+   function Check_No_Locks (Self_ID : ST.Task_ID) return Boolean is\n+   begin\n+      return True;\n+   end Check_No_Locks;\n+\n+   ----------------------\n+   -- Environment_Task --\n+   ----------------------\n+\n+   function Environment_Task return Task_ID is\n+   begin\n+      return Environment_Task_ID;\n+   end Environment_Task;\n+\n+   -------------------------\n+   -- Lock_All_Tasks_List --\n+   -------------------------\n+\n+   procedure Lock_All_Tasks_List is\n+   begin\n+      Write_Lock (All_Tasks_L'Access);\n+   end Lock_All_Tasks_List;\n+\n+   ---------------------------\n+   -- Unlock_All_Tasks_List --\n+   ---------------------------\n+\n+   procedure Unlock_All_Tasks_List is\n+   begin\n+      Unlock (All_Tasks_L'Access);\n+   end Unlock_All_Tasks_List;\n+\n+   ------------------\n+   -- Suspend_Task --\n+   ------------------\n+\n+   function Suspend_Task\n+     (T           : ST.Task_ID;\n+      Thread_Self : Thread_Id) return Boolean is\n+   begin\n+      if T.Common.LL.Thread /= Thread_Self then\n+         return pthread_suspend (T.Common.LL.Thread) = 0;\n+      else\n+         return True;\n+      end if;\n+   end Suspend_Task;\n+\n+   -----------------\n+   -- Resume_Task --\n+   -----------------\n+\n+   function Resume_Task\n+     (T           : ST.Task_ID;\n+      Thread_Self : Thread_Id) return Boolean is\n+   begin\n+      if T.Common.LL.Thread /= Thread_Self then\n+         return pthread_resume (T.Common.LL.Thread) = 0;\n+      else\n+         return True;\n+      end if;\n+   end Resume_Task;\n+\n+   ----------------\n+   -- Initialize --\n+   ----------------\n+\n+   procedure Initialize (Environment_Task : Task_ID) is\n+   begin\n+      Environment_Task_ID := Environment_Task;\n+\n+      Initialize_Lock (All_Tasks_L'Access, All_Tasks_Level);\n+      --  Initialize the lock used to synchronize chain of all ATCBs.\n+\n+      Enter_Task (Environment_Task);\n+\n+      Set_Priority (Environment_Task,\n+        Environment_Task.Common.Current_Priority);\n+   end Initialize;\n+\n+   procedure Initialize_Athread_Library is\n+      Result : Interfaces.C.int;\n+      Init   : aliased pthread_init_struct;\n+\n+      package PINF renames System.Program_Info;\n+      package C    renames Interfaces.C;\n+\n+   begin\n+      Init.conf_initsize       := C.int (PINF.Pthread_Arena_Size);\n+      Init.max_sproc_count     := C.int (PINF.Max_Sproc_Count);\n+      Init.sproc_stack_size    := C.size_t (PINF.Sproc_Stack_Size);\n+      Init.os_default_priority := C.int (PINF.Os_Default_Priority);\n+      Init.os_sched_signal     := C.int (PINF.Pthread_Sched_Signal);\n+      Init.guard_pages         := C.int (PINF.Stack_Guard_Pages);\n+      Init.init_sproc_count    := C.int (PINF.Initial_Sproc_Count);\n+\n+      Result := pthread_exec_begin (Init'Access);\n+      pragma Assert (Result /= FUNC_ERR);\n+\n+      if Result = FUNC_ERR then\n+         raise Storage_Error;               --  Insufficient resources.\n+      end if;\n+\n+   end Initialize_Athread_Library;\n+\n+begin\n+   Initialize_Athread_Library;\n+end System.Task_Primitives.Operations;"}, {"sha": "b56675072b62266ec3c041f90715088a4db2fa2a", "filename": "gcc/ada/5gtasinf.adb", "status": "added", "additions": 270, "deletions": 0, "changes": 270, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5gtasinf.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5gtasinf.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5gtasinf.adb?ref=84481f762f0682e5f45b2f360446e1c7e333c880", "patch": "@@ -0,0 +1,270 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                     S Y S T E M . T A S K _ I N F O                      --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.2 $                              --\n+--                                                                          --\n+--          Copyright (C) 1992-1998 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package body contains the routines associated with the implementation\n+--  of the Task_Info pragma.\n+\n+--  This is the SGI specific version of this module.\n+\n+with Interfaces.C;\n+with System.OS_Interface;\n+with System;\n+with Unchecked_Conversion;\n+package body System.Task_Info is\n+\n+   use System.OS_Interface;\n+   use type Interfaces.C.int;\n+\n+   function To_Resource_T is new\n+     Unchecked_Conversion (Resource_Vector_T, resource_t);\n+\n+   MP_NPROCS : constant := 1;\n+\n+   function Sysmp (Cmd : Integer) return Integer;\n+   pragma Import (C, Sysmp);\n+\n+   function Num_Processors (Cmd : Integer := MP_NPROCS) return Integer\n+     renames Sysmp;\n+\n+   function Geteuid return Integer;\n+   pragma Import (C, Geteuid);\n+\n+   Locking_Map : constant array (Page_Locking) of Interfaces.C.int :=\n+     (NOLOCK   => 0,\n+      PROCLOCK => 1,\n+      TXTLOCK  => 2,\n+      DATLOCK  => 4);\n+\n+   package body Resource_Vector_Functions is\n+\n+      function \"+\" (R : Resource_T)\n+        return Resource_Vector_T is\n+         Result  : Resource_Vector_T  := NO_RESOURCES;\n+      begin\n+         Result (Resource_T'Pos (R)) := True;\n+         return Result;\n+      end \"+\";\n+\n+      function \"+\" (R1, R2 : Resource_T)\n+        return Resource_Vector_T is\n+         Result  : Resource_Vector_T  := NO_RESOURCES;\n+      begin\n+         Result (Resource_T'Pos (R1)) := True;\n+         Result (Resource_T'Pos (R2)) := True;\n+         return Result;\n+      end \"+\";\n+\n+      function \"+\" (R : Resource_T; S : Resource_Vector_T)\n+        return Resource_Vector_T is\n+         Result  : Resource_Vector_T := S;\n+      begin\n+         Result (Resource_T'Pos (R)) := True;\n+         return Result;\n+      end \"+\";\n+\n+      function \"+\" (S : Resource_Vector_T; R : Resource_T)\n+        return Resource_Vector_T is\n+         Result  : Resource_Vector_T :=  S;\n+      begin\n+         Result (Resource_T'Pos (R)) := True;\n+         return Result;\n+      end \"+\";\n+\n+      function \"+\" (S1, S2 : Resource_Vector_T)\n+        return Resource_Vector_T is\n+         Result  : Resource_Vector_T;\n+      begin\n+         Result :=  S1 or S2;\n+         return Result;\n+      end \"+\";\n+\n+      function \"-\" (S : Resource_Vector_T; R : Resource_T)\n+        return Resource_Vector_T is\n+         Result  : Resource_Vector_T := S;\n+      begin\n+         Result (Resource_T'Pos (R)) := False;\n+         return Result;\n+      end \"-\";\n+\n+   end Resource_Vector_Functions;\n+\n+   function New_Sproc (Attr : Sproc_Attributes) return sproc_t is\n+      Sproc_Attr : aliased sproc_attr_t;\n+      Sproc      : aliased sproc_t;\n+      Status     : int;\n+   begin\n+      Status := sproc_attr_init (Sproc_Attr'Unrestricted_Access);\n+      if Status = 0 then\n+\n+         Status := sproc_attr_setresources\n+           (Sproc_Attr'Unrestricted_Access,\n+            To_Resource_T (Attr.Sproc_Resources));\n+\n+         if Attr.CPU /= ANY_CPU then\n+            if Attr.CPU > Num_Processors then\n+               raise Invalid_CPU_Number;\n+            end if;\n+            Status := sproc_attr_setcpu\n+              (Sproc_Attr'Unrestricted_Access,\n+               int (Attr.CPU));\n+         end if;\n+\n+         if Attr.Resident /= NOLOCK then\n+\n+            if Geteuid /= 0 then\n+               raise Permission_Error;\n+            end if;\n+\n+            Status := sproc_attr_setresident\n+              (Sproc_Attr'Unrestricted_Access,\n+                Locking_Map (Attr.Resident));\n+         end if;\n+\n+         if Attr.NDPRI /= NDP_NONE then\n+--          if Geteuid /= 0 then\n+--             raise Permission_Error;\n+--          end if;\n+\n+            Status := sproc_attr_setprio\n+              (Sproc_Attr'Unrestricted_Access,\n+               int (Attr.NDPRI));\n+         end if;\n+\n+         Status := sproc_create\n+           (Sproc'Unrestricted_Access,\n+            Sproc_Attr'Unrestricted_Access,\n+            null,\n+            System.Null_Address);\n+\n+         if Status /= 0 then\n+            Status := sproc_attr_destroy (Sproc_Attr'Unrestricted_Access);\n+            raise Sproc_Create_Error;\n+         end if;\n+\n+         Status := sproc_attr_destroy (Sproc_Attr'Unrestricted_Access);\n+\n+      end if;\n+\n+      if Status /= 0 then\n+         raise Sproc_Create_Error;\n+      end if;\n+\n+      return Sproc;\n+   end New_Sproc;\n+\n+   function New_Sproc\n+     (Sproc_Resources : Resource_Vector_T      := NO_RESOURCES;\n+      CPU             : CPU_Number             := ANY_CPU;\n+      Resident        : Page_Locking           := NOLOCK;\n+      NDPRI           : Non_Degrading_Priority := NDP_NONE)\n+      return            sproc_t is\n+\n+      Attr : Sproc_Attributes :=\n+        (Sproc_Resources, CPU, Resident, NDPRI);\n+\n+   begin\n+      return New_Sproc (Attr);\n+   end New_Sproc;\n+\n+   function Unbound_Thread_Attributes\n+     (Thread_Resources : Resource_Vector_T := NO_RESOURCES;\n+      Thread_Timeslice : Duration          := 0.0)\n+      return             Thread_Attributes is\n+   begin\n+      return (False, Thread_Resources, Thread_Timeslice);\n+   end Unbound_Thread_Attributes;\n+\n+   function Bound_Thread_Attributes\n+     (Thread_Resources : Resource_Vector_T := NO_RESOURCES;\n+      Thread_Timeslice : Duration          := 0.0;\n+      Sproc            : sproc_t)\n+      return             Thread_Attributes is\n+   begin\n+      return (True, Thread_Resources, Thread_Timeslice, Sproc);\n+   end Bound_Thread_Attributes;\n+\n+   function Bound_Thread_Attributes\n+     (Thread_Resources : Resource_Vector_T      := NO_RESOURCES;\n+      Thread_Timeslice : Duration               := 0.0;\n+      Sproc_Resources  : Resource_Vector_T      := NO_RESOURCES;\n+      CPU              : CPU_Number             := ANY_CPU;\n+      Resident         : Page_Locking           := NOLOCK;\n+      NDPRI            : Non_Degrading_Priority := NDP_NONE)\n+      return             Thread_Attributes is\n+\n+      Sproc : sproc_t := New_Sproc\n+        (Sproc_Resources, CPU, Resident, NDPRI);\n+\n+   begin\n+      return (True, Thread_Resources, Thread_Timeslice, Sproc);\n+   end Bound_Thread_Attributes;\n+\n+   function New_Unbound_Thread_Attributes\n+     (Thread_Resources : Resource_Vector_T := NO_RESOURCES;\n+      Thread_Timeslice : Duration          := 0.0)\n+      return             Task_Info_Type is\n+   begin\n+      return new Thread_Attributes'\n+        (False, Thread_Resources, Thread_Timeslice);\n+   end New_Unbound_Thread_Attributes;\n+\n+   function New_Bound_Thread_Attributes\n+     (Thread_Resources : Resource_Vector_T := NO_RESOURCES;\n+      Thread_Timeslice : Duration          := 0.0;\n+      Sproc            : sproc_t)\n+      return             Task_Info_Type is\n+   begin\n+      return new Thread_Attributes'\n+        (True, Thread_Resources, Thread_Timeslice, Sproc);\n+   end  New_Bound_Thread_Attributes;\n+\n+   function New_Bound_Thread_Attributes\n+     (Thread_Resources : Resource_Vector_T      := NO_RESOURCES;\n+      Thread_Timeslice : Duration               := 0.0;\n+      Sproc_Resources  : Resource_Vector_T      := NO_RESOURCES;\n+      CPU              : CPU_Number             := ANY_CPU;\n+      Resident         : Page_Locking           := NOLOCK;\n+      NDPRI            : Non_Degrading_Priority := NDP_NONE)\n+      return             Task_Info_Type is\n+\n+      Sproc : sproc_t := New_Sproc\n+        (Sproc_Resources, CPU, Resident, NDPRI);\n+\n+   begin\n+      return new Thread_Attributes'\n+        (True, Thread_Resources, Thread_Timeslice, Sproc);\n+   end  New_Bound_Thread_Attributes;\n+\n+end System.Task_Info;"}, {"sha": "08955d8f0a70f75bdb824a74f299f002dd21fe40", "filename": "gcc/ada/5gtasinf.ads", "status": "added", "additions": 272, "deletions": 0, "changes": 272, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5gtasinf.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5gtasinf.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5gtasinf.ads?ref=84481f762f0682e5f45b2f360446e1c7e333c880", "patch": "@@ -0,0 +1,272 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                     S Y S T E M . T A S K _ I N F O                      --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.4 $\n+--                                                                          --\n+--          Copyright (C) 1992-2000 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package contains the definitions and routines associated with the\n+--  implementation of the Task_Info pragma.\n+\n+--  This is the SGI (libathread) specific version of this module.\n+\n+with System.OS_Interface;\n+with Unchecked_Deallocation;\n+package System.Task_Info is\n+pragma Elaborate_Body;\n+--  To ensure that a body is allowed\n+\n+   ---------------------------------------------------------\n+   -- Binding of Tasks to sprocs and sprocs to processors --\n+   ---------------------------------------------------------\n+\n+   --  The SGI implementation of the GNU Low-Level Interface (GNULLI)\n+   --  implements each Ada task as a Posix thread (Pthread).  The SGI\n+   --  Pthread library distributes threads across one or more processes\n+   --  that are members of a common share group.  Irix distributes\n+   --  processes across the available CPUs on a given machine.  The\n+   --  pragma Task_Info provides the mechanism to control the distribution\n+   --  of tasks to sprocs, and sprocs to processors.\n+\n+   --  Each thread has a number of attributes that dictate it's scheduling.\n+   --  These attributes are:\n+   --\n+   --      Bound_To_Sproc:  whether the thread is bound to a specific sproc\n+   --                       for its entire lifetime.\n+   --\n+   --      Timeslice:       Amount of time that a thread is allowed to execute\n+   --                       before the system yeilds control to another thread\n+   --                       of equal priority.\n+   --\n+   --      Resource_Vector: A bitmask used to control the binding of threads\n+   --                       to sprocs.\n+   --\n+\n+   --  Each share group process (sproc)\n+\n+   --  The Task_Info pragma:\n+\n+   --    pragma Task_Info (EXPRESSION);\n+\n+   --  allows the specification on a task by task basis of a value of type\n+   --  System.Task_Info.Task_Info_Type to be passed to a task when it is\n+   --  created. The specification of this type, and the effect on the task\n+   --  that is created is target dependent.\n+\n+   --  The Task_Info pragma appears within a task definition (compare the\n+   --  definition and implementation of pragma Priority). If no such pragma\n+   --  appears, then the value Task_Info_Unspecified is passed. If a pragma\n+   --  is present, then it supplies an alternative value. If the argument of\n+   --  the pragma is a discriminant reference, then the value can be set on\n+   --  a task by task basis by supplying the appropriate discriminant value.\n+\n+   --  Note that this means that the type used for Task_Info_Type must be\n+   --  suitable for use as a discriminant (i.e. a scalar or access type).\n+\n+   ----------------------\n+   -- Resource Vectors --\n+   ----------------------\n+\n+   --  <discussion>\n+\n+   type Resource_Vector_T is array (0 .. 31) of Boolean;\n+   pragma Pack (Resource_Vector_T);\n+\n+   NO_RESOURCES : constant Resource_Vector_T := (others => False);\n+\n+   generic\n+      type Resource_T is (<>); -- Discrete type up to 32 entries\n+   package Resource_Vector_Functions is\n+      function \"+\"(R : Resource_T)\n+         return Resource_Vector_T;\n+      function \"+\"(R1, R2 : Resource_T)\n+         return Resource_Vector_T;\n+      function \"+\"(R : Resource_T; S : Resource_Vector_T)\n+         return Resource_Vector_T;\n+      function \"+\"(S : Resource_Vector_T; R : Resource_T)\n+         return Resource_Vector_T;\n+      function \"+\"(S1, S2 : Resource_Vector_T)\n+         return Resource_Vector_T;\n+      function \"-\"(S : Resource_Vector_T; R : Resource_T)\n+         return Resource_Vector_T;\n+   end Resource_Vector_Functions;\n+\n+   ----------------------\n+   -- Sproc Attributes --\n+   ----------------------\n+\n+   subtype sproc_t is System.OS_Interface.sproc_t;\n+\n+   subtype CPU_Number is Integer range -1 .. Integer'Last;\n+\n+   ANY_CPU : constant CPU_Number := CPU_Number'First;\n+\n+   --\n+   --  Specification of IRIX Non Degrading Priorities.\n+   --\n+   --  WARNING: IRIX priorities have the reverse meaning of Ada priorities.\n+   --           The lower the priority value, the greater the greater the\n+   --           scheduling preference.\n+   --\n+   --  See the schedctl(2) man page for a complete discussion of non-degrading\n+   --  priorities.\n+   --\n+   type Non_Degrading_Priority is range 0 .. 255;\n+\n+   --  these priorities are higher than ALL normal user process priorities\n+   NDPHIMAX   : constant Non_Degrading_Priority := 30;\n+   NDPHIMIN   : constant Non_Degrading_Priority := 39;\n+\n+   subtype NDP_High is Non_Degrading_Priority range NDPHIMAX .. NDPHIMIN;\n+\n+   --  these priorities overlap normal user process priorities\n+   NDPNORMMAX : constant Non_Degrading_Priority := 40;\n+   NDPNORMMIN : constant Non_Degrading_Priority := 127;\n+\n+   subtype NDP_Norm is Non_Degrading_Priority range NDPNORMMAX .. NDPNORMMIN;\n+\n+   --  these priorities are below ALL normal user process priorities\n+   NDPLOMAX   : constant Non_Degrading_Priority := 128;\n+   NDPLOMIN   : constant Non_Degrading_Priority := 254;\n+\n+   NDP_NONE   : constant Non_Degrading_Priority := 255;\n+\n+   subtype NDP_LOW is Non_Degrading_Priority range NDPLOMAX .. NDPLOMIN;\n+\n+   type Page_Locking is\n+      (NOLOCK,     --  Do not lock pages in memory\n+       PROCLOCK,   --  Lock text and data segments into memory (process lock)\n+       TXTLOCK,    --  Lock text segment into memory (text lock)\n+       DATLOCK     --  Lock data segment into memory (data lock)\n+      );\n+\n+   type Sproc_Attributes is\n+      record\n+         Sproc_Resources : Resource_Vector_T      := NO_RESOURCES;\n+         CPU             : CPU_Number             := ANY_CPU;\n+         Resident        : Page_Locking           := NOLOCK;\n+         NDPRI           : Non_Degrading_Priority := NDP_NONE;\n+--       Sproc_Slice     : Duration               := 0.0;\n+--       Deadline_Period : Duration               := 0.0;\n+--       Deadline_Alloc  : Duration               := 0.0;\n+\n+      end record;\n+\n+   Default_Sproc_Attributes : constant Sproc_Attributes :=\n+      (NO_RESOURCES, ANY_CPU, NOLOCK, NDP_NONE);\n+\n+   function New_Sproc (Attr : Sproc_Attributes) return sproc_t;\n+   function New_Sproc\n+     (Sproc_Resources : Resource_Vector_T      := NO_RESOURCES;\n+      CPU             : CPU_Number             := ANY_CPU;\n+      Resident        : Page_Locking           := NOLOCK;\n+      NDPRI           : Non_Degrading_Priority := NDP_NONE)\n+      return            sproc_t;\n+   --\n+   --  Allocates a sproc_t controll structure and creates the\n+   --  corresponding sproc.\n+   --\n+\n+   Invalid_CPU_Number : exception;\n+   Permission_Error   : exception;\n+   Sproc_Create_Error : exception;\n+\n+   -----------------------\n+   -- Thread Attributes --\n+   -----------------------\n+\n+   type Thread_Attributes (Bound_To_Sproc : Boolean) is\n+      record\n+         Thread_Resources : Resource_Vector_T := NO_RESOURCES;\n+         Thread_Timeslice : Duration          := 0.0;\n+         case Bound_To_Sproc is\n+            when False =>\n+               null;\n+            when True   =>\n+               Sproc : sproc_t;\n+         end case;\n+      end record;\n+\n+   Default_Thread_Attributes : constant Thread_Attributes :=\n+     (False, NO_RESOURCES, 0.0);\n+\n+   function Unbound_Thread_Attributes\n+     (Thread_Resources : Resource_Vector_T := NO_RESOURCES;\n+      Thread_Timeslice : Duration          := 0.0)\n+      return             Thread_Attributes;\n+\n+   function Bound_Thread_Attributes\n+     (Thread_Resources : Resource_Vector_T := NO_RESOURCES;\n+      Thread_Timeslice : Duration          := 0.0;\n+      Sproc            : sproc_t)\n+      return             Thread_Attributes;\n+\n+   function Bound_Thread_Attributes\n+     (Thread_Resources : Resource_Vector_T      := NO_RESOURCES;\n+      Thread_Timeslice : Duration               := 0.0;\n+      Sproc_Resources  : Resource_Vector_T      := NO_RESOURCES;\n+      CPU              : CPU_Number             := ANY_CPU;\n+      Resident         : Page_Locking           := NOLOCK;\n+      NDPRI            : Non_Degrading_Priority := NDP_NONE)\n+      return             Thread_Attributes;\n+\n+   type Task_Info_Type is access all Thread_Attributes;\n+\n+   function New_Unbound_Thread_Attributes\n+     (Thread_Resources : Resource_Vector_T := NO_RESOURCES;\n+      Thread_Timeslice : Duration          := 0.0)\n+      return             Task_Info_Type;\n+\n+   function New_Bound_Thread_Attributes\n+     (Thread_Resources : Resource_Vector_T := NO_RESOURCES;\n+      Thread_Timeslice : Duration          := 0.0;\n+      Sproc            : sproc_t)\n+      return             Task_Info_Type;\n+\n+   function New_Bound_Thread_Attributes\n+     (Thread_Resources : Resource_Vector_T      := NO_RESOURCES;\n+      Thread_Timeslice : Duration               := 0.0;\n+      Sproc_Resources  : Resource_Vector_T      := NO_RESOURCES;\n+      CPU              : CPU_Number             := ANY_CPU;\n+      Resident         : Page_Locking           := NOLOCK;\n+      NDPRI            : Non_Degrading_Priority := NDP_NONE)\n+      return             Task_Info_Type;\n+\n+   type Task_Image_Type is access String;\n+   --  Used to generate a meaningful identifier for tasks that are variables\n+   --  and components of variables.\n+\n+   procedure Free_Task_Image is new\n+     Unchecked_Deallocation (String, Task_Image_Type);\n+\n+   Unspecified_Task_Info : constant Task_Info_Type := null;\n+\n+end System.Task_Info;"}, {"sha": "2d6edd8a29f19c5784da6099e0222fbd756a8ca9", "filename": "gcc/ada/5gtpgetc.adb", "status": "added", "additions": 210, "deletions": 0, "changes": 210, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5gtpgetc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5gtpgetc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5gtpgetc.adb?ref=84481f762f0682e5f45b2f360446e1c7e333c880", "patch": "@@ -0,0 +1,210 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS               --\n+--                                                                          --\n+--     S Y S T E M . T A S K _ P R I M I T I V E S . G E N _ T C B I N F    --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.5 $\n+--                                                                          --\n+--              Copyright (C) 1999-2000 Free Software Fundation             --\n+--                                                                          --\n+-- GNARL is free software; you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion. GNARL is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNARL; see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNARL was developed by the GNARL team at Florida State University. It is --\n+-- now maintained by Ada Core Technologies Inc. in cooperation with Florida --\n+-- State University (http://www.gnat.com).                                  --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is an SGI Irix version of this package\n+\n+--  This procedure creates the file \"a-tcbinf.c\"\n+--  \"A-tcbinf.c\" is subsequently compiled and made part of the RTL\n+--  to be referenced by the SGI Workshop debugger. The main procedure:\n+--  \"Gen_Tcbinf\" imports this child procedure and runs as part of the\n+--  RTL build process. Because of the complex process used to build\n+--  the GNAT RTL for all the different systems and the frequent changes\n+--  made to the internal data structures, its impractical to create\n+--  \"a-tcbinf.c\" using a standalone process.\n+with System.Tasking;\n+with Ada.Text_IO;\n+with Unchecked_Conversion;\n+\n+procedure System.Task_Primitives.Gen_Tcbinf is\n+\n+   use System.Tasking;\n+\n+   subtype Version_String is String (1 .. 4);\n+\n+   Version : constant Version_String := \"3.11\";\n+\n+   function To_Integer is new Unchecked_Conversion\n+     (Version_String, Integer);\n+\n+   type Dummy_TCB_Ptr is access Ada_Task_Control_Block (Entry_Num => 0);\n+   Dummy_TCB : constant Dummy_TCB_Ptr := new Ada_Task_Control_Block (0);\n+\n+   C_File : Ada.Text_IO.File_Type;\n+\n+   procedure Pl (S : String);\n+   procedure Nl (C : Ada.Text_IO.Positive_Count := 1);\n+   function State_Name (S : Task_States) return String;\n+\n+   procedure Pl (S : String) is\n+   begin\n+      Ada.Text_IO.Put_Line (C_File, S);\n+   end Pl;\n+\n+   procedure Nl (C : Ada.Text_IO.Positive_Count := 1) is\n+   begin\n+      Ada.Text_IO.New_Line (C_File, C);\n+   end Nl;\n+\n+   function State_Name (S : Task_States) return String is\n+   begin\n+      case S is\n+         when Unactivated =>\n+            return \"Unactivated\";\n+         when Runnable =>\n+            return \"Runnable\";\n+         when Terminated =>\n+            return \"Terminated\";\n+         when Activator_Sleep =>\n+            return \"Child Activation Wait\";\n+         when Acceptor_Sleep =>\n+            return \"Accept/Select Wait\";\n+         when Entry_Caller_Sleep =>\n+            return \"Waiting on Entry Call\";\n+         when Async_Select_Sleep =>\n+            return \"Async_Select Wait\";\n+         when Delay_Sleep =>\n+            return \"Delay Sleep\";\n+         when Master_Completion_Sleep =>\n+            return \"Child Termination Wait\";\n+         when Master_Phase_2_Sleep =>\n+            return \"Wait Child in Term Alt\";\n+         when Interrupt_Server_Idle_Sleep =>\n+            return \"Int Server Idle Sleep\";\n+         when Interrupt_Server_Blocked_Interrupt_Sleep =>\n+            return \"Int Server Blk Int Sleep\";\n+         when Timer_Server_Sleep =>\n+            return \"Timer Server Sleep\";\n+         when AST_Server_Sleep =>\n+            return \"AST Server Sleep\";\n+         when Asynchronous_Hold =>\n+            return \"Asynchronous Hold\";\n+         when Interrupt_Server_Blocked_On_Event_Flag =>\n+            return \"Int Server Blk Evt Flag\";\n+      end case;\n+   end State_Name;\n+\n+   All_Tasks_Link_Offset   : constant Integer\n+     := Dummy_TCB.Common'Position + Dummy_TCB.Common.All_Tasks_Link'Position;\n+   Entry_Count_Offset      : constant Integer\n+     := Dummy_TCB.Entry_Num'Position;\n+   Entry_Point_Offset      : constant Integer\n+     := Dummy_TCB.Common'Position + Dummy_TCB.Common.Task_Entry_Point'Position;\n+   Parent_Offset           : constant Integer\n+     := Dummy_TCB.Common'Position + Dummy_TCB.Common.Parent'Position;\n+   Base_Priority_Offset    : constant Integer\n+     := Dummy_TCB.Common'Position + Dummy_TCB.Common.Base_Priority'Position;\n+   Current_Priority_Offset : constant Integer\n+     := Dummy_TCB.Common'Position + Dummy_TCB.Common.Current_Priority'Position;\n+   Stack_Size_Offset       : constant Integer\n+     := Dummy_TCB.Common'Position +\n+       Dummy_TCB.Common.Compiler_Data.Pri_Stack_Info.Size'Position;\n+   State_Offset            : constant Integer\n+     := Dummy_TCB.Common'Position + Dummy_TCB.Common.State'Position;\n+   Task_Image_Offset       : constant Integer\n+     := Dummy_TCB.Common'Position + Dummy_TCB.Common.Task_Image'Position;\n+   Thread_Offset           : constant Integer\n+     := Dummy_TCB.Common'Position + Dummy_TCB.Common.LL'Position +\n+        Dummy_TCB.Common.LL.Thread'Position;\n+\n+begin\n+\n+   Ada.Text_IO.Create (C_File, Ada.Text_IO.Out_File, \"a-tcbinf.c\");\n+\n+   Pl (\"\");\n+   Pl (\"#include <sys/types.h>\");\n+   Pl (\"\");\n+   Pl (\"#define TCB_INFO_VERSION 2\");\n+   Pl (\"#define TCB_LIBRARY_VERSION \"\n+     & Integer'Image (To_Integer (Version)));\n+   Pl (\"\");\n+   Pl (\"typedef struct {\");\n+   Pl (\"\");\n+   Pl (\"   __uint32_t   info_version;\");\n+   Pl (\"   __uint32_t   library_version;\");\n+   Pl (\"\");\n+   Pl (\"   __uint32_t   All_Tasks_Link_Offset;\");\n+   Pl (\"   __uint32_t   Entry_Count_Offset;\");\n+   Pl (\"   __uint32_t   Entry_Point_Offset;\");\n+   Pl (\"   __uint32_t   Parent_Offset;\");\n+   Pl (\"   __uint32_t   Base_Priority_Offset;\");\n+   Pl (\"   __uint32_t   Current_Priority_Offset;\");\n+   Pl (\"   __uint32_t   Stack_Size_Offset;\");\n+   Pl (\"   __uint32_t   State_Offset;\");\n+   Pl (\"   __uint32_t   Task_Image_Offset;\");\n+   Pl (\"   __uint32_t   Thread_Offset;\");\n+   Pl (\"\");\n+   Pl (\"   char         **state_names;\");\n+   Pl (\"   __uint32_t   state_names_max;\");\n+   Pl (\"\");\n+   Pl (\"} task_control_block_info_t;\");\n+   Pl (\"\");\n+   Pl (\"static char *accepting_state_names = NULL;\");\n+\n+   Pl (\"\");\n+   Pl (\"static char *task_state_names[] = {\");\n+\n+   for State in Task_States loop\n+      Pl (\"   \"\"\" & State_Name (State) & \"\"\",\");\n+   end loop;\n+   Pl (\"   \"\"\"\"};\");\n+\n+   Pl (\"\");\n+   Pl (\"\");\n+   Pl (\"task_control_block_info_t __task_control_block_info = {\");\n+   Pl (\"\");\n+   Pl (\"   TCB_INFO_VERSION,\");\n+   Pl (\"   TCB_LIBRARY_VERSION,\");\n+   Pl (\"\");\n+   Pl (\"   \" & All_Tasks_Link_Offset'Img & \",\");\n+   Pl (\"   \" & Entry_Count_Offset'Img & \",\");\n+   Pl (\"   \" & Entry_Point_Offset'Img & \",\");\n+   Pl (\"   \" & Parent_Offset'Img & \",\");\n+   Pl (\"   \" & Base_Priority_Offset'Img & \",\");\n+   Pl (\"   \" & Current_Priority_Offset'Img & \",\");\n+   Pl (\"   \" & Stack_Size_Offset'Img & \",\");\n+   Pl (\"   \" & State_Offset'Img & \",\");\n+   Pl (\"   \" & Task_Image_Offset'Img & \",\");\n+   Pl (\"   \" & Thread_Offset'Img & \",\");\n+   Pl (\"\");\n+   Pl (\"   task_state_names,\");\n+   Pl (\"   sizeof (task_state_names),\");\n+   Pl (\"\");\n+   Pl (\"\");\n+   Pl (\"};\");\n+\n+   Ada.Text_IO.Close (C_File);\n+\n+end System.Task_Primitives.Gen_Tcbinf;"}, {"sha": "753c041942a6b90c4c0117b5b43c47fdd3beec95", "filename": "gcc/ada/5hosinte.adb", "status": "added", "additions": 561, "deletions": 0, "changes": 561, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5hosinte.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5hosinte.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5hosinte.adb?ref=84481f762f0682e5f45b2f360446e1c7e333c880", "patch": "@@ -0,0 +1,561 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS               --\n+--                                                                          --\n+--                   S Y S T E M . O S _ I N T E R F A C E                  --\n+--                                                                          --\n+--                                  B o d y                                 --\n+--                                                                          --\n+--                             $Revision: 1.14 $\n+--                                                                          --\n+--            Copyright (C) 1991-2001, Florida State University             --\n+--                                                                          --\n+-- GNARL is free software; you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion. GNARL is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNARL; see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNARL was developed by the GNARL team at Florida State University. It is --\n+-- now maintained by Ada Core Technologies Inc. in cooperation with Florida --\n+-- State University (http://www.gnat.com).                                  --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is a DCE version of this package.\n+--  Currently HP-UX and SNI use this file\n+\n+pragma Polling (Off);\n+--  Turn off polling, we do not want ATC polling to take place during\n+--  tasking operations. It causes infinite loops and other problems.\n+\n+--  This package encapsulates all direct interfaces to OS services\n+--  that are needed by children of System.\n+\n+with Interfaces.C; use Interfaces.C;\n+\n+package body System.OS_Interface is\n+\n+   -----------------\n+   -- To_Duration --\n+   -----------------\n+\n+   function To_Duration (TS : timespec) return Duration is\n+   begin\n+      return Duration (TS.tv_sec) + Duration (TS.tv_nsec) / 10#1#E9;\n+   end To_Duration;\n+\n+   -----------------\n+   -- To_Timespec --\n+   -----------------\n+\n+   function To_Timespec (D : Duration) return timespec is\n+      S : time_t;\n+      F : Duration;\n+\n+   begin\n+      S := time_t (Long_Long_Integer (D));\n+      F := D - Duration (S);\n+\n+      --  If F has negative value due to a round-up, adjust for positive F\n+      --  value.\n+      if F < 0.0 then\n+         S := S - 1;\n+         F := F + 1.0;\n+      end if;\n+\n+      return timespec' (tv_sec => S,\n+        tv_nsec => long (Long_Long_Integer (F * 10#1#E9)));\n+   end To_Timespec;\n+\n+   function To_Duration (TV : struct_timeval) return Duration is\n+   begin\n+      return Duration (TV.tv_sec) + Duration (TV.tv_usec) / 10#1#E6;\n+   end To_Duration;\n+\n+   function To_Timeval (D : Duration) return struct_timeval is\n+      S : time_t;\n+      F : Duration;\n+   begin\n+      S := time_t (Long_Long_Integer (D));\n+      F := D - Duration (S);\n+\n+      --  If F has negative value due to a round-up, adjust for positive F\n+      --  value.\n+\n+      if F < 0.0 then\n+         S := S - 1;\n+         F := F + 1.0;\n+      end if;\n+\n+      return struct_timeval' (tv_sec => S,\n+        tv_usec => time_t (Long_Long_Integer (F * 10#1#E6)));\n+   end To_Timeval;\n+\n+   ---------------------------\n+   --  POSIX.1c  Section 3  --\n+   ---------------------------\n+\n+   function sigwait\n+     (set : access sigset_t;\n+      sig : access Signal)\n+     return int\n+   is\n+      Result : int;\n+\n+   begin\n+      Result := sigwait (set);\n+\n+      if Result = -1 then\n+         sig.all := 0;\n+         return errno;\n+      end if;\n+\n+      sig.all := Signal (Result);\n+      return 0;\n+   end sigwait;\n+\n+   --  DCE_THREADS does not have pthread_kill. Instead, we just ignore it.\n+\n+   function pthread_kill (thread : pthread_t; sig : Signal) return int is\n+   begin\n+      return 0;\n+   end pthread_kill;\n+\n+   ----------------------------\n+   --  POSIX.1c  Section 11  --\n+   ----------------------------\n+\n+   --  For all the following functions, DCE Threads has a non standard\n+   --  behavior: it sets errno but the standard Posix requires it to be\n+   --  returned.\n+\n+   function pthread_mutexattr_init\n+     (attr : access pthread_mutexattr_t)\n+     return int\n+   is\n+      function pthread_mutexattr_create\n+        (attr : access pthread_mutexattr_t)\n+        return int;\n+      pragma Import (C, pthread_mutexattr_create, \"pthread_mutexattr_create\");\n+\n+   begin\n+      if pthread_mutexattr_create (attr) /= 0 then\n+         return errno;\n+      else\n+         return 0;\n+      end if;\n+   end pthread_mutexattr_init;\n+\n+   function pthread_mutexattr_destroy\n+     (attr : access pthread_mutexattr_t)\n+     return int\n+   is\n+      function pthread_mutexattr_delete\n+        (attr : access pthread_mutexattr_t)\n+        return int;\n+      pragma Import (C, pthread_mutexattr_delete, \"pthread_mutexattr_delete\");\n+\n+   begin\n+      if pthread_mutexattr_delete (attr) /= 0 then\n+         return errno;\n+      else\n+         return 0;\n+      end if;\n+   end pthread_mutexattr_destroy;\n+\n+   function pthread_mutex_init\n+     (mutex : access pthread_mutex_t;\n+      attr  : access pthread_mutexattr_t)\n+     return int\n+   is\n+      function pthread_mutex_init_base\n+        (mutex : access pthread_mutex_t;\n+         attr  : pthread_mutexattr_t)\n+        return int;\n+      pragma Import (C, pthread_mutex_init_base, \"pthread_mutex_init\");\n+\n+   begin\n+      if pthread_mutex_init_base (mutex, attr.all) /= 0 then\n+         return errno;\n+      else\n+         return 0;\n+      end if;\n+   end pthread_mutex_init;\n+\n+   function pthread_mutex_destroy\n+     (mutex : access pthread_mutex_t)\n+     return int\n+   is\n+      function pthread_mutex_destroy_base\n+        (mutex : access pthread_mutex_t)\n+        return int;\n+      pragma Import (C, pthread_mutex_destroy_base, \"pthread_mutex_destroy\");\n+\n+   begin\n+      if pthread_mutex_destroy_base (mutex) /= 0 then\n+         return errno;\n+      else\n+         return 0;\n+      end if;\n+   end pthread_mutex_destroy;\n+\n+   function pthread_mutex_lock\n+     (mutex : access pthread_mutex_t)\n+     return int\n+   is\n+      function pthread_mutex_lock_base\n+        (mutex : access pthread_mutex_t)\n+        return int;\n+      pragma Import (C, pthread_mutex_lock_base, \"pthread_mutex_lock\");\n+\n+   begin\n+      if pthread_mutex_lock_base (mutex) /= 0 then\n+         return errno;\n+      else\n+         return 0;\n+      end if;\n+   end pthread_mutex_lock;\n+\n+   function pthread_mutex_unlock\n+     (mutex : access pthread_mutex_t)\n+     return int\n+   is\n+      function pthread_mutex_unlock_base\n+        (mutex : access pthread_mutex_t)\n+        return int;\n+      pragma Import (C, pthread_mutex_unlock_base, \"pthread_mutex_unlock\");\n+\n+   begin\n+      if pthread_mutex_unlock_base (mutex) /= 0 then\n+         return errno;\n+      else\n+         return 0;\n+      end if;\n+   end pthread_mutex_unlock;\n+\n+   function pthread_condattr_init\n+     (attr : access pthread_condattr_t)\n+     return int\n+   is\n+      function pthread_condattr_create\n+        (attr : access pthread_condattr_t)\n+        return int;\n+      pragma Import (C, pthread_condattr_create, \"pthread_condattr_create\");\n+\n+   begin\n+      if pthread_condattr_create (attr) /= 0 then\n+         return errno;\n+      else\n+         return 0;\n+      end if;\n+   end pthread_condattr_init;\n+\n+   function pthread_condattr_destroy\n+     (attr : access pthread_condattr_t)\n+     return int\n+   is\n+      function pthread_condattr_delete\n+        (attr : access pthread_condattr_t)\n+        return int;\n+      pragma Import (C, pthread_condattr_delete, \"pthread_condattr_delete\");\n+\n+   begin\n+      if pthread_condattr_delete (attr) /= 0 then\n+         return errno;\n+      else\n+         return 0;\n+      end if;\n+   end pthread_condattr_destroy;\n+\n+   function pthread_cond_init\n+     (cond : access pthread_cond_t;\n+      attr : access pthread_condattr_t)\n+     return int\n+   is\n+      function pthread_cond_init_base\n+        (cond : access pthread_cond_t;\n+         attr : pthread_condattr_t)\n+        return int;\n+      pragma Import (C, pthread_cond_init_base, \"pthread_cond_init\");\n+\n+   begin\n+      if pthread_cond_init_base (cond, attr.all) /= 0 then\n+         return errno;\n+      else\n+         return 0;\n+      end if;\n+   end pthread_cond_init;\n+\n+   function pthread_cond_destroy\n+     (cond : access pthread_cond_t)\n+     return int\n+   is\n+      function pthread_cond_destroy_base\n+        (cond : access pthread_cond_t)\n+        return int;\n+      pragma Import (C, pthread_cond_destroy_base, \"pthread_cond_destroy\");\n+\n+   begin\n+      if pthread_cond_destroy_base (cond) /= 0 then\n+         return errno;\n+      else\n+         return 0;\n+      end if;\n+   end pthread_cond_destroy;\n+\n+   function pthread_cond_signal\n+     (cond : access pthread_cond_t)\n+     return int\n+   is\n+      function pthread_cond_signal_base\n+        (cond : access pthread_cond_t)\n+        return int;\n+      pragma Import (C, pthread_cond_signal_base, \"pthread_cond_signal\");\n+\n+   begin\n+      if pthread_cond_signal_base (cond) /= 0 then\n+         return errno;\n+      else\n+         return 0;\n+      end if;\n+   end pthread_cond_signal;\n+\n+   function pthread_cond_wait\n+     (cond  : access pthread_cond_t;\n+      mutex : access pthread_mutex_t)\n+     return int\n+   is\n+      function pthread_cond_wait_base\n+        (cond  : access pthread_cond_t;\n+         mutex : access pthread_mutex_t)\n+        return int;\n+      pragma Import (C, pthread_cond_wait_base, \"pthread_cond_wait\");\n+\n+   begin\n+      if pthread_cond_wait_base (cond, mutex) /= 0 then\n+         return errno;\n+      else\n+         return 0;\n+      end if;\n+   end pthread_cond_wait;\n+\n+   function pthread_cond_timedwait\n+     (cond    : access pthread_cond_t;\n+      mutex   : access pthread_mutex_t;\n+      abstime : access timespec)\n+     return int\n+   is\n+      function pthread_cond_timedwait_base\n+        (cond    : access pthread_cond_t;\n+         mutex   : access pthread_mutex_t;\n+         abstime : access timespec)\n+        return int;\n+      pragma Import (C, pthread_cond_timedwait_base, \"pthread_cond_timedwait\");\n+\n+   begin\n+      if pthread_cond_timedwait_base (cond, mutex, abstime) /= 0 then\n+         if errno = EAGAIN then\n+            return ETIMEDOUT;\n+         else\n+            return errno;\n+         end if;\n+      else\n+         return 0;\n+      end if;\n+   end pthread_cond_timedwait;\n+\n+   ----------------------------\n+   --  POSIX.1c  Section 13  --\n+   ----------------------------\n+\n+   function pthread_setschedparam\n+     (thread : pthread_t;\n+      policy : int;\n+      param  : access struct_sched_param) return int\n+   is\n+      function pthread_setscheduler\n+        (thread   : pthread_t;\n+         policy   : int;\n+         priority : int)\n+         return int;\n+      pragma Import (C, pthread_setscheduler, \"pthread_setscheduler\");\n+\n+   begin\n+      if pthread_setscheduler (thread, policy, param.sched_priority) = -1 then\n+         return errno;\n+      else\n+         return 0;\n+      end if;\n+   end pthread_setschedparam;\n+\n+   function sched_yield return int is\n+      procedure pthread_yield;\n+      pragma Import (C, pthread_yield, \"pthread_yield\");\n+   begin\n+      pthread_yield;\n+      return 0;\n+   end sched_yield;\n+\n+   -----------------------------\n+   --  P1003.1c - Section 16  --\n+   -----------------------------\n+\n+   function pthread_attr_init (attributes : access pthread_attr_t) return int\n+   is\n+      function pthread_attr_create\n+        (attributes : access pthread_attr_t)\n+        return int;\n+      pragma Import (C, pthread_attr_create, \"pthread_attr_create\");\n+\n+   begin\n+      if pthread_attr_create (attributes) /= 0 then\n+         return errno;\n+      else\n+         return 0;\n+      end if;\n+   end pthread_attr_init;\n+\n+   function pthread_attr_destroy\n+     (attributes : access pthread_attr_t) return int\n+   is\n+      function pthread_attr_delete\n+        (attributes : access pthread_attr_t)\n+        return int;\n+      pragma Import (C, pthread_attr_delete, \"pthread_attr_delete\");\n+\n+   begin\n+      if pthread_attr_delete (attributes) /= 0 then\n+         return errno;\n+      else\n+         return 0;\n+      end if;\n+   end pthread_attr_destroy;\n+\n+   function pthread_attr_setstacksize\n+     (attr      : access pthread_attr_t;\n+      stacksize : size_t) return int\n+   is\n+      function pthread_attr_setstacksize_base\n+        (attr      : access pthread_attr_t;\n+         stacksize : size_t)\n+        return int;\n+      pragma Import (C, pthread_attr_setstacksize_base,\n+                     \"pthread_attr_setstacksize\");\n+\n+   begin\n+      if pthread_attr_setstacksize_base (attr, stacksize) /= 0 then\n+         return errno;\n+      else\n+         return 0;\n+      end if;\n+   end pthread_attr_setstacksize;\n+\n+   function pthread_create\n+     (thread        : access pthread_t;\n+      attributes    : access pthread_attr_t;\n+      start_routine : Thread_Body;\n+      arg           : System.Address) return int\n+   is\n+      function pthread_create_base\n+        (thread        : access pthread_t;\n+         attributes    : pthread_attr_t;\n+         start_routine : Thread_Body;\n+         arg           : System.Address)\n+        return int;\n+      pragma Import (C, pthread_create_base, \"pthread_create\");\n+\n+   begin\n+      if pthread_create_base\n+        (thread, attributes.all, start_routine, arg) /= 0\n+      then\n+         return errno;\n+      else\n+         return 0;\n+      end if;\n+   end pthread_create;\n+\n+   ----------------------------\n+   --  POSIX.1c  Section 17  --\n+   ----------------------------\n+\n+   function pthread_setspecific\n+     (key   : pthread_key_t;\n+      value : System.Address) return int\n+   is\n+      function pthread_setspecific_base\n+        (key   : pthread_key_t;\n+         value : System.Address) return int;\n+      pragma Import (C, pthread_setspecific_base, \"pthread_setspecific\");\n+\n+   begin\n+      if pthread_setspecific_base (key, value) /= 0 then\n+         return errno;\n+      else\n+         return 0;\n+      end if;\n+   end pthread_setspecific;\n+\n+   function pthread_getspecific (key : pthread_key_t) return System.Address is\n+      function pthread_getspecific_base\n+        (key   : pthread_key_t;\n+         value : access System.Address) return  int;\n+      pragma Import (C, pthread_getspecific_base, \"pthread_getspecific\");\n+      Addr : aliased System.Address;\n+\n+   begin\n+      if pthread_getspecific_base (key, Addr'Access) /= 0 then\n+         return System.Null_Address;\n+      else\n+         return Addr;\n+      end if;\n+   end pthread_getspecific;\n+\n+   function pthread_key_create\n+     (key        : access pthread_key_t;\n+      destructor : destructor_pointer) return int\n+   is\n+      function pthread_keycreate\n+        (key        : access pthread_key_t;\n+         destructor : destructor_pointer) return int;\n+      pragma Import (C, pthread_keycreate, \"pthread_keycreate\");\n+\n+   begin\n+      if pthread_keycreate (key, destructor) /= 0 then\n+         return errno;\n+      else\n+         return 0;\n+      end if;\n+   end pthread_key_create;\n+\n+   function Get_Stack_Base (thread : pthread_t) return Address is\n+   begin\n+      return Null_Address;\n+   end Get_Stack_Base;\n+\n+   procedure pthread_init is\n+   begin\n+      null;\n+   end pthread_init;\n+\n+   function intr_attach (sig : int; handler : isr_address) return long is\n+      function c_signal (sig : int; handler : isr_address) return long;\n+      pragma Import (C, c_signal, \"signal\");\n+\n+   begin\n+      return c_signal (sig, handler);\n+   end intr_attach;\n+\n+end System.OS_Interface;"}, {"sha": "665715d137701196b726dafed8a74782a160e07a", "filename": "gcc/ada/5hosinte.ads", "status": "added", "additions": 491, "deletions": 0, "changes": 491, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5hosinte.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5hosinte.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5hosinte.ads?ref=84481f762f0682e5f45b2f360446e1c7e333c880", "patch": "@@ -0,0 +1,491 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS               --\n+--                                                                          --\n+--                   S Y S T E M . O S _ I N T E R F A C E                  --\n+--                                                                          --\n+--                                  S p e c                                 --\n+--                                                                          --\n+--                             $Revision: 1.28 $\n+--                                                                          --\n+--             Copyright (C) 1997-2001, Florida State University            --\n+--                                                                          --\n+-- GNARL is free software; you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion. GNARL is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNARL; see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNARL was developed by the GNARL team at Florida State University. It is --\n+-- now maintained by Ada Core Technologies Inc. in cooperation with Florida --\n+-- State University (http://www.gnat.com).                                  --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is the HP-UX version of this package.\n+\n+--  This package encapsulates all direct interfaces to OS services\n+--  that are needed by children of System.\n+\n+--  PLEASE DO NOT add any with-clauses to this package\n+--  or remove the pragma Elaborate_Body.\n+--  It is designed to be a bottom-level (leaf) package.\n+\n+with Interfaces.C;\n+package System.OS_Interface is\n+   pragma Preelaborate;\n+\n+   pragma Linker_Options (\"-lcma\");\n+\n+   subtype int            is Interfaces.C.int;\n+   subtype short          is Interfaces.C.short;\n+   subtype long           is Interfaces.C.long;\n+   subtype unsigned       is Interfaces.C.unsigned;\n+   subtype unsigned_short is Interfaces.C.unsigned_short;\n+   subtype unsigned_long  is Interfaces.C.unsigned_long;\n+   subtype unsigned_char  is Interfaces.C.unsigned_char;\n+   subtype plain_char     is Interfaces.C.plain_char;\n+   subtype size_t         is Interfaces.C.size_t;\n+\n+   -----------\n+   -- Errno --\n+   -----------\n+\n+   function errno return int;\n+   pragma Import (C, errno, \"__get_errno\");\n+\n+   EAGAIN    : constant := 11;\n+   EINTR     : constant := 4;\n+   EINVAL    : constant := 22;\n+   ENOMEM    : constant := 12;\n+   ETIME     : constant := 52;\n+   ETIMEDOUT : constant := 238;\n+\n+   FUNC_ERR : constant := -1;\n+\n+   -------------\n+   -- Signals --\n+   -------------\n+\n+   Max_Interrupt : constant := 44;\n+   type Signal is new int range 0 .. Max_Interrupt;\n+   for Signal'Size use int'Size;\n+\n+   SIGHUP     : constant := 1; --  hangup\n+   SIGINT     : constant := 2; --  interrupt (rubout)\n+   SIGQUIT    : constant := 3; --  quit (ASCD FS)\n+   SIGILL     : constant := 4; --  illegal instruction (not reset)\n+   SIGTRAP    : constant := 5; --  trace trap (not reset)\n+   SIGIOT     : constant := 6; --  IOT instruction\n+   SIGABRT    : constant := 6; --  used by abort, replace SIGIOT in the  future\n+   SIGEMT     : constant := 7; --  EMT instruction\n+   SIGFPE     : constant := 8; --  floating point exception\n+   SIGKILL    : constant := 9; --  kill (cannot be caught or ignored)\n+   SIGBUS     : constant := 10; --  bus error\n+   SIGSEGV    : constant := 11; --  segmentation violation\n+   SIGSYS     : constant := 12; --  bad argument to system call\n+   SIGPIPE    : constant := 13; --  write on a pipe with no one to read it\n+   SIGALRM    : constant := 14; --  alarm clock\n+   SIGTERM    : constant := 15; --  software termination signal from kill\n+   SIGUSR1    : constant := 16; --  user defined signal 1\n+   SIGUSR2    : constant := 17; --  user defined signal 2\n+   SIGCLD     : constant := 18; --  alias for SIGCHLD\n+   SIGCHLD    : constant := 18; --  child status change\n+   SIGPWR     : constant := 19; --  power-fail restart\n+   SIGVTALRM  : constant := 20; --  virtual timer alarm\n+   SIGPROF    : constant := 21; --  profiling timer alarm\n+   SIGIO      : constant := 22; --  asynchronous I/O\n+   SIGPOLL    : constant := 22; --  pollable event occurred\n+   SIGWINCH   : constant := 23; --  window size change\n+   SIGSTOP    : constant := 24; --  stop (cannot be caught or ignored)\n+   SIGTSTP    : constant := 25; --  user stop requested from tty\n+   SIGCONT    : constant := 26; --  stopped process has been continued\n+   SIGTTIN    : constant := 27; --  background tty read attempted\n+   SIGTTOU    : constant := 28; --  background tty write attempted\n+   SIGURG     : constant := 29; --  urgent condition on IO channel\n+   SIGLOST    : constant := 30; --  remote lock lost  (NFS)\n+   SIGDIL     : constant := 32; --  DIL signal\n+   SIGXCPU    : constant := 33; --  CPU time limit exceeded (setrlimit)\n+   SIGXFSZ    : constant := 34; --  file size limit exceeded (setrlimit)\n+\n+   SIGADAABORT : constant := SIGABRT;\n+   --  Note: on other targets, we usually use SIGABRT, but on HP/UX, it\n+   --  appears that SIGABRT can't be used in sigwait(), so we use SIGTERM.\n+\n+   type Signal_Set is array (Natural range <>) of Signal;\n+\n+   Unmasked    : constant Signal_Set :=\n+     (SIGBUS, SIGTRAP, SIGTTIN, SIGTTOU, SIGTSTP);\n+\n+   Reserved    : constant Signal_Set := (SIGKILL, SIGSTOP);\n+\n+   type sigset_t is private;\n+\n+   type isr_address is access procedure (sig : int);\n+\n+   function intr_attach (sig : int; handler : isr_address) return long;\n+\n+   Intr_Attach_Reset : constant Boolean := True;\n+   --  True if intr_attach is reset after an interrupt handler is called\n+\n+   function sigaddset (set : access sigset_t; sig : Signal) return int;\n+   pragma Import (C, sigaddset, \"sigaddset\");\n+\n+   function sigdelset (set : access sigset_t; sig : Signal) return int;\n+   pragma Import (C, sigdelset, \"sigdelset\");\n+\n+   function sigfillset (set : access sigset_t) return int;\n+   pragma Import (C, sigfillset, \"sigfillset\");\n+\n+   function sigismember (set : access sigset_t; sig : Signal) return int;\n+   pragma Import (C, sigismember, \"sigismember\");\n+\n+   function sigemptyset (set : access sigset_t) return int;\n+   pragma Import (C, sigemptyset, \"sigemptyset\");\n+\n+   type Signal_Handler is access procedure (signo : Signal);\n+\n+   type struct_sigaction is record\n+      sa_handler : System.Address;\n+      sa_mask    : sigset_t;\n+      sa_flags   : int;\n+   end record;\n+   pragma Convention (C, struct_sigaction);\n+   type struct_sigaction_ptr is access all struct_sigaction;\n+\n+   SA_RESTART  : constant  := 16#40#;\n+\n+   SIG_BLOCK   : constant  := 0;\n+   SIG_UNBLOCK : constant  := 1;\n+   SIG_SETMASK : constant  := 2;\n+\n+   SIG_DFL : constant := 0;\n+   SIG_IGN : constant := 1;\n+   SIG_ERR : constant := -1;\n+\n+   function sigaction\n+     (sig  : Signal;\n+      act  : struct_sigaction_ptr;\n+      oact : struct_sigaction_ptr) return int;\n+   pragma Import (C, sigaction, \"sigaction\");\n+\n+   ----------\n+   -- Time --\n+   ----------\n+\n+   type timespec is private;\n+\n+   function nanosleep (rqtp, rmtp : access timespec) return int;\n+   pragma Import (C, nanosleep);\n+\n+   type clockid_t is private;\n+\n+   CLOCK_REALTIME : constant clockid_t;\n+\n+   function Clock_Gettime\n+     (Clock_Id : clockid_t; Tp : access timespec) return int;\n+   pragma Import (C, Clock_Gettime);\n+\n+   function To_Duration (TS : timespec) return Duration;\n+   pragma Inline (To_Duration);\n+\n+   function To_Timespec (D : Duration) return timespec;\n+   pragma Inline (To_Timespec);\n+\n+   type struct_timeval is private;\n+\n+   function To_Duration (TV : struct_timeval) return Duration;\n+   pragma Inline (To_Duration);\n+\n+   function To_Timeval (D : Duration) return struct_timeval;\n+   pragma Inline (To_Timeval);\n+\n+   -------------------------\n+   -- Priority Scheduling --\n+   -------------------------\n+\n+   SCHED_FIFO  : constant := 0;\n+   SCHED_RR    : constant := 1;\n+   SCHED_OTHER : constant := 2;\n+\n+   -------------\n+   -- Process --\n+   -------------\n+\n+   type pid_t is private;\n+\n+   function kill (pid : pid_t; sig : Signal) return int;\n+   pragma Import (C, kill, \"kill\");\n+\n+   function getpid return pid_t;\n+   pragma Import (C, getpid, \"getpid\");\n+\n+   -------------\n+   -- Threads --\n+   -------------\n+\n+   type Thread_Body is access\n+     function (arg : System.Address) return System.Address;\n+   type pthread_t           is private;\n+   subtype Thread_Id        is pthread_t;\n+\n+   type pthread_mutex_t     is limited private;\n+   type pthread_cond_t      is limited private;\n+   type pthread_attr_t      is limited private;\n+   type pthread_mutexattr_t is limited private;\n+   type pthread_condattr_t  is limited private;\n+   type pthread_key_t       is private;\n+\n+   -----------\n+   -- Stack --\n+   -----------\n+\n+   function Get_Stack_Base (thread : pthread_t) return Address;\n+   pragma Inline (Get_Stack_Base);\n+   --  This is a dummy procedure to share some GNULLI files\n+\n+   ---------------------------------------\n+   -- Nonstandard Thread Initialization --\n+   ---------------------------------------\n+\n+   procedure pthread_init;\n+   pragma Inline (pthread_init);\n+   --  This is a dummy procedure to share some GNULLI files\n+\n+   -------------------------\n+   -- POSIX.1c  Section 3 --\n+   -------------------------\n+\n+   function sigwait (set : access sigset_t) return int;\n+   pragma Import (C, sigwait, \"cma_sigwait\");\n+\n+   function sigwait\n+     (set : access sigset_t;\n+      sig : access Signal) return int;\n+   pragma Inline (sigwait);\n+   --  DCE_THREADS has a nonstandard sigwait\n+\n+   function pthread_kill\n+     (thread : pthread_t;\n+      sig    : Signal) return int;\n+   pragma Inline (pthread_kill);\n+   --  DCE_THREADS doesn't have pthread_kill\n+\n+   type sigset_t_ptr is access all sigset_t;\n+\n+   function pthread_sigmask\n+     (how  : int;\n+      set  : sigset_t_ptr;\n+      oset : sigset_t_ptr) return int;\n+   --  DCE THREADS does not have pthread_sigmask. Instead, it uses\n+   --  sigprocmask to do the signal handling when the thread library is\n+   --  sucked in.\n+   pragma Import (C, pthread_sigmask, \"sigprocmask\");\n+\n+   --------------------------\n+   -- POSIX.1c  Section 11 --\n+   --------------------------\n+\n+   function pthread_mutexattr_init\n+     (attr : access pthread_mutexattr_t) return int;\n+   --  DCE_THREADS has a nonstandard pthread_mutexattr_init.\n+\n+   function pthread_mutexattr_destroy\n+     (attr : access pthread_mutexattr_t) return int;\n+   --  DCE_THREADS has a nonstandard pthread_mutexattr_destroy\n+\n+   function pthread_mutex_init\n+     (mutex : access pthread_mutex_t;\n+      attr  : access pthread_mutexattr_t) return int;\n+   --  DCE_THREADS has a nonstandard pthread_mutex_init\n+\n+   function pthread_mutex_destroy (mutex : access pthread_mutex_t) return int;\n+   --  DCE_THREADS has a nonstandard pthread_mutex_destroy\n+\n+   function pthread_mutex_lock (mutex : access pthread_mutex_t) return int;\n+   pragma Inline (pthread_mutex_lock);\n+   --  DCE_THREADS has nonstandard pthread_mutex_lock\n+\n+   function pthread_mutex_unlock (mutex : access pthread_mutex_t) return int;\n+   pragma Inline (pthread_mutex_unlock);\n+   --  DCE_THREADS has nonstandard pthread_mutex_lock\n+\n+   function pthread_condattr_init\n+     (attr : access pthread_condattr_t) return int;\n+   --  DCE_THREADS has nonstandard pthread_condattr_init\n+\n+   function pthread_condattr_destroy\n+     (attr : access pthread_condattr_t) return int;\n+   --  DCE_THREADS has nonstandard pthread_condattr_destroy\n+\n+   function pthread_cond_init\n+     (cond : access pthread_cond_t;\n+      attr : access pthread_condattr_t) return int;\n+   --  DCE_THREADS has nonstandard pthread_cond_init\n+\n+   function pthread_cond_destroy (cond : access pthread_cond_t) return int;\n+   --  DCE_THREADS has nonstandard pthread_cond_destroy\n+\n+   function pthread_cond_signal (cond : access pthread_cond_t) return int;\n+   pragma Inline (pthread_cond_signal);\n+   --  DCE_THREADS has nonstandard pthread_cond_signal\n+\n+   function pthread_cond_wait\n+     (cond  : access pthread_cond_t;\n+      mutex : access pthread_mutex_t) return int;\n+   pragma Inline (pthread_cond_wait);\n+   --  DCE_THREADS has a nonstandard pthread_cond_wait\n+\n+   function pthread_cond_timedwait\n+     (cond    : access pthread_cond_t;\n+      mutex   : access pthread_mutex_t;\n+      abstime : access timespec) return int;\n+   pragma Inline (pthread_cond_timedwait);\n+   --  DCE_THREADS has a nonstandard pthread_cond_timedwait\n+\n+   --------------------------\n+   -- POSIX.1c  Section 13 --\n+   --------------------------\n+\n+   type struct_sched_param is record\n+      sched_priority : int;  --  scheduling priority\n+   end record;\n+\n+   function pthread_setschedparam\n+     (thread : pthread_t;\n+      policy : int;\n+      param  : access struct_sched_param) return int;\n+   pragma Inline (pthread_setschedparam);\n+   --  DCE_THREADS has a nonstandard pthread_setschedparam\n+\n+   function sched_yield return int;\n+   pragma Inline (sched_yield);\n+   --  DCE_THREADS has a nonstandard sched_yield\n+\n+   ---------------------------\n+   -- P1003.1c - Section 16 --\n+   ---------------------------\n+\n+   function pthread_attr_init (attributes : access pthread_attr_t) return int;\n+   pragma Inline (pthread_attr_init);\n+   --  DCE_THREADS has a nonstandard pthread_attr_init\n+\n+   function pthread_attr_destroy\n+     (attributes : access pthread_attr_t) return int;\n+   pragma Inline (pthread_attr_destroy);\n+   --  DCE_THREADS has a nonstandard pthread_attr_destroy\n+\n+   function pthread_attr_setstacksize\n+     (attr      : access pthread_attr_t;\n+      stacksize : size_t) return int;\n+   pragma Inline (pthread_attr_setstacksize);\n+   --  DCE_THREADS has a nonstandard pthread_attr_setstacksize\n+\n+   function pthread_create\n+     (thread        : access pthread_t;\n+      attributes    : access pthread_attr_t;\n+      start_routine : Thread_Body;\n+      arg           : System.Address) return int;\n+   pragma Inline (pthread_create);\n+   --  DCE_THREADS has a nonstandard pthread_create\n+\n+   procedure pthread_detach (thread : access pthread_t);\n+   pragma Import (C, pthread_detach);\n+\n+   procedure pthread_exit (status : System.Address);\n+   pragma Import (C, pthread_exit, \"pthread_exit\");\n+\n+   function pthread_self return pthread_t;\n+   pragma Import (C, pthread_self, \"pthread_self\");\n+\n+   --------------------------\n+   -- POSIX.1c  Section 17 --\n+   --------------------------\n+\n+   function pthread_setspecific\n+     (key   : pthread_key_t;\n+      value : System.Address) return int;\n+   pragma Inline (pthread_setspecific);\n+   --  DCE_THREADS has a nonstandard pthread_setspecific\n+\n+   function pthread_getspecific (key : pthread_key_t) return System.Address;\n+   pragma Inline (pthread_getspecific);\n+   --  DCE_THREADS has a nonstandard pthread_getspecific\n+\n+   type destructor_pointer is access procedure (arg : System.Address);\n+\n+   function pthread_key_create\n+     (key        : access pthread_key_t;\n+      destructor : destructor_pointer) return int;\n+   pragma Inline (pthread_key_create);\n+   --  DCE_THREADS has a nonstandard pthread_key_create\n+\n+private\n+\n+   type array_type_1 is array (Integer range 0 .. 7) of unsigned_long;\n+   type sigset_t is record\n+      X_X_sigbits : array_type_1;\n+   end record;\n+   pragma Convention (C, sigset_t);\n+\n+   type pid_t is new int;\n+\n+   type time_t is new long;\n+\n+   type timespec is record\n+      tv_sec  : time_t;\n+      tv_nsec : long;\n+   end record;\n+   pragma Convention (C, timespec);\n+\n+   type clockid_t is new int;\n+   CLOCK_REALTIME : constant clockid_t := 1;\n+\n+   type struct_timeval is record\n+      tv_sec  : time_t;\n+      tv_usec : time_t;\n+   end record;\n+   pragma Convention (C, struct_timeval);\n+\n+   type cma_t_address is new System.Address;\n+\n+   type cma_t_handle is record\n+      field1 : cma_t_address;\n+      field2 : Short_Integer;\n+      field3 : Short_Integer;\n+   end record;\n+   for cma_t_handle'Size use 64;\n+\n+   type pthread_attr_t is new cma_t_handle;\n+   pragma Convention (C_Pass_By_Copy, pthread_attr_t);\n+\n+   type pthread_condattr_t is new cma_t_handle;\n+   pragma Convention (C_Pass_By_Copy, pthread_condattr_t);\n+\n+   type pthread_mutexattr_t is new cma_t_handle;\n+   pragma Convention (C_Pass_By_Copy, pthread_mutexattr_t);\n+\n+   type pthread_t is new cma_t_handle;\n+   pragma Convention (C_Pass_By_Copy, pthread_t);\n+\n+   type pthread_mutex_t is new cma_t_handle;\n+   pragma Convention (C_Pass_By_Copy, pthread_mutex_t);\n+\n+   type pthread_cond_t is new cma_t_handle;\n+   pragma Convention (C_Pass_By_Copy, pthread_cond_t);\n+\n+   type pthread_key_t is new int;\n+\n+end System.OS_Interface;"}, {"sha": "cdce2ba334d1ffb2ad31108cdadff3a07fe59cd4", "filename": "gcc/ada/5hparame.ads", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5hparame.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5hparame.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5hparame.ads?ref=84481f762f0682e5f45b2f360446e1c7e333c880", "patch": "@@ -0,0 +1,135 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                    S Y S T E M . P A R A M E T E R S                     --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                            $Revision: 1.5 $\n+--                                                                          --\n+--          Copyright (C) 1992-2000 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is the HP version of this package\n+\n+--  This package defines some system dependent parameters for GNAT. These\n+--  are values that are referenced by the runtime library and are therefore\n+--  relevant to the target machine.\n+\n+--  The parameters whose value is defined in the spec are not generally\n+--  expected to be changed. If they are changed, it will be necessary to\n+--  recompile the run-time library.\n+\n+--  The parameters which are defined by functions can be changed by modifying\n+--  the body of System.Parameters in file s-parame.adb. A change to this body\n+--  requires only rebinding and relinking of the application.\n+\n+--  Note: do not introduce any pragma Inline statements into this unit, since\n+--  otherwise the relinking and rebinding capability would be deactivated.\n+\n+package System.Parameters is\n+pragma Pure (Parameters);\n+\n+   ---------------------------------------\n+   -- Task And Stack Allocation Control --\n+   ---------------------------------------\n+\n+   type Task_Storage_Size is new Integer;\n+   --  Type used in tasking units for task storage size\n+\n+   type Size_Type is new Task_Storage_Size;\n+   --  Type used to provide task storage size to runtime\n+\n+   Unspecified_Size : constant Size_Type := Size_Type'First;\n+   --  Value used to indicate that no size type is set\n+\n+   subtype Ratio is Size_Type range -1 .. 100;\n+   Dynamic : constant Size_Type := -1;\n+   --  The secondary stack ratio is a constant between 0 and 100 which\n+   --  determines the percentage of the allocated task stack that is\n+   --  used by the secondary stack (the rest being the primary stack).\n+   --  The special value of minus one indicates that the secondary\n+   --  stack is to be allocated from the heap instead.\n+\n+   Sec_Stack_Ratio : constant Ratio := Dynamic;\n+   --  This constant defines the handling of the secondary stack\n+\n+   Sec_Stack_Dynamic : constant Boolean := Sec_Stack_Ratio = Dynamic;\n+   --  Convenient Boolean for testing for dynamic secondary stack\n+\n+   function Default_Stack_Size return Size_Type;\n+   --  Default task stack size used if none is specified\n+\n+   function Minimum_Stack_Size return Size_Type;\n+   --  Minimum task stack size permitted\n+\n+   function Adjust_Storage_Size (Size : Size_Type) return Size_Type;\n+   --  Given the storage size stored in the TCB, return the Storage_Size\n+   --  value required by the RM for the Storage_Size attribute. The\n+   --  required adjustment is as follows:\n+   --\n+   --    when Size = Unspecified_Size, return Default_Stack_Size\n+   --    when Size < Minimum_Stack_Size, return Minimum_Stack_Size\n+   --    otherwise return given Size\n+\n+   Stack_Grows_Down  : constant Boolean := False;\n+   --  This constant indicates whether the stack grows up (False) or\n+   --  down (True) in memory as functions are called. It is used for\n+   --  proper implementation of the stack overflow check.\n+\n+   ----------------------------------------------\n+   -- Characteristics of types in Interfaces.C --\n+   ----------------------------------------------\n+\n+   long_bits : constant := Long_Integer'Size;\n+   --  Number of bits in type long and unsigned_long. The normal convention\n+   --  is that this is the same as type Long_Integer, but this is not true\n+   --  of all targets. For example, in OpenVMS long /= Long_Integer.\n+\n+   ----------------------------------------------\n+   -- Behavior of Pragma Finalize_Storage_Only --\n+   ----------------------------------------------\n+\n+   --  Garbage_Collected is a Boolean constant whose value indicates the\n+   --  effect of the pragma Finalize_Storage_Entry on a controlled type.\n+\n+   --    Garbage_Collected = False\n+\n+   --      The system releases all storage on program termination only,\n+   --      but not other garbage collection occurs, so finalization calls\n+   --      are ommitted only for outer level onjects can be omitted if\n+   --      pragma Finalize_Storage_Only is used.\n+\n+   --    Garbage_Collected = True\n+\n+   --      The system provides full garbage collection, so it is never\n+   --      necessary to release storage for controlled objects for which\n+   --      a pragma Finalize_Storage_Only is used.\n+\n+   Garbage_Collected : constant Boolean := False;\n+   --  The storage mode for this system (release on program exit)\n+\n+end System.Parameters;"}, {"sha": "fef7ae9f3f3089604ca168f6b88b443ef2beec0c", "filename": "gcc/ada/5hsystem.ads", "status": "added", "additions": 226, "deletions": 0, "changes": 226, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5hsystem.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5hsystem.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5hsystem.ads?ref=84481f762f0682e5f45b2f360446e1c7e333c880", "patch": "@@ -0,0 +1,226 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                        GNAT RUN-TIME COMPONENTS                          --\n+--                                                                          --\n+--                               S Y S T E M                                --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                             (HP-UX Version)                              --\n+--                                                                          --\n+--                            $Revision: 1.15 $\n+--                                                                          --\n+--          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+package System is\n+pragma Pure (System);\n+--  Note that we take advantage of the implementation permission to\n+--  make this unit Pure instead of Preelaborable, see RM 13.7(36)\n+\n+   type Name is (SYSTEM_NAME_GNAT);\n+   System_Name : constant Name := SYSTEM_NAME_GNAT;\n+\n+   --  System-Dependent Named Numbers\n+\n+   Min_Int               : constant := Long_Long_Integer'First;\n+   Max_Int               : constant := Long_Long_Integer'Last;\n+\n+   Max_Binary_Modulus    : constant := 2 ** Long_Long_Integer'Size;\n+   Max_Nonbinary_Modulus : constant := Integer'Last;\n+\n+   Max_Base_Digits       : constant := Long_Long_Float'Digits;\n+   Max_Digits            : constant := Long_Long_Float'Digits;\n+\n+   Max_Mantissa          : constant := 63;\n+   Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);\n+\n+   Tick                  : constant := Standard'Tick;\n+\n+   --  Storage-related Declarations\n+\n+   type Address is private;\n+   Null_Address : constant Address;\n+\n+   Storage_Unit : constant := Standard'Storage_Unit;\n+   Word_Size    : constant := Standard'Word_Size;\n+   Memory_Size  : constant := 2 ** Standard'Address_Size;\n+\n+   --  Address comparison\n+\n+   function \"<\"  (Left, Right : Address) return Boolean;\n+   function \"<=\" (Left, Right : Address) return Boolean;\n+   function \">\"  (Left, Right : Address) return Boolean;\n+   function \">=\" (Left, Right : Address) return Boolean;\n+   function \"=\"  (Left, Right : Address) return Boolean;\n+\n+   pragma Import (Intrinsic, \"<\");\n+   pragma Import (Intrinsic, \"<=\");\n+   pragma Import (Intrinsic, \">\");\n+   pragma Import (Intrinsic, \">=\");\n+   pragma Import (Intrinsic, \"=\");\n+\n+   --  Other System-Dependent Declarations\n+\n+   type Bit_Order is (High_Order_First, Low_Order_First);\n+   Default_Bit_Order : constant Bit_Order := High_Order_First;\n+\n+   --  Priority-related Declarations (RM D.1)\n+\n+   Max_Priority : constant Positive := 30;\n+\n+   Max_Interrupt_Priority : constant Positive := 31;\n+\n+   subtype Any_Priority is Integer\n+     range 0 .. Standard'Max_Interrupt_Priority;\n+\n+   subtype Priority is Any_Priority\n+     range 0 .. Standard'Max_Priority;\n+\n+   --  Functional notation is needed in the following to avoid visibility\n+   --  problems when this package is compiled through rtsfind in the middle\n+   --  of another compilation.\n+\n+   subtype Interrupt_Priority is Any_Priority\n+     range\n+       Standard.\"+\" (Standard'Max_Priority,  1) ..\n+         Standard'Max_Interrupt_Priority;\n+\n+   Default_Priority : constant Priority :=\n+     Standard.\"/\" (Standard.\"+\" (Priority'First, Priority'Last), 2);\n+\n+private\n+\n+   type Address is mod Memory_Size;\n+   Null_Address : constant Address := 0;\n+\n+   --------------------------------------\n+   -- System Implementation Parameters --\n+   --------------------------------------\n+\n+   --  These parameters provide information about the target that is used\n+   --  by the compiler. They are in the private part of System, where they\n+   --  can be accessed using the special circuitry in the Targparm unit\n+   --  whose source should be consulted for more detailed descriptions\n+   --  of the individual switch values.\n+\n+   AAMP                      : constant Boolean := False;\n+   Command_Line_Args         : constant Boolean := True;\n+   Denorm                    : constant Boolean := False;\n+   Frontend_Layout           : constant Boolean := False;\n+   Functions_Return_By_DSP   : constant Boolean := False;\n+   Long_Shifts_Inlined       : constant Boolean := False;\n+   High_Integrity_Mode       : constant Boolean := False;\n+   Machine_Overflows         : constant Boolean := False;\n+   Machine_Rounds            : constant Boolean := True;\n+   OpenVMS                   : constant Boolean := False;\n+   Signed_Zeros              : constant Boolean := False;\n+   Stack_Check_Default       : constant Boolean := False;\n+   Stack_Check_Probes        : constant Boolean := False;\n+   Use_Ada_Main_Program_Name : constant Boolean := False;\n+   ZCX_By_Default            : constant Boolean := False;\n+   GCC_ZCX_Support           : constant Boolean := False;\n+   Front_End_ZCX_Support     : constant Boolean := False;\n+\n+   --------------------------\n+   -- Underlying Priorities --\n+   ---------------------------\n+\n+   --  Important note: this section of the file must come AFTER the\n+   --  definition of the system implementation parameters to ensure\n+   --  that the value of these parameters is available for analysis\n+   --  of the declarations here (using Rtsfind at compile time).\n+\n+   --  The underlying priorities table provides a generalized mechanism\n+   --  for mapping from Ada priorities to system priorities. In some\n+   --  cases a 1-1 mapping is not the convenient or optimal choice.\n+\n+   --  For HP/UX DCE Threads, we use the full range of 31 priorities\n+   --  in the Ada model, but map them by compression onto the more limited\n+   --  range of priorities available in HP/UX.\n+   --  For POSIX Threads, this table is ignored.\n+\n+   --  To replace the default values of the Underlying_Priorities mapping,\n+   --  copy this source file into your build directory, edit the file to\n+   --  reflect your desired behavior, and recompile with the command:\n+\n+   --     $ gcc -c -O2 -gnatpgn system.ads\n+\n+   --  then recompile the run-time parts that depend on this package:\n+\n+   --     $ gnatmake -a -gnatn -O2 <your application>\n+\n+   --  then force rebuilding your application if you need different options:\n+\n+   --     $ gnatmake -f <your options> <your application>\n+\n+   type Priorities_Mapping is array (Any_Priority) of Integer;\n+   pragma Suppress_Initialization (Priorities_Mapping);\n+   --  Suppress initialization in case gnat.adc specifies Normalize_Scalars\n+\n+   Underlying_Priorities : constant Priorities_Mapping :=\n+\n+     (Priority'First => 16,\n+\n+      1  => 17,\n+      2  => 18,\n+      3  => 18,\n+      4  => 18,\n+      5  => 18,\n+      6  => 19,\n+      7  => 19,\n+      8  => 19,\n+      9  => 20,\n+      10 => 20,\n+      11 => 21,\n+      12 => 21,\n+      13 => 22,\n+      14 => 23,\n+\n+      Default_Priority   => 24,\n+\n+      16 => 25,\n+      17 => 25,\n+      18 => 25,\n+      19 => 26,\n+      20 => 26,\n+      21 => 26,\n+      22 => 27,\n+      23 => 27,\n+      24 => 27,\n+      25 => 28,\n+      26 => 28,\n+      27 => 29,\n+      28 => 29,\n+      29 => 30,\n+\n+      Priority'Last      => 30,\n+\n+      Interrupt_Priority => 31);\n+\n+end System;"}, {"sha": "95e5c3cec11ff1b51986032c8b0d7d296b94f82b", "filename": "gcc/ada/5htaprop.adb", "status": "added", "additions": 1002, "deletions": 0, "changes": 1002, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5htaprop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5htaprop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5htaprop.adb?ref=84481f762f0682e5f45b2f360446e1c7e333c880", "patch": "@@ -0,0 +1,1002 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS               --\n+--                                                                          --\n+--     S Y S T E M . T A S K _ P R I M I T I V E S . O P E R A T I O N S    --\n+--                                                                          --\n+--                                  B o d y                                 --\n+--                                                                          --\n+--                             $Revision: 1.42 $\n+--                                                                          --\n+--             Copyright (C) 1991-2001, Florida State University            --\n+--                                                                          --\n+-- GNARL is free software; you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion. GNARL is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNARL; see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNARL was developed by the GNARL team at Florida State University. It is --\n+-- now maintained by Ada Core Technologies Inc. in cooperation with Florida --\n+-- State University (http://www.gnat.com).                                  --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is a HP-UX version of this package\n+\n+--  This package contains all the GNULL primitives that interface directly\n+--  with the underlying OS.\n+\n+pragma Polling (Off);\n+--  Turn off polling, we do not want ATC polling to take place during\n+--  tasking operations. It causes infinite loops and other problems.\n+\n+with System.Tasking.Debug;\n+--  used for Known_Tasks\n+\n+with Interfaces.C;\n+--  used for int\n+--           size_t\n+\n+with System.Interrupt_Management;\n+--  used for Keep_Unmasked\n+--           Abort_Task_Interrupt\n+--           Interrupt_ID\n+\n+with System.Interrupt_Management.Operations;\n+--  used for Set_Interrupt_Mask\n+--           All_Tasks_Mask\n+pragma Elaborate_All (System.Interrupt_Management.Operations);\n+\n+with System.Parameters;\n+--  used for Size_Type\n+\n+with System.Task_Primitives.Interrupt_Operations;\n+--  used for Get_Interrupt_ID\n+\n+with System.Tasking;\n+--  used for Ada_Task_Control_Block\n+--           Task_ID\n+\n+with System.Soft_Links;\n+--  used for Defer/Undefer_Abort\n+\n+--  Note that we do not use System.Tasking.Initialization directly since\n+--  this is a higher level package that we shouldn't depend on. For example\n+--  when using the restricted run time, it is replaced by\n+--  System.Tasking.Restricted.Initialization\n+\n+with System.OS_Primitives;\n+--  used for Delay_Modes\n+\n+with Unchecked_Conversion;\n+with Unchecked_Deallocation;\n+\n+package body System.Task_Primitives.Operations is\n+\n+   use System.Tasking.Debug;\n+   use System.Tasking;\n+   use Interfaces.C;\n+   use System.OS_Interface;\n+   use System.Parameters;\n+   use System.OS_Primitives;\n+\n+   package PIO renames System.Task_Primitives.Interrupt_Operations;\n+   package SSL renames System.Soft_Links;\n+\n+   ------------------\n+   --  Local Data  --\n+   ------------------\n+\n+   --  The followings are logically constants, but need to be initialized\n+   --  at run time.\n+\n+   ATCB_Key : aliased pthread_key_t;\n+   --  Key used to find the Ada Task_ID associated with a thread\n+\n+   All_Tasks_L : aliased System.Task_Primitives.RTS_Lock;\n+   --  See comments on locking rules in System.Tasking (spec).\n+\n+   Environment_Task_ID : Task_ID;\n+   --  A variable to hold Task_ID for the environment task.\n+\n+   Unblocked_Signal_Mask : aliased sigset_t;\n+   --  The set of signals that should unblocked in all tasks\n+\n+   Time_Slice_Val : Integer;\n+   pragma Import (C, Time_Slice_Val, \"__gl_time_slice_val\");\n+\n+   Locking_Policy : Character;\n+   pragma Import (C, Locking_Policy, \"__gl_locking_policy\");\n+\n+   Dispatching_Policy : Character;\n+   pragma Import (C, Dispatching_Policy, \"__gl_task_dispatching_policy\");\n+\n+   FIFO_Within_Priorities : constant Boolean := Dispatching_Policy = 'F';\n+   --  Indicates whether FIFO_Within_Priorities is set.\n+\n+   --  The followings are internal configuration constants needed.\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   procedure Abort_Handler (Sig : Signal);\n+\n+   function To_Task_ID is new Unchecked_Conversion (System.Address, Task_ID);\n+\n+   function To_Address is new Unchecked_Conversion (Task_ID, System.Address);\n+\n+   -------------------\n+   -- Abort_Handler --\n+   -------------------\n+\n+   --  Target-dependent binding of inter-thread Abort signal to\n+   --  the raising of the Abort_Signal exception.\n+\n+   --  The technical issues and alternatives here are essentially\n+   --  the same as for raising exceptions in response to other\n+   --  signals (e.g. Storage_Error).  See code and comments in\n+   --  the package body System.Interrupt_Management.\n+\n+   --  Some implementations may not allow an exception to be propagated\n+   --  out of a handler, and others might leave the signal or\n+   --  interrupt that invoked this handler masked after the exceptional\n+   --  return to the application code.\n+\n+   --  GNAT exceptions are originally implemented using setjmp()/longjmp().\n+   --  On most UNIX systems, this will allow transfer out of a signal handler,\n+   --  which is usually the only mechanism available for implementing\n+   --  asynchronous handlers of this kind.  However, some\n+   --  systems do not restore the signal mask on longjmp(), leaving the\n+   --  abort signal masked.\n+\n+   --  Alternative solutions include:\n+\n+   --       1. Change the PC saved in the system-dependent Context\n+   --          parameter to point to code that raises the exception.\n+   --          Normal return from this handler will then raise\n+   --          the exception after the mask and other system state has\n+   --          been restored (see example below).\n+   --       2. Use siglongjmp()/sigsetjmp() to implement exceptions.\n+   --       3. Unmask the signal in the Abortion_Signal exception handler\n+   --          (in the RTS).\n+\n+   --  The following procedure would be needed if we can't lonjmp out of\n+   --  a signal handler.  (See below.)\n+   --  procedure Raise_Abort_Signal is\n+   --  begin\n+   --     raise Standard'Abort_Signal;\n+   --  end if;\n+\n+   procedure Abort_Handler (Sig : Signal) is\n+      Self_Id : constant Task_ID := Self;\n+      Result  : Interfaces.C.int;\n+      Old_Set : aliased sigset_t;\n+\n+   begin\n+      --  Assuming it is safe to longjmp out of a signal handler, the\n+      --  following code can be used:\n+\n+      if Self_Id.Deferral_Level = 0\n+        and then Self_Id.Pending_ATC_Level < Self_Id.ATC_Nesting_Level and then\n+        not Self_Id.Aborting\n+      then\n+         Self_Id.Aborting := True;\n+\n+         --  Make sure signals used for RTS internal purpose are unmasked\n+\n+         Result := pthread_sigmask (SIG_UNBLOCK,\n+           Unblocked_Signal_Mask'Unchecked_Access, Old_Set'Unchecked_Access);\n+         pragma Assert (Result = 0);\n+\n+         raise Standard'Abort_Signal;\n+      end if;\n+\n+      --  Otherwise, something like this is required:\n+      --  if not Abort_Is_Deferred.all then\n+      --    --  Overwrite the return PC address with the address of the\n+      --    --  special raise routine, and \"return\" to that routine's\n+      --    --  starting address.\n+      --    Context.PC := Raise_Abort_Signal'Address;\n+      --    return;\n+      --  end if;\n+   end Abort_Handler;\n+\n+   -----------------\n+   -- Stack_Guard --\n+   -----------------\n+\n+   --  The underlying thread system sets a guard page at the\n+   --  bottom of a thread stack, so nothing is needed.\n+   --  ??? Check the comment above\n+\n+   procedure Stack_Guard (T : ST.Task_ID; On : Boolean) is\n+   begin\n+      null;\n+   end Stack_Guard;\n+\n+   -------------------\n+   -- Get_Thread_Id --\n+   -------------------\n+\n+   function Get_Thread_Id (T : ST.Task_ID) return OSI.Thread_Id is\n+   begin\n+      return T.Common.LL.Thread;\n+   end Get_Thread_Id;\n+\n+   ----------\n+   -- Self --\n+   ----------\n+\n+   function Self return Task_ID is\n+      Result : System.Address;\n+\n+   begin\n+      Result := pthread_getspecific (ATCB_Key);\n+      pragma Assert (Result /= System.Null_Address);\n+      return To_Task_ID (Result);\n+   end Self;\n+\n+   ---------------------\n+   -- Initialize_Lock --\n+   ---------------------\n+\n+   --  Note: mutexes and cond_variables needed per-task basis are\n+   --        initialized in Intialize_TCB and the Storage_Error is\n+   --        handled. Other mutexes (such as All_Tasks_Lock, Memory_Lock...)\n+   --        used in RTS is initialized before any status change of RTS.\n+   --        Therefore rasing Storage_Error in the following routines\n+   --        should be able to be handled safely.\n+\n+   procedure Initialize_Lock\n+     (Prio : System.Any_Priority;\n+      L    : access Lock)\n+   is\n+      Attributes : aliased pthread_mutexattr_t;\n+      Result : Interfaces.C.int;\n+   begin\n+      Result := pthread_mutexattr_init (Attributes'Access);\n+      pragma Assert (Result = 0 or else Result = ENOMEM);\n+\n+      if Result = ENOMEM then\n+         raise Storage_Error;\n+      end if;\n+\n+      L.Priority := Prio;\n+\n+      Result := pthread_mutex_init (L.L'Access, Attributes'Access);\n+      pragma Assert (Result = 0 or else Result = ENOMEM);\n+\n+      if Result = ENOMEM then\n+         raise Storage_Error;\n+      end if;\n+\n+      Result := pthread_mutexattr_destroy (Attributes'Access);\n+      pragma Assert (Result = 0);\n+   end Initialize_Lock;\n+\n+   procedure Initialize_Lock (L : access RTS_Lock; Level : Lock_Level) is\n+      Attributes : aliased pthread_mutexattr_t;\n+      Result : Interfaces.C.int;\n+\n+   begin\n+      Result := pthread_mutexattr_init (Attributes'Access);\n+      pragma Assert (Result = 0 or else Result = ENOMEM);\n+\n+      if Result = ENOMEM then\n+         raise Storage_Error;\n+      end if;\n+\n+      Result := pthread_mutex_init (L, Attributes'Access);\n+\n+      pragma Assert (Result = 0 or else Result = ENOMEM);\n+\n+      if Result = ENOMEM then\n+         raise Storage_Error;\n+      end if;\n+\n+      Result := pthread_mutexattr_destroy (Attributes'Access);\n+      pragma Assert (Result = 0);\n+   end Initialize_Lock;\n+\n+   -------------------\n+   -- Finalize_Lock --\n+   -------------------\n+\n+   procedure Finalize_Lock (L : access Lock) is\n+      Result : Interfaces.C.int;\n+\n+   begin\n+      Result := pthread_mutex_destroy (L.L'Access);\n+      pragma Assert (Result = 0);\n+   end Finalize_Lock;\n+\n+   procedure Finalize_Lock (L : access RTS_Lock) is\n+      Result : Interfaces.C.int;\n+\n+   begin\n+      Result := pthread_mutex_destroy (L);\n+      pragma Assert (Result = 0);\n+   end Finalize_Lock;\n+\n+   ----------------\n+   -- Write_Lock --\n+   ----------------\n+\n+   procedure Write_Lock (L : access Lock; Ceiling_Violation : out Boolean) is\n+      Result    : Interfaces.C.int;\n+\n+   begin\n+      L.Owner_Priority := Get_Priority (Self);\n+\n+      if L.Priority < L.Owner_Priority then\n+         Ceiling_Violation := True;\n+         return;\n+      end if;\n+\n+      Result := pthread_mutex_lock (L.L'Access);\n+      pragma Assert (Result = 0);\n+      Ceiling_Violation := False;\n+   end Write_Lock;\n+\n+   procedure Write_Lock (L : access RTS_Lock) is\n+      Result : Interfaces.C.int;\n+\n+   begin\n+      Result := pthread_mutex_lock (L);\n+      pragma Assert (Result = 0);\n+   end Write_Lock;\n+\n+   procedure Write_Lock (T : Task_ID) is\n+      Result : Interfaces.C.int;\n+\n+   begin\n+      Result := pthread_mutex_lock (T.Common.LL.L'Access);\n+      pragma Assert (Result = 0);\n+   end Write_Lock;\n+\n+   ---------------\n+   -- Read_Lock --\n+   ---------------\n+\n+   procedure Read_Lock (L : access Lock; Ceiling_Violation : out Boolean) is\n+   begin\n+      Write_Lock (L, Ceiling_Violation);\n+   end Read_Lock;\n+\n+   ------------\n+   -- Unlock --\n+   ------------\n+\n+   procedure Unlock (L : access Lock) is\n+      Result    : Interfaces.C.int;\n+\n+   begin\n+      Result := pthread_mutex_unlock (L.L'Access);\n+      pragma Assert (Result = 0);\n+   end Unlock;\n+\n+   procedure Unlock (L : access RTS_Lock) is\n+      Result : Interfaces.C.int;\n+\n+   begin\n+      Result := pthread_mutex_unlock (L);\n+      pragma Assert (Result = 0);\n+   end Unlock;\n+\n+   procedure Unlock (T : Task_ID) is\n+      Result : Interfaces.C.int;\n+\n+   begin\n+      Result := pthread_mutex_unlock (T.Common.LL.L'Access);\n+      pragma Assert (Result = 0);\n+   end Unlock;\n+\n+   -------------\n+   --  Sleep  --\n+   -------------\n+\n+   procedure Sleep (Self_ID : Task_ID;\n+                    Reason   : System.Tasking.Task_States) is\n+      Result : Interfaces.C.int;\n+\n+   begin\n+      pragma Assert (Self_ID = Self);\n+      Result := pthread_cond_wait (Self_ID.Common.LL.CV'Access,\n+        Self_ID.Common.LL.L'Access);\n+      --  EINTR is not considered a failure.\n+      pragma Assert (Result = 0 or else Result = EINTR);\n+   end Sleep;\n+\n+   -----------------\n+   -- Timed_Sleep --\n+   -----------------\n+\n+   --  This is for use within the run-time system, so abort is\n+   --  assumed to be already deferred, and the caller should be\n+   --  holding its own ATCB lock.\n+\n+   procedure Timed_Sleep\n+     (Self_ID  : Task_ID;\n+      Time     : Duration;\n+      Mode     : ST.Delay_Modes;\n+      Reason   : System.Tasking.Task_States;\n+      Timedout : out Boolean;\n+      Yielded  : out Boolean)\n+   is\n+      Check_Time : constant Duration := Monotonic_Clock;\n+      Abs_Time   : Duration;\n+      Request    : aliased timespec;\n+      Result     : Interfaces.C.int;\n+   begin\n+      Timedout := True;\n+      Yielded := False;\n+\n+      if Mode = Relative then\n+         Abs_Time := Duration'Min (Time, Max_Sensible_Delay) + Check_Time;\n+      else\n+         Abs_Time := Duration'Min (Check_Time + Max_Sensible_Delay, Time);\n+      end if;\n+\n+      if Abs_Time > Check_Time then\n+         Request := To_Timespec (Abs_Time);\n+\n+         loop\n+            exit when Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level\n+              or else Self_ID.Pending_Priority_Change;\n+\n+            Result := pthread_cond_timedwait\n+              (Self_ID.Common.LL.CV'Access, Self_ID.Common.LL.L'Access,\n+               Request'Access);\n+\n+            exit when Abs_Time <= Monotonic_Clock;\n+\n+            if Result = 0 or Result = EINTR then\n+               --  somebody may have called Wakeup for us\n+               Timedout := False;\n+               exit;\n+            end if;\n+\n+            pragma Assert (Result = ETIMEDOUT);\n+         end loop;\n+      end if;\n+   end Timed_Sleep;\n+\n+   -----------------\n+   -- Timed_Delay --\n+   -----------------\n+\n+   --  This is for use in implementing delay statements, so\n+   --  we assume the caller is abort-deferred but is holding\n+   --  no locks.\n+\n+   procedure Timed_Delay\n+     (Self_ID  : Task_ID;\n+      Time     : Duration;\n+      Mode     : ST.Delay_Modes)\n+   is\n+      Check_Time : constant Duration := Monotonic_Clock;\n+      Abs_Time   : Duration;\n+      Request    : aliased timespec;\n+      Result     : Interfaces.C.int;\n+   begin\n+\n+      --  Only the little window between deferring abort and\n+      --  locking Self_ID is the reason we need to\n+      --  check for pending abort and priority change below! :(\n+\n+      SSL.Abort_Defer.all;\n+      Write_Lock (Self_ID);\n+\n+      if Mode = Relative then\n+         Abs_Time := Time + Check_Time;\n+      else\n+         Abs_Time := Duration'Min (Check_Time + Max_Sensible_Delay, Time);\n+      end if;\n+\n+      if Abs_Time > Check_Time then\n+         Request := To_Timespec (Abs_Time);\n+         Self_ID.Common.State := Delay_Sleep;\n+\n+         loop\n+            if Self_ID.Pending_Priority_Change then\n+               Self_ID.Pending_Priority_Change := False;\n+               Self_ID.Common.Base_Priority := Self_ID.New_Base_Priority;\n+               Set_Priority (Self_ID, Self_ID.Common.Base_Priority);\n+            end if;\n+\n+            exit when Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level;\n+\n+            Result := pthread_cond_timedwait (Self_ID.Common.LL.CV'Access,\n+              Self_ID.Common.LL.L'Access, Request'Access);\n+\n+            exit when Abs_Time <= Monotonic_Clock;\n+\n+            pragma Assert (Result = 0 or else\n+              Result = ETIMEDOUT or else\n+              Result = EINTR);\n+         end loop;\n+\n+         Self_ID.Common.State := Runnable;\n+      end if;\n+\n+      Unlock (Self_ID);\n+      Result := sched_yield;\n+      SSL.Abort_Undefer.all;\n+   end Timed_Delay;\n+\n+   ---------------------\n+   -- Monotonic_Clock --\n+   ---------------------\n+\n+   function Monotonic_Clock return Duration is\n+      TS     : aliased timespec;\n+      Result : Interfaces.C.int;\n+\n+   begin\n+      Result := Clock_Gettime (CLOCK_REALTIME, TS'Unchecked_Access);\n+      pragma Assert (Result = 0);\n+      return To_Duration (TS);\n+   end Monotonic_Clock;\n+\n+   -------------------\n+   -- RT_Resolution --\n+   -------------------\n+\n+   function RT_Resolution return Duration is\n+   begin\n+      return 10#1.0#E-6;\n+   end RT_Resolution;\n+\n+   ------------\n+   -- Wakeup --\n+   ------------\n+\n+   procedure Wakeup (T : Task_ID; Reason : System.Tasking.Task_States) is\n+      Result : Interfaces.C.int;\n+\n+   begin\n+      Result := pthread_cond_signal (T.Common.LL.CV'Access);\n+      pragma Assert (Result = 0);\n+   end Wakeup;\n+\n+   -----------\n+   -- Yield --\n+   -----------\n+\n+   procedure Yield (Do_Yield : Boolean := True) is\n+      Result : Interfaces.C.int;\n+\n+   begin\n+      if Do_Yield then\n+         Result := sched_yield;\n+      end if;\n+   end Yield;\n+\n+   ------------------\n+   -- Set_Priority --\n+   ------------------\n+\n+   type Prio_Array_Type is array (System.Any_Priority) of Integer;\n+   pragma Atomic_Components (Prio_Array_Type);\n+\n+   Prio_Array : Prio_Array_Type;\n+   --  Global array containing the id of the currently running task for\n+   --  each priority.\n+   --\n+   --  Note: we assume that we are on a single processor with run-til-blocked\n+   --  scheduling.\n+\n+   procedure Set_Priority\n+     (T : Task_ID;\n+      Prio : System.Any_Priority;\n+      Loss_Of_Inheritance : Boolean := False)\n+   is\n+      Result     : Interfaces.C.int;\n+      Array_Item : Integer;\n+      Param      : aliased struct_sched_param;\n+\n+   begin\n+      Param.sched_priority  := Interfaces.C.int (Underlying_Priorities (Prio));\n+\n+      if Time_Slice_Val > 0 then\n+         Result := pthread_setschedparam\n+           (T.Common.LL.Thread, SCHED_RR, Param'Access);\n+\n+      elsif FIFO_Within_Priorities or else Time_Slice_Val = 0 then\n+         Result := pthread_setschedparam\n+           (T.Common.LL.Thread, SCHED_FIFO, Param'Access);\n+\n+      else\n+         Result := pthread_setschedparam\n+           (T.Common.LL.Thread, SCHED_OTHER, Param'Access);\n+      end if;\n+\n+      pragma Assert (Result = 0);\n+\n+      if FIFO_Within_Priorities then\n+\n+         --  Annex D requirement [RM D.2.2 par. 9]:\n+         --    If the task drops its priority due to the loss of inherited\n+         --    priority, it is added at the head of the ready queue for its\n+         --    new active priority.\n+\n+         if Loss_Of_Inheritance\n+           and then Prio < T.Common.Current_Priority\n+         then\n+            Array_Item := Prio_Array (T.Common.Base_Priority) + 1;\n+            Prio_Array (T.Common.Base_Priority) := Array_Item;\n+\n+            loop\n+               --  Let some processes a chance to arrive\n+\n+               Yield;\n+\n+               --  Then wait for our turn to proceed\n+\n+               exit when Array_Item = Prio_Array (T.Common.Base_Priority)\n+                 or else Prio_Array (T.Common.Base_Priority) = 1;\n+            end loop;\n+\n+            Prio_Array (T.Common.Base_Priority) :=\n+              Prio_Array (T.Common.Base_Priority) - 1;\n+         end if;\n+      end if;\n+\n+      T.Common.Current_Priority := Prio;\n+   end Set_Priority;\n+\n+   ------------------\n+   -- Get_Priority --\n+   ------------------\n+\n+   function Get_Priority (T : Task_ID) return System.Any_Priority is\n+   begin\n+      return T.Common.Current_Priority;\n+   end Get_Priority;\n+\n+   ----------------\n+   -- Enter_Task --\n+   ----------------\n+\n+   procedure Enter_Task (Self_ID : Task_ID) is\n+      Result  : Interfaces.C.int;\n+\n+   begin\n+      Self_ID.Common.LL.Thread := pthread_self;\n+\n+      Result := pthread_setspecific (ATCB_Key, To_Address (Self_ID));\n+      pragma Assert (Result = 0);\n+\n+      Lock_All_Tasks_List;\n+      for I in Known_Tasks'Range loop\n+         if Known_Tasks (I) = null then\n+            Known_Tasks (I) := Self_ID;\n+            Self_ID.Known_Tasks_Index := I;\n+            exit;\n+         end if;\n+      end loop;\n+      Unlock_All_Tasks_List;\n+   end Enter_Task;\n+\n+   --------------\n+   -- New_ATCB --\n+   --------------\n+\n+   function New_ATCB (Entry_Num : Task_Entry_Index) return Task_ID is\n+   begin\n+      return new Ada_Task_Control_Block (Entry_Num);\n+   end New_ATCB;\n+\n+   ----------------------\n+   --  Initialize_TCB  --\n+   ----------------------\n+\n+   procedure Initialize_TCB (Self_ID : Task_ID; Succeeded : out Boolean) is\n+      Mutex_Attr : aliased pthread_mutexattr_t;\n+      Result : Interfaces.C.int;\n+      Cond_Attr : aliased pthread_condattr_t;\n+\n+   begin\n+      Result := pthread_mutexattr_init (Mutex_Attr'Access);\n+      pragma Assert (Result = 0 or else Result = ENOMEM);\n+\n+      if Result /= 0 then\n+         Succeeded := False;\n+         return;\n+      end if;\n+\n+      Result := pthread_mutex_init (Self_ID.Common.LL.L'Access,\n+        Mutex_Attr'Access);\n+      pragma Assert (Result = 0 or else Result = ENOMEM);\n+\n+      if Result /= 0 then\n+         Succeeded := False;\n+         return;\n+      end if;\n+\n+      Result := pthread_mutexattr_destroy (Mutex_Attr'Access);\n+      pragma Assert (Result = 0);\n+\n+      Result := pthread_condattr_init (Cond_Attr'Access);\n+      pragma Assert (Result = 0 or else Result = ENOMEM);\n+\n+      if Result /= 0 then\n+         Result := pthread_mutex_destroy (Self_ID.Common.LL.L'Access);\n+         pragma Assert (Result = 0);\n+         Succeeded := False;\n+         return;\n+      end if;\n+\n+      Result := pthread_cond_init (Self_ID.Common.LL.CV'Access,\n+        Cond_Attr'Access);\n+      pragma Assert (Result = 0 or else Result = ENOMEM);\n+\n+      if Result = 0 then\n+         Succeeded := True;\n+      else\n+         Result := pthread_mutex_destroy (Self_ID.Common.LL.L'Access);\n+         pragma Assert (Result = 0);\n+         Succeeded := False;\n+      end if;\n+\n+      Result := pthread_condattr_destroy (Cond_Attr'Access);\n+      pragma Assert (Result = 0);\n+   end Initialize_TCB;\n+\n+   -----------------\n+   -- Create_Task --\n+   -----------------\n+\n+   procedure Create_Task\n+     (T          : Task_ID;\n+      Wrapper    : System.Address;\n+      Stack_Size : System.Parameters.Size_Type;\n+      Priority   : System.Any_Priority;\n+      Succeeded  : out Boolean)\n+   is\n+      Attributes          : aliased pthread_attr_t;\n+      Adjusted_Stack_Size : Interfaces.C.size_t;\n+      Result              : Interfaces.C.int;\n+\n+      function Thread_Body_Access is new\n+        Unchecked_Conversion (System.Address, Thread_Body);\n+\n+   begin\n+      if Stack_Size = Unspecified_Size then\n+         Adjusted_Stack_Size := Interfaces.C.size_t (Default_Stack_Size);\n+\n+      elsif Stack_Size < Minimum_Stack_Size then\n+         Adjusted_Stack_Size := Interfaces.C.size_t (Minimum_Stack_Size);\n+\n+      else\n+         Adjusted_Stack_Size := Interfaces.C.size_t (Stack_Size);\n+      end if;\n+\n+      Result := pthread_attr_init (Attributes'Access);\n+      pragma Assert (Result = 0 or else Result = ENOMEM);\n+\n+      if Result /= 0 then\n+         Succeeded := False;\n+         return;\n+      end if;\n+\n+      Result := pthread_attr_setstacksize\n+        (Attributes'Access, Adjusted_Stack_Size);\n+      pragma Assert (Result = 0);\n+\n+      --  Since the initial signal mask of a thread is inherited from the\n+      --  creator, and the Environment task has all its signals masked, we\n+      --  do not need to manipulate caller's signal mask at this point.\n+      --  All tasks in RTS will have All_Tasks_Mask initially.\n+\n+      Result := pthread_create\n+        (T.Common.LL.Thread'Access,\n+         Attributes'Access,\n+         Thread_Body_Access (Wrapper),\n+         To_Address (T));\n+      pragma Assert (Result = 0 or else Result = EAGAIN);\n+\n+      Succeeded := Result = 0;\n+\n+      pthread_detach (T.Common.LL.Thread'Access);\n+      --  Detach the thread using pthread_detach, sinc DCE threads do not have\n+      --  pthread_attr_set_detachstate.\n+\n+      Result := pthread_attr_destroy (Attributes'Access);\n+      pragma Assert (Result = 0);\n+\n+      Set_Priority (T, Priority);\n+   end Create_Task;\n+\n+   ------------------\n+   -- Finalize_TCB --\n+   ------------------\n+\n+   procedure Finalize_TCB (T : Task_ID) is\n+      Result : Interfaces.C.int;\n+      Tmp    : Task_ID := T;\n+\n+      procedure Free is new\n+        Unchecked_Deallocation (Ada_Task_Control_Block, Task_ID);\n+\n+   begin\n+      Result := pthread_mutex_destroy (T.Common.LL.L'Access);\n+      pragma Assert (Result = 0);\n+      Result := pthread_cond_destroy (T.Common.LL.CV'Access);\n+      pragma Assert (Result = 0);\n+\n+      if T.Known_Tasks_Index /= -1 then\n+         Known_Tasks (T.Known_Tasks_Index) := null;\n+      end if;\n+\n+      Free (Tmp);\n+   end Finalize_TCB;\n+\n+   ---------------\n+   -- Exit_Task --\n+   ---------------\n+\n+   procedure Exit_Task is\n+   begin\n+      pthread_exit (System.Null_Address);\n+   end Exit_Task;\n+\n+   ----------------\n+   -- Abort_Task --\n+   ----------------\n+\n+   procedure Abort_Task (T : Task_ID) is\n+   begin\n+      --\n+      --  Interrupt Server_Tasks may be waiting on an \"event\" flag (signal)\n+      --\n+      if T.Common.State = Interrupt_Server_Blocked_On_Event_Flag then\n+         System.Interrupt_Management.Operations.Interrupt_Self_Process\n+           (System.Interrupt_Management.Interrupt_ID\n+             (PIO.Get_Interrupt_ID (T)));\n+      end if;\n+   end Abort_Task;\n+\n+   ----------------\n+   -- Check_Exit --\n+   ----------------\n+\n+   --  Dummy versions.  The only currently working versions is for solaris\n+   --  (native).\n+\n+   function Check_Exit (Self_ID : ST.Task_ID) return Boolean is\n+   begin\n+      return True;\n+   end Check_Exit;\n+\n+   --------------------\n+   -- Check_No_Locks --\n+   --------------------\n+\n+   function Check_No_Locks (Self_ID : ST.Task_ID) return Boolean is\n+   begin\n+      return True;\n+   end Check_No_Locks;\n+\n+   ----------------------\n+   -- Environment_Task --\n+   ----------------------\n+\n+   function Environment_Task return Task_ID is\n+   begin\n+      return Environment_Task_ID;\n+   end Environment_Task;\n+\n+   -------------------------\n+   -- Lock_All_Tasks_List --\n+   -------------------------\n+\n+   procedure Lock_All_Tasks_List is\n+   begin\n+      Write_Lock (All_Tasks_L'Access);\n+   end Lock_All_Tasks_List;\n+\n+   ---------------------------\n+   -- Unlock_All_Tasks_List --\n+   ---------------------------\n+\n+   procedure Unlock_All_Tasks_List is\n+   begin\n+      Unlock (All_Tasks_L'Access);\n+   end Unlock_All_Tasks_List;\n+\n+   ------------------\n+   -- Suspend_Task --\n+   ------------------\n+\n+   function Suspend_Task\n+     (T           : ST.Task_ID;\n+      Thread_Self : Thread_Id) return Boolean is\n+   begin\n+      return False;\n+   end Suspend_Task;\n+\n+   -----------------\n+   -- Resume_Task --\n+   -----------------\n+\n+   function Resume_Task\n+     (T           : ST.Task_ID;\n+      Thread_Self : Thread_Id) return Boolean is\n+   begin\n+      return False;\n+   end Resume_Task;\n+\n+   ----------------\n+   -- Initialize --\n+   ----------------\n+\n+   procedure Initialize (Environment_Task : Task_ID) is\n+      act       : aliased struct_sigaction;\n+      old_act   : aliased struct_sigaction;\n+      Tmp_Set   : aliased sigset_t;\n+      Result    : Interfaces.C.int;\n+\n+   begin\n+\n+      Environment_Task_ID := Environment_Task;\n+\n+      Initialize_Lock (All_Tasks_L'Access, All_Tasks_Level);\n+      --  Initialize the lock used to synchronize chain of all ATCBs.\n+\n+      Enter_Task (Environment_Task);\n+\n+      --  Install the abort-signal handler\n+\n+      act.sa_flags := 0;\n+      act.sa_handler := Abort_Handler'Address;\n+\n+      Result := sigemptyset (Tmp_Set'Access);\n+      pragma Assert (Result = 0);\n+      act.sa_mask := Tmp_Set;\n+\n+      Result :=\n+        sigaction (\n+          Signal (System.Interrupt_Management.Abort_Task_Interrupt),\n+          act'Unchecked_Access,\n+          old_act'Unchecked_Access);\n+      pragma Assert (Result = 0);\n+   end Initialize;\n+\n+   procedure do_nothing (arg : System.Address);\n+\n+   procedure do_nothing (arg : System.Address) is\n+   begin\n+      null;\n+   end do_nothing;\n+\n+begin\n+\n+   declare\n+      Result : Interfaces.C.int;\n+   begin\n+      --  NOTE: Unlike other pthread implementations, we do *not* mask all\n+      --  signals here since we handle signals using the process-wide primitive\n+      --  signal, rather than using sigthreadmask and sigwait. The reason of\n+      --  this difference is that sigwait doesn't work when some critical\n+      --  signals (SIGABRT, SIGPIPE) are masked.\n+\n+      Result := pthread_key_create (ATCB_Key'Access, do_nothing'Access);\n+      pragma Assert (Result = 0);\n+   end;\n+\n+end System.Task_Primitives.Operations;"}, {"sha": "9bb0c20563c4435b2b64bf53c7a6670adbfb3300", "filename": "gcc/ada/5htaspri.ads", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5htaspri.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5htaspri.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5htaspri.ads?ref=84481f762f0682e5f45b2f360446e1c7e333c880", "patch": "@@ -0,0 +1,92 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS               --\n+--                                                                          --\n+--                 S Y S T E M . T A S K _ P R I M I T I V E S              --\n+--                                                                          --\n+--                                  S p e c                                 --\n+--                                                                          --\n+--                             $Revision: 1.7 $\n+--                                                                          --\n+--          Copyright (C) 1991-2000 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNARL is free software; you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion. GNARL is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNARL; see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNARL was developed by the GNARL team at Florida State University. It is --\n+-- now maintained by Ada Core Technologies Inc. in cooperation with Florida --\n+-- State University (http://www.gnat.com).                                  --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is a HP-UX version of this package.\n+\n+--  This package provides low-level support for most tasking features.\n+\n+pragma Polling (Off);\n+--  Turn off polling, we do not want ATC polling to take place during\n+--  tasking operations. It causes infinite loops and other problems.\n+\n+with System.OS_Interface;\n+--  used for pthread_mutex_t\n+--           pthread_cond_t\n+--           pthread_t\n+\n+package System.Task_Primitives is\n+\n+   type Lock is limited private;\n+   --  Should be used for implementation of protected objects.\n+\n+   type RTS_Lock is limited private;\n+   --  Should be used inside the runtime system.\n+   --  The difference between Lock and the RTS_Lock is that the later\n+   --  one serves only as a semaphore so that do not check for\n+   --  ceiling violations.\n+\n+   type Task_Body_Access is access procedure;\n+   --  Pointer to the task body's entry point (or possibly a wrapper\n+   --  declared local to the GNARL).\n+\n+   type Private_Data is limited private;\n+   --  Any information that the GNULLI needs maintained on a per-task\n+   --  basis.  A component of this type is guaranteed to be included\n+   --  in the Ada_Task_Control_Block.\n+\n+private\n+   type Lock is record\n+      L              : aliased System.OS_Interface.pthread_mutex_t;\n+      Priority       : Integer;\n+      Owner_Priority : Integer;\n+   end record;\n+\n+   type RTS_Lock is new System.OS_Interface.pthread_mutex_t;\n+   type Private_Data is record\n+      Thread      : aliased System.OS_Interface.pthread_t;\n+      pragma Atomic (Thread);\n+      --  Thread field may be updated by two different threads of control.\n+      --  (See, Enter_Task and Create_Task in s-taprop.adb).\n+      --  They put the same value (thr_self value). We do not want to\n+      --  use lock on those operations and the only thing we have to\n+      --  make sure is that they are updated in atomic fashion.\n+\n+      CV          : aliased System.OS_Interface.pthread_cond_t;\n+      L           : aliased RTS_Lock;\n+      --  protection for all components is lock L\n+   end record;\n+\n+end System.Task_Primitives;"}, {"sha": "cbc6680f1235738fdae10ca65a6b916ba540a333", "filename": "gcc/ada/5htraceb.adb", "status": "added", "additions": 601, "deletions": 0, "changes": 601, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5htraceb.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5htraceb.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5htraceb.adb?ref=84481f762f0682e5f45b2f360446e1c7e333c880", "patch": "@@ -0,0 +1,601 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                     S Y S T E M . T R A C E B A C K                      --\n+--                             (HP/UX Version)                              --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.10 $\n+--                                                                          --\n+--           Copyright (C) 1999-2001 Ada Core Technologies, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Unchecked_Conversion;\n+\n+package body System.Traceback is\n+\n+   --  This package implements the backtracing facility by way of a dedicated\n+   --  HP library for stack unwinding described in the \"Runtime Architecture\n+   --  Document\".\n+\n+   pragma Linker_Options (\"/usr/lib/libcl.a\");\n+\n+   --  The library basically offers services to fetch information about a\n+   --  \"previous\" frame based on information about a \"current\" one.\n+\n+   type Current_Frame_Descriptor is record\n+      cur_fsz : Address;  --  Frame size of current routine.\n+      cur_sp  : Address;  --  The current value of stack pointer.\n+      cur_rls : Address;  --  PC-space of the caller.\n+      cur_rlo : Address;  --  PC-offset of the caller.\n+      cur_dp  : Address;  --  Data Pointer of the current routine.\n+      top_rp  : Address;  --  Initial value of RP.\n+      top_mrp : Address;  --  Initial value of MRP.\n+      top_sr0 : Address;  --  Initial value of sr0.\n+      top_sr4 : Address;  --  Initial value of sr4.\n+      top_r3  : Address;  --  Initial value of gr3.\n+      cur_r19 : Address;  --  GR19 value of the calling routine.\n+      top_r4  : Address;  --  Initial value of gr4.\n+      dummy   : Address;  --  Reserved.\n+      out_rlo : Address;  --  PC-offset of the caller after get_previous.\n+   end record;\n+\n+   type Previous_Frame_Descriptor is record\n+      prev_fsz : Address;  --  frame size of calling routine.\n+      prev_sp  : Address;  --  SP of calling routine.\n+      prev_rls : Address;  --  PC_space of calling routine's caller.\n+      prev_rlo : Address;  --  PC_offset of calling routine's caller.\n+      prev_dp  : Address;  --  DP of calling routine.\n+      udescr0  : Address;  --  low word of calling routine's unwind desc.\n+      udescr1  : Address;  --  high word of calling routine's unwind desc.\n+      ustart   : Address;  --  start of the unwind region.\n+      uend     : Address;  --  end of the unwind region.\n+      uw_index : Address;  --  index into the unwind table.\n+      prev_r19 : Address;  --  GR19 value of the caller's caller.\n+      top_r3   : Address;  --  Caller's initial gr3.\n+      top_r4   : Address;  --  Caller's initial gr4.\n+   end record;\n+\n+   --  Provide useful shortcuts for the names\n+\n+   subtype CFD is Current_Frame_Descriptor;\n+   subtype PFD is Previous_Frame_Descriptor;\n+\n+   --  Frames with dynamic stack allocation are handled using the associated\n+   --  frame pointer, but HP compilers and GCC setup this pointer differently.\n+   --  HP compilers set it to point at the top (highest address) of the static\n+   --  part of the frame, wheras GCC sets it to point at the bottom of this\n+   --  region. We have to fake the unwinder to compensate for this difference,\n+   --  for which we'll need to access some subprograms unwind descriptors.\n+\n+   type Bits_2_Value is mod 2 ** 2;\n+   for Bits_2_Value'Size use 2;\n+\n+   type Bits_4_Value  is mod 2 ** 4;\n+   for Bits_4_Value'Size use 4;\n+\n+   type Bits_5_Value  is mod 2 ** 5;\n+   for Bits_5_Value'Size use 5;\n+\n+   type Bits_27_Value is mod 2 ** 27;\n+   for Bits_27_Value'Size use 27;\n+\n+   type Unwind_Descriptor is record\n+      cannot_unwind         : Boolean;\n+      mcode                 : Boolean;\n+      mcode_save_restore    : Boolean;\n+      region_desc           : Bits_2_Value;\n+      reserved0             : Boolean;\n+      entry_sr              : Boolean;\n+      entry_fr              : Bits_4_Value;\n+      entry_gr              : Bits_5_Value;\n+\n+      args_stored           : Boolean;\n+      variable_frame        : Boolean;\n+      separate_package_body : Boolean;\n+      frame_extension_mcode : Boolean;\n+\n+      stack_overflow_check  : Boolean;\n+      two_steps_sp_adjust   : Boolean;\n+      sr4_export            : Boolean;\n+      cxx_info              : Boolean;\n+\n+      cxx_try_catch         : Boolean;\n+      sched_entry_seq       : Boolean;\n+      reserved1             : Boolean;\n+      save_sp               : Boolean;\n+\n+      save_rp               : Boolean;\n+      save_mrp              : Boolean;\n+      save_r19              : Boolean;\n+      cleanups              : Boolean;\n+\n+      hpe_interrupt_marker  : Boolean;\n+      hpux_interrupt_marker : Boolean;\n+      large_frame           : Boolean;\n+      alloca_frame          : Boolean;\n+\n+      reserved2             : Boolean;\n+      frame_size            : Bits_27_Value;\n+   end record;\n+\n+   for Unwind_Descriptor'Size use 64;\n+\n+   for Unwind_Descriptor use record\n+      cannot_unwind         at 0 range 0 .. 0;\n+      mcode                 at 0 range 1 .. 1;\n+      mcode_save_restore    at 0 range 2 .. 2;\n+      region_desc           at 0 range 3 .. 4;\n+      reserved0             at 0 range 5 .. 5;\n+      entry_sr              at 0 range 6 .. 6;\n+      entry_fr              at 0 range 7 .. 10;\n+\n+      entry_gr              at 1 range 3 .. 7;\n+\n+      args_stored           at 2 range 0 .. 0;\n+      variable_frame        at 2 range 1 .. 1;\n+      separate_package_body at 2 range 2 .. 2;\n+      frame_extension_mcode at 2 range 3 .. 3;\n+      stack_overflow_check  at 2 range 4 .. 4;\n+      two_steps_sp_adjust   at 2 range 5 .. 5;\n+      sr4_export            at 2 range 6 .. 6;\n+      cxx_info              at 2 range 7 .. 7;\n+\n+      cxx_try_catch         at 3 range 0 .. 0;\n+      sched_entry_seq       at 3 range 1 .. 1;\n+      reserved1             at 3 range 2 .. 2;\n+      save_sp               at 3 range 3 .. 3;\n+      save_rp               at 3 range 4 .. 4;\n+      save_mrp              at 3 range 5 .. 5;\n+      save_r19              at 3 range 6 .. 6;\n+      cleanups              at 3 range 7 .. 7;\n+\n+      hpe_interrupt_marker  at 4 range 0 .. 0;\n+      hpux_interrupt_marker at 4 range 1 .. 1;\n+      large_frame           at 4 range 2 .. 2;\n+      alloca_frame          at 4 range 3 .. 3;\n+\n+      reserved2             at 4 range 4 .. 4;\n+      frame_size            at 4 range 5 .. 31;\n+   end record;\n+\n+   subtype UWD is Unwind_Descriptor;\n+   type UWD_Ptr is access all UWD;\n+\n+   function To_UWD_Access is new Ada.Unchecked_Conversion (Address, UWD_Ptr);\n+\n+   --  The descriptor associated with a given code location is retrieved\n+   --  using functions imported from the HP library, requiring the definition\n+   --  of additional structures.\n+\n+   type Unwind_Table_Region is record\n+      Table_Start : Address;\n+      Table_End   : Address;\n+   end record;\n+   --  An Unwind Table region, which is a memory area containing Unwind\n+   --  Descriptors.\n+\n+   subtype UWT is Unwind_Table_Region;\n+   type UWT_Ptr is access all UWT;\n+\n+   function To_UWT_Address is new Ada.Unchecked_Conversion (UWT_Ptr, Address);\n+\n+   --  The subprograms imported below are provided by the HP library\n+\n+   function U_get_unwind_table return UWT;\n+   pragma Import (C, U_get_unwind_table, \"U_get_unwind_table\");\n+   --  Get the unwind table region associated with the current executable.\n+   --  This function is actually documented as having an argument, but which\n+   --  is only used for the MPE/iX targets.\n+\n+   function U_get_shLib_unwind_table (r19 : Address) return UWT;\n+   pragma Import (C, U_get_shLib_unwind_table, \"U_get_shLib_unw_tbl\");\n+   --  Return the unwind table region associated with a possible shared\n+   --  library, as determined by the provided r19 value.\n+\n+   function U_get_shLib_text_addr (r19 : Address) return Address;\n+   pragma Import (C, U_get_shLib_text_addr, \"U_get_shLib_text_addr\");\n+   --  Return the address at which the code for a shared library begins, or\n+   --  -1 if the value provided for r19 does not identify shared library code.\n+\n+   function U_get_unwind_entry\n+     (Pc          : Address;\n+      Space       : Address;\n+      Table_Start : Address;\n+      Table_End   : Address)\n+      return        Address;\n+   pragma Import (C, U_get_unwind_entry, \"U_get_unwind_entry\");\n+   --  Given the bounds of an unwind table, return the address of the\n+   --  unwind descriptor associated with a code location/space. In the case\n+   --  of shared library code, the offset from the beginning of the library\n+   --  is expected as Pc.\n+\n+   procedure U_init_frame_record (Frame : access CFD);\n+   pragma Import (C, U_init_frame_record, \"U_init_frame_record\");\n+\n+   procedure U_prep_frame_rec_for_unwind (Frame : access CFD);\n+   pragma Import (C, U_prep_frame_rec_for_unwind,\n+                    \"U_prep_frame_rec_for_unwind\");\n+\n+   --  Fetch the description data of the frame in which these two procedures\n+   --  are called.\n+\n+   function U_get_u_rlo (Cur : access CFD; Prev : access PFD) return Integer;\n+   pragma Import (C, U_get_u_rlo, \"U_IS_STUB_OR_CALLX\");\n+   --  From a complete current frame with a return location possibly located\n+   --  into a linker generated stub, and basic information about the previous\n+   --  frame, place the first non stub return location into the current frame.\n+   --  Return -1 if something went wrong during the computation.\n+\n+   function U_is_shared_pc (rlo : Address; r19 : Address) return Address;\n+   pragma Import (C, U_is_shared_pc, \"U_is_shared_pc\");\n+   --  Return 0 if the provided return location does not correspond to code\n+   --  in a shared library, or something non null otherwise.\n+\n+   function U_get_previous_frame_x\n+     (current_frame  : access CFD;\n+      previous_frame : access PFD;\n+      previous_size  : Integer)\n+      return           Integer;\n+   pragma Import (C, U_get_previous_frame_x, \"U_get_previous_frame_x\");\n+   --  Fetch the data describing the \"previous\" frame relatively to the\n+   --  \"current\" one. \"previous_size\" should be the size of the \"previous\"\n+   --  frame descriptor provided.\n+   --\n+   --  The library provides a simpler interface without the size parameter\n+   --  but it is not usable when frames with dynamically allocated space are\n+   --  on the way.\n+\n+   ------------------\n+   -- C_Call_Chain --\n+   ------------------\n+\n+   function C_Call_Chain\n+     (Traceback   : System.Address;\n+      Max_Len     : Natural)\n+      return        Natural\n+   is\n+      Val : Natural;\n+\n+   begin\n+      Call_Chain (Traceback, Max_Len, Val);\n+      return Val;\n+   end C_Call_Chain;\n+\n+   ----------------\n+   -- Call_Chain --\n+   ----------------\n+\n+   procedure Call_Chain\n+     (Traceback   : System.Address;\n+      Max_Len     : Natural;\n+      Len         : out Natural;\n+      Exclude_Min : System.Address := System.Null_Address;\n+      Exclude_Max : System.Address := System.Null_Address)\n+   is\n+      type Tracebacks_Array is array (1 .. Max_Len) of System.Address;\n+      pragma Suppress_Initialization (Tracebacks_Array);\n+\n+      --  The code location returned by the unwinder is a return location but\n+      --  what we need is a call point. Under HP-UX call instructions are 4\n+      --  bytes long and the return point they specify is 4 bytes beyond the\n+      --  next instruction because of the delay slot.\n+\n+      Call_Size  : constant := 4;\n+      DSlot_Size : constant := 4;\n+      Rlo_Offset : constant := Call_Size + DSlot_Size;\n+\n+      --  Moreover, the return point is passed via a register which two least\n+      --  significant bits specify a privilege level that we will have to mask.\n+\n+      Priv_Mask  : constant := 16#00000003#;\n+\n+      Frame       : aliased CFD;\n+      Code        : System.Address;\n+      J           : Natural := 1;\n+      Pop_Success : Boolean;\n+      Trace       : Tracebacks_Array;\n+      for Trace'Address use Traceback;\n+\n+      --  The backtracing process needs a set of subprograms :\n+\n+      function UWD_For_RLO_Of (Frame : access CFD) return UWD_Ptr;\n+      --  Return an access to the unwind descriptor for the caller of\n+      --  a given frame, using only the provided return location.\n+\n+      function UWD_For_Caller_Of (Frame : access CFD) return UWD_Ptr;\n+      --  Return an access to the unwind descriptor for the user code caller\n+      --  of a given frame, or null if the information is not available.\n+\n+      function Pop_Frame (Frame : access CFD) return Boolean;\n+      --  Update the provided machine state structure so that it reflects\n+      --  the state one call frame \"above\" the initial one.\n+      --\n+      --  Return True if the operation has been successful, False otherwise.\n+      --  Failure typically occurs when the top of the call stack has been\n+      --  reached.\n+\n+      function Prepare_For_Unwind_Of (Frame : access CFD) return Boolean;\n+      --  Perform the necessary adaptations to the machine state before\n+      --  calling the unwinder. Currently used for the specific case of\n+      --  dynamically sized previous frames.\n+      --\n+      --  Return True if everything went fine, or False otherwise.\n+\n+      Program_UWT : constant UWT := U_get_unwind_table;\n+\n+      ---------------\n+      -- Pop_Frame --\n+      ---------------\n+\n+      function Pop_Frame (Frame : access CFD) return Boolean is\n+         Up_Frame    : aliased PFD;\n+         State_Ready : Boolean;\n+\n+      begin\n+         --  Check/adapt the state before calling the unwinder and return\n+         --  if anything went wrong.\n+\n+         State_Ready := Prepare_For_Unwind_Of (Frame);\n+\n+         if not State_Ready then\n+            return False;\n+         end if;\n+\n+         --  Now, safely call the unwinder and use the results.\n+\n+         if U_get_previous_frame_x (Frame,\n+                                    Up_Frame'Access,\n+                                    Up_Frame'Size) /= 0\n+         then\n+            return False;\n+         end if;\n+\n+         --  In case a stub is on the way, the usual previous return location\n+         --  (the one in prev_rlo) is the one in the stub and the \"real\" one\n+         --  is placed in the \"current\" record, so let's take this one into\n+         --  account.\n+\n+         Frame.out_rlo := Frame.cur_rlo;\n+\n+         Frame.cur_fsz := Up_Frame.prev_fsz;\n+         Frame.cur_sp  := Up_Frame.prev_sp;\n+         Frame.cur_rls := Up_Frame.prev_rls;\n+         Frame.cur_rlo := Up_Frame.prev_rlo;\n+         Frame.cur_dp  := Up_Frame.prev_dp;\n+         Frame.cur_r19 := Up_Frame.prev_r19;\n+         Frame.top_r3  := Up_Frame.top_r3;\n+         Frame.top_r4  := Up_Frame.top_r4;\n+\n+         return True;\n+      end Pop_Frame;\n+\n+      ---------------------------------\n+      -- Prepare_State_For_Unwind_Of --\n+      ---------------------------------\n+\n+      function Prepare_For_Unwind_Of (Frame : access CFD) return Boolean\n+      is\n+         Caller_UWD    : UWD_Ptr;\n+         FP_Adjustment : Integer;\n+\n+      begin\n+         --  No need to bother doing anything if the stack is already fully\n+         --  unwound.\n+\n+         if Frame.cur_rlo = 0 then\n+            return False;\n+         end if;\n+\n+         --  When ALLOCA_FRAME is set in an unwind descriptor, the unwinder\n+         --  uses the value provided in current.top_r3 or current.top_r4 as\n+         --  a frame pointer to compute the size of the frame. What decides\n+         --  between r3 or r4 is the unwind descriptor LARGE_FRAME bit, with\n+         --  r4 chosen if the bit is set.\n+\n+         --  The size computed by the unwinder is STATIC_PART + (SP - FP),\n+         --  which is correct with HP's frame pointer convention, but not\n+         --  with GCC's one since we end up with the static part accounted\n+         --  for twice.\n+\n+         --  We have to compute r4 when it is required because the unwinder\n+         --  has looked for it at a place where it was not if we went through\n+         --  GCC frames.\n+\n+         --  The size of the static part of a frame can be found in the\n+         --  associated unwind descriptor.\n+\n+         Caller_UWD := UWD_For_Caller_Of (Frame);\n+\n+         --  If we cannot get it, we are unable to compute the potentially\n+         --  necessary adjustments. We'd better not try to go on then.\n+\n+         if Caller_UWD = null then\n+            return False;\n+         end if;\n+\n+         --  If the caller frame is a GCC one, r3 is its frame pointer and\n+         --  points to the bottom of the frame. The value to provide for r4\n+         --  can then be computed directly from the one of r3, compensating\n+         --  for the static part of the frame.\n+\n+         --  If the caller frame is an HP one, r3 is used to locate the\n+         --  previous frame marker, that is it also points to the bottom of\n+         --  the frame (this is why r3 cannot be used as the frame pointer in\n+         --  the HP sense for large frames). The value to provide for r4 can\n+         --  then also be computed from the one of r3 with the compensation\n+         --  for the static part of the frame.\n+\n+         FP_Adjustment := Integer (Caller_UWD.frame_size * 8);\n+         Frame.top_r4  := Address (Integer (Frame.top_r3) + FP_Adjustment);\n+\n+         return True;\n+      end Prepare_For_Unwind_Of;\n+\n+      -----------------------\n+      -- UWD_For_Caller_Of --\n+      -----------------------\n+\n+      function UWD_For_Caller_Of (Frame : access CFD) return UWD_Ptr\n+      is\n+         UWD_Access : UWD_Ptr;\n+\n+      begin\n+         --  First try the most direct path, using the return location data\n+         --  associated with the frame.\n+\n+         UWD_Access := UWD_For_RLO_Of (Frame);\n+\n+         if UWD_Access /= null then\n+            return UWD_Access;\n+         end if;\n+\n+         --  If we did not get a result, we might face an in-stub return\n+         --  address. In this case U_get_previous_frame can tell us what the\n+         --  first not-in-stub return point is. We cannot call it directly,\n+         --  though, because we haven't computed the potentially necessary\n+         --  frame pointer adjustments, which might lead to SEGV in some\n+         --  circumstances. Instead, we directly call the libcl routine which\n+         --  is called by U_get_previous_frame and which only requires few\n+         --  information. Take care, however, that the information is provided\n+         --  in the \"current\" argument, so we need to work on a copy to avoid\n+         --  disturbing our caller.\n+\n+         declare\n+            U_Current  : aliased CFD := Frame.all;\n+            U_Previous : aliased PFD;\n+\n+         begin\n+            U_Previous.prev_dp  := U_Current.cur_dp;\n+            U_Previous.prev_rls := U_Current.cur_rls;\n+            U_Previous.prev_sp  := U_Current.cur_sp - U_Current.cur_fsz;\n+\n+            if U_get_u_rlo (U_Current'Access, U_Previous'Access) /= -1 then\n+               UWD_Access := UWD_For_RLO_Of (U_Current'Access);\n+            end if;\n+         end;\n+\n+         return UWD_Access;\n+      end UWD_For_Caller_Of;\n+\n+      --------------------\n+      -- UWD_For_RLO_Of --\n+      --------------------\n+\n+      function UWD_For_RLO_Of (Frame : access CFD) return UWD_Ptr\n+      is\n+         UWD_Address : Address;\n+\n+         --  The addresses returned by the library point to full descriptors\n+         --  including the frame information bits but also the applicable PC\n+         --  range. We need to account for this.\n+\n+         Frame_Info_Offset  : constant := 8;\n+\n+      begin\n+         --  First try to locate the descriptor in the program's unwind table.\n+\n+         UWD_Address := U_get_unwind_entry (Frame.cur_rlo,\n+                                            Frame.cur_rls,\n+                                            Program_UWT.Table_Start,\n+                                            Program_UWT.Table_End);\n+\n+         --  If we did not get it, we might have a frame from code in a\n+         --  stub or shared library. For code in stub we would have to\n+         --  compute the first non-stub return location but this is not\n+         --  the role of this subprogram, so let's just try to see if we\n+         --  can get a result from the tables in shared libraries.\n+\n+         if UWD_Address = -1\n+           and then U_is_shared_pc (Frame.cur_rlo, Frame.cur_r19) /= 0\n+         then\n+            declare\n+               Shlib_UWT   : UWT := U_get_shLib_unwind_table (Frame.cur_r19);\n+               Shlib_Start : Address := U_get_shLib_text_addr (Frame.cur_r19);\n+               Rlo_Offset  : Address := Frame.cur_rlo - Shlib_Start;\n+\n+            begin\n+               UWD_Address := U_get_unwind_entry (Rlo_Offset,\n+                                                  Frame.cur_rls,\n+                                                  Shlib_UWT.Table_Start,\n+                                                  Shlib_UWT.Table_End);\n+            end;\n+         end if;\n+\n+         if UWD_Address /= -1 then\n+            return To_UWD_Access (UWD_Address + Frame_Info_Offset);\n+         else\n+            return null;\n+         end if;\n+      end UWD_For_RLO_Of;\n+\n+   --  Start of processing for Call_Chain\n+\n+   begin\n+      --  Fetch the state for this subprogram's frame and pop it so that the\n+      --  backtrace starts at the right point for our caller, that is at its\n+      --  own frame.\n+\n+      U_init_frame_record (Frame'Access);\n+      Frame.top_sr0 := 0;\n+      Frame.top_sr4 := 0;\n+\n+      U_prep_frame_rec_for_unwind (Frame'Access);\n+\n+      Pop_Success := Pop_Frame (Frame'Access);\n+\n+      --  Loop popping frames and storing locations until either a problem\n+      --  occurs, or the top of the call chain is reached, or the provided\n+      --  array is full.\n+\n+      loop\n+         --  We have to test some conditions against the return location\n+         --  as it is returned, so get it as is first.\n+\n+         Code := Frame.out_rlo;\n+\n+         exit when not Pop_Success or else Code = 0 or else J = Max_Len + 1;\n+\n+         --  Compute the call point from the retrieved return location :\n+         --  Mask the privilege bits and account for the delta between the\n+         --  call site and the return point.\n+\n+         Code := (Code and not Priv_Mask) - Rlo_Offset;\n+\n+         if Code < Exclude_Min or else Code > Exclude_Max then\n+            Trace (J) := Code;\n+            J := J + 1;\n+         end if;\n+\n+         Pop_Success := Pop_Frame (Frame'Access);\n+      end loop;\n+\n+      Len := J - 1;\n+   end Call_Chain;\n+\n+end System.Traceback;\n+"}, {"sha": "fd47dda726115b37b4e8d93c7eb37bc15df9f0b7", "filename": "gcc/ada/5iosinte.adb", "status": "added", "additions": 130, "deletions": 0, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5iosinte.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5iosinte.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5iosinte.adb?ref=84481f762f0682e5f45b2f360446e1c7e333c880", "patch": "@@ -0,0 +1,130 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS               --\n+--                                                                          --\n+--                   S Y S T E M . O S _ I N T E R F A C E                  --\n+--                                                                          --\n+--                                   B o d y                                --\n+--                                                                          --\n+--                             $Revision: 1.12 $\n+--                                                                          --\n+--             Copyright (C) 1991-2001 Florida State University             --\n+--                                                                          --\n+-- GNARL is free software; you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion. GNARL is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNARL; see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNARL was developed by the GNARL team at Florida State University. It is --\n+-- now maintained by Ada Core Technologies Inc. in cooperation with Florida --\n+-- State University (http://www.gnat.com).                                  --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is a LinuxThreads, Solaris pthread and HP-UX pthread version of this\n+--  package.\n+\n+pragma Polling (Off);\n+--  Turn off polling, we do not want ATC polling to take place during\n+--  tasking operations. It causes infinite loops and other problems.\n+\n+--  This package encapsulates all direct interfaces to OS services\n+--  that are needed by children of System.\n+\n+with Interfaces.C; use Interfaces.C;\n+package body System.OS_Interface is\n+\n+   --------------------\n+   -- Get_Stack_Base --\n+   --------------------\n+\n+   function Get_Stack_Base (thread : pthread_t) return Address is\n+   begin\n+      return Null_Address;\n+   end Get_Stack_Base;\n+\n+   ------------------\n+   -- pthread_init --\n+   ------------------\n+\n+   procedure pthread_init is\n+   begin\n+      null;\n+   end pthread_init;\n+\n+   -----------------\n+   -- To_Duration --\n+   -----------------\n+\n+   function To_Duration (TS : timespec) return Duration is\n+   begin\n+      return Duration (TS.tv_sec) + Duration (TS.tv_nsec) / 10#1#E9;\n+   end To_Duration;\n+\n+   function To_Duration (TV : struct_timeval) return Duration is\n+   begin\n+      return Duration (TV.tv_sec) + Duration (TV.tv_usec) / 10#1#E6;\n+   end To_Duration;\n+\n+   -----------------\n+   -- To_Timespec --\n+   -----------------\n+\n+   function To_Timespec (D : Duration) return timespec is\n+      S : time_t;\n+      F : Duration;\n+\n+   begin\n+      S := time_t (Long_Long_Integer (D));\n+      F := D - Duration (S);\n+\n+      --  If F has negative value due to a round-up, adjust for positive F\n+      --  value.\n+\n+      if F < 0.0 then\n+         S := S - 1;\n+         F := F + 1.0;\n+      end if;\n+\n+      return timespec'\n+        (tv_sec => S, tv_nsec => long (Long_Long_Integer (F * 10#1#E9)));\n+   end To_Timespec;\n+\n+   ----------------\n+   -- To_Timeval --\n+   ----------------\n+\n+   function To_Timeval (D : Duration) return struct_timeval is\n+      S : time_t;\n+      F : Duration;\n+\n+   begin\n+      S := time_t (Long_Long_Integer (D));\n+      F := D - Duration (S);\n+\n+      --  If F has negative value due to a round-up, adjust for positive F\n+      --  value.\n+\n+      if F < 0.0 then\n+         S := S - 1;\n+         F := F + 1.0;\n+      end if;\n+\n+      return struct_timeval'\n+        (tv_sec => S, tv_usec => time_t (Long_Long_Integer (F * 10#1#E6)));\n+   end To_Timeval;\n+\n+end System.OS_Interface;"}, {"sha": "571cea2869fa5842a851e6a9219735421c72490a", "filename": "gcc/ada/5iosinte.ads", "status": "added", "additions": 519, "deletions": 0, "changes": 519, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5iosinte.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5iosinte.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5iosinte.ads?ref=84481f762f0682e5f45b2f360446e1c7e333c880", "patch": "@@ -0,0 +1,519 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS               --\n+--                                                                          --\n+--                   S Y S T E M . O S _ I N T E R F A C E                  --\n+--                                                                          --\n+--                                  S p e c                                 --\n+--                                                                          --\n+--                              $Revision: 1.27 $\n+--                                                                          --\n+--          Copyright (C) 1991-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNARL is free software; you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion. GNARL is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNARL; see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNARL was developed by the GNARL team at Florida State University. It is --\n+-- now maintained by Ada Core Technologies Inc. in cooperation with Florida --\n+-- State University (http://www.gnat.com).                                  --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is a Linux (LinuxThreads) version of this package.\n+\n+--  This package encapsulates all direct interfaces to OS services\n+--  that are needed by children of System.\n+\n+--  PLEASE DO NOT add any with-clauses to this package\n+--  or remove the pragma Elaborate_Body.\n+--  It is designed to be a bottom-level (leaf) package.\n+\n+with Interfaces.C;\n+package System.OS_Interface is\n+   pragma Preelaborate;\n+\n+   pragma Linker_Options (\"-lpthread\");\n+\n+   subtype int            is Interfaces.C.int;\n+   subtype char           is Interfaces.C.char;\n+   subtype short          is Interfaces.C.short;\n+   subtype long           is Interfaces.C.long;\n+   subtype unsigned       is Interfaces.C.unsigned;\n+   subtype unsigned_short is Interfaces.C.unsigned_short;\n+   subtype unsigned_long  is Interfaces.C.unsigned_long;\n+   subtype unsigned_char  is Interfaces.C.unsigned_char;\n+   subtype plain_char     is Interfaces.C.plain_char;\n+   subtype size_t         is Interfaces.C.size_t;\n+\n+   -----------\n+   -- Errno --\n+   -----------\n+\n+   function errno return int;\n+   pragma Import (C, errno, \"__get_errno\");\n+\n+   EAGAIN    : constant := 11;\n+   EINTR     : constant := 4;\n+   EINVAL    : constant := 22;\n+   ENOMEM    : constant := 12;\n+   EPERM     : constant := 1;\n+   ETIMEDOUT : constant := 110;\n+\n+   -------------\n+   -- Signals --\n+   -------------\n+\n+   Max_Interrupt : constant := 63;\n+   type Signal is new int range 0 .. Max_Interrupt;\n+   for Signal'Size use int'Size;\n+\n+   SIGHUP     : constant := 1; --  hangup\n+   SIGINT     : constant := 2; --  interrupt (rubout)\n+   SIGQUIT    : constant := 3; --  quit (ASCD FS)\n+   SIGILL     : constant := 4; --  illegal instruction (not reset)\n+   SIGTRAP    : constant := 5; --  trace trap (not reset)\n+   SIGIOT     : constant := 6; --  IOT instruction\n+   SIGABRT    : constant := 6; --  used by abort, replace SIGIOT in the  future\n+   SIGFPE     : constant := 8; --  floating point exception\n+   SIGKILL    : constant := 9; --  kill (cannot be caught or ignored)\n+   SIGBUS     : constant := 7; --  bus error\n+   SIGSEGV    : constant := 11; --  segmentation violation\n+   SIGPIPE    : constant := 13; --  write on a pipe with no one to read it\n+   SIGALRM    : constant := 14; --  alarm clock\n+   SIGTERM    : constant := 15; --  software termination signal from kill\n+   SIGUSR1    : constant := 10; --  user defined signal 1\n+   SIGUSR2    : constant := 12; --  user defined signal 2\n+   SIGCLD     : constant := 17; --  alias for SIGCHLD\n+   SIGCHLD    : constant := 17; --  child status change\n+   SIGPWR     : constant := 30; --  power-fail restart\n+   SIGWINCH   : constant := 28; --  window size change\n+   SIGURG     : constant := 23; --  urgent condition on IO channel\n+   SIGPOLL    : constant := 29; --  pollable event occurred\n+   SIGIO      : constant := 29; --  I/O now possible (4.2 BSD)\n+   SIGLOST    : constant := 29; --  File lock lost\n+   SIGSTOP    : constant := 19; --  stop (cannot be caught or ignored)\n+   SIGTSTP    : constant := 20; --  user stop requested from tty\n+   SIGCONT    : constant := 18; --  stopped process has been continued\n+   SIGTTIN    : constant := 21; --  background tty read attempted\n+   SIGTTOU    : constant := 22; --  background tty write attempted\n+   SIGVTALRM  : constant := 26; --  virtual timer expired\n+   SIGPROF    : constant := 27; --  profiling timer expired\n+   SIGXCPU    : constant := 24; --  CPU time limit exceeded\n+   SIGXFSZ    : constant := 25; --  filesize limit exceeded\n+   SIGUNUSED  : constant := 31;  --  unused signal (Linux)\n+   SIGSTKFLT  : constant := 16;  --  coprocessor stack fault (Linux)\n+   SIGLTHRRES : constant := 32;  --  LinuxThreads restart signal\n+   SIGLTHRCAN : constant := 33;  --  LinuxThreads cancel signal\n+   SIGLTHRDBG : constant := 34;  --  LinuxThreads debugger signal\n+\n+   SIGADAABORT : constant := SIGABRT;\n+   --  Change this if you want to use another signal for task abort.\n+   --  SIGTERM might be a good one.\n+\n+   type Signal_Set is array (Natural range <>) of Signal;\n+\n+   Unmasked    : constant Signal_Set := (\n+      SIGTRAP,\n+      --  To enable debugging on multithreaded applications, mark SIGTRAP to\n+      --  be kept unmasked.\n+\n+      SIGBUS,\n+\n+      SIGTTIN, SIGTTOU, SIGTSTP,\n+      --  Keep these three signals unmasked so that background processes\n+      --  and IO behaves as normal \"C\" applications\n+\n+      SIGPROF,\n+      --  To avoid confusing the profiler\n+\n+      SIGKILL, SIGSTOP,\n+      --  These two signals actually cannot be masked;\n+      --  POSIX simply won't allow it.\n+\n+      SIGLTHRRES, SIGLTHRCAN, SIGLTHRDBG);\n+      --  These three signals are used by LinuxThreads starting from\n+      --  glibc 2.1 (future 2.2).\n+\n+   Reserved    : constant Signal_Set :=\n+   --  I am not sure why the following two signals are reserved.\n+   --  I guess they are not supported by this version of Linux.\n+     (SIGVTALRM, SIGUNUSED);\n+\n+   type sigset_t is private;\n+\n+   function sigaddset (set : access sigset_t; sig : Signal) return int;\n+   pragma Import (C, sigaddset, \"sigaddset\");\n+\n+   function sigdelset (set : access sigset_t; sig : Signal) return int;\n+   pragma Import (C, sigdelset, \"sigdelset\");\n+\n+   function sigfillset (set : access sigset_t) return int;\n+   pragma Import (C, sigfillset, \"sigfillset\");\n+\n+   function sigismember (set : access sigset_t; sig : Signal) return int;\n+   pragma Import (C, sigismember, \"sigismember\");\n+\n+   function sigemptyset (set : access sigset_t) return int;\n+   pragma Import (C, sigemptyset, \"sigemptyset\");\n+\n+   type union_type_3 is new String (1 .. 116);\n+   type siginfo_t is record\n+      si_signo : int;\n+      si_code  : int;\n+      si_errno : int;\n+      X_data   : union_type_3;\n+   end record;\n+   pragma Convention (C, siginfo_t);\n+\n+   type struct_sigaction is record\n+      sa_handler   : System.Address;\n+      sa_mask      : sigset_t;\n+      sa_flags     : unsigned_long;\n+      sa_restorer  : System.Address;\n+   end record;\n+   pragma Convention (C, struct_sigaction);\n+   type struct_sigaction_ptr is access all struct_sigaction;\n+\n+   type Machine_State is record\n+      eip : unsigned_long;\n+      ebx : unsigned_long;\n+      esp : unsigned_long;\n+      ebp : unsigned_long;\n+      esi : unsigned_long;\n+      edi : unsigned_long;\n+   end record;\n+   type Machine_State_Ptr is access all Machine_State;\n+\n+   SIG_BLOCK   : constant := 0;\n+   SIG_UNBLOCK : constant := 1;\n+   SIG_SETMASK : constant := 2;\n+\n+   SIG_DFL : constant := 0;\n+   SIG_IGN : constant := 1;\n+\n+   function sigaction\n+     (sig  : Signal;\n+      act  : struct_sigaction_ptr;\n+      oact : struct_sigaction_ptr) return int;\n+   pragma Import (C, sigaction, \"sigaction\");\n+\n+   ----------\n+   -- Time --\n+   ----------\n+\n+   type timespec is private;\n+\n+   function To_Duration (TS : timespec) return Duration;\n+   pragma Inline (To_Duration);\n+\n+   function To_Timespec (D : Duration) return timespec;\n+   pragma Inline (To_Timespec);\n+\n+   type struct_timeval is private;\n+\n+   function To_Duration (TV : struct_timeval) return Duration;\n+   pragma Inline (To_Duration);\n+\n+   function To_Timeval (D : Duration) return struct_timeval;\n+   pragma Inline (To_Timeval);\n+\n+   function gettimeofday\n+     (tv : access struct_timeval;\n+      tz : System.Address := System.Null_Address) return int;\n+   pragma Import (C, gettimeofday, \"gettimeofday\");\n+\n+   -------------------------\n+   -- Priority Scheduling --\n+   -------------------------\n+\n+   SCHED_OTHER : constant := 0;\n+   SCHED_FIFO  : constant := 1;\n+   SCHED_RR    : constant := 2;\n+\n+   -------------\n+   -- Process --\n+   -------------\n+\n+   type pid_t is private;\n+\n+   function kill (pid : pid_t; sig : Signal) return int;\n+   pragma Import (C, kill, \"kill\");\n+\n+   function getpid return pid_t;\n+   pragma Import (C, getpid, \"getpid\");\n+\n+   -------------\n+   -- Threads --\n+   -------------\n+\n+   type Thread_Body is access\n+     function (arg : System.Address) return System.Address;\n+   type pthread_t           is private;\n+   subtype Thread_Id        is pthread_t;\n+\n+   type pthread_mutex_t     is limited private;\n+   type pthread_cond_t      is limited private;\n+   type pthread_attr_t      is limited private;\n+   type pthread_mutexattr_t is limited private;\n+   type pthread_condattr_t  is limited private;\n+   type pthread_key_t       is private;\n+\n+   PTHREAD_CREATE_DETACHED : constant := 1;\n+\n+   -----------\n+   -- Stack --\n+   -----------\n+\n+   function Get_Stack_Base (thread : pthread_t) return Address;\n+   pragma Inline (Get_Stack_Base);\n+   --  This is a dummy procedure to share some GNULLI files\n+\n+   ---------------------------------------\n+   -- Nonstandard Thread Initialization --\n+   ---------------------------------------\n+\n+   procedure pthread_init;\n+   pragma Inline (pthread_init);\n+   --  This is a dummy procedure to share some GNULLI files\n+\n+   -------------------------\n+   -- POSIX.1c  Section 3 --\n+   -------------------------\n+\n+   function sigwait (set : access sigset_t; sig : access Signal) return int;\n+   pragma Import (C, sigwait, \"sigwait\");\n+\n+   function pthread_kill (thread : pthread_t; sig : Signal) return int;\n+   pragma Import (C, pthread_kill, \"pthread_kill\");\n+\n+   type sigset_t_ptr is access all sigset_t;\n+\n+   function pthread_sigmask\n+     (how  : int;\n+      set  : sigset_t_ptr;\n+      oset : sigset_t_ptr) return int;\n+   pragma Import (C, pthread_sigmask, \"pthread_sigmask\");\n+\n+   --------------------------\n+   -- POSIX.1c  Section 11 --\n+   --------------------------\n+\n+   function pthread_mutexattr_init\n+     (attr : access pthread_mutexattr_t) return int;\n+   pragma Import (C, pthread_mutexattr_init, \"pthread_mutexattr_init\");\n+\n+   function pthread_mutexattr_destroy\n+     (attr : access pthread_mutexattr_t) return int;\n+   pragma Import (C, pthread_mutexattr_destroy, \"pthread_mutexattr_destroy\");\n+\n+   function pthread_mutex_init\n+     (mutex : access pthread_mutex_t;\n+      attr  : access pthread_mutexattr_t) return int;\n+   pragma Import (C, pthread_mutex_init, \"pthread_mutex_init\");\n+\n+   function pthread_mutex_destroy (mutex : access pthread_mutex_t) return int;\n+   pragma Import (C, pthread_mutex_destroy, \"pthread_mutex_destroy\");\n+\n+   function pthread_mutex_lock (mutex : access pthread_mutex_t) return int;\n+   pragma Import (C, pthread_mutex_lock, \"pthread_mutex_lock\");\n+\n+   function pthread_mutex_unlock (mutex : access pthread_mutex_t) return int;\n+   pragma Import (C, pthread_mutex_unlock, \"pthread_mutex_unlock\");\n+\n+   function pthread_condattr_init\n+     (attr : access pthread_condattr_t) return int;\n+   pragma Import (C, pthread_condattr_init, \"pthread_condattr_init\");\n+\n+   function pthread_condattr_destroy\n+     (attr : access pthread_condattr_t) return int;\n+   pragma Import (C, pthread_condattr_destroy, \"pthread_condattr_destroy\");\n+\n+   function pthread_cond_init\n+     (cond : access pthread_cond_t;\n+      attr : access pthread_condattr_t) return int;\n+   pragma Import (C, pthread_cond_init, \"pthread_cond_init\");\n+\n+   function pthread_cond_destroy (cond : access pthread_cond_t) return int;\n+   pragma Import (C, pthread_cond_destroy, \"pthread_cond_destroy\");\n+\n+   function pthread_cond_signal (cond : access pthread_cond_t) return int;\n+   pragma Import (C, pthread_cond_signal, \"pthread_cond_signal\");\n+\n+   function pthread_cond_wait\n+     (cond  : access pthread_cond_t;\n+      mutex : access pthread_mutex_t) return int;\n+   pragma Import (C, pthread_cond_wait, \"pthread_cond_wait\");\n+\n+   function pthread_cond_timedwait\n+     (cond    : access pthread_cond_t;\n+      mutex   : access pthread_mutex_t;\n+      abstime : access timespec) return int;\n+   pragma Import (C, pthread_cond_timedwait, \"pthread_cond_timedwait\");\n+\n+   --------------------------\n+   -- POSIX.1c  Section 13 --\n+   --------------------------\n+\n+   type struct_sched_param is record\n+      sched_priority : int;  --  scheduling priority\n+   end record;\n+   pragma Convention (C, struct_sched_param);\n+\n+   function pthread_setschedparam\n+     (thread : pthread_t;\n+      policy : int;\n+      param  : access struct_sched_param) return int;\n+   pragma Import (C, pthread_setschedparam, \"pthread_setschedparam\");\n+\n+   function pthread_attr_setschedpolicy\n+     (attr   : access pthread_attr_t;\n+      policy : int) return int;\n+   pragma Import\n+     (C, pthread_attr_setschedpolicy, \"pthread_attr_setschedpolicy\");\n+\n+   function sched_yield return int;\n+   pragma Import (C, sched_yield, \"sched_yield\");\n+\n+   ---------------------------\n+   -- P1003.1c - Section 16 --\n+   ---------------------------\n+\n+   function pthread_attr_init\n+     (attributes : access pthread_attr_t) return int;\n+   pragma Import (C, pthread_attr_init, \"pthread_attr_init\");\n+\n+   function pthread_attr_destroy\n+     (attributes : access pthread_attr_t) return int;\n+   pragma Import (C, pthread_attr_destroy, \"pthread_attr_destroy\");\n+\n+   function pthread_attr_setdetachstate\n+     (attr        : access pthread_attr_t;\n+      detachstate : int) return int;\n+   pragma Import\n+     (C, pthread_attr_setdetachstate, \"pthread_attr_setdetachstate\");\n+\n+   function pthread_attr_setstacksize\n+     (attr      : access pthread_attr_t;\n+      stacksize : size_t) return int;\n+   pragma Import (C, pthread_attr_setstacksize, \"pthread_attr_setstacksize\");\n+\n+   function pthread_create\n+     (thread        : access pthread_t;\n+      attributes    : access pthread_attr_t;\n+      start_routine : Thread_Body;\n+      arg           : System.Address) return int;\n+   pragma Import (C, pthread_create, \"pthread_create\");\n+\n+   procedure pthread_exit (status : System.Address);\n+   pragma Import (C, pthread_exit, \"pthread_exit\");\n+\n+   function pthread_self return pthread_t;\n+   pragma Import (C, pthread_self, \"pthread_self\");\n+\n+   --------------------------\n+   -- POSIX.1c  Section 17 --\n+   --------------------------\n+\n+   function pthread_setspecific\n+     (key   : pthread_key_t;\n+      value : System.Address) return int;\n+   pragma Import (C, pthread_setspecific, \"pthread_setspecific\");\n+\n+   function pthread_getspecific (key : pthread_key_t) return System.Address;\n+   pragma Import (C, pthread_getspecific, \"pthread_getspecific\");\n+\n+   type destructor_pointer is access procedure (arg : System.Address);\n+\n+   function pthread_key_create\n+     (key        : access pthread_key_t;\n+      destructor : destructor_pointer) return int;\n+   pragma Import (C, pthread_key_create, \"pthread_key_create\");\n+\n+private\n+\n+   type sigset_t is array (0 .. 31) of unsigned_long;\n+   pragma Convention (C, sigset_t);\n+   for sigset_t'Size use 1024;\n+   --  This is for GNU libc version 2 but should be backward compatible with\n+   --  other libc where sigset_t is smaller.\n+\n+   type pid_t is new int;\n+\n+   type time_t is new long;\n+\n+   type timespec is record\n+      tv_sec  : time_t;\n+      tv_nsec : long;\n+   end record;\n+   pragma Convention (C, timespec);\n+\n+   type struct_timeval is record\n+      tv_sec  : time_t;\n+      tv_usec : time_t;\n+   end record;\n+   pragma Convention (C, struct_timeval);\n+\n+   type pthread_attr_t is record\n+      detachstate   : int;\n+      schedpolicy   : int;\n+      schedparam    : struct_sched_param;\n+      inheritsched  : int;\n+      scope         : int;\n+      guardsize     : size_t;\n+      stackaddr_set : int;\n+      stackaddr     : System.Address;\n+      stacksize     : size_t;\n+   end record;\n+   pragma Convention (C_Pass_By_Copy, pthread_attr_t);\n+\n+   type pthread_condattr_t is record\n+      dummy : int;\n+   end record;\n+   pragma Convention (C, pthread_condattr_t);\n+\n+   type pthread_mutexattr_t is record\n+      mutexkind : int;\n+   end record;\n+   pragma Convention (C, pthread_mutexattr_t);\n+\n+   type pthread_t is new unsigned_long;\n+\n+   type struct_pthread_queue is record\n+      head : System.Address;\n+      tail : System.Address;\n+   end record;\n+   pragma Convention (C, struct_pthread_queue);\n+\n+   type pthread_mutex_t is record\n+      m_spinlock : int;\n+      m_count    : int;\n+      m_owner    : System.Address;\n+      m_kind     : int;\n+      m_waiting  : struct_pthread_queue;\n+   end record;\n+   pragma Convention (C, pthread_mutex_t);\n+\n+   type pthread_cond_t is record\n+      c_spinlock : int;\n+      c_waiting  : struct_pthread_queue;\n+   end record;\n+   pragma Convention (C, pthread_cond_t);\n+\n+   type pthread_key_t is new unsigned;\n+\n+end System.OS_Interface;"}, {"sha": "bc4b7d33efc676fbd5c2af37a7c878330b62bf78", "filename": "gcc/ada/5itaprop.adb", "status": "added", "additions": 1044, "deletions": 0, "changes": 1044, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5itaprop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5itaprop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5itaprop.adb?ref=84481f762f0682e5f45b2f360446e1c7e333c880", "patch": "@@ -0,0 +1,1044 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS               --\n+--                                                                          --\n+--     S Y S T E M . T A S K _ P R I M I T I V E S . O P E R A T I O N S    --\n+--                                                                          --\n+--                                  B o d y                                 --\n+--                                                                          --\n+--                             $Revision: 1.43 $\n+--                                                                          --\n+--             Copyright (C) 1991-2001, Florida State University            --\n+--                                                                          --\n+-- GNARL is free software; you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion. GNARL is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNARL; see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNARL was developed by the GNARL team at Florida State University. It is --\n+-- now maintained by Ada Core Technologies Inc. in cooperation with Florida --\n+-- State University (http://www.gnat.com).                                  --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is a Linux (LinuxThreads) version of this package\n+\n+--  This package contains all the GNULL primitives that interface directly\n+--  with the underlying OS.\n+\n+pragma Polling (Off);\n+--  Turn off polling, we do not want ATC polling to take place during\n+--  tasking operations. It causes infinite loops and other problems.\n+\n+with System.Tasking.Debug;\n+--  used for Known_Tasks\n+\n+with Interfaces.C;\n+--  used for int\n+--           size_t\n+\n+with System.Interrupt_Management;\n+--  used for Keep_Unmasked\n+--           Abort_Task_Interrupt\n+--           Interrupt_ID\n+\n+with System.Interrupt_Management.Operations;\n+--  used for Set_Interrupt_Mask\n+--           All_Tasks_Mask\n+pragma Elaborate_All (System.Interrupt_Management.Operations);\n+\n+with System.Parameters;\n+--  used for Size_Type\n+\n+with System.Tasking;\n+--  used for Ada_Task_Control_Block\n+--           Task_ID\n+\n+with Ada.Exceptions;\n+--  used for Raise_Exception\n+--           Raise_From_Signal_Handler\n+--           Exception_Id\n+\n+with System.Soft_Links;\n+--  used for Defer/Undefer_Abort\n+\n+--  Note that we do not use System.Tasking.Initialization directly since\n+--  this is a higher level package that we shouldn't depend on. For example\n+--  when using the restricted run time, it is replaced by\n+--  System.Tasking.Restricted.Initialization\n+\n+with System.OS_Primitives;\n+--  used for Delay_Modes\n+\n+with System.Soft_Links;\n+--  used for Get_Machine_State_Addr\n+\n+with Unchecked_Conversion;\n+with Unchecked_Deallocation;\n+\n+package body System.Task_Primitives.Operations is\n+\n+   use System.Tasking.Debug;\n+   use System.Tasking;\n+   use Interfaces.C;\n+   use System.OS_Interface;\n+   use System.Parameters;\n+   use System.OS_Primitives;\n+\n+   package SSL renames System.Soft_Links;\n+\n+   ------------------\n+   --  Local Data  --\n+   ------------------\n+\n+   Max_Stack_Size : constant := 2000 * 1024;\n+   --  LinuxThreads does not return an error value when requesting\n+   --  a task stack size which is too large, so we have to check this\n+   --  ourselves.\n+\n+   --  The followings are logically constants, but need to be initialized\n+   --  at run time.\n+\n+   ATCB_Key : aliased pthread_key_t;\n+   --  Key used to find the Ada Task_ID associated with a thread\n+\n+   All_Tasks_L : aliased System.Task_Primitives.RTS_Lock;\n+   --  See comments on locking rules in System.Tasking (spec).\n+\n+   Environment_Task_ID : Task_ID;\n+   --  A variable to hold Task_ID for the environment task.\n+\n+   Unblocked_Signal_Mask : aliased sigset_t;\n+   --  The set of signals that should unblocked in all tasks\n+\n+   --  The followings are internal configuration constants needed.\n+   Priority_Ceiling_Emulation : constant Boolean := True;\n+\n+   Next_Serial_Number : Task_Serial_Number := 100;\n+   --  We start at 100, to reserve some special values for\n+   --  using in error checking.\n+   --  The following are internal configuration constants needed.\n+\n+   Time_Slice_Val : Integer;\n+   pragma Import (C, Time_Slice_Val, \"__gl_time_slice_val\");\n+\n+   Dispatching_Policy : Character;\n+   pragma Import (C, Dispatching_Policy, \"__gl_task_dispatching_policy\");\n+\n+   FIFO_Within_Priorities : constant Boolean := Dispatching_Policy = 'F';\n+   --  Indicates whether FIFO_Within_Priorities is set.\n+\n+   --  The following are effectively constants, but they need to\n+   --  be initialized by calling a pthread_ function.\n+\n+   Mutex_Attr   : aliased pthread_mutexattr_t;\n+   Cond_Attr    : aliased pthread_condattr_t;\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   subtype unsigned_short is Interfaces.C.unsigned_short;\n+   subtype unsigned_long is Interfaces.C.unsigned_long;\n+\n+   procedure Abort_Handler\n+     (signo         : Signal;\n+      gs            : unsigned_short;\n+      fs            : unsigned_short;\n+      es            : unsigned_short;\n+      ds            : unsigned_short;\n+      edi           : unsigned_long;\n+      esi           : unsigned_long;\n+      ebp           : unsigned_long;\n+      esp           : unsigned_long;\n+      ebx           : unsigned_long;\n+      edx           : unsigned_long;\n+      ecx           : unsigned_long;\n+      eax           : unsigned_long;\n+      trapno        : unsigned_long;\n+      err           : unsigned_long;\n+      eip           : unsigned_long;\n+      cs            : unsigned_short;\n+      eflags        : unsigned_long;\n+      esp_at_signal : unsigned_long;\n+      ss            : unsigned_short;\n+      fpstate       : System.Address;\n+      oldmask       : unsigned_long;\n+      cr2           : unsigned_long);\n+\n+   function To_Task_ID is new Unchecked_Conversion (System.Address, Task_ID);\n+\n+   function To_Address is new Unchecked_Conversion (Task_ID, System.Address);\n+\n+   function To_pthread_t is new Unchecked_Conversion\n+     (Integer, System.OS_Interface.pthread_t);\n+\n+   -------------------\n+   -- Abort_Handler --\n+   -------------------\n+\n+   --  Target-dependent binding of inter-thread Abort signal to\n+   --  the raising of the Abort_Signal exception.\n+\n+   --  The technical issues and alternatives here are essentially\n+   --  the same as for raising exceptions in response to other\n+   --  signals (e.g. Storage_Error).  See code and comments in\n+   --  the package body System.Interrupt_Management.\n+\n+   --  Some implementations may not allow an exception to be propagated\n+   --  out of a handler, and others might leave the signal or\n+   --  interrupt that invoked this handler masked after the exceptional\n+   --  return to the application code.\n+\n+   --  GNAT exceptions are originally implemented using setjmp()/longjmp().\n+   --  On most UNIX systems, this will allow transfer out of a signal handler,\n+   --  which is usually the only mechanism available for implementing\n+   --  asynchronous handlers of this kind.  However, some\n+   --  systems do not restore the signal mask on longjmp(), leaving the\n+   --  abort signal masked.\n+\n+   --  Alternative solutions include:\n+\n+   --       1. Change the PC saved in the system-dependent Context\n+   --          parameter to point to code that raises the exception.\n+   --          Normal return from this handler will then raise\n+   --          the exception after the mask and other system state has\n+   --          been restored (see example below).\n+   --       2. Use siglongjmp()/sigsetjmp() to implement exceptions.\n+   --       3. Unmask the signal in the Abortion_Signal exception handler\n+   --          (in the RTS).\n+\n+   --  Note that with the new exception mechanism, it is not correct to\n+   --  simply \"raise\" an exception from a signal handler, that's why we\n+   --  use Raise_From_Signal_Handler\n+\n+   procedure Abort_Handler\n+     (signo   : Signal;\n+      gs            : unsigned_short;\n+      fs            : unsigned_short;\n+      es            : unsigned_short;\n+      ds            : unsigned_short;\n+      edi           : unsigned_long;\n+      esi           : unsigned_long;\n+      ebp           : unsigned_long;\n+      esp           : unsigned_long;\n+      ebx           : unsigned_long;\n+      edx           : unsigned_long;\n+      ecx           : unsigned_long;\n+      eax           : unsigned_long;\n+      trapno        : unsigned_long;\n+      err           : unsigned_long;\n+      eip           : unsigned_long;\n+      cs            : unsigned_short;\n+      eflags        : unsigned_long;\n+      esp_at_signal : unsigned_long;\n+      ss            : unsigned_short;\n+      fpstate       : System.Address;\n+      oldmask       : unsigned_long;\n+      cr2           : unsigned_long)\n+   is\n+      Self_Id : Task_ID := Self;\n+      Result  : Interfaces.C.int;\n+      Old_Set : aliased sigset_t;\n+\n+      function To_Machine_State_Ptr is new\n+        Unchecked_Conversion (Address, Machine_State_Ptr);\n+\n+      --  These are not directly visible\n+\n+      procedure Raise_From_Signal_Handler\n+        (E : Ada.Exceptions.Exception_Id;\n+         M : System.Address);\n+      pragma Import\n+        (Ada, Raise_From_Signal_Handler,\n+         \"ada__exceptions__raise_from_signal_handler\");\n+      pragma No_Return (Raise_From_Signal_Handler);\n+\n+      mstate  : Machine_State_Ptr;\n+      message : aliased constant String := \"\" & ASCII.Nul;\n+      --  a null terminated String.\n+\n+   begin\n+      if Self_Id.Deferral_Level = 0\n+        and then Self_Id.Pending_ATC_Level < Self_Id.ATC_Nesting_Level\n+        and then not Self_Id.Aborting\n+      then\n+         Self_Id.Aborting := True;\n+\n+         --  Make sure signals used for RTS internal purpose are unmasked\n+\n+         Result := pthread_sigmask (SIG_UNBLOCK,\n+           Unblocked_Signal_Mask'Unchecked_Access, Old_Set'Unchecked_Access);\n+         pragma Assert (Result = 0);\n+\n+         mstate := To_Machine_State_Ptr (SSL.Get_Machine_State_Addr.all);\n+         mstate.eip := eip;\n+         mstate.ebx := ebx;\n+         mstate.esp := esp_at_signal;\n+         mstate.ebp := ebp;\n+         mstate.esi := esi;\n+         mstate.edi := edi;\n+\n+         Raise_From_Signal_Handler\n+           (Standard'Abort_Signal'Identity, message'Address);\n+      end if;\n+   end Abort_Handler;\n+\n+   -------------------\n+   --  Stack_Guard  --\n+   -------------------\n+\n+   --  The underlying thread system extends the memory (up to 2MB) when\n+   --  needed.\n+\n+   procedure Stack_Guard (T : ST.Task_ID; On : Boolean) is\n+   begin\n+      null;\n+   end Stack_Guard;\n+\n+   --------------------\n+   -- Get_Thread_Id  --\n+   --------------------\n+\n+   function Get_Thread_Id (T : ST.Task_ID) return OSI.Thread_Id is\n+   begin\n+      return T.Common.LL.Thread;\n+   end Get_Thread_Id;\n+\n+   ----------\n+   -- Self --\n+   ----------\n+\n+   function Self return Task_ID is\n+      Result : System.Address;\n+\n+   begin\n+      Result := pthread_getspecific (ATCB_Key);\n+      pragma Assert (Result /= System.Null_Address);\n+      return To_Task_ID (Result);\n+   end Self;\n+\n+   ---------------------\n+   -- Initialize_Lock --\n+   ---------------------\n+\n+   --  Note: mutexes and cond_variables needed per-task basis are\n+   --        initialized in Intialize_TCB and the Storage_Error is\n+   --        handled. Other mutexes (such as All_Tasks_Lock, Memory_Lock...)\n+   --        used in RTS is initialized before any status change of RTS.\n+   --        Therefore rasing Storage_Error in the following routines\n+   --        should be able to be handled safely.\n+\n+   procedure Initialize_Lock\n+     (Prio : System.Any_Priority;\n+      L    : access Lock)\n+   is\n+      Result : Interfaces.C.int;\n+   begin\n+      if Priority_Ceiling_Emulation then\n+         L.Ceiling := Prio;\n+      end if;\n+\n+      Result := pthread_mutex_init (L.L'Access, Mutex_Attr'Access);\n+\n+      pragma Assert (Result = 0 or else Result = ENOMEM);\n+\n+      if Result = ENOMEM then\n+         Ada.Exceptions.Raise_Exception (Storage_Error'Identity,\n+           \"Failed to allocate a lock\");\n+      end if;\n+   end Initialize_Lock;\n+\n+   procedure Initialize_Lock (L : access RTS_Lock; Level : Lock_Level) is\n+      Result : Interfaces.C.int;\n+\n+   begin\n+      Result := pthread_mutex_init (L, Mutex_Attr'Access);\n+\n+      pragma Assert (Result = 0 or else Result = ENOMEM);\n+\n+      if Result = ENOMEM then\n+         raise Storage_Error;\n+      end if;\n+   end Initialize_Lock;\n+\n+   -------------------\n+   -- Finalize_Lock --\n+   -------------------\n+\n+   procedure Finalize_Lock (L : access Lock) is\n+      Result : Interfaces.C.int;\n+\n+   begin\n+      Result := pthread_mutex_destroy (L.L'Access);\n+      pragma Assert (Result = 0);\n+   end Finalize_Lock;\n+\n+   procedure Finalize_Lock (L : access RTS_Lock) is\n+      Result : Interfaces.C.int;\n+\n+   begin\n+      Result := pthread_mutex_destroy (L);\n+      pragma Assert (Result = 0);\n+   end Finalize_Lock;\n+\n+   ----------------\n+   -- Write_Lock --\n+   ----------------\n+\n+   procedure Write_Lock (L : access Lock; Ceiling_Violation : out Boolean) is\n+      Result : Interfaces.C.int;\n+\n+   begin\n+      if Priority_Ceiling_Emulation then\n+         declare\n+            Self_ID : constant Task_ID := Self;\n+         begin\n+            if Self_ID.Common.LL.Active_Priority > L.Ceiling then\n+               Ceiling_Violation := True;\n+               return;\n+            end if;\n+            L.Saved_Priority := Self_ID.Common.LL.Active_Priority;\n+            if Self_ID.Common.LL.Active_Priority < L.Ceiling then\n+               Self_ID.Common.LL.Active_Priority := L.Ceiling;\n+            end if;\n+            Result := pthread_mutex_lock (L.L'Access);\n+            pragma Assert (Result = 0);\n+            Ceiling_Violation := False;\n+         end;\n+      else\n+         Result := pthread_mutex_lock (L.L'Access);\n+         Ceiling_Violation := Result = EINVAL;\n+         --  assumes the cause of EINVAL is a priority ceiling violation\n+         pragma Assert (Result = 0 or else Result = EINVAL);\n+      end if;\n+   end Write_Lock;\n+\n+   procedure Write_Lock (L : access RTS_Lock) is\n+      Result : Interfaces.C.int;\n+\n+   begin\n+      Result := pthread_mutex_lock (L);\n+      pragma Assert (Result = 0);\n+   end Write_Lock;\n+\n+   procedure Write_Lock (T : Task_ID) is\n+      Result : Interfaces.C.int;\n+\n+   begin\n+      Result := pthread_mutex_lock (T.Common.LL.L'Access);\n+      pragma Assert (Result = 0);\n+   end Write_Lock;\n+\n+   ---------------\n+   -- Read_Lock --\n+   ---------------\n+\n+   procedure Read_Lock (L : access Lock; Ceiling_Violation : out Boolean) is\n+   begin\n+      Write_Lock (L, Ceiling_Violation);\n+   end Read_Lock;\n+\n+   ------------\n+   -- Unlock --\n+   ------------\n+\n+   procedure Unlock (L : access Lock) is\n+      Result : Interfaces.C.int;\n+\n+   begin\n+      if Priority_Ceiling_Emulation then\n+         declare\n+            Self_ID : constant Task_ID := Self;\n+         begin\n+            Result := pthread_mutex_unlock (L.L'Access);\n+            pragma Assert (Result = 0);\n+            if Self_ID.Common.LL.Active_Priority > L.Saved_Priority then\n+               Self_ID.Common.LL.Active_Priority := L.Saved_Priority;\n+            end if;\n+         end;\n+      else\n+         Result := pthread_mutex_unlock (L.L'Access);\n+         pragma Assert (Result = 0);\n+      end if;\n+   end Unlock;\n+\n+   procedure Unlock (L : access RTS_Lock) is\n+      Result : Interfaces.C.int;\n+      --  Beware of any changes to this that might\n+      --  require access to the ATCB after the mutex is unlocked.\n+      --  This is the last operation performed by a task\n+      --  before it allows its ATCB to be deallocated, so it\n+      --  MUST NOT refer to the ATCB.\n+\n+   begin\n+      Result := pthread_mutex_unlock (L);\n+      pragma Assert (Result = 0);\n+   end Unlock;\n+\n+   procedure Unlock (T : Task_ID) is\n+      Result : Interfaces.C.int;\n+\n+   begin\n+      Result := pthread_mutex_unlock (T.Common.LL.L'Access);\n+      pragma Assert (Result = 0);\n+   end Unlock;\n+\n+   -------------\n+   --  Sleep  --\n+   -------------\n+\n+   procedure Sleep (Self_ID : Task_ID;\n+                    Reason   : System.Tasking.Task_States) is\n+      Result : Interfaces.C.int;\n+\n+   begin\n+      pragma Assert (Self_ID = Self);\n+      Result := pthread_cond_wait (Self_ID.Common.LL.CV'Access,\n+        Self_ID.Common.LL.L'Access);\n+      --  EINTR is not considered a failure.\n+      pragma Assert (Result = 0 or else Result = EINTR);\n+   end Sleep;\n+\n+   -----------------\n+   -- Timed_Sleep --\n+   -----------------\n+\n+   --  This is for use within the run-time system, so abort is\n+   --  assumed to be already deferred, and the caller should be\n+   --  holding its own ATCB lock.\n+\n+   procedure Timed_Sleep\n+     (Self_ID  : Task_ID;\n+      Time     : Duration;\n+      Mode     : ST.Delay_Modes;\n+      Reason   : System.Tasking.Task_States;\n+      Timedout : out Boolean;\n+      Yielded  : out Boolean)\n+   is\n+      Check_Time : constant Duration := Monotonic_Clock;\n+      Abs_Time   : Duration;\n+      Request    : aliased timespec;\n+      Result     : Interfaces.C.int;\n+   begin\n+      Timedout := True;\n+      Yielded := False;\n+\n+      if Mode = Relative then\n+         Abs_Time := Duration'Min (Time, Max_Sensible_Delay) + Check_Time;\n+      else\n+         Abs_Time := Duration'Min (Check_Time + Max_Sensible_Delay, Time);\n+      end if;\n+\n+      if Abs_Time > Check_Time then\n+         Request := To_Timespec (Abs_Time);\n+\n+         loop\n+            exit when Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level\n+              or else Self_ID.Pending_Priority_Change;\n+\n+            Result := pthread_cond_timedwait\n+              (Self_ID.Common.LL.CV'Access, Self_ID.Common.LL.L'Access,\n+               Request'Access);\n+\n+            exit when Abs_Time <= Monotonic_Clock;\n+\n+            if Result = 0 or Result = EINTR then\n+               --  somebody may have called Wakeup for us\n+               Timedout := False;\n+               exit;\n+            end if;\n+\n+            pragma Assert (Result = ETIMEDOUT);\n+         end loop;\n+      end if;\n+   end Timed_Sleep;\n+\n+   -----------------\n+   -- Timed_Delay --\n+   -----------------\n+\n+   --  This is for use in implementing delay statements, so\n+   --  we assume the caller is abort-deferred but is holding\n+   --  no locks.\n+\n+   procedure Timed_Delay\n+     (Self_ID  : Task_ID;\n+      Time     : Duration;\n+      Mode     : ST.Delay_Modes)\n+   is\n+      Check_Time : constant Duration := Monotonic_Clock;\n+      Abs_Time   : Duration;\n+      Request    : aliased timespec;\n+      Result     : Interfaces.C.int;\n+   begin\n+\n+      --  Only the little window between deferring abort and\n+      --  locking Self_ID is the reason we need to\n+      --  check for pending abort and priority change below! :(\n+\n+      SSL.Abort_Defer.all;\n+      Write_Lock (Self_ID);\n+\n+      if Mode = Relative then\n+         Abs_Time := Time + Check_Time;\n+      else\n+         Abs_Time := Duration'Min (Check_Time + Max_Sensible_Delay, Time);\n+      end if;\n+\n+      if Abs_Time > Check_Time then\n+         Request := To_Timespec (Abs_Time);\n+         Self_ID.Common.State := Delay_Sleep;\n+\n+         loop\n+            if Self_ID.Pending_Priority_Change then\n+               Self_ID.Pending_Priority_Change := False;\n+               Self_ID.Common.Base_Priority := Self_ID.New_Base_Priority;\n+               Set_Priority (Self_ID, Self_ID.Common.Base_Priority);\n+            end if;\n+\n+            exit when Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level;\n+\n+            Result := pthread_cond_timedwait (Self_ID.Common.LL.CV'Access,\n+              Self_ID.Common.LL.L'Access, Request'Access);\n+\n+            exit when Abs_Time <= Monotonic_Clock;\n+\n+            pragma Assert (Result = 0 or else\n+              Result = ETIMEDOUT or else\n+              Result = EINTR);\n+         end loop;\n+\n+         Self_ID.Common.State := Runnable;\n+      end if;\n+\n+      Unlock (Self_ID);\n+      Result := sched_yield;\n+      SSL.Abort_Undefer.all;\n+   end Timed_Delay;\n+\n+   ---------------------\n+   -- Monotonic_Clock --\n+   ---------------------\n+\n+   function Monotonic_Clock return Duration is\n+      TV     : aliased struct_timeval;\n+      Result : Interfaces.C.int;\n+\n+   begin\n+      Result := gettimeofday (TV'Access, System.Null_Address);\n+      pragma Assert (Result = 0);\n+      return To_Duration (TV);\n+   end Monotonic_Clock;\n+\n+   -------------------\n+   -- RT_Resolution --\n+   -------------------\n+\n+   function RT_Resolution return Duration is\n+   begin\n+      return 10#1.0#E-6;\n+   end RT_Resolution;\n+\n+   ------------\n+   -- Wakeup --\n+   ------------\n+\n+   procedure Wakeup (T : Task_ID; Reason : System.Tasking.Task_States) is\n+      Result : Interfaces.C.int;\n+\n+   begin\n+      Result := pthread_cond_signal (T.Common.LL.CV'Access);\n+      pragma Assert (Result = 0);\n+   end Wakeup;\n+\n+   -----------\n+   -- Yield --\n+   -----------\n+\n+   procedure Yield (Do_Yield : Boolean := True) is\n+      Result : Interfaces.C.int;\n+\n+   begin\n+      if Do_Yield then\n+         Result := sched_yield;\n+      end if;\n+   end Yield;\n+\n+   ------------------\n+   -- Set_Priority --\n+   ------------------\n+\n+   procedure Set_Priority\n+     (T : Task_ID;\n+      Prio : System.Any_Priority;\n+      Loss_Of_Inheritance : Boolean := False)\n+   is\n+      Result : Interfaces.C.int;\n+      Param  : aliased struct_sched_param;\n+\n+   begin\n+      T.Common.Current_Priority := Prio;\n+\n+      if Priority_Ceiling_Emulation then\n+         if T.Common.LL.Active_Priority < Prio then\n+            T.Common.LL.Active_Priority := Prio;\n+         end if;\n+      end if;\n+\n+      --  Priorities are in range 1 .. 99 on Linux, so map 0 .. 31 to 1 .. 32\n+      Param.sched_priority := Interfaces.C.int (Prio) + 1;\n+\n+      if Time_Slice_Val > 0 then\n+         Result := pthread_setschedparam\n+           (T.Common.LL.Thread, SCHED_RR, Param'Access);\n+\n+      elsif FIFO_Within_Priorities or else Time_Slice_Val = 0 then\n+         Result := pthread_setschedparam\n+           (T.Common.LL.Thread, SCHED_FIFO, Param'Access);\n+\n+      else\n+         Result := pthread_setschedparam\n+           (T.Common.LL.Thread, SCHED_OTHER, Param'Access);\n+      end if;\n+\n+      pragma Assert (Result = 0 or else Result = EPERM);\n+   end Set_Priority;\n+\n+   ------------------\n+   -- Get_Priority --\n+   ------------------\n+\n+   function Get_Priority (T : Task_ID) return System.Any_Priority is\n+   begin\n+      return T.Common.Current_Priority;\n+   end Get_Priority;\n+\n+   ----------------\n+   -- Enter_Task --\n+   ----------------\n+\n+   procedure Enter_Task (Self_ID : Task_ID) is\n+      Result : Interfaces.C.int;\n+\n+   begin\n+      Self_ID.Common.LL.Thread := pthread_self;\n+\n+      Result := pthread_setspecific (ATCB_Key, To_Address (Self_ID));\n+      pragma Assert (Result = 0);\n+\n+      Lock_All_Tasks_List;\n+      for I in Known_Tasks'Range loop\n+         if Known_Tasks (I) = null then\n+            Known_Tasks (I) := Self_ID;\n+            Self_ID.Known_Tasks_Index := I;\n+            exit;\n+         end if;\n+      end loop;\n+      Unlock_All_Tasks_List;\n+   end Enter_Task;\n+\n+   --------------\n+   -- New_ATCB --\n+   --------------\n+\n+   function New_ATCB (Entry_Num : Task_Entry_Index) return Task_ID is\n+   begin\n+      return new Ada_Task_Control_Block (Entry_Num);\n+   end New_ATCB;\n+\n+   --------------------\n+   -- Initialize_TCB --\n+   --------------------\n+\n+   procedure Initialize_TCB (Self_ID : Task_ID; Succeeded : out Boolean) is\n+      Result : Interfaces.C.int;\n+\n+   begin\n+      --  Give the task a unique serial number.\n+\n+      Self_ID.Serial_Number := Next_Serial_Number;\n+      Next_Serial_Number := Next_Serial_Number + 1;\n+      pragma Assert (Next_Serial_Number /= 0);\n+\n+      Self_ID.Common.LL.Thread := To_pthread_t (-1);\n+\n+      Result := pthread_mutex_init (Self_ID.Common.LL.L'Access,\n+        Mutex_Attr'Access);\n+      pragma Assert (Result = 0 or else Result = ENOMEM);\n+\n+      if Result /= 0 then\n+         Succeeded := False;\n+         return;\n+      end if;\n+\n+      Result := pthread_cond_init (Self_ID.Common.LL.CV'Access,\n+        Cond_Attr'Access);\n+      pragma Assert (Result = 0 or else Result = ENOMEM);\n+\n+      if Result = 0 then\n+         Succeeded := True;\n+      else\n+         Result := pthread_mutex_destroy (Self_ID.Common.LL.L'Access);\n+         pragma Assert (Result = 0);\n+         Succeeded := False;\n+      end if;\n+\n+      Result := pthread_condattr_destroy (Cond_Attr'Access);\n+      pragma Assert (Result = 0);\n+   end Initialize_TCB;\n+\n+   -----------------\n+   -- Create_Task --\n+   -----------------\n+\n+   procedure Create_Task\n+     (T          : Task_ID;\n+      Wrapper    : System.Address;\n+      Stack_Size : System.Parameters.Size_Type;\n+      Priority   : System.Any_Priority;\n+      Succeeded  : out Boolean)\n+   is\n+      Attributes : aliased pthread_attr_t;\n+      Result     : Interfaces.C.int;\n+\n+      function Thread_Body_Access is new\n+        Unchecked_Conversion (System.Address, Thread_Body);\n+\n+   begin\n+      Result := pthread_attr_init (Attributes'Access);\n+      pragma Assert (Result = 0 or else Result = ENOMEM);\n+\n+      if Result /= 0 or else Stack_Size > Max_Stack_Size then\n+         Succeeded := False;\n+         return;\n+      end if;\n+\n+      Result := pthread_attr_setdetachstate\n+        (Attributes'Access, PTHREAD_CREATE_DETACHED);\n+      pragma Assert (Result = 0);\n+\n+      --  Since the initial signal mask of a thread is inherited from the\n+      --  creator, and the Environment task has all its signals masked, we\n+      --  do not need to manipulate caller's signal mask at this point.\n+      --  All tasks in RTS will have All_Tasks_Mask initially.\n+\n+      Result := pthread_create\n+        (T.Common.LL.Thread'Access,\n+         Attributes'Access,\n+         Thread_Body_Access (Wrapper),\n+         To_Address (T));\n+      pragma Assert (Result = 0 or else Result = EAGAIN);\n+\n+      Succeeded := Result = 0;\n+\n+      Result := pthread_attr_destroy (Attributes'Access);\n+      pragma Assert (Result = 0);\n+\n+      Set_Priority (T, Priority);\n+   end Create_Task;\n+\n+   ------------------\n+   -- Finalize_TCB --\n+   ------------------\n+\n+   procedure Finalize_TCB (T : Task_ID) is\n+      Result : Interfaces.C.int;\n+      Tmp    : Task_ID := T;\n+\n+      procedure Free is new\n+        Unchecked_Deallocation (Ada_Task_Control_Block, Task_ID);\n+\n+   begin\n+      Result := pthread_mutex_destroy (T.Common.LL.L'Access);\n+      pragma Assert (Result = 0);\n+      Result := pthread_cond_destroy (T.Common.LL.CV'Access);\n+      pragma Assert (Result = 0);\n+      if T.Known_Tasks_Index /= -1 then\n+         Known_Tasks (T.Known_Tasks_Index) := null;\n+      end if;\n+      Free (Tmp);\n+   end Finalize_TCB;\n+\n+   ---------------\n+   -- Exit_Task --\n+   ---------------\n+\n+   procedure Exit_Task is\n+   begin\n+      pthread_exit (System.Null_Address);\n+   end Exit_Task;\n+\n+   ----------------\n+   -- Abort_Task --\n+   ----------------\n+\n+   procedure Abort_Task (T : Task_ID) is\n+      Result : Interfaces.C.int;\n+\n+   begin\n+      Result := pthread_kill (T.Common.LL.Thread,\n+        Signal (System.Interrupt_Management.Abort_Task_Interrupt));\n+      pragma Assert (Result = 0);\n+   end Abort_Task;\n+\n+   ----------------\n+   -- Check_Exit --\n+   ----------------\n+\n+   --  Dummy versions.  The only currently working versions is for solaris\n+   --  (native).\n+\n+   function Check_Exit (Self_ID : ST.Task_ID) return Boolean is\n+   begin\n+      return True;\n+   end Check_Exit;\n+\n+   --------------------\n+   -- Check_No_Locks --\n+   --------------------\n+\n+   function Check_No_Locks (Self_ID : ST.Task_ID) return Boolean is\n+   begin\n+      return True;\n+   end Check_No_Locks;\n+\n+   ----------------------\n+   -- Environment_Task --\n+   ----------------------\n+\n+   function Environment_Task return Task_ID is\n+   begin\n+      return Environment_Task_ID;\n+   end Environment_Task;\n+\n+   -------------------------\n+   -- Lock_All_Tasks_List --\n+   -------------------------\n+\n+   procedure Lock_All_Tasks_List is\n+   begin\n+      Write_Lock (All_Tasks_L'Access);\n+   end Lock_All_Tasks_List;\n+\n+   ---------------------------\n+   -- Unlock_All_Tasks_List --\n+   ---------------------------\n+\n+   procedure Unlock_All_Tasks_List is\n+   begin\n+      Unlock (All_Tasks_L'Access);\n+   end Unlock_All_Tasks_List;\n+\n+   ------------------\n+   -- Suspend_Task --\n+   ------------------\n+\n+   function Suspend_Task\n+     (T           : ST.Task_ID;\n+      Thread_Self : Thread_Id) return Boolean is\n+   begin\n+      if T.Common.LL.Thread /= Thread_Self then\n+         return pthread_kill (T.Common.LL.Thread, SIGSTOP) = 0;\n+      else\n+         return True;\n+      end if;\n+   end Suspend_Task;\n+\n+   -----------------\n+   -- Resume_Task --\n+   -----------------\n+\n+   function Resume_Task\n+     (T           : ST.Task_ID;\n+      Thread_Self : Thread_Id) return Boolean is\n+   begin\n+      if T.Common.LL.Thread /= Thread_Self then\n+         return pthread_kill (T.Common.LL.Thread, SIGCONT) = 0;\n+      else\n+         return True;\n+      end if;\n+   end Resume_Task;\n+\n+   ----------------\n+   -- Initialize --\n+   ----------------\n+\n+   procedure Initialize (Environment_Task : Task_ID) is\n+      act       : aliased struct_sigaction;\n+      old_act   : aliased struct_sigaction;\n+      Tmp_Set   : aliased sigset_t;\n+      Result    : Interfaces.C.int;\n+\n+   begin\n+      Environment_Task_ID := Environment_Task;\n+\n+      Result := pthread_mutexattr_init (Mutex_Attr'Access);\n+      pragma Assert (Result = 0 or else Result = ENOMEM);\n+\n+      Result := pthread_condattr_init (Cond_Attr'Access);\n+      pragma Assert (Result = 0 or else Result = ENOMEM);\n+\n+      Initialize_Lock (All_Tasks_L'Access, All_Tasks_Level);\n+      --  Initialize the lock used to synchronize chain of all ATCBs.\n+\n+      Enter_Task (Environment_Task);\n+\n+      --  Install the abort-signal handler\n+\n+      act.sa_flags := 0;\n+      act.sa_handler := Abort_Handler'Address;\n+\n+      Result := sigemptyset (Tmp_Set'Access);\n+      pragma Assert (Result = 0);\n+      act.sa_mask := Tmp_Set;\n+\n+      Result :=\n+        sigaction\n+          (Signal (Interrupt_Management.Abort_Task_Interrupt),\n+           act'Unchecked_Access,\n+           old_act'Unchecked_Access);\n+      pragma Assert (Result = 0);\n+   end Initialize;\n+\n+begin\n+   declare\n+      Result : Interfaces.C.int;\n+   begin\n+      --  Mask Environment task for all signals. The original mask of the\n+      --  Environment task will be recovered by Interrupt_Server task\n+      --  during the elaboration of s-interr.adb.\n+\n+      System.Interrupt_Management.Operations.Set_Interrupt_Mask\n+        (System.Interrupt_Management.Operations.All_Tasks_Mask'Access);\n+\n+      --  Prepare the set of signals that should unblocked in all tasks\n+\n+      Result := sigemptyset (Unblocked_Signal_Mask'Access);\n+      pragma Assert (Result = 0);\n+\n+      for J in Interrupt_Management.Interrupt_ID loop\n+         if System.Interrupt_Management.Keep_Unmasked (J) then\n+            Result := sigaddset (Unblocked_Signal_Mask'Access, Signal (J));\n+            pragma Assert (Result = 0);\n+         end if;\n+      end loop;\n+\n+      Result := pthread_key_create (ATCB_Key'Access, null);\n+      pragma Assert (Result = 0);\n+   end;\n+\n+end System.Task_Primitives.Operations;"}, {"sha": "0360c2999a198924327c3f8517db91e46789fb33", "filename": "gcc/ada/5itaspri.ads", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5itaspri.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5itaspri.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5itaspri.ads?ref=84481f762f0682e5f45b2f360446e1c7e333c880", "patch": "@@ -0,0 +1,99 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS               --\n+--                                                                          --\n+--                 S Y S T E M . T A S K _ P R I M I T I V E S              --\n+--                                                                          --\n+--                                  S p e c                                 --\n+--                                                                          --\n+--                             $Revision: 1.5 $\n+--                                                                          --\n+--           Copyright (C) 1991-2000 Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNARL is free software; you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion. GNARL is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNARL; see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNARL was developed by the GNARL team at Florida State University. It is --\n+-- now maintained by Ada Core Technologies Inc. in cooperation with Florida --\n+-- State University (http://www.gnat.com).                                  --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is the Linux (LinuxThreads) version of this package.\n+\n+--  This package provides low-level support for most tasking features.\n+\n+pragma Polling (Off);\n+--  Turn off polling, we do not want ATC polling to take place during\n+--  tasking operations. It causes infinite loops and other problems.\n+\n+with System.OS_Interface;\n+--  used for pthread_mutex_t\n+--           pthread_cond_t\n+--           pthread_t\n+\n+package System.Task_Primitives is\n+\n+   type Lock is limited private;\n+   --  Should be used for implementation of protected objects.\n+\n+   type RTS_Lock is limited private;\n+   --  Should be used inside the runtime system.\n+   --  The difference between Lock and the RTS_Lock is that the later\n+   --  one serves only as a semaphore so that do not check for\n+   --  ceiling violations.\n+\n+   type Task_Body_Access is access procedure;\n+   --  Pointer to the task body's entry point (or possibly a wrapper\n+   --  declared local to the GNARL).\n+\n+   type Private_Data is limited private;\n+   --  Any information that the GNULLI needs maintained on a per-task\n+   --  basis.  A component of this type is guaranteed to be included\n+   --  in the Ada_Task_Control_Block.\n+\n+private\n+\n+   type Prio_Array_Type is array (System.Any_Priority) of Integer;\n+\n+   type Lock is record\n+      L          : aliased System.OS_Interface.pthread_mutex_t;\n+      Ceiling    : System.Any_Priority := System.Any_Priority'First;\n+      Saved_Priority : System.Any_Priority := System.Any_Priority'First;\n+   end record;\n+\n+   type RTS_Lock is new System.OS_Interface.pthread_mutex_t;\n+   type Private_Data is record\n+      Thread      : aliased System.OS_Interface.pthread_t;\n+      pragma Atomic (Thread);\n+      --  Thread field may be updated by two different threads of control.\n+      --  (See, Enter_Task and Create_Task in s-taprop.adb).\n+      --  They put the same value (thr_self value). We do not want to\n+      --  use lock on those operations and the only thing we have to\n+      --  make sure is that they are updated in atomic fashion.\n+\n+      CV          : aliased System.OS_Interface.pthread_cond_t;\n+      L           : aliased RTS_Lock;\n+      --  protection for all components is lock L\n+\n+      Active_Priority : System.Any_Priority := System.Any_Priority'First;\n+      --  Simulated active priority,\n+      --  used only if Priority_Ceiling_Support is True.\n+   end record;\n+\n+end System.Task_Primitives;"}, {"sha": "d3d9a66f609c066904d2ee833c39c66a1fb1653c", "filename": "gcc/ada/5ksystem.ads", "status": "added", "additions": 159, "deletions": 0, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5ksystem.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5ksystem.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5ksystem.ads?ref=84481f762f0682e5f45b2f360446e1c7e333c880", "patch": "@@ -0,0 +1,159 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                        GNAT RUN-TIME COMPONENTS                          --\n+--                                                                          --\n+--                               S Y S T E M                                --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                          (VxWorks version M68K)                          --\n+--                                                                          --\n+--                            $Revision: 1.11 $\n+--                                                                          --\n+--          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+package System is\n+pragma Pure (System);\n+--  Note that we take advantage of the implementation permission to\n+--  make this unit Pure instead of Preelaborable, see RM 13.7(36)\n+\n+   type Name is (SYSTEM_NAME_GNAT);\n+   System_Name : constant Name := SYSTEM_NAME_GNAT;\n+\n+   --  System-Dependent Named Numbers\n+\n+   Min_Int               : constant := Long_Long_Integer'First;\n+   Max_Int               : constant := Long_Long_Integer'Last;\n+\n+   Max_Binary_Modulus    : constant := 2 ** Long_Long_Integer'Size;\n+   Max_Nonbinary_Modulus : constant := Integer'Last;\n+\n+   Max_Base_Digits       : constant := Long_Long_Float'Digits;\n+   Max_Digits            : constant := Long_Long_Float'Digits;\n+\n+   Max_Mantissa          : constant := 63;\n+   Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);\n+\n+   Tick                  : constant := Standard'Tick;\n+\n+   --  Storage-related Declarations\n+\n+   type Address is private;\n+   Null_Address : constant Address;\n+\n+   Storage_Unit : constant := Standard'Storage_Unit;\n+   Word_Size    : constant := Standard'Word_Size;\n+   Memory_Size  : constant := 2 ** Standard'Address_Size;\n+\n+   --  Address comparison\n+\n+   function \"<\"  (Left, Right : Address) return Boolean;\n+   function \"<=\" (Left, Right : Address) return Boolean;\n+   function \">\"  (Left, Right : Address) return Boolean;\n+   function \">=\" (Left, Right : Address) return Boolean;\n+   function \"=\"  (Left, Right : Address) return Boolean;\n+\n+   pragma Import (Intrinsic, \"<\");\n+   pragma Import (Intrinsic, \"<=\");\n+   pragma Import (Intrinsic, \">\");\n+   pragma Import (Intrinsic, \">=\");\n+   pragma Import (Intrinsic, \"=\");\n+\n+   --  Other System-Dependent Declarations\n+\n+   type Bit_Order is (High_Order_First, Low_Order_First);\n+   Default_Bit_Order : constant Bit_Order :=\n+                         Bit_Order'Val (Standard'Default_Bit_Order);\n+\n+   --  Priority-related Declarations (RM D.1)\n+\n+   --  256 is reserved for the VxWorks kernel\n+   --  248 - 255 correspond to hardware interrupt levels 0 .. 7\n+   --  247 is a catchall default \"interrupt\" priority for signals, allowing\n+   --  higher priority than normal tasks, but lower than hardware\n+   --  priority levels.  Protected Object ceilings can override\n+   --  these values\n+   --  246 is used by the Interrupt_Manager task\n+\n+   Max_Priority : constant Positive := 245;\n+\n+   Max_Interrupt_Priority : constant Positive := 255;\n+\n+   subtype Any_Priority is Integer\n+     range 0 .. Standard'Max_Interrupt_Priority;\n+\n+   subtype Priority is Any_Priority\n+     range 0 .. Standard'Max_Priority;\n+\n+   --  Functional notation is needed in the following to avoid visibility\n+   --  problems when this package is compiled through rtsfind in the middle\n+   --  of another compilation.\n+\n+   subtype Interrupt_Priority is Any_Priority\n+     range\n+       Standard.\"+\" (Standard'Max_Priority,  1) ..\n+         Standard'Max_Interrupt_Priority;\n+\n+   Default_Priority : constant Priority :=\n+     Standard.\"/\" (Standard.\"+\" (Priority'First, Priority'Last), 2);\n+\n+private\n+\n+   type Address is mod Memory_Size;\n+   Null_Address : constant Address := 0;\n+\n+   --------------------------------------\n+   -- System Implementation Parameters --\n+   --------------------------------------\n+\n+   --  These parameters provide information about the target that is used\n+   --  by the compiler. They are in the private part of System, where they\n+   --  can be accessed using the special circuitry in the Targparm unit\n+   --  whose source should be consulted for more detailed descriptions\n+   --  of the individual switch values.\n+\n+   AAMP                      : constant Boolean := False;\n+   Command_Line_Args         : constant Boolean := False;\n+   Denorm                    : constant Boolean := True;\n+   Frontend_Layout           : constant Boolean := False;\n+   Functions_Return_By_DSP   : constant Boolean := False;\n+   Long_Shifts_Inlined       : constant Boolean := False;\n+   High_Integrity_Mode       : constant Boolean := False;\n+   Machine_Overflows         : constant Boolean := False;\n+   Machine_Rounds            : constant Boolean := True;\n+   OpenVMS                   : constant Boolean := False;\n+   Signed_Zeros              : constant Boolean := False;\n+   Stack_Check_Default       : constant Boolean := False;\n+   Stack_Check_Probes        : constant Boolean := False;\n+   Use_Ada_Main_Program_Name : constant Boolean := True;\n+   ZCX_By_Default            : constant Boolean := False;\n+   GCC_ZCX_Support           : constant Boolean := False;\n+   Front_End_ZCX_Support     : constant Boolean := False;\n+\n+end System;"}, {"sha": "85cbe3d802139d36d97f9e4d0e37a945c2384279", "filename": "gcc/ada/5kvxwork.ads", "status": "added", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5kvxwork.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5kvxwork.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5kvxwork.ads?ref=84481f762f0682e5f45b2f360446e1c7e333c880", "patch": "@@ -0,0 +1,121 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                 GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS              --\n+--                                                                          --\n+--                        S Y S T E M . V X W O R K S                       --\n+--                                                                          --\n+--                                   S p e c                                --\n+--                                                                          --\n+--                             $Revision: 1.2 $\n+--                                                                          --\n+--            Copyright (C) 1998-2001 Free Software Foundation              --\n+--                                                                          --\n+-- GNARL is free software; you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion. GNARL is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNARL; see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNARL was developed by the GNARL team at Florida State University. It is --\n+-- now maintained by Ada Core Technologies Inc. in cooperation with Florida --\n+-- State University (http://www.gnat.com).                                  --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is the M68K VxWorks version of this package.\n+\n+with Interfaces.C;\n+\n+package System.VxWorks is\n+   pragma Preelaborate (System.VxWorks);\n+\n+   package IC renames Interfaces.C;\n+\n+   --  Define enough of a Wind Task Control Block in order to\n+   --  obtain the inherited priority.  When porting this to\n+   --  different versions of VxWorks (this is based on 5.3[.1]),\n+   --  be sure to look at the definition for WIND_TCB located\n+   --  in $WIND_BASE/target/h/taskLib.h\n+\n+   type Wind_Fill_1 is array (0 .. 16#3F#) of IC.unsigned_char;\n+   type Wind_Fill_2 is array (16#48# .. 16#107#) of IC.unsigned_char;\n+\n+   type Wind_TCB is record\n+      Fill_1          : Wind_Fill_1; -- 0x00 - 0x3f\n+      Priority        : IC.int;  -- 0x40 - 0x43, current (inherited) priority\n+      Normal_Priority : IC.int;  -- 0x44 - 0x47, base priority\n+      Fill_2          : Wind_Fill_2; -- 0x48 - 0x107\n+      spare1          : Address;  -- 0x108 - 0x10b\n+      spare2          : Address;  -- 0x10c - 0x10f\n+      spare3          : Address;  -- 0x110 - 0x113\n+      spare4          : Address;  -- 0x114 - 0x117\n+   end record;\n+   type Wind_TCB_Ptr is access Wind_TCB;\n+\n+   --  Floating point context record.  68K version\n+\n+   FP_NUM_DREGS : constant := 8;\n+   FP_STATE_FRAME_SIZE : constant := 216;\n+\n+   type DOUBLEX is array (1 .. 12) of Interfaces.Unsigned_8;\n+   pragma Pack (DOUBLEX);\n+   for DOUBLEX'Size use 12 * 8;\n+\n+   type DOUBLEX_Array is array (1 .. FP_NUM_DREGS) of DOUBLEX;\n+   pragma Pack (DOUBLEX_Array);\n+   for DOUBLEX_Array'Size use FP_NUM_DREGS * 12 * 8;\n+\n+   type FPREG_SET is record\n+      fpcr  : IC.int;\n+      fpsr  : IC.int;\n+      fpiar : IC.int;\n+      fpx   : DOUBLEX_Array;\n+   end record;\n+\n+   type Fp_State_Frame_Array is array (1 .. FP_STATE_FRAME_SIZE) of IC.char;\n+   pragma Pack (Fp_State_Frame_Array);\n+   for Fp_State_Frame_Array'Size use 8 * FP_STATE_FRAME_SIZE;\n+\n+   type FP_CONTEXT is record\n+      fpRegSet   : FPREG_SET;\n+      stateFrame : Fp_State_Frame_Array;\n+   end record;\n+   pragma Convention (C, FP_CONTEXT);\n+\n+   Num_HW_Interrupts : constant := 256;\n+   --  Number of entries in the hardware interrupt vector table\n+\n+   --  VxWorks 5.3 and 5.4 version\n+   type TASK_DESC is record\n+      td_id           : IC.int;   --  task id\n+      td_name         : Address;  --  name of task\n+      td_priority     : IC.int;   --  task priority\n+      td_status       : IC.int;   --  task status\n+      td_options      : IC.int;   --  task option bits (see below)\n+      td_entry        : Address;  --  original entry point of task\n+      td_sp           : Address;  --  saved stack pointer\n+      td_pStackBase   : Address;  --  the bottom of the stack\n+      td_pStackLimit  : Address;  --  the effective end of the stack\n+      td_pStackEnd    : Address;  --  the actual end of the stack\n+      td_stackSize    : IC.int;   --  size of stack in bytes\n+      td_stackCurrent : IC.int;   --  current stack usage in bytes\n+      td_stackHigh    : IC.int;   --  maximum stack usage in bytes\n+      td_stackMargin  : IC.int;   --  current stack margin in bytes\n+      td_errorStatus  : IC.int;   --  most recent task error status\n+      td_delay        : IC.int;   --  delay/timeout ticks\n+   end record;\n+   pragma Convention (C, TASK_DESC);\n+\n+end System.VxWorks;"}, {"sha": "5361af7f2813d49ddf6746cc92b1a7d55e0f6ba2", "filename": "gcc/ada/5lintman.adb", "status": "added", "additions": 357, "deletions": 0, "changes": 357, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5lintman.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5lintman.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5lintman.adb?ref=84481f762f0682e5f45b2f360446e1c7e333c880", "patch": "@@ -0,0 +1,357 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS               --\n+--                                                                          --\n+--           S Y S T E M . I N T E R R U P T _ M A N A G E M E N T          --\n+--                                                                          --\n+--                                  B o d y                                 --\n+--                                                                          --\n+--                             $Revision: 1.18 $\n+--                                                                          --\n+--             Copyright (C) 1991-2001 Florida State University             --\n+--                                                                          --\n+-- GNARL is free software; you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion. GNARL is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNARL; see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNARL was developed by the GNARL team at Florida State University. It is --\n+-- now maintained by Ada Core Technologies Inc. in cooperation with Florida --\n+-- State University (http://www.gnat.com).                                  --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is the Linux version of this package\n+\n+--  This file performs the system-dependent translation between machine\n+--  exceptions and the Ada exceptions, if any, that should be raised when they\n+--  occur. This version works for the x86 running linux.\n+\n+--  This is a Sun OS (FSU THREADS) version of this package\n+\n+--  PLEASE DO NOT add any dependences on other packages. ??? why not ???\n+--  This package is designed to work with or without tasking support.\n+\n+--  Make a careful study of all signals available under the OS, to see which\n+--  need to be reserved, kept always unmasked, or kept always unmasked. Be on\n+--  the lookout for special signals that may be used by the thread library.\n+\n+--  The definitions of \"reserved\" differ slightly between the ARM and POSIX.\n+--  Here is the ARM definition of reserved interrupt:\n+\n+--  The set of reserved interrupts is implementation defined. A reserved\n+--  interrupt is either an interrupt for which user-defined handlers are not\n+--  supported, or one which already has an attached handler by some other\n+--  implementation-defined means. Program units can be connected to\n+--  non-reserved interrupts.\n+\n+--  POSIX.5b/.5c specifies further:\n+\n+--  Signals which the application cannot accept, and for which the application\n+--  cannot modify the signal action or masking, because the signals are\n+--  reserved for use by the Ada language implementation. The reserved signals\n+--  defined by this standard are Signal_Abort, Signal_Alarm,\n+--  Signal_Floating_Point_Error, Signal_Illegal_Instruction,\n+--  Signal_Segmentation_Violation, Signal_Bus_Error. If the implementation\n+--  supports any signals besides those defined by this standard, the\n+--  implementation may also reserve some of those.\n+\n+--  The signals defined by POSIX.5b/.5c that are not specified as being\n+--  reserved are SIGHUP, SIGINT, SIGPIPE, SIGQUIT, SIGTERM, SIGUSR1, SIGUSR2,\n+--  SIGCHLD, SIGCONT, SIGSTOP, SIGTSTP, SIGTTIN, SIGTTOU, SIGIO SIGURG, and all\n+--  the real-time signals.\n+\n+--  Beware of reserving signals that POSIX.5b/.5c require to be available for\n+--  users. POSIX.5b/.5c say:\n+\n+--  An implementation shall not impose restrictions on the ability of an\n+--  application to send, accept, block, or ignore the signals defined by this\n+--  standard, except as specified in this standard.\n+\n+--  Here are some other relevant requirements from POSIX.5b/.5c:\n+\n+--  For the environment task, the initial signal mask is that specified for\n+--  the process...\n+\n+--  It is anticipated that the paragraph above may be modified by a future\n+--  revision of this standard, to require that the realtime signals always be\n+--  initially masked for a process that is an Ada active partition.\n+\n+--  For all other tasks, the initial signal mask shall include all the signals\n+--  that are not reserved signals and are not bound to entries of the task.\n+\n+with Interfaces.C;\n+--  used for int and other types\n+\n+with System.Error_Reporting;\n+--  used for Shutdown\n+\n+with System.OS_Interface;\n+--  used for various Constants, Signal and types\n+\n+with Ada.Exceptions;\n+--  used for Exception_Id\n+--           Raise_From_Signal_Handler\n+\n+with System.Soft_Links;\n+--  used for Get_Machine_State_Addr\n+\n+with Unchecked_Conversion;\n+\n+package body System.Interrupt_Management is\n+\n+   use Interfaces.C;\n+   use System.Error_Reporting;\n+   use System.OS_Interface;\n+\n+   package TSL renames System.Soft_Links;\n+\n+   type Interrupt_List is array (Interrupt_ID range <>) of Interrupt_ID;\n+   Exception_Interrupts : constant Interrupt_List :=\n+     (SIGFPE, SIGILL, SIGSEGV);\n+\n+   Unreserve_All_Interrupts : Interfaces.C.int;\n+   pragma Import\n+     (C, Unreserve_All_Interrupts, \"__gl_unreserve_all_interrupts\");\n+\n+   subtype int is Interfaces.C.int;\n+   subtype unsigned_short is Interfaces.C.unsigned_short;\n+   subtype unsigned_long is Interfaces.C.unsigned_long;\n+\n+   ----------------------\n+   -- Notify_Exception --\n+   ----------------------\n+\n+   Signal_Mask : aliased sigset_t;\n+   --  The set of signals handled by Notify_Exception\n+\n+   --  This function identifies the Ada exception to be raised using\n+   --  the information when the system received a synchronous signal.\n+   --  Since this function is machine and OS dependent, different code\n+   --  has to be provided for different target.\n+\n+   procedure Notify_Exception\n+     (signo         : Signal;\n+      gs            : unsigned_short;\n+      fs            : unsigned_short;\n+      es            : unsigned_short;\n+      ds            : unsigned_short;\n+      edi           : unsigned_long;\n+      esi           : unsigned_long;\n+      ebp           : unsigned_long;\n+      esp           : unsigned_long;\n+      ebx           : unsigned_long;\n+      edx           : unsigned_long;\n+      ecx           : unsigned_long;\n+      eax           : unsigned_long;\n+      trapno        : unsigned_long;\n+      err           : unsigned_long;\n+      eip           : unsigned_long;\n+      cs            : unsigned_short;\n+      eflags        : unsigned_long;\n+      esp_at_signal : unsigned_long;\n+      ss            : unsigned_short;\n+      fpstate       : System.Address;\n+      oldmask       : unsigned_long;\n+      cr2           : unsigned_long);\n+\n+   procedure Notify_Exception\n+     (signo         : Signal;\n+      gs            : unsigned_short;\n+      fs            : unsigned_short;\n+      es            : unsigned_short;\n+      ds            : unsigned_short;\n+      edi           : unsigned_long;\n+      esi           : unsigned_long;\n+      ebp           : unsigned_long;\n+      esp           : unsigned_long;\n+      ebx           : unsigned_long;\n+      edx           : unsigned_long;\n+      ecx           : unsigned_long;\n+      eax           : unsigned_long;\n+      trapno        : unsigned_long;\n+      err           : unsigned_long;\n+      eip           : unsigned_long;\n+      cs            : unsigned_short;\n+      eflags        : unsigned_long;\n+      esp_at_signal : unsigned_long;\n+      ss            : unsigned_short;\n+      fpstate       : System.Address;\n+      oldmask       : unsigned_long;\n+      cr2           : unsigned_long)\n+   is\n+\n+      function To_Machine_State_Ptr is new\n+        Unchecked_Conversion (Address, Machine_State_Ptr);\n+\n+      --  These are not directly visible\n+\n+      procedure Raise_From_Signal_Handler\n+        (E : Ada.Exceptions.Exception_Id;\n+         M : System.Address);\n+      pragma Import\n+        (Ada, Raise_From_Signal_Handler,\n+         \"ada__exceptions__raise_from_signal_handler\");\n+      pragma No_Return (Raise_From_Signal_Handler);\n+\n+      mstate  : Machine_State_Ptr;\n+      message : aliased constant String := \"\" & ASCII.Nul;\n+      --  a null terminated String.\n+\n+      Result  : int;\n+\n+   begin\n+\n+      --  Raise_From_Signal_Handler makes sure that the exception is raised\n+      --  safely from this signal handler.\n+\n+      --  ??? The original signal mask (the one we had before coming into this\n+      --  signal catching function) should be restored by\n+      --  Raise_From_Signal_Handler. For now, restore it explicitely\n+\n+      Result := pthread_sigmask (SIG_UNBLOCK, Signal_Mask'Access, null);\n+      pragma Assert (Result = 0);\n+\n+      --  Check that treatment of exception propagation here\n+      --  is consistent with treatment of the abort signal in\n+      --  System.Task_Primitives.Operations.\n+\n+      mstate := To_Machine_State_Ptr (TSL.Get_Machine_State_Addr.all);\n+      mstate.eip := eip;\n+      mstate.ebx := ebx;\n+      mstate.esp := esp_at_signal;\n+      mstate.ebp := ebp;\n+      mstate.esi := esi;\n+      mstate.edi := edi;\n+\n+      case signo is\n+         when SIGFPE =>\n+            Raise_From_Signal_Handler\n+              (Constraint_Error'Identity, message'Address);\n+         when SIGILL =>\n+            Raise_From_Signal_Handler\n+              (Constraint_Error'Identity, message'Address);\n+         when SIGSEGV =>\n+            Raise_From_Signal_Handler\n+              (Storage_Error'Identity, message'Address);\n+         when others =>\n+            if Shutdown (\"Unexpected signal\") then\n+               null;\n+            end if;\n+      end case;\n+   end Notify_Exception;\n+\n+   ---------------------------\n+   -- Initialize_Interrupts --\n+   ---------------------------\n+\n+   --  Nothing needs to be done on this platform.\n+\n+   procedure Initialize_Interrupts is\n+   begin\n+      null;\n+   end Initialize_Interrupts;\n+\n+begin\n+   declare\n+      act     : aliased struct_sigaction;\n+      old_act : aliased struct_sigaction;\n+      Result  : int;\n+\n+   begin\n+\n+      --  Need to call pthread_init very early because it is doing signal\n+      --  initializations.\n+\n+      pthread_init;\n+\n+      Abort_Task_Interrupt := SIGADAABORT;\n+\n+      act.sa_handler := Notify_Exception'Address;\n+\n+      act.sa_flags := 0;\n+      --  On some targets, we set sa_flags to SA_NODEFER so that during the\n+      --  handler execution we do not change the Signal_Mask to be masked for\n+      --  the Signal.\n+      --  This is a temporary fix to the problem that the Signal_Mask is\n+      --  not restored after the exception (longjmp) from the handler.\n+      --  The right fix should be made in sigsetjmp so that we save\n+      --  the Signal_Set and restore it after a longjmp.\n+      --  Since SA_NODEFER is obsolete, instead we reset explicitely\n+      --  the mask in the exception handler.\n+\n+      Result := sigemptyset (Signal_Mask'Access);\n+      pragma Assert (Result = 0);\n+\n+      for J in Exception_Interrupts'Range loop\n+         Result :=\n+           sigaddset (Signal_Mask'Access, Signal (Exception_Interrupts (J)));\n+         pragma Assert (Result = 0);\n+      end loop;\n+\n+      act.sa_mask := Signal_Mask;\n+\n+      Result :=\n+        sigaction\n+        (Signal (SIGFPE), act'Unchecked_Access,\n+         old_act'Unchecked_Access);\n+      pragma Assert (Result = 0);\n+\n+      for J in Exception_Interrupts'First + 1 .. Exception_Interrupts'Last loop\n+         Keep_Unmasked (Exception_Interrupts (J)) := True;\n+         if Unreserve_All_Interrupts = 0 then\n+            Result :=\n+              sigaction\n+              (Signal (Exception_Interrupts (J)),\n+               act'Unchecked_Access,\n+               old_act'Unchecked_Access);\n+            pragma Assert (Result = 0);\n+         end if;\n+      end loop;\n+\n+      Keep_Unmasked (Abort_Task_Interrupt) := True;\n+      Keep_Unmasked (SIGXCPU) := True;\n+      Keep_Unmasked (SIGBUS) := True;\n+      Keep_Unmasked (SIGFPE) := True;\n+\n+      --  By keeping SIGINT unmasked, allow the user to do a Ctrl-C, but in the\n+      --  same time, disable the ability of handling this signal\n+      --  via Ada.Interrupts.\n+      --  The pragma Unreserve_All_Interrupts let the user the ability to\n+      --  change this behavior.\n+\n+      if Unreserve_All_Interrupts = 0 then\n+         Keep_Unmasked (SIGINT) := True;\n+      end if;\n+\n+      for J in Unmasked'Range loop\n+         Keep_Unmasked (Interrupt_ID (Unmasked (J))) := True;\n+      end loop;\n+\n+      Reserve := Keep_Unmasked or Keep_Masked;\n+\n+      for J in Reserved'Range loop\n+         Reserve (Interrupt_ID (Reserved (J))) := True;\n+      end loop;\n+\n+      Reserve (0) := True;\n+      --  We do not have Signal 0 in reality. We just use this value\n+      --  to identify non-existent signals (see s-intnam.ads). Therefore,\n+      --  Signal 0 should not be used in all signal related operations hence\n+      --  mark it as reserved.\n+\n+   end;\n+end System.Interrupt_Management;"}, {"sha": "973243da1a0f2f446be1eb7025c4382e657b5b9e", "filename": "gcc/ada/5lml-tgt.adb", "status": "added", "additions": 343, "deletions": 0, "changes": 343, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5lml-tgt.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5lml-tgt.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5lml-tgt.adb?ref=84481f762f0682e5f45b2f360446e1c7e333c880", "patch": "@@ -0,0 +1,343 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                             M L I B . T G T                              --\n+--                             (Linux Version)                              --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision: 1.2 $\n+--                                                                          --\n+--              Copyright (C) 2001, Ada Core Technologies, Inc.             --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package provides a set of target dependent routines to build\n+--  static, dynamic and shared libraries.\n+\n+--  This is the Linux version of the body.\n+\n+with Ada.Characters.Handling;   use Ada.Characters.Handling;\n+with GNAT.Directory_Operations; use GNAT.Directory_Operations;\n+with MLib.Fil;\n+with MLib.Utl;\n+with Namet;       use Namet;\n+with Opt;\n+with Osint;       use Osint;\n+with Output;      use Output;\n+with System;\n+\n+package body MLib.Tgt is\n+\n+   use GNAT;\n+   use MLib;\n+\n+   --  ??? serious lack of comments below, all these declarations need to\n+   --  be commented, none are:\n+\n+   package Files renames MLib.Fil;\n+   package Tools renames MLib.Utl;\n+\n+   Args : Argument_List_Access := new Argument_List (1 .. 20);\n+   Last_Arg : Natural := 0;\n+\n+   Cp      : constant String_Access := Locate_Exec_On_Path (\"cp\");\n+   Force   : constant String_Access := new String'(\"-f\");\n+\n+   procedure Add_Arg (Arg : String);\n+\n+   -------------\n+   -- Add_Arg --\n+   -------------\n+\n+   procedure Add_Arg (Arg : String) is\n+   begin\n+      if Last_Arg = Args'Last then\n+         declare\n+            New_Args : constant Argument_List_Access :=\n+                         new Argument_List (1 .. Args'Last * 2);\n+\n+         begin\n+            New_Args (Args'Range) := Args.all;\n+            Args := New_Args;\n+         end;\n+      end if;\n+\n+      Last_Arg := Last_Arg + 1;\n+      Args (Last_Arg) := new String'(Arg);\n+   end Add_Arg;\n+\n+   -----------------\n+   -- Archive_Ext --\n+   -----------------\n+\n+   function Archive_Ext return  String is\n+   begin\n+      return  \"a\";\n+   end Archive_Ext;\n+\n+   -----------------\n+   -- Base_Option --\n+   -----------------\n+\n+   function Base_Option return String is\n+   begin\n+      return \"\";\n+   end Base_Option;\n+\n+   ---------------------------\n+   -- Build_Dynamic_Library --\n+   ---------------------------\n+\n+   procedure Build_Dynamic_Library\n+     (Ofiles       : Argument_List;\n+      Foreign      : Argument_List;\n+      Afiles       : Argument_List;\n+      Options      : Argument_List;\n+      Lib_Filename : String;\n+      Lib_Dir      : String;\n+      Lib_Address  : String  := \"\";\n+      Lib_Version  : String  := \"\";\n+      Relocatable  : Boolean := False)\n+   is\n+      Lib_File : constant String :=\n+        Lib_Dir & Directory_Separator & \"lib\" &\n+        Files.Ext_To (Lib_Filename, DLL_Ext);\n+\n+      use type Argument_List;\n+      use type String_Access;\n+\n+      Version_Arg  : String_Access;\n+\n+      Symbolic_Link_Needed : Boolean := False;\n+\n+   begin\n+      if Opt.Verbose_Mode then\n+         Write_Str (\"building relocatable shared library \");\n+         Write_Line (Lib_File);\n+      end if;\n+\n+      if Lib_Version = \"\" then\n+         Tools.Gcc\n+           (Output_File => Lib_File,\n+            Objects     => Ofiles,\n+            Options     => Options);\n+\n+      else\n+         Version_Arg := new String'(\"-Wl,-soname,\" & Lib_Version);\n+\n+         if Is_Absolute_Path (Lib_Version) then\n+            Tools.Gcc\n+              (Output_File => Lib_Version,\n+               Objects     => Ofiles,\n+               Options     => Options & Version_Arg);\n+            Symbolic_Link_Needed := Lib_Version /= Lib_File;\n+\n+         else\n+            Tools.Gcc\n+              (Output_File => Lib_Dir & Directory_Separator & Lib_Version,\n+               Objects     => Ofiles,\n+               Options     => Options & Version_Arg);\n+            Symbolic_Link_Needed :=\n+              Lib_Dir & Directory_Separator & Lib_Version /= Lib_File;\n+         end if;\n+\n+         if Symbolic_Link_Needed then\n+            declare\n+               Success : Boolean;\n+               Oldpath : String (1 .. Lib_Version'Length + 1);\n+               Newpath : String (1 .. Lib_File'Length + 1);\n+               Result  : Integer;\n+\n+               function Symlink\n+                 (Oldpath : System.Address;\n+                  Newpath : System.Address)\n+                  return    Integer;\n+               pragma Import (C, Symlink, \"__gnat_symlink\");\n+\n+            begin\n+               Oldpath (1 .. Lib_Version'Length) := Lib_Version;\n+               Oldpath (Oldpath'Last)            := ASCII.NUL;\n+               Newpath (1 .. Lib_File'Length)    := Lib_File;\n+               Newpath (Newpath'Last)            := ASCII.NUL;\n+\n+               Delete_File (Lib_File, Success);\n+\n+               Result := Symlink (Oldpath'Address, Newpath'Address);\n+            end;\n+         end if;\n+      end if;\n+   end Build_Dynamic_Library;\n+\n+   --------------------\n+   -- Copy_ALI_Files --\n+   --------------------\n+\n+   procedure Copy_ALI_Files\n+     (From : Name_Id;\n+      To   : Name_Id)\n+   is\n+      Dir      : Dir_Type;\n+      Name     : String (1 .. 1_000);\n+      Last     : Natural;\n+      Success  : Boolean;\n+      From_Dir : constant String := Get_Name_String (From);\n+      To_Dir   : constant String_Access :=\n+                   new String'(Get_Name_String (To));\n+\n+   begin\n+      Last_Arg := 0;\n+      Open (Dir, From_Dir);\n+\n+      loop\n+         Read (Dir, Name, Last);\n+         exit when Last = 0;\n+         if Last > 4\n+\n+           and then\n+           To_Lower (Name (Last - 3 .. Last)) = \".ali\"\n+         then\n+            Add_Arg (From_Dir & Directory_Separator & Name (1 .. Last));\n+         end if;\n+      end loop;\n+\n+      if Last_Arg /= 0 then\n+         if not Opt.Quiet_Output then\n+            Write_Str (\"cp -f \");\n+\n+            for J in 1 .. Last_Arg loop\n+               Write_Str (Args (J).all);\n+               Write_Char (' ');\n+            end loop;\n+\n+            Write_Line (To_Dir.all);\n+         end if;\n+\n+         Spawn (Cp.all,\n+                Force & Args (1 .. Last_Arg) & To_Dir,\n+                Success);\n+\n+         if not Success then\n+            Fail (\"could not copy ALI files to library dir\");\n+         end if;\n+      end if;\n+   end Copy_ALI_Files;\n+\n+   -------------------------\n+   -- Default_DLL_Address --\n+   -------------------------\n+\n+   function Default_DLL_Address return String is\n+   begin\n+      return \"\";\n+   end Default_DLL_Address;\n+\n+   -------------\n+   -- DLL_Ext --\n+   -------------\n+\n+   function DLL_Ext return String is\n+   begin\n+      return \"so\";\n+   end DLL_Ext;\n+\n+   --------------------\n+   -- Dynamic_Option --\n+   --------------------\n+\n+   function Dynamic_Option return String is\n+   begin\n+      return  \"-shared\";\n+   end Dynamic_Option;\n+\n+   -------------------\n+   -- Is_Object_Ext --\n+   -------------------\n+\n+   function Is_Object_Ext (Ext : String) return Boolean is\n+   begin\n+      return Ext = \".o\";\n+   end Is_Object_Ext;\n+\n+   --------------\n+   -- Is_C_Ext --\n+   --------------\n+\n+   function Is_C_Ext (Ext : String) return Boolean is\n+   begin\n+      return Ext = \".c\";\n+   end Is_C_Ext;\n+\n+   --------------------\n+   -- Is_Archive_Ext --\n+   --------------------\n+\n+   function Is_Archive_Ext (Ext : String) return Boolean is\n+   begin\n+      return Ext = \".a\" or else Ext = \".so\";\n+   end Is_Archive_Ext;\n+\n+   -------------\n+   -- Libgnat --\n+   -------------\n+\n+   function Libgnat return String is\n+   begin\n+      return \"libgnat.a\";\n+   end Libgnat;\n+\n+   -----------------------------\n+   -- Libraries_Are_Supported --\n+   -----------------------------\n+\n+   function Libraries_Are_Supported return Boolean is\n+   begin\n+      return True;\n+   end Libraries_Are_Supported;\n+\n+   --------------------------------\n+   -- Linker_Library_Path_Option --\n+   --------------------------------\n+\n+   function Linker_Library_Path_Option\n+     (Directory : String)\n+      return      String_Access\n+   is\n+   begin\n+      return new String'(\"-Wl,-rpath,\" & Directory);\n+   end Linker_Library_Path_Option;\n+\n+   ----------------\n+   -- Object_Ext --\n+   ----------------\n+\n+   function Object_Ext return String is\n+   begin\n+      return  \"o\";\n+   end Object_Ext;\n+\n+   ----------------\n+   -- PIC_Option --\n+   ----------------\n+\n+   function PIC_Option return String is\n+   begin\n+      return  \"-fPIC\";\n+   end PIC_Option;\n+\n+end MLib.Tgt;"}, {"sha": "9a1e6c5ca53976cc57bc42e1a34d6aba8a0c5816", "filename": "gcc/ada/5losinte.ads", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5losinte.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5losinte.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5losinte.ads?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "9ec0bbc6321442989f7567cb2c1feaa4504773d6", "filename": "gcc/ada/5lsystem.ads", "status": "added", "additions": 150, "deletions": 0, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5lsystem.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5lsystem.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5lsystem.ads?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "571317af3832b0cdcf4551ff1386fddb0fdab808", "filename": "gcc/ada/5mosinte.ads", "status": "added", "additions": 562, "deletions": 0, "changes": 562, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5mosinte.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5mosinte.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5mosinte.ads?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "2daf08ca22200922c8dde6a3bd0fe296ada9ab23", "filename": "gcc/ada/5mvxwork.ads", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5mvxwork.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5mvxwork.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5mvxwork.ads?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "11787bbf928eb5790730ead5fe1cdfb99d7b636f", "filename": "gcc/ada/5ninmaop.adb", "status": "added", "additions": 194, "deletions": 0, "changes": 194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5ninmaop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5ninmaop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5ninmaop.adb?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "4b4a34c934669ce4029d71c2c2b079e88a39aa71", "filename": "gcc/ada/5nintman.adb", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5nintman.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5nintman.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5nintman.adb?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "c854786c2ba8652458a6e8254df02c373db431ca", "filename": "gcc/ada/5nosinte.ads", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5nosinte.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5nosinte.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5nosinte.ads?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "fa28e3689202bc521f46791ca0dce85aff4bb873", "filename": "gcc/ada/5ntaprop.adb", "status": "added", "additions": 434, "deletions": 0, "changes": 434, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5ntaprop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5ntaprop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5ntaprop.adb?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "e51b948c7a24fe3281956a8b147c3022d0d3cebd", "filename": "gcc/ada/5ntaspri.ads", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5ntaspri.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5ntaspri.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5ntaspri.ads?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "31726f2acbcdaa65ef4eb98eb1dcbe241c598dab", "filename": "gcc/ada/5ointerr.adb", "status": "added", "additions": 303, "deletions": 0, "changes": 303, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5ointerr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5ointerr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5ointerr.adb?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "129ea81d7055199d32282db053cfe23990ca3b5b", "filename": "gcc/ada/5omastop.adb", "status": "added", "additions": 592, "deletions": 0, "changes": 592, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5omastop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5omastop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5omastop.adb?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "b5686b315487c0d2bec2857150a35bcead3918d5", "filename": "gcc/ada/5oosinte.adb", "status": "added", "additions": 256, "deletions": 0, "changes": 256, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5oosinte.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5oosinte.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5oosinte.adb?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "70d6bb2518ee6c08cf609d9a62749dde23e58af4", "filename": "gcc/ada/5oosinte.ads", "status": "added", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5oosinte.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5oosinte.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5oosinte.ads?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "0531bdec522aec5b23e79fba42b6e5973824821e", "filename": "gcc/ada/5oosprim.adb", "status": "added", "additions": 175, "deletions": 0, "changes": 175, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5oosprim.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5oosprim.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5oosprim.adb?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "44d24ea5d2a35f2e5f7c1d346e79bd2429a81321", "filename": "gcc/ada/5oparame.adb", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5oparame.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5oparame.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5oparame.adb?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "f5110ed20f32ab018007833936846905703ee15e", "filename": "gcc/ada/5osystem.ads", "status": "added", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5osystem.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5osystem.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5osystem.ads?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "3fd7229a79e275395be1bf9303e77d92b09fc462", "filename": "gcc/ada/5otaprop.adb", "status": "added", "additions": 1066, "deletions": 0, "changes": 1066, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5otaprop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5otaprop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5otaprop.adb?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "dd4fc9e901670062637f73fe7d0060282d07f533", "filename": "gcc/ada/5otaspri.ads", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5otaspri.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5otaspri.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5otaspri.ads?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "8e2a8ace0a0ccab87884ca9994ef811e2c021836", "filename": "gcc/ada/5posinte.ads", "status": "added", "additions": 567, "deletions": 0, "changes": 567, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5posinte.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5posinte.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5posinte.ads?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "72130a0beccc92052cd4357598de5d89b451ab40", "filename": "gcc/ada/5posprim.adb", "status": "added", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5posprim.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5posprim.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5posprim.adb?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "47deae2da5b12ccf4197236912f49adacdf8d41a", "filename": "gcc/ada/5pvxwork.ads", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5pvxwork.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5pvxwork.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5pvxwork.ads?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "fd7e452519931c1ed9a41475482c11706f0612dc", "filename": "gcc/ada/5qosinte.adb", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5qosinte.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5qosinte.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5qosinte.adb?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "7bc4d2c8088662f7f4c9701ecd883beb2d679672", "filename": "gcc/ada/5qosinte.ads", "status": "added", "additions": 188, "deletions": 0, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5qosinte.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5qosinte.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5qosinte.ads?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "776f7ca97446238e969cf3ae95758d893fb25fad", "filename": "gcc/ada/5qparame.ads", "status": "added", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5qparame.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5qparame.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5qparame.ads?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "54c8e6752e3017e9128a36cdf4c25fb00b9db232", "filename": "gcc/ada/5qstache.adb", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5qstache.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5qstache.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5qstache.adb?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "00cfe90c07f2f5b7a6605140bb9038a43facfe28", "filename": "gcc/ada/5qtaprop.adb", "status": "added", "additions": 1777, "deletions": 0, "changes": 1777, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5qtaprop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5qtaprop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5qtaprop.adb?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "6c1866d1976681545cbd998af7712c7fd4b1e33f", "filename": "gcc/ada/5qtaspri.ads", "status": "added", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5qtaspri.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5qtaspri.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5qtaspri.ads?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "7f3bd8c2393cf607b455db00b6bad4469ae715a5", "filename": "gcc/ada/5qvxwork.ads", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5qvxwork.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5qvxwork.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5qvxwork.ads?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "8fb59c494c934dbc5daacefc665a9dd56d324fe7", "filename": "gcc/ada/5rosinte.adb", "status": "added", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5rosinte.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5rosinte.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5rosinte.adb?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "3bbadf19ef2fec08691f0bbeb2f1983456de0c90", "filename": "gcc/ada/5rosinte.ads", "status": "added", "additions": 527, "deletions": 0, "changes": 527, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5rosinte.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5rosinte.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5rosinte.ads?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "761284df07116c106e544d599f87bbc5680cd7c1", "filename": "gcc/ada/5rparame.adb", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5rparame.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5rparame.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5rparame.adb?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "24f68edea171899103a8867928480ce80919c556", "filename": "gcc/ada/5sintman.adb", "status": "added", "additions": 224, "deletions": 0, "changes": 224, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5sintman.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5sintman.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5sintman.adb?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "4dfc8ad8b222ccd0fa8dd5eebf33e9e90a9d76b3", "filename": "gcc/ada/5smastop.adb", "status": "added", "additions": 159, "deletions": 0, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5smastop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5smastop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5smastop.adb?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "fffc3fdad8eb7996cae68a73b0b9784b37131e59", "filename": "gcc/ada/5sosinte.adb", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5sosinte.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5sosinte.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5sosinte.adb?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "490ec600c7f91dcf14f7d07017ddcf007141af47", "filename": "gcc/ada/5sosinte.ads", "status": "added", "additions": 561, "deletions": 0, "changes": 561, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5sosinte.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5sosinte.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5sosinte.ads?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "30d6cc9324c1411dd6c606d601b9b699bb7284f7", "filename": "gcc/ada/5sparame.adb", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5sparame.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5sparame.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5sparame.adb?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "2f30306e80829e292854e4a43e476629f7c0bd79", "filename": "gcc/ada/5ssystem.ads", "status": "added", "additions": 150, "deletions": 0, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5ssystem.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5ssystem.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5ssystem.ads?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "3815b5fb751607ddfb231c1c6b858314ffde7c9a", "filename": "gcc/ada/5staprop.adb", "status": "added", "additions": 1939, "deletions": 0, "changes": 1939, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5staprop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5staprop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5staprop.adb?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "c940af1a93ae5cdc69af06a43eb85565948af2e7", "filename": "gcc/ada/5stasinf.adb", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5stasinf.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5stasinf.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5stasinf.adb?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "dba3b189f5a92b804ef95a81887c915843052d0c", "filename": "gcc/ada/5stasinf.ads", "status": "added", "additions": 144, "deletions": 0, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5stasinf.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5stasinf.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5stasinf.ads?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "ee71fe0cba121c1ad2c0854a983128d3f56a0e20", "filename": "gcc/ada/5staspri.ads", "status": "added", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5staspri.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5staspri.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5staspri.ads?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "c041c16489ee9a1414d048358e1f6c9c2e0137ef", "filename": "gcc/ada/5stpopse.adb", "status": "added", "additions": 196, "deletions": 0, "changes": 196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5stpopse.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5stpopse.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5stpopse.adb?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "9ddae2f8145e276f897d47ad2d9a2a6cd04d3d5a", "filename": "gcc/ada/5svxwork.ads", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5svxwork.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5svxwork.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5svxwork.ads?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "b95708a8e5bcb427d15580f79c8395ef31e72280", "filename": "gcc/ada/5tosinte.ads", "status": "added", "additions": 660, "deletions": 0, "changes": 660, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5tosinte.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5tosinte.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5tosinte.ads?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "9b11d3baa8e9371d1be7b294cac332d0bcc371d1", "filename": "gcc/ada/5uintman.adb", "status": "added", "additions": 269, "deletions": 0, "changes": 269, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5uintman.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5uintman.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5uintman.adb?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "352777c77f0a9a109bb7c71a8529033540ebc1e1", "filename": "gcc/ada/5uosinte.ads", "status": "added", "additions": 555, "deletions": 0, "changes": 555, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5uosinte.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5uosinte.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5uosinte.ads?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "25ef26854cf94f69795d6528fc1336113fa74c0f", "filename": "gcc/ada/5vasthan.adb", "status": "added", "additions": 603, "deletions": 0, "changes": 603, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5vasthan.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5vasthan.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5vasthan.adb?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "0077a2481613f7715bc10391c9eb4974214301ae", "filename": "gcc/ada/5vinmaop.adb", "status": "added", "additions": 280, "deletions": 0, "changes": 280, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5vinmaop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5vinmaop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5vinmaop.adb?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "cb974377a9721725367ad71d3925aac182e71904", "filename": "gcc/ada/5vinterr.adb", "status": "added", "additions": 1292, "deletions": 0, "changes": 1292, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5vinterr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5vinterr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5vinterr.adb?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "e47b5351c3c1f31b677d91e48bbd3317755d7e9f", "filename": "gcc/ada/5vintman.adb", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5vintman.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5vintman.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5vintman.adb?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "046c870975de8352ce252097bd6ba526ff009baf", "filename": "gcc/ada/5vintman.ads", "status": "added", "additions": 145, "deletions": 0, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5vintman.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5vintman.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5vintman.ads?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "6cdcd38f373f44a58dcb573a172907b9f6c295aa", "filename": "gcc/ada/5vmastop.adb", "status": "added", "additions": 373, "deletions": 0, "changes": 373, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5vmastop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5vmastop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5vmastop.adb?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "34e821524b19781399ad760c31eef6127872fad7", "filename": "gcc/ada/5vosinte.adb", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5vosinte.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5vosinte.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5vosinte.adb?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "890547c38dd6db788ea18cc7fe51093ad2b8df10", "filename": "gcc/ada/5vosinte.ads", "status": "added", "additions": 642, "deletions": 0, "changes": 642, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5vosinte.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5vosinte.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5vosinte.ads?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "cde0e3b49d03e23db930c03eb1345130471f5b65", "filename": "gcc/ada/5vosprim.adb", "status": "added", "additions": 196, "deletions": 0, "changes": 196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5vosprim.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5vosprim.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5vosprim.adb?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "bcdca5d705a40d7550cbf23fd09a6a8d114091a7", "filename": "gcc/ada/5vosprim.ads", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5vosprim.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5vosprim.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5vosprim.ads?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "2788e6620c756c1c46c28ccc6292040e6e939df7", "filename": "gcc/ada/5vparame.ads", "status": "added", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5vparame.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5vparame.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5vparame.ads?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "41cebb1e749bff09ccd1b927a8bc6afd99a8410f", "filename": "gcc/ada/5vsystem.ads", "status": "added", "additions": 236, "deletions": 0, "changes": 236, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5vsystem.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5vsystem.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5vsystem.ads?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "d3891c84b7779d3c969fafd2d8c6e72bbcaefc56", "filename": "gcc/ada/5vtaprop.adb", "status": "added", "additions": 915, "deletions": 0, "changes": 915, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5vtaprop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5vtaprop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5vtaprop.adb?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "fb744912f8e278684457267f40aac018693976c3", "filename": "gcc/ada/5vtaspri.ads", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5vtaspri.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5vtaspri.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5vtaspri.ads?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "5da5cde38d604a93d0237f0ba3233aac0289a050", "filename": "gcc/ada/5vtpopde.adb", "status": "added", "additions": 144, "deletions": 0, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5vtpopde.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5vtpopde.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5vtpopde.adb?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "0ab769fff708a151311356a34283a8fcd94b0f9e", "filename": "gcc/ada/5vtpopde.ads", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5vtpopde.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5vtpopde.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5vtpopde.ads?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "606b08bad2b263a7f9f7a08fcabcfaa4d5d89317", "filename": "gcc/ada/5vvaflop.adb", "status": "added", "additions": 623, "deletions": 0, "changes": 623, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5vvaflop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5vvaflop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5vvaflop.adb?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "5edcddb67e202e715beaf0473df85fb218d13397", "filename": "gcc/ada/5wgloloc.adb", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5wgloloc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5wgloloc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5wgloloc.adb?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "7e8acb989fa4a9ad4a68c83ccf686ad6a40afd10", "filename": "gcc/ada/5wintman.adb", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5wintman.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5wintman.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5wintman.adb?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "77e42e5b773956b1107716177dbf79855d1b8778", "filename": "gcc/ada/5wmemory.adb", "status": "added", "additions": 229, "deletions": 0, "changes": 229, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5wmemory.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5wmemory.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5wmemory.adb?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "50a68ffecb416095fe1b2b63b455b5ac1183a506", "filename": "gcc/ada/5wosinte.ads", "status": "added", "additions": 437, "deletions": 0, "changes": 437, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5wosinte.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5wosinte.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5wosinte.ads?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "a86325a8b6938f94465f48da84b97bbd6f80fb59", "filename": "gcc/ada/5wosprim.adb", "status": "added", "additions": 228, "deletions": 0, "changes": 228, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5wosprim.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5wosprim.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5wosprim.adb?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "70e11949afdef7e8955e4ac7c669f2fd7727c517", "filename": "gcc/ada/5wsystem.ads", "status": "added", "additions": 201, "deletions": 0, "changes": 201, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5wsystem.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5wsystem.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5wsystem.ads?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "850ddb696b80463c4ce5081ef5f18c0ea7053d5b", "filename": "gcc/ada/5wtaprop.adb", "status": "added", "additions": 1113, "deletions": 0, "changes": 1113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5wtaprop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5wtaprop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5wtaprop.adb?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "02cefc4e1983b2a584d364519e4172cad1ea6922", "filename": "gcc/ada/5wtaspri.ads", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5wtaspri.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5wtaspri.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5wtaspri.ads?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "ca3d9e52c9ab3f488cde5a5699be7c6e3e51c726", "filename": "gcc/ada/5ysystem.ads", "status": "added", "additions": 159, "deletions": 0, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5ysystem.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5ysystem.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5ysystem.ads?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "5e428f26c083f53bbcf9264b2b2f650690ee77ca", "filename": "gcc/ada/5zinterr.adb", "status": "added", "additions": 1658, "deletions": 0, "changes": 1658, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5zinterr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5zinterr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5zinterr.adb?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "2f58cc2b86f358c8eb605fc2ebb1c11bbca5ec9b", "filename": "gcc/ada/5zintman.adb", "status": "added", "additions": 295, "deletions": 0, "changes": 295, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5zintman.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5zintman.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5zintman.adb?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "c578234c7128012e479b020ac34c47962ddb9907", "filename": "gcc/ada/5zosinte.adb", "status": "added", "additions": 831, "deletions": 0, "changes": 831, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5zosinte.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5zosinte.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5zosinte.adb?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "f0777793005202199efc793bf6c6c78e56c98a44", "filename": "gcc/ada/5zosinte.ads", "status": "added", "additions": 555, "deletions": 0, "changes": 555, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5zosinte.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5zosinte.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5zosinte.ads?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "b327f92bba721ad366180167676712ceafa83bfe", "filename": "gcc/ada/5zosprim.adb", "status": "added", "additions": 146, "deletions": 0, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5zosprim.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5zosprim.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5zosprim.adb?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "e515df183540c3669b1a3854bf19151db7d446fe", "filename": "gcc/ada/5zparame.ads", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5zparame.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5zparame.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5zparame.ads?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "3bdb5688a1de0b2c8f3acee77adcd628ec9dbc78", "filename": "gcc/ada/5zsystem.ads", "status": "added", "additions": 159, "deletions": 0, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5zsystem.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5zsystem.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5zsystem.ads?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "b543ae23b33f4aa90dbc46680c22b6ff3377b1af", "filename": "gcc/ada/5ztaprop.adb", "status": "added", "additions": 1065, "deletions": 0, "changes": 1065, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5ztaprop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F5ztaprop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5ztaprop.adb?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "40dac7bb8dc726eb9785b970622608324fff1e4c", "filename": "gcc/ada/6vcpp.adb", "status": "added", "additions": 338, "deletions": 0, "changes": 338, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F6vcpp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F6vcpp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F6vcpp.adb?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "858a10cfb3b76563b2043a6a6dbaaf0d026fcfa1", "filename": "gcc/ada/6vcstrea.adb", "status": "added", "additions": 183, "deletions": 0, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F6vcstrea.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F6vcstrea.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F6vcstrea.adb?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "cfdd49b2c7ddf77f5cc662252c0b3fc1bb211d1e", "filename": "gcc/ada/6vinterf.ads", "status": "added", "additions": 174, "deletions": 0, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F6vinterf.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F6vinterf.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F6vinterf.ads?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "a920b371055f1cd119325ba4a936fa43d51e8a6e", "filename": "gcc/ada/7sinmaop.adb", "status": "added", "additions": 356, "deletions": 0, "changes": 356, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F7sinmaop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F7sinmaop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F7sinmaop.adb?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "2e0a85ca894fd509954f9d0ba82d495399c7a7b9", "filename": "gcc/ada/7sintman.adb", "status": "added", "additions": 242, "deletions": 0, "changes": 242, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F7sintman.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F7sintman.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F7sintman.adb?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "4d2dfa1ccf14e487d93a8ecb85f20518847cd07b", "filename": "gcc/ada/7sosinte.adb", "status": "added", "additions": 366, "deletions": 0, "changes": 366, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F7sosinte.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F7sosinte.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F7sosinte.adb?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "a8eee2ae87c4f91ba94333bb684a91f069750df2", "filename": "gcc/ada/7sosprim.adb", "status": "added", "additions": 156, "deletions": 0, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F7sosprim.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F7sosprim.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F7sosprim.adb?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "7c2dbe82be749249a66144cd8a889b90367c8fa4", "filename": "gcc/ada/7staprop.adb", "status": "added", "additions": 1108, "deletions": 0, "changes": 1108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F7staprop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F7staprop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F7staprop.adb?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "4cfd2fd4568205a93484ce0609fc528e52d03ace", "filename": "gcc/ada/7staspri.ads", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F7staspri.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F7staspri.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F7staspri.ads?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "03fcdedaca8894cd7936d606f16fbe2545cc75a3", "filename": "gcc/ada/7stpopsp.adb", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F7stpopsp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F7stpopsp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F7stpopsp.adb?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "08c672c8d764b17ee402c647208a885558bdf76e", "filename": "gcc/ada/7straceb.adb", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F7straceb.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F7straceb.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F7straceb.adb?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "f6e1f4c7686e717692e2af8ec8b94955170dbddb", "filename": "gcc/ada/86numaux.adb", "status": "added", "additions": 595, "deletions": 0, "changes": 595, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F86numaux.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F86numaux.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F86numaux.adb?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "e1c3bb377fedd4c53e2e44f2f94a024bcbf4847f", "filename": "gcc/ada/86numaux.ads", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F86numaux.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F86numaux.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F86numaux.ads?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "8f749fa51dae0f9a332ce66ba38963092853fe19", "filename": "gcc/ada/9drpc.adb", "status": "added", "additions": 1053, "deletions": 0, "changes": 1053, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F9drpc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2F9drpc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F9drpc.adb?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "a3c8606675efed98a862cb1130f8852146bd3cee", "filename": "gcc/ada/Make-lang.in", "status": "added", "additions": 647, "deletions": 0, "changes": 647, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMake-lang.in?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "f96c4ee54c16938fef1b197a3cfa4b0590e9deaf", "filename": "gcc/ada/Makefile.adalib", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2FMakefile.adalib", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2FMakefile.adalib", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.adalib?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "d5f44a94b9dc5fa93396f55a2221dda9e8272030", "filename": "gcc/ada/Makefile.in", "status": "added", "additions": 4749, "deletions": 0, "changes": 4749, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.in?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "ee20a9634e5045d658b79d3c4e471c6abd074d61", "filename": "gcc/ada/machcode.ads", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2Fmachcode.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2Fmachcode.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmachcode.ads?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "945dd20ce5661adeb6cd4ce9b554ae15ee171452", "filename": "gcc/ada/make.adb", "status": "added", "additions": 4455, "deletions": 0, "changes": 4455, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2Fmake.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2Fmake.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmake.adb?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "587f71d6a55e6f37c773e6f4ef81b283e499f025", "filename": "gcc/ada/make.ads", "status": "added", "additions": 274, "deletions": 0, "changes": 274, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2Fmake.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2Fmake.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmake.ads?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "d06eb1fa2cc989d2c776eb7c679b68606fb0e38c", "filename": "gcc/ada/makeusg.adb", "status": "added", "additions": 277, "deletions": 0, "changes": 277, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2Fmakeusg.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2Fmakeusg.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmakeusg.adb?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "80d433f1a2f40ed08281b067cdc5951c6c7d3a7d", "filename": "gcc/ada/makeusg.ads", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2Fmakeusg.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2Fmakeusg.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmakeusg.ads?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "b7345c0e974c03034e032ceb6548a1fd27f92663", "filename": "gcc/ada/math_lib.adb", "status": "added", "additions": 1029, "deletions": 0, "changes": 1029, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2Fmath_lib.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2Fmath_lib.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmath_lib.adb?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "b0fca0293c3fb1198d706c537caa275ddbbb5d2e", "filename": "gcc/ada/mdll.adb", "status": "added", "additions": 410, "deletions": 0, "changes": 410, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2Fmdll.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2Fmdll.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmdll.adb?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "2a13be1830bf9f7dd6aec2d0aa899ede67e4324f", "filename": "gcc/ada/mdll.ads", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2Fmdll.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2Fmdll.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmdll.ads?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "9aad7e117a095abe38f67dbabfcad58abc0a44c2", "filename": "gcc/ada/mdllfile.adb", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2Fmdllfile.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2Fmdllfile.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmdllfile.adb?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "ca6a222c72429271fd1c23b83611b55888bb59de", "filename": "gcc/ada/mdllfile.ads", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2Fmdllfile.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2Fmdllfile.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmdllfile.ads?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "fee7218c5be1837d2da3aaa448364cc94f424b41", "filename": "gcc/ada/mdlltool.adb", "status": "added", "additions": 346, "deletions": 0, "changes": 346, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2Fmdlltool.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2Fmdlltool.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmdlltool.adb?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "0e9b55c9afffa7474c51242e076af01622a3c43f", "filename": "gcc/ada/mdlltool.ads", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2Fmdlltool.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2Fmdlltool.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmdlltool.ads?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "d8db62b751b21a3c8833e5f36f04741c546cd4ab", "filename": "gcc/ada/memroot.adb", "status": "added", "additions": 663, "deletions": 0, "changes": 663, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2Fmemroot.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2Fmemroot.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmemroot.adb?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "38ef645e519452443e5502a4ca950e62f666882e", "filename": "gcc/ada/memroot.ads", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2Fmemroot.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2Fmemroot.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmemroot.ads?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "7938de5714dcba3495584d6eeb6db4865e701138", "filename": "gcc/ada/memtrack.adb", "status": "added", "additions": 278, "deletions": 0, "changes": 278, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2Fmemtrack.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2Fmemtrack.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmemtrack.adb?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "365bc0abfabc28d8bda9dd4d695da35120cf3f5a", "filename": "gcc/ada/misc.c", "status": "added", "additions": 1098, "deletions": 0, "changes": 1098, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmisc.c?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "eac9c1deb038868ce25430c799c8e8dd23c3cebc", "filename": "gcc/ada/mlib-fil.adb", "status": "added", "additions": 125, "deletions": 0, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2Fmlib-fil.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2Fmlib-fil.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-fil.adb?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "b4d4701b94f6cc45b2fc2182c7d983308bbc5a9a", "filename": "gcc/ada/mlib-fil.ads", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2Fmlib-fil.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2Fmlib-fil.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-fil.ads?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "13c62ee2c162deadccff3ae36e9412f53baa7e39", "filename": "gcc/ada/mlib-prj.adb", "status": "added", "additions": 339, "deletions": 0, "changes": 339, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2Fmlib-prj.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2Fmlib-prj.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-prj.adb?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "cfc90a9dbc9052ea62907e863e3bb6df81eb583f", "filename": "gcc/ada/mlib-prj.ads", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2Fmlib-prj.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2Fmlib-prj.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-prj.ads?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "2a25aef1ae9a53dfb853ee41091aa1ae5720fe6a", "filename": "gcc/ada/mlib-tgt.adb", "status": "added", "additions": 187, "deletions": 0, "changes": 187, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2Fmlib-tgt.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2Fmlib-tgt.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-tgt.adb?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "a40619d0075019473a6934ac47dc36f75073c697", "filename": "gcc/ada/mlib-tgt.ads", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2Fmlib-tgt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2Fmlib-tgt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-tgt.ads?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "5b4f1f0fe4626fca57b97f743e90aea9e026ca00", "filename": "gcc/ada/mlib-utl.adb", "status": "added", "additions": 263, "deletions": 0, "changes": 263, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2Fmlib-utl.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2Fmlib-utl.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-utl.adb?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "64330f0a7cd60200f095d841ea3fc35cf208c6e8", "filename": "gcc/ada/mlib-utl.ads", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2Fmlib-utl.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2Fmlib-utl.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-utl.ads?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "db0cca900190bce7bdcf742f552a25ee1ef9c36f", "filename": "gcc/ada/mlib.adb", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2Fmlib.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2Fmlib.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib.adb?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}, {"sha": "7b4be16b9937c0c3944d966a768d2aeecc01f247", "filename": "gcc/ada/mlib.ads", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2Fmlib.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84481f762f0682e5f45b2f360446e1c7e333c880/gcc%2Fada%2Fmlib.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib.ads?ref=84481f762f0682e5f45b2f360446e1c7e333c880"}]}