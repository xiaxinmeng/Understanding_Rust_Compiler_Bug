{"sha": "09fa81dbb7a6c892b01bac7e8193316fd1428d36", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDlmYTgxZGJiN2E2Yzg5MmIwMWJhYzdlODE5MzMxNmZkMTQyOGQzNg==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2004-10-05T18:53:08Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2004-10-05T18:53:08Z"}, "message": "tree-cfg.c (cleanup_tree_cfg): Don't call delete_unreachable_blosk() after thread_jumps().\n\n\t* tree-cfg.c (cleanup_tree_cfg): Don't call\n\tdelete_unreachable_blosk() after thread_jumps().\n\t(thread_jumps): Always remove basic blocks as they become\n\tunreachable.\n\nFrom-SVN: r88565", "tree": {"sha": "7fae4898199d1fdc2587f07810eabd58a25e5843", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7fae4898199d1fdc2587f07810eabd58a25e5843"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/09fa81dbb7a6c892b01bac7e8193316fd1428d36", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09fa81dbb7a6c892b01bac7e8193316fd1428d36", "html_url": "https://github.com/Rust-GCC/gccrs/commit/09fa81dbb7a6c892b01bac7e8193316fd1428d36", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09fa81dbb7a6c892b01bac7e8193316fd1428d36/comments", "author": null, "committer": null, "parents": [{"sha": "1111ad788aeaa829e581c310efbd36f6d66bdbb0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1111ad788aeaa829e581c310efbd36f6d66bdbb0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1111ad788aeaa829e581c310efbd36f6d66bdbb0"}], "stats": {"total": 41, "additions": 22, "deletions": 19}, "files": [{"sha": "7ef42ea0c2dbe1285f25934748d9d70c7e3b74a4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09fa81dbb7a6c892b01bac7e8193316fd1428d36/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09fa81dbb7a6c892b01bac7e8193316fd1428d36/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=09fa81dbb7a6c892b01bac7e8193316fd1428d36", "patch": "@@ -1,3 +1,10 @@\n+2004-10-05  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* tree-cfg.c (cleanup_tree_cfg): Don't call\n+\tdelete_unreachable_blosk() after thread_jumps().\n+\t(thread_jumps): Always remove basic blocks as they become\n+\tunreachable.\n+\n 2004-10-05  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* tree-cfg.c (cleanup_tree_cfg): Remove variable"}, {"sha": "afeb4de0751428b77cab805c2421d8c438b3cb21", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 15, "deletions": 19, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09fa81dbb7a6c892b01bac7e8193316fd1428d36/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09fa81dbb7a6c892b01bac7e8193316fd1428d36/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=09fa81dbb7a6c892b01bac7e8193316fd1428d36", "patch": "@@ -723,12 +723,7 @@ cleanup_tree_cfg (void)\n      opportunities for itself, so iterate on it until nothing\n      changes.  */\n   while (thread_jumps ())\n-    {\n-      /* delete_unreachable_blocks() does its job only when\n-\t thread_jumps() produces more unreachable blocks.  */\n-      delete_unreachable_blocks ();\n-      retval = true;\n-    }\n+    retval = true;\n \n #ifdef ENABLE_CHECKING\n   if (retval)\n@@ -3969,22 +3964,23 @@ thread_jumps (void)\n \t\t}\n \t    }\n \n-\t  /* Update the dominators.  */\n-\t  if (dom_computed[CDI_DOMINATORS] >= DOM_CONS_OK)\n+\t  /* Remove the unreachable blocks (observe that if all blocks\n+\t     were reachable before, only those in the path we threaded\n+\t     over and did not have any predecessor outside of the path\n+\t     become unreachable).  */\n+\t  for (; old_dest != dest; old_dest = tmp)\n \t    {\n-\t      /* Remove the unreachable blocks (observe that if all blocks\n-\t\t were reachable before, only those in the path we threaded\n-\t\t over and did not have any predecessor outside of the path\n-\t\t become unreachable).  */\n-\t      for (; old_dest != dest; old_dest = tmp)\n-\t\t{\n-\t\t  tmp = EDGE_SUCC (old_dest, 0)->dest;\n+\t      tmp = EDGE_SUCC (old_dest, 0)->dest;\n \n-\t\t  if (EDGE_COUNT (old_dest->preds) > 0)\n-\t\t    break;\n+\t      if (EDGE_COUNT (old_dest->preds) > 0)\n+\t\tbreak;\n \n-\t\t  delete_basic_block (old_dest);\n-\t\t}\n+\t      delete_basic_block (old_dest);\n+\t    }\n+\n+\t  /* Update the dominators.  */\n+\t  if (dom_computed[CDI_DOMINATORS] >= DOM_CONS_OK)\n+\t    {\n \t      /* If the dominator of the destination was in the path, set its\n \t\t dominator to the start of the redirected edge.  */\n \t      if (get_immediate_dominator (CDI_DOMINATORS, old_dest) == NULL)"}]}