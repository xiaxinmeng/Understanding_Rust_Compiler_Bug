{"sha": "16df4ee6c2ffe1d50d601794f43d23ed3b2b050c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTZkZjRlZTZjMmZmZTFkNTBkNjAxNzk0ZjQzZDIzZWQzYjJiMDUwYw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2005-05-10T16:37:36Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2005-05-10T16:37:36Z"}, "message": "ia64.c (ia64_expand_atomic_op): New.\n\n        * config/ia64/ia64.c (ia64_expand_atomic_op): New.\n        * config/ia64/ia64-protos.h: Declare it.\n        * config/ia64/sync.md (I124MODE, FETCHOP, fetchop_name): New.\n        (sync_add<I48MODE>, sync_old_add<I48MODE>): Remove.\n        (sync_<FETCHOP><IMODE>, sync_nand<IMODE>): New.\n        (sync_old_<FETCHOP><IMODE>, sync_old_nand<IMODE>): New.\n        (sync_new_<FETCHOP><IMODE>, sync_new_nand<IMODE>): New.\n        (cmpxchg_rel_<I124MODE>): Split from cmpxchg_acq_<IMODE>.  Zero\n        extend result; use release semantics.\n        (cmpxchg_rel_di): Rename from cmpxchg_acq_<IMODE>; use release.\n        (sync_val_compare_and_swap_<IMODE>): Update to match.\n\nFrom-SVN: r99527", "tree": {"sha": "a406036b256c752b114e7d03ababbf371f536a4b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a406036b256c752b114e7d03ababbf371f536a4b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/16df4ee6c2ffe1d50d601794f43d23ed3b2b050c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16df4ee6c2ffe1d50d601794f43d23ed3b2b050c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16df4ee6c2ffe1d50d601794f43d23ed3b2b050c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16df4ee6c2ffe1d50d601794f43d23ed3b2b050c/comments", "author": null, "committer": null, "parents": [{"sha": "64552cd79032ccee03175488798bd12e22062e6a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64552cd79032ccee03175488798bd12e22062e6a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/64552cd79032ccee03175488798bd12e22062e6a"}], "stats": {"total": 255, "additions": 219, "deletions": 36}, "files": [{"sha": "24428811ca23fb8da249f442b44daca59bc575a2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16df4ee6c2ffe1d50d601794f43d23ed3b2b050c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16df4ee6c2ffe1d50d601794f43d23ed3b2b050c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=16df4ee6c2ffe1d50d601794f43d23ed3b2b050c", "patch": "@@ -1,3 +1,17 @@\n+2005-05-10  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/ia64/ia64.c (ia64_expand_atomic_op): New.\n+\t* config/ia64/ia64-protos.h: Declare it.\n+\t* config/ia64/sync.md (I124MODE, FETCHOP, fetchop_name): New.\n+\t(sync_add<I48MODE>, sync_old_add<I48MODE>): Remove.\n+\t(sync_<FETCHOP><IMODE>, sync_nand<IMODE>): New.\n+\t(sync_old_<FETCHOP><IMODE>, sync_old_nand<IMODE>): New.\n+\t(sync_new_<FETCHOP><IMODE>, sync_new_nand<IMODE>): New.\n+\t(cmpxchg_rel_<I124MODE>): Split from cmpxchg_acq_<IMODE>.  Zero\n+\textend result; use release semantics.\n+\t(cmpxchg_rel_di): Rename from cmpxchg_acq_<IMODE>; use release.\n+\t(sync_val_compare_and_swap_<IMODE>): Update to match.\n+\n 2005-05-10  Richard Henderson  <rth@redhat.com>\n \n \t* optabs.c (expand_compare_and_swap_loop): Don't clobber old value"}, {"sha": "1eb458838607c656fba0b6982e6d2c04ec96cb5b", "filename": "gcc/config/ia64/ia64-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16df4ee6c2ffe1d50d601794f43d23ed3b2b050c/gcc%2Fconfig%2Fia64%2Fia64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16df4ee6c2ffe1d50d601794f43d23ed3b2b050c/gcc%2Fconfig%2Fia64%2Fia64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64-protos.h?ref=16df4ee6c2ffe1d50d601794f43d23ed3b2b050c", "patch": "@@ -51,6 +51,7 @@ extern bool ia64_expand_vecint_minmax (enum rtx_code, enum machine_mode, rtx[]);\n extern void ia64_expand_call (rtx, rtx, rtx, int);\n extern void ia64_split_call (rtx, rtx, rtx, rtx, rtx, int, int);\n extern void ia64_reload_gp (void);\n+extern void ia64_expand_atomic_op (enum rtx_code, rtx, rtx, rtx, rtx);\n \n extern HOST_WIDE_INT ia64_initial_elimination_offset (int, int);\n extern void ia64_expand_prologue (void);"}, {"sha": "d75a74f0f1e6a0d34aaaf342e43631ff2b34bf50", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16df4ee6c2ffe1d50d601794f43d23ed3b2b050c/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16df4ee6c2ffe1d50d601794f43d23ed3b2b050c/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=16df4ee6c2ffe1d50d601794f43d23ed3b2b050c", "patch": "@@ -1662,6 +1662,111 @@ ia64_split_call (rtx retval, rtx addr, rtx retaddr, rtx scratch_r,\n   if ((!TARGET_CONST_GP || is_desc) && !noreturn_p && !sibcall_p)\n     ia64_reload_gp ();\n }\n+\n+/* Expand an atomic operation.  We want to perform MEM <CODE>= VAL atomically.\n+\n+   This differs from the generic code in that we know about the zero-extending\n+   properties of cmpxchg, and the zero-extending requirements of ar.ccv.  We\n+   also know that ld.acq+cmpxchg.rel equals a full barrier.\n+\n+   The loop we want to generate looks like\n+\n+\tcmp_reg = mem;\n+      label:\n+        old_reg = cmp_reg;\n+\tnew_reg = cmp_reg op val;\n+\tcmp_reg = compare-and-swap(mem, old_reg, new_reg)\n+\tif (cmp_reg != old_reg)\n+\t  goto label;\n+\n+   Note that we only do the plain load from memory once.  Subsequent\n+   iterations use the value loaded by the compare-and-swap pattern.  */\n+\n+void\n+ia64_expand_atomic_op (enum rtx_code code, rtx mem, rtx val,\n+\t\t       rtx old_dst, rtx new_dst)\n+{\n+  enum machine_mode mode = GET_MODE (mem);\n+  rtx old_reg, new_reg, cmp_reg, ar_ccv, label;\n+  enum insn_code icode;\n+\n+  /* Special case for using fetchadd.  */\n+  if ((mode == SImode || mode == DImode) && fetchadd_operand (val, mode))\n+    {\n+      if (!old_dst)\n+        old_dst = gen_reg_rtx (mode);\n+\n+      emit_insn (gen_memory_barrier ());\n+\n+      if (mode == SImode)\n+\ticode = CODE_FOR_fetchadd_acq_si;\n+      else\n+\ticode = CODE_FOR_fetchadd_acq_di;\n+      emit_insn (GEN_FCN (icode) (old_dst, mem, val));\n+\n+      if (new_dst)\n+\t{\n+\t  new_reg = expand_simple_binop (mode, PLUS, old_dst, val, new_dst,\n+\t\t\t\t\t true, OPTAB_WIDEN);\n+\t  if (new_reg != new_dst)\n+\t    emit_move_insn (new_dst, new_reg);\n+\t}\n+      return;\n+    }\n+\n+  /* Because of the volatile mem read, we get an ld.acq, which is the\n+     front half of the full barrier.  The end half is the cmpxchg.rel.  */\n+  gcc_assert (MEM_VOLATILE_P (mem));\n+\n+  old_reg = gen_reg_rtx (DImode);\n+  cmp_reg = gen_reg_rtx (DImode);\n+  label = gen_label_rtx ();\n+\n+  if (mode != DImode)\n+    {\n+      val = simplify_gen_subreg (DImode, val, mode, 0);\n+      emit_insn (gen_extend_insn (cmp_reg, mem, DImode, mode, 1));\n+    }\n+  else\n+    emit_move_insn (cmp_reg, mem);\n+\n+  emit_label (label);\n+\n+  ar_ccv = gen_rtx_REG (DImode, AR_CCV_REGNUM);\n+  emit_move_insn (old_reg, cmp_reg);\n+  emit_move_insn (ar_ccv, cmp_reg);\n+\n+  if (old_dst)\n+    emit_move_insn (old_dst, gen_lowpart (mode, cmp_reg));\n+\n+  new_reg = cmp_reg;\n+  if (code == NOT)\n+    {\n+      new_reg = expand_simple_unop (DImode, NOT, new_reg, NULL_RTX, true);\n+      code = AND;\n+    }\n+  new_reg = expand_simple_binop (DImode, code, new_reg, val, NULL_RTX,\n+\t\t\t\t true, OPTAB_DIRECT);\n+\n+  if (mode != DImode)\n+    new_reg = gen_lowpart (mode, new_reg);\n+  if (new_dst)\n+    emit_move_insn (new_dst, new_reg);\n+\n+  switch (mode)\n+    {\n+    case QImode:  icode = CODE_FOR_cmpxchg_rel_qi;  break;\n+    case HImode:  icode = CODE_FOR_cmpxchg_rel_hi;  break;\n+    case SImode:  icode = CODE_FOR_cmpxchg_rel_si;  break;\n+    case DImode:  icode = CODE_FOR_cmpxchg_rel_di;  break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  emit_insn (GEN_FCN (icode) (cmp_reg, mem, ar_ccv, new_reg));\n+\n+  emit_cmp_and_jump_insns (cmp_reg, old_reg, EQ, NULL, DImode, true, label);\n+}\n \f\n /* Begin the assembly file.  */\n "}, {"sha": "a5fa1ff304c4c164a1259440df9bdc76f0b2eb48", "filename": "gcc/config/ia64/sync.md", "status": "modified", "additions": 99, "deletions": 36, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16df4ee6c2ffe1d50d601794f43d23ed3b2b050c/gcc%2Fconfig%2Fia64%2Fsync.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16df4ee6c2ffe1d50d601794f43d23ed3b2b050c/gcc%2Fconfig%2Fia64%2Fsync.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fsync.md?ref=16df4ee6c2ffe1d50d601794f43d23ed3b2b050c", "patch": "@@ -20,9 +20,13 @@\n ;; Boston, MA 02111-1307, USA.\n \n (define_mode_macro IMODE [QI HI SI DI])\n+(define_mode_macro I124MODE [QI HI SI])\n (define_mode_macro I48MODE [SI DI])\n (define_mode_attr modesuffix [(QI \"1\") (HI \"2\") (SI \"4\") (DI \"8\")])\n \n+(define_code_macro FETCHOP [plus minus ior xor and])\n+(define_code_attr fetchop_name\n+  [(plus \"add\") (minus \"sub\") (ior \"ior\") (xor \"xor\") (and \"and\")])\n \n (define_insn \"memory_barrier\"\n   [(set (mem:BLK (match_scratch:DI 0 \"X\"))\n@@ -31,44 +35,80 @@\n   \"mf\"\n   [(set_attr \"itanium_class\" \"syst_m\")])\n \n-(define_expand \"sync_add<mode>\"\n-  [(match_operand:I48MODE 0 \"memory_operand\" \"\")\n-   (match_operand:I48MODE 1 \"general_operand\" \"\")]\n+(define_insn \"fetchadd_acq_<mode>\"\n+  [(set (match_operand:I48MODE 0 \"gr_register_operand\" \"=r\")\n+\t(match_operand:I48MODE 1 \"not_postinc_memory_operand\" \"+S\"))\n+   (set (match_dup 1)\n+\t(unspec:I48MODE [(match_dup 1)\n+\t\t\t (match_operand:I48MODE 2 \"fetchadd_operand\" \"n\")]\n+\t\t        UNSPEC_FETCHADD_ACQ))]\n+  \"\"\n+  \"fetchadd<modesuffix>.acq %0 = %1, %2\"\n+  [(set_attr \"itanium_class\" \"sem\")])\n+\n+(define_expand \"sync_<fetchop_name><mode>\"\n+  [(set (match_operand:IMODE 0 \"memory_operand\" \"\")\n+\t(FETCHOP:IMODE (match_dup 0)\n+\t  (match_operand:IMODE 1 \"general_operand\" \"\")))]\n   \"\"\n {\n-  rtx tmp;\n-  if (!fetchadd_operand (operands[1], <MODE>mode))\n-    FAIL;\n+  ia64_expand_atomic_op (<CODE>, operands[0], operands[1], NULL, NULL);\n+  DONE;\n+})\n \n-  tmp = gen_reg_rtx (<MODE>mode);\n-  emit_insn (gen_memory_barrier ());\n-  emit_insn (gen_fetchadd_acq_<mode> (tmp, operands[0], operands[1]));\n+(define_expand \"sync_nand<mode>\"\n+  [(set (match_operand:IMODE 0 \"memory_operand\" \"\")\n+\t(and:IMODE (not:IMODE (match_dup 0))\n+\t  (match_operand:IMODE 1 \"general_operand\" \"\")))]\n+  \"\"\n+{\n+  ia64_expand_atomic_op (NOT, operands[0], operands[1], NULL, NULL);\n   DONE;\n })\n \n-(define_expand \"sync_old_add<mode>\"\n-  [(match_operand:I48MODE 0 \"gr_register_operand\" \"\")\n-   (match_operand:I48MODE 1 \"memory_operand\" \"\")\n-   (match_operand:I48MODE 2 \"general_operand\" \"\")]\n+(define_expand \"sync_old_<fetchop_name><mode>\"\n+  [(set (match_operand:IMODE 0 \"gr_register_operand\" \"\")\n+\t(FETCHOP:IMODE \n+\t  (match_operand:IMODE 1 \"memory_operand\" \"\")\n+\t  (match_operand:IMODE 2 \"general_operand\" \"\")))]\n   \"\"\n {\n-  if (!fetchadd_operand (operands[2], <MODE>mode))\n-    FAIL;\n-  emit_insn (gen_memory_barrier ());\n-  emit_insn (gen_fetchadd_acq_<mode> (operands[0], operands[1], operands[2]));\n+  ia64_expand_atomic_op (<CODE>, operands[1], operands[2], operands[0], NULL);\n   DONE;\n })\n \n-(define_insn \"fetchadd_acq_<mode>\"\n-  [(set (match_operand:I48MODE 0 \"gr_register_operand\" \"=r\")\n-\t(match_operand:I48MODE 1 \"not_postinc_memory_operand\" \"+S\"))\n-   (set (match_dup 1)\n-\t(unspec:I48MODE [(match_dup 1)\n-\t\t\t (match_operand:I48MODE 2 \"fetchadd_operand\" \"n\")]\n-\t\t        UNSPEC_FETCHADD_ACQ))]\n+(define_expand \"sync_old_nand<mode>\"\n+  [(set (match_operand:IMODE 0 \"gr_register_operand\" \"\")\n+\t(and:IMODE \n+\t  (not:IMODE (match_operand:IMODE 1 \"memory_operand\" \"\"))\n+\t  (match_operand:IMODE 2 \"general_operand\" \"\")))]\n   \"\"\n-  \"fetchadd<modesuffix>.acq %0 = %1, %2\"\n-  [(set_attr \"itanium_class\" \"sem\")])\n+{\n+  ia64_expand_atomic_op (NOT, operands[1], operands[2], operands[0], NULL);\n+  DONE;\n+})\n+\n+(define_expand \"sync_new_<fetchop_name><mode>\"\n+  [(set (match_operand:IMODE 0 \"gr_register_operand\" \"\")\n+\t(FETCHOP:IMODE \n+\t  (match_operand:IMODE 1 \"memory_operand\" \"\")\n+\t  (match_operand:IMODE 2 \"general_operand\" \"\")))]\n+  \"\"\n+{\n+  ia64_expand_atomic_op (<CODE>, operands[1], operands[2], NULL, operands[0]);\n+  DONE;\n+})\n+\n+(define_expand \"sync_new_nand<mode>\"\n+  [(set (match_operand:IMODE 0 \"gr_register_operand\" \"\")\n+\t(and:IMODE \n+\t  (not:IMODE (match_operand:IMODE 1 \"memory_operand\" \"\"))\n+\t  (match_operand:IMODE 2 \"general_operand\" \"\")))]\n+  \"\"\n+{\n+  ia64_expand_atomic_op (NOT, operands[1], operands[2], NULL, operands[0]);\n+  DONE;\n+})\n \n (define_expand \"sync_compare_and_swap<mode>\"\n   [(match_operand:IMODE 0 \"gr_register_operand\" \"\")\n@@ -78,23 +118,46 @@\n   \"\"\n {\n   rtx ccv = gen_rtx_REG (DImode, AR_CCV_REGNUM);\n+  rtx dst;\n+\n   convert_move (ccv, operands[2], 1);\n+\n+  dst = operands[0];\n+  if (GET_MODE (dst) != DImode)\n+    dst = gen_reg_rtx (DImode);\n+\n   emit_insn (gen_memory_barrier ());\n-  emit_insn (gen_cmpxchg_acq_<mode> (operands[0], operands[1],\n-\t\t\t\t     ccv, operands[3]));\n+  emit_insn (gen_cmpxchg_rel_<mode> (dst, operands[1], ccv, operands[3]));\n+\n+  if (dst != operands[0])\n+    emit_move_insn (operands[0], gen_lowpart (<MODE>mode, dst));\n   DONE;\n })\n \n-(define_insn \"cmpxchg_acq_<mode>\"\n-  [(set (match_operand:IMODE 0 \"gr_register_operand\" \"=r\")\n-\t(match_operand:IMODE 1 \"not_postinc_memory_operand\" \"+S\"))\n+(define_insn \"cmpxchg_rel_<mode>\"\n+  [(set (match_operand:DI 0 \"gr_register_operand\" \"=r\")\n+\t(zero_extend:DI\n+\t  (match_operand:I124MODE 1 \"not_postinc_memory_operand\" \"+S\")))\n+   (set (match_dup 1)\n+        (unspec:I124MODE\n+\t  [(match_dup 1)\n+\t   (match_operand:DI 2 \"ar_ccv_reg_operand\" \"\")\n+\t   (match_operand:I124MODE 3 \"gr_register_operand\" \"r\")]\n+\t  UNSPEC_CMPXCHG_ACQ))]\n+  \"\"\n+  \"cmpxchg<modesuffix>.rel %0 = %1, %3, %2\"\n+  [(set_attr \"itanium_class\" \"sem\")])\n+\n+(define_insn \"cmpxchg_rel_di\"\n+  [(set (match_operand:DI 0 \"gr_register_operand\" \"=r\")\n+\t(match_operand:DI 1 \"not_postinc_memory_operand\" \"+S\"))\n    (set (match_dup 1)\n-        (unspec:IMODE [(match_dup 1)\n-\t\t       (match_operand:DI 2 \"ar_ccv_reg_operand\" \"\")\n-\t\t       (match_operand:IMODE 3 \"gr_register_operand\" \"r\")]\n-\t\t      UNSPEC_CMPXCHG_ACQ))]\n+        (unspec:DI [(match_dup 1)\n+\t\t    (match_operand:DI 2 \"ar_ccv_reg_operand\" \"\")\n+\t\t    (match_operand:DI 3 \"gr_register_operand\" \"r\")]\n+\t\t   UNSPEC_CMPXCHG_ACQ))]\n   \"\"\n-  \"cmpxchg<modesuffix>.acq %0 = %1, %3, %2\"\n+  \"cmpxchg8.rel %0 = %1, %3, %2\"\n   [(set_attr \"itanium_class\" \"sem\")])\n \n (define_insn \"sync_lock_test_and_set<mode>\""}]}