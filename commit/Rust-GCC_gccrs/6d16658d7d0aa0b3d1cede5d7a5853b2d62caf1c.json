{"sha": "6d16658d7d0aa0b3d1cede5d7a5853b2d62caf1c", "node_id": "C_kwDOANBUbNoAKDZkMTY2NThkN2QwYWEwYjNkMWNlZGU1ZDdhNTg1M2IyZDYyY2FmMWM", "commit": {"author": {"name": "Bob Duff", "email": "duff@adacore.com", "date": "2022-08-08T18:45:31Z"}, "committer": {"name": "Marc Poulhi\u00e8s", "email": "poulhies@adacore.com", "date": "2022-09-06T07:14:21Z"}, "message": "[Ada] Place \"at end\" on body nodes\n\nThis patch fixes a bug where finalization code might refer to variables\noutside their lifetime. The previous version moved declarations into the\nHandled_Statement_Sequence (HSS), so that the \"at end\" handler of the\nHSS could handle exceptions raised by those declarations. The\nFirst_Real_Statement field was used to find the first statement after\nthe moved declarations. In addition, if the HSS already had exception\nhandlers, it was wrapped in another layer of block_statement. This\ndoesn't work if there are variable-sized objects allocated on the\n(primary) stack, because the stack will be popped before the \"at end\" is\ninvoked.\n\nIn the new version, we allow \"at end\" on nodes such as\nN_Subprogram_Body, in addition to HSS. We modify gigi so that such an\n\"at end\" applies to the whole body (declarations and HSS) by extending\nsupport for At_End_Proc mechanism to N_Block_Statement and N_*_Body\nnodes. This also removes the support for First_Real_Statement. In\nparticular, an exception raised by the declarations will trigger the \"at\nend\". We no longer move declarations into the HSS, we no longer have a\nFirst_Real_Statement field, and we no longer do the wrapping mentioned\nabove.\n\nThis change requires various other changes, in cases where we depended\non the First_Real_Statement and the moving/wrapping mentioned above.\n\ngcc/ada/\n\n\t* gen_il-fields.ads\n\t(First_Real_Statement): Remove this field.\n\t* gen_il-gen-gen_nodes.adb: Remove the First_Real_Statement field.\n\tAdd the At_End_Proc field to nodes that have both Declarations and\n\tHSS.\n\t* sinfo.ads\n\t(At_End_Proc): Document new semantics.\n\t(First_Real_Statement): Remove comment.\n\t* exp_ch11.adb\n\t(Expand_N_Handled_Sequence_Of_Statements): Remove\n\tFirst_Real_Statement.\n\t* exp_ch7.adb\n\t(Build_Cleanup_Statements): Remove \"Historical note\"; it doesn't\n\tseem useful, and we have revision history.\n\t(Create_Finalizer): Insert the finalizer later, typically in the\n\tstatement list, in some cases.\n\t(Build_Finalizer_Call): Attach the \"at end\" handler to the parent\n\tof the HSS node in most cases, so it applies to declarations.\n\t(Expand_Cleanup_Actions): Remove Wrap_HSS_In_Block and the call to\n\tit. Remove the code that moves declarations. Remove some redundant\n\tcode.\n\t* exp_ch9.adb\n\t(Build_Protected_Entry): Copy the At_End_Proc.\n\t(Build_Protected_Subprogram_Body): Reverse the sense of Exc_Safe,\n\tto avoid double negatives. Remove \"Historical note\" as in\n\texp_ch7.adb.\n\t(Build_Unprotected_Subprogram_Body): Copy the At_End_Proc from the\n\tprotected version.\n\t(Expand_N_Conditional_Entry_Call): Use First (Statements(...))\n\tinstead of First_Real_Statement(...).\n\t(Expand_N_Task_Body): Put the Abort_Undefer call at the beginning\n\tof the declarations, rather than in the HSS. Use First\n\t(Statements(...)) instead of First_Real_Statement(...). Copy the\n\tAt_End_Proc.\n\t* inline.adb\n\t(Has_Initialized_Type): Return False if the declaration does not\n\tcome from source.\n\t* libgnarl/s-tpoben.ads\n\t(Lock_Entries, Lock_Entries_With_Status): Document when these\n\tthings raise Program_Error. It's not clear that\n\tLock_Entries_With_Status ought to be raising exceptions, but at\n\tleast it's documented now.\n\t* sem.ads: Minor comment fixes.\n\t* sem_ch6.adb\n\t(Analyze_Subprogram_Body_Helper): Use First (Statements(...))\n\tinstead of First_Real_Statement(...).\n\t(Analyze_Null_Procedure): Minor comment fix.\n\t* sem_util.adb\n\t(Might_Raise): Return True for N_Raise_Expression. Adjust the part\n\tabout exceptions generated by the back end to match the reality of\n\twhat the back end generates.\n\t(Update_First_Real_Statement): Remove.\n\t* sem_util.ads: Remove First_Real_Statement from comment.\n\t* sinfo-utils.ads\n\t(First_Real_Statement): New function that always returns Empty.\n\tThis should be removed once gnat-llvm and codepeer have been\n\tupdated to not refer to First_Real_Statement.\n\t* sprint.adb\n\t(Sprint_At_End_Proc): Deal with printing At_End_Proc.\n\t* sem_prag.adb: Minor comment fixes.\n\t* gcc-interface/trans.cc (At_End_Proc_to_gnu): New function.\n\t(Subprogram_Body_to_gnu): Call it to handle an At_End_Proc.\n\t(Handled_Sequence_Of_Statements_to_gnu): Likewise. Remove the\n\tsupport for First_Real_Statement and clean up the rest.\n\t(Exception_Handler_to_gnu): Do not push binding levels.\n\t(Compilation_Unit_to_gnu): Adjust call to process_decls.\n\t(gnat_to_gnu) <N_Package_Specification>: Likewise. <N_Entry_Body>:\n\tLikewise. <N_Freeze_Entity>: Likewise. <N_Block_Statement>:\n\tLikewise and call At_End_Proc_to_gnu to handle an At_End_Proc.\n\t<N_Package_Body>: Likewise.\n\t(process_decls): Remove GNAT_END_LIST parameter and adjust\n\trecursive calls.\n\nCo-authored-by: Eric Botcazou <ebotcazou@adacore.com>", "tree": {"sha": "c75af43821934b416aa26ff3b64c79bfd5db59b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c75af43821934b416aa26ff3b64c79bfd5db59b8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6d16658d7d0aa0b3d1cede5d7a5853b2d62caf1c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d16658d7d0aa0b3d1cede5d7a5853b2d62caf1c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d16658d7d0aa0b3d1cede5d7a5853b2d62caf1c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d16658d7d0aa0b3d1cede5d7a5853b2d62caf1c/comments", "author": {"login": "bobduff", "id": 29099567, "node_id": "MDQ6VXNlcjI5MDk5NTY3", "avatar_url": "https://avatars.githubusercontent.com/u/29099567?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bobduff", "html_url": "https://github.com/bobduff", "followers_url": "https://api.github.com/users/bobduff/followers", "following_url": "https://api.github.com/users/bobduff/following{/other_user}", "gists_url": "https://api.github.com/users/bobduff/gists{/gist_id}", "starred_url": "https://api.github.com/users/bobduff/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bobduff/subscriptions", "organizations_url": "https://api.github.com/users/bobduff/orgs", "repos_url": "https://api.github.com/users/bobduff/repos", "events_url": "https://api.github.com/users/bobduff/events{/privacy}", "received_events_url": "https://api.github.com/users/bobduff/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dkm", "id": 87603, "node_id": "MDQ6VXNlcjg3NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/87603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dkm", "html_url": "https://github.com/dkm", "followers_url": "https://api.github.com/users/dkm/followers", "following_url": "https://api.github.com/users/dkm/following{/other_user}", "gists_url": "https://api.github.com/users/dkm/gists{/gist_id}", "starred_url": "https://api.github.com/users/dkm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dkm/subscriptions", "organizations_url": "https://api.github.com/users/dkm/orgs", "repos_url": "https://api.github.com/users/dkm/repos", "events_url": "https://api.github.com/users/dkm/events{/privacy}", "received_events_url": "https://api.github.com/users/dkm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aed54a141a74b1752a5ba052f2ef151940867201", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aed54a141a74b1752a5ba052f2ef151940867201", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aed54a141a74b1752a5ba052f2ef151940867201"}], "stats": {"total": 641, "additions": 237, "deletions": 404}, "files": [{"sha": "98ce886c71cf16cb52deb7743add88edff64ec76", "filename": "gcc/ada/exp_ch11.adb", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d16658d7d0aa0b3d1cede5d7a5853b2d62caf1c/gcc%2Fada%2Fexp_ch11.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d16658d7d0aa0b3d1cede5d7a5853b2d62caf1c/gcc%2Fada%2Fexp_ch11.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch11.adb?ref=6d16658d7d0aa0b3d1cede5d7a5853b2d62caf1c", "patch": "@@ -1305,9 +1305,6 @@ package body Exp_Ch11 is\n       then\n          pragma Assert (not Is_Thunk (Current_Scope));\n          Expand_Cleanup_Actions (Parent (N));\n-\n-      else\n-         Set_First_Real_Statement (N, First (Statements (N)));\n       end if;\n    end Expand_N_Handled_Sequence_Of_Statements;\n "}, {"sha": "3ffebfb6408d67a6d697d223d7eabe406cedbd40", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 52, "deletions": 172, "changes": 224, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d16658d7d0aa0b3d1cede5d7a5853b2d62caf1c/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d16658d7d0aa0b3d1cede5d7a5853b2d62caf1c/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=6d16658d7d0aa0b3d1cede5d7a5853b2d62caf1c", "patch": "@@ -59,7 +59,6 @@ with Sinfo.Nodes;    use Sinfo.Nodes;\n with Sinfo.Utils;    use Sinfo.Utils;\n with Sem;            use Sem;\n with Sem_Aux;        use Sem_Aux;\n-with Sem_Ch3;        use Sem_Ch3;\n with Sem_Ch7;        use Sem_Ch7;\n with Sem_Ch8;        use Sem_Ch8;\n with Sem_Res;        use Sem_Res;\n@@ -927,10 +926,6 @@ package body Exp_Ch7 is\n             pragma Assert (Present (Param));\n             pragma Assert (Present (Conc_Typ));\n \n-            --  Historical note: In earlier versions of GNAT, there was code\n-            --  at this point to generate stuff to service entry queues. It is\n-            --  now abstracted in Build_Protected_Subprogram_Call_Cleanup.\n-\n             Build_Protected_Subprogram_Call_Cleanup\n               (Specification (N), Conc_Typ, Loc, Stmts);\n          end;\n@@ -2066,10 +2061,15 @@ package body Exp_Ch7 is\n                --  In the case where the last construct to contain a controlled\n                --  object is either a nested package, an instantiation or a\n                --  freeze node, the body must be inserted directly after the\n-               --  construct.\n+               --  construct, except if the insertion point is already placed\n+               --  after the construct, typically in the statement list.\n \n                if Nkind (Last_Top_Level_Ctrl_Construct) in\n                     N_Freeze_Entity | N_Package_Declaration | N_Package_Body\n+                 and then not\n+                  (List_Containing (Last_Top_Level_Ctrl_Construct) = Spec_Decls\n+                    and then Present (Stmts)\n+                    and then List_Containing (Finalizer_Insert_Nod) = Stmts)\n                then\n                   Finalizer_Insert_Nod := Last_Top_Level_Ctrl_Construct;\n                end if;\n@@ -2546,7 +2546,7 @@ package body Exp_Ch7 is\n                            --  template and not the actually instantiation\n                            --  (which is generated too late for us to process\n                            --  it), so there is no need to update in particular\n-                           --  to update Last_Top_Level_Ctrl_Construct here.\n+                           --  Last_Top_Level_Ctrl_Construct here.\n \n                            if Counter_Val > Old_Counter_Val then\n                               Counter_Val := Old_Counter_Val;\n@@ -3692,15 +3692,6 @@ package body Exp_Ch7 is\n    --------------------------\n \n    procedure Build_Finalizer_Call (N : Node_Id; Fin_Id : Entity_Id) is\n-      Is_Protected_Subp_Body : constant Boolean :=\n-        Nkind (N) = N_Subprogram_Body\n-        and then Is_Protected_Subprogram_Body (N);\n-      --  Determine whether N denotes the protected version of a subprogram\n-      --  which belongs to a protected type.\n-\n-      Loc : constant Source_Ptr := Sloc (N);\n-      HSS : Node_Id := Handled_Statement_Sequence (N);\n-\n    begin\n       --  Do not perform this expansion in SPARK mode because we do not create\n       --  finalizers in the first place.\n@@ -3730,19 +3721,40 @@ package body Exp_Ch7 is\n       --        end;\n       --     end Prot_SubpP;\n \n-      if Is_Protected_Subp_Body then\n-         HSS := Handled_Statement_Sequence (Last (Statements (HSS)));\n-      end if;\n-\n-      pragma Assert (No (At_End_Proc (HSS)));\n-      Set_At_End_Proc (HSS, New_Occurrence_Of (Fin_Id, Loc));\n-\n-      --  Attach reference to finalizer to tree, for LLVM use\n-\n-      Set_Parent (At_End_Proc (HSS), HSS);\n+      declare\n+         Loc : constant Source_Ptr := Sloc (N);\n \n-      Analyze (At_End_Proc (HSS));\n-      Expand_At_End_Handler (HSS, Empty);\n+         Is_Protected_Subp_Body : constant Boolean :=\n+           Nkind (N) = N_Subprogram_Body\n+           and then Is_Protected_Subprogram_Body (N);\n+         --  True if N is the protected version of a subprogram that belongs to\n+         --  a protected type.\n+\n+         HSS : constant Node_Id :=\n+           (if Is_Protected_Subp_Body\n+             then Handled_Statement_Sequence\n+               (Last (Statements (Handled_Statement_Sequence (N))))\n+             else Handled_Statement_Sequence (N));\n+\n+         --  We attach the At_End_Proc to the HSS if this is an accept\n+         --  statement or extended return statement. Also in the case of\n+         --  a protected subprogram, because if Service_Entries raises an\n+         --  exception, we do not lock the PO, so we also do not want to\n+         --  unlock it.\n+\n+         Use_HSS : constant Boolean :=\n+           Nkind (N) in N_Accept_Statement | N_Extended_Return_Statement\n+           or else Is_Protected_Subp_Body;\n+\n+         At_End_Proc_Bearer : constant Node_Id := (if Use_HSS then HSS else N);\n+      begin\n+         pragma Assert (No (At_End_Proc (At_End_Proc_Bearer)));\n+         Set_At_End_Proc (At_End_Proc_Bearer, New_Occurrence_Of (Fin_Id, Loc));\n+         --  Attach reference to finalizer to tree, for LLVM use\n+         Set_Parent (At_End_Proc (At_End_Proc_Bearer), At_End_Proc_Bearer);\n+         Analyze (At_End_Proc (At_End_Proc_Bearer));\n+         Expand_At_End_Handler (At_End_Proc_Bearer, Empty);\n+      end;\n    end Build_Finalizer_Call;\n \n    ---------------------\n@@ -5544,12 +5556,6 @@ package body Exp_Ch7 is\n                                  Nkind (N) = N_Block_Statement\n                                    and then Present (Cleanup_Actions (N));\n \n-      Has_Postcondition      : constant Boolean :=\n-                                 Nkind (N) = N_Subprogram_Body\n-                                   and then Present\n-                                              (Postconditions_Proc\n-                                                (Unique_Defining_Entity (N)));\n-\n       Actions_Required       : constant Boolean :=\n                                  Requires_Cleanup_Actions (N, True)\n                                    or else Is_Asynchronous_Call\n@@ -5560,47 +5566,9 @@ package body Exp_Ch7 is\n                                    or else Needs_Sec_Stack_Mark\n                                    or else Needs_Custom_Cleanup;\n \n-      HSS : Node_Id := Handled_Statement_Sequence (N);\n       Loc : Source_Ptr;\n       Cln : List_Id;\n \n-      procedure Wrap_HSS_In_Block;\n-      --  Move HSS inside a new block along with the original exception\n-      --  handlers. Make the newly generated block the sole statement of HSS.\n-\n-      -----------------------\n-      -- Wrap_HSS_In_Block --\n-      -----------------------\n-\n-      procedure Wrap_HSS_In_Block is\n-         Block : constant Node_Id :=\n-           Make_Block_Statement (Loc, Handled_Statement_Sequence => HSS);\n-         Block_Id : constant Entity_Id :=\n-           New_Internal_Entity (E_Block, Current_Scope, Loc, 'B');\n-         End_Lab : constant Node_Id := End_Label (HSS);\n-         --  Preserve end label to provide proper cross-reference information\n-\n-      begin\n-         Set_Identifier (Block, New_Occurrence_Of (Block_Id, Loc));\n-         Set_Etype (Block_Id, Standard_Void_Type);\n-         Set_Block_Node (Block_Id, Identifier (Block));\n-\n-         --  Signal the finalization machinery that this particular block\n-         --  contains the original context.\n-\n-         Set_Is_Finalization_Wrapper (Block);\n-\n-         HSS := Make_Handled_Sequence_Of_Statements (Loc,\n-           Statements => New_List (Block),\n-           End_Label => End_Lab);\n-         Set_First_Real_Statement (HSS, Block);\n-         Set_Handled_Statement_Sequence (N, HSS);\n-\n-         if Nkind (N) = N_Subprogram_Body then\n-            Set_Has_Nested_Block_With_Handler (Scop);\n-         end if;\n-      end Wrap_HSS_In_Block;\n-\n    --  Start of processing for Expand_Cleanup_Actions\n \n    begin\n@@ -5671,12 +5639,14 @@ package body Exp_Ch7 is\n          Cln := No_List;\n       end if;\n \n-      declare\n-         Decls     : List_Id := Declarations (N);\n-         Fin_Id    : Entity_Id;\n-         Mark      : Entity_Id := Empty;\n-         New_Decls : List_Id;\n+      if No (Declarations (N)) then\n+         Set_Declarations (N, New_List);\n+      end if;\n \n+      declare\n+         Decls  : constant List_Id := Declarations (N);\n+         Fin_Id : Entity_Id;\n+         Mark   : Entity_Id := Empty;\n       begin\n          --  If we are generating expanded code for debugging purposes, use the\n          --  Sloc of the point of insertion for the cleanup code. The Sloc will\n@@ -5703,109 +5673,22 @@ package body Exp_Ch7 is\n             Establish_Task_Master (N);\n          end if;\n \n-         New_Decls := New_List;\n-\n          --  If secondary stack is in use, generate:\n          --\n          --    Mnn : constant Mark_Id := SS_Mark;\n \n          if Needs_Sec_Stack_Mark then\n+            Set_Uses_Sec_Stack (Scop, False); -- avoid duplicate SS marks\n             Mark := Make_Temporary (Loc, 'M');\n \n-            Append_To (New_Decls, Build_SS_Mark_Call (Loc, Mark));\n-            Set_Uses_Sec_Stack (Scop, False);\n-         end if;\n-\n-         --  If exception handlers are present in a non-subprogram\n-         --  construct, wrap the sequence of statements in a block.\n-         --  Otherwise, code can be moved so that the wrong handlers\n-         --  apply. It is important not to do this for function bodies,\n-         --  because otherwise transient finalizable objects created\n-         --  by a return statement get finalized too late. It is harmless\n-         --  not to do this for procedures.\n-\n-         if Present (Exception_Handlers (HSS))\n-           and then Nkind (N) /= N_Subprogram_Body\n-         then\n-            Wrap_HSS_In_Block;\n-\n-         --  Ensure that the First_Real_Statement field is set\n-\n-         elsif No (First_Real_Statement (HSS)) then\n-            Set_First_Real_Statement (HSS, First (Statements (HSS)));\n-         end if;\n-\n-         --  Do not move the Activation_Chain declaration in the context of\n-         --  task allocation blocks. Task allocation blocks use _chain in their\n-         --  cleanup handlers and gigi complains if it is declared in the\n-         --  sequence of statements of the scope that declares the handler.\n-\n-         if Is_Task_Allocation then\n             declare\n-               Chain_Decl : constant N_Object_Declaration_Id :=\n-                 Parent (Activation_Chain_Entity (N));\n-               pragma Assert (List_Containing (Chain_Decl) = Decls);\n+               Mark_Call : constant Node_Id := Build_SS_Mark_Call (Loc, Mark);\n             begin\n-               Remove (Chain_Decl);\n-               Prepend_To (New_Decls, Chain_Decl);\n+               Prepend_To (Decls, Mark_Call);\n+               Analyze (Mark_Call);\n             end;\n          end if;\n \n-         --  Move the _postconditions subprogram declaration and its associated\n-         --  objects into the declarations section so that it is callable\n-         --  within _postconditions.\n-\n-         if Has_Postcondition then\n-            declare\n-               Decl      : Node_Id;\n-               Prev_Decl : Node_Id;\n-\n-            begin\n-               Decl :=\n-                 Prev (Subprogram_Body\n-                        (Postconditions_Proc (Current_Subprogram)));\n-               while Present (Decl) loop\n-                  Prev_Decl := Prev (Decl);\n-\n-                  Remove (Decl);\n-                  Prepend_To (New_Decls, Decl);\n-\n-                  exit when Nkind (Decl) = N_Subprogram_Declaration\n-                              and then Chars (Corresponding_Body (Decl))\n-                                         = Name_uPostconditions;\n-\n-                  Decl := Prev_Decl;\n-               end loop;\n-            end;\n-         end if;\n-\n-         --  Ensure the presence of a declaration list in order to successfully\n-         --  append all original statements to it.\n-\n-         if No (Decls) then\n-            Set_Declarations (N, New_List);\n-            Decls := Declarations (N);\n-         end if;\n-\n-         --  Move the declarations into the sequence of statements in order to\n-         --  have them protected by the At_End handler. It may seem weird to\n-         --  put declarations in the sequence of statement but in fact nothing\n-         --  forbids that at the tree level.\n-\n-         Append_List_To (Decls, Statements (HSS));\n-         Set_Statements (HSS, Decls);\n-\n-         --  Reset the Sloc of the handled statement sequence to properly\n-         --  reflect the new initial \"statement\" in the sequence.\n-\n-         Set_Sloc (HSS, Sloc (First (Decls)));\n-\n-         --  The declarations of finalizer spec and auxiliary variables replace\n-         --  the old declarations that have been moved inward.\n-\n-         Set_Declarations (N, New_Decls);\n-         Analyze_Declarations (New_Decls);\n-\n          --  Generate finalization calls for all controlled objects appearing\n          --  in the statements of N. Add context specific cleanup for various\n          --  constructs.\n@@ -5814,7 +5697,7 @@ package body Exp_Ch7 is\n            (N           => N,\n             Clean_Stmts => Build_Cleanup_Statements (N, Cln),\n             Mark_Id     => Mark,\n-            Top_Decls   => New_Decls,\n+            Top_Decls   => Decls,\n             Defer_Abort => Nkind (Original_Node (N)) = N_Task_Body\n                              or else Is_Master,\n             Fin_Id      => Fin_Id);\n@@ -10103,9 +9986,6 @@ package body Exp_Ch7 is\n             Make_Handled_Sequence_Of_Statements (Loc,\n               Statements => New_List (Loop_Copy)));\n \n-      Set_First_Real_Statement\n-        (Handled_Statement_Sequence (Local_Body), Loop_Copy);\n-\n       Rewrite (Loop_Stmt, Local_Body);\n       Analyze (Loop_Stmt);\n "}, {"sha": "a5349e7611b0e1b711db774e2cf22dde68624510", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 25, "deletions": 33, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d16658d7d0aa0b3d1cede5d7a5853b2d62caf1c/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d16658d7d0aa0b3d1cede5d7a5853b2d62caf1c/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=6d16658d7d0aa0b3d1cede5d7a5853b2d62caf1c", "patch": "@@ -3811,6 +3811,7 @@ package body Exp_Ch9 is\n          --  Establish link between subprogram body and source entry body\n \n          Set_Corresponding_Entry_Body (Proc_Body, N);\n+         Set_At_End_Proc (Proc_Body, At_End_Proc (N));\n \n          Reset_Scopes_To (Proc_Body, Protected_Body_Subprogram (Ent));\n          return Proc_Body;\n@@ -4021,8 +4022,7 @@ package body Exp_Ch9 is\n       Pid       : Node_Id;\n       N_Op_Spec : Node_Id) return Node_Id\n    is\n-      Exc_Safe : constant Boolean := not Might_Raise (N);\n-      --  True if N cannot raise an exception\n+      Might_Raise : constant Boolean := Sem_Util.Might_Raise (N);\n \n       Loc       : constant Source_Ptr := Sloc (N);\n       Op_Spec   : constant Node_Id := Specification (N);\n@@ -4059,7 +4059,17 @@ package body Exp_Ch9 is\n       --  for use by the protected version built below.\n \n       if Nkind (Op_Spec) = N_Function_Specification then\n-         if Exc_Safe then\n+         if Might_Raise then\n+            Unprot_Call :=\n+              Make_Simple_Return_Statement (Loc,\n+                Expression =>\n+                  Make_Function_Call (Loc,\n+                    Name                   =>\n+                      Make_Identifier (Loc,\n+                        Chars => Chars (Defining_Unit_Name (N_Op_Spec))),\n+                    Parameter_Associations => Uactuals));\n+\n+         else\n             R := Make_Temporary (Loc, 'R');\n \n             Unprot_Call :=\n@@ -4078,16 +4088,6 @@ package body Exp_Ch9 is\n             Return_Stmt :=\n               Make_Simple_Return_Statement (Loc,\n                 Expression => New_Occurrence_Of (R, Loc));\n-\n-         else\n-            Unprot_Call :=\n-              Make_Simple_Return_Statement (Loc,\n-                Expression =>\n-                  Make_Function_Call (Loc,\n-                    Name                   =>\n-                      Make_Identifier (Loc,\n-                        Chars => Chars (Defining_Unit_Name (N_Op_Spec))),\n-                    Parameter_Associations => Uactuals));\n          end if;\n \n          if Has_Aspect (Pid, Aspect_Exclusive_Functions)\n@@ -4113,7 +4113,7 @@ package body Exp_Ch9 is\n \n       --  Wrap call in block that will be covered by an at_end handler\n \n-      if not Exc_Safe then\n+      if Might_Raise then\n          Unprot_Call :=\n            Make_Block_Statement (Loc,\n              Handled_Statement_Sequence =>\n@@ -4160,7 +4160,7 @@ package body Exp_Ch9 is\n          Stmts := New_List (Lock_Stmt);\n       end if;\n \n-      if not Exc_Safe then\n+      if Might_Raise then\n          Append (Unprot_Call, Stmts);\n       else\n          if Nkind (Op_Spec) = N_Function_Specification then\n@@ -4170,10 +4170,6 @@ package body Exp_Ch9 is\n             Append (Unprot_Call, Stmts);\n          end if;\n \n-         --  Historical note: Previously, call to the cleanup was inserted\n-         --  here. This is now done by Build_Protected_Subprogram_Call_Cleanup,\n-         --  which is also shared by the 'not Exc_Safe' path.\n-\n          Build_Protected_Subprogram_Call_Cleanup (Op_Spec, Pid, Loc, Stmts);\n \n          if Nkind (Op_Spec) = N_Function_Specification then\n@@ -4196,10 +4192,10 @@ package body Exp_Ch9 is\n             Make_Handled_Sequence_Of_Statements (Loc, Statements => Stmts));\n \n       --  Mark this subprogram as a protected subprogram body so that the\n-      --  cleanup will be inserted. This is done only in the 'not Exc_Safe'\n-      --  path as otherwise the cleanup has already been inserted.\n+      --  cleanup will be inserted. This is done only in the Might_Raise\n+      --  case because otherwise the cleanup has already been inserted.\n \n-      if not Exc_Safe then\n+      if Might_Raise then\n          Set_Is_Protected_Subprogram_Body (Sub_Body);\n       end if;\n \n@@ -5236,7 +5232,8 @@ package body Exp_Ch9 is\n           Specification              =>\n             Build_Protected_Sub_Specification (N, Pid, Unprotected_Mode),\n           Declarations               => Decls,\n-          Handled_Statement_Sequence => Handled_Statement_Sequence (N));\n+          Handled_Statement_Sequence => Handled_Statement_Sequence (N),\n+          At_End_Proc                => At_End_Proc (N));\n    end Build_Unprotected_Subprogram_Body;\n \n    ----------------------------\n@@ -8216,7 +8213,7 @@ package body Exp_Ch9 is\n \n       else\n          Transient_Blk :=\n-           First_Real_Statement (Handled_Statement_Sequence (Blk));\n+           First (Statements (Handled_Statement_Sequence (Blk)));\n \n          if Present (Transient_Blk)\n            and then Nkind (Transient_Blk) = N_Block_Statement\n@@ -11833,17 +11830,11 @@ package body Exp_Ch9 is\n \n       if Abort_Allowed then\n          Call := Build_Runtime_Call (Loc, RE_Abort_Undefer);\n-         Insert_Before\n-           (First (Statements (Handled_Statement_Sequence (N))), Call);\n+         Prepend (Call, Declarations (N));\n          Analyze (Call);\n       end if;\n \n-      --  The statement part has already been protected with an at_end and\n-      --  cleanup actions. The call to Complete_Activation must be placed\n-      --  at the head of the sequence of statements of that block. The\n-      --  declarations have been merged in this sequence of statements but\n-      --  the first real statement is accessible from the First_Real_Statement\n-      --  field (which was set for exactly this purpose).\n+      --  Place call to Complete_Activation at the head of the statement list.\n \n       if Restricted_Profile then\n          Call := Build_Runtime_Call (Loc, RE_Complete_Restricted_Activation);\n@@ -11852,7 +11843,7 @@ package body Exp_Ch9 is\n       end if;\n \n       Insert_Before\n-        (First_Real_Statement (Handled_Statement_Sequence (N)), Call);\n+        (First (Statements (Handled_Statement_Sequence (N))), Call);\n       Analyze (Call);\n \n       New_N :=\n@@ -11861,6 +11852,7 @@ package body Exp_Ch9 is\n           Declarations               => Declarations (N),\n           Handled_Statement_Sequence => Handled_Statement_Sequence (N));\n       Set_Is_Task_Body_Procedure (New_N);\n+      Set_At_End_Proc (New_N, At_End_Proc (N));\n \n       --  If the task contains generic instantiations, cleanup actions are\n       --  delayed until after instantiation. Transfer the activation chain to"}, {"sha": "58412a0f76a3f8ef79f45a25c95f0a8db0cee18a", "filename": "gcc/ada/gcc-interface/trans.cc", "status": "modified", "additions": 71, "deletions": 85, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d16658d7d0aa0b3d1cede5d7a5853b2d62caf1c/gcc%2Fada%2Fgcc-interface%2Ftrans.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d16658d7d0aa0b3d1cede5d7a5853b2d62caf1c/gcc%2Fada%2Fgcc-interface%2Ftrans.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.cc?ref=6d16658d7d0aa0b3d1cede5d7a5853b2d62caf1c", "patch": "@@ -234,7 +234,7 @@ static inline bool stmt_group_may_fallthru (void);\n static enum gimplify_status gnat_gimplify_stmt (tree *);\n static void elaborate_all_entities (Node_Id);\n static void process_freeze_entity (Node_Id);\n-static void process_decls (List_Id, List_Id, Node_Id, bool, bool);\n+static void process_decls (List_Id, List_Id, bool, bool);\n static tree emit_check (tree, tree, int, Node_Id);\n static tree build_unary_op_trapv (enum tree_code, tree, tree, Node_Id);\n static tree build_binary_op_trapv (enum tree_code, tree, tree, tree, Node_Id);\n@@ -3778,6 +3778,30 @@ build_return_expr (tree ret_obj, tree ret_val)\n   return build1 (RETURN_EXPR, void_type_node, result_expr);\n }\n \n+/* Subroutine of gnat_to_gnu to translate the At_End_Proc of GNAT_NODE, an\n+   N_Block_Statement or N_Handled_Sequence_Of_Statements or N_*_Body node.\n+\n+   To invoked the GCC mechanism, we call add_cleanup and when we leave the\n+   group, end_stmt_group will create the TRY_FINALLY_EXPR construct.  */\n+\n+static void\n+At_End_Proc_to_gnu (Node_Id gnat_node)\n+{\n+  tree proc_decl = gnat_to_gnu (At_End_Proc (gnat_node));\n+\n+  /* When not optimizing, disable inlining of finalizers as this can\n+     create a more complex CFG in the parent function.  */\n+  if (!optimize || optimize_debug)\n+    DECL_DECLARED_INLINE_P (proc_decl) = 0;\n+\n+  /* If there is no end label attached, we use the location of the At_End\n+     procedure because Expand_Cleanup_Actions might reset the location of\n+      the enclosing construct to that of an inner statement.  */\n+  add_cleanup (build_call_n_expr (proc_decl, 0),\n+\t       Present (End_Label (gnat_node))\n+\t       ? End_Label (gnat_node) : At_End_Proc (gnat_node));\n+}\n+\n /* Subroutine of gnat_to_gnu to translate GNAT_NODE, an N_Subprogram_Body.  */\n \n static void\n@@ -3928,12 +3952,16 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n   gnat_pushlevel ();\n \n   /* First translate the declarations of the subprogram.  */\n-  process_decls (Declarations (gnat_node), Empty, Empty, true, true);\n+  process_decls (Declarations (gnat_node), Empty, true, true);\n \n   /* Then generate the code of the subprogram itself.  A return statement will\n      be present and any Out parameters will be handled there.  */\n   add_stmt (gnat_to_gnu (Handled_Statement_Sequence (gnat_node)));\n \n+  /* Process the At_End_Proc, if any.  */\n+  if (Present (At_End_Proc (gnat_node)))\n+    At_End_Proc_to_gnu (gnat_node);\n+\n   gnat_poplevel ();\n   tree gnu_result = end_stmt_group ();\n \n@@ -5305,86 +5333,50 @@ static tree\n Handled_Sequence_Of_Statements_to_gnu (Node_Id gnat_node)\n {\n   /* If just annotating, ignore all EH and cleanups.  */\n-  const bool gcc_eh\n+  const bool eh\n     = !type_annotate_only && Present (Exception_Handlers (gnat_node));\n   const bool at_end = !type_annotate_only && Present (At_End_Proc (gnat_node));\n-  const bool binding_for_block = (at_end || gcc_eh);\n-  tree gnu_inner_block; /* The statement(s) for the block itself.  */\n   tree gnu_result;\n   Node_Id gnat_temp;\n \n-  /* The GCC exception handling mechanism can handle both ZCX and SJLJ schemes.\n-     To call the GCC mechanism, we call add_cleanup, and when we leave the\n-     binding, end_stmt_group will create the TRY_FINALLY_EXPR construct.\n+  /* The exception handling mechanism can handle both ZCX and SJLJ schemes, and\n+     is exposed through the TRY_CATCH_EXPR construct that we build manually.\n \n      ??? The region level calls down there have been specifically put in place\n      for a ZCX context and currently the order in which things are emitted\n      (region/handlers) is different from the SJLJ case.  Instead of putting\n      other calls with different conditions at other places for the SJLJ case,\n      it seems cleaner to reorder things for the SJLJ case and generalize the\n-     condition to make it not ZCX specific.\n+     condition to make it not ZCX specific.  */\n \n-     If there are any exceptions or cleanup processing involved, we need an\n-     outer statement group and binding level.  */\n-  if (binding_for_block)\n-    {\n-      start_stmt_group ();\n-      gnat_pushlevel ();\n-    }\n-\n-  /* If we are to call a function when exiting this block, add a cleanup\n-     to the binding level we made above.  Note that add_cleanup is FIFO\n-     so we must register this cleanup after the EH cleanup just above.  */\n-  if (at_end)\n-    {\n-      tree proc_decl = gnat_to_gnu (At_End_Proc (gnat_node));\n-\n-      /* When not optimizing, disable inlining of finalizers as this can\n-\t create a more complex CFG in the parent function.  */\n-      if (!optimize || optimize_debug)\n-\tDECL_DECLARED_INLINE_P (proc_decl) = 0;\n-\n-      /* If there is no end label attached, we use the location of the At_End\n-\t procedure because Expand_Cleanup_Actions might reset the location of\n-\t the enclosing construct to that of an inner statement.  */\n-      add_cleanup (build_call_n_expr (proc_decl, 0),\n-\t\t   Present (End_Label (gnat_node))\n-\t\t   ? End_Label (gnat_node) : At_End_Proc (gnat_node));\n-    }\n-\n-  /* Now build the tree for the declarations and statements inside this\n-     block.  */\n+  /* First build the tree for the statements inside the sequence.  */\n   start_stmt_group ();\n \n-  if (Present (First_Real_Statement (gnat_node)))\n-    process_decls (Statements (gnat_node), Empty,\n-\t\t   First_Real_Statement (gnat_node), true, true);\n-\n-  /* Generate code for each statement in the block.  */\n-  for (gnat_temp = (Present (First_Real_Statement (gnat_node))\n-\t\t    ? First_Real_Statement (gnat_node)\n-\t\t    : First (Statements (gnat_node)));\n-       Present (gnat_temp); gnat_temp = Next (gnat_temp))\n+  for (gnat_temp = First (Statements (gnat_node));\n+       Present (gnat_temp);\n+       gnat_temp = Next (gnat_temp))\n     add_stmt (gnat_to_gnu (gnat_temp));\n \n-  gnu_inner_block = end_stmt_group ();\n+  gnu_result = end_stmt_group ();\n \n-  if (gcc_eh)\n+  /* Then process the exception handlers, if any.  */\n+  if (eh)\n     {\n       tree gnu_handlers;\n       location_t locus;\n \n-      /* First make a block containing the handlers.  */\n+      /* First make a group containing the handlers.  */\n       start_stmt_group ();\n       for (gnat_temp = First_Non_Pragma (Exception_Handlers (gnat_node));\n \t   Present (gnat_temp);\n \t   gnat_temp = Next_Non_Pragma (gnat_temp))\n \tadd_stmt (gnat_to_gnu (gnat_temp));\n       gnu_handlers = end_stmt_group ();\n \n-      /* Now make the TRY_CATCH_EXPR for the block.  */\n-      gnu_result = build2 (TRY_CATCH_EXPR, void_type_node,\n-\t\t\t   gnu_inner_block, gnu_handlers);\n+      /* Now make the TRY_CATCH_EXPR for the group.  */\n+      gnu_result\n+\t= build2 (TRY_CATCH_EXPR, void_type_node, gnu_result, gnu_handlers);\n+\n       /* Set a location.  We need to find a unique location for the dispatching\n \t code, otherwise we can get coverage or debugging issues.  Try with\n \t the location of the end label.  */\n@@ -5398,14 +5390,13 @@ Handled_Sequence_Of_Statements_to_gnu (Node_Id gnat_node)\n            coverage analysis tools.  */\n \tset_expr_location_from_node (gnu_result, gnat_node, true);\n     }\n-  else\n-    gnu_result = gnu_inner_block;\n \n-  /* Now close our outer block, if we had to make one.  */\n-  if (binding_for_block)\n+  /* Process the At_End_Proc, if any.  */\n+  if (at_end)\n     {\n+      start_stmt_group ();\n       add_stmt (gnu_result);\n-      gnat_poplevel ();\n+      At_End_Proc_to_gnu (gnat_node);\n       gnu_result = end_stmt_group ();\n     }\n \n@@ -5493,7 +5484,6 @@ Exception_Handler_to_gnu (Node_Id gnat_node)\n     }\n \n   start_stmt_group ();\n-  gnat_pushlevel ();\n \n   /* Expand a call to the begin_handler hook at the beginning of the\n      handler, and arrange for a call to the end_handler hook to occur\n@@ -5584,7 +5574,7 @@ Exception_Handler_to_gnu (Node_Id gnat_node)\n   else\n     {\n       start_stmt_group ();\n-      gnat_pushlevel ();\n+\n       /* CODE: void *EXPRP = __builtin_eh_handler (0); */\n       tree prop_ptr\n \t= create_var_decl (get_identifier (\"EXPRP\"), NULL_TREE,\n@@ -5604,14 +5594,11 @@ Exception_Handler_to_gnu (Node_Id gnat_node)\n       add_stmt_with_node (ecall, gnat_node);\n \n       /* CODE: } */\n-      gnat_poplevel ();\n       tree eblk = end_stmt_group ();\n       tree ehls = build2 (EH_ELSE_EXPR, void_type_node, call, eblk);\n       add_cleanup (ehls, gnat_node);\n     }\n \n-  gnat_poplevel ();\n-\n   gnu_incoming_exc_ptr = prev_gnu_incoming_exc_ptr;\n \n   return\n@@ -5677,7 +5664,7 @@ Compilation_Unit_to_gnu (Node_Id gnat_node)\n        gnat_pragma = Next (gnat_pragma))\n     if (Nkind (gnat_pragma) == N_Pragma)\n       add_stmt (gnat_to_gnu (gnat_pragma));\n-  process_decls (Declarations (Aux_Decls_Node (gnat_node)), Empty, Empty,\n+  process_decls (Declarations (Aux_Decls_Node (gnat_node)), Empty,\n \t\t true, true);\n \n   /* Process the unit itself.  */\n@@ -7365,8 +7352,10 @@ gnat_to_gnu (Node_Id gnat_node)\n \t{\n \t  start_stmt_group ();\n \t  gnat_pushlevel ();\n-\t  process_decls (Declarations (gnat_node), Empty, Empty, true, true);\n+\t  process_decls (Declarations (gnat_node), Empty, true, true);\n \t  add_stmt (gnat_to_gnu (Handled_Statement_Sequence (gnat_node)));\n+\t  if (Present (At_End_Proc (gnat_node)))\n+\t    At_End_Proc_to_gnu (gnat_node);\n \t  gnat_poplevel ();\n \t  gnu_result = end_stmt_group ();\n \t}\n@@ -7606,15 +7595,14 @@ gnat_to_gnu (Node_Id gnat_node)\n       break;\n \n     case N_Package_Specification:\n-\n       start_stmt_group ();\n       process_decls (Visible_Declarations (gnat_node),\n-\t\t     Private_Declarations (gnat_node), Empty, true, true);\n+\t\t     Private_Declarations (gnat_node),\n+\t\t     true, true);\n       gnu_result = end_stmt_group ();\n       break;\n \n     case N_Package_Body:\n-\n       /* If this is the body of a generic package - do nothing.  */\n       if (Ekind (Corresponding_Spec (gnat_node)) == E_Generic_Package)\n \t{\n@@ -7623,11 +7611,11 @@ gnat_to_gnu (Node_Id gnat_node)\n \t}\n \n       start_stmt_group ();\n-      process_decls (Declarations (gnat_node), Empty, Empty, true, true);\n-\n+      process_decls (Declarations (gnat_node), Empty, true, true);\n       if (Present (Handled_Statement_Sequence (gnat_node)))\n \tadd_stmt (gnat_to_gnu (Handled_Statement_Sequence (gnat_node)));\n-\n+      if (Present (At_End_Proc (gnat_node)))\n+\tAt_End_Proc_to_gnu (gnat_node);\n       gnu_result = end_stmt_group ();\n       break;\n \n@@ -7673,7 +7661,7 @@ gnat_to_gnu (Node_Id gnat_node)\n     case N_Task_Body:\n       /* These nodes should only be present when annotating types.  */\n       gcc_assert (type_annotate_only);\n-      process_decls (Declarations (gnat_node), Empty, Empty, true, true);\n+      process_decls (Declarations (gnat_node), Empty, true, true);\n       gnu_result = alloc_stmt_list ();\n       break;\n \n@@ -7975,7 +7963,7 @@ gnat_to_gnu (Node_Id gnat_node)\n     case N_Freeze_Entity:\n       start_stmt_group ();\n       process_freeze_entity (gnat_node);\n-      process_decls (Actions (gnat_node), Empty, Empty, true, true);\n+      process_decls (Actions (gnat_node), Empty, true, true);\n       gnu_result = end_stmt_group ();\n       break;\n \n@@ -9203,17 +9191,13 @@ process_freeze_entity (Node_Id gnat_node)\n    we declare a function if there was no spec).  The second pass\n    elaborates the bodies.\n \n-   GNAT_END_LIST gives the element in the list past the end.  Normally,\n-   this is Empty, but can be First_Real_Statement for a\n-   Handled_Sequence_Of_Statements.\n-\n    We make a complete pass through both lists if PASS1P is true, then make\n    the second pass over both lists if PASS2P is true.  The lists usually\n    correspond to the public and private parts of a package.  */\n \n static void\n process_decls (List_Id gnat_decls, List_Id gnat_decls2,\n-\t       Node_Id gnat_end_list, bool pass1p, bool pass2p)\n+\t       bool pass1p, bool pass2p)\n {\n   List_Id gnat_decl_array[2];\n   Node_Id gnat_decl;\n@@ -9225,7 +9209,8 @@ process_decls (List_Id gnat_decls, List_Id gnat_decls2,\n     for (i = 0; i <= 1; i++)\n       if (Present (gnat_decl_array[i]))\n \tfor (gnat_decl = First (gnat_decl_array[i]);\n-\t     gnat_decl != gnat_end_list; gnat_decl = Next (gnat_decl))\n+\t     Present (gnat_decl);\n+\t     gnat_decl = Next (gnat_decl))\n \t  {\n \t    /* For package specs, we recurse inside the declarations,\n \t       thus taking the two pass approach inside the boundary.  */\n@@ -9234,14 +9219,14 @@ process_decls (List_Id gnat_decls, List_Id gnat_decls2,\n \t\t\t   == N_Package_Specification)))\n \t      process_decls (Visible_Declarations (Specification (gnat_decl)),\n \t\t\t     Private_Declarations (Specification (gnat_decl)),\n-\t\t\t     Empty, true, false);\n+\t\t\t     true, false);\n \n \t    /* Similarly for any declarations in the actions of a\n \t       freeze node.  */\n \t    else if (Nkind (gnat_decl) == N_Freeze_Entity)\n \t      {\n \t\tprocess_freeze_entity (gnat_decl);\n-\t\tprocess_decls (Actions (gnat_decl), Empty, Empty, true, false);\n+\t\tprocess_decls (Actions (gnat_decl), Empty, true, false);\n \t      }\n \n \t    /* Package bodies with freeze nodes get their elaboration deferred\n@@ -9308,7 +9293,8 @@ process_decls (List_Id gnat_decls, List_Id gnat_decls2,\n     for (i = 0; i <= 1; i++)\n       if (Present (gnat_decl_array[i]))\n \tfor (gnat_decl = First (gnat_decl_array[i]);\n-\t     gnat_decl != gnat_end_list; gnat_decl = Next (gnat_decl))\n+\t     Present (gnat_decl);\n+\t     gnat_decl = Next (gnat_decl))\n \t  {\n \t    if (Nkind (gnat_decl) == N_Subprogram_Body\n \t\t|| Nkind (gnat_decl) == N_Subprogram_Body_Stub\n@@ -9321,10 +9307,10 @@ process_decls (List_Id gnat_decls, List_Id gnat_decls2,\n \t\t\t\t== N_Package_Specification)))\n \t      process_decls (Visible_Declarations (Specification (gnat_decl)),\n \t\t\t     Private_Declarations (Specification (gnat_decl)),\n-\t\t\t     Empty, false, true);\n+\t\t\t     false, true);\n \n \t    else if (Nkind (gnat_decl) == N_Freeze_Entity)\n-\t      process_decls (Actions (gnat_decl), Empty, Empty, false, true);\n+\t      process_decls (Actions (gnat_decl), Empty, false, true);\n \n \t    else if (Nkind (gnat_decl) == N_Subprogram_Renaming_Declaration)\n \t      add_stmt (gnat_to_gnu (gnat_decl));"}, {"sha": "ccdaa79f86a0b355240ff507209b47ad702bcc71", "filename": "gcc/ada/gen_il-fields.ads", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d16658d7d0aa0b3d1cede5d7a5853b2d62caf1c/gcc%2Fada%2Fgen_il-fields.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d16658d7d0aa0b3d1cede5d7a5853b2d62caf1c/gcc%2Fada%2Fgen_il-fields.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgen_il-fields.ads?ref=6d16658d7d0aa0b3d1cede5d7a5853b2d62caf1c", "patch": "@@ -183,7 +183,6 @@ package Gen_IL.Fields is\n       First_Inlined_Subprogram,\n       First_Name,\n       First_Named_Actual,\n-      First_Real_Statement,\n       First_Subtype_Link,\n       Float_Truncate,\n       Formal_Type_Definition,"}, {"sha": "f7aadc48f4078eee25cf91795a5f0cfbb15f6fc8", "filename": "gcc/ada/gen_il-gen-gen_nodes.adb", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d16658d7d0aa0b3d1cede5d7a5853b2d62caf1c/gcc%2Fada%2Fgen_il-gen-gen_nodes.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d16658d7d0aa0b3d1cede5d7a5853b2d62caf1c/gcc%2Fada%2Fgen_il-gen-gen_nodes.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgen_il-gen-gen_nodes.adb?ref=6d16658d7d0aa0b3d1cede5d7a5853b2d62caf1c", "patch": "@@ -804,13 +804,15 @@ begin -- Gen_IL.Gen.Gen_Nodes\n    Cc (N_Package_Body, N_Unit_Body,\n        (Sy (Defining_Unit_Name, Node_Id),\n         Sy (Declarations, List_Id, Default_No_List),\n-        Sy (Handled_Statement_Sequence, Node_Id, Default_Empty)));\n+        Sy (Handled_Statement_Sequence, Node_Id, Default_Empty),\n+        Sy (At_End_Proc, Node_Id, Default_Empty)));\n \n    Cc (N_Subprogram_Body, N_Unit_Body,\n        (Sy (Specification, Node_Id),\n         Sy (Declarations, List_Id, Default_No_List),\n         Sy (Handled_Statement_Sequence, Node_Id, Default_Empty),\n         Sy (Bad_Is_Detected, Flag),\n+        Sy (At_End_Proc, Node_Id, Default_Empty),\n         Sm (Activation_Chain_Entity, Node_Id),\n         Sm (Acts_As_Spec, Flag),\n         Sm (Corresponding_Entry_Body, Node_Id),\n@@ -832,6 +834,7 @@ begin -- Gen_IL.Gen.Gen_Nodes\n        (Sy (Defining_Identifier, Node_Id),\n         Sy (Declarations, List_Id, Default_No_List),\n         Sy (Handled_Statement_Sequence, Node_Id, Default_Empty),\n+        Sy (At_End_Proc, Node_Id, Default_Empty),\n         Sm (Activation_Chain_Entity, Node_Id),\n         Sm (Is_Task_Master, Flag)));\n \n@@ -975,6 +978,7 @@ begin -- Gen_IL.Gen.Gen_Nodes\n         Sy (Has_Created_Identifier, Flag),\n         Sy (Is_Asynchronous_Call_Block, Flag),\n         Sy (Is_Task_Allocation_Block, Flag),\n+        Sy (At_End_Proc, Node_Id, Default_Empty),\n         Sm (Activation_Chain_Entity, Node_Id),\n         Sm (Cleanup_Actions, List_Id),\n         Sm (Exception_Junk, Flag),\n@@ -1334,6 +1338,7 @@ begin -- Gen_IL.Gen.Gen_Nodes\n         Sy (Entry_Body_Formal_Part, Node_Id),\n         Sy (Declarations, List_Id, Default_No_List),\n         Sy (Handled_Statement_Sequence, Node_Id, Default_Empty),\n+        Sy (At_End_Proc, Node_Id, Default_Empty),\n         Sm (Activation_Chain_Entity, Node_Id)));\n \n    Cc (N_Entry_Call_Alternative, Node_Kind,\n@@ -1421,8 +1426,7 @@ begin -- Gen_IL.Gen.Gen_Nodes\n        (Sy (Statements, List_Id, Default_Empty_List),\n         Sy (End_Label, Node_Id, Default_Empty),\n         Sy (Exception_Handlers, List_Id, Default_No_List),\n-        Sy (At_End_Proc, Node_Id, Default_Empty),\n-        Sm (First_Real_Statement, Node_Id)));\n+        Sy (At_End_Proc, Node_Id, Default_Empty)));\n \n    Cc (N_Index_Or_Discriminant_Constraint, Node_Kind,\n        (Sy (Constraints, List_Id)));"}, {"sha": "b0eb2948774ad0e308a24cc597065fc8a9cbd2da", "filename": "gcc/ada/inline.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d16658d7d0aa0b3d1cede5d7a5853b2d62caf1c/gcc%2Fada%2Finline.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d16658d7d0aa0b3d1cede5d7a5853b2d62caf1c/gcc%2Fada%2Finline.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finline.adb?ref=6d16658d7d0aa0b3d1cede5d7a5853b2d62caf1c", "patch": "@@ -4536,13 +4536,14 @@ package body Inline is\n       Decl   : Node_Id;\n \n    begin\n-      if No (E_Body) then        --  imported subprogram\n+      if No (E_Body) then -- imported subprogram\n          return False;\n \n       else\n          Decl := First (Declarations (E_Body));\n          while Present (Decl) loop\n             if Nkind (Decl) = N_Full_Type_Declaration\n+              and then Comes_From_Source (Decl)\n               and then Present (Init_Proc (Defining_Identifier (Decl)))\n             then\n                return True;"}, {"sha": "c6866f9a94cea363047557df7d450e3fe039210b", "filename": "gcc/ada/libgnarl/s-tpoben.ads", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d16658d7d0aa0b3d1cede5d7a5853b2d62caf1c/gcc%2Fada%2Flibgnarl%2Fs-tpoben.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d16658d7d0aa0b3d1cede5d7a5853b2d62caf1c/gcc%2Fada%2Flibgnarl%2Fs-tpoben.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnarl%2Fs-tpoben.ads?ref=6d16658d7d0aa0b3d1cede5d7a5853b2d62caf1c", "patch": "@@ -189,14 +189,19 @@ package System.Tasking.Protected_Objects.Entries is\n    --  Lock a protected object for write access. Upon return, the caller owns\n    --  the lock to this object, and no other call to Lock or Lock_Read_Only\n    --  with the same argument will return until the corresponding call to\n-   --  Unlock has been made by the caller. Program_Error is raised in case of\n-   --  ceiling violation.\n+   --  Unlock has been made by the caller. Program_Error is raised in case\n+   --  of ceiling violation, or if the protected object has already been\n+   --  finalized, or if Detect_Blocking is true and the protected object\n+   --  is already locked by the current task. In the Program_Error cases,\n+   --  the object is not locked.\n \n    procedure Lock_Entries_With_Status\n      (Object            : Protection_Entries_Access;\n       Ceiling_Violation : out Boolean);\n    --  Same as above, but return the ceiling violation status instead of\n-   --  raising Program_Error.\n+   --  raising Program_Error. This raises Program_Error in the other\n+   --  cases mentioned for Lock_Entries. In the Program_Error cases,\n+   --  the object is not locked.\n \n    procedure Lock_Read_Only_Entries (Object : Protection_Entries_Access);\n    --  Lock a protected object for read access. Upon return, the caller owns"}, {"sha": "5c7633bbb6b19ef1fc0cb6cf1a05f1287f78f3a8", "filename": "gcc/ada/sem.ads", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d16658d7d0aa0b3d1cede5d7a5853b2d62caf1c/gcc%2Fada%2Fsem.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d16658d7d0aa0b3d1cede5d7a5853b2d62caf1c/gcc%2Fada%2Fsem.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem.ads?ref=6d16658d7d0aa0b3d1cede5d7a5853b2d62caf1c", "patch": "@@ -32,7 +32,7 @@\n \n --    Analysis     implements the bulk of semantic analysis such as\n --                 name analysis and type resolution for declarations,\n---                 instructions and expressions. The main routine\n+--                 statements, and expressions. The main routine\n --                 driving this process is procedure Analyze given below.\n --                 This analysis phase is really a bottom up pass that is\n --                 achieved during the recursive traversal performed by the\n@@ -46,26 +46,25 @@\n --                 completed during analysis (because of overloading\n --                 ambiguities). Specifically, after completing the bottom\n --                 up pass carried out during analysis for expressions, the\n---                 Resolve routine (see the spec of sem_res for more info)\n+--                 Resolve routine (see the spec of Sem_Res for more info)\n --                 is called to perform a top down resolution with\n --                 recursive calls to itself to resolve operands.\n \n---    Expansion    if we are not generating code this phase is a no-op.\n+--    Expansion    If we are not generating code this phase is a no-op.\n --                 Otherwise this phase expands, i.e. transforms, original\n---                 declaration, expressions or instructions into simpler\n---                 structures that can be handled by the back-end. This\n---                 phase is also in charge of generating code which is\n---                 implicit in the original source (for instance for\n---                 default initializations, controlled types, etc.)\n---                 There are two separate instances where expansion is\n+--                 source constructs into simpler constructs that can be\n+--                 handled by the back-end. This phase is also in charge of\n+--                 generating code which is implicit in the original source\n+--                 (for instance for default initializations, controlled types,\n+--                 etc.)  There are two separate instances where expansion is\n --                 invoked. For declarations and instructions, expansion is\n---                 invoked just after analysis since no resolution needs\n---                 to be performed. For expressions, expansion is done just\n---                 after resolution. In both cases expansion is done from the\n---                 bottom up just before the end of Analyze for instructions\n---                 and declarations or the call to Resolve for expressions.\n---                 The main routine driving expansion is Expand.\n---                 See the spec of Expander for more details.\n+--                 invoked just after analysis since no resolution needs to be\n+--                 performed. For expressions, expansion is done just after\n+--                 resolution. In both cases expansion is done from the bottom\n+--                 up just before the end of Analyze for instructions and\n+--                 declarations or the call to Resolve for expressions.  The\n+--                 main routine driving expansion is Expand.  See the spec of\n+--                 Expander for more details.\n \n --  To summarize, in normal code generation mode we recursively traverse the\n --  abstract syntax tree top-down performing semantic analysis bottom\n@@ -110,7 +109,7 @@\n --  pragmas that appear with subprogram specifications rather than in the body.\n \n --  Collectively we call these Spec_Expressions. The routine that performs the\n---  special analysis is called Analyze_Spec_Expression.\n+--  special analysis is called Preanalyze_Spec_Expression.\n \n --  Expansion has to be deferred since you can't generate code for expressions\n --  that reference types that have not been frozen yet. As an example, consider\n@@ -134,7 +133,7 @@\n --  of the expression cannot be obtained at the point of declaration, only at\n --  the point of use.\n \n---  Generally our model is to combine analysis resolution and expansion, but\n+--  Generally our model is to combine analysis, resolution, and expansion, but\n --  this is the one case where this model falls down. Here is how we patch\n --  it up without causing too much distortion to our basic model.\n \n@@ -175,7 +174,7 @@\n --  children is performed before expansion of the parent does not work if the\n --  code generated for the children by the expander needs to be evaluated\n --  repeatedly (for instance in the above aggregate \"new Thing (Function_Call)\"\n---  needs to be called 100 times.)\n+--  needs to be called 100 times).\n \n --  The reason this mechanism does not work is that the expanded code for the\n --  children is typically inserted above the parent and thus when the parent"}, {"sha": "c92e69139bebe38e94761abc8b1672f020bb536f", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d16658d7d0aa0b3d1cede5d7a5853b2d62caf1c/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d16658d7d0aa0b3d1cede5d7a5853b2d62caf1c/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=6d16658d7d0aa0b3d1cede5d7a5853b2d62caf1c", "patch": "@@ -2032,7 +2032,7 @@ package body Sem_Ch6 is\n       end loop;\n \n       --  Determine whether the null procedure may be a completion of a generic\n-      --  suprogram, in which case we use the new null body as the completion\n+      --  subprogram, in which case we use the new null body as the completion\n       --  and set minimal semantic information on the original declaration,\n       --  which is rewritten as a null statement.\n \n@@ -5409,17 +5409,9 @@ package body Sem_Ch6 is\n       --  we have a special test to set X as apparently assigned to suppress\n       --  the warning.\n \n-      --  If X above is controlled, we need to use First_Real_Statement to skip\n-      --  generated finalization-related code. Otherwise (First_Real_Statement\n-      --  is Empty), we just get the first statement.\n-\n       declare\n-         Stm : Node_Id := First_Real_Statement (HSS);\n+         Stm : Node_Id := First (Statements (HSS));\n       begin\n-         if No (Stm) then\n-            Stm := First (Statements (HSS));\n-         end if;\n-\n          --  Skip call markers installed by the ABE mechanism, labels, and\n          --  Push_xxx_Error_Label to find the first real statement.\n "}, {"sha": "eaaf3d711798a274d33bd72857dc54497a29f690", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d16658d7d0aa0b3d1cede5d7a5853b2d62caf1c/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d16658d7d0aa0b3d1cede5d7a5853b2d62caf1c/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=6d16658d7d0aa0b3d1cede5d7a5853b2d62caf1c", "patch": "@@ -9430,8 +9430,8 @@ package body Sem_Prag is\n \n                   --  If the pragma comes from an aspect specification, there\n                   --  must be an Import aspect specified as well. In the rare\n-                  --  case where Import is set to False, the suprogram needs to\n-                  --  have a local completion.\n+                  --  case where Import is set to False, the subprogram needs\n+                  --  to have a local completion.\n \n                   declare\n                      Imp_Aspect : constant Node_Id :=\n@@ -20139,7 +20139,7 @@ package body Sem_Prag is\n                end loop;\n \n                --  If entity in not in current scope it may be the enclosing\n-               --  suprogram body to which the aspect applies.\n+               --  subprogram body to which the aspect applies.\n \n                if not Found then\n                   if Entity (Id) = Current_Scope"}, {"sha": "4a12f080bcaebbd8147ff26fe893292e9b49a7fb", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 3, "deletions": 50, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d16658d7d0aa0b3d1cede5d7a5853b2d62caf1c/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d16658d7d0aa0b3d1cede5d7a5853b2d62caf1c/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=6d16658d7d0aa0b3d1cede5d7a5853b2d62caf1c", "patch": "@@ -22900,6 +22900,7 @@ package body Sem_Util is\n                        | N_Function_Call\n                        | N_Raise_Statement\n                        | N_Raise_xxx_Error\n+                       | N_Raise_Expression\n          then\n             Result := True;\n             return Abandon;\n@@ -24049,13 +24050,6 @@ package body Sem_Util is\n       pragma Inline (Update_CFS_Sloc);\n       --  Update the Comes_From_Source and Sloc attributes of node or entity N\n \n-      procedure Update_First_Real_Statement\n-        (Old_HSS : Node_Id;\n-         New_HSS : Node_Id);\n-      pragma Inline (Update_First_Real_Statement);\n-      --  Update semantic attribute First_Real_Statement of handled sequence of\n-      --  statements New_HSS based on handled sequence of statements Old_HSS.\n-\n       procedure Update_Named_Associations\n         (Old_Call : Node_Id;\n          New_Call : Node_Id);\n@@ -24570,14 +24564,6 @@ package body Sem_Util is\n                Set_Renamed_Object_Of_Possibly_Void\n                  (Defining_Entity (Result), Name (Result));\n \n-            --  Update the First_Real_Statement attribute of a replicated\n-            --  handled sequence of statements.\n-\n-            elsif Nkind (N) = N_Handled_Sequence_Of_Statements then\n-               Update_First_Real_Statement\n-                 (Old_HSS => N,\n-                  New_HSS => Result);\n-\n             --  Update the Chars attribute of identifiers\n \n             elsif Nkind (N) = N_Identifier then\n@@ -24680,39 +24666,6 @@ package body Sem_Util is\n          end if;\n       end Update_CFS_Sloc;\n \n-      ---------------------------------\n-      -- Update_First_Real_Statement --\n-      ---------------------------------\n-\n-      procedure Update_First_Real_Statement\n-        (Old_HSS : Node_Id;\n-         New_HSS : Node_Id)\n-      is\n-         Old_First_Stmt : constant Node_Id := First_Real_Statement (Old_HSS);\n-\n-         New_Stmt : Node_Id;\n-         Old_Stmt : Node_Id;\n-\n-      begin\n-         --  Recreate the First_Real_Statement attribute of a handled sequence\n-         --  of statements by traversing the statement lists of both sequences\n-         --  in parallel.\n-\n-         if Present (Old_First_Stmt) then\n-            New_Stmt := First (Statements (New_HSS));\n-            Old_Stmt := First (Statements (Old_HSS));\n-            while Present (Old_Stmt) and then Old_Stmt /= Old_First_Stmt loop\n-               Next (New_Stmt);\n-               Next (Old_Stmt);\n-            end loop;\n-\n-            pragma Assert (Present (New_Stmt));\n-            pragma Assert (Present (Old_Stmt));\n-\n-            Set_First_Real_Statement (New_HSS, New_Stmt);\n-         end if;\n-      end Update_First_Real_Statement;\n-\n       -------------------------------\n       -- Update_Named_Associations --\n       -------------------------------\n@@ -25424,8 +25377,8 @@ package body Sem_Util is\n       --    * Semantic fields of entities such as Etype and Scope must be\n       --      updated to reference the proper replicated entities.\n \n-      --    * Semantic fields of nodes such as First_Real_Statement must be\n-      --      updated to reference the proper replicated nodes.\n+      --    * Some semantic fields of nodes must be updated to reference\n+      --      the proper replicated nodes.\n \n       --  Finally, quantified expressions contain an implicit declaration for\n       --  the bound variable. Given that quantified expressions appearing"}, {"sha": "001e58f48082f10c66dd02a580625b0edca6f403", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d16658d7d0aa0b3d1cede5d7a5853b2d62caf1c/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d16658d7d0aa0b3d1cede5d7a5853b2d62caf1c/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=6d16658d7d0aa0b3d1cede5d7a5853b2d62caf1c", "patch": "@@ -2743,7 +2743,6 @@ package Sem_Util is\n    --      fields are recreated after the replication takes place.\n    --\n    --        First_Named_Actual\n-   --        First_Real_Statement\n    --        Next_Named_Actual\n    --\n    --      If applicable, the Etype field (if any) is updated to refer to a"}, {"sha": "3f250349a0c1913b12f4bc6805db55de5c0f356e", "filename": "gcc/ada/sinfo-utils.ads", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d16658d7d0aa0b3d1cede5d7a5853b2d62caf1c/gcc%2Fada%2Fsinfo-utils.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d16658d7d0aa0b3d1cede5d7a5853b2d62caf1c/gcc%2Fada%2Fsinfo-utils.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo-utils.ads?ref=6d16658d7d0aa0b3d1cede5d7a5853b2d62caf1c", "patch": "@@ -54,6 +54,12 @@ package Sinfo.Utils is\n    -- Miscellaneous Tree Access Subprograms --\n    -------------------------------------------\n \n+   function First_Real_Statement -- ????\n+     (Ignored : N_Handled_Sequence_Of_Statements_Id) return Node_Id is (Empty);\n+   --  The First_Real_Statement field is going away, but it is referenced in\n+   --  codepeer and gnat-llvm. This is a temporary version, always returning\n+   --  Empty, to ease the transition.\n+\n    function End_Location (N : Node_Id) return Source_Ptr;\n    --  N is an N_If_Statement or N_Case_Statement node, and this function\n    --  returns the location of the IF token in the END IF sequence by"}, {"sha": "28573c3a2234117ff4120eca2b2ff1d2791a95a5", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d16658d7d0aa0b3d1cede5d7a5853b2d62caf1c/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d16658d7d0aa0b3d1cede5d7a5853b2d62caf1c/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=6d16658d7d0aa0b3d1cede5d7a5853b2d62caf1c", "patch": "@@ -891,9 +891,12 @@ package Sinfo is\n    --    required for the corresponding reference or modification.\n \n    --  At_End_Proc\n-   --    This field is present in an N_Handled_Sequence_Of_Statements node.\n+   --    This field is present in N_Handled_Sequence_Of_Statements,\n+   --    N_Package_Body, N_Subprogram_Body, N_Task_Body, N_Block_Statement,\n+   --    and N_Entry_Body.\n    --    It contains an identifier reference for the cleanup procedure to be\n-   --    called. See description of this node for further details.\n+   --    called. See description of N_Handled_Sequence_Of_Statements node\n+   --    for further details.\n \n    --  Backwards_OK\n    --    A flag present in the N_Assignment_Statement node. It is used only\n@@ -1307,15 +1310,6 @@ package Sinfo is\n    --    named associations). Note: this field points to the explicit actual\n    --    parameter itself, not the N_Parameter_Association node (its parent).\n \n-   --  First_Real_Statement\n-   --    Present in N_Handled_Sequence_Of_Statements node. Normally set to\n-   --    Empty. Used only when declarations are moved into the statement part\n-   --    of a construct as a result of wrapping an AT END handler that is\n-   --    required to cover the declarations. In this case, this field is used\n-   --    to remember the location in the statements list of the first real\n-   --    statement, i.e. the statement that used to be first in the statement\n-   --    list before the declarations were prepended.\n-\n    --  First_Subtype_Link\n    --    Present in N_Freeze_Entity node for an anonymous base type that is\n    --    implicitly created by the declaration of a first subtype. It points\n@@ -5167,6 +5161,7 @@ package Sinfo is\n       --  Is_Finalization_Wrapper\n       --  Is_Initialization_Block\n       --  Is_Task_Master\n+      --  At_End_Proc (set to Empty if no clean up procedure)\n \n       -------------------------\n       -- 5.7  Exit Statement --\n@@ -5686,6 +5681,7 @@ package Sinfo is\n       --  Handled_Statement_Sequence (set to Empty if no HSS present)\n       --  Corresponding_Spec\n       --  Was_Originally_Stub\n+      --  At_End_Proc (set to Empty if no clean up procedure)\n \n       --  Note: if a source level package does not contain a handled sequence\n       --  of statements, then the parser supplies a dummy one with a null\n@@ -6164,6 +6160,7 @@ package Sinfo is\n       --  Declarations\n       --  Handled_Statement_Sequence\n       --  Activation_Chain_Entity\n+      --  At_End_Proc (set to Empty if no clean up procedure)\n \n       -----------------------------------\n       -- 9.5.2  Entry Body Formal Part --\n@@ -6715,6 +6712,7 @@ package Sinfo is\n       --  Corresponding_Spec_Of_Stub\n       --  Library_Unit points to the subunit\n       --  Corresponding_Body\n+      --  At_End_Proc (set to Empty if no clean up procedure)\n \n       -------------------------------\n       -- 10.1.3  Package Body Stub --\n@@ -6745,6 +6743,7 @@ package Sinfo is\n       --  Corresponding_Spec_Of_Stub\n       --  Library_Unit points to the subunit\n       --  Corresponding_Body\n+      --  At_End_Proc (set to Empty if no clean up procedure)\n \n       ---------------------------------\n       -- 10.1.3  Protected Body Stub --\n@@ -6830,6 +6829,11 @@ package Sinfo is\n       --  declarations. The big difference is that the cleanup actions occur\n       --  on either a normal or an abnormal exit from the statement sequence.\n \n+      --  At_End_Proc is also a field of various nodes that can contain\n+      --  both Declarations and Handled_Statement_Sequence, such as subprogram\n+      --  bodies and block statements. In that case, the At_End_Proc\n+      --  protects the Declarations as well as the Handled_Statement_Sequence.\n+\n       --  Note: the list of Exception_Handlers can contain pragmas as well\n       --  as actual handlers. In practice these pragmas can only occur at\n       --  the start of the list, since any pragmas occurring later on will\n@@ -6856,7 +6860,6 @@ package Sinfo is\n       --  End_Label (set to Empty if expander generated)\n       --  Exception_Handlers (set to No_List if none present)\n       --  At_End_Proc (set to Empty if no clean up procedure)\n-      --  First_Real_Statement\n \n       --  Note: A Handled_Sequence_Of_Statements can contain both\n       --  Exception_Handlers and an At_End_Proc."}, {"sha": "0f292c870b846a1bccf10680dd180a0964bc35f1", "filename": "gcc/ada/sprint.adb", "status": "modified", "additions": 25, "deletions": 8, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d16658d7d0aa0b3d1cede5d7a5853b2d62caf1c/gcc%2Fada%2Fsprint.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d16658d7d0aa0b3d1cede5d7a5853b2d62caf1c/gcc%2Fada%2Fsprint.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsprint.adb?ref=6d16658d7d0aa0b3d1cede5d7a5853b2d62caf1c", "patch": "@@ -199,6 +199,9 @@ package body Sprint is\n    --  For the case of Semicolon False, no semicolon is removed or output, and\n    --  all the aspects are printed on a single line.\n \n+   procedure Sprint_At_End_Proc (Node : Node_Id);\n+   --  Print At_End_Proc attribute if present\n+\n    procedure Sprint_Bar_List (List : List_Id);\n    --  Print the given list with items separated by vertical bars\n \n@@ -750,6 +753,22 @@ package body Sprint is\n       end if;\n    end Sprint_Aspect_Specifications;\n \n+   ------------------------\n+   -- Sprint_At_End_Proc --\n+   ------------------------\n+\n+   procedure Sprint_At_End_Proc (Node : Node_Id) is\n+   begin\n+      if Present (At_End_Proc (Node)) then\n+         Write_Indent_Str (\"at end\");\n+         Indent_Begin;\n+         Write_Indent;\n+         Sprint_Node (At_End_Proc (Node));\n+         Write_Char (';');\n+         Indent_End;\n+      end if;\n+   end Sprint_At_End_Proc;\n+\n    ---------------------\n    -- Sprint_Bar_List --\n    ---------------------\n@@ -1226,6 +1245,7 @@ package body Sprint is\n             end if;\n \n             Write_Char (';');\n+            Sprint_At_End_Proc (Node);\n \n          when N_Call_Marker =>\n             null;\n@@ -1646,6 +1666,7 @@ package body Sprint is\n             Write_Indent_Str (\"end \");\n             Write_Id (Defining_Identifier (Node));\n             Write_Char (';');\n+            Sprint_At_End_Proc (Node);\n \n          when N_Entry_Body_Formal_Part =>\n             if Present (Entry_Index_Specification (Node)) then\n@@ -2164,14 +2185,7 @@ package body Sprint is\n                Indent_End;\n             end if;\n \n-            if Present (At_End_Proc (Node)) then\n-               Write_Indent_Str (\"at end\");\n-               Indent_Begin;\n-               Write_Indent;\n-               Sprint_Node (At_End_Proc (Node));\n-               Write_Char (';');\n-               Indent_End;\n-            end if;\n+            Sprint_At_End_Proc (Node);\n \n          when N_Identifier =>\n             Set_Debug_Sloc;\n@@ -2699,6 +2713,7 @@ package body Sprint is\n             Sprint_End_Label\n               (Handled_Statement_Sequence (Node), Defining_Unit_Name (Node));\n             Write_Char (';');\n+            Sprint_At_End_Proc (Node);\n \n          when N_Package_Body_Stub =>\n             Write_Indent_Str_Sloc (\"package body \");\n@@ -3326,6 +3341,7 @@ package body Sprint is\n               (Handled_Statement_Sequence (Node),\n                  Defining_Unit_Name (Specification (Node)));\n             Write_Char (';');\n+            Sprint_At_End_Proc (Node);\n \n             if Is_List_Member (Node)\n               and then Present (Next (Node))\n@@ -3398,6 +3414,7 @@ package body Sprint is\n             Sprint_End_Label\n               (Handled_Statement_Sequence (Node), Defining_Identifier (Node));\n             Write_Char (';');\n+            Sprint_At_End_Proc (Node);\n \n          when N_Task_Body_Stub =>\n             Write_Indent_Str_Sloc (\"task body \");"}]}