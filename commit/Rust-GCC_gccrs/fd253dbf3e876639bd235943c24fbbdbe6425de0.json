{"sha": "fd253dbf3e876639bd235943c24fbbdbe6425de0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmQyNTNkYmYzZTg3NjYzOWJkMjM1OTQzYzI0ZmJiZGJlNjQyNWRlMA==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2019-01-12T18:34:30Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2019-01-12T18:34:30Z"}, "message": "ISO_Fortran_binding_2.f90: Remove because of reports of ICEs.\n\n2019-01-12  Paul Thomas  <pault@gcc.gnu.org>\n\n\t* gfortran.dg/ISO_Fortran_binding_2.f90 : Remove because of\n\treports of ICEs.\n\t* gfortran.dg/ISO_Fortran_binding_2.c : Ditto.\n\nFrom-SVN: r267884", "tree": {"sha": "6b4a8cd34578c7162aa451a19cee04b21d8fd8ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6b4a8cd34578c7162aa451a19cee04b21d8fd8ef"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fd253dbf3e876639bd235943c24fbbdbe6425de0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd253dbf3e876639bd235943c24fbbdbe6425de0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd253dbf3e876639bd235943c24fbbdbe6425de0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd253dbf3e876639bd235943c24fbbdbe6425de0/comments", "author": null, "committer": null, "parents": [{"sha": "43d168a46e288660b16fb6a7c66a8e77752345aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43d168a46e288660b16fb6a7c66a8e77752345aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/43d168a46e288660b16fb6a7c66a8e77752345aa"}], "stats": {"total": 325, "additions": 16, "deletions": 309}, "files": [{"sha": "3d74b63c85b762bae37f55416ec5557cc4719cb5", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd253dbf3e876639bd235943c24fbbdbe6425de0/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd253dbf3e876639bd235943c24fbbdbe6425de0/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=fd253dbf3e876639bd235943c24fbbdbe6425de0", "patch": "@@ -1,3 +1,18 @@\n+2019-01-12  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\t* gfortran.dg/ISO_Fortran_binding_2.f90 : Remove because of\n+\treports of ICEs.\n+\t* gfortran.dg/ISO_Fortran_binding_2.c : Ditto.\n+\n+2019-01-12  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\t* gfortran.dg/ISO_Fortran_binding_1.f90 : New test.\n+\t* gfortran.dg/ISO_Fortran_binding_1.c : Auxilliary file for test.\n+\t* gfortran.dg/ISO_Fortran_binding_2.f90 : New test.\n+\t* gfortran.dg/ISO_Fortran_binding_2.c : Auxilliary file for test.\n+\t* gfortran.dg/bind_c_array_params_2.f90 : Change search string\n+\tfor dump tree scan.\n+\n 2019-01-11  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \tPR fortran/35031\n@@ -19,7 +34,7 @@\n 2019-01-11  Tobias Burnus  <burnus@net-b.de>\n \n \tPR C++/88114\n-\t* g++.dg/cpp0x/defaulted61.C: New\t\n+\t* g++.dg/cpp0x/defaulted61.C: New\n \t* g++.dg/cpp0x/defaulted62.C: New.\n \n 2019-01-11  Jakub Jelinek  <jakub@redhat.com>"}, {"sha": "1c1af2070b3f9d76b65ac5940ad9ec5b6ee86e6b", "filename": "gcc/testsuite/gfortran.dg/ISO_Fortran_binding_2.c", "status": "removed", "additions": 0, "deletions": 115, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43d168a46e288660b16fb6a7c66a8e77752345aa/gcc%2Ftestsuite%2Fgfortran.dg%2FISO_Fortran_binding_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43d168a46e288660b16fb6a7c66a8e77752345aa/gcc%2Ftestsuite%2Fgfortran.dg%2FISO_Fortran_binding_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2FISO_Fortran_binding_2.c?ref=43d168a46e288660b16fb6a7c66a8e77752345aa", "patch": "@@ -1,115 +0,0 @@\n-/* Test F2018 18.5: ISO_Fortran_binding.h functions.  */\n-\n-#include <ISO_Fortran_binding.h>\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <complex.h>\n-\n-/* Test the example in F2018 C.12.9: Processing assumed-shape arrays in C,\n-   modified to use CFI_address instead of pointer arithmetic.  */\n-\n-int address_c(CFI_cdesc_t * a_desc, const int idx[])\n-{\n-  int *res_addr;\n-  CFI_index_t CFI_idx[1];\n-\n-  CFI_idx[0] = (CFI_index_t)idx[0];\n-\n-  res_addr = CFI_address (a_desc, CFI_idx);\n-  if (res_addr == NULL)\n-    return -1;\n-  return *res_addr;\n-}\n-\n-\n-int deallocate_c(CFI_cdesc_t * dd)\n-{\n-  return CFI_deallocate(dd);\n-}\n-\n-\n-int allocate_c(CFI_cdesc_t * da, CFI_index_t lower[], CFI_index_t upper[])\n-{\n-  return CFI_allocate(da, lower, upper, 0);\n-}\n-\n-int establish_c(CFI_cdesc_t * desc, int *rank, int *attr)\n-{\n-  typedef struct {double x; double _Complex y;} t;\n-  int err;\n-  CFI_index_t idx[1], extent[1];\n-  void *ptr;\n-\n-  extent[0] = 1;\n-  ptr = malloc ((size_t)(extent[0] * sizeof(t)));\n-  err = CFI_establish((CFI_cdesc_t *)desc,\n-\t\t      ptr,\n-\t\t      (CFI_attribute_t)*attr,\n-\t\t      CFI_type_struct,\n-\t\t      sizeof(t), (CFI_rank_t)*rank, extent);\n-  free (ptr);\n-  return err;\n-}\n-\n-int contiguous_c(CFI_cdesc_t * desc)\n-{\n-  return CFI_is_contiguous(desc);\n-}\n-\n-float section_c(int *std_case, CFI_cdesc_t * source, int *low, int *str)\n-{\n-  CFI_index_t idx[CFI_MAX_RANK], lower[CFI_MAX_RANK],\n-\t\t  strides[CFI_MAX_RANK], upper[CFI_MAX_RANK];\n-  CFI_CDESC_T(1) section;\n-  int ind, size;\n-  float *ret_addr;\n-  float ans = 0.0;\n-\n-  if (*std_case == 1)\n-    {\n-      lower[0] = (CFI_index_t)low[0];\n-      strides[0] = (CFI_index_t)str[0];\n-      ind = CFI_establish((CFI_cdesc_t *)&section, NULL, CFI_attribute_other,\n-\t\t\t  CFI_type_float, 0, 1, NULL);\n-      if (ind) return -1.0;\n-      ind = CFI_section((CFI_cdesc_t *)&section, source, lower, NULL, strides);\n-      if (ind) return (float)ind;\n-    }\n-\n-  return 0.0;\n-}\n-\n-\n-int select_part_c (CFI_cdesc_t * source)\n-{\n-  typedef struct\n-  {\n-    double x;\n-    double _Complex y;\n-  } t;\n-  CFI_CDESC_T(2) component;\n-  CFI_cdesc_t * comp_cdesc = (CFI_cdesc_t *)&component;\n-  CFI_index_t extent[] = {10,10};\n-  CFI_index_t idx[] = {4,0};\n-  int res;\n-\n-  res = CFI_establish(comp_cdesc, NULL, CFI_attribute_other,\n-\t\t      CFI_type_double_Complex, sizeof(double _Complex),\n-\t\t      2, extent);\n-  if (res)\n-    return res;\n-\n-  res = CFI_select_part(comp_cdesc, source, offsetof(t,y), 0);\n-\n-  return res;\n-}\n-\n-\n-int setpointer_c(CFI_cdesc_t * ptr1, CFI_cdesc_t * ptr2, int lbounds[])\n-{\n-  CFI_index_t lower_bounds[] = {lbounds[0],lbounds[1]};\n-  int ind;\n-\n-  ind = CFI_setpointer(ptr1, ptr2, lower_bounds);\n-  return ind;\n-}"}, {"sha": "2670045e1faae66c7f3d525970135ff594b16a4e", "filename": "gcc/testsuite/gfortran.dg/ISO_Fortran_binding_2.f90", "status": "removed", "additions": 0, "deletions": 193, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43d168a46e288660b16fb6a7c66a8e77752345aa/gcc%2Ftestsuite%2Fgfortran.dg%2FISO_Fortran_binding_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43d168a46e288660b16fb6a7c66a8e77752345aa/gcc%2Ftestsuite%2Fgfortran.dg%2FISO_Fortran_binding_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2FISO_Fortran_binding_2.f90?ref=43d168a46e288660b16fb6a7c66a8e77752345aa", "patch": "@@ -1,193 +0,0 @@\n-! { dg-do run }\n-! { dg-additional-sources ISO_Fortran_binding_2.c }\n-! { dg-options \"-fbounds-check\" }\n-!\n-! Test F2018 18.5: ISO_Fortran_binding.h function errors.\n-!\n-  USE, INTRINSIC :: ISO_C_BINDING\n-\n-  TYPE, BIND(C) :: T\n-    REAL(C_DOUBLE) :: X\n-    complex(C_DOUBLE_COMPLEX) :: Y\n-  END TYPE\n-\n-  type :: mytype\n-    integer :: i\n-    integer :: j\n-  end type\n-\n-  INTERFACE\n-    FUNCTION c_address(a, idx) BIND(C, NAME=\"address_c\") RESULT(err)\n-      USE, INTRINSIC :: ISO_C_BINDING\n-      INTEGER(C_INT) :: err\n-      INTEGER(C_INT), dimension(1) :: idx\n-      type(*), DIMENSION(..) :: a\n-    END FUNCTION c_address\n-\n-    FUNCTION c_deallocate(a) BIND(C, NAME=\"deallocate_c\") RESULT(err)\n-      USE, INTRINSIC :: ISO_C_BINDING\n-      INTEGER(C_INT) :: err\n-      type(*), DIMENSION(..) :: a\n-    END FUNCTION c_deallocate\n-\n-    FUNCTION c_allocate(a, lower, upper) BIND(C, NAME=\"allocate_c\") RESULT(err)\n-      USE, INTRINSIC :: ISO_C_BINDING\n-      INTEGER(C_INT) :: err\n-      type(*), DIMENSION(..) :: a\n-      integer(C_INTPTR_T), DIMENSION(15) :: lower, upper\n-    END FUNCTION c_allocate\n-\n-    FUNCTION c_establish(a, rank, attr) BIND(C, NAME=\"establish_c\") RESULT(err)\n-      USE, INTRINSIC :: ISO_C_BINDING\n-      import\n-      INTEGER(C_INT) :: err\n-      INTEGER(C_INT) :: rank, attr\n-      type (T), DIMENSION(..), intent(out) :: a\n-    END FUNCTION c_establish\n-\n-    FUNCTION c_contiguous(a) BIND(C, NAME=\"contiguous_c\") RESULT(err)\n-      USE, INTRINSIC :: ISO_C_BINDING\n-      INTEGER(C_INT) :: err\n-      type(*), DIMENSION(..) :: a\n-    END FUNCTION c_contiguous\n-\n-    FUNCTION c_section(std_case, a, lower, strides) BIND(C, NAME=\"section_c\") RESULT(ans)\n-      USE, INTRINSIC :: ISO_C_BINDING\n-      real(C_FLOAT) :: ans\n-      INTEGER(C_INT) :: std_case\n-      INTEGER(C_INT), dimension(15) :: lower\n-      INTEGER(C_INT), dimension(15) :: strides\n-      type(*), DIMENSION(..) :: a\n-    END FUNCTION c_section\n-\n-    FUNCTION c_select_part(a) BIND(C, NAME=\"select_part_c\") RESULT(ans)\n-      USE, INTRINSIC :: ISO_C_BINDING\n-      INTEGER(C_INT) :: ans\n-      type(*), DIMENSION(..) :: a\n-    END FUNCTION c_select_part\n-\n-    FUNCTION c_setpointer(a, b, lbounds) BIND(C, NAME=\"setpointer_c\") RESULT(err)\n-      USE, INTRINSIC :: ISO_C_BINDING\n-      INTEGER(C_INT) :: err\n-      INTEGER(C_INT), dimension(2) :: lbounds\n-      type(*), DIMENSION(..) :: a, b\n-    END FUNCTION c_setpointer\n-  END INTERFACE\n-\n-  integer(C_INTPTR_T), dimension(15) :: lower, upper\n-\n-  call test_CFI_address\n-  call test_CFI_deallocate\n-  call test_CFI_allocate\n-  call test_CFI_establish\n-  call test_CFI_contiguous\n-  call test_CFI_section\n-  call test_CFI_select_part\n-  call test_CFI_setpointer\n-\n-contains\n-  subroutine test_CFI_address\n-    integer, dimension(:), allocatable :: a\n-    allocate (a, source = [1,2,3])\n-    if (c_address (a, [2]) .ne. 3) stop 1   ! OK\n-    if (c_address (a, [3]) .ne. -1) stop 2  ! \"subscripts[0], is out of bounds\"\n-    if (c_address (a, [-1]) .ne. -1) stop 3 ! \"subscripts[0], is out of bounds\"\n-    deallocate (a)\n-    if (c_address (a, [2]) .ne. -1) stop 4  ! \"C Descriptor must not be NULL\"\n-  end subroutine test_CFI_address\n-\n-  subroutine test_CFI_deallocate\n-    integer, dimension(:), allocatable :: a\n-    integer, dimension(2,2) :: b\n-    if (c_deallocate (a) .ne. 2) stop 5     ! \"Base address is already NULL\"\n-    allocate (a(2))\n-    if (c_deallocate (a) .ne. 0) stop 6     ! OK\n-    if (c_deallocate (b) .ne. 7) stop 7     ! \"must describe a pointer or allocatable\"\n-  end subroutine test_CFI_deallocate\n-\n-  subroutine test_CFI_allocate\n-    integer, dimension(:,:), allocatable :: a\n-    integer, dimension(2,2) :: b\n-    lower(1:2) = [2,2]\n-    upper(1:2) = [10,10]\n-    allocate (a(1,1))\n-    if (c_allocate (a, lower, upper) .ne. 3) stop 8  ! \"C descriptor must be NULL\"\n-    if (allocated (a)) deallocate (a)\n-    if (c_allocate (a, lower, upper) .ne. 0) stop 9  ! OK\n-    if (c_allocate (b, lower, upper) .ne. 7) STOP 10 ! \"must describe a pointer or allocatable\"\n-  end subroutine test_CFI_allocate\n-\n-  subroutine test_CFI_establish\n-    type(T), allocatable :: a(:)\n-    INTEGER(C_INT) :: rank\n-    INTEGER(C_INT) :: attr\n-    attr = 0                                         ! establish a pointer\n-    rank = 16\n-    if (c_establish (a, rank, attr) .ne. 5) stop 11  ! \"Rank must be between 0 and 15\"\n-    rank = 1\n-    if (c_establish (a, rank, attr) .ne. 0) stop 12  ! OK\n-    if (allocated (a)) deallocate (a)\n-    if (c_establish (a, rank, attr) .ne. 0) Stop 13  ! OK the first time\n-    if (c_establish (a, rank, attr) .ne. 10) Stop 14 ! \"its base address must be NULL\"\n-    if (allocated (a)) deallocate (a)\n-    attr = 1                                         ! establish an allocatable\n-    if (c_establish (a, rank, attr) .ne. 7) Stop 15  ! \"is for a nonallocatable entity\"\n-  end subroutine test_CFI_establish\n-\n-  subroutine test_CFI_contiguous\n-    integer, allocatable :: a\n-    if (c_contiguous (a) .ne. 2) stop 16  ! \"Descriptor is already NULL\"\n-    allocate (a)\n-    if (c_contiguous (a) .ne. 5) stop 17  ! \"must describe an array\"\n-  end subroutine test_CFI_contiguous\n-\n-  subroutine test_CFI_section\n-    real, allocatable, dimension (:) :: a\n-    integer, dimension(15) :: lower, strides\n-    integer :: i\n-    real :: b\n-    lower(1) = 10\n-    strides(1) = 5\n-    if (int (c_section (1, a, lower, strides)) .ne. 2) &\n-        stop 18 ! \"Base address of source must not be NULL\"\n-    allocate (a(100))\n-    if (int (c_section (1, a, lower, strides)) .ne. 0) &\n-        stop 19 ! OK\n-    if (int (c_section (1, b, lower, strides)) .ne. 5) &\n-        stop 20 ! \"Source must describe an array\"\n-    strides(1) = 0\n-    if (int (c_section (1, a, lower, strides)) .ne. 5) &\n-        stop 21 ! \"Rank of result must be equal to the rank of source\"\n-    strides(1) = 5\n-    lower(1) = -1\n-    if (int (c_section (1, a, lower, strides)) .ne. 12) &\n-        stop 22 ! \"Lower bounds must be within the bounds of the fortran array\"\n-    lower(1) = 100\n-    if (int (c_section (1, a, lower, strides)) .ne. 12) &\n-        stop 23 ! \"Lower bounds must be within the bounds of the fortran array\"\n-  end subroutine test_CFI_section\n-\n-  subroutine test_CFI_select_part\n-    type(t), allocatable, dimension(:) :: a\n-    type(t) :: src\n-    allocate (a(1), source = src)\n-    if (c_select_part (a) .ne. 5) stop 24 ! \"Source and result must have the same rank\"\n-    deallocate (a)\n-    if (c_select_part (a) .ne. 2) stop 25 ! \"source must not be NULL\"\n-  end subroutine test_CFI_select_part\n-\n-  subroutine test_CFI_setpointer\n-    integer, dimension(2,2), target :: tgt1\n-    integer, dimension(:,:), pointer :: src\n-    type (t), dimension(2), target :: tgt2\n-    type (t), dimension(:), pointer :: res\n-    type (t), dimension(2, 2), target, save :: tgt3\n-    type (t), dimension(:, :), pointer :: src1\n-    integer, dimension(2) :: lbounds = [-1, -2]\n-    src => tgt1\n-    res => tgt2\n-    if (c_setpointer (res, src, lbounds) .ne. 4) stop 26 ! \"Element lengths\"\n-    src1 => tgt3\n-    if (c_setpointer (res, src1, lbounds) .ne. 5) stop 27 ! \"Ranks of result\"\n-  end subroutine test_CFI_setpointer\n-end"}]}