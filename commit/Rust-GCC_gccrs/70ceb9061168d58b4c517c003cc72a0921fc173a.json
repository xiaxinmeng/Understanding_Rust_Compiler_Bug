{"sha": "70ceb9061168d58b4c517c003cc72a0921fc173a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzBjZWI5MDYxMTY4ZDU4YjRjNTE3YzAwM2NjNzJhMDkyMWZjMTczYQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-03-06T22:18:11Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-03-06T22:18:11Z"}, "message": "Add prototypes for static functions.\n\n(last_{jump,label}_suid): Deleted; all uses deleted.\n(reg_crosses_blocks): Likewise.\n(stupid_life_analysis): Only allocate MAX_SUID entries of after_insn_hard_regs.\nUse GET_RTX_CLASS when possible.\nInitialize all of reg_renumber.\nUse reg_alternate_class when reg not available in preferred class.\n(stupid_find_reg): Delete argument CROSSES_BLOCKS.\n\nFrom-SVN: r6706", "tree": {"sha": "d4d7833540e5a66b401bc544a2163b5a41d613c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d4d7833540e5a66b401bc544a2163b5a41d613c9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/70ceb9061168d58b4c517c003cc72a0921fc173a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70ceb9061168d58b4c517c003cc72a0921fc173a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/70ceb9061168d58b4c517c003cc72a0921fc173a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70ceb9061168d58b4c517c003cc72a0921fc173a/comments", "author": null, "committer": null, "parents": [{"sha": "63cc239cc6f13c189205760de8768dd3689bfa60", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63cc239cc6f13c189205760de8768dd3689bfa60", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63cc239cc6f13c189205760de8768dd3689bfa60"}], "stats": {"total": 122, "additions": 40, "deletions": 82}, "files": [{"sha": "b4b15fb3d23c63cd9e6e3604096d786e8a7e6ceb", "filename": "gcc/stupid.c", "status": "modified", "additions": 40, "deletions": 82, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70ceb9061168d58b4c517c003cc72a0921fc173a/gcc%2Fstupid.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70ceb9061168d58b4c517c003cc72a0921fc173a/gcc%2Fstupid.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstupid.c?ref=70ceb9061168d58b4c517c003cc72a0921fc173a", "patch": "@@ -64,16 +64,6 @@ static int *uid_suid;\n \n static int last_call_suid;\n \n-/* Record the suid of the last JUMP_INSN\n-   so we can tell whether a pseudo reg crosses any jumps.  */\n-\n-static int last_jump_suid;\n-\n-/* Record the suid of the last CODE_LABEL\n-   so we can tell whether a pseudo reg crosses any labels.  */\n-\n-static int last_label_suid;\n-\n /* Element N is suid of insn where life span of pseudo reg N ends.\n    Element is  0 if register N has not been seen yet on backward scan.  */\n \n@@ -83,10 +73,6 @@ static int *reg_where_dead;\n \n static int *reg_where_born;\n \n-/* Element N is 1 if pseudo reg N lives across labels or jumps.  */\n-\n-static char *reg_crosses_blocks;\n-\n /* Numbers of pseudo-regs to be allocated, highest priority first.  */\n \n static int *reg_order;\n@@ -105,9 +91,10 @@ static HARD_REG_SET *after_insn_hard_regs;\n #define MARK_LIVE_AFTER(INSN,REGNO)  \\\n   SET_HARD_REG_BIT (after_insn_hard_regs[INSN_SUID (INSN)], (REGNO))\n \n-static void stupid_mark_refs ();\n-static int stupid_reg_compare ();\n-static int stupid_find_reg ();\n+static int stupid_reg_compare\tPROTO((int *, int *));\n+static int stupid_find_reg\tPROTO((int, enum reg_class, enum machine_mode,\n+\t\t\t\t       int, int));\n+static void stupid_mark_refs\tPROTO((rtx, rtx));\n \f\n /* Stupid life analysis is for the case where only variables declared\n    `register' go in registers.  For this case, we mark all\n@@ -125,7 +112,7 @@ stupid_life_analysis (f, nregs, file)\n {\n   register int i;\n   register rtx last, insn;\n-  int max_uid;\n+  int max_uid, max_suid;\n \n   bzero (regs_ever_live, sizeof regs_ever_live);\n \n@@ -148,15 +135,14 @@ stupid_life_analysis (f, nregs, file)\n   last = 0;\t\t\t/* In case of empty function body */\n   for (insn = f, i = 0; insn; insn = NEXT_INSN (insn))\n     {\n-      if (GET_CODE (insn) == INSN || GET_CODE (insn) == CALL_INSN\n-\t  || GET_CODE (insn) == JUMP_INSN)\n+      if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n \tlast = insn;\n+\n       INSN_SUID (insn) = ++i;\n     }\n \n   last_call_suid = i + 1;\n-  last_jump_suid = i + 1;\n-  last_label_suid = i + 1;\n+  max_suid = i + 1;\n \n   max_regno = nregs;\n \n@@ -168,31 +154,28 @@ stupid_life_analysis (f, nregs, file)\n   reg_where_born = (int *) alloca (nregs * sizeof (int));\n   bzero (reg_where_born, nregs * sizeof (int));\n \n-  reg_crosses_blocks = (char *) alloca (nregs);\n-  bzero (reg_crosses_blocks, nregs);\n-\n   reg_order = (int *) alloca (nregs * sizeof (int));\n   bzero (reg_order, nregs * sizeof (int));\n \n   reg_renumber = (short *) oballoc (nregs * sizeof (short));\n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     reg_renumber[i] = i;\n \n-  for (i = FIRST_VIRTUAL_REGISTER; i <= LAST_VIRTUAL_REGISTER; i++)\n+  for (i = FIRST_VIRTUAL_REGISTER; i < max_regno; i++)\n     reg_renumber[i] = -1;\n \n-  after_insn_hard_regs = (HARD_REG_SET *) alloca (max_uid * sizeof (HARD_REG_SET));\n-  bzero (after_insn_hard_regs, max_uid * sizeof (HARD_REG_SET));\n+  after_insn_hard_regs\n+    = (HARD_REG_SET *) alloca (max_suid * sizeof (HARD_REG_SET));\n+\n+  bzero (after_insn_hard_regs, max_suid * sizeof (HARD_REG_SET));\n \n   /* Allocate and zero out many data structures\n      that will record the data from lifetime analysis.  */\n \n   allocate_for_life_analysis ();\n \n   for (i = 0; i < max_regno; i++)\n-    {\n-      reg_n_deaths[i] = 1;\n-    }\n+    reg_n_deaths[i] = 1;\n \n   bzero (regs_live, nregs);\n \n@@ -209,8 +192,7 @@ stupid_life_analysis (f, nregs, file)\n     {\n       register HARD_REG_SET *p = after_insn_hard_regs + INSN_SUID (insn);\n \n-      /* Copy the info in regs_live\n-\t into the element of after_insn_hard_regs\n+      /* Copy the info in regs_live into the element of after_insn_hard_regs\n \t for the current position in the rtl code.  */\n \n       for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n@@ -228,27 +210,18 @@ stupid_life_analysis (f, nregs, file)\n \t  last_call_suid = INSN_SUID (insn);\n \t  IOR_HARD_REG_SET (after_insn_hard_regs[last_call_suid],\n \t\t\t    call_used_reg_set);\n+\n \t  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n \t    if (call_used_regs[i])\n \t      regs_live[i] = 0;\n \t}\n \n-      if (GET_CODE (insn) == JUMP_INSN)\n-\tlast_jump_suid = INSN_SUID (insn);\n-\n-      if (GET_CODE (insn) == CODE_LABEL)\n-\tlast_label_suid = INSN_SUID (insn);\n-\n       /* Update which hard regs are currently live\n \t and also the birth and death suids of pseudo regs\n \t based on the pattern of this insn.  */\n \n-      if (GET_CODE (insn) == INSN\n-\t  || GET_CODE (insn) == CALL_INSN\n-\t  || GET_CODE (insn) == JUMP_INSN)\n-\t{\n-\t  stupid_mark_refs (PATTERN (insn), insn);\n-\t}\n+      if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n+\tstupid_mark_refs (PATTERN (insn), insn);\n     }\n \n   /* Now decide the order in which to allocate the pseudo registers.  */\n@@ -265,35 +238,26 @@ stupid_life_analysis (f, nregs, file)\n   for (i = LAST_VIRTUAL_REGISTER + 1; i < max_regno; i++)\n     {\n       register int r = reg_order[i];\n-      enum reg_class class;\n \n       /* Some regnos disappear from the rtl.  Ignore them to avoid crash.  */\n       if (regno_reg_rtx[r] == 0)\n \tcontinue;\n \n       /* Now find the best hard-register class for this pseudo register */\n       if (N_REG_CLASSES > 1)\n-\t{\n-\t  class = reg_preferred_class (r);\n-\n-\t  reg_renumber[r] = stupid_find_reg (reg_n_calls_crossed[r], class,\n-\t\t\t\t\t     PSEUDO_REGNO_MODE (r),\n-\t\t\t\t\t     reg_where_born[r],\n-\t\t\t\t\t     reg_where_dead[r],\n-\t\t\t\t\t     reg_crosses_blocks[r]);\n-\t}\n-      else\n-\treg_renumber[r] = -1;\n+\treg_renumber[r] = stupid_find_reg (reg_n_calls_crossed[r], \n+\t\t\t\t\t   reg_preferred_class (r),\n+\t\t\t\t\t   PSEUDO_REGNO_MODE (r),\n+\t\t\t\t\t   reg_where_born[r],\n+\t\t\t\t\t   reg_where_dead[r]);\n \n-      /* If no reg available in that class,\n-\t try any reg.  */\n-      if (reg_renumber[r] == -1)\n+      /* If no reg available in that class, try alternate class.  */\n+      if (reg_renumber[r] == -1 && reg_alternate_class (r) != NO_REGS)\n \treg_renumber[r] = stupid_find_reg (reg_n_calls_crossed[r],\n-\t\t\t\t\t   GENERAL_REGS,\n+\t\t\t\t\t   reg_alternate_class (r),\n \t\t\t\t\t   PSEUDO_REGNO_MODE (r),\n \t\t\t\t\t   reg_where_born[r],\n-\t\t\t\t\t   reg_where_dead[r],\n-\t\t\t\t\t   reg_crosses_blocks[r]);\n+\t\t\t\t\t   reg_where_dead[r]);\n     }\n \n   if (file)\n@@ -313,10 +277,12 @@ stupid_reg_compare (r1p, r2p)\n   int tem;\n \n   tem = len2 - len1;\n-  if (tem != 0) return tem;\n+  if (tem != 0)\n+    return tem;\n \n   tem = reg_n_refs[r1] - reg_n_refs[r2];\n-  if (tem != 0) return tem;\n+  if (tem != 0)\n+    return tem;\n \n   /* If regs are equally good, sort by regno,\n      so that the results of qsort leave nothing to chance.  */\n@@ -332,18 +298,14 @@ stupid_reg_compare (r1p, r2p)\n    Return -1 if such a block cannot be found.\n \n    If CALL_PRESERVED is nonzero, insist on registers preserved\n-   over subroutine calls, and return -1 if cannot find such.\n-   If CROSSES_BLOCKS is nonzero, reject registers for which\n-   PRESERVE_DEATH_INFO_REGNO_P is true.  */\n+   over subroutine calls, and return -1 if cannot find such.  */\n \n static int\n-stupid_find_reg (call_preserved, class, mode,\n-\t\t born_insn, dead_insn, crosses_blocks)\n+stupid_find_reg (call_preserved, class, mode, born_insn, dead_insn)\n      int call_preserved;\n      enum reg_class class;\n      enum machine_mode mode;\n      int born_insn, dead_insn;\n-     int crosses_blocks;\n {\n   register int i, ins;\n #ifdef HARD_REG_SET\n@@ -380,13 +342,6 @@ stupid_find_reg (call_preserved, class, mode,\n       int regno = i;\n #endif\n \n-      /* If we need reasonable death info on this hard reg,\n-\t don't use it for anything whose life spans a label or a jump.  */\n-#ifdef PRESERVE_DEATH_INFO_REGNO_P\n-      if (PRESERVE_DEATH_INFO_REGNO_P (regno)\n-\t  && crosses_blocks)\n-\tcontinue;\n-#endif\n       /* If a register has screwy overlap problems,\n \t don't use it at all if not optimizing.\n \t Actually this is only for the 387 stack register,\n@@ -414,10 +369,11 @@ stupid_find_reg (call_preserved, class, mode,\n \t      return regno;\n \t    }\n #ifndef REG_ALLOC_ORDER\n-\t  i += j;\t\t\t/* Skip starting points we know will lose */\n+\t  i += j;\t\t/* Skip starting points we know will lose */\n #endif\n \t}\n     }\n+\n   return -1;\n }\n \f\n@@ -445,13 +401,16 @@ stupid_mark_refs (x, insn)\n \t    {\n \t      register int j\n \t\t= HARD_REGNO_NREGS (regno, GET_MODE (SET_DEST (x)));\n+\n \t      while (--j >= 0)\n \t\t{\n \t\t  regs_ever_live[regno+j] = 1;\n \t\t  regs_live[regno+j] = 0;\n+\n \t\t  /* The following line is for unused outputs;\n \t\t     they do get stored even though never used again.  */\n \t\t  MARK_LIVE_AFTER (insn, regno);\n+\n \t\t  /* When a hard reg is clobbered, mark it in use\n \t\t     just before this insn, so it is live all through.  */\n \t\t  if (code == CLOBBER && INSN_SUID (insn) > 0)\n@@ -470,6 +429,7 @@ stupid_mark_refs (x, insn)\n \t      int where_born = INSN_SUID (insn) - (code == CLOBBER);\n \n \t      reg_where_born[regno] = where_born;\n+\n \t      /* The reg must live at least one insn even\n \t\t in it is never again used--because it has to go\n \t\t in SOME hard reg.  Mark it as dying after the current\n@@ -486,11 +446,9 @@ stupid_mark_refs (x, insn)\n \n \t      if (last_call_suid < reg_where_dead[regno])\n \t\treg_n_calls_crossed[regno] += 1;\n-\t      if (last_jump_suid < reg_where_dead[regno]\n-\t\t  || last_label_suid < reg_where_dead[regno])\n-\t\treg_crosses_blocks[regno] = 1;\n \t    }\n \t}\n+\n       /* Record references from the value being set,\n \t or from addresses in the place being set if that's not a reg.\n \t If setting a SUBREG, we treat the entire reg as *used*.  */"}]}