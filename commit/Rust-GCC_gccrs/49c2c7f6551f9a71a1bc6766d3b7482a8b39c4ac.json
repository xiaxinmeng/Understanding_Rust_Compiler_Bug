{"sha": "49c2c7f6551f9a71a1bc6766d3b7482a8b39c4ac", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDljMmM3ZjY1NTFmOWE3MWExYmM2NzY2ZDNiNzQ4MmE4YjM5YzRhYw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2021-05-21T09:25:53Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2021-05-21T09:27:28Z"}, "message": "Remove discriminant checks in gigi\n\ngcc/ada/\n\t* gcc-interface/utils.c (gnat_pushdecl): Fix typo in comment.\n\t* gcc-interface/utils2.c (build_simple_component_ref): Build NULL_EXPR\n\tif the offset of the field has overflowed.\n\t(build_component_ref): Add gigi checking assertion that the reference\n\thas been built and replace the discriminant check by a Program_Error.", "tree": {"sha": "2cd3100c10ad8eb60ece0684751dd82f5f95be71", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2cd3100c10ad8eb60ece0684751dd82f5f95be71"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/49c2c7f6551f9a71a1bc6766d3b7482a8b39c4ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49c2c7f6551f9a71a1bc6766d3b7482a8b39c4ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/49c2c7f6551f9a71a1bc6766d3b7482a8b39c4ac", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49c2c7f6551f9a71a1bc6766d3b7482a8b39c4ac/comments", "author": null, "committer": null, "parents": [{"sha": "3553d8c2fecbe8d831538c661c9e58e7ae50c385", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3553d8c2fecbe8d831538c661c9e58e7ae50c385", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3553d8c2fecbe8d831538c661c9e58e7ae50c385"}], "stats": {"total": 17, "additions": 11, "deletions": 6}, "files": [{"sha": "1786fbf81867569037c29a47230d3083a005cf23", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49c2c7f6551f9a71a1bc6766d3b7482a8b39c4ac/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49c2c7f6551f9a71a1bc6766d3b7482a8b39c4ac/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=49c2c7f6551f9a71a1bc6766d3b7482a8b39c4ac", "patch": "@@ -784,7 +784,7 @@ gnat_pushdecl (tree decl, Node_Id gnat_node)\n   tree context = NULL_TREE;\n   struct deferred_decl_context_node *deferred_decl_context = NULL;\n \n-  /* If explicitely asked to make DECL global or if it's an imported nested\n+  /* If explicitly asked to make DECL global or if it's an imported nested\n      object, short-circuit the regular Scope-based context computation.  */\n   if (!((TREE_PUBLIC (decl) && DECL_EXTERNAL (decl)) || force_global == 1))\n     {"}, {"sha": "e8ed4b292a59e97b651986ec89f7490832ab2153", "filename": "gcc/ada/gcc-interface/utils2.c", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/49c2c7f6551f9a71a1bc6766d3b7482a8b39c4ac/gcc%2Fada%2Fgcc-interface%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/49c2c7f6551f9a71a1bc6766d3b7482a8b39c4ac/gcc%2Fada%2Fgcc-interface%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils2.c?ref=49c2c7f6551f9a71a1bc6766d3b7482a8b39c4ac", "patch": "@@ -2071,7 +2071,9 @@ build_simple_component_ref (tree record, tree field, bool no_fold)\n      need to warn since this will be done on trying to declare the object.  */\n   if (TREE_CODE (DECL_FIELD_OFFSET (field)) == INTEGER_CST\n       && TREE_OVERFLOW (DECL_FIELD_OFFSET (field)))\n-    return NULL_TREE;\n+    return build1 (NULL_EXPR, TREE_TYPE (field),\n+\t\t   build_call_raise (SE_Object_Too_Large, Empty,\n+\t\t\t\t     N_Raise_Storage_Error));\n \n   ref = build3 (COMPONENT_REF, TREE_TYPE (field), record, field, NULL_TREE);\n \n@@ -2105,7 +2107,7 @@ build_simple_component_ref (tree record, tree field, bool no_fold)\n   return fold (ref);\n }\n \n-/* Likewise, but return NULL_EXPR and generate a Constraint_Error if the\n+/* Likewise, but return NULL_EXPR and generate a Program_Error if the\n    field is not found in the record.  */\n \n tree\n@@ -2115,10 +2117,13 @@ build_component_ref (tree record, tree field, bool no_fold)\n   if (ref)\n     return ref;\n \n-  /* Assume this is an invalid user field so raise Constraint_Error.  */\n+  /* The missing field should have been detected in the front-end.  */\n+  gigi_checking_assert (false);\n+\n+  /* Assume this is an invalid user field so raise Program_Error.  */\n   return build1 (NULL_EXPR, TREE_TYPE (field),\n-\t\t build_call_raise (CE_Discriminant_Check_Failed, Empty,\n-\t\t\t\t   N_Raise_Constraint_Error));\n+\t\t build_call_raise (PE_Explicit_Raise, Empty,\n+\t\t\t\t   N_Raise_Program_Error));\n }\n \n /* Helper for build_call_alloc_dealloc, with arguments to be interpreted"}]}