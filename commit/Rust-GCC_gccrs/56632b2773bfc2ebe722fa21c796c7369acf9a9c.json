{"sha": "56632b2773bfc2ebe722fa21c796c7369acf9a9c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTY2MzJiMjc3M2JmYzJlYmU3MjJmYTIxYzc5NmM3MzY5YWNmOWE5Yw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2014-11-17T19:08:07Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2014-11-17T19:08:07Z"}, "message": "Handle C++14 constexpr flow control.\n\n\t* constexpr.c (cxx_eval_loop_expr, cxx_eval_switch_expr): New.\n\t(cxx_eval_statement_list): New.\n\t(cxx_eval_constant_expression): Handle LABEL_EXPR,\n\tCASE_LABEL_EXPR, GOTO_EXPR, LOOP_EXPR, SWITCH_EXPR.  Handle jump\n\tsemantics of RETURN_EXPR.\n\t(many functions): Add jump_target parameter.\n\t(returns, breaks, continues, switches, label_matches): New.\n\t* cp-tree.h (LABEL_DECL_BREAK, LABEL_DECL_CONTINUE): New.\n\t* cp-gimplify.c (begin_bc_block): Set them.\n\nFrom-SVN: r217670", "tree": {"sha": "73dc149a26c6bd49aa72590cac53a322919a5295", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/73dc149a26c6bd49aa72590cac53a322919a5295"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/56632b2773bfc2ebe722fa21c796c7369acf9a9c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56632b2773bfc2ebe722fa21c796c7369acf9a9c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/56632b2773bfc2ebe722fa21c796c7369acf9a9c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56632b2773bfc2ebe722fa21c796c7369acf9a9c/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "27d93d2c8a36cea495599e4eb070d3f922aab279", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27d93d2c8a36cea495599e4eb070d3f922aab279", "html_url": "https://github.com/Rust-GCC/gccrs/commit/27d93d2c8a36cea495599e4eb070d3f922aab279"}], "stats": {"total": 427, "additions": 361, "deletions": 66}, "files": [{"sha": "18e06d82cd1e34a2750fa68ac4a382d931e162b6", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56632b2773bfc2ebe722fa21c796c7369acf9a9c/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56632b2773bfc2ebe722fa21c796c7369acf9a9c/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=56632b2773bfc2ebe722fa21c796c7369acf9a9c", "patch": "@@ -1,5 +1,16 @@\n 2014-11-17  Jason Merrill  <jason@redhat.com>\n \n+\tHandle C++14 constexpr flow control.\n+\t* constexpr.c (cxx_eval_loop_expr, cxx_eval_switch_expr): New.\n+\t(cxx_eval_statement_list): New.\n+\t(cxx_eval_constant_expression): Handle LABEL_EXPR,\n+\tCASE_LABEL_EXPR, GOTO_EXPR, LOOP_EXPR, SWITCH_EXPR.  Handle jump\n+\tsemantics of RETURN_EXPR.\n+\t(many functions): Add jump_target parameter.\n+\t(returns, breaks, continues, switches, label_matches): New.\n+\t* cp-tree.h (LABEL_DECL_BREAK, LABEL_DECL_CONTINUE): New.\n+\t* cp-gimplify.c (begin_bc_block): Set them.\n+\n \t* cp-gimplify.c (genericize_cp_loop): Use LOOP_EXPR.\n \t(genericize_for_stmt): Handle null statement-list.\n "}, {"sha": "5b2565413b0ec8ddbd6f047bc2bf2006343d1140", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 249, "deletions": 66, "changes": 315, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56632b2773bfc2ebe722fa21c796c7369acf9a9c/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56632b2773bfc2ebe722fa21c796c7369acf9a9c/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=56632b2773bfc2ebe722fa21c796c7369acf9a9c", "patch": "@@ -871,7 +871,7 @@ struct constexpr_ctx {\n static GTY (()) hash_table<constexpr_call_hasher> *constexpr_call_table;\n \n static tree cxx_eval_constant_expression (const constexpr_ctx *, tree,\n-\t\t\t\t\t  bool, bool, bool *, bool *);\n+\t\t\t\t\t  bool, bool, bool *, bool *, tree *);\n \n /* Compute a hash value for a constexpr call representation.  */\n \n@@ -993,7 +993,8 @@ cxx_eval_builtin_function_call (const constexpr_ctx *ctx, tree t,\n     {\n       args[i] = cxx_eval_constant_expression (ctx, CALL_EXPR_ARG (t, i),\n \t\t\t\t\t      allow_non_constant, addr,\n-\t\t\t\t\t      non_constant_p, overflow_p);\n+\t\t\t\t\t      non_constant_p, overflow_p,\n+\t\t\t\t\t      NULL);\n       if (allow_non_constant && *non_constant_p)\n \treturn t;\n     }\n@@ -1068,7 +1069,7 @@ cxx_bind_parameters_in_call (const constexpr_ctx *ctx, tree t,\n \t}\n       arg = cxx_eval_constant_expression (ctx, x, allow_non_constant,\n \t\t\t\t\t  TREE_CODE (type) == REFERENCE_TYPE,\n-\t\t\t\t\t  non_constant_p, overflow_p);\n+\t\t\t\t\t  non_constant_p, overflow_p, NULL);\n       /* Don't VERIFY_CONSTANT here.  */\n       if (*non_constant_p && allow_non_constant)\n \treturn;\n@@ -1149,7 +1150,7 @@ cxx_eval_call_expression (const constexpr_ctx *ctx, tree t,\n       /* Might be a constexpr function pointer.  */\n       fun = cxx_eval_constant_expression (ctx, fun, allow_non_constant,\n \t\t\t\t\t  /*addr*/false, non_constant_p,\n-\t\t\t\t\t  overflow_p);\n+\t\t\t\t\t  overflow_p, NULL);\n       STRIP_NOPS (fun);\n       if (TREE_CODE (fun) == ADDR_EXPR)\n \tfun = TREE_OPERAND (fun, 0);\n@@ -1185,7 +1186,8 @@ cxx_eval_call_expression (const constexpr_ctx *ctx, tree t,\n \t{\n \t  tree arg = convert_from_reference (get_nth_callarg (t, 1));\n \t  return cxx_eval_constant_expression (ctx, arg, allow_non_constant,\n-\t\t\t\t\t       addr, non_constant_p, overflow_p);\n+\t\t\t\t\t       addr, non_constant_p,\n+\t\t\t\t\t       overflow_p, NULL);\n \t}\n       else if (TREE_CODE (t) == AGGR_INIT_EXPR\n \t       && AGGR_INIT_ZERO_FIRST (t))\n@@ -1281,7 +1283,7 @@ cxx_eval_call_expression (const constexpr_ctx *ctx, tree t,\n \t      result = (cxx_eval_constant_expression\n \t\t\t(&new_ctx, new_call.fundef->body,\n \t\t\t allow_non_constant, addr,\n-\t\t\t non_constant_p, overflow_p));\n+\t\t\t non_constant_p, overflow_p, NULL));\n \t    }\n \t  else\n \t    {\n@@ -1321,8 +1323,10 @@ cxx_eval_call_expression (const constexpr_ctx *ctx, tree t,\n \t      else\n \t\tctx->values->put (res, NULL_TREE);\n \n+\t      tree jump_target = NULL_TREE;\n \t      cxx_eval_constant_expression (ctx, body, allow_non_constant,\n-\t\t\t\t\t    addr, non_constant_p, overflow_p);\n+\t\t\t\t\t    addr, non_constant_p, overflow_p,\n+\t\t\t\t\t    &jump_target);\n \n \t      if (VOID_TYPE_P (TREE_TYPE (res)))\n \t\t/* This can be null for a subobject constructor call, in\n@@ -1454,7 +1458,8 @@ cxx_eval_unary_expression (const constexpr_ctx *ctx, tree t,\n   tree r;\n   tree orig_arg = TREE_OPERAND (t, 0);\n   tree arg = cxx_eval_constant_expression (ctx, orig_arg, allow_non_constant,\n-\t\t\t\t\t   addr, non_constant_p, overflow_p);\n+\t\t\t\t\t   addr, non_constant_p, overflow_p,\n+\t\t\t\t\t   NULL);\n   VERIFY_CONSTANT (arg);\n   if (arg == orig_arg)\n     return t;\n@@ -1477,11 +1482,11 @@ cxx_eval_binary_expression (const constexpr_ctx *ctx, tree t,\n   tree lhs, rhs;\n   lhs = cxx_eval_constant_expression (ctx, orig_lhs,\n \t\t\t\t      allow_non_constant, addr,\n-\t\t\t\t      non_constant_p, overflow_p);\n+\t\t\t\t      non_constant_p, overflow_p, NULL);\n   VERIFY_CONSTANT (lhs);\n   rhs = cxx_eval_constant_expression (ctx, orig_rhs,\n \t\t\t\t      allow_non_constant, addr,\n-\t\t\t\t      non_constant_p, overflow_p);\n+\t\t\t\t      non_constant_p, overflow_p, NULL);\n   VERIFY_CONSTANT (rhs);\n   if (lhs == orig_lhs && rhs == orig_rhs)\n     return t;\n@@ -1497,20 +1502,24 @@ cxx_eval_binary_expression (const constexpr_ctx *ctx, tree t,\n static tree\n cxx_eval_conditional_expression (const constexpr_ctx *ctx, tree t,\n \t\t\t\t bool allow_non_constant, bool addr,\n-\t\t\t\t bool *non_constant_p, bool *overflow_p)\n+\t\t\t\t bool *non_constant_p, bool *overflow_p,\n+\t\t\t\t tree *jump_target)\n {\n   tree val = cxx_eval_constant_expression (ctx, TREE_OPERAND (t, 0),\n \t\t\t\t\t   allow_non_constant, addr,\n-\t\t\t\t\t   non_constant_p, overflow_p);\n+\t\t\t\t\t   non_constant_p, overflow_p,\n+\t\t\t\t\t   NULL);\n   VERIFY_CONSTANT (val);\n   /* Don't VERIFY_CONSTANT the other operands.  */\n   if (integer_zerop (val))\n     return cxx_eval_constant_expression (ctx, TREE_OPERAND (t, 2),\n \t\t\t\t\t allow_non_constant, addr,\n-\t\t\t\t\t non_constant_p, overflow_p);\n+\t\t\t\t\t non_constant_p, overflow_p,\n+\t\t\t\t\t jump_target);\n   return cxx_eval_constant_expression (ctx, TREE_OPERAND (t, 1),\n \t\t\t\t       allow_non_constant, addr,\n-\t\t\t\t       non_constant_p, overflow_p);\n+\t\t\t\t       non_constant_p, overflow_p,\n+\t\t\t\t       jump_target);\n }\n \n /* Subroutine of cxx_eval_constant_expression.\n@@ -1524,7 +1533,7 @@ cxx_eval_array_reference (const constexpr_ctx *ctx, tree t,\n   tree oldary = TREE_OPERAND (t, 0);\n   tree ary = cxx_eval_constant_expression (ctx, oldary,\n \t\t\t\t\t   allow_non_constant, addr,\n-\t\t\t\t\t   non_constant_p, overflow_p);\n+\t\t\t\t\t   non_constant_p, overflow_p, NULL);\n   tree index, oldidx;\n   HOST_WIDE_INT i;\n   tree elem_type;\n@@ -1534,7 +1543,7 @@ cxx_eval_array_reference (const constexpr_ctx *ctx, tree t,\n   oldidx = TREE_OPERAND (t, 1);\n   index = cxx_eval_constant_expression (ctx, oldidx,\n \t\t\t\t\tallow_non_constant, false,\n-\t\t\t\t\tnon_constant_p, overflow_p);\n+\t\t\t\t\tnon_constant_p, overflow_p, NULL);\n   VERIFY_CONSTANT (index);\n   if (addr && ary == oldary && index == oldidx)\n     return t;\n@@ -1565,7 +1574,8 @@ cxx_eval_array_reference (const constexpr_ctx *ctx, tree t,\n \t  tree val = build_value_init (elem_type, tf_warning_or_error);\n \t  return cxx_eval_constant_expression (ctx, val,\n \t\t\t\t\t       allow_non_constant, addr,\n-\t\t\t\t\t       non_constant_p, overflow_p);\n+\t\t\t\t\t       non_constant_p, overflow_p,\n+\t\t\t\t\t       NULL);\n \t}\n \n       if (!allow_non_constant)\n@@ -1611,7 +1621,7 @@ cxx_eval_component_reference (const constexpr_ctx *ctx, tree t,\n   tree orig_whole = TREE_OPERAND (t, 0);\n   tree whole = cxx_eval_constant_expression (ctx, orig_whole,\n \t\t\t\t\t     allow_non_constant, addr,\n-\t\t\t\t\t     non_constant_p, overflow_p);\n+\t\t\t\t\t     non_constant_p, overflow_p, NULL);\n   if (whole == orig_whole)\n     return t;\n   if (addr)\n@@ -1670,7 +1680,7 @@ cxx_eval_component_reference (const constexpr_ctx *ctx, tree t,\n   value = build_value_init (TREE_TYPE (t), tf_warning_or_error);\n   return cxx_eval_constant_expression (ctx, value,\n \t\t\t\t       allow_non_constant, addr,\n-\t\t\t\t       non_constant_p, overflow_p);\n+\t\t\t\t       non_constant_p, overflow_p, NULL);\n }\n \n /* Subroutine of cxx_eval_constant_expression.\n@@ -1688,7 +1698,7 @@ cxx_eval_bit_field_ref (const constexpr_ctx *ctx, tree t,\n   HOST_WIDE_INT istart, isize;\n   tree whole = cxx_eval_constant_expression (ctx, orig_whole,\n \t\t\t\t\t     allow_non_constant, addr,\n-\t\t\t\t\t     non_constant_p, overflow_p);\n+\t\t\t\t\t     non_constant_p, overflow_p, NULL);\n   tree start, field, value;\n   unsigned HOST_WIDE_INT i;\n \n@@ -1771,13 +1781,14 @@ cxx_eval_logical_expression (const constexpr_ctx *ctx, tree t,\n   tree r;\n   tree lhs = cxx_eval_constant_expression (ctx, TREE_OPERAND (t, 0),\n \t\t\t\t\t   allow_non_constant, addr,\n-\t\t\t\t\t   non_constant_p, overflow_p);\n+\t\t\t\t\t   non_constant_p, overflow_p, NULL);\n   VERIFY_CONSTANT (lhs);\n   if (tree_int_cst_equal (lhs, bailout_value))\n     return lhs;\n   gcc_assert (tree_int_cst_equal (lhs, continue_value));\n   r = cxx_eval_constant_expression (ctx, TREE_OPERAND (t, 1),\n-\t\t\t\t    allow_non_constant, addr, non_constant_p, overflow_p);\n+\t\t\t\t    allow_non_constant, addr, non_constant_p,\n+\t\t\t\t    overflow_p, NULL);\n   VERIFY_CONSTANT (r);\n   return r;\n }\n@@ -1920,7 +1931,8 @@ cxx_eval_bare_aggregate (const constexpr_ctx *ctx, tree t,\n \tCONSTRUCTOR_APPEND_ELT (*p, index, new_ctx.ctor);\n       tree elt = cxx_eval_constant_expression (&new_ctx, value,\n \t\t\t\t\t       allow_non_constant, addr,\n-\t\t\t\t\t       non_constant_p, overflow_p);\n+\t\t\t\t\t       non_constant_p, overflow_p,\n+\t\t\t\t\t       NULL);\n       /* Don't VERIFY_CONSTANT here.  */\n       if (allow_non_constant && *non_constant_p)\n \tbreak;\n@@ -2038,7 +2050,7 @@ cxx_eval_vec_init_1 (const constexpr_ctx *ctx, tree atype, tree init,\n \t     we just pre-built above.  */\n \t  eltinit = (cxx_eval_constant_expression\n \t\t     (&new_ctx, init, allow_non_constant,\n-\t\t      addr, non_constant_p, overflow_p));\n+\t\t      addr, non_constant_p, overflow_p, NULL));\n \t}\n       else\n \t{\n@@ -2052,7 +2064,7 @@ cxx_eval_vec_init_1 (const constexpr_ctx *ctx, tree atype, tree init,\n \t  eltinit = force_rvalue (eltinit, tf_warning_or_error);\n \t  eltinit = (cxx_eval_constant_expression\n \t\t     (&new_ctx, eltinit, allow_non_constant, addr,\n-\t\t      non_constant_p, overflow_p));\n+\t\t      non_constant_p, overflow_p, NULL));\n \t}\n       if (*non_constant_p && !allow_non_constant)\n \tbreak;\n@@ -2288,7 +2300,8 @@ cxx_eval_indirect_ref (const constexpr_ctx *ctx, tree t,\n {\n   tree orig_op0 = TREE_OPERAND (t, 0);\n   tree op0 = cxx_eval_constant_expression (ctx, orig_op0, allow_non_constant,\n-\t\t\t\t\t   /*addr*/false, non_constant_p, overflow_p);\n+\t\t\t\t\t   /*addr*/false, non_constant_p,\n+\t\t\t\t\t   overflow_p, NULL);\n   bool empty_base = false;\n   tree r;\n \n@@ -2301,7 +2314,7 @@ cxx_eval_indirect_ref (const constexpr_ctx *ctx, tree t,\n \n   if (r)\n     r = cxx_eval_constant_expression (ctx, r, allow_non_constant,\n-\t\t\t\t      addr, non_constant_p, overflow_p);\n+\t\t\t\t      addr, non_constant_p, overflow_p, NULL);\n   else\n     {\n       tree sub = op0;\n@@ -2403,7 +2416,8 @@ cxx_eval_trinary_expression (const constexpr_ctx *ctx, tree t,\n     {\n       args[i] = cxx_eval_constant_expression (ctx, TREE_OPERAND (t, i),\n \t\t\t\t\t      allow_non_constant, addr,\n-\t\t\t\t\t      non_constant_p, overflow_p);\n+\t\t\t\t\t      non_constant_p, overflow_p,\n+\t\t\t\t\t      NULL);\n       VERIFY_CONSTANT (args[i]);\n     }\n \n@@ -2436,7 +2450,7 @@ cxx_eval_store_expression (const constexpr_ctx *ctx, tree t,\n   tree target = TREE_OPERAND (t, 0);\n   target = cxx_eval_constant_expression (ctx, target,\n \t\t\t\t\t allow_non_constant, true,\n-\t\t\t\t\t non_constant_p, overflow_p);\n+\t\t\t\t\t non_constant_p, overflow_p, NULL);\n   if (*non_constant_p)\n     return t;\n \n@@ -2512,7 +2526,7 @@ cxx_eval_store_expression (const constexpr_ctx *ctx, tree t,\n \n   tree init = cxx_eval_constant_expression (&new_ctx, TREE_OPERAND (t, 1),\n \t\t\t\t\t    allow_non_constant, false,\n-\t\t\t\t\t    non_constant_p, overflow_p);\n+\t\t\t\t\t    non_constant_p, overflow_p, NULL);\n   if (target == object)\n     /* The hash table might have moved since the get earlier.  */\n     ctx->values->put (object, init);\n@@ -2542,12 +2556,12 @@ cxx_eval_increment_expression (const constexpr_ctx *ctx, tree t,\n \n   /* The operand as an lvalue.  */\n   op = cxx_eval_constant_expression (ctx, op, allow_non_constant, true,\n-\t\t\t\t     non_constant_p, overflow_p);\n+\t\t\t\t     non_constant_p, overflow_p, NULL);\n \n   /* The operand as an rvalue.  */\n   tree val = rvalue (op);\n   val = cxx_eval_constant_expression (ctx, val, allow_non_constant, false,\n-\t\t\t\t      non_constant_p, overflow_p);\n+\t\t\t\t      non_constant_p, overflow_p, NULL);\n   VERIFY_CONSTANT (val);\n \n   /* The modified value.  */\n@@ -2559,7 +2573,7 @@ cxx_eval_increment_expression (const constexpr_ctx *ctx, tree t,\n   /* Storing the modified value.  */\n   tree store = build2 (MODIFY_EXPR, type, op, mod);\n   cxx_eval_constant_expression (ctx, store, allow_non_constant,\n-\t\t\t\ttrue, non_constant_p, overflow_p);\n+\t\t\t\ttrue, non_constant_p, overflow_p, NULL);\n \n   /* And the value of the expression.  */\n   if (code == PREINCREMENT_EXPR || code == PREDECREMENT_EXPR)\n@@ -2576,6 +2590,159 @@ cxx_eval_increment_expression (const constexpr_ctx *ctx, tree t,\n     return val;\n }\n \n+/* Predicates for the meaning of *jump_target.  */\n+\n+static bool\n+returns (tree *jump_target)\n+{\n+  return *jump_target\n+    && TREE_CODE (*jump_target) == RETURN_EXPR;\n+}\n+\n+static bool\n+breaks (tree *jump_target)\n+{\n+  return *jump_target\n+    && TREE_CODE (*jump_target) == LABEL_DECL\n+    && LABEL_DECL_BREAK (*jump_target);\n+}\n+\n+static bool\n+continues (tree *jump_target)\n+{\n+  return *jump_target\n+    && TREE_CODE (*jump_target) == LABEL_DECL\n+    && LABEL_DECL_CONTINUE (*jump_target);\n+}\n+\n+static bool\n+switches (tree *jump_target)\n+{\n+  return *jump_target\n+    && TREE_CODE (*jump_target) == INTEGER_CST;\n+}\n+\n+/* Subroutine of cxx_eval_statement_list.  Determine whether the statement\n+   at I matches *jump_target.  If we're looking for a case label and we see\n+   the default label, copy I into DEFAULT_LABEL.  */\n+\n+static bool\n+label_matches (tree *jump_target, tree_stmt_iterator i,\n+\t       tree_stmt_iterator& default_label)\n+{\n+  tree stmt = tsi_stmt (i);\n+  switch (TREE_CODE (*jump_target))\n+    {\n+    case LABEL_DECL:\n+      if (TREE_CODE (stmt) == LABEL_EXPR\n+\t  && LABEL_EXPR_LABEL (stmt) == *jump_target)\n+\treturn true;\n+      break;\n+\n+    case INTEGER_CST:\n+      if (TREE_CODE (stmt) == CASE_LABEL_EXPR)\n+\t{\n+\t  if (!CASE_LOW (stmt))\n+\t    default_label = i;\n+\t  else if (tree_int_cst_equal (*jump_target, CASE_LOW (stmt)))\n+\t    return true;\n+\t}\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+  return false;\n+}\n+\n+/* Evaluate a STATEMENT_LIST for side-effects.  Handles various jump\n+   semantics, for switch, break, continue, and return.  */\n+\n+static tree\n+cxx_eval_statement_list (const constexpr_ctx *ctx, tree t,\n+\t\t\t bool allow_non_constant,\n+\t\t\t bool *non_constant_p, bool *overflow_p,\n+\t\t\t tree *jump_target)\n+{\n+  tree_stmt_iterator i;\n+  tree_stmt_iterator default_label = tree_stmt_iterator();\n+  for (i = tsi_start (t); !tsi_end_p (i); tsi_next (&i))\n+    {\n+    reenter:\n+      tree stmt = tsi_stmt (i);\n+      if (*jump_target)\n+\t{\n+\t  if (TREE_CODE (stmt) == STATEMENT_LIST)\n+\t    /* The label we want might be inside.  */;\n+\t  else if (label_matches (jump_target, i, default_label))\n+\t    /* Found it.  */\n+\t    *jump_target = NULL_TREE;\n+\t  else\n+\t    continue;\n+\t}\n+      cxx_eval_constant_expression (ctx, stmt,\n+\t\t\t\t    allow_non_constant, false,\n+\t\t\t\t    non_constant_p, overflow_p,\n+\t\t\t\t    jump_target);\n+      if (*non_constant_p)\n+\tbreak;\n+      if (returns (jump_target) || breaks (jump_target))\n+\tbreak;\n+    }\n+  if (switches (jump_target) && !tsi_end_p (default_label))\n+    {\n+      i = default_label;\n+      *jump_target = NULL_TREE;\n+      goto reenter;\n+    }\n+  return NULL_TREE;\n+}\n+\n+/* Evaluate a LOOP_EXPR for side-effects.  Handles break and return\n+   semantics; continue semantics are covered by cxx_eval_statement_list.  */\n+\n+static tree\n+cxx_eval_loop_expr (const constexpr_ctx *ctx, tree t,\n+\t\t    bool allow_non_constant,\n+\t\t    bool *non_constant_p, bool *overflow_p,\n+\t\t    tree *jump_target)\n+{\n+  tree body = TREE_OPERAND (t, 0);\n+  while (true)\n+    {\n+      cxx_eval_statement_list (ctx, body, allow_non_constant,\n+\t\t\t       non_constant_p, overflow_p, jump_target);\n+      if (returns (jump_target) || breaks (jump_target))\n+\tbreak;\n+    }\n+  if (breaks (jump_target))\n+    *jump_target = NULL_TREE;\n+  return NULL_TREE;\n+}\n+\n+/* Evaluate a SWITCH_EXPR for side-effects.  Handles switch and break jump\n+   semantics.  */\n+\n+static tree\n+cxx_eval_switch_expr (const constexpr_ctx *ctx, tree t,\n+\t\t      bool allow_non_constant,\n+\t\t      bool *non_constant_p, bool *overflow_p,\n+\t\t      tree *jump_target)\n+{\n+  tree cond = TREE_OPERAND (t, 0);\n+  cond = cxx_eval_constant_expression (ctx, cond, allow_non_constant, false,\n+\t\t\t\t       non_constant_p, overflow_p, NULL);\n+  VERIFY_CONSTANT (cond);\n+  *jump_target = cond;\n+\n+  tree body = TREE_OPERAND (t, 1);\n+  cxx_eval_statement_list (ctx, body, allow_non_constant,\n+\t\t\t   non_constant_p, overflow_p, jump_target);\n+  if (breaks (jump_target) || switches (jump_target))\n+    *jump_target = NULL_TREE;\n+  return NULL_TREE;\n+}\n+\n /* Attempt to reduce the expression T to a constant value.\n    On failure, issue diagnostic and return error_mark_node.  */\n /* FIXME unify with c_fully_fold */\n@@ -2584,7 +2751,8 @@ cxx_eval_increment_expression (const constexpr_ctx *ctx, tree t,\n static tree\n cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \t\t\t      bool allow_non_constant, bool addr,\n-\t\t\t      bool *non_constant_p, bool *overflow_p)\n+\t\t\t      bool *non_constant_p, bool *overflow_p,\n+\t\t\t      tree *jump_target)\n {\n   constexpr_ctx new_ctx;\n   tree r = t;\n@@ -2639,6 +2807,8 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n     case FUNCTION_DECL:\n     case TEMPLATE_DECL:\n     case LABEL_DECL:\n+    case LABEL_EXPR:\n+    case CASE_LABEL_EXPR:\n       return t;\n \n     case PARM_DECL:\n@@ -2683,7 +2853,8 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \t  {\n \t    init = cxx_eval_constant_expression (ctx, init,\n \t\t\t\t\t\t allow_non_constant, false,\n-\t\t\t\t\t\t non_constant_p, overflow_p);\n+\t\t\t\t\t\t non_constant_p, overflow_p,\n+\t\t\t\t\t\t NULL);\n \t    ctx->values->put (r, init);\n \t  }\n \telse if (ctx == &new_ctx)\n@@ -2721,7 +2892,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \t initialization of a temporary.  */\n       r = cxx_eval_constant_expression (ctx, TREE_OPERAND (t, 1),\n \t\t\t\t\tallow_non_constant, false,\n-\t\t\t\t\tnon_constant_p, overflow_p);\n+\t\t\t\t\tnon_constant_p, overflow_p, NULL);\n       if (!*non_constant_p)\n \t/* Adjust the type of the result to the type of the temporary.  */\n \tr = adjust_temp_type (TREE_TYPE (t), r);\n@@ -2734,7 +2905,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \t     not the side-effect of the initialization.  */\n \t  r = cxx_eval_constant_expression (ctx, TREE_OPERAND (t, 1),\n \t\t\t\t\t    allow_non_constant, false,\n-\t\t\t\t\t    non_constant_p, overflow_p);\n+\t\t\t\t\t    non_constant_p, overflow_p, NULL);\n \t  break;\n \t}\n       /* else fall through */\n@@ -2746,10 +2917,16 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n     case SCOPE_REF:\n       r = cxx_eval_constant_expression (ctx, TREE_OPERAND (t, 1),\n \t\t\t\t\tallow_non_constant, addr,\n-\t\t\t\t\tnon_constant_p, overflow_p);\n+\t\t\t\t\tnon_constant_p, overflow_p, NULL);\n       break;\n \n     case RETURN_EXPR:\n+      r = cxx_eval_constant_expression (ctx, TREE_OPERAND (t, 0),\n+\t\t\t\t\tallow_non_constant, addr,\n+\t\t\t\t\tnon_constant_p, overflow_p, NULL);\n+      *jump_target = t;\n+      break;\n+\n     case NON_LVALUE_EXPR:\n     case TRY_CATCH_EXPR:\n     case CLEANUP_POINT_EXPR:\n@@ -2759,7 +2936,8 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n     case EH_SPEC_BLOCK:\n       r = cxx_eval_constant_expression (ctx, TREE_OPERAND (t, 0),\n \t\t\t\t\tallow_non_constant, addr,\n-\t\t\t\t\tnon_constant_p, overflow_p);\n+\t\t\t\t\tnon_constant_p, overflow_p,\n+\t\t\t\t\tjump_target);\n       break;\n \n       /* These differ from cxx_eval_unary_expression in that this doesn't\n@@ -2776,7 +2954,8 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \ttree op = cxx_eval_constant_expression (ctx, oldop,\n \t\t\t\t\t\tallow_non_constant,\n \t\t\t\t\t\t/*addr*/true,\n-\t\t\t\t\t\tnon_constant_p, overflow_p);\n+\t\t\t\t\t\tnon_constant_p, overflow_p,\n+\t\t\t\t\t\tNULL);\n \t/* Don't VERIFY_CONSTANT here.  */\n \tif (*non_constant_p)\n \t  return t;\n@@ -2827,15 +3006,18 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \tif ((TREE_CODE (op0) == TARGET_EXPR && op1 == TARGET_EXPR_SLOT (op0))\n \t    || TREE_CODE (op1) == EMPTY_CLASS_EXPR)\n \t  r = cxx_eval_constant_expression (ctx, op0, allow_non_constant,\n-\t\t\t\t\t    addr, non_constant_p, overflow_p);\n+\t\t\t\t\t    addr, non_constant_p, overflow_p,\n+\t\t\t\t\t    jump_target);\n \telse\n \t  {\n \t    /* Check that the LHS is constant and then discard it.  */\n \t    cxx_eval_constant_expression (ctx, op0, allow_non_constant,\n-\t\t\t\t\t  false, non_constant_p, overflow_p);\n+\t\t\t\t\t  false, non_constant_p, overflow_p,\n+\t\t\t\t\t  jump_target);\n \t    op1 = TREE_OPERAND (t, 1);\n \t    r = cxx_eval_constant_expression (ctx, op1, allow_non_constant,\n-\t\t\t\t\t      addr, non_constant_p, overflow_p);\n+\t\t\t\t\t      addr, non_constant_p, overflow_p,\n+\t\t\t\t\t      jump_target);\n \t  }\n       }\n       break;\n@@ -2929,7 +3111,8 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n     case COND_EXPR:\n     case VEC_COND_EXPR:\n       r = cxx_eval_conditional_expression (ctx, t, allow_non_constant, addr,\n-\t\t\t\t\t   non_constant_p, overflow_p);\n+\t\t\t\t\t   non_constant_p, overflow_p,\n+\t\t\t\t\t   jump_target);\n       break;\n \n     case CONSTRUCTOR:\n@@ -2960,7 +3143,8 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \ttree oldop = TREE_OPERAND (t, 0);\n \ttree op = cxx_eval_constant_expression (ctx, oldop,\n \t\t\t\t\t\tallow_non_constant, addr,\n-\t\t\t\t\t\tnon_constant_p, overflow_p);\n+\t\t\t\t\t\tnon_constant_p, overflow_p,\n+\t\t\t\t\t\tNULL);\n \tif (*non_constant_p)\n \t  return t;\n \tif (POINTER_TYPE_P (TREE_TYPE (t))\n@@ -2992,25 +3176,16 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n       return t;\n \n     case STATEMENT_LIST:\n-      {\n-\tnew_ctx = *ctx;\n-\tnew_ctx.ctor = new_ctx.object = NULL_TREE;\n-\ttree_stmt_iterator i;\n-\tfor (i = tsi_start (t); !tsi_end_p (i); tsi_next (&i))\n-\t  {\n-\t    cxx_eval_constant_expression (&new_ctx, tsi_stmt (i),\n-\t\t\t\t\t  allow_non_constant, false,\n-\t\t\t\t\t  non_constant_p, overflow_p);\n-\t    if (*non_constant_p)\n-\t      break;\n-\t  }\n-      }\n-      break;\n+      new_ctx = *ctx;\n+      new_ctx.ctor = new_ctx.object = NULL_TREE;\n+      return cxx_eval_statement_list (&new_ctx, t, allow_non_constant,\n+\t\t\t\t      non_constant_p, overflow_p, jump_target);\n \n     case BIND_EXPR:\n       return cxx_eval_constant_expression (ctx, BIND_EXPR_BODY (t),\n \t\t\t\t\t   allow_non_constant, addr,\n-\t\t\t\t\t   non_constant_p, overflow_p);\n+\t\t\t\t\t   non_constant_p, overflow_p,\n+\t\t\t\t\t   jump_target);\n \n     case PREINCREMENT_EXPR:\n     case POSTINCREMENT_EXPR:\n@@ -3058,16 +3233,24 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \t  gcc_assert (same_type_ignoring_top_level_qualifiers_p\n \t\t      (TREE_TYPE (t), TREE_TYPE (ctor)));\n \t  return cxx_eval_constant_expression\n-\t    (ctx, ctor, allow_non_constant, addr, non_constant_p, overflow_p);\n+\t    (ctx, ctor, allow_non_constant, addr,\n+\t     non_constant_p, overflow_p, NULL);\n \t}\n       break;\n \n     case GOTO_EXPR:\n+      *jump_target = TREE_OPERAND (t, 0);\n+      gcc_assert (breaks (jump_target) || continues (jump_target));\n+      break;\n+\n     case LOOP_EXPR:\n+      cxx_eval_loop_expr (ctx, t, allow_non_constant,\n+\t\t\t  non_constant_p, overflow_p, jump_target);\n+      break;\n+\n     case SWITCH_EXPR:\n-      if (!allow_non_constant)\n-\tsorry (\"%qs in constant expression\", get_tree_code_name (TREE_CODE (t)));\n-      *non_constant_p = true;\n+      cxx_eval_switch_expr (ctx, t, allow_non_constant,\n+\t\t\t    non_constant_p, overflow_p, jump_target);\n       break;\n \n     default:\n@@ -3128,7 +3311,7 @@ cxx_eval_outermost_constant_expr (tree t, bool allow_non_constant,\n     }\n \n   r = cxx_eval_constant_expression (&ctx, r, allow_non_constant,\n-\t\t\t\t    false, &non_constant_p, &overflow_p);\n+\t\t\t\t    false, &non_constant_p, &overflow_p, NULL);\n \n   verify_constant (r, allow_non_constant, &non_constant_p, &overflow_p);\n \n@@ -3205,7 +3388,7 @@ is_sub_constant_expr (tree t)\n   hash_map <tree, tree> map;\n   ctx.values = &map;\n   cxx_eval_constant_expression (&ctx, t, true, false, &non_constant_p,\n-\t\t\t\t&overflow_p);\n+\t\t\t\t&overflow_p, NULL);\n   return !non_constant_p && !overflow_p;\n }\n "}, {"sha": "82be90be437f3886aad5cdb3fd3b73b5bdf62550", "filename": "gcc/cp/cp-gimplify.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56632b2773bfc2ebe722fa21c796c7369acf9a9c/gcc%2Fcp%2Fcp-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56632b2773bfc2ebe722fa21c796c7369acf9a9c/gcc%2Fcp%2Fcp-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.c?ref=56632b2773bfc2ebe722fa21c796c7369acf9a9c", "patch": "@@ -74,6 +74,10 @@ begin_bc_block (enum bc_t bc, location_t location)\n   tree label = create_artificial_label (location);\n   DECL_CHAIN (label) = bc_label[bc];\n   bc_label[bc] = label;\n+  if (bc == bc_break)\n+    LABEL_DECL_BREAK (label) = true;\n+  else\n+    LABEL_DECL_CONTINUE (label) = true;\n   return label;\n }\n "}, {"sha": "d3722d73f61148de1c69e06d1f2c796c5f76f61d", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56632b2773bfc2ebe722fa21c796c7369acf9a9c/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56632b2773bfc2ebe722fa21c796c7369acf9a9c/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=56632b2773bfc2ebe722fa21c796c7369acf9a9c", "patch": "@@ -148,12 +148,14 @@ c-common.h, not after.\n       DECL_LOCAL_FUNCTION_P (in FUNCTION_DECL)\n       DECL_MUTABLE_P (in FIELD_DECL)\n       DECL_DEPENDENT_P (in USING_DECL)\n+      LABEL_DECL_BREAK (in LABEL_DECL)\n    1: C_TYPEDEF_EXPLICITLY_SIGNED (in TYPE_DECL).\n       DECL_TEMPLATE_INSTANTIATED (in a VAR_DECL or a FUNCTION_DECL)\n       DECL_MEMBER_TEMPLATE_P (in TEMPLATE_DECL)\n       USING_DECL_TYPENAME_P (in USING_DECL)\n       DECL_VLA_CAPTURE_P (in FIELD_DECL)\n       DECL_ARRAY_PARAMETER_P (in PARM_DECL)\n+      LABEL_DECL_CONTINUE (in LABEL_DECL)\n    2: DECL_THIS_EXTERN (in VAR_DECL or FUNCTION_DECL).\n       DECL_IMPLICIT_TYPEDEF_P (in a TYPE_DECL)\n    3: DECL_IN_AGGR_P.\n@@ -3243,6 +3245,14 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n #define DECL_LOCAL_FUNCTION_P(NODE) \\\n   DECL_LANG_FLAG_0 (FUNCTION_DECL_CHECK (NODE))\n \n+/* Nonzero if NODE is the target for genericization of 'break' stmts.  */\n+#define LABEL_DECL_BREAK(NODE) \\\n+  DECL_LANG_FLAG_0 (LABEL_DECL_CHECK (NODE))\n+\n+/* Nonzero if NODE is the target for genericization of 'continue' stmts.  */\n+#define LABEL_DECL_CONTINUE(NODE) \\\n+  DECL_LANG_FLAG_1 (LABEL_DECL_CHECK (NODE))\n+\n /* True if NODE was declared with auto in its return type, but it has\n    started compilation and so the return type might have been changed by\n    return type deduction; its declared return type should be found in"}, {"sha": "fc5d4f81af1151b057ff1e7ccdf21ecc445cd4b7", "filename": "gcc/testsuite/g++.dg/cpp1y/constexpr-loop1.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56632b2773bfc2ebe722fa21c796c7369acf9a9c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-loop1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56632b2773bfc2ebe722fa21c796c7369acf9a9c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-loop1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-loop1.C?ref=56632b2773bfc2ebe722fa21c796c7369acf9a9c", "patch": "@@ -0,0 +1,13 @@\n+// { dg-do compile { target c++14 } }\n+\n+constexpr int f (int i)\n+{\n+  int j = 0;\n+  for (; i > 0; --i)\n+    ++j;\n+  return j;\n+}\n+\n+constexpr int i = f(42);\n+#define SA(X) static_assert((X),#X)\n+SA(i==42);"}, {"sha": "b114e21488819ea345ef48db026a0122cee346fd", "filename": "gcc/testsuite/g++.dg/cpp1y/constexpr-return1.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56632b2773bfc2ebe722fa21c796c7369acf9a9c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-return1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56632b2773bfc2ebe722fa21c796c7369acf9a9c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-return1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-return1.C?ref=56632b2773bfc2ebe722fa21c796c7369acf9a9c", "patch": "@@ -0,0 +1,11 @@\n+// { dg-do compile { target c++14 } }\n+\n+constexpr int f (int i)\n+{\n+  return 24;\n+  return 36;\n+}\n+\n+constexpr int i = f(42);\n+#define SA(X) static_assert((X),#X)\n+SA(i==24);"}, {"sha": "ae2628d800cdbfafdabcb08cdf9790a91ea7f367", "filename": "gcc/testsuite/g++.dg/cpp1y/constexpr-return2.C", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56632b2773bfc2ebe722fa21c796c7369acf9a9c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-return2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56632b2773bfc2ebe722fa21c796c7369acf9a9c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-return2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-return2.C?ref=56632b2773bfc2ebe722fa21c796c7369acf9a9c", "patch": "@@ -0,0 +1,7 @@\n+// { dg-do compile { target c++14 } }\n+\n+constexpr int f (int i)\n+{\n+}\n+\n+constexpr int i = f(42);\t// { dg-error \"flows off the end\" }"}, {"sha": "add732320f4c28841ef8f1a9f06f3432cbae2d66", "filename": "gcc/testsuite/g++.dg/cpp1y/constexpr-switch1.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56632b2773bfc2ebe722fa21c796c7369acf9a9c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-switch1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56632b2773bfc2ebe722fa21c796c7369acf9a9c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-switch1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-switch1.C?ref=56632b2773bfc2ebe722fa21c796c7369acf9a9c", "patch": "@@ -0,0 +1,16 @@\n+// { dg-do compile { target c++14 } }\n+\n+constexpr int f (int i)\n+{\n+  switch (i)\n+    {\n+    case 1:\n+      return 42;\n+    default:\n+      return 0;\n+    }\n+}\n+\n+constexpr int i = f(1);\n+#define SA(X) static_assert((X),#X)\n+SA(i==42);"}, {"sha": "a459a5efce9d5ea5688b76e0b2bdc77ef6350c39", "filename": "gcc/testsuite/g++.dg/cpp1y/constexpr-switch2.C", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56632b2773bfc2ebe722fa21c796c7369acf9a9c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-switch2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56632b2773bfc2ebe722fa21c796c7369acf9a9c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-switch2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-switch2.C?ref=56632b2773bfc2ebe722fa21c796c7369acf9a9c", "patch": "@@ -0,0 +1,20 @@\n+// { dg-do compile { target c++14 } }\n+\n+constexpr int f (int i)\n+{\n+  int j = 0;\n+  switch (i)\n+    {\n+    case 1:\n+      j = 42;\n+      break;\n+    default:\n+      j = 24;\n+      break;\n+    }\n+  return j;\n+}\n+\n+constexpr int i = f(1);\n+#define SA(X) static_assert((X),#X)\n+SA(i==42);"}, {"sha": "1aa1cf6bbaee69b06621dafc6619f919593f512f", "filename": "gcc/testsuite/g++.dg/cpp1y/constexpr-switch3.C", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56632b2773bfc2ebe722fa21c796c7369acf9a9c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-switch3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56632b2773bfc2ebe722fa21c796c7369acf9a9c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-switch3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-switch3.C?ref=56632b2773bfc2ebe722fa21c796c7369acf9a9c", "patch": "@@ -0,0 +1,20 @@\n+// { dg-do compile { target c++14 } }\n+\n+constexpr int f (int i)\n+{\n+  int j = 0;\n+  switch (i)\n+    {\n+    case 1:\n+      j = 42;\n+      break;\n+    default:\n+      j = 24;\n+      break;\n+    }\n+  return j;\n+}\n+\n+constexpr int i = f(2);\n+#define SA(X) static_assert((X),#X)\n+SA(i==24);"}]}