{"sha": "9e7b1d0a36292e03ebe3f149c4a97818e7567058", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWU3YjFkMGEzNjI5MmUwM2ViZTNmMTQ5YzRhOTc4MThlNzU2NzA1OA==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-04-04T21:28:09Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-04-04T21:28:09Z"}, "message": "(expand_call) [PCC_STATIC_STRUCT_RETURN]:\n\nAlways set pcc_struct_value if aggregate_value_p returns 1.\n\nFrom-SVN: r4007", "tree": {"sha": "d678c0cedb2f742b5163acf2098be36322fa3832", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d678c0cedb2f742b5163acf2098be36322fa3832"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9e7b1d0a36292e03ebe3f149c4a97818e7567058", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e7b1d0a36292e03ebe3f149c4a97818e7567058", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e7b1d0a36292e03ebe3f149c4a97818e7567058", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e7b1d0a36292e03ebe3f149c4a97818e7567058/comments", "author": null, "committer": null, "parents": [{"sha": "1d839079a610937b7623d0e8bbe88eeabcafc663", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d839079a610937b7623d0e8bbe88eeabcafc663", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d839079a610937b7623d0e8bbe88eeabcafc663"}], "stats": {"total": 47, "additions": 23, "deletions": 24}, "files": [{"sha": "b2b52b1337df6a0fa1bcd7bcd83218551ee1c219", "filename": "gcc/calls.c", "status": "modified", "additions": 23, "deletions": 24, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e7b1d0a36292e03ebe3f149c4a97818e7567058/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e7b1d0a36292e03ebe3f149c4a97818e7567058/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=9e7b1d0a36292e03ebe3f149c4a97818e7567058", "patch": "@@ -600,34 +600,33 @@ expand_call (exp, target, ignore)\n       is_const = 0;\n \n #ifdef PCC_STATIC_STRUCT_RETURN\n-      if (flag_pcc_struct_return)\n-\t{\n-\t  pcc_struct_value = 1;\n-\t  is_integrable = 0;  /* Easier than making that case work right.  */\n-\t}\n-      else\n-#endif\n-\t{\n-\t  struct_value_size = int_size_in_bytes (TREE_TYPE (exp));\n+      {\n+\tpcc_struct_value = 1;\n+\tis_integrable = 0;  /* Easier than making that case work right.  */\n+      }\n+#else /* not PCC_STATIC_STRUCT_RETURN */\n+      {\n+\tstruct_value_size = int_size_in_bytes (TREE_TYPE (exp));\n \n-\t  if (struct_value_size < 0)\n-\t    abort ();\n+\tif (struct_value_size < 0)\n+\t  abort ();\n \n-\t  if (target && GET_CODE (target) == MEM)\n-\t    structure_value_addr = XEXP (target, 0);\n-\t  else\n-\t    {\n-\t      /* Assign a temporary on the stack to hold the value.  */\n+\tif (target && GET_CODE (target) == MEM)\n+\t  structure_value_addr = XEXP (target, 0);\n+\telse\n+\t  {\n+\t    /* Assign a temporary on the stack to hold the value.  */\n \n-\t      /* For variable-sized objects, we must be called with a target\n-\t\t specified.  If we were to allocate space on the stack here,\n-\t\t we would have no way of knowing when to free it.  */\n+\t    /* For variable-sized objects, we must be called with a target\n+\t       specified.  If we were to allocate space on the stack here,\n+\t       we would have no way of knowing when to free it.  */\n \n-\t      structure_value_addr\n-\t\t= XEXP (assign_stack_temp (BLKmode, struct_value_size, 1), 0);\n-\t      target = 0;\n-\t    }\n-\t}\n+\t    structure_value_addr\n+\t      = XEXP (assign_stack_temp (BLKmode, struct_value_size, 1), 0);\n+\t    target = 0;\n+\t  }\n+      }\n+#endif /* not PCC_STATIC_STRUCT_RETURN */\n     }\n \n   /* If called function is inline, try to integrate it.  */"}]}