{"sha": "d1bb282efbf9ef9c4217119896d5d594eca627a5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDFiYjI4MmVmYmY5ZWY5YzQyMTcxMTk4OTZkNWQ1OTRlY2E2MjdhNQ==", "commit": {"author": {"name": "David Sherwood", "email": "david.sherwood@arm.com", "date": "2014-09-30T08:04:32Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2014-09-30T08:04:32Z"}, "message": "ira-int.h (ira_allocno): Add \"wmode\" field.\n\ngcc/\n2014-09-26  David Sherwood  <david.sherwood@arm.com>\n\n\t* ira-int.h (ira_allocno): Add \"wmode\" field.\n\t* ira-build.c (create_insn_allocnos): Add new \"parent\" function\n\tparameter.\n\t* ira-conflicts.c (ira_build_conflicts): Add conflicts for registers\n\tthat cannot be accessed in wmode.\n\nFrom-SVN: r215707", "tree": {"sha": "f4c9f1d2c838c3e2c542cc98b20aed91a2457ea4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f4c9f1d2c838c3e2c542cc98b20aed91a2457ea4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d1bb282efbf9ef9c4217119896d5d594eca627a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1bb282efbf9ef9c4217119896d5d594eca627a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d1bb282efbf9ef9c4217119896d5d594eca627a5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1bb282efbf9ef9c4217119896d5d594eca627a5/comments", "author": {"login": "david-arm", "id": 57997763, "node_id": "MDQ6VXNlcjU3OTk3NzYz", "avatar_url": "https://avatars.githubusercontent.com/u/57997763?v=4", "gravatar_id": "", "url": "https://api.github.com/users/david-arm", "html_url": "https://github.com/david-arm", "followers_url": "https://api.github.com/users/david-arm/followers", "following_url": "https://api.github.com/users/david-arm/following{/other_user}", "gists_url": "https://api.github.com/users/david-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/david-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/david-arm/subscriptions", "organizations_url": "https://api.github.com/users/david-arm/orgs", "repos_url": "https://api.github.com/users/david-arm/repos", "events_url": "https://api.github.com/users/david-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/david-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4176084b61c55045e4ac47c1b8794292f61b44e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4176084b61c55045e4ac47c1b8794292f61b44e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4176084b61c55045e4ac47c1b8794292f61b44e1"}], "stats": {"total": 69, "additions": 56, "deletions": 13}, "files": [{"sha": "d224b0fd3bf902b9181dc71923c2af2b8a11a9c8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1bb282efbf9ef9c4217119896d5d594eca627a5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1bb282efbf9ef9c4217119896d5d594eca627a5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d1bb282efbf9ef9c4217119896d5d594eca627a5", "patch": "@@ -1,3 +1,11 @@\n+2014-09-30  David Sherwood  <david.sherwood@arm.com>\n+\n+\t* ira-int.h (ira_allocno): Add \"wmode\" field.\n+\t* ira-build.c (create_insn_allocnos): Add new \"parent\" function\n+\tparameter.\n+\t* ira-conflicts.c (ira_build_conflicts): Add conflicts for registers\n+\tthat cannot be accessed in wmode.\n+\n 2014-09-30  Markus Trippelsdorf  <markus@trippelsdorf.de>\n \n \t* data-streamer.c (bp_unpack_var_len_int): Avoid signed"}, {"sha": "9c9916683ef5a258e2945f2154df3aba03e9ab24", "filename": "gcc/ira-build.c", "status": "modified", "additions": 22, "deletions": 12, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1bb282efbf9ef9c4217119896d5d594eca627a5/gcc%2Fira-build.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1bb282efbf9ef9c4217119896d5d594eca627a5/gcc%2Fira-build.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-build.c?ref=d1bb282efbf9ef9c4217119896d5d594eca627a5", "patch": "@@ -524,6 +524,7 @@ ira_create_allocno (int regno, bool cap_p,\n   ALLOCNO_BAD_SPILL_P (a) = false;\n   ALLOCNO_ASSIGNED_P (a) = false;\n   ALLOCNO_MODE (a) = (regno < 0 ? VOIDmode : PSEUDO_REGNO_MODE (regno));\n+  ALLOCNO_WMODE (a) = ALLOCNO_MODE (a);\n   ALLOCNO_PREFS (a) = NULL;\n   ALLOCNO_COPIES (a) = NULL;\n   ALLOCNO_HARD_REG_COSTS (a) = NULL;\n@@ -893,6 +894,7 @@ create_cap_allocno (ira_allocno_t a)\n   parent = ALLOCNO_LOOP_TREE_NODE (a)->parent;\n   cap = ira_create_allocno (ALLOCNO_REGNO (a), true, parent);\n   ALLOCNO_MODE (cap) = ALLOCNO_MODE (a);\n+  ALLOCNO_WMODE (cap) = ALLOCNO_WMODE (a);\n   aclass = ALLOCNO_CLASS (a);\n   ira_set_allocno_class (cap, aclass);\n   ira_create_allocno_objects (cap);\n@@ -1859,9 +1861,9 @@ static basic_block curr_bb;\n \n /* This recursive function creates allocnos corresponding to\n    pseudo-registers containing in X.  True OUTPUT_P means that X is\n-   a lvalue.  */\n+   an lvalue.  PARENT corresponds to the parent expression of X.  */\n static void\n-create_insn_allocnos (rtx x, bool output_p)\n+create_insn_allocnos (rtx x, rtx outer, bool output_p)\n {\n   int i, j;\n   const char *fmt;\n@@ -1876,7 +1878,15 @@ create_insn_allocnos (rtx x, bool output_p)\n \t  ira_allocno_t a;\n \n \t  if ((a = ira_curr_regno_allocno_map[regno]) == NULL)\n-\t    a = ira_create_allocno (regno, false, ira_curr_loop_tree_node);\n+\t    {\n+\t      a = ira_create_allocno (regno, false, ira_curr_loop_tree_node);\n+\t      if (outer != NULL && GET_CODE (outer) == SUBREG)\n+\t\t{\n+\t\t  enum machine_mode wmode = GET_MODE (outer);\n+\t\t  if (GET_MODE_SIZE (wmode) > GET_MODE_SIZE (ALLOCNO_WMODE (a)))\n+\t\t    ALLOCNO_WMODE (a) = wmode;\n+\t\t}\n+\t    }\n \n \t  ALLOCNO_NREFS (a)++;\n \t  ALLOCNO_FREQ (a) += REG_FREQ_FROM_BB (curr_bb);\n@@ -1887,36 +1897,36 @@ create_insn_allocnos (rtx x, bool output_p)\n     }\n   else if (code == SET)\n     {\n-      create_insn_allocnos (SET_DEST (x), true);\n-      create_insn_allocnos (SET_SRC (x), false);\n+      create_insn_allocnos (SET_DEST (x), NULL, true);\n+      create_insn_allocnos (SET_SRC (x), NULL, false);\n       return;\n     }\n   else if (code == CLOBBER)\n     {\n-      create_insn_allocnos (XEXP (x, 0), true);\n+      create_insn_allocnos (XEXP (x, 0), NULL, true);\n       return;\n     }\n   else if (code == MEM)\n     {\n-      create_insn_allocnos (XEXP (x, 0), false);\n+      create_insn_allocnos (XEXP (x, 0), NULL, false);\n       return;\n     }\n   else if (code == PRE_DEC || code == POST_DEC || code == PRE_INC ||\n \t   code == POST_INC || code == POST_MODIFY || code == PRE_MODIFY)\n     {\n-      create_insn_allocnos (XEXP (x, 0), true);\n-      create_insn_allocnos (XEXP (x, 0), false);\n+      create_insn_allocnos (XEXP (x, 0), NULL, true);\n+      create_insn_allocnos (XEXP (x, 0), NULL, false);\n       return;\n     }\n \n   fmt = GET_RTX_FORMAT (code);\n   for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n     {\n       if (fmt[i] == 'e')\n-\tcreate_insn_allocnos (XEXP (x, i), output_p);\n+\tcreate_insn_allocnos (XEXP (x, i), x, output_p);\n       else if (fmt[i] == 'E')\n \tfor (j = 0; j < XVECLEN (x, i); j++)\n-\t  create_insn_allocnos (XVECEXP (x, i, j), output_p);\n+\t  create_insn_allocnos (XVECEXP (x, i, j), x, output_p);\n     }\n }\n \n@@ -1935,7 +1945,7 @@ create_bb_allocnos (ira_loop_tree_node_t bb_node)\n   ira_assert (bb != NULL);\n   FOR_BB_INSNS_REVERSE (bb, insn)\n     if (NONDEBUG_INSN_P (insn))\n-      create_insn_allocnos (PATTERN (insn), false);\n+      create_insn_allocnos (PATTERN (insn), NULL, false);\n   /* It might be a allocno living through from one subloop to\n      another.  */\n   EXECUTE_IF_SET_IN_REG_SET (df_get_live_in (bb), FIRST_PSEUDO_REGISTER, i, bi)"}, {"sha": "15ed08bf6a45340430882ebb93ce06f331d2a799", "filename": "gcc/ira-conflicts.c", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1bb282efbf9ef9c4217119896d5d594eca627a5/gcc%2Fira-conflicts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1bb282efbf9ef9c4217119896d5d594eca627a5/gcc%2Fira-conflicts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-conflicts.c?ref=d1bb282efbf9ef9c4217119896d5d594eca627a5", "patch": "@@ -774,6 +774,27 @@ ira_build_conflicts (void)\n \t\t\t\ttemp_hard_reg_set);\n \t    }\n \n+\t  /* Now we deal with paradoxical subreg cases where certain registers\n+\t     cannot be accessed in the widest mode.  */\n+\t  enum machine_mode outer_mode = ALLOCNO_WMODE (a);\n+\t  enum machine_mode inner_mode = ALLOCNO_MODE (a);\n+\t  if (GET_MODE_SIZE (outer_mode) > GET_MODE_SIZE (inner_mode))\n+\t    {\n+\t      enum reg_class aclass = ALLOCNO_CLASS (a);\n+\t      for (int j = ira_class_hard_regs_num[aclass] - 1; j >= 0; --j)\n+\t\t{\n+\t\t   int inner_regno = ira_class_hard_regs[aclass][j];\n+\t\t   int outer_regno = simplify_subreg_regno (inner_regno,\n+\t\t\t\t\t\t\t    inner_mode, 0,\n+\t\t\t\t\t\t\t    outer_mode);\n+\t\t   if (outer_regno < 0\n+\t\t       || !in_hard_reg_set_p (reg_class_contents[aclass],\n+\t\t\t\t\t      outer_mode, outer_regno))\n+\t\t     SET_HARD_REG_BIT (OBJECT_CONFLICT_HARD_REGS (obj),\n+\t\t\t\t       inner_regno);\n+\t\t}\n+\t    }\n+\n \t  if (ALLOCNO_CALLS_CROSSED_NUM (a) != 0)\n \t    {\n \t      int regno;"}, {"sha": "e282415f98cde350bc3cb2e660047ddf7edc833b", "filename": "gcc/ira-int.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1bb282efbf9ef9c4217119896d5d594eca627a5/gcc%2Fira-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1bb282efbf9ef9c4217119896d5d594eca627a5/gcc%2Fira-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-int.h?ref=d1bb282efbf9ef9c4217119896d5d594eca627a5", "patch": "@@ -283,6 +283,9 @@ struct ira_allocno\n   /* Mode of the allocno which is the mode of the corresponding\n      pseudo-register.  */\n   ENUM_BITFIELD (machine_mode) mode : 8;\n+  /* Widest mode of the allocno which in at least one case could be\n+     for paradoxical subregs where wmode > mode.  */\n+  ENUM_BITFIELD (machine_mode) wmode : 8;\n   /* Register class which should be used for allocation for given\n      allocno.  NO_REGS means that we should use memory.  */\n   ENUM_BITFIELD (reg_class) aclass : 16;\n@@ -315,7 +318,7 @@ struct ira_allocno\n      number (0, ...) - 2.  Value -1 is used for allocnos spilled by the\n      reload (at this point pseudo-register has only one allocno) which\n      did not get stack slot yet.  */\n-  short int hard_regno;\n+  int hard_regno : 16;\n   /* Allocnos with the same regno are linked by the following member.\n      Allocnos corresponding to inner loops are first in the list (it\n      corresponds to depth-first traverse of the loops).  */\n@@ -436,6 +439,7 @@ struct ira_allocno\n #define ALLOCNO_BAD_SPILL_P(A) ((A)->bad_spill_p)\n #define ALLOCNO_ASSIGNED_P(A) ((A)->assigned_p)\n #define ALLOCNO_MODE(A) ((A)->mode)\n+#define ALLOCNO_WMODE(A) ((A)->wmode)\n #define ALLOCNO_PREFS(A) ((A)->allocno_prefs)\n #define ALLOCNO_COPIES(A) ((A)->allocno_copies)\n #define ALLOCNO_HARD_REG_COSTS(A) ((A)->hard_reg_costs)"}]}