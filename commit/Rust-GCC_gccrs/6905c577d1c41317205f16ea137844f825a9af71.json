{"sha": "6905c577d1c41317205f16ea137844f825a9af71", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjkwNWM1NzdkMWM0MTMxNzIwNWYxNmVhMTM3ODQ0ZjgyNWE5YWY3MQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2016-11-03T21:18:49Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2016-11-03T21:18:49Z"}, "message": "re PR debug/28767 (GCC should output DW_TAG_ptr_to_member for member functions)\n\n\tPR debug/28767\n\tPR debug/56974\n\t* langhooks.h (struct lang_hooks_for_types): Add type_dwarf_attribute\n\tlanghook.\n\t* langhooks.c (lhd_type_dwarf_attribute): New function.\n\t* langhooks-def.h (lhd_type_dwarf_attribute): Declare.\n\t(LANG_HOOKS_TYPE_DWARF_ATTRIBUTE): Define.\n\t(LANG_HOOKS_FOR_TYPES_INITIALIZER): Add\n\tLANG_HOOKS_TYPE_DWARF_ATTRIBUTE.\n\t(check_qualified_type, check_aligned_type): Call it.\n\t* dwarf2out.c (modified_type_die): Don't use type_main_variant\n\tfor FUNCTION_TYPE or METHOD_TYPE, instead walk over variants with\n\tcheck_base_type and check_lang_type.\n\t(gen_ptr_to_mbr_type_die): If lookup_type_die is already non-NULL,\n\treturn early.  For pointer-to-data-member add DW_AT_use_location\n\tattribute.\n\t(gen_subroutine_type_die): Add DW_AT_{,rvalue_}reference attribute\n\tif needed.\n\t(gen_type_die_with_usage): Don't use type_main_variant\n\tfor FUNCTION_TYPE or METHOD_TYPE, instead walk over variants with\n\tcheck_base_type and check_lang_type.  Formatting fixes. Call\n\tget_debug_type langhook.\ncp/\n\t* tree.c (cp_check_qualified_type): Use check_base_type and\n\tTYPE_QUALS comparison instead of check_qualified_type.\n\t(cxx_type_hash_eq): Return false if type_memfn_rqual don't match.\n\t* cp-objcp-common.c (cp_get_debug_type): New function.\n\t(cp_decl_dwarf_attribute): Don't handle types here.\n\t(cp_type_dwarf_attribute): New function.\n\t* cp-objcp-common.h (cp_get_debug_type, cp_type_dwarf_attribute):\n\tDeclare.\n\t(LANG_HOOKS_GET_DEBUG_TYPE, LANG_HOOKS_TYPE_DWARF_ATTRIBUTE):\n\tDefine.\ntestsuite/\n\t* g++.dg/debug/dwarf2/ptrdmem-1.C: New test.\n\t* g++.dg/debug/dwarf2/ref-3.C: New test.\n\t* g++.dg/debug/dwarf2/ref-4.C: New test.\n\t* g++.dg/debug/dwarf2/refqual-1.C: New test.\n\t* g++.dg/debug/dwarf2/refqual-2.C: New test.\n\nFrom-SVN: r241832", "tree": {"sha": "cc3fb0f31847cda7c470c5f67f99330aa7943907", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cc3fb0f31847cda7c470c5f67f99330aa7943907"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6905c577d1c41317205f16ea137844f825a9af71", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6905c577d1c41317205f16ea137844f825a9af71", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6905c577d1c41317205f16ea137844f825a9af71", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6905c577d1c41317205f16ea137844f825a9af71/comments", "author": null, "committer": null, "parents": [{"sha": "1906d6b4dc4cf6bddb82e9dc3534438230030a8e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1906d6b4dc4cf6bddb82e9dc3534438230030a8e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1906d6b4dc4cf6bddb82e9dc3534438230030a8e"}], "stats": {"total": 340, "additions": 309, "deletions": 31}, "files": [{"sha": "14486af0c5acfaf36545e9dadfe3dfeda21c3583", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6905c577d1c41317205f16ea137844f825a9af71/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6905c577d1c41317205f16ea137844f825a9af71/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6905c577d1c41317205f16ea137844f825a9af71", "patch": "@@ -1,3 +1,30 @@\n+2016-11-03  Jakub Jelinek  <jakub@redhat.com>\n+\t    Alexandre Oliva  <aoliva@redhat.com>\n+\t    Jason Merrill  <jason@redhat.com>\n+\n+\tPR debug/28767\n+\tPR debug/56974\n+\t* langhooks.h (struct lang_hooks_for_types): Add type_dwarf_attribute\n+\tlanghook.\n+\t* langhooks.c (lhd_type_dwarf_attribute): New function.\n+\t* langhooks-def.h (lhd_type_dwarf_attribute): Declare.\n+\t(LANG_HOOKS_TYPE_DWARF_ATTRIBUTE): Define.\n+\t(LANG_HOOKS_FOR_TYPES_INITIALIZER): Add\n+\tLANG_HOOKS_TYPE_DWARF_ATTRIBUTE.\n+\t(check_qualified_type, check_aligned_type): Call it.\n+\t* dwarf2out.c (modified_type_die): Don't use type_main_variant\n+\tfor FUNCTION_TYPE or METHOD_TYPE, instead walk over variants with\n+\tcheck_base_type and check_lang_type.\n+\t(gen_ptr_to_mbr_type_die): If lookup_type_die is already non-NULL,\n+\treturn early.  For pointer-to-data-member add DW_AT_use_location\n+\tattribute.\n+\t(gen_subroutine_type_die): Add DW_AT_{,rvalue_}reference attribute\n+\tif needed.\n+\t(gen_type_die_with_usage): Don't use type_main_variant\n+\tfor FUNCTION_TYPE or METHOD_TYPE, instead walk over variants with\n+\tcheck_base_type and check_lang_type.  Formatting fixes. Call\n+\tget_debug_type langhook.\n+\n 2016-11-03  Jason Merrill  <jason@redhat.com>\n \n \t* tree.c (check_lang_type): New."}, {"sha": "d20453bb7cec36ad7d306d5b5833fce6b48f14b0", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6905c577d1c41317205f16ea137844f825a9af71/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6905c577d1c41317205f16ea137844f825a9af71/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=6905c577d1c41317205f16ea137844f825a9af71", "patch": "@@ -1,3 +1,20 @@\n+2016-11-03  Jakub Jelinek  <jakub@redhat.com>\n+\t    Alexandre Oliva  <aoliva@redhat.com>\n+\t    Jason Merrill  <jason@redhat.com>\n+\n+\tPR debug/28767\n+\tPR debug/56974\n+\t* tree.c (cp_check_qualified_type): Use check_base_type and\n+\tTYPE_QUALS comparison instead of check_qualified_type.\n+\t(cxx_type_hash_eq): Return false if type_memfn_rqual don't match.\n+\t* cp-objcp-common.c (cp_get_debug_type): New function.\n+\t(cp_decl_dwarf_attribute): Don't handle types here.\n+\t(cp_type_dwarf_attribute): New function.\n+\t* cp-objcp-common.h (cp_get_debug_type, cp_type_dwarf_attribute):\n+\tDeclare.\n+\t(LANG_HOOKS_GET_DEBUG_TYPE, LANG_HOOKS_TYPE_DWARF_ATTRIBUTE):\n+\tDefine.\n+\n 2016-11-03  Jason Merrill  <jason@redhat.com>\n \n \t* tree.c (cp_check_qualified_type): Call check_base_type instead"}, {"sha": "633831ce4b3a822b3c0d32e7a9d221f350164746", "filename": "gcc/cp/cp-objcp-common.c", "status": "modified", "additions": 46, "deletions": 10, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6905c577d1c41317205f16ea137844f825a9af71/gcc%2Fcp%2Fcp-objcp-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6905c577d1c41317205f16ea137844f825a9af71/gcc%2Fcp%2Fcp-objcp-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-objcp-common.c?ref=6905c577d1c41317205f16ea137844f825a9af71", "patch": "@@ -131,6 +131,19 @@ cxx_types_compatible_p (tree x, tree y)\n   return same_type_ignoring_top_level_qualifiers_p (x, y);\n }\n \n+/* Return a type to use in the debug info instead of TYPE, or NULL_TREE to\n+   keep TYPE.  */\n+\n+tree\n+cp_get_debug_type (const_tree type)\n+{\n+  if (TYPE_PTRMEMFUNC_P (type) && !typedef_variant_p (type))\n+    return build_offset_type (TYPE_PTRMEMFUNC_OBJECT_TYPE (type),\n+\t\t\t      TREE_TYPE (TYPE_PTRMEMFUNC_FN_TYPE (type)));\n+\n+  return NULL_TREE;\n+}\n+\n /* Return -1 if dwarf ATTR shouldn't be added for DECL, or the attribute\n    value otherwise.  */\n int\n@@ -179,11 +192,6 @@ cp_decl_dwarf_attribute (const_tree decl, int attr)\n \t  && FUNCTION_REF_QUALIFIED (TREE_TYPE (decl))\n \t  && !FUNCTION_RVALUE_QUALIFIED (TREE_TYPE (decl)))\n \treturn 1;\n-      if ((TREE_CODE (decl) == FUNCTION_TYPE\n-\t   || TREE_CODE (decl) == METHOD_TYPE)\n-\t  && FUNCTION_REF_QUALIFIED (decl)\n-\t  && !FUNCTION_RVALUE_QUALIFIED (decl))\n-\treturn 1;\n       break;\n \n     case DW_AT_rvalue_reference:\n@@ -192,11 +200,6 @@ cp_decl_dwarf_attribute (const_tree decl, int attr)\n \t  && FUNCTION_REF_QUALIFIED (TREE_TYPE (decl))\n \t  && FUNCTION_RVALUE_QUALIFIED (TREE_TYPE (decl)))\n \treturn 1;\n-      if ((TREE_CODE (decl) == FUNCTION_TYPE\n-\t   || TREE_CODE (decl) == METHOD_TYPE)\n-\t  && FUNCTION_REF_QUALIFIED (decl)\n-\t  && FUNCTION_RVALUE_QUALIFIED (decl))\n-\treturn 1;\n       break;\n \n     case DW_AT_inline:\n@@ -216,6 +219,39 @@ cp_decl_dwarf_attribute (const_tree decl, int attr)\n   return -1;\n }\n \n+/* Return -1 if dwarf ATTR shouldn't be added for TYPE, or the attribute\n+   value otherwise.  */\n+int\n+cp_type_dwarf_attribute (const_tree type, int attr)\n+{\n+  if (type == NULL_TREE)\n+    return -1;\n+\n+  switch (attr)\n+    {\n+    case DW_AT_reference:\n+      if ((TREE_CODE (type) == FUNCTION_TYPE\n+\t   || TREE_CODE (type) == METHOD_TYPE)\n+\t  && FUNCTION_REF_QUALIFIED (type)\n+\t  && !FUNCTION_RVALUE_QUALIFIED (type))\n+\treturn 1;\n+      break;\n+\n+    case DW_AT_rvalue_reference:\n+      if ((TREE_CODE (type) == FUNCTION_TYPE\n+\t   || TREE_CODE (type) == METHOD_TYPE)\n+\t  && FUNCTION_REF_QUALIFIED (type)\n+\t  && FUNCTION_RVALUE_QUALIFIED (type))\n+\treturn 1;\n+      break;\n+\n+    default:\n+      break;\n+    }\n+\n+  return -1;\n+}\n+\n /* Stubs to keep c-opts.c happy.  */\n void\n push_file_scope (void)"}, {"sha": "65ac95c2ee1f56ab90925217abfb624cf6393df7", "filename": "gcc/cp/cp-objcp-common.h", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6905c577d1c41317205f16ea137844f825a9af71/gcc%2Fcp%2Fcp-objcp-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6905c577d1c41317205f16ea137844f825a9af71/gcc%2Fcp%2Fcp-objcp-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-objcp-common.h?ref=6905c577d1c41317205f16ea137844f825a9af71", "patch": "@@ -21,12 +21,14 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_CP_OBJCP_COMMON\n #define GCC_CP_OBJCP_COMMON\n \n-/* In cp/cp-lang.c and objcp/objcp-lang.c.  */\n+/* In cp/objcp-common.c, cp/cp-lang.c and objcp/objcp-lang.c.  */\n \n+extern tree cp_get_debug_type (const_tree);\n extern tree objcp_tsubst_copy_and_build (tree, tree, tsubst_flags_t,\n \t\t\t\t\t tree, bool);\n \n extern int cp_decl_dwarf_attribute (const_tree, int);\n+extern int cp_type_dwarf_attribute (const_tree, int);\n extern void cp_common_init_ts (void);\n \n /* Lang hooks that are shared between C++ and ObjC++ are defined here.  Hooks\n@@ -125,12 +127,16 @@ extern void cp_common_init_ts (void);\n #define LANG_HOOKS_REGISTER_BUILTIN_TYPE c_register_builtin_type\n #undef LANG_HOOKS_RECONSTRUCT_COMPLEX_TYPE\n #define LANG_HOOKS_RECONSTRUCT_COMPLEX_TYPE cp_reconstruct_complex_type\n+#undef LANG_HOOKS_GET_DEBUG_TYPE\n+#define LANG_HOOKS_GET_DEBUG_TYPE cp_get_debug_type\n #undef LANG_HOOKS_TO_TARGET_CHARSET\n #define LANG_HOOKS_TO_TARGET_CHARSET c_common_to_target_charset\n #undef LANG_HOOKS_GIMPLIFY_EXPR\n #define LANG_HOOKS_GIMPLIFY_EXPR cp_gimplify_expr\n #undef LANG_HOOKS_DECL_DWARF_ATTRIBUTE\n #define LANG_HOOKS_DECL_DWARF_ATTRIBUTE cp_decl_dwarf_attribute\n+#undef LANG_HOOKS_TYPE_DWARF_ATTRIBUTE\n+#define LANG_HOOKS_TYPE_DWARF_ATTRIBUTE cp_type_dwarf_attribute\n #undef LANG_HOOKS_OMP_PREDETERMINED_SHARING\n #define LANG_HOOKS_OMP_PREDETERMINED_SHARING cxx_omp_predetermined_sharing\n #undef LANG_HOOKS_OMP_CLAUSE_DEFAULT_CTOR"}, {"sha": "1dfff38a8624685c4da1c873460f50aabb9cd9d3", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 67, "deletions": 14, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6905c577d1c41317205f16ea137844f825a9af71/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6905c577d1c41317205f16ea137844f825a9af71/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=6905c577d1c41317205f16ea137844f825a9af71", "patch": "@@ -12573,8 +12573,20 @@ modified_type_die (tree type, int cv_quals, bool reverse,\n \t copy was created to help us keep track of typedef names) and\n \t that copy might have a different TYPE_UID from the original\n \t ..._TYPE node.  */\n-      if (TREE_CODE (type) != VECTOR_TYPE\n-\t  && TREE_CODE (type) != ARRAY_TYPE)\n+      if (TREE_CODE (type) == FUNCTION_TYPE\n+\t  || TREE_CODE (type) == METHOD_TYPE)\n+\t{\n+\t  /* For function/method types, can't just use type_main_variant here,\n+\t     because that can have different ref-qualifiers for C++,\n+\t     but try to canonicalize.  */\n+\t  tree main = TYPE_MAIN_VARIANT (type);\n+\t  for (tree t = main; t; t = TYPE_NEXT_VARIANT (t))\n+\t    if (check_base_type (t, main) && check_lang_type (t, type))\n+\t      return lookup_type_die (t);\n+\t  return lookup_type_die (type);\n+\t}\n+      else if (TREE_CODE (type) != VECTOR_TYPE\n+\t       && TREE_CODE (type) != ARRAY_TYPE)\n \treturn lookup_type_die (type_main_variant (type));\n       else\n \t/* Vectors have the debugging information in the type,\n@@ -23147,20 +23159,31 @@ gen_reference_type_die (tree type, dw_die_ref context_die)\n }\n #endif\n \n-/* Generate a DIE for a pointer to a member type.  */\n+/* Generate a DIE for a pointer to a member type.  TYPE can be an\n+   OFFSET_TYPE, for a pointer to data member, or a RECORD_TYPE, for a\n+   pointer to member function.  */\n \n static void\n gen_ptr_to_mbr_type_die (tree type, dw_die_ref context_die)\n {\n-  dw_die_ref ptr_die\n-    = new_die (DW_TAG_ptr_to_member_type,\n-\t       scope_die_for (type, context_die), type);\n+  if (lookup_type_die (type))\n+    return;\n+\n+  dw_die_ref ptr_die = new_die (DW_TAG_ptr_to_member_type,\n+\t\t\t\tscope_die_for (type, context_die), type);\n \n   equate_type_number_to_die (type, ptr_die);\n   add_AT_die_ref (ptr_die, DW_AT_containing_type,\n \t\t  lookup_type_die (TYPE_OFFSET_BASETYPE (type)));\n   add_type_attribute (ptr_die, TREE_TYPE (type), TYPE_UNQUALIFIED, false,\n \t\t      context_die);\n+\n+  if (TREE_CODE (TREE_TYPE (type)) != FUNCTION_TYPE\n+      && TREE_CODE (TREE_TYPE (type)) != METHOD_TYPE)\n+    {\n+      dw_loc_descr_ref op = new_loc_descr (DW_OP_plus, 0, 0);\n+      add_AT_loc (ptr_die, DW_AT_use_location, op);\n+    }\n }\n \n static char *producer_string;\n@@ -24095,6 +24118,13 @@ gen_subroutine_type_die (tree type, dw_die_ref context_die)\n \n   if (get_AT (subr_die, DW_AT_name))\n     add_pubtype (type, subr_die);\n+  if ((dwarf_version >= 5 || !dwarf_strict)\n+      && lang_hooks.types.type_dwarf_attribute (type, DW_AT_reference) != -1)\n+    add_AT_flag (subr_die, DW_AT_reference, 1);\n+  if ((dwarf_version >= 5 || !dwarf_strict)\n+      && lang_hooks.types.type_dwarf_attribute (type,\n+\t\t\t\t\t\tDW_AT_rvalue_reference) != -1)\n+    add_AT_flag (subr_die, DW_AT_rvalue_reference, 1);\n }\n \n /* Generate a DIE for a type definition.  */\n@@ -24316,13 +24346,36 @@ gen_type_die_with_usage (tree type, dw_die_ref context_die,\n       return;\n     }\n \n+  if (lang_hooks.types.get_debug_type)\n+    {\n+      tree debug_type = lang_hooks.types.get_debug_type (type);\n+\n+      if (debug_type != NULL_TREE && debug_type != type)\n+\t{\n+\t  gen_type_die_with_usage (debug_type, context_die, usage);\n+\t  return;\n+\t}\n+    }\n+\n   /* We are going to output a DIE to represent the unqualified version\n      of this type (i.e. without any const or volatile qualifiers) so\n      get the main variant (i.e. the unqualified version) of this type\n      now.  (Vectors and arrays are special because the debugging info is in the\n-     cloned type itself).  */\n-  if (TREE_CODE (type) != VECTOR_TYPE\n-      && TREE_CODE (type) != ARRAY_TYPE)\n+     cloned type itself.  Similarly function/method types can contain extra\n+     ref-qualification).  */\n+  if (TREE_CODE (type) == FUNCTION_TYPE\n+      || TREE_CODE (type) == METHOD_TYPE)\n+    {\n+      /* For function/method types, can't use type_main_variant here,\n+\t because that can have different ref-qualifiers for C++,\n+\t but try to canonicalize.  */\n+      tree main = TYPE_MAIN_VARIANT (type);\n+      for (tree t = main; t; t = TYPE_NEXT_VARIANT (t))\n+\tif (check_base_type (t, main) && check_lang_type (t, type))\n+\t  type = t;\n+    }\n+  else if (TREE_CODE (type) != VECTOR_TYPE\n+\t   && TREE_CODE (type) != ARRAY_TYPE)\n     type = type_main_variant (type);\n \n   /* If this is an array type with hidden descriptor, handle it first.  */\n@@ -24373,18 +24426,18 @@ gen_type_die_with_usage (tree type, dw_die_ref context_die,\n       /* For these types, all that is required is that we output a DIE (or a\n \t set of DIEs) to represent the \"basis\" type.  */\n       gen_type_die_with_usage (TREE_TYPE (type), context_die,\n-\t\t\t\tDINFO_USAGE_IND_USE);\n+\t\t\t       DINFO_USAGE_IND_USE);\n       break;\n \n     case OFFSET_TYPE:\n       /* This code is used for C++ pointer-to-data-member types.\n \t Output a description of the relevant class type.  */\n       gen_type_die_with_usage (TYPE_OFFSET_BASETYPE (type), context_die,\n-\t\t\t\t\tDINFO_USAGE_IND_USE);\n+\t\t\t       DINFO_USAGE_IND_USE);\n \n       /* Output a description of the type of the object pointed to.  */\n       gen_type_die_with_usage (TREE_TYPE (type), context_die,\n-\t\t\t\t\tDINFO_USAGE_IND_USE);\n+\t\t\t       DINFO_USAGE_IND_USE);\n \n       /* Now output a DIE to represent this pointer-to-data-member type\n \t itself.  */\n@@ -24394,14 +24447,14 @@ gen_type_die_with_usage (tree type, dw_die_ref context_die,\n     case FUNCTION_TYPE:\n       /* Force out return type (in case it wasn't forced out already).  */\n       gen_type_die_with_usage (TREE_TYPE (type), context_die,\n-\t\t\t\t\tDINFO_USAGE_DIR_USE);\n+\t\t\t       DINFO_USAGE_DIR_USE);\n       gen_subroutine_type_die (type, context_die);\n       break;\n \n     case METHOD_TYPE:\n       /* Force out return type (in case it wasn't forced out already).  */\n       gen_type_die_with_usage (TREE_TYPE (type), context_die,\n-\t\t\t\t\tDINFO_USAGE_DIR_USE);\n+\t\t\t       DINFO_USAGE_DIR_USE);\n       gen_subroutine_type_die (type, context_die);\n       break;\n "}, {"sha": "5c330f034b2f977900f0bf6f75898f11d0b0b759", "filename": "gcc/langhooks-def.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6905c577d1c41317205f16ea137844f825a9af71/gcc%2Flanghooks-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6905c577d1c41317205f16ea137844f825a9af71/gcc%2Flanghooks-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks-def.h?ref=6905c577d1c41317205f16ea137844f825a9af71", "patch": "@@ -84,6 +84,7 @@ extern bool lhd_omp_mappable_type (tree);\n extern const char *lhd_get_substring_location (const substring_loc &,\n \t\t\t\t\t       location_t *out_loc);\n extern int lhd_decl_dwarf_attribute (const_tree, int);\n+extern int lhd_type_dwarf_attribute (const_tree, int);\n \n #define LANG_HOOKS_NAME\t\t\t\"GNU unknown\"\n #define LANG_HOOKS_IDENTIFIER_SIZE\tsizeof (struct lang_identifier)\n@@ -186,6 +187,7 @@ extern tree lhd_make_node (enum tree_code);\n #define LANG_HOOKS_ENUM_UNDERLYING_BASE_TYPE lhd_enum_underlying_base_type\n #define LANG_HOOKS_GET_DEBUG_TYPE\tNULL\n #define LANG_HOOKS_GET_FIXED_POINT_TYPE_INFO NULL\n+#define LANG_HOOKS_TYPE_DWARF_ATTRIBUTE\tlhd_type_dwarf_attribute\n \n #define LANG_HOOKS_FOR_TYPES_INITIALIZER { \\\n   LANG_HOOKS_MAKE_TYPE, \\\n@@ -208,7 +210,8 @@ extern tree lhd_make_node (enum tree_code);\n   LANG_HOOKS_RECONSTRUCT_COMPLEX_TYPE, \\\n   LANG_HOOKS_ENUM_UNDERLYING_BASE_TYPE, \\\n   LANG_HOOKS_GET_DEBUG_TYPE, \\\n-  LANG_HOOKS_GET_FIXED_POINT_TYPE_INFO \\\n+  LANG_HOOKS_GET_FIXED_POINT_TYPE_INFO, \\\n+  LANG_HOOKS_TYPE_DWARF_ATTRIBUTE \\\n }\n \n /* Declaration hooks.  */"}, {"sha": "6483dc1c6d693381900106013c76491619e00ec0", "filename": "gcc/langhooks.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6905c577d1c41317205f16ea137844f825a9af71/gcc%2Flanghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6905c577d1c41317205f16ea137844f825a9af71/gcc%2Flanghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.c?ref=6905c577d1c41317205f16ea137844f825a9af71", "patch": "@@ -702,6 +702,15 @@ lhd_decl_dwarf_attribute (const_tree, int)\n   return -1;\n }\n \n+/* Default implementation of LANG_HOOKS_TYPE_DWARF_ATTRIBUTE.  Don't add\n+   any attributes.  */\n+\n+int\n+lhd_type_dwarf_attribute (const_tree, int)\n+{\n+  return -1;\n+}\n+\n /* Returns true if the current lang_hooks represents the GNU C frontend.  */\n \n bool"}, {"sha": "150227c88d02b2b4b55ae6eaa30aea281537d5cd", "filename": "gcc/langhooks.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6905c577d1c41317205f16ea137844f825a9af71/gcc%2Flanghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6905c577d1c41317205f16ea137844f825a9af71/gcc%2Flanghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.h?ref=6905c577d1c41317205f16ea137844f825a9af71", "patch": "@@ -162,6 +162,10 @@ struct lang_hooks_for_types\n      for the debugger about scale factor, etc.  */\n   bool (*get_fixed_point_type_info) (const_tree,\n \t\t\t\t     struct fixed_point_type_info *);\n+\n+  /* Returns -1 if dwarf ATTR shouldn't be added for TYPE, or the attribute\n+     value otherwise.  */\n+  int (*type_dwarf_attribute) (const_tree, int);\n };\n \n /* Language hooks related to decls and the symbol table.  */"}, {"sha": "371f6135cd733738d98c062cbb411de99cc6695d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6905c577d1c41317205f16ea137844f825a9af71/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6905c577d1c41317205f16ea137844f825a9af71/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6905c577d1c41317205f16ea137844f825a9af71", "patch": "@@ -1,10 +1,22 @@\n-2016-11-03  Fritz Reese <fritzoreese@gmail.com>\n+2016-11-03  Jakub Jelinek  <jakub@redhat.com>\n+\t    Alexandre Oliva  <aoliva@redhat.com>\n+\t    Jason Merrill  <jason@redhat.com>\n+\n+\tPR debug/28767\n+\tPR debug/56974\n+\t* g++.dg/debug/dwarf2/ptrdmem-1.C: New test.\n+\t* g++.dg/debug/dwarf2/ref-3.C: New test.\n+\t* g++.dg/debug/dwarf2/ref-4.C: New test.\n+\t* g++.dg/debug/dwarf2/refqual-1.C: New test.\n+\t* g++.dg/debug/dwarf2/refqual-2.C: New test.\n+\n+2016-11-03  Fritz Reese  <fritzoreese@gmail.com>\n \n \t* gfortran.dg/dec_exp_1.f90: New test.\n \t* gfortran.dg/dec_exp_2.f90: Likewise.\n \t* gfortran.dg/dec_exp_3.f90: Likewise.\n \n-2016-11-03  Fritz O. Reese <fritzoreese@gmail.com>\n+2016-11-03  Fritz O. Reese  <fritzoreese@gmail.com>\n \n \t* gfortran.dg/dec_parameter_1.f: New test.\n \t* gfortran.dg/dec_parameter_2.f90: Likewise.\n@@ -45,7 +57,7 @@\n \n \t* gcc.dg/store_merging_8.c: New testcase.\n \n-2016-11-02  Fritz O. Reese <fritzoreese@gmail.com>\n+2016-11-02  Fritz O. Reese  <fritzoreese@gmail.com>\n \n \t* gfortran.dg/warn_argument_mismatch_1.f90: New test.\n \n@@ -272,7 +284,7 @@\n \t* gcc.target/i386/pr34012.c: Add -fno-store-merging to dg-options.\n \t* g++.dg/init/new17.C: Likewise.\n \n-2016-10-26  Will Schmidt <will_schmidt@vnet.ibm.com>\n+2016-10-26  Will Schmidt  <will_schmidt@vnet.ibm.com>\n \n \tPR middle-end/72747\n \t* c-c++-common/pr72747-1.c: New test.\n@@ -348,7 +360,7 @@\n \t* gcc.dg/fold-convmaxconv-1.c: New test.\n \t* gcc.dg/fold-convminconv-1.c: New test.\n \n-2016-10-26  Steven G. Kargl <kargl@gcc.gnu.org>\n+2016-10-26  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \tPR fortran/78092\n \t* gfortran.dg/pr78092.f90: New test.\n@@ -13340,6 +13352,7 @@\n 2016-01-28  Ilya Enkovich  <enkovich.gnu@gmail.com>\n \n \t* gcc.dg/declare-simd.c: New test.\n+\n 2016-01-28  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/69466"}, {"sha": "5d65196f7afa424e9014e620fa7a3e686697b00c", "filename": "gcc/testsuite/g++.dg/debug/dwarf2/ptrdmem-1.C", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6905c577d1c41317205f16ea137844f825a9af71/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdebug%2Fdwarf2%2Fptrdmem-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6905c577d1c41317205f16ea137844f825a9af71/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdebug%2Fdwarf2%2Fptrdmem-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdebug%2Fdwarf2%2Fptrdmem-1.C?ref=6905c577d1c41317205f16ea137844f825a9af71", "patch": "@@ -0,0 +1,9 @@\n+// { dg-do compile }\n+// { dg-options \"-O -std=c++11 -g -dA -gno-strict-dwarf\" }\n+// { dg-final { scan-assembler-times \"DIE \\\\(\\[^\\n\\]*\\\\) DW_TAG_ptr_to_member_type\" 1 { xfail { powerpc-ibm-aix* } } } }\n+// { dg-final { scan-assembler-times \" DW_AT_use_location\" 1 { xfail { powerpc-ibm-aix* } } } }\n+// { dg-final { scan-assembler-not \" DW_AT_reference\" { xfail { powerpc-ibm-aix* } } } }\n+\n+struct S;\n+typedef int S::*pdm;\n+pdm pmf = 0;"}, {"sha": "6294d023d519aee351872b0a212e4b089fbf3cc3", "filename": "gcc/testsuite/g++.dg/debug/dwarf2/ref-3.C", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6905c577d1c41317205f16ea137844f825a9af71/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdebug%2Fdwarf2%2Fref-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6905c577d1c41317205f16ea137844f825a9af71/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdebug%2Fdwarf2%2Fref-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdebug%2Fdwarf2%2Fref-3.C?ref=6905c577d1c41317205f16ea137844f825a9af71", "patch": "@@ -0,0 +1,56 @@\n+// { dg-do compile { target c++11 } }\n+// { dg-options \"-g -gno-strict-dwarf -dA\" }\n+// { dg-final { scan-assembler-times \" DW_AT_reference\" 5 } }\n+// { dg-final { scan-assembler-times \" DW_AT_rvalue_reference\" 5 } }\n+// { dg-final { scan-assembler-times \"DIE \\\\(\\[^\\n\\]*\\\\) DW_TAG_subroutine_type\" 6 } }\n+// { dg-final { scan-assembler-times \"DIE \\\\(\\[^\\n\\]*\\\\) DW_TAG_ptr_to_member_type\" 7 } }\n+// { dg-final { scan-assembler-times \" DW_AT_use_location\" 1 } }\n+\n+struct S\n+{\n+  void foo1 ();\n+  void bar1 () &;\n+  void baz1 () &&;\n+  void foo2 () const;\n+  void bar2 () const &;\n+  void baz2 () const &&;\n+  void foo3 () const;\n+  void bar3 () const &;\n+  void baz3 () const &&;\n+  int d;\n+};\n+\n+void\n+test ()\n+{\n+  S s;\n+  auto o1 = &S::foo1;\n+  auto r1 = &S::bar1;\n+  auto z1 = &S::baz1;\n+  auto o2 = &S::foo2;\n+  auto r2 = &S::bar2;\n+  auto z2 = &S::baz2;\n+  auto o3 = &S::foo3;\n+  auto r3 = &S::bar3;\n+  auto z3 = &S::baz3;\n+  auto d1 = &S::d;\n+  void (S::*o4) () const;\n+  o4 = &S::foo3;\n+  void (S::*r4) () const &;\n+  r4 = &S::bar3;\n+  void (S::*z4) () const &&;\n+  z4 = &S::baz3;\n+  (s.*o1) ();\n+  (s.*r1) ();\n+  (S ().*z1) ();\n+  (s.*o2) ();\n+  (s.*r2) ();\n+  (S ().*z2) ();\n+  (s.*o3) ();\n+  (s.*r3) ();\n+  (S ().*z3) ();\n+  (s.*o4) ();\n+  (s.*r4) ();\n+  (S ().*z4) ();\n+  s.*d1 = 2;\n+}"}, {"sha": "b1fe0e4bce9044858d43c5b82b5e4c57b1189c50", "filename": "gcc/testsuite/g++.dg/debug/dwarf2/ref-4.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6905c577d1c41317205f16ea137844f825a9af71/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdebug%2Fdwarf2%2Fref-4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6905c577d1c41317205f16ea137844f825a9af71/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdebug%2Fdwarf2%2Fref-4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdebug%2Fdwarf2%2Fref-4.C?ref=6905c577d1c41317205f16ea137844f825a9af71", "patch": "@@ -0,0 +1,11 @@\n+// { dg-do compile { target c++11 } }\n+// { dg-options \"-g -gno-strict-dwarf -dA\" }\n+// { dg-final { scan-assembler-times \"DIE \\\\(\\[^\\n\\]*\\\\) DW_TAG_typedef\" 2 } }\n+// { dg-final { scan-assembler-times \"DIE \\\\(\\[^\\n\\]*\\\\) DW_TAG_ptr_to_member_type\" 2 } }\n+// { dg-final { scan-assembler-times \"DIE \\\\(\\[^\\n\\]*\\\\) DW_TAG_subroutine_type\" 1 } }\n+\n+struct A { void foo (); int a; };\n+typedef void (A::*PMF) ();\n+typedef int A::*PMI;\n+PMF pmf;\n+PMI pmi;"}, {"sha": "221008e99817e269e591fc97e249c54ac89536db", "filename": "gcc/testsuite/g++.dg/debug/dwarf2/refqual-1.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6905c577d1c41317205f16ea137844f825a9af71/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdebug%2Fdwarf2%2Frefqual-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6905c577d1c41317205f16ea137844f825a9af71/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdebug%2Fdwarf2%2Frefqual-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdebug%2Fdwarf2%2Frefqual-1.C?ref=6905c577d1c41317205f16ea137844f825a9af71", "patch": "@@ -0,0 +1,17 @@\n+// { dg-do compile }\n+// { dg-options \"-O -std=c++11 -g -dA -gno-strict-dwarf\" }\n+// { dg-final { scan-assembler-times \"DIE \\\\(\\[^\\n\\]*\\\\) DW_TAG_ptr_to_member_type\" 1 { xfail { powerpc-ibm-aix* } } } }\n+// { dg-final { scan-assembler-times \" DW_AT_reference\" 2 { xfail { powerpc-ibm-aix* } } } }\n+// { dg-final { scan-assembler-not \" DW_AT_use_location\" { xfail { powerpc-ibm-aix* } } } }\n+/* It is not clear what if anything we should output for\n+   DW_AT_use_location in a pointer to member function, so we don't\n+   output it for now.  */\n+\n+struct S {\n+  void mf(void) &;\n+};\n+\n+void S::mf() & {}\n+\n+typedef void (S::*pmft)(void) &;\n+pmft pmf = &S::mf;"}, {"sha": "ddf33c1971e5b3d0da225c9d49c85b88c6aade67", "filename": "gcc/testsuite/g++.dg/debug/dwarf2/refqual-2.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6905c577d1c41317205f16ea137844f825a9af71/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdebug%2Fdwarf2%2Frefqual-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6905c577d1c41317205f16ea137844f825a9af71/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdebug%2Fdwarf2%2Frefqual-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdebug%2Fdwarf2%2Frefqual-2.C?ref=6905c577d1c41317205f16ea137844f825a9af71", "patch": "@@ -0,0 +1,17 @@\n+// { dg-do compile }\n+// { dg-options \"-O -std=c++11 -g -dA -gno-strict-dwarf\" }\n+// { dg-final { scan-assembler-times \"DIE \\\\(\\[^\\n\\]*\\\\) DW_TAG_ptr_to_member_type\" 1 { xfail { powerpc-ibm-aix* } } } }\n+// { dg-final { scan-assembler-times \" DW_AT_rvalue_reference\" 2 { xfail { powerpc-ibm-aix* } } } }\n+// { dg-final { scan-assembler-not \" DW_AT_use_location\" { xfail { powerpc-ibm-aix* } } } }\n+/* It is not clear what if anything we should output for\n+   DW_AT_use_location in a pointer to member function, so we don't\n+   output it for now.  */\n+\n+struct S {\n+  void mf(void) &&;\n+};\n+\n+void S::mf() && {}\n+\n+typedef void (S::*pmft)(void) &&;\n+pmft pmf = &S::mf;"}]}