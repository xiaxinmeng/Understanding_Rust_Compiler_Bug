{"sha": "0064f49e76154354fa41c13403cac1da9069093a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDA2NGY0OWU3NjE1NDM1NGZhNDFjMTM0MDNjYWMxZGE5MDY5MDkzYQ==", "commit": {"author": {"name": "Wilco Dijkstra", "email": "wdijkstr@arm.com", "date": "2016-12-07T14:55:31Z"}, "committer": {"name": "Wilco Dijkstra", "email": "wilco@gcc.gnu.org", "date": "2016-12-07T14:55:31Z"}, "message": "GCC caches the whether a function is a leaf in crtl->is_leaf.\n\nGCC caches the whether a function is a leaf in crtl->is_leaf. Using this\nin the backend is best as leaf_function_p may not work correctly (eg. while\nemitting prolog or epilog code).  There are many reads of crtl->is_leaf\nbefore it is initialized.  Many targets do in targetm.frame_pointer_required\n(eg. arm, aarch64, i386, mips, sparc), which is called before register \nallocation by ira_setup_eliminable_regset and sched_init.\n\nAdditionally, SHRINK_WRAPPING_ENABLED calls targetm.have_simple_return,\nwhich evaluates the condition of the simple_return instruction.  On ARM\nthis results in a call to use_simple_return_p which requires crtl->is_leaf\nto be set correctly.\n\nTo fix this, initialize crtl->is_leaf in ira_setup_eliminable_regset and\nearly on in ira.  A bootstrap did not find any uninitialized reads of\ncrtl->is_leaf on Thumb-2.  A follow-up patch will remove incorrect uses\nof leaf_function_p from the ARM backend.\n\n    gcc/\n\t* gcc/ira.c (ira_setup_eliminable_regset): Initialize crtl->is_leaf.\n\t(ira): Move initialization of crtl->is_leaf earlier.\n\nFrom-SVN: r243347", "tree": {"sha": "310218f84b0a695466c72952cfa30dbf18f7f661", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/310218f84b0a695466c72952cfa30dbf18f7f661"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0064f49e76154354fa41c13403cac1da9069093a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0064f49e76154354fa41c13403cac1da9069093a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0064f49e76154354fa41c13403cac1da9069093a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0064f49e76154354fa41c13403cac1da9069093a/comments", "author": null, "committer": null, "parents": [{"sha": "8734dfacbbd841ccf1fb9682a631896013442807", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8734dfacbbd841ccf1fb9682a631896013442807", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8734dfacbbd841ccf1fb9682a631896013442807"}], "stats": {"total": 21, "additions": 16, "deletions": 5}, "files": [{"sha": "5556c78eb06cc6a07a26a249199629cc2de49b57", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0064f49e76154354fa41c13403cac1da9069093a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0064f49e76154354fa41c13403cac1da9069093a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0064f49e76154354fa41c13403cac1da9069093a", "patch": "@@ -1,3 +1,8 @@\n+2016-12-07  Wilco Dijkstra  <wdijkstr@arm.com>\n+\n+\t* gcc/ira.c (ira_setup_eliminable_regset): Initialize crtl->is_leaf.\n+\t(ira): Move initialization of crtl->is_leaf earlier.\n+\n 2016-12-07  Wilco Dijkstra  <wdijkstr@arm.com>\n \n \t* config/aarch64/aarch64.md (movti_aarch64): Change Ump to m."}, {"sha": "4a95e3d22be19e72cf2a6b4223fc455936313757", "filename": "gcc/ira.c", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0064f49e76154354fa41c13403cac1da9069093a/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0064f49e76154354fa41c13403cac1da9069093a/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=0064f49e76154354fa41c13403cac1da9069093a", "patch": "@@ -2266,6 +2266,10 @@ ira_setup_eliminable_regset (void)\n   int i;\n   static const struct {const int from, to; } eliminables[] = ELIMINABLE_REGS;\n \n+  /* Setup is_leaf as frame_pointer_required may use it.  This function\n+     is called by sched_init before ira if scheduling is enabled.  */\n+  crtl->is_leaf = leaf_function_p ();\n+\n   /* FIXME: If EXIT_IGNORE_STACK is set, we will not save and restore\n      sp for alloca.  So we can't eliminate the frame pointer in that\n      case.  At some point, we should improve this by emitting the\n@@ -5079,6 +5083,13 @@ ira (FILE *f)\n \n   clear_bb_flags ();\n \n+  /* Determine if the current function is a leaf before running IRA\n+     since this can impact optimizations done by the prologue and\n+     epilogue thus changing register elimination offsets.\n+     Other target callbacks may use crtl->is_leaf too, including\n+     SHRINK_WRAPPING_ENABLED, so initialize as early as possible.  */\n+  crtl->is_leaf = leaf_function_p ();\n+\n   /* Perform target specific PIC register initialization.  */\n   targetm.init_pic_reg ();\n \n@@ -5164,11 +5175,6 @@ ira (FILE *f)\n   if (warn_clobbered)\n     generate_setjmp_warnings ();\n \n-  /* Determine if the current function is a leaf before running IRA\n-     since this can impact optimizations done by the prologue and\n-     epilogue thus changing register elimination offsets.  */\n-  crtl->is_leaf = leaf_function_p ();\n-\n   if (resize_reg_info () && flag_ira_loop_pressure)\n     ira_set_pseudo_classes (true, ira_dump_file);\n "}]}