{"sha": "5a951baaf1b789281bf62b852d24a4ab8cf3e714", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWE5NTFiYWFmMWI3ODkyODFiZjYyYjg1MmQyNGE0YWI4Y2YzZTcxNA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2018-11-07T15:01:09Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2018-11-07T15:01:09Z"}, "message": "re PR tree-optimization/87914 (gcc fails to vectorize bitreverse code)\n\n2018-11-07  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/87914\n\t* tree-vect-loop.c (vect_is_simple_reduction): Improve detection\n\tof nested cycles.\n\t(vectorizable_reduction): Handle shifts and rotates by dispatching\n\tto vectorizable_shift.\n\t* tree-vect-stmts.c (vect_get_vec_def_for_operand_1): Handle\n\tin-loop uses of vect_nested_cycle defs.  Merge cycle and internal\n\tdef cases.\n\t(vectorizable_shift): Export and handle being called as\n\tvect_nested_cycle.\n\t(vect_analyze_stmt): Call vectorizable_shift after\n\tvectorizable_reduction.\n\t* tree-vectorizer.h (vectorizable_shift): Declare.\n\n\t* lib/target-supports.exp (check_effective_target_vect_var_shift): New.\n\t(check_avx2_available): Likewise.\n\t* g++.dg/vect/pr87914.cc: New testcase.\n\nFrom-SVN: r265876", "tree": {"sha": "0c036e96b195e6e1d15aa5359bf49a3c7372370d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0c036e96b195e6e1d15aa5359bf49a3c7372370d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5a951baaf1b789281bf62b852d24a4ab8cf3e714", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a951baaf1b789281bf62b852d24a4ab8cf3e714", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a951baaf1b789281bf62b852d24a4ab8cf3e714", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a951baaf1b789281bf62b852d24a4ab8cf3e714/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7d3a67d7b0c01c0370226db7840c9ef6e054b56c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d3a67d7b0c01c0370226db7840c9ef6e054b56c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d3a67d7b0c01c0370226db7840c9ef6e054b56c"}], "stats": {"total": 219, "additions": 170, "deletions": 49}, "files": [{"sha": "21ba2ef74971a52c47668c914d54e844f155a3dd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a951baaf1b789281bf62b852d24a4ab8cf3e714/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a951baaf1b789281bf62b852d24a4ab8cf3e714/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5a951baaf1b789281bf62b852d24a4ab8cf3e714", "patch": "@@ -1,3 +1,19 @@\n+2018-11-07  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/87914\n+\t* tree-vect-loop.c (vect_is_simple_reduction): Improve detection\n+\tof nested cycles.\n+\t(vectorizable_reduction): Handle shifts and rotates by dispatching\n+\tto vectorizable_shift.\n+\t* tree-vect-stmts.c (vect_get_vec_def_for_operand_1): Handle\n+\tin-loop uses of vect_nested_cycle defs.  Merge cycle and internal\n+\tdef cases.\n+\t(vectorizable_shift): Export and handle being called as\n+\tvect_nested_cycle.\n+\t(vect_analyze_stmt): Call vectorizable_shift after\n+\tvectorizable_reduction.\n+\t* tree-vectorizer.h (vectorizable_shift): Declare.\n+\n 2018-11-07  Jan Hubicka  <jh@suse.cz>\n \n \t* ipa-devirt.c (odr_types_equivalent_p): Expect constants"}, {"sha": "210ad30b66d0146bf130c57e0c4a399940854cd4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a951baaf1b789281bf62b852d24a4ab8cf3e714/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a951baaf1b789281bf62b852d24a4ab8cf3e714/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5a951baaf1b789281bf62b852d24a4ab8cf3e714", "patch": "@@ -1,3 +1,10 @@\n+2018-11-07  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/87914\n+\t* lib/target-supports.exp (check_effective_target_vect_var_shift): New.\n+\t(check_avx2_available): Likewise.\n+\t* g++.dg/vect/pr87914.cc: New testcase.\n+\n 2018-11-07  Chenghua Xu  <paul.hua.gm@gmail.com>\n \n \t* gcc.target/mips/loongson-ctz.c: Fix typo."}, {"sha": "12fbba3af2fc81f0d82bc1f636b0b65fb29883aa", "filename": "gcc/testsuite/g++.dg/vect/pr87914.cc", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a951baaf1b789281bf62b852d24a4ab8cf3e714/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fpr87914.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a951baaf1b789281bf62b852d24a4ab8cf3e714/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fpr87914.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fpr87914.cc?ref=5a951baaf1b789281bf62b852d24a4ab8cf3e714", "patch": "@@ -0,0 +1,49 @@\n+// { dg-do run }\n+// { dg-additional-options \"-fopenmp-simd\" }\n+// { dg-additional-options \"-mavx2\" { target { avx2_runtime } } }\n+\n+extern \"C\" int memcmp(const void *s1, const void *s2, __SIZE_TYPE__ n);\n+extern \"C\" void abort(void);\n+\n+template <typename T>\n+T reverseBits(T x)\n+{\n+  unsigned int s = sizeof(x) * 8;\n+  T mask = ~T(0);\n+  while ((s >>= 1) > 0)\n+    {\n+      mask ^= (mask << s);\n+      x = ((x >> s) & mask) | ((x << s) & ~mask); // unsupported use in stmt\n+    }\n+  return x;\n+}\n+\n+void __attribute__((noinline,noipa))\n+test_reverseBits(unsigned* x)\n+{\n+#pragma omp simd aligned(x:32)\n+  for (int i = 0; i < 16; ++i)\n+    x[i] = reverseBits(x[i]); // couldn't vectorize loop\n+}\n+\n+int main()\n+{\n+  unsigned arr[16] __attribute__((aligned(32)))\n+    = { 0x01020304, 0x05060708, 0x0a0b0c0d, 0x0e0f1011,\n+        0x11121314, 0x45065708, 0xfa0b3c0du, 0x0e0f1211,\n+        0x21222324, 0x55066708, 0xfa0b2c0du, 0x1e0f1011,\n+        0x31323334, 0x65067708, 0xfa0b5c0du, 0x0e3f1011 };\n+  unsigned arr2[16]\n+    = { 0x20c04080, 0x10e060a0, 0xb030d050, 0x8808f070u,\n+        0x28c84888, 0x10ea60a2, 0xb03cd05f, 0x8848f070u,\n+        0x24c44484, 0x10e660aa, 0xb034d05f, 0x8808f078u, \n+        0x2ccc4c8c, 0x10ee60a6, 0xb03ad05f, 0x8808fc70u };\n+\n+  test_reverseBits (arr);\n+\n+  if (memcmp (arr, arr2, sizeof (arr)) != 0)\n+    abort ();\n+  return 0;\n+}\n+\n+// { dg-final { scan-tree-dump \"OUTER LOOP VECTORIZED\" \"vect\" { target { vect_var_shift && vect_int } } } }"}, {"sha": "c202a083edd27d7e561fd6de2ee5a420eeac0ae5", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a951baaf1b789281bf62b852d24a4ab8cf3e714/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a951baaf1b789281bf62b852d24a4ab8cf3e714/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=5a951baaf1b789281bf62b852d24a4ab8cf3e714", "patch": "@@ -5329,6 +5329,15 @@ proc check_effective_target_vect_shift { } {\n \t\t && [check_effective_target_s390_vx]) }}]\n }\n \n+# Return 1 if the target supports hardware vector shift by register operation.\n+\n+proc check_effective_target_vect_var_shift { } {\n+    return [check_cached_effective_target_indexed vect_var_shift {\n+      expr {(([istarget i?86-*-*] || [istarget x86_64-*-*])\n+\t     && [check_avx2_available])\n+      }}]\n+}\n+\n proc check_effective_target_whole_vector_shift { } {\n     if { [istarget i?86-*-*] || [istarget x86_64-*-*]\n \t || [istarget ia64-*-*]\n@@ -7163,6 +7172,19 @@ proc check_avx_available { } {\n   return 0;\n }\n \n+# Return true if we are compiling for AVX2 target.\n+\n+proc check_avx2_available { } {\n+  if { [check_no_compiler_messages avx_available assembly {\n+    #ifndef __AVX2__\n+    #error unsupported\n+    #endif\n+  } \"\"] } {\n+    return 1;\n+  }\n+  return 0;\n+}\n+\n # Return true if we are compiling for SSSE3 target.\n \n proc check_ssse3_available { } {"}, {"sha": "5ce203b369dce7cb0d6826b82774da2136dbbd3e", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 58, "deletions": 29, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a951baaf1b789281bf62b852d24a4ab8cf3e714/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a951baaf1b789281bf62b852d24a4ab8cf3e714/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=5a951baaf1b789281bf62b852d24a4ab8cf3e714", "patch": "@@ -2843,6 +2843,11 @@ vect_is_simple_reduction (loop_vec_info loop_info, stmt_vec_info phi_info,\n           return NULL;\n         }\n \n+      /* For inner loop reductions in nested vectorization there are no\n+         constraints on the number of uses in the inner loop.  */\n+      if (loop == vect_loop->inner)\n+\tcontinue;\n+\n       nloop_uses++;\n       if (nloop_uses > 1)\n         {\n@@ -2901,13 +2906,19 @@ vect_is_simple_reduction (loop_vec_info loop_info, stmt_vec_info phi_info,\n       else\n \t/* We can have more than one loop-closed PHI.  */\n \tlcphis.safe_push (as_a <gphi *> (use_stmt));\n-      if (nloop_uses > 1)\n-\t{\n-\t  if (dump_enabled_p ())\n-\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t     \"reduction used in loop.\\n\");\n-\t  return NULL;\n-\t}\n+    }\n+\n+  /* If this isn't a nested cycle or if the nested cycle reduction value\n+     is used ouside of the inner loop we cannot handle uses of the reduction\n+     value.  */\n+  bool nested_in_vect_loop = flow_loop_nested_p (vect_loop, loop);\n+  if ((!nested_in_vect_loop || !lcphis.is_empty ())\n+      && nloop_uses > 1)\n+    {\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"reduction used in loop.\\n\");\n+      return NULL;\n     }\n \n   /* If DEF_STMT is a phi node itself, we expect it to have a single argument\n@@ -2968,9 +2979,15 @@ vect_is_simple_reduction (loop_vec_info loop_info, stmt_vec_info phi_info,\n     }\n \n   gassign *def_stmt = as_a <gassign *> (def_stmt_info->stmt);\n-  bool nested_in_vect_loop = flow_loop_nested_p (vect_loop, loop);\n   code = orig_code = gimple_assign_rhs_code (def_stmt);\n \n+  if (nested_in_vect_loop && !check_reduction)\n+    {\n+      if (dump_enabled_p ())\n+\treport_vect_op (MSG_NOTE, def_stmt, \"detected nested cycle: \");\n+      return def_stmt_info;\n+    }\n+\n   /* We can handle \"res -= x[i]\", which is non-associative by\n      simply rewriting this into \"res += -x[i]\".  Avoid changing\n      gimple instruction for the first simple tests and only do this\n@@ -6448,6 +6465,19 @@ vectorizable_reduction (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n   vec_mode = TYPE_MODE (vectype_in);\n   poly_uint64 nunits_out = TYPE_VECTOR_SUBPARTS (vectype_out);\n \n+  if (nested_cycle)\n+    {\n+      def_bb = gimple_bb (reduc_def_phi);\n+      def_stmt_loop = def_bb->loop_father;\n+      def_arg = PHI_ARG_DEF_FROM_EDGE (reduc_def_phi,\n+                                       loop_preheader_edge (def_stmt_loop));\n+      stmt_vec_info def_arg_stmt_info = loop_vinfo->lookup_def (def_arg);\n+      if (def_arg_stmt_info\n+\t  && (STMT_VINFO_DEF_TYPE (def_arg_stmt_info)\n+\t      == vect_double_reduction_def))\n+        double_reduc = true;\n+    }\n+\n   if (code == COND_EXPR)\n     {\n       /* Only call during the analysis stage, otherwise we'll lose\n@@ -6462,20 +6492,26 @@ vectorizable_reduction (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t  return false;\n         }\n     }\n-  else\n+  else if (code == LSHIFT_EXPR || code == RSHIFT_EXPR\n+\t   || code == LROTATE_EXPR || code == RROTATE_EXPR)\n     {\n-      /* 4. Supportable by target?  */\n-\n-      if (code == LSHIFT_EXPR || code == RSHIFT_EXPR\n-\t  || code == LROTATE_EXPR || code == RROTATE_EXPR)\n+      /* Only call during the analysis stage, otherwise we'll lose\n+\t STMT_VINFO_TYPE.  We only support this for nested cycles\n+\t without double reductions at the moment.  */\n+      if (!nested_cycle\n+\t  || double_reduc\n+\t  || (!vec_stmt && !vectorizable_shift (stmt_info, gsi, NULL,\n+\t\t\t\t\t\tNULL, cost_vec)))\n \t{\n-\t  /* Shifts and rotates are only supported by vectorizable_shifts,\n-\t     not vectorizable_reduction.  */\n           if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t     \"unsupported shift or rotation.\\n\");\n+\t\t\t     \"unsupported shift or rotation in reduction\\n\");\n \t  return false;\n \t}\n+    }\n+  else\n+    {\n+      /* 4. Supportable by target?  */\n \n       /* 4.1. check support for the operation in the loop  */\n       optab = optab_for_tree_code (code, vectype_in, optab_default);\n@@ -6580,19 +6616,6 @@ vectorizable_reduction (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \torig_code = cond_reduc_op_code;\n     }\n \n-  if (nested_cycle)\n-    {\n-      def_bb = gimple_bb (reduc_def_phi);\n-      def_stmt_loop = def_bb->loop_father;\n-      def_arg = PHI_ARG_DEF_FROM_EDGE (reduc_def_phi,\n-                                       loop_preheader_edge (def_stmt_loop));\n-      stmt_vec_info def_arg_stmt_info = loop_vinfo->lookup_def (def_arg);\n-      if (def_arg_stmt_info\n-\t  && (STMT_VINFO_DEF_TYPE (def_arg_stmt_info)\n-\t      == vect_double_reduction_def))\n-        double_reduc = true;\n-    }\n-\n   reduc_fn = IFN_LAST;\n \n   if (reduction_type == TREE_CODE_REDUCTION\n@@ -6963,6 +6986,12 @@ vectorizable_reduction (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n           /* Multiple types are not supported for condition.  */\n           break;\n         }\n+      if (code == LSHIFT_EXPR\n+\t  || code == RSHIFT_EXPR)\n+\t{\n+\t  vectorizable_shift (stmt_info, gsi, vec_stmt, slp_node, NULL);\n+\t  break;\n+\t}\n \n       /* Handle uses.  */\n       if (j == 0)"}, {"sha": "8133149b2dce1d354fa8f9bb46553ccb4d291419", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 15, "deletions": 20, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a951baaf1b789281bf62b852d24a4ab8cf3e714/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a951baaf1b789281bf62b852d24a4ab8cf3e714/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=5a951baaf1b789281bf62b852d24a4ab8cf3e714", "patch": "@@ -1461,6 +1461,16 @@ vect_get_vec_def_for_operand_1 (stmt_vec_info def_stmt_info,\n       /* Code should use vect_get_vec_def_for_operand.  */\n       gcc_unreachable ();\n \n+    /* Operand is defined by a loop header phi.  In case of nested\n+       cycles we also may have uses of the backedge def.  */\n+    case vect_reduction_def:\n+    case vect_double_reduction_def:\n+    case vect_nested_cycle:\n+    case vect_induction_def:\n+      gcc_assert (gimple_code (def_stmt_info->stmt) == GIMPLE_PHI\n+\t\t  || dt == vect_nested_cycle);\n+      /* Fallthru.  */\n+\n     /* operand is defined inside the loop.  */\n     case vect_internal_def:\n       {\n@@ -1480,23 +1490,6 @@ vect_get_vec_def_for_operand_1 (stmt_vec_info def_stmt_info,\n \treturn vec_oprnd;\n       }\n \n-    /* operand is defined by a loop header phi.  */\n-    case vect_reduction_def:\n-    case vect_double_reduction_def:\n-    case vect_nested_cycle:\n-    case vect_induction_def:\n-      {\n-\tgcc_assert (gimple_code (def_stmt_info->stmt) == GIMPLE_PHI);\n-\n-\t/* Get the def from the vectorized stmt.  */\n-\tvec_stmt_info = STMT_VINFO_VEC_STMT (def_stmt_info);\n-\tif (gphi *phi = dyn_cast <gphi *> (vec_stmt_info->stmt))\n-\t  vec_oprnd = PHI_RESULT (phi);\n-\telse\n-\t  vec_oprnd = gimple_get_lhs (vec_stmt_info->stmt);\n-\treturn vec_oprnd;\n-      }\n-\n     default:\n       gcc_unreachable ();\n     }\n@@ -5363,7 +5356,7 @@ vect_supportable_shift (enum tree_code code, tree scalar_type)\n    stmt to replace it, put it in VEC_STMT, and insert it at GSI.\n    Return true if STMT_INFO is vectorizable in this way.  */\n \n-static bool\n+bool\n vectorizable_shift (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t\t    stmt_vec_info *vec_stmt, slp_tree slp_node,\n \t\t    stmt_vector_for_cost *cost_vec)\n@@ -5401,6 +5394,7 @@ vectorizable_shift (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n     return false;\n \n   if (STMT_VINFO_DEF_TYPE (stmt_info) != vect_internal_def\n+      && STMT_VINFO_DEF_TYPE (stmt_info) != vect_nested_cycle\n       && ! vec_stmt)\n     return false;\n \n@@ -5480,7 +5474,8 @@ vectorizable_shift (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n      shift/rotate amount is a vector, use the vector/vector shift optabs.  */\n \n   if ((dt[1] == vect_internal_def\n-       || dt[1] == vect_induction_def)\n+       || dt[1] == vect_induction_def\n+       || dt[1] == vect_nested_cycle)\n       && !slp_node)\n     scalar_shift_arg = false;\n   else if (dt[1] == vect_constant_def\n@@ -9540,7 +9535,6 @@ vect_analyze_stmt (stmt_vec_info stmt_info, bool *need_to_vectorize,\n \t  || vectorizable_simd_clone_call (stmt_info, NULL, NULL, node,\n \t\t\t\t\t   cost_vec)\n \t  || vectorizable_conversion (stmt_info, NULL, NULL, node, cost_vec)\n-\t  || vectorizable_shift (stmt_info, NULL, NULL, node, cost_vec)\n \t  || vectorizable_operation (stmt_info, NULL, NULL, node, cost_vec)\n \t  || vectorizable_assignment (stmt_info, NULL, NULL, node, cost_vec)\n \t  || vectorizable_load (stmt_info, NULL, NULL, node, node_instance,\n@@ -9549,6 +9543,7 @@ vect_analyze_stmt (stmt_vec_info stmt_info, bool *need_to_vectorize,\n \t  || vectorizable_reduction (stmt_info, NULL, NULL, node,\n \t\t\t\t     node_instance, cost_vec)\n \t  || vectorizable_induction (stmt_info, NULL, NULL, node, cost_vec)\n+\t  || vectorizable_shift (stmt_info, NULL, NULL, node, cost_vec)\n \t  || vectorizable_condition (stmt_info, NULL, NULL, NULL, 0, node,\n \t\t\t\t     cost_vec)\n \t  || vectorizable_comparison (stmt_info, NULL, NULL, NULL, node,"}, {"sha": "e66f28b364ea641741a5cf382f4032dd3dcd799f", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a951baaf1b789281bf62b852d24a4ab8cf3e714/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a951baaf1b789281bf62b852d24a4ab8cf3e714/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=5a951baaf1b789281bf62b852d24a4ab8cf3e714", "patch": "@@ -1483,6 +1483,9 @@ extern opt_result vect_analyze_stmt (stmt_vec_info, bool *, slp_tree,\n extern bool vectorizable_condition (stmt_vec_info, gimple_stmt_iterator *,\n \t\t\t\t    stmt_vec_info *, tree, int, slp_tree,\n \t\t\t\t    stmt_vector_for_cost *);\n+extern bool vectorizable_shift (stmt_vec_info, gimple_stmt_iterator *,\n+\t\t\t\tstmt_vec_info *, slp_tree,\n+\t\t\t\tstmt_vector_for_cost *);\n extern void vect_get_load_cost (stmt_vec_info, int, bool,\n \t\t\t\tunsigned int *, unsigned int *,\n \t\t\t\tstmt_vector_for_cost *,"}]}