{"sha": "a7553ad60bebc419d510564b8b9f9e5e03725ff5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTc1NTNhZDYwYmViYzQxOWQ1MTA1NjRiOGI5ZjllNWUwMzcyNWZmNQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-01-05T15:16:06Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-01-05T15:16:06Z"}, "message": "store-merging: Handle vector CONSTRUCTORs using bswap [PR96239]\n\nI've tried to add such helper, but handling over just analysis and letting\neach pass handle it differently seems complicated given the limitations of\nthe bswap infrastructure.\n\nSo, this patch just hooks the optimization also into store-merging so that\nthe original testcase from the PR can be fixed.\n\n2021-01-05  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR tree-optimization/96239\n\t* gimple-ssa-store-merging.c (maybe_optimize_vector_constructor): New\n\tfunction.\n\t(get_status_for_store_merging): Don't return BB_INVALID for blocks\n\twith potential bswap optimizable CONSTRUCTORs.\n\t(pass_store_merging::execute): Optimize vector CONSTRUCTORs with bswap\n\tif possible.\n\n\t* gcc.dg/tree-ssa/pr96239.c: New test.", "tree": {"sha": "95629feb493724078551a23567e7dbbb69fc61e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/95629feb493724078551a23567e7dbbb69fc61e3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a7553ad60bebc419d510564b8b9f9e5e03725ff5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7553ad60bebc419d510564b8b9f9e5e03725ff5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7553ad60bebc419d510564b8b9f9e5e03725ff5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7553ad60bebc419d510564b8b9f9e5e03725ff5/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f70289378721d970ea1cfc39a30565f88cedc788", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f70289378721d970ea1cfc39a30565f88cedc788", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f70289378721d970ea1cfc39a30565f88cedc788"}], "stats": {"total": 118, "additions": 115, "deletions": 3}, "files": [{"sha": "4577647cbc61ecfaaf4955a77a459cf7cca99500", "filename": "gcc/gimple-ssa-store-merging.c", "status": "modified", "additions": 97, "deletions": 3, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7553ad60bebc419d510564b8b9f9e5e03725ff5/gcc%2Fgimple-ssa-store-merging.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7553ad60bebc419d510564b8b9f9e5e03725ff5/gcc%2Fgimple-ssa-store-merging.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-store-merging.c?ref=a7553ad60bebc419d510564b8b9f9e5e03725ff5", "patch": "@@ -1257,6 +1257,75 @@ bswap_replace (gimple_stmt_iterator gsi, gimple *ins_stmt, tree fndecl,\n   return tgt;\n }\n \n+/* Try to optimize an assignment CUR_STMT with CONSTRUCTOR on the rhs\n+   using bswap optimizations.  CDI_DOMINATORS need to be\n+   computed on entry.  Return true if it has been optimized and\n+   TODO_update_ssa is needed.  */\n+\n+static bool\n+maybe_optimize_vector_constructor (gimple *cur_stmt)\n+{\n+  tree fndecl = NULL_TREE, bswap_type = NULL_TREE, load_type;\n+  struct symbolic_number n;\n+  bool bswap;\n+\n+  gcc_assert (is_gimple_assign (cur_stmt)\n+\t      && gimple_assign_rhs_code (cur_stmt) == CONSTRUCTOR);\n+\n+  tree rhs = gimple_assign_rhs1 (cur_stmt);\n+  if (!VECTOR_TYPE_P (TREE_TYPE (rhs))\n+      || !INTEGRAL_TYPE_P (TREE_TYPE (TREE_TYPE (rhs)))\n+      || gimple_assign_lhs (cur_stmt) == NULL_TREE)\n+    return false;\n+\n+  HOST_WIDE_INT sz = int_size_in_bytes (TREE_TYPE (rhs)) * BITS_PER_UNIT;\n+  switch (sz)\n+    {\n+    case 16:\n+      load_type = bswap_type = uint16_type_node;\n+      break;\n+    case 32:\n+      if (builtin_decl_explicit_p (BUILT_IN_BSWAP32)\n+\t  && optab_handler (bswap_optab, SImode) != CODE_FOR_nothing)\n+\t{\n+\t  load_type = uint32_type_node;\n+\t  fndecl = builtin_decl_explicit (BUILT_IN_BSWAP32);\n+\t  bswap_type = TREE_VALUE (TYPE_ARG_TYPES (TREE_TYPE (fndecl)));\n+\t}\n+      else\n+\treturn false;\n+      break;\n+    case 64:\n+      if (builtin_decl_explicit_p (BUILT_IN_BSWAP64)\n+\t  && (optab_handler (bswap_optab, DImode) != CODE_FOR_nothing\n+\t      || (word_mode == SImode\n+\t\t  && builtin_decl_explicit_p (BUILT_IN_BSWAP32)\n+\t\t  && optab_handler (bswap_optab, SImode) != CODE_FOR_nothing)))\n+\t{\n+\t  load_type = uint64_type_node;\n+\t  fndecl = builtin_decl_explicit (BUILT_IN_BSWAP64);\n+\t  bswap_type = TREE_VALUE (TYPE_ARG_TYPES (TREE_TYPE (fndecl)));\n+\t}\n+      else\n+\treturn false;\n+      break;\n+    default:\n+      return false;\n+    }\n+\n+  gimple *ins_stmt = find_bswap_or_nop (cur_stmt, &n, &bswap);\n+  if (!ins_stmt || n.range != (unsigned HOST_WIDE_INT) sz)\n+    return false;\n+\n+  if (bswap && !fndecl && n.range != 16)\n+    return false;\n+\n+  memset (&nop_stats, 0, sizeof (nop_stats));\n+  memset (&bswap_stats, 0, sizeof (bswap_stats));\n+  return bswap_replace (gsi_for_stmt (cur_stmt), ins_stmt, fndecl,\n+\t\t\tbswap_type, load_type, &n, bswap) != NULL_TREE;\n+}\n+\n /* Find manual byte swap implementations as well as load in a given\n    endianness. Byte swaps are turned into a bswap builtin invokation\n    while endian loads are converted to bswap builtin invokation or\n@@ -5128,6 +5197,7 @@ static enum basic_block_status\n get_status_for_store_merging (basic_block bb)\n {\n   unsigned int num_statements = 0;\n+  unsigned int num_constructors = 0;\n   gimple_stmt_iterator gsi;\n   edge e;\n \n@@ -5140,9 +5210,27 @@ get_status_for_store_merging (basic_block bb)\n \n       if (store_valid_for_store_merging_p (stmt) && ++num_statements >= 2)\n \tbreak;\n+\n+      if (is_gimple_assign (stmt)\n+\t  && gimple_assign_rhs_code (stmt) == CONSTRUCTOR)\n+\t{\n+\t  tree rhs = gimple_assign_rhs1 (stmt);\n+\t  if (VECTOR_TYPE_P (TREE_TYPE (rhs))\n+\t      && INTEGRAL_TYPE_P (TREE_TYPE (TREE_TYPE (rhs)))\n+\t      && gimple_assign_lhs (stmt) != NULL_TREE)\n+\t    {\n+\t      HOST_WIDE_INT sz\n+\t\t= int_size_in_bytes (TREE_TYPE (rhs)) * BITS_PER_UNIT;\n+\t      if (sz == 16 || sz == 32 || sz == 64)\n+\t\t{\n+\t\t  num_constructors = 1;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n     }\n \n-  if (num_statements == 0)\n+  if (num_statements == 0 && num_constructors == 0)\n     return BB_INVALID;\n \n   if (cfun->can_throw_non_call_exceptions && cfun->eh\n@@ -5151,7 +5239,7 @@ get_status_for_store_merging (basic_block bb)\n       && e->dest == bb->next_bb)\n     return BB_EXTENDED_VALID;\n \n-  return num_statements >= 2 ? BB_VALID : BB_INVALID;\n+  return (num_statements >= 2 || num_constructors) ? BB_VALID : BB_INVALID;\n }\n \n /* Entry point for the pass.  Go over each basic block recording chains of\n@@ -5191,9 +5279,10 @@ pass_store_merging::execute (function *fun)\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tfprintf (dump_file, \"Processing basic block <%d>:\\n\", bb->index);\n \n-      for (gsi = gsi_after_labels (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+      for (gsi = gsi_after_labels (bb); !gsi_end_p (gsi); )\n \t{\n \t  gimple *stmt = gsi_stmt (gsi);\n+\t  gsi_next (&gsi);\n \n \t  if (is_gimple_debug (stmt))\n \t    continue;\n@@ -5209,6 +5298,11 @@ pass_store_merging::execute (function *fun)\n \t      continue;\n \t    }\n \n+\t  if (is_gimple_assign (stmt)\n+\t      && gimple_assign_rhs_code (stmt) == CONSTRUCTOR\n+\t      && maybe_optimize_vector_constructor (stmt))\n+\t    continue;\n+\n \t  if (store_valid_for_store_merging_p (stmt))\n \t    changed |= process_store (stmt);\n \t  else"}, {"sha": "a099fd9ec6ffe1b9acb805ac4297de271edc2356", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr96239.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7553ad60bebc419d510564b8b9f9e5e03725ff5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr96239.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7553ad60bebc419d510564b8b9f9e5e03725ff5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr96239.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr96239.c?ref=a7553ad60bebc419d510564b8b9f9e5e03725ff5", "patch": "@@ -0,0 +1,18 @@\n+/* PR tree-optimization/96239 */\n+/* { dg-do compile { target { ilp32 || lp64 } } } */\n+/* { dg-options \"-O3 -fdump-tree-optimized\" } */\n+/* { dg-final { scan-tree-dump \" r>> 8;\" \"optimized\" { target bswap } } } */\n+\n+union U { unsigned char c[2]; unsigned short s; };\n+\n+unsigned short\n+foo (unsigned short x)\n+{\n+  union U u;\n+  u.s = x;\n+  unsigned char v = u.c[0];\n+  unsigned char w = u.c[1];\n+  u.c[0] = w;\n+  u.c[1] = v;\n+  return u.s;\n+}"}]}