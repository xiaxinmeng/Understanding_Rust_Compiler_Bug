{"sha": "382738969d8f7964a7e03bd3a6c67431c8b865e2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzgyNzM4OTY5ZDhmNzk2NGE3ZTAzYmQzYTZjNjc0MzFjOGI4NjVlMg==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1997-09-16T16:11:13Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1997-09-16T16:11:13Z"}, "message": "More stuff from Uli.\n\nFrom-SVN: r15487", "tree": {"sha": "06e2506d35cf68fbba4bbc8595df41c188e9f512", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/06e2506d35cf68fbba4bbc8595df41c188e9f512"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/382738969d8f7964a7e03bd3a6c67431c8b865e2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/382738969d8f7964a7e03bd3a6c67431c8b865e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/382738969d8f7964a7e03bd3a6c67431c8b865e2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/382738969d8f7964a7e03bd3a6c67431c8b865e2/comments", "author": null, "committer": null, "parents": [{"sha": "e693cc28bbfeb1c1728bec4392505d2eba2b1090", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e693cc28bbfeb1c1728bec4392505d2eba2b1090", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e693cc28bbfeb1c1728bec4392505d2eba2b1090"}], "stats": {"total": 269, "additions": 269, "deletions": 0}, "files": [{"sha": "bbd9792c593af1c37168e163b0d147588ecf4bd0", "filename": "config/mt-linux", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/382738969d8f7964a7e03bd3a6c67431c8b865e2/config%2Fmt-linux", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/382738969d8f7964a7e03bd3a6c67431c8b865e2/config%2Fmt-linux", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/config%2Fmt-linux?ref=382738969d8f7964a7e03bd3a6c67431c8b865e2", "patch": "@@ -0,0 +1,2 @@\n+# When using glibc 2 on Linux we must always use vtable thunks.\n+  CXXFLAGS=-O2 -g -fvtable-thunks"}, {"sha": "ffda17208399045c9df853d84d85bd338abf542f", "filename": "libio/config/linuxlibc1.mt", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/382738969d8f7964a7e03bd3a6c67431c8b865e2/libio%2Fconfig%2Flinuxlibc1.mt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/382738969d8f7964a7e03bd3a6c67431c8b865e2/libio%2Fconfig%2Flinuxlibc1.mt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fconfig%2Flinuxlibc1.mt?ref=382738969d8f7964a7e03bd3a6c67431c8b865e2", "patch": "@@ -0,0 +1,26 @@\n+# Since the Linux C library has libio, we have to be very careful.\n+\n+# By default, we build libio and use it.  If someone wants to not\n+# build it, let them go to extra work.  The reason is that the user\n+# may want a newer, bug fixed libio, also on a linux 1.0.8 system\n+# things just won't build with the bottom section uncommented.\n+\n+# Comment this out to avoid including the stdio functions in libiostream.a:\n+LIBIOSTREAM_OBJECTS = $(IO_OBJECTS) $(IOSTREAM_OBJECTS) $(STDIO_WRAP_OBJECTS) $(OSPRIM_OBJECTS)\n+LIBIOSTREAM_DEP = $(LIBIOSTREAM_OBJECTS) stmp-stdio\n+LIBIOSTREAM_USE = $(LIBIOSTREAM_OBJECTS) `cat stdio.list`\n+\n+# Comment the above and uncomment the below to use the code in the Linux libc:\n+# We have _G_config.h in /usr/include.\n+# _G_CONFIG_H=\n+\n+# We have those in libc.a.\n+# IO_OBJECTS=\n+# STDIO_WRAP_OBJECTS=\n+# OSPRIM_OBJECTS=\n+\n+# We have the rest in /usr/include.\n+# USER_INCLUDES=PlotFile.h SFile.h builtinbuf.h editbuf.h fstream.h \\\n+# \tindstream.h iomanip.h iostream.h istream.h ostream.h \\\n+# \tparsestream.h pfstream.h procbuf.h stdiostream.h stream.h \\\n+# \tstreambuf.h strfile.h strstream.h"}, {"sha": "6b959e455a8d89df3f71d37a64f544611081bd3c", "filename": "libio/stdio/obprintf.c", "status": "added", "additions": 168, "deletions": 0, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/382738969d8f7964a7e03bd3a6c67431c8b865e2/libio%2Fstdio%2Fobprintf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/382738969d8f7964a7e03bd3a6c67431c8b865e2/libio%2Fstdio%2Fobprintf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fstdio%2Fobprintf.c?ref=382738969d8f7964a7e03bd3a6c67431c8b865e2", "patch": "@@ -0,0 +1,168 @@\n+/* Print output of stream to given obstack.\n+   Copyright (C) 1996, 1997 Free Software Foundation, Inc.\n+   This file is part of the GNU C Library.\n+   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1996.\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Library General Public License as\n+   published by the Free Software Foundation; either version 2 of the\n+   License, or (at your option) any later version.\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Library General Public License for more details.\n+\n+   You should have received a copy of the GNU Library General Public\n+   License along with the GNU C Library; see the file COPYING.LIB.  If not,\n+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n+   Boston, MA 02111-1307, USA.  */\n+\n+\n+#ifdef __STDC__\n+#include <stdlib.h>\n+#endif\n+#include \"libioP.h\"\n+#include <string.h>\n+#include <errno.h>\n+#include <obstack.h>\n+#include <stdarg.h>\n+\n+\n+struct _IO_obstack_file\n+{\n+  struct _IO_FILE file;\n+  const void *vtable;\n+  struct obstack *obstack;\n+};\n+\n+\n+static int\n+_IO_obstack_overflow (_IO_FILE *fp, int c)\n+{\n+  struct obstack *obstack = ((struct _IO_obstack_file *) fp)->obstack;\n+\n+  /* Make room for another character.  This might as well allocate a\n+     new chunk a memory and moves the old contents over.  */\n+  if (c != EOF)\n+    obstack_1grow (obstack, c);\n+\n+  /* Setup the buffer pointers again.  */\n+  fp->_IO_write_base = obstack_base (obstack);\n+  fp->_IO_write_ptr = obstack_next_free (obstack);\n+  fp->_IO_write_end = fp->_IO_write_base + obstack_room (obstack);\n+  /* Now allocate the rest of the current chunk.  */\n+  obstack_blank_fast (obstack, fp->_IO_write_end - fp->_IO_write_ptr);\n+\n+  return c;\n+}\n+\n+\n+static _IO_size_t\n+_IO_obstack_xsputn (_IO_FILE *fp, const void *data, _IO_size_t n)\n+{\n+  struct obstack *obstack = ((struct _IO_obstack_file *) fp)->obstack;\n+\n+  if (fp->_IO_write_ptr + n > fp->_IO_write_end)\n+    {\n+      /* We need some more memory.  First shrink the buffer to the\n+\t space we really currently need.  */\n+      obstack_blank (obstack, fp->_IO_write_ptr - fp->_IO_write_end);\n+\n+      /* Now grow for N bytes.  */\n+      obstack_blank (obstack, n);\n+\n+      /* Setup the buffer pointers again.  */\n+      fp->_IO_write_base = obstack_base (obstack);\n+      fp->_IO_write_ptr = obstack_next_free (obstack);\n+      fp->_IO_write_end = (fp->_IO_write_base + obstack_room (obstack));\n+      /* Now allocate the rest of the current chunk.  */\n+      obstack_blank_fast (obstack, fp->_IO_write_end - fp->_IO_write_ptr);\n+    }\n+  else\n+    {\n+      memcpy (fp->_IO_write_ptr, data, n);\n+      fp->_IO_write_ptr += n;\n+    }\n+\n+  return n;\n+}\n+\n+\n+/* the jump table.  */\n+static struct _IO_jump_t _IO_obstack_jumps =\n+{\n+  JUMP_INIT_DUMMY,\n+  JUMP_INIT(finish, NULL),\n+  JUMP_INIT(overflow, _IO_obstack_overflow),\n+  JUMP_INIT(underflow, NULL),\n+  JUMP_INIT(uflow, NULL),\n+  JUMP_INIT(pbackfail, NULL),\n+  JUMP_INIT(xsputn, _IO_obstack_xsputn),\n+  JUMP_INIT(xsgetn, NULL),\n+  JUMP_INIT(seekoff, NULL),\n+  JUMP_INIT(seekpos, NULL),\n+  JUMP_INIT(setbuf, NULL),\n+  JUMP_INIT(sync, NULL),\n+  JUMP_INIT(doallocate, NULL),\n+  JUMP_INIT(read, NULL),\n+  JUMP_INIT(write, NULL),\n+  JUMP_INIT(seek, NULL),\n+  JUMP_INIT(close, NULL),\n+  JUMP_INIT(stat, NULL)\n+};\n+\n+\n+int\n+_IO_obstack_vprintf (struct obstack *obstack, const char *format, va_list args)\n+{\n+  struct obstack_FILE\n+    {\n+      struct _IO_obstack_file ofile;\n+#ifdef _IO_MTSAFE_IO\n+      _IO_lock_t lock;\n+#endif\n+  } new_f;\n+  int result;\n+\n+#ifdef _IO_MTSAFE_IO\n+  new_f.ofile.file._lock = &new_f.lock;\n+#endif\n+\n+  _IO_init ((_IO_FILE *) &new_f.ofile, 0);\n+  _IO_JUMPS (&new_f.ofile.file) = &_IO_obstack_jumps;\n+  _IO_str_init_static (&new_f.ofile.file, obstack_base (obstack),\n+\t\t       (obstack_object_size (obstack) +\n+\t\t\tobstack_room (obstack)), obstack_next_free (obstack));\n+  /* Now allocate the rest of the current chunk.  */\n+  obstack_blank_fast (obstack,\n+\t\t      (new_f.ofile.file._IO_write_end\n+\t\t       - new_f.ofile.file._IO_write_ptr));\n+  new_f.ofile.obstack = obstack;\n+\n+  result = _IO_vfprintf ((_IO_FILE *) &new_f, format, args);\n+\n+  /* Shrink the buffer to the space we really currently need.  */\n+  obstack_blank (obstack, (new_f.ofile.file._IO_write_ptr\n+\t\t\t   - new_f.ofile.file._IO_write_end));\n+\n+  return result;\n+}\n+#ifdef weak_alias\n+weak_alias (_IO_obstack_vprintf, obstack_vprintf)\n+#endif\n+\n+\n+int\n+_IO_obstack_printf (struct obstack *obstack, const char *format, ...)\n+{\n+  int result;\n+  va_list ap;\n+  va_start (ap, format);\n+  result = _IO_obstack_vprintf (obstack, format, ap);\n+  va_end (ap);\n+  return result;\n+}\n+#ifdef weak_alias\n+weak_alias (_IO_obstack_printf, obstack_printf)\n+#endif"}, {"sha": "15513d0fca7dc73592b6fe3dbac419fa01035cf9", "filename": "libio/stdio/vasprintf.c", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/382738969d8f7964a7e03bd3a6c67431c8b865e2/libio%2Fstdio%2Fvasprintf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/382738969d8f7964a7e03bd3a6c67431c8b865e2/libio%2Fstdio%2Fvasprintf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libio%2Fstdio%2Fvasprintf.c?ref=382738969d8f7964a7e03bd3a6c67431c8b865e2", "patch": "@@ -0,0 +1,72 @@\n+/* Copyright (C) 1995, 1997 Free Software Foundation, Inc.\n+   This file is part of the GNU IO Library.\n+\n+   This library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU General Public License as\n+   published by the Free Software Foundation; either version 2, or (at\n+   your option) any later version.\n+\n+   This library is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this library; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+   MA 02111-1307, USA.\n+\n+   As a special exception, if you link this library with files\n+   compiled with a GNU compiler to produce an executable, this does\n+   not cause the resulting executable to be covered by the GNU General\n+   Public License.  This exception does not however invalidate any\n+   other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n+\n+#include <malloc.h>\n+#include \"libioP.h\"\n+#include \"stdio.h\"\n+#include \"strfile.h\"\n+\n+int\n+_IO_vasprintf (result_ptr, format, args)\n+     char **result_ptr;\n+     const char *format;\n+     _IO_va_list args;\n+{\n+  /* Initial size of the buffer to be used.  Will be doubled each time an\n+     overflow occurs.  */\n+  const _IO_size_t init_string_size = 100;\n+  char *string;\n+  _IO_strfile sf;\n+#ifdef _IO_MTSAFE_IO\n+  _IO_lock_t lock;\n+#endif\n+  int ret;\n+  string = (char *) malloc (init_string_size);\n+  if (string == NULL)\n+    return -1;\n+#ifdef _IO_MTSAFE_IO\n+  sf._sbf._f._lock = &lock;\n+#endif\n+  _IO_init ((_IO_FILE *) &sf, 0);\n+  _IO_JUMPS ((_IO_FILE *) &sf) = &_IO_str_jumps;\n+  _IO_str_init_static ((_IO_FILE *) &sf, string, init_string_size, string);\n+  sf._sbf._f._flags &= ~_IO_USER_BUF;\n+  sf._s._allocate_buffer = (_IO_alloc_type) malloc;\n+  sf._s._free_buffer = (_IO_free_type) free;\n+  ret = _IO_vfprintf ((_IO_FILE *) &sf, format, args);\n+  if (ret < 0)\n+    return ret;\n+  *result_ptr = (char *) realloc (sf._sbf._f._IO_buf_base,\n+\t\t\t\t  (sf._sbf._f._IO_write_ptr\n+\t\t\t\t   - sf._sbf._f._IO_write_base) +1);\n+  if (*result_ptr == NULL)\n+    *result_ptr = sf._sbf._f._IO_buf_base;\n+  (*result_ptr)[sf._sbf._f._IO_write_ptr-sf._sbf._f._IO_write_base] = '\\0';\n+  return ret;\n+}\n+\n+#ifdef weak_alias\n+weak_alias (_IO_vasprintf, vasprintf)\n+#endif"}, {"sha": "6afe1e514d93f3401e2ce6d283662a5403a2f730", "filename": "libstdc++/config/linux.mt", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/382738969d8f7964a7e03bd3a6c67431c8b865e2/libstdc%2B%2B%2Fconfig%2Flinux.mt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/382738969d8f7964a7e03bd3a6c67431c8b865e2/libstdc%2B%2B%2Fconfig%2Flinux.mt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fconfig%2Flinux.mt?ref=382738969d8f7964a7e03bd3a6c67431c8b865e2", "patch": "@@ -0,0 +1 @@\n+MT_CFLAGS = -D_PTHREADS"}]}