{"sha": "ebc1b29edb3428dd18e76cba8626625bfb184f1d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWJjMWIyOWVkYjM0MjhkZDE4ZTc2Y2JhODYyNjYyNWJmYjE4NGYxZA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2016-05-11T10:24:11Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2016-05-11T10:24:11Z"}, "message": "re PR middle-end/71002 (-fstrict-aliasing breaks Boost's short string optimization implementation)\n\n2016-05-11  Richard Biener  <rguenther@suse.de>\n\n\tPR middle-end/71002\n\t* alias.c (reference_alias_ptr_type): Preserve alias-set zero\n\tif the langhook insists on it.\n\t* fold-const.c (make_bit_field_ref): Add arg for the original\n\treference and preserve its alias-set.\n\t(decode_field_reference): Take exp by reference and adjust it\n\tto the original memory reference.\n\t(optimize_bit_field_compare): Adjust callers.\n\t(fold_truth_andor_1): Likewise.\n\t* gimplify.c (gimplify_expr): Adjust in-SSA form test.\n\n\t* g++.dg/torture/pr71002.C: New testcase.\n\nFrom-SVN: r236117", "tree": {"sha": "c56af27e777a33142ec5005ae7600ac16297fad4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c56af27e777a33142ec5005ae7600ac16297fad4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ebc1b29edb3428dd18e76cba8626625bfb184f1d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebc1b29edb3428dd18e76cba8626625bfb184f1d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ebc1b29edb3428dd18e76cba8626625bfb184f1d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebc1b29edb3428dd18e76cba8626625bfb184f1d/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "98ccd1d7ab1d9a0c99cce0d1c05ddcda3659dd26", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98ccd1d7ab1d9a0c99cce0d1c05ddcda3659dd26", "html_url": "https://github.com/Rust-GCC/gccrs/commit/98ccd1d7ab1d9a0c99cce0d1c05ddcda3659dd26"}], "stats": {"total": 236, "additions": 213, "deletions": 23}, "files": [{"sha": "ffef84e9844e4f821576ef6a70563e038a6e9f6b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebc1b29edb3428dd18e76cba8626625bfb184f1d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebc1b29edb3428dd18e76cba8626625bfb184f1d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ebc1b29edb3428dd18e76cba8626625bfb184f1d", "patch": "@@ -1,3 +1,16 @@\n+2016-05-11  Richard Biener  <rguenther@suse.de>\n+\n+\tPR middle-end/71002\n+\t* alias.c (reference_alias_ptr_type): Preserve alias-set zero\n+\tif the langhook insists on it.\n+\t* fold-const.c (make_bit_field_ref): Add arg for the original\n+\treference and preserve its alias-set.\n+\t(decode_field_reference): Take exp by reference and adjust it\n+\tto the original memory reference.\n+\t(optimize_bit_field_compare): Adjust callers.\n+\t(fold_truth_andor_1): Likewise.\n+\t* gimplify.c (gimplify_expr): Adjust in-SSA form test.\n+\n 2016-05-11  Ilya Enkovich  <ilya.enkovich@intel.com>\n \n \tPR middle-end/70807"}, {"sha": "1e4c4d19e69a35cfffd0a92fe529f9e74845959f", "filename": "gcc/alias.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebc1b29edb3428dd18e76cba8626625bfb184f1d/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebc1b29edb3428dd18e76cba8626625bfb184f1d/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=ebc1b29edb3428dd18e76cba8626625bfb184f1d", "patch": "@@ -769,6 +769,10 @@ reference_alias_ptr_type_1 (tree *t)\n tree\n reference_alias_ptr_type (tree t)\n {\n+  /* If the frontend assigns this alias-set zero, preserve that.  */\n+  if (lang_hooks.get_alias_set (t) == 0)\n+    return ptr_type_node;\n+\n   tree ptype = reference_alias_ptr_type_1 (&t);\n   /* If there is a given pointer type for aliasing purposes, return it.  */\n   if (ptype != NULL_TREE)"}, {"sha": "c4346de9750fa5cacc181bdfc769911b89a5a674", "filename": "gcc/fold-const.c", "status": "modified", "additions": 30, "deletions": 22, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebc1b29edb3428dd18e76cba8626625bfb184f1d/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebc1b29edb3428dd18e76cba8626625bfb184f1d/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=ebc1b29edb3428dd18e76cba8626625bfb184f1d", "patch": "@@ -117,14 +117,8 @@ static enum tree_code compcode_to_comparison (enum comparison_code);\n static int operand_equal_for_comparison_p (tree, tree, tree);\n static int twoval_comparison_p (tree, tree *, tree *, int *);\n static tree eval_subst (location_t, tree, tree, tree, tree, tree);\n-static tree make_bit_field_ref (location_t, tree, tree,\n-\t\t\t\tHOST_WIDE_INT, HOST_WIDE_INT, int, int);\n static tree optimize_bit_field_compare (location_t, enum tree_code,\n \t\t\t\t\ttree, tree, tree);\n-static tree decode_field_reference (location_t, tree, HOST_WIDE_INT *,\n-\t\t\t\t    HOST_WIDE_INT *,\n-\t\t\t\t    machine_mode *, int *, int *, int *,\n-\t\t\t\t    tree *, tree *);\n static int simple_operand_p (const_tree);\n static bool simple_operand_p_2 (tree);\n static tree range_binop (enum tree_code, tree, tree, int, tree, int);\n@@ -3803,15 +3797,23 @@ distribute_real_division (location_t loc, enum tree_code code, tree type,\n \f\n /* Return a BIT_FIELD_REF of type TYPE to refer to BITSIZE bits of INNER\n    starting at BITPOS.  The field is unsigned if UNSIGNEDP is nonzero\n-   and uses reverse storage order if REVERSEP is nonzero.  */\n+   and uses reverse storage order if REVERSEP is nonzero.  ORIG_INNER\n+   is the original memory reference used to preserve the alias set of\n+   the access.  */\n \n static tree\n-make_bit_field_ref (location_t loc, tree inner, tree type,\n+make_bit_field_ref (location_t loc, tree inner, tree orig_inner, tree type,\n \t\t    HOST_WIDE_INT bitsize, HOST_WIDE_INT bitpos,\n \t\t    int unsignedp, int reversep)\n {\n   tree result, bftype;\n \n+  if (get_alias_set (inner) != get_alias_set (orig_inner))\n+    inner = fold_build2 (MEM_REF, TREE_TYPE (inner),\n+\t\t\t build_fold_addr_expr (inner),\n+\t\t\t build_int_cst\n+\t\t\t  (reference_alias_ptr_type (orig_inner), 0));\n+\n   if (bitpos == 0 && !reversep)\n     {\n       tree size = TYPE_SIZE (TREE_TYPE (inner));\n@@ -3937,13 +3939,13 @@ optimize_bit_field_compare (location_t loc, enum tree_code code,\n        and return.  */\n     return fold_build2_loc (loc, code, compare_type,\n \t\t\tfold_build2_loc (loc, BIT_AND_EXPR, unsigned_type,\n-\t\t\t\t     make_bit_field_ref (loc, linner,\n+\t\t\t\t     make_bit_field_ref (loc, linner, lhs,\n \t\t\t\t\t\t\t unsigned_type,\n \t\t\t\t\t\t\t nbitsize, nbitpos,\n \t\t\t\t\t\t\t 1, lreversep),\n \t\t\t\t     mask),\n \t\t\tfold_build2_loc (loc, BIT_AND_EXPR, unsigned_type,\n-\t\t\t\t     make_bit_field_ref (loc, rinner,\n+\t\t\t\t     make_bit_field_ref (loc, rinner, rhs,\n \t\t\t\t\t\t\t unsigned_type,\n \t\t\t\t\t\t\t nbitsize, nbitpos,\n \t\t\t\t\t\t\t 1, rreversep),\n@@ -3988,8 +3990,8 @@ optimize_bit_field_compare (location_t loc, enum tree_code code,\n   /* Make a new bitfield reference, shift the constant over the\n      appropriate number of bits and mask it with the computed mask\n      (in case this was a signed field).  If we changed it, make a new one.  */\n-  lhs = make_bit_field_ref (loc, linner, unsigned_type, nbitsize, nbitpos, 1,\n-\t\t\t    lreversep);\n+  lhs = make_bit_field_ref (loc, linner, lhs, unsigned_type,\n+\t\t\t    nbitsize, nbitpos, 1, lreversep);\n \n   rhs = const_binop (BIT_AND_EXPR,\n \t\t     const_binop (LSHIFT_EXPR,\n@@ -4028,11 +4030,12 @@ optimize_bit_field_compare (location_t loc, enum tree_code code,\n    do anything with.  */\n \n static tree\n-decode_field_reference (location_t loc, tree exp, HOST_WIDE_INT *pbitsize,\n+decode_field_reference (location_t loc, tree *exp_, HOST_WIDE_INT *pbitsize,\n \t\t\tHOST_WIDE_INT *pbitpos, machine_mode *pmode,\n \t\t\tint *punsignedp, int *preversep, int *pvolatilep,\n \t\t\ttree *pmask, tree *pand_mask)\n {\n+  tree exp = *exp_;\n   tree outer_type = 0;\n   tree and_mask = 0;\n   tree mask, inner, offset;\n@@ -4069,6 +4072,8 @@ decode_field_reference (location_t loc, tree exp, HOST_WIDE_INT *pbitsize,\n       || TREE_CODE (inner) == PLACEHOLDER_EXPR)\n     return 0;\n \n+  *exp_ = exp;\n+\n   /* If the number of bits in the reference is the same as the bitsize of\n      the outer type, then the outer type gives the signedness. Otherwise\n      (in case of a small bitfield) the signedness is unchanged.  */\n@@ -5677,19 +5682,19 @@ fold_truth_andor_1 (location_t loc, enum tree_code code, tree truth_type,\n \n   ll_reversep = lr_reversep = rl_reversep = rr_reversep = 0;\n   volatilep = 0;\n-  ll_inner = decode_field_reference (loc, ll_arg,\n+  ll_inner = decode_field_reference (loc, &ll_arg,\n \t\t\t\t     &ll_bitsize, &ll_bitpos, &ll_mode,\n \t\t\t\t     &ll_unsignedp, &ll_reversep, &volatilep,\n \t\t\t\t     &ll_mask, &ll_and_mask);\n-  lr_inner = decode_field_reference (loc, lr_arg,\n+  lr_inner = decode_field_reference (loc, &lr_arg,\n \t\t\t\t     &lr_bitsize, &lr_bitpos, &lr_mode,\n \t\t\t\t     &lr_unsignedp, &lr_reversep, &volatilep,\n \t\t\t\t     &lr_mask, &lr_and_mask);\n-  rl_inner = decode_field_reference (loc, rl_arg,\n+  rl_inner = decode_field_reference (loc, &rl_arg,\n \t\t\t\t     &rl_bitsize, &rl_bitpos, &rl_mode,\n \t\t\t\t     &rl_unsignedp, &rl_reversep, &volatilep,\n \t\t\t\t     &rl_mask, &rl_and_mask);\n-  rr_inner = decode_field_reference (loc, rr_arg,\n+  rr_inner = decode_field_reference (loc, &rr_arg,\n \t\t\t\t     &rr_bitsize, &rr_bitpos, &rr_mode,\n \t\t\t\t     &rr_unsignedp, &rr_reversep, &volatilep,\n \t\t\t\t     &rr_mask, &rr_and_mask);\n@@ -5851,12 +5856,14 @@ fold_truth_andor_1 (location_t loc, enum tree_code code, tree truth_type,\n       lr_mask = const_binop (BIT_IOR_EXPR, lr_mask, rr_mask);\n       if (lnbitsize == rnbitsize && xll_bitpos == xlr_bitpos)\n \t{\n-\t  lhs = make_bit_field_ref (loc, ll_inner, lntype, lnbitsize, lnbitpos,\n+\t  lhs = make_bit_field_ref (loc, ll_inner, ll_arg,\n+\t\t\t\t    lntype, lnbitsize, lnbitpos,\n \t\t\t\t    ll_unsignedp || rl_unsignedp, ll_reversep);\n \t  if (! all_ones_mask_p (ll_mask, lnbitsize))\n \t    lhs = build2 (BIT_AND_EXPR, lntype, lhs, ll_mask);\n \n-\t  rhs = make_bit_field_ref (loc, lr_inner, rntype, rnbitsize, rnbitpos,\n+\t  rhs = make_bit_field_ref (loc, lr_inner, lr_arg,\n+\t\t\t\t    rntype, rnbitsize, rnbitpos,\n \t\t\t\t    lr_unsignedp || rr_unsignedp, lr_reversep);\n \t  if (! all_ones_mask_p (lr_mask, rnbitsize))\n \t    rhs = build2 (BIT_AND_EXPR, rntype, rhs, lr_mask);\n@@ -5878,11 +5885,11 @@ fold_truth_andor_1 (location_t loc, enum tree_code code, tree truth_type,\n \t{\n \t  tree type;\n \n-\t  lhs = make_bit_field_ref (loc, ll_inner, lntype,\n+\t  lhs = make_bit_field_ref (loc, ll_inner, ll_arg, lntype,\n \t\t\t\t    ll_bitsize + rl_bitsize,\n \t\t\t\t    MIN (ll_bitpos, rl_bitpos),\n \t\t\t\t    ll_unsignedp, ll_reversep);\n-\t  rhs = make_bit_field_ref (loc, lr_inner, rntype,\n+\t  rhs = make_bit_field_ref (loc, lr_inner, lr_arg, rntype,\n \t\t\t\t    lr_bitsize + rr_bitsize,\n \t\t\t\t    MIN (lr_bitpos, rr_bitpos),\n \t\t\t\t    lr_unsignedp, lr_reversep);\n@@ -5947,7 +5954,8 @@ fold_truth_andor_1 (location_t loc, enum tree_code code, tree truth_type,\n      reference we will make.  Unless the mask is all ones the width of\n      that field, perform the mask operation.  Then compare with the\n      merged constant.  */\n-  result = make_bit_field_ref (loc, ll_inner, lntype, lnbitsize, lnbitpos,\n+  result = make_bit_field_ref (loc, ll_inner, ll_arg,\n+\t\t\t       lntype, lnbitsize, lnbitpos,\n \t\t\t       ll_unsignedp || rl_unsignedp, ll_reversep);\n \n   ll_mask = const_binop (BIT_IOR_EXPR, ll_mask, rl_mask);"}, {"sha": "c433a84a854566d9f73e67cb9943aa5bf82bc885", "filename": "gcc/gimplify.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebc1b29edb3428dd18e76cba8626625bfb184f1d/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebc1b29edb3428dd18e76cba8626625bfb184f1d/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=ebc1b29edb3428dd18e76cba8626625bfb184f1d", "patch": "@@ -10452,7 +10452,7 @@ gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \t     in suitable form.  Re-gimplifying would mark the address\n \t     operand addressable.  Always gimplify when not in SSA form\n \t     as we still may have to gimplify decls with value-exprs.  */\n-\t  if (!gimplify_ctxp || !gimplify_ctxp->into_ssa\n+\t  if (!gimplify_ctxp || !gimple_in_ssa_p (cfun)\n \t      || !is_gimple_mem_ref_addr (TREE_OPERAND (*expr_p, 0)))\n \t    {\n \t      ret = gimplify_expr (&TREE_OPERAND (*expr_p, 0), pre_p, post_p,"}, {"sha": "12fd1d05fbeeeaf193a8c4cdf912fabf97e96bd4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebc1b29edb3428dd18e76cba8626625bfb184f1d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebc1b29edb3428dd18e76cba8626625bfb184f1d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ebc1b29edb3428dd18e76cba8626625bfb184f1d", "patch": "@@ -1,3 +1,8 @@\n+2016-05-11  Richard Biener  <rguenther@suse.de>\n+\n+\tPR middle-end/71002\n+\t* g++.dg/torture/pr71002.C: New testcase.\n+\n 2016-05-11  Ilya Enkovich  <ilya.enkovich@intel.com>\n \n \tPR middle-end/70807"}, {"sha": "8a726809217037a2ce503c3a4d23bcaeceb3e4d2", "filename": "gcc/testsuite/g++.dg/torture/pr71002.C", "status": "added", "additions": 160, "deletions": 0, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebc1b29edb3428dd18e76cba8626625bfb184f1d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr71002.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebc1b29edb3428dd18e76cba8626625bfb184f1d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr71002.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr71002.C?ref=ebc1b29edb3428dd18e76cba8626625bfb184f1d", "patch": "@@ -0,0 +1,160 @@\n+// { dg-do run }\n+\n+using size_t = __SIZE_TYPE__;\n+\n+inline void* operator new(size_t, void* p) noexcept\n+{ return p; }\n+\n+inline void operator delete(void*, void*)\n+{ }\n+\n+struct long_t\n+{\n+  size_t is_short : 1;\n+  size_t length   : (__SIZEOF_SIZE_T__ * __CHAR_BIT__ - 1);\n+  size_t capacity;\n+  char* pointer;\n+};\n+\n+union long_raw_t {\n+  unsigned char data[sizeof(long_t)];\n+  struct __attribute__((aligned(alignof(long_t)))) { } align;\n+};\n+\n+struct short_header\n+{\n+  unsigned char is_short : 1;\n+  unsigned char length   : (__CHAR_BIT__ - 1);\n+};\n+\n+struct short_t\n+{\n+  short_header h;\n+  char data[23];\n+};\n+\n+union repr_t\n+{\n+  long_raw_t  r;\n+  short_t     s;\n+\n+  const short_t& short_repr() const\n+  { return s; }\n+\n+  const long_t& long_repr() const\n+  { return *static_cast<const long_t*>(static_cast<const void*>(&r)); }\n+\n+  short_t& short_repr()\n+  { return s;  }\n+\n+  long_t& long_repr()\n+  { return *static_cast<long_t*>(static_cast<void*>(&r)); }\n+};\n+\n+class string\n+{\n+public:\n+  string()\n+  {\n+    short_t& s = m_repr.short_repr();\n+    s.h.is_short = 1;\n+    s.h.length = 0;\n+    s.data[0] = '\\0';\n+  }\n+\n+  string(const char* str)\n+  {\n+    size_t length = __builtin_strlen(str);\n+    if (length + 1 > 23) {\n+      long_t& l = m_repr.long_repr();\n+      l.is_short = 0;\n+      l.length = length;\n+      l.capacity = length + 1;\n+      l.pointer = new char[l.capacity];\n+      __builtin_memcpy(l.pointer, str, length + 1);\n+    } else {\n+      short_t& s = m_repr.short_repr();\n+      s.h.is_short = 1;\n+      s.h.length = length;\n+      __builtin_memcpy(s.data, str, length + 1);\n+    }\n+  }\n+\n+  string(string&& other)\n+    : string{}\n+  {\n+    swap_data(other);\n+  }\n+\n+  ~string()\n+  {\n+    if (!is_short()) {\n+      delete[] m_repr.long_repr().pointer;\n+    }\n+  }\n+\n+  size_t length() const\n+  { return is_short() ? short_length() : long_length(); }\n+\n+private:\n+  bool is_short() const\n+  { return m_repr.s.h.is_short != 0; }\n+\n+  size_t short_length() const\n+  { return m_repr.short_repr().h.length; }\n+\n+  size_t long_length() const\n+  { return m_repr.long_repr().length; }\n+\n+  void swap_data(string& other)\n+  {\n+    if (is_short()) {\n+      if (other.is_short()) {\n+        repr_t tmp(m_repr);\n+        m_repr = other.m_repr;\n+        other.m_repr = tmp;\n+      } else {\n+        short_t short_backup(m_repr.short_repr());\n+        m_repr.short_repr().~short_t();\n+        ::new(&m_repr.long_repr()) long_t(other.m_repr.long_repr());\n+        other.m_repr.long_repr().~long_t();\n+        ::new(&other.m_repr.short_repr()) short_t(short_backup);\n+      }\n+    } else {\n+      if (other.is_short()) {\n+        short_t short_backup(other.m_repr.short_repr());\n+        other.m_repr.short_repr().~short_t();\n+        ::new(&other.m_repr.long_repr()) long_t(m_repr.long_repr());\n+        m_repr.long_repr().~long_t();\n+        ::new(&m_repr.short_repr()) short_t(short_backup);\n+      } else {\n+        long_t tmp(m_repr.long_repr());\n+        m_repr.long_repr() = other.m_repr.long_repr();\n+        other.m_repr.long_repr() = tmp;\n+      }\n+    }\n+  }\n+\n+  repr_t m_repr;\n+};\n+\n+struct foo\n+{\n+  __attribute__((noinline))\n+  foo(string str)\n+    : m_str{static_cast<string&&>(str)},\n+      m_len{m_str.length()}\n+  { }\n+\n+  string m_str;\n+  size_t m_len;\n+};\n+\n+int main()\n+{\n+  foo f{\"the quick brown fox jumps over the lazy dog\"};\n+  if (f.m_len == 0) {\n+    __builtin_abort();\n+  }\n+  return 0;\n+}"}]}