{"sha": "cf3c30d31f791b34b0190f0f06c732f14f63f2f5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2YzYzMwZDMxZjc5MWIzNGIwMTkwZjBmMDZjNzMyZjE0ZjYzZjJmNQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2012-12-08T03:31:37Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2012-12-08T03:31:37Z"}, "message": "re PR c++/55127 (Incorrect \"dependent scope\" error with partial specialization of non-type parameter)\n\n\tPR c++/55127\n\t* search.c (accessible_in_template_p): New.\n\t* cp-tree.h: Declare it.\n\t* pt.c (instantiation_dependent_scope_ref_p): New.\n\t(value_dependent_expression_p): Use it.\n\t(instantiation_dependent_r): Likewise.\n\t* semantics.c (finish_decltype_type): Handle SCOPE_REF.\n\nFrom-SVN: r194318", "tree": {"sha": "3caa0e662e11296db05750ca5ead364263a066e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3caa0e662e11296db05750ca5ead364263a066e6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cf3c30d31f791b34b0190f0f06c732f14f63f2f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf3c30d31f791b34b0190f0f06c732f14f63f2f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf3c30d31f791b34b0190f0f06c732f14f63f2f5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf3c30d31f791b34b0190f0f06c732f14f63f2f5/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4eaee921faac4b20bcc81988ec2b1af4cc087efc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4eaee921faac4b20bcc81988ec2b1af4cc087efc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4eaee921faac4b20bcc81988ec2b1af4cc087efc"}], "stats": {"total": 84, "additions": 75, "deletions": 9}, "files": [{"sha": "a5d0b76c61541173e168be620c6ef425e17f7b21", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf3c30d31f791b34b0190f0f06c732f14f63f2f5/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf3c30d31f791b34b0190f0f06c732f14f63f2f5/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=cf3c30d31f791b34b0190f0f06c732f14f63f2f5", "patch": "@@ -1,5 +1,13 @@\n 2012-12-07  Jason Merrill  <jason@redhat.com>\n \n+\tPR c++/55127\n+\t* search.c (accessible_in_template_p): New.\n+\t* cp-tree.h: Declare it.\n+\t* pt.c (instantiation_dependent_scope_ref_p): New.\n+\t(value_dependent_expression_p): Use it.\n+\t(instantiation_dependent_r): Likewise.\n+\t* semantics.c (finish_decltype_type): Handle SCOPE_REF.\n+\n \tPR c++/55419\n \t* tree.c (build_target_expr): Don't set TREE_CONSTANT.\n "}, {"sha": "465fa0f78efb6a2e51bd0551f60799359d245e83", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf3c30d31f791b34b0190f0f06c732f14f63f2f5/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf3c30d31f791b34b0190f0f06c732f14f63f2f5/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=cf3c30d31f791b34b0190f0f06c732f14f63f2f5", "patch": "@@ -5489,6 +5489,7 @@ extern tree lookup_base                         (tree, tree, base_access,\n \t\t\t\t\t\t base_kind *, tsubst_flags_t);\n extern tree dcast_base_hint\t\t\t(tree, tree);\n extern int accessible_p\t\t\t\t(tree, tree, bool);\n+extern int accessible_in_template_p\t\t(tree, tree);\n extern tree lookup_field_1\t\t\t(tree, tree, bool);\n extern tree lookup_field\t\t\t(tree, tree, int, bool);\n extern int lookup_fnfields_1\t\t\t(tree, tree);"}, {"sha": "1bc9e1bef14507b80323f5426b695071e8a2c7e7", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 23, "deletions": 8, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf3c30d31f791b34b0190f0f06c732f14f63f2f5/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf3c30d31f791b34b0190f0f06c732f14f63f2f5/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=cf3c30d31f791b34b0190f0f06c732f14f63f2f5", "patch": "@@ -19293,6 +19293,22 @@ dependent_scope_p (tree scope)\n \t  && !currently_open_class (scope));\n }\n \n+/* T is a SCOPE_REF; return whether we need to consider it\n+    instantiation-dependent so that we can check access at instantiation\n+    time even though we know which member it resolves to.  */\n+\n+static bool\n+instantiation_dependent_scope_ref_p (tree t)\n+{\n+  if (DECL_P (TREE_OPERAND (t, 1))\n+      && CLASS_TYPE_P (TREE_OPERAND (t, 0))\n+      && accessible_in_template_p (TREE_OPERAND (t, 0),\n+\t\t\t\t   TREE_OPERAND (t, 1)))\n+    return false;\n+  else\n+    return true;\n+}\n+\n /* Returns TRUE if the EXPRESSION is value-dependent, in the sense of\n    [temp.dep.constexpr].  EXPRESSION is already known to be a constant\n    expression.  */\n@@ -19400,10 +19416,9 @@ value_dependent_expression_p (tree expression)\n       return instantiation_dependent_expression_p (expression);\n \n     case SCOPE_REF:\n-      /* instantiation_dependent_r treats this as dependent so that we\n-\t check access at instantiation time, and all instantiation-dependent\n-\t expressions should also be considered value-dependent.  */\n-      return true;\n+      /* All instantiation-dependent expressions should also be considered\n+\t value-dependent.  */\n+      return instantiation_dependent_scope_ref_p (expression);\n \n     case COMPONENT_REF:\n       return (value_dependent_expression_p (TREE_OPERAND (expression, 0))\n@@ -19744,10 +19759,10 @@ instantiation_dependent_r (tree *tp, int *walk_subtrees,\n       break;\n \n     case SCOPE_REF:\n-      /* Similarly, finish_qualified_id_expr builds up a SCOPE_REF in a\n-\t template so that we can check access at instantiation time even\n-\t though we know which member it resolves to.  */\n-      return *tp;\n+      if (instantiation_dependent_scope_ref_p (*tp))\n+\treturn *tp;\n+      else\n+\tbreak;\n \n     default:\n       break;"}, {"sha": "1cd4fc584db81155e75baf1edb822d589bc60fdd", "filename": "gcc/cp/search.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf3c30d31f791b34b0190f0f06c732f14f63f2f5/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf3c30d31f791b34b0190f0f06c732f14f63f2f5/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=cf3c30d31f791b34b0190f0f06c732f14f63f2f5", "patch": "@@ -832,6 +832,19 @@ dfs_accessible_post (tree binfo, void * /*data*/)\n   return NULL_TREE;\n }\n \n+/* Like accessible_p below, but within a template returns true iff DECL is\n+   accessible in TYPE to all possible instantiations of the template.  */\n+\n+int\n+accessible_in_template_p (tree type, tree decl)\n+{\n+  int save_ptd = processing_template_decl;\n+  processing_template_decl = 0;\n+  int val = accessible_p (type, decl, false);\n+  processing_template_decl = save_ptd;\n+  return val;\n+}\n+\n /* DECL is a declaration from a base class of TYPE, which was the\n    class used to name DECL.  Return nonzero if, in the current\n    context, DECL is accessible.  If TYPE is actually a BINFO node,"}, {"sha": "179c5089cc92562b0d48c735c857a36f6b0e4d57", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf3c30d31f791b34b0190f0f06c732f14f63f2f5/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf3c30d31f791b34b0190f0f06c732f14f63f2f5/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=cf3c30d31f791b34b0190f0f06c732f14f63f2f5", "patch": "@@ -5268,7 +5268,8 @@ finish_decltype_type (tree expr, bool id_expression_or_member_access_p,\n         expr = TREE_OPERAND (expr, 0);\n \n       if (TREE_CODE (expr) == OFFSET_REF\n-          || TREE_CODE (expr) == MEMBER_REF)\n+          || TREE_CODE (expr) == MEMBER_REF\n+\t  || TREE_CODE (expr) == SCOPE_REF)\n         /* We're only interested in the field itself. If it is a\n            BASELINK, we will need to see through it in the next\n            step.  */"}, {"sha": "ba78bfbd5a33c3c51f722e5ebb0adbd4633be421", "filename": "gcc/testsuite/g++.dg/template/defarg16.C", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf3c30d31f791b34b0190f0f06c732f14f63f2f5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fdefarg16.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf3c30d31f791b34b0190f0f06c732f14f63f2f5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fdefarg16.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fdefarg16.C?ref=cf3c30d31f791b34b0190f0f06c732f14f63f2f5", "patch": "@@ -0,0 +1,28 @@\n+// PR c++/55127\n+\n+struct some_class\n+{\n+  static const bool     is_valid_type = true;\n+};\n+\n+template< typename Type\n+        , bool Valid = Type::is_valid_type\n+>\n+struct wrapper;\n+\n+template< typename Type >\n+struct wrapper< Type, true >\n+{\n+  typedef Type type;\n+};\n+\n+template< typename T >\n+void fun()\n+{\n+  wrapper<some_class>::type x;\n+}\n+\n+int main()\n+{\n+  fun<int>();\n+}"}]}