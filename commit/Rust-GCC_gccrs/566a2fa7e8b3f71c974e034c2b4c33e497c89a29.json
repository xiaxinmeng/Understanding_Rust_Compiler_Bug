{"sha": "566a2fa7e8b3f71c974e034c2b4c33e497c89a29", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTY2YTJmYTdlOGIzZjcxYzk3NGUwMzRjMmI0YzMzZTQ5N2M4OWEyOQ==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2018-03-27T23:14:22Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2018-03-27T23:14:22Z"}, "message": "re PR target/84914 (PowerPC complex multiply/divide calls the wrong function when -mabi=ieeelongdouble)\n\n[gcc]\n2018-03-27  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\tPR target/84914\n\t* config/rs6000/rs6000.c (create_complex_muldiv): New helper\n\tfunction to create the function decl for complex long double\n\tmultiply and divide for -mabi=ieeelongdouble.\n\t(init_float128_ieee): Call it.\n\n[gcc/testsuite]\n2018-03-27  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\tPR target/84914\n\t* gcc.target/powerpc/mulkc-2.c: New tests to make sure complex\n\tlong double multiply/divide uses the correct function.\n\t* gcc.target/powerpc/mulkc-3.c: Likewise.\n\t* gcc.target/powerpc/divkc-2.c: Likewise.\n\t* gcc.target/powerpc/divkc-3.c: Likewise.\n\nFrom-SVN: r258908", "tree": {"sha": "066f92cc658234d41fc2b5d288f707c43ab03827", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/066f92cc658234d41fc2b5d288f707c43ab03827"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/566a2fa7e8b3f71c974e034c2b4c33e497c89a29", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/566a2fa7e8b3f71c974e034c2b4c33e497c89a29", "html_url": "https://github.com/Rust-GCC/gccrs/commit/566a2fa7e8b3f71c974e034c2b4c33e497c89a29", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/566a2fa7e8b3f71c974e034c2b4c33e497c89a29/comments", "author": null, "committer": null, "parents": [{"sha": "fc5dbf7c5449e918cb5570d6edd861fe618830d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc5dbf7c5449e918cb5570d6edd861fe618830d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc5dbf7c5449e918cb5570d6edd861fe618830d3"}], "stats": {"total": 122, "additions": 122, "deletions": 0}, "files": [{"sha": "69b715eb099e0ff2e145adf54bf3076dbca3b0a0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/566a2fa7e8b3f71c974e034c2b4c33e497c89a29/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/566a2fa7e8b3f71c974e034c2b4c33e497c89a29/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=566a2fa7e8b3f71c974e034c2b4c33e497c89a29", "patch": "@@ -1,3 +1,11 @@\n+2018-03-27  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\tPR target/84914\n+\t* config/rs6000/rs6000.c (create_complex_muldiv): New helper\n+\tfunction to create the function decl for complex long double\n+\tmultiply and divide for -mabi=ieeelongdouble.\n+\t(init_float128_ieee): Call it.\n+\n 2018-03-27  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR target/85044"}, {"sha": "37c55f43c56df500745cbc07193e259484e4648c", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/566a2fa7e8b3f71c974e034c2b4c33e497c89a29/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/566a2fa7e8b3f71c974e034c2b4c33e497c89a29/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=566a2fa7e8b3f71c974e034c2b4c33e497c89a29", "patch": "@@ -18561,6 +18561,26 @@ init_float128_ibm (machine_mode mode)\n     }\n }\n \n+/* Create a decl for either complex long double multiply or complex long double\n+   divide when long double is IEEE 128-bit floating point.  We can't use\n+   __multc3 and __divtc3 because the original long double using IBM extended\n+   double used those names.  The complex multiply/divide functions are encoded\n+   as builtin functions with a complex result and 4 scalar inputs.  */\n+\n+static void\n+create_complex_muldiv (const char *name, built_in_function fncode, tree fntype)\n+{\n+  tree fndecl = add_builtin_function (name, fntype, fncode, BUILT_IN_NORMAL,\n+\t\t\t\t      name, NULL_TREE);\n+\n+  set_builtin_decl (fncode, fndecl, true);\n+\n+  if (TARGET_DEBUG_BUILTIN)\n+    fprintf (stderr, \"create complex %s, fncode: %d\\n\", name, (int) fncode);\n+\n+  return;\n+}\n+\n /* Set up IEEE 128-bit floating point routines.  Use different names if the\n    arguments can be passed in a vector register.  The historical PowerPC\n    implementation of IEEE 128-bit floating point used _q_<op> for the names, so\n@@ -18572,6 +18592,27 @@ init_float128_ieee (machine_mode mode)\n {\n   if (FLOAT128_VECTOR_P (mode))\n     {\n+      /* Set up to call __mulkc3 and __divkc3 under -mabi=ieeelongdouble.  */\n+     if (mode == TFmode && TARGET_IEEEQUAD)\n+       {\n+\t built_in_function fncode_mul =\n+\t   (built_in_function) (BUILT_IN_COMPLEX_MUL_MIN + TCmode\n+\t\t\t\t- MIN_MODE_COMPLEX_FLOAT);\n+\t built_in_function fncode_div =\n+\t   (built_in_function) (BUILT_IN_COMPLEX_DIV_MIN + TCmode\n+\t\t\t\t- MIN_MODE_COMPLEX_FLOAT);\n+\n+\t tree fntype = build_function_type_list (complex_long_double_type_node,\n+\t\t\t\t\t\t long_double_type_node,\n+\t\t\t\t\t\t long_double_type_node,\n+\t\t\t\t\t\t long_double_type_node,\n+\t\t\t\t\t\t long_double_type_node,\n+\t\t\t\t\t\t NULL_TREE);\n+\n+\t create_complex_muldiv (\"__mulkc3\", fncode_mul, fntype);\n+\t create_complex_muldiv (\"__divkc3\", fncode_div, fntype);\n+       }\n+\n       set_optab_libfunc (add_optab, mode, \"__addkf3\");\n       set_optab_libfunc (sub_optab, mode, \"__subkf3\");\n       set_optab_libfunc (neg_optab, mode, \"__negkf2\");"}, {"sha": "b195bd77bf5809db653e10a1797481ea7a3c92b1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/566a2fa7e8b3f71c974e034c2b4c33e497c89a29/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/566a2fa7e8b3f71c974e034c2b4c33e497c89a29/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=566a2fa7e8b3f71c974e034c2b4c33e497c89a29", "patch": "@@ -1,3 +1,12 @@\n+2018-03-27  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\tPR target/84914\n+\t* gcc.target/powerpc/mulkc-2.c: New tests to make sure complex\n+\tlong double multiply/divide uses the correct function.\n+\t* gcc.target/powerpc/mulkc-3.c: Likewise.\n+\t* gcc.target/powerpc/divkc-2.c: Likewise.\n+\t* gcc.target/powerpc/divkc-3.c: Likewise.\n+\n 2018-03-27  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/85067"}, {"sha": "d3fcbedac72101011373e01f803b557ffea5aab6", "filename": "gcc/testsuite/gcc.target/powerpc/divkc3-2.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/566a2fa7e8b3f71c974e034c2b4c33e497c89a29/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fdivkc3-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/566a2fa7e8b3f71c974e034c2b4c33e497c89a29/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fdivkc3-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fdivkc3-2.c?ref=566a2fa7e8b3f71c974e034c2b4c33e497c89a29", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-require-effective-target powerpc_p8vector_ok } */\n+/* { dg-options \"-O2 -mpower8-vector -mabi=ieeelongdouble -Wno-psabi\" } */\n+\n+/* Check that complex multiply generates the right call when long double is\n+   IEEE 128-bit floating point.  */\n+\n+typedef _Complex long double cld_t;\n+\n+void\n+divide (cld_t *p, cld_t *q, cld_t *r)\n+{\n+  *p = *q / *r;\n+}\n+\n+/* { dg-final { scan-assembler \"bl __divkc3\" } } */"}, {"sha": "45695fef8ce34ce3e848399f2a9edbee1cd6c87d", "filename": "gcc/testsuite/gcc.target/powerpc/divkc3-3.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/566a2fa7e8b3f71c974e034c2b4c33e497c89a29/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fdivkc3-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/566a2fa7e8b3f71c974e034c2b4c33e497c89a29/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fdivkc3-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fdivkc3-3.c?ref=566a2fa7e8b3f71c974e034c2b4c33e497c89a29", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-require-effective-target powerpc_p8vector_ok } */\n+/* { dg-options \"-O2 -mpower8-vector -mabi=ibmlongdouble -Wno-psabi\" } */\n+\n+/* Check that complex multiply generates the right call when long double is\n+   IBM extended double floating point.  */\n+\n+typedef _Complex long double cld_t;\n+\n+void\n+divide (cld_t *p, cld_t *q, cld_t *r)\n+{\n+  *p = *q / *r;\n+}\n+\n+/* { dg-final { scan-assembler \"bl __divtc3\" } } */"}, {"sha": "9ba577a0cc33ff026659d5b5243cb94527639044", "filename": "gcc/testsuite/gcc.target/powerpc/mulkc3-2.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/566a2fa7e8b3f71c974e034c2b4c33e497c89a29/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fmulkc3-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/566a2fa7e8b3f71c974e034c2b4c33e497c89a29/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fmulkc3-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fmulkc3-2.c?ref=566a2fa7e8b3f71c974e034c2b4c33e497c89a29", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-require-effective-target powerpc_p8vector_ok } */\n+/* { dg-options \"-O2 -mpower8-vector -mabi=ieeelongdouble -Wno-psabi\" } */\n+\n+/* Check that complex multiply generates the right call when long double is\n+   IEEE 128-bit floating point.  */\n+\n+typedef _Complex long double cld_t;\n+\n+void\n+multiply (cld_t *p, cld_t *q, cld_t *r)\n+{\n+  *p = *q * *r;\n+}\n+\n+/* { dg-final { scan-assembler \"bl __mulkc3\" } } */"}, {"sha": "db873015898022325b6f6ac367108f34a459986e", "filename": "gcc/testsuite/gcc.target/powerpc/mulkc3-3.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/566a2fa7e8b3f71c974e034c2b4c33e497c89a29/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fmulkc3-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/566a2fa7e8b3f71c974e034c2b4c33e497c89a29/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fmulkc3-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fmulkc3-3.c?ref=566a2fa7e8b3f71c974e034c2b4c33e497c89a29", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-require-effective-target powerpc_p8vector_ok } */\n+/* { dg-options \"-O2 -mpower8-vector -mabi=ibmlongdouble -Wno-psabi\" } */\n+\n+/* Check that complex multiply generates the right call when long double is\n+   IBM extended double floating point.  */\n+\n+typedef _Complex long double cld_t;\n+\n+void\n+multiply (cld_t *p, cld_t *q, cld_t *r)\n+{\n+  *p = *q * *r;\n+}\n+\n+/* { dg-final { scan-assembler \"bl __multc3\" } } */"}]}