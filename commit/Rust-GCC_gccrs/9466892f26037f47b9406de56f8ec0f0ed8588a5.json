{"sha": "9466892f26037f47b9406de56f8ec0f0ed8588a5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTQ2Njg5MmYyNjAzN2Y0N2I5NDA2ZGU1NmY4ZWMwZjBlZDg1ODhhNQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-03T09:59:55Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-03T09:59:55Z"}, "message": "[multiple changes]\n\n2011-08-03  Yannick Moy  <moy@adacore.com>\n\n\t* alfa.ads Update format of ALFA section in ALI file in order to add a\n\tmapping from bodies to specs when both are present\n\t(ALFA_Scope_Record): add components for spec file/scope\n\t* get_alfa.adb (Get_ALFA): read the new file/scope for spec when present\n\t* lib-xref-alfa.adb\n\t(Collect_ALFA): after all scopes have been collected, fill in the spec\n\t information when relevant\n\t* put_alfa.adb (Put_ALFA): write the new file/scope for spec when\n\tpresent.\n\n2011-08-03  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* inline.adb (Add_Inlined_Subprogram): Do not consider the enclosing\n\tcode unit to decide whether to add internally generated subprograms.\n\t\n2011-08-03  Javier Miranda  <miranda@adacore.com>\n\n\t* sem_aux.ads, sem_aux.adb (Is_VM_By_Copy_Actual): New subprogram.\n\t* exp_ch9.adb\n\t(Build_Simple_Entry_Call): Handle actuals that must be handled by copy\n\tin VM targets.\n\n2011-08-03  Emmanuel Briot  <briot@adacore.com>\n\n\t* make.adb, makeutl.adb, makeutl.ads (Make.Switches_Of): now shares\n\tcode with Makeutl.Get_Switches.\n\t* prj-tree.adb: Update comment.\n\nFrom-SVN: r177256", "tree": {"sha": "31d4ca3913ebc45ae492b86546843f75431efc60", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/31d4ca3913ebc45ae492b86546843f75431efc60"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9466892f26037f47b9406de56f8ec0f0ed8588a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9466892f26037f47b9406de56f8ec0f0ed8588a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9466892f26037f47b9406de56f8ec0f0ed8588a5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9466892f26037f47b9406de56f8ec0f0ed8588a5/comments", "author": null, "committer": null, "parents": [{"sha": "b5ea9143e7536eb2e599ee581b06c5f21129b86b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5ea9143e7536eb2e599ee581b06c5f21129b86b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b5ea9143e7536eb2e599ee581b06c5f21129b86b"}], "stats": {"total": 537, "additions": 335, "deletions": 202}, "files": [{"sha": "3090c3eeb7a2b6c74c9d9798938e9d27a1b3481e", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9466892f26037f47b9406de56f8ec0f0ed8588a5/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9466892f26037f47b9406de56f8ec0f0ed8588a5/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=9466892f26037f47b9406de56f8ec0f0ed8588a5", "patch": "@@ -1,3 +1,33 @@\n+2011-08-03  Yannick Moy  <moy@adacore.com>\n+\n+\t* alfa.ads Update format of ALFA section in ALI file in order to add a\n+\tmapping from bodies to specs when both are present\n+\t(ALFA_Scope_Record): add components for spec file/scope\n+\t* get_alfa.adb (Get_ALFA): read the new file/scope for spec when present\n+\t* lib-xref-alfa.adb\n+\t(Collect_ALFA): after all scopes have been collected, fill in the spec\n+\t information when relevant\n+\t* put_alfa.adb (Put_ALFA): write the new file/scope for spec when\n+\tpresent.\n+\n+2011-08-03  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* inline.adb (Add_Inlined_Subprogram): Do not consider the enclosing\n+\tcode unit to decide whether to add internally generated subprograms.\n+\t\n+2011-08-03  Javier Miranda  <miranda@adacore.com>\n+\n+\t* sem_aux.ads, sem_aux.adb (Is_VM_By_Copy_Actual): New subprogram.\n+\t* exp_ch9.adb\n+\t(Build_Simple_Entry_Call): Handle actuals that must be handled by copy\n+\tin VM targets.\n+\n+2011-08-03  Emmanuel Briot  <briot@adacore.com>\n+\n+\t* make.adb, makeutl.adb, makeutl.ads (Make.Switches_Of): now shares\n+\tcode with Makeutl.Get_Switches.\n+\t* prj-tree.adb: Update comment.\n+\n 2011-08-03  Thomas Quinot  <quinot@adacore.com>\n \n \t* sem_cat.adb (Validate_RCI_Subprogram_Declaration): Reject a remote"}, {"sha": "8601a321f21c40886b198b3a5287d9ef724345a9", "filename": "gcc/ada/alfa.ads", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9466892f26037f47b9406de56f8ec0f0ed8588a5/gcc%2Fada%2Falfa.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9466892f26037f47b9406de56f8ec0f0ed8588a5/gcc%2Fada%2Falfa.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Falfa.ads?ref=9466892f26037f47b9406de56f8ec0f0ed8588a5", "patch": "@@ -89,7 +89,7 @@ package ALFA is\n    --      reading of the ALFA information, and means that the ALFA information\n    --      can stand on its own without needing other parts of the ALI file.\n \n-   --    FS . scope line type col entity\n+   --    FS . scope line type col entity (-> spec-file . spec-scope)?\n \n    --      scope is the ones-origin scope number for the current file (e.g. 2 =\n    --      reference to the second FS line in this FD block).\n@@ -113,6 +113,9 @@ package ALFA is\n    --      entity is the name of the scope entity, with casing in the canonical\n    --      casing for the source file where it is defined.\n \n+   --      spec-file and spec-scope are respectively the file and scope for the\n+   --      spec corresponding to the current body scope, when they differ.\n+\n    --  ------------------\n    --  -- Xref Section --\n    --  ------------------\n@@ -234,6 +237,14 @@ package ALFA is\n       Scope_Num : Nat;\n       --  Set to the scope number for the scope\n \n+      Spec_File_Num : Nat;\n+      --  Set to the file dependency number for the scope corresponding to the\n+      --  spec of the current scope entity, if different, or else 0.\n+\n+      Spec_Scope_Num : Nat;\n+      --  Set to the scope number for the scope corresponding to the spec of\n+      --  the current scope entity, if different, or else 0.\n+\n       Line : Nat;\n       --  Line number for the scope\n "}, {"sha": "1b2e7fd81d09d23df04b2898c414e754d91e8dd1", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9466892f26037f47b9406de56f8ec0f0ed8588a5/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9466892f26037f47b9406de56f8ec0f0ed8588a5/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=9466892f26037f47b9406de56f8ec0f0ed8588a5", "patch": "@@ -3796,6 +3796,27 @@ package body Exp_Ch9 is\n                       Attribute_Name => Name_Unchecked_Access,\n                     Prefix =>\n                       New_Reference_To (Defining_Identifier (N_Node), Loc)));\n+\n+               --  If it is a vm_by_copy_actual, copy it to a new variable\n+\n+               elsif Is_VM_By_Copy_Actual (Actual) then\n+                  N_Node :=\n+                    Make_Object_Declaration (Loc,\n+                      Defining_Identifier => Make_Temporary (Loc, 'J'),\n+                      Aliased_Present     => True,\n+                      Object_Definition   =>\n+                        New_Reference_To (Etype (Formal), Loc),\n+                      Expression => New_Copy_Tree (Actual));\n+                  Set_Assignment_OK (N_Node);\n+\n+                  Append (N_Node, Decls);\n+\n+                  Append_To (Plist,\n+                    Make_Attribute_Reference (Loc,\n+                      Attribute_Name => Name_Unchecked_Access,\n+                    Prefix =>\n+                      New_Reference_To (Defining_Identifier (N_Node), Loc)));\n+\n                else\n                   --  Interface class-wide formal\n \n@@ -3947,7 +3968,8 @@ package body Exp_Ch9 is\n \n             Set_Assignment_OK (Actual);\n             while Present (Actual) loop\n-               if Is_By_Copy_Type (Etype (Actual))\n+               if (Is_By_Copy_Type (Etype (Actual))\n+                     or else Is_VM_By_Copy_Actual (Actual))\n                  and then Ekind (Formal) /= E_In_Parameter\n                then\n                   N_Node :="}, {"sha": "d9565b19b1b2d38f5b024eaf244203527e8351c4", "filename": "gcc/ada/get_alfa.adb", "status": "modified", "additions": 30, "deletions": 13, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9466892f26037f47b9406de56f8ec0f0ed8588a5/gcc%2Fada%2Fget_alfa.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9466892f26037f47b9406de56f8ec0f0ed8588a5/gcc%2Fada%2Fget_alfa.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fget_alfa.adb?ref=9466892f26037f47b9406de56f8ec0f0ed8588a5", "patch": "@@ -254,10 +254,12 @@ begin\n \n          when 'S' =>\n             declare\n-               Scope : Nat;\n-               Line  : Nat;\n-               Col   : Nat;\n-               Typ   : Character;\n+               Spec_File  : Nat;\n+               Spec_Scope : Nat;\n+               Scope      : Nat;\n+               Line       : Nat;\n+               Col        : Nat;\n+               Typ        : Character;\n \n             begin\n                --  Scan out location\n@@ -279,21 +281,36 @@ begin\n \n                Skip_Spaces;\n                Get_Name;\n+               Skip_Spaces;\n+\n+               if Nextc = '-' then\n+                  Skipc;\n+                  Check ('>');\n+                  Skip_Spaces;\n+                  Spec_File := Get_Nat;\n+                  Check ('.');\n+                  Spec_Scope := Get_Nat;\n+               else\n+                  Spec_File  := 0;\n+                  Spec_Scope := 0;\n+               end if;\n \n                --  Make new scope table entry (will fill in From_Xref and\n                --  To_Xref later). Initial range (From_Xref .. To_Xref) is\n                --  empty for scopes without entities.\n \n                ALFA_Scope_Table.Append (\n-                 (Scope_Entity => Empty,\n-                  Scope_Name   => new String'(Name_Str (1 .. Name_Len)),\n-                  File_Num     => Cur_File,\n-                  Scope_Num    => Cur_Scope,\n-                  Line         => Line,\n-                  Stype        => Typ,\n-                  Col          => Col,\n-                  From_Xref    => 1,\n-                  To_Xref      => 0));\n+                 (Scope_Entity   => Empty,\n+                  Scope_Name     => new String'(Name_Str (1 .. Name_Len)),\n+                  File_Num       => Cur_File,\n+                  Scope_Num      => Cur_Scope,\n+                  Spec_File_Num  => Spec_File,\n+                  Spec_Scope_Num => Spec_Scope,\n+                  Line           => Line,\n+                  Stype          => Typ,\n+                  Col            => Col,\n+                  From_Xref      => 1,\n+                  To_Xref        => 0));\n             end;\n \n             --  Update counter for scopes"}, {"sha": "5f5a4a01b05e664d1999b265950da8b9b7318438", "filename": "gcc/ada/inline.adb", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9466892f26037f47b9406de56f8ec0f0ed8588a5/gcc%2Fada%2Finline.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9466892f26037f47b9406de56f8ec0f0ed8588a5/gcc%2Fada%2Finline.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finline.adb?ref=9466892f26037f47b9406de56f8ec0f0ed8588a5", "patch": "@@ -428,13 +428,17 @@ package body Inline is\n    --  Start of processing for Add_Inlined_Subprogram\n \n    begin\n-      --  Insert the current subprogram in the list of inlined subprograms, if\n-      --  it can actually be inlined by the back-end, and if its unit is known\n-      --  to be inlined, or is an instance whose body will be analyzed anyway.\n-\n-      if (Is_Inlined (Pack) or else Is_Generic_Instance (Pack))\n+      --  If the subprogram is to be inlined, and if its unit is known to be\n+      --  inlined or is an instance whose body will be analyzed anyway or the\n+      --  subprogram has been generated by the compiler, and if it is declared\n+      --  at the library level not in the main unit, and if it can be inlined\n+      --  by the back-end, then insert it in the list of inlined subprograms.\n+\n+      if Is_Inlined (E)\n+        and then (Is_Inlined (Pack)\n+                    or else Is_Generic_Instance (Pack)\n+                    or else Is_Internal (E))\n         and then not Scope_In_Main_Unit (E)\n-        and then Is_Inlined (E)\n         and then not Is_Nested (E)\n         and then not Has_Initialized_Type (E)\n       then"}, {"sha": "860e80eb90a38b0b39049e7ffe1ddd9fa211a0fa", "filename": "gcc/ada/lib-xref-alfa.adb", "status": "modified", "additions": 103, "deletions": 22, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9466892f26037f47b9406de56f8ec0f0ed8588a5/gcc%2Fada%2Flib-xref-alfa.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9466892f26037f47b9406de56f8ec0f0ed8588a5/gcc%2Fada%2Flib-xref-alfa.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-xref-alfa.adb?ref=9466892f26037f47b9406de56f8ec0f0ed8588a5", "patch": "@@ -140,6 +140,9 @@ package body ALFA is\n       's' => True,\n       others => False);\n \n+   type Entity_Hashed_Range is range 0 .. 255;\n+   --  Size of hash table headers\n+\n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n@@ -155,6 +158,9 @@ package body ALFA is\n    --  Filter table Xrefs to add all references used in ALFA to the table\n    --  ALFA_Xref_Table.\n \n+   function Entity_Hash (E : Entity_Id) return Entity_Hashed_Range;\n+   --  Hash function for hash table\n+\n    procedure Traverse_Declarations_Or_Statements  (L : List_Id);\n    procedure Traverse_Handled_Statement_Sequence  (N : Node_Id);\n    procedure Traverse_Package_Body                (N : Node_Id);\n@@ -339,15 +345,17 @@ package body ALFA is\n       --  filled even later, but are initialized to represent an empty range.\n \n       ALFA_Scope_Table.Append (\n-        (Scope_Name   => new String'(Exact_Source_Name (Sloc (E))),\n-         File_Num     => 0,\n-         Scope_Num    => 0,\n-         Line         => Nat (Get_Logical_Line_Number (Loc)),\n-         Stype        => Typ,\n-         Col          => Nat (Get_Column_Number (Loc)),\n-         From_Xref    => 1,\n-         To_Xref      => 0,\n-         Scope_Entity => E));\n+        (Scope_Name     => new String'(Exact_Source_Name (Sloc (E))),\n+         File_Num       => 0,\n+         Scope_Num      => 0,\n+         Spec_File_Num  => 0,\n+         Spec_Scope_Num => 0,\n+         Line           => Nat (Get_Logical_Line_Number (Loc)),\n+         Stype          => Typ,\n+         Col            => Nat (Get_Column_Number (Loc)),\n+         From_Xref      => 1,\n+         To_Xref        => 0,\n+         Scope_Entity   => E));\n    end Add_ALFA_Scope;\n \n    --------------------\n@@ -367,36 +375,37 @@ package body ALFA is\n          procedure Set_Scope_Num (N : Entity_Id; Num : Nat);\n       end Scopes;\n \n+      ------------\n+      -- Scopes --\n+      ------------\n+\n       package body Scopes is\n          type Scope is record\n             Num    : Nat;\n             Entity : Entity_Id;\n          end record;\n \n-         type Scope_Hashed is range 0 .. 255;\n-\n-         function Scope_Hash (E : Entity_Id) return Scope_Hashed;\n-\n-         function Scope_Hash (E : Entity_Id) return Scope_Hashed is\n-            Value  : constant Int := Int (E);\n-            Modulo : constant Int := Int (Scope_Hashed'Last) + 1;\n-         begin\n-            return Scope_Hashed (Value - (Value / Modulo) * Modulo);\n-         end Scope_Hash;\n-\n          package Scopes is new GNAT.HTable.Simple_HTable\n-           (Header_Num => Scope_Hashed,\n+           (Header_Num => Entity_Hashed_Range,\n             Element    => Scope,\n             No_Element => (Num => No_Scope, Entity => Empty),\n             Key        => Entity_Id,\n-            Hash       => Scope_Hash,\n+            Hash       => Entity_Hash,\n             Equal      => \"=\");\n \n+         -------------------\n+         -- Get_Scope_Num --\n+         -------------------\n+\n          function Get_Scope_Num (N : Entity_Id) return Nat is\n          begin\n             return Scopes.Get (N).Num;\n          end Get_Scope_Num;\n \n+         -------------------\n+         -- Set_Scope_Num --\n+         -------------------\n+\n          procedure Set_Scope_Num (N : Entity_Id; Num : Nat) is\n          begin\n             Scopes.Set (K => N, E => Scope'(Num => Num, Entity => N));\n@@ -782,11 +791,83 @@ package body ALFA is\n          end if;\n       end loop;\n \n+      --  Fill in the spec information when relevant\n+\n+      declare\n+         package Entity_Hash_Table is new\n+           GNAT.HTable.Simple_HTable\n+             (Header_Num => Entity_Hashed_Range,\n+              Element    => Scope_Index,\n+              No_Element => 0,\n+              Key        => Entity_Id,\n+              Hash       => Entity_Hash,\n+              Equal      => \"=\");\n+\n+      begin\n+         --  Fill in the hash-table\n+\n+         for S in ALFA_Scope_Table.First .. ALFA_Scope_Table.Last loop\n+            declare\n+               Srec : ALFA_Scope_Record renames ALFA_Scope_Table.Table (S);\n+            begin\n+               Entity_Hash_Table.Set (Srec.Scope_Entity, S);\n+            end;\n+         end loop;\n+\n+         --  Use the hash-table to locate spec entities\n+\n+         for S in ALFA_Scope_Table.First .. ALFA_Scope_Table.Last loop\n+            declare\n+               Srec : ALFA_Scope_Record renames ALFA_Scope_Table.Table (S);\n+               Body_Entity : Entity_Id;\n+               Spec_Entity : Entity_Id;\n+               Spec_Scope  : Scope_Index;\n+            begin\n+               if Ekind (Srec.Scope_Entity) = E_Subprogram_Body then\n+                  Body_Entity := Parent (Parent (Srec.Scope_Entity));\n+               elsif Ekind (Srec.Scope_Entity) = E_Package_Body then\n+                  Body_Entity := Parent (Srec.Scope_Entity);\n+               else\n+                  Body_Entity := Empty;\n+               end if;\n+\n+               if Present (Body_Entity) then\n+                  if Nkind (Body_Entity) = N_Defining_Program_Unit_Name then\n+                     Body_Entity := Parent (Body_Entity);\n+                  end if;\n+\n+                  Spec_Entity := Corresponding_Spec (Body_Entity);\n+                  Spec_Scope := Entity_Hash_Table.Get (Spec_Entity);\n+\n+                  --  Spec of generic may be missing\n+\n+                  if Spec_Scope /= 0 then\n+                     Srec.Spec_File_Num :=\n+                       ALFA_Scope_Table.Table (Spec_Scope).File_Num;\n+                     Srec.Spec_Scope_Num :=\n+                       ALFA_Scope_Table.Table (Spec_Scope).Scope_Num;\n+                  end if;\n+               end if;\n+            end;\n+         end loop;\n+\n+      end;\n+\n       --  Generate cross reference ALFA information\n \n       Add_ALFA_Xrefs;\n    end Collect_ALFA;\n \n+   -----------------\n+   -- Entity_Hash --\n+   -----------------\n+\n+   function Entity_Hash (E : Entity_Id) return Entity_Hashed_Range is\n+   begin\n+      return Entity_Hashed_Range\n+        (E mod (Entity_Id (Entity_Hashed_Range'Last) + 1));\n+   end Entity_Hash;\n+\n    -----------------------------------------\n    -- Traverse_Declarations_Or_Statements --\n    -----------------------------------------"}, {"sha": "534795a14dbb030246d380e5ab9304bc8cb78a36", "filename": "gcc/ada/make.adb", "status": "modified", "additions": 14, "deletions": 152, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9466892f26037f47b9406de56f8ec0f0ed8588a5/gcc%2Fada%2Fmake.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9466892f26037f47b9406de56f8ec0f0ed8588a5/gcc%2Fada%2Fmake.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmake.adb?ref=9466892f26037f47b9406de56f8ec0f0ed8588a5", "patch": "@@ -625,8 +625,6 @@ package body Make is\n \n    function Switches_Of\n      (Source_File      : File_Name_Type;\n-      Source_File_Name : String;\n-      Source_Index     : Int;\n       Project          : Project_Id;\n       In_Package       : Package_Id;\n       Allow_ALI        : Boolean) return Variable_Value;\n@@ -780,7 +778,6 @@ package body Make is\n \n    procedure Collect_Arguments\n      (Source_File    : File_Name_Type;\n-      Source_Index   : Int;\n       Is_Main_Source : Boolean;\n       Args           : Argument_List);\n    --  Collect all arguments for a source to be compiled, including those\n@@ -1282,8 +1279,6 @@ package body Make is\n          Switches :=\n            Switches_Of\n              (Source_File      => Name_Find,\n-              Source_File_Name => File_Name,\n-              Source_Index     => Index,\n               Project          => Main_Project,\n               In_Package       => The_Package,\n               Allow_ALI        => Program = Binder or else Program = Linker);\n@@ -1707,8 +1702,7 @@ package body Make is\n \n             --  First, collect all the switches\n \n-            Collect_Arguments\n-              (Source_File, Source_Index, Is_Main_Source, The_Args);\n+            Collect_Arguments (Source_File, Is_Main_Source, The_Args);\n \n             Prev_Switch := Dummy_Switch;\n \n@@ -2246,7 +2240,6 @@ package body Make is\n \n    procedure Collect_Arguments\n      (Source_File    : File_Name_Type;\n-      Source_Index   : Int;\n       Is_Main_Source : Boolean;\n       Args           : Argument_List)\n    is\n@@ -2319,8 +2312,6 @@ package body Make is\n                   Switches :=\n                     Switches_Of\n                       (Source_File      => Source_File,\n-                       Source_File_Name => Source_File_Name,\n-                       Source_Index     => Source_Index,\n                        Project          => Arguments_Project,\n                        In_Package       => Compiler_Package,\n                        Allow_ALI        => False);\n@@ -3429,8 +3420,8 @@ package body Make is\n                --  The source file that we are checking can be located\n \n             else\n-               Collect_Arguments (Source_File, Source_Index,\n-                                  Source_File = Main_Source, Args);\n+               Collect_Arguments\n+                  (Source_File, Source_File = Main_Source, Args);\n \n                --  Do nothing if project of source is externally built\n \n@@ -8454,153 +8445,24 @@ package body Make is\n \n    function Switches_Of\n      (Source_File      : File_Name_Type;\n-      Source_File_Name : String;\n-      Source_Index     : Int;\n       Project          : Project_Id;\n       In_Package       : Package_Id;\n       Allow_ALI        : Boolean) return Variable_Value\n    is\n-      Lang : constant Language_Ptr := Get_Language_From_Name (Project, \"ada\");\n-\n       Switches : Variable_Value;\n-\n-      Defaults : constant Array_Element_Id :=\n-                   Prj.Util.Value_Of\n-                     (Name      => Name_Default_Switches,\n-                      In_Arrays =>\n-                        Project_Tree.Packages.Table\n-                          (In_Package).Decl.Arrays,\n-                      In_Tree   => Project_Tree);\n-\n-      Switches_Array : constant Array_Element_Id :=\n-                         Prj.Util.Value_Of\n-                           (Name      => Name_Switches,\n-                            In_Arrays =>\n-                              Project_Tree.Packages.Table\n-                                (In_Package).Decl.Arrays,\n-                            In_Tree   => Project_Tree);\n+      Is_Default : Boolean;\n \n    begin\n-      --  First, try Switches (<file name>)\n-\n-      Switches :=\n-        Prj.Util.Value_Of\n-          (Index           => Name_Id (Source_File),\n-           Src_Index       => Source_Index,\n-           In_Array        => Switches_Array,\n-           In_Tree         => Project_Tree,\n-           Allow_Wildcards => True);\n-\n-      --  Check also without the suffix\n-\n-      if Switches = Nil_Variable_Value\n-        and then Lang /= null\n-      then\n-         declare\n-            Naming      : Lang_Naming_Data renames Lang.Config.Naming_Data;\n-            Name        : String (1 .. Source_File_Name'Length + 3);\n-            Last        : Positive := Source_File_Name'Length;\n-            Spec_Suffix : String   := Get_Name_String (Naming.Spec_Suffix);\n-            Body_Suffix : String   := Get_Name_String (Naming.Body_Suffix);\n-            Truncated   : Boolean  := False;\n-\n-         begin\n-            Canonical_Case_File_Name (Spec_Suffix);\n-            Canonical_Case_File_Name (Body_Suffix);\n-            Name (1 .. Last) := Source_File_Name;\n-\n-            if Last > Body_Suffix'Length\n-               and then Name (Last - Body_Suffix'Length + 1 .. Last) =\n-                                                                  Body_Suffix\n-            then\n-               Truncated := True;\n-               Last := Last - Body_Suffix'Length;\n-            end if;\n-\n-            if not Truncated\n-              and then Last > Spec_Suffix'Length\n-              and then Name (Last - Spec_Suffix'Length + 1 .. Last) =\n-                                                                 Spec_Suffix\n-            then\n-               Truncated := True;\n-               Last := Last - Spec_Suffix'Length;\n-            end if;\n-\n-            if Truncated then\n-               Name_Len := 0;\n-               Add_Str_To_Name_Buffer (Name (1 .. Last));\n-               Switches :=\n-                 Prj.Util.Value_Of\n-                   (Index           => Name_Find,\n-                    Src_Index       => 0,\n-                    In_Array        => Switches_Array,\n-                    In_Tree         => Project_Tree,\n-                    Allow_Wildcards => True);\n-\n-               if Switches = Nil_Variable_Value and then Allow_ALI then\n-                  Last := Source_File_Name'Length;\n-\n-                  while Name (Last) /= '.' loop\n-                     Last := Last - 1;\n-                  end loop;\n-\n-                  Name_Len := 0;\n-                  Add_Str_To_Name_Buffer (Name (1 .. Last));\n-                  Add_Str_To_Name_Buffer (\"ali\");\n-\n-                  Switches :=\n-                    Prj.Util.Value_Of\n-                      (Index     => Name_Find,\n-                       Src_Index => 0,\n-                       In_Array  => Switches_Array,\n-                       In_Tree   => Project_Tree);\n-               end if;\n-            end if;\n-         end;\n-      end if;\n-\n-      --  Next, try Switches (\"Ada\")\n-\n-      if Switches = Nil_Variable_Value then\n-         Switches :=\n-           Prj.Util.Value_Of\n-             (Index                  => Name_Ada,\n-              Src_Index              => 0,\n-              In_Array               => Switches_Array,\n-              In_Tree                => Project_Tree,\n-              Force_Lower_Case_Index => True);\n-\n-         if Switches /= Nil_Variable_Value then\n-            Switch_May_Be_Passed_To_The_Compiler := False;\n-         end if;\n-      end if;\n-\n-      --  Next, try Switches (others)\n-\n-      if Switches = Nil_Variable_Value then\n-         Switches :=\n-           Prj.Util.Value_Of\n-             (Index     => All_Other_Names,\n-              Src_Index => 0,\n-              In_Array  => Switches_Array,\n-              In_Tree   => Project_Tree);\n-\n-         if Switches /= Nil_Variable_Value then\n-            Switch_May_Be_Passed_To_The_Compiler := False;\n-         end if;\n-      end if;\n-\n-      --  And finally, Default_Switches (\"Ada\")\n-\n-      if Switches = Nil_Variable_Value then\n-         Switches :=\n-           Prj.Util.Value_Of\n-             (Index     => Name_Ada,\n-              Src_Index => 0,\n-              In_Array  => Defaults,\n-              In_Tree   => Project_Tree);\n-      end if;\n-\n+      Makeutl.Get_Switches\n+        (Source_File  => Source_File,\n+         Source_Lang  => Name_Ada,\n+         Source_Prj   => Project,\n+         Pkg_Name     => Project_Tree.Packages.Table (In_Package).Name,\n+         Project_Tree => Project_Tree,\n+         Value        => Switches,\n+         Is_Default   => Is_Default,\n+         Test_Without_Suffix => True,\n+         Check_ALI_Suffix => Allow_ALI);\n       return Switches;\n    end Switches_Of;\n "}, {"sha": "5afb62923a5ab2e3b3e37241f5f44f8aa1fbd434", "filename": "gcc/ada/makeutl.adb", "status": "modified", "additions": 76, "deletions": 2, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9466892f26037f47b9406de56f8ec0f0ed8588a5/gcc%2Fada%2Fmakeutl.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9466892f26037f47b9406de56f8ec0f0ed8588a5/gcc%2Fada%2Fmakeutl.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmakeutl.adb?ref=9466892f26037f47b9406de56f8ec0f0ed8588a5", "patch": "@@ -685,7 +685,9 @@ package body Makeutl is\n       Pkg_Name     : Name_Id;\n       Project_Tree : Project_Tree_Ref;\n       Value        : out Variable_Value;\n-      Is_Default   : out Boolean)\n+      Is_Default   : out Boolean;\n+      Test_Without_Suffix : Boolean := False;\n+      Check_ALI_Suffix    : Boolean := False)\n    is\n       Project : constant Project_Id :=\n                   Ultimate_Extending_Project_Of (Source_Prj);\n@@ -694,6 +696,7 @@ package body Makeutl is\n                     (Name        => Pkg_Name,\n                      In_Packages => Project.Decl.Packages,\n                      In_Tree     => Project_Tree);\n+      Lang : Language_Ptr;\n    begin\n       Is_Default := False;\n \n@@ -706,8 +709,79 @@ package body Makeutl is\n             Allow_Wildcards         => True);\n       end if;\n \n+      if Value = Nil_Variable_Value\n+        and then Test_Without_Suffix\n+      then\n+         Lang :=\n+           Get_Language_From_Name (Project, Get_Name_String (Source_Lang));\n+\n+         if Lang /= null then\n+            declare\n+               Naming      : Lang_Naming_Data renames Lang.Config.Naming_Data;\n+               SF_Name     : constant String := Get_Name_String (Source_File);\n+               Last        : Positive := SF_Name'Length;\n+               Name        : String (1 .. Last + 3);\n+               Spec_Suffix : String   := Get_Name_String (Naming.Spec_Suffix);\n+               Body_Suffix : String   := Get_Name_String (Naming.Body_Suffix);\n+               Truncated   : Boolean  := False;\n+            begin\n+               Canonical_Case_File_Name (Spec_Suffix);\n+               Canonical_Case_File_Name (Body_Suffix);\n+               Name (1 .. Last) := SF_Name;\n+\n+               if Last > Body_Suffix'Length\n+                 and then Name (Last - Body_Suffix'Length + 1 .. Last) =\n+                   Body_Suffix\n+               then\n+                  Truncated := True;\n+                  Last := Last - Body_Suffix'Length;\n+               end if;\n+\n+               if not Truncated\n+                 and then Last > Spec_Suffix'Length\n+                 and then Name (Last - Spec_Suffix'Length + 1 .. Last) =\n+                   Spec_Suffix\n+               then\n+                  Truncated := True;\n+                  Last := Last - Spec_Suffix'Length;\n+               end if;\n+\n+               if Truncated then\n+                  Name_Len := 0;\n+                  Add_Str_To_Name_Buffer (Name (1 .. Last));\n+\n+                  Value := Prj.Util.Value_Of\n+                    (Name                    => Name_Find,\n+                     Attribute_Or_Array_Name => Name_Switches,\n+                     In_Package              => Pkg,\n+                     In_Tree                 => Project_Tree,\n+                     Allow_Wildcards         => True);\n+               end if;\n+\n+               if Value = Nil_Variable_Value\n+                 and then Check_ALI_Suffix\n+               then\n+                  Last := SF_Name'Length;\n+                  while Name (Last) /= '.' loop\n+                     Last := Last - 1;\n+                  end loop;\n+\n+                  Name_Len := 0;\n+                  Add_Str_To_Name_Buffer (Name (1 .. Last));\n+                  Add_Str_To_Name_Buffer (\"ali\");\n+\n+                  Value := Prj.Util.Value_Of\n+                    (Name                    => Name_Find,\n+                     Attribute_Or_Array_Name => Name_Switches,\n+                     In_Package              => Pkg,\n+                     In_Tree                 => Project_Tree,\n+                     Allow_Wildcards         => True);\n+               end if;\n+            end;\n+         end if;\n+      end if;\n+\n       if Value = Nil_Variable_Value then\n-         Is_Default := True;\n          Is_Default := True;\n          Value :=\n            Prj.Util.Value_Of"}, {"sha": "31a456213cef8247042296edf86b4b17c857d7c2", "filename": "gcc/ada/makeutl.ads", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9466892f26037f47b9406de56f8ec0f0ed8588a5/gcc%2Fada%2Fmakeutl.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9466892f26037f47b9406de56f8ec0f0ed8588a5/gcc%2Fada%2Fmakeutl.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmakeutl.ads?ref=9466892f26037f47b9406de56f8ec0f0ed8588a5", "patch": "@@ -161,13 +161,20 @@ package Makeutl is\n       Pkg_Name     : Name_Id;\n       Project_Tree : Project_Tree_Ref;\n       Value        : out Variable_Value;\n-      Is_Default   : out Boolean);\n+      Is_Default   : out Boolean;\n+      Test_Without_Suffix : Boolean := False;\n+      Check_ALI_Suffix    : Boolean := False);\n    --  Compute the switches (Compilation switches for instance) for the given\n    --  file. This checks various attributes to see if there are file specific\n    --  switches, or else defaults on the switches for the corresponding\n    --  language. Is_Default is set to False if there were file-specific\n    --  switches Source_File can be set to No_File to force retrieval of\n    --  the default switches.\n+   --  If Test_Without_Suffix is True, and there is no\n+   --  \" for Switches(Source_File) use\", then this procedure also tests without\n+   --  the extension of the filename.\n+   --  If Test_Without_Suffix is True and Check_ALI_Suffix is True, then we\n+   --  also replace the file extension with \".ali\" when testing.\n \n    function Linker_Options_Switches\n      (Project  : Project_Id;"}, {"sha": "3ac6a889f837f3c3db0cb1dddb96fba31eee38c8", "filename": "gcc/ada/prj-tree.adb", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9466892f26037f47b9406de56f8ec0f0ed8588a5/gcc%2Fada%2Fprj-tree.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9466892f26037f47b9406de56f8ec0f0ed8588a5/gcc%2Fada%2Fprj-tree.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-tree.adb?ref=9466892f26037f47b9406de56f8ec0f0ed8588a5", "patch": "@@ -1011,12 +1011,10 @@ package body Prj.Tree is\n       --  project, since we want to preserve the current environment. But we\n       --  still need to ensure that the external references are properly\n       --  initialized.\n+      --  Prj.Ext.Reset (Tree.External);\n \n       Prj.Ext.Initialize (Self.External);\n \n-      --  Why is this line commented out ???\n-      --  Prj.Ext.Reset (Tree.External);\n-\n       Self.Flags := Flags;\n    end Initialize;\n "}, {"sha": "bf35cbbabf5dafd0edd2b10f8b4655d50f181142", "filename": "gcc/ada/put_alfa.adb", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9466892f26037f47b9406de56f8ec0f0ed8588a5/gcc%2Fada%2Fput_alfa.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9466892f26037f47b9406de56f8ec0f0ed8588a5/gcc%2Fada%2Fput_alfa.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fput_alfa.adb?ref=9466892f26037f47b9406de56f8ec0f0ed8588a5", "patch": "@@ -78,6 +78,16 @@ begin\n                   Write_Info_Char (S.Scope_Name (N));\n                end loop;\n \n+               if S.Spec_File_Num /= 0 then\n+                  Write_Info_Char (' ');\n+                  Write_Info_Char ('-');\n+                  Write_Info_Char ('>');\n+                  Write_Info_Char (' ');\n+                  Write_Info_Nat (S.Spec_File_Num);\n+                  Write_Info_Char ('.');\n+                  Write_Info_Nat (S.Spec_Scope_Num);\n+               end if;\n+\n                Write_Info_Terminate;\n             end;\n "}, {"sha": "5b7de452037bcc412c464f7bfb30e1d9eeb991b0", "filename": "gcc/ada/sem_aux.adb", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9466892f26037f47b9406de56f8ec0f0ed8588a5/gcc%2Fada%2Fsem_aux.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9466892f26037f47b9406de56f8ec0f0ed8588a5/gcc%2Fada%2Fsem_aux.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aux.adb?ref=9466892f26037f47b9406de56f8ec0f0ed8588a5", "patch": "@@ -33,6 +33,7 @@\n with Atree;  use Atree;\n with Einfo;  use Einfo;\n with Namet;  use Namet;\n+with Opt;    use Opt;\n with Sinfo;  use Sinfo;\n with Snames; use Snames;\n with Stand;  use Stand;\n@@ -784,6 +785,18 @@ package body Sem_Aux is\n       end if;\n    end Is_Limited_Type;\n \n+   --------------------------\n+   -- Is_VM_By_Copy_Actual --\n+   --------------------------\n+\n+   function Is_VM_By_Copy_Actual (N : Node_Id) return Boolean is\n+   begin\n+      return not Tagged_Type_Expansion\n+        and then Nkind (N) = N_Identifier\n+        and then Present (Renamed_Object (Entity (N)))\n+        and then Nkind (Renamed_Object (Entity (N))) = N_Slice;\n+   end Is_VM_By_Copy_Actual;\n+\n    ----------------------\n    -- Nearest_Ancestor --\n    ----------------------"}, {"sha": "acf37e6450b97eb0bd3d2b93b38bd1d236a11c51", "filename": "gcc/ada/sem_aux.ads", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9466892f26037f47b9406de56f8ec0f0ed8588a5/gcc%2Fada%2Fsem_aux.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9466892f26037f47b9406de56f8ec0f0ed8588a5/gcc%2Fada%2Fsem_aux.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aux.ads?ref=9466892f26037f47b9406de56f8ec0f0ed8588a5", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -186,6 +186,10 @@ package Sem_Aux is\n    --  composite containing a limited component, or a subtype of any of\n    --  these types).\n \n+   function Is_VM_By_Copy_Actual (N : Node_Id) return Boolean;\n+   --  Returns True if we are compiling on VM targets and N is a node that\n+   --  requires to be passed by copy in these targets.\n+\n    function Nearest_Ancestor (Typ : Entity_Id) return Entity_Id;\n    --  Given a subtype Typ, this function finds out the nearest ancestor from\n    --  which constraints and predicates are inherited. There is no simple link"}]}