{"sha": "65263c1f70b4e589e70c35c244a7f6294e5c4c1e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjUyNjNjMWY3MGI0ZTU4OWU3MGMzNWMyNDRhN2Y2Mjk0ZTVjNGMxZQ==", "commit": {"author": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2015-03-17T01:01:54Z"}, "committer": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2015-03-17T01:01:54Z"}, "message": "re PR fortran/64432 (SYSTEM_CLOCK(COUNT_RATE=rate) wrong result for integer(4)::rate)\n\n2015-03-16  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n\n\tPR fortran/64432\n\t*trans-intrinisic.c (conv_intrinsic_system_clock): Check the\n\tsmallest kind passed in user arguments and hardcode tesults for\n\tKIND=1 or KIND=2 to indicate no clock available.\n\nFrom-SVN: r221471", "tree": {"sha": "9791d46b3c1a833057bfc1cc6c6ad00071453cbb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9791d46b3c1a833057bfc1cc6c6ad00071453cbb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/65263c1f70b4e589e70c35c244a7f6294e5c4c1e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65263c1f70b4e589e70c35c244a7f6294e5c4c1e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/65263c1f70b4e589e70c35c244a7f6294e5c4c1e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65263c1f70b4e589e70c35c244a7f6294e5c4c1e/comments", "author": null, "committer": null, "parents": [{"sha": "a5858a3dfff043b6693ab4b59ee5a41d3e20bad7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5858a3dfff043b6693ab4b59ee5a41d3e20bad7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a5858a3dfff043b6693ab4b59ee5a41d3e20bad7"}], "stats": {"total": 137, "additions": 101, "deletions": 36}, "files": [{"sha": "b638835c9beb315b8b21fd6f37e085fe47daabc9", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65263c1f70b4e589e70c35c244a7f6294e5c4c1e/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65263c1f70b4e589e70c35c244a7f6294e5c4c1e/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=65263c1f70b4e589e70c35c244a7f6294e5c4c1e", "patch": "@@ -1,3 +1,10 @@\n+2015-03-16  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n+\n+\tPR fortran/64432\n+\t*trans-intrinisic.c (conv_intrinsic_system_clock): Check the\n+\tsmallest kind passed in user arguments and hardcode tesults for\n+\tKIND=1 or KIND=2 to indicate no clock available.\n+\n 2015-03-16  Andre Vehreschild  <vehre@gmx.de>\n \n \t* resolve.c: Prevent segfault on illegal input."}, {"sha": "6f23a9709fb0e7190a9a9a4b87ec8c2560a46645", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 94, "deletions": 36, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65263c1f70b4e589e70c35c244a7f6294e5c4c1e/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65263c1f70b4e589e70c35c244a7f6294e5c4c1e/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=65263c1f70b4e589e70c35c244a7f6294e5c4c1e", "patch": "@@ -2671,22 +2671,13 @@ conv_intrinsic_system_clock (gfc_code *code)\n   stmtblock_t block;\n   gfc_se count_se, count_rate_se, count_max_se;\n   tree arg1 = NULL_TREE, arg2 = NULL_TREE, arg3 = NULL_TREE;\n-  tree type, tmp;\n-  int kind;\n+  tree tmp;\n+  int least;\n \n   gfc_expr *count = code->ext.actual->expr;\n   gfc_expr *count_rate = code->ext.actual->next->expr;\n   gfc_expr *count_max = code->ext.actual->next->next->expr;\n \n-  /* The INTEGER(8) version has higher precision, it is used if both COUNT\n-     and COUNT_MAX can hold 64-bit values, or are absent.  */\n-  if ((!count || count->ts.kind >= 8)\n-      && (!count_max || count_max->ts.kind >= 8))\n-    kind = 8;\n-  else\n-    kind = gfc_default_integer_kind;\n-  type = gfc_get_int_type (kind);\n-\n   /* Evaluate our arguments.  */\n   if (count)\n     {\n@@ -2706,36 +2697,103 @@ conv_intrinsic_system_clock (gfc_code *code)\n       gfc_conv_expr (&count_max_se, count_max);\n     }\n \n-  /* Prepare temporary variables if we need them.  */\n-  if (count && count->ts.kind != kind)\n-    arg1 = gfc_create_var (type, \"count\");\n-  else if (count)\n-    arg1 = count_se.expr;\n+  /* Find the smallest kind found of the arguments.  */\n+  least = 16;\n+  least = (count && count->ts.kind < least) ? count->ts.kind : least;\n+  least = (count_rate && count_rate->ts.kind < least) ? count_rate->ts.kind\n+\t\t\t\t\t\t      : least;\n+  least = (count_max && count_max->ts.kind < least) ? count_max->ts.kind\n+\t\t\t\t\t\t    : least;\n \n-  if (count_rate && (count_rate->ts.kind != kind\n-\t\t     || count_rate->ts.type != BT_INTEGER))\n-    arg2 = gfc_create_var (type, \"count_rate\");\n-  else if (count_rate)\n-    arg2 = count_rate_se.expr;\n+  /* Prepare temporary variables.  */\n \n-  if (count_max && count_max->ts.kind != kind)\n-    arg3 = gfc_create_var (type, \"count_max\");\n-  else if (count_max)\n-    arg3 = count_max_se.expr;\n+  if (count)\n+    {\n+      if (least >= 8)\n+\targ1 = gfc_create_var (gfc_get_int_type (8), \"count\");\n+      else if (least == 4)\n+\targ1 = gfc_create_var (gfc_get_int_type (4), \"count\");\n+      else if (count->ts.kind == 1)\n+        arg1 = gfc_conv_mpz_to_tree (gfc_integer_kinds[0].pedantic_min_int,\n+\t\t\t\t     count->ts.kind);\n+      else\n+        arg1 = gfc_conv_mpz_to_tree (gfc_integer_kinds[1].pedantic_min_int,\n+\t\t\t\t     count->ts.kind);\n+    }\n+\n+  if (count_rate)\n+    {\n+      if (least >= 8)\n+\targ2 = gfc_create_var (gfc_get_int_type (8), \"count_rate\");\n+      else if (least == 4)\n+\targ2 = gfc_create_var (gfc_get_int_type (4), \"count_rate\");\n+      else\n+        arg2 = integer_zero_node;\n+    }\n+\n+  if (count_max)\n+    {\n+      if (least >= 8)\n+\targ3 = gfc_create_var (gfc_get_int_type (8), \"count_max\");\n+      else if (least == 4)\n+\targ3 = gfc_create_var (gfc_get_int_type (4), \"count_max\");\n+      else\n+        arg3 = integer_zero_node;\n+    }\n \n   /* Make the function call.  */\n   gfc_init_block (&block);\n-  tmp = build_call_expr_loc (input_location,\n-\t\t\t     kind == 4 ? gfor_fndecl_system_clock4\n-\t\t\t\t       : gfor_fndecl_system_clock8,\n-                             3,\n-\t\t\t     arg1 ? gfc_build_addr_expr (NULL_TREE, arg1)\n-\t\t\t\t  : null_pointer_node,\n-\t\t\t     arg2 ? gfc_build_addr_expr (NULL_TREE, arg2)\n-\t\t\t\t  : null_pointer_node,\n-\t\t\t     arg3 ? gfc_build_addr_expr (NULL_TREE, arg3)\n-\t\t\t\t  : null_pointer_node);\n-  gfc_add_expr_to_block (&block, tmp);\n+\n+if (least <= 2)\n+  {\n+    if (least == 1)\n+      {\n+\targ1 ? gfc_build_addr_expr (NULL_TREE, arg1)\n+\t       : null_pointer_node;\n+\targ2 ? gfc_build_addr_expr (NULL_TREE, arg2)\n+\t       : null_pointer_node;\n+\targ3 ? gfc_build_addr_expr (NULL_TREE, arg3)\n+\t       : null_pointer_node;\n+      }\n+  \n+    if (least == 2)\n+      {\n+\targ1 ? gfc_build_addr_expr (NULL_TREE, arg1)\n+\t       : null_pointer_node;\n+\targ2 ? gfc_build_addr_expr (NULL_TREE, arg2)\n+\t       : null_pointer_node;\n+\targ3 ? gfc_build_addr_expr (NULL_TREE, arg3)\n+\t       : null_pointer_node;\n+      }\n+  }\n+else\n+  {\n+    if (least == 4)\n+      {\n+\ttmp = build_call_expr_loc (input_location,\n+\t\tgfor_fndecl_system_clock4, 3,\n+\t\targ1 ? gfc_build_addr_expr (NULL_TREE, arg1)\n+\t\t       : null_pointer_node,\n+\t\targ2 ? gfc_build_addr_expr (NULL_TREE, arg2)\n+\t\t       : null_pointer_node,\n+\t\targ3 ? gfc_build_addr_expr (NULL_TREE, arg3)\n+\t\t       : null_pointer_node);\n+\tgfc_add_expr_to_block (&block, tmp);\n+      }\n+    /* Handle kind>=8, 10, or 16 arguments */\n+    if (least >= 8)\n+      {\n+\ttmp = build_call_expr_loc (input_location,\n+\t\tgfor_fndecl_system_clock8, 3,\n+\t\targ1 ? gfc_build_addr_expr (NULL_TREE, arg1)\n+\t\t       : null_pointer_node,\n+\t\targ2 ? gfc_build_addr_expr (NULL_TREE, arg2)\n+\t\t       : null_pointer_node,\n+\t\targ3 ? gfc_build_addr_expr (NULL_TREE, arg3)\n+\t\t       : null_pointer_node);\n+\tgfc_add_expr_to_block (&block, tmp);\n+      }\n+  }\n \n   /* And store values back if needed.  */\n   if (arg1 && arg1 != count_se.expr)"}]}