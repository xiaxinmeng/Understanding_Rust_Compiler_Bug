{"sha": "3379b71f51c36c499ca5ce4ec877bd70b96a580e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzM3OWI3MWY1MWMzNmM0OTljYTVjZTRlYzg3N2JkNzBiOTZhNTgwZQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2014-05-06T19:22:16Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2014-05-06T19:22:16Z"}, "message": "revert: lra-constraints.c (valid_address_p): Move earlier in file.\n\ngcc/\n\tRevert:\n\t2014-05-03  Richard Sandiford  <rdsandiford@googlemail.com>\n\n\t* lra-constraints.c (valid_address_p): Move earlier in file.\n\tAdd a constraint argument to the address_info version.\n\t(satisfies_memory_constraint_p): New function.\n\t(satisfies_address_constraint_p): Likewise.\n\t(process_alt_operands, curr_insn_transform): Use them.\n\t(process_address): Pass the constraint to valid_address_p when\n\tchecking address operands.\n\nFrom-SVN: r210121", "tree": {"sha": "cc060c93a156cf1f7771a6b514b00fb2e6bec714", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cc060c93a156cf1f7771a6b514b00fb2e6bec714"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3379b71f51c36c499ca5ce4ec877bd70b96a580e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3379b71f51c36c499ca5ce4ec877bd70b96a580e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3379b71f51c36c499ca5ce4ec877bd70b96a580e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3379b71f51c36c499ca5ce4ec877bd70b96a580e/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "224dbc07a51880b778766549934fcdac9b2f6097", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/224dbc07a51880b778766549934fcdac9b2f6097", "html_url": "https://github.com/Rust-GCC/gccrs/commit/224dbc07a51880b778766549934fcdac9b2f6097"}], "stats": {"total": 163, "additions": 71, "deletions": 92}, "files": [{"sha": "00b1e5ad16aaccb516b5c2a8cf5fe1c90fe13456", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3379b71f51c36c499ca5ce4ec877bd70b96a580e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3379b71f51c36c499ca5ce4ec877bd70b96a580e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3379b71f51c36c499ca5ce4ec877bd70b96a580e", "patch": "@@ -1,3 +1,16 @@\n+2014-05-06  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\tRevert:\n+\t2014-05-03  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* lra-constraints.c (valid_address_p): Move earlier in file.\n+\tAdd a constraint argument to the address_info version.\n+\t(satisfies_memory_constraint_p): New function.\n+\t(satisfies_address_constraint_p): Likewise.\n+\t(process_alt_operands, curr_insn_transform): Use them.\n+\t(process_address): Pass the constraint to valid_address_p when\n+\tchecking address operands.\n+\n 2014-05-06  Richard Sandiford  <r.sandiford@uk.ibm.com>\n \n \t* lto-cgraph.c (compute_ltrans_boundary): Make node variables local"}, {"sha": "aac50876d21a5c9be55803d9022892861984bf47", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 58, "deletions": 92, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3379b71f51c36c499ca5ce4ec877bd70b96a580e/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3379b71f51c36c499ca5ce4ec877bd70b96a580e/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=3379b71f51c36c499ca5ce4ec877bd70b96a580e", "patch": "@@ -317,94 +317,6 @@ in_mem_p (int regno)\n   return get_reg_class (regno) == NO_REGS;\n }\n \n-/* Return 1 if ADDR is a valid memory address for mode MODE in address\n-   space AS, and check that each pseudo has the proper kind of hard\n-   reg.\t */\n-static int\n-valid_address_p (enum machine_mode mode ATTRIBUTE_UNUSED,\n-\t\t rtx addr, addr_space_t as)\n-{\n-#ifdef GO_IF_LEGITIMATE_ADDRESS\n-  lra_assert (ADDR_SPACE_GENERIC_P (as));\n-  GO_IF_LEGITIMATE_ADDRESS (mode, addr, win);\n-  return 0;\n-\n- win:\n-  return 1;\n-#else\n-  return targetm.addr_space.legitimate_address_p (mode, addr, 0, as);\n-#endif\n-}\n-\n-/* Return whether address AD is valid.  If CONSTRAINT is null,\n-   check for general addresses, otherwise check the extra constraint\n-   CONSTRAINT.  */\n-static bool\n-valid_address_p (struct address_info *ad, const char *constraint = 0)\n-{\n-  /* Some ports do not check displacements for eliminable registers,\n-     so we replace them temporarily with the elimination target.  */\n-  rtx saved_base_reg = NULL_RTX;\n-  rtx saved_index_reg = NULL_RTX;\n-  rtx *base_term = strip_subreg (ad->base_term);\n-  rtx *index_term = strip_subreg (ad->index_term);\n-  if (base_term != NULL)\n-    {\n-      saved_base_reg = *base_term;\n-      lra_eliminate_reg_if_possible (base_term);\n-      if (ad->base_term2 != NULL)\n-\t*ad->base_term2 = *ad->base_term;\n-    }\n-  if (index_term != NULL)\n-    {\n-      saved_index_reg = *index_term;\n-      lra_eliminate_reg_if_possible (index_term);\n-    }\n-  bool ok_p = (constraint\n-#ifdef EXTRA_CONSTRAINT_STR\n-\t       ? EXTRA_CONSTRAINT_STR (*ad->outer, constraint[0], constraint)\n-#else\n-\t       ? false\n-#endif\n-\t       : valid_address_p (ad->mode, *ad->outer, ad->as));\n-  if (saved_base_reg != NULL_RTX)\n-    {\n-      *base_term = saved_base_reg;\n-      if (ad->base_term2 != NULL)\n-\t*ad->base_term2 = *ad->base_term;\n-    }\n-  if (saved_index_reg != NULL_RTX)\n-    *index_term = saved_index_reg;\n-  return ok_p;\n-}\n-\n-#ifdef EXTRA_CONSTRAINT_STR\n-/* Return true if, after elimination, OP satisfies extra memory constraint\n-   CONSTRAINT.  */\n-static bool\n-satisfies_memory_constraint_p (rtx op, const char *constraint)\n-{\n-  struct address_info ad;\n-\n-  if (!MEM_P (op))\n-    return false;\n-\n-  decompose_mem_address (&ad, op);\n-  return valid_address_p (&ad, constraint);\n-}\n-\n-/* Return true if, after elimination, OP satisfies extra address constraint\n-   CONSTRAINT.  */\n-static bool\n-satisfies_address_constraint_p (rtx op, const char *constraint)\n-{\n-  struct address_info ad;\n-\n-  decompose_lea_address (&ad, &op);\n-  return valid_address_p (&ad, constraint);\n-}\n-#endif\n-\n /* Initiate equivalences for LRA.  As we keep original equivalences\n    before any elimination, we need to make copies otherwise any change\n    in insns might change the equivalences.  */\n@@ -2029,7 +1941,7 @@ process_alt_operands (int only_alternative)\n #ifdef EXTRA_CONSTRAINT_STR\n \t\t      if (EXTRA_MEMORY_CONSTRAINT (c, p))\n \t\t\t{\n-\t\t\t  if (satisfies_memory_constraint_p (op, p))\n+\t\t\t  if (EXTRA_CONSTRAINT_STR (op, c, p))\n \t\t\t    win = true;\n \t\t\t  else if (spilled_pseudo_p (op))\n \t\t\t    win = true;\n@@ -2048,7 +1960,7 @@ process_alt_operands (int only_alternative)\n \t\t\t}\n \t\t      if (EXTRA_ADDRESS_CONSTRAINT (c, p))\n \t\t\t{\n-\t\t\t  if (satisfies_address_constraint_p (op, p))\n+\t\t\t  if (EXTRA_CONSTRAINT_STR (op, c, p))\n \t\t\t    win = true;\n \n \t\t\t  /* If we didn't already win, we can reload\n@@ -2664,6 +2576,60 @@ process_alt_operands (int only_alternative)\n   return ok_p;\n }\n \n+/* Return 1 if ADDR is a valid memory address for mode MODE in address\n+   space AS, and check that each pseudo has the proper kind of hard\n+   reg.\t */\n+static int\n+valid_address_p (enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t rtx addr, addr_space_t as)\n+{\n+#ifdef GO_IF_LEGITIMATE_ADDRESS\n+  lra_assert (ADDR_SPACE_GENERIC_P (as));\n+  GO_IF_LEGITIMATE_ADDRESS (mode, addr, win);\n+  return 0;\n+\n+ win:\n+  return 1;\n+#else\n+  return targetm.addr_space.legitimate_address_p (mode, addr, 0, as);\n+#endif\n+}\n+\n+/* Return whether address AD is valid.  */\n+\n+static bool\n+valid_address_p (struct address_info *ad)\n+{\n+  /* Some ports do not check displacements for eliminable registers,\n+     so we replace them temporarily with the elimination target.  */\n+  rtx saved_base_reg = NULL_RTX;\n+  rtx saved_index_reg = NULL_RTX;\n+  rtx *base_term = strip_subreg (ad->base_term);\n+  rtx *index_term = strip_subreg (ad->index_term);\n+  if (base_term != NULL)\n+    {\n+      saved_base_reg = *base_term;\n+      lra_eliminate_reg_if_possible (base_term);\n+      if (ad->base_term2 != NULL)\n+\t*ad->base_term2 = *ad->base_term;\n+    }\n+  if (index_term != NULL)\n+    {\n+      saved_index_reg = *index_term;\n+      lra_eliminate_reg_if_possible (index_term);\n+    }\n+  bool ok_p = valid_address_p (ad->mode, *ad->outer, ad->as);\n+  if (saved_base_reg != NULL_RTX)\n+    {\n+      *base_term = saved_base_reg;\n+      if (ad->base_term2 != NULL)\n+\t*ad->base_term2 = *ad->base_term;\n+    }\n+  if (saved_index_reg != NULL_RTX)\n+    *index_term = saved_index_reg;\n+  return ok_p;\n+}\n+\n /* Make reload base reg + disp from address AD.  Return the new pseudo.  */\n static rtx\n base_plus_disp_to_reg (struct address_info *ad)\n@@ -2866,7 +2832,7 @@ process_address (int nop, rtx *before, rtx *after)\n      EXTRA_CONSTRAINT_STR for the validation.  */\n   if (constraint[0] != 'p'\n       && EXTRA_ADDRESS_CONSTRAINT (constraint[0], constraint)\n-      && valid_address_p (&ad, constraint))\n+      && EXTRA_CONSTRAINT_STR (op, constraint[0], constraint))\n     return change_p;\n #endif\n \n@@ -3573,7 +3539,7 @@ curr_insn_transform (void)\n \t\t  break;\n #ifdef EXTRA_CONSTRAINT_STR\n \t\tif (EXTRA_MEMORY_CONSTRAINT (c, constraint)\n-\t\t    && satisfies_memory_constraint_p (tem, constraint))\n+\t\t    && EXTRA_CONSTRAINT_STR (tem, c, constraint))\n \t\t  break;\n #endif\n \t      }"}]}