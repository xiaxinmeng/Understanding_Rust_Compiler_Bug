{"sha": "5b5e609d03ec31780977795463c3b12f1c2387f3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWI1ZTYwOWQwM2VjMzE3ODA5Nzc3OTU0NjNjM2IxMmYxYzIzODdmMw==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2001-12-04T20:13:41Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2001-12-04T20:13:41Z"}, "message": "[multiple changes]\n\n\n2001-12-04  Benjamin Kosnik  <bkoz@redhat.com>\n\n\t* src/Makefile.am (sources): Add ext-inst.cc.\n\t* src/Makefile.in: Regenerate.\n\t* src/ext-inst.cc: New file.\n\t* include/bits/stl_threads.h: Format.\n\t* src/globals.cc: Add instantiation for _S_swap_lock.\n\n\t* testsuite/18_support/numeric_limits.cc: Add numeric_limits<B>\n\tinstantiation.\n\n2001-12-04  John David Anglin  <dave@hiauly1.hia.nrc.ca>\n\n\t* testsuite/22_locale/numpunct_members_wchar_t.cc: Only compile\n\tand execute test01 if _GLIBCPP_USE_WCHAR_T is defined.\n\t* testsuite/26_numerics/complex_inserters_extractors.cc: Provide\n\tfor explicit instantiation of class std::basic_string<char,\n\tgnu_char_traits, std::allocator<char> >.\n\nFrom-SVN: r47622", "tree": {"sha": "fd7ad5dc0be1549da91fe3baab2269de32e71b66", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fd7ad5dc0be1549da91fe3baab2269de32e71b66"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5b5e609d03ec31780977795463c3b12f1c2387f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b5e609d03ec31780977795463c3b12f1c2387f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b5e609d03ec31780977795463c3b12f1c2387f3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b5e609d03ec31780977795463c3b12f1c2387f3/comments", "author": null, "committer": null, "parents": [{"sha": "344c6d1f1359cd894b72a1161aa6a2160b36a042", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/344c6d1f1359cd894b72a1161aa6a2160b36a042", "html_url": "https://github.com/Rust-GCC/gccrs/commit/344c6d1f1359cd894b72a1161aa6a2160b36a042"}], "stats": {"total": 352, "additions": 221, "deletions": 131}, "files": [{"sha": "84f842f2c4a72609890d4847336c35847997a9cd", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b5e609d03ec31780977795463c3b12f1c2387f3/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b5e609d03ec31780977795463c3b12f1c2387f3/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=5b5e609d03ec31780977795463c3b12f1c2387f3", "patch": "@@ -1,3 +1,22 @@\n+2001-12-04  Benjamin Kosnik  <bkoz@redhat.com>\n+\n+\t* src/Makefile.am (sources): Add ext-inst.cc.\n+\t* src/Makefile.in: Regenerate.\n+\t* src/ext-inst.cc: New file.\n+\t* include/bits/stl_threads.h: Format.\n+\t* src/globals.cc: Add instantiation for _S_swap_lock.\n+\n+\t* testsuite/18_support/numeric_limits.cc: Add numeric_limits<B>\n+\tinstantiation.\n+\n+2001-12-04  John David Anglin  <dave@hiauly1.hia.nrc.ca>\n+\n+\t* testsuite/22_locale/numpunct_members_wchar_t.cc: Only compile\n+\tand execute test01 if _GLIBCPP_USE_WCHAR_T is defined.\n+\t* testsuite/26_numerics/complex_inserters_extractors.cc: Provide\n+\tfor explicit instantiation of class std::basic_string<char,\n+\tgnu_char_traits, std::allocator<char> >.\n+\n 2001-12-03  Benjamin Kosnik  <bkoz@redhat.com>\n \n \t* testsuite/22_locale/collate.cc: Compile-only."}, {"sha": "0150cd58c85cbcbb9409752ae8cf9d8c5a141259", "filename": "libstdc++-v3/include/bits/stl_threads.h", "status": "modified", "additions": 132, "deletions": 120, "changes": 252, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b5e609d03ec31780977795463c3b12f1c2387f3/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_threads.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b5e609d03ec31780977795463c3b12f1c2387f3/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_threads.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_threads.h?ref=5b5e609d03ec31780977795463c3b12f1c2387f3", "patch": "@@ -53,22 +53,22 @@\n \n namespace std\n {\n-\n-// Class _Refcount_Base provides a type, _RC_t, a data member,\n-// _M_ref_count, and member functions _M_incr and _M_decr, which perform\n-// atomic preincrement/predecrement.  The constructor initializes \n-// _M_ref_count.\n-struct _Refcount_Base\n-{\n-  // The type _RC_t\n-  typedef size_t _RC_t;\n-  \n-  // The data member _M_ref_count\n-   volatile _RC_t _M_ref_count;\n-\n-  // Constructor\n-  __gthread_mutex_t _M_ref_count_lock;\n-  _Refcount_Base(_RC_t __n) : _M_ref_count(__n)\n+  // Class _Refcount_Base provides a type, _RC_t, a data member,\n+  // _M_ref_count, and member functions _M_incr and _M_decr, which perform\n+  // atomic preincrement/predecrement.  The constructor initializes \n+  // _M_ref_count.\n+  struct _Refcount_Base\n+  {\n+    // The type _RC_t\n+    typedef size_t _RC_t;\n+    \n+    // The data member _M_ref_count\n+    volatile _RC_t _M_ref_count;\n+    \n+    // Constructor\n+    __gthread_mutex_t _M_ref_count_lock;\n+\n+    _Refcount_Base(_RC_t __n) : _M_ref_count(__n)\n     {\n #ifdef __GTHREAD_MUTEX_INIT\n       __gthread_mutex_t __tmp = __GTHREAD_MUTEX_INIT;\n@@ -80,112 +80,128 @@ struct _Refcount_Base\n #endif\n     }\n \n-  void _M_incr() {\n-    __gthread_mutex_lock(&_M_ref_count_lock);\n-    ++_M_ref_count;\n-    __gthread_mutex_unlock(&_M_ref_count_lock);\n-  }\n-  _RC_t _M_decr() {\n-    __gthread_mutex_lock(&_M_ref_count_lock);\n-    volatile _RC_t __tmp = --_M_ref_count;\n-    __gthread_mutex_unlock(&_M_ref_count_lock);\n-    return __tmp;\n-  }\n-};\n+    void \n+    _M_incr() \n+    {\n+      __gthread_mutex_lock(&_M_ref_count_lock);\n+      ++_M_ref_count;\n+      __gthread_mutex_unlock(&_M_ref_count_lock);\n+    }\n \n-// Atomic swap on unsigned long\n-// This is guaranteed to behave as though it were atomic only if all\n-// possibly concurrent updates use _Atomic_swap.\n-// In some cases the operation is emulated with a lock.\n+    _RC_t \n+    _M_decr() \n+    {\n+      __gthread_mutex_lock(&_M_ref_count_lock);\n+      volatile _RC_t __tmp = --_M_ref_count;\n+      __gthread_mutex_unlock(&_M_ref_count_lock);\n+      return __tmp;\n+    }\n+  };\n+\n+  // Atomic swap on unsigned long\n+  // This is guaranteed to behave as though it were atomic only if all\n+  // possibly concurrent updates use _Atomic_swap.\n+  // In some cases the operation is emulated with a lock.\n #if defined (__GTHREAD_MUTEX_INIT)\n-// This could be optimized to use the atomicity.h abstraction layer.\n-// vyzo: simple _Atomic_swap implementation following the guidelines above\n-       // We use a template here only to get a unique initialized instance.\n-    template<int __dummy>\n-    struct _Swap_lock_struct {\n-        static __gthread_mutex_t _S_swap_lock;\n-    };\n-\n-    template<int __dummy>\n+  // This could be optimized to use the atomicity.h abstraction layer.\n+  // vyzo: simple _Atomic_swap implementation following the guidelines above\n+  // We use a template here only to get a unique initialized instance.\n+  template<int __dummy>\n+    struct _Swap_lock_struct \n+    { static __gthread_mutex_t _S_swap_lock; };\n+\n+  template<int __dummy>\n     __gthread_mutex_t\n     _Swap_lock_struct<__dummy>::_S_swap_lock = __GTHREAD_MUTEX_INIT;\n \n-    // This should be portable, but performance is expected\n-    // to be quite awful.  This really needs platform specific\n-    // code.\n-    inline unsigned long _Atomic_swap(unsigned long * __p, unsigned long __q) {\n-        __gthread_mutex_lock(&_Swap_lock_struct<0>::_S_swap_lock);\n-        unsigned long __result = *__p;\n-        *__p = __q;\n-        __gthread_mutex_unlock(&_Swap_lock_struct<0>::_S_swap_lock);\n-        return __result;\n-    }\n+  // This should be portable, but performance is expected to be quite\n+  // awful.  This really needs platform specific code.\n+  inline unsigned long \n+  _Atomic_swap(unsigned long * __p, unsigned long __q) \n+  {\n+    __gthread_mutex_lock(&_Swap_lock_struct<0>::_S_swap_lock);\n+    unsigned long __result = *__p;\n+    *__p = __q;\n+    __gthread_mutex_unlock(&_Swap_lock_struct<0>::_S_swap_lock);\n+    return __result;\n+  }\n #endif\n \n-// Locking class.  Note that this class *does not have a constructor*.\n-// It must be initialized either statically, with __STL_MUTEX_INITIALIZER,\n-// or dynamically, by explicitly calling the _M_initialize member function.\n-// (This is similar to the ways that a pthreads mutex can be initialized.)\n-// There are explicit member functions for acquiring and releasing the lock.\n+  // Locking class.  Note that this class *does not have a\n+  // constructor*.  It must be initialized either statically, with\n+  // __STL_MUTEX_INITIALIZER, or dynamically, by explicitly calling\n+  // the _M_initialize member function.  (This is similar to the ways\n+  // that a pthreads mutex can be initialized.)  There are explicit\n+  // member functions for acquiring and releasing the lock.\n \n-// There is no constructor because static initialization is essential for\n-// some uses, and only a class aggregate (see section 8.5.1 of the C++\n-// standard) can be initialized that way.  That means we must have no\n-// constructors, no base classes, no virtual functions, and no private or\n-// protected members.\n+  // There is no constructor because static initialization is\n+  // essential for some uses, and only a class aggregate (see section\n+  // 8.5.1 of the C++ standard) can be initialized that way.  That\n+  // means we must have no constructors, no base classes, no virtual\n+  // functions, and no private or protected members.\n \n #if !defined(__GTHREAD_MUTEX_INIT) && defined(__GTHREAD_MUTEX_INIT_FUNCTION)\n-extern __gthread_mutex_t _GLIBCPP_mutex;\n-extern __gthread_mutex_t *_GLIBCPP_mutex_address;\n-extern __gthread_once_t _GLIBCPP_once;\n-extern void _GLIBCPP_mutex_init (void);\n-extern void _GLIBCPP_mutex_address_init (void);\n+  extern __gthread_mutex_t _GLIBCPP_mutex;\n+  extern __gthread_mutex_t *_GLIBCPP_mutex_address;\n+  extern __gthread_once_t _GLIBCPP_once;\n+  extern void _GLIBCPP_mutex_init (void);\n+  extern void _GLIBCPP_mutex_address_init (void);\n #endif\n \n-struct _STL_mutex_lock\n-{\n-  // The class must be statically initialized with __STL_MUTEX_INITIALIZER.\n+  struct _STL_mutex_lock\n+  {\n+    // The class must be statically initialized with __STL_MUTEX_INITIALIZER.\n #if !defined(__GTHREAD_MUTEX_INIT) && defined(__GTHREAD_MUTEX_INIT_FUNCTION)\n-  volatile int _M_init_flag;\n-  __gthread_once_t _M_once;\n+    volatile int _M_init_flag;\n+    __gthread_once_t _M_once;\n #endif\n-  __gthread_mutex_t _M_lock;\n-  void _M_initialize() {\n+    __gthread_mutex_t _M_lock;\n+\n+    void \n+    _M_initialize() \n+    {\n #ifdef __GTHREAD_MUTEX_INIT\n-    // There should be no code in this path given the usage rules above.\n+      // There should be no code in this path given the usage rules above.\n #elif defined(__GTHREAD_MUTEX_INIT_FUNCTION)\n-    if (_M_init_flag) return;\n-    if (__gthread_once (&_GLIBCPP_once, _GLIBCPP_mutex_init) != 0\n-        && __gthread_active_p ())\n-      abort ();\n-    __gthread_mutex_lock (&_GLIBCPP_mutex);\n-    if (!_M_init_flag) {\n-\t// Even though we have a global lock, we use __gthread_once to be\n-\t// absolutely certain the _M_lock mutex is only initialized once on\n-\t// multiprocessor systems.\n-\t_GLIBCPP_mutex_address = &_M_lock;\n-\tif (__gthread_once (&_M_once, _GLIBCPP_mutex_address_init) != 0\n+      if (_M_init_flag) return;\n+      if (__gthread_once (&_GLIBCPP_once, _GLIBCPP_mutex_init) != 0\n+\t  && __gthread_active_p ())\n+\tabort ();\n+      __gthread_mutex_lock (&_GLIBCPP_mutex);\n+      if (!_M_init_flag) \n+\t{\n+\t  // Even though we have a global lock, we use __gthread_once to be\n+\t  // absolutely certain the _M_lock mutex is only initialized once on\n+\t  // multiprocessor systems.\n+\t  _GLIBCPP_mutex_address = &_M_lock;\n+\t  if (__gthread_once (&_M_once, _GLIBCPP_mutex_address_init) != 0\n \t    && __gthread_active_p ())\n-\t  abort ();\n-\t_M_init_flag = 1;\n-    }\n-    __gthread_mutex_unlock (&_GLIBCPP_mutex);\n+\t    abort ();\n+\t  _M_init_flag = 1;\n+\t}\n+      __gthread_mutex_unlock (&_GLIBCPP_mutex);\n #endif\n-  }\n-  void _M_acquire_lock() {\n+    }\n+\n+    void \n+    _M_acquire_lock() \n+    {\n #if !defined(__GTHREAD_MUTEX_INIT) && defined(__GTHREAD_MUTEX_INIT_FUNCTION)\n-    if (!_M_init_flag) _M_initialize();\n+      if (!_M_init_flag) _M_initialize();\n #endif\n-    __gthread_mutex_lock(&_M_lock);\n-  }\n-  void _M_release_lock() {\n+      __gthread_mutex_lock(&_M_lock);\n+    }\n+\n+    void \n+    _M_release_lock() \n+    {\n #if !defined(__GTHREAD_MUTEX_INIT) && defined(__GTHREAD_MUTEX_INIT_FUNCTION)\n-    if (!_M_init_flag) _M_initialize();\n+      if (!_M_init_flag) _M_initialize();\n #endif\n-    __gthread_mutex_unlock(&_M_lock);\n-  }\n-};\n-\n+      __gthread_mutex_unlock(&_M_lock);\n+    }\n+  };\n+  \n #ifdef __GTHREAD_MUTEX_INIT\n #define __STL_MUTEX_INITIALIZER = { __GTHREAD_MUTEX_INIT }\n #elif defined(__GTHREAD_MUTEX_INIT_FUNCTION)\n@@ -197,28 +213,24 @@ struct _STL_mutex_lock\n #endif\n #endif\n \n-// A locking class that uses _STL_mutex_lock.  The constructor takes a\n-// reference to an _STL_mutex_lock, and acquires a lock.  The\n-// destructor releases the lock.  It's not clear that this is exactly\n-// the right functionality.  It will probably change in the future.\n-\n-struct _STL_auto_lock\n-{\n-  _STL_mutex_lock& _M_lock;\n-  \n-  _STL_auto_lock(_STL_mutex_lock& __lock) : _M_lock(__lock)\n+  // A locking class that uses _STL_mutex_lock.  The constructor takes a\n+  // reference to an _STL_mutex_lock, and acquires a lock.  The\n+  // destructor releases the lock.  It's not clear that this is exactly\n+  // the right functionality.  It will probably change in the future.\n+  struct _STL_auto_lock\n+  {\n+    _STL_mutex_lock& _M_lock;\n+    \n+    _STL_auto_lock(_STL_mutex_lock& __lock) : _M_lock(__lock)\n     { _M_lock._M_acquire_lock(); }\n-  ~_STL_auto_lock() { _M_lock._M_release_lock(); }\n \n-private:\n-  void operator=(const _STL_auto_lock&);\n-  _STL_auto_lock(const _STL_auto_lock&);\n-};\n+    ~_STL_auto_lock() { _M_lock._M_release_lock(); }\n \n+  private:\n+    void operator=(const _STL_auto_lock&);\n+    _STL_auto_lock(const _STL_auto_lock&);\n+  };\n+  \n } // namespace std\n \n-#endif /* __SGI_STL_INTERNAL_THREADS_H */\n-\n-// Local Variables:\n-// mode:C++\n-// End:\n+#endif "}, {"sha": "0e12404600060a28438bc53258c7247343fce40a", "filename": "libstdc++-v3/src/Makefile.am", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b5e609d03ec31780977795463c3b12f1c2387f3/libstdc%2B%2B-v3%2Fsrc%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b5e609d03ec31780977795463c3b12f1c2387f3/libstdc%2B%2B-v3%2Fsrc%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2FMakefile.am?ref=5b5e609d03ec31780977795463c3b12f1c2387f3", "patch": "@@ -64,8 +64,9 @@ sources = \\\n \tcomplex_io.cc functexcept.cc globals.cc ios.cc limits.cc \\\n \tlocale.cc locale-inst.cc localename.cc \\\n \tcollate.cc messages.cc moneypunct.cc numpunct.cc time.cc \\\n+\tvterminate.cc \\\n \tmisc-inst.cc stdexcept.cc stl-inst.cc string-inst.cc strstream.cc \\\n-\tvalarray-inst.cc wstring-inst.cc concept-inst.cc vterminate.cc\n+\tvalarray-inst.cc wstring-inst.cc concept-inst.cc ext-inst.cc\n \n VPATH = $(top_srcdir)/src:$(top_srcdir)\n "}, {"sha": "643aebe74009bc14fc989f51395adef0bf201367", "filename": "libstdc++-v3/src/Makefile.in", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b5e609d03ec31780977795463c3b12f1c2387f3/libstdc%2B%2B-v3%2Fsrc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b5e609d03ec31780977795463c3b12f1c2387f3/libstdc%2B%2B-v3%2Fsrc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2FMakefile.in?ref=5b5e609d03ec31780977795463c3b12f1c2387f3", "patch": "@@ -189,8 +189,9 @@ sources = \\\n \tcomplex_io.cc functexcept.cc globals.cc ios.cc limits.cc \\\n \tlocale.cc locale-inst.cc localename.cc \\\n \tcollate.cc messages.cc moneypunct.cc numpunct.cc time.cc \\\n+\tvterminate.cc \\\n \tmisc-inst.cc stdexcept.cc stl-inst.cc string-inst.cc strstream.cc \\\n-\tvalarray-inst.cc wstring-inst.cc concept-inst.cc vterminate.cc\n+\tvalarray-inst.cc wstring-inst.cc concept-inst.cc ext-inst.cc\n \n \n VPATH = $(top_srcdir)/src:$(top_srcdir)\n@@ -266,9 +267,9 @@ LIBS = @LIBS@\n libstdc___la_OBJECTS =  basic_file.lo bitset.lo c++locale.lo cmath.lo \\\n codecvt.lo complex_io.lo functexcept.lo globals.lo ios.lo limits.lo \\\n locale.lo locale-inst.lo localename.lo collate.lo messages.lo \\\n-moneypunct.lo numpunct.lo time.lo misc-inst.lo stdexcept.lo stl-inst.lo \\\n-string-inst.lo strstream.lo valarray-inst.lo wstring-inst.lo \\\n-concept-inst.lo vterminate.lo\n+moneypunct.lo numpunct.lo time.lo vterminate.lo misc-inst.lo \\\n+stdexcept.lo stl-inst.lo string-inst.lo strstream.lo valarray-inst.lo \\\n+wstring-inst.lo concept-inst.lo ext-inst.lo\n CXXFLAGS = @CXXFLAGS@\n CXXCOMPILE = $(CXX) $(DEFS) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)\n CXXLD = $(CXX)"}, {"sha": "34cd4e6a9fdcd24f1fa529b1b74882f0762224ab", "filename": "libstdc++-v3/src/ext-inst.cc", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b5e609d03ec31780977795463c3b12f1c2387f3/libstdc%2B%2B-v3%2Fsrc%2Fext-inst.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b5e609d03ec31780977795463c3b12f1c2387f3/libstdc%2B%2B-v3%2Fsrc%2Fext-inst.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fext-inst.cc?ref=5b5e609d03ec31780977795463c3b12f1c2387f3", "patch": "@@ -0,0 +1,39 @@\n+// Explicit instantiation file.\n+\n+// Copyright (C) 2001 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+//\n+// ISO C++ 14882:\n+//\n+\n+#include <ext/rope>\n+\n+namespace std\n+{\n+  template const unsigned long rope<char, std::allocator<char> >::_S_min_len;\n+} // namespace std"}, {"sha": "20fe96994fbcc94be86245fe70acf2470a36aa05", "filename": "libstdc++-v3/src/globals.cc", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b5e609d03ec31780977795463c3b12f1c2387f3/libstdc%2B%2B-v3%2Fsrc%2Fglobals.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b5e609d03ec31780977795463c3b12f1c2387f3/libstdc%2B%2B-v3%2Fsrc%2Fglobals.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fglobals.cc?ref=5b5e609d03ec31780977795463c3b12f1c2387f3", "patch": "@@ -93,8 +93,9 @@ namespace std\n   // function call to initialize a mutex.  For example, see stl_threads.h.\n #if __GTHREADS\n #ifdef __GTHREAD_MUTEX_INIT\n-  // This path is not needed since static initialization of mutexs works\n-  // on this platform.\n+  // Need to provide explicit instantiations of static data for\n+  // systems with broken weak linkage support.\n+  template __gthread_mutex_t _Swap_lock_struct<0>::_S_swap_lock;\n #elif defined(__GTHREAD_MUTEX_INIT_FUNCTION)\n   __gthread_once_t _GLIBCPP_once = __GTHREAD_ONCE_INIT;\n   __gthread_mutex_t _GLIBCPP_mutex;"}, {"sha": "54249b5d0e645593956a0c8bc21745fbfb3090d5", "filename": "libstdc++-v3/src/string-inst.cc", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b5e609d03ec31780977795463c3b12f1c2387f3/libstdc%2B%2B-v3%2Fsrc%2Fstring-inst.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b5e609d03ec31780977795463c3b12f1c2387f3/libstdc%2B%2B-v3%2Fsrc%2Fstring-inst.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fstring-inst.cc?ref=5b5e609d03ec31780977795463c3b12f1c2387f3", "patch": "@@ -21,8 +21,7 @@\n // As a special exception, you may use this file as part of a free software\n // library without restriction.  Specifically, if other files instantiate\n // templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n+// this file and link it with other files to produce an executable, this// file does not by itself cause the resulting executable to be covered by\n // the GNU General Public License.  This exception does not however\n // invalidate any other reasons why the executable file might be covered by\n // the GNU General Public License."}, {"sha": "99450c6acd8c12770e99257f3d7917e8560eac7d", "filename": "libstdc++-v3/testsuite/18_support/numeric_limits.cc", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b5e609d03ec31780977795463c3b12f1c2387f3/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Fnumeric_limits.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b5e609d03ec31780977795463c3b12f1c2387f3/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Fnumeric_limits.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Fnumeric_limits.cc?ref=5b5e609d03ec31780977795463c3b12f1c2387f3", "patch": "@@ -92,7 +92,10 @@ template<typename T>\n     operator==(int i) { return i == key; }\n   };\n \n-struct B { };\n+struct B \n+{\n+  B(int i = 0) { }\n+};\n \n \n bool test01()\n@@ -139,6 +142,8 @@ bool test01()\n }\n \n // test linkage of the generic bits\n+template struct std::numeric_limits<B>;\n+\n void test02()\n {\n   typedef std::numeric_limits<B> b_nl_type;\n@@ -176,3 +181,9 @@ int main()\n \n     return 0;\n }\n+\n+\n+\n+\n+\n+"}, {"sha": "25694f4757ad8562783f8e39795715377a315b75", "filename": "libstdc++-v3/testsuite/22_locale/numpunct_members_wchar_t.cc", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b5e609d03ec31780977795463c3b12f1c2387f3/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fnumpunct_members_wchar_t.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b5e609d03ec31780977795463c3b12f1c2387f3/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fnumpunct_members_wchar_t.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fnumpunct_members_wchar_t.cc?ref=5b5e609d03ec31780977795463c3b12f1c2387f3", "patch": "@@ -26,6 +26,7 @@\n // XXX This test is not working for non-glibc locale models.\n // { dg-do run { xfail *-*-* } }\n \n+#ifdef _GLIBCPP_USE_WCHAR_T\n void test01()\n {\n   using namespace std;\n@@ -79,10 +80,12 @@ void test01()\n   VERIFY( dp2 != dp4 );\n   VERIFY( th2 != th4 );\n }\n+#endif\n \n int main()\n {\n+#ifdef _GLIBCPP_USE_WCHAR_T\n   test01();\n-\n+#endif\n   return 0;\n }"}, {"sha": "d304aa47b38905ac45b4aa5ccc5026d6789fd302", "filename": "libstdc++-v3/testsuite/26_numerics/complex_inserters_extractors.cc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b5e609d03ec31780977795463c3b12f1c2387f3/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fcomplex_inserters_extractors.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b5e609d03ec31780977795463c3b12f1c2387f3/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fcomplex_inserters_extractors.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fcomplex_inserters_extractors.cc?ref=5b5e609d03ec31780977795463c3b12f1c2387f3", "patch": "@@ -106,6 +106,7 @@ struct gnu_char_traits : public std::char_traits<char>\n { };\n \n typedef std::basic_ostringstream<char, gnu_char_traits> gnu_sstream;\n+template class std::basic_string<char, gnu_char_traits, std::allocator<char> >;\n \n void test02()\n {\n@@ -143,3 +144,6 @@ main()\n   return 0;\n }\n \n+\n+\n+"}]}