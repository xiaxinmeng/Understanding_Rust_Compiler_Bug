{"sha": "da574a866b86e92f0305e68ddb7f1993365fb5dd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGE1NzRhODY2Yjg2ZTkyZjAzMDVlNjhkZGI3ZjE5OTMzNjVmYjVkZA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-05-21T12:39:44Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-05-21T12:39:44Z"}, "message": "[multiple changes]\n\n2014-05-21  Robert Dewar  <dewar@adacore.com>\n\n\t* stand.adb (Tree_Read): Read missing entities.\n\t(Tree_Write): Write missing entities.\n\n2014-05-21  Ben Brosgol  <brosgol@adacore.com>\n\n\t* gnat_ugn.texi: Wordsmithing edits to Coupling Metrics Control\n\tsection in gnatmetric chapter.\n\n2014-05-21  Robert Dewar  <dewar@adacore.com>\n\n\t* exp_ch6.adb (Expand_Actuals): Spec moved here, since not used\n\toutside Exp_Ch6 (Expand_Actuals): Deal with proper insertion of\n\tpost-call copy write back (see detailed comment in code).\n\t* exp_ch6.ads (Expand_Actuals): Moved to body, not used outside\n\tExp_Ch6.\n\t* tbuild.ads: Minor reformatting.\n\n2014-05-21  Robert Dewar  <dewar@adacore.com>\n\n\t* stand.ads: Add warning about adding new entities and\n\tTree_Read/Tree_Write.\n\n2014-05-21  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_util.adb (Set_Entity_With_Checks): Don't complain about\n\treferences to restricted entities within the units in which they\n\tare declared.\n\n2014-05-21  Robert Dewar  <dewar@adacore.com>\n\n\t* gnat1drv.adb (Check_Bad_Body): Use Source_File_Is_Body to\n\tsimplify the needed test, and also deal with failure to catch\n\tsituations with non-standard names.\n\t* sinput-l.ads, sinput-l.adb (Source_File_Is_No_Body): New function\n\t(Source_File_Is_Subunit): Removed, no longer used.\n\n2014-05-21  Javier Miranda  <miranda@adacore.com>\n\n\t* exp_ch4.adb\n\t(Expand_Allocator_Expression.Apply_Accessibility_Check): for a\n\trenaming of an access to interface object there is no need to\n\tgenerate extra code to reference the tag.\n\nFrom-SVN: r210696", "tree": {"sha": "ba9f0ac533f629f4411df8124838123e84d56389", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ba9f0ac533f629f4411df8124838123e84d56389"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/da574a866b86e92f0305e68ddb7f1993365fb5dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da574a866b86e92f0305e68ddb7f1993365fb5dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/da574a866b86e92f0305e68ddb7f1993365fb5dd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da574a866b86e92f0305e68ddb7f1993365fb5dd/comments", "author": null, "committer": null, "parents": [{"sha": "77a40ec16aeae9e13a96cef15799dd992cd23106", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77a40ec16aeae9e13a96cef15799dd992cd23106", "html_url": "https://github.com/Rust-GCC/gccrs/commit/77a40ec16aeae9e13a96cef15799dd992cd23106"}], "stats": {"total": 650, "additions": 458, "deletions": 192}, "files": [{"sha": "e20056cf04e736cd4c3cbc4ce3e660c412391607", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da574a866b86e92f0305e68ddb7f1993365fb5dd/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da574a866b86e92f0305e68ddb7f1993365fb5dd/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=da574a866b86e92f0305e68ddb7f1993365fb5dd", "patch": "@@ -1,3 +1,48 @@\n+2014-05-21  Robert Dewar  <dewar@adacore.com>\n+\n+\t* stand.adb (Tree_Read): Read missing entities.\n+\t(Tree_Write): Write missing entities.\n+\n+2014-05-21  Ben Brosgol  <brosgol@adacore.com>\n+\n+\t* gnat_ugn.texi: Wordsmithing edits to Coupling Metrics Control\n+\tsection in gnatmetric chapter.\n+\n+2014-05-21  Robert Dewar  <dewar@adacore.com>\n+\n+\t* exp_ch6.adb (Expand_Actuals): Spec moved here, since not used\n+\toutside Exp_Ch6 (Expand_Actuals): Deal with proper insertion of\n+\tpost-call copy write back (see detailed comment in code).\n+\t* exp_ch6.ads (Expand_Actuals): Moved to body, not used outside\n+\tExp_Ch6.\n+\t* tbuild.ads: Minor reformatting.\n+\n+2014-05-21  Robert Dewar  <dewar@adacore.com>\n+\n+\t* stand.ads: Add warning about adding new entities and\n+\tTree_Read/Tree_Write.\n+\n+2014-05-21  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_util.adb (Set_Entity_With_Checks): Don't complain about\n+\treferences to restricted entities within the units in which they\n+\tare declared.\n+\n+2014-05-21  Robert Dewar  <dewar@adacore.com>\n+\n+\t* gnat1drv.adb (Check_Bad_Body): Use Source_File_Is_Body to\n+\tsimplify the needed test, and also deal with failure to catch\n+\tsituations with non-standard names.\n+\t* sinput-l.ads, sinput-l.adb (Source_File_Is_No_Body): New function\n+\t(Source_File_Is_Subunit): Removed, no longer used.\n+\n+2014-05-21  Javier Miranda  <miranda@adacore.com>\n+\n+\t* exp_ch4.adb\n+\t(Expand_Allocator_Expression.Apply_Accessibility_Check): for a\n+\trenaming of an access to interface object there is no need to\n+\tgenerate extra code to reference the tag.\n+\n 2014-05-21  Robert Dewar  <dewar@adacore.com>\n \n \t* errout.adb, erroutc.adb, erroutc.ads: Allow warning tag in pragma"}, {"sha": "9b225fe0224901c09ec7cc63580c7e81ced92238", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da574a866b86e92f0305e68ddb7f1993365fb5dd/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da574a866b86e92f0305e68ddb7f1993365fb5dd/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=da574a866b86e92f0305e68ddb7f1993365fb5dd", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -831,13 +831,25 @@ package body Exp_Ch4 is\n \n             --  Step 2: Create the accessibility comparison\n \n+            --  Reference the tag: for a renaming of an access to an interface\n+            --  object Obj_Ref already references the tag of the secondary\n+            --  dispatch table.\n+\n+            if Present (Parent (Entity (Obj_Ref)))\n+              and then Present (Renamed_Object (Entity (Obj_Ref)))\n+              and then Is_Interface (DesigT)\n+            then\n+               null;\n+\n             --  Generate:\n             --    Ref'Tag\n \n-            Obj_Ref :=\n-              Make_Attribute_Reference (Loc,\n-                Prefix         => Obj_Ref,\n-                Attribute_Name => Name_Tag);\n+            else\n+               Obj_Ref :=\n+                 Make_Attribute_Reference (Loc,\n+                   Prefix         => Obj_Ref,\n+                   Attribute_Name => Name_Tag);\n+            end if;\n \n             --  For tagged types, determine the accessibility level by looking\n             --  at the type specific data of the dispatch table. Generate:"}, {"sha": "2aa9dc714b3086597f43ae4626281afd282ebf45", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 130, "deletions": 36, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da574a866b86e92f0305e68ddb7f1993365fb5dd/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da574a866b86e92f0305e68ddb7f1993365fb5dd/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=da574a866b86e92f0305e68ddb7f1993365fb5dd", "patch": "@@ -165,6 +165,41 @@ package body Exp_Ch6 is\n    --  the values are not changed for the call, we know immediately that\n    --  we have an infinite recursion.\n \n+   procedure Expand_Actuals (N : in out Node_Id; Subp : Entity_Id);\n+   --  For each actual of an in-out or out parameter which is a numeric\n+   --  (view) conversion of the form T (A), where A denotes a variable,\n+   --  we insert the declaration:\n+   --\n+   --    Temp : T[ := T (A)];\n+   --\n+   --  prior to the call. Then we replace the actual with a reference to Temp,\n+   --  and append the assignment:\n+   --\n+   --    A := TypeA (Temp);\n+   --\n+   --  after the call. Here TypeA is the actual type of variable A. For out\n+   --  parameters, the initial declaration has no expression. If A is not an\n+   --  entity name, we generate instead:\n+   --\n+   --    Var  : TypeA renames A;\n+   --    Temp : T := Var;       --  omitting expression for out parameter.\n+   --    ...\n+   --    Var := TypeA (Temp);\n+   --\n+   --  For other in-out parameters, we emit the required constraint checks\n+   --  before and/or after the call.\n+   --\n+   --  For all parameter modes, actuals that denote components and slices of\n+   --  packed arrays are expanded into suitable temporaries.\n+   --\n+   --  For non-scalar objects that are possibly unaligned, add call by copy\n+   --  code (copy in for IN and IN OUT, copy out for OUT and IN OUT).\n+   --\n+   --  The parameter N is IN OUT because in some cases, the expansion code\n+   --  rewrites the call as an expression actions with the call inside. In\n+   --  this case N is reset to point to the inside call so that the caller\n+   --  can continue processing of this call.\n+\n    procedure Expand_Ctrl_Function_Call (N : Node_Id);\n    --  N is a function call which returns a controlled object. Transform the\n    --  call into a temporary which retrieves the returned object from the\n@@ -939,7 +974,7 @@ package body Exp_Ch6 is\n    -- Expand_Actuals --\n    --------------------\n \n-   procedure Expand_Actuals (N : Node_Id; Subp : Entity_Id) is\n+   procedure Expand_Actuals (N : in out Node_Id; Subp : Entity_Id) is\n       Loc       : constant Source_Ptr := Sloc (N);\n       Actual    : Node_Id;\n       Formal    : Entity_Id;\n@@ -976,10 +1011,10 @@ package body Exp_Ch6 is\n       --  the effect that this might lead to unaligned arguments.\n \n       function Make_Var (Actual : Node_Id) return Entity_Id;\n-      --  Returns an entity that refers to the given actual parameter,\n-      --  Actual (not including any type conversion). If Actual is an\n-      --  entity name, then this entity is returned unchanged, otherwise\n-      --  a renaming is created to provide an entity for the actual.\n+      --  Returns an entity that refers to the given actual parameter, Actual\n+      --  (not including any type conversion). If Actual is an entity name,\n+      --  then this entity is returned unchanged, otherwise a renaming is\n+      --  created to provide an entity for the actual.\n \n       procedure Reset_Packed_Prefix;\n       --  The expansion of a packed array component reference is delayed in\n@@ -1604,8 +1639,8 @@ package body Exp_Ch6 is\n                   --  Also pass by copy if change of representation\n \n                   or else not Same_Representation\n-                               (Etype (Formal),\n-                                Etype (Expression (Actual))))\n+                                (Etype (Formal),\n+                                 Etype (Expression (Actual))))\n             then\n                Add_Call_By_Copy_Code;\n \n@@ -1809,7 +1844,7 @@ package body Exp_Ch6 is\n                if In_Open_Scopes (Entity (Actual)) then\n                   Rewrite (Actual,\n                     (Make_Function_Call (Loc,\n-                     Name => New_Occurrence_Of (RTE (RE_Self), Loc))));\n+                       Name => New_Occurrence_Of (RTE (RE_Self), Loc))));\n                   Analyze (Actual);\n \n                --  A task type cannot otherwise appear as an actual\n@@ -1831,36 +1866,93 @@ package body Exp_Ch6 is\n          --  Cases where the call is not a member of a statement list\n \n          if not Is_List_Member (N) then\n-            declare\n-               P :  Node_Id := Parent (N);\n \n-            begin\n-               --  In Ada 2012 the call may be a function call in an expression\n-               --  (since OUT and IN OUT parameters are now allowed for such\n-               --  calls. The write-back of (in)-out parameters is handled\n-               --  by the back-end, but the constraint checks generated when\n-               --  subtypes of formal and actual don't match must be inserted\n-               --  in the form of assignments, at the nearest point after the\n-               --  declaration or statement that contains the call.\n-\n-               if Ada_Version >= Ada_2012\n-                 and then Nkind (N) = N_Function_Call\n-               then\n-                  while Nkind (P) not in N_Declaration\n-                    and then\n-                      Nkind (P) not in N_Statement_Other_Than_Procedure_Call\n-                  loop\n-                     P := Parent (P);\n-                  end loop;\n+            --  In Ada 2012 the call may be a function call in an expression\n+            --  (since OUT and IN OUT parameters are now allowed for such\n+            --  calls). The write-back of (in)-out parameters is handled\n+            --  by the back-end, but the constraint checks generated when\n+            --  subtypes of formal and actual don't match must be inserted\n+            --  in the form of assignments.\n \n-                  Insert_Actions_After (P, Post_Call);\n+            if Ada_Version >= Ada_2012\n+              and then Nkind (N) = N_Function_Call\n+            then\n+               --  We used to just do handle this by climbing up parents to\n+               --  a non-statement/declaration and then simply making a call\n+               --  to Insert_Actions_After (P, Post_Call), but that doesn't\n+               --  work. If we are in the middle of an expression, e.g. the\n+               --  condition of an IF, this call would insert after the IF\n+               --  statement, which is much too late to be doing the write\n+               --  back. For example:\n+\n+               --     if Clobber (X) then\n+               --        Put_Line (X'Img);\n+               --     else\n+               --        goto Junk\n+               --     end if;\n+\n+               --  Now assume Clobber changes X, if we put the write back\n+               --  after the IF, the Put_Line gets the wrong value and the\n+               --  goto causes the write back to be skipped completely.\n+\n+               --  To deal with this, we replace the call by\n+\n+               --    do\n+               --       Tnnn : function-result-type renames function-call;\n+               --       Post_Call actions\n+               --    in\n+               --       Tnnn;\n+               --    end;\n+\n+               --  Note: this won't do in Modify_Tree_For_C mode, but we\n+               --  will deal with that later (it will require creating a\n+               --  declaration for Temp, using Insert_Declaration) ???\n \n-               --  If not the special Ada 2012 case of a function call, then\n-               --  we must have the triggering statement of a triggering\n-               --  alternative or an entry call alternative, and we can add\n-               --  the post call stuff to the corresponding statement list.\n+               declare\n+                  Tnnn  : constant Entity_Id := Make_Temporary (Loc, 'T');\n+                  FRTyp : constant Entity_Id := Etype (N);\n+                  Name  : constant Node_Id   := Relocate_Node (N);\n \n-               else\n+               begin\n+                  Prepend_To (Post_Call,\n+                    Make_Object_Renaming_Declaration (Loc,\n+                      Defining_Identifier => Tnnn,\n+                      Subtype_Mark        => New_Occurrence_Of (FRTyp, Loc),\n+                      Name                => Name));\n+\n+                  Rewrite (N,\n+                    Make_Expression_With_Actions (Loc,\n+                      Actions    => Post_Call,\n+                      Expression => New_Occurrence_Of (Tnnn, Loc)));\n+\n+                  --  We don't want to just blindly call Analyze_And_Resolve\n+                  --  because that would cause unwanted recursion on the call.\n+                  --  So for a moment set the call as analyzed to prevent that\n+                  --  recursion, and get the rest analyzed properly, then reset\n+                  --  the analyzed flag, so our caller can continue.\n+\n+                  Set_Analyzed (Name, True);\n+                  Analyze_And_Resolve (N, FRTyp);\n+                  Set_Analyzed (Name, False);\n+\n+                  --  Reset calling argument to point to function call inside\n+                  --  the expression with actions so the caller can continue\n+                  --  to process the call.\n+\n+                  N := Name;\n+               end;\n+\n+            --  If not the special Ada 2012 case of a function call, then\n+            --  we must have the triggering statement of a triggering\n+            --  alternative or an entry call alternative, and we can add\n+            --  the post call stuff to the corresponding statement list.\n+\n+            else\n+               declare\n+                  P : Node_Id;\n+\n+               begin\n+                  P := Parent (N);\n                   pragma Assert (Nkind_In (P, N_Triggering_Alternative,\n                                               N_Entry_Call_Alternative));\n \n@@ -1870,15 +1962,17 @@ package body Exp_Ch6 is\n                   else\n                      Set_Statements (P, Post_Call);\n                   end if;\n-               end if;\n \n-            end;\n+                  return;\n+               end;\n+            end if;\n \n          --  Otherwise, normal case where N is in a statement sequence,\n          --  just put the post-call stuff after the call statement.\n \n          else\n             Insert_Actions_After (N, Post_Call);\n+            return;\n          end if;\n       end if;\n "}, {"sha": "801a5a2a61ab1d0730c214664bcddd11d47e4b4d", "filename": "gcc/ada/exp_ch6.ads", "status": "modified", "additions": 1, "deletions": 31, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da574a866b86e92f0305e68ddb7f1993365fb5dd/gcc%2Fada%2Fexp_ch6.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da574a866b86e92f0305e68ddb7f1993365fb5dd/gcc%2Fada%2Fexp_ch6.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.ads?ref=da574a866b86e92f0305e68ddb7f1993365fb5dd", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -37,36 +37,6 @@ package Exp_Ch6 is\n    procedure Expand_N_Subprogram_Body_Stub      (N : Node_Id);\n    procedure Expand_N_Subprogram_Declaration    (N : Node_Id);\n \n-   procedure Expand_Actuals (N : Node_Id; Subp : Entity_Id);\n-   --  For each actual of an in-out or out parameter which is a numeric\n-   --  (view) conversion of the form T (A), where A denotes a variable,\n-   --  we insert the declaration:\n-   --\n-   --    Temp : T[ := T (A)];\n-   --\n-   --  prior to the call. Then we replace the actual with a reference to Temp,\n-   --  and append the assignment:\n-   --\n-   --    A := TypeA (Temp);\n-   --\n-   --  after the call. Here TypeA is the actual type of variable A. For out\n-   --  parameters, the initial declaration has no expression. If A is not an\n-   --  entity name, we generate instead:\n-   --\n-   --    Var  : TypeA renames A;\n-   --    Temp : T := Var;       --  omitting expression for out parameter.\n-   --    ...\n-   --    Var := TypeA (Temp);\n-   --\n-   --  For other in-out parameters, we emit the required constraint checks\n-   --  before and/or after the call.\n-   --\n-   --  For all parameter modes, actuals that denote components and slices of\n-   --  packed arrays are expanded into suitable temporaries.\n-   --\n-   --  For non-scalar objects that are possibly unaligned, add call by copy\n-   --  code (copy in for IN and IN OUT, copy out for OUT and IN OUT).\n-\n    procedure Expand_Call (N : Node_Id);\n    --  This procedure contains common processing for Expand_N_Function_Call,\n    --  Expand_N_Procedure_Statement, and Expand_N_Entry_Call."}, {"sha": "87dcaca6afe2c7391f1fad478ec4aed9c5529dc6", "filename": "gcc/ada/gnat1drv.adb", "status": "modified", "additions": 10, "deletions": 15, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da574a866b86e92f0305e68ddb7f1993365fb5dd/gcc%2Fada%2Fgnat1drv.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da574a866b86e92f0305e68ddb7f1993365fb5dd/gcc%2Fada%2Fgnat1drv.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat1drv.adb?ref=da574a866b86e92f0305e68ddb7f1993365fb5dd", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -633,7 +633,6 @@ procedure Gnat1drv is\n          Sname := Unit_Name (Main_Unit);\n \n          --  If we do not already have a body name, then get the body name\n-         --  (but how can we have a body name here???)\n \n          if not Is_Body_Name (Sname) then\n             Sname := Get_Body_Name (Sname);\n@@ -651,19 +650,15 @@ procedure Gnat1drv is\n          --  to include both in a partition, this is diagnosed at bind time. In\n          --  Ada 83 mode this is not a warning case.\n \n-         --  Note: if weird file names are being used, we can have a situation\n-         --  where the file name that supposedly contains body in fact contains\n-         --  a spec, or we can't tell what it contains. Skip the error message\n-         --  in these cases.\n-\n-         --  Also ignore body that is nothing but pragma No_Body; (that's the\n-         --  whole point of this pragma, to be used this way and to cause the\n-         --  body file to be ignored in this context).\n+         --  Note that in general we do not give the message if the file in\n+         --  question does not look like a body. This includes weird cases,\n+         --  but in particular means that if the file is just a No_Body pragma,\n+         --  then we won't give the message (that's the whole point of this\n+         --  pragma, to be used this way and to cause the body file to be\n+         --  ignored in this context).\n \n          if Src_Ind /= No_Source_File\n-           and then Get_Expected_Unit_Type (Fname) = Expect_Body\n-           and then not Source_File_Is_Subunit (Src_Ind)\n-           and then not Source_File_Is_No_Body (Src_Ind)\n+           and then Source_File_Is_Body (Src_Ind)\n          then\n             Errout.Finalize (Last_Call => False);\n \n@@ -693,8 +688,8 @@ procedure Gnat1drv is\n             else\n                --  For generic instantiations, we never allow a body\n \n-               if Nkind (Original_Node (Unit (Main_Unit_Node)))\n-               in N_Generic_Instantiation\n+               if Nkind (Original_Node (Unit (Main_Unit_Node))) in\n+                                                    N_Generic_Instantiation\n                then\n                   Bad_Body_Error\n                     (\"generic instantiation for $$ does not allow a body\");"}, {"sha": "5cba4dd41514b6b52c30580451bff89eca283c71", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 76, "deletions": 62, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da574a866b86e92f0305e68ddb7f1993365fb5dd/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da574a866b86e92f0305e68ddb7f1993365fb5dd/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=da574a866b86e92f0305e68ddb7f1993365fb5dd", "patch": "@@ -16232,50 +16232,48 @@ Do not report the extra exit points for subprogram bodies\n @cindex Coupling metrics control in @command{gnatmetric}\n \n @noindent\n-@cindex Coupling metrics (in in @command{gnatmetric})\n+@cindex Coupling metrics (in @command{gnatmetric})\n Coupling metrics measure the dependencies between a given entity and other\n-entities the program consists of. The goal of these metrics is to estimate the\n-stability of the whole program considered as the collection of entities\n-(modules, classes etc.).\n+entities in the program. This information is useful since high coupling\n+may signal potential issues with maintainability as the program evolves.\n \n-Gnatmetric computes the following coupling metrics:\n+@command{gnatmetric} computes the following coupling metrics:\n \n @itemize @bullet\n \n @item\n-@emph{object-oriented coupling} - for classes in traditional object-oriented\n+@emph{object-oriented coupling}, for classes in traditional object-oriented\n sense;\n \n @item\n-@emph{unit coupling} - for all the program units making up a program;\n+@emph{unit coupling}, for all the program units making up a program;\n \n @item\n-@emph{control coupling} - this metric counts dependencies between a unit and\n-only those units that define subprograms;\n+@emph{control coupling}, reflecting dependencies between a unit and\n+other units that contain subprograms.\n @end itemize\n \n @noindent\n Two kinds of coupling metrics are computed:\n \n-@table @asis\n-@item fan-out coupling (efferent coupling)\n+@itemize @bullet\n+@item fan-out coupling (``efferent coupling''):\n @cindex fan-out coupling\n @cindex efferent coupling\n-the number of entities the given entity depends upon. It\n-estimates in what extent the given entity depends on the changes in\n-``external world''\n+the number of entities the given entity depends upon. This metric\n+reflects how the given entity depends on the changes in the\n+``external world''.\n \n-@item fan-in coupling (afferent coupling)\n+@item fan-in coupling (``afferent'' coupling):\n @cindex fan-in coupling\n @cindex afferent coupling\n the number of entities that depend on a given entity.\n-It estimates in what extent the ``external world'' depends on the changes in a\n-given entity\n-@end table\n+This metric reflects how the ``external world'' depends on the changes in a\n+given entity.\n+@end itemize\n \n @noindent\n-\n-Object-oriented coupling metrics are metrics that measure the dependencies\n+Object-oriented coupling metrics measure the dependencies\n between a given class (or a group of classes) and the other classes in the\n program. In this subsection the term ``class'' is used in its traditional\n object-oriented programming sense (an instantiable module that contains data\n@@ -16292,128 +16290,144 @@ that depend upon @code{K}.\n A category's fan-in coupling is the number of classes outside the\n category that depend on classes belonging to the category.\n \n-Ada's implementation of the object-oriented paradigm does not use the\n-traditional class notion, so the definition of the coupling\n+Ada's object-oriented paradigm separates the instantiable entity\n+(type) from the module (package), so the definition of the coupling\n metrics for Ada maps the class and class category notions\n onto Ada constructs.\n \n-For the coupling metrics, several kinds of modules -- a library package,\n-a library generic package, and a library generic package instantiation --\n-that define a tagged type or an interface type are\n-considered to be a class. A category consists of a library package (or\n+For the coupling metrics, several kinds of modules that define a tagged type\n+or an interface type  -- library packages, library generic packages, and\n+library generic package instantiations -- are considered to be classes.\n+A category consists of a library package (or\n a library generic package) that defines a tagged or an interface type,\n together with all its descendant (generic) packages that define tagged\n-or interface types. That is a\n-category is an Ada hierarchy of library-level program units. So class coupling\n-in case of Ada is called as tagged coupling, and category coupling - as\n-hierarchy coupling.\n-\n-For any package counted as a class, its body and subunits (if any) are\n-considered together with its spec when counting the dependencies, and coupling\n-metrics are reported for spec units only. For dependencies between classes,\n-the Ada semantic dependencies are considered. For object-oriented coupling\n-metrics, only dependencies on units that are considered as classes, are\n+or interface types. Thus a\n+category is an Ada hierarchy of library-level program units. Class\n+coupling in Ada is referred to as ``tagged coupling'', and category coupling\n+is referred to as ``hierarchy coupling''.\n+\n+For any package serving as a class, its body and subunits (if any) are\n+considered together with its spec when computing dependencies, and coupling\n+metrics are reported for spec units only. Dependencies between classes\n+mean Ada semantic dependencies. For object-oriented coupling\n+metrics, only dependencies on units treated as classes are\n considered.\n \n-For unit and control coupling also not compilation units but program units are\n-counted. That is, for a package, its spec, its body and its subunits (if any)\n-are considered as making up one unit, and the dependencies that are counted\n-are the dependencies of all these compilation units collected together as\n-the dependencies as a (whole) unit. And metrics are reported for spec\n-compilation units only (or for a subprogram body unit in case if there is no\n+Similarly, for unit and control coupling an entity is considered to be the\n+conceptual construct consisting of the entity's specification, body, and\n+any subunits (transitively).\n+@command{gnatmetric} computes\n+the dependencies of all these units as a whole, but\n+metrics are only reported for spec\n+units (or for a subprogram body unit in case if there is no\n separate spec for the given subprogram).\n \n-For unit coupling, dependencies between all kinds of program units are\n-considered. For control coupling, for each unit the dependencies of this unit\n-upon units that define subprograms are counted, so control fan-out coupling\n-is reported for all units, but control fan-in coupling - only for the units\n+For unit coupling, dependencies are computed between all kinds of program\n+units. For control coupling, the dependencies of a given unit are limited to\n+those units that define subprograms. Thus control fan-out coupling is reported\n+for all units, but control fan-in coupling is only reported for units\n that define subprograms.\n \n The following simple example illustrates the difference between unit coupling\n and control coupling metrics:\n \n @smallexample @c ada\n+@group\n package Lib_1 is\n     function F_1 (I : Integer) return Integer;\n end Lib_1;\n+@end group\n \n+@group\n package Lib_2 is\n     type T_2 is new Integer;\n end Lib_2;\n+@end group\n \n+@group\n package body Lib_1 is\n     function F_1 (I : Integer) return Integer is\n     begin\n        return I + 1;\n     end F_1;\n end Lib_1;\n+@end group\n \n+@group\n with Lib_2; use Lib_2;\n package Pack is\n     Var : T_2;\n     function Fun (I : Integer) return Integer;\n end Pack;\n+@end group\n \n+@group\n with Lib_1; use Lib_1;\n package body Pack is\n     function Fun (I : Integer) return Integer is\n     begin\n        return F_1 (I);\n     end Fun;\n end Pack;\n+@end group\n @end smallexample\n \n @noindent\n-if we apply @command{gnatmetric} with @code{--coupling-all} option to these\n-units, the result will be:\n+If we apply @command{gnatmetric} with the @option{--coupling-all} option to\n+these units, the result will be:\n \n @smallexample\n+@group\n Coupling metrics:\n =================\n     Unit Lib_1 (C:\\customers\\662\\L406-007\\lib_1.ads)\n        control fan-out coupling  : 0\n        control fan-in coupling   : 1\n        unit fan-out coupling     : 0\n        unit fan-in coupling      : 1\n+@end group\n \n+@group\n     Unit Pack (C:\\customers\\662\\L406-007\\pack.ads)\n        control fan-out coupling  : 1\n        control fan-in coupling   : 0\n        unit fan-out coupling     : 2\n        unit fan-in coupling      : 0\n+@end group\n \n+@group\n     Unit Lib_2 (C:\\customers\\662\\L406-007\\lib_2.ads)\n        control fan-out coupling  : 0\n        unit fan-out coupling     : 0\n        unit fan-in coupling      : 1\n+@end group\n @end smallexample\n \n @noindent\n The result does not contain values for object-oriented\n-coupling because none of the argument unit contains a tagged type and\n+coupling because none of the argument units contains a tagged type and\n therefore none of these units can be treated as a class.\n \n-@code{Pack} (considered as a program unit, that is spec+body) depends on two\n-units - @code{Lib_1} @code{and Lib_2}, therefore it has unit fan-out coupling\n-equals to 2. And nothing depend on it, so its unit fan-in coupling is 0 as\n-well as control fan-in coupling. Only one of the units @code{Pack} depends\n+The @code{Pack} package (spec and body) depends on two\n+units -- @code{Lib_1} @code{and Lib_2} -- and so its unit fan-out coupling\n+is 2. Since nothing depends on it, its unit fan-in coupling is 0, as\n+is its control fan-in coupling. Only one of the units @code{Pack} depends\n upon defines a subprogram, so its control fan-out coupling is 1.\n \n-@code{Lib_2} depends on nothing, so fan-out metrics for it are 0. It does\n-not define a subprogram, so control fan-in metric cannot be applied to it,\n-and there is one unit that depends on it (@code{Pack}), so it has\n-unit fan-in coupling equals to 1.\n+@code{Lib_2} depends on nothing, so its fan-out metrics are 0. It does\n+not define any subprograms, so it has no control fan-in metric.\n+One unit (@code{Pack}) depends on it , so its unit fan-in coupling is 1.\n \n @code{Lib_1} is similar to @code{Lib_2}, but it does define a subprogram.\n-So it has control fan-in coupling equals to 1 (because there is a unit\n+Its control fan-in coupling is 1 (because there is one unit\n depending on it).\n \n When computing coupling metrics, @command{gnatmetric} counts only\n dependencies between units that are arguments of the @command{gnatmetric}\n-call. Coupling metrics are program-wide (or project-wide) metrics, so to\n-get a valid result, you should call @command{gnatmetric} for\n-the whole set of sources that make up your program. It can be done\n-by calling @command{gnatmetric} from the GNAT driver with @option{-U}\n+invocation. Coupling metrics are program-wide (or project-wide) metrics, so\n+you should invoke @command{gnatmetric} for\n+the complete set of sources comprising your program. This can be done\n+by invoking @command{gnatmetric} from the GNAT driver with the @option{-U}\n option (see @ref{The GNAT Driver and Project Files} for details).\n \n By default, all the coupling metrics are disabled. You can use the following"}, {"sha": "042f44dbb9e4e725a477fe42627a54035df2faf0", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da574a866b86e92f0305e68ddb7f1993365fb5dd/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da574a866b86e92f0305e68ddb7f1993365fb5dd/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=da574a866b86e92f0305e68ddb7f1993365fb5dd", "patch": "@@ -15877,6 +15877,11 @@ package body Sem_Util is\n \n       if Restriction_Check_Required (No_Abort_Statements)\n         and then (Is_RTE (Val, RE_Abort_Task))\n+\n+        --  A special extra check, don't complain about a reference from within\n+        --  the Ada.Task_Identification package itself!\n+\n+        and then not In_Same_Extended_Unit (N, Val)\n       then\n          Check_Restriction (No_Abort_Statements, Post_Node);\n       end if;\n@@ -15892,6 +15897,10 @@ package body Sem_Util is\n                   Is_RTE (Val, RE_Exchange_Handler) or else\n                   Is_RTE (Val, RE_Detach_Handler)   or else\n                   Is_RTE (Val, RE_Reference))\n+        --  A special extra check, don't complain about a reference from within\n+        --  the Ada.Interrupts package itself!\n+\n+        and then not In_Same_Extended_Unit (N, Val)\n       then\n          Check_Restriction (No_Dynamic_Attachment, Post_Node);\n       end if;"}, {"sha": "c084555cd93caa6273be91c48ac1fcf8748643ec", "filename": "gcc/ada/sinput-l.adb", "status": "modified", "additions": 101, "deletions": 27, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da574a866b86e92f0305e68ddb7f1993365fb5dd/gcc%2Fada%2Fsinput-l.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da574a866b86e92f0305e68ddb7f1993365fb5dd/gcc%2Fada%2Fsinput-l.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinput-l.adb?ref=da574a866b86e92f0305e68ddb7f1993365fb5dd", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -795,9 +795,106 @@ package body Sinput.L is\n       Prep_Buffer (Prep_Buffer_Last) := C;\n    end Put_Char_In_Prep_Buffer;\n \n-   -----------------------------------\n-   -- Source_File_Is_Pragma_No_Body --\n-   -----------------------------------\n+   -------------------------\n+   -- Source_File_Is_Body --\n+   -------------------------\n+\n+   function Source_File_Is_Body (X : Source_File_Index) return Boolean is\n+      Pcount : Natural;\n+\n+   begin\n+      Initialize_Scanner (No_Unit, X);\n+\n+      --  Loop to look for subprogram or package body\n+\n+      loop\n+         case Token is\n+\n+            --  PRAGMA, WITH, USE (which can appear before a body)\n+\n+            when Tok_Pragma | Tok_With | Tok_Use =>\n+\n+               --  We just want to skip any of these, do it by skipping to a\n+               --  semicolon, but check for EOF, in case we have bad syntax.\n+\n+               loop\n+                  if Token = Tok_Semicolon then\n+                     Scan;\n+                     exit;\n+                  elsif Token = Tok_EOF then\n+                     return False;\n+                  else\n+                     Scan;\n+                  end if;\n+               end loop;\n+\n+            --  PACKAGE\n+\n+            when Tok_Package =>\n+               Scan; -- Past PACKAGE\n+\n+               --  We have a body if and only if BODY follows\n+\n+               return Token = Tok_Body;\n+\n+            --  FUNCTION or PROCEDURE\n+\n+            when Tok_Procedure | Tok_Function =>\n+               Pcount := 0;\n+\n+               --  Loop through tokens following PROCEDURE or FUNCTION\n+\n+               loop\n+                  Scan;\n+\n+                  case Token is\n+\n+                     --  For parens, count paren level (note that paren level\n+                     --  can get greater than 1 if we have default parameters).\n+\n+                     when Tok_Left_Paren =>\n+                        Pcount := Pcount + 1;\n+\n+                     when Tok_Right_Paren =>\n+                        Pcount := Pcount - 1;\n+\n+                     --  EOF means something weird, probably no body\n+\n+                     when Tok_EOF =>\n+                        return False;\n+\n+                     --  BEGIN or IS or END definitely means body is present\n+\n+                     when Tok_Begin | Tok_Is | Tok_End =>\n+                        return True;\n+\n+                     --  Semicolon means no body present if at outside any\n+                     --  parens. If within parens, ignore, since it could be\n+                     --  a parameter separator.\n+\n+                     when Tok_Semicolon =>\n+                        if Pcount = 0 then\n+                           return False;\n+                        end if;\n+\n+                     --  Skip anything else\n+\n+                     when others =>\n+                        null;\n+                  end case;\n+               end loop;\n+\n+            --  Anything else in main scan means we don't have a body\n+\n+            when others =>\n+               return False;\n+         end case;\n+      end loop;\n+   end Source_File_Is_Body;\n+\n+   ----------------------------\n+   -- Source_File_Is_No_Body --\n+   ----------------------------\n \n    function Source_File_Is_No_Body (X : Source_File_Index) return Boolean is\n    begin\n@@ -826,27 +923,4 @@ package body Sinput.L is\n       return Token = Tok_EOF;\n    end Source_File_Is_No_Body;\n \n-   ----------------------------\n-   -- Source_File_Is_Subunit --\n-   ----------------------------\n-\n-   function Source_File_Is_Subunit (X : Source_File_Index) return Boolean is\n-   begin\n-      Initialize_Scanner (No_Unit, X);\n-\n-      --  We scan past junk to the first interesting compilation unit token, to\n-      --  see if it is SEPARATE. We ignore WITH keywords during this and also\n-      --  PRIVATE. The reason for ignoring PRIVATE is that it handles some\n-      --  error situations, and also to handle PRIVATE WITH in Ada 2005 mode.\n-\n-      while Token = Tok_With\n-        or else Token = Tok_Private\n-        or else (Token not in Token_Class_Cunit and then Token /= Tok_EOF)\n-      loop\n-         Scan;\n-      end loop;\n-\n-      return Token = Tok_Separate;\n-   end Source_File_Is_Subunit;\n-\n end Sinput.L;"}, {"sha": "c1ac9c512fc44e1d2b70f263423c14162ecdf3df", "filename": "gcc/ada/sinput-l.ads", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da574a866b86e92f0305e68ddb7f1993365fb5dd/gcc%2Fada%2Fsinput-l.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da574a866b86e92f0305e68ddb7f1993365fb5dd/gcc%2Fada%2Fsinput-l.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinput-l.ads?ref=da574a866b86e92f0305e68ddb7f1993365fb5dd", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2008, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -64,19 +64,16 @@ package Sinput.L is\n    --  Called on completing the parsing of a source file. This call completes\n    --  the source file table entry for the current source file.\n \n+   function Source_File_Is_Body (X : Source_File_Index) return Boolean;\n+   --  Returns true if the designated source file contains a subprogram body\n+   --  or a package body. This is a limited scan just to determine the answer\n+   --  to this question..\n+\n    function Source_File_Is_No_Body (X : Source_File_Index) return Boolean;\n    --  Returns true if the designated source file contains pragma No_Body;\n    --  and no other tokens. If the source file contains anything other than\n    --  this sequence of three tokens, then False is returned.\n \n-   function Source_File_Is_Subunit (X : Source_File_Index) return Boolean;\n-   --  This function determines if a source file represents a subunit. It\n-   --  works by scanning for the first compilation unit token, and returning\n-   --  True if it is the token SEPARATE. It will return False otherwise,\n-   --  meaning that the file cannot possibly be a legal subunit. This\n-   --  function does NOT do a complete parse of the file, or build a\n-   --  tree. It is used in the main driver in the check for bad bodies.\n-\n    -------------------------------------------------\n    -- Subprograms for Dealing With Instantiations --\n    -------------------------------------------------"}, {"sha": "b2c6a3fa4737bc860ba1ac337253763616074fba", "filename": "gcc/ada/stand.adb", "status": "modified", "additions": 56, "deletions": 3, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da574a866b86e92f0305e68ddb7f1993365fb5dd/gcc%2Fada%2Fstand.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da574a866b86e92f0305e68ddb7f1993365fb5dd/gcc%2Fada%2Fstand.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fstand.adb?ref=da574a866b86e92f0305e68ddb7f1993365fb5dd", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2013,  Free Software Foundation, Inc.        --\n+--          Copyright (C) 1992-2014,  Free Software Foundation, Inc.        --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -29,6 +29,7 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+with Elists;  use Elists;\n with System;  use System;\n with Tree_IO; use Tree_IO;\n \n@@ -46,9 +47,32 @@ package body Stand is\n       Tree_Read_Int (Int (Standard_Package_Node));\n       Tree_Read_Int (Int (Last_Standard_Node_Id));\n       Tree_Read_Int (Int (Last_Standard_List_Id));\n+\n+      Tree_Read_Int (Int (Boolean_Literals (False)));\n+      Tree_Read_Int (Int (Boolean_Literals (True)));\n+\n       Tree_Read_Int (Int (Standard_Void_Type));\n       Tree_Read_Int (Int (Standard_Exception_Type));\n       Tree_Read_Int (Int (Standard_A_String));\n+      Tree_Read_Int (Int (Standard_A_Char));\n+      Tree_Read_Int (Int (Standard_Debug_Renaming_Type));\n+\n+      --  Deal with Predefined_Float_Types, which is an Elist. We wrote the\n+      --  entities out in sequence, terminated by an Empty entry.\n+\n+      declare\n+         Elmt : Entity_Id;\n+      begin\n+         Predefined_Float_Types := New_Elmt_List;\n+         loop\n+            Tree_Read_Int (Int (Elmt));\n+            exit when Elmt = Empty;\n+            Append_Elmt (Elmt, Predefined_Float_Types);\n+         end loop;\n+      end;\n+\n+      --  Remainder of special entities\n+\n       Tree_Read_Int (Int (Any_Id));\n       Tree_Read_Int (Int (Any_Type));\n       Tree_Read_Int (Int (Any_Access));\n@@ -59,23 +83,25 @@ package body Stand is\n       Tree_Read_Int (Int (Any_Discrete));\n       Tree_Read_Int (Int (Any_Fixed));\n       Tree_Read_Int (Int (Any_Integer));\n+      Tree_Read_Int (Int (Any_Modular));\n       Tree_Read_Int (Int (Any_Numeric));\n       Tree_Read_Int (Int (Any_Real));\n       Tree_Read_Int (Int (Any_Scalar));\n       Tree_Read_Int (Int (Any_String));\n+      Tree_Read_Int (Int (Raise_Type));\n       Tree_Read_Int (Int (Universal_Integer));\n       Tree_Read_Int (Int (Universal_Real));\n       Tree_Read_Int (Int (Universal_Fixed));\n       Tree_Read_Int (Int (Standard_Integer_8));\n       Tree_Read_Int (Int (Standard_Integer_16));\n       Tree_Read_Int (Int (Standard_Integer_32));\n       Tree_Read_Int (Int (Standard_Integer_64));\n-      Tree_Read_Int (Int (Standard_Unsigned_64));\n       Tree_Read_Int (Int (Standard_Short_Short_Unsigned));\n       Tree_Read_Int (Int (Standard_Short_Unsigned));\n       Tree_Read_Int (Int (Standard_Unsigned));\n       Tree_Read_Int (Int (Standard_Long_Unsigned));\n       Tree_Read_Int (Int (Standard_Long_Long_Unsigned));\n+      Tree_Read_Int (Int (Standard_Unsigned_64));\n       Tree_Read_Int (Int (Abort_Signal));\n       Tree_Read_Int (Int (Standard_Op_Rotate_Left));\n       Tree_Read_Int (Int (Standard_Op_Rotate_Right));\n@@ -96,9 +122,34 @@ package body Stand is\n       Tree_Write_Int (Int (Standard_Package_Node));\n       Tree_Write_Int (Int (Last_Standard_Node_Id));\n       Tree_Write_Int (Int (Last_Standard_List_Id));\n+\n+      Tree_Write_Int (Int (Boolean_Literals (False)));\n+      Tree_Write_Int (Int (Boolean_Literals (True)));\n+\n       Tree_Write_Int (Int (Standard_Void_Type));\n       Tree_Write_Int (Int (Standard_Exception_Type));\n       Tree_Write_Int (Int (Standard_A_String));\n+      Tree_Write_Int (Int (Standard_A_Char));\n+      Tree_Write_Int (Int (Standard_Debug_Renaming_Type));\n+\n+      --  Deal with Predefined_Float_Types, which is an Elist. Write the\n+      --  entities out in sequence, terminated by an Empty entry.\n+\n+      declare\n+         Elmt : Elmt_Id;\n+\n+      begin\n+         Elmt := First_Elmt (Predefined_Float_Types);\n+         while Present (Elmt) loop\n+            Tree_Write_Int (Int (Node (Elmt)));\n+            Next_Elmt (Elmt);\n+         end loop;\n+\n+         Tree_Write_Int (Int (Empty));\n+      end;\n+\n+      --  Remainder of special entries\n+\n       Tree_Write_Int (Int (Any_Id));\n       Tree_Write_Int (Int (Any_Type));\n       Tree_Write_Int (Int (Any_Access));\n@@ -109,23 +160,25 @@ package body Stand is\n       Tree_Write_Int (Int (Any_Discrete));\n       Tree_Write_Int (Int (Any_Fixed));\n       Tree_Write_Int (Int (Any_Integer));\n+      Tree_Write_Int (Int (Any_Modular));\n       Tree_Write_Int (Int (Any_Numeric));\n       Tree_Write_Int (Int (Any_Real));\n       Tree_Write_Int (Int (Any_Scalar));\n       Tree_Write_Int (Int (Any_String));\n+      Tree_Write_Int (Int (Raise_Type));\n       Tree_Write_Int (Int (Universal_Integer));\n       Tree_Write_Int (Int (Universal_Real));\n       Tree_Write_Int (Int (Universal_Fixed));\n       Tree_Write_Int (Int (Standard_Integer_8));\n       Tree_Write_Int (Int (Standard_Integer_16));\n       Tree_Write_Int (Int (Standard_Integer_32));\n       Tree_Write_Int (Int (Standard_Integer_64));\n-      Tree_Write_Int (Int (Standard_Unsigned_64));\n       Tree_Write_Int (Int (Standard_Short_Short_Unsigned));\n       Tree_Write_Int (Int (Standard_Short_Unsigned));\n       Tree_Write_Int (Int (Standard_Unsigned));\n       Tree_Write_Int (Int (Standard_Long_Unsigned));\n       Tree_Write_Int (Int (Standard_Long_Long_Unsigned));\n+      Tree_Write_Int (Int (Standard_Unsigned_64));\n       Tree_Write_Int (Int (Abort_Signal));\n       Tree_Write_Int (Int (Standard_Op_Rotate_Left));\n       Tree_Write_Int (Int (Standard_Op_Rotate_Right));"}, {"sha": "6bcd8cbeb759374056245a3a8fb5ca2e6efdbec6", "filename": "gcc/ada/stand.ads", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da574a866b86e92f0305e68ddb7f1993365fb5dd/gcc%2Fada%2Fstand.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da574a866b86e92f0305e68ddb7f1993365fb5dd/gcc%2Fada%2Fstand.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fstand.ads?ref=da574a866b86e92f0305e68ddb7f1993365fb5dd", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -37,6 +37,11 @@ with Types; use Types;\n \n package Stand is\n \n+   --  Warning: the entities defined in this package are written out by the\n+   --  Tree_Write routine, and read back in by the Tree_Read routine, so be\n+   --  sure to modify these two routines if you add entities that are not\n+   --  part of Standard_Entity.\n+\n    type Standard_Entity_Type is (\n    --  This enumeration type contains an entry for each name in Standard\n "}, {"sha": "507dca41bf1c577630dbb247f939e896d85ff80e", "filename": "gcc/ada/tbuild.ads", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da574a866b86e92f0305e68ddb7f1993365fb5dd/gcc%2Fada%2Ftbuild.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da574a866b86e92f0305e68ddb7f1993365fb5dd/gcc%2Fada%2Ftbuild.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftbuild.ads?ref=da574a866b86e92f0305e68ddb7f1993365fb5dd", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -205,8 +205,6 @@ package Tbuild is\n    --  captures the value of an expression (e.g. an aggregate). It should be\n    --  set whenever possible to point to the expression that is being captured.\n    --  This is provided to get better error messages, e.g. from CodePeer.\n-   --\n-   --  Make_Temp_Id would probably be a better name for this function???\n \n    function Make_Unsuppress_Block\n      (Loc   : Source_Ptr;"}]}