{"sha": "f4e72d6e0038f6c97c11336f797f1a37971fd562", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjRlNzJkNmUwMDM4ZjZjOTdjMTEzMzZmNzk3ZjFhMzc5NzFmZDU2Mg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2000-02-28T12:21:24Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2000-02-28T12:21:24Z"}, "message": "lcm.c: Minor reformatting throughout.\n\n\t* lcm.c: Minor reformatting throughout.\n\t(reg_dies, reg_becomes_live): Properly handle multiple hard regs.\n\nFrom-SVN: r32234", "tree": {"sha": "a740dddedc492eec88bea56059fe0d4d0131de2b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a740dddedc492eec88bea56059fe0d4d0131de2b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f4e72d6e0038f6c97c11336f797f1a37971fd562", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4e72d6e0038f6c97c11336f797f1a37971fd562", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f4e72d6e0038f6c97c11336f797f1a37971fd562", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4e72d6e0038f6c97c11336f797f1a37971fd562/comments", "author": null, "committer": null, "parents": [{"sha": "98c3b85006a1603e0261a1c7d1ebc8cd08169419", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98c3b85006a1603e0261a1c7d1ebc8cd08169419", "html_url": "https://github.com/Rust-GCC/gccrs/commit/98c3b85006a1603e0261a1c7d1ebc8cd08169419"}], "stats": {"total": 313, "additions": 154, "deletions": 159}, "files": [{"sha": "66e9939065d7e37822267440c5e3d47d6153e624", "filename": "gcc/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4e72d6e0038f6c97c11336f797f1a37971fd562/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4e72d6e0038f6c97c11336f797f1a37971fd562/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f4e72d6e0038f6c97c11336f797f1a37971fd562", "patch": "@@ -5,6 +5,9 @@ Mon Feb 28 13:07:19 MET 2000  Jan Hubicka  <jh@suse.cz>\n \n Mon Feb 28 07:03:27 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n+\t* lcm.c: Minor reformatting throughout.\n+\t(reg_dies, reg_becomes_live): Properly handle multiple hard regs.\n+\t\n \t* toplev.c (rest_of_compilation): Account for time in\n \toptimize_mode_switching.\n "}, {"sha": "2d054d10a94f3bcf0989526d08fb02bd8f84cc94", "filename": "gcc/lcm.c", "status": "modified", "additions": 151, "deletions": 159, "changes": 310, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4e72d6e0038f6c97c11336f797f1a37971fd562/gcc%2Flcm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4e72d6e0038f6c97c11336f797f1a37971fd562/gcc%2Flcm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flcm.c?ref=f4e72d6e0038f6c97c11336f797f1a37971fd562", "patch": "@@ -1,5 +1,4 @@\n-/* Generic partial redundancy elimination with lazy code motion\n-   support.\n+/* Generic partial redundancy elimination with lazy code motion support.\n    Copyright (C) 1998, 1999, 2000 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n@@ -52,7 +51,6 @@ Boston, MA 02111-1307, USA.  */\n \n #include \"config.h\"\n #include \"system.h\"\n-\n #include \"rtl.h\"\n #include \"regs.h\"\n #include \"hard-reg-set.h\"\n@@ -62,32 +60,38 @@ Boston, MA 02111-1307, USA.  */\n #include \"recog.h\"\n #include \"basic-block.h\"\n #include \"tm_p.h\"\n+\n /* We want target macros for the mode switching code to be able to refer\n    to instruction attribute values.  */\n #include \"insn-attr.h\"\n \n /* Edge based LCM routines.  */\n-static void compute_antinout_edge  PARAMS ((sbitmap *, sbitmap *,\n-\t\t\t\t\t   sbitmap *, sbitmap *));\n-static void compute_earliest  PARAMS ((struct edge_list *, int, sbitmap *,\n-\t\t\t\t     sbitmap *, sbitmap *, sbitmap *,\n-\t\t\t\t     sbitmap *));\n-static void compute_laterin  PARAMS ((struct edge_list *, sbitmap *,\n-\t\t\t\t    sbitmap *, sbitmap *, sbitmap *));\n-static void compute_insert_delete  PARAMS ((struct edge_list *edge_list,\n-\t\t\t\t\t   sbitmap *, sbitmap *, sbitmap *,\n-\t\t\t\t\t   sbitmap *, sbitmap *));\n+static void compute_antinout_edge\tPARAMS ((sbitmap *, sbitmap *,\n+\t\t\t\t\t\t sbitmap *, sbitmap *));\n+static void compute_earliest\t\tPARAMS ((struct edge_list *, int,\n+\t\t\t\t\t\t sbitmap *, sbitmap *,\n+\t\t\t\t\t\t sbitmap *, sbitmap *,\n+\t\t\t\t\t\t sbitmap *));\n+static void compute_laterin\t\tPARAMS ((struct edge_list *, sbitmap *,\n+\t\t\t\t\t\t sbitmap *, sbitmap *,\n+\t\t\t\t\t\t sbitmap *));\n+static void compute_insert_delete\tPARAMS ((struct edge_list *edge_list,\n+\t\t\t\t\t\t sbitmap *, sbitmap *,\n+\t\t\t\t\t\t sbitmap *, sbitmap *,\n+\t\t\t\t\t\t sbitmap *));\n \n /* Edge based LCM routines on a reverse flowgraph.  */\n-static void compute_farthest\tPARAMS ((struct edge_list *, int, sbitmap *,\n-\t\t\t\t\t sbitmap *, sbitmap*, sbitmap *,\n-\t\t\t\t\t sbitmap *));\n-static void compute_nearerout\tPARAMS ((struct edge_list *, sbitmap *,\n-\t\t\t\t       sbitmap *, sbitmap *, sbitmap *));\n-static void compute_rev_insert_delete  PARAMS ((struct edge_list *edge_list,\n-\t\t\t\t\t       sbitmap *, sbitmap *, sbitmap *,\n-\t\t\t\t\t       sbitmap *, sbitmap *));\n-\n+static void compute_farthest\t\tPARAMS ((struct edge_list *, int,\n+\t\t\t\t\t\t sbitmap *, sbitmap *,\n+\t\t\t\t\t\t sbitmap*, sbitmap *,\n+\t\t\t\t\t\t sbitmap *));\n+static void compute_nearerout\t\tPARAMS ((struct edge_list *, sbitmap *,\n+\t\t\t\t\t\t sbitmap *, sbitmap *,\n+\t\t\t\t\t\t sbitmap *));\n+static void compute_rev_insert_delete\tPARAMS ((struct edge_list *edge_list,\n+\t\t\t\t\t\t sbitmap *, sbitmap *,\n+\t\t\t\t\t\t sbitmap *, sbitmap *,\n+\t\t\t\t\t\t sbitmap *));\n \f\n /* Edge based lcm routines.  */\n \n@@ -109,8 +113,8 @@ compute_antinout_edge (antloc, transp, antin, antout)\n   /* Allocate a worklist array/queue.  Entries are only added to the\n      list if they were not already on the list.  So the size is\n      bounded by the number of basic blocks.  */\n-  tos = worklist = (basic_block *) xmalloc (sizeof (basic_block)\n-\t\t\t\t\t    * n_basic_blocks);\n+  tos = worklist\n+    = (basic_block *) xmalloc (sizeof (basic_block) * n_basic_blocks);\n \n   /* We want a maximal solution, so make an optimistic initialization of\n      ANTIN.  */\n@@ -137,12 +141,10 @@ compute_antinout_edge (antloc, transp, antin, antout)\n       bb = b->index;\n \n       if (b->aux == EXIT_BLOCK_PTR)\n-\t{\n-\t  /* Do not clear the aux field for blocks which are\n-\t     predecessors of the EXIT block.  That way we never\n-\t     add then to the worklist again.  */\n-\t  sbitmap_zero (antout[bb]);\n-\t}\n+\t/* Do not clear the aux field for blocks which are predecessors of\n+\t   the EXIT block.  That way we never add then to the worklist\n+\t   again.  */\n+\tsbitmap_zero (antout[bb]);\n       else\n \t{\n \t  /* Clear the aux field of this block so that it can be added to\n@@ -152,24 +154,22 @@ compute_antinout_edge (antloc, transp, antin, antout)\n \t}\n \n       if (sbitmap_a_or_b_and_c (antin[bb], antloc[bb], transp[bb], antout[bb]))\n-\t{\n-\t  /* If the in state of this block changed, then we need\n-\t     to add the predecessors of this block to the worklist\n-\t     if they are not already on the worklist.  */\n-          for (e = b->pred; e; e = e->pred_next)\n+\t/* If the in state of this block changed, then we need\n+\t   to add the predecessors of this block to the worklist\n+\t   if they are not already on the worklist.  */\n+\tfor (e = b->pred; e; e = e->pred_next)\n+\t  if (!e->src->aux && e->src != ENTRY_BLOCK_PTR)\n \t    {\n-\t      if (!e->src->aux && e->src != ENTRY_BLOCK_PTR)\n-\t        {\n-\t          *tos++ = e->src;\n-\t          e->src->aux = e;\n-\t        }\n+\t      *tos++ = e->src;\n+\t      e->src->aux = e;\n \t    }\n-\t}\n     }\n+\n   free (tos);\n }\n \n /* Compute the earliest vector for edge based lcm.  */\n+\n static void\n compute_earliest (edge_list, n_exprs, antin, antout, avout, kill, earliest)\n      struct edge_list *edge_list;\n@@ -194,19 +194,18 @@ compute_earliest (edge_list, n_exprs, antin, antout, avout, kill, earliest)\n       else\n         {\n \t  if (succ == EXIT_BLOCK_PTR)\n-\t    {\n-\t      sbitmap_zero (earliest[x]);\n-\t    }\n+\t    sbitmap_zero (earliest[x]);\n \t  else\n \t    {\n \t      sbitmap_difference (difference, antin[succ->index], \n \t      \t\t\t  avout[pred->index]);\n \t      sbitmap_not (temp_bitmap, antout[pred->index]);\n-\t      sbitmap_a_and_b_or_c (earliest[x], difference, kill[pred->index], \n-\t\t\t\t    temp_bitmap);\n+\t      sbitmap_a_and_b_or_c (earliest[x], difference,\n+\t\t\t\t    kill[pred->index], temp_bitmap);\n \t    }\n \t}\n     }\n+\n   free (temp_bitmap);\n   free (difference);\n }\n@@ -254,8 +253,8 @@ compute_laterin (edge_list, earliest, antloc, later, laterin)\n   /* Allocate a worklist array/queue.  Entries are only added to the\n      list if they were not already on the list.  So the size is\n      bounded by the number of basic blocks.  */\n-  tos = worklist = (basic_block *) xmalloc (sizeof (basic_block)\n-\t\t\t\t\t    * (n_basic_blocks + 1));\n+  tos = worklist\n+    = (basic_block *) xmalloc (sizeof (basic_block) * (n_basic_blocks + 1));\n \n   /* Initialize a mapping from each edge to its index.  */\n   for (i = 0; i < num_edges; i++)\n@@ -278,7 +277,7 @@ compute_laterin (edge_list, earliest, antloc, later, laterin)\n      the entry block.  That edge should always have a LATER value the\n      same as EARLIEST for that edge.  */\n   for (e = ENTRY_BLOCK_PTR->succ; e; e = e->succ_next)\n-    sbitmap_copy (later[(size_t)e->aux], earliest[(size_t)e->aux]);\n+    sbitmap_copy (later[(size_t) e->aux], earliest[(size_t) e->aux]);\n \n   /* Add all the blocks to the worklist.  This prevents an early exit from\n      the loop given our optimistic initialization of LATER above.  */\n@@ -304,21 +303,17 @@ compute_laterin (edge_list, earliest, antloc, later, laterin)\n \n       /* Calculate LATER for all outgoing edges.  */\n       for (e = b->succ; e != NULL; e = e->succ_next)\n-\t{\n-\t  if (sbitmap_union_of_diff (later[(size_t) e->aux],\n-\t\t\t\t     earliest[(size_t) e->aux],\n-\t\t\t\t     laterin[e->src->index],\n-\t\t\t\t     antloc[e->src->index]))\n-\t    {\n-\t      /* If LATER for an outgoing edge was changed, then we need\n-\t\t to add the target of the outgoing edge to the worklist.  */\n-\t      if (e->dest != EXIT_BLOCK_PTR && e->dest->aux == 0)\n-\t\t{\n-\t\t  *tos++ = e->dest;\n-\t\t  e->dest->aux = e;\n-\t\t}\n-\t    }\n-        }\n+\tif (sbitmap_union_of_diff (later[(size_t) e->aux],\n+\t\t\t\t   earliest[(size_t) e->aux],\n+\t\t\t\t   laterin[e->src->index],\n+\t\t\t\t   antloc[e->src->index])\n+\t    /* If LATER for an outgoing edge was changed, then we need\n+\t       to add the target of the outgoing edge to the worklist.  */\n+\t    && e->dest != EXIT_BLOCK_PTR && e->dest->aux == 0)\n+\t  {\n+\t    *tos++ = e->dest;\n+\t    e->dest->aux = e;\n+\t  }\n     }\n \n   /* Computation of insertion and deletion points requires computing LATERIN\n@@ -334,6 +329,7 @@ compute_laterin (edge_list, earliest, antloc, later, laterin)\n }\n \n /* Compute the insertion and deletion points for edge based LCM.  */\n+\n static void\n compute_insert_delete (edge_list, antloc, later, laterin,\n \t\t       insert, delete)\n@@ -348,17 +344,17 @@ compute_insert_delete (edge_list, antloc, later, laterin,\n   for (x = 0; x < NUM_EDGES (edge_list); x++)\n     {\n       basic_block b = INDEX_EDGE_SUCC_BB (edge_list, x);\n+\n       if (b == EXIT_BLOCK_PTR)\n \tsbitmap_difference (insert[x], later[x], laterin[n_basic_blocks]);\n       else\n \tsbitmap_difference (insert[x], later[x], laterin[b->index]);\n     }\n }\n \n-/* Given local properties TRANSP, ANTLOC, AVOUT, KILL return the \n-   insert and delete vectors for edge based LCM.  Returns an\n-   edgelist which is used to map the insert vector to what edge\n-   an expression should be inserted on.  */\n+/* Given local properties TRANSP, ANTLOC, AVOUT, KILL return the insert and\n+   delete vectors for edge based LCM.  Returns an edgelist which is used to\n+   map the insert vector to what edge an expression should be inserted on.  */\n \n struct edge_list *\n pre_edge_lcm (file, n_exprs, transp, avloc, antloc, kill, insert, delete)\n@@ -397,8 +393,6 @@ pre_edge_lcm (file, n_exprs, transp, avloc, antloc, kill, insert, delete)\n   avin = sbitmap_vector_alloc (n_basic_blocks, n_exprs);\n   avout = sbitmap_vector_alloc (n_basic_blocks, n_exprs);\n   compute_available (avloc, kill, avout, avin);\n-\n-\n   free (avin);\n \n   /* Compute global anticipatability.  */\n@@ -428,11 +422,11 @@ pre_edge_lcm (file, n_exprs, transp, avloc, antloc, kill, insert, delete)\n   free (avout);\n \n   later = sbitmap_vector_alloc (num_edges, n_exprs);\n+\n   /* Allocate an extra element for the exit block in the laterin vector.  */\n   laterin = sbitmap_vector_alloc (n_basic_blocks + 1, n_exprs);\n   compute_laterin (edge_list, earliest, antloc, later, laterin);\n \n-\n #ifdef LCM_DEBUG_INFO\n   if (file)\n     {\n@@ -454,7 +448,8 @@ pre_edge_lcm (file, n_exprs, transp, avloc, antloc, kill, insert, delete)\n   if (file)\n     {\n       dump_sbitmap_vector (file, \"pre_insert_map\", \"\", *insert, num_edges);\n-      dump_sbitmap_vector (file, \"pre_delete_map\", \"\", *delete, n_basic_blocks);\n+      dump_sbitmap_vector (file, \"pre_delete_map\", \"\", *delete,\n+\t\t\t   n_basic_blocks);\n     }\n #endif\n \n@@ -463,6 +458,7 @@ pre_edge_lcm (file, n_exprs, transp, avloc, antloc, kill, insert, delete)\n \n /* Compute the AVIN and AVOUT vectors from the AVLOC and KILL vectors.\n    Return the number of passes we performed to iterate to a solution.  */\n+\n void\n compute_available (avloc, kill, avout, avin)\n      sbitmap *avloc, *kill, *avout, *avin;  \n@@ -474,8 +470,8 @@ compute_available (avloc, kill, avout, avin)\n   /* Allocate a worklist array/queue.  Entries are only added to the\n      list if they were not already on the list.  So the size is\n      bounded by the number of basic blocks.  */\n-  tos = worklist = (basic_block *) xmalloc (sizeof (basic_block)\n-\t\t\t\t\t    * n_basic_blocks);\n+  tos = worklist\n+    = (basic_block *) xmalloc (sizeof (basic_block) * n_basic_blocks);\n \n   /* We want a maximal solution.  */\n   sbitmap_vector_ones (avout, n_basic_blocks);\n@@ -504,12 +500,9 @@ compute_available (avloc, kill, avout, avin)\n \t intersection of avouts is the null set.  We can identify such blocks\n \t by the special value in the AUX field in the block structure.  */\n       if (b->aux == ENTRY_BLOCK_PTR)\n-\t{\n-\t  /* Do not clear the aux field for blocks which are\n-\t     successors of the ENTRY block.  That way we never\n-\t     add then to the worklist again.  */\n-\t  sbitmap_zero (avin[bb]);\n-\t}\n+\t/* Do not clear the aux field for blocks which are successors of the\n+\t   ENTRY block.  That way we never add then to the worklist again.  */\n+\tsbitmap_zero (avin[bb]);\n       else\n \t{\n \t  /* Clear the aux field of this block so that it can be added to\n@@ -519,24 +512,22 @@ compute_available (avloc, kill, avout, avin)\n \t}\n \n       if (sbitmap_union_of_diff (avout[bb], avloc[bb], avin[bb], kill[bb]))\n-\t{\n-\t  /* If the out state of this block changed, then we need\n-\t     to add the successors of this block to the worklist\n-\t     if they are not already on the worklist.  */\n-          for (e = b->succ; e; e = e->succ_next)\n+\t/* If the out state of this block changed, then we need\n+\t   to add the successors of this block to the worklist\n+\t   if they are not already on the worklist.  */\n+\tfor (e = b->succ; e; e = e->succ_next)\n+\t  if (!e->dest->aux && e->dest != EXIT_BLOCK_PTR)\n \t    {\n-\t      if (!e->dest->aux && e->dest != EXIT_BLOCK_PTR)\n-\t        {\n-\t          *tos++ = e->dest;\n-\t          e->dest->aux = e;\n-\t        }\n+\t      *tos++ = e->dest;\n+\t      e->dest->aux = e;\n \t    }\n-\t}\n     }\n+\n   free (tos);\n }\n \n /* Compute the farthest vector for edge based lcm.  */\n+\n static void\n compute_farthest (edge_list, n_exprs, st_avout, st_avin, st_antin, \n \t\t  kill, farthest)\n@@ -562,9 +553,7 @@ compute_farthest (edge_list, n_exprs, st_avout, st_avin, st_antin,\n       else\n \t{\n \t  if (pred == ENTRY_BLOCK_PTR)\n-\t    {\n-\t      sbitmap_zero (farthest[x]);\n-\t    }\n+\t    sbitmap_zero (farthest[x]);\n \t  else\n \t    {\n \t      sbitmap_difference (difference, st_avout[pred->index], \n@@ -575,6 +564,7 @@ compute_farthest (edge_list, n_exprs, st_avout, st_avin, st_antin,\n \t    }\n \t}\n     }\n+\n   free (temp_bitmap);\n   free (difference);\n }\n@@ -598,8 +588,8 @@ compute_nearerout (edge_list, farthest, st_avloc, nearer, nearerout)\n   /* Allocate a worklist array/queue.  Entries are only added to the\n      list if they were not already on the list.  So the size is\n      bounded by the number of basic blocks.  */\n-  tos = worklist = (basic_block *) xmalloc (sizeof (basic_block)\n-\t\t\t\t\t    * (n_basic_blocks + 1));\n+  tos = worklist\n+    = (basic_block *) xmalloc (sizeof (basic_block) * (n_basic_blocks + 1));\n \n   /* Initialize NEARER for each edge and build a mapping from an edge to\n      its index.  */\n@@ -641,21 +631,17 @@ compute_nearerout (edge_list, farthest, st_avloc, nearer, nearerout)\n \n       /* Calculate NEARER for all incoming edges.  */\n       for (e = b->pred; e != NULL; e = e->pred_next)\n-\t{\n-\t  if (sbitmap_union_of_diff (nearer[(size_t) e->aux],\n-\t\t\t\t     farthest[(size_t) e->aux],\n-\t\t\t\t     nearerout[e->dest->index],\n-\t\t\t\t     st_avloc[e->dest->index]))\n-\t    {\n-\t      /* If NEARER for an incoming edge was changed, then we need\n-\t\t to add the source of the incoming edge to the worklist.  */\n-\t      if (e->src != ENTRY_BLOCK_PTR && e->src->aux == 0)\n-\t\t{\n-\t\t  *tos++ = e->src;\n-\t\t  e->src->aux = e;\n-\t\t}\n-\t    }\n-        }\n+\tif (sbitmap_union_of_diff (nearer[(size_t) e->aux],\n+\t\t\t\t   farthest[(size_t) e->aux],\n+\t\t\t\t   nearerout[e->dest->index],\n+\t\t\t\t   st_avloc[e->dest->index])\n+\t    /* If NEARER for an incoming edge was changed, then we need\n+\t       to add the source of the incoming edge to the worklist.  */\n+\t    && e->src != ENTRY_BLOCK_PTR && e->src->aux == 0)\n+\t  {\n+\t    *tos++ = e->src;\n+\t    e->src->aux = e;\n+\t  }\n     }\n \n   /* Computation of insertion and deletion points requires computing NEAREROUT\n@@ -671,6 +657,7 @@ compute_nearerout (edge_list, farthest, st_avloc, nearer, nearerout)\n }\n \n /* Compute the insertion and deletion points for edge based LCM.  */\n+\n static void\n compute_rev_insert_delete (edge_list, st_avloc, nearer, nearerout,\n \t\t\t   insert, delete)\n@@ -766,6 +753,7 @@ pre_edge_rev_lcm (file, n_exprs, transp, st_avloc, st_antloc, kill,\n   free (st_avout);\n \n   nearer = sbitmap_vector_alloc (num_edges, n_exprs);\n+\n   /* Allocate an extra element for the entry block.  */\n   nearerout = sbitmap_vector_alloc (n_basic_blocks + 1, n_exprs);\n   compute_nearerout (edge_list, farthest, st_avloc, nearer, nearerout);\n@@ -783,7 +771,8 @@ pre_edge_rev_lcm (file, n_exprs, transp, st_avloc, st_antloc, kill,\n \n   *insert = sbitmap_vector_alloc (num_edges, n_exprs);\n   *delete = sbitmap_vector_alloc (n_basic_blocks, n_exprs);\n-  compute_rev_insert_delete (edge_list, st_avloc, nearer, nearerout, *insert, *delete);\n+  compute_rev_insert_delete (edge_list, st_avloc, nearer, nearerout,\n+\t\t\t     *insert, *delete);\n \n   free (nearerout);\n   free (nearer);\n@@ -792,15 +781,17 @@ pre_edge_rev_lcm (file, n_exprs, transp, st_avloc, st_antloc, kill,\n   if (file)\n     {\n       dump_sbitmap_vector (file, \"pre_insert_map\", \"\", *insert, num_edges);\n-      dump_sbitmap_vector (file, \"pre_delete_map\", \"\", *delete, n_basic_blocks);\n+      dump_sbitmap_vector (file, \"pre_delete_map\", \"\", *delete,\n+\t\t\t   n_basic_blocks);\n     }\n #endif\n \n   return edge_list;\n }\n \n-/* MODE SWITCHING */\n-/* The algorithm for setting the modes consists of scanning the insn list\n+/* Mode switching:\n+\n+   The algorithm for setting the modes consists of scanning the insn list\n    and finding all the insns which require a specific mode.  Each insn gets\n    a unique struct seginfo element.  These structures are inserted into a list\n    for each basic block.  For each entity, there is an array of bb_info over\n@@ -916,8 +907,10 @@ make_preds_opaque (b, j)\n   for (e = b->pred; e; e = e->pred_next)\n     {\n       basic_block pb = e->src;\n+\n       if (e->aux || ! TEST_BIT (transp[pb->index], j))\n \tcontinue;\n+\n       RESET_BIT (transp[pb->index], j);\n       make_preds_opaque (pb, j);\n     }\n@@ -930,18 +923,16 @@ reg_dies (reg, live)\n      rtx reg;\n      HARD_REG_SET live;\n {\n-  int regno;\n+  int regno, nregs;\n \n   if (GET_CODE (reg) != REG)\n     return;\n+\n   regno = REGNO (reg);\n   if (regno < FIRST_PSEUDO_REGISTER)\n-    {\n-      int nregs = HARD_REGNO_NREGS (regno, GET_MODE (reg));\n-\n-      for (; --nregs >=0; nregs--, regno++)\n-\tCLEAR_HARD_REG_BIT (live, regno);\n-    }\n+    for (nregs = HARD_REGNO_NREGS (regno, GET_MODE (reg)) - 1; nregs >= 0;\n+\t nregs--)\n+      CLEAR_HARD_REG_BIT (live, regno + nregs);\n }\n \n /* Record in LIVE that register REG became live.\n@@ -953,7 +944,7 @@ reg_becomes_live (reg, setter, live)\n      rtx setter ATTRIBUTE_UNUSED;\n      void *live;\n {\n-  int regno;\n+  int regno, nregs;\n \n   if (GET_CODE (reg) == SUBREG)\n     reg = SUBREG_REG (reg);\n@@ -963,17 +954,15 @@ reg_becomes_live (reg, setter, live)\n \n   regno = REGNO (reg);\n   if (regno < FIRST_PSEUDO_REGISTER)\n-    {\n-      int nregs = HARD_REGNO_NREGS (regno, GET_MODE (reg));\n-\n-      for (; nregs-- > 0; regno++)\n-\tSET_HARD_REG_BIT (* (HARD_REG_SET *) live, regno);\n-    }\n+    for (nregs = HARD_REGNO_NREGS (regno, GET_MODE (reg)) - 1; nregs >= 0;\n+\t nregs--)\n+      SET_HARD_REG_BIT (* (HARD_REG_SET *) live, regno + nregs);\n }\n #endif\n \n /* Find all insns that need a particular mode\n    setting, and insert the necessary mode switches.  */\n+\n void\n optimize_mode_switching (file)\n      FILE *file ATTRIBUTE_UNUSED;\n@@ -994,17 +983,16 @@ optimize_mode_switching (file)\n   int max_num_modes = 0;\n \n   for (e = N_ENTITIES - 1, n_entities = 0; e >= 0; e--)\n-    {\n-      if (OPTIMIZE_MODE_SWITCHING (e))\n-\t{\n-\t  /* Create the list of segments within each basic block.  */\n-\t  bb_info[n_entities]\n-\t    = (struct bb_info *) xcalloc (n_basic_blocks, sizeof **bb_info);\n-\t  entity_map[n_entities++] = e;\n-\t  if (num_modes[e] > max_num_modes)\n-\t    max_num_modes = num_modes[e];\n-\t}\n-    }\n+    if (OPTIMIZE_MODE_SWITCHING (e))\n+      {\n+\t/* Create the list of segments within each basic block.  */\n+\tbb_info[n_entities]\n+\t  = (struct bb_info *) xcalloc (n_basic_blocks, sizeof **bb_info);\n+\tentity_map[n_entities++] = e;\n+\tif (num_modes[e] > max_num_modes)\n+\t  max_num_modes = num_modes[e];\n+      }\n+\n   if (! n_entities)\n     return;\n \n@@ -1014,7 +1002,6 @@ optimize_mode_switching (file)\n   for (eg = EXIT_BLOCK_PTR->pred; eg; eg = eg->pred_next)\n     {\n       int bb = eg->src->index;\n-\n       rtx insn = BLOCK_END (bb);\n       rtx use = MODE_USES_IN_EXIT_BLOCK;\n \n@@ -1023,6 +1010,7 @@ optimize_mode_switching (file)\n       while ((GET_CODE (insn) == INSN && GET_CODE (PATTERN (insn)) == USE)\n \t     || GET_CODE (insn) == JUMP_INSN)\n \tinsn = PREV_INSN (insn);\n+\n       use = emit_insn_after (use, insn);\n       if (insn == BLOCK_END (bb))\n \tBLOCK_END (bb) = use;\n@@ -1077,12 +1065,14 @@ optimize_mode_switching (file)\n \t\t  for (link = REG_NOTES (insn); link; link = XEXP (link, 1))\n \t\t    if (REG_NOTE_KIND (link) == REG_DEAD)\n \t\t      reg_dies (XEXP (link, 0), live_now);\n+\n \t\t  note_stores (PATTERN (insn), reg_becomes_live, &live_now);\n \t\t  for (link = REG_NOTES (insn); link; link = XEXP (link, 1))\n \t\t    if (REG_NOTE_KIND (link) == REG_UNUSED)\n \t\t      reg_dies (XEXP (link, 0), live_now);\n \t\t}\n \t    }\n+\n \t  info[bb].computing = last_mode;\n \t  /* Check for blocks without ANY mode requirements.  */\n \t  if (last_mode == no_mode)\n@@ -1094,6 +1084,7 @@ optimize_mode_switching (file)\n #ifdef MODE_AT_ENTRY\n       {\n \tint mode = MODE_AT_ENTRY (e);\n+\n \tif (mode != no_mode)\n \t  {\n \t    for (eg = ENTRY_BLOCK_PTR->succ; eg; eg = eg->succ_next)\n@@ -1110,11 +1101,11 @@ optimize_mode_switching (file)\n \t\t   has none (because we don't need to set it),\n \t\t   but retain whatever mode it computes.  */\n \t\tif (info[bb].seginfo->mode == mode)\n-\t\t  {\n-\t\t    info[bb].seginfo->mode = no_mode;\n-\t\t  }\n-\t\t/* Insert a fake computing definition of MODE into entry blocks\n-\t\t   which compute no mode. This represents the mode on entry.  */\n+\t\t  info[bb].seginfo->mode = no_mode;\n+\n+\t\t/* Insert a fake computing definition of MODE into entry\n+\t\t   blocks which compute no mode. This represents the mode on\n+\t\t   entry.  */\n \t\telse if (info[bb].computing == no_mode)\n \t\t  {\n \t\t    info[bb].computing = mode;\n@@ -1141,7 +1132,6 @@ optimize_mode_switching (file)\n \t  \n \t  for (bb = 0 ; bb < n_basic_blocks; bb++)\n \t    {\n-\n \t      if (info[bb].seginfo->mode == m)\n \t\tSET_BIT (antic[bb], j);\n \n@@ -1158,10 +1148,11 @@ optimize_mode_switching (file)\n       edge_list = pre_edge_lcm (file, 1, transp, comp, antic,\n \t\t\t\tkill, &insert, &delete);\n \n-      for (j = n_entities - 1; j >=0; j--)\n+      for (j = n_entities - 1; j >= 0; j--)\n \t{\n \t  /* Insert all mode sets that have been inserted by lcm.  */\n \t  int no_mode = num_modes[entity_map[j]];\n+\n \t  /* Wherever we have moved a mode setting upwards in the flow graph,\n \t     the blocks between the new setting site and the now redundant\n \t     computation ceases to be transparent for any lower-priority\n@@ -1187,7 +1178,9 @@ optimize_mode_switching (file)\n \t      mode = current_mode[j];\n \t      src_bb = eg->src;\n \n-\t      REG_SET_TO_HARD_REG_SET (live_at_edge, src_bb->global_live_at_end);\n+\t      REG_SET_TO_HARD_REG_SET (live_at_edge,\n+\t\t\t\t       src_bb->global_live_at_end);\n+\n \t      start_sequence ();\n \t      EMIT_MODE_SET (entity_map[j], mode, live_at_edge);\n \t      mode_set = gen_sequence ();\n@@ -1197,7 +1190,6 @@ optimize_mode_switching (file)\n \t\t previous block.  */\n \t      if (eg->flags & EDGE_ABNORMAL)\n \t\t{\n-\n \t\t  src_bb->end = emit_insn_after (mode_set, src_bb->end);\n \t\t  bb_info[j][src_bb->index].computing = mode;\n \t\t  RESET_BIT (transp[src_bb->index], j);\n@@ -1207,19 +1199,17 @@ optimize_mode_switching (file)\n \t\t  need_commit = 1;\n \t\t  insert_insn_on_edge (mode_set, eg);\n \t\t}\n-\n \t    }\n \n \t  for (bb = n_basic_blocks - 1; bb >= 0; bb--)\n-\t    {\n-\t      if (TEST_BIT (delete[bb], j))\n-\t\t{\n-\t\t  make_preds_opaque (BASIC_BLOCK (bb), j);\n-\t\t  /* Cancel the 'deleted' mode set.  */\n-\t\t  bb_info[j][bb].seginfo->mode = no_mode;\n-\t\t}\n-\t    }\n+\t    if (TEST_BIT (delete[bb], j))\n+\t      {\n+\t\tmake_preds_opaque (BASIC_BLOCK (bb), j);\n+\t\t/* Cancel the 'deleted' mode set.  */\n+\t\tbb_info[j][bb].seginfo->mode = no_mode;\n+\t      }\n \t}\n+\n       free_edge_list (edge_list);\n     }\n \n@@ -1244,9 +1234,11 @@ optimize_mode_switching (file)\n \t\t  emit_block_insn_before (mode_set, ptr->insn_ptr,\n \t\t\t\t\t  BASIC_BLOCK (ptr->bbnum));\n \t\t}\n+\n \t      free (ptr);\n \t    }\n \t}\n+\n       free (bb_info[j]);\n     }\n "}]}