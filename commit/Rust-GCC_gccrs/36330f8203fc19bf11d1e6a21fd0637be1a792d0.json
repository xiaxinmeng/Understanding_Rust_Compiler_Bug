{"sha": "36330f8203fc19bf11d1e6a21fd0637be1a792d0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzYzMzBmODIwM2ZjMTliZjExZDFlNmEyMWZkMDYzN2JlMWE3OTJkMA==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2018-06-08T12:16:18Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2018-06-08T12:16:18Z"}, "message": "Covert ipa-pure-const.c to symbol_summary.\n\n2018-06-08  Martin Liska  <mliska@suse.cz>\n\n\t* ipa-pure-const.c (struct funct_state_d): Do it class instead\n\tof struct.\n\t(class funct_state_summary_t): New function_summary class.\n\t(has_function_state): Remove.\n\t(get_function_state): Likewise.\n\t(set_function_state): Likewise.\n\t(add_new_function): Likewise.\n\t(funct_state_summary_t::insert): New function.\n\t(duplicate_node_data): Remove.\n\t(remove_node_data): Remove.\n\t(funct_state_summary_t::duplicate): New function.\n\t(register_hooks): Create new funct_state_summaries.\n\t(pure_const_generate_summary): Use it.\n\t(pure_const_write_summary): Likewise.\n\t(pure_const_read_summary): Likewise.\n\t(propagate_pure_const): Likewise.\n\t(propagate_nothrow): Likewise.\n\t(dump_malloc_lattice): Likewise.\n\t(propagate_malloc): Likewise.\n\t(execute): Do not register hooks, just remove summary\n\tinstead.\n\t(pass_ipa_pure_const::pass_ipa_pure_const): Simplify\n\tconstructor.\n\nFrom-SVN: r261313", "tree": {"sha": "89f371cd2e2fe8db0e6c1cd6354c364a2ce92484", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/89f371cd2e2fe8db0e6c1cd6354c364a2ce92484"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/36330f8203fc19bf11d1e6a21fd0637be1a792d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36330f8203fc19bf11d1e6a21fd0637be1a792d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/36330f8203fc19bf11d1e6a21fd0637be1a792d0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36330f8203fc19bf11d1e6a21fd0637be1a792d0/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6adcb793611207a5b6aeb30c9670ab083f2ed03c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6adcb793611207a5b6aeb30c9670ab083f2ed03c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6adcb793611207a5b6aeb30c9670ab083f2ed03c"}], "stats": {"total": 219, "additions": 92, "deletions": 127}, "files": [{"sha": "9a4dda69f8346da66371064ea975718919d2f018", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36330f8203fc19bf11d1e6a21fd0637be1a792d0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36330f8203fc19bf11d1e6a21fd0637be1a792d0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=36330f8203fc19bf11d1e6a21fd0637be1a792d0", "patch": "@@ -1,3 +1,29 @@\n+2018-06-08  Martin Liska  <mliska@suse.cz>\n+\n+\t* ipa-pure-const.c (struct funct_state_d): Do it class instead\n+\tof struct.\n+\t(class funct_state_summary_t): New function_summary class.\n+\t(has_function_state): Remove.\n+\t(get_function_state): Likewise.\n+\t(set_function_state): Likewise.\n+\t(add_new_function): Likewise.\n+\t(funct_state_summary_t::insert): New function.\n+\t(duplicate_node_data): Remove.\n+\t(remove_node_data): Remove.\n+\t(funct_state_summary_t::duplicate): New function.\n+\t(register_hooks): Create new funct_state_summaries.\n+\t(pure_const_generate_summary): Use it.\n+\t(pure_const_write_summary): Likewise.\n+\t(pure_const_read_summary): Likewise.\n+\t(propagate_pure_const): Likewise.\n+\t(propagate_nothrow): Likewise.\n+\t(dump_malloc_lattice): Likewise.\n+\t(propagate_malloc): Likewise.\n+\t(execute): Do not register hooks, just remove summary\n+\tinstead.\n+\t(pass_ipa_pure_const::pass_ipa_pure_const): Simplify\n+\tconstructor.\n+\n 2018-06-08  Martin Liska  <mliska@suse.cz>\n \n \t* ipa-reference.c (remove_node_data): Remove."}, {"sha": "2cf8c2fa32cbc16a7f667ac29e2de76eb2254866", "filename": "gcc/ipa-pure-const.c", "status": "modified", "additions": 66, "deletions": 127, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36330f8203fc19bf11d1e6a21fd0637be1a792d0/gcc%2Fipa-pure-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36330f8203fc19bf11d1e6a21fd0637be1a792d0/gcc%2Fipa-pure-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-pure-const.c?ref=36330f8203fc19bf11d1e6a21fd0637be1a792d0", "patch": "@@ -85,8 +85,20 @@ static const char *malloc_state_names[] = {\"malloc_top\", \"malloc\", \"malloc_botto\n \n /* Holder for the const_state.  There is one of these per function\n    decl.  */\n-struct funct_state_d\n+class funct_state_d\n {\n+public:\n+  funct_state_d (): pure_const_state (IPA_NEITHER),\n+    state_previously_known (IPA_NEITHER), looping_previously_known (true),\n+    looping (true), can_throw (true), can_free (true),\n+    malloc_state (STATE_MALLOC_BOTTOM) {}\n+\n+  funct_state_d (const funct_state_d &s): pure_const_state (s.pure_const_state),\n+    state_previously_known (s.state_previously_known),\n+    looping_previously_known (s.looping_previously_known),\n+    looping (s.looping), can_throw (s.can_throw), can_free (s.can_free),\n+    malloc_state (s.malloc_state) {}\n+\n   /* See above.  */\n   enum pure_const_state_e pure_const_state;\n   /* What user set here; we can be always sure about this.  */\n@@ -110,20 +122,25 @@ struct funct_state_d\n   enum malloc_state_e malloc_state;\n };\n \n-/* State used when we know nothing about function.  */\n-static struct funct_state_d varying_state\n-   = { IPA_NEITHER, IPA_NEITHER, true, true, true, true, STATE_MALLOC_BOTTOM };\n-\n-\n typedef struct funct_state_d * funct_state;\n \n /* The storage of the funct_state is abstracted because there is the\n    possibility that it may be desirable to move this to the cgraph\n    local info.  */\n \n-/* Array, indexed by cgraph node uid, of function states.  */\n+class funct_state_summary_t: public function_summary <funct_state_d *>\n+{\n+public:\n+  funct_state_summary_t (symbol_table *symtab):\n+    function_summary <funct_state_d *> (symtab) {}\n+\n+  virtual void insert (cgraph_node *, funct_state_d *state);\n+  virtual void duplicate (cgraph_node *src_node, cgraph_node *dst_node,\n+\t\t\t  funct_state_d *src_data,\n+\t\t\t  funct_state_d *dst_data);\n+};\n \n-static vec<funct_state> funct_state_vec;\n+static funct_state_summary_t *funct_state_summaries = NULL;\n \n static bool gate_pure_const (void);\n \n@@ -155,12 +172,6 @@ class pass_ipa_pure_const : public ipa_opt_pass_d\n \n private:\n   bool init_p;\n-\n-  /* Holders of ipa cgraph hooks: */\n-  struct cgraph_node_hook_list *function_insertion_hook_holder;\n-  struct cgraph_2node_hook_list *node_duplication_hook_holder;\n-  struct cgraph_node_hook_list *node_removal_hook_holder;\n-\n }; // class pass_ipa_pure_const\n \n } // anon namespace\n@@ -278,48 +289,6 @@ warn_function_cold (tree decl)\n \t\t\t true, warned_about, \"cold\");\n }\n \n-/* Return true if we have a function state for NODE.  */\n-\n-static inline bool\n-has_function_state (struct cgraph_node *node)\n-{\n-  if (!funct_state_vec.exists ()\n-      || funct_state_vec.length () <= (unsigned int)node->uid)\n-    return false;\n-  return funct_state_vec[node->uid] != NULL;\n-}\n-\n-/* Return the function state from NODE.  */\n-\n-static inline funct_state\n-get_function_state (struct cgraph_node *node)\n-{\n-  if (!funct_state_vec.exists ()\n-      || funct_state_vec.length () <= (unsigned int)node->uid\n-      || !funct_state_vec[node->uid])\n-    /* We might want to put correct previously_known state into varying.  */\n-    return &varying_state;\n- return funct_state_vec[node->uid];\n-}\n-\n-/* Set the function state S for NODE.  */\n-\n-static inline void\n-set_function_state (struct cgraph_node *node, funct_state s)\n-{\n-  if (!funct_state_vec.exists ()\n-      || funct_state_vec.length () <= (unsigned int)node->uid)\n-     funct_state_vec.safe_grow_cleared (node->uid + 1);\n-\n-  /* If funct_state_vec already contains a funct_state, we have to release\n-     it before it's going to be ovewritten.  */\n-  if (funct_state_vec[node->uid] != NULL\n-      && funct_state_vec[node->uid] != &varying_state)\n-    free (funct_state_vec[node->uid]);\n-\n-  funct_state_vec[node->uid] = s;\n-}\n-\n /* Check to see if the use (or definition when CHECKING_WRITE is true)\n    variable T is legal in a function that is either pure or const.  */\n \n@@ -1148,40 +1117,29 @@ analyze_function (struct cgraph_node *fn, bool ipa)\n   return l;\n }\n \n-/* Called when new function is inserted to callgraph late.  */\n-static void\n-add_new_function (struct cgraph_node *node, void *data ATTRIBUTE_UNUSED)\n+void\n+funct_state_summary_t::insert (cgraph_node *node, funct_state_d *state)\n {\n   /* There are some shared nodes, in particular the initializers on\n      static declarations.  We do not need to scan them more than once\n      since all we would be interested in are the addressof\n      operations.  */\n   if (opt_for_fn (node->decl, flag_ipa_pure_const))\n-    set_function_state (node, analyze_function (node, true));\n-}\n-\n-/* Called when new clone is inserted to callgraph late.  */\n-\n-static void\n-duplicate_node_data (struct cgraph_node *src, struct cgraph_node *dst,\n-\t \t     void *data ATTRIBUTE_UNUSED)\n-{\n-  if (has_function_state (src))\n     {\n-      funct_state l = XNEW (struct funct_state_d);\n-      gcc_assert (!has_function_state (dst));\n-      memcpy (l, get_function_state (src), sizeof (*l));\n-      set_function_state (dst, l);\n+      funct_state_d *a = analyze_function (node, true);\n+      new (state) funct_state_d (*a);\n+      free (a);\n     }\n }\n \n /* Called when new clone is inserted to callgraph late.  */\n \n-static void\n-remove_node_data (struct cgraph_node *node, void *data ATTRIBUTE_UNUSED)\n+void\n+funct_state_summary_t::duplicate (cgraph_node *, cgraph_node *,\n+\t\t\t\t  funct_state_d *src_data,\n+\t\t\t\t  funct_state_d *dst_data)\n {\n-  if (has_function_state (node))\n-    set_function_state (node, NULL);\n+  new (dst_data) funct_state_d (*src_data);\n }\n \n \f\n@@ -1194,12 +1152,7 @@ register_hooks (void)\n \n   init_p = true;\n \n-  node_removal_hook_holder =\n-      symtab->add_cgraph_removal_hook (&remove_node_data, NULL);\n-  node_duplication_hook_holder =\n-      symtab->add_cgraph_duplication_hook (&duplicate_node_data, NULL);\n-  function_insertion_hook_holder =\n-      symtab->add_cgraph_insertion_hook (&add_new_function, NULL);\n+  funct_state_summaries = new funct_state_summary_t (symtab);\n }\n \n \n@@ -1222,7 +1175,11 @@ pure_const_generate_summary (void)\n \n   FOR_EACH_DEFINED_FUNCTION (node)\n     if (opt_for_fn (node->decl, flag_ipa_pure_const))\n-      set_function_state (node, analyze_function (node, true));\n+      {\n+\tfunct_state_d *a = analyze_function (node, true);\n+\tnew (funct_state_summaries->get_create (node)) funct_state_d (*a);\n+\tfree (a);\n+      }\n }\n \n \n@@ -1244,7 +1201,7 @@ pure_const_write_summary (void)\n        lsei_next_function_in_partition (&lsei))\n     {\n       node = lsei_cgraph_node (lsei);\n-      if (node->definition && has_function_state (node))\n+      if (node->definition && funct_state_summaries->exists (node))\n \tcount++;\n     }\n \n@@ -1255,15 +1212,13 @@ pure_const_write_summary (void)\n        lsei_next_function_in_partition (&lsei))\n     {\n       node = lsei_cgraph_node (lsei);\n-      if (node->definition && has_function_state (node))\n+      funct_state_d *fs = funct_state_summaries->get (node);\n+      if (node->definition && fs != NULL)\n \t{\n \t  struct bitpack_d bp;\n-\t  funct_state fs;\n \t  int node_ref;\n \t  lto_symtab_encoder_t encoder;\n \n-\t  fs = get_function_state (node);\n-\n \t  encoder = ob->decl_state->symtab_node_encoder;\n \t  node_ref = lto_symtab_encoder_encode (encoder, node);\n \t  streamer_write_uhwi_stream (ob->main_stream, node_ref);\n@@ -1319,13 +1274,12 @@ pure_const_read_summary (void)\n \t      funct_state fs;\n \t      lto_symtab_encoder_t encoder;\n \n-\t      fs = XCNEW (struct funct_state_d);\n \t      index = streamer_read_uhwi (ib);\n \t      encoder = file_data->symtab_node_encoder;\n \t      node = dyn_cast<cgraph_node *> (lto_symtab_encoder_deref (encoder,\n \t\t\t\t\t\t\t\t\tindex));\n-\t      set_function_state (node, fs);\n \n+\t      fs = funct_state_summaries->get_create (node);\n \t      /* Note that the flags must be read in the opposite\n \t\t order in which they were written (the bitflags were\n \t\t pushed into FLAGS).  */\n@@ -1481,7 +1435,7 @@ propagate_pure_const (void)\n \t  int i;\n \t  struct ipa_ref *ref = NULL;\n \n-\t  funct_state w_l = get_function_state (w);\n+\t  funct_state w_l = funct_state_summaries->get_create (w);\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    fprintf (dump_file, \"  Visiting %s state:%s looping %i\\n\",\n \t\t     w->dump_name (),\n@@ -1523,7 +1477,7 @@ propagate_pure_const (void)\n \t\t}\n \t      if (avail > AVAIL_INTERPOSABLE)\n \t\t{\n-\t\t  funct_state y_l = get_function_state (y);\n+\t\t  funct_state y_l = funct_state_summaries->get_create (y);\n \t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t\t    {\n \t\t      fprintf (dump_file,\n@@ -1637,7 +1591,7 @@ propagate_pure_const (void)\n       while (w && !can_free)\n \t{\n \t  struct cgraph_edge *e;\n-\t  funct_state w_l = get_function_state (w);\n+\t  funct_state w_l = funct_state_summaries->get_create (w);\n \n \t  if (w_l->can_free\n \t      || w->get_availability () == AVAIL_INTERPOSABLE\n@@ -1652,7 +1606,7 @@ propagate_pure_const (void)\n \t\t\t\t\t\t\t\t  e->caller);\n \n \t      if (avail > AVAIL_INTERPOSABLE)\n-\t\tcan_free = get_function_state (y)->can_free;\n+\t\tcan_free = funct_state_summaries->get_create (y)->can_free;\n \t      else\n \t\tcan_free = true;\n \t    }\n@@ -1665,7 +1619,7 @@ propagate_pure_const (void)\n       w = node;\n       while (w)\n \t{\n-\t  funct_state w_l = get_function_state (w);\n+\t  funct_state w_l = funct_state_summaries->get_create (w);\n \t  enum pure_const_state_e this_state = pure_const_state;\n \t  bool this_looping = looping;\n \n@@ -1804,7 +1758,7 @@ propagate_nothrow (void)\n \n \t  if (!TREE_NOTHROW (w->decl))\n \t    {\n-\t      funct_state w_l = get_function_state (w);\n+\t      funct_state w_l = funct_state_summaries->get_create (w);\n \n \t      if (w_l->can_throw\n \t\t  || w->get_availability () == AVAIL_INTERPOSABLE)\n@@ -1829,7 +1783,7 @@ propagate_nothrow (void)\n \t\t     throw.  */\n \t\t  if (avail <= AVAIL_INTERPOSABLE\n \t\t      || (!TREE_NOTHROW (y->decl)\n-\t\t\t  && (get_function_state (y)->can_throw\n+\t\t\t  && (funct_state_summaries->get_create (y)->can_throw\n \t\t\t      || (opt_for_fn (y->decl, flag_non_call_exceptions)\n \t\t\t\t  && !e->callee->binds_to_current_def_p (w)))))\n \t\t    can_throw = true;\n@@ -1849,7 +1803,7 @@ propagate_nothrow (void)\n       w = node;\n       while (w)\n \t{\n-\t  funct_state w_l = get_function_state (w);\n+\t  funct_state w_l = funct_state_summaries->get_create (w);\n \t  if (!can_throw && !TREE_NOTHROW (w->decl))\n \t    {\n \t      /* Inline clones share declaration with their offline copies;\n@@ -1887,7 +1841,7 @@ dump_malloc_lattice (FILE *dump_file, const char *s)\n   cgraph_node *node;\n   FOR_EACH_FUNCTION (node)\n     {\n-      funct_state fs = get_function_state (node);\n+      funct_state fs = funct_state_summaries->get_create (node);\n       malloc_state_e state = fs->malloc_state;\n       fprintf (dump_file, \"%s: %s\\n\", node->name (), malloc_state_names[state]);\n     }\n@@ -1902,12 +1856,10 @@ propagate_malloc (void)\n   FOR_EACH_FUNCTION (node)\n     {\n       if (DECL_IS_MALLOC (node->decl))\n-\tif (!has_function_state (node))\n+\tif (!funct_state_summaries->exists (node))\n \t  {\n-\t    funct_state l = XCNEW (struct funct_state_d);\n-\t    *l = varying_state;\n-\t    l->malloc_state = STATE_MALLOC;\n-\t    set_function_state (node, l);\n+\t    funct_state fs = funct_state_summaries->get_create (node);\n+\t    fs->malloc_state = STATE_MALLOC;\n \t  }\n     }\n \n@@ -1926,10 +1878,10 @@ propagate_malloc (void)\n \t  cgraph_node *node = order[i];\n \t  if (node->alias\n \t      || !node->definition\n-\t      || !has_function_state (node))\n+\t      || !funct_state_summaries->exists (node))\n \t    continue;\n \n-\t  funct_state l = get_function_state (node);\n+\t  funct_state l = funct_state_summaries->get_create (node);\n \n \t  /* FIXME: add support for indirect-calls.  */\n \t  if (node->indirect_calls)\n@@ -1959,12 +1911,13 @@ propagate_malloc (void)\n \t  for (unsigned j = 0; j < callees.length (); j++)\n \t    {\n \t      cgraph_node *callee = callees[j];\n-\t      if (!has_function_state (callee))\n+\t      if (!funct_state_summaries->exists (node))\n \t\t{\n \t\t  new_state = STATE_MALLOC_BOTTOM;\n \t\t  break;\n \t\t}\n-\t      malloc_state_e callee_state = get_function_state (callee)->malloc_state;\n+\t      malloc_state_e callee_state\n+\t\t= funct_state_summaries->get_create (callee)->malloc_state;\n \t      if (new_state < callee_state)\n \t\tnew_state = callee_state;\n \t    }\n@@ -1977,9 +1930,9 @@ propagate_malloc (void)\n     }\n \n   FOR_EACH_DEFINED_FUNCTION (node)\n-    if (has_function_state (node))\n+    if (funct_state_summaries->exists (node))\n       {\n-\tfunct_state l = get_function_state (node);\n+\tfunct_state l = funct_state_summaries->get_create (node);\n \tif (!node->alias\n \t    && l->malloc_state == STATE_MALLOC\n \t    && !node->global.inlined_to)\n@@ -2007,24 +1960,15 @@ unsigned int\n pass_ipa_pure_const::\n execute (function *)\n {\n-  struct cgraph_node *node;\n   bool remove_p;\n \n-  symtab->remove_cgraph_insertion_hook (function_insertion_hook_holder);\n-  symtab->remove_cgraph_duplication_hook (node_duplication_hook_holder);\n-  symtab->remove_cgraph_removal_hook (node_removal_hook_holder);\n-\n   /* Nothrow makes more function to not lead to return and improve\n      later analysis.  */\n   propagate_nothrow ();\n   propagate_malloc ();\n   remove_p = propagate_pure_const ();\n \n-  /* Cleanup. */\n-  FOR_EACH_FUNCTION (node)\n-    if (has_function_state (node))\n-      free (get_function_state (node));\n-  funct_state_vec.release ();\n+  delete funct_state_summaries;\n   return remove_p ? TODO_remove_functions : 0;\n }\n \n@@ -2045,12 +1989,7 @@ pass_ipa_pure_const::pass_ipa_pure_const(gcc::context *ctxt)\n \t\t     0, /* function_transform_todo_flags_start */\n \t\t     NULL, /* function_transform */\n \t\t     NULL), /* variable_transform */\n-  init_p(false),\n-  function_insertion_hook_holder(NULL),\n-  node_duplication_hook_holder(NULL),\n-  node_removal_hook_holder(NULL)\n-{\n-}\n+  init_p (false) {}\n \n ipa_opt_pass_d *\n make_pass_ipa_pure_const (gcc::context *ctxt)"}]}