{"sha": "4e58524e8c8ff4144fb15fd2867c60bf46d6ca67", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGU1ODUyNGU4YzhmZjQxNDRmYjE1ZmQyODY3YzYwYmY0NmQ2Y2E2Nw==", "commit": {"author": {"name": "Hans-Peter Nilsson", "email": "hp@bitrange.com", "date": "2003-07-16T17:44:59Z"}, "committer": {"name": "Hans-Peter Nilsson", "email": "hp@gcc.gnu.org", "date": "2003-07-16T17:44:59Z"}, "message": "mmix-protos.h: Convert prototypes to ISO C90.\n\n\t* config/mmix/mmix-protos.h: Convert prototypes to ISO C90.\n\t* config/mmix/mmix.c: Convert functions to ISO C90.\n  \t(mmix_eh_return_handler_rtx, mmix_output_shifted_value): Tweak\n\tformatting.\n\t(mmix_get_hard_reg_initial_val): Tweak section head comment.\n\nFrom-SVN: r69466", "tree": {"sha": "85e9d9a0dc7fa82c37f6f83663ab3169a64ddcd5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/85e9d9a0dc7fa82c37f6f83663ab3169a64ddcd5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4e58524e8c8ff4144fb15fd2867c60bf46d6ca67", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e58524e8c8ff4144fb15fd2867c60bf46d6ca67", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e58524e8c8ff4144fb15fd2867c60bf46d6ca67", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e58524e8c8ff4144fb15fd2867c60bf46d6ca67/comments", "author": null, "committer": null, "parents": [{"sha": "dced0d12fbac3d87ca3d98163d2cf27f6655fb2e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dced0d12fbac3d87ca3d98163d2cf27f6655fb2e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dced0d12fbac3d87ca3d98163d2cf27f6655fb2e"}], "stats": {"total": 637, "additions": 250, "deletions": 387}, "files": [{"sha": "8b1b57f81d37b3e1fd72313a84fc873e6763f934", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e58524e8c8ff4144fb15fd2867c60bf46d6ca67/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e58524e8c8ff4144fb15fd2867c60bf46d6ca67/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4e58524e8c8ff4144fb15fd2867c60bf46d6ca67", "patch": "@@ -1,3 +1,11 @@\n+2003-07-16  Hans-Peter Nilsson  <hp@bitrange.com>\n+\n+\t* config/mmix/mmix-protos.h: Convert prototypes to ISO C90.\n+\t* config/mmix/mmix.c: Convert functions to ISO C90.\n+  \t(mmix_eh_return_handler_rtx, mmix_output_shifted_value): Tweak\n+\tformatting.\n+\t(mmix_get_hard_reg_initial_val): Tweak section head comment.\n+\n 2003-07-16  J\"orn Rennecke <joern.rennecke@superh.com>\n \n \t* c-pragma.h (HANDLE_PRAGMA_WEAK): Always define to SUPPORTS_WEAK."}, {"sha": "a5ae7c8ae2fb09ebdd7e99c0511f6d30137aaac5", "filename": "gcc/config/mmix/mmix-protos.h", "status": "modified", "additions": 73, "deletions": 78, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e58524e8c8ff4144fb15fd2867c60bf46d6ca67/gcc%2Fconfig%2Fmmix%2Fmmix-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e58524e8c8ff4144fb15fd2867c60bf46d6ca67/gcc%2Fconfig%2Fmmix%2Fmmix-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmmix%2Fmmix-protos.h?ref=4e58524e8c8ff4144fb15fd2867c60bf46d6ca67", "patch": "@@ -1,5 +1,5 @@\n /* Prototypes for exported functions defined in mmix.c\n-   Copyright (C) 2000, 2001, 2002  Free Software Foundation, Inc.\n+   Copyright (C) 2000, 2001, 2002, 2003  Free Software Foundation, Inc.\n    Contributed by Hans-Peter Nilsson (hp@bitrange.com)\n \n This file is part of GCC.\n@@ -19,94 +19,89 @@ along with GCC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n-extern void mmix_override_options PARAMS ((void));\n-extern void mmix_init_expanders PARAMS ((void));\n-extern int mmix_eh_return_data_regno PARAMS ((int));\n-extern int mmix_initial_elimination_offset PARAMS ((int, int));\n-extern int mmix_starting_frame_offset PARAMS ((void));\n-extern int mmix_function_arg_regno_p PARAMS ((int, int));\n-extern void mmix_function_profiler PARAMS ((FILE *, int));\n-extern void mmix_trampoline_template PARAMS ((FILE *));\n+extern void mmix_override_options (void);\n+extern void mmix_init_expanders (void);\n+extern int mmix_eh_return_data_regno (int);\n+extern int mmix_initial_elimination_offset (int, int);\n+extern int mmix_starting_frame_offset (void);\n+extern int mmix_function_arg_regno_p (int, int);\n+extern void mmix_function_profiler (FILE *, int);\n+extern void mmix_trampoline_template (FILE *);\n extern int mmix_trampoline_size;\n-extern int mmix_reversible_cc_mode PARAMS ((enum machine_mode));\n+extern int mmix_reversible_cc_mode (enum machine_mode);\n extern int mmix_register_move_cost\n-  PARAMS ((enum machine_mode, enum reg_class, enum reg_class));\n-extern const char *mmix_text_section_asm_op PARAMS ((void));\n-extern const char *mmix_data_section_asm_op PARAMS ((void));\n-extern void mmix_asm_output_source_filename PARAMS ((FILE *, const char *));\n-extern void mmix_output_quoted_string PARAMS ((FILE *, const char *, int));\n-extern void mmix_asm_output_source_line  PARAMS ((FILE *, int));\n-extern void mmix_asm_output_ascii PARAMS ((FILE *, const char *, int));\n-extern void mmix_asm_output_label PARAMS ((FILE *, const char *));\n-extern void mmix_asm_weaken_label PARAMS ((FILE *, const char *));\n-extern void mmix_asm_output_labelref PARAMS ((FILE *, const char *));\n-extern void mmix_asm_output_def PARAMS ((FILE *, const char *, const char *));\n-extern int mmix_print_operand_punct_valid_p PARAMS ((int));\n-extern void mmix_asm_output_reg_push PARAMS ((FILE *, int));\n-extern void mmix_asm_output_reg_pop PARAMS ((FILE *, int));\n-extern void mmix_asm_output_skip PARAMS ((FILE *, int));\n-extern void mmix_asm_output_align PARAMS ((FILE *, int));\n-extern int mmix_shiftable_wyde_value PARAMS ((unsigned HOST_WIDEST_INT));\n-extern void mmix_output_register_setting\n-  PARAMS ((FILE *, int, HOST_WIDEST_INT, int));\n-extern void mmix_conditional_register_usage PARAMS ((void));\n-extern int mmix_local_regno PARAMS ((int));\n-extern int mmix_dbx_register_number PARAMS ((int));\n-extern int mmix_use_simple_return PARAMS ((void));\n-extern void mmix_make_decl_one_only PARAMS ((tree));\n+  (enum machine_mode, enum reg_class, enum reg_class);\n+extern const char *mmix_text_section_asm_op (void);\n+extern const char *mmix_data_section_asm_op (void);\n+extern void mmix_asm_output_source_filename (FILE *, const char *);\n+extern void mmix_output_quoted_string (FILE *, const char *, int);\n+extern void mmix_asm_output_source_line  (FILE *, int);\n+extern void mmix_asm_output_ascii (FILE *, const char *, int);\n+extern void mmix_asm_output_label (FILE *, const char *);\n+extern void mmix_asm_weaken_label (FILE *, const char *);\n+extern void mmix_asm_output_labelref (FILE *, const char *);\n+extern void mmix_asm_output_def (FILE *, const char *, const char *);\n+extern int mmix_print_operand_punct_valid_p (int);\n+extern void mmix_asm_output_reg_push (FILE *, int);\n+extern void mmix_asm_output_reg_pop (FILE *, int);\n+extern void mmix_asm_output_skip (FILE *, int);\n+extern void mmix_asm_output_align (FILE *, int);\n+extern int mmix_shiftable_wyde_value (unsigned HOST_WIDEST_INT);\n+extern void mmix_output_register_setting (FILE *, int, HOST_WIDEST_INT, int);\n+extern void mmix_conditional_register_usage (void);\n+extern int mmix_local_regno (int);\n+extern int mmix_dbx_register_number (int);\n+extern int mmix_use_simple_return (void);\n+extern void mmix_make_decl_one_only (tree);\n extern int mmix_function_arg_pass_by_reference\n-  PARAMS ((const CUMULATIVE_ARGS *, enum machine_mode, tree, int));\n-extern rtx mmix_function_outgoing_value PARAMS ((tree, tree));\n-extern int mmix_function_value_regno_p PARAMS ((int));\n-extern int mmix_data_alignment PARAMS ((tree, int));\n-extern int mmix_constant_alignment PARAMS ((tree, int));\n-extern int mmix_local_alignment PARAMS ((tree, int));\n+  (const CUMULATIVE_ARGS *, enum machine_mode, tree, int);\n+extern rtx mmix_function_outgoing_value (tree, tree);\n+extern int mmix_function_value_regno_p (int);\n+extern int mmix_data_alignment (tree, int);\n+extern int mmix_constant_alignment (tree, int);\n+extern int mmix_local_alignment (tree, int);\n extern void mmix_setup_incoming_varargs\n-  PARAMS ((CUMULATIVE_ARGS *, enum machine_mode, tree, int *, int));\n-extern void mmix_asm_output_pool_prologue\n-  PARAMS ((FILE *, const char *, tree, int));\n-extern void mmix_asm_output_aligned_common\n-  PARAMS ((FILE *, const char *, int, int));\n-extern void mmix_asm_output_aligned_local\n-  PARAMS ((FILE *, const char *, int, int));\n+  (CUMULATIVE_ARGS *, enum machine_mode, tree, int *, int);\n+extern void mmix_asm_output_pool_prologue (FILE *, const char *, tree, int);\n+extern void mmix_asm_output_aligned_common (FILE *, const char *, int, int);\n+extern void mmix_asm_output_aligned_local (FILE *, const char *, int, int);\n extern void mmix_asm_declare_register_global\n-  PARAMS ((FILE *, tree, int, const char *));\n+  (FILE *, tree, int, const char *);\n extern rtx mmix_function_arg\n-  PARAMS ((const CUMULATIVE_ARGS *, enum machine_mode, tree, int, int));\n-extern rtx mmix_expand_builtin_va_arg PARAMS ((tree, tree));\n-extern void mmix_asm_output_addr_diff_elt PARAMS ((FILE *, rtx, int, int));\n-extern void mmix_asm_output_addr_vec_elt PARAMS ((FILE *, int));\n-extern enum reg_class mmix_preferred_reload_class\n-  PARAMS ((rtx, enum reg_class));\n+  (const CUMULATIVE_ARGS *, enum machine_mode, tree, int, int);\n+extern rtx mmix_expand_builtin_va_arg (tree, tree);\n+extern void mmix_asm_output_addr_diff_elt (FILE *, rtx, int, int);\n+extern void mmix_asm_output_addr_vec_elt (FILE *, int);\n+extern enum reg_class mmix_preferred_reload_class (rtx, enum reg_class);\n extern enum reg_class mmix_preferred_output_reload_class\n-  PARAMS ((rtx, enum reg_class));\n+  (rtx, enum reg_class);\n extern enum reg_class mmix_secondary_reload_class\n-  PARAMS ((enum reg_class, enum machine_mode, rtx, int));\n-extern int mmix_const_ok_for_letter_p PARAMS ((HOST_WIDE_INT, int));\n-extern int mmix_const_double_ok_for_letter_p PARAMS ((rtx, int));\n-extern int mmix_extra_constraint PARAMS ((rtx, int, int));\n-extern rtx mmix_dynamic_chain_address PARAMS ((rtx));\n-extern rtx mmix_return_addr_rtx PARAMS ((int, rtx));\n-extern rtx mmix_eh_return_stackadj_rtx PARAMS ((void));\n-extern rtx mmix_eh_return_handler_rtx PARAMS ((void));\n-extern void mmix_initialize_trampoline PARAMS ((rtx, rtx, rtx));\n-extern int mmix_constant_address_p PARAMS ((rtx));\n-extern int mmix_legitimate_address PARAMS ((enum machine_mode, rtx, int));\n-extern int mmix_legitimate_constant_p PARAMS ((rtx));\n-extern void mmix_print_operand PARAMS ((FILE *, rtx, int));\n-extern void mmix_print_operand_address PARAMS ((FILE *, rtx));\n-extern void mmix_expand_prologue PARAMS ((void));\n-extern void mmix_expand_epilogue PARAMS ((void));\n-extern rtx mmix_get_hard_reg_initial_val PARAMS ((enum machine_mode, int));\n-extern int mmix_asm_preferred_eh_data_format PARAMS ((int, int));\n-extern void mmix_setup_frame_addresses PARAMS ((void));\n+  (enum reg_class, enum machine_mode, rtx, int);\n+extern int mmix_const_ok_for_letter_p (HOST_WIDE_INT, int);\n+extern int mmix_const_double_ok_for_letter_p (rtx, int);\n+extern int mmix_extra_constraint (rtx, int, int);\n+extern rtx mmix_dynamic_chain_address (rtx);\n+extern rtx mmix_return_addr_rtx (int, rtx);\n+extern rtx mmix_eh_return_stackadj_rtx (void);\n+extern rtx mmix_eh_return_handler_rtx (void);\n+extern void mmix_initialize_trampoline (rtx, rtx, rtx);\n+extern int mmix_constant_address_p (rtx);\n+extern int mmix_legitimate_address (enum machine_mode, rtx, int);\n+extern int mmix_legitimate_constant_p (rtx);\n+extern void mmix_print_operand (FILE *, rtx, int);\n+extern void mmix_print_operand_address (FILE *, rtx);\n+extern void mmix_expand_prologue (void);\n+extern void mmix_expand_epilogue (void);\n+extern rtx mmix_get_hard_reg_initial_val (enum machine_mode, int);\n+extern int mmix_asm_preferred_eh_data_format (int, int);\n+extern void mmix_setup_frame_addresses (void);\n \n #ifdef RTX_CODE\n /* Needs to be ifdef:d for sake of enum rtx_code.  */\n-extern enum machine_mode mmix_select_cc_mode PARAMS ((enum rtx_code, rtx, rtx));\n-extern void mmix_canonicalize_comparison PARAMS ((enum rtx_code *, rtx *, rtx *));\n-extern int mmix_valid_comparison PARAMS ((enum rtx_code, enum machine_mode, rtx));\n-extern rtx mmix_gen_compare_reg PARAMS ((enum rtx_code, rtx, rtx));\n+extern enum machine_mode mmix_select_cc_mode (enum rtx_code, rtx, rtx);\n+extern void mmix_canonicalize_comparison (enum rtx_code *, rtx *, rtx *);\n+extern int mmix_valid_comparison (enum rtx_code, enum machine_mode, rtx);\n+extern rtx mmix_gen_compare_reg (enum rtx_code, rtx, rtx);\n #endif\n \n /*"}, {"sha": "1feebdd9ae9f650198b92fedf4efb7e67c732da9", "filename": "gcc/config/mmix/mmix.c", "status": "modified", "additions": 169, "deletions": 309, "changes": 478, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e58524e8c8ff4144fb15fd2867c60bf46d6ca67/gcc%2Fconfig%2Fmmix%2Fmmix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e58524e8c8ff4144fb15fd2867c60bf46d6ca67/gcc%2Fconfig%2Fmmix%2Fmmix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmmix%2Fmmix.c?ref=4e58524e8c8ff4144fb15fd2867c60bf46d6ca67", "patch": "@@ -1,5 +1,5 @@\n /* Definitions of target machine for GNU compiler, for MMIX.\n-   Copyright (C) 2000, 2001, 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n    Contributed by Hans-Peter Nilsson (hp@bitrange.com)\n \n This file is part of GCC.\n@@ -117,28 +117,25 @@ const char *mmix_cc1_ignored_option;\n static int mmix_output_destination_register;\n \n static void mmix_output_shiftvalue_op_from_str\n-  PARAMS ((FILE *, const char *, HOST_WIDEST_INT));\n-static void mmix_output_shifted_value PARAMS ((FILE *, HOST_WIDEST_INT));\n-static void mmix_output_condition PARAMS ((FILE *, rtx, int));\n-static HOST_WIDEST_INT mmix_intval PARAMS ((rtx));\n-static void mmix_output_octa PARAMS ((FILE *, HOST_WIDEST_INT, int));\n-static bool mmix_assemble_integer PARAMS ((rtx, unsigned int, int));\n-static struct machine_function * mmix_init_machine_status PARAMS ((void));\n-static void mmix_encode_section_info PARAMS ((tree, rtx, int));\n-static const char *mmix_strip_name_encoding PARAMS ((const char *));\n-static void mmix_emit_sp_add PARAMS ((HOST_WIDE_INT offset));\n-static void mmix_target_asm_function_prologue\n-  PARAMS ((FILE *, HOST_WIDE_INT));\n-static void mmix_target_asm_function_end_prologue PARAMS ((FILE *));\n-static void mmix_target_asm_function_epilogue\n-  PARAMS ((FILE *, HOST_WIDE_INT));\n-static void mmix_reorg PARAMS ((void));\n+  (FILE *, const char *, HOST_WIDEST_INT);\n+static void mmix_output_shifted_value (FILE *, HOST_WIDEST_INT);\n+static void mmix_output_condition (FILE *, rtx, int);\n+static HOST_WIDEST_INT mmix_intval (rtx);\n+static void mmix_output_octa (FILE *, HOST_WIDEST_INT, int);\n+static bool mmix_assemble_integer (rtx, unsigned int, int);\n+static struct machine_function *mmix_init_machine_status (void);\n+static void mmix_encode_section_info (tree, rtx, int);\n+static const char *mmix_strip_name_encoding (const char *);\n+static void mmix_emit_sp_add (HOST_WIDE_INT offset);\n+static void mmix_target_asm_function_prologue (FILE *, HOST_WIDE_INT);\n+static void mmix_target_asm_function_end_prologue (FILE *);\n+static void mmix_target_asm_function_epilogue (FILE *, HOST_WIDE_INT);\n+static void mmix_reorg (void);\n static void mmix_asm_output_mi_thunk\n-  PARAMS ((FILE *, tree, HOST_WIDE_INT, HOST_WIDE_INT, tree));\n-static void mmix_file_start PARAMS ((void));\n-static void mmix_file_end PARAMS ((void));\n-static bool mmix_rtx_costs\n-  PARAMS ((rtx, int, int, int *));\n+  (FILE *, tree, HOST_WIDE_INT, HOST_WIDE_INT, tree);\n+static void mmix_file_start (void);\n+static void mmix_file_end (void);\n+static bool mmix_rtx_costs (rtx, int, int, int *);\n \n \n /* Target structure macros.  Listed by node.  See `Using and Porting GCC'\n@@ -198,7 +195,7 @@ struct gcc_target targetm = TARGET_INITIALIZER;\n /* OVERRIDE_OPTIONS.  */\n \n void\n-mmix_override_options ()\n+mmix_override_options (void)\n {\n   /* Should we err or should we warn?  Hmm.  At least we must neutralize\n      it.  For example the wrong kind of case-tables will be generated with\n@@ -215,15 +212,15 @@ mmix_override_options ()\n /* INIT_EXPANDERS.  */\n \n void\n-mmix_init_expanders ()\n+mmix_init_expanders (void)\n {\n   init_machine_status = mmix_init_machine_status;\n }\n \n /* Set the per-function data.  */\n \n static struct machine_function *\n-mmix_init_machine_status ()\n+mmix_init_machine_status (void)\n {\n   return ggc_alloc_cleared (sizeof (struct machine_function));\n }\n@@ -234,9 +231,7 @@ mmix_init_machine_status ()\n    at least 32-bit alignment. */\n \n int\n-mmix_data_alignment (type, basic_align)\n-     tree type ATTRIBUTE_UNUSED;\n-     int basic_align;\n+mmix_data_alignment (tree type ATTRIBUTE_UNUSED, int basic_align)\n {\n   if (basic_align < 32)\n     return 32;\n@@ -247,9 +242,7 @@ mmix_data_alignment (type, basic_align)\n /* CONSTANT_ALIGNMENT.  */\n \n int\n-mmix_constant_alignment (constant, basic_align)\n-     tree constant ATTRIBUTE_UNUSED;\n-     int basic_align;\n+mmix_constant_alignment (tree constant ATTRIBUTE_UNUSED, int basic_align)\n {\n   if (basic_align < 32)\n     return 32;\n@@ -260,9 +253,7 @@ mmix_constant_alignment (constant, basic_align)\n /* LOCAL_ALIGNMENT.  */\n \n int\n-mmix_local_alignment (type, basic_align)\n-     tree type ATTRIBUTE_UNUSED;\n-     int basic_align;\n+mmix_local_alignment (tree type ATTRIBUTE_UNUSED, int basic_align)\n {\n   if (basic_align < 32)\n     return 32;\n@@ -273,7 +264,7 @@ mmix_local_alignment (type, basic_align)\n /* CONDITIONAL_REGISTER_USAGE.  */\n \n void\n-mmix_conditional_register_usage ()\n+mmix_conditional_register_usage (void)\n {\n   int i;\n \n@@ -314,8 +305,7 @@ mmix_conditional_register_usage ()\n    saved are local.  */\n \n int\n-mmix_local_regno (regno)\n-     int regno;\n+mmix_local_regno (int regno)\n {\n   return regno <= MMIX_LAST_STACK_REGISTER_REGNUM && !call_used_regs[regno];\n }\n@@ -324,9 +314,7 @@ mmix_local_regno (regno)\n    We need to extend the reload class of REMAINDER_REG and HIMULT_REG.  */\n \n enum reg_class\n-mmix_preferred_reload_class (x, class)\n-     rtx x ATTRIBUTE_UNUSED;\n-     enum reg_class class;\n+mmix_preferred_reload_class (rtx x ATTRIBUTE_UNUSED, enum reg_class class)\n {\n   /* FIXME: Revisit.  */\n   return GET_CODE (x) == MOD && GET_MODE (x) == DImode\n@@ -337,9 +325,8 @@ mmix_preferred_reload_class (x, class)\n    We need to extend the reload class of REMAINDER_REG and HIMULT_REG.  */\n \n enum reg_class\n-mmix_preferred_output_reload_class (x, class)\n-     rtx x ATTRIBUTE_UNUSED;\n-     enum reg_class class;\n+mmix_preferred_output_reload_class (rtx x ATTRIBUTE_UNUSED,\n+\t\t\t\t    enum reg_class class)\n {\n   /* FIXME: Revisit.  */\n   return GET_CODE (x) == MOD && GET_MODE (x) == DImode\n@@ -350,11 +337,10 @@ mmix_preferred_output_reload_class (x, class)\n    We need to reload regs of REMAINDER_REG and HIMULT_REG elsewhere.  */\n \n enum reg_class\n-mmix_secondary_reload_class (class, mode, x, in_p)\n-     enum reg_class class;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n-     rtx x ATTRIBUTE_UNUSED;\n-     int in_p ATTRIBUTE_UNUSED;\n+mmix_secondary_reload_class (enum reg_class class,\n+\t\t\t     enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\t     rtx x ATTRIBUTE_UNUSED,\n+\t\t\t     int in_p ATTRIBUTE_UNUSED)\n {\n   if (class == REMAINDER_REG\n       || class == HIMULT_REG\n@@ -367,9 +353,7 @@ mmix_secondary_reload_class (class, mode, x, in_p)\n /* CONST_OK_FOR_LETTER_P.  */\n \n int\n-mmix_const_ok_for_letter_p (value, c)\n-     HOST_WIDE_INT value;\n-     int c;\n+mmix_const_ok_for_letter_p (HOST_WIDE_INT value, int c)\n {\n   return\n     (c == 'I' ? value >= 0 && value <= 255\n@@ -386,9 +370,7 @@ mmix_const_ok_for_letter_p (value, c)\n /* CONST_DOUBLE_OK_FOR_LETTER_P.  */\n \n int\n-mmix_const_double_ok_for_letter_p (value, c)\n-     rtx value;\n-     int c;\n+mmix_const_double_ok_for_letter_p (rtx value, int c)\n {\n   return\n     (c == 'G' ? value == CONST0_RTX (GET_MODE (value))\n@@ -400,10 +382,7 @@ mmix_const_double_ok_for_letter_p (value, c)\n    CONST_INT:s, but rather often as CONST_DOUBLE:s.  */\n \n int\n-mmix_extra_constraint (x, c, strict)\n-     rtx x;\n-     int c;\n-     int strict;\n+mmix_extra_constraint (rtx x, int c, int strict)\n {\n   HOST_WIDEST_INT value;\n \n@@ -455,8 +434,7 @@ mmix_extra_constraint (x, c, strict)\n /* DYNAMIC_CHAIN_ADDRESS.  */\n \n rtx\n-mmix_dynamic_chain_address (frame)\n-     rtx frame;\n+mmix_dynamic_chain_address (rtx frame)\n {\n   /* FIXME: the frame-pointer is stored at offset -8 from the current\n      frame-pointer.  Unfortunately, the caller assumes that a\n@@ -468,7 +446,7 @@ mmix_dynamic_chain_address (frame)\n /* STARTING_FRAME_OFFSET.  */\n \n int\n-mmix_starting_frame_offset ()\n+mmix_starting_frame_offset (void)\n {\n   /* The old frame pointer is in the slot below the new one, so\n      FIRST_PARM_OFFSET does not need to depend on whether the\n@@ -485,9 +463,7 @@ mmix_starting_frame_offset ()\n /* RETURN_ADDR_RTX.  */\n \n rtx\n-mmix_return_addr_rtx (count, frame)\n-     int count;\n-     rtx frame ATTRIBUTE_UNUSED;\n+mmix_return_addr_rtx (int count, rtx frame ATTRIBUTE_UNUSED)\n {\n   return count == 0\n     ? (MMIX_CFUN_NEEDS_SAVED_EH_RETURN_ADDRESS\n@@ -503,7 +479,7 @@ mmix_return_addr_rtx (count, frame)\n /* SETUP_FRAME_ADDRESSES.  */\n \n void\n-mmix_setup_frame_addresses ()\n+mmix_setup_frame_addresses (void)\n {\n   /* Nothing needed at the moment.  */\n }\n@@ -512,9 +488,7 @@ mmix_setup_frame_addresses ()\n    pointer.  Used to eliminate the frame pointer.  */\n \n int\n-mmix_initial_elimination_offset (fromreg, toreg)\n-     int fromreg;\n-     int toreg;\n+mmix_initial_elimination_offset (int fromreg, int toreg)\n {\n   int regno;\n   int fp_sp_offset\n@@ -567,12 +541,11 @@ mmix_initial_elimination_offset (fromreg, toreg)\n    one that must go on stack.  */\n \n rtx\n-mmix_function_arg (argsp, mode, type, named, incoming)\n-     const CUMULATIVE_ARGS * argsp;\n-     enum machine_mode mode;\n-     tree type;\n-     int named ATTRIBUTE_UNUSED;\n-     int incoming;\n+mmix_function_arg (const CUMULATIVE_ARGS *argsp,\n+\t\t   enum machine_mode mode,\n+\t\t   tree type,\n+\t\t   int named ATTRIBUTE_UNUSED,\n+\t\t   int incoming)\n {\n   /* Last-argument marker.  */\n   if (type == void_type_node)\n@@ -600,11 +573,10 @@ mmix_function_arg (argsp, mode, type, named, incoming)\n    everything that goes by value.  */\n \n int\n-mmix_function_arg_pass_by_reference (argsp, mode, type, named)\n-     const CUMULATIVE_ARGS * argsp;\n-     enum machine_mode mode;\n-     tree type;\n-     int named ATTRIBUTE_UNUSED;\n+mmix_function_arg_pass_by_reference (const CUMULATIVE_ARGS *argsp,\n+\t\t\t\t     enum machine_mode mode,\n+\t\t\t\t     tree type,\n+\t\t\t\t     int named ATTRIBUTE_UNUSED)\n {\n   /* FIXME: Check: I'm not sure the MUST_PASS_IN_STACK check is\n      necessary.  */\n@@ -619,9 +591,7 @@ mmix_function_arg_pass_by_reference (argsp, mode, type, named)\n    passed, and 0 otherwise.  */\n \n int\n-mmix_function_arg_regno_p (regno, incoming)\n-     int regno;\n-     int incoming;\n+mmix_function_arg_regno_p (int regno, int incoming)\n {\n   int first_arg_regnum\n     = incoming ? MMIX_FIRST_INCOMING_ARG_REGNUM : MMIX_FIRST_ARG_REGNUM;\n@@ -633,9 +603,7 @@ mmix_function_arg_regno_p (regno, incoming)\n /* FUNCTION_OUTGOING_VALUE.  */\n \n rtx\n-mmix_function_outgoing_value (valtype, func)\n-     tree valtype;\n-     tree func ATTRIBUTE_UNUSED;\n+mmix_function_outgoing_value (tree valtype, tree func ATTRIBUTE_UNUSED)\n {\n   enum machine_mode mode = TYPE_MODE (valtype);\n   enum machine_mode cmode;\n@@ -684,17 +652,15 @@ mmix_function_outgoing_value (valtype, func)\n /* FUNCTION_VALUE_REGNO_P.  */\n \n int\n-mmix_function_value_regno_p (regno)\n-     int regno;\n+mmix_function_value_regno_p (int regno)\n {\n   return regno == MMIX_RETURN_VALUE_REGNUM;\n }\n \n /* EH_RETURN_DATA_REGNO. */\n \n int\n-mmix_eh_return_data_regno (n)\n-     int n ATTRIBUTE_UNUSED;\n+mmix_eh_return_data_regno (int n)\n {\n   if (n >= 0 && n < 4)\n     return MMIX_EH_RETURN_DATA_REGNO_START + n;\n@@ -705,26 +671,24 @@ mmix_eh_return_data_regno (n)\n /* EH_RETURN_STACKADJ_RTX. */\n \n rtx\n-mmix_eh_return_stackadj_rtx ()\n+mmix_eh_return_stackadj_rtx (void)\n {\n   return gen_rtx_REG (Pmode, MMIX_EH_RETURN_STACKADJ_REGNUM);\n }\n \n /* EH_RETURN_HANDLER_RTX.  */\n \n rtx\n-mmix_eh_return_handler_rtx ()\n+mmix_eh_return_handler_rtx (void)\n {\n-  return\n-    gen_rtx_REG (Pmode, MMIX_INCOMING_RETURN_ADDRESS_REGNUM);\n+  return gen_rtx_REG (Pmode, MMIX_INCOMING_RETURN_ADDRESS_REGNUM);\n }\n \n /* ASM_PREFERRED_EH_DATA_FORMAT. */\n \n int\n-mmix_asm_preferred_eh_data_format (code, global)\n-     int code ATTRIBUTE_UNUSED;\n-     int global ATTRIBUTE_UNUSED;\n+mmix_asm_preferred_eh_data_format (int code ATTRIBUTE_UNUSED,\n+\t\t\t\t   int global ATTRIBUTE_UNUSED)\n {\n   /* This is the default (was at 2001-07-20).  Revisit when needed.  */\n   return DW_EH_PE_absptr;\n@@ -735,18 +699,16 @@ mmix_asm_preferred_eh_data_format (code, global)\n    mmix_reorg.  */\n \n static void\n-mmix_target_asm_function_prologue (stream, framesize)\n-     FILE *stream ATTRIBUTE_UNUSED;\n-     HOST_WIDE_INT framesize ATTRIBUTE_UNUSED;\n+mmix_target_asm_function_prologue (FILE *stream ATTRIBUTE_UNUSED,\n+\t\t\t\t   HOST_WIDE_INT framesize ATTRIBUTE_UNUSED)\n {\n   cfun->machine->in_prologue = 1;\n }\n \n /* Make a note that we've seen the end of the prologue.  */\n \n static void\n-mmix_target_asm_function_end_prologue (stream)\n-     FILE *stream ATTRIBUTE_UNUSED;\n+mmix_target_asm_function_end_prologue (FILE *stream ATTRIBUTE_UNUSED)\n {\n   cfun->machine->in_prologue = 0;\n }\n@@ -756,7 +718,7 @@ mmix_target_asm_function_end_prologue (stream)\n    register number used to modify the register numbers at output time.  */\n \n static void\n-mmix_reorg ()\n+mmix_reorg (void)\n {\n   int regno;\n \n@@ -796,10 +758,8 @@ mmix_reorg ()\n /* TARGET_ASM_FUNCTION_EPILOGUE.  */\n \n static void\n-mmix_target_asm_function_epilogue (stream, locals_size)\n-     FILE *stream;\n-     HOST_WIDE_INT locals_size ATTRIBUTE_UNUSED;\n-\n+mmix_target_asm_function_epilogue (FILE *stream,\n+\t\t\t\t   HOST_WIDE_INT locals_size ATTRIBUTE_UNUSED)\n {\n   /* Emit an \\n for readability of the generated assembly.  */\n   fputc ('\\n', stream);\n@@ -808,12 +768,11 @@ mmix_target_asm_function_epilogue (stream, locals_size)\n /* TARGET_ASM_OUTPUT_MI_THUNK.  */\n \n static void\n-mmix_asm_output_mi_thunk (stream, fndecl, delta, vcall_offset, func)\n-     FILE * stream;\n-     tree fndecl ATTRIBUTE_UNUSED;\n-     HOST_WIDE_INT delta;\n-     HOST_WIDE_INT vcall_offset ATTRIBUTE_UNUSED;\n-     tree func;\n+mmix_asm_output_mi_thunk (FILE *stream,\n+\t\t\t  tree fndecl ATTRIBUTE_UNUSED,\n+\t\t\t  HOST_WIDE_INT delta,\n+\t\t\t  HOST_WIDE_INT vcall_offset ATTRIBUTE_UNUSED,\n+\t\t\t  tree func)\n {\n   /* If you define STRUCT_VALUE to 0, rather than use STRUCT_VALUE_REGNUM,\n      (i.e. pass location of structure to return as invisible first\n@@ -838,23 +797,20 @@ mmix_asm_output_mi_thunk (stream, fndecl, delta, vcall_offset, func)\n /* FUNCTION_PROFILER.  */\n \n void\n-mmix_function_profiler (stream, labelno)\n-     FILE *stream ATTRIBUTE_UNUSED;\n-     int labelno ATTRIBUTE_UNUSED;\n+mmix_function_profiler (FILE *stream ATTRIBUTE_UNUSED,\n+\t\t\tint labelno ATTRIBUTE_UNUSED)\n {\n   sorry (\"function_profiler support for MMIX\");\n }\n \n /* SETUP_INCOMING_VARARGS.  */\n \n void\n-mmix_setup_incoming_varargs (args_so_farp, mode, vartype, pretend_sizep,\n-\t\t\t     second_time)\n-     CUMULATIVE_ARGS * args_so_farp;\n-     enum machine_mode mode;\n-     tree vartype;\n-     int * pretend_sizep;\n-     int second_time ATTRIBUTE_UNUSED;\n+mmix_setup_incoming_varargs (CUMULATIVE_ARGS *args_so_farp,\n+\t\t\t     enum machine_mode mode,\n+\t\t\t     tree vartype,\n+\t\t\t     int *pretend_sizep,\n+\t\t\t     int second_time ATTRIBUTE_UNUSED)\n {\n   /* The last named variable has been handled, but\n      args_so_farp has not been advanced for it.  */\n@@ -875,9 +831,7 @@ mmix_setup_incoming_varargs (args_so_farp, mode, vartype, pretend_sizep,\n    pass-by-reference, then perform an indirection.  */\n \n rtx\n-mmix_expand_builtin_va_arg (valist, type)\n-     tree valist;\n-     tree type;\n+mmix_expand_builtin_va_arg (tree valist, tree type)\n {\n   tree ptr_size = size_int (BITS_PER_WORD / BITS_PER_UNIT);\n   tree addr_tree, type_size = NULL;\n@@ -982,8 +936,7 @@ int mmix_trampoline_size = 32;\n /* TRAMPOLINE_TEMPLATE.  */\n \n void\n-mmix_trampoline_template (stream)\n-     FILE * stream;\n+mmix_trampoline_template (FILE *stream)\n {\n   /* Read a value into the static-chain register and jump somewhere.  The\n      static chain is stored at offset 16, and the function address is\n@@ -1005,10 +958,7 @@ mmix_trampoline_template (stream)\n    some day it will).  */\n \n void\n-mmix_initialize_trampoline (trampaddr, fnaddr, static_chain)\n-     rtx trampaddr;\n-     rtx fnaddr;\n-     rtx static_chain;\n+mmix_initialize_trampoline (rtx trampaddr, rtx fnaddr, rtx static_chain)\n {\n   emit_move_insn (gen_rtx_MEM (DImode, plus_constant (trampaddr, 16)),\n \t\t  static_chain);\n@@ -1025,8 +975,7 @@ mmix_initialize_trampoline (trampaddr, fnaddr, static_chain)\n    instruction, unless TARGET_BASE_ADDRESSES.  */\n \n int\n-mmix_constant_address_p (x)\n-     rtx x;\n+mmix_constant_address_p (rtx x)\n {\n   RTX_CODE code = GET_CODE (x);\n   int addend = 0;\n@@ -1089,10 +1038,9 @@ mmix_constant_address_p (x)\n    Used by GO_IF_LEGITIMATE_ADDRESS.  */\n \n int\n-mmix_legitimate_address (mode, x, strict_checking)\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n-     rtx x;\n-     int strict_checking;\n+mmix_legitimate_address (enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\t rtx x,\n+\t\t\t int strict_checking)\n {\n #define MMIX_REG_OK(X)\t\t\t\t\t\t\t\\\n   ((strict_checking\t\t\t\t\t\t\t\\\n@@ -1151,8 +1099,7 @@ mmix_legitimate_address (mode, x, strict_checking)\n /* LEGITIMATE_CONSTANT_P.  */\n \n int\n-mmix_legitimate_constant_p (x)\n-     rtx x;\n+mmix_legitimate_constant_p (rtx x)\n {\n   RTX_CODE code = GET_CODE (x);\n \n@@ -1168,10 +1115,7 @@ mmix_legitimate_constant_p (x)\n /* SELECT_CC_MODE.  */\n \n enum machine_mode\n-mmix_select_cc_mode (op, x, y)\n-     RTX_CODE op;\n-     rtx x;\n-     rtx y ATTRIBUTE_UNUSED;\n+mmix_select_cc_mode (RTX_CODE op, rtx x, rtx y ATTRIBUTE_UNUSED)\n {\n   /* We use CCmode, CC_UNSmode, CC_FPmode, CC_FPEQmode and CC_FUNmode to\n      output different compare insns.  Note that we do not check the\n@@ -1198,8 +1142,7 @@ mmix_select_cc_mode (op, x, y)\n /* REVERSIBLE_CC_MODE.  */\n \n int\n-mmix_reversible_cc_mode (mode)\n-     enum machine_mode mode;\n+mmix_reversible_cc_mode (enum machine_mode mode)\n {\n   /* That is, all integer and the EQ, NE, ORDERED and UNORDERED float\n      compares.  */\n@@ -1209,11 +1152,10 @@ mmix_reversible_cc_mode (mode)\n /* TARGET_RTX_COSTS.  */\n \n static bool\n-mmix_rtx_costs (x, code, outer_code, total)\n-     rtx x ATTRIBUTE_UNUSED;\n-     int code ATTRIBUTE_UNUSED;\n-     int outer_code ATTRIBUTE_UNUSED;\n-     int *total ATTRIBUTE_UNUSED;\n+mmix_rtx_costs (rtx x ATTRIBUTE_UNUSED,\n+\t\tint code ATTRIBUTE_UNUSED,\n+\t\tint outer_code ATTRIBUTE_UNUSED,\n+\t\tint *total ATTRIBUTE_UNUSED)\n {\n   /* For the time being, this is just a stub and we'll accept the\n      generic calculations, until we can do measurements, at least.\n@@ -1224,10 +1166,9 @@ mmix_rtx_costs (x, code, outer_code, total)\n /* REGISTER_MOVE_COST.  */\n \n int\n-mmix_register_move_cost (mode, from, to)\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n-     enum reg_class from;\n-     enum reg_class to;\n+mmix_register_move_cost (enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\t enum reg_class from,\n+\t\t\t enum reg_class to)\n {\n   return (from == GENERAL_REGS && from == to) ? 2 : 3;\n }\n@@ -1239,16 +1180,13 @@ mmix_register_move_cost (mode, from, to)\n /* DATA_SECTION_ASM_OP.  */\n \n const char *\n-mmix_data_section_asm_op ()\n+mmix_data_section_asm_op (void)\n {\n   return \"\\t.data ! mmixal:= 8H LOC 9B\";\n }\n \n static void\n-mmix_encode_section_info (decl, rtl, first)\n-     tree decl;\n-     rtx rtl;\n-     int first;\n+mmix_encode_section_info (tree decl, rtx rtl, int first)\n {\n   /* Test for an external declaration, and do nothing if it is one.  */\n   if ((TREE_CODE (decl) == VAR_DECL\n@@ -1293,8 +1231,7 @@ mmix_encode_section_info (decl, rtl, first)\n }\n \n static const char *\n-mmix_strip_name_encoding (name)\n-     const char *name;\n+mmix_strip_name_encoding (const char *name)\n {\n   for (; (*name == '@' || *name == '*'); name++)\n     ;\n@@ -1306,7 +1243,7 @@ mmix_strip_name_encoding (name)\n    We just emit a little comment for the time being.  */\n \n static void\n-mmix_file_start ()\n+mmix_file_start (void)\n {\n   default_file_start ();\n \n@@ -1319,7 +1256,7 @@ mmix_file_start ()\n /* TARGET_ASM_FILE_END.  */\n \n static void\n-mmix_file_end ()\n+mmix_file_end (void)\n {\n   /* Make sure each file ends with the data section. */\n   data_section ();\n@@ -1328,9 +1265,7 @@ mmix_file_end ()\n /* ASM_OUTPUT_SOURCE_FILENAME.  */\n \n void\n-mmix_asm_output_source_filename (stream, name)\n-     FILE * stream;\n-     const char * name;\n+mmix_asm_output_source_filename (FILE *stream, const char *name)\n {\n   fprintf (stream, \"# 1 \");\n   OUTPUT_QUOTED_STRING (stream, name);\n@@ -1340,10 +1275,7 @@ mmix_asm_output_source_filename (stream, name)\n /* OUTPUT_QUOTED_STRING.  */\n \n void\n-mmix_output_quoted_string (stream, string, length)\n-     FILE * stream;\n-     const char * string;\n-     int length;\n+mmix_output_quoted_string (FILE *stream, const char *string, int length)\n {\n   const char * string_end = string + length;\n   static const char *const unwanted_chars = \"\\\"[]\\\\\";\n@@ -1387,9 +1319,7 @@ mmix_output_quoted_string (stream, string, length)\n /* ASM_OUTPUT_SOURCE_LINE.  */\n \n void\n-mmix_asm_output_source_line  (stream, lineno)\n-     FILE * stream;\n-     int lineno;\n+mmix_asm_output_source_line  (FILE *stream, int lineno)\n {\n   fprintf (stream, \"# %d \", lineno);\n   OUTPUT_QUOTED_STRING (stream, main_input_filename);\n@@ -1401,10 +1331,7 @@ mmix_asm_output_source_line  (stream, lineno)\n    CONST_DOUBLEs.  */\n \n static bool\n-mmix_assemble_integer (x, size, aligned_p)\n-     rtx x;\n-     unsigned int size;\n-     int aligned_p;\n+mmix_assemble_integer (rtx x, unsigned int size, int aligned_p)\n {\n   if (aligned_p)\n     switch (size)\n@@ -1465,10 +1392,7 @@ mmix_assemble_integer (x, size, aligned_p)\n /* ASM_OUTPUT_ASCII.  */\n \n void\n-mmix_asm_output_ascii (stream, string, length)\n-     FILE *stream;\n-     const char *string;\n-     int length;\n+mmix_asm_output_ascii (FILE *stream, const char *string, int length)\n {\n   while (length > 0)\n     {\n@@ -1484,11 +1408,10 @@ mmix_asm_output_ascii (stream, string, length)\n /* ASM_OUTPUT_ALIGNED_COMMON.  */\n \n void\n-mmix_asm_output_aligned_common (stream, name, size, align)\n-     FILE *stream;\n-     const char *name;\n-     int size;\n-     int align;\n+mmix_asm_output_aligned_common (FILE *stream,\n+\t\t\t\tconst char *name,\n+\t\t\t\tint size,\n+\t\t\t\tint align)\n {\n   /* This is mostly the elfos.h one.  There doesn't seem to be a way to\n      express this in a mmixal-compatible way.  */\n@@ -1501,11 +1424,10 @@ mmix_asm_output_aligned_common (stream, name, size, align)\n /* ASM_OUTPUT_ALIGNED_LOCAL.  */\n \n void\n-mmix_asm_output_aligned_local (stream, name, size, align)\n-     FILE * stream;\n-     const char * name;\n-     int size;\n-     int align;\n+mmix_asm_output_aligned_local (FILE *stream,\n+\t\t\t       const char *name,\n+\t\t\t       int size,\n+\t\t\t       int align)\n {\n   data_section ();\n \n@@ -1517,9 +1439,7 @@ mmix_asm_output_aligned_local (stream, name, size, align)\n /* ASM_OUTPUT_LABEL.  */\n \n void\n-mmix_asm_output_label (stream, name)\n-     FILE *stream;\n-     const char * name;\n+mmix_asm_output_label (FILE *stream, const char *name)\n {\n   assemble_name (stream, name);\n   fprintf (stream, \"\\tIS @\\n\");\n@@ -1528,11 +1448,10 @@ mmix_asm_output_label (stream, name)\n /* ASM_DECLARE_REGISTER_GLOBAL.  */\n \n void\n-mmix_asm_declare_register_global (stream, decl, regno, name)\n-     FILE *stream ATTRIBUTE_UNUSED;\n-     tree decl ATTRIBUTE_UNUSED;\n-     int regno ATTRIBUTE_UNUSED;\n-     const char *name ATTRIBUTE_UNUSED;\n+mmix_asm_declare_register_global (FILE *stream ATTRIBUTE_UNUSED,\n+\t\t\t\t  tree decl ATTRIBUTE_UNUSED,\n+\t\t\t\t  int regno ATTRIBUTE_UNUSED,\n+\t\t\t\t  const char *name ATTRIBUTE_UNUSED)\n {\n   /* Nothing to do here, but there *will* be, therefore the framework is\n      here.  */\n@@ -1541,9 +1460,8 @@ mmix_asm_declare_register_global (stream, decl, regno, name)\n /* ASM_WEAKEN_LABEL.  */\n \n void\n-mmix_asm_weaken_label (stream, name)\n-     FILE * stream ATTRIBUTE_UNUSED;\n-     const char * name ATTRIBUTE_UNUSED;\n+mmix_asm_weaken_label (FILE *stream ATTRIBUTE_UNUSED,\n+\t\t       const char *name ATTRIBUTE_UNUSED)\n {\n   fprintf (stream, \"\\t.weak \");\n   assemble_name (stream, name);\n@@ -1553,8 +1471,7 @@ mmix_asm_weaken_label (stream, name)\n /* MAKE_DECL_ONE_ONLY.  */\n \n void\n-mmix_make_decl_one_only (decl)\n-     tree decl;\n+mmix_make_decl_one_only (tree decl)\n {\n   DECL_WEAK (decl) = 1;\n }\n@@ -1563,9 +1480,7 @@ mmix_make_decl_one_only (decl)\n    Strip GCC's '*' and our own '@'.  No order is assumed.  */\n \n void\n-mmix_asm_output_labelref (stream, name)\n-     FILE *stream;\n-     const char *name;\n+mmix_asm_output_labelref (FILE *stream, const char *name)\n {\n   int is_extern = 1;\n \n@@ -1581,10 +1496,7 @@ mmix_asm_output_labelref (stream, name)\n /* ASM_OUTPUT_DEF.  */\n \n void\n-mmix_asm_output_def (stream, name, value)\n-     FILE * stream;\n-     const char * name;\n-     const char * value;\n+mmix_asm_output_def (FILE *stream, const char *name, const char *value)\n {\n   assemble_name (stream, name);\n   fprintf (stream, \"\\tIS \");\n@@ -1595,10 +1507,7 @@ mmix_asm_output_def (stream, name, value)\n /* PRINT_OPERAND.  */\n \n void\n-mmix_print_operand (stream, x, code)\n-     FILE * stream;\n-     rtx x;\n-     int code;\n+mmix_print_operand (FILE *stream, rtx x, int code)\n {\n   /* When we add support for different codes later, we can, when needed,\n      drop through to the main handler with a modified operand.  */\n@@ -1825,8 +1734,7 @@ mmix_print_operand (stream, x, code)\n /* PRINT_OPERAND_PUNCT_VALID_P.  */\n \n int\n-mmix_print_operand_punct_valid_p (code)\n-     int code ATTRIBUTE_UNUSED;\n+mmix_print_operand_punct_valid_p (int code ATTRIBUTE_UNUSED)\n {\n   /* A '+' is used for branch prediction, similar to other ports.  */\n   return code == '+'\n@@ -1837,9 +1745,7 @@ mmix_print_operand_punct_valid_p (code)\n /* PRINT_OPERAND_ADDRESS.  */\n \n void\n-mmix_print_operand_address (stream, x)\n-     FILE *stream;\n-     rtx x;\n+mmix_print_operand_address (FILE *stream, rtx x)\n {\n   if (REG_P (x))\n     {\n@@ -1884,9 +1790,7 @@ mmix_print_operand_address (stream, x)\n /* ASM_OUTPUT_REG_PUSH.  */\n \n void\n-mmix_asm_output_reg_push (stream, regno)\n-     FILE * stream;\n-     int regno;\n+mmix_asm_output_reg_push (FILE *stream, int regno)\n {\n   fprintf (stream, \"\\tSUBU %s,%s,8\\n\\tSTOU %s,%s,0\\n\",\n \t   reg_names[MMIX_STACK_POINTER_REGNUM],\n@@ -1898,9 +1802,7 @@ mmix_asm_output_reg_push (stream, regno)\n /* ASM_OUTPUT_REG_POP.  */\n \n void\n-mmix_asm_output_reg_pop (stream, regno)\n-     FILE * stream;\n-     int regno;\n+mmix_asm_output_reg_pop (FILE *stream, int regno)\n {\n   fprintf (stream, \"\\tLDOU %s,%s,0\\n\\tINCL %s,8\\n\",\n \t   reg_names[MMIX_OUTPUT_REGNO (regno)],\n@@ -1911,41 +1813,34 @@ mmix_asm_output_reg_pop (stream, regno)\n /* ASM_OUTPUT_ADDR_DIFF_ELT.  */\n \n void\n-mmix_asm_output_addr_diff_elt (stream, body, value, rel)\n-     FILE *stream;\n-     rtx body ATTRIBUTE_UNUSED;\n-     int value;\n-     int rel;\n+mmix_asm_output_addr_diff_elt (FILE *stream,\n+\t\t\t       rtx body ATTRIBUTE_UNUSED,\n+\t\t\t       int value,\n+\t\t\t       int rel)\n {\n   fprintf (stream, \"\\tTETRA L%d-L%d\\n\", value, rel);\n }\n \n /* ASM_OUTPUT_ADDR_VEC_ELT.  */\n \n void\n-mmix_asm_output_addr_vec_elt (stream, value)\n-     FILE *stream;\n-     int value;\n+mmix_asm_output_addr_vec_elt (FILE *stream, int value)\n {\n   fprintf (stream, \"\\tOCTA L:%d\\n\", value);\n }\n \n /* ASM_OUTPUT_SKIP.  */\n \n void\n-mmix_asm_output_skip (stream, nbytes)\n-     FILE *stream;\n-     int nbytes;\n+mmix_asm_output_skip (FILE *stream, int nbytes)\n {\n   fprintf (stream, \"\\tLOC @+%d\\n\", nbytes);\n }\n \n /* ASM_OUTPUT_ALIGN.  */\n \n void\n-mmix_asm_output_align (stream, power)\n-     FILE *stream;\n-     int power;\n+mmix_asm_output_align (FILE *stream, int power)\n {\n   /* We need to record the needed alignment of this section in the object,\n      so we have to output an alignment directive.  Use a .p2align (not\n@@ -1960,8 +1855,7 @@ mmix_asm_output_align (stream, power)\n /* DBX_REGISTER_NUMBER.  */\n \n int\n-mmix_dbx_register_number (regno)\n-     int regno;\n+mmix_dbx_register_number (int regno)\n {\n   /* Adjust the register number to the one it will be output as, dammit.\n      It'd be nice if we could check the assumption that we're filling a\n@@ -1979,15 +1873,13 @@ mmix_dbx_register_number (regno)\n \n /* End of target macro support functions.\n \n-   Now MMIX's own functions.  First the exported ones.  */\n+   Now the MMIX port's own functions.  First the exported ones.  */\n \n /* Wrapper for get_hard_reg_initial_val since integrate.h isn't included\n    from insn-emit.c.  */\n \n rtx\n-mmix_get_hard_reg_initial_val (mode, regno)\n-     enum machine_mode mode;\n-     int regno;\n+mmix_get_hard_reg_initial_val (enum machine_mode mode, int regno)\n {\n   return get_hard_reg_initial_val (mode, regno);\n }\n@@ -1996,7 +1888,7 @@ mmix_get_hard_reg_initial_val (mode, regno)\n    \"POP %d,0\" should be used even within the function.  */\n \n int\n-mmix_use_simple_return ()\n+mmix_use_simple_return (void)\n {\n   int regno;\n \n@@ -2033,7 +1925,7 @@ mmix_use_simple_return ()\n /* Expands the function prologue into RTX.  */\n \n void\n-mmix_expand_prologue ()\n+mmix_expand_prologue (void)\n {\n   HOST_WIDE_INT locals_size = get_frame_size ();\n   int regno;\n@@ -2268,7 +2160,7 @@ mmix_expand_prologue ()\n /* Expands the function epilogue into RTX.  */\n \n void\n-mmix_expand_epilogue ()\n+mmix_expand_epilogue (void)\n {\n   HOST_WIDE_INT locals_size = get_frame_size ();\n   int regno;\n@@ -2391,11 +2283,10 @@ mmix_expand_epilogue ()\n    first insn and after the last insn is wanted.  */\n \n void\n-mmix_output_register_setting (stream, regno, value, do_begin_end)\n-     FILE *stream;\n-     int regno;\n-     HOST_WIDEST_INT value;\n-     int do_begin_end;\n+mmix_output_register_setting (FILE *stream,\n+\t\t\t      int regno,\n+\t\t\t      HOST_WIDEST_INT value,\n+\t\t\t      int do_begin_end)\n {\n   if (do_begin_end)\n     fprintf (stream, \"\\t\");\n@@ -2503,8 +2394,7 @@ mmix_output_register_setting (stream, regno, value, do_begin_end)\n    else return 0.  */\n \n int\n-mmix_shiftable_wyde_value (value)\n-     unsigned HOST_WIDEST_INT value;\n+mmix_shiftable_wyde_value (unsigned HOST_WIDEST_INT value)\n {\n   /* Shift by 16 bits per group, stop when we've found two groups with\n      nonzero bits.  */\n@@ -2530,9 +2420,7 @@ mmix_shiftable_wyde_value (value)\n /* True if this is an address_operand or a symbolic operand.  */\n \n int\n-mmix_symbolic_or_address_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+mmix_symbolic_or_address_operand (rtx op, enum machine_mode mode)\n {\n   switch (GET_CODE (op))\n     {\n@@ -2558,9 +2446,7 @@ mmix_symbolic_or_address_operand (op, mode)\n    doesn't seem to be worth it at the moment.  */\n \n int\n-mmix_reg_or_constant_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+mmix_reg_or_constant_operand (rtx op, enum machine_mode mode)\n {\n   return register_operand (op, mode)\n     || (GET_CODE (op) == CONST_DOUBLE && GET_MODE (op) == VOIDmode)\n@@ -2570,9 +2456,7 @@ mmix_reg_or_constant_operand (op, mode)\n /* True if this is a register with a condition-code mode.  */\n \n int\n-mmix_reg_cc_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+mmix_reg_cc_operand (rtx op, enum machine_mode mode)\n {\n   if (mode == VOIDmode)\n     mode = GET_MODE (op);\n@@ -2587,9 +2471,7 @@ mmix_reg_cc_operand (op, mode)\n    replaced by (reg).  */\n \n int\n-mmix_foldable_comparison_operator (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+mmix_foldable_comparison_operator (rtx op, enum machine_mode mode)\n {\n   RTX_CODE code = GET_CODE (op);\n \n@@ -2614,9 +2496,7 @@ mmix_foldable_comparison_operator (op, mode)\n    code with -ffast-math (gcc.dg/20001228-1.c).  */\n \n int\n-mmix_comparison_operator (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+mmix_comparison_operator (rtx op, enum machine_mode mode)\n {\n   RTX_CODE code = GET_CODE (op);\n \n@@ -2652,9 +2532,7 @@ mmix_comparison_operator (op, mode)\n /* True if this is a register or 0 (int or float).  */\n \n int\n-mmix_reg_or_0_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+mmix_reg_or_0_operand (rtx op, enum machine_mode mode)\n {\n   /* FIXME: Is mode calculation necessary and correct?  */\n   return\n@@ -2665,9 +2543,7 @@ mmix_reg_or_0_operand (op, mode)\n /* True if this is a register or an int 0..255.  */\n \n int\n-mmix_reg_or_8bit_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+mmix_reg_or_8bit_operand (rtx op, enum machine_mode mode)\n {\n   return register_operand (op, mode)\n     || (GET_CODE (op) == CONST_INT\n@@ -2679,10 +2555,7 @@ mmix_reg_or_8bit_operand (op, mode)\n    is the comparison of mode is CC-somethingmode.  */\n \n int\n-mmix_valid_comparison (code, mode, op)\n-     RTX_CODE code;\n-     enum machine_mode mode;\n-     rtx op;\n+mmix_valid_comparison (RTX_CODE code, enum machine_mode mode, rtx op)\n {\n   if (mode == VOIDmode && op != NULL_RTX)\n     mode = GET_MODE (op);\n@@ -2711,9 +2584,7 @@ mmix_valid_comparison (code, mode, op)\n    NULL_RTX if this is not a valid comparison.  */\n \n rtx\n-mmix_gen_compare_reg (code, x, y)\n-     RTX_CODE code;\n-     rtx x, y;\n+mmix_gen_compare_reg (RTX_CODE code, rtx x, rtx y)\n {\n   enum machine_mode ccmode = SELECT_CC_MODE (code, x, y);\n   rtx cc_reg;\n@@ -2748,8 +2619,7 @@ mmix_gen_compare_reg (code, x, y)\n /* Local (static) helper functions.  */\n \n static void\n-mmix_emit_sp_add (offset)\n-     HOST_WIDE_INT offset;\n+mmix_emit_sp_add (HOST_WIDE_INT offset)\n {\n   rtx insn;\n \n@@ -2793,10 +2663,9 @@ mmix_emit_sp_add (offset)\n    wyde.  The type of operator is passed as an asm output modifier.  */\n \n static void\n-mmix_output_shiftvalue_op_from_str (stream, mainop, value)\n-     FILE *stream;\n-     const char *mainop;\n-     HOST_WIDEST_INT value;\n+mmix_output_shiftvalue_op_from_str (FILE *stream,\n+\t\t\t\t    const char *mainop,\n+\t\t\t\t    HOST_WIDEST_INT value)\n {\n   static const char *const op_part[] = {\"L\", \"ML\", \"MH\", \"H\"};\n   int i;\n@@ -2827,10 +2696,7 @@ mmix_output_shiftvalue_op_from_str (stream, mainop, value)\n /* Print a 64-bit value, optionally prefixed by assembly pseudo.  */\n \n static void\n-mmix_output_octa (stream, value, do_begin_end)\n-     FILE *stream;\n-     HOST_WIDEST_INT value;\n-     int do_begin_end;\n+mmix_output_octa (FILE *stream, HOST_WIDEST_INT value, int do_begin_end)\n {\n   /* Snipped from final.c:output_addr_const.  We need to avoid the\n      presumed universal \"0x\" prefix.  We can do it by replacing \"0x\" with\n@@ -2864,9 +2730,7 @@ mmix_output_octa (stream, value, do_begin_end)\n    be output with an operand).  */\n \n static void\n-mmix_output_shifted_value (stream, value)\n-     FILE * stream;\n-     HOST_WIDEST_INT value;\n+mmix_output_shifted_value (FILE *stream, HOST_WIDEST_INT value)\n {\n   int i;\n \n@@ -2878,13 +2742,13 @@ mmix_output_shifted_value (stream, value)\n     }\n \n   for (i = 0; i < 4; i++)\n-  {\n-    /* We know we're through when we find one-bits in the low 16 bits.  */\n-    if (value & 0xffff)\n     {\n-      fprintf (stream, \"#%x\", (int) (value & 0xffff));\n-      return;\n-    }\n+      /* We know we're through when we find one-bits in the low 16 bits.  */\n+      if (value & 0xffff)\n+\t{\n+\t  fprintf (stream, \"#%x\", (int) (value & 0xffff));\n+\t  return;\n+\t}\n \n     value >>= 16;\n   }\n@@ -2902,10 +2766,7 @@ mmix_output_shifted_value (stream, value)\n    same as swapping the arguments).  */\n \n static void\n-mmix_output_condition (stream, x, reversed)\n-     FILE *stream;\n-     rtx x;\n-     int reversed;\n+mmix_output_condition (FILE *stream, rtx x, int reversed)\n {\n   struct cc_conv\n   {\n@@ -3010,8 +2871,7 @@ mmix_output_condition (stream, x, reversed)\n /* Return the bit-value for a const_int or const_double.  */\n \n static HOST_WIDEST_INT\n-mmix_intval (x)\n-     rtx x;\n+mmix_intval (rtx x)\n {\n   unsigned HOST_WIDEST_INT retval;\n "}]}