{"sha": "9a6cde3a01859dacb3fc2bf5ba8df1919678a751", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWE2Y2RlM2EwMTg1OWRhY2IzZmMyYmY1YmE4ZGYxOTE5Njc4YTc1MQ==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-05-30T23:41:55Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-05-30T23:41:55Z"}, "message": "(reload): If only non-group need is unfilled, see if\nregs spilled for earlier classes can satisfy it.\n\nFrom-SVN: r4597", "tree": {"sha": "77f239a505dc8b5c21f6eb489f16db7ce58c8071", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/77f239a505dc8b5c21f6eb489f16db7ce58c8071"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9a6cde3a01859dacb3fc2bf5ba8df1919678a751", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a6cde3a01859dacb3fc2bf5ba8df1919678a751", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a6cde3a01859dacb3fc2bf5ba8df1919678a751", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a6cde3a01859dacb3fc2bf5ba8df1919678a751/comments", "author": null, "committer": null, "parents": [{"sha": "5cf460ff62e48be48b6d624ed45446a98dbed7da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5cf460ff62e48be48b6d624ed45446a98dbed7da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5cf460ff62e48be48b6d624ed45446a98dbed7da"}], "stats": {"total": 29, "additions": 29, "deletions": 0}, "files": [{"sha": "08813427e0b243a29047b96623954a4c9279567f", "filename": "gcc/reload1.c", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a6cde3a01859dacb3fc2bf5ba8df1919678a751/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a6cde3a01859dacb3fc2bf5ba8df1919678a751/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=9a6cde3a01859dacb3fc2bf5ba8df1919678a751", "patch": "@@ -1785,6 +1785,35 @@ reload (first, global, dumpfile)\n \n \t  while (max_needs[class] > 0 || max_nongroups[class] > 0)\n \t    {\n+#ifdef SMALL_REGISTER_CLASSES\n+\t      /* This should be right for all machines, but only the 386\n+\t\t is known to need it, so this conditional plays safe.\n+\t\t ??? For 2.5, try making this unconditional.  */\n+\t      /* If we spilled enough regs, but they weren't counted\n+\t\t against the non-group need, see if we can count them now.\n+\t\t If so, we can avoid some actual spilling.  */\n+\t      if (max_needs[class] <= 0 && max_nongroups[class] > 0)\n+\t\tfor (i = 0; i < n_spills; i++)\n+\t\t  if (TEST_HARD_REG_BIT (reg_class_contents[class],\n+\t\t\t\t\t spill_regs[i])\n+\t\t      && !TEST_HARD_REG_BIT (counted_for_groups,\n+\t\t\t\t\t     spill_regs[i])\n+\t\t      && !TEST_HARD_REG_BIT (counted_for_nongroups,\n+\t\t\t\t\t     spill_regs[i])\n+\t\t      && max_nongroups[class] > 0)\n+\t\t    {\n+\t\t      register enum reg_class *p;\n+\n+\t\t      SET_HARD_REG_BIT (counted_for_nongroups, spill_regs[i]);\n+\t\t      max_nongroups[class]--;\n+\t\t      p = reg_class_superclasses[class];\n+\t\t      while (*p != LIM_REG_CLASSES)\n+\t\t\tmax_nongroups[(int) *p++]--;\n+\t\t    }\n+\t      if (max_needs[class] <= 0 && max_nongroups[class] <= 0)\n+\t\tbreak;\n+#endif\n+\n \t      /* Consider the potential reload regs that aren't\n \t\t yet in use as reload regs, in order of preference.\n \t\t Find the most preferred one that's in this class.  */"}]}