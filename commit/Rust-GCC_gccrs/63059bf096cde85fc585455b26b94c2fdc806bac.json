{"sha": "63059bf096cde85fc585455b26b94c2fdc806bac", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjMwNTliZjA5NmNkZTg1ZmM1ODU0NTViMjZiOTRjMmZkYzgwNmJhYw==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2019-07-01T13:35:15Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2019-07-01T13:35:15Z"}, "message": "[Ada] Clean up of GNAT.Graphs\n\n------------\n-- Source --\n------------\n\n--  operations.adb\n\nwith Ada.Text_IO; use Ada.Text_IO;\nwith GNAT;        use GNAT;\nwith GNAT.Graphs; use GNAT.Graphs;\nwith GNAT.Sets;   use GNAT.Sets;\n\nprocedure Operations is\n   type Vertex_Id is\n     (No_V, VA, VB, VC, VD, VE, VF, VG, VH, VX, VY, VZ);\n   No_Vertex_Id : constant Vertex_Id := No_V;\n\n   function Hash_Vertex (V : Vertex_Id) return Bucket_Range_Type;\n\n   type Edge_Id is\n    (No_E, E1, E2, E3, E4, E5, E6, E7, E8, E9, E10, E97, E98, E99);\n   No_Edge_Id : constant Edge_Id := No_E;\n\n   function Hash_Edge (E : Edge_Id) return Bucket_Range_Type;\n\n   package ES is new Membership_Sets\n     (Element_Type => Edge_Id,\n      \"=\"          => \"=\",\n      Hash         => Hash_Edge);\n\n   package DG is new Directed_Graphs\n     (Vertex_Id   => Vertex_Id,\n      No_Vertex   => No_Vertex_Id,\n      Hash_Vertex => Hash_Vertex,\n      Same_Vertex => \"=\",\n      Edge_Id     => Edge_Id,\n      No_Edge     => No_Edge_Id,\n      Hash_Edge   => Hash_Edge,\n      Same_Edge   => \"=\");\n   use DG;\n\n   package VS is new Membership_Sets\n     (Element_Type => Vertex_Id,\n      \"=\"          => \"=\",\n      Hash         => Hash_Vertex);\n\n   -----------------------\n   -- Local subprograms --\n   -----------------------\n\n   procedure Check_Belongs_To_Component\n     (R        : String;\n      G        : Directed_Graph;\n      V        : Vertex_Id;\n      Exp_Comp : Component_Id);\n   --  Verify that vertex V of graph G belongs to component Exp_Comp. R is the\n   --  calling routine.\n\n   procedure Check_Belongs_To_Some_Component\n     (R : String;\n      G : Directed_Graph;\n      V : Vertex_Id);\n   --  Verify that vertex V of graph G belongs to some component. R is the\n   --  calling routine.\n\n   procedure Check_Destination_Vertex\n     (R     : String;\n      G     : Directed_Graph;\n      E     : Edge_Id;\n      Exp_V : Vertex_Id);\n   --  Vertify that the destination vertex of edge E of grah G is Exp_V. R is\n   --  the calling routine.\n\n   procedure Check_Distinct_Components\n     (R      : String;\n      Comp_1 : Component_Id;\n      Comp_2 : Component_Id);\n   --  Verify that components Comp_1 and Comp_2 are distinct (not the same)\n\n   procedure Check_Has_Component\n     (R      : String;\n      G      : Directed_Graph;\n      G_Name : String;\n      Comp   : Component_Id);\n   --  Verify that graph G with name G_Name contains component Comp. R is the\n   --  calling routine.\n\n   procedure Check_Has_Edge\n     (R : String;\n      G : Directed_Graph;\n      E : Edge_Id);\n   --  Verify that graph G contains edge E. R is the calling routine.\n\n   procedure Check_Has_Vertex\n     (R : String;\n      G : Directed_Graph;\n      V : Vertex_Id);\n   --  Verify that graph G contains vertex V. R is the calling routine.\n\n   procedure Check_No_Component\n     (R : String;\n      G : Directed_Graph;\n      V : Vertex_Id);\n   --  Verify that vertex V does not belong to some component. R is the calling\n   --  routine.\n\n   procedure Check_No_Component\n     (R      : String;\n      G      : Directed_Graph;\n      G_Name : String;\n      Comp   : Component_Id);\n   --  Verify that graph G with name G_Name does not contain component Comp. R\n   --  is the calling routine.\n\n   procedure Check_No_Edge\n     (R : String;\n      G : Directed_Graph;\n      E : Edge_Id);\n   --  Verify that graph G does not contain edge E. R is the calling routine.\n\n   procedure Check_No_Vertex\n     (R : String;\n      G : Directed_Graph;\n      V : Vertex_Id);\n   --  Verify that graph G does not contain vertex V. R is the calling routine.\n\n   procedure Check_Number_Of_Components\n     (R       : String;\n      G       : Directed_Graph;\n      Exp_Num : Natural);\n   --  Verify that graph G has exactly Exp_Num components. R is the calling\n   --  routine.\n\n   procedure Check_Number_Of_Edges\n     (R       : String;\n      G       : Directed_Graph;\n      Exp_Num : Natural);\n   --  Verify that graph G has exactly Exp_Num edges. R is the calling routine.\n\n   procedure Check_Number_Of_Vertices\n     (R       : String;\n      G       : Directed_Graph;\n      Exp_Num : Natural);\n   --  Verify that graph G has exactly Exp_Num vertices. R is the calling\n   --  routine.\n\n   procedure Check_Outgoing_Edge_Iterator\n     (R   : String;\n      G   : Directed_Graph;\n      V   : Vertex_Id;\n      Set : ES.Membership_Set);\n   --  Verify that all outgoing edges of vertex V of graph G can be iterated\n   --  and appear in set Set. R is the calling routine.\n\n   procedure Check_Source_Vertex\n     (R     : String;\n      G     : Directed_Graph;\n      E     : Edge_Id;\n      Exp_V : Vertex_Id);\n   --  Vertify that the source vertex of edge E of grah G is Exp_V. R is the\n   --  calling routine.\n\n   procedure Check_Vertex_Iterator\n     (R    : String;\n      G    : Directed_Graph;\n      Comp : Component_Id;\n      Set  : VS.Membership_Set);\n   --  Verify that all vertices of component Comp of graph G can be iterated\n   --  and appear in set Set. R is the calling routine.\n\n   function Create_And_Populate return Directed_Graph;\n   --  Create a brand new graph (see body for the shape of the graph)\n\n   procedure Error (R : String; Msg : String);\n   --  Output an error message with text Msg within the context of routine R\n\n   procedure Test_Add_Edge;\n   --  Verify the semantics of routine Add_Edge\n\n   procedure Test_Add_Vertex;\n   --  Verify the semantics of routine Add_Vertex\n\n   procedure Test_All_Edge_Iterator;\n   --  Verify the semantics of All_Edge_Iterator\n\n   procedure Test_All_Vertex_Iterator;\n   --  Verify the semantics of All_Vertex_Iterator\n\n   procedure Test_Component;\n   --  Verify the semantics of routine Component\n\n   procedure Test_Component_Iterator;\n   --  Verify the semantics of Component_Iterator\n\n   procedure Test_Contains_Component;\n   --  Verify the semantics of routine Contains_Component\n\n   procedure Test_Contains_Edge;\n   --  Verify the semantics of routine Contains_Edge\n\n   procedure Test_Contains_Vertex;\n   --  Verify the semantics of routine Contains_Vertex\n\n   procedure Test_Delete_Edge;\n   --  Verify the semantics of routine Delete_Edge\n\n   procedure Test_Destination_Vertex;\n   --  Verify the semantics of routine Destination_Vertex\n\n   procedure Test_Find_Components;\n   --  Verify the semantics of routine Find_Components\n\n   procedure Test_Is_Empty;\n   --  Verify the semantics of routine Is_Empty\n\n   procedure Test_Number_Of_Components;\n   --  Verify the semantics of routine Number_Of_Components\n\n   procedure Test_Number_Of_Edges;\n   --  Verify the semantics of routine Number_Of_Edges\n\n   procedure Test_Number_Of_Vertices;\n   --  Verify the semantics of routine Number_Of_Vertices\n\n   procedure Test_Outgoing_Edge_Iterator;\n   --  Verify the semantics of Outgoing_Edge_Iterator\n\n   procedure Test_Present;\n   --  Verify the semantics of routine Present\n\n   procedure Test_Source_Vertex;\n   --  Verify the semantics of routine Source_Vertex\n\n   procedure Test_Vertex_Iterator;\n   --  Verify the semantics of Vertex_Iterator;\n\n   procedure Unexpected_Exception (R : String);\n   --  Output an error message concerning an unexpected exception within\n   --  routine R.\n\n   --------------------------------\n   -- Check_Belongs_To_Component --\n   --------------------------------\n\n   procedure Check_Belongs_To_Component\n     (R        : String;\n      G        : Directed_Graph;\n      V        : Vertex_Id;\n      Exp_Comp : Component_Id)\n   is\n      Act_Comp : constant Component_Id := Component (G, V);\n\n   begin\n      if Act_Comp /= Exp_Comp then\n         Error (R, \"inconsistent component for vertex \" & V'Img);\n         Error (R, \"  expected: \" & Exp_Comp'Img);\n         Error (R, \"  got     : \" & Act_Comp'Img);\n      end if;\n   end Check_Belongs_To_Component;\n\n   -------------------------------------\n   -- Check_Belongs_To_Some_Component --\n   -------------------------------------\n\n   procedure Check_Belongs_To_Some_Component\n     (R : String;\n      G : Directed_Graph;\n      V : Vertex_Id)\n   is\n   begin\n      if not Present (Component (G, V)) then\n         Error (R, \"vertex \" & V'Img & \" does not belong to a component\");\n      end if;\n   end Check_Belongs_To_Some_Component;\n\n   ------------------------------\n   -- Check_Destination_Vertex --\n   ------------------------------\n\n   procedure Check_Destination_Vertex\n     (R     : String;\n      G     : Directed_Graph;\n      E     : Edge_Id;\n      Exp_V : Vertex_Id)\n   is\n      Act_V : constant Vertex_Id := Destination_Vertex (G, E);\n\n   begin\n      if Act_V /= Exp_V then\n         Error (R, \"inconsistent destination vertex for edge \" & E'Img);\n         Error (R, \"  expected: \" & Exp_V'Img);\n         Error (R, \"  got     : \" & Act_V'Img);\n      end if;\n   end Check_Destination_Vertex;\n\n   -------------------------------\n   -- Check_Distinct_Components --\n   -------------------------------\n\n   procedure Check_Distinct_Components\n     (R      : String;\n      Comp_1 : Component_Id;\n      Comp_2 : Component_Id)\n   is\n   begin\n      if Comp_1 = Comp_2 then\n         Error (R, \"components are not distinct\");\n      end if;\n   end Check_Distinct_Components;\n\n   -------------------------\n   -- Check_Has_Component --\n   -------------------------\n\n   procedure Check_Has_Component\n     (R      : String;\n      G      : Directed_Graph;\n      G_Name : String;\n      Comp   : Component_Id)\n   is\n   begin\n      if not Contains_Component (G, Comp) then\n         Error (R, \"graph \" & G_Name & \" lacks component\");\n      end if;\n   end Check_Has_Component;\n\n   --------------------\n   -- Check_Has_Edge --\n   --------------------\n\n   procedure Check_Has_Edge\n     (R : String;\n      G : Directed_Graph;\n      E : Edge_Id)\n   is\n   begin\n      if not Contains_Edge (G, E) then\n         Error (R, \"graph lacks edge \" & E'Img);\n      end if;\n   end Check_Has_Edge;\n\n   ----------------------\n   -- Check_Has_Vertex --\n   ----------------------\n\n   procedure Check_Has_Vertex\n     (R : String;\n      G : Directed_Graph;\n      V : Vertex_Id)\n   is\n   begin\n      if not Contains_Vertex (G, V) then\n         Error (R, \"graph lacks vertex \" & V'Img);\n      end if;\n   end Check_Has_Vertex;\n\n   ------------------------\n   -- Check_No_Component --\n   ------------------------\n\n   procedure Check_No_Component\n     (R : String;\n      G : Directed_Graph;\n      V : Vertex_Id)\n   is\n   begin\n      if Present (Component (G, V)) then\n         Error (R, \"vertex \" & V'Img & \" belongs to a component\");\n      end if;\n   end Check_No_Component;\n\n   procedure Check_No_Component\n     (R      : String;\n      G      : Directed_Graph;\n      G_Name : String;\n      Comp   : Component_Id)\n   is\n   begin\n      if Contains_Component (G, Comp) then\n         Error (R, \"graph \" & G_Name & \" contains component\");\n      end if;\n   end Check_No_Component;\n\n   -------------------\n   -- Check_No_Edge --\n   -------------------\n\n   procedure Check_No_Edge\n     (R : String;\n      G : Directed_Graph;\n      E : Edge_Id)\n   is\n   begin\n      if Contains_Edge (G, E) then\n         Error (R, \"graph contains edge \" & E'Img);\n      end if;\n   end Check_No_Edge;\n\n   ---------------------\n   -- Check_No_Vertex --\n   ---------------------\n\n   procedure Check_No_Vertex\n     (R : String;\n      G : Directed_Graph;\n      V : Vertex_Id)\n   is\n   begin\n      if Contains_Vertex (G, V) then\n         Error (R, \"graph contains vertex \" & V'Img);\n      end if;\n   end Check_No_Vertex;\n\n   --------------------------------\n   -- Check_Number_Of_Components --\n   --------------------------------\n\n   procedure Check_Number_Of_Components\n     (R       : String;\n      G       : Directed_Graph;\n      Exp_Num : Natural)\n   is\n      Act_Num : constant Natural := Number_Of_Components (G);\n\n   begin\n      if Act_Num /= Exp_Num then\n         Error (R, \"inconsistent number of components\");\n         Error (R, \"  expected: \" & Exp_Num'Img);\n         Error (R, \"  got     : \" & Act_Num'Img);\n      end if;\n   end Check_Number_Of_Components;\n\n   ---------------------------\n   -- Check_Number_Of_Edges --\n   ---------------------------\n\n   procedure Check_Number_Of_Edges\n     (R       : String;\n      G       : Directed_Graph;\n      Exp_Num : Natural)\n   is\n      Act_Num : constant Natural := Number_Of_Edges (G);\n\n   begin\n      if Act_Num /= Exp_Num then\n         Error (R, \"inconsistent number of edges\");\n         Error (R, \"  expected: \" & Exp_Num'Img);\n         Error (R, \"  got     : \" & Act_Num'Img);\n      end if;\n   end Check_Number_Of_Edges;\n\n   ------------------------------\n   -- Check_Number_Of_Vertices --\n   ------------------------------\n\n   procedure Check_Number_Of_Vertices\n     (R       : String;\n      G       : Directed_Graph;\n      Exp_Num : Natural)\n   is\n      Act_Num : constant Natural := Number_Of_Vertices (G);\n\n   begin\n      if Act_Num /= Exp_Num then\n         Error (R, \"inconsistent number of vertices\");\n         Error (R, \"  expected: \" & Exp_Num'Img);\n         Error (R, \"  got     : \" & Act_Num'Img);\n      end if;\n   end Check_Number_Of_Vertices;\n\n   ----------------------------------\n   -- Check_Outgoing_Edge_Iterator --\n   ----------------------------------\n\n   procedure Check_Outgoing_Edge_Iterator\n     (R   : String;\n      G   : Directed_Graph;\n      V   : Vertex_Id;\n      Set : ES.Membership_Set)\n   is\n      E : Edge_Id;\n\n      Out_E_Iter : Outgoing_Edge_Iterator;\n\n   begin\n      --  Iterate over all outgoing edges of vertex V while removing edges seen\n      --  from the set.\n\n      Out_E_Iter := Iterate_Outgoing_Edges (G, V);\n      while Has_Next (Out_E_Iter) loop\n         Next (Out_E_Iter, E);\n\n         if ES.Contains (Set, E) then\n            ES.Delete (Set, E);\n         else\n            Error (R, \"outgoing edge \" & E'Img & \" is not iterated\");\n         end if;\n      end loop;\n\n      --  At this point the set of edges should be empty\n\n      if not ES.Is_Empty (Set) then\n         Error (R, \"not all outgoing edges were iterated\");\n      end if;\n   end Check_Outgoing_Edge_Iterator;\n\n   -------------------------\n   -- Check_Source_Vertex --\n   -------------------------\n\n   procedure Check_Source_Vertex\n     (R     : String;\n      G     : Directed_Graph;\n      E     : Edge_Id;\n      Exp_V : Vertex_Id)\n   is\n      Act_V : constant Vertex_Id := Source_Vertex (G, E);\n\n   begin\n      if Act_V /= Exp_V then\n         Error (R, \"inconsistent source vertex\");\n         Error (R, \"  expected: \" & Exp_V'Img);\n         Error (R, \"  got     : \" & Act_V'Img);\n      end if;\n   end Check_Source_Vertex;\n\n   ---------------------------\n   -- Check_Vertex_Iterator --\n   ---------------------------\n\n   procedure Check_Vertex_Iterator\n     (R    : String;\n      G    : Directed_Graph;\n      Comp : Component_Id;\n      Set  : VS.Membership_Set)\n   is\n      V : Vertex_Id;\n\n      V_Iter : Vertex_Iterator;\n\n   begin\n      --  Iterate over all vertices of component Comp while removing vertices\n      --  seen from the set.\n\n      V_Iter := Iterate_Vertices (G, Comp);\n      while Has_Next (V_Iter) loop\n         Next (V_Iter, V);\n\n         if VS.Contains (Set, V) then\n            VS.Delete (Set, V);\n         else\n            Error (R, \"vertex \" & V'Img & \" is not iterated\");\n         end if;\n      end loop;\n\n      --  At this point the set of vertices should be empty\n\n      if not VS.Is_Empty (Set) then\n         Error (R, \"not all vertices were iterated\");\n      end if;\n   end Check_Vertex_Iterator;\n\n   -------------------------\n   -- Create_And_Populate --\n   -------------------------\n\n   function Create_And_Populate return Directed_Graph is\n      G : constant Directed_Graph :=\n            Create (Initial_Vertices => Vertex_Id'Size,\n                    Initial_Edges    => Edge_Id'Size);\n\n   begin\n      --       9         8           1        2\n      --  G <------ F <------  A  ------> B -------> C\n      --  |                  ^ | |        ^          ^\n      --  +------------------+ | +-------------------+\n      --       10              |          |   3\n      --                    4  |        5 |\n      --                       v          |\n      --            H          D ---------+\n      --                      | ^\n      --                      | |\n      --                    6 | | 7\n      --                      | |\n      --                      v |\n      --                       E\n      --\n      --  Components:\n      --\n      --    [A, F, G]\n      --    [B]\n      --    [C]\n      --    [D, E]\n      --    [H]\n\n      Add_Vertex (G, VA);\n      Add_Vertex (G, VB);\n      Add_Vertex (G, VC);\n      Add_Vertex (G, VD);\n      Add_Vertex (G, VE);\n      Add_Vertex (G, VF);\n      Add_Vertex (G, VG);\n      Add_Vertex (G, VH);\n\n      Add_Edge (G, E1,  Source => VA, Destination => VB);\n      Add_Edge (G, E2,  Source => VB, Destination => VC);\n      Add_Edge (G, E3,  Source => VA, Destination => VC);\n      Add_Edge (G, E4,  Source => VA, Destination => VD);\n      Add_Edge (G, E5,  Source => VD, Destination => VB);\n      Add_Edge (G, E6,  Source => VD, Destination => VE);\n      Add_Edge (G, E7,  Source => VE, Destination => VD);\n      Add_Edge (G, E8,  Source => VA, Destination => VF);\n      Add_Edge (G, E9,  Source => VF, Destination => VG);\n      Add_Edge (G, E10, Source => VG, Destination => VA);\n\n      return G;\n   end Create_And_Populate;\n\n   -----------\n   -- Error --\n   -----------\n\n   procedure Error (R : String; Msg : String) is\n   begin\n      Put_Line (\"ERROR: \" & R & \": \" & Msg);\n   end Error;\n\n   ---------------\n   -- Hash_Edge --\n   ---------------\n\n   function Hash_Edge (E : Edge_Id) return Bucket_Range_Type is\n   begin\n      return Bucket_Range_Type (Edge_Id'Pos (E));\n   end Hash_Edge;\n\n   -----------------\n   -- Hash_Vertex --\n   -----------------\n\n   function Hash_Vertex (V : Vertex_Id) return Bucket_Range_Type is\n   begin\n      return Bucket_Range_Type (Vertex_Id'Pos (V));\n   end Hash_Vertex;\n\n   -------------------\n   -- Test_Add_Edge --\n   -------------------\n\n   procedure Test_Add_Edge is\n      R : constant String := \"Test_Add_Edge\";\n\n      E : Edge_Id;\n      G : Directed_Graph := Create_And_Populate;\n\n      All_E_Iter : All_Edge_Iterator;\n      Out_E_Iter : Outgoing_Edge_Iterator;\n\n   begin\n      --  Try to add the same edge twice\n\n      begin\n         Add_Edge (G, E1, VB, VH);\n         Error (R, \"duplicate edge not detected\");\n      exception\n         when Duplicate_Edge => null;\n         when others         => Unexpected_Exception (R);\n      end;\n\n      --  Try to add an edge with a bogus source\n\n      begin\n         Add_Edge (G, E97, Source => VX, Destination => VC);\n         Error (R, \"missing vertex not detected\");\n      exception\n         when Missing_Vertex => null;\n         when others         => Unexpected_Exception (R);\n      end;\n\n      --  Try to add an edge with a bogus destination\n\n      begin\n         Add_Edge (G, E97, Source => VF, Destination => VY);\n         Error (R, \"missing vertex not detected\");\n      exception\n         when Missing_Vertex => null;\n         when others         => Unexpected_Exception (R);\n      end;\n\n      --  Delete edge E1 between vertices VA and VB\n\n      begin\n         Delete_Edge (G, E1);\n      exception\n         when others => Unexpected_Exception (R);\n      end;\n\n      --  Try to re-add edge E1\n\n      begin\n         Add_Edge (G, E1, Source => VA, Destination => VB);\n      exception\n         when others => Unexpected_Exception (R);\n      end;\n\n      --  Lock all edges in the graph\n\n      All_E_Iter := Iterate_All_Edges (G);\n\n      --  Try to add an edge given that all edges are locked\n\n      begin\n         Add_Edge (G, E97, Source => VG, Destination => VH);\n         Error (R, \"all edges not locked\");\n      exception\n         when Iterated => null;\n         when others   => Unexpected_Exception (R);\n      end;\n\n      --  Unlock all edges by iterating over them\n\n      while Has_Next (All_E_Iter) loop Next (All_E_Iter, E); end loop;\n\n      --  Lock all outgoing edges of vertex VD\n\n      Out_E_Iter := Iterate_Outgoing_Edges (G, VD);\n\n      --  Try to add an edge with source VD given that all edges of VD are\n      --  locked.\n\n      begin\n         Add_Edge (G, E97, Source => VD, Destination => VG);\n         Error (R, \"outgoing edges of VD not locked\");\n      exception\n         when Iterated => null;\n         when others   => Unexpected_Exception (R);\n      end;\n\n      --  Unlock the edges of vertex VD by iterating over them\n\n      while Has_Next (Out_E_Iter) loop Next (Out_E_Iter, E); end loop;\n\n      Destroy (G);\n   end Test_Add_Edge;\n\n   ---------------------\n   -- Test_Add_Vertex --\n   ---------------------\n\n   procedure Test_Add_Vertex is\n      R : constant String := \"Test_Add_Vertex\";\n\n      G : Directed_Graph := Create_And_Populate;\n      V : Vertex_Id;\n\n      All_V_Iter : All_Vertex_Iterator;\n\n   begin\n      --  Try to add the same vertex twice\n\n      begin\n         Add_Vertex (G, VD);\n         Error (R, \"duplicate vertex not detected\");\n      exception\n         when Duplicate_Vertex => null;\n         when others           => Unexpected_Exception (R);\n      end;\n\n      --  Lock all vertices in the graph\n\n      All_V_Iter := Iterate_All_Vertices (G);\n\n      --  Try to add a vertex given that all vertices are locked\n\n      begin\n         Add_Vertex (G, VZ);\n         Error (R, \"all vertices not locked\");\n      exception\n         when Iterated => null;\n         when others   => Unexpected_Exception (R);\n      end;\n\n      --  Unlock all vertices by iterating over them\n\n      while Has_Next (All_V_Iter) loop Next (All_V_Iter, V); end loop;\n\n      Destroy (G);\n   end Test_Add_Vertex;\n\n   ----------------------------\n   -- Test_All_Edge_Iterator --\n   ----------------------------\n\n   procedure Test_All_Edge_Iterator is\n      R : constant String := \"Test_All_Edge_Iterator\";\n\n      E : Edge_Id;\n      G : Directed_Graph := Create_And_Populate;\n\n      All_E_Iter : All_Edge_Iterator;\n      All_Edges  : ES.Membership_Set;\n\n   begin\n      --  Collect all expected edges in a set\n\n      All_Edges := ES.Create (Number_Of_Edges (G));\n\n      for Curr_E in E1 .. E10 loop\n         ES.Insert (All_Edges, Curr_E);\n      end loop;\n\n      --  Iterate over all edges while removing encountered edges from the set\n\n      All_E_Iter := Iterate_All_Edges (G);\n      while Has_Next (All_E_Iter) loop\n         Next (All_E_Iter, E);\n\n         if ES.Contains (All_Edges, E) then\n            ES.Delete (All_Edges, E);\n         else\n            Error (R, \"edge \" & E'Img & \" is not iterated\");\n         end if;\n      end loop;\n\n      --  At this point the set of edges should be empty\n\n      if not ES.Is_Empty (All_Edges) then\n         Error (R, \"not all edges were iterated\");\n      end if;\n\n      ES.Destroy (All_Edges);\n      Destroy (G);\n   end Test_All_Edge_Iterator;\n\n   ------------------------------\n   -- Test_All_Vertex_Iterator --\n   ------------------------------\n\n   procedure Test_All_Vertex_Iterator is\n      R : constant String := \"Test_All_Vertex_Iterator\";\n\n      G : Directed_Graph := Create_And_Populate;\n      V : Vertex_Id;\n\n      All_V_Iter   : All_Vertex_Iterator;\n      All_Vertices : VS.Membership_Set;\n\n   begin\n      --  Collect all expected vertices in a set\n\n      All_Vertices := VS.Create (Number_Of_Vertices (G));\n\n      for Curr_V in VA .. VH loop\n         VS.Insert (All_Vertices, Curr_V);\n      end loop;\n\n      --  Iterate over all vertices while removing encountered vertices from\n      --  the set.\n\n      All_V_Iter := Iterate_All_Vertices (G);\n      while Has_Next (All_V_Iter) loop\n         Next (All_V_Iter, V);\n\n         if VS.Contains (All_Vertices, V) then\n            VS.Delete (All_Vertices, V);\n         else\n            Error (R, \"vertex \" & V'Img & \" is not iterated\");\n         end if;\n      end loop;\n\n      --  At this point the set of vertices should be empty\n\n      if not VS.Is_Empty (All_Vertices) then\n         Error (R, \"not all vertices were iterated\");\n      end if;\n\n      VS.Destroy (All_Vertices);\n      Destroy (G);\n   end Test_All_Vertex_Iterator;\n\n   --------------------\n   -- Test_Component --\n   --------------------\n\n   procedure Test_Component is\n      R : constant String := \"Test_Component\";\n\n      G : Directed_Graph := Create (Initial_Vertices => 3, Initial_Edges => 2);\n\n   begin\n      --      E1\n      --    ----->\n      --  VA       VB     VC\n      --    <-----\n      --      E2\n      --\n      --  Components:\n      --\n      --    [VA, VB]\n      --    [VC]\n\n      Add_Vertex (G, VA);\n      Add_Vertex (G, VB);\n      Add_Vertex (G, VC);\n\n      Add_Edge (G, E1, Source => VA, Destination => VB);\n      Add_Edge (G, E2, Source => VB, Destination => VA);\n\n      --  None of the vertices should belong to a component\n\n      Check_No_Component (R, G, VA);\n      Check_No_Component (R, G, VB);\n      Check_No_Component (R, G, VC);\n\n      --  Find the strongly connected components in the graph\n\n      Find_Components (G);\n\n      --  Vertices should belong to a component\n\n      Check_Belongs_To_Some_Component (R, G, VA);\n      Check_Belongs_To_Some_Component (R, G, VB);\n      Check_Belongs_To_Some_Component (R, G, VC);\n\n      Destroy (G);\n   end Test_Component;\n\n   -----------------------------\n   -- Test_Component_Iterator --\n   -----------------------------\n\n   procedure Test_Component_Iterator is\n      R : constant String := \"Test_Component_Iterator\";\n\n      G : Directed_Graph := Create_And_Populate;\n\n      Comp       : Component_Id;\n      Comp_Count : Natural;\n      Comp_Iter  : Component_Iterator;\n\n   begin\n      Find_Components (G);\n      Check_Number_Of_Components (R, G, 5);\n\n      Comp_Count := Number_Of_Components (G);\n\n      --  Iterate over all components while decrementing their number\n\n      Comp_Iter := Iterate_Components (G);\n      while Has_Next (Comp_Iter) loop\n         Next (Comp_Iter, Comp);\n\n         Comp_Count := Comp_Count - 1;\n      end loop;\n\n      --  At this point all components should have been accounted for\n\n      if Comp_Count /= 0 then\n         Error (R, \"not all components were iterated\");\n      end if;\n\n      Destroy (G);\n   end Test_Component_Iterator;\n\n   -----------------------------\n   -- Test_Contains_Component --\n   -----------------------------\n\n   procedure Test_Contains_Component is\n      R : constant String := \"Test_Contains_Component\";\n\n      G1 : Directed_Graph :=\n             Create (Initial_Vertices => 2, Initial_Edges => 2);\n      G2 : Directed_Graph :=\n             Create (Initial_Vertices => 2, Initial_Edges => 2);\n\n   begin\n      --      E1\n      --    ----->\n      --  VA       VB\n      --    <-----\n      --      E2\n      --\n      --  Components:\n      --\n      --    [VA, VB]\n\n      Add_Vertex (G1, VA);\n      Add_Vertex (G1, VB);\n\n      Add_Edge (G1, E1, Source => VA, Destination => VB);\n      Add_Edge (G1, E2, Source => VB, Destination => VA);\n\n      --      E97\n      --    ----->\n      --  VX       VY\n      --    <-----\n      --      E98\n      --\n      --  Components:\n      --\n      --    [VX, VY]\n\n      Add_Vertex (G2, VX);\n      Add_Vertex (G2, VY);\n\n      Add_Edge (G2, E97, Source => VX, Destination => VY);\n      Add_Edge (G2, E98, Source => VY, Destination => VX);\n\n      --  Find the strongly connected components in both graphs\n\n      Find_Components (G1);\n      Find_Components (G2);\n\n      --  Vertices should belong to a component\n\n      Check_Belongs_To_Some_Component (R, G1, VA);\n      Check_Belongs_To_Some_Component (R, G1, VB);\n      Check_Belongs_To_Some_Component (R, G2, VX);\n      Check_Belongs_To_Some_Component (R, G2, VY);\n\n      --  Verify that each graph contains the correct component\n\n      Check_Has_Component (R, G1, \"G1\", Component (G1, VA));\n      Check_Has_Component (R, G1, \"G1\", Component (G1, VB));\n      Check_Has_Component (R, G2, \"G2\", Component (G2, VX));\n      Check_Has_Component (R, G2, \"G2\", Component (G2, VY));\n\n      --  Verify that each graph does not contain components from the other\n      --  graph.\n\n      Check_No_Component (R, G1, \"G1\", Component (G2, VX));\n      Check_No_Component (R, G1, \"G1\", Component (G2, VY));\n      Check_No_Component (R, G2, \"G2\", Component (G1, VA));\n      Check_No_Component (R, G2, \"G2\", Component (G1, VB));\n\n      Destroy (G1);\n      Destroy (G2);\n   end Test_Contains_Component;\n\n   ------------------------\n   -- Test_Contains_Edge --\n   ------------------------\n\n   procedure Test_Contains_Edge is\n      R : constant String := \"Test_Contains_Edge\";\n\n      G : Directed_Graph := Create_And_Populate;\n\n   begin\n      --  Verify that all edges in the range E1 .. E10 exist\n\n      for Curr_E in E1 .. E10 loop\n         Check_Has_Edge (R, G, Curr_E);\n      end loop;\n\n      --  Verify that no extra edges are present\n\n      for Curr_E in E97 .. E99 loop\n         Check_No_Edge (R, G, Curr_E);\n      end loop;\n\n      --  Add new edges E97, E98, and E99\n\n      Add_Edge (G, E97, Source => VG, Destination => VF);\n      Add_Edge (G, E98, Source => VH, Destination => VE);\n      Add_Edge (G, E99, Source => VD, Destination => VC);\n\n      --  Verify that all edges in the range E1 .. E99 exist\n\n      for Curr_E in E1 .. E99 loop\n         Check_Has_Edge (R, G, Curr_E);\n      end loop;\n\n      --  Delete each edge that corresponds to an even position in Edge_Id\n\n      for Curr_E in E1 .. E99 loop\n         if Edge_Id'Pos (Curr_E) mod 2 = 0 then\n            Delete_Edge (G, Curr_E);\n         end if;\n      end loop;\n\n      --  Verify that all \"even\" edges are missing, and all \"odd\" edges are\n      --  present.\n\n      for Curr_E in E1 .. E99 loop\n         if Edge_Id'Pos (Curr_E) mod 2 = 0 then\n            Check_No_Edge (R, G, Curr_E);\n         else\n            Check_Has_Edge (R, G, Curr_E);\n         end if;\n      end loop;\n\n      Destroy (G);\n   end Test_Contains_Edge;\n\n   --------------------------\n   -- Test_Contains_Vertex --\n   --------------------------\n\n   procedure Test_Contains_Vertex is\n      R : constant String := \"Test_Contains_Vertex\";\n\n      G : Directed_Graph := Create_And_Populate;\n\n   begin\n      --  Verify that all vertices in the range VA .. VH exist\n\n      for Curr_V in VA .. VH loop\n         Check_Has_Vertex (R, G, Curr_V);\n      end loop;\n\n      --  Verify that no extra vertices are present\n\n      for Curr_V in VX .. VZ loop\n         Check_No_Vertex (R, G, Curr_V);\n      end loop;\n\n      --  Add new vertices VX, VY, and VZ\n\n      Add_Vertex (G, VX);\n      Add_Vertex (G, VY);\n      Add_Vertex (G, VZ);\n\n      --  Verify that all vertices in the range VA .. VZ exist\n\n      for Curr_V in VA .. VZ loop\n         Check_Has_Vertex (R, G, Curr_V);\n      end loop;\n\n      Destroy (G);\n   end Test_Contains_Vertex;\n\n   ----------------------\n   -- Test_Delete_Edge --\n   ----------------------\n\n   procedure Test_Delete_Edge is\n      R : constant String := \"Test_Delete_Edge\";\n\n      E : Edge_Id;\n      G : Directed_Graph := Create_And_Populate;\n      V : Vertex_Id;\n\n      All_E_Iter : All_Edge_Iterator;\n      All_V_Iter : All_Vertex_Iterator;\n      Out_E_Iter : Outgoing_Edge_Iterator;\n\n   begin\n      --  Try to delete a bogus edge\n\n      begin\n         Delete_Edge (G, E97);\n         Error (R, \"missing vertex deleted\");\n      exception\n         when Missing_Edge => null;\n         when others       => Unexpected_Exception (R);\n      end;\n\n      --  Delete edge E1 between vertices VA and VB\n\n      begin\n         Delete_Edge (G, E1);\n      exception\n         when others => Unexpected_Exception (R);\n      end;\n\n      --  Verify that edge E1 is gone from all edges in the graph\n\n      All_E_Iter := Iterate_All_Edges (G);\n      while Has_Next (All_E_Iter) loop\n         Next (All_E_Iter, E);\n\n         if E = E1 then\n            Error (R, \"edge \" & E'Img & \" not removed from all edges\");\n         end if;\n      end loop;\n\n      --  Verify that edge E1 is gone from the outgoing edges of vertex VA\n\n      Out_E_Iter := Iterate_Outgoing_Edges (G, VA);\n      while Has_Next (Out_E_Iter) loop\n         Next (Out_E_Iter, E);\n\n         if E = E1 then\n            Error\n              (R, \"edge \" & E'Img & \"not removed from outgoing edges of VA\");\n         end if;\n      end loop;\n\n      --  Delete all edges in the range E2 .. E10\n\n      for Curr_E in E2 .. E10 loop\n         Delete_Edge (G, Curr_E);\n      end loop;\n\n      --  Verify that all edges are gone from the graph\n\n      All_E_Iter := Iterate_All_Edges (G);\n      while Has_Next (All_E_Iter) loop\n         Next (All_E_Iter, E);\n\n         Error (R, \"edge \" & E'Img & \" not removed from all edges\");\n      end loop;\n\n      --  Verify that all edges are gone from the respective source vertices\n\n      All_V_Iter := Iterate_All_Vertices (G);\n      while Has_Next (All_V_Iter) loop\n         Next (All_V_Iter, V);\n\n         Out_E_Iter := Iterate_Outgoing_Edges (G, V);\n         while Has_Next (Out_E_Iter) loop\n            Next (Out_E_Iter, E);\n\n            Error (R, \"edge \" & E'Img & \" not removed from vertex \" & V'Img);\n         end loop;\n      end loop;\n\n      Destroy (G);\n   end Test_Delete_Edge;\n\n   -----------------------------\n   -- Test_Destination_Vertex --\n   -----------------------------\n\n   procedure Test_Destination_Vertex is\n      R : constant String := \"Test_Destination_Vertex\";\n\n      G : Directed_Graph := Create_And_Populate;\n\n   begin\n      --  Verify the destination vertices of all edges in the graph\n\n      Check_Destination_Vertex (R, G, E1,  VB);\n      Check_Destination_Vertex (R, G, E2,  VC);\n      Check_Destination_Vertex (R, G, E3,  VC);\n      Check_Destination_Vertex (R, G, E4,  VD);\n      Check_Destination_Vertex (R, G, E5,  VB);\n      Check_Destination_Vertex (R, G, E6,  VE);\n      Check_Destination_Vertex (R, G, E7,  VD);\n      Check_Destination_Vertex (R, G, E8,  VF);\n      Check_Destination_Vertex (R, G, E9,  VG);\n      Check_Destination_Vertex (R, G, E10, VA);\n\n      Destroy (G);\n   end Test_Destination_Vertex;\n\n   --------------------------\n   -- Test_Find_Components --\n   --------------------------\n\n   procedure Test_Find_Components is\n      R : constant String := \"Test_Find_Components\";\n\n      G : Directed_Graph := Create_And_Populate;\n\n      Comp_1 : Component_Id;  --  [A, F, G]\n      Comp_2 : Component_Id;  --  [B]\n      Comp_3 : Component_Id;  --  [C]\n      Comp_4 : Component_Id;  --  [D, E]\n      Comp_5 : Component_Id;  --  [H]\n\n   begin\n      Find_Components (G);\n\n      --  Vertices should belong to a component\n\n      Check_Belongs_To_Some_Component (R, G, VA);\n      Check_Belongs_To_Some_Component (R, G, VB);\n      Check_Belongs_To_Some_Component (R, G, VC);\n      Check_Belongs_To_Some_Component (R, G, VD);\n      Check_Belongs_To_Some_Component (R, G, VH);\n\n      --  Extract the ids of the components from the first vertices in each\n      --  component.\n\n      Comp_1 := Component (G, VA);\n      Comp_2 := Component (G, VB);\n      Comp_3 := Component (G, VC);\n      Comp_4 := Component (G, VD);\n      Comp_5 := Component (G, VH);\n\n      --  Verify that the components are distinct\n\n      Check_Distinct_Components (R, Comp_1, Comp_2);\n      Check_Distinct_Components (R, Comp_1, Comp_3);\n      Check_Distinct_Components (R, Comp_1, Comp_4);\n      Check_Distinct_Components (R, Comp_1, Comp_5);\n\n      Check_Distinct_Components (R, Comp_2, Comp_3);\n      Check_Distinct_Components (R, Comp_2, Comp_4);\n      Check_Distinct_Components (R, Comp_2, Comp_5);\n\n      Check_Distinct_Components (R, Comp_3, Comp_4);\n      Check_Distinct_Components (R, Comp_3, Comp_5);\n\n      Check_Distinct_Components (R, Comp_4, Comp_5);\n\n      --  Verify that the remaining nodes belong to the proper component\n\n      Check_Belongs_To_Component (R, G, VF, Comp_1);\n      Check_Belongs_To_Component (R, G, VG, Comp_1);\n      Check_Belongs_To_Component (R, G, VE, Comp_4);\n\n      Destroy (G);\n   end Test_Find_Components;\n\n   -------------------\n   -- Test_Is_Empty --\n   -------------------\n\n   procedure Test_Is_Empty is\n      R : constant String := \"Test_Is_Empty\";\n\n      G : Directed_Graph := Create (Initial_Vertices => 3, Initial_Edges => 2);\n\n   begin\n      --  Verify that a graph without vertices and edges is empty\n\n      if not Is_Empty (G) then\n         Error (R, \"graph is empty\");\n      end if;\n\n      --  Add vertices\n\n      Add_Vertex (G, VA);\n      Add_Vertex (G, VB);\n\n      --  Verify that a graph with vertices and no edges is not empty\n\n      if Is_Empty (G) then\n         Error (R, \"graph is not empty\");\n      end if;\n\n      --  Add edges\n\n      Add_Edge (G, E1, Source => VA, Destination => VB);\n\n      --  Verify that a graph with vertices and edges is not empty\n\n      if Is_Empty (G) then\n         Error (R, \"graph is not empty\");\n      end if;\n\n      Destroy (G);\n   end Test_Is_Empty;\n\n   -------------------------------\n   -- Test_Number_Of_Components --\n   -------------------------------\n\n   procedure Test_Number_Of_Components is\n      R : constant String := \"Test_Number_Of_Components\";\n\n      G : Directed_Graph := Create (Initial_Vertices => 3, Initial_Edges => 2);\n\n   begin\n      --  Verify that an empty graph has exactly 0 components\n\n      Check_Number_Of_Components (R, G, 0);\n\n      --      E1\n      --    ----->\n      --  VA       VB     VC\n      --    <-----\n      --      E2\n      --\n      --  Components:\n      --\n      --    [VA, VB]\n      --    [VC]\n\n      Add_Vertex (G, VA);\n      Add_Vertex (G, VB);\n      Add_Vertex (G, VC);\n\n      Add_Edge (G, E1, Source => VA, Destination => VB);\n      Add_Edge (G, E2, Source => VB, Destination => VA);\n\n      --  Verify that the graph has exact 0 components even though it contains\n      --  vertices and edges.\n\n      Check_Number_Of_Components (R, G, 0);\n\n      Find_Components (G);\n\n      --  Verify that the graph has exactly 2 components\n\n      Check_Number_Of_Components (R, G, 2);\n\n      Destroy (G);\n   end Test_Number_Of_Components;\n\n   --------------------------\n   -- Test_Number_Of_Edges --\n   --------------------------\n\n   procedure Test_Number_Of_Edges is\n      R : constant String := \"Test_Number_Of_Edges\";\n\n      G : Directed_Graph := Create_And_Populate;\n\n   begin\n      --  Verify that the graph has exactly 10 edges\n\n      Check_Number_Of_Edges (R, G, 10);\n\n      --  Delete two edges\n\n      Delete_Edge (G, E1);\n      Delete_Edge (G, E2);\n\n      --  Verify that the graph has exactly 8 edges\n\n      Check_Number_Of_Edges (R, G, 8);\n\n      --  Delete the remaining edge\n\n      for Curr_E in E3 .. E10 loop\n         Delete_Edge (G, Curr_E);\n      end loop;\n\n      --  Verify that the graph has exactly 0 edges\n\n      Check_Number_Of_Edges (R, G, 0);\n\n      --  Add two edges\n\n      Add_Edge (G, E1, Source => VF, Destination => VA);\n      Add_Edge (G, E2, Source => VC, Destination => VH);\n\n      --  Verify that the graph has exactly 2 edges\n\n      Check_Number_Of_Edges (R, G, 2);\n\n      Destroy (G);\n   end Test_Number_Of_Edges;\n\n   -----------------------------\n   -- Test_Number_Of_Vertices --\n   -----------------------------\n\n   procedure Test_Number_Of_Vertices is\n      R : constant String := \"Test_Number_Of_Vertices\";\n\n      G : Directed_Graph :=\n            Create (Initial_Vertices => 4, Initial_Edges => 12);\n\n   begin\n      --  Verify that an empty graph has exactly 0 vertices\n\n      Check_Number_Of_Vertices (R, G, 0);\n\n      --  Add three vertices\n\n      Add_Vertex (G, VC);\n      Add_Vertex (G, VG);\n      Add_Vertex (G, VX);\n\n      --  Verify that the graph has exactly 3 vertices\n\n      Check_Number_Of_Vertices (R, G, 3);\n\n      --  Add one edge\n\n      Add_Edge (G, E8, Source => VX, Destination => VG);\n\n      --  Verify that the graph has exactly 3 vertices\n\n      Check_Number_Of_Vertices (R, G, 3);\n\n      Destroy (G);\n   end Test_Number_Of_Vertices;\n\n   ---------------------------------\n   -- Test_Outgoing_Edge_Iterator --\n   ---------------------------------\n\n   procedure Test_Outgoing_Edge_Iterator is\n      R : constant String := \"Test_Outgoing_Edge_Iterator\";\n\n      G   : Directed_Graph := Create_And_Populate;\n      Set : ES.Membership_Set;\n\n   begin\n      Set := ES.Create (4);\n\n      ES.Insert (Set, E1);\n      ES.Insert (Set, E3);\n      ES.Insert (Set, E4);\n      ES.Insert (Set, E8);\n      Check_Outgoing_Edge_Iterator (R, G, VA, Set);\n\n      ES.Insert (Set, E2);\n      Check_Outgoing_Edge_Iterator (R, G, VB, Set);\n\n      Check_Outgoing_Edge_Iterator (R, G, VC, Set);\n\n      ES.Insert (Set, E5);\n      ES.Insert (Set, E6);\n      Check_Outgoing_Edge_Iterator (R, G, VD, Set);\n\n      ES.Insert (Set, E7);\n      Check_Outgoing_Edge_Iterator (R, G, VE, Set);\n\n      ES.Insert (Set, E9);\n      Check_Outgoing_Edge_Iterator (R, G, VF, Set);\n\n      ES.Insert (Set, E10);\n      Check_Outgoing_Edge_Iterator (R, G, VG, Set);\n\n      Check_Outgoing_Edge_Iterator (R, G, VH, Set);\n\n      ES.Destroy (Set);\n      Destroy (G);\n   end Test_Outgoing_Edge_Iterator;\n\n   ------------------\n   -- Test_Present --\n   ------------------\n\n   procedure Test_Present is\n      R : constant String := \"Test_Present\";\n\n      G : Directed_Graph := Nil;\n\n   begin\n      --  Verify that a non-existent graph is not present\n\n      if Present (G) then\n         Error (R, \"graph is not present\");\n      end if;\n\n      G := Create_And_Populate;\n\n      --  Verify that an existing graph is present\n\n      if not Present (G) then\n         Error (R, \"graph is present\");\n      end if;\n\n      Destroy (G);\n\n      --  Verify that a destroyed graph is not present\n\n      if Present (G) then\n         Error (R, \"graph is not present\");\n      end if;\n   end Test_Present;\n\n   ------------------------\n   -- Test_Source_Vertex --\n   ------------------------\n\n   procedure Test_Source_Vertex is\n      R : constant String := \"Test_Source_Vertex\";\n\n      G : Directed_Graph := Create_And_Populate;\n\n   begin\n      --  Verify the source vertices of all edges in the graph\n\n      Check_Source_Vertex (R, G, E1,  VA);\n      Check_Source_Vertex (R, G, E2,  VB);\n      Check_Source_Vertex (R, G, E3,  VA);\n      Check_Source_Vertex (R, G, E4,  VA);\n      Check_Source_Vertex (R, G, E5,  VD);\n      Check_Source_Vertex (R, G, E6,  VD);\n      Check_Source_Vertex (R, G, E7,  VE);\n      Check_Source_Vertex (R, G, E8,  VA);\n      Check_Source_Vertex (R, G, E9,  VF);\n      Check_Source_Vertex (R, G, E10, VG);\n\n      Destroy (G);\n   end Test_Source_Vertex;\n\n   --------------------------\n   -- Test_Vertex_Iterator --\n   --------------------------\n\n   procedure Test_Vertex_Iterator is\n      R : constant String := \"Test_Vertex_Iterator\";\n\n      G   : Directed_Graph := Create_And_Populate;\n      Set : VS.Membership_Set;\n\n   begin\n      Find_Components (G);\n\n      Set := VS.Create (3);\n\n      VS.Insert (Set, VA);\n      VS.Insert (Set, VF);\n      VS.Insert (Set, VG);\n      Check_Vertex_Iterator (R, G, Component (G, VA), Set);\n\n      VS.Insert (Set, VB);\n      Check_Vertex_Iterator (R, G, Component (G, VB), Set);\n\n      VS.Insert (Set, VC);\n      Check_Vertex_Iterator (R, G, Component (G, VC), Set);\n\n      VS.Insert (Set, VD);\n      VS.Insert (Set, VE);\n      Check_Vertex_Iterator (R, G, Component (G, VD), Set);\n\n      VS.Insert (Set, VH);\n      Check_Vertex_Iterator (R, G, Component (G, VH), Set);\n\n      VS.Destroy (Set);\n      Destroy (G);\n   end Test_Vertex_Iterator;\n\n   --------------------------\n   -- Unexpected_Exception --\n   --------------------------\n\n   procedure Unexpected_Exception (R : String) is\n   begin\n      Error (R, \"unexpected exception\");\n   end Unexpected_Exception;\n\n--  Start of processing for Operations\n\nbegin\n   Test_Add_Edge;\n   Test_Add_Vertex;\n   Test_All_Edge_Iterator;\n   Test_All_Vertex_Iterator;\n   Test_Component;\n   Test_Component_Iterator;\n   Test_Contains_Component;\n   Test_Contains_Edge;\n   Test_Contains_Vertex;\n   Test_Delete_Edge;\n   Test_Destination_Vertex;\n   Test_Find_Components;\n   Test_Is_Empty;\n   Test_Number_Of_Components;\n   Test_Number_Of_Edges;\n   Test_Number_Of_Vertices;\n   Test_Outgoing_Edge_Iterator;\n   Test_Present;\n   Test_Source_Vertex;\n   Test_Vertex_Iterator;\n\nend Operations;\n\n----------------------------\n-- Compilation and output --\n----------------------------\n\n$ gnatmake -q operations.adb -largs -lgmem\n$ ./operations\n$ gnatmem operations > leaks.txt\n$ grep -c \"non freed allocations\" leaks.txt\n0\n\n2019-07-01  Hristian Kirtchev  <kirtchev@adacore.com>\n\ngcc/ada/\n\n\t* libgnat/g-graphs.adb: Use type Directed_Graph rather than\n\tInstance in various routines.\n\t* libgnat/g-graphs.ads: Change type Instance to Directed_Graph.\n\tUpdate various routines that mention the type.\n\nFrom-SVN: r272863", "tree": {"sha": "56b50b0929eab6927d68b117c1a1357720849bef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/56b50b0929eab6927d68b117c1a1357720849bef"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/63059bf096cde85fc585455b26b94c2fdc806bac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63059bf096cde85fc585455b26b94c2fdc806bac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63059bf096cde85fc585455b26b94c2fdc806bac", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63059bf096cde85fc585455b26b94c2fdc806bac/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1d88851ce9576ee755b9a47f076d434e8e1057cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d88851ce9576ee755b9a47f076d434e8e1057cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d88851ce9576ee755b9a47f076d434e8e1057cf"}], "stats": {"total": 243, "additions": 127, "deletions": 116}, "files": [{"sha": "f11697b282224b7b9a4518ca9c9957576165d9e0", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63059bf096cde85fc585455b26b94c2fdc806bac/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63059bf096cde85fc585455b26b94c2fdc806bac/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=63059bf096cde85fc585455b26b94c2fdc806bac", "patch": "@@ -1,3 +1,10 @@\n+2019-07-01  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* libgnat/g-graphs.adb: Use type Directed_Graph rather than\n+\tInstance in various routines.\n+\t* libgnat/g-graphs.ads: Change type Instance to Directed_Graph.\n+\tUpdate various routines that mention the type.\n+\n 2019-07-01  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* libgnat/g-sets.adb: Use type Membership_Set rathern than"}, {"sha": "210e08363cb64abb08a6600948818629f2720b07", "filename": "gcc/ada/libgnat/g-graphs.adb", "status": "modified", "additions": 75, "deletions": 69, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63059bf096cde85fc585455b26b94c2fdc806bac/gcc%2Fada%2Flibgnat%2Fg-graphs.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63059bf096cde85fc585455b26b94c2fdc806bac/gcc%2Fada%2Flibgnat%2Fg-graphs.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fg-graphs.adb?ref=63059bf096cde85fc585455b26b94c2fdc806bac", "patch": "@@ -45,107 +45,109 @@ package body GNAT.Graphs is\n    -- Directed_Graph --\n    --------------------\n \n-   package body Directed_Graph is\n+   package body Directed_Graphs is\n \n       -----------------------\n       -- Local subprograms --\n       -----------------------\n \n       procedure Add_Component\n-        (G        : Instance;\n+        (G        : Directed_Graph;\n          Comp     : Component_Id;\n-         Vertices : Vertex_List.Instance);\n+         Vertices : Vertex_List.Doubly_Linked_List);\n       pragma Inline (Add_Component);\n       --  Add component Comp which houses vertices Vertices to graph G\n \n-      procedure Ensure_Created (G : Instance);\n+      procedure Ensure_Created (G : Directed_Graph);\n       pragma Inline (Ensure_Created);\n       --  Verify that graph G is created. Raise Not_Created if this is not the\n       --  case.\n \n       procedure Ensure_Not_Present\n-        (G : Instance;\n+        (G : Directed_Graph;\n          E : Edge_Id);\n       pragma Inline (Ensure_Not_Present);\n       --  Verify that graph G lacks edge E. Raise Duplicate_Edge if this is not\n       --  the case.\n \n       procedure Ensure_Not_Present\n-        (G : Instance;\n+        (G : Directed_Graph;\n          V : Vertex_Id);\n       pragma Inline (Ensure_Not_Present);\n       --  Verify that graph G lacks vertex V. Raise Duplicate_Vertex if this is\n       --  not the case.\n \n       procedure Ensure_Present\n-        (G    : Instance;\n+        (G    : Directed_Graph;\n          Comp : Component_Id);\n       pragma Inline (Ensure_Present);\n       --  Verify that component Comp exists in graph G. Raise Missing_Component\n       --  if this is not the case.\n \n       procedure Ensure_Present\n-        (G : Instance;\n+        (G : Directed_Graph;\n          E : Edge_Id);\n       pragma Inline (Ensure_Present);\n       --  Verify that edge E is present in graph G. Raise Missing_Edge if this\n       --  is not the case.\n \n       procedure Ensure_Present\n-        (G : Instance;\n+        (G : Directed_Graph;\n          V : Vertex_Id);\n       pragma Inline (Ensure_Present);\n       --  Verify that vertex V is present in graph G. Raise Missing_Vertex if\n       --  this is not the case.\n \n-      procedure Free is new Ada.Unchecked_Deallocation (Graph, Instance);\n+      procedure Free is\n+        new Ada.Unchecked_Deallocation\n+              (Directed_Graph_Attributes, Directed_Graph);\n \n       function Get_Component_Attributes\n-        (G    : Instance;\n+        (G    : Directed_Graph;\n          Comp : Component_Id) return Component_Attributes;\n       pragma Inline (Get_Component_Attributes);\n       --  Obtain the attributes of component Comp of graph G\n \n       function Get_Edge_Attributes\n-        (G : Instance;\n+        (G : Directed_Graph;\n          E : Edge_Id) return Edge_Attributes;\n       pragma Inline (Get_Edge_Attributes);\n       --  Obtain the attributes of edge E of graph G\n \n       function Get_Vertex_Attributes\n-        (G : Instance;\n+        (G : Directed_Graph;\n          V : Vertex_Id) return Vertex_Attributes;\n       pragma Inline (Get_Vertex_Attributes);\n       --  Obtain the attributes of vertex V of graph G\n \n       function Get_Outgoing_Edges\n-        (G : Instance;\n-         V : Vertex_Id) return Edge_Set.Instance;\n+        (G : Directed_Graph;\n+         V : Vertex_Id) return Edge_Set.Membership_Set;\n       pragma Inline (Get_Outgoing_Edges);\n       --  Obtain the Outgoing_Edges attribute of vertex V of graph G\n \n       function Get_Vertices\n-        (G    : Instance;\n-         Comp : Component_Id) return Vertex_List.Instance;\n+        (G    : Directed_Graph;\n+         Comp : Component_Id) return Vertex_List.Doubly_Linked_List;\n       pragma Inline (Get_Vertices);\n       --  Obtain the Vertices attribute of component Comp of graph G\n \n       procedure Set_Component\n-        (G   : Instance;\n+        (G   : Directed_Graph;\n          V   : Vertex_Id;\n          Val : Component_Id);\n       pragma Inline (Set_Component);\n       --  Set attribute Component of vertex V of graph G to value Val\n \n       procedure Set_Outgoing_Edges\n-        (G   : Instance;\n+        (G   : Directed_Graph;\n          V   : Vertex_Id;\n-         Val : Edge_Set.Instance);\n+         Val : Edge_Set.Membership_Set);\n       pragma Inline (Set_Outgoing_Edges);\n       --  Set attribute Outgoing_Edges of vertex V of graph G to value Val\n \n       procedure Set_Vertex_Attributes\n-        (G   : Instance;\n+        (G   : Directed_Graph;\n          V   : Vertex_Id;\n          Val : Vertex_Attributes);\n       pragma Inline (Set_Vertex_Attributes);\n@@ -156,9 +158,9 @@ package body GNAT.Graphs is\n       -------------------\n \n       procedure Add_Component\n-        (G        : Instance;\n+        (G        : Directed_Graph;\n          Comp     : Component_Id;\n-         Vertices : Vertex_List.Instance)\n+         Vertices : Vertex_List.Doubly_Linked_List)\n       is\n       begin\n          pragma Assert (Present (G));\n@@ -176,7 +178,7 @@ package body GNAT.Graphs is\n       --------------\n \n       procedure Add_Edge\n-        (G           : Instance;\n+        (G           : Directed_Graph;\n          E           : Edge_Id;\n          Source      : Vertex_Id;\n          Destination : Vertex_Id)\n@@ -209,7 +211,7 @@ package body GNAT.Graphs is\n       ----------------\n \n       procedure Add_Vertex\n-        (G : Instance;\n+        (G : Directed_Graph;\n          V : Vertex_Id)\n       is\n       begin\n@@ -239,7 +241,7 @@ package body GNAT.Graphs is\n       ---------------\n \n       function Component\n-        (G : Instance;\n+        (G : Directed_Graph;\n          V : Vertex_Id) return Component_Id\n       is\n       begin\n@@ -254,7 +256,7 @@ package body GNAT.Graphs is\n       ------------------------\n \n       function Contains_Component\n-        (G    : Instance;\n+        (G    : Directed_Graph;\n          Comp : Component_Id) return Boolean\n       is\n       begin\n@@ -268,7 +270,7 @@ package body GNAT.Graphs is\n       -------------------\n \n       function Contains_Edge\n-        (G : Instance;\n+        (G : Directed_Graph;\n          E : Edge_Id) return Boolean\n       is\n       begin\n@@ -282,7 +284,7 @@ package body GNAT.Graphs is\n       ---------------------\n \n       function Contains_Vertex\n-        (G : Instance;\n+        (G : Directed_Graph;\n          V : Vertex_Id) return Boolean\n       is\n       begin\n@@ -297,9 +299,9 @@ package body GNAT.Graphs is\n \n       function Create\n         (Initial_Vertices : Positive;\n-         Initial_Edges    : Positive) return Instance\n+         Initial_Edges    : Positive) return Directed_Graph\n       is\n-         G : constant Instance := new Graph;\n+         G : constant Directed_Graph := new Directed_Graph_Attributes;\n \n       begin\n          G.All_Edges    := Edge_Map.Create      (Initial_Edges);\n@@ -314,7 +316,7 @@ package body GNAT.Graphs is\n       -----------------\n \n       procedure Delete_Edge\n-        (G : Instance;\n+        (G : Directed_Graph;\n          E : Edge_Id)\n       is\n          Source : Vertex_Id;\n@@ -341,7 +343,7 @@ package body GNAT.Graphs is\n       ------------------------\n \n       function Destination_Vertex\n-        (G : Instance;\n+        (G : Directed_Graph;\n          E : Edge_Id) return Vertex_Id\n       is\n       begin\n@@ -355,7 +357,7 @@ package body GNAT.Graphs is\n       -- Destroy --\n       -------------\n \n-      procedure Destroy (G : in out Instance) is\n+      procedure Destroy (G : in out Directed_Graph) is\n       begin\n          Ensure_Created (G);\n \n@@ -410,7 +412,7 @@ package body GNAT.Graphs is\n       -- Ensure_Created --\n       --------------------\n \n-      procedure Ensure_Created (G : Instance) is\n+      procedure Ensure_Created (G : Directed_Graph) is\n       begin\n          if not Present (G) then\n             raise Not_Created;\n@@ -422,7 +424,7 @@ package body GNAT.Graphs is\n       ------------------------\n \n       procedure Ensure_Not_Present\n-        (G : Instance;\n+        (G : Directed_Graph;\n          E : Edge_Id)\n       is\n       begin\n@@ -436,7 +438,7 @@ package body GNAT.Graphs is\n       ------------------------\n \n       procedure Ensure_Not_Present\n-        (G : Instance;\n+        (G : Directed_Graph;\n          V : Vertex_Id)\n       is\n       begin\n@@ -450,7 +452,7 @@ package body GNAT.Graphs is\n       --------------------\n \n       procedure Ensure_Present\n-        (G    : Instance;\n+        (G    : Directed_Graph;\n          Comp : Component_Id)\n       is\n       begin\n@@ -464,7 +466,7 @@ package body GNAT.Graphs is\n       --------------------\n \n       procedure Ensure_Present\n-        (G : Instance;\n+        (G : Directed_Graph;\n          E : Edge_Id)\n       is\n       begin\n@@ -478,7 +480,7 @@ package body GNAT.Graphs is\n       --------------------\n \n       procedure Ensure_Present\n-        (G : Instance;\n+        (G : Directed_Graph;\n          V : Vertex_Id)\n       is\n       begin\n@@ -491,7 +493,7 @@ package body GNAT.Graphs is\n       -- Find_Components --\n       ---------------------\n \n-      procedure Find_Components (G : Instance) is\n+      procedure Find_Components (G : Directed_Graph) is\n \n          --  The components of graph G are discovered using Tarjan's strongly\n          --  connected component algorithm. Do not modify this code unless you\n@@ -527,7 +529,7 @@ package body GNAT.Graphs is\n            (Attrs : in out Tarjan_Attributes);\n          --  Destroy the contents of attributes Attrs\n \n-         package Tarjan_Map is new Dynamic_HTable\n+         package Tarjan_Map is new Dynamic_Hash_Tables\n            (Key_Type              => Vertex_Id,\n             Value_Type            => Tarjan_Attributes,\n             No_Value              => No_Tarjan_Attributes,\n@@ -543,7 +545,7 @@ package body GNAT.Graphs is\n          -- Tarjan_Stack --\n          ------------------\n \n-         package Tarjan_Stack is new Doubly_Linked_List\n+         package Tarjan_Stack is new Doubly_Linked_Lists\n            (Element_Type    => Vertex_Id,\n             \"=\"             => Same_Vertex,\n             Destroy_Element => Destroy_Vertex);\n@@ -552,8 +554,8 @@ package body GNAT.Graphs is\n          -- Global data --\n          -----------------\n \n-         Attrs : Tarjan_Map.Instance   := Tarjan_Map.Nil;\n-         Stack : Tarjan_Stack.Instance := Tarjan_Stack.Nil;\n+         Attrs : Tarjan_Map.Dynamic_Hash_Table   := Tarjan_Map.Nil;\n+         Stack : Tarjan_Stack.Doubly_Linked_List := Tarjan_Stack.Nil;\n \n          -----------------------\n          -- Local subprograms --\n@@ -689,7 +691,7 @@ package body GNAT.Graphs is\n \n          procedure Create_Component (V : Vertex_Id) is\n             Curr_V   : Vertex_Id;\n-            Vertices : Vertex_List.Instance;\n+            Vertices : Vertex_List.Doubly_Linked_List;\n \n          begin\n             Vertices := Vertex_List.Create;\n@@ -1047,7 +1049,7 @@ package body GNAT.Graphs is\n       ------------------------------\n \n       function Get_Component_Attributes\n-        (G    : Instance;\n+        (G    : Directed_Graph;\n          Comp : Component_Id) return Component_Attributes\n       is\n       begin\n@@ -1062,7 +1064,7 @@ package body GNAT.Graphs is\n       -------------------------\n \n       function Get_Edge_Attributes\n-        (G : Instance;\n+        (G : Directed_Graph;\n          E : Edge_Id) return Edge_Attributes\n       is\n       begin\n@@ -1077,7 +1079,7 @@ package body GNAT.Graphs is\n       ---------------------------\n \n       function Get_Vertex_Attributes\n-        (G : Instance;\n+        (G : Directed_Graph;\n          V : Vertex_Id) return Vertex_Attributes\n       is\n       begin\n@@ -1092,8 +1094,8 @@ package body GNAT.Graphs is\n       ------------------------\n \n       function Get_Outgoing_Edges\n-        (G : Instance;\n-         V : Vertex_Id) return Edge_Set.Instance\n+        (G : Directed_Graph;\n+         V : Vertex_Id) return Edge_Set.Membership_Set\n       is\n       begin\n          pragma Assert (Present (G));\n@@ -1107,8 +1109,8 @@ package body GNAT.Graphs is\n       ------------------\n \n       function Get_Vertices\n-        (G    : Instance;\n-         Comp : Component_Id) return Vertex_List.Instance\n+        (G    : Directed_Graph;\n+         Comp : Component_Id) return Vertex_List.Doubly_Linked_List\n       is\n       begin\n          pragma Assert (Present (G));\n@@ -1166,7 +1168,7 @@ package body GNAT.Graphs is\n       -- Is_Empty --\n       --------------\n \n-      function Is_Empty (G : Instance) return Boolean is\n+      function Is_Empty (G : Directed_Graph) return Boolean is\n       begin\n          Ensure_Created (G);\n \n@@ -1179,7 +1181,9 @@ package body GNAT.Graphs is\n       -- Iterate_All_Edges --\n       -----------------------\n \n-      function Iterate_All_Edges (G : Instance) return All_Edge_Iterator is\n+      function Iterate_All_Edges\n+        (G : Directed_Graph) return All_Edge_Iterator\n+      is\n       begin\n          Ensure_Created (G);\n \n@@ -1191,7 +1195,7 @@ package body GNAT.Graphs is\n       --------------------------\n \n       function Iterate_All_Vertices\n-        (G : Instance) return All_Vertex_Iterator\n+        (G : Directed_Graph) return All_Vertex_Iterator\n       is\n       begin\n          Ensure_Created (G);\n@@ -1203,7 +1207,9 @@ package body GNAT.Graphs is\n       -- Iterate_Components --\n       ------------------------\n \n-      function Iterate_Components (G : Instance) return Component_Iterator is\n+      function Iterate_Components\n+        (G : Directed_Graph) return Component_Iterator\n+      is\n       begin\n          Ensure_Created (G);\n \n@@ -1215,7 +1221,7 @@ package body GNAT.Graphs is\n       ----------------------------\n \n       function Iterate_Outgoing_Edges\n-        (G : Instance;\n+        (G : Directed_Graph;\n          V : Vertex_Id) return Outgoing_Edge_Iterator\n       is\n       begin\n@@ -1232,7 +1238,7 @@ package body GNAT.Graphs is\n       ----------------------\n \n       function Iterate_Vertices\n-        (G    : Instance;\n+        (G    : Directed_Graph;\n          Comp : Component_Id) return Vertex_Iterator\n       is\n       begin\n@@ -1306,7 +1312,7 @@ package body GNAT.Graphs is\n       -- Number_Of_Components --\n       --------------------------\n \n-      function Number_Of_Components (G : Instance) return Natural is\n+      function Number_Of_Components (G : Directed_Graph) return Natural is\n       begin\n          Ensure_Created (G);\n \n@@ -1317,7 +1323,7 @@ package body GNAT.Graphs is\n       -- Number_Of_Edges --\n       ---------------------\n \n-      function Number_Of_Edges (G : Instance) return Natural is\n+      function Number_Of_Edges (G : Directed_Graph) return Natural is\n       begin\n          Ensure_Created (G);\n \n@@ -1328,7 +1334,7 @@ package body GNAT.Graphs is\n       -- Number_Of_Vertices --\n       ------------------------\n \n-      function Number_Of_Vertices (G : Instance) return Natural is\n+      function Number_Of_Vertices (G : Directed_Graph) return Natural is\n       begin\n          Ensure_Created (G);\n \n@@ -1339,7 +1345,7 @@ package body GNAT.Graphs is\n       -- Present --\n       -------------\n \n-      function Present (G : Instance) return Boolean is\n+      function Present (G : Directed_Graph) return Boolean is\n       begin\n          return G /= Nil;\n       end Present;\n@@ -1349,7 +1355,7 @@ package body GNAT.Graphs is\n       -------------------\n \n       procedure Set_Component\n-        (G   : Instance;\n+        (G   : Directed_Graph;\n          V   : Vertex_Id;\n          Val : Component_Id)\n       is\n@@ -1369,9 +1375,9 @@ package body GNAT.Graphs is\n       ------------------------\n \n       procedure Set_Outgoing_Edges\n-        (G   : Instance;\n+        (G   : Directed_Graph;\n          V   : Vertex_Id;\n-         Val : Edge_Set.Instance)\n+         Val : Edge_Set.Membership_Set)\n       is\n          VA : Vertex_Attributes;\n \n@@ -1389,7 +1395,7 @@ package body GNAT.Graphs is\n       ---------------------------\n \n       procedure Set_Vertex_Attributes\n-        (G   : Instance;\n+        (G   : Directed_Graph;\n          V   : Vertex_Id;\n          Val : Vertex_Attributes)\n       is\n@@ -1405,7 +1411,7 @@ package body GNAT.Graphs is\n       -------------------\n \n       function Source_Vertex\n-        (G : Instance;\n+        (G : Directed_Graph;\n          E : Edge_Id) return Vertex_Id\n       is\n       begin\n@@ -1414,7 +1420,7 @@ package body GNAT.Graphs is\n \n          return Get_Edge_Attributes (G, E).Source;\n       end Source_Vertex;\n-   end Directed_Graph;\n+   end Directed_Graphs;\n \n    --------------------\n    -- Hash_Component --"}, {"sha": "c4bf17dffcedb19afd91d74533b4770221d2947a", "filename": "gcc/ada/libgnat/g-graphs.ads", "status": "modified", "additions": 45, "deletions": 47, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/63059bf096cde85fc585455b26b94c2fdc806bac/gcc%2Fada%2Flibgnat%2Fg-graphs.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/63059bf096cde85fc585455b26b94c2fdc806bac/gcc%2Fada%2Flibgnat%2Fg-graphs.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fg-graphs.ads?ref=63059bf096cde85fc585455b26b94c2fdc806bac", "patch": "@@ -53,9 +53,9 @@ package GNAT.Graphs is\n    function Present (Comp : Component_Id) return Boolean;\n    --  Determine whether component Comp exists\n \n-   --------------------\n-   -- Directed_Graph --\n-   --------------------\n+   ---------------------\n+   -- Directed_Graphs --\n+   ---------------------\n \n    --  The following package offers a directed graph abstraction with the\n    --  following characteristics:\n@@ -67,7 +67,7 @@ package GNAT.Graphs is\n    --\n    --  The following use pattern must be employed when operating this graph:\n    --\n-   --    Graph : Instance := Create (<some size>, <some size>);\n+   --    Graph : Directed_Graph := Create (<some size>, <some size>);\n    --\n    --    <various operations>\n    --\n@@ -113,7 +113,7 @@ package GNAT.Graphs is\n               Right : Edge_Id) return Boolean;\n       --  Compare edge Left to edge Right for identity\n \n-   package Directed_Graph is\n+   package Directed_Graphs is\n \n       --  The following exceptions are raised when an attempt is made to add\n       --  the same edge or vertex in a graph.\n@@ -135,11 +135,11 @@ package GNAT.Graphs is\n       --  The following type denotes a graph handle. Each instance must be\n       --  created using routine Create.\n \n-      type Instance is private;\n-      Nil : constant Instance;\n+      type Directed_Graph is private;\n+      Nil : constant Directed_Graph;\n \n       procedure Add_Edge\n-        (G           : Instance;\n+        (G           : Directed_Graph;\n          E           : Edge_Id;\n          Source      : Vertex_Id;\n          Destination : Vertex_Id);\n@@ -155,7 +155,7 @@ package GNAT.Graphs is\n       --      present in the graph.\n \n       procedure Add_Vertex\n-        (G : Instance;\n+        (G : Directed_Graph;\n          V : Vertex_Id);\n       --  Add vertex V to graph G. This action raises the following exceptions:\n       --\n@@ -164,37 +164,37 @@ package GNAT.Graphs is\n       --    * Iterated, when the graph has an outstanding vertex iterator\n \n       function Component\n-        (G : Instance;\n+        (G : Directed_Graph;\n          V : Vertex_Id) return Component_Id;\n       --  Obtain the component where vertex V of graph G resides. This action\n       --  raises the following exceptions:\n       --\n       --    * Missing_Vertex, when the vertex is not present in the graph\n \n       function Contains_Component\n-        (G    : Instance;\n+        (G    : Directed_Graph;\n          Comp : Component_Id) return Boolean;\n       --  Determine whether graph G contains component Comp\n \n       function Contains_Edge\n-        (G : Instance;\n+        (G : Directed_Graph;\n          E : Edge_Id) return Boolean;\n       --  Determine whether graph G contains edge E\n \n       function Contains_Vertex\n-        (G : Instance;\n+        (G : Directed_Graph;\n          V : Vertex_Id) return Boolean;\n       --  Determine whether graph G contains vertex V\n \n       function Create\n         (Initial_Vertices : Positive;\n-         Initial_Edges    : Positive) return Instance;\n+         Initial_Edges    : Positive) return Directed_Graph;\n       --  Create a new graph with vertex capacity Initial_Vertices and edge\n       --  capacity Initial_Edges. This routine must be called at the start of\n       --  a graph's lifetime.\n \n       procedure Delete_Edge\n-        (G : Instance;\n+        (G : Directed_Graph;\n          E : Edge_Id);\n       --  Delete edge E from graph G. This action raises these exceptions:\n       --\n@@ -206,44 +206,44 @@ package GNAT.Graphs is\n       --      not present in the graph.\n \n       function Destination_Vertex\n-        (G : Instance;\n+        (G : Directed_Graph;\n          E : Edge_Id) return Vertex_Id;\n       --  Obtain the destination vertex of edge E of graph G. This action\n       --  raises the following exceptions:\n       --\n       --    * Missing_Edge, when the edge is not present in the graph\n \n-      procedure Destroy (G : in out Instance);\n+      procedure Destroy (G : in out Directed_Graph);\n       --  Destroy the contents of graph G, rendering it unusable. This routine\n       --  must be called at the end of a graph's lifetime. This action raises\n       --  the following exceptions:\n       --\n       --    * Iterated, if the graph has any outstanding iterator\n \n-      procedure Find_Components (G : Instance);\n+      procedure Find_Components (G : Directed_Graph);\n       --  Find all components of graph G. This action raises the following\n       --  exceptions:\n       --\n       --    * Iterated, when the components or vertices of the graph have an\n       --      outstanding iterator.\n \n-      function Is_Empty (G : Instance) return Boolean;\n+      function Is_Empty (G : Directed_Graph) return Boolean;\n       --  Determine whether graph G is empty\n \n-      function Number_Of_Components (G : Instance) return Natural;\n+      function Number_Of_Components (G : Directed_Graph) return Natural;\n       --  Obtain the total number of components of graph G\n \n-      function Number_Of_Edges (G : Instance) return Natural;\n+      function Number_Of_Edges (G : Directed_Graph) return Natural;\n       --  Obtain the total number of edges of graph G\n \n-      function Number_Of_Vertices (G : Instance) return Natural;\n+      function Number_Of_Vertices (G : Directed_Graph) return Natural;\n       --  Obtain the total number of vertices of graph G\n \n-      function Present (G : Instance) return Boolean;\n+      function Present (G : Directed_Graph) return Boolean;\n       --  Determine whether graph G exists\n \n       function Source_Vertex\n-        (G : Instance;\n+        (G : Directed_Graph;\n          E : Edge_Id) return Vertex_Id;\n       --  Obtain the source vertex that \"owns\" edge E of graph G. This action\n       --  raises the following exceptions:\n@@ -274,7 +274,7 @@ package GNAT.Graphs is\n       function Has_Next (Iter : All_Edge_Iterator) return Boolean;\n       --  Determine whether iterator Iter has more edges to examine\n \n-      function Iterate_All_Edges (G : Instance) return All_Edge_Iterator;\n+      function Iterate_All_Edges (G : Directed_Graph) return All_Edge_Iterator;\n       --  Obtain an iterator over all edges of graph G\n \n       procedure Next\n@@ -294,7 +294,8 @@ package GNAT.Graphs is\n       function Has_Next (Iter : All_Vertex_Iterator) return Boolean;\n       --  Determine whether iterator Iter has more vertices to examine\n \n-      function Iterate_All_Vertices (G : Instance) return All_Vertex_Iterator;\n+      function Iterate_All_Vertices\n+        (G : Directed_Graph) return All_Vertex_Iterator;\n       --  Obtain an iterator over all vertices of graph G\n \n       procedure Next\n@@ -315,7 +316,8 @@ package GNAT.Graphs is\n       function Has_Next (Iter : Component_Iterator) return Boolean;\n       --  Determine whether iterator Iter has more components to examine\n \n-      function Iterate_Components (G : Instance) return Component_Iterator;\n+      function Iterate_Components\n+        (G : Directed_Graph) return Component_Iterator;\n       --  Obtain an iterator over all components of graph G\n \n       procedure Next\n@@ -336,7 +338,7 @@ package GNAT.Graphs is\n       --  Determine whether iterator Iter has more outgoing edges to examine\n \n       function Iterate_Outgoing_Edges\n-        (G : Instance;\n+        (G : Directed_Graph;\n          V : Vertex_Id) return Outgoing_Edge_Iterator;\n       --  Obtain an iterator over all the outgoing edges \"owned\" by vertex V of\n       --  graph G.\n@@ -360,7 +362,7 @@ package GNAT.Graphs is\n       --  Determine whether iterator Iter has more vertices to examine\n \n       function Iterate_Vertices\n-        (G    : Instance;\n+        (G    : Directed_Graph;\n          Comp : Component_Id) return Vertex_Iterator;\n       --  Obtain an iterator over all vertices that comprise component Comp of\n       --  graph G.\n@@ -396,7 +398,7 @@ package GNAT.Graphs is\n       procedure Destroy_Edge_Attributes (Attrs : in out Edge_Attributes);\n       --  Destroy the contents of attributes Attrs\n \n-      package Edge_Map is new Dynamic_HTable\n+      package Edge_Map is new Dynamic_Hash_Tables\n         (Key_Type              => Edge_Id,\n          Value_Type            => Edge_Attributes,\n          No_Value              => No_Edge_Attributes,\n@@ -412,7 +414,7 @@ package GNAT.Graphs is\n       -- Edge_Set --\n       --------------\n \n-      package Edge_Set is new Membership_Set\n+      package Edge_Set is new Membership_Sets\n         (Element_Type => Edge_Id,\n          \"=\"          => \"=\",\n          Hash         => Hash_Edge);\n@@ -424,7 +426,7 @@ package GNAT.Graphs is\n       procedure Destroy_Vertex (V : in out Vertex_Id);\n       --  Destroy the contents of a vertex\n \n-      package Vertex_List is new Doubly_Linked_List\n+      package Vertex_List is new Doubly_Linked_Lists\n         (Element_Type    => Vertex_Id,\n          \"=\"             => Same_Vertex,\n          Destroy_Element => Destroy_Vertex);\n@@ -437,7 +439,7 @@ package GNAT.Graphs is\n          Component : Component_Id := No_Component;\n          --  The component where a vertex lives\n \n-         Outgoing_Edges : Edge_Set.Instance := Edge_Set.Nil;\n+         Outgoing_Edges : Edge_Set.Membership_Set := Edge_Set.Nil;\n          --  The set of edges that extend out from a vertex\n       end record;\n \n@@ -448,7 +450,7 @@ package GNAT.Graphs is\n       procedure Destroy_Vertex_Attributes (Attrs : in out Vertex_Attributes);\n       --  Destroy the contents of attributes Attrs\n \n-      package Vertex_Map is new Dynamic_HTable\n+      package Vertex_Map is new Dynamic_Hash_Tables\n         (Key_Type              => Vertex_Id,\n          Value_Type            => Vertex_Attributes,\n          No_Value              => No_Vertex_Attributes,\n@@ -465,7 +467,7 @@ package GNAT.Graphs is\n       -------------------\n \n       type Component_Attributes is record\n-         Vertices : Vertex_List.Instance := Vertex_List.Nil;\n+         Vertices : Vertex_List.Doubly_Linked_List := Vertex_List.Nil;\n       end record;\n \n       No_Component_Attributes : constant Component_Attributes :=\n@@ -475,7 +477,7 @@ package GNAT.Graphs is\n         (Attrs : in out Component_Attributes);\n       --  Destroy the contents of attributes Attrs\n \n-      package Component_Map is new Dynamic_HTable\n+      package Component_Map is new Dynamic_Hash_Tables\n         (Key_Type              => Component_Id,\n          Value_Type            => Component_Attributes,\n          No_Value              => No_Component_Attributes,\n@@ -491,25 +493,21 @@ package GNAT.Graphs is\n       -- Graph --\n       -----------\n \n-      type Graph is record\n-         All_Edges : Edge_Map.Instance := Edge_Map.Nil;\n+      type Directed_Graph_Attributes is record\n+         All_Edges : Edge_Map.Dynamic_Hash_Table := Edge_Map.Nil;\n          --  The map of edge -> edge attributes for all edges in the graph\n \n-         All_Vertices : Vertex_Map.Instance := Vertex_Map.Nil;\n+         All_Vertices : Vertex_Map.Dynamic_Hash_Table := Vertex_Map.Nil;\n          --  The map of vertex -> vertex attributes for all vertices in the\n          --  graph.\n \n-         Components : Component_Map.Instance := Component_Map.Nil;\n+         Components : Component_Map.Dynamic_Hash_Table := Component_Map.Nil;\n          --  The map of component -> component attributes for all components\n          --  in the graph.\n       end record;\n \n-      --------------\n-      -- Instance --\n-      --------------\n-\n-      type Instance is access Graph;\n-      Nil : constant Instance := null;\n+      type Directed_Graph is access Directed_Graph_Attributes;\n+      Nil : constant Directed_Graph := null;\n \n       ---------------\n       -- Iterators --\n@@ -520,7 +518,7 @@ package GNAT.Graphs is\n       type Component_Iterator     is new Component_Map.Iterator;\n       type Outgoing_Edge_Iterator is new Edge_Set.Iterator;\n       type Vertex_Iterator        is new Vertex_List.Iterator;\n-   end Directed_Graph;\n+   end Directed_Graphs;\n \n private\n    No_Component    : constant Component_Id := Component_Id'First;"}]}