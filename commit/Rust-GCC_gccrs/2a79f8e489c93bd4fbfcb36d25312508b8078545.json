{"sha": "2a79f8e489c93bd4fbfcb36d25312508b8078545", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmE3OWY4ZTQ4OWM5M2JkNGZiZmNiMzZkMjUzMTI1MDhiODA3ODU0NQ==", "commit": {"author": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2009-09-18T15:12:48Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2009-09-18T15:12:48Z"}, "message": "re PR target/38288 (i386/i386.c: 7 * set but not used variables)\n\n\tPR target/38288\n\tFrom David Binderman <dcb314@hotmail.com>:\n\t* gcc/config/i386/i386.c (ix86_function_regparm): Remove useless\n\tlocal variable f.  Remove stale comments.\n\t(ix86_compute_frame_layout): Remove useless local variable total_size.\n\tRemove #if 0'd code.\n\t(legitimate_address_p): Remove useless local variables\n\treason_rtx and reason.\n\t(ix86_split_copysign_const): Remove useless local variable op1.\n\t(scale_counter): Remove useless local variable piece_size_mask.\n\nFrom-SVN: r151854", "tree": {"sha": "d075d9c99f7b61128e8d4245344a3cd0acb7c230", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d075d9c99f7b61128e8d4245344a3cd0acb7c230"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2a79f8e489c93bd4fbfcb36d25312508b8078545", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a79f8e489c93bd4fbfcb36d25312508b8078545", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a79f8e489c93bd4fbfcb36d25312508b8078545", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a79f8e489c93bd4fbfcb36d25312508b8078545/comments", "author": null, "committer": null, "parents": [{"sha": "6465b6a71f79ed135f18fee5f8ab40ecd8265d39", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6465b6a71f79ed135f18fee5f8ab40ecd8265d39", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6465b6a71f79ed135f18fee5f8ab40ecd8265d39"}], "stats": {"total": 159, "additions": 51, "deletions": 108}, "files": [{"sha": "aa1a8ad09c91fbb38b6591ff8208d294812a17f5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a79f8e489c93bd4fbfcb36d25312508b8078545/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a79f8e489c93bd4fbfcb36d25312508b8078545/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2a79f8e489c93bd4fbfcb36d25312508b8078545", "patch": "@@ -1,3 +1,16 @@\n+2009-09-18  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\tPR target/38288\n+\tFrom David Binderman <dcb314@hotmail.com>:\n+\t* gcc/config/i386/i386.c (ix86_function_regparm): Remove useless\n+\tlocal variable f.  Remove stale comments.\n+\t(ix86_compute_frame_layout): Remove useless local variable total_size.\n+\tRemove #if 0'd code.\n+\t(legitimate_address_p): Remove useless local variables\n+\treason_rtx and reason.\n+\t(ix86_split_copysign_const): Remove useless local variable op1.\n+\t(scale_counter): Remove useless local variable piece_size_mask.\n+\n 2009-09-18  Jakub Jelinek  <jakub@redhat.com>\n \n \t* stmt.c (expand_asm_operands): Set REG_ATTRS on the temporary from\n@@ -126,7 +139,7 @@\n \t(ipa_early_sra_gate): New function.\n \t(pass_early_ipa_sra): New variable.\n \t* Makefile.in (tree-sra.o): Add cgraph.h to dependencies.\n-\t\n+\n 2009-09-17  Michael Matz  <matz@suse.de>\n \n \tPR middle-end/41347\n@@ -203,7 +216,7 @@\n \n \t* config/sh/sh.c (output_stack_adjust): Add new argument frame_p.\n \t(sh_expand_prologue): Update calls to output_stack_adjust.\n-\t(sh_expand_epilogue): Likewise.\t\n+\t(sh_expand_epilogue): Likewise.\n \n 2009-09-15  Adam Nemet  <anemet@caviumnetworks.com>\n \n@@ -272,8 +285,8 @@\n \n 2009-09-15  Christian Bruel  <christian.bruel@st.com>\n \n-        * regrename.c (do_replace): Update REG_DEAD notes. \n-\t\n+\t* regrename.c (do_replace): Update REG_DEAD notes.\n+\n 2009-09-15  Revital Eres  <eres@il.ibm.com>\n \n \t* doc/tm.texi (TARGET_SUPPORT_VECTOR_MISALIGNMENT): Document."}, {"sha": "3d907c04e1d7aa3d25f6e529abe763cc4e6407f5", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 34, "deletions": 104, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a79f8e489c93bd4fbfcb36d25312508b8078545/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a79f8e489c93bd4fbfcb36d25312508b8078545/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=2a79f8e489c93bd4fbfcb36d25312508b8078545", "patch": "@@ -4516,7 +4516,6 @@ ix86_function_regparm (const_tree type, const_tree decl)\n       if (i && i->local)\n \t{\n \t  int local_regparm, globals = 0, regno;\n-\t  struct function *f;\n \n \t  /* Make sure no regparm register is taken by a\n \t     fixed register variable.  */\n@@ -4531,16 +4530,7 @@ ix86_function_regparm (const_tree type, const_tree decl)\n \t      && !DECL_NO_STATIC_CHAIN (decl))\n \t    local_regparm = 2;\n \n-\t  /* If the function realigns its stackpointer, the prologue will\n-\t     clobber %ecx.  If we've already generated code for the callee,\n-\t     the callee DECL_STRUCT_FUNCTION is gone, so we fall back to\n-\t     scanning the attributes for the self-realigning property.  */\n-\t  f = DECL_STRUCT_FUNCTION (decl);\n-          /* Since current internal arg pointer won't conflict with\n-\t     parameter passing regs, so no need to change stack\n-\t     realignment and adjust regparm number.\n-\n-\t     Each fixed register usage increases register pressure,\n+\t  /* Each fixed register usage increases register pressure,\n \t     so less registers should be used for argument passing.\n \t     This functionality can be overriden by an explicit\n \t     regparm value.  */\n@@ -7822,15 +7812,13 @@ ix86_builtin_setjmp_frame_value (void)\n static void\n ix86_compute_frame_layout (struct ix86_frame *frame)\n {\n-  HOST_WIDE_INT total_size;\n   unsigned int stack_alignment_needed;\n   HOST_WIDE_INT offset;\n   unsigned int preferred_alignment;\n   HOST_WIDE_INT size = get_frame_size ();\n \n   frame->nregs = ix86_nsaved_regs ();\n   frame->nsseregs = ix86_nsaved_sseregs ();\n-  total_size = size;\n \n   stack_alignment_needed = crtl->stack_alignment_needed / BITS_PER_UNIT;\n   preferred_alignment = crtl->preferred_stack_boundary / BITS_PER_UNIT;\n@@ -7976,26 +7964,6 @@ ix86_compute_frame_layout (struct ix86_frame *frame)\n     frame->red_zone_size = 0;\n   frame->to_allocate -= frame->red_zone_size;\n   frame->stack_pointer_offset -= frame->red_zone_size;\n-#if 0\n-  fprintf (stderr, \"\\n\");\n-  fprintf (stderr, \"size: %ld\\n\", (long)size);\n-  fprintf (stderr, \"nregs: %ld\\n\", (long)frame->nregs);\n-  fprintf (stderr, \"nsseregs: %ld\\n\", (long)frame->nsseregs);\n-  fprintf (stderr, \"padding0: %ld\\n\", (long)frame->padding0);\n-  fprintf (stderr, \"alignment1: %ld\\n\", (long)stack_alignment_needed);\n-  fprintf (stderr, \"padding1: %ld\\n\", (long)frame->padding1);\n-  fprintf (stderr, \"va_arg: %ld\\n\", (long)frame->va_arg_size);\n-  fprintf (stderr, \"padding2: %ld\\n\", (long)frame->padding2);\n-  fprintf (stderr, \"to_allocate: %ld\\n\", (long)frame->to_allocate);\n-  fprintf (stderr, \"red_zone_size: %ld\\n\", (long)frame->red_zone_size);\n-  fprintf (stderr, \"frame_pointer_offset: %ld\\n\", (long)frame->frame_pointer_offset);\n-  fprintf (stderr, \"hard_frame_pointer_offset: %ld\\n\",\n-\t   (long)frame->hard_frame_pointer_offset);\n-  fprintf (stderr, \"stack_pointer_offset: %ld\\n\", (long)frame->stack_pointer_offset);\n-  fprintf (stderr, \"current_function_is_leaf: %ld\\n\", (long)current_function_is_leaf);\n-  fprintf (stderr, \"cfun->calls_alloca: %ld\\n\", (long)cfun->calls_alloca);\n-  fprintf (stderr, \"x86_current_function_calls_tls_descriptor: %ld\\n\", (long)ix86_current_function_calls_tls_descriptor);\n-#endif\n }\n \n /* Emit code to save registers in the prologue.  */\n@@ -9609,14 +9577,10 @@ ix86_legitimate_address_p (enum machine_mode mode ATTRIBUTE_UNUSED,\n   struct ix86_address parts;\n   rtx base, index, disp;\n   HOST_WIDE_INT scale;\n-  const char *reason = NULL;\n-  rtx reason_rtx = NULL_RTX;\n \n   if (ix86_decompose_address (addr, &parts) <= 0)\n-    {\n-      reason = \"decomposition failed\";\n-      goto report_error;\n-    }\n+    /* Decomposition failed.  */\n+    return false;\n \n   base = parts.base;\n   index = parts.index;\n@@ -9632,7 +9596,6 @@ ix86_legitimate_address_p (enum machine_mode mode ATTRIBUTE_UNUSED,\n   if (base)\n     {\n       rtx reg;\n-      reason_rtx = base;\n \n       if (REG_P (base))\n   \treg = base;\n@@ -9642,23 +9605,17 @@ ix86_legitimate_address_p (enum machine_mode mode ATTRIBUTE_UNUSED,\n \t\t  <= UNITS_PER_WORD)\n   \treg = SUBREG_REG (base);\n       else\n-\t{\n-\t  reason = \"base is not a register\";\n-\t  goto report_error;\n-\t}\n+\t/* Base is not a register.  */\n+\treturn false;\n \n       if (GET_MODE (base) != Pmode)\n-\t{\n-\t  reason = \"base is not in Pmode\";\n-\t  goto report_error;\n-\t}\n+\t/* Base is not in Pmode.  */\n+\treturn false;\n \n       if ((strict && ! REG_OK_FOR_BASE_STRICT_P (reg))\n \t  || (! strict && ! REG_OK_FOR_BASE_NONSTRICT_P (reg)))\n-\t{\n-\t  reason = \"base is not valid\";\n-\t  goto report_error;\n-\t}\n+\t/* Base is not valid.  */\n+\treturn false;\n     }\n \n   /* Validate index register.\n@@ -9668,7 +9625,6 @@ ix86_legitimate_address_p (enum machine_mode mode ATTRIBUTE_UNUSED,\n   if (index)\n     {\n       rtx reg;\n-      reason_rtx = index;\n \n       if (REG_P (index))\n   \treg = index;\n@@ -9678,47 +9634,34 @@ ix86_legitimate_address_p (enum machine_mode mode ATTRIBUTE_UNUSED,\n \t\t  <= UNITS_PER_WORD)\n   \treg = SUBREG_REG (index);\n       else\n-\t{\n-\t  reason = \"index is not a register\";\n-\t  goto report_error;\n-\t}\n+\t/* Index is not a register.  */\n+\treturn false;\n \n       if (GET_MODE (index) != Pmode)\n-\t{\n-\t  reason = \"index is not in Pmode\";\n-\t  goto report_error;\n-\t}\n+\t/* Index is not in Pmode.  */\n+\treturn false;\n \n       if ((strict && ! REG_OK_FOR_INDEX_STRICT_P (reg))\n \t  || (! strict && ! REG_OK_FOR_INDEX_NONSTRICT_P (reg)))\n-\t{\n-\t  reason = \"index is not valid\";\n-\t  goto report_error;\n-\t}\n+\t/* Index is not valid.  */\n+\treturn false;\n     }\n \n   /* Validate scale factor.  */\n   if (scale != 1)\n     {\n-      reason_rtx = GEN_INT (scale);\n       if (!index)\n-\t{\n-\t  reason = \"scale without index\";\n-\t  goto report_error;\n-\t}\n+\t/* Scale without index.  */\n+\treturn false;\n \n       if (scale != 2 && scale != 4 && scale != 8)\n-\t{\n-\t  reason = \"scale is not a valid multiplier\";\n-\t  goto report_error;\n-\t}\n+\t/* Scale is not a valid multiplier.  */\n+\treturn false;\n     }\n \n   /* Validate displacement.  */\n   if (disp)\n     {\n-      reason_rtx = disp;\n-\n       if (GET_CODE (disp) == CONST\n \t  && GET_CODE (XEXP (disp, 0)) == UNSPEC\n \t  && XINT (XEXP (disp, 0), 1) != UNSPEC_MACHOPIC_OFFSET)\n@@ -9732,8 +9675,9 @@ ix86_legitimate_address_p (enum machine_mode mode ATTRIBUTE_UNUSED,\n \t    gcc_assert (flag_pic);\n \t    if (!TARGET_64BIT)\n \t      goto is_legitimate_pic;\n-\t    reason = \"64bit address unspec\";\n-\t    goto report_error;\n+\n+\t    /* 64bit address unspec.  */\n+\t    return false;\n \n \t  case UNSPEC_GOTPCREL:\n \t    gcc_assert (flag_pic);\n@@ -9747,8 +9691,8 @@ ix86_legitimate_address_p (enum machine_mode mode ATTRIBUTE_UNUSED,\n \t    break;\n \n \t  default:\n-\t    reason = \"invalid address unspec\";\n-\t    goto report_error;\n+\t    /* Invalid address unspec.  */\n+\t    return false;\n \t  }\n \n       else if (SYMBOLIC_CONST (disp)\n@@ -9771,16 +9715,12 @@ ix86_legitimate_address_p (enum machine_mode mode ATTRIBUTE_UNUSED,\n \t\t  || !CONST_INT_P (XEXP (XEXP (disp, 0), 1))\n \t\t  || (XINT (XEXP (XEXP (disp, 0), 0), 1) != UNSPEC_DTPOFF\n \t\t      && XINT (XEXP (XEXP (disp, 0), 0), 1) != UNSPEC_NTPOFF))\n-\t\t{\n-\t\t  reason = \"non-constant pic memory reference\";\n-\t\t  goto report_error;\n-\t\t}\n+\t\t/* Non-constant pic memory reference.  */\n+\t\treturn false;\n \t    }\n \t  else if (! legitimate_pic_address_disp_p (disp))\n-\t    {\n-\t      reason = \"displacement is an invalid pic construct\";\n-\t      goto report_error;\n-\t    }\n+\t    /* Displacement is an invalid pic construct.  */\n+\t    return false;\n \n           /* This code used to verify that a symbolic pic displacement\n \t     includes the pic_offset_table_rtx register.\n@@ -9810,23 +9750,16 @@ ix86_legitimate_address_p (enum machine_mode mode ATTRIBUTE_UNUSED,\n \t\t   || !legitimate_constant_p (disp))\n \t       && (GET_CODE (disp) != SYMBOL_REF\n \t\t   || !legitimate_constant_p (disp)))\n-\t{\n-\t  reason = \"displacement is not constant\";\n-\t  goto report_error;\n-\t}\n+\t/* Displacement is not constant.  */\n+\treturn false;\n       else if (TARGET_64BIT\n \t       && !x86_64_immediate_operand (disp, VOIDmode))\n-\t{\n-\t  reason = \"displacement is out of range\";\n-\t  goto report_error;\n-\t}\n+\t/* Displacement is out of range.  */\n+\treturn false;\n     }\n \n   /* Everything looks valid.  */\n-  return TRUE;\n-\n- report_error:\n-  return FALSE;\n+  return true;\n }\n \n /* Determine if a given RTX is a valid constant address.  */\n@@ -14123,11 +14056,10 @@ void\n ix86_split_copysign_const (rtx operands[])\n {\n   enum machine_mode mode, vmode;\n-  rtx dest, op0, op1, mask, x;\n+  rtx dest, op0, mask, x;\n \n   dest = operands[0];\n   op0 = operands[1];\n-  op1 = operands[2];\n   mask = operands[3];\n \n   mode = GET_MODE (dest);\n@@ -16998,15 +16930,13 @@ static rtx\n scale_counter (rtx countreg, int scale)\n {\n   rtx sc;\n-  rtx piece_size_mask;\n \n   if (scale == 1)\n     return countreg;\n   if (CONST_INT_P (countreg))\n     return GEN_INT (INTVAL (countreg) / scale);\n   gcc_assert (REG_P (countreg));\n \n-  piece_size_mask = GEN_INT (scale - 1);\n   sc = expand_simple_binop (GET_MODE (countreg), LSHIFTRT, countreg,\n \t\t\t    GEN_INT (exact_log2 (scale)),\n \t\t\t    NULL, 1, OPTAB_DIRECT);"}]}