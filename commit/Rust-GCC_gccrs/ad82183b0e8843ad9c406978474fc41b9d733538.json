{"sha": "ad82183b0e8843ad9c406978474fc41b9d733538", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWQ4MjE4M2IwZTg4NDNhZDljNDA2OTc4NDc0ZmM0MWI5ZDczMzUzOA==", "commit": {"author": {"name": "Phil Edwards", "email": "pme@gcc.gnu.org", "date": "2000-08-30T20:18:12Z"}, "committer": {"name": "Phil Edwards", "email": "pme@gcc.gnu.org", "date": "2000-08-30T20:18:12Z"}, "message": "codecvt.html: Behind-the-scenes ASCII->HTML tweaks for certain browsers.\n\n2000-08-30  Phil Edwards  <pme@sources.redhat.com>\n\n\t* docs/22_locale/codecvt.html:  Behind-the-scenes ASCII->HTML\n\t  tweaks for certain browsers.\n\nFrom-SVN: r36067", "tree": {"sha": "a6f26a8cf7d2ef0f2e61a5b4eda349ac264a438e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a6f26a8cf7d2ef0f2e61a5b4eda349ac264a438e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ad82183b0e8843ad9c406978474fc41b9d733538", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad82183b0e8843ad9c406978474fc41b9d733538", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad82183b0e8843ad9c406978474fc41b9d733538", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad82183b0e8843ad9c406978474fc41b9d733538/comments", "author": null, "committer": null, "parents": [{"sha": "aef9fbbf8980f9348ebc70e75b1193d1828887f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aef9fbbf8980f9348ebc70e75b1193d1828887f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aef9fbbf8980f9348ebc70e75b1193d1828887f9"}], "stats": {"total": 65, "additions": 36, "deletions": 29}, "files": [{"sha": "3debd0e253f3c387bbf188602a4766c35ab6a141", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad82183b0e8843ad9c406978474fc41b9d733538/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad82183b0e8843ad9c406978474fc41b9d733538/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=ad82183b0e8843ad9c406978474fc41b9d733538", "patch": "@@ -1,3 +1,8 @@\n+2000-08-30  Phil Edwards  <pme@sources.redhat.com>\n+\n+\t* docs/22_locale/codecvt.html:  Behind-the-scenes ASCII->HTML\n+\t  tweaks for certain browsers.\n+\n 2000-08-28  Benjamin Kosnik  <bkoz@purist.soma.redhat.com>\n \n \t* docs/22_locale/codecvt.html: Add more bits, format. "}, {"sha": "9289d7dd634595a3b38ceb8de2e125f3eef9e0d5", "filename": "libstdc++-v3/docs/22_locale/codecvt.html", "status": "modified", "additions": 31, "deletions": 29, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad82183b0e8843ad9c406978474fc41b9d733538/libstdc%2B%2B-v3%2Fdocs%2F22_locale%2Fcodecvt.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad82183b0e8843ad9c406978474fc41b9d733538/libstdc%2B%2B-v3%2Fdocs%2F22_locale%2Fcodecvt.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2F22_locale%2Fcodecvt.html?ref=ad82183b0e8843ad9c406978474fc41b9d733538", "patch": "@@ -17,7 +17,7 @@ <H2>\n different character encoding schemes. In particular, the standard\n attempts to detail conversions between the implementation-defined wide\n characters (hereafter referred to as wchar_t) and the standard type\n-char that is so beloved in classic \"C\" (which can now be referred to\n+char that is so beloved in classic &quot;C&quot; (which can now be referred to\n as narrow characters.)  This document attempts to describe how the GNU\n libstdc++-v3 implementation deals with the conversion between wide and\n narrow characters, and also presents a framework for dealing with the\n@@ -42,7 +42,7 @@ <H2>\n \n <BLOCKQUOTE>\n <I>\n--1- The class codecvt<internT,externT,stateT> is for use when\n+-1- The class codecvt&lt;internT,externT,stateT&gt; is for use when\n converting from one codeset to another, such as from wide characters\n to multibyte characters, between wide character encodings such as\n Unicode and EUC. \n@@ -68,11 +68,11 @@ <H2>\n <BLOCKQUOTE>\n <I>\n -3- The instantiations required in the Table ??\n-(lib.locale.category), namely codecvt<wchar_t,char,mbstate_t> and\n-codecvt<char,char,mbstate_t>, convert the implementation-defined\n-native character set. codecvt<char,char,mbstate_t> implements a\n+(lib.locale.category), namely codecvt&lt;wchar_t,char,mbstate_t&gt; and\n+codecvt&lt;char,char,mbstate_t&gt;, convert the implementation-defined\n+native character set. codecvt&lt;char,char,mbstate_t&gt; implements a\n degenerate conversion; it does not convert at\n-all. codecvt<wchar_t,char,mbstate_t> converts between the native\n+all. codecvt&lt;wchar_t,char,mbstate_t&gt; converts between the native\n character sets for tiny and wide characters. Instantiations on\n mbstate_t perform conversion between encodings known to the library\n implementor.  Other encodings can be converted by specializing on a\n@@ -100,7 +100,7 @@ <H2>\n 2. Some thoughts on what would be useful\n </H2>\n Probably the most frequently asked question about code conversion is:\n-\"So dudes, what's the deal with Unicode strings?\" The dude part is\n+&quot;So dudes, what's the deal with Unicode strings?&quot; The dude part is\n optional, but apparently the usefulness of Unicode strings is pretty\n widely appreciated. Sadly, this specific encoding (And other useful\n encodings like UTF8, UCS4, ISO 8859-10, etc etc etc) are not mentioned\n@@ -168,7 +168,8 @@ <H2>\n \n <P>\n For iconv-based implementations, string literals for each of the\n-encodings (ie. \"UCS-2\" and \"UTF-8\") are necessary, although for other,\n+encodings (ie. &quot;UCS-2&quot; and &quot;UTF-8&quot;) are necessary,\n+although for other,\n non-iconv implementations a table of enumerated values or some other\n mechanism may be required.\n \n@@ -178,13 +179,13 @@ <H2>\n <LI>\n  Some encodings are require explicit endian-ness. As such, some kind\n   of endian marker or other byte-order marker will be necessary. See\n-  \"Footnotes for C/C++ developers\" in Haible for more information on\n+  &quot;Footnotes for C/C++ developers&quot; in Haible for more information on\n   UCS-2/Unicode endian issues. (Summary: big endian seems most likely,\n   however implementations, most notably Microsoft, vary.)\n \n <LI>\n  Types representing the conversion state, for conversions involving\n-  the machinery in the \"C\" library, or the conversion descriptor, for\n+  the machinery in the &quot;C&quot; library, or the conversion descriptor, for\n   conversions using iconv (such as the type iconv_t.)  Note that the\n   conversion descriptor encodes more information than a simple encoding\n   state type.\n@@ -207,14 +208,14 @@ <H2>\n \n <P>\n <H2>\n-3. Problems with \"C\" code conversions : thread safety, global locales,\n-   termination.\n+3. Problems with &quot;C&quot; code conversions : thread safety, global\n+locales, termination.\n </H2>\n \n In addition, multi-threaded and multi-locale environments also impact\n the design and requirements for code conversions. In particular, they\n-affect the required specialization codecvt<wchar_t, char, mbstate_t>\n-when implemented using standard \"C\" functions.\n+affect the required specialization codecvt&lt;wchar_t, char, mbstate_t&gt;\n+when implemented using standard &quot;C&quot; functions.\n \n <P>\n Three problems arise, one big, one of medium importance, and one small. \n@@ -233,7 +234,7 @@ <H2>\n \n <P>\n The last, and fundamental problem, is the assumption of a global\n-locale for all the \"C\" functions referenced above. For something like\n+locale for all the &quot;C&quot; functions referenced above. For something like\n C++ iostreams (where codecvt is explicitly used) the notion of\n multiple locales is fundamental. In practice, most users may not run\n into this limitation. However, as a quality of implementation issue,\n@@ -243,7 +244,7 @@ <H2>\n option, a high-quality implementation, damn the additional complexity!\n \n <P>\n-For the required specialization codecvt<wchar_t, char, mbstate_t> ,\n+For the required specialization codecvt&lt;wchar_t, char, mbstate_t&gt; ,\n conversions are made between the internal character set (always UCS4\n on GNU/Linux) and whatever the currently selected locale for the\n LC_CTYPE category implements.\n@@ -256,15 +257,15 @@ <H2>\n \n <P>\n <TT>\n-codecvt&#60char, char, mbstate_t&#62\n+codecvt&lt;char, char, mbstate_t&gt;\n </TT>\n <P>\n This is a degenerate (ie, does nothing) specialization. Implementing\n this was a piece of cake.\n \n <P>\n <TT>\n-codecvt&#60char, wchar_t, mbstate_t&#62\n+codecvt&lt;char, wchar_t, mbstate_t&gt;\n </TT>\n <P>\n This specialization, by specifying all the template parameters, pretty\n@@ -353,7 +354,7 @@ <H2>\n \n <P>\n <TT> \n-__enc_traits(const __enc_traits&)\n+__enc_traits(const __enc_traits&amp;)\n </TT>\n <P>\n As iconv allocates memory and sets up conversion descriptors, the copy\n@@ -363,8 +364,8 @@ <H2>\n \n <P>\n Definitions for all the required codecvt member functions are provided\n-for this specialization, and usage of codecvt<internal character type,\n-external character type, __enc_traits> is consistent with other\n+for this specialization, and usage of codecvt&lt;internal character type,\n+external character type, __enc_traits&gt; is consistent with other\n codecvt usage.\n \n <P>\n@@ -379,7 +380,7 @@ <H2>\n   typedef unicode_t\t\t\t\tint_type;\n   typedef char\t\t\t\t\text_type;\n   typedef __enc_traits\t\t\t\tenc_type;\n-  typedef codecvt<int_type, ext_type, enc_type>\tunicode_codecvt;\n+  typedef codecvt&lt;int_type, ext_type, enc_type&gt;\tunicode_codecvt;\n \n   const ext_type* \te_lit = \"black pearl jasmine tea\";\n   int \t\t\tsize = strlen(e_lit);\n@@ -399,8 +400,8 @@ <H2>\n   // construct a locale object with the specialized facet.\n   locale \t\tloc(locale::classic(), new unicode_codecvt);\n   // sanity check the constructed locale has the specialized facet.\n-  VERIFY( has_facet<unicode_codecvt>(loc) );\n-  const unicode_codecvt&\tcvt = use_facet<unicode_codecvt>(loc); \n+  VERIFY( has_facet&lt;unicode_codecvt&gt;(loc) );\n+  const unicode_codecvt&amp; cvt = use_facet&lt;unicode_codecvt&gt;(loc); \n   // convert between const char* and unicode strings\n   unicode_codecvt::state_type state01(\"UNICODE\", \"ISO_8859-1\");\n   initialize_state(state01);\n@@ -454,7 +455,8 @@ <H2>\n \t\tstandards-conformant manner?\n \n \t\t<LI>\n-\t\thow to synchronize the \"C\" and \"C++\" conversion information?\n+\t\thow to synchronize the &quot;C&quot; and &quot;C++&quot;\n+        conversion information?\n \n \t\t<LI>\n \t\twchar_t/char internal buffers and conversions between\n@@ -475,17 +477,17 @@ <H2>\n 8. Bibliography / Referenced Documents\n </H2>\n \n-Drepper, Ulrich, GNU libc (glibc) 2.2 manual. In particular, Chapters \"6. Character Set Handling\" and \"7 Locales and Internationalization\"\n+Drepper, Ulrich, GNU libc (glibc) 2.2 manual. In particular, Chapters &quot;6. Character Set Handling&quot; and &quot;7 Locales and Internationalization&quot;\n \n <P>\n Drepper, Ulrich, Numerous, late-night email correspondence\n \n <P>\n-Feather, Clive, \"A brief description of Normative Addendum 1,\" in particular the parts on Extended Character Sets\n+Feather, Clive, &quot;A brief description of Normative Addendum 1,&quot; in particular the parts on Extended Character Sets\n http://www.lysator.liu.se/c/na1.html\n \n <P>\n-Haible, Bruno, \"The Unicode HOWTO\" v0.18, 4 August 2000\n+Haible, Bruno, &quot;The Unicode HOWTO&quot; v0.18, 4 August 2000\n ftp://ftp.ilog.fr/pub/Users/haible/utf8/Unicode-HOWTO.html\n \n <P>\n@@ -495,7 +497,7 @@ <H2>\n ISO/IEC 9899:1999 Programming languages - C\n \n <P>\n-Khun, Markus, \"UTF-8 and Unicode FAQ for Unix/Linux\"\n+Khun, Markus, &quot;UTF-8 and Unicode FAQ for Unix/Linux&quot;\n http://www.cl.cam.ac.uk/~mgk25/unicode.html\n \n <P>"}]}