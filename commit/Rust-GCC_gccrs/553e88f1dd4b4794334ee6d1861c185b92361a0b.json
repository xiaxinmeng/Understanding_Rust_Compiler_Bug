{"sha": "553e88f1dd4b4794334ee6d1861c185b92361a0b", "node_id": "C_kwDOANBUbNoAKDU1M2U4OGYxZGQ0YjQ3OTQzMzRlZTZkMTg2MWMxODViOTIzNjFhMGI", "commit": {"author": {"name": "David Faust", "email": "david.faust@oracle.com", "date": "2021-11-15T19:24:40Z"}, "committer": {"name": "David Faust", "email": "david.faust@oracle.com", "date": "2021-11-16T21:10:41Z"}, "message": "Replace Bstatement with GCC tree", "tree": {"sha": "62075b93b07f3dce20b0c0afa1bc8024bb1cac89", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/62075b93b07f3dce20b0c0afa1bc8024bb1cac89"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/553e88f1dd4b4794334ee6d1861c185b92361a0b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/553e88f1dd4b4794334ee6d1861c185b92361a0b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/553e88f1dd4b4794334ee6d1861c185b92361a0b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/553e88f1dd4b4794334ee6d1861c185b92361a0b/comments", "author": {"login": "dafaust", "id": 4460334, "node_id": "MDQ6VXNlcjQ0NjAzMzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4460334?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dafaust", "html_url": "https://github.com/dafaust", "followers_url": "https://api.github.com/users/dafaust/followers", "following_url": "https://api.github.com/users/dafaust/following{/other_user}", "gists_url": "https://api.github.com/users/dafaust/gists{/gist_id}", "starred_url": "https://api.github.com/users/dafaust/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dafaust/subscriptions", "organizations_url": "https://api.github.com/users/dafaust/orgs", "repos_url": "https://api.github.com/users/dafaust/repos", "events_url": "https://api.github.com/users/dafaust/events{/privacy}", "received_events_url": "https://api.github.com/users/dafaust/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dafaust", "id": 4460334, "node_id": "MDQ6VXNlcjQ0NjAzMzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4460334?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dafaust", "html_url": "https://github.com/dafaust", "followers_url": "https://api.github.com/users/dafaust/followers", "following_url": "https://api.github.com/users/dafaust/following{/other_user}", "gists_url": "https://api.github.com/users/dafaust/gists{/gist_id}", "starred_url": "https://api.github.com/users/dafaust/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dafaust/subscriptions", "organizations_url": "https://api.github.com/users/dafaust/orgs", "repos_url": "https://api.github.com/users/dafaust/repos", "events_url": "https://api.github.com/users/dafaust/events{/privacy}", "received_events_url": "https://api.github.com/users/dafaust/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b52a68d2d8676ea378f0fbb6726639cc80402542", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b52a68d2d8676ea378f0fbb6726639cc80402542", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b52a68d2d8676ea378f0fbb6726639cc80402542"}], "stats": {"total": 352, "additions": 153, "deletions": 199}, "files": [{"sha": "0e631e188719d01af19f1df37c885b6b30cbf187", "filename": "gcc/rust/backend/rust-compile-block.h", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/553e88f1dd4b4794334ee6d1861c185b92361a0b/gcc%2Frust%2Fbackend%2Frust-compile-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/553e88f1dd4b4794334ee6d1861c185b92361a0b/gcc%2Frust%2Fbackend%2Frust-compile-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-block.h?ref=553e88f1dd4b4794334ee6d1861c185b92361a0b", "patch": "@@ -53,8 +53,7 @@ class CompileConditionalBlocks : public HIRCompileBase\n   using Rust::Compile::HIRCompileBase::visit;\n \n public:\n-  static Bstatement *compile (HIR::IfExpr *expr, Context *ctx,\n-\t\t\t      Bvariable *result)\n+  static tree compile (HIR::IfExpr *expr, Context *ctx, Bvariable *result)\n   {\n     CompileConditionalBlocks resolver (ctx, result);\n     expr->accept_vis (resolver);\n@@ -72,7 +71,7 @@ class CompileConditionalBlocks : public HIRCompileBase\n     : HIRCompileBase (ctx), translated (nullptr), result (result)\n   {}\n \n-  Bstatement *translated;\n+  tree translated;\n   Bvariable *result;\n };\n \n@@ -81,8 +80,8 @@ class CompileExprWithBlock : public HIRCompileBase\n   using Rust::Compile::HIRCompileBase::visit;\n \n public:\n-  static Bstatement *compile (HIR::ExprWithBlock *expr, Context *ctx,\n-\t\t\t      Bvariable *result)\n+  static tree compile (HIR::ExprWithBlock *expr, Context *ctx,\n+\t\t       Bvariable *result)\n   {\n     CompileExprWithBlock resolver (ctx, result);\n     expr->accept_vis (resolver);\n@@ -109,7 +108,7 @@ class CompileExprWithBlock : public HIRCompileBase\n     : HIRCompileBase (ctx), translated (nullptr), result (result)\n   {}\n \n-  Bstatement *translated;\n+  tree translated;\n   Bvariable *result;\n };\n "}, {"sha": "1128fa82cae0d6cd897b835a646f874a129f619a", "filename": "gcc/rust/backend/rust-compile-context.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/553e88f1dd4b4794334ee6d1861c185b92361a0b/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/553e88f1dd4b4794334ee6d1861c185b92361a0b/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-context.h?ref=553e88f1dd4b4794334ee6d1861c185b92361a0b", "patch": "@@ -139,12 +139,12 @@ class Context\n     return scope_stack.back ();\n   }\n \n-  void add_statement_to_enclosing_scope (Bstatement *stmt)\n+  void add_statement_to_enclosing_scope (tree stmt)\n   {\n     statements.at (statements.size () - 2).push_back (stmt);\n   }\n \n-  void add_statement (Bstatement *stmt) { statements.back ().push_back (stmt); }\n+  void add_statement (tree stmt) { statements.back ().push_back (stmt); }\n \n   void insert_var_decl (HirId id, ::Bvariable *decl)\n   {\n@@ -323,7 +323,7 @@ class Context\n   std::map<HirId, ::Bfunction *> compiled_fn_map;\n   std::map<HirId, tree> compiled_consts;\n   std::map<HirId, ::Blabel *> compiled_labels;\n-  std::vector<::std::vector<Bstatement *>> statements;\n+  std::vector<::std::vector<tree>> statements;\n   std::vector<::Bblock *> scope_stack;\n   std::vector<::Bvariable *> loop_value_stack;\n   std::vector<::Blabel *> loop_begin_labels;"}, {"sha": "8786702498a7ee82e21fc38009d6f16e2b8f1bea", "filename": "gcc/rust/backend/rust-compile-expr.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/553e88f1dd4b4794334ee6d1861c185b92361a0b/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/553e88f1dd4b4794334ee6d1861c185b92361a0b/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc?ref=553e88f1dd4b4794334ee6d1861c185b92361a0b", "patch": "@@ -86,7 +86,7 @@ CompileExpr::visit (HIR::CompoundAssignmentExpr &expr)\n   auto operator_expr\n     = ctx->get_backend ()->arithmetic_or_logical_expression (op, lhs, rhs,\n \t\t\t\t\t\t\t     expr.get_locus ());\n-  Bstatement *assignment\n+  tree assignment\n     = ctx->get_backend ()->assignment_statement (fn.fndecl, lhs, operator_expr,\n \t\t\t\t\t\t expr.get_locus ());\n   ctx->add_statement (assignment);\n@@ -178,7 +178,7 @@ CompileExpr::compile_dyn_dispatch_call (const TyTy::DynamicObjectType *dyn,\n   fncontext fnctx = ctx->peek_fn ();\n   Bblock *enclosing_scope = ctx->peek_enclosing_scope ();\n   bool is_address_taken = false;\n-  Bstatement *ret_var_stmt = nullptr;\n+  tree ret_var_stmt = NULL_TREE;\n   Bvariable *fn_convert_expr_tmp\n     = ctx->get_backend ()->temporary_variable (fnctx.fndecl, enclosing_scope,\n \t\t\t\t\t       expected_fntype, fn_convert_expr,"}, {"sha": "14d43450b424f1be351cc4fd3223331d3dad717d", "filename": "gcc/rust/backend/rust-compile-expr.h", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/553e88f1dd4b4794334ee6d1861c185b92361a0b/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/553e88f1dd4b4794334ee6d1861c185b92361a0b/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.h?ref=553e88f1dd4b4794334ee6d1861c185b92361a0b", "patch": "@@ -379,7 +379,7 @@ class CompileExpr : public HIRCompileBase\n \n     rvalue = coercion_site (rvalue, actual, expected, expr.get_locus ());\n \n-    Bstatement *assignment\n+    tree assignment\n       = ctx->get_backend ()->assignment_statement (fn.fndecl, lvalue, rvalue,\n \t\t\t\t\t\t   expr.get_locus ());\n \n@@ -518,7 +518,7 @@ class CompileExpr : public HIRCompileBase\n \ttree block_type = TyTyResolveCompile::compile (ctx, if_type);\n \n \tbool is_address_taken = false;\n-\tBstatement *ret_var_stmt = nullptr;\n+\ttree ret_var_stmt = nullptr;\n \ttmp = ctx->get_backend ()->temporary_variable (\n \t  fnctx.fndecl, enclosing_scope, block_type, NULL, is_address_taken,\n \t  expr.get_locus (), &ret_var_stmt);\n@@ -555,7 +555,7 @@ class CompileExpr : public HIRCompileBase\n \ttree block_type = TyTyResolveCompile::compile (ctx, if_type);\n \n \tbool is_address_taken = false;\n-\tBstatement *ret_var_stmt = nullptr;\n+\ttree ret_var_stmt = nullptr;\n \ttmp = ctx->get_backend ()->temporary_variable (\n \t  fnctx.fndecl, enclosing_scope, block_type, NULL, is_address_taken,\n \t  expr.get_locus (), &ret_var_stmt);\n@@ -591,7 +591,7 @@ class CompileExpr : public HIRCompileBase\n \ttree block_type = TyTyResolveCompile::compile (ctx, block_tyty);\n \n \tbool is_address_taken = false;\n-\tBstatement *ret_var_stmt = nullptr;\n+\ttree ret_var_stmt = nullptr;\n \ttmp = ctx->get_backend ()->temporary_variable (\n \t  fnctx.fndecl, enclosing_scope, block_type, NULL, is_address_taken,\n \t  expr.get_locus (), &ret_var_stmt);\n@@ -744,7 +744,7 @@ class CompileExpr : public HIRCompileBase\n \ttree block_type = TyTyResolveCompile::compile (ctx, block_tyty);\n \n \tbool is_address_taken = false;\n-\tBstatement *ret_var_stmt = nullptr;\n+\ttree ret_var_stmt = NULL_TREE;\n \ttmp = ctx->get_backend ()->temporary_variable (\n \t  fnctx.fndecl, enclosing_scope, block_type, NULL, is_address_taken,\n \t  expr.get_locus (), &ret_var_stmt);\n@@ -759,7 +759,7 @@ class CompileExpr : public HIRCompileBase\n \t  = ctx->get_backend ()->label (fnctx.fndecl,\n \t\t\t\t\tloop_label.get_lifetime ().get_name (),\n \t\t\t\t\tloop_label.get_locus ());\n-\tBstatement *label_decl\n+\ttree label_decl\n \t  = ctx->get_backend ()->label_definition_statement (label);\n \tctx->add_statement (label_decl);\n \tctx->insert_label_decl (\n@@ -768,7 +768,7 @@ class CompileExpr : public HIRCompileBase\n \n     Blabel *loop_begin_label\n       = ctx->get_backend ()->label (fnctx.fndecl, \"\", expr.get_locus ());\n-    Bstatement *loop_begin_label_decl\n+    tree loop_begin_label_decl\n       = ctx->get_backend ()->label_definition_statement (loop_begin_label);\n     ctx->add_statement (loop_begin_label_decl);\n     ctx->push_loop_begin_label (loop_begin_label);\n@@ -777,7 +777,7 @@ class CompileExpr : public HIRCompileBase\n       = CompileBlock::compile (expr.get_loop_block ().get (), ctx, nullptr);\n     tree loop_expr\n       = ctx->get_backend ()->loop_expression (code_block, expr.get_locus ());\n-    Bstatement *loop_stmt\n+    tree loop_stmt\n       = ctx->get_backend ()->expression_statement (fnctx.fndecl, loop_expr);\n     ctx->add_statement (loop_stmt);\n \n@@ -800,7 +800,7 @@ class CompileExpr : public HIRCompileBase\n \t  = ctx->get_backend ()->label (fnctx.fndecl,\n \t\t\t\t\tloop_label.get_lifetime ().get_name (),\n \t\t\t\t\tloop_label.get_locus ());\n-\tBstatement *label_decl\n+\ttree label_decl\n \t  = ctx->get_backend ()->label_definition_statement (label);\n \tctx->add_statement (label_decl);\n \tctx->insert_label_decl (\n@@ -819,7 +819,7 @@ class CompileExpr : public HIRCompileBase\n \n     Blabel *loop_begin_label\n       = ctx->get_backend ()->label (fnctx.fndecl, \"\", expr.get_locus ());\n-    Bstatement *loop_begin_label_decl\n+    tree loop_begin_label_decl\n       = ctx->get_backend ()->label_definition_statement (loop_begin_label);\n     ctx->add_statement (loop_begin_label_decl);\n     ctx->push_loop_begin_label (loop_begin_label);\n@@ -828,22 +828,21 @@ class CompileExpr : public HIRCompileBase\n       = CompileExpr::Compile (expr.get_predicate_expr ().get (), ctx);\n     tree exit_expr\n       = ctx->get_backend ()->exit_expression (condition, expr.get_locus ());\n-    Bstatement *break_stmt\n+    tree break_stmt\n       = ctx->get_backend ()->expression_statement (fnctx.fndecl, exit_expr);\n     ctx->add_statement (break_stmt);\n \n     Bblock *code_block\n       = CompileBlock::compile (expr.get_loop_block ().get (), ctx, nullptr);\n-    Bstatement *code_block_stmt\n-      = ctx->get_backend ()->block_statement (code_block);\n+    tree code_block_stmt = ctx->get_backend ()->block_statement (code_block);\n     ctx->add_statement (code_block_stmt);\n \n     ctx->pop_loop_begin_label ();\n     ctx->pop_block ();\n \n     tree loop_expr\n       = ctx->get_backend ()->loop_expression (loop_block, expr.get_locus ());\n-    Bstatement *loop_stmt\n+    tree loop_stmt\n       = ctx->get_backend ()->expression_statement (fnctx.fndecl, loop_expr);\n     ctx->add_statement (loop_stmt);\n   }\n@@ -860,7 +859,7 @@ class CompileExpr : public HIRCompileBase\n \ttree result_reference = ctx->get_backend ()->var_expression (\n \t  loop_result_holder, expr.get_expr ()->get_locus ());\n \n-\tBstatement *assignment = ctx->get_backend ()->assignment_statement (\n+\ttree assignment = ctx->get_backend ()->assignment_statement (\n \t  fnctx.fndecl, result_reference, compiled_expr, expr.get_locus ());\n \tctx->add_statement (assignment);\n       }\n@@ -896,7 +895,7 @@ class CompileExpr : public HIRCompileBase\n \t    return;\n \t  }\n \n-\tBstatement *goto_label\n+\ttree goto_label\n \t  = ctx->get_backend ()->goto_statement (label, expr.get_locus ());\n \tctx->add_statement (goto_label);\n       }\n@@ -905,7 +904,7 @@ class CompileExpr : public HIRCompileBase\n \ttree exit_expr = ctx->get_backend ()->exit_expression (\n \t  ctx->get_backend ()->boolean_constant_expression (true),\n \t  expr.get_locus ());\n-\tBstatement *break_stmt\n+\ttree break_stmt\n \t  = ctx->get_backend ()->expression_statement (fnctx.fndecl, exit_expr);\n \tctx->add_statement (break_stmt);\n       }\n@@ -945,7 +944,7 @@ class CompileExpr : public HIRCompileBase\n \t  }\n       }\n \n-    Bstatement *goto_label\n+    tree goto_label\n       = ctx->get_backend ()->goto_statement (label, expr.get_locus ());\n     ctx->add_statement (goto_label);\n   }"}, {"sha": "fb3b381144e3e983f4d617192226b265e19c8903", "filename": "gcc/rust/backend/rust-compile-implitem.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/553e88f1dd4b4794334ee6d1861c185b92361a0b/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/553e88f1dd4b4794334ee6d1861c185b92361a0b/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h?ref=553e88f1dd4b4794334ee6d1861c185b92361a0b", "patch": "@@ -278,7 +278,7 @@ class CompileInherentImplItem : public HIRCompileBase\n \ttree return_type = TyTyResolveCompile::compile (ctx, tyret);\n \n \tbool address_is_taken = false;\n-\tBstatement *ret_var_stmt = nullptr;\n+\ttree ret_var_stmt = NULL_TREE;\n \n \treturn_address = ctx->get_backend ()->temporary_variable (\n \t  fndecl, code_block, return_type, NULL, address_is_taken,\n@@ -538,7 +538,7 @@ class CompileTraitItem : public HIRCompileBase\n \ttree return_type = TyTyResolveCompile::compile (ctx, tyret);\n \n \tbool address_is_taken = false;\n-\tBstatement *ret_var_stmt = nullptr;\n+\ttree ret_var_stmt = NULL_TREE;\n \n \treturn_address = ctx->get_backend ()->temporary_variable (\n \t  fndecl, code_block, return_type, NULL, address_is_taken,"}, {"sha": "0e7737c27f4b199f59aa36801b165ac5a04db7cb", "filename": "gcc/rust/backend/rust-compile-item.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/553e88f1dd4b4794334ee6d1861c185b92361a0b/gcc%2Frust%2Fbackend%2Frust-compile-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/553e88f1dd4b4794334ee6d1861c185b92361a0b/gcc%2Frust%2Fbackend%2Frust-compile-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-item.h?ref=553e88f1dd4b4794334ee6d1861c185b92361a0b", "patch": "@@ -277,7 +277,7 @@ class CompileItem : public HIRCompileBase\n \ttree return_type = TyTyResolveCompile::compile (ctx, tyret);\n \n \tbool address_is_taken = false;\n-\tBstatement *ret_var_stmt = nullptr;\n+\ttree ret_var_stmt = NULL_TREE;\n \n \treturn_address = ctx->get_backend ()->temporary_variable (\n \t  fndecl, code_block, return_type, NULL, address_is_taken,"}, {"sha": "f3ee69d984837b0d9f2fc2f807e7a705c4b6a8dc", "filename": "gcc/rust/backend/rust-compile-stmt.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/553e88f1dd4b4794334ee6d1861c185b92361a0b/gcc%2Frust%2Fbackend%2Frust-compile-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/553e88f1dd4b4794334ee6d1861c185b92361a0b/gcc%2Frust%2Fbackend%2Frust-compile-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-stmt.h?ref=553e88f1dd4b4794334ee6d1861c185b92361a0b", "patch": "@@ -118,7 +118,7 @@ class CompileStmt : public HIRCompileBase\n     auto fnctx = ctx->peek_fn ();\n     if (ty->is_unit ())\n       {\n-\tBstatement *expr_stmt\n+\ttree expr_stmt\n \t  = ctx->get_backend ()->expression_statement (fnctx.fndecl, init);\n \tctx->add_statement (expr_stmt);\n       }"}, {"sha": "8b74c779f453d4106d20bb7826887a5b3d664193", "filename": "gcc/rust/backend/rust-compile.cc", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/553e88f1dd4b4794334ee6d1861c185b92361a0b/gcc%2Frust%2Fbackend%2Frust-compile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/553e88f1dd4b4794334ee6d1861c185b92361a0b/gcc%2Frust%2Fbackend%2Frust-compile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile.cc?ref=553e88f1dd4b4794334ee6d1861c185b92361a0b", "patch": "@@ -349,7 +349,7 @@ CompileBlock::visit (HIR::BlockExpr &expr)\n       auto compiled_expr = CompileStmt::Compile (s.get (), ctx);\n       if (compiled_expr != nullptr)\n \t{\n-\t  Bstatement *compiled_stmt\n+\t  tree compiled_stmt\n \t    = ctx->get_backend ()->expression_statement (fnctx.fndecl,\n \t\t\t\t\t\t\t compiled_expr);\n \t  ctx->add_statement (compiled_stmt);\n@@ -365,7 +365,7 @@ CompileBlock::visit (HIR::BlockExpr &expr)\n \t{\n \t  if (result == nullptr)\n \t    {\n-\t      Bstatement *final_stmt\n+\t      tree final_stmt\n \t\t= ctx->get_backend ()->expression_statement (fnctx.fndecl,\n \t\t\t\t\t\t\t     compiled_expr);\n \t      ctx->add_statement (final_stmt);\n@@ -375,7 +375,7 @@ CompileBlock::visit (HIR::BlockExpr &expr)\n \t      tree result_reference = ctx->get_backend ()->var_expression (\n \t\tresult, expr.get_final_expr ()->get_locus ());\n \n-\t      Bstatement *assignment\n+\t      tree assignment\n \t\t= ctx->get_backend ()->assignment_statement (fnctx.fndecl,\n \t\t\t\t\t\t\t     result_reference,\n \t\t\t\t\t\t\t     compiled_expr,\n@@ -438,7 +438,7 @@ CompileConditionalBlocks::visit (HIR::IfExprConseqIf &expr)\n \t\t\t\t  start_location, end_location);\n   ctx->push_block (else_block);\n \n-  Bstatement *else_stmt_decl\n+  tree else_stmt_decl\n     = CompileConditionalBlocks::compile (expr.get_conseq_if_expr (), ctx,\n \t\t\t\t\t result);\n   ctx->add_statement (else_stmt_decl);\n@@ -486,7 +486,7 @@ HIRCompileBase::compile_function_body (\n       auto compiled_expr = CompileStmt::Compile (s.get (), ctx);\n       if (compiled_expr != nullptr)\n \t{\n-\t  Bstatement *compiled_stmt\n+\t  tree compiled_stmt\n \t    = ctx->get_backend ()->expression_statement (fndecl, compiled_expr);\n \t  ctx->add_statement (compiled_stmt);\n \t}\n@@ -513,7 +513,7 @@ HIRCompileBase::compile_function_body (\n \t    }\n \t  else\n \t    {\n-\t      Bstatement *final_stmt\n+\t      tree final_stmt\n \t\t= ctx->get_backend ()->expression_statement (fndecl,\n \t\t\t\t\t\t\t     compiled_expr);\n \t      ctx->add_statement (final_stmt);\n@@ -612,7 +612,7 @@ HIRCompileBase::coerce_to_dyn_object (tree compiled_ref,\n   fncontext fnctx = ctx->peek_fn ();\n   Bblock *enclosing_scope = ctx->peek_enclosing_scope ();\n   bool is_address_taken = false;\n-  Bstatement *ret_var_stmt = nullptr;\n+  tree ret_var_stmt = NULL_TREE;\n \n   Bvariable *dyn_tmp = ctx->get_backend ()->temporary_variable (\n     fnctx.fndecl, enclosing_scope, dynamic_object, constructed_trait_object,"}, {"sha": "22e2b6b2a2a294c32c9604ca473b45f44c9726c4", "filename": "gcc/rust/rust-backend.h", "status": "modified", "additions": 24, "deletions": 39, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/553e88f1dd4b4794334ee6d1861c185b92361a0b/gcc%2Frust%2Frust-backend.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/553e88f1dd4b4794334ee6d1861c185b92361a0b/gcc%2Frust%2Frust-backend.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-backend.h?ref=553e88f1dd4b4794334ee6d1861c185b92361a0b", "patch": "@@ -41,9 +41,6 @@ saw_errors (void);\n // frontend, and passed back to the backend.  The types must be\n // defined by the backend using these names.\n \n-// The backend representation of a statement.\n-class Bstatement;\n-\n // The backend representation of a function definition or declaration.\n class Bfunction;\n \n@@ -84,7 +81,6 @@ class Backend\n \n   // debug\n   virtual void debug (tree) = 0;\n-  virtual void debug (Bstatement *) = 0;\n   virtual void debug (Bfunction *) = 0;\n   virtual void debug (Bblock *) = 0;\n   virtual void debug (Bvariable *) = 0;\n@@ -328,8 +324,7 @@ class Backend\n     = 0;\n \n   // Create an expression that executes BSTAT before BEXPR.\n-  virtual tree compound_expression (Bstatement *bstat, tree bexpr, Location)\n-    = 0;\n+  virtual tree compound_expression (tree bstat, tree bexpr, Location) = 0;\n \n   // Return an expression that executes THEN_EXPR if CONDITION is true, or\n   // ELSE_EXPR otherwise and returns the result as type BTYPE, within the\n@@ -400,32 +395,29 @@ class Backend\n   // Create an error statement.  This is used for cases which should\n   // not occur in a correct program, in order to keep the compilation\n   // going without crashing.\n-  virtual Bstatement *error_statement () = 0;\n+  virtual tree error_statement () = 0;\n \n   // Create an expression statement within the specified function.\n-  virtual Bstatement *expression_statement (Bfunction *, tree) = 0;\n+  virtual tree expression_statement (Bfunction *, tree) = 0;\n \n   // Create a variable initialization statement in the specified\n   // function.  This initializes a local variable at the point in the\n   // program flow where it is declared.\n-  virtual Bstatement *init_statement (Bfunction *, Bvariable *var, tree init)\n-    = 0;\n+  virtual tree init_statement (Bfunction *, Bvariable *var, tree init) = 0;\n \n   // Create an assignment statement within the specified function.\n-  virtual Bstatement *assignment_statement (Bfunction *, tree lhs, tree rhs,\n-\t\t\t\t\t    Location)\n+  virtual tree assignment_statement (Bfunction *, tree lhs, tree rhs, Location)\n     = 0;\n \n   // Create a return statement, passing the representation of the\n   // function and the list of values to return.\n-  virtual Bstatement *return_statement (Bfunction *, const std::vector<tree> &,\n-\t\t\t\t\tLocation)\n+  virtual tree return_statement (Bfunction *, const std::vector<tree> &,\n+\t\t\t\t Location)\n     = 0;\n \n   // Create an if statement within a function.  ELSE_BLOCK may be NULL.\n-  virtual Bstatement *if_statement (Bfunction *, tree condition,\n-\t\t\t\t    Bblock *then_block, Bblock *else_block,\n-\t\t\t\t    Location)\n+  virtual tree if_statement (Bfunction *, tree condition, Bblock *then_block,\n+\t\t\t     Bblock *else_block, Location)\n     = 0;\n \n   // infinite loop expressions\n@@ -441,26 +433,24 @@ class Backend\n   // either end with a goto statement or will fall through into\n   // STATEMENTS[i + 1].  CASES[i] is empty for the default clause,\n   // which need not be last.  FUNCTION is the current function.\n-  virtual Bstatement *\n-  switch_statement (Bfunction *function, tree value,\n-\t\t    const std::vector<std::vector<tree> > &cases,\n-\t\t    const std::vector<Bstatement *> &statements, Location)\n+  virtual tree switch_statement (Bfunction *function, tree value,\n+\t\t\t\t const std::vector<std::vector<tree> > &cases,\n+\t\t\t\t const std::vector<tree> &statements, Location)\n     = 0;\n \n   // Create a single statement from two statements.\n-  virtual Bstatement *compound_statement (Bstatement *, Bstatement *) = 0;\n+  virtual tree compound_statement (tree, tree) = 0;\n \n   // Create a single statement from a list of statements.\n-  virtual Bstatement *statement_list (const std::vector<Bstatement *> &) = 0;\n+  virtual tree statement_list (const std::vector<tree> &) = 0;\n \n   // Create a statement that attempts to execute BSTAT and calls EXCEPT_STMT if\n   // an exception occurs. EXCEPT_STMT may be NULL.  FINALLY_STMT may be NULL and\n   // if not NULL, it will always be executed.  This is used for handling defers\n   // in Go functions.  In C++, the resulting code is of this form:\n   //   try { BSTAT; } catch { EXCEPT_STMT; } finally { FINALLY_STMT; }\n-  virtual Bstatement *\n-  exception_handler_statement (Bstatement *bstat, Bstatement *except_stmt,\n-\t\t\t       Bstatement *finally_stmt, Location)\n+  virtual tree exception_handler_statement (tree bstat, tree except_stmt,\n+\t\t\t\t\t    tree finally_stmt, Location)\n     = 0;\n \n   // Blocks.\n@@ -484,13 +474,11 @@ class Backend\n   // the statements are created.  Then the statements are added to the\n   // block.  This will called exactly once per block.  The vector may\n   // be empty if there are no statements.\n-  virtual void block_add_statements (Bblock *,\n-\t\t\t\t     const std::vector<Bstatement *> &)\n-    = 0;\n+  virtual void block_add_statements (Bblock *, const std::vector<tree> &) = 0;\n \n   // Return the block as a statement.  This is used to include a block\n   // in a list of statements.\n-  virtual Bstatement *block_statement (Bblock *) = 0;\n+  virtual tree block_statement (Bblock *) = 0;\n \n   // Variables.\n \n@@ -567,8 +555,7 @@ class Backend\n   // *PSTATEMENT to a statement which initializes the variable.\n   virtual Bvariable *temporary_variable (Bfunction *, Bblock *, tree, tree init,\n \t\t\t\t\t bool address_is_taken,\n-\t\t\t\t\t Location location,\n-\t\t\t\t\t Bstatement **pstatement)\n+\t\t\t\t\t Location location, tree *pstatement)\n     = 0;\n \n   // Create an implicit variable that is compiler-defined.  This is\n@@ -694,10 +681,10 @@ class Backend\n   // Create a statement which defines a label.  This statement will be\n   // put into the codestream at the point where the label should be\n   // defined.\n-  virtual Bstatement *label_definition_statement (Blabel *) = 0;\n+  virtual tree label_definition_statement (Blabel *) = 0;\n \n   // Create a goto statement to a label.\n-  virtual Bstatement *goto_statement (Blabel *, Location) = 0;\n+  virtual tree goto_statement (Blabel *, Location) = 0;\n \n   // Create an expression for the address of a label.  This is used to\n   // get the return address of a deferred function which may call\n@@ -759,9 +746,8 @@ class Backend\n   // be a statement that looks like this in C++:\n   //   finish:\n   //     try { DEFER_RETURN; } catch { CHECK_DEFER; goto finish; }\n-  virtual Bstatement *function_defer_statement (Bfunction *function,\n-\t\t\t\t\t\ttree undefer, tree check_defer,\n-\t\t\t\t\t\tLocation)\n+  virtual tree function_defer_statement (Bfunction *function, tree undefer,\n+\t\t\t\t\t tree check_defer, Location)\n     = 0;\n \n   // Record PARAM_VARS as the variables to use for the parameters of FUNCTION.\n@@ -774,8 +760,7 @@ class Backend\n \n   // Set the function body for FUNCTION using the code in CODE_STMT.  Returns\n   // true on success, false on failure.\n-  virtual bool function_set_body (Bfunction *function, Bstatement *code_stmt)\n-    = 0;\n+  virtual bool function_set_body (Bfunction *function, tree code_stmt) = 0;\n \n   // Look up a named built-in function in the current backend implementation.\n   // Returns NULL if no built-in function by that name exists."}, {"sha": "873e664f6b592e80cc604fe628842496fbfe13f3", "filename": "gcc/rust/rust-gcc.cc", "status": "modified", "additions": 91, "deletions": 120, "changes": 211, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/553e88f1dd4b4794334ee6d1861c185b92361a0b/gcc%2Frust%2Frust-gcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/553e88f1dd4b4794334ee6d1861c185b92361a0b/gcc%2Frust%2Frust-gcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-gcc.cc?ref=553e88f1dd4b4794334ee6d1861c185b92361a0b", "patch": "@@ -70,12 +70,6 @@ class Gcc_tree\n \n // In gcc, types, expressions, and statements are all trees.\n \n-class Bstatement : public Gcc_tree\n-{\n-public:\n-  Bstatement (tree t) : Gcc_tree (t) {}\n-};\n-\n class Bfunction : public Gcc_tree\n {\n public:\n@@ -149,7 +143,6 @@ class Gcc_backend : public Backend\n   Gcc_backend ();\n \n   void debug (tree t) { debug_tree (t); };\n-  void debug (Bstatement *t) { debug_tree (t->get_tree ()); };\n   void debug (Bfunction *t) { debug_tree (t->get_tree ()); };\n   void debug (Bblock *t) { debug_tree (t->get_tree ()); };\n   void debug (Bvariable *t) { debug_tree (t->get_decl ()); };\n@@ -318,7 +311,7 @@ class Gcc_backend : public Backend\n \n   tree struct_field_expression (tree, size_t, Location);\n \n-  tree compound_expression (Bstatement *, tree, Location);\n+  tree compound_expression (tree, tree, Location);\n \n   tree conditional_expression (Bfunction *, tree, tree, tree, tree, Location);\n \n@@ -348,35 +341,29 @@ class Gcc_backend : public Backend\n \n   // Statements.\n \n-  Bstatement *error_statement ()\n-  {\n-    return this->make_statement (error_mark_node);\n-  }\n+  tree error_statement () { return error_mark_node; }\n \n-  Bstatement *expression_statement (Bfunction *, tree);\n+  tree expression_statement (Bfunction *, tree);\n \n-  Bstatement *init_statement (Bfunction *, Bvariable *var, tree init);\n+  tree init_statement (Bfunction *, Bvariable *var, tree init);\n \n-  Bstatement *assignment_statement (Bfunction *, tree lhs, tree rhs, Location);\n+  tree assignment_statement (Bfunction *, tree lhs, tree rhs, Location);\n \n-  Bstatement *return_statement (Bfunction *, const std::vector<tree> &,\n-\t\t\t\tLocation);\n+  tree return_statement (Bfunction *, const std::vector<tree> &, Location);\n \n-  Bstatement *if_statement (Bfunction *, tree condition, Bblock *then_block,\n-\t\t\t    Bblock *else_block, Location);\n+  tree if_statement (Bfunction *, tree condition, Bblock *then_block,\n+\t\t     Bblock *else_block, Location);\n \n-  Bstatement *switch_statement (Bfunction *function, tree value,\n-\t\t\t\tconst std::vector<std::vector<tree>> &cases,\n-\t\t\t\tconst std::vector<Bstatement *> &statements,\n-\t\t\t\tLocation);\n+  tree switch_statement (Bfunction *function, tree value,\n+\t\t\t const std::vector<std::vector<tree>> &cases,\n+\t\t\t const std::vector<tree> &statements, Location);\n \n-  Bstatement *compound_statement (Bstatement *, Bstatement *);\n+  tree compound_statement (tree, tree);\n \n-  Bstatement *statement_list (const std::vector<Bstatement *> &);\n+  tree statement_list (const std::vector<tree> &);\n \n-  Bstatement *exception_handler_statement (Bstatement *bstat,\n-\t\t\t\t\t   Bstatement *except_stmt,\n-\t\t\t\t\t   Bstatement *finally_stmt, Location);\n+  tree exception_handler_statement (tree bstat, tree except_stmt,\n+\t\t\t\t    tree finally_stmt, Location);\n \n   tree loop_expression (Bblock *body, Location);\n \n@@ -387,9 +374,9 @@ class Gcc_backend : public Backend\n   Bblock *block (Bfunction *, Bblock *, const std::vector<Bvariable *> &,\n \t\t Location, Location);\n \n-  void block_add_statements (Bblock *, const std::vector<Bstatement *> &);\n+  void block_add_statements (Bblock *, const std::vector<tree> &);\n \n-  Bstatement *block_statement (Bblock *);\n+  tree block_statement (Bblock *);\n \n   // Variables.\n \n@@ -412,7 +399,7 @@ class Gcc_backend : public Backend\n \t\t\t\t    Location);\n \n   Bvariable *temporary_variable (Bfunction *, Bblock *, tree, tree, bool,\n-\t\t\t\t Location, Bstatement **);\n+\t\t\t\t Location, tree *);\n \n   Bvariable *implicit_variable (const std::string &, const std::string &,\n \t\t\t\ttree, bool, bool, bool, int64_t);\n@@ -437,9 +424,9 @@ class Gcc_backend : public Backend\n \n   Blabel *label (Bfunction *, const std::string &name, Location);\n \n-  Bstatement *label_definition_statement (Blabel *);\n+  tree label_definition_statement (Blabel *);\n \n-  Bstatement *goto_statement (Blabel *, Location);\n+  tree goto_statement (Blabel *, Location);\n \n   tree label_address (Blabel *, Location);\n \n@@ -451,13 +438,13 @@ class Gcc_backend : public Backend\n \t\t       const std::string &asm_name, unsigned int flags,\n \t\t       Location);\n \n-  Bstatement *function_defer_statement (Bfunction *function, tree undefer,\n-\t\t\t\t\ttree defer, Location);\n+  tree function_defer_statement (Bfunction *function, tree undefer, tree defer,\n+\t\t\t\t Location);\n \n   bool function_set_parameters (Bfunction *function,\n \t\t\t\tconst std::vector<Bvariable *> &);\n \n-  bool function_set_body (Bfunction *function, Bstatement *code_stmt);\n+  bool function_set_body (Bfunction *function, tree code_stmt);\n \n   Bfunction *lookup_gcc_builtin (const std::string &);\n \n@@ -472,9 +459,6 @@ class Gcc_backend : public Backend\n \n private:\n \n-  // Make a Bstatement from a tree.\n-  Bstatement *make_statement (tree t) { return new Bstatement (t); }\n-\n   Bfunction *make_function (tree t) { return new Bfunction (t); }\n \n   tree fill_in_fields (tree, const std::vector<typed_identifier> &);\n@@ -1530,10 +1514,8 @@ Gcc_backend::struct_field_expression (tree struct_tree, size_t index,\n // Return an expression that executes BSTAT before BEXPR.\n \n tree\n-Gcc_backend::compound_expression (Bstatement *bstat, tree expr,\n-\t\t\t\t  Location location)\n+Gcc_backend::compound_expression (tree stat, tree expr, Location location)\n {\n-  tree stat = bstat->get_tree ();\n   if (stat == error_mark_node || expr == error_mark_node)\n     return this->error_expression ();\n   tree ret = fold_build2_loc (location.gcc_location (), COMPOUND_EXPR,\n@@ -2042,15 +2024,15 @@ Gcc_backend::call_expression (Bfunction *, // containing fcn for call\n \n // An expression as a statement.\n \n-Bstatement *\n+tree\n Gcc_backend::expression_statement (Bfunction *, tree expr)\n {\n-  return this->make_statement (expr);\n+  return expr;\n }\n \n // Variable initialization.\n \n-Bstatement *\n+tree\n Gcc_backend::init_statement (Bfunction *, Bvariable *var, tree init_tree)\n {\n   tree var_tree = var->get_decl ();\n@@ -2077,12 +2059,12 @@ Gcc_backend::init_statement (Bfunction *, Bvariable *var, tree init_tree)\n     ret = build2_loc (DECL_SOURCE_LOCATION (var_tree), COMPOUND_EXPR,\n \t\t      void_type_node, init_tree, ret);\n \n-  return this->make_statement (ret);\n+  return ret;\n }\n \n // Assignment.\n \n-Bstatement *\n+tree\n Gcc_backend::assignment_statement (Bfunction *bfn, tree lhs, tree rhs,\n \t\t\t\t   Location location)\n {\n@@ -2104,14 +2086,13 @@ Gcc_backend::assignment_statement (Bfunction *bfn, tree lhs, tree rhs,\n \n   rhs = this->convert_tree (TREE_TYPE (lhs), rhs, location);\n \n-  return this->make_statement (fold_build2_loc (location.gcc_location (),\n-\t\t\t\t\t\tMODIFY_EXPR, void_type_node,\n-\t\t\t\t\t\tlhs, rhs));\n+  return fold_build2_loc (location.gcc_location (), MODIFY_EXPR, void_type_node,\n+\t\t\t  lhs, rhs);\n }\n \n // Return.\n \n-Bstatement *\n+tree\n Gcc_backend::return_statement (Bfunction *bfunction,\n \t\t\t       const std::vector<tree> &vals, Location location)\n {\n@@ -2140,7 +2121,7 @@ Gcc_backend::return_statement (Bfunction *bfunction,\n       tree ret = fold_build1_loc (location.gcc_location (), RETURN_EXPR,\n \t\t\t\t  void_type_node, NULL_TREE);\n       append_to_statement_list (ret, &stmt_list);\n-      return this->make_statement (stmt_list);\n+      return stmt_list;\n     }\n \n   tree ret;\n@@ -2196,7 +2177,7 @@ Gcc_backend::return_statement (Bfunction *bfunction,\n       append_to_statement_list (ret_expr, &stmt_list);\n       ret = stmt_list;\n     }\n-  return this->make_statement (ret);\n+  return ret;\n }\n \n // Create a statement that attempts to execute BSTAT and calls EXCEPT_STMT if an\n@@ -2205,35 +2186,28 @@ Gcc_backend::return_statement (Bfunction *bfunction,\n // functions.  In C++, the resulting code is of this form:\n //   try { BSTAT; } catch { EXCEPT_STMT; } finally { FINALLY_STMT; }\n \n-Bstatement *\n-Gcc_backend::exception_handler_statement (Bstatement *bstat,\n-\t\t\t\t\t  Bstatement *except_stmt,\n-\t\t\t\t\t  Bstatement *finally_stmt,\n-\t\t\t\t\t  Location location)\n+tree\n+Gcc_backend::exception_handler_statement (tree try_stmt, tree except_stmt,\n+\t\t\t\t\t  tree finally_stmt, Location location)\n {\n-  tree stat_tree = bstat->get_tree ();\n-  tree except_tree = except_stmt == NULL ? NULL_TREE : except_stmt->get_tree ();\n-  tree finally_tree\n-    = finally_stmt == NULL ? NULL_TREE : finally_stmt->get_tree ();\n-\n-  if (stat_tree == error_mark_node || except_tree == error_mark_node\n-      || finally_tree == error_mark_node)\n+  if (try_stmt == error_mark_node || except_stmt == error_mark_node\n+      || finally_stmt == error_mark_node)\n     return this->error_statement ();\n \n-  if (except_tree != NULL_TREE)\n-    stat_tree = build2_loc (location.gcc_location (), TRY_CATCH_EXPR,\n-\t\t\t    void_type_node, stat_tree,\n-\t\t\t    build2_loc (location.gcc_location (), CATCH_EXPR,\n-\t\t\t\t\tvoid_type_node, NULL, except_tree));\n-  if (finally_tree != NULL_TREE)\n-    stat_tree = build2_loc (location.gcc_location (), TRY_FINALLY_EXPR,\n-\t\t\t    void_type_node, stat_tree, finally_tree);\n-  return this->make_statement (stat_tree);\n+  if (except_stmt != NULL_TREE)\n+    try_stmt = build2_loc (location.gcc_location (), TRY_CATCH_EXPR,\n+\t\t\t   void_type_node, try_stmt,\n+\t\t\t   build2_loc (location.gcc_location (), CATCH_EXPR,\n+\t\t\t\t       void_type_node, NULL, except_stmt));\n+  if (finally_stmt != NULL_TREE)\n+    try_stmt = build2_loc (location.gcc_location (), TRY_FINALLY_EXPR,\n+\t\t\t   void_type_node, try_stmt, finally_stmt);\n+  return try_stmt;\n }\n \n // If.\n \n-Bstatement *\n+tree\n Gcc_backend::if_statement (Bfunction *, tree cond_tree, Bblock *then_block,\n \t\t\t   Bblock *else_block, Location location)\n {\n@@ -2244,7 +2218,7 @@ Gcc_backend::if_statement (Bfunction *, tree cond_tree, Bblock *then_block,\n     return this->error_statement ();\n   tree ret = build3_loc (location.gcc_location (), COND_EXPR, void_type_node,\n \t\t\t cond_tree, then_tree, else_tree);\n-  return this->make_statement (ret);\n+  return ret;\n }\n \n // Loops\n@@ -2265,10 +2239,10 @@ Gcc_backend::exit_expression (tree cond_tree, Location locus)\n \n // Switch.\n \n-Bstatement *\n+tree\n Gcc_backend::switch_statement (Bfunction *function, tree value,\n \t\t\t       const std::vector<std::vector<tree>> &cases,\n-\t\t\t       const std::vector<Bstatement *> &statements,\n+\t\t\t       const std::vector<tree> &statements,\n \t\t\t       Location switch_location)\n {\n   gcc_assert (cases.size () == statements.size ());\n@@ -2281,13 +2255,13 @@ Gcc_backend::switch_statement (Bfunction *function, tree value,\n \n   tree stmt_list = NULL_TREE;\n   std::vector<std::vector<tree>>::const_iterator pc = cases.begin ();\n-  for (std::vector<Bstatement *>::const_iterator ps = statements.begin ();\n+  for (std::vector<tree>::const_iterator ps = statements.begin ();\n        ps != statements.end (); ++ps, ++pc)\n     {\n       if (pc->empty ())\n \t{\n-\t  location_t loc = (*ps != NULL ? EXPR_LOCATION ((*ps)->get_tree ())\n-\t\t\t\t\t: UNKNOWN_LOCATION);\n+\t  location_t loc\n+\t    = (*ps != NULL ? EXPR_LOCATION (*ps) : UNKNOWN_LOCATION);\n \t  tree label = create_artificial_label (loc);\n \t  tree c = build_case_label (NULL_TREE, NULL_TREE, label);\n \t  append_to_statement_list (c, &stmt_list);\n@@ -2309,7 +2283,7 @@ Gcc_backend::switch_statement (Bfunction *function, tree value,\n \n       if (*ps != NULL)\n \t{\n-\t  tree t = (*ps)->get_tree ();\n+\t  tree t = (*ps);\n \t  if (t == error_mark_node)\n \t    return this->error_statement ();\n \t  append_to_statement_list (t, &stmt_list);\n@@ -2322,20 +2296,20 @@ Gcc_backend::switch_statement (Bfunction *function, tree value,\n     return this->error_statement ();\n   tree t = build2_loc (switch_location.gcc_location (), SWITCH_EXPR, NULL_TREE,\n \t\t       tv, stmt_list);\n-  return this->make_statement (t);\n+  return t;\n }\n \n // Pair of statements.\n \n-Bstatement *\n-Gcc_backend::compound_statement (Bstatement *s1, Bstatement *s2)\n+tree\n+Gcc_backend::compound_statement (tree s1, tree s2)\n {\n   tree stmt_list = NULL_TREE;\n-  tree t = s1->get_tree ();\n+  tree t = s1;\n   if (t == error_mark_node)\n     return this->error_statement ();\n   append_to_statement_list (t, &stmt_list);\n-  t = s2->get_tree ();\n+  t = s2;\n   if (t == error_mark_node)\n     return this->error_statement ();\n   append_to_statement_list (t, &stmt_list);\n@@ -2345,24 +2319,24 @@ Gcc_backend::compound_statement (Bstatement *s1, Bstatement *s2)\n   if (stmt_list == NULL_TREE)\n     stmt_list = integer_zero_node;\n \n-  return this->make_statement (stmt_list);\n+  return stmt_list;\n }\n \n // List of statements.\n \n-Bstatement *\n-Gcc_backend::statement_list (const std::vector<Bstatement *> &statements)\n+tree\n+Gcc_backend::statement_list (const std::vector<tree> &statements)\n {\n   tree stmt_list = NULL_TREE;\n-  for (std::vector<Bstatement *>::const_iterator p = statements.begin ();\n+  for (std::vector<tree>::const_iterator p = statements.begin ();\n        p != statements.end (); ++p)\n     {\n-      tree t = (*p)->get_tree ();\n+      tree t = (*p);\n       if (t == error_mark_node)\n \treturn this->error_statement ();\n       append_to_statement_list (t, &stmt_list);\n     }\n-  return this->make_statement (stmt_list);\n+  return stmt_list;\n }\n \n // Make a block.  For some reason gcc uses a dual structure for\n@@ -2436,13 +2410,13 @@ Gcc_backend::block (Bfunction *function, Bblock *enclosing,\n \n void\n Gcc_backend::block_add_statements (Bblock *bblock,\n-\t\t\t\t   const std::vector<Bstatement *> &statements)\n+\t\t\t\t   const std::vector<tree> &statements)\n {\n   tree stmt_list = NULL_TREE;\n-  for (std::vector<Bstatement *>::const_iterator p = statements.begin ();\n+  for (std::vector<tree>::const_iterator p = statements.begin ();\n        p != statements.end (); ++p)\n     {\n-      tree s = (*p)->get_tree ();\n+      tree s = (*p);\n       if (s != error_mark_node)\n \tappend_to_statement_list (s, &stmt_list);\n     }\n@@ -2454,12 +2428,12 @@ Gcc_backend::block_add_statements (Bblock *bblock,\n \n // Return a block as a statement.\n \n-Bstatement *\n+tree\n Gcc_backend::block_statement (Bblock *bblock)\n {\n   tree bind_tree = bblock->get_tree ();\n   gcc_assert (TREE_CODE (bind_tree) == BIND_EXPR);\n-  return this->make_statement (bind_tree);\n+  return bind_tree;\n }\n \n // This is not static because we declare it with GTY(()) in rust-c.h.\n@@ -2706,7 +2680,7 @@ Bvariable *\n Gcc_backend::temporary_variable (Bfunction *function, Bblock *bblock,\n \t\t\t\t tree type_tree, tree init_tree,\n \t\t\t\t bool is_address_taken, Location location,\n-\t\t\t\t Bstatement **pstatement)\n+\t\t\t\t tree *pstatement)\n {\n   gcc_assert (function != NULL);\n   tree decl = function->get_tree ();\n@@ -2756,8 +2730,8 @@ Gcc_backend::temporary_variable (Bfunction *function, Bblock *bblock,\n   if (is_address_taken)\n     TREE_ADDRESSABLE (var) = 1;\n \n-  *pstatement = this->make_statement (\n-    build1_loc (location.gcc_location (), DECL_EXPR, void_type_node, var));\n+  *pstatement\n+    = build1_loc (location.gcc_location (), DECL_EXPR, void_type_node, var);\n \n   // For a zero sized type, don't initialize VAR with BINIT, but still\n   // evaluate BINIT for its side effects.\n@@ -3004,24 +2978,22 @@ Gcc_backend::label (Bfunction *function, const std::string &name,\n \n // Make a statement which defines a label.\n \n-Bstatement *\n+tree\n Gcc_backend::label_definition_statement (Blabel *label)\n {\n   tree lab = label->get_tree ();\n-  tree ret = fold_build1_loc (DECL_SOURCE_LOCATION (lab), LABEL_EXPR,\n-\t\t\t      void_type_node, lab);\n-  return this->make_statement (ret);\n+  return fold_build1_loc (DECL_SOURCE_LOCATION (lab), LABEL_EXPR,\n+\t\t\t  void_type_node, lab);\n }\n \n // Make a goto statement.\n \n-Bstatement *\n+tree\n Gcc_backend::goto_statement (Blabel *label, Location location)\n {\n   tree lab = label->get_tree ();\n-  tree ret = fold_build1_loc (location.gcc_location (), GOTO_EXPR,\n-\t\t\t      void_type_node, lab);\n-  return this->make_statement (ret);\n+  return fold_build1_loc (location.gcc_location (), GOTO_EXPR, void_type_node,\n+\t\t\t  lab);\n }\n \n // Get the address of a label.\n@@ -3097,7 +3069,7 @@ Gcc_backend::function (tree functype, const std::string &name,\n //   finish:\n //     try { UNDEFER; } catch { CHECK_DEFER; goto finish; }\n \n-Bstatement *\n+tree\n Gcc_backend::function_defer_statement (Bfunction *function, tree undefer_tree,\n \t\t\t\t       tree defer_tree, Location location)\n {\n@@ -3114,19 +3086,19 @@ Gcc_backend::function_defer_statement (Bfunction *function, tree undefer_tree,\n \n   tree stmt_list = NULL;\n   Blabel *blabel = this->label (function, \"\", location);\n-  Bstatement *label_def = this->label_definition_statement (blabel);\n-  append_to_statement_list (label_def->get_tree (), &stmt_list);\n+  tree label_def = this->label_definition_statement (blabel);\n+  append_to_statement_list (label_def, &stmt_list);\n \n-  Bstatement *jump_stmt = this->goto_statement (blabel, location);\n-  tree jump = jump_stmt->get_tree ();\n-  tree catch_body = build2 (COMPOUND_EXPR, void_type_node, defer_tree, jump);\n+  tree jump_stmt = this->goto_statement (blabel, location);\n+  tree catch_body\n+    = build2 (COMPOUND_EXPR, void_type_node, defer_tree, jump_stmt);\n   catch_body = build2 (CATCH_EXPR, void_type_node, NULL, catch_body);\n   tree try_catch\n     = build2 (TRY_CATCH_EXPR, void_type_node, undefer_tree, catch_body);\n   append_to_statement_list (try_catch, &stmt_list);\n   pop_cfun ();\n \n-  return this->make_statement (stmt_list);\n+  return stmt_list;\n }\n \n // Record PARAM_VARS as the variables to use for the parameters of FUNCTION.\n@@ -3157,14 +3129,13 @@ Gcc_backend::function_set_parameters (\n // Set the function body for FUNCTION using the code in CODE_BLOCK.\n \n bool\n-Gcc_backend::function_set_body (Bfunction *function, Bstatement *code_stmt)\n+Gcc_backend::function_set_body (Bfunction *function, tree code_stmt)\n {\n   tree func_tree = function->get_tree ();\n-  tree code = code_stmt->get_tree ();\n \n-  if (func_tree == error_mark_node || code == error_mark_node)\n+  if (func_tree == error_mark_node || code_stmt == error_mark_node)\n     return false;\n-  DECL_SAVED_TREE (func_tree) = code;\n+  DECL_SAVED_TREE (func_tree) = code_stmt;\n   return true;\n }\n "}]}