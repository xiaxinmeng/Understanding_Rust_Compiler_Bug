{"sha": "279f3eb50bc5e442683a3a4dd7cc45f04e3cb2fd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjc5ZjNlYjUwYmM1ZTQ0MjY4M2EzYTRkZDdjYzQ1ZjA0ZTNjYjJmZA==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2006-10-22T20:11:09Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2006-10-22T20:11:09Z"}, "message": "re PR tree-optimization/15911 (VRP/DOM does not like TRUTH_AND_EXPR)\n\n2006-10-22  Jeff Law  <law@redhat.com>\n\tRichard Guenther  <rguenther@suse.de>\n\n\tPR tree-optimization/15911\n\t* tree-vrp.c (extract_code_and_val_from_cond): New function.\n\t(register_edge_assert_for_1): Likewise.\n\t(register_edge_assert_for): Handle &&/&/||/| in conditionals.\n\t(find_conditional_asserts): Adjust for new function signature.\n\t(find_assert_locations): Likewise.\n\n\t* gcc.dg/tree-ssa/vrp30.c: New testcase.\n\nCo-Authored-By: Richard Guenther <rguenther@suse.de>\n\nFrom-SVN: r117960", "tree": {"sha": "8695afab2bc8d1fcab73a86cb9eadef594bd4121", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8695afab2bc8d1fcab73a86cb9eadef594bd4121"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/279f3eb50bc5e442683a3a4dd7cc45f04e3cb2fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/279f3eb50bc5e442683a3a4dd7cc45f04e3cb2fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/279f3eb50bc5e442683a3a4dd7cc45f04e3cb2fd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/279f3eb50bc5e442683a3a4dd7cc45f04e3cb2fd/comments", "author": null, "committer": null, "parents": [{"sha": "c0546edb9deed301073a96fd543ee03d40f911d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0546edb9deed301073a96fd543ee03d40f911d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c0546edb9deed301073a96fd543ee03d40f911d5"}], "stats": {"total": 370, "additions": 289, "deletions": 81}, "files": [{"sha": "85fde5deff907f3b5817c2af30fe6bb3fcbb7e4a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/279f3eb50bc5e442683a3a4dd7cc45f04e3cb2fd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/279f3eb50bc5e442683a3a4dd7cc45f04e3cb2fd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=279f3eb50bc5e442683a3a4dd7cc45f04e3cb2fd", "patch": "@@ -1,3 +1,13 @@\n+2006-10-22  Jeff Law  <law@redhat.com>\n+\tRichard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/15911\n+\t* tree-vrp.c (extract_code_and_val_from_cond): New function.\n+\t(register_edge_assert_for_1): Likewise.\n+\t(register_edge_assert_for): Handle &&/&/||/| in conditionals.\n+\t(find_conditional_asserts): Adjust for new function signature.\n+\t(find_assert_locations): Likewise.\n+\n 2006-10-22  H.J. Lu  <hongjiu.lu@intel.com>\n \n \t* config/i386/tmmintrin.h: Remove the duplicated content."}, {"sha": "860107e23388e58741469e4190f9ff32babf696b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/279f3eb50bc5e442683a3a4dd7cc45f04e3cb2fd/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/279f3eb50bc5e442683a3a4dd7cc45f04e3cb2fd/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=279f3eb50bc5e442683a3a4dd7cc45f04e3cb2fd", "patch": "@@ -1,3 +1,9 @@\n+2006-10-22  Jeff Law  <law@redhat.com>\n+\tRichard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/15911\n+\t* gcc.dg/tree-ssa/vrp30.c: New testcase.\n+\n 2006-10-22  Nathan Sidwell  <nathan@codesourcery.com>\n \n \tPR c++/20647"}, {"sha": "245dcfb74c50bbac1ca3f6fdde88fbdb37724250", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp30.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/279f3eb50bc5e442683a3a4dd7cc45f04e3cb2fd/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp30.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/279f3eb50bc5e442683a3a4dd7cc45f04e3cb2fd/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp30.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp30.c?ref=279f3eb50bc5e442683a3a4dd7cc45f04e3cb2fd", "patch": "@@ -0,0 +1,30 @@\n+/* { dg-do link } */\n+/* { dg-options \"-O2\" } */\n+\n+extern int link_error (int);\n+\n+int tst2 (int x, int y)\n+{\n+  /* VRP should be able to extract range information for\n+     x and y out of this TRUTH_AND_EXPR.  */\n+  if ((x > 5555) && (y < 6666))\n+    {\n+      if (x > 5555)\n+        if (y < 6666)\n+          return 1111;\n+        else\n+          return link_error (2222);\n+      else\n+        if (y < 6666)\n+          return link_error (3333);\n+        else\n+          return link_error (4444);\n+    }\n+  else\n+    return 0;\n+}\n+\n+int main()\n+{\n+  return 0;\n+}"}, {"sha": "6d220fbc7174a105af0aabd1bde5534f502edafd", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 243, "deletions": 81, "changes": 324, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/279f3eb50bc5e442683a3a4dd7cc45f04e3cb2fd/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/279f3eb50bc5e442683a3a4dd7cc45f04e3cb2fd/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=279f3eb50bc5e442683a3a4dd7cc45f04e3cb2fd", "patch": "@@ -2688,127 +2688,288 @@ register_new_assert_for (tree name,\n   bitmap_set_bit (need_assert_for, SSA_NAME_VERSION (name));\n }\n \n+/* COND is a predicate which uses NAME.  Extract a suitable test code\n+   and value and store them into *CODE_P and *VAL_P so the predicate\n+   is normalized to NAME *CODE_P *VAL_P.\n \n-/* Try to register an edge assertion for SSA name NAME on edge E for\n-   the conditional jump pointed to by SI.  Return true if an assertion\n-   for NAME could be registered.  */\n+   If no extraction was possible, return FALSE, otherwise return TRUE.\n+\n+   If INVERT is true, then we invert the result stored into *CODE_P.  */\n \n static bool\n-register_edge_assert_for (tree name, edge e, block_stmt_iterator si)\n+extract_code_and_val_from_cond (tree name, tree cond, bool invert,\n+\t\t\t\tenum tree_code *code_p, tree *val_p)\n {\n-  tree val, stmt;\n   enum tree_code comp_code;\n+  tree val;\n+\n+  /* Predicates may be a single SSA name or NAME OP VAL.  */\n+  if (cond == name)\n+    {\n+      /* If the predicate is a name, it must be NAME, in which\n+\t case we create the predicate NAME == true or\n+\t NAME == false accordingly.  */\n+      comp_code = EQ_EXPR;\n+      val = invert ? boolean_false_node : boolean_true_node;\n+    }\n+  else\n+    {\n+      /* Otherwise, we have a comparison of the form NAME COMP VAL\n+         or VAL COMP NAME.  */\n+      if (name == TREE_OPERAND (cond, 1))\n+        {\n+\t  /* If the predicate is of the form VAL COMP NAME, flip\n+\t     COMP around because we need to register NAME as the\n+\t     first operand in the predicate.  */\n+\t  comp_code = swap_tree_comparison (TREE_CODE (cond));\n+\t  val = TREE_OPERAND (cond, 0);\n+\t}\n+      else\n+\t{\n+\t  /* The comparison is of the form NAME COMP VAL, so the\n+\t     comparison code remains unchanged.  */\n+\t  comp_code = TREE_CODE (cond);\n+\t  val = TREE_OPERAND (cond, 1);\n+\t}\n+\n+      /* Invert the comparison code as necessary.  */\n+      if (invert)\n+\tcomp_code = invert_tree_comparison (comp_code, 0);\n+\n+      /* VRP does not handle float types.  */\n+      if (SCALAR_FLOAT_TYPE_P (TREE_TYPE (val)))\n+\treturn false;\n+\n+      /* Do not register always-false predicates.\n+\t FIXME:  this works around a limitation in fold() when dealing with\n+\t enumerations.  Given 'enum { N1, N2 } x;', fold will not\n+\t fold 'if (x > N2)' to 'if (0)'.  */\n+      if ((comp_code == GT_EXPR || comp_code == LT_EXPR)\n+\t  && INTEGRAL_TYPE_P (TREE_TYPE (val)))\n+\t{\n+\t  tree min = TYPE_MIN_VALUE (TREE_TYPE (val));\n+\t  tree max = TYPE_MAX_VALUE (TREE_TYPE (val));\n+\n+\t  if (comp_code == GT_EXPR\n+\t      && (!max\n+\t          || compare_values (val, max) == 0))\n+\t    return false;\n+\n+\t  if (comp_code == LT_EXPR\n+\t      && (!min\n+\t          || compare_values (val, min) == 0))\n+\t    return false;\n+\t}\n+    }\n+  *code_p = comp_code;\n+  *val_p = val;\n+  return true;\n+}\n \n-  stmt = bsi_stmt (si);\n+/* OP is an operand of a truth value expression which is known to have\n+   a particular value.  Register any asserts for OP and for any\n+   operands in OP's defining statement. \n+\n+   If CODE is EQ_EXPR, then we want to register OP is zero (false),\n+   if CODE is NE_EXPR, then we want to register OP is nonzero (true).   */\n+\n+static bool\n+register_edge_assert_for_1 (tree op, enum tree_code code,\n+\t\t\t    edge e, block_stmt_iterator bsi)\n+{\n+  bool invert, retval = false;\n+  tree op_def, rhs, val;\n+\n+  /* We only care about SSA_NAMEs.  */\n+  if (TREE_CODE (op) != SSA_NAME)\n+    return false;\n+\n+  /* We know that OP will have a zero or nonzero value.  If OP is used\n+     more than once go ahead and register an assert for OP. \n+\n+     The FOUND_IN_SUBGRAPH support is not helpful in this situation as\n+     it will always be set for OP (because OP is used in a COND_EXPR in\n+     the subgraph).  */\n+  if (!has_single_use (op))\n+    {\n+      val = build_int_cst (TREE_TYPE (op), 0);\n+      register_new_assert_for (op, code, val, NULL, e, bsi);\n+      retval = true;\n+    }\n+\n+  /* Now look at how OP is set.  If it's set from a comparison,\n+     a truth operation or some bit operations, then we may be able\n+     to register information about the operands of that assignment.  */\n+  op_def = SSA_NAME_DEF_STMT (op);\n+  if (TREE_CODE (op_def) != MODIFY_EXPR)\n+    return retval;\n+\n+  invert = (code == EQ_EXPR ? true : false);\n+  rhs = TREE_OPERAND (op_def, 1);\n+\n+  if (COMPARISON_CLASS_P (rhs))\n+    {\n+      tree op0 = TREE_OPERAND (rhs, 0);\n+      tree op1 = TREE_OPERAND (rhs, 1);\n+\n+      /* Conditionally register an assert for each SSA_NAME in the\n+\t comparison.  */\n+      if (TREE_CODE (op0) == SSA_NAME\n+\t  && !has_single_use (op0)\n+\t  && extract_code_and_val_from_cond (op0, rhs,\n+\t\t\t\t\t     invert, &code, &val))\n+\t{\n+\t  register_new_assert_for (op0, code, val, NULL, e, bsi);\n+\t  retval = true;\n+\t}\n+\n+      /* Similarly for the second operand of the comparison.  */\n+      if (TREE_CODE (op1) == SSA_NAME\n+\t  && !has_single_use (op1)\n+\t  && extract_code_and_val_from_cond (op1, rhs,\n+\t\t\t\t\t     invert, &code, &val))\n+\t{\n+\t  register_new_assert_for (op1, code, val, NULL, e, bsi);\n+\t  retval = true;\n+\t}\n+    }\n+  else if ((code == NE_EXPR\n+\t    && (TREE_CODE (rhs) == TRUTH_AND_EXPR\n+\t\t|| TREE_CODE (rhs) == BIT_AND_EXPR))\n+\t   || (code == EQ_EXPR\n+\t       && (TREE_CODE (rhs) == TRUTH_OR_EXPR\n+\t\t   || TREE_CODE (rhs) == BIT_IOR_EXPR)))\n+    {\n+      /* Recurse on each operand.  */\n+      retval |= register_edge_assert_for_1 (TREE_OPERAND (rhs, 0),\n+\t\t\t\t\t    code, e, bsi);\n+      retval |= register_edge_assert_for_1 (TREE_OPERAND (rhs, 1),\n+\t\t\t\t\t    code, e, bsi);\n+    }\n+  else if (TREE_CODE (rhs) == TRUTH_NOT_EXPR)\n+    {\n+      invert = !invert;\n+      /* Recurse, flipping the tense of INVERT.  */\n+      retval |= register_edge_assert_for_1 (TREE_OPERAND (rhs, 0),\n+\t\t\t\t\t    invert, e, bsi);\n+    }\n+  else if (TREE_CODE (rhs) == SSA_NAME)\n+    {\n+      /* Recurse through the copy, the tense of INVERT remains\n+\t unchanged.  */\n+      retval |= register_edge_assert_for_1 (rhs, code, e, bsi);\n+    }\n+  else if (TREE_CODE (rhs) == NOP_EXPR\n+\t   || TREE_CODE (rhs) == CONVERT_EXPR\n+\t   || TREE_CODE (rhs) == VIEW_CONVERT_EXPR\n+\t   || TREE_CODE (rhs) == NON_LVALUE_EXPR)\n+    { \n+      /* Recurse through the type conversion, the tense of INVERT \n+\t remains unchanged.  */\n+      retval |= register_edge_assert_for_1 (TREE_OPERAND (rhs, 0),\n+\t\t\t\t\t    code, e, bsi);\n+    }\n+\n+  return retval;\n+}\n+\n+/* Try to register an edge assertion for SSA name NAME on edge E for\n+   the condition COND contributing to the conditional jump pointed to by SI.\n+   Return true if an assertion for NAME could be registered.  */\n+\n+static bool\n+register_edge_assert_for (tree name, edge e, block_stmt_iterator si, tree cond)\n+{\n+  tree val;\n+  enum tree_code comp_code;\n+  bool retval = false;\n+  bool is_else_edge = (e->flags & EDGE_FALSE_VALUE) != 0;\n \n   /* Do not attempt to infer anything in names that flow through\n      abnormal edges.  */\n   if (SSA_NAME_OCCURS_IN_ABNORMAL_PHI (name))\n     return false;\n \n-  /* If NAME was not found in the sub-graph reachable from E, then\n-     there's nothing to do.  */\n-  if (!TEST_BIT (found_in_subgraph, SSA_NAME_VERSION (name)))\n+  if (!extract_code_and_val_from_cond (name, cond, is_else_edge,\n+\t\t\t\t       &comp_code, &val))\n     return false;\n \n-  /* We found a use of NAME in the sub-graph rooted at E->DEST.\n-     Register an assertion for NAME according to the value that NAME\n-     takes on edge E.  */\n-  if (TREE_CODE (stmt) == COND_EXPR)\n+  /* Only register an ASSERT_EXPR if NAME was found in the sub-graph\n+     reachable from E.  */\n+  if (TEST_BIT (found_in_subgraph, SSA_NAME_VERSION (name)))\n     {\n-      /* If BB ends in a COND_EXPR then NAME then we should insert\n-\t the original predicate on EDGE_TRUE_VALUE and the\n-\t opposite predicate on EDGE_FALSE_VALUE.  */\n-      tree cond = COND_EXPR_COND (stmt);\n-      bool is_else_edge = (e->flags & EDGE_FALSE_VALUE) != 0;\n-\n-      /* Predicates may be a single SSA name or NAME OP VAL.  */\n-      if (cond == name)\n-\t{\n-\t  /* If the predicate is a name, it must be NAME, in which\n-\t     case we create the predicate NAME == true or\n-\t     NAME == false accordingly.  */\n-\t  comp_code = EQ_EXPR;\n-\t  val = (is_else_edge) ? boolean_false_node : boolean_true_node;\n-\t}\n-      else\n-\t{\n-\t  /* Otherwise, we have a comparison of the form NAME COMP VAL\n-\t     or VAL COMP NAME.  */\n-\t  if (name == TREE_OPERAND (cond, 1))\n-\t    {\n-\t      /* If the predicate is of the form VAL COMP NAME, flip\n-\t\t COMP around because we need to register NAME as the\n-\t\t first operand in the predicate.  */\n-\t      comp_code = swap_tree_comparison (TREE_CODE (cond));\n-\t      val = TREE_OPERAND (cond, 0);\n-\t    }\n-\t  else\n-\t    {\n-\t      /* The comparison is of the form NAME COMP VAL, so the\n-\t\t comparison code remains unchanged.  */\n-\t      comp_code = TREE_CODE (cond);\n-\t      val = TREE_OPERAND (cond, 1);\n-\t    }\n+      register_new_assert_for (name, comp_code, val, NULL, e, si);\n+      retval = true;\n+    }\n \n-\t  /* If we are inserting the assertion on the ELSE edge, we\n-\t     need to invert the sign comparison.  */\n-\t  if (is_else_edge)\n-\t    comp_code = invert_tree_comparison (comp_code, 0);\n-\n-\t  /* Do not register always-false predicates.  FIXME, this\n-\t     works around a limitation in fold() when dealing with\n-\t     enumerations.  Given 'enum { N1, N2 } x;', fold will not\n-\t     fold 'if (x > N2)' to 'if (0)'.  */\n-\t  if ((comp_code == GT_EXPR || comp_code == LT_EXPR)\n-\t      && (INTEGRAL_TYPE_P (TREE_TYPE (val))\n-\t\t  || SCALAR_FLOAT_TYPE_P (TREE_TYPE (val))))\n-\t    {\n-\t      tree min = TYPE_MIN_VALUE (TREE_TYPE (val));\n-\t      tree max = TYPE_MAX_VALUE (TREE_TYPE (val));\n+  /* If COND is effectively an equality test of an SSA_NAME against\n+     the value zero or one, then we may be able to assert values\n+     for SSA_NAMEs which flow into COND.  */\n \n-\t      if (comp_code == GT_EXPR && compare_values (val, max) == 0)\n-\t\treturn false;\n+  /* In the case of NAME == 1 or NAME != 0, for TRUTH_AND_EXPR defining\n+     statement of NAME we can assert both operands of the TRUTH_AND_EXPR\n+     have non-zero value.  */\n+  if (((comp_code == EQ_EXPR && integer_onep (val))\n+       || (comp_code == NE_EXPR && integer_zerop (val))))\n+    {\n+      tree def_stmt = SSA_NAME_DEF_STMT (name);\n \n-\t      if (comp_code == LT_EXPR && compare_values (val, min) == 0)\n-\t\treturn false;\n-\t    }\n+      if (TREE_CODE (def_stmt) == MODIFY_EXPR\n+\t  && (TREE_CODE (TREE_OPERAND (def_stmt, 1)) == TRUTH_AND_EXPR\n+\t      || TREE_CODE (TREE_OPERAND (def_stmt, 1)) == BIT_AND_EXPR))\n+\t{\n+\t  tree op0 = TREE_OPERAND (TREE_OPERAND (def_stmt, 1), 0);\n+\t  tree op1 = TREE_OPERAND (TREE_OPERAND (def_stmt, 1), 1);\n+\t  retval |= register_edge_assert_for_1 (op0, NE_EXPR, e, si);\n+\t  retval |= register_edge_assert_for_1 (op1, NE_EXPR, e, si);\n \t}\n     }\n-  else\n+\n+  /* In the case of NAME == 0 or NAME != 1, for TRUTH_OR_EXPR defining\n+     statement of NAME we can assert both operands of the TRUTH_OR_EXPR\n+     have zero value.  */\n+  if (((comp_code == EQ_EXPR && integer_zerop (val))\n+       || (comp_code == NE_EXPR && integer_onep (val))))\n     {\n-      /* FIXME.  Handle SWITCH_EXPR.  */\n-      gcc_unreachable ();\n+      tree def_stmt = SSA_NAME_DEF_STMT (name);\n+\n+      if (TREE_CODE (def_stmt) == MODIFY_EXPR\n+\t  && (TREE_CODE (TREE_OPERAND (def_stmt, 1)) == TRUTH_OR_EXPR\n+\t      || TREE_CODE (TREE_OPERAND (def_stmt, 1)) == BIT_IOR_EXPR))\n+\t{\n+\t  tree op0 = TREE_OPERAND (TREE_OPERAND (def_stmt, 1), 0);\n+\t  tree op1 = TREE_OPERAND (TREE_OPERAND (def_stmt, 1), 1);\n+\t  retval |= register_edge_assert_for_1 (op0, EQ_EXPR, e, si);\n+\t  retval |= register_edge_assert_for_1 (op1, EQ_EXPR, e, si);\n+\t}\n     }\n \n-  register_new_assert_for (name, comp_code, val, NULL, e, si);\n-  return true;\n+  return retval;\n }\n \n \n static bool find_assert_locations (basic_block bb);\n \n /* Determine whether the outgoing edges of BB should receive an\n-   ASSERT_EXPR for each of the operands of BB's last statement.  The\n-   last statement of BB must be a COND_EXPR or a SWITCH_EXPR.\n+   ASSERT_EXPR for each of the operands of BB's LAST statement.\n+   The last statement of BB must be a COND_EXPR or a SWITCH_EXPR.\n \n    If any of the sub-graphs rooted at BB have an interesting use of\n    the predicate operands, an assert location node is added to the\n    list of assertions for the corresponding operands.  */\n \n static bool\n-find_conditional_asserts (basic_block bb)\n+find_conditional_asserts (basic_block bb, tree last)\n {\n   bool need_assert;\n-  block_stmt_iterator last_si;\n-  tree op, last;\n+  block_stmt_iterator bsi;\n+  tree op;\n   edge_iterator ei;\n   edge e;\n   ssa_op_iter iter;\n \n   need_assert = false;\n-  last_si = bsi_last (bb);\n-  last = bsi_stmt (last_si);\n+  bsi = bsi_for_stmt (last);\n \n   /* Look for uses of the operands in each of the sub-graphs\n      rooted at BB.  We need to check each of the outgoing edges\n@@ -2852,7 +3013,8 @@ find_conditional_asserts (basic_block bb)\n       /* Register the necessary assertions for each operand in the\n \t conditional predicate.  */\n       FOR_EACH_SSA_TREE_OPERAND (op, last, iter, SSA_OP_USE)\n-\tneed_assert |= register_edge_assert_for (op, e, last_si);\n+\tneed_assert |= register_edge_assert_for (op, e, bsi,\n+\t\t\t\t\t\t COND_EXPR_COND (last));\n     }\n \n   /* Finally, indicate that we have found the operands in the\n@@ -3042,7 +3204,7 @@ find_assert_locations (basic_block bb)\n       && TREE_CODE (last) == COND_EXPR\n       && !fp_predicate (COND_EXPR_COND (last))\n       && !ZERO_SSA_OPERANDS (last, SSA_OP_USE))\n-    need_assert |= find_conditional_asserts (bb);\n+    need_assert |= find_conditional_asserts (bb, last);\n \n   /* Recurse into the dominator children of BB.  */\n   for (son = first_dom_son (CDI_DOMINATORS, bb);"}]}