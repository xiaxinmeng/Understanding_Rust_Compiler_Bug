{"sha": "897b3b31f0a94b8bac59c6061655c6a32646d0a0", "node_id": "C_kwDOANBUbNoAKDg5N2IzYjMxZjBhOTRiOGJhYzU5YzYwNjE2NTVjNmEzMjY0NmQwYTA", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-07-07T19:50:26Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-07-07T19:50:26Z"}, "message": "analyzer: fix false positives from -Wanalyzer-tainted-divisor [PR106225]\n\ngcc/analyzer/ChangeLog:\n\tPR analyzer/106225\n\t* sm-taint.cc (taint_state_machine::on_stmt): Move handling of\n\tassignments from division to...\n\t(taint_state_machine::check_for_tainted_divisor): ...this new\n\tfunction.  Reject warning when the divisor is known to be non-zero.\n\t* sm.cc: Include \"analyzer/program-state.h\".\n\t(sm_context::get_old_region_model): New.\n\t* sm.h (sm_context::get_old_region_model): New decl.\n\ngcc/testsuite/ChangeLog:\n\tPR analyzer/106225\n\t* gcc.dg/analyzer/taint-divisor-1.c: Add test coverage for various\n\tcorrect and incorrect checks against zero.\n\nSigned-off-by: David Malcolm <dmalcolm@redhat.com>", "tree": {"sha": "65777b219fc02057535cf09d3f199d58a259e783", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/65777b219fc02057535cf09d3f199d58a259e783"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/897b3b31f0a94b8bac59c6061655c6a32646d0a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/897b3b31f0a94b8bac59c6061655c6a32646d0a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/897b3b31f0a94b8bac59c6061655c6a32646d0a0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/897b3b31f0a94b8bac59c6061655c6a32646d0a0/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ad6135e261ced29972e5aa33404e45bcdd99440f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad6135e261ced29972e5aa33404e45bcdd99440f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad6135e261ced29972e5aa33404e45bcdd99440f"}], "stats": {"total": 131, "additions": 119, "deletions": 12}, "files": [{"sha": "4075cf6d868fcc9b6c124fd9ec9ff2ba9d5171a8", "filename": "gcc/analyzer/sm-taint.cc", "status": "modified", "additions": 39, "deletions": 12, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/897b3b31f0a94b8bac59c6061655c6a32646d0a0/gcc%2Fanalyzer%2Fsm-taint.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/897b3b31f0a94b8bac59c6061655c6a32646d0a0/gcc%2Fanalyzer%2Fsm-taint.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-taint.cc?ref=897b3b31f0a94b8bac59c6061655c6a32646d0a0", "patch": "@@ -109,6 +109,9 @@ class taint_state_machine : public state_machine\n \t\t\t\t   const supernode *node,\n \t\t\t\t   const gcall *call,\n \t\t\t\t   tree callee_fndecl) const;\n+  void check_for_tainted_divisor (sm_context *sm_ctxt,\n+\t\t\t\t  const supernode *node,\n+\t\t\t\t  const gassign *assign) const;\n \n public:\n   /* State for a \"tainted\" value: unsanitized data potentially under an\n@@ -803,18 +806,7 @@ taint_state_machine::on_stmt (sm_context *sm_ctxt,\n \tcase ROUND_MOD_EXPR:\n \tcase RDIV_EXPR:\n \tcase EXACT_DIV_EXPR:\n-\t  {\n-\t    tree divisor = gimple_assign_rhs2 (assign);;\n-\t    state_t state = sm_ctxt->get_state (stmt, divisor);\n-\t    enum bounds b;\n-\t    if (get_taint (state, TREE_TYPE (divisor), &b))\n-\t      {\n-\t\ttree diag_divisor = sm_ctxt->get_diagnostic_tree (divisor);\n-\t\tsm_ctxt->warn  (node, stmt, divisor,\n-\t\t\t\tnew tainted_divisor (*this, diag_divisor, b));\n-\t\tsm_ctxt->set_next_state (stmt, divisor, m_stop);\n-\t      }\n-\t  }\n+\t  check_for_tainted_divisor (sm_ctxt, node, assign);\n \t  break;\n \t}\n     }\n@@ -989,6 +981,41 @@ taint_state_machine::check_for_tainted_size_arg (sm_context *sm_ctxt,\n     }\n }\n \n+/* Complain if ASSIGN (a division operation) has a tainted divisor\n+   that could be zero.  */\n+\n+void\n+taint_state_machine::check_for_tainted_divisor (sm_context *sm_ctxt,\n+\t\t\t\t\t\tconst supernode *node,\n+\t\t\t\t\t\tconst gassign *assign) const\n+{\n+  const region_model *old_model = sm_ctxt->get_old_region_model ();\n+  if (!old_model)\n+    return;\n+\n+  tree divisor_expr = gimple_assign_rhs2 (assign);;\n+  const svalue *divisor_sval = old_model->get_rvalue (divisor_expr, NULL);\n+\n+  state_t state = sm_ctxt->get_state (assign, divisor_sval);\n+  enum bounds b;\n+  if (get_taint (state, TREE_TYPE (divisor_expr), &b))\n+    {\n+      const svalue *zero_sval\n+\t= old_model->get_manager ()->get_or_create_int_cst\n+\t    (TREE_TYPE (divisor_expr), 0);\n+      tristate ts\n+\t= old_model->eval_condition (divisor_sval, NE_EXPR, zero_sval);\n+      if (ts.is_true ())\n+\t/* The divisor is known to not equal 0: don't warn.  */\n+\treturn;\n+\n+      tree diag_divisor = sm_ctxt->get_diagnostic_tree (divisor_expr);\n+      sm_ctxt->warn (node, assign, divisor_expr,\n+\t\t     new tainted_divisor (*this, diag_divisor, b));\n+      sm_ctxt->set_next_state (assign, divisor_sval, m_stop);\n+    }\n+}\n+\n } // anonymous namespace\n \n /* Internal interface to this file. */"}, {"sha": "d17d5c765b46b50769848322f0b7ed5b6afe0ba7", "filename": "gcc/analyzer/sm.cc", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/897b3b31f0a94b8bac59c6061655c6a32646d0a0/gcc%2Fanalyzer%2Fsm.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/897b3b31f0a94b8bac59c6061655c6a32646d0a0/gcc%2Fanalyzer%2Fsm.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm.cc?ref=897b3b31f0a94b8bac59c6061655c6a32646d0a0", "patch": "@@ -40,6 +40,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"analyzer/program-point.h\"\n #include \"analyzer/store.h\"\n #include \"analyzer/svalue.h\"\n+#include \"analyzer/program-state.h\"\n \n #if ENABLE_ANALYZER\n \n@@ -159,6 +160,17 @@ state_machine::to_json () const\n   return sm_obj;\n }\n \n+/* class sm_context.  */\n+\n+const region_model *\n+sm_context::get_old_region_model () const\n+{\n+  if (const program_state *old_state = get_old_program_state ())\n+    return old_state->m_region_model;\n+  else\n+    return NULL;\n+}\n+\n /* Create instances of the various state machines, each using LOGGER,\n    and populate OUT with them.  */\n "}, {"sha": "353a6db53b00362c50df963935e2e6386281ef1a", "filename": "gcc/analyzer/sm.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/897b3b31f0a94b8bac59c6061655c6a32646d0a0/gcc%2Fanalyzer%2Fsm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/897b3b31f0a94b8bac59c6061655c6a32646d0a0/gcc%2Fanalyzer%2Fsm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm.h?ref=897b3b31f0a94b8bac59c6061655c6a32646d0a0", "patch": "@@ -279,6 +279,8 @@ class sm_context\n   virtual const program_state *get_old_program_state () const = 0;\n   virtual const program_state *get_new_program_state () const = 0;\n \n+  const region_model *get_old_region_model () const;\n+\n protected:\n   sm_context (int sm_idx, const state_machine &sm)\n   : m_sm_idx (sm_idx), m_sm (sm) {}"}, {"sha": "b7c1faef1c478f4dbc576098589ab1d0a8143bec", "filename": "gcc/testsuite/gcc.dg/analyzer/taint-divisor-1.c", "status": "modified", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/897b3b31f0a94b8bac59c6061655c6a32646d0a0/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftaint-divisor-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/897b3b31f0a94b8bac59c6061655c6a32646d0a0/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftaint-divisor-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftaint-divisor-1.c?ref=897b3b31f0a94b8bac59c6061655c6a32646d0a0", "patch": "@@ -24,3 +24,69 @@ int test_2 (FILE *f)\n   fread (&s, sizeof (s), 1, f);\n   return s.a % s.b;  /* { dg-warning \"use of attacker-controlled value 's\\\\.b' as divisor without checking for zero\" } */\n }\n+\n+/* We shouldn't complain if the divisor has been checked for zero.  */\n+\n+int test_checked_ne_zero (FILE *f)\n+{\n+  struct st1 s;\n+  fread (&s, sizeof (s), 1, f);\n+  if (s.b)\n+    return s.a / s.b; /* { dg-bogus \"divisor\" } */\n+  else\n+    return 0;\n+}\n+\n+int test_checked_gt_zero (FILE *f)\n+{\n+  struct st1 s;\n+  fread (&s, sizeof (s), 1, f);\n+  if (s.b > 0)\n+    return s.a / s.b; /* { dg-bogus \"divisor\" } */\n+  else\n+    return 0;\n+}\n+\n+int test_checked_lt_zero (FILE *f)\n+{\n+  struct st1 s;\n+  fread (&s, sizeof (s), 1, f);\n+  if (s.b < 0)\n+    return s.a / s.b; /* { dg-bogus \"divisor\" } */\n+  else\n+    return 0;\n+}\n+\n+/* We should complain if the check on the divisor still allows it to be\n+   zero.  */\n+\n+int test_checked_ge_zero (FILE *f)\n+{\n+  struct st1 s;\n+  fread (&s, sizeof (s), 1, f);\n+  if (s.b >= 0)\n+    return s.a / s.b;  /* { dg-warning \"use of attacker-controlled value 's\\\\.b' as divisor without checking for zero\" } */\n+  else\n+    return 0;\n+}\n+\n+int test_checked_le_zero (FILE *f)\n+{\n+  struct st1 s;\n+  fread (&s, sizeof (s), 1, f);\n+  if (s.b <= 0)\n+    return s.a / s.b;  /* { dg-warning \"use of attacker-controlled value 's\\\\.b' as divisor without checking for zero\" } */\n+  else\n+    return 0;\n+}\n+\n+int test_checked_eq_zero (FILE *f)\n+{\n+  struct st1 s;\n+  fread (&s, sizeof (s), 1, f);\n+  /* Wrong sense of test.  */\n+  if (s.b != 0)\n+    return 0;\n+  else\n+    return s.a / s.b;  /* { dg-warning \"use of attacker-controlled value 's\\\\.b' as divisor without checking for zero\" } */\n+}"}]}