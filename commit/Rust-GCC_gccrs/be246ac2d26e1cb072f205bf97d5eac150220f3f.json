{"sha": "be246ac2d26e1cb072f205bf97d5eac150220f3f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmUyNDZhYzJkMjZlMWNiMDcyZjIwNWJmOTdkNWVhYzE1MDIyMGYzZg==", "commit": {"author": {"name": "Anthony Sharp", "email": "anthonysharp15@gmail.com", "date": "2021-03-10T20:36:03Z"}, "committer": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2021-03-17T23:11:02Z"}, "message": "c++: Private parent access check for using decls [PR19377]\n\nThis bug was already mostly fixed by the patch for PR17314. This\npatch continues that by ensuring that where a using decl is used,\ncausing an access failure to a child class because the using decl is\nprivate, the compiler correctly points to the using decl as the\nsource of the problem.\n\ngcc/cp/ChangeLog:\n\n2021-03-10  Anthony Sharp  <anthonysharp15@gmail.com>\n\n\t* semantics.c (get_class_access_diagnostic_decl): New\n\tfunction that examines special cases when a parent\n\tclass causes a private access failure.\n\t(enforce_access): Slightly modified to call function\n\tabove.\n\ngcc/testsuite/ChangeLog:\n\n2021-03-10  Anthony Sharp  <anthonysharp15@gmail.com>\n\n\t* g++.dg/cpp1z/using9.C: New using decl test.\n\nCo-authored-by: Jason Merrill <jason@redhat.com>", "tree": {"sha": "346b3e5f33583fc9fcbfb848de10fe0284e0d47c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/346b3e5f33583fc9fcbfb848de10fe0284e0d47c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/be246ac2d26e1cb072f205bf97d5eac150220f3f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be246ac2d26e1cb072f205bf97d5eac150220f3f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be246ac2d26e1cb072f205bf97d5eac150220f3f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be246ac2d26e1cb072f205bf97d5eac150220f3f/comments", "author": {"login": "anthonysharpy", "id": 55365296, "node_id": "MDQ6VXNlcjU1MzY1Mjk2", "avatar_url": "https://avatars.githubusercontent.com/u/55365296?v=4", "gravatar_id": "", "url": "https://api.github.com/users/anthonysharpy", "html_url": "https://github.com/anthonysharpy", "followers_url": "https://api.github.com/users/anthonysharpy/followers", "following_url": "https://api.github.com/users/anthonysharpy/following{/other_user}", "gists_url": "https://api.github.com/users/anthonysharpy/gists{/gist_id}", "starred_url": "https://api.github.com/users/anthonysharpy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/anthonysharpy/subscriptions", "organizations_url": "https://api.github.com/users/anthonysharpy/orgs", "repos_url": "https://api.github.com/users/anthonysharpy/repos", "events_url": "https://api.github.com/users/anthonysharpy/events{/privacy}", "received_events_url": "https://api.github.com/users/anthonysharpy/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5074c6fa38cef1abb9a355d717b41441a44c4e6a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5074c6fa38cef1abb9a355d717b41441a44c4e6a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5074c6fa38cef1abb9a355d717b41441a44c4e6a"}], "stats": {"total": 150, "additions": 132, "deletions": 18}, "files": [{"sha": "b02596f73bd1bbc22d9f5088b30006a5c2895e30", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 83, "deletions": 18, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be246ac2d26e1cb072f205bf97d5eac150220f3f/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be246ac2d26e1cb072f205bf97d5eac150220f3f/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=be246ac2d26e1cb072f205bf97d5eac150220f3f", "patch": "@@ -256,6 +256,72 @@ pop_to_parent_deferring_access_checks (void)\n     }\n }\n \n+/* Called from enforce_access.  A class has attempted (but failed) to access\n+   DECL.  It is already established that a baseclass of that class,\n+   PARENT_BINFO, has private access to DECL.  Examine certain special cases\n+   to find a decl that accurately describes the source of the problem.  If\n+   none of the special cases apply, simply return DECL as the source of the\n+   problem.  */\n+\n+static tree\n+get_class_access_diagnostic_decl (tree parent_binfo, tree decl)\n+{\n+  /* When a class is denied access to a decl in a baseclass, most of the\n+     time it is because the decl itself was declared as private at the point\n+     of declaration.\n+\n+     However, in C++, there are (at least) two situations in which a decl\n+     can be private even though it was not originally defined as such.\n+     These two situations only apply if a baseclass had private access to\n+     DECL (this function is only called if that is the case).  */\n+\n+  /* We should first check whether the reason the parent had private access\n+     to DECL was simply because DECL was created and declared as private in\n+     the parent.  If it was, then DECL is definitively the source of the\n+     problem.  */\n+  if (SAME_BINFO_TYPE_P (context_for_name_lookup (decl),\n+\t\t\t BINFO_TYPE (parent_binfo)))\n+    return decl;\n+\n+  /* 1.  If the \"using\" keyword is used to inherit DECL within the parent,\n+     this may cause DECL to be private, so we should return the using\n+     statement as the source of the problem.\n+\n+     Scan the fields of PARENT_BINFO and see if there are any using decls.  If\n+     there are, see if they inherit DECL.  If they do, that's where DECL must\n+     have been declared private.  */\n+\n+  for (tree parent_field = TYPE_FIELDS (BINFO_TYPE (parent_binfo));\n+       parent_field;\n+       parent_field = DECL_CHAIN (parent_field))\n+    /* Not necessary, but also check TREE_PRIVATE for the sake of\n+       eliminating obviously non-relevant using decls.  */\n+    if (TREE_CODE (parent_field) == USING_DECL\n+\t&& TREE_PRIVATE (parent_field))\n+      {\n+\ttree decl_stripped = strip_using_decl (parent_field);\n+\n+\t/* The using statement might be overloaded.  If so, we need to\n+\t   check all of the overloads.  */\n+\tfor (ovl_iterator iter (decl_stripped); iter; ++iter)\n+\t  /* If equal, the using statement inherits DECL, and so is the\n+\t     source of the access failure, so return it.  */\n+\t  if (*iter == decl)\n+\t    return parent_field;\n+      }\n+\n+  /* 2.  If DECL was privately inherited by the parent class, then DECL will\n+     be inaccessible, even though it may originally have been accessible to\n+     deriving classes.  In that case, the fault lies with the parent, since it\n+     used a private inheritance, so we return the parent as the source of the\n+     problem.\n+\n+     Since this is the last check, we just assume it's true.  At worst, it\n+     will simply point to the class that failed to give access, which is\n+     technically true.  */\n+  return TYPE_NAME (BINFO_TYPE (parent_binfo));\n+}\n+\n /* If the current scope isn't allowed to access DECL along\n    BASETYPE_PATH, give an error, or if we're parsing a function or class\n    template, defer the access check to be performed at instantiation time.\n@@ -317,34 +383,33 @@ enforce_access (tree basetype_path, tree decl, tree diag_decl,\n \tdiag_decl = strip_inheriting_ctors (diag_decl);\n       if (complain & tf_error)\n \t{\n-\t  /* We will usually want to point to the same place as\n-\t     diag_decl but not always.  */\n+\t  access_kind access_failure_reason = ak_none;\n+\n+\t  /* By default, using the decl as the source of the problem will\n+\t     usually give correct results.  */\n \t  tree diag_location = diag_decl;\n-\t  access_kind parent_access = ak_none;\n \n-\t  /* See if any of BASETYPE_PATH's parents had private access\n-\t     to DECL.  If they did, that will tell us why we don't.  */\n+\t  /* However, if a parent of BASETYPE_PATH had private access to decl,\n+\t     then it actually might be the case that the source of the problem\n+\t     is not DECL.  */\n \t  tree parent_binfo = get_parent_with_private_access (decl,\n \t\t\t\t\t\t\t      basetype_path);\n \n-\t  /* If a parent had private access, then the diagnostic\n-\t     location DECL should be that of the parent class, since it\n-\t     failed to give suitable access by using a private\n-\t     inheritance.  But if DECL was actually defined in the parent,\n-\t     it wasn't privately inherited, and so we don't need to do\n-\t     this, and complain_about_access will figure out what to\n-\t     do.  */\n-\t  if (parent_binfo != NULL_TREE\n-\t      && (context_for_name_lookup (decl)\n-\t\t  != BINFO_TYPE (parent_binfo)))\n+\t  /* So if a parent did have private access, then we need to do\n+\t     special checks to obtain the best diagnostic location decl.  */\n+\t  if (parent_binfo != NULL_TREE)\n \t    {\n-\t      diag_location = TYPE_NAME (BINFO_TYPE (parent_binfo));\n-\t      parent_access = ak_private;\n+\t      diag_location = get_class_access_diagnostic_decl (parent_binfo,\n+\t\t\t\t\t\t\t\tdiag_decl);\n+\n+\t      /* We also at this point know that the reason access failed was\n+\t\t because decl was private.  */\n+\t      access_failure_reason = ak_private;\n \t    }\n \n \t  /* Finally, generate an error message.  */\n \t  complain_about_access (decl, diag_decl, diag_location, true,\n-\t\t\t\t parent_access);\n+\t\t\t\t access_failure_reason);\n \t}\n       if (afi)\n \tafi->record_access_failure (basetype_path, decl, diag_decl);"}, {"sha": "98e36babb01cbec4ba550e091773df355a4c03c9", "filename": "gcc/testsuite/g++.dg/cpp1z/using9.C", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be246ac2d26e1cb072f205bf97d5eac150220f3f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fusing9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be246ac2d26e1cb072f205bf97d5eac150220f3f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fusing9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fusing9.C?ref=be246ac2d26e1cb072f205bf97d5eac150220f3f", "patch": "@@ -0,0 +1,49 @@\n+/* { dg-do compile { target c++17 } } */\n+// Created for c++ PR19377\n+\n+class A2\n+{\n+  protected:\n+  int separate(int a);\n+  int separate(int a, int b);\n+  int separate(int a, int b, int c);\n+  int comma(int a);\n+  int alone;\n+};\n+\n+class A1\n+{\n+  protected:\n+  int separate();\n+  int comma();\n+};\n+\n+class A3\n+{\n+  protected:\n+  int comma(int a, int b);\n+};\n+\n+class B:private A3, private A1, private A2\n+{\n+  // Using decls in a comma-separated list.\n+  using A2::comma, A3::comma, A1::comma;  // { dg-message \"declared\" }\n+  // Separate using statements.\n+  using A2::separate; // { dg-message \"declared\" }\n+  using A1::separate; // { dg-message \"declared\" }\n+  // No ambiguity, just for the sake of it.\n+  using A2::alone; // { dg-message \"declared\" }\n+};\n+\n+class C:public B\n+{\n+  void f()\n+  {\n+    comma(); // { dg-error \"private\" }\n+    separate(); // { dg-error \"private\" }\n+    separate(1); // { dg-error \"private\" }\n+    separate(1, 2); // { dg-error \"private\" }\n+    separate(1, 2, 3); // { dg-error \"private\" }\n+    alone = 5; // { dg-error \"private\" }\n+  }\n+};"}]}