{"sha": "56898e437a538c7edc0724a3650f5cb81c9d5721", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTY4OThlNDM3YTUzOGM3ZWRjMDcyNGEzNjUwZjVjYjgxYzlkNTcyMQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-10-14T08:05:52Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-10-14T08:05:52Z"}, "message": "[C] Avoid exposing internal details in aka types\n\nThe current aka diagnostics can sometimes leak internal details that\nseem more likely to be distracting than useful.  E.g. on aarch64:\n\n  void f (va_list *va) { *va = 1; }\n\ngives:\n\n  incompatible types when assigning to type \u2018va_list\u2019 {aka \u2018__va_list\u2019} from type \u2018int\u2019\n\nwhere __va_list isn't something the user is expected to know about.\nA similar thing happens for C++ on the arm_neon.h-based:\n\n  float x;\n  int8x8_t y = x;\n\nwhich gives:\n\n  cannot convert \u2018float\u2019 to \u2018int8x8_t\u2019 {aka \u2018__Int8x8_t\u2019} in initialization\n\nThis is accurate -- and __Int8x8_t is defined by the AArch64 PCS --\nbut it's not going to be meaningful to most users.\n\nThis patch stops the aka code looking through typedefs if all of\nthe following are true:\n\n(1) the typedef is built into the compiler or comes from a system header\n\n(2) the target of the typedef is anonymous or has a name in the\n    implementation namespace\n\n(3) the target type is a tag type or vector type, which have in common that:\n    (a) we print their type names if they have one\n    (b) what we print for anonymous types isn't all that useful\n        (\"struct <anonymous>\" etc. for tag types, pseudo-C \"__vector(N) T\"\n        for vector types)\n\nThe patch does this by recursively looking for the aka type, like the\nC++ frontend already does.  This in turn makes \"aka\" work for distinct type\ncopies like __Int8x8_t on aarch64, fixing the ??? in aarch64/diag_aka_1.c.\n\n2019-10-14  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/c-family/\n\t* c-common.h (user_facing_original_type_p): Declare.\n\t* c-common.c: Include c-spellcheck.h.\n\t(user_facing_original_type_p): New function.\n\ngcc/c/\n\t* c-objc-common.c (useful_aka_type_p): Replace with...\n\t(get_aka_type): ...this new function.  Given the original type,\n\tdecide which aka type to print (if any).  Only look through typedefs\n\tif user_facing_original_type_p.\n\t(print_type): Update accordingly.\n\ngcc/testsuite/\n\t* gcc.dg/diag-aka-5.h: New test.\n\t* gcc.dg/diag-aka-5a.c: Likewise.\n\t* gcc.dg/diag-aka-5b.c: Likewise.\n\t* gcc.target/aarch64/diag_aka_1.c (f): Expect an aka to be printed\n\tfor myvec.\n\nFrom-SVN: r276951", "tree": {"sha": "94c4cbef454873ea3d58380d67930ee520289c86", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/94c4cbef454873ea3d58380d67930ee520289c86"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/56898e437a538c7edc0724a3650f5cb81c9d5721", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56898e437a538c7edc0724a3650f5cb81c9d5721", "html_url": "https://github.com/Rust-GCC/gccrs/commit/56898e437a538c7edc0724a3650f5cb81c9d5721", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56898e437a538c7edc0724a3650f5cb81c9d5721/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b9424661f58de6c0aa9dc4c855c1fd913cc06282", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9424661f58de6c0aa9dc4c855c1fd913cc06282", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9424661f58de6c0aa9dc4c855c1fd913cc06282"}], "stats": {"total": 496, "additions": 454, "deletions": 42}, "files": [{"sha": "cb3b9cfa98ef38637a9eb889122002a322ed10e4", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56898e437a538c7edc0724a3650f5cb81c9d5721/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56898e437a538c7edc0724a3650f5cb81c9d5721/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=56898e437a538c7edc0724a3650f5cb81c9d5721", "patch": "@@ -1,3 +1,9 @@\n+2019-10-14  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* c-common.h (user_facing_original_type_p): Declare.\n+\t* c-common.c: Include c-spellcheck.h.\n+\t(user_facing_original_type_p): New function.\n+\n 2019-10-12  Jakub Jelinek  <jakub@redhat.com>\n \n \t* c-common.h (c_omp_mark_declare_variant,"}, {"sha": "483d874bc3a2148830bbd835c03b2b7608885b21", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56898e437a538c7edc0724a3650f5cb81c9d5721/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56898e437a538c7edc0724a3650f5cb81c9d5721/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=56898e437a538c7edc0724a3650f5cb81c9d5721", "patch": "@@ -48,6 +48,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimplify.h\"\n #include \"substring-locations.h\"\n #include \"spellcheck.h\"\n+#include \"c-spellcheck.h\"\n #include \"selftest.h\"\n \n cpp_reader *parse_in;\t\t/* Declared in c-pragma.h.  */\n@@ -7713,6 +7714,52 @@ set_underlying_type (tree x)\n     }\n }\n \n+/* Return true if it is worth exposing the DECL_ORIGINAL_TYPE of TYPE to\n+   the user in diagnostics, false if it would be better to use TYPE itself.\n+   TYPE is known to satisfy typedef_variant_p.  */\n+\n+bool\n+user_facing_original_type_p (const_tree type)\n+{\n+  gcc_assert (typedef_variant_p (type));\n+  tree decl = TYPE_NAME (type);\n+\n+  /* Look through any typedef in \"user\" code.  */\n+  if (!DECL_IN_SYSTEM_HEADER (decl) && !DECL_IS_BUILTIN (decl))\n+    return true;\n+\n+  /* If the original type is also named and is in the user namespace,\n+     assume it too is a user-facing type.  */\n+  tree orig_type = DECL_ORIGINAL_TYPE (decl);\n+  if (tree orig_id = TYPE_IDENTIFIER (orig_type))\n+    if (!name_reserved_for_implementation_p (IDENTIFIER_POINTER (orig_id)))\n+      return true;\n+\n+  switch (TREE_CODE (orig_type))\n+    {\n+    /* Don't look through to an anonymous vector type, since the syntax\n+       we use for them in diagnostics isn't real C or C++ syntax.\n+       And if ORIG_TYPE is named but in the implementation namespace,\n+       TYPE is likely to be more meaningful to the user.  */\n+    case VECTOR_TYPE:\n+      return false;\n+\n+    /* Don't expose anonymous tag types that are presumably meant to be\n+       known by their typedef name.  Also don't expose tags that are in\n+       the implementation namespace, such as:\n+\n+         typedef struct __foo foo;  */\n+    case RECORD_TYPE:\n+    case UNION_TYPE:\n+    case ENUMERAL_TYPE:\n+      return false;\n+\n+    /* Look through to anything else.  */\n+    default:\n+      return true;\n+    }\n+}\n+\n /* Record the types used by the current global variable declaration\n    being parsed, so that we can decide later to emit their debug info.\n    Those types are in types_used_by_cur_var_decl, and we are going to"}, {"sha": "3bc021b65d96321a2a2a6769d2ba7695945e5447", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56898e437a538c7edc0724a3650f5cb81c9d5721/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56898e437a538c7edc0724a3650f5cb81c9d5721/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=56898e437a538c7edc0724a3650f5cb81c9d5721", "patch": "@@ -1063,6 +1063,7 @@ extern tree builtin_type_for_size (int, bool);\n extern void c_common_mark_addressable_vec (tree);\n \n extern void set_underlying_type (tree);\n+extern bool user_facing_original_type_p (const_tree);\n extern void record_types_used_by_current_var_decl (tree);\n extern vec<tree, va_gc> *make_tree_vector (void);\n extern void release_tree_vector (vec<tree, va_gc> *);"}, {"sha": "23310ce0e43aa4faa6af62c1830d6b55addb1c7f", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56898e437a538c7edc0724a3650f5cb81c9d5721/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56898e437a538c7edc0724a3650f5cb81c9d5721/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=56898e437a538c7edc0724a3650f5cb81c9d5721", "patch": "@@ -1,3 +1,11 @@\n+2019-10-14  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* c-objc-common.c (useful_aka_type_p): Replace with...\n+\t(get_aka_type): ...this new function.  Given the original type,\n+\tdecide which aka type to print (if any).  Only look through typedefs\n+\tif user_facing_original_type_p.\n+\t(print_type): Update accordingly.\n+\n 2019-10-14  Jakub Jelinek  <jakub@redhat.com>\n \n \t* c-parser.c (c_parser_omp_all_clauses): Change bool NESTED_P argument"}, {"sha": "10d72c57dfb829d4395e3516fccc1657aaa7e0e0", "filename": "gcc/c/c-objc-common.c", "status": "modified", "additions": 91, "deletions": 39, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56898e437a538c7edc0724a3650f5cb81c9d5721/gcc%2Fc%2Fc-objc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56898e437a538c7edc0724a3650f5cb81c9d5721/gcc%2Fc%2Fc-objc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-objc-common.c?ref=56898e437a538c7edc0724a3650f5cb81c9d5721", "patch": "@@ -28,6 +28,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"langhooks.h\"\n #include \"c-objc-common.h\"\n #include \"gcc-rich-location.h\"\n+#include \"stringpool.h\"\n+#include \"attribs.h\"\n \n static bool c_tree_printer (pretty_printer *, text_info *, const char *,\n \t\t\t    int, bool, bool, bool, bool *, const char **);\n@@ -62,71 +64,120 @@ c_objc_common_init (void)\n   return c_common_init ();\n }\n \n-/* Return true if it's worth saying that TYPE1 is also known as TYPE2.  */\n+/* Decide whether it's worth saying that TYPE is also known as some other\n+   type.  Return the other type if so, otherwise return TYPE.  */\n \n-static bool\n-useful_aka_type_p (tree type1, tree type2)\n+static tree\n+get_aka_type (tree type)\n {\n-  if (type1 == type2)\n-    return false;\n-\n-  if (type1 == error_mark_node || type2 == error_mark_node)\n-    return false;\n-\n-  if (TREE_CODE (type1) != TREE_CODE (type2))\n-    return true;\n+  if (type == error_mark_node)\n+    return type;\n \n-  if (typedef_variant_p (type1))\n+  tree result;\n+  if (typedef_variant_p (type))\n     {\n       /* Saying that \"foo\" is also known as \"struct foo\" or\n \t \"struct <anonymous>\" is unlikely to be useful, since users of\n \t structure-like types would already know that they're structures.\n \t The same applies to unions and enums; in general, printing the\n \t tag is only useful if it has a different name.  */\n-      tree_code code = TREE_CODE (type2);\n-      tree id2 = TYPE_IDENTIFIER (type2);\n+      tree orig_type = DECL_ORIGINAL_TYPE (TYPE_NAME (type));\n+      tree_code code = TREE_CODE (orig_type);\n+      tree orig_id = TYPE_IDENTIFIER (orig_type);\n       if ((code == RECORD_TYPE || code == UNION_TYPE || code == ENUMERAL_TYPE)\n-\t  && (!id2 || TYPE_IDENTIFIER (type1) == id2))\n-\treturn false;\n+\t  && (!orig_id || TYPE_IDENTIFIER (type) == orig_id))\n+\treturn type;\n \n-      return true;\n+      if (!user_facing_original_type_p (type))\n+\treturn type;\n+\n+      result = get_aka_type (orig_type);\n     }\n   else\n     {\n-      switch (TREE_CODE (type1))\n+      tree canonical = TYPE_CANONICAL (type);\n+      if (canonical && TREE_CODE (type) != TREE_CODE (canonical))\n+\treturn canonical;\n+\n+      /* Recursive calls might choose a middle ground between TYPE\n+\t (which has no typedefs stripped) and CANONICAL (which has\n+\t all typedefs stripped).  So try to reuse TYPE or CANONICAL if\n+\t convenient, but be prepared to create a new type if necessary.  */\n+      switch (TREE_CODE (type))\n \t{\n \tcase POINTER_TYPE:\n \tcase REFERENCE_TYPE:\n-\t  return useful_aka_type_p (TREE_TYPE (type1), TREE_TYPE (type2));\n+\t  {\n+\t    tree target_type = get_aka_type (TREE_TYPE (type));\n+\n+\t    if (target_type == TREE_TYPE (type))\n+\t      return type;\n+\n+\t    if (canonical && target_type == TREE_TYPE (canonical))\n+\t      return canonical;\n+\n+\t    result = (TREE_CODE (type) == POINTER_TYPE\n+\t\t      ? build_pointer_type (target_type)\n+\t\t      : build_reference_type (target_type));\n+\t    break;\n+\t  }\n \n \tcase ARRAY_TYPE:\n-\t  return (useful_aka_type_p (TYPE_DOMAIN (type1), TYPE_DOMAIN (type2))\n-\t\t  || useful_aka_type_p (TREE_TYPE (type1), TREE_TYPE (type2)));\n+\t  {\n+\t    tree element_type = get_aka_type (TREE_TYPE (type));\n+\t    tree index_type = (TYPE_DOMAIN (type)\n+\t\t\t       ? get_aka_type (TYPE_DOMAIN (type))\n+\t\t\t       : NULL_TREE);\n+\n+\t    if (element_type == TREE_TYPE (type)\n+\t\t&& index_type == TYPE_DOMAIN (type))\n+\t      return type;\n+\n+\t    if (canonical\n+\t\t&& element_type == TREE_TYPE (canonical)\n+\t\t&& index_type == TYPE_DOMAIN (canonical))\n+\t      return canonical;\n+\n+\t    result = build_array_type (element_type, index_type,\n+\t\t\t\t       TYPE_TYPELESS_STORAGE (type));\n+\t    break;\n+\t  }\n \n \tcase FUNCTION_TYPE:\n \t  {\n-\t    tree args1 = TYPE_ARG_TYPES (type1);\n-\t    tree args2 = TYPE_ARG_TYPES (type2);\n-\t    while (args1 != args2)\n+\t    tree return_type = get_aka_type (TREE_TYPE (type));\n+\n+\t    tree args = TYPE_ARG_TYPES (type);\n+\t    if (args == error_mark_node)\n+\t      return type;\n+\n+\t    auto_vec<tree, 32> arg_types;\n+\t    bool type_ok_p = true;\n+\t    while (args && args != void_list_node)\n \t      {\n-\t\t/* Although this shouldn't happen, it seems to wrong to assert\n-\t\t   for it in a diagnostic routine.  */\n-\t\tif (!args1 || args1 == void_type_node)\n-\t\t  return true;\n-\t\tif (!args2 || args2 == void_type_node)\n-\t\t  return true;\n-\t\tif (useful_aka_type_p (TREE_VALUE (args1), TREE_VALUE (args2)))\n-\t\t  return true;\n-\t\targs1 = TREE_CHAIN (args1);\n-\t\targs2 = TREE_CHAIN (args2);\n+\t\ttree arg_type = get_aka_type (TREE_VALUE (args));\n+\t\targ_types.safe_push (arg_type);\n+\t\ttype_ok_p &= (arg_type == TREE_VALUE (args));\n+\t\targs = TREE_CHAIN (args);\n \t      }\n-\t    return useful_aka_type_p (TREE_TYPE (type1), TREE_TYPE (type2));\n+\n+\t    if (type_ok_p && return_type == TREE_TYPE (type))\n+\t      return type;\n+\n+\t    unsigned int i;\n+\t    tree arg_type;\n+\t    FOR_EACH_VEC_ELT_REVERSE (arg_types, i, arg_type)\n+\t      args = tree_cons (NULL_TREE, arg_type, args);\n+\t    result = build_function_type (return_type, args);\n+\t    break;\n \t  }\n \n \tdefault:\n-\t  return true;\n+\t  return canonical ? canonical : type;\n \t}\n     }\n+  return build_type_attribute_qual_variant (result, TYPE_ATTRIBUTES (type),\n+\t\t\t\t\t    TYPE_QUALS (type));\n }\n \n /* Print T to CPP.  */\n@@ -150,11 +201,12 @@ print_type (c_pretty_printer *cpp, tree t, bool *quoted)\n      stripped version.  But sometimes the stripped version looks\n      exactly the same, so we don't want it after all.  To avoid\n      printing it in that case, we play ugly obstack games.  */\n-  if (TYPE_CANONICAL (t) && useful_aka_type_p (t, TYPE_CANONICAL (t)))\n+  tree aka_type = get_aka_type (t);\n+  if (aka_type != t)\n     {\n       c_pretty_printer cpp2;\n       /* Print the stripped version into a temporary printer.  */\n-      cpp2.type_id (TYPE_CANONICAL (t));\n+      cpp2.type_id (aka_type);\n       struct obstack *ob2 = cpp2.buffer->obstack;\n       /* Get the stripped version from the temporary printer.  */\n       const char *aka = (char *) obstack_base (ob2);\n@@ -174,7 +226,7 @@ print_type (c_pretty_printer *cpp, tree t, bool *quoted)\n       pp_c_whitespace (cpp);\n       if (*quoted)\n \tpp_begin_quote (cpp, pp_show_color (cpp));\n-      cpp->type_id (TYPE_CANONICAL (t));\n+      cpp->type_id (aka_type);\n       if (*quoted)\n \tpp_end_quote (cpp, pp_show_color (cpp));\n       pp_right_brace (cpp);"}, {"sha": "7385c3345055311ac9806215cddc830945b1c0a1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56898e437a538c7edc0724a3650f5cb81c9d5721/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56898e437a538c7edc0724a3650f5cb81c9d5721/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=56898e437a538c7edc0724a3650f5cb81c9d5721", "patch": "@@ -1,3 +1,11 @@\n+2019-10-14  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* gcc.dg/diag-aka-5.h: New test.\n+\t* gcc.dg/diag-aka-5a.c: Likewise.\n+\t* gcc.dg/diag-aka-5b.c: Likewise.\n+\t* gcc.target/aarch64/diag_aka_1.c (f): Expect an aka to be printed\n+\tfor myvec.\n+\n 2019-10-14  Jakub Jelinek  <jakub@redhat.com>\n \n \t* c-c++-common/gomp/declare-variant-7.c: Add tests for clauses not"}, {"sha": "0c7404d766404a8d6ce35460970dc96b7d8b2e2b", "filename": "gcc/testsuite/gcc.dg/diag-aka-5.h", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56898e437a538c7edc0724a3650f5cb81c9d5721/gcc%2Ftestsuite%2Fgcc.dg%2Fdiag-aka-5.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56898e437a538c7edc0724a3650f5cb81c9d5721/gcc%2Ftestsuite%2Fgcc.dg%2Fdiag-aka-5.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdiag-aka-5.h?ref=56898e437a538c7edc0724a3650f5cb81c9d5721", "patch": "@@ -0,0 +1,22 @@\n+#ifdef IS_SYSTEM_HEADER\n+#pragma GCC system_header\n+#endif\n+\n+typedef enum __internal_enum { A, B } user_enum;\n+typedef user_enum *user_enum_ptr;\n+\n+typedef struct __internal_struct { int i; } user_struct;\n+typedef user_struct user_struct_copy;\n+typedef user_struct *user_struct_ptr;\n+\n+typedef union __internal_union { int i; } user_union;\n+typedef user_union user_union_copy;\n+typedef user_union *user_union_ptr;\n+\n+typedef unsigned int user_vector __attribute__((__vector_size__(16)));\n+typedef user_vector user_vector_copy;\n+typedef user_vector *user_vector_ptr;\n+\n+typedef int user_int;\n+typedef user_int user_int_copy;\n+typedef user_int *user_int_ptr;"}, {"sha": "8768a79204a409b365331a49495ec828f16a4c96", "filename": "gcc/testsuite/gcc.dg/diag-aka-5a.c", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56898e437a538c7edc0724a3650f5cb81c9d5721/gcc%2Ftestsuite%2Fgcc.dg%2Fdiag-aka-5a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56898e437a538c7edc0724a3650f5cb81c9d5721/gcc%2Ftestsuite%2Fgcc.dg%2Fdiag-aka-5a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdiag-aka-5a.c?ref=56898e437a538c7edc0724a3650f5cb81c9d5721", "patch": "@@ -0,0 +1,135 @@\n+#define IS_SYSTEM_HEADER\n+#include \"diag-aka-5.h\"\n+\n+typedef user_enum user_enum_copy;\n+\n+struct s { int i; };\n+\n+user_enum ue1;\n+user_enum_copy ue2;\n+user_enum_ptr ue_ptr1;\n+user_enum *ue_ptr2;\n+const user_enum *const_ue_ptr1;\n+const user_enum_copy *const_ue_ptr2;\n+volatile user_enum *volatile_ue_ptr1;\n+volatile user_enum_copy *volatile_ue_ptr2;\n+__extension__ _Atomic user_enum *atomic_ue_ptr1;\n+__extension__ _Atomic user_enum_copy *atomic_ue_ptr2;\n+user_enum (*ue_array_ptr1)[10];\n+user_enum_copy (*ue_array_ptr2)[10];\n+user_enum (*ue_fn_ptr1) (void);\n+void (*ue_fn_ptr2) (user_enum);\n+void (*ue_fn_ptr3) (user_enum, ...);\n+user_enum_copy (*ue_fn_ptr4) (void);\n+void (*ue_fn_ptr5) (user_enum_copy);\n+void (*ue_fn_ptr6) (user_enum_copy, ...);\n+user_enum (*__attribute__((__transaction_unsafe__)) unsafe_ue_fn_ptr1) (void);\n+user_enum_copy (*__attribute__((__transaction_unsafe__)) unsafe_ue_fn_ptr2) (void);\n+\n+user_struct us1;\n+user_struct_copy us2;\n+user_struct_ptr us_ptr1;\n+user_struct *us_ptr2;\n+const user_struct *const_us_ptr1;\n+const user_struct_copy *const_us_ptr2;\n+\n+user_union uu1;\n+user_union_copy uu2;\n+user_union_ptr uu_ptr1;\n+user_union *uu_ptr2;\n+const user_union *const_uu_ptr1;\n+const user_union_copy *const_uu_ptr2;\n+\n+user_vector uv1;\n+user_vector_copy uv2;\n+user_vector_ptr uv_ptr1;\n+user_vector *uv_ptr2;\n+const user_vector *const_uv_ptr1;\n+const user_vector_copy *const_uv_ptr2;\n+\n+user_int ui1;\n+user_int_copy ui2;\n+user_int_ptr ui_ptr1;\n+user_int *ui_ptr2;\n+const user_int *const_ui_ptr1;\n+const user_int_copy *const_ui_ptr2;\n+volatile user_int *volatile_ui_ptr1;\n+volatile user_int_copy *volatile_ui_ptr2;\n+__extension__ _Atomic user_int *atomic_ui_ptr1;\n+__extension__ _Atomic user_int_copy *atomic_ui_ptr2;\n+user_int (*ui_array_ptr1)[10];\n+user_int_copy (*ui_array_ptr2)[10];\n+user_int (*ui_fn_ptr1) (void);\n+void (*ui_fn_ptr2) (user_int);\n+void (*ui_fn_ptr3) (user_int, ...);\n+user_int_copy (*ui_fn_ptr4) (void);\n+void (*ui_fn_ptr5) (user_int_copy);\n+void (*ui_fn_ptr6) (user_int_copy, ...);\n+user_int (*__attribute__((__transaction_unsafe__)) unsafe_ui_fn_ptr1) (void);\n+user_int_copy (*__attribute__((__transaction_unsafe__)) unsafe_ui_fn_ptr2) (void);\n+\n+void f (struct s s)\n+{\n+  ue1 = s; /* { dg-error {assigning to type 'user_enum' from type 'struct s'} } */\n+  ue2 = s; /* { dg-error {assigning to type 'user_enum_copy' {aka 'user_enum'} from type 'struct s'} } */\n+  ue_ptr1 = &s; /* { dg-error {assignment to 'user_enum_ptr' {aka 'user_enum \\*'} from incompatible pointer type 'struct s \\*'} } */\n+  ue_ptr2 = &s; /* { dg-error {assignment to 'user_enum \\*' from incompatible pointer type 'struct s \\*'} } */\n+  const_ue_ptr1 = &s; /* { dg-error {assignment to 'const user_enum \\*' from incompatible pointer type 'struct s \\*'} } */\n+  const_ue_ptr2 = &s; /* { dg-error {assignment to 'const user_enum_copy \\*' {aka 'const user_enum \\*'} from incompatible pointer type 'struct s \\*'} } */\n+  volatile_ue_ptr1 = &s; /* { dg-error {assignment to 'volatile user_enum \\*' from incompatible pointer type 'struct s \\*'} } */\n+  volatile_ue_ptr2 = &s; /* { dg-error {assignment to 'volatile user_enum_copy \\*' {aka 'volatile user_enum \\*'} from incompatible pointer type 'struct s \\*'} } */\n+  atomic_ue_ptr1 = &s; /* { dg-error {assignment to '_Atomic user_enum \\*' from incompatible pointer type 'struct s \\*'} } */\n+  atomic_ue_ptr2 = &s; /* { dg-error {assignment to '_Atomic user_enum_copy \\*' {aka '_Atomic user_enum \\*'} from incompatible pointer type 'struct s \\*'} } */\n+  ue_array_ptr1 = &s; /* { dg-error {assignment to 'user_enum \\(\\*\\)\\[10\\]' from incompatible pointer type 'struct s \\*'} } */\n+  ue_array_ptr2 = &s; /* { dg-error {assignment to 'user_enum_copy \\(\\*\\)\\[10\\]' {aka 'user_enum \\(\\*\\)\\[10\\]'} from incompatible pointer type 'struct s \\*'} } */\n+  ue_fn_ptr1 = &s; /* { dg-error {assignment to 'user_enum \\(\\*\\)\\(void\\)' from incompatible pointer type 'struct s \\*'} } */\n+  ue_fn_ptr2 = &s; /* { dg-error {assignment to 'void \\(\\*\\)\\(user_enum\\)' from incompatible pointer type 'struct s \\*'} } */\n+  ue_fn_ptr3 = &s; /* { dg-error {assignment to 'void \\(\\*\\)\\(user_enum, \\.\\.\\.\\)' from incompatible pointer type 'struct s \\*'} } */\n+  ue_fn_ptr4 = &s; /* { dg-error {assignment to 'user_enum_copy \\(\\*\\)\\(void\\)' {aka 'user_enum \\(\\*\\)\\(void\\)'} from incompatible pointer type 'struct s \\*'} } */\n+  ue_fn_ptr5 = &s; /* { dg-error {assignment to 'void \\(\\*\\)\\(user_enum_copy\\)' {aka 'void \\(\\*\\)\\(user_enum\\)'} from incompatible pointer type 'struct s \\*'} } */\n+  ue_fn_ptr6 = &s; /* { dg-error {assignment to 'void \\(\\*\\)\\(user_enum_copy, \\.\\.\\.\\)' {aka 'void \\(\\*\\)\\(user_enum, \\.\\.\\.\\)'} from incompatible pointer type 'struct s \\*'} } */\n+  unsafe_ue_fn_ptr1 = &s; /* { dg-error {assignment to 'user_enum \\(__attribute__\\(\\(transaction_unsafe\\)\\) \\*\\)\\(void\\)' from incompatible pointer type 'struct s \\*'} } */\n+  unsafe_ue_fn_ptr2 = &s; /* { dg-error {assignment to 'user_enum_copy \\(__attribute__\\(\\(transaction_unsafe\\)\\) \\*\\)\\(void\\)' {aka 'user_enum \\(__attribute__\\(\\(transaction_unsafe\\)\\) \\*\\)\\(void\\)'} from incompatible pointer type 'struct s \\*'} } */\n+\n+  us1 = s; /* { dg-error {assigning to type 'user_struct' from type 'struct s'} } */\n+  us2 = s; /* { dg-error {assigning to type 'user_struct_copy' {aka 'user_struct'} from type 'struct s'} } */\n+  us_ptr1 = &s; /* { dg-error {assignment to 'user_struct_ptr' {aka 'user_struct \\*'} from incompatible pointer type 'struct s \\*'} } */\n+  us_ptr2 = &s; /* { dg-error {assignment to 'user_struct \\*' from incompatible pointer type 'struct s \\*'} } */\n+  const_us_ptr1 = &s; /* { dg-error {assignment to 'const user_struct \\*' from incompatible pointer type 'struct s \\*'} } */\n+  const_us_ptr2 = &s; /* { dg-error {assignment to 'const user_struct_copy \\*' {aka 'const user_struct \\*'} from incompatible pointer type 'struct s \\*'} } */\n+\n+  uu1 = s; /* { dg-error {assigning to type 'user_union' from type 'struct s'} } */\n+  uu2 = s; /* { dg-error {assigning to type 'user_union_copy' {aka 'user_union'} from type 'struct s'} } */\n+  uu_ptr1 = &s; /* { dg-error {assignment to 'user_union_ptr' {aka 'user_union \\*'} from incompatible pointer type 'struct s \\*'} } */\n+  uu_ptr2 = &s; /* { dg-error {assignment to 'user_union \\*' from incompatible pointer type 'struct s \\*'} } */\n+  const_uu_ptr1 = &s; /* { dg-error {assignment to 'const user_union \\*' from incompatible pointer type 'struct s \\*'} } */\n+  const_uu_ptr2 = &s; /* { dg-error {assignment to 'const user_union_copy \\*' {aka 'const user_union \\*'} from incompatible pointer type 'struct s \\*'} } */\n+\n+  uv1 = s; /* { dg-error {assigning to type 'user_vector' from type 'struct s'} } */\n+  uv2 = s; /* { dg-error {assigning to type 'user_vector_copy' {aka 'user_vector'} from type 'struct s'} } */\n+  uv_ptr1 = &s; /* { dg-error {assignment to 'user_vector_ptr' {aka 'user_vector \\*'} from incompatible pointer type 'struct s \\*'} } */\n+  uv_ptr2 = &s; /* { dg-error {assignment to 'user_vector \\*' from incompatible pointer type 'struct s \\*'} } */\n+  const_uv_ptr1 = &s; /* { dg-error {assignment to 'const user_vector \\*' from incompatible pointer type 'struct s \\*'} } */\n+  const_uv_ptr2 = &s; /* { dg-error {assignment to 'const user_vector_copy \\*' {aka 'const user_vector \\*'} from incompatible pointer type 'struct s \\*'} } */\n+\n+  ui1 = s; /* { dg-error {assigning to type 'user_int' {aka 'int'} from type 'struct s'} } */\n+  ui2 = s; /* { dg-error {assigning to type 'user_int_copy' {aka 'int'} from type 'struct s'} } */\n+  ui_ptr1 = &s; /* { dg-error {assignment to 'user_int_ptr' {aka 'int \\*'} from incompatible pointer type 'struct s \\*'} } */\n+  ui_ptr2 = &s; /* { dg-error {assignment to 'user_int \\*' {aka 'int \\*'} from incompatible pointer type 'struct s \\*'} } */\n+  const_ui_ptr1 = &s; /* { dg-error {assignment to 'const user_int \\*' {aka 'const int \\*'} from incompatible pointer type 'struct s \\*'} } */\n+  const_ui_ptr2 = &s; /* { dg-error {assignment to 'const user_int_copy \\*' {aka 'const int \\*'} from incompatible pointer type 'struct s \\*'} } */\n+  volatile_ui_ptr1 = &s; /* { dg-error {assignment to 'volatile user_int \\*' {aka 'volatile int \\*'} from incompatible pointer type 'struct s \\*'} } */\n+  volatile_ui_ptr2 = &s; /* { dg-error {assignment to 'volatile user_int_copy \\*' {aka 'volatile int \\*'} from incompatible pointer type 'struct s \\*'} } */\n+  atomic_ui_ptr1 = &s; /* { dg-error {assignment to '_Atomic user_int \\*' {aka '_Atomic int \\*'} from incompatible pointer type 'struct s \\*'} } */\n+  atomic_ui_ptr2 = &s; /* { dg-error {assignment to '_Atomic user_int_copy \\*' {aka '_Atomic int \\*'} from incompatible pointer type 'struct s \\*'} } */\n+  ui_array_ptr1 = &s; /* { dg-error {assignment to 'user_int \\(\\*\\)\\[10\\]' {aka 'int \\(\\*\\)\\[10\\]'} from incompatible pointer type 'struct s \\*'} } */\n+  ui_array_ptr2 = &s; /* { dg-error {assignment to 'user_int_copy \\(\\*\\)\\[10\\]' {aka 'int \\(\\*\\)\\[10\\]'} from incompatible pointer type 'struct s \\*'} } */\n+  ui_fn_ptr1 = &s; /* { dg-error {assignment to 'user_int \\(\\*\\)\\(void\\)' {aka 'int \\(\\*\\)\\(void\\)'} from incompatible pointer type 'struct s \\*'} } */\n+  ui_fn_ptr2 = &s; /* { dg-error {assignment to 'void \\(\\*\\)\\(user_int\\)' {aka 'void \\(\\*\\)\\(int\\)'} from incompatible pointer type 'struct s \\*'} } */\n+  ui_fn_ptr3 = &s; /* { dg-error {assignment to 'void \\(\\*\\)\\(user_int, \\.\\.\\.\\)' {aka 'void \\(\\*\\)\\(int, \\.\\.\\.\\)'} from incompatible pointer type 'struct s \\*'} } */\n+  ui_fn_ptr4 = &s; /* { dg-error {assignment to 'user_int_copy \\(\\*\\)\\(void\\)' {aka 'int \\(\\*\\)\\(void\\)'} from incompatible pointer type 'struct s \\*'} } */\n+  ui_fn_ptr5 = &s; /* { dg-error {assignment to 'void \\(\\*\\)\\(user_int_copy\\)' {aka 'void \\(\\*\\)\\(int\\)'} from incompatible pointer type 'struct s \\*'} } */\n+  ui_fn_ptr6 = &s; /* { dg-error {assignment to 'void \\(\\*\\)\\(user_int_copy, \\.\\.\\.\\)' {aka 'void \\(\\*\\)\\(int, \\.\\.\\.\\)'} from incompatible pointer type 'struct s \\*'} } */\n+  unsafe_ui_fn_ptr1 = &s; /* { dg-error {assignment to 'user_int \\(__attribute__\\(\\(transaction_unsafe\\)\\) \\*\\)\\(void\\)' {aka 'int \\(__attribute__\\(\\(transaction_unsafe\\)\\) \\*\\)\\(void\\)'} from incompatible pointer type 'struct s \\*'} } */\n+  unsafe_ui_fn_ptr2 = &s; /* { dg-error {assignment to 'user_int_copy \\(__attribute__\\(\\(transaction_unsafe\\)\\) \\*\\)\\(void\\)' {aka 'int \\(__attribute__\\(\\(transaction_unsafe\\)\\) \\*\\)\\(void\\)'} from incompatible pointer type 'struct s \\*'} } */\n+}"}, {"sha": "e0ec7c816a20f180d6811d4b2842a86df6e324dc", "filename": "gcc/testsuite/gcc.dg/diag-aka-5b.c", "status": "added", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56898e437a538c7edc0724a3650f5cb81c9d5721/gcc%2Ftestsuite%2Fgcc.dg%2Fdiag-aka-5b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56898e437a538c7edc0724a3650f5cb81c9d5721/gcc%2Ftestsuite%2Fgcc.dg%2Fdiag-aka-5b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdiag-aka-5b.c?ref=56898e437a538c7edc0724a3650f5cb81c9d5721", "patch": "@@ -0,0 +1,134 @@\n+#include \"diag-aka-5.h\"\n+\n+typedef user_enum user_enum_copy;\n+\n+struct s { int i; };\n+\n+user_enum ue1;\n+user_enum_copy ue2;\n+user_enum_ptr ue_ptr1;\n+user_enum *ue_ptr2;\n+const user_enum *const_ue_ptr1;\n+const user_enum_copy *const_ue_ptr2;\n+volatile user_enum *volatile_ue_ptr1;\n+volatile user_enum_copy *volatile_ue_ptr2;\n+__extension__ _Atomic user_enum *atomic_ue_ptr1;\n+__extension__ _Atomic user_enum_copy *atomic_ue_ptr2;\n+user_enum (*ue_array_ptr1)[10];\n+user_enum_copy (*ue_array_ptr2)[10];\n+user_enum (*ue_fn_ptr1) (void);\n+void (*ue_fn_ptr2) (user_enum);\n+void (*ue_fn_ptr3) (user_enum, ...);\n+user_enum_copy (*ue_fn_ptr4) (void);\n+void (*ue_fn_ptr5) (user_enum_copy);\n+void (*ue_fn_ptr6) (user_enum_copy, ...);\n+user_enum (*__attribute__((__transaction_unsafe__)) unsafe_ue_fn_ptr1) (void);\n+user_enum_copy (*__attribute__((__transaction_unsafe__)) unsafe_ue_fn_ptr2) (void);\n+\n+user_struct us1;\n+user_struct_copy us2;\n+user_struct_ptr us_ptr1;\n+user_struct *us_ptr2;\n+const user_struct *const_us_ptr1;\n+const user_struct_copy *const_us_ptr2;\n+\n+user_union uu1;\n+user_union_copy uu2;\n+user_union_ptr uu_ptr1;\n+user_union *uu_ptr2;\n+const user_union *const_uu_ptr1;\n+const user_union_copy *const_uu_ptr2;\n+\n+user_vector uv1;\n+user_vector_copy uv2;\n+user_vector_ptr uv_ptr1;\n+user_vector *uv_ptr2;\n+const user_vector *const_uv_ptr1;\n+const user_vector_copy *const_uv_ptr2;\n+\n+user_int ui1;\n+user_int_copy ui2;\n+user_int_ptr ui_ptr1;\n+user_int *ui_ptr2;\n+const user_int *const_ui_ptr1;\n+const user_int_copy *const_ui_ptr2;\n+volatile user_int *volatile_ui_ptr1;\n+volatile user_int_copy *volatile_ui_ptr2;\n+__extension__ _Atomic user_int *atomic_ui_ptr1;\n+__extension__ _Atomic user_int_copy *atomic_ui_ptr2;\n+user_int (*ui_array_ptr1)[10];\n+user_int_copy (*ui_array_ptr2)[10];\n+user_int (*ui_fn_ptr1) (void);\n+void (*ui_fn_ptr2) (user_int);\n+void (*ui_fn_ptr3) (user_int, ...);\n+user_int_copy (*ui_fn_ptr4) (void);\n+void (*ui_fn_ptr5) (user_int_copy);\n+void (*ui_fn_ptr6) (user_int_copy, ...);\n+user_int (*__attribute__((__transaction_unsafe__)) unsafe_ui_fn_ptr1) (void);\n+user_int_copy (*__attribute__((__transaction_unsafe__)) unsafe_ui_fn_ptr2) (void);\n+\n+void f (struct s s)\n+{\n+  ue1 = s; /* { dg-error {assigning to type 'user_enum' {aka 'enum __internal_enum'} from type 'struct s'} } */\n+  ue2 = s; /* { dg-error {assigning to type 'user_enum_copy' {aka 'enum __internal_enum'} from type 'struct s'} } */\n+  ue_ptr1 = &s; /* { dg-error {assignment to 'user_enum_ptr' {aka 'enum __internal_enum \\*'} from incompatible pointer type 'struct s \\*'} } */\n+  ue_ptr2 = &s; /* { dg-error {assignment to 'user_enum \\*' {aka 'enum __internal_enum \\*'} from incompatible pointer type 'struct s \\*'} } */\n+  const_ue_ptr1 = &s; /* { dg-error {assignment to 'const user_enum \\*' {aka 'const enum __internal_enum \\*'} from incompatible pointer type 'struct s \\*'} } */\n+  const_ue_ptr2 = &s; /* { dg-error {assignment to 'const user_enum_copy \\*' {aka 'const enum __internal_enum \\*'} from incompatible pointer type 'struct s \\*'} } */\n+  volatile_ue_ptr1 = &s; /* { dg-error {assignment to 'volatile user_enum \\*' {aka 'volatile enum __internal_enum \\*'} from incompatible pointer type 'struct s \\*'} } */\n+  volatile_ue_ptr2 = &s; /* { dg-error {assignment to 'volatile user_enum_copy \\*' {aka 'volatile enum __internal_enum \\*'} from incompatible pointer type 'struct s \\*'} } */\n+  atomic_ue_ptr1 = &s; /* { dg-error {assignment to '_Atomic user_enum \\*' {aka '_Atomic enum __internal_enum \\*'} from incompatible pointer type 'struct s \\*'} } */\n+  atomic_ue_ptr2 = &s; /* { dg-error {assignment to '_Atomic user_enum_copy \\*' {aka '_Atomic enum __internal_enum \\*'} from incompatible pointer type 'struct s \\*'} } */\n+  ue_array_ptr1 = &s; /* { dg-error {assignment to 'user_enum \\(\\*\\)\\[10\\]' {aka 'enum __internal_enum \\(\\*\\)\\[10\\]'} from incompatible pointer type 'struct s \\*'} } */\n+  ue_array_ptr2 = &s; /* { dg-error {assignment to 'user_enum_copy \\(\\*\\)\\[10\\]' {aka 'enum __internal_enum \\(\\*\\)\\[10\\]'} from incompatible pointer type 'struct s \\*'} } */\n+  ue_fn_ptr1 = &s; /* { dg-error {assignment to 'user_enum \\(\\*\\)\\(void\\)' {aka 'enum __internal_enum \\(\\*\\)\\(void\\)'} from incompatible pointer type 'struct s \\*'} } */\n+  ue_fn_ptr2 = &s; /* { dg-error {assignment to 'void \\(\\*\\)\\(user_enum\\)' {aka 'void \\(\\*\\)\\(enum __internal_enum\\)'} from incompatible pointer type 'struct s \\*'} } */\n+  ue_fn_ptr3 = &s; /* { dg-error {assignment to 'void \\(\\*\\)\\(user_enum, \\.\\.\\.\\)' {aka 'void \\(\\*\\)\\(enum __internal_enum, \\.\\.\\.\\)'} from incompatible pointer type 'struct s \\*'} } */\n+  ue_fn_ptr4 = &s; /* { dg-error {assignment to 'user_enum_copy \\(\\*\\)\\(void\\)' {aka 'enum __internal_enum \\(\\*\\)\\(void\\)'} from incompatible pointer type 'struct s \\*'} } */\n+  ue_fn_ptr5 = &s; /* { dg-error {assignment to 'void \\(\\*\\)\\(user_enum_copy\\)' {aka 'void \\(\\*\\)\\(enum __internal_enum\\)'} from incompatible pointer type 'struct s \\*'} } */\n+  ue_fn_ptr6 = &s; /* { dg-error {assignment to 'void \\(\\*\\)\\(user_enum_copy, \\.\\.\\.\\)' {aka 'void \\(\\*\\)\\(enum __internal_enum, \\.\\.\\.\\)'} from incompatible pointer type 'struct s \\*'} } */\n+  unsafe_ue_fn_ptr1 = &s; /* { dg-error {assignment to 'user_enum \\(__attribute__\\(\\(transaction_unsafe\\)\\) \\*\\)\\(void\\)' {aka 'enum __internal_enum \\(__attribute__\\(\\(transaction_unsafe\\)\\) \\*\\)\\(void\\)'} from incompatible pointer type 'struct s \\*'} } */\n+  unsafe_ue_fn_ptr2 = &s; /* { dg-error {assignment to 'user_enum_copy \\(__attribute__\\(\\(transaction_unsafe\\)\\) \\*\\)\\(void\\)' {aka 'enum __internal_enum \\(__attribute__\\(\\(transaction_unsafe\\)\\) \\*\\)\\(void\\)'} from incompatible pointer type 'struct s \\*'} } */\n+\n+  us1 = s; /* { dg-error {assigning to type 'user_struct' {aka 'struct __internal_struct'} from type 'struct s'} } */\n+  us2 = s; /* { dg-error {assigning to type 'user_struct_copy' {aka 'struct __internal_struct'} from type 'struct s'} } */\n+  us_ptr1 = &s; /* { dg-error {assignment to 'user_struct_ptr' {aka 'struct __internal_struct \\*'} from incompatible pointer type 'struct s \\*'} } */\n+  us_ptr2 = &s; /* { dg-error {assignment to 'user_struct \\*' {aka 'struct __internal_struct \\*'} from incompatible pointer type 'struct s \\*'} } */\n+  const_us_ptr1 = &s; /* { dg-error {assignment to 'const user_struct \\*' {aka 'const struct __internal_struct \\*'} from incompatible pointer type 'struct s \\*'} } */\n+  const_us_ptr2 = &s; /* { dg-error {assignment to 'const user_struct_copy \\*' {aka 'const struct __internal_struct \\*'} from incompatible pointer type 'struct s \\*'} } */\n+\n+  uu1 = s; /* { dg-error {assigning to type 'user_union' {aka 'union __internal_union'} from type 'struct s'} } */\n+  uu2 = s; /* { dg-error {assigning to type 'user_union_copy' {aka 'union __internal_union'} from type 'struct s'} } */\n+  uu_ptr1 = &s; /* { dg-error {assignment to 'user_union_ptr' {aka 'union __internal_union \\*'} from incompatible pointer type 'struct s \\*'} } */\n+  uu_ptr2 = &s; /* { dg-error {assignment to 'user_union \\*' {aka 'union __internal_union \\*'} from incompatible pointer type 'struct s \\*'} } */\n+  const_uu_ptr1 = &s; /* { dg-error {assignment to 'const user_union \\*' {aka 'const union __internal_union \\*'} from incompatible pointer type 'struct s \\*'} } */\n+  const_uu_ptr2 = &s; /* { dg-error {assignment to 'const user_union_copy \\*' {aka 'const union __internal_union \\*'} from incompatible pointer type 'struct s \\*'} } */\n+\n+  uv1 = s; /* { dg-error {assigning to type 'user_vector' {aka '__vector\\([48]\\) unsigned int'} from type 'struct s'} } */\n+  uv2 = s; /* { dg-error {assigning to type 'user_vector_copy' {aka '__vector\\([48]\\) unsigned int'} from type 'struct s'} } */\n+  uv_ptr1 = &s; /* { dg-error {assignment to 'user_vector_ptr' {aka '__vector\\([48]\\) unsigned int \\*'} from incompatible pointer type 'struct s \\*'} } */\n+  uv_ptr2 = &s; /* { dg-error {assignment to 'user_vector \\*' {aka '__vector\\([48]\\) unsigned int \\*'} from incompatible pointer type 'struct s \\*'} } */\n+  const_uv_ptr1 = &s; /* { dg-error {assignment to 'const user_vector \\*' {aka 'const __vector\\([48]\\) unsigned int \\*'} from incompatible pointer type 'struct s \\*'} } */\n+  const_uv_ptr2 = &s; /* { dg-error {assignment to 'const user_vector_copy \\*' {aka 'const __vector\\([48]\\) unsigned int \\*'} from incompatible pointer type 'struct s \\*'} } */\n+\n+  ui1 = s; /* { dg-error {assigning to type 'user_int' {aka 'int'} from type 'struct s'} } */\n+  ui2 = s; /* { dg-error {assigning to type 'user_int_copy' {aka 'int'} from type 'struct s'} } */\n+  ui_ptr1 = &s; /* { dg-error {assignment to 'user_int_ptr' {aka 'int \\*'} from incompatible pointer type 'struct s \\*'} } */\n+  ui_ptr2 = &s; /* { dg-error {assignment to 'user_int \\*' {aka 'int \\*'} from incompatible pointer type 'struct s \\*'} } */\n+  const_ui_ptr1 = &s; /* { dg-error {assignment to 'const user_int \\*' {aka 'const int \\*'} from incompatible pointer type 'struct s \\*'} } */\n+  const_ui_ptr2 = &s; /* { dg-error {assignment to 'const user_int_copy \\*' {aka 'const int \\*'} from incompatible pointer type 'struct s \\*'} } */\n+  volatile_ui_ptr1 = &s; /* { dg-error {assignment to 'volatile user_int \\*' {aka 'volatile int \\*'} from incompatible pointer type 'struct s \\*'} } */\n+  volatile_ui_ptr2 = &s; /* { dg-error {assignment to 'volatile user_int_copy \\*' {aka 'volatile int \\*'} from incompatible pointer type 'struct s \\*'} } */\n+  atomic_ui_ptr1 = &s; /* { dg-error {assignment to '_Atomic user_int \\*' {aka '_Atomic int \\*'} from incompatible pointer type 'struct s \\*'} } */\n+  atomic_ui_ptr2 = &s; /* { dg-error {assignment to '_Atomic user_int_copy \\*' {aka '_Atomic int \\*'} from incompatible pointer type 'struct s \\*'} } */\n+  ui_array_ptr1 = &s; /* { dg-error {assignment to 'user_int \\(\\*\\)\\[10\\]' {aka 'int \\(\\*\\)\\[10\\]'} from incompatible pointer type 'struct s \\*'} } */\n+  ui_array_ptr2 = &s; /* { dg-error {assignment to 'user_int_copy \\(\\*\\)\\[10\\]' {aka 'int \\(\\*\\)\\[10\\]'} from incompatible pointer type 'struct s \\*'} } */\n+  ui_fn_ptr1 = &s; /* { dg-error {assignment to 'user_int \\(\\*\\)\\(void\\)' {aka 'int \\(\\*\\)\\(void\\)'} from incompatible pointer type 'struct s \\*'} } */\n+  ui_fn_ptr2 = &s; /* { dg-error {assignment to 'void \\(\\*\\)\\(user_int\\)' {aka 'void \\(\\*\\)\\(int\\)'} from incompatible pointer type 'struct s \\*'} } */\n+  ui_fn_ptr3 = &s; /* { dg-error {assignment to 'void \\(\\*\\)\\(user_int, \\.\\.\\.\\)' {aka 'void \\(\\*\\)\\(int, \\.\\.\\.\\)'} from incompatible pointer type 'struct s \\*'} } */\n+  ui_fn_ptr4 = &s; /* { dg-error {assignment to 'user_int_copy \\(\\*\\)\\(void\\)' {aka 'int \\(\\*\\)\\(void\\)'} from incompatible pointer type 'struct s \\*'} } */\n+  ui_fn_ptr5 = &s; /* { dg-error {assignment to 'void \\(\\*\\)\\(user_int_copy\\)' {aka 'void \\(\\*\\)\\(int\\)'} from incompatible pointer type 'struct s \\*'} } */\n+  ui_fn_ptr6 = &s; /* { dg-error {assignment to 'void \\(\\*\\)\\(user_int_copy, \\.\\.\\.\\)' {aka 'void \\(\\*\\)\\(int, \\.\\.\\.\\)'} from incompatible pointer type 'struct s \\*'} } */\n+  unsafe_ui_fn_ptr1 = &s; /* { dg-error {assignment to 'user_int \\(__attribute__\\(\\(transaction_unsafe\\)\\) \\*\\)\\(void\\)' {aka 'int \\(__attribute__\\(\\(transaction_unsafe\\)\\) \\*\\)\\(void\\)'} from incompatible pointer type 'struct s \\*'} } */\n+  unsafe_ui_fn_ptr2 = &s; /* { dg-error {assignment to 'user_int_copy \\(__attribute__\\(\\(transaction_unsafe\\)\\) \\*\\)\\(void\\)' {aka 'int \\(__attribute__\\(\\(transaction_unsafe\\)\\) \\*\\)\\(void\\)'} from incompatible pointer type 'struct s \\*'} } */\n+}"}, {"sha": "98dffead6a8f3a31b54fa7d01eda6ae349f1f235", "filename": "gcc/testsuite/gcc.target/aarch64/diag_aka_1.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56898e437a538c7edc0724a3650f5cb81c9d5721/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fdiag_aka_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56898e437a538c7edc0724a3650f5cb81c9d5721/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fdiag_aka_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fdiag_aka_1.c?ref=56898e437a538c7edc0724a3650f5cb81c9d5721", "patch": "@@ -8,7 +8,6 @@ void f (float x)\n   __Int8x8_t *ptr1 = &x; /* { dg-error {initialization of '__Int8x8_t \\*' from incompatible pointer type 'float \\*'} } */\n   int8x8_t y2 = x; /* { dg-error {incompatible types when initializing type 'int8x8_t' using type 'float'} } */\n   int8x8_t *ptr2 = &x; /* { dg-error {initialization of 'int8x8_t \\*' from incompatible pointer type 'float \\*'} } */\n-  /* ??? For these it would be better to print an aka for 'int16x4_t'.  */\n-  myvec y3 = x; /* { dg-error {incompatible types when initializing type 'myvec' using type 'float'} } */\n-  myvec *ptr3 = &x; /* { dg-error {initialization of 'myvec \\*' from incompatible pointer type 'float \\*'} } */\n+  myvec y3 = x; /* { dg-error {incompatible types when initializing type 'myvec' {aka 'int16x4_t'} using type 'float'} } */\n+  myvec *ptr3 = &x; /* { dg-error {initialization of 'myvec \\*' {aka 'int16x4_t \\*'} from incompatible pointer type 'float \\*'} } */\n }"}]}