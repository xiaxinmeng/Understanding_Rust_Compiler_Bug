{"sha": "af15298919fc249fc35fc33144271c560c74939c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWYxNTI5ODkxOWZjMjQ5ZmMzNWZjMzMxNDQyNzFjNTYwYzc0OTM5Yw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2004-04-08T13:23:50Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2004-04-08T13:23:50Z"}, "message": "[multiple changes]\n\n2004-04-08  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n\n\t* trans.c (tree_transform): Shortcut returning error_mark_node for\n\tstatements in annotate_only_mode.\n\t(tree_transform, case N_Label, case N_Return_Statement,\n\tN_Goto_Statement): Make statement tree instead of generating code.\n\t(tree_transform, case N_Assignment_Statement): No longer check\n\ttype_annotate_only.\n\t(gnat_expand_stmt, case GOTO_STMT, case LABEL_STMT, case\n\tRETURN_STMT): New.\n\t(first_nondeleted_insn, build_block_stmt, make_expr_stmt_from_rtl):\n\tNew fcns.\n\t(gnat_to_gnu): Collect any RTL generated and deal with it.\n\t(tree_transform, case N_And_Then): Refine when have non-null RTL_EXPR.\n\t(tree_transform case N_If_Statement): Rewrite to make IF_STMT.\n\t(gnat_expand_stmt, case BLOCK_STMT, IF_STMT): New cases.\n\n\t* ada-tree.def (GOTO_STMT, LABEL_STMT, RETURN_STMT): New tree nodes.\n\n\t* ada-tree.def (EXPR_STMT): Fix typo in name.\n\t(BLOCK_STMT, IF_STMT): New nodes.\n\n\t* ada-tree.h (GOTO_STMT_LABEL, LABEL_STMT_LABEL,\n\tLABEL_STMT_FIRST_IN_EH): New macros.\n\t(RETURN_STMT_EXPR): Likewise.\n\n\t* ada-tree.h: (BLOCK_STMT_LIST, IF_STMT_COND, IF_STMT_TRUE,\n\tIF_STMT_ELSEIF, IF_STMT_ELSE): New macros.\n\n2004-04-08  Thomas Quinot  <quinot@act-europe.fr>\n\n\t* atree.ads: Correct documentation on extended nodes.\n\n\t* link.c: Set run_path_option for FreeBSD.\n\n2004-04-08  Vincent Celier  <celier@gnat.com>\n\n\t* mlib-prj.adb (Build_Library.Check_Libs): On OpenVMS, if dec.ali is\n\tone of the ALI file, do not link with DEC lib.\n\n\t* par.adb Remove the last two characters (\"%s\" or \"%b\") when checking\n\tif a language defined unit may be recompiled.\n\n2004-04-08  Ed Schonberg  <schonberg@gnat.com>\n\n\t* sem_ch4.adb (Remove_Abstract_Operations): Improve error message when\n\tremoval of abstract operation leaves no possible interpretation for\n\texpression.\n\n\t* sem_eval.adb (Eval_Qualified_Expression): Use\n\tSet_Raises_Constraint_Error on node when needed, so that it does not\n\tget optimized away by subsequent optimizations.\n\n\t* sem_res.adb (Resolve_Intrinsic_Operator): Save interpretations of\n\toperands even when they are not wrapped in a type conversion.\n\n2004-04-08  Olivier Hainque  <hainque@act-europe.fr>\n\n\t* sem_prag.adb (Set_Exported): Warn about making static as result of\n\texport only when the export is coming from source. This may be not\n\tbe true e.g. on VMS where we expand export pragmas for exception codes\n\ttogether with imported or exported exceptions, and we don't want the\n\tuser to be warned about something he didn't write.\n\n2004-04-08  Thomas Quinot  <quinot@act-europe.fr>\n\n\t* sem_util.adb (Note_Possible_Modification): Reorganize to remove code\n\tduplication between normal entities and those declared as renamings.\n\tNo functional change.\n\n\t* s-fileio.ads (Form): Remove pragma Inline, as we cannot currently\n\tinline functions returning an unconstrained result.\n\n2004-04-08  Eric Botcazou  <ebotcazou@act-europe.fr>\n\n\t* utils.c (type_for_mode): Handle BLKmode and VOIDmode properly, to\n\tconform to what other front-ends do.\n\n2004-04-08  Doug Rupp  <rupp@gnat.com>\n\n\t* 5vml-tgt.adb: Use Gas instead of VMS Macro to build auto init shared\n\tlibraries.\n\nFrom-SVN: r80504", "tree": {"sha": "98ecce319b28000f5041a6bf64ba3936cb69b73c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/98ecce319b28000f5041a6bf64ba3936cb69b73c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/af15298919fc249fc35fc33144271c560c74939c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af15298919fc249fc35fc33144271c560c74939c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af15298919fc249fc35fc33144271c560c74939c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af15298919fc249fc35fc33144271c560c74939c/comments", "author": null, "committer": null, "parents": [{"sha": "2897f1d41141d67398e0647d9713d690c4368959", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2897f1d41141d67398e0647d9713d690c4368959", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2897f1d41141d67398e0647d9713d690c4368959"}], "stats": {"total": 608, "additions": 434, "deletions": 174}, "files": [{"sha": "851ccf761b7257ad7dae0e6de286c277def333a8", "filename": "gcc/ada/5vml-tgt.adb", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af15298919fc249fc35fc33144271c560c74939c/gcc%2Fada%2F5vml-tgt.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af15298919fc249fc35fc33144271c560c74939c/gcc%2Fada%2F5vml-tgt.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5vml-tgt.adb?ref=af15298919fc249fc35fc33144271c560c74939c", "patch": "@@ -50,15 +50,10 @@ package body MLib.Tgt is\n    --  Used to add the generated auto-init object files for auto-initializing\n    --  stand-alone libraries.\n \n-   Macro_Name   : constant String := \"macro\";\n+   Macro_Name   : constant String := \"mcr gnu:[bin]gcc -c -x assembler\";\n    --  The name of the command to invoke the macro-assembler\n \n-   --  Options to use when invoking gcc to build the dynamic library\n-\n-   No_Start_Files : aliased String := \"-nostartfiles\";\n-\n-   VMS_Options : Argument_List :=\n-     (No_Start_Files'Access, null);\n+   VMS_Options : Argument_List := (1 .. 1 => null);\n \n    Gnatsym_Name : constant String := \"gnatsym\";\n \n@@ -272,7 +267,7 @@ package body MLib.Tgt is\n            new String'(\"--for-linker=\" & Opt_File_Name & \"/OPTIONS\");\n       end if;\n \n-      VMS_Options (VMS_Options'First + 1) := For_Linker_Opt;\n+      VMS_Options (VMS_Options'First) := For_Linker_Opt;\n \n       for J in Inter'Range loop\n          To_Lower (Inter (J).all);\n@@ -293,7 +288,7 @@ package body MLib.Tgt is\n \n       if Auto_Init then\n          declare\n-            Macro_File_Name : constant String := Lib_Filename & \"$init.mar\";\n+            Macro_File_Name : constant String := Lib_Filename & \"$init.asm\";\n             Macro_File      : Ada.Text_IO.File_Type;\n             Init_Proc       : String := Lib_Filename & \"INIT\";\n             Popen_Result    : System.Address;\n@@ -319,13 +314,12 @@ package body MLib.Tgt is\n             begin\n                Create (Macro_File, Out_File, Macro_File_Name);\n \n-               Put_Line (Macro_File, ASCII.HT & \".EXTRN LIB$INITIALIZE\");\n-               Put_Line (Macro_File, ASCII.HT & \".EXTRN \" & Init_Proc);\n                Put_Line\n                  (Macro_File,\n-                  ASCII.HT & \".PSECT LIB$INITIALIZE USR,GBL,NOEXE,NOWRT,LONG\");\n-               Put_Line (Macro_File, ASCII.HT & \".ADDRESS \" & Init_Proc);\n-               Put_Line (Macro_File, ASCII.HT & \".END\");\n+                  ASCII.HT & \".section LIB$INITIALIZE,GBL,NOWRT\");\n+               Put_Line\n+                 (Macro_File,\n+                  ASCII.HT & \".long \" & Init_Proc);\n \n                Close (Macro_File);\n "}, {"sha": "0a24bc008c9783c8636a21c039cca51ff6f3b89d", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af15298919fc249fc35fc33144271c560c74939c/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af15298919fc249fc35fc33144271c560c74939c/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=af15298919fc249fc35fc33144271c560c74939c", "patch": "@@ -1,3 +1,86 @@\n+2004-04-08  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* trans.c (tree_transform): Shortcut returning error_mark_node for\n+\tstatements in annotate_only_mode.\n+\t(tree_transform, case N_Label, case N_Return_Statement,\n+\tN_Goto_Statement): Make statement tree instead of generating code.\n+\t(tree_transform, case N_Assignment_Statement): No longer check\n+\ttype_annotate_only.\n+\t(gnat_expand_stmt, case GOTO_STMT, case LABEL_STMT, case\n+\tRETURN_STMT): New.\n+\t(first_nondeleted_insn, build_block_stmt, make_expr_stmt_from_rtl):\n+\tNew fcns.\n+\t(gnat_to_gnu): Collect any RTL generated and deal with it.\n+\t(tree_transform, case N_And_Then): Refine when have non-null RTL_EXPR.\n+\t(tree_transform case N_If_Statement): Rewrite to make IF_STMT.\n+\t(gnat_expand_stmt, case BLOCK_STMT, IF_STMT): New cases.\n+\n+\t* ada-tree.def (GOTO_STMT, LABEL_STMT, RETURN_STMT): New tree nodes.\n+\n+\t* ada-tree.def (EXPR_STMT): Fix typo in name.\n+\t(BLOCK_STMT, IF_STMT): New nodes.\n+\n+\t* ada-tree.h (GOTO_STMT_LABEL, LABEL_STMT_LABEL,\n+\tLABEL_STMT_FIRST_IN_EH): New macros.\n+\t(RETURN_STMT_EXPR): Likewise.\n+\n+\t* ada-tree.h: (BLOCK_STMT_LIST, IF_STMT_COND, IF_STMT_TRUE,\n+\tIF_STMT_ELSEIF, IF_STMT_ELSE): New macros.\n+\n+2004-04-08  Thomas Quinot  <quinot@act-europe.fr>\n+\n+\t* atree.ads: Correct documentation on extended nodes.\n+\n+\t* link.c: Set run_path_option for FreeBSD.\n+\n+2004-04-08  Vincent Celier  <celier@gnat.com>\n+\n+\t* mlib-prj.adb (Build_Library.Check_Libs): On OpenVMS, if dec.ali is\n+\tone of the ALI file, do not link with DEC lib.\n+\n+\t* par.adb Remove the last two characters (\"%s\" or \"%b\") when checking\n+\tif a language defined unit may be recompiled.\n+\n+2004-04-08  Ed Schonberg  <schonberg@gnat.com>\n+\n+\t* sem_ch4.adb (Remove_Abstract_Operations): Improve error message when\n+\tremoval of abstract operation leaves no possible interpretation for\n+\texpression.\n+\n+\t* sem_eval.adb (Eval_Qualified_Expression): Use\n+\tSet_Raises_Constraint_Error on node when needed, so that it does not\n+\tget optimized away by subsequent optimizations.\n+\n+\t* sem_res.adb (Resolve_Intrinsic_Operator): Save interpretations of\n+\toperands even when they are not wrapped in a type conversion.\n+\n+2004-04-08  Olivier Hainque  <hainque@act-europe.fr>\n+\n+\t* sem_prag.adb (Set_Exported): Warn about making static as result of\n+\texport only when the export is coming from source. This may be not\n+\tbe true e.g. on VMS where we expand export pragmas for exception codes\n+\ttogether with imported or exported exceptions, and we don't want the\n+\tuser to be warned about something he didn't write.\n+\n+2004-04-08  Thomas Quinot  <quinot@act-europe.fr>\n+\n+\t* sem_util.adb (Note_Possible_Modification): Reorganize to remove code\n+\tduplication between normal entities and those declared as renamings.\n+\tNo functional change.\n+\n+\t* s-fileio.ads (Form): Remove pragma Inline, as we cannot currently\t\n+\tinline functions returning an unconstrained result.\n+\n+2004-04-08  Eric Botcazou  <ebotcazou@act-europe.fr>\n+\n+\t* utils.c (type_for_mode): Handle BLKmode and VOIDmode properly, to\n+\tconform to what other front-ends do.\n+\n+2004-04-08  Doug Rupp  <rupp@gnat.com>\n+\n+\t* 5vml-tgt.adb: Use Gas instead of VMS Macro to build auto init shared\n+\tlibraries.\n+\n 2004-04-06  Pascal Obry  <obry@gnat.com>\n \n \t* adaint.c (DIR_SEPARATOR): Properly set DIR_SEPARATOR on Win32."}, {"sha": "e58963ed20ae675b320146aa7dc289ff3f3b32fa", "filename": "gcc/ada/ada-tree.def", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af15298919fc249fc35fc33144271c560c74939c/gcc%2Fada%2Fada-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af15298919fc249fc35fc33144271c560c74939c/gcc%2Fada%2Fada-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fada-tree.def?ref=af15298919fc249fc35fc33144271c560c74939c", "patch": "@@ -84,4 +84,26 @@ DEFTREECODE (GNAT_LOOP_ID, \"gnat_loop_id\", 'x', 0)\n    We start with an expression statement, whose only operand is an\n    expression, EXPR_STMT_EXPR, Execution of the statement means evaluation of\n    the expression (such as a MODIFY_EXPR) and discarding its result.  */\n-DEFTREECODE (EXPR_STMT, \"expr_stmt_expr\", 's', 1)\n+DEFTREECODE (EXPR_STMT, \"expr_stmt\", 's', 1)\n+\n+/* This represents a list of statements.  BLOCK_STMT_LIST is a list\n+   statement tree, chained via TREE_CHAIN.  */\n+DEFTREECODE (BLOCK_STMT, \"block_stmt\", 's', 1)\n+\n+/* This is an IF statement.  IF_STMT_COND is the condition being tested,\n+   IF_STMT_TRUE is the statement to be executed if the condition is\n+   true; IF_STMT_ELSEIF, if non-null, is a list of more IF_STMT nodes (where\n+   we only look at IF_STMT_COND and IF_STMT_TRUE) that correspond to\n+   any \"else if\" parts; and IF_STMT_ELSE is the statement to be executed if\n+   all conditions are.  */\n+DEFTREECODE (IF_STMT, \"if_stmt\", 's', 4)\n+\n+/* A goto just points to the label: GOTO_STMT_LABEL.  */\n+DEFTREECODE (GOTO_STMT, \"goto_stmt\", 's', 1)\n+\n+/* A label: LABEL_STMT_LABEL is the label and LABEL_STMT_FIRST_IN_EH is set\n+   if this is the first label of an exception handler.  */\n+DEFTREECODE (LABEL_STMT, \"label_stmt\", 's', 1)\n+\n+/* A \"return\".  RETURN_STMT_EXPR is the value to return if non-null.  */\n+DEFTREECODE (RETURN_STMT, \"return_stmt\", 's', 1)"}, {"sha": "572a5b72e295e0f779189fb9c826f2dca2affaed", "filename": "gcc/ada/ada-tree.h", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af15298919fc249fc35fc33144271c560c74939c/gcc%2Fada%2Fada-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af15298919fc249fc35fc33144271c560c74939c/gcc%2Fada%2Fada-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fada-tree.h?ref=af15298919fc249fc35fc33144271c560c74939c", "patch": "@@ -294,5 +294,15 @@ struct lang_type GTY(())\n /* We store the Sloc in statement nodes.  */\n #define TREE_SLOC(NODE)\t\tTREE_COMPLEXITY (STMT_CHECK (NODE))\n \n-/* There is just one field in an EXPR_STMT: the expression.  */\n #define EXPR_STMT_EXPR(NODE)\tTREE_OPERAND_CHECK_CODE (NODE, EXPR_STMT, 0)\n+#define BLOCK_STMT_LIST(NODE)\tTREE_OPERAND_CHECK_CODE (NODE, BLOCK_STMT, 0)\n+#define IF_STMT_COND(NODE)\tTREE_OPERAND_CHECK_CODE (NODE, IF_STMT, 0)\n+#define IF_STMT_TRUE(NODE)\tTREE_OPERAND_CHECK_CODE (NODE, IF_STMT, 1)\n+#define IF_STMT_ELSEIF(NODE)\tTREE_OPERAND_CHECK_CODE (NODE, IF_STMT, 2)\n+#define IF_STMT_ELSE(NODE)\tTREE_OPERAND_CHECK_CODE (NODE, IF_STMT, 3)\n+#define GOTO_STMT_LABEL(NODE)\tTREE_OPERAND_CHECK_CODE (NODE, GOTO_STMT, 0)\n+#define LABEL_STMT_LABEL(NODE)\tTREE_OPERAND_CHECK_CODE (NODE, LABEL_STMT, 0)\n+#define LABEL_STMT_FIRST_IN_EH(NODE) \\\n+  (LABEL_STMT_CHECK (NODE)->common.unsigned_flag)\n+#define RETURN_STMT_EXPR(NODE)\tTREE_OPERAND_CHECK_CODE (NODE, RETURN_STMT, 0)\n+"}, {"sha": "0f38e3ee491b4ad55f8e608be0b5f9017b710fc5", "filename": "gcc/ada/atree.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af15298919fc249fc35fc33144271c560c74939c/gcc%2Fada%2Fatree.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af15298919fc249fc35fc33144271c560c74939c/gcc%2Fada%2Fatree.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.ads?ref=af15298919fc249fc35fc33144271c560c74939c", "patch": "@@ -495,7 +495,7 @@ package Atree is\n    function Extend_Node (Node : Node_Id) return Entity_Id;\n    --  This function returns a copy of its input node with an extension\n    --  added. The fields of the extension are set to Empty. Due to the way\n-   --  extensions are handled (as two consecutive array elements), it may\n+   --  extensions are handled (as four consecutive array elements), it may\n    --  be necessary to reallocate the node, so that the returned value is\n    --  not the same as the input value, but where possible the returned\n    --  value will be the same as the input value (i.e. the extension will"}, {"sha": "e16978eca3e01f66d505bae4424338ddec90687d", "filename": "gcc/ada/link.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af15298919fc249fc35fc33144271c560c74939c/gcc%2Fada%2Flink.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af15298919fc249fc35fc33144271c560c74939c/gcc%2Fada%2Flink.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flink.c?ref=af15298919fc249fc35fc33144271c560c74939c", "patch": "@@ -156,7 +156,7 @@ const char *object_library_extension = \".a\";\n \n #elif defined (__FreeBSD__)\n char *object_file_option = \"\";\n-char *run_path_option = \"\";\n+char *run_path_option = \"-Wl,-rpath,\";\n char shared_libgnat_default = STATIC;\n int link_max = 2147483647;\n unsigned char objlist_file_supported = 0;"}, {"sha": "612845c7f1f1c2bce7096570ecd9ad467e1ecb29", "filename": "gcc/ada/mlib-prj.adb", "status": "modified", "additions": 20, "deletions": 8, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af15298919fc249fc35fc33144271c560c74939c/gcc%2Fada%2Fmlib-prj.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af15298919fc249fc35fc33144271c560c74939c/gcc%2Fada%2Fmlib-prj.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-prj.adb?ref=af15298919fc249fc35fc33144271c560c74939c", "patch": "@@ -308,6 +308,9 @@ package body MLib.Prj is\n       Libdecgnat_Needed : Boolean := False;\n       --  On OpenVMS, set to True if library needs to be linked with libdecgnat\n \n+      Check_Libdecgnat : Boolean := Hostparm.OpenVMS;\n+      --  Set to False if package Dec is part of the library sources.\n+\n       Data : Project_Data := Projects.Table (For_Project);\n \n       Object_Directory_Path : constant String :=\n@@ -372,7 +375,8 @@ package body MLib.Prj is\n       --  to link with -lgnarl (this is the case when there is a dependency\n       --  on s-osinte.ads). On OpenVMS, set Libdecgnat_Needed if the ALI file\n       --  indicates that there is a need to link with -ldecgnat (this is the\n-      --  case when there is a dependency on dec.ads).\n+      --  case when there is a dependency on dec.ads, except when it is the\n+      --  DEC library, the one that contains package DEC).\n \n       procedure Process (The_ALI : File_Name_Type);\n       --  Check if the closure of a library unit which is or should be in the\n@@ -504,12 +508,17 @@ package body MLib.Prj is\n          Text     : Text_Buffer_Ptr;\n          Id       : ALI.ALI_Id;\n \n-         pragma Warnings (Off, Id);\n-         --  Comment needed ???\n-\n       begin\n+         --  On OpenVMS, if we have package DEC, it means this is the DEC lib:\n+         --  no need to link with itself.\n+\n+         if Check_Libdecgnat and then ALI_File = \"dec.ali\" then\n+            Check_Libdecgnat := False;\n+            Libdecgnat_Needed := False;\n+         end if;\n+\n          if not Libgnarl_Needed or\n-           (Hostparm.OpenVMS and then (not Libdecgnat_Needed))\n+           (Check_Libdecgnat and then (not Libdecgnat_Needed))\n          then\n             --  Scan the ALI file\n \n@@ -526,15 +535,15 @@ package body MLib.Prj is\n                           Read_Lines => \"D\");\n             Free (Text);\n \n-            --  Look for s-osinte.ads in the dependencies\n+            --  Look for s-osinte.ads and dec.ads in the dependencies\n \n             for Index in ALI.ALIs.Table (Id).First_Sdep ..\n                          ALI.ALIs.Table (Id).Last_Sdep\n             loop\n                if ALI.Sdep.Table (Index).Sfile = S_Osinte_Ads then\n                   Libgnarl_Needed := True;\n \n-               elsif Hostparm.OpenVMS and then\n+               elsif Check_Libdecgnat and then\n                      ALI.Sdep.Table (Index).Sfile = S_Dec_Ads\n                then\n                   Libdecgnat_Needed := True;\n@@ -1941,7 +1950,10 @@ package body MLib.Prj is\n       end if;\n \n       Status := fclose (Fd);\n-      --  Is it really right to ignore any close error ???\n+\n+      --  It is safe to ignore any error when closing, because the file was\n+      --  only opened for reading.\n+\n    end Process_Binder_File;\n \n    ------------------"}, {"sha": "2d86577a48c230b095e44d4e4f618a6500c550f8", "filename": "gcc/ada/par.adb", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af15298919fc249fc35fc33144271c560c74939c/gcc%2Fada%2Fpar.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af15298919fc249fc35fc33144271c560c74939c/gcc%2Fada%2Fpar.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar.adb?ref=af15298919fc249fc35fc33144271c560c74939c", "patch": "@@ -1310,16 +1310,24 @@ begin\n                  and then not GNAT_Mode\n                then\n                   declare\n-                     Name : constant String :=\n-                              Get_Name_String\n-                               (Unit_Name (Current_Source_Unit));\n+                     Uname : constant String :=\n+                               Get_Name_String\n+                                 (Unit_Name (Current_Source_Unit));\n+                     Name : String (1 .. Uname'Length - 2);\n+\n                   begin\n-                     if (Name = \"ada\"                  or else\n-                         Name = \"calendar\"             or else\n-                         Name = \"interfaces\"           or else\n-                         Name = \"system\"               or else\n-                         Name = \"machine_code\"         or else\n-                         Name = \"unchecked_conversion\" or else\n+                     --  Because Unit_Name includes \"%s\" or \"%b\", we need to\n+                     --  strip the last two characters to get the real unit\n+                     --  name.\n+\n+                     Name := Uname (Uname'First .. Uname'Last - 2);\n+\n+                     if (Name = \"ada\"                    or else\n+                         Name = \"calendar\"               or else\n+                         Name = \"interfaces\"             or else\n+                         Name = \"system\"                 or else\n+                         Name = \"machine_code\"           or else\n+                         Name = \"unchecked_conversion\"   or else\n                          Name = \"unchecked_deallocation\"\n                            or else (Name'Length > 4\n                                      and then"}, {"sha": "dbbc8bfa3910251c272369c68db902354c4a7062", "filename": "gcc/ada/s-fileio.ads", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af15298919fc249fc35fc33144271c560c74939c/gcc%2Fada%2Fs-fileio.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af15298919fc249fc35fc33144271c560c74939c/gcc%2Fada%2Fs-fileio.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-fileio.ads?ref=af15298919fc249fc35fc33144271c560c74939c", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2002, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2004, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -250,7 +250,6 @@ package System.File_IO is\n private\n    pragma Inline (Check_Read_Status);\n    pragma Inline (Check_Write_Status);\n-   pragma Inline (Form);\n    pragma Inline (Mode);\n \n end System.File_IO;"}, {"sha": "2b958a839c9e477890f3619728a1d574d352dae2", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af15298919fc249fc35fc33144271c560c74939c/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af15298919fc249fc35fc33144271c560c74939c/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=af15298919fc249fc35fc33144271c560c74939c", "patch": "@@ -4332,7 +4332,7 @@ package body Sem_Ch4 is\n    procedure Remove_Abstract_Operations (N : Node_Id) is\n       I               : Interp_Index;\n       It              : Interp;\n-      Has_Abstract_Op : Boolean := False;\n+      Abstract_Op     : Entity_Id := Empty;\n \n       --  AI-310: If overloaded, remove abstract non-dispatching\n       --  operations.\n@@ -4347,7 +4347,7 @@ package body Sem_Ch4 is\n               and then Is_Abstract (It.Nam)\n               and then not Is_Dispatching_Operation (It.Nam)\n             then\n-               Has_Abstract_Op := True;\n+               Abstract_Op := It.Nam;\n                Remove_Interp (I);\n                exit;\n             end if;\n@@ -4359,7 +4359,7 @@ package body Sem_Ch4 is\n          --  always added to the overload set, unless it is a universal\n          --  operation.\n \n-         if not Has_Abstract_Op then\n+         if No (Abstract_Op) then\n             return;\n \n          elsif Nkind (N) in N_Op then\n@@ -4398,10 +4398,9 @@ package body Sem_Ch4 is\n \n             begin\n                if Present (Universal_Interpretation (Arg1))\n-                 or else\n-                   (Present (Next (Arg1))\n-                     and then\n-                       Present (Universal_Interpretation (Next (Arg1))))\n+                 and then\n+                   (No (Next (Arg1))\n+                     or else Present (Universal_Interpretation (Next (Arg1))))\n                then\n                   return;\n \n@@ -4417,6 +4416,23 @@ package body Sem_Ch4 is\n                end if;\n             end;\n          end if;\n+\n+         --  If the removal has left no valid interpretations, emit\n+         --  error message now an label node as illegal.\n+\n+         if Present (Abstract_Op) then\n+            Get_First_Interp (N, I, It);\n+\n+            if No (It.Nam) then\n+\n+               --  Removal of abstract operation left no viable candidate.\n+\n+               Set_Etype (N, Any_Type);\n+               Error_Msg_Sloc := Sloc (Abstract_Op);\n+               Error_Msg_NE\n+                 (\"cannot call abstract operation& declared#\", N, Abstract_Op);\n+            end if;\n+         end if;\n       end if;\n    end Remove_Abstract_Operations;\n "}, {"sha": "9c2031013428923e653114fa6240a10c6c8d0324", "filename": "gcc/ada/sem_eval.adb", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af15298919fc249fc35fc33144271c560c74939c/gcc%2Fada%2Fsem_eval.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af15298919fc249fc35fc33144271c560c74939c/gcc%2Fada%2Fsem_eval.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.adb?ref=af15298919fc249fc35fc33144271c560c74939c", "patch": "@@ -1947,6 +1947,13 @@ package body Sem_Eval is\n         or else Nkind (Parent (N)) = N_Allocator\n       then\n          Check_Non_Static_Context (Operand);\n+\n+         --  If operand is known to raise constraint_error, set the\n+         --  flag on the expression so it does not get optimized away.\n+\n+         if Nkind (Operand) = N_Raise_Constraint_Error then\n+            Set_Raises_Constraint_Error (N);\n+         end if;\n          return;\n       end if;\n "}, {"sha": "ea1eab3405ab2c14aa6c184a20f7b599b85bd1d1", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af15298919fc249fc35fc33144271c560c74939c/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af15298919fc249fc35fc33144271c560c74939c/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=af15298919fc249fc35fc33144271c560c74939c", "patch": "@@ -3555,7 +3555,15 @@ package body Sem_Prag is\n                Set_Is_Public (E);\n                Set_Is_Statically_Allocated (E);\n \n-               if Warn_On_Export_Import then\n+               --  Warn if the corresponding W flag is set and the pragma\n+               --  comes from source. The latter may be not be true e.g. on\n+               --  VMS where we expand export pragmas for exception codes\n+               --  associated with imported or exported exceptions. We don't\n+               --  want the user to be warned about something he didn't write.\n+\n+               if Warn_On_Export_Import\n+                 and then Comes_From_Source (Arg)\n+               then\n                   Error_Msg_NE\n                     (\"?& has been made static as a result of Export\", Arg, E);\n                   Error_Msg_N"}, {"sha": "103ebfdd9474825edbdcff486eb8e5828d243d27", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af15298919fc249fc35fc33144271c560c74939c/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af15298919fc249fc35fc33144271c560c74939c/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=af15298919fc249fc35fc33144271c560c74939c", "patch": "@@ -4965,6 +4965,7 @@ package body Sem_Res is\n       end loop;\n \n       Set_Entity (N, Op);\n+      Set_Is_Overloaded (N, False);\n \n       --  If the operand type is private, rewrite with suitable\n       --  conversions on the operands and the result, to expose\n@@ -4993,17 +4994,21 @@ package body Sem_Res is\n         or else Typ /= Etype (Right_Opnd (N))\n       then\n          --  Add explicit conversion where needed, and save interpretations\n-         --  if operands are overloaded.\n+         --  in case operands are overloaded.\n \n-         Arg1 := Convert_To (Typ, Left_Opnd (N));\n+         Arg1 := Convert_To (Typ, Left_Opnd  (N));\n          Arg2 := Convert_To (Typ, Right_Opnd (N));\n \n          if Nkind (Arg1) = N_Type_Conversion then\n             Save_Interps (Left_Opnd (N), Expression (Arg1));\n+         else\n+            Save_Interps (Left_Opnd (N), Arg1);\n          end if;\n \n          if Nkind (Arg2) = N_Type_Conversion then\n             Save_Interps (Right_Opnd (N), Expression (Arg2));\n+         else\n+            Save_Interps (Right_Opnd (N), Arg1);\n          end if;\n \n          Rewrite (Left_Opnd  (N), Arg1);"}, {"sha": "a3adc6ed3cb706d77b1f8a723b3b984b96751459", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 19, "deletions": 39, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af15298919fc249fc35fc33144271c560c74939c/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af15298919fc249fc35fc33144271c560c74939c/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=af15298919fc249fc35fc33144271c560c74939c", "patch": "@@ -4985,41 +4985,12 @@ package body Sem_Util is\n       Ent : Entity_Id;\n       Exp : Node_Id;\n \n-      procedure Set_Ref (E : Entity_Id; N : Node_Id);\n-      --  Internal routine to note modification on entity E by node N\n-      --  Has no effect if entity E does not represent an object.\n-\n-      -------------\n-      -- Set_Ref --\n-      -------------\n-\n-      procedure Set_Ref (E : Entity_Id; N : Node_Id) is\n-      begin\n-         if Is_Object (E) then\n-            if Comes_From_Source (N)\n-              or else Modification_Comes_From_Source\n-            then\n-               Set_Never_Set_In_Source (E, False);\n-            end if;\n-\n-            Set_Is_True_Constant    (E, False);\n-            Set_Current_Value       (E, Empty);\n-            Generate_Reference      (E, N, 'm');\n-            Kill_Checks             (E);\n-\n-            if not Can_Never_Be_Null (E) then\n-               Set_Is_Known_Non_Null (E, False);\n-            end if;\n-         end if;\n-      end Set_Ref;\n-\n-   --  Start of processing for Note_Possible_Modification\n-\n    begin\n       --  Loop to find referenced entity, if there is one\n \n       Exp := N;\n       loop\n+         <<Continue>>\n          Ent := Empty;\n \n          if Is_Entity_Name (Exp) then\n@@ -5074,24 +5045,33 @@ package body Sem_Util is\n          --  Now look for entity being referenced\n \n          if Present (Ent) then\n-            if (Ekind (Ent) = E_Variable or else Ekind (Ent) = E_Constant)\n-              and then Present (Renamed_Object (Ent))\n-            then\n-               Set_Never_Set_In_Source (Ent, False);\n+\n+            if Is_Object (Ent) then\n+               if Comes_From_Source (Exp)\n+                 or else Modification_Comes_From_Source\n+               then\n+                  Set_Never_Set_In_Source (Ent, False);\n+               end if;\n+\n                Set_Is_True_Constant    (Ent, False);\n                Set_Current_Value       (Ent, Empty);\n \n                if not Can_Never_Be_Null (Ent) then\n                   Set_Is_Known_Non_Null (Ent, False);\n                end if;\n \n-               Exp := Renamed_Object (Ent);\n+               if (Ekind (Ent) = E_Variable or else Ekind (Ent) = E_Constant)\n+                 and then Present (Renamed_Object (Ent))\n+               then\n+                  Exp := Renamed_Object (Ent);\n+                  goto Continue;\n+               end if;\n \n-            else\n-               Set_Ref (Ent, Exp);\n-               Kill_Checks (Ent);\n-               return;\n+               Generate_Reference (Ent, Exp, 'm');\n             end if;\n+\n+            Kill_Checks (Ent);\n+            return;\n          end if;\n       end loop;\n    end Note_Possible_Modification;"}, {"sha": "8b24761c3a5b5b5b127b6815b64dcafee075915e", "filename": "gcc/ada/trans.c", "status": "modified", "additions": 199, "deletions": 87, "changes": 286, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af15298919fc249fc35fc33144271c560c74939c/gcc%2Fada%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af15298919fc249fc35fc33144271c560c74939c/gcc%2Fada%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftrans.c?ref=af15298919fc249fc35fc33144271c560c74939c", "patch": "@@ -104,6 +104,9 @@ Node_Id error_gnat_node;\n static GTY(()) tree gnu_return_label_stack;\n \n static tree tree_transform (Node_Id);\n+static rtx first_nondeleted_insn (rtx);\n+static tree build_block_stmt (List_Id);\n+static tree make_expr_stmt_from_rtl (rtx, Node_Id);\n static void elaborate_all_entities (Node_Id);\n static void process_freeze_entity (Node_Id);\n static void process_inlined_subprograms (Node_Id);\n@@ -255,15 +258,60 @@ tree\n gnat_to_gnu (Node_Id gnat_node)\n {\n   tree gnu_root;\n+  bool made_sequence = false;\n+    \n+  /* We support the use of this on statements now as a transition\n+     to full function-at-a-time processing.  So we need to see if anything\n+     we do generates RTL and returns error_mark_node.  */\n+  if (!global_bindings_p ())\n+    {\n+      start_sequence ();\n+      emit_note (NOTE_INSN_DELETED);\n+      made_sequence = true;\n+    }\n \n   /* Save node number in case error */\n   error_gnat_node = gnat_node;\n \n   gnu_root = tree_transform (gnat_node);\n \n-  /* If we got no code as a result, something is wrong.  */\n-  if (gnu_root == error_mark_node && ! type_annotate_only)\n-    gigi_abort (303);\n+  if (gnu_root == error_mark_node)\n+    {\n+      if (!made_sequence)\n+\t{\n+\t  if (type_annotate_only)\n+\t    return gnu_root;\n+\t  else\n+\t    gigi_abort (303);\n+\t}\n+\n+      gnu_root = make_expr_stmt_from_rtl (first_nondeleted_insn (get_insns ()),\n+\t\t\t\t\t  gnat_node);\n+      end_sequence ();\n+    }\n+  else if (made_sequence)\n+    {\n+      rtx insns = first_nondeleted_insn (get_insns ());\n+\n+      end_sequence ();\n+\n+      if (insns)\n+\t{\n+\t  /* If we have a statement, we need to first evaluate any RTL we\n+\t     made in the process of building it and then the statement.  */\n+\t  if (IS_STMT (gnu_root))\n+\t    {\n+\t      tree gnu_expr_stmt = make_expr_stmt_from_rtl (insns, gnat_node);\n+\n+\t      TREE_CHAIN (gnu_expr_stmt) = gnu_root;\n+\t      gnu_root = build_nt (BLOCK_STMT, gnu_expr_stmt);\n+\t      TREE_TYPE (gnu_root) = void_type_node;\n+\t      TREE_SLOC (gnu_root) = Sloc (gnat_node);\n+\t    }\n+\t  else\n+\t    emit_insn (insns);\n+\t}\n+    }\n \n   return gnu_root;\n }\n@@ -290,6 +338,10 @@ tree_transform (Node_Id gnat_node)\n   /* Set input_file_name and lineno from the Sloc in the GNAT tree. */\n   set_lineno (gnat_node, 0);\n \n+  if (IN (Nkind (gnat_node), N_Statement_Other_Than_Procedure_Call)\n+      && type_annotate_only)\n+    return error_mark_node;\n+\n   /* If this is a Statement and we are at top level, we add the statement\n      as an elaboration for a null tree.  That will cause it to be placed\n      in the elaboration procedure.  */\n@@ -1795,7 +1847,7 @@ tree_transform (Node_Id gnat_node)\n \n \tgnu_result_type = get_unpadded_type (Etype (gnat_node));\n \n-\tif (RTL_EXPR_SEQUENCE (gnu_rhs_side) != 0)\n+\tif (first_nondeleted_insn (RTL_EXPR_SEQUENCE (gnu_rhs_side)))\n \t  gnu_rhs = build (COMPOUND_EXPR, gnu_result_type, gnu_rhs_side,\n \t\t\t   gnu_rhs);\n \n@@ -2020,31 +2072,17 @@ tree_transform (Node_Id gnat_node)\n     /***************************/\n \n     case N_Label:\n-      if (! type_annotate_only)\n-\t{\n-\t  tree gnu_label = gnat_to_gnu (Identifier (gnat_node));\n-\t  Node_Id gnat_parent = Parent (gnat_node);\n-\n-\t  expand_label (gnu_label);\n-\n-\t  /* If this is the first label of an exception handler, we must\n-\t     mark that any CALL_INSN can jump to it.  */\n-\t  if (Present (gnat_parent)\n-\t      && Nkind (gnat_parent) == N_Exception_Handler\n-\t      && First (Statements (gnat_parent)) == gnat_node)\n-\t    nonlocal_goto_handler_labels\n-\t      = gen_rtx_EXPR_LIST (VOIDmode, label_rtx (gnu_label),\n-\t\t\t\t   nonlocal_goto_handler_labels);\n-\t}\n+      gnu_result = build_nt (LABEL_STMT, gnat_to_gnu (Identifier (gnat_node)));\n+      LABEL_STMT_FIRST_IN_EH (gnu_result)\n+\t=  (Present (Parent (gnat_node))\n+\t    && Nkind (Parent (gnat_node)) == N_Exception_Handler\n+\t    && First (Statements (Parent (gnat_node))) == gnat_node);\n       break;\n \n     case N_Null_Statement:\n       break;\n \n     case N_Assignment_Statement:\n-      if (type_annotate_only)\n-\tbreak;\n-\n       /* Get the LHS and RHS of the statement and convert any reference to an\n \t unconstrained array into a reference to the underlying array.  */\n       gnu_lhs = maybe_unconstrained_array (gnat_to_gnu (Name (gnat_node)));\n@@ -2071,53 +2109,28 @@ tree_transform (Node_Id gnat_node)\n       break;\n \n     case N_If_Statement:\n-      /* Start an IF statement giving the condition.  */\n-      gnu_expr = gnat_to_gnu (Condition (gnat_node));\n-      set_lineno (gnat_node, 1);\n-      expand_start_cond (gnu_expr, 0);\n-\n-      /* Generate code for the statements to be executed if the condition\n-\t is true.  */\n+      gnu_result = NULL_TREE;\n \n-      for (gnat_temp = First (Then_Statements (gnat_node));\n-\t   Present (gnat_temp);\n-\t   gnat_temp = Next (gnat_temp))\n-\tgnat_to_code (gnat_temp);\n-\n-      /* Generate each of the \"else if\" parts.  */\n+      /* Make an IF_STMT for each of the \"else if\" parts.  */\n       if (Present (Elsif_Parts (gnat_node)))\n-\t{\n-\t  for (gnat_temp = First (Elsif_Parts (gnat_node));\n-\t       Present (gnat_temp);\n-\t       gnat_temp = Next (gnat_temp))\n-\t    {\n-\t      Node_Id gnat_statement;\n-\n-\t      expand_start_else ();\n-\n-\t      /* Set up the line numbers for each condition we test.  */\n-\t      set_lineno (Condition (gnat_temp), 1);\n-\t      expand_elseif (gnat_to_gnu (Condition (gnat_temp)));\n-\n-\t      for (gnat_statement = First (Then_Statements (gnat_temp));\n-\t\t   Present (gnat_statement);\n-\t\t   gnat_statement = Next (gnat_statement))\n-\t\tgnat_to_code (gnat_statement);\n-\t    }\n-\t}\n-\n-      /* Finally, handle any statements in the \"else\" part.  */\n-      if (Present (Else_Statements (gnat_node)))\n-\t{\n-\t  expand_start_else ();\n-\n-\t  for (gnat_temp = First (Else_Statements (gnat_node));\n-\t       Present (gnat_temp);\n-\t       gnat_temp = Next (gnat_temp))\n-\t    gnat_to_code (gnat_temp);\n-\t}\n+\tfor (gnat_temp = First (Elsif_Parts (gnat_node));\n+\t     Present (gnat_temp); gnat_temp = Next (gnat_temp))\n+\t  {\n+\t    tree gnu_elseif\n+\t      = build_nt (IF_STMT, gnat_to_gnu (Condition (gnat_temp)),\n+\t\t\t  build_block_stmt (Then_Statements (gnat_temp)),\n+\t\t\t  NULL_TREE, NULL_TREE);\n+\n+\t    TREE_SLOC (gnu_elseif) = Sloc (Condition (gnat_temp));\n+\t    TREE_CHAIN (gnu_elseif) = gnu_result;\n+\t    TREE_TYPE (gnu_elseif) = void_type_node;\n+\t    gnu_result = gnu_elseif;\n+\t  }\n \n-      expand_end_cond ();\n+      gnu_result = build_nt (IF_STMT, gnat_to_gnu (Condition (gnat_node)),\n+\t\t\t     build_block_stmt (Then_Statements (gnat_node)),\n+\t\t\t     nreverse (gnu_result),\n+\t\t\t     build_block_stmt (Else_Statements (gnat_node)));\n       break;\n \n     case N_Case_Statement:\n@@ -2456,9 +2469,6 @@ tree_transform (Node_Id gnat_node)\n       break;\n \n     case N_Return_Statement:\n-      if (type_annotate_only)\n-\tbreak;\n-\n       {\n \t/* The gnu function type of the subprogram currently processed.  */\n \ttree gnu_subprog_type = TREE_TYPE (current_function_decl);\n@@ -2478,7 +2488,11 @@ tree_transform (Node_Id gnat_node)\n \t   a branch to that label.  */\n \n \tif (TREE_VALUE (gnu_return_label_stack) != 0)\n-\t  expand_goto (TREE_VALUE (gnu_return_label_stack));\n+\t  {\n+\t    gnu_result = build_nt (GOTO_STMT,\n+\t\t\t\t   TREE_VALUE (gnu_return_label_stack));\n+\t    break;\n+\t  }\n \n \telse if (TYPE_CI_CO_LIST (gnu_subprog_type) != NULL_TREE)\n \t  {\n@@ -2538,25 +2552,12 @@ tree_transform (Node_Id gnat_node)\n \t      }\n \t  }\n \n-\tset_lineno (gnat_node, 1);\n-\tif (gnu_ret_val)\n-\t  expand_return (build_binary_op (MODIFY_EXPR, NULL_TREE,\n-\t\t\t\t\t  DECL_RESULT (current_function_decl),\n-\t\t\t\t\t  gnu_ret_val));\n-\telse\n-\t  expand_null_return ();\n-\n+\tgnu_result = build_nt (RETURN_STMT, gnu_ret_val);\n       }\n       break;\n \n     case N_Goto_Statement:\n-      if (type_annotate_only)\n-\tbreak;\n-\n-      gnu_expr = gnat_to_gnu (Name (gnat_node));\n-      TREE_USED (gnu_expr) = 1;\n-      set_lineno (gnat_node, 1);\n-      expand_goto (gnu_expr);\n+      gnu_result = build_nt (GOTO_STMT, gnat_to_gnu (Name (gnat_node)));\n       break;\n \n     /****************************/\n@@ -4174,19 +4175,130 @@ tree_transform (Node_Id gnat_node)\n   return gnu_result;\n }\n \f\n+/* INSN is a list of insns.  Return the first rtl in the list that isn't\n+   an INSN_NOTE_DELETED.  */\n+\n+static rtx\n+first_nondeleted_insn (rtx insns)\n+{\n+  for (; insns && GET_CODE (insns) == NOTE\n+       && NOTE_LINE_NUMBER (insns) == NOTE_INSN_DELETED;\n+       insns = NEXT_INSN (insns))\n+    ;\n+\n+  return insns;\n+}\n+\f\n+/* Build a BLOCK_STMT from GNAT_LIST, a possibly-empty list of statements.  */\n+\n+static tree\n+build_block_stmt (List_Id gnat_list)\n+{\n+  tree gnu_result = NULL_TREE;\n+  Node_Id gnat_node;\n+\n+  if (No (gnat_list) || Is_Empty_List (gnat_list))\n+    return NULL_TREE;\n+\n+  for (gnat_node = First (gnat_list);\n+       Present (gnat_node);\n+       gnat_node = Next (gnat_node))\n+    gnu_result = chainon (gnat_to_gnu (gnat_node), gnu_result);\n+\n+  gnu_result = build_nt (BLOCK_STMT, nreverse (gnu_result));\n+  TREE_SLOC (gnu_result) = TREE_SLOC (BLOCK_STMT_LIST (gnu_result));\n+  TREE_TYPE (gnu_result) = void_type_node;\n+  return gnu_result;\n+} \n+\n+/* Build an EXPR_STMT to evaluate INSNS.  Use Sloc from GNAT_NODE.   */\n+\n+static tree\n+make_expr_stmt_from_rtl (rtx insns, Node_Id gnat_node)\n+{\n+  tree gnu_result = make_node (RTL_EXPR);\n+\n+  TREE_TYPE (gnu_result) = void_type_node;\n+  RTL_EXPR_RTL (gnu_result) = RTL_EXPR_ALT_RTL (gnu_result) = const0_rtx;\n+  RTL_EXPR_SEQUENCE (gnu_result) = insns;\n+  rtl_expr_chain = tree_cons (NULL_TREE, gnu_result, rtl_expr_chain);\n+\n+  gnu_result = build_nt (EXPR_STMT, gnu_result);\n+  TREE_SLOC (gnu_result) = Sloc (gnat_node);\n+  TREE_TYPE (gnu_result) = void_type_node;\n+\n+  return gnu_result;\n+}\n+\f\n /* GNU_STMT is a statement.  We generate code for that statement.  */\n \n void\n gnat_expand_stmt (tree gnu_stmt)\n {\n-  set_lineno_from_sloc (TREE_SLOC (gnu_stmt), 1);\n+  tree gnu_elmt;\n+\n+  if (TREE_SLOC (gnu_stmt))\n+    set_lineno_from_sloc (TREE_SLOC (gnu_stmt), 1);\n \n   switch (TREE_CODE (gnu_stmt))\n     {\n     case EXPR_STMT:\n       expand_expr_stmt (EXPR_STMT_EXPR (gnu_stmt));\n       break;\n \n+    case BLOCK_STMT:\n+      for (gnu_elmt = BLOCK_STMT_LIST (gnu_stmt); gnu_elmt;\n+\t   gnu_elmt = TREE_CHAIN (gnu_elmt))\n+\texpand_expr_stmt (gnu_elmt);\n+      break;\n+\n+    case IF_STMT:\n+      expand_start_cond (IF_STMT_COND (gnu_stmt), 0);\n+\n+      if (IF_STMT_TRUE (gnu_stmt))\n+\texpand_expr_stmt (IF_STMT_TRUE (gnu_stmt));\n+\n+      for (gnu_elmt = IF_STMT_ELSEIF (gnu_stmt); gnu_elmt;\n+\t   gnu_elmt = TREE_CHAIN (gnu_elmt))\n+\t{\n+\t  expand_start_else ();\n+\t  set_lineno_from_sloc (TREE_SLOC (gnu_elmt), 1);\n+\t  expand_elseif (IF_STMT_COND (gnu_elmt));\n+\t  expand_expr_stmt (IF_STMT_TRUE (gnu_elmt));\n+\t}\n+\n+      if (IF_STMT_ELSE (gnu_stmt))\n+\t{\n+\t  expand_start_else ();\n+\t  expand_expr_stmt (IF_STMT_ELSE (gnu_stmt));\n+\t}\n+\n+      expand_end_cond ();\n+      break;\n+\n+    case GOTO_STMT:\n+      TREE_USED (GOTO_STMT_LABEL (gnu_stmt)) = 1;\n+      expand_goto (GOTO_STMT_LABEL (gnu_stmt));\n+      break;\n+\n+    case LABEL_STMT:\n+      expand_label (LABEL_STMT_LABEL (gnu_stmt));\n+      if (LABEL_STMT_FIRST_IN_EH (gnu_stmt))\n+\tnonlocal_goto_handler_labels\n+\t  = gen_rtx_EXPR_LIST (VOIDmode,\n+\t\t\t       label_rtx (LABEL_STMT_LABEL (gnu_stmt)),\n+\t\t\t       nonlocal_goto_handler_labels);\n+      break;\n+\n+    case RETURN_STMT:\n+      if (RETURN_STMT_EXPR (gnu_stmt))\n+\texpand_return (build_binary_op (MODIFY_EXPR, NULL_TREE,\n+\t\t\t\t\tDECL_RESULT (current_function_decl),\n+\t\t\t\t\tRETURN_STMT_EXPR (gnu_stmt)));\n+      else\n+\texpand_null_return ();\n+      break;\n+\n     default:\n       abort ();\n     }"}, {"sha": "8b0bf8183dd1127a84b64d11e7d2a45fd67cd1a2", "filename": "gcc/ada/utils.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af15298919fc249fc35fc33144271c560c74939c/gcc%2Fada%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af15298919fc249fc35fc33144271c560c74939c/gcc%2Fada%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils.c?ref=af15298919fc249fc35fc33144271c560c74939c", "patch": "@@ -2069,7 +2069,11 @@ float_type_for_precision (int precision, enum machine_mode mode)\n tree\n gnat_type_for_mode (enum machine_mode mode, int unsignedp)\n {\n-  if (GET_MODE_CLASS (mode) == MODE_FLOAT)\n+  if (mode == BLKmode)\n+    return NULL_TREE;\n+  else if (mode == VOIDmode)\n+    return void_type_node;\n+  else if (GET_MODE_CLASS (mode) == MODE_FLOAT)\n     return float_type_for_precision (GET_MODE_PRECISION (mode), mode);\n   else\n     return gnat_type_for_size (GET_MODE_BITSIZE (mode), unsignedp);"}]}