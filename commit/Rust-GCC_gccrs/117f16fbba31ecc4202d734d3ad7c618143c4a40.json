{"sha": "117f16fbba31ecc4202d734d3ad7c618143c4a40", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTE3ZjE2ZmJiYTMxZWNjNDIwMmQ3MzRkM2FkN2M2MTgxNDNjNGE0MA==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2014-03-27T20:07:16Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2014-03-27T20:07:16Z"}, "message": "re PR testsuite/60672 (FAIL: g++.dg/cpp1y/auto-fn25.C -std=gnu++1y  (test for errors, line 7))\n\n[gcc]\n2014-03-27  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\t* config/rs6000/constraints.md (wD constraint): New constraint to\n\tmatch the constant integer to get the top DImode/DFmode out of a\n\tvector in a VSX register.\n\n\t* config/rs6000/predicates.md (vsx_scalar_64bit): New predicate to\n\tmatch the constant integer to get the top DImode/DFmode out of a\n\tvector in a VSX register.\n\n\t* config/rs6000/rs6000-builtins.def (VBPERMQ): Add vbpermq builtin\n\tfor ISA 2.07.\n\n\t* config/rs6000/rs6000-c.c (altivec_overloaded_builtins): Add\n\tvbpermq builtins.\n\n\t* config/rs6000/rs6000.c (rs6000_debug_reg_global): If\n\t-mdebug=reg, print value of VECTOR_ELEMENT_SCALAR_64BIT.\n\n\t* config/rs6000/vsx.md (vsx_extract_<mode>, V2DI/V2DF modes):\n\tOptimize vec_extract of 64-bit values, where the value being\n\textracted is in the top word, where we can use scalar\n\tinstructions.  Add direct move and store support.  Combine the big\n\tendian/little endian vector select load support into a single\n\tinsn.\n\t(vsx_extract_<mode>_internal1): Likewise.\n\t(vsx_extract_<mode>_internal2): Likewise.\n\t(vsx_extract_<mode>_load): Likewise.\n\t(vsx_extract_<mode>_store): Likewise.\n\t(vsx_extract_<mode>_zero): Delete, big and little endian insns are\n\tcombined into vsx_extract_<mode>_load.\n\t(vsx_extract_<mode>_one_le): Likewise.\n\n\t* config/rs6000/rs6000.h (VECTOR_ELEMENT_SCALAR_64BIT): Macro to\n\tdefine the top 64-bit vector element.\n\n\t* doc/md.texi (PowerPC and IBM RS6000 constraints): Document wD\n\tconstraint.\n\n\tPR target/60672\n\t* config/rs6000/altivec.h (vec_xxsldwi): Add missing define to\n\tenable use of xxsldwi and xxpermdi builtin functions.\n\t(vec_xxpermdi): Likewise.\n\n\t* doc/extend.texi (PowerPC AltiVec/VSX Built-in Functions):\n\tDocument use of vec_xxsldwi and vec_xxpermdi builtins.\n\n[gcc/testsuite]\n2014-03-27  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\t* gcc.target/powerpc/p8vector-vbpermq.c: New test to test the\n\tvbpermq builtin.\n\n\t* gcc.target/powerpc/vsx-extract-1.c: New test to test VSX\n\tvec_select optimizations.\n\t* gcc.target/powerpc/vsx-extract-2.c: Likewise.\n\t* gcc.target/powerpc/vsx-extract-3.c: Likewise.\n\n\tPR target/60672\n\t* gcc.target/powerpc/pr60676.c: New file, make sure xxsldwi and\n\txxpermdi builtins are supported.\n\nFrom-SVN: r208877", "tree": {"sha": "cbc1b2cc94ac1e09bf62fb232d9527d97d0c4864", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cbc1b2cc94ac1e09bf62fb232d9527d97d0c4864"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/117f16fbba31ecc4202d734d3ad7c618143c4a40", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/117f16fbba31ecc4202d734d3ad7c618143c4a40", "html_url": "https://github.com/Rust-GCC/gccrs/commit/117f16fbba31ecc4202d734d3ad7c618143c4a40", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/117f16fbba31ecc4202d734d3ad7c618143c4a40/comments", "author": null, "committer": null, "parents": [{"sha": "9e038952c553edf5aed95342eec677b2ddb69c38", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e038952c553edf5aed95342eec677b2ddb69c38", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e038952c553edf5aed95342eec677b2ddb69c38"}], "stats": {"total": 488, "additions": 455, "deletions": 33}, "files": [{"sha": "f3b01bc362696a4242b36df4dabd035cb7447598", "filename": "gcc/ChangeLog", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/117f16fbba31ecc4202d734d3ad7c618143c4a40/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/117f16fbba31ecc4202d734d3ad7c618143c4a40/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=117f16fbba31ecc4202d734d3ad7c618143c4a40", "patch": "@@ -1,3 +1,50 @@\n+2014-03-27  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* config/rs6000/constraints.md (wD constraint): New constraint to\n+\tmatch the constant integer to get the top DImode/DFmode out of a\n+\tvector in a VSX register.\n+\n+\t* config/rs6000/predicates.md (vsx_scalar_64bit): New predicate to\n+\tmatch the constant integer to get the top DImode/DFmode out of a\n+\tvector in a VSX register.\n+\n+\t* config/rs6000/rs6000-builtins.def (VBPERMQ): Add vbpermq builtin\n+\tfor ISA 2.07.\n+\n+\t* config/rs6000/rs6000-c.c (altivec_overloaded_builtins): Add\n+\tvbpermq builtins.\n+\n+\t* config/rs6000/rs6000.c (rs6000_debug_reg_global): If\n+\t-mdebug=reg, print value of VECTOR_ELEMENT_SCALAR_64BIT.\n+\n+\t* config/rs6000/vsx.md (vsx_extract_<mode>, V2DI/V2DF modes):\n+\tOptimize vec_extract of 64-bit values, where the value being\n+\textracted is in the top word, where we can use scalar\n+\tinstructions.  Add direct move and store support.  Combine the big\n+\tendian/little endian vector select load support into a single\n+\tinsn.\n+\t(vsx_extract_<mode>_internal1): Likewise.\n+\t(vsx_extract_<mode>_internal2): Likewise.\n+\t(vsx_extract_<mode>_load): Likewise.\n+\t(vsx_extract_<mode>_store): Likewise.\n+\t(vsx_extract_<mode>_zero): Delete, big and little endian insns are\n+\tcombined into vsx_extract_<mode>_load.\n+\t(vsx_extract_<mode>_one_le): Likewise.\n+\n+\t* config/rs6000/rs6000.h (VECTOR_ELEMENT_SCALAR_64BIT): Macro to\n+\tdefine the top 64-bit vector element.\n+\n+\t* doc/md.texi (PowerPC and IBM RS6000 constraints): Document wD\n+\tconstraint.\n+\n+\tPR target/60672\n+\t* config/rs6000/altivec.h (vec_xxsldwi): Add missing define to\n+\tenable use of xxsldwi and xxpermdi builtin functions.\n+\t(vec_xxpermdi): Likewise.\n+\n+\t* doc/extend.texi (PowerPC AltiVec/VSX Built-in Functions):\n+\tDocument use of vec_xxsldwi and vec_xxpermdi builtins.\n+\n 2014-03-27  Vladimir Makarov  <vmakarov@redhat.com>\n \n \tPR rtl-optimization/60650"}, {"sha": "129cf6fa16203360ae30339855bbaae2fb07c1fe", "filename": "gcc/config/rs6000/altivec.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/117f16fbba31ecc4202d734d3ad7c618143c4a40/gcc%2Fconfig%2Frs6000%2Faltivec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/117f16fbba31ecc4202d734d3ad7c618143c4a40/gcc%2Fconfig%2Frs6000%2Faltivec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Faltivec.h?ref=117f16fbba31ecc4202d734d3ad7c618143c4a40", "patch": "@@ -319,6 +319,11 @@\n #define vec_sqrt __builtin_vec_sqrt\n #define vec_vsx_ld __builtin_vec_vsx_ld\n #define vec_vsx_st __builtin_vec_vsx_st\n+\n+/* Note, xxsldi and xxpermdi were added as __builtin_vsx_<xxx> functions\n+   instead of __builtin_vec_<xxx>  */\n+#define vec_xxsldwi __builtin_vsx_xxsldwi\n+#define vec_xxpermdi __builtin_vsx_xxpermdi\n #endif\n \n #ifdef _ARCH_PWR8\n@@ -329,6 +334,7 @@\n #define vec_vaddcuq __builtin_vec_vaddcuq\n #define vec_vaddudm __builtin_vec_vaddudm\n #define vec_vadduqm __builtin_vec_vadduqm\n+#define vec_vbpermq __builtin_vec_vbpermq\n #define vec_vclz __builtin_vec_vclz\n #define vec_vclzb __builtin_vec_vclzb\n #define vec_vclzd __builtin_vec_vclzd"}, {"sha": "674cb40bf7a3f9c88523f448f023a5e5f123c85b", "filename": "gcc/config/rs6000/altivec.md", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/117f16fbba31ecc4202d734d3ad7c618143c4a40/gcc%2Fconfig%2Frs6000%2Faltivec.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/117f16fbba31ecc4202d734d3ad7c618143c4a40/gcc%2Fconfig%2Frs6000%2Faltivec.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Faltivec.md?ref=117f16fbba31ecc4202d734d3ad7c618143c4a40", "patch": "@@ -142,6 +142,7 @@\n    UNSPEC_VSUBCUQ\n    UNSPEC_VSUBEUQM\n    UNSPEC_VSUBECUQ\n+   UNSPEC_VBPERMQ\n ])\n \n (define_c_enum \"unspecv\"\n@@ -3322,3 +3323,14 @@\n   [(set_attr \"length\" \"4\")\n    (set_attr \"type\" \"vecsimple\")])\n \n+;; We use V2DI as the output type to simplify converting the permute\n+;; bits into an integer\n+(define_insn \"altivec_vbpermq\"\n+  [(set (match_operand:V2DI 0 \"register_operand\" \"=v\")\n+\t(unspec:V2DI [(match_operand:V16QI 1 \"register_operand\" \"v\")\n+\t\t      (match_operand:V16QI 2 \"register_operand\" \"v\")]\n+\t\t     UNSPEC_VBPERMQ))]\n+  \"TARGET_P8_VECTOR\"\n+  \"vbpermq %0,%1,%2\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"vecsimple\")])"}, {"sha": "9d6a3bbe7c87ef0ab9a2e2ba38b77cb17f361d02", "filename": "gcc/config/rs6000/constraints.md", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/117f16fbba31ecc4202d734d3ad7c618143c4a40/gcc%2Fconfig%2Frs6000%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/117f16fbba31ecc4202d734d3ad7c618143c4a40/gcc%2Fconfig%2Frs6000%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fconstraints.md?ref=117f16fbba31ecc4202d734d3ad7c618143c4a40", "patch": "@@ -106,6 +106,11 @@\n (define_register_constraint \"wz\" \"rs6000_constraints[RS6000_CONSTRAINT_wz]\"\n   \"Floating point register if the LFIWZX instruction is enabled or NO_REGS.\")\n \n+(define_constraint \"wD\"\n+  \"Int constant that is the element number of the 64-bit scalar in a vector.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"TARGET_VSX && (ival == VECTOR_ELEMENT_SCALAR_64BIT)\")))\n+\n ;; Lq/stq validates the address for load/store quad\n (define_memory_constraint \"wQ\"\n   \"Memory operand suitable for the load/store quad instructions\""}, {"sha": "28f4f5d98b1e0ef95c7720c013ab5218072a9df7", "filename": "gcc/config/rs6000/predicates.md", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/117f16fbba31ecc4202d734d3ad7c618143c4a40/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/117f16fbba31ecc4202d734d3ad7c618143c4a40/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpredicates.md?ref=117f16fbba31ecc4202d734d3ad7c618143c4a40", "patch": "@@ -981,6 +981,14 @@\n   (ior (match_operand 0 \"zero_fp_constant\")\n        (match_operand 0 \"reg_or_mem_operand\")))\n \n+;; Return 1 if the operand is a CONST_INT and it is the element for 64-bit\n+;; data types inside of a vector that scalar instructions operate on\n+(define_predicate \"vsx_scalar_64bit\"\n+  (match_code \"const_int\")\n+{\n+  return (INTVAL (op) == VECTOR_ELEMENT_SCALAR_64BIT);\n+})\n+\n ;; Return 1 if the operand is a general register or memory operand without\n ;; pre_inc or pre_dec or pre_modify, which produces invalid form of PowerPC\n ;; lwa instruction."}, {"sha": "83351691fa5fee510ae123649c7c111dac60b500", "filename": "gcc/config/rs6000/rs6000-builtin.def", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/117f16fbba31ecc4202d734d3ad7c618143c4a40/gcc%2Fconfig%2Frs6000%2Frs6000-builtin.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/117f16fbba31ecc4202d734d3ad7c618143c4a40/gcc%2Fconfig%2Frs6000%2Frs6000-builtin.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-builtin.def?ref=117f16fbba31ecc4202d734d3ad7c618143c4a40", "patch": "@@ -1374,6 +1374,7 @@ BU_P8V_AV_2 (VMINUD,\t\t\"vminud\",\tCONST,\tuminv2di3)\n BU_P8V_AV_2 (VMAXUD,\t\t\"vmaxud\",\tCONST,\tumaxv2di3)\n BU_P8V_AV_2 (VMRGEW,\t\t\"vmrgew\",\tCONST,\tp8_vmrgew)\n BU_P8V_AV_2 (VMRGOW,\t\t\"vmrgow\",\tCONST,\tp8_vmrgow)\n+BU_P8V_AV_2 (VBPERMQ,\t\t\"vbpermq\",\tCONST,\taltivec_vbpermq)\n BU_P8V_AV_2 (VPKUDUM,\t\t\"vpkudum\",\tCONST,\taltivec_vpkudum)\n BU_P8V_AV_2 (VPKSDSS,\t\t\"vpksdss\",\tCONST,\taltivec_vpksdss)\n BU_P8V_AV_2 (VPKUDUS,\t\t\"vpkudus\",\tCONST,\taltivec_vpkudus)\n@@ -1448,6 +1449,7 @@ BU_P8V_OVERLOAD_2 (ORC,\t\t\"orc\")\n BU_P8V_OVERLOAD_2 (VADDCUQ,\t\"vaddcuq\")\n BU_P8V_OVERLOAD_2 (VADDUDM,\t\"vaddudm\")\n BU_P8V_OVERLOAD_2 (VADDUQM,\t\"vadduqm\")\n+BU_P8V_OVERLOAD_2 (VBPERMQ,\t\"vbpermq\")\n BU_P8V_OVERLOAD_2 (VMAXSD,\t\"vmaxsd\")\n BU_P8V_OVERLOAD_2 (VMAXUD,\t\"vmaxud\")\n BU_P8V_OVERLOAD_2 (VMINSD,\t\"vminsd\")"}, {"sha": "46c4a9d8c2eedc5a12a01f85ff4ae0a81445b7fb", "filename": "gcc/config/rs6000/rs6000-c.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/117f16fbba31ecc4202d734d3ad7c618143c4a40/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/117f16fbba31ecc4202d734d3ad7c618143c4a40/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-c.c?ref=117f16fbba31ecc4202d734d3ad7c618143c4a40", "patch": "@@ -3778,6 +3778,12 @@ const struct altivec_builtin_types altivec_overloaded_builtins[] = {\n     RS6000_BTI_unsigned_V1TI, RS6000_BTI_unsigned_V1TI,\n     RS6000_BTI_unsigned_V1TI, 0 },\n \n+  { P8V_BUILTIN_VEC_VBPERMQ, P8V_BUILTIN_VBPERMQ,\n+    RS6000_BTI_V2DI, RS6000_BTI_V16QI, RS6000_BTI_V16QI, 0 },\n+  { P8V_BUILTIN_VEC_VBPERMQ, P8V_BUILTIN_VBPERMQ,\n+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V16QI,\n+    RS6000_BTI_unsigned_V16QI, 0 },\n+\n   { P8V_BUILTIN_VEC_VCLZ, P8V_BUILTIN_VCLZB,\n     RS6000_BTI_V16QI, RS6000_BTI_V16QI, 0, 0 },\n   { P8V_BUILTIN_VEC_VCLZ, P8V_BUILTIN_VCLZB,"}, {"sha": "cd852579d116187c2337575dedf0b399e4e9a777", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/117f16fbba31ecc4202d734d3ad7c618143c4a40/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/117f16fbba31ecc4202d734d3ad7c618143c4a40/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=117f16fbba31ecc4202d734d3ad7c618143c4a40", "patch": "@@ -2310,6 +2310,10 @@ rs6000_debug_reg_global (void)\n \t   (int)END_BUILTINS);\n   fprintf (stderr, DEBUG_FMT_D, \"Number of rs6000 builtins\",\n \t   (int)RS6000_BUILTIN_COUNT);\n+\n+  if (TARGET_VSX)\n+    fprintf (stderr, DEBUG_FMT_D, \"VSX easy 64-bit scalar element\",\n+\t     (int)VECTOR_ELEMENT_SCALAR_64BIT);\n }\n \n \f"}, {"sha": "9ec3647fedd3ae15c113484b0fd6d42c23a41a15", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/117f16fbba31ecc4202d734d3ad7c618143c4a40/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/117f16fbba31ecc4202d734d3ad7c618143c4a40/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=117f16fbba31ecc4202d734d3ad7c618143c4a40", "patch": "@@ -477,6 +477,10 @@ extern int rs6000_vector_align[];\n #define VECTOR_ELT_ORDER_BIG                                  \\\n   (BYTES_BIG_ENDIAN || (rs6000_altivec_element_order == 2))\n \n+/* Element number of the 64-bit value in a 128-bit vector that can be accessed\n+   with scalar instructions.  */\n+#define VECTOR_ELEMENT_SCALAR_64BIT\t((BYTES_BIG_ENDIAN) ? 0 : 1)\n+\n /* Alignment options for fields in structures for sub-targets following\n    AIX-like ABI.\n    ALIGN_POWER word-aligns FP doubles (default AIX ABI)."}, {"sha": "a06cdd507e4cfbe51b8a6f41e445282a08fb7078", "filename": "gcc/config/rs6000/vsx.md", "status": "modified", "additions": 110, "deletions": 33, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/117f16fbba31ecc4202d734d3ad7c618143c4a40/gcc%2Fconfig%2Frs6000%2Fvsx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/117f16fbba31ecc4202d734d3ad7c618143c4a40/gcc%2Fconfig%2Frs6000%2Fvsx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fvsx.md?ref=117f16fbba31ecc4202d734d3ad7c618143c4a40", "patch": "@@ -1531,52 +1531,129 @@\n   [(set_attr \"type\" \"vecperm\")])\n \n ;; Extract a DF/DI element from V2DF/V2DI\n-(define_insn \"vsx_extract_<mode>\"\n-  [(set (match_operand:<VS_scalar> 0 \"vsx_register_operand\" \"=ws,d,?wa\")\n-\t(vec_select:<VS_scalar> (match_operand:VSX_D 1 \"vsx_register_operand\" \"wd,wd,wa\")\n+(define_expand \"vsx_extract_<mode>\"\n+  [(set (match_operand:<VS_scalar> 0 \"register_operand\" \"\")\n+\t(vec_select:<VS_scalar> (match_operand:VSX_D 1 \"register_operand\" \"\")\n \t\t       (parallel\n-\t\t\t[(match_operand:QI 2 \"u5bit_cint_operand\" \"i,i,i\")])))]\n+\t\t\t[(match_operand:QI 2 \"u5bit_cint_operand\" \"\")])))]\n   \"VECTOR_MEM_VSX_P (<MODE>mode)\"\n+  \"\")\n+\n+;; Optimize cases were we can do a simple or direct move.\n+;; Or see if we can avoid doing the move at all\n+(define_insn \"*vsx_extract_<mode>_internal1\"\n+  [(set (match_operand:<VS_scalar> 0 \"register_operand\" \"=d,ws,?wa,r\")\n+\t(vec_select:<VS_scalar>\n+\t (match_operand:VSX_D 1 \"register_operand\" \"d,wd,wa,wm\")\n+\t (parallel\n+\t  [(match_operand:QI 2 \"vsx_scalar_64bit\" \"wD,wD,wD,wD\")])))]\n+  \"VECTOR_MEM_VSX_P (<MODE>mode) && TARGET_POWERPC64 && TARGET_DIRECT_MOVE\"\n+{\n+  int op0_regno = REGNO (operands[0]);\n+  int op1_regno = REGNO (operands[1]);\n+\n+  if (op0_regno == op1_regno)\n+    return \"nop\";\n+\n+  if (INT_REGNO_P (op0_regno))\n+    return \"mfvsrd %0,%x1\";\n+\n+  if (FP_REGNO_P (op0_regno) && FP_REGNO_P (op1_regno))\n+    return \"fmr %0,%1\";\n+\n+  return \"xxlor %x0,%x1,%x1\";\n+}\n+  [(set_attr \"type\" \"fp,vecsimple,vecsimple,mftgpr\")\n+   (set_attr \"length\" \"4\")])\n+\n+(define_insn \"*vsx_extract_<mode>_internal2\"\n+  [(set (match_operand:<VS_scalar> 0 \"vsx_register_operand\" \"=d,ws,ws,?wa\")\n+\t(vec_select:<VS_scalar>\n+\t (match_operand:VSX_D 1 \"vsx_register_operand\" \"d,wd,wd,wa\")\n+\t (parallel [(match_operand:QI 2 \"u5bit_cint_operand\" \"wD,wD,i,i\")])))]\n+  \"VECTOR_MEM_VSX_P (<MODE>mode)\n+   && (!TARGET_POWERPC64 || !TARGET_DIRECT_MOVE\n+       || INTVAL (operands[2]) != VECTOR_ELEMENT_SCALAR_64BIT)\"\n {\n   int fldDM;\n   gcc_assert (UINTVAL (operands[2]) <= 1);\n+\n+  if (INTVAL (operands[2]) == VECTOR_ELEMENT_SCALAR_64BIT)\n+    {\n+      int op0_regno = REGNO (operands[0]);\n+      int op1_regno = REGNO (operands[1]);\n+\n+      if (op0_regno == op1_regno)\n+\treturn \"nop\";\n+\n+      if (FP_REGNO_P (op0_regno) && FP_REGNO_P (op1_regno))\n+\treturn \"fmr %0,%1\";\n+\n+      return \"xxlor %x0,%x1,%x1\";\n+    }\n+\n   fldDM = INTVAL (operands[2]) << 1;\n   if (!BYTES_BIG_ENDIAN)\n     fldDM = 3 - fldDM;\n   operands[3] = GEN_INT (fldDM);\n-  return \\\"xxpermdi %x0,%x1,%x1,%3\\\";\n+  return \"xxpermdi %x0,%x1,%x1,%3\";\n }\n-  [(set_attr \"type\" \"vecperm\")])\n+  [(set_attr \"type\" \"fp,vecsimple,vecperm,vecperm\")\n+   (set_attr \"length\" \"4\")])\n \n-;; Optimize extracting element 0 from memory\n-(define_insn \"*vsx_extract_<mode>_zero\"\n-  [(set (match_operand:<VS_scalar> 0 \"vsx_register_operand\" \"=ws,d,?wa\")\n+;; Optimize extracting a single scalar element from memory if the scalar is in\n+;; the correct location to use a single load.\n+(define_insn \"*vsx_extract_<mode>_load\"\n+  [(set (match_operand:<VS_scalar> 0 \"register_operand\" \"=d,wv,wr\")\n \t(vec_select:<VS_scalar>\n-\t (match_operand:VSX_D 1 \"indexed_or_indirect_operand\" \"Z,Z,Z\")\n-\t (parallel [(const_int 0)])))]\n-  \"VECTOR_MEM_VSX_P (<MODE>mode) && WORDS_BIG_ENDIAN\"\n-  \"lxsd%U1x %x0,%y1\"\n-  [(set (attr \"type\")\n-      (if_then_else\n-\t(match_test \"update_indexed_address_mem (operands[1], VOIDmode)\")\n-\t(const_string \"fpload_ux\")\n-\t(const_string \"fpload\")))\n-   (set_attr \"length\" \"4\")])  \n-\n-;; Optimize extracting element 1 from memory for little endian\n-(define_insn \"*vsx_extract_<mode>_one_le\"\n-  [(set (match_operand:<VS_scalar> 0 \"vsx_register_operand\" \"=ws,d,?wa\")\n+\t (match_operand:VSX_D 1 \"memory_operand\" \"m,Z,m\")\n+\t (parallel [(match_operand:QI 2 \"vsx_scalar_64bit\" \"wD,wD,wD\")])))]\n+  \"VECTOR_MEM_VSX_P (<MODE>mode)\"\n+  \"@\n+   lfd%U1%X1 %0,%1\n+   lxsd%U1x %x0,%y1\n+   ld%U1%X1 %0,%1\"\n+  [(set_attr_alternative \"type\"\n+      [(if_then_else\n+\t (match_test \"update_indexed_address_mem (operands[1], VOIDmode)\")\n+\t (const_string \"fpload_ux\")\n+\t (if_then_else\n+\t   (match_test \"update_address_mem (operands[1], VOIDmode)\")\n+\t   (const_string \"fpload_u\")\n+\t   (const_string \"fpload\")))\n+       (const_string \"fpload\")\n+       (if_then_else\n+\t (match_test \"update_indexed_address_mem (operands[1], VOIDmode)\")\n+\t (const_string \"load_ux\")\n+\t (if_then_else\n+\t   (match_test \"update_address_mem (operands[1], VOIDmode)\")\n+\t   (const_string \"load_u\")\n+\t   (const_string \"load\")))])\n+   (set_attr \"length\" \"4\")])\n+\n+;; Optimize storing a single scalar element that is the right location to\n+;; memory\n+(define_insn \"*vsx_extract_<mode>_store\"\n+  [(set (match_operand:<VS_scalar> 0 \"memory_operand\" \"=m,Z,?Z\")\n \t(vec_select:<VS_scalar>\n-\t (match_operand:VSX_D 1 \"indexed_or_indirect_operand\" \"Z,Z,Z\")\n-\t (parallel [(const_int 1)])))]\n-  \"VECTOR_MEM_VSX_P (<MODE>mode) && !WORDS_BIG_ENDIAN\"\n-  \"lxsd%U1x %x0,%y1\"\n-  [(set (attr \"type\")\n-      (if_then_else\n-\t(match_test \"update_indexed_address_mem (operands[1], VOIDmode)\")\n-\t(const_string \"fpload_ux\")\n-\t(const_string \"fpload\")))\n-   (set_attr \"length\" \"4\")])  \n+\t (match_operand:VSX_D 1 \"register_operand\" \"d,wd,wa\")\n+\t (parallel [(match_operand:QI 2 \"vsx_scalar_64bit\" \"wD,wD,wD\")])))]\n+  \"VECTOR_MEM_VSX_P (<MODE>mode)\"\n+  \"@\n+   stfd%U0%X0 %1,%0\n+   stxsd%U0x %x1,%y0\n+   stxsd%U0x %x1,%y0\"\n+  [(set_attr_alternative \"type\"\n+      [(if_then_else\n+\t (match_test \"update_indexed_address_mem (operands[0], VOIDmode)\")\n+\t (const_string \"fpstore_ux\")\n+\t (if_then_else\n+\t   (match_test \"update_address_mem (operands[0], VOIDmode)\")\n+\t   (const_string \"fpstore_u\")\n+\t   (const_string \"fpstore\")))\n+       (const_string \"fpstore\")\n+       (const_string \"fpstore\")])\n+   (set_attr \"length\" \"4\")])\n \n ;; Extract a SF element from V4SF\n (define_insn_and_split \"vsx_extract_v4sf\""}, {"sha": "2818c1b0b6f6596a1558922498f593239f13cbfe", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/117f16fbba31ecc4202d734d3ad7c618143c4a40/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/117f16fbba31ecc4202d734d3ad7c618143c4a40/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=117f16fbba31ecc4202d734d3ad7c618143c4a40", "patch": "@@ -14859,6 +14859,35 @@ void vec_vsx_st (vector unsigned char, int, unsigned char *);\n void vec_vsx_st (vector bool char, int, vector bool char *);\n void vec_vsx_st (vector bool char, int, unsigned char *);\n void vec_vsx_st (vector bool char, int, signed char *);\n+\n+vector double vec_xxpermdi (vector double, vector double, int);\n+vector float vec_xxpermdi (vector float, vector float, int);\n+vector long long vec_xxpermdi (vector long long, vector long long, int);\n+vector unsigned long long vec_xxpermdi (vector unsigned long long,\n+                                        vector unsigned long long, int);\n+vector int vec_xxpermdi (vector int, vector int, int);\n+vector unsigned int vec_xxpermdi (vector unsigned int,\n+                                  vector unsigned int, int);\n+vector short vec_xxpermdi (vector short, vector short, int);\n+vector unsigned short vec_xxpermdi (vector unsigned short,\n+                                    vector unsigned short, int);\n+vector signed char vec_xxpermdi (vector signed char, vector signed char, int);\n+vector unsigned char vec_xxpermdi (vector unsigned char,\n+                                   vector unsigned char, int);\n+\n+vector double vec_xxsldi (vector double, vector double, int);\n+vector float vec_xxsldi (vector float, vector float, int);\n+vector long long vec_xxsldi (vector long long, vector long long, int);\n+vector unsigned long long vec_xxsldi (vector unsigned long long,\n+                                      vector unsigned long long, int);\n+vector int vec_xxsldi (vector int, vector int, int);\n+vector unsigned int vec_xxsldi (vector unsigned int, vector unsigned int, int);\n+vector short vec_xxsldi (vector short, vector short, int);\n+vector unsigned short vec_xxsldi (vector unsigned short,\n+                                  vector unsigned short, int);\n+vector signed char vec_xxsldi (vector signed char, vector signed char, int);\n+vector unsigned char vec_xxsldi (vector unsigned char,\n+                                 vector unsigned char, int);\n @end smallexample\n \n Note that the @samp{vec_ld} and @samp{vec_st} built-in functions always"}, {"sha": "13e34b5e2a9435f1620f311d65651afff1744f06", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/117f16fbba31ecc4202d734d3ad7c618143c4a40/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/117f16fbba31ecc4202d734d3ad7c618143c4a40/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=117f16fbba31ecc4202d734d3ad7c618143c4a40", "patch": "@@ -2162,6 +2162,9 @@ VSX vector register to hold scalar float values or NO_REGS.\n @item wz\n Floating point register if the LFIWZX instruction is enabled or NO_REGS.\n \n+@item wD\n+Int constant that is the element number of the 64-bit scalar in a vector.\n+\n @item wQ\n A memory address that will work with the @code{lq} and @code{stq}\n instructions."}, {"sha": "bf280022184ffe204d6552ddfdcad6312dd84d9a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/117f16fbba31ecc4202d734d3ad7c618143c4a40/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/117f16fbba31ecc4202d734d3ad7c618143c4a40/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=117f16fbba31ecc4202d734d3ad7c618143c4a40", "patch": "@@ -1,3 +1,17 @@\n+2014-03-27  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* gcc.target/powerpc/p8vector-vbpermq.c: New test to test the\n+\tvbpermq builtin.\n+\n+\t* gcc.target/powerpc/vsx-extract-1.c: New test to test VSX\n+\tvec_select optimizations.\n+\t* gcc.target/powerpc/vsx-extract-2.c: Likewise.\n+\t* gcc.target/powerpc/vsx-extract-3.c: Likewise.\n+\n+\tPR target/60672\n+\t* gcc.target/powerpc/pr60676.c: New file, make sure xxsldwi and\n+\txxpermdi builtins are supported.\n+\n 2014-03-27  Vladimir Makarov  <vmakarov@redhat.com>\n \n \tPR rtl-optimization/60650"}, {"sha": "d1664985a562f0d2c0ea4f871f6cd3bf083c4aa6", "filename": "gcc/testsuite/gcc.target/powerpc/p8vector-vbpermq.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/117f16fbba31ecc4202d734d3ad7c618143c4a40/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fp8vector-vbpermq.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/117f16fbba31ecc4202d734d3ad7c618143c4a40/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fp8vector-vbpermq.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fp8vector-vbpermq.c?ref=117f16fbba31ecc4202d734d3ad7c618143c4a40", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target powerpc_p8vector_ok } */\n+/* { dg-options \"-O3 -mcpu=power8\" } */\n+/* { dg-final { scan-assembler     \"vbpermq\" } } */\n+/* { dg-final { scan-assembler     \"mfvsrd\"  } } */\n+/* { dg-final { scan-assembler-not \"stfd\"    } } */\n+/* { dg-final { scan-assembler-not \"stxvd2x\" } } */\n+\n+#include <altivec.h>\n+\n+#if __LITTLE_ENDIAN__\n+#define OFFSET 1\n+#else\n+#define OFFSET 0\n+#endif\n+\n+long foos (vector signed char a, vector signed char b)\n+{\n+  return vec_extract (vec_vbpermq (a, b), OFFSET);\n+}\n+\n+long foou (vector unsigned char a, vector unsigned char b)\n+{\n+  return vec_extract (vec_vbpermq (a, b), OFFSET);\n+}\n+"}, {"sha": "86fd8c6d2e3624138d1b33a66f7d1847ae33937c", "filename": "gcc/testsuite/gcc.target/powerpc/pr60676.c", "status": "added", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/117f16fbba31ecc4202d734d3ad7c618143c4a40/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr60676.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/117f16fbba31ecc4202d734d3ad7c618143c4a40/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr60676.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr60676.c?ref=117f16fbba31ecc4202d734d3ad7c618143c4a40", "patch": "@@ -0,0 +1,128 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target powerpc_vsx_ok } */\n+/* { dg-options \"-O3 -mcpu=power7\" } */\n+/* { dg-final { scan-assembler \"xxsldwi\"  } } */\n+/* { dg-final { scan-assembler \"xxpermdi\" } } */\n+\n+#include <altivec.h>\n+\n+vector double\n+v2df_shift (vector double a, vector double b)\n+{\n+  return vec_xxsldwi (a, b, 1);\n+}\n+\n+vector float\n+v4sf_shift (vector float a, vector float b)\n+{\n+  return vec_xxsldwi (a, b, 1);\n+}\n+\n+vector long long\n+v2di_shift (vector long long a, vector long long b)\n+{\n+  return vec_xxsldwi (a, b, 1);\n+}\n+\n+vector unsigned long long\n+v2diu_shift (vector unsigned long long a, vector unsigned long long b)\n+{\n+  return vec_xxsldwi (a, b, 1);\n+}\n+\n+vector int\n+v4si_shift (vector int a, vector int b)\n+{\n+  return vec_xxsldwi (a, b, 1);\n+}\n+\n+vector unsigned int\n+v4siu_shift (vector unsigned int a, vector unsigned int b)\n+{\n+  return vec_xxsldwi (a, b, 1);\n+}\n+\n+vector short\n+v8hi_shift (vector short a, vector short b)\n+{\n+  return vec_xxsldwi (a, b, 1);\n+}\n+\n+vector unsigned short\n+v8hiu_shift (vector unsigned short a, vector unsigned short b)\n+{\n+  return vec_xxsldwi (a, b, 1);\n+}\n+\n+vector signed char\n+v16qi_shift (vector signed char a, vector signed char b)\n+{\n+  return vec_xxsldwi (a, b, 1);\n+}\n+\n+vector unsigned char\n+v16qiu_shift (vector unsigned char a, vector unsigned char b)\n+{\n+  return vec_xxsldwi (a, b, 1);\n+}\n+\n+vector double\n+v2df_permute (vector double a, vector double b)\n+{\n+  return vec_xxpermdi (a, b, 1);\n+}\n+\n+vector float\n+v4sf_permute (vector float a, vector float b)\n+{\n+  return vec_xxpermdi (a, b, 1);\n+}\n+\n+vector long long\n+v2di_permute (vector long long a, vector long long b)\n+{\n+  return vec_xxpermdi (a, b, 1);\n+}\n+\n+vector unsigned long long\n+v2diu_permute (vector unsigned long long a, vector unsigned long long b)\n+{\n+  return vec_xxpermdi (a, b, 1);\n+}\n+\n+vector int\n+v4si_permute (vector int a, vector int b)\n+{\n+  return vec_xxpermdi (a, b, 1);\n+}\n+\n+vector unsigned int\n+v4siu_permute (vector unsigned int a, vector unsigned int b)\n+{\n+  return vec_xxpermdi (a, b, 1);\n+}\n+\n+vector short\n+v8hi_permute (vector short a, vector short b)\n+{\n+  return vec_xxpermdi (a, b, 1);\n+}\n+\n+vector unsigned short\n+v8hiu_permute (vector unsigned short a, vector unsigned short b)\n+{\n+  return vec_xxpermdi (a, b, 1);\n+}\n+\n+vector signed char\n+v16qi_permute (vector signed char a, vector signed char b)\n+{\n+  return vec_xxpermdi (a, b, 1);\n+}\n+\n+vector unsigned char\n+v16qiu_permute (vector unsigned char a, vector unsigned char b)\n+{\n+  return vec_xxpermdi (a, b, 1);\n+}"}, {"sha": "e1f0ca8e887d33ee69625599cd3b1fddcba6bdb1", "filename": "gcc/testsuite/gcc.target/powerpc/vsx-extract-1.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/117f16fbba31ecc4202d734d3ad7c618143c4a40/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-extract-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/117f16fbba31ecc4202d734d3ad7c618143c4a40/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-extract-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-extract-1.c?ref=117f16fbba31ecc4202d734d3ad7c618143c4a40", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target powerpc_vsx_ok } */\n+/* { dg-options \"-O3 -mcpu=power7\" } */\n+/* { dg-final { scan-assembler     \"lfd\"    } } */\n+/* { dg-final { scan-assembler-not \"lxvd2x\" } } */\n+\n+#include <altivec.h>\n+\n+#if __LITTLE_ENDIAN__\n+#define OFFSET 1\n+#else\n+#define OFFSET 0\n+#endif\n+\n+double get_value (vector double *p) { return vec_extract (*p, OFFSET); }"}, {"sha": "be29af861106f42954f6c47dc4e33b59838b21f2", "filename": "gcc/testsuite/gcc.target/powerpc/vsx-extract-2.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/117f16fbba31ecc4202d734d3ad7c618143c4a40/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-extract-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/117f16fbba31ecc4202d734d3ad7c618143c4a40/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-extract-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-extract-2.c?ref=117f16fbba31ecc4202d734d3ad7c618143c4a40", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target powerpc_vsx_ok } */\n+/* { dg-options \"-O3 -mcpu=power7\" } */\n+/* { dg-final { scan-assembler     \"xxlor\"  } } */\n+/* { dg-final { scan-assembler-not \"lfd\"    } } */\n+/* { dg-final { scan-assembler-not \"lxvd2x\" } } */\n+\n+#include <altivec.h>\n+\n+#if __LITTLE_ENDIAN__\n+#define OFFSET 1\n+#else\n+#define OFFSET 0\n+#endif\n+\n+double get_value (vector double v) { return vec_extract (v, OFFSET); }"}, {"sha": "ea421265e41f998dca3578f9fff913d514663cff", "filename": "gcc/testsuite/gcc.target/powerpc/vsx-extract-3.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/117f16fbba31ecc4202d734d3ad7c618143c4a40/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-extract-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/117f16fbba31ecc4202d734d3ad7c618143c4a40/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-extract-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-extract-3.c?ref=117f16fbba31ecc4202d734d3ad7c618143c4a40", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target powerpc_p8vector_ok } */\n+/* { dg-options \"-O3 -mcpu=power8\" } */\n+/* { dg-final { scan-assembler     \"mfvsrd\"  } } */\n+/* { dg-final { scan-assembler-not \"stfd\"    } } */\n+/* { dg-final { scan-assembler-not \"stxvd2x\" } } */\n+\n+#include <altivec.h>\n+\n+#if __LITTLE_ENDIAN__\n+#define OFFSET 1\n+#else\n+#define OFFSET 0\n+#endif\n+\n+long get_value (vector long v) { return vec_extract (v, OFFSET); }"}]}