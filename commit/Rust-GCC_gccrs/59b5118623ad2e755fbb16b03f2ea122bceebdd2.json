{"sha": "59b5118623ad2e755fbb16b03f2ea122bceebdd2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTliNTExODYyM2FkMmU3NTVmYmIxNmIwM2YyZWExMjJiY2VlYmRkMg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-08-30T11:17:29Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-08-30T11:17:29Z"}, "message": "[51/77] Use opt_scalar_int_mode when iterating over integer modes\n\nThis patch uses opt_scalar_int_mode rather than machine_mode\nwhen iterating over scalar_int_modes, in cases where that helps\nwith future patches.  (Using machine_mode is still OK in places\nthat don't really care about the mode being a scalar integer.)\n\n2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* cse.c (cse_insn): Use opt_scalar_int_mode for the mode iterator.\n\t* explow.c (hard_function_value): Likewise.\n\t* expmed.c (extract_fixed_bit_field_1): Likewise.  Move the\n\tconvert_to_mode call outside the loop.\n\t* expr.c (alignment_for_piecewise_move): Use opt_scalar_int_mode\n\tfor the mode iterator.  Require the mode specified by max_pieces\n\tto exist.\n\t(emit_block_move_via_movmem): Use opt_scalar_int_mode for the\n\tmode iterator.\n\t(copy_blkmode_to_reg): Likewise.\n\t(set_storage_via_setmem): Likewise.\n\t* optabs.c (prepare_cmp_insn): Likewise.\n\t* rtlanal.c (init_num_sign_bit_copies_in_rep): Likewise.\n\t* stor-layout.c (finish_bitfield_representative): Likewise.\n\ngcc/fortran/\n\t* trans-types.c (gfc_init_kinds): Use opt_scalar_int_mode for\n\tthe mode iterator.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r251503", "tree": {"sha": "d8a02d6a9315b50f067bce1643d4b753a588251f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d8a02d6a9315b50f067bce1643d4b753a588251f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/59b5118623ad2e755fbb16b03f2ea122bceebdd2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59b5118623ad2e755fbb16b03f2ea122bceebdd2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/59b5118623ad2e755fbb16b03f2ea122bceebdd2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59b5118623ad2e755fbb16b03f2ea122bceebdd2/comments", "author": null, "committer": null, "parents": [{"sha": "5e4e37bff76a3fbaf4f6e18a343f7c484eeb642e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e4e37bff76a3fbaf4f6e18a343f7c484eeb642e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e4e37bff76a3fbaf4f6e18a343f7c484eeb642e"}], "stats": {"total": 127, "additions": 79, "deletions": 48}, "files": [{"sha": "9e03f631cb2ba8c24c9e76a54eba282f2a390955", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59b5118623ad2e755fbb16b03f2ea122bceebdd2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59b5118623ad2e755fbb16b03f2ea122bceebdd2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=59b5118623ad2e755fbb16b03f2ea122bceebdd2", "patch": "@@ -1,3 +1,22 @@\n+2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* cse.c (cse_insn): Use opt_scalar_int_mode for the mode iterator.\n+\t* explow.c (hard_function_value): Likewise.\n+\t* expmed.c (extract_fixed_bit_field_1): Likewise.  Move the\n+\tconvert_to_mode call outside the loop.\n+\t* expr.c (alignment_for_piecewise_move): Use opt_scalar_int_mode\n+\tfor the mode iterator.  Require the mode specified by max_pieces\n+\tto exist.\n+\t(emit_block_move_via_movmem): Use opt_scalar_int_mode for the\n+\tmode iterator.\n+\t(copy_blkmode_to_reg): Likewise.\n+\t(set_storage_via_setmem): Likewise.\n+\t* optabs.c (prepare_cmp_insn): Likewise.\n+\t* rtlanal.c (init_num_sign_bit_copies_in_rep): Likewise.\n+\t* stor-layout.c (finish_bitfield_representative): Likewise.\n+\n 2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "34ea3d22f547bc91f871f352aea47729034ec713", "filename": "gcc/cse.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59b5118623ad2e755fbb16b03f2ea122bceebdd2/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59b5118623ad2e755fbb16b03f2ea122bceebdd2/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=59b5118623ad2e755fbb16b03f2ea122bceebdd2", "patch": "@@ -4885,11 +4885,12 @@ cse_insn (rtx_insn *insn)\n \t  && GET_CODE (src) == AND && CONST_INT_P (XEXP (src, 1))\n \t  && GET_MODE_SIZE (int_mode) < UNITS_PER_WORD)\n \t{\n-\t  machine_mode tmode;\n+\t  opt_scalar_int_mode tmode_iter;\n \t  rtx new_and = gen_rtx_AND (VOIDmode, NULL_RTX, XEXP (src, 1));\n \n-\t  FOR_EACH_WIDER_MODE (tmode, int_mode)\n+\t  FOR_EACH_WIDER_MODE (tmode_iter, int_mode)\n \t    {\n+\t      scalar_int_mode tmode = tmode_iter.require ();\n \t      if (GET_MODE_SIZE (tmode) > UNITS_PER_WORD)\n \t\tbreak;\n \n@@ -4932,18 +4933,19 @@ cse_insn (rtx_insn *insn)\n \t{\n \t  struct rtx_def memory_extend_buf;\n \t  rtx memory_extend_rtx = &memory_extend_buf;\n-\t  machine_mode tmode;\n \n \t  /* Set what we are trying to extend and the operation it might\n \t     have been extended with.  */\n \t  memset (memory_extend_rtx, 0, sizeof (*memory_extend_rtx));\n \t  PUT_CODE (memory_extend_rtx, extend_op);\n \t  XEXP (memory_extend_rtx, 0) = src;\n \n-\t  FOR_EACH_WIDER_MODE (tmode, int_mode)\n+\t  opt_scalar_int_mode tmode_iter;\n+\t  FOR_EACH_WIDER_MODE (tmode_iter, int_mode)\n \t    {\n \t      struct table_elt *larger_elt;\n \n+\t      scalar_int_mode tmode = tmode_iter.require ();\n \t      if (GET_MODE_SIZE (tmode) > UNITS_PER_WORD)\n \t\tbreak;\n "}, {"sha": "c5af8ee82ef400416a8d1f7a1b3a8ad517d66d1d", "filename": "gcc/explow.c", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59b5118623ad2e755fbb16b03f2ea122bceebdd2/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59b5118623ad2e755fbb16b03f2ea122bceebdd2/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=59b5118623ad2e755fbb16b03f2ea122bceebdd2", "patch": "@@ -1906,7 +1906,7 @@ hard_function_value (const_tree valtype, const_tree func, const_tree fntype,\n       && GET_MODE (val) == BLKmode)\n     {\n       unsigned HOST_WIDE_INT bytes = int_size_in_bytes (valtype);\n-      machine_mode tmpmode;\n+      opt_scalar_int_mode tmpmode;\n \n       /* int_size_in_bytes can return -1.  We don't need a check here\n \t since the value of bytes will then be large enough that no\n@@ -1915,14 +1915,11 @@ hard_function_value (const_tree valtype, const_tree func, const_tree fntype,\n       FOR_EACH_MODE_IN_CLASS (tmpmode, MODE_INT)\n \t{\n \t  /* Have we found a large enough mode?  */\n-\t  if (GET_MODE_SIZE (tmpmode) >= bytes)\n+\t  if (GET_MODE_SIZE (tmpmode.require ()) >= bytes)\n \t    break;\n \t}\n \n-      /* No suitable mode found.  */\n-      gcc_assert (tmpmode != VOIDmode);\n-\n-      PUT_MODE (val, tmpmode);\n+      PUT_MODE (val, tmpmode.require ());\n     }\n   return val;\n }"}, {"sha": "0422ba2ed000c2685509f985b522b823b24cf251", "filename": "gcc/expmed.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59b5118623ad2e755fbb16b03f2ea122bceebdd2/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59b5118623ad2e755fbb16b03f2ea122bceebdd2/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=59b5118623ad2e755fbb16b03f2ea122bceebdd2", "patch": "@@ -2076,12 +2076,13 @@ extract_fixed_bit_field_1 (machine_mode tmode, rtx op0,\n \n   /* Find the narrowest integer mode that contains the field.  */\n \n-  FOR_EACH_MODE_IN_CLASS (mode, MODE_INT)\n-    if (GET_MODE_BITSIZE (mode) >= bitsize + bitnum)\n-      {\n-\top0 = convert_to_mode (mode, op0, 0);\n-\tbreak;\n-      }\n+  opt_scalar_int_mode mode_iter;\n+  FOR_EACH_MODE_IN_CLASS (mode_iter, MODE_INT)\n+    if (GET_MODE_BITSIZE (mode_iter.require ()) >= bitsize + bitnum)\n+      break;\n+\n+  mode = mode_iter.require ();\n+  op0 = convert_to_mode (mode, op0, 0);\n \n   if (mode != tmode)\n     target = 0;"}, {"sha": "f95a7fe64bf7b0e458ec21d8c0adcf5f6e49f6ed", "filename": "gcc/expr.c", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59b5118623ad2e755fbb16b03f2ea122bceebdd2/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59b5118623ad2e755fbb16b03f2ea122bceebdd2/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=59b5118623ad2e755fbb16b03f2ea122bceebdd2", "patch": "@@ -699,18 +699,18 @@ convert_modes (machine_mode mode, machine_mode oldmode, rtx x, int unsignedp)\n static unsigned int\n alignment_for_piecewise_move (unsigned int max_pieces, unsigned int align)\n {\n-  machine_mode tmode;\n+  scalar_int_mode tmode\n+    = int_mode_for_size (max_pieces * BITS_PER_UNIT, 1).require ();\n \n-  tmode = mode_for_size (max_pieces * BITS_PER_UNIT, MODE_INT, 1);\n   if (align >= GET_MODE_ALIGNMENT (tmode))\n     align = GET_MODE_ALIGNMENT (tmode);\n   else\n     {\n-      machine_mode tmode, xmode;\n-\n-      xmode = NARROWEST_INT_MODE;\n-      FOR_EACH_MODE_IN_CLASS (tmode, MODE_INT)\n+      scalar_int_mode xmode = NARROWEST_INT_MODE;\n+      opt_scalar_int_mode mode_iter;\n+      FOR_EACH_MODE_IN_CLASS (mode_iter, MODE_INT)\n \t{\n+\t  tmode = mode_iter.require ();\n \t  if (GET_MODE_SIZE (tmode) > max_pieces\n \t      || SLOW_UNALIGNED_ACCESS (tmode, align))\n \t    break;\n@@ -1707,7 +1707,6 @@ emit_block_move_via_movmem (rtx x, rtx y, rtx size, unsigned int align,\n \t\t\t    unsigned HOST_WIDE_INT probable_max_size)\n {\n   int save_volatile_ok = volatile_ok;\n-  machine_mode mode;\n \n   if (expected_align < align)\n     expected_align = align;\n@@ -1726,8 +1725,10 @@ emit_block_move_via_movmem (rtx x, rtx y, rtx size, unsigned int align,\n      including more than one in the machine description unless\n      the more limited one has some advantage.  */\n \n-  FOR_EACH_MODE_IN_CLASS (mode, MODE_INT)\n+  opt_scalar_int_mode mode_iter;\n+  FOR_EACH_MODE_IN_CLASS (mode_iter, MODE_INT)\n     {\n+      scalar_int_mode mode = mode_iter.require ();\n       enum insn_code code = direct_optab_handler (movmem_optab, mode);\n \n       if (code != CODE_FOR_nothing\n@@ -2791,13 +2792,13 @@ copy_blkmode_to_reg (machine_mode mode, tree src)\n     {\n       /* Find the smallest integer mode large enough to hold the\n \t entire structure.  */\n-      FOR_EACH_MODE_IN_CLASS (mode, MODE_INT)\n-\t/* Have we found a large enough mode?  */\n-\tif (GET_MODE_SIZE (mode) >= bytes)\n+      opt_scalar_int_mode mode_iter;\n+      FOR_EACH_MODE_IN_CLASS (mode_iter, MODE_INT)\n+\tif (GET_MODE_SIZE (mode_iter.require ()) >= bytes)\n \t  break;\n \n       /* A suitable mode should have been found.  */\n-      gcc_assert (mode != VOIDmode);\n+      mode = mode_iter.require ();\n     }\n \n   if (GET_MODE_SIZE (mode) < GET_MODE_SIZE (word_mode))\n@@ -3035,8 +3036,6 @@ set_storage_via_setmem (rtx object, rtx size, rtx val, unsigned int align,\n      including more than one in the machine description unless\n      the more limited one has some advantage.  */\n \n-  machine_mode mode;\n-\n   if (expected_align < align)\n     expected_align = align;\n   if (expected_size != -1)\n@@ -3047,8 +3046,10 @@ set_storage_via_setmem (rtx object, rtx size, rtx val, unsigned int align,\n \texpected_size = min_size;\n     }\n \n-  FOR_EACH_MODE_IN_CLASS (mode, MODE_INT)\n+  opt_scalar_int_mode mode_iter;\n+  FOR_EACH_MODE_IN_CLASS (mode_iter, MODE_INT)\n     {\n+      scalar_int_mode mode = mode_iter.require ();\n       enum insn_code code = direct_optab_handler (setmem_optab, mode);\n \n       if (code != CODE_FOR_nothing"}, {"sha": "7fd40d4b6dab67384818115f486f85a56d22efb5", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59b5118623ad2e755fbb16b03f2ea122bceebdd2/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59b5118623ad2e755fbb16b03f2ea122bceebdd2/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=59b5118623ad2e755fbb16b03f2ea122bceebdd2", "patch": "@@ -1,3 +1,10 @@\n+2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* trans-types.c (gfc_init_kinds): Use opt_scalar_int_mode for\n+\tthe mode iterator.\n+\n 2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "a3b4c0786479035c0d49674710a4efc5586339ef", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59b5118623ad2e755fbb16b03f2ea122bceebdd2/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59b5118623ad2e755fbb16b03f2ea122bceebdd2/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=59b5118623ad2e755fbb16b03f2ea122bceebdd2", "patch": "@@ -363,15 +363,16 @@ gfc_init_c_interop_kinds (void)\n void\n gfc_init_kinds (void)\n {\n-  machine_mode mode;\n+  opt_scalar_int_mode int_mode_iter;\n   opt_scalar_float_mode float_mode_iter;\n   int i_index, r_index, kind;\n   bool saw_i4 = false, saw_i8 = false;\n   bool saw_r4 = false, saw_r8 = false, saw_r10 = false, saw_r16 = false;\n \n-  for (i_index = 0, mode = MIN_MODE_INT; mode <= MAX_MODE_INT;\n-       mode = (machine_mode) ((int) mode + 1))\n+  i_index = 0;\n+  FOR_EACH_MODE_IN_CLASS (int_mode_iter, MODE_INT)\n     {\n+      scalar_int_mode mode = int_mode_iter.require ();\n       int kind, bitsize;\n \n       if (!targetm.scalar_mode_supported_p (mode))"}, {"sha": "bc93fcf25c015a74b9d7e9156148fa1cd3b37210", "filename": "gcc/optabs.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59b5118623ad2e755fbb16b03f2ea122bceebdd2/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59b5118623ad2e755fbb16b03f2ea122bceebdd2/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=59b5118623ad2e755fbb16b03f2ea122bceebdd2", "patch": "@@ -3800,8 +3800,10 @@ prepare_cmp_insn (rtx x, rtx y, enum rtx_code comparison, rtx size,\n \n       /* Try to use a memory block compare insn - either cmpstr\n \t or cmpmem will do.  */\n-      FOR_EACH_MODE_IN_CLASS (cmp_mode, MODE_INT)\n+      opt_scalar_int_mode cmp_mode_iter;\n+      FOR_EACH_MODE_IN_CLASS (cmp_mode_iter, MODE_INT)\n \t{\n+\t  scalar_int_mode cmp_mode = cmp_mode_iter.require ();\n \t  cmp_code = direct_optab_handler (cmpmem_optab, cmp_mode);\n \t  if (cmp_code == CODE_FOR_nothing)\n \t    cmp_code = direct_optab_handler (cmpstr_optab, cmp_mode);"}, {"sha": "63009a2f0083a1e6bdafc92d6bda1ca654a94c76", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59b5118623ad2e755fbb16b03f2ea122bceebdd2/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59b5118623ad2e755fbb16b03f2ea122bceebdd2/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=59b5118623ad2e755fbb16b03f2ea122bceebdd2", "patch": "@@ -5660,12 +5660,14 @@ get_condition (rtx_insn *jump, rtx_insn **earliest, int allow_cc_mode,\n static void\n init_num_sign_bit_copies_in_rep (void)\n {\n-  machine_mode mode, in_mode;\n+  opt_scalar_int_mode in_mode_iter;\n+  scalar_int_mode mode;\n \n-  FOR_EACH_MODE_IN_CLASS (in_mode, MODE_INT)\n-    FOR_EACH_MODE_UNTIL (mode, in_mode)\n+  FOR_EACH_MODE_IN_CLASS (in_mode_iter, MODE_INT)\n+    FOR_EACH_MODE_UNTIL (mode, in_mode_iter.require ())\n       {\n-\tmachine_mode i;\n+\tscalar_int_mode in_mode = in_mode_iter.require ();\n+\tscalar_int_mode i;\n \n \t/* Currently, it is assumed that TARGET_MODE_REP_EXTENDED\n \t   extends to the next widest mode.  */\n@@ -5678,7 +5680,7 @@ init_num_sign_bit_copies_in_rep (void)\n \t  {\n \t    /* This must always exist (for the last iteration it will be\n \t       IN_MODE).  */\n-\t    machine_mode wider = GET_MODE_WIDER_MODE (i).require ();\n+\t    scalar_int_mode wider = GET_MODE_WIDER_MODE (i).require ();\n \n \t    if (targetm.mode_rep_extended (i, wider) == SIGN_EXTEND\n \t\t/* We can only check sign-bit copies starting from the"}, {"sha": "ad42c040e0738d172568fd36103f60f7e79f6f40", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59b5118623ad2e755fbb16b03f2ea122bceebdd2/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59b5118623ad2e755fbb16b03f2ea122bceebdd2/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=59b5118623ad2e755fbb16b03f2ea122bceebdd2", "patch": "@@ -1888,7 +1888,6 @@ static void\n finish_bitfield_representative (tree repr, tree field)\n {\n   unsigned HOST_WIDE_INT bitsize, maxbitsize;\n-  machine_mode mode;\n   tree nextf, size;\n \n   size = size_diffop (DECL_FIELD_OFFSET (field),\n@@ -1953,15 +1952,15 @@ finish_bitfield_representative (tree repr, tree field)\n   gcc_assert (maxbitsize % BITS_PER_UNIT == 0);\n \n   /* Find the smallest nice mode to use.  */\n-  FOR_EACH_MODE_IN_CLASS (mode, MODE_INT)\n-    if (GET_MODE_BITSIZE (mode) >= bitsize)\n+  opt_scalar_int_mode mode_iter;\n+  FOR_EACH_MODE_IN_CLASS (mode_iter, MODE_INT)\n+    if (GET_MODE_BITSIZE (mode_iter.require ()) >= bitsize)\n       break;\n-  if (mode != VOIDmode\n-      && (GET_MODE_BITSIZE (mode) > maxbitsize\n-\t  || GET_MODE_BITSIZE (mode) > MAX_FIXED_MODE_SIZE))\n-    mode = VOIDmode;\n \n-  if (mode == VOIDmode)\n+  scalar_int_mode mode;\n+  if (!mode_iter.exists (&mode)\n+      || GET_MODE_BITSIZE (mode) > maxbitsize\n+      || GET_MODE_BITSIZE (mode) > MAX_FIXED_MODE_SIZE)\n     {\n       /* We really want a BLKmode representative only as a last resort,\n          considering the member b in"}]}