{"sha": "7c4c65d11469d29403d5a88316445ec95cd3c3f8", "node_id": "C_kwDOANBUbNoAKDdjNGM2NWQxMTQ2OWQyOTQwM2Q1YTg4MzE2NDQ1ZWM5NWNkM2MzZjg", "commit": {"author": {"name": "Francois-Xavier Coudert", "email": "fxcoudert@gcc.gnu.org", "date": "2022-08-31T13:22:50Z"}, "committer": {"name": "Francois-Xavier Coudert", "email": "fxcoudert@gmail.com", "date": "2022-09-10T10:11:37Z"}, "message": "fortran: Add IEEE_SIGNBIT and IEEE_FMA functions\n\nThe functions are added to the IEEE_ARITHMETIC module, but\nare entirely expanded in the front-end, using GCC built-ins.\n\n2022-08-31  Francois-Xavier Coudert <fxcoudert@gcc.gnu.org>\n\n\tPR fortran/95644\n\ngcc/fortran/\n\t* f95-lang.cc (gfc_init_builtin_functions): Declare FMA\n\tbuilt-ins.\n\t* mathbuiltins.def: Declare FMA built-ins.\n\t* trans-intrinsic.cc (conv_intrinsic_ieee_fma): New function.\n\t(conv_intrinsic_ieee_signbit): New function.\n\t(gfc_build_intrinsic_lib_fndecls): Add cases for FMA and\n\tSIGNBIT.\n\ngcc/testsuite/\n\t* gfortran.dg/ieee/fma_1.f90: New test.\n\t* gfortran.dg/ieee/signbit_1.f90: New test.\n\nlibgfortran/\n\t* ieee/ieee_arithmetic.F90: Add IEEE_SIGNBIT and IEEE_FMA.", "tree": {"sha": "550c3386757612d2dd7a7f5ec15086f7c7c3c92d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/550c3386757612d2dd7a7f5ec15086f7c7c3c92d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7c4c65d11469d29403d5a88316445ec95cd3c3f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c4c65d11469d29403d5a88316445ec95cd3c3f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c4c65d11469d29403d5a88316445ec95cd3c3f8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c4c65d11469d29403d5a88316445ec95cd3c3f8/comments", "author": {"login": "fxcoudert", "id": 1980544, "node_id": "MDQ6VXNlcjE5ODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1980544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fxcoudert", "html_url": "https://github.com/fxcoudert", "followers_url": "https://api.github.com/users/fxcoudert/followers", "following_url": "https://api.github.com/users/fxcoudert/following{/other_user}", "gists_url": "https://api.github.com/users/fxcoudert/gists{/gist_id}", "starred_url": "https://api.github.com/users/fxcoudert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fxcoudert/subscriptions", "organizations_url": "https://api.github.com/users/fxcoudert/orgs", "repos_url": "https://api.github.com/users/fxcoudert/repos", "events_url": "https://api.github.com/users/fxcoudert/events{/privacy}", "received_events_url": "https://api.github.com/users/fxcoudert/received_events", "type": "User", "site_admin": false}, "committer": {"login": "fxcoudert", "id": 1980544, "node_id": "MDQ6VXNlcjE5ODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1980544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fxcoudert", "html_url": "https://github.com/fxcoudert", "followers_url": "https://api.github.com/users/fxcoudert/followers", "following_url": "https://api.github.com/users/fxcoudert/following{/other_user}", "gists_url": "https://api.github.com/users/fxcoudert/gists{/gist_id}", "starred_url": "https://api.github.com/users/fxcoudert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fxcoudert/subscriptions", "organizations_url": "https://api.github.com/users/fxcoudert/orgs", "repos_url": "https://api.github.com/users/fxcoudert/repos", "events_url": "https://api.github.com/users/fxcoudert/events{/privacy}", "received_events_url": "https://api.github.com/users/fxcoudert/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "861d1a11c0a052ddb3851950d3c0db86b320646d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/861d1a11c0a052ddb3851950d3c0db86b320646d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/861d1a11c0a052ddb3851950d3c0db86b320646d"}], "stats": {"total": 400, "additions": 398, "deletions": 2}, "files": [{"sha": "ff4bf800e497349ee2de8d072794a7c6374803d6", "filename": "gcc/fortran/f95-lang.cc", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c4c65d11469d29403d5a88316445ec95cd3c3f8/gcc%2Ffortran%2Ff95-lang.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c4c65d11469d29403d5a88316445ec95cd3c3f8/gcc%2Ffortran%2Ff95-lang.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ff95-lang.cc?ref=7c4c65d11469d29403d5a88316445ec95cd3c3f8", "patch": "@@ -1281,6 +1281,22 @@ gfc_init_builtin_functions (void)\n \t\t      \"__builtin_assume_aligned\",\n \t\t      ATTR_CONST_NOTHROW_LEAF_LIST);\n \n+  ftype = build_function_type_list (long_double_type_node, long_double_type_node,\n+\t\t\t\t    long_double_type_node, long_double_type_node,\n+\t\t\t\t    NULL_TREE);\n+  gfc_define_builtin (\"__builtin_fmal\", ftype, BUILT_IN_FMAL,\n+\t\t      \"fmal\", ATTR_CONST_NOTHROW_LEAF_LIST);\n+  ftype = build_function_type_list (double_type_node, double_type_node,\n+\t\t\t\t    double_type_node, double_type_node,\n+\t\t\t\t    NULL_TREE);\n+  gfc_define_builtin (\"__builtin_fma\", ftype, BUILT_IN_FMA,\n+\t\t      \"fma\", ATTR_CONST_NOTHROW_LEAF_LIST);\n+  ftype = build_function_type_list (float_type_node, float_type_node,\n+\t\t\t\t    float_type_node, float_type_node,\n+\t\t\t\t    NULL_TREE);\n+  gfc_define_builtin (\"__builtin_fmaf\", ftype, BUILT_IN_FMAF,\n+\t\t      \"fmaf\", ATTR_CONST_NOTHROW_LEAF_LIST);\n+\n   gfc_define_builtin (\"__emutls_get_address\",\n \t\t      builtin_types[BT_FN_PTR_PTR],\n \t\t      BUILT_IN_EMUTLS_GET_ADDRESS,"}, {"sha": "9d55c34cda8a2a3e459bf280ff1421a911e247fb", "filename": "gcc/fortran/mathbuiltins.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c4c65d11469d29403d5a88316445ec95cd3c3f8/gcc%2Ffortran%2Fmathbuiltins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c4c65d11469d29403d5a88316445ec95cd3c3f8/gcc%2Ffortran%2Fmathbuiltins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmathbuiltins.def?ref=7c4c65d11469d29403d5a88316445ec95cd3c3f8", "patch": "@@ -60,6 +60,7 @@ OTHER_BUILTIN (CABS,      \"cabs\",      cabs,    true)\n OTHER_BUILTIN (COPYSIGN,  \"copysign\",  2,       true)\n OTHER_BUILTIN (CPOW,      \"cpow\",      cpow,    true)\n OTHER_BUILTIN (FABS,      \"fabs\",      1,       true)\n+OTHER_BUILTIN (FMA,       \"fma\",       3,       true)\n OTHER_BUILTIN (FMOD,      \"fmod\",      2,       true)\n OTHER_BUILTIN (FREXP,     \"frexp\",     frexp,   false)\n OTHER_BUILTIN (LOGB,      \"logb\",      1,       true)"}, {"sha": "bb938026828be28125df5d92f9b3a07f561c6e25", "filename": "gcc/fortran/trans-intrinsic.cc", "status": "modified", "additions": 49, "deletions": 2, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c4c65d11469d29403d5a88316445ec95cd3c3f8/gcc%2Ffortran%2Ftrans-intrinsic.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c4c65d11469d29403d5a88316445ec95cd3c3f8/gcc%2Ffortran%2Ftrans-intrinsic.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.cc?ref=7c4c65d11469d29403d5a88316445ec95cd3c3f8", "patch": "@@ -695,7 +695,7 @@ gfc_build_intrinsic_lib_fndecls (void)\n        C99-like library functions.  For now, we only handle _Float128\n        q-suffixed or IEC 60559 f128-suffixed functions.  */\n \n-    tree type, complex_type, func_1, func_2, func_cabs, func_frexp;\n+    tree type, complex_type, func_1, func_2, func_3, func_cabs, func_frexp;\n     tree func_iround, func_lround, func_llround, func_scalbn, func_cpow;\n \n     memset (quad_decls, 0, sizeof(tree) * (END_BUILTINS + 1));\n@@ -715,6 +715,8 @@ gfc_build_intrinsic_lib_fndecls (void)\n \t\t\t\t\t     type, NULL_TREE);\n     /* type (*) (type, type) */\n     func_2 = build_function_type_list (type, type, type, NULL_TREE);\n+    /* type (*) (type, type, type) */\n+    func_3 = build_function_type_list (type, type, type, type, NULL_TREE);\n     /* type (*) (type, &int) */\n     func_frexp\n       = build_function_type_list (type,\n@@ -9781,7 +9783,7 @@ conv_ieee_function_args (gfc_se *se, gfc_expr *expr, tree *argarray,\n }\n \n \n-/* Generate code for intrinsics IEEE_IS_NAN, IEEE_IS_FINITE,\n+/* Generate code for intrinsics IEEE_IS_NAN, IEEE_IS_FINITE\n    and IEEE_UNORDERED, which translate directly to GCC type-generic\n    built-ins.  */\n \n@@ -9801,6 +9803,23 @@ conv_intrinsic_ieee_builtin (gfc_se * se, gfc_expr * expr,\n }\n \n \n+/* Generate code for intrinsics IEEE_SIGNBIT.  */\n+\n+static void\n+conv_intrinsic_ieee_signbit (gfc_se * se, gfc_expr * expr)\n+{\n+  tree arg, signbit;\n+\n+  conv_ieee_function_args (se, expr, &arg, 1);\n+  signbit = build_call_expr_loc (input_location,\n+\t\t\t\t builtin_decl_explicit (BUILT_IN_SIGNBIT),\n+\t\t\t\t 1, arg);\n+  signbit = fold_build2_loc (input_location, NE_EXPR, logical_type_node,\n+\t\t\t     signbit, integer_zero_node);\n+  se->expr = fold_convert (gfc_typenode_for_spec (&expr->ts), signbit);\n+}\n+\n+\n /* Generate code for IEEE_IS_NORMAL intrinsic:\n      IEEE_IS_NORMAL(x) --> (__builtin_isnormal(x) || x == 0)  */\n \n@@ -10207,6 +10226,30 @@ conv_intrinsic_ieee_value (gfc_se *se, gfc_expr *expr)\n }\n \n \n+/* Generate code for IEEE_FMA.  */\n+\n+static void\n+conv_intrinsic_ieee_fma (gfc_se * se, gfc_expr * expr)\n+{\n+  tree args[3], decl, call;\n+  int argprec;\n+\n+  conv_ieee_function_args (se, expr, args, 3);\n+\n+  /* All three arguments should have the same type.  */\n+  gcc_assert (TYPE_PRECISION (TREE_TYPE (args[0])) == TYPE_PRECISION (TREE_TYPE (args[1])));\n+  gcc_assert (TYPE_PRECISION (TREE_TYPE (args[0])) == TYPE_PRECISION (TREE_TYPE (args[2])));\n+\n+  /* Call the type-generic FMA built-in.  */\n+  argprec = TYPE_PRECISION (TREE_TYPE (args[0]));\n+  decl = builtin_decl_for_precision (BUILT_IN_FMA, argprec);\n+  call = build_call_expr_loc_array (input_location, decl, 3, args);\n+\n+  /* Convert to the final type.  */\n+  se->expr = fold_convert (TREE_TYPE (args[0]), call);\n+}\n+\n+\n /* Generate code for an intrinsic function from the IEEE_ARITHMETIC\n    module.  */\n \n@@ -10221,6 +10264,8 @@ gfc_conv_ieee_arithmetic_function (gfc_se * se, gfc_expr * expr)\n     conv_intrinsic_ieee_builtin (se, expr, BUILT_IN_ISFINITE, 1);\n   else if (startswith (name, \"_gfortran_ieee_unordered\"))\n     conv_intrinsic_ieee_builtin (se, expr, BUILT_IN_ISUNORDERED, 2);\n+  else if (startswith (name, \"_gfortran_ieee_signbit\"))\n+    conv_intrinsic_ieee_signbit (se, expr);\n   else if (startswith (name, \"_gfortran_ieee_is_normal\"))\n     conv_intrinsic_ieee_is_normal (se, expr);\n   else if (startswith (name, \"_gfortran_ieee_is_negative\"))\n@@ -10241,6 +10286,8 @@ gfc_conv_ieee_arithmetic_function (gfc_se * se, gfc_expr * expr)\n     conv_intrinsic_ieee_class (se, expr);\n   else if (startswith (name, \"ieee_value_\") && ISDIGIT (name[11]))\n     conv_intrinsic_ieee_value (se, expr);\n+  else if (startswith (name, \"_gfortran_ieee_fma\"))\n+    conv_intrinsic_ieee_fma (se, expr);\n   else\n     /* It is not among the functions we translate directly.  We return\n        false, so a library function call is emitted.  */"}, {"sha": "34636426c98cee43b69274853556879b8a341448", "filename": "gcc/testsuite/gfortran.dg/ieee/fma_1.f90", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c4c65d11469d29403d5a88316445ec95cd3c3f8/gcc%2Ftestsuite%2Fgfortran.dg%2Fieee%2Ffma_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c4c65d11469d29403d5a88316445ec95cd3c3f8/gcc%2Ftestsuite%2Fgfortran.dg%2Fieee%2Ffma_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fieee%2Ffma_1.f90?ref=7c4c65d11469d29403d5a88316445ec95cd3c3f8", "patch": "@@ -0,0 +1,100 @@\n+! Test IEEE_FMA\n+! { dg-do run }\n+\n+  use, intrinsic :: ieee_features\n+  use, intrinsic :: ieee_exceptions\n+  use, intrinsic :: ieee_arithmetic\n+  implicit none\n+\n+  integer :: ex\n+\n+  real :: sx1, sx2, sx3\n+  double precision :: dx1, dx2, dx3\n+\n+  ! k1 and k2 will be large real kinds, if supported, and single/double\n+  ! otherwise\n+  integer, parameter :: k1 = &\n+    max(ieee_selected_real_kind(precision(0.d0) + 1), kind(0.))\n+  integer, parameter :: k2 = &\n+    max(ieee_selected_real_kind(precision(0._k1) + 1), kind(0.d0))\n+\n+  real(kind=k1) :: lx1, lx2, lx3\n+  real(kind=k2) :: wx1, wx2, wx3\n+\n+  ! Float\n+\n+  sx1 = 3 ; sx2 = 2 ; sx3 = 1\n+  if (ieee_fma(sx1, sx2, sx3) /= 7) stop 1\n+  sx1 = 0 ; sx2 = 2 ; sx3 = 1\n+  if (ieee_fma(sx1, sx2, sx3) /= 1) stop 2\n+  sx1 = 3 ; sx2 = 2 ; sx3 = 0\n+  if (ieee_fma(sx1, sx2, sx3) /= 6) stop 3\n+\n+  ex = int(log(rrspacing(real(1, kind(sx1)))) / log(real(2, kind(sx1)))) - 1\n+  sx1 = 1 + spacing(real(1, kind(sx1)))\n+  sx2 = 2 ; sx2 = sx2 ** ex ; sx2 = sx2 * 3\n+  sx3 = -sx2\n+\n+  print *, sx1 * sx2 + sx3\n+  print *, ieee_fma(sx1, sx2, sx3)\n+  if (ieee_fma(sx1, sx2, sx3) /= real(3, kind(sx1)) / 2) stop 4\n+  !if (ieee_fma(sx1, sx2, sx3) == sx1 * sx2 + sx3) stop 5\n+\n+  ! Double\n+\n+  dx1 = 3 ; dx2 = 2 ; dx3 = 1\n+  if (ieee_fma(dx1, dx2, dx3) /= 7) stop 1\n+  dx1 = 0 ; dx2 = 2 ; dx3 = 1\n+  if (ieee_fma(dx1, dx2, dx3) /= 1) stop 2\n+  dx1 = 3 ; dx2 = 2 ; dx3 = 0\n+  if (ieee_fma(dx1, dx2, dx3) /= 6) stop 3\n+\n+  ex = int(log(rrspacing(real(1, kind(dx1)))) / log(real(2, kind(dx1)))) - 1\n+  dx1 = 1 + spacing(real(1, kind(dx1)))\n+  dx2 = 2 ; dx2 = dx2 ** ex ; dx2 = dx2 * 3\n+  dx3 = -dx2\n+\n+  print *, dx1 * dx2 + dx3\n+  print *, ieee_fma(dx1, dx2, dx3)\n+  if (ieee_fma(dx1, dx2, dx3) /= real(3, kind(dx1)) / 2) stop 4\n+  !if (ieee_fma(dx1, dx2, dx3) == dx1 * dx2 + dx3) stop 5\n+\n+  ! Large kind 1\n+\n+  lx1 = 3 ; lx2 = 2 ; lx3 = 1\n+  if (ieee_fma(lx1, lx2, lx3) /= 7) stop 1\n+  lx1 = 0 ; lx2 = 2 ; lx3 = 1\n+  if (ieee_fma(lx1, lx2, lx3) /= 1) stop 2\n+  lx1 = 3 ; lx2 = 2 ; lx3 = 0\n+  if (ieee_fma(lx1, lx2, lx3) /= 6) stop 3\n+\n+  ex = int(log(rrspacing(real(1, kind(lx1)))) / log(real(2, kind(lx1)))) - 1\n+  lx1 = 1 + spacing(real(1, kind(lx1)))\n+  lx2 = 2 ; lx2 = lx2 ** ex ; lx2 = lx2 * 3\n+  lx3 = -lx2\n+\n+  print *, lx1 * lx2 + lx3\n+  print *, ieee_fma(lx1, lx2, lx3)\n+  if (ieee_fma(lx1, lx2, lx3) /= real(3, kind(lx1)) / 2) stop 4\n+  if (ieee_fma(lx1, lx2, lx3) == lx1 * lx2 + lx3) stop 5\n+\n+  ! Large kind 2\n+\n+  wx1 = 3 ; wx2 = 2 ; wx3 = 1\n+  if (ieee_fma(wx1, wx2, wx3) /= 7) stop 1\n+  wx1 = 0 ; wx2 = 2 ; wx3 = 1\n+  if (ieee_fma(wx1, wx2, wx3) /= 1) stop 2\n+  wx1 = 3 ; wx2 = 2 ; wx3 = 0\n+  if (ieee_fma(wx1, wx2, wx3) /= 6) stop 3\n+\n+  ex = int(log(rrspacing(real(1, kind(wx1)))) / log(real(2, kind(wx1)))) - 1\n+  wx1 = 1 + spacing(real(1, kind(wx1)))\n+  wx2 = 2 ; wx2 = wx2 ** ex ; wx2 = wx2 * 3\n+  wx3 = -wx2\n+\n+  print *, wx1 * wx2 + wx3\n+  print *, ieee_fma(wx1, wx2, wx3)\n+  if (ieee_fma(wx1, wx2, wx3) /= real(3, kind(wx1)) / 2) stop 4\n+  if (ieee_fma(wx1, wx2, wx3) == wx1 * wx2 + wx3) stop 5\n+\n+end"}, {"sha": "5d6e41de73931901091f93e8ad68409881bab042", "filename": "gcc/testsuite/gfortran.dg/ieee/signbit_1.f90", "status": "added", "additions": 166, "deletions": 0, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c4c65d11469d29403d5a88316445ec95cd3c3f8/gcc%2Ftestsuite%2Fgfortran.dg%2Fieee%2Fsignbit_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c4c65d11469d29403d5a88316445ec95cd3c3f8/gcc%2Ftestsuite%2Fgfortran.dg%2Fieee%2Fsignbit_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fieee%2Fsignbit_1.f90?ref=7c4c65d11469d29403d5a88316445ec95cd3c3f8", "patch": "@@ -0,0 +1,166 @@\n+! Test IEEE_SIGNBIT\n+! { dg-do run }\n+\n+  use, intrinsic :: ieee_features\n+  use, intrinsic :: ieee_exceptions\n+  use, intrinsic :: ieee_arithmetic\n+  implicit none\n+\n+  real :: sx1\n+  double precision :: dx1\n+\n+  ! k1 and k2 will be large real kinds, if supported, and single/double\n+  ! otherwise\n+  integer, parameter :: k1 = &\n+    max(ieee_selected_real_kind(precision(0.d0) + 1), kind(0.))\n+  integer, parameter :: k2 = &\n+    max(ieee_selected_real_kind(precision(0._k1) + 1), kind(0.d0))\n+\n+  real(kind=k1) :: xk1\n+  real(kind=k2) :: xk2\n+\n+  ! Float\n+\n+  sx1 = 1.3\n+  if (ieee_signbit(sx1)) stop 1\n+  sx1 = huge(sx1)\n+  if (ieee_signbit(sx1)) stop 2\n+  sx1 = ieee_value(sx1, ieee_positive_inf)\n+  if (ieee_signbit(sx1)) stop 3\n+  sx1 = tiny(sx1)\n+  if (ieee_signbit(sx1)) stop 4\n+  sx1 = tiny(sx1)\n+  sx1 = sx1 / 101\n+  if (ieee_signbit(sx1)) stop 5\n+  sx1 = 0\n+  if (ieee_signbit(sx1)) stop 6\n+  sx1 = ieee_value(sx1, ieee_quiet_nan)\n+  if (ieee_signbit(sx1)) stop 7\n+\n+  sx1 = -1.3\n+  if (.not. ieee_signbit(sx1)) stop 8\n+  sx1 = -huge(sx1)\n+  if (.not. ieee_signbit(sx1)) stop 9\n+  sx1 = -ieee_value(sx1, ieee_positive_inf)\n+  if (.not. ieee_signbit(sx1)) stop 10\n+  sx1 = -tiny(sx1)\n+  if (.not. ieee_signbit(sx1)) stop 11\n+  sx1 = -tiny(sx1)\n+  sx1 = sx1 / 101\n+  if (.not. ieee_signbit(sx1)) stop 12\n+  sx1 = 0\n+  sx1 = -sx1\n+  if (.not. ieee_signbit(sx1)) stop 13\n+  sx1 = ieee_value(sx1, ieee_quiet_nan)\n+  sx1 = -sx1\n+  if (.not. ieee_signbit(sx1)) stop 14\n+\n+  ! Double\n+\n+  dx1 = 1.3\n+  if (ieee_signbit(dx1)) stop 1\n+  dx1 = huge(dx1)\n+  if (ieee_signbit(dx1)) stop 2\n+  dx1 = ieee_value(dx1, ieee_positive_inf)\n+  if (ieee_signbit(dx1)) stop 3\n+  dx1 = tiny(dx1)\n+  if (ieee_signbit(dx1)) stop 4\n+  dx1 = tiny(dx1)\n+  dx1 = dx1 / 101\n+  if (ieee_signbit(dx1)) stop 5\n+  dx1 = 0\n+  if (ieee_signbit(dx1)) stop 6\n+  dx1 = ieee_value(dx1, ieee_quiet_nan)\n+  if (ieee_signbit(dx1)) stop 7\n+\n+  dx1 = -1.3\n+  if (.not. ieee_signbit(dx1)) stop 8\n+  dx1 = -huge(dx1)\n+  if (.not. ieee_signbit(dx1)) stop 9\n+  dx1 = -ieee_value(dx1, ieee_positive_inf)\n+  if (.not. ieee_signbit(dx1)) stop 10\n+  dx1 = -tiny(dx1)\n+  if (.not. ieee_signbit(dx1)) stop 11\n+  dx1 = -tiny(dx1)\n+  dx1 = dx1 / 101\n+  if (.not. ieee_signbit(dx1)) stop 12\n+  dx1 = 0\n+  dx1 = -dx1\n+  if (.not. ieee_signbit(dx1)) stop 13\n+  dx1 = ieee_value(dx1, ieee_quiet_nan)\n+  dx1 = -dx1\n+  if (.not. ieee_signbit(dx1)) stop 14\n+\n+  ! Large kind 1\n+\n+  xk1 = 1.3\n+  if (ieee_signbit(xk1)) stop 1\n+  xk1 = huge(xk1)\n+  if (ieee_signbit(xk1)) stop 2\n+  xk1 = ieee_value(xk1, ieee_positive_inf)\n+  if (ieee_signbit(xk1)) stop 3\n+  xk1 = tiny(xk1)\n+  if (ieee_signbit(xk1)) stop 4\n+  xk1 = tiny(xk1)\n+  xk1 = xk1 / 101\n+  if (ieee_signbit(xk1)) stop 5\n+  xk1 = 0\n+  if (ieee_signbit(xk1)) stop 6\n+  xk1 = ieee_value(xk1, ieee_quiet_nan)\n+  if (ieee_signbit(xk1)) stop 7\n+\n+  xk1 = -1.3\n+  if (.not. ieee_signbit(xk1)) stop 8\n+  xk1 = -huge(xk1)\n+  if (.not. ieee_signbit(xk1)) stop 9\n+  xk1 = -ieee_value(xk1, ieee_positive_inf)\n+  if (.not. ieee_signbit(xk1)) stop 10\n+  xk1 = -tiny(xk1)\n+  if (.not. ieee_signbit(xk1)) stop 11\n+  xk1 = -tiny(xk1)\n+  xk1 = xk1 / 101\n+  if (.not. ieee_signbit(xk1)) stop 12\n+  xk1 = 0\n+  xk1 = -xk1\n+  if (.not. ieee_signbit(xk1)) stop 13\n+  xk1 = ieee_value(xk1, ieee_quiet_nan)\n+  xk1 = -xk1\n+  if (.not. ieee_signbit(xk1)) stop 14\n+\n+  ! Large kind 2\n+\n+  xk2 = 1.3\n+  if (ieee_signbit(xk2)) stop 1\n+  xk2 = huge(xk2)\n+  if (ieee_signbit(xk2)) stop 2\n+  xk2 = ieee_value(xk2, ieee_positive_inf)\n+  if (ieee_signbit(xk2)) stop 3\n+  xk2 = tiny(xk2)\n+  if (ieee_signbit(xk2)) stop 4\n+  xk2 = tiny(xk2)\n+  xk2 = xk2 / 101\n+  if (ieee_signbit(xk2)) stop 5\n+  xk2 = 0\n+  if (ieee_signbit(xk2)) stop 6\n+  xk2 = ieee_value(xk2, ieee_quiet_nan)\n+  if (ieee_signbit(xk2)) stop 7\n+\n+  xk2 = -1.3\n+  if (.not. ieee_signbit(xk2)) stop 8\n+  xk2 = -huge(xk2)\n+  if (.not. ieee_signbit(xk2)) stop 9\n+  xk2 = -ieee_value(xk2, ieee_positive_inf)\n+  if (.not. ieee_signbit(xk2)) stop 10\n+  xk2 = -tiny(xk2)\n+  if (.not. ieee_signbit(xk2)) stop 11\n+  xk2 = -tiny(xk2)\n+  xk2 = xk2 / 101\n+  if (.not. ieee_signbit(xk2)) stop 12\n+  xk2 = 0\n+  xk2 = -xk2\n+  if (.not. ieee_signbit(xk2)) stop 13\n+  xk2 = ieee_value(xk2, ieee_quiet_nan)\n+  xk2 = -xk2\n+  if (.not. ieee_signbit(xk2)) stop 14\n+\n+end"}, {"sha": "4e01aa5504c18ee4079ceb8cdd328867a2e2c36a", "filename": "libgfortran/ieee/ieee_arithmetic.F90", "status": "modified", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c4c65d11469d29403d5a88316445ec95cd3c3f8/libgfortran%2Fieee%2Fieee_arithmetic.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c4c65d11469d29403d5a88316445ec95cd3c3f8/libgfortran%2Fieee%2Fieee_arithmetic.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fieee%2Fieee_arithmetic.F90?ref=7c4c65d11469d29403d5a88316445ec95cd3c3f8", "patch": "@@ -343,6 +343,39 @@ module IEEE_ARITHMETIC\n   end interface\n   public :: IEEE_UNORDERED\n \n+  ! IEEE_FMA\n+\n+  interface\n+    elemental real(kind=4) function _gfortran_ieee_fma_4 (A, B, C)\n+      real(kind=4), intent(in) :: A, B, C\n+    end function\n+    elemental real(kind=8) function _gfortran_ieee_fma_8 (A, B, C)\n+      real(kind=8), intent(in) :: A, B, C\n+    end function\n+#ifdef HAVE_GFC_REAL_10\n+    elemental real(kind=10) function _gfortran_ieee_fma_10 (A, B, C)\n+      real(kind=10), intent(in) :: A, B, C\n+    end function\n+#endif\n+#ifdef HAVE_GFC_REAL_16\n+    elemental real(kind=16) function _gfortran_ieee_fma_16 (A, B, C)\n+      real(kind=16), intent(in) :: A, B, C\n+    end function\n+#endif\n+  end interface\n+\n+  interface IEEE_FMA\n+    procedure &\n+#ifdef HAVE_GFC_REAL_16\n+      _gfortran_ieee_fma_16, &\n+#endif\n+#ifdef HAVE_GFC_REAL_10\n+      _gfortran_ieee_fma_10, &\n+#endif\n+      _gfortran_ieee_fma_8, _gfortran_ieee_fma_4\n+  end interface\n+  public :: IEEE_FMA\n+\n   ! IEEE_LOGB\n \n   interface\n@@ -702,6 +735,39 @@ module IEEE_ARITHMETIC\n   end interface\n   public :: IEEE_SCALB\n \n+  ! IEEE_SIGNBIT\n+\n+  interface\n+    elemental logical function _gfortran_ieee_signbit_4 (X)\n+      real(kind=4), intent(in) :: X\n+    end function\n+    elemental logical function _gfortran_ieee_signbit_8 (X)\n+      real(kind=8), intent(in) :: X\n+    end function\n+#ifdef HAVE_GFC_REAL_10\n+    elemental logical function _gfortran_ieee_signbit_10 (X)\n+      real(kind=10), intent(in) :: X\n+    end function\n+#endif\n+#ifdef HAVE_GFC_REAL_16\n+    elemental logical function _gfortran_ieee_signbit_16 (X)\n+      real(kind=16), intent(in) :: X\n+    end function\n+#endif\n+  end interface\n+\n+  interface IEEE_SIGNBIT\n+    procedure &\n+#ifdef HAVE_GFC_REAL_16\n+      _gfortran_ieee_signbit_16, &\n+#endif\n+#ifdef HAVE_GFC_REAL_10\n+      _gfortran_ieee_signbit_10, &\n+#endif\n+      _gfortran_ieee_signbit_8, _gfortran_ieee_signbit_4\n+  end interface\n+  public :: IEEE_SIGNBIT\n+\n   ! IEEE_VALUE\n \n   interface IEEE_VALUE"}]}