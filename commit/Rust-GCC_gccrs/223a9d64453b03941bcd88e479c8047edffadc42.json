{"sha": "223a9d64453b03941bcd88e479c8047edffadc42", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjIzYTlkNjQ0NTNiMDM5NDFiY2Q4OGU0NzljODA0N2VkZmZhZGM0Mg==", "commit": {"author": {"name": "Naveen.H.S", "email": "naveen.S@kpitcummins.com", "date": "2010-07-26T09:39:04Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "2010-07-26T09:39:04Z"}, "message": "configure.ac: Support all v850 targets.\n\n        * configure.ac: Support all v850 targets.\n        * configure: Regenerate.\n\n        * config/v850/lib1funcs.asm (save_r2_r31, return_r2_r31,\n        save_r20_r31, return_r20_r31, save_r21_r31, return_r21_r31,\n        save_r22_r31, return_r22_r31, save_r23_r31, return_r23_r31,\n        save_r24_r31, return_r24_r31, save_r25_r31, return_r25_r31,\n        save_r26_r31, return_r26_r31, save_r27_r31, return_r27_r31,\n        save_r28_r31, return_r28_r31, save_r29_r31, return_r29_r31,\n        save_r31, return_r31, save_interrupt, return_interrupt,\n        save_all_interrupt, return_all_interrupt, L_save_r2_r31,\n        L_return_interrupt, callt_return_interrupt, L_restore_all_interrupt,\n        L_save_##START##_r31c, L_callt_save_r31c: Updated as per the\n        new ABI requirements.\n        save_r6_r9, L_callt_save_r6_r9: Remove.\n        * config/v850/predicates.md (even_reg_operand, disp23_operand,\n        const_float_1_operand const_float_0_operand): New Predicates.\n        (pattern_is_ok_for_prepare, pattern_is_ok_for_prologue,\n        pattern_is_ok_for_epilogue): Update as per the ABI requirements.\n        * config/v850/t-v850: Update multilibs for new target variants.\n        (save_varargs, callt_save_varargs, callt_save_r6_r9): Remove.\n        * config/v850/t-v850e: Likewise.\n        * config/v850/v850.c (v850_issue_rate): New.\n        (v850_strict_argument_naming): New.\n        (function_arg): Modify to generate a different ABI.\n        (print_operand): Update case 'z' to support float modes.\n        (output_move_single): Modify to generate appropriate and better\n        assembly.\n        (v850_float_z_comparison_operator, v850_select_cc_mode,\n        v850_float_nz_comparison_operator,  v850_gen_float_compare,\n        v850_gen_compare): New functions to support comparison of\n        float values.\n        (ep_memory_offset): Add support for V850E2 targets.\n        (INTERRUPT_FIXED_NUM, INTERRUPT_ALL_SAVE_NUM): Update.\n        (INTERRUPT_REGPARM_NUM): Remove.\n        (compute_register_save_size): Add extra case to save/restore\n        long call.\n        (use_prolog_function): New function to support prologue.\n        (expand_prologue): Add support for V850E2 targets and modified\n        as per the current ABI requirements.\n        (expand_epilogue): Likewise.\n        (construct_restore_jr): Modify based on TARGET_LONG_CALLS.\n        (construct_save_jarl): Likewise.\n        (construct_dispose_instruction): Update as per the current ABI\n        requirements.\n        (construct_prepare_instruction): Likewise.\n        * config/v850/v850.h(TARGET_CPU_DEFAULT): Add target predefines.\n        (TARGET_CPU_v850e2, TARGET_CPU_v850e2v3): Define\n        (CPP_SPEC): Updated to support v850e2 targets.\n        (STRICT_ALIGNMENT): Modified.\n        (FIRST_PSEUDO_REGISTER): Updated to add even registers.\n        (FIXED_REGISTERS): Likewise.\n        (CALL_USED_REGISTERS): Likewise.\n        (CONDITIONAL_REGISTER_USAGE): Updated.\n        (HARD_REGNO_MODE_OK): Updated.\n        (reg_class): Updated to add even registers.\n        (REG_CLASS_NAMES): Likewise.\n        (REG_CLASS_CONTENTS): Likewise.\n        (REGNO_REG_CLASS): Updated for CC registers.\n        (REG_CLASS_FROM_LETTER): Added support for even registers.\n        (REGNO_OK_FOR_BASE_P): Updated for CC registers.\n        (STACK_POINTER_REGNUM, FRAME_POINTER_REGNUM, LINK_POINTER_REGNUM,\n        ARG_POINTER_REGNUM): Updated.\n        (FUNCTION_ARG_ADVANCE): Define.\n        (REG_PARM_STACK_SPACE): Update as per the current ABI requirements.\n        (OUTGOING_REG_PARM_STACK_SPACE): Remove.\n        (EXTRA_CONSTRAINT): Add new constraint 'W' for 23-bit displacement.\n        (GO_IF_LEGITIMATE_ADDRESS): Updated.\n        (SELECT_CC_MODE): Define.\n        (REGISTER_NAMES): Updated to add psw and fcc registers.\n        (ADDITIONAL_REGISTER_NAMES): Updated.\n        (ASM_OUTPUT_ADDR_DIFF_ELT): Updated to support new targets.\n        (JUMP_TABLES_IN_TEXT_SECTION): Updated.\n        * config/v850/v850.md (define_constants): Define new constants.\n        (type): Update store,bit1,macc,div,fpu and single attributes.\n        (cpu): New attribute.\n        (cc): Add set_z attribute.\n        (unsign23byte_load, sign23byte_load, unsign23hword_load,\n        sign23hword_load, 23word_load, 23byte_store, 23hword_store,\n        23word_store): New instructions for 23-bit displacement load and\n        store.\n        (movqi_internal, movhi_internal): Update the attributes.\n        (movsi, movsi_internal_v850e): Updated to support v850e2 targets.\n        (movsi_internal_v850e, movsi_internal, movsf_internal): Update\n        the attributes.\n        (v850_tst1): Modified using CC_REGNUM.\n        (tstsi): Remove.\n        (cmpsi): Modified as define_expand from define_insn.\n        (cmpsi_insn, cmpsf, cmpdf): New instructions.\n        (addsi3, subsi3, negsi2, divmodsi4, udivmodsi4, divmodhi4,\n        udivmodhi4, v850_clr1_1, v850_clr1_2, v850_clr1_3, andsi3,\n        v850_set1_1, v850_set1_3, iorsi3, v850_not1_1, v850_not1_3, xorsi3,\n        one_cmplsi2): Clobber the CC_REGNUM register.\n        (v850_clr1_1, v850_clr1_2, v850_clr1_3, andsi3, v850_set1_1,\n        v850_set1_2, v850_set1_3, iorsi3, v850_not1_1, v850_not1_2,\n        v850_not1_3, xorsi3, one_cmplsi2): Update the attributes\n        accordingly.\n        (setf_insn, set_z_insn, set_nz_insn): New instructions for\n        v850e2v3 target.\n        (movsicc_normal_cc, movsicc_reversed_cc): New instructions.\n        (movsicc, movsicc_normal, movsicc_reversed): Add support for V850E2\n        targets.\n        (sasf_1, sasf_2): Remove.\n        (sasf): New instruction.\n        (rotlhi3, rotlhi3_8, rotlsi3, rotlsi3_16): Update to support V850E2\n        targets. CC_REGNUM register is clobbered and attributes are\n        updated.\n        (branch_z_normal, branch_z_invert, branch_nz_normal,\n        branch_nz_invert): New branch related instructions.\n        (jump): Updated the attributes.\n        (switch): Update to support new targets. CC_REGNUM register is\n        clobbered and attributes are updated.\n        (call_internal_short, call_internal_long, call_value_internal_short,\n        call_value_internal_long): Updated the attributes.\n        (zero_extendhisi2, zero_extendqisi2): CC_REGNUM register is\n        clobbered and attributes are updated.\n        (extendhisi_insn, extendhisi2, extendqisi_insn, extendqisi2):\n        Update to support new targets. CC_REGNUM register is clobbered.\n        (ashlsi3_v850e2, lshrsi3_v850e2, ashrsi3_v850e2): New shift\n        instructions.\n        (lshrsi3, ashrsi3): CC_REGNUM register is clobbered and attributes\n        are updated.\n        (ffssi2, addsf3, adddf3, subsf3, subdf3, mulsf3, muldf3, divsf3,\n        divdf3, minsf3, mindf3, maxsf3, maxdf3, abssf2, absdf2, negsf2,\n        negdf2, sqrtsf2, sqrtdf2, truncsfsi2, truncdfsi2, floatsisf2,\n        floatsidf2, extendsfdf2, extenddfsf2, recipsf2, recipdf2,\n        rsqrtsf2, rsqrtdf2, maddsf4, msubsf4, nmaddsf4, nmsubsf4,\n        cmpsf_le_insn, cmpsf_lt_insn, cmpsf_ge_insn, cmpsf_gt_insn,\n        cmpsf_eq_insn, cmpsf_ne_insn, cmpdf_le_insn, cmpdf_lt_insn,\n        cmpdf_ge_insn, cmpdf_gt_insn, cmpdf_eq_insn, cmpdf_ne_insn, trfsr,\n        movsfcc, movdfcc, movsfcc_z_insn, movsfcc_nz_insn, movdfcc_z_insn,\n        movdfcc_nz_insn, movedfcc_z_zero, movedfcc_nz_zero): New floating\n        point instructions defined for V850e2v3 target.\n        (callt_save_interrupt, callt_return_interrupt, return_interrupt):\n        Add support for V850E2 targets and CC_REGNUM register is clobbered.\n        (callt_save_all_interrupt, callt_restore_all_interrupt): Add\n        support for new targets.\n        * config/v850/v850-modes.def: New file.\n        * config/v850/v850.opt(mstrict-align): Remove.\n        (mno-strict-align, mjump-tables-in-data-section, mv850e2,\n        mv850e2v3): New command line options for V850.\n        * config.gcc: Update the newly added files.\n        * doc/invoke.texi: Update the newly added command line options for\n        V850 target.\n\nFrom-SVN: r162530", "tree": {"sha": "af8ef80d8e412a2350d830083669a6b2e6cef7c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/af8ef80d8e412a2350d830083669a6b2e6cef7c0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/223a9d64453b03941bcd88e479c8047edffadc42", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/223a9d64453b03941bcd88e479c8047edffadc42", "html_url": "https://github.com/Rust-GCC/gccrs/commit/223a9d64453b03941bcd88e479c8047edffadc42", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/223a9d64453b03941bcd88e479c8047edffadc42/comments", "author": null, "committer": null, "parents": [{"sha": "4e89a3faf8c34372ad9952dde29038b8954f3309", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e89a3faf8c34372ad9952dde29038b8954f3309", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e89a3faf8c34372ad9952dde29038b8954f3309"}], "stats": {"total": 3494, "additions": 2396, "deletions": 1098}, "files": [{"sha": "766fbe5ad6699b2265376e788288e4cb4205be93", "filename": "ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/223a9d64453b03941bcd88e479c8047edffadc42/ChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/223a9d64453b03941bcd88e479c8047edffadc42/ChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/ChangeLog?ref=223a9d64453b03941bcd88e479c8047edffadc42", "patch": "@@ -1,3 +1,8 @@\n+2010-07-26  Naveen.H.S  <naveen.S@kpitcummins.com>\n+\n+\t* configure.ac: Support all v850 targets.\n+\t* configure: Regenerate.\n+\n 2010-07-23  Marc Glisse <marc.glisse@normalesup.org>\n \n \tPR bootstrap/44455"}, {"sha": "fc759d774c16d0238f65c85795707417c8e8cdc6", "filename": "configure", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/223a9d64453b03941bcd88e479c8047edffadc42/configure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/223a9d64453b03941bcd88e479c8047edffadc42/configure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/configure?ref=223a9d64453b03941bcd88e479c8047edffadc42", "patch": "@@ -3730,13 +3730,7 @@ case \"${target}\" in\n   v810-*-*)\n     noconfigdirs=\"$noconfigdirs bfd binutils gas gcc gdb ld target-libstdc++-v3 opcodes target-libgloss ${libgcj}\"\n     ;;\n-  v850-*-*)\n-    noconfigdirs=\"$noconfigdirs target-libgloss ${libgcj}\"\n-    ;;\n-  v850e-*-*)\n-    noconfigdirs=\"$noconfigdirs target-libgloss ${libgcj}\"\n-    ;;\n-  v850ea-*-*)\n+  v850*-*-*)\n     noconfigdirs=\"$noconfigdirs target-libgloss ${libgcj}\"\n     ;;\n   vax-*-vms)"}, {"sha": "3d969aa0ebc282858cca9d537bae91891d506d93", "filename": "configure.ac", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/223a9d64453b03941bcd88e479c8047edffadc42/configure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/223a9d64453b03941bcd88e479c8047edffadc42/configure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/configure.ac?ref=223a9d64453b03941bcd88e479c8047edffadc42", "patch": "@@ -967,13 +967,7 @@ case \"${target}\" in\n   v810-*-*)\n     noconfigdirs=\"$noconfigdirs bfd binutils gas gcc gdb ld target-libstdc++-v3 opcodes target-libgloss ${libgcj}\"\n     ;;\n-  v850-*-*)\n-    noconfigdirs=\"$noconfigdirs target-libgloss ${libgcj}\"\n-    ;;\n-  v850e-*-*)\n-    noconfigdirs=\"$noconfigdirs target-libgloss ${libgcj}\"\n-    ;;\n-  v850ea-*-*)\n+  v850*-*-*)\n     noconfigdirs=\"$noconfigdirs target-libgloss ${libgcj}\"\n     ;;\n   vax-*-vms)"}, {"sha": "fcf57dfad502d90be1737afd50fda907ce3656fb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 144, "deletions": 0, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/223a9d64453b03941bcd88e479c8047edffadc42/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/223a9d64453b03941bcd88e479c8047edffadc42/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=223a9d64453b03941bcd88e479c8047edffadc42", "patch": "@@ -1,3 +1,147 @@\n+2010-07-26  Naveen.H.S  <naveen.S@kpitcummins.com>\n+\n+\t* config/v850/lib1funcs.asm (save_r2_r31, return_r2_r31,\n+\tsave_r20_r31, return_r20_r31, save_r21_r31, return_r21_r31,\n+\tsave_r22_r31, return_r22_r31, save_r23_r31, return_r23_r31,\n+\tsave_r24_r31, return_r24_r31, save_r25_r31, return_r25_r31,\n+\tsave_r26_r31, return_r26_r31, save_r27_r31, return_r27_r31,\n+\tsave_r28_r31, return_r28_r31, save_r29_r31, return_r29_r31,\n+\tsave_r31, return_r31, save_interrupt, return_interrupt,\n+\tsave_all_interrupt, return_all_interrupt, L_save_r2_r31,\n+\tL_return_interrupt, callt_return_interrupt, L_restore_all_interrupt,\n+\tL_save_##START##_r31c, L_callt_save_r31c: Updated as per the\n+\tnew ABI requirements.\n+\tsave_r6_r9, L_callt_save_r6_r9: Remove.\n+\t* config/v850/predicates.md (even_reg_operand, disp23_operand,\n+\tconst_float_1_operand const_float_0_operand): New Predicates.\n+\t(pattern_is_ok_for_prepare, pattern_is_ok_for_prologue,\n+\tpattern_is_ok_for_epilogue): Update as per the ABI requirements.\n+\t* config/v850/t-v850: Update multilibs for new target variants.\n+\t(save_varargs, callt_save_varargs, callt_save_r6_r9): Remove.\n+\t* config/v850/t-v850e: Likewise.\n+\t* config/v850/v850.c (v850_issue_rate): New.\n+\t(v850_strict_argument_naming): New.\n+\t(function_arg): Modify to generate a different ABI.\n+\t(print_operand): Update case 'z' to support float modes.\n+\t(output_move_single): Modify to generate appropriate and better\n+\tassembly.\n+\t(v850_float_z_comparison_operator, v850_select_cc_mode,\n+\tv850_float_nz_comparison_operator,  v850_gen_float_compare,\n+\tv850_gen_compare): New functions to support comparison of\n+\tfloat values.\n+\t(ep_memory_offset): Add support for V850E2 targets.\n+\t(INTERRUPT_FIXED_NUM, INTERRUPT_ALL_SAVE_NUM): Update.\n+\t(INTERRUPT_REGPARM_NUM): Remove.\n+\t(compute_register_save_size): Add extra case to save/restore\n+\tlong call.\n+\t(use_prolog_function): New function to support prologue.\n+\t(expand_prologue): Add support for V850E2 targets and modified\n+\tas per the current ABI requirements.\n+\t(expand_epilogue): Likewise.\n+\t(construct_restore_jr): Modify based on TARGET_LONG_CALLS.\n+\t(construct_save_jarl): Likewise.\n+\t(construct_dispose_instruction): Update as per the current ABI\n+\trequirements.\n+\t(construct_prepare_instruction): Likewise.\n+\t* config/v850/v850.h(TARGET_CPU_DEFAULT): Add target predefines.\n+\t(TARGET_CPU_v850e2, TARGET_CPU_v850e2v3): Define\n+\t(CPP_SPEC): Updated to support v850e2 targets.\n+\t(STRICT_ALIGNMENT): Modified.\n+\t(FIRST_PSEUDO_REGISTER): Updated to add even registers.\n+\t(FIXED_REGISTERS): Likewise.\n+\t(CALL_USED_REGISTERS): Likewise.\n+\t(CONDITIONAL_REGISTER_USAGE): Updated.\n+\t(HARD_REGNO_MODE_OK): Updated.\n+\t(reg_class): Updated to add even registers.\n+\t(REG_CLASS_NAMES): Likewise.\n+\t(REG_CLASS_CONTENTS): Likewise.\n+\t(REGNO_REG_CLASS): Updated for CC registers.\n+\t(REG_CLASS_FROM_LETTER): Added support for even registers.\n+\t(REGNO_OK_FOR_BASE_P): Updated for CC registers.\n+\t(STACK_POINTER_REGNUM, FRAME_POINTER_REGNUM, LINK_POINTER_REGNUM,\n+\tARG_POINTER_REGNUM): Updated.\n+\t(FUNCTION_ARG_ADVANCE): Define.\n+\t(REG_PARM_STACK_SPACE): Update as per the current ABI requirements.\n+\t(OUTGOING_REG_PARM_STACK_SPACE): Remove.\n+\t(EXTRA_CONSTRAINT): Add new constraint 'W' for 23-bit displacement.\n+\t(GO_IF_LEGITIMATE_ADDRESS): Updated.\n+\t(SELECT_CC_MODE): Define.\n+\t(REGISTER_NAMES): Updated to add psw and fcc registers.\n+\t(ADDITIONAL_REGISTER_NAMES): Updated.\n+\t(ASM_OUTPUT_ADDR_DIFF_ELT): Updated to support new targets.\n+\t(JUMP_TABLES_IN_TEXT_SECTION): Updated.\n+\t* config/v850/v850.md (define_constants): Define new constants.\n+\t(type): Update store,bit1,macc,div,fpu and single attributes.\n+\t(cpu): New attribute.\n+\t(cc): Add set_z attribute.\n+\t(unsign23byte_load, sign23byte_load, unsign23hword_load,\n+\tsign23hword_load, 23word_load, 23byte_store, 23hword_store,\n+\t23word_store): New instructions for 23-bit displacement load and\n+\tstore.\n+\t(movqi_internal, movhi_internal): Update the attributes.\n+\t(movsi, movsi_internal_v850e): Updated to support v850e2 targets.\n+\t(movsi_internal_v850e, movsi_internal, movsf_internal): Update\n+\tthe attributes.\n+\t(v850_tst1): Modified using CC_REGNUM.\n+\t(tstsi): Remove.\n+\t(cmpsi): Modified as define_expand from define_insn.\n+\t(cmpsi_insn, cmpsf, cmpdf): New instructions.\n+\t(addsi3, subsi3, negsi2, divmodsi4, udivmodsi4, divmodhi4,\n+\tudivmodhi4, v850_clr1_1, v850_clr1_2, v850_clr1_3, andsi3,\n+\tv850_set1_1, v850_set1_3, iorsi3, v850_not1_1, v850_not1_3, xorsi3,\n+\tone_cmplsi2): Clobber the CC_REGNUM register.\n+\t(v850_clr1_1, v850_clr1_2, v850_clr1_3, andsi3, v850_set1_1,\n+\tv850_set1_2, v850_set1_3, iorsi3, v850_not1_1, v850_not1_2,\n+\tv850_not1_3, xorsi3, one_cmplsi2): Update the attributes\n+\taccordingly.\n+\t(setf_insn, set_z_insn, set_nz_insn): New instructions for\n+\tv850e2v3 target.\n+\t(movsicc_normal_cc, movsicc_reversed_cc): New instructions.\n+\t(movsicc, movsicc_normal, movsicc_reversed): Add support for V850E2\n+\ttargets.\n+\t(sasf_1, sasf_2): Remove.\n+\t(sasf): New instruction.\n+\t(rotlhi3, rotlhi3_8, rotlsi3, rotlsi3_16): Update to support V850E2\n+\ttargets. CC_REGNUM register is clobbered and attributes are\n+\tupdated.\n+\t(branch_z_normal, branch_z_invert, branch_nz_normal,\n+\tbranch_nz_invert): New branch related instructions.\n+\t(jump): Updated the attributes.\n+\t(switch): Update to support new targets. CC_REGNUM register is\n+\tclobbered and attributes are updated.\n+\t(call_internal_short, call_internal_long, call_value_internal_short,\n+\tcall_value_internal_long): Updated the attributes.\n+\t(zero_extendhisi2, zero_extendqisi2): CC_REGNUM register is\n+\tclobbered and attributes are updated.\n+\t(extendhisi_insn, extendhisi2, extendqisi_insn, extendqisi2):\n+\tUpdate to support new targets. CC_REGNUM register is clobbered.\n+\t(ashlsi3_v850e2, lshrsi3_v850e2, ashrsi3_v850e2): New shift\n+\tinstructions.\n+\t(lshrsi3, ashrsi3): CC_REGNUM register is clobbered and attributes\n+\tare updated.\n+\t(ffssi2, addsf3, adddf3, subsf3, subdf3, mulsf3, muldf3, divsf3,\n+\tdivdf3, minsf3, mindf3, maxsf3, maxdf3, abssf2, absdf2, negsf2,\n+\tnegdf2, sqrtsf2, sqrtdf2, truncsfsi2, truncdfsi2, floatsisf2,\n+\tfloatsidf2, extendsfdf2, extenddfsf2, recipsf2, recipdf2,\n+\trsqrtsf2, rsqrtdf2, maddsf4, msubsf4, nmaddsf4, nmsubsf4,\n+\tcmpsf_le_insn, cmpsf_lt_insn, cmpsf_ge_insn, cmpsf_gt_insn,\n+\tcmpsf_eq_insn, cmpsf_ne_insn, cmpdf_le_insn, cmpdf_lt_insn,\n+\tcmpdf_ge_insn, cmpdf_gt_insn, cmpdf_eq_insn, cmpdf_ne_insn, trfsr,\n+\tmovsfcc, movdfcc, movsfcc_z_insn, movsfcc_nz_insn, movdfcc_z_insn,\n+\tmovdfcc_nz_insn, movedfcc_z_zero, movedfcc_nz_zero): New floating\n+\tpoint instructions defined for V850e2v3 target.\n+\t(callt_save_interrupt, callt_return_interrupt, return_interrupt):\n+\tAdd support for V850E2 targets and CC_REGNUM register is clobbered.\n+\t(callt_save_all_interrupt, callt_restore_all_interrupt): Add\n+\tsupport for new targets.\n+\t* config/v850/v850-modes.def: New file.\n+\t* config/v850/v850.opt(mstrict-align): Remove.\n+\t(mno-strict-align, mjump-tables-in-data-section, mv850e2,\n+\tmv850e2v3): New command line options for V850.\n+\t* config.gcc: Update the newly added files.\n+\t* doc/invoke.texi: Update the newly added command line options for\n+\tV850 target.\n+\n 2010-07-26  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/45052"}, {"sha": "3834aecbd26e8ffa7a7d2380e061c80f6303f509", "filename": "gcc/config.gcc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/223a9d64453b03941bcd88e479c8047edffadc42/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/223a9d64453b03941bcd88e479c8047edffadc42/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=223a9d64453b03941bcd88e479c8047edffadc42", "patch": "@@ -2517,6 +2517,7 @@ v850e1-*-*)\n \ttm_p_file=v850/v850-protos.h\n \ttmake_file=v850/t-v850e\n \tmd_file=v850/v850.md\n+\textra_modes=v850/v850-modes.def\n \tout_file=v850/v850.c\n \textra_options=\"${extra_options} v850/v850.opt\"\n \tif test x$stabs = xyes\n@@ -2534,6 +2535,7 @@ v850e-*-*)\n \ttm_p_file=v850/v850-protos.h\n \ttmake_file=v850/t-v850e\n \tmd_file=v850/v850.md\n+\textra_modes=v850/v850-modes.def\n \tout_file=v850/v850.c\n \textra_options=\"${extra_options} v850/v850.opt\"\n \tif test x$stabs = xyes"}, {"sha": "c3312bd0c32acbb987a43d9c4404228395a82f9b", "filename": "gcc/config/v850/lib1funcs.asm", "status": "modified", "additions": 589, "deletions": 641, "changes": 1230, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/223a9d64453b03941bcd88e479c8047edffadc42/gcc%2Fconfig%2Fv850%2Flib1funcs.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/223a9d64453b03941bcd88e479c8047edffadc42/gcc%2Fconfig%2Fv850%2Flib1funcs.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Flib1funcs.asm?ref=223a9d64453b03941bcd88e479c8047edffadc42", "patch": "@@ -80,7 +80,7 @@ ___mulsi3:\n         add   r7,  r10\n         jmp   [r31]\n #endif /* __v850__ */\n-#if defined(__v850e__) || defined(__v850ea__)\n+#if defined(__v850e__) || defined(__v850ea__) || defined(__v850e2__) || defined(__v850e2v3__)\n         /* This routine is almost unneccesarry because gcc\n            generates the MUL instruction for the RTX mulsi3.\n            But if someone wants to link his application with\n@@ -260,8 +260,8 @@ ___modsi3:\n \t.align\t2\n \t.globl\t__save_r2_r29\n \t.type\t__save_r2_r29,@function\n-\t/* Allocate space and save registers 2, 20 .. 29 on the stack */\n-\t/* Called via:\tjalr __save_r2_r29,r10 */\n+\t/* Allocate space and save registers 2, 20 .. 29 on the stack.  */\n+\t/* Called via:\tjalr __save_r2_r29,r10.  */\n __save_r2_r29:\n #ifdef __EP__\n \tmov\tep,r1\n@@ -296,8 +296,8 @@ __save_r2_r29:\n \tjmp\t[r10]\n \t.size\t__save_r2_r29,.-__save_r2_r29\n \n-\t/* Restore saved registers, deallocate stack and return to the user */\n-\t/* Called via:\tjr __return_r2_r29 */\n+\t/* Restore saved registers, deallocate stack and return to the user.  */\n+\t/* Called via:\tjr __return_r2_r29.  */\n \t.align\t2\n \t.globl\t__return_r2_r29\n \t.type\t__return_r2_r29,@function\n@@ -341,8 +341,8 @@ __return_r2_r29:\n \t.align\t2\n \t.globl\t__save_r20_r29\n \t.type\t__save_r20_r29,@function\n-\t/* Allocate space and save registers 20 .. 29 on the stack */\n-\t/* Called via:\tjalr __save_r20_r29,r10 */\n+\t/* Allocate space and save registers 20 .. 29 on the stack.  */\n+\t/* Called via:\tjalr __save_r20_r29,r10.  */\n __save_r20_r29:\n #ifdef __EP__\n \tmov\tep,r1\n@@ -375,8 +375,8 @@ __save_r20_r29:\n \tjmp\t[r10]\n \t.size\t__save_r20_r29,.-__save_r20_r29\n \n-\t/* Restore saved registers, deallocate stack and return to the user */\n-\t/* Called via:\tjr __return_r20_r29 */\n+\t/* Restore saved registers, deallocate stack and return to the user.  */\n+\t/* Called via:\tjr __return_r20_r29.  */\n \t.align\t2\n \t.globl\t__return_r20_r29\n \t.type\t__return_r20_r29,@function\n@@ -418,8 +418,8 @@ __return_r20_r29:\n \t.align\t2\n \t.globl\t__save_r21_r29\n \t.type\t__save_r21_r29,@function\n-\t/* Allocate space and save registers 21 .. 29 on the stack */\n-\t/* Called via:\tjalr __save_r21_r29,r10 */\n+\t/* Allocate space and save registers 21 .. 29 on the stack.  */\n+\t/* Called via:\tjalr __save_r21_r29,r10.  */\n __save_r21_r29:\n #ifdef __EP__\n \tmov\tep,r1\n@@ -450,8 +450,8 @@ __save_r21_r29:\n \tjmp\t[r10]\n \t.size\t__save_r21_r29,.-__save_r21_r29\n \n-\t/* Restore saved registers, deallocate stack and return to the user */\n-\t/* Called via:\tjr __return_r21_r29 */\n+\t/* Restore saved registers, deallocate stack and return to the user.  */\n+\t/* Called via:\tjr __return_r21_r29.  */\n \t.align\t2\n \t.globl\t__return_r21_r29\n \t.type\t__return_r21_r29,@function\n@@ -491,8 +491,8 @@ __return_r21_r29:\n \t.align\t2\n \t.globl\t__save_r22_r29\n \t.type\t__save_r22_r29,@function\n-\t/* Allocate space and save registers 22 .. 29 on the stack */\n-\t/* Called via:\tjalr __save_r22_r29,r10 */\n+\t/* Allocate space and save registers 22 .. 29 on the stack.  */\n+\t/* Called via:\tjalr __save_r22_r29,r10.  */\n __save_r22_r29:\n #ifdef __EP__\n \tmov\tep,r1\n@@ -521,8 +521,8 @@ __save_r22_r29:\n \tjmp\t[r10]\n \t.size\t__save_r22_r29,.-__save_r22_r29\n \n-\t/* Restore saved registers, deallocate stack and return to the user */\n-\t/* Called via:\tjr __return_r22_r29 */\n+\t/* Restore saved registers, deallocate stack and return to the user.  */\n+\t/* Called via:\tjr __return_r22_r29.  */\n \t.align\t2\n \t.globl\t__return_r22_r29\n \t.type\t__return_r22_r29,@function\n@@ -560,8 +560,8 @@ __return_r22_r29:\n \t.align\t2\n \t.globl\t__save_r23_r29\n \t.type\t__save_r23_r29,@function\n-\t/* Allocate space and save registers 23 .. 29 on the stack */\n-\t/* Called via:\tjalr __save_r23_r29,r10 */\n+\t/* Allocate space and save registers 23 .. 29 on the stack.  */\n+\t/* Called via:\tjalr __save_r23_r29,r10.  */\n __save_r23_r29:\n #ifdef __EP__\n \tmov\tep,r1\n@@ -588,8 +588,8 @@ __save_r23_r29:\n \tjmp\t[r10]\n \t.size\t__save_r23_r29,.-__save_r23_r29\n \n-\t/* Restore saved registers, deallocate stack and return to the user */\n-\t/* Called via:\tjr __return_r23_r29 */\n+\t/* Restore saved registers, deallocate stack and return to the user.  */\n+\t/* Called via:\tjr __return_r23_r29.  */\n \t.align\t2\n \t.globl\t__return_r23_r29\n \t.type\t__return_r23_r29,@function\n@@ -625,8 +625,8 @@ __return_r23_r29:\n \t.align\t2\n \t.globl\t__save_r24_r29\n \t.type\t__save_r24_r29,@function\n-\t/* Allocate space and save registers 24 .. 29 on the stack */\n-\t/* Called via:\tjalr __save_r24_r29,r10 */\n+\t/* Allocate space and save registers 24 .. 29 on the stack.  */\n+\t/* Called via:\tjalr __save_r24_r29,r10.  */\n __save_r24_r29:\n #ifdef __EP__\n \tmov\tep,r1\n@@ -651,8 +651,8 @@ __save_r24_r29:\n \tjmp\t[r10]\n \t.size\t__save_r24_r29,.-__save_r24_r29\n \n-\t/* Restore saved registers, deallocate stack and return to the user */\n-\t/* Called via:\tjr __return_r24_r29 */\n+\t/* Restore saved registers, deallocate stack and return to the user.  */\n+\t/* Called via:\tjr __return_r24_r29.  */\n \t.align\t2\n \t.globl\t__return_r24_r29\n \t.type\t__return_r24_r29,@function\n@@ -686,8 +686,8 @@ __return_r24_r29:\n \t.align\t2\n \t.globl\t__save_r25_r29\n \t.type\t__save_r25_r29,@function\n-\t/* Allocate space and save registers 25 .. 29 on the stack */\n-\t/* Called via:\tjalr __save_r25_r29,r10 */\n+\t/* Allocate space and save registers 25 .. 29 on the stack.  */\n+\t/* Called via:\tjalr __save_r25_r29,r10.  */\n __save_r25_r29:\n #ifdef __EP__\n \tmov\tep,r1\n@@ -710,8 +710,8 @@ __save_r25_r29:\n \tjmp\t[r10]\n \t.size\t__save_r25_r29,.-__save_r25_r29\n \n-\t/* Restore saved registers, deallocate stack and return to the user */\n-\t/* Called via:\tjr __return_r25_r29 */\n+\t/* Restore saved registers, deallocate stack and return to the user.  */\n+\t/* Called via:\tjr __return_r25_r29.  */\n \t.align\t2\n \t.globl\t__return_r25_r29\n \t.type\t__return_r25_r29,@function\n@@ -743,8 +743,8 @@ __return_r25_r29:\n \t.align\t2\n \t.globl\t__save_r26_r29\n \t.type\t__save_r26_r29,@function\n-\t/* Allocate space and save registers 26 .. 29 on the stack */\n-\t/* Called via:\tjalr __save_r26_r29,r10 */\n+\t/* Allocate space and save registers 26 .. 29 on the stack.  */\n+\t/* Called via:\tjalr __save_r26_r29,r10.  */\n __save_r26_r29:\n #ifdef __EP__\n \tmov\tep,r1\n@@ -765,8 +765,8 @@ __save_r26_r29:\n \tjmp\t[r10]\n \t.size\t__save_r26_r29,.-__save_r26_r29\n \n-\t/* Restore saved registers, deallocate stack and return to the user */\n-\t/* Called via:\tjr __return_r26_r29 */\n+\t/* Restore saved registers, deallocate stack and return to the user.  */\n+\t/* Called via:\tjr __return_r26_r29.  */\n \t.align\t2\n \t.globl\t__return_r26_r29\n \t.type\t__return_r26_r29,@function\n@@ -796,8 +796,8 @@ __return_r26_r29:\n \t.align\t2\n \t.globl\t__save_r27_r29\n \t.type\t__save_r27_r29,@function\n-\t/* Allocate space and save registers 27 .. 29 on the stack */\n-\t/* Called via:\tjalr __save_r27_r29,r10 */\n+\t/* Allocate space and save registers 27 .. 29 on the stack.  */\n+\t/* Called via:\tjalr __save_r27_r29,r10.  */\n __save_r27_r29:\n \tadd\t-12,sp\n \tst.w\tr29,0[sp]\n@@ -806,8 +806,8 @@ __save_r27_r29:\n \tjmp\t[r10]\n \t.size\t__save_r27_r29,.-__save_r27_r29\n \n-\t/* Restore saved registers, deallocate stack and return to the user */\n-\t/* Called via:\tjr __return_r27_r29 */\n+\t/* Restore saved registers, deallocate stack and return to the user.  */\n+\t/* Called via:\tjr __return_r27_r29.  */\n \t.align\t2\n \t.globl\t__return_r27_r29\n \t.type\t__return_r27_r29,@function\n@@ -825,17 +825,17 @@ __return_r27_r29:\n \t.align\t2\n \t.globl\t__save_r28_r29\n \t.type\t__save_r28_r29,@function\n-\t/* Allocate space and save registers 28,29 on the stack */\n-\t/* Called via:\tjalr __save_r28_r29,r10 */\n+\t/* Allocate space and save registers 28,29 on the stack.  */\n+\t/* Called via:\tjalr __save_r28_r29,r10.  */\n __save_r28_r29:\n \tadd\t-8,sp\n \tst.w\tr29,0[sp]\n \tst.w\tr28,4[sp]\n \tjmp\t[r10]\n \t.size\t__save_r28_r29,.-__save_r28_r29\n \n-\t/* Restore saved registers, deallocate stack and return to the user */\n-\t/* Called via:\tjr __return_r28_r29 */\n+\t/* Restore saved registers, deallocate stack and return to the user.  */\n+\t/* Called via:\tjr __return_r28_r29.  */\n \t.align\t2\n \t.globl\t__return_r28_r29\n \t.type\t__return_r28_r29,@function\n@@ -852,16 +852,16 @@ __return_r28_r29:\n \t.align\t2\n \t.globl\t__save_r29\n \t.type\t__save_r29,@function\n-\t/* Allocate space and save register 29 on the stack */\n-\t/* Called via:\tjalr __save_r29,r10 */\n+\t/* Allocate space and save register 29 on the stack.  */\n+\t/* Called via:\tjalr __save_r29,r10.  */\n __save_r29:\n \tadd\t-4,sp\n \tst.w\tr29,0[sp]\n \tjmp\t[r10]\n \t.size\t__save_r29,.-__save_r29\n \n-\t/* Restore saved register 29, deallocate stack and return to the user */\n-\t/* Called via:\tjr __return_r29 */\n+\t/* Restore saved register 29, deallocate stack and return to the user.  */\n+\t/* Called via:\tjr __return_r29.  */\n \t.align\t2\n \t.globl\t__return_r29\n \t.type\t__return_r29,@function\n@@ -883,76 +883,76 @@ __return_r29:\n __save_r2_r31:\n #ifdef __EP__\n \tmov\tep,r1\n-\taddi\t-64,sp,sp\n+\taddi\t-48,sp,sp\n \tmov\tsp,ep\n-\tsst.w\tr29,16[ep]\n-\tsst.w\tr28,20[ep]\n-\tsst.w\tr27,24[ep]\n-\tsst.w\tr26,28[ep]\n-\tsst.w\tr25,32[ep]\n-\tsst.w\tr24,36[ep]\n-\tsst.w\tr23,40[ep]\n-\tsst.w\tr22,44[ep]\n-\tsst.w\tr21,48[ep]\n-\tsst.w\tr20,52[ep]\n-\tsst.w\tr2,56[ep]\n-\tsst.w\tr31,60[ep]\n+\tsst.w\tr29,0[ep]\n+\tsst.w\tr28,4[ep]\n+\tsst.w\tr27,8[ep]\n+\tsst.w\tr26,12[ep]\n+\tsst.w\tr25,16[ep]\n+\tsst.w\tr24,20[ep]\n+\tsst.w\tr23,24[ep]\n+\tsst.w\tr22,28[ep]\n+\tsst.w\tr21,32[ep]\n+\tsst.w\tr20,36[ep]\n+\tsst.w\tr2,40[ep]\n+\tsst.w\tr31,44[ep]\n \tmov\tr1,ep\n #else\n-\taddi\t-64,sp,sp\n-\tst.w\tr29,16[sp]\n-\tst.w\tr28,20[sp]\n-\tst.w\tr27,24[sp]\n-\tst.w\tr26,28[sp]\n-\tst.w\tr25,32[sp]\n-\tst.w\tr24,36[sp]\n-\tst.w\tr23,40[sp]\n-\tst.w\tr22,44[sp]\n-\tst.w\tr21,48[sp]\n-\tst.w\tr20,52[sp]\n-\tst.w\tr2,56[sp]\n-\tst.w\tr31,60[sp]\n+\taddi\t-48,sp,sp\n+\tst.w\tr29,0[sp]\n+\tst.w\tr28,4[sp]\n+\tst.w\tr27,8[sp]\n+\tst.w\tr26,12[sp]\n+\tst.w\tr25,16[sp]\n+\tst.w\tr24,20[sp]\n+\tst.w\tr23,24[sp]\n+\tst.w\tr22,28[sp]\n+\tst.w\tr21,32[sp]\n+\tst.w\tr20,36[sp]\n+\tst.w\tr2,40[sp]\n+\tst.w\tr31,44[sp]\n #endif\n \tjmp\t[r10]\n \t.size\t__save_r2_r31,.-__save_r2_r31\n \n-\t/* Restore saved registers, deallocate stack and return to the user */\n-\t/* Called via:\tjr __return_r20_r31 */\n+\t/* Restore saved registers, deallocate stack and return to the user.  */\n+\t/* Called via:\tjr __return_r20_r31.  */\n \t.align\t2\n \t.globl\t__return_r2_r31\n \t.type\t__return_r2_r31,@function\n __return_r2_r31:\n #ifdef __EP__\n \tmov\tep,r1\n \tmov\tsp,ep\n-\tsld.w\t16[ep],r29\n-\tsld.w\t20[ep],r28\n-\tsld.w\t24[ep],r27\n-\tsld.w\t28[ep],r26\n-\tsld.w\t32[ep],r25\n-\tsld.w\t36[ep],r24\n-\tsld.w\t40[ep],r23\n-\tsld.w\t44[ep],r22\n-\tsld.w\t48[ep],r21\n-\tsld.w\t52[ep],r20\n-\tsld.w\t56[ep],r2\n-\tsld.w\t60[ep],r31\n-\taddi\t64,sp,sp\n+\tsld.w\t0[ep],r29\n+\tsld.w\t4[ep],r28\n+\tsld.w\t8[ep],r27\n+\tsld.w\t12[ep],r26\n+\tsld.w\t16[ep],r25\n+\tsld.w\t20[ep],r24\n+\tsld.w\t24[ep],r23\n+\tsld.w\t28[ep],r22\n+\tsld.w\t32[ep],r21\n+\tsld.w\t36[ep],r20\n+\tsld.w\t40[ep],r2\n+\tsld.w\t44[ep],r31\n+\taddi\t48,sp,sp\n \tmov\tr1,ep\n #else\n-\tld.w\t16[sp],r29\n-\tld.w\t20[sp],r28\n-\tld.w\t24[sp],r27\n-\tld.w\t28[sp],r26\n-\tld.w\t32[sp],r25\n-\tld.w\t36[sp],r24\n-\tld.w\t40[sp],r23\n-\tld.w\t44[sp],r22\n-\tld.w\t48[sp],r21\n-\tld.w\t52[sp],r20\n-\tld.w\t56[sp],r2\n-\tld.w\t60[sp],r31\n-\taddi\t64,sp,sp\n+\tld.w\t44[sp],r29\n+\tld.w\t40[sp],r28\n+\tld.w\t36[sp],r27\n+\tld.w\t32[sp],r26\n+\tld.w\t28[sp],r25\n+\tld.w\t24[sp],r24\n+\tld.w\t20[sp],r23\n+\tld.w\t16[sp],r22\n+\tld.w\t12[sp],r21\n+\tld.w\t8[sp],r20\n+\tld.w\t4[sp],r2\n+\tld.w\t0[sp],r31\n+\taddi\t48,sp,sp\n #endif\n \tjmp\t[r31]\n \t.size\t__return_r2_r31,.-__return_r2_r31\n@@ -963,78 +963,78 @@ __return_r2_r31:\n \t.align\t2\n \t.globl\t__save_r20_r31\n \t.type\t__save_r20_r31,@function\n-\t/* Allocate space and save registers 20 .. 29, 31 on the stack */\n-\t/* Also allocate space for the argument save area */\n-\t/* Called via:\tjalr __save_r20_r31,r10 */\n+\t/* Allocate space and save registers 20 .. 29, 31 on the stack.  */\n+\t/* Also allocate space for the argument save area.  */\n+\t/* Called via:\tjalr __save_r20_r31,r10.  */\n __save_r20_r31:\n #ifdef __EP__\n \tmov\tep,r1\n-\taddi\t-60,sp,sp\n+\taddi\t-44,sp,sp\n \tmov\tsp,ep\n-\tsst.w\tr29,16[ep]\n-\tsst.w\tr28,20[ep]\n-\tsst.w\tr27,24[ep]\n-\tsst.w\tr26,28[ep]\n-\tsst.w\tr25,32[ep]\n-\tsst.w\tr24,36[ep]\n-\tsst.w\tr23,40[ep]\n-\tsst.w\tr22,44[ep]\n-\tsst.w\tr21,48[ep]\n-\tsst.w\tr20,52[ep]\n-\tsst.w\tr31,56[ep]\n+\tsst.w\tr29,0[ep]\n+\tsst.w\tr28,4[ep]\n+\tsst.w\tr27,8[ep]\n+\tsst.w\tr26,12[ep]\n+\tsst.w\tr25,16[ep]\n+\tsst.w\tr24,20[ep]\n+\tsst.w\tr23,24[ep]\n+\tsst.w\tr22,28[ep]\n+\tsst.w\tr21,32[ep]\n+\tsst.w\tr20,36[ep]\n+\tsst.w\tr31,40[ep]\n \tmov\tr1,ep\n #else\n-\taddi\t-60,sp,sp\n-\tst.w\tr29,16[sp]\n-\tst.w\tr28,20[sp]\n-\tst.w\tr27,24[sp]\n-\tst.w\tr26,28[sp]\n-\tst.w\tr25,32[sp]\n-\tst.w\tr24,36[sp]\n-\tst.w\tr23,40[sp]\n-\tst.w\tr22,44[sp]\n-\tst.w\tr21,48[sp]\n-\tst.w\tr20,52[sp]\n-\tst.w\tr31,56[sp]\n+\taddi\t-44,sp,sp\n+\tst.w\tr29,0[sp]\n+\tst.w\tr28,4[sp]\n+\tst.w\tr27,8[sp]\n+\tst.w\tr26,12[sp]\n+\tst.w\tr25,16[sp]\n+\tst.w\tr24,20[sp]\n+\tst.w\tr23,24[sp]\n+\tst.w\tr22,28[sp]\n+\tst.w\tr21,32[sp]\n+\tst.w\tr20,36[sp]\n+\tst.w\tr31,40[sp]\n #endif\n \tjmp\t[r10]\n \t.size\t__save_r20_r31,.-__save_r20_r31\n \n-\t/* Restore saved registers, deallocate stack and return to the user */\n-\t/* Called via:\tjr __return_r20_r31 */\n+\t/* Restore saved registers, deallocate stack and return to the user.  */\n+\t/* Called via:\tjr __return_r20_r31.  */\n \t.align\t2\n \t.globl\t__return_r20_r31\n \t.type\t__return_r20_r31,@function\n __return_r20_r31:\n #ifdef __EP__\n \tmov\tep,r1\n \tmov\tsp,ep\n-\tsld.w\t16[ep],r29\n-\tsld.w\t20[ep],r28\n-\tsld.w\t24[ep],r27\n-\tsld.w\t28[ep],r26\n-\tsld.w\t32[ep],r25\n-\tsld.w\t36[ep],r24\n-\tsld.w\t40[ep],r23\n-\tsld.w\t44[ep],r22\n-\tsld.w\t48[ep],r21\n-\tsld.w\t52[ep],r20\n-\tsld.w\t56[ep],r31\n-\taddi\t60,sp,sp\n+\tsld.w\t0[ep],r29\n+\tsld.w\t4[ep],r28\n+\tsld.w\t8[ep],r27\n+\tsld.w\t12[ep],r26\n+\tsld.w\t16[ep],r25\n+\tsld.w\t20[ep],r24\n+\tsld.w\t24[ep],r23\n+\tsld.w\t28[ep],r22\n+\tsld.w\t32[ep],r21\n+\tsld.w\t36[ep],r20\n+\tsld.w\t40[ep],r31\n+\taddi\t44,sp,sp\n \tmov\tr1,ep\n #else\n-\tld.w\t16[sp],r29\n-\tld.w\t20[sp],r28\n-\tld.w\t24[sp],r27\n-\tld.w\t28[sp],r26\n-\tld.w\t32[sp],r25\n-\tld.w\t36[sp],r24\n-\tld.w\t40[sp],r23\n-\tld.w\t44[sp],r22\n-\tld.w\t48[sp],r21\n-\tld.w\t52[sp],r20\n-\tld.w\t56[sp],r31\n-\taddi\t60,sp,sp\n+\tld.w\t0[sp],r29\n+\tld.w\t4[sp],r28\n+\tld.w\t8[sp],r27\n+\tld.w\t12[sp],r26\n+\tld.w\t16[sp],r25\n+\tld.w\t20[sp],r24\n+\tld.w\t24[sp],r23\n+\tld.w\t28[sp],r22\n+\tld.w\t32[sp],r21\n+\tld.w\t36[sp],r20\n+\tld.w\t40[sp],r31\n+\taddi\t44,sp,sp\n #endif\n \tjmp\t[r31]\n \t.size\t__return_r20_r31,.-__return_r20_r31\n@@ -1045,74 +1045,75 @@ __return_r20_r31:\n \t.align\t2\n \t.globl\t__save_r21_r31\n \t.type\t__save_r21_r31,@function\n-\t/* Allocate space and save registers 21 .. 29, 31 on the stack */\n-\t/* Also allocate space for the argument save area */\n-\t/* Called via:\tjalr __save_r21_r31,r10 */\n+\t/* Allocate space and save registers 21 .. 29, 31 on the stack.  */\n+\t/* Also allocate space for the argument save area.  */\n+\t/* Called via:\tjalr __save_r21_r31,r10.  */\n __save_r21_r31:\n-#ifdef __EP__\n+#ifdef __EP__\t\n \tmov\tep,r1\n-\taddi\t-56,sp,sp\n+\taddi\t-40,sp,sp\n \tmov\tsp,ep\n-\tsst.w\tr29,16[ep]\n-\tsst.w\tr28,20[ep]\n-\tsst.w\tr27,24[ep]\n-\tsst.w\tr26,28[ep]\n-\tsst.w\tr25,32[ep]\n-\tsst.w\tr24,36[ep]\n-\tsst.w\tr23,40[ep]\n-\tsst.w\tr22,44[ep]\n-\tsst.w\tr21,48[ep]\n-\tsst.w\tr31,52[ep]\n+\tsst.w\tr29,0[ep]\n+\tsst.w\tr28,4[ep]\n+\tsst.w\tr27,8[ep]\n+\tsst.w\tr26,12[ep]\n+\tsst.w\tr25,16[ep]\n+\tsst.w\tr24,20[ep]\n+\tsst.w\tr23,24[ep]\n+\tsst.w\tr22,28[ep]\n+\tsst.w\tr21,32[ep]\n+\tsst.w\tr31,36[ep]\n \tmov\tr1,ep\n-#else\n-\taddi\t-56,sp,sp\n-\tst.w\tr29,16[sp]\n-\tst.w\tr28,20[sp]\n-\tst.w\tr27,24[sp]\n-\tst.w\tr26,28[sp]\n-\tst.w\tr25,32[sp]\n-\tst.w\tr24,36[sp]\n-\tst.w\tr23,40[sp]\n-\tst.w\tr22,44[sp]\n-\tst.w\tr21,48[sp]\n-\tst.w\tr31,52[sp]\n-#endif\n \tjmp\t[r10]\n+#else\t\n+\taddi\t-40,sp,sp\n+\tst.w\tr29,0[sp]\n+\tst.w\tr28,4[sp]\n+\tst.w\tr27,8[sp]\n+\tst.w\tr26,12[sp]\n+\tst.w\tr25,16[sp]\n+\tst.w\tr24,20[sp]\n+\tst.w\tr23,24[sp]\n+\tst.w\tr22,28[sp]\n+\tst.w\tr21,32[sp]\n+\tst.w\tr31,36[sp]\n+\tjmp\t[r10]\n+#endif\t\n \t.size\t__save_r21_r31,.-__save_r21_r31\n \n-\t/* Restore saved registers, deallocate stack and return to the user */\n-\t/* Called via:\tjr __return_r21_r31 */\n+\t/* Restore saved registers, deallocate stack and return to the user.  */\n+\t/* Called via:\tjr __return_r21_r31.  */\n \t.align\t2\n \t.globl\t__return_r21_r31\n \t.type\t__return_r21_r31,@function\n __return_r21_r31:\n #ifdef __EP__\n \tmov\tep,r1\n \tmov\tsp,ep\n-\tsld.w\t16[ep],r29\n-\tsld.w\t20[ep],r28\n-\tsld.w\t24[ep],r27\n-\tsld.w\t28[ep],r26\n-\tsld.w\t32[ep],r25\n-\tsld.w\t36[ep],r24\n-\tsld.w\t40[ep],r23\n-\tsld.w\t44[ep],r22\n-\tsld.w\t48[ep],r21\n-\tsld.w\t52[ep],r31\n-\taddi\t56,sp,sp\n+\tsld.w\t0[ep],r29\n+\tsld.w\t4[ep],r28\n+\tsld.w\t8[ep],r27\n+\tsld.w\t12[ep],r26\n+\tsld.w\t16[ep],r25\n+\tsld.w\t20[ep],r24\n+\tsld.w\t24[ep],r23\n+\tsld.w\t28[ep],r22\n+\tsld.w\t32[ep],r21\n+\tsld.w\t36[ep],r31\n+\taddi\t40,sp,sp\n \tmov\tr1,ep\n #else\n-\tld.w\t16[sp],r29\n-\tld.w\t20[sp],r28\n-\tld.w\t24[sp],r27\n-\tld.w\t28[sp],r26\n-\tld.w\t32[sp],r25\n-\tld.w\t36[sp],r24\n-\tld.w\t40[sp],r23\n-\tld.w\t44[sp],r22\n-\tld.w\t48[sp],r21\n-\tld.w\t52[sp],r31\n-\taddi\t56,sp,sp\n+\tld.w\t0[sp],r29\n+\tld.w\t4[sp],r28\n+\tld.w\t8[sp],r27\n+\tld.w\t12[sp],r26\n+\tld.w\t16[sp],r25\n+\tld.w\t20[sp],r24\n+\tld.w\t24[sp],r23\n+\tld.w\t28[sp],r22\n+\tld.w\t32[sp],r21\n+\tld.w\t36[sp],r31\n+\taddi\t40,sp,sp\n #endif\n \tjmp\t[r31]\n \t.size\t__return_r21_r31,.-__return_r21_r31\n@@ -1123,70 +1124,70 @@ __return_r21_r31:\n \t.align\t2\n \t.globl\t__save_r22_r31\n \t.type\t__save_r22_r31,@function\n-\t/* Allocate space and save registers 22 .. 29, 31 on the stack */\n-\t/* Also allocate space for the argument save area */\n-\t/* Called via:\tjalr __save_r22_r31,r10 */\n+\t/* Allocate space and save registers 22 .. 29, 31 on the stack.  */\n+\t/* Also allocate space for the argument save area.  */\n+\t/* Called via:\tjalr __save_r22_r31,r10.  */\n __save_r22_r31:\n #ifdef __EP__\n \tmov\tep,r1\n-\taddi\t-52,sp,sp\n+\taddi\t-36,sp,sp\n \tmov\tsp,ep\n-\tsst.w\tr29,16[ep]\n-\tsst.w\tr28,20[ep]\n-\tsst.w\tr27,24[ep]\n-\tsst.w\tr26,28[ep]\n-\tsst.w\tr25,32[ep]\n-\tsst.w\tr24,36[ep]\n-\tsst.w\tr23,40[ep]\n-\tsst.w\tr22,44[ep]\n-\tsst.w\tr31,48[ep]\n+\tsst.w\tr29,0[ep]\n+\tsst.w\tr28,4[ep]\n+\tsst.w\tr27,8[ep]\n+\tsst.w\tr26,12[ep]\n+\tsst.w\tr25,16[ep]\n+\tsst.w\tr24,20[ep]\n+\tsst.w\tr23,24[ep]\n+\tsst.w\tr22,28[ep]\n+\tsst.w\tr31,32[ep]\n \tmov\tr1,ep\n #else\n-\taddi\t-52,sp,sp\n-\tst.w\tr29,16[sp]\n-\tst.w\tr28,20[sp]\n-\tst.w\tr27,24[sp]\n-\tst.w\tr26,28[sp]\n-\tst.w\tr25,32[sp]\n-\tst.w\tr24,36[sp]\n-\tst.w\tr23,40[sp]\n-\tst.w\tr22,44[sp]\n-\tst.w\tr31,48[sp]\n+\taddi\t-36,sp,sp\n+\tst.w\tr29,0[sp]\n+\tst.w\tr28,4[sp]\n+\tst.w\tr27,8[sp]\n+\tst.w\tr26,12[sp]\n+\tst.w\tr25,16[sp]\n+\tst.w\tr24,20[sp]\n+\tst.w\tr23,24[sp]\n+\tst.w\tr22,28[sp]\n+\tst.w\tr31,32[sp]\n #endif\n \tjmp\t[r10]\n \t.size\t__save_r22_r31,.-__save_r22_r31\n \n-\t/* Restore saved registers, deallocate stack and return to the user */\n-\t/* Called via:\tjr __return_r22_r31 */\n+\t/* Restore saved registers, deallocate stack and return to the user.  */\n+\t/* Called via:\tjr __return_r22_r31.  */\n \t.align\t2\n \t.globl\t__return_r22_r31\n \t.type\t__return_r22_r31,@function\n __return_r22_r31:\n #ifdef __EP__\n \tmov\tep,r1\n \tmov\tsp,ep\n-\tsld.w\t16[ep],r29\n-\tsld.w\t20[ep],r28\n-\tsld.w\t24[ep],r27\n-\tsld.w\t28[ep],r26\n-\tsld.w\t32[ep],r25\n-\tsld.w\t36[ep],r24\n-\tsld.w\t40[ep],r23\n-\tsld.w\t44[ep],r22\n-\tsld.w\t48[ep],r31\n-\taddi\t52,sp,sp\n+\tsld.w\t0[ep],r29\n+\tsld.w\t4[ep],r28\n+\tsld.w\t8[ep],r27\n+\tsld.w\t12[ep],r26\n+\tsld.w\t16[ep],r25\n+\tsld.w\t20[ep],r24\n+\tsld.w\t24[ep],r23\n+\tsld.w\t28[ep],r22\n+\tsld.w\t32[ep],r31\n+\taddi\t36,sp,sp\n \tmov\tr1,ep\n #else\n-\tld.w\t16[sp],r29\n-\tld.w\t20[sp],r28\n-\tld.w\t24[sp],r27\n-\tld.w\t28[sp],r26\n-\tld.w\t32[sp],r25\n-\tld.w\t36[sp],r24\n-\tld.w\t40[sp],r23\n-\tld.w\t44[sp],r22\n-\tld.w\t48[sp],r31\n-\taddi\t52,sp,sp\n+\tld.w\t0[sp],r29\n+\tld.w\t4[sp],r28\n+\tld.w\t8[sp],r27\n+\tld.w\t12[sp],r26\n+\tld.w\t16[sp],r25\n+\tld.w\t20[sp],r24\n+\tld.w\t24[sp],r23\n+\tld.w\t28[sp],r22\n+\tld.w\t32[sp],r31\n+\taddi\t36,sp,sp\n #endif\n \tjmp\t[r31]\n \t.size\t__return_r22_r31,.-__return_r22_r31\n@@ -1197,66 +1198,66 @@ __return_r22_r31:\n \t.align\t2\n \t.globl\t__save_r23_r31\n \t.type\t__save_r23_r31,@function\n-\t/* Allocate space and save registers 23 .. 29, 31 on the stack */\n-\t/* Also allocate space for the argument save area */\n-\t/* Called via:\tjalr __save_r23_r31,r10 */\n+\t/* Allocate space and save registers 23 .. 29, 31 on the stack.  */\n+\t/* Also allocate space for the argument save area.  */\n+\t/* Called via:\tjalr __save_r23_r31,r10.  */\n __save_r23_r31:\n #ifdef __EP__\n \tmov\tep,r1\n-\taddi\t-48,sp,sp\n+\taddi\t-32,sp,sp\n \tmov\tsp,ep\n-\tsst.w\tr29,16[ep]\n-\tsst.w\tr28,20[ep]\n-\tsst.w\tr27,24[ep]\n-\tsst.w\tr26,28[ep]\n-\tsst.w\tr25,32[ep]\n-\tsst.w\tr24,36[ep]\n-\tsst.w\tr23,40[ep]\n-\tsst.w\tr31,44[ep]\n+\tsst.w\tr29,0[ep]\n+\tsst.w\tr28,4[ep]\n+\tsst.w\tr27,8[ep]\n+\tsst.w\tr26,12[ep]\n+\tsst.w\tr25,16[ep]\n+\tsst.w\tr24,20[ep]\n+\tsst.w\tr23,24[ep]\n+\tsst.w\tr31,28[ep]\n \tmov\tr1,ep\n #else\n-\taddi\t-48,sp,sp\n-\tst.w\tr29,16[sp]\n-\tst.w\tr28,20[sp]\n-\tst.w\tr27,24[sp]\n-\tst.w\tr26,28[sp]\n-\tst.w\tr25,32[sp]\n-\tst.w\tr24,36[sp]\n-\tst.w\tr23,40[sp]\n-\tst.w\tr31,44[sp]\n+\taddi\t-32,sp,sp\n+\tst.w\tr29,0[sp]\n+\tst.w\tr28,4[sp]\n+\tst.w\tr27,8[sp]\n+\tst.w\tr26,12[sp]\n+\tst.w\tr25,16[sp]\n+\tst.w\tr24,20[sp]\n+\tst.w\tr23,24[sp]\n+\tst.w\tr31,28[sp]\n #endif\n \tjmp\t[r10]\n \t.size\t__save_r23_r31,.-__save_r23_r31\n \n-\t/* Restore saved registers, deallocate stack and return to the user */\n-\t/* Called via:\tjr __return_r23_r31 */\n+\t/* Restore saved registers, deallocate stack and return to the user.  */\n+\t/* Called via:\tjr __return_r23_r31.  */\n \t.align\t2\n \t.globl\t__return_r23_r31\n \t.type\t__return_r23_r31,@function\n __return_r23_r31:\n #ifdef __EP__\n \tmov\tep,r1\n \tmov\tsp,ep\n-\tsld.w\t16[ep],r29\n-\tsld.w\t20[ep],r28\n-\tsld.w\t24[ep],r27\n-\tsld.w\t28[ep],r26\n-\tsld.w\t32[ep],r25\n-\tsld.w\t36[ep],r24\n-\tsld.w\t40[ep],r23\n-\tsld.w\t44[ep],r31\n-\taddi\t48,sp,sp\n+\tsld.w\t0[ep],r29\n+\tsld.w\t4[ep],r28\n+\tsld.w\t8[ep],r27\n+\tsld.w\t12[ep],r26\n+\tsld.w\t16[ep],r25\n+\tsld.w\t20[ep],r24\n+\tsld.w\t24[ep],r23\n+\tsld.w\t28[ep],r31\n+\taddi\t32,sp,sp\n \tmov\tr1,ep\n #else\n-\tld.w\t16[sp],r29\n-\tld.w\t20[sp],r28\n-\tld.w\t24[sp],r27\n-\tld.w\t28[sp],r26\n-\tld.w\t32[sp],r25\n-\tld.w\t36[sp],r24\n-\tld.w\t40[sp],r23\n-\tld.w\t44[sp],r31\n-\taddi\t48,sp,sp\n+\tld.w\t0[sp],r29\n+\tld.w\t4[sp],r28\n+\tld.w\t8[sp],r27\n+\tld.w\t12[sp],r26\n+\tld.w\t16[sp],r25\n+\tld.w\t20[sp],r24\n+\tld.w\t24[sp],r23\n+\tld.w\t28[sp],r31\n+\taddi\t32,sp,sp\n #endif\n \tjmp\t[r31]\n \t.size\t__return_r23_r31,.-__return_r23_r31\n@@ -1267,62 +1268,62 @@ __return_r23_r31:\n \t.align\t2\n \t.globl\t__save_r24_r31\n \t.type\t__save_r24_r31,@function\n-\t/* Allocate space and save registers 24 .. 29, 31 on the stack */\n-\t/* Also allocate space for the argument save area */\n-\t/* Called via:\tjalr __save_r24_r31,r10 */\n+\t/* Allocate space and save registers 24 .. 29, 31 on the stack.  */\n+\t/* Also allocate space for the argument save area.  */\n+\t/* Called via:\tjalr __save_r24_r31,r10.  */\n __save_r24_r31:\n #ifdef __EP__\n \tmov\tep,r1\n-\taddi\t-44,sp,sp\n+\taddi\t-28,sp,sp\n \tmov\tsp,ep\n-\tsst.w\tr29,16[ep]\n-\tsst.w\tr28,20[ep]\n-\tsst.w\tr27,24[ep]\n-\tsst.w\tr26,28[ep]\n-\tsst.w\tr25,32[ep]\n-\tsst.w\tr24,36[ep]\n-\tsst.w\tr31,40[ep]\n+\tsst.w\tr29,0[ep]\n+\tsst.w\tr28,4[ep]\n+\tsst.w\tr27,8[ep]\n+\tsst.w\tr26,12[ep]\n+\tsst.w\tr25,16[ep]\n+\tsst.w\tr24,20[ep]\n+\tsst.w\tr31,24[ep]\n \tmov\tr1,ep\n #else\n-\taddi\t-44,sp,sp\n-\tst.w\tr29,16[sp]\n-\tst.w\tr28,20[sp]\n-\tst.w\tr27,24[sp]\n-\tst.w\tr26,28[sp]\n-\tst.w\tr25,32[sp]\n-\tst.w\tr24,36[sp]\n-\tst.w\tr31,40[sp]\n+\taddi\t-28,sp,sp\n+\tst.w\tr29,0[sp]\n+\tst.w\tr28,4[sp]\n+\tst.w\tr27,8[sp]\n+\tst.w\tr26,12[sp]\n+\tst.w\tr25,16[sp]\n+\tst.w\tr24,20[sp]\n+\tst.w\tr31,24[sp]\n #endif\n \tjmp\t[r10]\n \t.size\t__save_r24_r31,.-__save_r24_r31\n \n-\t/* Restore saved registers, deallocate stack and return to the user */\n-\t/* Called via:\tjr __return_r24_r31 */\n+\t/* Restore saved registers, deallocate stack and return to the user.  */\n+\t/* Called via:\tjr __return_r24_r31.  */\n \t.align\t2\n \t.globl\t__return_r24_r31\n \t.type\t__return_r24_r31,@function\n __return_r24_r31:\n #ifdef __EP__\n \tmov\tep,r1\n \tmov\tsp,ep\n-\tsld.w\t16[ep],r29\n-\tsld.w\t20[ep],r28\n-\tsld.w\t24[ep],r27\n-\tsld.w\t28[ep],r26\n-\tsld.w\t32[ep],r25\n-\tsld.w\t36[ep],r24\n-\tsld.w\t40[ep],r31\n-\taddi\t44,sp,sp\n+\tsld.w\t0[ep],r29\n+\tsld.w\t4[ep],r28\n+\tsld.w\t8[ep],r27\n+\tsld.w\t12[ep],r26\n+\tsld.w\t16[ep],r25\n+\tsld.w\t20[ep],r24\n+\tsld.w\t24[ep],r31\n+\taddi\t28,sp,sp\n \tmov\tr1,ep\n #else\n-\tld.w\t16[sp],r29\n-\tld.w\t20[sp],r28\n-\tld.w\t24[sp],r27\n-\tld.w\t28[sp],r26\n-\tld.w\t32[sp],r25\n-\tld.w\t36[sp],r24\n-\tld.w\t40[sp],r31\n-\taddi\t44,sp,sp\n+\tld.w\t0[sp],r29\n+\tld.w\t4[sp],r28\n+\tld.w\t8[sp],r27\n+\tld.w\t12[sp],r26\n+\tld.w\t16[sp],r25\n+\tld.w\t20[sp],r24\n+\tld.w\t24[sp],r31\n+\taddi\t28,sp,sp\n #endif\n \tjmp\t[r31]\n \t.size\t__return_r24_r31,.-__return_r24_r31\n@@ -1333,58 +1334,58 @@ __return_r24_r31:\n \t.align\t2\n \t.globl\t__save_r25_r31\n \t.type\t__save_r25_r31,@function\n-\t/* Allocate space and save registers 25 .. 29, 31 on the stack */\n-\t/* Also allocate space for the argument save area */\n-\t/* Called via:\tjalr __save_r25_r31,r10 */\n+\t/* Allocate space and save registers 25 .. 29, 31 on the stack.  */\n+\t/* Also allocate space for the argument save area.  */\n+\t/* Called via:\tjalr __save_r25_r31,r10.  */\n __save_r25_r31:\n #ifdef __EP__\n \tmov\tep,r1\n-\taddi\t-40,sp,sp\n+\taddi\t-24,sp,sp\n \tmov\tsp,ep\n-\tsst.w\tr29,16[ep]\n-\tsst.w\tr28,20[ep]\n-\tsst.w\tr27,24[ep]\n-\tsst.w\tr26,28[ep]\n-\tsst.w\tr25,32[ep]\n-\tsst.w\tr31,36[ep]\n+\tsst.w\tr29,0[ep]\n+\tsst.w\tr28,4[ep]\n+\tsst.w\tr27,8[ep]\n+\tsst.w\tr26,12[ep]\n+\tsst.w\tr25,16[ep]\n+\tsst.w\tr31,20[ep]\n \tmov\tr1,ep\n #else\n-\taddi\t-40,sp,sp\n-\tst.w\tr29,16[sp]\n-\tst.w\tr28,20[sp]\n-\tst.w\tr27,24[sp]\n-\tst.w\tr26,28[sp]\n-\tst.w\tr25,32[sp]\n-\tst.w\tr31,36[sp]\n+\taddi\t-24,sp,sp\n+\tst.w\tr29,0[sp]\n+\tst.w\tr28,4[sp]\n+\tst.w\tr27,8[sp]\n+\tst.w\tr26,12[sp]\n+\tst.w\tr25,16[sp]\n+\tst.w\tr31,20[sp]\n #endif\n \tjmp\t[r10]\n \t.size\t__save_r25_r31,.-__save_r25_r31\n \n-\t/* Restore saved registers, deallocate stack and return to the user */\n-\t/* Called via:\tjr __return_r25_r31 */\n+\t/* Restore saved registers, deallocate stack and return to the user.  */\n+\t/* Called via:\tjr __return_r25_r31.  */\n \t.align\t2\n \t.globl\t__return_r25_r31\n \t.type\t__return_r25_r31,@function\n __return_r25_r31:\n #ifdef __EP__\n \tmov\tep,r1\n \tmov\tsp,ep\n-\tsld.w\t16[ep],r29\n-\tsld.w\t20[ep],r28\n-\tsld.w\t24[ep],r27\n-\tsld.w\t28[ep],r26\n-\tsld.w\t32[ep],r25\n-\tsld.w\t36[ep],r31\n-\taddi\t40,sp,sp\n+\tsld.w\t0[ep],r29\n+\tsld.w\t4[ep],r28\n+\tsld.w\t8[ep],r27\n+\tsld.w\t12[ep],r26\n+\tsld.w\t16[ep],r25\n+\tsld.w\t20[ep],r31\n+\taddi\t24,sp,sp\n \tmov\tr1,ep\n #else\n-\tld.w\t16[sp],r29\n-\tld.w\t20[sp],r28\n-\tld.w\t24[sp],r27\n-\tld.w\t28[sp],r26\n-\tld.w\t32[sp],r25\n-\tld.w\t36[sp],r31\n-\taddi\t40,sp,sp\n+\tld.w\t0[sp],r29\n+\tld.w\t4[sp],r28\n+\tld.w\t8[sp],r27\n+\tld.w\t12[sp],r26\n+\tld.w\t16[sp],r25\n+\tld.w\t20[sp],r31\n+\taddi\t24,sp,sp\n #endif\n \tjmp\t[r31]\n \t.size\t__return_r25_r31,.-__return_r25_r31\n@@ -1395,54 +1396,54 @@ __return_r25_r31:\n \t.align\t2\n \t.globl\t__save_r26_r31\n \t.type\t__save_r26_r31,@function\n-\t/* Allocate space and save registers 26 .. 29, 31 on the stack */\n-\t/* Also allocate space for the argument save area */\n-\t/* Called via:\tjalr __save_r26_r31,r10 */\n+\t/* Allocate space and save registers 26 .. 29, 31 on the stack.  */\n+\t/* Also allocate space for the argument save area.  */\n+\t/* Called via:\tjalr __save_r26_r31,r10.  */\n __save_r26_r31:\n #ifdef __EP__\n \tmov\tep,r1\n-\taddi\t-36,sp,sp\n+\taddi\t-20,sp,sp\n \tmov\tsp,ep\n-\tsst.w\tr29,16[ep]\n-\tsst.w\tr28,20[ep]\n-\tsst.w\tr27,24[ep]\n-\tsst.w\tr26,28[ep]\n-\tsst.w\tr31,32[ep]\n+\tsst.w\tr29,0[ep]\n+\tsst.w\tr28,4[ep]\n+\tsst.w\tr27,8[ep]\n+\tsst.w\tr26,12[ep]\n+\tsst.w\tr31,16[ep]\n \tmov\tr1,ep\n #else\n-\taddi\t-36,sp,sp\n-\tst.w\tr29,16[sp]\n-\tst.w\tr28,20[sp]\n-\tst.w\tr27,24[sp]\n-\tst.w\tr26,28[sp]\n-\tst.w\tr31,32[sp]\n+\taddi\t-20,sp,sp\n+\tst.w\tr29,0[sp]\n+\tst.w\tr28,4[sp]\n+\tst.w\tr27,8[sp]\n+\tst.w\tr26,12[sp]\n+\tst.w\tr31,16[sp]\n #endif\n \tjmp\t[r10]\n \t.size\t__save_r26_r31,.-__save_r26_r31\n \n-\t/* Restore saved registers, deallocate stack and return to the user */\n-\t/* Called via:\tjr __return_r26_r31 */\n+\t/* Restore saved registers, deallocate stack and return to the user.  */\n+\t/* Called via:\tjr __return_r26_r31.  */\n \t.align\t2\n \t.globl\t__return_r26_r31\n \t.type\t__return_r26_r31,@function\n __return_r26_r31:\n #ifdef __EP__\n \tmov\tep,r1\n \tmov\tsp,ep\n-\tsld.w\t16[ep],r29\n-\tsld.w\t20[ep],r28\n-\tsld.w\t24[ep],r27\n-\tsld.w\t28[ep],r26\n-\tsld.w\t32[ep],r31\n-\taddi\t36,sp,sp\n+\tsld.w\t0[ep],r29\n+\tsld.w\t4[ep],r28\n+\tsld.w\t8[ep],r27\n+\tsld.w\t12[ep],r26\n+\tsld.w\t16[ep],r31\n+\taddi\t20,sp,sp\n \tmov\tr1,ep\n #else\n-\tld.w\t16[sp],r29\n-\tld.w\t20[sp],r28\n-\tld.w\t24[sp],r27\n-\tld.w\t28[sp],r26\n-\tld.w\t32[sp],r31\n-\taddi\t36,sp,sp\n+\tld.w\t0[sp],r29\n+\tld.w\t4[sp],r28\n+\tld.w\t8[sp],r27\n+\tld.w\t12[sp],r26\n+\tld.w\t16[sp],r31\n+\taddi\t20,sp,sp\n #endif\n \tjmp\t[r31]\n \t.size\t__return_r26_r31,.-__return_r26_r31\n@@ -1453,50 +1454,50 @@ __return_r26_r31:\n \t.align\t2\n \t.globl\t__save_r27_r31\n \t.type\t__save_r27_r31,@function\n-\t/* Allocate space and save registers 27 .. 29, 31 on the stack */\n-\t/* Also allocate space for the argument save area */\n-\t/* Called via:\tjalr __save_r27_r31,r10 */\n+\t/* Allocate space and save registers 27 .. 29, 31 on the stack.  */\n+\t/* Also allocate space for the argument save area.  */\n+\t/* Called via:\tjalr __save_r27_r31,r10.  */\n __save_r27_r31:\n #ifdef __EP__\n \tmov\tep,r1\n-\taddi\t-32,sp,sp\n+\taddi\t-16,sp,sp\n \tmov\tsp,ep\n-\tsst.w\tr29,16[ep]\n-\tsst.w\tr28,20[ep]\n-\tsst.w\tr27,24[ep]\n-\tsst.w\tr31,28[ep]\n+\tsst.w\tr29,0[ep]\n+\tsst.w\tr28,4[ep]\n+\tsst.w\tr27,8[ep]\n+\tsst.w\tr31,12[ep]\n \tmov\tr1,ep\n #else\n-\taddi\t-32,sp,sp\n-\tst.w\tr29,16[sp]\n-\tst.w\tr28,20[sp]\n-\tst.w\tr27,24[sp]\n-\tst.w\tr31,28[sp]\n+\taddi\t-16,sp,sp\n+\tst.w\tr29,0[sp]\n+\tst.w\tr28,4[sp]\n+\tst.w\tr27,8[sp]\n+\tst.w\tr31,12[sp]\n #endif\n \tjmp\t[r10]\n \t.size\t__save_r27_r31,.-__save_r27_r31\n \n-\t/* Restore saved registers, deallocate stack and return to the user */\n-\t/* Called via:\tjr __return_r27_r31 */\n+\t/* Restore saved registers, deallocate stack and return to the user.  */\n+\t/* Called via:\tjr __return_r27_r31.  */\n \t.align\t2\n \t.globl\t__return_r27_r31\n \t.type\t__return_r27_r31,@function\n __return_r27_r31:\n #ifdef __EP__\n \tmov\tep,r1\n \tmov\tsp,ep\n-\tsld.w\t16[ep],r29\n-\tsld.w\t20[ep],r28\n-\tsld.w\t24[ep],r27\n-\tsld.w\t28[ep],r31\n-\taddi\t32,sp,sp\n+\tsld.w\t0[ep],r29\n+\tsld.w\t4[ep],r28\n+\tsld.w\t8[ep],r27\n+\tsld.w\t12[ep],r31\n+\taddi\t16,sp,sp\n \tmov\tr1,ep\n #else\n-\tld.w\t16[sp],r29\n-\tld.w\t20[sp],r28\n-\tld.w\t24[sp],r27\n-\tld.w\t28[sp],r31\n-\taddi\t32,sp,sp\n+\tld.w\t0[sp],r29\n+\tld.w\t4[sp],r28\n+\tld.w\t8[sp],r27\n+\tld.w\t12[sp],r31\n+\taddi\t16,sp,sp\n #endif\n \tjmp\t[r31]\n \t.size\t__return_r27_r31,.-__return_r27_r31\n@@ -1507,27 +1508,27 @@ __return_r27_r31:\n \t.align\t2\n \t.globl\t__save_r28_r31\n \t.type\t__save_r28_r31,@function\n-\t/* Allocate space and save registers 28 .. 29, 31 on the stack */\n-\t/* Also allocate space for the argument save area */\n-\t/* Called via:\tjalr __save_r28_r31,r10 */\n+\t/* Allocate space and save registers 28 .. 29, 31 on the stack.  */\n+\t/* Also allocate space for the argument save area.  */\n+\t/* Called via:\tjalr __save_r28_r31,r10.  */\n __save_r28_r31:\n-\taddi\t-28,sp,sp\n-\tst.w\tr29,16[sp]\n-\tst.w\tr28,20[sp]\n-\tst.w\tr31,24[sp]\n+\taddi\t-12,sp,sp\n+\tst.w\tr29,0[sp]\n+\tst.w\tr28,4[sp]\n+\tst.w\tr31,8[sp]\n \tjmp\t[r10]\n \t.size\t__save_r28_r31,.-__save_r28_r31\n \n-\t/* Restore saved registers, deallocate stack and return to the user */\n-\t/* Called via:\tjr __return_r28_r31 */\n+\t/* Restore saved registers, deallocate stack and return to the user.  */\n+\t/* Called via:\tjr __return_r28_r31.  */\n \t.align\t2\n \t.globl\t__return_r28_r31\n \t.type\t__return_r28_r31,@function\n __return_r28_r31:\n-\tld.w\t16[sp],r29\n-\tld.w\t20[sp],r28\n-\tld.w\t24[sp],r31\n-\taddi\t28,sp,sp\n+\tld.w\t0[sp],r29\n+\tld.w\t4[sp],r28\n+\tld.w\t8[sp],r31\n+\taddi\t12,sp,sp\n \tjmp\t[r31]\n \t.size\t__return_r28_r31,.-__return_r28_r31\n #endif /* L_save_28c */\n@@ -1537,25 +1538,25 @@ __return_r28_r31:\n \t.align\t2\n \t.globl\t__save_r29_r31\n \t.type\t__save_r29_r31,@function\n-\t/* Allocate space and save registers 29 & 31 on the stack */\n-\t/* Also allocate space for the argument save area */\n-\t/* Called via:\tjalr __save_r29_r31,r10 */\n+\t/* Allocate space and save registers 29 & 31 on the stack.  */\n+\t/* Also allocate space for the argument save area.  */\n+\t/* Called via:\tjalr __save_r29_r31,r10.  */\n __save_r29_r31:\n-\taddi\t-24,sp,sp\n-\tst.w\tr29,16[sp]\n-\tst.w\tr31,20[sp]\n+\taddi\t-8,sp,sp\n+\tst.w\tr29,0[sp]\n+\tst.w\tr31,4[sp]\n \tjmp\t[r10]\n \t.size\t__save_r29_r31,.-__save_r29_r31\n \n-\t/* Restore saved registers, deallocate stack and return to the user */\n-\t/* Called via:\tjr __return_r29_r31 */\n+\t/* Restore saved registers, deallocate stack and return to the user.  */\n+\t/* Called via:\tjr __return_r29_r31.  */\n \t.align\t2\n \t.globl\t__return_r29_r31\n \t.type\t__return_r29_r31,@function\n __return_r29_r31:\n-\tld.w\t16[sp],r29\n-\tld.w\t20[sp],r31\n-\taddi\t24,sp,sp\n+\tld.w\t0[sp],r29\n+\tld.w\t4[sp],r31\n+\taddi\t8,sp,sp\n \tjmp\t[r31]\n \t.size\t__return_r29_r31,.-__return_r29_r31\n #endif /* L_save_29c */\n@@ -1567,60 +1568,35 @@ __return_r29_r31:\n \t.type\t__save_r31,@function\n \t/* Allocate space and save register 31 on the stack.  */\n \t/* Also allocate space for the argument save area.  */\n-\t/* Called via:\tjalr __save_r31,r10 */\n+\t/* Called via:\tjalr __save_r31,r10.  */\n __save_r31:\n-\taddi\t-20,sp,sp\n-\tst.w\tr31,16[sp]\n+\taddi\t-4,sp,sp\n+\tst.w\tr31,0[sp]\n \tjmp\t[r10]\n \t.size\t__save_r31,.-__save_r31\n \n \t/* Restore saved registers, deallocate stack and return to the user.  */\n-\t/* Called via:\tjr __return_r31 */\n+\t/* Called via:\tjr __return_r31.  */\n \t.align\t2\n \t.globl\t__return_r31\n \t.type\t__return_r31,@function\n __return_r31:\n-\tld.w\t16[sp],r31\n-\taddi\t20,sp,sp\n+\tld.w\t0[sp],r31\n+\taddi\t4,sp,sp\n \tjmp\t[r31]\n         .size   __return_r31,.-__return_r31\n #endif /* L_save_31c */\n \n-#ifdef L_save_varargs\n-\t.text\n-\t.align\t2\n-\t.globl\t__save_r6_r9\n-\t.type\t__save_r6_r9,@function\n-\t/* Save registers 6 .. 9 on the stack for variable argument functions.  */\n-\t/* Called via:\tjalr __save_r6_r9,r10 */\n-__save_r6_r9:\n-#ifdef __EP__\n-\tmov\tep,r1\n-\tmov\tsp,ep\n-\tsst.w\tr6,0[ep]\n-\tsst.w\tr7,4[ep]\n-\tsst.w\tr8,8[ep]\n-\tsst.w\tr9,12[ep]\n-\tmov\tr1,ep\n-#else\n-\tst.w\tr6,0[sp]\n-\tst.w\tr7,4[sp]\n-\tst.w\tr8,8[sp]\n-\tst.w\tr9,12[sp]\n-#endif\n-\tjmp\t[r10]\n-\t.size\t__save_r6_r9,.-__save_r6_r9\n-#endif /* L_save_varargs */\n-\n #ifdef\tL_save_interrupt\n \t.text\n \t.align\t2\n \t.globl\t__save_interrupt\n \t.type\t__save_interrupt,@function\n \t/* Save registers r1, r4 on stack and load up with expected values.  */\n-\t/* Note, 12 bytes of stack have already been allocated.  */\n-\t/* Called via:\tjalr __save_interrupt,r10 */\n+\t/* Note, 20 bytes of stack have already been allocated.  */\n+\t/* Called via:\tjalr __save_interrupt,r10.  */\n __save_interrupt:\n+       /* add -20,sp ; st.w r11,16[sp] ; st.w r10,12[sp] ; */\n \tst.w\tep,0[sp]\n \tst.w\tgp,4[sp]\n \tst.w\tr1,8[sp]\n@@ -1632,7 +1608,7 @@ __save_interrupt:\n \t.size\t__save_interrupt,.-__save_interrupt\n \n \t/* Restore saved registers, deallocate stack and return from the interrupt.  */\n-\t/* Called via:\tjr __return_interrupt */\n+\t/* Called via:\tjr __return_interrupt.  */\n \t.align\t2\n \t.globl\t__return_interrupt\n \t.type\t__return_interrupt,@function\n@@ -1641,7 +1617,8 @@ __return_interrupt:\n \tld.w\t4[sp],gp\n \tld.w\t8[sp],r1\n \tld.w\t12[sp],r10\n-\taddi\t16,sp,sp\n+\tld.w    16[sp],r11\n+\taddi    20,sp,sp\n \treti\n \t.size\t__return_interrupt,.-__return_interrupt\n #endif /* L_save_interrupt */\n@@ -1653,66 +1630,66 @@ __return_interrupt:\n \t.type\t__save_all_interrupt,@function\n \t/* Save all registers except for those saved in __save_interrupt.  */\n \t/* Allocate enough stack for all of the registers & 16 bytes of space.  */\n-\t/* Called via:\tjalr __save_all_interrupt,r10 */\n+\t/* Called via:\tjalr __save_all_interrupt,r10.  */\n __save_all_interrupt:\n-\taddi\t-120,sp,sp\n+\taddi\t-104,sp,sp\n #ifdef __EP__\n \tmov\tep,r1\n \tmov\tsp,ep\n-\tsst.w\tr31,116[ep]\n-\tsst.w\tr2,112[ep]\n-\tsst.w\tgp,108[ep]\n-\tsst.w\tr6,104[ep]\n-\tsst.w\tr7,100[ep]\n-\tsst.w\tr8,96[ep]\n-\tsst.w\tr9,92[ep]\n-\tsst.w\tr11,88[ep]\n-\tsst.w\tr12,84[ep]\n-\tsst.w\tr13,80[ep]\n-\tsst.w\tr14,76[ep]\n-\tsst.w\tr15,72[ep]\n-\tsst.w\tr16,68[ep]\n-\tsst.w\tr17,64[ep]\n-\tsst.w\tr18,60[ep]\n-\tsst.w\tr19,56[ep]\n-\tsst.w\tr20,52[ep]\n-\tsst.w\tr21,48[ep]\n-\tsst.w\tr22,44[ep]\n-\tsst.w\tr23,40[ep]\n-\tsst.w\tr24,36[ep]\n-\tsst.w\tr25,32[ep]\n-\tsst.w\tr26,28[ep]\n-\tsst.w\tr27,24[ep]\n-\tsst.w\tr28,20[ep]\n-\tsst.w\tr29,16[ep]\n+\tsst.w\tr31,100[ep]\n+\tsst.w\tr2,96[ep]\n+\tsst.w\tgp,92[ep]\n+\tsst.w\tr6,88[ep]\n+\tsst.w\tr7,84[ep]\n+\tsst.w\tr8,80[ep]\n+\tsst.w\tr9,76[ep]\n+\tsst.w\tr11,72[ep]\n+\tsst.w\tr12,68[ep]\n+\tsst.w\tr13,64[ep]\n+\tsst.w\tr14,60[ep]\n+\tsst.w\tr15,56[ep]\n+\tsst.w\tr16,52[ep]\n+\tsst.w\tr17,48[ep]\n+\tsst.w\tr18,44[ep]\n+\tsst.w\tr19,40[ep]\n+\tsst.w\tr20,36[ep]\n+\tsst.w\tr21,32[ep]\n+\tsst.w\tr22,28[ep]\n+\tsst.w\tr23,24[ep]\n+\tsst.w\tr24,20[ep]\n+\tsst.w\tr25,16[ep]\n+\tsst.w\tr26,12[ep]\n+\tsst.w\tr27,8[ep]\n+\tsst.w\tr28,4[ep]\n+\tsst.w\tr29,0[ep]\n \tmov\tr1,ep\n #else\n-\tst.w\tr31,116[sp]\n-\tst.w\tr2,112[sp]\n-\tst.w\tgp,108[sp]\n-\tst.w\tr6,104[sp]\n-\tst.w\tr7,100[sp]\n-\tst.w\tr8,96[sp]\n-\tst.w\tr9,92[sp]\n-\tst.w\tr11,88[sp]\n-\tst.w\tr12,84[sp]\n-\tst.w\tr13,80[sp]\n-\tst.w\tr14,76[sp]\n-\tst.w\tr15,72[sp]\n-\tst.w\tr16,68[sp]\n-\tst.w\tr17,64[sp]\n-\tst.w\tr18,60[sp]\n-\tst.w\tr19,56[sp]\n-\tst.w\tr20,52[sp]\n-\tst.w\tr21,48[sp]\n-\tst.w\tr22,44[sp]\n-\tst.w\tr23,40[sp]\n-\tst.w\tr24,36[sp]\n-\tst.w\tr25,32[sp]\n-\tst.w\tr26,28[sp]\n-\tst.w\tr27,24[sp]\n-\tst.w\tr28,20[sp]\n-\tst.w\tr29,16[sp]\n+\tst.w\tr31,100[sp]\n+\tst.w\tr2,96[sp]\n+\tst.w\tgp,92[sp]\n+\tst.w\tr6,88[sp]\n+\tst.w\tr7,84[sp]\n+\tst.w\tr8,80[sp]\n+\tst.w\tr9,76[sp]\n+\tst.w\tr11,72[sp]\n+\tst.w\tr12,68[sp]\n+\tst.w\tr13,64[sp]\n+\tst.w\tr14,60[sp]\n+\tst.w\tr15,56[sp]\n+\tst.w\tr16,52[sp]\n+\tst.w\tr17,48[sp]\n+\tst.w\tr18,44[sp]\n+\tst.w\tr19,40[sp]\n+\tst.w\tr20,36[sp]\n+\tst.w\tr21,32[sp]\n+\tst.w\tr22,28[sp]\n+\tst.w\tr23,24[sp]\n+\tst.w\tr24,20[sp]\n+\tst.w\tr25,16[sp]\n+\tst.w\tr26,12[sp]\n+\tst.w\tr27,8[sp]\n+\tst.w\tr28,4[sp]\n+\tst.w\tr29,0[sp]\n #endif\n \tjmp\t[r10]\n \t.size\t__save_all_interrupt,.-__save_all_interrupt\n@@ -1721,73 +1698,72 @@ __save_all_interrupt:\n \t.type\t__restore_all_interrupt,@function\n \t/* Restore all registers saved in __save_all_interrupt and\n \t   deallocate the stack space.  */\n-\t/* Called via:\tjalr __restore_all_interrupt,r10 */\n+\t/* Called via:\tjalr __restore_all_interrupt,r10.  */\n __restore_all_interrupt:\n #ifdef __EP__\n \tmov\tep,r1\n \tmov\tsp,ep\n-\tsld.w\t116[ep],r31\n-\tsld.w\t112[ep],r2\n-\tsld.w\t108[ep],gp\n-\tsld.w\t104[ep],r6\n-\tsld.w\t100[ep],r7\n-\tsld.w\t96[ep],r8\n-\tsld.w\t92[ep],r9\n-\tsld.w\t88[ep],r11\n-\tsld.w\t84[ep],r12\n-\tsld.w\t80[ep],r13\n-\tsld.w\t76[ep],r14\n-\tsld.w\t72[ep],r15\n-\tsld.w\t68[ep],r16\n-\tsld.w\t64[ep],r17\n-\tsld.w\t60[ep],r18\n-\tsld.w\t56[ep],r19\n-\tsld.w\t52[ep],r20\n-\tsld.w\t48[ep],r21\n-\tsld.w\t44[ep],r22\n-\tsld.w\t40[ep],r23\n-\tsld.w\t36[ep],r24\n-\tsld.w\t32[ep],r25\n-\tsld.w\t28[ep],r26\n-\tsld.w\t24[ep],r27\n-\tsld.w\t20[ep],r28\n-\tsld.w\t16[ep],r29\n+\tsld.w\t100[ep],r31\n+\tsld.w\t96[ep],r2\n+\tsld.w\t92[ep],gp\n+\tsld.w\t88[ep],r6\n+\tsld.w\t84[ep],r7\n+\tsld.w\t80[ep],r8\n+\tsld.w\t76[ep],r9\n+\tsld.w\t72[ep],r11\n+\tsld.w\t68[ep],r12\n+\tsld.w\t64[ep],r13\n+\tsld.w\t60[ep],r14\n+\tsld.w\t56[ep],r15\n+\tsld.w\t52[ep],r16\n+\tsld.w\t48[ep],r17\n+\tsld.w\t44[ep],r18\n+\tsld.w\t40[ep],r19\n+\tsld.w\t36[ep],r20\n+\tsld.w\t32[ep],r21\n+\tsld.w\t28[ep],r22\n+\tsld.w\t24[ep],r23\n+\tsld.w\t20[ep],r24\n+\tsld.w\t16[ep],r25\n+\tsld.w\t12[ep],r26\n+\tsld.w\t8[ep],r27\n+\tsld.w\t4[ep],r28\n+\tsld.w\t0[ep],r29\n \tmov\tr1,ep\n #else\n-\tld.w\t116[sp],r31\n-\tld.w\t112[sp],r2\n-\tld.w\t108[sp],gp\n-\tld.w\t104[sp],r6\n-\tld.w\t100[sp],r7\n-\tld.w\t96[sp],r8\n-\tld.w\t92[sp],r9\n-\tld.w\t88[sp],r11\n-\tld.w\t84[sp],r12\n-\tld.w\t80[sp],r13\n-\tld.w\t76[sp],r14\n-\tld.w\t72[sp],r15\n-\tld.w\t68[sp],r16\n-\tld.w\t64[sp],r17\n-\tld.w\t60[sp],r18\n-\tld.w\t56[sp],r19\n-\tld.w\t52[sp],r20\n-\tld.w\t48[sp],r21\n-\tld.w\t44[sp],r22\n-\tld.w\t40[sp],r23\n-\tld.w\t36[sp],r24\n-\tld.w\t32[sp],r25\n-\tld.w\t28[sp],r26\n-\tld.w\t24[sp],r27\n-\tld.w\t20[sp],r28\n-\tld.w\t16[sp],r29\n-#endif\n-\taddi\t120,sp,sp\t\n+\tld.w\t100[sp],r31\n+\tld.w\t96[sp],r2\n+\tld.w\t92[sp],gp\n+\tld.w\t88[sp],r6\n+\tld.w\t84[sp],r7\n+\tld.w\t80[sp],r8\n+\tld.w\t76[sp],r9\n+\tld.w\t72[sp],r11\n+\tld.w\t68[sp],r12\n+\tld.w\t64[sp],r13\n+\tld.w\t60[sp],r14\n+\tld.w\t56[sp],r15\n+\tld.w\t52[sp],r16\n+\tld.w\t48[sp],r17\n+\tld.w\t44[sp],r18\n+\tld.w\t40[sp],r19\n+\tld.w\t36[sp],r20\n+\tld.w\t32[sp],r21\n+\tld.w\t28[sp],r22\n+\tld.w\t24[sp],r23\n+\tld.w\t20[sp],r24\n+\tld.w\t16[sp],r25\n+\tld.w\t12[sp],r26\n+\tld.w\t8[sp],r27\n+\tld.w\t4[sp],r28\n+\tld.w\t0[sp],r29\n+#endif\n+\taddi\t104,sp,sp\t\n \tjmp\t[r10]\n \t.size\t__restore_all_interrupt,.-__restore_all_interrupt\n #endif /* L_save_all_interrupt */\n-\n \t\n-#if defined __v850e__\n+#if defined(__v850e__) || defined(__v850e1__) || defined(__v850e2__) || defined(__v850e2v3__)\n #ifdef\tL_callt_save_r2_r29\n \t/* Put these functions into the call table area.  */\n \t.call_table_text\n@@ -1821,7 +1797,7 @@ __callt_save_r2_r29:\t.short ctoff(.L_save_r2_r29)\n \t.type\t__callt_return_r2_r29,@function\n __callt_return_r2_r29:\t.short ctoff(.L_return_r2_r29)\n \t\n-#endif /* L_callt_save_r2_r29 */\n+#endif /* L_callt_save_r2_r29.  */\n \n #ifdef\tL_callt_save_r2_r31\n \t/* Put these functions into the call table area.  */\n@@ -1834,14 +1810,14 @@ __callt_return_r2_r29:\t.short ctoff(.L_return_r2_r29)\n .L_save_r2_r31:\n \tadd\t-4, sp\n \tst.w\tr2, 0[sp]\n-\tprepare {r20 - r29, r31}, 4\n+\tprepare {r20 - r29, r31}, 0\n \tctret\n \n \t/* Restore saved registers, deallocate stack and return to the user.  */\n \t/* Called via:\tcallt ctoff(__callt_return_r2_r31).  */\n \t.align\t2\n .L_return_r2_r31:\n-\tdispose 4, {r20 - r29, r31}\n+\tdispose 0, {r20 - r29, r31}\n \tld.w    0[sp], r2\n \taddi\t4, sp, sp\n \tjmp     [r31]\n@@ -1859,41 +1835,6 @@ __callt_return_r2_r31:\t.short ctoff(.L_return_r2_r31)\n \t\n #endif /* L_callt_save_r2_r31 */\n \n-\n-#ifdef L_callt_save_r6_r9\n-\t/* Put these functions into the call table area.  */\n-\t.call_table_text\n-\t\n-\t/* Save registers r6 - r9 onto the stack in the space reserved for them.\n-\t   Use by variable argument functions. \n-\t   Called via:\tcallt ctoff(__callt_save_r6_r9).  */\n-\t.align\t2\n-.L_save_r6_r9:\n-#ifdef __EP__\n-\tmov\tep,r1\n-\tmov\tsp,ep\n-\tsst.w\tr6,0[ep]\n-\tsst.w\tr7,4[ep]\n-\tsst.w\tr8,8[ep]\n-\tsst.w\tr9,12[ep]\n-\tmov\tr1,ep\n-#else\n-\tst.w\tr6,0[sp]\n-\tst.w\tr7,4[sp]\n-\tst.w\tr8,8[sp]\n-\tst.w\tr9,12[sp]\n-#endif\n-\tctret\n-\n-\t/* Place the offsets of the start of this routines into the call table.  */\n-\t.call_table_data\n-\n-\t.global\t__callt_save_r6_r9\n-\t.type\t__callt_save_r6_r9,@function\n-__callt_save_r6_r9:\t.short ctoff(.L_save_r6_r9)\n-#endif /* L_callt_save_r6_r9 */\n-\n-\t\n #ifdef\tL_callt_save_interrupt\n \t/* Put these functions into the call table area.  */\n \t.call_table_text\n@@ -1903,31 +1844,39 @@ __callt_save_r6_r9:\t.short ctoff(.L_save_r6_r9)\n \t.align\t2\n .L_save_interrupt:\n         /* SP has already been moved before callt ctoff(_save_interrupt).  */\n-        /* addi -24, sp, sp  */\n+        /* R1,R10,R11,ctpc,ctpsw has alread been saved bofore callt ctoff(_save_interrupt).  */\n+        /* addi -28, sp, sp  */\n+        /* st.w r1,    24[sp] */\n+        /* st.w r10,   12[sp] */\n+        /* st.w r11,   16[sp] */\n+        /* stsr ctpc,  r10    */\n+        /* st.w r10,   20[sp] */\n+        /* stsr ctpsw, r10    */\n+        /* st.w r10,   24[sp] */\n         st.w    ep,  0[sp]\n         st.w    gp,  4[sp]\n         st.w    r1,  8[sp]\n-        /* R10 has already been saved before callt ctoff(_save_interrupt).  */\n-        /* st.w    r10, 12[sp]  */\n \tmov\thilo(__ep),ep\n \tmov\thilo(__gp),gp\n \tctret\n \n+        .call_table_text\n \t/* Restore saved registers, deallocate stack and return from the interrupt.  */\n         /* Called via:  callt ctoff(__callt_restore_interrupt).  */\n \t.align\t2\n \t.globl\t__return_interrupt\n \t.type\t__return_interrupt,@function\n .L_return_interrupt:\n-        ld.w    20[sp], r1\n+        ld.w    24[sp], r1\n         ldsr    r1,     ctpsw\n-        ld.w    16[sp], r1\n+        ld.w    20[sp], r1\n         ldsr    r1,     ctpc\n+        ld.w    16[sp], r11\n         ld.w    12[sp], r10\n         ld.w     8[sp], r1\n         ld.w     4[sp], gp\n         ld.w     0[sp], ep\n-        addi    24, sp, sp\n+        addi    28, sp, sp\n         reti\n \n \t/* Place the offsets of the start of these routines into the call table.  */\n@@ -1989,16 +1938,16 @@ __callt_return_interrupt:       .short ctoff(.L_return_interrupt)\n \tst.w\tr18, 4[sp]\n \tst.w\tr19, 0[sp]\n #endif\n-\tprepare {r20 - r29, r31}, 4\n+\tprepare {r20 - r29, r31}, 0\n \tctret\t\n \n \t/* Restore all registers saved in __save_all_interrupt\n \t   deallocate the stack space.  */\n \t/* Called via:\tcallt ctoff(__callt_restore_all_interrupt).  */\n \t.align 2\n .L_restore_all_interrupt:\n-\tdispose 4, {r20 - r29, r31}\n-#ifdef __EP__\t\n+\tdispose 0, {r20 - r29, r31}\n+#ifdef __EP__\n \tmov\tep, r1\n \tmov\tsp, ep\n \tsld.w\t0 [ep], r19\n@@ -2061,7 +2010,7 @@ __callt_restore_all_interrupt:\t.short ctoff(.L_restore_all_interrupt)\n \tctret\t\t\t\t\t\t\t\t\t;\\\n \t\t\t\t\t\t\t\t\t\t;\\\n \t/* Restore saved registers, deallocate stack and return.  */\t\t;\\\n-\t/* Called via:\tcallt ctoff(__return_START_r29) */\t\t\t;\\\n+\t/* Called via:\tcallt ctoff(__return_START_r29).  */\t\t\t;\\\n \t.align\t2\t\t\t\t\t\t\t\t;\\\n .L_return_##START##_r29:\t\t\t\t\t\t\t;\\\n \tdispose 0, { START - r29 }, r31\t\t\t\t\t\t;\\\n@@ -2084,14 +2033,14 @@ __callt_return_##START##_r29:\t.short ctoff(.L_return_##START##_r29 )\n \t/* Allocate space and save registers START .. r31 on the stack.  */\t;\\\n \t/* Called via:\tcallt ctoff(__callt_save_START_r31c).  */\t\t;\\\n .L_save_##START##_r31c:\t\t\t\t\t\t\t\t;\\\n-\tprepare { START - r29, r31}, 4\t\t\t\t\t\t;\\\n+\tprepare { START - r29, r31}, 0\t\t\t\t\t\t;\\\n \tctret\t\t\t\t\t\t\t\t\t;\\\n \t\t\t\t\t\t\t\t\t\t;\\\n \t/* Restore saved registers, deallocate stack and return.  */\t\t;\\\n \t/* Called via:\tcallt ctoff(__return_START_r31c).  */\t\t\t;\\\n \t.align\t2\t\t\t\t\t\t\t\t;\\\n .L_return_##START##_r31c:\t\t\t\t\t\t\t;\\\n-\tdispose 4, { START - r29, r31}, r31\t\t\t\t\t;\\\n+\tdispose 0, { START - r29, r31}, r31\t\t\t\t\t;\\\n \t\t\t\t\t\t\t\t\t\t;\\\n \t/* Place the offsets of the start of these funcs into the call table.  */;\\\n \t.call_table_data\t\t\t\t\t\t\t;\\\n@@ -2174,14 +2123,14 @@ __callt_return_##START##_r31c:  .short ctoff(.L_return_##START##_r31c )\n \t/* Allocate space and save register r31 on the stack.  */\n \t/* Called via:\tcallt ctoff(__callt_save_r31c).  */\n .L_callt_save_r31c:\n-\tprepare {r31}, 4\n+\tprepare {r31}, 0\n \tctret\n \n \t/* Restore saved registers, deallocate stack and return.  */\n \t/* Called via:\tcallt ctoff(__return_r31c).  */\n \t.align\t2\n .L_callt_return_r31c:\n-\tdispose 4, {r31}, r31\n+\tdispose 0, {r31}, r31\n \t\n \t/* Place the offsets of the start of these funcs into the call table.  */\n \t.call_table_data\n@@ -2364,8 +2313,7 @@ ___muldi3:\n         mov   r26, r10\n         mov   r27, r11\n         jr    __return_r26_r31\n-#endif /* __v850__ */\n-#if defined(__v850e__) || defined(__v850ea__)\n+#else /* defined(__v850e__) */\n \t/*  (Ahi << 32 + Alo) * (Bhi << 32 + Blo) */\n \t/*   r7           r6      r9         r8   */\n \tmov  r8, r10\n@@ -2375,7 +2323,7 @@ ___muldi3:\n \tadd  r8, r11\n \tadd  r9, r11\n \tjmp  [r31]\n-\n-#endif /* defined(__v850e__)  || defined(__v850ea__) */\n+#endif /* defined(__v850e__) */\n \t.size ___muldi3, . - ___muldi3\n #endif\n+\t"}, {"sha": "680bd8e86821d105c25794d40f50675f554eb3d4", "filename": "gcc/config/v850/predicates.md", "status": "modified", "additions": 77, "deletions": 13, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/223a9d64453b03941bcd88e479c8047edffadc42/gcc%2Fconfig%2Fv850%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/223a9d64453b03941bcd88e479c8047edffadc42/gcc%2Fconfig%2Fv850%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fpredicates.md?ref=223a9d64453b03941bcd88e479c8047edffadc42", "patch": "@@ -68,6 +68,17 @@\n   return register_operand (op, mode);\n })\n \n+;; Return true if OP is a even number register.\n+\n+(define_predicate \"even_reg_operand\"\n+  (match_code \"reg\")\n+{\n+  return (GET_CODE (op) == REG\n+\t  && (REGNO (op) >= FIRST_PSEUDO_REGISTER\n+\t      || ((REGNO (op) > 0) && (REGNO (op) < 32)\n+\t\t   && ((REGNO (op) & 1)==0))));\n+})\n+\n ;; Return true if OP is a valid call operand.\n \n (define_predicate \"call_address_operand\"\n@@ -79,7 +90,7 @@\n   return (GET_CODE (op) == SYMBOL_REF || GET_CODE (op) == REG);\n })\n \n-;; TODO: Add a comment here.\n+;; Return true if OP is a valid source operand for SImode move.\n \n (define_predicate \"movsi_source_operand\"\n   (match_code \"label_ref,symbol_ref,const_int,const_double,const,high,mem,reg,subreg\")\n@@ -97,7 +108,21 @@\n     return general_operand (op, mode);\n })\n \n-;; TODO: Add a comment here.\n+;; Return true if OP is a valid operand for 23 bit displacement\n+;; operations.\n+\n+(define_predicate \"disp23_operand\"\n+  (match_code \"const_int\")\n+{\n+  if (GET_CODE (op) == CONST_INT\n+      && ((unsigned)(INTVAL (op)) >= 0x8000)\n+      && ((unsigned)(INTVAL (op)) < 0x400000))\n+    return 1;\n+  else\n+    return 0;\n+})\n+\n+;; Return true if OP is a symbol ref with 16-bit signed value.\n \n (define_predicate \"special_symbolref_operand\"\n   (match_code \"symbol_ref\")\n@@ -115,7 +140,8 @@\n   return FALSE;\n })\n \n-;; TODO: Add a comment here.\n+;; Return true if OP is a valid operand for bit related operations\n+;; containing only single 1 in its binary representation.\n \n (define_predicate \"power_of_two_operand\"\n   (match_code \"const_int\")\n@@ -140,7 +166,7 @@\n \n   /* If there are no registers to save then the function prologue\n      is not suitable.  */\n-  if (count <= 2)\n+  if (count <= (TARGET_LONG_CALLS ? 3 : 2))\n     return 0;\n \n   /* The pattern matching has already established that we are adjusting the\n@@ -198,18 +224,24 @@\n     }\n \n   /* Make sure that the last entries in the vector are clobbers.  */\n-  for (; i < count; i++)\n+  vector_element = XVECEXP (op, 0, i++);\n+\n+  if (GET_CODE (vector_element) != CLOBBER\n+      || GET_CODE (XEXP (vector_element, 0)) != REG\n+      || REGNO (XEXP (vector_element, 0)) != 10)\n+    return 0;\n+\n+  if (TARGET_LONG_CALLS)\n     {\n-      vector_element = XVECEXP (op, 0, i);\n+      vector_element = XVECEXP (op, 0, i++);\n \n       if (GET_CODE (vector_element) != CLOBBER\n \t  || GET_CODE (XEXP (vector_element, 0)) != REG\n-\t  || !(REGNO (XEXP (vector_element, 0)) == 10\n-\t       || (TARGET_LONG_CALLS ? (REGNO (XEXP (vector_element, 0)) == 11) : 0 )))\n+\t  || REGNO (XEXP (vector_element, 0)) != 11)\n \treturn 0;\n     }\n \n-  return 1;\n+  return i == count;\n })\n \n ;; Return nonzero if the given RTX is suitable for collapsing into\n@@ -239,7 +271,7 @@\n \t  (mem:SI (plus:SI (reg:SI 3) (match_operand:SI n \"immediate_operand\" \"i\"))))\n      */\n \n-  for (i = 3; i < count; i++)\n+  for (i = 2; i < count; i++)\n     {\n       rtx vector_element = XVECEXP (op, 0, i);\n       rtx dest;\n@@ -372,13 +404,16 @@\n \n      */\n \n-  for (i = 2; i < count; i++)\n+  for (i = 1; i < count; i++)\n     {\n       rtx vector_element = XVECEXP (op, 0, i);\n       rtx dest;\n       rtx src;\n       rtx plus;\n \n+      if (GET_CODE (vector_element) == CLOBBER)\n+\tcontinue;\n+\n       if (GET_CODE (vector_element) != SET)\n \treturn 0;\n \n@@ -406,14 +441,15 @@\n \t space just acquired by the first operand then abandon this quest.\n \t Note: the test is <= because both values are negative.\t */\n       if (INTVAL (XEXP (plus, 1))\n-\t  <= INTVAL (XEXP (SET_SRC (XVECEXP (op, 0, 0)), 1)))\n+\t  < INTVAL (XEXP (SET_SRC (XVECEXP (op, 0, 0)), 1)))\n \treturn 0;\n     }\n \n   return 1;\n })\n \n-;; TODO: Add a comment here.\n+;; Return true if OP is a valid operand for bit related operations\n+;; containing only single 0 in its binary representation.\n \n (define_predicate \"not_power_of_two_operand\"\n   (match_code \"const_int\")\n@@ -436,3 +472,31 @@\n     return 0;\n   return 1;\n })\n+\n+;; Return true if OP is a float value operand with value as 1.\n+\n+(define_predicate \"const_float_1_operand\"\n+  (match_code \"const_int\")\n+{\n+  if (GET_CODE (op) != CONST_DOUBLE\n+      || mode != GET_MODE (op)\n+      || (mode != DFmode && mode != SFmode))\n+    return 0;\n+\n+  return op == CONST1_RTX(mode);\n+})\n+\n+;; Return true if OP is a float value operand with value as 0.\n+\n+(define_predicate \"const_float_0_operand\"\n+  (match_code \"const_int\")\n+{\n+  if (GET_CODE (op) != CONST_DOUBLE\n+      || mode != GET_MODE (op)\n+      || (mode != DFmode && mode != SFmode))\n+    return 0;\n+\n+  return op == CONST0_RTX(mode);\n+})\n+\n+"}, {"sha": "6ae399192cb9ee2a70f8ab61c89b244d7bc53490", "filename": "gcc/config/v850/t-v850", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/223a9d64453b03941bcd88e479c8047edffadc42/gcc%2Fconfig%2Fv850%2Ft-v850", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/223a9d64453b03941bcd88e479c8047edffadc42/gcc%2Fconfig%2Fv850%2Ft-v850", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Ft-v850?ref=223a9d64453b03941bcd88e479c8047edffadc42", "patch": "@@ -46,7 +46,6 @@ LIB1ASMFUNCS\t= _mulsi3 \\\n \t\t  _save_28c \\\n \t\t  _save_29c \\\n \t\t  _save_31c \\\n-\t\t  _save_varargs \\\n \t\t  _save_interrupt \\\n \t\t  _save_all_interrupt \\\n                   _callt_save_20 \\\n@@ -70,12 +69,10 @@ LIB1ASMFUNCS\t= _mulsi3 \\\n \t\t  _callt_save_28c \\\n \t\t  _callt_save_29c \\\n \t\t  _callt_save_31c \\\n-\t\t  _callt_save_varargs \\\n \t\t  _callt_save_interrupt \\\n \t\t  _callt_save_all_interrupt \\\n \t\t  _callt_save_r2_r29 \\\n \t\t  _callt_save_r2_r31 \\\n-\t\t  _callt_save_r6_r9 \\\n \t\t  _negdi2 \\\n \t\t  _cmpdi2 \\\n \t\t  _ucmpdi2 \\\n@@ -100,10 +97,10 @@ fp-bit.c: $(srcdir)/config/fp-bit.c\n \tcat $(srcdir)/config/fp-bit.c >> fp-bit.c\n \n # Create target-specific versions of the libraries\n-MULTILIB_OPTIONS  = mv850e\n-MULTILIB_DIRNAMES = v850e\n+MULTILIB_OPTIONS  = mv850/mv850e/mv850e2/mv850e2v3\n+MULTILIB_DIRNAMES = v850 v850e v850e2 v850e2v3\n INSTALL_LIBGCC    = install-multilib\n-MULTILIB_MATCHES  = mv850e=mv850e1\n+MULTILIB_MATCHES  = mv850e=mv850e1 \n \n TCFLAGS = -mno-app-regs -msmall-sld -Wa,-mwarn-signed-overflow -Wa,-mwarn-unsigned-overflow\n "}, {"sha": "055321455b5917e82bdbf61e2d29ef63e57e5cd2", "filename": "gcc/config/v850/t-v850e", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/223a9d64453b03941bcd88e479c8047edffadc42/gcc%2Fconfig%2Fv850%2Ft-v850e", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/223a9d64453b03941bcd88e479c8047edffadc42/gcc%2Fconfig%2Fv850%2Ft-v850e", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Ft-v850e?ref=223a9d64453b03941bcd88e479c8047edffadc42", "patch": "@@ -45,7 +45,6 @@ LIB1ASMFUNCS\t= _mulsi3 \\\n \t\t  _save_28c \\\n \t\t  _save_29c \\\n \t\t  _save_31c \\\n-\t\t  _save_varargs \\\n \t\t  _save_interrupt \\\n \t\t  _save_all_interrupt \\\n                   _callt_save_20 \\\n@@ -69,12 +68,10 @@ LIB1ASMFUNCS\t= _mulsi3 \\\n \t\t  _callt_save_28c \\\n \t\t  _callt_save_29c \\\n \t\t  _callt_save_31c \\\n-\t\t  _callt_save_varargs \\\n \t\t  _callt_save_interrupt \\\n \t\t  _callt_save_all_interrupt \\\n \t\t  _callt_save_r2_r29 \\\n \t\t  _callt_save_r2_r31 \\\n-\t\t  _callt_save_r6_r9 \\\n \t\t  _negdi2 \\\n \t\t  _cmpdi2 \\\n \t\t  _ucmpdi2 \\"}, {"sha": "d90ce5456c271a7a2b4550e355880eaa7b43a0f0", "filename": "gcc/config/v850/v850-modes.def", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/223a9d64453b03941bcd88e479c8047edffadc42/gcc%2Fconfig%2Fv850%2Fv850-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/223a9d64453b03941bcd88e479c8047edffadc42/gcc%2Fconfig%2Fv850%2Fv850-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850-modes.def?ref=223a9d64453b03941bcd88e479c8047edffadc42", "patch": "@@ -0,0 +1,29 @@\n+/* Definitions of target machine for GNU compiler. NEC V850 series\n+  Copyright (C) 2005\n+   Free Software Foundation, Inc.\n+   Contributed by NEC EL\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 2, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+  GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING.  If not, write to\n+  the Free Software Foundation, 59 Temple Place - Suite 330,\n+   Boston, MA 02111-1307, USA.  */\n+\n+CC_MODE (CC_FPU_LT);\n+CC_MODE (CC_FPU_LE);\n+CC_MODE (CC_FPU_GT);\n+CC_MODE (CC_FPU_GE);\n+CC_MODE (CC_FPU_EQ);\n+CC_MODE (CC_FPU_NE);\n+"}, {"sha": "3fe08797da7b9745f93b48361f52e4bd1e4df8a2", "filename": "gcc/config/v850/v850-protos.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/223a9d64453b03941bcd88e479c8047edffadc42/gcc%2Fconfig%2Fv850%2Fv850-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/223a9d64453b03941bcd88e479c8047edffadc42/gcc%2Fconfig%2Fv850%2Fv850-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850-protos.h?ref=223a9d64453b03941bcd88e479c8047edffadc42", "patch": "@@ -43,6 +43,11 @@ extern char * construct_restore_jr          (rtx);\n extern char * construct_dispose_instruction (rtx);\n extern char * construct_prepare_instruction (rtx);\n extern int    ep_memory_operand             (rtx, Mmode, int);\n+extern int    v850_float_z_comparison_operator (rtx, Mmode);\n+extern int    v850_float_nz_comparison_operator (rtx, Mmode);\n+extern rtx    v850_gen_compare              (enum rtx_code, Mmode, rtx, rtx);\n+extern Mmode  v850_gen_float_compare (enum rtx_code, Mmode, rtx, rtx);\n+extern Mmode  v850_select_cc_mode (RTX_CODE, rtx, rtx);\n #ifdef TREE_CODE\n extern rtx    function_arg                  (CUMULATIVE_ARGS *, Mmode, tree, int);\n #endif"}, {"sha": "0879726a0264d42414ee16a4ae909e1bf069cfd8", "filename": "gcc/config/v850/v850.c", "status": "modified", "additions": 309, "deletions": 165, "changes": 474, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/223a9d64453b03941bcd88e479c8047edffadc42/gcc%2Fconfig%2Fv850%2Fv850.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/223a9d64453b03941bcd88e479c8047edffadc42/gcc%2Fconfig%2Fv850%2Fv850.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.c?ref=223a9d64453b03941bcd88e479c8047edffadc42", "patch": "@@ -65,6 +65,7 @@ static void v850_asm_init_sections   (void);\n static section *v850_select_section (tree, int, unsigned HOST_WIDE_INT);\n static void v850_encode_data_area    (tree, rtx);\n static void v850_encode_section_info (tree, rtx, int);\n+static int v850_issue_rate (void);\n static bool v850_return_in_memory    (const_tree, const_tree);\n static rtx v850_function_value (const_tree, const_tree, bool);\n static void v850_setup_incoming_varargs (CUMULATIVE_ARGS *, enum machine_mode,\n@@ -73,6 +74,7 @@ static bool v850_pass_by_reference (CUMULATIVE_ARGS *, enum machine_mode,\n \t\t\t\t    const_tree, bool);\n static int v850_arg_partial_bytes (CUMULATIVE_ARGS *, enum machine_mode,\n \t\t\t\t   tree, bool);\n+static bool v850_strict_argument_naming (CUMULATIVE_ARGS *);\n static bool v850_can_eliminate       (const int, const int);\n static void v850_asm_trampoline_template (FILE *);\n static void v850_trampoline_init (rtx, tree, rtx);\n@@ -101,6 +103,8 @@ data_area_stack_element * data_area_stack = NULL;\n    function is an interrupt handler.  */\n static int v850_interrupt_cache_p = FALSE;\n \n+rtx v850_compare_op0, v850_compare_op1;\n+\n /* Whether current function is an interrupt handler.  */\n static int v850_interrupt_p = FALSE;\n \n@@ -169,6 +173,9 @@ static const struct attribute_spec v850_attribute_table[] =\n #undef TARGET_MACHINE_DEPENDENT_REORG\n #define TARGET_MACHINE_DEPENDENT_REORG v850_reorg\n \n+#undef TARGET_SCHED_ISSUE_RATE\n+#define TARGET_SCHED_ISSUE_RATE v850_issue_rate\n+\n #undef TARGET_PROMOTE_PROTOTYPES\n #define TARGET_PROMOTE_PROTOTYPES hook_bool_const_tree_true\n \n@@ -198,6 +205,9 @@ static const struct attribute_spec v850_attribute_table[] =\n #undef TARGET_TRAMPOLINE_INIT\n #define TARGET_TRAMPOLINE_INIT v850_trampoline_init\n \n+#undef TARGET_STRICT_ARGUMENT_NAMING\n+#define TARGET_STRICT_ARGUMENT_NAMING v850_strict_argument_naming\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n /* Set the maximum size of small memory area TYPE to the value given\n@@ -258,7 +268,10 @@ v850_handle_option (size_t code, const char *arg, int value ATTRIBUTE_UNUSED)\n       return true;\n     }\n }\n-\f\n+\n+/* Handle the TARGET_PASS_BY_REFERENCE target hook.\n+   Specify whether to pass the argument by reference.  */\n+\n static bool\n v850_pass_by_reference (CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED,\n \t\t\tenum machine_mode mode, const_tree type,\n@@ -274,6 +287,14 @@ v850_pass_by_reference (CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED,\n   return size > 8;\n }\n \n+/* Implementing the Varargs Macros.  */\n+\n+static bool\n+v850_strict_argument_naming (CUMULATIVE_ARGS * ca ATTRIBUTE_UNUSED)\n+{\n+  return !TARGET_GHS ? true : false;\n+}\n+\n /* Return an RTX to represent where an argument with mode MODE\n    and type TYPE will be passed to a function.  If the result\n    is NULL_RTX, the argument will be pushed.  */\n@@ -287,22 +308,24 @@ function_arg (CUMULATIVE_ARGS * cum,\n   rtx result = NULL_RTX;\n   int size, align;\n \n-  if (TARGET_GHS && !named)\n+  if (!named)\n     return NULL_RTX;\n \n   if (mode == BLKmode)\n     size = int_size_in_bytes (type);\n   else\n     size = GET_MODE_SIZE (mode);\n \n+  size = (size + UNITS_PER_WORD -1) & ~(UNITS_PER_WORD -1);\n+\n   if (size < 1)\n     {\n       /* Once we have stopped using argument registers, do not start up again.  */\n       cum->nbytes = 4 * UNITS_PER_WORD;\n       return NULL_RTX;\n     }\n \n-  if (type)\n+  if (size <= UNITS_PER_WORD && type)\n     align = TYPE_ALIGN (type) / BITS_PER_UNIT;\n   else\n     align = size;\n@@ -337,10 +360,8 @@ function_arg (CUMULATIVE_ARGS * cum,\n   return result;\n }\n \n-\f\n /* Return the number of bytes which must be put into registers\n    for values which are part in registers and part in memory.  */\n-\n static int\n v850_arg_partial_bytes (CUMULATIVE_ARGS * cum, enum machine_mode mode,\n                         tree type, bool named)\n@@ -378,7 +399,6 @@ v850_arg_partial_bytes (CUMULATIVE_ARGS * cum, enum machine_mode mode,\n   return 4 * UNITS_PER_WORD - cum->nbytes;\n }\n \n-\f\n /* Return the high and low words of a CONST_DOUBLE */\n \n static void\n@@ -713,6 +733,11 @@ v850_print_operand (FILE * file, rtx x, int code)\n     case 'z':\t\t\t/* reg or zero */\n       if (GET_CODE (x) == REG)\n \tfputs (reg_names[REGNO (x)], file);\n+      else if ((GET_MODE(x) == SImode\n+\t\t|| GET_MODE(x) == DFmode\n+\t\t|| GET_MODE(x) == SFmode)\n+\t\t&& x == CONST0_RTX(GET_MODE(x)))\n+      fputs (reg_names[0], file);\n       else\n \t{\n \t  gcc_assert (x == const0_rtx);\n@@ -917,13 +942,13 @@ output_move_single (rtx * operands)\n \t    return \"mov %1,%0\";\n \n \t  else if (CONST_OK_FOR_K (value))\t/* Signed 16-bit immediate.  */\n-\t    return \"movea lo(%1),%.,%0\";\n+\t    return \"movea %1,%.,%0\";\n \n \t  else if (CONST_OK_FOR_L (value))\t/* Upper 16 bits were set.  */\n-\t    return \"movhi hi(%1),%.,%0\";\n+\t    return \"movhi hi0(%1),%.,%0\";\n \n \t  /* A random constant.  */\n-\t  else if (TARGET_V850E)\n+\t  else if (TARGET_V850E || TARGET_V850E2_ALL)\n \t      return \"mov %1,%0\";\n \t  else\n \t    return \"movhi hi(%1),%.,%0\\n\\tmovea lo(%1),%0,%0\";\n@@ -939,13 +964,13 @@ output_move_single (rtx * operands)\n \t    return \"mov %F1,%0\";\n \n \t  else if (CONST_OK_FOR_K (high))\t/* Signed 16-bit immediate.  */\n-\t    return \"movea lo(%F1),%.,%0\";\n+\t    return \"movea %F1,%.,%0\";\n \n \t  else if (CONST_OK_FOR_L (high))\t/* Upper 16 bits were set.  */\n-\t    return \"movhi hi(%F1),%.,%0\";\n+\t    return \"movhi hi0(%F1),%.,%0\";\n \n \t  /* A random constant.  */\n-\t  else if (TARGET_V850E)\n+\telse if (TARGET_V850E || TARGET_V850E2_ALL)\n \t      return \"mov %F1,%0\";\n \n \t  else\n@@ -962,7 +987,7 @@ output_move_single (rtx * operands)\n \t       || GET_CODE (src) == SYMBOL_REF\n \t       || GET_CODE (src) == CONST)\n \t{\n-\t  if (TARGET_V850E)\n+\t  if (TARGET_V850E || TARGET_V850E2_ALL) \n \t    return \"mov hilo(%1),%0\";\n \t  else\n \t    return \"movhi hi(%1),%.,%0\\n\\tmovea lo(%1),%0,%0\";\n@@ -996,7 +1021,169 @@ output_move_single (rtx * operands)\n   return \"\";\n }\n \n-\f\n+/* Generate comparison code.  */\n+int\n+v850_float_z_comparison_operator (rtx op, enum machine_mode mode)\n+{\n+  enum rtx_code code = GET_CODE (op);\n+\n+  if (GET_RTX_CLASS (code) != RTX_COMPARE\n+      && GET_RTX_CLASS (code) != RTX_COMM_COMPARE)\n+    return 0;\n+\n+  if (mode != GET_MODE (op) && mode != VOIDmode)\n+    return 0;\n+\n+  if ((GET_CODE (XEXP (op, 0)) != REG\n+       || REGNO (XEXP (op, 0)) != CC_REGNUM)\n+      || XEXP (op, 1) != const0_rtx)\n+    return 0;\n+\n+  if (GET_MODE (XEXP (op, 0)) == CC_FPU_LTmode)\n+    return code == LT;\n+  if (GET_MODE (XEXP (op, 0)) == CC_FPU_LEmode)\n+    return code == LE;\n+  if (GET_MODE (XEXP (op, 0)) == CC_FPU_EQmode)\n+    return code == EQ;\n+\n+  return 0;\n+}\n+\n+int\n+v850_float_nz_comparison_operator (rtx op, enum machine_mode mode)\n+{\n+  enum rtx_code code = GET_CODE (op);\n+\n+  if (GET_RTX_CLASS (code) != RTX_COMPARE\n+      && GET_RTX_CLASS (code) != RTX_COMM_COMPARE)\n+    return 0;\n+\n+  if (mode != GET_MODE (op) && mode != VOIDmode)\n+    return 0;\n+\n+  if ((GET_CODE (XEXP (op, 0)) != REG\n+       || REGNO (XEXP (op, 0)) != CC_REGNUM)\n+      || XEXP (op, 1) != const0_rtx)\n+    return 0;\n+\n+  if (GET_MODE (XEXP (op, 0)) == CC_FPU_GTmode)\n+    return code == GT;\n+  if (GET_MODE (XEXP (op, 0)) == CC_FPU_GEmode)\n+    return code == GE;\n+  if (GET_MODE (XEXP (op, 0)) == CC_FPU_NEmode)\n+    return code == NE;\n+\n+  return 0;\n+}\n+\n+enum machine_mode\n+v850_select_cc_mode (enum rtx_code cond, rtx op0, rtx op1)\n+{\n+  if (GET_MODE_CLASS (GET_MODE (op0)) == MODE_FLOAT)\n+    {\n+      switch (cond)\n+\t{\n+\tcase LE:\n+\t  return CC_FPU_LEmode;\n+\tcase GE:\n+\t  return CC_FPU_GEmode;\n+\tcase LT:\n+\t  return CC_FPU_LTmode;\n+\tcase GT:\n+\t  return CC_FPU_GTmode;\n+\tcase EQ:\n+\t  return CC_FPU_EQmode;\n+\tcase NE:\n+\t  return CC_FPU_NEmode;\n+\tdefault:\n+\t  abort ();\n+\t}\n+    }\n+  return CCmode;\n+}\n+\n+enum machine_mode\n+v850_gen_float_compare (enum rtx_code cond, enum machine_mode mode ATTRIBUTE_UNUSED, rtx op0, rtx op1)\n+{\n+  if (GET_MODE(op0) == DFmode)\n+    {\n+      switch (cond)\n+\t{\n+\tcase LE:\n+\t  emit_insn (gen_cmpdf_le_insn (op0, op1));\n+\t  break;\n+\tcase GE:\n+\t  emit_insn (gen_cmpdf_ge_insn (op0, op1));\n+\t  break;\n+\tcase LT:\n+\t  emit_insn (gen_cmpdf_lt_insn (op0, op1));\n+\t  break;\n+\tcase GT:\n+\t  emit_insn (gen_cmpdf_gt_insn (op0, op1));\n+\t  break;\n+\tcase EQ:\n+\t  emit_insn (gen_cmpdf_eq_insn (op0, op1));\n+\t  break;\n+\tcase NE:\n+\t  emit_insn (gen_cmpdf_ne_insn (op0, op1));\n+\t  break;\n+\tdefault:\n+\t  abort ();\n+\t}\n+    }\n+  else if (GET_MODE(v850_compare_op0) == SFmode)\n+    {\n+      switch (cond)\n+\t{\n+\tcase LE:\n+\t  emit_insn (gen_cmpsf_le_insn(op0, op1));\n+\t  break;\n+\tcase GE:\n+\t  emit_insn (gen_cmpsf_ge_insn(op0, op1));\n+\t  break;\n+\tcase LT:\n+\t  emit_insn (gen_cmpsf_lt_insn(op0, op1));\n+\t  break;\n+\tcase GT:\n+\t  emit_insn (gen_cmpsf_gt_insn(op0, op1));\n+\t  break;\n+\tcase EQ:\n+\t  emit_insn (gen_cmpsf_eq_insn(op0, op1));\n+\t  break;\n+\tcase NE:\n+\t  emit_insn (gen_cmpsf_ne_insn(op0, op1));\n+\t  break;\n+\tdefault:\n+\t  abort ();\n+\t}\n+    }\n+  else\n+    {\n+      abort ();\n+    }\n+\n+  return v850_select_cc_mode (cond, op0, op1);\n+}\n+\n+rtx\n+v850_gen_compare (enum rtx_code cond, enum machine_mode mode, rtx op0, rtx op1)\n+{\n+  if (GET_MODE_CLASS(GET_MODE (op0)) != MODE_FLOAT)\n+    {\n+      emit_insn (gen_cmpsi_insn (op0, op1));\n+      return gen_rtx_fmt_ee (cond, mode, gen_rtx_REG(CCmode, CC_REGNUM), const0_rtx);\n+    }\n+  else\n+    {\n+      rtx cc_reg;\n+      mode = v850_gen_float_compare (cond, mode, op0, op1);\n+      cc_reg = gen_rtx_REG (mode, CC_REGNUM);\n+      emit_insn (gen_rtx_SET(mode, cc_reg, gen_rtx_REG (mode, FCC_REGNUM)));  \n+\n+      return gen_rtx_fmt_ee (cond, mode, cc_reg, const0_rtx);\n+    }\n+}\n+\n /* Return maximum offset supported for a short EP memory reference of mode\n    MODE and signedness UNSIGNEDP.  */\n \n@@ -1010,9 +1197,8 @@ ep_memory_offset (enum machine_mode mode, int unsignedp ATTRIBUTE_UNUSED)\n     case QImode:\n       if (TARGET_SMALL_SLD)\n \tmax_offset = (1 << 4);\n-      else if (TARGET_V850E \n-\t       && (   (  unsignedp && ! TARGET_US_BIT_SET)\n-\t\t   || (! unsignedp &&   TARGET_US_BIT_SET)))\n+      else if ((TARGET_V850E || TARGET_V850E2_ALL)\n+\t\t&& unsignedp)\n \tmax_offset = (1 << 4);\n       else\n \tmax_offset = (1 << 7);\n@@ -1021,9 +1207,8 @@ ep_memory_offset (enum machine_mode mode, int unsignedp ATTRIBUTE_UNUSED)\n     case HImode:\n       if (TARGET_SMALL_SLD)\n \tmax_offset = (1 << 5);\n-      else if (TARGET_V850E\n-\t       && (   (  unsignedp && ! TARGET_US_BIT_SET)\n-\t\t   || (! unsignedp &&   TARGET_US_BIT_SET)))\n+      else if ((TARGET_V850E || TARGET_V850E2_ALL)\n+\t\t&& unsignedp)\n \tmax_offset = (1 << 5);\n       else\n \tmax_offset = (1 << 8);\n@@ -1420,18 +1605,15 @@ v850_reorg (void)\n     }\n }\n \n-\f\n /* # of registers saved by the interrupt handler.  */\n-#define INTERRUPT_FIXED_NUM 4\n+#define INTERRUPT_FIXED_NUM 5\n \n /* # of bytes for registers saved by the interrupt handler.  */\n #define INTERRUPT_FIXED_SAVE_SIZE (4 * INTERRUPT_FIXED_NUM)\n \n-/* # of registers saved in register parameter area.  */\n-#define INTERRUPT_REGPARM_NUM 4\n /* # of words saved for other registers.  */\n #define INTERRUPT_ALL_SAVE_NUM \\\n-  (30 - INTERRUPT_FIXED_NUM + INTERRUPT_REGPARM_NUM)\n+  (30 - INTERRUPT_FIXED_NUM)\n \n #define INTERRUPT_ALL_SAVE_SIZE (4 * INTERRUPT_ALL_SAVE_NUM)\n \n@@ -1477,6 +1659,7 @@ compute_register_save_size (long * p_reg_saved)\n \t  case 1:\t\t/* temp used to hold ep */\n \t  case 4:\t\t/* gp */\n \t  case 10:\t\t/* temp used to call interrupt save/restore */\n+\t  case 11:\t\t/* temp used to call interrupt save/restore (long call) */\n \t  case EP_REGNUM:\t/* ep */\n \t    size += 4;\n \t    break;\n@@ -1550,19 +1733,50 @@ compute_frame_size (int size, long * p_reg_saved)\n \t  + crtl->outgoing_args_size);\n }\n \n-\f\n+static int\n+use_prolog_function (int num_save, int frame_size)\n+{\n+  int alloc_stack = (4 * num_save);\n+  int unalloc_stack = frame_size - alloc_stack;\n+  int save_func_len, restore_func_len;\n+  int save_normal_len, restore_normal_len;\n+\n+  if (! TARGET_DISABLE_CALLT)\n+      save_func_len = restore_func_len = 2;\n+  else\n+      save_func_len = restore_func_len = TARGET_LONG_CALLS ? (4+4+4+2+2) : 4;\n+\n+  if (unalloc_stack)\n+    {\n+      save_func_len += CONST_OK_FOR_J (-unalloc_stack) ? 2 : 4;\n+      restore_func_len += CONST_OK_FOR_J (-unalloc_stack) ? 2 : 4;\n+    }\n+\n+  /* See if we would have used ep to save the stack.  */\n+  if (TARGET_EP && num_save > 3 && (unsigned)frame_size < 255)\n+    save_normal_len = restore_normal_len = (3 * 2) + (2 * num_save);\n+  else\n+    save_normal_len = restore_normal_len = 4 * num_save;\n+\n+  save_normal_len += CONST_OK_FOR_J (-frame_size) ? 2 : 4;\n+  restore_normal_len += (CONST_OK_FOR_J (frame_size) ? 2 : 4) + 2;\n+\n+  /* Don't bother checking if we don't actually save any space.\n+     This happens for instance if one register is saved and additional\n+     stack space is allocated.  */\n+  return ((save_func_len + restore_func_len) < (save_normal_len + restore_normal_len));\n+}\n+\n void\n expand_prologue (void)\n {\n   unsigned int i;\n-  int offset;\n   unsigned int size = get_frame_size ();\n   unsigned int actual_fsize;\n   unsigned int init_stack_alloc = 0;\n   rtx save_regs[32];\n   rtx save_all;\n   unsigned int num_save;\n-  unsigned int default_stack;\n   int code;\n   int interrupt_handler = v850_interrupt_function_p (current_function_decl);\n   long reg_saved = 0;\n@@ -1572,7 +1786,7 @@ expand_prologue (void)\n   /* Save/setup global registers for interrupt functions right now.  */\n   if (interrupt_handler)\n     {\n-      if (TARGET_V850E && ! TARGET_DISABLE_CALLT)\n+      if (! TARGET_DISABLE_CALLT)\n \temit_insn (gen_callt_save_interrupt ());\n       else\n \temit_insn (gen_save_interrupt ());\n@@ -1583,93 +1797,48 @@ expand_prologue (void)\n \tactual_fsize -= INTERRUPT_ALL_SAVE_SIZE;\n     }\n \n-  /* Save arg registers to the stack if necessary.  */\n-  else if (crtl->args.info.anonymous_args)\n-    {\n-      if (TARGET_PROLOG_FUNCTION && TARGET_V850E && !TARGET_DISABLE_CALLT)\n-\temit_insn (gen_save_r6_r9_v850e ());\n-      else if (TARGET_PROLOG_FUNCTION && ! TARGET_LONG_CALLS)\n-\temit_insn (gen_save_r6_r9 ());\n-      else\n-\t{\n-\t  offset = 0;\n-\t  for (i = 6; i < 10; i++)\n-\t    {\n-\t      emit_move_insn (gen_rtx_MEM (SImode,\n-\t\t\t\t\t   plus_constant (stack_pointer_rtx,\n-\t\t\t\t\t\t\t  offset)),\n-\t\t\t      gen_rtx_REG (SImode, i));\n-\t      offset += 4;\n-\t    }\n-\t}\n-    }\n-\n   /* Identify all of the saved registers.  */\n   num_save = 0;\n-  default_stack = 0;\n-  for (i = 1; i < 31; i++)\n+  for (i = 1; i < 32; i++)\n     {\n       if (((1L << i) & reg_saved) != 0)\n \tsave_regs[num_save++] = gen_rtx_REG (Pmode, i);\n     }\n \n-  /* If the return pointer is saved, the helper functions also allocate\n-     16 bytes of stack for arguments to be saved in.  */\n-  if (((1L << LINK_POINTER_REGNUM) & reg_saved) != 0)\n-    {\n-      save_regs[num_save++] = gen_rtx_REG (Pmode, LINK_POINTER_REGNUM);\n-      default_stack = 16;\n-    }\n-\n   /* See if we have an insn that allocates stack space and saves the particular\n      registers we want to.  */\n   save_all = NULL_RTX;\n-  if (TARGET_PROLOG_FUNCTION && num_save > 0 && actual_fsize >= default_stack)\n+  if (TARGET_PROLOG_FUNCTION && num_save > 0)\n     {\n-      int alloc_stack = (4 * num_save) + default_stack;\n-      int unalloc_stack = actual_fsize - alloc_stack;\n-      int save_func_len = 4;\n-      int save_normal_len;\n-\n-      if (unalloc_stack)\n-\tsave_func_len += CONST_OK_FOR_J (unalloc_stack) ? 2 : 4;\n-\n-      /* see if we would have used ep to save the stack */\n-      if (TARGET_EP && num_save > 3 && (unsigned)actual_fsize < 255)\n-\tsave_normal_len = (3 * 2) + (2 * num_save);\n-      else\n-\tsave_normal_len = 4 * num_save;\n-\n-      save_normal_len += CONST_OK_FOR_J (actual_fsize) ? 2 : 4;\n-\n-      /* Don't bother checking if we don't actually save any space.\n-\t This happens for instance if one register is saved and additional\n-\t stack space is allocated.  */\n-      if (save_func_len < save_normal_len)\n+      if (use_prolog_function (num_save, actual_fsize))\n \t{\n+\t  int alloc_stack = 4 * num_save;\n+\t  int offset = 0;\n+\n \t  save_all = gen_rtx_PARALLEL\n \t    (VOIDmode,\n \t     rtvec_alloc (num_save + 1\n-\t\t\t  + (TARGET_V850 ? (TARGET_LONG_CALLS ? 2 : 1) : 0)));\n+\t\t\t  + (TARGET_DISABLE_CALLT ? (TARGET_LONG_CALLS ? 2 : 1) : 0)));\n \n \t  XVECEXP (save_all, 0, 0)\n \t    = gen_rtx_SET (VOIDmode,\n \t\t\t   stack_pointer_rtx,\n-\t\t\t   plus_constant (stack_pointer_rtx, -alloc_stack));\n-\n-\t  offset = - default_stack;\n+\t\t\t   gen_rtx_PLUS (Pmode,\n+\t\t\t\t\t stack_pointer_rtx,\n+\t\t\t\t\t GEN_INT(-alloc_stack)));\n \t  for (i = 0; i < num_save; i++)\n \t    {\n+\t      offset -= 4;\n \t      XVECEXP (save_all, 0, i+1)\n \t\t= gen_rtx_SET (VOIDmode,\n \t\t\t       gen_rtx_MEM (Pmode,\n-\t\t\t\t\t    plus_constant (stack_pointer_rtx,\n-\t\t\t\t\t\t\t   offset)),\n+\t\t\t\t\t    gen_rtx_PLUS (Pmode,\n+\t\t\t\t\t\t\t  stack_pointer_rtx,\n+\t\t\t\t\t\t\t  GEN_INT(offset))),\n \t\t\t       save_regs[i]);\n-\t      offset -= 4;\n \t    }\n \n-\t  if (TARGET_V850)\n+\t  if (TARGET_DISABLE_CALLT)\n \t    {\n \t      XVECEXP (save_all, 0, num_save + 1)\n \t\t= gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (Pmode, 10));\n@@ -1686,12 +1855,6 @@ expand_prologue (void)\n \t      INSN_CODE (insn) = code;\n \t      actual_fsize -= alloc_stack;\n \t      \n-\t      if (TARGET_DEBUG)\n-\t\tfprintf (stderr, \"\\\n-Saved %d bytes via prologue function (%d vs. %d) for function %s\\n\",\n-\t\t\t save_normal_len - save_func_len,\n-\t\t\t save_normal_len, save_func_len,\n-\t\t\t IDENTIFIER_POINTER (DECL_NAME (current_function_decl)));\n \t    }\n \t  else\n \t    save_all = NULL_RTX;\n@@ -1705,13 +1868,14 @@ Saved %d bytes via prologue function (%d vs. %d) for function %s\\n\",\n       /* Special case interrupt functions that save all registers for a call.  */\n       if (interrupt_handler && ((1L << LINK_POINTER_REGNUM) & reg_saved) != 0)\n \t{\n-\t  if (TARGET_V850E && ! TARGET_DISABLE_CALLT)\n+\t  if (! TARGET_DISABLE_CALLT)\n \t    emit_insn (gen_callt_save_all_interrupt ());\n \t  else\n \t    emit_insn (gen_save_all_interrupt ());\n \t}\n       else\n \t{\n+\t  int offset;\n \t  /* If the stack is too big, allocate it in chunks so we can do the\n \t     register saves.  We use the register save size so we use the ep\n \t     register.  */\n@@ -1755,7 +1919,7 @@ Saved %d bytes via prologue function (%d vs. %d) for function %s\\n\",\n   if (actual_fsize > init_stack_alloc)\n     {\n       int diff = actual_fsize - init_stack_alloc;\n-      if (CONST_OK_FOR_K (diff))\n+      if (CONST_OK_FOR_K (-diff))\n \temit_insn (gen_addsi3 (stack_pointer_rtx,\n \t\t\t       stack_pointer_rtx,\n \t\t\t       GEN_INT (-diff)));\n@@ -1777,15 +1941,12 @@ void\n expand_epilogue (void)\n {\n   unsigned int i;\n-  int offset;\n   unsigned int size = get_frame_size ();\n   long reg_saved = 0;\n   int actual_fsize = compute_frame_size (size, &reg_saved);\n-  unsigned int init_stack_free = 0;\n   rtx restore_regs[32];\n   rtx restore_all;\n   unsigned int num_restore;\n-  unsigned int default_stack;\n   int code;\n   int interrupt_handler = v850_interrupt_function_p (current_function_decl);\n \n@@ -1803,49 +1964,28 @@ expand_epilogue (void)\n \n   /* Identify all of the saved registers.  */\n   num_restore = 0;\n-  default_stack = 0;\n-  for (i = 1; i < 31; i++)\n+  for (i = 1; i < 32; i++)\n     {\n       if (((1L << i) & reg_saved) != 0)\n \trestore_regs[num_restore++] = gen_rtx_REG (Pmode, i);\n     }\n \n-  /* If the return pointer is saved, the helper functions also allocate\n-     16 bytes of stack for arguments to be saved in.  */\n-  if (((1L << LINK_POINTER_REGNUM) & reg_saved) != 0)\n-    {\n-      restore_regs[num_restore++] = gen_rtx_REG (Pmode, LINK_POINTER_REGNUM);\n-      default_stack = 16;\n-    }\n-\n   /* See if we have an insn that restores the particular registers we\n      want to.  */\n   restore_all = NULL_RTX;\n-  \n+\n   if (TARGET_PROLOG_FUNCTION\n       && num_restore > 0\n-      && actual_fsize >= (signed) default_stack\n       && !interrupt_handler)\n     {\n-      int alloc_stack = (4 * num_restore) + default_stack;\n-      int unalloc_stack = actual_fsize - alloc_stack;\n-      int restore_func_len = 4;\n+      int alloc_stack = (4 * num_restore);\n+      int restore_func_len;\n       int restore_normal_len;\n \n-      if (unalloc_stack)\n-\trestore_func_len += CONST_OK_FOR_J (unalloc_stack) ? 2 : 4;\n-\n-      /* See if we would have used ep to restore the registers.  */\n-      if (TARGET_EP && num_restore > 3 && (unsigned)actual_fsize < 255)\n-\trestore_normal_len = (3 * 2) + (2 * num_restore);\n-      else\n-\trestore_normal_len = 4 * num_restore;\n-\n-      restore_normal_len += (CONST_OK_FOR_J (actual_fsize) ? 2 : 4) + 2;\n-\n       /* Don't bother checking if we don't actually save any space.  */\n-      if (restore_func_len < restore_normal_len)\n+      if (use_prolog_function (num_restore, actual_fsize))\n \t{\n+\t  int offset;\n \t  restore_all = gen_rtx_PARALLEL (VOIDmode,\n \t\t\t\t\t  rtvec_alloc (num_restore + 2));\n \t  XVECEXP (restore_all, 0, 0) = gen_rtx_RETURN (VOIDmode);\n@@ -1862,8 +2002,9 @@ expand_epilogue (void)\n \t\t= gen_rtx_SET (VOIDmode,\n \t\t\t       restore_regs[i],\n \t\t\t       gen_rtx_MEM (Pmode,\n-\t\t\t\t\t    plus_constant (stack_pointer_rtx,\n-\t\t\t\t\t\t\t   offset)));\n+                                            gen_rtx_PLUS (Pmode,\n+                                                          stack_pointer_rtx,\n+                                                          GEN_INT(offset))));\n \t      offset -= 4;\n \t    }\n \n@@ -1893,12 +2034,6 @@ expand_epilogue (void)\n \t      insn = emit_jump_insn (restore_all);\n \t      INSN_CODE (insn) = code;\n \n-\t      if (TARGET_DEBUG)\n-\t\tfprintf (stderr, \"\\\n-Saved %d bytes via epilogue function (%d vs. %d) in function %s\\n\",\n-\t\t\t restore_normal_len - restore_func_len,\n-\t\t\t restore_normal_len, restore_func_len,\n-\t\t\t IDENTIFIER_POINTER (DECL_NAME (current_function_decl)));\n \t    }\n \t  else\n \t    restore_all = NULL_RTX;\n@@ -1909,8 +2044,12 @@ Saved %d bytes via epilogue function (%d vs. %d) in function %s\\n\",\n      old fashioned way (one by one).  */\n   if (!restore_all)\n     {\n+      unsigned int init_stack_free;\n+\n       /* If the stack is large, we need to cut it down in 2 pieces.  */\n-      if (actual_fsize && !CONST_OK_FOR_K (-actual_fsize))\n+      if (interrupt_handler)\n+       init_stack_free = 0;\n+      else if (actual_fsize && !CONST_OK_FOR_K (-actual_fsize))\n \tinit_stack_free = 4 * num_restore;\n       else\n \tinit_stack_free = (signed) actual_fsize;\n@@ -1920,7 +2059,7 @@ Saved %d bytes via epilogue function (%d vs. %d) in function %s\\n\",\n \t{\n \t  int diff;\n \n-\t  diff = actual_fsize - ((interrupt_handler) ? 0 : init_stack_free);\n+\t  diff = actual_fsize - init_stack_free;\n \n \t  if (CONST_OK_FOR_K (diff))\n \t    emit_insn (gen_addsi3 (stack_pointer_rtx,\n@@ -1940,15 +2079,15 @@ Saved %d bytes via epilogue function (%d vs. %d) in function %s\\n\",\n \t for a call.  */\n       if (interrupt_handler && ((1L << LINK_POINTER_REGNUM) & reg_saved) != 0)\n \t{\n-\t  if (TARGET_V850E && ! TARGET_DISABLE_CALLT)\n+\t  if (! TARGET_DISABLE_CALLT)\n \t    emit_insn (gen_callt_restore_all_interrupt ());\n \t  else\n \t    emit_insn (gen_restore_all_interrupt ());\n \t}\n       else\n \t{\n \t  /* Restore registers from the beginning of the stack frame.  */\n-\t  offset = init_stack_free - 4;\n+\t  int offset = init_stack_free - 4;\n \n \t  /* Restore the return pointer first.  */\n \t  if (num_restore > 0\n@@ -1982,7 +2121,7 @@ Saved %d bytes via epilogue function (%d vs. %d) in function %s\\n\",\n       /* And return or use reti for interrupt handlers.  */\n       if (interrupt_handler)\n         {\n-          if (TARGET_V850E && ! TARGET_DISABLE_CALLT)\n+          if (! TARGET_DISABLE_CALLT)\n             emit_insn (gen_callt_return_interrupt ());\n           else\n             emit_jump_insn (gen_return_interrupt ());\n@@ -1997,9 +2136,7 @@ Saved %d bytes via epilogue function (%d vs. %d) in function %s\\n\",\n   v850_interrupt_p = FALSE;\n }\n \n-\f\n /* Update the condition code from the insn.  */\n-\n void\n notice_update_cc (rtx body, rtx insn)\n {\n@@ -2026,7 +2163,7 @@ notice_update_cc (rtx body, rtx insn)\n \n     case CC_SET_ZNV:\n       /* Insn sets the Z,N,V flags of CC to recog_data.operand[0].\n-\t C is in an unusable state.  */\n+  \t C is in an unusable state.  */\n       CC_STATUS_INIT;\n       cc_status.flags |= CC_NO_CARRY;\n       cc_status.value1 = recog_data.operand[0];\n@@ -2044,7 +2181,7 @@ notice_update_cc (rtx body, rtx insn)\n       break;\n     }\n }\n-\f\n+\n /* Retrieve the data area that has been chosen for the given decl.  */\n \n v850_data_area\n@@ -2258,6 +2395,7 @@ v850_encode_section_info (tree decl, rtx rtl, int first)\n    pops registers off the stack and possibly releases some extra stack space\n    as well.  The code has already verified that the RTL matches these\n    requirements.  */\n+\n char *\n construct_restore_jr (rtx op)\n {\n@@ -2287,7 +2425,7 @@ construct_restore_jr (rtx op)\n   stack_bytes -= (count - 2) * 4;\n \n   /* Make sure that the amount we are popping either 0 or 16 bytes.  */\n-  if (stack_bytes != 0 && stack_bytes != 16)\n+  if (stack_bytes != 0)\n     {\n       error (\"bad amount of stack space removal: %d\", stack_bytes);\n       return NULL;\n@@ -2319,8 +2457,6 @@ construct_restore_jr (rtx op)\n   /* Discover the last register to pop.  */\n   if (mask & (1 << LINK_POINTER_REGNUM))\n     {\n-      gcc_assert (stack_bytes == 16);\n-      \n       last = LINK_POINTER_REGNUM;\n     }\n   else\n@@ -2376,7 +2512,7 @@ construct_save_jarl (rtx op)\n   int i;\n   static char buff [100]; /* XXX */\n   \n-  if (count <= 2)\n+  if (count <= (TARGET_LONG_CALLS ? 3 : 2)) \n     {\n       error (\"bogus JARL construction: %d\\n\", count);\n       return NULL;\n@@ -2396,7 +2532,7 @@ construct_save_jarl (rtx op)\n   stack_bytes += (count - (TARGET_LONG_CALLS ? 3 : 2)) * 4;\n \n   /* Make sure that the amount we are popping either 0 or 16 bytes.  */\n-  if (stack_bytes != 0 && stack_bytes != -16)\n+  if (stack_bytes != 0)\n     {\n       error (\"bad amount of stack space removal: %d\", stack_bytes);\n       return NULL;\n@@ -2428,8 +2564,6 @@ construct_save_jarl (rtx op)\n   /* Discover the last register to push.  */\n   if (mask & (1 << LINK_POINTER_REGNUM))\n     {\n-      gcc_assert (stack_bytes == -16);\n-      \n       last = LINK_POINTER_REGNUM;\n     }\n   else\n@@ -2719,7 +2853,7 @@ construct_dispose_instruction (rtx op)\n     }\n \n   if (! TARGET_DISABLE_CALLT\n-      && (use_callt || stack_bytes == 0 || stack_bytes == 16))\n+      && (use_callt || stack_bytes == 0))\n     {\n       if (use_callt)\n \t{\n@@ -2735,8 +2869,8 @@ construct_dispose_instruction (rtx op)\n \t  if (i == 31)\n \t    sprintf (buff, \"callt ctoff(__callt_return_r31c)\");\n \t  else\n-\t    sprintf (buff, \"callt ctoff(__callt_return_r%d_r%d%s)\",\n-\t\t     i, (mask & (1 << 31)) ? 31 : 29, stack_bytes ? \"c\" : \"\");\n+\t    sprintf (buff, \"callt ctoff(__callt_return_r%d_r%s)\",\n+\t\t     i, (mask & (1 << 31)) ? \"31c\" : \"29\");\n \t}\n     }\n   else\n@@ -2789,16 +2923,16 @@ construct_dispose_instruction (rtx op)\n char *\n construct_prepare_instruction (rtx op)\n {\n-  int                count = XVECLEN (op, 0);\n+  int                count;\n   int                stack_bytes;\n   unsigned long int  mask;\n   int\t\t     i;\n   static char        buff[ 100 ]; /* XXX */\n   int\t\t     use_callt = 0;\n   \n-  if (count <= 1)\n+  if (XVECLEN (op, 0) <= 1)\n     {\n-      error (\"bogus PREPEARE construction: %d\", count);\n+      error (\"bogus PREPEARE construction: %d\", XVECLEN (op, 0));\n       return NULL;\n     }\n \n@@ -2810,8 +2944,6 @@ construct_prepare_instruction (rtx op)\n     \n   stack_bytes = INTVAL (XEXP (SET_SRC (XVECEXP (op, 0, 0)), 1));\n \n-  /* Each push will put 4 bytes from the stack.  */\n-  stack_bytes += (count - 1) * 4;\n \n   /* Make sure that the amount we are popping\n      will fit into the DISPOSE instruction.  */\n@@ -2822,11 +2954,15 @@ construct_prepare_instruction (rtx op)\n     }\n \n   /* Now compute the bit mask of registers to push.  */\n+  count = 0;\n   mask = 0;\n-  for (i = 1; i < count; i++)\n+  for (i = 1; i < XVECLEN (op, 0); i++)\n     {\n       rtx vector_element = XVECEXP (op, 0, i);\n       \n+      if (GET_CODE (vector_element) == CLOBBER)\n+\tcontinue;\n+      \n       gcc_assert (GET_CODE (vector_element) == SET);\n       gcc_assert (GET_CODE (SET_SRC (vector_element)) == REG);\n       gcc_assert (register_is_ok_for_epilogue (SET_SRC (vector_element),\n@@ -2836,10 +2972,13 @@ construct_prepare_instruction (rtx op)\n \tuse_callt = 1;\n       else\n \tmask |= 1 << REGNO (SET_SRC (vector_element));\n+      count++;\n     }\n \n+  stack_bytes += count * 4;\n+\n   if ((! TARGET_DISABLE_CALLT)\n-      && (use_callt || stack_bytes == 0 || stack_bytes == -16))\n+      && (use_callt || stack_bytes == 0))\n     {\n       if (use_callt)\n \t{\n@@ -2854,8 +2993,8 @@ construct_prepare_instruction (rtx op)\n       if (i == 31)\n \tsprintf (buff, \"callt ctoff(__callt_save_r31c)\");\n       else\n-\tsprintf (buff, \"callt ctoff(__callt_save_r%d_r%d%s)\",\n-\t\t i, (mask & (1 << 31)) ? 31 : 29, stack_bytes ? \"c\" : \"\");\n+\tsprintf (buff, \"callt ctoff(__callt_save_r%d_r%s)\",\n+\t\t i, (mask & (1 << 31)) ? \"31c\" : \"29\");\n     }\n   else\n     {\n@@ -2900,7 +3039,7 @@ construct_prepare_instruction (rtx op)\n   \n   return buff;\n }\n-\f\n+\n /* Return an RTX indicating where the return address to the\n    calling function can be found.  */\n \n@@ -3045,5 +3184,10 @@ v850_trampoline_init (rtx m_tramp, tree fndecl, rtx chain_value)\n   mem = adjust_address (m_tramp, SImode, 20);\n   emit_move_insn (mem, fnaddr);\n }\n-\f\n+\n+static int\n+v850_issue_rate (void)\n+{\n+  return (TARGET_V850E2_ALL? 2 : 1);\n+}\n #include \"gt-v850.h\""}, {"sha": "1a3905fc28c66aba29bde6779bfd09fd0ba96e0f", "filename": "gcc/config/v850/v850.h", "status": "modified", "additions": 127, "deletions": 67, "changes": 194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/223a9d64453b03941bcd88e479c8047edffadc42/gcc%2Fconfig%2Fv850%2Fv850.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/223a9d64453b03941bcd88e479c8047edffadc42/gcc%2Fconfig%2Fv850%2Fv850.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.h?ref=223a9d64453b03941bcd88e479c8047edffadc42", "patch": "@@ -22,16 +22,24 @@\n #ifndef GCC_V850_H\n #define GCC_V850_H\n \n+extern GTY(()) rtx v850_compare_op0;\n+extern GTY(()) rtx v850_compare_op1;\n+\n /* These are defined in svr4.h but we want to override them.  */\n #undef LIB_SPEC\n+#define LIB_SPEC \"%{!shared:%{!symbolic:--start-group -lc -lgcc --end-group}}\"\n+\n #undef ENDFILE_SPEC\n #undef LINK_SPEC\n #undef STARTFILE_SPEC\n #undef ASM_SPEC\n \n #define TARGET_CPU_generic \t1\n #define TARGET_CPU_v850e   \t2\n-#define TARGET_CPU_v850e1  \t3\n+#define TARGET_CPU_v850e1\t3\n+#define TARGET_CPU_v850e2\t4\n+#define TARGET_CPU_v850e2v3\t5\n+\n \n #ifndef TARGET_CPU_DEFAULT\n #define TARGET_CPU_DEFAULT\tTARGET_CPU_generic\n@@ -58,25 +66,50 @@\n \n #if TARGET_CPU_DEFAULT == TARGET_CPU_v850e1\n #undef  MASK_DEFAULT\n-#define MASK_DEFAULT            MASK_V850E\t/* No practical difference.  */\n+#define MASK_DEFAULT            MASK_V850E     /* No practical difference.  */     \n+#undef  SUBTARGET_ASM_SPEC\n+#define SUBTARGET_ASM_SPEC\t\"%{!mv*:-mv850e1}\"\n+#undef  SUBTARGET_CPP_SPEC\n+#define SUBTARGET_CPP_SPEC\t\"%{!mv*:-D__v850e1__} %{mv850e1:-D__v850e1__}\"\n+#undef  TARGET_VERSION\n+#define TARGET_VERSION\t\tfprintf (stderr, \" (NEC V850E1)\");\n+#endif\n+\n+#if TARGET_CPU_DEFAULT == TARGET_CPU_v850e2\n+#undef  MASK_DEFAULT\n+#define MASK_DEFAULT            MASK_V850E2\t\n+#undef  SUBTARGET_ASM_SPEC\n+#define SUBTARGET_ASM_SPEC \t\"%{!mv*:-mv850e2}\"\n+#undef  SUBTARGET_CPP_SPEC\n+#define SUBTARGET_CPP_SPEC \t\"%{!mv*:-D__v850e2__} %{mv850e2:-D__v850e2__}\"\n+#undef  TARGET_VERSION\n+#define TARGET_VERSION \t\tfprintf (stderr, \" (NEC V850E2)\");\n+#endif\n+\n+#if TARGET_CPU_DEFAULT == TARGET_CPU_v850e2v3\n+#undef  MASK_DEFAULT\n+#define MASK_DEFAULT            MASK_V850E2V3\n #undef  SUBTARGET_ASM_SPEC\n-#define SUBTARGET_ASM_SPEC \t\"%{!mv*:-mv850e1}\"\n+#define SUBTARGET_ASM_SPEC\t\"%{!mv*:-mv850e2v3}\"\n #undef  SUBTARGET_CPP_SPEC\n-#define SUBTARGET_CPP_SPEC \t\"%{!mv*:-D__v850e1__} %{mv850e1:-D__v850e1__}\"\n+#define SUBTARGET_CPP_SPEC\t\"%{!mv*:-D__v850e2v3__} %{mv850e2v3:-D__v850e2v3__}\"\n #undef  TARGET_VERSION\n-#define TARGET_VERSION \t\tfprintf (stderr, \" (NEC V850E1)\");\n+#define TARGET_VERSION\t\tfprintf (stderr, \" (NEC V850E2V3)\");\n #endif\n \n+#define TARGET_V850E2_ALL      (TARGET_V850E2 || TARGET_V850E2V3) \n+\n #define ASM_SPEC \"%{mv*:-mv%*}\"\n-#define CPP_SPEC\t\t\"%{mv850e:-D__v850e__} %{mv850:-D__v850__} %(subtarget_cpp_spec)\"\n+#define CPP_SPEC               \"%{mv850e2v3:-D__v850e2v3__} %{mv850e2:-D__v850e2__} %{mv850e:-D__v850e__} %{mv850:-D__v850__} %(subtarget_cpp_spec)\" \\\n+                               \" %{mep:-D__EP__}\"\n \n #define EXTRA_SPECS \\\n  { \"subtarget_asm_spec\", SUBTARGET_ASM_SPEC }, \\\n  { \"subtarget_cpp_spec\", SUBTARGET_CPP_SPEC } \n \n /* Names to predefine in the preprocessor for this target machine.  */\n #define TARGET_CPU_CPP_BUILTINS() do {\t\t\\\n-  builtin_define( \"__v851__\" );\t\t\t\\\n+  builtin_define( \"__v851__\" );                        \\\n   builtin_define( \"__v850\" );\t\t\t\\\n   builtin_assert( \"machine=v850\" );\t\t\\\n   builtin_assert( \"cpu=v850\" );\t\t\t\\\n@@ -130,7 +163,6 @@ extern struct small_memory_info small_memory[(int)SMALL_MEMORY_max];\n \n #define OPTIMIZATION_OPTIONS(LEVEL,SIZE)\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n-  target_flags |= MASK_STRICT_ALIGN;\t\t\t\t\t\\\n   if (LEVEL)\t\t\t\t\t\t\t\t\\\n     /* Note - we no longer enable MASK_EP when optimizing.  This is\t\\\n        because of a hardware bug which stops the SLD and SST instructions\\\n@@ -196,7 +228,7 @@ extern struct small_memory_info small_memory[(int)SMALL_MEMORY_max];\n \n /* Define this if move instructions will actually fail to work\n    when given unaligned data.  */\n-#define STRICT_ALIGNMENT  TARGET_STRICT_ALIGN\n+#define STRICT_ALIGNMENT  (!TARGET_NO_STRICT_ALIGN)\n \n /* Define this as 1 if `char' should by default be signed; else as 0.\n \n@@ -212,16 +244,17 @@ extern struct small_memory_info small_memory[(int)SMALL_MEMORY_max];\n    All registers that the compiler knows about must be given numbers,\n    even those that are not normally considered general registers.  */\n \n-#define FIRST_PSEUDO_REGISTER 34\n+#define FIRST_PSEUDO_REGISTER 36\n \n /* 1 for registers that have pervasive standard uses\n    and are not available for the register allocator.  */\n \n #define FIXED_REGISTERS \\\n-  { 1, 1, 0, 1, 1, 0, 0, 0, \\\n+  { 1, 1, 1, 1, 1, 1, 0, 0, \\\n     0, 0, 0, 0, 0, 0, 0, 0, \\\n     0, 0, 0, 0, 0, 0, 0, 0, \\\n     0, 0, 0, 0, 0, 0, 1, 0, \\\n+    1, 1,\t\\\n     1, 1}\n \n /* 1 for registers not available across function calls.\n@@ -233,10 +266,11 @@ extern struct small_memory_info small_memory[(int)SMALL_MEMORY_max];\n    like.  */\n \n #define CALL_USED_REGISTERS \\\n-  { 1, 1, 0, 1, 1, 1, 1, 1, \\\n+  { 1, 1, 1, 1, 1, 1, 1, 1, \\\n     1, 1, 1, 1, 1, 1, 1, 1, \\\n     1, 1, 1, 1, 0, 0, 0, 0, \\\n     0, 0, 0, 0, 0, 0, 1, 1, \\\n+    1, 1,\t\\\n     1, 1}\n \n /* List the order in which to allocate registers.  Each register must be\n@@ -254,19 +288,21 @@ extern struct small_memory_info small_memory[(int)SMALL_MEMORY_max];\n    6,  7,  8,  9, 31,\t\t\t/* argument registers */\t\\\n   29, 28, 27, 26, 25, 24, 23, 22,\t/* saved registers */\t\t\\\n   21, 20,  2,\t\t\t\t\t\t\t\t\\\n-   0,  1,  3,  4,  5, 30, 32, 33\t/* fixed registers */\t\t\\\n+   0,  1,  3,  4,  5, 30, 32, 33,      /* fixed registers */           \\\n+  34, 35\t\t\t\t\t\t\t\t\\\n }\n \n /* If TARGET_APP_REGS is not defined then add r2 and r5 to\n    the pool of fixed registers. See PR 14505.  */\n-#define CONDITIONAL_REGISTER_USAGE  \\\n-{                                                       \\\n-  if (!TARGET_APP_REGS)                                 \\\n-    {                                                   \\\n-      fixed_regs[2] = 1;  call_used_regs[2] = 1;        \\\n-      fixed_regs[5] = 1;  call_used_regs[5] = 1;        \\\n-    }                                                   \\\n-}\n+#define CONDITIONAL_REGISTER_USAGE             \\\n+{                                              \\\n+  if (TARGET_APP_REGS)                         \\\n+    {                                          \\\n+     fixed_regs[2] = 0;  call_used_regs[2] = 0;        \\\n+     fixed_regs[5] = 0;  call_used_regs[5] = 1;        \\\n+    }                                          \\\n+ }\n+\n \n /* Return number of consecutive hard regs needed starting at reg REGNO\n    to hold something of mode MODE.\n@@ -281,7 +317,7 @@ extern struct small_memory_info small_memory[(int)SMALL_MEMORY_max];\n    MODE.  */\n \n #define HARD_REGNO_MODE_OK(REGNO, MODE) \\\n- ((((REGNO) & 1) == 0) || (GET_MODE_SIZE (MODE) <= 4))\n+ ((GET_MODE_SIZE (MODE) <= 4) || (((REGNO) & 1) == 0 && (REGNO) != 0))\n \n /* Value is 1 if it is a good idea to tie two pseudo registers\n    when one has mode MODE1 and one has mode MODE2.\n@@ -313,7 +349,7 @@ extern struct small_memory_info small_memory[(int)SMALL_MEMORY_max];\n    \n enum reg_class\n {\n-  NO_REGS, GENERAL_REGS, ALL_REGS, LIM_REG_CLASSES\n+  NO_REGS, GENERAL_REGS, EVEN_REGS, ALL_REGS, LIM_REG_CLASSES\n };\n \n #define N_REG_CLASSES (int) LIM_REG_CLASSES\n@@ -326,25 +362,26 @@ enum reg_class\n /* Give names of register classes as strings for dump file.  */\n \n #define REG_CLASS_NAMES \\\n-{ \"NO_REGS\", \"GENERAL_REGS\", \"ALL_REGS\", \"LIM_REGS\" }\n+{ \"NO_REGS\", \"GENERAL_REGS\", \"EVEN_REGS\", \"ALL_REGS\", \"LIM_REGS\" }\n \n /* Define which registers fit in which classes.\n    This is an initializer for a vector of HARD_REG_SET\n    of length N_REG_CLASSES.  */\n \n-#define REG_CLASS_CONTENTS  \t\t\\\n-{\t\t\t\t\t\\\n-  { 0x00000000 }, /* NO_REGS      */\t\\\n-  { 0xffffffff }, /* GENERAL_REGS */   \t\\\n-  { 0xffffffff }, /* ALL_REGS \t*/\t\\\n+#define REG_CLASS_CONTENTS                     \\\n+{                                              \\\n+  { 0x00000000,0x0 }, /* NO_REGS      */       \\\n+  { 0xffffffff,0x0 }, /* GENERAL_REGS */       \\\n+  { 0x55555554,0x0 }, /* EVEN_REGS */          \\\n+  { 0xffffffff,0x0 }, /* ALL_REGS      */      \\\n }\n \n /* The same information, inverted:\n    Return the class number of the smallest class containing\n    reg number REGNO.  This could be a conditional expression\n    or could index an array.  */\n \n-#define REGNO_REG_CLASS(REGNO)  GENERAL_REGS\n+#define REGNO_REG_CLASS(REGNO)  ((REGNO == CC_REGNUM || REGNO == FCC_REGNUM) ? NO_REGS : GENERAL_REGS)\n \n /* The class value for index registers, and the one for base regs.  */\n \n@@ -353,7 +390,8 @@ enum reg_class\n \n /* Get reg_class from a letter such as appears in the machine description.  */\n \n-#define REG_CLASS_FROM_LETTER(C) (NO_REGS)\n+#define REG_CLASS_FROM_LETTER(C) \\\n+       (C == 'e' ? EVEN_REGS : (NO_REGS))\n \n /* Macros to check register numbers against specific register classes.  */\n \n@@ -363,8 +401,11 @@ enum reg_class\n    Since they use reg_renumber, they are safe only once reg_renumber\n    has been allocated, which happens in local-alloc.c.  */\n  \n-#define REGNO_OK_FOR_BASE_P(regno) \\\n-  ((regno) < FIRST_PSEUDO_REGISTER || reg_renumber[regno] >= 0)\n+#define REGNO_OK_FOR_BASE_P(regno)             \\\n+  (((regno) < FIRST_PSEUDO_REGISTER            \\\n+    && (regno) != CC_REGNUM                    \\\n+    && (regno) != FCC_REGNUM)                  \\\n+   || reg_renumber[regno] >= 0)\n \n #define REGNO_OK_FOR_INDEX_P(regno) 0\n \n@@ -470,13 +511,13 @@ enum reg_class\n    The values of these macros are register numbers.  */\n \n /* Register to use for pushing function arguments.  */\n-#define STACK_POINTER_REGNUM 3\n+#define STACK_POINTER_REGNUM SP_REGNUM\n \n /* Base register for access to local variables of the function.  */\n-#define FRAME_POINTER_REGNUM 32\n+#define FRAME_POINTER_REGNUM 34\n \n /* Register containing return address from latest function call.  */\n-#define LINK_POINTER_REGNUM 31\n+#define LINK_POINTER_REGNUM LP_REGNUM\n      \n /* On some machines the offset between the frame pointer and starting\n    offset of the automatic variables is not known until after register\n@@ -501,7 +542,7 @@ enum reg_class\n #define HARD_FRAME_POINTER_REGNUM 29\n \n /* Base register for access to arguments of the function.  */\n-#define ARG_POINTER_REGNUM 33\n+#define ARG_POINTER_REGNUM 35\n \n /* Register in which static-chain is passed to a function.  */\n #define STATIC_CHAIN_REGNUM 20\n@@ -593,19 +634,18 @@ struct cum_arg { int nbytes; int anonymous_args; };\n /* Update the data in CUM to advance over an argument\n    of mode MODE and data type TYPE.\n    (TYPE is null for libcalls where that information may not be available.)  */\n-\n-#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\\\n- ((CUM).nbytes += ((MODE) != BLKmode\t\t\t\\\n-  ? (GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) & -UNITS_PER_WORD\t\\\n-  : (int_size_in_bytes (TYPE) + UNITS_PER_WORD - 1) & -UNITS_PER_WORD))\n+#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\t\t\\\n+ ((CUM).nbytes +=\t\t\t\t\t\t\t\\\n+  ((((TYPE) && int_size_in_bytes (TYPE) > 8)\t\t\t\t\\\n+   ? GET_MODE_SIZE (Pmode)\t\t\t\t\t\t\\\n+   : ((MODE) != BLKmode\t\t\t\t\t\t\t\\\n+      ? GET_MODE_SIZE ((MODE))\t\t\t\t\t\t\\\n+      : int_size_in_bytes ((TYPE))))\t\t\t\t\t\\\n+   + UNITS_PER_WORD - 1) & -UNITS_PER_WORD)\n \n /* When a parameter is passed in a register, stack space is still\n    allocated for it.  */\n-#define REG_PARM_STACK_SPACE(DECL) (!TARGET_GHS ? 16 : 0)\n-\n-/* Define this if the above stack space is to be considered part of the\n-   space allocated by the caller.  */\n-#define OUTGOING_REG_PARM_STACK_SPACE(FNTYPE) 1\n+#define REG_PARM_STACK_SPACE(DECL) 0\n \n /* 1 if N is a possible register number for function argument passing.  */\n \n@@ -723,8 +763,11 @@ struct cum_arg { int nbytes; int anonymous_args; };\n \t\t   && SYMBOL_REF_ZDA_P (OP))\t\t\t\t\\\n \t\t  || (GET_CODE (OP) == CONST\t\t\t\t\\\n \t\t      && GET_CODE (XEXP (OP, 0)) == PLUS\t\t\\\n-\t\t      && GET_CODE (XEXP (XEXP (OP, 0), 0)) == SYMBOL_REF \\\n+\t\t      && GET_CODE (XEXP (XEXP (OP, 0), 0)) == SYMBOL_REF\\\n \t\t      && SYMBOL_REF_ZDA_P (XEXP (XEXP (OP, 0), 0))))\t\\\n+  : (C) == 'W' ? (GET_CODE (OP) == CONST_INT                            \\\n+\t\t  && ((unsigned)(INTVAL (OP)) >= 0x8000)               \\\n+\t\t  && ((unsigned)(INTVAL (OP)) < 0x400000))              \\\n   : 0)\n \f\n /* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n@@ -765,7 +808,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n      goto ADDR;\t\t\t\t\t\t\t\t\\\n   if (GET_CODE (X) == PLUS\t\t\t\t\t\t\\\n       && RTX_OK_FOR_BASE_P (XEXP (X, 0)) \t\t\t\t\\\n-      && CONSTANT_ADDRESS_P (XEXP (X, 1))\t\t\t\t\\\n+      && (GET_CODE (XEXP (X,1)) == CONST_INT && CONST_OK_FOR_K (INTVAL(XEXP (X,1)) + GET_MODE_NUNITS(MODE) * UNITS_PER_WORD)) \\\n       && ((MODE == QImode || INTVAL (XEXP (X, 1)) % 2 == 0)\t\t\\\n \t   && CONST_OK_FOR_K (INTVAL (XEXP (X, 1)) \t\t\t\\\n                               + (GET_MODE_NUNITS (MODE) * UNITS_PER_WORD)))) \\\n@@ -783,7 +826,18 @@ do {\t\t\t\t\t\t\t\t\t\\\n \t&& GET_CODE (XEXP (XEXP (X, 0), 0)) == SYMBOL_REF\t\t\\\n \t&& GET_CODE (XEXP (XEXP (X, 0), 1)) == CONST_INT\t\t\\\n \t&& ! CONST_OK_FOR_K (INTVAL (XEXP (XEXP (X, 0), 1)))))\n-\f\n+\n+/* Given a comparison code (EQ, NE, etc.) and the first operand of a COMPARE,\n+   return the mode to be used for the comparison.\n+\n+   For floating-point equality comparisons, CCFPEQmode should be used.\n+   VOIDmode should be used in all other cases.\n+\n+   For integer comparisons against zero, reduce to CCNOmode or CCZmode if\n+   possible, to allow for more combinations.  */\n+\n+#define SELECT_CC_MODE(OP, X, Y)       v850_select_cc_mode (OP, X, Y)\n+\n /* Tell final.c how to eliminate redundant test instructions.  */\n \n /* Here we define machine-dependent flags and fields in cc_status\n@@ -889,22 +943,25 @@ typedef enum\n /* How to refer to registers in assembler output.\n    This sequence is indexed by compiler's hard-register-number (see above).  */\n \n-#define REGISTER_NAMES\t\t\t\t\t\t\t\\\n-{  \"r0\",  \"r1\",  \"r2\",  \"sp\",  \"gp\",  \"r5\",  \"r6\" , \"r7\",\t\t\\\n-   \"r8\",  \"r9\", \"r10\", \"r11\", \"r12\", \"r13\", \"r14\", \"r15\",\t\t\\\n-  \"r16\", \"r17\", \"r18\", \"r19\", \"r20\", \"r21\", \"r22\", \"r23\",\t\t\\\n-  \"r24\", \"r25\", \"r26\", \"r27\", \"r28\", \"r29\",  \"ep\", \"r31\",\t\t\\\n+#define REGISTER_NAMES                                         \\\n+{  \"r0\",  \"r1\",  \"r2\",  \"sp\",  \"gp\",  \"r5\",  \"r6\" , \"r7\",      \\\n+   \"r8\",  \"r9\", \"r10\", \"r11\", \"r12\", \"r13\", \"r14\", \"r15\",      \\\n+  \"r16\", \"r17\", \"r18\", \"r19\", \"r20\", \"r21\", \"r22\", \"r23\",      \\\n+  \"r24\", \"r25\", \"r26\", \"r27\", \"r28\", \"r29\",  \"ep\", \"r31\",      \\\n+  \"psw\", \"fcc\",      \\\n   \".fp\", \".ap\"}\n \n-#define ADDITIONAL_REGISTER_NAMES\t\t\t\t\t\\\n-{ { \"zero\",\t0 },\t\t\t\t\t\t\t\\\n-  { \"hp\",\t2 },\t\t\t\t\t\t\t\\\n-  { \"r3\",\t3 },\t\t\t\t\t\t\t\\\n-  { \"r4\",\t4 },\t\t\t\t\t\t\t\\\n-  { \"tp\",\t5 },\t\t\t\t\t\t\t\\\n-  { \"fp\",\t29 },\t\t\t\t\t\t\t\\\n-  { \"r30\",\t30 },\t\t\t\t\t\t\t\\\n-  { \"lp\",\t31} }\n+/* Register numbers */\n+\n+#define ADDITIONAL_REGISTER_NAMES              \\\n+{ { \"zero\",    ZERO_REGNUM },                  \\\n+  { \"hp\",      2 },                            \\\n+  { \"r3\",      3 },                            \\\n+  { \"r4\",      4 },                            \\\n+  { \"tp\",      5 },                            \\\n+  { \"fp\",      29 },                           \\\n+  { \"r30\",     30 },                           \\\n+  { \"lp\",      LP_REGNUM} }\n \n #define ASM_OUTPUT_REG_PUSH(FILE,REGNO)\n #define ASM_OUTPUT_REG_POP(FILE,REGNO)\n@@ -919,12 +976,13 @@ typedef enum\n \n /* Disable the shift, which is for the currently disabled \"switch\"\n    opcode.  Se casesi in v850.md.  */\n+\n #define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL) \t\t\\\n   fprintf (FILE, \"\\t%s %s.L%d-.L%d%s\\n\",\t\t\t\t\\\n \t   (TARGET_BIG_SWITCH ? \".long\" : \".short\"),\t\t\t\\\n-\t   (0 && ! TARGET_BIG_SWITCH && TARGET_V850E ? \"(\" : \"\"),\t\t\\\n+\t   (0 && ! TARGET_BIG_SWITCH && (TARGET_V850E || TARGET_V850E2_ALL) ? \"(\" : \"\"),             \\\n \t   VALUE, REL,\t\t\t\t\t\t\t\\\n-\t   (0 && ! TARGET_BIG_SWITCH && TARGET_V850E ? \")>>1\" : \"\"))\n+\t   (0 && ! TARGET_BIG_SWITCH && (TARGET_V850E || TARGET_V850E2_ALL) ? \")>>1\" : \"\"))\n \n #define ASM_OUTPUT_ALIGN(FILE, LOG)\t\\\n   if ((LOG) != 0)\t\t\t\\\n@@ -949,7 +1007,7 @@ typedef enum\n \n /* The switch instruction requires that the jump table immediately follow\n    it.  */\n-#define JUMP_TABLES_IN_TEXT_SECTION 1\n+#define JUMP_TABLES_IN_TEXT_SECTION (!TARGET_JUMP_TABLES_IN_DATA_SECTION)\n \n /* svr4.h defines this assuming that 4 byte alignment is required.  */\n #undef ASM_OUTPUT_BEFORE_CASE_LABEL\n@@ -1075,3 +1133,5 @@ extern union tree_node * GHS_current_section_names [(int) COUNT_OF_GHS_SECTION_K\n #define TARGET_ASM_INIT_SECTIONS v850_asm_init_sections\n \n #endif /* ! GCC_V850_H */\n+\n+"}, {"sha": "3a9485522deafc959bbeabf32c83df8127743a74", "filename": "gcc/config/v850/v850.md", "status": "modified", "additions": 1074, "deletions": 184, "changes": 1258, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/223a9d64453b03941bcd88e479c8047edffadc42/gcc%2Fconfig%2Fv850%2Fv850.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/223a9d64453b03941bcd88e479c8047edffadc42/gcc%2Fconfig%2Fv850%2Fv850.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.md?ref=223a9d64453b03941bcd88e479c8047edffadc42", "patch": "@@ -32,6 +32,21 @@\n \n ;; The size of instructions in bytes.\n \n+;;---------------------------------------------------------------------------\n+;; Constants\n+\n+;;\n+(define_constants\n+  [(ZERO_REGNUM            \t0)          ; constant zero\n+   (SP_REGNUM      \t\t3)          ; Stack Pointer\n+   (GP_REGNUM      \t\t4)          ; GP Pointer\n+   (EP_REGNUM      \t\t30)         ; EP pointer\n+   (LP_REGNUM       \t\t31)         ; Return address register\n+   (CC_REGNUM       \t\t32)         ; Condition code pseudo register\n+   (FCC_REGNUM      \t\t33)         ; Floating Condition code pseudo register\n+  ]\n+)\n+\n (define_attr \"length\" \"\"\n   (const_int 4))\n \n@@ -42,9 +57,22 @@\n \t    \n ;; Types of instructions (for scheduling purposes).\n \n-(define_attr \"type\" \"load,mult,other\"\n+(define_attr \"type\" \"load,store,bit1,mult,macc,div,fpu,single,other\"\n   (const_string \"other\"))\n \n+(define_attr \"cpu\" \"none,v850,v850e,v850e1,v850e2,v850e2v3\"\n+  (cond [(ne (symbol_ref \"TARGET_V850\") (const_int 0))\n+       (const_string \"v850\")\n+       (ne (symbol_ref \"TARGET_V850E\") (const_int 0))\n+       (const_string \"v850e\")\n+       (ne (symbol_ref \"TARGET_V850E1\") (const_int 0))\n+       (const_string \"v850e1\")\n+       (ne (symbol_ref \"TARGET_V850E2\") (const_int 0))\n+       (const_string \"v850e2\")\n+       (ne (symbol_ref \"TARGET_V850E2\") (const_int 0))\n+       (const_string \"v850e2v3\")]\n+       (const_string \"none\")))\n+\n ;; Condition code settings.\n ;; none - insn does not affect cc\n ;; none_0hit - insn does not affect cc but it does modify operand 0\n@@ -54,7 +82,7 @@\n ;; set_zn  - sets z,n to usable values; v,c is unknown.\n ;; compare - compare instruction\n ;; clobber - value of cc is unknown\n-(define_attr \"cc\" \"none,none_0hit,set_zn,set_znv,compare,clobber\"\n+(define_attr \"cc\" \"none,none_0hit,set_z,set_zn,set_znv,compare,clobber\"\n   (const_string \"clobber\"))\n \f\n ;; Function units for the V850.  As best as I can tell, there's\n@@ -76,7 +104,81 @@\n ;; ----------------------------------------------------------------------\n ;; MOVE INSTRUCTIONS\n ;; ----------------------------------------------------------------------\n+(define_insn \"sign23byte_load\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(sign_extend:SI\n+\t(mem:QI (plus:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t (match_operand 2 \"disp23_operand\" \"W\")))))]\n+  \"TARGET_V850E2V3\"\n+  \"ld.b %2[%1],%0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"none_0hit\")])\n+  \n+(define_insn \"unsign23byte_load\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(zero_extend:SI\n+\t(mem:QI (plus:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t (match_operand 2 \"disp23_operand\" \"W\")))))]\n+  \"TARGET_V850E2V3\"\n+  \"ld.bu %2[%1],%0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"none_0hit\")])\n+\n+(define_insn \"sign23hword_load\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(sign_extend:SI\n+\t(mem:HI (plus:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t (match_operand 2 \"disp23_operand\" \"W\")))))]\n+  \"TARGET_V850E2V3\"\n+  \"ld.h %2[%1],%0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"none_0hit\")])\n+\n+(define_insn \"unsign23hword_load\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(zero_extend:SI\n+\t(mem:HI (plus:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t (match_operand 2 \"disp23_operand\" \"W\")))))]\n+  \"TARGET_V850E2V3\"\n+  \"ld.hu %2[%1],%0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"none_0hit\")])\n \n+(define_insn \"23word_load\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(mem:SI (plus:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t (match_operand 2 \"disp23_operand\" \"W\"))))]\n+  \"TARGET_V850E2V3\"\n+  \"ld.w %2[%1],%0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"none_0hit\")])\n+\n+(define_insn \"23byte_store\"\n+  [(set (mem:QI (plus:SI (match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t\t (match_operand 1 \"disp23_operand\" \"W\")))\n+\t(match_operand:QI 2 \"register_operand\" \"r\"))]\n+  \"TARGET_V850E2V3\"\n+  \"st.b %2,%1[%0]\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"none_0hit\")])\n+\n+(define_insn \"23hword_store\"\n+  [(set (mem:HI (plus:SI (match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t\t (match_operand 1 \"disp23_operand\" \"W\")))\n+\t(match_operand:HI 2 \"register_operand\" \"r\"))]\n+  \"TARGET_V850E2V3\"\n+  \"st.h %2,%1[%0]\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"none_0hit\")])\n+\n+(define_insn \"23word_store\"\n+  [(set (mem:SI (plus:SI (match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t\t (match_operand 1 \"disp23_operand\" \"W\")))\n+\t(match_operand:SI 2 \"register_operand\" \"r\"))]\n+  \"TARGET_V850E2V3\"\n+  \"st.w %2,%1[%0]\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"none_0hit\")])\n ;; movqi\n \n (define_expand \"movqi\"\n@@ -99,7 +201,7 @@\n   \"* return output_move_single (operands);\"\n   [(set_attr \"length\" \"2,4,2,2,4,4,4\")\n    (set_attr \"cc\" \"none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit\")\n-   (set_attr \"type\" \"other,other,load,other,load,other,other\")])\n+   (set_attr \"type\" \"other,other,load,other,load,store,store\")])\n \n ;; movhi\n \n@@ -123,7 +225,7 @@\n   \"* return output_move_single (operands);\"\n   [(set_attr \"length\" \"2,4,2,2,4,4,4\")\n    (set_attr \"cc\" \"none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit\")\n-   (set_attr \"type\" \"other,other,load,other,load,other,other\")])\n+   (set_attr \"type\" \"other,other,load,other,load,store,store\")])\n \n ;; movsi and helpers\n \n@@ -161,7 +263,7 @@\n      must be done with HIGH & LO_SUM patterns.  */\n   if (CONSTANT_P (operands[1])\n       && GET_CODE (operands[1]) != HIGH\n-      && ! TARGET_V850E\n+      && ! (TARGET_V850E || TARGET_V850E2_ALL)\n       && !special_symbolref_operand (operands[1], VOIDmode)\n       && !(GET_CODE (operands[1]) == CONST_INT\n \t   && (CONST_OK_FOR_J (INTVAL (operands[1]))\n@@ -193,13 +295,13 @@\n (define_insn \"*movsi_internal_v850e\"\n   [(set (match_operand:SI 0 \"general_operand\" \"=r,r,r,r,Q,r,r,m,m,r\")\n \t(match_operand:SI 1 \"general_operand\" \"Jr,K,L,Q,Ir,m,R,r,I,i\"))]\n-  \"TARGET_V850E\n+  \"(TARGET_V850E || TARGET_V850E2_ALL)\n    && (register_operand (operands[0], SImode)\n        || reg_or_0_operand (operands[1], SImode))\"\n   \"* return output_move_single (operands);\"\n   [(set_attr \"length\" \"2,4,4,2,2,4,4,4,4,6\")\n    (set_attr \"cc\" \"none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit\")\n-   (set_attr \"type\" \"other,other,other,load,other,load,other,other,other,other\")])\n+   (set_attr \"type\" \"other,other,other,load,other,load,other,store,store,other\")])\n \n (define_insn \"*movsi_internal\"\n   [(set (match_operand:SI 0 \"general_operand\" \"=r,r,r,r,Q,r,r,m,m\")\n@@ -209,7 +311,7 @@\n   \"* return output_move_single (operands);\"\n   [(set_attr \"length\" \"2,4,4,2,2,4,4,4,4\")\n    (set_attr \"cc\" \"none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit\")\n-   (set_attr \"type\" \"other,other,other,load,other,load,other,other,other\")])\n+   (set_attr \"type\" \"other,other,other,load,other,load,store,store,other\")])\n \n (define_insn \"*movsf_internal\"\n   [(set (match_operand:SF 0 \"general_operand\" \"=r,r,r,r,r,Q,r,m,m,r\")\n@@ -219,9 +321,8 @@\n   \"* return output_move_single (operands);\"\n   [(set_attr \"length\" \"2,4,4,8,2,2,4,4,4,8\")\n    (set_attr \"cc\" \"none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit\")\n-   (set_attr \"type\" \"other,other,other,other,load,other,load,other,other,other\")])\n+   (set_attr \"type\" \"other,other,other,other,load,other,load,store,store,other\")])\n \n-\f\n ;; ----------------------------------------------------------------------\n ;; TEST INSTRUCTIONS\n ;; ----------------------------------------------------------------------\n@@ -273,27 +374,63 @@\n \t\t\t\t\t\t\t    (const_int 0)]))]\n   \"\")\n \n-(define_insn \"*cmpsi\"\n+(define_expand \"cmpsi\"\n   [(set (cc0)\n-\t(compare (match_operand:SI 0 \"register_operand\" \"r,r,r\")\n-\t\t (match_operand:SI 1 \"reg_or_int5_operand\" \"r,I,J\")))]\n+\t(compare (match_operand:SI 0 \"register_operand\" \"r,r\")\n+\t\t (match_operand:SI 1 \"reg_or_int5_operand\" \"r,J\")))]\n+   \"\"\n+  \"\n+{\n+  v850_compare_op0 = operands[0];\n+  v850_compare_op1 = operands[1];\n+  DONE;\n+}\")\n+\n+(define_insn \"cmpsi_insn\"\n+  [(set (cc0)\n+\t(compare (match_operand:SI 0 \"register_operand\" \"r,r\")\n+\t\t (match_operand:SI 1 \"reg_or_int5_operand\" \"r,J\")))]\n   \"\"\n   \"@\n   cmp %1,%0\n-  cmp %.,%0\n   cmp %1,%0\"\n-  [(set_attr \"length\" \"2,2,2\")\n-   (set_attr \"cc\" \"compare,set_znv,compare\")])\n+  [(set_attr \"length\" \"2,2\")\n+   (set_attr \"cc\" \"compare\")])\n+\n+(define_expand \"cmpsf\"\n+  [(set (reg:CC CC_REGNUM)\n+\t(compare (match_operand:SF 0 \"register_operand\" \"r\")\n+\t\t (match_operand:SF 1 \"register_operand\" \"r\")))]\n+  \"TARGET_V850E2V3\"\n+  \"\n+{\n+  v850_compare_op0 = operands[0];\n+  v850_compare_op1 = operands[1];\n+  DONE;\n+}\")\n+\n+(define_expand \"cmpdf\"\n+  [(set (reg:CC CC_REGNUM)\n+\t(compare (match_operand:DF 0 \"even_reg_operand\" \"r\")\n+\t\t (match_operand:DF 1 \"even_reg_operand\" \"r\")))]\n+  \"TARGET_V850E2V3\"\n+  \"\n+{\n+  v850_compare_op0 = operands[0];\n+  v850_compare_op1 = operands[1];\n+  DONE;\n+}\")\n \n-\f\n ;; ----------------------------------------------------------------------\n ;; ADD INSTRUCTIONS\n ;; ----------------------------------------------------------------------\n \n (define_insn \"addsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r\")\n \t(plus:SI (match_operand:SI 1 \"register_operand\" \"%0,r,r\")\n-\t\t (match_operand:SI 2 \"nonmemory_operand\" \"rJ,K,U\")))]\n+\t\t (match_operand:SI 2 \"nonmemory_operand\" \"rJ,K,U\")))\n+   (clobber (reg:CC CC_REGNUM))]\n+\n   \"\"\n   \"@\n    add %2,%0\n@@ -309,17 +446,19 @@\n (define_insn \"subsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n \t(minus:SI (match_operand:SI 1 \"register_operand\" \"0,r\")\n-\t\t  (match_operand:SI 2 \"register_operand\" \"r,0\")))]\n+\t\t  (match_operand:SI 2 \"register_operand\" \"r,0\")))\n+   (clobber (reg:CC CC_REGNUM))]\n   \"\"\n   \"@\n   sub %2,%0\n   subr %1,%0\"\n   [(set_attr \"length\" \"2,2\")\n-   (set_attr \"cc\" \"set_zn\")])\n+   (set_attr \"cc\" \"set_zn,set_zn\")])\n \n (define_insn \"negsi2\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-        (neg:SI (match_operand:SI 1 \"register_operand\" \"0\")))]\n+\t(neg:SI (match_operand:SI 1 \"register_operand\" \"0\")))\n+   (clobber (reg:CC CC_REGNUM))]\n   \"\"\n   \"subr %.,%0\"\n   [(set_attr \"length\" \"2\")\n@@ -379,7 +518,7 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(mult:SI (match_operand:SI 1 \"register_operand\" \"%0\")\n \t\t (match_operand:SI 2 \"reg_or_int9_operand\" \"rO\")))]\n-  \"TARGET_V850E\"\n+  \"(TARGET_V850E || TARGET_V850E2_ALL)\"\n   \"mul %2,%1,%.\"\n   [(set_attr \"length\" \"4\")\n    (set_attr \"cc\" \"none_0hit\")\n@@ -401,25 +540,27 @@\n \t\t(match_operand:SI 2 \"register_operand\" \"r\")))\n    (set (match_operand:SI 3 \"register_operand\" \"=r\")\n \t(mod:SI (match_dup 1)\n-\t\t(match_dup 2)))]\n+\t\t(match_dup 2)))\n+   (clobber (reg:CC CC_REGNUM))]\n   \"TARGET_V850E\"\n   \"div %2,%0,%3\"\n   [(set_attr \"length\" \"4\")\n    (set_attr \"cc\" \"clobber\")\n-   (set_attr \"type\" \"other\")])\n+   (set_attr \"type\" \"div\")])\n \t\n (define_insn \"udivmodsi4\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(udiv:SI (match_operand:SI 1 \"register_operand\" \"0\")\n \t\t (match_operand:SI 2 \"register_operand\" \"r\")))\n    (set (match_operand:SI 3 \"register_operand\" \"=r\")\n \t(umod:SI (match_dup 1)\n-\t\t (match_dup 2)))]\n+\t\t (match_dup 2)))\n+   (clobber (reg:CC CC_REGNUM))]\n   \"TARGET_V850E\"\n   \"divu %2,%0,%3\"\n   [(set_attr \"length\" \"4\")\n    (set_attr \"cc\" \"clobber\")\n-   (set_attr \"type\" \"other\")])\n+   (set_attr \"type\" \"div\")])\n \t\n ;; ??? There is a 2 byte instruction for generating only the quotient.\n ;; However, it isn't clear how to compute the length field correctly.\n@@ -430,12 +571,13 @@\n \t\t(match_operand:HI 2 \"register_operand\" \"r\")))\n    (set (match_operand:HI 3 \"register_operand\" \"=r\")\n \t(mod:HI (match_dup 1)\n-\t\t(match_dup 2)))]\n+\t\t(match_dup 2)))\n+   (clobber (reg:CC CC_REGNUM))]\n   \"TARGET_V850E\"\n   \"divh %2,%0,%3\"\n   [(set_attr \"length\" \"4\")\n    (set_attr \"cc\" \"clobber\")\n-   (set_attr \"type\" \"other\")])\n+   (set_attr \"type\" \"div\")])\n \n ;; Half-words are sign-extended by default, so we must zero extend to a word\n ;; here before doing the divide.\n@@ -446,12 +588,13 @@\n \t\t (match_operand:HI 2 \"register_operand\" \"r\")))\n    (set (match_operand:HI 3 \"register_operand\" \"=r\")\n \t(umod:HI (match_dup 1)\n-\t\t (match_dup 2)))]\n+\t\t (match_dup 2)))\n+   (clobber (reg:CC CC_REGNUM))]\n   \"TARGET_V850E\"\n   \"zxh %0 ; divhu %2,%0,%3\"\n   [(set_attr \"length\" \"4\")\n    (set_attr \"cc\" \"clobber\")\n-   (set_attr \"type\" \"other\")])\n+   (set_attr \"type\" \"div\")])\n \f\n ;; ----------------------------------------------------------------------\n ;; AND INSTRUCTIONS\n@@ -461,7 +604,8 @@\n   [(set (match_operand:QI 0 \"memory_operand\" \"=m\")\n \t(subreg:QI\n \t  (and:SI (subreg:SI (match_dup 0) 0)\n-\t\t  (match_operand:QI 1 \"not_power_of_two_operand\" \"\")) 0))]\n+\t\t  (match_operand:QI 1 \"not_power_of_two_operand\" \"\")) 0))\n+   (clobber (reg:CC CC_REGNUM))]\n   \"\"\n   \"*\n {\n@@ -472,13 +616,15 @@\n   return \\\"\\\";\n }\"\n   [(set_attr \"length\" \"4\")\n-   (set_attr \"cc\" \"clobber\")])\n+   (set_attr \"cc\" \"clobber\")\n+   (set_attr \"type\" \"bit1\")])\n \n (define_insn \"*v850_clr1_2\"\n   [(set (match_operand:HI 0 \"indirect_operand\" \"=m\")\n \t(subreg:HI\n \t  (and:SI (subreg:SI (match_dup 0) 0)\n-\t\t  (match_operand:HI 1 \"not_power_of_two_operand\" \"\")) 0))]\n+\t\t  (match_operand:HI 1 \"not_power_of_two_operand\" \"\")) 0))\n+   (clobber (reg:CC CC_REGNUM))]\n   \"\"\n   \"*\n {\n@@ -492,12 +638,14 @@\n   return \\\"\\\";\n }\"\n   [(set_attr \"length\" \"4\")\n-   (set_attr \"cc\" \"clobber\")])\n+   (set_attr \"cc\" \"clobber\")\n+   (set_attr \"type\" \"bit1\")])\n \n (define_insn \"*v850_clr1_3\"\n   [(set (match_operand:SI 0 \"indirect_operand\" \"=m\")\n \t(and:SI (match_dup 0)\n-\t\t(match_operand:SI 1 \"not_power_of_two_operand\" \"\")))]\n+\t\t(match_operand:SI 1 \"not_power_of_two_operand\" \"\")))\n+   (clobber (reg:CC CC_REGNUM))]\n   \"\"\n   \"*\n {\n@@ -511,19 +659,21 @@\n   return \\\"\\\";\n }\"\n   [(set_attr \"length\" \"4\")\n-   (set_attr \"cc\" \"clobber\")])\n+   (set_attr \"cc\" \"clobber\")\n+   (set_attr \"type\" \"bit1\")])\n \n (define_insn \"andsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r\")\n \t(and:SI (match_operand:SI 1 \"register_operand\" \"%0,0,r\")\n-\t\t(match_operand:SI 2 \"nonmemory_operand\" \"r,I,M\")))]\n+\t\t(match_operand:SI 2 \"nonmemory_operand\" \"r,I,M\")))\n+   (clobber (reg:CC CC_REGNUM))]\n   \"\"\n   \"@\n   and %2,%0\n   and %.,%0\n   andi %2,%1,%0\"\n   [(set_attr \"length\" \"2,2,4\")\n-   (set_attr \"cc\" \"set_znv\")])\n+   (set_attr \"cc\" \"set_zn\")])\n \n ;; ----------------------------------------------------------------------\n ;; OR INSTRUCTIONS\n@@ -532,11 +682,13 @@\n (define_insn \"*v850_set1_1\"\n   [(set (match_operand:QI 0 \"memory_operand\" \"=m\")\n \t(subreg:QI (ior:SI (subreg:SI (match_dup 0) 0)\n-\t\t\t   (match_operand 1 \"power_of_two_operand\" \"\")) 0))]\n+\t\t\t   (match_operand 1 \"power_of_two_operand\" \"\")) 0))\n+   (clobber (reg:CC CC_REGNUM))]\n   \"\"\n   \"set1 %M1,%0\"\n   [(set_attr \"length\" \"4\")\n-   (set_attr \"cc\" \"clobber\")])\n+   (set_attr \"cc\" \"clobber\")\n+   (set_attr \"type\" \"bit1\")])\n \n (define_insn \"*v850_set1_2\"\n   [(set (match_operand:HI 0 \"indirect_operand\" \"=m\")\n@@ -561,12 +713,14 @@\n   return \\\"\\\";\n }\"\n   [(set_attr \"length\" \"4\")\n-   (set_attr \"cc\" \"clobber\")])\n+   (set_attr \"cc\" \"clobber\")\n+   (set_attr \"type\" \"bit1\")])\n \n (define_insn \"*v850_set1_3\"\n   [(set (match_operand:SI 0 \"indirect_operand\" \"=m\")\n \t(ior:SI (match_dup 0)\n-\t\t(match_operand 1 \"power_of_two_operand\" \"\")))]\n+\t\t(match_operand 1 \"power_of_two_operand\" \"\")))\n+   (clobber (reg:CC CC_REGNUM))]\n   \"\"\n   \"*\n {\n@@ -586,19 +740,21 @@\n   return \\\"\\\";\n }\"\n   [(set_attr \"length\" \"4\")\n-   (set_attr \"cc\" \"clobber\")])\n+   (set_attr \"cc\" \"clobber\")\n+   (set_attr \"type\" \"bit1\")])\n \n (define_insn \"iorsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r\")\n \t(ior:SI (match_operand:SI 1 \"register_operand\" \"%0,0,r\")\n-\t\t(match_operand:SI 2 \"nonmemory_operand\" \"r,I,M\")))]\n+\t\t(match_operand:SI 2 \"nonmemory_operand\" \"r,I,M\")))\n+   (clobber (reg:CC CC_REGNUM))]\n   \"\"\n   \"@\n   or %2,%0\n   or %.,%0\n   ori %2,%1,%0\"\n   [(set_attr \"length\" \"2,2,4\")\n-   (set_attr \"cc\" \"set_znv\")])\n+   (set_attr \"cc\" \"set_zn\")])\n \n ;; ----------------------------------------------------------------------\n ;; XOR INSTRUCTIONS\n@@ -607,11 +763,13 @@\n (define_insn \"*v850_not1_1\"\n   [(set (match_operand:QI 0 \"memory_operand\" \"=m\")\n \t(subreg:QI (xor:SI (subreg:SI (match_dup 0) 0)\n-\t\t\t   (match_operand 1 \"power_of_two_operand\" \"\")) 0))]\n+\t\t\t   (match_operand 1 \"power_of_two_operand\" \"\")) 0))\n+   (clobber (reg:CC CC_REGNUM))]\n   \"\"\n   \"not1 %M1,%0\"\n   [(set_attr \"length\" \"4\")\n-   (set_attr \"cc\" \"clobber\")])\n+   (set_attr \"cc\" \"clobber\")\n+   (set_attr \"type\" \"bit1\")])\n \n (define_insn \"*v850_not1_2\"\n   [(set (match_operand:HI 0 \"indirect_operand\" \"=m\")\n@@ -636,12 +794,14 @@\n   return \\\"\\\";\n }\"\n   [(set_attr \"length\" \"4\")\n-   (set_attr \"cc\" \"clobber\")])\n+   (set_attr \"cc\" \"clobber\")\n+   (set_attr \"type\" \"bit1\")])\n \n (define_insn \"*v850_not1_3\"\n   [(set (match_operand:SI 0 \"indirect_operand\" \"=m\")\n \t(xor:SI (match_dup 0)\n-\t\t(match_operand 1 \"power_of_two_operand\" \"\")))]\n+\t\t(match_operand 1 \"power_of_two_operand\" \"\")))\n+   (clobber (reg:CC CC_REGNUM))]\n   \"\"\n   \"*\n {\n@@ -661,32 +821,35 @@\n   return \\\"\\\";\n }\"\n   [(set_attr \"length\" \"4\")\n-   (set_attr \"cc\" \"clobber\")])\n+   (set_attr \"cc\" \"clobber\")\n+   (set_attr \"type\" \"bit1\")])\n \n (define_insn \"xorsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r\")\n \t(xor:SI (match_operand:SI 1 \"register_operand\" \"%0,0,r\")\n-\t\t(match_operand:SI 2 \"nonmemory_operand\" \"r,I,M\")))]\n+\t\t(match_operand:SI 2 \"nonmemory_operand\" \"r,I,M\")))\n+   (clobber (reg:CC CC_REGNUM))]\n   \"\"\n   \"@\n   xor %2,%0\n   xor %.,%0\n   xori %2,%1,%0\"\n   [(set_attr \"length\" \"2,2,4\")\n-   (set_attr \"cc\" \"set_znv\")])\n+   (set_attr \"cc\" \"set_zn\")])\n \f\n ;; ----------------------------------------------------------------------\n ;; NOT INSTRUCTIONS\n ;; ----------------------------------------------------------------------\n \n (define_insn \"one_cmplsi2\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(not:SI (match_operand:SI 1 \"register_operand\" \"r\")))]\n+\t(not:SI (match_operand:SI 1 \"register_operand\" \"r\")))\n+   (clobber (reg:CC CC_REGNUM))]\n   \"\"\n   \"not %1,%0\"\n   [(set_attr \"length\" \"2\")\n-   (set_attr \"cc\" \"set_znv\")])\n-\f\n+   (set_attr \"cc\" \"set_zn\")])\n+\n ;; -----------------------------------------------------------------\n ;; BIT FIELDS\n ;; -----------------------------------------------------------------\n@@ -724,6 +887,31 @@\n   [(set_attr \"length\" \"4\")\n    (set_attr \"cc\" \"none_0hit\")])\n \n+(define_insn \"setf_insn\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(match_operator:SI 1 \"comparison_operator\"\n+                          [(reg:CC CC_REGNUM) (const_int 0)]))]\n+  \"\"\n+  \"setf %b1,%0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"none_0hit\")])\n+\n+(define_insn \"set_z_insn\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(match_operand 1 \"v850_float_z_comparison_operator\" \"\"))]\n+  \"TARGET_V850E2V3\"\n+  \"setf z,%0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"none_0hit\")])\n+\n+(define_insn \"set_nz_insn\" \n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(match_operand 1 \"v850_float_nz_comparison_operator\" \"\"))]\n+  \"TARGET_V850E2V3\"\n+  \"setf nz,%0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"none_0hit\")])\n+\n ;; ----------------------------------------------------------------------\n ;; CONDITIONAL MOVE INSTRUCTIONS\n ;; ----------------------------------------------------------------------\n@@ -738,7 +926,7 @@\n \t (match_operand 1 \"comparison_operator\")\n \t (match_operand:SI 2 \"reg_or_const_operand\" \"rJ\")\n \t (match_operand:SI 3 \"reg_or_const_operand\" \"rI\")))]\n-  \"TARGET_V850E\"\n+  \"(TARGET_V850E || TARGET_V850E2_ALL)\"\n   \"\n {\n   if (   (GET_CODE (operands[2]) == CONST_INT\n@@ -775,6 +963,30 @@\n ;; condition codes may have already been set by an earlier instruction,\n ;; but we have no code here to avoid the compare if it is unnecessary.\n \n+(define_insn \"movsicc_normal_cc\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+        (if_then_else:SI\n+         (match_operator 1 \"comparison_operator\"\n+                         [(reg:CC CC_REGNUM) (const_int 0)])\n+         (match_operand:SI 2 \"reg_or_int5_operand\" \"rJ\")\n+         (match_operand:SI 3 \"reg_or_0_operand\" \"rI\")))]\n+  \"(TARGET_V850E || TARGET_V850E2_ALL)\"\n+  \"cmov %c1,%2,%z3,%0\";\n+  [(set_attr \"length\" \"6\")\n+   (set_attr \"cc\" \"compare\")])\n+\n+(define_insn \"movsicc_reversed_cc\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+        (if_then_else:SI\n+         (match_operator 1 \"comparison_operator\"\n+                         [(reg:CC CC_REGNUM) (const_int 0)])\n+         (match_operand:SI 2 \"reg_or_0_operand\" \"rI\")\n+         (match_operand:SI 3 \"reg_or_int5_operand\" \"rJ\")))]\n+  \"(TARGET_V850E || TARGET_V850E2_ALL)\"\n+  \"cmov %C1,%3,%z2,%0\"\n+  [(set_attr \"length\" \"6\")\n+   (set_attr \"cc\" \"compare\")])\n+\n (define_insn \"*movsicc_normal\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(if_then_else:SI\n@@ -783,7 +995,7 @@\n \t\t\t  (match_operand:SI 5 \"reg_or_int5_operand\" \"rJ\")])\n \t (match_operand:SI 2 \"reg_or_int5_operand\" \"rJ\")\n \t (match_operand:SI 3 \"reg_or_0_operand\" \"rI\")))]\n-  \"TARGET_V850E\"\n+  \"(TARGET_V850E || TARGET_V850E2_ALL)\"\n   \"cmp %5,%4 ; cmov %c1,%2,%z3,%0\"\n   [(set_attr \"length\" \"6\")\n    (set_attr \"cc\" \"clobber\")])\n@@ -796,7 +1008,7 @@\n \t\t\t  (match_operand:SI 5 \"reg_or_int5_operand\" \"rJ\")])\n \t (match_operand:SI 2 \"reg_or_0_operand\" \"rI\")\n \t (match_operand:SI 3 \"reg_or_int5_operand\" \"rJ\")))]\n-  \"TARGET_V850E\"\n+  \"(TARGET_V850E || TARGET_V850E2_ALL)\"\n   \"cmp %5,%4 ; cmov %C1,%3,%z2,%0\"\n   [(set_attr \"length\" \"6\")\n    (set_attr \"cc\" \"clobber\")])\n@@ -812,7 +1024,7 @@\n \t\t\t  (const_int 0)])\n \t (match_operand:SI 4 \"reg_or_int5_operand\" \"rJ\")\n \t (match_operand:SI 5 \"reg_or_0_operand\" \"rI\")))]\n-  \"TARGET_V850E\"\n+  \"(TARGET_V850E || TARGET_V850E2_ALL)\"\n   \"tst1 %3,%2 ; cmov %c1,%4,%z5,%0\"\n   [(set_attr \"length\" \"8\")\n    (set_attr \"cc\" \"clobber\")])\n@@ -828,7 +1040,7 @@\n \t\t\t  (const_int 0)])\n \t (match_operand:SI 4 \"reg_or_0_operand\" \"rI\")\n \t (match_operand:SI 5 \"reg_or_int5_operand\" \"rJ\")))]\n-  \"TARGET_V850E\"\n+  \"(TARGET_V850E || TARGET_V850E2_ALL)\"\n   \"tst1 %3,%2 ; cmov %C1,%5,%z4,%0\"\n   [(set_attr \"length\" \"8\")\n    (set_attr \"cc\" \"clobber\")])\n@@ -838,23 +1050,16 @@\n ;; second pattern by subsequent combining.  As above, we must include the\n ;; comparison to avoid input reloads in an insn using cc0.\n \n-(define_insn \"*sasf_1\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(ior:SI (match_operator 1 \"comparison_operator\" [(cc0) (const_int 0)])\n-\t\t(ashift:SI (match_operand:SI 2 \"register_operand\" \"\")\n-\t\t\t   (const_int 1))))]\n-  \"TARGET_V850E\"\n-  \"* gcc_unreachable ();\")\n-\n-(define_insn \"*sasf_2\"\n+(define_insn \"*sasf\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(ior:SI\n \t (match_operator 1 \"comparison_operator\"\n \t\t\t [(match_operand:SI 3 \"register_operand\" \"r\")\n \t\t\t  (match_operand:SI 4 \"reg_or_int5_operand\" \"rJ\")])\n \t (ashift:SI (match_operand:SI 2 \"register_operand\" \"0\")\n-\t\t    (const_int 1))))]\n-  \"TARGET_V850E\"\n+\t\t    (const_int 1))))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"(TARGET_V850E || TARGET_V850E2_ALL)\"\n   \"cmp %4,%3 ; sasf %c1,%0\"\n   [(set_attr \"length\" \"6\")\n    (set_attr \"cc\" \"clobber\")])\n@@ -866,17 +1071,19 @@\n \t\t\t [(match_operand:SI 4 \"register_operand\" \"\")\n \t\t\t  (match_operand:SI 5 \"reg_or_int5_operand\" \"\")])\n \t (match_operand:SI 2 \"const_int_operand\" \"\")\n-\t (match_operand:SI 3 \"const_int_operand\" \"\")))]\n-  \"TARGET_V850E\n+\t (match_operand:SI 3 \"const_int_operand\" \"\")))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"(TARGET_V850E || TARGET_V850E2_ALL)\n    && ((INTVAL (operands[2]) ^ INTVAL (operands[3])) == 1)\n    && ((INTVAL (operands[2]) + INTVAL (operands[3])) != 1)\n    && (GET_CODE (operands[5]) == CONST_INT\n       || REGNO (operands[0]) != REGNO (operands[5]))\n    && REGNO (operands[0]) != REGNO (operands[4])\"\n   [(set (match_dup 0) (match_dup 6))\n-   (set (match_dup 0)\n-\t(ior:SI (match_op_dup 7 [(match_dup 4) (match_dup 5)])\n-\t\t(ashift:SI (match_dup 0) (const_int 1))))]\n+   (parallel [(set (match_dup 0)\n+\t\t   (ior:SI (match_op_dup 7 [(match_dup 4) (match_dup 5)])\n+\t\t\t   (ashift:SI (match_dup 0) (const_int 1))))\n+\t      (clobber (reg:CC CC_REGNUM))])]\n   \"\n {\n   operands[6] = GEN_INT (INTVAL (operands[2]) >> 1);\n@@ -887,15 +1094,16 @@\n \t\t\t\t  GET_MODE (operands[1]),\n \t\t\t\t  XEXP (operands[1], 0), XEXP (operands[1], 1));\n }\")\n+\n ;; ---------------------------------------------------------------------\n ;; BYTE SWAP INSTRUCTIONS\n ;; ---------------------------------------------------------------------\n-\n (define_expand \"rotlhi3\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"\")\n-\t(rotate:HI (match_operand:HI 1 \"register_operand\" \"\")\n-\t\t   (match_operand:HI 2 \"const_int_operand\" \"\")))]\n-  \"TARGET_V850E\"\n+  [(parallel [(set (match_operand:HI 0 \"register_operand\" \"\")\n+\t\t   (rotate:HI (match_operand:HI 1 \"register_operand\" \"\")\n+\t\t\t      (match_operand:HI 2 \"const_int_operand\" \"\")))\n+\t      (clobber (reg:CC CC_REGNUM))])]\n+  \"(TARGET_V850E || TARGET_V850E2_ALL)\"\n   \"\n {\n   if (INTVAL (operands[2]) != 8)\n@@ -905,17 +1113,19 @@\n (define_insn \"*rotlhi3_8\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n \t(rotate:HI (match_operand:HI 1 \"register_operand\" \"r\")\n-\t\t   (const_int 8)))]\n-  \"TARGET_V850E\"\n+\t\t   (const_int 8)))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"(TARGET_V850E || TARGET_V850E2_ALL)\"\n   \"bsh %1,%0\"\n   [(set_attr \"length\" \"4\")\n    (set_attr \"cc\" \"clobber\")])\n \n (define_expand \"rotlsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(rotate:SI (match_operand:SI 1 \"register_operand\" \"\")\n-\t\t   (match_operand:SI 2 \"const_int_operand\" \"\")))]\n-  \"TARGET_V850E\"\n+  [(parallel [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t\t   (rotate:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t\t      (match_operand:SI 2 \"const_int_operand\" \"\")))\n+\t      (clobber (reg:CC CC_REGNUM))])]\n+  \"(TARGET_V850E || TARGET_V850E2_ALL)\"\n   \"\n {\n   if (INTVAL (operands[2]) != 16)\n@@ -925,12 +1135,13 @@\n (define_insn \"*rotlsi3_16\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(rotate:SI (match_operand:SI 1 \"register_operand\" \"r\")\n-\t\t   (const_int 16)))]\n-  \"TARGET_V850E\"\n+\t\t   (const_int 16)))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"(TARGET_V850E || TARGET_V850E2_ALL)\"\n   \"hsw %1,%0\"\n   [(set_attr \"length\" \"4\")\n    (set_attr \"cc\" \"clobber\")])\n-\f\n+\n ;; ----------------------------------------------------------------------\n ;; JUMP INSTRUCTIONS\n ;; ----------------------------------------------------------------------\n@@ -992,6 +1203,86 @@\n \t\t  (const_int 6)))\n   (set_attr \"cc\" \"none\")])\n \n+(define_insn \"branch_z_normal\"\t\n+  [(set (pc)\n+\t(if_then_else (match_operand 1 \"v850_float_z_comparison_operator\" \"\")\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"TARGET_V850E2V3\"\n+  \"*\n+{\n+  if (get_attr_length (insn) == 2)\n+    return \\\"bz %l0\\\";\n+  else\n+    return \\\"bnz 1f ; jr %l0 ; 1:\\\";\n+}\"\n+ [(set (attr \"length\")\n+    (if_then_else (lt (abs (minus (match_dup 0) (pc)))\n+\t\t      (const_int 256))\n+\t\t  (const_int 2)\n+\t\t  (const_int 6)))\n+  (set_attr \"cc\" \"none\")])\n+\n+(define_insn \"*branch_z_invert\"\n+  [(set (pc)\n+\t(if_then_else (match_operand 1 \"v850_float_z_comparison_operator\" \"\")\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"TARGET_V850E2V3\"\n+  \"*\n+{\n+  if (get_attr_length (insn) == 2)\n+    return \\\"bnz %l0\\\";\n+  else\n+    return \\\"bz 1f ; jr %l0 ; 1:\\\";\n+}\"\n+ [(set (attr \"length\")\n+    (if_then_else (lt (abs (minus (match_dup 0) (pc)))\n+\t\t\t   (const_int 256))\n+\t\t  (const_int 2)\n+\t\t  (const_int 6)))\n+  (set_attr \"cc\" \"none\")])\n+\n+(define_insn \"branch_nz_normal\"\n+  [(set (pc)\n+\t(if_then_else (match_operand 1 \"v850_float_nz_comparison_operator\" \"\")\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"TARGET_V850E2V3\"\n+  \"*\n+{\n+  if (get_attr_length (insn) == 2)\n+    return \\\"bnz %l0\\\";\n+  else\n+    return \\\"bz 1f ; jr %l0 ; 1:\\\";\n+}\"\n+[(set (attr \"length\")\n+    (if_then_else (lt (abs (minus (match_dup 0) (pc)))\n+\t\t\t   (const_int 256))\n+\t\t  (const_int 2)\n+\t\t  (const_int 6)))\n+  (set_attr \"cc\" \"none\")])\n+\n+(define_insn \"*branch_nz_invert\"\n+  [(set (pc)\n+\t(if_then_else (match_operand 1 \"v850_float_nz_comparison_operator\" \"\")\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"TARGET_V850E2V3\"\n+  \"*\n+{\n+  if (get_attr_length (insn) == 2)\n+    return \\\"bz %l0\\\";\n+  else\n+    return \\\"bnz 1f ; jr %l0 ; 1:\\\";\n+}\"\n+ [(set (attr \"length\")\n+    (if_then_else (lt (abs (minus (match_dup 0) (pc)))\n+\t\t      (const_int 256))\n+\t\t  (const_int 2)\n+\t\t  (const_int 6)))\n+  (set_attr \"cc\" \"none\")])\n+\n ;; Unconditional and other jump instructions.\n \n (define_insn \"jump\"\n@@ -1000,7 +1291,7 @@\n   \"\"\n   \"*\n {\n-  if (get_attr_length (insn) == 2)\n+ if (get_attr_length (insn) == 2)\n     return \\\"br %0\\\";\n   else\n     return \\\"jr %0\\\";\n@@ -1031,12 +1322,12 @@\n   [(set (pc)\n \t(plus:SI\n \t (sign_extend:SI\n-\t  (mem:HI\n-\t   (plus:SI (ashift:SI (match_operand:SI 0 \"register_operand\" \"r\")\n-\t\t\t       (const_int 1))\n-\t\t    (label_ref (match_operand 1 \"\" \"\")))))\n-\t (label_ref (match_dup 1))))]\n-  \"TARGET_V850E\"\n+\t (mem:HI\n+\t  (plus:SI (ashift:SI (match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t\t      (const_int 1))\n+\t\t   (label_ref (match_operand 1 \"\" \"\")))))\n+\t(label_ref (match_dup 1))))]\n+  \"(TARGET_V850E || TARGET_V850E2_ALL)\"\n   \"switch %0\"\n   [(set_attr \"length\" \"2\")\n    (set_attr \"cc\" \"none\")])\n@@ -1113,7 +1404,8 @@\n   \"@\n   jarl %0,r31\n   jarl .+4,r31 ; add 4,r31 ; jmp %0\"\n-  [(set_attr \"length\" \"4,8\")]\n+  [(set_attr \"length\" \"4,8\")\n+   (set_attr \"cc\" \"clobber,clobber\")]\n )\n \n (define_insn \"call_internal_long\"\n@@ -1133,7 +1425,8 @@\n   else\n     return \\\"jarl .+4,r31 ; add 4,r31 ; jmp %0\\\";\n   }\"\n-  [(set_attr \"length\" \"16,8\")]\n+  [(set_attr \"length\" \"16,8\")\n+   (set_attr \"cc\" \"clobber,clobber\")]\n )\n \n ;; Call subroutine, returning value in operand 0\n@@ -1169,7 +1462,8 @@\n   \"@\n   jarl %1,r31\n   jarl .+4,r31 ; add 4,r31 ; jmp %1\"\n-  [(set_attr \"length\" \"4,8\")]\n+  [(set_attr \"length\" \"4,8\")\n+   (set_attr \"cc\" \"clobber,clobber\")]\n )\n \n (define_insn \"call_value_internal_long\"\n@@ -1191,7 +1485,8 @@\n   else\n     return \\\"jarl .+4, r31 ; add 4, r31 ; jmp %1\\\";\n   }\"\n-  [(set_attr \"length\" \"16,8\")]\n+  [(set_attr \"length\" \"16,8\")\n+   (set_attr \"cc\" \"clobber,clobber\")]\n )\n \n (define_insn \"nop\"\n@@ -1208,55 +1503,60 @@\n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r,r\")\n \t(zero_extend:SI\n-\t (match_operand:HI 1 \"nonimmediate_operand\" \"0,r,T,m\")))]\n-  \"TARGET_V850E\"\n+        (match_operand:HI 1 \"nonimmediate_operand\" \"0,r,T,m\")))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"(TARGET_V850E || TARGET_V850E2_ALL)\"\n   \"@\n    zxh %0\n    andi 65535,%1,%0\n    sld.hu %1,%0\n    ld.hu %1,%0\"\n   [(set_attr \"length\" \"2,4,2,4\")\n-   (set_attr \"cc\" \"none_0hit,set_znv,none_0hit,none_0hit\")])\n+   (set_attr \"cc\" \"none_0hit,set_zn,none_0hit,none_0hit\")])\n \n (define_insn \"zero_extendhisi2\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(zero_extend:SI\n-\t (match_operand:HI 1 \"register_operand\" \"r\")))]\n+\t(match_operand:HI 1 \"register_operand\" \"r\")))\n+   (clobber (reg:CC CC_REGNUM))]\n   \"\"\n   \"andi 65535,%1,%0\"\n   [(set_attr \"length\" \"4\")\n-   (set_attr \"cc\" \"set_znv\")])\n+   (set_attr \"cc\" \"set_zn\")])\n \n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r,r\")\n \t(zero_extend:SI\n-\t (match_operand:QI 1 \"nonimmediate_operand\" \"0,r,T,m\")))]\n-  \"TARGET_V850E\"\n+\t(match_operand:QI 1 \"nonimmediate_operand\" \"0,r,T,m\")))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"(TARGET_V850E || TARGET_V850E2_ALL)\"\n   \"@\n    zxb %0\n    andi 255,%1,%0\n    sld.bu %1,%0\n    ld.bu %1,%0\"\n   [(set_attr \"length\" \"2,4,2,4\")\n-   (set_attr \"cc\" \"none_0hit,set_znv,none_0hit,none_0hit\")])\n+   (set_attr \"cc\" \"none_0hit,set_zn,none_0hit,none_0hit\")])\n \n (define_insn \"zero_extendqisi2\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(zero_extend:SI\n-\t (match_operand:QI 1 \"register_operand\" \"r\")))]\n+\t(match_operand:QI 1 \"register_operand\" \"r\")))\n+   (clobber (reg:CC CC_REGNUM))]\n   \"\"\n   \"andi 255,%1,%0\"\n   [(set_attr \"length\" \"4\")\n-   (set_attr \"cc\" \"set_znv\")])\n+   (set_attr \"cc\" \"set_zn\")])\n \n ;;- sign extension instructions\n \n ;; ??? The extendhisi2 pattern should not emit shifts for v850e?\n \n (define_insn \"*extendhisi_insn\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r\")\n-\t(sign_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"0,Q,m\")))]\n-  \"TARGET_V850E\"\n+\t(sign_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"0,Q,m\")))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"(TARGET_V850E || TARGET_V850E2_ALL)\"\n   \"@\n    sxh %0\n    sld.h %1,%0\n@@ -1268,12 +1568,14 @@\n ;; instruction.\n \n (define_expand \"extendhisi2\"\n-  [(set (match_dup 2)\n-        (ashift:SI (match_operand:HI 1 \"register_operand\" \"\")\n-                   (const_int 16)))\n-   (set (match_operand:SI 0 \"register_operand\" \"\")\n-       (ashiftrt:SI (match_dup 2)\n-                     (const_int 16)))]\n+  [(parallel [(set (match_dup 2)\n+\t\t   (ashift:SI (match_operand:HI 1 \"register_operand\" \"\")\n+\t\t\t      (const_int 16)))\n+\t      (clobber (reg:CC CC_REGNUM))])\n+   (parallel [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t\t   (ashiftrt:SI (match_dup 2)\n+\t\t\t\t(const_int 16)))\n+\t      (clobber (reg:CC CC_REGNUM))])]\n   \"\"\n   \"\n {\n@@ -1285,8 +1587,9 @@\n \n (define_insn \"*extendqisi_insn\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r\")\n-\t(sign_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"0,Q,m\")))]\n-  \"TARGET_V850E\"\n+\t(sign_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"0,Q,m\")))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"(TARGET_V850E || TARGET_V850E2_ALL)\"\n   \"@\n    sxb %0\n    sld.b %1,%0\n@@ -1298,12 +1601,14 @@\n ;; instruction.\n \n (define_expand \"extendqisi2\"\n-  [(set (match_dup 2)\n-        (ashift:SI (match_operand:QI 1 \"register_operand\" \"\")\n-                   (const_int 24)))\n-   (set (match_operand:SI 0 \"register_operand\" \"\")\n-        (ashiftrt:SI (match_dup 2)\n-                     (const_int 24)))]\n+  [(parallel [(set (match_dup 2)\n+\t\t   (ashift:SI (match_operand:QI 1 \"register_operand\" \"\")\n+\t\t\t      (const_int 24)))\n+\t      (clobber (reg:CC CC_REGNUM))])\n+   (parallel [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t\t   (ashiftrt:SI (match_dup 2)\n+\t\t\t      (const_int 24)))\n+\t      (clobber (reg:CC CC_REGNUM))])]\n   \"\"\n   \"\n {\n@@ -1317,39 +1622,88 @@\n \n (define_insn \"ashlsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n-\t(ashift:SI\n-\t (match_operand:SI 1 \"register_operand\" \"0,0\")\n-\t (match_operand:SI 2 \"nonmemory_operand\" \"r,N\")))]\n+      (ashift:SI\n+\t(match_operand:SI 1 \"register_operand\" \"0,0\")\n+\t(match_operand:SI 2 \"nonmemory_operand\" \"r,N\")))\n+   (clobber (reg:CC CC_REGNUM))]\n   \"\"\n   \"@\n   shl %2,%0\n   shl %2,%0\"\n   [(set_attr \"length\" \"4,2\")\n+   (set_attr \"cc\" \"set_zn\")])\n+\n+(define_insn \"ashlsi3_v850e2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+      (ashift:SI\n+\t(match_operand:SI 1 \"register_operand\" \"r\")\n+\t(match_operand:SI 2 \"nonmemory_operand\" \"r\")))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"TARGET_V850E2_ALL\"\n+  \"shl %2,%1,%0\"\n+  [(set_attr \"length\" \"4\")\n    (set_attr \"cc\" \"set_znv\")])\n \n (define_insn \"lshrsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n-\t(lshiftrt:SI\n-\t (match_operand:SI 1 \"register_operand\" \"0,0\")\n-\t (match_operand:SI 2 \"nonmemory_operand\" \"r,N\")))]\n+      (lshiftrt:SI\n+\t(match_operand:SI 1 \"register_operand\" \"0,0\")\n+        (match_operand:SI 2 \"nonmemory_operand\" \"r,N\")))\n+   (clobber (reg:CC CC_REGNUM))]\n   \"\"\n   \"@\n   shr %2,%0\n   shr %2,%0\"\n   [(set_attr \"length\" \"4,2\")\n-   (set_attr \"cc\" \"set_znv\")])\n+   (set_attr \"cc\" \"set_zn\")])\n+\n+(define_insn \"lshrsi3_v850e2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+      (lshiftrt:SI\n+\t(match_operand:SI 1 \"register_operand\" \"r\")\n+\t(match_operand:SI 2 \"nonmemory_operand\" \"r\")))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"TARGET_V850E2_ALL\"\n+  \"shr %2,%1,%0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"set_zn\")])\n \n (define_insn \"ashrsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n-\t(ashiftrt:SI\n-\t (match_operand:SI 1 \"register_operand\" \"0,0\")\n-\t (match_operand:SI 2 \"nonmemory_operand\" \"r,N\")))]\n+      (ashiftrt:SI\n+\t(match_operand:SI 1 \"register_operand\" \"0,0\")\n+\t(match_operand:SI 2 \"nonmemory_operand\" \"r,N\")))\n+   (clobber (reg:CC CC_REGNUM))]\n   \"\"\n   \"@\n   sar %2,%0\n   sar %2,%0\"\n   [(set_attr \"length\" \"4,2\")\n-   (set_attr \"cc\" \"set_znv\")])\n+   (set_attr \"cc\" \"set_zn, set_zn\")])\n+\n+(define_insn \"ashrsi3_v850e2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+      (ashiftrt:SI\n+\t(match_operand:SI 1 \"register_operand\" \"r\")\n+\t(match_operand:SI 2 \"nonmemory_operand\" \"r\")))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"TARGET_V850E2_ALL\"\n+  \"sar %2,%1,%0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"set_zn\")])\n+\n+;; ----------------------------------------------------------------------\n+;; FIND FIRST BIT INSTRUCTION\n+;; ----------------------------------------------------------------------\n+\n+(define_insn \"ffssi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+       (ffs:SI (match_operand:SI 1 \"register_operand\" \"r\")))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"TARGET_V850E2_ALL\"\n+  \"sch1r %1,%0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"clobber\")])\n \n ;; ----------------------------------------------------------------------\n ;; PROLOGUE/EPILOGUE\n@@ -1383,8 +1737,559 @@\n   [(set_attr \"length\" \"2\")\n    (set_attr \"cc\" \"none\")])\n \n+;; ----------------------------------------------------------------------\n+;; v850e2V3 floating-point hardware support\n+;; ----------------------------------------------------------------------\n+\n+\n+(define_insn \"addsf3\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=r\")\n+\t(plus:SF (match_operand:SF 1 \"register_operand\" \"r\")\n+\t\t (match_operand:SF 2 \"register_operand\" \"r\")))]\n+  \"TARGET_V850E2V3\"\n+  \"addf.s %1,%2,%0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"none_0hit\")\n+   (set_attr \"type\" \"fpu\")])\n+\n+(define_insn \"adddf3\"\n+  [(set (match_operand:DF 0 \"even_reg_operand\" \"=r\")\n+\t(plus:DF (match_operand:DF 1 \"even_reg_operand\" \"r\")\n+\t(match_operand:DF 2 \"even_reg_operand\" \"r\")))]\n+  \"TARGET_V850E2V3\"\n+  \"addf.d %1,%2,%0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"none_0hit\")\n+   (set_attr \"type\" \"fpu\")])\n+\n+(define_insn \"subsf3\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=r\")\n+\t(minus:SF (match_operand:SF 1 \"register_operand\" \"r\")\n+\t\t  (match_operand:SF 2 \"register_operand\" \"r\")))]\n+  \"TARGET_V850E2V3\"\n+  \"subf.s %2,%1,%0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"none_0hit\")\n+   (set_attr \"type\" \"fpu\")])\n+\n+(define_insn \"subdf3\"\n+  [(set (match_operand:DF 0 \"even_reg_operand\" \"=r\")\n+\t(minus:DF (match_operand:DF 1 \"even_reg_operand\" \"r\")\n+\t\t  (match_operand:DF 2 \"even_reg_operand\" \"r\")))]\n+  \"TARGET_V850E2V3\"\n+  \"subf.d %2,%1,%0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"none_0hit\")\n+   (set_attr \"type\" \"fpu\")])\n+\n+(define_insn \"mulsf3\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=r\")\n+\t(mult:SF (match_operand:SF 1 \"register_operand\" \"r\")\n+\t\t (match_operand:SF 2 \"register_operand\" \"r\")))]\n+  \"TARGET_V850E2V3\"\n+  \"mulf.s %1,%2,%0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"none_0hit\")\n+   (set_attr \"type\" \"fpu\")])\n+\n+(define_insn \"muldf3\"\n+  [(set (match_operand:DF 0 \"even_reg_operand\" \"=r\")\n+\t(mult:DF (match_operand:DF 1 \"even_reg_operand\" \"r\")\n+\t\t (match_operand:DF 2 \"even_reg_operand\" \"r\")))]\n+  \"TARGET_V850E2V3\"\n+  \"mulf.d %1,%2,%0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"none_0hit\")\n+   (set_attr \"type\" \"fpu\")])\n+\n+(define_insn \"divsf3\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=r\")\n+\t(div:SF (match_operand:SF 1 \"register_operand\" \"r\")\n+\t\t(match_operand:SF 2 \"register_operand\" \"r\")))]\n+  \"TARGET_V850E2V3\"\n+  \"divf.s %2,%1,%0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"none_0hit\")\n+   (set_attr \"type\" \"fpu\")])\n+\n+(define_insn \"divdf3\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n+\t(div:DF (match_operand:DF 1 \"even_reg_operand\" \"r\")\n+\t\t(match_operand:DF 2 \"even_reg_operand\" \"r\")))]\n+  \"TARGET_V850E2V3\"\n+  \"divf.d %2,%1,%0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"none_0hit\")\n+   (set_attr \"type\" \"fpu\")])\n+\n+(define_insn \"minsf3\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=r\")\n+\t(smin:SF (match_operand:SF 1 \"reg_or_0_operand\" \"r\")\n+\t\t (match_operand:SF 2 \"reg_or_0_operand\" \"r\")))]\n+  \"TARGET_V850E2V3\"\n+  \"minf.s %z1,%z2,%0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"none_0hit\")\n+   (set_attr \"type\" \"fpu\")])\n+\n+(define_insn \"mindf3\"\n+  [(set (match_operand:DF 0 \"even_reg_operand\" \"=r\")\n+\t(smin:DF (match_operand:DF 1 \"even_reg_operand\" \"r\")\n+\t\t (match_operand:DF 2 \"even_reg_operand\" \"r\")))]\n+  \"TARGET_V850E2V3\"\n+  \"minf.d %1,%2,%0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"none_0hit\")\n+   (set_attr \"type\" \"fpu\")])\n+\n+(define_insn \"maxsf3\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=r\")\n+\t(smax:SF (match_operand:SF 1 \"reg_or_0_operand\" \"r\")\n+\t\t (match_operand:SF 2 \"reg_or_0_operand\" \"r\")))]\n+  \"TARGET_V850E2V3\"\n+  \"maxf.s %z1,%z2,%0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"none_0hit\")\n+   (set_attr \"type\" \"fpu\")])\n+\n+(define_insn \"maxdf3\"\n+  [(set (match_operand:DF 0 \"even_reg_operand\" \"=r\")\n+\t(smax:DF (match_operand:DF 1 \"even_reg_operand\" \"r\")\n+\t\t (match_operand:DF 2 \"even_reg_operand\" \"r\")))]\n+  \"TARGET_V850E2V3\"\n+  \"maxf.d %1,%2,%0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"none_0hit\")\n+   (set_attr \"type\" \"fpu\")])\n+\n+(define_insn \"abssf2\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=r\")\n+\t(abs:SF (match_operand:SF 1 \"register_operand\" \"r\")))]\n+  \"TARGET_V850E2V3\"\n+  \"absf.s %1,%0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"none_0hit\")\n+   (set_attr \"type\" \"fpu\")])\n+\n+(define_insn \"absdf2\"\n+  [(set (match_operand:DF 0 \"even_reg_operand\" \"=r\")\n+\t(abs:DF (match_operand:DF 1 \"even_reg_operand\" \"r\")))]\n+  \"TARGET_V850E2V3\"\n+  \"absf.d %1,%0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"none_0hit\")\n+   (set_attr \"type\" \"fpu\")])\n+\n+(define_insn \"negsf2\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=r\")\n+\t(neg:SF (match_operand:SF 1 \"register_operand\" \"r\")))]\n+  \"TARGET_V850E2V3\"\n+  \"negf.s %1,%0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"none_0hit\")\n+   (set_attr \"type\" \"fpu\")])\n+\n+(define_insn \"negdf2\"\n+  [(set (match_operand:DF 0 \"even_reg_operand\" \"=r\")\n+\t(neg:DF (match_operand:DF 1 \"even_reg_operand\" \"r\")))]\n+  \"TARGET_V850E2V3\"\n+  \"negf.d %1,%0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"none_0hit\")\n+   (set_attr \"type\" \"fpu\")])\n+\n+;; square-root\n+(define_insn \"sqrtsf2\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=r\")\n+\t(sqrt:SF (match_operand:SF 1 \"register_operand\" \"r\")))]\n+  \"TARGET_V850E2V3\"\n+  \"sqrtf.s %1,%0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"none_0hit\")\n+   (set_attr \"type\" \"fpu\")])\n+\n+(define_insn \"sqrtdf2\"\n+  [(set (match_operand:DF 0 \"even_reg_operand\" \"=r\")\n+\t(sqrt:DF (match_operand:DF 1 \"even_reg_operand\" \"r\")))]\n+  \"TARGET_V850E2V3\"\n+  \"sqrtf.d %1,%0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"none_0hit\")\n+   (set_attr \"type\" \"fpu\")])\n+\n+;; float -> int\n+(define_insn \"fix_truncsfsi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(fix:SI (fix:SF (match_operand:SF 1 \"register_operand\" \"r\"))))]\n+  \"TARGET_V850E2V3\"\n+  \"trncf.sw %1,%0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"none_0hit\")\n+   (set_attr \"type\" \"fpu\")])\n+\n+(define_insn \"fix_truncdfsi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(fix:SI (fix:DF (match_operand:DF 1 \"even_reg_operand\" \"r\"))))]\n+  \"TARGET_V850E2V3\"\n+  \"trncf.dw %1,%0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"none_0hit\")\n+   (set_attr \"type\" \"fpu\")])\n+\n+;; int -> float\n+(define_insn \"floatsisf2\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=r\")\n+\t(float:SF (match_operand:SI 1 \"reg_or_0_operand\" \"rI\")))]\n+  \"TARGET_V850E2V3\"\n+  \"cvtf.ws %z1, %0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"none_0hit\")\n+   (set_attr \"type\" \"fpu\")])\n+\n+(define_insn \"floatsidf2\"\n+  [(set (match_operand:DF 0 \"even_reg_operand\" \"=r\")\n+\t(float:DF (match_operand:SI 1 \"reg_or_0_operand\" \"rI\")))]\n+  \"TARGET_V850E2V3\"\n+  \"cvtf.wd %z1,%0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"none_0hit\")\n+   (set_attr \"type\" \"fpu\")])\n+\n+;; single-float -> double-float\n+(define_insn \"extendsfdf2\"\n+  [(set (match_operand:DF 0 \"even_reg_operand\" \"=r\")\n+\t(float_extend:DF\n+\t (match_operand:SF 1 \"reg_or_0_operand\" \"rI\")))]\n+  \"TARGET_V850E2V3\"\n+  \"cvtf.sd %z1,%0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"none_0hit\")\n+   (set_attr \"type\" \"fpu\")])\n+\n+;; double-float -> single-float\n+(define_insn \"truncdfsf2\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=r\")\n+\t(float_truncate:SF\n+\t (match_operand:DF 1 \"even_reg_operand\" \"r\")))]\n+  \"TARGET_V850E2V3\"\n+  \"cvtf.ds %1,%0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"none_0hit\")\n+   (set_attr \"type\" \"fpu\")])\n+\n+;;\n+;; ---------------- special insns\n+;;\n+\n+;;; reciprocal\n+(define_insn \"recipsf2\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=r\")\n+\t(div:SF (match_operand:SF 1 \"const_float_1_operand\" \"\")\n+\t\t(match_operand:SF 2 \"register_operand\" \"r\")))]\n+  \"TARGET_V850E2V3\"\n+  \"recipf.s %2,%0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"none_0hit\")\n+   (set_attr \"type\" \"fpu\")])\n+\n+(define_insn \"recipdf2\"\n+  [(set (match_operand:DF 0 \"even_reg_operand\" \"=r\")\n+\t(div:DF (match_operand:DF 1 \"const_float_1_operand\" \"\")\n+\t\t(match_operand:DF 2 \"even_reg_operand\" \"r\")))]\n+  \"TARGET_V850E2V3\"\n+  \"recipf.d %2,%0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"none_0hit\")\n+   (set_attr \"type\" \"fpu\")])\n+\n+;;; reciprocal of square-root\n+(define_insn \"rsqrtsf2\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=r\")\n+\t(div:SF (match_operand:SF 1 \"const_float_1_operand\" \"\")\n+\t\t(sqrt:SF (match_operand:SF 2 \"register_operand\" \"r\"))))]\n+  \"TARGET_V850E2V3\"\n+  \"rsqrtf.s %2,%0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"none_0hit\")\n+   (set_attr \"type\" \"fpu\")])\n+\n+(define_insn \"rsqrtdf2\"\n+  [(set (match_operand:DF 0 \"even_reg_operand\" \"=r\")\n+\t(div:DF (match_operand:DF 1 \"const_float_1_operand\" \"\")\n+\t\t(sqrt:DF (match_operand:DF 2 \"even_reg_operand\" \"r\"))))]\n+  \"TARGET_V850E2V3\"\n+  \"rsqrtf.d %2,%0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"none_0hit\")\n+   (set_attr \"type\" \"fpu\")])\n+\n+;;; multiply-add\n+(define_insn \"maddsf4\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=r\")\n+\t(plus:SF (mult:SF (match_operand:SF 1 \"register_operand\" \"r\")\n+\t\t\t  (match_operand:SF 2 \"register_operand\" \"r\"))\n+\t\t (match_operand:SF 3 \"register_operand\" \"r\")))]\n+  \"TARGET_V850E2V3\"\n+  \"maddf.s %2,%1,%3,%0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"none_0hit\")\n+   (set_attr \"type\" \"fpu\")])\n+\n+\n+;;; multiply-subtract\n+(define_insn \"msubsf4\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=r\")\n+\t(minus:SF (mult:SF (match_operand:SF 1 \"register_operand\" \"r\")\n+\t\t\t   (match_operand:SF 2 \"register_operand\" \"r\"))\n+\t\t  (match_operand:SF 3 \"register_operand\" \"r\")))]\n+  \"TARGET_V850E2V3\"\n+  \"msubf.s %2,%1,%3,%0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"none_0hit\")\n+   (set_attr \"type\" \"fpu\")])\n+\n+;;; negative-multiply-add\n+(define_insn \"nmaddsf4\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=r\")\n+\t(neg:SF (plus:SF (mult:SF (match_operand:SF 1 \"register_operand\" \"r\")\n+\t\t\t\t  (match_operand:SF 2 \"register_operand\" \"r\"))\n+\t\t\t (match_operand:SF 3 \"register_operand\" \"r\"))))]\n+  \"TARGET_V850E2V3\"\n+  \"nmaddf.s %2,%1,%3,%0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"none_0hit\")\n+   (set_attr \"type\" \"fpu\")])\n+\n+;; negative-multiply-subtract\n+(define_insn \"nmsubsf4\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=r\")\n+\t(neg:SF (minus:SF (mult:SF (match_operand:SF 1 \"register_operand\" \"r\")\n+\t\t\t\t   (match_operand:SF 2 \"register_operand\" \"r\"))\n+\t\t\t  (match_operand:SF 3 \"register_operand\" \"r\"))))]\n+  \"TARGET_V850E2V3\"\n+  \"nmsubf.s %2,%1,%3,%0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"none_0hit\")\n+   (set_attr \"type\" \"fpu\")])\n+;\n+; ---------------- comparison/conditionals\n+;\n+; SF\n+\n+(define_insn \"cmpsf_le_insn\"\n+  [(set (reg:CC_FPU_LE FCC_REGNUM)\n+        (compare:CC_FPU_LE (match_operand:SF 0 \"register_operand\" \"r\")\n+\t\t\t   (match_operand:SF 1 \"register_operand\" \"r\")))]\n+  \"TARGET_V850E2V3\"\n+  \"cmpf.s le,%z0,%z1\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"none_0hit\")\n+   (set_attr \"type\" \"fpu\")])\n+\n+(define_insn \"cmpsf_lt_insn\"\n+  [(set (reg:CC_FPU_LT FCC_REGNUM)\n+        (compare:CC_FPU_LT (match_operand:SF 0 \"register_operand\" \"r\")\n+\t\t\t   (match_operand:SF 1 \"register_operand\" \"r\")))]\n+  \"TARGET_V850E2V3\"\n+  \"cmpf.s lt,%z0,%z1\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"none_0hit\")\n+   (set_attr \"type\" \"fpu\")])\n+\n+(define_insn \"cmpsf_ge_insn\"\n+  [(set (reg:CC_FPU_GE FCC_REGNUM)\n+        (compare:CC_FPU_GE (match_operand:SF 0 \"register_operand\" \"r\")\n+\t\t\t   (match_operand:SF 1 \"register_operand\" \"r\")))]\n+  \"TARGET_V850E2V3\"\n+  \"cmpf.s ge,%z0,%z1\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"none_0hit\")\n+   (set_attr \"type\" \"fpu\")])\n+\n+(define_insn \"cmpsf_gt_insn\"\n+  [(set (reg:CC_FPU_GT FCC_REGNUM)\n+        (compare:CC_FPU_GT (match_operand:SF 0 \"register_operand\" \"r\")\n+\t\t\t   (match_operand:SF 1 \"register_operand\" \"r\")))]\n+  \"TARGET_V850E2V3\"\n+  \"cmpf.s gt,%z0,%z1\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"none_0hit\")\n+   (set_attr \"type\" \"fpu\")])\n+\n+(define_insn \"cmpsf_eq_insn\"\n+  [(set (reg:CC_FPU_EQ FCC_REGNUM)\n+        (compare:CC_FPU_EQ (match_operand:SF 0 \"register_operand\" \"r\")\n+\t\t\t   (match_operand:SF 1 \"register_operand\" \"r\")))]\n+  \"TARGET_V850E2V3\"\n+  \"cmpf.s eq,%z0,%z1\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"none_0hit\")\n+   (set_attr \"type\" \"fpu\")])\n+\n+(define_insn \"cmpsf_ne_insn\"\n+  [(set (reg:CC_FPU_NE FCC_REGNUM)\n+        (compare:CC_FPU_NE (match_operand:SF 0 \"register_operand\" \"r\")\n+\t\t\t   (match_operand:SF 1 \"register_operand\" \"r\")))]\n+  \"TARGET_V850E2V3\"\n+  \"cmpf.s neq,%z0,%z1\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"none_0hit\")\n+   (set_attr \"type\" \"fpu\")])\n+\n+; DF\n+\n+(define_insn \"cmpdf_le_insn\"\n+  [(set (reg:CC_FPU_LE FCC_REGNUM)\n+        (compare:CC_FPU_LE (match_operand:DF 0 \"even_reg_operand\" \"r\")\n+\t\t\t   (match_operand:DF 1 \"even_reg_operand\" \"r\")))]\n+  \"TARGET_V850E2V3\"\n+  \"cmpf.d le,%z0,%z1\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"none_0hit\")\n+   (set_attr \"type\" \"fpu\")])\n+\n+(define_insn \"cmpdf_lt_insn\"\n+  [(set (reg:CC_FPU_LT FCC_REGNUM)\n+        (compare:CC_FPU_LT (match_operand:DF 0 \"even_reg_operand\" \"r\")\n+\t\t\t   (match_operand:DF 1 \"even_reg_operand\" \"r\")))]\n+  \"TARGET_V850E2V3\"\n+  \"cmpf.d lt,%z0,%z1\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"none_0hit\")\n+   (set_attr \"type\" \"fpu\")])\n+\n+(define_insn \"cmpdf_ge_insn\"\n+  [(set (reg:CC_FPU_GE FCC_REGNUM)\n+        (compare:CC_FPU_GE (match_operand:DF 0 \"even_reg_operand\" \"r\")\n+\t\t\t   (match_operand:DF 1 \"even_reg_operand\" \"r\")))]\n+  \"TARGET_V850E2V3\"\n+  \"cmpf.d ge,%z0,%z1\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"none_0hit\")\n+   (set_attr \"type\" \"fpu\")])\n+\n+(define_insn \"cmpdf_gt_insn\"\n+  [(set (reg:CC_FPU_GT FCC_REGNUM)\n+        (compare:CC_FPU_GT (match_operand:DF 0 \"even_reg_operand\" \"r\")\n+\t\t      (match_operand:DF 1 \"even_reg_operand\" \"r\")))]\n+  \"TARGET_V850E2V3\"\n+  \"cmpf.d gt,%z0,%z1\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"none_0hit\")\n+   (set_attr \"type\" \"fpu\")])\n+\n+(define_insn \"cmpdf_eq_insn\"\n+  [(set (reg:CC_FPU_EQ FCC_REGNUM)\n+        (compare:CC_FPU_EQ (match_operand:DF 0 \"even_reg_operand\" \"r\")\n+\t\t\t   (match_operand:DF 1 \"even_reg_operand\" \"r\")))]\n+  \"TARGET_V850E2V3\"\n+  \"cmpf.d eq,%z0,%z1\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"none_0hit\")\n+   (set_attr \"type\" \"fpu\")])\n+\n+(define_insn \"cmpdf_ne_insn\"\n+  [(set (reg:CC_FPU_NE FCC_REGNUM)\n+        (compare:CC_FPU_NE (match_operand:DF 0 \"even_reg_operand\" \"r\")\n+\t\t\t   (match_operand:DF 1 \"even_reg_operand\" \"r\")))]\n+  \"TARGET_V850E2V3\"\n+  \"cmpf.d neq,%z0,%z1\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"none_0hit\")\n+   (set_attr \"type\" \"fpu\")])\n+\n+\n+;;\n+;; Transfer a v850e2v3 fcc to the Z bit of CC0 (this is necessary to do a\n+;; conditional branch based on a floating-point compare)\n+;;\n+\n+(define_insn \"trfsr\"\n+  [(set (match_operand 0 \"\" \"\") (match_operand 1 \"\" \"\"))]\n+  \"TARGET_V850E2V3\n+   && GET_MODE(operands[0]) == GET_MODE(operands[1])\n+   && GET_CODE(operands[0]) == REG && REGNO (operands[0]) == CC_REGNUM\n+   && GET_CODE(operands[1]) == REG && REGNO (operands[1]) == FCC_REGNUM\n+   && (GET_MODE(operands[0]) == CC_FPU_LEmode\n+       || GET_MODE(operands[0]) == CC_FPU_GEmode\n+       || GET_MODE(operands[0]) == CC_FPU_LTmode\n+       || GET_MODE(operands[0]) == CC_FPU_GTmode\n+       || GET_MODE(operands[0]) == CC_FPU_EQmode\n+       || GET_MODE(operands[0]) == CC_FPU_NEmode)\"\n+  \"trfsr\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"set_z\")\n+   (set_attr \"type\" \"fpu\")])\n+\n+;;\n+;; Floating-point conditional moves for the v850e2v3.\n+;;\n+\n+;; The actual v850e2v3 conditional move instructions\n+;;\n+(define_insn \"movsfcc_z_insn\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=r\")\n+\t(if_then_else:SF\n+\t (match_operand 3 \"v850_float_z_comparison_operator\" \"\")\n+\t (match_operand:SF 1 \"reg_or_0_operand\" \"rIG\")\n+\t (match_operand:SF 2 \"reg_or_0_operand\" \"rIG\")))]\n+  \"TARGET_V850E2V3\"\n+  \"cmovf.s 0,%z1,%z2,%0\"\n+  [(set_attr \"cc\" \"clobber\")]) ;; ??? or none_0hit\n+\n+(define_insn \"movsfcc_nz_insn\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=r\")\n+\t(if_then_else:SF\n+\t (match_operand 3 \"v850_float_nz_comparison_operator\" \"\")\n+\t (match_operand:SF 1 \"reg_or_0_operand\" \"rIG\")\n+\t (match_operand:SF 2 \"reg_or_0_operand\" \"rIG\")))]\n+  \"TARGET_V850E2V3\"\n+  \"cmovf.s 0,%z2,%z1,%0\"\n+  [(set_attr \"cc\" \"clobber\")]) ;; ??? or none_0hit\n+\n+(define_insn \"movdfcc_z_insn\"\n+  [(set (match_operand:DF 0 \"even_reg_operand\" \"=r\")\n+\t(if_then_else:DF\n+\t (match_operand 3 \"v850_float_z_comparison_operator\" \"\")\n+\t (match_operand:DF 1 \"even_reg_operand\" \"r\")\n+\t (match_operand:DF 2 \"even_reg_operand\" \"r\")))]\n+  \"TARGET_V850E2V3\"\n+  \"cmovf.d 0,%z1,%z2,%0\"\n+  [(set_attr \"cc\" \"clobber\")]) ;; ??? or none_0hit\n+\n+(define_insn \"movdfcc_nz_insn\"\n+  [(set (match_operand:DF 0 \"even_reg_operand\" \"=r\")\n+\t(if_then_else:DF\n+\t (match_operand 3 \"v850_float_nz_comparison_operator\" \"\")\n+\t (match_operand:DF 1 \"even_reg_operand\" \"r\")\n+\t (match_operand:DF 2 \"even_reg_operand\" \"r\")))]\n+  \"TARGET_V850E2V3\"\n+  \"cmovf.d 0,%z2,%z1,%0\"\n+  [(set_attr \"cc\" \"clobber\")]) ;; ??? or none_0hit\n+\n+(define_insn \"movedfcc_z_zero\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n+\t(if_then_else:DF\n+\t (match_operand 3 \"v850_float_z_comparison_operator\" \"\")\n+\t (match_operand:DF 1 \"reg_or_0_operand\" \"rIG\")\n+\t (match_operand:DF 2 \"reg_or_0_operand\" \"rIG\")))]\n+  \"TARGET_V850E2V3\"\n+  \"cmovf.s 0,%z1,%z2,%0 ; cmovf.s 0,%Z1,%Z2,%R0\"\n+  [(set_attr \"length\" \"8\")\n+   (set_attr \"cc\" \"clobber\")]) ;; ??? or none_0hit\n+\n+(define_insn \"movedfcc_nz_zero\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n+\t(if_then_else:DF\n+\t (match_operand 3 \"v850_float_nz_comparison_operator\" \"\")\n+\t (match_operand:DF 1 \"reg_or_0_operand\" \"rIG\")\n+\t (match_operand:DF 2 \"reg_or_0_operand\" \"rIG\")))]\n+  \"TARGET_V850E2V3\"\n+  \"cmovf.s 0,%z2,%z1,%0 ; cmovf.s 0,%Z2,%Z1,%R0\"\n+  [(set_attr \"length\" \"8\")\n+   (set_attr \"cc\" \"clobber\")]) ;; ??? or none_0hit\n+\n \n-\f\n ;; ----------------------------------------------------------------------\n ;; HELPER INSTRUCTIONS for saving the prologue and epilogue registers\n ;; ----------------------------------------------------------------------\n@@ -1396,18 +2301,19 @@\n ;;\n ;; Actually, convert the RTXs into a PREPARE instruction.\n ;;\n+\n (define_insn \"\"\n  [(match_parallel 0 \"pattern_is_ok_for_prepare\"\n    [(set (reg:SI 3)\n \t (plus:SI (reg:SI 3) (match_operand:SI 1 \"immediate_operand\" \"i\")))\n     (set (mem:SI (plus:SI (reg:SI 3)\n \t\t\t  (match_operand:SI 2 \"immediate_operand\" \"i\")))\n \t (match_operand:SI 3 \"register_is_ok_for_epilogue\" \"r\"))])]\n- \"TARGET_PROLOG_FUNCTION && TARGET_V850E\"\n+ \"TARGET_PROLOG_FUNCTION && (TARGET_V850E || TARGET_V850E2_ALL)\"\n  \"* return construct_prepare_instruction (operands[0]);\n  \"\n  [(set_attr \"length\" \"4\")\n-  (set_attr \"cc\"     \"none\")])\n+  (set_attr \"cc\"     \"clobber\")])\n \n (define_insn \"\"\n  [(match_parallel 0 \"pattern_is_ok_for_prologue\"\n@@ -1416,7 +2322,7 @@\n     (set (mem:SI (plus:SI (reg:SI 3)\n \t\t\t   (match_operand:SI 2 \"immediate_operand\" \"i\")))\n \t (match_operand:SI 3 \"register_is_ok_for_epilogue\" \"r\"))])]\n- \"TARGET_PROLOG_FUNCTION && TARGET_V850\"\n+ \"TARGET_PROLOG_FUNCTION\"\n  \"* return construct_save_jarl (operands[0]);\n  \"\n  [(set (attr \"length\") (if_then_else (eq_attr \"long_calls\" \"yes\")\n@@ -1435,11 +2341,11 @@\n     (set (match_operand:SI 2 \"register_is_ok_for_epilogue\" \"=r\")\n \t (mem:SI (plus:SI (reg:SI 3)\n \t\t\t  (match_operand:SI 3 \"immediate_operand\" \"i\"))))])]\n- \"TARGET_PROLOG_FUNCTION && TARGET_V850E\"\n+ \"TARGET_PROLOG_FUNCTION && (TARGET_V850E || TARGET_V850E2_ALL)\"\n  \"* return construct_dispose_instruction (operands[0]);\n  \"\n  [(set_attr \"length\" \"4\")\n-  (set_attr \"cc\"     \"none\")])\n+  (set_attr \"cc\"     \"clobber\")])\n \n ;; This pattern will match a return RTX followed by any number of pop RTXs\n ;; and possible a stack adjustment as well.  These RTXs will be turned into\n@@ -1453,7 +2359,7 @@\n     (set (match_operand:SI 2 \"register_is_ok_for_epilogue\" \"=r\")\n \t (mem:SI (plus:SI (reg:SI 3)\n \t\t\t  (match_operand:SI 3 \"immediate_operand\" \"i\"))))])]\n- \"TARGET_PROLOG_FUNCTION && TARGET_V850\"\n+ \"TARGET_PROLOG_FUNCTION\"\n  \"* return construct_restore_jr (operands[0]);\n  \"\n  [(set (attr \"length\") (if_then_else (eq_attr \"long_calls\" \"yes\")\n@@ -1464,46 +2370,50 @@\n ;; Initialize an interrupt function.  Do not depend on TARGET_PROLOG_FUNCTION.\n (define_insn \"callt_save_interrupt\"\n   [(unspec_volatile [(const_int 0)] 2)]\n-    \"TARGET_V850E && !TARGET_DISABLE_CALLT\"\n+    \"(TARGET_V850E || TARGET_V850E2_ALL) && !TARGET_DISABLE_CALLT\"\n     ;; The CALLT instruction stores the next address of CALLT to CTPC register\n     ;; without saving its previous value.  So if the interrupt handler\n     ;; or its caller could possibly execute the CALLT insn, save_interrupt \n     ;; MUST NOT be called via CALLT.\n     \"*\n {\n-  output_asm_insn (\\\"addi -24,   sp, sp\\\", operands);\n+  output_asm_insn (\\\"addi -28,   sp, sp\\\", operands);\n+  output_asm_insn (\\\"st.w r1,    24[sp]\\\", operands);\n   output_asm_insn (\\\"st.w r10,   12[sp]\\\", operands);\n+  output_asm_insn (\\\"st.w r11,   16[sp]\\\", operands);\n   output_asm_insn (\\\"stsr ctpc,  r10\\\",    operands);\n-  output_asm_insn (\\\"st.w r10,   16[sp]\\\", operands);\n-  output_asm_insn (\\\"stsr ctpsw, r10\\\",    operands);\n   output_asm_insn (\\\"st.w r10,   20[sp]\\\", operands);\n+  output_asm_insn (\\\"stsr ctpsw, r10\\\",    operands);\n+  output_asm_insn (\\\"st.w r10,   24[sp]\\\", operands);\n   output_asm_insn (\\\"callt ctoff(__callt_save_interrupt)\\\", operands);\n   return \\\"\\\";\n }\"\n    [(set_attr \"length\" \"26\")\n-    (set_attr \"cc\" \"none\")])\n+    (set_attr \"cc\" \"clobber\")])\n \n (define_insn \"callt_return_interrupt\"\n   [(unspec_volatile [(const_int 0)] 3)]\n-  \"TARGET_V850E && !TARGET_DISABLE_CALLT\"\n+  \"(TARGET_V850E || TARGET_V850E2_ALL) && !TARGET_DISABLE_CALLT\"\n   \"callt ctoff(__callt_return_interrupt)\"\n   [(set_attr \"length\" \"2\")\n    (set_attr \"cc\" \"clobber\")])\n \n (define_insn \"save_interrupt\"\n-  [(set (reg:SI 3) (plus:SI (reg:SI 3) (const_int -16)))\n-   (set (mem:SI (plus:SI (reg:SI 3) (const_int -16))) (reg:SI 30))\n-   (set (mem:SI (plus:SI (reg:SI 3) (const_int -12))) (reg:SI 4))\n-   (set (mem:SI (plus:SI (reg:SI 3) (const_int  -8))) (reg:SI 1))\n-   (set (mem:SI (plus:SI (reg:SI 3) (const_int  -4))) (reg:SI 10))]\n+  [(set (reg:SI 3) (plus:SI (reg:SI 3) (const_int -20)))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -20))) (reg:SI 30))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -16))) (reg:SI 4))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int -12))) (reg:SI 1))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int  -8))) (reg:SI 10))\n+   (set (mem:SI (plus:SI (reg:SI 3) (const_int  -4))) (reg:SI 11))]\n   \"\"\n   \"*\n {\n   if (TARGET_PROLOG_FUNCTION && !TARGET_LONG_CALLS)\n-    return \\\"add -16,sp\\;st.w r10,12[sp]\\;jarl __save_interrupt,r10\\\";\n+    return \\\"addi -20,sp,sp \\; st.w r11,16[sp] \\; st.w r10,12[sp] \\; jarl __save_interrupt,r10\\\";\n   else\n     {\n-      output_asm_insn (\\\"add   -16, sp\\\", operands);\n+      output_asm_insn (\\\"addi  -20, sp, sp\\\", operands);\n+      output_asm_insn (\\\"st.w  r11, 16[sp]\\\", operands);\n       output_asm_insn (\\\"st.w  r10, 12[sp]\\\", operands);\n       output_asm_insn (\\\"st.w  ep, 0[sp]\\\", operands);\n       output_asm_insn (\\\"st.w  gp, 4[sp]\\\", operands);\n@@ -1524,7 +2434,8 @@\n ;; Restore r1, r4, r10, and return from the interrupt\n (define_insn \"return_interrupt\"\n   [(return)\n-   (set (reg:SI 3)  (plus:SI (reg:SI 3) (const_int 16)))\n+   (set (reg:SI 3)  (plus:SI (reg:SI 3) (const_int 20)))\n+   (set (reg:SI 11) (mem:SI (plus:SI (reg:SI 3) (const_int 16))))\n    (set (reg:SI 10) (mem:SI (plus:SI (reg:SI 3) (const_int 12))))\n    (set (reg:SI 1)  (mem:SI (plus:SI (reg:SI 3) (const_int  8))))\n    (set (reg:SI 4)  (mem:SI (plus:SI (reg:SI 3) (const_int  4))))\n@@ -1540,7 +2451,8 @@\n       output_asm_insn (\\\"ld.w 4[sp],  gp\\\",   operands);\n       output_asm_insn (\\\"ld.w 8[sp],  r1\\\",   operands);\n       output_asm_insn (\\\"ld.w 12[sp], r10\\\", operands);\n-      output_asm_insn (\\\"addi 16, sp, sp\\\",   operands);\n+      output_asm_insn (\\\"ld.w 16[sp], r11\\\", operands);\n+      output_asm_insn (\\\"addi 20, sp, sp\\\",   operands);\n       output_asm_insn (\\\"reti\\\",            operands);\n       return \\\"\\\";\n     }\n@@ -1560,7 +2472,7 @@\n \n (define_insn \"callt_save_all_interrupt\"\n   [(unspec_volatile [(const_int 0)] 0)]\n-  \"TARGET_V850E && !TARGET_DISABLE_CALLT\"\n+  \"(TARGET_V850E || TARGET_V850E2_ALL) && !TARGET_DISABLE_CALLT\"\n   \"callt ctoff(__callt_save_all_interrupt)\"\n   [(set_attr \"length\" \"2\")\n    (set_attr \"cc\" \"none\")])\n@@ -1661,7 +2573,7 @@\n \n (define_insn \"callt_restore_all_interrupt\"\n   [(unspec_volatile [(const_int 0)] 1)]\n-  \"TARGET_V850E && !TARGET_DISABLE_CALLT\"\n+  \"(TARGET_V850E || TARGET_V850E2_ALL) && !TARGET_DISABLE_CALLT\"\n   \"callt ctoff(__callt_restore_all_interrupt)\"\n   [(set_attr \"length\" \"2\")\n    (set_attr \"cc\" \"none\")])\n@@ -1752,26 +2664,4 @@\n   [(set_attr \"length\" \"4\")\n    (set_attr \"cc\" \"clobber\")])\n \n-;; Save r6-r9 for a variable argument function\n-(define_insn \"save_r6_r9_v850e\"\n-  [(set (mem:SI (reg:SI 3)) (reg:SI 6))\n-   (set (mem:SI (plus:SI (reg:SI 3) (const_int 4))) (reg:SI 7))\n-   (set (mem:SI (plus:SI (reg:SI 3) (const_int 8))) (reg:SI 8))\n-   (set (mem:SI (plus:SI (reg:SI 3) (const_int 12))) (reg:SI 9))\n-  ]\n-  \"TARGET_PROLOG_FUNCTION && TARGET_V850E && !TARGET_DISABLE_CALLT\"\n-  \"callt ctoff(__callt_save_r6_r9)\"\n-  [(set_attr \"length\" \"2\")\n-   (set_attr \"cc\" \"none\")])\n-\n-(define_insn \"save_r6_r9\"\n-  [(set (mem:SI (reg:SI 3)) (reg:SI 6))\n-   (set (mem:SI (plus:SI (reg:SI 3) (const_int 4))) (reg:SI 7))\n-   (set (mem:SI (plus:SI (reg:SI 3) (const_int 8))) (reg:SI 8))\n-   (set (mem:SI (plus:SI (reg:SI 3) (const_int 12))) (reg:SI 9))\n-   (clobber (reg:SI 10))]\n-  \"TARGET_PROLOG_FUNCTION && ! TARGET_LONG_CALLS\"\n-  \"jarl __save_r6_r9,r10\"\n-  [(set_attr \"length\" \"4\")\n-   (set_attr \"cc\" \"clobber\")])\n "}, {"sha": "988101393bc9b2ace6d2729765f994ee93d8a149", "filename": "gcc/config/v850/v850.opt", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/223a9d64453b03941bcd88e479c8047edffadc42/gcc%2Fconfig%2Fv850%2Fv850.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/223a9d64453b03941bcd88e479c8047edffadc42/gcc%2Fconfig%2Fv850%2Fv850.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.opt?ref=223a9d64453b03941bcd88e479c8047edffadc42", "patch": "@@ -66,10 +66,14 @@ mtda\n Target RejectNegative Joined\n Set the max size of data eligible for the TDA area\n \n-mstrict-align\n-Target Report Mask(STRICT_ALIGN)\n+mno-strict-align\n+Target Report Mask(NO_STRICT_ALIGN)\n Enforce strict alignment\n \n+mjump-tables-in-data-section\n+Target Report Mask(JUMP_TABLES_IN_DATA_SECTION)\n+Enforce table jump\n+\n mUS-bit-set\n Target Report Mask(US_BIT_SET)\n \n@@ -82,9 +86,17 @@ Target Report RejectNegative Mask(V850E)\n Compile for the v850e processor\n \n mv850e1\n-Target RejectNegative Mask(V850E) MaskExists\n+Target RejectNegative Mask(V850E1)\n Compile for the v850e1 processor\n \n+mv850e2\n+Target Report RejectNegative Mask(V850E2)\n+Compile for the v850e2 processor\n+\n+mv850e2v3\n+Target Report RejectNegative Mask(V850E2V3)\n+Compile for the v850e2v3 processor\n+\n mzda\n Target RejectNegative Joined\n Set the max size of data eligible for the ZDA area"}, {"sha": "73051de06f13ecd025c72ba46e9538a3c93d8973", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/223a9d64453b03941bcd88e479c8047edffadc42/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/223a9d64453b03941bcd88e479c8047edffadc42/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=223a9d64453b03941bcd88e479c8047edffadc42", "patch": "@@ -868,6 +868,8 @@ See RS/6000 and PowerPC Options.\n -mtda=@var{n}  -msda=@var{n}  -mzda=@var{n} @gol\n -mapp-regs  -mno-app-regs @gol\n -mdisable-callt  -mno-disable-callt @gol\n+-mv850e2v3 @gol\n+-mv850e2 @gol\n -mv850e1 @gol\n -mv850e @gol\n -mv850  -mbig-switch}\n@@ -16957,18 +16959,29 @@ the compiler.  This setting is the default.\n @opindex mno-app-regs\n This option will cause r2 and r5 to be treated as fixed registers.\n \n+@item -mv850e2v3\n+@opindex mv850e2v3\n+Specify that the target processor is the V850E2V3.  The preprocessor\n+constants @samp{__v850e2v3__} will be defined if\n+this option is used.\n+\n+@item -mv850e2\n+@opindex mv850e2\n+Specify that the target processor is the V850E2.  The preprocessor\n+constants @samp{__v850e2__} will be defined if\n+\n @item -mv850e1\n @opindex mv850e1\n Specify that the target processor is the V850E1.  The preprocessor\n constants @samp{__v850e1__} and @samp{__v850e__} will be defined if\n-this option is used.\n \n @item -mv850e\n @opindex mv850e\n Specify that the target processor is the V850E@.  The preprocessor\n constant @samp{__v850e__} will be defined if this option is used.\n \n If neither @option{-mv850} nor @option{-mv850e} nor @option{-mv850e1}\n+nor @option{-mv850e2} nor @option{-mv850e2v3}\n are defined then a default target processor will be chosen and the\n relevant @samp{__v850*__} preprocessor constant will be defined.\n \n@@ -16978,7 +16991,7 @@ defined, regardless of which processor variant is the target.\n @item -mdisable-callt\n @opindex mdisable-callt\n This option will suppress generation of the CALLT instruction for the\n-v850e and v850e1 flavors of the v850 architecture.  The default is\n+v850e, v850e1, v850e2 and v850e2v3 flavors of the v850 architecture.  The default is\n @option{-mno-disable-callt} which allows the CALLT instruction to be used.\n \n @end table"}]}