{"sha": "1a8463c91b999952fed1e1e23652d55ade546ede", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWE4NDYzYzkxYjk5OTk1MmZlZDFlMWUyMzY1MmQ1NWFkZTU0NmVkZQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-07-29T20:19:33Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-07-29T20:19:33Z"}, "message": "(XCOFF_SCAN_LIBS): Define if OBJECT_FORMAT_COFF and XCOFF_DEBUGGING_FORMAT.\n\n(SCAN_LIBRARIES): Also define if XCOFF_SCAN_LIBS.\n(scan_libraries): Implement for AIX.\n\nFrom-SVN: r10207", "tree": {"sha": "748b3e13580398e68a29187c4530a137bc8291d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/748b3e13580398e68a29187c4530a137bc8291d0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1a8463c91b999952fed1e1e23652d55ade546ede", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a8463c91b999952fed1e1e23652d55ade546ede", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a8463c91b999952fed1e1e23652d55ade546ede", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a8463c91b999952fed1e1e23652d55ade546ede/comments", "author": null, "committer": null, "parents": [{"sha": "53fbaf5abfd0a8f6ad5f214e32e0c44b92727e12", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/53fbaf5abfd0a8f6ad5f214e32e0c44b92727e12", "html_url": "https://github.com/Rust-GCC/gccrs/commit/53fbaf5abfd0a8f6ad5f214e32e0c44b92727e12"}], "stats": {"total": 165, "additions": 164, "deletions": 1}, "files": [{"sha": "3d6df21f1250bf1be2b9c8a1937dddd95ab78d15", "filename": "gcc/collect2.c", "status": "modified", "additions": 164, "deletions": 1, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a8463c91b999952fed1e1e23652d55ade546ede/gcc%2Fcollect2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a8463c91b999952fed1e1e23652d55ade546ede/gcc%2Fcollect2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcollect2.c?ref=1a8463c91b999952fed1e1e23652d55ade546ede", "patch": "@@ -158,6 +158,10 @@ char *strerror();\n #define MY_ISCOFF(X) ISCOFF (X)\n #endif\n \n+#ifdef XCOFF_DEBUGGING_INFO\n+#define XCOFF_SCAN_LIBS\n+#endif\n+\n #endif /* OBJECT_FORMAT_COFF */\n \n #ifdef OBJECT_FORMAT_ROSE\n@@ -196,7 +200,7 @@ char *strerror();\n #define SYMBOL__MAIN __main\n #endif\n \n-#if defined (LDD_SUFFIX) || SUNOS4_SHARED_LIBRARIES\n+#if defined (LDD_SUFFIX) || SUNOS4_SHARED_LIBRARIES || defined(XCOFF_SCAN_LIBS)\n #define SCAN_LIBRARIES\n #endif\n \n@@ -2573,6 +2577,165 @@ scan_prog_file (prog_name, which_pass)\n   (void) ldclose(ldptr);\n }\n \n+#ifdef XCOFF_SCAN_LIBS\n+/* Scan imported AIX libraries for GCC static ctors and dtors.\n+   FIXME: it is possible to link an executable without the actual import\n+\t  library by using an \"import file\" - a text file listing symbols\n+\t  exported by a library.  To support this, we would have to scan\n+\t  import files as well as actual shared binaries to find GCC ctors.\n+   TODO: use memory mapping instead of 'ld' routines, files are already\n+\t memory mapped, but we could eliminate the extra in-memory copies.\n+\t Is it worth the effort?  */\n+\n+static void\n+scan_libraries (prog_name)\n+     char *prog_name;\n+{\n+  LDFILE *ldptr;\n+  SCNHDR ldsh;\n+  static struct path_prefix libpath; /* we should only do this once */\n+\n+  if ((ldptr = ldopen (prog_name, ldptr)) == NULL)\n+    fatal (\"%s: can't open as COFF file\", prog_name);\n+      \n+  if (!MY_ISCOFF (HEADER (ldptr).f_magic))\n+    fatal (\"%s: not a COFF file\", prog_name);\n+\n+  /* find and read loader section */\n+  if (ldnshread (ldptr, _LOADER, &ldsh))\n+    {\n+      LDHDR ldh;\n+      char *impbuf;\n+      int idx;\n+      FSEEK (ldptr, ldsh.s_scnptr, BEGINNING);\n+      FREAD (&ldh, sizeof ldh, 1, ldptr);\n+      /* read import library list */\n+      impbuf = alloca (ldh.l_istlen);\n+      FSEEK (ldptr, ldh.l_impoff + ldsh.s_scnptr, BEGINNING);\n+      FREAD (impbuf, ldh.l_istlen, 1, ldptr);\n+      idx = strlen (impbuf) + 1;\n+      idx += strlen (impbuf+idx) + 1;\n+      if (debug)\n+\tfprintf (stderr, \"LIBPATH=%s\\n\", impbuf);\n+      prefix_from_string (impbuf, &libpath);\n+      while (idx < ldh.l_istlen)\n+\t{\n+\t  char *implib = impbuf + idx;\n+\t  char *impmem = implib + strlen (implib) + 1;\n+\t  char *soname = 0;\n+\t  LDFILE *libptr = NULL;\n+\t  struct prefix_list *pl;\n+\t  ARCHDR ah;\n+\t  idx += strlen (implib) + 1;\n+\t  if (!implib[0])\n+\t    continue;\n+\t  idx += strlen (impmem) + 1;\n+\t  if (*implib == '/')\n+\t    {\n+\t      if (access (soname, R_OK) == 0)\n+\t\tsoname = implib;\n+\t    }\n+\t  else\n+\t    {\n+\t      char *temp = alloca (libpath.max_len + strlen (implib) + 1);\n+\t      for (pl = libpath.plist; pl; pl = pl->next)\n+\t\t{\n+\t\t  strcpy (temp, pl->prefix);\n+\t\t  strcat (temp, implib);\n+\t\t  if (access (temp, R_OK) == 0)\n+\t\t    {\n+\t\t      soname = temp;\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t  if (!soname)\n+\t    {\n+\t      fatal (\"%s: library not found\", implib);\n+\t      continue;\n+\t    }\n+\t  if (debug)\n+\t    {\n+\t      if (impmem[0])\n+\t\tfprintf (stderr, \"%s (%s)\\n\", soname, impmem);\n+\t      else\n+\t\tfprintf (stderr, \"%s\\n\", soname);\n+\t    }\n+\t  ah.ar_name[0] = 0;\n+\t  do\n+\t    {\n+\t      /* scan imported shared objects for GCC GLOBAL ctors */\n+\t      short type;\n+\t      if ((libptr = ldopen (soname, libptr)) == NULL)\n+\t\tfatal (\"%s: can't open import library\", soname);\n+\t      if (TYPE (libptr) == ARTYPE)\n+\t\t{\n+\t\t  LDFILE *memptr;\n+\t\t  if (!impmem[0])\n+\t\t    fatal (\"%s: no archive member specified\", soname);\n+\t\t  ldahread (libptr, &ah);\n+\t\t  if (strcmp (ah.ar_name, impmem))\n+\t\t    continue;\n+\t\t}\n+\t      type = HEADER (libptr).f_magic;\n+\t      if (HEADER (libptr).f_flags & F_SHROBJ)\n+\t\t{\n+\t\t  SCNHDR soldsh;\n+\t\t  LDHDR soldh;\n+\t\t  long symcnt, i;\n+\t\t  char *ldstrings;\n+\t\t  LDSYM *lsyms;\n+\t\t  if (!ldnshread (libptr, _LOADER, &soldsh))\n+\t\t    fatal (\"%s: not an import library\", soname);\n+\t\t  FSEEK (libptr, soldsh.s_scnptr, BEGINNING);\n+\t\t  if (FREAD (&soldh, sizeof soldh, 1, libptr) != 1)\n+\t\t    fatal (\"%s: can't read loader section\", soname);\n+\t\t  /*fprintf (stderr, \"\\tscanning %s\\n\", soname);*/\n+\t\t  symcnt = soldh.l_nsyms;\n+\t\t  lsyms = alloca (symcnt * sizeof *lsyms);\n+\t\t  symcnt = FREAD (lsyms, sizeof *lsyms, symcnt, libptr);\n+\t\t  ldstrings = alloca (soldh.l_stlen);\n+\t\t  FSEEK (libptr, soldsh.s_scnptr+soldh.l_stoff, BEGINNING);\n+\t\t  FREAD (ldstrings, soldh.l_stlen, 1, libptr);\n+\t\t  for (i = 0; i < symcnt; ++i)\n+\t\t    {\n+\t\t      LDSYM *l = lsyms + i;\n+\t\t      if (LDR_EXPORT (*l))\n+\t\t\t{\n+\t\t\t  char *expname = 0;\n+\t\t\t  if (l->l_zeroes)\n+\t\t\t    expname = l->l_name;\n+\t\t\t  else if (l->l_offset < soldh.l_stlen)\n+\t\t\t    expname = ldstrings + l->l_offset;\n+\t\t\t  switch (is_ctor_dtor (expname))\n+\t\t\t    {\n+\t\t\t    case 3:\n+\t\t\t      if (debug)\n+\t\t\t\tfprintf (stderr, \"\\t%s\\n\", expname);\n+\t\t\t      add_to_list (&constructors, expname);\n+\t\t\t      break;\n+\n+\t\t\t    case 4:\n+\t\t\t      add_to_list (&destructors, expname);\n+\t\t\t      break;\n+\n+\t\t\t    default: /* not a constructor or destructor */\n+\t\t\t      continue;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t      else\n+\t\tfprintf (stderr, \"%s: type = %04X flags = %04X\\n\", \n+\t\t\t ah.ar_name, type, HEADER (libptr).f_flags);\n+\t    }\n+\t  while (ldclose (libptr) == FAILURE);\n+\t  /* printf (stderr, \"closed %s\\n\", soname); */\n+\t}\n+    }\n+}\n+#endif /* XCOFF_SCAN_LIBS */\n+\n #endif /* OBJECT_FORMAT_COFF */\n \n \f"}]}